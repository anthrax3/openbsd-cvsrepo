head	1.45;
access;
symbols
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.45.0.4
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.4
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.42.0.6
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.40.0.8
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.6
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.39.0.6
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.35.0.8
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.4
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.27.0.4
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.15.0.6
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.4
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.45
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.44;
commitid	6vhYvh5CxZAHMnsN;

1.44
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.43;
commitid	t9FBKDfc4VDxpEy2;

1.43
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.42;
commitid	uzzBR7hz9ncd4O6G;

1.42
date	2013.12.28.03.30.41;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2013.06.25.02.27.44;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.38;

1.38
date	2009.08.02.10.38.34;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.31.11.38.26;	author blambert;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.22.23.51.43;	author sthen;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.34;

1.34
date	2008.05.13.01.40.39;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.17.17.34.22;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.10.22.36.18;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.30.09.36.21;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2006.12.28.09.24.27;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2006.12.15.21.47.27;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.06.21.46.18;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.26.04.40.09;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.07.15.01.24;	author mcbride;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.16.03.41.58;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.08.06.57.55;	author mcbride;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.18.16.15.33;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2004.10.09.02.17.03;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.09.02.06.56;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.27.18.25.48;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.26.00.59.58;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.03.19.05.56;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.28.00.28.43;	author mcbride;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.11.18.28.45;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.26.06.01.28;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.04.11.30.06;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.57;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.05.18.33.33;	author nate;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.06.25.20.24.13;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.08.02.16.41;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.03.12.31.43;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.12.19.32.43;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.28.05.24.05;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.26.20.04.17;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.30.01.02.33;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.12.07.22.01.31;	author jason;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.07.16.14.59.07;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.11.11.19.34.47;	author jason;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.25.24;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.07.04.10.41.42;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.10.31.03.22.44;	author nate;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2004.06.05.23.12.48;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.05.19.22.20.35;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@/*	$OpenBSD: mii_physubr.c,v 1.44 2014/12/05 15:50:04 mpi Exp $	*/
/*	$NetBSD: mii_physubr.c,v 1.20 2001/04/13 23:30:09 thorpej Exp $	*/

/*-
 * Copyright (c) 1998, 1999, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Subroutines common to all PHYs.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_media.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

/*
 * Media to register setting conversion table.  Order matters.
 * XXX 802.3 doesn't specify ANAR or ANLPAR bits for 1000base.
 */
const struct mii_media mii_media_table[] = {
	/* None */
	{ BMCR_ISO,		ANAR_CSMA,		0 },
	/* 10baseT */
	{ BMCR_S10,		ANAR_CSMA|ANAR_10,	0 },
	/* 10baseT-FDX */
	{ BMCR_S10|BMCR_FDX,	ANAR_CSMA|ANAR_10_FD,	0 },
	/* 100baseT4 */
	{ BMCR_S100,		ANAR_CSMA|ANAR_T4,	0 },
	/* 100baseTX */
	{ BMCR_S100,		ANAR_CSMA|ANAR_TX,	0 },
	/* 100baseTX-FDX */
	{ BMCR_S100|BMCR_FDX,	ANAR_CSMA|ANAR_TX_FD,	0 },
	/* 1000baseX */
	{ BMCR_S1000,		ANAR_CSMA,		0 },
	/* 1000baseX-FDX */
	{ BMCR_S1000|BMCR_FDX,	ANAR_CSMA,		0 },
	/* 1000baseT */
	{ BMCR_S1000,		ANAR_CSMA,		GTCR_ADV_1000THDX },
	/* 1000baseT-FDX */
	{ BMCR_S1000|BMCR_FDX,	ANAR_CSMA,		GTCR_ADV_1000TFDX },
};

void
mii_phy_setmedia(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int bmcr, anar, gtcr;

	if (IFM_SUBTYPE(ife->ifm_media) == IFM_AUTO) {
		if ((PHY_READ(sc, MII_BMCR) & BMCR_AUTOEN) == 0 ||
		    (sc->mii_flags & MIIF_FORCEANEG))
			(void) mii_phy_auto(sc, 1);
		return;
	}

	/*
	 * Table index is stored in the media entry.
	 */
#ifdef DIAGNOSTIC
	if (ife->ifm_data >= MII_NMEDIA)
		panic("mii_phy_setmedia");
#endif

	anar = mii_media_table[ife->ifm_data].mm_anar;
	bmcr = mii_media_table[ife->ifm_data].mm_bmcr;
	gtcr = mii_media_table[ife->ifm_data].mm_gtcr;

	if (mii->mii_media.ifm_media & IFM_ETH_MASTER) {
		switch (IFM_SUBTYPE(ife->ifm_media)) {
		case IFM_1000_T:
			gtcr |= GTCR_MAN_MS|GTCR_ADV_MS;
			break;

		default:
			panic("mii_phy_setmedia: MASTER on wrong media");
		}
	}

	if (ife->ifm_media & IFM_LOOP)
		bmcr |= BMCR_LOOP;

	PHY_WRITE(sc, MII_ANAR, anar);
	PHY_WRITE(sc, MII_BMCR, bmcr);
	if (sc->mii_flags & MIIF_HAVE_GTCR)
		PHY_WRITE(sc, MII_100T2CR, gtcr);
}

int
mii_phy_auto(struct mii_softc *sc, int waitfor)
{
	int bmsr, i;

	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		/*
		 * Check for 1000BASE-X.  Autonegotiation is a bit
		 * different on such devices.
		 */
		if (sc->mii_flags & MIIF_IS_1000X) {
			uint16_t anar = 0;

			if (sc->mii_extcapabilities & EXTSR_1000XFDX)
				anar |= ANAR_X_FD;
			if (sc->mii_extcapabilities & EXTSR_1000XHDX)
				anar |= ANAR_X_HD;

			if (sc->mii_flags & MIIF_DOPAUSE &&
			    sc->mii_extcapabilities & EXTSR_1000XFDX)
				anar |= ANAR_X_PAUSE_TOWARDS;

			PHY_WRITE(sc, MII_ANAR, anar);
		} else {
			uint16_t anar;

			anar = BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) |
			    ANAR_CSMA;
			/* 
			 * Most 100baseTX PHY's only support symmetric
			 * PAUSE, so we don't advertise asymmetric
			 * PAUSE unless we also have 1000baseT capability.
			 */
			if (sc->mii_flags & MIIF_DOPAUSE) {
				if (sc->mii_capabilities & BMSR_100TXFDX)
					anar |= ANAR_FC;
				if (sc->mii_extcapabilities & EXTSR_1000TFDX)
					anar |= ANAR_PAUSE_TOWARDS;
			}
			PHY_WRITE(sc, MII_ANAR, anar);
			if (sc->mii_flags & MIIF_HAVE_GTCR) {
				uint16_t gtcr = 0;

				if (sc->mii_extcapabilities & EXTSR_1000TFDX)
					gtcr |= GTCR_ADV_1000TFDX;
				if (sc->mii_extcapabilities & EXTSR_1000THDX)
					gtcr |= GTCR_ADV_1000THDX;

				PHY_WRITE(sc, MII_100T2CR, gtcr);
			}
		}
		PHY_WRITE(sc, MII_BMCR, BMCR_AUTOEN | BMCR_STARTNEG);
	}

	if (waitfor) {
		/* Wait 500ms for it to complete. */
		for (i = 0; i < 500; i++) {
			if ((bmsr = PHY_READ(sc, MII_BMSR)) & BMSR_ACOMP)
				return (0);
			delay(1000);
		}

		/*
		 * Don't need to worry about clearing MIIF_DOINGAUTO.
		 * If that's set, a timeout is pending, and it will
		 * clear the flag.
		 */
		return (EIO);
	}

	/*
	 * Just let it finish asynchronously.  This is for the benefit of
	 * the tick handler driving autonegotiation.  Don't want 500ms
	 * delays all the time while the system is running!
	 */
	if (sc->mii_flags & MIIF_AUTOTSLEEP) {
		sc->mii_flags |= MIIF_DOINGAUTO;
		tsleep(&sc->mii_flags, PZERO, "miiaut", hz >> 1);
		mii_phy_auto_timeout(sc);
	} else if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		sc->mii_flags |= MIIF_DOINGAUTO;
		timeout_set(&sc->mii_phy_timo, mii_phy_auto_timeout, sc);
		timeout_add_msec(&sc->mii_phy_timo, 500);
	}
	return (EJUSTRETURN);
}

void
mii_phy_auto_timeout(void *arg)
{
	struct mii_softc *sc = arg;
	int s, bmsr;

	if ((sc->mii_dev.dv_flags & DVF_ACTIVE) == 0)
		return;

	s = splnet();
	sc->mii_flags &= ~MIIF_DOINGAUTO;
	bmsr = PHY_READ(sc, MII_BMSR);

	/* Update the media status. */
	(void) PHY_SERVICE(sc, sc->mii_pdata, MII_POLLSTAT);
	splx(s);
}

int
mii_phy_tick(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int reg;

	/* Just bail now if the interface is down. */
	if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
		return (EJUSTRETURN);

	/*
	 * If we're not doing autonegotiation, we don't need to do
	 * any extra work here.  However, we need to check the link
	 * status so we can generate an announcement if the status
	 * changes.
	 */
	if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
		return (0);

	/* Read the status register twice; BMSR_LINK is latch-low. */
	reg = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
	if (reg & BMSR_LINK) {
		/*
		 * See above.
		 */
		return (0);
	}

	/*
	 * Only retry autonegotiation every mii_anegticks seconds.
	 */
	if (!sc->mii_anegticks)
		sc->mii_anegticks = MII_ANEGTICKS;

	if (++sc->mii_ticks <= sc->mii_anegticks)
		return (EJUSTRETURN);

	sc->mii_ticks = 0;
	PHY_RESET(sc);

	if (mii_phy_auto(sc, 0) == EJUSTRETURN)
		return (EJUSTRETURN);

	/*
	 * Might need to generate a status message if autonegotiation
	 * failed.
	 */
	return (0);
}

void
mii_phy_reset(struct mii_softc *sc)
{
	int reg, i;

	if (sc->mii_flags & MIIF_NOISOLATE)
		reg = BMCR_RESET;
	else
		reg = BMCR_RESET | BMCR_ISO;
	PHY_WRITE(sc, MII_BMCR, reg);

	/*
	 * It is best to allow a little time for the reset to settle
	 * in before we start polling the BMCR again.  Notably, the
	 * DP83840A manual states that there should be a 500us delay
	 * between asserting software reset and attempting MII serial
	 * operations.  Also, a DP83815 can get into a bad state on
	 * cable removal and reinsertion if we do not delay here.
	 */
	delay(500);

	/* Wait another 100ms for it to complete. */
	for (i = 0; i < 100; i++) {
		reg = PHY_READ(sc, MII_BMCR);
		if ((reg & BMCR_RESET) == 0)
			break;
		delay(1000);
	}

	if (sc->mii_inst != 0 && ((sc->mii_flags & MIIF_NOISOLATE) == 0))
		PHY_WRITE(sc, MII_BMCR, reg | BMCR_ISO);
}

void
mii_phy_down(struct mii_softc *sc)
{
	if (sc->mii_flags & MIIF_DOINGAUTO) {
		sc->mii_flags &= ~MIIF_DOINGAUTO;
		timeout_del(&sc->mii_phy_timo);
	}
}


void
mii_phy_status(struct mii_softc *sc)
{
	PHY_STATUS(sc);
}

void
mii_phy_update(struct mii_softc *sc, int cmd)
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifnet *ifp = mii->mii_ifp;
	int announce, s;

	if (sc->mii_media_active != mii->mii_media_active ||
	    sc->mii_media_status != mii->mii_media_status ||
	    cmd == MII_MEDIACHG) {
		announce = mii_phy_statusmsg(sc);
		(*mii->mii_statchg)(sc->mii_dev.dv_parent);
		sc->mii_media_active = mii->mii_media_active;
		sc->mii_media_status = mii->mii_media_status;

		if (announce) {
			s = splnet();
			if_link_state_change(ifp);
			splx(s);
		}
	}
}

int
mii_phy_statusmsg(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifnet *ifp = mii->mii_ifp;
	u_int64_t baudrate;
	int link_state, announce = 0;

	if (mii->mii_media_status & IFM_AVALID) {
		if (mii->mii_media_status & IFM_ACTIVE) {
			if (mii->mii_media_active & IFM_FDX)
				link_state = LINK_STATE_FULL_DUPLEX;
			else
				link_state = LINK_STATE_HALF_DUPLEX;
		} else
			link_state = LINK_STATE_DOWN;
	} else
		link_state = LINK_STATE_UNKNOWN;

	baudrate = ifmedia_baudrate(mii->mii_media_active);

	if (link_state != ifp->if_link_state) {
		ifp->if_link_state = link_state;
		/*
		 * XXX Right here we'd like to notify protocols
		 * XXX that the link status has changed, so that
		 * XXX e.g. Duplicate Address Detection can restart.
		 */
		announce = 1;
	}

	if (baudrate != ifp->if_baudrate) {
		ifp->if_baudrate = baudrate;
		announce = 1;
	}

	return (announce);
}

/*
 * Initialize generic PHY media based on BMSR, called when a PHY is
 * attached.
 */
void
mii_phy_add_media(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;

#define	ADD(m, c)	ifmedia_add(&mii->mii_media, (m), (c), NULL)

	if ((sc->mii_flags & MIIF_NOISOLATE) == 0)
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc->mii_inst),
		    MII_MEDIA_NONE);

	if (sc->mii_capabilities & BMSR_10THDX) {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, sc->mii_inst),
		    MII_MEDIA_10_T);
	}
	if (sc->mii_capabilities & BMSR_10TFDX) {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, sc->mii_inst),
		    MII_MEDIA_10_T_FDX);
	}
	if (sc->mii_capabilities & BMSR_100TXHDX) {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, sc->mii_inst),
		    MII_MEDIA_100_TX);
	}
	if (sc->mii_capabilities & BMSR_100TXFDX) {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, sc->mii_inst),
		    MII_MEDIA_100_TX_FDX);
	}
	if (sc->mii_capabilities & BMSR_100T4) {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, 0, sc->mii_inst),
		    MII_MEDIA_100_T4);
	}
	if (sc->mii_extcapabilities & EXTSR_MEDIAMASK) {
		/*
		 * XXX Right now only handle 1000SX and 1000TX.  Need
		 * XXX to handle 1000LX and 1000CX some how.
		 */
		if (sc->mii_extcapabilities & EXTSR_1000XHDX) {
			sc->mii_anegticks = MII_ANEGTICKS_GIGE;
			sc->mii_flags |= MIIF_IS_1000X;
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_SX, 0,
			    sc->mii_inst), MII_MEDIA_1000_X);
		}
		if (sc->mii_extcapabilities & EXTSR_1000XFDX) {
			sc->mii_anegticks = MII_ANEGTICKS_GIGE;
			sc->mii_flags |= MIIF_IS_1000X;
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_SX, IFM_FDX,
			    sc->mii_inst), MII_MEDIA_1000_X_FDX);
		}

		/*
		 * 1000baseT media needs to be able to manipulate
		 * master/slave mode.  We set IFM_ETH_MASTER in
		 * the "don't care mask" and filter it out when
		 * the media is set.
		 *
		 * All 1000baseT PHYs have a 1000baseT control register.
		 */
		if (sc->mii_extcapabilities & EXTSR_1000THDX) {
			sc->mii_anegticks = MII_ANEGTICKS_GIGE;
			sc->mii_flags |= MIIF_HAVE_GTCR;
			mii->mii_media.ifm_mask |= IFM_ETH_MASTER;
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0,
			    sc->mii_inst), MII_MEDIA_1000_T);
		}
		if (sc->mii_extcapabilities & EXTSR_1000TFDX) {
			sc->mii_anegticks = MII_ANEGTICKS_GIGE;
			sc->mii_flags |= MIIF_HAVE_GTCR;
			mii->mii_media.ifm_mask |= IFM_ETH_MASTER;
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX,
			    sc->mii_inst), MII_MEDIA_1000_T_FDX);
		}
	}

	if (sc->mii_capabilities & BMSR_ANEG) {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, sc->mii_inst),
		    MII_NMEDIA);	/* intentionally invalid index */
	}
#undef ADD
}

void
mii_phy_delete_media(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;

	ifmedia_delete_instance(&mii->mii_media, sc->mii_inst);
}

int
mii_phy_detach(struct device *self, int flags)
{
	struct mii_softc *sc = (void *) self;

	if (sc->mii_flags & MIIF_DOINGAUTO)
		timeout_del(&sc->mii_phy_timo);

	mii_phy_delete_media(sc);

	return (0);
}

const struct mii_phydesc *
mii_phy_match(const struct mii_attach_args *ma, const struct mii_phydesc *mpd)
{

	for (; mpd->mpd_name != NULL; mpd++) {
		if (MII_OUI(ma->mii_id1, ma->mii_id2) == mpd->mpd_oui &&
		    MII_MODEL(ma->mii_id2) == mpd->mpd_model)
			return (mpd);
	}
	return (NULL);
}

/*
 * Return the flow control status flag from MII_ANAR & MII_ANLPAR.
 */
uint64_t
mii_phy_flowstatus(struct mii_softc *sc)
{
	int anar, anlpar;

	if ((sc->mii_flags & MIIF_DOPAUSE) == 0)
		return (0);

	anar = PHY_READ(sc, MII_ANAR);
	anlpar = PHY_READ(sc, MII_ANLPAR);

	/* For 1000baseX, the bits are in a different location. */
	if (sc->mii_flags & MIIF_IS_1000X) {
		anar <<= 3;
		anlpar <<= 3;
	}

	if ((anar & ANAR_PAUSE_SYM) & (anlpar & ANLPAR_PAUSE_SYM))
		return (IFM_FLOW|IFM_ETH_TXPAUSE|IFM_ETH_RXPAUSE);

	if ((anar & ANAR_PAUSE_SYM) == 0) {
		if ((anar & ANAR_PAUSE_ASYM) &&
		    ((anlpar & ANLPAR_PAUSE_TOWARDS) == ANLPAR_PAUSE_TOWARDS))
			return (IFM_FLOW|IFM_ETH_TXPAUSE);
		else
			return (0);
	}

	if ((anar & ANAR_PAUSE_ASYM) == 0) {
		if (anlpar & ANLPAR_PAUSE_SYM)
			return (IFM_FLOW|IFM_ETH_TXPAUSE|IFM_ETH_RXPAUSE);
		else
			return (0);
	}

	switch ((anlpar & ANLPAR_PAUSE_TOWARDS)) {
	case ANLPAR_PAUSE_NONE:
		return (0);

	case ANLPAR_PAUSE_ASYM:
		return (IFM_FLOW|IFM_ETH_RXPAUSE);

	default:
		return (IFM_FLOW|IFM_ETH_RXPAUSE|IFM_ETH_TXPAUSE);
	}
	/* NOTREACHED */
}

/*
 * Given an ifmedia word, return the corresponding ANAR value.
 */
int
mii_anar(uint64_t media)
{
	int rv;

	switch (media & (IFM_TMASK|IFM_NMASK|IFM_FDX)) {
	case IFM_ETHER|IFM_10_T:
		rv = ANAR_10|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_10_T|IFM_FDX:
		rv = ANAR_10_FD|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_100_TX:
		rv = ANAR_TX|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_100_TX|IFM_FDX:
		rv = ANAR_TX_FD|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_100_T4:
		rv = ANAR_T4|ANAR_CSMA;
		break;
	default:
		rv = 0;
		break;
	}

	return (rv);
}
@


1.44
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.43 2014/09/14 14:17:25 jsg Exp $	*/
d512 1
a512 1
int
d564 1
a564 1
mii_anar(int media)
@


1.43
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.42 2013/12/28 03:30:41 deraadt Exp $	*/
d46 1
@


1.42
log
@mii drivers no longer need activate functions.  Repair of the PHY
configuration setting is done at resume time because all networks
drivers which were previously up, do an IFF_UP operation which
hits PHY_RESET.
This was in snapshots for about 2 weeks.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.41 2013/06/25 02:27:44 brad Exp $	*/
a43 1
#include <sys/proc.h>
@


1.41
log
@Remove unsigned comparison < 0.

Pointed out by LLVM.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.40 2011/07/03 15:47:16 matthew Exp $	*/
a481 14
}

int
mii_phy_activate(struct device *self, int act)
{
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		/* Nothing special to do. */
		break;
	}

	return (rv);
@


1.40
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.39 2009/10/13 19:33:16 pirofti Exp $	*/
d97 1
a97 1
	if (ife->ifm_data < 0 || ife->ifm_data >= MII_NMEDIA)
@


1.39
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.38 2009/08/02 10:38:34 miod Exp $	*/
a489 3
	case DVACT_ACTIVATE:
		break;

@


1.38
log
@Never return nonzero in a device activate method invoked with DVACT_ACTIVATE,
for this prevents it to be invoked with DVACT_DEACTIVATE later. This had
been sweeped some time ago already, but bad constructs crept in again.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.37 2009/07/31 11:38:26 blambert Exp $	*/
d485 1
a485 1
mii_phy_activate(struct device *self, enum devact act)
@


1.37
log
@timeout_add -> timeout_add_msec

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.36 2009/07/22 23:51:43 sthen Exp $	*/
a490 1
		rv = EOPNOTSUPP;
@


1.36
log
@comment fix from Brad; OpenBSD's mii_phy_add_media() does not print
the media names like NetBSD does.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.35 2008/06/26 05:42:16 ray Exp $	*/
d207 1
a207 1
		timeout_add(&sc->mii_phy_timo, hz / 2);
@


1.35
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.34 2008/05/13 01:40:39 brad Exp $	*/
d394 1
a394 2
 * attached.  We expect to be set up to print a comma-separated list
 * of media names.  Does not print a newline.
@


1.34
log
@Since Ethernet links can only be full duplex or half duplex the link
state reporting code in the MII layer / em(4) and vge(4) will never
fall back to the point of only reporting the link as being UP without
the duplex setting being reported, so simplify the code a bit here.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.33 2007/09/17 17:34:22 brad Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.33
log
@- Use a 64-bit int for the baudrate within the ifmedia_baudrate struct and
return a 64-bit int for ifmedia_baudrate().
- Fix consumers of ifmedia_baudrate() to deal with the change.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.32 2007/02/10 22:36:18 kettenis Exp $	*/
d372 1
a372 1
			else if (mii->mii_media_active & IFM_HDX)
a373 2
			else
				link_state = LINK_STATE_UP;
@


1.32
log
@Use right flow control autonegotiation bits for 1000baseX.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.31 2006/12/30 09:36:21 kettenis Exp $	*/
d365 2
a366 1
	int baudrate, link_state, announce = 0;
@


1.31
log
@Make mii_phy_auto() advertise flow control if MIIF_DOPAUSE is set.

ok jsg@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.30 2006/12/28 09:24:27 kettenis Exp $	*/
d169 1
a169 1
					anar |= ANAR_X_PAUSE_TOWARDS;
d550 7
a556 1
	if ((anar & ANAR_X_PAUSE_SYM) & (anlpar & ANLPAR_X_PAUSE_SYM))
d559 3
a561 4
	if ((anar & ANAR_X_PAUSE_SYM) == 0) {
		if ((anar & ANAR_X_PAUSE_ASYM) &&
		    ((anlpar &
		      ANLPAR_X_PAUSE_TOWARDS) == ANLPAR_X_PAUSE_TOWARDS))
d567 2
a568 2
	if ((anar & ANAR_X_PAUSE_ASYM) == 0) {
		if (anlpar & ANLPAR_X_PAUSE_SYM)
d574 2
a575 2
	switch ((anlpar & ANLPAR_X_PAUSE_TOWARDS)) {
	case ANLPAR_X_PAUSE_NONE:
d578 1
a578 1
	case ANLPAR_X_PAUSE_ASYM:
@


1.30
log
@Add function to detect flow control status.  From NetBSD.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.29 2006/12/15 21:47:27 reyk Exp $	*/
d150 4
d160 11
@


1.29
log
@use mii_media_active instead of mii_media_status to get the full
duplex state. this will actually enable duplex reporting for drivers
using the mii layer.

figured out by Moritz Grimm with sk(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.28 2006/11/28 19:21:15 reyk Exp $	*/
d519 46
@


1.28
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.27 2005/11/06 21:46:18 brad Exp $	*/
d354 1
a354 1
			if (mii->mii_media_status & IFM_FDX)
d356 1
a356 1
			else if (mii->mii_media_status & IFM_HDX)
@


1.27
log
@correctly track the falling edge of a media state change in mii_phy_tick().
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.26 2005/03/26 04:40:09 krw Exp $	*/
d353 8
a360 3
		if (mii->mii_media_status & IFM_ACTIVE)
			link_state = LINK_STATE_UP;
		else
@


1.26
log
@Cleanup. Use defines, standard names, consistant comparison operators, etc.
for auto negotiation ticks code. No functional change.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.25 2005/02/07 15:01:24 mcbride Exp $	*/
d257 1
a257 1
	if (++sc->mii_ticks != sc->mii_anegticks)
@


1.25
log
@Use new if_link_state_change() instead of sending route message and notifying
carp directly.

ok brad@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.24 2004/12/16 03:41:58 brad Exp $	*/
a85 2
void	mii_phy_auto_timeout(void *);

d252 1
a252 1
	 * Only retry autonegotiation every N seconds.
d255 1
a255 1
		sc->mii_anegticks = 5;
d419 1
a419 1
		 * XXX to hnalde 1000LX and 1000CX some how.
d422 1
a422 1
			sc->mii_anegticks = 10;
d428 1
a428 1
			sc->mii_anegticks = 10;
d443 1
a443 1
			sc->mii_anegticks = 10;
d450 1
a450 1
			sc->mii_anegticks = 10;
@


1.24
log
@Make sure ifp->if_baudrate is valid when the parent's statchg
callback is made.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.23 2004/12/08 06:57:55 mcbride Exp $	*/
a54 1
#include <net/route.h>
a58 7
#include "carp.h"
#if NCARP > 0
#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/ip_carp.h>
#endif

d341 1
a341 1
			rt_ifmsg(ifp);
a342 4
#if NCARP > 0
			if (ifp->if_carp)
				carp_carpdev_state(ifp);
#endif
@


1.23
log
@Check if_type in carp_carpdev_state() to make sure we're not
dealing with a carp interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.22 2004/11/18 16:15:33 brad Exp $	*/
d336 2
d342 1
a343 1
		mii_phy_statusmsg(sc);
d346 10
d359 1
a359 1
void
d364 1
a364 1
	int s, baudrate, link_state, announce = 0;
d391 1
a391 9
	if (announce) {
		s = splnet();
		rt_ifmsg(ifp);
		splx(s);
#if NCARP > 0
		if (ifp->if_carp)
			carp_carpdev_state(ifp);
#endif
	}
@


1.22
log
@add mii_phy_match() for table-driven lookup.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.21 2004/10/09 02:17:03 brad Exp $	*/
d385 1
a385 1
			carp_carpdev_state(ifp->if_carp);
@


1.21
log
@Allow a little time for the reset to settle in before we start polling
the BMCR again. The DP83840A manual states that there should be a 500us delay
between asserting software reset and attempting MII serial operations.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.20 2004/10/09 02:06:56 brad Exp $	*/
d512 12
@


1.20
log
@add master flag support for 1000baseT and autonegotiation support for 1000baseX.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.19 2004/09/27 18:25:48 brad Exp $	*/
d294 11
a304 1
	/* Wait 100ms for it to complete. */
@


1.19
log
@ANSI protos and some minor cleanup

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.18 2004/09/26 00:59:58 brad Exp $	*/
d101 1
a101 1
	int bmcr, anar;
d120 12
d138 2
d148 30
a177 2
		PHY_WRITE(sc, MII_ANAR,
		    BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA);
d423 1
d429 1
d433 9
d444 2
d451 2
@


1.18
log
@Restructure the PHY entry points to use a structure of
entry points instead of descrete function pointers, and
extend this to include a "reset" entry point. Make sure
any PHY-specific reset routine is always used.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.17 2004/08/03 19:05:56 brad Exp $	*/
d97 1
a97 2
mii_phy_setmedia(sc)
	struct mii_softc *sc;
d129 1
a129 3
mii_phy_auto(sc, waitfor)
	struct mii_softc *sc;
	int waitfor;
d173 1
a173 2
mii_phy_auto_timeout(arg)
	void *arg;
d191 1
a191 2
mii_phy_tick(sc)
	struct mii_softc *sc;
d242 1
a242 2
mii_phy_reset(sc)
	struct mii_softc *sc;
d265 1
a265 2
mii_phy_down(sc)
	struct mii_softc *sc;
d275 1
a275 2
mii_phy_status(sc)
	struct mii_softc *sc;
a276 1

d281 1
a281 3
mii_phy_update(sc, cmd)
	struct mii_softc *sc;
	int cmd;
d296 1
a296 2
mii_phy_statusmsg(sc)
	struct mii_softc *sc;
d344 1
a344 2
mii_phy_add_media(sc)
	struct mii_softc *sc;
d409 1
a409 2
mii_phy_delete_media(sc)
	struct mii_softc *sc;
d417 1
a417 3
mii_phy_activate(self, act)
	struct device *self;
	enum devact act;
d435 1
a435 3
mii_phy_detach(self, flags)
	struct device *self;
	int flags;
d451 1
a451 2
mii_anar(media)
	int media;
@


1.17
log
@Add a MIIF_FORCEANEG flag to be passed to mii_attach.  This forces an
autonegotiation to take place if IFM_AUTO is selected in mii_media_set.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.16 2004/04/28 00:28:43 mcbride Exp $	*/
d190 1
a190 1
	(void) (*sc->mii_service)(sc, sc->mii_pdata, MII_POLLSTAT);
d234 1
a234 1
	mii_phy_reset(sc);
d286 1
a286 1
	(*sc->mii_status)(sc);
@


1.16
log
@Make carp(4) aware of its physical interface:
- If the physical interface goes down or the link goes down,
  the carp interface goes down as well.
- We treat this like the preemption holdoff with pfsync.
  So if one of the carp interfaces is known to be bad (because the
  physical interface it's associated with is bad), all the other carp
  interfaces back off: they won't preempt, and their advskew goes to 240.

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.15 2003/03/11 18:28:45 jason Exp $	*/
d105 2
a106 1
		if ((PHY_READ(sc, MII_BMCR) & BMCR_AUTOEN) == 0)
@


1.15
log
@- Fill in the mm_gtcr column (not currently used)
- fill in the last few rows to avoid a crash on some devices
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.14 2002/11/26 06:01:28 nate Exp $	*/
d60 7
d342 4
@


1.14
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.13 2002/05/04 11:30:06 fgsch Exp $	*/
d65 20
a84 8
	{ BMCR_ISO,		ANAR_CSMA },		/* None */
	{ BMCR_S10,		ANAR_CSMA|ANAR_10 },	/* 10baseT */
	{ BMCR_S10|BMCR_FDX,	ANAR_CSMA|ANAR_10_FD },	/* 10baseT-FDX */
	{ BMCR_S100,		ANAR_CSMA|ANAR_T4 },	/* 100baseT4 */
	{ BMCR_S100,		ANAR_CSMA|ANAR_TX },	/* 100baseTX */
	{ BMCR_S100|BMCR_FDX,	ANAR_CSMA|ANAR_TX_FD },	/* 100baseTX-FDX */
	{ BMCR_S1000,		ANAR_CSMA },		/* 1000base */
	{ BMCR_S1000|BMCR_FDX,	ANAR_CSMA },		/* 1000base-FDX */
@


1.13
log
@some space and tab cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.12 2002/03/14 01:26:57 millert Exp $	*/
d380 1
a380 1
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_TX, 0,
d385 1
a385 1
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_TX, IFM_FDX,
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.11 2001/10/05 18:33:33 nate Exp $	*/
d209 1
a209 1
	
d240 1
a240 1
		reg = PHY_READ(sc, MII_BMCR); 
d389 1
a389 1
	
@


1.11
log
@Differentiate between 1000baseT and 1000baseX.
Add some support for gigabit control/status regs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.10 2001/06/25 20:24:13 nate Exp $	*/
d75 1
a75 1
void	mii_phy_auto_timeout __P((void *));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.11 2001/10/05 18:33:33 nate Exp $	*/
d75 1
a75 1
void	mii_phy_auto_timeout(void *);
d209 1
a209 1

d240 1
a240 1
		reg = PHY_READ(sc, MII_BMCR);
d389 1
a389 1

@


1.11.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 8
a72 20
	/* None */
	{ BMCR_ISO,		ANAR_CSMA,		0 },
	/* 10baseT */
	{ BMCR_S10,		ANAR_CSMA|ANAR_10,	0 },
	/* 10baseT-FDX */
	{ BMCR_S10|BMCR_FDX,	ANAR_CSMA|ANAR_10_FD,	0 },
	/* 100baseT4 */
	{ BMCR_S100,		ANAR_CSMA|ANAR_T4,	0 },
	/* 100baseTX */
	{ BMCR_S100,		ANAR_CSMA|ANAR_TX,	0 },
	/* 100baseTX-FDX */
	{ BMCR_S100|BMCR_FDX,	ANAR_CSMA|ANAR_TX_FD,	0 },
	/* 1000baseX */
	{ BMCR_S1000,		ANAR_CSMA,		0 },
	/* 1000baseX-FDX */
	{ BMCR_S1000|BMCR_FDX,	ANAR_CSMA,		0 },
	/* 1000baseT */
	{ BMCR_S1000,		ANAR_CSMA,		GTCR_ADV_1000THDX },
	/* 1000baseT-FDX */
	{ BMCR_S1000|BMCR_FDX,	ANAR_CSMA,		GTCR_ADV_1000TFDX },
d380 1
a380 1
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0,
d385 1
a385 1
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX,
@


1.10
log
@Change autonegotiation timeout for devices with a gigabit phy to 10s.  All
other devices default to 5 seconds. ok deraadt. from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.9 2001/06/08 02:16:41 nate Exp $	*/
d371 1
a371 1
			    sc->mii_inst), MII_MEDIA_1000);
d376 1
a376 1
			    sc->mii_inst), MII_MEDIA_1000_FDX);
d381 1
a381 1
			    sc->mii_inst), MII_MEDIA_1000);
d386 1
a386 1
			    sc->mii_inst), MII_MEDIA_1000_FDX);
@


1.9
log
@Add some general support info for gigabit phys
Fix some comments
Remove some dead code
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.8 2001/05/03 12:31:43 aaron Exp $	*/
d205 1
a205 1
	 * Only retry autonegotiation every 5 seconds.
d207 4
a210 1
	if (++sc->mii_ticks != 5)
d369 1
d374 1
d379 1
d384 1
@


1.8
log
@Add an MIIF_AUTOTSLEEP flag, needed by new aue(4) code. From NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: mii_physubr.c,v 1.7 2000/10/12 19:32:43 aaron Exp $	*/
/*	$NetBSD: mii_physubr.c,v 1.16 2000/03/15 20:34:43 thorpej Exp $	*/
d62 1
d66 2
a67 2
	{ 0,			ANAR_CSMA|ANAR_10 },	/* 10baseT */
	{ BMCR_FDX,		ANAR_CSMA|ANAR_10_FD },	/* 10baseT-FDX */
d71 2
a93 1

d317 1
a317 1
		s = splimp();	/* XXX Should be splnet() */
a342 5
#if 0
		if ((sc->mii_flags & MIIF_NOLOOP) == 0)
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_LOOP,
			    sc->mii_inst), MII_MEDIA_10_T);
#endif
a350 5
#if 0
		if ((sc->mii_flags & MIIF_NOLOOP) == 0)
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_LOOP,
			    sc->mii_inst), MII_MEDIA_100_TX);
#endif
a358 5
#if 0
		if ((sc->mii_flags & MIIF_NOLOOP) == 0)
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, IFM_LOOP,
			    sc->mii_inst), MII_MEDIA_100_T4);
#endif
d360 23
d432 33
@


1.7
log
@Don't mix usage of old and new timeout code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.6 2000/08/28 05:24:05 jason Exp $	*/
d51 1
d141 5
a145 1
	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
@


1.6
log
@hush
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.5 2000/08/26 20:04:17 nate Exp $	*/
d412 1
a412 1
		untimeout(mii_phy_auto_timeout, sc);
@


1.5
log
@sync mii code with netbsd
adds detach functionality for phys
some code cleanup

Nobody really had time to test all of this out, but theo said commit anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.4 2000/06/30 01:02:33 art Exp $	*/
a325 1
	const char *sep = "";
a327 1
#define	PRINT(s)	printf("%s%s", sep, s); sep = ", "
a340 1
		PRINT("10baseT");
a344 1
		PRINT("10baseT-FDX");
a353 1
		PRINT("100baseTX");
a357 1
		PRINT("100baseTX-FDX");
a366 1
		PRINT("100baseT4");
a370 1
		PRINT("auto");
a372 1
#undef PRINT
@


1.4
log
@Convert to new timeouts.
@
text
@d1 2
a2 2
/*	$OpenBSD: mii_physubr.c,v 1.3 1999/12/07 22:01:31 jason Exp $	*/
/*	$NetBSD: mii_physubr.c,v 1.2.6.1 1999/04/23 15:40:26 perry Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
d54 1
d68 1
a68 1
	{ BMCR_S100|BMCR_FDX,	ANAR_CSMA|ANAR_TX_FD }, /* 100baseTX-FDX */
d77 1
a77 1
	struct mii_data*mii = sc->mii_pdata;
d81 6
d107 3
a109 2
mii_phy_auto(mii, waitfor)
	struct mii_softc *mii;
d113 4
a116 4
	if ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {
		PHY_WRITE(mii, MII_ANAR,
		    BMSR_MEDIA_TO_ANAR(mii->mii_capabilities) | ANAR_CSMA);
		PHY_WRITE(mii, MII_BMCR, BMCR_AUTOEN | BMCR_STARTNEG);
d122 1
a122 1
			if ((bmsr = PHY_READ(mii, MII_BMSR)) & BMSR_ACOMP)
a124 5
#if 0
		if ((bmsr & BMSR_ACOMP) == 0)
			printf("%s: autonegotiation failed to complete\n",
			    mii->mii_dev.dv_xname);
#endif
d140 4
a143 4
	if ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {
		mii->mii_flags |= MIIF_DOINGAUTO;
		timeout_set(&mii->mii_phy_timo, mii_phy_auto_timeout, mii);
		timeout_add(&mii->mii_phy_timo, hz / 2);
d152 1
a152 1
	struct mii_softc *mii = arg;
d155 3
d159 2
a160 2
	mii->mii_flags &= ~MIIF_DOINGAUTO;
	bmsr = PHY_READ(mii, MII_BMSR);
d163 1
a163 1
	(void) (*mii->mii_service)(mii, mii->mii_pdata, MII_POLLSTAT);
d167 49
d217 2
a218 2
mii_phy_reset(mii)
	struct mii_softc *mii;
d222 1
a222 1
	if (mii->mii_flags & MIIF_NOISOLATE)
d226 1
a226 1
	PHY_WRITE(mii, MII_BMCR, reg);
d230 1
a230 1
		reg = PHY_READ(mii, MII_BMCR); 
d236 2
a237 2
	if (mii->mii_inst != 0 && ((mii->mii_flags & MIIF_NOISOLATE) == 0))
		PHY_WRITE(mii, MII_BMCR, reg | BMCR_ISO);
d239 1
d250 66
d322 1
a322 1
mii_add_media(sc)
d326 1
d329 1
d343 1
d345 1
a345 2

	if (sc->mii_capabilities & BMSR_10TFDX)
d348 2
d355 2
a356 2
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, IFM_LOOP,
			    sc->mii_inst), MII_MEDIA_100_T4);
d358 1
d360 1
a360 1
	if (sc->mii_capabilities & BMSR_100TXFDX)
d363 2
d373 1
d375 1
a375 1
	if (sc->mii_capabilities & BMSR_ANEG)
d378 2
d381 45
@


1.3
log
@Merge with NetBSD:
o move common support functions for phy drivers from mii.c to mii_physubr.c,
	so that they are not includes if no PHY is configured
o Clean up the code that adds media a little, and make media selection
	table-driven in preparation for some other changes to be made.
o Don't add any loopback versions of media, for now.
o Add mii_down(), which is used by MAC drivers to inform PHYs that the
	interface is now down.  PHYs use this to cancel pending asynchronous
	operations.
o Add OUI for Enable Semiconductor.
o New Driver for TDK TSC78Q2120 PHY
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.2 1999/07/16 14:59:07 jason Exp $	*/
d139 2
a140 1
		timeout(mii_phy_auto_timeout, mii, hz >> 1);
d190 1
a190 1
		untimeout(mii_phy_auto_timeout, sc);
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: mii_physubr.c,v 1.7 2000/10/12 19:32:43 aaron Exp $	*/
/*	$NetBSD: mii_physubr.c,v 1.16 2000/03/15 20:34:43 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2000 The NetBSD Foundation, Inc.
a53 1
#include <net/route.h>
d67 1
a67 1
	{ BMCR_S100|BMCR_FDX,	ANAR_CSMA|ANAR_TX_FD },	/* 100baseTX-FDX */
d76 1
a76 1
	struct mii_data *mii = sc->mii_pdata;
a79 6
	if (IFM_SUBTYPE(ife->ifm_media) == IFM_AUTO) {
		if ((PHY_READ(sc, MII_BMCR) & BMCR_AUTOEN) == 0)
			(void) mii_phy_auto(sc, 1);
		return;
	}

d100 2
a101 3
mii_phy_auto(sc, waitfor)
	struct mii_softc *sc;
	int waitfor;
d105 4
a108 4
	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		PHY_WRITE(sc, MII_ANAR,
		    BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA);
		PHY_WRITE(sc, MII_BMCR, BMCR_AUTOEN | BMCR_STARTNEG);
d114 1
a114 1
			if ((bmsr = PHY_READ(sc, MII_BMSR)) & BMSR_ACOMP)
d117 5
d137 3
a139 4
	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		sc->mii_flags |= MIIF_DOINGAUTO;
		timeout_set(&sc->mii_phy_timo, mii_phy_auto_timeout, sc);
		timeout_add(&sc->mii_phy_timo, hz / 2);
d148 1
a148 1
	struct mii_softc *sc = arg;
a150 3
	if ((sc->mii_dev.dv_flags & DVF_ACTIVE) == 0)
		return;

d152 2
a153 2
	sc->mii_flags &= ~MIIF_DOINGAUTO;
	bmsr = PHY_READ(sc, MII_BMSR);
d156 1
a156 1
	(void) (*sc->mii_service)(sc, sc->mii_pdata, MII_POLLSTAT);
a159 49
int
mii_phy_tick(sc)
	struct mii_softc *sc;
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int reg;

	/* Just bail now if the interface is down. */
	if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
		return (EJUSTRETURN);

	/*
	 * If we're not doing autonegotiation, we don't need to do
	 * any extra work here.  However, we need to check the link
	 * status so we can generate an announcement if the status
	 * changes.
	 */
	if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
		return (0);

	/* Read the status register twice; BMSR_LINK is latch-low. */
	reg = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
	if (reg & BMSR_LINK) {
		/*
		 * See above.
		 */
		return (0);
	}

	/*
	 * Only retry autonegotiation every 5 seconds.
	 */
	if (++sc->mii_ticks != 5)
		return (EJUSTRETURN);

	sc->mii_ticks = 0;
	mii_phy_reset(sc);

	if (mii_phy_auto(sc, 0) == EJUSTRETURN)
		return (EJUSTRETURN);

	/*
	 * Might need to generate a status message if autonegotiation
	 * failed.
	 */
	return (0);
}

d161 2
a162 2
mii_phy_reset(sc)
	struct mii_softc *sc;
d166 1
a166 1
	if (sc->mii_flags & MIIF_NOISOLATE)
d170 1
a170 1
	PHY_WRITE(sc, MII_BMCR, reg);
d174 1
a174 1
		reg = PHY_READ(sc, MII_BMCR); 
d180 2
a181 2
	if (sc->mii_inst != 0 && ((sc->mii_flags & MIIF_NOISOLATE) == 0))
		PHY_WRITE(sc, MII_BMCR, reg | BMCR_ISO);
a182 1

d189 1
a189 67
		timeout_del(&sc->mii_phy_timo);
	}
}


void
mii_phy_status(sc)
	struct mii_softc *sc;
{

	(*sc->mii_status)(sc);
}

void
mii_phy_update(sc, cmd)
	struct mii_softc *sc;
	int cmd;
{
	struct mii_data *mii = sc->mii_pdata;

	if (sc->mii_media_active != mii->mii_media_active ||
	    sc->mii_media_status != mii->mii_media_status ||
	    cmd == MII_MEDIACHG) {
		(*mii->mii_statchg)(sc->mii_dev.dv_parent);
		mii_phy_statusmsg(sc);
		sc->mii_media_active = mii->mii_media_active;
		sc->mii_media_status = mii->mii_media_status;
	}
}

void
mii_phy_statusmsg(sc)
	struct mii_softc *sc;
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifnet *ifp = mii->mii_ifp;
	int s, baudrate, link_state, announce = 0;

	if (mii->mii_media_status & IFM_AVALID) {
		if (mii->mii_media_status & IFM_ACTIVE)
			link_state = LINK_STATE_UP;
		else
			link_state = LINK_STATE_DOWN;
	} else
		link_state = LINK_STATE_UNKNOWN;

	baudrate = ifmedia_baudrate(mii->mii_media_active);

	if (link_state != ifp->if_link_state) {
		ifp->if_link_state = link_state;
		/*
		 * XXX Right here we'd like to notify protocols
		 * XXX that the link status has changed, so that
		 * XXX e.g. Duplicate Address Detection can restart.
		 */
		announce = 1;
	}

	if (baudrate != ifp->if_baudrate) {
		ifp->if_baudrate = baudrate;
		announce = 1;
	}

	if (announce) {
		s = splimp();	/* XXX Should be splnet() */
		rt_ifmsg(ifp);
		splx(s);
d199 1
a199 1
mii_phy_add_media(sc)
d219 2
a220 1
	if (sc->mii_capabilities & BMSR_10TFDX) {
a222 1
	}
d228 2
a229 2
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_LOOP,
			    sc->mii_inst), MII_MEDIA_100_TX);
d232 1
a232 1
	if (sc->mii_capabilities & BMSR_100TXFDX) {
a234 1
	}
d244 1
a244 1
	if (sc->mii_capabilities & BMSR_ANEG) {
a246 1
	}
a247 44
}

void
mii_phy_delete_media(sc)
	struct mii_softc *sc;
{
	struct mii_data *mii = sc->mii_pdata;

	ifmedia_delete_instance(&mii->mii_media, sc->mii_inst);
}

int
mii_phy_activate(self, act)
	struct device *self;
	enum devact act;
{
	int rv = 0;

	switch (act) {
	case DVACT_ACTIVATE:
		rv = EOPNOTSUPP;
		break;

	case DVACT_DEACTIVATE:
		/* Nothing special to do. */
		break;
	}

	return (rv);
}

int
mii_phy_detach(self, flags)
	struct device *self;
	int flags;
{
	struct mii_softc *sc = (void *) self;

	if (sc->mii_flags & MIIF_DOINGAUTO)
		timeout_del(&sc->mii_phy_timo);

	mii_phy_delete_media(sc);

	return (0);
@


1.3.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mii_physubr.c,v 1.20 2001/04/13 23:30:09 thorpej Exp $	*/
a50 1
#include <sys/proc.h>
a60 1
 * XXX 802.3 doesn't specify ANAR or ANLPAR bits for 1000base.
d64 2
a65 2
	{ BMCR_S10,		ANAR_CSMA|ANAR_10 },	/* 10baseT */
	{ BMCR_S10|BMCR_FDX,	ANAR_CSMA|ANAR_10_FD },	/* 10baseT-FDX */
a68 2
	{ BMCR_S1000,		ANAR_CSMA },		/* 1000base */
	{ BMCR_S1000|BMCR_FDX,	ANAR_CSMA },		/* 1000base-FDX */
d90 1
d140 1
a140 5
	if (sc->mii_flags & MIIF_AUTOTSLEEP) {
		sc->mii_flags |= MIIF_DOINGAUTO;
		tsleep(&sc->mii_flags, PZERO, "miiaut", hz >> 1);
		mii_phy_auto_timeout(sc);
	} else if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
d198 1
a198 1
	 * Only retry autonegotiation every N seconds.
d200 1
a200 4
	if (!sc->mii_anegticks)
		sc->mii_anegticks = 5;
	
	if (++sc->mii_ticks != sc->mii_anegticks)
d310 1
a310 1
		s = splnet();
d336 5
d349 5
d362 5
a367 27
	if (sc->mii_extcapabilities & EXTSR_MEDIAMASK) {
		/*
		 * XXX Right now only handle 1000SX and 1000TX.  Need
		 * XXX to hnalde 1000LX and 1000CX some how.
		 */
		if (sc->mii_extcapabilities & EXTSR_1000XHDX) {
			sc->mii_anegticks = 10;
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_SX, 0,
			    sc->mii_inst), MII_MEDIA_1000);
		}
		if (sc->mii_extcapabilities & EXTSR_1000XFDX) {
			sc->mii_anegticks = 10;
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_SX, IFM_FDX,
			    sc->mii_inst), MII_MEDIA_1000_FDX);
		}
		if (sc->mii_extcapabilities & EXTSR_1000THDX) {
			sc->mii_anegticks = 10;
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_TX, 0,
			    sc->mii_inst), MII_MEDIA_1000);
		}
		if (sc->mii_extcapabilities & EXTSR_1000TFDX) {
			sc->mii_anegticks = 10;
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_TX, IFM_FDX,
			    sc->mii_inst), MII_MEDIA_1000_FDX);
		}
	}
	
a416 33
}

/*
 * Given an ifmedia word, return the corresponding ANAR value.
 */
int
mii_anar(media)
	int media;
{
	int rv;

	switch (media & (IFM_TMASK|IFM_NMASK|IFM_FDX)) {
	case IFM_ETHER|IFM_10_T:
		rv = ANAR_10|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_10_T|IFM_FDX:
		rv = ANAR_10_FD|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_100_TX:
		rv = ANAR_TX|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_100_TX|IFM_FDX:
		rv = ANAR_TX_FD|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_100_T4:
		rv = ANAR_T4|ANAR_CSMA;
		break;
	default:
		rv = 0;
		break;
	}

	return (rv);
@


1.3.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.3.2.2 2001/07/04 10:41:42 niklas Exp $	*/
d371 1
a371 1
			    sc->mii_inst), MII_MEDIA_1000_X);
d376 1
a376 1
			    sc->mii_inst), MII_MEDIA_1000_X_FDX);
d381 1
a381 1
			    sc->mii_inst), MII_MEDIA_1000_T);
d386 1
a386 1
			    sc->mii_inst), MII_MEDIA_1000_T_FDX);
@


1.3.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 1
a75 1
void	mii_phy_auto_timeout(void *);
@


1.3.2.5
log
@Sync the SMP branch with 3.3
@
text
@d65 8
a72 20
	/* None */
	{ BMCR_ISO,		ANAR_CSMA,		0 },
	/* 10baseT */
	{ BMCR_S10,		ANAR_CSMA|ANAR_10,	0 },
	/* 10baseT-FDX */
	{ BMCR_S10|BMCR_FDX,	ANAR_CSMA|ANAR_10_FD,	0 },
	/* 100baseT4 */
	{ BMCR_S100,		ANAR_CSMA|ANAR_T4,	0 },
	/* 100baseTX */
	{ BMCR_S100,		ANAR_CSMA|ANAR_TX,	0 },
	/* 100baseTX-FDX */
	{ BMCR_S100|BMCR_FDX,	ANAR_CSMA|ANAR_TX_FD,	0 },
	/* 1000baseX */
	{ BMCR_S1000,		ANAR_CSMA,		0 },
	/* 1000baseX-FDX */
	{ BMCR_S1000|BMCR_FDX,	ANAR_CSMA,		0 },
	/* 1000baseT */
	{ BMCR_S1000,		ANAR_CSMA,		GTCR_ADV_1000THDX },
	/* 1000baseT-FDX */
	{ BMCR_S1000|BMCR_FDX,	ANAR_CSMA,		GTCR_ADV_1000TFDX },
d209 1
a209 1

d240 1
a240 1
		reg = PHY_READ(sc, MII_BMCR);
d380 1
a380 1
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0,
d385 1
a385 1
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX,
d389 1
a389 1

@


1.3.2.6
log
@Merge with the trunk
@
text
@a59 7
#include "carp.h"
#if NCARP > 0
#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/ip_carp.h>
#endif

a334 4
#if NCARP > 0
		if (ifp->if_carp)
			carp_carpdev_state(ifp->if_carp);
#endif
@


1.2
log
@Sync with NetBSD:
o Implement asynchronous autonegotiation when driven by the MII tick
  (one-second clock).  Prevents .5s delays every 5 seconds when the interface
  is up but there is no link.
o Correct the sense of the PCR_FLINK100 bit in nsphy.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii_physubr.c,v 1.1 1998/11/11 19:34:47 jason Exp $	*/
d58 12
d72 27
a153 5
#if 0
	if ((bmsr & BMSR_ACOMP) == 0)
		printf("%s: autonegotiation failed to complete\n",
		    sc->sc_dev.dv_xname);
#endif
d182 66
@


1.1
log
@Merge with NetBSD:
o additional phy drivers (seeq, ics, level1)
o "unknown phy" driver for unsupported phys
o collected common code into mii_physubr
o exphy isn't the only phy that doesn't have valid id registers
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mii_physubr.c,v 1.2 1998/11/04 23:28:15 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d48 1
d50 1
d58 2
d61 1
a61 1
mii_phy_auto(mii)
d66 25
a90 9
	PHY_WRITE(mii, MII_ANAR,
	    BMSR_MEDIA_TO_ANAR(mii->mii_capabilities) | ANAR_CSMA);
	PHY_WRITE(mii, MII_BMCR, BMCR_AUTOEN | BMCR_STARTNEG);

	/* Wait 500ms for it to complete. */
	for (i = 0; i < 500; i++) {
		if ((bmsr = PHY_READ(mii, MII_BMSR)) & BMSR_ACOMP)
			return (1);
		delay(1000);
d92 23
d118 1
a118 1
		    mii->mii_dev.dv_xname);
d120 4
a123 1
	return (0);
@

