head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.8
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.6
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.21.0.4
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.18
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.16
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.14
	OPENBSD_5_0:1.18.0.12
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.10
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.8
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.4
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.8
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SMP:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.23
date	2015.07.19.06.28.12;	author yuo;	state Exp;
branches;
next	1.22;
commitid	vzHDNxGG1slGlZhk;

1.22
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.21;
commitid	p4LJxGKbi0BU2cG6;

1.21
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.20;
commitid	t9FBKDfc4VDxpEy2;

1.20
date	2013.12.28.03.30.41;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.28.09.46.06;	author mikeb;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.17.07.19.19;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.31.15.04.33;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.07.23.44.51;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.05.16.56.56;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.19.19.30.14;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.19.17.08.14;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.26.04.40.09;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.19.06.00.04;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.28.18.27.55;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.27.18.25.48;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.26.00.59.58;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.20.06.05.27;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.04.11.30.06;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.05.18.26.48;	author nate;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.08.19.15.07.34;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.29.19.00.36;	author jason;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	2000.08.28.13.40.23;	author jason;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.22.25.28;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.10.31.03.22.44;	author nate;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@use standardized register definition in mii.h rather than each
specific driver definition.

no logical change.

ok deraadt@@
@
text
@/*	$OpenBSD: xmphy.c,v 1.22 2015/03/14 03:38:48 jsg Exp $	*/

/*
 * Copyright (c) 2000
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/mii/xmphy.c,v 1.1 2000/04/22 01:58:18 wpaul Exp $
 */

/*
 * driver for the XaQti XMAC II's internal PHY. This is sort of
 * like a 10/100 PHY, except the only thing we're really autoselecting
 * here is full/half duplex. Speed is always 1000mbps.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_media.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <dev/mii/xmphyreg.h>

int xmphy_probe(struct device *, void *, void *);
void xmphy_attach(struct device *, struct device *, void *);

struct cfattach xmphy_ca = {
	sizeof(struct mii_softc), xmphy_probe, xmphy_attach, mii_phy_detach
};

struct cfdriver xmphy_cd = {
	NULL, "xmphy", DV_DULL
};

int	xmphy_service(struct mii_softc *, struct mii_data *, int);
void	xmphy_status(struct mii_softc *);

int	xmphy_mii_phy_auto(struct mii_softc *);

const struct mii_phy_funcs xmphy_funcs = {
	xmphy_service, xmphy_status, mii_phy_reset,
};

static const struct mii_phydesc xmphys[] = {
	{ MII_OUI_xxXAQTI,	MII_MODEL_XAQTI_XMACII,
	  MII_STR_XAQTI_XMACII },

	{ MII_OUI_JATO,		MII_MODEL_JATO_BASEX,
	  MII_STR_JATO_BASEX },

	{ 0,			0,
	  NULL },
};

int xmphy_probe(struct device *parent, void *match, void *aux)
{
	struct mii_attach_args *ma = aux;

	if (mii_phy_match(ma, xmphys) != NULL)
		return (10);

	return (0);
}

void
xmphy_attach(struct device *parent, struct device *self, void *aux)
{
	struct mii_softc *sc = (struct mii_softc *)self;
	struct mii_attach_args *ma = aux;
	struct mii_data *mii = ma->mii_data;
	const struct mii_phydesc *mpd;

	mpd = mii_phy_match(ma, xmphys);
	printf(": %s, rev. %d\n", mpd->mpd_name, MII_REV(ma->mii_id2));

	sc->mii_inst = mii->mii_instance;
	sc->mii_phy = ma->mii_phyno;
	sc->mii_funcs = &xmphy_funcs;
	sc->mii_pdata = mii;
	sc->mii_flags = ma->mii_flags;
	sc->mii_anegticks = MII_ANEGTICKS;

	sc->mii_flags |= MIIF_NOISOLATE;

#define	ADD(m, c)	ifmedia_add(&mii->mii_media, (m), (c), NULL)

	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc->mii_inst),
	    BMCR_ISO);

	PHY_RESET(sc);

	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_SX, 0, sc->mii_inst),
	    BMCR_FDX);
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_SX, IFM_FDX, sc->mii_inst), 0);
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, sc->mii_inst), 0);

#undef ADD
}

int
xmphy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
{
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int reg;

	if ((sc->mii_dev.dv_flags & DVF_ACTIVE) == 0)
		return (ENXIO);

	switch (cmd) {
	case MII_POLLSTAT:
		/*
		 * If we're not polling our PHY instance, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);
		break;

	case MII_MEDIACHG:
		/*
		 * If the media indicates a different PHY instance,
		 * isolate ourselves.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst) {
			reg = PHY_READ(sc, MII_BMCR);
			PHY_WRITE(sc, MII_BMCR, reg | BMCR_ISO);
			return (0);
		}

		/*
		 * If the interface is not up, don't do anything.
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			break;

		switch (IFM_SUBTYPE(ife->ifm_media)) {
		case IFM_AUTO:
			(void) xmphy_mii_phy_auto(sc);
			break;
		case IFM_1000_SX:
			PHY_RESET(sc);
			if ((ife->ifm_media & IFM_GMASK) == IFM_FDX) {
				PHY_WRITE(sc, MII_ANAR, ANAR_10_FD);
				PHY_WRITE(sc, MII_BMCR, BMCR_FDX);
			} else {
				PHY_WRITE(sc, MII_ANAR, ANAR_10);
				PHY_WRITE(sc, MII_BMCR, 0);
			}
			break;
		default:
			return (EINVAL);
		}
		break;

	case MII_TICK:
		/*
		 * If we're not currently selected, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);

		/*
		 * Is the interface even up?
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			return (0);

		/*
		 * Only used for autonegotiation.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			break;

                /*
                 * Check to see if we have link.  If we do, we don't
                 * need to restart the autonegotiation process.  Read
                 * the BMSR twice in case it's latched.
                 */
		reg = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
		if (reg & BMSR_LINK) {
			sc->mii_ticks = 0;
			break;
		}

		/*
		 * Only retry autonegotiation every mii_anegticks seconds.
		 */
		if (++sc->mii_ticks <= sc->mii_anegticks)
			break;

		sc->mii_ticks = 0;
		PHY_RESET(sc);

		xmphy_mii_phy_auto(sc);
		break;
	}

	/* Update the media status. */
	mii_phy_status(sc);

	/* Callback if something changed. */
	mii_phy_update(sc, cmd);
	return (0);
}

void
xmphy_status(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	int bmsr, bmcr, anlpar;

	mii->mii_media_status = IFM_AVALID;
	mii->mii_media_active = IFM_ETHER;

	bmsr = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
	if (bmsr & BMSR_LINK)
		mii->mii_media_status |= IFM_ACTIVE;

	/* Do dummy read of extended status register. */
	bmcr = PHY_READ(sc, MII_EXTSR);

	bmcr = PHY_READ(sc, MII_BMCR);

	if (bmcr & BMCR_LOOP)
		mii->mii_media_active |= IFM_LOOP;


	if (bmcr & BMCR_AUTOEN) {
		if ((bmsr & BMSR_ACOMP) == 0) {
			if (bmsr & BMSR_LINK) {
				mii->mii_media_active |= IFM_1000_SX|IFM_HDX;
				return;
			}
			/* Erg, still trying, I guess... */
			mii->mii_media_active |= IFM_NONE;
			return;
		}

		mii->mii_media_active |= IFM_1000_SX;
		anlpar = PHY_READ(sc, MII_ANAR) & PHY_READ(sc, MII_ANLPAR);
		if (anlpar & ANLPAR_10_FD)
			mii->mii_media_active |= IFM_FDX;
		else
			mii->mii_media_active |= IFM_HDX;
		return;
	}

	mii->mii_media_active |= IFM_1000_SX;
	if (bmcr & BMCR_FDX)
		mii->mii_media_active |= IFM_FDX;
	else
		mii->mii_media_active |= IFM_HDX;

	return;
}


int
xmphy_mii_phy_auto(struct mii_softc *sc)
{
	int anar = 0;

	anar = PHY_READ(sc, MII_ANAR);
	anar |= ANAR_10_FD|ANAR_10;
	PHY_WRITE(sc, MII_ANAR, anar);
	DELAY(1000);
	PHY_WRITE(sc, MII_BMCR, BMCR_AUTOEN | BMCR_STARTNEG);

	return (EJUSTRETURN);
}
@


1.22
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.21 2014/12/05 15:50:04 mpi Exp $	*/
d128 1
a128 1
	    XMPHY_BMCR_FDX);
d177 2
a178 2
				PHY_WRITE(sc, XMPHY_MII_ANAR, XMPHY_ANAR_FDX);
				PHY_WRITE(sc, XMPHY_MII_BMCR, XMPHY_BMCR_FDX);
d180 2
a181 2
				PHY_WRITE(sc, XMPHY_MII_ANAR, XMPHY_ANAR_HDX);
				PHY_WRITE(sc, XMPHY_MII_BMCR, 0);
d249 2
a250 3
	bmsr = PHY_READ(sc, XMPHY_MII_BMSR) |
	    PHY_READ(sc, XMPHY_MII_BMSR);
	if (bmsr & XMPHY_BMSR_LINK)
d254 1
a254 1
	bmcr = PHY_READ(sc, XMPHY_MII_EXTSTS);
d256 1
a256 1
	bmcr = PHY_READ(sc, XMPHY_MII_BMCR);
d258 1
a258 1
	if (bmcr & XMPHY_BMCR_LOOP)
d262 3
a264 3
	if (bmcr & XMPHY_BMCR_AUTOEN) {
		if ((bmsr & XMPHY_BMSR_ACOMP) == 0) {
			if (bmsr & XMPHY_BMSR_LINK) {
d274 2
a275 3
		anlpar = PHY_READ(sc, XMPHY_MII_ANAR) &
		    PHY_READ(sc, XMPHY_MII_ANLPAR);
		if (anlpar & XMPHY_ANLPAR_FDX)
d283 1
a283 1
	if (bmcr & XMPHY_BMCR_FDX)
d297 3
a299 3
	anar = PHY_READ(sc, XMPHY_MII_ANAR);
	anar |= XMPHY_ANAR_FDX|XMPHY_ANAR_HDX;
	PHY_WRITE(sc, XMPHY_MII_ANAR, anar);
d301 1
a301 2
	PHY_WRITE(sc, XMPHY_MII_BMCR,
	    XMPHY_BMCR_AUTOEN | XMPHY_BMCR_STARTNEG);
@


1.21
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.20 2013/12/28 03:30:41 deraadt Exp $	*/
a44 1
#include <sys/kernel.h>
@


1.20
log
@mii drivers no longer need activate functions.  Repair of the PHY
configuration setting is done at resume time because all networks
drivers which were previously up, do an IFF_UP operation which
hits PHY_RESET.
This was in snapshots for about 2 weeks.
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.19 2013/05/28 09:46:06 mikeb Exp $	*/
d51 1
@


1.19
log
@Fix a common issue across different PHY drivers to reset the
autonegotiation timer when PHY gets the link so that if we
restart the timer the mii_ticks value would be sane.

Lifted originally from FreeBSD, tested by a few on re(4) and
bge(4), ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.18 2008/09/17 07:19:19 brad Exp $	*/
d63 1
a63 2
	sizeof(struct mii_softc), xmphy_probe, xmphy_attach, mii_phy_detach,
	    mii_phy_activate
@


1.18
log
@Remove the unsupported media types explicitly listed in the switch cases
for MII_MEDIACHG. The default case will catch these media types.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.17 2006/12/31 15:04:33 krw Exp $	*/
d215 2
a216 1
		if (reg & BMSR_LINK)
d218 1
@


1.17
log
@Bring last few phys into line by calling their XXX_status() functions
through mii_phy_status() rather than directly. No functional change.

from brad@@ ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.16 2006/10/07 23:44:51 brad Exp $	*/
a184 3
		case IFM_100_T4:
		case IFM_100_TX:
		case IFM_10_T:
@


1.16
log
@g/c unused code.
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.15 2006/08/05 16:56:56 brad Exp $	*/
d235 1
a235 1
	xmphy_status(sc);
@


1.15
log
@Simplify autoneg code. Tested with a fibre sk and lge.
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.14 2005/06/19 19:30:14 brad Exp $	*/
a172 7
#ifdef foo
			/*
			 * If we're already in auto mode, just return.
			 */
			if (PHY_READ(sc, XMPHY_MII_BMCR) & XMPHY_BMCR_AUTOEN)
				return (0);
#endif
@


1.14
log
@- some clean up
- for consistency fix order of operations for MII_TICK switch case in eephy
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.13 2005/06/19 17:08:14 brad Exp $	*/
d74 1
a74 1
int	xmphy_mii_phy_auto(struct mii_softc *, int);
d180 1
a180 1
			(void) xmphy_mii_phy_auto(sc, 1);
d237 1
a237 3
		if (xmphy_mii_phy_auto(sc, 0) == EJUSTRETURN)
			return (0);

d304 1
a304 1
xmphy_mii_phy_auto(struct mii_softc *sc, int waitfor)
d306 1
a306 24
	int bmsr, anar = 0, i;

	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		anar = PHY_READ(sc, XMPHY_MII_ANAR);
		anar |= XMPHY_ANAR_FDX|XMPHY_ANAR_HDX;
		PHY_WRITE(sc, XMPHY_MII_ANAR, anar);
		DELAY(1000);
		PHY_WRITE(sc, XMPHY_MII_BMCR,
		    XMPHY_BMCR_AUTOEN | XMPHY_BMCR_STARTNEG);
	}

	if (waitfor) {
		/* Wait 500ms for it to complete. */
		for (i = 0; i < 500; i++) {
			if ((bmsr = PHY_READ(sc, XMPHY_MII_BMSR)) &
			    XMPHY_BMSR_ACOMP)
				return (0);
			DELAY(1000);
#if 0
		if ((bmsr & BMSR_ACOMP) == 0)
			printf("%s: autonegotiation failed to complete\n",
			    mii->mii_dev.dv_xname);
#endif
		}
d308 6
a313 7
		/*
		 * Don't need to worry about clearing MIIF_DOINGAUTO.
		 * If that's set, a timeout is pending, and it will
		 * clear the flag.
		 */
		return (EIO);
	}
a314 10
	/*
	 * Just let it finish asynchronously.  This is for the benefit of
	 * the tick handler driving autonegotiation.  Don't want 500ms
	 * delays all the time while the system is running!
	 */
	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		sc->mii_flags |= MIIF_DOINGAUTO;
		timeout_set(&sc->mii_phy_timo, mii_phy_auto_timeout, sc);
		timeout_add(&sc->mii_phy_timo, hz >> 1);
	}
@


1.13
log
@rev 1.4

Tweak the xmphy driver a little bit based on something I learned about
the built-in 1000baseX interface in the Level 1 LXT1001 chip. The Level 1
PHY comes up with the isolate bit in the control register set by default,
but it also has the autonegotiate bit set. When you tell the xmphy driver
to select IFM_AUTO mode, it sees that the autoneg bit is already on, and
thus doesn't bother updating the control register. However this means that
the isolate bit is never turned off (unless you manually select 1000baseSX
full or half duplex mode, which does result in the control register being
modified and the ISO bit being turned off).

This subtle and unusual behavioral difference stopped me from being able
to receive packets on the SMC9462TX card for several days, since isolating
the PHY disconnects it from the MAC's data interface. The fix is to omit
the 'is the autoneg big set?' test, since it doesn't really provide much
of an optimization anyway.

This commit also updates the xmphy driver to support the Jato/Level 1
internal PHY. (I'm not sure how Jato Technologies is related to Level 1:
all I know is the OUI from the PHY ID registers maps to Jato in the OUI
database.)

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.12 2005/03/26 04:40:09 krw Exp $	*/
a234 1

d239 1
@


1.12
log
@Cleanup. Use defines, standard names, consistant comparison operators, etc.
for auto negotiation ticks code. No functional change.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.11 2005/02/19 06:00:04 brad Exp $	*/
d84 3
d96 1
a96 1
		return(10);
d98 1
a98 1
	return(0);
d173 1
d179 1
a207 6
		 * Only used for autonegotiation.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			return (0);

		/*
d214 1
a214 1
	 	 * Only retry autonegotiation every mii_anegticks seconds.
d216 2
a217 2
		if (++sc->mii_ticks <= sc->mii_anegticks)
			return (0);
d219 8
a226 1
		sc->mii_ticks = 0;
d229 1
a229 3
		 * Check to see if we have link.  If we do, we don't
		 * need to restart the autonegotiation process.  Read
		 * the BMSR twice in case it's latched.
d231 1
a231 3
		reg = PHY_READ(sc, XMPHY_MII_BMSR) |
		    PHY_READ(sc, XMPHY_MII_BMSR);
		if (reg & XMPHY_BMSR_LINK)
d234 2
d237 1
d239 1
a239 1
			return(0);
d308 1
a308 1
	int bmsr, i;
d311 4
a314 2
		PHY_WRITE(sc, XMPHY_MII_ANAR,
		    XMPHY_ANAR_FDX|XMPHY_ANAR_HDX);
@


1.11
log
@use mii_phy_match()
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.10 2005/01/28 18:27:55 brad Exp $	*/
a74 1
extern void	mii_phy_auto_timeout(void *);
d114 1
a114 1
	sc->mii_anegticks = 5;
d215 1
a215 1
		 * Only retry autonegotiation every 5 seconds.
d217 1
a217 1
		if (++sc->mii_ticks != sc->mii_anegticks)
@


1.10
log
@Get flags passed down to PHY drivers correctly.  This was done on
an adhoc basis in a couple of PHY drivers, this fixes it more generally.

From NetBSD

Fixes panics with aue(4) NICs.
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.9 2004/09/27 18:25:48 brad Exp $	*/
d81 8
d93 1
a93 2
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxXAQTI &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_XAQTI_XMACII)
d105 1
d107 2
a108 1
	printf(": %s, rev. %d\n", MII_STR_XAQTI_XMACII, MII_REV(ma->mii_id2));
@


1.9
log
@ANSI protos and some minor cleanup

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.8 2004/09/26 00:59:58 brad Exp $	*/
d105 1
a105 1
	sc->mii_flags |= MIIF_NOISOLATE | mii->mii_flags;
d107 2
@


1.8
log
@Restructure the PHY entry points to use a structure of
entry points instead of descrete function pointers, and
extend this to include a "reset" entry point. Make sure
any PHY-specific reset routine is always used.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.7 2004/09/20 06:05:27 brad Exp $	*/
d81 1
a81 3
int xmphy_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d93 1
a93 3
xmphy_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d124 1
a124 4
xmphy_service(sc, mii, cmd)
	struct mii_softc *sc;
	struct mii_data *mii;
	int cmd;
d237 1
a237 2
xmphy_status(sc)
	struct mii_softc *sc;
d291 1
a291 3
xmphy_mii_phy_auto(mii, waitfor)
	struct mii_softc *mii;
	int waitfor;
d295 2
a296 2
	if ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {
		PHY_WRITE(mii, XMPHY_MII_ANAR,
d298 1
a298 1
		PHY_WRITE(mii, XMPHY_MII_BMCR,
d305 1
a305 1
			if ((bmsr = PHY_READ(mii, XMPHY_MII_BMSR)) &
d329 4
a332 4
	if ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {
		mii->mii_flags |= MIIF_DOINGAUTO;
		timeout_set(&mii->mii_phy_timo, mii_phy_auto_timeout, mii);
		timeout_add(&mii->mii_phy_timo, hz >> 1);
@


1.7
log
@don't include sys/malloc.h, no memory management functions are used
by any of the MII drivers.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.6 2002/05/04 11:30:06 fgsch Exp $	*/
d77 4
d107 1
a107 2
	sc->mii_service = xmphy_service;
	sc->mii_status = xmphy_status;
d117 1
a117 1
	mii_phy_reset(sc);
d175 1
a175 1
			mii_phy_reset(sc);
d229 1
a229 1
		mii_phy_reset(sc);
@


1.6
log
@some space and tab cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.5 2002/03/14 01:26:58 millert Exp $	*/
a46 1
#include <sys/malloc.h>
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.4 2001/10/05 18:26:48 nate Exp $	*/
d214 1
a214 1
		
@


1.4
log
@use anegticks for phys that do their own autonegotiation timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.3 2001/08/19 15:07:34 miod Exp $	*/
d60 2
a61 2
int xmphy_probe __P((struct device *, void *, void *));
void xmphy_attach __P((struct device *, struct device *, void *));
d72 2
a73 2
int	xmphy_service __P((struct mii_softc *, struct mii_data *, int));
void	xmphy_status __P((struct mii_softc *));
d75 2
a76 2
int	xmphy_mii_phy_auto __P((struct mii_softc *, int));
extern void	mii_phy_auto_timeout __P((void *));
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.4 2001/10/05 18:26:48 nate Exp $	*/
d60 2
a61 2
int xmphy_probe(struct device *, void *, void *);
void xmphy_attach(struct device *, struct device *, void *);
d72 2
a73 2
int	xmphy_service(struct mii_softc *, struct mii_data *, int);
void	xmphy_status(struct mii_softc *);
d75 2
a76 2
int	xmphy_mii_phy_auto(struct mii_softc *, int);
extern void	mii_phy_auto_timeout(void *);
d214 1
a214 1

@


1.3
log
@More old timeouts removal, mainly affected unused/unmaintained code.
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.2 2000/08/29 19:00:36 jason Exp $	*/
d108 1
d212 1
a212 1
		if (++sc->mii_ticks != 5)
@


1.2
log
@openbsdisms
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.1 2000/08/28 13:40:23 jason Exp $	*/
d338 2
a339 1
		timeout(mii_phy_auto_timeout, mii, hz >> 1);
@


1.2.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.2 2000/08/29 19:00:36 jason Exp $	*/
@


1.2.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: xmphy.c,v 1.2.6.1 2001/05/14 22:25:28 niklas Exp $	*/
a107 1
	sc->mii_anegticks = 5;
d211 1
a211 1
		if (++sc->mii_ticks != sc->mii_anegticks)
d338 1
a338 2
		timeout_set(&mii->mii_phy_timo, mii_phy_auto_timeout, mii);
		timeout_add(&mii->mii_phy_timo, hz >> 1);
@


1.2.6.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 2
a61 2
int xmphy_probe(struct device *, void *, void *);
void xmphy_attach(struct device *, struct device *, void *);
d72 2
a73 2
int	xmphy_service(struct mii_softc *, struct mii_data *, int);
void	xmphy_status(struct mii_softc *);
d75 2
a76 2
int	xmphy_mii_phy_auto(struct mii_softc *, int);
extern void	mii_phy_auto_timeout(void *);
@


1.2.6.4
log
@Sync the SMP branch with 3.3
@
text
@d214 1
a214 1

@


1.1
log
@driver for the XAQTI XMACII phy from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 1
a107 1
	sc->mii_flags |= MIIF_NOISOLATE;
d132 3
@

