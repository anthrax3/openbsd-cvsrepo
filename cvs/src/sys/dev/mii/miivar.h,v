head	1.34;
access;
symbols
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.8
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.32.0.10
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.8
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.14
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.12
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.10
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.8
	OPENBSD_5_0:1.31.0.6
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.6
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.4
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.6
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.34
date	2015.09.12.09.49.20;	author miod;	state Exp;
branches;
next	1.33;
commitid	vr80MJsSmhOmakZ8;

1.33
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.32;
commitid	6vhYvh5CxZAHMnsN;

1.32
date	2013.12.28.03.30.41;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.20.20.42.16;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.29;

1.29
date	2008.11.08.03.11.16;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.28.09.24.27;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.06.09.27.19;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.23.01.42.16;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.22.11.50.53;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.26.04.40.09;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.16.03.41.58;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.18.16.15.33;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.27.18.25.48;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.26.00.59.58;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.02.21.53.31;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.13.16.18.56;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.26.21.43.31;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.04.11.30.06;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.57;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.05.18.33.33;	author nate;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.08.19.15.07.34;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.25.20.24.13;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.08.02.16.41;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.03.12.31.43;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.16.16.53.54;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.26.20.04.17;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.30.01.02.33;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.24.21.13.33;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.12.07.22.01.31;	author jason;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.07.16.14.59.07;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	98.11.11.19.34.48;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.09.10.17.17.34;	author jason;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.14.22.25.25;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.07.04.10.41.44;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.10.31.03.22.44;	author nate;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2004.02.19.10.56.24;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	;


desc
@@


1.34
log
@mii_softc's view of the current mii state need to use the proper types
(ifmedia64).
@
text
@/*	$OpenBSD: miivar.h,v 1.33 2015/09/11 13:02:28 stsp Exp $	*/
/*	$NetBSD: miivar.h,v 1.17 2000/03/06 20:56:57 thorpej Exp $	*/

/*-
 * Copyright (c) 1998, 1999, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _DEV_MII_MIIVAR_H_
#define	_DEV_MII_MIIVAR_H_

#include <sys/queue.h>
#include <sys/timeout.h>

/*
 * Media Independent Interface autoconfiguration definitions.
 *
 * This file exports an interface which attempts to be compatible
 * with the BSD/OS 3.0 interface.
 */

struct mii_softc;

/*
 * Callbacks from MII layer into network interface device driver.
 */
typedef	int (*mii_readreg_t)(struct device *, int, int);
typedef	void (*mii_writereg_t)(struct device *, int, int, int);
typedef	void (*mii_statchg_t)(struct device *);

/*
 * A network interface driver has one of these structures in its softc.
 * It is the interface from the network interface driver to the MII
 * layer.
 */
struct mii_data {
	struct ifmedia mii_media;	/* media information */
	struct ifnet *mii_ifp;		/* pointer back to network interface */

	int mii_flags;			/* misc. flags; see below */

	/*
	 * For network interfaces with multiple PHYs, a list of all
	 * PHYs is required so they can all be notified when a media
	 * request is made.
	 */
	LIST_HEAD(mii_listhead, mii_softc) mii_phys;
	uint64_t mii_instance;

	/*
	 * PHY driver fills this in with active media status.
	 */
	uint64_t mii_media_status;
	uint64_t mii_media_active;

	/*
	 * Calls from MII layer into network interface driver.
	 */
	mii_readreg_t mii_readreg;
	mii_writereg_t mii_writereg;
	mii_statchg_t mii_statchg;
};
typedef struct mii_data mii_data_t;

struct mii_phy_funcs {
	int (*pf_service)(struct mii_softc *, struct mii_data *, int);
	void (*pf_status)(struct mii_softc *);
	void (*pf_reset)(struct mii_softc *);
};

/*
 * Requests that can be made to the downcall.
 */
#define	MII_TICK	1	/* once-per-second tick */
#define	MII_MEDIACHG	2	/* user changed media; perform the switch */
#define	MII_POLLSTAT	3	/* user requested media status; fill it in */
#define	MII_DOWN	4	/* interface is down */

/*
 * Each PHY driver's softc has one of these as the first member.
 * XXX This would be better named "phy_softc", but this is the name
 * XXX BSDI used, and we would like to have the same interface.
 */
struct mii_softc {
	struct device mii_dev;		/* generic device glue */

	LIST_ENTRY(mii_softc) mii_list;	/* entry on parent's PHY list */

	int mii_phy;			/* our MII address */
	int mii_oui;			/* MII_OUI(ma->mii_id1, ma->mii_id2) */
	int mii_model;			/* MII_MODEL(ma->mii_id2) */
	int mii_rev;			/* MII_REV(ma->mii_id2) */
	int mii_offset;			/* first PHY, second PHY, etc. */
	uint64_t mii_inst;		/* instance for ifmedia */

	/* Our PHY functions. */
	const struct mii_phy_funcs *mii_funcs;

	struct mii_data *mii_pdata;	/* pointer to parent's mii_data */

	int mii_flags;			/* misc. flags; see below */
	int mii_capabilities;		/* capabilities from BMSR */
	int mii_extcapabilities;	/* extended capabilities */
	int mii_ticks;			/* MII_TICK counter */
	int mii_anegticks;		/* ticks before retrying aneg */

	struct timeout mii_phy_timo;	/* timeout handle */

	uint64_t mii_media_active;		/* last active media */
	uint64_t mii_media_status;		/* last active status */
};
typedef struct mii_softc mii_softc_t;

/* Default mii_anegticks values. */
#define MII_ANEGTICKS		5
#define MII_ANEGTICKS_GIGE	10

/* mii_flags */
#define	MIIF_INITDONE	0x0001		/* has been initialized (mii_data) */
#define	MIIF_NOISOLATE	0x0002		/* do not isolate the PHY */
#define	MIIF_NOLOOP	0x0004		/* no loopback capability */
#define	MIIF_DOINGAUTO	0x0008		/* doing autonegotiation (mii_softc) */
#define MIIF_AUTOTSLEEP	0x0010		/* use tsleep(), not timeout() */
#define MIIF_HAVEFIBER	0x0020		/* from parent: has fiber interface */
#define	MIIF_HAVE_GTCR	0x0040		/* has 100base-T2/1000base-T CR */
#define	MIIF_IS_1000X	0x0080		/* is a 1000BASE-X device */
#define	MIIF_DOPAUSE	0x0100		/* advertise PAUSE capability */
#define	MIIF_IS_HPNA	0x0200		/* is a HomePNA device */
#define	MIIF_FORCEANEG	0x0400		/* force autonegotiation */

#define	MIIF_INHERIT_MASK	(MIIF_NOISOLATE|MIIF_NOLOOP|MIIF_AUTOTSLEEP)

/*
 * Special `locators' passed to mii_attach().  If one of these is not
 * an `any' value, we look for *that* PHY and configure it.  If both
 * are not `any', that is an error, and mii_attach() will panic.
 */
#define	MII_OFFSET_ANY		-1
#define	MII_PHY_ANY		-1

/*
 * Used to attach a PHY to a parent.
 */
struct mii_attach_args {
	struct mii_data *mii_data;	/* pointer to parent data */
	int mii_phyno;			/* MII address */
	int mii_id1;			/* PHY ID register 1 */
	int mii_id2;			/* PHY ID register 2 */
	int mii_capmask;		/* capability mask from BMSR */
	int mii_flags;			/* flags from parent */
};
typedef struct mii_attach_args mii_attach_args_t;

/*
 * Used to match a PHY.
 */
struct mii_phydesc {
	u_int32_t mpd_oui;		/* the PHY's OUI */
	u_int32_t mpd_model;		/* the PHY's model */
	const char *mpd_name;		/* the PHY's name */
};

/*
 * An array of these structures map MII media types to BMCR/ANAR settings.
 */
struct mii_media {
	int	mm_bmcr;		/* BMCR settings for this media */
	int	mm_anar;		/* ANAR settings for this media */
	int	mm_gtcr;		/* 100base-T2 or 1000base-T CR */
};

#define	MII_MEDIA_NONE		0
#define	MII_MEDIA_10_T		1
#define	MII_MEDIA_10_T_FDX	2
#define	MII_MEDIA_100_T4	3
#define	MII_MEDIA_100_TX	4
#define	MII_MEDIA_100_TX_FDX	5
#define	MII_MEDIA_1000_X	6
#define	MII_MEDIA_1000_X_FDX	7
#define	MII_MEDIA_1000_T	8
#define	MII_MEDIA_1000_T_FDX	9
#define	MII_NMEDIA		10

#ifdef _KERNEL

#define	PHY_READ(p, r) \
	(*(p)->mii_pdata->mii_readreg)((p)->mii_dev.dv_parent, \
	    (p)->mii_phy, (r))

#define	PHY_WRITE(p, r, v) \
	(*(p)->mii_pdata->mii_writereg)((p)->mii_dev.dv_parent, \
	    (p)->mii_phy, (r), (v))

#define	PHY_SERVICE(p, d, o) \
	(*(p)->mii_funcs->pf_service)((p), (d), (o))

#define	PHY_STATUS(p) \
	(*(p)->mii_funcs->pf_status)((p))

#define	PHY_RESET(p) \
	(*(p)->mii_funcs->pf_reset)((p))

#define mii_phy_probe(x, y, z) \
	mii_attach((x), (y), (z), MII_PHY_ANY, MII_OFFSET_ANY, 0)

#define MII_OUI(id1, id2)	(((id1) << 6) | ((id2) >> 10))
#define MII_MODEL(id2)		(((id2) & IDR2_MODEL) >> 4)
#define MII_REV(id2)		((id2) & IDR2_REV)

void	mii_attach(struct device *, struct mii_data *, int, int,
	    int, int);
void	mii_detach(struct mii_data *, int, int);

int	mii_mediachg(struct mii_data *);
void	mii_tick(struct mii_data *);
void	mii_pollstat(struct mii_data *);
void	mii_down(struct mii_data *);
int	mii_anar(uint64_t);

int	mii_phy_detach(struct device *, int);

const struct mii_phydesc *mii_phy_match(const struct mii_attach_args *,
	    const struct mii_phydesc *);

void	mii_phy_add_media(struct mii_softc *);
void	mii_phy_delete_media(struct mii_softc *);

void	mii_phy_setmedia(struct mii_softc *);
int	mii_phy_auto(struct mii_softc *, int);
void	mii_phy_auto_timeout(void *);
void	mii_phy_reset(struct mii_softc *);
void	mii_phy_down(struct mii_softc *);
int	mii_phy_tick(struct mii_softc *);

void	mii_phy_status(struct mii_softc *);
void	mii_phy_update(struct mii_softc *, int);
int	mii_phy_statusmsg(struct mii_softc *);

uint64_t	mii_phy_flowstatus(struct mii_softc *);

void	ukphy_status(struct mii_softc *);

#endif /* _KERNEL */

#endif /* _DEV_MII_MIIVAR_H_ */
@


1.33
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.32 2013/12/28 03:30:41 deraadt Exp $	*/
d134 2
a135 2
	int mii_media_active;		/* last active media */
	int mii_media_status;		/* last active status */
@


1.32
log
@mii drivers no longer need activate functions.  Repair of the PHY
configuration setting is done at resume time because all networks
drivers which were previously up, do an IFF_UP operation which
hits PHY_RESET.
This was in snapshots for about 2 weeks.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.31 2010/04/20 20:42:16 deraadt Exp $	*/
d73 1
a73 1
	int mii_instance;
d78 2
a79 2
	int mii_media_status;
	int mii_media_active;
d119 1
a119 1
	int mii_inst;			/* instance for ifmedia */
d243 1
a243 1
int	mii_anar(int);
d264 1
a264 1
int	mii_phy_flowstatus(struct mii_softc *);
@


1.31
log
@mii_activate() is unused
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.30 2009/10/13 19:33:16 pirofti Exp $	*/
a244 1
int	mii_phy_activate(struct device *, int);
@


1.30
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.29 2008/11/08 03:11:16 brad Exp $	*/
a236 1
void	mii_activate(struct mii_data *, int, int, int);
@


1.29
log
@Add a softc field mii_oui to store the OUI.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.28 2008/06/26 05:42:16 ray Exp $	*/
d237 1
a237 1
void	mii_activate(struct mii_data *, enum devact, int, int);
d246 1
a246 1
int	mii_phy_activate(struct device *, enum devact);
@


1.28
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.27 2006/12/28 09:24:27 kettenis Exp $	*/
d115 1
@


1.27
log
@Add function to detect flow control status.  From NetBSD.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.26 2005/11/06 09:27:19 brad Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.26
log
@move some macros from mii.h to miivar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.25 2005/07/23 01:42:16 brad Exp $	*/
d271 2
@


1.25
log
@back out last commit, this causes problems on some systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.24 2005/07/22 11:50:53 brad Exp $	*/
d236 4
@


1.24
log
@Reading the IEEE specs shows that the bits have to be reversed when
mapping an OUI to the MII id registers.

From drochner NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.23 2005/03/26 04:40:09 krw Exp $	*/
a268 5

int	mii_oui(int, int);
#define	MII_OUI(id1, id2)	mii_oui(id1, id2)
#define	MII_MODEL(id2)		(((id2) & IDR2_MODEL) >> 4)
#define	MII_REV(id2)		((id2) & IDR2_REV)
@


1.23
log
@Cleanup. Use defines, standard names, consistant comparison operators, etc.
for auto negotiation ticks code. No functional change.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.22 2004/12/16 03:41:58 brad Exp $	*/
d246 1
d270 5
a274 1
int	mii_anar(int);
@


1.22
log
@Make sure ifp->if_baudrate is valid when the parent's statchg
callback is made.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.21 2004/11/18 16:15:33 brad Exp $	*/
d145 4
d258 1
@


1.21
log
@add mii_phy_match() for table-driven lookup.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.20 2004/09/27 18:25:48 brad Exp $	*/
d260 1
a260 1
void	mii_phy_statusmsg(struct mii_softc *);
@


1.20
log
@ANSI protos and some minor cleanup

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.19 2004/09/26 00:59:58 brad Exp $	*/
d182 9
d245 3
@


1.19
log
@Restructure the PHY entry points to use a structure of
entry points instead of descrete function pointers, and
extend this to include a "reset" entry point. Make sure
any PHY-specific reset routine is always used.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.18 2004/08/02 21:53:31 brad Exp $	*/
a44 4

#if defined(__NetBSD__)
#include <sys/callout.h>
#elif defined(__OpenBSD__)
a45 1
#endif
a137 3
#if defined(__NetBSD__)
	struct callout mii_nway_ch;	/* NWAY callout */
#elif defined(__OpenBSD__)
a138 1
#endif
@


1.18
log
@more MII flags

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.17 2003/10/13 16:18:56 krw Exp $	*/
d102 5
a106 10
/*
 * This call is used by the MII layer to call into the PHY driver
 * to perform a `service request'.
 */
typedef	int (*mii_downcall_t)(struct mii_softc *, struct mii_data *, int);

/*
 * This is a call back into the PHY driver made by a `status request'.
 */
typedef void (*mii_statusreq_t)(struct mii_softc *);
d132 3
a134 2
	mii_downcall_t mii_service;	/* our downcall */
	mii_statusreq_t mii_status;	/* our status request fn */
d220 9
@


1.17
log
@Bring bge and brgphy more up to date with changes from FreeBSD and NetBSD.

Some bug fixes, support for new hardware like the 5704 and 5705.

Testing by deraadt@@, danh@@, and drahn@@ amoung others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.16 2003/09/26 21:43:31 miod Exp $	*/
d166 4
@


1.16
log
@Typos: defintion -> definition, proccess -> process

There are more occurences hiding in binutils, lynx and afs but I am too
lazy to report them upstream at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.15 2002/05/04 11:30:06 fgsch Exp $	*/
d132 2
@


1.15
log
@some space and tab cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.14 2002/03/14 01:26:57 millert Exp $	*/
d53 1
a53 1
 * Media Independent Interface autoconfiguration defintions.
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.13 2001/10/05 18:33:33 nate Exp $	*/
d128 1
a128 1
	
@


1.13
log
@Differentiate between 1000baseT and 1000baseX.
Add some support for gigabit control/status regs.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.12 2001/08/19 15:07:34 miod Exp $	*/
d64 3
a66 3
typedef	int (*mii_readreg_t) __P((struct device *, int, int));
typedef	void (*mii_writereg_t) __P((struct device *, int, int, int));
typedef	void (*mii_statchg_t) __P((struct device *));
d106 1
a106 1
typedef	int (*mii_downcall_t) __P((struct mii_softc *, struct mii_data *, int));
d111 1
a111 1
typedef void (*mii_statusreq_t) __P((struct mii_softc *));
d222 25
a246 25
void	mii_attach __P((struct device *, struct mii_data *, int, int,
	    int, int));
void	mii_activate __P((struct mii_data *, enum devact, int, int));
void	mii_detach __P((struct mii_data *, int, int));

int	mii_mediachg __P((struct mii_data *));
void	mii_tick __P((struct mii_data *));
void	mii_pollstat __P((struct mii_data *));
void	mii_down __P((struct mii_data *));

int	mii_phy_activate __P((struct device *, enum devact));
int	mii_phy_detach __P((struct device *, int));

void	mii_phy_add_media __P((struct mii_softc *));
void	mii_phy_delete_media __P((struct mii_softc *));

void	mii_phy_setmedia __P((struct mii_softc *));
int	mii_phy_auto __P((struct mii_softc *, int));
void	mii_phy_reset __P((struct mii_softc *));
void	mii_phy_down __P((struct mii_softc *));
int	mii_phy_tick __P((struct mii_softc *));

void	mii_phy_status __P((struct mii_softc *));
void	mii_phy_update __P((struct mii_softc *, int));
void	mii_phy_statusmsg __P((struct mii_softc *));
d248 1
a248 1
void	ukphy_status __P((struct mii_softc *));
d250 1
a250 1
int	mii_anar __P((int));
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.13 2001/10/05 18:33:33 nate Exp $	*/
d64 3
a66 3
typedef	int (*mii_readreg_t)(struct device *, int, int);
typedef	void (*mii_writereg_t)(struct device *, int, int, int);
typedef	void (*mii_statchg_t)(struct device *);
d106 1
a106 1
typedef	int (*mii_downcall_t)(struct mii_softc *, struct mii_data *, int);
d111 1
a111 1
typedef void (*mii_statusreq_t)(struct mii_softc *);
d128 1
a128 1

d222 25
a246 25
void	mii_attach(struct device *, struct mii_data *, int, int,
	    int, int);
void	mii_activate(struct mii_data *, enum devact, int, int);
void	mii_detach(struct mii_data *, int, int);

int	mii_mediachg(struct mii_data *);
void	mii_tick(struct mii_data *);
void	mii_pollstat(struct mii_data *);
void	mii_down(struct mii_data *);

int	mii_phy_activate(struct device *, enum devact);
int	mii_phy_detach(struct device *, int);

void	mii_phy_add_media(struct mii_softc *);
void	mii_phy_delete_media(struct mii_softc *);

void	mii_phy_setmedia(struct mii_softc *);
int	mii_phy_auto(struct mii_softc *, int);
void	mii_phy_reset(struct mii_softc *);
void	mii_phy_down(struct mii_softc *);
int	mii_phy_tick(struct mii_softc *);

void	mii_phy_status(struct mii_softc *);
void	mii_phy_update(struct mii_softc *, int);
void	mii_phy_statusmsg(struct mii_softc *);
d248 1
a248 1
void	ukphy_status(struct mii_softc *);
d250 1
a250 1
int	mii_anar(int);
@


1.12
log
@More old timeouts removal, mainly affected unused/unmaintained code.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.11 2001/06/25 20:24:13 nate Exp $	*/
d162 2
d194 1
d203 5
a207 3
#define MII_MEDIA_1000		6
#define MII_MEDIA_1000_FDX	7
#define	MII_NMEDIA		8
@


1.11
log
@Change autonegotiation timeout for devices with a gigabit phy to 10s.  All
other devices default to 5 seconds. ok deraadt. from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.10 2001/06/08 02:16:41 nate Exp $	*/
d147 2
a152 2

	struct timeout mii_phy_timo;	/* timeout handle */
@


1.10
log
@Add some general support info for gigabit phys
Fix some comments
Remove some dead code
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.9 2001/05/03 12:31:43 aaron Exp $	*/
d143 1
@


1.9
log
@Add an MIIF_AUTOTSLEEP flag, needed by new aue(4) code. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.8 2000/10/16 16:53:54 aaron Exp $	*/
d141 1
d199 3
a201 1
#define	MII_NMEDIA		6
d243 2
@


1.8
log
@Do not pass any flags to mii_attach() through the mii_phy_probe() wrapper.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.7 2000/08/26 20:04:17 nate Exp $	*/
d159 1
d161 1
a161 1
#define	MIIF_INHERIT_MASK	(MIIF_NOISOLATE|MIIF_NOLOOP)
@


1.7
log
@sync mii code with netbsd
adds detach functionality for phys
some code cleanup

Nobody really had time to test all of this out, but theo said commit anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.6 2000/06/30 01:02:33 art Exp $	*/
d210 1
a210 1
	mii_attach((x), (y), (z), MII_PHY_ANY, MII_OFFSET_ANY, MIIF_NOISOLATE)
@


1.6
log
@Convert to new timeouts.
@
text
@d1 2
a2 2
/*	$OpenBSD: miivar.h,v 1.5 2000/04/24 21:13:33 niklas Exp $	*/
/*	$NetBSD: miivar.h,v 1.7.6.1 1999/04/23 15:40:35 perry Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
d45 4
d50 1
d77 2
d109 5
d132 1
d136 1
d142 8
a149 1
	int mii_active;			/* last active media */
d163 8
d179 1
d187 2
a188 2
	int	mm_bmcr;	/* BMCR settings for this media */
	int	mm_anar;	/* ANAR settings for this media */
d209 8
d221 6
a226 3
void	mii_phy_probe __P((struct device *, struct mii_data *, int));
int	mii_detach __P((struct mii_softc *, int));
void	mii_add_media __P((struct mii_softc *));
d232 5
@


1.5
log
@Add simple mii detach routine while waiting for the post-2.7
merge of NetBSD mii work
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.4 1999/12/07 22:01:31 jason Exp $	*/
d45 1
d129 1
@


1.4
log
@Merge with NetBSD:
o move common support functions for phy drivers from mii.c to mii_physubr.c,
	so that they are not includes if no PHY is configured
o Clean up the code that adds media a little, and make media selection
	table-driven in preparation for some other changes to be made.
o Don't add any loopback versions of media, for now.
o Add mii_down(), which is used by MAC drivers to inform PHYs that the
	interface is now down.  PHYs use this to cancel pending asynchronous
	operations.
o Add OUI for Enable Semiconductor.
o New Driver for TDK TSC78Q2120 PHY
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.3 1999/07/16 14:59:07 jason Exp $	*/
d182 1
@


1.4.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: miivar.h,v 1.8 2000/10/16 16:53:54 aaron Exp $	*/
/*	$NetBSD: miivar.h,v 1.17 2000/03/06 20:56:57 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2000 The NetBSD Foundation, Inc.
a45 6
#if defined(__NetBSD__)
#include <sys/callout.h>
#elif defined(__OpenBSD__)
#include <sys/timeout.h>
#endif

a70 2
	int mii_flags;			/* misc. flags; see below */

a100 5
 * This is a call back into the PHY driver made by a `status request'.
 */
typedef void (*mii_statusreq_t) __P((struct mii_softc *));

/*
a118 1
	int mii_offset;			/* first PHY, second PHY, etc. */
a121 1
	mii_statusreq_t mii_status;	/* our status request fn */
d127 1
a127 9

#if defined(__NetBSD__)
	struct callout mii_nway_ch;	/* NWAY callout */
#endif

	int mii_media_active;		/* last active media */
	int mii_media_status;		/* last active status */

	struct timeout mii_phy_timo;	/* timeout handle */
a139 8
 * Special `locators' passed to mii_attach().  If one of these is not
 * an `any' value, we look for *that* PHY and configure it.  If both
 * are not `any', that is an error, and mii_attach() will panic.
 */
#define	MII_OFFSET_ANY		-1
#define	MII_PHY_ANY		-1

/*
a147 1
	int mii_flags;			/* flags from parent */
d155 2
a156 2
	int	mm_bmcr;		/* BMCR settings for this media */
	int	mm_anar;		/* ANAR settings for this media */
a176 8
#define mii_phy_probe(x, y, z) \
	mii_attach((x), (y), (z), MII_PHY_ANY, MII_OFFSET_ANY, 0)

void	mii_attach __P((struct device *, struct mii_data *, int, int,
	    int, int));
void	mii_activate __P((struct mii_data *, enum devact, int, int));
void	mii_detach __P((struct mii_data *, int, int));

d181 2
a182 6

int	mii_phy_activate __P((struct device *, enum devact));
int	mii_phy_detach __P((struct device *, int));

void	mii_phy_add_media __P((struct mii_softc *));
void	mii_phy_delete_media __P((struct mii_softc *));
a187 5
int	mii_phy_tick __P((struct mii_softc *));

void	mii_phy_status __P((struct mii_softc *));
void	mii_phy_update __P((struct mii_softc *, int));
void	mii_phy_statusmsg __P((struct mii_softc *));
@


1.4.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.4.2.1 2001/05/14 22:25:25 niklas Exp $	*/
a140 1
	int mii_extcapabilities;	/* extended capabilities */
a141 1
	int mii_anegticks;		/* ticks before retrying aneg */
a158 1
#define MIIF_AUTOTSLEEP	0x0010		/* use tsleep(), not timeout() */
d160 1
a160 1
#define	MIIF_INHERIT_MASK	(MIIF_NOISOLATE|MIIF_NOLOOP|MIIF_AUTOTSLEEP)
d197 1
a197 3
#define MII_MEDIA_1000		6
#define MII_MEDIA_1000_FDX	7
#define	MII_NMEDIA		8
a238 2

int	mii_anar __P((int));
@


1.4.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.4.2.2 2001/07/04 10:41:44 niklas Exp $	*/
a146 2
#elif defined(__OpenBSD__)
	struct timeout mii_phy_timo;	/* timeout handle */
d151 2
a161 2
#define MIIF_HAVEFIBER	0x0020		/* from parent: has fiber interface */
#define	MIIF_HAVE_GTCR	0x0040		/* has 100base-T2/1000base-T CR */
a191 1
	int	mm_gtcr;		/* 100base-T2 or 1000base-T CR */
d200 3
a202 5
#define	MII_MEDIA_1000_X	6
#define	MII_MEDIA_1000_X_FDX	7
#define	MII_MEDIA_1000_T	8
#define	MII_MEDIA_1000_T_FDX	9
#define	MII_NMEDIA		10
@


1.4.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 3
a66 3
typedef	int (*mii_readreg_t)(struct device *, int, int);
typedef	void (*mii_writereg_t)(struct device *, int, int, int);
typedef	void (*mii_statchg_t)(struct device *);
d106 1
a106 1
typedef	int (*mii_downcall_t)(struct mii_softc *, struct mii_data *, int);
d111 1
a111 1
typedef void (*mii_statusreq_t)(struct mii_softc *);
d222 25
a246 25
void	mii_attach(struct device *, struct mii_data *, int, int,
	    int, int);
void	mii_activate(struct mii_data *, enum devact, int, int);
void	mii_detach(struct mii_data *, int, int);

int	mii_mediachg(struct mii_data *);
void	mii_tick(struct mii_data *);
void	mii_pollstat(struct mii_data *);
void	mii_down(struct mii_data *);

int	mii_phy_activate(struct device *, enum devact);
int	mii_phy_detach(struct device *, int);

void	mii_phy_add_media(struct mii_softc *);
void	mii_phy_delete_media(struct mii_softc *);

void	mii_phy_setmedia(struct mii_softc *);
int	mii_phy_auto(struct mii_softc *, int);
void	mii_phy_reset(struct mii_softc *);
void	mii_phy_down(struct mii_softc *);
int	mii_phy_tick(struct mii_softc *);

void	mii_phy_status(struct mii_softc *);
void	mii_phy_update(struct mii_softc *, int);
void	mii_phy_statusmsg(struct mii_softc *);
d248 1
a248 1
void	ukphy_status(struct mii_softc *);
d250 1
a250 1
int	mii_anar(int);
@


1.4.2.5
log
@Sync the SMP branch with 3.3
@
text
@d128 1
a128 1

@


1.4.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d53 1
a53 1
 * Media Independent Interface autoconfiguration definitions.
a131 2
	int mii_model;			/* MII_MODEL(ma->mii_id2) */
	int mii_rev;			/* MII_REV(ma->mii_id2) */
@


1.3
log
@Sync with NetBSD:
o Implement asynchronous autonegotiation when driven by the MII tick
  (one-second clock).  Prevents .5s delays every 5 seconds when the interface
  is up but there is no link.
o Correct the sense of the PCR_FLINK100 bit in nsphy.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: miivar.h,v 1.2 1998/11/11 19:34:48 jason Exp $	*/
d106 1
d132 6
a137 2
#define	MIIF_NOISOLATE	0x0001		/* do not isolate the PHY */
#define	MIIF_DOINGAUTO	0x0002		/* doing autonegotiation */
d151 16
a176 1
int	mii_anar __P((int));
d180 1
d182 1
a182 3
void	mii_add_media __P((struct mii_data *, int, int));

int	mii_media_from_bmcr __P((int));
d184 1
d187 1
@


1.2
log
@Merge with NetBSD:
o additional phy drivers (seeq, ics, level1)
o "unknown phy" driver for unsupported phys
o collected common code into mii_physubr
o exphy isn't the only phy that doesn't have valid id registers
@
text
@d1 2
a2 2
/*	$OpenBSD: miivar.h,v 1.1 1998/09/10 17:17:34 jason Exp $	*/
/*	$NetBSD: miivar.h,v 1.7 1998/11/05 04:08:02 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d132 1
d165 1
a165 1
int	mii_phy_auto __P((struct mii_softc *));
@


1.1
log
@OpenBSD gets sys/dev/mii layer from NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: miivar.h,v 1.1 1998/08/10 23:55:18 thorpej Exp $	*/
d103 1
a103 1
#define	MII_TICK	1
d122 5
d130 3
d147 8
d161 7
@

