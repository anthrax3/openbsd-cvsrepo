head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.24
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.22
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.20
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.18
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.14
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.12
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.10
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.8
	OPENBSD_5_0:1.21.0.6
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.12
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.10
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.8
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.6
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.12.0.8
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.12
	UBC:1.10.0.4
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.12.29.18.35.39;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	1fYcZ02Uap1RfDMQ;

1.22
date	2015.12.28.22.25.40;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	eiQPjwLEYLCzFvFZ;

1.21
date	2010.04.20.20.42.16;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.23.01.42.16;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.22.11.50.53;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.09.21.32.06;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.28.18.27.55;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.27.18.25.48;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.26.00.59.58;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.57;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.10.15.05.47;	author jason;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2000.08.26.20.04.17;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.27.07.37.13;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.24.21.13.33;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.12.07.22.01.31;	author jason;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.07.23.12.39.11;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.02.04.23.00.57;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.01.04.03.57.55;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	98.11.11.19.34.47;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.09.10.17.17.33;	author jason;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.25.24;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.10.31.03.22.44;	author nate;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.28.00.38.19;	author niklas;	state Exp;
branches;
next	;

1.10.4.1
date	2002.06.11.03.42.23;	author art;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Tweak previous by de-indenting label and replacing remaining continues
with gotos.

supported by kettenis@@, ok sobrado@@
@
text
@/*	$OpenBSD: mii.c,v 1.22 2015/12/28 22:25:40 mmcc Exp $	*/
/*	$NetBSD: mii.c,v 1.19 2000/02/02 17:09:44 thorpej Exp $	*/

/*-
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * MII bus layer, glues MII-capable network interface drivers to sharable
 * PHY drivers.  This exports an interface compatible with BSD/OS 3.0's,
 * plus some NetBSD extensions.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

int	mii_print(void *, const char *);
int	mii_submatch(struct device *, void *, void *);

#define MIICF_PHY		0	/* cf_loc index */
#define MIICF_PHY_DEFAULT	(-1)	/* default phy device */

/*
 * Helper function used by network interface drivers, attaches PHYs
 * to the network interface driver parent.
 */
void
mii_attach(struct device *parent, struct mii_data *mii, int capmask,
    int phyloc, int offloc, int flags)
{
	struct mii_attach_args ma;
	struct mii_softc *child;
	int bmsr, offset = 0;
	int phymin, phymax;

	if (phyloc != MII_PHY_ANY && offloc != MII_OFFSET_ANY)
		panic("mii_attach: phyloc and offloc specified");

	if (phyloc == MII_PHY_ANY) {
		phymin = 0;
		phymax = MII_NPHY - 1;
	} else
		phymin = phymax = phyloc;

	if ((mii->mii_flags & MIIF_INITDONE) == 0) {
		LIST_INIT(&mii->mii_phys);
		mii->mii_flags |= MIIF_INITDONE;
	}

	for (ma.mii_phyno = phymin; ma.mii_phyno <= phymax; ma.mii_phyno++) {
		/*
		 * Make sure we haven't already configured a PHY at this
		 * address.  This allows mii_attach() to be called
		 * multiple times.
		 */
		for (child = LIST_FIRST(&mii->mii_phys); child != NULL;
		     child = LIST_NEXT(child, mii_list)) {
			if (child->mii_phy == ma.mii_phyno) {
				/*
				 * Yes, there is already something
				 * configured at this address.
				 */
				offset++;
				goto loop_end;
			}
		}

		/*
		 * Check to see if there is a PHY at this address.  Note,
		 * many braindead PHYs report 0/0 in their ID registers,
		 * so we test for media in the BMSR.
		 */
		bmsr = (*mii->mii_readreg)(parent, ma.mii_phyno, MII_BMSR);
		if (bmsr == 0 || bmsr == 0xffff ||
		    (bmsr & (BMSR_MEDIAMASK|BMSR_EXTSTAT)) == 0) {
			/* Assume no PHY at this address. */
			goto loop_end;
		}

		/*
		 * There is a PHY at this address.  If we were given an
		 * `offset' locator, skip this PHY if it doesn't match.
		 */
		if (offloc != MII_OFFSET_ANY && offloc != offset) {
			offset++;
			goto loop_end;
		}

		/*
		 * Extract the IDs.  Braindead PHYs will be handled by
		 * the `ukphy' driver, as we have no ID information to
		 * match on.
		 */
		ma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,
		    MII_PHYIDR1);
		ma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,
		    MII_PHYIDR2);

		ma.mii_data = mii;
		ma.mii_capmask = capmask;
		ma.mii_flags = flags | (mii->mii_flags & MIIF_INHERIT_MASK);

		if ((child = (struct mii_softc *)config_found_sm(parent, &ma,
		    mii_print, mii_submatch)) != NULL) {
			/*
			 * Link it up in the parent's MII data.
			 */
			LIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);
			child->mii_offset = offset;
			mii->mii_instance++;
		}
		offset++;

loop_end:	;
	}
}

void
mii_detach(struct mii_data *mii, int phyloc, int offloc)
{
	struct mii_softc *child, *nchild;

	if (phyloc != MII_PHY_ANY && offloc != MII_PHY_ANY)
		panic("mii_detach: phyloc and offloc specified");

	if ((mii->mii_flags & MIIF_INITDONE) == 0)
		return;

	for (child = LIST_FIRST(&mii->mii_phys);
	     child != NULL; child = nchild) {
		nchild = LIST_NEXT(child, mii_list);
		if (phyloc != MII_PHY_ANY || offloc != MII_OFFSET_ANY) {
			if (phyloc != MII_PHY_ANY &&
			    phyloc != child->mii_phy)
				continue;
			if (offloc != MII_OFFSET_ANY &&
			    offloc != child->mii_offset)
				continue;
		}
		LIST_REMOVE(child, mii_list);
		(void) config_detach(&child->mii_dev, DETACH_FORCE);
	}
}

int
mii_print(void *aux, const char *pnp)
{
	struct mii_attach_args *ma = aux;

	if (pnp != NULL)
		printf("OUI 0x%06x model 0x%04x rev %d at %s",
		    MII_OUI(ma->mii_id1, ma->mii_id2), MII_MODEL(ma->mii_id2),
		    MII_REV(ma->mii_id2), pnp);

	printf(" phy %d", ma->mii_phyno);
	return (UNCONF);
}

int
mii_submatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct mii_attach_args *ma = aux;

	if (ma->mii_phyno != cf->cf_loc[MIICF_PHY] &&
	    cf->cf_loc[MIICF_PHY] != MIICF_PHY_DEFAULT)
		return (0);

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

/*
 * Media changed; notify all PHYs.
 */
int
mii_mediachg(struct mii_data *mii)
{
	struct mii_softc *child;
	int rv;

	mii->mii_media_status = 0;
	mii->mii_media_active = IFM_NONE;

	for (child = LIST_FIRST(&mii->mii_phys); child != NULL;
	     child = LIST_NEXT(child, mii_list)) {
		rv = PHY_SERVICE(child, mii, MII_MEDIACHG);
		if (rv)
			return (rv);
	}
	return (0);
}

/*
 * Call the PHY tick routines, used during autonegotiation.
 */
void
mii_tick(struct mii_data *mii)
{
	struct mii_softc *child;

	for (child = LIST_FIRST(&mii->mii_phys); child != NULL;
	     child = LIST_NEXT(child, mii_list))
		(void) PHY_SERVICE(child, mii, MII_TICK);
}

/*
 * Get media status from PHYs.
 */
void
mii_pollstat(struct mii_data *mii)
{
	struct mii_softc *child;

	mii->mii_media_status = 0;
	mii->mii_media_active = IFM_NONE;

	for (child = LIST_FIRST(&mii->mii_phys); child != NULL;
	     child = LIST_NEXT(child, mii_list))
		(void) PHY_SERVICE(child, mii, MII_POLLSTAT);
}

/*
 * Inform the PHYs that the interface is down.
 */
void
mii_down(struct mii_data *mii)
{
	struct mii_softc *child;

	for (child = LIST_FIRST(&mii->mii_phys); child != NULL;
	     child = LIST_NEXT(child, mii_list))
		(void) PHY_SERVICE(child, mii, MII_DOWN);
}
@


1.22
log
@1. Add a loop_end label to the outer loop
2. Replace a continue statement in an inner loop with goto loop_end

This fixes a simple logical bug found with Coccinelle.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.21 2010/04/20 20:42:16 deraadt Exp $	*/
d111 1
a111 1
			continue;
d120 1
a120 1
			continue;
d148 1
a148 1
		loop_end: ;
@


1.21
log
@mii_activate() is unused
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.20 2009/10/13 19:33:16 pirofti Exp $	*/
d98 1
a98 1
				continue;
d147 2
@


1.20
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.19 2008/06/26 05:42:16 ray Exp $	*/
a146 34
	}
}

void
mii_activate(struct mii_data *mii, int act, int phyloc, int offloc)
{
	struct mii_softc *child;

	if (phyloc != MII_PHY_ANY && offloc != MII_OFFSET_ANY)
		panic("mii_activate: phyloc and offloc specified");

	if ((mii->mii_flags & MIIF_INITDONE) == 0)
		return;

	for (child = LIST_FIRST(&mii->mii_phys);
	     child != NULL; child = LIST_NEXT(child, mii_list)) {
		if (phyloc != MII_PHY_ANY || offloc != MII_OFFSET_ANY) {
			if (phyloc != MII_PHY_ANY &&
			    phyloc != child->mii_phy)
				continue;
			if (offloc != MII_OFFSET_ANY &&
			    offloc != child->mii_offset)
				continue;
		}
		switch (act) {
		case DVACT_ACTIVATE:
			panic("mii_activate: DVACT_ACTIVATE");
			break;

		case DVACT_DEACTIVATE:
			if (config_deactivate(&child->mii_dev) != 0)
				panic("%s: config_activate(%d) failed",
				    child->mii_dev.dv_xname, act);
		}
@


1.19
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.18 2005/07/23 01:42:16 brad Exp $	*/
d151 1
a151 1
mii_activate(struct mii_data *mii, enum devact act, int phyloc, int offloc)
@


1.18
log
@back out last commit, this causes problems on some systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.17 2005/07/22 11:50:53 brad Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.17
log
@Reading the IEEE specs shows that the bits have to be reversed when
mapping an OUI to the MII id registers.

From drochner NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.16 2005/07/09 21:32:06 brad Exp $	*/
a305 22
}

static unsigned char
bitreverse(unsigned char x)
{
	static unsigned char nibbletab[16] = {
		0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15
	};

	return ((nibbletab[x & 15] << 4) | nibbletab[x >> 4]);
}

int
mii_oui(int id1, int id2)
{
	int h;

	h = (id1 << 6) | (id2 >> 10);

	return ((bitreverse(h >> 16) << 16) |
		(bitreverse((h >> 8) & 255) << 8) |
		bitreverse(h & 255));
@


1.16
log
@rev 1.34

for offloc, use MII_OFFSET_ANY rather than abusing MII_PHY_ANY.

From yamt NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.15 2005/01/28 18:27:55 brad Exp $	*/
d306 22
@


1.15
log
@Get flags passed down to PHY drivers correctly.  This was done on
an adhoc basis in a couple of PHY drivers, this fixes it more generally.

From NetBSD

Fixes panics with aue(4) NICs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.14 2004/09/27 18:25:48 brad Exp $	*/
d77 1
a77 1
	if (phyloc != MII_PHY_ANY && offloc != MII_PHY_ANY)
d162 1
a162 1
	if (phyloc != MII_PHY_ANY && offloc != MII_PHY_ANY)
@


1.14
log
@ANSI protos and some minor cleanup

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.13 2004/09/26 00:59:58 brad Exp $	*/
d142 1
a142 1
		ma.mii_flags = flags;
@


1.13
log
@Restructure the PHY entry points to use a structure of
entry points instead of descrete function pointers, and
extend this to include a "reset" entry point. Make sure
any PHY-specific reset routine is always used.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.12 2002/10/12 01:09:44 krw Exp $	*/
d69 2
a70 4
mii_attach(parent, mii, capmask, phyloc, offloc, flags)
	struct device *parent;
	struct mii_data *mii;
	int capmask, phyloc, offloc, flags;
a148 3
#if defined(__NetBSD__)
			callout_init(&child->mii_nway_ch);
#endif
d158 1
a158 4
mii_activate(mii, act, phyloc, offloc)
	struct mii_data *mii;
	enum devact act;
	int phyloc, offloc;
d192 1
a192 3
mii_detach(mii, phyloc, offloc)
	struct mii_data *mii;
	int phyloc, offloc;
d219 1
a219 3
mii_print(aux, pnp)
	void *aux;
	const char *pnp;
d233 1
a233 3
mii_submatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d249 1
a249 2
mii_mediachg(mii)
	struct mii_data *mii;
d270 1
a270 2
mii_tick(mii)
	struct mii_data *mii;
d283 1
a283 2
mii_pollstat(mii)
	struct mii_data *mii;
d299 1
a299 2
mii_down(mii)
	struct mii_data *mii;
@


1.12
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.11 2002/03/14 01:26:57 millert Exp $	*/
d274 1
a274 1
		rv = (*child->mii_service)(child, mii, MII_MEDIACHG);
d292 1
a292 1
		(void) (*child->mii_service)(child, mii, MII_TICK);
d309 1
a309 1
		(void) (*child->mii_service)(child, mii, MII_POLLSTAT);
d323 1
a323 1
		(void) (*child->mii_service)(child, mii, MII_DOWN);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.10 2001/10/10 15:05:47 jason Exp $	*/
d193 1
a193 1
				panic("%s: config_activate(%d) failed\n",
@


1.10
log
@gigabit only phys don't have any of the 10/100 bits set in BMSR, but the
EXTSTAT bit -is- set.  Add EXTSTAT to the early check of BMSR so that
sk/xmphy can attach correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.9 2000/08/26 20:04:17 nate Exp $	*/
d58 2
a59 2
int	mii_print __P((void *, const char *));
int	mii_submatch __P((struct device *, void *, void *));
@


1.10.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.10 2001/10/10 15:05:47 jason Exp $	*/
d58 2
a59 2
int	mii_print(void *, const char *);
int	mii_submatch(struct device *, void *, void *);
@


1.10.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.10.4.1 2002/06/11 03:42:23 art Exp $	*/
d193 1
a193 1
				panic("%s: config_activate(%d) failed",
@


1.9
log
@sync mii code with netbsd
adds detach functionality for phys
some code cleanup

Nobody really had time to test all of this out, but theo said commit anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.8 2000/04/27 07:37:13 niklas Exp $	*/
d118 1
a118 1
		    (bmsr & BMSR_MEDIAMASK) == 0) {
@


1.8
log
@Some PHYs does not report any OUI/MODEL combo, recognize another such case
@
text
@d1 2
a2 2
/*	$OpenBSD: mii.c,v 1.6 1999/12/07 22:01:31 jason Exp $	*/
/*	$NetBSD: mii.c,v 1.9 1998/11/05 04:08:02 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d69 1
a69 1
mii_phy_probe(parent, mii, capmask)
d72 1
a72 1
	int capmask;
d76 2
d79 52
a130 1
	LIST_INIT(&mii->mii_phys);
a131 1
	for (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {
d133 3
a135 2
		 * Check to see if there is a PHY at this address.  If
		 * the register contains garbage, assume no.
a140 21
		if ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&
		    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {
			/*
			 * ARGH!!  3Com internal PHYs report 0/0 in their
			 * ID registers!  If we spot this, check to see
			 * if the BMSR has reasonable data in it.
			 * And if that wasn't enough there are PHYs
			 * reporting 0xffff/0xffff too.
			 */
			if ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&
			    MII_MODEL(ma.mii_id2) == 0) ||
			    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&
			    MII_MODEL(ma.mii_id2) == 0x3f)) {
				int bmsr = (*mii->mii_readreg)(parent,
				    ma.mii_phyno, MII_BMSR);
				if (bmsr == 0 || bmsr == 0xffff ||
				    (bmsr & BMSR_MEDIAMASK) == 0)
					continue;
			} else
				continue;
		}
d144 1
d151 3
d155 1
d158 1
d162 64
a225 10
int
mii_detach(msc, flags)
	struct mii_softc *msc;
	int flags;
{
	LIST_REMOVE(msc, mii_list);
	/* XXX The following condition should always be true.  */
	if (msc->mii_inst == msc->mii_pdata->mii_instance - 1)
		msc->mii_pdata->mii_instance--;
	return config_detach(&msc->mii_dev, flags);
d318 1
a318 1
{ 
d320 1
a320 1
 
d324 1
a324 1
}  
@


1.7
log
@Add simple mii detach routine while waiting for the post-2.7
merge of NetBSD mii work
@
text
@d94 2
d97 4
a100 2
			if (MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&
			    MII_MODEL(ma.mii_id2) == 0) {
@


1.6
log
@Merge with NetBSD:
o move common support functions for phy drivers from mii.c to mii_physubr.c,
	so that they are not includes if no PHY is configured
o Clean up the code that adds media a little, and make media selection
	table-driven in preparation for some other changes to be made.
o Don't add any loopback versions of media, for now.
o Add mii_down(), which is used by MAC drivers to inform PHYs that the
	interface is now down.  PHYs use this to cancel pending asynchronous
	operations.
o Add OUI for Enable Semiconductor.
o New Driver for TDK TSC78Q2120 PHY
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.5 1999/07/23 12:39:11 deraadt Exp $	*/
d118 12
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: mii.c,v 1.9 2000/08/26 20:04:17 nate Exp $	*/
/*	$NetBSD: mii.c,v 1.19 2000/02/02 17:09:44 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
d69 1
a69 1
mii_attach(parent, mii, capmask, phyloc, offloc, flags)
d72 1
a72 1
	int capmask, phyloc, offloc, flags;
a75 2
	int bmsr, offset = 0;
	int phymin, phymax;
d77 1
a77 52
	if (phyloc != MII_PHY_ANY && offloc != MII_PHY_ANY)
		panic("mii_attach: phyloc and offloc specified");

	if (phyloc == MII_PHY_ANY) {
		phymin = 0;
		phymax = MII_NPHY - 1;
	} else
		phymin = phymax = phyloc;

	if ((mii->mii_flags & MIIF_INITDONE) == 0) {
		LIST_INIT(&mii->mii_phys);
		mii->mii_flags |= MIIF_INITDONE;
	}

	for (ma.mii_phyno = phymin; ma.mii_phyno <= phymax; ma.mii_phyno++) {
		/*
		 * Make sure we haven't already configured a PHY at this
		 * address.  This allows mii_attach() to be called
		 * multiple times.
		 */
		for (child = LIST_FIRST(&mii->mii_phys); child != NULL;
		     child = LIST_NEXT(child, mii_list)) {
			if (child->mii_phy == ma.mii_phyno) {
				/*
				 * Yes, there is already something
				 * configured at this address.
				 */
				offset++;
				continue;
			}
		}

		/*
		 * Check to see if there is a PHY at this address.  Note,
		 * many braindead PHYs report 0/0 in their ID registers,
		 * so we test for media in the BMSR.
		 */
		bmsr = (*mii->mii_readreg)(parent, ma.mii_phyno, MII_BMSR);
		if (bmsr == 0 || bmsr == 0xffff ||
		    (bmsr & BMSR_MEDIAMASK) == 0) {
			/* Assume no PHY at this address. */
			continue;
		}

		/*
		 * There is a PHY at this address.  If we were given an
		 * `offset' locator, skip this PHY if it doesn't match.
		 */
		if (offloc != MII_OFFSET_ANY && offloc != offset) {
			offset++;
			continue;
		}
d79 1
d81 2
a82 3
		 * Extract the IDs.  Braindead PHYs will be handled by
		 * the `ukphy' driver, as we have no ID information to
		 * match on.
d88 17
a107 1
		ma.mii_flags = flags;
a113 3
#if defined(__NetBSD__)
			callout_init(&child->mii_nway_ch);
#endif
a114 1
			child->mii_offset = offset;
a116 67
		offset++;
	}
}

void
mii_activate(mii, act, phyloc, offloc)
	struct mii_data *mii;
	enum devact act;
	int phyloc, offloc;
{
	struct mii_softc *child;

	if (phyloc != MII_PHY_ANY && offloc != MII_PHY_ANY)
		panic("mii_activate: phyloc and offloc specified");

	if ((mii->mii_flags & MIIF_INITDONE) == 0)
		return;

	for (child = LIST_FIRST(&mii->mii_phys);
	     child != NULL; child = LIST_NEXT(child, mii_list)) {
		if (phyloc != MII_PHY_ANY || offloc != MII_OFFSET_ANY) {
			if (phyloc != MII_PHY_ANY &&
			    phyloc != child->mii_phy)
				continue;
			if (offloc != MII_OFFSET_ANY &&
			    offloc != child->mii_offset)
				continue;
		}
		switch (act) {
		case DVACT_ACTIVATE:
			panic("mii_activate: DVACT_ACTIVATE");
			break;

		case DVACT_DEACTIVATE:
			if (config_deactivate(&child->mii_dev) != 0)
				panic("%s: config_activate(%d) failed\n",
				    child->mii_dev.dv_xname, act);
		}
	}
}

void
mii_detach(mii, phyloc, offloc)
	struct mii_data *mii;
	int phyloc, offloc;
{
	struct mii_softc *child, *nchild;

	if (phyloc != MII_PHY_ANY && offloc != MII_PHY_ANY)
		panic("mii_detach: phyloc and offloc specified");

	if ((mii->mii_flags & MIIF_INITDONE) == 0)
		return;

	for (child = LIST_FIRST(&mii->mii_phys);
	     child != NULL; child = nchild) {
		nchild = LIST_NEXT(child, mii_list);
		if (phyloc != MII_PHY_ANY || offloc != MII_OFFSET_ANY) {
			if (phyloc != MII_PHY_ANY &&
			    phyloc != child->mii_phy)
				continue;
			if (offloc != MII_OFFSET_ANY &&
			    offloc != child->mii_offset)
				continue;
		}
		LIST_REMOVE(child, mii_list);
		(void) config_detach(&child->mii_dev, DETACH_FORCE);
d210 1
a210 1
{
d212 1
a212 1

d216 1
a216 1
}
@


1.6.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.6.2.1 2001/05/14 22:25:24 niklas Exp $	*/
d118 1
a118 1
		    (bmsr & (BMSR_MEDIAMASK|BMSR_EXTSTAT)) == 0) {
@


1.6.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 2
a59 2
int	mii_print(void *, const char *);
int	mii_submatch(struct device *, void *, void *);
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@d193 1
a193 1
				panic("%s: config_activate(%d) failed",
@


1.5
log
@do not print media information to dmesg; ifconfig shows it
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.4 1999/02/04 23:00:57 jason Exp $	*/
a58 3
#ifdef __NetBSD__
int	mii_submatch __P((struct device *, struct cfdata *, void *));
#else
a59 1
#endif
a60 1
#ifdef __OpenBSD__
a62 1
#endif
a135 8
#ifdef __NetBSD__
int
mii_submatch(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void *aux;
{
#else
a141 1
#endif
a151 52
 * Given an ifmedia word, return the corresponding ANAR value.
 */
int
mii_anar(media)
	int media;
{
	int rv;

	switch (media & (IFM_TMASK|IFM_NMASK|IFM_FDX)) {
	case IFM_ETHER|IFM_10_T:
		rv = ANAR_10|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_10_T|IFM_FDX:
		rv = ANAR_10_FD|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_100_TX:
		rv = ANAR_TX|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_100_TX|IFM_FDX:
		rv = ANAR_TX_FD|ANAR_CSMA;
		break;
	case IFM_ETHER|IFM_100_T4:
		rv = ANAR_T4|ANAR_CSMA;
		break;
	default:
		rv = 0;
		break;
	}

	return (rv);
}

/*
 * Given a BMCR value, return the corresponding ifmedia word.
 */
int
mii_media_from_bmcr(bmcr)
	int bmcr;
{
	int rv = IFM_ETHER;

	if (bmcr & BMCR_S100)
		rv |= IFM_100_TX;
	else
		rv |= IFM_10_T;
	if (bmcr & BMCR_FDX)
		rv |= IFM_FDX;

	return (rv);
}

/*
d205 1
a205 3
 * Initialize generic PHY media based on BMSR, called when a PHY is
 * attached.  We expect to be set up to print a comma-separated list
 * of media names.  Does not print a newline.
d208 1
a208 1
mii_add_media(mii, bmsr, instance)
d210 7
a216 30
	int bmsr, instance;
{
#define	ADD(m, c)	ifmedia_add(&mii->mii_media, (m), (c), NULL)

	if (bmsr & BMSR_10THDX)
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, instance), 0);
	if (bmsr & BMSR_10TFDX)
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, instance),
		    BMCR_FDX);
	if (bmsr & BMSR_100TXHDX)
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, instance),
		    BMCR_S100);
	if (bmsr & BMSR_100TXFDX)
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, instance),
		    BMCR_S100|BMCR_FDX);
	if (bmsr & BMSR_100T4) {
		/*
		 * XXX How do you enable 100baseT4?  I assume we set
		 * XXX BMCR_S100 and then assume the PHYs will take
		 * XXX watever action is necessary to switch themselves
		 * XXX into T4 mode.
		 */
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_T4, 0, instance),
		    BMCR_S100);
	}
	if (bmsr & BMSR_ANEG)
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, instance),
		    BMCR_AUTOEN);
#undef ADD
}
@


1.4
log
@Fix bit test; from netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.3 1999/01/04 03:57:55 jason Exp $	*/
a280 2
	const char *sep = "";

a281 1
#define	PRINT(s)	printf("%s%s", sep, s); sep = ", "
d283 1
a283 1
	if (bmsr & BMSR_10THDX) {
d285 1
a285 3
		PRINT("10baseT");
	}
	if (bmsr & BMSR_10TFDX) {
d288 1
a288 3
		PRINT("10baseT-FDX");
	}
	if (bmsr & BMSR_100TXHDX) {
d291 1
a291 3
		PRINT("100baseTX");
	}
	if (bmsr & BMSR_100TXFDX) {
a293 2
		PRINT("100baseTX-FDX");
	}
a302 1
		PRINT("100baseT4");
d304 1
a304 1
	if (bmsr & BMSR_ANEG) {
a306 2
		PRINT("auto");
	}
a307 1
#undef PRINT
@


1.3
log
@Make sure both phyid registers have bogus values before assuming
it's a phy with no phyid.
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.2 1998/11/11 19:34:47 jason Exp $	*/
d212 1
a212 1
	if (bmcr & IFM_FDX)
@


1.2
log
@Merge with NetBSD:
o additional phy drivers (seeq, ics, level1)
o "unknown phy" driver for unsupported phys
o collected common code into mii_physubr
o exphy isn't the only phy that doesn't have valid id registers
@
text
@d1 1
a1 1
/*	$OpenBSD: mii.c,v 1.1 1998/09/10 17:17:33 jason Exp $	*/
d94 2
a95 2
		if (ma.mii_id1 == 0 || ma.mii_id1 == 0xffff ||
		    ma.mii_id2 == 0 || ma.mii_id2 == 0xffff) {
@


1.1
log
@OpenBSD gets sys/dev/mii layer from NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mii.c,v 1.7 1998/08/11 00:41:44 thorpej Exp $	*/
d134 1
a134 1
		printf("PHY oui 0x%x model 0x%x rev 0x%x at %s",
d195 19
@

