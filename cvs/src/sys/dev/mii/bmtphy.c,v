head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.10
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.4
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.14
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.10
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.8
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.20
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.19;
commitid	p4LJxGKbi0BU2cG6;

1.19
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.18;
commitid	t9FBKDfc4VDxpEy2;

1.18
date	2013.12.28.03.30.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.25.09.56.24;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.27.19.11.08;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.06.22.50.15;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.25.20.05.44;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.26.04.40.09;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.04.23.23.56;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.28.18.27.55;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.24.01.58.02;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.27.18.25.48;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.26.03.38.34;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.26.00.59.58;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.20.06.05.27;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.05.18.26.48;	author nate;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.06.18.06.31.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.01.21.40.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.11.06.47.31;	author deraadt;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.25.19;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.07.04.10.41.38;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.10.31.03.22.44;	author nate;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.42.23;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: bmtphy.c,v 1.19 2014/12/05 15:50:04 mpi Exp $	*/
/*	$NetBSD: bmtphy.c,v 1.17 2005/01/17 13:17:45 scw Exp $	*/

/*-
 * Copyright (c) 2001 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Driver for Broadcom BCM5201/BCM5202 "Mini-Theta" PHYs.  This also
 * drives the PHY on the 3Com 3c905C.  The 3c905C's PHY is described in
 * the 3c905C data sheet.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_media.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <dev/mii/bmtphyreg.h>

int	bmtphymatch(struct device *, void *, void *);
void	bmtphyattach(struct device *, struct device *, void *);

struct cfattach bmtphy_ca = {
	sizeof(struct mii_softc), bmtphymatch, bmtphyattach, mii_phy_detach
};

struct cfdriver bmtphy_cd = {
	NULL, "bmtphy", DV_DULL
};

int	bmtphy_service(struct mii_softc *, struct mii_data *, int);
void	bmtphy_status(struct mii_softc *);
void	bmtphy_reset(struct mii_softc *);

const struct mii_phy_funcs bmtphy_funcs = {
	bmtphy_service, bmtphy_status, bmtphy_reset,
};

static const struct mii_phydesc bmtphys[] = {
	{ MII_OUI_BROADCOM,		MII_MODEL_BROADCOM_3C905B,
	  MII_STR_BROADCOM_3C905B },
	{ MII_OUI_BROADCOM,		MII_MODEL_BROADCOM_3C905C,
	  MII_STR_BROADCOM_3C905C },
	{ MII_OUI_BROADCOM,		MII_MODEL_BROADCOM_BCM4401,
	  MII_STR_BROADCOM_BCM4401 },
	{ MII_OUI_BROADCOM,		MII_MODEL_BROADCOM_BCM5201,
	  MII_STR_BROADCOM_BCM5201 },
	{ MII_OUI_BROADCOM,		MII_MODEL_BROADCOM_BCM5214,
	  MII_STR_BROADCOM_BCM5214 },
	{ MII_OUI_BROADCOM,		MII_MODEL_BROADCOM_BCM5220,
	  MII_STR_BROADCOM_BCM5220 },
	{ MII_OUI_BROADCOM,		MII_MODEL_BROADCOM_BCM5221,
	  MII_STR_BROADCOM_BCM5221 },
	{ MII_OUI_BROADCOM,		MII_MODEL_BROADCOM_BCM5222,
	  MII_STR_BROADCOM_BCM5222 },

	{ 0,				0,
	  NULL },
};

int
bmtphymatch(struct device *parent, void *match, void *aux)
{
	struct mii_attach_args *ma = aux;

	if (mii_phy_match(ma, bmtphys) != NULL)
		return (10);

	return (0);
}

void
bmtphyattach(struct device *parent, struct device *self, void *aux)
{
	struct mii_softc *sc = (struct mii_softc *)self;
	struct mii_attach_args *ma = aux;
	struct mii_data *mii = ma->mii_data;
	const struct mii_phydesc *mpd;

	mpd = mii_phy_match(ma, bmtphys);
	printf(": %s, rev. %d\n", mpd->mpd_name, MII_REV(ma->mii_id2));

	sc->mii_model = MII_MODEL(ma->mii_id2);
	sc->mii_inst = mii->mii_instance;
	sc->mii_phy = ma->mii_phyno;
	sc->mii_funcs = &bmtphy_funcs;
	sc->mii_pdata = mii;
	sc->mii_flags = ma->mii_flags;
	sc->mii_anegticks = MII_ANEGTICKS;

	PHY_RESET(sc);

	/*
	 * XXX Check AUX_STS_FX_MODE to set MIIF_HAVE_FIBER?
	 */

	sc->mii_capabilities =
	    PHY_READ(sc, MII_BMSR) & ma->mii_capmask;
	if (sc->mii_capabilities & BMSR_MEDIAMASK)
		mii_phy_add_media(sc);
}

int
bmtphy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
{
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int reg;

	if ((sc->mii_dev.dv_flags & DVF_ACTIVE) == 0)
		return (ENXIO);

	switch (cmd) {
	case MII_POLLSTAT:
		/*
		 * If we're not polling our PHY instance, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);
		break;

	case MII_MEDIACHG:
		/*
		 * If the media indicates a different PHY instance,
		 * isolate ourselves.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst) {
			reg = PHY_READ(sc, MII_BMCR);
			PHY_WRITE(sc, MII_BMCR, reg | BMCR_ISO);
			return (0);
		}

		/*
		 * If the interface is not up, don't do anything.
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			break;

		mii_phy_setmedia(sc);
		break;

	case MII_TICK:
		/*
		 * If we're not currently selected, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);

		if (mii_phy_tick(sc) == EJUSTRETURN)
			return (0);
		break;

	case MII_DOWN:
		mii_phy_down(sc);
		return (0);
	}

	/* Update the media status. */
	mii_phy_status(sc);

	/* Callback if something changed. */
	mii_phy_update(sc, cmd);
	return (0);
}

void
bmtphy_status(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int bmsr, bmcr, aux_csr;

	mii->mii_media_status = IFM_AVALID;
	mii->mii_media_active = IFM_ETHER;

	bmsr = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
	if (bmsr & BMSR_LINK)
		mii->mii_media_status |= IFM_ACTIVE;

	bmcr = PHY_READ(sc, MII_BMCR);
	if (bmcr & BMCR_ISO) {
		mii->mii_media_active |= IFM_NONE;
		mii->mii_media_status = 0;
		return;
	}

	if (bmcr & BMCR_LOOP)
		mii->mii_media_active |= IFM_LOOP;

	if (bmcr & BMCR_AUTOEN) {
		/*
		 * The later are only valid if autonegotiation
		 * has completed (or it's disabled).
		 */
		if ((bmsr & BMSR_ACOMP) == 0) {
			/* Erg, still trying, I guess... */
			mii->mii_media_active |= IFM_NONE;
			return;
		}

		aux_csr = PHY_READ(sc, MII_BMTPHY_AUX_CSR);
		if (aux_csr & AUX_CSR_SPEED)
			mii->mii_media_active |= IFM_100_TX;
		else
			mii->mii_media_active |= IFM_10_T;

		if (aux_csr & AUX_CSR_FDX)
			mii->mii_media_active |= mii_phy_flowstatus(sc) | IFM_FDX;
		else
			mii->mii_media_active |= IFM_HDX;
	} else
		mii->mii_media_active = ife->ifm_media;
}

void
bmtphy_reset(struct mii_softc *sc)
{
	u_int16_t data;

	mii_phy_reset(sc);

	if (sc->mii_model == MII_MODEL_BROADCOM_BCM5221) {
		/* Enable shadow register mode */
		data = PHY_READ(sc, 0x1f);
		PHY_WRITE(sc, 0x1f, data | 0x0080);

		/* Enable APD (Auto PowerDetect) */
		data = PHY_READ(sc, MII_BMTPHY_AUX2);
		PHY_WRITE(sc, MII_BMTPHY_AUX2, data | 0x0020);

		/* Enable clocks across APD for
		 * Auto-MDIX functionality */
		data = PHY_READ(sc, MII_BMTPHY_INTR);
		PHY_WRITE(sc, MII_BMTPHY_INTR, data | 0x0004);

		/* Disable shadow register mode */
		data = PHY_READ(sc, 0x1f);
		PHY_WRITE(sc, 0x1f, data & ~0x0080);
	}
}
@


1.19
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.18 2013/12/28 03:30:40 deraadt Exp $	*/
a36 1
#include <sys/kernel.h>
@


1.18
log
@mii drivers no longer need activate functions.  Repair of the PHY
configuration setting is done at resume time because all networks
drivers which were previously up, do an IFF_UP operation which
hits PHY_RESET.
This was in snapshots for about 2 weeks.
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.17 2009/07/25 09:56:24 sthen Exp $	*/
d43 1
@


1.17
log
@Add flow control status reporting. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.16 2006/12/27 19:11:08 kettenis Exp $	*/
d55 1
a55 2
	sizeof(struct mii_softc), bmtphymatch, bmtphyattach, mii_phy_detach,
	    mii_phy_activate
@


1.16
log
@Always explicitly set IFM_HDX for half-duplex.

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.15 2005/11/06 22:50:15 brad Exp $	*/
d239 1
a239 1
			mii->mii_media_active |= IFM_FDX;
@


1.15
log
@Add some DSP init code for BCM5221's.

Values derived from Apple's GMAC driver, same init
code also exists in Linux's sungem_phy driver.

tested by miod@@ pedro@@ and otto@@ on a few systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.14 2005/05/25 20:05:44 brad Exp $	*/
d237 1
d240 2
a241 1

@


1.14
log
@BCM5220
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.13 2005/03/26 04:40:09 krw Exp $	*/
d65 1
d68 1
a68 1
	bmtphy_service, bmtphy_status, mii_phy_reset,
d115 1
d242 27
@


1.13
log
@Cleanup. Use defines, standard names, consistant comparison operators, etc.
for auto negotiation ticks code. No functional change.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.12 2005/02/04 23:23:56 brad Exp $	*/
d81 2
@


1.12
log
@- attach 3com 3c905C PHY with bmtphy
- use mii_phy_reset() instead of bmtphy_reset()
- use mii_phy_match()
- sync bmtphyreg.h to NetBSD

Tested on a few bce(4), gem(4), xl(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.11 2005/01/28 18:27:55 brad Exp $	*/
d117 1
a117 1
	sc->mii_anegticks = 5;
@


1.11
log
@Get flags passed down to PHY drivers correctly.  This was done on
an adhoc basis in a couple of PHY drivers, this fixes it more generally.

From NetBSD

Fixes panics with aue(4) NICs.
@
text
@d1 2
a2 2
/*	$OpenBSD: bmtphy.c,v 1.10 2005/01/24 01:58:02 brad Exp $	*/
/*	$NetBSD: nsphy.c,v 1.25 2000/02/02 23:34:57 thorpej Exp $	*/
d30 3
a32 2
 * driver for Broadcom BCM5201/5202 Mini-Theta ethernet 10/100 PHY
 * Data Sheet available from Broadcom
a64 1
void	bmtphy_reset(struct mii_softc *);
d67 21
a87 1
	bmtphy_service, bmtphy_status, bmtphy_reset,
d95 1
a95 14
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_BROADCOM &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM4401)
		return (10);
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_BROADCOM &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5201)
		return (10);
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_BROADCOM &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5214)
		return (10);
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_BROADCOM &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5221)
		return (10);
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_BROADCOM &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5222)
d107 1
a107 12
	char *model;

	if (MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM4401)
		model = MII_STR_BROADCOM_BCM4401;
	else if (MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5201)
		model = MII_STR_BROADCOM_BCM5201;
	else if (MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5214)
		model = MII_STR_BROADCOM_BCM5214;
	else if (MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5221)
		model = MII_STR_BROADCOM_BCM5221;
	else if (MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5222)
		model = MII_STR_BROADCOM_BCM5222;
d109 2
a110 1
	printf(": %s, rev. %d\n", model, MII_REV(ma->mii_id2));
d198 1
a198 1
	int bmsr, bmcr, auxc;
d203 1
a203 2
	bmsr = PHY_READ(sc, MII_BMSR) |
	    PHY_READ(sc, MII_BMSR);
d228 2
a229 2
		auxc = PHY_READ(sc, MII_BMTPHY_AUXC);
		if (auxc & AUXC_SP100)
d233 1
a233 1
		if (auxc & AUXC_FDX)
a237 16
}

void
bmtphy_reset(struct mii_softc *sc)
{
	int anar;

	mii_phy_reset(sc);

	anar = PHY_READ(sc, MII_ANAR);
	anar |= BMSR_MEDIA_TO_ANAR(PHY_READ(sc, MII_BMSR));
	PHY_WRITE(sc, MII_ANAR, anar);

        /* Chip resets with FDX bit not set */
        PHY_WRITE(sc, MII_BMCR, PHY_READ(sc, MII_BMCR) |
	    BMCR_S100|BMCR_AUTOEN|BMCR_STARTNEG|BMCR_FDX);
@


1.10
log
@more Broadcom PHY
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.9 2004/09/27 18:25:48 brad Exp $	*/
d119 1
a119 1
	sc->mii_flags = mii->mii_flags;
@


1.9
log
@ANSI protos and some minor cleanup

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.8 2004/09/26 03:38:34 brad Exp $	*/
d76 3
d82 3
d87 3
d102 3
a104 1
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5201)
d106 2
d110 2
d123 4
@


1.8
log
@simplify MII_TICK case by using mii_phy_tick().
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.7 2004/09/26 00:59:58 brad Exp $	*/
d71 1
a71 4
bmtphymatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d86 1
a86 4
bmtphyattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d116 1
a116 4
bmtphy_service(sc, mii, cmd)
	struct mii_softc *sc;
	struct mii_data *mii;
	int cmd;
d178 1
a178 2
bmtphy_status(sc)
	struct mii_softc *sc;
d226 1
a226 2
bmtphy_reset(sc)
	struct mii_softc *sc;
@


1.7
log
@Restructure the PHY entry points to use a structure of
entry points instead of descrete function pointers, and
extend this to include a "reset" entry point. Make sure
any PHY-specific reset routine is always used.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.6 2004/09/20 06:05:27 brad Exp $	*/
d169 1
a169 31
		/*
		 * Only used for autonegotiation.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			return (0);

		/*
		 * Is the interface even up?
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			return (0);

		/*
		 * Check to see if we have link.  If we do, we don't
		 * need to restart the autonegotiation process.  Read
		 * the BMSR twice in case it's latched.
		 */
		reg = PHY_READ(sc, MII_BMSR) |
		    PHY_READ(sc, MII_BMSR);
		if (reg & BMSR_LINK)
			return (0);

		/*
		 * Only retry autonegotiation every 5 seconds.
		 */
		if (++sc->mii_ticks != sc->mii_anegticks)
			return (0);

		sc->mii_ticks = 0;
		bmtphy_reset(sc);
		if (mii_phy_auto(sc, 0) == EJUSTRETURN)
@


1.6
log
@don't include sys/malloc.h, no memory management functions are used
by any of the MII drivers.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.5 2002/03/14 01:26:57 millert Exp $	*/
d66 4
d108 1
a108 2
	sc->mii_service = bmtphy_service;
	sc->mii_status = bmtphy_status;
d113 1
a113 1
	bmtphy_reset(sc);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.4 2001/10/05 18:26:48 nate Exp $	*/
a37 1
#include <sys/malloc.h>
@


1.4
log
@use anegticks for phys that do their own autonegotiation timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.3 2001/06/18 06:31:59 deraadt Exp $	*/
d51 2
a52 2
int	bmtphymatch __P((struct device *, void *, void *));
void	bmtphyattach __P((struct device *, struct device *, void *));
d63 3
a65 3
int	bmtphy_service __P((struct mii_softc *, struct mii_data *, int));
void	bmtphy_status __P((struct mii_softc *));
void	bmtphy_reset __P((struct mii_softc *));
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.4 2001/10/05 18:26:48 nate Exp $	*/
d51 2
a52 2
int	bmtphymatch(struct device *, void *, void *);
void	bmtphyattach(struct device *, struct device *, void *);
d63 3
a65 3
int	bmtphy_service(struct mii_softc *, struct mii_data *, int);
void	bmtphy_status(struct mii_softc *);
void	bmtphy_reset(struct mii_softc *);
@


1.3
log
@copyright notices; noted missing by nate
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.2 2001/06/01 21:40:48 deraadt Exp $	*/
d109 1
d192 1
a192 1
		if (++sc->mii_ticks != 5)
@


1.2
log
@support BCM5221
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.1 2001/04/11 06:47:31 deraadt Exp $	*/
d3 25
@


1.1
log
@driver for BCM5201/5202 PHY
@
text
@d1 1
a1 1
/*	$OpenBSD: nsphy.c,v 1.9 2000/08/26 20:04:18 nate Exp $	*/
d53 3
d69 6
d76 1
a76 2
	printf(": %s, rev. %d\n", MII_STR_BROADCOM_BCM5201,
	    MII_REV(ma->mii_id2));
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.1 2001/04/11 06:47:31 deraadt Exp $	*/
@


1.1.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.1.4.1 2001/05/14 22:25:19 niklas Exp $	*/
a3 25
/*-
 * Copyright (c) 2001 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

a52 3
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_BROADCOM &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5221)
		return (10);
a65 6
	char *model;

	if (MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5201)
		model = MII_STR_BROADCOM_BCM5201;
	else if (MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5221)
		model = MII_STR_BROADCOM_BCM5221;
d67 2
a68 1
	printf(": %s, rev. %d\n", model, MII_REV(ma->mii_id2));
@


1.1.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bmtphy.c,v 1.1.4.2 2001/07/04 10:41:38 niklas Exp $	*/
a108 1
	sc->mii_anegticks = 5;
d191 1
a191 1
		if (++sc->mii_ticks != sc->mii_anegticks)
@


1.1.4.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 2
a52 2
int	bmtphymatch(struct device *, void *, void *);
void	bmtphyattach(struct device *, struct device *, void *);
d63 3
a65 3
int	bmtphy_service(struct mii_softc *, struct mii_data *, int);
void	bmtphy_status(struct mii_softc *);
void	bmtphy_reset(struct mii_softc *);
@


