head	1.25;
access;
symbols
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.16
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.14
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.12
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.10
	OPENBSD_5_0:1.22.0.8
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.9.0.8
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.25
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.24;
commitid	p4LJxGKbi0BU2cG6;

1.24
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.23;
commitid	t9FBKDfc4VDxpEy2;

1.23
date	2013.12.28.03.30.41;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.22.10.39.51;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.24.17.11.37;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.30.05.08.29;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2008.04.02.22.14.29;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.27.19.11.09;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.22.04.45.13;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.27.09.24.01;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.26.04.40.09;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.19.06.00.04;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.28.18.27.55;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.27.18.25.48;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.26.00.59.58;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.20.06.05.27;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.26.06.01.28;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.04.11.30.06;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.05.18.29.15;	author nate;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.10.05.18.26.48;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.19.15.07.34;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.02.06.29.49;	author nate;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.07.02.05.08.28;	author nate;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.08.02.19.30;	author nate;	state Exp;
branches;
next	;

1.3.2.1
date	2001.10.31.03.22.44;	author nate;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.05.19.22.20.35;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: nsgphy.c,v 1.24 2014/12/05 15:50:04 mpi Exp $	*/
/*
 * Copyright (c) 2001 Wind River Systems
 * Copyright (c) 2001
 *	Bill Paul <wpaul@@bsdi.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Driver for the National Semiconductor DP83861, DP83865 and DP83891
 * 10/100/1000 PHYs.
 * Datasheet available at: http://www.national.com/ds/DP/DP83861.pdf
 * and at: http://www.national.com/ds/DP/DP83865.pdf
 *
 * The DP83891 is the older NatSemi gigE PHY which isn't being sold
 * anymore. The DP83861 is its replacement, which is an 'enhanced'
 * firmware driven component. The major difference between the
 * two is that the 83891 can't generate interrupts, while the
 * 83861 can. (I think it wasn't originally designed to do this, but
 * it can now thanks to firmware updates.) The 83861 also allows
 * access to its internal RAM via indirect register access.
 *
 * The DP83865 is a low power version of the DP83861.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_media.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <dev/mii/nsgphyreg.h>

int	nsgphymatch(struct device*, void *, void *);
void	nsgphyattach(struct device *, struct device *, void *);

struct cfattach nsgphy_ca = {
	sizeof(struct mii_softc), nsgphymatch, nsgphyattach, mii_phy_detach
};

struct cfdriver nsgphy_cd = {
	NULL, "nsgphy", DV_DULL
};

int	nsgphy_service(struct mii_softc *, struct mii_data *, int);
void	nsgphy_status(struct mii_softc *);

const struct mii_phy_funcs nsgphy_funcs = {
	nsgphy_service, nsgphy_status, mii_phy_reset,
};

static const struct mii_phydesc nsgphys[] = {
	{ MII_OUI_NATSEMI,		MII_MODEL_NATSEMI_DP83861,
	  MII_STR_NATSEMI_DP83861 },
	{ MII_OUI_NATSEMI,		MII_MODEL_NATSEMI_DP83865,
	  MII_STR_NATSEMI_DP83865 },
	{ MII_OUI_NATSEMI,		MII_MODEL_NATSEMI_DP83891,
	  MII_STR_NATSEMI_DP83891 },

	{ 0,			0,
	  NULL },
};

int
nsgphymatch(struct device *parent, void *match, void *aux)
{
	struct mii_attach_args *ma = aux;

	if (mii_phy_match(ma, nsgphys) != NULL)
		return (10);

	return (0);
}

void
nsgphyattach(struct device *parent, struct device *self, void *aux)
{
	struct mii_softc *sc = (struct mii_softc *)self;
	struct mii_attach_args *ma = aux;
	struct mii_data *mii = ma->mii_data;
	const struct mii_phydesc *mpd;
	int anar;

	mpd = mii_phy_match(ma, nsgphys);
	printf(": %s, rev. %d\n", mpd->mpd_name, MII_REV(ma->mii_id2));

	sc->mii_inst = mii->mii_instance;
	sc->mii_phy = ma->mii_phyno;
	sc->mii_funcs = &nsgphy_funcs;
	sc->mii_pdata = mii;
	sc->mii_flags = ma->mii_flags;
	sc->mii_anegticks = MII_ANEGTICKS;

	PHY_RESET(sc);

	sc->mii_capabilities =
		PHY_READ(sc, MII_BMSR) & ma->mii_capmask;
	if (sc->mii_capabilities & BMSR_EXTSTAT)
		sc->mii_extcapabilities = PHY_READ(sc, MII_EXTSR);

	/*
	 * The PHY seems to have the 10baseT BMSR bits
	 * hard-wired to 0, even though the device supports
	 * 10baseT.  What we do instead is read the post-reset
	 * ANAR, who's 10baseT-related bits are set by strapping
	 * pin 180, and fake the BMSR bits.
	 */
	anar = PHY_READ(sc, MII_ANAR);
	if (anar & ANAR_10)
		sc->mii_capabilities |= (BMSR_10THDX & ma->mii_capmask);
	if (anar & ANAR_10_FD)
		sc->mii_capabilities |= (BMSR_10TFDX & ma->mii_capmask);

	if ((sc->mii_capabilities & BMSR_MEDIAMASK) ||
	    (sc->mii_extcapabilities & EXTSR_MEDIAMASK))
		mii_phy_add_media(sc);
}

int
nsgphy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
{
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int reg;

	if ((sc->mii_dev.dv_flags & DVF_ACTIVE) == 0)
		return (ENXIO);

	switch (cmd) {
	case MII_POLLSTAT:
		/*
		 * If we're not polling our PHY instance, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);
		break;

	case MII_MEDIACHG:
		/*
		 * If the media indicates a different PHY instance,
		 * isolate ourselves.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst) {
			reg = PHY_READ(sc, MII_BMCR);
			PHY_WRITE(sc, MII_BMCR, reg | BMCR_ISO);
			return (0);
		}

		/*
		 * If the interface is not up, don't do anything.
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			break;

		mii_phy_setmedia(sc);
		break;

	case MII_TICK:
		/*
		 * If we're not currently selected, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);

		if (mii_phy_tick(sc) == EJUSTRETURN)
			return (0);
		break;
	case MII_DOWN:
		mii_phy_down(sc);
		return (0);
	}

	/* Update the media status. */
	mii_phy_status(sc);

	/* Callback if something changed. */
	mii_phy_update(sc, cmd);
	return (0);
}

void
nsgphy_status(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int bmsr, bmcr, physup, gtsr;

	mii->mii_media_status = IFM_AVALID;
	mii->mii_media_active = IFM_ETHER;

	bmsr = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);

	physup = PHY_READ(sc, NSGPHY_MII_PHYSUP);

	if (physup & PHY_SUP_LINK)
		mii->mii_media_status |= IFM_ACTIVE;

	bmcr = PHY_READ(sc, MII_BMCR);
	if (bmcr & BMCR_ISO) {
		mii->mii_media_active |= IFM_NONE;
		mii->mii_media_status = 0;
		return;
	}

	if (bmcr & BMCR_LOOP)
		mii->mii_media_active |= IFM_LOOP;

	if (bmcr & BMCR_AUTOEN) {
		if ((bmsr & BMSR_ACOMP) == 0) {
			/* Erg, still trying, I guess... */
			mii->mii_media_active |= IFM_NONE;
			return;
		}

		switch (physup & (PHY_SUP_SPEED1|PHY_SUP_SPEED0)) {
		case PHY_SUP_SPEED1:
			mii->mii_media_active |= IFM_1000_T;
			gtsr = PHY_READ(sc, MII_100T2SR);
			if (gtsr & GTSR_MS_RES)
				mii->mii_media_active |= IFM_ETH_MASTER;
			break;

		case PHY_SUP_SPEED0:
			mii->mii_media_active |= IFM_100_TX;
			break;

		case 0:
			mii->mii_media_active |= IFM_10_T;
			break;

		default:
			mii->mii_media_active |= IFM_NONE;
			mii->mii_media_status = 0;
			return;
		}

		if (physup & PHY_SUP_DUPLEX)
			mii->mii_media_active |= mii_phy_flowstatus(sc) | IFM_FDX;
		else
			mii->mii_media_active |= IFM_HDX;
	} else
		mii->mii_media_active = ife->ifm_media;
}
@


1.24
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.23 2013/12/28 03:30:41 deraadt Exp $	*/
a54 1
#include <sys/kernel.h>
@


1.23
log
@mii drivers no longer need activate functions.  Repair of the PHY
configuration setting is done at resume time because all networks
drivers which were previously up, do an IFF_UP operation which
hits PHY_RESET.
This was in snapshots for about 2 weeks.
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.22 2009/07/22 10:39:51 sthen Exp $	*/
d60 1
@


1.22
log
@Comment diff only; list an additional supported PHY and add a link
to the datasheet. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.21 2008/10/24 17:11:37 brad Exp $	*/
d72 1
a72 2
	sizeof(struct mii_softc), nsgphymatch, nsgphyattach, mii_phy_detach,
	mii_phy_activate
@


1.21
log
@Get flow control negotiation status.
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.20 2008/05/30 05:08:29 brad Exp $	*/
d37 1
a37 1
 * Driver for the National Semiconductor DP83891 and DP83861
d40 1
@


1.20
log
@some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.19 2008/04/02 22:14:29 kettenis Exp $	*/
d271 1
a271 1
			mii->mii_media_active |= IFM_FDX;
@


1.19
log
@Add support for the DP83865.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.18 2006/12/27 19:11:09 kettenis Exp $	*/
d132 1
a132 1
        if (sc->mii_capabilities & BMSR_EXTSTAT)
d148 3
a150 3
        if ((sc->mii_capabilities & BMSR_MEDIAMASK) ||
            (sc->mii_extcapabilities & EXTSR_MEDIAMASK))
                mii_phy_add_media(sc);
@


1.18
log
@Always explicitly set IFM_HDX for half-duplex.

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.17 2006/07/22 04:45:13 brad Exp $	*/
d48 2
d89 2
@


1.17
log
@On the Gig PHYTER, for whatever reason, the 10baseT-related bits of the
BMSR are wired to 0, yet the PHY supports 10baseT.  So, to get around
this, we test the ANAR 10baseT bits after a PHY reset.  These bits are
set according to input pin 180.  If we see the 10baseT ANAR bits set,
we fake them in the BMSR so that we can actually autonegotiate 10baseT.

From thorpej@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.16 2005/05/27 09:24:01 brad Exp $	*/
d263 1
d265 1
d268 2
@


1.16
log
@modernize and cleanup the nsgphy code, using mii_phy_setmedia/mii_phy_tick
and the generic MII #defines
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.15 2005/03/26 04:40:09 krw Exp $	*/
d112 1
d124 2
d130 14
@


1.15
log
@Cleanup. Use defines, standard names, consistant comparison operators, etc.
for auto negotiation ticks code. No functional change.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.14 2005/02/19 06:00:04 brad Exp $	*/
a79 2
int	nsgphy_mii_phy_auto(struct mii_softc *, int);

d121 1
a121 3
	sc->mii_anegticks = MII_ANEGTICKS_GIGE;

	PHY_RESET(sc);
a129 9

#if 0
        strap = PHY_READ(sc, MII_GPHYTER_STRAP);
        printf("%s: strapped to %s mode", sc->mii_dev.dv_xname,
	       (strap & STRAP_MS_VAL) ? "master" : "slave");
        if (strap & STRAP_NC_MODE)
                printf(", pre-C5 BCM5400 compat enabled");
        printf("\n");
#endif
d167 1
a167 47
		switch (IFM_SUBTYPE(ife->ifm_media)) {
		case IFM_AUTO:
			(void) nsgphy_mii_phy_auto(sc, 0);
			break;
		case IFM_1000_T:
			if ((ife->ifm_media & IFM_GMASK) == IFM_FDX) {
				PHY_WRITE(sc, NSGPHY_MII_BMCR,
				    NSGPHY_BMCR_FDX|NSGPHY_BMCR_SPD1);
			} else {
				PHY_WRITE(sc, NSGPHY_MII_BMCR,
				    NSGPHY_BMCR_SPD1);
			}
			PHY_WRITE(sc, NSGPHY_MII_ANAR, NSGPHY_SEL_TYPE);

			/*
			 * When setting the link manually, one side must
			 * be the master and the other the slave. However
			 * ifmedia doesn't give us a good way to specify
			 * this, so we fake it by using one of the LINK
			 * flags. If LINK0 is set, we program the PHY to
			 * be a master, otherwise it's a slave.
			 */
			if ((mii->mii_ifp->if_flags & IFF_LINK0)) {
				PHY_WRITE(sc, NSGPHY_MII_1000CTL,
				    NSGPHY_1000CTL_MSE|NSGPHY_1000CTL_MSC);
			} else {
				PHY_WRITE(sc, NSGPHY_MII_1000CTL,
				    NSGPHY_1000CTL_MSE);
			}
			break;
		case IFM_100_T4:
			/*
			 * XXX Not supported as a manual setting right now.
			 */
			return (EINVAL);
		case IFM_NONE:
			PHY_WRITE(sc, MII_BMCR, BMCR_ISO|BMCR_PDOWN);
			break;
		default:
			/*
			 * BMCR data is stored in the ifmedia entry.
			 */
			PHY_WRITE(sc, MII_ANAR,
			    mii_anar(ife->ifm_media));
			PHY_WRITE(sc, MII_BMCR, ife->ifm_data);
			break;
		}
d177 1
a177 16
		/*
		 * Only used for autonegotiation.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			return (0);

		/*
		 * Is the interface even up?
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			return (0);

		/*
	 	 * Only retry autonegotiation every mii_anegticks seconds.
		 */
		if (++sc->mii_ticks <= sc->mii_anegticks)
a178 13

		sc->mii_ticks = 0;

		/*
		 * Check to see if we have link.
		 */
		reg = PHY_READ(sc, NSGPHY_MII_PHYSUP);
		if (reg & NSGPHY_PHYSUP_LNKSTS)
			break;

		PHY_RESET(sc);
		if (nsgphy_mii_phy_auto(sc, 0) == EJUSTRETURN)
			return(0);
d197 2
a198 1
	int bmsr, bmcr, physup, anlpar, gstat;
d203 2
a204 1
	bmsr = PHY_READ(sc, NSGPHY_MII_BMSR) | PHY_READ(sc, NSGPHY_MII_BMSR);
d206 2
a207 1
	if (physup & NSGPHY_PHYSUP_LNKSTS)
d210 6
a215 1
	bmcr = PHY_READ(sc, NSGPHY_MII_BMCR);
d217 1
a217 1
	if (bmcr & NSGPHY_BMCR_LOOP)
d220 2
a221 2
	if (bmcr & NSGPHY_BMCR_AUTOEN) {
		if ((bmsr & NSGPHY_BMSR_ACOMP) == 0) {
a225 20
		anlpar = PHY_READ(sc, NSGPHY_MII_ANLPAR);
		gstat = PHY_READ(sc, NSGPHY_MII_1000STS);
		if (gstat & NSGPHY_1000STS_LPFD)
			mii->mii_media_active |= IFM_1000_T|IFM_FDX;
		else if (gstat & NSGPHY_1000STS_LPHD)
			mii->mii_media_active |= IFM_1000_T|IFM_HDX;
		else if (anlpar & NSGPHY_ANLPAR_100T4)
			mii->mii_media_active |= IFM_100_T4;
		else if (anlpar & NSGPHY_ANLPAR_100FDX)
			mii->mii_media_active |= IFM_100_TX|IFM_FDX;
		else if (anlpar & NSGPHY_ANLPAR_100HDX)
			mii->mii_media_active |= IFM_100_TX;
		else if (anlpar & NSGPHY_ANLPAR_10FDX)
			mii->mii_media_active |= IFM_10_T|IFM_FDX;
		else if (anlpar & NSGPHY_ANLPAR_10HDX)
			mii->mii_media_active |= IFM_10_T|IFM_HDX;
		else
			mii->mii_media_active |= IFM_NONE;
		return;
	}
d227 7
a233 13
	switch(bmcr & (NSGPHY_BMCR_SPD1|NSGPHY_BMCR_SPD0)) {
	case NSGPHY_S1000:
		mii->mii_media_active |= IFM_1000_T;
		break;
	case NSGPHY_S100:
		mii->mii_media_active |= IFM_100_TX;
		break;
	case NSGPHY_S10:
		mii->mii_media_active |= IFM_10_T;
		break;
	default:
		break;
	}
d235 3
a237 4
	if (bmcr & NSGPHY_BMCR_FDX)
		mii->mii_media_active |= IFM_FDX;
	else
		mii->mii_media_active |= IFM_HDX;
d239 3
a241 2
	return;
}
d243 3
a245 34

int
nsgphy_mii_phy_auto(struct mii_softc *sc, int waitfor)
{
	int bmsr, ktcr = 0, i;

	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		PHY_RESET(sc);
		PHY_WRITE(sc, NSGPHY_MII_BMCR, 0);
		DELAY(1000);
		ktcr = PHY_READ(sc, NSGPHY_MII_1000CTL);
		PHY_WRITE(sc, NSGPHY_MII_1000CTL, ktcr |
		    (NSGPHY_1000CTL_AFD|NSGPHY_1000CTL_AHD));
		ktcr = PHY_READ(sc, NSGPHY_MII_1000CTL);
		DELAY(1000);
		PHY_WRITE(sc, NSGPHY_MII_ANAR,
		    BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA);
		DELAY(1000);
		PHY_WRITE(sc, NSGPHY_MII_BMCR,
		    NSGPHY_BMCR_AUTOEN | NSGPHY_BMCR_STARTNEG);
	}

	if (waitfor) {
		/* Wait 500ms for it to complete. */
		for (i = 0; i < 500; i++) {
			if ((bmsr = PHY_READ(sc, NSGPHY_MII_BMSR)) &
			    NSGPHY_BMSR_ACOMP)
				return (0);
			DELAY(1000);
#if 0
		if ((bmsr & BMSR_ACOMP) == 0)
			printf("%s: autonegotiation failed to complete\n",
			    mii->mii_dev.dv_xname);
#endif
d247 4
a250 20

		/*
		 * Don't need to worry about clearing MIIF_DOINGAUTO.
		 * If that's set, a timeout is pending, and it will
		 * clear the flag.
		 */
		return (EIO);
	}

	/*
	 * Just let it finish asynchronously.  This is for the benefit of
	 * the tick handler driving autonegotiation.  Don't want 500ms
	 * delays all the time while the system is running!
	 */
	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		sc->mii_flags |= MIIF_DOINGAUTO;
		timeout_set(&sc->mii_phy_timo, mii_phy_auto_timeout, sc);
		timeout_add(&sc->mii_phy_timo, hz >> 1);
	}
	return (EJUSTRETURN);
@


1.14
log
@use mii_phy_match()
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.13 2005/01/28 18:27:55 brad Exp $	*/
d80 1
a80 2
static int	nsgphy_mii_phy_auto(struct mii_softc *, int);
extern void	mii_phy_auto_timeout(void *);
d123 1
a123 1
	sc->mii_anegticks = 10;
d249 1
a249 1
		 * Only retry autonegotiation if we've hit the timeout.
d251 1
a251 1
		if (++sc->mii_ticks != sc->mii_anegticks)
d349 1
a349 1
static int
@


1.13
log
@Get flags passed down to PHY drivers correctly.  This was done on
an adhoc basis in a couple of PHY drivers, this fixes it more generally.

From NetBSD

Fixes panics with aue(4) NICs.
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.12 2004/09/27 18:25:48 brad Exp $	*/
d87 10
d102 1
a102 3
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_NATSEMI &&
	    (MII_MODEL(ma->mii_id2) == MII_MODEL_NATSEMI_DP83891 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_NATSEMI_DP83861))
d114 1
d116 2
a117 11
	switch(MII_MODEL(ma->mii_id2)) {
	case MII_MODEL_NATSEMI_DP83861:
	  printf(": %s, rev. %d\n", MII_STR_NATSEMI_DP83861,
		 MII_REV(ma->mii_id2));
	  break;

	case MII_MODEL_NATSEMI_DP83891:
	  printf(": %s, rev. %d\n", MII_STR_NATSEMI_DP83891,
		 MII_REV(ma->mii_id2));
	  break;
	}
@


1.12
log
@ANSI protos and some minor cleanup

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.11 2004/09/26 00:59:58 brad Exp $	*/
d123 1
a123 1
	sc->mii_flags = mii->mii_flags;
@


1.11
log
@Restructure the PHY entry points to use a structure of
entry points instead of descrete function pointers, and
extend this to include a "reset" entry point. Make sure
any PHY-specific reset routine is always used.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.10 2004/09/20 06:05:27 brad Exp $	*/
d88 1
a88 4
nsgphymatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d101 1
a101 4
nsgphyattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d147 1
a147 4
nsgphy_service(sc, mii, cmd)
	struct mii_softc *sc;
	struct mii_data *mii;
	int cmd;
d282 1
a282 2
nsgphy_status(sc)
	struct mii_softc *sc;
d351 1
a351 3
nsgphy_mii_phy_auto(mii, waitfor)
	struct mii_softc *mii;
	int waitfor;
d355 3
a357 3
	if ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {
		PHY_RESET(mii);
		PHY_WRITE(mii, NSGPHY_MII_BMCR, 0);
d359 2
a360 2
		ktcr = PHY_READ(mii, NSGPHY_MII_1000CTL);
		PHY_WRITE(mii, NSGPHY_MII_1000CTL, ktcr |
d362 1
a362 1
		ktcr = PHY_READ(mii, NSGPHY_MII_1000CTL);
d364 2
a365 2
		PHY_WRITE(mii, NSGPHY_MII_ANAR,
		    BMSR_MEDIA_TO_ANAR(mii->mii_capabilities) | ANAR_CSMA);
d367 1
a367 1
		PHY_WRITE(mii, NSGPHY_MII_BMCR,
d374 1
a374 1
			if ((bmsr = PHY_READ(mii, NSGPHY_MII_BMSR)) &
d398 4
a401 4
	if ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {
		mii->mii_flags |= MIIF_DOINGAUTO;
		timeout_set(&mii->mii_phy_timo, mii_phy_auto_timeout, mii);
		timeout_add(&mii->mii_phy_timo, hz >> 1);
@


1.10
log
@don't include sys/malloc.h, no memory management functions are used
by any of the MII drivers.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.9 2002/11/26 06:01:28 nate Exp $	*/
d83 4
a87 1

d127 1
a127 2
	sc->mii_service = nsgphy_service;
	sc->mii_status = nsgphy_status;
d132 1
a132 1
	mii_phy_reset(sc);
d273 1
a273 1
		mii_phy_reset(sc);
d368 1
a368 1
		mii_phy_reset(mii);
@


1.9
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.8 2002/05/04 11:30:06 fgsch Exp $	*/
a33 1
 * $FreeBSD$
a53 1
#include <sys/malloc.h>
@


1.8
log
@some space and tab cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.7 2002/03/14 01:26:58 millert Exp $	*/
d194 1
a194 1
		case IFM_1000_TX:
d319 1
a319 1
			mii->mii_media_active |= IFM_1000_TX|IFM_FDX;
d321 1
a321 1
			mii->mii_media_active |= IFM_1000_TX|IFM_HDX;
d339 1
a339 1
		mii->mii_media_active |= IFM_1000_TX;
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.6 2001/10/05 18:29:15 nate Exp $	*/
d263 1
a263 1
		
@


1.6
log
@Remove modes that should be autodetected
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.5 2001/10/05 18:26:48 nate Exp $	*/
d67 2
a68 2
int	nsgphymatch __P((struct device*, void *, void *));
void	nsgphyattach __P((struct device *, struct device *, void *));
d79 2
a80 2
int	nsgphy_service __P((struct mii_softc *, struct mii_data *, int));
void	nsgphy_status __P((struct mii_softc *));
d82 2
a83 2
static int	nsgphy_mii_phy_auto __P((struct mii_softc *, int));
extern void	mii_phy_auto_timeout __P((void *));
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.6 2001/10/05 18:29:15 nate Exp $	*/
d67 2
a68 2
int	nsgphymatch(struct device*, void *, void *);
void	nsgphyattach(struct device *, struct device *, void *);
d79 2
a80 2
int	nsgphy_service(struct mii_softc *, struct mii_data *, int);
void	nsgphy_status(struct mii_softc *);
d82 2
a83 2
static int	nsgphy_mii_phy_auto(struct mii_softc *, int);
extern void	mii_phy_auto_timeout(void *);
d263 1
a263 1

@


1.6.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d194 1
a194 1
		case IFM_1000_T:
d319 1
a319 1
			mii->mii_media_active |= IFM_1000_T|IFM_FDX;
d321 1
a321 1
			mii->mii_media_active |= IFM_1000_T|IFM_HDX;
d339 1
a339 1
		mii->mii_media_active |= IFM_1000_T;
@


1.5
log
@use anegticks for phys that do their own autonegotiation timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.4 2001/08/19 15:07:34 miod Exp $	*/
a149 13

#define	ADD(m, c)	ifmedia_add(&mii->mii_media, (m), (c), NULL)

	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc->mii_inst),
	    BMCR_ISO);
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_TX, 0, sc->mii_inst),
	    NSGPHY_S1000);
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_TX, IFM_FDX, sc->mii_inst),
	    NSGPHY_S1000|NSGPHY_BMCR_FDX);
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_LOOP,
	    sc->mii_inst), BMCR_LOOP|BMCR_S100);

#undef ADD
@


1.4
log
@More old timeouts removal, mainly affected unused/unmaintained code.
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.3 2001/07/02 06:29:49 nate Exp $	*/
d130 1
d272 1
a272 4
		 * Only retry autonegotiation every 5 seconds.
		 * Actually, for gigE PHYs, we should wait longer, since
		 * 5 seconds is the mimimum time the documentation
		 * says to wait for a 1000mbps link to be established.
d274 1
a274 1
		if (++sc->mii_ticks != 10)
@


1.3
log
@Remove spurious printf
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.2 2001/07/02 05:08:28 nate Exp $	*/
d427 2
a428 1
		timeout(mii_phy_auto_timeout, mii, hz >> 1);
@


1.3.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.3 2001/07/02 06:29:49 nate Exp $	*/
a129 1
	sc->mii_anegticks = 10;
d149 13
d271 4
a274 1
		 * Only retry autonegotiation if we've hit the timeout.
d276 1
a276 1
		if (++sc->mii_ticks != sc->mii_anegticks)
d427 1
a427 2
		timeout_set(&mii->mii_phy_timo, mii_phy_auto_timeout, mii);
		timeout_add(&mii->mii_phy_timo, hz >> 1);
@


1.3.2.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 2
a68 2
int	nsgphymatch(struct device*, void *, void *);
void	nsgphyattach(struct device *, struct device *, void *);
d79 2
a80 2
int	nsgphy_service(struct mii_softc *, struct mii_data *, int);
void	nsgphy_status(struct mii_softc *);
d82 2
a83 2
static int	nsgphy_mii_phy_auto(struct mii_softc *, int);
extern void	mii_phy_auto_timeout(void *);
@


1.3.2.3
log
@Sync the SMP branch with 3.3
@
text
@d194 1
a194 1
		case IFM_1000_T:
d263 1
a263 1

d319 1
a319 1
			mii->mii_media_active |= IFM_1000_T|IFM_FDX;
d321 1
a321 1
			mii->mii_media_active |= IFM_1000_T|IFM_HDX;
d339 1
a339 1
		mii->mii_media_active |= IFM_1000_T;
@


1.2
log
@Print out correct version string
@
text
@d1 1
a1 1
/*	$OpenBSD: nsgphy.c,v 1.1 2001/06/08 02:19:30 nate Exp $	*/
a136 1
        printf("%s: ", sc->mii_dev.dv_xname);
@


1.1
log
@Add support for National Semiconductor Gigabit PHYs (DP83891 and DP83861)
From FreeBSD (Unverified)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 11
a122 2
	printf(": %s, rev. %d\n", MII_STR_NATSEMI_DP83861,
	       MII_REV(ma->mii_id2));
@

