head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.18
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.16
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.12
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.10
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.8
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.18
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.16
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.14
	OPENBSD_5_0:1.23.0.12
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.10
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.8
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.5.0.6
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.2
	SMP_BASE:1.1;
locks; strict;
comment	@ * @;


1.25
date	2013.12.28.03.30.41;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2013.05.28.09.46.06;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2008.09.11.17.20.18;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.08.07.38.33;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.22.11.20.10;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.11.15.00.17;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.10.21.15.14;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.27.19.11.08;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.05.17.01.34;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.04.21.52.37;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.27.08.04.15;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.26.04.40.09;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.28.18.27.55;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.25.03.51.24;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.16.14.26.22;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.27.18.25.48;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.26.00.59.58;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2002.10.20.16.46.28;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.04.11.30.06;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.57;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.02.23.01.54;	author aaron;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2000.09.07.20.10.21;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.26.20.04.17;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.18.19.35.32;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.09.01.15.16;	author jason;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.05.14.22.25.20;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.03.28.00.38.19;	author niklas;	state Exp;
branches;
next	;

1.5.6.1
date	2002.06.11.03.42.23;	author art;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@mii drivers no longer need activate functions.  Repair of the PHY
configuration setting is done at resume time because all networks
drivers which were previously up, do an IFF_UP operation which
hits PHY_RESET.
This was in snapshots for about 2 weeks.
@
text
@/*	$OpenBSD: dcphy.c,v 1.24 2013/05/28 09:46:06 mikeb Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/mii/dcphy.c,v 1.6 2000/10/05 17:36:14 wpaul Exp $
 */

/*
 * Pseudo-driver for internal NWAY support on DEC 21143 and workalike
 * controllers. Technically we're abusing the miibus code to handle
 * media selection and NWAY support here since there is no MII
 * interface. However the logical operations are roughly the same,
 * and the alternative is to create a fake MII interface in the driver,
 * which is harder to do.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/errno.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <dev/ic/dcreg.h>

#define DC_SETBIT(sc, reg, x)                           \
        CSR_WRITE_4(sc, reg,                            \
                CSR_READ_4(sc, reg) | x)

#define DC_CLRBIT(sc, reg, x)                           \
        CSR_WRITE_4(sc, reg,                            \
                CSR_READ_4(sc, reg) & ~x)

#define MIIF_AUTOTIMEOUT	0x0004

/*
 * This is the subsystem ID for the built-in 21143 ethernet
 * in several Compaq Presario systems. Apparently these are
 * 10Mbps only, so we need to treat them specially.
 */
#define COMPAQ_PRESARIO_ID	0xb0bb0e11

int	dcphy_match(struct device *, void *, void *);
void	dcphy_attach(struct device *, struct device *, void *);

struct cfattach dcphy_ca = {
	sizeof(struct mii_softc), dcphy_match, dcphy_attach, mii_phy_detach
};

struct cfdriver dcphy_cd = {
	NULL, "dcphy", DV_DULL
};

int	dcphy_service(struct mii_softc *, struct mii_data *, int);
void	dcphy_status(struct mii_softc *);
int	dcphy_mii_phy_auto(struct mii_softc *, int);
void	dcphy_reset(struct mii_softc *);

const struct mii_phy_funcs dcphy_funcs = {
	dcphy_service, dcphy_status, dcphy_reset,
};

int
dcphy_match(struct device *parent, void *match, void *aux)
{
	struct mii_attach_args *ma = aux;

	/*
	 * The dc driver will report the 21143 vendor and device
	 * ID to let us know that it wants us to attach.
	 */
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxDEC &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_xxDEC_xxDC)
		return (10);

	return (0);
}

void
dcphy_attach(struct device *parent, struct device *self, void *aux)
{
	struct mii_softc *sc = (struct mii_softc *)self;
	struct mii_attach_args *ma = aux;
	struct mii_data *mii = ma->mii_data;
	struct dc_softc *dc_sc;

	printf(": internal PHY\n");
	sc->mii_inst = mii->mii_instance;
	sc->mii_phy = ma->mii_phyno;
	sc->mii_funcs = &dcphy_funcs;
	sc->mii_pdata = mii;
	sc->mii_flags = ma->mii_flags;
	sc->mii_anegticks = 50;

	sc->mii_flags |= MIIF_NOISOLATE;

	dc_sc = mii->mii_ifp->if_softc;
	CSR_WRITE_4(dc_sc, DC_10BTSTAT, 0);
	CSR_WRITE_4(dc_sc, DC_10BTCTRL, 0);

#define	ADD(m, c)	ifmedia_add(&mii->mii_media, (m), (c), NULL)

	switch(dc_sc->dc_csid) {
	case COMPAQ_PRESARIO_ID:
		/* Example of how to only allow 10Mbps modes. */
		sc->mii_capabilities = BMSR_ANEG|BMSR_10TFDX|BMSR_10THDX;
		break;
	default:
		if (dc_sc->dc_pmode == DC_PMODE_SIA) {
			sc->mii_capabilities =
			    BMSR_ANEG|BMSR_10TFDX|BMSR_10THDX;
		} else {
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_LOOP,
			    sc->mii_inst), BMCR_LOOP|BMCR_S100);

			sc->mii_capabilities =
			    BMSR_ANEG|BMSR_100TXFDX|BMSR_100TXHDX|
			    BMSR_10TFDX|BMSR_10THDX;
		}
		break;
	}

	if (dc_sc->dc_type == DC_TYPE_21145)
		sc->mii_capabilities = BMSR_10THDX;

	sc->mii_capabilities &= ma->mii_capmask;
	if (sc->mii_capabilities & BMSR_MEDIAMASK)
		mii_phy_add_media(sc);
#undef ADD
}

int
dcphy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
{
	struct dc_softc *dc_sc;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int reg;
	u_int32_t mode;

	if ((sc->mii_dev.dv_flags & DVF_ACTIVE) == 0)
		return (ENXIO);

	dc_sc = mii->mii_ifp->if_softc;

	switch (cmd) {
	case MII_POLLSTAT:
		/*
		 * If we're not polling our PHY instance, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);
		break;

	case MII_MEDIACHG:
		/*
		 * If the media indicates a different PHY instance,
		 * isolate ourselves.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);

		/*
		 * If the interface is not up, don't do anything.
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			break;

		sc->mii_flags = 0;
		mii->mii_media_active = IFM_NONE;
		mode = CSR_READ_4(dc_sc, DC_NETCFG);
		mode &= ~(DC_NETCFG_FULLDUPLEX|DC_NETCFG_PORTSEL|
		    DC_NETCFG_PCS|DC_NETCFG_SCRAMBLER|DC_NETCFG_SPEEDSEL);

		switch (IFM_SUBTYPE(ife->ifm_media)) {
		case IFM_AUTO:
			/*PHY_RESET(sc);*/
			sc->mii_flags &= ~MIIF_DOINGAUTO;
			(void) dcphy_mii_phy_auto(sc, 0);
			break;
		case IFM_100_TX:
			PHY_RESET(sc);
			DC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);
			mode |= DC_NETCFG_PORTSEL|DC_NETCFG_PCS|
			    DC_NETCFG_SCRAMBLER;
			if ((ife->ifm_media & IFM_GMASK) == IFM_FDX)
				mode |= DC_NETCFG_FULLDUPLEX;
			else
				mode &= ~DC_NETCFG_FULLDUPLEX;
			CSR_WRITE_4(dc_sc, DC_NETCFG, mode);
			break;
		case IFM_10_T:
			DC_CLRBIT(dc_sc, DC_SIARESET, DC_SIA_RESET);
			DC_CLRBIT(dc_sc, DC_10BTCTRL, 0xFFFF);
			if ((ife->ifm_media & IFM_GMASK) == IFM_FDX)
				DC_SETBIT(dc_sc, DC_10BTCTRL, 0x7F3D);
			else
				DC_SETBIT(dc_sc, DC_10BTCTRL, 0x7F3F);
			DC_SETBIT(dc_sc, DC_SIARESET, DC_SIA_RESET);
			DC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);
			mode &= ~DC_NETCFG_PORTSEL;
			mode |= DC_NETCFG_SPEEDSEL;
			if ((ife->ifm_media & IFM_GMASK) == IFM_FDX)
				mode |= DC_NETCFG_FULLDUPLEX;
			else
				mode &= ~DC_NETCFG_FULLDUPLEX;
			CSR_WRITE_4(dc_sc, DC_NETCFG, mode);
			break;
		default:
			return (EINVAL);
		}
		break;

	case MII_TICK:
		/*
		 * If we're not currently selected, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);

		/*
		 * Is the interface even up?
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			return (0);

		/*
		 * Only used for autonegotiation.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			break;

		reg = CSR_READ_4(dc_sc, DC_10BTSTAT);
		if (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100)) {
			sc->mii_ticks = 0;
			break;
		}

		/*
		 * Only retry autonegotiation every mii_anegticks seconds.
		 *
		 * Otherwise, fall through to calling dcphy_status()
		 * since real Intel 21143 chips don't show valid link
		 * status until autonegotiation is switched off, and
		 * that only happens in dcphy_status().  Without this,
		 * successful autonegotiation is never recognised on
		 * these chips.
		 */
		if (++sc->mii_ticks <= sc->mii_anegticks)
			break;

		sc->mii_ticks = 0;
		sc->mii_flags &= ~MIIF_DOINGAUTO;
		dcphy_mii_phy_auto(sc, 0);

		break;
	}

	/* Update the media status. */
	mii_phy_status(sc);

	/* Callback if something changed. */
	mii_phy_update(sc, cmd);
	return (0);
}

void
dcphy_status(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	int reg, anlpar, tstat = 0;
	struct dc_softc *dc_sc;

	dc_sc = mii->mii_ifp->if_softc;

	mii->mii_media_status = IFM_AVALID;
	mii->mii_media_active = IFM_ETHER;

	reg = CSR_READ_4(dc_sc, DC_10BTSTAT);
	if (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100))
		mii->mii_media_status |= IFM_ACTIVE;

	if (CSR_READ_4(dc_sc, DC_10BTCTRL) & DC_TCTL_AUTONEGENBL) {
		/* Erg, still trying, I guess... */
		tstat = CSR_READ_4(dc_sc, DC_10BTSTAT);
		if ((tstat & DC_TSTAT_ANEGSTAT) != DC_ASTAT_AUTONEGCMP) {
			if ((DC_IS_MACRONIX(dc_sc) || DC_IS_PNICII(dc_sc)) &&
			    (tstat & DC_TSTAT_ANEGSTAT) == DC_ASTAT_DISABLE)
				goto skip;
			mii->mii_media_active |= IFM_NONE;
			return;
		}

		if (tstat & DC_TSTAT_LP_CAN_NWAY) {
			anlpar = tstat >> 16;
			if (anlpar & ANLPAR_TX_FD &&
			    sc->mii_capabilities & BMSR_100TXFDX)
				mii->mii_media_active |= IFM_100_TX|IFM_FDX;
			else if (anlpar & ANLPAR_T4 &&
			    sc->mii_capabilities & BMSR_100T4)
				mii->mii_media_active |= IFM_100_T4|IFM_HDX;
			else if (anlpar & ANLPAR_TX &&
			    sc->mii_capabilities & BMSR_100TXHDX)
				mii->mii_media_active |= IFM_100_TX|IFM_HDX;
			else if (anlpar & ANLPAR_10_FD)
				mii->mii_media_active |= IFM_10_T|IFM_FDX;
			else if (anlpar & ANLPAR_10)
				mii->mii_media_active |= IFM_10_T|IFM_HDX;
			else
				mii->mii_media_active |= IFM_NONE;
			if (DC_IS_INTEL(dc_sc))
				DC_CLRBIT(dc_sc, DC_10BTCTRL,
				    DC_TCTL_AUTONEGENBL);
			return;
		}

		/*
		 * If the other side doesn't support NWAY, then the
		 * best we can do is determine if we have a 10Mbps or
		 * 100Mbps link. There's no way to know if the link
		 * is full or half duplex, so we default to half duplex
		 * and hope that the user is clever enough to manually
		 * change the media settings if we're wrong.
		 */
		if (!(reg & DC_TSTAT_LS100))
			mii->mii_media_active |= IFM_100_TX|IFM_HDX;
		else if (!(reg & DC_TSTAT_LS10))
			mii->mii_media_active |= IFM_10_T|IFM_HDX;
		else
			mii->mii_media_active |= IFM_NONE;
		if (DC_IS_INTEL(dc_sc))
			DC_CLRBIT(dc_sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);
		return;
	}

skip:
	if (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_SPEEDSEL)
		mii->mii_media_active |= IFM_10_T;
	else
		mii->mii_media_active |= IFM_100_TX;

	if (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_FULLDUPLEX)
		mii->mii_media_active |= IFM_FDX;
	else
		mii->mii_media_active |= IFM_HDX;
}

int
dcphy_mii_phy_auto(struct mii_softc *mii, int waitfor)
{
	int			i;
	struct dc_softc		*sc;

	sc = mii->mii_pdata->mii_ifp->if_softc;

	if ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {
		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);
		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);
		DC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);
		if (mii->mii_capabilities & BMSR_100TXHDX)
			CSR_WRITE_4(sc, DC_10BTCTRL, 0x3FFFF);
		else
			CSR_WRITE_4(sc, DC_10BTCTRL, 0xFFFF);
		DC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);
		DC_SETBIT(sc, DC_10BTCTRL, DC_TCTL_AUTONEGENBL);
		DC_SETBIT(sc, DC_10BTSTAT, DC_ASTAT_TXDISABLE);
	}

	if (waitfor) {
		/* Wait 500ms for it to complete. */
		for (i = 0; i < 500; i++) {
			if ((CSR_READ_4(sc, DC_10BTSTAT) & DC_TSTAT_ANEGSTAT)
			    == DC_ASTAT_AUTONEGCMP)
				return (0);
			DELAY(1000);
		}
		/*
		 * Don't need to worry about clearing MIIF_DOINGAUTO.
		 * If that's set, a timeout is pending, and it will
		 * clear the flag.
		 */
		return (EIO);
	}

	/*
	 * Just let it finish asynchronously.  This is for the benefit of
	 * the tick handler driving autonegotiation.  Don't want 500ms
	 * delays all the time while the system is running!
	 */
	if ((mii->mii_flags & MIIF_DOINGAUTO) == 0)
		mii->mii_flags |= MIIF_DOINGAUTO;

	return (EJUSTRETURN);
}

void
dcphy_reset(struct mii_softc *mii)
{
	struct dc_softc		*sc;

	sc = mii->mii_pdata->mii_ifp->if_softc;

	DC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);
	DELAY(1000);
	DC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);

	return;
}
@


1.24
log
@Fix a common issue across different PHY drivers to reset the
autonegotiation timer when PHY gets the link so that if we
restart the timer the mii_ticks value would be sane.

Lifted originally from FreeBSD, tested by a few on re(4) and
bge(4), ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.23 2008/09/11 17:20:18 brad Exp $	*/
d88 1
a88 2
	sizeof(struct mii_softc), dcphy_match, dcphy_attach, mii_phy_detach,
	    mii_phy_activate
@


1.23
log
@Fix a typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.22 2008/09/08 07:38:33 brad Exp $	*/
d275 2
a276 1
		if (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100))
d278 1
@


1.22
log
@IEEE 802.3 Annex 28B.3 explicitly specifies the following relative
priorities of the technologies supported by 802.3 Selector Field
value.

1000BASE-T full duplex
1000BASE-T
100BASE-T2 full duplex
100BASE-TX full duplex
100BASE-T2
100BASE-T4
100BASE-TX
10BASE-T full duplex
10BAST-T

However PHY drivers did not honor the order such that 100BASE-T4 had
higher priority than 100BASE-TX full duplex. Fix a long standing bug
such that PHY drivers choose the highest common denominator ability.

This bug is exposed by a Cisco 3550 switch which inadvertently
announces 100BASE-T4 capability even though it is not capable of
100BASE-T4 operation, it is a 100BASE-TX switch.

From FreeBSD

Tested with dc(4), fxp(4), rl(4), sis(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.21 2008/07/22 11:20:10 martynas Exp $	*/
d337 1
a337 1
				mii->mii_media_active |= IFM_100_TX|IFM_HDX;
@


1.21
log
@more negotation -> negotiation;  ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.20 2008/07/11 15:00:17 brad Exp $	*/
d335 4
a338 1
			if (anlpar & ANLPAR_T4 &&
a340 3
			else if (anlpar & ANLPAR_TX_FD &&
			    sc->mii_capabilities & BMSR_100TXFDX)
				mii->mii_media_active |= IFM_100_TX|IFM_FDX;
@


1.20
log
@Check the correct BMSR bit in the capabilities field when checking
for 100baseT4. The dcphy(4) driver could inadvertently display
100baseT4 for the media type for PHY not actually capable of
100baseT4.

From FreeBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.19 2008/06/10 21:15:14 brad Exp $	*/
d285 1
a285 1
		 * successful autonegotation is never recognised on
@


1.19
log
@Some header cleanup. Remove some unused headers and shuffle some around
for consistency between drivers.

"looks good" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.18 2006/12/27 19:11:08 kettenis Exp $	*/
d336 1
a336 1
			    sc->mii_capabilities & BMSR_100TXHDX)
@


1.18
log
@Always explicitly set IFM_HDX for half-duplex.

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.17 2006/08/05 17:01:34 brad Exp $	*/
a46 1
#include <sys/device.h>
d49 1
a50 1
#include <sys/timeout.h>
d53 2
a55 2
#include <net/if_dl.h>
#include <net/if_types.h>
d57 1
a63 4

#include <machine/bus.h>

#include <dev/pci/pcivar.h>
@


1.17
log
@add sys/timeout.h and remove redundant sys/socket.h header.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.16 2005/08/04 21:52:37 brad Exp $	*/
d341 1
a341 1
				mii->mii_media_active |= IFM_100_T4;
d347 1
a347 1
				mii->mii_media_active |= IFM_100_TX;
d351 1
a351 1
				mii->mii_media_active |= IFM_10_T;
d359 1
d369 1
a369 1
			mii->mii_media_active |= IFM_100_TX;
d371 1
a371 1
			mii->mii_media_active |= IFM_10_T;
a379 1

d384 1
d387 2
a388 2

	return;
@


1.16
log
@allow dcphy_status() to be called even when the parent interface
is in the down state. on some dc's with dcphy this will now allow
the card to show carrier state and some link speed though not
necessarily full-duplex for some reason. something to look into
still.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.15 2005/05/27 08:04:15 brad Exp $	*/
d51 1
a52 1
#include <sys/socket.h>
@


1.15
log
@some cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.14 2005/03/26 04:40:09 krw Exp $	*/
d196 1
a196 1
		if (IFM_INST(ife->ifm_media) != sc->mii_inst) {
a197 1
		}
d205 1
a205 1
		if (IFM_INST(ife->ifm_media) != sc->mii_inst) {
a206 1
		}
a225 5
		case IFM_100_T4:
			/*
			 * XXX Not supported as a manual setting right now.
			 */
			return (EINVAL);
a320 3

	if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
		return;
@


1.14
log
@Cleanup. Use defines, standard names, consistant comparison operators, etc.
for auto negotiation ticks code. No functional change.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.13 2005/01/28 18:27:55 brad Exp $	*/
a142 2
	mii->mii_instance++;

d262 1
a262 1
			return(EINVAL);
d426 1
a426 1
				return(0);
d434 1
a434 1
		return(EIO);
d445 1
a445 1
	return(EJUSTRETURN);
@


1.13
log
@Get flags passed down to PHY drivers correctly.  This was done on
an adhoc basis in a couple of PHY drivers, this fixes it more generally.

From NetBSD

Fixes panics with aue(4) NICs.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.12 2004/12/25 03:51:24 brad Exp $	*/
d102 1
a102 1
int	dcphy_auto(struct mii_softc *, int);
d139 1
d228 1
a228 1
			(void) dcphy_auto(sc, 0);
d292 1
a292 1
		 * Only retry autonegotiation every 5 seconds.
d301 1
a301 1
		if (++sc->mii_ticks != 50)
d306 1
a306 1
		dcphy_auto(sc, 0);
d403 1
a403 1
dcphy_auto(struct mii_softc *mii, int waitfor)
@


1.12
log
@- remove unneccessary break
- reorder operations and a few return (0)'s to break's with MII_TICK switch case
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.11 2004/11/16 14:26:22 brad Exp $	*/
d138 1
a138 1
	sc->mii_flags = mii->mii_flags;
d141 1
@


1.11
log
@if_dc.c rev 1.56

Do not call mii_pollstat() from within device tick routines; the status
information is updated by mii_tick().

dcphy.c rev 1.13

Work around an Intel 21143 chip bug.

Rev 1.56 of if_dc.c removed calls to mii_pollstat() from the dc_tick()
routine.  dc_tick() is called regularly to detect link up and link down
status, especially when autonegotiating.

The expectation was that mii_tick() (which is still called from dc_tick())
would update status information automatically in all cases where it would
be sensible to do so.

Unfortunately, with authentic 21143 chips this is not the case, and
the driver never successfully autonegotiates.  This is because (despite
what it says in the 21143 manual) the chip always claims that link is not
present while the autonegotiation enable bit is set.  Autonegotation takes
place and succeeds, but the driver tests the link bits before it switches
off the autonegotiation enable bit, and success is not recognised.

The simplest solution is to call dcphy_status() more often for MII_TICK
calls by dropping out of the switch statement instead of exiting when
we are autonegotiating and link appears to not be present.  When
autonegotiation succeeds, dcphy_status() will note the speed and fdx/hdx
state and turn off the autonegotiation enable bit.  The next call to
dcphy_status() will notice that link is present, and the dc driver code
will be notified.

Macronix chips also use this code, but implement link detection as
described in the manual, and hence don't need this patch.  However, tests
on a Macronix 98715AEC-C show that it does not adversely affect them.

From FreeBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.10 2004/09/27 18:25:48 brad Exp $	*/
a262 1
			break;
d274 1
a274 1
		 * Only used for autonegotiation.
d276 1
a276 1
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
d280 1
a280 1
		 * Is the interface even up?
d282 2
a283 2
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			return (0);
d287 1
a287 1
			return (0);
d303 1
a303 2
		/*if (DC_IS_INTEL(dc_sc))*/
			sc->mii_flags &= ~MIIF_DOINGAUTO;
@


1.10
log
@ANSI protos and some minor cleanup

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.9 2004/09/26 00:59:58 brad Exp $	*/
d286 1
a286 3
		reg = CSR_READ_4(dc_sc, DC_10BTSTAT) &
		    (DC_TSTAT_LS10|DC_TSTAT_LS100);

d292 7
d301 1
a301 1
			return (0);
d334 1
a334 3
	reg = CSR_READ_4(dc_sc, DC_10BTSTAT) &
	    (DC_TSTAT_LS10|DC_TSTAT_LS100);

@


1.9
log
@Restructure the PHY entry points to use a structure of
entry points instead of descrete function pointers, and
extend this to include a "reset" entry point. Make sure
any PHY-specific reset routine is always used.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.8 2002/10/20 16:46:28 henning Exp $	*/
d110 1
a110 3
dcphy_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d126 1
a126 4
dcphy_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d179 1
a179 4
dcphy_service(sc, mii, cmd)
	struct mii_softc *sc;
	struct mii_data *mii;
	int cmd;
d315 1
a315 2
dcphy_status(sc)
	struct mii_softc *sc;
d400 1
a400 3
dcphy_auto(mii, waitfor)
	struct mii_softc	*mii;
	int			waitfor;
d448 1
a448 2
dcphy_reset(mii)
	struct mii_softc	*mii;
@


1.8
log
@add support for intel 21145
This chip is some strange abnormal 21143 variant. It really only works with
10 MBit/s halfduplex only and autonegotiation is totally broken in hardware.
Should also have a HomePNA phy, but we don't support that.
for now requires and explicit "media 10BaseT".
if anybody has such a chip please mail me.

nick@@ is the only one who has the hardware and did an incredible amount of
testing. Thanks for all the help, Nick!

some hints and ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.7 2002/05/04 11:30:06 fgsch Exp $	*/
d105 4
d141 1
a141 2
	sc->mii_service = dcphy_service;
	sc->mii_status = dcphy_status;
d232 1
a232 1
			/*dcphy_reset(sc);*/
d242 1
a242 1
			dcphy_reset(sc);
@


1.7
log
@some space and tab cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.6 2002/03/14 01:26:57 millert Exp $	*/
d170 3
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.5 2001/04/02 23:01:54 aaron Exp $	*/
d95 1
a95 1
	  
d374 1
a374 1
		 * 100Mbps link. There's no way to know if the link 
@


1.5
log
@Oops, this should have been committed along with the SROM media block parsing
changes to the dc driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.4 2000/09/07 20:10:21 aaron Exp $	*/
d88 2
a89 2
int	dcphy_match	__P((struct device *, void *, void *));
void	dcphy_attach	__P((struct device *, struct device *, void *));
d100 4
a103 4
int	dcphy_service	__P((struct mii_softc *, struct mii_data *, int));
void	dcphy_status	__P((struct mii_softc *));
int	dcphy_auto	__P((struct mii_softc *, int));
void	dcphy_reset	__P((struct mii_softc *));
@


1.5.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.5 2001/04/02 23:01:54 aaron Exp $	*/
d88 2
a89 2
int	dcphy_match(struct device *, void *, void *);
void	dcphy_attach(struct device *, struct device *, void *);
d95 1
a95 1

d100 4
a103 4
int	dcphy_service(struct mii_softc *, struct mii_data *, int);
void	dcphy_status(struct mii_softc *);
int	dcphy_auto(struct mii_softc *, int);
void	dcphy_reset(struct mii_softc *);
d374 1
a374 1
		 * 100Mbps link. There's no way to know if the link
@


1.5.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.5.6.1 2002/06/11 03:42:23 art Exp $	*/
a169 3

	if (dc_sc->dc_type == DC_TYPE_21145)
		sc->mii_capabilities = BMSR_10THDX;
@


1.4
log
@During the last FreeBSD dc(4) sync, I very stupidly forgot to check for changes
in dcphy(4) as well, breaking some cards (i.e., the Macronix PMAC 98715). This
commit brings dcphy up-to-date. Thanks to cgruber@@troba.com and ericj@@ for
providing me with Macronix cards for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.3 2000/08/26 20:04:17 nate Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/mii/dcphy.c,v 1.5 2000/06/05 19:37:15 wpaul Exp $
d157 11
a167 6
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_LOOP,
		    sc->mii_inst), BMCR_LOOP|BMCR_S100);

		sc->mii_capabilities =
		    BMSR_ANEG|BMSR_100TXFDX|BMSR_100TXHDX|
		    BMSR_10TFDX|BMSR_10THDX;
d391 4
a394 1
	if (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_SCRAMBLER)
a395 2
	else
		mii->mii_media_active |= IFM_10_T;
@


1.3
log
@sync mii code with netbsd
adds detach functionality for phys
some code cleanup

Nobody really had time to test all of this out, but theo said commit anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.2 2000/04/18 19:35:32 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/mii/dcphy.c,v 1.2 1999/12/13 21:45:13 wpaul Exp $
a49 1
#include <sys/malloc.h>
d222 1
d283 2
a284 9
		if (sc->mii_flags & MIIF_DOINGAUTO) {
			if (++sc->mii_ticks != 5)
				return(0);
			else {
				sc->mii_ticks = 0;
				sc->mii_flags &= ~MIIF_DOINGAUTO;
				sc->mii_flags |= MIIF_AUTOTIMEOUT;
			}
		}
d286 2
a287 1
		sc->mii_flags &= ~MIIF_DOINGAUTO;
d290 1
a290 3
		 * Check to see if we have link.  If we do, we don't
		 * need to restart the autonegotiation process.  Read
		 * the BMSR twice in case it's latched.
d292 2
a293 31
		reg = CSR_READ_4(dc_sc, DC_10BTSTAT) &
		    (DC_TSTAT_LS10|DC_TSTAT_LS100);

		if (IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX &&
		    !(reg & DC_TSTAT_LS100)) {
			if (sc->mii_flags & MIIF_AUTOTIMEOUT) {
				sc->mii_flags &= ~MIIF_AUTOTIMEOUT;
				break;
			} else
				return(0);
		} else if (IFM_SUBTYPE(mii->mii_media_active) == IFM_10_T &&
		    !(reg & DC_TSTAT_LS10)) {
			if (sc->mii_flags & MIIF_AUTOTIMEOUT) {
				sc->mii_flags &= ~MIIF_AUTOTIMEOUT;
				break;
			} else
				return(0);
		} else if (IFM_SUBTYPE(mii->mii_media_active) == IFM_NONE &&
		    (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100))) {
			if (sc->mii_flags & MIIF_AUTOTIMEOUT) {
				sc->mii_flags &= ~MIIF_AUTOTIMEOUT;
				break;
			} else
				return(0);
		} else if (CSR_READ_4(dc_sc, DC_ISR) & DC_ISR_LINKGOOD) {
			if (sc->mii_flags & MIIF_AUTOTIMEOUT) {
				sc->mii_flags &= ~MIIF_AUTOTIMEOUT;
				break;
			} else
				return(0);
		}
d296 2
a297 1
		/*dcphy_reset(sc);*/
d316 1
a316 1
	int reg, anlpar;
d324 3
d328 1
a328 1
	     (DC_TSTAT_LS10|DC_TSTAT_LS100);
d333 1
a333 7
	if (sc->mii_flags & MIIF_DOINGAUTO) {
		mii->mii_media_active |= IFM_NONE;
		return;
	}

	if (CSR_READ_4(dc_sc, DC_10BTCTRL) & DC_TCTL_AUTONEGENBL &&
	    CSR_READ_4(dc_sc, DC_10BTSTAT) & DC_TSTAT_ANEGSTAT) {
d335 5
a339 2
		if ((CSR_READ_4(dc_sc, DC_10BTSTAT) &
		    DC_ASTAT_AUTONEGCMP) != DC_ASTAT_AUTONEGCMP) {
d344 2
a345 2
		if (CSR_READ_4(dc_sc, DC_10BTSTAT) & DC_TSTAT_LP_CAN_NWAY) {
			anlpar = CSR_READ_4(dc_sc, DC_10BTSTAT) >> 16;
d350 1
a350 1
			    sc->mii_capabilities & BMSR_100TXHDX)
d385 1
@


1.2
log
@split dc driver into bus dependent and bus independent (pci) parts
(cardbus to come later).
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.1 2000/01/09 01:15:16 jason Exp $	*/
d93 2
a94 1
	sizeof(struct mii_softc), dcphy_match, dcphy_attach
d139 1
d141 1
d168 2
a169 4
	if ((sc->mii_capabilities & BMSR_MEDIAMASK) == 0)
		printf("no media present");
	else
		mii_add_media(sc);
d184 3
d340 1
a340 1
	dcphy_status(sc);
d343 1
a343 4
	if (sc->mii_active != mii->mii_media_active || cmd == MII_MEDIACHG) {
		(*mii->mii_statchg)(sc->mii_dev.dv_parent);
		sc->mii_active = mii->mii_media_active;
	}
@


1.1
log
@emulated phy for if_dc; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
a70 1
#include <dev/pci/if_dcreg.h>
@


1.1.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: dcphy.c,v 1.5 2001/04/02 23:01:54 aaron Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/mii/dcphy.c,v 1.6 2000/10/05 17:36:14 wpaul Exp $
d50 1
d70 1
a70 1
#include <dev/ic/dcreg.h>
d93 1
a93 2
	sizeof(struct mii_softc), dcphy_match, dcphy_attach, mii_phy_detach,
	    mii_phy_activate
a137 1
	sc->mii_status = dcphy_status;
a138 1
	sc->mii_flags = mii->mii_flags;
d155 6
a160 11
		if (dc_sc->dc_pmode == DC_PMODE_SIA) {
			sc->mii_capabilities =
			    BMSR_ANEG|BMSR_10TFDX|BMSR_10THDX;
		} else {
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_LOOP,
			    sc->mii_inst), BMCR_LOOP|BMCR_S100);

			sc->mii_capabilities =
			    BMSR_ANEG|BMSR_100TXFDX|BMSR_100TXHDX|
			    BMSR_10TFDX|BMSR_10THDX;
		}
d165 4
a168 2
	if (sc->mii_capabilities & BMSR_MEDIAMASK)
		mii_phy_add_media(sc);
a182 3
	if ((sc->mii_dev.dv_flags & DVF_ACTIVE) == 0)
		return (ENXIO);

a218 1
			sc->mii_flags &= ~MIIF_DOINGAUTO;
d279 9
a287 2
		reg = CSR_READ_4(dc_sc, DC_10BTSTAT) &
		    (DC_TSTAT_LS10|DC_TSTAT_LS100);
d289 1
a289 2
		if (!(reg & DC_TSTAT_LS10) || !(reg & DC_TSTAT_LS100))
			return (0);
d292 3
a294 1
		 * Only retry autonegotiation every 5 seconds.
d296 31
a326 2
		if (++sc->mii_ticks != 50)
			return (0);
d329 1
a329 2
		/*if (DC_IS_INTEL(dc_sc))*/
			sc->mii_flags &= ~MIIF_DOINGAUTO;
d336 1
a336 1
	mii_phy_status(sc);
d339 4
a342 1
	mii_phy_update(sc, cmd);
d351 1
a351 1
	int reg, anlpar, tstat = 0;
a358 3
	if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
		return;

d360 1
a360 1
	    (DC_TSTAT_LS10|DC_TSTAT_LS100);
d365 7
a371 1
	if (CSR_READ_4(dc_sc, DC_10BTCTRL) & DC_TCTL_AUTONEGENBL) {
d373 2
a374 5
		tstat = CSR_READ_4(dc_sc, DC_10BTSTAT);
		if ((tstat & DC_TSTAT_ANEGSTAT) != DC_ASTAT_AUTONEGCMP) {
			if ((DC_IS_MACRONIX(dc_sc) || DC_IS_PNICII(dc_sc)) &&
			    (tstat & DC_TSTAT_ANEGSTAT) == DC_ASTAT_DISABLE)
				goto skip;
d379 2
a380 2
		if (tstat & DC_TSTAT_LP_CAN_NWAY) {
			anlpar = tstat >> 16;
d385 1
a385 1
			    sc->mii_capabilities & BMSR_100TXFDX)
d420 3
a422 3
skip:

	if (CSR_READ_4(dc_sc, DC_NETCFG) & DC_NETCFG_SPEEDSEL)
a423 2
	else
		mii->mii_media_active |= IFM_100_TX;
@


1.1.2.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 2
a89 2
int	dcphy_match(struct device *, void *, void *);
void	dcphy_attach(struct device *, struct device *, void *);
d100 4
a103 4
int	dcphy_service(struct mii_softc *, struct mii_data *, int);
void	dcphy_status(struct mii_softc *);
int	dcphy_auto(struct mii_softc *, int);
void	dcphy_reset(struct mii_softc *);
@


1.1.2.3
log
@Sync the SMP branch with 3.3
@
text
@d95 1
a95 1

a170 3
	if (dc_sc->dc_type == DC_TYPE_21145)
		sc->mii_capabilities = BMSR_10THDX;

d374 1
a374 1
		 * 100Mbps link. There's no way to know if the link
@


