head	1.35;
access;
symbols
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.4
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.33.0.18
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.16
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.14
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.10
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.8
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.6
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.28.0.10
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.12
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.8
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.8
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.6
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.13.0.8
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.6
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.35
date	2015.08.17.15.36.29;	author krw;	state Exp;
branches;
next	1.34;
commitid	Le3SuX5chjCNZy3I;

1.34
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.33;
commitid	p4LJxGKbi0BU2cG6;

1.33
date	2011.06.22.14.17.01;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.08.00.34.56;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.03.12.47.04;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.23.07.47.12;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.13.16.50.26;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.08.14.20.26;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2007.03.25.10.33.52;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.12.21.02.44.55;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.09.19.05.48;	author uwe;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.15.21.37.57;	author grange;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.17.22.44.55;	author grange;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.17.21.50.14;	author grange;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.16.11.58.15;	author grange;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.28.21.01.42;	author grange;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.14.22.51.54;	author grange;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.12.10.58.45;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.09.00.38.07;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.28.19.22.37;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.21.20.10.32;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.19.16.32.59;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.21.17.55.43;	author miod;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.07.12.01.45.42;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.09.20.10.40;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.25.13.11.55;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.29.02.18.33;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.29.18.42.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.28.18.08.45;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.20.07.40.32;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.07.11.22.46;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.11.17.01.22.55;	author csapuntz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.11.05.04.32.03;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	99.08.05.00.12.09;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.07.18.21.25.17;	author csapuntz;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.14.22.23.05;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2003.05.13.19.34.56;	author ho;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.35
log
@The 80's called and want their interface back. Remove last fragments of
ST-506 support. Remove redundant 'precomp' variables/fields and rename
remaining few to 'features' to be consistant with the rest of the code.

Consensus that no ST-506 disks (requiring ISA cards, <120MB, usually
rife with bad sectors that can't be worked around) are still running
OpenBSD.
@
text
@/*      $OpenBSD: ata.c,v 1.34 2015/03/14 03:38:47 jsg Exp $      */
/*      $NetBSD: ata.c,v 1.9 1999/04/15 09:41:09 bouyer Exp $      */
/*
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/syslog.h>
#include <sys/pool.h>

#include <machine/bus.h>

#include <dev/ata/atareg.h>
#include <dev/ata/atavar.h>
#include <dev/ic/wdcreg.h>

#define DEBUG_FUNCS  0x08
#define DEBUG_PROBE  0x10
#ifdef WDCDEBUG
extern int wdcdebug_mask; /* init'ed in wdc.c */
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_mask & (level)) != 0)	\
		printf args;			\
} while (0)
#else
#define WDCDEBUG_PRINT(args, level)
#endif

#define ATAPARAMS_SIZE 512

/* Get the disk's parameters */
int
ata_get_params(struct ata_drive_datas *drvp, u_int8_t flags,
    struct ataparams *prms)
{
	char *tb;
	struct wdc_command wdc_c;
	int i;
	u_int16_t *p;
	int ret;

	WDCDEBUG_PRINT(("ata_get_params\n"), DEBUG_FUNCS);

	bzero(&wdc_c, sizeof(struct wdc_command));

	if (drvp->drive_flags & DRIVE_ATA) {
		wdc_c.r_command = WDCC_IDENTIFY;
		wdc_c.r_st_bmask = WDCS_DRDY;
		wdc_c.r_st_pmask = 0;
		wdc_c.timeout = 3000; /* 3s */
	} else if (drvp->drive_flags & DRIVE_ATAPI) {
		wdc_c.r_command = ATAPI_IDENTIFY_DEVICE;
		wdc_c.r_st_bmask = 0;
		wdc_c.r_st_pmask = 0;
		wdc_c.timeout = 10000; /* 10s */
	} else {
		WDCDEBUG_PRINT(("ata_get_params: no disks\n"),
		    DEBUG_FUNCS|DEBUG_PROBE);
		return CMD_ERR;
	}

	tb = dma_alloc(ATAPARAMS_SIZE, PR_NOWAIT | PR_ZERO);
	if (tb == NULL)
		return CMD_AGAIN;
	wdc_c.flags = AT_READ | flags;
	wdc_c.data = tb;
	wdc_c.bcount = ATAPARAMS_SIZE;

	if ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {
		WDCDEBUG_PRINT(("%s: wdc_exec_command failed: %d\n",
		    __func__, ret), DEBUG_PROBE);
		dma_free(tb, ATAPARAMS_SIZE);
		return CMD_AGAIN;
	}

	if (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {
		WDCDEBUG_PRINT(("%s: IDENTIFY failed: 0x%x\n", __func__,
		    wdc_c.flags), DEBUG_PROBE);

		dma_free(tb, ATAPARAMS_SIZE);
		return CMD_ERR;
	} else {
#if BYTE_ORDER == BIG_ENDIAN
		/* All the fields in the params structure are 16-bit
		   integers except for the ID strings which are char
		   strings.  The 16-bit integers are currently in
		   memory in little-endian, regardless of architecture.
		   So, they need to be swapped on big-endian architectures
		   before they are accessed through the ataparams structure.

		   The swaps below avoid touching the char strings.
		*/

		swap16_multi((u_int16_t *)tb, 10);
		swap16_multi((u_int16_t *)tb + 20, 3);
		swap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);
#endif
		/* Read in parameter block. */
		bcopy(tb, prms, sizeof(struct ataparams));

		/*
		 * Shuffle string byte order.
		 * ATAPI Mitsumi and NEC drives don't need this.
		 */
		if ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==
		    WDC_CFG_ATAPI &&
		    ((prms->atap_model[0] == 'N' &&
			prms->atap_model[1] == 'E') ||
		     (prms->atap_model[0] == 'F' &&
			 prms->atap_model[1] == 'X'))) {
			dma_free(tb, ATAPARAMS_SIZE);
			return CMD_OK;
		}
		for (i = 0; i < sizeof(prms->atap_model); i += 2) {
			p = (u_short *)(prms->atap_model + i);
			*p = swap16(*p);
		}
		for (i = 0; i < sizeof(prms->atap_serial); i += 2) {
			p = (u_short *)(prms->atap_serial + i);
			*p = swap16(*p);
		}
		for (i = 0; i < sizeof(prms->atap_revision); i += 2) {
			p = (u_short *)(prms->atap_revision + i);
			*p = swap16(*p);
		}

		dma_free(tb, ATAPARAMS_SIZE);
		return CMD_OK;
	}
}

int
ata_set_mode(struct ata_drive_datas *drvp, u_int8_t mode, u_int8_t flags)
{
	struct wdc_command wdc_c;

	WDCDEBUG_PRINT(("%s: mode=0x%x, flags=0x%x\n", __func__,
	    mode, flags), DEBUG_PROBE);

	bzero(&wdc_c, sizeof(struct wdc_command));

	wdc_c.r_command = SET_FEATURES;
	wdc_c.r_st_bmask = 0;
	wdc_c.r_st_pmask = 0;
	wdc_c.r_features = WDSF_SET_MODE;
	wdc_c.r_count = mode;
	wdc_c.flags = flags;
	wdc_c.timeout = 1000; /* 1s */
	if (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE)
		return CMD_AGAIN;

	WDCDEBUG_PRINT(("%s: after wdc_exec_command() wdc_c.flags=0x%x\n",
	    __func__, wdc_c.flags), DEBUG_PROBE);

	if (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {
		return CMD_ERR;
	}
	return CMD_OK;
}

void
ata_dmaerr(struct ata_drive_datas *drvp)
{
	/*
	 * Downgrade decision: if we get NERRS_MAX in NXFER.
	 * We start with n_dmaerrs set to NERRS_MAX-1 so that the
	 * first error within the first NXFER ops will immediately trigger
	 * a downgrade.
	 * If we got an error and n_xfers is bigger than NXFER reset counters.
	 */
	drvp->n_dmaerrs++;
	if (drvp->n_dmaerrs >= NERRS_MAX && drvp->n_xfers <= NXFER) {
		wdc_downgrade_mode(drvp);
		drvp->n_dmaerrs = NERRS_MAX-1;
		drvp->n_xfers = 0;
		return;
	}
	if (drvp->n_xfers > NXFER) {
		drvp->n_dmaerrs = 1; /* just got an error */
		drvp->n_xfers = 1; /* restart counting from this error */
	}
}

void
ata_perror(struct ata_drive_datas *drvp, int errno, char *buf, size_t buf_len)
{
	static char *errstr0_3[] = {"address mark not found",
	    "track 0 not found", "aborted command", "media change requested",
	    "id not found", "media changed", "uncorrectable data error",
	    "bad block detected"};
	static char *errstr4_5[] = {"",
	    "no media/write protected", "aborted command",
	    "media change requested", "id not found", "media changed",
	    "uncorrectable data error", "interface CRC error"};
	char **errstr;
	int i;
	char *sep = "";
	size_t len = 0;

	if (drvp->ata_vers >= 4)
		errstr = errstr4_5;
	else
		errstr = errstr0_3;

	if (errno == 0) {
		snprintf(buf, buf_len, "error not notified");
	}

	for (i = 0; i < 8; i++) {
		if (errno & (1 << i)) {
			snprintf(buf + len, buf_len - len, "%s%s", sep,
			    errstr[i]);
			len = strlen(buf);
			sep = ", ";
		}
	}
}
@


1.34
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.33 2011/06/22 14:17:01 krw Exp $      */
d171 1
a171 1
	wdc_c.r_precomp = WDSF_SET_MODE;
@


1.33
log
@Print correct function name in debug statements. ata_get_params, not
ata_get_parms or wdc_ata_get_parms.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.32 2011/04/08 00:34:56 deraadt Exp $      */
a41 1
#include <dev/ic/wdcvar.h>
@


1.32
log
@one dma_free() was mistakenly left as free()
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.31 2011/04/03 12:47:04 krw Exp $      */
d69 1
a69 1
	WDCDEBUG_PRINT(("ata_get_parms\n"), DEBUG_FUNCS);
d84 1
a84 1
		WDCDEBUG_PRINT(("wdc_ata_get_parms: no disks\n"),
@


1.31
log
@Safer, big mem friendly, allocation of ATAPARAMS buf that is the
target of DMA.

ok deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.30 2010/07/23 07:47:12 jsg Exp $      */
d138 1
a138 1
			free(tb, M_DEVBUF);
@


1.30
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.29 2010/07/13 16:50:26 deraadt Exp $      */
d35 1
d89 1
a89 1
	tb = malloc(ATAPARAMS_SIZE, M_DEVBUF, M_NOWAIT | M_ZERO); /* XXX dma reachable */
d99 1
a99 1
		free(tb, M_DEVBUF);
d107 1
a107 1
		free(tb, M_DEVBUF);
d154 1
a154 1
		free(tb, M_DEVBUF);
@


1.29
log
@Do not put a data buffer on the stack; malloc it (we will use dma_alloc
later, when we trust it)
ok matthew
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.28 2007/04/08 14:20:26 pedro Exp $      */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.28
log
@Use CMD_OK instead of 0, no binary change, from mickey
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.27 2007/03/25 10:33:52 deraadt Exp $      */
d67 1
a67 1
	char tb[ATAPARAMS_SIZE];
a74 1
	bzero(tb, sizeof(tb));
d92 4
d103 1
d111 1
d141 2
a142 1
			 prms->atap_model[1] == 'X')))
d144 1
d158 1
@


1.27
log
@kill extra space in output with diskerr(); ok jsg
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.26 2006/12/21 02:44:55 krw Exp $      */
d137 1
a137 1
			return 0;
@


1.26
log
@'immediatly' -> 'immediately' in comments.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.25 2005/11/09 19:05:48 uwe Exp $      */
d234 1
a234 1
			snprintf(buf + len, buf_len - len, "%s %s", sep,
d237 1
a237 1
			sep = ",";
@


1.25
log
@Don't fall back to fake geometry if ata_get_params() fails.
"looks sane" grange@@; tested by niall@@ krw@@ jmc@@ jolan@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.24 2004/01/15 21:37:57 grange Exp $      */
d190 1
a190 1
	 * first error within the first NXFER ops will immediatly trigger
@


1.24
log
@ansi and some spaces; no f/c
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.23 2003/11/17 22:44:55 grange Exp $      */
a75 1
	bzero(prms, sizeof(struct ataparams));
@


1.23
log
@Various cleanups, knf, better debug messages.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.22 2003/11/17 21:50:14 grange Exp $      */
d64 2
a65 4
ata_get_params(drvp, flags, prms)
	struct ata_drive_datas *drvp;
	u_int8_t flags;
	struct ataparams *prms;
d157 1
a157 4
ata_set_mode(drvp, mode, flags)
	struct ata_drive_datas *drvp;
	u_int8_t mode;
	u_int8_t flags;
d186 1
a186 2
ata_dmaerr(drvp)
	struct ata_drive_datas *drvp;
@


1.22
log
@Don't wait for DRQ after issuing IDENTIFY command; instead check for DRQ
asserted after BSY is cleared in data read codepath. Solves delays in
probe.
The first version of this diff was done by costa@@ a long time ago but
had some issues. This one is a partial sync with NetBSD.

ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.21 2003/10/16 11:58:15 grange Exp $      */
d92 2
d101 2
a102 1
		printf ("WDC_EXEC_COMMAND: %d\n", ret);
d166 3
a168 1
	WDCDEBUG_PRINT(("ata_set_mode=0x%x\n", mode), DEBUG_FUNCS);
d180 4
@


1.21
log
@Cleanup a bit, more pretty debug messages.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.20 2003/09/28 21:01:42 grange Exp $      */
d84 1
a84 1
		wdc_c.r_st_pmask = WDCS_DRQ;
d89 1
a89 1
		wdc_c.r_st_pmask = WDCS_DRQ;
d171 1
a171 1
	wdc_c.flags = AT_READ | flags;
@


1.20
log
@kill trailing spaces, no functional changes
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.19 2003/04/14 22:51:54 grange Exp $      */
a70 1

d73 1
d98 3
a100 6
	{
		int ret;
		if ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {
			printf ("WDC_EXEC_COMMAND: %d\n", ret);
			return CMD_AGAIN;
		}
d104 2
a105 2
		WDCDEBUG_PRINT(("IDENTIFY failed: 0x%x\n", wdc_c.flags)
		    , DEBUG_PROBE);
@


1.19
log
@revert last change since it causes problems on some devices
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.17 2003/04/09 00:38:07 ho Exp $      */
d122 1
a122 1
		  
@


1.18
log
@Don't wait for DRQ after issuing IDENTIFY command. Fix long detecting
of atapi devices.
Problem reported by Nicolas Baldi <nib1@@cs.pitt.edu>, diff from costa@@.
@
text
@d84 1
a84 1
		wdc_c.r_st_pmask = 0;
d89 1
a89 1
		wdc_c.r_st_pmask = 0;
@


1.17
log
@sprintf->snprintf. miod@@, grange@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.16 2003/02/28 19:22:37 grange Exp $      */
d84 1
a84 1
		wdc_c.r_st_pmask = WDCS_DRQ;
d89 1
a89 1
		wdc_c.r_st_pmask = WDCS_DRQ;
@


1.16
log
@Increase IDENTIFY command timeout to 3 sec, as required by some
drives; from NetBSD
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.15 2003/02/21 20:10:32 grange Exp $      */
d209 1
a209 4
ata_perror(drvp, errno, buf)
	struct ata_drive_datas *drvp;
	int errno;
	char *buf;
d222 1
d230 1
a230 1
		sprintf(buf, "error not notified");
d235 3
a237 1
			buf += sprintf(buf, "%s %s", sep, errstr[i]);
@


1.15
log
@Fix Manuel Bouyer's copyright, from NetBSD
ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.14 2002/12/19 16:32:59 grange Exp $      */
d85 1
a85 1
		wdc_c.timeout = 1000; /* 1s */
@


1.14
log
@Protect WDCDEBUG_PRINT macro with do {} while (0)
ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.13 2001/09/21 17:55:43 miod Exp $      */
d4 1
a4 1
 * Copyright (c) 1998 Manuel Bouyer.  All rights reserved.
@


1.13
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.12 2001/07/12 01:45:42 csapuntz Exp $      */
d52 4
a55 3
#define WDCDEBUG_PRINT(args, level) \
        if (wdcdebug_mask & (level)) \
		printf args
@


1.13.4.1
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$      */
d4 1
a4 1
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
d52 3
a54 4
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_mask & (level)) != 0)	\
		printf args;			\
} while (0)
d84 1
a84 1
		wdc_c.timeout = 3000; /* 3s */
d208 4
a211 1
ata_perror(struct ata_drive_datas *drvp, int errno, char *buf, size_t buf_len)
a223 1
	size_t len = 0;
d231 1
a231 1
		snprintf(buf, buf_len, "error not notified");
d236 1
a236 3
			snprintf(buf + len, buf_len - len, "%s %s", sep,
			    errstr[i]);
			len = strlen(buf);
@


1.12
log
@

Rework of probe code. Try better to deal with floating buses. Depending
on the value floating on the bus, we would occasionally skip the register
writability tests. Whoops...

Move fix for a flash device that doesn't wake up until a command is sent

Try to supress spurious interrupts. However, if one does happen, acknowledge
it anyway by reading status. This prevents the interrupt condition from
persisting.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.11 2001/07/09 20:10:40 csapuntz Exp $      */
d100 1
a100 1
			printf ("WDC_EXEC_COMMAND: %d\n");
@


1.11
log
@ch_flags should be ch_status
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.10 2001/03/25 13:11:55 csapuntz Exp $      */
a72 1
	int try = 0;
a75 1
 again:
d82 1
a82 1
		wdc_c.r_st_bmask = (try == 0) ? WDCS_DRDY : 0;
a105 2
		struct channel_softc *chp = drvp->chnl_softc;

a107 11

		/* Andreas Gunnarsson reports a setup with a flash
		   disk where the ATA drive remains comatose until
		   it is sent a command */  
		if (try == 0 && (drvp->drive_flags & DRIVE_ATA) &&
		    (wdc_c.flags & AT_TIMEOU) &&
		    !(chp->ch_status & WDCS_BSY)) {
			WDCDEBUG_PRINT(("Retrying IDENTIFY\n"), DEBUG_PROBE);
			try++;
			goto again;
		}
@


1.10
log
@Minor mods to DMA interface - get rid of unnecessary args. Allow DMA functions to return status flags.

Note: Changing code to have DMA interface indicate when I/O is done (a la NetBSD) was considered. It was rejected due to questionable backward compatability
with ISA DMA and MAC obio DMA

Added irqack from NetBSD (though this feature should really be in the
PCI interrupt handlers)

Use pool
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.9 2001/01/29 02:18:33 niklas Exp $      */
d118 1
a118 1
		    !(chp->ch_flags & WDCS_BSY)) {
@


1.9
log
@Fix bug where timeouts triggered too early, caused panic on ATAPI tapes.
Removed hardcoded WDCDEBUG definitions.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.8 2000/10/29 18:42:49 deraadt Exp $      */
d196 24
@


1.8
log
@undo this; adds files, unacceptable at this point in release
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.6 2000/07/20 07:40:32 csapuntz Exp $      */
a46 2

#define WDCDEBUG
@


1.7
log
@

Reduce footprint of ATA driver by only having PROBE debug messages compiled
in by default.
@
text
@d47 13
a59 1
#include <dev/ic/wdcdbg.h>
d104 1
d112 2
a113 1
		WDCDEBUG_PRINT_PROBE(("IDENTIFY failed: 0x%x\n", wdc_c.flags));
d121 1
a121 2
			WDCDEBUG_PRINT_PROBE
			    (("Retrying IDENTIFY\n"));
@


1.6
log
@

Fix to ATA detect. Some devices seem to be comatose after reset
(return 0x00 status persistently). Send them identify to wake them up.

Flag value 0x10000 will enable probe messages for a channel/controller.
When UKC supports setting flags, this will be useful debugging
failing IDE detects without kernel recompiles.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.5 2000/04/07 11:22:46 niklas Exp $      */
d47 1
a47 13

#define WDCDEBUG

#define DEBUG_FUNCS  0x08
#define DEBUG_PROBE  0x10
#ifdef WDCDEBUG
extern int wdcdebug_mask; /* init'ed in wdc.c */
#define WDCDEBUG_PRINT(args, level) \
        if (wdcdebug_mask & (level)) \
		printf args
#else
#define WDCDEBUG_PRINT(args, level)
#endif
a91 1
			printf ("WDC_EXEC_COMMAND: %d\n");
d99 1
a99 2
		WDCDEBUG_PRINT(("IDENTIFY failed: 0x%x\n", wdc_c.flags)
		    , DEBUG_PROBE);
d107 2
a108 1
			WDCDEBUG_PRINT(("Retrying IDENTIFY\n"), DEBUG_PROBE);
@


1.5
log
@correct debug printouts
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.4 1999/11/17 01:22:55 csapuntz Exp $      */
d41 2
a42 1
#include <dev/ic/wdcreg.h>
d45 4
d75 1
d79 1
d86 1
a86 1
		wdc_c.r_st_bmask = WDCS_DRDY;
d110 16
@


1.4
log
@

New interface to ATA registers that goes through the lower-level device
driver (pciide, wdc, etc.)

Remove #define WDCDEBUG from top of files

More fixes to ATAPISCSI logic:

Not all devices transition correctly between phases. Devices are supposed
to keep BSY high until they've set the registers to the next sensible
state. Some devices drop BSY and leave the registers in an old or
nonsense state. Our polling code is extremely sensitive to this
(though an early itnerrupt could also observe this). So, if the device is
in an unexpected state, the new polling code waits for a while in the hope
that it enters a better state.

This seems to fix many of the problems reported.

Also, there was a horrible bug which would cause sense to fail on a ATAPI
command that sent data to the drive
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.3 1999/11/05 04:32:03 csapuntz Exp $      */
d71 1
a71 1
	WDCDEBUG_PRINT(("wdc_ata_get_parms\n"), DEBUG_FUNCS);
d159 1
a159 1
	WDCDEBUG_PRINT(("wdc_ata_set_mode=0x%x\n", mode), DEBUG_FUNCS);
@


1.4.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.10 2001/03/25 13:11:55 csapuntz Exp $      */
d41 1
a41 2
#include <machine/bus.h>

a43 2
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcvar.h>
a69 1
	int try = 0;
d71 1
a71 1
	WDCDEBUG_PRINT(("ata_get_parms\n"), DEBUG_FUNCS);
a72 1
 again:
d79 1
a79 1
		wdc_c.r_st_bmask = (try == 0) ? WDCS_DRDY : 0;
a102 16
		struct channel_softc *chp = drvp->chnl_softc;

		WDCDEBUG_PRINT(("IDENTIFY failed: 0x%x\n", wdc_c.flags)
		    , DEBUG_PROBE);

		/* Andreas Gunnarsson reports a setup with a flash
		   disk where the ATA drive remains comatose until
		   it is sent a command */  
		if (try == 0 && (drvp->drive_flags & DRIVE_ATA) &&
		    (wdc_c.flags & AT_TIMEOU) &&
		    !(chp->ch_flags & WDCS_BSY)) {
			WDCDEBUG_PRINT(("Retrying IDENTIFY\n"), DEBUG_PROBE);
			try++;
			goto again;
		}

d159 1
a159 1
	WDCDEBUG_PRINT(("ata_set_mode=0x%x\n", mode), DEBUG_FUNCS);
a174 24
}

void
ata_dmaerr(drvp)
	struct ata_drive_datas *drvp;
{
	/*
	 * Downgrade decision: if we get NERRS_MAX in NXFER.
	 * We start with n_dmaerrs set to NERRS_MAX-1 so that the
	 * first error within the first NXFER ops will immediatly trigger
	 * a downgrade.
	 * If we got an error and n_xfers is bigger than NXFER reset counters.
	 */
	drvp->n_dmaerrs++;
	if (drvp->n_dmaerrs >= NERRS_MAX && drvp->n_xfers <= NXFER) {
		wdc_downgrade_mode(drvp);
		drvp->n_dmaerrs = NERRS_MAX-1;
		drvp->n_xfers = 0;
		return;
	}
	if (drvp->n_xfers > NXFER) {
		drvp->n_dmaerrs = 1; /* just got an error */
		drvp->n_xfers = 1; /* restart counting from this error */
	}
@


1.4.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.4.2.1 2001/05/14 22:23:05 niklas Exp $      */
d73 1
d77 1
d84 1
a84 1
		wdc_c.r_st_bmask = WDCS_DRDY;
d102 1
a102 1
			printf ("WDC_EXEC_COMMAND: %d\n", ret);
d108 2
d112 11
@


1.4.2.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*      $OpenBSD$      */
d4 1
a4 1
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
d52 3
a54 4
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_mask & (level)) != 0)	\
		printf args;			\
} while (0)
d84 1
a84 1
		wdc_c.timeout = 3000; /* 3s */
@


1.4.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.4.2.3 2003/03/28 00:38:10 niklas Exp $      */
d209 4
a212 1
ata_perror(struct ata_drive_datas *drvp, int errno, char *buf, size_t buf_len)
a224 1
	size_t len = 0;
d232 1
a232 1
		snprintf(buf, buf_len, "error not notified");
d237 1
a237 3
			snprintf(buf + len, buf_len - len, "%s %s", sep,
			    errstr[i]);
			len = strlen(buf);
@


1.4.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD$      */
d64 4
a67 2
ata_get_params(struct ata_drive_datas *drvp, u_int8_t flags,
    struct ataparams *prms)
d71 1
a73 1
	int ret;
d84 1
a84 1
		wdc_c.r_st_pmask = 0;
d89 1
a89 1
		wdc_c.r_st_pmask = 0;
a91 2
		WDCDEBUG_PRINT(("wdc_ata_get_parms: no disks\n"),
		    DEBUG_FUNCS|DEBUG_PROBE);
d98 6
a103 4
	if ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {
		WDCDEBUG_PRINT(("%s: wdc_exec_command failed: %d\n",
		    __func__, ret), DEBUG_PROBE);
		return CMD_AGAIN;
d107 2
a108 2
		WDCDEBUG_PRINT(("%s: IDENTIFY failed: 0x%x\n", __func__,
		    wdc_c.flags), DEBUG_PROBE);
d122 1
a122 1

d159 4
a162 1
ata_set_mode(struct ata_drive_datas *drvp, u_int8_t mode, u_int8_t flags)
d166 1
a166 3
	WDCDEBUG_PRINT(("%s: mode=0x%x, flags=0x%x\n", __func__,
	    mode, flags), DEBUG_PROBE);

d174 1
a174 1
	wdc_c.flags = flags;
a177 4

	WDCDEBUG_PRINT(("%s: after wdc_exec_command() wdc_c.flags=0x%x\n",
	    __func__, wdc_c.flags), DEBUG_PROBE);

d185 2
a186 1
ata_dmaerr(struct ata_drive_datas *drvp)
@


1.3
log
@

Fix ata_get_params on big endian platforms.

We have diverged from NetBSD in that wdc_exec_xfer no longer automatically
swaps.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.2 1999/08/05 00:12:09 niklas Exp $      */
a30 4

#ifndef WDCDEBUG
#define WDCDEBUG
#endif /* WDCDEBUG */
@


1.2
log
@Make IDE compile on alpha again:
use b* instead of mem* functions, adhere to NISADMA for DMA support.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.1 1999/07/18 21:25:17 csapuntz Exp $      */
d60 2
d69 1
a69 1
	char tb[DEV_BSIZE];
a71 1
#if BYTE_ORDER == LITTLE_ENDIAN
a73 1
#endif
d77 1
a77 1
	bzero(tb, DEV_BSIZE);
d96 1
a96 1
	wdc_c.bcount = DEV_BSIZE;
d109 15
d126 1
a126 1
#if BYTE_ORDER == LITTLE_ENDIAN
d140 1
a140 1
			*p = ntohs(*p);
d144 1
a144 1
			*p = ntohs(*p);
d148 1
a148 1
			*p = ntohs(*p);
d150 1
a150 1
#endif
@


1.1
log
@

Import of NetBSD ATA/IDE stuff.

Introduction of home-grown

To enable this stuff in your configuration, look at the NEWATA conf file
and go through

dev/isa/files.isa
dev/pci/files.pci
conf/files
arch/i386/conf/files.i386

and follow the instructions on commenting/uncommenting stuff
@
text
@d1 1
a1 1
/*      $OpenBSD: ata.c,v 1.9 1999/04/15 09:41:09 bouyer Exp $      */
d77 3
a79 3
	memset(tb, 0, DEV_BSIZE);
	memset(prms, 0, sizeof(struct ataparams));
	memset(&wdc_c, 0, sizeof(struct wdc_command));
d110 1
a110 1
		memcpy(prms, tb, sizeof(struct ataparams));
d149 1
a149 1
	memset(&wdc_c, 0, sizeof(struct wdc_command));
@

