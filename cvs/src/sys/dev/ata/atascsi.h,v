head	1.52;
access;
symbols
	OPENBSD_6_2:1.52.0.4
	OPENBSD_6_2_BASE:1.52
	OPENBSD_6_1:1.50.0.8
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.49.0.4
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.48.0.8
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.48.0.6
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.47.0.10
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.47.0.8
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.47.0.6
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.4
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.45.0.2
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.32.0.4
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.52
date	2017.05.31.05.54.06;	author jmatthew;	state Exp;
branches;
next	1.51;
commitid	2p4gp1YCBXm8CZZv;

1.51
date	2017.05.31.05.47.29;	author jmatthew;	state Exp;
branches;
next	1.50;
commitid	HzlQQtwlto0xYm76;

1.50
date	2015.12.29.09.44.46;	author kettenis;	state Exp;
branches;
next	1.49;
commitid	2kurxjxTY0o8fPnX;

1.49
date	2015.05.15.10.54.26;	author dlg;	state Exp;
branches;
next	1.48;
commitid	lsYfop0A1uJxUQF8;

1.48
date	2013.12.09.11.44.52;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.08.07.43.05;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2011.05.08.19.46.10;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.26.21.41.00;	author drahn;	state Exp;
branches;
next	1.44;

1.44
date	2010.09.23.11.41.54;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2010.09.20.06.02.50;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.03.00.41.58;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.05.11.33.26;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.22.00.58.32;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.19.10.52.15;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.05.04.11.06;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.05.00.55.03;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.03.07.09.29;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.08.08.07.51;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2009.12.07.09.37.34;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.01.03.09.15;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2007.12.28.16.19.14;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.06.12.19.01;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.28.18.16.08;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.26.20.13.53;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.26.15.59.53;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.23.18.21.55;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.12.13.08.34;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.10.07.57.21;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.05.11.13.05;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.04.12.39.16;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.02.05.14.52;	author pascoe;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.22.05.15.39;	author pascoe;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.21.12.41.28;	author pascoe;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.21.00.09.16;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.20.14.10.53;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.20.12.01.18;	author pascoe;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.20.11.07.02;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.20.10.02.31;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.20.08.47.46;	author pascoe;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.20.07.45.11;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.20.07.09.42;	author pascoe;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.20.05.33.02;	author pascoe;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.20.04.38.11;	author pascoe;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.13.11.22.36;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.13.11.20.57;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.28.13.25.42;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.19.13.18.08;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.19.12.10.40;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.19.11.53.34;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.19.11.48.34;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.19.11.44.24;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.52
log
@add some details relating to SATA device power management
part of a diff from Imre Vadasz via sf@@
@
text
@/*	$OpenBSD: atascsi.h,v 1.51 2017/05/31 05:47:29 jmatthew Exp $ */

/*
 * Copyright (c) 2007 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2010 Conformal Systems LLC <info@@conformal.com>
 * Copyright (c) 2010 Jonathan Matthew <jonathan@@d14n.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _DEV_ATA_ATASCSI_H_
#define _DEV_ATA_ATASCSI_H_

#include <sys/task.h>

struct atascsi;
struct scsi_link;

/*
 * ATA commands
 */

#define ATA_C_READDMA_EXT	0x25
#define ATA_C_READ_LOG_EXT	0x2f
#define ATA_C_WRITEDMA_EXT	0x35
#define ATA_C_READ_FPDMA	0x60
#define ATA_C_WRITE_FPDMA	0x61
#define ATA_C_PACKET		0xa0
#define ATA_C_IDENTIFY_PACKET	0xa1
#define ATA_C_READDMA		0xc8
#define ATA_C_WRITEDMA		0xca
#define ATA_C_STANDBY_IMMED	0xe0
#define ATA_C_READ_PM		0xe4
#define ATA_C_WRITE_PM		0xe8
#define ATA_C_FLUSH_CACHE	0xe7
#define ATA_C_FLUSH_CACHE_EXT	0xea /* lba48 */
#define ATA_C_IDENTIFY		0xec
#define ATA_C_SET_FEATURES	0xef
#define ATA_C_SEC_FREEZE_LOCK	0xf5
#define ATA_C_DSM		0x06

/*
 * ATA SET FEATURES subcommands (feature field)
 */
#define ATA_SF_WRITECACHE_EN	0x02
#define ATA_SF_XFERMODE		0x03
#define ATA_SF_SATA_FEATURE_EN	0x10
#define  ATA_SF_XFERMODE_UDMA	0x40
#define ATA_SF_SATA_FEATURE_DIS	0x90
#define ATA_SF_LOOKAHEAD_EN	0xaa

/*
 * ATA SET FEATURES args (count field)
 */
#define ATA_SF_SATA_DEVIPS	0x03	/* Device-initiated power management */
#define ATA_SF_SATA_DEVAPS	0x07	/* Device Automatic Partial to Slumber transitions */
#define ATA_SF_SATA_DEVSLEEP	0x09	/* DevSleep power management state */

struct ata_identify {
	u_int16_t	config;		/*   0 */
	u_int16_t	ncyls;		/*   1 */
	u_int16_t	reserved1;	/*   2 */
	u_int16_t	nheads;		/*   3 */
	u_int16_t	track_size;	/*   4 */
	u_int16_t	sector_size;	/*   5 */
	u_int16_t	nsectors;	/*   6 */
	u_int16_t	reserved2[3];	/*   7 vendor unique */
	u_int8_t	serial[20];	/*  10 */
	u_int16_t	buffer_type;	/*  20 */
	u_int16_t	buffer_size;	/*  21 */
	u_int16_t	ecc;		/*  22 */
	u_int8_t	firmware[8];	/*  23 */
	u_int8_t	model[40];	/*  27 */
	u_int16_t	multi;		/*  47 */
	u_int16_t	dwcap;		/*  48 */
	u_int16_t	cap;		/*  49 */
	u_int16_t	reserved3;	/*  50 */
	u_int16_t	piomode;	/*  51 */
	u_int16_t	dmamode;	/*  52 */
	u_int16_t	validinfo;	/*  53 */
#define ATA_ID_VALIDINFO_ULTRADMA	0x0004
	u_int16_t	curcyls;	/*  54 */
	u_int16_t	curheads;	/*  55 */
	u_int16_t	cursectrk;	/*  56 */
	u_int16_t	curseccp[2];	/*  57 */
	u_int16_t	mult2;		/*  59 */
	u_int16_t	addrsec[2];	/*  60 */
	u_int16_t	worddma;	/*  62 */
	u_int16_t	dworddma;	/*  63 */
	u_int16_t	advpiomode;	/*  64 */
	u_int16_t	minmwdma;	/*  65 */
	u_int16_t	recmwdma;	/*  66 */
	u_int16_t	minpio;		/*  67 */
	u_int16_t	minpioflow;	/*  68 */
	u_int16_t	add_support;	/*  69 */
#define ATA_ID_ADD_SUPPORT_DRT	0x4000
	u_int16_t	reserved4;	/*  70 */
	u_int16_t	typtime[2];	/*  71 */
	u_int16_t	reserved5[2];	/*  73 */
	u_int16_t	qdepth;		/*  75 */
#define ATA_QDEPTH(_q)		(((_q) & 0x1f) + 1)
	u_int16_t	satacap;	/*  76 */
#define ATA_SATACAP_GEN1	0x0002
#define ATA_SATACAP_GEN2	0x0004
#define ATA_SATACAP_GEN3	0x0008
#define ATA_SATACAP_NCQ		0x0100
#define ATA_SATACAP_HIPM	0x0200
#define ATA_SATACAP_HOSTAPS	0x2000
#define ATA_SATACAP_DEVAPS	0x4000
	u_int16_t	reserved6;	/*  77 */
	u_int16_t	satafsup;	/*  78 */
#define ATA_SATAFSUP_DIPM	0x0008
#define ATA_SATAFSUP_DEVSLP	0x0100
	u_int16_t	satafen;	/*  79 */
#define ATA_SATAFEN_DIPM	0x0008
#define ATA_SATAFEN_DEVSLP	0x0100
	u_int16_t	majver;		/*  80 */
	u_int16_t	minver;		/*  81 */
	u_int16_t	cmdset82;	/*  82 */
	u_int16_t	cmdset83;	/*  83 */
	u_int16_t	cmdset84;	/*  84 */
	u_int16_t	features85;	/*  85 */
	u_int16_t	features86;	/*  86 */
	u_int16_t	features87;	/*  87 */
#define ATA_ID_F87_WWN		(1<<8)
	u_int16_t	ultradma;	/*  88 */
	u_int16_t	erasetime;	/*  89 */
	u_int16_t	erasetimex;	/*  90 */
	u_int16_t	apm;		/*  91 */
	u_int16_t	masterpw;	/*  92 */
	u_int16_t	hwreset;	/*  93 */
	u_int16_t	acoustic;	/*  94 */
	u_int16_t	stream_min;	/*  95 */
	u_int16_t	stream_xfer_d;	/*  96 */
	u_int16_t	stream_lat;	/*  97 */
	u_int16_t	streamperf[2];	/*  98 */
	u_int16_t	addrsecxt[4];	/* 100 */
	u_int16_t	stream_xfer_p;	/* 104 */
	u_int16_t	padding1;	/* 105 */
	u_int16_t	p2l_sect;	/* 106 */
#define ATA_ID_P2L_SECT_MASK	0xc000
#define ATA_ID_P2L_SECT_VALID	0x4000
#define ATA_ID_P2L_SECT_SET	0x2000
#define ATA_ID_P2L_SECT_SIZESET	0x1000
#define ATA_ID_P2L_SECT_SIZE	0x000f
	u_int16_t	seek_delay;	/* 107 */
	u_int16_t	naa_ieee_oui;	/* 108 */
	u_int16_t	ieee_oui_uid;	/* 109 */
	u_int16_t	uid_mid;	/* 110 */
	u_int16_t	uid_low;	/* 111 */
	u_int16_t	resv_wwn[4];	/* 112 */
	u_int16_t	incits;		/* 116 */
	u_int16_t	words_lsec[2];	/* 117 */
	u_int16_t	cmdset119;	/* 119 */
	u_int16_t	features120;	/* 120 */
	u_int16_t	padding2[6];
	u_int16_t	rmsn;		/* 127 */
	u_int16_t	securestatus;	/* 128 */
	u_int16_t	vendor[31];	/* 129 */
	u_int16_t	padding3[8];	/* 160 */
	u_int16_t	form;		/* 168 */
#define ATA_ID_FORM_MASK	0x000f
	u_int16_t	data_set_mgmt;	/* 169 */
#define ATA_ID_DATA_SET_MGMT_TRIM 0x0001
	u_int16_t	padding4[6];	/* 170 */
	u_int16_t	curmedser[30];	/* 176 */
	u_int16_t	sctsupport;	/* 206 */
	u_int16_t	rpm;		/* 207 */
	u_int16_t	padding5[1];	/* 208 */
	u_int16_t	logical_align;	/* 209 */
#define ATA_ID_LALIGN_MASK	0xc000
#define ATA_ID_LALIGN_VALID	0x4000
#define ATA_ID_LALIGN		0x3fff
	u_int16_t	padding6[45];	/* 210 */
	u_int16_t	integrity;	/* 255 */
} __packed;

/*
 * IDENTIFY DEVICE data
 */
#define ATA_IDENTIFY_WRITECACHE		(1 << 5)
#define ATA_IDENTIFY_LOOKAHEAD		(1 << 6)

/*
 * ATA DSM (Data Set Management) subcommands
 */
#define ATA_DSM_TRIM		0x01

#define ATA_DSM_TRIM_DESC(_lba, _len)	((_lba) | ((u_int64_t)(_len) << 48))
#define ATA_DSM_TRIM_MAX_LEN		0xffff

/*
 * Frame Information Structures
 */

#define ATA_FIS_LENGTH		20

struct ata_fis_h2d {
	u_int8_t		type;
#define ATA_FIS_TYPE_H2D		0x27
	u_int8_t		flags;
#define ATA_H2D_FLAGS_CMD		(1<<7)
	u_int8_t		command;
	u_int8_t		features;
#define ATA_H2D_FEATURES_DMA		(1<<0)
#define ATA_H2D_FEATURES_DIR		(1<<2)
#define ATA_H2D_FEATURES_DIR_READ	(1<<2)
#define ATA_H2D_FEATURES_DIR_WRITE	(0<<2)

	u_int8_t		lba_low;
	u_int8_t		lba_mid;
	u_int8_t		lba_high;
	u_int8_t		device;
#define ATA_H2D_DEVICE_LBA		0x40

	u_int8_t		lba_low_exp;
	u_int8_t		lba_mid_exp;
	u_int8_t		lba_high_exp;
	u_int8_t		features_exp;

	u_int8_t		sector_count;
	u_int8_t		sector_count_exp;
	u_int8_t		reserved0;
	u_int8_t		control;
#define ATA_FIS_CONTROL_SRST		0x04
#define ATA_FIS_CONTROL_4BIT		0x08

	u_int8_t		reserved1;
	u_int8_t		reserved2;
	u_int8_t		reserved3;
	u_int8_t		reserved4;
} __packed;

struct ata_fis_d2h {
	u_int8_t		type;
#define ATA_FIS_TYPE_D2H		0x34
	u_int8_t		flags;
#define ATA_D2H_FLAGS_INTR		(1<<6)
	u_int8_t		status;
	u_int8_t		error;

	u_int8_t		lba_low;
	u_int8_t		lba_mid;
	u_int8_t		lba_high;
	u_int8_t		device;

	u_int8_t		lba_low_exp;
	u_int8_t		lba_mid_exp;
	u_int8_t		lba_high_exp;
	u_int8_t		reserved0;

	u_int8_t		sector_count;
	u_int8_t		sector_count_exp;
	u_int8_t		reserved1;
	u_int8_t		reserved2;

	u_int8_t		reserved3;
	u_int8_t		reserved4;
	u_int8_t		reserved5;
	u_int8_t		reserved6;
} __packed;

/*
 * SATA log page 10h - 
 * looks like a D2H FIS, with errored tag number in first byte.
 */
struct ata_log_page_10h {
	struct ata_fis_d2h	err_regs;
#define ATA_LOG_10H_TYPE_NOTQUEUED	0x80
#define ATA_LOG_10H_TYPE_TAG_MASK	0x1f
	u_int8_t		reserved[256 - sizeof(struct ata_fis_d2h)];
	u_int8_t		vendor_specific[255];
	u_int8_t		checksum;
} __packed;

/*
 * SATA registers
 */

#define SATA_SStatus_DET		0x00f
#define SATA_SStatus_DET_NODEV		0x000
#define SATA_SStatus_DET_NOPHY		0x001
#define SATA_SStatus_DET_DEV		0x003
#define SATA_SStatus_DET_OFFLINE	0x004

#define SATA_SStatus_SPD		0x0f0
#define SATA_SStatus_SPD_NONE		0x000
#define SATA_SStatus_SPD_1_5		0x010
#define SATA_SStatus_SPD_3_0		0x020
#define SATA_SStatus_SPD_6_0		0x030

#define SATA_SStatus_IPM		0xf00
#define SATA_SStatus_IPM_NODEV		0x000
#define SATA_SStatus_IPM_ACTIVE		0x100
#define SATA_SStatus_IPM_PARTIAL	0x200
#define SATA_SStatus_IPM_SLUMBER	0x600
#define SATA_SStatus_IPM_DEVSLEEP	0x800

#define SATA_SIGNATURE_PORT_MULTIPLIER	0x96690101
#define SATA_SIGNATURE_ATAPI		0xeb140101
#define SATA_SIGNATURE_DISK		0x00000101

/*
 * ATA interface
 */

struct ata_xfer {
	struct ata_fis_h2d	*fis;
	struct ata_fis_d2h	rfis;
	u_int8_t		*packetcmd;
	u_int8_t		tag;

	void			*data;
	size_t			datalen;
	size_t			resid;

	void			(*complete)(struct ata_xfer *);
	struct task		task;
	struct timeout		stimeout;
	u_int			timeout;

	int			flags;
#define ATA_F_READ			(1<<0)
#define ATA_F_WRITE			(1<<1)
#define ATA_F_NOWAIT			(1<<2)
#define ATA_F_POLL			(1<<3)
#define ATA_F_PIO			(1<<4)
#define ATA_F_PACKET			(1<<5)
#define ATA_F_NCQ			(1<<6)
#define ATA_F_DONE			(1<<7)
#define ATA_F_GET_RFIS			(1<<8)
#define ATA_FMT_FLAGS			"\020" "\011GET_RFIS" "\010DONE" \
					"\007NCQ" "\006PACKET" "\005PIO" \
					"\004POLL" "\003NOWAIT" "\002WRITE" \
					"\001READ"

	volatile int		state;
#define ATA_S_SETUP			0
#define ATA_S_PENDING			1
#define ATA_S_COMPLETE			2
#define ATA_S_ERROR			3
#define ATA_S_TIMEOUT			4
#define ATA_S_ONCHIP			5
#define ATA_S_PUT			6
#define ATA_S_DONE			7

	void			*atascsi_private;

	int			pmp_port;
};

/*
 * atascsi
 */

struct atascsi_methods {
	int			(*ata_probe)(void *, int, int);
	void			(*ata_free)(void *, int, int);
	struct ata_xfer *	(*ata_get_xfer)(void *, int);
	void			(*ata_put_xfer)(struct ata_xfer *);
	void			(*ata_cmd)(struct ata_xfer *);
};

struct atascsi_attach_args {
	void			*aaa_cookie;

	struct atascsi_methods	*aaa_methods;
	void			(*aaa_minphys)(struct buf *,
				    struct scsi_link *);
	int			aaa_nports;
	int			aaa_ncmds;
	int			aaa_capability;
#define ASAA_CAP_NCQ		(1 << 0)
#define ASAA_CAP_NEEDS_RESERVED	(1 << 1)
#define ASAA_CAP_PMP_NCQ	(1 << 2)
};

#define ATA_PORT_T_NONE		0
#define ATA_PORT_T_DISK		1
#define ATA_PORT_T_ATAPI	2
#define ATA_PORT_T_PM		3

struct atascsi	*atascsi_attach(struct device *, struct atascsi_attach_args *);
int		atascsi_detach(struct atascsi *, int);

int		atascsi_probe_dev(struct atascsi *, int, int);
int		atascsi_detach_dev(struct atascsi *, int, int, int);

void		ata_complete(struct ata_xfer *);

#endif /* _DEV_ATA_ATASCSI_H_ */
@


1.51
log
@fix SATA_SStatus_DET_OFFLINE value and add newer SStatus bits
from Imre Vadasz via sf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.50 2015/12/29 09:44:46 kettenis Exp $ */
d53 1
a53 1
 * ATA SET FEATURES subcommands
d57 1
d59 1
d62 7
d115 1
d117 3
a119 1
#define ATA_SATACAP_PWRMGMT	0x0200
d122 2
d125 2
@


1.50
log
@Set UltraDMA transfer mode.  Some (early?) SATA drives, such as the Maxtor
7Y250M0, refuse to do DMA unless the transfer mode has been set.  This causes
reads (and presumably writes) to time out.

Unlike the wdc code, this only sets the UltraDMA transfer mode.  If we ever
want to support ancient PATA drivers through the atascsi layer, we probably
need to set the PIO and/or MWDMA transfer modes as well.

ok jmatthew@@, dlg@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.49 2015/05/15 10:54:26 dlg Exp $ */
d278 1
a278 1
#define SATA_SStatus_DET_OFFLINE	0x008
d284 1
d291 1
@


1.49
log
@rename the probe and free members of atascsi_methods to ata_probe
and ata_free.

this makes them consistent with the rest of the members, and lets
me #define free to weird debug things in the kernel without screwing
these files up.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.48 2013/12/09 11:44:52 dlg Exp $ */
d56 2
d82 1
@


1.48
log
@replace workq_task_add with a task. stash teh struct in the ata xfer thing
so its now reliable.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.47 2011/07/08 07:43:05 dlg Exp $ */
d346 2
a347 2
	int			(*probe)(void *, int, int);
	void			(*free)(void *, int, int);
@


1.47
log
@macros for TRIM
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.46 2011/05/08 19:46:10 matthew Exp $ */
d24 2
d307 1
@


1.46
log
@Move ata_put_xfer() from ata_xfer to atascsi_methods.  It's just silly
to have a non-changing function pointer be part of an object rather
than it's virtual method table.

ok dlg@@; tested on ahci(4) by Mattieu Baptiste, jasper@@, and Jason
Crawford; no sili(4) testers, but identical changes to ahci(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.45 2011/01/26 21:41:00 drahn Exp $ */
d177 3
@


1.45
log
@Add port multiplier support, has been in snaps for a while with no reported
issues. No actual OKs, but general acknowledgement and 'get it in' from several.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.44 2010/09/23 11:41:54 dlg Exp $ */
d21 3
a332 2

	void			(*ata_put_xfer)(struct ata_xfer *);
d343 1
d373 2
@


1.44
log
@commands and bits for data set management.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.43 2010/09/20 06:02:50 dlg Exp $ */
d5 2
d38 2
d208 2
d311 5
a315 3
#define ATA_FMT_FLAGS			"\020" "\007DONE" "\007NCQ" \
					"\006PACKET" "\005PIO" "\004POLL" \
					"\003NOWAIT" "\002WRITE" "\001READ"
d329 2
d339 3
a341 3
	int			(*probe)(void *, int);
	void			(*free)(void *, int);
	struct ata_xfer *	(*ata_get_xfer)(void *, int );
d356 1
d362 1
d367 2
a368 2
int		atascsi_probe_dev(struct atascsi *, int);
int		atascsi_detach_dev(struct atascsi *, int, int);
@


1.43
log
@define and use macros for looking at ncq bits.

requested by and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.42 2010/07/03 00:41:58 kettenis Exp $ */
d41 1
d165 5
@


1.42
log
@Implement translation of the SCSI START STOP UNIT command.

ok dlg@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.41 2010/05/05 11:33:26 dlg Exp $ */
d89 1
d91 4
@


1.41
log
@map the ATA data set management stuff (ie, trim) to the SCSI thin
provisioning bits in read cap 16
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.40 2010/04/22 00:58:32 dlg Exp $ */
d35 1
@


1.40
log
@cut atascsi over to providing and using iopools. this gets rid of NO_CCB
and makes the ioctl path more reliable on busy disks by allowing it to
sleep in the runqueue for an io to use.

mk@@ did the original diff and figured most of the problems out. ok mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.39 2010/04/19 10:52:15 dlg Exp $ */
d82 3
a84 1
	u_int16_t	reserved4[2];	/*  69 */
d138 3
a140 1
	u_int16_t	padding4[7];	/* 169 */
@


1.39
log
@move the stupid throwing away of ata_xfers out the run of the first scsi
inquiry against the device up to when the port is probed. this has been
bugging me for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.38 2010/04/05 04:11:06 dlg Exp $ */
a265 11
struct ata_port {
	struct ata_identify	ap_identify;
	struct atascsi		*ap_as;
	int			ap_port;
	int			ap_type;
#define ATA_PORT_T_NONE			0
#define ATA_PORT_T_DISK			1
#define ATA_PORT_T_ATAPI		2
	int			ap_ncqdepth;
};

d331 4
@


1.38
log
@fill in the the lowest aligned logical block address field. it
indicates the LBA of the first logical block that is located at the
beginning of a physical block

implemented as best as i can by my understanding of the spec. not tested
yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.37 2010/04/05 00:55:03 dlg Exp $ */
a273 2
	int			ap_features;
#define ATA_PORT_F_PROBED		(1 << 0)
@


1.37
log
@add support for ata disks with block sizes other than 512 bytes. i havent
ever seen one, but the spec describes how to do it.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.36 2010/04/03 07:09:29 dlg Exp $ */
d140 6
a145 1
	u_int16_t	padding5[47];	/* 208 */
@


1.36
log
@add support for emulating the disk characteristics and disk limits vpd
pages. this if the first step in figuring out if disks use a different
physical block size compared to the logical block size they present to the
operating system.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.35 2009/12/08 08:07:51 dlg Exp $ */
d117 1
a117 1
#define ATA_ID_P2L_SECT_LARGE	0x1000
@


1.35
log
@krw and marco found another problem with my atascsi chanages.

turns out you cant send atapi devices the ata IDENTIFY command, they dont
grok it. you have to send a PACKET IDENTIFY instead, which is exactly the
same but with a different command id.

this diff changes it so we send a PACKET IDENTIFY to atapi devices.

my diff "broke" this because it actually checks to see if the IDENTIFY
succeeded rather than just completed. the previous code was wrong with
regard to atapi devices. it is just lucky we dont use the IDENTIFY output
for atapi devs.

my apologies to marco@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.32 2008/01/01 03:09:15 dlg Exp $ */
d113 6
a118 1
	u_int16_t	phys_sect_sz;	/* 106 */
d133 4
a136 1
	u_int16_t	padding3[16];	/* 160 */
d139 2
a140 1
	u_int16_t	padding4[48];	/* 207 */
@


1.34
log
@get rid of the return codes from command submission, ata_cmd handlers
now return void. all state about a command is now represented within
the ata_xfer structure, and all layers using it (both hba and
atascsi) now check only ata_xfer.

this relies on my scsi midlayer changes. it was written just before
the second last backout of the midlayer.
@
text
@d32 1
@


1.33
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d286 4
a289 3
#define ATA_FMT_FLAGS			"\020" "\007NCQ" "\006PACKET" \
					"\005PIO" "\004POLL" "\003NOWAIT" \
					"\002WRITE" "\001READ"
d299 1
a305 4
#define ATA_QUEUED		0
#define ATA_COMPLETE		1
#define ATA_ERROR		2

d314 1
a314 1
	int			(*ata_cmd)(struct ata_xfer *);
d335 2
@


1.32
log
@provide a thing for use with %b to show which xa flags are set.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.31 2007/12/28 16:19:14 dlg Exp $ */
d20 1
d323 2
a324 1
	void			(*aaa_minphys)(struct buf *);
@


1.31
log
@massage the way vpds are defined. rename the page used for the devices
serial number and split the vpd header out for use in other places. while
here define the device identification page bits too.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.30 2007/12/06 12:19:01 jsg Exp $ */
d285 4
@


1.30
log
@Ask for write cache and read look ahead to be turned
on if supported as per the wd changes.  Some drives don't
do this for us and it helps performance by a large amount.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.29 2007/11/28 18:16:08 dlg Exp $ */
d96 1
@


1.29
log
@when we probe a port send an ata inquiry to the device and cache
the result in the ata_port struct. use this cached inquiry data
when building the replies to scsi commands rather than fetching a
new copy of ata inq every time.

this shrinks the code by 100 lines. it also avoids a malloc in a
scsi io path, which could be issued at a time when malloc isnt
guaranteed to succeed, but a real scsi io definitely should.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.28 2007/11/26 20:13:53 dlg Exp $ */
d36 1
d39 6
d131 6
@


1.28
log
@implement atascsi_probe_dev and atascsi_detach_dev. they let a hba tell
the midlayer(s) what to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.27 2007/11/26 15:59:53 dlg Exp $ */
d237 1
d255 1
a255 1
	u_int8_t		*data;
@


1.27
log
@drive port probes from the scsi midlayer now that it will ask the adapter
if a device is there before doing any scsi commands. also implement a free
path for when devices are detached. software hotplug has been tested on
sili, and ahci is still working according to claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.26 2007/11/23 18:21:55 dlg Exp $ */
d315 1
a315 1
int		atascsi_detach_dev(struct atascsi *, int);
@


1.26
log
@starting bits to implement hotplug of sili controllers. this adds the code
to clean up the atascsi stuff, and has sili call it when its going away.

tested on an expresscard sili variant by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.25 2007/04/12 13:08:34 jsg Exp $ */
d294 1
@


1.25
log
@Do a security freeze lock like we do in wd(4) to deal with systems
that leave the security set on by default.

"looks sane" grange@@, "looks ok" pascoe@@, "put it in" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.24 2007/04/10 07:57:21 jsg Exp $ */
d311 1
a311 1
int		atascsi_detach(struct atascsi *);
@


1.24
log
@Sort ATA commands by value.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.23 2007/04/05 11:13:05 dlg Exp $ */
d36 1
@


1.23
log
@device signatures appear to be common to sata controllers too.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.22 2007/04/04 12:39:16 dlg Exp $ */
a24 5
#define ATA_C_IDENTIFY		0xec
#define ATA_C_FLUSH_CACHE	0xe7
#define ATA_C_FLUSH_CACHE_EXT	0xea /* lba48 */
#define ATA_C_READDMA		0xc8
#define ATA_C_WRITEDMA		0xca
d26 1
a27 1
#define ATA_C_PACKET		0xa0
d30 6
a35 1
#define ATA_C_READ_LOG_EXT	0x2f
@


1.22
log
@some registers are shared amongst various sata controllers, so stick
definitions of them here. this starts with the SStatus register.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.21 2007/04/02 05:14:52 pascoe Exp $ */
d226 4
@


1.21
log
@Read log page 10h to determine the NCQ error, instead of aborting all
active commands when an error is encountered.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.20 2007/03/22 05:15:39 pascoe Exp $ */
d205 21
@


1.20
log
@Let atascsi issue NCQ commands if the controller supports it.

This includes a nasty hack to reduce openings and throw away command slots
if the device supports a lower queue depth than the host controller does.
Yes, we're thinking about a better solution.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.19 2007/03/21 12:41:28 pascoe Exp $ */
d35 1
d191 13
@


1.19
log
@Add support for issuing NCQ commands via AHCI.

Because you cannot have NCQ commands active at the same time as standard
(non-queued) commands, we must introduce a queueing scheme into the driver.

This scheme ensures that a standard command is only issued to the drive when
all currently active NCQ commands have finished, and that NCQ command issue
is delayed when we have a pending standard command.

Additionally, the queueing scheme adds a constraint to ensure that there are
never more than two standard commands issued on a port at once.  This should
ensure that commands become active in the order they were submitted (regardless
of their command slot number) both initially and when the port is reactivated
after error recovery.

These points mean that issuing a standard command effectively serialises the
port, which may help us implement meaningful I/O barriers in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.18 2007/03/21 00:09:16 dlg Exp $ */
d33 2
d203 3
d265 3
@


1.18
log
@replace the array of u_int8_ts for the fis/registers with a struct to make
it a bit easier to read. there are variations on this, but they can be
defined later.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.17 2007/03/20 14:10:53 dlg Exp $ */
d224 1
@


1.17
log
@add missing FLUSH_CACHE commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.16 2007/03/20 12:01:18 pascoe Exp $ */
d122 69
d203 3
a205 52
/* These offsets correspond with the layout of the SATA Host to Device
 * and Device to Host FISes.  Do not change them. */
enum ata_register_map {
	REGS_TYPE = 0,
	FIS_TYPE = 0,
#define REGS_TYPE_REG_H2D		0x27
#define REGS_TYPE_REG_D2H		0x34
#define REGS_TYPE_SDB_D2H		0xA1
	H2D_DEVCTL_OR_COMMAND = 1,
#define H2D_DEVCTL_OR_COMMAND_DEVCTL	0x00
#define H2D_DEVCTL_OR_COMMAND_COMMAND	0x80
#define H2D_DEVCTL_OR_COMMAND_PMULT_MSK	0x0f
	D2H_INTERRUPT = 1,
#define D2H_INTERRUPT_INTERRUPT		0x40
	H2D_COMMAND = 2,
	D2H_STATUS = 2,
	H2D_FEATURES = 3,
	D2H_ERROR = 3,
	SECTOR_NUM = 4,
	LBA_LOW = 4,
	CYL_LOW = 5,
	LBA_MID = 5,
	CYL_HIGH = 6,
	LBA_HIGH = 6,
	DEVICE_HEAD = 7,
	DEVICE = 7,
#define H2D_DEVICE_LBA			0x40
	SECTOR_NUM_EXP = 8,
	LBA_LOW_EXP = 8,
	CYL_LOW_EXP = 9,
	LBA_MID_EXP = 9,
	CYL_HIGH_EXP = 10,
	LBA_HIGH_EXP = 10,
	FEATURES_EXP = 11,
	SECTOR_COUNT = 12,
	SECTOR_COUNT_EXP = 13,
	RESERVED_14 = 14,
	CONTROL = 15,
	RESERVED_16 = 16,
	RESERVED_17 = 17,
	RESERVED_18 = 18,
	RESERVED_19 = 19,
	MAX_ATA_REGS = 20
};

struct ata_regs {
	u_int8_t		regs[MAX_ATA_REGS];
};

struct ata_cmd {
	struct ata_regs		*tx;
	struct ata_regs		rx_err;
a208 6
	u_int8_t		st_bmask;
	u_int8_t		st_pmask;
};

struct ata_xfer {
	struct ata_cmd		cmd;
@


1.16
log
@Add support for ATA PACKET commands.  This should make ATAPI cdrom drives,
etc, just work.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.15 2007/03/20 11:07:02 dlg Exp $ */
d26 2
@


1.15
log
@move ata command definitions from atascsi.c to atascsi.h
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.14 2007/03/20 10:02:31 dlg Exp $ */
d30 1
d184 2
d207 1
@


1.14
log
@reorder slightly. ata bits before atascsi
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.13 2007/03/20 08:47:46 pascoe Exp $ */
d20 97
@


1.13
log
@Add timeout handling for ATA commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.12 2007/03/20 07:45:11 dlg Exp $ */
a19 1
struct ata_xfer;
d21 3
a23 14
struct atascsi_methods {
	int			(*probe)(void *, int);
	struct ata_xfer *	(*ata_get_xfer)(void *, int );
	int			(*ata_cmd)(struct ata_xfer *);
};

struct atascsi_attach_args {
	void			*aaa_cookie;

	struct atascsi_methods	*aaa_methods;
	void			(*aaa_minphys)(struct buf *);
	int			aaa_nports;
	int			aaa_ncmds;
};
d124 19
@


1.12
log
@nothing from wdc, wd, or any of the existing ata stuff pls. this gets rid
of the wdcreg.h include in atascsi.

"feel free to remove" pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.11 2007/03/20 07:09:42 pascoe Exp $ */
d124 2
@


1.11
log
@Request "descriptor processed" interrupts only for PIO requests (inquiry,
etc), and request that the D2H FIS at the completion of all (DMA) commands
generate an interrupt.

This makes each data transfer generate one interrupt instead of two and
should guarantee that the interrupt that is generated actually arrives
after the command has completed.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.10 2007/03/20 05:33:02 pascoe Exp $ */
d72 1
@


1.10
log
@Instead of having a copy of every register that we will issue in the ata_cmd,
simply include a pointer to the command FIS that we will issue to the device.

Include another space where we can copy back an error register set from a
failed command.

This means that we can now build and issue arbitrary commands from atascsi,
and retrieve errors back.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.9 2007/03/20 04:38:11 pascoe Exp $ */
d117 1
@


1.9
log
@Change API for struct ata_xfer allocation to move it into the device that
atascsi will be driving, and add it to the AHCI CCB.

This effectively gives us all the resources we need for a transfer in one
hit, meaning that we don't need to worry about whether we will have a pool
shortage or not enough CCBs.  The SCSI mid layer should take care to never
exceed the number of CCBs we have available, based on our sc_link.openings.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.8 2007/03/13 11:22:36 dlg Exp $ */
d46 48
d95 3
a97 6
	u_int8_t		command;
	u_int8_t		head;
	u_int16_t		cyl;
	u_int8_t		sector;
	u_int8_t		count;
	u_int8_t		features;
a99 1
	u_int8_t		error;
@


1.8
log
@we need a resid too
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.7 2007/03/13 11:20:57 dlg Exp $ */
d24 2
a25 1
	int			(*ata_cmd)(void *, struct ata_xfer *);
a67 1
	struct ata_port		*port;
d78 1
d81 2
@


1.7
log
@add timeouts on ata_xfers
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.6 2007/02/28 13:25:42 dlg Exp $ */
d61 1
@


1.6
log
@stash a pointer to the atascsi instance in ata_port structs. the completion
routine will take a pointer to ata_xfer, not a void *. add some states and
flags for the xfers, and some values for the hba to return when processing
them.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.5 2007/02/19 13:18:08 jsg Exp $ */
d63 2
@


1.5
log
@precomp -> features as per ATA spec
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.4 2007/02/19 12:10:40 dlg Exp $ */
d37 1
d62 1
a62 1
	void			(*complete)(void *);
d66 9
a74 4
#define ATA_F_READ		(1<<0)
#define ATA_F_WRITE		(1<<1)
#define ATA_F_NOWAIT		(1<<2)
#define ATA_F_POLL		(1<<2)
d78 4
@


1.4
log
@i think ata_xfers should look more like this. stash the number of the port
in the ata_port struct so a hba can find its own info for that port.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d50 1
a50 1
	u_int8_t		precomp;
@


1.3
log
@implement the start of the framework for scsi emulation of ata disks
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.h,v 1.2 2007/02/19 11:48:34 dlg Exp $ */
d37 1
d44 12
d57 3
a59 1
	int			port;
d61 3
d65 4
a68 4
#define ATA_F_POLL		(1<<0)
#define ATA_F_NOSLEEP		(1<<1)

	u_int8_t		*cmd;
d70 1
a70 2
	u_int8_t		*data;
	size_t			datalen;
@


1.2
log
@as is short for atascsi, not ab
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d36 1
a36 1
struct atascsi_port {
d38 3
a40 3
#define ATABUS_PORT_T_NONE		0
#define ATABUS_PORT_T_DISK		1
#define ATABUS_PORT_T_ATAPI		2
@


1.1
log
@pull in atascsi, a scsi to ata translation layer, so i can work on it in
tree. ive lost two large changes today thanks to my own stupidity which
could have been avoided if they were in the tree.

discussed with deraadt@@

ok jsg@@ grange@@ an older version was ok marco@@
@
text
@@

