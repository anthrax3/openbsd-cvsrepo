head	1.128;
access;
symbols
	OPENBSD_6_1:1.128.0.6
	OPENBSD_6_1_BASE:1.128
	OPENBSD_6_0:1.128.0.2
	OPENBSD_6_0_BASE:1.128
	OPENBSD_5_9:1.127.0.2
	OPENBSD_5_9_BASE:1.127
	OPENBSD_5_8:1.124.0.4
	OPENBSD_5_8_BASE:1.124
	OPENBSD_5_7:1.122.0.4
	OPENBSD_5_7_BASE:1.122
	OPENBSD_5_6:1.119.0.4
	OPENBSD_5_6_BASE:1.119
	OPENBSD_5_5:1.118.0.4
	OPENBSD_5_5_BASE:1.118
	OPENBSD_5_4:1.116.0.10
	OPENBSD_5_4_BASE:1.116
	OPENBSD_5_3:1.116.0.8
	OPENBSD_5_3_BASE:1.116
	OPENBSD_5_2:1.116.0.6
	OPENBSD_5_2_BASE:1.116
	OPENBSD_5_1_BASE:1.116
	OPENBSD_5_1:1.116.0.4
	OPENBSD_5_0:1.116.0.2
	OPENBSD_5_0_BASE:1.116
	OPENBSD_4_9:1.101.0.2
	OPENBSD_4_9_BASE:1.101
	OPENBSD_4_8:1.90.0.2
	OPENBSD_4_8_BASE:1.90
	OPENBSD_4_7:1.71.0.2
	OPENBSD_4_7_BASE:1.71
	OPENBSD_4_6:1.64.0.6
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.64.0.2
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.62.0.2
	OPENBSD_4_4_BASE:1.62
	OPENBSD_4_3:1.60.0.2
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11;
locks; strict;
comment	@ * @;


1.128
date	2016.03.15.18.04.57;	author jca;	state Exp;
branches;
next	1.127;
commitid	KATUqQKuPOgJSA9e;

1.127
date	2016.01.03.21.07.46;	author kettenis;	state Exp;
branches;
next	1.126;
commitid	XDznfu03hsph9Q1W;

1.126
date	2015.12.29.09.44.46;	author kettenis;	state Exp;
branches;
next	1.125;
commitid	2kurxjxTY0o8fPnX;

1.125
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.124;
commitid	NdgfPIGUgJxQPnT7;

1.124
date	2015.05.15.10.54.26;	author dlg;	state Exp;
branches;
next	1.123;
commitid	lsYfop0A1uJxUQF8;

1.123
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.122;
commitid	p4LJxGKbi0BU2cG6;

1.122
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.121;
commitid	MyKPm9Q3dQu92BiX;

1.121
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.120;
commitid	zM5ckwX4kwwmipG0;

1.120
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.119;
commitid	uzzBR7hz9ncd4O6G;

1.119
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.118;
commitid	I19imNlAX05zJOED;

1.118
date	2013.12.09.11.44.52;	author dlg;	state Exp;
branches;
next	1.117;

1.117
date	2013.09.18.01.06.26;	author dlg;	state Exp;
branches;
next	1.116;

1.116
date	2011.08.03.00.27.20;	author dlg;	state Exp;
branches;
next	1.115;

1.115
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.114;

1.114
date	2011.07.09.06.24.41;	author dlg;	state Exp;
branches;
next	1.113;

1.113
date	2011.07.09.01.50.41;	author matthew;	state Exp;
branches;
next	1.112;

1.112
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.111;

1.111
date	2011.07.08.08.16.50;	author dlg;	state Exp;
branches;
next	1.110;

1.110
date	2011.07.08.07.45.36;	author dlg;	state Exp;
branches;
next	1.109;

1.109
date	2011.07.08.07.15.31;	author dlg;	state Exp;
branches;
next	1.108;

1.108
date	2011.07.05.03.47.55;	author dlg;	state Exp;
branches;
next	1.107;

1.107
date	2011.06.21.06.03.14;	author matthew;	state Exp;
branches;
next	1.106;

1.106
date	2011.06.02.00.07.30;	author matthew;	state Exp;
branches;
next	1.105;

1.105
date	2011.05.08.19.46.10;	author matthew;	state Exp;
branches;
next	1.104;

1.104
date	2011.05.05.19.23.05;	author matthew;	state Exp;
branches;
next	1.103;

1.103
date	2011.04.27.23.51.09;	author matthew;	state Exp;
branches;
next	1.102;

1.102
date	2011.04.02.15.23.36;	author krw;	state Exp;
branches;
next	1.101;

1.101
date	2011.02.03.21.22.19;	author matthew;	state Exp;
branches;
next	1.100;

1.100
date	2011.01.26.21.41.00;	author drahn;	state Exp;
branches;
next	1.99;

1.99
date	2011.01.12.21.00.04;	author kettenis;	state Exp;
branches;
next	1.98;

1.98
date	2010.11.20.05.12.39;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2010.09.23.11.44.22;	author dlg;	state Exp;
branches;
next	1.95;

1.95
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2010.09.20.06.02.50;	author dlg;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.19.23.13.02;	author dlg;	state Exp;
branches;
next	1.92;

1.92
date	2010.09.19.12.08.27;	author dlg;	state Exp;
branches;
next	1.91;

1.91
date	2010.09.02.11.54.44;	author dlg;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.27.04.41.56;	author matthew;	state Exp;
branches;
next	1.89;

1.89
date	2010.07.20.01.06.54;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.03.00.41.58;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.19.21.43.16;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2010.05.26.12.17.35;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2010.05.05.11.33.26;	author dlg;	state Exp;
branches;
next	1.83;

1.83
date	2010.04.29.22.28.39;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2010.04.23.01.39.05;	author dlg;	state Exp;
branches;
next	1.81;

1.81
date	2010.04.22.00.58.32;	author dlg;	state Exp;
branches;
next	1.80;

1.80
date	2010.04.19.10.52.15;	author dlg;	state Exp;
branches;
next	1.79;

1.79
date	2010.04.05.04.11.06;	author dlg;	state Exp;
branches;
next	1.78;

1.78
date	2010.04.05.01.47.54;	author dlg;	state Exp;
branches;
next	1.77;

1.77
date	2010.04.05.00.59.31;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2010.04.05.00.55.03;	author dlg;	state Exp;
branches;
next	1.75;

1.75
date	2010.04.03.09.35.48;	author dlg;	state Exp;
branches;
next	1.74;

1.74
date	2010.04.03.09.32.14;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2010.04.03.07.09.29;	author dlg;	state Exp;
branches;
next	1.72;

1.72
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2009.12.08.10.18.11;	author dlg;	state Exp;
branches;
next	1.69;

1.69
date	2009.12.08.08.07.51;	author dlg;	state Exp;
branches;
next	1.68;

1.68
date	2009.12.07.12.36.23;	author dlg;	state Exp;
branches;
next	1.67;

1.67
date	2009.12.07.09.37.34;	author dlg;	state Exp;
branches;
next	1.66;

1.66
date	2009.10.22.07.59.26;	author dlg;	state Exp;
branches;
next	1.65;

1.65
date	2009.09.13.19.21.42;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2008.09.25.11.00.48;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2008.05.05.12.19.38;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2008.03.26.14.00.28;	author dlg;	state Exp;
branches;
next	1.60;

1.60
date	2007.12.30.13.02.53;	author dlg;	state Exp;
branches;
next	1.59;

1.59
date	2007.12.29.00.45.26;	author dlg;	state Exp;
branches;
next	1.58;

1.58
date	2007.12.28.16.38.23;	author dlg;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.28.16.30.08;	author dlg;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.28.16.21.06;	author dlg;	state Exp;
branches;
next	1.55;

1.55
date	2007.12.28.16.19.14;	author dlg;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.09.01.30.59;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2007.12.09.01.05.09;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.06.12.19.01;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.28.18.16.07;	author dlg;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.28.13.47.09;	author dlg;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.26.20.13.53;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.26.15.59.53;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.23.18.21.55;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.23.16.01.47;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.23.15.14.11;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.23.12.56.31;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.16.02.17.27;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.01.15.34.48;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.22.05.11.45;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.12.13.08.34;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.10.23.37.06;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.24.22.03.18;	author pascoe;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.23.05.28.34;	author pascoe;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.23.05.27.16;	author pascoe;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.23.05.25.02;	author pascoe;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.23.05.18.47;	author pascoe;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.22.05.15.39;	author pascoe;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.21.23.40.30;	author pascoe;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.21.03.42.07;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.21.00.09.16;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.20.15.03.22;	author pascoe;	state Exp;
branches;
next	1.28;

1.28
date	2007.03.20.13.42.05;	author pascoe;	state Exp;
branches;
next	1.27;

1.27
date	2007.03.20.13.01.04;	author pascoe;	state Exp;
branches;
next	1.26;

1.26
date	2007.03.20.12.44.04;	author pascoe;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.20.12.31.49;	author pascoe;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.20.12.24.02;	author pascoe;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.20.12.01.18;	author pascoe;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.20.11.07.02;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.20.07.45.11;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.20.07.09.42;	author pascoe;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.20.06.43.06;	author pascoe;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.20.06.41.38;	author pascoe;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.20.05.33.02;	author pascoe;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.20.04.38.11;	author pascoe;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.13.11.20.57;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.12.00.35.15;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.12.00.33.09;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.12.00.31.17;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.07.03.04.28;	author pascoe;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.06.12.25.00;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.28.13.38.04;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.28.13.23.23;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.19.12.06.16;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.19.12.04.01;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.19.11.57.45;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.19.11.55.04;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.19.11.53.34;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.19.11.48.34;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.19.11.44.24;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.128
log
@Fix size passed to free(), found the hard way by Nick Permyakov

ok deraadt@@
@
text
@/*	$OpenBSD: atascsi.c,v 1.127 2016/01/03 21:07:46 kettenis Exp $ */

/*
 * Copyright (c) 2007 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2010 Conformal Systems LLC <info@@conformal.com>
 * Copyright (c) 2010 Jonathan Matthew <jonathan@@d14n.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/pool.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/ata/atascsi.h>
#include <dev/ata/pmreg.h>

struct atascsi_port;

struct atascsi {
	struct device		*as_dev;
	void			*as_cookie;

	struct atascsi_host_port **as_host_ports;

	struct atascsi_methods	*as_methods;
	struct scsi_adapter	as_switch;
	struct scsi_link	as_link;
	struct scsibus_softc	*as_scsibus;

	int			as_capability;
	int			as_ncqdepth;
};

/*
 * atascsi_host_port is a port attached to the host controller, and
 * only holds the details relevant to the host controller.
 * atascsi_port is any port, including ports on port multipliers, and
 * it holds details of the device attached to the port.
 *
 * When there is a port multiplier attached to a port, the ahp_ports
 * array in the atascsi_host_port struct contains one atascsi_port for
 * each port, and one for the control port (port 15).  The index into
 * the array is the LUN used to address the port.  For the control port,
 * the LUN is 0, and for the port multiplier ports, the LUN is the
 * port number plus one.
 *
 * When there is no port multiplier attached to a port, the ahp_ports
 * array contains a single entry for the device.  The LUN and port number
 * for this entry are both 0.
 */

struct atascsi_host_port {
	struct scsi_iopool	ahp_iopool;
	struct atascsi		*ahp_as;
	int			ahp_port;
	int			ahp_nports;

	struct atascsi_port	**ahp_ports;
};

struct atascsi_port {
	struct ata_identify	ap_identify;
	struct atascsi_host_port *ap_host_port;
	struct atascsi		*ap_as;
	int			ap_pmp_port;
	int			ap_type;
	int			ap_ncqdepth;
	int			ap_features;
#define ATA_PORT_F_NCQ			0x1
#define ATA_PORT_F_TRIM			0x2
};

void		atascsi_cmd(struct scsi_xfer *);
int		atascsi_probe(struct scsi_link *);
void		atascsi_free(struct scsi_link *);

/* template */
struct scsi_adapter atascsi_switch = {
	atascsi_cmd,		/* scsi_cmd */
	scsi_minphys,		/* scsi_minphys */
	atascsi_probe,		/* dev_probe */
	atascsi_free,		/* dev_free */
	NULL,			/* ioctl */
};

void		ata_swapcopy(void *, void *, size_t);

void		atascsi_disk_cmd(struct scsi_xfer *);
void		atascsi_disk_cmd_done(struct ata_xfer *);
void		atascsi_disk_inq(struct scsi_xfer *);
void		atascsi_disk_inquiry(struct scsi_xfer *);
void		atascsi_disk_vpd_supported(struct scsi_xfer *);
void		atascsi_disk_vpd_serial(struct scsi_xfer *);
void		atascsi_disk_vpd_ident(struct scsi_xfer *);
void		atascsi_disk_vpd_ata(struct scsi_xfer *);
void		atascsi_disk_vpd_limits(struct scsi_xfer *);
void		atascsi_disk_vpd_info(struct scsi_xfer *);
void		atascsi_disk_vpd_thin(struct scsi_xfer *);
void		atascsi_disk_write_same_16(struct scsi_xfer *);
void		atascsi_disk_write_same_16_done(struct ata_xfer *);
void		atascsi_disk_unmap(struct scsi_xfer *);
void		atascsi_disk_unmap_task(void *);
void		atascsi_disk_unmap_done(struct ata_xfer *);
void		atascsi_disk_capacity(struct scsi_xfer *);
void		atascsi_disk_capacity16(struct scsi_xfer *);
void		atascsi_disk_sync(struct scsi_xfer *);
void		atascsi_disk_sync_done(struct ata_xfer *);
void		atascsi_disk_sense(struct scsi_xfer *);
void		atascsi_disk_start_stop(struct scsi_xfer *);
void		atascsi_disk_start_stop_done(struct ata_xfer *);

void		atascsi_atapi_cmd(struct scsi_xfer *);
void		atascsi_atapi_cmd_done(struct ata_xfer *);

void		atascsi_pmp_cmd(struct scsi_xfer *);
void		atascsi_pmp_cmd_done(struct ata_xfer *);
void		atascsi_pmp_sense(struct scsi_xfer *xs);
void		atascsi_pmp_inq(struct scsi_xfer *xs);


void		atascsi_passthru_12(struct scsi_xfer *);
void		atascsi_passthru_16(struct scsi_xfer *);
int		atascsi_passthru_map(struct scsi_xfer *, u_int8_t, u_int8_t);
void		atascsi_passthru_done(struct ata_xfer *);

void		atascsi_done(struct scsi_xfer *, int);

void		ata_exec(struct atascsi *, struct ata_xfer *);

void		ata_polled_complete(struct ata_xfer *);
int		ata_polled(struct ata_xfer *);

u_int64_t	ata_identify_blocks(struct ata_identify *);
u_int		ata_identify_blocksize(struct ata_identify *);
u_int		ata_identify_block_l2p_exp(struct ata_identify *);
u_int		ata_identify_block_logical_align(struct ata_identify *);

void		*atascsi_io_get(void *);
void		atascsi_io_put(void *, void *);
struct atascsi_port * atascsi_lookup_port(struct scsi_link *);

int		atascsi_port_identify(struct atascsi_port *,
		    struct ata_identify *);
int		atascsi_port_set_features(struct atascsi_port *, int, int);


struct atascsi *
atascsi_attach(struct device *self, struct atascsi_attach_args *aaa)
{
	struct scsibus_attach_args	saa;
	struct atascsi			*as;

	as = malloc(sizeof(*as), M_DEVBUF, M_WAITOK | M_ZERO);

	as->as_dev = self;
	as->as_cookie = aaa->aaa_cookie;
	as->as_methods = aaa->aaa_methods;
	as->as_capability = aaa->aaa_capability;
	as->as_ncqdepth = aaa->aaa_ncmds;

	/* copy from template and modify for ourselves */
	as->as_switch = atascsi_switch;
	if (aaa->aaa_minphys != NULL)
		as->as_switch.scsi_minphys = aaa->aaa_minphys;

	/* fill in our scsi_link */
	as->as_link.adapter = &as->as_switch;
	as->as_link.adapter_softc = as;
	as->as_link.adapter_buswidth = aaa->aaa_nports;
	as->as_link.luns = SATA_PMP_MAX_PORTS;
	as->as_link.adapter_target = aaa->aaa_nports;
	as->as_link.openings = 1;

	as->as_host_ports = mallocarray(aaa->aaa_nports,
	    sizeof(struct atascsi_host_port *),	M_DEVBUF, M_WAITOK | M_ZERO);

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &as->as_link;

	/* stash the scsibus so we can do hotplug on it */
	as->as_scsibus = (struct scsibus_softc *)config_found(self, &saa,
	    scsiprint);

	return (as);
}

int
atascsi_detach(struct atascsi *as, int flags)
{
	int				rv;

	rv = config_detach((struct device *)as->as_scsibus, flags);
	if (rv != 0)
		return (rv);

	free(as->as_host_ports, M_DEVBUF, 0);
	free(as, M_DEVBUF, sizeof(*as));

	return (0);
}

int
atascsi_probe_dev(struct atascsi *as, int port, int lun)
{
	if (lun == 0) {
		return (scsi_probe_target(as->as_scsibus, port));
	} else {
		return (scsi_probe_lun(as->as_scsibus, port, lun));
	}
}

int
atascsi_detach_dev(struct atascsi *as, int port, int lun, int flags)
{
	if (lun == 0) {
		return (scsi_detach_target(as->as_scsibus, port, flags));
	} else {
		return (scsi_detach_lun(as->as_scsibus, port, lun, flags));
	}
}

struct atascsi_port *
atascsi_lookup_port(struct scsi_link *link)
{
	struct atascsi 			*as = link->adapter_softc;
	struct atascsi_host_port 	*ahp;

	if (link->target >= as->as_link.adapter_buswidth)
		return (NULL);

	ahp = as->as_host_ports[link->target];
	if (link->lun >= ahp->ahp_nports)
		return (NULL);

	return (ahp->ahp_ports[link->lun]);
}

int
atascsi_probe(struct scsi_link *link)
{
	struct atascsi			*as = link->adapter_softc;
	struct atascsi_host_port 	*ahp;
	struct atascsi_port		*ap;
	struct ata_xfer			*xa;
	struct ata_identify		*identify;
	int				port, type, qdepth;
	int				rv;
	u_int16_t			cmdset;
	u_int16_t			validinfo, ultradma;
	int				i, xfermode = -1;

	port = link->target;
	if (port >= as->as_link.adapter_buswidth)
		return (ENXIO);

	/* if this is a PMP port, check it's valid */
	if (link->lun > 0) {
		if (link->lun >= as->as_host_ports[port]->ahp_nports)
			return (ENXIO);
	}

	type = as->as_methods->ata_probe(as->as_cookie, port, link->lun);
	switch (type) {
	case ATA_PORT_T_DISK:
		break;
	case ATA_PORT_T_ATAPI:
		link->flags |= SDEV_ATAPI;
		link->quirks |= SDEV_ONLYBIG;
		break;
	case ATA_PORT_T_PM:
		if (link->lun != 0) {
			printf("%s.%d.%d: Port multipliers cannot be nested\n",
			    as->as_dev->dv_xname, port, link->lun);
			rv = ENODEV;
			goto unsupported;
		}
		break;
	default:
		rv = ENODEV;
		goto unsupported;
	}

	ap = malloc(sizeof(*ap), M_DEVBUF, M_WAITOK | M_ZERO);
	ap->ap_as = as;

	if (link->lun == 0) {
		ahp = malloc(sizeof(*ahp), M_DEVBUF, M_WAITOK | M_ZERO);
		ahp->ahp_as = as;
		ahp->ahp_port = port;

		scsi_iopool_init(&ahp->ahp_iopool, ahp, atascsi_io_get,
		    atascsi_io_put);

		as->as_host_ports[port] = ahp;

		if (type == ATA_PORT_T_PM) {
			ahp->ahp_nports = SATA_PMP_MAX_PORTS;
			ap->ap_pmp_port = SATA_PMP_CONTROL_PORT;
		} else {
			ahp->ahp_nports = 1;
			ap->ap_pmp_port = 0;
		}
		ahp->ahp_ports = mallocarray(ahp->ahp_nports,
		    sizeof(struct atascsi_port *), M_DEVBUF, M_WAITOK | M_ZERO);
	} else {
		ahp = as->as_host_ports[port];
		ap->ap_pmp_port = link->lun - 1;
	}

	ap->ap_host_port = ahp;
	ap->ap_type = type;

	link->pool = &ahp->ahp_iopool;

	/* fetch the device info, except for port multipliers */
	if (type != ATA_PORT_T_PM) {

		/* devices attached to port multipliers tend not to be
		 * spun up at this point, and sometimes this prevents
		 * identification from working, so we retry a few times
		 * with a fairly long delay.
		 */

		identify = dma_alloc(sizeof(*identify), PR_WAITOK | PR_ZERO);

		int count = (link->lun > 0) ? 6 : 2;
		while (count--) {
			rv = atascsi_port_identify(ap, identify);
			if (rv == 0) {
				ap->ap_identify = *identify;
				break;
			}
			if (count > 0)
				delay(5000000);
		}

		dma_free(identify, sizeof(*identify));

		if (rv != 0) {
			goto error;
		}
	}

	ahp->ahp_ports[link->lun] = ap;

	if (type != ATA_PORT_T_DISK)
		return (0);

	/*
	 * Early SATA drives (as well as PATA drives) need to have
	 * their transfer mode set properly, otherwise commands that
	 * use DMA will time out.
	 */
	validinfo = letoh16(ap->ap_identify.validinfo);
	if (ISSET(validinfo, ATA_ID_VALIDINFO_ULTRADMA)) {
		ultradma = letoh16(ap->ap_identify.ultradma);
		for (i = 7; i >= 0; i--) {
			if (ultradma & (1 << i)) {
				xfermode = ATA_SF_XFERMODE_UDMA | i;
				break;
			}
		}
	}
	if (xfermode != -1)
		(void)atascsi_port_set_features(ap, ATA_SF_XFERMODE, xfermode);

	if (as->as_capability & ASAA_CAP_NCQ &&
	    ISSET(letoh16(ap->ap_identify.satacap), ATA_SATACAP_NCQ) &&
	    (link->lun == 0 || as->as_capability & ASAA_CAP_PMP_NCQ)) {
		ap->ap_ncqdepth = ATA_QDEPTH(letoh16(ap->ap_identify.qdepth));
		qdepth = MIN(ap->ap_ncqdepth, as->as_ncqdepth);
		if (ISSET(as->as_capability, ASAA_CAP_NEEDS_RESERVED))
			qdepth--;

		if (qdepth > 1) {
			SET(ap->ap_features, ATA_PORT_F_NCQ);

			/* Raise the number of openings */
			link->openings = qdepth;

			/*
			 * XXX for directly attached devices, throw away any xfers
			 * that have tag numbers higher than what the device supports.
			 */
			if (link->lun == 0) {
				while (qdepth--) {
					xa = scsi_io_get(&ahp->ahp_iopool, SCSI_NOSLEEP);
					if (xa->tag < link->openings) {
						xa->state = ATA_S_COMPLETE;
						scsi_io_put(&ahp->ahp_iopool, xa);
					}
				}
			}
		}
	}

	if (ISSET(letoh16(ap->ap_identify.data_set_mgmt), 
	    ATA_ID_DATA_SET_MGMT_TRIM))
		SET(ap->ap_features, ATA_PORT_F_TRIM);

	cmdset = letoh16(ap->ap_identify.cmdset82);

	/* Enable write cache if supported */
	if (ISSET(cmdset, ATA_IDENTIFY_WRITECACHE)) {
		/* We don't care if it fails. */
		(void)atascsi_port_set_features(ap, ATA_SF_WRITECACHE_EN, 0);
	}

	/* Enable read lookahead if supported */
	if (ISSET(cmdset, ATA_IDENTIFY_LOOKAHEAD)) {
		/* We don't care if it fails. */
		(void)atascsi_port_set_features(ap, ATA_SF_LOOKAHEAD_EN, 0);
	}

	/*
	 * FREEZE LOCK the device so malicous users can't lock it on us.
	 * As there is no harm in issuing this to devices that don't
	 * support the security feature set we just send it, and don't bother
	 * checking if the device sends a command abort to tell us it doesn't
	 * support it
	 */
	xa = scsi_io_get(&ahp->ahp_iopool, SCSI_NOSLEEP);
	if (xa == NULL)
		panic("no free xfers on a new port");
	xa->fis->command = ATA_C_SEC_FREEZE_LOCK;
	xa->fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	xa->flags = ATA_F_POLL;
	xa->timeout = 1000;
	xa->complete = ata_polled_complete;
	xa->pmp_port = ap->ap_pmp_port;
	xa->atascsi_private = &ahp->ahp_iopool;
	ata_exec(as, xa);
	ata_polled(xa); /* we dont care if it doesnt work */

	return (0);
error:
	free(ap, M_DEVBUF, sizeof(*ap));
unsupported:

	as->as_methods->ata_free(as->as_cookie, port, link->lun);
	return (rv);
}

void
atascsi_free(struct scsi_link *link)
{
	struct atascsi			*as = link->adapter_softc;
	struct atascsi_host_port	*ahp;
	struct atascsi_port		*ap;
	int				port;

	port = link->target;
	if (port >= as->as_link.adapter_buswidth)
		return;

	ahp = as->as_host_ports[port];
	if (ahp == NULL)
		return;

	if (link->lun >= ahp->ahp_nports)
		return;

	ap = ahp->ahp_ports[link->lun];
	free(ap, M_DEVBUF, sizeof(*ap));
	ahp->ahp_ports[link->lun] = NULL;

	as->as_methods->ata_free(as->as_cookie, port, link->lun);

	if (link->lun == ahp->ahp_nports - 1) {
		/* we've already freed all of ahp->ahp_ports, now
		 * free ahp itself.  this relies on the order luns are
		 * detached in scsi_detach_target().
		 */
		free(ahp, M_DEVBUF, sizeof(*ahp));
		as->as_host_ports[port] = NULL;
	}
}

void
atascsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct atascsi_port	*ap;

	ap = atascsi_lookup_port(link);
	if (ap == NULL) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	switch (ap->ap_type) {
	case ATA_PORT_T_DISK:
		atascsi_disk_cmd(xs);
		break;
	case ATA_PORT_T_ATAPI:
		atascsi_atapi_cmd(xs);
		break;
	case ATA_PORT_T_PM:
		atascsi_pmp_cmd(xs);
		break;

	case ATA_PORT_T_NONE:
	default:
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		break;
	}
}

void
atascsi_disk_cmd(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;
	struct ata_xfer		*xa = xs->io;
	int			flags = 0;
	struct ata_fis_h2d	*fis;
	u_int64_t		lba;
	u_int32_t		sector_count;

	ap = atascsi_lookup_port(link);

	switch (xs->cmd->opcode) {
	case READ_COMMAND:
	case READ_BIG:
	case READ_12:
	case READ_16:
		flags = ATA_F_READ;
		break;
	case WRITE_COMMAND:
	case WRITE_BIG:
	case WRITE_12:
	case WRITE_16:
		flags = ATA_F_WRITE;
		/* deal with io outside the switch */
		break;

	case WRITE_SAME_16:
		atascsi_disk_write_same_16(xs);
		return;
	case UNMAP:
		atascsi_disk_unmap(xs);
		return;

	case SYNCHRONIZE_CACHE:
		atascsi_disk_sync(xs);
		return;
	case REQUEST_SENSE:
		atascsi_disk_sense(xs);
		return;
	case INQUIRY:
		atascsi_disk_inq(xs);
		return;
	case READ_CAPACITY:
		atascsi_disk_capacity(xs);
		return;
	case READ_CAPACITY_16:
		atascsi_disk_capacity16(xs);
		return;

	case ATA_PASSTHRU_12:
		atascsi_passthru_12(xs);
		return;
	case ATA_PASSTHRU_16:
		atascsi_passthru_16(xs);
		return;

	case START_STOP:
		atascsi_disk_start_stop(xs);
		return;

	case TEST_UNIT_READY:
	case PREVENT_ALLOW:
		atascsi_done(xs, XS_NOERROR);
		return;

	default:
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	xa->flags = flags;
	scsi_cmd_rw_decode(xs->cmd, &lba, &sector_count);
	if ((lba >> 48) != 0 || (sector_count >> 16) != 0) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	fis = xa->fis;

	fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	fis->lba_low = lba & 0xff;
	fis->lba_mid = (lba >> 8) & 0xff;
	fis->lba_high = (lba >> 16) & 0xff;

	if (ISSET(ap->ap_features, ATA_PORT_F_NCQ) &&
	    (xa->tag < ap->ap_ncqdepth) &&
	    !(xs->flags & SCSI_POLL)) {
		/* Use NCQ */
		xa->flags |= ATA_F_NCQ;
		fis->command = (xa->flags & ATA_F_WRITE) ?
		    ATA_C_WRITE_FPDMA : ATA_C_READ_FPDMA;
		fis->device = ATA_H2D_DEVICE_LBA;
		fis->lba_low_exp = (lba >> 24) & 0xff;
		fis->lba_mid_exp = (lba >> 32) & 0xff;
		fis->lba_high_exp = (lba >> 40) & 0xff;
		fis->sector_count = xa->tag << 3;
		fis->features = sector_count & 0xff;
		fis->features_exp = (sector_count >> 8) & 0xff;
	} else if (sector_count > 0x100 || lba > 0xfffffff) {
		/* Use LBA48 */
		fis->command = (xa->flags & ATA_F_WRITE) ?
		    ATA_C_WRITEDMA_EXT : ATA_C_READDMA_EXT;
		fis->device = ATA_H2D_DEVICE_LBA;
		fis->lba_low_exp = (lba >> 24) & 0xff;
		fis->lba_mid_exp = (lba >> 32) & 0xff;
		fis->lba_high_exp = (lba >> 40) & 0xff;
		fis->sector_count = sector_count & 0xff;
		fis->sector_count_exp = (sector_count >> 8) & 0xff;
	} else {
		/* Use LBA */
		fis->command = (xa->flags & ATA_F_WRITE) ?
		    ATA_C_WRITEDMA : ATA_C_READDMA;
		fis->device = ATA_H2D_DEVICE_LBA | ((lba >> 24) & 0x0f);
		fis->sector_count = sector_count & 0xff;
	}

	xa->data = xs->data;
	xa->datalen = xs->datalen;
	xa->complete = atascsi_disk_cmd_done;
	xa->timeout = xs->timeout;
	xa->pmp_port = ap->ap_pmp_port;
	xa->atascsi_private = xs;
	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;

	ata_exec(as, xa);
}

void
atascsi_disk_cmd_done(struct ata_xfer *xa)
{
	struct scsi_xfer	*xs = xa->atascsi_private;

	switch (xa->state) {
	case ATA_S_COMPLETE:
		xs->error = XS_NOERROR;
		break;
	case ATA_S_ERROR:
		/* fake sense? */
		xs->error = XS_DRIVER_STUFFUP;
		break;
	case ATA_S_TIMEOUT:
		xs->error = XS_TIMEOUT;
		break;
	default:
		panic("atascsi_disk_cmd_done: unexpected ata_xfer state (%d)",
		    xa->state);
	}

	xs->resid = xa->resid;

	scsi_done(xs);
}

void
atascsi_disk_inq(struct scsi_xfer *xs)
{
	struct scsi_inquiry	*inq = (struct scsi_inquiry *)xs->cmd;

	if (xs->cmdlen != sizeof(*inq)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	if (ISSET(inq->flags, SI_EVPD)) {
		switch (inq->pagecode) {
		case SI_PG_SUPPORTED:
			atascsi_disk_vpd_supported(xs);
			break;
		case SI_PG_SERIAL:
			atascsi_disk_vpd_serial(xs);
			break;
		case SI_PG_DEVID:
			atascsi_disk_vpd_ident(xs);
			break;
		case SI_PG_ATA:
			atascsi_disk_vpd_ata(xs);
			break;
		case SI_PG_DISK_LIMITS:
			atascsi_disk_vpd_limits(xs);
			break;
		case SI_PG_DISK_INFO:
			atascsi_disk_vpd_info(xs);
			break;
		case SI_PG_DISK_THIN:
			atascsi_disk_vpd_thin(xs);
			break;
		default:
			atascsi_done(xs, XS_DRIVER_STUFFUP);
			break;
		}
	} else
		atascsi_disk_inquiry(xs);
}

void
atascsi_disk_inquiry(struct scsi_xfer *xs)
{
	struct scsi_inquiry_data inq;
	struct scsi_link        *link = xs->sc_link;
	struct atascsi_port	*ap;

	ap = atascsi_lookup_port(link);

	bzero(&inq, sizeof(inq));

	inq.device = T_DIRECT;
	inq.version = 0x05; /* SPC-3 */
	inq.response_format = 2;
	inq.additional_length = 32;
	inq.flags |= SID_CmdQue;
	bcopy("ATA     ", inq.vendor, sizeof(inq.vendor));
	ata_swapcopy(ap->ap_identify.model, inq.product,
	    sizeof(inq.product));
	ata_swapcopy(ap->ap_identify.firmware, inq.revision,
	    sizeof(inq.revision));

	bcopy(&inq, xs->data, MIN(sizeof(inq), xs->datalen));

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_disk_vpd_supported(struct scsi_xfer *xs)
{
	struct {
		struct scsi_vpd_hdr	hdr;
		u_int8_t		list[7];
	}			pg;
	struct scsi_link        *link = xs->sc_link;
	struct atascsi_port	*ap;
	int			fat;

	ap = atascsi_lookup_port(link);
	fat = ISSET(ap->ap_features, ATA_PORT_F_TRIM) ? 0 : 1;

	bzero(&pg, sizeof(pg));

	pg.hdr.device = T_DIRECT;
	pg.hdr.page_code = SI_PG_SUPPORTED;
	_lto2b(sizeof(pg.list) - fat, pg.hdr.page_length);
	pg.list[0] = SI_PG_SUPPORTED;
	pg.list[1] = SI_PG_SERIAL;
	pg.list[2] = SI_PG_DEVID;
	pg.list[3] = SI_PG_ATA;
	pg.list[4] = SI_PG_DISK_LIMITS;
	pg.list[5] = SI_PG_DISK_INFO;
	pg.list[6] = SI_PG_DISK_THIN; /* "trimmed" if fat. get it? tehe. */

	bcopy(&pg, xs->data, MIN(sizeof(pg) - fat, xs->datalen));

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_disk_vpd_serial(struct scsi_xfer *xs)
{
	struct scsi_link        *link = xs->sc_link;
	struct atascsi_port	*ap;
	struct scsi_vpd_serial	pg;

	ap = atascsi_lookup_port(link);
	bzero(&pg, sizeof(pg));

	pg.hdr.device = T_DIRECT;
	pg.hdr.page_code = SI_PG_SERIAL;
	_lto2b(sizeof(ap->ap_identify.serial), pg.hdr.page_length);
	ata_swapcopy(ap->ap_identify.serial, pg.serial,
	    sizeof(ap->ap_identify.serial));

	bcopy(&pg, xs->data, MIN(sizeof(pg), xs->datalen));

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_disk_vpd_ident(struct scsi_xfer *xs)
{
	struct scsi_link        *link = xs->sc_link;
	struct atascsi_port	*ap;
	struct {
		struct scsi_vpd_hdr	hdr;
		struct scsi_vpd_devid_hdr devid_hdr;
		u_int8_t		devid[68];
	}			pg;
	u_int8_t		*p;
	size_t			pg_len;

	ap = atascsi_lookup_port(link);
	bzero(&pg, sizeof(pg));
	if (letoh16(ap->ap_identify.features87) & ATA_ID_F87_WWN) {
		pg_len = 8;

		pg.devid_hdr.pi_code = VPD_DEVID_CODE_BINARY;
		pg.devid_hdr.flags = VPD_DEVID_ASSOC_LU | VPD_DEVID_TYPE_NAA;

		ata_swapcopy(&ap->ap_identify.naa_ieee_oui, pg.devid, pg_len);
	} else {
		pg_len = 68;

		pg.devid_hdr.pi_code = VPD_DEVID_CODE_ASCII;
		pg.devid_hdr.flags = VPD_DEVID_ASSOC_LU | VPD_DEVID_TYPE_T10;

		p = pg.devid;
		bcopy("ATA     ", p, 8);
		p += 8;
		ata_swapcopy(ap->ap_identify.model, p,
		    sizeof(ap->ap_identify.model));
		p += sizeof(ap->ap_identify.model);
		ata_swapcopy(ap->ap_identify.serial, p,
		    sizeof(ap->ap_identify.serial));
	}

	pg.devid_hdr.len = pg_len;
	pg_len += sizeof(pg.devid_hdr);

	pg.hdr.device = T_DIRECT;
	pg.hdr.page_code = SI_PG_DEVID;
	_lto2b(pg_len, pg.hdr.page_length);
	pg_len += sizeof(pg.hdr);

	bcopy(&pg, xs->data, MIN(pg_len, xs->datalen));

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_disk_vpd_ata(struct scsi_xfer *xs)
{
	struct scsi_link        *link = xs->sc_link;
	struct atascsi_port	*ap;
	struct scsi_vpd_ata	pg;

	ap = atascsi_lookup_port(link);
	bzero(&pg, sizeof(pg));

	pg.hdr.device = T_DIRECT;
	pg.hdr.page_code = SI_PG_ATA;
	_lto2b(sizeof(pg) - sizeof(pg.hdr), pg.hdr.page_length);

	memset(pg.sat_vendor, ' ', sizeof(pg.sat_vendor));
	memcpy(pg.sat_vendor, "OpenBSD",
	    MIN(strlen("OpenBSD"), sizeof(pg.sat_vendor)));
	memset(pg.sat_product, ' ', sizeof(pg.sat_product));
	memcpy(pg.sat_product, "atascsi",
	    MIN(strlen("atascsi"), sizeof(pg.sat_product)));
	memset(pg.sat_revision, ' ', sizeof(pg.sat_revision));
	memcpy(pg.sat_revision, osrelease,
	    MIN(strlen(osrelease), sizeof(pg.sat_product)));

	/* XXX device signature */

	switch (ap->ap_type) {
	case ATA_PORT_T_DISK:
		pg.command_code = VPD_ATA_COMMAND_CODE_ATA;
		break;
	case ATA_PORT_T_ATAPI:
		pg.command_code = VPD_ATA_COMMAND_CODE_ATAPI;
		break;
	}

	memcpy(pg.identify, &ap->ap_identify, sizeof(pg.identify));

	bcopy(&pg, xs->data, MIN(sizeof(pg), xs->datalen));

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_disk_vpd_limits(struct scsi_xfer *xs)
{
	struct scsi_link        *link = xs->sc_link;
	struct atascsi_port	*ap;
	struct scsi_vpd_disk_limits pg;

	ap = atascsi_lookup_port(link);
	bzero(&pg, sizeof(pg));
	pg.hdr.device = T_DIRECT;
	pg.hdr.page_code = SI_PG_DISK_LIMITS;
	_lto2b(SI_PG_DISK_LIMITS_LEN_THIN, pg.hdr.page_length);

	_lto2b(1 << ata_identify_block_l2p_exp(&ap->ap_identify),
	    pg.optimal_xfer_granularity);

	if (ISSET(ap->ap_features, ATA_PORT_F_TRIM)) {
		/*
		 * ATA only supports 65535 blocks per TRIM descriptor, so
		 * avoid having to split UNMAP descriptors and overflow the page
		 * limit by using that as a max.
		 */
		_lto4b(ATA_DSM_TRIM_MAX_LEN, pg.max_unmap_lba_count);
		_lto4b(512 / 8, pg.max_unmap_desc_count);
        }

	bcopy(&pg, xs->data, MIN(sizeof(pg), xs->datalen));

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_disk_vpd_info(struct scsi_xfer *xs)
{
	struct scsi_link        *link = xs->sc_link;
	struct atascsi_port	*ap;
	struct scsi_vpd_disk_info pg;

	ap = atascsi_lookup_port(link);
	bzero(&pg, sizeof(pg));
	pg.hdr.device = T_DIRECT;
	pg.hdr.page_code = SI_PG_DISK_INFO;
	_lto2b(sizeof(pg) - sizeof(pg.hdr), pg.hdr.page_length);

	_lto2b(letoh16(ap->ap_identify.rpm), pg.rpm);
	pg.form_factor = letoh16(ap->ap_identify.form) & ATA_ID_FORM_MASK;

	bcopy(&pg, xs->data, MIN(sizeof(pg), xs->datalen));

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_disk_vpd_thin(struct scsi_xfer *xs)
{
	struct scsi_link        *link = xs->sc_link;
	struct atascsi_port	*ap;
	struct scsi_vpd_disk_thin pg;

	ap = atascsi_lookup_port(link);
	if (!ISSET(ap->ap_features, ATA_PORT_F_TRIM)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	bzero(&pg, sizeof(pg));
	pg.hdr.device = T_DIRECT;
	pg.hdr.page_code = SI_PG_DISK_THIN;
	_lto2b(sizeof(pg) - sizeof(pg.hdr), pg.hdr.page_length);

	pg.flags = VPD_DISK_THIN_TPU | VPD_DISK_THIN_TPWS;

	bcopy(&pg, xs->data, MIN(sizeof(pg), xs->datalen));

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_disk_write_same_16(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;
	struct scsi_write_same_16 *cdb;
	struct ata_xfer		*xa = xs->io;
	struct ata_fis_h2d	*fis;
	u_int64_t		lba;
	u_int32_t		length;
	u_int64_t		desc;

	if (xs->cmdlen != sizeof(*cdb)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	ap = atascsi_lookup_port(link);
	cdb = (struct scsi_write_same_16 *)xs->cmd;

	if (!ISSET(cdb->flags, WRITE_SAME_F_UNMAP) ||
	   !ISSET(ap->ap_features, ATA_PORT_F_TRIM)) {
		/* generate sense data */
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	if (xs->datalen < 512) {
		/* generate sense data */
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	lba = _8btol(cdb->lba);
	length = _4btol(cdb->length);

	if (length > ATA_DSM_TRIM_MAX_LEN) {
		/* XXX we dont support requests over 65535 blocks */
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	xa->data = xs->data;
	xa->datalen = 512;
	xa->flags = ATA_F_WRITE;
	xa->pmp_port = ap->ap_pmp_port;
	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;
	xa->complete = atascsi_disk_write_same_16_done;
	xa->atascsi_private = xs;
	xa->timeout = (xs->timeout < 45000) ? 45000 : xs->timeout;

	/* TRIM sends a list of blocks to discard in the databuf. */
	memset(xa->data, 0, xa->datalen);
	desc = htole64(ATA_DSM_TRIM_DESC(lba, length));
	memcpy(xa->data, &desc, sizeof(desc));

	fis = xa->fis;
	fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	fis->command = ATA_C_DSM;
	fis->features = ATA_DSM_TRIM;
	fis->sector_count = 1;

	ata_exec(as, xa);
}

void
atascsi_disk_write_same_16_done(struct ata_xfer *xa)
{
	struct scsi_xfer	*xs = xa->atascsi_private;

	switch (xa->state) {
	case ATA_S_COMPLETE:
		xs->error = XS_NOERROR;
		break;
	case ATA_S_ERROR:
		xs->error = XS_DRIVER_STUFFUP;
		break;
	case ATA_S_TIMEOUT:
		xs->error = XS_TIMEOUT;
		break;

	default:
		panic("atascsi_disk_write_same_16_done: "
		    "unexpected ata_xfer state (%d)", xa->state);
	}

	scsi_done(xs);
}

void
atascsi_disk_unmap(struct scsi_xfer *xs)
{
	struct ata_xfer		*xa = xs->io;
	struct scsi_unmap	*cdb;
	struct scsi_unmap_data	*unmap;
	u_int			len;

	if (ISSET(xs->flags, SCSI_POLL) || xs->cmdlen != sizeof(*cdb))
		atascsi_done(xs, XS_DRIVER_STUFFUP);

	cdb = (struct scsi_unmap *)xs->cmd;
	len = _2btol(cdb->list_len);
	if (xs->datalen != len || len < sizeof(*unmap)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	unmap = (struct scsi_unmap_data *)xs->data;
	if (_2btol(unmap->data_length) != len) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	len = _2btol(unmap->desc_length);
	if (len != xs->datalen - sizeof(*unmap)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	if (len < sizeof(struct scsi_unmap_desc)) {
		/* no work, no error according to sbc3 */
		atascsi_done(xs, XS_NOERROR);
	}

	if (len > sizeof(struct scsi_unmap_desc) * 64) {
		/* more work than we advertised */
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	/* let's go */
	if (ISSET(xs->flags, SCSI_NOSLEEP)) {
		task_set(&xa->task, atascsi_disk_unmap_task, xs);
		task_add(systq, &xa->task);
	} else {
		/* we can already sleep for memory */
		atascsi_disk_unmap_task(xs);
	}
}

void
atascsi_disk_unmap_task(void *xxs)
{
	struct scsi_xfer	*xs = xxs;
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;
	struct ata_xfer		*xa = xs->io;
	struct ata_fis_h2d	*fis;
	struct scsi_unmap_data	*unmap;
	struct scsi_unmap_desc	*descs, *d;
	u_int64_t		*trims;
	u_int			len, i;

	trims = dma_alloc(512, PR_WAITOK | PR_ZERO);

	ap = atascsi_lookup_port(link);
	unmap = (struct scsi_unmap_data *)xs->data;
	descs = (struct scsi_unmap_desc *)(unmap + 1);

	len = _2btol(unmap->desc_length) / sizeof(*d);
	for (i = 0; i < len; i++) {
		d = &descs[i];
		if (_4btol(d->logical_blocks) > ATA_DSM_TRIM_MAX_LEN)
			goto fail;

		trims[i] = htole64(ATA_DSM_TRIM_DESC(_8btol(d->logical_addr),
		    _4btol(d->logical_blocks)));
	}

	xa->data = trims;
	xa->datalen = 512;
	xa->flags = ATA_F_WRITE;
	xa->pmp_port = ap->ap_pmp_port;
	xa->complete = atascsi_disk_unmap_done;
	xa->atascsi_private = xs;
	xa->timeout = (xs->timeout < 45000) ? 45000 : xs->timeout;

	fis = xa->fis;
	fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	fis->command = ATA_C_DSM;
	fis->features = ATA_DSM_TRIM;
	fis->sector_count = 1;

	ata_exec(as, xa);
	return;

 fail:
	dma_free(xa->data, 512);
	atascsi_done(xs, XS_DRIVER_STUFFUP);
}

void
atascsi_disk_unmap_done(struct ata_xfer *xa)
{
	struct scsi_xfer	*xs = xa->atascsi_private;

	dma_free(xa->data, 512);

	switch (xa->state) {
	case ATA_S_COMPLETE:
		xs->error = XS_NOERROR;
		break;
	case ATA_S_ERROR:
		xs->error = XS_DRIVER_STUFFUP;
		break;
	case ATA_S_TIMEOUT:
		xs->error = XS_TIMEOUT;
		break;

	default:
		panic("atascsi_disk_unmap_done: "
		    "unexpected ata_xfer state (%d)", xa->state);
	}

	scsi_done(xs);
}

void
atascsi_disk_sync(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;
	struct ata_xfer		*xa = xs->io;

	if (xs->cmdlen != sizeof(struct scsi_synchronize_cache)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	ap = atascsi_lookup_port(link);
	xa->datalen = 0;
	xa->flags = ATA_F_READ;
	xa->complete = atascsi_disk_sync_done;
	/* Spec says flush cache can take >30 sec, so give it at least 45. */
	xa->timeout = (xs->timeout < 45000) ? 45000 : xs->timeout;
	xa->atascsi_private = xs;
	xa->pmp_port = ap->ap_pmp_port;
	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;

	xa->fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	xa->fis->command = ATA_C_FLUSH_CACHE;
	xa->fis->device = 0;

	ata_exec(as, xa);
}

void
atascsi_disk_sync_done(struct ata_xfer *xa)
{
	struct scsi_xfer	*xs = xa->atascsi_private;

	switch (xa->state) {
	case ATA_S_COMPLETE:
		xs->error = XS_NOERROR;
		break;

	case ATA_S_ERROR:
	case ATA_S_TIMEOUT:
		printf("atascsi_disk_sync_done: %s\n",
		    xa->state == ATA_S_TIMEOUT ? "timeout" : "error");
		xs->error = (xa->state == ATA_S_TIMEOUT ? XS_TIMEOUT :
		    XS_DRIVER_STUFFUP);
		break;

	default:
		panic("atascsi_disk_sync_done: unexpected ata_xfer state (%d)",
		    xa->state);
	}

	scsi_done(xs);
}

u_int64_t
ata_identify_blocks(struct ata_identify *id)
{
	u_int64_t		blocks = 0;
	int			i;

	if (letoh16(id->cmdset83) & 0x0400) {
		/* LBA48 feature set supported */
		for (i = 3; i >= 0; --i) {
			blocks <<= 16;
			blocks += letoh16(id->addrsecxt[i]);
		}
	} else {
		blocks = letoh16(id->addrsec[1]);
		blocks <<= 16;
		blocks += letoh16(id->addrsec[0]);
	}

	return (blocks - 1);
}

u_int
ata_identify_blocksize(struct ata_identify *id)
{
	u_int			blocksize = 512;
	u_int16_t		p2l_sect = letoh16(id->p2l_sect);
	
	if ((p2l_sect & ATA_ID_P2L_SECT_MASK) == ATA_ID_P2L_SECT_VALID &&
	    ISSET(p2l_sect, ATA_ID_P2L_SECT_SIZESET)) {
		blocksize = letoh16(id->words_lsec[1]);
		blocksize <<= 16;
		blocksize += letoh16(id->words_lsec[0]);
		blocksize <<= 1;
	}

	return (blocksize);
}

u_int
ata_identify_block_l2p_exp(struct ata_identify *id)
{
	u_int			exponent = 0;
	u_int16_t		p2l_sect = letoh16(id->p2l_sect);
	
	if ((p2l_sect & ATA_ID_P2L_SECT_MASK) == ATA_ID_P2L_SECT_VALID &&
	    ISSET(p2l_sect, ATA_ID_P2L_SECT_SET)) {
		exponent = (p2l_sect & ATA_ID_P2L_SECT_SIZE);
	}

	return (exponent);
}

u_int
ata_identify_block_logical_align(struct ata_identify *id)
{
	u_int			align = 0;
	u_int16_t		p2l_sect = letoh16(id->p2l_sect);
	u_int16_t		logical_align = letoh16(id->logical_align);
	
	if ((p2l_sect & ATA_ID_P2L_SECT_MASK) == ATA_ID_P2L_SECT_VALID &&
	    ISSET(p2l_sect, ATA_ID_P2L_SECT_SET) &&
	    (logical_align & ATA_ID_LALIGN_MASK) == ATA_ID_LALIGN_VALID)
		align = logical_align & ATA_ID_LALIGN;

	return (align);
}

void
atascsi_disk_capacity(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct atascsi_port	*ap;
	struct scsi_read_cap_data rcd;
	u_int64_t		capacity;

	ap = atascsi_lookup_port(link);
	if (xs->cmdlen != sizeof(struct scsi_read_capacity)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	bzero(&rcd, sizeof(rcd));
	capacity = ata_identify_blocks(&ap->ap_identify);
	if (capacity > 0xffffffff)
		capacity = 0xffffffff;

	_lto4b(capacity, rcd.addr);
	_lto4b(ata_identify_blocksize(&ap->ap_identify), rcd.length);

	bcopy(&rcd, xs->data, MIN(sizeof(rcd), xs->datalen));

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_disk_capacity16(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct atascsi_port	*ap;
	struct scsi_read_cap_data_16 rcd;
	u_int			align;
	u_int16_t		lowest_aligned = 0;

	ap = atascsi_lookup_port(link);
	if (xs->cmdlen != sizeof(struct scsi_read_capacity_16)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	bzero(&rcd, sizeof(rcd));

	_lto8b(ata_identify_blocks(&ap->ap_identify), rcd.addr);
	_lto4b(ata_identify_blocksize(&ap->ap_identify), rcd.length);
	rcd.logical_per_phys = ata_identify_block_l2p_exp(&ap->ap_identify);
	align = ata_identify_block_logical_align(&ap->ap_identify);
	if (align > 0)
		lowest_aligned = (1 << rcd.logical_per_phys) - align;

	if (ISSET(ap->ap_features, ATA_PORT_F_TRIM)) {
		SET(lowest_aligned, READ_CAP_16_TPE);

		if (ISSET(letoh16(ap->ap_identify.add_support), 
		    ATA_ID_ADD_SUPPORT_DRT))
			SET(lowest_aligned, READ_CAP_16_TPRZ);
	}
	_lto2b(lowest_aligned, rcd.lowest_aligned);

	bcopy(&rcd, xs->data, MIN(sizeof(rcd), xs->datalen));

	atascsi_done(xs, XS_NOERROR);
}

int
atascsi_passthru_map(struct scsi_xfer *xs, u_int8_t count_proto, u_int8_t flags)
{
	struct ata_xfer		*xa = xs->io;

	xa->data = xs->data;
	xa->datalen = xs->datalen;
	xa->timeout = xs->timeout;
	xa->flags = 0;
	if (xs->flags & SCSI_DATA_IN)
		xa->flags |= ATA_F_READ;
	if (xs->flags & SCSI_DATA_OUT)
		xa->flags |= ATA_F_WRITE;
	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;

	switch (count_proto & ATA_PASSTHRU_PROTO_MASK) {
	case ATA_PASSTHRU_PROTO_NON_DATA:
	case ATA_PASSTHRU_PROTO_PIO_DATAIN:
	case ATA_PASSTHRU_PROTO_PIO_DATAOUT:
		xa->flags |= ATA_F_PIO;
		break;
	default:
		/* we dont support this yet */
		return (1);
	}

	xa->atascsi_private = xs;
	xa->complete = atascsi_passthru_done;

	return (0);
}

void
atascsi_passthru_12(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;
	struct ata_xfer		*xa = xs->io;
	struct scsi_ata_passthru_12 *cdb;
	struct ata_fis_h2d	*fis;

	if (xs->cmdlen != sizeof(*cdb)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	cdb = (struct scsi_ata_passthru_12 *)xs->cmd;
	/* validate cdb */

	if (atascsi_passthru_map(xs, cdb->count_proto, cdb->flags) != 0) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	ap = atascsi_lookup_port(link);
	fis = xa->fis;
	fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	fis->command = cdb->command;
	fis->features = cdb->features;
	fis->lba_low = cdb->lba_low;
	fis->lba_mid = cdb->lba_mid;
	fis->lba_high = cdb->lba_high;
	fis->device = cdb->device;
	fis->sector_count = cdb->sector_count;
	xa->pmp_port = ap->ap_pmp_port;

	ata_exec(as, xa);
}

void
atascsi_passthru_16(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;
	struct ata_xfer		*xa = xs->io;
	struct scsi_ata_passthru_16 *cdb;
	struct ata_fis_h2d	*fis;

	if (xs->cmdlen != sizeof(*cdb)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	cdb = (struct scsi_ata_passthru_16 *)xs->cmd;
	/* validate cdb */

	if (atascsi_passthru_map(xs, cdb->count_proto, cdb->flags) != 0) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	ap = atascsi_lookup_port(link);
	fis = xa->fis;
	fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	fis->command = cdb->command;
	fis->features = cdb->features[1];
	fis->lba_low = cdb->lba_low[1];
	fis->lba_mid = cdb->lba_mid[1];
	fis->lba_high = cdb->lba_high[1];
	fis->device = cdb->device;
	fis->lba_low_exp = cdb->lba_low[0];
	fis->lba_mid_exp = cdb->lba_mid[0];
	fis->lba_high_exp = cdb->lba_high[0];
	fis->features_exp = cdb->features[0];
	fis->sector_count = cdb->sector_count[1];
	fis->sector_count_exp = cdb->sector_count[0];
	xa->pmp_port = ap->ap_pmp_port;

	ata_exec(as, xa);
}

void
atascsi_passthru_done(struct ata_xfer *xa)
{
	struct scsi_xfer	*xs = xa->atascsi_private;

	/*
	 * XXX need to generate sense if cdb wants it
	 */

	switch (xa->state) {
	case ATA_S_COMPLETE:
		xs->error = XS_NOERROR;
		break;
	case ATA_S_ERROR:
		xs->error = XS_DRIVER_STUFFUP;
		break;
	case ATA_S_TIMEOUT:
		printf("atascsi_passthru_done, timeout\n");
		xs->error = XS_TIMEOUT;
		break;
	default:
		panic("atascsi_atapi_cmd_done: unexpected ata_xfer state (%d)",
		    xa->state);
	}

	xs->resid = xa->resid;

	scsi_done(xs);
}

void
atascsi_disk_sense(struct scsi_xfer *xs)
{
	struct scsi_sense_data	*sd = (struct scsi_sense_data *)xs->data;

	bzero(xs->data, xs->datalen);
	/* check datalen > sizeof(struct scsi_sense_data)? */
	sd->error_code = SSD_ERRCODE_CURRENT;
	sd->flags = SKEY_NO_SENSE;

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_disk_start_stop(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;
	struct ata_xfer		*xa = xs->io;
	struct scsi_start_stop	*ss = (struct scsi_start_stop *)xs->cmd;

	if (xs->cmdlen != sizeof(*ss)) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	if (ss->how != SSS_STOP) {
		atascsi_done(xs, XS_NOERROR);
		return;
	}

	/*
	 * A SCSI START STOP UNIT command with the START bit set to
	 * zero gets translated into an ATA FLUSH CACHE command
	 * followed by an ATA STANDBY IMMEDIATE command.
	 */
	ap = atascsi_lookup_port(link);
	xa->datalen = 0;
	xa->flags = ATA_F_READ;
	xa->complete = atascsi_disk_start_stop_done;
	/* Spec says flush cache can take >30 sec, so give it at least 45. */
	xa->timeout = (xs->timeout < 45000) ? 45000 : xs->timeout;
	xa->pmp_port = ap->ap_pmp_port;
	xa->atascsi_private = xs;
	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;

	xa->fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	xa->fis->command = ATA_C_FLUSH_CACHE;
	xa->fis->device = 0;

	ata_exec(as, xa);
}

void
atascsi_disk_start_stop_done(struct ata_xfer *xa)
{
	struct scsi_xfer	*xs = xa->atascsi_private;
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;

	switch (xa->state) {
	case ATA_S_COMPLETE:
		break;

	case ATA_S_ERROR:
	case ATA_S_TIMEOUT:
		xs->error = (xa->state == ATA_S_TIMEOUT ? XS_TIMEOUT :
		    XS_DRIVER_STUFFUP);
		xs->resid = xa->resid;
		scsi_done(xs);
		return;

	default:
		panic("atascsi_disk_start_stop_done: unexpected ata_xfer state (%d)",
		    xa->state);
	}

	/*
	 * The FLUSH CACHE command completed succesfully; now issue
	 * the STANDBY IMMEDATE command.
	 */
	ap = atascsi_lookup_port(link);
	xa->datalen = 0;
	xa->flags = ATA_F_READ;
	xa->state = ATA_S_SETUP;
	xa->complete = atascsi_disk_cmd_done;
	/* Spec says flush cache can take >30 sec, so give it at least 45. */
	xa->timeout = (xs->timeout < 45000) ? 45000 : xs->timeout;
	xa->pmp_port = ap->ap_pmp_port;
	xa->atascsi_private = xs;
	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;

	xa->fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	xa->fis->command = ATA_C_STANDBY_IMMED;
	xa->fis->device = 0;

	ata_exec(as, xa);
}

void
atascsi_atapi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;
	struct ata_xfer		*xa = xs->io;
	struct ata_fis_h2d	*fis;

	switch (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
	case SCSI_DATA_IN:
		xa->flags = ATA_F_PACKET | ATA_F_READ;
		break;
	case SCSI_DATA_OUT:
		xa->flags = ATA_F_PACKET | ATA_F_WRITE;
		break;
	default:
		xa->flags = ATA_F_PACKET;
	}
	xa->flags |= ATA_F_GET_RFIS;

	ap = atascsi_lookup_port(link);
	xa->data = xs->data;
	xa->datalen = xs->datalen;
	xa->complete = atascsi_atapi_cmd_done;
	xa->timeout = xs->timeout;
	xa->pmp_port = ap->ap_pmp_port;
	xa->atascsi_private = xs;
	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;

	fis = xa->fis;
	fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	fis->command = ATA_C_PACKET;
	fis->device = 0;
	fis->sector_count = xa->tag << 3;
	fis->features = ATA_H2D_FEATURES_DMA | ((xa->flags & ATA_F_WRITE) ?
	    ATA_H2D_FEATURES_DIR_WRITE : ATA_H2D_FEATURES_DIR_READ);
	fis->lba_mid = 0x00;
	fis->lba_high = 0x20;

	/* Copy SCSI command into ATAPI packet. */
	memcpy(xa->packetcmd, xs->cmd, xs->cmdlen);

	ata_exec(as, xa);
}

void
atascsi_atapi_cmd_done(struct ata_xfer *xa)
{
	struct scsi_xfer	*xs = xa->atascsi_private;
	struct scsi_sense_data  *sd = &xs->sense;

	switch (xa->state) {
	case ATA_S_COMPLETE:
		xs->error = XS_NOERROR;
		break;
	case ATA_S_ERROR:
		/* Return PACKET sense data */
		sd->error_code = SSD_ERRCODE_CURRENT;
		sd->flags = (xa->rfis.error & 0xf0) >> 4;
		if (xa->rfis.error & 0x04)
			sd->flags = SKEY_ILLEGAL_REQUEST;
		if (xa->rfis.error & 0x02)
			sd->flags |= SSD_EOM;
		if (xa->rfis.error & 0x01)
			sd->flags |= SSD_ILI;
		xs->error = XS_SENSE;
		break;
	case ATA_S_TIMEOUT:
		printf("atascsi_atapi_cmd_done, timeout\n");
		xs->error = XS_TIMEOUT;
		break;
	default:
		panic("atascsi_atapi_cmd_done: unexpected ata_xfer state (%d)",
		    xa->state);
	}

	xs->resid = xa->resid;

	scsi_done(xs);
}

void
atascsi_pmp_cmd(struct scsi_xfer *xs)
{
	switch (xs->cmd->opcode) {
	case REQUEST_SENSE:
		atascsi_pmp_sense(xs);
		return;
	case INQUIRY:
		atascsi_pmp_inq(xs);
		return;

	case TEST_UNIT_READY:
	case PREVENT_ALLOW:
		atascsi_done(xs, XS_NOERROR);
		return;

	default:
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}
}

void
atascsi_pmp_sense(struct scsi_xfer *xs)
{
	struct scsi_sense_data *sd = (struct scsi_sense_data *)xs->data;

	bzero(xs->data, xs->datalen);
	sd->error_code = SSD_ERRCODE_CURRENT;
	sd->flags = SKEY_NO_SENSE;

	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_pmp_inq(struct scsi_xfer *xs)
{
	struct scsi_inquiry_data inq;
	struct scsi_inquiry *in_inq = (struct scsi_inquiry *)xs->cmd;

	if (ISSET(in_inq->flags, SI_EVPD)) {
		/* any evpd pages we need to support here? */
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
	}

	bzero(&inq, sizeof(inq));
	inq.device = 0x1E;	/* "well known logical unit" seems reasonable */
	inq.version = 0x05;	/* SPC-3? */
	inq.response_format = 2;
	inq.additional_length = 32;
	inq.flags |= SID_CmdQue;
	bcopy("ATA     ", inq.vendor, sizeof(inq.vendor));

	/* should use the data from atascsi_pmp_identify here?
	 * not sure how useful the chip id is, but maybe it'd be
	 * nice to include the number of ports.
	 */
	bcopy("Port Multiplier", inq.product, sizeof(inq.product));
	bcopy("    ", inq.revision, sizeof(inq.revision));

	bcopy(&inq, xs->data, MIN(sizeof(inq), xs->datalen));
	atascsi_done(xs, XS_NOERROR);
}

void
atascsi_done(struct scsi_xfer *xs, int error)
{
	xs->error = error;
	scsi_done(xs);
}

void
ata_exec(struct atascsi *as, struct ata_xfer *xa)
{
	as->as_methods->ata_cmd(xa);
}

void *
atascsi_io_get(void *cookie)
{
	struct atascsi_host_port	*ahp = cookie;
	struct atascsi			*as = ahp->ahp_as;
	struct ata_xfer			*xa;

	xa = as->as_methods->ata_get_xfer(as->as_cookie, ahp->ahp_port);
	if (xa != NULL)
		xa->fis->type = ATA_FIS_TYPE_H2D;

	return (xa);
}

void
atascsi_io_put(void *cookie, void *io)
{
	struct atascsi_host_port	*ahp = cookie;
	struct atascsi			*as = ahp->ahp_as;
	struct ata_xfer			*xa = io;

	xa->state = ATA_S_COMPLETE; /* XXX this state machine is dumb */
	as->as_methods->ata_put_xfer(xa);
}

void
ata_polled_complete(struct ata_xfer *xa)
{
	/* do nothing */
}

int
ata_polled(struct ata_xfer *xa)
{
	int			rv;

	if (!ISSET(xa->flags, ATA_F_DONE))
		panic("ata_polled: xa isnt complete");

	switch (xa->state) {
	case ATA_S_COMPLETE:
		rv = 0;
		break;
	case ATA_S_ERROR:
	case ATA_S_TIMEOUT:
		rv = EIO;
		break;
	default:
		panic("ata_polled: xa state (%d)",
		    xa->state);
	}

	scsi_io_put(xa->atascsi_private, xa);

	return (rv);
}

void
ata_complete(struct ata_xfer *xa)
{
	SET(xa->flags, ATA_F_DONE);
	xa->complete(xa);
}

void
ata_swapcopy(void *src, void *dst, size_t len)
{
	u_int16_t *s = src, *d = dst;
	int i;

	len /= 2;

	for (i = 0; i < len; i++)
		d[i] = swap16(s[i]);
}

int
atascsi_port_identify(struct atascsi_port *ap, struct ata_identify *identify)
{
	struct atascsi			*as = ap->ap_as;
	struct atascsi_host_port	*ahp = ap->ap_host_port;
	struct ata_xfer			*xa;

	xa = scsi_io_get(&ahp->ahp_iopool, SCSI_NOSLEEP);
	if (xa == NULL)
		panic("no free xfers on a new port");
	xa->pmp_port = ap->ap_pmp_port;
	xa->data = identify;
	xa->datalen = sizeof(*identify);
	xa->fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	xa->fis->command = (ap->ap_type == ATA_PORT_T_DISK) ?
	    ATA_C_IDENTIFY : ATA_C_IDENTIFY_PACKET;
	xa->fis->device = 0;
	xa->flags = ATA_F_READ | ATA_F_PIO | ATA_F_POLL;
	xa->timeout = 1000;
	xa->complete = ata_polled_complete;
	xa->atascsi_private = &ahp->ahp_iopool;
	ata_exec(as, xa);
	return (ata_polled(xa));
}

int
atascsi_port_set_features(struct atascsi_port *ap, int subcommand, int arg)
{
	struct atascsi			*as = ap->ap_as;
	struct atascsi_host_port	*ahp = ap->ap_host_port;
	struct ata_xfer			*xa;

	xa = scsi_io_get(&ahp->ahp_iopool, SCSI_NOSLEEP);
	if (xa == NULL)
		panic("no free xfers on a new port");
	xa->fis->command = ATA_C_SET_FEATURES;
	xa->fis->features = subcommand;
	xa->fis->sector_count = arg;
	xa->fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
	xa->flags = ATA_F_POLL;
	xa->timeout = 1000;
	xa->complete = ata_polled_complete;
	xa->pmp_port = ap->ap_pmp_port;
	xa->atascsi_private = &ahp->ahp_iopool;
	ata_exec(as, xa);
	return (ata_polled(xa));
}
@


1.127
log
@Fix typo in comment.

Pointed out by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.126 2015/12/29 09:44:46 kettenis Exp $ */
d494 1
a494 1
		free(ahp, M_DEVBUF, sizeof(*ap));
@


1.126
log
@Set UltraDMA transfer mode.  Some (early?) SATA drives, such as the Maxtor
7Y250M0, refuse to do DMA unless the transfer mode has been set.  This causes
reads (and presumably writes) to time out.

Unlike the wdc code, this only sets the UltraDMA transfer mode.  If we ever
want to support ancient PATA drivers through the atascsi layer, we probably
need to set the PIO and/or MWDMA transfer modes as well.

ok jmatthew@@, dlg@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.125 2015/08/28 00:03:53 deraadt Exp $ */
d370 1
a370 1
	 * Early SATA drivers (as well as PATA drives) need to have
@


1.125
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.124 2015/05/15 10:54:26 dlg Exp $ */
d269 2
d368 18
@


1.124
log
@rename the probe and free members of atascsi_methods to ata_probe
and ata_free.

this makes them consistent with the rest of the members, and lets
me #define free to weird debug things in the kernel without screwing
these files up.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.123 2015/03/14 03:38:47 jsg Exp $ */
d217 1
a217 1
	free(as, M_DEVBUF, 0);
d437 1
a437 1
	free(ap, M_DEVBUF, 0);
d464 1
a464 1
	free(ap, M_DEVBUF, 0);
d474 1
a474 1
		free(ahp, M_DEVBUF, 0);
@


1.123
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.122 2015/01/27 03:17:36 dlg Exp $ */
d280 1
a280 1
	type = as->as_methods->probe(as->as_cookie, port, link->lun);
d440 1
a440 1
	as->as_methods->free(as->as_cookie, port, link->lun);
d467 1
a467 1
	as->as_methods->free(as->as_cookie, port, link->lun);
@


1.122
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.121 2014/12/09 07:05:06 doug Exp $ */
a35 2

#include <sys/ataio.h>
@


1.121
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.120 2014/09/14 14:17:24 jsg Exp $ */
d124 1
a124 1
void		atascsi_disk_unmap_task(void *, void *);
d1093 1
a1093 1
		task_set(&xa->task, atascsi_disk_unmap_task, xs, NULL);
d1097 1
a1097 1
		atascsi_disk_unmap_task(xs, NULL);
d1102 1
a1102 1
atascsi_disk_unmap_task(void *xxs, void *a)
@


1.120
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.119 2014/07/12 18:48:17 tedu Exp $ */
d196 2
a197 2
	as->as_host_ports = malloc(sizeof(struct atascsi_host_port *) *
	    aaa->aaa_nports, M_DEVBUF, M_WAITOK | M_ZERO);
d323 2
a324 2
		ahp->ahp_ports = malloc(sizeof(struct atascsi_port *) *
		    ahp->ahp_nports, M_DEVBUF, M_WAITOK | M_ZERO);
@


1.119
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.118 2013/12/09 11:44:52 dlg Exp $ */
a26 1
#include <sys/proc.h>
@


1.118
log
@replace workq_task_add with a task. stash teh struct in the ata xfer thing
so its now reliable.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.117 2013/09/18 01:06:26 dlg Exp $ */
d219 2
a220 2
	free(as->as_host_ports, M_DEVBUF);
	free(as, M_DEVBUF);
d440 1
a440 1
	free(ap, M_DEVBUF);
d467 1
a467 1
	free(ap, M_DEVBUF);
d477 1
a477 1
		free(ahp, M_DEVBUF);
@


1.117
log
@return after done in atascsi_disk_unmap.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.116 2011/08/03 00:27:20 dlg Exp $ */
d1054 1
d1093 5
a1097 1
	if (!ISSET(xs->flags, SCSI_NOSLEEP))
a1098 4
	else if (workq_add_task(NULL, 0, atascsi_disk_unmap_task,
	    xs, NULL) != 0) {
		atascsi_done(xs, XS_DRIVER_STUFFUP);
		return;
@


1.116
log
@Alexander Polakov found a use of an uninitialized pointer in the scsi
unmap handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.115 2011/07/17 22:46:48 matthew Exp $ */
d1063 1
a1063 1
	if (xs->datalen != len || len < sizeof(*unmap))
d1065 2
d1069 1
a1069 1
	if (_2btol(unmap->data_length) != len)
d1071 2
d1075 1
a1075 1
	if (len != xs->datalen - sizeof(*unmap))
d1077 2
d1088 1
d1095 1
a1095 1
	    xs, NULL) != 0)
d1097 2
@


1.115
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.114 2011/07/09 06:24:41 dlg Exp $ */
d1108 1
@


1.114
log
@translate the scsi UNMAP command into an equiv TRIM, and advertise UNMAP
support via the thin provisioning page.

this emul is a bit unreliable since atascsi needs to allocate memory for
the TRIM command to use, but we figure that the world wont end if we lose
a TRIM unlink real io.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.113 2011/07/09 01:50:41 matthew Exp $ */
a52 1
	int			as_nports;
a181 1
	as->as_nports = aaa->aaa_nports;
d192 3
a194 1
	as->as_link.adapter_target = SCSI_NO_ADAPTER_TARGET;
d198 1
a198 1
	    as->as_nports, M_DEVBUF, M_WAITOK | M_ZERO);
a201 2
	saa.saa_targets = as->as_nports;
	saa.saa_luns = SATA_PMP_MAX_PORTS;
d251 1
a251 1
	if (link->target >= as->as_nports)
d274 1
a274 1
	if (port >= as->as_nports)
d456 1
a456 1
	if (port >= as->as_nports)
@


1.113
log
@Fix fallout from my previous SCSI refactoring diff (moving
adapter_buswidth to sc_targets): gdt(4) and atascsi(4) still used it
in other ways.

Apply appropriate fixes; tested on ahci(4).

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.112 2011/07/08 22:09:27 matthew Exp $ */
d125 3
d546 3
d955 1
a955 1
	pg.flags = VPD_DISK_THIN_TPWS;
d1047 118
@


1.112
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.111 2011/07/08 08:16:50 dlg Exp $ */
d53 1
d180 1
d191 1
a191 1
	as->as_link.adapter_target = aaa->aaa_nports;
d195 1
a195 1
	    aaa->aaa_nports, M_DEVBUF, M_WAITOK | M_ZERO);
d199 1
a199 1
	saa.saa_targets = aaa->aaa_nports;
d250 1
a250 1
	if (link->target >= as->as_link.adapter_buswidth)
d273 1
a273 1
	if (port >= as->as_link.adapter_buswidth)
d455 1
a455 1
	if (port >= as->as_link.adapter_buswidth)
@


1.111
log
@fill in the ata vpd page as best we can. i dont know how to fill in the
device signature so i left it blank, and the identify is the cached copy
in the port structure.

i filled the SAT vendor stuff in as "OpenBSD", "atascsi", osrelease.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.109 2011/07/08 07:15:31 dlg Exp $ */
a188 2
	as->as_link.adapter_buswidth = aaa->aaa_nports;
	as->as_link.luns = SATA_PMP_MAX_PORTS;
d197 2
@


1.110
log
@provide the thin provisining vpd page if the disk does trim. only claim
to do WRITE SAME 16 for now (which is all we do).
@
text
@d118 1
d684 3
d736 1
a736 1
		u_int8_t		list[6];
d753 4
a756 3
	pg.list[3] = SI_PG_DISK_LIMITS;
	pg.list[4] = SI_PG_DISK_INFO;
	pg.list[5] = SI_PG_DISK_THIN; /* "trimmed" if fat. get it? tehe. */
d831 42
@


1.109
log
@some trim cleanups and additions.

use less magic numbers when check the block limits for trim. fill in the
block limits vpd page with some conservative numbers about how much
unmap we can do at a time (~32MB over 64 descriptors).
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.108 2011/07/05 03:47:55 dlg Exp $ */
d120 1
d689 3
d732 1
a732 1
		u_int8_t		list[5];
d734 6
d745 1
a745 1
	_lto2b(sizeof(pg.list), pg.hdr.page_length);
d751 1
d753 1
a753 1
	bcopy(&pg, xs->data, MIN(sizeof(pg), xs->datalen));
d876 25
@


1.108
log
@i forgot to set the sector_count when translating WRITE SAME 16
into DSM/TRIM commands.

found by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.107 2011/06/21 06:03:14 matthew Exp $ */
d835 10
d892 1
a892 1
	if (cdb->flags != WRITE_SAME_F_UNMAP ||
d908 1
a908 1
	if (length > 0xffff) {
d926 1
a926 1
	desc = htole64(((u_int64_t)length << 48) | lba);
a946 1

d948 2
d951 1
a951 4
		printf("atascsi_disk_write_same_16_done: %s\n",
		    xa->state == ATA_S_TIMEOUT ? "timeout" : "error");
		xs->error = (xa->state == ATA_S_TIMEOUT ? XS_TIMEOUT :
		    XS_DRIVER_STUFFUP);
@


1.107
log
@Laurence Tratt reported that his "Intel 6 Series AHCI" ahci(4) no
longer detects his OCZ Vertex 3 after atascsi.c r1.104.  For some
reason, the first IDENTIFY command issued silently fails without any
notification.  In lieu of a better fix, workaround this for now by
allowing IDENTIFY to be reissued a second time for non-PMP disks.

Discussed with jmatthew@@ and dlg@@; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.106 2011/06/02 00:07:30 matthew Exp $ */
d889 6
d905 1
a905 1
	xa->datalen = xs->datalen;
d923 1
@


1.106
log
@Small refactoring of atascsi and fix non-data ATA commands to not set
ATA_F_PIO or ATA_F_READ.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.105 2011/05/08 19:46:10 matthew Exp $ */
d342 1
a342 1
		int count = (link->lun > 0) ? 6 : 1;
d346 1
a346 2
				bcopy(identify, &ap->ap_identify,
				    sizeof(ap->ap_identify));
@


1.105
log
@Move ata_put_xfer() from ata_xfer to atascsi_methods.  It's just silly
to have a non-changing function pointer be part of an object rather
than it's virtual method table.

ok dlg@@; tested on ahci(4) by Mattieu Baptiste, jasper@@, and Jason
Crawford; no sili(4) testers, but identical changes to ahci(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.104 2011/05/05 19:23:05 matthew Exp $ */
d160 5
d339 3
d344 1
a344 18
			xa = scsi_io_get(&ahp->ahp_iopool, SCSI_NOSLEEP);
			if (xa == NULL)
				panic("no free xfers on a new port");
			identify = dma_alloc(sizeof(*identify),
			    PR_WAITOK | PR_ZERO);
			xa->pmp_port = ap->ap_pmp_port;
			xa->data = identify;
			xa->datalen = sizeof(*identify);
			xa->fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
			xa->fis->command = (type == ATA_PORT_T_DISK) ?
			    ATA_C_IDENTIFY : ATA_C_IDENTIFY_PACKET;
			xa->fis->device = 0;
			xa->flags = ATA_F_READ | ATA_F_PIO | ATA_F_POLL;
			xa->timeout = 1000;
			xa->complete = ata_polled_complete;
			xa->atascsi_private = &ahp->ahp_iopool;
			ata_exec(as, xa);
			rv = ata_polled(xa);
a347 1
				dma_free(identify, sizeof(*identify));
a349 1
			dma_free(identify, sizeof(*identify));
d354 2
d404 2
a405 13
		xa = scsi_io_get(&ahp->ahp_iopool, SCSI_NOSLEEP);
		if (xa == NULL)
			panic("no free xfers on a new port");
		xa->fis->command = ATA_C_SET_FEATURES;
		xa->fis->features = ATA_SF_WRITECACHE_EN;
		xa->fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
		xa->flags = ATA_F_READ | ATA_F_PIO | ATA_F_POLL;
		xa->timeout = 1000;
		xa->complete = ata_polled_complete;
		xa->pmp_port = ap->ap_pmp_port;
		xa->atascsi_private = &ahp->ahp_iopool;
		ata_exec(as, xa);
		ata_polled(xa); /* we dont care if it doesnt work */
d410 2
a411 13
		xa = scsi_io_get(&ahp->ahp_iopool, SCSI_NOSLEEP);
		if (xa == NULL)
			panic("no free xfers on a new port");
		xa->fis->command = ATA_C_SET_FEATURES;
		xa->fis->features = ATA_SF_LOOKAHEAD_EN;
		xa->fis->flags = ATA_H2D_FLAGS_CMD | ap->ap_pmp_port;
		xa->flags = ATA_F_READ | ATA_F_PIO | ATA_F_POLL;
		xa->timeout = 1000;
		xa->complete = ata_polled_complete;
		xa->pmp_port = ap->ap_pmp_port;
		xa->atascsi_private = &ahp->ahp_iopool;
		ata_exec(as, xa);
		ata_polled(xa); /* we dont care if it doesnt work */
d426 1
a426 1
	xa->flags = ATA_F_READ | ATA_F_PIO | ATA_F_POLL;
d1619 48
@


1.104
log
@Go back to only attempting one IDENTIFY command against directly
attached devices as in the pre-port-multiplier code.  (Devices
attached via port multipliers still get multiple attempts though.)
Also don't bother sleeping after the last iteration if all attempts
failed.

Discussed with dlg@@ and Jonathan Matthew; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.103 2011/04/27 23:51:09 matthew Exp $ */
d1593 3
a1595 1
	struct ata_xfer		*xa = io;
d1598 1
a1598 1
	xa->ata_put_xfer(xa);
@


1.103
log
@Fix a few off-by-1 errors in atascsi.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.102 2011/04/02 15:23:36 krw Exp $ */
d334 2
a335 2
		int count = 5;
		do {
d361 3
a363 2
			delay(5000000);
		} while (count--);
@


1.102
log
@Safer, big mem friendly, allocation of identify buf that is the
target of DMA.

ok dlg@@ deraadt@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.101 2011/02/03 21:22:19 matthew Exp $ */
d241 1
a241 1
	if (link->target > as->as_link.adapter_buswidth)
d264 1
a264 1
	if (port > as->as_link.adapter_buswidth)
d269 1
a269 1
		if (link->lun > as->as_host_ports[port]->ahp_nports)
d482 1
a482 1
	if (port > as->as_link.adapter_buswidth)
@


1.101
log
@Initialize stack memory before use.  Found with clang.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.100 2011/01/26 21:41:00 drahn Exp $ */
d29 1
d339 2
a340 2
			/* XXX dma reachable */
			identify = malloc(sizeof(*identify), M_TEMP, M_WAITOK);
d357 1
a357 1
				free(identify, M_TEMP);
d360 1
a360 1
			free(identify, M_TEMP);
@


1.100
log
@Add port multiplier support, has been in snaps for a while with no reported
issues. No actual OKs, but general acknowledgement and 'get it in' from several.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.99 2011/01/12 21:00:04 kettenis Exp $ */
d1542 1
@


1.99
log
@Reset the state member of the ata_xfer to ATA_S_SETUP before reusing it
to issue another command, since sili(4) actually checks.  Fix a small
inaccuracy in a comment while I'm there.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.98 2010/11/20 05:12:39 deraadt Exp $ */
d5 2
d35 1
d45 1
a45 1
	struct atascsi_port	**as_ports;
d56 27
d85 1
a85 1
	struct scsi_iopool	ap_iopool;
d87 1
a87 1
	int			ap_port;
d89 1
d132 6
d157 1
d182 1
a182 1
	as->as_link.luns = 1; /* XXX port multiplier as luns */
d186 2
a187 2
	as->as_ports = malloc(sizeof(struct atascsi_port *) * aaa->aaa_nports,
	    M_DEVBUF, M_WAITOK | M_ZERO);
d208 1
a208 1
	free(as->as_ports, M_DEVBUF);
d215 1
a215 1
atascsi_probe_dev(struct atascsi *as, int port)
d217 5
a221 1
	return (scsi_probe_target(as->as_scsibus, port));
d225 11
a235 1
atascsi_detach_dev(struct atascsi *as, int port, int flags)
d237 11
a247 1
	return (scsi_detach_target(as->as_scsibus, port, flags));
d253 8
a260 11
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;
	struct ata_xfer		*xa;
	struct ata_identify	*identify;
	int			port, type, qdepth;
	int			rv;
	u_int16_t		cmdset;

	/* revisit this when we do port multipliers */
	if (link->lun > 0)
		return (ENXIO);
d266 7
a272 1
	type = as->as_methods->probe(as->as_cookie, port);
d280 8
d295 26
a320 1
	ap->ap_port = port;
d323 4
a326 2
	scsi_iopool_init(&ap->ap_iopool, ap, atascsi_io_get, atascsi_io_put);
	link->pool = &ap->ap_iopool;
d328 38
a365 20
	/* fetch the device info */
	xa = scsi_io_get(&ap->ap_iopool, SCSI_NOSLEEP);
	if (xa == NULL)
		panic("no free xfers on a new port");
	identify = malloc(sizeof(*identify), M_TEMP, M_WAITOK); /* XXX dma reachable */
	xa->data = identify;
	xa->datalen = sizeof(*identify);
	xa->fis->flags = ATA_H2D_FLAGS_CMD;
	xa->fis->command = (type == ATA_PORT_T_DISK) ?
	    ATA_C_IDENTIFY : ATA_C_IDENTIFY_PACKET;
	xa->fis->device = 0;
	xa->flags = ATA_F_READ | ATA_F_PIO | ATA_F_POLL;
	xa->timeout = 1000;
	xa->complete = ata_polled_complete;
	xa->atascsi_private = &ap->ap_iopool;
	ata_exec(as, xa);
	rv = ata_polled(xa);
	if (rv != 0) {
		free(identify, M_TEMP);
		goto error;
a366 2
	bcopy(identify, &ap->ap_identify, sizeof(ap->ap_identify));
	free(identify, M_TEMP);
d368 1
a368 1
	as->as_ports[port] = ap;
d374 4
a377 3
	    ISSET(letoh16(ap->ap_identify.satacap), ATA_SATACAP_NCQ)) {
		qdepth = ATA_QDEPTH(letoh16(ap->ap_identify.qdepth));
		qdepth = MIN(qdepth, as->as_ncqdepth);
d388 2
a389 2
			 * XXX throw away any xfers that have tag numbers
			 * higher than what the device supports.
d391 7
a397 5
			while (qdepth--) {
				xa = scsi_io_get(&ap->ap_iopool, SCSI_NOSLEEP);
				if (xa->tag < link->openings) {
					xa->state = ATA_S_COMPLETE;
					scsi_io_put(&ap->ap_iopool, xa);
d411 1
a411 1
		xa = scsi_io_get(&ap->ap_iopool, SCSI_NOSLEEP);
d416 1
a416 1
		xa->fis->flags = ATA_H2D_FLAGS_CMD;
d420 2
a421 1
		xa->atascsi_private = &ap->ap_iopool;
d428 1
a428 1
		xa = scsi_io_get(&ap->ap_iopool, SCSI_NOSLEEP);
d433 1
a433 1
		xa->fis->flags = ATA_H2D_FLAGS_CMD;
d437 2
a438 1
		xa->atascsi_private = &ap->ap_iopool;
d450 1
a450 1
	xa = scsi_io_get(&ap->ap_iopool, SCSI_NOSLEEP);
d454 1
a454 1
	xa->fis->flags = ATA_H2D_FLAGS_CMD;
d458 2
a459 1
	xa->atascsi_private = &ap->ap_iopool;
d467 2
a468 1
	as->as_methods->free(as->as_cookie, port);
d475 4
a478 3
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap;
	int			port;
d480 2
a481 1
	if (link->lun > 0)
d484 2
a485 2
	port = link->target;
	if (port > as->as_link.adapter_buswidth)
d488 1
a488 2
	ap = as->as_ports[port];
	if (ap == NULL)
d491 1
d493 3
a495 1
	as->as_ports[port] = NULL;
d497 8
a504 1
	as->as_methods->free(as->as_cookie, port);
d511 1
a511 2
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap = as->as_ports[link->target];
d513 1
d526 3
d542 1
a542 1
	struct atascsi_port	*ap = as->as_ports[link->target];
d549 2
d616 1
a616 1
	fis->flags = ATA_H2D_FLAGS_CMD;
d622 1
d657 1
d731 3
a733 2
	struct atascsi          *as = link->adapter_softc;
	struct atascsi_port	*ap = as->as_ports[link->target];
d781 1
a781 2
	struct atascsi          *as = link->adapter_softc;
	struct atascsi_port	*ap = as->as_ports[link->target];
d784 1
d802 1
a802 2
	struct atascsi          *as = link->adapter_softc;
	struct atascsi_port	*ap = as->as_ports[link->target];
d811 1
d853 1
a853 2
	struct atascsi          *as = link->adapter_softc;
	struct atascsi_port	*ap = as->as_ports[link->target];
d856 1
d874 1
a874 2
	struct atascsi          *as = link->adapter_softc;
	struct atascsi_port	*ap = as->as_ports[link->target];
d877 1
d896 1
a896 1
	struct atascsi_port	*ap = as->as_ports[link->target];
d909 1
d931 1
d944 1
a944 1
	fis->flags = ATA_H2D_FLAGS_CMD;
d982 1
d990 1
d997 1
d1001 1
a1001 1
	xa->fis->flags = ATA_H2D_FLAGS_CMD;
d1105 1
a1105 2
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap = as->as_ports[link->target];
d1109 1
d1132 1
a1132 2
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap = as->as_ports[link->target];
d1137 1
d1204 1
d1222 1
d1224 1
a1224 1
	fis->flags = ATA_H2D_FLAGS_CMD;
d1232 1
d1242 1
d1260 1
d1262 1
a1262 1
	fis->flags = ATA_H2D_FLAGS_CMD;
d1275 1
d1328 1
d1347 1
d1353 1
d1358 1
a1358 1
	xa->fis->flags = ATA_H2D_FLAGS_CMD;
d1371 1
d1394 1
d1401 1
d1406 1
a1406 1
	xa->fis->flags = ATA_H2D_FLAGS_CMD;
d1418 1
d1432 1
d1434 1
d1439 1
d1445 1
a1445 1
	fis->flags = ATA_H2D_FLAGS_CMD;
d1497 64
d1576 3
a1578 3
	struct atascsi_port	*ap = cookie;
	struct atascsi		*as = ap->ap_as;
	struct ata_xfer		*xa;
d1580 1
a1580 1
	xa = as->as_methods->ata_get_xfer(as->as_cookie, ap->ap_port);
a1645 1

@


1.98
log
@clean up cases of ;;
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.97 2010/10/12 00:53:32 krw Exp $ */
d1189 1
a1189 1
	 * A SCSI START_STOP UNIT command with the START bit set to
d1239 1
@


1.97
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.96 2010/09/23 11:44:22 dlg Exp $ */
d786 1
a786 1
	xa->datalen = xs->datalen;;
@


1.96
log
@translate WRITE SAME 16 into DSM TRIM.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.95 2010/09/20 06:17:49 krw Exp $ */
d599 1
@


1.95
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.94 2010/09/20 06:02:50 dlg Exp $ */
d61 1
d88 2
d284 4
d427 4
d749 84
d1004 1
a1004 2
	if (ISSET(letoh16(ap->ap_identify.data_set_mgmt), 
	    ATA_ID_DATA_SET_MGMT_TRIM)) {
@


1.94
log
@define and use macros for looking at ncq bits.

requested by and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.93 2010/09/19 23:13:02 dlg Exp $ */
d1069 1
a1069 1
	sd->error_code = 0x70; /* XXX magic */
@


1.93
log
@move the ncq depth calculation into atascsi_probe where it belongs. by
default we now only give devices 1 openings unless both the adapter and
device support ncq and a queue depth greater than one.

tested by josh elsasser, who always seems to get hurt when i change the
openings handling in atascsi.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.92 2010/09/19 12:08:27 dlg Exp $ */
d255 2
a256 2
	    (letoh16(ap->ap_identify.satacap) & (1 << 8))) {
		qdepth = (letoh16(ap->ap_identify.qdepth) & 0x1f) + 1;
@


1.92
log
@check the cdb length on the scsi commands we emulate in atascsi as a way to
check that the midlayer is doing the right thing.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.91 2010/09/02 11:54:44 dlg Exp $ */
d50 1
d60 1
a60 2
#define ATA_PORT_F_PROBED	1
	int			ap_ncqdepth;
d130 1
d143 1
a143 3
	as->as_link.openings = aaa->aaa_ncmds;
	if (as->as_capability & ASAA_CAP_NEEDS_RESERVED)
		as->as_link.openings--;
d192 1
a192 1
	int			port, type;
d254 27
d471 2
a472 1
	if (ap->ap_ncqdepth && !(xs->flags & SCSI_POLL)) {
a580 1
	struct ata_xfer		*xa;
a596 35

	if (ap->ap_features & ATA_PORT_F_PROBED)
		return;

	ap->ap_features = ATA_PORT_F_PROBED;

	if (as->as_capability & ASAA_CAP_NCQ &&
	    (letoh16(ap->ap_identify.satacap) & (1 << 8))) {
		int host_ncqdepth;
		/*
		 * At this point, openings should be the number of commands the
		 * host controller supports, less any reserved slot the host
		 * controller needs for recovery.
		 */
		host_ncqdepth = link->openings +
		    ((as->as_capability & ASAA_CAP_NEEDS_RESERVED) ? 1 : 0);

		ap->ap_ncqdepth = (letoh16(ap->ap_identify.qdepth) & 0x1f) + 1;

		/* Limit the number of openings to what the device supports. */
		if (host_ncqdepth > ap->ap_ncqdepth)
			link->openings -= (host_ncqdepth - ap->ap_ncqdepth);

		/*
		 * XXX throw away any xfers that have tag numbers higher than
		 * what the device supports.
		 */
		while (host_ncqdepth--) {
			xa = scsi_io_get(&ap->ap_iopool, SCSI_NOSLEEP);
			if (xa->tag < ap->ap_ncqdepth) {
				xa->state = ATA_S_COMPLETE;
				scsi_io_put(&ap->ap_iopool, xa);
			}
		}
	}
@


1.91
log
@the page_length field in the vpd page header is 2 bytes, not 1.

ok krw@@ marco@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.90 2010/07/27 04:41:56 matthew Exp $ */
d517 5
d753 5
d876 5
d904 5
d975 5
d1010 5
d1091 5
@


1.90
log
@Add scsi_cmd_rw_decode() for decoding any SCSI READ or WRITE command,
and update atascsi(4) to make use of it.  (Other HBAs will be updated
post-release.)  Should allow for use of SATA drives with >2^32 LBAs.

ok deraadt@@, dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.89 2010/07/20 01:06:54 deraadt Exp $ */
d615 1
a615 1
	pg.hdr.page_length = sizeof(pg.list);
d639 1
a639 1
	pg.hdr.page_length = sizeof(ap->ap_identify.serial);
d691 1
a691 1
	pg.hdr.page_length = pg_len;
d710 1
a710 1
	pg.hdr.page_length = SI_PG_DISK_LIMITS_LEN_THIN;
d731 1
a731 1
	pg.hdr.page_length = sizeof(pg) - sizeof(pg.hdr);
@


1.89
log
@Do not put a data buffer on the stack.  It will be dma'd to.  Use
malloc() for now, but mark it is dma reachable, and we will pick it up
on the sweep in a while
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.88 2010/07/03 00:41:58 kettenis Exp $ */
a374 2
	struct scsi_rw		*rw;
	struct scsi_rw_big	*rwb;
d380 1
d382 2
a383 1
	case READ_COMMAND:
d386 1
d388 2
a389 1
	case WRITE_COMMAND:
d432 4
a435 8
	if (xs->cmdlen == 6) {
		rw = (struct scsi_rw *)xs->cmd;
		lba = _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);
		sector_count = rw->length ? rw->length : 0x100;
	} else {
		rwb = (struct scsi_rw_big *)xs->cmd;
		lba = _4btol(rwb->addr);
		sector_count = _2btol(rwb->length);
@


1.88
log
@Implement translation of the SCSI START STOP UNIT command.

ok dlg@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.87 2010/06/28 18:31:01 krw Exp $ */
d192 1
d230 3
a232 2
	xa->data = &ap->ap_identify;
	xa->datalen = sizeof(ap->ap_identify);
d243 2
a244 1
	if (rv != 0)
d246 3
@


1.87
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.86 2010/06/19 21:43:16 krw Exp $ */
d92 2
d409 4
a413 1
	case START_STOP:
d1048 78
@


1.86
log
@Remove more splbio/splx pairs from around scsi_done() calls.

From Matthew Dempsky.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.85 2010/05/26 12:17:35 dlg Exp $ */
a75 4
struct scsi_device atascsi_device = {
	NULL, NULL, NULL, NULL
};

a134 1
	as->as_link.device = &atascsi_device;
@


1.85
log
@the addr field in read cap 16 is 8 bytes, not 4. pity, i had really big
disks for a few minutes there.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.84 2010/05/05 11:33:26 dlg Exp $ */
a1131 2
	int			s;

a1132 2

	s = splbio();
a1133 1
	splx(s);
@


1.84
log
@map the ATA data set management stuff (ie, trim) to the SCSI thin
provisioning bits in read cap 16
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.83 2010/04/29 22:28:39 krw Exp $ */
d887 1
a887 1
	_lto4b(ata_identify_blocks(&ap->ap_identify), rcd.addr);
@


1.83
log
@Revert r1.80, leaving iopools in place. Fixes PR#6365. Why WD3200KS-00P
disks on ATI SBx00 care is mysterious but let's keep them working.

Fix tested by Josh Elsasser, submitter of PR#6365. Thanks!

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.82 2010/04/23 01:39:05 dlg Exp $ */
d883 1
d892 11
a902 1
		_lto2b((1 << rcd.logical_per_phys) - align, rcd.lowest_aligned);
@


1.82
log
@the SAT spec from t10.org defines messages for tunnelling ATA commands over
SCSI when you're talking to a scsi to ata translation layer (satl). this
implements the ata command ioctl handler in scsi_ioctl.c that wraps the
ata command requests up in these scsi commands and then issues them against
the hardware. this cuts atascsi over to interpreting these scsi commands
rather than the ioctls directly.

this should allow mpi users (with a relatively recent firmware) to use
atactl against their SATA disks. i cant test cos my mpi(4) parts are too
old to either support these scsi commands or too old to take recent
firmwares.

ok marco@@ @@krw tested by krw@@ and me on ahci/atascsi
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.81 2010/04/22 00:58:32 dlg Exp $ */
d58 2
a248 30
	if (as->as_capability & ASAA_CAP_NCQ &&
	    (letoh16(ap->ap_identify.satacap) & (1 << 8))) {
		int host_ncqdepth;
		/*
		 * At this point, openings should be the number of commands the
		 * host controller supports, less any reserved slot the host
		 * controller needs for recovery.
		 */
		host_ncqdepth = link->openings +
		    ((as->as_capability & ASAA_CAP_NEEDS_RESERVED) ? 1 : 0);

		ap->ap_ncqdepth = (letoh16(ap->ap_identify.qdepth) & 0x1f) + 1;

		/* Limit the number of openings to what the device supports. */
		if (host_ncqdepth > ap->ap_ncqdepth)
			link->openings -= (host_ncqdepth - ap->ap_ncqdepth);

		/*
		 * XXX throw away any xfers that have tag numbers higher than
		 * what the device supports.
		 */
		while (host_ncqdepth--) {
			xa = scsi_io_get(&ap->ap_iopool, SCSI_NOSLEEP);
			if (xa->tag < ap->ap_ncqdepth) {
				xa->state = ATA_S_COMPLETE;
				scsi_io_put(&ap->ap_iopool, xa);
			}
		}
	}

d541 1
d545 1
a545 1
	struct scsi_inquiry_data inq;
d562 35
@


1.81
log
@cut atascsi over to providing and using iopools. this gets rid of NO_CCB
and makes the ioctl path more reliable on busy disks by allowing it to
sleep in the runqueue for an io to use.

mk@@ did the original diff and figured most of the problems out. ok mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.80 2010/04/19 10:52:15 dlg Exp $ */
a61 2
int		atascsi_ioctl(struct scsi_link *, u_long, caddr_t, int,
		    struct proc *);
d71 1
a71 1
	atascsi_ioctl		/* ioctl */
d98 5
d433 7
d890 128
a1119 90
}

int atascsi_ioctl_cmd(struct atascsi *, struct atascsi_port *, atareq_t *);
void atascsi_ioctl_done(struct ata_xfer *);

int
atascsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flags,
    struct proc *p)
{
	struct atascsi		*as = link->adapter_softc;
	struct atascsi_port	*ap = as->as_ports[link->target];

	switch (cmd) {
	case ATAIOCCOMMAND:
		return (atascsi_ioctl_cmd(as, ap, (atareq_t *)addr));
	default:
		return (ENOTTY);
	}
}

int
atascsi_ioctl_cmd(struct atascsi *as, struct atascsi_port *ap, atareq_t *atareq)
{
	struct ata_xfer		*xa;
	struct ata_fis_h2d	*fis;
	void			*buf;
	int			 rc = 0;
	int			 s;

	xa = scsi_io_get(&ap->ap_iopool, 0);

	fis = xa->fis;
	fis->flags = ATA_H2D_FLAGS_CMD;
	fis->command = atareq->command;
	fis->features = atareq->features;
	fis->lba_low = atareq->sec_num;
	fis->lba_mid = atareq->cylinder;
	fis->lba_high = atareq->cylinder >> 8;
	fis->device = atareq->head & 0x0f;
	fis->sector_count = atareq->sec_count;

	buf = malloc(atareq->datalen, M_TEMP, M_WAITOK);

	xa->data = buf;
	xa->datalen = atareq->datalen;
	xa->complete = atascsi_ioctl_done;
	xa->timeout = atareq->timeout;
	xa->flags = 0;
	if (atareq->flags & ATACMD_READ)
		xa->flags |= ATA_F_READ;
	if (atareq->flags & ATACMD_WRITE) {
		xa->flags |= ATA_F_WRITE;
		copyin(atareq->databuf, buf, atareq->datalen);
	}
	xa->atascsi_private = NULL;

	as->as_methods->ata_cmd(xa);
	s = splbio();
	while (!ISSET(xa->flags, ATA_F_DONE))
		tsleep(xa, PRIBIO, "atascsi", 0);
	splx(s);

	switch (xa->state) {
	case ATA_S_COMPLETE:
		atareq->retsts = ATACMD_OK;
		if (atareq->flags & ATACMD_READ)
			rc = copyout(buf, atareq->databuf, atareq->datalen);
		break;
	case ATA_S_ERROR:
		atareq->retsts = ATACMD_ERROR;
		break;
	case ATA_S_TIMEOUT:
		atareq->retsts = ATACMD_TIMEOUT;
		break;
	default:
		panic("atascsi_ioctl_cmd: unexpected ata_xfer state (%d)",
		    xa->state);
	}

	free(buf, M_TEMP);

	scsi_io_put(&ap->ap_iopool, xa);

	return (rc);
}

void
atascsi_ioctl_done(struct ata_xfer *xa)
{
	wakeup(xa);
@


1.80
log
@move the stupid throwing away of ata_xfers out the run of the first scsi
inquiry against the device up to when the port is probed. this has been
bugging me for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.79 2010/04/05 04:11:06 dlg Exp $ */
d36 2
d42 1
a42 1
	struct ata_port		**as_ports;
d52 9
a103 3
struct ata_xfer	*ata_get_xfer(struct ata_port *);
void		ata_put_xfer(struct ata_xfer *);

d112 3
d144 1
a144 1
	as->as_ports = malloc(sizeof(struct ata_port *) * aaa->aaa_nports,
d188 1
a188 1
	struct ata_port		*ap;
d220 3
d224 1
a224 1
	xa = ata_get_xfer(ap);
d236 1
d266 1
a266 1
			xa = ata_get_xfer(ap);
d269 1
a269 1
				ata_put_xfer(xa);
d281 1
a281 1
		xa = ata_get_xfer(ap);
d290 1
d297 1
a297 1
		xa = ata_get_xfer(ap);
d306 1
d318 1
a318 1
	xa = ata_get_xfer(ap);
d326 1
d342 1
a342 1
	struct ata_port		*ap;
d367 1
a367 1
	struct ata_port		*ap = as->as_ports[link->target];
d394 2
a395 1
	struct ata_port		*ap = as->as_ports[link->target];
a398 1
	struct ata_xfer		*xa;
a440 6
	xa = ata_get_xfer(ap);
	if (xa == NULL) {
		atascsi_done(xs, XS_NO_CCB);
		return;
	}

a521 1
	ata_put_xfer(xa);
d561 1
a561 1
	struct ata_port		*ap = as->as_ports[link->target];
d610 1
a610 1
	struct ata_port		*ap = as->as_ports[link->target];
d631 1
a631 1
	struct ata_port		*ap = as->as_ports[link->target];
d682 1
a682 1
	struct ata_port		*ap = as->as_ports[link->target];
d703 1
a703 1
	struct ata_port		*ap = as->as_ports[link->target];
d724 1
a724 8
	struct ata_port		*ap = as->as_ports[link->target];
	struct ata_xfer		*xa;

	xa = ata_get_xfer(ap);
	if (xa == NULL) {
		atascsi_done(xs, XS_NO_CCB);
		return;
	}
a764 2
	ata_put_xfer(xa);

d840 1
a840 1
	struct ata_port		*ap = as->as_ports[link->target];
d862 1
a862 1
	struct ata_port		*ap = as->as_ports[link->target];
d898 1
a898 2
	struct ata_port		*ap = as->as_ports[link->target];
	struct ata_xfer		*xa;
a900 6
	xa = ata_get_xfer(ap);
	if (xa == NULL) {
		atascsi_done(xs, XS_NO_CCB);
		return;
	}

a967 1
	ata_put_xfer(xa);
d984 1
a984 1
int atascsi_ioctl_cmd(struct atascsi *, struct ata_port *, atareq_t *);
d992 1
a992 1
	struct ata_port		*ap = as->as_ports[link->target];
d1003 1
a1003 1
atascsi_ioctl_cmd(struct atascsi *as, struct ata_port *ap, atareq_t *atareq)
d1011 1
a1011 3
	xa = ata_get_xfer(ap);
	if (xa == NULL)
		return (ENOMEM);
d1063 1
a1063 1
	ata_put_xfer(xa);
d1080 2
a1081 2
struct ata_xfer *
ata_get_xfer(struct ata_port *ap)
d1083 1
d1095 1
a1095 1
ata_put_xfer(struct ata_xfer *xa)
d1097 3
d1130 1
a1130 1
	ata_put_xfer(xa);
@


1.79
log
@fill in the the lowest aligned logical block address field. it
indicates the LBA of the first logical block that is located at the
beginning of a physical block

implemented as best as i can by my understanding of the spec. not tested
yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.78 2010/04/05 01:47:54 dlg Exp $ */
d229 30
a567 37

	if (ap->ap_features & ATA_PORT_F_PROBED)
		return;

	ap->ap_features = ATA_PORT_F_PROBED;

	if (as->as_capability & ASAA_CAP_NCQ &&
	    (letoh16(ap->ap_identify.satacap) & (1 << 8))) {
		int host_ncqdepth;
		/*
		 * At this point, openings should be the number of commands the
		 * host controller supports, less any reserved slot the host
		 * controller needs for recovery.
		 */
		host_ncqdepth = link->openings +
		    ((as->as_capability & ASAA_CAP_NEEDS_RESERVED) ? 1 : 0);

		ap->ap_ncqdepth = (letoh16(ap->ap_identify.qdepth) & 0x1f) + 1;

		/* Limit the number of openings to what the device supports. */
		if (host_ncqdepth > ap->ap_ncqdepth)
			link->openings -= (host_ncqdepth - ap->ap_ncqdepth);

		/*
		 * XXX throw away any xfers that have tag numbers higher than
		 * what the device supports.
		 */
		while (host_ncqdepth--) {
			struct ata_xfer *xa;

			xa = ata_get_xfer(ap);
			if (xa->tag < ap->ap_ncqdepth) {
				xa->state = ATA_S_COMPLETE;
				ata_put_xfer(xa);
			}
		}
	}
@


1.78
log
@populate the logical per physical exponent of the read cap 16 reply by
factoring the processing that the limits vpd page does out.

this will be easier when i get hold of a disk that does provide values in
these ata identify fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.77 2010/04/05 00:59:31 dlg Exp $ */
d102 1
d825 15
d869 1
d876 3
@


1.77
log
@add support for READ_CAPACITY_16.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.76 2010/04/05 00:55:03 dlg Exp $ */
d101 1
a678 1
	u_int16_t		p2l_sect;
d685 2
a686 7
	p2l_sect = letoh16(ap->ap_identify.p2l_sect);
	if ((p2l_sect & ATA_ID_P2L_SECT_MASK) == ATA_ID_P2L_SECT_VALID &&
	    ISSET(p2l_sect, ATA_ID_P2L_SECT_SET)) {
		_lto2b(2 << (p2l_sect & SI_PG_DISK_LIMITS_LEN_THIN),
		    pg.optimal_xfer_granularity);
	} else
		_lto2b(1, pg.optimal_xfer_granularity);
d810 14
d858 1
@


1.76
log
@add support for ata disks with block sizes other than 512 bytes. i havent
ever seen one, but the spec describes how to do it.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.75 2010/04/03 09:35:48 dlg Exp $ */
d81 1
d376 3
d830 18
@


1.75
log
@byteswap the cmdset word properly so we enable the right features on
bigendian archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.74 2010/04/03 09:32:14 dlg Exp $ */
d98 3
d773 2
a774 2
void
atascsi_disk_capacity(struct scsi_xfer *xs)
d776 1
a776 6
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct ata_port		*ap = as->as_ports[link->target];
	struct ata_identify	*id = &ap->ap_identify;
	struct scsi_read_cap_data rcd;
	u_int64_t		capacity = 0;
a778 1
	bzero(&rcd, sizeof(rcd));
d782 2
a783 2
			capacity <<= 16;
			capacity += letoh16(id->addrsecxt[i]);
d786 3
a788 3
		capacity = letoh16(id->addrsec[1]);
		capacity <<= 16;
		capacity += letoh16(id->addrsec[0]);
d791 31
d825 2
a826 2
	_lto4b(capacity - 1, rcd.addr);
	_lto4b(512, rcd.length);
@


1.74
log
@remove some debug output
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.73 2010/04/03 07:09:29 dlg Exp $ */
d175 1
d226 2
d229 1
a229 1
	if (ap->ap_identify.cmdset82 & ATA_IDENTIFY_WRITECACHE) {
d244 1
a244 1
	if (ap->ap_identify.cmdset82 & ATA_IDENTIFY_LOOKAHEAD) {
@


1.73
log
@add support for emulating the disk characteristics and disk limits vpd
pages. this if the first step in figuring out if disks use a different
physical block size compared to the logical block size they present to the
operating system.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.72 2010/03/23 01:57:19 krw Exp $ */
a223 2

	printf("106: 0x%04x\n", ap->ap_identify.p2l_sect);
@


1.72
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.71 2010/01/09 23:15:06 krw Exp $ */
d78 2
d225 2
d491 6
d572 1
a572 1
		u_int8_t		list[3];
d583 2
d659 48
@


1.71
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.70 2009/12/08 10:18:11 dlg Exp $ */
d50 1
a50 1
int		atascsi_cmd(struct scsi_xfer *);
d303 1
a303 1
int
d312 1
a312 1
		return (COMPLETE);
a327 2

	return (COMPLETE);
@


1.70
log
@the ata identify structure is stupid. its full of buffers you have
to swap to use.

this diff doesnt swap fields the identify structure when its fetched, but
adds a function that swaps them and copies them into a destination buffer.
there is no functional change to the existing users of these fields,
specifically the scsi inquiry faker and the device serial vpd page.

this does fix the devid vpd page though. if a disk has a wwn we now present
it correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.69 2009/12/08 08:07:51 dlg Exp $ */
a469 1
	xs->flags |= ITSDONE;
a707 1
	xs->flags |= ITSDONE;
a842 1
	xs->flags |= ITSDONE;
@


1.69
log
@krw and marco found another problem with my atascsi chanages.

turns out you cant send atapi devices the ata IDENTIFY command, they dont
grok it. you have to send a PACKET IDENTIFY instead, which is exactly the
same but with a different command id.

this diff changes it so we send a PACKET IDENTIFY to atapi devices.

my diff "broke" this because it actually checks to see if the IDENTIFY
succeeded rather than just completed. the previous code was wrong with
regard to atapi devices. it is just lucky we dont use the IDENTIFY output
for atapi devs.

my apologies to marco@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.68 2009/12/07 12:36:23 dlg Exp $ */
d69 1
a69 1
void		ata_fix_identify(struct ata_identify *);
a217 2
	ata_fix_identify(&ap->ap_identify);

a302 19
void
ata_fix_identify(struct ata_identify *id)
{
	u_int16_t		*swap;
	int			i;

	swap = (u_int16_t *)id->serial;
	for (i = 0; i < sizeof(id->serial) / sizeof(u_int16_t); i++)
		swap[i] = swap16(swap[i]);

	swap = (u_int16_t *)id->firmware;
	for (i = 0; i < sizeof(id->firmware) / sizeof(u_int16_t); i++)
		swap[i] = swap16(swap[i]);

	swap = (u_int16_t *)id->model;
	for (i = 0; i < sizeof(id->model) / sizeof(u_int16_t); i++)
		swap[i] = swap16(swap[i]);
}

d513 4
a516 2
	bcopy(ap->ap_identify.model, inq.product, sizeof(inq.product));
	bcopy(ap->ap_identify.firmware, inq.revision, sizeof(inq.revision));
d595 1
a595 1
	bcopy(ap->ap_identify.serial, pg.serial,
d618 1
a618 1
	if (ap->ap_identify.features87 & ATA_ID_F87_WWN) {
d624 1
a624 2
		/* XXX ata_identify field(s) should be renamed */
		bcopy(&ap->ap_identify.naa_ieee_oui, pg.devid, pg_len);
d634 1
a634 1
		bcopy(ap->ap_identify.model, p,
d637 1
a637 1
		bcopy(ap->ap_identify.serial, p,
d1016 13
@


1.68
log
@oops, wrong version of previous diff.

we have to exec a command (with ata_exec) before we check if its done with
ata_polled. of course an unstarted command will not be done.

found by and debugged with krw@@
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.67 2009/12/07 09:37:34 dlg Exp $ */
d207 2
a208 1
	xa->fis->command = ATA_C_IDENTIFY;
@


1.67
log
@get rid of the return codes from command submission, ata_cmd handlers
now return void. all state about a command is now represented within
the ata_xfer structure, and all layers using it (both hba and
atascsi) now check only ata_xfer.

this relies on my scsi midlayer changes. it was written just before
the second last backout of the midlayer.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.66 2009/10/22 07:59:26 dlg Exp $ */
d212 1
d235 1
d250 1
d269 1
@


1.66
log
@gc unused global
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.64 2009/02/16 21:19:06 miod Exp $ */
d71 1
a71 1
int		atascsi_disk_cmd(struct scsi_xfer *);
d73 7
a79 7
int		atascsi_disk_inq(struct scsi_xfer *);
int		atascsi_disk_inquiry(struct scsi_xfer *);
int		atascsi_disk_vpd_supported(struct scsi_xfer *);
int		atascsi_disk_vpd_serial(struct scsi_xfer *);
int		atascsi_disk_vpd_ident(struct scsi_xfer *);
int		atascsi_disk_capacity(struct scsi_xfer *);
int		atascsi_disk_sync(struct scsi_xfer *);
d81 1
a81 1
int		atascsi_disk_sense(struct scsi_xfer *);
d83 1
a83 1
int		atascsi_atapi_cmd(struct scsi_xfer *);
d86 1
a86 1
int		atascsi_done(struct scsi_xfer *, int);
d88 1
a88 1
int		ata_exec(struct atascsi *, struct ata_xfer *);
d93 3
a209 1
	xa->complete = ata_put_xfer;
d211 3
a213 2
	if (ata_exec(as, xa) != COMPLETE) {
		rv = EIO;
a214 1
	}
a231 1
		xa->complete = ata_put_xfer;
d233 2
a234 1
		ata_exec(as, xa); /* we dont care if this works or not */
a245 1
		xa->complete = ata_put_xfer;
d247 2
a248 1
		ata_exec(as, xa); /* we dont care if this works or not */
a263 1
	xa->complete = ata_put_xfer;
d265 2
a266 1
	ata_exec(as, xa); /* we dont care if this works or not */
d326 4
a329 2
	if (ap == NULL)
		return (atascsi_done(xs, XS_DRIVER_STUFFUP));
d333 2
a334 1
		return (atascsi_disk_cmd(xs));
d336 2
a337 1
		return (atascsi_atapi_cmd(xs));
d341 2
a342 1
		return (atascsi_done(xs, XS_DRIVER_STUFFUP));
d344 2
d348 1
a348 1
int
d374 2
a375 1
		return (atascsi_disk_sync(xs));
d377 2
a378 1
		return (atascsi_disk_sense(xs));
d380 2
a381 1
		return (atascsi_disk_inq(xs));
d383 2
a384 1
		return (atascsi_disk_capacity(xs));
d389 2
a390 1
		return (atascsi_done(xs, XS_NOERROR));
d393 2
a394 1
		return (atascsi_done(xs, XS_DRIVER_STUFFUP));
d398 4
a401 2
	if (xa == NULL)
		return (NO_CCB);
d459 1
a459 1
	return (ata_exec(as, xa));
d490 1
a490 1
int
d498 2
a499 1
			return (atascsi_disk_vpd_supported(xs));
d501 2
a502 1
			return (atascsi_disk_vpd_serial(xs));
d504 2
a505 1
			return (atascsi_disk_vpd_ident(xs));
d507 2
a508 1
			return (atascsi_done(xs, XS_DRIVER_STUFFUP));
d510 2
a511 3
	}

	return (atascsi_disk_inquiry(xs));
d514 1
a514 1
int
a520 1
	int			rv;
d534 1
a534 1
	rv = atascsi_done(xs, XS_NOERROR);
d537 1
a537 1
		return (rv);
a571 2

	return (rv);
d574 1
a574 1
int
d593 1
a593 1
	return (atascsi_done(xs, XS_NOERROR));
d596 1
a596 1
int
d614 1
a614 1
	return (atascsi_done(xs, XS_NOERROR));
d617 1
a617 1
int
d666 1
a666 1
	return (atascsi_done(xs, XS_NOERROR));
d669 1
a669 1
int
d678 4
a681 2
	if (xa == NULL)
		return (NO_CCB);
d696 1
a696 1
	return (ata_exec(as, xa));
d728 1
a728 1
int
d760 1
a760 1
	return (atascsi_done(xs, XS_NOERROR));
d763 1
a763 1
int
d773 1
a773 1
	return (atascsi_done(xs, XS_NOERROR));
d776 1
a776 1
int
d786 4
a789 2
	if (xa == NULL)
		return (NO_CCB);
d823 1
a823 1
	return (ata_exec(as, xa));
d864 1
a864 1
int
a869 1
	xs->flags |= ITSDONE;
a873 1
	return (COMPLETE);
d901 1
d932 5
a936 15
	switch (as->as_methods->ata_cmd(xa)) {
	case ATA_COMPLETE:
		break;
	case ATA_QUEUED:
		while (xa->state == ATA_S_PENDING || xa->state == ATA_S_ONCHIP)
			tsleep(xa, PRIBIO, "atascsi", 0);
		break;
	case ATA_ERROR:
		free(buf, M_TEMP);
		ata_put_xfer(xa);
		atareq->retsts = ATACMD_ERROR;
		return (EIO);
	default:
		panic("atascsi_ioctl_cmd: unexpected return from ata_cmd");
	}
d968 1
a968 1
int
d971 1
a971 12
	int polled = xa->flags & ATA_F_POLL;

	switch (as->as_methods->ata_cmd(xa)) {
	case ATA_COMPLETE:
	case ATA_ERROR:
		return (COMPLETE);
	case ATA_QUEUED:
		if (!polled)
			return (SUCCESSFULLY_QUEUED);
	default:
		panic("unexpected return from ata_exec");
	}
d991 39
@


1.65
log
@Unchecked copyout() calls cause premature death in furry animals, so
check their return values in the ATA_S_COMPLETE ioctl handler.
dlg@@ agrees.
@
text
@a87 2
int		ata_running = 0;

@


1.64
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.63 2008/09/25 11:00:48 krw Exp $ */
d883 1
d934 1
a934 1
			copyout(buf, atareq->databuf, atareq->datalen);
d951 1
a951 1
	return (0);
@


1.63
log
@Initialize 'capacity' to 0 and use tabs to indent. "won't hurt" miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.62 2008/05/05 12:19:38 krw Exp $ */
d59 1
a59 1
	minphys,		/* scsi_minphys */
d110 2
a111 1
	as->as_switch.scsi_minphys = aaa->aaa_minphys;
@


1.62
log
@Don't set the adaptor template link's flags and quirks when trying to
set the flags and quirks for a device. Should fix weird issues where
the device after an ATAPI device gets marked as ATAPI.  First reported
on misc@@ by Daniel Wade, who also provided some useful testing.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.61 2008/03/26 14:00:28 dlg Exp $ */
d717 2
a718 2
        struct scsi_read_cap_data rcd;
        u_int64_t		capacity;
@


1.61
log
@plug a mem leak. the array of ports wasnt freed on detach.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.59 2007/12/29 00:45:26 dlg Exp $ */
d185 2
a186 2
		as->as_link.flags |= SDEV_ATAPI;
		as->as_link.quirks |= SDEV_ONLYBIG;
@


1.60
log
@dont freeze lock or set caching modes on ata devices that arent disks, its
not a good idea.

found by simon@@ who plugged a sata dvd drive into ahci.
@
text
@d145 1
@


1.59
log
@the scsi layer always had function pointers for asking the hba about a
device before issuing scsi commands to it, but it was never implemented,
never used, and no hba actually filled them in. i came along and added
another two function pointers for the same thing.

this cleans up the extra pointers.

ok krw@@ marco@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.58 2007/12/28 16:38:23 dlg Exp $ */
d217 3
@


1.58
log
@provide vpd page 0, which lists which vpd pages we provide.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.57 2007/12/28 16:30:08 dlg Exp $ */
a59 3
	NULL,
	NULL,
	atascsi_ioctl,		/* ioctl */
d61 2
a62 1
	atascsi_free		/* dev_free */
@


1.57
log
@rename some functions to make it clear theyre used to emulate vpd responses
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.56 2007/12/28 16:21:06 dlg Exp $ */
d77 1
d479 2
d554 22
@


1.56
log
@implement emulation of vpd page 83, the device identification page. if the
disk provides a wwn, use it, otherwise do our best to generate an id from
the model and serial number.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.54 2007/12/09 01:30:59 dlg Exp $ */
d77 2
a78 2
int		atascsi_disk_serial(struct scsi_xfer *);
int		atascsi_disk_ident(struct scsi_xfer *);
d479 1
a479 1
			return (atascsi_disk_serial(xs));
d481 1
a481 1
			return (atascsi_disk_ident(xs));
d554 1
a554 1
atascsi_disk_serial(struct scsi_xfer *xs)
d575 1
a575 1
atascsi_disk_ident(struct scsi_xfer *xs)
@


1.55
log
@massage the way vpds are defined. rename the page used for the devices
serial number and split the vpd header out for use in other places. while
here define the device identification page bits too.

ok krw@@ marco@@
@
text
@d78 1
d480 2
d570 52
@


1.54
log
@unify synchronous scsi xfer completion handling. this started out as a fix
to the completions for some scsi commands we simply ack in the disk_cmd
handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.53 2007/12/09 01:05:09 dlg Exp $ */
d556 1
a556 1
	struct scsi_inquiry_vpd	vpd;
d558 1
a558 1
	bzero(&vpd, sizeof(vpd));
d560 4
a563 4
	vpd.device = T_DIRECT;
	vpd.page_code = SI_PG_SERIAL;
	vpd.page_length = sizeof(ap->ap_identify.serial);
	bcopy(ap->ap_identify.serial, vpd.serial,
d566 1
a566 1
	bcopy(&vpd, xs->data, MIN(sizeof(vpd), xs->datalen));
@


1.53
log
@remove the nosleep argument to ata_get_xfer. it is a relic from when i
used to allocated xfers out of a pool rather than as part of the hbas ccb
structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.52 2007/12/06 12:19:01 jsg Exp $ */
d86 1
a86 1
int		atascsi_stuffup(struct scsi_xfer *);
d322 1
a322 1
		return (atascsi_stuffup(xs));
d332 1
a332 1
		return (atascsi_stuffup(xs));
d373 1
a373 1
		return (COMPLETE);
d376 1
a376 1
		return (atascsi_stuffup(xs));
d480 1
a480 1
			return (atascsi_stuffup(xs));
d494 1
a494 1
	int			s;
d508 1
a508 5
	xs->error = XS_NOERROR;
	xs->flags |= ITSDONE;
	s = splbio();
	scsi_done(xs);
	splx(s);
d511 1
a511 1
		return (COMPLETE);
d547 1
a547 1
	return (COMPLETE);
a556 1
	int			s;
a566 5
	xs->error = XS_NOERROR;
	xs->flags |= ITSDONE;
	s = splbio();
	scsi_done(xs);
	splx(s);
d568 1
a568 1
	return (COMPLETE);
a637 1
	int			s;
a658 5
	xs->error = XS_NOERROR;
	xs->flags |= ITSDONE;
	s = splbio();
	scsi_done(xs);
	splx(s);
d660 1
a660 1
	return (COMPLETE);
a666 1
	int			s;
d673 1
a673 7
	xs->error = XS_NOERROR;
	xs->flags |= ITSDONE;

	s = splbio();
	scsi_done(xs);
	splx(s);
	return (COMPLETE);
d763 1
a763 1
atascsi_stuffup(struct scsi_xfer *xs)
d767 1
a767 1
	xs->error = XS_DRIVER_STUFFUP;
@


1.52
log
@Ask for write cache and read look ahead to be turned
on if supported as per the wd changes.  Some drives don't
do this for us and it helps performance by a large amount.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.51 2007/11/28 18:16:07 dlg Exp $ */
d92 1
a92 1
struct ata_xfer	*ata_get_xfer(struct ata_port *, int);
d198 1
a198 1
	xa = ata_get_xfer(ap, 1);
d220 1
a220 1
		xa = ata_get_xfer(ap, 1);
d234 1
a234 1
		xa = ata_get_xfer(ap, 1);
d253 1
a253 1
	xa = ata_get_xfer(ap, 1);
d379 1
a379 1
	xa = ata_get_xfer(ap, xs->flags & SCSI_NOSLEEP);
d543 1
a543 1
			xa = ata_get_xfer(ap, 1);
d589 1
a589 1
	xa = ata_get_xfer(ap, xs->flags & SCSI_NOSLEEP);
d708 1
a708 1
	xa = ata_get_xfer(ap, xs->flags & SCSI_NOSLEEP);
d824 1
a824 1
	xa = ata_get_xfer(ap, 0);
d917 1
a917 1
ata_get_xfer(struct ata_port *ap, int nosleep /* XXX unused */)
@


1.51
log
@when we probe a port send an ata inquiry to the device and cache
the result in the ata_port struct. use this cached inquiry data
when building the replies to scsi commands rather than fetching a
new copy of ata inq every time.

this shrinks the code by 100 lines. it also avoids a malloc in a
scsi io path, which could be issued at a time when malloc isnt
guaranteed to succeed, but a real scsi io definitely should.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.50 2007/11/28 13:47:09 dlg Exp $ */
d217 28
@


1.50
log
@make ata controllers protect their own command lists so atascsi doesnt have
to continually go to splbio to ensure its safe to work on them. shrinks
code a little.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.49 2007/11/26 20:13:53 dlg Exp $ */
d71 1
a71 4
struct ata_xfer *ata_setup_identify(struct ata_port *, int);
void		ata_free_identify(struct ata_xfer *);
void		ata_complete_identify(struct ata_xfer *,
		    struct ata_identify *);
d76 2
a77 2
void		atascsi_disk_inq_done(struct ata_xfer *);
void		atascsi_disk_serial_done(struct ata_xfer *);
a78 1
void		atascsi_disk_capacity_done(struct ata_xfer *);
a82 2
void		atascsi_empty_done(struct ata_xfer *);

a87 1

d169 1
d188 2
a189 1
		return (ENODEV);
d197 1
a197 2
	as->as_ports[port] = ap;

d200 17
a216 1
		return (EBUSY);
d225 3
d230 2
a231 2
	xa->complete = atascsi_empty_done;
	xa->flags = ATA_F_POLL | ATA_F_PIO;
d233 1
a233 1
	ata_exec(as, xa);
d236 5
a266 27
struct ata_xfer *
ata_setup_identify(struct ata_port *ap, int nosleep)
{
	struct ata_xfer		*xa;

	xa = ata_get_xfer(ap, nosleep);
	if (xa == NULL)
		return (NULL);

	xa->data = malloc(512, M_TEMP, nosleep ? (M_NOWAIT | M_ZERO) :
	    (M_WAITOK | M_ZERO));
	if (xa->data == NULL) {
		xa->state = ATA_S_ERROR;
		ata_put_xfer(xa);
		return (NULL);
	}
	xa->datalen = 512;

	xa->fis->flags = ATA_H2D_FLAGS_CMD;
	xa->fis->command = ATA_C_IDENTIFY;
	xa->fis->device = 0;

	xa->flags = ATA_F_READ | ATA_F_PIO;

	return (xa);
}

d268 1
a268 8
ata_free_identify(struct ata_xfer *xa)
{
	free(xa->data, M_TEMP);
	ata_put_xfer(xa);
}

void
ata_complete_identify(struct ata_xfer *xa, struct ata_identify *id)
a272 3
	bcopy(xa->data, id, sizeof(struct ata_identify));
	ata_free_identify(xa);

a414 6
atascsi_empty_done(struct ata_xfer *xa)
{
	ata_put_xfer(xa);
}

void
d445 1
a445 6
	struct scsi_link	*link = xs->sc_link;
	struct atascsi		*as = link->adapter_softc;
	struct ata_port		*ap = as->as_ports[link->target];
	struct ata_xfer		*xa;
	struct scsi_inquiry	*inq;
	void			(*complete)(struct ata_xfer *);
a446 1
	inq = (struct scsi_inquiry *)xs->cmd;
d450 1
a450 2
			complete = atascsi_disk_serial_done;
			break;
d454 1
a454 6
	} else
		complete = atascsi_disk_inq_done;

	xa = ata_setup_identify(ap, xs->flags & SCSI_NOSLEEP);
	if (xa == NULL)
		return (NO_CCB);
d456 1
a456 7
	xa->complete = complete;
	xa->timeout = xs->timeout;
	xa->atascsi_private = xs;
	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;

	return (ata_exec(as, xa));
d459 2
a460 2
void
atascsi_disk_inq_done(struct ata_xfer *xa)
a461 1
	struct scsi_xfer	*xs = xa->atascsi_private;
a464 1
	struct ata_identify	id;
d466 1
a466 15
	int			host_ncqdepth, complete = 0;

	switch (xa->state) {
	case ATA_S_COMPLETE:
		ata_complete_identify(xa, &id);

		bzero(&inq, sizeof(inq));

		inq.device = T_DIRECT;
		inq.version = 0x05; /* SPC-3 */
		inq.response_format = 2;
		inq.additional_length = 32;
		bcopy("ATA     ", inq.vendor, sizeof(inq.vendor));
		bcopy(id.model, inq.product, sizeof(inq.product));
		bcopy(id.firmware, inq.revision, sizeof(inq.revision));
d468 1
a468 4
		bcopy(&inq, xs->data, MIN(sizeof(inq), xs->datalen));
		xs->error = XS_NOERROR;
		complete = 1;
		break;
d470 7
a476 6
	case ATA_S_ERROR:
	case ATA_S_TIMEOUT:
		ata_free_identify(xa);
		xs->error = (xa->state == ATA_S_TIMEOUT ? XS_TIMEOUT :
		    XS_DRIVER_STUFFUP);
		break;
d478 1
a478 4
	default:
		panic("atascsi_disk_inq_done: unexpected ata_xfer state (%d)",
		    xa->state);
	}
d480 1
d482 1
d484 1
d486 2
a487 2
	if (!complete || (ap->ap_features & ATA_PORT_F_PROBED))
		return;
d491 3
a493 2
	if (as->as_capability & ASAA_CAP_NCQ && (letoh16(id.satacap) &
	    (1 << 8))) {
d496 2
a497 3
		 * host controller supports, less the one that is outstanding
		 * as a result of this inquiry, less any reserved slot the 
		 * host controller needs for recovery.
d499 2
a500 2
		host_ncqdepth = link->openings + 1 + ((as->as_capability &
		    ASAA_CAP_NEEDS_RESERVED) ? 1 : 0);
d502 1
a502 1
		ap->ap_ncqdepth = (letoh16(id.qdepth) & 0x1f) + 1;
d522 2
d526 2
a527 2
void
atascsi_disk_serial_done(struct ata_xfer *xa)
d529 3
a531 2
	struct scsi_xfer	*xs = xa->atascsi_private;
	struct ata_identify	id;
d533 1
d535 1
a535 5
	switch (xa->state) {
	case ATA_S_COMPLETE:
		ata_complete_identify(xa, &id);

		bzero(&vpd, sizeof(vpd));
d537 5
a541 20
		vpd.device = T_DIRECT;
		vpd.page_code = SI_PG_SERIAL;
		vpd.page_length = sizeof(id.serial);
		bcopy(id.serial, vpd.serial, sizeof(id.serial));

		bcopy(&vpd, xs->data, MIN(sizeof(vpd), xs->datalen));
		xs->error = XS_NOERROR;
		break;

	case ATA_S_ERROR:
	case ATA_S_TIMEOUT:
		ata_free_identify(xa);
		xs->error = (xa->state == ATA_S_TIMEOUT ? XS_TIMEOUT :
		    XS_DRIVER_STUFFUP);
		break;

	default:
		panic("atascsi_disk_serial_done: unexpected xa state (%d)",
		    xa->state);
	}
d543 2
d546 1
d548 3
d616 3
a618 22
	struct ata_xfer		*xa;

	xa = ata_setup_identify(ap, xs->flags & SCSI_NOSLEEP);
	if (xa == NULL)
		return (NO_CCB);

	xa->complete = atascsi_disk_capacity_done;
	xa->timeout = xs->timeout;
	xa->atascsi_private = xs;
	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;

	return (ata_exec(as, xa));
}

void
atascsi_disk_capacity_done(struct ata_xfer *xa)
{
	struct scsi_xfer	*xs = xa->atascsi_private;
	struct ata_identify	id;
	struct scsi_read_cap_data rcd;
	u_int64_t		capacity;
d620 1
d622 4
a625 13
	switch (xa->state) {
	case ATA_S_COMPLETE:
		ata_complete_identify(xa, &id);

		bzero(&rcd, sizeof(rcd));
		if (letoh16(id.cmdset83) & 0x0400) {
			/* LBA48 feature set supported */
			for (i = 3; i >= 0; --i) {
				capacity <<= 16;
				capacity += letoh16(id.addrsecxt[i]);
			}
		} else {
			capacity = letoh16(id.addrsec[1]);
d627 1
a627 1
			capacity += letoh16(id.addrsec[0]);
d629 5
d635 2
a636 17
		/* XXX SCSI layer can't handle a device this big yet */
		if (capacity > 0xffffffff)
			capacity = 0xffffffff;

		_lto4b(capacity - 1, rcd.addr);
		_lto4b(512, rcd.length);

		bcopy(&rcd, xs->data, MIN(sizeof(rcd), xs->datalen));
		xs->error = XS_NOERROR;
		break;

	case ATA_S_ERROR:
	case ATA_S_TIMEOUT:
		ata_free_identify(xa);
		xs->error = (xa->state == ATA_S_TIMEOUT ? XS_TIMEOUT :
		    XS_DRIVER_STUFFUP);
		break;
d638 2
a639 4
	default:
		panic("atascsi_disk_capacity_done: "
		    "unexpected ata_xfer state (%d)", xa->state);
	}
d641 2
d644 1
d646 3
@


1.49
log
@implement atascsi_probe_dev and atascsi_detach_dev. they let a hba tell
the midlayer(s) what to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.48 2007/11/26 15:59:53 dlg Exp $ */
a175 1
	int			s;
a203 1
	s = splbio();
a204 1
	splx(s);
a252 1
	int			s;
a253 1
	s = splbio();
a254 1
	splx(s);
a260 1
		s = splbio();
a262 1
		splx(s);
d333 1
a333 1
	int			s, flags = 0;
a369 1
	s = splbio();
a370 1
	splx(s);
a629 1
	int			s;
a630 1
	s = splbio();
a631 1
	splx(s);
a779 1
	int			s;
a782 1
	s = splbio();
a783 1
	splx(s);
a897 1
	int			s;
a898 1
	s = splbio();
a899 1
	splx(s);
a936 1
		s = splbio();
a937 1
		splx(s);
a962 1
	s = splbio();
a963 1
	splx(s);
@


1.48
log
@drive port probes from the scsi midlayer now that it will ask the adapter
if a device is there before doing any scsi commands. also implement a free
path for when devices are detached. software hotplug has been tested on
sili, and ahci is still working according to claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.47 2007/11/23 18:21:55 dlg Exp $ */
d155 12
@


1.47
log
@starting bits to implement hotplug of sili controllers. this adds the code
to clean up the atascsi stuff, and has sili call it when its going away.

tested on an expresscard sili variant by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.46 2007/11/23 16:01:47 dlg Exp $ */
d53 2
d62 3
a64 1
	atascsi_ioctl		/* ioctl */
a70 3
int		atascsi_probe(struct atascsi *, int);
void		atascsi_unprobe(struct atascsi *, int);

a106 1
	int				i;
a132 4
	/* fill in the port array with the type of devices there */
	for (i = 0; i < as->as_link.adapter_buswidth; i++)
		atascsi_probe(as, i);

a146 1
	int				i;
a151 3
	for (i = 0; i < as->as_link.adapter_buswidth; i++)
		atascsi_unprobe(as, i);

d158 1
a158 1
atascsi_probe(struct atascsi *as, int port)
d160 1
d163 6
a168 1
	int			type, s;
d170 1
d217 1
a217 1
atascsi_unprobe(struct atascsi *as, int port)
d219 1
d221 4
d226 1
d236 2
@


1.46
log
@use copyin and copyout to get the actual ata data in and out of the kernel
for the ata ioctl used by atactl. i dont know how this worked before.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.45 2007/11/23 15:14:11 dlg Exp $ */
d68 1
d148 1
a148 1
atascsi_detach(struct atascsi *as)
d150 12
d215 16
@


1.45
log
@implement translation of the scsi vpd page for fetching a disks serial
number. lets bioctl against an atascsi disk see the serial number.

continually requested by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.44 2007/11/23 12:56:31 dlg Exp $ */
d865 1
d884 3
a886 1
	xa->data = atareq->databuf;
d893 1
a893 1
	if (atareq->flags & ATACMD_WRITE)
d895 2
d907 1
d920 2
d933 2
@


1.44
log
@t10 has a whole spec on doing SCSI to ATA translation called SAT. i wish
id known about it when i wrote atascsi. anyway.

it says we should claim SPC-3 when we fake INQUIRY.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.43 2007/11/16 02:17:27 dlg Exp $ */
d78 1
d436 14
d455 1
a455 1
	xa->complete = atascsi_disk_inq_done;
d545 38
@


1.43
log
@accept ATA ioctls so tools like atactl work on disks behind the atascsi
layer. i intended to write better ways to deal with disks, but i have been
too slack. shame on me.

this is less code than the equivilent in wdc/pciide, which amuses me
greatly.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.42 2007/10/01 15:34:48 krw Exp $ */
d467 1
a467 1
		inq.version = 2;
@


1.42
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.41 2007/04/22 05:11:45 dlg Exp $ */
d34 2
d51 2
d60 1
a60 1
	NULL			/* ioctl */
d787 97
@


1.41
log
@when an ata command returns an error, dont fill dmesg with messages about
it. returning an error to the scsi midlayer is all we need to do, which in
turn will do the right thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.40 2007/04/12 13:08:34 jsg Exp $ */
d102 1
a102 2
	as = malloc(sizeof(struct atascsi), M_DEVBUF, M_WAITOK);
	bzero(as, sizeof(struct atascsi));
d125 1
a125 2
	    M_DEVBUF, M_WAITOK);
	bzero(as->as_ports, sizeof(struct ata_port *) * aaa->aaa_nports);
d169 1
a169 2
	ap = malloc(sizeof(struct ata_port), M_DEVBUF, M_WAITOK);
	bzero(ap, sizeof(struct ata_port));
d211 2
a212 1
	xa->data = malloc(512, M_TEMP, nosleep ? M_NOWAIT : M_WAITOK);
a219 1
	bzero(xa->data, 512);
@


1.40
log
@Do a security freeze lock like we do in wd(4) to deal with systems
that leave the security set on by default.

"looks sane" grange@@, "looks ok" pascoe@@, "put it in" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.39 2007/04/10 23:37:06 dlg Exp $ */
a409 1
		printf("%s: error\n", __FUNCTION__);
@


1.39
log
@endian fixes for the read capacity handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.37 2007/03/23 05:28:34 pascoe Exp $ */
d80 2
d153 2
a154 1
	int			type;
d179 20
d391 6
@


1.38
log
@Complete the right scsi_xfer when processing a disk sync request.
@
text
@d598 2
a599 1
		if (id.cmdset83 & 0x0400) { /* LBA48 feature set supported */
d602 1
a602 1
				capacity += id.addrsecxt[i];
d605 1
a605 1
			capacity = id.addrsec[1];
d607 1
a607 1
			capacity += id.addrsec[0];
@


1.37
log
@Track the ATA xfer's state more closely - may help us identify why some
are seeing a panic at halt time.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.33 2007/03/22 05:15:39 pascoe Exp $ */
a519 2
	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;
a520 1

d523 3
@


1.36
log
@Really clear the device register on the flush cache command.  Last commit
adjusted the packet and identify commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.35 2007/03/23 05:25:02 pascoe Exp $ */
d194 1
d495 2
a496 1
			if (xa->tag < ap->ap_ncqdepth)
d498 1
d546 2
@


1.35
log
@Clear the device register on the flush cache command, in case something
that shouldn't care about don't care bits does care.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.34 2007/03/23 05:18:47 pascoe Exp $ */
d526 1
@


1.34
log
@Catch timed out disk commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.33 2007/03/22 05:15:39 pascoe Exp $ */
d203 1
d688 1
@


1.33
log
@Let atascsi issue NCQ commands if the controller supports it.

This includes a nasty hack to reduce openings and throw away command slots
if the device supports a lower queue depth than the host controller does.
Yes, we're thinking about a better solution.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.32 2007/03/21 23:40:30 pascoe Exp $ */
d381 3
@


1.32
log
@A polled xfer has completed and been put by the time ata_cmd returns, so
don't use xa->flags afterwards.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.30 2007/03/21 00:09:16 dlg Exp $ */
d44 2
d106 1
d120 2
d136 1
a136 1
            scsiprint);
d169 1
d327 13
a339 1
	if (sector_count > 0x100 || lba > 0xfffffff) {
d419 3
d424 1
d442 1
d459 35
@


1.31
log
@atascsi sends h2d fis's, not d2h.
@
text
@d693 2
d700 1
a700 1
		if (!(xa->flags & ATA_F_POLL))
@


1.30
log
@replace the array of u_int8_ts for the fis/registers with a struct to make
it a bit easier to read. there are variations on this, but they can be
defined later.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.29 2007/03/20 15:03:22 pascoe Exp $ */
d713 1
a713 1
		xa->fis->type = ATA_FIS_TYPE_D2H;
@


1.29
log
@Be sure to reset ata_xfer flags for all PACKET transfers, otherwise we
could pick up a previous ATA_F_POLL from a previous non-data command.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.28 2007/03/20 13:42:05 pascoe Exp $ */
d195 2
a196 5
	xa->cmd.tx->regs[H2D_DEVCTL_OR_COMMAND] = H2D_DEVCTL_OR_COMMAND_COMMAND;
	xa->cmd.tx->regs[H2D_COMMAND] = ATA_C_IDENTIFY;

	xa->cmd.st_bmask = 0x40; /* XXX magic WDCS_DRDY */;
	xa->cmd.st_pmask = 0x00;
d264 1
a266 1
	u_int8_t		*regs;
d314 1
a314 1
	regs = xa->cmd.tx->regs;
d316 4
a319 7
	regs[H2D_DEVCTL_OR_COMMAND] = H2D_DEVCTL_OR_COMMAND_COMMAND;
	regs[LBA_LOW] = lba & 0xff;
	regs[LBA_MID] = (lba >> 8) & 0xff;
	regs[LBA_HIGH] = (lba >> 16) & 0xff;

	if (xs->flags & SCSI_POLL)
		xa->flags |= ATA_F_POLL;
d323 1
a323 1
		regs[H2D_COMMAND] = (xa->flags & ATA_F_WRITE) ?
d325 6
a330 6
		regs[DEVICE] = H2D_DEVICE_LBA;
		regs[LBA_LOW_EXP] = (lba >> 24) & 0xff;
		regs[LBA_MID_EXP] = (lba >> 32) & 0xff;
		regs[LBA_HIGH_EXP] = (lba >> 40) & 0xff;
		regs[SECTOR_COUNT] = sector_count & 0xff;
		regs[SECTOR_COUNT_EXP] = (sector_count >> 8) & 0xff;
d333 1
a333 1
		regs[H2D_COMMAND] = (xa->flags & ATA_F_WRITE) ?
d335 2
a336 2
		regs[DEVICE] = H2D_DEVICE_LBA | ((lba >> 24) & 0x0f);
		regs[SECTOR_COUNT] = sector_count & 0xff;
d344 2
d462 2
a463 3
	xa->cmd.tx->regs[H2D_DEVCTL_OR_COMMAND] =
	    H2D_DEVCTL_OR_COMMAND_COMMAND;
	xa->cmd.tx->regs[H2D_COMMAND] = ATA_C_FLUSH_CACHE;
d596 1
a596 1
	u_int8_t		*regs;
d623 8
a630 8
	regs = xa->cmd.tx->regs;
	regs[H2D_DEVCTL_OR_COMMAND] = H2D_DEVCTL_OR_COMMAND_COMMAND;
	regs[H2D_COMMAND] = ATA_C_PACKET;
	regs[SECTOR_COUNT] = xa->cmd.tag << 3;
	regs[H2D_FEATURES] = 0x01 /* DMA */ |
	    ((xa->flags & ATA_F_WRITE) ? 0x00 : 0x04) /* direction */;
	regs[LBA_MID]  = 0x00;	/* byte count low */
	regs[LBA_HIGH] = 0x20;	/* byte count high, limit to 8K per data FIS */
d633 1
a633 1
	memcpy(xa->cmd.packetcmd, xs->cmd, xs->cmdlen);
d651 2
a652 2
		sd->flags = (xa->cmd.rx_err.regs[D2H_ERROR] & 0xf0) >> 4;
		if (xa->cmd.rx_err.regs[D2H_ERROR] & 0x04)
d654 1
a654 1
		if (xa->cmd.rx_err.regs[D2H_ERROR] & 0x02)
d656 1
a656 1
		if (xa->cmd.rx_err.regs[D2H_ERROR] & 0x01)
d708 8
a715 2
	return (ap->ap_as->as_methods->ata_get_xfer(ap->ap_as->as_cookie,
	    ap->ap_port));
@


1.28
log
@Basic FLUSH CACHE support.

Note that the ATA spec says we're should retry after error until we see no
more errors.  This is not (yet) implemented.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.25 2007/03/20 12:31:49 pascoe Exp $ */
d611 1
a611 1
		xa->flags = ATA_F_READ;
d614 1
a614 1
		xa->flags = ATA_F_WRITE;
d616 2
a619 1
	xa->flags |= ATA_F_PACKET;
@


1.27
log
@Tag ATAPI transfers that have no data phase correctly, otherwise the command
isn't sent to the device.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.26 2007/03/20 12:44:04 pascoe Exp $ */
d75 1
d445 53
a497 1
	return (atascsi_stuffup(xs));
@


1.26
log
@Oops, remove some unused variables and unmangle a command name.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.25 2007/03/20 12:31:49 pascoe Exp $ */
d558 1
a558 1
		xa->flags = ATA_F_READ | ATA_F_PACKET;
d561 1
a561 1
		xa->flags = ATA_F_WRITE | ATA_F_PACKET;
d565 1
@


1.25
log
@Cap the device size we present to 2TB, just in case someone attaches
something really big.  The SCSI layer isn't yet ready for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.24 2007/03/20 12:24:02 pascoe Exp $ */
a385 1
	int			s;
a453 1
	int			s;
d643 1
a643 1
	switch (as->as_methods->ata_issue_cmd(xa)) {
@


1.24
log
@Move common completion handling into ata_exec itself.  Removes a double free
in the inquiry error paths, as the HBA will have already completed the
ata_xfer with an error.

Reminder and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.23 2007/03/20 12:01:18 pascoe Exp $ */
d476 1
a476 1
	u_int32_t		capacity;
d494 4
@


1.23
log
@Add support for ATA PACKET commands.  This should make ATAPI cdrom drives,
etc, just work.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.22 2007/03/20 11:07:02 dlg Exp $ */
d350 1
a350 9
	switch (ata_exec(as, xa)) {
	case ATA_COMPLETE:
	case ATA_ERROR:
		return (COMPLETE);
	case ATA_QUEUED:
		return (SUCCESSFULLY_QUEUED);
	default:
		panic("unexpected return from ata_exec");
	}
d398 1
a398 13
	switch (ata_exec(as, xa)) {
	case ATA_COMPLETE:
		return (COMPLETE);
	case ATA_QUEUED:
		return (SUCCESSFULLY_QUEUED);
	case ATA_ERROR:
		s = splbio();
		ata_free_identify(xa);
		splx(s);
		return (atascsi_stuffup(xs));
	default:
		panic("unexpected return from ata_exec");
	}
d408 3
a410 1
	ata_complete_identify(xa, &id);
d412 1
a412 1
	bzero(&inq, sizeof(inq));
d414 23
a436 7
	inq.device = T_DIRECT;
	inq.version = 2;
	inq.response_format = 2;
	inq.additional_length = 32;
	bcopy("ATA     ", inq.vendor, sizeof(inq.vendor));
	bcopy(id.model, inq.product, sizeof(inq.product));
	bcopy(id.firmware, inq.revision, sizeof(inq.revision));
a437 2
	bcopy(&inq, xs->data, MIN(sizeof(inq), xs->datalen));
	xs->error = XS_NOERROR;
a438 1

d467 1
a467 13
	switch (ata_exec(as, xa)) {
	case ATA_COMPLETE:
		return (COMPLETE);
	case ATA_QUEUED:
		return (SUCCESSFULLY_QUEUED);
	case ATA_ERROR:
		s = splbio();
		ata_free_identify(xa);
		splx(s);
		return (atascsi_stuffup(xs));
	default:
		panic("unexpected return from ata_exec");
	}
d479 3
a481 1
	ata_complete_identify(xa, &id);
d483 8
a490 3
	bzero(&rcd, sizeof(rcd));
	if (id.cmdset83 & 0x0400) {
		for (i = 3; i >= 0; --i) {
d492 1
a492 1
			capacity += id.addrsecxt[i];
d494 18
a511 4
	} else {
		capacity = id.addrsec[1];
		capacity <<= 16;
		capacity += id.addrsec[0];
a513 5
	_lto4b(capacity - 1, rcd.addr);
	_lto4b(512, rcd.length);

	bcopy(&rcd, xs->data, MIN(sizeof(rcd), xs->datalen));
	xs->error = XS_NOERROR;
a514 1

d583 1
a583 9
	switch (ata_exec(as, xa)) {
	case ATA_COMPLETE:
	case ATA_ERROR:
		return (COMPLETE);
	case ATA_QUEUED:
		return (SUCCESSFULLY_QUEUED);
	default:
		panic("unexpected return from ata_exec");
	}
d641 10
a650 1
	return (as->as_methods->ata_cmd(xa));
a651 1

@


1.22
log
@move ata command definitions from atascsi.c to atascsi.h
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.21 2007/03/20 07:45:11 dlg Exp $ */
d78 1
d151 10
a160 2
	if (type != ATA_PORT_T_DISK) /* XXX ATAPI too one day */
		return (ENXIO);
a539 1

d543 89
a631 1
	return (atascsi_stuffup(xs));
@


1.21
log
@nothing from wdc, wd, or any of the existing ata stuff pls. this gets rid
of the wdcreg.h include in atascsi.

"feel free to remove" pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.20 2007/03/20 07:09:42 pascoe Exp $ */
a32 95

/* XXX ata_identify should be in atareg.h */

#define ATA_C_IDENTIFY		0xec
#define ATA_C_READDMA		0xc8
#define ATA_C_WRITEDMA		0xca
#define ATA_C_READDMA_EXT	0x25
#define ATA_C_WRITEDMA_EXT	0x35

struct ata_identify {
	u_int16_t	config;		/*   0 */
	u_int16_t	ncyls;		/*   1 */
	u_int16_t	reserved1;	/*   2 */
	u_int16_t	nheads;		/*   3 */
	u_int16_t	track_size;	/*   4 */
	u_int16_t	sector_size;	/*   5 */
	u_int16_t	nsectors;	/*   6 */
	u_int16_t	reserved2[3];	/*   7 vendor unique */
	u_int8_t	serial[20];	/*  10 */
	u_int16_t	buffer_type;	/*  20 */
	u_int16_t	buffer_size;	/*  21 */
	u_int16_t	ecc;		/*  22 */
	u_int8_t	firmware[8];	/*  23 */
	u_int8_t	model[40];	/*  27 */
	u_int16_t	multi;		/*  47 */
	u_int16_t	dwcap;		/*  48 */
	u_int16_t	cap;		/*  49 */
	u_int16_t	reserved3;	/*  50 */
	u_int16_t	piomode;	/*  51 */
	u_int16_t	dmamode;	/*  52 */
	u_int16_t	validinfo;	/*  53 */
	u_int16_t	curcyls;	/*  54 */
	u_int16_t	curheads;	/*  55 */
	u_int16_t	cursectrk;	/*  56 */
	u_int16_t	curseccp[2];	/*  57 */
	u_int16_t	mult2;		/*  59 */
	u_int16_t	addrsec[2];	/*  60 */
	u_int16_t	worddma;	/*  62 */
	u_int16_t	dworddma;	/*  63 */
	u_int16_t	advpiomode;	/*  64 */
	u_int16_t	minmwdma;	/*  65 */
	u_int16_t	recmwdma;	/*  66 */
	u_int16_t	minpio;		/*  67 */
	u_int16_t	minpioflow;	/*  68 */
	u_int16_t	reserved4[2];	/*  69 */
	u_int16_t	typtime[2];	/*  71 */
	u_int16_t	reserved5[2];	/*  73 */
	u_int16_t	qdepth;		/*  75 */
	u_int16_t	satacap;	/*  76 */
	u_int16_t	reserved6;	/*  77 */
	u_int16_t	satafsup;	/*  78 */
	u_int16_t	satafen;	/*  79 */
	u_int16_t	majver;		/*  80 */
	u_int16_t	minver;		/*  81 */
	u_int16_t	cmdset82;	/*  82 */
	u_int16_t	cmdset83;	/*  83 */
	u_int16_t	cmdset84;	/*  84 */
	u_int16_t	features85;	/*  85 */
	u_int16_t	features86;	/*  86 */
	u_int16_t	features87;	/*  87 */
	u_int16_t	ultradma;	/*  88 */
	u_int16_t	erasetime;	/*  89 */
	u_int16_t	erasetimex;	/*  90 */
	u_int16_t	apm;		/*  91 */
	u_int16_t	masterpw;	/*  92 */
	u_int16_t	hwreset;	/*  93 */
	u_int16_t	acoustic;	/*  94 */
	u_int16_t	stream_min;	/*  95 */
	u_int16_t	stream_xfer_d;	/*  96 */
	u_int16_t	stream_lat;	/*  97 */
	u_int16_t	streamperf[2];	/*  98 */
	u_int16_t	addrsecxt[4];	/* 100 */
	u_int16_t	stream_xfer_p;	/* 104 */
	u_int16_t	padding1;	/* 105 */
	u_int16_t	phys_sect_sz;	/* 106 */
	u_int16_t	seek_delay;	/* 107 */
	u_int16_t	naa_ieee_oui;	/* 108 */
	u_int16_t	ieee_oui_uid;	/* 109 */
	u_int16_t	uid_mid;	/* 110 */
	u_int16_t	uid_low;	/* 111 */
	u_int16_t	resv_wwn[4];	/* 112 */
	u_int16_t	incits;		/* 116 */
	u_int16_t	words_lsec[2];	/* 117 */
	u_int16_t	cmdset119;	/* 119 */
	u_int16_t	features120;	/* 120 */
	u_int16_t	padding2[6];
	u_int16_t	rmsn;		/* 127 */
	u_int16_t	securestatus;	/* 128 */
	u_int16_t	vendor[31];	/* 129 */
	u_int16_t	padding3[16];	/* 160 */
	u_int16_t	curmedser[30];	/* 176 */
	u_int16_t	sctsupport;	/* 206 */
	u_int16_t	padding4[48];	/* 207 */
	u_int16_t	integrity;	/* 255 */
} __packed;
@


1.20
log
@Request "descriptor processed" interrupts only for PIO requests (inquiry,
etc), and request that the D2H FIS at the completion of all (DMA) commands
generate an interrupt.

This makes each data transfer generate one interrupt instead of two and
should guarantee that the interrupt that is generated actually arrives
after the command has completed.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.19 2007/03/20 06:43:06 pascoe Exp $ */
a33 2
#include <dev/ic/wdcreg.h>

d37 4
d415 2
a416 2
		    WDCC_WRITEDMA_EXT : WDCC_READDMA_EXT;
		regs[DEVICE] = WDSD_LBA;
d425 2
a426 2
		    WDCC_WRITEDMA : WDCC_READDMA;
		regs[DEVICE] = WDSD_LBA | ((lba >> 24) & 0x0f);
@


1.19
log
@Calculate the residual and copy it back to the scsi_xfer, so that RW actually
works.

From dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.18 2007/03/20 06:41:38 pascoe Exp $ */
d284 1
a284 1
	xa->flags = ATA_F_READ;
@


1.18
log
@Add support for issuing sector read/write commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.17 2007/03/20 05:33:02 pascoe Exp $ */
d464 1
@


1.17
log
@Instead of having a copy of every register that we will issue in the ata_cmd,
simply include a pointer to the command FIS that we will issue to the device.

Include another space where we can copy back an error register set from a
failed command.

This means that we can now build and issue arbitrary commands from atascsi,
and retrieve errors back.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.16 2007/03/20 04:38:11 pascoe Exp $ */
d34 2
d162 1
a342 1
#if 0
d346 7
a352 2
	int			s;
#endif
d356 3
a359 1
	case READ_COMMAND:
d361 1
d383 85
a467 1
	return (atascsi_stuffup(xs));
@


1.16
log
@Change API for struct ata_xfer allocation to move it into the device that
atascsi will be driving, and add it to the AHCI CCB.

This effectively gives us all the resources we need for a transfer in one
hit, meaning that we don't need to worry about whether we will have a pool
shortage or not enough CCBs.  The SCSI mid layer should take care to never
exceed the number of CCBs we have available, based on our sc_link.openings.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.15 2007/03/13 11:20:57 dlg Exp $ */
d275 3
a277 1
	xa->cmd.command = ATA_C_IDENTIFY;
@


1.15
log
@add timeouts on ata_xfers
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.14 2007/03/12 00:35:15 dlg Exp $ */
a25 1
#include <sys/pool.h>
a172 4
struct pool	ata_xfer_pool;

void		ata_init(void);
void		ata_destroy(void);
a185 2
	ata_init();

a226 2
	ata_destroy();

d385 1
a385 1
		return (atascsi_stuffup(xs));
d451 1
a451 1
		return (atascsi_stuffup(xs));
a547 19
void
ata_init(void)
{
	if (ata_running++)
		return;

	pool_init(&ata_xfer_pool, sizeof(struct ata_xfer), 0, 0, 0, "xapl",
	    NULL);
}

void
ata_destroy(void)
{
	if (--ata_running)
		return;

	pool_destroy(&ata_xfer_pool);
}
 
d551 1
a551 2
	xa->state = ATA_S_PENDING;
	return (as->as_methods->ata_cmd(as->as_cookie, xa));
d554 1
d556 1
a556 1
ata_get_xfer(struct ata_port *ap, int nosleep)
d558 2
a559 10
	struct ata_xfer		*xa;

	xa = pool_get(&ata_xfer_pool, nosleep ? PR_NOWAIT : PR_WAITOK);
	if (xa != NULL) {
		bzero(&xa->cmd, sizeof(xa->cmd));
		xa->port = ap;
		xa->state = ATA_S_SETUP;
	}

	return (xa);
d565 1
a565 1
	pool_put(&ata_xfer_pool, xa);
@


1.14
log
@ata counts sectors from 1, scsi counts from 0. adjust the value in the
read capacity completion to compensate.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.13 2007/03/12 00:33:09 dlg Exp $ */
d397 1
d463 1
@


1.13
log
@parse the ata_identify to get a more correct value for the capacity of the
disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.12 2007/03/12 00:31:17 dlg Exp $ */
d504 1
a504 1
	_lto4b(capacity, rcd.addr);
@


1.12
log
@finish teh ata_identify struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.10 2007/03/06 12:25:00 dlg Exp $ */
d487 2
d493 12
a504 1
	_lto4b(1024 * 1024 * 1024, rcd.addr);
@


1.11
log
@Set ITSDONE otherwise the SCSI layer will sleep forever waiting for our
queued commands to be done.
@
text
@d40 84
a123 19
	u_int16_t	config;		/*  0 */
	u_int16_t	ncyls;		/*  1 (OBSOLETE) */
	u_int16_t	reserved1;	/*  2 */
	u_int16_t	nheads;		/*  3 (OBSOLETE) */
	u_int16_t	track_size;	/*  4 (OBSOLETE) */
	u_int16_t	sector_size;	/*  5 (OBSOLETE) */
	u_int16_t	nsectors;	/*  6 (OBSOLETE) */
	u_int16_t	reserved2[3];	/*  7 vendor unique */
	u_int8_t	serial[20];	/* 10 */
	u_int16_t	buffer_type;	/* 20 */
	u_int16_t	buffer_size;	/* 21 */
	u_int16_t	ecc;		/* 22 */
	u_int8_t	firmware[8];	/* 23 */
	u_int8_t	model[40];	/* 27 */
	u_int16_t	multi;		/* 47 */
	u_int16_t	dwcap;		/* 48 */
	u_int16_t	cap;		/* 49 */
	u_int16_t	reserved3;	/* 50 */
	/* XXX there's a LOT more of this */
@


1.10
log
@big changes to the completion path in ahci.c

- add a ccb_done member to the ahci_ccb, which points to a function that
is used to complete the current xfer
- ccbs no longer rely on an ata_xfer being provided for submission to work
- ahci is stupid and has no way to telling you the difference between an
empty command slot, and a completed command. we keep track of active
commands with ap_active in ahci_port, so we dont try and complete commands
we havent actually submitted
- ahci_start simple submits a command to the hardware now
- provide the start of an interrupt handler for each port (which is not yet
called by the controllers interrupt handler)
- provide an ahci_poll which is built on top of ahci_start and
ahci_port_intr
- remove the fake ata_xfers from the softreset path
- on completion of an ahci command, sync the relevant dma memory
- provide a completion path for ata_xfers which syncs the xfers buffer
and calls the xfers completion handler

in atascsi.c:

- start defining the contents of the response to an ATA IDENTIFY command
specific to SATA
- implement the faking of scsi inquiries, so now you'll actually see a disk
attach to ahci.
- start implementing a fake scsi read capacity. it presents a fake geometry
though, so dont get too excited when ahci magically makes your disk have a
terabyte in size.

lots of discussion, help, tweaks, and an ok from pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.7 2007/02/19 12:06:16 dlg Exp $ */
d372 1
d431 1
d448 2
d469 2
@


1.9
log
@when allocating an xfer, preinit several values according to the port its
destined for. add ata_exec, which will push the xfer on the right path.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.8 2007/02/28 13:23:23 dlg Exp $ */
d35 26
d90 5
d97 1
d99 1
d177 3
d183 10
a192 3
#if 0
	as->as_ports[port] = as->as_methods->probe(as->as_cookie, port);
#endif
d197 60
d321 53
a373 1
	return (atascsi_stuffup(xs));
d385 47
a431 1
	return (atascsi_stuffup(xs));
@


1.8
log
@we allocate an array of pointers, so we should bzero an array of pointers,
not an array of ints.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.7 2007/02/19 12:06:16 dlg Exp $ */
d81 3
a83 1
struct ata_xfer	*ata_get_xfer(int);
d288 7
d297 1
a297 1
ata_get_xfer(int nosleep)
d302 5
a315 2


@


1.7
log
@actually init and destroy the shared ata stuff when an atascsi instance
is created or destroyed.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.6 2007/02/19 12:04:01 dlg Exp $ */
d115 1
a115 1
	bzero(as->as_ports, sizeof(int) * aaa->aaa_nports);
@


1.6
log
@code to set up a global pool for allocating ata_xfers out of, and for
accessing that pool.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d91 2
d134 2
@


1.5
log
@oops, i should have tried to compile the REQUEST_SENSE handling before
committing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.4 2007/02/19 11:55:04 dlg Exp $ */
d26 1
a46 2
int		atascsi_probe(struct atascsi *, int);

d62 2
d74 10
d263 37
@


1.4
log
@REQUEST_SENSE will say there is no sense data.
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.3 2007/02/19 11:53:34 dlg Exp $ */
d219 2
a220 1
	struct scsi_sense_data	*sd = xs->data;
@


1.3
log
@implement the start of the framework for scsi emulation of ata disks
@
text
@d1 1
a1 1
/*	$OpenBSD: atascsi.c,v 1.2 2007/02/19 11:48:34 dlg Exp $ */
d203 1
d209 1
d211 1
a211 1
atascsi_disk_sense(struct scsi_xfer *xs)
d215 1
d217 1
a217 1
atascsi_disk_capacity(struct scsi_xfer *xs)
d219 12
a230 1
	return (atascsi_stuffup(xs));
d232 1
@


1.2
log
@as is short for atascsi, not ab
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d29 1
d38 1
a38 1
	int			*as_ports;
d63 10
d100 1
a100 1
	as->as_ports = malloc(sizeof(int) * aaa->aaa_nports,
d130 1
d132 1
d139 88
@


1.1
log
@pull in atascsi, a scsi to ata translation layer, so i can work on it in
tree. ive lost two large changes today thanks to my own stupidity which
could have been avoided if they were in the tree.

discussed with deraadt@@

ok jsg@@ grange@@ an older version was ok marco@@
@
text
@d34 2
a35 2
	struct device		*ab_dev;
	void			*ab_cookie;
d37 1
a37 1
	int			*ab_ports;
d39 4
a42 4
	struct atascsi_methods	*ab_methods;
	struct scsi_adapter	ab_switch;
	struct scsi_link	ab_link;
	struct scsibus_softc	*ab_scsibus;
d66 1
a66 1
	struct atascsi			*ab;
d69 2
a70 2
	ab = malloc(sizeof(struct atascsi), M_DEVBUF, M_WAITOK);
	bzero(ab, sizeof(struct atascsi));
d72 3
a74 3
	ab->ab_dev = self;
	ab->ab_cookie = aaa->aaa_cookie;
	ab->ab_methods = aaa->aaa_methods;
d77 2
a78 2
	ab->ab_switch = atascsi_switch;
	ab->ab_switch.scsi_minphys = aaa->aaa_minphys;
d81 7
a87 7
	ab->ab_link.device = &atascsi_device;
	ab->ab_link.adapter = &ab->ab_switch;
	ab->ab_link.adapter_softc = ab;
	ab->ab_link.adapter_buswidth = aaa->aaa_nports;
	ab->ab_link.luns = 1; /* XXX port multiplier as luns */
	ab->ab_link.adapter_target = aaa->aaa_nports;
	ab->ab_link.openings = aaa->aaa_ncmds;
d89 1
a89 1
	ab->ab_ports = malloc(sizeof(int) * aaa->aaa_nports,
d91 1
a91 1
	bzero(ab->ab_ports, sizeof(int) * aaa->aaa_nports);
d94 2
a95 2
	for (i = 0; i < ab->ab_link.adapter_buswidth; i++)
		atascsi_probe(ab, i);
d98 1
a98 1
	saa.saa_sc_link = &ab->ab_link;
d101 1
a101 1
	ab->ab_scsibus = (struct scsibus_softc *)config_found(self, &saa,
d104 1
a104 1
	return (ab);
d108 1
a108 1
atascsi_detach(struct atascsi *ab)
d114 1
a114 1
atascsi_probe(struct atascsi *ab, int port)
d116 1
a116 1
	if (port > ab->ab_link.adapter_buswidth)
d119 1
a119 1
	ab->ab_ports[port] = ab->ab_methods->probe(ab->ab_cookie, port);
@

