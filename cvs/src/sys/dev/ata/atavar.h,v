head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.6
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.20
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.18
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.16
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.14
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.20
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.22
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.18
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.16
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.14
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.12
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.10
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.21
date	2015.08.17.15.36.29;	author krw;	state Exp;
branches;
next	1.20;
commitid	Le3SuX5chjCNZy3I;

1.20
date	2011.04.15.20.53.28;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.24.07.05.44;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.21.09.57.04;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.16.20.21.07;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.16.20.03.40;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.28.21.01.42;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.09.00.38.08;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.21.20.10.33;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.03.16.03;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.06.25.19.31.48;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.01.00.07.25;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.25.13.11.56;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.10.07.06.16;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.09.03.42.03;	author csapuntz;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.09.05.21.45.22;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.07.22.02.51.15;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	99.07.18.21.25.17;	author csapuntz;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.23.05;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.07.04.10.40.16;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2003.05.13.19.34.56;	author ho;	state Exp;
branches;
next	1.4.4.7;

1.4.4.7
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@The 80's called and want their interface back. Remove last fragments of
ST-506 support. Remove redundant 'precomp' variables/fields and rename
remaining few to 'features' to be consistant with the rest of the code.

Consensus that no ST-506 disks (requiring ISA cards, <120MB, usually
rife with bad sectors that can't be worked around) are still running
OpenBSD.
@
text
@/*	$OpenBSD: atavar.h,v 1.20 2011/04/15 20:53:28 miod Exp $	*/
/*	$NetBSD: atavar.h,v 1.13 1999/03/10 13:11:43 bouyer Exp $	*/

/*
 * Copyright (c) 1998, 2001 Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef _DEV_ATA_ATAVAR_H_
#define _DEV_ATA_ATAVAR_H_

/* High-level functions and structures used by both ATA and ATAPI devices */
#include <dev/ata/atareg.h>

/* Datas common to drives and controller drivers */
struct ata_drive_datas {
	u_int8_t drive; /* drive number */
	int8_t ata_vers; /* ATA version supported */
	u_int16_t drive_flags; /* bitmask for drives present/absent and cap */
#define DRIVE_ATA	0x0001
#define DRIVE_ATAPI	0x0002
#define DRIVE_OLD	0x0004
#define DRIVE (DRIVE_ATA|DRIVE_ATAPI|DRIVE_OLD)
#define DRIVE_CAP32	0x0008
#define DRIVE_DMA	0x0010
#define DRIVE_UDMA	0x0020
#define DRIVE_MODE	0x0040 /* the drive reported its mode */
#define DRIVE_RESET	0x0080 /* reset the drive state at next xfer */
#define DRIVE_DMAERR	0x0100 /* Udma transfer had crc error, don't try DMA */
#define DRIVE_DSCBA	0x0200 /* DSC in buffer availability mode */
#define DRIVE_DSCWAIT	0x0400 /* In wait for DSC to be asserted */
#define DRIVE_DEVICE_RESET 0x0800 /* Drive supports DEVICE RESET command */
#define DRIVE_SATA	0x1000 /* SATA drive */
	/*
	 * Current setting of drive's PIO, DMA and UDMA modes.
	 * Is initialised by the disks drivers at attach time, and may be
	 * changed later by the controller's code if needed
	 */
	u_int8_t PIO_mode; /* Current setting of drive's PIO mode */
	u_int8_t DMA_mode; /* Current setting of drive's DMA mode */
	u_int8_t UDMA_mode; /* Current setting of drive's UDMA mode */
	/* Supported modes for this drive */
	u_int8_t PIO_cap; /* supported drive's PIO mode */
	u_int8_t DMA_cap; /* supported drive's DMA mode */
	u_int8_t UDMA_cap; /* supported drive's UDMA mode */
	/*
	 * Drive state. This is drive-type (ATA or ATAPI) dependant
	 * This is reset to 0 after a channel reset.
	 */
	u_int8_t state;

#define ACAP_LEN            0x01  /* 16 byte commands */
#define ACAP_DSC            0x02  /* use DSC signalling */
	/* 0x20-0x40 reserved for ATAPI_CFG_DRQ_MASK */
	u_int8_t atapi_cap;

	/* Keeps track of the number of resets that have occurred in a row
	   without a successful command completion. */
	u_int8_t n_resets;
	u_int8_t n_dmaerrs;
	u_int32_t n_xfers;
#define NERRS_MAX 4
#define NXFER 1000

	char drive_name[31];
	int  cf_flags;
	void *chnl_softc; /* channel softc */

	struct ataparams id;
};

/* ATA/ATAPI common attachement datas */
struct ata_atapi_attach {
    u_int8_t aa_type; /* Type of device */
#define T_ATA 0
#define T_ATAPI 1
    u_int8_t aa_channel; /* controller's channel */
    u_int8_t aa_openings; /* Number of simultaneous commands possible */
    struct ata_drive_datas *aa_drv_data;
    void *aa_bus_private; /* infos specifics to this bus */
};

/* User config flags that force (or disable) the use of a mode */
#define ATA_CONFIG_PIO_MODES	0x0007
#define ATA_CONFIG_PIO_SET	0x0008
#define ATA_CONFIG_PIO_OFF	0
#define ATA_CONFIG_DMA_MODES	0x0070
#define ATA_CONFIG_DMA_SET	0x0080
#define ATA_CONFIG_DMA_DISABLE	0x0070
#define ATA_CONFIG_DMA_OFF	4
#define ATA_CONFIG_UDMA_MODES	0x0700
#define ATA_CONFIG_UDMA_SET	0x0800
#define ATA_CONFIG_UDMA_DISABLE	0x0700
#define ATA_CONFIG_UDMA_OFF	8

/*
 * ATA/ATAPI commands description
 *
 * This structure defines the interface between the ATA/ATAPI device driver
 * and the controller for short commands. It contains the command's parameter,
 * the len of data's to read/write (if any), and a function to call upon
 * completion.
 * If no sleep is allowed, the driver can poll for command completion.
 * Once the command completed, if the error registed is valid, the flag
 * AT_ERROR is set and the error register value is copied to r_error .
 * A separate interface is needed for read/write or ATAPI packet commands
 * (which need multiple interrupts per commands).
 */
struct wdc_command {
    u_int8_t r_command;  /* Parameters to upload to registers */
    u_int8_t r_head;
    u_int16_t r_cyl;
    u_int8_t r_sector;
    u_int8_t r_count;
    u_int8_t r_features;
    u_int8_t r_st_bmask; /* status register mask to wait for before command */
    u_int8_t r_st_pmask; /* status register mask to wait for after command */
    u_int8_t r_error;    /* error register after command done */
    volatile u_int16_t flags;
#define AT_READ     0x0001 /* There is data to read */
#define AT_WRITE    0x0002 /* There is data to write (excl. with AT_READ) */
#define AT_WAIT     0x0008 /* wait in controller code for command completion */
#define AT_POLL     0x0010 /* poll for command completion (no interrupts) */
#define AT_DONE     0x0020 /* command is done */
#define AT_ERROR    0x0040 /* command is done with error */
#define AT_TIMEOU   0x0080 /* command timed out */
#define AT_DF       0x0100 /* Drive fault */
#define AT_READREG  0x0200 /* Read registers on completion */
    int timeout;         /* timeout (in ms) */
    void *data;          /* Data buffer address */
    int bcount;          /* number of bytes to transfer */
    void (*callback)(void *); /* command to call once command completed */
    void *callback_arg;  /* argument passed to *callback() */
};

extern int at_poll;

int wdc_exec_command(struct ata_drive_datas *, struct wdc_command*);
#define WDC_COMPLETE  0x01
#define WDC_QUEUED    0x02
#define WDC_TRY_AGAIN 0x03

void wdc_probe_caps(struct ata_drive_datas*, struct ataparams *);
void wdc_print_caps(struct ata_drive_datas*);
int  wdc_downgrade_mode(struct ata_drive_datas*);

void wdc_reset_channel(struct ata_drive_datas *, int);

int wdc_ata_addref(struct ata_drive_datas *);
void wdc_ata_delref(struct ata_drive_datas *);
void wdc_ata_kill_pending(struct ata_drive_datas *);

int ata_get_params(struct ata_drive_datas*, u_int8_t,
	struct ataparams *);
int ata_set_mode(struct ata_drive_datas*, u_int8_t, u_int8_t);
/* return code for these cmds */
#define CMD_OK    0
#define CMD_ERR   1
#define CMD_AGAIN 2

void ata_dmaerr(struct ata_drive_datas *);
void ata_perror(struct ata_drive_datas *, int, char *, size_t);

#endif	/* !_DEV_ATA_ATAVAR_H_ */
@


1.20
log
@Change wdc_reset_channel() to take a `no wait' argument. Pass in turn this
argument to wdcreset(), to have it skip waiting until active channels see
their BUSY bit clear in the status register.

Use this feature in the resume path, during the first reset operation. The
first reset is supposed to only wake up the controller, and the disks don't
come back until the second reset is issued, therefore waiting for them to
report themselves as ready after the first reset, but before the second, is
moot - and as a matter of fact some controllers, such as the AMD 754 and
clones/offspring (e.g. Geode) keep the BUSY bit asserted after the first
reset.

Last, but not least, make sure wd@@ata invokes wd_get_params() again before
returning from the resume code, as we will still be using polled transfers
for a short while.

This causes the Lemote Yeelong to resume within less than one second, instead
of the lousy 30 seconds wait between the two resets; and the wd_get_params()
voodoo prevents it from getting spurious ide interrupts afterwards.

wd_get_params() magic from dlg; rest of the work by yours truly after enough
prodding by dlg@@ and pirofti@@, among others. ok deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.19 2010/07/23 07:47:13 jsg Exp $	*/
d135 1
a135 1
    u_int8_t r_precomp;
@


1.19
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.18 2004/09/24 07:05:44 grange Exp $	*/
d167 1
a167 1
void wdc_reset_channel(struct ata_drive_datas *);
@


1.18
log
@Multiple inclusion protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.17 2003/10/21 09:57:04 jmc Exp $	*/
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Manuel Bouyer.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.17
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.16 2003/10/16 20:21:07 grange Exp $	*/
d35 3
d189 2
@


1.16
log
@New flag to mark SATA drives
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.15 2003/10/16 20:03:40 grange Exp $	*/
d81 1
a81 1
	   without a succesful command completion. */
@


1.15
log
@spaces/tabs cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.14 2003/09/28 21:01:42 grange Exp $	*/
d56 1
@


1.14
log
@kill trailing spaces, no functional changes
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.13 2003/04/09 00:38:08 ho Exp $	*/
d151 1
a151 1
    int timeout;	 /* timeout (in ms) */
d153 1
a153 1
    int bcount;           /* number of bytes to transfer */
d161 2
a162 2
#define WDC_COMPLETE 0x01
#define WDC_QUEUED   0x02
d176 1
a176 1
	 struct ataparams *);
@


1.13
log
@sprintf->snprintf. miod@@, grange@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.12 2003/02/21 20:10:33 grange Exp $	*/
d25 1
a25 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
d45 1
a45 1
#define DRIVE_OLD	0x0004 
d48 1
a48 1
#define DRIVE_DMA	0x0010 
d90 1
a90 1
    
d119 1
a119 1
 * ATA/ATAPI commands description 
@


1.12
log
@Fix Manuel Bouyer's copyright, from NetBSD
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.11 2002/03/14 03:16:03 millert Exp $	*/
d184 1
a184 1
void ata_perror(struct ata_drive_datas *, int, char *);
@


1.11
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.10 2002/03/14 01:26:52 millert Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Manuel Bouyer.
d17 1
a17 2
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
d22 10
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.9 2001/09/20 17:02:31 mpech Exp $	*/
d156 1
a156 1
    void (*callback)(void*); /* command to call once command completed */
@


1.9
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.8 2001/06/25 19:31:48 csapuntz Exp $	*/
d156 1
a156 1
    void (*callback) __P((void*)); /* command to call once command completed */
d162 1
a162 1
int wdc_exec_command __P((struct ata_drive_datas *, struct wdc_command*));
d167 13
a179 13
void wdc_probe_caps __P((struct ata_drive_datas*, struct ataparams *));
void wdc_print_caps __P((struct ata_drive_datas*));
int  wdc_downgrade_mode __P((struct ata_drive_datas*));

void wdc_reset_channel __P((struct ata_drive_datas *));

int wdc_ata_addref __P((struct ata_drive_datas *));
void wdc_ata_delref __P((struct ata_drive_datas *));
void wdc_ata_kill_pending __P((struct ata_drive_datas *));

int ata_get_params __P((struct ata_drive_datas*, u_int8_t,
	 struct ataparams *));
int ata_set_mode __P((struct ata_drive_datas*, u_int8_t, u_int8_t));
d185 2
a186 2
void ata_dmaerr __P((struct ata_drive_datas *));
void ata_perror __P((struct ata_drive_datas *, int, char *));
@


1.9.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.9 2001/09/20 17:02:31 mpech Exp $	*/
d156 1
a156 1
    void (*callback)(void *); /* command to call once command completed */
d162 1
a162 1
int wdc_exec_command(struct ata_drive_datas *, struct wdc_command*);
d167 13
a179 13
void wdc_probe_caps(struct ata_drive_datas*, struct ataparams *);
void wdc_print_caps(struct ata_drive_datas*);
int  wdc_downgrade_mode(struct ata_drive_datas*);

void wdc_reset_channel(struct ata_drive_datas *);

int wdc_ata_addref(struct ata_drive_datas *);
void wdc_ata_delref(struct ata_drive_datas *);
void wdc_ata_kill_pending(struct ata_drive_datas *);

int ata_get_params(struct ata_drive_datas*, u_int8_t,
	 struct ataparams *);
int ata_set_mode(struct ata_drive_datas*, u_int8_t, u_int8_t);
d185 2
a186 2
void ata_dmaerr(struct ata_drive_datas *);
void ata_perror(struct ata_drive_datas *, int, char *);
@


1.9.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
a5 1
 * Copyright (c) 1998, 2001 Manuel Bouyer.
d17 2
a18 1
 *	This product includes software developed by Manuel Bouyer.
d23 11
a33 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d186 1
a186 1
void ata_perror(struct ata_drive_datas *, int, char *, size_t);
@


1.8
log
@

Fix excessive resets and device probes by storing IDENTIFY results in the
drvp structure
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.7 2001/05/01 00:07:25 csapuntz Exp $	*/
d81 1
a81 1
	/* Keeps track of the number of resets that have occured in a row
@


1.7
log
@

Add fields to keep track of reset capabilities and resets better
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.6 2001/03/25 13:11:56 csapuntz Exp $	*/
d37 2
a38 3
/* Hight-level functions and structures used by both ATA and ATAPI devices */

struct ataparams;
d42 3
a44 3
    u_int8_t drive; /* drive number */
    int8_t ata_vers; /* ATA version supported */
    u_int16_t drive_flags; /* bitmask for drives present/absent and cap */
d58 17
a74 17
    /*
     * Current setting of drive's PIO, DMA and UDMA modes.
     * Is initialised by the disks drivers at attach time, and may be
     * changed later by the controller's code if needed
     */
    u_int8_t PIO_mode; /* Current setting of drive's PIO mode */
    u_int8_t DMA_mode; /* Current setting of drive's DMA mode */
    u_int8_t UDMA_mode; /* Current setting of drive's UDMA mode */
    /* Supported modes for this drive */
    u_int8_t PIO_cap; /* supported drive's PIO mode */
    u_int8_t DMA_cap; /* supported drive's DMA mode */
    u_int8_t UDMA_cap; /* supported drive's UDMA mode */
    /*
     * Drive state. This is drive-type (ATA or ATAPI) dependant
     * This is reset to 0 after a channel reset.
     */
    u_int8_t state;
d78 2
a79 2
    /* 0x20-0x40 reserved for ATAPI_CFG_DRQ_MASK */
    u_int8_t atapi_cap;
d81 5
a85 5
    /* Keeps track of the number of resets that have occured in a row
       without a succesful command completion. */
    u_int8_t n_resets;
    u_int8_t n_dmaerrs;
    u_int32_t n_xfers;
d89 5
a93 3
    char drive_name[31];
    int  cf_flags;
    void *chnl_softc; /* channel softc */
a176 1
struct ataparams;
@


1.6
log
@Minor mods to DMA interface - get rid of unnecessary args. Allow DMA functions to return status flags.

Note: Changing code to have DMA interface indicate when I/O is done (a la NetBSD) was considered. It was rejected due to questionable backward compatability
with ISA DMA and MAC obio DMA

Added irqack from NetBSD (though this feature should really be in the
PCI interrupt handlers)

Use pool
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.5 2000/04/10 07:06:16 csapuntz Exp $	*/
d58 1
a58 1

d82 3
@


1.5
log
@

Added support for wd detach (merge from NetBSD). Support for
SCSI/ATAPI detach is not here yet.

Minor cleanup of wdc. Downgrade to UDMA mode 1 before going further.
Want to stay in UDMA modes because they're more error-resilient due to
a CRC.

Got rid of some of the ridiculous amount of softc sharing going on.
Hopefully, this will make the life of whoever goes in and fixes the
ref-counting to be correct easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.4 1999/10/09 03:42:03 csapuntz Exp $	*/
a81 1
    /* Number of DMA errors. Reset to 0 after every successful transfers. */
d83 3
a85 2
    /* downgrade mode after this many successive errors */
#define NERRS_MAX 2
d171 1
d182 1
@


1.4
log
@

wdc layer work:
Separate wdc_probe_caps into wdc_probe_caps and wdc_print_caps for more
flexibility in printing capability information.

Get rid of wdc_final_attach.

Include name of device (e.g. cd0), if possible, on errors.

atapiscsi layer work:
Put a pointer to the SCSI device into ata_drive_datas' drv_softc field

Simplify, simplify, simplify. Got rid of a bunch of fields in atapiscsi_softc

Delay printing capabilities until we know the real device name (e.g. st0)
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.3 1999/09/05 21:45:22 niklas Exp $	*/
d58 1
d87 2
a88 1
    struct device *drv_softc; /* ATA/PI drive's softc, can be NULL */
d155 2
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.6 2001/03/25 13:11:56 csapuntz Exp $	*/
a57 1

d81 1
d83 2
a84 3
    u_int32_t n_xfers;
#define NERRS_MAX 4
#define NXFER 1000
d86 1
a86 2
    char drive_name[31];
    int  cf_flags;
a153 2
extern int at_poll;

a166 1
void wdc_ata_kill_pending __P((struct ata_drive_datas *));
a176 1
void ata_dmaerr __P((struct ata_drive_datas *));
@


1.4.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.4.4.1 2001/05/14 22:23:05 niklas Exp $	*/
d37 3
a39 2
/* High-level functions and structures used by both ATA and ATAPI devices */
#include <dev/ata/atareg.h>
d43 3
a45 3
	u_int8_t drive; /* drive number */
	int8_t ata_vers; /* ATA version supported */
	u_int16_t drive_flags; /* bitmask for drives present/absent and cap */
d58 18
a75 18
#define DRIVE_DEVICE_RESET 0x0800 /* Drive supports DEVICE RESET command */
	/*
	 * Current setting of drive's PIO, DMA and UDMA modes.
	 * Is initialised by the disks drivers at attach time, and may be
	 * changed later by the controller's code if needed
	 */
	u_int8_t PIO_mode; /* Current setting of drive's PIO mode */
	u_int8_t DMA_mode; /* Current setting of drive's DMA mode */
	u_int8_t UDMA_mode; /* Current setting of drive's UDMA mode */
	/* Supported modes for this drive */
	u_int8_t PIO_cap; /* supported drive's PIO mode */
	u_int8_t DMA_cap; /* supported drive's DMA mode */
	u_int8_t UDMA_cap; /* supported drive's UDMA mode */
	/*
	 * Drive state. This is drive-type (ATA or ATAPI) dependant
	 * This is reset to 0 after a channel reset.
	 */
	u_int8_t state;
d79 2
a80 2
	/* 0x20-0x40 reserved for ATAPI_CFG_DRQ_MASK */
	u_int8_t atapi_cap;
d82 2
a83 5
	/* Keeps track of the number of resets that have occured in a row
	   without a succesful command completion. */
	u_int8_t n_resets;
	u_int8_t n_dmaerrs;
	u_int32_t n_xfers;
d87 3
a89 5
	char drive_name[31];
	int  cf_flags;
	void *chnl_softc; /* channel softc */
    
	struct ataparams id;
d173 1
@


1.4.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.4.4.2 2001/07/04 10:40:16 niklas Exp $	*/
d81 1
a81 1
	/* Keeps track of the number of resets that have occurred in a row
@


1.4.4.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d156 1
a156 1
    void (*callback)(void *); /* command to call once command completed */
d162 1
a162 1
int wdc_exec_command(struct ata_drive_datas *, struct wdc_command*);
d167 13
a179 13
void wdc_probe_caps(struct ata_drive_datas*, struct ataparams *);
void wdc_print_caps(struct ata_drive_datas*);
int  wdc_downgrade_mode(struct ata_drive_datas*);

void wdc_reset_channel(struct ata_drive_datas *);

int wdc_ata_addref(struct ata_drive_datas *);
void wdc_ata_delref(struct ata_drive_datas *);
void wdc_ata_kill_pending(struct ata_drive_datas *);

int ata_get_params(struct ata_drive_datas*, u_int8_t,
	 struct ataparams *);
int ata_set_mode(struct ata_drive_datas*, u_int8_t, u_int8_t);
d185 2
a186 2
void ata_dmaerr(struct ata_drive_datas *);
void ata_perror(struct ata_drive_datas *, int, char *);
@


1.4.4.5
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a5 1
 * Copyright (c) 1998, 2001 Manuel Bouyer.
d17 2
a18 1
 *	This product includes software developed by Manuel Bouyer.
d23 11
a33 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.4.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.4.4.5 2003/03/28 00:38:10 niklas Exp $	*/
d184 1
a184 1
void ata_perror(struct ata_drive_datas *, int, char *, size_t);
@


1.4.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d25 1
a25 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
d45 1
a45 1
#define DRIVE_OLD	0x0004
d48 1
a48 1
#define DRIVE_DMA	0x0010
a55 1
#define DRIVE_SATA	0x1000 /* SATA drive */
d80 1
a80 1
	   without a successful command completion. */
d90 1
a90 1

d119 1
a119 1
 * ATA/ATAPI commands description
d151 1
a151 1
    int timeout;         /* timeout (in ms) */
d153 1
a153 1
    int bcount;          /* number of bytes to transfer */
d161 2
a162 2
#define WDC_COMPLETE  0x01
#define WDC_QUEUED    0x02
d176 1
a176 1
	struct ataparams *);
@


1.3
log
@Support for ATAPI tapes, works but still has some rough edges.  Some style.
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.2 1999/07/22 02:51:15 csapuntz Exp $	*/
d39 2
d86 1
a86 1
    struct device *drv_softc; /* ATA drives softc, if any */
d159 2
a160 1
void wdc_probe_caps __P((struct ata_drive_datas*));
@


1.2
log
@

Added ATAPI capabilities to the increasingly poorly named ata_drive_datas
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.1 1999/07/18 21:25:17 csapuntz Exp $	*/
d54 2
d75 1
d85 1
a85 1
    void* chnl_softc; /* channel softc */
@


1.1
log
@

Import of NetBSD ATA/IDE stuff.

Introduction of home-grown

To enable this stuff in your configuration, look at the NEWATA conf file
and go through

dev/isa/files.isa
dev/pci/files.pci
conf/files
arch/i386/conf/files.i386

and follow the instructions on commenting/uncommenting stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: atavar.h,v 1.13 1999/03/10 13:11:43 bouyer Exp $	*/
d71 4
@

