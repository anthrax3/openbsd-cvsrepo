head	1.120;
access;
symbols
	OPENBSD_6_1:1.120.0.6
	OPENBSD_6_1_BASE:1.120
	OPENBSD_6_0:1.120.0.4
	OPENBSD_6_0_BASE:1.120
	OPENBSD_5_9:1.120.0.2
	OPENBSD_5_9_BASE:1.120
	OPENBSD_5_8:1.117.0.6
	OPENBSD_5_8_BASE:1.117
	OPENBSD_5_7:1.117.0.4
	OPENBSD_5_7_BASE:1.117
	OPENBSD_5_6:1.116.0.4
	OPENBSD_5_6_BASE:1.116
	OPENBSD_5_5:1.114.0.4
	OPENBSD_5_5_BASE:1.114
	OPENBSD_5_4:1.110.0.2
	OPENBSD_5_4_BASE:1.110
	OPENBSD_5_3:1.109.0.2
	OPENBSD_5_3_BASE:1.109
	OPENBSD_5_2:1.108.0.6
	OPENBSD_5_2_BASE:1.108
	OPENBSD_5_1_BASE:1.108
	OPENBSD_5_1:1.108.0.4
	OPENBSD_5_0:1.108.0.2
	OPENBSD_5_0_BASE:1.108
	OPENBSD_4_9:1.97.0.2
	OPENBSD_4_9_BASE:1.97
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.77.0.2
	OPENBSD_4_7_BASE:1.77
	OPENBSD_4_6:1.75.0.4
	OPENBSD_4_6_BASE:1.75
	OPENBSD_4_5:1.73.0.2
	OPENBSD_4_5_BASE:1.73
	OPENBSD_4_4:1.71.0.2
	OPENBSD_4_4_BASE:1.71
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.66.0.2
	OPENBSD_4_2_BASE:1.66
	OPENBSD_4_1:1.53.0.2
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.46.0.2
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.41.0.4
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.40
	SMP_SYNC_B:1.40
	OPENBSD_3_5:1.40.0.2
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.25
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9;
locks; strict;
comment	@ * @;


1.120
date	2016.01.20.17.23.58;	author stefan;	state Exp;
branches;
next	1.119;
commitid	iJEmZe6Wd2Rh90CY;

1.119
date	2015.08.26.22.29.39;	author deraadt;	state Exp;
branches;
next	1.118;
commitid	9UUhRItijkeDy08a;

1.118
date	2015.08.17.15.36.29;	author krw;	state Exp;
branches;
next	1.117;
commitid	Le3SuX5chjCNZy3I;

1.117
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.116;
commitid	uzzBR7hz9ncd4O6G;

1.116
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.115;
commitid	I19imNlAX05zJOED;

1.115
date	2014.07.10.14.21.20;	author deraadt;	state Exp;
branches;
next	1.114;
commitid	Jjzk0Y0KSLF2oro4;

1.114
date	2013.10.14.23.33.13;	author krw;	state Exp;
branches;
next	1.113;

1.113
date	2013.10.14.23.26.23;	author krw;	state Exp;
branches;
next	1.112;

1.112
date	2013.09.27.12.12.16;	author krw;	state Exp;
branches;
next	1.111;

1.111
date	2013.09.15.13.44.53;	author krw;	state Exp;
branches;
next	1.110;

1.110
date	2013.06.11.16.42.14;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2011.07.06.04.49.36;	author matthew;	state Exp;
branches;
next	1.107;

1.107
date	2011.06.30.16.28.05;	author matthew;	state Exp;
branches;
next	1.106;

1.106
date	2011.06.20.06.45.07;	author matthew;	state Exp;
branches;
next	1.105;

1.105
date	2011.06.19.04.55.34;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2011.06.19.04.35.06;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.102;

1.102
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.101;

1.101
date	2011.05.31.17.35.35;	author matthew;	state Exp;
branches;
next	1.100;

1.100
date	2011.04.18.04.16.13;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2011.04.15.20.53.28;	author miod;	state Exp;
branches;
next	1.98;

1.98
date	2011.04.05.19.57.40;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2010.12.31.22.58.40;	author kettenis;	state Exp;
branches;
next	1.96;

1.96
date	2010.12.30.20.29.13;	author kettenis;	state Exp;
branches;
next	1.95;

1.95
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.94;

1.94
date	2010.09.20.01.24.08;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.08.15.16.22;	author jsing;	state Exp;
branches;
next	1.92;

1.92
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.91;

1.91
date	2010.09.01.01.38.12;	author dlg;	state Exp;
branches;
next	1.90;

1.90
date	2010.08.31.17.00.32;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.22.21.40.46;	author kettenis;	state Exp;
branches;
next	1.86;

1.86
date	2010.07.22.18.10.37;	author mlarkin;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.28.08.35.46;	author jsing;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.07.20.32.45;	author jsg;	state Exp;
branches;
next	1.83;

1.83
date	2010.05.26.16.16.23;	author thib;	state Exp;
branches;
next	1.82;

1.82
date	2010.05.24.11.18.50;	author kettenis;	state Exp;
branches;
next	1.81;

1.81
date	2010.05.23.09.58.57;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.79;

1.79
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.78;

1.78
date	2010.04.11.16.58.06;	author kettenis;	state Exp;
branches;
next	1.77;

1.77
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.76;

1.76
date	2009.08.13.15.23.12;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2009.06.17.01.30.30;	author thib;	state Exp;
branches;
next	1.74;

1.74
date	2009.06.03.22.09.30;	author thib;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.08.01.32.06;	author chl;	state Exp;
branches;
next	1.72;

1.72
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.71;

1.71
date	2008.06.27.06.03.08;	author ray;	state Exp;
branches;
next	1.70;

1.70
date	2008.06.15.00.36.41;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2008.02.07.12.58.30;	author sthen;	state Exp;
branches;
next	1.68;

1.68
date	2007.12.05.23.11.34;	author jsg;	state Exp;
branches;
next	1.67;

1.67
date	2007.11.26.23.59.01;	author jsg;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.18.20.55.52;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.07.03.50.20;	author ray;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.05.00.38.20;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.31.05.24.06;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.28.02.24.21;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.27.11.37.56;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.26.22.42.11;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2007.03.27.23.32.55;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2007.03.25.18.05.49;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.15.00.53.26;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.06.03.17.24;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2006.10.17.23.20.12;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2006.10.04.00.52.55;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.21.12.09.01;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.12.13.53.44;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.05.22.49.22;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2006.01.21.12.18.47;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2005.11.09.19.05.48;	author uwe;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.01.02.16.56;	author uwe;	state Exp;
branches;
next	1.43;

1.43
date	2005.08.27.14.14.48;	author jsg;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.15.18.09.29;	author grange;	state Exp;
branches;
next	1.41;

1.41
date	2004.07.06.00.38.38;	author aaron;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.03.17.16.03;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.02.21.29.38;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.21.21.00.14;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.16.21.00.57;	author grange;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.15.21.37.57;	author grange;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.21.09.57.04;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.28.21.01.42;	author grange;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.20.19.57.04;	author grange;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.25.20.52.57;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.20.03.59.35;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.09.00.38.08;	author ho;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.06.15.28.25;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.21.20.10.33;	author grange;	state Exp;
branches;
next	1.26;

1.26
date	2002.12.19.16.32.59;	author grange;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.24.09.34.25;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.03.09.18.46;	author gluk;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.03.16.03;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.07.19.04.46;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.08.06.20.50.28;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.31.07.07.00;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.12.02.44.17;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.30.21.19.45;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.02.19.41.35;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.25.03.50.50;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.30.06.56.24;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.10.07.06.16;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.07.09.12.44;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.11.17.01.22.55;	author csapuntz;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.10.09.07.14.00;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	99.10.09.03.42.03;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	99.08.15.09.47.18;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.08.10.23.09.49;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.08.05.00.12.09;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.07.22.04.36.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.07.22.04.00.42;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	99.07.20.03.23.05;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	99.07.18.21.25.17;	author csapuntz;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.14.22.23.06;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.07.04.10.40.17;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.11.13.21.09.59;	author niklas;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2003.05.13.19.34.56;	author ho;	state Exp;
branches;
next	1.10.2.9;

1.10.2.9
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.10.2.10;

1.10.2.10
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	1.10.2.11;

1.10.2.11
date	2004.06.05.23.12.37;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.01.31.22.55.30;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.120
log
@Set segflg member of uio struct with symbolic enum value
instead of using magic numbers. No binary change.

Diff from Martin Natano.

ok deraadt@@
@
text
@/*	$OpenBSD: wd.c,v 1.119 2015/08/26 22:29:39 deraadt Exp $ */
/*	$NetBSD: wd.c,v 1.193 1999/02/28 17:15:27 explorer Exp $ */

/*
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *	notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *	notice, this list of conditions and the following disclaimer in the
 *	documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Onno van der Linden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#if 0
#include "rnd.h"
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/mutex.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/syslog.h>
#include <sys/timeout.h>
#include <sys/vnode.h>
#include <sys/dkio.h>
#include <sys/reboot.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/ata/atareg.h>
#include <dev/ata/atavar.h>
#include <dev/ata/wdvar.h>
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcvar.h>
#if 0
#include "locators.h"
#endif

#define	LBA48_THRESHOLD		(0xfffffff)	/* 128GB / DEV_BSIZE */

#define	WDIORETRIES_SINGLE 4	/* number of retries before single-sector */
#define	WDIORETRIES	5	/* number of retries before giving up */
#define	RECOVERYTIME hz/2	/* time to wait before retrying a cmd */

#define DEBUG_INTR   0x01
#define DEBUG_XFERS  0x02
#define DEBUG_STATUS 0x04
#define DEBUG_FUNCS  0x08
#define DEBUG_PROBE  0x10
#ifdef WDCDEBUG
extern int wdcdebug_wd_mask; /* init'ed in ata_wdc.c */
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_wd_mask & (level)) != 0)	\
		printf args;			\
} while (0)
#else
#define WDCDEBUG_PRINT(args, level)
#endif


#define sc_drive sc_wdc_bio.drive
#define sc_mode sc_wdc_bio.mode
#define sc_multi sc_wdc_bio.multi

int	wdprobe(struct device *, void *, void *);
void	wdattach(struct device *, struct device *, void *);
int	wddetach(struct device *, int);
int	wdactivate(struct device *, int);
int	wdprint(void *, char *);

struct cfattach wd_ca = {
	sizeof(struct wd_softc), wdprobe, wdattach,
	wddetach, wdactivate
};

struct cfdriver wd_cd = {
	NULL, "wd", DV_DISK
};

void  wdgetdefaultlabel(struct wd_softc *, struct disklabel *);
int   wdgetdisklabel(dev_t dev, struct wd_softc *, struct disklabel *, int);
void  wdstrategy(struct buf *);
void  wdstart(void *);
void  __wdstart(struct wd_softc*, struct buf *);
void  wdrestart(void *);
int   wd_get_params(struct wd_softc *, u_int8_t, struct ataparams *);
void  wd_flushcache(struct wd_softc *, int);
void  wd_standby(struct wd_softc *, int);

/* XXX: these should go elsewhere */
cdev_decl(wd);
bdev_decl(wd);

#define wdlookup(unit) (struct wd_softc *)disk_lookup(&wd_cd, (unit))


int
wdprobe(struct device *parent, void *match_, void *aux)
{
	struct ata_atapi_attach *aa_link = aux;
	struct cfdata *match = match_;

	if (aa_link == NULL)
		return 0;
	if (aa_link->aa_type != T_ATA)
		return 0;

	if (match->cf_loc[0] != -1 &&
	    match->cf_loc[0] != aa_link->aa_channel)
		return 0;

	if (match->cf_loc[1] != -1 &&
	    match->cf_loc[1] != aa_link->aa_drv_data->drive)
		return 0;

	return 1;
}

void
wdattach(struct device *parent, struct device *self, void *aux)
{
	struct wd_softc *wd = (void *)self;
	struct ata_atapi_attach *aa_link= aux;
	struct wdc_command wdc_c;
	int i, blank;
	char buf[41], c, *p, *q;
	WDCDEBUG_PRINT(("wdattach\n"), DEBUG_FUNCS | DEBUG_PROBE);

	wd->openings = aa_link->aa_openings;
	wd->drvp = aa_link->aa_drv_data;

	strlcpy(wd->drvp->drive_name, wd->sc_dev.dv_xname,
	    sizeof(wd->drvp->drive_name));
	wd->drvp->cf_flags = wd->sc_dev.dv_cfdata->cf_flags;

	if ((NERRS_MAX - 2) > 0)
		wd->drvp->n_dmaerrs = NERRS_MAX - 2;
	else
		wd->drvp->n_dmaerrs = 0;

	/* read our drive info */
	if (wd_get_params(wd, at_poll, &wd->sc_params) != 0) {
		printf("%s: IDENTIFY failed\n", wd->sc_dev.dv_xname);
		return;
	}

	for (blank = 0, p = wd->sc_params.atap_model, q = buf, i = 0;
	    i < sizeof(wd->sc_params.atap_model); i++) {
		c = *p++;
		if (c == '\0')
			break;
		if (c != ' ') {
			if (blank) {
				*q++ = ' ';
				blank = 0;
			}
			*q++ = c;
		} else
			blank = 1;
		}
	*q++ = '\0';

	printf(": <%s>\n", buf);

	wdc_probe_caps(wd->drvp, &wd->sc_params);
	wdc_print_caps(wd->drvp);

	if ((wd->sc_params.atap_multi & 0xff) > 1) {
		wd->sc_multi = wd->sc_params.atap_multi & 0xff;
	} else {
		wd->sc_multi = 1;
	}

	printf("%s: %d-sector PIO,", wd->sc_dev.dv_xname, wd->sc_multi);

	/* use 48-bit LBA if enabled */
	/* XXX: shall we use it if drive capacity < 137Gb? */
	if ((wd->sc_params.atap_cmd2_en & ATAPI_CMD2_48AD) != 0)
		wd->sc_flags |= WDF_LBA48;

	/* Prior to ATA-4, LBA was optional. */
	if ((wd->sc_params.atap_capabilities1 & WDC_CAP_LBA) != 0)
		wd->sc_flags |= WDF_LBA;
#if 0
	/* ATA-4 requires LBA. */
	if (wd->sc_params.atap_ataversion != 0xffff &&
	    wd->sc_params.atap_ataversion >= WDC_VER_ATA4)
		wd->sc_flags |= WDF_LBA;
#endif

	if ((wd->sc_flags & WDF_LBA48) != 0) {
		wd->sc_capacity =
		    (((u_int64_t)wd->sc_params.atap_max_lba[3] << 48) |
		     ((u_int64_t)wd->sc_params.atap_max_lba[2] << 32) |
		     ((u_int64_t)wd->sc_params.atap_max_lba[1] << 16) |
		      (u_int64_t)wd->sc_params.atap_max_lba[0]);
		printf(" LBA48, %lluMB, %llu sectors\n",
		    wd->sc_capacity / (1048576 / DEV_BSIZE),
		    wd->sc_capacity);
	} else if ((wd->sc_flags & WDF_LBA) != 0) {
		wd->sc_capacity =
		    (wd->sc_params.atap_capacity[1] << 16) |
		    wd->sc_params.atap_capacity[0];
		printf(" LBA, %lluMB, %llu sectors\n",
		    wd->sc_capacity / (1048576 / DEV_BSIZE),
		    wd->sc_capacity);
	} else {
		wd->sc_capacity =
		    wd->sc_params.atap_cylinders *
		    wd->sc_params.atap_heads *
		    wd->sc_params.atap_sectors;
		printf(" CHS, %lluMB, %d cyl, %d head, %d sec, %llu sectors\n",
		    wd->sc_capacity / (1048576 / DEV_BSIZE),
		    wd->sc_params.atap_cylinders,
		    wd->sc_params.atap_heads,
		    wd->sc_params.atap_sectors,
		    wd->sc_capacity);
	}
	WDCDEBUG_PRINT(("%s: atap_dmatiming_mimi=%d, atap_dmatiming_recom=%d\n",
	    self->dv_xname, wd->sc_params.atap_dmatiming_mimi,
	    wd->sc_params.atap_dmatiming_recom), DEBUG_PROBE);

	/* use read look ahead if supported */
	if (wd->sc_params.atap_cmd_set1 & WDC_CMD1_AHEAD) {
		bzero(&wdc_c, sizeof(struct wdc_command));
		wdc_c.r_command = SET_FEATURES;
		wdc_c.r_features = WDSF_READAHEAD_EN;
		wdc_c.timeout = 1000;
		wdc_c.flags = at_poll;

		if (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {
			printf("%s: enable look ahead command didn't "
			    "complete\n", wd->sc_dev.dv_xname);
		}
	}

	/* use write cache if supported */
	if (wd->sc_params.atap_cmd_set1 & WDC_CMD1_CACHE) {
		bzero(&wdc_c, sizeof(struct wdc_command));
		wdc_c.r_command = SET_FEATURES;
		wdc_c.r_features = WDSF_EN_WR_CACHE;
		wdc_c.timeout = 1000;
		wdc_c.flags = at_poll;
	
		if (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {
			printf("%s: enable write cache command didn't "
			    "complete\n", wd->sc_dev.dv_xname);
		}
	}

	/*
	 * FREEZE LOCK the drive so malicous users can't lock it on us.
	 * As there is no harm in issuing this to drives that don't
	 * support the security feature set we just send it, and don't
	 * bother checking if the drive sends a command abort to tell us it
	 * doesn't support it.
	 */
	bzero(&wdc_c, sizeof(struct wdc_command));

	wdc_c.r_command = WDCC_SEC_FREEZE_LOCK;
	wdc_c.timeout = 1000;
	wdc_c.flags = at_poll;
	if (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {
		printf("%s: freeze lock command didn't complete\n",
		    wd->sc_dev.dv_xname);
	}

	/*
	 * Initialize disk structures.
	 */
	wd->sc_dk.dk_name = wd->sc_dev.dv_xname;
	bufq_init(&wd->sc_bufq, BUFQ_DEFAULT);
	timeout_set(&wd->sc_restart_timeout, wdrestart, wd);

	/* Attach disk. */
	disk_attach(&wd->sc_dev, &wd->sc_dk);
	wd->sc_wdc_bio.lp = wd->sc_dk.dk_label;
}

int
wdactivate(struct device *self, int act)
{
	struct wd_softc *wd = (void *)self;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		break;
	case DVACT_POWERDOWN:
		wd_flushcache(wd, AT_POLL);
		if (boothowto & RB_POWERDOWN)
			wd_standby(wd, AT_POLL);
		break;
	case DVACT_RESUME:
		/*
		 * Do two resets separated by a small delay. The
		 * first wakes the controller, the second resets
		 * the channel.
		 */
		wdc_disable_intr(wd->drvp->chnl_softc);
		wdc_reset_channel(wd->drvp, 1);
		delay(10000);
		wdc_reset_channel(wd->drvp, 0);
		wdc_enable_intr(wd->drvp->chnl_softc);
		wd_get_params(wd, at_poll, &wd->sc_params);
		break;
	}
	return (rv);
}

int
wddetach(struct device *self, int flags)
{
	struct wd_softc *sc = (struct wd_softc *)self;

	timeout_del(&sc->sc_restart_timeout);

	bufq_drain(&sc->sc_bufq);

	disk_gone(wdopen, self->dv_unit);

	/* Detach disk. */
	bufq_destroy(&sc->sc_bufq);
	disk_detach(&sc->sc_dk);

	return (0);
}

/*
 * Read/write routine for a buffer.  Validates the arguments and schedules the
 * transfer.  Does not wait for the transfer to complete.
 */
void
wdstrategy(struct buf *bp)
{
	struct wd_softc *wd;
	int s;

	wd = wdlookup(DISKUNIT(bp->b_dev));
	if (wd == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}

	WDCDEBUG_PRINT(("wdstrategy (%s)\n", wd->sc_dev.dv_xname),
	    DEBUG_XFERS);

	/* If device invalidated (e.g. media change, door open), error. */
	if ((wd->sc_flags & WDF_LOADED) == 0) {
		bp->b_error = EIO;
		goto bad;
	}

	/* Validate the request. */
	if (bounds_check_with_label(bp, wd->sc_dk.dk_label) == -1)
		goto done;

	/* Check that the number of sectors can fit in a byte. */
	if ((bp->b_bcount / wd->sc_dk.dk_label->d_secsize) >= (1 << NBBY)) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* Queue transfer on drive, activate drive and controller if idle. */
	bufq_queue(&wd->sc_bufq, bp);
	s = splbio();
	wdstart(wd);
	splx(s);
	device_unref(&wd->sc_dev);
	return;

 bad:
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:
	s = splbio();
	biodone(bp);
	splx(s);
	if (wd != NULL)
		device_unref(&wd->sc_dev);
}

/*
 * Queue a drive for I/O.
 */
void
wdstart(void *arg)
{
	struct wd_softc *wd = arg;
	struct buf *bp = NULL;

	WDCDEBUG_PRINT(("wdstart %s\n", wd->sc_dev.dv_xname),
	    DEBUG_XFERS);
	while (wd->openings > 0) {

		/* Is there a buf for us ? */
		if ((bp = bufq_dequeue(&wd->sc_bufq)) == NULL)
			return;
		/*
		 * Make the command. First lock the device
		 */
		wd->openings--;

		wd->retries = 0;
		__wdstart(wd, bp);
	}
}

void
__wdstart(struct wd_softc *wd, struct buf *bp)
{
	struct disklabel *lp;
	u_int64_t nsecs;

	lp = wd->sc_dk.dk_label;
	wd->sc_wdc_bio.blkno = DL_BLKTOSEC(lp, bp->b_blkno + DL_SECTOBLK(lp,
	    DL_GETPOFFSET(&lp->d_partitions[DISKPART(bp->b_dev)])));
	wd->sc_wdc_bio.blkdone =0;
	wd->sc_bp = bp;
	/*
	 * If we're retrying, retry in single-sector mode. This will give us
	 * the sector number of the problem, and will eventually allow the
	 * transfer to succeed.
	 */
	if (wd->retries >= WDIORETRIES_SINGLE)
		wd->sc_wdc_bio.flags = ATA_SINGLE;
	else
		wd->sc_wdc_bio.flags = 0;
	nsecs = howmany(bp->b_bcount, lp->d_secsize);
	if ((wd->sc_flags & WDF_LBA48) &&
	    /* use LBA48 only if really need */
	    ((wd->sc_wdc_bio.blkno + nsecs - 1 >= LBA48_THRESHOLD) ||
	     (nsecs > 0xff)))
		wd->sc_wdc_bio.flags |= ATA_LBA48;
	if (wd->sc_flags & WDF_LBA)
		wd->sc_wdc_bio.flags |= ATA_LBA;
	if (bp->b_flags & B_READ)
		wd->sc_wdc_bio.flags |= ATA_READ;
	wd->sc_wdc_bio.bcount = bp->b_bcount;
	wd->sc_wdc_bio.databuf = bp->b_data;
	wd->sc_wdc_bio.wd = wd;
	/* Instrumentation. */
	disk_busy(&wd->sc_dk);
	switch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {
	case WDC_TRY_AGAIN:
		timeout_add_sec(&wd->sc_restart_timeout, 1);
		break;
	case WDC_QUEUED:
		break;
	case WDC_COMPLETE:
		/*
		 * This code is never executed because we never set
		 * the ATA_POLL flag above
		 */
#if 0
		if (wd->sc_wdc_bio.flags & ATA_POLL)
			wddone(wd);
#endif
		break;
	default:
		panic("__wdstart: bad return code from wdc_ata_bio()");
	}
}

void
wddone(void *v)
{
	struct wd_softc *wd = v;
	struct buf *bp = wd->sc_bp;
	char buf[256], *errbuf = buf;
	WDCDEBUG_PRINT(("wddone %s\n", wd->sc_dev.dv_xname),
	    DEBUG_XFERS);

	bp->b_resid = wd->sc_wdc_bio.bcount;
	errbuf[0] = '\0';
	switch (wd->sc_wdc_bio.error) {
	case ERR_NODEV:
		bp->b_flags |= B_ERROR;
		bp->b_error = ENXIO;
		break;
	case ERR_DMA:
		errbuf = "DMA error";
		goto retry;
	case ERR_DF:
		errbuf = "device fault";
		goto retry;
	case TIMEOUT:
		errbuf = "device timeout";
		goto retry;
	case ERROR:
		/* Don't care about media change bits */
		if (wd->sc_wdc_bio.r_error != 0 &&
		    (wd->sc_wdc_bio.r_error & ~(WDCE_MC | WDCE_MCR)) == 0)
			goto noerror;
		ata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf,
		    sizeof buf);
retry:
		/* Just reset and retry. Can we do more ? */
		wdc_reset_channel(wd->drvp, 0);
		diskerr(bp, "wd", errbuf, LOG_PRINTF,
		    wd->sc_wdc_bio.blkdone, wd->sc_dk.dk_label);
		if (wd->retries++ < WDIORETRIES) {
			printf(", retrying\n");
			timeout_add(&wd->sc_restart_timeout, RECOVERYTIME);
			return;
		}
		printf("\n");
		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
		break;
	case NOERROR:
noerror:	if ((wd->sc_wdc_bio.flags & ATA_CORR) || wd->retries > 0)
			printf("%s: soft error (corrected)\n",
			    wd->sc_dev.dv_xname);
	}
	disk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));
	biodone(bp);
	wd->openings++;
	wdstart(wd);
}

void
wdrestart(void *v)
{
	struct wd_softc *wd = v;
	struct buf *bp = wd->sc_bp;
	struct channel_softc *chnl;
	int s;
	WDCDEBUG_PRINT(("wdrestart %s\n", wd->sc_dev.dv_xname),
	    DEBUG_XFERS);

	chnl = (struct channel_softc *)(wd->drvp->chnl_softc);
	if (chnl->dying)
		return;

	s = splbio();
	disk_unbusy(&wd->sc_dk, 0, (bp->b_flags & B_READ));
	__wdstart(v, bp);
	splx(s);
}

int
wdread(dev_t dev, struct uio *uio, int flags)
{

	WDCDEBUG_PRINT(("wdread\n"), DEBUG_XFERS);
	return (physio(wdstrategy, dev, B_READ, minphys, uio));
}

int
wdwrite(dev_t dev, struct uio *uio, int flags)
{

	WDCDEBUG_PRINT(("wdwrite\n"), DEBUG_XFERS);
	return (physio(wdstrategy, dev, B_WRITE, minphys, uio));
}

int
wdopen(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct wd_softc *wd;
	struct channel_softc *chnl;
	int unit, part;
	int error;

	WDCDEBUG_PRINT(("wdopen\n"), DEBUG_FUNCS);

	unit = DISKUNIT(dev);
	wd = wdlookup(unit);
	if (wd == NULL)
		return ENXIO;
	chnl = (struct channel_softc *)(wd->drvp->chnl_softc);
	if (chnl->dying)
		return (ENXIO);

	/*
	 * If this is the first open of this device, add a reference
	 * to the adapter.
	 */
	if ((error = disk_lock(&wd->sc_dk)) != 0)
		goto bad4;

	if (wd->sc_dk.dk_openmask != 0) {
		/*
		 * If any partition is open, but the disk has been invalidated,
		 * disallow further opens.
		 */
		if ((wd->sc_flags & WDF_LOADED) == 0) {
			error = EIO;
			goto bad3;
		}
	} else {
		if ((wd->sc_flags & WDF_LOADED) == 0) {
			wd->sc_flags |= WDF_LOADED;

			/* Load the physical device parameters. */
			wd_get_params(wd, AT_WAIT, &wd->sc_params);

			/* Load the partition info if not already loaded. */
			if (wdgetdisklabel(dev, wd,
			    wd->sc_dk.dk_label, 0) == EIO) {
				error = EIO;
				goto bad;
			}
		}
	}

	part = DISKPART(dev);

	if ((error = disk_openpart(&wd->sc_dk, part, fmt, 1)) != 0)
		goto bad;

	disk_unlock(&wd->sc_dk);
	device_unref(&wd->sc_dev);
	return 0;

bad:
	if (wd->sc_dk.dk_openmask == 0) {
	}

bad3:
	disk_unlock(&wd->sc_dk);
bad4:
	device_unref(&wd->sc_dev);
	return error;
}

int
wdclose(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct wd_softc *wd;
	int part = DISKPART(dev);

	wd = wdlookup(DISKUNIT(dev));
	if (wd == NULL)
		return ENXIO;

	WDCDEBUG_PRINT(("wdclose\n"), DEBUG_FUNCS);

	disk_lock_nointr(&wd->sc_dk);

	disk_closepart(&wd->sc_dk, part, fmt);

	if (wd->sc_dk.dk_openmask == 0) {
		wd_flushcache(wd, 0);
		/* XXXX Must wait for I/O to complete! */
	}

	disk_unlock(&wd->sc_dk);

	device_unref(&wd->sc_dev);
	return (0);
}

void
wdgetdefaultlabel(struct wd_softc *wd, struct disklabel *lp)
{
	WDCDEBUG_PRINT(("wdgetdefaultlabel\n"), DEBUG_FUNCS);
	bzero(lp, sizeof(struct disklabel));

	lp->d_secsize = DEV_BSIZE;
	DL_SETDSIZE(lp, wd->sc_capacity);
	lp->d_ntracks = wd->sc_params.atap_heads;
	lp->d_nsectors = wd->sc_params.atap_sectors;
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
	lp->d_ncylinders = DL_GETDSIZE(lp) / lp->d_secpercyl;
	if (wd->drvp->ata_vers == -1) {
		lp->d_type = DTYPE_ST506;
		strncpy(lp->d_typename, "ST506/MFM/RLL", sizeof lp->d_typename);
	} else {
		lp->d_type = DTYPE_ESDI;
		strncpy(lp->d_typename, "ESDI/IDE disk", sizeof lp->d_typename);
	}
	/* XXX - user viscopy() like sd.c */
	strncpy(lp->d_packname, wd->sc_params.atap_model, sizeof lp->d_packname);
	lp->d_flags = 0;
	lp->d_version = 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);
}

/*
 * Fabricate a default disk label, and try to read the correct one.
 */
int
wdgetdisklabel(dev_t dev, struct wd_softc *wd, struct disklabel *lp,
    int spoofonly)
{
	int error;

	WDCDEBUG_PRINT(("wdgetdisklabel\n"), DEBUG_FUNCS);

	wdgetdefaultlabel(wd, lp);

	if (wd->drvp->state > RECAL)
		wd->drvp->drive_flags |= DRIVE_RESET;
	error = readdisklabel(DISKLABELDEV(dev), wdstrategy, lp,
	    spoofonly);
	if (wd->drvp->state > RECAL)
		wd->drvp->drive_flags |= DRIVE_RESET;
	return (error);
}

int
wdioctl(dev_t dev, u_long xfer, caddr_t addr, int flag, struct proc *p)
{
	struct wd_softc *wd;
	struct disklabel *lp;
	int error = 0;

	WDCDEBUG_PRINT(("wdioctl\n"), DEBUG_FUNCS);

	wd = wdlookup(DISKUNIT(dev));
	if (wd == NULL)
		return ENXIO;

	if ((wd->sc_flags & WDF_LOADED) == 0) {
		error = EIO;
		goto exit;
	}

	switch (xfer) {
	case DIOCRLDINFO:
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		wdgetdisklabel(dev, wd, lp, 0);
		bcopy(lp, wd->sc_dk.dk_label, sizeof(*lp));
		free(lp, M_TEMP, sizeof(*lp));
		goto exit;

	case DIOCGPDINFO:
		wdgetdisklabel(dev, wd, (struct disklabel *)addr, 1);
		goto exit;

	case DIOCGDINFO:
		*(struct disklabel *)addr = *(wd->sc_dk.dk_label);
		goto exit;

	case DIOCGPART:
		((struct partinfo *)addr)->disklab = wd->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &wd->sc_dk.dk_label->d_partitions[DISKPART(dev)];
		goto exit;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}

		if ((error = disk_lock(&wd->sc_dk)) != 0)
			goto exit;

		error = setdisklabel(wd->sc_dk.dk_label,
		    (struct disklabel *)addr, wd->sc_dk.dk_openmask);
		if (error == 0) {
			if (wd->drvp->state > RECAL)
				wd->drvp->drive_flags |= DRIVE_RESET;
			if (xfer == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    wdstrategy, wd->sc_dk.dk_label);
		}

		disk_unlock(&wd->sc_dk);
		goto exit;

#ifdef notyet
	case DIOCWFORMAT:
		if ((flag & FWRITE) == 0)
			return EBADF;
		{
		struct format_op *fop;
		struct iovec aiov;
		struct uio auio;

		fop = (struct format_op *)addr;
		aiov.iov_base = fop->df_buf;
		aiov.iov_len = fop->df_count;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_resid = fop->df_count;
		auio.uio_segflg = UIO_USERSPACE;
		auio.uio_offset =
			fop->df_startblk * wd->sc_dk.dk_label->d_secsize;
		auio.uio_procp = p;
		error = physio(wdformat, dev, B_WRITE, minphys, &auio);
		fop->df_count -= auio.uio_resid;
		fop->df_reg[0] = wdc->sc_status;
		fop->df_reg[1] = wdc->sc_error;
		goto exit;
		}
#endif

	default:
		error = wdc_ioctl(wd->drvp, xfer, addr, flag, p);
		goto exit;
	}

#ifdef DIAGNOSTIC
	panic("wdioctl: impossible");
#endif

 exit:
	device_unref(&wd->sc_dev);
	return (error);
}

#ifdef B_FORMAT
int
wdformat(struct buf *bp)
{

	bp->b_flags |= B_FORMAT;
	return wdstrategy(bp);
}
#endif

daddr_t
wdsize(dev_t dev)
{
	struct wd_softc *wd;
	struct disklabel *lp;
	int part, omask;
	daddr_t size;

	WDCDEBUG_PRINT(("wdsize\n"), DEBUG_FUNCS);

	wd = wdlookup(DISKUNIT(dev));
	if (wd == NULL)
		return (-1);

	part = DISKPART(dev);
	omask = wd->sc_dk.dk_openmask & (1 << part);

	if (omask == 0 && wdopen(dev, 0, S_IFBLK, NULL) != 0) {
		size = -1;
		goto exit;
	}

	lp = wd->sc_dk.dk_label;
	size = DL_SECTOBLK(lp, DL_GETPSIZE(&lp->d_partitions[part]));
	if (omask == 0 && wdclose(dev, 0, S_IFBLK, NULL) != 0)
		size = -1;

 exit:
	device_unref(&wd->sc_dev);
	return (size);
}

/* #define WD_DUMP_NOT_TRUSTED if you just want to watch */
static int wddoingadump = 0;
static int wddumprecalibrated = 0;
static int wddumpmulti = 1;

/*
 * Dump core after a system crash.
 */
int
wddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{
	struct wd_softc *wd;	/* disk unit to do the I/O */
	struct disklabel *lp;   /* disk's disklabel */
	int unit, part;
	int nblks;	/* total number of sectors left to write */
	int nwrt;	/* sectors to write with current i/o. */
	int err;
	char errbuf[256];

	/* Check if recursive dump; if so, punt. */
	if (wddoingadump)
		return EFAULT;
	wddoingadump = 1;

	unit = DISKUNIT(dev);
	wd = wdlookup(unit);
	if (wd == NULL)
		return ENXIO;

	part = DISKPART(dev);

	/* Make sure it was initialized. */
	if (wd->drvp->state < READY)
		return ENXIO;

	/* Convert to disk sectors.  Request must be a multiple of size. */
	lp = wd->sc_dk.dk_label;
	if ((size % lp->d_secsize) != 0)
		return EFAULT;
	nblks = size / lp->d_secsize;
	blkno = blkno / (lp->d_secsize / DEV_BSIZE);

	/* Check transfer bounds against partition size. */
	if ((blkno < 0) || ((blkno + nblks) > DL_GETPSIZE(&lp->d_partitions[part])))
		return EINVAL;

	/* Offset block number to start of partition. */
	blkno += DL_GETPOFFSET(&lp->d_partitions[part]);

	/* Recalibrate, if first dump transfer. */
	if (wddumprecalibrated == 0) {
		wddumpmulti = wd->sc_multi;
		wddumprecalibrated = 1;
		wd->drvp->state = RECAL;
	}

	while (nblks > 0) {
		nwrt = min(nblks, wddumpmulti);
		wd->sc_wdc_bio.blkno = blkno;
		wd->sc_wdc_bio.flags = ATA_POLL;
		if (wd->sc_flags & WDF_LBA48)
			wd->sc_wdc_bio.flags |= ATA_LBA48;
		if (wd->sc_flags & WDF_LBA)
			wd->sc_wdc_bio.flags |= ATA_LBA;
		wd->sc_wdc_bio.bcount = nwrt * lp->d_secsize;
		wd->sc_wdc_bio.databuf = va;
		wd->sc_wdc_bio.wd = wd;
#ifndef WD_DUMP_NOT_TRUSTED
		switch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {
		case WDC_TRY_AGAIN:
			panic("wddump: try again");
			break;
		case WDC_QUEUED:
			panic("wddump: polled command has been queued");
			break;
		case WDC_COMPLETE:
			break;
		}
		switch(wd->sc_wdc_bio.error) {
		case TIMEOUT:
			printf("wddump: device timed out");
			err = EIO;
			break;
		case ERR_DF:
			printf("wddump: drive fault");
			err = EIO;
			break;
		case ERR_DMA:
			printf("wddump: DMA error");
			err = EIO;
			break;
		case ERROR:
			errbuf[0] = '\0';
			ata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf,
			    sizeof errbuf);
			printf("wddump: %s", errbuf);
			err = EIO;
			break;
		case NOERROR:
			err = 0;
			break;
		default:
			panic("wddump: unknown error type");
		}
		if (err != 0) {
			printf("\n");
			return err;
		}
#else	/* WD_DUMP_NOT_TRUSTED */
		/* Let's just talk about this first... */
		printf("wd%d: dump addr 0x%x, cylin %d, head %d, sector %d\n",
		    unit, va, cylin, head, sector);
		delay(500 * 1000);	/* half a second */
#endif

		/* update block count */
		nblks -= nwrt;
		blkno += nwrt;
		va += nwrt * lp->d_secsize;
	}

	wddoingadump = 0;
	return 0;
}

int
wd_get_params(struct wd_softc *wd, u_int8_t flags, struct ataparams *params)
{
	switch (ata_get_params(wd->drvp, flags, params)) {
	case CMD_AGAIN:
		return 1;
	case CMD_ERR:
		/* If we already have drive parameters, reuse them. */
		if (wd->sc_params.atap_cylinders != 0) {
			if (params != &wd->sc_params)
				bcopy(&wd->sc_params, params,
				    sizeof(struct ataparams));
			return 0;
		}
		/*
		 * We `know' there's a drive here; just assume it's old.
		 * This geometry is only used to read the MBR and print a
		 * (false) attach message.
		 */
		bzero(params, sizeof(struct ataparams));
		strncpy(params->atap_model, "ST506",
		    sizeof params->atap_model);
		params->atap_config = ATA_CFG_FIXED;
		params->atap_cylinders = 1024;
		params->atap_heads = 8;
		params->atap_sectors = 17;
		params->atap_multi = 1;
		params->atap_capabilities1 = params->atap_capabilities2 = 0;
		wd->drvp->ata_vers = -1; /* Mark it as pre-ATA */
		return 0;
	case CMD_OK:
		return 0;
	default:
		panic("wd_get_params: bad return code from ata_get_params");
		/* NOTREACHED */
	}
}

void
wd_flushcache(struct wd_softc *wd, int flags)
{
	struct wdc_command wdc_c;

	if (wd->drvp->ata_vers < 4) /* WDCC_FLUSHCACHE is here since ATA-4 */
		return;
	bzero(&wdc_c, sizeof(struct wdc_command));
	wdc_c.r_command = (wd->sc_flags & WDF_LBA48 ? WDCC_FLUSHCACHE_EXT :
	    WDCC_FLUSHCACHE);
	wdc_c.r_st_bmask = WDCS_DRDY;
	wdc_c.r_st_pmask = WDCS_DRDY;
	if (flags != 0) {
		wdc_c.flags = AT_POLL;
	} else {
		wdc_c.flags = AT_WAIT;
	}
	wdc_c.timeout = 30000; /* 30s timeout */
	if (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {
		printf("%s: flush cache command didn't complete\n",
		    wd->sc_dev.dv_xname);
	}
	if (wdc_c.flags & AT_TIMEOU) {
		printf("%s: flush cache command timeout\n",
		    wd->sc_dev.dv_xname);
	}
	if (wdc_c.flags & AT_DF) {
		printf("%s: flush cache command: drive fault\n",
		    wd->sc_dev.dv_xname);
	}
	/*
	 * Ignore error register, it shouldn't report anything else
	 * than COMMAND ABORTED, which means the device doesn't support
	 * flush cache
	 */
}

void
wd_standby(struct wd_softc *wd, int flags)
{
	struct wdc_command wdc_c;

	bzero(&wdc_c, sizeof(struct wdc_command));
	wdc_c.r_command = WDCC_STANDBY_IMMED;
	wdc_c.r_st_bmask = WDCS_DRDY;
	wdc_c.r_st_pmask = WDCS_DRDY;
	if (flags != 0) {
		wdc_c.flags = AT_POLL;
	} else {
		wdc_c.flags = AT_WAIT;
	}
	wdc_c.timeout = 30000; /* 30s timeout */
	if (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {
		printf("%s: standby command didn't complete\n",
		    wd->sc_dev.dv_xname);
	}
	if (wdc_c.flags & AT_TIMEOU) {
		printf("%s: standby command timeout\n",
		    wd->sc_dev.dv_xname);
	}
	if (wdc_c.flags & AT_DF) {
		printf("%s: standby command: drive fault\n",
		    wd->sc_dev.dv_xname);
	}
	/*
	 * Ignore error register, it shouldn't report anything else
	 * than COMMAND ABORTED, which means the device doesn't support
	 * standby
	 */
}
@


1.119
log
@trivial size to free()
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.118 2015/08/17 15:36:29 krw Exp $ */
d839 1
a839 1
		auio.uio_segflg = 0;
@


1.118
log
@The 80's called and want their interface back. Remove last fragments of
ST-506 support. Remove redundant 'precomp' variables/fields and rename
remaining few to 'features' to be consistant with the rest of the code.

Consensus that no ST-506 disks (requiring ISA cards, <120MB, usually
rife with bad sectors that can't be worked around) are still running
OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.117 2014/09/14 14:17:24 jsg Exp $ */
d784 1
a784 1
		free(lp, M_TEMP, 0);
@


1.117
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.116 2014/07/12 18:48:17 tedu Exp $ */
d281 1
a281 1
		wdc_c.r_precomp = WDSF_READAHEAD_EN;
d295 1
a295 1
		wdc_c.r_precomp = WDSF_EN_WR_CACHE;
@


1.116
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.115 2014/07/10 14:21:20 deraadt Exp $ */
d76 1
a76 1
#include <sys/proc.h>
@


1.115
log
@remove most of the boolean_t infection outside uvm/ddb/pmap; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.114 2013/10/14 23:33:13 krw Exp $ */
d784 1
a784 1
		free(lp, M_TEMP);
@


1.114
log
@Use DL_SECTOBLK() instead of handrolling same calculation to get
wdsize() return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.113 2013/10/14 23:26:23 krw Exp $ */
a79 2

#include <uvm/uvm_extern.h>
@


1.113
log
@XXsize() returns daddr_t, so calculate the return value in a daddr_t
variable and not (usually) an int.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.112 2013/09/27 12:12:16 krw Exp $ */
d881 1
d899 2
a900 2
	size = DL_GETPSIZE(&wd->sc_dk.dk_label->d_partitions[part]) *
	    (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
@


1.112
log
@Try harder to ensure wddump() doesn't decrement the count
of sectors to write by one value and increment the address
the next i/o will start at by a different amount.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.111 2013/09/15 13:44:53 krw Exp $ */
d882 1
a882 1
	int64_t size;
@


1.111
log
@Make it clearer that sc_wdc_bio.blkno is actuall a disk hardware
address by using the DL_BLKTOSEC() and DL_SECTOBLK() defines rather
than handrolling the equivalent. Fixes current addition of a 512-byte
block value (b_blkno) to a disk hardware address (DL_GETPOFFSET()).

Tested on real wd(4) hardware by guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.110 2013/06/11 16:42:14 deraadt Exp $ */
d923 1
d965 1
d972 1
a972 2
		wd->sc_wdc_bio.bcount =
			min(nblks, wddumpmulti) * lp->d_secsize;
d1024 3
a1026 3
		nblks -= min(nblks, wddumpmulti);
		blkno += min(nblks, wddumpmulti);
		va += min(nblks, wddumpmulti) * lp->d_secsize;
@


1.110
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.109 2012/10/08 21:47:50 deraadt Exp $ */
d468 2
a469 1
	daddr_t nblks;
d471 3
a473 3
	wd->sc_wdc_bio.blkno = bp->b_blkno +
	    DL_GETPOFFSET(&wd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)]);
	wd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
d485 1
a485 1
	nblks = bp->b_bcount / wd->sc_dk.dk_label->d_secsize;
d488 2
a489 2
	    ((wd->sc_wdc_bio.blkno + nblks - 1 >= LBA48_THRESHOLD) ||
	     (nblks > 0xff)))
@


1.109
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.108 2011/07/06 04:49:36 matthew Exp $ */
d468 1
a468 1
	daddr64_t nblks;
d876 1
a876 1
daddr64_t
d916 1
a916 1
wddump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
@


1.108
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.107 2011/06/30 16:28:05 matthew Exp $ */
a144 1
void  wd_shutdown(void *);
a328 4
	wd->sc_sdhook = shutdownhook_establish(wd_shutdown, wd);
	if (wd->sc_sdhook == NULL)
		printf("%s: WARNING: unable to establish shutdown hook\n",
		    wd->sc_dev.dv_xname);
d344 2
d347 2
a348 1
		wd_standby(wd, AT_POLL);
a377 4
	/* Get rid of the shutdown hook. */
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);

a1137 10
}

void
wd_shutdown(void *arg)
{
	struct wd_softc *wd = arg;

	wd_flushcache(wd, AT_POLL);
	if (boothowto & RB_POWERDOWN)
		wd_standby(wd, AT_POLL);
@


1.107
log
@Refactor some common open/close/detach disk driver code into
subr_disk.c.  For now just the MI disk drivers.

ok deraadt@@, krw@@; jsing@@ liked the approach too
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.106 2011/06/20 06:45:07 matthew Exp $ */
a409 8
	/* Valid request?  */
	if (bp->b_blkno < 0 ||
	    (bp->b_bcount % wd->sc_dk.dk_label->d_secsize) != 0 ||
	    (bp->b_bcount / wd->sc_dk.dk_label->d_secsize) >= (1 << NBBY)) {
		bp->b_error = EINVAL;
		goto bad;
	}

d416 2
a417 2
	/* If it's a null transfer, return immediately. */
	if (bp->b_bcount == 0)
d420 6
a425 6
	/*
	 * Do bounds checking, adjust transfer. if error, process.
	 * If end of partition, just return.
	 */
	if (bounds_check_with_label(bp, wd->sc_dk.dk_label) <= 0)
		goto done;
d433 2
a434 1
bad:
a435 2
done:
	/* Toss transfer; we're done early. */
d437 1
@


1.106
log
@Call bufq_drain() in wddetach() instead of reimplementing the same
logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.105 2011/06/19 04:55:34 deraadt Exp $ */
a372 1
	int bmaj, cmaj, mn;
d378 1
a378 9
	/* Locate the lowest minor number to be detached. */
	mn = DISKMINOR(self->dv_unit, 0);

	for (bmaj = 0; bmaj < nblkdev; bmaj++)
		if (bdevsw[bmaj].d_open == wdopen)
			vdevgone(bmaj, mn, mn + MAXPARTITIONS - 1, VBLK);
	for (cmaj = 0; cmaj < nchrdev; cmaj++)
		if (cdevsw[cmaj].d_open == wdopen)
			vdevgone(cmaj, mn, mn + MAXPARTITIONS - 1, VCHR);
d680 1
a680 5
	/* Check that the partition exists. */
	if (part != RAW_PART &&
	    (part >= wd->sc_dk.dk_label->d_npartitions ||
	     wd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		error = ENXIO;
a681 13
	}

	/* Insure only one open at a time. */
	switch (fmt) {
	case S_IFCHR:
		wd->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		wd->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	wd->sc_dk.dk_openmask =
	    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;
d712 1
a712 10
	switch (fmt) {
	case S_IFCHR:
		wd->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		wd->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	wd->sc_dk.dk_openmask =
	    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;
@


1.105
log
@Use disk_lock_nointr() in the xxclose() routines so that they cannot
be interrupted.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.104 2011/06/19 04:35:06 deraadt Exp $ */
d373 1
a373 2
	struct buf *bp;
	int s, bmaj, cmaj, mn;
d377 1
a377 8
	/* Remove unprocessed buffers from queue */
	s = splbio();
	while ((bp = bufq_dequeue(&sc->sc_bufq)) != NULL) {
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		biodone(bp);
	}
	splx(s);
@


1.104
log
@Use disk_lock/disk_unlock directly and in the same way in these drivers,
rather than using various wrappings.  Convert vnd to using the sc_dk
rwlock instead of using one of its own.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.103 2011/06/05 18:40:33 matthew Exp $ */
a736 1
	int error = 0;
d743 2
a744 2
	if ((error = disk_lock(&wd->sc_dk)) != 0)
		goto exit;
a763 1
 exit:
d765 1
a765 1
	return (error);
@


1.103
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.102 2011/06/03 21:14:11 matthew Exp $ */
a150 2
#define wdlock(wd)  disk_lock(&(wd)->sc_dk)
#define wdunlock(wd)  disk_unlock(&(wd)->sc_dk)
d667 1
a667 1
	if ((error = wdlock(wd)) != 0)
d717 1
a717 1
	wdunlock(wd);
d726 1
a726 1
	wdunlock(wd);
d744 1
a744 1
	if ((error = wdlock(wd)) != 0)
d763 1
a763 1
	wdunlock(wd);
d868 1
a868 1
		if ((error = wdlock(wd)) != 0)
d881 1
a881 1
		wdunlock(wd);
@


1.102
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.101 2011/05/31 17:35:35 matthew Exp $ */
a871 1
		wd->sc_flags |= WDF_LABELLING;
a882 1
		wd->sc_flags &= ~WDF_LABELLING;
a883 12
		goto exit;

	case DIOCWLABEL:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}

		if (*(int *)addr)
			wd->sc_flags |= WDF_WLABEL;
		else
			wd->sc_flags &= ~WDF_WLABEL;
@


1.101
log
@Change a few of the more common disk drivers (sd, cd, wd, rd, and vnd)
to return EBUSY if the user tries to modify an open partition's offset
or size.  Only sadness can result if a user tries this, and rejecting
it prevents a race between sdstart() and sdstrategy().

Curiously, there was already code in the kernel and in disklabel(8) to
detect/handle this, but it was effectively disabled because the disk
drivers always used something like "/* sc->sc_dk.dk_openmask */ 0",
and this commented out code has existed since even r1.1 in NetBSD.

I had no problems building a release and messing around with
disklabel(8) for a bit with this diff.  Canarying the more common MI
disk drivers until we gain confidence that there aren't any
regressions, then we can switch the remaining drivers.

"I am surprised you got me convinced that this stuff is safe" deraadt@@
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.100 2011/04/18 04:16:13 deraadt Exp $ */
d451 1
a451 2
	if (bounds_check_with_label(bp, wd->sc_dk.dk_label,
	    (wd->sc_flags & (WDF_WLABEL|WDF_LABELLING)) != 0) <= 0)
@


1.100
log
@keep an eye out for wdc registers returning 0xff.  if they return 0xff,
this probably means the controller is dead -- as in, a hot plug eject
event.  in that case, mark the driver dead and try harder to return -1
in the interrupt handler.
tested by many
ok dlg, miod did not object
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.99 2011/04/15 20:53:28 miod Exp $ */
d876 1
a876 1
		    (struct disklabel *)addr, /*wd->sc_dk.dk_openmask : */0);
@


1.99
log
@Change wdc_reset_channel() to take a `no wait' argument. Pass in turn this
argument to wdcreset(), to have it skip waiting until active channels see
their BUSY bit clear in the status register.

Use this feature in the resume path, during the first reset operation. The
first reset is supposed to only wake up the controller, and the disks don't
come back until the second reset is issued, therefore waiting for them to
report themselves as ready after the first reset, but before the second, is
moot - and as a matter of fact some controllers, such as the AMD 754 and
clones/offspring (e.g. Geode) keep the BUSY bit asserted after the first
reset.

Last, but not least, make sure wd@@ata invokes wd_get_params() again before
returning from the resume code, as we will still be using polled transfers
for a short while.

This causes the Lemote Yeelong to resume within less than one second, instead
of the lousy 30 seconds wait between the two resets; and the wd_get_params()
voodoo prevents it from getting spurious ide interrupts afterwards.

wd_get_params() magic from dlg; rest of the work by yours truly after enough
prodding by dlg@@ and pirofti@@, among others. ok deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.98 2011/04/05 19:57:40 deraadt Exp $ */
d378 2
d617 1
d622 4
d652 1
d662 3
@


1.98
log
@wd_hibernate_io() is a standalone disk io writer which tries to not
damage kernel memory very much while doing the job.  It is not very
pretty yet, but improving it will need some MI work.
ok mlarkin jsg dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.97 2010/12/31 22:58:40 kettenis Exp $ */
d358 1
a358 1
		 * the channel
d361 1
a361 1
		wdc_reset_channel(wd->drvp);
d363 1
a363 1
		wdc_reset_channel(wd->drvp);
d365 1
d586 1
a586 1
		wdc_reset_channel(wd->drvp);
@


1.97
log
@Reintroduce the code that puts the drive into standby in shutdown, but
only do this if we're going to power down the machine.

"My god, it is a 3 line diff.  Commit it before it gets bigger!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.96 2010/12/30 20:29:13 kettenis Exp $ */
a115 34
struct wd_softc {
	/* General disk infos */
	struct device sc_dev;
	struct disk sc_dk;
	struct bufq sc_bufq;

	/* IDE disk soft states */
	struct ata_bio sc_wdc_bio; /* current transfer */
	struct buf *sc_bp; /* buf being transferred */
	struct ata_drive_datas *drvp; /* Our controller's infos */
	int openings;
	struct ataparams sc_params;/* drive characteristics found */
	int sc_flags;
#define WDF_LOCKED	  0x01
#define WDF_WANTED	  0x02
#define WDF_WLABEL	  0x04 /* label is writable */
#define WDF_LABELLING	  0x08 /* writing label */
/*
 * XXX Nothing resets this yet, but disk change sensing will when ATA-4 is
 * more fully implemented.
 */
#define WDF_LOADED	0x10 /* parameters loaded */
#define WDF_WAIT	0x20 /* waiting for resources */
#define WDF_LBA		0x40 /* using LBA mode */
#define WDF_LBA48	0x80 /* using 48-bit LBA mode */

	u_int64_t sc_capacity;
	int cyl; /* actual drive parameters */
	int heads;
	int sectors;
	int retries; /* number of xfer retry */
	struct timeout sc_restart_timeout;
	void *sc_sdhook;
};
@


1.96
log
@The NVIDIA MCP89 SATA controller found on the 2010 Apple 13" MacBook Pro
can't address block 0xffffffff in LBA mode, at least in combination with
the Hitachi HTS545032B9SA02 and HTS545050B9SA02 drives that Apple ships.
So use LBA48 mode from that block onwards.

ok marco@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.95 2010/09/22 01:18:57 matthew Exp $ */
d79 1
d1244 2
@


1.95
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.94 2010/09/20 01:24:08 deraadt Exp $ */
d551 1
a551 1
	    ((wd->sc_wdc_bio.blkno + nblks - 1 > LBA48_THRESHOLD) ||
@


1.94
log
@DVACT_ACTIVATE and DVACT_DEACTIVATE do nothing here; remove
the false comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.93 2010/09/08 15:16:22 jsing Exp $ */
d662 1
a662 1
	return (physio(wdstrategy, NULL, dev, B_READ, minphys, uio));
d670 1
a670 1
	return (physio(wdstrategy, NULL, dev, B_WRITE, minphys, uio));
d941 1
a941 2
		error = physio(wdformat, NULL, dev, B_WRITE, minphys,
		    &auio);
@


1.93
log
@Introduce a disk_lookup() function which calls device_lookup(), before
verifying that the resulting device is present on the disklist. This
avoids a race whereby the disk driver can be accessed as soon as the
softc has been allocated, but before the disk has completed
initialisation and has called disk_attach() (up until this point
dk_label is still a null pointer).

Cut cd(4), sd(4) and wd(4) across to disk_lookup(). All callers of
disk_attach() need to be tested and cut over in due course.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.92 2010/09/08 14:47:12 jsing Exp $ */
a382 2
	case DVACT_ACTIVATE:
		break;
a397 5
		break;
	case DVACT_DEACTIVATE:
		/*
		* Nothing to do; we key off the device's DVF_ACTIVATE.
		*/
@


1.92
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.90 2010/08/31 17:00:32 deraadt Exp $ */
d186 1
a186 1
#define wdlookup(unit) (struct wd_softc *)device_lookup(&wd_cd, (unit))
@


1.91
log
@make struct bufq a member of the softc for devices that use it,
rather than it being a pointer to something that needs to be allocated
at attach. since all these devices need a bufq to operate, it makes
sense to have it allocated as part of the softc and get bufq_init
to just initialise all its fields. it also gets rid of the possibility
that you wont be able to allocate the bufq struct during attach,
which is something you dont want to happen.

secondly, it consistently implements a split between wrapper functions
and the per discipline implementation of the bufq handlers. it
consistently does the locking in the wrappers rather than doing
half in the wrappers and the other half in the implementations.

it also consistently handles the outstanding bufq bq pointer in the
wrappers.

this hides most of the implementation inside kern_bufq.c. the only
stuff left in buf.h is for the bits each implementation needs to
put inside struct buf.

tested by thib@@ krw@@ and me
ok thib@@ matthew@@
no objection from krw@@
@
text
@d372 1
a372 1
	disk_attach(&wd->sc_dk);
@


1.90
log
@sort DVACT_ actions in order of use
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.89 2010/08/28 20:23:22 matthew Exp $ */
d119 1
a119 1
	struct bufq	*sc_bufq;
d364 1
a364 1
	wd->sc_bufq = bufq_init(BUFQ_DEFAULT);
d419 1
a419 1
	while ((bp = BUFQ_DEQUEUE(sc->sc_bufq)) != NULL) {
d441 1
a441 1
	bufq_destroy(sc->sc_bufq);
d492 1
a492 1
	BUFQ_QUEUE(wd->sc_bufq, bp);
d524 1
a524 1
		if ((bp = BUFQ_DEQUEUE(wd->sc_bufq)) == NULL)
@


1.89
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.88 2010/07/23 07:47:13 jsg Exp $ */
a384 6

	case DVACT_DEACTIVATE:
		/*
		* Nothing to do; we key off the device's DVF_ACTIVATE.
		*/
		break;
d400 5
@


1.88
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.87 2010/07/22 21:40:46 kettenis Exp $ */
a179 2
struct dkdriver wddkdriver = { wdstrategy };

a362 1
	wd->sc_dk.dk_driver = &wddkdriver;
@


1.87
log
@Give the drive a little bit more time to complete the STANDBY IMMED command.
The ATA spec seems to suggest it may take up to 30s.  This seems a little bit
long.  To quote Theo: "by that time some drives have probably parked their own
heads in boredom".  But it shouldn't hurt unless your drive is seriously
broken.  Makes some laptops suspend much better.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.86 2010/07/22 18:10:37 mlarkin Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *	must display the following acknowledgement:
 *  This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *	derived from this software without specific prior written permission.
@


1.86
log
@

First part of better pciide resume. Wake the channel by performing two
resets separated by a small delay (a delay intended to offend jsg who will
definitely want to fix it by checking for RDY instead)

Tested on a variety of amd and i386 hardware by myself and deraadt@@

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.85 2010/06/28 08:35:46 jsing Exp $ */
d1234 1
a1234 1
	wdc_c.timeout = 1000; /* 1s timeout */
@


1.85
log
@Move disk_attach() to the end of the attach functions, at which point the
disk is now ready to handle I/O.

ok krw@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.83 2010/05/26 16:16:23 thib Exp $ */
d402 12
@


1.84
log
@partial backout of 1.81 as invoking standby in shutdown
breaks at least socppc and armish
@
text
@d368 1
a368 1
	 * Initialize and attach the disk structure.
a372 2
	disk_attach(&wd->sc_dk);
	wd->sc_wdc_bio.lp = wd->sc_dk.dk_label;
d378 4
@


1.83
log
@Reintroduce bufqs. A few changes since it was backed out after some good
comments from dlg@@.

No need for a separate bufq.h, keep all of in buf.h; As requested by kittens
and deraadt.

Only sd(4) and wd(4) for now. The rest of the drivers will be converted soon,
also other goodies like heuristics for sd(4) for selecting the bufq type and
the death of disksort() are forthcoming.

Tested on: i386, amd64, sparc64, macppc, loongson and alpha by myself and
phessler.

OK art@@, beck@@, kettenis@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.82 2010/05/24 11:18:50 kettenis Exp $ */
a1245 1
	wd_standby(wd, AT_POLL);
@


1.82
log
@Flush cache before suspend.

ok krw@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.81 2010/05/23 09:58:57 kettenis Exp $ */
d73 1
d124 2
a125 1
	struct buf sc_q;
d372 1
d409 1
a409 1
	struct buf *dp, *bp;
d414 1
a414 2
	for (dp = &sc->sc_q; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;
d436 1
d487 1
a488 1
	disksort(&wd->sc_q, bp);
d512 1
a512 1
	struct buf *dp, *bp = NULL;
d519 1
a519 2
		dp = &wd->sc_q;
		if ((bp = dp->b_actf) == NULL)  /* yes, an assign */
a520 2
		dp->b_actf = bp->b_actf;

@


1.81
log
@Place drive in standby mode before shutdown.  Avoids the loud click heard on
many laptops when powering them down.

ok jsg@@, oga@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.80 2010/05/18 04:41:14 dlg Exp $ */
d395 1
@


1.80
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.79 2010/04/23 15:25:21 jsing Exp $ */
d180 1
a382 1
	struct wdc_command wdc_c;
d395 1
a395 9
		bzero(&wdc_c, sizeof(struct wdc_command));

		wdc_c.r_command = WDCC_STANDBY_IMMED;
		wdc_c.timeout = 1000;
		wdc_c.flags = at_poll;
		if (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {
			printf("%s: enter standby command didn't complete\n",
			       wd->sc_dev.dv_xname);
		}
d1206 34
d1243 1
d1245 1
@


1.79
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.77 2009/10/13 19:33:16 pirofti Exp $ */
d82 1
@


1.78
log
@Send "STANDBY IMMEDIATE" command to ATA disks upon suspend.  For this to work,
pciide(4) needs to formward DVACT_SUSPEND and DVACT_RESUME events to its
children, so do that.

Gets rid of the nasty "click" sound from the disk on many laptops.

ok marco@@, jsg@@
@
text
@a822 2
	lp->d_rpm = 3600;
	lp->d_interleave = 1;
@


1.77
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.76 2009/08/13 15:23:12 deraadt Exp $ */
d380 2
d392 11
@


1.76
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.75 2009/06/17 01:30:30 thib Exp $ */
d159 1
a159 1
int	wdactivate(struct device *, enum devact);
d378 1
a378 1
wdactivate(struct device *self, enum devact act)
@


1.75
log
@Revert bufq's. this is inline with the major midlayer reverts that
have been going on. this appears to bring us back to stable state.

lots of testing by oga and ariane and my self.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.74 2009/06/03 22:09:30 thib Exp $ */
d172 1
a172 1
void  wdgetdisklabel(dev_t dev, struct wd_softc *, struct disklabel *, int);
d706 5
a710 1
			wdgetdisklabel(dev, wd, wd->sc_dk.dk_label, 0);
d823 1
a823 1
void
d827 1
a827 1
	char *errstring;
d835 1
a835 1
	errstring = readdisklabel(DISKLABELDEV(dev), wdstrategy, lp,
d839 1
a839 3
	if (errstring) {
		/*printf("%s: %s\n", wd->sc_dev.dv_xname, errstring);*/
	}
@


1.74
log
@add a flexible buffer queue (bufq) api, based on the never used
one by tedu@@. It doesn't do anything smart yet, it just uses
plain old disksort. we also keep the old method of queueing bufs
since some miods have crazy MD drivers that need some love.

ok beck@@, art@@
tested by many on many archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.72 2008/09/10 14:01:22 blambert Exp $ */
d122 1
a122 1

d399 1
a399 1
	struct buf *bp;
d404 2
a405 1
	while ((bp = BUFQ_GET(sc->sc_dk.dk_bufq)) != NULL) {
d478 1
a478 1
	BUFQ_ADD(wd->sc_dk.dk_bufq, bp);
d502 1
a502 1
	struct buf *bp = NULL;
d509 2
a510 1
		if ((bp = BUFQ_GET(wd->sc_dk.dk_bufq)) == NULL)
d512 2
@


1.73
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok krw@@
@
text
@d122 1
a122 1
	struct buf sc_q;
d399 1
a399 1
	struct buf *dp, *bp;
d404 1
a404 2
	for (dp = &sc->sc_q; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;
d477 1
a477 1
	disksort(&wd->sc_q, bp);
d501 1
a501 1
	struct buf *dp, *bp = NULL;
d508 1
a508 2
		dp = &wd->sc_q;
		if ((bp = dp->b_actf) == NULL)  /* yes, an assign */
a509 2
		dp->b_actf = bp->b_actf;

@


1.72
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.71 2008/06/27 06:03:08 ray Exp $ */
a219 1
	struct channel_softc *chp;
a220 1
	u_int8_t drive;
a225 2
	chp = wd->drvp->chnl_softc;
	drive = wd->drvp->drive;
@


1.71
log
@More removal of clauses 3 and 4 from NetBSD licenses.

OK deraadt@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.70 2008/06/15 00:36:41 krw Exp $ */
d564 1
a564 1
		timeout_add(&wd->sc_restart_timeout, hz);
@


1.70
log
@Don't bypass partition bounds check for RAW_PART. We now guarantee that
RAW_PART will always be 0 -> disksize, so the bounds check will always
pass for i/o's to valid addresses. Now the i/o will be properly truncated
if it goes past the end of the device. This prevents various adverse
impacts of issuing i/o's for data past the end of the device.

Repeatedly requested by todd@@.

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.69 2008/02/07 12:58:30 sthen Exp $ */
a47 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.69
log
@enable DMA for 1-sector devices (i.e. most flash devices).
from NetBSD

ok krw thib henning, tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.68 2007/12/05 23:11:34 jsg Exp $ */
d484 1
a484 2
	if (DISKPART(bp->b_dev) != RAW_PART &&
	    bounds_check_with_label(bp, wd->sc_dk.dk_label,
@


1.68
log
@Switch set features commands to use wdc_exec_command() to allow
them to be properly polled.

Fixes previously problematic machines of form and ckuethe.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.67 2007/11/26 23:59:01 jsg Exp $ */
d551 1
a551 1
	if (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)
a1067 1
again:
a1069 2
		if (wddumpmulti == 1)
			wd->sc_wdc_bio.flags |= ATA_SINGLE;
a1115 5
			if (wddumpmulti != 1) {
				wddumpmulti = 1; /* retry in single-sector */
				printf(", retrying\n");
				goto again;
			}
@


1.67
log
@Enable read ahead and write cache enable if supported by
the disk rather than depending on the disk to have it on.

A bunch of people have suggested this should go in.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.66 2007/06/20 18:15:46 deraadt Exp $ */
d330 13
a342 3
	if (wd->sc_params.atap_cmd_set1 & WDC_CMD1_AHEAD)
		wdccommand(chp, drive, SET_FEATURES, 0, 0, 0, 0,
		    WDSF_READAHEAD_EN);
d344 12
a355 3
	if (wd->sc_params.atap_cmd_set1 & WDC_CMD1_CACHE)
		wdccommand(chp, drive, SET_FEATURES, 0, 0, 0, 0,
		    WDSF_EN_WR_CACHE);
@


1.66
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.65 2007/06/18 20:55:52 deraadt Exp $ */
d227 1
d229 1
d235 2
d328 9
@


1.65
log
@avoid modification race in DIOCRLDINFO; ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.64 2007/06/08 05:27:58 deraadt Exp $ */
d179 1
a179 3
void  wdgetdisklabel(dev_t dev, struct wd_softc *,
				 struct disklabel *,
				 struct cpu_disklabel *, int);
d453 1
a453 1
	    bounds_check_with_label(bp, wd->sc_dk.dk_label, wd->sc_dk.dk_cpulabel,
d686 1
a686 2
			wdgetdisklabel(dev, wd, wd->sc_dk.dk_label,
			    wd->sc_dk.dk_cpulabel, 0);
d801 1
a801 1
    struct cpu_disklabel *clp, int spoofonly)
a806 2
	bzero(clp, sizeof(struct cpu_disklabel));

d811 1
a811 1
	errstring = readdisklabel(DISKLABELDEV(dev), wdstrategy, lp, clp,
d841 1
a841 1
		wdgetdisklabel(dev, wd, lp, wd->sc_dk.dk_cpulabel, 0);
d846 3
a848 7
	case DIOCGPDINFO: {
			struct cpu_disklabel osdep;

			wdgetdisklabel(dev, wd, (struct disklabel *)addr,
			    &osdep, 1);
			goto exit;
		}
d872 1
a872 2
		    (struct disklabel *)addr, /*wd->sc_dk.dk_openmask : */0,
		    wd->sc_dk.dk_cpulabel);
d878 1
a878 2
				    wdstrategy, wd->sc_dk.dk_label,
				    wd->sc_dk.dk_cpulabel);
@


1.64
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.63 2007/06/07 03:50:20 ray Exp $ */
d829 1
d845 4
a848 2
		wdgetdisklabel(dev, wd, wd->sc_dk.dk_label,
		    wd->sc_dk.dk_cpulabel, 0);
d850 1
@


1.63
log
@strncpy -> strlcpy, plus a little spacing line up.

OK deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.62 2007/06/06 17:15:13 deraadt Exp $ */
d792 1
@


1.62
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.61 2007/06/05 00:38:20 deraadt Exp $ */
d140 1
a140 1
#define WDF_LABELLING   0x08 /* writing label */
d236 2
a237 2
	strncpy(wd->drvp->drive_name, wd->sc_dev.dv_xname,
		sizeof(wd->drvp->drive_name) - 1);
@


1.61
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.60 2007/06/01 00:07:48 krw Exp $ */
d509 1
a509 1
	daddr_t nblks;
d955 1
a955 1
int
d960 1
a960 1
	int size;
d995 1
a995 1
wddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
@


1.60
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.59 2007/05/31 05:24:06 krw Exp $ */
a508 1
	daddr_t p_offset;
d511 2
a512 6
	if (DISKPART(bp->b_dev) != RAW_PART)
		p_offset =
		    wd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)].p_offset;
	else
		p_offset = 0;
	wd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;
d775 1
a775 1
	lp->d_secperunit = wd->sc_capacity;
d779 1
a779 1
	lp->d_ncylinders = lp->d_secperunit / lp->d_secpercyl;
d976 1
a976 1
	size = wd->sc_dk.dk_label->d_partitions[part].p_size *
d1028 1
a1028 1
	if ((blkno < 0) || ((blkno + nblks) > lp->d_partitions[part].p_size))
d1032 1
a1032 1
	blkno += lp->d_partitions[part].p_offset;
@


1.59
log
@Kill old, no longer necessary kludge to try fooling readdisklabel()
into using DOS geometry by calling it twice. And don't ignore the
drive state if readdisklabel() returns a non-NULL value.

ok weingart@@ grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.58 2007/04/28 02:24:21 krw Exp $ */
a796 5

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;
@


1.58
log
@Fix comments above DISKMINOR uses. DISKMINOR provides minor not major
number (wd.c), and the uses are to find the minimum minor to be
detached.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.57 2007/04/27 11:37:56 krw Exp $ */
d825 4
a828 14
	errstring = readdisklabel(DISKLABELDEV(dev),
	    wdstrategy, lp, clp, spoofonly);
	if (errstring) {
		/*
		 * This probably happened because the drive's default
		 * geometry doesn't match the DOS geometry.  We
		 * assume the DOS geometry is now in the label and try
		 * again.  XXX This is a kluge.
		 */
		if (wd->drvp->state > RECAL)
			wd->drvp->drive_flags |= DRIVE_RESET;
		errstring = readdisklabel(DISKLABELDEV(dev),
		    wdstrategy, lp, clp, spoofonly);
	}
a830 1
		return;
a831 3

	if (wd->drvp->state > RECAL)
		wd->drvp->drive_flags |= DRIVE_RESET;
@


1.57
log
@Nuke WDUNIT/WDPART/etc. defines and just use standard DISKUNIT/DISKPART/etc.
ones. No change to wd.o.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.56 2007/04/26 22:42:11 krw Exp $ */
d393 1
a393 1
	/* locate the major number */
@


1.56
log
@Eliminate CPU_BIOS from userland and wd(4) by always using the BIOS
geometry in the disklabel when there is a BIOS geometry to provide.
This removes the option to set a disklabel to 'BIOS' geometry via the
'g b' command in the editor.

Makes reported geometry more consistant and moves MD code to MD land
where it should be.

Doc help from jmc@@, Feedback from millert@@, marco@@, weingart@@,
kettenis@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.55 2007/03/27 23:32:55 deraadt Exp $ */
a109 7
#define	WDUNIT(dev)		DISKUNIT(dev)
#define	WDPART(dev)		DISKPART(dev)
#define WDMINOR(unit, part)	DISKMINOR(unit, part)
#define	MAKEWDDEV(maj, unit, part)	MAKEDISKDEV(maj, unit, part)

#define	WDLABELDEV(dev)	(MAKEWDDEV(major(dev), WDUNIT(dev), RAW_PART))

d394 1
a394 1
	mn = WDMINOR(self->dv_unit, 0);
d423 1
a423 1
	wd = wdlookup(WDUNIT(bp->b_dev));
d454 1
a454 1
	if (WDPART(bp->b_dev) != RAW_PART &&
d512 1
a512 1
	if (WDPART(bp->b_dev) != RAW_PART)
d514 1
a514 1
		    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;
d664 1
a664 1
	unit = WDUNIT(dev);
d698 1
a698 1
	part = WDPART(dev);
d739 1
a739 1
	int part = WDPART(dev);
d742 1
a742 1
	wd = wdlookup(WDUNIT(dev));
d825 1
a825 1
	errstring = readdisklabel(WDLABELDEV(dev),
d836 1
a836 1
		errstring = readdisklabel(WDLABELDEV(dev),
d856 1
a856 1
	wd = wdlookup(WDUNIT(dev));
d885 1
a885 1
		    &wd->sc_dk.dk_label->d_partitions[WDPART(dev)];
d906 1
a906 1
				error = writedisklabel(WDLABELDEV(dev),
d988 1
a988 1
	wd = wdlookup(WDUNIT(dev));
d992 1
a992 1
	part = WDPART(dev);
d1033 1
a1033 1
	unit = WDUNIT(dev);
d1038 1
a1038 1
	part = WDPART(dev);
@


1.55
log
@OK, I understand why jsg wanted the disk_unbusy() in wdretry(), and he
was right.  There is another path that ends up avoiding the disk_unbusy
call I inserted.... tested by robert too
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.54 2007/03/25 18:05:49 deraadt Exp $ */
a790 9
#ifdef CPU_BIOS
	/*
	 * Stick to what the controller says for BIOS compatibility. Let the
	 * CPU_BIOS logic on i386 and friends deal with any mismatch to actual
	 * size.
	 */
	lp->d_ncylinders = wd->sc_params.atap_cylinders;
#else
	/* We are not constrained by BIOS concerns. Calculate cylinder count. */
a791 1
#endif
@


1.54
log
@wdc retries (including after suspends) caused a disk to remain busy when
it should not; ok dlg
problem spotted using zaurus soft-drive-led diff which is pending
i think i convinced jsg now that this fix is better than putting it
in wdrestart
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.53 2007/02/15 00:53:26 krw Exp $ */
a611 1
			disk_unbusy(&wd->sc_dk, 0, (bp->b_flags & B_READ));
d641 1
@


1.53
log
@Don't print the error strings returned by readdisklabel().  If you
need the debug info uncomment the printf's you need. Crude but
effective way to suppress 'no disklabel' errors that pop up at the
most innconvenient times to frighten users. More elegant method,
DPRINTF-like constructs or something, later.

"Yay!" marco@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.52 2007/02/06 03:17:24 krw Exp $ */
d612 1
@


1.52
log
@De-register. No object code change.

From Bret Lambert.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.51 2006/10/17 23:20:12 krw Exp $ */
d856 1
a856 1
		printf("%s: %s\n", wd->sc_dev.dv_xname, errstring);
@


1.51
log
@For non-CPU_BIOS architectures calculate the number of cylinders on
a disk rather than accepting the cylinder count provided by the disk
or controller. This cylinder count will be '16383' for any disk >8.4G
according to the ATA spec. CPU_BIOS on i386/amd64 has magic to deal
with this, but other archs do not need to be restricted by the needs
of PC BIOS.

Fixes the default MBR OpenBSD partition size and disklabel on non-CPU_BIOS
archtitectures.

No change to behaviour on i386/amd64 machines.

Noted by Stuart Henderson on his Thecus.

Testing by various, including 'old i386 machines' nick@@

ok tom@@ pedro@@ weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.50 2006/10/04 00:52:55 krw Exp $ */
d948 1
a948 1
		register struct format_op *fop;
@


1.50
log
@Zap bad144 bad sector info in disklabels. Sparsely used if at all for
a few obsolete and easily replaced disk models. And didn't work anyway
according to Bob, who has tried.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.49 2006/08/21 12:09:01 krw Exp $ */
d786 1
d789 7
d797 4
a800 1
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
a809 1
	lp->d_secperunit = wd->sc_capacity;
@


1.49
log
@Delete #ifdef/#ifndef __OpenBSD__ chunks, leaving just the code we
use. Easier to read and eliminates a potentially confusing unused call
to wdgetdisklabel(). No change to object files.

ok brad@@ dlg@@ grange@@ deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.48 2006/08/12 13:53:44 krw Exp $ */
a168 1
#define sc_badsect sc_wdc_bio.badsect
a202 4
#ifdef DKBAD
void	bad144intern(struct wd_softc *);
#endif

a828 2
	wd->sc_badsect[0] = -1;

a851 4
#ifdef DKBAD
	if ((lp->d_flags & D_BADSECT) != 0)
		bad144intern(wd);
#endif
a871 10
#ifdef DKBAD
	case DIOCSBAD:
		if ((flag & FWRITE) == 0)
			return EBADF;
		DKBAD(wd->sc_dk.dk_cpulabel) = *(struct dkbad *)addr;
		wd->sc_dk.dk_label->d_flags |= D_BADSECT;
		bad144intern(wd);
		goto exit;
#endif

a1146 26

#ifdef DKBAD
/*
 * Internalize the bad sector table.
 */
void
bad144intern(struct wd_softc *wd)
{
	struct dkbad *bt = &DKBAD(wd->sc_dk.dk_cpulabel);
	struct disklabel *lp = wd->sc_dk.dk_label;
	int i = 0;

	WDCDEBUG_PRINT(("bad144intern\n"), DEBUG_XFERS);

	for (; i < NBT_BAD; i++) {
		if (bt->bt_bad[i].bt_cyl == 0xffff)
			break;
		wd->sc_badsect[i] =
		    bt->bt_bad[i].bt_cyl * lp->d_secpercyl +
		    (bt->bt_bad[i].bt_trksec >> 8) * lp->d_nsectors +
		    (bt->bt_bad[i].bt_trksec & 0xff);
	}
	for (; i < NBT_BAD+1; i++)
		wd->sc_badsect[i] = -1;
}
#endif
@


1.48
log
@Setting d_secsize to DEV_BSIZE (or 1 << DEV_BSHIFT, or 512) and then
setting RAW_PART's p_size to d_secperunit * (d_secsize / DEV_BSIZE) is
a waste of a few ops. And p_size should be in sectors anyway.

Just set RAW_PART's p_size to d_secperunit to make usage consistant
across the tree.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.47 2006/03/05 22:49:22 krw Exp $ */
a170 3
#ifndef __OpenBSD__
int	wdprobe(struct device *, struct cfdata *, void *);
#else
a171 1
#endif
a181 1
#ifdef __OpenBSD__
a184 3
#else
extern struct cfdriver wd_cd;
#endif
a223 9
#ifndef __OpenBSD__
	if (match->cf_loc[ATACF_CHANNEL] != ATACF_CHANNEL_DEFAULT &&
	    match->cf_loc[ATACF_CHANNEL] != aa_link->aa_channel)
		return 0;

	if (match->cf_loc[ATACF_DRIVE] != ATACF_DRIVE_DEFAULT &&
	    match->cf_loc[ATACF_DRIVE] != aa_link->aa_drv_data->drive)
		return 0;
#else
a230 1
#endif
a683 6
#ifndef __OpenBSD__
	if (wd->sc_dk.dk_openmask == 0 &&
	    (error = wdc_ata_addref(wd->drvp)) != 0)
		return (error);
#endif

a741 4
#ifndef __OpenBSD__
	if (wd->sc_dk.dk_openmask == 0)
		wdc_ata_delref(wd->drvp);
#endif
a774 3
#ifndef __OpenBSD__
		wdc_ata_delref(wd->drvp);
#endif
a952 6

#ifndef __OpenBSD__
	case DIOCGDEFLABEL:
		wdgetdefaultlabel(wd, (struct disklabel *)addr);
		goto exit;
#endif
@


1.47
log
@Remove more NRND NetBSDisms.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.46 2006/01/21 12:18:47 miod Exp $ */
d841 1
a841 2
	lp->d_partitions[RAW_PART].p_size =
	lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
@


1.46
log
@Invoke disk_detach() and related cleanup work in detach(), rather than
zeroref() - just to be on the safe side, should we mess up our ref count.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.45 2005/11/09 19:05:48 uwe Exp $ */
a87 3
#if NRND > 0
#include <sys/rnd.h>
#endif
a161 3
#if NRND > 0
	rndsource_element_t	rnd_source;
#endif
a384 4
#if NRND > 0
	rnd_attach_source(&wd->rnd_source, wd->sc_dev.dv_xname,
			  RND_TYPE_DISK, 0);
#endif
a439 5
#if NRND > 0
	/* Unhook the entropy source. */
	rnd_detach_source(&sc->rnd_source);
#endif

a648 3
#if NRND > 0
	rnd_add_uint32(&wd->rnd_source, bp->b_blkno);
#endif
@


1.45
log
@Don't fall back to fake geometry if ata_get_params() fails.
"looks sane" grange@@; tested by niall@@ krw@@ jmc@@ jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.44 2005/09/01 02:16:56 uwe Exp $ */
a184 1
void    wdzeroref(struct device *);
d189 1
a189 1
	wddetach, wdactivate, wdzeroref
d447 3
a455 9
}

void
wdzeroref(struct device *self)
{
	struct wd_softc *sc = (struct wd_softc *)self;

	/* Detach disk. */
	disk_detach(&sc->sc_dk);
@


1.44
log
@On zaurus, don't fall back to fake geometry if ata_get_params() fails,
which can happen if the integrated microdrive's DRQ is not clear.  This
fixes the drive geometry in the default disklabel.
Help from weingart@@ and grange@@; "mention `grange and i will fix this
better after 3.8 or we will be flailed'" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.43 2005/08/27 14:14:48 jsg Exp $ */
a1260 6
#ifdef __zaurus__
	/* XXX fix after 3.8 release */
	/* We already have the drive parameters; just return them. */
	if (params == &wd->sc_params && wd->sc_params.atap_cylinders != 0)
		return 0;
#endif /* __zaurus__ */
d1265 1
a1265 3
#ifdef __zaurus__
		/* XXX fix after 3.8 release */
		/* We already have the drive parameters; reuse them. */
d1267 3
a1269 1
			*params = wd->sc_params;
a1271 1
#endif /* __zaurus__ */
d1277 1
@


1.43
log
@Use the ATA security FREEZE LOCK command on disks before
they are presented to the rest of the system to stop
a password being set that could deny access to the disk.
ok grange@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.42 2005/05/15 18:09:29 grange Exp $ */
d1261 6
d1271 8
@


1.42
log
@Use FLUSHCACHE EXT instead of FLUSHCACHE for LBA48 operations.
First noticed by christos@@netbsd (iirc) a long time ago.

Tested by canacar@@ and krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.41 2004/07/06 00:38:38 aaron Exp $ */
d265 1
d363 18
@


1.41
log
@Replace magic number with a more descriptive #define.  This magic number was
particularly vile because it looks like a typo (i.e., looks like one "f" is
missing), but it's really not.  I happened to notice this myself, but the fix
is inspired by NetBSD in the interest of keeping the code similar.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.40 2004/03/03 17:16:03 tedu Exp $ */
d1277 2
a1278 1
	wdc_c.r_command = WDCC_FLUSHCACHE;
@


1.40
log
@remove bufq support until i figure out just what's going wrong.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.30 2003/05/20 03:59:35 tedu Exp $ */
d107 2
d566 2
a567 1
	    ((wd->sc_wdc_bio.blkno + nblks - 1 > 0xfffffff) || (nblks > 0xff)))
@


1.39
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.38 2004/02/02 21:29:38 tedu Exp $ */
d137 1
a137 1
	struct bufq *sc_q;
a266 6
	wd->sc_q = BUFQ_ALLOC(0);
#ifdef DIAGNOSTIC
	if (wd->sc_q == NULL)
		return;
#endif

d400 1
a400 1
	struct buf *bp;
d405 2
a406 1
	while ((bp = BUFQ_GET(sc->sc_q)) != NULL) {
a430 1
	BUFQ_FREE(sc->sc_q);
d491 1
a491 1
	BUFQ_ADD(wd->sc_q, bp);
d515 1
a515 1
	struct buf *bp = NULL;
d522 2
a523 1
		if ((bp = BUFQ_GET(wd->sc_q)) == NULL)
d525 1
@


1.38
log
@as grange pointed out, BUFQ_ALLOC might fail
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.37 2004/01/21 21:00:14 tedu Exp $ */
d651 2
a652 1
	disk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));
@


1.37
log
@dynamic bufq support.  basically a nullop.  ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.36 2004/01/16 21:00:57 grange Exp $ */
d268 4
@


1.36
log
@Do not print CHS info for LBA drives, it's useless for drives with
capacity > 8GB. Total number of cylinders is enough.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.35 2004/01/15 21:37:57 grange Exp $ */
d137 1
a137 1
	struct bufq_default sc_q;
d267 1
a267 2
	wd->sc_q.bufq.bufq_get = bufq_default_get;
	wd->sc_q.bufq.bufq_add = bufq_default_add;
d407 1
a407 1
	while ((bp = BUFQ_GET(&sc->sc_q)) != NULL) {
d432 1
d493 1
a493 1
	BUFQ_ADD(&wd->sc_q, bp);
d524 1
a524 1
		if ((bp = BUFQ_GET(&wd->sc_q)) == NULL)
@


1.35
log
@ansi and some spaces; no f/c
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.34 2003/10/21 09:57:04 jmc Exp $ */
d338 1
a338 2
		printf(" LBA48, %lluMB, %d cyl, %d head,"
		    " %d sec, %llu sectors\n",
a339 3
		    wd->sc_params.atap_cylinders,
		    wd->sc_params.atap_heads,
		    wd->sc_params.atap_sectors,
d345 1
a345 1
		printf(" LBA, %lluMB, %d cyl, %d head, %d sec, %llu sectors\n",
a346 3
		    wd->sc_params.atap_cylinders,
		    wd->sc_params.atap_heads,
		    wd->sc_params.atap_sectors,
@


1.34
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.33 2003/09/28 21:01:42 grange Exp $ */
d227 1
a227 8
wdprobe(parent, match_, aux)
	struct device *parent;
#ifndef __OpenBSD__
	struct cfdata *match;
#else
	void *match_;
#endif
	void *aux;
d259 1
a259 3
wdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d389 1
a389 3
wdactivate(self, act)
	struct device *self;
	enum devact act;
a405 1

d407 1
a407 3
wddetach(self, flags)
	struct device *self;
	int flags;
d445 1
a445 2
wdzeroref(self)
	struct device *self;
d458 1
a458 2
wdstrategy(bp)
	struct buf *bp;
d521 1
a521 2
wdstart(arg)
	void *arg;
d545 1
a545 3
__wdstart(wd, bp)
	struct wd_softc *wd;
	struct buf *bp;
d604 1
a604 2
wddone(v)
	void *v;
d664 1
a664 2
wdrestart(v)
	void *v;
d678 1
a678 4
wdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d686 1
a686 4
wdwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d694 1
a694 4
wdopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
d784 1
a784 4
wdclose(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
d810 1
a810 1
		wd_flushcache(wd,0);
d825 1
a825 3
wdgetdefaultlabel(wd, lp)
	struct wd_softc *wd;
	struct disklabel *lp;
d864 2
a865 6
wdgetdisklabel(dev, wd, lp, clp, spoofonly)
	dev_t  dev;
	struct wd_softc *wd;
	struct disklabel *lp;
	struct cpu_disklabel *clp;
	int spoofonly;
d907 1
a907 6
wdioctl(dev, xfer, addr, flag, p)
	dev_t dev;
	u_long xfer;
	caddr_t addr;
	int flag;
	struct proc *p;
d1054 1
a1054 2
wdsize(dev)
	dev_t dev;
d1093 1
a1093 5
wddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
d1221 1
a1221 2
bad144intern(wd)
	struct wd_softc *wd;
d1243 1
a1243 4
wd_get_params(wd, flags, params)
	struct wd_softc *wd;
	u_int8_t flags;
	struct ataparams *params;
d1273 1
a1273 3
wd_flushcache(wd, flags)
	struct wd_softc *wd;
	int flags;
d1309 1
a1309 2
wd_shutdown(arg)
	void *arg;
@


1.33
log
@kill trailing spaces, no functional changes
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.32 2003/07/20 19:57:04 grange Exp $ */
d143 1
a143 1
	struct ataparams sc_params;/* drive characteistics found */
@


1.32
log
@Use LBA48 only when accessing blocks after 137Gb limit or using sectors
count more than 255 to reduce registers writting overhead. Gives me
about 5% perfomance increase in a dumb synthetic test.

Some input and ok from costa@@ a long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.31 2003/06/25 20:52:57 tedu Exp $ */
d144 1
a144 1
	int sc_flags;	  
d200 1
a200 1
void  wdgetdisklabel(dev_t dev, struct wd_softc *, 
d282 1
a282 1
	strncpy(wd->drvp->drive_name, wd->sc_dev.dv_xname, 
d389 1
a389 1
		    wd->sc_dev.dv_xname); 
d487 1
a487 1
	
d495 1
a495 1
	
d551 1
a551 1
		/* 
d608 1
a608 1
		/* 
d781 1
a781 1
	
d826 1
a826 1
	
d961 1
a961 1
	
d993 1
a993 1
	
d999 1
a999 1
	
d1026 1
a1026 1
	
d1053 1
a1053 1
	
d1072 1
a1072 1
		
d1176 1
a1176 1
		return EINVAL;  
d1187 1
a1187 1
  
d1233 1
a1233 1
		case NOERROR: 
@


1.31
log
@implement new means of manipulating buf queues, bufq.
accessed with BUFQ macros, bufq structs support extensible, potentially
changable algorithms and queue formats.  the current default scheme
should support nice priority based queuing, but is missing some vfs_bio.c
support.
only on wd.c for now, other drivers are easy converts.
as a side bonus, this makes the driver code look cleaner.
idea for the name comes from netbsd, but this scheme is incompatible.
thanks to various people for testing.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.30 2003/05/20 03:59:35 tedu Exp $ */
d567 2
d587 4
a590 1
	if (wd->sc_flags & WDF_LBA48)
@


1.30
log
@change spaces to tabs so i can mail grange diffs :)
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.29 2003/04/09 00:38:08 ho Exp $ */
d137 1
a137 1
	struct buf sc_q;
d276 3
d424 1
a424 1
	struct buf *dp, *bp;
d429 1
a429 3
	for (dp = &sc->sc_q; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;
		
d516 1
a516 1
	disksort(&wd->sc_q, bp);
d541 1
a541 1
	struct buf *dp, *bp=0;
d548 3
a550 5
		dp = &wd->sc_q;
		if ((bp = dp->b_actf) == NULL)  /* yes, an assign */
			 return;
		dp->b_actf = bp->b_actf;
	
d1114 2
a1115 5
	if (wd->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)
		size = -1;
	else
		size = wd->sc_dk.dk_label->d_partitions[part].p_size *
		    (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
@


1.29
log
@sprintf->snprintf. miod@@, grange@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.28 2003/04/06 15:28:25 krw Exp $ */
d113 1
a113 1
#define WDMINOR(unit, part)     DISKMINOR(unit, part)
d181 2
a182 2
int     wddetach(struct device *, int);
int     wdactivate(struct device *, enum devact);
d396 2
a397 2
        struct device *self;
        enum devact act;
d399 1
a399 1
        int rv = 0;
d401 11
a411 11
        switch (act) {
        case DVACT_ACTIVATE:
                break;

        case DVACT_DEACTIVATE:
                /*
                 * Nothing to do; we key off the device's DVF_ACTIVATE.
                 */
                break;
        }
        return (rv);
d417 2
a418 2
        struct device *self;
        int flags;
d420 3
a422 3
        struct wd_softc *sc = (struct wd_softc *)self;
        struct buf *dp, *bp;
        int s, bmaj, cmaj, mn;
d435 2
a436 2
        /* locate the major number */
        mn = WDMINOR(self->dv_unit, 0);
d438 2
a439 2
        for (bmaj = 0; bmaj < nblkdev; bmaj++)
                if (bdevsw[bmaj].d_open == wdopen)
d441 2
a442 2
        for (cmaj = 0; cmaj < nchrdev; cmaj++)
                if (cdevsw[cmaj].d_open == wdopen)
d450 2
a451 2
        /* Unhook the entropy source. */
        rnd_detach_source(&sc->rnd_source);
d454 1
a454 1
        return (0);
d459 1
a459 1
        struct device *self;
d461 1
a461 1
        struct wd_softc *sc = (struct wd_softc *)self;
d463 2
a464 2
        /* Detach disk. */
        disk_detach(&sc->sc_dk);
d764 1
a764 1
				       wd->sc_dk.dk_cpulabel, 0);
@


1.28
log
@Some easy strcpy elimination.

a) strcpy -> strncpy for copies into disklabel fields d_packname and
d_typename.

b) '16' -> 'sizeof d_packname' or 'sizeof d_typename' in existing
strncpy's.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.27 2003/02/21 20:10:33 grange Exp $ */
d649 2
a650 1
		ata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);
d1227 2
a1228 1
			ata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);
@


1.27
log
@Fix Manuel Bouyer's copyright, from NetBSD
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.26 2002/12/19 16:32:59 grange Exp $ */
d867 1
a867 1
		strncpy(lp->d_typename, "ST506/MFM/RLL", 16);
d870 1
a870 1
		strncpy(lp->d_typename, "ESDI/IDE disk", 16);
d873 1
a873 1
	strncpy(lp->d_packname, wd->sc_params.atap_model, 16);
@


1.26
log
@Protect WDCDEBUG_PRINT macro with do {} while (0)
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.25 2002/05/24 09:34:25 art Exp $ */
d5 1
a5 1
 * Copyright (c) 1998 Manuel Bouyer.  All rights reserved.
@


1.25
log
@protect biodone with splbio.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.24 2002/05/03 09:18:46 gluk Exp $ */
d125 4
a128 3
#define WDCDEBUG_PRINT(args, level) \
	if (wdcdebug_wd_mask & (level)) \
		printf args
@


1.24
log
@LBA48 support.
Adopted from NetBSD by Alexander Yurchenko <grange@@openbsd.ru>.

costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.23 2002/03/14 03:16:03 millert Exp $ */
d524 1
d526 1
@


1.23
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.22 2002/03/14 01:26:52 millert Exp $ */
d152 1
a152 1
#define WDF_LOADED	  0x10 /* parameters loaded */
d154 2
a155 1
#define WDF_LBA	 0x40 /* using LBA mode */
d157 1
a157 1
	int sc_capacity;
d322 5
d337 14
a350 1
	if ((wd->sc_flags & WDF_LBA) != 0) {
d354 1
a354 1
		printf(" LBA, %dMB, %d cyl, %d head, %d sec, %d sectors\n",
d365 1
a365 1
		printf(" CHS, %dMB, %d cyl, %d head, %d sec, %d sectors\n",
d583 2
d1189 2
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.21 2002/01/07 19:04:46 mickey Exp $ */
d204 1
a204 1
void  wdrestart(void*);
d207 1
a207 1
void  wd_shutdown(void*);
@


1.21
log
@pass the proc* down the ioctl chain to controller; mjacob@@ csapuntz@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.20 2001/11/06 19:53:18 miod Exp $ */
d174 1
a174 1
int	wdprobe		__P((struct device *, struct cfdata *, void *));
d176 1
a176 1
int	wdprobe		__P((struct device *, void *, void *));
d178 5
a182 5
void	wdattach	__P((struct device *, struct device *, void *));
int     wddetach __P((struct device *, int));
int     wdactivate __P((struct device *, enum devact));
void    wdzeroref __P((struct device *));
int	wdprint	__P((void *, char *));
d197 2
a198 2
void  wdgetdefaultlabel __P((struct wd_softc *, struct disklabel *));
void  wdgetdisklabel __P((dev_t dev, struct wd_softc *, 
d200 8
a207 8
				 struct cpu_disklabel *, int));
void  wdstrategy	__P((struct buf *));
void  wdstart	__P((void *));
void  __wdstart	__P((struct wd_softc*, struct buf *));
void  wdrestart __P((void*));
int   wd_get_params __P((struct wd_softc *, u_int8_t, struct ataparams *));
void  wd_flushcache __P((struct wd_softc *, int));
void  wd_shutdown __P((void*));
d216 1
a216 1
void	bad144intern __P((struct wd_softc *));
@


1.20
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.19 2001/08/06 20:50:28 miod Exp $ */
d1045 1
a1045 1
		error = wdc_ioctl(wd->drvp, xfer, addr, flag);
@


1.20.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.21 2002/01/07 19:04:46 mickey Exp $ */
d1045 1
a1045 1
		error = wdc_ioctl(wd->drvp, xfer, addr, flag, p);
@


1.20.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.20.2.1 2002/01/31 22:55:30 niklas Exp $ */
d152 1
a152 1
#define WDF_LOADED	0x10 /* parameters loaded */
d154 1
a154 2
#define WDF_LBA		0x40 /* using LBA mode */
#define WDF_LBA48	0x80 /* using 48-bit LBA mode */
d156 1
a156 1
	u_int64_t sc_capacity;
d174 1
a174 1
int	wdprobe(struct device *, struct cfdata *, void *);
d176 1
a176 1
int	wdprobe(struct device *, void *, void *);
d178 5
a182 5
void	wdattach(struct device *, struct device *, void *);
int     wddetach(struct device *, int);
int     wdactivate(struct device *, enum devact);
void    wdzeroref(struct device *);
int	wdprint(void *, char *);
d197 2
a198 2
void  wdgetdefaultlabel(struct wd_softc *, struct disklabel *);
void  wdgetdisklabel(dev_t dev, struct wd_softc *, 
d200 8
a207 8
				 struct cpu_disklabel *, int);
void  wdstrategy(struct buf *);
void  wdstart(void *);
void  __wdstart(struct wd_softc*, struct buf *);
void  wdrestart(void *);
int   wd_get_params(struct wd_softc *, u_int8_t, struct ataparams *);
void  wd_flushcache(struct wd_softc *, int);
void  wd_shutdown(void *);
d216 1
a216 1
void	bad144intern(struct wd_softc *);
a320 5
	/* use 48-bit LBA if enabled */
	/* XXX: shall we use it if drive capacity < 137Gb? */
	if ((wd->sc_params.atap_cmd2_en & ATAPI_CMD2_48AD) != 0)
		wd->sc_flags |= WDF_LBA48;

d331 1
a331 14
	if ((wd->sc_flags & WDF_LBA48) != 0) {
		wd->sc_capacity =
		    (((u_int64_t)wd->sc_params.atap_max_lba[3] << 48) |
		     ((u_int64_t)wd->sc_params.atap_max_lba[2] << 32) |
		     ((u_int64_t)wd->sc_params.atap_max_lba[1] << 16) |
		      (u_int64_t)wd->sc_params.atap_max_lba[0]);
		printf(" LBA48, %lluMB, %d cyl, %d head,"
		    " %d sec, %llu sectors\n",
		    wd->sc_capacity / (1048576 / DEV_BSIZE),
		    wd->sc_params.atap_cylinders,
		    wd->sc_params.atap_heads,
		    wd->sc_params.atap_sectors,
		    wd->sc_capacity);
	} else if ((wd->sc_flags & WDF_LBA) != 0) {
d335 1
a335 1
		printf(" LBA, %lluMB, %d cyl, %d head, %d sec, %llu sectors\n",
d346 1
a346 1
		printf(" CHS, %lluMB, %d cyl, %d head, %d sec, %llu sectors\n",
a504 1
	s = splbio();
a505 1
	splx(s);
a563 2
	if (wd->sc_flags & WDF_LBA48)
		wd->sc_wdc_bio.flags |= ATA_LBA48;
a1167 2
		if (wd->sc_flags & WDF_LBA48)
			wd->sc_wdc_bio.flags |= ATA_LBA48;
@


1.20.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
d125 3
a127 4
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_wd_mask & (level)) != 0)	\
		printf args;			\
} while (0)
d648 1
a648 2
		ata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf,
		    sizeof buf);
d866 1
a866 1
		strncpy(lp->d_typename, "ST506/MFM/RLL", sizeof lp->d_typename);
d869 1
a869 1
		strncpy(lp->d_typename, "ESDI/IDE disk", sizeof lp->d_typename);
d872 1
a872 1
	strncpy(lp->d_packname, wd->sc_params.atap_model, sizeof lp->d_packname);
d1225 1
a1225 2
			ata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf,
			    sizeof errbuf);
@


1.19
log
@Remove legacy __BDEVSW_DUMP_OLD_TYPE code.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.18 2001/07/31 07:07:00 csapuntz Exp $ */
d93 1
a93 1
#include <vm/vm.h>
@


1.18
log
@
Go down only one Ultra DMA mode at a time. Thanks to Matt Evans for
suggesting this fix.

Update atapiscsi Ultra DMA downgrade logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.17 2001/07/12 02:44:17 csapuntz Exp $ */
a1102 1
#ifndef __BDEVSW_DUMP_OLD_TYPE
a1234 15
#else /* __BDEVSW_DUMP_NEW_TYPE */


int
wddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{

	/* Not implemented. */
	return ENXIO;
}
#endif /* __BDEVSW_DUMP_NEW_TYPE */
@


1.17
log
@extra wddone caused biodone panics occasionally
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.16 2001/04/30 21:19:45 csapuntz Exp $ */
d280 5
@


1.16
log
@

Move ioctl stuff to low-level driver
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.15 2001/04/02 19:41:35 csapuntz Exp $ */
d575 8
a582 1
		wddone(wd);
@


1.15
log
@

ATA_POLL should have been AT_POLL

Flushcache on shutdown used to pass both AT_POLL and AT_WAIT. The two flags
do not make sense together.

Should fix panic when shutting down from ddb
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.14 2001/01/25 03:50:50 todd Exp $ */
d102 1
a102 1
#include <sys/ataio.h>
a106 1
#define	WAITTIME	(4 * hz)	/* time to wait for a completion */
a196 20
/*
 * Glue necessary to hook WDCIOCCOMMAND into physio
 */

struct wd_ioctl {
	LIST_ENTRY(wd_ioctl) wi_list;
	struct buf wi_bp;
	struct uio wi_uio;
	struct iovec wi_iov;
	atareq_t wi_atareq;
	struct wd_softc *wi_softc;
};

LIST_HEAD(, wd_ioctl) wi_head;

struct	wd_ioctl *wi_find __P((struct buf *));
void	wi_free __P((struct wd_ioctl *));
struct	wd_ioctl *wi_get __P((void));
void	wdioctlstrategy __P((struct buf *));

d1031 1
a1031 50

	case ATAIOCCOMMAND:
		/*
		 * Make sure this command is (relatively) safe first
		 */
		if ((((atareq_t *) addr)->flags & ATACMD_READ) == 0 &&
		    (flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
		{
		struct wd_ioctl *wi;
		atareq_t *atareq = (atareq_t *) addr;
		int error;

		wi = wi_get();
		wi->wi_softc = wd;
		wi->wi_atareq = *atareq;

		if (atareq->datalen && atareq->flags &
		    (ATACMD_READ | ATACMD_WRITE)) {
			wi->wi_iov.iov_base = atareq->databuf;
			wi->wi_iov.iov_len = atareq->datalen;
			wi->wi_uio.uio_iov = &wi->wi_iov;
			wi->wi_uio.uio_iovcnt = 1;
			wi->wi_uio.uio_resid = atareq->datalen;
			wi->wi_uio.uio_offset = 0;
			wi->wi_uio.uio_segflg = UIO_USERSPACE;
			wi->wi_uio.uio_rw =
			    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE;
			wi->wi_uio.uio_procp = p;
			error = physio(wdioctlstrategy, &wi->wi_bp, dev,
			    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE,
			    minphys, &wi->wi_uio);
		} else {
			/* No need to call physio if we don't have any
			   user data */
			wi->wi_bp.b_flags = 0;
			wi->wi_bp.b_data = 0;
			wi->wi_bp.b_bcount = 0;
			wi->wi_bp.b_dev = 0;
			wi->wi_bp.b_proc = p;
			wdioctlstrategy(&wi->wi_bp);
			error = wi->wi_bp.b_error;
		}
		*atareq = wi->wi_atareq;
		wi_free(wi);
		goto exit;
		}

d1033 1
a1033 1
		error = ENOTTY;
a1343 179
}

/*
 * Allocate space for a ioctl queue structure.  Mostly taken from
 * scsipi_ioctl.c
 */
struct wd_ioctl *
wi_get()
{
	struct wd_ioctl *wi;
	int s;

	wi = malloc(sizeof(struct wd_ioctl), M_TEMP, M_WAITOK);
	bzero(wi, sizeof (struct wd_ioctl));
	s = splbio();
	LIST_INSERT_HEAD(&wi_head, wi, wi_list);
	splx(s);
	return (wi);
}

/*
 * Free an ioctl structure and remove it from our list
 */

void
wi_free(wi)
	struct wd_ioctl *wi;
{
	int s;

	s = splbio();
	LIST_REMOVE(wi, wi_list);
	splx(s);
	free(wi, M_TEMP);
}

/*
 * Find a wd_ioctl structure based on the struct buf.
 */

struct wd_ioctl *
wi_find(bp)
	struct buf *bp;
{
	struct wd_ioctl *wi;
	int s;

	s = splbio();
	for (wi = wi_head.lh_first; wi != 0; wi = wi->wi_list.le_next)
		if (bp == &wi->wi_bp)
			break;
	splx(s);
	return (wi);
}

/*
 * Ioctl pseudo strategy routine
 *
 * This is mostly stolen from scsipi_ioctl.c:scsistrategy().  What
 * happens here is:
 *
 * - wdioctl() queues a wd_ioctl structure.
 *
 * - wdioctl() calls physio/wdioctlstrategy based on whether or not
 *   user space I/O is required.  If physio() is called, physio() eventually
 *   calls wdioctlstrategy().
 *
 * - In either case, wdioctlstrategy() calls wdc_exec_command()
 *   to perform the actual command
 *
 * The reason for the use of the pseudo strategy routine is because
 * when doing I/O to/from user space, physio _really_ wants to be in
 * the loop.  We could put the entire buffer into the ioctl request
 * structure, but that won't scale if we want to do things like download
 * microcode.
 */

void
wdioctlstrategy(bp)
	struct buf *bp;
{
	struct wd_ioctl *wi;
	struct wdc_command wdc_c;
	int error = 0;

	wi = wi_find(bp);
	if (wi == NULL) {
		printf("user_strat: No ioctl\n");
		error = EINVAL;
		goto bad;
	}

	bzero(&wdc_c, sizeof(wdc_c));

	/*
	 * Abort if physio broke up the transfer
	 */

	if (bp->b_bcount != wi->wi_atareq.datalen) {
		printf("physio split wd ioctl request... cannot proceed\n");
		error = EIO;
		goto bad;
	}

	/*
	 * Abort if we didn't get a buffer size that was a multiple of
	 * our sector size (or was larger than NBBY)
	 */

	if ((bp->b_bcount % wi->wi_softc->sc_dk.dk_label->d_secsize) != 0 ||
	    (bp->b_bcount / wi->wi_softc->sc_dk.dk_label->d_secsize) >=
	     (1 << NBBY)) {
		error = EINVAL;
		goto bad;
	}

	/*
	 * Make sure a timeout was supplied in the ioctl request
	 */

	if (wi->wi_atareq.timeout == 0) {
		error = EINVAL;
		goto bad;
	}

	if (wi->wi_atareq.flags & ATACMD_READ)
		wdc_c.flags |= AT_READ;
	else if (wi->wi_atareq.flags & ATACMD_WRITE)
		wdc_c.flags |= AT_WRITE;

	if (wi->wi_atareq.flags & ATACMD_READREG)
		wdc_c.flags |= AT_READREG;

	wdc_c.flags |= AT_WAIT;

	wdc_c.timeout = wi->wi_atareq.timeout;
	wdc_c.r_command = wi->wi_atareq.command;
	wdc_c.r_head = wi->wi_atareq.head & 0x0f;
	wdc_c.r_cyl = wi->wi_atareq.cylinder;
	wdc_c.r_sector = wi->wi_atareq.sec_num;
	wdc_c.r_count = wi->wi_atareq.sec_count;
	wdc_c.r_precomp = wi->wi_atareq.features;
	wdc_c.r_st_bmask = WDCS_DRDY;
	wdc_c.r_st_pmask = WDCS_DRDY;
	wdc_c.data = wi->wi_bp.b_data;
	wdc_c.bcount = wi->wi_bp.b_bcount;

	if (wdc_exec_command(wi->wi_softc->drvp, &wdc_c) != WDC_COMPLETE) {
		wi->wi_atareq.retsts = ATACMD_ERROR;
		goto bad;
	}

	if (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {
		if (wdc_c.flags & AT_ERROR) {
			wi->wi_atareq.retsts = ATACMD_ERROR;
			wi->wi_atareq.error = wdc_c.r_error;
		} else if (wdc_c.flags & AT_DF)
			wi->wi_atareq.retsts = ATACMD_DF;
		else
			wi->wi_atareq.retsts = ATACMD_TIMEOUT;
	} else {
		wi->wi_atareq.retsts = ATACMD_OK;
		if (wi->wi_atareq.flags & ATACMD_READREG) {
			wi->wi_atareq.head = wdc_c.r_head ;
			wi->wi_atareq.cylinder = wdc_c.r_cyl;
			wi->wi_atareq.sec_num = wdc_c.r_sector;
			wi->wi_atareq.sec_count = wdc_c.r_count; 
			wi->wi_atareq.features = wdc_c.r_precomp; 
			wi->wi_atareq.error = wdc_c.r_error; 
		}
	}

	bp->b_error = 0;
	biodone(bp);
	return;
bad:
	bp->b_flags |= B_ERROR;
	bp->b_error = error;
	biodone(bp);
@


1.14
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.12 2000/04/10 07:06:16 csapuntz Exp $ */
d1383 5
a1387 1
	wdc_c.flags = flags | AT_WAIT;
d1413 1
a1413 1
	wd_flushcache(wd, ATA_POLL);
@


1.13
log
@Convert to new timeout API.
@
text
@d140 1
a140 1
	struct buf *sc_bp; /* buf being transfered */
@


1.12
log
@

Added support for wd detach (merge from NetBSD). Support for
SCSI/ATAPI detach is not here yet.

Minor cleanup of wdc. Downgrade to UDMA mode 1 before going further.
Want to stay in UDMA modes because they're more error-resilient due to
a CRC.

Got rid of some of the ridiculous amount of softc sharing going on.
Hopefully, this will make the life of whoever goes in and fixes the
ref-counting to be correct easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.11 2000/04/07 09:12:44 niklas Exp $ */
d165 1
d387 1
d591 1
a591 1
		timeout(wdrestart, wd, hz);
d642 1
a642 1
			timeout(wdrestart, wd, RECOVERYTIME);
@


1.11
log
@remove statics
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.10 1999/11/17 01:22:55 csapuntz Exp $ */
d91 1
d114 1
a140 1
	void *wdc_softc;   /* pointer to our parent */
d156 1
d165 1
d179 3
d185 2
a186 1
	sizeof(struct wd_softc), wdprobe, wdattach
d238 5
a242 2
int	wdlock	__P((struct wd_softc *));
void	wdunlock	__P((struct wd_softc *));
d295 5
a299 4
	wd->drvp = aa_link->aa_drv_data;;
	wd->wdc_softc = parent;
	/* give back our softc to our caller */
	wd->drvp->drv_softc = &wd->sc_dev;
d302 1
a302 1
	if (wd_get_params(wd, AT_POLL, &wd->sc_params) != 0) {
d378 2
a379 1
	if (shutdownhook_establish(wd_shutdown, wd) == NULL)
d388 73
d469 1
a469 1
	struct wd_softc *wd = wd_cd.cd_devs[WDUNIT(bp->b_dev)];
d471 7
d512 1
d520 2
d584 1
d614 4
d633 2
a634 1
retry:		/* Just reset and retry. Can we do more ? */
a697 47
/*
 * Wait interruptibly for an exclusive lock.
 *
 * XXX
 * Several drivers do this; it should be abstracted and made MP-safe.
 */
int
wdlock(wd)
	struct wd_softc *wd;
{
	int error;
	int s;

	WDCDEBUG_PRINT(("wdlock\n"), DEBUG_FUNCS);

	s = splbio();

	while ((wd->sc_flags & WDF_LOCKED) != 0) {
		wd->sc_flags |= WDF_WANTED;
		if ((error = tsleep(wd, PRIBIO | PCATCH,
		    "wdlck", 0)) != 0) {
			splx(s);
			return error;
		}
	}
	wd->sc_flags |= WDF_LOCKED;
	splx(s);
	return 0;
}

/*
 * Unlock and wake up any waiters.
 */
void
wdunlock(wd)
	struct wd_softc *wd;
{

	WDCDEBUG_PRINT(("wdunlock\n"), DEBUG_FUNCS);

	wd->sc_flags &= ~WDF_LOCKED;
	if ((wd->sc_flags & WDF_WANTED) != 0) {
		wd->sc_flags &= ~WDF_WANTED;
		wakeup(wd);
	}
}

d709 1
d711 1
a711 3
	if (unit >= wd_cd.cd_ndevs)
		return ENXIO;
	wd = wd_cd.cd_devs[unit];
d773 1
d787 1
d797 1
a797 1
	struct wd_softc *wd = wd_cd.cd_devs[WDUNIT(dev)];
d799 5
a803 1
	int error;
d807 1
a807 1
		return error;
d829 4
a832 1
	return 0;
a839 1

d931 2
a932 2
	struct wd_softc *wd = wd_cd.cd_devs[WDUNIT(dev)];
	int error;
d936 8
a943 2
	if ((wd->sc_flags & WDF_LOADED) == 0)
		return EIO;
d953 1
a953 1
		return 0;
d959 1
a959 1
		return 0;
d965 1
a965 1
			return 0;
d970 1
a970 1
		return 0;
d976 1
a976 1
		return 0;
d980 4
a983 2
		if ((flag & FWRITE) == 0)
			return EBADF;
d986 1
a986 1
			return error;
d1003 1
a1003 1
		return error;
d1006 5
a1010 2
		if ((flag & FWRITE) == 0)
			return EBADF;
d1015 1
a1015 1
		return 0;
d1020 1
a1020 1
		return 0;
d1047 1
a1047 1
		return error;
d1056 4
a1059 2
		    (flag & FWRITE) == 0)
			return (EBADF);
d1097 1
a1097 1
		return(error);
d1101 2
a1102 1
		return ENOTTY;
d1108 4
d1129 1
a1129 1
	int part, unit, omask;
d1134 1
a1134 4
	unit = WDUNIT(dev);
	if (unit >= wd_cd.cd_ndevs)
		return (-1);
	wd = wd_cd.cd_devs[unit];
d1141 5
a1145 2
	if (omask == 0 && wdopen(dev, 0, S_IFBLK, NULL) != 0)
		return (-1);
d1152 4
a1155 1
		return (-1);
d1188 2
a1189 4
	if (unit >= wd_cd.cd_ndevs)
		return ENXIO;
	wd = wd_cd.cd_devs[unit];
	if (wd == (struct wd_softc *)0)
d1230 1
@


1.10
log
@

New interface to ATA registers that goes through the lower-level device
driver (pciide, wdc, etc.)

Remove #define WDCDEBUG from top of files

More fixes to ATAPISCSI logic:

Not all devices transition correctly between phases. Devices are supposed
to keep BSY high until they've set the registers to the next sensible
state. Some devices drop BSY and leave the registers in an old or
nonsense state. Our polling code is extremely sensitive to this
(though an early itnerrupt could also observe this). So, if the device is
in an unexpected state, the new polling code waits for a while in the hope
that it enters a better state.

This seems to fix many of the problems reported.

Also, there was a horrible bug which would cause sense to fail on a ATAPI
command that sent data to the drive
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.9 1999/10/09 07:14:00 csapuntz Exp $ */
d211 1
a211 1
static void  wdgetdisklabel __P((dev_t dev, struct wd_softc *, 
d229 1
a229 1
static void bad144intern __P((struct wd_softc *));
d815 1
a815 1
static void
@


1.10.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.15 2001/04/02 19:41:35 csapuntz Exp $ */
a90 1
#include <sys/vnode.h>
a112 1
#define WDMINOR(unit, part)     DISKMINOR(unit, part)
d138 2
a139 1
	struct buf *sc_bp; /* buf being transferred */
a154 1

a162 2
	struct timeout sc_restart_timeout;
	void *sc_sdhook;
a175 3
int     wddetach __P((struct device *, int));
int     wdactivate __P((struct device *, enum devact));
void    wdzeroref __P((struct device *));
d179 1
a179 2
	sizeof(struct wd_softc), wdprobe, wdattach,
	wddetach, wdactivate, wdzeroref
d211 1
a211 1
void  wdgetdisklabel __P((dev_t dev, struct wd_softc *, 
d229 1
a229 1
void	bad144intern __P((struct wd_softc *));
d231 2
a232 5

#define wdlock(wd)  disk_lock(&(wd)->sc_dk)
#define wdunlock(wd)  disk_unlock(&(wd)->sc_dk)
#define wdlookup(unit) (struct wd_softc *)device_lookup(&wd_cd, (unit))

d285 4
a288 5
	wd->drvp = aa_link->aa_drv_data;

	strncpy(wd->drvp->drive_name, wd->sc_dev.dv_xname, 
		sizeof(wd->drvp->drive_name) - 1);
	wd->drvp->cf_flags = wd->sc_dev.dv_cfdata->cf_flags;
d291 1
a291 1
	if (wd_get_params(wd, at_poll, &wd->sc_params) != 0) {
d367 1
a367 2
	wd->sc_sdhook = shutdownhook_establish(wd_shutdown, wd);
	if (wd->sc_sdhook == NULL)
a373 74
	timeout_set(&wd->sc_restart_timeout, wdrestart, wd);
}

int
wdactivate(self, act)
        struct device *self;
        enum devact act;
{
        int rv = 0;

        switch (act) {
        case DVACT_ACTIVATE:
                break;

        case DVACT_DEACTIVATE:
                /*
                 * Nothing to do; we key off the device's DVF_ACTIVATE.
                 */
                break;
        }
        return (rv);
}


int
wddetach(self, flags)
        struct device *self;
        int flags;
{
        struct wd_softc *sc = (struct wd_softc *)self;
        struct buf *dp, *bp;
        int s, bmaj, cmaj, mn;

	/* Remove unprocessed buffers from queue */
	s = splbio();
	for (dp = &sc->sc_q; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;
		
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		biodone(bp);
	}
	splx(s);

        /* locate the major number */
        mn = WDMINOR(self->dv_unit, 0);

        for (bmaj = 0; bmaj < nblkdev; bmaj++)
                if (bdevsw[bmaj].d_open == wdopen)
			vdevgone(bmaj, mn, mn + MAXPARTITIONS - 1, VBLK);
        for (cmaj = 0; cmaj < nchrdev; cmaj++)
                if (cdevsw[cmaj].d_open == wdopen)
			vdevgone(cmaj, mn, mn + MAXPARTITIONS - 1, VCHR);

	/* Get rid of the shutdown hook. */
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);

#if NRND > 0
        /* Unhook the entropy source. */
        rnd_detach_source(&sc->rnd_source);
#endif

        return (0);
}

void
wdzeroref(self)
        struct device *self;
{
        struct wd_softc *sc = (struct wd_softc *)self;

        /* Detach disk. */
        disk_detach(&sc->sc_dk);
d384 1
a384 1
	struct wd_softc *wd;
a385 7

	wd = wdlookup(WDUNIT(bp->b_dev));
	if (wd == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}

a419 1
	device_unref(&wd->sc_dev);
a426 2
	if (wd != NULL)
		device_unref(&wd->sc_dev);
a488 1
	wd->sc_wdc_bio.wd = wd;
d493 1
a493 1
		timeout_add(&wd->sc_restart_timeout, hz);
a517 4
	case ERR_NODEV:
		bp->b_flags |= B_ERROR;
		bp->b_error = ENXIO;
		break;
d533 1
a533 2
retry:
		/* Just reset and retry. Can we do more ? */
d539 1
a539 1
			timeout_add(&wd->sc_restart_timeout, RECOVERYTIME);
d597 47
a654 1

d656 3
a658 1
	wd = wdlookup(unit);
a719 1
	device_unref(&wd->sc_dev);
a732 1
	device_unref(&wd->sc_dev);
d742 1
a742 1
	struct wd_softc *wd;
d744 1
a744 5
	int error = 0;

	wd = wdlookup(WDUNIT(dev));
	if (wd == NULL)
		return ENXIO;
d748 1
a748 1
		goto exit;
d770 1
a770 4

 exit:
	device_unref(&wd->sc_dev);
	return (error);
d778 1
d815 1
a815 1
void
d870 2
a871 2
	struct wd_softc *wd;
	int error = 0;
d875 2
a876 8
	wd = wdlookup(WDUNIT(dev));
	if (wd == NULL)
		return ENXIO;
	
	if ((wd->sc_flags & WDF_LOADED) == 0) {
		error = EIO;
		goto exit;
	}
d886 1
a886 1
		goto exit;
d892 1
a892 1
		goto exit;
d898 1
a898 1
			goto exit;
d903 1
a903 1
		goto exit;
d909 1
a909 1
		goto exit;
d913 2
a914 4
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
d917 1
a917 1
			goto exit;
d934 1
a934 1
		goto exit;
d937 2
a938 5
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}

d943 1
a943 1
		goto exit;
d948 1
a948 1
		goto exit;
d975 1
a975 1
		goto exit;
d984 2
a985 4
		    (flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
d1023 1
a1023 1
		goto exit;
d1027 1
a1027 2
		error = ENOTTY;
		goto exit;
a1032 4

 exit:
	device_unref(&wd->sc_dev);
	return (error);
d1050 1
a1050 1
	int part, omask;
d1055 4
a1058 1
	wd = wdlookup(WDUNIT(dev));
d1065 2
a1066 5
	if (omask == 0 && wdopen(dev, 0, S_IFBLK, NULL) != 0) {
		size = -1;
		goto exit;
	}

d1073 1
a1073 4
		size = -1;

 exit:
	device_unref(&wd->sc_dev);
d1106 4
a1109 2
	wd = wdlookup(unit);
	if (wd == NULL)
a1149 1
		wd->sc_wdc_bio.wd = wd;
d1300 1
a1300 5
	if (flags != 0) {
		wdc_c.flags = AT_POLL;
	} else {
		wdc_c.flags = AT_WAIT;
	}
d1326 1
a1326 1
	wd_flushcache(wd, AT_POLL);
@


1.10.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.10.2.1 2001/05/14 22:23:06 niklas Exp $ */
d102 1
a102 1
#include <dev/ic/wdcvar.h>
d107 1
d198 20
d1052 50
a1101 1
		
d1103 1
a1103 1
		error = wdc_ioctl(wd->drvp, xfer, addr, flag);
d1414 179
@


1.10.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.10.2.2 2001/07/04 10:40:17 niklas Exp $ */
a280 5
	if ((NERRS_MAX - 2) > 0)
		wd->drvp->n_dmaerrs = NERRS_MAX - 2;
	else
		wd->drvp->n_dmaerrs = 0;

d575 1
a575 8
		/* 
		 * This code is never executed because we never set
		 * the ATA_POLL flag above
		 */
#if 0
		if (wd->sc_wdc_bio.flags & ATA_POLL)
			wddone(wd);
#endif
d1091 1
d1224 15
@


1.10.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d93 1
a93 1
#include <uvm/uvm_extern.h>
@


1.10.2.5
log
@Merge in trunk
@
text
@d1045 1
a1045 1
		error = wdc_ioctl(wd->drvp, xfer, addr, flag, p);
@


1.10.2.6
log
@Merge in -current from about a week ago
@
text
@d174 1
a174 1
int	wdprobe(struct device *, struct cfdata *, void *);
d176 1
a176 1
int	wdprobe(struct device *, void *, void *);
d178 5
a182 5
void	wdattach(struct device *, struct device *, void *);
int     wddetach(struct device *, int);
int     wdactivate(struct device *, enum devact);
void    wdzeroref(struct device *);
int	wdprint(void *, char *);
d197 2
a198 2
void  wdgetdefaultlabel(struct wd_softc *, struct disklabel *);
void  wdgetdisklabel(dev_t dev, struct wd_softc *, 
d200 8
a207 8
				 struct cpu_disklabel *, int);
void  wdstrategy(struct buf *);
void  wdstart(void *);
void  __wdstart(struct wd_softc*, struct buf *);
void  wdrestart(void *);
int   wd_get_params(struct wd_softc *, u_int8_t, struct ataparams *);
void  wd_flushcache(struct wd_softc *, int);
void  wd_shutdown(void *);
d216 1
a216 1
void	bad144intern(struct wd_softc *);
@


1.10.2.7
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a5 1
 * Copyright (c) 1998, 2001 Manuel Bouyer.  All rights reserved.
d125 3
a127 4
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_wd_mask & (level)) != 0)	\
		printf args;			\
} while (0)
d152 1
a152 1
#define WDF_LOADED	0x10 /* parameters loaded */
d154 1
a154 2
#define WDF_LBA		0x40 /* using LBA mode */
#define WDF_LBA48	0x80 /* using 48-bit LBA mode */
d156 1
a156 1
	u_int64_t sc_capacity;
a320 5
	/* use 48-bit LBA if enabled */
	/* XXX: shall we use it if drive capacity < 137Gb? */
	if ((wd->sc_params.atap_cmd2_en & ATAPI_CMD2_48AD) != 0)
		wd->sc_flags |= WDF_LBA48;

d331 1
a331 14
	if ((wd->sc_flags & WDF_LBA48) != 0) {
		wd->sc_capacity =
		    (((u_int64_t)wd->sc_params.atap_max_lba[3] << 48) |
		     ((u_int64_t)wd->sc_params.atap_max_lba[2] << 32) |
		     ((u_int64_t)wd->sc_params.atap_max_lba[1] << 16) |
		      (u_int64_t)wd->sc_params.atap_max_lba[0]);
		printf(" LBA48, %lluMB, %d cyl, %d head,"
		    " %d sec, %llu sectors\n",
		    wd->sc_capacity / (1048576 / DEV_BSIZE),
		    wd->sc_params.atap_cylinders,
		    wd->sc_params.atap_heads,
		    wd->sc_params.atap_sectors,
		    wd->sc_capacity);
	} else if ((wd->sc_flags & WDF_LBA) != 0) {
d335 1
a335 1
		printf(" LBA, %lluMB, %d cyl, %d head, %d sec, %llu sectors\n",
d346 1
a346 1
		printf(" CHS, %lluMB, %d cyl, %d head, %d sec, %llu sectors\n",
a504 1
	s = splbio();
a505 1
	splx(s);
a563 2
	if (wd->sc_flags & WDF_LBA48)
		wd->sc_wdc_bio.flags |= ATA_LBA48;
a1167 2
		if (wd->sc_flags & WDF_LBA48)
			wd->sc_wdc_bio.flags |= ATA_LBA48;
@


1.10.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.10.2.7 2003/03/28 00:38:10 niklas Exp $ */
d649 1
a649 2
		ata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf,
		    sizeof buf);
d867 1
a867 1
		strncpy(lp->d_typename, "ST506/MFM/RLL", sizeof lp->d_typename);
d870 1
a870 1
		strncpy(lp->d_typename, "ESDI/IDE disk", sizeof lp->d_typename);
d873 1
a873 1
	strncpy(lp->d_packname, wd->sc_params.atap_model, sizeof lp->d_packname);
d1226 1
a1226 2
			ata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf,
			    sizeof errbuf);
@


1.10.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.10.2.8 2003/05/13 19:34:56 ho Exp $ */
d113 1
a113 1
#define WDMINOR(unit, part)	DISKMINOR(unit, part)
d181 2
a182 2
int	wddetach(struct device *, int);
int	wdactivate(struct device *, enum devact);
d396 2
a397 2
	struct device *self;
	enum devact act;
d399 1
a399 1
	int rv = 0;
d401 11
a411 11
	switch (act) {
	case DVACT_ACTIVATE:
		break;

	case DVACT_DEACTIVATE:
		/*
		* Nothing to do; we key off the device's DVF_ACTIVATE.
		*/
		break;
	}
	return (rv);
d417 2
a418 2
	struct device *self;
	int flags;
d420 3
a422 3
	struct wd_softc *sc = (struct wd_softc *)self;
	struct buf *dp, *bp;
	int s, bmaj, cmaj, mn;
d435 2
a436 2
	/* locate the major number */
	mn = WDMINOR(self->dv_unit, 0);
d438 2
a439 2
	for (bmaj = 0; bmaj < nblkdev; bmaj++)
		if (bdevsw[bmaj].d_open == wdopen)
d441 2
a442 2
	for (cmaj = 0; cmaj < nchrdev; cmaj++)
		if (cdevsw[cmaj].d_open == wdopen)
d450 2
a451 2
	/* Unhook the entropy source. */
	rnd_detach_source(&sc->rnd_source);
d454 1
a454 1
	return (0);
d459 1
a459 1
	struct device *self;
d461 1
a461 1
	struct wd_softc *sc = (struct wd_softc *)self;
d463 2
a464 2
	/* Detach disk. */
	disk_detach(&sc->sc_dk);
d764 1
a764 1
			    wd->sc_dk.dk_cpulabel, 0);
@


1.10.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d137 1
a137 1
	struct bufq *sc_q;
d143 2
a144 2
	struct ataparams sc_params;/* drive characteristics found */
	int sc_flags;
d200 1
a200 1
void  wdgetdisklabel(dev_t dev, struct wd_softc *,
d227 8
a234 1
wdprobe(struct device *parent, void *match_, void *aux)
d266 3
a268 1
wdattach(struct device *parent, struct device *self, void *aux)
a275 6
	wd->sc_q = BUFQ_ALLOC(0);
#ifdef DIAGNOSTIC
	if (wd->sc_q == NULL)
		return;
#endif

d279 1
a279 1
	strncpy(wd->drvp->drive_name, wd->sc_dev.dv_xname,
d344 2
a345 1
		printf(" LBA48, %lluMB, %llu sectors\n",
d347 3
d355 1
a355 1
		printf(" LBA, %lluMB, %llu sectors\n",
d357 3
d386 1
a386 1
		    wd->sc_dev.dv_xname);
d395 3
a397 1
wdactivate(struct device *self, enum devact act)
d414 1
d416 3
a418 1
wddetach(struct device *self, int flags)
d421 1
a421 1
	struct buf *bp;
d426 3
a428 1
	while ((bp = BUFQ_GET(sc->sc_q)) != NULL) {
a452 1
	BUFQ_FREE(sc->sc_q);
d458 2
a459 1
wdzeroref(struct device *self)
d472 2
a473 1
wdstrategy(struct buf *bp)
d486 1
a486 1

d494 1
a494 1

d515 1
a515 1
	BUFQ_ADD(wd->sc_q, bp);
d536 2
a537 1
wdstart(void *arg)
d540 1
a540 1
	struct buf *bp = NULL;
d547 6
a552 4
		if ((bp = BUFQ_GET(wd->sc_q)) == NULL)
			return;

		/*
d563 3
a565 1
__wdstart(struct wd_softc *wd, struct buf *bp)
a567 2
	daddr_t nblks;

d586 1
a586 4
	nblks = bp->b_bcount / wd->sc_dk.dk_label->d_secsize;
	if ((wd->sc_flags & WDF_LBA48) &&
	    /* use LBA48 only if really need */
	    ((wd->sc_wdc_bio.blkno + nblks - 1 > 0xfffffff) || (nblks > 0xff)))
d604 1
a604 1
		/*
d619 2
a620 1
wddone(void *v)
d680 2
a681 1
wdrestart(void *v)
d695 4
a698 1
wdread(dev_t dev, struct uio *uio, int flags)
d706 4
a709 1
wdwrite(dev_t dev, struct uio *uio, int flags)
d717 4
a720 1
wdopen(dev_t dev, int flag, int fmt, struct proc *p)
d777 1
a777 1

d810 4
a813 1
wdclose(dev_t dev, int flag, int fmt, struct proc *p)
d822 1
a822 1

d839 1
a839 1
		wd_flushcache(wd, 0);
d854 3
a856 1
wdgetdefaultlabel(struct wd_softc *wd, struct disklabel *lp)
d895 6
a900 2
wdgetdisklabel(dev_t dev, struct wd_softc *wd, struct disklabel *lp,
    struct cpu_disklabel *clp, int spoofonly)
d942 6
a947 1
wdioctl(dev_t dev, u_long xfer, caddr_t addr, int flag, struct proc *p)
d957 1
a957 1

d989 1
a989 1

d995 1
a995 1

d1022 1
a1022 1

d1049 1
a1049 1

d1068 1
a1068 1

d1094 2
a1095 1
wdsize(dev_t dev)
d1115 5
a1119 2
	size = wd->sc_dk.dk_label->d_partitions[part].p_size *
	    (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
d1137 5
a1141 1
wddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
d1175 1
a1175 1
		return EINVAL;
d1186 1
a1186 1

d1232 1
a1232 1
		case NOERROR:
d1269 2
a1270 1
bad144intern(struct wd_softc *wd)
d1292 4
a1295 1
wd_get_params(struct wd_softc *wd, u_int8_t flags, struct ataparams *params)
d1325 3
a1327 1
wd_flushcache(struct wd_softc *wd, int flags)
d1363 2
a1364 1
wd_shutdown(void *arg)
@


1.10.2.11
log
@Merge with the trunk
@
text
@d137 1
a137 1
	struct buf sc_q;
d267 6
d406 1
a406 1
	struct buf *dp, *bp;
d411 1
a411 2
	for (dp = &sc->sc_q; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;
d436 1
d497 1
a497 1
	disksort(&wd->sc_q, bp);
d521 1
a521 1
	struct buf *dp, *bp = NULL;
d528 1
a528 2
		dp = &wd->sc_q;
		if ((bp = dp->b_actf) == NULL)  /* yes, an assign */
a529 1
		dp->b_actf = bp->b_actf;
d651 1
a651 2
	disk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));
@


1.9
log
@

Fix printout at attach time. Print PIO/DMA mode information after having
printed line with the name of hard disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.8 1999/10/09 03:42:03 csapuntz Exp $ */
a67 4

#ifndef WDCDEBUG
#define WDCDEBUG
#endif /* WDCDEBUG */
@


1.8
log
@

wdc layer work:
Separate wdc_probe_caps into wdc_probe_caps and wdc_print_caps for more
flexibility in printing capability information.

Get rid of wdc_final_attach.

Include name of device (e.g. cd0), if possible, on errors.

atapiscsi layer work:
Put a pointer to the SCSI device into ata_drive_datas' drv_softc field

Simplify, simplify, simplify. Got rid of a bunch of fields in atapiscsi_softc

Delay printing capabilities until we know the real device name (e.g. st0)
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.7 1999/08/15 09:47:18 millert Exp $ */
a299 3
	wdc_probe_caps(wd->drvp, &wd->sc_params);
	wdc_print_caps(wd->drvp);

d317 3
@


1.7
log
@o Correctly set type and typename in driver-generated label
Should really use viscopy() when copying atap_model -> d_packname.
When wd's become sd's this will be trivial (viscopy() lives in sd.c)
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.6 1999/08/10 23:09:49 deraadt Exp $ */
d299 3
@


1.6
log
@support DIOCRLDINFO
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.5 1999/08/05 00:12:09 niklas Exp $ */
d788 1
a788 2
#if 0
	if (strcmp(wd->sc_params.atap_model, "ST506") == 0) {
d790 1
a790 1
		strncpy(lp->d_typename, "ST506 disk", 16);
d793 1
a793 2
		strncpy(lp->d_typename, "ESDI/IDE",
		sizeof lp->d_typename);
d795 2
a796 3
#endif
	strncpy(lp->d_typename, wd->sc_params.atap_model, 16);
	strncpy(lp->d_packname, "fictitious", 16);
@


1.5
log
@Make IDE compile on alpha again:
use b* instead of mem* functions, adhere to NISADMA for DMA support.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.4 1999/07/22 04:36:47 deraadt Exp $ */
d893 4
@


1.4
log
@shorten dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.3 1999/07/22 04:00:42 csapuntz Exp $ */
d781 1
a781 1
	memset(lp, 0, sizeof(struct disklabel));
d831 1
a831 1
	memset(clp, 0, sizeof(struct cpu_disklabel));
d1296 1
a1296 1
	memset(&wdc_c, 0, sizeof(struct wdc_command));
d1340 1
a1340 1
	memset(wi, 0, sizeof (struct wd_ioctl));
d1419 1
a1419 1
	memset(&wdc_c, 0, sizeof(wdc_c));
@


1.3
log
@

Fix bad144intern.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.2 1999/07/20 03:23:05 csapuntz Exp $ */
d324 1
a324 2
	printf("%s: drive supports %d-sector pio transfers,",
	    wd->sc_dev.dv_xname, wd->sc_multi);
a336 1
		printf(" lba addressing\n");
d340 1
a340 3
		printf("%s: %dMB, %d cyl, %d head, %d sec, "
		    "%d bytes/sect x %d sectors\n",
		    self->dv_xname,
a344 1
		    DEV_BSIZE,
a346 1
		printf(" chs addressing\n");
d351 1
a351 2
		printf("%s: %dMB, %d cyl, %d head, %d sec, %d bytes/sect x %d "
		    "sectors\n", self->dv_xname,
a355 1
		    DEV_BSIZE,
@


1.2
log
@

126 -> NBT_BAD

Fix disklabel/bad sectors stuff in wd
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.1 1999/07/18 21:25:17 csapuntz Exp $ */
d1243 1
a1243 1
	struct dkbad *bt = &wd->sc_dk.dk_cpulabel->bad;
@


1.1
log
@

Import of NetBSD ATA/IDE stuff.

Introduction of home-grown

To enable this stuff in your configuration, look at the NEWATA conf file
and go through

dev/isa/files.isa
dev/pci/files.pci
conf/files
arch/i386/conf/files.i386

and follow the instructions on commenting/uncommenting stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.193 1999/02/28 17:15:27 explorer Exp $ */
d215 3
a217 1
static void  wdgetdisklabel	__P((dev_t dev, struct wd_softc *));
d232 1
a232 1
#ifdef HAS_BAD144_HANDLING
a694 2
			int ret;

d698 1
a698 4
			ret = wd_get_params(wd, AT_WAIT, &wd->sc_params);
			if (ret != 0) {
				panic ("Parameter loading problem: %d\n");
			}
d701 2
a702 1
			wdgetdisklabel(dev, wd);
d828 1
a828 1
wdgetdisklabel(dev, wd)
d831 3
a834 1
	struct disklabel *lp = wd->sc_dk.dk_label;
d839 1
a839 1
	memset(wd->sc_dk.dk_cpulabel, 0, sizeof(struct cpu_disklabel));
d848 1
a848 1
	    wdstrategy, lp, wd->sc_dk.dk_cpulabel, 0);
d859 1
a859 1
		    wdstrategy, lp, wd->sc_dk.dk_cpulabel, 0);
d868 1
a868 1
#ifdef HAS_BAD144_HANDLING
d891 1
a891 1
#ifdef HAS_BAD144_HANDLING
d895 1
a895 1
		wd->sc_dk.dk_cpulabel->bad = *(struct dkbad *)addr;
d901 8
d1235 1
a1235 1
#ifdef HAS_BAD144_HANDLING
@

