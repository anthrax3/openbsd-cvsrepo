head	1.50;
access;
symbols
	OPENBSD_6_2:1.50.0.10
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.50.0.8
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.49.0.4
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.47.0.4
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.46.0.6
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.44.0.4
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.2
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.4
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.4
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.8
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.6
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.16
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.50
date	2015.08.17.15.36.29;	author krw;	state Exp;
branches;
next	1.49;
commitid	Le3SuX5chjCNZy3I;

1.49
date	2015.04.04.13.03.44;	author mpi;	state Exp;
branches;
next	1.48;
commitid	Gt2EAzj8T0ZD5UyL;

1.48
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.47;
commitid	p4LJxGKbi0BU2cG6;

1.47
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.46;
commitid	uzzBR7hz9ncd4O6G;

1.46
date	2013.11.06.12.06.58;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.17.02.36.45;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2011.11.15.17.14.14;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2011.11.14.00.25.17;	author mlarkin;	state Exp;
branches;
next	1.42;

1.42
date	2011.11.13.23.13.28;	author mlarkin;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.22.22.12.45;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.15.16.44.18;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2011.05.24.23.18.47;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.18.04.16.13;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.05.19.57.40;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.03.23.17.13;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2010.11.06.16.53.15;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.23.07.47.12;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.27.06.03.08;	author ray;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.07.12.58.30;	author sthen;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.14.00.53.47;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.04.00.52.55;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.21.12.09.01;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.02.18.55.08;	author grange;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.23.20.48.33;	author grange;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.15.21.37.57;	author grange;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.17.08.14.09;	author grange;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.16.11.30.00;	author grange;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.28.21.01.42;	author grange;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.23.22.07.15;	author grange;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.21.20.10.33;	author grange;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.13.20.54.59;	author grange;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.10.13.50.56;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.19.16.32.59;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.03.09.18.46;	author gluk;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.16.23.23.42;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.28.19.49.36;	author csapuntz;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.07.31.06.14.05;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.21.09.08.48;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.21.08.30.19;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.25.18.25.00;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.25.13.11.56;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.30.01.03.40;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.10.07.06.16;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	99.11.17.01.22.55;	author csapuntz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.11.05.04.29.34;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	99.10.27.20.10.28;	author chris;	state Exp;
branches;
next	1.1;

1.1
date	99.07.18.21.25.17;	author csapuntz;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.14.22.23.05;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2004.06.05.23.12.37;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.50
log
@The 80's called and want their interface back. Remove last fragments of
ST-506 support. Remove redundant 'precomp' variables/fields and rename
remaining few to 'features' to be consistant with the rest of the code.

Consensus that no ST-506 disks (requiring ISA cards, <120MB, usually
rife with bad sectors that can't be worked around) are still running
OpenBSD.
@
text
@/*      $OpenBSD: ata_wdc.c,v 1.49 2015/04/04 13:03:44 mpi Exp $	*/
/*	$NetBSD: ata_wdc.c,v 1.21 1999/08/09 09:43:11 bouyer Exp $	*/

/*
 * Copyright (c) 1998, 2001 Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum, by Onno van der Linden and by Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/syslog.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/ata/atavar.h>
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcvar.h>
#include <dev/ata/wdvar.h>

#ifdef HIBERNATE
#include <sys/hibernate.h>
#endif

#define DEBUG_INTR   0x01
#define DEBUG_XFERS  0x02
#define DEBUG_STATUS 0x04
#define DEBUG_FUNCS  0x08
#define DEBUG_PROBE  0x10

#ifdef WDCDEBUG
#ifndef WDCDEBUG_WD_MASK
#define WDCDEBUG_WD_MASK 0x00
#endif
int wdcdebug_wd_mask = WDCDEBUG_WD_MASK;
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_wd_mask & (level)) != 0)	\
		printf args;			\
} while (0)
#else
#define WDCDEBUG_PRINT(args, level)
#endif

#define ATA_DELAY 45000 /* 45s for a drive I/O */

void  wdc_ata_bio_start(struct channel_softc *, struct wdc_xfer *);
void  _wdc_ata_bio_start(struct channel_softc *, struct wdc_xfer *);
int   wdc_ata_bio_intr(struct channel_softc *, struct wdc_xfer *, int);
void  wdc_ata_bio_kill_xfer(struct channel_softc *, struct wdc_xfer *);
void  wdc_ata_bio_done(struct channel_softc *, struct wdc_xfer *);
int   wdc_ata_ctrl_intr(struct channel_softc *, struct wdc_xfer *, int);
int   wdc_ata_err(struct ata_drive_datas *, struct ata_bio *);
#define WDC_ATA_NOERR 0x00 /* Drive doesn't report an error */
#define WDC_ATA_RECOV 0x01 /* There was a recovered error */
#define WDC_ATA_ERR   0x02 /* Drive reports an error */

#ifdef HIBERNATE
int
wd_hibernate_io(dev_t dev, daddr_t blkno, vaddr_t addr, size_t size, int op, void *page)
{
	struct {
		struct wd_softc wd;
		struct wdc_xfer xfer;
		struct channel_softc chp;
		daddr_t poffset;
		size_t psize;
	} *my = page;
	struct wd_softc *real_wd, *wd = &my->wd;
	struct wdc_xfer *xfer = &my->xfer;
	struct channel_softc *chp = &my->chp;
	struct ata_bio *ata_bio;
	extern struct cfdriver wd_cd;

	/* early call for initialization */
	if (op == HIB_INIT) {
		my->poffset = blkno;
		my->psize = size;
		return(0);
	}

	real_wd = (struct wd_softc *)disk_lookup(&wd_cd, DISKUNIT(dev));
	if (real_wd == NULL)
		return (ENODEV);

	if (op == HIB_DONE) {
		struct wdc_softc *wdc = chp->wdc;
		config_suspend(&wdc->sc_dev, DVACT_RESUME);
		return (0);
	}

	if (blkno > my->psize)
		return (E2BIG);
	blkno += my->poffset;

	/*
	 * Craft a fake set of softc and related structures
	 * which we think the driver modifies.  Some of these will
	 * have pointers which reach to unsafe places, but..
	 */
	bcopy(real_wd->drvp->chnl_softc, &my->chp, sizeof my->chp);
	chp->ch_drive[0].chnl_softc = chp;
	chp->ch_drive[1].chnl_softc = chp;

	bcopy(real_wd, &my->wd, sizeof my->wd);
	ata_bio = &wd->sc_wdc_bio;
	ata_bio->wd = wd;		/* fixup ata_bio->wd */
	wd->drvp = &chp->ch_drive[real_wd->drvp->drive];

	/* Fill the request and submit it */
	wd->sc_wdc_bio.blkno = blkno;
	wd->sc_wdc_bio.flags = ATA_POLL | ATA_LBA48;
	if (op == HIB_R)
		wd->sc_wdc_bio.flags |= ATA_READ;
	wd->sc_wdc_bio.bcount = size;
	wd->sc_wdc_bio.databuf = (caddr_t)addr;
	wd->sc_wdc_bio.wd = wd;

	bzero(&my->xfer, sizeof my->xfer);
	xfer->c_flags |= C_PRIVATEXFER;	/* Our xfer is totally private */
	xfer->c_flags |= C_POLL;
	xfer->drive = wd->drvp->drive;
	xfer->cmd = ata_bio;
	xfer->databuf = ata_bio->databuf;
	xfer->c_bcount = ata_bio->bcount;
	xfer->c_start = wdc_ata_bio_start;
	xfer->c_intr = wdc_ata_bio_intr;
	xfer->c_kill_xfer = wdc_ata_bio_kill_xfer;
	wdc_exec_xfer(chp, xfer);
	return (ata_bio->flags & ATA_ITSDONE) ? 0 : EIO;
}
#endif /* HIBERNATE */

/*
 * Handle block I/O operation. Return WDC_COMPLETE, WDC_QUEUED, or
 * WDC_TRY_AGAIN. Must be called at splbio().
 */
int
wdc_ata_bio(struct ata_drive_datas *drvp, struct ata_bio *ata_bio)
{
	struct wdc_xfer *xfer;
	struct channel_softc *chp = drvp->chnl_softc;

	xfer = wdc_get_xfer(WDC_NOSLEEP);
	if (xfer == NULL)
		return WDC_TRY_AGAIN;
	if (ata_bio->flags & ATA_POLL)
		xfer->c_flags |= C_POLL;
	if (!(ata_bio->flags & ATA_POLL) &&
	    (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) &&
	    (ata_bio->flags & ATA_SINGLE) == 0 &&
	    (ata_bio->bcount > 512 ||
	    (chp->wdc->quirks & WDC_QUIRK_NOSHORTDMA) == 0))
		xfer->c_flags |= C_DMA;
	xfer->drive = drvp->drive;
	xfer->cmd = ata_bio;
	xfer->databuf = ata_bio->databuf;
	xfer->c_bcount = ata_bio->bcount;
	xfer->c_start = wdc_ata_bio_start;
	xfer->c_intr = wdc_ata_bio_intr;
	xfer->c_kill_xfer = wdc_ata_bio_kill_xfer;
	wdc_exec_xfer(chp, xfer);
	return (ata_bio->flags & ATA_ITSDONE) ? WDC_COMPLETE : WDC_QUEUED;
}

void
wdc_ata_bio_start(struct channel_softc *chp, struct wdc_xfer *xfer)
{
	struct ata_bio *ata_bio = xfer->cmd;
	WDCDEBUG_PRINT(("wdc_ata_bio_start %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),
	    DEBUG_XFERS);

	/* start timeout machinery */
	if ((ata_bio->flags & ATA_POLL) == 0)
		timeout_add_msec(&chp->ch_timo, ATA_DELAY);
	_wdc_ata_bio_start(chp, xfer);
}

void
_wdc_ata_bio_start(struct channel_softc *chp, struct wdc_xfer *xfer)
{
	struct ata_bio *ata_bio = xfer->cmd;
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	u_int16_t cyl;
	u_int8_t head, sect, cmd = 0;
	int nblks;
	int ata_delay;
	int error, dma_flags = 0;

	WDCDEBUG_PRINT(("_wdc_ata_bio_start %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),
	    DEBUG_INTR | DEBUG_XFERS);
	/* Do control operations specially. */
	if (drvp->state < READY) {
		/*
		 * Actually, we want to be careful not to mess with the control
		 * state if the device is currently busy, but we can assume
		 * that we never get to this point if that's the case.
		 */
		/* at this point, we should only be in RECAL state */
		if (drvp->state != RECAL) {
			printf("%s:%d:%d: bad state %d in _wdc_ata_bio_start\n",
			    chp->wdc->sc_dev.dv_xname, chp->channel,
			    xfer->drive, drvp->state);
			panic("_wdc_ata_bio_start: bad state");
		}
		xfer->c_intr = wdc_ata_ctrl_intr;
		wdc_set_drive(chp, xfer->drive);
		if (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, ATA_DELAY) != 0)
			goto timeout;
		wdccommandshort(chp, xfer->drive, WDCC_RECAL);
		drvp->state = RECAL_WAIT;
		if ((ata_bio->flags & ATA_POLL) == 0) {
			chp->ch_flags |= WDCF_IRQ_WAIT;
		} else {
			/* Wait for at last 400ns for status bit to be valid */
			DELAY(1);
			wdc_ata_ctrl_intr(chp, xfer, 0);
		}
		return;
	}

	if (xfer->c_flags & C_DMA) {
		if (drvp->n_xfers <= NXFER)
			drvp->n_xfers++;
		dma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;
		if (ata_bio->flags & ATA_LBA48)
			dma_flags |= WDC_DMA_LBA48;
	}
	if (ata_bio->flags & ATA_SINGLE)
		ata_delay = ATA_DELAY;
	else
		ata_delay = ATA_DELAY;
again:
	/*
	 *
	 * When starting a multi-sector transfer, or doing single-sector
	 * transfers...
	 */
	if (xfer->c_skip == 0 || (ata_bio->flags & ATA_SINGLE) != 0) {
		if (ata_bio->flags & ATA_SINGLE)
			nblks = 1;
		else
			nblks = xfer->c_bcount / ata_bio->lp->d_secsize;
		if (ata_bio->flags & ATA_LBA) {
			sect = (ata_bio->blkno >> 0) & 0xff;
			cyl = (ata_bio->blkno >> 8) & 0xffff;
			head = (ata_bio->blkno >> 24) & 0x0f;
			head |= WDSD_LBA;
		} else {
			int blkno = ata_bio->blkno;
			sect = blkno % ata_bio->lp->d_nsectors;
			sect++;    /* Sectors begin with 1, not 0. */
			blkno /= ata_bio->lp->d_nsectors;
			head = blkno % ata_bio->lp->d_ntracks;
			blkno /= ata_bio->lp->d_ntracks;
			cyl = blkno;
			head |= WDSD_CHS;
		}
		if (xfer->c_flags & C_DMA) {
			ata_bio->nblks = nblks;
			ata_bio->nbytes = xfer->c_bcount;
			if (ata_bio->flags & ATA_LBA48)
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READDMA_EXT : WDCC_WRITEDMA_EXT;
			else
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READDMA : WDCC_WRITEDMA;
	    		/* Init the DMA channel. */
			error = (*chp->wdc->dma_init)(chp->wdc->dma_arg,
			    chp->channel, xfer->drive,
			    (char *)xfer->databuf + xfer->c_skip,
			    ata_bio->nbytes, dma_flags);
			if (error) {
				if (error == EINVAL) {
					/*
					 * We can't do DMA on this transfer
					 * for some reason.  Fall back to
					 * PIO.
					 */
					xfer->c_flags &= ~C_DMA;
					error = 0;
					goto do_pio;
				}
				ata_bio->error = ERR_DMA;
				ata_bio->r_error = 0;
				wdc_ata_bio_done(chp, xfer);
				return;
			}
			/* Initiate command */
			wdc_set_drive(chp, xfer->drive);
			if (wait_for_ready(chp, ata_delay) < 0)
				goto timeout;

			/* start the DMA channel (before) */
			if (chp->ch_flags & WDCF_DMA_BEFORE_CMD)
				(*chp->wdc->dma_start)(chp->wdc->dma_arg,
				    chp->channel, xfer->drive);

			if (ata_bio->flags & ATA_LBA48) {
				wdccommandext(chp, xfer->drive, cmd,
				    (u_int64_t)ata_bio->blkno, nblks);
			} else {
				wdccommand(chp, xfer->drive, cmd, cyl,
				    head, sect, nblks, 0);
			}

			/* start the DMA channel (after) */
			if ((chp->ch_flags & WDCF_DMA_BEFORE_CMD) == 0)
				(*chp->wdc->dma_start)(chp->wdc->dma_arg,
				    chp->channel, xfer->drive);

			chp->ch_flags |= WDCF_DMA_WAIT;
			/* wait for irq */
			goto intr;
		} /* else not DMA */
 do_pio:
		ata_bio->nblks = min(nblks, ata_bio->multi);
		ata_bio->nbytes = ata_bio->nblks * ata_bio->lp->d_secsize;
		KASSERT(nblks == 1 || (ata_bio->flags & ATA_SINGLE) == 0);
		if (ata_bio->nblks > 1) {
			if (ata_bio->flags & ATA_LBA48)
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READMULTI_EXT : WDCC_WRITEMULTI_EXT;
			else
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READMULTI : WDCC_WRITEMULTI;
		} else {
			if (ata_bio->flags & ATA_LBA48)
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READ_EXT : WDCC_WRITE_EXT;
			else
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READ : WDCC_WRITE;
		}
		/* Initiate command! */
		wdc_set_drive(chp, xfer->drive);
		if (wait_for_ready(chp, ata_delay) < 0)
			goto timeout;
		if (ata_bio->flags & ATA_LBA48) {
			wdccommandext(chp, xfer->drive, cmd,
			    (u_int64_t)ata_bio->blkno, nblks);
		} else {
			wdccommand(chp, xfer->drive, cmd, cyl,
			    head, sect, nblks, 0);
		}
	} else if (ata_bio->nblks > 1) {
		/* The number of blocks in the last stretch may be smaller. */
		nblks = xfer->c_bcount / ata_bio->lp->d_secsize;
		if (ata_bio->nblks > nblks) {
			ata_bio->nblks = nblks;
			ata_bio->nbytes = xfer->c_bcount;
		}
	}
	/* If this was a write and not using DMA, push the data. */
	if ((ata_bio->flags & ATA_READ) == 0) {
		if (wait_for_drq(chp, ata_delay) != 0) {
			printf("%s:%d:%d: timeout waiting for DRQ, "
			    "st=0x%b, err=0x%02x\n",
			    chp->wdc->sc_dev.dv_xname, chp->channel,
			    xfer->drive, chp->ch_status, WDCS_BITS,
			    chp->ch_error);
			if (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)
				ata_bio->error = TIMEOUT;
			wdc_ata_bio_done(chp, xfer);
			return;
		}
		if (wdc_ata_err(drvp, ata_bio) == WDC_ATA_ERR) {
			wdc_ata_bio_done(chp, xfer);
			return;
		}
		wdc_output_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,
		    ata_bio->nbytes);
	}

intr:	/* Wait for IRQ (either real or polled) */
	if ((ata_bio->flags & ATA_POLL) == 0) {
		chp->ch_flags |= WDCF_IRQ_WAIT;
	} else {
		/* Wait for at last 400ns for status bit to be valid */
		delay(1);
		if (chp->ch_flags & WDCF_DMA_WAIT) {
			wdc_dmawait(chp, xfer, ATA_DELAY);
			chp->ch_flags &= ~WDCF_DMA_WAIT;
		}
		wdc_ata_bio_intr(chp, xfer, 0);
		if ((ata_bio->flags & ATA_ITSDONE) == 0)
			goto again;
	}
	return;
timeout:
	if (chp->ch_status == 0xff)
		return;
	printf("%s:%d:%d: not ready, st=0x%b, err=0x%02x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    chp->ch_status, WDCS_BITS, chp->ch_error);
	if (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)
		ata_bio->error = TIMEOUT;
	wdc_ata_bio_done(chp, xfer);
	return;
}

int
wdc_ata_bio_intr(struct channel_softc *chp, struct wdc_xfer *xfer, int irq)
{
	struct ata_bio *ata_bio = xfer->cmd;
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	int drv_err;

	WDCDEBUG_PRINT(("wdc_ata_bio_intr %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),
	    DEBUG_INTR | DEBUG_XFERS);


	/* Is it not a transfer, but a control operation? */
	if (drvp->state < READY) {
		printf("%s:%d:%d: bad state %d in wdc_ata_bio_intr\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
		    drvp->state);
		panic("wdc_ata_bio_intr: bad state");
	}

	/*
	 * reset on timeout. This will cause extra resets in the case
	 * of occasional lost interrupts
	 */
	if (xfer->c_flags & C_TIMEOU)
		goto timeout;

	/* Ack interrupt done by wait_for_unbusy */
	if (wait_for_unbusy(chp,
	    (irq == 0) ? ATA_DELAY : 0) < 0) {
		if (irq)
			return 0; /* IRQ was not for us */
		printf("%s:%d:%d: device timeout, c_bcount=%d, c_skip%d\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
		    xfer->c_bcount, xfer->c_skip);

		goto timeout;
	}
	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);

	drv_err = wdc_ata_err(drvp, ata_bio);

	if (xfer->c_flags & C_DMA) {
		if (chp->wdc->dma_status != 0) {
			if (drv_err != WDC_ATA_ERR) {
				ata_bio->error = ERR_DMA;
				drv_err = WDC_ATA_ERR;
			}
		}
		if (chp->ch_status & WDCS_DRQ) {
			if (drv_err != WDC_ATA_ERR) {
				printf("%s:%d:%d: intr with DRQ (st=0x%b)\n",
				    chp->wdc->sc_dev.dv_xname, chp->channel,
				    xfer->drive, chp->ch_status, WDCS_BITS);
				ata_bio->error = TIMEOUT;
				drv_err = WDC_ATA_ERR;
			}
		}
		if (drv_err != WDC_ATA_ERR)
			goto end;
		ata_dmaerr(drvp);
	}

	/* if we had an error, end */
	if (drv_err == WDC_ATA_ERR) {
		wdc_ata_bio_done(chp, xfer);
		return 1;
	}

	/* If this was a read and not using DMA, fetch the data. */
	if ((ata_bio->flags & ATA_READ) != 0) {
		if ((chp->ch_status & WDCS_DRQ) != WDCS_DRQ) {
			printf("%s:%d:%d: read intr before drq\n",
			    chp->wdc->sc_dev.dv_xname, chp->channel,
			    xfer->drive);
			ata_bio->error = TIMEOUT;
			wdc_ata_bio_done(chp, xfer);
			return 1;
		}
		wdc_input_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,
		    ata_bio->nbytes);
	}
end:
	ata_bio->blkno += ata_bio->nblks;
	ata_bio->blkdone += ata_bio->nblks;
	xfer->c_skip += ata_bio->nbytes;
	xfer->c_bcount -= ata_bio->nbytes;
	/* See if this transfer is complete. */
	if (xfer->c_bcount > 0) {
		if ((ata_bio->flags & ATA_POLL) == 0) {
			/* Start the next operation */
			_wdc_ata_bio_start(chp, xfer);
		} else {
			/* Let _wdc_ata_bio_start do the loop */
			return 1;
		}
	} else { /* Done with this transfer */
		ata_bio->error = NOERROR;
		wdc_ata_bio_done(chp, xfer);
	}
	return 1;

timeout:
	if (xfer->c_flags & C_DMA)
		ata_dmaerr(drvp);

	ata_bio->error = TIMEOUT;
	wdc_ata_bio_done(chp, xfer);
	return 1;
}

void
wdc_ata_bio_kill_xfer(struct channel_softc *chp, struct wdc_xfer *xfer)
{
	struct ata_bio *ata_bio = xfer->cmd;

	timeout_del(&chp->ch_timo);
	/* remove this command from xfer queue */
	wdc_free_xfer(chp, xfer);

	ata_bio->flags |= ATA_ITSDONE;
	ata_bio->error = ERR_NODEV;
	ata_bio->r_error = WDCE_ABRT;
	if ((ata_bio->flags & ATA_POLL) == 0) {
		WDCDEBUG_PRINT(("wdc_ata_done: wddone\n"), DEBUG_XFERS);
		wddone(ata_bio->wd);
	}
}

void
wdc_ata_bio_done(struct channel_softc *chp, struct wdc_xfer *xfer)
{
	struct ata_bio *ata_bio = xfer->cmd;

	WDCDEBUG_PRINT(("wdc_ata_bio_done %s:%d:%d: flags 0x%x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    (u_int)xfer->c_flags),
	    DEBUG_XFERS);

	if ((xfer->c_flags & C_PRIVATEXFER) == 0)
		timeout_del(&chp->ch_timo);

	/* feed back residual bcount to our caller */
	ata_bio->bcount = xfer->c_bcount;

	/* remove this command from xfer queue */
	wdc_free_xfer(chp, xfer);

	ata_bio->flags |= ATA_ITSDONE;
	if ((ata_bio->flags & ATA_POLL) == 0) {
		WDCDEBUG_PRINT(("wdc_ata_done: wddone\n"), DEBUG_XFERS);
		wddone(ata_bio->wd);
	}
	WDCDEBUG_PRINT(("wdcstart from wdc_ata_done, flags 0x%x\n",
	    chp->ch_flags), DEBUG_XFERS);
	wdcstart(chp);
}

/*
 * Implement operations needed before read/write.
 */
int
wdc_ata_ctrl_intr(struct channel_softc *chp, struct wdc_xfer *xfer, int irq)
{
	struct ata_bio *ata_bio = xfer->cmd;
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	char *errstring = NULL;
	int delay = (irq == 0) ? ATA_DELAY : 0;

	WDCDEBUG_PRINT(("wdc_ata_ctrl_intr: state %d\n", drvp->state),
	    DEBUG_FUNCS);

again:
	switch (drvp->state) {
	case RECAL:    /* Should not be in this state here */
		panic("wdc_ata_ctrl_intr: state==RECAL");
		break;

	case RECAL_WAIT:
		errstring = "recal";
		if (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))
			goto timeout;
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
		if (chp->ch_status & (WDCS_ERR | WDCS_DWF))
			goto error;
	/* FALLTHROUGH */

	case PIOMODE:
		/* Don't try to set modes if controller can't be adjusted */
		if ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0)
			goto geometry;
		/* Also don't try if the drive didn't report its mode */
		if ((drvp->drive_flags & DRIVE_MODE) == 0)
			goto geometry;
		/* SET FEATURES 0x08 is only for PIO mode > 2 */
		if (drvp->PIO_mode <= 2)
			goto geometry;
		wdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,
		    0x08 | drvp->PIO_mode, WDSF_SET_MODE);
		drvp->state = PIOMODE_WAIT;
		break;

	case PIOMODE_WAIT:
		errstring = "piomode";
		if (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))
			goto timeout;
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
		if (chp->ch_status & (WDCS_ERR | WDCS_DWF))
			goto error;
	/* FALLTHROUGH */

	case DMAMODE:
		if (drvp->drive_flags & DRIVE_UDMA) {
			wdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,
			    0x40 | drvp->UDMA_mode, WDSF_SET_MODE);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			wdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,
			    0x20 | drvp->DMA_mode, WDSF_SET_MODE);
		} else {
			goto geometry;
		}
		drvp->state = DMAMODE_WAIT;
		break;
	case DMAMODE_WAIT:
		errstring = "dmamode";
		if (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))
			goto timeout;
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
		if (chp->ch_status & (WDCS_ERR | WDCS_DWF))
			goto error;
	/* FALLTHROUGH */

	case GEOMETRY:
	geometry:
		if (ata_bio->flags & ATA_LBA)
			goto multimode;
		wdccommand(chp, xfer->drive, WDCC_IDP,
		    ata_bio->lp->d_ncylinders,
		    ata_bio->lp->d_ntracks - 1, 0, ata_bio->lp->d_nsectors, 0);
		drvp->state = GEOMETRY_WAIT;
		break;

	case GEOMETRY_WAIT:
		errstring = "geometry";
		if (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))
			goto timeout;
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
		if (chp->ch_status & (WDCS_ERR | WDCS_DWF))
			goto error;
		/* FALLTHROUGH */

	case MULTIMODE:
	multimode:
		if (ata_bio->multi == 1)
			goto ready;
		wdccommand(chp, xfer->drive, WDCC_SETMULTI, 0, 0, 0,
		    ata_bio->multi, 0);
		drvp->state = MULTIMODE_WAIT;
		break;

	case MULTIMODE_WAIT:
		errstring = "setmulti";
		if (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))
			goto timeout;
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
		if (chp->ch_status & (WDCS_ERR | WDCS_DWF))
			goto error;
		/* FALLTHROUGH */

	case READY:
	ready:
		drvp->state = READY;
		/*
		 * The drive is usable now
		 */
		xfer->c_intr = wdc_ata_bio_intr;
		_wdc_ata_bio_start(chp, xfer);
		return 1;
	}

	if ((ata_bio->flags & ATA_POLL) == 0) {
		chp->ch_flags |= WDCF_IRQ_WAIT;
	} else {
		goto again;
	}
	return 1;

timeout:
	if (irq && (xfer->c_flags & C_TIMEOU) == 0) {
		return 0; /* IRQ was not for us */
	}
	printf("%s:%d:%d: %s timed out\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, errstring);
	ata_bio->error = TIMEOUT;
	drvp->state = 0;
	wdc_ata_bio_done(chp, xfer);
	return 0;
error:
	printf("%s:%d:%d: %s ",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    errstring);
	if (chp->ch_status & WDCS_DWF) {
		printf("drive fault\n");
		ata_bio->error = ERR_DF;
	} else {
		printf("error (%x)\n", chp->ch_error);
		ata_bio->r_error = chp->ch_error;
		ata_bio->error = ERROR;
	}
	drvp->state = 0;
	wdc_ata_bio_done(chp, xfer);
	return 1;
}

int
wdc_ata_err(struct ata_drive_datas *drvp, struct ata_bio *ata_bio)
{
	struct channel_softc *chp = drvp->chnl_softc;
	ata_bio->error = 0;

	if (chp->ch_status == 0xff) {
		ata_bio->error = ERR_NODEV;
		return WDC_ATA_ERR;
	}
	if (chp->ch_status & WDCS_BSY) {
		ata_bio->error = TIMEOUT;
		return WDC_ATA_ERR;
	}

	if (chp->ch_status & WDCS_DWF) {
		ata_bio->error = ERR_DF;
		return WDC_ATA_ERR;
	}

	if (chp->ch_status & WDCS_ERR) {
		ata_bio->error = ERROR;
		ata_bio->r_error = chp->ch_error;
		if (drvp->drive_flags & DRIVE_UDMA &&
		    (ata_bio->r_error & WDCE_CRC)) {
			/*
			 * Record the CRC error, to avoid downgrading to
			 * multiword DMA
			 */
			drvp->drive_flags |= DRIVE_DMAERR;
		}
		if (ata_bio->r_error & (WDCE_BBK | WDCE_UNC | WDCE_IDNF |
		    WDCE_ABRT | WDCE_TK0NF | WDCE_AMNF))
			return WDC_ATA_ERR;
		return WDC_ATA_NOERR;
	}

	if (chp->ch_status & WDCS_CORR)
		ata_bio->flags |= ATA_CORR;
	return WDC_ATA_NOERR;
}

#if 0
int
wdc_ata_addref(drvp)
	struct ata_drive_datas *drvp;
{
	struct channel_softc *chp = drvp->chnl_softc;

	return (wdc_addref(chp));
}

void
wdc_ata_delref(drvp)
	struct ata_drive_datas *drvp;
{
	struct channel_softc *chp = drvp->chnl_softc;

	wdc_delref(chp);
}
#endif
@


1.49
log
@Use config_suspend() instead of dereferencing ca_activate directly to
support drivers that do not need any specific suspend/resume magic and
do not have an activate function.

config_suspend() will automagically propagate the event to the children
of the driver.  Needed at least by kauaiata(4/macppc).

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.48 2015/03/14 03:38:47 jsg Exp $	*/
d402 1
a402 3
			    head, sect, nblks,
			    (ata_bio->lp->d_type == DTYPE_ST506) ?
			    ata_bio->lp->d_precompcyl / 4 : 0);
d702 1
a702 3
		    ata_bio->lp->d_ntracks - 1, 0, ata_bio->lp->d_nsectors,
		    (ata_bio->lp->d_type == DTYPE_ST506) ?
			ata_bio->lp->d_precompcyl / 4 : 0);
@


1.48
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.47 2014/09/14 14:17:24 jsg Exp $	*/
d144 1
a144 5
		struct device *dv = &wdc->sc_dev;
		struct cfdata *cfd = dv->dv_cfdata;

		/* The ca_activate function for the parent controller */
		(cfd->cf_attach->ca_activate)(dv, DVACT_RESUME);
@


1.47
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.46 2013/11/06 12:06:58 deraadt Exp $	*/
a72 1
#include <dev/ata/atareg.h>
@


1.46
log
@teach the side-effect free drivers about the partition they are dealing
by passing a start/length in the HIB_INIT op.  Then rebase all
hibernate-time block offsets to be relative to the start of that partition.
This simplifies things a lot.
ok mlarkin
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.45 2013/01/17 02:36:45 deraadt Exp $	*/
a68 1
#include <sys/proc.h>
@


1.45
log
@Add a hibernate HIB_DONE op.  After the memory-side-effect driver finishes
IO to the disk, DVACT_RESUME the controller back to normal operation.  That
allows us to do the full DVACT_POWERDOWN sequence afterwards.
ok mlarkin
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.44 2011/11/15 17:14:14 deraadt Exp $	*/
d124 2
d134 3
a136 1
	if (op == HIB_INIT)
d138 1
d153 4
@


1.44
log
@on failure, the hibernate io function should return an errno type variable,
instead of 1.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.43 2011/11/14 00:25:17 mlarkin Exp $	*/
d138 10
@


1.43
log
@

Use a fixed io_page for all hibernate I/O, which is needed for
ahci_hibernate_io, a skeleton of which is also provided in this diff.

This code is from deraadt@@. Tested on a few wd machines to ensure it works
there as well.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.42 2011/11/13 23:13:28 mlarkin Exp $	*/
d173 1
a173 1
	return (ata_bio->flags & ATA_ITSDONE) ? 0 : 1;
@


1.42
log
@

Add some #defines for the various hibernate I/O modes, some of the
groundwork for *_hibernate_io functions other than wd_hibernate_io

These changes were sent to me by deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.41 2011/09/22 22:12:45 deraadt Exp $	*/
d130 4
@


1.41
log
@KNF of mlarkin's code, requested by him.  Some improvements to the interface
for talking to the disk driver snuck in.
ok mlarkin
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.40 2011/07/15 16:44:18 deraadt Exp $	*/
d80 4
d116 1
d118 1
a118 1
wd_hibernate_io(dev_t dev, daddr_t blkno, vaddr_t addr, size_t size, int wr, void *page)
d152 1
a152 1
	if (wr == 0)
d171 1
@


1.40
log
@Cope with the start-dma-before-init errata and some other register setup
errata for the Serverworks SATA chipset found on the macppc xserve G5.
ok jmc
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.39 2011/05/24 23:18:47 matthew Exp $	*/
d113 1
a113 1
wd_hibernate_io(dev_t dev, daddr_t blkno, caddr_t addr, size_t size, int wr, void *page)
d150 1
a150 1
	wd->sc_wdc_bio.databuf = addr;
@


1.39
log
@Move wdc_cd from ata/ata_wdc.c to ic/wdc.c so that you can compile a
kernel without the former.  Also, eliminate two dead stores in
wdcattach().

ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.38 2011/04/18 04:16:13 deraadt Exp $	*/
d328 6
d341 6
a346 3
			/* start the DMA channel */
			(*chp->wdc->dma_start)(chp->wdc->dma_arg,
			    chp->channel, xfer->drive);
@


1.38
log
@keep an eye out for wdc registers returning 0xff.  if they return 0xff,
this probably means the controller is dead -- as in, a hot plug eject
event.  in that case, mark the driver dead and try harder to return -1
in the interrupt handler.
tested by many
ok dlg, miod did not object
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.37 2011/04/05 19:57:40 deraadt Exp $	*/
a99 4

struct cfdriver wdc_cd = {
	NULL, "wdc", DV_DULL
};
@


1.37
log
@wd_hibernate_io() is a standalone disk io writer which tries to not
damage kernel memory very much while doing the job.  It is not very
pretty yet, but improving it will need some MI work.
ok mlarkin jsg dlg
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.36 2011/04/03 23:17:13 dlg Exp $	*/
d423 2
d761 5
@


1.36
log
@pirofti made me look at wd(4) code, which made me sad.

increase the timeout on io from 10s to 45s. ata says we should wait
30, but i am cynical. this gives loongson disks enough time to wake
up on resume.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.35 2010/11/06 16:53:15 kettenis Exp $	*/
d67 1
d116 55
d572 2
a573 1
	timeout_del(&chp->ch_timo);
@


1.35
log
@If the dma_init callback function returns with EINVAL, fall back to PIO.
This will be used to work around bugs in certain pciide(4) controllers.

From NetBSD.

ok jsg@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.34 2010/07/23 07:47:12 jsg Exp $	*/
d98 1
a98 1
#define ATA_DELAY 10000 /* 10s for a drive I/O */
@


1.34
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.33 2009/01/21 21:53:59 grange Exp $	*/
d170 1
a170 1
	int dma_flags = 0;
d252 1
a252 1
			if ((*chp->wdc->dma_init)(chp->wdc->dma_arg,
d255 12
a266 1
			    ata_bio->nbytes, dma_flags) != 0) {
d290 1
@


1.33
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.32 2008/06/27 06:03:08 ray Exp $	*/
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Manuel Bouyer.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.32
log
@More removal of clauses 3 and 4 from NetBSD licenses.

OK deraadt@@ and millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.31 2008/02/07 12:58:30 sthen Exp $	*/
d163 1
a163 1
		timeout_add(&chp->ch_timo, ATA_DELAY / 1000 * hz);
@


1.31
log
@enable DMA for 1-sector devices (i.e. most flash devices).
from NetBSD

ok krw thib henning, tested by many
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.30 2007/02/14 00:53:47 jsg Exp $	*/
a49 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.30
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.29 2006/10/04 00:52:55 krw Exp $	*/
d294 2
a295 1
		if (ata_bio->nblks > 1 && (ata_bio->flags & ATA_SINGLE) == 0) {
@


1.29
log
@Zap bad144 bad sector info in disklabels. Sparsely used if at all for
a few obsolete and easily replaced disk models. And didn't work anyway
according to Bob, who has tried.

ok beck@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.28 2006/08/21 12:09:01 krw Exp $	*/
d562 1
a562 1
	/* fall through */
d587 1
a587 1
	/* fall through */
d609 1
a609 1
	/* fall through */
d631 1
a631 1
		/* fall through */
d650 1
a650 1
		/* fall through */
@


1.28
log
@Delete #ifdef/#ifndef __OpenBSD__ chunks, leaving just the code we
use. Easier to read and eliminates a potentially confusing unused call
to wdgetdisklabel(). No change to object files.

ok brad@@ dlg@@ grange@@ deraadt@@ marco@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.27 2004/06/02 18:55:08 grange Exp $	*/
a239 24
		/* Check for bad sectors and adjust transfer, if necessary. */
		if ((ata_bio->lp->d_flags & D_BADSECT) != 0) {
			long blkdiff;
			int i;
			for (i = 0; (blkdiff = ata_bio->badsect[i]) != -1;
			     i++) {
				blkdiff -= ata_bio->blkno;
				if (blkdiff < 0)
					continue;
				if (blkdiff == 0) {
					/* Replace current block of transfer. */
					ata_bio->blkno =
					    ata_bio->lp->d_secperunit -
					    ata_bio->lp->d_nsectors - i - 1;
				}
				if (blkdiff < nblks) {
					/* Bad block inside transfer. */
					ata_bio->flags |= ATA_SINGLE;
					nblks = 1;
				}
				break;
			}
			/* Transfer is okay now. */
		}
@


1.27
log
@Add quirks field to the wdc softc and implement the first one:
WDC_QUIRK_NOSHORTDMA which disables DMA for the one-sector
transfers. Use this quirk for the Geode SC1100 IDE to fix
hanging during fdisk reported in PR 3729.
Thanks to Alexandre Belloni <abelloni@@nerim.net> for testing.

ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.26 2004/01/23 20:48:33 grange Exp $	*/
a112 1
#ifdef __OpenBSD__
a115 1
#endif
@


1.26
log
@Use %b to display status register, this will make bug reports more
informative. Also convert WDCS_BITS string to caps.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.25 2004/01/15 21:37:57 grange Exp $	*/
d147 3
a149 1
	    (ata_bio->flags & ATA_SINGLE) == 0)
@


1.25
log
@ansi and some spaces; no f/c
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.24 2003/10/17 08:14:09 grange Exp $	*/
d358 1
a358 1
			    "st=0x%02x, err=0x%02x\n",
d360 2
a361 1
			    xfer->drive, chp->ch_status, chp->ch_error);
d391 1
a391 1
	printf("%s:%d:%d: not ready, st=0x%02x, err=0x%02x\n",
d393 1
a393 1
	    chp->ch_status, chp->ch_error);
d452 1
a452 1
				printf("%s:%d:%d: intr with DRQ (st=0x%x)\n",
d454 1
a454 1
				    xfer->drive, chp->ch_status);
@


1.24
log
@Merge an old fix from NetBSD:
- do not stop/unload current DMA operation if an IRQ was not detected
  by DMA engine unless the force flag was given, fixes DMA problems
  in shared IRQ setups;
- ack interrupt before entering DMA codepath

Tested by many.
Work by niklas@@ but he doesn't want to commit it for some reason.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.23 2003/10/16 11:30:00 grange Exp $	*/
d119 2
a120 2
void  wdc_ata_bio_start(struct channel_softc *,struct wdc_xfer *);
void  _wdc_ata_bio_start(struct channel_softc *,struct wdc_xfer *);
d122 1
a122 1
void  wdc_ata_bio_kill_xfer(struct channel_softc *,struct wdc_xfer *);
d135 1
a135 3
wdc_ata_bio(drvp, ata_bio)
	struct ata_drive_datas *drvp;
	struct ata_bio *ata_bio;
d161 1
a161 3
wdc_ata_bio_start(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
d175 1
a175 3
_wdc_ata_bio_start(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
d400 1
a400 4
wdc_ata_bio_intr(chp, xfer, irq)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int irq;
d512 1
a512 3
wdc_ata_bio_kill_xfer(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
d530 1
a530 3
wdc_ata_bio_done(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
d561 1
a561 4
wdc_ata_ctrl_intr(chp, xfer, irq)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int irq;
d721 1
a721 3
wdc_ata_err(drvp, ata_bio)
	struct ata_drive_datas *drvp;
	struct ata_bio *ata_bio;
@


1.23
log
@Allow setting of wdcdebug*_mask variables via preprocessor defines.
This makes creating debug kernels be much more easy.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.22 2003/09/28 21:01:42 grange Exp $	*/
d318 1
d386 4
d446 2
a451 4
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
			chp->channel, xfer->drive);

a471 3
	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);

d512 1
a512 4
	if (xfer->c_flags & C_DMA) {
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
			chp->channel, xfer->drive);
a513 1
	}
@


1.22
log
@kill trailing spaces, no functional changes
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.21 2003/07/23 22:07:15 grange Exp $	*/
d99 4
a102 1
int wdcdebug_wd_mask = 0;
@


1.21
log
@Old Promise ATA controllers need some additional operations
during DMA transfers to work correctly with LBA48 drives.
Based on diff from Takeshi Nakayama <tn@@catvmics.ne.jp> for NetBSD
with some corrections from FreeBSD ATA driver.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.20 2003/02/21 20:10:33 grange Exp $	*/
d25 1
a25 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
d120 1
a120 1
void  wdc_ata_bio_done(struct channel_softc *, struct wdc_xfer *); 
d241 1
a241 1
		else 
d294 1
a294 1
			    (char *)xfer->databuf + xfer->c_skip, 
d344 1
a344 1
			    head, sect, nblks, 
d443 1
a443 1
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, 
d511 2
a512 2
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, 
			chp->channel, xfer->drive);	
d549 1
a549 1
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, 
d638 1
a638 1
		}	
d699 1
a699 1
		_wdc_ata_bio_start(chp, xfer); 
@


1.20
log
@Fix Manuel Bouyer's copyright, from NetBSD
ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.19 2003/02/13 20:54:59 grange Exp $	*/
d225 2
@


1.19
log
@Don't force all ATAPI devices to PIO mode 3, there are
devices which only support PIO mode 2 or less. Use
atap_oldpiotiming to obtain supported mode for such devices.
Also use SET FEATURES only for PIO mode > 2.

Work by Alec Skelly <alec@@dtkco.com> with my little help.

ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.18 2003/01/10 13:50:56 grange Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Manuel Bouyer.
d17 1
a17 2
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
d22 10
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.18
log
@splio->splbio in comment
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.17 2002/12/19 16:32:59 grange Exp $	*/
d610 3
@


1.17
log
@Protect WDCDEBUG_PRINT macro with do {} while (0)
ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.16 2002/10/12 01:09:44 krw Exp $	*/
d131 1
a131 1
 * WDC_TRY_AGAIN. Must be called at splio().
@


1.16
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.15 2002/05/03 09:18:46 gluk Exp $	*/
d102 4
a105 3
#define WDCDEBUG_PRINT(args, level) \
	if (wdcdebug_wd_mask & (level)) \
		printf args
@


1.15
log
@LBA48 support.
Adopted from NetBSD by Alexander Yurchenko <grange@@openbsd.ru>.

costa@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.14 2002/03/16 23:23:42 csapuntz Exp $	*/
d416 1
a416 1
		panic("wdc_ata_bio_intr: bad state\n");
@


1.14
log
@Use wdc_setdrive
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.13 2002/03/14 01:26:52 millert Exp $	*/
d284 6
a289 2
			cmd = (ata_bio->flags & ATA_READ) ?
			    WDCC_READDMA : WDCC_WRITEDMA;
d304 7
a310 2
			wdccommand(chp, xfer->drive, cmd, cyl,
			    head, sect, nblks, 0);
d320 6
a325 2
			cmd = (ata_bio->flags & ATA_READ) ?
			    WDCC_READMULTI : WDCC_WRITEMULTI;
d327 6
a332 2
			cmd = (ata_bio->flags & ATA_READ) ?
			    WDCC_READ : WDCC_WRITE;
d338 9
a346 4
		wdccommand(chp, xfer->drive, cmd, cyl,
		    head, sect, nblks, 
		    (ata_bio->lp->d_type == DTYPE_ST506) ?
		    ata_bio->lp->d_precompcyl / 4 : 0);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.12 2001/11/28 19:49:36 csapuntz Exp $	*/
d207 1
a207 1
		CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));
d297 1
a297 2
			CHP_WRITE_REG(chp, wdr_sdh, 
			    WDSD_IBM | (xfer->drive << 4));
d318 1
a318 1
		CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));
@


1.12
log
@Add tag line. Thanks to David Krause
@
text
@d1 1
a1 1
/*      $OpenBSD$	*/
d117 7
a123 7
void  wdc_ata_bio_start  __P((struct channel_softc *,struct wdc_xfer *));
void  _wdc_ata_bio_start  __P((struct channel_softc *,struct wdc_xfer *));
int   wdc_ata_bio_intr   __P((struct channel_softc *, struct wdc_xfer *, int));
void  wdc_ata_bio_kill_xfer __P((struct channel_softc *,struct wdc_xfer *));
void  wdc_ata_bio_done   __P((struct channel_softc *, struct wdc_xfer *)); 
int   wdc_ata_ctrl_intr __P((struct channel_softc *, struct wdc_xfer *, int));
int   wdc_ata_err __P((struct ata_drive_datas *, struct ata_bio *));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.12 2001/11/28 19:49:36 csapuntz Exp $	*/
d117 7
a123 7
void  wdc_ata_bio_start(struct channel_softc *,struct wdc_xfer *);
void  _wdc_ata_bio_start(struct channel_softc *,struct wdc_xfer *);
int   wdc_ata_bio_intr(struct channel_softc *, struct wdc_xfer *, int);
void  wdc_ata_bio_kill_xfer(struct channel_softc *,struct wdc_xfer *);
void  wdc_ata_bio_done(struct channel_softc *, struct wdc_xfer *); 
int   wdc_ata_ctrl_intr(struct channel_softc *, struct wdc_xfer *, int);
int   wdc_ata_err(struct ata_drive_datas *, struct ata_bio *);
d207 1
a207 1
		wdc_set_drive(chp, xfer->drive);
d284 2
a285 6
			if (ata_bio->flags & ATA_LBA48)
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READDMA_EXT : WDCC_WRITEDMA_EXT;
			else
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READDMA : WDCC_WRITEDMA;
d297 2
a298 1
			wdc_set_drive(chp, xfer->drive);
d301 2
a302 7
			if (ata_bio->flags & ATA_LBA48) {
				wdccommandext(chp, xfer->drive, cmd,
				    (u_int64_t)ata_bio->blkno, nblks);
			} else {
				wdccommand(chp, xfer->drive, cmd, cyl,
				    head, sect, nblks, 0);
			}
d312 2
a313 6
			if (ata_bio->flags & ATA_LBA48)
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READMULTI_EXT : WDCC_WRITEMULTI_EXT;
			else
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READMULTI : WDCC_WRITEMULTI;
d315 2
a316 6
			if (ata_bio->flags & ATA_LBA48)
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READ_EXT : WDCC_WRITE_EXT;
			else
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READ : WDCC_WRITE;
d319 1
a319 1
		wdc_set_drive(chp, xfer->drive);
d322 4
a325 9
		if (ata_bio->flags & ATA_LBA48) {
			wdccommandext(chp, xfer->drive, cmd,
			    (u_int64_t)ata_bio->blkno, nblks);
		} else {
			wdccommand(chp, xfer->drive, cmd, cyl,
			    head, sect, nblks, 
			    (ata_bio->lp->d_type == DTYPE_ST506) ?
			    ata_bio->lp->d_precompcyl / 4 : 0);
		}
@


1.12.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: ata_wdc.c,v 1.12.2.1 2002/06/11 03:42:16 art Exp $	*/
d416 1
a416 1
		panic("wdc_ata_bio_intr: bad state");
@


1.12.2.3
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$	*/
d5 1
a5 1
 * Copyright (c) 1998, 2001 Manuel Bouyer.
d17 2
a18 1
 *	This product includes software developed by Manuel Bouyer.
d23 11
a33 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d102 3
a104 4
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_wd_mask & (level)) != 0)	\
		printf args;			\
} while (0)
d130 1
a130 1
 * WDC_TRY_AGAIN. Must be called at splbio().
a608 3
			goto geometry;
		/* SET FEATURES 0x08 is only for PIO mode > 2 */
		if (drvp->PIO_mode <= 2)
@


1.11
log
@

On DMA timeouts, stop busmaster PCIIDE and reset channel. Avoid reading
device registers as this may cause lock-ups on some chipsets

Clean-up in atapiscsi. Get rid of claim_irq. Instead, atapiscsi always
returns -1 (maybe) from the interrupt handler.
@
text
@d1 1
@


1.10
log
@Undo last fix to ata_wdc.c. Don't deregister timeout in generic code
@
text
@d144 2
a145 1
	if ((drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) &&
d398 2
a399 2
	 * if we missed an interrupt in a PIO transfer, reset and restart.
	 * Don't try to continue transfer, we may have missed cycles.
d401 2
a402 5
	if ((xfer->c_flags & (C_TIMEOU | C_DMA)) == C_TIMEOU) {
		ata_bio->error = TIMEOUT;
		wdc_ata_bio_done(chp, xfer);
		return 1;
	}
d407 1
a407 1
		if (irq && (xfer->c_flags & C_TIMEOU) == 0)
d413 1
a413 12
		/* if we were using DMA, stop channel and deal with error */
		if (xfer->c_flags & C_DMA) {
			chp->wdc->dma_status =
			    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, 
				chp->channel,
				xfer->drive);
			ata_dmaerr(drvp);
		}

		ata_bio->error = TIMEOUT;
		wdc_ata_bio_done(chp, xfer);
		return 1;
a417 1
	/* If we were using DMA, Turn off the DMA channel and check for error */
d419 3
a421 16
		if (ata_bio->flags & ATA_POLL) {
			/*
			 * IDE drives deassert WDCS_BSY before transfer is
			 * complete when using DMA. Polling for DRQ to deassert
			 * is not enouth DRQ is not required to be
			 * asserted for DMA transfers, so poll for DRDY.
			 */
			if (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY,
			    ATA_DELAY) < 0) {
				printf("%s:%d:%d: polled transfer timed out "
				    "(st=0x%x)\n", chp->wdc->sc_dev.dv_xname,
				    chp->channel, xfer->drive, chp->ch_status);
				ata_bio->error = TIMEOUT;
				drv_err = WDC_ATA_ERR;
			}
		}
a422 3
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, chp->channel,
			xfer->drive);
d483 12
@


1.9
log
@Don't hang on missing interrupts
@
text
@d117 1
d164 16
d187 1
a187 1
	WDCDEBUG_PRINT(("wdc_ata_bio_start %s:%d:%d\n",
d199 1
a199 1
			printf("%s:%d:%d: bad state %d in wdc_ata_bio_start\n",
d202 1
a202 1
			panic("wdc_ata_bio_start: bad state");
a211 1
			timeout_add(&chp->ch_timo, ATA_DELAY / 1000 * hz);
a354 1
		timeout_add(&chp->ch_timo, ATA_DELAY / 1000 * hz);
a361 1

d504 1
a504 1
			wdc_ata_bio_start(chp, xfer);
d506 1
a506 1
			/* Let wdc_ata_bio_start do the loop */
d691 1
a691 1
		wdc_ata_bio_start(chp, xfer); 
a696 1
		timeout_add(&chp->ch_timo, ATA_DELAY / 1000 * hz);
@


1.8
log
@
Missing irqack, cleanup DMA error handling
@
text
@a116 1
void  _wdc_ata_bio_start  __P((struct channel_softc *,struct wdc_xfer *));
a162 16
	WDCDEBUG_PRINT(("wdc_ata_bio_start %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),
	    DEBUG_XFERS);

	/* start timeout machinery */
	if ((ata_bio->flags & ATA_POLL) == 0)
		timeout_add(&chp->ch_timo, ATA_DELAY / 1000 * hz);
	_wdc_ata_bio_start(chp, xfer);
}

void
_wdc_ata_bio_start(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
{
	struct ata_bio *ata_bio = xfer->cmd;
d170 1
a170 1
	WDCDEBUG_PRINT(("_wdc_ata_bio_start %s:%d:%d\n",
d182 1
a182 1
			printf("%s:%d:%d: bad state %d in _wdc_ata_bio_start\n",
d185 1
a185 1
			panic("_wdc_ata_bio_start: bad state");
d195 1
d339 1
d347 1
d490 1
a490 1
			_wdc_ata_bio_start(chp, xfer);
d492 1
a492 1
			/* Let _wdc_ata_bio_start do the loop */
d677 1
a677 1
		_wdc_ata_bio_start(chp, xfer); 
d683 1
@


1.7
log
@Minor mods to DMA interface - get rid of unnecessary args. Allow DMA functions to return status flags.

Note: Changing code to have DMA interface indicate when I/O is done (a la NetBSD) was considered. It was rejected due to questionable backward compatability
with ISA DMA and MAC obio DMA

Added irqack from NetBSD (though this feature should really be in the
PCI interrupt handlers)

Use pool
@
text
@a283 1
			nblks = ata_bio->nblks;
a515 1

a541 2
	int drive = xfer->drive;
	struct ata_drive_datas *drvp = &chp->ch_drive[drive];
a548 5
	if (ata_bio->error == NOERROR)
		drvp->n_dmaerrs = 0;
	else if (drvp->n_dmaerrs >= NERRS_MAX) {
		wdc_downgrade_mode(drvp);
	}
d593 2
@


1.6
log
@Convert some parts to new timeouts.
@
text
@d221 2
a223 1
		dma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;
d229 1
a229 1
 again:
d304 1
a304 1
			    chp->channel, xfer->drive, dma_flags);
d353 1
a353 1
 intr:	/* Wait for IRQ (either real or polled) */
d364 1
a364 1
 timeout:
a382 1
	int dma_flags = 0;
a396 5
	if (xfer->c_flags & C_DMA) {
		dma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;
		dma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;
	}

d415 2
a416 1
		/* if we were using DMA, turn off DMA channel */
d418 5
a422 3
			(*chp->wdc->dma_finish)(chp->wdc->dma_arg,
			    chp->channel, xfer->drive, dma_flags);
			drvp->n_dmaerrs++;
d424 1
d429 1
a429 1
	
d450 5
a454 2
		if ((*chp->wdc->dma_finish)(chp->wdc->dma_arg,
		    chp->channel, xfer->drive, dma_flags) != 0) {
d471 1
a471 1
		drvp->n_dmaerrs++;
d474 3
d622 2
d644 2
d666 2
d685 2
@


1.5
log
@

Added support for wd detach (merge from NetBSD). Support for
SCSI/ATAPI detach is not here yet.

Minor cleanup of wdc. Downgrade to UDMA mode 1 before going further.
Want to stay in UDMA modes because they're more error-resilient due to
a CRC.

Got rid of some of the ridiculous amount of softc sharing going on.
Hopefully, this will make the life of whoever goes in and fixes the
ref-counting to be correct easier.
@
text
@d170 1
a170 1
		timeout(wdctimeout, chp, ATA_DELAY / 1000 * hz);
d520 1
a520 1
	untimeout(wdctimeout, chp);
d547 1
a547 1
	untimeout(wdctimeout, chp);
@


1.4
log
@

New interface to ATA registers that goes through the lower-level device
driver (pciide, wdc, etc.)

Remove #define WDCDEBUG from top of files

More fixes to ATAPISCSI logic:

Not all devices transition correctly between phases. Devices are supposed
to keep BSY high until they've set the registers to the next sensible
state. Some devices drop BSY and leave the registers in an old or
nonsense state. Our polling code is extremely sensitive to this
(though an early itnerrupt could also observe this). So, if the device is
in an unexpected state, the new polling code waits for a while in the hope
that it enters a better state.

This seems to fix many of the problems reported.

Also, there was a horrible bug which would cause sense to fail on a ATAPI
command that sent data to the drive
@
text
@d98 1
d119 1
d153 1
d228 1
a228 1
again:
d244 1
a244 1
			    i++) {
d261 1
a261 1
		/* Transfer is okay now. */
d328 2
a329 2
		ata_bio->nblks = nblks;
		ata_bio->nbytes = xfer->c_bcount;
d352 1
a352 1
intr:	/* Wait for IRQ (either real or polled) */
d363 1
a363 1
timeout:
d512 21
d563 1
a563 1
		wddone(chp->ch_drive[drive].drv_softc);
@


1.4.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@a97 1

a117 1
void  wdc_ata_bio_kill_xfer __P((struct channel_softc *,struct wdc_xfer *));
a150 1
	xfer->c_kill_xfer = wdc_ata_bio_kill_xfer;
d167 1
a167 1
		timeout_add(&chp->ch_timo, ATA_DELAY / 1000 * hz);
a217 2
		if (drvp->n_xfers <= NXFER)
			drvp->n_xfers++;
d219 1
d241 1
a241 1
			     i++) {
d258 1
a258 1
			/* Transfer is okay now. */
d280 1
d300 1
a300 1
			    chp->channel, xfer->drive);
d325 2
a326 2
			ata_bio->nblks = nblks;
			ata_bio->nbytes = xfer->c_bcount;
d379 1
d394 5
d417 1
a417 2

		/* if we were using DMA, stop channel and deal with error */
d419 3
a421 5
			chp->wdc->dma_status =
			    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, 
				chp->channel,
				xfer->drive);
			ata_dmaerr(drvp);
a422 1

d427 1
a427 1

d448 2
a449 5

		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, chp->channel,
			xfer->drive);
		if (chp->wdc->dma_status != 0) {
d466 1
a466 1
		ata_dmaerr(drvp);
a468 3
	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);

a509 20
wdc_ata_bio_kill_xfer(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
{
	struct ata_bio *ata_bio = xfer->cmd;

	timeout_del(&chp->ch_timo);
	/* remove this command from xfer queue */
	wdc_free_xfer(chp, xfer);

	ata_bio->flags |= ATA_ITSDONE;
	ata_bio->error = ERR_NODEV;
	ata_bio->r_error = WDCE_ABRT;
	if ((ata_bio->flags & ATA_POLL) == 0) {
		WDCDEBUG_PRINT(("wdc_ata_done: wddone\n"), DEBUG_XFERS);
		wddone(ata_bio->wd);
	}
}

void
d515 2
d523 6
a528 1
	timeout_del(&chp->ch_timo);
d539 1
a539 1
		wddone(ata_bio->wd);
a572 2
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
a592 2
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
a612 2
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
a632 2
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
a649 2
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
@


1.4.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d144 1
a144 2
	if (!(ata_bio->flags & ATA_POLL) &&
	    (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) &&
d397 2
a398 2
	 * reset on timeout. This will cause extra resets in the case
	 * of occasional lost interrupts
d400 5
a404 2
	if (xfer->c_flags & C_TIMEOU)
		goto timeout;
d409 1
a409 1
		if (irq)
d415 12
a426 1
		goto timeout;
d431 1
d433 17
d451 2
a452 3
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, 
			chp->channel, xfer->drive);

a512 12
	return 1;

timeout:
	if (xfer->c_flags & C_DMA) {
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, 
			chp->channel, xfer->drive);	
		ata_dmaerr(drvp);
	}

	ata_bio->error = TIMEOUT;
	wdc_ata_bio_done(chp, xfer);
@


1.4.2.3
log
@Merge in -current
@
text
@a0 1
/*      $OpenBSD$	*/
@


1.4.2.4
log
@Merge in -current from about a week ago
@
text
@d117 7
a123 7
void  wdc_ata_bio_start(struct channel_softc *,struct wdc_xfer *);
void  _wdc_ata_bio_start(struct channel_softc *,struct wdc_xfer *);
int   wdc_ata_bio_intr(struct channel_softc *, struct wdc_xfer *, int);
void  wdc_ata_bio_kill_xfer(struct channel_softc *,struct wdc_xfer *);
void  wdc_ata_bio_done(struct channel_softc *, struct wdc_xfer *); 
int   wdc_ata_ctrl_intr(struct channel_softc *, struct wdc_xfer *, int);
int   wdc_ata_err(struct ata_drive_datas *, struct ata_bio *);
d207 1
a207 1
		wdc_set_drive(chp, xfer->drive);
d297 2
a298 1
			wdc_set_drive(chp, xfer->drive);
d319 1
a319 1
		wdc_set_drive(chp, xfer->drive);
@


1.4.2.5
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a5 1
 * Copyright (c) 1998, 2001 Manuel Bouyer.
d17 2
a18 1
 *	This product includes software developed by Manuel Bouyer.
d23 11
a33 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d102 3
a104 4
#define WDCDEBUG_PRINT(args, level) do {	\
	if ((wdcdebug_wd_mask & (level)) != 0)	\
		printf args;			\
} while (0)
d130 1
a130 1
 * WDC_TRY_AGAIN. Must be called at splbio().
d284 2
a285 6
			if (ata_bio->flags & ATA_LBA48)
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READDMA_EXT : WDCC_WRITEDMA_EXT;
			else
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READDMA : WDCC_WRITEDMA;
d300 2
a301 7
			if (ata_bio->flags & ATA_LBA48) {
				wdccommandext(chp, xfer->drive, cmd,
				    (u_int64_t)ata_bio->blkno, nblks);
			} else {
				wdccommand(chp, xfer->drive, cmd, cyl,
				    head, sect, nblks, 0);
			}
d311 2
a312 6
			if (ata_bio->flags & ATA_LBA48)
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READMULTI_EXT : WDCC_WRITEMULTI_EXT;
			else
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READMULTI : WDCC_WRITEMULTI;
d314 2
a315 6
			if (ata_bio->flags & ATA_LBA48)
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READ_EXT : WDCC_WRITE_EXT;
			else
				cmd = (ata_bio->flags & ATA_READ) ?
				    WDCC_READ : WDCC_WRITE;
d321 4
a324 9
		if (ata_bio->flags & ATA_LBA48) {
			wdccommandext(chp, xfer->drive, cmd,
			    (u_int64_t)ata_bio->blkno, nblks);
		} else {
			wdccommand(chp, xfer->drive, cmd, cyl,
			    head, sect, nblks, 
			    (ata_bio->lp->d_type == DTYPE_ST506) ?
			    ata_bio->lp->d_precompcyl / 4 : 0);
		}
d394 1
a394 1
		panic("wdc_ata_bio_intr: bad state");
a586 3
			goto geometry;
		/* SET FEATURES 0x08 is only for PIO mode > 2 */
		if (drvp->PIO_mode <= 2)
@


1.4.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d25 1
a25 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
d99 1
a99 4
#ifndef WDCDEBUG_WD_MASK
#define WDCDEBUG_WD_MASK 0x00
#endif
int wdcdebug_wd_mask = WDCDEBUG_WD_MASK;
d116 2
a117 2
void  wdc_ata_bio_start(struct channel_softc *, struct wdc_xfer *);
void  _wdc_ata_bio_start(struct channel_softc *, struct wdc_xfer *);
d119 2
a120 2
void  wdc_ata_bio_kill_xfer(struct channel_softc *, struct wdc_xfer *);
void  wdc_ata_bio_done(struct channel_softc *, struct wdc_xfer *);
d132 3
a134 1
wdc_ata_bio(struct ata_drive_datas *drvp, struct ata_bio *ata_bio)
d160 3
a162 1
wdc_ata_bio_start(struct channel_softc *chp, struct wdc_xfer *xfer)
d176 3
a178 1
_wdc_ata_bio_start(struct channel_softc *chp, struct wdc_xfer *xfer)
a224 2
		if (ata_bio->flags & ATA_LBA48)
			dma_flags |= WDC_DMA_LBA48;
d239 1
a239 1
		else
d292 1
a292 1
			    (char *)xfer->databuf + xfer->c_skip,
a312 1
			chp->ch_flags |= WDCF_DMA_WAIT;
d342 1
a342 1
			    head, sect, nblks,
d358 1
a358 1
			    "st=0x%b, err=0x%02x\n",
d360 1
a360 2
			    xfer->drive, chp->ch_status, WDCS_BITS,
			    chp->ch_error);
a379 4
		if (chp->ch_flags & WDCF_DMA_WAIT) {
			wdc_dmawait(chp, xfer, ATA_DELAY);
			chp->ch_flags &= ~WDCF_DMA_WAIT;
		}
d386 1
a386 1
	printf("%s:%d:%d: not ready, st=0x%b, err=0x%02x\n",
d388 1
a388 1
	    chp->ch_status, WDCS_BITS, chp->ch_error);
d396 4
a399 1
wdc_ata_bio_intr(struct channel_softc *chp, struct wdc_xfer *xfer, int irq)
a435 2
	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);
d440 4
d452 1
a452 1
				printf("%s:%d:%d: intr with DRQ (st=0x%b)\n",
d454 1
a454 1
				    xfer->drive, chp->ch_status, WDCS_BITS);
d464 3
d507 4
a510 1
	if (xfer->c_flags & C_DMA)
d512 1
d520 3
a522 1
wdc_ata_bio_kill_xfer(struct channel_softc *chp, struct wdc_xfer *xfer)
d540 3
a542 1
wdc_ata_bio_done(struct channel_softc *chp, struct wdc_xfer *xfer)
d547 1
a547 1
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
d573 4
a576 1
wdc_ata_ctrl_intr(struct channel_softc *chp, struct wdc_xfer *xfer, int irq)
d636 1
a636 1
		}
d697 1
a697 1
		_wdc_ata_bio_start(chp, xfer);
d736 3
a738 1
wdc_ata_err(struct ata_drive_datas *drvp, struct ata_bio *ata_bio)
@


1.4.2.7
log
@Merge with the trunk
@
text
@d147 1
a147 3
	    (ata_bio->flags & ATA_SINGLE) == 0 &&
	    (ata_bio->bcount > 512 ||
	    (chp->wdc->quirks & WDC_QUIRK_NOSHORTDMA) == 0))
@


1.3
log
@

use wdc_input_bytes and wdc_output_bytes
@
text
@a71 4
#ifndef WDCDEBUG
#define WDCDEBUG
#endif /* WDCDEBUG */

d202 1
a202 2
		bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
		    WDSD_IBM | (xfer->drive << 4));
d292 1
a292 1
			bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
d314 1
a314 2
		bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
		    WDSD_IBM | (xfer->drive << 4));
@


1.2
log
@bugfixes from netbsd ata_wdc.c, ok csapuntz@@

from bouyer:
- Add some debug printf (WDCPROBE) in _wdcreset_wait(), I've needed these
  2 times in the past
- Set up timeout per xfer instead of per interrupt. This helps with
  PIO transfer (we would call timeout()/untimout() several times for a
  transfer).
- If we missed an interrupt for a PIO transfer, reset and restart it
  immedialy, don't try to recover and continue. If we missed an interrupt we
  may have lost a read/write cycle on the IDE bus. If this happens 1) we
  corrupt data and 2) we enter an interrupt loop at the end of the xfer, as
  the drive has some more data to read/write, but the host thinks the xfer is
  done.
This last change fix the (or at last some of the) 'lookup after lost interrupt'
some peoples have been experiencing.
@
text
@a89 6
#ifndef __BUS_SPACE_HAS_STREAM_METHODS
#define    bus_space_write_multi_stream_2    bus_space_write_multi_2
#define    bus_space_write_multi_stream_4    bus_space_write_multi_4
#define    bus_space_read_multi_stream_2    bus_space_read_multi_2
#define    bus_space_read_multi_stream_4    bus_space_read_multi_4
#endif /* __BUS_SPACE_HAS_STREAM_METHODS */
d351 2
a352 29
		if ((chp->wdc->cap & WDC_CAPABILITY_ATA_NOSTREAM)) {
			if (drvp->drive_flags & DRIVE_CAP32) {
				bus_space_write_multi_4(chp->data32iot,
				    chp->data32ioh, 0,
				    (u_int32_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    ata_bio->nbytes >> 2);
			} else {
				bus_space_write_multi_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    ata_bio->nbytes >> 1);
			}
		} else {
			if (drvp->drive_flags & DRIVE_CAP32) {
				bus_space_write_multi_stream_4(chp->data32iot,
				    chp->data32ioh, 0,
				    (u_int32_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    ata_bio->nbytes >> 2);
			} else {
				bus_space_write_multi_stream_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    ata_bio->nbytes >> 1);
			}
		}
d491 2
a492 29
		if ((chp->wdc->cap & WDC_CAPABILITY_ATA_NOSTREAM)) {
			if (drvp->drive_flags & DRIVE_CAP32) {
				bus_space_read_multi_4(chp->data32iot,
				    chp->data32ioh, 0,
				    (u_int32_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    ata_bio->nbytes >> 2);
			} else {
				bus_space_read_multi_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    ata_bio->nbytes >> 1);
			}
		} else {
			if (drvp->drive_flags & DRIVE_CAP32) {
				bus_space_read_multi_stream_4(chp->data32iot,
				    chp->data32ioh, 0,
				    (u_int32_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    ata_bio->nbytes >> 2);
			} else {
				bus_space_read_multi_stream_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    ata_bio->nbytes >> 1);
			}
		}
a493 1

@


1.1
log
@

Import of NetBSD ATA/IDE stuff.

Introduction of home-grown

To enable this stuff in your configuration, look at the NEWATA conf file
and go through

dev/isa/files.isa
dev/pci/files.pci
conf/files
arch/i386/conf/files.i386

and follow the instructions on commenting/uncommenting stuff
@
text
@d1 1
a1 2
/*      $OpenBSD: $     */
/*	$NetBSD: ata_wdc.c,v 1.19 1999/04/01 21:46:28 bouyer Exp $	*/
d126 1
d171 16
d194 1
a194 1
	WDCDEBUG_PRINT(("wdc_ata_bio_start %s:%d:%d\n",
d196 1
a196 2
	    DEBUG_XFERS);

d206 1
a206 1
			printf("%s:%d:%d: bad state %d in wdc_ata_bio_start\n",
d209 1
a209 1
			panic("wdc_ata_bio_start: bad state");
a219 2
			timeout(wdctimeout, chp,
			    ATA_DELAY / 1000 * hz);
a390 1
		timeout(wdctimeout, chp, ata_delay / 1000 * hz);
d438 10
d564 1
a564 1
			wdc_ata_bio_start(chp, xfer);
d566 1
a566 1
			/* Let wdc_ata_bio_start do the loop */
a581 1
	int need_done = xfer->c_flags & C_NEEDDONE;
d590 1
d604 1
a604 1
	if (need_done) {
d728 1
a728 1
		wdc_ata_bio_start(chp, xfer); 
a733 1
		timeout(wdctimeout, chp, ATA_DELAY / 1000 * hz);
@

