head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.16
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.16
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.14
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.12
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.2.0.2
	UBC_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.09.22.00.47.19;	author jsg;	state Exp;
branches;
next	1.10;
commitid	wK1RhDwCi9nyuU19;

1.10
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.9;
commitid	uzzBR7hz9ncd4O6G;

1.9
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.30.15.22.26;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.10.18.38.24;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.05.02.23.03;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.02.22.05.44;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.05.10.27.06;	author mickey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.10.04.19.18.00;	author gluk;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.01.31.22.55.29;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Fix indentation of a break statement.  No binary change.
@
text
@/* $OpenBSD: radio.c,v 1.10 2014/09/14 14:17:24 jsg Exp $ */
/* $RuOBSD: radio.c,v 1.7 2001/12/04 06:03:05 tm Exp $ */

/*
 * Copyright (c) 2001 Maxim Tsyplakov <tm@@oganer.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* This is /dev/radio driver for OpenBSD */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/device.h>
#include <sys/vnode.h>
#include <sys/radioio.h>
#include <sys/conf.h>

#include <dev/audio_if.h>
#include <dev/radio_if.h>
#include <dev/radiovar.h>

int	radioprobe(struct device *, void *, void *);
void	radioattach(struct device *, struct device *, void *);
int	radiodetach(struct device *, int);
int	radioactivate(struct device *, int);
int	radioprint(void *, const char *);

struct cfattach radio_ca = {
	sizeof(struct radio_softc), radioprobe, radioattach,
	radiodetach, radioactivate
};

struct cfdriver radio_cd = {
	NULL, "radio", DV_DULL
};

int
radioprobe(struct device *parent, void *match, void *aux)
{
	struct audio_attach_args *sa = aux;
	return (sa->type == AUDIODEV_TYPE_RADIO) ? 1 : 0;
}

void
radioattach(struct device *parent, struct device *self, void *aux)
{
	struct radio_softc *sc = (void *) self;
	struct audio_attach_args *sa = aux;

	printf("\n");
	sc->hw_if = sa->hwif;
	sc->hw_hdl = sa->hdl;
	sc->sc_dev = parent;
}

int
radioopen(dev_t dev, int flags, int fmt, struct proc *p)
{
	int	unit;
	struct radio_softc *sc;

	unit = RADIOUNIT(dev);
	if (unit >= radio_cd.cd_ndevs ||
	    (sc = radio_cd.cd_devs[unit]) == NULL ||
	     sc->hw_if == NULL)
		return (ENXIO);

	if (sc->hw_if->open != NULL)
		return (sc->hw_if->open(sc->hw_hdl, flags, fmt, p));
	else
		return (0);
}

int
radioclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	struct radio_softc *sc;

	sc = radio_cd.cd_devs[RADIOUNIT(dev)];

	if (sc->hw_if->close != NULL)
		return (sc->hw_if->close(sc->hw_hdl, flags, fmt, p));
	else
		return (0);
}

int
radioioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct radio_softc *sc;
	int unit, error;

	unit = RADIOUNIT(dev);
	if (unit >= radio_cd.cd_ndevs ||
	    (sc = radio_cd.cd_devs[unit]) == NULL || sc->hw_if == NULL)
		return (ENXIO);

	error = EOPNOTSUPP;
	switch (cmd) {
	case RIOCGINFO:
		if (sc->hw_if->get_info)
			error = (sc->hw_if->get_info)(sc->hw_hdl,
					(struct radio_info *)data);
		break;
	case RIOCSINFO:
		if (!(flags & FWRITE))
			return (EACCES);
		if (sc->hw_if->set_info)
			error = (sc->hw_if->set_info)(sc->hw_hdl,
				(struct radio_info *)data);
		break;
	case RIOCSSRCH:
		if (!(flags & FWRITE))
			return (EACCES);
		if (sc->hw_if->search)
			error = (sc->hw_if->search)(sc->hw_hdl,
					*(int *)data);
		break;
	default:
		error = (ENOTTY);
	}

	return (error);
}

/*
 * Called from hardware driver. This is where the MI radio driver gets
 * probed/attached to the hardware driver
 */

struct device *
radio_attach_mi(struct radio_hw_if *rhwp, void *hdlp, struct device *dev)
{
	struct audio_attach_args arg;

	arg.type = AUDIODEV_TYPE_RADIO;
	arg.hwif = rhwp;
	arg.hdl = hdlp;
	return (config_found(dev, &arg, radioprint));
}

int
radioprint(void *aux, const char *pnp)
{
	if (pnp != NULL)
		printf("radio at %s", pnp);
	return (UNCONF);
}

int
radiodetach(struct device *self, int flags)
{
	/*struct radio_softc *sc = (struct radio_softc *)self;*/
	int maj, mn;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == radioopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	return (0);
}

int
radioactivate(struct device *self, int act)
{
	struct radio_softc *sc = (struct radio_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
}
@


1.10
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: radio.c,v 1.9 2011/07/03 15:47:16 matthew Exp $ */
d127 1
a127 1
			break;
@


1.9
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/* $OpenBSD: radio.c,v 1.8 2009/10/13 19:33:16 pirofti Exp $ */
a32 1
#include <sys/proc.h>
@


1.8
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: radio.c,v 1.7 2006/06/23 06:27:11 miod Exp $ */
a197 3
	case DVACT_ACTIVATE:
		break;

@


1.7
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: radio.c,v 1.6 2002/05/30 15:22:26 mickey Exp $ */
d49 1
a49 1
int	radioactivate(struct device *, enum devact);
d193 1
a193 1
radioactivate(struct device *self, enum devact act)
@


1.6
log
@make radio attach, not steal other audio attachments
@
text
@d1 1
a1 1
/* $OpenBSD: radio.c,v 1.5 2002/01/10 18:38:24 mickey Exp $ */
a198 1
		return (EOPNOTSUPP);
@


1.5
log
@check if device was opened for writing for modifying ops, also it's enotty not einval; from Vladimir Popov <jumbo@@narod.ru> and me
@
text
@d1 1
a1 1
/* $OpenBSD: radio.c,v 1.4 2002/01/05 02:23:03 mickey Exp $ */
d42 1
d64 2
a65 1
	return (1);
d72 1
a72 3
	struct radio_attach_args *sa = aux;
	struct radio_hw_if *hwp = sa->hwif;
	void  *hdlp = sa->hdl;
d75 2
a76 2
	sc->hw_if = hwp;
	sc->hw_hdl = hdlp;
d158 1
a158 1
	struct radio_attach_args arg;
d160 1
@


1.4
log
@support detach, from netbsd
@
text
@d1 1
a1 1
/* $OpenBSD: radio.c,v 1.3 2002/01/02 22:05:44 mickey Exp $ */
d36 1
d130 2
d137 2
d144 1
a144 1
		error = EINVAL;
@


1.3
log
@probe does not print anything
@
text
@d1 1
a1 1
/* $OpenBSD: radio.c,v 1.2 2001/12/05 10:27:06 mickey Exp $ */
d37 1
d39 1
d46 2
a47 3
int	radioopen(dev_t, int, int, struct proc *);
int	radioclose(dev_t, int, int, struct proc *);
int	radioioctl(dev_t, u_long, caddr_t, int, struct proc *);
d52 1
a52 1
	NULL, NULL
d89 1
a89 1
		return (ENXIO); 
d98 1
a98 1
radioclose(dev_t dev, int flags, int fmt, struct proc *p) 
d150 1
a150 1
struct device  *
d163 38
a200 1
	return UNCONF;
@


1.2
log
@update for radio drivers from tm@@oganer.net und jumbo@@narod.ru
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d61 1
a61 2
	printf("\n");		/* stub!?, fixme */
	return 1;
@


1.2.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: radio.c,v 1.5 2002/01/10 18:38:24 mickey Exp $ */
a35 1
#include <sys/fcntl.h>
a36 1
#include <sys/vnode.h>
a37 1
#include <sys/conf.h>
d44 3
a46 2
int	radiodetach(struct device *, int);
int	radioactivate(struct device *, enum devact);
d51 1
a51 1
	radiodetach, radioactivate
d61 2
a62 1
	return (1);
d89 1
a89 1
		return (ENXIO);
d98 1
a98 1
radioclose(dev_t dev, int flags, int fmt, struct proc *p)
a128 2
		if (!(flags & FWRITE))
			return (EACCES);
a133 2
		if (!(flags & FWRITE))
			return (EACCES);
d139 1
a139 1
		error = (ENOTTY);
d150 1
a150 1
struct device *
d163 1
a163 38
	if (pnp != NULL)
		printf("radio at %s", pnp);
	return (UNCONF);
}

int
radiodetach(struct device *self, int flags)
{
	/*struct radio_softc *sc = (struct radio_softc *)self;*/
	int maj, mn;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == radioopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	return (0);
}

int
radioactivate(struct device *self, enum devact act)
{
	struct radio_softc *sc = (struct radio_softc *)self;

	switch (act) {
	case DVACT_ACTIVATE:
		return (EOPNOTSUPP);
		break;

	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
@


1.2.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: radio.c,v 1.2.2.1 2002/01/31 22:55:29 niklas Exp $ */
a41 1
#include <dev/audio_if.h>
d63 1
a63 2
	struct audio_attach_args *sa = aux;
	return (sa->type == AUDIODEV_TYPE_RADIO) ? 1 : 0;
d70 3
a72 1
	struct audio_attach_args *sa = aux;
d75 2
a76 2
	sc->hw_if = sa->hwif;
	sc->hw_hdl = sa->hdl;
d158 1
a158 1
	struct audio_attach_args arg;
a159 1
	arg.type = AUDIODEV_TYPE_RADIO;
@


1.1
log
@Device independent framework for FM-radio driver.

Work by Maxim Tsyplakov <tm@@oganer.net>,
        Vladimir Popov <jumbo@@narod.ru>
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/* $RuOBSD: radio.c,v 1.5 2001/09/30 14:52:49 pva Exp $ */
d38 1
d90 3
d94 1
a94 1
		return (sc->hw_if->open(dev, flags, fmt, p));
d103 5
a107 1
	return (sc->hw_if->close(dev, flags, fmt, p));
a112 1
	int unit;
d114 1
d118 1
a118 2
	    (sc = radio_cd.cd_devs[unit]) == NULL ||
	     sc->hw_if == NULL)
d120 23
a142 2
	else
		return (sc->hw_if->ioctl(dev, cmd, data, flags, p));
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.1.4.2
log
@Merge in trunk
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $RuOBSD: radio.c,v 1.7 2001/12/04 06:03:05 tm Exp $ */
a35 1
#include <sys/fcntl.h>
a36 1
#include <sys/vnode.h>
a37 2
#include <sys/conf.h>

d43 3
a45 2
int	radiodetach(struct device *, int);
int	radioactivate(struct device *, enum devact);
d50 1
a50 1
	radiodetach, radioactivate
d60 2
a61 1
	return (1);
d88 1
a88 4
		return (ENXIO);

	if (sc->hw_if->open != NULL)
		return (sc->hw_if->open(sc->hw_hdl, flags, fmt, p));
d90 1
a90 1
		return (0);
d94 1
a94 1
radioclose(dev_t dev, int flags, int fmt, struct proc *p)
d99 1
a99 5

	if (sc->hw_if->close != NULL)
		return (sc->hw_if->close(sc->hw_hdl, flags, fmt, p));
	else
		return (0);
d105 1
a106 1
	int unit, error;
d110 2
a111 1
	    (sc = radio_cd.cd_devs[unit]) == NULL || sc->hw_if == NULL)
d113 2
a114 27

	error = EOPNOTSUPP;
	switch (cmd) {
	case RIOCGINFO:
		if (sc->hw_if->get_info)
			error = (sc->hw_if->get_info)(sc->hw_hdl,
					(struct radio_info *)data);
			break;
	case RIOCSINFO:
		if (!(flags & FWRITE))
			return (EACCES);
		if (sc->hw_if->set_info)
			error = (sc->hw_if->set_info)(sc->hw_hdl,
				(struct radio_info *)data);
		break;
	case RIOCSSRCH:
		if (!(flags & FWRITE))
			return (EACCES);
		if (sc->hw_if->search)
			error = (sc->hw_if->search)(sc->hw_hdl,
					*(int *)data);
		break;
	default:
		error = (ENOTTY);
	}

	return (error);
d122 1
a122 1
struct device *
d135 1
a135 38
	if (pnp != NULL)
		printf("radio at %s", pnp);
	return (UNCONF);
}

int
radiodetach(struct device *self, int flags)
{
	/*struct radio_softc *sc = (struct radio_softc *)self;*/
	int maj, mn;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == radioopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	return (0);
}

int
radioactivate(struct device *self, enum devact act)
{
	struct radio_softc *sc = (struct radio_softc *)self;

	switch (act) {
	case DVACT_ACTIVATE:
		return (EOPNOTSUPP);
		break;

	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@a41 1
#include <dev/audio_if.h>
d63 1
a63 2
	struct audio_attach_args *sa = aux;
	return (sa->type == AUDIODEV_TYPE_RADIO) ? 1 : 0;
d70 3
a72 1
	struct audio_attach_args *sa = aux;
d75 2
a76 2
	sc->hw_if = sa->hwif;
	sc->hw_hdl = sa->hdl;
d158 1
a158 1
	struct audio_attach_args arg;
a159 1
	arg.type = AUDIODEV_TYPE_RADIO;
@


