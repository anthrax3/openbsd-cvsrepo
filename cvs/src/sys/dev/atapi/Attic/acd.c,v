head	1.37;
access;
symbols
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	UBC_SYNC_A:1.37
	UBC_SYNC_B:1.37
	SMP:1.37.0.2
	kame_19991208:1.36
	OPENBSD_2_6:1.36.0.2
	OPENBSD_2_6_BASE:1.36
	OPENBSD_2_5:1.35.0.2
	OPENBSD_2_5_BASE:1.35
	OPENBSD_2_4:1.34.0.2
	OPENBSD_2_4_BASE:1.34
	OPENBSD_2_3:1.29.0.4
	OPENBSD_2_3_BASE:1.29
	OPENBSD_2_2:1.29.0.2
	OPENBSD_2_2_BASE:1.29
	OPENBSD_2_1:1.23.0.2
	OPENBSD_2_1_BASE:1.23
	OPENBSD_2_0:1.14.0.2
	OPENBSD_2_0_BASE:1.14;
locks; strict;
comment	@ * @;


1.37
date	99.12.11.21.22.39;	author csapuntz;	state dead;
branches;
next	1.36;

1.36
date	99.08.10.23.09.50;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	99.03.12.04.09.07;	author provos;	state Exp;
branches;
next	1.34;

1.34
date	98.10.05.17.30.58;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	98.10.03.21.18.59;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	98.07.12.01.20.20;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	98.07.11.03.48.24;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.06.09.13.29.57;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	97.10.18.10.37.06;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	97.09.11.11.20.45;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	97.08.08.21.47.00;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	97.07.07.19.48.46;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	97.06.24.05.29.53;	author downsj;	state Exp;
branches;
next	1.24;

1.24
date	97.06.15.02.37.59;	author downsj;	state Exp;
branches;
next	1.23;

1.23
date	97.03.26.01.53.49;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.02.23.18.48.13;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	97.02.23.13.08.49;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	97.02.23.03.08.27;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	97.02.23.02.31.43;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	96.12.24.01.33.38;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.12.11.19.08.24;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.12.05.13.12.11;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.12.05.13.11.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.10.05.07.17.00;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	96.09.11.07.22.03;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	96.09.04.22.13.45;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.09.04.00.51.13;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.08.09.06.57.58;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.08.08.16.52.25;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.08.07.01.56.27;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.08.06.22.41.00;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.07.22.03.35.41;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.10.08.01.06;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.10.00.43.56;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.06.09.18.42.46;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.06.09.08.59.46;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.06.08.09.12.40;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.37
log
@

Bye-bye to the old ATAPI driver
@
text
@/*	$OpenBSD: acd.c,v 1.36 1999/08/10 23:09:50 deraadt Exp $	*/

/*
 * Copyright (c) 1996 Manuel Bouyer.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mtio.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/cdio.h>
#include <sys/proc.h>  

#include <dev/atapi/atapilink.h>
#include <dev/atapi/atapi.h>

#include <ufs/ffs/fs.h>			/* for BBSIZE and SBSIZE */

#define	CDUNIT(z)			DISKUNIT(z)
#define	CDPART(z)			DISKPART(z)
#define	MAKECDDEV(maj, unit, part)	MAKEDISKDEV(maj, unit, part)

#define MAXTRACK	99
#define CD_BLOCK_OFFSET	150
#define CD_FRAMES	75
#define CD_SECS		60
struct cd_toc {
	struct ioc_toc_header hdr;
	struct cd_toc_entry tab[MAXTRACK+1];	/* One extra for the leadout */
};

#define TOC_HEADER_LEN			0
#define TOC_HEADER_STARTING_TRACK	2
#define TOC_HEADER_ENDING_TRACK		3
#define TOC_HEADER_SZ			4

#define TOC_ENTRY_CONTROL_ADDR_TYPE	1
#define TOC_ENTRY_TRACK			2
#define TOC_ENTRY_MSF_LBA		4
#define TOC_ENTRY_SZ			8

#ifdef ACD_DEBUG
#define ACD_DEBUG_PRINT(args)		printf args
#else
#define ACD_DEBUG_PRINT(args)
#endif

#ifdef ATAPI_DEBUG
#define ATAPI_DEBUG_PRINT(args)		printf args
#else
#define ATAPI_DEBUG_PRINT(args)
#endif

struct acd_softc {
	struct	device sc_dev;
	struct	disk sc_dk;

	int flags;
#define	CDF_LOCKED	0x01
#define	CDF_WANTED	0x02
#define	CDF_WLABEL	0x04		/* label is writable */
#define	CDF_LABELLING	0x08		/* writing label */
#define CDF_NOTREADY	0x10		/* not ready at boot */
	struct	at_dev_link *ad_link;	/* contains our drive number, etc ... */
	struct	atapi_mode_data mode_page;	/* drive capabilities */

	struct	cd_parms {
		int	blksize;
		u_int32_t disksize;	/* total number sectors */
	} params;
	struct	buf buf_queue;
};

int	acdmatch __P((struct device *, void *, void *));
void	acdattach __P((struct device *, struct device *, void *));

struct cfattach acd_ca = {
	sizeof(struct acd_softc), acdmatch, acdattach
};

struct cfdriver acd_cd = {
	NULL, "acd", DV_DISK
};

void	acdgetdisklabel __P((struct acd_softc *));
int	acd_get_parms __P((struct acd_softc *, int));
void	acdstrategy __P((struct buf *));
void	acdstart __P((void *));
int	acd_pause __P((struct acd_softc *, int));
void	acdminphys __P((struct buf*));
u_int32_t acd_size __P((struct acd_softc*, int));
int	acddone __P((void *));
int	acdlock __P((struct acd_softc *));
void	acdunlock __P((struct acd_softc *));
int	acdopen __P((dev_t, int, int));
int	acdclose __P((dev_t, int, int));
int	acdread __P((dev_t, struct uio*));
int	acdwrite __P((dev_t, struct uio*));
int	acdioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	acd_reset __P((struct acd_softc *));
int	acdsize __P((dev_t));
int	acddump __P((dev_t, daddr_t, caddr_t, size_t));
int	acd_get_mode __P((struct acd_softc *, struct atapi_mode_data *, int,
	    int, int));
int	acd_set_mode __P((struct acd_softc *, struct atapi_mode_data *, int));
int	acd_setchan __P((struct acd_softc *, u_char, u_char, u_char, u_char));
int	acd_play_big __P((struct acd_softc *, int, int));
int	acd_load_toc __P((struct acd_softc *, struct cd_toc *));
int	acd_play_tracks __P((struct acd_softc *, int, int, int, int));
int	acd_play_msf __P((struct acd_softc *, int, int, int, int, int, int));
int	acd_read_subchannel __P((struct acd_softc *, int, int, int,
	    struct cd_sub_channel_info *, int));
int	acd_read_toc __P((struct acd_softc *, int, int, void *, int));
#if 0
/* Not used anywhere, left here in case that changes. */
static void lba2msf __P((u_int32_t, u_int8_t *, u_int8_t *, u_int8_t *));
#endif
static __inline u_int32_t msf2lba __P((u_int8_t, u_int8_t, u_int8_t));

struct dkdriver acddkdriver = { acdstrategy };

/*
 * Called by the low level atapi code to find the right driver
 * for a drive on the bus.
 */
int
acdmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct at_dev_link *sa = aux;

#ifdef ATAPI_DEBUG_PROBE
	printf("acdmatch: device %d\n",
	    sa->id.config.device_type & ATAPI_DEVICE_TYPE_MASK);
#endif

	if (((sa->id.config.device_type & ATAPI_DEVICE_TYPE_MASK) ==
	    ATAPI_DEVICE_TYPE_CD) || (sa->quirks & AQUIRK_CDROM))
		return 1;
	return 0;
}

/*
 * The routine called by the low level atapi routine when it discovers
 * A device suitable for this driver
 */
void
acdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct acd_softc *acd = (void *)self;
	struct at_dev_link *sa = aux;
	struct atapi_cappage *cap;

	printf("\n");

	sa->device_softc = acd;
	sa->start = acdstart;
	sa->done = acddone;
	sa->flags |= ADEV_REMOVABLE;
	sa->openings = 1;
	acd->ad_link = sa;

	/*
	 * Initialize and attach the disk structure.
	 */
	acd->sc_dk.dk_driver = &acddkdriver;
	acd->sc_dk.dk_name = acd->sc_dev.dv_xname;
	disk_attach(&acd->sc_dk);

	dk_establish(&acd->sc_dk, &acd->sc_dev);   

	if (atapi_test_unit_ready(sa, A_POLLED | A_SILENT) != 0) {
		/* To clear media change, etc ...*/
		delay(1000);
		if (atapi_test_unit_ready(sa, A_POLLED | A_SILENT) != 0)
			acd->flags |= CDF_NOTREADY;
	}

	if (acd_get_mode(acd, &acd->mode_page, ATAPI_CAP_PAGE, CAPPAGESIZE,
	    A_POLLED) != 0) {
		printf("%s: can't MODE SENSE: acd_get_mode failed\n",
		    self->dv_xname);
		return;
	}

	/*
	 * Display useful information about the drive (not media!).
	 */
	cap = &acd->mode_page.page_cap;

	/* Don't print anything unless it looks valid. */
	if (cap->cur_speed > 0) {
		printf ("%s: ", self->dv_xname);
		if (cap->cur_speed != cap->max_speed)
			printf ("%d/", cap->cur_speed * 1000 / 1024);
		printf ("%dKb/sec", cap->max_speed * 1000 / 1024);
		if (cap->buf_size)
			printf (", %dKb cache", cap->buf_size);
		if (cap->format_cap & FORMAT_AUDIO_PLAY)
			printf (", audio play");
		if (cap->max_vol_levels)
			printf (", %d volume levels", cap->max_vol_levels);
		printf ("\n");
	}

	/* We can autoprobe AQUIRK_NODOORLOCK */
	if (!(acd->ad_link->quirks & AQUIRK_NODOORLOCK)) {
		if (atapi_prevent(acd->ad_link, PR_PREVENT)) {
			acd->ad_link->quirks |= AQUIRK_NODOORLOCK;
			printf ("%s: disabling door locks.\n", self->dv_xname);
		} else
			atapi_prevent(acd->ad_link, PR_ALLOW);
	}
}

/*
 * Wait interruptibly for an exclusive lock.
 *
 * XXX
 * Several drivers do this; it should be abstracted and made MP-safe.
 */
int
acdlock(acd)
	struct acd_softc *acd;
{
	int error;

	while ((acd->flags & CDF_LOCKED) != 0) {
		acd->flags |= CDF_WANTED;
		if ((error = tsleep(acd, PRIBIO | PCATCH, "acdlck", 0)) != 0)
			return error;
	}
	acd->flags |= CDF_LOCKED;
	return 0;
}

/*
 * Unlock and wake up any waiters.
 */
void
acdunlock(acd)
	struct acd_softc *acd;
{

	acd->flags &= ~CDF_LOCKED;
	if ((acd->flags & CDF_WANTED) != 0) {
		acd->flags &= ~CDF_WANTED;
		wakeup(acd);
	}
}

/*
 * open the device. Make sure the partition info is a up-to-date as can be.
 */
int
acdopen(dev, flag, fmt)
	dev_t dev;
	int flag, fmt;
{
	struct acd_softc *acd;
	struct at_dev_link *ad_link;
	int unit, part;
	int error;

	ACD_DEBUG_PRINT(("acd: open\n"));

	unit = CDUNIT(dev);
	if (unit >= acd_cd.cd_ndevs)
		return ENXIO;
	acd = acd_cd.cd_devs[unit];
	if (acd == NULL)
		return ENXIO;

	ad_link = acd->ad_link;

	error = atapi_test_unit_ready(ad_link, A_SILENT);
	if ((error != 0) && (acd->flags & CDF_NOTREADY)) {
		/* Do it again. */
		delay(1000);
		error = atapi_test_unit_ready(ad_link, A_SILENT);
	}

	if (error != 0) {
		if (error != UNIT_ATTENTION)
			return EIO;
		if ((ad_link->flags & ADEV_OPEN) != 0)
			return EIO;
	}

	error = acdlock(acd);
	if (error)
		return error;

	if (acd->sc_dk.dk_openmask != 0) {
		/*
		 * If any partition is open, but the disk has been invalidated,
		 * disallow further opens.
		 */
		if ((ad_link->flags & ADEV_MEDIA_LOADED) == 0) {
			error = EIO;
			goto bad3;
		}
	} else {
		ad_link->flags |= ADEV_OPEN;

		/* Lock the pack in. */
		if ((error = atapi_prevent(ad_link, PR_PREVENT)) != 0)
			goto bad;

		if ((ad_link->flags & ADEV_MEDIA_LOADED) == 0) {
			ad_link->flags |= ADEV_MEDIA_LOADED;

			/* Load the physical device parameters. */
			if (acd_get_parms(acd, 0) != 0) {
				error = ENXIO;
				goto bad2;
			}

			/* Fabricate a disk label. */
			acdgetdisklabel(acd);
		}
	}

	part = CDPART(dev);

	/* Check that the partition exists. */
	if (part != RAW_PART &&
	    (part >= acd->sc_dk.dk_label->d_npartitions ||
	    acd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		error = ENXIO;
		goto bad;
	}

	/* Insure only one open at a time. */
	switch (fmt) {
	case S_IFCHR:
		acd->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		acd->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	acd->sc_dk.dk_openmask =
	    acd->sc_dk.dk_copenmask | acd->sc_dk.dk_bopenmask;

	ACD_DEBUG_PRINT(("acd: open complete\n"));

	acdunlock(acd);
	return 0;

bad2:
	ad_link->flags &= ~ADEV_MEDIA_LOADED;

bad:
	if (acd->sc_dk.dk_openmask == 0) {
		atapi_prevent(ad_link, PR_ALLOW);
		ad_link->flags &= ~ADEV_OPEN;
	}

bad3:
	acdunlock(acd);
	return error;
}

/*
 * close the device.. only called if we are the LAST
 * occurence of an open device
 */
int
acdclose(dev, flag, fmt)
	dev_t dev;
	int flag, fmt;
{
	struct acd_softc *acd = acd_cd.cd_devs[CDUNIT(dev)];
	int part = CDPART(dev);
	int error;

	if ((error = acdlock(acd)) != 0)
		return error;

	switch (fmt) {
	case S_IFCHR:
		acd->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		acd->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	acd->sc_dk.dk_openmask =
	    acd->sc_dk.dk_copenmask | acd->sc_dk.dk_bopenmask;

	if (acd->sc_dk.dk_openmask == 0) {
		/* XXXX Must wait for I/O to complete! */

		atapi_prevent(acd->ad_link, PR_ALLOW);
		acd->ad_link->flags &= ~ADEV_OPEN;

		if (acd->ad_link->flags & ADEV_EJECTING) {
			atapi_start_stop(acd->ad_link, SSS_STOP|SSS_LOEJ, 0);

			acd->ad_link->flags &= ~ADEV_EJECTING;
		}
	}

	acdunlock(acd);
	return 0;
}

/*
 * Actually translate the requested transfer into one the physical driver can
 * understand.  The transfer is described by a buf and will include only one
 * physical transfer.
 */
void
acdstrategy(bp)
	struct buf *bp;
{
	struct acd_softc *acd = acd_cd.cd_devs[CDUNIT(bp->b_dev)];
	int opri;

	ACD_DEBUG_PRINT(("acdstrategy\n"));

	/*
	 * The transfer must be a whole number of blocks.
	 */
	if ((bp->b_bcount % acd->sc_dk.dk_label->d_secsize) != 0) {
		bp->b_error = EINVAL;
		goto bad;
	}
	if ((bp->b_flags & (B_READ|B_WRITE)) == B_WRITE) {
		bp->b_error = EROFS;
		goto bad;
	}
	/*
	 * If the device has been made invalid, error out
	 * maybe the media changed
	 */
	if ((acd->ad_link->flags & ADEV_MEDIA_LOADED) == 0) {
		bp->b_error = EIO;
		goto bad;
	}
	/*
	 * If it's a null transfer, return immediately
	 */
	if (bp->b_bcount == 0)
		goto done;

	/*
	 * Do bounds checking, adjust transfer. if error, process.
	 * If end of partition, just return.
	 */
	if (CDPART(bp->b_dev) != RAW_PART &&
	    bounds_check_with_label(bp, acd->sc_dk.dk_label,
	    acd->sc_dk.dk_cpulabel,
	    (acd->flags & (CDF_WLABEL|CDF_LABELLING)) != 0) <= 0)
		goto done;

	opri = splbio();

	/*
	 * Place it in the queue of disk activities for this disk
	 */
	disksort(&acd->buf_queue, bp);

	/*
	 * Tell the device to get going on the transfer if it's
	 * not doing anything, otherwise just wait for completion
	 */
	acdstart(acd);

	splx(opri);
	return;

bad:
	bp->b_flags |= B_ERROR;
done:
	/*
	 * Correctly set the buf to indicate a completed xfer
	 */
	bp->b_resid = bp->b_bcount;
	biodone(bp);
}

/*
 * acdstart looks to see if there is a buf waiting for the device
 * and that the device is not already busy. If both are true,
 * It deques the buf and creates a atapi command to perform the
 * transfer in the buf. The transfer request will call atapi_done
 * on completion, which will in turn call this routine again
 * so that the next queued transfer is performed.
 * The bufs are queued by the strategy routine (cdstrategy)
 *
 * This routine is also called after other non-queued requests
 * have been made of the atapi driver, to ensure that the queue
 * continues to be drained.
 *
 * must be called at the correct (highish) spl level
 * cdstart() is called at splbio from cdstrategy and atapi_done
 */
void
acdstart(vp)
	void *vp;
{
	struct acd_softc *acd = vp;
	struct at_dev_link *ad_link;
	struct buf *bp = 0;
	struct buf *dp;
	struct atapi_read cmd;
	u_int32_t blkno, nblks;
	struct partition *p;

	ACD_DEBUG_PRINT(("acd: acdstart\n"));

#ifdef DIAGNOSTIC
	if (acd == NULL) {
		printf("acdstart: null acd\n");
		return;
	}
#endif

	ad_link = acd->ad_link;

#ifdef DIAGNOSTIC
	if (ad_link == NULL) {
		printf("acdstart: null ad_link\n");
		return;
	}
#endif
	/*
	 * Check if the device has room for another command
	 */
	while (ad_link->openings > 0) {
		/*
		 * there is excess capacity, but a special waits
		 * It'll need the adapter as soon as we clear out of the
		 * way and let it run (user level wait).
		 */
		if (ad_link->flags & ADEV_WAITING) {
			ATAPI_DEBUG_PRINT(("acdstart: waking up\n"));

			ad_link->flags &= ~ADEV_WAITING;
			wakeup((caddr_t)ad_link);
			return;
		}
		
		/*
		 * See if there is a buf with work for us to do..
		 */
		dp = &acd->buf_queue;
#ifdef ACD_DEBUG
		if (dp == NULL) {
			printf("acdstart: null dp\n");
			return;
		}
#endif
		if ((bp = dp->b_actf) == NULL)	/* yes, an assign */
			return;

		ACD_DEBUG_PRINT(("acdstart: a buf\n"));

		dp->b_actf = bp->b_actf;

		/*
		 * If the device has become invalid, abort all the
		 * reads and writes until all files have been closed and
		 * re-opened
		 */
		if ((ad_link->flags & ADEV_MEDIA_LOADED) == 0) {
			bp->b_error = EIO;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
			biodone(bp);
			continue;
		}

		/*
		 *
		 * First, translate the block to absolute and put it in terms
		 * of the logical blocksize of the device.
		 */
		blkno =
		    bp->b_blkno / (acd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
		if (CDPART(bp->b_dev) != RAW_PART) {
			p = &acd->sc_dk.dk_label->d_partitions[
			    CDPART(bp->b_dev)];
			blkno += p->p_offset;
		}
		nblks = howmany(bp->b_bcount, acd->sc_dk.dk_label->d_secsize);

		ACD_DEBUG_PRINT(("acdstart: blkno %d nblk %d\n", blkno,
		    nblks));

		/*
		 *  Fill out the atapi command
		 */
		bzero(&cmd, sizeof(cmd));
		cmd.opcode = ATAPI_READ;
		_lto4b(blkno, cmd.lba);
		_lto2b(nblks, cmd.length);

		/* Instrumentation. */
		disk_busy(&acd->sc_dk);

		/*
		 * Call the routine that chats with the adapter.
		 * Note: we cannot sleep as we may be an interrupt
		 */
		if (atapi_exec_io(ad_link, &cmd, sizeof(cmd), bp, A_NOSLEEP)) {
		 	disk_unbusy(&acd->sc_dk, 0);
			printf("%s: not queued", acd->sc_dev.dv_xname);
		}
	}
}

int
acdread(dev, uio)
	dev_t dev;
	struct uio *uio;
{

	return (physio(acdstrategy, NULL, dev, B_READ, acdminphys, uio));
}

int
acdwrite(dev, uio)
	dev_t dev;
	struct uio *uio;
{

	return (physio(acdstrategy, NULL, dev, B_WRITE, acdminphys, uio));
}

#if 0
/* Not used anywhere, left here in case that changes. */

/*
 * conversion between minute-seconde-frame and logical block adress
 * adresses format
 */
static void
lba2msf (lba, m, s, f)
	u_int32_t lba;
	u_int8_t *m, *s, *f;
{
	u_int32_t tmp;
	tmp = lba + CD_BLOCK_OFFSET;	/* offset of first logical frame */
	tmp &= 0xffffff;		/* negative lbas use only 24 bits */
	*m = tmp / (CD_SECS * CD_FRAMES);
	tmp %= (CD_SECS * CD_FRAMES);
	*s = tmp / CD_FRAMES;
	*f = tmp % CD_FRAMES;
}
#endif

static __inline u_int32_t
msf2lba (m, s, f)
	u_int8_t m, s, f;
{
	return (((m * CD_SECS) + s) * CD_FRAMES + f) - CD_BLOCK_OFFSET;
}

/*
 * Perform special action on behalf of the user.
 * Knows about the internals of this device
 */
int
acdioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	struct acd_softc *acd = acd_cd.cd_devs[CDUNIT(dev)];
	int error;

	/*
	 * If the device is not valid.. abandon ship
	 */
	if ((acd->ad_link->flags & ADEV_MEDIA_LOADED) == 0)
		return EIO;

	switch (cmd) {
	case DIOCRLDINFO:
		acdgetdisklabel(acd);
		return 0;
	case DIOCGDINFO:
	case DIOCGPDINFO:
		*(struct disklabel *)addr = *acd->sc_dk.dk_label;
		return 0;

	case DIOCGPART:
		((struct partinfo *)addr)->disklab = acd->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &acd->sc_dk.dk_label->d_partitions[CDPART(dev)];
		return 0;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0)
			return EBADF;

		if ((error = acdlock(acd)) != 0)
			return error;
		acd->flags |= CDF_LABELLING;

		error = setdisklabel(acd->sc_dk.dk_label,
		    (struct disklabel *)addr, /*acd->sc_dk.dk_openmask : */0,
		    acd->sc_dk.dk_cpulabel);
		if (error == 0) {
			/* XXX ?? */
		}

		acd->flags &= ~CDF_LABELLING;
		acdunlock(acd);
		return error;

	case DIOCWLABEL:
		return EROFS;

	case CDIOCPLAYTRACKS: {
		struct ioc_play_track *args = (struct ioc_play_track *)addr;

		return acd_play_tracks(acd, args->start_track,
		    args->start_index, args->end_track, args->end_index);
	}

	case CDIOCPLAYMSF: {
		struct ioc_play_msf *args = (struct ioc_play_msf *)addr;

		return acd_play_msf(acd, args->start_m, args->start_s,
		    args->start_f, args->end_m, args->end_s, args->end_f);
	}

	case CDIOCPLAYBLOCKS: {
		struct ioc_play_blocks *args = (struct ioc_play_blocks *)addr;

		return acd_play_big(acd, args->blk, args->len);
	}

	case CDIOCREADSUBCHANNEL: {
		struct ioc_read_subchannel *args =
		    (struct ioc_read_subchannel *)addr;
		struct cd_sub_channel_info data;
		int len = args->data_len;

		if (len > (int)sizeof(data) ||
		    len < (int)sizeof(struct cd_sub_channel_header))
			return EINVAL;

		error = acd_read_subchannel(acd, args->address_format,
		    args->data_format, args->track, &data, len);
		if (error)
			return error;
		return copyout(&data, args->data, len);
	}

	/* XXX Remove endian dependency */
	case CDIOREADTOCHEADER: {
		struct ioc_toc_header hdr;

		error = acd_read_toc(acd, 0, 0, &hdr, sizeof(hdr));
		if (error)
			return error;
		if (acd->ad_link->quirks & AQUIRK_LITTLETOC)
			bswap((u_int8_t *)&hdr.len, sizeof(hdr.len));
		bcopy(&hdr, addr, sizeof(hdr));
		return 0;
	}

	/* XXX Remove endian dependency */
	case CDIOREADTOCENTRYS: {
		struct ioc_read_toc_entry *te =
		    (struct ioc_read_toc_entry *)addr;
		struct cd_toc toc;
		struct ioc_toc_header *th = &toc.hdr;
		int len = te->data_len;
		int ntracks;

		if (len > (int)sizeof(toc.tab) ||
		    len < (int)sizeof(struct cd_toc_entry))
			return EINVAL;

		error = acd_read_toc(acd, te->address_format,
		    te->starting_track, &toc,
		    len + sizeof(struct ioc_toc_header));
		if (error)
			return error;

		if (te->address_format == CD_LBA_FORMAT) {
			for (ntracks =
			    th->ending_track - th->starting_track + 1;
		            ntracks >= 0; ntracks--) {
				toc.tab[ntracks].addr_type = CD_LBA_FORMAT;
				if (acd->ad_link->quirks & AQUIRK_LITTLETOC)
					bswap((u_int8_t*)
					    &toc.tab[ntracks].addr.addr,
					    sizeof(toc.tab[ntracks].addr.addr));
			}
		}
		if (acd->ad_link->quirks & AQUIRK_LITTLETOC)
			bswap((u_int8_t*)&th->len, sizeof(th->len));
		len = min(len, ntohs(th->len) - (sizeof(th->starting_track) +
			sizeof(th->ending_track)));
		return copyout(toc.tab, te->data, len);
	}

	case CDIOCSETPATCH: {
		struct ioc_patch *arg = (struct ioc_patch *)addr;

		return acd_setchan(acd, arg->patch[0], arg->patch[1],
		    arg->patch[2], arg->patch[3]);
	}

	case CDIOCGETVOL: {
		struct ioc_vol *arg = (struct ioc_vol *)addr;
		struct atapi_mode_data data;

		error = acd_get_mode(acd, &data, ATAPI_AUDIO_PAGE,
		    AUDIOPAGESIZE, 0);
		if (error)
			return error;
		arg->vol[0] = data.page_audio.port[0].volume;
		arg->vol[1] = data.page_audio.port[1].volume;
		arg->vol[2] = data.page_audio.port[2].volume;
		arg->vol[3] = data.page_audio.port[3].volume;
		return 0;
	}

	case CDIOCSETVOL: {
		struct ioc_vol *arg = (struct ioc_vol *)addr;
		struct atapi_mode_data data, mask;

		error = acd_get_mode(acd, &data, ATAPI_AUDIO_PAGE,
		    AUDIOPAGESIZE, 0);
		if (error)
			return error;

		error = acd_get_mode(acd, &mask, ATAPI_AUDIO_PAGE_MASK,
		    AUDIOPAGESIZE, 0);
		if (error)
			return error;

		data.page_audio.port[0].volume = arg->vol[0] &
		    mask.page_audio.port[0].volume;
		data.page_audio.port[1].volume = arg->vol[1] &
		    mask.page_audio.port[1].volume;
		data.page_audio.port[2].volume = arg->vol[2] &
		    mask.page_audio.port[2].volume;
		data.page_audio.port[3].volume = arg->vol[3] &
		    mask.page_audio.port[3].volume;

		return acd_set_mode(acd, &data, AUDIOPAGESIZE);
	}

	case CDIOCSETMONO: {
		return acd_setchan(acd, BOTH_CHANNEL, BOTH_CHANNEL,
		    MUTE_CHANNEL, MUTE_CHANNEL);
	}

	case CDIOCSETSTEREO: {
		return acd_setchan(acd, LEFT_CHANNEL, RIGHT_CHANNEL,
		    MUTE_CHANNEL, MUTE_CHANNEL);
	}

	case CDIOCSETMUTE: {
		return acd_setchan(acd, MUTE_CHANNEL, MUTE_CHANNEL,
		    MUTE_CHANNEL, MUTE_CHANNEL);
	}

	case CDIOCSETLEFT: {
		return acd_setchan(acd, LEFT_CHANNEL, LEFT_CHANNEL,
		    MUTE_CHANNEL, MUTE_CHANNEL);
	}

	case CDIOCSETRIGHT: {
		return acd_setchan(acd, RIGHT_CHANNEL, RIGHT_CHANNEL,
		    MUTE_CHANNEL, MUTE_CHANNEL);
	}

	case CDIOCRESUME:
		return acd_pause(acd, PA_RESUME);

	case CDIOCPAUSE:
		return acd_pause(acd, PA_PAUSE);

	case CDIOCSTART:
		return atapi_start_stop(acd->ad_link, SSS_START, 0);

	case CDIOCSTOP:
		return atapi_start_stop(acd->ad_link, SSS_STOP, 0);

	case MTIOCTOP:
		if (((struct mtop *)addr)->mt_op != MTOFFL)
			return EIO;
		/* FALLTHROUGH */

	case CDIOCEJECT:	/* FALLTHROUGH */
	case DIOCEJECT:
		acd->ad_link->flags |= ADEV_EJECTING;
		return 0;

	case CDIOCALLOW:
		return atapi_prevent(acd->ad_link, PR_ALLOW);

	case CDIOCPREVENT:
		return atapi_prevent(acd->ad_link, PR_PREVENT);

	case DIOCLOCK:
		return atapi_prevent(acd->ad_link,
		    (*(int *)addr) ? PR_PREVENT : PR_ALLOW);

	case CDIOCRESET:
		return acd_reset(acd);

	default:
		return ENOTTY;
	}

#ifdef DIAGNOSTIC
	panic("acdioctl: impossible");
#endif
}

/*
 * Load the label information on the named device
 * Actually fabricate a disklabel
 *
 * EVENTUALLY take information about different
 * data tracks from the TOC and put it in the disklabel
 */
void
acdgetdisklabel(acd)
	struct acd_softc *acd;
{
	struct disklabel *lp = acd->sc_dk.dk_label;
	char *errstring;
	u_int8_t hdr[TOC_HEADER_SZ], *toc, *ent;
	u_int32_t lba, nlba;
	int i, n, len, is_data, data_track = -1;

	bzero(lp, sizeof(struct disklabel));
	bzero(acd->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));

	lp->d_secsize = acd->params.blksize;
	lp->d_ntracks = 1;
	lp->d_nsectors = 100;
	lp->d_ncylinders = (acd->params.disksize / 100) + 1;
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
	if (lp->d_secpercyl == 0) {
		lp->d_secpercyl = 100;
		/* as long as it's not 0 - readdisklabel divides by it (?) */
	}

	strncpy(lp->d_typename, "ATAPI CD-ROM", 16);
	lp->d_type = DTYPE_SCSI;	/* XXX */
	strncpy(lp->d_packname, "fictitious", 16);
	lp->d_secperunit = acd->params.disksize;
	lp->d_rpm = 300;
	lp->d_interleave = 1;
	lp->d_flags = D_REMOVABLE;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	/*
	 * Read the TOC and loop throught the individual tracks and lay them
	 * out in our disklabel.  If there is a data track, call the generic
	 * disklabel read routine.  XXX should we move all data tracks up front
	 * before any other tracks?
	 */
	if (acd_read_toc(acd, 0, 0, hdr, TOC_HEADER_SZ))
		return;
	n = min(hdr[TOC_HEADER_ENDING_TRACK] - hdr[TOC_HEADER_STARTING_TRACK] +
	   1, MAXPARTITIONS);
	len = TOC_HEADER_SZ + (n + 1) * TOC_ENTRY_SZ;
	MALLOC(toc, u_int8_t *, len, M_TEMP, M_WAITOK);
	if (acd_read_toc (acd, CD_LBA_FORMAT, 0, toc, len))
		goto done;

	/* XXX - these values for BBSIZE and SBSIZE assume ffs */
	lp->d_bbsize = BBSIZE;
	lp->d_sbsize = SBSIZE;

	/* The raw partition is special.  */
	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * lp->d_secsize / DEV_BSIZE;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;

	/* Create the partition table.  */
	lp->d_npartitions = max(RAW_PART, n) + 1;
	ent = toc + TOC_HEADER_SZ;
	lba = ((acd->ad_link->quirks & AQUIRK_LITTLETOC) ?
	    ent[TOC_ENTRY_MSF_LBA] | ent[TOC_ENTRY_MSF_LBA + 1] << 8 |
	    ent[TOC_ENTRY_MSF_LBA + 2] << 16 |
	    ent[TOC_ENTRY_MSF_LBA + 3] << 24 :
	    ent[TOC_ENTRY_MSF_LBA] << 24 | ent[TOC_ENTRY_MSF_LBA + 1] << 16 |
	    ent[TOC_ENTRY_MSF_LBA + 2] << 8 | ent[TOC_ENTRY_MSF_LBA + 3]) *
	    lp->d_secsize / DEV_BSIZE;

	for (i = 0; i < (n > RAW_PART + 1 ? n + 1 : n); i++) {
		/* The raw partition was specially handled above.  */
		if (i != RAW_PART) {
			is_data = toc[TOC_HEADER_SZ +
			    TOC_ENTRY_CONTROL_ADDR_TYPE] & 4;
			lp->d_partitions[i].p_fstype =
			    is_data ? FS_UNUSED : FS_OTHER;
			if (is_data && data_track == -1)
				data_track = i;
			ent += TOC_ENTRY_SZ;
			nlba = ((acd->ad_link->quirks & AQUIRK_LITTLETOC) ?
			    ent[TOC_ENTRY_MSF_LBA] |
			    ent[TOC_ENTRY_MSF_LBA + 1] << 8 |
			    ent[TOC_ENTRY_MSF_LBA + 2] << 16 |
			    ent[TOC_ENTRY_MSF_LBA + 3] << 24 :
			    ent[TOC_ENTRY_MSF_LBA] << 24 |
			    ent[TOC_ENTRY_MSF_LBA + 1] << 16 |
			    ent[TOC_ENTRY_MSF_LBA + 2] << 8 |
			    ent[TOC_ENTRY_MSF_LBA + 3]) * lp->d_secsize /
			    DEV_BSIZE;
			lp->d_partitions[i].p_offset = lba;
			lp->d_partitions[i].p_size = nlba - lba;
			lba = nlba;
		}
	}

	/* We have a data track, look in there for a real disklabel.  */
	if (data_track != -1) {
#ifdef notyet
		/*
		 * Reading a disklabel inside the track we setup above
		 * does not yet work, for unknown reasons.
		 */
		errstring = readdisklabel(MAKECDDEV(0, acd->sc_dev.dv_unit,
		    data_track), acdstrategy, lp, acd->sc_dk.dk_cpulabel, 0);
#else
		errstring = readdisklabel(MAKECDDEV(0, acd->sc_dev.dv_unit,
		    RAW_PART), acdstrategy, lp, acd->sc_dk.dk_cpulabel, 0);
#endif
		/*if (errstring)
			printf("%s: %s\n", acd->sc_dev.dv_xname, errstring);*/
	}

done:
	FREE(toc, M_TEMP);
}

/*
 * Find out from the device what it's capacity is
 */
u_int32_t
acd_size(acd, flags)
	struct acd_softc *acd;
	int flags;
{
	struct atapi_read_cd_capacity_data rdcap;
	struct atapi_read_cd_capacity cmd;
	int result;

	if (acd->ad_link->quirks & AQUIRK_NOCAPACITY) {
		/*
		 * the drive doesn't support the READ_CD_CAPACITY command
		 * use a fake size
		 */
		acd->params.blksize = 2048;
		acd->params.disksize = 400000;

		return 400000;
	}

	/*
	 * make up a atapi command and ask the atapi driver to do
	 * it for you.
	 */
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = ATAPI_READ_CD_CAPACITY;
	cmd.len = sizeof(rdcap);

	/*
	 * If the command works, interpret the result as a 4 byte
	 * number of blocks and a blocksize
	 */
	result = atapi_exec_cmd(acd->ad_link, &cmd, sizeof(cmd),
				&rdcap, sizeof(rdcap), B_READ, 0);
	if (result != 0) {
		u_int8_t error = result >> 8;
		/* Get the sense key and check for an illegal request */
		if ((error >> 4) == ATAPI_SK_ILLEGAL_REQUEST) {
			acd->ad_link->quirks |= AQUIRK_NOCAPACITY;
			return acd_size(acd, flags);
		}
		ATAPI_DEBUG_PRINT(("ATAPI_READ_CD_CAPACITY failed\n"));
		return 0;
	}

	acd->params.blksize = _4btol((u_int8_t*)&rdcap.blksize);
	if (acd->params.blksize < 512 || acd->params.blksize > 2048)
		acd->params.blksize = 2048;	/* some drives lie ! */
	acd->params.disksize = _4btol((u_int8_t*)&rdcap.size);

	ATAPI_DEBUG_PRINT(("acd_size: %ld %ld\n", acd->params.blksize,
	    acd->params.disksize));
	return acd->params.disksize;
}

/*
 * Get the requested page into the buffer given
 */
int
acd_get_mode(acd, data, page, len, flags)
	struct acd_softc *acd;
	struct atapi_mode_data *data;
	int page, len, flags;
{
	struct atapi_mode_sense atapi_cmd;
	int error;

	bzero(&atapi_cmd, sizeof(atapi_cmd));
	bzero(data, sizeof(struct atapi_mode_data));
	atapi_cmd.opcode = ATAPI_MODE_SENSE;
	atapi_cmd.page_code_control = page;
	_lto2b(len, atapi_cmd.length);

	error = atapi_exec_cmd(acd->ad_link, &atapi_cmd, sizeof(atapi_cmd),
	    data, len, B_READ, flags);
	if (!error) {
		switch(page) {
		case ATAPI_CAP_PAGE: {
			struct atapi_cappage *fix = &data->page_cap;

        		/*
	         	 * Fix cappage entries in place.
			 */
			fix->max_speed = _2btos((u_int8_t *)&fix->max_speed);
			fix->max_vol_levels =
			    _2btos((u_int8_t *)&fix->max_vol_levels);
			fix->buf_size = _2btos((u_int8_t *)&fix->buf_size);
			fix->cur_speed = _2btos((u_int8_t *)&fix->cur_speed);
			break;
		      }
		}
	}

	return(error);
}

/*
 * Get the requested page into the buffer given
 */
int
acd_set_mode(acd, data, len)
	struct acd_softc *acd;
	struct atapi_mode_data *data;
	int len;
{
	struct atapi_mode_select atapi_cmd;

	bzero(&data->header.length, sizeof(data->header.length));
	bzero(&atapi_cmd, sizeof(atapi_cmd));

	atapi_cmd.opcode = ATAPI_MODE_SELECT;
	atapi_cmd.flags |= MODE_BIT;
	atapi_cmd.page = data->page_code;
	_lto2b(len, atapi_cmd.length);

	return atapi_exec_cmd(acd->ad_link, &atapi_cmd, sizeof(atapi_cmd),
	    data, len, B_WRITE, 0);
}

int
acd_setchan(acd, c0, c1, c2, c3)
	struct acd_softc *acd;
	u_char c0, c1, c2, c3;
{
	struct atapi_mode_data data;
	int error;

	error = acd_get_mode(acd, &data, ATAPI_AUDIO_PAGE, AUDIOPAGESIZE, 0);
	if (error)
		return error;

	data.page_audio.port[0].channels = c0;
	data.page_audio.port[1].channels = c1;
	data.page_audio.port[2].channels = c2;
	data.page_audio.port[3].channels = c3;

	return acd_set_mode(acd, &data, AUDIOPAGESIZE);
}

/*
 * Get atapi driver to send a "start playing" command
 */
int
acd_play_big(acd, blkno, nblks)
	struct acd_softc *acd;
	int blkno, nblks;
{
	struct atapi_play_big atapi_cmd;

	bzero(&atapi_cmd, sizeof(atapi_cmd));
	atapi_cmd.opcode = ATAPI_PLAY_BIG;
	_lto4b(blkno, atapi_cmd.lba);
	_lto4b(nblks, atapi_cmd.length);

	return atapi_exec_cmd(acd->ad_link, &atapi_cmd, sizeof(atapi_cmd),
	    NULL, 0, 0, 0);
}

int
acd_load_toc(acd, toc)
	struct acd_softc *acd;
	struct cd_toc *toc;
{
	int i, ntracks, len, error;
	u_int32_t *lba;

	error = acd_read_toc(acd, 0, 0, toc, sizeof(toc->hdr));
	if (error)
		return error;

	ntracks = toc->hdr.ending_track-toc->hdr.starting_track + 1;
	len = (ntracks+1) * sizeof(struct cd_toc_entry) + sizeof(toc->hdr);
	error = acd_read_toc(acd, CD_MSF_FORMAT, 0, toc, len);
	if (error)
		return(error);
	for (i = 0; i <= ntracks; i++) {
		lba = (u_int32_t*)toc->tab[i].addr.addr;
		*lba = msf2lba(toc->tab[i].addr.addr[1],
		    toc->tab[i].addr.addr[2], toc->tab[i].addr.addr[3]);
	}
	return 0;
}

/*
 * Get atapi driver to send a "start playing" command
 */
int
acd_play_tracks(acd, strack, sindex, etrack, eindex)
	struct acd_softc *acd;
	int strack, sindex, etrack, eindex;
{
	u_int32_t *start, *end, len;
	struct cd_toc toc;
	int error;

	if (!etrack)
		return EIO;
	if (strack > etrack)
		return EINVAL;

	error = acd_load_toc(acd, &toc);
	if (error)
		return error;

	if (++etrack > (toc.hdr.ending_track + 1))
		etrack = toc.hdr.ending_track + 1;

	strack -= toc.hdr.starting_track;
	etrack -= toc.hdr.starting_track;
	if (strack < 0)
		return EINVAL;

	start = (u_int32_t*)toc.tab[strack].addr.addr;
	end = (u_int32_t*)toc.tab[etrack].addr.addr;
	len = *end - *start;

	return acd_play_big(acd, *start, len);
}

/*
 * Get atapi driver to send a "play msf" command
 */
int
acd_play_msf(acd, startm, starts, startf, endm, ends, endf)
	struct acd_softc *acd;
	int startm, starts, startf, endm, ends, endf;
{
	struct atapi_play_msf atapi_cmd;

	bzero(&atapi_cmd, sizeof(atapi_cmd));
	atapi_cmd.opcode = ATAPI_PLAY_MSF;
	atapi_cmd.start_m = startm;
	atapi_cmd.start_s = starts;
	atapi_cmd.start_f = startf;
	atapi_cmd.end_m = endm;
	atapi_cmd.end_s = ends;
	atapi_cmd.end_f = endf;

	return atapi_exec_cmd(acd->ad_link, (struct atapi_generic *)&atapi_cmd,
	    sizeof(atapi_cmd), NULL, 0, 0, 0);
}

/*
 * Get atapi driver to send a "start up" command
 */
int
acd_pause(acd, go)
	struct acd_softc *acd;
	int go;
{
	struct atapi_pause_resume cmd;

	bzero(&cmd, sizeof(cmd));
	cmd.opcode = ATAPI_PAUSE_RESUME;
	cmd.resume = go & 0xff;

	return atapi_exec_cmd(acd->ad_link, &cmd , sizeof(cmd), 0, 0, 0, 0);
}

/*
 * Get atapi driver to send a "RESET" command
 */
int
acd_reset(acd)
	struct acd_softc *acd;
{
#ifdef notyet	
	return atapi_soft_reset(acd->ad_link);
#else
 	return 0;
#endif
}

/*
 * Read subchannel
 */
int
acd_read_subchannel(acd, mode, format, track, data, len)
	struct acd_softc *acd;
	int mode, format, len;
	struct cd_sub_channel_info *data;
{
	struct atapi_read_subchannel atapi_cmd;

	bzero(&atapi_cmd, sizeof(atapi_cmd));

	atapi_cmd.opcode = ATAPI_READ_SUBCHANNEL;
	if (mode == CD_MSF_FORMAT)
		atapi_cmd.flags[0] |= SUBCHAN_MSF;
	if (len > (int)sizeof(struct cd_sub_channel_header))
		atapi_cmd.flags[1] |= SUBCHAN_SUBQ;
	atapi_cmd.subchan_format = format;
	atapi_cmd.track = track;
	_lto2b(len, atapi_cmd.length);

	return atapi_exec_cmd(acd->ad_link, (struct atapi_generic *)&atapi_cmd,
	    sizeof(struct atapi_read_subchannel), (u_char *)data, len, B_READ,
	    0);
}

/*
 * Read table of contents
 */
int
acd_read_toc(acd, mode, start, data, len)
	struct acd_softc *acd;
	int mode, start, len;
	void *data;
{
	struct atapi_read_toc atapi_cmd;

	bzero(&atapi_cmd, sizeof(atapi_cmd));

	atapi_cmd.opcode = ATAPI_READ_TOC;
	if (mode == CD_MSF_FORMAT)
		atapi_cmd.flags |= TOC_MSF;
	atapi_cmd.track = start;
	_lto2b(len, atapi_cmd.length);

	return atapi_exec_cmd(acd->ad_link, (struct atapi_generic *)&atapi_cmd,
	    sizeof(struct atapi_read_toc), data, len, B_READ, 0);
}

/*
 * Get the atapi driver to send a full inquiry to the device and use the
 * results to fill out the disk parameter structure.
 */
int
acd_get_parms(acd, flags)
	struct acd_softc *acd;
	int flags;
{
	/*
	 * give a number of sectors so that sec * trks * cyls
	 * is <= disk_size
	 */
	if (acd_size(acd, flags) == 0)
		return ENXIO;

	return 0;
}

int
acdsize(dev)
	dev_t dev;
{
	/* CD-ROMs are read-only. */
	return -1;
}

void acdminphys(bp)
	struct buf *bp;
{
	minphys(bp);
}

int
acddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{
	/* Not implemented. */
	return ENXIO;
}

int
acddone(vp)
	void *vp;
{
	struct atapi_command_packet *acp = vp;
	struct at_dev_link *ad_link = acp->ad_link;
	struct acd_softc *acd = ad_link->device_softc;

	if (acp->bp != NULL)
		disk_unbusy(&acd->sc_dk,
		    (acp->bp->b_bcount - acp->bp->b_resid));

	return (0);     
}
@


1.36
log
@support DIOCRLDINFO
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.35 1999/03/12 04:09:07 provos Exp $	*/
@


1.35
log
@fix problem where last entry in cd toc had seconds and frame zeroed,
wouters@@cistron.nl.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.34 1998/10/05 17:30:58 millert Exp $	*/
d724 3
@


1.34
log
@make DIOCGPDINFO equivalent to DIOCGDINFO for cd's
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.33 1998/10/03 21:18:59 millert Exp $	*/
d840 2
a841 2

		len = min(len, ntohs(th->len) - sizeof(struct ioc_toc_header));
@


1.33
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.32 1998/07/12 01:20:20 deraadt Exp $	*/
d725 1
@


1.32
log
@fill in d_bbsize and d_sbsize
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.31 1998/07/11 03:48:24 deraadt Exp $	*/
d1073 1
a1073 1
		    data_track), acdstrategy, lp, acd->sc_dk.dk_cpulabel);
d1076 1
a1076 1
		    RAW_PART), acdstrategy, lp, acd->sc_dk.dk_cpulabel);
@


1.31
log
@always return TOC information in big-endian order; problem noted by
csapuntz@@lcs.mit.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.30 1998/06/09 13:29:57 provos Exp $	*/
d54 2
d1017 4
@


1.30
log
@Autodetect ATAPI CDROMS which do not support the ATAPI_READ_CD_CAPACITY
and fake it (meaning add AQUIRK_NOCAPACITY).
Also add an entry for NEC CD Changer reported by W. Scholten
<wouters@@cistron.nl>.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.29 1997/10/18 10:37:06 deraadt Exp $	*/
d799 1
a799 2
		if (acd->ad_link->quirks & AQUIRK_LITTLETOC) {
#if BYTE_ORDER == BIG_ENDIAN
a800 3
#endif
		} else
			hdr.len = ntohs(hdr.len);
d829 1
a829 2
				if (acd->ad_link->quirks & AQUIRK_LITTLETOC) {
#if BYTE_ORDER == BIG_ENDIAN
d832 1
a832 6
					    sizeof(toc.tab[ntracks].addr.addr)
					    );
#endif
				} else
					toc.tab[ntracks].addr.lba =
					    ntohl(toc.tab[ntracks].addr.lba);
d835 1
a835 2
		if (acd->ad_link->quirks & AQUIRK_LITTLETOC) {
#if BYTE_ORDER == BIG_ENDIAN
a836 3
#endif
		} else
			th->len = ntohs(th->len);
d838 1
a838 1
		len = min(len, th->len - sizeof(struct ioc_toc_header));
@


1.29
log
@avoid "no disklabel" error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.28 1997/09/11 11:20:45 deraadt Exp $	*/
d1104 1
d1129 9
a1137 2
	if (atapi_exec_cmd(acd->ad_link, &cmd, sizeof(cmd),
	    &rdcap, sizeof(rdcap), B_READ, 0) != 0) {
@


1.28
log
@cd_play/acd_play() were replaced a while back
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.27 1997/08/08 21:47:00 niklas Exp $	*/
d1086 2
a1087 2
		if (errstring)
			printf("%s: %s\n", acd->sc_dev.dv_xname, errstring);
@


1.27
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.26 1997/07/07 19:48:46 niklas Exp $	*/
a141 1
int	acd_play __P((struct acd_softc *, int, int));
a1225 19
}

/*
 * Get atapi driver to send a "start playing" command
 */
int
acd_play(acd, blkno, nblks)
	struct acd_softc *acd;
	int blkno, nblks;
{
	struct atapi_play atapi_cmd;

	bzero(&atapi_cmd, sizeof(atapi_cmd));
	atapi_cmd.opcode = ATAPI_PLAY_AUDIO;
	_lto4b(blkno, atapi_cmd.lba);
	_lto2b(nblks, atapi_cmd.length);

	return atapi_exec_cmd(acd->ad_link, &atapi_cmd, sizeof(atapi_cmd),
	    NULL, 0, 0, 0);
@


1.26
log
@Get rid of the arch-dependent long type
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.25 1997/06/24 05:29:53 downsj Exp $	*/
d493 1
@


1.25
log
@Add AQUIRK_TUR, from manuel.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.24 1997/06/15 02:37:59 downsj Exp $	*/
d104 1
a104 1
		u_long	disksize;	/* total number sectors */
d126 1
a126 1
u_long	acd_size __P((struct acd_softc*, int));
d1097 1
a1097 1
u_long
@


1.24
log
@Automatically decide whether or not to disable door locks.  Idea from provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.23 1997/03/26 01:53:49 deraadt Exp $	*/
a127 1
#ifndef XXX
a137 1
#endif
@


1.23
log
@deal with CD drives that indicate 2352 bytes per block...
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.22 1997/02/23 18:48:13 niklas Exp $	*/
d245 9
@


1.22
log
@Just some more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.21 1997/02/23 13:08:49 niklas Exp $	*/
a986 5
#if 0
	/* I don't think this is necessary anymore.  */
	if (lp->d_secsize > 2048)
		lp->d_secsize = 2048;
#endif
d1128 2
@


1.21
log
@Some KNF, but more important: fix disklabels for audio CDs +
preliminary support for multi-session CDs although the ISO9660 spoofing
must be remade for that to really work.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.20 1997/02/23 03:08:27 niklas Exp $	*/
d1159 1
a1159 1
			       data, len, B_READ, flags);
d1164 1
d1169 2
a1170 1
			fix->max_vol_levels = _2btos((u_int8_t *)&fix->max_vol_levels);
d1173 2
a1174 1
			} break;
d1201 1
a1201 1
			      data, len, B_WRITE, 0);
d1240 1
a1240 1
			      NULL, 0, 0, 0);
d1259 1
a1259 1
			      NULL, 0, 0, 0);
d1282 1
a1282 2
			       toc->tab[i].addr.addr[2],
			       toc->tab[i].addr.addr[3]);
d1343 1
a1343 1
			      sizeof(atapi_cmd), NULL, 0, 0, 0);
d1400 2
a1401 2
			      sizeof(struct atapi_read_subchannel),
			      (u_char *)data, len, B_READ, 0);
d1424 1
a1424 2
			      sizeof(struct atapi_read_toc), data,
			      len, B_READ, 0);
a1435 1

a1449 1

a1456 1

a1466 1

@


1.20
log
@Fix mem leak, count partitions (tracks) right for audio disklabels.  Partition offset & sizes still worng in this case though.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.19 1997/02/23 02:31:43 niklas Exp $	*/
d221 1
a221 1
			 A_POLLED) != 0) {
d223 1
a223 1
		       self->dv_xname);
d361 1
a361 1
	     acd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
d615 2
a616 2
			p =
			  &acd->sc_dk.dk_label->d_partitions[CDPART(bp->b_dev)];
d621 2
a622 2
		ACD_DEBUG_PRINT(("acdstart: blkno %d nblk %d\n",
		    blkno, nblks));
d639 1
a639 1
		 if (atapi_exec_io(ad_link, &cmd, sizeof(cmd), bp, A_NOSLEEP)) {
d752 1
a752 2
				       args->start_index, args->end_track,
				       args->end_index);
d759 1
a759 2
				    args->start_f, args->end_m, args->end_s,
				    args->end_f);
d769 2
a770 2
		struct ioc_read_subchannel *args
				= (struct ioc_read_subchannel *)addr;
d779 1
a779 1
		    	args->data_format, args->track, &data, len);
d805 1
a805 1
				(struct ioc_read_toc_entry *)addr;
d822 5
a826 4
		    for (ntracks = th->ending_track - th->starting_track + 1;
		         ntracks >= 0; ntracks--) {
			toc.tab[ntracks].addr_type = CD_LBA_FORMAT;
			if (acd->ad_link->quirks & AQUIRK_LITTLETOC) {
d828 4
a831 1
				bswap((u_int8_t*)&toc.tab[ntracks].addr.addr, sizeof(toc.tab[ntracks].addr.addr));
d833 4
a836 3
			} else
				(u_int32_t)(*toc.tab[ntracks].addr.addr) = ntohl((u_int32_t)(*toc.tab[ntracks].addr.addr));
		    }
d840 1
a840 1
				bswap((u_int8_t*)&th->len, sizeof(th->len));
d853 1
a853 1
				   arg->patch[2], arg->patch[3]);
d859 1
d899 1
a899 1
				   MUTE_CHANNEL, MUTE_CHANNEL);
d904 1
a904 1
				   MUTE_CHANNEL, MUTE_CHANNEL);
d909 1
a909 1
				   MUTE_CHANNEL, MUTE_CHANNEL);
d914 1
a914 1
				   MUTE_CHANNEL, MUTE_CHANNEL);
d919 1
a919 1
				   MUTE_CHANNEL, MUTE_CHANNEL);
d938 1
d953 1
d979 1
a979 1
	u_int8_t hdr[TOC_HEADER_SZ], *toc, *ent, *lent;
d981 1
a981 1
	int i, n, len;
d988 1
d1001 1
d1014 4
a1017 1
	 * Call the generic disklabel extraction routine if we have a data CD
d1021 3
a1023 2
	n = hdr[TOC_HEADER_ENDING_TRACK] - hdr[TOC_HEADER_STARTING_TRACK] + 1;
	len = TOC_HEADER_SZ + n * TOC_ENTRY_SZ;
d1028 57
a1084 12
	if (toc[TOC_HEADER_SZ + TOC_ENTRY_CONTROL_ADDR_TYPE] & 4) {
		strncpy(lp->d_typename, "ATAPI CD-ROM", 16);
		lp->d_partitions[RAW_PART].p_offset = 0;
		lp->d_partitions[RAW_PART].p_size =
		    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
		lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
		lp->d_npartitions = RAW_PART + 1;

		errstring =
		    readdisklabel(MAKECDDEV(0, acd->sc_dev.dv_unit, RAW_PART),
		    acdstrategy, lp, acd->sc_dk.dk_cpulabel);
		if (errstring) {
a1085 35
			goto done;
		}
	} else {
		strncpy(lp->d_typename, "ATAPI audio CD", 16);
		lp->d_npartitions = min(n + 1, MAXPARTITIONS);
		ent = toc + TOC_HEADER_SZ;
		lba =
		    (acd->ad_link->quirks & AQUIRK_LITTLETOC) ?
		    ent[TOC_ENTRY_MSF_LBA] | ent[TOC_ENTRY_MSF_LBA + 1] << 8 :
		    ent[TOC_ENTRY_MSF_LBA] << 8 | ent[TOC_ENTRY_MSF_LBA + 1];
		for (i = 0; i < min(n + 1, MAXPARTITIONS); i++) {
			if (i == RAW_PART) {
				lp->d_partitions[i].p_offset = 0;
				lent = toc + TOC_HEADER_SZ + n * TOC_ENTRY_SZ;
				lp->d_partitions[i].p_size =
				    (acd->ad_link->quirks & AQUIRK_LITTLETOC) ?
				    lent[TOC_ENTRY_MSF_LBA] |
				    lent[TOC_ENTRY_MSF_LBA + 1] << 8 :
				    lent[TOC_ENTRY_MSF_LBA] << 8 |
				    lent[TOC_ENTRY_MSF_LBA + 1];
				lp->d_partitions[i].p_fstype = FS_UNUSED;
			} else {
				lp->d_partitions[i].p_fstype = FS_OTHER;
				ent += TOC_ENTRY_SZ;
				nlba =
				    (acd->ad_link->quirks & AQUIRK_LITTLETOC) ?
				    ent[TOC_ENTRY_MSF_LBA] |
				    ent[TOC_ENTRY_MSF_LBA + 1] << 8 :
				    ent[TOC_ENTRY_MSF_LBA] << 8 |
				    ent[TOC_ENTRY_MSF_LBA + 1];
				lp->d_partitions[i].p_offset = lba;
				lp->d_partitions[i].p_size = nlba - lba;
				lba = nlba;
			}
		}
@


1.19
log
@Audio CDs were read as data CDs before, which broke audio.
This change fixes that and tries to make sane disklabels for audio disks,
however it fails at that, but I think the fix is good enough to go in.
Hopefully the disklabel will be really fixed tomorrow.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.18 1996/12/24 01:33:38 deraadt Exp $	*/
d1010 1
a1010 3
	n = ((acd->ad_link->quirks & AQUIRK_LITTLETOC) ?
	    (hdr[TOC_HEADER_LEN] | hdr[TOC_HEADER_LEN + 1] << 8) :
	    (hdr[TOC_HEADER_LEN] << 8 | hdr[TOC_HEADER_LEN + 1])) + 1;
d1013 2
a1014 2
	if (acd_read_toc (acd, 0, 0, toc, len))
		return;
d1029 1
a1029 1
			return;
d1033 1
a1033 1
		lp->d_npartitions = n + 1;
a1035 1
		    (ent[TOC_ENTRY_CONTROL_ADDR_TYPE] >> 4) == CD_LBA_FORMAT ?
d1038 1
a1038 3
		    ent[TOC_ENTRY_MSF_LBA] << 8 | ent[TOC_ENTRY_MSF_LBA + 1] :
		    msf2lba(ent[TOC_ENTRY_MSF_LBA + 1],
		    ent[TOC_ENTRY_MSF_LBA + 2], ent[TOC_ENTRY_MSF_LBA + 3]);
a1043 2
				    (lent[TOC_ENTRY_CONTROL_ADDR_TYPE] >>
				    4) == CD_LBA_FORMAT ?
d1048 1
a1048 4
				    lent[TOC_ENTRY_MSF_LBA + 1] :
				    msf2lba(lent[TOC_ENTRY_MSF_LBA + 1],
				    lent[TOC_ENTRY_MSF_LBA + 2],
				    lent[TOC_ENTRY_MSF_LBA + 3]);
d1053 1
a1053 2
				nlba = (ent[TOC_ENTRY_CONTROL_ADDR_TYPE] >>
				    4) == CD_LBA_FORMAT ?
d1058 1
a1058 4
				    ent[TOC_ENTRY_MSF_LBA + 1] :
				    msf2lba(ent[TOC_ENTRY_MSF_LBA + 1],
				    ent[TOC_ENTRY_MSF_LBA + 2],
				    ent[TOC_ENTRY_MSF_LBA + 3]);
d1065 3
@


1.18
log
@deal with the 2340 lie in the right place, i think
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.17 1996/12/11 19:08:24 deraadt Exp $	*/
d40 1
a43 1
#include <sys/malloc.h>
d67 10
d973 3
d981 1
d984 1
a993 1
	strncpy(lp->d_typename, "ATAPI CD-ROM", 16);
a1000 6
	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;

d1006 1
a1006 1
	 * Call the generic disklabel extraction routine
d1008 8
a1015 4
	errstring = readdisklabel(MAKECDDEV(0, acd->sc_dev.dv_unit, RAW_PART),
	    acdstrategy, lp, acd->sc_dk.dk_cpulabel);
	if (errstring) {
		printf("%s: %s\n", acd->sc_dev.dv_xname, errstring);
d1017 61
@


1.17
log
@b_resid cleanups, pointed out by minoura@@kw.netlaputa.or.jp in netbsd pr#3007
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.16 1996/12/05 13:12:11 deraadt Exp $	*/
d968 2
a1052 2
	if (acd->params.blksize > 2048)
		acd->params.blksize = 2048;
@


1.16
log
@if block size is > 2048, set it to 2048. atapi drives that lie!
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.14 1996/10/05 07:17:00 downsj Exp $	*/
d592 1
@


1.15
log
@call readdisklabel() in the same fashion as sd.c does
@
text
@d1050 2
@


1.14
log
@[a]cd_play -> [a]cd_play_big.  Say hello to cdio(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.13 1996/09/11 07:22:03 downsj Exp $	*/
d961 1
a965 1
#if 0	/* XXX */
a966 2
#endif
	lp->d_secsize = 2048;
d971 4
a983 4
	lp->d_partitions[0].p_offset = 0;
	lp->d_partitions[0].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
	lp->d_partitions[0].p_fstype = FS_ISO9660;
d987 1
a987 1
	lp->d_partitions[RAW_PART].p_fstype = FS_ISO9660;
d993 10
@


1.13
log
@Remove unneeded quirk, and only print drive capabilities if it appears the
device actually filled in the information.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.12 1996/09/04 22:13:45 niklas Exp $	*/
d756 1
a756 1
		return acd_play(acd, args->blk, args->len);
@


1.12
log
@make GCC 'appier and remove unused vars.  Also fix retval
and a debug printout
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.11 1996/09/04 00:51:13 downsj Exp $	*/
d222 14
a235 11
	printf ("%s: ", self->dv_xname);
	if (cap->cur_speed != cap->max_speed)
		printf ("%d/", cap->cur_speed * 1000 / 1024);
	printf ("%dKb/sec", cap->max_speed * 1000 / 1024);
	if (cap->buf_size)
		printf (", %dKb cache", cap->buf_size);
	if (cap->format_cap & FORMAT_AUDIO_PLAY)
		printf (", audio play");
	if (cap->max_vol_levels)
		printf (", %d volume levels", cap->max_vol_levels);
	printf ("\n");
@


1.11
log
@Pull in pieces of Manuel's patch6:

	- At Milton Ngan's request, wdc now probes for atapi devices first, and
	  then wd drives, because some old atapi devices were detected as ide
  	  drives.
  	- Integration of Milton Ngan's fix for some
	 'wdc_atapi_intr: unknown phase 1' due to a timing problem.

Some additional changes (like ADEV_* -> AQUIRK_*) for the sake of
compatibility.  Manuel's additional quirk type was added as well.

I'm not sure I like the retry change to wdc.c; please let me know if anyone
has any problems with their drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.10 1996/08/09 06:57:58 niklas Exp $	*/
a1003 2
	u_long blksize;
	u_long size;
d1037 3
a1039 2
	ATAPI_DEBUG_PRINT(("acd_size: %ld %ld\n",blksize,size));
	return size;
@


1.10
log
@Pedant mode: avoid mixed signedness comparisons.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.9 1996/08/08 16:52:25 niklas Exp $	*/
a146 1
static __inline void bswap __P((u_int8_t *, int));
d167 1
a167 1
	    ATAPI_DEVICE_TYPE_CD) || (sa->quirks & ADEV_CDROM))
a678 11
static __inline void
bswap (buf, len)
	u_int8_t *buf;
	int len;
{       
	u_int16_t *p = (u_int16_t *)(buf + len);

	while (--p >= (u_int16_t *)buf)
		*p = (*p & 0xff) << 8 | (*p >> 8 & 0xff);
}

d780 1
a780 1
		if (acd->ad_link->quirks & ADEV_LITTLETOC) {
d813 1
a813 1
			if (acd->ad_link->quirks & ADEV_LITTLETOC) {
d821 1
a821 1
		if (acd->ad_link->quirks & ADEV_LITTLETOC) {
d998 2
a999 2
acd_size(cd, flags)
	struct acd_softc *cd;
d1007 11
d1030 1
a1030 1
	if (atapi_exec_cmd(cd->ad_link, &cmd , sizeof(cmd),
d1036 2
a1037 9
	blksize = _4btol((u_int8_t*)&rdcap.blksize);
	if (blksize < 512)
		blksize = 2048;	/* some drives lie ! */
	cd->params.blksize = blksize;

	size = _4btol((u_int8_t*)&rdcap.size);
	if (size < 100)
		size = 400000;	/* ditto */
	cd->params.disksize = size;
@


1.9
log
@Shave some bytes never used
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.8 1996/08/07 01:56:27 downsj Exp $	*/
d774 2
a775 2
		if (len > sizeof(data) ||
		    len < sizeof(struct cd_sub_channel_header))
d811 2
a812 2
		if (len > sizeof(toc.tab) ||
		    len < sizeof(struct cd_toc_entry))
d1302 1
a1302 1
	if (len > sizeof(struct cd_sub_channel_header))
@


1.8
log
@bus.h using ATAPI, by niklas, plus a quirk table and some small fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.7 1996/08/06 22:41:00 downsj Exp $	*/
d142 2
d145 1
d651 3
d671 1
@


1.7
log
@acd.c: Better support for drives that don't set themselves READY at boot;
atapi.h: fix a couple types that I missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.6 1996/07/22 03:35:41 downsj Exp $	*/
d113 1
a113 1
void	acdstart __P((struct acd_softc *));
d117 15
a131 2
int	acddone __P((struct atapi_command_packet *));
int	acd_get_mode __P((struct acd_softc *, struct atapi_mode_data *, int, int, int));
d139 2
a140 1
int	acd_read_subchannel __P((struct acd_softc *, int, int, int, struct cd_sub_channel_info *, int));
d142 3
a144 2
u_long	msf2lba __P((u_char, u_char, u_char ));

a156 1
	struct cfdata *cf = match;
a163 1
	/* XXX!!! */
d165 1
a165 4
	    ATAPI_DEVICE_TYPE_CD) ||
	   (((sa->id.config.device_type & ATAPI_DEVICE_TYPE_MASK) ==
	    ATAPI_DEVICE_TYPE_DAD) &&
	    (sa->id.config.cmd_drq_rem & ATAPI_REMOVABLE)))
d324 1
a324 1
		if (error = atapi_prevent(ad_link, PR_PREVENT))
d517 2
a518 2
acdstart(acd)
	struct acd_softc *acd;
d520 1
d623 2
a624 1
		 if (atapi_exec_io(ad_link, &cmd, sizeof(cmd), bp, A_NOSLEEP))
d626 1
d652 1
a652 1
void
d654 2
a655 2
	u_long lba;
	u_char *m, *s, *f;
d657 1
a657 1
	u_long tmp;
d666 1
a666 1
u_long
d668 1
a668 1
	u_char m, s, f;
d673 11
d721 1
a721 1
		if (error = acdlock(acd))
d771 3
a773 3
		if (error = acd_read_subchannel(acd, args->address_format,
		    				args->data_format, args->track,
						&data, len))
d778 1
d782 2
a783 1
		if (error = acd_read_toc(acd, 0, 0, &hdr, sizeof(hdr)))
d785 6
a790 1
		hdr.len = ntohs(hdr.len);
d795 1
d808 4
a811 3
		if (error = acd_read_toc(acd, te->address_format,
		    			 te->starting_track, &toc,
		    			 len + sizeof(struct ioc_toc_header)))
d818 6
a823 2
			(u_int32_t)(*toc.tab[ntracks].addr.addr) =
				ntohl((u_int32_t)(*toc.tab[ntracks].addr.addr));
d826 6
a831 1
		th->len = ntohs(th->len);
d847 3
a849 2
		if (error = acd_get_mode(acd, &data, ATAPI_AUDIO_PAGE,
					   AUDIOPAGESIZE, 0))
d862 3
a864 2
		if (error = acd_get_mode(acd, &data, ATAPI_AUDIO_PAGE,
					 AUDIOPAGESIZE, 0))
d867 3
a869 2
		if (error = acd_get_mode(acd, &mask, ATAPI_AUDIO_PAGE_MASK,
					 AUDIOPAGESIZE, 0))
d1030 1
a1030 1
	blksize = ntohl(rdcap.blksize);
d1035 1
a1035 1
	size = ntohl(rdcap.size);
d1379 2
a1380 2
acddone(acp)
	struct atapi_command_packet *acp;
d1382 1
@


1.6
log
@Initial integration of pieces of Manuel's patch5.  From the announce:

	- integration of Milton Ngan's patch, which provide audio
	  command support.

..with lots of cleaning up by me.

Audio is still untested.  This will change shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.5 1996/06/10 08:01:06 downsj Exp $	*/
d88 1
d194 2
a195 1
		(void)atapi_test_unit_ready(sa, A_POLLED | A_SILENT);
d283 8
a290 1
	if ((error = atapi_test_unit_ready(ad_link, 0)) != 0) {
@


1.5
log
@* Keep the cappage in the acd_softc.
* If TYPE_DAD, and removable, assume it's a busted CD-ROM.
* Print out some cappage data in attach, and other cosmetic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.4 1996/06/10 00:43:56 downsj Exp $	*/
d58 9
d89 2
a90 1
	struct	cappage cap;		/* drive capabilities */
d117 12
d149 1
d170 1
a170 1
	struct mode_sense cmd;
d190 5
a194 3
	(void)atapi_test_unit_ready(sa, A_POLLED | A_SILENT); 
	delay(1000);
	(void)atapi_test_unit_ready(sa, A_POLLED | A_SILENT);
d196 4
a199 9
	/* To clear media change, etc ...*/
	bzero(&cmd, sizeof(cmd));
	cmd.operation_code = ATAPI_MODE_SENSE;
	cmd.page_code_control = CAP_PAGE;
	_lto2b(sizeof(struct cappage), cmd.length);
	if (atapi_exec_cmd(sa, &cmd , sizeof(cmd), &acd->cap,
	    sizeof(struct cappage), B_READ, A_POLLED) != 0) {
		printf("%s: can't MODE SENSE: atapi_exec_cmd failed\n",
		    self->dv_xname);
d204 1
a204 1
	 * Fix cappage entries in place.
d206 1
a206 4
	acd->cap.max_speed = _2btos((u_int8_t *)&acd->cap.max_speed);
	acd->cap.max_vol_levels = _2btos((u_int8_t *)&acd->cap.max_vol_levels);
	acd->cap.buf_size = _2btos((u_int8_t *)&acd->cap.buf_size);
	acd->cap.cur_speed = _2btos((u_int8_t *)&acd->cap.cur_speed);
a207 3
	/*
	 * Display useful information about the drive (not media!).
	 */
d209 6
a214 6
	if (acd->cap.cur_speed != acd->cap.max_speed)
		printf ("%d/", acd->cap.cur_speed * 1000 / 1024);
	printf ("%dKb/sec", acd->cap.max_speed * 1000 / 1024);
	if (acd->cap.buf_size)
		printf (", %dKb cache", acd->cap.buf_size);
	if (acd->cap.format_cap & FORMAT_AUDIO_PLAY)
d216 2
a217 2
	if (acd->cap.max_vol_levels)
		printf (", %d volume levels", acd->cap.max_vol_levels);
d281 1
a281 1
	if ((error = atapi_test_unit_ready(ad_link,0)) != 0) {
d288 2
a289 1
	if (error = acdlock(acd))
d504 1
a504 1
	struct read cmd;
d516 1
a516 1
		
d592 1
a592 1
		cmd.operation_code = ATAPI_READ;
d627 25
d706 1
a706 3
#ifdef notyet
	case CDIOCPLAYTRACKS:
		{
d708 1
a708 7
		struct acd_mode_data data;
		if (error = acd_get_mode(acd, &data, AUDIO_PAGE))
			return error;
		data.page.audio.flags &= ~CD_PA_SOTC;
		data.page.audio.flags |= CD_PA_IMMED;
		if (error = acd_set_mode(acd, &data))
			return error;
d710 2
a711 1
		    args->start_index, args->end_track, args->end_index);
a712 1
#endif
d714 6
a719 14
#ifdef notyet
	case CDIOCPLAYMSF:
		{
		struct ioc_play_msf *args
		= (struct ioc_play_msf *)addr;
		struct cd_mode_data data;
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
			return error;
		data.page.audio.flags &= ~CD_PA_SOTC;
		data.page.audio.flags |= CD_PA_IMMED;
		if (error = cd_set_mode(cd, &data))
			return error;
		return cd_play_msf(cd, args->start_m, args->start_s,
		    args->start_f, args->end_m, args->end_s, args->end_f);
a720 1
#endif
d722 4
a725 13
#ifdef notyet
	case CDIOCPLAYBLOCKS:
	{
		struct ioc_play_blocks *args
		= (struct ioc_play_blocks *)addr;
		struct cd_mode_data data;
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
			return error;
		data.page.audio.flags &= ~CD_PA_SOTC;
		data.page.audio.flags |= CD_PA_IMMED;
		if (error = cd_set_mode(cd, &data))
			return error;
		return cd_play(cd, args->blk, args->len);
a726 1
#endif
d728 1
a728 3
#ifdef notyet 
	case CDIOCREADSUBCHANNEL:
	{
d730 1
a730 1
		= (struct ioc_read_subchannel *)addr;
d733 1
d737 4
a740 2
		if (error = cd_read_subchannel(cd, args->address_format,
		    args->data_format, args->track, &data, len))
a741 3
		len = min(len, ((data.header.data_len[0] << 8) +
		    data.header.data_len[1] +
		    sizeof(struct cd_sub_channel_header)));
a743 1
#endif
d745 4
a748 5
#ifdef notyet
	case CDIOREADTOCHEADER:
	{
		struct ioc_toc_header th;
		if (error = cd_read_toc(cd, 0, 0, &th, sizeof(th)))
d750 2
a751 2
		th.len = ntohs(th.len);
		bcopy(&th, addr, sizeof(th));
a753 1
#endif
d755 1
a755 7
#ifdef notyet
	case CDIOREADTOCENTRYS:
	{
		struct cd_toc {
			struct ioc_toc_header header;
			struct cd_toc_entry entries[65];
		} data;
d757 3
a759 2
		(struct ioc_read_toc_entry *)addr;
		struct ioc_toc_header *th;
d761 1
a761 1
		th = &data.header;
d763 1
a763 1
		if (len > sizeof(data.entries) ||
d766 4
a769 3
		if (error = cd_read_toc(cd, te->address_format,
		    te->starting_track, (struct cd_toc_entry *)&data,
		    len + sizeof(struct ioc_toc_header)))
d771 13
a783 3
		len = min(len, ntohs(th->len) - (sizeof(th->starting_track) +
		    sizeof(th->ending_track)));
		return copyout(data.entries, te->data, len);
a784 1
#endif
d786 1
a786 3
#ifdef notyet
	case CDIOCSETPATCH:
	{
d788 3
a790 8
		struct cd_mode_data data;
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
			return error;
		data.page.audio.port[LEFT_PORT].channels = arg->patch[0];
		data.page.audio.port[RIGHT_PORT].channels = arg->patch[1];
		data.page.audio.port[2].channels = arg->patch[2];
		data.page.audio.port[3].channels = arg->patch[3];
		return cd_set_mode(cd, &data);
a791 1
#endif
d793 1
a793 3
#ifdef notyet
	case CDIOCGETVOL:
	{
d795 3
a797 2
		struct cd_mode_data data;
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
d799 4
a802 4
		arg->vol[LEFT_PORT] = data.page.audio.port[LEFT_PORT].volume;
		arg->vol[RIGHT_PORT] = data.page.audio.port[RIGHT_PORT].volume;
		arg->vol[2] = data.page.audio.port[2].volume;
		arg->vol[3] = data.page.audio.port[3].volume;
a804 1
#endif
d806 1
a806 3
#ifdef notyet
	case CDIOCSETVOL:
	{
d808 8
a815 2
		struct cd_mode_data data;
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
d817 11
a827 7
		data.page.audio.port[LEFT_PORT].channels = CHANNEL_0;
		data.page.audio.port[LEFT_PORT].volume = arg->vol[LEFT_PORT];
		data.page.audio.port[RIGHT_PORT].channels = CHANNEL_1;
		data.page.audio.port[RIGHT_PORT].volume = arg->vol[RIGHT_PORT];
		data.page.audio.port[2].volume = arg->vol[2];
		data.page.audio.port[3].volume = arg->vol[3];
		return cd_set_mode(cd, &data);
a828 1
#endif
d830 3
a832 14
#ifdef notyet
	case CDIOCSETMONO:
	{
		struct ioc_vol *arg = (struct ioc_vol *)addr;
		struct cd_mode_data data;
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
			return error;
		data.page.audio.port[LEFT_PORT].channels =
		    LEFT_CHANNEL | RIGHT_CHANNEL | 4 | 8;
		data.page.audio.port[RIGHT_PORT].channels =
		    LEFT_CHANNEL | RIGHT_CHANNEL;
		data.page.audio.port[2].channels = 0;
		data.page.audio.port[3].channels = 0;
		return cd_set_mode(cd, &data);
a833 1
#endif
d835 3
a837 12
#ifdef notyet
	case CDIOCSETSTEREO:
	{
		struct ioc_vol *arg = (struct ioc_vol *)addr;
		struct cd_mode_data data;
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
			return error;
		data.page.audio.port[LEFT_PORT].channels = LEFT_CHANNEL;
		data.page.audio.port[RIGHT_PORT].channels = RIGHT_CHANNEL;
		data.page.audio.port[2].channels = 0;
		data.page.audio.port[3].channels = 0;
		return cd_set_mode(cd, &data);
a838 1
#endif
d840 3
a842 12
#ifdef notyet
	case CDIOCSETMUTE:
	{
		struct ioc_vol *arg = (struct ioc_vol *)addr;
		struct cd_mode_data data;
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
			return error;
		data.page.audio.port[LEFT_PORT].channels = 0;
		data.page.audio.port[RIGHT_PORT].channels = 0;
		data.page.audio.port[2].channels = 0;
		data.page.audio.port[3].channels = 0;
		return cd_set_mode(cd, &data);
a843 1
#endif
d845 3
a847 12
#ifdef notyet
	case CDIOCSETLEFT:
	{
		struct ioc_vol *arg = (struct ioc_vol *)addr;
		struct cd_mode_data data;
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
			return error;
		data.page.audio.port[LEFT_PORT].channels = LEFT_CHANNEL;
		data.page.audio.port[RIGHT_PORT].channels = LEFT_CHANNEL;
		data.page.audio.port[2].channels = 0;
		data.page.audio.port[3].channels = 0;
		return cd_set_mode(cd, &data);
a848 1
#endif
d850 3
a852 12
#ifdef notyet
	case CDIOCSETRIGHT:
	{
		struct ioc_vol *arg = (struct ioc_vol *)addr;
		struct cd_mode_data data;
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
			return error;
		data.page.audio.port[LEFT_PORT].channels = RIGHT_CHANNEL;
		data.page.audio.port[RIGHT_PORT].channels = RIGHT_CHANNEL;
		data.page.audio.port[2].channels = 0;
		data.page.audio.port[3].channels = 0;
		return cd_set_mode(cd, &data);
a853 1
#endif
d893 1
a893 1
	panic("cdioctl: impossible");
d953 2
a954 2
	struct read_cd_capacity_data rdcap;
	struct read_cd_capacity cmd;
d963 1
a963 1
	cmd.operation_code = ATAPI_READ_CD_CAPACITY;
a989 1
#ifdef notyet
d994 4
a997 4
cd_get_mode(cd, data, page)
	struct acd_softc *cd;
	struct cd_mode_data *data;
	int page;
d999 1
a999 1
	struct scsi_mode_sense scsi_cmd;
d1002 24
a1025 8
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	bzero(data, sizeof(*data));
	scsi_cmd.opcode = MODE_SENSE;
	scsi_cmd.page = page;
	scsi_cmd.length = sizeof(*data) & 0xff;
	return scsi_scsi_cmd(cd->ad_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)data, sizeof(*data), CDRETRIES, 20000,
	    NULL, SCSI_DATA_IN);
d1032 23
a1054 3
cd_set_mode(cd, data)
	struct acd_softc *cd;
	struct cd_mode_data *data;
d1056 2
a1057 1
	struct scsi_mode_select scsi_cmd;
d1059 10
a1068 8
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SELECT;
	scsi_cmd.byte2 |= SMS_PF;
	scsi_cmd.length = sizeof(*data) & 0xff;
	data->header.data_length = 0;
	return scsi_scsi_cmd(cd->ad_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)data, sizeof(*data), CDRETRIES, 20000,
	    NULL, SCSI_DATA_OUT);
d1072 1
a1072 1
 * Get scsi driver to send a "start playing" command
d1075 2
a1076 2
cd_play(cd, blkno, nblks)
	struct acd_softc *cd;
d1079 1
a1079 1
	struct scsi_play scsi_cmd;
d1081 4
a1084 4
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = PLAY;
	_lto4b(blkno, scsi_cmd.blk_addr);
	_lto2b(nblks, scsi_cmd.xfer_len);
d1086 2
a1087 2
	return scsi_scsi_cmd(cd->ad_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, CDRETRIES, 200000, NULL, 0);
d1091 1
a1091 1
 * Get scsi driver to send a "start playing" command
d1094 2
a1095 2
cd_play_big(cd, blkno, nblks)
	struct acd_softc *cd;
d1098 1
a1098 1
	struct scsi_play_big scsi_cmd;
d1100 4
a1103 4
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = PLAY_BIG;
	_lto4b(blkno, scsi_cmd.blk_addr);
	_lto4b(nblks, scsi_cmd.xfer_len);
d1105 28
a1132 2
	return scsi_scsi_cmd(cd->ad_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, CDRETRIES, 20000, NULL, 0);
d1136 1
a1136 1
 * Get scsi driver to send a "start playing" command
d1139 2
a1140 2
cd_play_tracks(cd, strack, sindex, etrack, eindex)
	struct acd_softc *cd;
d1143 8
a1150 1
	struct scsi_play_track scsi_cmd;
d1152 15
a1166 6
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = PLAY_TRACK;
	scsi_cmd.start_track = strack;
	scsi_cmd.start_index = sindex;
	scsi_cmd.end_track = etrack;
	scsi_cmd.end_index = eindex;
d1168 1
a1168 2
	return scsi_scsi_cmd(cd->ad_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, CDRETRIES, 20000, NULL, 0);
d1172 1
a1172 1
 * Get scsi driver to send a "play msf" command
d1175 2
a1176 2
cd_play_msf(cd, startm, starts, startf, endm, ends, endf)
	struct acd_softc *cd;
d1179 1
a1179 1
	struct scsi_play_msf scsi_cmd;
d1181 8
a1188 8
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = PLAY_MSF;
	scsi_cmd.start_m = startm;
	scsi_cmd.start_s = starts;
	scsi_cmd.start_f = startf;
	scsi_cmd.end_m = endm;
	scsi_cmd.end_s = ends;
	scsi_cmd.end_f = endf;
d1190 2
a1191 2
	return scsi_scsi_cmd(cd->ad_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, CDRETRIES, 2000, NULL, 0);
a1193 2
#endif  /* notyet */

d1202 1
a1202 1
	struct pause_resume cmd;
d1205 1
a1205 1
	cmd.operation_code = ATAPI_PAUSE_RESUME;
a1224 1
#ifdef notyet
d1229 2
a1230 2
cd_read_subchannel(cd, mode, format, track, data, len)
	struct acd_softc *cd;
d1234 3
a1236 1
	struct scsi_read_subchannel scsi_cmd;
d1238 1
a1238 2
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = READ_SUBCHANNEL;
d1240 10
a1249 9
		scsi_cmd.byte2 |= CD_MSF;
	scsi_cmd.byte3 = SRS_SUBQ;
	scsi_cmd.subchan_format = format;
	scsi_cmd.track = track;
	_lto2b(len, scsi_cmd.data_len);

	return scsi_scsi_cmd(cd->ad_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(struct scsi_read_subchannel), (u_char *)data, len,
	    CDRETRIES, 5000, NULL, SCSI_DATA_IN);
d1256 2
a1257 2
cd_read_toc(cd, mode, start, data, len)
	struct acd_softc *cd;
d1259 1
a1259 1
	struct cd_toc_entry *data;
d1261 1
a1261 2
	struct scsi_read_toc scsi_cmd;
	int ntoc;
d1263 1
a1263 8
	bzero(&scsi_cmd, sizeof(scsi_cmd));
#if 0
	if (len != sizeof(struct ioc_toc_header))
		ntoc = ((len) - sizeof(struct ioc_toc_header)) /
		    sizeof(struct cd_toc_entry);
	else
#endif
		ntoc = len;
d1265 1
a1265 1
	scsi_cmd.opcode = READ_TOC;
d1267 7
a1273 7
		scsi_cmd.byte2 |= CD_MSF;
	scsi_cmd.from_track = start;
	_lto2b(ntoc, scsi_cmd.data_len);

	return scsi_scsi_cmd(cd->ad_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(struct scsi_read_toc), (u_char *)data, len, CDRETRIES,
	    5000, NULL, SCSI_DATA_IN);
a1274 2

#endif /* notyet */
@


1.4
log
@Several changes:
	* Implemented NetBSD PR#2529, adding ZIP 100.
	* Added MTIOCTOP support to acd, cd, and sd.
	* Implemented eject on close for acd, cd, and sd.

`mt -f /dev/rcd0d offline' now ejects a mounted {acd|cd|sd} when it is
unmounted.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.3 1996/06/09 18:42:46 downsj Exp $	*/
d80 1
d127 5
a131 2
	if ((sa->id.config.device_type & ATAPI_DEVICE_TYPE_MASK) ==
	    ATAPI_DEVICE_TYPE_CD)
a147 1
	struct cappage cap;
d175 3
a177 3
	_lto2b(sizeof(cap), cmd.length);
	if (atapi_exec_cmd(sa, &cmd , sizeof(cmd), &cap, sizeof(cap),
	    B_READ, A_POLLED) != 0) {
d182 23
@


1.3
log
@Bug fix from Manuel.
@
text
@d1 1
a1 1
/*	$OpenBSD: acd.c,v 1.2 1996/06/09 08:59:46 downsj Exp $	*/
d40 1
d354 6
d883 5
a887 1
	case CDIOCEJECT:
d889 2
a890 1
		return atapi_start_stop(acd->ad_link, SSS_STOP|SSS_LOEJ, 0);
@


1.2
log
@acd.c: Removed some pointless code, cleaned up some more debug statements.
everything: added RCS ids.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d985 1
a985 1
	size = ntohl(size);
@


1.1
log
@Initial support ATAPI CD-ROMs.

Based on Manuel Bouyer's drivers.
@
text
@d1 1
a1 1
/*	$NetBSD: $	*/
d63 6
a143 2
	int print_type = 0;
	char *mtype;
a177 64

	/* Determine media type. */
	switch (cap.medium_type) {
	case MDT_UNKNOWN:
		mtype = "medium type unknown";
		break;

	case MDT_DATA_120:
		mtype = "120mm data disc";
		break;

	case MDT_AUDIO_120:
		mtype = "120mm audio disc";
		break;

	case MDT_COMB_120:
		mtype = "120mm data/audio disc";
		break;

	case MDT_PHOTO_120:
		mtype = "120mm photo disc";
		break;

	case MDT_DATA_80:
		mtype = "80mm data disc";
		break;

	case MDT_AUDIO_80:
		mtype = "80mm audio disc";
		break;

	case MDT_COMB_80:
		mtype = "80mm data/audio disc";
		break;

	case MDT_PHOTO_80:
		mtype = "80mm photo disc";
		break;

	case MDT_NO_DISC:
		mtype = "drive empty";
		break;

	case MDT_DOOR_OPEN:
		mtype = "door open";
		break;

	case MDT_FMT_ERROR:
		mtype = "medium format error";
		break;

	default:
		mtype = "unknown type";
		print_type = 1;
		break;
	}

	/*
	 * Display information about the drive.
	 */
	printf("%s: %s", self->dv_xname, mtype);
	if (print_type)
		printf(" (type 0x%x)", cap.medium_type);
	printf("\n");
d487 2
a488 3
#ifdef ATAPI_DEBUG
			printf("acdstart: waking up\n");
#endif
d976 1
a976 3
#ifdef ATAPI_DEBUG
		printf("ATAPI_READ_CD_CAPACITY failed\n");
#endif
a988 3
#ifdef ATAPI_DEBUG
	printf("acd_size: %ld %ld\n",blksize,size);
#endif
d990 1
@
