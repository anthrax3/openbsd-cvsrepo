head	1.24;
access;
symbols
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	UBC_SYNC_A:1.24
	UBC_SYNC_B:1.24
	SMP:1.24.0.2
	kame_19991208:1.23
	OPENBSD_2_6:1.23.0.2
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.22.0.4
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.22.0.2
	OPENBSD_2_4_BASE:1.22
	OPENBSD_2_3:1.21.0.2
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.18.0.2
	OPENBSD_2_2_BASE:1.18
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11;
locks; strict;
comment	@ * @;


1.24
date	99.12.11.21.22.39;	author csapuntz;	state dead;
branches;
next	1.23;

1.23
date	99.06.05.21.58.14;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.06.09.13.29.58;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	98.01.02.18.22.07;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	97.11.10.15.23.03;	author flipk;	state Exp;
branches;
next	1.19;

1.19
date	97.11.05.01.57.42;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.08.19.19.04.48;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.08.17.22.00.04;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.07.07.19.48.50;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	97.06.24.05.29.54;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.06.15.02.38.01;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	97.06.06.23.43.06;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	96.11.23.21.46.29;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	96.09.12.02.36.10;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.09.11.07.22.04;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.09.06.12.19.10;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.09.04.00.51.13;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.08.09.01.33.57;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.08.07.05.40.47;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.08.07.01.56.28;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.07.22.03.35.42;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.08.01.13;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.06.09.08.59.49;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.06.08.09.12.41;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.24
log
@

Bye-bye to the old ATAPI driver
@
text
@/*	$OpenBSD: atapiconf.c,v 1.23 1999/06/05 21:58:14 deraadt Exp $	*/

/*
 * Copyright (c) 1996 Manuel Bouyer.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Manuel Bouyer.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/proc.h>  

#include <dev/atapi/atapilink.h>
#include <dev/atapi/atapi.h>

#define SILENT_PRINTF(flags,string) if (!(flags & A_SILENT)) printf string

#ifdef ATAPI_DEBUG_CMD
#define ATAPI_DEBUG_CMD_PRINT(args)	printf args
#else
#define ATAPI_DEBUG_CMD_PRINT(args)
#endif

#ifdef ATAPI_DEBUG_FCTN
#define ATAPI_DEBUG_FCTN_PRINT(args)	printf args
#else
#define ATAPI_DEBUG_FCTN_PRINT(args)
#endif

struct atapibus_softc {
	struct	device sc_dev;
	struct	bus_link *b_link;
};

LIST_HEAD(pkt_free_list, atapi_command_packet) pkt_free_list;

int atapi_error __P((struct atapi_command_packet *));
void atapi_sense __P((struct atapi_command_packet *, u_int8_t, u_int8_t));
void at_print_addr __P((struct at_dev_link *, u_int8_t));

int atapibusmatch __P((struct device *, void *, void *));
void atapibusattach __P((struct device *, struct device *, void *));
void atapi_fixquirk __P((struct at_dev_link *));
int atapiprint __P((void *, const char *));

struct cfattach atapibus_ca = {
	sizeof(struct atapibus_softc), atapibusmatch, atapibusattach
};

struct cfdriver atapibus_cd = {
	NULL, "atapibus", DV_DULL
};


/*
 * ATAPI quirk table support.
 */

struct atapi_quirk_inquiry_pattern {
	u_int8_t type;
	u_int8_t rem;
	char *product;
	char *revision;

	u_int8_t quirks;
};

struct atapi_quirk_inquiry_pattern atapi_quirk_inquiry_patterns[] = {
	/* GoldStar 8X */
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "GCD-R580B", "1.00", AQUIRK_LITTLETOC},
	/* MATSHITA CR-574 */
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "MATSHITA CR-574", "1.06", AQUIRK_NOCAPACITY},
	/* NEC Multispin 2Vi */
	{ATAPI_DEVICE_TYPE_DAD, ATAPI_REMOVABLE,
	 "NEC                 CD-ROM DRIVE:260", "3.04", AQUIRK_CDROM},
	/* NEC 273 */
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "NEC                 CD-ROM DRIVE:273", "4.21", AQUIRK_NOTUR},
	/* NEC 4CD changer CDR-C251 */
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "NEC                 CD-ROM DRIVE:251", "4.14", AQUIRK_NOCAPACITY},
	/* Sanyo 4x */
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "SANYO CRD-254P", "1.02", AQUIRK_NOCAPACITY},
	/* Sanyo 4x */
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "SANYO CRD-S54P", "1.08", AQUIRK_NOCAPACITY},
	/* Sanyo 6x */
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "SANYO CRD-256P", "1.02", AQUIRK_NOCAPACITY},
	/* Another Sanyo 4x */
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "CD-ROM  CDR-S1", "1.70",AQUIRK_NOCAPACITY},
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "CD-ROM  CDR-N16", "1.25",AQUIRK_NOCAPACITY},
	/* Acer Notelight 370 */
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "UJDCD8730", "1.14", AQUIRK_NODOORLOCK},
	/* ALPS CD changer */
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "ALPS ELECTRIC CO.,LTD. DC544C", "SW03D", AQUIRK_NOTUR},
	{0, 0, NULL, NULL, 0}
};

int
atapibusmatch(parent, match, aux)
        struct device *parent;
        void *match, *aux;
{
	struct bus_link *ab_link = aux;

	if (ab_link == NULL)
		return 0;
	if (ab_link->type != BUS)
		return 0;
	return 1;
}

void
atapi_fixquirk(ad_link)
	struct at_dev_link *ad_link;
{
	struct atapi_identify *id = &ad_link->id;
	struct atapi_quirk_inquiry_pattern *quirk;

	/*
	 * Shuffle string byte order.
	 * Mitsumi and NEC drives don't need this.
	 */
	if (((id->model[0] == 'N' && id->model[1] == 'E') ||
	    (id->model[0] == 'F' && id->model[1] == 'X')) == 0)
		bswap(id->model, sizeof(id->model));
	bswap(id->serial_number, sizeof(id->serial_number));
	bswap(id->firmware_revision, sizeof(id->firmware_revision));

	/*
	 * Clean up the model name, serial and
	 * revision numbers.
	 */
	btrim(id->model, sizeof(id->model));
	btrim(id->serial_number, sizeof(id->serial_number));
	btrim(id->firmware_revision, sizeof(id->firmware_revision));

#define quirk_null(_q)	((_q->type == 0) && (_q->rem == 0) && \
			 (_q->product == NULL) && (_q->revision == NULL))

	for (quirk = atapi_quirk_inquiry_patterns;
	     !quirk_null(quirk); quirk++) {
		if ((id->config.device_type
		    & ATAPI_DEVICE_TYPE_MASK) != quirk->type)
			continue;
		if ((id->config.cmd_drq_rem & quirk->rem) == 0)
			continue;
		if (strcmp(id->model, quirk->product))
			continue;
		if (strcmp(id->firmware_revision, quirk->revision))
			continue;

		break;
	}

	if (!quirk_null(quirk)) {
		/* Found a quirk entry for this drive. */
		ad_link->quirks = quirk->quirks;
	}
}

int
atapiprint(aux, bus)
	void *aux;
	const char *bus;
{
	struct at_dev_link *ad_link = aux;
	struct atapi_identify *id = &ad_link->id;
	char *dtype, *fixrem;

	/*
	 * Figure out basic device type.
	 */
	switch (id->config.device_type & ATAPI_DEVICE_TYPE_MASK) {
	case ATAPI_DEVICE_TYPE_DAD:
		dtype = "direct";
		break;

	case ATAPI_DEVICE_TYPE_CD:
		dtype = "cdrom";
		break;

	case ATAPI_DEVICE_TYPE_OMD:
		dtype = "optical";
		break;

	default:
		dtype = "unknown";
		break;
	}

	fixrem = (id->config.cmd_drq_rem & ATAPI_REMOVABLE) ?
	    "removable" : "fixed";

	if (bus != NULL)
		printf("%s", bus);

	if (id->serial_number[0]) {
		printf(" drive %d: <%s, %s, %s> ATAPI %d/%s %s",
	    	    ad_link->drive, id->model, id->serial_number,
	    	    id->firmware_revision,
	    	    (id->config.device_type & ATAPI_DEVICE_TYPE_MASK),
		    dtype, fixrem);
	} else {
		printf(" drive %d: <%s, %s> ATAPI %d/%s %s",
	    	    ad_link->drive, id->model, id->firmware_revision,
	    	    (id->config.device_type & ATAPI_DEVICE_TYPE_MASK),
		    dtype, fixrem);
	}

	return UNCONF;
}


void
atapibusattach(parent, self, aux)
        struct device *parent, *self;
        void *aux;
{
	struct atapibus_softc *ab = (struct atapibus_softc *)self;
	struct bus_link *ab_link_proto = aux;
	struct atapi_identify ids;
	struct atapi_identify *id = &ids;
	struct at_dev_link *ad_link;
	int drive;

	printf("\n");

	ab_link_proto->atapibus_softc = (caddr_t)ab;
	ab->b_link = ab_link_proto;

	for (drive = 0; drive < 2 ; drive++) {
		if (wdc_atapi_get_params(ab_link_proto, drive, id)) {
#ifdef ATAPI_DEBUG_PROBE
			printf("%s drive %d: cmdsz 0x%x drqtype 0x%x\n",
			    self->dv_xname, drive,
			    id->config.cmd_drq_rem & ATAPI_PACKET_SIZE_MASK,
			    id->config.cmd_drq_rem & ATAPI_DRQ_MASK);
#endif

			/*
			 * Allocate a device link and try and attach
			 * a driver to this device.  If we fail, free
			 * the link.
			 */
			ad_link = malloc(sizeof(*ad_link), M_DEVBUF, M_NOWAIT);
			if (ad_link == NULL) {
				printf("%s: can't allocate link for drive %d\n",
				    self->dv_xname, drive);
				continue;
			}

			/* Fill in link. */
			ad_link->drive = drive;
			if (id->config.cmd_drq_rem & ATAPI_PACKET_SIZE_16)
				ad_link->flags |= ACAP_LEN;
			ad_link->flags |=
			    (id->config.cmd_drq_rem & ATAPI_DRQ_MASK) << 3;
			ad_link->bus = ab_link_proto;
			bcopy(id, &ad_link->id, sizeof(*id));

			/* Fix strings and look through the quirk table. */
			atapi_fixquirk(ad_link);

			/* Try to find a match. */
			if (config_found(self, ad_link, atapiprint) == NULL)
				free(ad_link, M_DEVBUF);
		}
	}
}

int
atapi_exec_cmd(ad_link, cmd, cmd_size, databuf, datalen, rw, flags)
	struct at_dev_link *ad_link;
	void *cmd;
	int cmd_size;
	void *databuf;
	int datalen;
	int rw;
	int flags;
{
	struct atapi_command_packet *pkt;
	struct bus_link *b_link = ad_link->bus;
	int status, s;

	/* Allocate packet. */
	pkt = atapi_get_pkt(ad_link, flags);
	if (pkt == NULL)
		return -1;

	/* Fill it out. */
	bcopy(cmd, &pkt->cmd_store, cmd_size);
	pkt->command = &pkt->cmd_store;
	pkt->command_size = (ad_link->flags & ACAP_LEN) ? 16 : 12;
	pkt->databuf = databuf;
	pkt->data_size = datalen;
	pkt->flags = rw | (flags & 0xff) | (ad_link->flags & 0x0300);
	pkt->drive = ad_link->drive;

	/* Send it to drive. */
	wdc_atapi_send_command_packet(b_link, pkt);
	if ((flags & (A_POLLED | A_NOSLEEP)) == 0) {
		ATAPI_DEBUG_CMD_PRINT(("atapi_exec_cmd: sleeping\n"));

		s = splbio();
		while ((pkt->status & ITSDONE) == 0)
			tsleep(pkt, PRIBIO + 1,"atapicmd", 0);
		splx(s);

		ATAPI_DEBUG_CMD_PRINT(("atapi_exec_cmd: done sleeping\n"));

		status = pkt->status & STATUS_MASK;
		atapi_free_pkt(pkt);
	} else {
		if ((flags & A_POLLED) != 0) {
			if ((pkt->status & ERROR) && (pkt->error)) {
				atapi_error(pkt);
				SILENT_PRINTF(flags,("\n"));
			}
		}
		status = pkt->status & STATUS_MASK;
		if ((flags & A_POLLED) != 0)
			atapi_free_pkt(pkt);
	}

	if ((pkt->status & ERROR) && (pkt->error))
	     status |= pkt->error << 8;

	return status;
}

int
atapi_exec_io(ad_link, cmd, cmd_size, bp, flags)
	struct at_dev_link *ad_link;
	void *cmd;
	int cmd_size;
	struct buf *bp;
	int flags;
{
	struct atapi_command_packet *pkt;
	struct bus_link *b_link = ad_link->bus;

	/* Allocate a packet. */
	pkt = atapi_get_pkt(ad_link, flags);
	if (pkt == NULL) {
		printf("atapi_exec_io: no pkt\n");
		return ERROR;
	}

	/* Fill it in. */
	bcopy(cmd, &pkt->cmd_store, cmd_size);
	pkt->command = &pkt->cmd_store;
	pkt->command_size = (ad_link->flags & ACAP_LEN) ? 16 : 12;
	pkt->bp = bp;
	pkt->databuf = bp->b_data;
	pkt->data_size = bp->b_bcount;
	pkt->flags = (bp->b_flags & (B_READ|B_WRITE)) | (flags & 0xff) |
	    (ad_link->flags & 0x0300);
	pkt->drive = ad_link->drive;

	wdc_atapi_send_command_packet(b_link, pkt);
	return (pkt->status & STATUS_MASK);
}

void
atapi_done(acp)
	struct atapi_command_packet *acp;
{
	struct at_dev_link *ad_link = acp->ad_link;
	struct buf *bp = acp->bp;
	int error = 0;

	ATAPI_DEBUG_CMD_PRINT(("atapi_done\n"));

	if ((acp->status & ERROR) && (acp->error)) {
		atapi_error(acp);
		if (acp->status & RETRY) {
			if (acp->retries <ATAPI_NRETRIES) {
				acp->retries++;
				acp->status = 0;
				acp->error = 0;
				SILENT_PRINTF(acp->flags & 0xff,
				    (", retry #%d\n", acp->retries));
				wdc_atapi_send_command_packet(ad_link->bus,
				    acp);
				return;
			} else
				acp->status = ERROR;
		}
		SILENT_PRINTF(acp->flags & 0xff,("\n"));
	}
	acp->status |= ITSDONE;

	if (ad_link->done) {
		ATAPI_DEBUG_CMD_PRINT(("calling private done\n"));
		error = (*ad_link->done)(acp);
		if (error == EJUSTRETURN)
			return;
	}
	if (acp->bp == NULL) {
		ATAPI_DEBUG_CMD_PRINT(("atapidone: wakeup acp\n"));
		wakeup(acp);
		return;
	}

	ATAPI_DEBUG_CMD_PRINT(("atapi_done: status %d\n", acp->status));

	switch (acp->status & 0x0f) {
	case MEDIA_CHANGE:
		if (ad_link->flags & ADEV_REMOVABLE)
			ad_link->flags &= ~ADEV_MEDIA_LOADED;

		error = EIO;
		break;

	case NO_ERROR:
		error = 0;
		break;

	case ERROR:
	case END_OF_MEDIA:
	default:
		error = EIO;
		break;
	}

	switch (acp->status & 0xf0) {
	case NOT_READY:
	case UNIT_ATTENTION:
		if (ad_link->flags & ADEV_REMOVABLE)
			ad_link->flags &= ~ADEV_MEDIA_LOADED;

		error = EIO;
		break;
	}

	if (error) {
		bp->b_error = error;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
	} else {
		bp->b_error = 0;
		bp->b_resid = acp->data_size;
	}
	biodone(bp);
	atapi_free_pkt(acp);
}

struct atapi_command_packet *
atapi_get_pkt(ad_link, flags)
	struct at_dev_link *ad_link;
	int flags;
{
	struct atapi_command_packet *pkt;
	int s;

	s = splbio();
	while (ad_link->openings <= 0) {
		if (flags & A_NOSLEEP) {
			splx(s);
			return 0;
		}

		ATAPI_DEBUG_CMD_PRINT(("atapi_get_pkt: sleeping\n"));

		ad_link->flags |= ADEV_WAITING;
		(void)tsleep(ad_link, PRIBIO, "getpkt", 0);
	}

	ad_link->openings--;

	if ((pkt = pkt_free_list.lh_first) != 0) {
		LIST_REMOVE(pkt, free_list);
		splx(s);
	} else {
		splx(s);
		pkt = malloc(sizeof(struct atapi_command_packet), M_DEVBUF,
		    ((flags & A_NOSLEEP) != 0 ? M_NOWAIT : M_WAITOK));
		if (pkt == NULL) {
			printf("atapi_get_pkt: cannot allocate pkt\n");
			ad_link->openings++;
			return 0;
		}
	}

	bzero(pkt, sizeof(struct atapi_command_packet));
	pkt->ad_link = ad_link;
	return pkt;
}

void
atapi_free_pkt(pkt)
	struct atapi_command_packet *pkt;
{
	struct at_dev_link *ad_link = pkt->ad_link;
	int s;

	s = splbio();
	LIST_INSERT_HEAD(&pkt_free_list, pkt, free_list);

	ad_link->openings++;

	if ((ad_link->flags & ADEV_WAITING) != 0) {
		ad_link->flags &= ~ADEV_WAITING;
		wakeup(ad_link);
	} else {
		if (ad_link->start) {
			ATAPI_DEBUG_CMD_PRINT(("atapi_free_pkt: calling private start\n"));
			(*ad_link->start)((void *)ad_link->device_softc);
		}
	}
	splx(s);
}

int
atapi_test_unit_ready(ad_link, flags)
	struct at_dev_link *ad_link;
	int flags;
{	
	int ret;
	struct atapi_test_unit_ready cmd;

	ATAPI_DEBUG_FCTN_PRINT(("atapi_test_unit_ready: "));

	/* Device doesn't support TUR! */
	if (ad_link->quirks & AQUIRK_NOTUR)
		ret = 0;
	else {
		bzero(&cmd, sizeof(cmd));
		cmd.opcode = ATAPI_TEST_UNIT_READY;
		ret = atapi_exec_cmd(ad_link, &cmd, sizeof(cmd), 0, 0, 0,
		    flags);
	}
	ATAPI_DEBUG_FCTN_PRINT(("atapi_test_unit_ready: ret %d\n", ret));
	return ret;
}

int
atapi_start_stop(ad_link, how, flags)
	struct at_dev_link  *ad_link;
	int how;
	int flags;
{
	struct atapi_start_stop_unit cmd;
	int ret;
		
	ATAPI_DEBUG_FCTN_PRINT(("atapi_start_stop: "));

	bzero(&cmd, sizeof(cmd));
	cmd.opcode = ATAPI_START_STOP_UNIT;
	cmd.how = how;

	ret = atapi_exec_cmd(ad_link, &cmd, sizeof(cmd), 0,0,0,flags);

	ATAPI_DEBUG_FCTN_PRINT(("ret %d\n", ret));

	return ret;
}

int
atapi_prevent(ad_link, how)
	struct at_dev_link *ad_link;
	int how;
{
	struct atapi_prevent_allow_medium_removal cmd;
	int ret;

	ATAPI_DEBUG_FCTN_PRINT(("atapi_prevent: "));

	if (ad_link->quirks & AQUIRK_NODOORLOCK) 
	        ret = 0;
	else { 
	        bzero(&cmd, sizeof(cmd));
		cmd.opcode = ATAPI_PREVENT_ALLOW_MEDIUM_REMOVAL;
		cmd.how = how & 0xff;

		ret = atapi_exec_cmd(ad_link, &cmd, sizeof(cmd), 0,0,0,0);
	}
	ATAPI_DEBUG_FCTN_PRINT(("ret %d\n", ret));

	return ret;
}

int 
atapi_error(acp)
	struct atapi_command_packet* acp;
{
	int flags, error, ret = -1;
	struct at_dev_link *ad_link = acp->ad_link;

	flags = acp->flags & 0xff;
	error = acp->error;

	at_print_addr(ad_link, acp->flags & 0xff);

	if (error & ATAPI_MCR) {
		SILENT_PRINTF(flags,("media change requested "));
		acp->status = MEDIA_CHANGE;
	}

	if (error & ATAPI_ABRT) {      
		SILENT_PRINTF(flags,("command aborted "));
		acp->status = ERROR; 
	}

	if (error & ATAPI_EOM) {
		SILENT_PRINTF(flags,("end of media "));
		acp->status = END_OF_MEDIA;
	}

	if (error & ATAPI_ILI) {
		SILENT_PRINTF(flags,("illegal length indication "));
		acp->status = ERROR;
	}

	if ((error & 0x0f) == 0)
		ret = 0;

	atapi_sense(acp, error >> 4, flags);

	if (((flags & A_SILENT) == 0) && (acp->status != NO_ERROR)) {
		int i;
		printf(", command:");
		for (i = 0; i < acp->command_size; i++)
			printf(" %2x", ((u_int8_t *)acp->command)[i]);
	}

	return ret;
}

void
atapi_sense(acp, sense_key, flags)
	struct atapi_command_packet *acp;
	u_int8_t sense_key;
	u_int8_t flags;
{
	struct at_dev_link *ad_link = acp->ad_link;

	switch (sense_key) {
	case ATAPI_SK_NO_SENSE:
		break;

	case ATAPI_SK_REC_ERROR:
		SILENT_PRINTF(flags,("recovered error"));
		acp->status = 0;
		break;

	case ATAPI_SK_NOT_READY:
		SILENT_PRINTF(flags,("not ready"));
		acp->status = NOT_READY;
		break;

	case ATAPI_SK_MEDIUM_ERROR:
		SILENT_PRINTF(flags,("media error"));
		acp->status = ERROR;
		break;

	case ATAPI_SK_HARDWARE_ERROR:
		SILENT_PRINTF(flags,("hardware error"));
		acp->status = ERROR;
		break;

	case ATAPI_SK_ILLEGAL_REQUEST:
		SILENT_PRINTF(flags,("illegal request"));
		acp->status = ERROR;
		break;

	case ATAPI_SK_UNIT_ATTENTION:
		SILENT_PRINTF(flags,("unit attention"));
		acp->status = UNIT_ATTENTION;
		if (ad_link->flags & ADEV_REMOVABLE)
			ad_link->flags &= ~ADEV_MEDIA_LOADED;
		break;

	case ATAPI_SK_DATA_PROTECT:
		SILENT_PRINTF(flags,("data protect"));
		acp->status = ERROR;
		break;

	case ATAPI_SK_ABORTED_COMMAND:
		SILENT_PRINTF(flags,("aborted command"));
		acp->status = RETRY;
		break;

	case ATAPI_SK_MISCOMPARE:
		SILENT_PRINTF(flags,("miscompare"));
		acp->status = ERROR;
		break;

	default:
		SILENT_PRINTF(flags,("unexpected sense key %02x", sense_key));
		acp->status = ERROR;
	}
}

void
at_print_addr(ad_link, flags)
	struct at_dev_link *ad_link; 
	u_int8_t flags;
{

	if (flags & A_SILENT)
		return;

	printf("%s(%s:%d): ", ad_link->device_softc ?
	    ((struct device *)ad_link->device_softc)->dv_xname : "probe",
	    ((struct device *)ad_link->bus->wdc_softc)->dv_xname,
	    ad_link->drive);
}
@


1.23
log
@say media error instead of medium error
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.22 1998/06/09 13:29:58 provos Exp $	*/
@


1.22
log
@Autodetect ATAPI CDROMS which do not support the ATAPI_READ_CD_CAPACITY
and fake it (meaning add AQUIRK_NOCAPACITY).
Also add an entry for NEC CD Changer reported by W. Scholten
<wouters@@cistron.nl>.
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.21 1998/01/02 18:22:07 provos Exp $	*/
d689 1
a689 1
		SILENT_PRINTF(flags,("medium error"));
@


1.21
log
@add NOCAPACITY quirk for a sanyo? cdrom, reported by ian@@darwinsys.com
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.20 1997/11/10 15:23:03 flipk Exp $	*/
d108 3
d360 3
@


1.20
log
@yet another Sanyo quirk
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.19 1997/11/05 01:57:42 deraadt Exp $	*/
d120 2
@


1.19
log
@another Sanyo quirk; nihilis@@physical.addiction.com; PR#343
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.18 1997/08/19 19:04:48 deraadt Exp $	*/
d117 3
@


1.18
log
@SANYO CRD-254P has AQUIRK_NOCAPACITY
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.17 1997/08/17 22:00:04 millert Exp $	*/
d111 3
@


1.17
log
@Add quirk for MATSHITA CR-574, from Berndt Josef Wulf <wulf@@ping.net.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.16 1997/07/07 19:48:50 niklas Exp $	*/
d108 3
@


1.16
log
@Get rid of the arch-dependent long type
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.15 1997/06/24 05:29:54 downsj Exp $	*/
d99 3
@


1.15
log
@Add AQUIRK_TUR, from manuel.
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.14 1997/06/15 02:38:01 downsj Exp $	*/
d297 1
a297 1
	long rw;
@


1.14
log
@Automatically decide whether or not to disable door locks.  Idea from provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.13 1997/06/06 23:43:06 provos Exp $	*/
d96 1
d98 2
a99 2
	 "GCD-R580B", "1.00", AQUIRK_LITTLETOC},/* GoldStar 8X */

d102 7
a108 1
						/* NEC Multispin 2Vi */
d111 4
a114 3
						/* Acer Notelight 370 */

	{0, 0, NULL, NULL, 0}			/* The End */
d540 9
a548 5
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = ATAPI_TEST_UNIT_READY;

	ret = atapi_exec_cmd(ad_link, &cmd, sizeof(cmd), 0, 0, 0, flags);

a549 1

@


1.13
log
@not all atapi cdroms can lock the door. todo: autodetect
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.12 1996/11/23 21:46:29 kstailey Exp $	*/
d103 2
a104 1
	 "UJDCD8730", "1.14", AQUIRK_NODOORLOCK}, /* Acer Notelight 370 */
@


1.12
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.11 1996/09/12 02:36:10 downsj Exp $	*/
d102 2
d573 6
a578 5
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = ATAPI_PREVENT_ALLOW_MEDIUM_REMOVAL;
	cmd.how = how & 0xff;

	ret = atapi_exec_cmd(ad_link, &cmd, sizeof(cmd), 0,0,0,0);
d580 2
@


1.11
log
@Add some spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.10 1996/09/11 07:22:04 downsj Exp $	*/
d71 1
a71 1
int atapiprint __P((void *, char *));
d172 1
a172 1
	char *bus;
@


1.10
log
@Remove unneeded quirk, and only print drive capabilities if it appears the
device actually filled in the information.
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.9 1996/09/06 12:19:10 mickey Exp $	*/
d595 1
a595 1
		SILENT_PRINTF(flags,("media change requested"));
d600 1
a600 1
		SILENT_PRINTF(flags,("command aborted"));
d605 1
a605 1
		SILENT_PRINTF(flags,("end of media"));
d610 1
a610 1
		SILENT_PRINTF(flags,("illegal length indication"));
@


1.9
log
@add my cd-rom to quirk table.... no other changes.
hmmm, how BSDi do handle all this quirks w/o 'em ?
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.8 1996/09/04 00:51:13 downsj Exp $	*/
a101 2
	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	"NEC                 CD-ROM DRIVE:273", "4.21", AQUIRK_TIMING},
@


1.8
log
@Pull in pieces of Manuel's patch6:

	- At Milton Ngan's request, wdc now probes for atapi devices first, and
	  then wd drives, because some old atapi devices were detected as ide
  	  drives.
  	- Integration of Milton Ngan's fix for some
	 'wdc_atapi_intr: unknown phase 1' due to a timing problem.

Some additional changes (like ADEV_* -> AQUIRK_*) for the sake of
compatibility.  Manuel's additional quirk type was added as well.

I'm not sure I like the retry change to wdc.c; please let me know if anyone
has any problems with their drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.7 1996/08/09 01:33:57 niklas Exp $	*/
d102 2
@


1.7
log
@Quirks for NEC 2Vi.  I just had this play audio to me on the Amiga!
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.6 1996/08/07 05:40:47 downsj Exp $	*/
a63 3
static __inline void bswap __P((char *, int));
static __inline void btrim __P((char *, int));

d97 1
a97 1
	 "GCD-R580B", "1.00", ADEV_LITTLETOC},	/* GoldStar 8X */
d100 1
a100 1
	 "NEC                 CD-ROM DRIVE:260", "3.04", ADEV_CDROM},
a276 27
}

static __inline void
bswap (buf, len)
	char *buf;
	int len;
{       
	u_int16_t *p = (u_int16_t *)(buf + len);

	while (--p >= (u_int16_t *)buf)
		*p = (*p & 0xff) << 8 | (*p >> 8 & 0xff);
}

static __inline void
btrim (buf, len)
	char *buf;
	int len;
{
	char *p; 

	/* Remove the trailing spaces. */
	for (p = buf; p < buf + len; ++p)
		if (*p == '\0')
			*p = ' ';

	for (p = buf + len - 1; p >= buf && *p == ' '; --p)
		*p = '\0';
@


1.6
log
@It's silly to try and do the quirks table ala SCSI at this point; do it
my way, instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.5 1996/08/07 01:56:28 downsj Exp $	*/
d101 4
@


1.5
log
@bus.h using ATAPI, by niklas, plus a quirk table and some small fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.4 1996/07/22 03:35:42 downsj Exp $	*/
d90 5
a94 6
	struct {
		u_int8_t type;
		u_int8_t rem;
		char *product;
		char *revision;
	} pattern;
d99 4
a102 2
	{{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
	 "GCD-R580B", "1.00"}, ADEV_LITTLETOC},
d124 1
a124 2
	struct atapi_quirk_inquiry_pattern *finger;
	int quirk, nquirks;
d144 2
a145 4
	nquirks = sizeof(atapi_quirk_inquiry_patterns) /
		    sizeof(struct atapi_quirk_inquiry_pattern);
	for (quirk = 0; quirk < nquirks; quirk++) {
		finger = &atapi_quirk_inquiry_patterns[quirk];
d147 2
d150 1
a150 1
		    & ATAPI_DEVICE_TYPE_MASK) != finger->pattern.type)
d152 1
a152 1
		if ((id->config.cmd_drq_rem & finger->pattern.rem) == 0)
d154 1
a154 1
		if (strcmp(id->model, finger->pattern.product))
d156 1
a156 1
		if (strcmp(id->firmware_revision, finger->pattern.revision))
d162 1
a162 1
	if (quirk < nquirks) {
d164 1
a164 1
		ad_link->quirks = finger->quirks;
@


1.4
log
@Initial integration of pieces of Manuel's patch5.  From the announce:

	- integration of Milton Ngan's patch, which provide audio
	  command support.

..with lots of cleaning up by me.

Audio is still untested.  This will change shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.3 1996/06/10 08:01:13 downsj Exp $	*/
d64 2
a65 2
static void bswap __P((char *, int));
static void btrim __P((char *, int));
d73 2
d85 19
a108 1
	struct cfdata *cf = match;
d118 50
a200 24
	/*
	 * Shuffle string byte order.
	 * Mitsumi and NEC drives don't need this.
	 */
	if (((id->model[0] == 'N' && id->model[1] == 'E') ||
	    (id->model[0] == 'F' && id->model[1] == 'X')) == 0)
		bswap(id->model, sizeof(id->model));

	/*
	 * XXX Poorly named... These appear to actually be in
	 * XXX network byte order, so bswap() is a no-op on
	 * XXX big-endian hosts.  Clean me up, please.
	 */
	bswap(id->serial_number, sizeof(id->serial_number));
	bswap(id->firmware_revision, sizeof(id->firmware_revision));

	/*
	 * Clean up the model name, serial and
	 * revision numbers.
	 */
	btrim(id->model, sizeof(id->model));
	btrim(id->serial_number, sizeof(id->serial_number));
	btrim(id->firmware_revision, sizeof(id->firmware_revision));

d204 12
a215 4
	printf(" drive %d: <%s, %s, %s> ATAPI %d/%s %s",
	    ad_link->drive, id->model, id->serial_number,
	    id->firmware_revision,
	    id->config.device_type & ATAPI_DEVICE_TYPE_MASK, dtype, fixrem);
d268 3
d278 1
a278 1
static void
d286 2
a287 2
		*p = ntohs(*p);
}   
d289 1
a289 1
static void
d387 1
a387 1
	pkt->flags = bp->b_flags & (B_READ|B_WRITE) | (flags & 0xff) |
@


1.3
log
@* Keep the cappage in the acd_softc.
* If TYPE_DAD, and removable, assume it's a busted CD-ROM.
* Print out some cappage data in attach, and other cosmetic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: atapiconf.c,v 1.2 1996/06/09 08:59:49 downsj Exp $	*/
d494 1
a494 1
	struct test_unit_ready cmd;
d499 1
a499 1
	cmd.operation_code = ATAPI_TEST_UNIT_READY;
d514 1
a514 1
	struct start_stop_unit cmd;
d520 1
a520 1
	cmd.operation_code = ATAPI_START_STOP_UNIT;
d535 1
a535 1
	struct prevent_allow_medium_removal cmd;
d541 1
a541 1
	cmd.operation_code = ATAPI_PREVENT_ALLOW_MEDIUM_REMOVAL;
@


1.2
log
@acd.c: Removed some pointless code, cleaned up some more debug statements.
everything: added RCS ids.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 1
a158 1
	printf(" drive %d: <%s, %s, %s> type %d/%s %s",
@


1.1
log
@Initial support ATAPI CD-ROMs.

Based on Manuel Bouyer's drivers.
@
text
@d1 1
a1 1
/*	$NetBSD: $	*/
@
