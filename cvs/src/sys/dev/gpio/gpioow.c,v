head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.28
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.26
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.22
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.12
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.20
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.18
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.16
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.14
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.10
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.8
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.10
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.8
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.24.12.12.12;	author mbalmer;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.04.16.27.03;	author grange;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@/*	$OpenBSD: gpioow.c,v 1.4 2009/10/13 19:33:16 pirofti Exp $	*/

/*
 * Copyright (c) 2006 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * 1-Wire bus bit-banging through GPIO pin.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/gpio.h>

#include <dev/gpio/gpiovar.h>

#include <dev/onewire/onewirevar.h>

#define GPIOOW_NPINS		1
#define GPIOOW_PIN_DATA		0

struct gpioow_softc {
	struct device		sc_dev;

	void *			sc_gpio;
	struct gpio_pinmap	sc_map;
	int			__map[GPIOOW_NPINS];

	struct onewire_bus	sc_ow_bus;
	struct device *		sc_ow_dev;

	int			sc_data;
	int			sc_dying;
};

int	gpioow_match(struct device *, void *, void *);
void	gpioow_attach(struct device *, struct device *, void *);
int	gpioow_detach(struct device *, int);
int	gpioow_activate(struct device *, int);

int	gpioow_ow_reset(void *);
int	gpioow_ow_bit(void *, int);

void	gpioow_bb_rx(void *);
void	gpioow_bb_tx(void *);
int	gpioow_bb_get(void *);
void	gpioow_bb_set(void *, int);

struct cfattach gpioow_ca = {
	sizeof(struct gpioow_softc),
	gpioow_match,
	gpioow_attach,
	gpioow_detach,
	gpioow_activate
};

struct cfdriver gpioow_cd = {
	NULL, "gpioow", DV_DULL
};

static const struct onewire_bbops gpioow_bbops = {
	gpioow_bb_rx,
	gpioow_bb_tx,
	gpioow_bb_get,
	gpioow_bb_set
};

int
gpioow_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct gpio_attach_args *ga = aux;

	if (ga->ga_offset == -1)
		return 0;

	return (strcmp(cf->cf_driver->cd_name, "gpioow") == 0);
}

void
gpioow_attach(struct device *parent, struct device *self, void *aux)
{
	struct gpioow_softc *sc = (struct gpioow_softc *)self;
	struct gpio_attach_args *ga = aux;
	struct onewirebus_attach_args oba;
	int caps;

	/* Check that we have enough pins */
	if (gpio_npins(ga->ga_mask) != GPIOOW_NPINS) {
		printf(": invalid pin mask\n");
		return;
	}

	/* Map pins */
	sc->sc_gpio = ga->ga_gpio;
	sc->sc_map.pm_map = sc->__map;
	if (gpio_pin_map(sc->sc_gpio, ga->ga_offset, ga->ga_mask,
	    &sc->sc_map)) {
		printf(": can't map pins\n");
		return;
	}

	/* Configure data pin */
	caps = gpio_pin_caps(sc->sc_gpio, &sc->sc_map, GPIOOW_PIN_DATA);
	if (!(caps & GPIO_PIN_OUTPUT)) {
		printf(": data pin is unable to drive output\n");
		goto fail;
	}
	if (!(caps & GPIO_PIN_INPUT)) {
		printf(": data pin is unable to read input\n");
		goto fail;
	}
	printf(": DATA[%d]", sc->sc_map.pm_map[GPIOOW_PIN_DATA]);
	sc->sc_data = GPIO_PIN_OUTPUT;
	if (caps & GPIO_PIN_OPENDRAIN) {
		printf(" open-drain");
		sc->sc_data |= GPIO_PIN_OPENDRAIN;
	} else if ((caps & GPIO_PIN_PUSHPULL) && (caps & GPIO_PIN_TRISTATE)) {
		printf(" push-pull tri-state");
		sc->sc_data |= GPIO_PIN_PUSHPULL;
	}
	if (caps & GPIO_PIN_PULLUP) {
		printf(" pull-up");
		sc->sc_data |= GPIO_PIN_PULLUP;
	}
	gpio_pin_ctl(sc->sc_gpio, &sc->sc_map, GPIOOW_PIN_DATA, sc->sc_data);

	printf("\n");

	/* Attach 1-Wire bus */
	sc->sc_ow_bus.bus_cookie = sc;
	sc->sc_ow_bus.bus_reset = gpioow_ow_reset;
	sc->sc_ow_bus.bus_bit = gpioow_ow_bit;

	bzero(&oba, sizeof(oba));
	oba.oba_bus = &sc->sc_ow_bus;
	sc->sc_ow_dev = config_found(self, &oba, onewirebus_print);

	return;

fail:
	gpio_pin_unmap(sc->sc_gpio, &sc->sc_map);
}

int
gpioow_detach(struct device *self, int flags)
{
	struct gpioow_softc *sc = (struct gpioow_softc *)self;
	int rv = 0;

	gpio_pin_unmap(sc->sc_gpio, &sc->sc_map);

	if (sc->sc_ow_dev != NULL)
		rv = config_detach(sc->sc_ow_dev, flags);

	return (rv);
}

int
gpioow_activate(struct device *self, int act)
{
	struct gpioow_softc *sc = (struct gpioow_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		if (sc->sc_ow_dev != NULL)
			rv = config_deactivate(sc->sc_ow_dev);
		break;
	}

	return (rv);
}

int
gpioow_ow_reset(void *arg)
{
	return (onewire_bb_reset(&gpioow_bbops, arg));
}

int
gpioow_ow_bit(void *arg, int value)
{
	return (onewire_bb_bit(&gpioow_bbops, arg, value));
}

void
gpioow_bb_rx(void *arg)
{
	struct gpioow_softc *sc = arg;
	int data = sc->sc_data;

	data &= ~(GPIO_PIN_INPUT | GPIO_PIN_OUTPUT | GPIO_PIN_TRISTATE);
	data |= GPIO_PIN_INPUT;
	if (data & GPIO_PIN_PUSHPULL)
		data |= GPIO_PIN_TRISTATE;
	if (sc->sc_data != data) {
		sc->sc_data = data;
		gpio_pin_ctl(sc->sc_gpio, &sc->sc_map, GPIOOW_PIN_DATA,
		    sc->sc_data);
	}
}

void
gpioow_bb_tx(void *arg)
{
	struct gpioow_softc *sc = arg;
	int data = sc->sc_data;

	data &= ~(GPIO_PIN_INPUT | GPIO_PIN_OUTPUT | GPIO_PIN_TRISTATE);
	data |= GPIO_PIN_OUTPUT;
	if (sc->sc_data != data) {
		sc->sc_data = data;
		gpio_pin_ctl(sc->sc_gpio, &sc->sc_map, GPIOOW_PIN_DATA,
		    sc->sc_data);
	}
}

int
gpioow_bb_get(void *arg)
{
	struct gpioow_softc *sc = arg;

	return (gpio_pin_read(sc->sc_gpio, &sc->sc_map, GPIOOW_PIN_DATA) ==
	    GPIO_PIN_HIGH ? 1 : 0);
}

void
gpioow_bb_set(void *arg, int value)
{
	struct gpioow_softc *sc = arg;

	gpio_pin_write(sc->sc_gpio, &sc->sc_map, GPIOOW_PIN_DATA,
	    value ? GPIO_PIN_HIGH : GPIO_PIN_LOW);
}
@


1.4
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioow.c,v 1.3 2008/11/24 12:12:12 mbalmer Exp $	*/
a178 2
	case DVACT_ACTIVATE:
		break;
@


1.3
log
@- Add two new ioctls to gpio(4), GPIOATTACH and GPIODETACH, to allow to attach
and detach devices on a gpiobus at runtime.  The offset and mask locators
in kernel config files can still be used for static configuration, so this
does not break existing custome kernel configs.

- Have gpioow(4) unmap the pins it used from the gpiobus during detach

Changes to gpioctl(8) will be a separate committ.

ok uwe
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioow.c,v 1.2 2006/06/23 06:27:11 miod Exp $	*/
d52 1
a52 1
int	gpioow_activate(struct device *, enum devact);
d173 1
a173 1
gpioow_activate(struct device *self, enum devact act)
@


1.2
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioow.c,v 1.1 2006/03/04 16:27:03 grange Exp $	*/
d85 4
d163 2
@


1.1
log
@Dallas 1-Wire bus support. Includes the following drivers:

gpioow(4)	1-Wire bus bit-banging through GPIO pin
onewire(4)	1-Wire bus driver
owid(4)		1-Wire ID family type device
owtemp(4)	1-Wire temperature family type device

Drivers for RS-232 and USB bus masters will follow.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d174 1
a174 1
		return (EOPNOTSUPP);
@

