head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.2
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.14.0.8
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.6
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.12
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.8
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.6
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.15
date	2017.08.18.12.15.35;	author jsg;	state Exp;
branches;
next	1.14;
commitid	vmTwjjqEc71e47c8;

1.14
date	2015.08.27.05.48.40;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	ULvUaha3BSapxTpg;

1.13
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.12;
commitid	I19imNlAX05zJOED;

1.12
date	2011.10.03.20.24.51;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.29.11.04.56;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.26.15.04.42;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.26.14.51.20;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.24.12.12.12;	author mbalmer;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.26.18.48.17;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.14.12.33.49;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.05.11.52.24;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.23.21.18.37;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.22.15.37.42;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.15.17.47.52;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.03.18.08.00;	author grange;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.12.38;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Test for device_lookup() returning NULL in gpioioctl() and gpioclose().
Coverity CIDs 1453046, 1453184.
@
text
@/*	$OpenBSD: gpio.c,v 1.14 2015/08/27 05:48:40 deraadt Exp $	*/

/*
 * Copyright (c) 2008 Marc Balmer <mbalmer@@openbsd.org>
 * Copyright (c) 2004, 2006 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * General Purpose Input/Output framework.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/gpio.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/queue.h>

#include <dev/gpio/gpiovar.h>

struct gpio_softc {
	struct device sc_dev;

	gpio_chipset_tag_t		 sc_gc;		/* GPIO controller */
	gpio_pin_t			*sc_pins;	/* pins array */
	int				 sc_npins;	/* number of pins */

	int sc_opened;
	LIST_HEAD(, gpio_dev)		 sc_devs;	/* devices */
	LIST_HEAD(, gpio_name) 	 	 sc_names;	/* named pins */
};

int	gpio_match(struct device *, void *, void *);
int	gpio_submatch(struct device *, void *, void *);
void	gpio_attach(struct device *, struct device *, void *);
int	gpio_detach(struct device *, int);
int	gpio_search(struct device *, void *, void *);
int	gpio_print(void *, const char *);
int	gpio_pinbyname(struct gpio_softc *, char *gp_name);

struct cfattach gpio_ca = {
	sizeof (struct gpio_softc),
	gpio_match,
	gpio_attach,
	gpio_detach
};

struct cfdriver gpio_cd = {
	NULL, "gpio", DV_DULL
};

int
gpio_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct gpiobus_attach_args *gba = aux;

	return (strcmp(gba->gba_name, cf->cf_driver->cd_name) == 0);
}

int
gpio_submatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct gpio_attach_args *ga = aux;

	if (strcmp(ga->ga_dvname, cf->cf_driver->cd_name) != 0)
		return (0);

	return ((*cf->cf_attach->ca_match)(parent, match, aux));
}

void
gpio_attach(struct device *parent, struct device *self, void *aux)
{
	struct gpio_softc *sc = (struct gpio_softc *)self;
	struct gpiobus_attach_args *gba = aux;

	sc->sc_gc = gba->gba_gc;
	sc->sc_pins = gba->gba_pins;
	sc->sc_npins = gba->gba_npins;

	printf(": %d pins\n", sc->sc_npins);

	/*
	 * Attach all devices that can be connected to the GPIO pins
	 * described in the kernel configuration file.
	 */
	config_search(gpio_search, self, sc);
}

int
gpio_detach(struct device *self, int flags)
{
	int maj, mn;

	/* Locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == gpioopen)
			break;

	/* Nuke the vnodes for any open instances (calls close) */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	return (0);
}

int
gpio_search(struct device *parent, void *arg, void *aux)
{
	struct cfdata *cf = arg;
	struct gpio_attach_args ga;

	ga.ga_gpio = aux;
	ga.ga_offset = cf->cf_loc[0];
	ga.ga_mask = cf->cf_loc[1];
	ga.ga_flags = cf->cf_loc[2];

	if (cf->cf_attach->ca_match(parent, cf, &ga) > 0)
		config_attach(parent, cf, &ga, gpio_print);

	return (0);
}

int
gpio_print(void *aux, const char *pnp)
{
	struct gpio_attach_args *ga = aux;
	int i;

	printf(" pins");
	for (i = 0; i < 32; i++)
		if (ga->ga_mask & (1 << i))
			printf(" %d", ga->ga_offset + i);

	return (UNCONF);
}

int
gpiobus_print(void *aux, const char *pnp)
{
	struct gpiobus_attach_args *gba = aux;

	if (pnp != NULL)
		printf("%s at %s", gba->gba_name, pnp);

	return (UNCONF);
}

int
gpio_pin_map(void *gpio, int offset, u_int32_t mask, struct gpio_pinmap *map)
{
	struct gpio_softc *sc = gpio;
	int npins, pin, i;

	npins = gpio_npins(mask);
	if (npins > sc->sc_npins)
		return (1);

	for (npins = 0, i = 0; i < 32; i++)
		if (mask & (1 << i)) {
			pin = offset + i;
			if (pin < 0 || pin >= sc->sc_npins)
				return (1);
			if (sc->sc_pins[pin].pin_mapped)
				return (1);
			sc->sc_pins[pin].pin_mapped = 1;
			map->pm_map[npins++] = pin;
		}
	map->pm_size = npins;

	return (0);
}

void
gpio_pin_unmap(void *gpio, struct gpio_pinmap *map)
{
	struct gpio_softc *sc = gpio;
	int pin, i;

	for (i = 0; i < map->pm_size; i++) {
		pin = map->pm_map[i];
		sc->sc_pins[pin].pin_mapped = 0;
	}
}

int
gpio_pin_read(void *gpio, struct gpio_pinmap *map, int pin)
{
	struct gpio_softc *sc = gpio;

	return (gpiobus_pin_read(sc->sc_gc, map->pm_map[pin]));
}

void
gpio_pin_write(void *gpio, struct gpio_pinmap *map, int pin, int value)
{
	struct gpio_softc *sc = gpio;

	return (gpiobus_pin_write(sc->sc_gc, map->pm_map[pin], value));
}

void
gpio_pin_ctl(void *gpio, struct gpio_pinmap *map, int pin, int flags)
{
	struct gpio_softc *sc = gpio;

	return (gpiobus_pin_ctl(sc->sc_gc, map->pm_map[pin], flags));
}

int
gpio_pin_caps(void *gpio, struct gpio_pinmap *map, int pin)
{
	struct gpio_softc *sc = gpio;

	return (sc->sc_pins[map->pm_map[pin]].pin_caps);
}

int
gpio_npins(u_int32_t mask)
{
	int npins, i;

	for (npins = 0, i = 0; i < 32; i++)
		if (mask & (1 << i))
			npins++;

	return (npins);
}

int
gpioopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct gpio_softc *sc;

	sc = (struct gpio_softc *)device_lookup(&gpio_cd, minor(dev));
	if (sc == NULL)
		return (ENXIO);

	if (sc->sc_opened)
		return (EBUSY);
	sc->sc_opened = 1;

	return (0);
}

int
gpioclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct gpio_softc *sc;

	sc = (struct gpio_softc *)device_lookup(&gpio_cd, minor(dev));
	if (sc == NULL)
		return (ENXIO);

	sc->sc_opened = 0;

	return (0);
}

int
gpio_pinbyname(struct gpio_softc *sc, char *gp_name)
{
	struct gpio_name *nm;

	LIST_FOREACH(nm, &sc->sc_names, gp_next)
		if (!strcmp(nm->gp_name, gp_name))
			return (nm->gp_pin);
	return (-1);
}

int
gpioioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct gpio_softc *sc;
	gpio_chipset_tag_t gc;
	struct gpio_info *info;
	struct gpio_pin_op *op;
	struct gpio_attach *attach;
	struct gpio_attach_args ga;
	struct gpio_dev *gdev;
	struct gpio_name *nm;
	struct gpio_pin_set *set;
	struct device *dv;
	int pin, value, flags, npins, found;

	sc = (struct gpio_softc *)device_lookup(&gpio_cd, minor(dev));
	if (sc == NULL)
		return (ENXIO);

	gc = sc->sc_gc;

	switch (cmd) {
	case GPIOINFO:
		info = (struct gpio_info *)data;
		if (securelevel < 1)
			info->gpio_npins = sc->sc_npins;
		else {
			for (pin = npins = 0; pin < sc->sc_npins; pin++)
				if (sc->sc_pins[pin].pin_flags & GPIO_PIN_SET)
					++npins;
			info->gpio_npins = npins;
		}
		break;
	case GPIOPINREAD:
		op = (struct gpio_pin_op *)data;

		if (op->gp_name[0] != '\0') {
			pin = gpio_pinbyname(sc, op->gp_name);
			if (pin == -1)
				return (EINVAL);
		} else
			pin = op->gp_pin;

		if (pin < 0 || pin >= sc->sc_npins)
			return (EINVAL);

		if (!(sc->sc_pins[pin].pin_flags & GPIO_PIN_SET) &&
		    securelevel > 0)
			return (EPERM);

		/* return read value */
		op->gp_value = gpiobus_pin_read(gc, pin);
		break;
	case GPIOPINWRITE:
		if ((flag & FWRITE) == 0)
			return (EBADF);

		op = (struct gpio_pin_op *)data;

		if (op->gp_name[0] != '\0') {
			pin = gpio_pinbyname(sc, op->gp_name);
			if (pin == -1)
				return (EINVAL);
		} else
			pin = op->gp_pin;

		if (pin < 0 || pin >= sc->sc_npins)
			return (EINVAL);

		if (sc->sc_pins[pin].pin_mapped)
			return (EBUSY);

		if (!(sc->sc_pins[pin].pin_flags & GPIO_PIN_SET) &&
		    securelevel > 0)
			return (EPERM);

		value = op->gp_value;
		if (value != GPIO_PIN_LOW && value != GPIO_PIN_HIGH)
			return (EINVAL);

		gpiobus_pin_write(gc, pin, value);
		/* return old value */
		op->gp_value = sc->sc_pins[pin].pin_state;
		/* update current value */
		sc->sc_pins[pin].pin_state = value;
		break;
	case GPIOPINTOGGLE:
		if ((flag & FWRITE) == 0)
			return (EBADF);

		op = (struct gpio_pin_op *)data;

		if (op->gp_name[0] != '\0') {
			pin = gpio_pinbyname(sc, op->gp_name);
			if (pin == -1)
				return (EINVAL);
		} else
			pin = op->gp_pin;

		if (pin < 0 || pin >= sc->sc_npins)
			return (EINVAL);

		if (sc->sc_pins[pin].pin_mapped)
			return (EBUSY);

		if (!(sc->sc_pins[pin].pin_flags & GPIO_PIN_SET) &&
		    securelevel > 0)
			return (EPERM);

		value = (sc->sc_pins[pin].pin_state == GPIO_PIN_LOW ?
		    GPIO_PIN_HIGH : GPIO_PIN_LOW);
		gpiobus_pin_write(gc, pin, value);
		/* return old value */
		op->gp_value = sc->sc_pins[pin].pin_state;
		/* update current value */
		sc->sc_pins[pin].pin_state = value;
		break;
	case GPIOATTACH:
		if (securelevel > 0)
			return (EPERM);

		attach = (struct gpio_attach *)data;
		bzero(&ga, sizeof(ga));
		ga.ga_gpio = sc;
		ga.ga_dvname = attach->ga_dvname;
		ga.ga_offset = attach->ga_offset;
		ga.ga_mask = attach->ga_mask;
		ga.ga_flags = attach->ga_flags;
		dv = config_found_sm((struct device *)sc, &ga, gpiobus_print,
		    gpio_submatch);
		if (dv != NULL) {
			gdev = malloc(sizeof(*gdev), M_DEVBUF,
			    M_WAITOK);
			gdev->sc_dev = dv;
			LIST_INSERT_HEAD(&sc->sc_devs, gdev, sc_next);
		}
		break;
	case GPIODETACH:
		if (securelevel > 0)
			return (EPERM);

		attach = (struct gpio_attach *)data;
		LIST_FOREACH(gdev, &sc->sc_devs, sc_next) {
			if (strcmp(gdev->sc_dev->dv_xname, attach->ga_dvname)
			    == 0) {
				if (config_detach(gdev->sc_dev, 0) == 0) {
					LIST_REMOVE(gdev, sc_next);
					free(gdev, M_DEVBUF, sizeof(*gdev));
				}
				break;
			}
		}
		break;
	case GPIOPINSET:
		if (securelevel > 0)
			return (EPERM);

		set = (struct gpio_pin_set *)data;

		if (set->gp_name[0] != '\0') {
			pin = gpio_pinbyname(sc, set->gp_name);
			if (pin == -1)
				return (EINVAL);
		} else
			pin = set->gp_pin;
		if (pin < 0 || pin >= sc->sc_npins)
			return (EINVAL);
		flags = set->gp_flags;
		/* check that the controller supports all requested flags */
		if ((flags & sc->sc_pins[pin].pin_caps) != flags)
			return (ENODEV);
		flags = set->gp_flags | GPIO_PIN_SET;

		set->gp_caps = sc->sc_pins[pin].pin_caps;
		/* return old value */
		set->gp_flags = sc->sc_pins[pin].pin_flags;
		if (flags > 0) {
			gpiobus_pin_ctl(gc, pin, flags);
			/* update current value */
			sc->sc_pins[pin].pin_flags = flags;
		}

		/* rename pin or new pin? */
		if (set->gp_name2[0] != '\0') {
			found = 0;
			LIST_FOREACH(nm, &sc->sc_names, gp_next)
				if (nm->gp_pin == pin) {
					strlcpy(nm->gp_name, set->gp_name2,
					    sizeof(nm->gp_name));
					found = 1;
					break;
				}
			if (!found) {
				nm = malloc(sizeof(*nm), M_DEVBUF, M_WAITOK);
				strlcpy(nm->gp_name, set->gp_name2,
				    sizeof(nm->gp_name));
				nm->gp_pin = set->gp_pin;
				LIST_INSERT_HEAD(&sc->sc_names, nm, gp_next);
			}
		}
		break;
	case GPIOPINUNSET:
		if (securelevel > 0)
			return (EPERM);

		set = (struct gpio_pin_set *)data;
		if (set->gp_name[0] != '\0') {
			pin = gpio_pinbyname(sc, set->gp_name);
			if (pin == -1)
				return (EINVAL);
		} else
			pin = set->gp_pin;
		
		if (pin < 0 || pin >= sc->sc_npins)
			return (EINVAL);
		if (sc->sc_pins[pin].pin_mapped)
			return (EBUSY);
		if (!(sc->sc_pins[pin].pin_flags & GPIO_PIN_SET))
			return (EINVAL);

		LIST_FOREACH(nm, &sc->sc_names, gp_next) {
			if (nm->gp_pin == pin) {
				LIST_REMOVE(nm, gp_next);
				free(nm, M_DEVBUF, sizeof(*nm));
				break;
			}
		}
		sc->sc_pins[pin].pin_flags &= ~GPIO_PIN_SET;
		break;
	default:
		return (ENOTTY);
	}

	return (0);
}
@


1.14
log
@simple sizes for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.13 2014/07/12 18:48:17 tedu Exp $	*/
d270 3
d305 3
@


1.13
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.12 2011/10/03 20:24:51 matthieu Exp $	*/
d414 1
a414 1
			gdev = malloc(sizeof(struct gpio_dev), M_DEVBUF,
d430 1
a430 1
					free(gdev, M_DEVBUF, 0);
d476 1
a476 2
				nm = malloc(sizeof(struct gpio_name),
				    M_DEVBUF, M_WAITOK);
d506 1
a506 1
				free(nm, M_DEVBUF, 0);
@


1.12
log
@Add a 'flag' locator to gpioiic(4), and define a first flag
value to swap the SDA and SCL pins assigment during attach.
Mostly from work with mbalmer@@NetBSD.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.11 2009/08/29 11:04:56 miod Exp $	*/
d430 1
a430 1
					free(gdev, M_DEVBUF);
d507 1
a507 1
				free(nm, M_DEVBUF);
@


1.11
log
@submatch functions used with config_found_sm() are required to invoke the
driver's ca_match function. (only offender in the whole tree)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.10 2008/11/26 15:04:42 mbalmer Exp $	*/
d134 1
d410 1
@


1.10
log
@Add my copyright here, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.9 2008/11/26 14:51:20 mbalmer Exp $	*/
d83 4
a86 1
	return (strcmp(ga->ga_dvname, cf->cf_driver->cd_name) == 0);
@


1.9
log
@Change the semantics of gpio(4) devices by locking down pin
configuration and device attachment/detachment to securelevel 0.

GPIO pins can now only be configured at securelevel 0.  Once the
securelevel is raised, only pins that have been configured and set
for securelevel access using the GPIOPINSET ioctl are accessible.
This also adds the possibility to give GPIO pins a name.

ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.8 2008/11/24 12:12:12 mbalmer Exp $	*/
d4 1
@


1.8
log
@- Add two new ioctls to gpio(4), GPIOATTACH and GPIODETACH, to allow to attach
and detach devices on a gpiobus at runtime.  The offset and mask locators
in kernel config files can still be used for static configuration, so this
does not break existing custome kernel configs.

- Have gpioow(4) unmap the pins it used from the gpiobus during detach

Changes to gpioctl(8) will be a separate committ.

ok uwe
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.7 2006/03/26 18:48:17 grange Exp $	*/
d39 3
a41 3
	gpio_chipset_tag_t sc_gc;	/* our GPIO controller */
	gpio_pin_t *sc_pins;		/* pins array */
	int sc_npins;			/* total number of pins */
d44 2
a45 1
	LIST_HEAD(, gpio_dev) sc_list;
d54 1
d271 11
a287 1
	struct gpio_pin_ctl *ctl;
d291 2
d294 1
a294 1
	int pin, value, flags;
d302 8
a309 2

		info->gpio_npins = sc->sc_npins;
d314 7
a320 1
		pin = op->gp_pin;
d324 4
d337 7
a343 1
		pin = op->gp_pin;
d346 1
d350 4
d370 7
a376 1
		pin = op->gp_pin;
d379 1
d383 4
d395 3
a397 11
	case GPIOPINCTL:
		if ((flag & FWRITE) == 0)
			return (EBADF);

		ctl = (struct gpio_pin_ctl *)data;

		pin = ctl->gp_pin;
		if (pin < 0 || pin >= sc->sc_npins)
			return (EINVAL);
		if (sc->sc_pins[pin].pin_mapped)
			return (EBUSY);
a398 15
		flags = ctl->gp_flags;
		/* check that the controller supports all requested flags */
		if ((flags & sc->sc_pins[pin].pin_caps) != flags)
			return (ENODEV);

		ctl->gp_caps = sc->sc_pins[pin].pin_caps;
		/* return old value */
		ctl->gp_flags = sc->sc_pins[pin].pin_flags;
		if (flags > 0) {
			gpiobus_pin_ctl(gc, pin, flags);
			/* update current value */
			sc->sc_pins[pin].pin_flags = flags;
		}
		break;
	case GPIOATTACH:
d411 1
a411 1
			LIST_INSERT_HEAD(&sc->sc_list, gdev, sc_next);
d415 3
d419 1
a419 1
		LIST_FOREACH(gdev, &sc->sc_list, sc_next) {
d429 77
@


1.7
log
@Don't allow to change gpio pin state if /dev/gpio was opened
in read-only mode. Spotted by form@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.6 2006/01/14 12:33:49 grange Exp $	*/
d31 2
d44 1
d48 1
d71 8
a78 2
	if (strcmp(gba->gba_name, cf->cf_driver->cd_name) != 0)
		return (0);
d80 1
a80 1
	return (1);
d276 4
d367 29
@


1.6
log
@Add gpio_pin_caps() method to provide pin capabilities.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.5 2006/01/05 11:52:24 grange Exp $	*/
d27 1
d288 3
d310 3
d330 3
@


1.5
log
@Finish framework for attaching kernel drivers to the GPIO pins.
Not used yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.4 2004/11/23 21:18:37 grange Exp $	*/
d208 8
@


1.4
log
@Let gpio_detach() do something useful.
Tested by reyk@@ on gpio@@ath.
@
text
@d1 2
a2 1
/*	$OpenBSD: gpio.c,v 1.3 2004/11/22 15:37:42 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004 Alexander Yurchenko <grange@@openbsd.org>
d88 1
a88 1
	config_search(gpio_search, self, NULL);
d114 2
a115 1
	ga.ga_pin = cf->cf_loc[0];
d133 1
a133 1
			printf(" %d", ga->ga_pin + i);
d150 73
d284 2
d303 2
d320 2
@


1.3
log
@added detach function to support hotpluggable gpios.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.2 2004/09/15 17:47:52 grange Exp $	*/
d28 1
d91 1
a91 1
gpio_detach(struct device *parent, int flags)
d93 11
@


1.2
log
@Tweak in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpio.c,v 1.1 2004/06/03 18:08:00 grange Exp $	*/
d43 1
d50 2
a51 1
	gpio_attach
d87 6
@


1.1
log
@A framework for supporting various General Purpose Input/Output (GPIO)
devices. Such devices provide a set of pins that you can use to connect
for example leds to it.
The pins can be accessed either from userland through the /dev/gpio*
device files or from the kernel drivers. The latter is necessary
for implementing timing-sensitive things like i2c or 1-wire master
controller.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 1
a19 1
 * General Purpose I/O framework.
@


1.1.2.1
log
@Merge with the trunk
@
text
@@

