head	1.42;
access;
symbols
	OPENBSD_6_1:1.42.0.4
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.28.0.4
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.18
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.16
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.14
	OPENBSD_5_0:1.23.0.12
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.10
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.8
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.7.0.2
	UBC_BASE:1.7
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.42
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.41;
commitid	VyLWTsbepAOk7VQM;

1.41
date	2016.04.13.11.36.00;	author mpi;	state Exp;
branches;
next	1.40;
commitid	nHRUtEnkD6rbEjY0;

1.40
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.39;
commitid	J9apD0jq2AjFmqZc;

1.39
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.38;
commitid	f4dx5ry1aOiKJw33;

1.38
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.37;
commitid	B0kwmVGiD5DVx4kv;

1.37
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.36;
commitid	5gdEnqVoJuTuwdTu;

1.36
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.35;
commitid	5DvsamK0GblTp8ww;

1.35
date	2015.10.25.13.13.06;	author mpi;	state Exp;
branches;
next	1.34;
commitid	SaArro4mM2Ab3ure;

1.34
date	2015.09.12.10.15.10;	author miod;	state Exp;
branches;
next	1.33;
commitid	7nT32okhwAwISbr0;

1.33
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.32;
commitid	6vhYvh5CxZAHMnsN;

1.32
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.31;
commitid	9ERVupAoYqW4Iok9;

1.31
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.30;
commitid	MVWrtktB46JRxFWT;

1.30
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.29;
commitid	hN5bFCE56DrAjl99;

1.29
date	2015.04.07.14.59.06;	author mpi;	state Exp;
branches;
next	1.28;
commitid	KvW3QlPLT9mb40b7;

1.28
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.27;
commitid	yM2VFFhpDTeFQlve;

1.27
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.26;
commitid	nYggAidK85QbUFh2;

1.26
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2013.08.07.01.06.40;	author bluhm;	state Exp;
branches;
next	1.24;

1.24
date	2013.05.28.09.46.06;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.02.20.00.56;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.25.22.41.46;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.08.17.03.01;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.15.05.24.12;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.27.01.50.52;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.27.01.36.53;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.24.21.54.38;	author henric;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.18.32.41;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.28.19.47.54;	author jason;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.11.28.16.52.44;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.28.05.42.24;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.27.02.33.15;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.12.19.48.11;	author jason;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.08.31.15.12.05;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.20.22.47.08;	author jason;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.12.05.00.43.31;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.06.07.11.02.32;	author ho;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.02.19.10.56.32;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.06.05.23.12.57;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.22.14.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.42
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: be.c,v 1.41 2016/04/13 11:36:00 mpi Exp $	*/
/*	$NetBSD: be.c,v 1.26 2001/03/20 15:39:20 pk Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1998 Theo de Raadt and Jason L. Wright.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>

#include <dev/sbus/sbusvar.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/sbus/qecreg.h>
#include <dev/sbus/qecvar.h>
#include <dev/sbus/bereg.h>

struct be_softc {
	struct	device	sc_dev;
	bus_space_tag_t	sc_bustag;	/* bus & dma tags */
	bus_dma_tag_t	sc_dmatag;
	bus_dmamap_t	sc_dmamap;
	struct	arpcom sc_arpcom;
	/*struct	ifmedia sc_ifmedia;	-* interface media */
	struct mii_data	sc_mii;		/* MII media control */
#define sc_media	sc_mii.mii_media/* shorthand */
	int		sc_phys[2];	/* MII instance -> phy */

	struct timeout sc_tick_ch;

	/*
	 * Some `mii_softc' items we need to emulate MII operation
	 * for our internal transceiver.
	 */
	int		sc_mii_inst;	/* instance of internal phy */
	uint64_t	sc_mii_active;	/* currently active medium */
	int		sc_mii_ticks;	/* tick counter */
	int		sc_mii_flags;	/* phy status flags */
#define MIIF_HAVELINK	0x04000000
	int		sc_intphy_curspeed;	/* Established link speed */

	struct	qec_softc *sc_qec;	/* QEC parent */

	bus_space_handle_t	sc_qr;	/* QEC registers */
	bus_space_handle_t	sc_br;	/* BE registers */
	bus_space_handle_t	sc_cr;	/* channel registers */
	bus_space_handle_t	sc_tr;	/* transceiver registers */

	u_int	sc_rev;

	int	sc_channel;		/* channel number */
	int	sc_burst;

	struct  qec_ring	sc_rb;	/* Packet Ring Buffer */
};

int	bematch(struct device *, void *, void *);
void	beattach(struct device *, struct device *, void *);

void	beinit(struct be_softc *);
void	bestart(struct ifnet *);
void	bestop(struct be_softc *);
void	bewatchdog(struct ifnet *);
int	beioctl(struct ifnet *, u_long, caddr_t);
void	bereset(struct be_softc *);

int	beintr(void *);
int	berint(struct be_softc *);
int	betint(struct be_softc *);
int	beqint(struct be_softc *, u_int32_t);
int	beeint(struct be_softc *, u_int32_t);

static void	be_read(struct be_softc *, int, int);
static int	be_put(struct be_softc *, int, struct mbuf *);
static struct mbuf *be_get(struct be_softc *, int, int);

void	be_pal_gate(struct be_softc *, int);

/* ifmedia callbacks */
void	be_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int	be_ifmedia_upd(struct ifnet *);

void	be_mcreset(struct be_softc *);

/* MII methods & callbacks */
static int	be_mii_readreg(struct device *, int, int);
static void	be_mii_writereg(struct device *, int, int, int);
static void	be_mii_statchg(struct device *);

/* MII helpers */
static void	be_mii_sync(struct be_softc *);
static void	be_mii_sendbits(struct be_softc *, int, u_int32_t, int);
static int	be_mii_reset(struct be_softc *, int);
static int	be_tcvr_read_bit(struct be_softc *, int);
static void	be_tcvr_write_bit(struct be_softc *, int, int);

void	be_tick(void *);
void	be_intphy_auto(struct be_softc *);
void	be_intphy_status(struct be_softc *);
int	be_intphy_service(struct be_softc *, struct mii_data *, int);


struct cfattach be_ca = {
	sizeof(struct be_softc), bematch, beattach
};

struct cfdriver be_cd = {
	NULL, "be", DV_IFNET
};

int
bematch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct sbus_attach_args *sa = aux;

	return (strcmp(cf->cf_driver->cd_name, sa->sa_name) == 0);
}

void
beattach(struct device *parent, struct device *self, void *aux)
{
	struct sbus_attach_args *sa = aux;
	struct qec_softc *qec = (struct qec_softc *)parent;
	struct be_softc *sc = (struct be_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mii_data *mii = &sc->sc_mii;
	struct mii_softc *child;
	int node = sa->sa_node;
	bus_dma_tag_t dmatag = sa->sa_dmatag;
	bus_dma_segment_t seg;
	bus_size_t size;
	uint64_t instance;
	int rseg, error;
	u_int32_t v;
	extern void myetheraddr(u_char *);

	/* Pass on the bus tags */
	sc->sc_bustag = sa->sa_bustag;
	sc->sc_dmatag = sa->sa_dmatag;

	if (sa->sa_nreg < 3) {
		printf("%s: only %d register sets\n",
		    self->dv_xname, sa->sa_nreg);
		return;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    (bus_addr_t)sa->sa_reg[0].sbr_offset,
	    (bus_size_t)sa->sa_reg[0].sbr_size, 0, 0, &sc->sc_cr) != 0) {
		printf("beattach: cannot map registers\n");
		return;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[1].sbr_slot,
	    (bus_addr_t)sa->sa_reg[1].sbr_offset,
	    (bus_size_t)sa->sa_reg[1].sbr_size, 0, 0, &sc->sc_br) != 0) {
		printf("beattach: cannot map registers\n");
		return;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[2].sbr_slot,
	    (bus_addr_t)sa->sa_reg[2].sbr_offset,
	    (bus_size_t)sa->sa_reg[2].sbr_size, 0, 0, &sc->sc_tr) != 0) {
		printf("beattach: cannot map registers\n");
		return;
	}

	sc->sc_qec = qec;
	sc->sc_qr = qec->sc_regs;

	sc->sc_rev = getpropint(node, "board-version", -1);
	printf(" rev %x", sc->sc_rev);

	bestop(sc);

	sc->sc_channel = getpropint(node, "channel#", -1);
	if (sc->sc_channel == -1)
		sc->sc_channel = 0;

	sc->sc_burst = getpropint(node, "burst-sizes", -1);
	if (sc->sc_burst == -1)
		sc->sc_burst = qec->sc_burst;

	/* Clamp at parent's burst sizes */
	sc->sc_burst &= qec->sc_burst;

	/* Establish interrupt handler */
	if (sa->sa_nintr == 0 || bus_intr_establish(sa->sa_bustag, sa->sa_pri,
	    IPL_NET, 0, beintr, sc, self->dv_xname) == NULL) {
		printf(": no interrupt established\n");
		return;
	}

	myetheraddr(sc->sc_arpcom.ac_enaddr);
	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	/*
	 * Allocate descriptor ring and buffers.
	 */

	/* for now, allocate as many bufs as there are ring descriptors */
	sc->sc_rb.rb_ntbuf = QEC_XD_RING_MAXSIZE;
	sc->sc_rb.rb_nrbuf = QEC_XD_RING_MAXSIZE;

	size =	QEC_XD_RING_MAXSIZE * sizeof(struct qec_xd) +
		QEC_XD_RING_MAXSIZE * sizeof(struct qec_xd) +
		sc->sc_rb.rb_ntbuf * BE_PKT_BUF_SZ +
		sc->sc_rb.rb_nrbuf * BE_PKT_BUF_SZ;

	/* Get a DMA handle */
	if ((error = bus_dmamap_create(dmatag, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
		printf("%s: DMA map create error %d\n", self->dv_xname, error);
		return;
	}

	/* Allocate DMA buffer */
	if ((error = bus_dmamem_alloc(sa->sa_dmatag, size, 0, 0,
	    &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: DMA buffer alloc error %d\n",
			self->dv_xname, error);
		return;
	}

	/* Map DMA memory in CPU addressable space */
	if ((error = bus_dmamem_map(sa->sa_dmatag, &seg, rseg, size,
	    &sc->sc_rb.rb_membase, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: DMA buffer map error %d\n",
			self->dv_xname, error);
		bus_dmamem_free(sa->sa_dmatag, &seg, rseg);
		return;
	}

	/* Load the buffer */
	if ((error = bus_dmamap_load(dmatag, sc->sc_dmamap,
	    sc->sc_rb.rb_membase, size, NULL, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: DMA buffer map load error %d\n",
		    self->dv_xname, error);
		bus_dmamem_unmap(dmatag, sc->sc_rb.rb_membase, size);
		bus_dmamem_free(dmatag, &seg, rseg);
		return;
	}
	sc->sc_rb.rb_dmabase = sc->sc_dmamap->dm_segs[0].ds_addr;

	/*
	 * Initialize our media structures and MII info.
	 */
	mii->mii_ifp = ifp;
	mii->mii_readreg = be_mii_readreg;
	mii->mii_writereg = be_mii_writereg;
	mii->mii_statchg = be_mii_statchg;

	ifmedia_init(&mii->mii_media, 0, be_ifmedia_upd, be_ifmedia_sts);

	timeout_set(&sc->sc_tick_ch, be_tick, sc);

	/*
	 * Initialize transceiver and determine which PHY connection to use.
	 */
	be_mii_sync(sc);
	v = bus_space_read_4(sc->sc_bustag, sc->sc_tr, BE_TRI_MGMTPAL);

	instance = 0;

	if ((v & MGMT_PAL_EXT_MDIO) != 0) {

		mii_attach(&sc->sc_dev, mii, 0xffffffff, BE_PHY_EXTERNAL,
		    MII_OFFSET_ANY, 0);

		child = LIST_FIRST(&mii->mii_phys);
		if (child == NULL) {
			/* No PHY attached */
			ifmedia_add(&sc->sc_media,
			    IFM_MAKEWORD(IFM_ETHER,IFM_NONE,0,instance),
			    0, NULL);
			ifmedia_set(&sc->sc_media,
			    IFM_MAKEWORD(IFM_ETHER,IFM_NONE,0,instance));
		} else {
			/*
			 * Note: we support just one PHY on the external
			 * MII connector.
			 */
#ifdef DIAGNOSTIC
			if (LIST_NEXT(child, mii_list) != NULL) {
				printf("%s: spurious MII device %s attached\n",
				    sc->sc_dev.dv_xname,
				    child->mii_dev.dv_xname);
			}
#endif
			if (child->mii_phy != BE_PHY_EXTERNAL ||
			    child->mii_inst > 0) {
				printf("%s: cannot accommodate MII device %s"
				    " at phy %d, instance %lld\n",
				    sc->sc_dev.dv_xname,
				    child->mii_dev.dv_xname,
				    child->mii_phy, child->mii_inst);
			} else {
				sc->sc_phys[instance] = child->mii_phy;
			}

			/*
			 * XXX - we can really do the following ONLY if the
			 * phy indeed has the auto negotiation capability!!
			 */
			ifmedia_set(&sc->sc_media,
			    IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,instance));

			/* Mark our current media setting */
			be_pal_gate(sc, BE_PHY_EXTERNAL);
			instance++;
		}

	}

	if ((v & MGMT_PAL_INT_MDIO) != 0) {
		/*
		 * The be internal phy looks vaguely like MII hardware,
		 * but not enough to be able to use the MII device
		 * layer. Hence, we have to take care of media selection
		 * ourselves.
		 */

		sc->sc_mii_inst = instance;
		sc->sc_phys[instance] = BE_PHY_INTERNAL;

		/* Use `ifm_data' to store BMCR bits */
		ifmedia_add(&sc->sc_media,
		    IFM_MAKEWORD(IFM_ETHER,IFM_10_T,0,instance), 0, NULL);
		ifmedia_add(&sc->sc_media,
		    IFM_MAKEWORD(IFM_ETHER,IFM_100_TX,0,instance),
		    BMCR_S100, NULL);
		ifmedia_add(&sc->sc_media,
		    IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,instance), 0, NULL);

		printf("on-board transceiver at %s: 10baseT, 100baseTX, auto\n",
		    self->dv_xname);

		be_mii_reset(sc, BE_PHY_INTERNAL);
		/* Only set default medium here if there's no external PHY */
		if (instance == 0) {
			be_pal_gate(sc, BE_PHY_INTERNAL);
			ifmedia_set(&sc->sc_media,
			    IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,instance));
		} else
			be_mii_writereg((void *)sc,
			    BE_PHY_INTERNAL, MII_BMCR, BMCR_ISO);
	}

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = bestart;
	ifp->if_ioctl = beioctl;
	ifp->if_watchdog = bewatchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);
}


/*
 * Routine to copy from mbuf chain to transmit buffer in
 * network buffer memory.
 */
static __inline__ int
be_put(struct be_softc *sc, int idx, struct mbuf *m)
{
	struct mbuf *n;
	int len, tlen = 0, boff = 0;
	caddr_t bp;

	bp = sc->sc_rb.rb_txbuf + (idx % sc->sc_rb.rb_ntbuf) * BE_PKT_BUF_SZ;

	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			n = m_free(m);
			continue;
		}
		bcopy(mtod(m, caddr_t), bp+boff, len);
		boff += len;
		tlen += len;
		n = m_free(m);
	}
	return (tlen);
}

/*
 * Pull data off an interface.
 * Len is the length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present,
 * we copy into clusters.
 */
static __inline__ struct mbuf *
be_get(struct be_softc *sc, int idx, int totlen)
{
	struct mbuf *m;
	struct mbuf *top, **mp;
	int len, pad, boff = 0;
	caddr_t bp;

	bp = sc->sc_rb.rb_rxbuf + (idx % sc->sc_rb.rb_nrbuf) * BE_PKT_BUF_SZ;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);
	m->m_pkthdr.len = totlen;

	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	m->m_data += pad;
	len = MHLEN - pad;
	top = NULL;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return (NULL);
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(bp + boff, mtod(m, caddr_t), len);
		boff += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}

/*
 * Pass a packet to the higher levels.
 */
static __inline__ void
be_read(struct be_softc *sc, int idx, int len)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    len > ETHERMTU + sizeof(struct ether_header)) {

		printf("%s: invalid packet size %d; dropping\n",
		    ifp->if_xname, len);

		ifp->if_ierrors++;
		return;
	}

	/*
	 * Pull packet off interface.
	 */
	m = be_get(sc, idx, len);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

/*
 * Start output on interface.
 * We make two assumptions here:
 *  1) that the current priority is set to splnet _before_ this code
 *     is called *and* is returned to the appropriate priority after
 *     return
 *  2) that the IFF_OACTIVE flag is checked before this code is called
 *     (i.e. that the output part of the interface is idle)
 */
void
bestart(struct ifnet *ifp)
{
	struct be_softc *sc = (struct be_softc *)ifp->if_softc;
	struct qec_xd *txd = sc->sc_rb.rb_txd;
	struct mbuf *m;
	unsigned int bix, len;
	unsigned int ntbuf = sc->sc_rb.rb_ntbuf;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	bix = sc->sc_rb.rb_tdhead;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		len = be_put(sc, bix, m);

		/*
		 * Initialize transmit registers and start transmission
		 */
		txd[bix].xd_flags = QEC_XD_OWN | QEC_XD_SOP | QEC_XD_EOP |
				    (len & QEC_XD_LENGTH);
		bus_space_write_4(sc->sc_bustag, sc->sc_cr, BE_CRI_CTRL,
				  BE_CR_CTRL_TWAKEUP);

		if (++bix == QEC_XD_RING_MAXSIZE)
			bix = 0;

		if (++sc->sc_rb.rb_td_nbusy == ntbuf) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
	}

	sc->sc_rb.rb_tdhead = bix;
}

void
bestop(struct be_softc *sc)
{
	int n;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t br = sc->sc_br;

	timeout_del(&sc->sc_tick_ch);

	/* Down the MII. */
	mii_down(&sc->sc_mii);
	(void)be_intphy_service(sc, &sc->sc_mii, MII_DOWN);

	/* Stop the transmitter */
	bus_space_write_4(t, br, BE_BRI_TXCFG, 0);
	for (n = 32; n > 0; n--) {
		if (bus_space_read_4(t, br, BE_BRI_TXCFG) == 0)
			break;
		DELAY(20);
	}

	/* Stop the receiver */
	bus_space_write_4(t, br, BE_BRI_RXCFG, 0);
	for (n = 32; n > 0; n--) {
		if (bus_space_read_4(t, br, BE_BRI_RXCFG) == 0)
			break;
		DELAY(20);
	}
}

/*
 * Reset interface.
 */
void
bereset(struct be_softc *sc)
{
	int s;

	s = splnet();
	bestop(sc);
	if ((sc->sc_arpcom.ac_if.if_flags & IFF_UP) != 0)
		beinit(sc);
	splx(s);
}

void
bewatchdog(struct ifnet *ifp)
{
	struct be_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;
	bereset(sc);
}

int
beintr(void *v)
{
	struct be_softc *sc = (struct be_softc *)v;
	bus_space_tag_t t = sc->sc_bustag;
	u_int32_t whyq, whyb, whyc;
	int r = 0;

	/* Read QEC status, channel status and BE status */
	whyq = bus_space_read_4(t, sc->sc_qr, QEC_QRI_STAT);
	whyc = bus_space_read_4(t, sc->sc_cr, BE_CRI_STAT);
	whyb = bus_space_read_4(t, sc->sc_br, BE_BRI_STAT);

	if (whyq & QEC_STAT_BM)
		r |= beeint(sc, whyb);

	if (whyq & QEC_STAT_ER)
		r |= beqint(sc, whyc);

	if (whyq & QEC_STAT_TX && whyc & BE_CR_STAT_TXIRQ)
		r |= betint(sc);

	if (whyq & QEC_STAT_RX && whyc & BE_CR_STAT_RXIRQ)
		r |= berint(sc);

	return (r);
}

/*
 * QEC Interrupt.
 */
int
beqint(struct be_softc *sc, u_int32_t why)
{
	int r = 0, rst = 0;

	if (why & BE_CR_STAT_TXIRQ)
		r |= 1;
	if (why & BE_CR_STAT_RXIRQ)
		r |= 1;

	if (why & BE_CR_STAT_BERROR) {
		r |= 1;
		rst = 1;
		printf("%s: bigmac error\n", sc->sc_dev.dv_xname);
	}

	if (why & BE_CR_STAT_TXDERR) {
		r |= 1;
		rst = 1;
		printf("%s: bogus tx descriptor\n", sc->sc_dev.dv_xname);
	}

	if (why & (BE_CR_STAT_TXLERR | BE_CR_STAT_TXPERR | BE_CR_STAT_TXSERR)) {
		r |= 1;
		rst = 1;
		printf("%s: tx dma error ( ", sc->sc_dev.dv_xname);
		if (why & BE_CR_STAT_TXLERR)
			printf("Late ");
		if (why & BE_CR_STAT_TXPERR)
			printf("Parity ");
		if (why & BE_CR_STAT_TXSERR)
			printf("Generic ");
		printf(")\n");
	}

	if (why & BE_CR_STAT_RXDROP) {
		r |= 1;
		rst = 1;
		printf("%s: out of rx descriptors\n", sc->sc_dev.dv_xname);
	}

	if (why & BE_CR_STAT_RXSMALL) {
		r |= 1;
		rst = 1;
		printf("%s: rx descriptor too small\n", sc->sc_dev.dv_xname);
	}

	if (why & (BE_CR_STAT_RXLERR | BE_CR_STAT_RXPERR | BE_CR_STAT_RXSERR)) {
		r |= 1;
		rst = 1;
		printf("%s: rx dma error ( ", sc->sc_dev.dv_xname);
		if (why & BE_CR_STAT_RXLERR)
			printf("Late ");
		if (why & BE_CR_STAT_RXPERR)
			printf("Parity ");
		if (why & BE_CR_STAT_RXSERR)
			printf("Generic ");
		printf(")\n");
	}

	if (!r) {
		rst = 1;
		printf("%s: unexpected error interrupt %08x\n",
			sc->sc_dev.dv_xname, why);
	}

	if (rst) {
		printf("%s: resetting\n", sc->sc_dev.dv_xname);
		bereset(sc);
	}

	return (r);
}

/*
 * Error interrupt.
 */
int
beeint(struct be_softc *sc, u_int32_t why)
{
	int r = 0, rst = 0;

	if (why & BE_BR_STAT_RFIFOVF) {
		r |= 1;
		rst = 1;
		printf("%s: receive fifo overrun\n", sc->sc_dev.dv_xname);
	}
	if (why & BE_BR_STAT_TFIFO_UND) {
		r |= 1;
		rst = 1;
		printf("%s: transmit fifo underrun\n", sc->sc_dev.dv_xname);
	}
	if (why & BE_BR_STAT_MAXPKTERR) {
		r |= 1;
		rst = 1;
		printf("%s: max packet size error\n", sc->sc_dev.dv_xname);
	}

	if (!r) {
		rst = 1;
		printf("%s: unexpected error interrupt %08x\n",
			sc->sc_dev.dv_xname, why);
	}

	if (rst) {
		printf("%s: resetting\n", sc->sc_dev.dv_xname);
		bereset(sc);
	}

	return (r);
}

/*
 * Transmit interrupt.
 */
int
betint(struct be_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t br = sc->sc_br;
	unsigned int bix, txflags;

	/*
	 * Unload collision counters
	 */
	ifp->if_collisions +=
		bus_space_read_4(t, br, BE_BRI_NCCNT) +
		bus_space_read_4(t, br, BE_BRI_FCCNT) +
		bus_space_read_4(t, br, BE_BRI_EXCNT) +
		bus_space_read_4(t, br, BE_BRI_LTCNT);

	/*
	 * the clear the hardware counters
	 */
	bus_space_write_4(t, br, BE_BRI_NCCNT, 0);
	bus_space_write_4(t, br, BE_BRI_FCCNT, 0);
	bus_space_write_4(t, br, BE_BRI_EXCNT, 0);
	bus_space_write_4(t, br, BE_BRI_LTCNT, 0);

	bix = sc->sc_rb.rb_tdtail;

	for (;;) {
		if (sc->sc_rb.rb_td_nbusy <= 0)
			break;

		txflags = sc->sc_rb.rb_txd[bix].xd_flags;

		if (txflags & QEC_XD_OWN)
			break;

		ifq_clr_oactive(&ifp->if_snd);

		if (++bix == QEC_XD_RING_MAXSIZE)
			bix = 0;

		--sc->sc_rb.rb_td_nbusy;
	}

	sc->sc_rb.rb_tdtail = bix;

	bestart(ifp);

	if (sc->sc_rb.rb_td_nbusy == 0)
		ifp->if_timer = 0;

	return (1);
}

/*
 * Receive interrupt.
 */
int
berint(struct be_softc *sc)
{
	struct qec_xd *xd = sc->sc_rb.rb_rxd;
	unsigned int bix, len;
	unsigned int nrbuf = sc->sc_rb.rb_nrbuf;

	bix = sc->sc_rb.rb_rdtail;

	/*
	 * Process all buffers with valid data.
	 */
	for (;;) {
		len = xd[bix].xd_flags;
		if (len & QEC_XD_OWN)
			break;

		len &= QEC_XD_LENGTH;
		be_read(sc, bix, len);

		/* ... */
		xd[(bix+nrbuf) % QEC_XD_RING_MAXSIZE].xd_flags =
			QEC_XD_OWN | (BE_PKT_BUF_SZ & QEC_XD_LENGTH);

		if (++bix == QEC_XD_RING_MAXSIZE)
			bix = 0;
	}

	sc->sc_rb.rb_rdtail = bix;

	return (1);
}

int
beioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct be_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		beinit(sc);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			bestop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			beinit(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			bestop(sc);
			beinit(sc);
		}
#ifdef BEDEBUG
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = 1;
		else
			sc->sc_debug = 0;
#endif
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			be_mcreset(sc);
		error = 0;
	}

	splx(s);
	return (error);
}


void
beinit(struct be_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t br = sc->sc_br;
	bus_space_handle_t cr = sc->sc_cr;
	struct qec_softc *qec = sc->sc_qec;
	u_int32_t v;
	u_int32_t qecaddr;
	u_int8_t *ea;
	int s;

	s = splnet();

	qec_meminit(&sc->sc_rb, BE_PKT_BUF_SZ);

	bestop(sc);

	ea = sc->sc_arpcom.ac_enaddr;
	bus_space_write_4(t, br, BE_BRI_MACADDR0, (ea[0] << 8) | ea[1]);
	bus_space_write_4(t, br, BE_BRI_MACADDR1, (ea[2] << 8) | ea[3]);
	bus_space_write_4(t, br, BE_BRI_MACADDR2, (ea[4] << 8) | ea[5]);

	/* Clear hash table */
	bus_space_write_4(t, br, BE_BRI_HASHTAB0, 0);
	bus_space_write_4(t, br, BE_BRI_HASHTAB1, 0);
	bus_space_write_4(t, br, BE_BRI_HASHTAB2, 0);
	bus_space_write_4(t, br, BE_BRI_HASHTAB3, 0);

	/* Re-initialize RX configuration */
	v = BE_BR_RXCFG_FIFO;
	bus_space_write_4(t, br, BE_BRI_RXCFG, v);

	be_mcreset(sc);

	bus_space_write_4(t, br, BE_BRI_RANDSEED, 0xbd);

	bus_space_write_4(t, br, BE_BRI_XIFCFG,
			  BE_BR_XCFG_ODENABLE | BE_BR_XCFG_RESV);

	bus_space_write_4(t, br, BE_BRI_JSIZE, 4);

	/*
	 * Turn off counter expiration interrupts as well as
	 * 'gotframe' and 'sentframe'
	 */
	bus_space_write_4(t, br, BE_BRI_IMASK,
			  BE_BR_IMASK_GOTFRAME	|
			  BE_BR_IMASK_RCNTEXP	|
			  BE_BR_IMASK_ACNTEXP	|
			  BE_BR_IMASK_CCNTEXP	|
			  BE_BR_IMASK_LCNTEXP	|
			  BE_BR_IMASK_CVCNTEXP	|
			  BE_BR_IMASK_SENTFRAME	|
			  BE_BR_IMASK_NCNTEXP	|
			  BE_BR_IMASK_ECNTEXP	|
			  BE_BR_IMASK_LCCNTEXP	|
			  BE_BR_IMASK_FCNTEXP	|
			  BE_BR_IMASK_DTIMEXP);

	/* Channel registers: */
	bus_space_write_4(t, cr, BE_CRI_RXDS, (u_int32_t)sc->sc_rb.rb_rxddma);
	bus_space_write_4(t, cr, BE_CRI_TXDS, (u_int32_t)sc->sc_rb.rb_txddma);

	qecaddr = sc->sc_channel * qec->sc_msize;
	bus_space_write_4(t, cr, BE_CRI_RXWBUF, qecaddr);
	bus_space_write_4(t, cr, BE_CRI_RXRBUF, qecaddr);
	bus_space_write_4(t, cr, BE_CRI_TXWBUF, qecaddr + qec->sc_rsize);
	bus_space_write_4(t, cr, BE_CRI_TXRBUF, qecaddr + qec->sc_rsize);

	bus_space_write_4(t, cr, BE_CRI_RIMASK, 0);
	bus_space_write_4(t, cr, BE_CRI_TIMASK, 0);
	bus_space_write_4(t, cr, BE_CRI_QMASK, 0);
	bus_space_write_4(t, cr, BE_CRI_BMASK, 0);
	bus_space_write_4(t, cr, BE_CRI_CCNT, 0);

	/* Enable transmitter */
	bus_space_write_4(t, br, BE_BRI_TXCFG,
			  BE_BR_TXCFG_FIFO | BE_BR_TXCFG_ENABLE);

	/* Enable receiver */
	v = bus_space_read_4(t, br, BE_BRI_RXCFG);
	v |= BE_BR_RXCFG_FIFO | BE_BR_RXCFG_ENABLE;
	bus_space_write_4(t, br, BE_BRI_RXCFG, v);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	be_ifmedia_upd(ifp);
	timeout_add_sec(&sc->sc_tick_ch, 1);
	splx(s);
}

void
be_mcreset(struct be_softc *sc)
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t br = sc->sc_br;
	u_int32_t crc;
	u_int16_t hash[4];
	u_int8_t octet;
	u_int32_t v;
	int i, j;
	struct ether_multi *enm;
	struct ether_multistep step;

	if (ifp->if_flags & IFF_PROMISC) {
		v = bus_space_read_4(t, br, BE_BRI_RXCFG);
		v |= BE_BR_RXCFG_PMISC;
		bus_space_write_4(t, br, BE_BRI_RXCFG, v);
		return;
	}

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_ALLMULTI) {
		hash[3] = hash[2] = hash[1] = hash[0] = 0xffff;
		goto chipit;
	}

	hash[3] = hash[2] = hash[1] = hash[0] = 0;

	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		crc = 0xffffffff;

		for (i = 0; i < ETHER_ADDR_LEN; i++) {
			octet = enm->enm_addrlo[i];

			for (j = 0; j < 8; j++) {
				if ((crc & 1) ^ (octet & 1)) {
					crc >>= 1;
					crc ^= MC_POLY_LE;
				}
				else
					crc >>= 1;
				octet >>= 1;
			}
		}

		crc >>= 26;
		hash[crc >> 4] |= 1 << (crc & 0xf);
		ETHER_NEXT_MULTI(step, enm);
	}

	ifp->if_flags &= ~IFF_ALLMULTI;

chipit:
	/* Enable the hash filter */
	bus_space_write_4(t, br, BE_BRI_HASHTAB0, hash[0]);
	bus_space_write_4(t, br, BE_BRI_HASHTAB1, hash[1]);
	bus_space_write_4(t, br, BE_BRI_HASHTAB2, hash[2]);
	bus_space_write_4(t, br, BE_BRI_HASHTAB3, hash[3]);

	v = bus_space_read_4(t, br, BE_BRI_RXCFG);
	v &= ~BE_BR_RXCFG_PMISC;
	v |= BE_BR_RXCFG_HENABLE;
	bus_space_write_4(t, br, BE_BRI_RXCFG, v);
}

/*
 * Set the tcvr to an idle state
 */
void
be_mii_sync(struct be_softc *sc)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t tr = sc->sc_tr;
	int n = 32;

	while (n--) {
		bus_space_write_4(t, tr, BE_TRI_MGMTPAL,
		    MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO | MGMT_PAL_OENAB);
		(void)bus_space_read_4(t, tr, BE_TRI_MGMTPAL);
		bus_space_write_4(t, tr, BE_TRI_MGMTPAL,
		    MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO |
		    MGMT_PAL_OENAB | MGMT_PAL_DCLOCK);
		(void)bus_space_read_4(t, tr, BE_TRI_MGMTPAL);
	}
}

void
be_pal_gate(struct be_softc *sc, int phy)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t tr = sc->sc_tr;
	u_int32_t v;

	be_mii_sync(sc);

	v = ~(TCVR_PAL_EXTLBACK | TCVR_PAL_MSENSE | TCVR_PAL_LTENABLE);
	if (phy == BE_PHY_INTERNAL)
		v &= ~TCVR_PAL_SERIAL;

	bus_space_write_4(t, tr, BE_TRI_TCVRPAL, v);
	(void)bus_space_read_4(t, tr, BE_TRI_TCVRPAL);
}

static int
be_tcvr_read_bit(struct be_softc *sc, int phy)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t tr = sc->sc_tr;
	int ret;

	if (phy == BE_PHY_INTERNAL) {
		bus_space_write_4(t, tr, BE_TRI_MGMTPAL, MGMT_PAL_EXT_MDIO);
		(void)bus_space_read_4(t, tr, BE_TRI_MGMTPAL);
		bus_space_write_4(t, tr, BE_TRI_MGMTPAL,
		    MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK);
		(void)bus_space_read_4(t, tr, BE_TRI_MGMTPAL);
		ret = (bus_space_read_4(t, tr, BE_TRI_MGMTPAL) &
			MGMT_PAL_INT_MDIO) >> MGMT_PAL_INT_MDIO_SHIFT;
	} else {
		bus_space_write_4(t, tr, BE_TRI_MGMTPAL, MGMT_PAL_INT_MDIO);
		(void)bus_space_read_4(t, tr, BE_TRI_MGMTPAL);
		ret = (bus_space_read_4(t, tr, BE_TRI_MGMTPAL) &
		    MGMT_PAL_EXT_MDIO) >> MGMT_PAL_EXT_MDIO_SHIFT;
		bus_space_write_4(t, tr, BE_TRI_MGMTPAL,
		    MGMT_PAL_INT_MDIO | MGMT_PAL_DCLOCK);
		(void)bus_space_read_4(t, tr, BE_TRI_MGMTPAL);
	}

	return (ret);
}

static void
be_tcvr_write_bit(struct be_softc *sc, int phy, int bit)
{
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t tr = sc->sc_tr;
	u_int32_t v;

	if (phy == BE_PHY_INTERNAL) {
		v = ((bit & 1) << MGMT_PAL_INT_MDIO_SHIFT) |
		    MGMT_PAL_OENAB | MGMT_PAL_EXT_MDIO;
	} else {
		v = ((bit & 1) << MGMT_PAL_EXT_MDIO_SHIFT)
		    | MGMT_PAL_OENAB | MGMT_PAL_INT_MDIO;
	}
	bus_space_write_4(t, tr, BE_TRI_MGMTPAL, v);
	(void)bus_space_read_4(t, tr, BE_TRI_MGMTPAL);
	bus_space_write_4(t, tr, BE_TRI_MGMTPAL, v | MGMT_PAL_DCLOCK);
	(void)bus_space_read_4(t, tr, BE_TRI_MGMTPAL);
}

static void
be_mii_sendbits(struct be_softc *sc, int phy, u_int32_t data, int nbits)
{
	int i;

	for (i = 1 << (nbits - 1); i != 0; i >>= 1)
		be_tcvr_write_bit(sc, phy, (data & i) != 0);
}

static int
be_mii_readreg(struct device *self, int phy, int reg)
{
	struct be_softc *sc = (struct be_softc *)self;
	int val = 0, i;

	/*
	 * Read the PHY register by manually driving the MII control lines.
	 */
	be_mii_sync(sc);
	be_mii_sendbits(sc, phy, MII_COMMAND_START, 2);
	be_mii_sendbits(sc, phy, MII_COMMAND_READ, 2);
	be_mii_sendbits(sc, phy, phy, 5);
	be_mii_sendbits(sc, phy, reg, 5);

	(void) be_tcvr_read_bit(sc, phy);
	(void) be_tcvr_read_bit(sc, phy);

	for (i = 15; i >= 0; i--)
		val |= (be_tcvr_read_bit(sc, phy) << i);

	(void) be_tcvr_read_bit(sc, phy);
	(void) be_tcvr_read_bit(sc, phy);
	(void) be_tcvr_read_bit(sc, phy);

	return (val);
}

void
be_mii_writereg(struct device *self, int phy, int reg, int val)
{
	struct be_softc *sc = (struct be_softc *)self;
	int i;

	/*
	 * Write the PHY register by manually driving the MII control lines.
	 */
	be_mii_sync(sc);
	be_mii_sendbits(sc, phy, MII_COMMAND_START, 2);
	be_mii_sendbits(sc, phy, MII_COMMAND_WRITE, 2);
	be_mii_sendbits(sc, phy, phy, 5);
	be_mii_sendbits(sc, phy, reg, 5);

	be_tcvr_write_bit(sc, phy, 1);
	be_tcvr_write_bit(sc, phy, 0);

	for (i = 15; i >= 0; i--)
		be_tcvr_write_bit(sc, phy, (val >> i) & 1);
}

int
be_mii_reset(struct be_softc *sc, int phy)
{
	int n;

	be_mii_writereg((struct device *)sc, phy, MII_BMCR,
	    BMCR_LOOP | BMCR_PDOWN | BMCR_ISO);
	be_mii_writereg((struct device *)sc, phy, MII_BMCR, BMCR_RESET);

	for (n = 16; n >= 0; n--) {
		int bmcr = be_mii_readreg((struct device *)sc, phy, MII_BMCR);
		if ((bmcr & BMCR_RESET) == 0)
			break;
		DELAY(20);
	}
	if (n == 0) {
		printf("%s: bmcr reset failed\n", sc->sc_dev.dv_xname);
		return (EIO);
	}

	return (0);
}

void
be_tick(void *arg)
{
	struct be_softc *sc = arg;
	int s = splnet();

	mii_tick(&sc->sc_mii);
	(void)be_intphy_service(sc, &sc->sc_mii, MII_TICK);

	timeout_add_sec(&sc->sc_tick_ch, 1);
	splx(s);
}

void
be_mii_statchg(struct device *self)
{
	struct be_softc *sc = (struct be_softc *)self;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t br = sc->sc_br;
	u_int64_t instance;
	u_int32_t v;

	instance = IFM_INST(sc->sc_mii.mii_media.ifm_cur->ifm_media);
#ifdef DIAGNOSTIC
	if (instance > 1)
		panic("be_mii_statchg: instance %lld out of range", instance);
#endif

	/* Update duplex mode in TX configuration */
	v = bus_space_read_4(t, br, BE_BRI_TXCFG);
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0)
		v |= BE_BR_TXCFG_FULLDPLX;
	else
		v &= ~BE_BR_TXCFG_FULLDPLX;
	bus_space_write_4(t, br, BE_BRI_TXCFG, v);

	/* Change to appropriate gate in transceiver PAL */
	be_pal_gate(sc, sc->sc_phys[instance]);
}

/*
 * Get current media settings.
 */
void
be_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct be_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	(void)be_intphy_service(sc, &sc->sc_mii, MII_POLLSTAT);

	ifmr->ifm_status = sc->sc_mii.mii_media_status;
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
	return;
}

/*
 * Set media options.
 */
int
be_ifmedia_upd(struct ifnet *ifp)
{
	struct be_softc *sc = ifp->if_softc;
	int error;

	if ((error = mii_mediachg(&sc->sc_mii)) != 0)
		return (error);

	return (be_intphy_service(sc, &sc->sc_mii, MII_MEDIACHG));
}

/*
 * Service routine for our pseudo-MII internal transceiver.
 */
int
be_intphy_service(struct be_softc *sc, struct mii_data *mii, int cmd)
{
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int bmcr, bmsr;
	int error;

	switch (cmd) {
	case MII_POLLSTAT:
		/*
		 * If we're not polling our PHY instance, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->sc_mii_inst)
			return (0);

		break;

	case MII_MEDIACHG:

		/*
		 * If the media indicates a different PHY instance,
		 * isolate ourselves.
		 */
		if (IFM_INST(ife->ifm_media) != sc->sc_mii_inst) {
			bmcr = be_mii_readreg((void *)sc,
			    BE_PHY_INTERNAL, MII_BMCR);
			be_mii_writereg((void *)sc,
			    BE_PHY_INTERNAL, MII_BMCR, bmcr | BMCR_ISO);
			sc->sc_mii_flags &= ~MIIF_HAVELINK;
			sc->sc_intphy_curspeed = 0;
			return (0);
		}


		if ((error = be_mii_reset(sc, BE_PHY_INTERNAL)) != 0)
			return (error);

		bmcr = be_mii_readreg((void *)sc, BE_PHY_INTERNAL, MII_BMCR);

		/*
		 * Select the new mode and take out of isolation
		 */
		if (IFM_SUBTYPE(ife->ifm_media) == IFM_100_TX)
			bmcr |= BMCR_S100;
		else if (IFM_SUBTYPE(ife->ifm_media) == IFM_10_T)
			bmcr &= ~BMCR_S100;
		else if (IFM_SUBTYPE(ife->ifm_media) == IFM_AUTO) {
			if ((sc->sc_mii_flags & MIIF_HAVELINK) != 0) {
				bmcr &= ~BMCR_S100;
				bmcr |= sc->sc_intphy_curspeed;
			} else {
				/* Keep isolated until link is up */
				bmcr |= BMCR_ISO;
				sc->sc_mii_flags |= MIIF_DOINGAUTO;
			}
		}

		if ((IFM_OPTIONS(ife->ifm_media) & IFM_FDX) != 0)
			bmcr |= BMCR_FDX;
		else
			bmcr &= ~BMCR_FDX;

		be_mii_writereg((void *)sc, BE_PHY_INTERNAL, MII_BMCR, bmcr);
		break;

	case MII_TICK:
		/*
		 * If we're not currently selected, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->sc_mii_inst)
			return (0);

		/* Only used for automatic media selection */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			return (0);

		/* Is the interface even up? */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			return (0);

		/*
		 * Check link status; if we don't have a link, try another
		 * speed. We can't detect duplex mode, so half-duplex is
		 * what we have to settle for.
		 */

		/* Read twice in case the register is latched */
		bmsr = be_mii_readreg((void *)sc, BE_PHY_INTERNAL, MII_BMSR) |
		    be_mii_readreg((void *)sc, BE_PHY_INTERNAL, MII_BMSR);

		if ((bmsr & BMSR_LINK) != 0) {
			/* We have a carrier */
			bmcr = be_mii_readreg((void *)sc,
			    BE_PHY_INTERNAL, MII_BMCR);

			if ((sc->sc_mii_flags & MIIF_DOINGAUTO) != 0) {
				bmcr = be_mii_readreg((void *)sc,
				    BE_PHY_INTERNAL, MII_BMCR);

				sc->sc_mii_flags |= MIIF_HAVELINK;
				sc->sc_intphy_curspeed = (bmcr & BMCR_S100);
				sc->sc_mii_flags &= ~MIIF_DOINGAUTO;

				bmcr &= ~BMCR_ISO;
				be_mii_writereg((void *)sc,
				    BE_PHY_INTERNAL, MII_BMCR, bmcr);

				printf("%s: link up at %s Mbps\n",
				    sc->sc_dev.dv_xname,
				    (bmcr & BMCR_S100) ? "100" : "10");
			}
			sc->sc_mii_ticks = 0;
			return (0);
		}

		if ((sc->sc_mii_flags & MIIF_DOINGAUTO) == 0) {
			sc->sc_mii_flags |= MIIF_DOINGAUTO;
			sc->sc_mii_flags &= ~MIIF_HAVELINK;
			sc->sc_intphy_curspeed = 0;
			printf("%s: link down\n", sc->sc_dev.dv_xname);
		}

		/* Only retry autonegotiation every 5 seconds. */
		if (++sc->sc_mii_ticks < 5)
			return(0);

		sc->sc_mii_ticks = 0;
		bmcr = be_mii_readreg((void *)sc, BE_PHY_INTERNAL, MII_BMCR);
		/* Just flip the fast speed bit */
		bmcr ^= BMCR_S100;
		be_mii_writereg((void *)sc, BE_PHY_INTERNAL, MII_BMCR, bmcr);

		break;

	case MII_DOWN:
		/* Isolate this phy */
		bmcr = be_mii_readreg((void *)sc, BE_PHY_INTERNAL, MII_BMCR);
		be_mii_writereg((void *)sc,
		    BE_PHY_INTERNAL, MII_BMCR, bmcr | BMCR_ISO);
		return (0);
	}

	/* Update the media status. */
	be_intphy_status(sc);

	/* Callback if something changed. */
	if (sc->sc_mii_active != mii->mii_media_active || cmd == MII_MEDIACHG) {
		(*mii->mii_statchg)((struct device *)sc);
		sc->sc_mii_active = mii->mii_media_active;
	}
	return (0);
}

/*
 * Determine status of internal transceiver
 */
void
be_intphy_status(struct be_softc *sc)
{
	struct mii_data *mii = &sc->sc_mii;
	uint64_t media_active, media_status;
	int bmcr, bmsr;

	media_status = IFM_AVALID;
	media_active = 0;

	/*
	 * Internal transceiver; do the work here.
	 */
	bmcr = be_mii_readreg((struct device *)sc, BE_PHY_INTERNAL, MII_BMCR);

	switch (bmcr & (BMCR_S100 | BMCR_FDX)) {
	case (BMCR_S100 | BMCR_FDX):
		media_active = IFM_ETHER | IFM_100_TX | IFM_FDX;
		break;
	case BMCR_S100:
		media_active = IFM_ETHER | IFM_100_TX | IFM_HDX;
		break;
	case BMCR_FDX:
		media_active = IFM_ETHER | IFM_10_T | IFM_FDX;
		break;
	case 0:
		media_active = IFM_ETHER | IFM_10_T | IFM_HDX;
		break;
	}

	/* Read twice in case the register is latched */
	bmsr = be_mii_readreg((struct device *)sc, BE_PHY_INTERNAL, MII_BMSR)|
	       be_mii_readreg((struct device *)sc, BE_PHY_INTERNAL, MII_BMSR);
	if (bmsr & BMSR_LINK)
		media_status |= IFM_ACTIVE;

	mii->mii_media_status = media_status;
	mii->mii_media_active = media_active;
}
@


1.41
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.40 2015/12/08 13:34:22 tedu Exp $	*/
a852 1
		ifp->if_opackets++;
@


1.40
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.39 2015/11/25 11:20:38 mpi Exp $	*/
a433 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.39
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.38 2015/11/25 03:09:59 dlg Exp $	*/
d433 1
a433 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.38
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.37 2015/11/24 17:11:40 mpi Exp $	*/
a72 1
#include <net/netisr.h>
@


1.37
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.36 2015/11/24 13:33:18 mpi Exp $	*/
d573 1
a573 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d609 1
a609 1
			ifp->if_flags |= IFF_OACTIVE;
d854 1
a854 1
		ifp->if_flags &= ~IFF_OACTIVE;
d1063 1
a1063 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.36
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.35 2015/10/25 13:13:06 mpi Exp $	*/
a72 1
#include <net/if_dl.h>
@


1.35
log
@arp_ifinit() is no longer needed and almost dead.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.34 2015/09/12 10:15:10 miod Exp $	*/
a73 1
#include <net/if_types.h>
@


1.34
log
@More ifmedia64 fallout; that should be the last.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.33 2015/09/11 13:02:28 stsp Exp $	*/
a914 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d923 1
a923 9
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			beinit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		default:
			beinit(sc);
			break;
		}
@


1.33
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.32 2015/07/08 07:21:50 mpi Exp $	*/
d116 1
a116 1
	int		sc_mii_active;	/* currently active medium */
@


1.32
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.31 2015/06/24 09:40:54 mpi Exp $	*/
d213 1
a213 1
	int instance;
d374 1
a374 1
				    " at phy %d, instance %d\n",
d1338 1
a1338 1
	u_int instance;
d1344 1
a1344 1
		panic("be_mii_statchg: instance %d out of range", instance);
d1553 1
a1553 1
	int media_active, media_status;
d1583 1
a1583 1
		media_status |=  IFM_ACTIVE;
@


1.31
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.30 2015/05/13 10:42:46 jsg Exp $	*/
d461 1
a461 1
			MFREE(m, n);
d467 1
a467 1
		MFREE(m, n);
@


1.30
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.29 2015/04/07 14:59:06 mpi Exp $	*/
a551 1
	ifp->if_ipackets++;
@


1.29
log
@Keep in sync with the sparc version: convert to if_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.28 2014/12/22 02:28:52 tedu Exp $	*/
d583 1
a583 1
		if (m == 0)
@


1.28
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.27 2014/08/11 12:45:45 mpi Exp $	*/
a480 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a490 1
	m->m_pkthdr.rcvif = ifp;
d531 1
d554 2
a555 10
#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
@


1.27
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.26 2013/11/26 09:50:33 mpi Exp $	*/
a934 1
#ifdef INET
a938 1
#endif /* INET */
@


1.26
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.25 2013/08/07 01:06:40 bluhm Exp $	*/
a77 1
#ifdef INET
a78 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a79 1
#endif
@


1.25
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.24 2013/05/28 09:46:06 mikeb Exp $	*/
d1119 3
a1130 16
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/*
			 * We must listen to a range of multicast
			 * addresses.  For now, just accept all
			 * multicasts, rather than trying to set only
			 * those filter bits needed to match the range.
			 * (At this time, the only use of address
			 * ranges is for IP multicast routing, for
			 * which the range is big enough to require
			 * all bits set.)
			 */
			hash[3] = hash[2] = hash[1] = hash[0] = 0xffff;
			ifp->if_flags |= IFF_ALLMULTI;
			goto chipit;
		}

@


1.24
log
@Fix a common issue across different PHY drivers to reset the
autonegotiation timer when PHY gets the link so that if we
restart the timer the mii_ticks value would be sane.

Lifted originally from FreeBSD, tested by a few on re(4) and
bge(4), ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.23 2008/11/28 02:44:18 brad Exp $	*/
a80 1
#include <netinet/in_var.h>
@


1.23
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.22 2008/10/02 20:21:14 brad Exp $	*/
d1534 1
@


1.22
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.21 2008/09/10 14:01:23 blambert Exp $	*/
a983 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom):
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				be_mcreset(sc);
			error = 0;
		}
		break;
d988 1
d991 6
@


1.21
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.20 2008/06/26 05:42:18 ray Exp $	*/
a935 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d1005 1
a1005 2
		error = EINVAL;
		break;
d1007 1
@


1.20
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.19 2006/06/02 20:00:56 miod Exp $	*/
d1108 1
a1108 1
	timeout_add(&sc->sc_tick_ch, hz);
d1372 1
a1372 1
	timeout_add(&sc->sc_tick_ch, hz);
@


1.19
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.18 2006/03/25 22:41:46 djm Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.18
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.17 2005/06/08 17:03:01 henning Exp $	*/
a111 1
	struct	sbusdev sc_sd;		/* sbus device */
@


1.17
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.16 2005/01/15 05:24:12 brad Exp $	*/
d574 1
a574 1
		bpf_mtap(ifp->if_bpf, m);
d614 1
a614 1
			bpf_mtap(ifp->if_bpf, m);
@


1.16
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.15 2004/05/12 06:35:11 tedu Exp $	*/
a92 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a958 16
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else
				bcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			beinit(sc);
			break;
		    }
#endif /* NS */
@


1.15
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.14 2003/06/27 01:50:52 jason Exp $	*/
d1029 2
a1030 1
			be_mcreset(sc);
@


1.14
log
@ansi functions
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.13 2003/06/27 01:36:53 jason Exp $	*/
a99 1
#include <net/bpfdesc.h>
@


1.13
log
@These don't need linear mappings either.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.12 2003/06/24 21:54:38 henric Exp $	*/
d211 1
a211 4
bematch(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
d220 1
a220 3
beattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d469 1
a469 4
be_put(sc, idx, m)
	struct be_softc *sc;
	int idx;
	struct mbuf *m;
d498 1
a498 3
be_get(sc, idx, totlen)
	struct be_softc *sc;
	int idx, totlen;
d549 1
a549 3
be_read(sc, idx, len)
	struct be_softc *sc;
	int idx, len;
d596 1
a596 2
bestart(ifp)
	struct ifnet *ifp;
d649 1
a649 2
bestop(sc)
	struct be_softc *sc;
d682 1
a682 2
bereset(sc)
	struct be_softc *sc;
d694 1
a694 2
bewatchdog(ifp)
	struct ifnet *ifp;
d704 1
a704 2
beintr(v)
	void *v;
d735 1
a735 3
beqint(sc, why)
	struct be_softc *sc;
	u_int32_t why;
d812 1
a812 3
beeint(sc, why)
	struct be_softc *sc;
	u_int32_t why;
d850 1
a850 2
betint(sc)
	struct be_softc *sc;
d908 1
a908 2
berint(sc)
	struct be_softc *sc;
d941 1
a941 4
beioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d1048 1
a1048 2
beinit(sc)
	struct be_softc *sc;
d1142 1
a1142 2
be_mcreset(sc)
	struct be_softc *sc;
d1228 1
a1228 2
be_mii_sync(sc)
	struct be_softc *sc;
d1246 1
a1246 3
be_pal_gate(sc, phy)
	struct be_softc *sc;
	int phy;
d1263 1
a1263 3
be_tcvr_read_bit(sc, phy)
	struct be_softc *sc;
	int phy;
d1291 1
a1291 4
be_tcvr_write_bit(sc, phy, bit)
	struct be_softc *sc;
	int phy;
	int bit;
d1311 1
a1311 5
be_mii_sendbits(sc, phy, data, nbits)
	struct be_softc *sc;
	int phy;
	u_int32_t data;
	int nbits;
d1320 1
a1320 3
be_mii_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
d1348 1
a1348 3
be_mii_writereg(self, phy, reg, val)
	struct device *self;
	int phy, reg, val;
d1370 1
a1370 3
be_mii_reset(sc, phy)
	struct be_softc *sc;
	int phy;
d1393 1
a1393 2
be_tick(arg)
	void	*arg;
d1406 1
a1406 2
be_mii_statchg(self)
	struct device *self;
d1436 1
a1436 3
be_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d1452 1
a1452 2
be_ifmedia_upd(ifp)
	struct ifnet *ifp;
d1467 1
a1467 4
be_intphy_service(sc, mii, cmd)
	struct be_softc *sc;
	struct mii_data *mii;
	int cmd;
d1622 1
a1622 2
be_intphy_status(sc)
	struct be_softc *sc;
@


1.12
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.11 2003/06/02 18:32:41 jason Exp $	*/
d252 1
a252 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[0].sbr_slot,
d254 1
a254 2
	    (bus_size_t)sa->sa_reg[0].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_cr) != 0) {
d259 1
a259 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[1].sbr_slot,
d261 1
a261 2
	    (bus_size_t)sa->sa_reg[1].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_br) != 0) {
d266 1
a266 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[2].sbr_slot,
d268 1
a268 2
	    (bus_size_t)sa->sa_reg[2].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_tr) != 0) {
@


1.11
log
@Nuke my clause 3 and 4 (and a couple of files jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.10 2003/02/17 01:29:20 henric Exp $	*/
d300 1
a300 1
	    IPL_NET, 0, beintr, sc) == NULL) {
@


1.10
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.9 2002/06/14 21:34:59 todd Exp $	*/
a51 2
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.8 2002/03/14 01:27:02 millert Exp $	*/
d254 2
a255 2
	if (bus_space_map2(sa->sa_bustag,
	    (bus_type_t)sa->sa_reg[0].sbr_slot,
d263 2
a264 2
	if (bus_space_map2(sa->sa_bustag,
	    (bus_type_t)sa->sa_reg[1].sbr_slot,
d272 2
a273 2
	if (bus_space_map2(sa->sa_bustag,
	    (bus_type_t)sa->sa_reg[2].sbr_slot,
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.7 2001/11/28 19:47:54 jason Exp $	*/
d405 1
a405 1
				printf("%s: cannot accomodate MII device %s"
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.6 2001/11/28 16:52:44 jason Exp $	*/
d158 2
a159 2
int	bematch __P((struct device *, void *, void *));
void	beattach __P((struct device *, struct device *, void *));
d161 16
a176 16
void	beinit __P((struct be_softc *));
void	bestart __P((struct ifnet *));
void	bestop __P((struct be_softc *));
void	bewatchdog __P((struct ifnet *));
int	beioctl __P((struct ifnet *, u_long, caddr_t));
void	bereset __P((struct be_softc *));

int	beintr __P((void *));
int	berint __P((struct be_softc *));
int	betint __P((struct be_softc *));
int	beqint __P((struct be_softc *, u_int32_t));
int	beeint __P((struct be_softc *, u_int32_t));

static void	be_read __P((struct be_softc *, int, int));
static int	be_put __P((struct be_softc *, int, struct mbuf *));
static struct mbuf *be_get __P((struct be_softc *, int, int));
d178 1
a178 1
void	be_pal_gate __P((struct be_softc *, int));
d181 2
a182 2
void	be_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
int	be_ifmedia_upd __P((struct ifnet *));
d184 1
a184 1
void	be_mcreset __P((struct be_softc *));
d187 3
a189 3
static int	be_mii_readreg __P((struct device *, int, int));
static void	be_mii_writereg __P((struct device *, int, int, int));
static void	be_mii_statchg __P((struct device *));
d192 10
a201 10
static void	be_mii_sync __P((struct be_softc *));
static void	be_mii_sendbits __P((struct be_softc *, int, u_int32_t, int));
static int	be_mii_reset __P((struct be_softc *, int));
static int	be_tcvr_read_bit __P((struct be_softc *, int));
static void	be_tcvr_write_bit __P((struct be_softc *, int, int));

void	be_tick __P((void *));
void	be_intphy_auto __P((struct be_softc *));
void	be_intphy_status __P((struct be_softc *));
int	be_intphy_service __P((struct be_softc *, struct mii_data *, int));
d242 1
a242 1
	extern void myetheraddr __P((u_char *));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.7 2001/11/28 19:47:54 jason Exp $	*/
d158 2
a159 2
int	bematch(struct device *, void *, void *);
void	beattach(struct device *, struct device *, void *);
d161 16
a176 16
void	beinit(struct be_softc *);
void	bestart(struct ifnet *);
void	bestop(struct be_softc *);
void	bewatchdog(struct ifnet *);
int	beioctl(struct ifnet *, u_long, caddr_t);
void	bereset(struct be_softc *);

int	beintr(void *);
int	berint(struct be_softc *);
int	betint(struct be_softc *);
int	beqint(struct be_softc *, u_int32_t);
int	beeint(struct be_softc *, u_int32_t);

static void	be_read(struct be_softc *, int, int);
static int	be_put(struct be_softc *, int, struct mbuf *);
static struct mbuf *be_get(struct be_softc *, int, int);
d178 1
a178 1
void	be_pal_gate(struct be_softc *, int);
d181 2
a182 2
void	be_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int	be_ifmedia_upd(struct ifnet *);
d184 1
a184 1
void	be_mcreset(struct be_softc *);
d187 3
a189 3
static int	be_mii_readreg(struct device *, int, int);
static void	be_mii_writereg(struct device *, int, int, int);
static void	be_mii_statchg(struct device *);
d192 10
a201 10
static void	be_mii_sync(struct be_softc *);
static void	be_mii_sendbits(struct be_softc *, int, u_int32_t, int);
static int	be_mii_reset(struct be_softc *, int);
static int	be_tcvr_read_bit(struct be_softc *, int);
static void	be_tcvr_write_bit(struct be_softc *, int, int);

void	be_tick(void *);
void	be_intphy_auto(struct be_softc *);
void	be_intphy_status(struct be_softc *);
int	be_intphy_service(struct be_softc *, struct mii_data *, int);
d242 1
a242 1
	extern void myetheraddr(u_char *);
@


1.7.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.7.2.1 2002/06/11 03:42:29 art Exp $	*/
d405 1
a405 1
				printf("%s: cannot accommodate MII device %s"
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d254 2
a255 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[0].sbr_slot,
d263 2
a264 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[1].sbr_slot,
d272 2
a273 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[2].sbr_slot,
@


1.6
log
@grr... include bpfilter.h for NBPFILTER
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.5 2001/11/28 05:42:24 jason Exp $	*/
d250 1
a250 1
			self->dv_xname, sa->sa_nreg);
d255 4
a258 4
			  (bus_type_t)sa->sa_reg[0].sbr_slot,
			  (bus_addr_t)sa->sa_reg[0].sbr_offset,
			  (bus_size_t)sa->sa_reg[0].sbr_size,
			  BUS_SPACE_MAP_LINEAR, 0, &sc->sc_cr) != 0) {
d264 4
a267 4
			  (bus_type_t)sa->sa_reg[1].sbr_slot,
			  (bus_addr_t)sa->sa_reg[1].sbr_offset,
			  (bus_size_t)sa->sa_reg[1].sbr_size,
			  BUS_SPACE_MAP_LINEAR, 0, &sc->sc_br) != 0) {
d273 4
a276 4
			  (bus_type_t)sa->sa_reg[2].sbr_slot,
			  (bus_addr_t)sa->sa_reg[2].sbr_offset,
			  (bus_size_t)sa->sa_reg[2].sbr_size,
			  BUS_SPACE_MAP_LINEAR, 0, &sc->sc_tr) != 0) {
d325 1
a325 1
				    BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
d332 1
a332 1
				      &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
d340 1
a340 2
			            &sc->sc_rb.rb_membase,
			            BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
d349 1
a349 2
				     sc->sc_rb.rb_membase, size, NULL,
				     BUS_DMA_NOWAIT)) != 0) {
d351 1
a351 1
			self->dv_xname, error);
d387 2
a388 2
				    IFM_MAKEWORD(IFM_ETHER,IFM_NONE,0,instance),
				    0, NULL);
d390 1
a390 1
				   IFM_MAKEWORD(IFM_ETHER,IFM_NONE,0,instance));
d399 2
a400 2
				       sc->sc_dev.dv_xname,
				       child->mii_dev.dv_xname);
d406 4
a409 4
				       " at phy %d, instance %d\n",
				       sc->sc_dev.dv_xname,
				       child->mii_dev.dv_xname,
				       child->mii_phy, child->mii_inst);
d419 1
a419 1
				   IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,instance));
d441 1
a441 2
			    IFM_MAKEWORD(IFM_ETHER,IFM_10_T,0,instance),
			    0, NULL);
d443 2
a444 2
			    IFM_MAKEWORD(IFM_ETHER,IFM_100_TX,0,instance),
			    BMCR_S100, NULL);
d446 1
a446 2
			    IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,instance),
			    0, NULL);
d449 1
a449 1
			self->dv_xname);
d456 1
a456 1
				   IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,instance));
d459 1
a459 1
				BE_PHY_INTERNAL, MII_BMCR, BMCR_ISO);
d468 1
a468 1
		IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
d578 1
a578 1
			ifp->if_xname, len);
a723 1

d1006 1
a1006 1
					*(union ns_host *)LLADDR(ifp->if_sadl);
d1009 1
a1009 1
				      sizeof(sc->sc_arpcom.ac_enaddr));
d1273 1
a1273 2
				  MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO |
				  MGMT_PAL_OENAB);
d1276 2
a1277 2
				  MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO |
				  MGMT_PAL_OENAB | MGMT_PAL_DCLOCK);
d1314 1
a1314 1
				  MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK);
d1322 1
a1322 1
			MGMT_PAL_EXT_MDIO) >> MGMT_PAL_EXT_MDIO_SHIFT;
d1324 1
a1324 1
				  MGMT_PAL_INT_MDIO | MGMT_PAL_DCLOCK);
d1343 1
a1343 1
			MGMT_PAL_OENAB | MGMT_PAL_EXT_MDIO;
d1346 1
a1346 1
			| MGMT_PAL_OENAB | MGMT_PAL_INT_MDIO;
d1363 1
a1363 1
	for (i = 1 << (nbits - 1); i != 0; i >>= 1) {
a1364 1
	}
d1429 1
a1429 1
			BMCR_LOOP | BMCR_PDOWN | BMCR_ISO);
d1456 1
a1457 1
	timeout_add(&sc->sc_tick_ch, hz);
d1553 1
a1553 1
				BE_PHY_INTERNAL, MII_BMCR);
d1555 1
a1555 1
				BE_PHY_INTERNAL, MII_BMCR, bmcr | BMCR_ISO);
d1616 1
a1616 1
		       be_mii_readreg((void *)sc, BE_PHY_INTERNAL, MII_BMSR);
d1621 1
a1621 1
					BE_PHY_INTERNAL, MII_BMCR);
d1625 1
a1625 1
						BE_PHY_INTERNAL, MII_BMCR);
d1633 1
a1633 1
					BE_PHY_INTERNAL, MII_BMCR, bmcr);
d1636 2
a1637 2
					sc->sc_dev.dv_xname,
					(bmcr & BMCR_S100) ? "100" : "10");
d1665 1
a1665 1
				BE_PHY_INTERNAL, MII_BMCR, bmcr | BMCR_ISO);
@


1.5
log
@be sure to call ether_ioctl, like everyone else.
also, complain if we don't get an interrupt established.
current state: be doesn't interrupt, qe gets rx/tx sbus dma errors *sigh*
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.4 2001/11/27 02:33:15 jason Exp $	*/
d66 2
@


1.4
log
@remove sc_enaddr and just put the ethernet address into arpcom.ac_enaddr.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.3 2001/09/12 19:48:11 jason Exp $	*/
d299 5
a303 3
	if (sa->sa_nintr)
		(void)bus_intr_establish(sa->sa_bustag, sa->sa_pri, IPL_NET,
					 0, beintr, sc);
d986 5
@


1.3
log
@get sc_bustag and sc_dmatag from attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.2 2001/08/31 15:12:05 jason Exp $	*/
a153 3

	/* MAC address */
	u_int8_t sc_enaddr[6];
d303 2
a304 2
	myetheraddr(sc->sc_enaddr);
	printf(" address %s\n", ether_sprintf(sc->sc_enaddr));
d1005 1
a1005 1
				      sizeof(sc->sc_enaddr));
d1097 1
a1097 1
	ea = sc->sc_enaddr;
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current
@
text
@a66 2
#include "bpfilter.h"

d154 3
d251 1
a251 1
		    self->dv_xname, sa->sa_nreg);
d256 4
a259 4
	    (bus_type_t)sa->sa_reg[0].sbr_slot,
	    (bus_addr_t)sa->sa_reg[0].sbr_offset,
	    (bus_size_t)sa->sa_reg[0].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_cr) != 0) {
d265 4
a268 4
	    (bus_type_t)sa->sa_reg[1].sbr_slot,
	    (bus_addr_t)sa->sa_reg[1].sbr_offset,
	    (bus_size_t)sa->sa_reg[1].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_br) != 0) {
d274 4
a277 4
	    (bus_type_t)sa->sa_reg[2].sbr_slot,
	    (bus_addr_t)sa->sa_reg[2].sbr_offset,
	    (bus_size_t)sa->sa_reg[2].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_tr) != 0) {
d302 3
a304 5
	if (sa->sa_nintr == 0 || bus_intr_establish(sa->sa_bustag, sa->sa_pri,
	    IPL_NET, 0, beintr, sc) == NULL) {
		printf(": no interrupt established\n");
		return;
	}
d306 2
a307 2
	myetheraddr(sc->sc_arpcom.ac_enaddr);
	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d324 1
a324 1
	    BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
d331 1
a331 1
	    &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
d339 2
a340 1
	    &sc->sc_rb.rb_membase, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
d349 2
a350 1
	    sc->sc_rb.rb_membase, size, NULL, BUS_DMA_NOWAIT)) != 0) {
d352 1
a352 1
		    self->dv_xname, error);
d388 2
a389 2
			    IFM_MAKEWORD(IFM_ETHER,IFM_NONE,0,instance),
			    0, NULL);
d391 1
a391 1
			    IFM_MAKEWORD(IFM_ETHER,IFM_NONE,0,instance));
d400 2
a401 2
				    sc->sc_dev.dv_xname,
				    child->mii_dev.dv_xname);
d407 4
a410 4
				    " at phy %d, instance %d\n",
				    sc->sc_dev.dv_xname,
				    child->mii_dev.dv_xname,
				    child->mii_phy, child->mii_inst);
d420 1
a420 1
			    IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,instance));
d442 2
a443 1
		    IFM_MAKEWORD(IFM_ETHER,IFM_10_T,0,instance), 0, NULL);
d445 2
a446 2
		    IFM_MAKEWORD(IFM_ETHER,IFM_100_TX,0,instance),
		    BMCR_S100, NULL);
d448 2
a449 1
		    IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,instance), 0, NULL);
d452 1
a452 1
		    self->dv_xname);
d459 1
a459 1
			    IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,instance));
d462 1
a462 1
			    BE_PHY_INTERNAL, MII_BMCR, BMCR_ISO);
d471 1
a471 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
d581 1
a581 1
		    ifp->if_xname, len);
d727 1
a987 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d1005 1
a1005 1
				    *(union ns_host *)LLADDR(ifp->if_sadl);
d1008 1
a1008 1
				    sizeof(sc->sc_arpcom.ac_enaddr));
d1100 1
a1100 1
	ea = sc->sc_arpcom.ac_enaddr;
d1272 2
a1273 1
		    MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO | MGMT_PAL_OENAB);
d1276 2
a1277 2
		    MGMT_PAL_INT_MDIO | MGMT_PAL_EXT_MDIO |
		    MGMT_PAL_OENAB | MGMT_PAL_DCLOCK);
d1314 1
a1314 1
		    MGMT_PAL_EXT_MDIO | MGMT_PAL_DCLOCK);
d1322 1
a1322 1
		    MGMT_PAL_EXT_MDIO) >> MGMT_PAL_EXT_MDIO_SHIFT;
d1324 1
a1324 1
		    MGMT_PAL_INT_MDIO | MGMT_PAL_DCLOCK);
d1343 1
a1343 1
		    MGMT_PAL_OENAB | MGMT_PAL_EXT_MDIO;
d1346 1
a1346 1
		    | MGMT_PAL_OENAB | MGMT_PAL_INT_MDIO;
d1363 1
a1363 1
	for (i = 1 << (nbits - 1); i != 0; i >>= 1)
d1365 1
d1430 1
a1430 1
	    BMCR_LOOP | BMCR_PDOWN | BMCR_ISO);
d1457 1
a1458 1
	splx(s);
d1554 1
a1554 1
			    BE_PHY_INTERNAL, MII_BMCR);
d1556 1
a1556 1
			    BE_PHY_INTERNAL, MII_BMCR, bmcr | BMCR_ISO);
d1617 1
a1617 1
		    be_mii_readreg((void *)sc, BE_PHY_INTERNAL, MII_BMSR);
d1622 1
a1622 1
			    BE_PHY_INTERNAL, MII_BMCR);
d1626 1
a1626 1
				    BE_PHY_INTERNAL, MII_BMCR);
d1634 1
a1634 1
				    BE_PHY_INTERNAL, MII_BMCR, bmcr);
d1637 2
a1638 2
				    sc->sc_dev.dv_xname,
				    (bmcr & BMCR_S100) ? "100" : "10");
d1666 1
a1666 1
		    BE_PHY_INTERNAL, MII_BMCR, bmcr | BMCR_ISO);
@


1.3.4.3
log
@Merge in -current from roughly a week ago
@
text
@d158 2
a159 2
int	bematch(struct device *, void *, void *);
void	beattach(struct device *, struct device *, void *);
d161 16
a176 16
void	beinit(struct be_softc *);
void	bestart(struct ifnet *);
void	bestop(struct be_softc *);
void	bewatchdog(struct ifnet *);
int	beioctl(struct ifnet *, u_long, caddr_t);
void	bereset(struct be_softc *);

int	beintr(void *);
int	berint(struct be_softc *);
int	betint(struct be_softc *);
int	beqint(struct be_softc *, u_int32_t);
int	beeint(struct be_softc *, u_int32_t);

static void	be_read(struct be_softc *, int, int);
static int	be_put(struct be_softc *, int, struct mbuf *);
static struct mbuf *be_get(struct be_softc *, int, int);
d178 1
a178 1
void	be_pal_gate(struct be_softc *, int);
d181 2
a182 2
void	be_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int	be_ifmedia_upd(struct ifnet *);
d184 1
a184 1
void	be_mcreset(struct be_softc *);
d187 3
a189 3
static int	be_mii_readreg(struct device *, int, int);
static void	be_mii_writereg(struct device *, int, int, int);
static void	be_mii_statchg(struct device *);
d192 10
a201 10
static void	be_mii_sync(struct be_softc *);
static void	be_mii_sendbits(struct be_softc *, int, u_int32_t, int);
static int	be_mii_reset(struct be_softc *, int);
static int	be_tcvr_read_bit(struct be_softc *, int);
static void	be_tcvr_write_bit(struct be_softc *, int, int);

void	be_tick(void *);
void	be_intphy_auto(struct be_softc *);
void	be_intphy_status(struct be_softc *);
int	be_intphy_service(struct be_softc *, struct mii_data *, int);
d242 1
a242 1
	extern void myetheraddr(u_char *);
@


1.3.4.4
log
@Sync the SMP branch with 3.3
@
text
@d254 2
a255 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[0].sbr_slot,
d263 2
a264 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[1].sbr_slot,
d272 2
a273 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[2].sbr_slot,
d405 1
a405 1
				printf("%s: cannot accommodate MII device %s"
@


1.3.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.3.4.4 2003/03/28 00:38:29 niklas Exp $	*/
d52 2
@


1.3.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d211 4
a214 1
bematch(struct device *parent, void *vcf, void *aux)
d223 3
a225 1
beattach(struct device *parent, struct device *self, void *aux)
d252 2
a253 1
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
d255 2
a256 1
	    (bus_size_t)sa->sa_reg[0].sbr_size, 0, 0, &sc->sc_cr) != 0) {
d261 2
a262 1
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[1].sbr_slot,
d264 2
a265 1
	    (bus_size_t)sa->sa_reg[1].sbr_size, 0, 0, &sc->sc_br) != 0) {
d270 2
a271 1
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[2].sbr_slot,
d273 2
a274 1
	    (bus_size_t)sa->sa_reg[2].sbr_size, 0, 0, &sc->sc_tr) != 0) {
d300 1
a300 1
	    IPL_NET, 0, beintr, sc, self->dv_xname) == NULL) {
d480 4
a483 1
be_put(struct be_softc *sc, int idx, struct mbuf *m)
d512 3
a514 1
be_get(struct be_softc *sc, int idx, int totlen)
d565 3
a567 1
be_read(struct be_softc *sc, int idx, int len)
d614 2
a615 1
bestart(struct ifnet *ifp)
d668 2
a669 1
bestop(struct be_softc *sc)
d702 2
a703 1
bereset(struct be_softc *sc)
d715 2
a716 1
bewatchdog(struct ifnet *ifp)
d726 2
a727 1
beintr(void *v)
d758 3
a760 1
beqint(struct be_softc *sc, u_int32_t why)
d837 3
a839 1
beeint(struct be_softc *sc, u_int32_t why)
d877 2
a878 1
betint(struct be_softc *sc)
d936 2
a937 1
berint(struct be_softc *sc)
d970 4
a973 1
beioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
d1080 2
a1081 1
beinit(struct be_softc *sc)
d1175 2
a1176 1
be_mcreset(struct be_softc *sc)
d1262 2
a1263 1
be_mii_sync(struct be_softc *sc)
d1281 3
a1283 1
be_pal_gate(struct be_softc *sc, int phy)
d1300 3
a1302 1
be_tcvr_read_bit(struct be_softc *sc, int phy)
d1330 4
a1333 1
be_tcvr_write_bit(struct be_softc *sc, int phy, int bit)
d1353 5
a1357 1
be_mii_sendbits(struct be_softc *sc, int phy, u_int32_t data, int nbits)
d1366 3
a1368 1
be_mii_readreg(struct device *self, int phy, int reg)
d1396 3
a1398 1
be_mii_writereg(struct device *self, int phy, int reg, int val)
d1420 3
a1422 1
be_mii_reset(struct be_softc *sc, int phy)
d1445 2
a1446 1
be_tick(void *arg)
d1459 2
a1460 1
be_mii_statchg(struct device *self)
d1490 3
a1492 1
be_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
d1508 2
a1509 1
be_ifmedia_upd(struct ifnet *ifp)
d1524 4
a1527 1
be_intphy_service(struct be_softc *sc, struct mii_data *mii, int cmd)
d1682 2
a1683 1
be_intphy_status(struct be_softc *sc)
@


1.3.4.7
log
@Merge with the trunk
@
text
@d100 1
@


1.2
log
@implement autoconf mechanism using device_register(); from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: be.c,v 1.1 2001/08/20 22:47:08 jason Exp $	*/
d244 4
@


1.1
log
@qec+be (another driver originally written under OpenBSD, but pulled into
this heirarchy from the NetBSD tree... and who says the projects don't
work together).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a242 1
	struct bootpath *bp;
a472 5

	bp = sa->sa_bp;
	if (bp != NULL && strcmp(bp->name, be_cd.cd_name) == 0 &&
	    sc->sc_dev.dv_unit == bp->val[1])
		bp->dev = &sc->sc_dev;
@

