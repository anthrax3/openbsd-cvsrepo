head	1.59;
access;
symbols
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.59.0.12
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.59.0.10
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.59.0.8
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.59.0.6
	OPENBSD_5_6_BASE:1.59
	OPENBSD_5_5:1.59.0.4
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.58.0.16
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.58.0.14
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.58.0.12
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.10
	OPENBSD_5_0:1.58.0.8
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.58.0.6
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.58.0.4
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.57.0.6
	OPENBSD_4_6_BASE:1.57
	OPENBSD_4_5:1.57.0.2
	OPENBSD_4_5_BASE:1.57
	OPENBSD_4_4:1.56.0.8
	OPENBSD_4_4_BASE:1.56
	OPENBSD_4_3:1.56.0.6
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.56.0.4
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.52.0.6
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.52.0.4
	OPENBSD_3_8_BASE:1.52
	OPENBSD_3_7:1.52.0.2
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.44.0.6
	OPENBSD_3_6_BASE:1.44
	SMP_SYNC_A:1.44
	SMP_SYNC_B:1.44
	OPENBSD_3_5:1.44.0.4
	OPENBSD_3_5_BASE:1.44
	OPENBSD_3_4:1.44.0.2
	OPENBSD_3_4_BASE:1.44
	UBC_SYNC_A:1.39
	OPENBSD_3_3:1.35.0.2
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.33
	UBC:1.2.0.2
	UBC_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.59
date	2013.10.20.20.07.30;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2008.12.27.17.23.03;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.17.22.18.16;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2006.12.02.11.21.37;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.25.21.23.32;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.02.20.00.56;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.15.18.40.16;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.08.21.35.03;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.07.16.44.52;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2005.03.03.01.52.41;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2005.03.03.01.41.11;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2005.03.01.21.23.36;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2004.11.29.22.07.40;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.03.21.02.13;	author jason;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.24.21.54.38;	author henric;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.18.17.35.30;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.02.18.32.41;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.31.21.01.59;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	2003.03.28.15.03.41;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.28.03.18.03;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.28.00.23.05;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.27.18.06.48;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2003.03.20.15.42.06;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.12.19.41.20;	author henric;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.10.03.18.59;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2002.08.31.21.18.48;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.16.02.54.54;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.12.16.18.59;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2002.08.06.03.48.45;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.05.22.12.32;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.02.16.13.07;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.30.23.03.30;	author jason;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.30.18.07.02;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.26.15.49.56;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.26.04.24.44;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.25.19.04.46;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.03.02.32.06;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.21.20.25.28;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.29.09.45.30;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.03.16.07;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.14.22;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.04.23.32.52;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.24.18.51.29;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.23.05.47.50;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.07.16.39.48;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.07.04.44.52;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.06.18.40.56;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.06.18.20.34;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.05.20.00.04;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.05.18.34.39;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.06.00.49.41;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.04.19.39.06;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.04.01.13.29;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.05.05.38.28;	author jason;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.12.04.20.07.06;	author jason;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.05.13.19.35.10;	author ho;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.06.07.11.02.32;	author ho;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.02.19.10.56.32;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.01.31.22.55.38;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.05.19.22.14.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@/*	$OpenBSD: cgsix.c,v 1.58 2009/09/05 14:09:35 miod Exp $	*/

/*
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#include <dev/sbus/sbusvar.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>
#include <dev/sbus/cgsixreg.h>
#include <dev/ic/bt458reg.h>

int cgsix_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t cgsix_mmap(void *, off_t, int);
int cgsix_is_console(int);
int cg6_bt_getcmap(union bt_cmap *, struct wsdisplay_cmap *);
int cg6_bt_putcmap(union bt_cmap *, struct wsdisplay_cmap *);
void cgsix_loadcmap_immediate(struct cgsix_softc *, u_int, u_int);
void cgsix_loadcmap_deferred(struct cgsix_softc *, u_int, u_int);
void cgsix_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void cgsix_reset(struct cgsix_softc *, u_int32_t);
void cgsix_hardreset(struct cgsix_softc *);
void cgsix_burner(void *, u_int, u_int);
int cgsix_intr(void *);
void cgsix_ras_init(struct cgsix_softc *);
int cgsix_ras_copyrows(void *, int, int, int);
int cgsix_ras_copycols(void *, int, int, int, int);
int cgsix_ras_erasecols(void *, int, int, int, long int);
int cgsix_ras_eraserows(void *, int, int, long int);
int cgsix_ras_do_cursor(struct rasops_info *);
int cgsix_setcursor(struct cgsix_softc *, struct wsdisplay_cursor *);
int cgsix_updatecursor(struct cgsix_softc *, u_int);

struct wsdisplay_accessops cgsix_accessops = {
	.ioctl = cgsix_ioctl,
	.mmap = cgsix_mmap,
	.burn_screen = cgsix_burner
};

int	cgsixmatch(struct device *, void *, void *);
void	cgsixattach(struct device *, struct device *, void *);

struct cfattach cgsix_ca = {
	sizeof (struct cgsix_softc), cgsixmatch, cgsixattach
};

struct cfdriver cgsix_cd = {
	NULL, "cgsix", DV_DULL
};

int
cgsixmatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct sbus_attach_args *sa = aux;

	return (strcmp(cf->cf_driver->cd_name, sa->sa_name) == 0);
}

void    
cgsixattach(struct device *parent, struct device *self, void *aux)
{
	struct cgsix_softc *sc = (struct cgsix_softc *)self;
	struct sbus_attach_args *sa = aux;
	int node, console;
	u_int32_t fhc, rev;
	const char *nam;

	node = sa->sa_node;
	sc->sc_bustag = sa->sa_bustag;
	sc->sc_paddr = sbus_bus_addr(sa->sa_bustag, sa->sa_slot, sa->sa_offset);

	if (sa->sa_nreg != 1) {
		printf(": expected %d registers, got %d\n", 1, sa->sa_nreg);
		goto fail;
	}

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, 0);

	/*
	 * Map just BT, FHC, FBC, THC, and video RAM.
	 */
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_BT_OFFSET,
	    CGSIX_BT_SIZE, 0, 0, &sc->sc_bt_regs) != 0) {
		printf(": cannot map bt registers\n");
		goto fail_bt;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_FHC_OFFSET,
	    CGSIX_FHC_SIZE, 0, 0, &sc->sc_fhc_regs) != 0) {
		printf(": cannot map fhc registers\n");
		goto fail_fhc;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_THC_OFFSET,
	    CGSIX_THC_SIZE, 0, 0, &sc->sc_thc_regs) != 0) {
		printf(": cannot map thc registers\n");
		goto fail_thc;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_VID_OFFSET,
	    sc->sc_sunfb.sf_fbsize, BUS_SPACE_MAP_LINEAR,
	    0, &sc->sc_vid_regs) != 0) {
		printf(": cannot map vid registers\n");
		goto fail_vid;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_TEC_OFFSET,
	    CGSIX_TEC_SIZE, 0, 0, &sc->sc_tec_regs) != 0) {
		printf(": cannot map tec registers\n");
		goto fail_tec;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_FBC_OFFSET,
	    CGSIX_FBC_SIZE, 0, 0, &sc->sc_fbc_regs) != 0) {
		printf(": cannot map fbc registers\n");
		goto fail_fbc;
	}

	if ((sc->sc_ih = bus_intr_establish(sa->sa_bustag, sa->sa_pri,
	    IPL_TTY, 0, cgsix_intr, sc, self->dv_xname)) == NULL) {
		printf(": couldn't establish interrupt, pri %d\n%s",
		    INTLEV(sa->sa_pri), self->dv_xname);
	}

	/* if prom didn't initialize us, do it the hard way */
	if (OF_getproplen(node, "width") != sizeof(u_int32_t))
		cgsix_hardreset(sc);

	nam = getpropstring(node, "model");
	if (*nam == '\0')
		nam = sa->sa_name;
	printf(": %s", nam);

	console = cgsix_is_console(node);

	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;
	cgsix_reset(sc, rev);

	cgsix_burner(sc, 1, 0);

	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
	    sc->sc_vid_regs);
	sc->sc_sunfb.sf_ro.ri_hw = sc;

	printf(", %dx%d, rev %d\n", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height, rev);

	fbwscons_init(&sc->sc_sunfb, 0, console);
	fbwscons_setcolormap(&sc->sc_sunfb, cgsix_setcolor);

	/*
	 * Old rev. cg6 cards do not like the current acceleration code.
	 *
	 * Some hints from Sun point out at timing and cache problems, which
	 * will be investigated later.
	 */
	if (rev < 5)
		sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags |= CG6_CFFLAG_NOACCEL;

	if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL)
	    == 0) {
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_sunfb.sf_ro.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_do_cursor = cgsix_ras_do_cursor;
		cgsix_ras_init(sc);
	}

	if (console)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &cgsix_accessops, console);

	return;

fail_fbc:
	bus_space_unmap(sa->sa_bustag, sc->sc_tec_regs, CGSIX_TEC_SIZE);
fail_tec:
	bus_space_unmap(sa->sa_bustag, sc->sc_vid_regs, sc->sc_sunfb.sf_fbsize);
fail_vid:
	bus_space_unmap(sa->sa_bustag, sc->sc_thc_regs, CGSIX_THC_SIZE);
fail_thc:
	bus_space_unmap(sa->sa_bustag, sc->sc_fhc_regs, CGSIX_FHC_SIZE);
fail_fhc:
	bus_space_unmap(sa->sa_bustag, sc->sc_bt_regs, CGSIX_BT_SIZE);
fail_bt:
fail:
	return;
}

int
cgsix_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct cgsix_softc *sc = v;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cursor *curs;
	struct wsdisplay_curpos *pos;
	u_char r[2], g[2], b[2];
	int error, s;
	u_int mode;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG6;
		break;
	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)data;
		if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags &
		    CG6_CFFLAG_NOACCEL) == 0) {
			if (sc->sc_mode != WSDISPLAYIO_MODE_EMUL &&
			    mode == WSDISPLAYIO_MODE_EMUL)
				cgsix_ras_init(sc);
		}
		sc->sc_mode = mode;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (void *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cg6_bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cg6_bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		/* if we can handle interrupts, defer the update */
		if (sc->sc_ih != NULL)
			cgsix_loadcmap_deferred(sc, cm->index, cm->count);
		else
			cgsix_loadcmap_immediate(sc, cm->index, cm->count);
		break;
	case WSDISPLAYIO_SCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		return (cgsix_setcursor(sc, curs));
	case WSDISPLAYIO_GCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		if (curs->which & WSDISPLAY_CURSOR_DOCUR)
			curs->enable = sc->sc_curs_enabled;
		if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
			curs->pos.x = sc->sc_curs_pos.x;
			curs->pos.y = sc->sc_curs_pos.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
			curs->hot.x = sc->sc_curs_hot.x;
			curs->hot.y = sc->sc_curs_hot.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
			curs->cmap.index = 0;
			curs->cmap.count = 2;
			r[0] = sc->sc_curs_fg >> 16;
			g[0] = sc->sc_curs_fg >> 8;
			b[0] = sc->sc_curs_fg >> 0;
			r[1] = sc->sc_curs_bg >> 16;
			g[1] = sc->sc_curs_bg >> 8;
			b[1] = sc->sc_curs_bg >> 0;
			error = copyout(r, curs->cmap.red, sizeof(r));
			if (error)
				return (error);
			error = copyout(g, curs->cmap.green, sizeof(g));
			if (error)
				return (error);
			error = copyout(b, curs->cmap.blue, sizeof(b));
			if (error)
				return (error);
		}
		if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
			size_t l;

			curs->size.x = sc->sc_curs_size.x;
			curs->size.y = sc->sc_curs_size.y;
			l = (sc->sc_curs_size.x * sc->sc_curs_size.y) / NBBY;
			error = copyout(sc->sc_curs_image, curs->image, l);
			if (error)
				return (error);
			error = copyout(sc->sc_curs_mask, curs->mask, l);
			if (error)
				return (error);
		}
		break;
	case WSDISPLAYIO_GCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = sc->sc_curs_pos.x;
		pos->y = sc->sc_curs_pos.y;
		break;
	case WSDISPLAYIO_SCURPOS:
		pos = (struct wsdisplay_curpos *)data;
		s = spltty();
		sc->sc_curs_pos.x = pos->x;
		sc->sc_curs_pos.y = pos->y;
		cgsix_updatecursor(sc, WSDISPLAY_CURSOR_DOPOS);
		splx(s);
		break;
	case WSDISPLAYIO_GCURMAX:
		pos = (struct wsdisplay_curpos *)data;
		pos->x = pos->y = 32;
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;
	default:
		return -1; /* not supported */
        }

	return (0);
}

int
cgsix_setcursor(struct cgsix_softc *sc, struct wsdisplay_cursor *curs)
{
	u_int8_t r[2], g[2], b[2], image[128], mask[128];
	int s, error;
	size_t imcount;

	/*
	 * Do stuff that can generate errors first, then we'll blast it
	 * all at once.
	 */
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		if (curs->cmap.count < 2)
			return (EINVAL);
		error = copyin(curs->cmap.red, r, sizeof(r));
		if (error)
			return (error);
		error = copyin(curs->cmap.green, g, sizeof(g));
		if (error)
			return (error);
		error = copyin(curs->cmap.blue, b, sizeof(b));
		if (error)
			return (error);
	}

	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		if (curs->size.x > CG6_MAX_CURSOR ||
		    curs->size.y > CG6_MAX_CURSOR)
			return (EINVAL);
		imcount = (curs->size.x * curs->size.y) / NBBY;
		error = copyin(curs->image, image, imcount);
		if (error)
			return (error);
		error = copyin(curs->mask, mask, imcount);
		if (error)
			return (error);
	}

	/*
	 * Ok, everything is in kernel space and sane, update state.
	 */
	s = spltty();

	if (curs->which & WSDISPLAY_CURSOR_DOCUR)
		sc->sc_curs_enabled = curs->enable;
	if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
		sc->sc_curs_pos.x = curs->pos.x;
		sc->sc_curs_pos.y = curs->pos.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
		sc->sc_curs_hot.x = curs->hot.x;
		sc->sc_curs_hot.y = curs->hot.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		sc->sc_curs_fg = ((r[0] << 16) | (g[0] << 8) | (b[0] << 0));
		sc->sc_curs_bg = ((r[1] << 16) | (g[1] << 8) | (b[1] << 0));
	}
	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		sc->sc_curs_size.x = curs->size.x;
		sc->sc_curs_size.y = curs->size.y;
		bcopy(image, sc->sc_curs_image, imcount);
		bcopy(mask, sc->sc_curs_mask, imcount);
	}

	cgsix_updatecursor(sc, curs->which);
	splx(s);

	return (0);
}

int
cgsix_updatecursor(struct cgsix_softc *sc, u_int which)
{
	if (which & WSDISPLAY_CURSOR_DOCMAP) {
		BT_WRITE(sc, BT_ADDR, BT_OV1 << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x00ff0000) >> 16) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x0000ff00) >> 8) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x000000ff) >> 0) << 24);

		BT_WRITE(sc, BT_ADDR, BT_OV3 << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x00ff0000) >> 16) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x0000ff00) >> 8) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x000000ff) >> 0) << 24);
	}

	if (which & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOHOT)) {
		u_int32_t x, y;

		x = sc->sc_curs_pos.x + CG6_MAX_CURSOR - sc->sc_curs_hot.x;
		y = sc->sc_curs_pos.y + CG6_MAX_CURSOR - sc->sc_curs_hot.y;
		THC_WRITE(sc, CG6_THC_CURSXY,
		    ((x & 0xffff) << 16) | (y & 0xffff));
	}

	if (which & WSDISPLAY_CURSOR_DOCUR) {
		u_int32_t c;

		/* Enable or disable the cursor overlay planes */
		if (sc->sc_curs_enabled) {
			BT_WRITE(sc, BT_ADDR, BT_CR << 24);
			c = BT_READ(sc, BT_CTRL);
			c |= (BTCR_DISPENA_OV0 | BTCR_DISPENA_OV1) << 24;
			BT_WRITE(sc, BT_CTRL, c);
		} else {
			BT_WRITE(sc, BT_ADDR, BT_CR << 24);
			c = BT_READ(sc, BT_CTRL);
			c &= ~((BTCR_DISPENA_OV0 | BTCR_DISPENA_OV1) << 24);
			BT_WRITE(sc, BT_CTRL, c);
			THC_WRITE(sc, CG6_THC_CURSXY, THC_CURSOFF);
		}
	}

	return (0);
}

struct mmo {
	off_t mo_uaddr;
	bus_size_t mo_size;
	bus_size_t mo_physoff;
};

paddr_t
cgsix_mmap(void *v, off_t off, int prot)
{
	struct cgsix_softc *sc = v;
	struct mmo *mo;
	bus_addr_t u;
	bus_size_t sz;

	static struct mmo mmo[] = {
		{ CG6_USER_RAM, 0, CGSIX_VID_OFFSET },

		/* do not actually know how big most of these are! */
		{ CG6_USER_FBC, 1, CGSIX_FBC_OFFSET },
		{ CG6_USER_TEC, 1, CGSIX_TEC_OFFSET },
		{ CG6_USER_BTREGS, 8192 /* XXX */, CGSIX_BT_OFFSET },
		{ CG6_USER_FHC, 1, CGSIX_FHC_OFFSET },
		{ CG6_USER_THC, CGSIX_THC_SIZE, CGSIX_THC_OFFSET },
		{ CG6_USER_ROM, 65536, CGSIX_ROM_OFFSET },
		{ CG6_USER_DHC, 1, CGSIX_DHC_OFFSET },
	};
#define	NMMO (sizeof mmo / sizeof *mmo)

	if (off & PGOFSET || off < 0)
		return (-1);

	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
		for (mo = mmo; mo < &mmo[NMMO]; mo++) {
			if (off < mo->mo_uaddr)
				continue;
			u = off - mo->mo_uaddr;
			sz = mo->mo_size ? mo->mo_size : sc->sc_sunfb.sf_fbsize;
			if (u < sz) {
				return (bus_space_mmap(sc->sc_bustag,
				    sc->sc_paddr, u + mo->mo_physoff,
				    prot, BUS_SPACE_MAP_LINEAR));
			}
		}
		break;

	case WSDISPLAYIO_MODE_DUMBFB:
		/* Allow mapping as a dumb framebuffer from offset 0 */
		if (off >= 0 && off < sc->sc_sunfb.sf_fbsize)
			return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
			    off + CGSIX_VID_OFFSET, prot,
			    BUS_SPACE_MAP_LINEAR));
		break;
	}

	return (-1);
}

int
cgsix_is_console(int node)
{
	extern int fbnode;

	return (fbnode == node);
}

int
cg6_bt_getcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyout(&bcm->cm_map[index + i][0],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][1],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][2],
		    &rcm->blue[i], 1)) != 0)
			return (error);
	}
	return (0);
}

int
cg6_bt_putcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &bcm->cm_map[index + i][0], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &bcm->cm_map[index + i][1], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &bcm->cm_map[index + i][2], 1)) != 0)
			return (error);
	}
	return (0);
}

void
cgsix_loadcmap_deferred(struct cgsix_softc *sc, u_int start, u_int ncolors)
{
	u_int32_t thcm;

	thcm = THC_READ(sc, CG6_THC_MISC);
	thcm &= ~THC_MISC_RESET;
	thcm |= THC_MISC_INTEN;
	THC_WRITE(sc, CG6_THC_MISC, thcm);
}

void
cgsix_loadcmap_immediate(struct cgsix_softc *sc, u_int start, u_int ncolors)
{
	u_int cstart;
	u_int32_t v;
	int count;

	cstart = BT_D4M3(start);
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	BT_WRITE(sc, BT_ADDR, BT_D4M4(start) << 24);
	while (--count >= 0) {
		v = sc->sc_cmap.cm_chip[cstart];
		BT_WRITE(sc, BT_CMAP, v << 0);
		BT_WRITE(sc, BT_CMAP, v << 8);
		BT_WRITE(sc, BT_CMAP, v << 16);
		BT_WRITE(sc, BT_CMAP, v << 24);
		cstart++;
	}
}

void
cgsix_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct cgsix_softc *sc = v;
	union bt_cmap *bcm = &sc->sc_cmap;

	bcm->cm_map[index][0] = r;
	bcm->cm_map[index][1] = g;
	bcm->cm_map[index][2] = b;
	cgsix_loadcmap_immediate(sc, index, 1);
}

void
cgsix_reset(struct cgsix_softc *sc, u_int32_t fhcrev)
{
	u_int32_t fhc;

	/* hide the cursor, just in case */
	THC_WRITE(sc, CG6_THC_CURSXY, THC_CURSOFF);

	TEC_WRITE(sc, CG6_TEC_MV, 0);
	TEC_WRITE(sc, CG6_TEC_CLIP, 0);
	TEC_WRITE(sc, CG6_TEC_VDC, 0);

	/* take core of hardware bugs in old revisions */
	if (fhcrev < 5) {
		/*
		 * Keep current resolution; set cpu to 68020, set test
		 * window (size 1Kx1K), and for rev 1, disable dest cache.
		 */
		fhc = FHC_READ(sc);
		fhc &= FHC_RES_MASK;
		fhc |= FHC_CPU_68020 | FHC_TEST |
		    (11 << FHC_TESTX_SHIFT) | (11 << FHC_TESTY_SHIFT);
		if (fhcrev < 2)
			fhc |= FHC_DST_DISABLE;
		FHC_WRITE(sc, fhc);
	}

	/* enable cursor overlays in brooktree DAC */
	BT_WRITE(sc, BT_ADDR, BT_CR << 24);
	BT_WRITE(sc, BT_CTRL, BT_READ(sc, BT_CTRL) |
	    ((BTCR_DISPENA_OV1 | BTCR_DISPENA_OV0) << 24));
}

void
cgsix_hardreset(struct cgsix_softc *sc)
{
	u_int32_t fhc, rev;

	/* enable all of the bit planes */
	BT_WRITE(sc, BT_ADDR, BT_RMR << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0xff << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/* no bit planes should blink */
	BT_WRITE(sc, BT_ADDR, BT_BMR << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00 << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/*
	 * enable the RAMDAC, disable blink, disable overlay 0 and 1,
	 * use 4:1 multiplexor.
	 */
	BT_WRITE(sc, BT_ADDR, BT_CR << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL,
	    (BTCR_MPLX_4 | BTCR_RAMENA | BTCR_BLINK_6464) << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/* disable the D/A read pins */
	BT_WRITE(sc, BT_ADDR, BT_CTR << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00 << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/* configure thc */
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_RESET | THC_MISC_INTR |
	    THC_MISC_CYCLS);
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_INTR | THC_MISC_CYCLS);

	THC_WRITE(sc, CG6_THC_HSYNC1, 0x10009);
	THC_WRITE(sc, CG6_THC_HSYNC2, 0x570000);
	THC_WRITE(sc, CG6_THC_HSYNC3, 0x15005d);
	THC_WRITE(sc, CG6_THC_VSYNC1, 0x10005);
	THC_WRITE(sc, CG6_THC_VSYNC2, 0x2403a8);
	THC_WRITE(sc, CG6_THC_REFRESH, 0x16b);

	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_RESET | THC_MISC_INTR |
	    THC_MISC_CYCLS);
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_INTR | THC_MISC_CYCLS);

	/* configure fhc (1152x900) */
	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;

	fhc = FHC_RES_1152 | FHC_CPU_68020 | FHC_TEST;
	if (rev < 1)
		fhc |= FHC_FROP_DISABLE;
	if (rev < 2)
		fhc |= FHC_DST_DISABLE;
	FHC_WRITE(sc, fhc);
}

void
cgsix_burner(void *vsc, u_int on, u_int flags)
{
	struct cgsix_softc *sc = vsc;
	int s;
	u_int32_t thcm;

	s = splhigh();
	thcm = THC_READ(sc, CG6_THC_MISC);
	if (on)
		thcm |= THC_MISC_VIDEN | THC_MISC_SYNCEN;
	else {
		thcm &= ~THC_MISC_VIDEN;
		if (flags & WSDISPLAY_BURN_VBLANK)
			thcm &= ~THC_MISC_SYNCEN;
	}
	THC_WRITE(sc, CG6_THC_MISC, thcm);
	splx(s);
}

int
cgsix_intr(void *vsc)
{
	struct cgsix_softc *sc = vsc;
	u_int32_t thcm;

	thcm = THC_READ(sc, CG6_THC_MISC);
	if ((thcm & (THC_MISC_INTEN | THC_MISC_INTR)) !=
	    (THC_MISC_INTEN | THC_MISC_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	thcm &= ~(THC_MISC_RESET | THC_MISC_INTEN);
	thcm |= THC_MISC_INTR;
	THC_WRITE(sc, CG6_THC_MISC, thcm);
	cgsix_loadcmap_immediate(sc, 0, 256);
	return (1);
}

void
cgsix_ras_init(struct cgsix_softc *sc)
{
	u_int32_t m;

	CG6_DRAIN(sc);
	m = FBC_READ(sc, CG6_FBC_MODE);
	m &= ~FBC_MODE_MASK;
	m |= FBC_MODE_VAL;
	FBC_WRITE(sc, CG6_FBC_MODE, m);
}

int
cgsix_ras_copyrows(void *cookie, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (dst == src)
		return 0;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_rows)
		n = ri->ri_rows - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_rows)
		n = ri->ri_rows - dst;
	if (n <= 0)
		return 0;
	n *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_COPY);
	FBC_WRITE(sc, CG6_FBC_X0, ri->ri_xorigin);
	FBC_WRITE(sc, CG6_FBC_Y0, ri->ri_yorigin + src);
	FBC_WRITE(sc, CG6_FBC_X1, ri->ri_xorigin + ri->ri_emuwidth - 1);
	FBC_WRITE(sc, CG6_FBC_Y1, ri->ri_yorigin + src + n - 1);
	FBC_WRITE(sc, CG6_FBC_X2, ri->ri_xorigin);
	FBC_WRITE(sc, CG6_FBC_Y2, ri->ri_yorigin + dst);
	FBC_WRITE(sc, CG6_FBC_X3, ri->ri_xorigin + ri->ri_emuwidth - 1);
	FBC_WRITE(sc, CG6_FBC_Y3, ri->ri_yorigin + dst + n - 1);
	CG6_BLIT_WAIT(sc);
	CG6_DRAIN(sc);

	return 0;
}

int
cgsix_ras_copycols(void *cookie, int row, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (dst == src)
		return 0;
	if ((row < 0) || (row >= ri->ri_rows))
		return 0;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_cols)
		n = ri->ri_cols - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_cols)
		n = ri->ri_cols - dst;
	if (n <= 0)
		return 0;
	n *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_COPY);
	FBC_WRITE(sc, CG6_FBC_X0, ri->ri_xorigin + src);
	FBC_WRITE(sc, CG6_FBC_Y0, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_X1, ri->ri_xorigin + src + n - 1);
	FBC_WRITE(sc, CG6_FBC_Y1,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_X2, ri->ri_xorigin + dst);
	FBC_WRITE(sc, CG6_FBC_Y2, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_X3, ri->ri_xorigin + dst + n - 1);
	FBC_WRITE(sc, CG6_FBC_Y3,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	CG6_BLIT_WAIT(sc);
	CG6_DRAIN(sc);

	return 0;
}

int
cgsix_ras_erasecols(void *cookie, int row, int col, int n, long int attr)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	int fg, bg;

	if ((row < 0) || (row >= ri->ri_rows))
		return 0;
	if (col < 0) {
		n += col;
		col = 0;
	}
	if (col + n > ri->ri_cols)
		n = ri->ri_cols - col;
	if (n <= 0)
		return 0;
	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FILL);
	FBC_WRITE(sc, CG6_FBC_FG, ri->ri_devcmap[bg]);
	FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col);
	FBC_WRITE(sc, CG6_FBC_ARECTY,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col + n - 1);
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);

	return 0;
}

int
cgsix_ras_eraserows(void *cookie, int row, int n, long int attr)
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;
	int fg, bg;

	if (row < 0) {
		n += row;
		row = 0;
	}
	if (row + n > ri->ri_rows)
		n = ri->ri_rows - row;
	if (n <= 0)
		return 0;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FILL);
	FBC_WRITE(sc, CG6_FBC_FG, ri->ri_devcmap[bg]);
	if ((n == ri->ri_rows) && (ri->ri_flg & RI_FULLCLEAR)) {
		FBC_WRITE(sc, CG6_FBC_ARECTY, 0);
		FBC_WRITE(sc, CG6_FBC_ARECTX, 0);
		FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_height - 1);
		FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_width - 1);
	} else {
		row *= ri->ri_font->fontheight;
		FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
		FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin);
		FBC_WRITE(sc, CG6_FBC_ARECTY,
		    ri->ri_yorigin + row + (n * ri->ri_font->fontheight) - 1);
		FBC_WRITE(sc, CG6_FBC_ARECTX,
		    ri->ri_xorigin + ri->ri_emuwidth - 1);
	}
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);

	return 0;
}

int
cgsix_ras_do_cursor(struct rasops_info *ri)
{
	struct cgsix_softc *sc = ri->ri_hw;
	int row, col;

	row = ri->ri_crow * ri->ri_font->fontheight;
	col = ri->ri_ccol * ri->ri_font->fontwidth;
	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FLIP);
	FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col);
	FBC_WRITE(sc, CG6_FBC_ARECTY,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_ARECTX,
	    ri->ri_xorigin + col + ri->ri_font->fontwidth - 1);
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);

	return 0;
}
@


1.58
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.57 2008/12/27 17:23:03 miod Exp $	*/
d77 3
a79 9
	cgsix_ioctl,
	cgsix_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgsix_burner,
@


1.57
log
@Sync the sparc64 fb* api with the recent changes done on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.56 2006/12/17 22:18:16 miod Exp $	*/
d68 5
a72 5
void cgsix_ras_copyrows(void *, int, int, int);
void cgsix_ras_copycols(void *, int, int, int, int);
void cgsix_ras_erasecols(void *, int, int, int, long int);
void cgsix_ras_eraserows(void *, int, int, long int);
void cgsix_ras_do_cursor(struct rasops_info *);
d797 1
a797 1
void
d804 1
a804 1
		return;
d818 1
a818 1
		return;
d842 2
d846 1
a846 1
void
d853 1
a853 1
		return;
d855 1
a855 1
		return;
d869 1
a869 1
		return;
d896 2
d900 1
a900 1
void
d908 1
a908 1
		return;
d916 1
a916 1
		return;
d940 2
d944 1
a944 1
void
d958 1
a958 1
		return;
d988 2
d992 1
a992 1
void
d1017 2
@


1.56
log
@Remove unnecessary <dev/wscons/wscons_raster.h> inclusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.55 2006/12/02 11:21:37 miod Exp $	*/
a55 5
int cgsix_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgsix_free_screen(void *, void *);
int cgsix_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
d79 3
a81 3
	cgsix_alloc_screen,
	cgsix_free_screen,
	cgsix_show_screen,
d200 6
a205 1
	fbwscons_init(&sc->sc_sunfb, console ? 0 : RI_CLEAR);
d226 1
a226 6
	printf(", %dx%d, rev %d\n", sc->sc_sunfb.sf_width,
	    sc->sc_sunfb.sf_height, rev);

	fbwscons_setcolormap(&sc->sc_sunfb, cgsix_setcolor);

	if (console) {
a227 1
	}
a493 33
	return (0);
}

int
cgsix_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct cgsix_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgsix_free_screen(void *v, void *cookie)
{
	struct cgsix_softc *sc = v;

	sc->sc_nscreens--;
}

int
cgsix_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
@


1.55
log
@Use the unpack_attr emulops instead of doing an inline rasops_unpack_attr.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.54 2006/07/25 21:23:32 miod Exp $	*/
a49 1
#include <dev/wscons/wscons_raster.h>
@


1.54
log
@Do not bother reading the existing colormap on attach, since we will
override it with the rasops one.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.53 2006/06/02 20:00:56 miod Exp $	*/
d941 1
d957 2
d968 1
a968 1
	FBC_WRITE(sc, CG6_FBC_FG, ri->ri_devcmap[(attr >> 16) & 0xf]);
d983 1
d994 2
d1005 1
a1005 1
	FBC_WRITE(sc, CG6_FBC_FG, ri->ri_devcmap[(attr >> 16) & 0xf]);
@


1.53
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.52 2005/03/15 18:40:16 miod Exp $	*/
d119 1
a119 1
	int node, console, i;
a200 8
	/* grab the current palette */
	BT_WRITE(sc, BT_ADDR, 0);
	for (i = 0; i < 256; i++) {
		sc->sc_cmap.cm_map[i][0] = BT_READ(sc, BT_CMAP) >> 24;
		sc->sc_cmap.cm_map[i][1] = BT_READ(sc, BT_CMAP) >> 24;
		sc->sc_cmap.cm_map[i][2] = BT_READ(sc, BT_CMAP) >> 24;
	}

d252 1
a252 1
;
@


1.52
log
@Take care of updating the PROMs view of the cursor position in the common fb
code, rather than doing this in only a subset of the fb drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.51 2005/03/08 21:35:03 miod Exp $	*/
a209 2

	sbus_establish(&sc->sc_sd, self);
@


1.51
log
@When failing to register an interrupt, display the correct priority on sparc64.

ok cloder@@ martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.50 2005/03/07 16:44:52 miod Exp $	*/
a78 1
void cgsix_ras_updatecursor(struct rasops_info *);
a242 1
		sc->sc_sunfb.sf_ro.ri_updatecursor = cgsix_ras_updatecursor;
a1052 11
}

void
cgsix_ras_updatecursor(struct rasops_info *ri)
{
	struct cgsix_softc *sc = ri->ri_hw;

	if (sc->sc_sunfb.sf_crowp != NULL)
		*sc->sc_sunfb.sf_crowp = ri->ri_crow;
	if (sc->sc_sunfb.sf_ccolp != NULL)
		*sc->sc_sunfb.sf_ccolp = ri->ri_ccol;
@


1.50
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.49 2005/03/03 01:52:41 miod Exp $	*/
d184 1
a184 1
		    sa->sa_pri, self->dv_xname);
@


1.49
log
@If we couldn't register an interrupt, don't abort attaching - we'll just
update colormaps immediately rather than waiting for the retrace interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.48 2005/03/03 01:41:11 miod Exp $	*/
d245 1
a245 1
		fbwscons_console_init(&sc->sc_sunfb, -1, cgsix_burner);
@


1.48
log
@Do not unmap more memory than we mapped earlier, in case of attachment failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.47 2005/03/01 21:23:36 miod Exp $	*/
d183 2
a184 2
		printf(": couldn't establish interrupt, pri %d\n", sa->sa_pri);
		goto fail_intr;
a251 2
fail_intr:
	bus_space_unmap(sa->sa_bustag, sc->sc_fbc_regs, CGSIX_FBC_SIZE);
d314 5
a318 1
		cgsix_loadcmap_deferred(sc, cm->index, cm->count);
@


1.47
log
@Display hardware name and display resolution at attach time, as done on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.46 2005/01/05 23:04:25 miod Exp $	*/
d257 1
a257 1
	bus_space_unmap(sa->sa_bustag, sc->sc_vid_regs, CGSIX_VID_SIZE);
@


1.46
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.45 2004/11/29 22:07:40 miod Exp $	*/
d120 1
a120 1
	int console, i;
d122 1
d124 1
d133 1
a133 1
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, sa->sa_node, 0);
d188 1
a188 1
	if (OF_getproplen(sa->sa_node, "width") != sizeof(u_int32_t))
d191 6
a196 1
	console = cgsix_is_console(sa->sa_node);
d238 2
a239 1
	printf("\n");
@


1.45
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.44 2003/07/03 21:02:13 jason Exp $	*/
d377 1
@


1.44
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.43 2003/06/24 21:54:38 henric Exp $	*/
a55 13
struct wsscreen_descr cgsix_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgsix_scrlist[] = {
	&cgsix_stdscreen,
	/* XXX other formats? */
};

struct wsscreen_list cgsix_screenlist = {
	sizeof(cgsix_scrlist) / sizeof(struct wsscreen_descr *), cgsix_scrlist
};

a119 1
	struct wsemuldisplaydev_attach_args waa;
a230 5
	cgsix_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgsix_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d237 1
a237 2
		fbwscons_console_init(&sc->sc_sunfb, &cgsix_stdscreen, -1,
		    cgsix_burner);
d240 1
a240 5
	waa.console = console;
	waa.scrdata = &cgsix_screenlist;
	waa.accessops = &cgsix_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.43
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.42 2003/06/18 17:35:30 miod Exp $	*/
d120 1
a120 3
cgsixmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d129 1
a129 3
cgsixattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d286 1
a286 6
cgsix_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d530 2
a531 6
cgsix_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d548 1
a548 3
cgsix_free_screen(v, cookie)
	void *v;
	void *cookie;
d556 2
a557 6
cgsix_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d569 1
a569 4
cgsix_mmap(v, off, prot)
	void *v;
	off_t off;
	int prot;
d621 1
a621 2
cgsix_is_console(node)
	int node;
d629 1
a629 3
cg6_bt_getcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d651 1
a651 3
cg6_bt_putcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d673 1
a673 3
cgsix_loadcmap_deferred(sc, start, ncolors)
	struct cgsix_softc *sc;
	u_int start, ncolors;
d684 1
a684 3
cgsix_loadcmap_immediate(sc, start, ncolors)
	struct cgsix_softc *sc;
	u_int start, ncolors;
d716 1
a716 3
cgsix_reset(sc, fhcrev)
	struct cgsix_softc *sc;
	u_int32_t fhcrev;
d749 1
a749 2
cgsix_hardreset(sc)
	struct cgsix_softc *sc;
d810 1
a810 3
cgsix_burner(vsc, on, flags)
	void *vsc;
	u_int on, flags;
d830 1
a830 2
cgsix_intr(vsc)
	void *vsc;
d851 1
a851 2
cgsix_ras_init(sc)
	struct cgsix_softc *sc;
d863 1
a863 3
cgsix_ras_copyrows(cookie, src, dst, n)
	void *cookie;
	int src, dst, n;
d910 1
a910 3
cgsix_ras_copycols(cookie, row, src, dst, n)
	void *cookie;
	int row, src, dst, n;
d962 1
a962 4
cgsix_ras_erasecols(cookie, row, col, n, attr)
	void *cookie;
	int row, col, n;
	long int attr;
d1001 1
a1001 4
cgsix_ras_eraserows(cookie, row, n, attr)
	void *cookie;
	int row, n;
	long int attr;
d1044 1
a1044 2
cgsix_ras_do_cursor(ri)
	struct rasops_info *ri;
d1071 1
a1071 2
cgsix_ras_updatecursor(ri)
	struct rasops_info *ri;
@


1.42
log
@Switch to fbxxx() API.
cgsix tested and ok jason@@, the rest tested by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.41 2003/06/02 18:32:41 jason Exp $	*/
d198 1
a198 1
	    IPL_TTY, 0, cgsix_intr, sc)) == NULL) {
@


1.41
log
@Nuke my clause 3 and 4 (and a couple of files jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.40 2003/05/31 21:01:59 jason Exp $	*/
d52 1
a57 5
	0, 0,	/* will be filled in -- XXX shouldn't, it's global. */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d81 1
a81 2
void cgsix_setcolor(struct cgsix_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t);
a85 1
static int a2int(char *, int);
a138 1
	long defattr;
d149 1
a149 4
	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);
d177 1
a177 1
	    sc->sc_linebytes * sc->sc_height, BUS_SPACE_MAP_LINEAR,
d225 1
a225 5
	sc->sc_rasops.ri_depth = sc->sc_depth;
	sc->sc_rasops.ri_stride = sc->sc_linebytes;
	sc->sc_rasops.ri_flg = RI_CENTER |
	    (console ? 0 : RI_CLEAR);
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
d227 2
a228 8
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));
	sc->sc_rasops.ri_hw = sc;
d237 1
a237 1
		sc->sc_dev.dv_cfdata->cf_flags |= CG6_CFFLAG_NOACCEL;
d239 7
a245 6
	if ((sc->sc_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL) == 0) {
		sc->sc_rasops.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_rasops.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_rasops.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_rasops.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_rasops.ri_do_cursor = cgsix_ras_do_cursor;
d249 4
a252 5
	cgsix_stdscreen.nrows = sc->sc_rasops.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_rasops.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_rasops.ri_ops;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
d256 1
a256 11
	cgsix_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
	cgsix_setcolor(sc, WSCOL_RED, 255, 0, 0);
	cgsix_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
	cgsix_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
	cgsix_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
	cgsix_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
	cgsix_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
	cgsix_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
	/* for cursor inversion */
	cgsix_setcolor(sc, (~WSCOL_WHITE) & 0xff, 0, 0, 0);
	cgsix_setcolor(sc, (~WSCOL_BLACK) & 0xff, 255, 255, 255);
d259 3
a261 10
		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_crowp = sc->sc_ccolp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;
		sc->sc_rasops.ri_updatecursor = cgsix_ras_updatecursor;

		wsdisplay_cnattach(&cgsix_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
d312 2
a313 2
		if ((sc->sc_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL)
		    == 0) {
d322 3
a324 3
		wdf->height = sc->sc_height;
		wdf->width  = sc->sc_width;
		wdf->depth  = sc->sc_depth;
d328 1
a328 1
		*(u_int *)data = sc->sc_linebytes;
d551 1
a551 1
	*cookiep = &sc->sc_rasops;
d554 1
a554 1
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
d621 1
a621 2
			sz = mo->mo_size ? mo->mo_size :
			    sc->sc_linebytes * sc->sc_height;
d632 1
a632 1
		if (off >= 0 && off < (sc->sc_linebytes * sc->sc_height))
a641 12
static int
a2int(char *cp, int deflt)
{
	int i = 0;

	if (*cp == '\0')
		return (deflt);
	while (*cp != '\0')
		i = i * 10 + *cp++ - '0';
	return (i);
}

d735 1
a735 4
cgsix_setcolor(sc, index, r, g, b)
	struct cgsix_softc *sc;
	u_int index;
	u_int8_t r, g, b;
d737 1
d1125 4
a1128 4
	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.40
log
@real register definitions for the brooktree 451/457/458 on the cgsix and
cgthree.  ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.39 2003/03/28 15:03:41 jason Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.39
log
@Fix the color inversion of the cursor (now it's not a solid block of black =)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.38 2003/03/28 03:18:03 jason Exp $	*/
d58 1
d533 15
a547 9
		BT_WRITE(sc, BT_ADDR, 1 << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x00ff0000)>> 16) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x0000ff00)>> 8) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x000000ff)>> 0) << 24);

		BT_WRITE(sc, BT_ADDR, 3 << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x00ff0000)>> 16) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x0000ff00)>> 8) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x000000ff)>> 0) << 24);
d562 1
d564 1
a564 1
			BT_WRITE(sc, BT_ADDR, 6 << 24);
d566 1
a566 1
			c |= 3 << 24;
d569 1
a569 1
			BT_WRITE(sc, BT_ADDR, 6 << 24);
d571 1
a571 1
			c &= ~(3 << 24);
d832 4
a835 3
	/* enable cursor in brooktree DAC */
	BT_WRITE(sc, BT_ADDR, 0x6 << 24);
	BT_WRITE(sc, BT_CTRL, BT_READ(sc, BT_CTRL) | (0x3 << 24));
d844 2
a845 2
	/* setup brooktree */
	BT_WRITE(sc, BT_ADDR, 0x04 << 24);
d850 2
a851 1
	BT_WRITE(sc, BT_ADDR, 0x05 << 24);
d856 5
a860 1
	BT_WRITE(sc, BT_ADDR, 0x06 << 24);
d862 2
a863 1
	BT_WRITE(sc, BT_CTRL, 0x70 << 24);
d866 2
a867 1
	BT_WRITE(sc, BT_ADDR, 0x07 << 24);
a870 1

@


1.38
log
@Use the brand new types instead of WSDISPLAY_TYPE_UNKNOWN
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.37 2003/03/28 00:23:05 miod Exp $	*/
a280 1
	cgsix_setcolor(sc, 255, 0, 0, 0);
d288 3
@


1.37
log
@If console acceleration was not enabled, do not reinitialize the blitter
when leaving X11.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.36 2003/03/27 18:06:48 jason Exp $	*/
d347 1
a347 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
@


1.36
log
@add support for *CURS* ioctls
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.35 2003/03/20 15:42:06 jason Exp $	*/
d351 6
a356 3
		if (sc->sc_mode != WSDISPLAYIO_MODE_EMUL &&
		    mode == WSDISPLAYIO_MODE_EMUL)
			cgsix_ras_init(sc);
@


1.35
log
@Compute linebytes and such earlier and use them to decide how much
memory to map.  (fixes the TGX+ running in 1280x1024x8 mode). ok miod, millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.34 2003/02/12 19:41:20 henric Exp $	*/
d103 2
d339 4
a342 1
	int error;
a365 1

a371 1

d379 48
a426 3

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
d428 4
d433 7
d441 5
a445 2
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d447 1
a447 1
		return -1; /* not supported yet */
d449 114
@


1.34
log
@Labels must be followed by a statement.  (Pointed out by gcc3.)

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.33 2002/09/10 03:18:59 jason Exp $	*/
d158 5
d189 2
a190 1
	    CGSIX_VID_SIZE, BUS_SPACE_MAP_LINEAR, 0, &sc->sc_vid_regs) != 0) {
a233 5

	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);
@


1.33
log
@Register more wsscreen properties to take advantage of wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.32 2002/08/31 21:18:48 jason Exp $	*/
d322 1
@


1.32
log
@Always setup the RAMDAC (even if we're not the console) so when the display
is cleared, it's cleared to a known color (white instead of whatever is put
in the ramdac by the prom, usually cyan).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.31 2002/08/16 02:54:54 jason Exp $	*/
d64 1
@


1.31
log
@Turn OFF (not ON) acceleration if revision < 5
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.30 2002/08/12 16:18:59 jason Exp $	*/
d276 10
a286 10
		cgsix_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
		cgsix_setcolor(sc, 255, 0, 0, 0);
		cgsix_setcolor(sc, WSCOL_RED, 255, 0, 0);
		cgsix_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
		cgsix_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
		cgsix_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
		cgsix_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
		cgsix_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
		cgsix_setcolor(sc, WSCOL_WHITE, 255, 255, 255);

@


1.30
log
@Update rom cursor position if we're the console framebuffer
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.29 2002/08/06 03:48:45 jason Exp $	*/
d257 1
a257 1
		sc->sc_dev.dv_cfdata->cf_flags &= ~CG6_CFFLAG_NOACCEL;
@


1.29
log
@Set RI_CLEAR if the card isn't the console framebuffer; based on discussion with miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.28 2002/08/05 22:12:32 miod Exp $	*/
d101 1
d248 1
a259 1
		sc->sc_rasops.ri_hw = sc;
a276 2
		int *ccolp, *crowp;

d287 7
a293 6
		if (romgetcursoraddr(&crowp, &ccolp))
			ccolp = crowp = NULL;
		if (ccolp != NULL)
			sc->sc_rasops.ri_ccol = *ccolp;
		if (crowp != NULL)
			sc->sc_rasops.ri_crow = *crowp;
d975 12
@


1.28
log
@Force acceleration to be turned off if we encounter an old hardware
revision.
Jason and I think that only someone out of his mind would plug an old
dusty dual slot cgsix in an ultrra, but it's better to be safe anyways.
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.27 2002/08/02 16:13:07 millert Exp $	*/
d236 2
a237 1
	sc->sc_rasops.ri_flg = RI_CENTER;
@


1.27
log
@Do correct bounds checking in get/set/put cmap routines.  A few of
these check were already OK but have been modified for consistency.
Problem found by Silvio Cesare.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.26 2002/07/30 23:03:30 jason Exp $	*/
d90 1
a90 1
void cgsix_reset(struct cgsix_softc *);
d146 1
d213 3
a215 1
	cgsix_reset(sc);
d247 9
d611 1
a611 1
cgsix_reset(sc)
d613 1
d615 1
a615 1
	u_int32_t fhc, rev;
a623 2
	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;
d625 1
a625 1
	if (rev < 5) {
d630 1
d634 1
a634 1
		if (rev < 2)
@


1.26
log
@- Whoops, I had the mode mask and value bits backwards
- make sure FBC_MODE is reset when switching back to WSDISPLAYIO_MODE_EMUL
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.25 2002/07/30 18:07:02 jason Exp $	*/
d509 1
a509 1
	if (index >= 256 || index + count > 256)
d533 1
a533 2
	if (index >= 256 || rcm->count > 256 ||
	    (rcm->index + rcm->count) > 256)
@


1.25
log
@- Allow disabling of console acceleration with cf_flags
- handle native and dumb mappings separately
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.24 2002/07/26 15:49:56 jason Exp $	*/
d322 1
d329 5
a333 1
		sc->sc_mode = *(u_int *)data;
a741 3
#if 0
	/* XXX doesn't work as advertised */
	FBC_WRITE(sc, CG6_FBC_MODE, m);
a743 1
#endif
@


1.24
log
@House cleaning (move reg defns into their own file), and be sure to drain
the CG6 before starting operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.23 2002/07/26 04:24:44 jason Exp $	*/
d243 10
a252 7
	sc->sc_rasops.ri_hw = sc;
	sc->sc_rasops.ri_ops.copyrows = cgsix_ras_copyrows;
	sc->sc_rasops.ri_ops.copycols = cgsix_ras_copycols;
	sc->sc_rasops.ri_ops.eraserows = cgsix_ras_eraserows;
	sc->sc_rasops.ri_ops.erasecols = cgsix_ras_erasecols;
	sc->sc_rasops.ri_do_cursor = cgsix_ras_do_cursor;
	cgsix_ras_init(sc);
d327 3
d413 6
d426 17
d444 1
a444 1
	if (off & PGOFSET)
d447 24
a470 4
	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (off >= 0 && off < (sc->sc_linebytes * sc->sc_height))
		return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
		    off + CGSIX_VID_OFFSET, prot, BUS_SPACE_MAP_LINEAR));
@


1.23
log
@add support for hardware accelerated fill/copy; from NetBSD (committed from the acceptably fast non-X11 console of a U1)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.22 2002/07/25 19:04:46 miod Exp $	*/
d57 1
a57 228

union bt_cmap {
	u_int8_t cm_map[256][3];	/* 256 r/b/g entries */
	u_int32_t cm_chip[256 * 3 / 4];	/* the way the chip is loaded */
};

#define	BT_ADDR		0x00		/* map address register */
#define	BT_CMAP		0x04		/* colormap data register */
#define	BT_CTRL		0x08		/* control register */
#define	BT_OMAP		0x0c		/* overlay (cursor) map register */

#define	BT_D4M3(x)	((((x) >> 2) << 1) + ((x) >> 2)) /* (x / 4) * 3 */
#define	BT_D4M4(x)	((x) & ~3)			 /* (x / 4) * 4 */

#define	CGSIX_ROM_OFFSET	0x000000
#define	CGSIX_BT_OFFSET		0x200000
#define	CGSIX_BT_SIZE		(sizeof(u_int32_t) * 4)
#define	CGSIX_DHC_OFFSET	0x240000
#define	CGSIX_ALT_OFFSET	0x280000
#define	CGSIX_FHC_OFFSET	0x300000
#define	CGSIX_FHC_SIZE		(sizeof(u_int32_t) * 1)
#define	CGSIX_THC_OFFSET	0x301000
#define	CGSIX_THC_SIZE		(sizeof(u_int32_t) * 640)
#define	CGSIX_FBC_OFFSET	0x700000
#define	CGSIX_FBC_SIZE		0x1000
#define	CGSIX_TEC_OFFSET	0x701000
#define	CGSIX_TEC_SIZE		(sizeof(u_int32_t) * 3)
#define	CGSIX_VID_OFFSET	0x800000
#define	CGSIX_VID_SIZE		(1024 * 1024)

#define	CG6_FHC			0x0		/* fhc register */

#define	FHC_FBID_MASK		0xff000000	/* frame buffer id */
#define	FHC_FBID_SHIFT		24
#define	FHC_REV_MASK		0x00f00000	/* revision */
#define	FHC_REV_SHIFT		20
#define	FHC_FROP_DISABLE	0x00080000	/* disable fast rasterop */
#define	FHC_ROW_DISABLE		0x00040000	/* ??? */
#define	FHC_SRC_DISABLE		0x00020000	/* ??? */
#define	FHC_DST_DISABLE		0x00010000	/* disable dst cache */
#define	FHC_RESET		0x00008000	/* ??? */
#define	FHC_LEBO		0x00002000	/* set little endian order */
#define	FHC_RES_MASK		0x00001800	/* resolution: */
#define	FHC_RES_1024		0x00000000	/*  1024x768 */
#define	FHC_RES_1152		0x00000800	/*  1152x900 */
#define	FHC_RES_1280		0x00001000	/*  1280x1024 */
#define	FHC_RES_1600		0x00001800	/*  1600x1200 */
#define	FHC_CPU_MASK		0x00000600	/* cpu type: */
#define	FHC_CPU_SPARC		0x00000000	/*  sparc */
#define	FHC_CPU_68020		0x00000200	/*  68020 */
#define	FHC_CPU_386		0x00000400	/*  i386 */
#define	FHC_TEST		0x00000100	/* test window */
#define	FHC_TESTX_MASK		0x000000f0	/* test window X */
#define	FHC_TESTX_SHIFT		4
#define	FHC_TESTY_MASK		0x0000000f	/* test window Y */
#define	FHC_TESTY_SHIFT		0

#define	CG6_FBC_MODE		0x004		/* mode setting */
#define	CG6_FBC_CLIP		0x008		/* ??? */
#define	CG6_FBC_S		0x010		/* global status */
#define	CG6_FBC_DRAW		0x014		/* drawing pipeline status */
#define	CG6_FBC_BLIT		0x018		/* blitter status */
#define	CG6_FBC_X0		0x080		/* blitter, src llx */
#define	CG6_FBC_Y0		0x084		/* blitter, src lly */
#define	CG6_FBC_X1		0x090		/* blitter, src urx */
#define	CG6_FBC_Y1		0x094		/* blitter, src ury */
#define	CG6_FBC_X2		0x0a0		/* blitter, dst llx */
#define	CG6_FBC_Y2		0x0a4		/* blitter, dst lly */
#define	CG6_FBC_X3		0x0b0		/* blitter, dst urx */
#define	CG6_FBC_Y3		0x0b4		/* blitter, dst ury */
#define	CG6_FBC_OFFX		0x0c0		/* x offset for drawing */
#define	CG6_FBC_OFFY		0x0c4		/* y offset for drawing */
#define	CG6_FBC_CLIPMINX	0x0e0		/* clip rectangle llx */
#define	CG6_FBC_CLIPMINY	0x0e4		/* clip rectangle lly */
#define	CG6_FBC_CLIPMAXX	0x0f0		/* clip rectangle urx */
#define	CG6_FBC_CLIPMAXY	0x0f4		/* clip rectangle ury */
#define	CG6_FBC_FG		0x100		/* fg value for rop */
#define	CG6_FBC_ALU		0x108		/* operation */
#define	CG6_FBC_ARECTX		0x900		/* rectangle drawing, x coord */
#define	CG6_FBC_ARECTY		0x904		/* rectangle drawing, y coord */

#define	FBC_MODE_MASK	(						\
	  0x00200000 /* GX_BLIT_SRC */					\
	| 0x00020000 /* GX_MODE_COLOR8 */				\
	| 0x00008000 /* GX_DRAW_RENDER */				\
	| 0x00002000 /* GX_BWRITE0_ENABLE */				\
	| 0x00001000 /* GX_BWRITE1_DISABLE */				\
	| 0x00000200 /* GX_BREAD_0 */					\
	| 0x00000080 /* GX_BDISP_0 */					\
)
#define FBC_MODE_VAL   (						\
	  0x00300000 /* GX_BLIT_ALL */					\
	| 0x00060000 /* GX_MODE_ALL */					\
	| 0x00018000 /* GX_DRAW_ALL */					\
	| 0x00006000 /* GX_BWRITE0_ALL */				\
	| 0x00001800 /* GX_BWRITE1_ALL */				\
	| 0x00000600 /* GX_BREAD_ALL */					\
	| 0x00000180 /* GX_BDISP_ALL */					\
)

#define	FBC_S_GXINPROGRESS	0x10000000	/* drawing in progress */

#define	FBC_BLIT_UNKNOWN	0x80000000	/* ??? */
#define	FBC_BLIT_GXFULL		0x20000000	/* queue is full */

#define	FBC_DRAW_UNKNOWN	0x80000000	/* ??? */
#define	FBC_DRAW_GXFULL		0x20000000

/* Value for the alu register for screen-to-screen copies */
#define FBC_ALU_COPY    (						\
	  0x80000000 /* GX_PLANE_ONES (ignore planemask register) */	\
	| 0x20000000 /* GX_PIXEL_ONES (ignore pixelmask register) */	\
	| 0x00800000 /* GX_ATTR_SUPP (function unknown) */		\
	| 0x00000000 /* GX_RAST_BOOL (function unknown) */		\
	| 0x00000000 /* GX_PLOT_PLOT (function unknown) */		\
	| 0x08000000 /* GX_PATTERN_ONES (ignore pattern) */		\
	| 0x01000000 /* GX_POLYG_OVERLAP (unsure - handle overlap?) */	\
	| 0x0000cccc /* ALU = src */					\
)

/* Value for the alu register for region fills */
#define FBC_ALU_FILL	(						\
	  0x80000000 /* GX_PLANE_ONES (ignore planemask register) */	\
	| 0x20000000 /* GX_PIXEL_ONES (ignore pixelmask register) */	\
	| 0x00800000 /* GX_ATTR_SUPP (function unknown) */		\
	| 0x00000000 /* GX_RAST_BOOL (function unknown) */		\
	| 0x00000000 /* GX_PLOT_PLOT (function unknown) */		\
	| 0x08000000 /* GX_PATTERN_ONES (ignore pattern) */		\
	| 0x01000000 /* GX_POLYG_OVERLAP (unsure - handle overlap?) */	\
	| 0x0000ff00 /* ALU = fg color */				\
)

/* Value for the alu register for toggling an area */
#define FBC_ALU_FLIP	(						\
	  0x80000000 /* GX_PLANE_ONES (ignore planemask register) */	\
	| 0x20000000 /* GX_PIXEL_ONES (ignore pixelmask register) */	\
	| 0x00800000 /* GX_ATTR_SUPP (function unknown) */		\
	| 0x00000000 /* GX_RAST_BOOL (function unknown) */		\
	| 0x00000000 /* GX_PLOT_PLOT (function unknown) */		\
	| 0x08000000 /* GX_PATTERN_ONES (ignore pattern) */		\
	| 0x01000000 /* GX_POLYG_OVERLAP (unsure - handle overlap?) */	\
	| 0x00005555 /* ALU = ~dst */					\
)

#define	CG6_TEC_MV		0x0		/* matrix stuff */
#define	CG6_TEC_CLIP		0x4		/* clipping stuff */
#define	CG6_TEC_VDC		0x8		/* ??? */

#define	CG6_THC_HSYNC1		0x800		/* horizontal sync timing */
#define	CG6_THC_HSYNC2		0x804		/* more hsync timing */
#define	CG6_THC_HSYNC3		0x808		/* yet more hsync timing */
#define	CG6_THC_VSYNC1		0x80c		/* vertical sync timing */
#define	CG6_THC_VSYNC2		0x810		/* only two of these */
#define	CG6_THC_REFRESH		0x814		/* refresh counter */
#define	CG6_THC_MISC		0x818		/* misc control/status */
#define	CG6_THC_CURSXY		0x8fc		/* cursor x/y, 16 bit each */
#define	CG6_THC_CURSMASK	0x900		/* cursor mask bits */
#define	CG6_THC_CURSBITS	0x980		/* cursor bits */

/* cursor x/y position for 'off' */
#define	THC_CURSOFF		((65536-32) | ((65536-32) << 16))

#define	THC_MISC_REV_M		0x000f0000	/* chip revision */
#define	THC_MISC_REV_S		16
#define	THC_MISC_RESET		0x00001000	/* reset */
#define	THC_MISC_VIDEN		0x00000400	/* video enable */
#define	THC_MISC_SYNC		0x00000200	/* not sure what ... */
#define	THC_MISC_VSYNC		0x00000100	/* ... these really are */
#define	THC_MISC_SYNCEN		0x00000080	/* sync enable */
#define	THC_MISC_CURSRES	0x00000040	/* cursor resolution */
#define	THC_MISC_INTEN		0x00000020	/* v.retrace intr enable */
#define	THC_MISC_INTR		0x00000010	/* intr pending/ack */
#define	THC_MISC_CYCLS		0x0000000f	/* cycles before transfer */

struct cgsix_softc {
	struct device sc_dev;
	struct sbusdev sc_sd;
	bus_space_tag_t sc_bustag;
	bus_addr_t sc_paddr;
	bus_space_handle_t sc_bt_regs;
	bus_space_handle_t sc_fhc_regs;
	bus_space_handle_t sc_thc_regs;
	bus_space_handle_t sc_tec_regs;
	bus_space_handle_t sc_vid_regs;
	bus_space_handle_t sc_fbc_regs;
	struct rasops_info sc_rasops;
	int sc_nscreens;
	int sc_width, sc_height, sc_depth, sc_linebytes;
	union bt_cmap sc_cmap;
	void *sc_ih;
};

#define	CG6_USER_FBC	0x70000000
#define	CG6_USER_TEC	0x70001000
#define	CG6_USER_BTREGS	0x70002000
#define	CG6_USER_FHC	0x70004000
#define	CG6_USER_THC	0x70005000
#define	CG6_USER_ROM	0x70006000
#define	CG6_USER_RAM	0x70016000
#define	CG6_USER_DHC	0x80000000

#define	THC_READ(sc,r) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_thc_regs, (r))
#define	THC_WRITE(sc,r,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_thc_regs, (r), (v))

#define	TEC_READ(sc,r) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_tec_regs, (r))
#define	TEC_WRITE(sc,r,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_tec_regs, (r), (v))

#define	FHC_READ(sc) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_fhc_regs, CG6_FHC)
#define	FHC_WRITE(sc,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_fhc_regs, CG6_FHC, (v))

#define	FBC_READ(sc,r) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_fbc_regs, (r))
#define	FBC_WRITE(sc,r,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_fbc_regs, (r), (v))

#define	BT_WRITE(sc, reg, val) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_bt_regs, (reg), (val))
#define	BT_READ(sc, reg) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_bt_regs, (reg))
#define	BT_BARRIER(sc,reg,flags) \
    bus_space_barrier((sc)->sc_bustag, (sc)->sc_bt_regs, (reg), \
	sizeof(u_int32_t), (flags))
a248 1
#if 0
a249 1
#endif
a678 11
#define CG6_BLIT_WAIT(sc)					\
	while ((FBC_READ(sc, CG6_FBC_BLIT) &			\
	    (FBC_BLIT_UNKNOWN|FBC_BLIT_GXFULL)) ==		\
	    (FBC_BLIT_UNKNOWN|FBC_BLIT_GXFULL))
#define CG6_DRAW_WAIT(sc)					\
	while ((FBC_READ(sc, CG6_FBC_DRAW) &			\
	    (FBC_DRAW_UNKNOWN|FBC_DRAW_GXFULL)) ==		\
	    (FBC_DRAW_UNKNOWN|FBC_DRAW_GXFULL))
#define	CG6_DRAIN(sc)						\
	while (FBC_READ(sc, CG6_FBC_S) & FBC_S_GXINPROGRESS)

d688 3
d693 1
@


1.22
log
@Adapt the framebuffer code to the WSDISPLAY_TYPE constant changes, and
add the necessary magic for wsemul_sun color handling.

Initially based on a patch from jason@@, then some tinkering by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.21 2002/06/03 02:32:06 jason Exp $	*/
d81 1
d114 87
d241 1
d273 5
d322 6
d383 1
a383 1
	 * Map just BT, FHC, THC, and video RAM.
d387 1
a387 1
	    CGSIX_BT_SIZE, BUS_SPACE_MAP_LINEAR, 0, &sc->sc_bt_regs) != 0) {
d394 1
a394 1
	    CGSIX_FHC_SIZE, BUS_SPACE_MAP_LINEAR, 0, &sc->sc_fhc_regs) != 0) {
d401 1
a401 1
	    CGSIX_THC_SIZE, BUS_SPACE_MAP_LINEAR, 0, &sc->sc_thc_regs) != 0) {
d415 1
a415 1
	    CGSIX_TEC_SIZE, BUS_SPACE_MAP_LINEAR, 0, &sc->sc_tec_regs) != 0) {
d420 7
d470 9
d521 2
d906 243
@


1.21
log
@Convert from rcons to rasops
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.20 2002/05/21 20:25:28 jason Exp $	*/
d368 1
a368 1
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, &defattr);
d376 1
a376 1
		cgsix_setcolor(sc, 255, 255, 255, 255);
d492 1
a492 1
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, attrp);
@


1.20
log
@Enable the blanker now that the X stuff is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.19 2002/04/08 17:49:42 jason Exp $	*/
d56 1
a56 1
#include <dev/rcons/raster.h>
d153 1
a155 2
	struct rcons sc_rcons;
	struct raster sc_raster;
a191 11
struct wsdisplay_emulops cgsix_emulops = {
	rcons_cursor,
	rcons_mapchar,
	rcons_putchar,
	rcons_copycols,
	rcons_erasecols,
	rcons_copyrows,
	rcons_eraserows,
	rcons_alloc_attr
};

d351 4
a354 6
	sc->sc_rcons.rc_sp = &sc->sc_raster;
	sc->sc_raster.width = sc->sc_width;
	sc->sc_raster.height = sc->sc_height;
	sc->sc_raster.depth = sc->sc_depth;
	sc->sc_raster.linelongs = sc->sc_linebytes / 4;
	sc->sc_raster.pixels = (void *)bus_space_vaddr(sc->sc_bustag,
d356 13
a368 20

	if (console == 0 ||
	    romgetcursoraddr(&sc->sc_rcons.rc_crowp, &sc->sc_rcons.rc_ccolp)) {
		sc->sc_rcons.rc_crow = sc->sc_rcons.rc_ccol = -1;
		sc->sc_rcons.rc_crowp = &sc->sc_rcons.rc_crow;
		sc->sc_rcons.rc_ccolp = &sc->sc_rcons.rc_ccol;
	}

	sc->sc_rcons.rc_maxcol =
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80);
	sc->sc_rcons.rc_maxrow =
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34);

	rcons_init(&sc->sc_rcons,
	    sc->sc_rcons.rc_maxrow, sc->sc_rcons.rc_maxcol);

	cgsix_stdscreen.nrows = sc->sc_rcons.rc_maxrow;
	cgsix_stdscreen.ncols = sc->sc_rcons.rc_maxcol;
	cgsix_stdscreen.textops = &cgsix_emulops;
	rcons_alloc_attr(&sc->sc_rcons, 0, 0, 0, &defattr);
d373 2
d385 9
a393 2
		wsdisplay_cnattach(&cgsix_stdscreen, &sc->sc_rcons,
		    *sc->sc_rcons.rc_ccolp, *sc->sc_rcons.rc_crowp, defattr);
d488 5
a492 4
	*cookiep = &sc->sc_rcons;
	*curyp = *sc->sc_rcons.rc_crowp;
	*curxp = *sc->sc_rcons.rc_ccolp;
	rcons_alloc_attr(&sc->sc_rcons, 0, 0, 0, attrp);
@


1.19
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.18 2002/03/29 09:45:30 fgsch Exp $	*/
d250 1
a250 1
	NULL,	/* burner */
@


1.18
log
@o remove extra args in printf's.
o remove unneded struct.
o change error to match reality.

jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.17 2002/03/14 03:16:07 millert Exp $	*/
d32 5
@


1.17
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.16 2002/03/14 01:27:02 millert Exp $	*/
a187 6
struct mmo {
	u_long	mo_uaddr;		/* user (virtual address */
	u_long	mo_size;		/* size, or 0 for video ram size */
	u_long	mo_physoff;		/* offset from sc_physadr */
};

d295 1
a295 1
		printf(": cannot map bt registers\n", self->dv_xname);
d302 1
a302 1
		printf(": cannot map fhc registers\n", self->dv_xname);
d309 1
a309 1
		printf(": cannot map thc registers\n", self->dv_xname);
d316 1
a316 1
		printf(": cannot map vid registers\n", self->dv_xname);
d323 1
a323 1
		printf(": cannot map tec registers\n", self->dv_xname);
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.15 2002/03/14 01:14:22 jason Exp $	*/
d226 2
a227 2
int cgsix_show_screen __P((void *, void *, int,
    void (*cb)(void *, int, int), void *));
@


1.15
log
@Reload the palette only during the vert retrace interrupt
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.14 2002/03/04 23:32:52 jason Exp $	*/
d222 4
a225 4
int cgsix_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
int cgsix_alloc_screen __P((void *, const struct wsscreen_descr *, void **,
    int *, int *, long *));
void cgsix_free_screen __P((void *, void *));
d227 14
a240 14
    void (*cb) __P((void *, int, int)), void *));
paddr_t cgsix_mmap __P((void *, off_t, int));
int cgsix_is_console __P((int));
int cg6_bt_getcmap __P((union bt_cmap *, struct wsdisplay_cmap *));
int cg6_bt_putcmap __P((union bt_cmap *, struct wsdisplay_cmap *));
void cgsix_loadcmap_immediate __P((struct cgsix_softc *, u_int, u_int));
void cgsix_loadcmap_deferred __P((struct cgsix_softc *, u_int, u_int));
void cgsix_setcolor __P((struct cgsix_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t));
void cgsix_reset __P((struct cgsix_softc *));
void cgsix_hardreset __P((struct cgsix_softc *));
void cgsix_burner __P((void *, u_int, u_int));
int cgsix_intr __P((void *));
static int a2int __P((char *, int));
d254 2
a255 2
int	cgsixmatch	__P((struct device *, void *, void *));
void	cgsixattach	__P((struct device *, struct device *, void *));
d524 1
a524 1
	void (*cb) __P((void *, int, int));
@


1.14
log
@Disable the wscons burner functionality... I'm not in the mood to debug it right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.13 2002/02/24 18:51:29 jason Exp $	*/
d153 1
d232 2
a233 1
void cgsix_loadcmap __P((struct cgsix_softc *, u_int, u_int));
d239 1
d333 6
d362 1
a362 1
	sbus_establish(&sc->sc_sd, &sc->sc_dev);
d417 2
d471 1
a471 1
		cgsix_loadcmap(sc, cm->index, cm->count);
d620 14
a633 1
cgsix_loadcmap(sc, start, ncolors)
d665 1
a665 1
	cgsix_loadcmap(sc, index, 1);
d778 22
@


1.13
log
@Proper screenblank semantics
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.12 2002/02/23 05:47:50 jason Exp $	*/
d248 1
a248 1
	cgsix_burner,
@


1.12
log
@Add burner function so wscons can blank the fb
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.11 2002/02/07 16:39:48 jason Exp $	*/
d346 1
a346 1
	cgsix_burner(sc, 0, 0);
d745 1
a745 1
	if (!on)
@


1.11
log
@Do a more complete initialization if the prom didn't do it for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.10 2002/02/07 04:44:52 jason Exp $	*/
d236 1
a236 2
void cgsix_blank __P((struct cgsix_softc *, int));

d245 4
a248 1
	0 /* load_font */
d346 1
a346 1
	cgsix_blank(sc, 0);
d735 3
a737 3
cgsix_blank(sc, blank)
	struct cgsix_softc *sc;
	int blank;
d739 1
d745 1
a745 3
	if (blank)
		thcm &= ~(THC_MISC_VIDEN | THC_MISC_SYNCEN);
	else
d747 5
@


1.10
log
@use bus_space_vaddr
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.9 2002/02/06 18:40:56 jason Exp $	*/
d126 1
a126 1
#define	THC_MISC_REV_M		0x000f0000
d128 1
a128 1
#define	THC_MISC_RESET		0x00001000	/* ??? */
d136 1
d183 3
a185 7

#define	BT_INIT(sc) do {					\
	BT_WRITE((sc), BT_ADDR, 0x06);	/* command reg */	\
	BT_WRITE((sc), BT_CTRL, 0x73);	/* overlay plane */	\
	BT_WRITE((sc), BT_ADDR, 0x04);  /* read mask */		\
	BT_WRITE((sc), BT_CTRL, 0xff);	/* color planes */	\
} while (0)
d235 1
d328 4
d334 2
a343 1
	cgsix_reset(sc);
d346 4
a349 15
	sc->sc_depth = getpropint(sa->sa_node, "depth", -1);
	if (sc->sc_depth == -1)
		sc->sc_depth = 8;

	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", -1);
	if (sc->sc_linebytes == -1)
		sc->sc_linebytes = 1152;

	sc->sc_height = getpropint(sa->sa_node, "height", -1);
	if (sc->sc_height == -1)
		sc->sc_height = 900;

	sc->sc_width = getpropint(sa->sa_node, "width", -1);
	if (sc->sc_width == -1)
		sc->sc_width = 1152;
d674 56
@


1.9
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.8 2002/02/06 18:20:34 jason Exp $	*/
d366 2
a367 1
	sc->sc_raster.pixels = (void *)sc->sc_vid_regs;
@


1.8
log
@non console framebuffers, reset and initialize them correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.7 2002/02/05 20:00:04 jason Exp $	*/
a62 12
#define	BT_WRITE(sc, reg, val) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_bt_regs, (reg), (val))
#define	BT_READ(sc, reg) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_bt_regs, (reg))

#define	BT_INIT(sc) do {					\
	BT_WRITE((sc), BT_ADDR, 0x06);	/* command reg */	\
	BT_WRITE((sc), BT_CTRL, 0x73);	/* overlay plane */	\
	BT_WRITE((sc), BT_ADDR, 0x04);  /* read mask */		\
	BT_WRITE((sc), BT_CTRL, 0xff);	/* color planes */	\
} while (0)

d163 27
a647 15

#define	THC_READ(sc,r) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_thc_regs, (r))
#define	THC_WRITE(sc,r,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_thc_regs, (r), (v))

#define	TEC_READ(sc,r) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_tec_regs, (r))
#define	TEC_WRITE(sc,r,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_tec_regs, (r), (v))

#define	FHC_READ(sc) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_fhc_regs, CG6_FHC)
#define	FHC_WRITE(sc,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_fhc_regs, CG6_FHC, (v))
@


1.7
log
@Allow mapping as a dumb framebuffer (from offset 0)... This allows us to
get as far here as with vgafb.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.6 2002/02/05 18:34:39 jason Exp $	*/
d89 1
d93 56
d157 1
d222 2
d308 7
d317 1
d325 3
d398 2
d632 67
@


1.6
log
@Implement vgafb_mmap() fully
From NetBSD: change bus_space_mmap() prototype to standard one
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.5 2002/01/06 00:49:41 jason Exp $	*/
a442 14
	struct mmo *mo;
	u_int u, sz;

	static struct mmo mmo[] = {
		{ CG6_USER_RAM, 0, CGSIX_VID_OFFSET },
		{ CG6_USER_FBC, 1, CGSIX_FBC_OFFSET },
		{ CG6_USER_TEC, 1, CGSIX_TEC_OFFSET },
		{ CG6_USER_BTREGS, 8192 /* XXX */, CGSIX_BT_OFFSET },
		{ CG6_USER_FHC, 1, CGSIX_FHC_OFFSET },
		{ CG6_USER_THC, 1, CGSIX_THC_OFFSET },
		{ CG6_USER_ROM, 1, CGSIX_ROM_OFFSET },
		{ CG6_USER_DHC, 1, CGSIX_DHC_OFFSET },
	};
#define	NMMO	(sizeof(mmo) / sizeof(*mmo))
d447 4
a450 18
	/*
	 * Entries with size 0 map video RAM (i.e., the size in fb data).
	 *
	 * Since we work in pages, the fact that the map offset table's
	 * sizes are sometimes bizarre (e.g., 1) is effectively ignored:
	 * one byte is as good as one page.
	 */
	for (mo = mmo; mo < &mmo[NMMO]; mo++) {
		if ((u_long)off < mo->mo_uaddr)
			continue;
		u = off - mo->mo_uaddr;
		sz = mo->mo_size ? mo->mo_size :
		    sc->sc_linebytes * sc->sc_height;
		if (u < sz)
			return (bus_space_mmap(sc->sc_bustag,
			    sc->sc_paddr, u + mo->mo_physoff,
			    prot, BUS_SPACE_MAP_LINEAR));
	}
@


1.5
log
@Claim to support WSSCREEN_WSCOLORS (drivers support it, but rcons doesn't
appear to).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.4 2002/01/04 19:39:06 jason Exp $	*/
a96 1
	bus_type_t sc_btype;
a209 1
	sc->sc_btype = (bus_type_t)sa->sa_slot;
d474 4
a477 9
		if (u < sz) {
			bus_space_handle_t bh;

			if (bus_space_mmap(sc->sc_bustag, sc->sc_btype,
			    sc->sc_paddr + u + mo->mo_physoff,
			    BUS_SPACE_MAP_LINEAR, &bh))
				return (-1);
			return ((paddr_t)bh);
		}
@


1.4
log
@Add handling for cmap get/put (mostly from sparc)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.3 2002/01/04 01:13:29 jason Exp $	*/
d140 1
a140 1
	WSSCREEN_REVERSE
@


1.3
log
@add mmap functionality (most from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.2 2001/12/05 05:38:28 jason Exp $	*/
d53 25
d106 1
d160 5
d207 1
a207 1
	int console;
d252 7
d306 11
a316 1
	if (console)
d319 1
d348 1
d350 1
a366 1
#if 0
d368 6
a373 1
		return vgafb_getcmap(vc, (struct wsdisplay_cmap *)data);
d375 6
a380 2
		return vgafb_putcmap(vc, (struct wsdisplay_cmap *)data);
#endif
d509 85
@


1.2
log
@Same stuff as cgthree:
- fix initialization so that the cursor is initialized to be in the same
place the prom left it.
- remove some trial and error #if 0 stuff
- fix copyo's in a2int()
- ditch *_romcursoraddr for a direct call to romgetcursoraddr()
- allow this to attach (without panic()) if it is not the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.1 2001/12/04 20:07:06 jason Exp $	*/
d53 1
d56 2
d62 2
d71 2
d83 15
d180 2
d380 1
a380 1
cgsix_mmap(v, offset, prot)
d382 1
a382 1
	off_t offset;
a384 1
#if 0
d386 14
a399 1
#endif
d401 1
a401 1
	if (offset & PGOFSET)
d403 25
@


1.2.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.5 2002/01/06 00:49:41 jason Exp $	*/
a52 26
union bt_cmap {
	u_int8_t cm_map[256][3];	/* 256 r/b/g entries */
	u_int32_t cm_chip[256 * 3 / 4];	/* the way the chip is loaded */
};

#define	BT_ADDR		0x00		/* map address register */
#define	BT_CMAP		0x04		/* colormap data register */
#define	BT_CTRL		0x08		/* control register */
#define	BT_OMAP		0x0c		/* overlay (cursor) map register */

#define	BT_WRITE(sc, reg, val) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_bt_regs, (reg), (val))
#define	BT_READ(sc, reg) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_bt_regs, (reg))

#define	BT_INIT(sc) do {					\
	BT_WRITE((sc), BT_ADDR, 0x06);	/* command reg */	\
	BT_WRITE((sc), BT_CTRL, 0x73);	/* overlay plane */	\
	BT_WRITE((sc), BT_ADDR, 0x04);  /* read mask */		\
	BT_WRITE((sc), BT_CTRL, 0xff);	/* color planes */	\
} while (0)

#define	BT_D4M3(x)	((((x) >> 2) << 1) + ((x) >> 2)) /* (x / 4) * 3 */
#define	BT_D4M4(x)	((x) & ~3)			 /* (x / 4) * 4 */

#define	CGSIX_ROM_OFFSET	0x000000
a54 2
#define	CGSIX_DHC_OFFSET	0x240000
#define	CGSIX_ALT_OFFSET	0x280000
a58 2
#define	CGSIX_FBC_OFFSET	0x700000
#define	CGSIX_TEC_OFFSET	0x701000
a65 2
	bus_addr_t sc_paddr;
	bus_type_t sc_btype;
a73 16
	union bt_cmap sc_cmap;
};

#define	CG6_USER_FBC	0x70000000
#define	CG6_USER_TEC	0x70001000
#define	CG6_USER_BTREGS	0x70002000
#define	CG6_USER_FHC	0x70004000
#define	CG6_USER_THC	0x70005000
#define	CG6_USER_ROM	0x70006000
#define	CG6_USER_RAM	0x70016000
#define	CG6_USER_DHC	0x80000000

struct mmo {
	u_long	mo_uaddr;		/* user (virtual address */
	u_long	mo_size;		/* size, or 0 for video ram size */
	u_long	mo_physoff;		/* offset from sc_physadr */
d92 1
a92 1
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
a111 5
int cg6_bt_getcmap __P((union bt_cmap *, struct wsdisplay_cmap *));
int cg6_bt_putcmap __P((union bt_cmap *, struct wsdisplay_cmap *));
void cgsix_loadcmap __P((struct cgsix_softc *, u_int, u_int));
void cgsix_setcolor __P((struct cgsix_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t));
d154 1
a154 1
	int console, i;
a157 2
	sc->sc_btype = (bus_type_t)sa->sa_slot;
	sc->sc_paddr = sbus_bus_addr(sa->sa_bustag, sa->sa_slot, sa->sa_offset);
a196 7
	BT_WRITE(sc, BT_ADDR, 0);
	for (i = 0; i < 256; i++) {
		sc->sc_cmap.cm_map[i][0] = BT_READ(sc, BT_CMAP) >> 24;
		sc->sc_cmap.cm_map[i][1] = BT_READ(sc, BT_CMAP) >> 24;
		sc->sc_cmap.cm_map[i][2] = BT_READ(sc, BT_CMAP) >> 24;
	}

d244 1
a244 11
	if (console) {
		cgsix_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
		cgsix_setcolor(sc, 255, 255, 255, 255);
		cgsix_setcolor(sc, WSCOL_RED, 255, 0, 0);
		cgsix_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
		cgsix_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
		cgsix_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
		cgsix_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
		cgsix_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
		cgsix_setcolor(sc, WSCOL_WHITE, 255, 255, 255);

a246 1
	}
a274 1
	struct wsdisplay_cmap *cm;
a275 1
	int error;
d292 1
d294 1
a294 6
		cm = (struct wsdisplay_cmap *)data;
		error = cg6_bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

d296 2
a297 6
		cm = (struct wsdisplay_cmap *)data;
		error = cg6_bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgsix_loadcmap(sc, cm->index, cm->count);
		break;
d356 1
a356 1
cgsix_mmap(v, off, prot)
d358 1
a358 1
	off_t off;
d361 1
d363 1
a363 14
	struct mmo *mo;
	u_int u, sz;

	static struct mmo mmo[] = {
		{ CG6_USER_RAM, 0, CGSIX_VID_OFFSET },
		{ CG6_USER_FBC, 1, CGSIX_FBC_OFFSET },
		{ CG6_USER_TEC, 1, CGSIX_TEC_OFFSET },
		{ CG6_USER_BTREGS, 8192 /* XXX */, CGSIX_BT_OFFSET },
		{ CG6_USER_FHC, 1, CGSIX_FHC_OFFSET },
		{ CG6_USER_THC, 1, CGSIX_THC_OFFSET },
		{ CG6_USER_ROM, 1, CGSIX_ROM_OFFSET },
		{ CG6_USER_DHC, 1, CGSIX_DHC_OFFSET },
	};
#define	NMMO	(sizeof(mmo) / sizeof(*mmo))
d365 1
a365 1
	if (off & PGOFSET)
a366 25

	/*
	 * Entries with size 0 map video RAM (i.e., the size in fb data).
	 *
	 * Since we work in pages, the fact that the map offset table's
	 * sizes are sometimes bizarre (e.g., 1) is effectively ignored:
	 * one byte is as good as one page.
	 */
	for (mo = mmo; mo < &mmo[NMMO]; mo++) {
		if ((u_long)off < mo->mo_uaddr)
			continue;
		u = off - mo->mo_uaddr;
		sz = mo->mo_size ? mo->mo_size :
		    sc->sc_linebytes * sc->sc_height;
		if (u < sz) {
			bus_space_handle_t bh;

			if (bus_space_mmap(sc->sc_bustag, sc->sc_btype,
			    sc->sc_paddr + u + mo->mo_physoff,
			    BUS_SPACE_MAP_LINEAR, &bh))
				return (-1);
			return ((paddr_t)bh);
		}
	}

a388 85
}

int
cg6_bt_getcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || index + count > 256)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyout(&bcm->cm_map[index + i][0],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][1],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][2],
		    &rcm->blue[i], 1)) != 0)
			return (error);
	}
	return (0);
}

int
cg6_bt_putcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || rcm->count > 256 ||
	    (rcm->index + rcm->count) > 256)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &bcm->cm_map[index + i][0], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &bcm->cm_map[index + i][1], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &bcm->cm_map[index + i][2], 1)) != 0)
			return (error);
	}
	return (0);
}

void
cgsix_loadcmap(sc, start, ncolors)
	struct cgsix_softc *sc;
	u_int start, ncolors;
{
	u_int cstart;
	u_int32_t v;
	int count;

	cstart = BT_D4M3(start);
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	BT_WRITE(sc, BT_ADDR, BT_D4M4(start) << 24);
	while (--count >= 0) {
		v = sc->sc_cmap.cm_chip[cstart];
		BT_WRITE(sc, BT_CMAP, v << 0);
		BT_WRITE(sc, BT_CMAP, v << 8);
		BT_WRITE(sc, BT_CMAP, v << 16);
		BT_WRITE(sc, BT_CMAP, v << 24);
		cstart++;
	}
}

void
cgsix_setcolor(sc, index, r, g, b)
	struct cgsix_softc *sc;
	u_int index;
	u_int8_t r, g, b;
{
	union bt_cmap *bcm = &sc->sc_cmap;

	bcm->cm_map[index][0] = r;
	bcm->cm_map[index][1] = g;
	bcm->cm_map[index][2] = b;
	cgsix_loadcmap(sc, index, 1);
@


1.2.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.2.2.1 2002/01/31 22:55:38 niklas Exp $	*/
a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d51 1
a51 1
#include <dev/rasops/rasops.h>
d63 12
a88 1
#define	CGSIX_TEC_SIZE		(sizeof(u_int32_t) * 3)
a91 57
#define	CG6_FHC			0x0		/* fhc register */

#define	FHC_FBID_MASK		0xff000000	/* frame buffer id */
#define	FHC_FBID_SHIFT		24
#define	FHC_REV_MASK		0x00f00000	/* revision */
#define	FHC_REV_SHIFT		20
#define	FHC_FROP_DISABLE	0x00080000	/* disable fast rasterop */
#define	FHC_ROW_DISABLE		0x00040000	/* ??? */
#define	FHC_SRC_DISABLE		0x00020000	/* ??? */
#define	FHC_DST_DISABLE		0x00010000	/* disable dst cache */
#define	FHC_RESET		0x00008000	/* ??? */
#define	FHC_LEBO		0x00002000	/* set little endian order */
#define	FHC_RES_MASK		0x00001800	/* resolution: */
#define	FHC_RES_1024		0x00000000	/*  1024x768 */
#define	FHC_RES_1152		0x00000800	/*  1152x900 */
#define	FHC_RES_1280		0x00001000	/*  1280x1024 */
#define	FHC_RES_1600		0x00001800	/*  1600x1200 */
#define	FHC_CPU_MASK		0x00000600	/* cpu type: */
#define	FHC_CPU_SPARC		0x00000000	/*  sparc */
#define	FHC_CPU_68020		0x00000200	/*  68020 */
#define	FHC_CPU_386		0x00000400	/*  i386 */
#define	FHC_TEST		0x00000100	/* test window */
#define	FHC_TESTX_MASK		0x000000f0	/* test window X */
#define	FHC_TESTX_SHIFT		4
#define	FHC_TESTY_MASK		0x0000000f	/* test window Y */
#define	FHC_TESTY_SHIFT		0

#define	CG6_TEC_MV		0x0		/* matrix stuff */
#define	CG6_TEC_CLIP		0x4		/* clipping stuff */
#define	CG6_TEC_VDC		0x8		/* ??? */

#define	CG6_THC_HSYNC1		0x800		/* horizontal sync timing */
#define	CG6_THC_HSYNC2		0x804		/* more hsync timing */
#define	CG6_THC_HSYNC3		0x808		/* yet more hsync timing */
#define	CG6_THC_VSYNC1		0x80c		/* vertical sync timing */
#define	CG6_THC_VSYNC2		0x810		/* only two of these */
#define	CG6_THC_REFRESH		0x814		/* refresh counter */
#define	CG6_THC_MISC		0x818		/* misc control/status */
#define	CG6_THC_CURSXY		0x8fc		/* cursor x/y, 16 bit each */
#define	CG6_THC_CURSMASK	0x900		/* cursor mask bits */
#define	CG6_THC_CURSBITS	0x980		/* cursor bits */

/* cursor x/y position for 'off' */
#define	THC_CURSOFF		((65536-32) | ((65536-32) << 16))

#define	THC_MISC_REV_M		0x000f0000	/* chip revision */
#define	THC_MISC_REV_S		16
#define	THC_MISC_RESET		0x00001000	/* reset */
#define	THC_MISC_VIDEN		0x00000400	/* video enable */
#define	THC_MISC_SYNC		0x00000200	/* not sure what ... */
#define	THC_MISC_VSYNC		0x00000100	/* ... these really are */
#define	THC_MISC_SYNCEN		0x00000080	/* sync enable */
#define	THC_MISC_CURSRES	0x00000040	/* cursor resolution */
#define	THC_MISC_INTEN		0x00000020	/* v.retrace intr enable */
#define	THC_MISC_INTR		0x00000010	/* intr pending/ack */
#define	THC_MISC_CYCLS		0x0000000f	/* cycles before transfer */

d97 1
a100 1
	bus_space_handle_t sc_tec_regs;
a101 1
	struct rasops_info sc_rasops;
d104 2
a106 1
	void *sc_ih;
d118 5
a122 14
#define	THC_READ(sc,r) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_thc_regs, (r))
#define	THC_WRITE(sc,r,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_thc_regs, (r), (v))

#define	TEC_READ(sc,r) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_tec_regs, (r))
#define	TEC_WRITE(sc,r,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_tec_regs, (r), (v))

#define	FHC_READ(sc) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_fhc_regs, CG6_FHC)
#define	FHC_WRITE(sc,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_fhc_regs, CG6_FHC, (v))
d124 10
a133 7
#define	BT_WRITE(sc, reg, val) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_bt_regs, (reg), (val))
#define	BT_READ(sc, reg) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_bt_regs, (reg))
#define	BT_BARRIER(sc,reg,flags) \
    bus_space_barrier((sc)->sc_bustag, (sc)->sc_bt_regs, (reg), \
	sizeof(u_int32_t), (flags))
d152 15
a166 19
int cgsix_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgsix_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgsix_free_screen(void *, void *);
int cgsix_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgsix_mmap(void *, off_t, int);
int cgsix_is_console(int);
int cg6_bt_getcmap(union bt_cmap *, struct wsdisplay_cmap *);
int cg6_bt_putcmap(union bt_cmap *, struct wsdisplay_cmap *);
void cgsix_loadcmap_immediate(struct cgsix_softc *, u_int, u_int);
void cgsix_loadcmap_deferred(struct cgsix_softc *, u_int, u_int);
void cgsix_setcolor(struct cgsix_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t);
void cgsix_reset(struct cgsix_softc *);
void cgsix_hardreset(struct cgsix_softc *);
void cgsix_burner(void *, u_int, u_int);
int cgsix_intr(void *);
static int a2int(char *, int);
d174 1
a174 4
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgsix_burner,
d177 2
a178 2
int	cgsixmatch(struct device *, void *, void *);
void	cgsixattach(struct device *, struct device *, void *);
d211 1
d225 1
a225 1
		printf(": cannot map bt registers\n");
d232 1
a232 1
		printf(": cannot map fhc registers\n");
d239 1
a239 1
		printf(": cannot map thc registers\n");
d246 1
a246 1
		printf(": cannot map vid registers\n");
a249 17
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_TEC_OFFSET,
	    CGSIX_TEC_SIZE, BUS_SPACE_MAP_LINEAR, 0, &sc->sc_tec_regs) != 0) {
		printf(": cannot map tec registers\n");
		goto fail_tec;
	}

	if ((sc->sc_ih = bus_intr_establish(sa->sa_bustag, sa->sa_pri,
	    IPL_TTY, 0, cgsix_intr, sc)) == NULL) {
		printf(": couldn't establish interrupt, pri %d\n", sa->sa_pri);
		goto fail_intr;
	}

	/* if prom didn't initialize us, do it the hard way */
	if (OF_getproplen(sa->sa_node, "width") != sizeof(u_int32_t))
		cgsix_hardreset(sc);

a251 3
	cgsix_reset(sc);

	/* grab the current palette */
d259 44
a302 27
	cgsix_burner(sc, 1, 0);

	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);

	sbus_establish(&sc->sc_sd, self);

	sc->sc_rasops.ri_depth = sc->sc_depth;
	sc->sc_rasops.ri_stride = sc->sc_linebytes;
	sc->sc_rasops.ri_flg = RI_CENTER;
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
	    sc->sc_vid_regs);
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));

	cgsix_stdscreen.nrows = sc->sc_rasops.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_rasops.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_rasops.ri_ops;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, &defattr);
a306 2
		int *ccolp, *crowp;

d317 2
a318 9
		if (romgetcursoraddr(&crowp, &ccolp))
			ccolp = crowp = NULL;
		if (ccolp != NULL)
			sc->sc_rasops.ri_ccol = *ccolp;
		if (crowp != NULL)
			sc->sc_rasops.ri_crow = *crowp;

		wsdisplay_cnattach(&cgsix_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
a328 4
fail_intr:
	bus_space_unmap(sa->sa_bustag, sc->sc_tec_regs, CGSIX_TEC_SIZE);
fail_tec:
	bus_space_unmap(sa->sa_bustag, sc->sc_vid_regs, CGSIX_VID_SIZE);
d379 1
a379 1
		cgsix_loadcmap_deferred(sc, cm->index, cm->count);
d409 4
a412 5
	*cookiep = &sc->sc_rasops;
	*curyp = 0;
	*curxp = 0;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, attrp);
d432 1
a432 1
	void (*cb)(void *, int, int);
d445 14
d463 23
a485 4
	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (off >= 0 && off < (sc->sc_linebytes * sc->sc_height))
		return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
		    off + CGSIX_VID_OFFSET, prot, BUS_SPACE_MAP_LINEAR));
d561 1
a561 14
cgsix_loadcmap_deferred(sc, start, ncolors)
	struct cgsix_softc *sc;
	u_int start, ncolors;
{
	u_int32_t thcm;

	thcm = THC_READ(sc, CG6_THC_MISC);
	thcm &= ~THC_MISC_RESET;
	thcm |= THC_MISC_INTEN;
	THC_WRITE(sc, CG6_THC_MISC, thcm);
}

void
cgsix_loadcmap_immediate(sc, start, ncolors)
d593 1
a593 135
	cgsix_loadcmap_immediate(sc, index, 1);
}

void
cgsix_reset(sc)
	struct cgsix_softc *sc;
{
	u_int32_t fhc, rev;

	/* hide the cursor, just in case */
	THC_WRITE(sc, CG6_THC_CURSXY, THC_CURSOFF);

	TEC_WRITE(sc, CG6_TEC_MV, 0);
	TEC_WRITE(sc, CG6_TEC_CLIP, 0);
	TEC_WRITE(sc, CG6_TEC_VDC, 0);

	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;
	/* take core of hardware bugs in old revisions */
	if (rev < 5) {
		/*
		 * Keep current resolution; set cpu to 68020, set test
		 * window (size 1Kx1K), and for rev 1, disable dest cache.
		 */
		fhc &= FHC_RES_MASK;
		fhc |= FHC_CPU_68020 | FHC_TEST |
		    (11 << FHC_TESTX_SHIFT) | (11 << FHC_TESTY_SHIFT);
		if (rev < 2)
			fhc |= FHC_DST_DISABLE;
		FHC_WRITE(sc, fhc);
	}

	/* enable cursor in brooktree DAC */
	BT_WRITE(sc, BT_ADDR, 0x6 << 24);
	BT_WRITE(sc, BT_CTRL, BT_READ(sc, BT_CTRL) | (0x3 << 24));
}

void
cgsix_hardreset(sc)
	struct cgsix_softc *sc;
{
	u_int32_t fhc, rev;

	/* setup brooktree */
	BT_WRITE(sc, BT_ADDR, 0x04 << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0xff << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	BT_WRITE(sc, BT_ADDR, 0x05 << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00 << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	BT_WRITE(sc, BT_ADDR, 0x06 << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x70 << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	BT_WRITE(sc, BT_ADDR, 0x07 << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00 << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);


	/* configure thc */
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_RESET | THC_MISC_INTR |
	    THC_MISC_CYCLS);
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_INTR | THC_MISC_CYCLS);

	THC_WRITE(sc, CG6_THC_HSYNC1, 0x10009);
	THC_WRITE(sc, CG6_THC_HSYNC2, 0x570000);
	THC_WRITE(sc, CG6_THC_HSYNC3, 0x15005d);
	THC_WRITE(sc, CG6_THC_VSYNC1, 0x10005);
	THC_WRITE(sc, CG6_THC_VSYNC2, 0x2403a8);
	THC_WRITE(sc, CG6_THC_REFRESH, 0x16b);

	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_RESET | THC_MISC_INTR |
	    THC_MISC_CYCLS);
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_INTR | THC_MISC_CYCLS);

	/* configure fhc (1152x900) */
	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;

	fhc = FHC_RES_1152 | FHC_CPU_68020 | FHC_TEST;
	if (rev < 1)
		fhc |= FHC_FROP_DISABLE;
	if (rev < 2)
		fhc |= FHC_DST_DISABLE;
	FHC_WRITE(sc, fhc);
}

void
cgsix_burner(vsc, on, flags)
	void *vsc;
	u_int on, flags;
{
	struct cgsix_softc *sc = vsc;
	int s;
	u_int32_t thcm;

	s = splhigh();
	thcm = THC_READ(sc, CG6_THC_MISC);
	if (on)
		thcm |= THC_MISC_VIDEN | THC_MISC_SYNCEN;
	else {
		thcm &= ~THC_MISC_VIDEN;
		if (flags & WSDISPLAY_BURN_VBLANK)
			thcm &= ~THC_MISC_SYNCEN;
	}
	THC_WRITE(sc, CG6_THC_MISC, thcm);
	splx(s);
}

int
cgsix_intr(vsc)
	void *vsc;
{
	struct cgsix_softc *sc = vsc;
	u_int32_t thcm;

	thcm = THC_READ(sc, CG6_THC_MISC);
	if ((thcm & (THC_MISC_INTEN | THC_MISC_INTR)) !=
	    (THC_MISC_INTEN | THC_MISC_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	thcm &= ~(THC_MISC_RESET | THC_MISC_INTEN);
	thcm |= THC_MISC_INTR;
	THC_WRITE(sc, CG6_THC_MISC, thcm);
	cgsix_loadcmap_immediate(sc, 0, 256);
	return (1);
@


1.2.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.2.2.2 2002/06/11 03:42:29 art Exp $	*/
d57 134
a190 1
#include <dev/sbus/cgsixreg.h>
a196 1
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
d223 1
a223 1
void cgsix_reset(struct cgsix_softc *, u_int32_t);
a227 7
void cgsix_ras_init(struct cgsix_softc *);
void cgsix_ras_copyrows(void *, int, int, int);
void cgsix_ras_copycols(void *, int, int, int, int);
void cgsix_ras_erasecols(void *, int, int, int, long int);
void cgsix_ras_eraserows(void *, int, int, long int);
void cgsix_ras_do_cursor(struct rasops_info *);
void cgsix_ras_updatecursor(struct rasops_info *);
a272 1
	u_int32_t fhc, rev;
d283 1
a283 1
	 * Map just BT, FHC, FBC, THC, and video RAM.
d287 1
a287 1
	    CGSIX_BT_SIZE, 0, 0, &sc->sc_bt_regs) != 0) {
d294 1
a294 1
	    CGSIX_FHC_SIZE, 0, 0, &sc->sc_fhc_regs) != 0) {
d301 1
a301 1
	    CGSIX_THC_SIZE, 0, 0, &sc->sc_thc_regs) != 0) {
d315 1
a315 1
	    CGSIX_TEC_SIZE, 0, 0, &sc->sc_tec_regs) != 0) {
a319 7
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_FBC_OFFSET,
	    CGSIX_FBC_SIZE, 0, 0, &sc->sc_fbc_regs) != 0) {
		printf(": cannot map fbc registers\n");
		goto fail_fbc;
	}

d332 1
a332 3
	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;
	cgsix_reset(sc, rev);
d353 1
a353 2
	sc->sc_rasops.ri_flg = RI_CENTER |
	    (console ? 0 : RI_CLEAR);
a362 19
	sc->sc_rasops.ri_hw = sc;

	/*
	 * Old rev. cg6 cards do not like the current acceleration code.
	 *
	 * Some hints from Sun point out at timing and cache problems, which
	 * will be investigated later.
	 */
	if (rev < 5)
		sc->sc_dev.dv_cfdata->cf_flags |= CG6_CFFLAG_NOACCEL;

	if ((sc->sc_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL) == 0) {
		sc->sc_rasops.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_rasops.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_rasops.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_rasops.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_rasops.ri_do_cursor = cgsix_ras_do_cursor;
		cgsix_ras_init(sc);
	}
d368 1
a368 1
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
d372 2
a373 9
	cgsix_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
	cgsix_setcolor(sc, 255, 0, 0, 0);
	cgsix_setcolor(sc, WSCOL_RED, 255, 0, 0);
	cgsix_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
	cgsix_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
	cgsix_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
	cgsix_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
	cgsix_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
	cgsix_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
d375 16
a390 8
	if (console) {
		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_crowp = sc->sc_ccolp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;
		sc->sc_rasops.ri_updatecursor = cgsix_ras_updatecursor;
a404 2
	bus_space_unmap(sa->sa_bustag, sc->sc_fbc_regs, CGSIX_FBC_SIZE);
fail_fbc:
a429 1
	u_int mode;
a434 7
	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)data;
		if (sc->sc_mode != WSDISPLAYIO_MODE_EMUL &&
		    mode == WSDISPLAYIO_MODE_EMUL)
			cgsix_ras_init(sc);
		sc->sc_mode = mode;
		break;
d492 1
a492 1
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
a517 6
struct mmo {
	off_t mo_uaddr;
	bus_size_t mo_size;
	bus_size_t mo_physoff;
};

a524 17
	struct mmo *mo;
	bus_addr_t u;
	bus_size_t sz;

	static struct mmo mmo[] = {
		{ CG6_USER_RAM, 0, CGSIX_VID_OFFSET },

		/* do not actually know how big most of these are! */
		{ CG6_USER_FBC, 1, CGSIX_FBC_OFFSET },
		{ CG6_USER_TEC, 1, CGSIX_TEC_OFFSET },
		{ CG6_USER_BTREGS, 8192 /* XXX */, CGSIX_BT_OFFSET },
		{ CG6_USER_FHC, 1, CGSIX_FHC_OFFSET },
		{ CG6_USER_THC, CGSIX_THC_SIZE, CGSIX_THC_OFFSET },
		{ CG6_USER_ROM, 65536, CGSIX_ROM_OFFSET },
		{ CG6_USER_DHC, 1, CGSIX_DHC_OFFSET },
	};
#define	NMMO (sizeof mmo / sizeof *mmo)
d526 1
a526 1
	if (off & PGOFSET || off < 0)
d529 4
a532 24
	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
		for (mo = mmo; mo < &mmo[NMMO]; mo++) {
			if (off < mo->mo_uaddr)
				continue;
			u = off - mo->mo_uaddr;
			sz = mo->mo_size ? mo->mo_size :
			    sc->sc_linebytes * sc->sc_height;
			if (u < sz) {
				return (bus_space_mmap(sc->sc_bustag,
				    sc->sc_paddr, u + mo->mo_physoff,
				    prot, BUS_SPACE_MAP_LINEAR));
			}
		}
		break;

	case WSDISPLAYIO_MODE_DUMBFB:
		/* Allow mapping as a dumb framebuffer from offset 0 */
		if (off >= 0 && off < (sc->sc_linebytes * sc->sc_height))
			return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
			    off + CGSIX_VID_OFFSET, prot,
			    BUS_SPACE_MAP_LINEAR));
		break;
	}
d566 1
a566 1
	if (index >= 256 || count > 256 - index)
d590 2
a591 1
	if (index >= 256 || count > 256 - index)
d657 1
a657 1
cgsix_reset(sc, fhcrev)
a658 1
	u_int32_t fhcrev;
d660 1
a660 1
	u_int32_t fhc;
d669 2
d672 1
a672 1
	if (fhcrev < 5) {
a676 1
		fhc = FHC_READ(sc);
d680 1
a680 1
		if (fhcrev < 2)
a787 244
}

void
cgsix_ras_init(sc)
	struct cgsix_softc *sc;
{
	u_int32_t m;

	CG6_DRAIN(sc);
	m = FBC_READ(sc, CG6_FBC_MODE);
	m &= ~FBC_MODE_MASK;
	m |= FBC_MODE_VAL;
	FBC_WRITE(sc, CG6_FBC_MODE, m);
}

void
cgsix_ras_copyrows(cookie, src, dst, n)
	void *cookie;
	int src, dst, n;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (dst == src)
		return;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_rows)
		n = ri->ri_rows - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_rows)
		n = ri->ri_rows - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_COPY);
	FBC_WRITE(sc, CG6_FBC_X0, ri->ri_xorigin);
	FBC_WRITE(sc, CG6_FBC_Y0, ri->ri_yorigin + src);
	FBC_WRITE(sc, CG6_FBC_X1, ri->ri_xorigin + ri->ri_emuwidth - 1);
	FBC_WRITE(sc, CG6_FBC_Y1, ri->ri_yorigin + src + n - 1);
	FBC_WRITE(sc, CG6_FBC_X2, ri->ri_xorigin);
	FBC_WRITE(sc, CG6_FBC_Y2, ri->ri_yorigin + dst);
	FBC_WRITE(sc, CG6_FBC_X3, ri->ri_xorigin + ri->ri_emuwidth - 1);
	FBC_WRITE(sc, CG6_FBC_Y3, ri->ri_yorigin + dst + n - 1);
	CG6_BLIT_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_copycols(cookie, row, src, dst, n)
	void *cookie;
	int row, src, dst, n;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (dst == src)
		return;
	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_cols)
		n = ri->ri_cols - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_cols)
		n = ri->ri_cols - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_COPY);
	FBC_WRITE(sc, CG6_FBC_X0, ri->ri_xorigin + src);
	FBC_WRITE(sc, CG6_FBC_Y0, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_X1, ri->ri_xorigin + src + n - 1);
	FBC_WRITE(sc, CG6_FBC_Y1,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_X2, ri->ri_xorigin + dst);
	FBC_WRITE(sc, CG6_FBC_Y2, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_X3, ri->ri_xorigin + dst + n - 1);
	FBC_WRITE(sc, CG6_FBC_Y3,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	CG6_BLIT_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_erasecols(cookie, row, col, n, attr)
	void *cookie;
	int row, col, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (col < 0) {
		n += col;
		col = 0;
	}
	if (col + n > ri->ri_cols)
		n = ri->ri_cols - col;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FILL);
	FBC_WRITE(sc, CG6_FBC_FG, ri->ri_devcmap[(attr >> 16) & 0xf]);
	FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col);
	FBC_WRITE(sc, CG6_FBC_ARECTY,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col + n - 1);
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_eraserows(cookie, row, n, attr)
	void *cookie;
	int row, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (row < 0) {
		n += row;
		row = 0;
	}
	if (row + n > ri->ri_rows)
		n = ri->ri_rows - row;
	if (n <= 0)
		return;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FILL);
	FBC_WRITE(sc, CG6_FBC_FG, ri->ri_devcmap[(attr >> 16) & 0xf]);
	if ((n == ri->ri_rows) && (ri->ri_flg & RI_FULLCLEAR)) {
		FBC_WRITE(sc, CG6_FBC_ARECTY, 0);
		FBC_WRITE(sc, CG6_FBC_ARECTX, 0);
		FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_height - 1);
		FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_width - 1);
	} else {
		row *= ri->ri_font->fontheight;
		FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
		FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin);
		FBC_WRITE(sc, CG6_FBC_ARECTY,
		    ri->ri_yorigin + row + (n * ri->ri_font->fontheight) - 1);
		FBC_WRITE(sc, CG6_FBC_ARECTX,
		    ri->ri_xorigin + ri->ri_emuwidth - 1);
	}
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_do_cursor(ri)
	struct rasops_info *ri;
{
	struct cgsix_softc *sc = ri->ri_hw;
	int row, col;

	row = ri->ri_crow * ri->ri_font->fontheight;
	col = ri->ri_ccol * ri->ri_font->fontwidth;
	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FLIP);
	FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col);
	FBC_WRITE(sc, CG6_FBC_ARECTY,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_ARECTX,
	    ri->ri_xorigin + col + ri->ri_font->fontwidth - 1);
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_updatecursor(ri)
	struct rasops_info *ri;
{
	struct cgsix_softc *sc = ri->ri_hw;

	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.2.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a102 2
int cgsix_setcursor(struct cgsix_softc *, struct wsdisplay_cursor *);
int cgsix_updatecursor(struct cgsix_softc *, u_int);
a157 5
	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);

d184 1
a184 2
	    sc->sc_linebytes * sc->sc_height, BUS_SPACE_MAP_LINEAR,
	    0, &sc->sc_vid_regs) != 0) {
d229 5
d278 1
a285 3
	/* for cursor inversion */
	cgsix_setcolor(sc, (~WSCOL_WHITE) & 0xff, 0, 0, 0);
	cgsix_setcolor(sc, (~WSCOL_BLACK) & 0xff, 255, 255, 255);
a321 1
;
d335 1
a335 4
	struct wsdisplay_cursor *curs;
	struct wsdisplay_curpos *pos;
	u_char r[2], g[2], b[2];
	int error, s;
d340 1
a340 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG6;
d344 3
a346 6
		if ((sc->sc_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL)
		    == 0) {
			if (sc->sc_mode != WSDISPLAYIO_MODE_EMUL &&
			    mode == WSDISPLAYIO_MODE_EMUL)
				cgsix_ras_init(sc);
		}
d359 1
d366 1
d374 3
a376 48
	case WSDISPLAYIO_SCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		return (cgsix_setcursor(sc, curs));
	case WSDISPLAYIO_GCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		if (curs->which & WSDISPLAY_CURSOR_DOCUR)
			curs->enable = sc->sc_curs_enabled;
		if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
			curs->pos.x = sc->sc_curs_pos.x;
			curs->pos.y = sc->sc_curs_pos.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
			curs->hot.x = sc->sc_curs_hot.x;
			curs->hot.y = sc->sc_curs_hot.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
			curs->cmap.index = 0;
			curs->cmap.count = 2;
			r[0] = sc->sc_curs_fg >> 16;
			g[0] = sc->sc_curs_fg >> 8;
			b[0] = sc->sc_curs_fg >> 0;
			r[1] = sc->sc_curs_bg >> 16;
			g[1] = sc->sc_curs_bg >> 8;
			b[1] = sc->sc_curs_bg >> 0;
			error = copyout(r, curs->cmap.red, sizeof(r));
			if (error)
				return (error);
			error = copyout(g, curs->cmap.green, sizeof(g));
			if (error)
				return (error);
			error = copyout(b, curs->cmap.blue, sizeof(b));
			if (error)
				return (error);
		}
		if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
			size_t l;

			curs->size.x = sc->sc_curs_size.x;
			curs->size.y = sc->sc_curs_size.y;
			l = (sc->sc_curs_size.x * sc->sc_curs_size.y) / NBBY;
			error = copyout(sc->sc_curs_image, curs->image, l);
			if (error)
				return (error);
			error = copyout(sc->sc_curs_mask, curs->mask, l);
			if (error)
				return (error);
		}
		break;
a377 4
		pos = (struct wsdisplay_curpos *)data;
		pos->x = sc->sc_curs_pos.x;
		pos->y = sc->sc_curs_pos.y;
		break;
a378 7
		pos = (struct wsdisplay_curpos *)data;
		s = spltty();
		sc->sc_curs_pos.x = pos->x;
		sc->sc_curs_pos.y = pos->y;
		cgsix_updatecursor(sc, WSDISPLAY_CURSOR_DOPOS);
		splx(s);
		break;
d380 2
a381 5
		pos = (struct wsdisplay_curpos *)data;
		pos->x = pos->y = 32;
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
d383 1
a383 1
		return -1; /* not supported */
a384 114

	return (0);
}

int
cgsix_setcursor(struct cgsix_softc *sc, struct wsdisplay_cursor *curs)
{
	u_int8_t r[2], g[2], b[2], image[128], mask[128];
	int s, error;
	size_t imcount;

	/*
	 * Do stuff that can generate errors first, then we'll blast it
	 * all at once.
	 */
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		if (curs->cmap.count < 2)
			return (EINVAL);
		error = copyin(curs->cmap.red, r, sizeof(r));
		if (error)
			return (error);
		error = copyin(curs->cmap.green, g, sizeof(g));
		if (error)
			return (error);
		error = copyin(curs->cmap.blue, b, sizeof(b));
		if (error)
			return (error);
	}

	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		if (curs->size.x > CG6_MAX_CURSOR ||
		    curs->size.y > CG6_MAX_CURSOR)
			return (EINVAL);
		imcount = (curs->size.x * curs->size.y) / NBBY;
		error = copyin(curs->image, image, imcount);
		if (error)
			return (error);
		error = copyin(curs->mask, mask, imcount);
		if (error)
			return (error);
	}

	/*
	 * Ok, everything is in kernel space and sane, update state.
	 */
	s = spltty();

	if (curs->which & WSDISPLAY_CURSOR_DOCUR)
		sc->sc_curs_enabled = curs->enable;
	if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
		sc->sc_curs_pos.x = curs->pos.x;
		sc->sc_curs_pos.y = curs->pos.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
		sc->sc_curs_hot.x = curs->hot.x;
		sc->sc_curs_hot.y = curs->hot.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		sc->sc_curs_fg = ((r[0] << 16) | (g[0] << 8) | (b[0] << 0));
		sc->sc_curs_bg = ((r[1] << 16) | (g[1] << 8) | (b[1] << 0));
	}
	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		sc->sc_curs_size.x = curs->size.x;
		sc->sc_curs_size.y = curs->size.y;
		bcopy(image, sc->sc_curs_image, imcount);
		bcopy(mask, sc->sc_curs_mask, imcount);
	}

	cgsix_updatecursor(sc, curs->which);
	splx(s);

	return (0);
}

int
cgsix_updatecursor(struct cgsix_softc *sc, u_int which)
{
	if (which & WSDISPLAY_CURSOR_DOCMAP) {
		BT_WRITE(sc, BT_ADDR, 1 << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x00ff0000)>> 16) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x0000ff00)>> 8) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x000000ff)>> 0) << 24);

		BT_WRITE(sc, BT_ADDR, 3 << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x00ff0000)>> 16) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x0000ff00)>> 8) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x000000ff)>> 0) << 24);
	}

	if (which & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOHOT)) {
		u_int32_t x, y;

		x = sc->sc_curs_pos.x + CG6_MAX_CURSOR - sc->sc_curs_hot.x;
		y = sc->sc_curs_pos.y + CG6_MAX_CURSOR - sc->sc_curs_hot.y;
		THC_WRITE(sc, CG6_THC_CURSXY,
		    ((x & 0xffff) << 16) | (y & 0xffff));
	}

	if (which & WSDISPLAY_CURSOR_DOCUR) {
		u_int32_t c;

		if (sc->sc_curs_enabled) {
			BT_WRITE(sc, BT_ADDR, 6 << 24);
			c = BT_READ(sc, BT_CTRL);
			c |= 3 << 24;
			BT_WRITE(sc, BT_CTRL, c);
		} else {
			BT_WRITE(sc, BT_ADDR, 6 << 24);
			c = BT_READ(sc, BT_CTRL);
			c &= ~(3 << 24);
			BT_WRITE(sc, BT_CTRL, c);
			THC_WRITE(sc, CG6_THC_CURSXY, THC_CURSOFF);
		}
	}
@


1.1
log
@wscons driver for cgsix (based on vgafb from macppc and cgsix from sparc)
Still kinda ugly, but seems to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: spif.c,v 1.8 2001/10/05 15:50:30 jason Exp $	*/
a110 1
int cgsix_romcursoraddr __P((int **, int **));
d222 3
a224 2
	sc->sc_rcons.rc_crow = sc->sc_rcons.rc_ccol = -1;
	if (cgsix_romcursoraddr(&sc->sc_rcons.rc_crowp, &sc->sc_rcons.rc_ccolp)) {
a228 11
#if 0
	sc->sc_rcons.rc_font = &console_font;
	sc->sc_rcons.rc_maxcol =
	    sc->sc_raster.width / sc->sc_rcons.rc_font->width;
	sc->sc_rcons.rc_maxrow =
	    sc->sc_raster.height / sc->sc_rcons.rc_font->height;
	sc->sc_rcons.rc_maxcol = min(sc->sc_rcons.rc_maxcol,
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));
	sc->sc_rcons.rc_maxrow = min(sc->sc_rcons.rc_maxrow,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34));
#else
a232 1
#endif
d234 2
a235 1
	rcons_init(&sc->sc_rcons, 160, 160);
d242 6
a251 5

	printf("\n");

	wsdisplay_cnattach(&cgsix_stdscreen, &sc->sc_rcons, 0, 0, defattr);

d327 2
a328 1
	*curxp = *curyp = 0;
d373 1
a373 1
	int i;
d378 1
a378 1
		i = i * 10 + *cp++ - '\0';
a379 16
}

int
cgsix_romcursoraddr(rowp, colp)
	int **rowp, **colp;
{
	int rx, cx;

	return (1);
	/*
	 * XXX these calls crash the machine... OF_interpret appears to
	 * be broken.
	 */
	OF_interpret("addr line#", 1, &rx);
	OF_interpret("addr column#", 1, &cx);
	return (0);
@


1.1.2.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a52 14
union bt_cmap {
	u_int8_t cm_map[256][3];	/* 256 r/b/g entries */
	u_int32_t cm_chip[256 * 3 / 4];	/* the way the chip is loaded */
};

#define	BT_ADDR		0x00		/* map address register */
#define	BT_CMAP		0x04		/* colormap data register */
#define	BT_CTRL		0x08		/* control register */
#define	BT_OMAP		0x0c		/* overlay (cursor) map register */

#define	BT_D4M3(x)	((((x) >> 2) << 1) + ((x) >> 2)) /* (x / 4) * 3 */
#define	BT_D4M4(x)	((x) & ~3)			 /* (x / 4) * 4 */

#define	CGSIX_ROM_OFFSET	0x000000
a54 2
#define	CGSIX_DHC_OFFSET	0x240000
#define	CGSIX_ALT_OFFSET	0x280000
a58 3
#define	CGSIX_FBC_OFFSET	0x700000
#define	CGSIX_TEC_OFFSET	0x701000
#define	CGSIX_TEC_SIZE		(sizeof(u_int32_t) * 3)
a61 57
#define	CG6_FHC			0x0		/* fhc register */

#define	FHC_FBID_MASK		0xff000000	/* frame buffer id */
#define	FHC_FBID_SHIFT		24
#define	FHC_REV_MASK		0x00f00000	/* revision */
#define	FHC_REV_SHIFT		20
#define	FHC_FROP_DISABLE	0x00080000	/* disable fast rasterop */
#define	FHC_ROW_DISABLE		0x00040000	/* ??? */
#define	FHC_SRC_DISABLE		0x00020000	/* ??? */
#define	FHC_DST_DISABLE		0x00010000	/* disable dst cache */
#define	FHC_RESET		0x00008000	/* ??? */
#define	FHC_LEBO		0x00002000	/* set little endian order */
#define	FHC_RES_MASK		0x00001800	/* resolution: */
#define	FHC_RES_1024		0x00000000	/*  1024x768 */
#define	FHC_RES_1152		0x00000800	/*  1152x900 */
#define	FHC_RES_1280		0x00001000	/*  1280x1024 */
#define	FHC_RES_1600		0x00001800	/*  1600x1200 */
#define	FHC_CPU_MASK		0x00000600	/* cpu type: */
#define	FHC_CPU_SPARC		0x00000000	/*  sparc */
#define	FHC_CPU_68020		0x00000200	/*  68020 */
#define	FHC_CPU_386		0x00000400	/*  i386 */
#define	FHC_TEST		0x00000100	/* test window */
#define	FHC_TESTX_MASK		0x000000f0	/* test window X */
#define	FHC_TESTX_SHIFT		4
#define	FHC_TESTY_MASK		0x0000000f	/* test window Y */
#define	FHC_TESTY_SHIFT		0

#define	CG6_TEC_MV		0x0		/* matrix stuff */
#define	CG6_TEC_CLIP		0x4		/* clipping stuff */
#define	CG6_TEC_VDC		0x8		/* ??? */

#define	CG6_THC_HSYNC1		0x800		/* horizontal sync timing */
#define	CG6_THC_HSYNC2		0x804		/* more hsync timing */
#define	CG6_THC_HSYNC3		0x808		/* yet more hsync timing */
#define	CG6_THC_VSYNC1		0x80c		/* vertical sync timing */
#define	CG6_THC_VSYNC2		0x810		/* only two of these */
#define	CG6_THC_REFRESH		0x814		/* refresh counter */
#define	CG6_THC_MISC		0x818		/* misc control/status */
#define	CG6_THC_CURSXY		0x8fc		/* cursor x/y, 16 bit each */
#define	CG6_THC_CURSMASK	0x900		/* cursor mask bits */
#define	CG6_THC_CURSBITS	0x980		/* cursor bits */

/* cursor x/y position for 'off' */
#define	THC_CURSOFF		((65536-32) | ((65536-32) << 16))

#define	THC_MISC_REV_M		0x000f0000	/* chip revision */
#define	THC_MISC_REV_S		16
#define	THC_MISC_RESET		0x00001000	/* reset */
#define	THC_MISC_VIDEN		0x00000400	/* video enable */
#define	THC_MISC_SYNC		0x00000200	/* not sure what ... */
#define	THC_MISC_VSYNC		0x00000100	/* ... these really are */
#define	THC_MISC_SYNCEN		0x00000080	/* sync enable */
#define	THC_MISC_CURSRES	0x00000040	/* cursor resolution */
#define	THC_MISC_INTEN		0x00000020	/* v.retrace intr enable */
#define	THC_MISC_INTR		0x00000010	/* intr pending/ack */
#define	THC_MISC_CYCLS		0x0000000f	/* cycles before transfer */

a65 1
	bus_addr_t sc_paddr;
a68 1
	bus_space_handle_t sc_tec_regs;
a73 39
	union bt_cmap sc_cmap;
};

#define	CG6_USER_FBC	0x70000000
#define	CG6_USER_TEC	0x70001000
#define	CG6_USER_BTREGS	0x70002000
#define	CG6_USER_FHC	0x70004000
#define	CG6_USER_THC	0x70005000
#define	CG6_USER_ROM	0x70006000
#define	CG6_USER_RAM	0x70016000
#define	CG6_USER_DHC	0x80000000

#define	THC_READ(sc,r) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_thc_regs, (r))
#define	THC_WRITE(sc,r,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_thc_regs, (r), (v))

#define	TEC_READ(sc,r) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_tec_regs, (r))
#define	TEC_WRITE(sc,r,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_tec_regs, (r), (v))

#define	FHC_READ(sc) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_fhc_regs, CG6_FHC)
#define	FHC_WRITE(sc,v) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_fhc_regs, CG6_FHC, (v))

#define	BT_WRITE(sc, reg, val) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_bt_regs, (reg), (val))
#define	BT_READ(sc, reg) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_bt_regs, (reg))
#define	BT_BARRIER(sc,reg,flags) \
    bus_space_barrier((sc)->sc_bustag, (sc)->sc_bt_regs, (reg), \
	sizeof(u_int32_t), (flags))

struct mmo {
	u_long	mo_uaddr;		/* user (virtual address */
	u_long	mo_size;		/* size, or 0 for video ram size */
	u_long	mo_physoff;		/* offset from sc_physadr */
d92 1
a92 1
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d111 1
d113 1
a113 8
int cg6_bt_getcmap __P((union bt_cmap *, struct wsdisplay_cmap *));
int cg6_bt_putcmap __P((union bt_cmap *, struct wsdisplay_cmap *));
void cgsix_loadcmap __P((struct cgsix_softc *, u_int, u_int));
void cgsix_setcolor __P((struct cgsix_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t));
void cgsix_reset __P((struct cgsix_softc *));
void cgsix_hardreset __P((struct cgsix_softc *));
void cgsix_burner __P((void *, u_int, u_int));
d122 1
a122 4
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	NULL,	/* burner */
d155 1
a155 1
	int console, i;
a158 1
	sc->sc_paddr = sbus_bus_addr(sa->sa_bustag, sa->sa_slot, sa->sa_offset);
a195 11
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_TEC_OFFSET,
	    CGSIX_TEC_SIZE, BUS_SPACE_MAP_LINEAR, 0, &sc->sc_tec_regs) != 0) {
		printf(": cannot map tec registers\n", self->dv_xname);
		goto fail_tec;
	}

	/* if prom didn't initialize us, do it the hard way */
	if (OF_getproplen(sa->sa_node, "width") != sizeof(u_int32_t))
		cgsix_hardreset(sc);

d198 15
a212 16
	cgsix_reset(sc);

	/* grab the current palette */
	BT_WRITE(sc, BT_ADDR, 0);
	for (i = 0; i < 256; i++) {
		sc->sc_cmap.cm_map[i][0] = BT_READ(sc, BT_CMAP) >> 24;
		sc->sc_cmap.cm_map[i][1] = BT_READ(sc, BT_CMAP) >> 24;
		sc->sc_cmap.cm_map[i][2] = BT_READ(sc, BT_CMAP) >> 24;
	}

	cgsix_burner(sc, 1, 0);

	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);
d221 1
a221 2
	sc->sc_raster.pixels = (void *)bus_space_vaddr(sc->sc_bustag,
	    sc->sc_vid_regs);
d223 2
a224 3
	if (console == 0 ||
	    romgetcursoraddr(&sc->sc_rcons.rc_crowp, &sc->sc_rcons.rc_ccolp)) {
		sc->sc_rcons.rc_crow = sc->sc_rcons.rc_ccol = -1;
d229 11
d244 1
d246 1
a246 2
	rcons_init(&sc->sc_rcons,
	    sc->sc_rcons.rc_maxrow, sc->sc_rcons.rc_maxcol);
a252 17
	printf("\n");

	if (console) {
		cgsix_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
		cgsix_setcolor(sc, 255, 255, 255, 255);
		cgsix_setcolor(sc, WSCOL_RED, 255, 0, 0);
		cgsix_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
		cgsix_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
		cgsix_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
		cgsix_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
		cgsix_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
		cgsix_setcolor(sc, WSCOL_WHITE, 255, 255, 255);

		wsdisplay_cnattach(&cgsix_stdscreen, &sc->sc_rcons,
		    *sc->sc_rcons.rc_ccolp, *sc->sc_rcons.rc_crowp, defattr);
	}

d257 5
a265 2
fail_tec:
	bus_space_unmap(sa->sa_bustag, sc->sc_vid_regs, CGSIX_VID_SIZE);
a284 1
	struct wsdisplay_cmap *cm;
a285 1
	int error;
d302 1
d304 1
a304 6
		cm = (struct wsdisplay_cmap *)data;
		error = cg6_bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

d306 2
a307 6
		cm = (struct wsdisplay_cmap *)data;
		error = cg6_bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgsix_loadcmap(sc, cm->index, cm->count);
		break;
d337 1
a337 2
	*curyp = *sc->sc_rcons.rc_crowp;
	*curxp = *sc->sc_rcons.rc_ccolp;
d365 1
a365 1
cgsix_mmap(v, off, prot)
d367 1
a367 1
	off_t off;
d370 1
d372 1
d374 1
a374 1
	if (off & PGOFSET)
a375 6

	/* Allow mapping as a dumb framebuffer from offset 0 */
	if (off >= 0 && off < (sc->sc_linebytes * sc->sc_height))
		return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
		    off + CGSIX_VID_OFFSET, prot, BUS_SPACE_MAP_LINEAR));

d382 1
a382 1
	int i = 0;
d387 1
a387 1
		i = i * 10 + *cp++ - '0';
d392 2
a393 2
cgsix_is_console(node)
	int node;
d395 1
a395 1
	extern int fbnode;
d397 7
a403 24
	return (fbnode == node);
}

int
cg6_bt_getcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || index + count > 256)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyout(&bcm->cm_map[index + i][0],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][1],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][2],
		    &rcm->blue[i], 1)) != 0)
			return (error);
	}
d408 2
a409 3
cg6_bt_putcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d411 1
a411 2
	u_int index = rcm->index, count = rcm->count, i;
	int error;
d413 1
a413 163
	if (index >= 256 || rcm->count > 256 ||
	    (rcm->index + rcm->count) > 256)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &bcm->cm_map[index + i][0], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &bcm->cm_map[index + i][1], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &bcm->cm_map[index + i][2], 1)) != 0)
			return (error);
	}
	return (0);
}

void
cgsix_loadcmap(sc, start, ncolors)
	struct cgsix_softc *sc;
	u_int start, ncolors;
{
	u_int cstart;
	u_int32_t v;
	int count;

	cstart = BT_D4M3(start);
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	BT_WRITE(sc, BT_ADDR, BT_D4M4(start) << 24);
	while (--count >= 0) {
		v = sc->sc_cmap.cm_chip[cstart];
		BT_WRITE(sc, BT_CMAP, v << 0);
		BT_WRITE(sc, BT_CMAP, v << 8);
		BT_WRITE(sc, BT_CMAP, v << 16);
		BT_WRITE(sc, BT_CMAP, v << 24);
		cstart++;
	}
}

void
cgsix_setcolor(sc, index, r, g, b)
	struct cgsix_softc *sc;
	u_int index;
	u_int8_t r, g, b;
{
	union bt_cmap *bcm = &sc->sc_cmap;

	bcm->cm_map[index][0] = r;
	bcm->cm_map[index][1] = g;
	bcm->cm_map[index][2] = b;
	cgsix_loadcmap(sc, index, 1);
}

void
cgsix_reset(sc)
	struct cgsix_softc *sc;
{
	u_int32_t fhc, rev;

	/* hide the cursor, just in case */
	THC_WRITE(sc, CG6_THC_CURSXY, THC_CURSOFF);

	TEC_WRITE(sc, CG6_TEC_MV, 0);
	TEC_WRITE(sc, CG6_TEC_CLIP, 0);
	TEC_WRITE(sc, CG6_TEC_VDC, 0);

	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;
	/* take core of hardware bugs in old revisions */
	if (rev < 5) {
		/*
		 * Keep current resolution; set cpu to 68020, set test
		 * window (size 1Kx1K), and for rev 1, disable dest cache.
		 */
		fhc &= FHC_RES_MASK;
		fhc |= FHC_CPU_68020 | FHC_TEST |
		    (11 << FHC_TESTX_SHIFT) | (11 << FHC_TESTY_SHIFT);
		if (rev < 2)
			fhc |= FHC_DST_DISABLE;
		FHC_WRITE(sc, fhc);
	}

	/* enable cursor in brooktree DAC */
	BT_WRITE(sc, BT_ADDR, 0x6 << 24);
	BT_WRITE(sc, BT_CTRL, BT_READ(sc, BT_CTRL) | (0x3 << 24));
}

void
cgsix_hardreset(sc)
	struct cgsix_softc *sc;
{
	u_int32_t fhc, rev;

	/* setup brooktree */
	BT_WRITE(sc, BT_ADDR, 0x04 << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0xff << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	BT_WRITE(sc, BT_ADDR, 0x05 << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00 << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	BT_WRITE(sc, BT_ADDR, 0x06 << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x70 << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	BT_WRITE(sc, BT_ADDR, 0x07 << 24);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00 << 24);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);


	/* configure thc */
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_RESET | THC_MISC_INTR |
	    THC_MISC_CYCLS);
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_INTR | THC_MISC_CYCLS);

	THC_WRITE(sc, CG6_THC_HSYNC1, 0x10009);
	THC_WRITE(sc, CG6_THC_HSYNC2, 0x570000);
	THC_WRITE(sc, CG6_THC_HSYNC3, 0x15005d);
	THC_WRITE(sc, CG6_THC_VSYNC1, 0x10005);
	THC_WRITE(sc, CG6_THC_VSYNC2, 0x2403a8);
	THC_WRITE(sc, CG6_THC_REFRESH, 0x16b);

	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_RESET | THC_MISC_INTR |
	    THC_MISC_CYCLS);
	THC_WRITE(sc, CG6_THC_MISC, THC_MISC_INTR | THC_MISC_CYCLS);

	/* configure fhc (1152x900) */
	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;

	fhc = FHC_RES_1152 | FHC_CPU_68020 | FHC_TEST;
	if (rev < 1)
		fhc |= FHC_FROP_DISABLE;
	if (rev < 2)
		fhc |= FHC_DST_DISABLE;
	FHC_WRITE(sc, fhc);
}

void
cgsix_burner(vsc, on, flags)
	void *vsc;
	u_int on, flags;
{
	struct cgsix_softc *sc = vsc;
	int s;
	u_int32_t thcm;

	s = splhigh();
	thcm = THC_READ(sc, CG6_THC_MISC);
	if (on)
		thcm |= THC_MISC_VIDEN | THC_MISC_SYNCEN;
	else {
		thcm &= ~THC_MISC_VIDEN;
		if (flags & WSDISPLAY_BURN_VBLANK)
			thcm &= ~THC_MISC_SYNCEN;
	}
	THC_WRITE(sc, CG6_THC_MISC, thcm);
	splx(s);
@


1.1.2.2
log
@Merge in -current from roughly a week ago
@
text
@a152 1
	void *sc_ih;
d221 17
a237 19
int cgsix_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgsix_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgsix_free_screen(void *, void *);
int cgsix_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgsix_mmap(void *, off_t, int);
int cgsix_is_console(int);
int cg6_bt_getcmap(union bt_cmap *, struct wsdisplay_cmap *);
int cg6_bt_putcmap(union bt_cmap *, struct wsdisplay_cmap *);
void cgsix_loadcmap_immediate(struct cgsix_softc *, u_int, u_int);
void cgsix_loadcmap_deferred(struct cgsix_softc *, u_int, u_int);
void cgsix_setcolor(struct cgsix_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t);
void cgsix_reset(struct cgsix_softc *);
void cgsix_hardreset(struct cgsix_softc *);
void cgsix_burner(void *, u_int, u_int);
int cgsix_intr(void *);
static int a2int(char *, int);
d251 2
a252 2
int	cgsixmatch(struct device *, void *, void *);
void	cgsixattach(struct device *, struct device *, void *);
a329 6
	if ((sc->sc_ih = bus_intr_establish(sa->sa_bustag, sa->sa_pri,
	    IPL_TTY, 0, cgsix_intr, sc)) == NULL) {
		printf(": couldn't establish interrupt, pri %d\n", sa->sa_pri);
		goto fail_intr;
	}

d353 1
a353 1
	sbus_establish(&sc->sc_sd, self);
a407 2
fail_intr:
	bus_space_unmap(sa->sa_bustag, sc->sc_tec_regs, CGSIX_TEC_SIZE);
d460 1
a460 1
		cgsix_loadcmap_deferred(sc, cm->index, cm->count);
d513 1
a513 1
	void (*cb)(void *, int, int);
d609 1
a609 14
cgsix_loadcmap_deferred(sc, start, ncolors)
	struct cgsix_softc *sc;
	u_int start, ncolors;
{
	u_int32_t thcm;

	thcm = THC_READ(sc, CG6_THC_MISC);
	thcm &= ~THC_MISC_RESET;
	thcm |= THC_MISC_INTEN;
	THC_WRITE(sc, CG6_THC_MISC, thcm);
}

void
cgsix_loadcmap_immediate(sc, start, ncolors)
d641 1
a641 1
	cgsix_loadcmap_immediate(sc, index, 1);
a753 22
}

int
cgsix_intr(vsc)
	void *vsc;
{
	struct cgsix_softc *sc = vsc;
	u_int32_t thcm;

	thcm = THC_READ(sc, CG6_THC_MISC);
	if ((thcm & (THC_MISC_INTEN | THC_MISC_INTR)) !=
	    (THC_MISC_INTEN | THC_MISC_INTR)) {
		/* Not expecting an interrupt, it's not for us. */
		return (0);
	}

	/* Acknowledge the interrupt and disable it. */
	thcm &= ~(THC_MISC_RESET | THC_MISC_INTEN);
	thcm |= THC_MISC_INTR;
	THC_WRITE(sc, CG6_THC_MISC, thcm);
	cgsix_loadcmap_immediate(sc, 0, 256);
	return (1);
@


1.1.2.3
log
@Sync the SMP branch with 3.3
@
text
@a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d51 153
a203 2
#include <dev/rasops/rasops.h>
#include <dev/sbus/cgsixreg.h>
a209 1
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
d236 1
a236 1
void cgsix_reset(struct cgsix_softc *, u_int32_t);
a240 7
void cgsix_ras_init(struct cgsix_softc *);
void cgsix_ras_copyrows(void *, int, int, int);
void cgsix_ras_copycols(void *, int, int, int, int);
void cgsix_ras_erasecols(void *, int, int, int, long int);
void cgsix_ras_eraserows(void *, int, int, long int);
void cgsix_ras_do_cursor(struct rasops_info *);
void cgsix_ras_updatecursor(struct rasops_info *);
d251 1
a251 1
	cgsix_burner,
a285 1
	u_int32_t fhc, rev;
a294 5
	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);

d296 1
a296 1
	 * Map just BT, FHC, FBC, THC, and video RAM.
d300 2
a301 2
	    CGSIX_BT_SIZE, 0, 0, &sc->sc_bt_regs) != 0) {
		printf(": cannot map bt registers\n");
d307 2
a308 2
	    CGSIX_FHC_SIZE, 0, 0, &sc->sc_fhc_regs) != 0) {
		printf(": cannot map fhc registers\n");
d314 2
a315 2
	    CGSIX_THC_SIZE, 0, 0, &sc->sc_thc_regs) != 0) {
		printf(": cannot map thc registers\n");
d321 2
a322 3
	    sc->sc_linebytes * sc->sc_height, BUS_SPACE_MAP_LINEAR,
	    0, &sc->sc_vid_regs) != 0) {
		printf(": cannot map vid registers\n");
d328 2
a329 2
	    CGSIX_TEC_SIZE, 0, 0, &sc->sc_tec_regs) != 0) {
		printf(": cannot map tec registers\n");
a332 7
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGSIX_FBC_OFFSET,
	    CGSIX_FBC_SIZE, 0, 0, &sc->sc_fbc_regs) != 0) {
		printf(": cannot map fbc registers\n");
		goto fail_fbc;
	}

d345 1
a345 3
	fhc = FHC_READ(sc);
	rev = (fhc & FHC_REV_MASK) >> FHC_REV_SHIFT;
	cgsix_reset(sc, rev);
d357 5
d364 6
a369 5
	sc->sc_rasops.ri_depth = sc->sc_depth;
	sc->sc_rasops.ri_stride = sc->sc_linebytes;
	sc->sc_rasops.ri_flg = RI_CENTER |
	    (console ? 0 : RI_CLEAR);
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
a370 8
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));
	sc->sc_rasops.ri_hw = sc;
d372 19
a390 23
	/*
	 * Old rev. cg6 cards do not like the current acceleration code.
	 *
	 * Some hints from Sun point out at timing and cache problems, which
	 * will be investigated later.
	 */
	if (rev < 5)
		sc->sc_dev.dv_cfdata->cf_flags |= CG6_CFFLAG_NOACCEL;

	if ((sc->sc_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL) == 0) {
		sc->sc_rasops.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_rasops.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_rasops.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_rasops.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_rasops.ri_do_cursor = cgsix_ras_do_cursor;
		cgsix_ras_init(sc);
	}

	cgsix_stdscreen.nrows = sc->sc_rasops.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_rasops.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_rasops.ri_ops;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
a393 10
	cgsix_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
	cgsix_setcolor(sc, 255, 0, 0, 0);
	cgsix_setcolor(sc, WSCOL_RED, 255, 0, 0);
	cgsix_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
	cgsix_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
	cgsix_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
	cgsix_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
	cgsix_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
	cgsix_setcolor(sc, WSCOL_WHITE, 255, 255, 255);

d395 9
a403 7
		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_crowp = sc->sc_ccolp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;
		sc->sc_rasops.ri_updatecursor = cgsix_ras_updatecursor;
d405 2
a406 2
		wsdisplay_cnattach(&cgsix_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
a417 2
	bus_space_unmap(sa->sa_bustag, sc->sc_fbc_regs, CGSIX_FBC_SIZE);
fail_fbc:
a428 1
;
a442 1
	u_int mode;
a447 7
	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)data;
		if (sc->sc_mode != WSDISPLAYIO_MODE_EMUL &&
		    mode == WSDISPLAYIO_MODE_EMUL)
			cgsix_ras_init(sc);
		sc->sc_mode = mode;
		break;
d501 4
a504 5
	*cookiep = &sc->sc_rasops;
	*curyp = 0;
	*curxp = 0;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
a529 6
struct mmo {
	off_t mo_uaddr;
	bus_size_t mo_size;
	bus_size_t mo_physoff;
};

a536 17
	struct mmo *mo;
	bus_addr_t u;
	bus_size_t sz;

	static struct mmo mmo[] = {
		{ CG6_USER_RAM, 0, CGSIX_VID_OFFSET },

		/* do not actually know how big most of these are! */
		{ CG6_USER_FBC, 1, CGSIX_FBC_OFFSET },
		{ CG6_USER_TEC, 1, CGSIX_TEC_OFFSET },
		{ CG6_USER_BTREGS, 8192 /* XXX */, CGSIX_BT_OFFSET },
		{ CG6_USER_FHC, 1, CGSIX_FHC_OFFSET },
		{ CG6_USER_THC, CGSIX_THC_SIZE, CGSIX_THC_OFFSET },
		{ CG6_USER_ROM, 65536, CGSIX_ROM_OFFSET },
		{ CG6_USER_DHC, 1, CGSIX_DHC_OFFSET },
	};
#define	NMMO (sizeof mmo / sizeof *mmo)
d538 1
a538 1
	if (off & PGOFSET || off < 0)
d541 4
a544 24
	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
		for (mo = mmo; mo < &mmo[NMMO]; mo++) {
			if (off < mo->mo_uaddr)
				continue;
			u = off - mo->mo_uaddr;
			sz = mo->mo_size ? mo->mo_size :
			    sc->sc_linebytes * sc->sc_height;
			if (u < sz) {
				return (bus_space_mmap(sc->sc_bustag,
				    sc->sc_paddr, u + mo->mo_physoff,
				    prot, BUS_SPACE_MAP_LINEAR));
			}
		}
		break;

	case WSDISPLAYIO_MODE_DUMBFB:
		/* Allow mapping as a dumb framebuffer from offset 0 */
		if (off >= 0 && off < (sc->sc_linebytes * sc->sc_height))
			return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
			    off + CGSIX_VID_OFFSET, prot,
			    BUS_SPACE_MAP_LINEAR));
		break;
	}
d578 1
a578 1
	if (index >= 256 || count > 256 - index)
d602 2
a603 1
	if (index >= 256 || count > 256 - index)
d669 1
a669 1
cgsix_reset(sc, fhcrev)
a670 1
	u_int32_t fhcrev;
d672 1
a672 1
	u_int32_t fhc;
d681 2
d684 1
a684 1
	if (fhcrev < 5) {
a688 1
		fhc = FHC_READ(sc);
d692 1
a692 1
		if (fhcrev < 2)
a799 244
}

void
cgsix_ras_init(sc)
	struct cgsix_softc *sc;
{
	u_int32_t m;

	CG6_DRAIN(sc);
	m = FBC_READ(sc, CG6_FBC_MODE);
	m &= ~FBC_MODE_MASK;
	m |= FBC_MODE_VAL;
	FBC_WRITE(sc, CG6_FBC_MODE, m);
}

void
cgsix_ras_copyrows(cookie, src, dst, n)
	void *cookie;
	int src, dst, n;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (dst == src)
		return;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_rows)
		n = ri->ri_rows - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_rows)
		n = ri->ri_rows - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_COPY);
	FBC_WRITE(sc, CG6_FBC_X0, ri->ri_xorigin);
	FBC_WRITE(sc, CG6_FBC_Y0, ri->ri_yorigin + src);
	FBC_WRITE(sc, CG6_FBC_X1, ri->ri_xorigin + ri->ri_emuwidth - 1);
	FBC_WRITE(sc, CG6_FBC_Y1, ri->ri_yorigin + src + n - 1);
	FBC_WRITE(sc, CG6_FBC_X2, ri->ri_xorigin);
	FBC_WRITE(sc, CG6_FBC_Y2, ri->ri_yorigin + dst);
	FBC_WRITE(sc, CG6_FBC_X3, ri->ri_xorigin + ri->ri_emuwidth - 1);
	FBC_WRITE(sc, CG6_FBC_Y3, ri->ri_yorigin + dst + n - 1);
	CG6_BLIT_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_copycols(cookie, row, src, dst, n)
	void *cookie;
	int row, src, dst, n;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (dst == src)
		return;
	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (src < 0) {
		n += src;
		src = 0;
	}
	if (src + n > ri->ri_cols)
		n = ri->ri_cols - src;
	if (dst < 0) {
		n += dst;
		dst = 0;
	}
	if (dst + n > ri->ri_cols)
		n = ri->ri_cols - dst;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_COPY);
	FBC_WRITE(sc, CG6_FBC_X0, ri->ri_xorigin + src);
	FBC_WRITE(sc, CG6_FBC_Y0, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_X1, ri->ri_xorigin + src + n - 1);
	FBC_WRITE(sc, CG6_FBC_Y1,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_X2, ri->ri_xorigin + dst);
	FBC_WRITE(sc, CG6_FBC_Y2, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_X3, ri->ri_xorigin + dst + n - 1);
	FBC_WRITE(sc, CG6_FBC_Y3,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	CG6_BLIT_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_erasecols(cookie, row, col, n, attr)
	void *cookie;
	int row, col, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if ((row < 0) || (row >= ri->ri_rows))
		return;
	if (col < 0) {
		n += col;
		col = 0;
	}
	if (col + n > ri->ri_cols)
		n = ri->ri_cols - col;
	if (n <= 0)
		return;
	n *= ri->ri_font->fontwidth;
	col *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FILL);
	FBC_WRITE(sc, CG6_FBC_FG, ri->ri_devcmap[(attr >> 16) & 0xf]);
	FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col);
	FBC_WRITE(sc, CG6_FBC_ARECTY,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col + n - 1);
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_eraserows(cookie, row, n, attr)
	void *cookie;
	int row, n;
	long int attr;
{
	struct rasops_info *ri = cookie;
	struct cgsix_softc *sc = ri->ri_hw;

	if (row < 0) {
		n += row;
		row = 0;
	}
	if (row + n > ri->ri_rows)
		n = ri->ri_rows - row;
	if (n <= 0)
		return;

	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FILL);
	FBC_WRITE(sc, CG6_FBC_FG, ri->ri_devcmap[(attr >> 16) & 0xf]);
	if ((n == ri->ri_rows) && (ri->ri_flg & RI_FULLCLEAR)) {
		FBC_WRITE(sc, CG6_FBC_ARECTY, 0);
		FBC_WRITE(sc, CG6_FBC_ARECTX, 0);
		FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_height - 1);
		FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_width - 1);
	} else {
		row *= ri->ri_font->fontheight;
		FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
		FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin);
		FBC_WRITE(sc, CG6_FBC_ARECTY,
		    ri->ri_yorigin + row + (n * ri->ri_font->fontheight) - 1);
		FBC_WRITE(sc, CG6_FBC_ARECTX,
		    ri->ri_xorigin + ri->ri_emuwidth - 1);
	}
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_do_cursor(ri)
	struct rasops_info *ri;
{
	struct cgsix_softc *sc = ri->ri_hw;
	int row, col;

	row = ri->ri_crow * ri->ri_font->fontheight;
	col = ri->ri_ccol * ri->ri_font->fontwidth;
	FBC_WRITE(sc, CG6_FBC_CLIP, 0);
	FBC_WRITE(sc, CG6_FBC_S, 0);
	FBC_WRITE(sc, CG6_FBC_OFFX, 0);
	FBC_WRITE(sc, CG6_FBC_OFFY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINX, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMINY, 0);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXX, ri->ri_width - 1);
	FBC_WRITE(sc, CG6_FBC_CLIPMAXY, ri->ri_height - 1);
	FBC_WRITE(sc, CG6_FBC_ALU, FBC_ALU_FLIP);
	FBC_WRITE(sc, CG6_FBC_ARECTY, ri->ri_yorigin + row);
	FBC_WRITE(sc, CG6_FBC_ARECTX, ri->ri_xorigin + col);
	FBC_WRITE(sc, CG6_FBC_ARECTY,
	    ri->ri_yorigin + row + ri->ri_font->fontheight - 1);
	FBC_WRITE(sc, CG6_FBC_ARECTX,
	    ri->ri_xorigin + col + ri->ri_font->fontwidth - 1);
	CG6_DRAW_WAIT(sc);
	CG6_DRAIN(sc);
}

void
cgsix_ras_updatecursor(ri)
	struct rasops_info *ri;
{
	struct cgsix_softc *sc = ri->ri_hw;

	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.1.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.1.2.3 2003/03/28 00:38:29 niklas Exp $	*/
a102 2
int cgsix_setcursor(struct cgsix_softc *, struct wsdisplay_cursor *);
int cgsix_updatecursor(struct cgsix_softc *, u_int);
d279 1
a286 3
	/* for cursor inversion */
	cgsix_setcolor(sc, (~WSCOL_WHITE) & 0xff, 0, 0, 0);
	cgsix_setcolor(sc, (~WSCOL_BLACK) & 0xff, 255, 255, 255);
d337 1
a337 4
	struct wsdisplay_cursor *curs;
	struct wsdisplay_curpos *pos;
	u_char r[2], g[2], b[2];
	int error, s;
d342 1
a342 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG6;
d346 3
a348 6
		if ((sc->sc_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL)
		    == 0) {
			if (sc->sc_mode != WSDISPLAYIO_MODE_EMUL &&
			    mode == WSDISPLAYIO_MODE_EMUL)
				cgsix_ras_init(sc);
		}
d361 1
d368 1
d376 3
a378 48
	case WSDISPLAYIO_SCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		return (cgsix_setcursor(sc, curs));
	case WSDISPLAYIO_GCURSOR:
		curs = (struct wsdisplay_cursor *)data;
		if (curs->which & WSDISPLAY_CURSOR_DOCUR)
			curs->enable = sc->sc_curs_enabled;
		if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
			curs->pos.x = sc->sc_curs_pos.x;
			curs->pos.y = sc->sc_curs_pos.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
			curs->hot.x = sc->sc_curs_hot.x;
			curs->hot.y = sc->sc_curs_hot.y;
		}
		if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
			curs->cmap.index = 0;
			curs->cmap.count = 2;
			r[0] = sc->sc_curs_fg >> 16;
			g[0] = sc->sc_curs_fg >> 8;
			b[0] = sc->sc_curs_fg >> 0;
			r[1] = sc->sc_curs_bg >> 16;
			g[1] = sc->sc_curs_bg >> 8;
			b[1] = sc->sc_curs_bg >> 0;
			error = copyout(r, curs->cmap.red, sizeof(r));
			if (error)
				return (error);
			error = copyout(g, curs->cmap.green, sizeof(g));
			if (error)
				return (error);
			error = copyout(b, curs->cmap.blue, sizeof(b));
			if (error)
				return (error);
		}
		if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
			size_t l;

			curs->size.x = sc->sc_curs_size.x;
			curs->size.y = sc->sc_curs_size.y;
			l = (sc->sc_curs_size.x * sc->sc_curs_size.y) / NBBY;
			error = copyout(sc->sc_curs_image, curs->image, l);
			if (error)
				return (error);
			error = copyout(sc->sc_curs_mask, curs->mask, l);
			if (error)
				return (error);
		}
		break;
a379 4
		pos = (struct wsdisplay_curpos *)data;
		pos->x = sc->sc_curs_pos.x;
		pos->y = sc->sc_curs_pos.y;
		break;
a380 7
		pos = (struct wsdisplay_curpos *)data;
		s = spltty();
		sc->sc_curs_pos.x = pos->x;
		sc->sc_curs_pos.y = pos->y;
		cgsix_updatecursor(sc, WSDISPLAY_CURSOR_DOPOS);
		splx(s);
		break;
d382 2
a383 5
		pos = (struct wsdisplay_curpos *)data;
		pos->x = pos->y = 32;
		break;
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
d385 1
a385 1
		return -1; /* not supported */
a386 114

	return (0);
}

int
cgsix_setcursor(struct cgsix_softc *sc, struct wsdisplay_cursor *curs)
{
	u_int8_t r[2], g[2], b[2], image[128], mask[128];
	int s, error;
	size_t imcount;

	/*
	 * Do stuff that can generate errors first, then we'll blast it
	 * all at once.
	 */
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		if (curs->cmap.count < 2)
			return (EINVAL);
		error = copyin(curs->cmap.red, r, sizeof(r));
		if (error)
			return (error);
		error = copyin(curs->cmap.green, g, sizeof(g));
		if (error)
			return (error);
		error = copyin(curs->cmap.blue, b, sizeof(b));
		if (error)
			return (error);
	}

	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		if (curs->size.x > CG6_MAX_CURSOR ||
		    curs->size.y > CG6_MAX_CURSOR)
			return (EINVAL);
		imcount = (curs->size.x * curs->size.y) / NBBY;
		error = copyin(curs->image, image, imcount);
		if (error)
			return (error);
		error = copyin(curs->mask, mask, imcount);
		if (error)
			return (error);
	}

	/*
	 * Ok, everything is in kernel space and sane, update state.
	 */
	s = spltty();

	if (curs->which & WSDISPLAY_CURSOR_DOCUR)
		sc->sc_curs_enabled = curs->enable;
	if (curs->which & WSDISPLAY_CURSOR_DOPOS) {
		sc->sc_curs_pos.x = curs->pos.x;
		sc->sc_curs_pos.y = curs->pos.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOHOT) {
		sc->sc_curs_hot.x = curs->hot.x;
		sc->sc_curs_hot.y = curs->hot.y;
	}
	if (curs->which & WSDISPLAY_CURSOR_DOCMAP) {
		sc->sc_curs_fg = ((r[0] << 16) | (g[0] << 8) | (b[0] << 0));
		sc->sc_curs_bg = ((r[1] << 16) | (g[1] << 8) | (b[1] << 0));
	}
	if (curs->which & WSDISPLAY_CURSOR_DOSHAPE) {
		sc->sc_curs_size.x = curs->size.x;
		sc->sc_curs_size.y = curs->size.y;
		bcopy(image, sc->sc_curs_image, imcount);
		bcopy(mask, sc->sc_curs_mask, imcount);
	}

	cgsix_updatecursor(sc, curs->which);
	splx(s);

	return (0);
}

int
cgsix_updatecursor(struct cgsix_softc *sc, u_int which)
{
	if (which & WSDISPLAY_CURSOR_DOCMAP) {
		BT_WRITE(sc, BT_ADDR, 1 << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x00ff0000)>> 16) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x0000ff00)>> 8) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_fg & 0x000000ff)>> 0) << 24);

		BT_WRITE(sc, BT_ADDR, 3 << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x00ff0000)>> 16) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x0000ff00)>> 8) << 24);
		BT_WRITE(sc, BT_OMAP, ((sc->sc_curs_bg & 0x000000ff)>> 0) << 24);
	}

	if (which & (WSDISPLAY_CURSOR_DOPOS | WSDISPLAY_CURSOR_DOHOT)) {
		u_int32_t x, y;

		x = sc->sc_curs_pos.x + CG6_MAX_CURSOR - sc->sc_curs_hot.x;
		y = sc->sc_curs_pos.y + CG6_MAX_CURSOR - sc->sc_curs_hot.y;
		THC_WRITE(sc, CG6_THC_CURSXY,
		    ((x & 0xffff) << 16) | (y & 0xffff));
	}

	if (which & WSDISPLAY_CURSOR_DOCUR) {
		u_int32_t c;

		if (sc->sc_curs_enabled) {
			BT_WRITE(sc, BT_ADDR, 6 << 24);
			c = BT_READ(sc, BT_CTRL);
			c |= 3 << 24;
			BT_WRITE(sc, BT_CTRL, c);
		} else {
			BT_WRITE(sc, BT_ADDR, 6 << 24);
			c = BT_READ(sc, BT_CTRL);
			c &= ~(3 << 24);
			BT_WRITE(sc, BT_CTRL, c);
			THC_WRITE(sc, CG6_THC_CURSXY, THC_CURSOFF);
		}
	}
@


1.1.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgsix.c,v 1.1.2.4 2003/05/13 19:35:10 ho Exp $	*/
d15 5
a57 1
#include <dev/ic/bt458reg.h>
d532 9
a540 15
		BT_WRITE(sc, BT_ADDR, BT_OV1 << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x00ff0000) >> 16) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x0000ff00) >> 8) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_fg & 0x000000ff) >> 0) << 24);

		BT_WRITE(sc, BT_ADDR, BT_OV3 << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x00ff0000) >> 16) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x0000ff00) >> 8) << 24);
		BT_WRITE(sc, BT_OMAP,
		    ((sc->sc_curs_bg & 0x000000ff) >> 0) << 24);
a554 1
		/* Enable or disable the cursor overlay planes */
d556 1
a556 1
			BT_WRITE(sc, BT_ADDR, BT_CR << 24);
d558 1
a558 1
			c |= (BTCR_DISPENA_OV0 | BTCR_DISPENA_OV1) << 24;
d561 1
a561 1
			BT_WRITE(sc, BT_ADDR, BT_CR << 24);
d563 1
a563 1
			c &= ~((BTCR_DISPENA_OV0 | BTCR_DISPENA_OV1) << 24);
d824 3
a826 4
	/* enable cursor overlays in brooktree DAC */
	BT_WRITE(sc, BT_ADDR, BT_CR << 24);
	BT_WRITE(sc, BT_CTRL, BT_READ(sc, BT_CTRL) |
	    ((BTCR_DISPENA_OV1 | BTCR_DISPENA_OV0) << 24));
d835 2
a836 2
	/* enable all of the bit planes */
	BT_WRITE(sc, BT_ADDR, BT_RMR << 24);
d841 1
a841 2
	/* no bit planes should blink */
	BT_WRITE(sc, BT_ADDR, BT_BMR << 24);
d846 1
a846 5
	/*
	 * enable the RAMDAC, disable blink, disable overlay 0 and 1,
	 * use 4:1 multiplexor.
	 */
	BT_WRITE(sc, BT_ADDR, BT_CR << 24);
d848 1
a848 2
	BT_WRITE(sc, BT_CTRL,
	    (BTCR_MPLX_4 | BTCR_RAMENA | BTCR_BLINK_6464) << 24);
d851 1
a851 2
	/* disable the D/A read pins */
	BT_WRITE(sc, BT_ADDR, BT_CTR << 24);
d855 1
@


1.1.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a51 1
#include <machine/fbvar.h>
d57 5
d85 2
a86 1
void cgsix_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
d91 1
d126 3
a128 1
cgsixmatch(struct device *parent, void *vcf, void *aux)
d137 3
a139 1
cgsixattach(struct device *parent, struct device *self, void *aux)
d145 1
d156 4
a159 1
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, sa->sa_node, 0);
d187 1
a187 1
	    sc->sc_sunfb.sf_fbsize, BUS_SPACE_MAP_LINEAR,
d208 1
a208 1
	    IPL_TTY, 0, cgsix_intr, sc, self->dv_xname)) == NULL) {
d235 5
a239 1
	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
d241 8
a248 2
	sc->sc_sunfb.sf_ro.ri_hw = sc;
	fbwscons_init(&sc->sc_sunfb, console ? 0 : RI_CLEAR);
d257 1
a257 1
		sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags |= CG6_CFFLAG_NOACCEL;
d259 6
a264 7
	if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags & CG6_CFFLAG_NOACCEL)
	    == 0) {
		sc->sc_sunfb.sf_ro.ri_ops.copyrows = cgsix_ras_copyrows;
		sc->sc_sunfb.sf_ro.ri_ops.copycols = cgsix_ras_copycols;
		sc->sc_sunfb.sf_ro.ri_ops.eraserows = cgsix_ras_eraserows;
		sc->sc_sunfb.sf_ro.ri_ops.erasecols = cgsix_ras_erasecols;
		sc->sc_sunfb.sf_ro.ri_do_cursor = cgsix_ras_do_cursor;
d268 5
a272 4
	cgsix_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgsix_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgsix_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgsix_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d276 11
a286 1
	fbwscons_setcolormap(&sc->sc_sunfb, cgsix_setcolor);
d289 10
a298 3
		sc->sc_sunfb.sf_ro.ri_updatecursor = cgsix_ras_updatecursor;
		fbwscons_console_init(&sc->sc_sunfb, &cgsix_stdscreen, -1,
		    cgsix_burner);
d327 6
a332 1
cgsix_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
d349 2
a350 2
		if ((sc->sc_sunfb.sf_dev.dv_cfdata->cf_flags &
		    CG6_CFFLAG_NOACCEL) == 0) {
d359 3
a361 3
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
d365 1
a365 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d576 6
a581 2
cgsix_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
d588 1
a588 1
	*cookiep = &sc->sc_sunfb.sf_ro;
d591 1
a591 1
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
d598 3
a600 1
cgsix_free_screen(void *v, void *cookie)
d608 6
a613 2
cgsix_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
d625 4
a628 1
cgsix_mmap(void *v, off_t off, int prot)
d658 2
a659 1
			sz = mo->mo_size ? mo->mo_size : sc->sc_sunfb.sf_fbsize;
d670 1
a670 1
		if (off >= 0 && off < sc->sc_sunfb.sf_fbsize)
d680 12
d693 2
a694 1
cgsix_is_console(int node)
d702 3
a704 1
cg6_bt_getcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
d726 3
a728 1
cg6_bt_putcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
d750 3
a752 1
cgsix_loadcmap_deferred(struct cgsix_softc *sc, u_int start, u_int ncolors)
d763 3
a765 1
cgsix_loadcmap_immediate(struct cgsix_softc *sc, u_int start, u_int ncolors)
d785 4
a788 1
cgsix_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
a789 1
	struct cgsix_softc *sc = v;
d799 3
a801 1
cgsix_reset(struct cgsix_softc *sc, u_int32_t fhcrev)
d834 2
a835 1
cgsix_hardreset(struct cgsix_softc *sc)
d896 3
a898 1
cgsix_burner(void *vsc, u_int on, u_int flags)
d918 2
a919 1
cgsix_intr(void *vsc)
d940 2
a941 1
cgsix_ras_init(struct cgsix_softc *sc)
d953 3
a955 1
cgsix_ras_copyrows(void *cookie, int src, int dst, int n)
d1002 3
a1004 1
cgsix_ras_copycols(void *cookie, int row, int src, int dst, int n)
d1056 4
a1059 1
cgsix_ras_erasecols(void *cookie, int row, int col, int n, long int attr)
d1098 4
a1101 1
cgsix_ras_eraserows(void *cookie, int row, int n, long int attr)
d1144 2
a1145 1
cgsix_ras_do_cursor(struct rasops_info *ri)
d1172 2
a1173 1
cgsix_ras_updatecursor(struct rasops_info *ri)
d1177 4
a1180 4
	if (sc->sc_sunfb.sf_crowp != NULL)
		*sc->sc_sunfb.sf_crowp = ri->ri_crow;
	if (sc->sc_sunfb.sf_ccolp != NULL)
		*sc->sc_sunfb.sf_ccolp = ri->ri_ccol;
@


