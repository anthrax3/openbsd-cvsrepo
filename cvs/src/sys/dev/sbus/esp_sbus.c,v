head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.2
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.24.0.16
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.12
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.10
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.8
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.14
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.12
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.4
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.5.0.6
	UBC_BASE:1.5
	SMP:1.5.0.4
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.25
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	uRv5pa9QDlZaYgwD;

1.24
date	2014.01.18.22.33.59;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.21.22.25.17;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.02.20.00.56;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.29.19.17.43;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.03.21.02.13;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.27.01.36.53;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.24.21.54.38;	author henric;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.27.16.43.28;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.11.19.20.28;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.09.09.25.11;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.09.22.33.58;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.03.16.07;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.27.04.01.42;	author jason;	state Exp;
branches
	1.5.4.1
	1.5.6.1;
next	1.4;

1.4
date	2001.09.26.00.03.34;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.25.23.58.15;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.21.14.57.56;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.21.14.30.09;	author jason;	state Exp;
branches;
next	;

1.5.4.1
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.03.28.00.38.30;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.05.13.19.35.10;	author ho;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2004.02.19.10.56.32;	author niklas;	state Exp;
branches;
next	;

1.5.6.1
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2003.05.19.22.14.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: esp_sbus.c,v 1.24 2014/01/18 22:33:59 dlg Exp $	*/
/*	$NetBSD: esp_sbus.c,v 1.14 2001/04/25 17:53:37 bouyer Exp $	*/

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum; Jason R. Thorpe of the Numerical Aerospace
 * Simulation Facility, NASA Ames Research Center; Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/malloc.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>

#include <dev/ic/lsi64854reg.h>
#include <dev/ic/lsi64854var.h>

#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>

#include <dev/sbus/sbusvar.h>

/* #define ESP_SBUS_DEBUG */

static int esp_unit_offset;

struct esp_softc {
	struct ncr53c9x_softc sc_ncr53c9x;	/* glue to MI code */

	bus_space_tag_t	sc_bustag;
	bus_dma_tag_t	sc_dmatag;

	bus_space_handle_t sc_reg;		/* the registers */
	struct lsi64854_softc *sc_dma;		/* pointer to my dma */

	int	sc_pri;				/* SBUS priority */
};

void	espattach_sbus(struct device *, struct device *, void *);
void	espattach_dma(struct device *, struct device *, void *);
int	espmatch_sbus(struct device *, void *, void *);


/* Linkup to the rest of the kernel */
struct cfattach esp_sbus_ca = {
	sizeof(struct esp_softc), espmatch_sbus, espattach_sbus
};
struct cfattach esp_dma_ca = {
	sizeof(struct esp_softc), espmatch_sbus, espattach_dma
};

/*
 * Functions and the switch for the MI code.
 */
static u_char	esp_read_reg(struct ncr53c9x_softc *, int);
static void	esp_write_reg(struct ncr53c9x_softc *, int, u_char);
static u_char	esp_rdreg1(struct ncr53c9x_softc *, int);
static void	esp_wrreg1(struct ncr53c9x_softc *, int, u_char);
static int	esp_dma_isintr(struct ncr53c9x_softc *);
static void	esp_dma_reset(struct ncr53c9x_softc *);
static int	esp_dma_intr(struct ncr53c9x_softc *);
static int	esp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
				    size_t *, int, size_t *);
static void	esp_dma_go(struct ncr53c9x_softc *);
static void	esp_dma_stop(struct ncr53c9x_softc *);
static int	esp_dma_isactive(struct ncr53c9x_softc *);

static struct ncr53c9x_glue esp_sbus_glue = {
	esp_read_reg,
	esp_write_reg,
	esp_dma_isintr,
	esp_dma_reset,
	esp_dma_intr,
	esp_dma_setup,
	esp_dma_go,
	esp_dma_stop,
	esp_dma_isactive,
	NULL,			/* gl_clear_latched_intr */
};

static struct ncr53c9x_glue esp_sbus_glue1 = {
	esp_rdreg1,
	esp_wrreg1,
	esp_dma_isintr,
	esp_dma_reset,
	esp_dma_intr,
	esp_dma_setup,
	esp_dma_go,
	esp_dma_stop,
	esp_dma_isactive,
	NULL,			/* gl_clear_latched_intr */
};

static void	espattach(struct esp_softc *, struct ncr53c9x_glue *);

int
espmatch_sbus(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	int rv;
	struct sbus_attach_args *sa = aux;

	if (strcmp("SUNW,fas", sa->sa_name) == 0)
	        return 1;

	rv = (strcmp(cf->cf_driver->cd_name, sa->sa_name) == 0 ||
	    strcmp("ptscII", sa->sa_name) == 0);
	return (rv);
}

void
espattach_sbus(struct device *parent, struct device *self, void *aux)
{
	struct esp_softc *esc = (void *)self;
	struct ncr53c9x_softc *sc = &esc->sc_ncr53c9x;
	struct sbus_attach_args *sa = aux;
	struct lsi64854_softc *lsc;
	int burst, sbusburst;

	esc->sc_bustag = sa->sa_bustag;
	esc->sc_dmatag = sa->sa_dmatag;

	sc->sc_id = getpropint(sa->sa_node, "initiator-id", 7);
	sc->sc_freq = getpropint(sa->sa_node, "clock-frequency", -1);
	if (sc->sc_freq < 0)
		sc->sc_freq = sa->sa_frequency;

#ifdef ESP_SBUS_DEBUG
	printf("%s: espattach_sbus: sc_id %d, freq %d\n",
	       self->dv_xname, sc->sc_id, sc->sc_freq);
#endif

	if (strcmp("SUNW,fas", sa->sa_name) == 0) {
		/*
		 * offset searches for other esp/dma devices.
		 */
		esp_unit_offset++;

		/*
		 * fas has 2 register spaces: dma(lsi64854) and SCSI core (ncr53c9x)
		 */
		if (sa->sa_nreg != 2) {
			printf("%s: %d register spaces\n", self->dv_xname, sa->sa_nreg);
			return;
		}

		/*
		 * allocate space for dma, in SUNW,fas there are no separate
		 * dma device
		 */
		lsc = malloc(sizeof (struct lsi64854_softc), M_DEVBUF, M_NOWAIT);

		if (lsc == NULL) {
			printf("%s: out of memory (lsi64854_softc)\n",
			       self->dv_xname);
			return;
		}
		esc->sc_dma = lsc;

		lsc->sc_bustag = sa->sa_bustag;
		lsc->sc_dmatag = sa->sa_dmatag;

		bcopy(sc->sc_dev.dv_xname, lsc->sc_dev.dv_xname,
		      sizeof (lsc->sc_dev.dv_xname));

		/* Map dma registers */
		if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
		    sa->sa_reg[0].sbr_offset, sa->sa_reg[0].sbr_size,
		    0, 0, &lsc->sc_regs) != 0) {
			printf("%s: cannot map dma registers\n", self->dv_xname);
			return;
		}

		/*
		 * XXX is this common(from bpp.c), the same in dma_sbus...etc.
		 *
		 * Get transfer burst size from PROM and plug it into the
		 * controller registers. This is needed on the Sun4m; do
		 * others need it too?
		 */
		sbusburst = ((struct sbus_softc *)parent)->sc_burst;
		if (sbusburst == 0)
			sbusburst = SBUS_BURST_32 - 1; /* 1->16 */

		burst = getpropint(sa->sa_node, "burst-sizes", -1);

#ifdef ESP_SBUS_DEBUG
		printf("espattach_sbus: burst 0x%x, sbus 0x%x\n",
		    burst, sbusburst);
#endif

		if (burst == -1)
			/* take SBus burst sizes */
			burst = sbusburst;

		/* Clamp at parent's burst sizes */
		burst &= sbusburst;
		lsc->sc_burst = (burst & SBUS_BURST_32) ? 32 :
		    (burst & SBUS_BURST_16) ? 16 : 0;

		lsc->sc_channel = L64854_CHANNEL_SCSI;
		lsc->sc_client = sc;

		lsi64854_attach(lsc);

		/*
		 * map SCSI core registers
		 */
		if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[1].sbr_slot,
		    sa->sa_reg[1].sbr_offset, sa->sa_reg[1].sbr_size,
		    0, 0, &esc->sc_reg) != 0) {
			printf("%s: cannot map scsi core registers\n",
			       self->dv_xname);
			return;
		}

		if (sa->sa_nintr == 0) {
			printf("%s: no interrupt property\n", self->dv_xname);
			return;
		}

		esc->sc_pri = sa->sa_pri;

		printf("%s", self->dv_xname);
		espattach(esc, &esp_sbus_glue);

		return;
	}

	/*
	 * Find the DMA by poking around the dma device structures
	 *
	 * What happens here is that if the dma driver has not been
	 * configured, then this returns a NULL pointer. Then when the
	 * dma actually gets configured, it does the opposing test, and
	 * if the sc->sc_esp field in its softc is NULL, then tries to
	 * find the matching esp driver.
	 */
	esc->sc_dma = (struct lsi64854_softc *)
	    getdevunit("dma", sc->sc_dev.dv_unit - esp_unit_offset);

	/*
	 * and a back pointer to us, for DMA
	 */
	if (esc->sc_dma)
		esc->sc_dma->sc_client = sc;
	else {
		printf("\n");
		panic("espattach: no dma found");
	}

	/*
	 * The `ESC' DMA chip must be reset before we can access
	 * the esp registers.
	 */
	if (esc->sc_dma->sc_rev == DMAREV_ESC)
		DMA_RESET(esc->sc_dma);

	/*
	 * Map my registers in, if they aren't already in virtual
	 * address space.
	 */
	if (sa->sa_npromvaddrs) {
		if (bus_space_map(sa->sa_bustag, sa->sa_promvaddrs[0],
		    sa->sa_size, BUS_SPACE_MAP_PROMADDRESS,
		    &esc->sc_reg) != 0) {
			printf("%s @@ sbus: cannot map registers\n",
				self->dv_xname);
			return;
		}
	} else {
		if (sbus_bus_map(sa->sa_bustag, sa->sa_slot,
		    sa->sa_offset, sa->sa_size, 0, 0, &esc->sc_reg) != 0) {
			printf("%s @@ sbus: cannot map registers\n",
				self->dv_xname);
			return;
		}
	}

	if (sa->sa_nintr == 0) {
		/*
		 * No interrupt properties: we quit; this might
		 * happen on e.g. a Sparc X terminal.
		 */
		printf("\n%s: no interrupt property\n", self->dv_xname);
		return;
	}

	esc->sc_pri = sa->sa_pri;

	if (strcmp("ptscII", sa->sa_name) == 0) {
		espattach(esc, &esp_sbus_glue1);
	} else {
		espattach(esc, &esp_sbus_glue);
	}
}

void
espattach_dma(struct device *parent, struct device *self, void *aux)
{
	struct esp_softc *esc = (void *)self;
	struct ncr53c9x_softc *sc = &esc->sc_ncr53c9x;
	struct sbus_attach_args *sa = aux;

	if (strcmp("ptscII", sa->sa_name) == 0) {
		return;
	}

	esc->sc_bustag = sa->sa_bustag;
	esc->sc_dmatag = sa->sa_dmatag;

	sc->sc_id = getpropint(sa->sa_node, "initiator-id", 7);
	sc->sc_freq = getpropint(sa->sa_node, "clock-frequency", -1);

	esc->sc_dma = (struct lsi64854_softc *)parent;
	esc->sc_dma->sc_client = sc;

	/*
	 * Map my registers in, if they aren't already in virtual
	 * address space.
	 */
	if (sa->sa_npromvaddrs) {
		if (bus_space_map(sa->sa_bustag, sa->sa_promvaddrs[0],
		    sa->sa_size /* ??? */, BUS_SPACE_MAP_PROMADDRESS,
		    &esc->sc_reg) != 0) {
			printf("%s @@ dma: cannot map registers\n",
				self->dv_xname);
			return;
		}
	} else {
		if (sbus_bus_map(sa->sa_bustag, sa->sa_slot, sa->sa_offset,
		    sa->sa_size, 0, 0, &esc->sc_reg) != 0) {
			printf("%s @@ dma: cannot map registers\n",
				self->dv_xname);
			return;
		}
	}

	if (sa->sa_nintr == 0) {
		/*
		 * No interrupt properties: we quit; this might
		 * happen on e.g. a Sparc X terminal.
		 */
		printf("\n%s: no interrupt property\n", self->dv_xname);
		return;
	}

	esc->sc_pri = sa->sa_pri;

	espattach(esc, &esp_sbus_glue);
}


/*
 * Attach this instance, and then all the sub-devices
 */
void
espattach(struct esp_softc *esc, struct ncr53c9x_glue *gluep)
{
	struct ncr53c9x_softc *sc = &esc->sc_ncr53c9x;
	void *icookie;
	unsigned int uid = 0;

	/*
	 * Set up glue for MI code early; we use some of it here.
	 */
	sc->sc_glue = gluep;

	/* gimme MHz */
	sc->sc_freq /= 1000000;

	/*
	 * XXX More of this should be in ncr53c9x_attach(), but
	 * XXX should we really poke around the chip that much in
	 * XXX the MI code?  Think about this more...
	 */

	/*
	 * It is necessary to try to load the 2nd config register here,
	 * to find out what rev the esp chip is, else the ncr53c9x_reset
	 * will not set up the defaults correctly.
	 */
	sc->sc_cfg1 = sc->sc_id | NCRCFG1_PARENB;
	sc->sc_cfg2 = NCRCFG2_SCSI2 | NCRCFG2_RPE;
	sc->sc_cfg3 = NCRCFG3_CDB;
	NCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);

	if ((NCR_READ_REG(sc, NCR_CFG2) & ~NCRCFG2_RSVD) !=
	    (NCRCFG2_SCSI2 | NCRCFG2_RPE)) {
		sc->sc_rev = NCR_VARIANT_ESP100;
	} else {
		sc->sc_cfg2 = NCRCFG2_SCSI2;
		NCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);
		sc->sc_cfg3 = 0;
		NCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);
		sc->sc_cfg3 = (NCRCFG3_CDB | NCRCFG3_FCLK);
		NCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);
		if (NCR_READ_REG(sc, NCR_CFG3) !=
		    (NCRCFG3_CDB | NCRCFG3_FCLK)) {
			sc->sc_rev = NCR_VARIANT_ESP100A;
		} else {
			/* NCRCFG2_FE enables > 64K transfers */
			sc->sc_cfg2 |= NCRCFG2_FE;
			sc->sc_cfg3 = 0;
			NCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);
			sc->sc_rev = NCR_VARIANT_ESP200;

			/* XXX spec says it's valid after power up or chip reset */
			uid = NCR_READ_REG(sc, NCR_UID);
			if (((uid & 0xf8) >> 3) == 0x0a) /* XXX */
				sc->sc_rev = NCR_VARIANT_FAS366;
		}
	}

#ifdef ESP_SBUS_DEBUG
	printf("espattach: revision %d, uid 0x%x\n", sc->sc_rev, uid);
#endif

	/*
	 * XXX minsync and maxxfer _should_ be set up in MI code,
	 * XXX but it appears to have some dependency on what sort
	 * XXX of DMA we're hooked up to, etc.
	 */

	/*
	 * This is the value used to start sync negotiations
	 * Note that the NCR register "SYNCTP" is programmed
	 * in "clocks per byte", and has a minimum value of 4.
	 * The SCSI period used in negotiation is one-fourth
	 * of the time (in nanoseconds) needed to transfer one byte.
	 * Since the chip's clock is given in MHz, we have the following
	 * formula: 4 * period = (1000 / freq) * 4
	 */
	sc->sc_minsync = 1000 / sc->sc_freq;

	/*
	 * Alas, we must now modify the value a bit, because it's
	 * only valid when can switch on FASTCLK and FASTSCSI bits  
	 * in config register 3... 
	 */
	switch (sc->sc_rev) {
	case NCR_VARIANT_ESP100:
		sc->sc_maxxfer = 64 * 1024;
		sc->sc_minsync = 0;	/* No synch on old chip? */
		break;

	case NCR_VARIANT_ESP100A:
		sc->sc_maxxfer = 64 * 1024;
		/* Min clocks/byte is 5 */
		sc->sc_minsync = ncr53c9x_cpb2stp(sc, 5);
		break;

	case NCR_VARIANT_ESP200:
	case NCR_VARIANT_FAS366:
		sc->sc_maxxfer = 16 * 1024 * 1024;
		/* XXX - do actually set FAST* bits */
		break;
	}

	/* Establish interrupt channel */
	icookie = bus_intr_establish(esc->sc_bustag, esc->sc_pri, IPL_BIO, 0,
				     ncr53c9x_intr, sc, sc->sc_dev.dv_xname);

	/* Turn on target selection using the `dma' method */
	if (sc->sc_rev != NCR_VARIANT_FAS366)
		sc->sc_features |= NCR_F_DMASELECT;

	/* Do the common parts of attachment. */
	ncr53c9x_attach(sc);
}

/*
 * Glue functions.
 */

#ifdef ESP_SBUS_DEBUG
int esp_sbus_debug = 0;

static struct {
	char *r_name;
	int   r_flag; 
} esp__read_regnames [] = {
	{ "TCL", 0},			/* 0/00 */
	{ "TCM", 0},			/* 1/04 */
	{ "FIFO", 0},			/* 2/08 */
	{ "CMD", 0},			/* 3/0c */
	{ "STAT", 0},			/* 4/10 */
	{ "INTR", 0},			/* 5/14 */
	{ "STEP", 0},			/* 6/18 */
	{ "FFLAGS", 1},			/* 7/1c */
	{ "CFG1", 1},			/* 8/20 */
	{ "STAT2", 0},			/* 9/24 */
	{ "CFG4", 1},			/* a/28 */
	{ "CFG2", 1},			/* b/2c */
	{ "CFG3", 1},			/* c/30 */
	{ "-none", 1},			/* d/34 */
	{ "TCH", 1},			/* e/38 */
	{ "TCX", 1},			/* f/3c */
};

static struct {
	char *r_name;
	int   r_flag;
} esp__write_regnames[] = {
	{ "TCL", 1},			/* 0/00 */
	{ "TCM", 1},			/* 1/04 */
	{ "FIFO", 0},			/* 2/08 */
	{ "CMD", 0},			/* 3/0c */
	{ "SELID", 1},			/* 4/10 */
	{ "TIMEOUT", 1},		/* 5/14 */
	{ "SYNCTP", 1},			/* 6/18 */
	{ "SYNCOFF", 1},		/* 7/1c */
	{ "CFG1", 1},			/* 8/20 */
	{ "CCF", 1},			/* 9/24 */
	{ "TEST", 1},			/* a/28 */
	{ "CFG2", 1},			/* b/2c */
	{ "CFG3", 1},			/* c/30 */
	{ "-none", 1},			/* d/34 */
	{ "TCH", 1},			/* e/38 */
	{ "TCX", 1},			/* f/3c */
};
#endif

u_char
esp_read_reg(struct ncr53c9x_softc *sc, int reg)
{
	struct esp_softc *esc = (struct esp_softc *)sc;
	u_char v;

	v = bus_space_read_1(esc->sc_bustag, esc->sc_reg, reg * 4);
#ifdef ESP_SBUS_DEBUG
	if (esp_sbus_debug && (reg < 0x10) && esp__read_regnames[reg].r_flag)
		printf("RD:%x <%s> %x\n", reg * 4,
		    ((unsigned)reg < 0x10) ? esp__read_regnames[reg].r_name : "<***>", v);
#endif
	return v;
}

void
esp_write_reg(struct ncr53c9x_softc *sc, int reg, u_char v)
{
	struct esp_softc *esc = (struct esp_softc *)sc;

#ifdef ESP_SBUS_DEBUG
	if (esp_sbus_debug && (reg < 0x10) && esp__write_regnames[reg].r_flag)
		printf("WR:%x <%s> %x\n", reg * 4,
		    ((unsigned)reg < 0x10) ? esp__write_regnames[reg].r_name : "<***>", v);
#endif
	bus_space_write_1(esc->sc_bustag, esc->sc_reg, reg * 4, v);
}

u_char
esp_rdreg1(struct ncr53c9x_softc *sc, int reg)
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (bus_space_read_1(esc->sc_bustag, esc->sc_reg, reg));
}

void
esp_wrreg1(struct ncr53c9x_softc *sc, int reg, u_char v)
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	bus_space_write_1(esc->sc_bustag, esc->sc_reg, reg, v);
}

int
esp_dma_isintr(struct ncr53c9x_softc *sc)
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (DMA_ISINTR(esc->sc_dma));
}

void
esp_dma_reset(struct ncr53c9x_softc *sc)
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	DMA_RESET(esc->sc_dma);
}

int
esp_dma_intr(struct ncr53c9x_softc *sc)
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (DMA_INTR(esc->sc_dma));
}

int
esp_dma_setup(struct ncr53c9x_softc *sc, caddr_t *addr, size_t *len,
    int datain, size_t *dmasize)
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (DMA_SETUP(esc->sc_dma, addr, len, datain, dmasize));
}

void
esp_dma_go(struct ncr53c9x_softc *sc)
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	DMA_GO(esc->sc_dma);
}

void
esp_dma_stop(struct ncr53c9x_softc *sc)
{
	struct esp_softc *esc = (struct esp_softc *)sc;
	u_int32_t csr;

	csr = L64854_GCSR(esc->sc_dma);
	csr &= ~D_EN_DMA;
	L64854_SCSR(esc->sc_dma, csr);
}

int
esp_dma_isactive(struct ncr53c9x_softc *sc)
{
	struct esp_softc *esc = (struct esp_softc *)sc;

	return (DMA_ISACTIVE(esc->sc_dma));
}

#if defined(DDB) && defined(notyet)
#include <machine/db_machdep.h>
#include <ddb/db_output.h>

void db_esp(db_expr_t, int, db_expr_t, char *);

void
db_esp(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct ncr53c9x_softc *sc;
	struct ncr53c9x_ecb *ecb;
	struct ncr53c9x_linfo *li;
	int u, t, i;

	for (u=0; u<10; u++) {
		sc = (struct ncr53c9x_softc *)
			getdevunit("esp", u);
		if (!sc) continue;

		db_printf("esp%d: nexus %p phase %x prev %x dp %p dleft %lx ify %x\n",
			  u, sc->sc_nexus, sc->sc_phase, sc->sc_prevphase, 
			  sc->sc_dp, sc->sc_dleft, sc->sc_msgify);
		db_printf("\tmsgout %x msgpriq %x msgin %x:%x:%x:%x:%x\n",
			  sc->sc_msgout, sc->sc_msgpriq, sc->sc_imess[0],
			  sc->sc_imess[1], sc->sc_imess[2], sc->sc_imess[3],
			  sc->sc_imess[0]);
		db_printf("ready: ");
		TAILQ_FOREACH(ecb, &sc->ready_list, chain) {
			db_printf("ecb %p ", ecb);
			if (ecb == TAILQ_NEXT(ecb, chain)) {
				db_printf("\nWARNING: tailq loop on ecb %p", ecb);
				break;
			}
		}
		db_printf("\n");
		
		for (t=0; t<NCR_NTARG; t++) {
			LIST_FOREACH(li, &sc->sc_tinfo[t].luns, link) {
				db_printf("t%d lun %d untagged %p busy %d used %x\n",
					  t, (int)li->lun, li->untagged, li->busy,
					  li->used);
				for (i=0; i<256; i++)
					if ((ecb = li->queued[i])) {
						db_printf("ecb %p tag %x\n", ecb, i);
					}
			}
		}
	}
}
#endif

@


1.24
log
@instead of having every bit of glue set up and attach an identical
scsi_adapter struct, just do it once in the chip code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.23 2010/06/28 18:31:02 krw Exp $	*/
a33 1
#include <sys/types.h>
@


1.23
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.22 2009/02/16 21:19:07 miod Exp $	*/
a56 7
struct scsi_adapter esp_switch = {
	ncr53c9x_scsi_cmd,
	scsi_minphys,		/* no max at this level; handled by DMA code */
	NULL,
	NULL,
};

d503 1
a503 1
	ncr53c9x_attach(sc, &esp_switch);
@


1.22
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.21 2008/06/26 05:42:18 ray Exp $	*/
a63 7
struct scsi_device esp_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};

d510 1
a510 1
	ncr53c9x_attach(sc, &esp_switch, &esp_dev);
@


1.21
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.20 2007/04/10 17:47:55 miod Exp $	*/
d59 1
a59 1
	minphys,		/* no max at this level; handled by DMA code */
@


1.20
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.19 2006/06/21 22:25:17 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.19
log
@Pick the sbus clock frequency from the attach args instead of peeking at the
parent softc.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.18 2006/06/02 20:00:56 miod Exp $	*/
d291 1
a291 1
	 * if the sc->sc_esp field in it's softc is NULL, then tries to
@


1.18
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.17 2006/03/05 21:48:56 miod Exp $	*/
d181 1
a181 2
		sc->sc_freq = ((struct sbus_softc *)
		    sc->sc_dev.dv_parent)->sc_clockfreq;
@


1.17
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.16 2004/09/29 19:17:43 miod Exp $	*/
a83 1
	struct sbusdev	sc_sd;			/* sbus device */
a279 4
		/* add me to the sbus structures */
		esc->sc_sd.sd_reset = (void *) ncr53c9x_reset;
		sbus_establish(&esc->sc_sd, &sc->sc_dev);

a346 4
	/* add me to the sbus structures */
	esc->sc_sd.sd_reset = (void *) ncr53c9x_reset;
	sbus_establish(&esc->sc_sd, &sc->sc_dev);

a404 4

	/* Assume SBus is grandparent */
	esc->sc_sd.sd_reset = (void *) ncr53c9x_reset;
	sbus_establish(&esc->sc_sd, parent);
@


1.16
log
@Ratibibugle now useless evcnt structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.15 2003/07/03 21:02:13 jason Exp $	*/
d724 1
a724 1
		for (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {
d726 1
a726 1
			if (ecb == ecb->chain.tqe_next) {
@


1.15
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.14 2003/06/27 01:36:53 jason Exp $	*/
a531 3

	/* register interrupt stats */
	evcnt_attach(&sc->sc_dev, "intr", &sc->sc_intrcnt);
@


1.14
log
@These don't need linear mappings either.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.13 2003/06/24 21:54:38 henric Exp $	*/
d153 1
a153 4
espmatch_sbus(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
d168 1
a168 3
espattach_sbus(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d364 1
a364 3
espattach_dma(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d427 1
a427 3
espattach(esc, gluep)
	struct esp_softc *esc;
	struct ncr53c9x_glue *gluep;
d597 1
a597 3
esp_read_reg(sc, reg)
	struct ncr53c9x_softc *sc;
	int reg;
d612 1
a612 4
esp_write_reg(sc, reg, v)
	struct ncr53c9x_softc *sc;
	int reg;
	u_char v;
d625 1
a625 3
esp_rdreg1(sc, reg)
	struct ncr53c9x_softc *sc;
	int reg;
d633 1
a633 4
esp_wrreg1(sc, reg, v)
	struct ncr53c9x_softc *sc;
	int reg;
	u_char v;
d641 1
a641 2
esp_dma_isintr(sc)
	struct ncr53c9x_softc *sc;
d649 1
a649 2
esp_dma_reset(sc)
	struct ncr53c9x_softc *sc;
d657 1
a657 2
esp_dma_intr(sc)
	struct ncr53c9x_softc *sc;
d665 2
a666 6
esp_dma_setup(sc, addr, len, datain, dmasize)
	struct ncr53c9x_softc *sc;
	caddr_t *addr;
	size_t *len;
	int datain;
	size_t *dmasize;
d674 1
a674 2
esp_dma_go(sc)
	struct ncr53c9x_softc *sc;
d682 1
a682 2
esp_dma_stop(sc)
	struct ncr53c9x_softc *sc;
d693 1
a693 2
esp_dma_isactive(sc)
	struct ncr53c9x_softc *sc;
d707 1
a707 5
db_esp(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
@


1.13
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.12 2003/03/27 16:43:28 jason Exp $	*/
d404 1
a404 1
		    sa->sa_size, BUS_SPACE_MAP_LINEAR, 0, &esc->sc_reg) != 0) {
@


1.12
log
@Don't need linear mappings in here.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.11 2003/02/17 01:29:20 henric Exp $	*/
d540 1
a540 1
				     ncr53c9x_intr, sc);
@


1.11
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.10 2003/02/11 19:20:28 mickey Exp $	*/
d229 3
a231 6
		if (sbus_bus_map(sa->sa_bustag,
		                   sa->sa_reg[0].sbr_slot,
			           sa->sa_reg[0].sbr_offset,
			           sa->sa_reg[0].sbr_size,
			           BUS_SPACE_MAP_LINEAR,
			           0, &lsc->sc_regs) != 0) {
d271 3
a273 6
		if (sbus_bus_map(sa->sa_bustag,
				 sa->sa_reg[1].sbr_slot,
				 sa->sa_reg[1].sbr_offset,
				 sa->sa_reg[1].sbr_size,
				 BUS_SPACE_MAP_LINEAR, 
				 0, &esc->sc_reg) != 0) {
d331 2
a332 3
				 sa->sa_size,
				 BUS_SPACE_MAP_PROMADDRESS | BUS_SPACE_MAP_LINEAR,
				 &esc->sc_reg) != 0) {
d339 1
a339 4
				 sa->sa_offset,
				 sa->sa_size,
				 BUS_SPACE_MAP_LINEAR,
				 0, &esc->sc_reg) != 0) {
d395 3
a397 5
		if (bus_space_map(sa->sa_bustag,
				   sa->sa_promvaddrs[0],
				   sa->sa_size,		/* ??? */
				   BUS_SPACE_MAP_PROMADDRESS | BUS_SPACE_MAP_LINEAR,
				   &esc->sc_reg) != 0) {
d403 2
a404 6
		if (sbus_bus_map(sa->sa_bustag,
				   sa->sa_slot,
				   sa->sa_offset,
				   sa->sa_size,
				   BUS_SPACE_MAP_LINEAR,
				   0, &esc->sc_reg) != 0) {
@


1.10
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.9 2003/02/09 09:25:11 jason Exp $	*/
d229 1
a229 1
		if (bus_space_map2(sa->sa_bustag,
d335 10
a344 3
	if (sa->sa_npromvaddrs)
		esc->sc_reg = (bus_space_handle_t)sa->sa_promvaddrs[0];
	else {
d404 12
a415 4
	if (sa->sa_npromvaddrs)
		esc->sc_reg = (bus_space_handle_t)sa->sa_promvaddrs[0];
	else {
		if (bus_space_map2(sa->sa_bustag,
@


1.9
log
@make ESP_SBUS_DEBUG compile
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.8 2002/04/09 22:33:58 jason Exp $	*/
d448 1
a448 1
	/* gimme Mhz */
@


1.8
log
@because SUNW,fas boards don't have a corresponding 'dma' device, searching
for the corresponding 'dma' for a non-fas 'esp' needs to have an offset
(really a count of the number of 'fas's)
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.7 2002/03/14 03:16:07 millert Exp $	*/
d252 1
a252 1
#if ESP_SBUS_DEBUG
@


1.7
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.6 2002/03/14 01:27:02 millert Exp $	*/
d80 2
d196 4
d312 1
a312 1
				getdevunit("dma", sc->sc_dev.dv_unit);
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.5 2001/09/27 04:01:42 jason Exp $	*/
d728 1
a728 1
void db_esp(db_expr_t, int, db_expr_t, char*);
@


1.5
log
@Huge merge with NetBSD.  For full details look at their revision history (1.26 -> 1.83)...
Highlights:
o tag queue support
o fas366 support (doesn't work yet on sparc, but does on sparc64)
o tons more
(thanks to hugh, fgsch and beck for testing)
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.4 2001/09/26 00:03:34 jason Exp $	*/
d93 3
a95 3
void	espattach_sbus	__P((struct device *, struct device *, void *));
void	espattach_dma	__P((struct device *, struct device *, void *));
int	espmatch_sbus	__P((struct device *, void *, void *));
d109 12
a120 12
static u_char	esp_read_reg __P((struct ncr53c9x_softc *, int));
static void	esp_write_reg __P((struct ncr53c9x_softc *, int, u_char));
static u_char	esp_rdreg1 __P((struct ncr53c9x_softc *, int));
static void	esp_wrreg1 __P((struct ncr53c9x_softc *, int, u_char));
static int	esp_dma_isintr __P((struct ncr53c9x_softc *));
static void	esp_dma_reset __P((struct ncr53c9x_softc *));
static int	esp_dma_intr __P((struct ncr53c9x_softc *));
static int	esp_dma_setup __P((struct ncr53c9x_softc *, caddr_t *,
				    size_t *, int, size_t *));
static void	esp_dma_go __P((struct ncr53c9x_softc *));
static void	esp_dma_stop __P((struct ncr53c9x_softc *));
static int	esp_dma_isactive __P((struct ncr53c9x_softc *));
d148 1
a148 1
static void	espattach __P((struct esp_softc *, struct ncr53c9x_glue *));
d728 1
a728 1
void db_esp __P((db_expr_t, int, db_expr_t, char*));
@


1.5.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.5 2001/09/27 04:01:42 jason Exp $	*/
a79 2
static int esp_unit_offset;

d93 3
a95 3
void	espattach_sbus(struct device *, struct device *, void *);
void	espattach_dma(struct device *, struct device *, void *);
int	espmatch_sbus(struct device *, void *, void *);
d109 12
a120 12
static u_char	esp_read_reg(struct ncr53c9x_softc *, int);
static void	esp_write_reg(struct ncr53c9x_softc *, int, u_char);
static u_char	esp_rdreg1(struct ncr53c9x_softc *, int);
static void	esp_wrreg1(struct ncr53c9x_softc *, int, u_char);
static int	esp_dma_isintr(struct ncr53c9x_softc *);
static void	esp_dma_reset(struct ncr53c9x_softc *);
static int	esp_dma_intr(struct ncr53c9x_softc *);
static int	esp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
				    size_t *, int, size_t *);
static void	esp_dma_go(struct ncr53c9x_softc *);
static void	esp_dma_stop(struct ncr53c9x_softc *);
static int	esp_dma_isactive(struct ncr53c9x_softc *);
d148 1
a148 1
static void	espattach(struct esp_softc *, struct ncr53c9x_glue *);
a193 4
		/*
		 * offset searches for other esp/dma devices.
		 */
		esp_unit_offset++;
d306 1
a306 1
	    getdevunit("dma", sc->sc_dev.dv_unit - esp_unit_offset);
d728 1
a728 1
void db_esp(db_expr_t, int, db_expr_t, char *);
@


1.5.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d229 6
a234 3
		if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
		    sa->sa_reg[0].sbr_offset, sa->sa_reg[0].sbr_size,
		    0, 0, &lsc->sc_regs) != 0) {
d252 1
a252 1
#ifdef ESP_SBUS_DEBUG
d274 6
a279 3
		if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[1].sbr_slot,
		    sa->sa_reg[1].sbr_offset, sa->sa_reg[1].sbr_size,
		    0, 0, &esc->sc_reg) != 0) {
d335 3
a337 9
	if (sa->sa_npromvaddrs) {
		if (bus_space_map(sa->sa_bustag, sa->sa_promvaddrs[0],
		    sa->sa_size, BUS_SPACE_MAP_PROMADDRESS,
		    &esc->sc_reg) != 0) {
			printf("%s @@ sbus: cannot map registers\n",
				self->dv_xname);
			return;
		}
	} else {
d339 4
a342 1
		    sa->sa_offset, sa->sa_size, 0, 0, &esc->sc_reg) != 0) {
d397 9
a405 11
	if (sa->sa_npromvaddrs) {
		if (bus_space_map(sa->sa_bustag, sa->sa_promvaddrs[0],
		    sa->sa_size /* ??? */, BUS_SPACE_MAP_PROMADDRESS,
		    &esc->sc_reg) != 0) {
			printf("%s @@ dma: cannot map registers\n",
				self->dv_xname);
			return;
		}
	} else {
		if (sbus_bus_map(sa->sa_bustag, sa->sa_slot, sa->sa_offset,
		    sa->sa_size, BUS_SPACE_MAP_LINEAR, 0, &esc->sc_reg) != 0) {
d448 1
a448 1
	/* gimme MHz */
@


1.5.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5.4.2
log
@Merge in -current from roughly a week ago
@
text
@d93 3
a95 3
void	espattach_sbus(struct device *, struct device *, void *);
void	espattach_dma(struct device *, struct device *, void *);
int	espmatch_sbus(struct device *, void *, void *);
d109 12
a120 12
static u_char	esp_read_reg(struct ncr53c9x_softc *, int);
static void	esp_write_reg(struct ncr53c9x_softc *, int, u_char);
static u_char	esp_rdreg1(struct ncr53c9x_softc *, int);
static void	esp_wrreg1(struct ncr53c9x_softc *, int, u_char);
static int	esp_dma_isintr(struct ncr53c9x_softc *);
static void	esp_dma_reset(struct ncr53c9x_softc *);
static int	esp_dma_intr(struct ncr53c9x_softc *);
static int	esp_dma_setup(struct ncr53c9x_softc *, caddr_t *,
				    size_t *, int, size_t *);
static void	esp_dma_go(struct ncr53c9x_softc *);
static void	esp_dma_stop(struct ncr53c9x_softc *);
static int	esp_dma_isactive(struct ncr53c9x_softc *);
d148 1
a148 1
static void	espattach(struct esp_softc *, struct ncr53c9x_glue *);
d728 1
a728 1
void db_esp(db_expr_t, int, db_expr_t, char *);
@


1.5.4.3
log
@Sync the SMP branch with 3.3
@
text
@a79 2
static int esp_unit_offset;

a193 4
		/*
		 * offset searches for other esp/dma devices.
		 */
		esp_unit_offset++;
d223 1
a223 1
		if (sbus_bus_map(sa->sa_bustag,
d246 1
a246 1
#ifdef ESP_SBUS_DEBUG
d306 1
a306 1
	    getdevunit("dma", sc->sc_dev.dv_unit - esp_unit_offset);
d329 3
a331 10
	if (sa->sa_npromvaddrs) {
		if (bus_space_map(sa->sa_bustag, sa->sa_promvaddrs[0],
				 sa->sa_size,
				 BUS_SPACE_MAP_PROMADDRESS | BUS_SPACE_MAP_LINEAR,
				 &esc->sc_reg) != 0) {
			printf("%s @@ sbus: cannot map registers\n",
				self->dv_xname);
			return;
		}
	} else {
d391 4
a394 12
	if (sa->sa_npromvaddrs) {
		if (bus_space_map(sa->sa_bustag,
				   sa->sa_promvaddrs[0],
				   sa->sa_size,		/* ??? */
				   BUS_SPACE_MAP_PROMADDRESS | BUS_SPACE_MAP_LINEAR,
				   &esc->sc_reg) != 0) {
			printf("%s @@ dma: cannot map registers\n",
				self->dv_xname);
			return;
		}
	} else {
		if (sbus_bus_map(sa->sa_bustag,
d442 1
a442 1
	/* gimme MHz */
@


1.5.4.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.5.4.3 2003/03/28 00:38:30 niklas Exp $	*/
d229 6
a234 3
		if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
		    sa->sa_reg[0].sbr_offset, sa->sa_reg[0].sbr_size,
		    0, 0, &lsc->sc_regs) != 0) {
d274 6
a279 3
		if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[1].sbr_slot,
		    sa->sa_reg[1].sbr_offset, sa->sa_reg[1].sbr_size,
		    0, 0, &esc->sc_reg) != 0) {
d337 3
a339 2
		    sa->sa_size, BUS_SPACE_MAP_PROMADDRESS,
		    &esc->sc_reg) != 0) {
d346 4
a349 1
		    sa->sa_offset, sa->sa_size, 0, 0, &esc->sc_reg) != 0) {
d405 5
a409 3
		if (bus_space_map(sa->sa_bustag, sa->sa_promvaddrs[0],
		    sa->sa_size /* ??? */, BUS_SPACE_MAP_PROMADDRESS,
		    &esc->sc_reg) != 0) {
d415 6
a420 2
		if (sbus_bus_map(sa->sa_bustag, sa->sa_slot, sa->sa_offset,
		    sa->sa_size, BUS_SPACE_MAP_LINEAR, 0, &esc->sc_reg) != 0) {
@


1.5.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d153 4
a156 1
espmatch_sbus(struct device *parent, void *vcf, void *aux)
d171 3
a173 1
espattach_sbus(struct device *parent, struct device *self, void *aux)
d369 3
a371 1
espattach_dma(struct device *parent, struct device *self, void *aux)
d404 1
a404 1
		    sa->sa_size, 0, 0, &esc->sc_reg) != 0) {
d434 3
a436 1
espattach(struct esp_softc *esc, struct ncr53c9x_glue *gluep)
d540 1
a540 1
				     ncr53c9x_intr, sc, sc->sc_dev.dv_xname);
d606 3
a608 1
esp_read_reg(struct ncr53c9x_softc *sc, int reg)
d623 4
a626 1
esp_write_reg(struct ncr53c9x_softc *sc, int reg, u_char v)
d639 3
a641 1
esp_rdreg1(struct ncr53c9x_softc *sc, int reg)
d649 4
a652 1
esp_wrreg1(struct ncr53c9x_softc *sc, int reg, u_char v)
d660 2
a661 1
esp_dma_isintr(struct ncr53c9x_softc *sc)
d669 2
a670 1
esp_dma_reset(struct ncr53c9x_softc *sc)
d678 2
a679 1
esp_dma_intr(struct ncr53c9x_softc *sc)
d687 6
a692 2
esp_dma_setup(struct ncr53c9x_softc *sc, caddr_t *addr, size_t *len,
    int datain, size_t *dmasize)
d700 2
a701 1
esp_dma_go(struct ncr53c9x_softc *sc)
d709 2
a710 1
esp_dma_stop(struct ncr53c9x_softc *sc)
d721 2
a722 1
esp_dma_isactive(struct ncr53c9x_softc *sc)
d736 5
a740 1
db_esp(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
@


1.4
log
@bad me, don't break current builds with uncomitted dependent changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.3 2001/09/25 23:58:15 jason Exp $	*/
a540 1
#ifdef notyet
a542 4
#else
	if (sc->sc_rev != NCR_VARIANT_FAS366)
		ncr53c9x_dmaselect = 1;
#endif
@


1.3
log
@pretty up attach messages (as best as possible) for fas.
pull in reset fix for ESC revsions from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: esp_sbus.c,v 1.2 2001/08/21 14:57:56 jason Exp $	*/
d541 1
d544 4
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d274 1
a274 1
			printf("%s @@ sbus: cannot map scsi core registers\n",
d280 1
a280 1
			printf("\n%s: no interrupt property\n", self->dv_xname);
d290 1
d319 7
d542 1
a542 1
		ncr53c9x_dmaselect = 1;
@


1.1
log
@esp driver from NetBSD (compiles and even probes disks =)
@
text
@d1 1
@

