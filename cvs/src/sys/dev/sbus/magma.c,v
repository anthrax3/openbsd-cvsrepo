head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.4
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.6
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.4
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.23.0.18
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.14
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.12
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.15.0.14
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.12
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.10
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	SMP:1.4.0.4
	UBC:1.4.0.2
	UBC_SYNC_B:1.5;
locks; strict;
comment	@ * @;


1.26
date	2016.03.14.18.01.18;	author stefan;	state Exp;
branches;
next	1.25;
commitid	mzWTMngNKluORs3y;

1.25
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.24;
commitid	C5iGb36LQxjM60Q3;

1.24
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.23;
commitid	OBNa5kfxQ2UXoiIw;

1.23
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.28.14.13.34;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.31.12.00.08;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.31.06.40.17;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.29.05.56.41;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.29.01.55.06;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.09.22.23.15;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.08.21.56.23;	author martin;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.03.16.44.51;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.15.20.32.17;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.15.03.47.43;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.27.01.36.53;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.24.21.54.38;	author henric;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.27.17.39.05;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.11.19.20.28;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.04.18.05;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.25.02.37.43;	author jason;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	2002.01.12.21.41.17;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.12.21.30.56;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.12.20.19.40;	author jason;	state Exp;
branches;
next	;

1.4.2.1
date	2002.01.31.22.55.38;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.05.19.22.14.42;	author tedu;	state Exp;
branches;
next	;

1.4.4.1
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2003.03.28.00.38.30;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2004.02.19.10.56.32;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Convert sparc drivers bpp and magma to uiomove

Compile test and ok tobiasu@@
@
text
@/*	$OpenBSD: magma.c,v 1.25 2015/02/10 21:56:09 miod Exp $	*/

/*-
 * Copyright (c) 1998 Iain Hibbert
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* #define MAGMA_DEBUG */

/*
 * Driver for Magma SBus Serial/Parallel cards using the Cirrus Logic
 * CD1400 & CD1190 chips
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/conf.h>
#include <sys/errno.h>

#include <machine/autoconf.h>
#include <machine/conf.h>
#include <machine/bus.h>
#include <machine/bppioctl.h>

#include <dev/sbus/sbusvar.h>
#include <dev/ic/cd1400reg.h>
#include <dev/ic/cd1190reg.h>

#include <dev/sbus/magmareg.h>

/* supported cards
 *
 *  The table below lists the cards that this driver is likely to
 *  be able to support.
 *
 *  Cards with parallel ports: except for the LC2+1Sp, they all use
 *  the CD1190 chip which I know nothing about.  I've tried to leave
 *  hooks for it so it shouldn't be too hard to add support later.
 *  (I think somebody is working on this separately)
 *
 *  Thanks to Bruce at Magma for telling me the hardware offsets.
 */
static const struct magma_board_info supported_cards[] = {
	{
		"MAGMA_Sp", "MAGMA,4_Sp", "Magma 4 Sp", 4, 0,
		1, 0xa000, 0xc000, 0xe000, { 0x8000, 0, 0, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,8_Sp", "Magma 8 Sp", 8, 0,
		2, 0xa000, 0xc000, 0xe000, { 0x4000, 0x6000, 0, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,_8HS_Sp", "Magma Fast 8 Sp", 8, 0,
		2, 0x2000, 0x4000, 0x6000, { 0x8000, 0xa000, 0, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,_8SP_422", "Magma 8 Sp - 422", 8, 0,
		2, 0x2000, 0x4000, 0x6000, { 0x8000, 0xa000, 0, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,12_Sp", "Magma 12 Sp", 12, 0,
		3, 0xa000, 0xc000, 0xe000, { 0x2000, 0x4000, 0x6000, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,16_Sp", "Magma 16 Sp", 16, 0,
		4, 0xd000, 0xe000, 0xf000, { 0x8000, 0x9000, 0xa000, 0xb000 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,16_Sp_2", "Magma 16 Sp", 16, 0,
		4, 0x2000, 0x4000, 0x6000, { 0x8000, 0xa000, 0xc000, 0xe000 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,16HS_Sp", "Magma Fast 16 Sp", 16, 0,
		4, 0x2000, 0x4000, 0x6000, { 0x8000, 0xa000, 0xc000, 0xe000 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,21_Sp", "Magma LC 2+1 Sp", 2, 1,
		1, 0xa000, 0xc000, 0xe000, { 0x8000, 0, 0, 0 },
		0, { 0, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,21HS_Sp", "Magma 2+1 Sp", 2, 1,
		1, 0xa000, 0xc000, 0xe000, { 0x4000, 0, 0, 0 },
		1, { 0x6000, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,41_Sp", "Magma 4+1 Sp", 4, 1,
		1, 0xa000, 0xc000, 0xe000, { 0x4000, 0, 0, 0 },
		1, { 0x6000, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,82_Sp", "Magma 8+2 Sp", 8, 2,
		2, 0xd000, 0xe000, 0xf000, { 0x8000, 0x9000, 0, 0 },
		2, { 0xa000, 0xb000 }
	},
	{
		"MAGMA_Sp", "MAGMA,P1_Sp", "Magma P1 Sp", 0, 1,
		0, 0, 0, 0, { 0, 0, 0, 0 },
		1, { 0x8000, 0 }
	},
	{
		"MAGMA_Sp", "MAGMA,P2_Sp", "Magma P2 Sp", 0, 2,
		0, 0, 0, 0, { 0, 0, 0, 0 },
		2, { 0x4000, 0x8000 }
	},
	{
		"MAGMA 2+1HS Sp", "", "Magma 2+1HS Sp", 2, 0,
		1, 0xa000, 0xc000, 0xe000, { 0x4000, 0, 0, 0 },
		1, { 0x8000, 0 }
	},
	{
		NULL, NULL, NULL, 0, 0,
		0, 0, 0, 0, { 0, 0, 0, 0 },
		0, { 0, 0 }
	}
};

/************************************************************************
 *
 *  Autoconfig Stuff
 */

struct cfattach magma_ca = {
	sizeof(struct magma_softc), magma_match, magma_attach
};

struct cfdriver magma_cd = {
	NULL, "magma", DV_DULL
};

struct cfattach mtty_ca = {
	sizeof(struct mtty_softc), mtty_match, mtty_attach
};

struct cfdriver mtty_cd = {
	NULL, "mtty", DV_TTY
};

struct cfattach mbpp_ca = {
	sizeof(struct mbpp_softc), mbpp_match, mbpp_attach
};

struct cfdriver mbpp_cd = {
	NULL, "mbpp", DV_DULL
};

/************************************************************************
 *
 *  CD1400 Routines
 *
 *	cd1400_compute_baud		calculate COR/BPR register values
 *	cd1400_write_ccr		write a value to CD1400 ccr
 *	cd1400_read_reg			read from a CD1400 register
 *	cd1400_write_reg		write to a CD1400 register
 *	cd1400_enable_transmitter	enable transmitting on CD1400 channel
 */

/*
 * compute the bpr/cor pair for any baud rate
 * returns 0 for success, 1 for failure
 */
int
cd1400_compute_baud(speed_t speed, int clock, int *cor, int *bpr)
{
	int c, co, br;

	if (speed < 50 || speed > 150000)
		return (1);

	for (c = 0, co = 8 ; co <= 2048 ; co <<= 2, c++) {
		br = ((clock * 1000000) + (co * speed) / 2) / (co * speed);
		if (br < 0x100) {
			*bpr = br;
			*cor = c;
			return (0);
		}
	}

	return (1);
}

#define	CD1400_READ_REG(cd,reg) \
    bus_space_read_1((cd)->cd_regt, (cd)->cd_regh, (reg))
#define	CD1400_WRITE_REG(cd,reg,value) \
    bus_space_write_1((cd)->cd_regt, (cd)->cd_regh, (reg), (value))

/*
 * Write a CD1400 channel command, should have a timeout?
 */
__inline void
cd1400_write_ccr(struct cd1400 *cd, u_char cmd)
{
	while (CD1400_READ_REG(cd, CD1400_CCR))
		/*EMPTY*/;

	CD1400_WRITE_REG(cd, CD1400_CCR, cmd);
}

/*
 * enable transmit service requests for cd1400 channel
 */
void
cd1400_enable_transmitter(struct cd1400 *cd, int channel)
{
	int s, srer;

	s = spltty();
	CD1400_WRITE_REG(cd, CD1400_CAR, channel);
	srer = CD1400_READ_REG(cd, CD1400_SRER);
	SET(srer, CD1400_SRER_TXRDY);
	CD1400_WRITE_REG(cd, CD1400_SRER, srer);
	splx(s);
}

/************************************************************************
 *
 *  CD1190 Routines
 */

/* well, there are none yet */

/************************************************************************
 *
 *  Magma Routines
 *
 * magma_match		reports if we have a magma board available
 * magma_attach		attaches magma boards to the sbus
 * magma_hard		hardware level interrupt routine
 * magma_soft		software level interrupt routine
 */

int
magma_match(struct device *parent, void *vcf, void *aux)
{
	struct sbus_attach_args *sa = aux;
	const struct magma_board_info *card;

	/* See if we support this device */
	for (card = supported_cards; ; card++) {
		if (card->mb_sbusname == NULL)
			/* End of table: no match */
			return (0);
		if (strcmp(sa->sa_name, card->mb_sbusname) == 0)
			break;
	}
	return (1);
}

void
magma_attach(struct device *parent, struct device *dev, void *aux)
{
	struct sbus_attach_args *sa = aux;
	struct magma_softc *sc = (struct magma_softc *)dev;
	const struct magma_board_info *card;
	char magma_prom[40], *clockstr;
	int chip, cd_clock;

	getpropstringA(sa->sa_node, "magma_prom", magma_prom);
	for (card = supported_cards; card->mb_name != NULL; card++) {
		if (strcmp(sa->sa_name, card->mb_sbusname) != 0)
			continue;
		if (strcmp(magma_prom, card->mb_name) == 0)
			break;
	}
	if (card->mb_name == NULL) {
		printf(": %s (unsupported)\n", magma_prom);
		return;
	}

	sc->sc_bustag = sa->sa_bustag;

	clockstr = getpropstring(sa->sa_node, "clock");
	if (strlen(clockstr) == 0)
		cd_clock = 25;
	else {
		cd_clock = 0;
		while (*clockstr != '\0')
			cd_clock = cd_clock * 10 + *clockstr++ - '0';
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset, sa->sa_reg[0].sbr_size,
	    0, 0, &sc->sc_iohandle) != 0) {
		printf(": can't map registers\n");
		return;
	}

	if (sa->sa_nintr < 1) {
		printf(": can't find interrupt\n");
		return;
	}
	sc->sc_ih = bus_intr_establish(sa->sa_bustag, sa->sa_pri, IPL_TTY, 0,
	    magma_hard, sc, dev->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt, pri %d\n",
		    INTLEV(sa->sa_pri));
		bus_space_unmap(sc->sc_bustag, sc->sc_iohandle,
		    sa->sa_reg[0].sbr_size);
		return;
	}

	sc->sc_sih = softintr_establish(IPL_TTY, magma_soft, sc);
	if (sc->sc_sih == NULL) {
		printf(": can't get soft intr\n");
		bus_space_unmap(sc->sc_bustag, sc->sc_iohandle,
		    sa->sa_reg[0].sbr_size);
		return;
	}

	printf(": %s\n", card->mb_realname);

	sc->ms_board = card;
	sc->ms_ncd1400 = card->mb_ncd1400;
	sc->ms_ncd1190 = card->mb_ncd1190;

	/* the SVCACK* lines are daisychained */
	if (bus_space_subregion(sc->sc_bustag, sc->sc_iohandle,
	    card->mb_svcackr, 1, &sc->sc_svcackrh)) {
		printf(": failed to map svcackr\n");
		return;
	}
	if (bus_space_subregion(sc->sc_bustag, sc->sc_iohandle,
	    card->mb_svcackt, 1, &sc->sc_svcackth)) {
		printf(": failed to map svcackt\n");
		return;
	}
	if (bus_space_subregion(sc->sc_bustag, sc->sc_iohandle,
	    card->mb_svcackm, 1, &sc->sc_svcackmh)) {
		printf(": failed to map svcackm\n");
		return;
	}

	/* init the cd1400 chips */
	for (chip = 0 ; chip < card->mb_ncd1400 ; chip++) {
		struct cd1400 *cd = &sc->ms_cd1400[chip];

		cd->cd_clock = cd_clock;

		if (bus_space_subregion(sc->sc_bustag, sc->sc_iohandle,
		    card->mb_cd1400[chip], CD1400_REGMAPSIZE, &cd->cd_regh)) {
			printf(": failed to map cd1400 regs\n");
			return;
		}
		cd->cd_regt = sc->sc_bustag;

		/* getpropstring(sa->sa_node, "chiprev"); */
		/* seemingly the Magma drivers just ignore the propstring */
		cd->cd_chiprev = CD1400_READ_REG(cd, CD1400_GFRCR);

		dprintf(("%s attach CD1400 %d addr 0x%x rev %x clock %dMHz\n",
			    sc->ms_dev.dv_xname, chip, cd->cd_reg,
			    cd->cd_chiprev, cd->cd_clock));

		/* clear GFRCR */
		CD1400_WRITE_REG(cd, CD1400_GFRCR, 0x00);

		/* reset whole chip */
		cd1400_write_ccr(cd,
		    CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);

		/* wait for revision code to be restored */
		while (CD1400_READ_REG(cd, CD1400_GFRCR) != cd->cd_chiprev)
		        ;

		/* set the Prescaler Period Register to tick at 1ms */
		CD1400_WRITE_REG(cd, CD1400_PPR,
		    ((cd->cd_clock * 1000000 / CD1400_PPR_PRESCALER + 500)
		    / 1000));

		/*
		 * The LC2+1Sp card is the only card that doesn't have a
		 * CD1190 for the parallel port, but uses channel 0 of the
		 * CD1400, so we make a note of it for later and set up the
		 * CD1400 for parallel mode operation.
		 */
		if (card->mb_npar && card->mb_ncd1190 == 0) {
			CD1400_WRITE_REG(cd, CD1400_GCR, CD1400_GCR_PARALLEL);
			cd->cd_parmode = 1;
		}
	}

	/* init the cd1190 chips */
	for (chip = 0 ; chip < card->mb_ncd1190 ; chip++) {
		struct cd1190 *cd = &sc->ms_cd1190[chip];

		if (bus_space_subregion(sc->sc_bustag, sc->sc_iohandle,
		    card->mb_cd1190[chip], CD1190_REGMAPSIZE, &cd->cd_regh)) {
			printf(": failed to map cd1190 regs\n");
			return;
		}
		cd->cd_regt = sc->sc_bustag;
		dprintf(("%s attach CD1190 %d addr 0x%x (failed)\n",
		    sc->ms_dev.dv_xname, chip, cd->cd_reg));
		/* XXX don't know anything about these chips yet */
	}

	/* configure the children */
	(void)config_found(dev, mtty_match, NULL);
	(void)config_found(dev, mbpp_match, NULL);
}

/*
 * hard interrupt routine
 *
 *  returns 1 if it handled it, otherwise 0
 *
 *  runs at interrupt priority
 */
int
magma_hard(void *arg)
{
	struct magma_softc *sc = arg;
	struct cd1400 *cd;
	int chip, status = 0;
	int serviced = 0;
	int needsoftint = 0;

	/*
	 * check status of all the CD1400 chips
	 */
	for (chip = 0 ; chip < sc->ms_ncd1400 ; chip++)
		status |= CD1400_READ_REG(&sc->ms_cd1400[chip], CD1400_SVRR);

	if (ISSET(status, CD1400_SVRR_RXRDY)) {
		/* enter rx service context */
		u_int8_t rivr = bus_space_read_1(sc->sc_bustag, sc->sc_svcackrh, 0);
		int port = rivr >> 4;

		if (rivr & (1<<3)) {			/* parallel port */
			struct mbpp_port *mbpp;
			int n_chars;

			mbpp = &sc->ms_mbpp->ms_port[port];
			cd = mbpp->mp_cd1400;

			/* don't think we have to handle exceptions */
			n_chars = CD1400_READ_REG(cd, CD1400_RDCR);
			while (n_chars--) {
				if (mbpp->mp_cnt == 0) {
					SET(mbpp->mp_flags, MBPPF_WAKEUP);
					needsoftint = 1;
					break;
				}
				*mbpp->mp_ptr = CD1400_READ_REG(cd, CD1400_RDSR);
				mbpp->mp_ptr++;
				mbpp->mp_cnt--;
			}
		} else {				/* serial port */
			struct mtty_port *mtty;
			u_char *ptr, n_chars, line_stat;

			mtty = &sc->ms_mtty->ms_port[port];
			cd = mtty->mp_cd1400;

			if (ISSET(rivr, CD1400_RIVR_EXCEPTION)) {
				line_stat = CD1400_READ_REG(cd, CD1400_RDSR);
				n_chars = 1;
			} else { /* no exception, received data OK */
				line_stat = 0;
				n_chars = CD1400_READ_REG(cd, CD1400_RDCR);
			}

			ptr = mtty->mp_rput;
			while (n_chars--) {
				*ptr++ = line_stat;
				*ptr++ = CD1400_READ_REG(cd, CD1400_RDSR);
				if (ptr == mtty->mp_rend)
					ptr = mtty->mp_rbuf;
				if (ptr == mtty->mp_rget) {
					if (ptr == mtty->mp_rbuf)
						ptr = mtty->mp_rend;
					ptr -= 2;
					SET(mtty->mp_flags,
					    MTTYF_RING_OVERFLOW);
					break;
				}
			}
			mtty->mp_rput = ptr;

			needsoftint = 1;
		}

		CD1400_WRITE_REG(cd, CD1400_EOSRR, 0);	/* end service context */
		serviced = 1;
	} /* if(rx_service...) */

	if (ISSET(status, CD1400_SVRR_MDMCH)) {
		u_int8_t mivr = bus_space_read_1(sc->sc_bustag, sc->sc_svcackmh, 0);
		int port = mivr >> 4;
		struct mtty_port *mtty;
		int carrier;
		u_char msvr;

		/*
		 * Handle CD (LC2+1Sp = DSR) changes.
		 */
		mtty = &sc->ms_mtty->ms_port[port];
		cd = mtty->mp_cd1400;
		msvr = CD1400_READ_REG(cd, CD1400_MSVR2);
		carrier = ISSET(msvr, cd->cd_parmode ? CD1400_MSVR2_DSR : CD1400_MSVR2_CD);

		if (mtty->mp_carrier != carrier) {
			SET(mtty->mp_flags, MTTYF_CARRIER_CHANGED);
			mtty->mp_carrier = carrier;
			needsoftint = 1;
		}

		CD1400_WRITE_REG(cd, CD1400_EOSRR, 0);	/* end service context */
		serviced = 1;
	} /* if(mdm_service...) */

	if (ISSET(status, CD1400_SVRR_TXRDY)) {
		/* enter tx service context */
		u_int8_t tivr = bus_space_read_1(sc->sc_bustag, sc->sc_svcackth, 0);
		int port = tivr >> 4;

		if (tivr & (1<<3)) {	/* parallel port */
			struct mbpp_port *mbpp;

			mbpp = &sc->ms_mbpp->ms_port[port];
			cd = mbpp->mp_cd1400;

			if (mbpp->mp_cnt) {
				int count = 0;

				/* fill the fifo */
				while (mbpp->mp_cnt && count++ < CD1400_PAR_FIFO_SIZE) {
					CD1400_WRITE_REG(cd, CD1400_TDR, *mbpp->mp_ptr);
					mbpp->mp_ptr++;
					mbpp->mp_cnt--;
				}
			} else {
				/* fifo is empty and we got no more data to send, so shut
				 * off interrupts and signal for a wakeup, which can't be
				 * done here in case we beat mbpp_send to the tsleep call
				 * (we are running at >spltty)
				 */
				CD1400_WRITE_REG(cd, CD1400_SRER, 0);
				SET(mbpp->mp_flags, MBPPF_WAKEUP);
				needsoftint = 1;
			}
		} else {		/* serial port */
			struct mtty_port *mtty;
			struct tty *tp;

			mtty = &sc->ms_mtty->ms_port[port];
			cd = mtty->mp_cd1400;
			tp = mtty->mp_tty;

			if (!ISSET(mtty->mp_flags, MTTYF_STOP)) {
				int count = 0;

				/* check if we should start/stop a break */
				if (ISSET(mtty->mp_flags, MTTYF_SET_BREAK)) {
					CD1400_WRITE_REG(cd, CD1400_TDR, 0);
					CD1400_WRITE_REG(cd, CD1400_TDR, 0x81);
					/* should we delay too? */
					CLR(mtty->mp_flags, MTTYF_SET_BREAK);
					count += 2;
				}

				if (ISSET(mtty->mp_flags, MTTYF_CLR_BREAK)) {
					CD1400_WRITE_REG(cd, CD1400_TDR, 0);
					CD1400_WRITE_REG(cd, CD1400_TDR, 0x83);
					CLR(mtty->mp_flags, MTTYF_CLR_BREAK);
					count += 2;
				}

				/* I don't quite fill the fifo in case the last one is a
				 * NULL which I have to double up because its the escape
				 * code for embedded transmit characters.
				 */
				while (mtty->mp_txc > 0 && count < CD1400_TX_FIFO_SIZE - 1) {
					u_char ch;

					ch = *mtty->mp_txp;

					mtty->mp_txc--;
					mtty->mp_txp++;

					if (ch == 0) {
						CD1400_WRITE_REG(cd, CD1400_TDR, ch);
						count++;
					}

					CD1400_WRITE_REG(cd, CD1400_TDR, ch);
					count++;
				}
			}

			/* if we ran out of work or are requested to STOP then
			 * shut off the txrdy interrupts and signal DONE to flush
			 * out the chars we have sent.
			 */
			if (mtty->mp_txc == 0 || ISSET(mtty->mp_flags, MTTYF_STOP)) {
				int srer;

				srer = CD1400_READ_REG(cd, CD1400_SRER);
				CLR(srer, CD1400_SRER_TXRDY);
				CD1400_WRITE_REG(cd, CD1400_SRER, srer);
				CLR(mtty->mp_flags, MTTYF_STOP);

				SET(mtty->mp_flags, MTTYF_DONE);
				needsoftint = 1;
			}
		}

		CD1400_WRITE_REG(cd, CD1400_EOSRR, 0);	/* end service context */
		serviced = 1;
	} /* if(tx_service...) */

	/* XXX service CD1190 interrupts too
	for (chip = 0 ; chip < sc->ms_ncd1190 ; chip++) {
	}
	*/

	if (needsoftint)
		softintr_schedule(sc->sc_sih);

	return (serviced);
}

/*
 * magma soft interrupt handler
 *
 *  returns 1 if it handled it, 0 otherwise
 *
 *  runs at spltty()
 */
void
magma_soft(void *arg)
{
	struct magma_softc *sc = arg;
	struct mtty_softc *mtty = sc->ms_mtty;
	struct mbpp_softc *mbpp = sc->ms_mbpp;
	int port;
	int serviced = 0;
	int s, flags;

	/*
	 * check the tty ports (if any) to see what needs doing
	 */
	if (mtty) {
		for (port = 0 ; port < mtty->ms_nports ; port++) {
			struct mtty_port *mp = &mtty->ms_port[port];
			struct tty *tp = mp->mp_tty;

			if (!ISSET(tp->t_state, TS_ISOPEN))
				continue;

			/*
			 * handle any received data
			 */
			while (mp->mp_rget != mp->mp_rput) {
				u_char stat;
				int data;

				stat = mp->mp_rget[0];
				data = mp->mp_rget[1];
				mp->mp_rget = ((mp->mp_rget + 2) == mp->mp_rend) ? mp->mp_rbuf : (mp->mp_rget + 2);

				if (stat & (CD1400_RDSR_BREAK | CD1400_RDSR_FE))
					data |= TTY_FE;
				if (stat & CD1400_RDSR_PE)
					data |= TTY_PE;

				if (stat & CD1400_RDSR_OE)
					log(LOG_WARNING, "%s%x: fifo overflow\n", mtty->ms_dev.dv_xname, port);

				(*linesw[tp->t_line].l_rint)(data, tp);
				serviced = 1;
			}

			s = splhigh();	/* block out hard interrupt routine */
			flags = mp->mp_flags;
			CLR(mp->mp_flags, MTTYF_DONE | MTTYF_CARRIER_CHANGED | MTTYF_RING_OVERFLOW);
			splx(s);	/* ok */

			if (ISSET(flags, MTTYF_CARRIER_CHANGED)) {
				dprintf(("%s%x: cd %s\n", mtty->ms_dev.dv_xname, port, mp->mp_carrier ? "on" : "off"));
				(*linesw[tp->t_line].l_modem)(tp, mp->mp_carrier);
				serviced = 1;
			}

			if (ISSET(flags, MTTYF_RING_OVERFLOW)) {
				log(LOG_WARNING, "%s%x: ring buffer overflow\n", mtty->ms_dev.dv_xname, port);
				serviced = 1;
			}

			if (ISSET(flags, MTTYF_DONE)) {
				ndflush(&tp->t_outq, mp->mp_txp - tp->t_outq.c_cf);
				CLR(tp->t_state, TS_BUSY);
				(*linesw[tp->t_line].l_start)(tp);	/* might be some more */
				serviced = 1;
			}
		} /* for (each mtty...) */
	}

	/*
	 * check the bpp ports (if any) to see what needs doing
	 */
	if (mbpp) {
		for (port = 0 ; port < mbpp->ms_nports ; port++) {
			struct mbpp_port *mp = &mbpp->ms_port[port];

			if (!ISSET(mp->mp_flags, MBPPF_OPEN))
				continue;

			s = splhigh();	/* block out hard intr routine */
			flags = mp->mp_flags;
			CLR(mp->mp_flags, MBPPF_WAKEUP);
			splx(s);

			if (ISSET(flags, MBPPF_WAKEUP)) {
				wakeup(mp);
				serviced = 1;
			}
		} /* for (each mbpp...) */
	}
}

/************************************************************************
 *
 *  MTTY Routines
 *
 *	mtty_match		match one mtty device
 *	mtty_attach		attach mtty devices
 *	mttyopen		open mtty device
 *	mttyclose		close mtty device
 *	mttyread		read from mtty
 *	mttywrite		write to mtty
 *	mttyioctl		do ioctl on mtty
 *	mttytty			return tty pointer for mtty
 *	mttystop		stop mtty device
 *	mtty_start		start mtty device
 *	mtty_param		set mtty parameters
 *	mtty_modem_control	set modem control lines
 */

int
mtty_match(struct device *parent, void *vcf, void *args)
{
	struct magma_softc *sc = (struct magma_softc *)parent;

	return (args == mtty_match && sc->ms_board->mb_nser &&
	    sc->ms_mtty == NULL);
}

void
mtty_attach(struct device *parent, struct device *dev, void *args)
{
	struct magma_softc *sc = (struct magma_softc *)parent;
	struct mtty_softc *ms = (struct mtty_softc *)dev;
	int port, chip, chan;

	sc->ms_mtty = ms;
	dprintf((" addr 0x%x", ms));

	for (port = 0, chip = 0, chan = 0;
	     port < sc->ms_board->mb_nser; port++) {
		struct mtty_port *mp = &ms->ms_port[port];
		struct tty *tp;

		mp->mp_cd1400 = &sc->ms_cd1400[chip];
		if (mp->mp_cd1400->cd_parmode && chan == 0) {
			/* skip channel 0 if parmode */
			chan = 1;
		}
		mp->mp_channel = chan;

		tp = ttymalloc(0);
		tp->t_oproc = mtty_start;
		tp->t_param = mtty_param;

		mp->mp_tty = tp;

		mp->mp_rbuf = malloc(MTTY_RBUF_SIZE, M_DEVBUF, M_NOWAIT);
		if (mp->mp_rbuf == NULL)
			break;

		mp->mp_rend = mp->mp_rbuf + MTTY_RBUF_SIZE;

		chan = (chan + 1) % CD1400_NO_OF_CHANNELS;
		if (chan == 0)
			chip++;
	}

	ms->ms_nports = port;
	printf(": %d tty%s\n", port, port == 1 ? "" : "s");
}

/*
 * open routine. returns zero if successful, else error code
 */
int
mttyopen(dev_t dev, int flags, int mode, struct proc *p)
{
	int card = MAGMA_CARD(dev);
	int port = MAGMA_PORT(dev);
	struct mtty_softc *ms;
	struct mtty_port *mp;
	struct tty *tp;
	struct cd1400 *cd;
	int s;

	if (card >= mtty_cd.cd_ndevs || (ms = mtty_cd.cd_devs[card]) == NULL
	    || port >= ms->ms_nports)
		return (ENXIO);	/* device not configured */

	mp = &ms->ms_port[port];
	tp = mp->mp_tty;
	tp->t_dev = dev;

	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		SET(tp->t_state, TS_WOPEN);

		/* set defaults */
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		if (ISSET(mp->mp_openflags, TIOCFLAG_CLOCAL))
			SET(tp->t_cflag, CLOCAL);
		if (ISSET(mp->mp_openflags, TIOCFLAG_CRTSCTS))
			SET(tp->t_cflag, CRTSCTS);
		if (ISSET(mp->mp_openflags, TIOCFLAG_MDMBUF))
			SET(tp->t_cflag, MDMBUF);
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;

		/* init ring buffer */
		mp->mp_rput = mp->mp_rget = mp->mp_rbuf;

		s = spltty();

		/* reset CD1400 channel */
		cd = mp->mp_cd1400;
		CD1400_WRITE_REG(cd, CD1400_CAR, mp->mp_channel);
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET);

		/* encode the port number in top half of LIVR */
		CD1400_WRITE_REG(cd, CD1400_LIVR, port << 4);

		/* sets parameters and raises DTR */
		(void)mtty_param(tp, &tp->t_termios);

		/* set tty watermarks */
		ttsetwater(tp);

		/* enable service requests */
		CD1400_WRITE_REG(cd, CD1400_SRER, CD1400_SRER_RXDATA | CD1400_SRER_MDMCH);

		/* tell the tty about the carrier status */
		if (ISSET(mp->mp_openflags, TIOCFLAG_SOFTCAR) || mp->mp_carrier)
			SET(tp->t_state, TS_CARR_ON);
		else
			CLR(tp->t_state, TS_CARR_ON);
	} else if (ISSET(tp->t_state, TS_XCLUDE) && suser(p, 0) != 0) {
		return (EBUSY);	/* superuser can break exclusive access */
	} else {
		s = spltty();
	}

	/* wait for carrier if necessary */
	if (!ISSET(flags, O_NONBLOCK)) {
		while (!ISSET(tp->t_cflag, CLOCAL) && !ISSET(tp->t_state, TS_CARR_ON)) {
			int error;

			SET(tp->t_state, TS_WOPEN);
			error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH, "mttydcd", 0);
			if (error != 0) {
				splx(s);
				CLR(tp->t_state, TS_WOPEN);
				return (error);
			}
		}
	}

	splx(s);

	return ((*linesw[tp->t_line].l_open)(dev, tp, p));
}

/*
 * close routine. returns zero if successful, else error code
 */
int
mttyclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
	struct tty *tp = mp->mp_tty;
	int s;

	(*linesw[tp->t_line].l_close)(tp, flag, p);
	s = spltty();

	/* if HUPCL is set, and the tty is no longer open
	 * shut down the port
	 */
	if (ISSET(tp->t_cflag, HUPCL) || !ISSET(tp->t_state, TS_ISOPEN)) {
	/* XXX wait until FIFO is empty before turning off the channel
		struct cd1400 *cd = mp->mp_cd1400;
	*/

		/* drop DTR and RTS */
		(void)mtty_modem_control(mp, 0, DMSET);

		/* turn off the channel
		CD1400_WRITE_REG(cd, CD1400_CAR, mp->mp_channel);
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET);
		*/
	}

	splx(s);
	ttyclose(tp);

	return (0);
}

/*
 * Read routine
 */
int
mttyread(dev_t dev, struct uio *uio, int flags)
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
	struct tty *tp = mp->mp_tty;

	return ((*linesw[tp->t_line].l_read)(tp, uio, flags));
}

/*
 * Write routine
 */
int
mttywrite(dev_t dev, struct uio *uio, int flags)
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
	struct tty *tp = mp->mp_tty;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flags));
}

/*
 * return tty pointer
 */
struct tty *
mttytty(dev_t dev)
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];

	return (mp->mp_tty);
}

/*
 * ioctl routine
 */
int
mttyioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
	struct tty *tp = mp->mp_tty;
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flags, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flags, p);
	if (error >= 0)
		return (error);

	error = 0;

	switch(cmd) {
	case TIOCSBRK:	/* set break */
		SET(mp->mp_flags, MTTYF_SET_BREAK);
		cd1400_enable_transmitter(mp->mp_cd1400, mp->mp_channel);
		break;

	case TIOCCBRK:	/* clear break */
		SET(mp->mp_flags, MTTYF_CLR_BREAK);
		cd1400_enable_transmitter(mp->mp_cd1400, mp->mp_channel);
		break;

	case TIOCSDTR:	/* set DTR */
		mtty_modem_control(mp, TIOCM_DTR, DMBIS);
		break;

	case TIOCCDTR:	/* clear DTR */
		mtty_modem_control(mp, TIOCM_DTR, DMBIC);
		break;

	case TIOCMSET:	/* set modem lines */
		mtty_modem_control(mp, *((int *)data), DMSET);
		break;

	case TIOCMBIS:	/* bit set modem lines */
		mtty_modem_control(mp, *((int *)data), DMBIS);
		break;

	case TIOCMBIC:	/* bit clear modem lines */
		mtty_modem_control(mp, *((int *)data), DMBIC);
		break;

	case TIOCMGET:	/* get modem lines */
		*((int *)data) = mtty_modem_control(mp, 0, DMGET);
		break;

	case TIOCGFLAGS:
		*((int *)data) = mp->mp_openflags;
		break;

	case TIOCSFLAGS:
		if (suser(p, 0))
			error = EPERM;
		else
			mp->mp_openflags = *((int *)data) &
				(TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL |
				TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF);
		break;

	default:
		error = ENOTTY;
	}

	return (error);
}

/*
 * Stop output, e.g., for ^S or output flush.
 */
int
mttystop(struct tty *tp, int flags)
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(tp->t_dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(tp->t_dev)];
	int s;

	s = spltty();

	if (ISSET(tp->t_state, TS_BUSY)) {
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);

		/*
		 * the transmit interrupt routine will disable transmit when it
		 * notices that MTTYF_STOP has been set.
		 */
		SET(mp->mp_flags, MTTYF_STOP);
	}

	splx(s);
	return (0);
}

/*
 * Start output, after a stop.
 */
void
mtty_start(struct tty *tp)
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(tp->t_dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(tp->t_dev)];
	int s;

	s = spltty();

	/* we only need to do something if we are not already busy
	 * or delaying or stopped
	 */
	if (!ISSET(tp->t_state, TS_TTSTOP | TS_TIMEOUT | TS_BUSY)) {

		/* if we are sleeping and output has drained below
		 * low water mark, awaken
		 */
		ttwakeupwr(tp);

		/* if something to send, start transmitting
		 */
		if (tp->t_outq.c_cc) {
			mp->mp_txc = ndqb(&tp->t_outq, 0);
			mp->mp_txp = tp->t_outq.c_cf;
			SET(tp->t_state, TS_BUSY);
			cd1400_enable_transmitter(mp->mp_cd1400, mp->mp_channel);
		}
	}

	splx(s);
}

/*
 * set/get modem line status
 *
 * bits can be: TIOCM_DTR, TIOCM_RTS, TIOCM_CTS, TIOCM_CD, TIOCM_RI, TIOCM_DSR
 *
 * note that DTR and RTS lines are exchanged, and that DSR is
 * not available on the LC2+1Sp card (used as CD)
 *
 * only let them fiddle with RTS if CRTSCTS is not enabled
 */
int
mtty_modem_control(struct mtty_port *mp, int bits, int howto)
{
	struct cd1400 *cd = mp->mp_cd1400;
	struct tty *tp = mp->mp_tty;
	int s, msvr;

	s = spltty();

	CD1400_WRITE_REG(cd, CD1400_CAR, mp->mp_channel);

	switch(howto) {
	case DMGET:	/* get bits */
		bits = 0;

		bits |= TIOCM_LE;

		msvr = CD1400_READ_REG(cd, CD1400_MSVR1);
		if (msvr & CD1400_MSVR1_RTS)
			bits |= TIOCM_DTR;

		msvr = CD1400_READ_REG(cd, CD1400_MSVR2);
		if (msvr & CD1400_MSVR2_DTR)
			bits |= TIOCM_RTS;
		if (msvr & CD1400_MSVR2_CTS)
			bits |= TIOCM_CTS;
		if (msvr & CD1400_MSVR2_RI)
			bits |= TIOCM_RI;
		if (msvr & CD1400_MSVR2_DSR)
			bits |= (cd->cd_parmode ? TIOCM_CD : TIOCM_DSR);
		if (msvr & CD1400_MSVR2_CD)
			bits |= (cd->cd_parmode ? 0 : TIOCM_CD);

		break;

	case DMSET:	/* reset bits */
		if (!ISSET(tp->t_cflag, CRTSCTS))
			CD1400_WRITE_REG(cd, CD1400_MSVR2,
			    ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));

		CD1400_WRITE_REG(cd, CD1400_MSVR1,
		    ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));

		break;

	case DMBIS:	/* set bits */
		if ((bits & TIOCM_RTS) && !ISSET(tp->t_cflag, CRTSCTS))
			CD1400_WRITE_REG(cd, CD1400_MSVR2, CD1400_MSVR2_DTR);

		if (bits & TIOCM_DTR)
			CD1400_WRITE_REG(cd, CD1400_MSVR1, CD1400_MSVR1_RTS);

		break;

	case DMBIC:	/* clear bits */
		if ((bits & TIOCM_RTS) && !ISSET(tp->t_cflag, CRTSCTS))
			CD1400_WRITE_REG(cd, CD1400_MSVR2, 0);

		if (bits & TIOCM_DTR)
			CD1400_WRITE_REG(cd, CD1400_MSVR1, 0);

		break;
	}

	splx(s);
	return (bits);
}

/*
 * Set tty parameters, returns error or 0 on success
 */
int
mtty_param(struct tty *tp, struct termios *t)
{
	struct mtty_softc *ms = mtty_cd.cd_devs[MAGMA_CARD(tp->t_dev)];
	struct mtty_port *mp = &ms->ms_port[MAGMA_PORT(tp->t_dev)];
	struct cd1400 *cd = mp->mp_cd1400;
	int rbpr, tbpr, rcor, tcor;
	u_char mcor1 = 0, mcor2 = 0;
	int s, opt;

	if (t->c_ospeed &&
	    cd1400_compute_baud(t->c_ospeed, cd->cd_clock, &tcor, &tbpr))
		return (EINVAL);

	if (t->c_ispeed &&
	    cd1400_compute_baud(t->c_ispeed, cd->cd_clock, &rcor, &rbpr))
		return (EINVAL);

	s = spltty();

	/* hang up the line if ospeed is zero, else raise DTR */
	(void)mtty_modem_control(mp, TIOCM_DTR,
	    (t->c_ospeed == 0 ? DMBIC : DMBIS));

	/* select channel, done in mtty_modem_control() */
	/* CD1400_WRITE_REG(cd, CD1400_CAR, mp->mp_channel); */

	/* set transmit speed */
	if (t->c_ospeed) {
		CD1400_WRITE_REG(cd, CD1400_TCOR, tcor);
		CD1400_WRITE_REG(cd, CD1400_TBPR, tbpr);
	}

	/* set receive speed */
	if (t->c_ispeed) {
		CD1400_WRITE_REG(cd, CD1400_RCOR, rcor);
		CD1400_WRITE_REG(cd, CD1400_RBPR, rbpr);
	}

	/* enable transmitting and receiving on this channel */
	opt = CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN | CD1400_CCR_RCVEN;
	cd1400_write_ccr(cd, opt);

	/* set parity, data and stop bits */
	opt = 0;
	if (ISSET(t->c_cflag, PARENB))
		opt |= (ISSET(t->c_cflag, PARODD) ? CD1400_COR1_PARODD : CD1400_COR1_PARNORMAL);

	if (!ISSET(t->c_iflag, INPCK))
		opt |= CD1400_COR1_NOINPCK; /* no parity checking */

	if (ISSET(t->c_cflag, CSTOPB))
		opt |= CD1400_COR1_STOP2;

	switch( t->c_cflag & CSIZE) {
	case CS5:
		opt |= CD1400_COR1_CS5;
		break;

	case CS6:
		opt |= CD1400_COR1_CS6;
		break;

	case CS7:
		opt |= CD1400_COR1_CS7;
		break;

	default:
		opt |= CD1400_COR1_CS8;
		break;
	}

	CD1400_WRITE_REG(cd, CD1400_COR1, opt);

	/*
	 * enable Embedded Transmit Commands (for breaks)
	 * use the CD1400 automatic CTS flow control if CRTSCTS is set
	 */
	opt = CD1400_COR2_ETC;
	if (ISSET(t->c_cflag, CRTSCTS))
		opt |= CD1400_COR2_CCTS_OFLOW;
	CD1400_WRITE_REG(cd, CD1400_COR2, opt);

	CD1400_WRITE_REG(cd, CD1400_COR3, MTTY_RX_FIFO_THRESHOLD);

	cd1400_write_ccr(cd, CD1400_CCR_CMDCORCHG | CD1400_CCR_COR1 | CD1400_CCR_COR2 | CD1400_CCR_COR3);

	CD1400_WRITE_REG(cd, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);
	CD1400_WRITE_REG(cd, CD1400_COR5, 0);

	/*
	 * if automatic RTS handshaking enabled, set DTR threshold
	 * (RTS and DTR lines are switched, CD1400 thinks its DTR)
	 */
	if (ISSET(t->c_cflag, CRTSCTS))
		mcor1 = MTTY_RX_DTR_THRESHOLD;

	/* set up `carrier detect' interrupts */
	if (cd->cd_parmode) {
		SET(mcor1, CD1400_MCOR1_DSRzd);
		SET(mcor2, CD1400_MCOR2_DSRod);
	} else {
		SET(mcor1, CD1400_MCOR1_CDzd);
		SET(mcor2, CD1400_MCOR2_CDod);
	}

	CD1400_WRITE_REG(cd, CD1400_MCOR1, mcor1);
	CD1400_WRITE_REG(cd, CD1400_MCOR2, mcor2);

	/* receive timeout 2ms */
	CD1400_WRITE_REG(cd, CD1400_RTPR, 2);

	splx(s);
	return (0);
}

/************************************************************************
 *
 *  MBPP Routines
 *
 *	mbpp_match	match one mbpp device
 *	mbpp_attach	attach mbpp devices
 *	mbppopen	open mbpp device
 *	mbppclose	close mbpp device
 *	mbppread	read from mbpp
 *	mbppwrite	write to mbpp
 *	mbppioctl	do ioctl on mbpp
 *	mbpppoll	do poll on mbpp
 *	mbpp_rw		general rw routine
 *	mbpp_timeout	rw timeout
 *	mbpp_start	rw start after delay
 *	mbpp_send	send data
 *	mbpp_recv	recv data
 */

int
mbpp_match(struct device *parent, void *vcf, void *args)
{
	struct magma_softc *sc = (struct magma_softc *)parent;

	return (args == mbpp_match && sc->ms_board->mb_npar &&
	    sc->ms_mbpp == NULL);
}

void
mbpp_attach(struct device *parent, struct device *dev, void *args)
{
	struct magma_softc *sc = (struct magma_softc *)parent;
	struct mbpp_softc *ms = (struct mbpp_softc *)dev;
	struct mbpp_port *mp;
	int port;

	sc->ms_mbpp = ms;
	dprintf((" addr 0x%x", ms));

	for (port = 0 ; port < sc->ms_board->mb_npar ; port++) {
		mp = &ms->ms_port[port];

		if (sc->ms_ncd1190)
			mp->mp_cd1190 = &sc->ms_cd1190[port];
		else
			mp->mp_cd1400 = &sc->ms_cd1400[0];

		timeout_set(&mp->mp_timeout_tmo, mbpp_timeout, mp);
		timeout_set(&mp->mp_start_tmo, mbpp_start, mp);
	}

	ms->ms_nports = port;
	printf(": %d port%s\n", port, port == 1 ? "" : "s");
}

/*
 * open routine. returns zero if successful, else error code
 */
int
mbppopen(dev_t dev, int flags, int mode, struct proc *p)
{
	int card = MAGMA_CARD(dev);
	int port = MAGMA_PORT(dev);
	struct mbpp_softc *ms;
	struct mbpp_port *mp;
	int s;

	if (card >= mbpp_cd.cd_ndevs || (ms = mbpp_cd.cd_devs[card]) == NULL || port >= ms->ms_nports)
		return (ENXIO);

	mp = &ms->ms_port[port];

	s = spltty();
	if (ISSET(mp->mp_flags, MBPPF_OPEN)) {
		splx(s);
		return (EBUSY);
	}
	SET(mp->mp_flags, MBPPF_OPEN);
	splx(s);

	/* set defaults */
	mp->mp_burst = BPP_BURST;
	mp->mp_timeout = mbpp_mstohz(BPP_TIMEOUT);
	mp->mp_delay = mbpp_mstohz(BPP_DELAY);

	/* init chips */
	if (mp->mp_cd1400) {	/* CD1400 */
		struct cd1400 *cd = mp->mp_cd1400;

		/* set up CD1400 channel */
		s = spltty();
		CD1400_WRITE_REG(cd, CD1400_CAR, 0);
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET);
		CD1400_WRITE_REG(cd, CD1400_LIVR, (1<<3));
		splx(s);
	} else {		/* CD1190 */
		mp->mp_flags = 0;
		return (ENXIO);
	}

	return (0);
}

/*
 * close routine. returns zero if successful, else error code
 */
int
mbppclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct mbpp_softc *ms = mbpp_cd.cd_devs[MAGMA_CARD(dev)];
	struct mbpp_port *mp = &ms->ms_port[MAGMA_PORT(dev)];

	mp->mp_flags = 0;
	return (0);
}

/*
 * Read routine
 */
int
mbppread(dev_t dev, struct uio *uio, int flags)
{
	return (mbpp_rw(dev, uio));
}

/*
 * Write routine
 */
int
mbppwrite(dev_t dev, struct uio *uio, int flags)
{
	return (mbpp_rw(dev, uio));
}

/*
 * ioctl routine
 */
int
mbppioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct mbpp_softc *ms = mbpp_cd.cd_devs[MAGMA_CARD(dev)];
	struct mbpp_port *mp = &ms->ms_port[MAGMA_PORT(dev)];
	struct bpp_param *bp;
	int error = 0;
	int s;

	switch(cmd) {
	case BPPIOCSPARAM:
		bp = (struct bpp_param *)data;
		if (bp->bp_burst < BPP_BURST_MIN || bp->bp_burst > BPP_BURST_MAX ||
		    bp->bp_delay < BPP_DELAY_MIN || bp->bp_delay > BPP_DELAY_MIN) {
			error = EINVAL;
		} else {
			mp->mp_burst = bp->bp_burst;
			mp->mp_timeout = mbpp_mstohz(bp->bp_timeout);
			mp->mp_delay = mbpp_mstohz(bp->bp_delay);
		}
		break;
	case BPPIOCGPARAM:
		bp = (struct bpp_param *)data;
		bp->bp_burst = mp->mp_burst;
		bp->bp_timeout = mbpp_hztoms(mp->mp_timeout);
		bp->bp_delay = mbpp_hztoms(mp->mp_delay);
		break;
	case BPPIOCGSTAT:
		/* XXX make this more generic */
		s = spltty();
		CD1400_WRITE_REG(mp->mp_cd1400, CD1400_CAR, 0);
		*(int *)data = CD1400_READ_REG(mp->mp_cd1400, CD1400_PSVR);
		splx(s);
		break;
	default:
		error = ENOTTY;
	}

	return (error);
}

/*
 * poll routine
 */
int
mbpppoll(dev_t dev, int events, struct proc *p)
{
	return (seltrue(dev, events, p));
}

int
mbpp_rw(dev_t dev, struct uio *uio)
{
	int card = MAGMA_CARD(dev);
	int port = MAGMA_PORT(dev);
	struct mbpp_softc *ms = mbpp_cd.cd_devs[card];
	struct mbpp_port *mp = &ms->ms_port[port];
	caddr_t buffer, ptr;
	size_t buflen, cnt, len;
	int s, error = 0;
	int gotdata = 0;

	if (uio->uio_resid == 0)
		return (0);

	buflen = ulmin(uio->uio_resid, mp->mp_burst);
	buffer = malloc(buflen, M_DEVBUF, M_WAITOK);

	SET(mp->mp_flags, MBPPF_UIO);

	/*
	 * start timeout, if needed
	 */
	if (mp->mp_timeout > 0) {
		SET(mp->mp_flags, MBPPF_TIMEOUT);
		timeout_add(&mp->mp_timeout_tmo, mp->mp_timeout);
	}

	len = cnt = 0;
	while (uio->uio_resid > 0) {
		len = ulmin(buflen, uio->uio_resid);
		ptr = buffer;

		if (uio->uio_rw == UIO_WRITE) {
			error = uiomove(ptr, len, uio);
			if (error)
				break;
		}
	again:		/* goto bad */
		/* timed out?  */
		if (!ISSET(mp->mp_flags, MBPPF_UIO))
			break;

		/*
		 * perform the operation
		 */
		if (uio->uio_rw == UIO_WRITE) {
			cnt = mbpp_send(mp, ptr, len);
		} else {
			cnt = mbpp_recv(mp, ptr, len);
		}

		if (uio->uio_rw == UIO_READ) {
			if (cnt) {
				error = uiomove(ptr, cnt, uio);
				if (error)
					break;
				gotdata++;
			}
			else if (gotdata)	/* consider us done */
				break;
		}

		/* timed out?  */
		if (!ISSET(mp->mp_flags, MBPPF_UIO))
			break;

		/*
		 * poll delay?
		 */
		if (mp->mp_delay > 0) {
			s = spltty();	/* XXX */
			SET(mp->mp_flags, MBPPF_DELAY);
			timeout_add(&mp->mp_start_tmo, mp->mp_delay);
			error = tsleep(mp, PCATCH | PZERO, "mbppdelay", 0);
			splx(s);
			if (error)
				break;
		}

		/*
		 * don't call uiomove again until we used all the data we grabbed
		 */
		if (uio->uio_rw == UIO_WRITE && cnt != len) {
			ptr += cnt;
			len -= cnt;
			cnt = 0;
			goto again;
		}
	}

	/*
	 * clear timeouts
	 */
	s = spltty();	/* XXX */
	if (ISSET(mp->mp_flags, MBPPF_TIMEOUT)) {
		timeout_del(&mp->mp_timeout_tmo);
		CLR(mp->mp_flags, MBPPF_TIMEOUT);
	}
	if (ISSET(mp->mp_flags, MBPPF_DELAY)) {
		timeout_del(&mp->mp_start_tmo);
		CLR(mp->mp_flags, MBPPF_DELAY);
	}
	splx(s);

	/*
	 * adjust for those chars that we uiomoved but never actually wrote
	 */
	if (uio->uio_rw == UIO_WRITE && cnt != len) {
		uio->uio_resid += (len - cnt);
	}

	free(buffer, M_DEVBUF, 0);
	return (error);
}

void
mbpp_timeout(void *arg)
{
	struct mbpp_port *mp = arg;

	CLR(mp->mp_flags, MBPPF_UIO | MBPPF_TIMEOUT);
	wakeup(mp);
}

void
mbpp_start(void *arg)
{
	struct mbpp_port *mp = arg;

	CLR(mp->mp_flags, MBPPF_DELAY);
	wakeup(mp);
}

int
mbpp_send(struct mbpp_port *mp, caddr_t ptr, int len)
{
	int s;
	struct cd1400 *cd = mp->mp_cd1400;

	/* set up io information */
	mp->mp_ptr = ptr;
	mp->mp_cnt = len;

	/* start transmitting */
	s = spltty();
	if (cd) {
		CD1400_WRITE_REG(cd, CD1400_CAR, 0);

		/* output strobe width ~1microsecond */
		CD1400_WRITE_REG(cd, CD1400_TBPR, 10);

		/* enable channel */
		cd1400_write_ccr(cd, CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN);
		CD1400_WRITE_REG(cd, CD1400_SRER, CD1400_SRER_TXRDY);
	}

	/* ZZzzz... */
	tsleep(mp, PCATCH | PZERO, "mbpp_send", 0);

	/* stop transmitting */
	if (cd) {
		CD1400_WRITE_REG(cd, CD1400_CAR, 0);

		/* disable transmitter */
		CD1400_WRITE_REG(cd, CD1400_SRER, 0);
		cd1400_write_ccr(cd, CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTDIS);

		/* flush fifo */
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET | CD1400_CCR_FTF);
	}
	splx(s);

	/* return number of chars sent */
	return (len - mp->mp_cnt);
}

int
mbpp_recv(struct mbpp_port *mp, caddr_t ptr, int len)
{
	int s;
	struct cd1400 *cd = mp->mp_cd1400;

	/* set up io information */
	mp->mp_ptr = ptr;
	mp->mp_cnt = len;

	/* start receiving */
	s = spltty();
	if (cd) {
		int rcor, rbpr;

		CD1400_WRITE_REG(cd, CD1400_CAR, 0);

		/* input strobe at 100kbaud (10microseconds) */
		cd1400_compute_baud(100000, cd->cd_clock, &rcor, &rbpr);
		CD1400_WRITE_REG(cd, CD1400_RCOR, rcor);
		CD1400_WRITE_REG(cd, CD1400_RBPR, rbpr);

		/* rx threshold */
		CD1400_WRITE_REG(cd, CD1400_COR3, MBPP_RX_FIFO_THRESHOLD);
		cd1400_write_ccr(cd, CD1400_CCR_CMDCORCHG | CD1400_CCR_COR3);

		/* enable channel */
		cd1400_write_ccr(cd, CD1400_CCR_CMDCHANCTL | CD1400_CCR_RCVEN);
		CD1400_WRITE_REG(cd, CD1400_SRER, CD1400_SRER_RXDATA);
	}

	/* ZZzzz... */
	tsleep(mp, PCATCH | PZERO, "mbpp_recv", 0);

	/* stop receiving */
	if (cd) {
		CD1400_WRITE_REG(cd, CD1400_CAR, 0);

		/* disable receiving */
		CD1400_WRITE_REG(cd, CD1400_SRER, 0);
		cd1400_write_ccr(cd, CD1400_CCR_CMDCHANCTL | CD1400_CCR_RCVDIS);
	}
	splx(s);

	/* return number of chars received */
	return (len - mp->mp_cnt);
}

int
mbpp_hztoms(int h)
{
	int m = h;

	if (m > 0)
		m = m * 1000 / hz;
	return (m);
}

int
mbpp_mstohz(int m)
{
	int h = m;

	if (h > 0) {
		h = h * hz / 1000;
		if (h == 0)
			h = 1000 / hz;
	}
	return (h);
}
@


1.25
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.24 2014/07/12 18:48:52 tedu Exp $	*/
d1526 1
a1526 1
	int buflen, cnt, len;
d1533 1
a1533 1
	buflen = min(uio->uio_resid, mp->mp_burst);
d1548 1
a1548 1
		len = min(buflen, uio->uio_resid);
d1552 1
a1552 1
			error = uiomovei(ptr, len, uio);
d1572 1
a1572 1
				error = uiomovei(ptr, cnt, uio);
@


1.24
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.23 2010/07/02 17:27:01 nicm Exp $	*/
d1552 1
a1552 1
			error = uiomove(ptr, len, uio);
d1572 1
a1572 1
				error = uiomove(ptr, cnt, uio);
@


1.23
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.22 2010/06/28 14:13:34 deraadt Exp $	*/
d1630 1
a1630 1
	free(buffer, M_DEVBUF);
@


1.22
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.21 2010/04/12 12:57:52 tedu Exp $	*/
d1119 1
a1119 8
		if (tp->t_outq.c_cc <= tp->t_lowat) {
			if (ISSET(tp->t_state, TS_ASLEEP)) {
				CLR(tp->t_state, TS_ASLEEP);
				wakeup(&tp->t_outq);
			}

			selwakeup(&tp->t_wsel);
		}
@


1.21
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.20 2009/11/09 17:53:39 nicm Exp $	*/
d808 1
a808 1
		tp = ttymalloc();
@


1.20
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.19 2009/10/31 12:00:08 fgsch Exp $	*/
d918 1
a918 1
	return ((*linesw[tp->t_line].l_open)(dev, tp));
d932 1
a932 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.19
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.18 2009/10/31 06:40:17 deraadt Exp $	*/
a1125 1
			KNOTE(&tp->t_wsel.si_note, 0);
@


1.18
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.17 2008/11/29 05:56:41 deraadt Exp $	*/
d895 1
a895 1
	} else if (ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0) {
@


1.17
log
@unbreak tree breakage snuck in
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.16 2008/11/29 01:55:06 ray Exp $	*/
d1126 1
@


1.16
log
@Iain Hibbert (plunky@@netbsd) removed clauses 3 and 4 from his
licenses as well. Thanks!

"Groovy" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.15 2005/07/09 22:23:15 miod Exp $	*/
d28 1
a28 1
#define MAGMA_DEBUG
@


1.15
log
@Do not #include "foo.h" and keep the whole file between #if NFOO >0 ... #endif,
config(8) will not bring us into play unless NFOO > 0 anyway.
@
text
@d1 3
a3 4
/*	$OpenBSD: magma.c,v 1.14 2005/03/08 21:56:23 martin Exp $	*/
/*
 * magma.c
 *
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Iain Hibbert
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d26 2
a27 1
 *
a28 1
 */
@


1.14
log
@also display the correct priority on sparc64 when failing to register
an interrupt

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.13 2003/10/03 16:44:51 miod Exp $	*/
a40 3
#include "magma.h"
#if NMAGMA > 0

a1777 2

#endif /* NMAGMA */
@


1.13
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.12 2003/09/23 16:51:12 millert Exp $	*/
d341 2
a342 1
		printf(": failed to establish interrupt\n");
@


1.12
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.11 2003/08/15 20:32:17 tedu Exp $	*/
a816 3
		if (tp == NULL)
			break;
		tty_attach(tp);
@


1.11
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.10 2003/07/15 03:47:43 jason Exp $	*/
d1360 1
a1360 1
 *	mbppselect	do select on mbpp
d1528 1
a1528 1
 * select routine
d1531 1
a1531 1
mbppselect(dev_t dev, int rw, struct proc *p)
d1533 1
a1533 1
	return (ENODEV);
@


1.10
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.9 2003/06/27 01:36:53 jason Exp $	*/
d1068 1
a1068 1
		if (suser(p->p_ucred, &p->p_acflag))
@


1.9
log
@These don't need linear mappings either.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.8 2003/06/24 21:54:38 henric Exp $	*/
d209 1
a209 4
cd1400_compute_baud(speed, clock, cor, bpr)
	speed_t speed;
	int clock;
	int *cor, *bpr;
d228 5
d237 1
a237 3
cd1400_write_ccr(cd, cmd)
	struct cd1400 *cd;
	u_char cmd;
d239 2
a240 5
	while (cd1400_read_reg(cd, CD1400_CCR))
		;

	cd1400_write_reg(cd, CD1400_CCR, cmd);
}
d242 1
a242 21
/*
 * read a value from a cd1400 register
 */
__inline u_char
cd1400_read_reg(cd, reg)
	struct cd1400 *cd;
	int reg;
{
	return (bus_space_read_1(cd->cd_regt, cd->cd_regh, reg));
}

/*
 * write a value to a cd1400 register
 */
__inline void
cd1400_write_reg(cd, reg, value)
	struct cd1400 *cd;
	int reg;
	u_char value;
{
	bus_space_write_1(cd->cd_regt, cd->cd_regh, reg, value);
d249 1
a249 3
cd1400_enable_transmitter(cd, channel)
	struct cd1400 *cd;
	int channel;
d254 2
a255 2
	cd1400_write_reg(cd, CD1400_CAR, channel);
	srer = cd1400_read_reg(cd, CD1400_SRER);
d257 1
a257 1
	cd1400_write_reg(cd, CD1400_SRER, srer);
d279 1
a279 3
magma_match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d296 1
a296 4
magma_attach(parent, dev, aux)
	struct device *parent;
	struct device *dev;
	void *aux;
d393 1
a393 1
		cd->cd_chiprev = cd1400_read_reg(cd, CD1400_GFRCR);
d400 1
a400 1
		cd1400_write_reg(cd, CD1400_GFRCR, 0x00);
d403 2
a404 1
		cd1400_write_ccr(cd, CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);
d407 1
a407 1
		while (cd1400_read_reg(cd, CD1400_GFRCR) != cd->cd_chiprev)
d411 3
a413 1
		cd1400_write_reg(cd, CD1400_PPR, ((cd->cd_clock * 1000000 / CD1400_PPR_PRESCALER + 500) / 1000));
d415 5
a419 3
		/* The LC2+1Sp card is the only card that doesn't have a CD1190 for the
		 * parallel port, but uses channel 0 of the CD1400, so we make a note
		 * of it for later and set up the CD1400 for parallel mode operation.
d422 1
a422 1
			cd1400_write_reg(cd, CD1400_GCR, CD1400_GCR_PARALLEL);
d437 2
a438 1
		dprintf(("%s attach CD1190 %d addr 0x%x (failed)\n", sc->ms_dev.dv_xname, chip, cd->cd_reg));
d455 1
a455 2
magma_hard(arg)
	void *arg;
d467 1
a467 1
		status |= cd1400_read_reg(&sc->ms_cd1400[chip], CD1400_SVRR);
d482 1
a482 1
			n_chars = cd1400_read_reg(cd, CD1400_RDCR);
d489 1
a489 1
				*mbpp->mp_ptr = cd1400_read_reg(cd, CD1400_RDSR);
d501 1
a501 1
				line_stat = cd1400_read_reg(cd, CD1400_RDSR);
d505 1
a505 1
				n_chars = cd1400_read_reg(cd, CD1400_RDCR);
d511 3
a513 2
				*ptr++ = cd1400_read_reg(cd, CD1400_RDSR);
				if (ptr == mtty->mp_rend) ptr = mtty->mp_rbuf;
d515 2
a516 1
					if (ptr == mtty->mp_rbuf) ptr = mtty->mp_rend;
d518 2
a519 1
					SET(mtty->mp_flags, MTTYF_RING_OVERFLOW);
d528 1
a528 1
		cd1400_write_reg(cd, CD1400_EOSRR, 0);	/* end service context */
d544 1
a544 1
		msvr = cd1400_read_reg(cd, CD1400_MSVR2);
d553 1
a553 1
		cd1400_write_reg(cd, CD1400_EOSRR, 0);	/* end service context */
d573 1
a573 1
					cd1400_write_reg(cd, CD1400_TDR, *mbpp->mp_ptr);
d583 1
a583 1
				cd1400_write_reg(cd, CD1400_SRER, 0);
d600 2
a601 2
					cd1400_write_reg(cd, CD1400_TDR, 0);
					cd1400_write_reg(cd, CD1400_TDR, 0x81);
d608 2
a609 2
					cd1400_write_reg(cd, CD1400_TDR, 0);
					cd1400_write_reg(cd, CD1400_TDR, 0x83);
d627 1
a627 1
						cd1400_write_reg(cd, CD1400_TDR, ch);
d631 1
a631 1
					cd1400_write_reg(cd, CD1400_TDR, ch);
d643 1
a643 1
				srer = cd1400_read_reg(cd, CD1400_SRER);
d645 1
a645 1
				cd1400_write_reg(cd, CD1400_SRER, srer);
d653 1
a653 1
		cd1400_write_reg(cd, CD1400_EOSRR, 0);	/* end service context */
d676 1
a676 2
magma_soft(arg)
	void *arg;
d693 2
a694 1
			if (!ISSET(tp->t_state, TS_ISOPEN)) continue;
d751 2
a752 1
			if (!ISSET(mp->mp_flags, MBPPF_OPEN)) continue;
d786 1
a786 3
mtty_match(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
d790 2
a791 1
	return (args == mtty_match && sc->ms_board->mb_nser && sc->ms_mtty == NULL);
d795 1
a795 4
mtty_attach(parent, dev, args)
	struct device *parent;
	struct device *dev;
	void *args;
d804 2
a805 1
	for (port = 0, chip = 0, chan = 0 ; port < sc->ms_board->mb_nser ; port++) {
d810 4
a813 1
		if (mp->mp_cd1400->cd_parmode && chan == 0) chan = 1; /* skip channel 0 if parmode */
d817 2
a818 1
		if (tp == NULL) break;
d826 2
a827 1
		if (mp->mp_rbuf == NULL) break;
d832 2
a833 1
		if (chan == 0) chip++;
d844 1
a844 5
mttyopen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
d854 2
a855 1
	if (card >= mtty_cd.cd_ndevs || (ms = mtty_cd.cd_devs[card]) == NULL || port >= ms->ms_nports)
d886 1
a886 1
		cd1400_write_reg(cd, CD1400_CAR, mp->mp_channel);
d890 1
a890 1
		cd1400_write_reg(cd, CD1400_LIVR, port << 4);
d899 1
a899 1
		cd1400_write_reg(cd, CD1400_SRER, CD1400_SRER_RXDATA | CD1400_SRER_MDMCH);
d936 1
a936 5
mttyclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d958 1
a958 1
		cd1400_write_reg(cd, CD1400_CAR, mp->mp_channel);
d973 1
a973 4
mttyread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d986 1
a986 4
mttywrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d999 1
a999 2
mttytty(dev)
	dev_t dev;
d1011 1
a1011 6
mttyioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d1087 1
a1087 3
mttystop(tp, flags)
	struct tty *tp;
	int flags;
d1114 1
a1114 2
mtty_start(tp)
	struct tty *tp;
d1163 1
a1163 4
mtty_modem_control(mp, bits, howto)
	struct mtty_port *mp;
	int bits;
	int howto;
d1171 1
a1171 1
	cd1400_write_reg(cd, CD1400_CAR, mp->mp_channel);
d1179 1
a1179 1
		msvr = cd1400_read_reg(cd, CD1400_MSVR1);
d1183 1
a1183 1
		msvr = cd1400_read_reg(cd, CD1400_MSVR2);
d1199 1
a1199 1
			cd1400_write_reg(cd, CD1400_MSVR2,
d1202 1
a1202 1
		cd1400_write_reg(cd, CD1400_MSVR1,
d1209 1
a1209 1
			cd1400_write_reg(cd, CD1400_MSVR2, CD1400_MSVR2_DTR);
d1212 1
a1212 1
			cd1400_write_reg(cd, CD1400_MSVR1, CD1400_MSVR1_RTS);
d1218 1
a1218 1
			cd1400_write_reg(cd, CD1400_MSVR2, 0);
d1221 1
a1221 1
			cd1400_write_reg(cd, CD1400_MSVR1, 0);
d1234 1
a1234 3
mtty_param(tp, t)
	struct tty *tp;
	struct termios *t;
d1243 2
a1244 1
	if (t->c_ospeed && cd1400_compute_baud(t->c_ospeed, cd->cd_clock, &tcor, &tbpr))
d1247 2
a1248 1
	if (t->c_ispeed && cd1400_compute_baud(t->c_ispeed, cd->cd_clock, &rcor, &rbpr))
d1254 2
a1255 1
	(void)mtty_modem_control(mp, TIOCM_DTR, (t->c_ospeed == 0 ? DMBIC : DMBIS));
d1258 1
a1258 1
	/* cd1400_write_reg(cd, CD1400_CAR, mp->mp_channel); */
d1262 2
a1263 2
		cd1400_write_reg(cd, CD1400_TCOR, tcor);
		cd1400_write_reg(cd, CD1400_TBPR, tbpr);
d1268 2
a1269 2
		cd1400_write_reg(cd, CD1400_RCOR, rcor);
		cd1400_write_reg(cd, CD1400_RBPR, rbpr);
d1305 1
a1305 1
	cd1400_write_reg(cd, CD1400_COR1, opt);
d1314 1
a1314 1
	cd1400_write_reg(cd, CD1400_COR2, opt);
d1316 1
a1316 1
	cd1400_write_reg(cd, CD1400_COR3, MTTY_RX_FIFO_THRESHOLD);
d1320 2
a1321 2
	cd1400_write_reg(cd, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);
	cd1400_write_reg(cd, CD1400_COR5, 0);
d1339 2
a1340 2
	cd1400_write_reg(cd, CD1400_MCOR1, mcor1);
	cd1400_write_reg(cd, CD1400_MCOR2, mcor2);
d1343 1
a1343 1
	cd1400_write_reg(cd, CD1400_RTPR, 2);
d1369 1
a1369 3
mbpp_match(parent, vcf, args)
	struct device *parent;
	void *vcf, *args;
d1378 1
a1378 4
mbpp_attach(parent, dev, args)
	struct device *parent;
	struct device *dev;
	void *args;
d1408 1
a1408 5
mbppopen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
d1440 1
a1440 1
		cd1400_write_reg(cd, CD1400_CAR, 0);
d1442 1
a1442 1
		cd1400_write_reg(cd, CD1400_LIVR, (1<<3));
d1456 1
a1456 5
mbppclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d1469 1
a1469 4
mbppread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d1478 1
a1478 4
mbppwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d1487 1
a1487 6
mbppioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d1516 2
a1517 2
		cd1400_write_reg(mp->mp_cd1400, CD1400_CAR, 0);
		*(int *)data = cd1400_read_reg(mp->mp_cd1400, CD1400_PSVR);
d1531 1
a1531 4
mbppselect(dev, rw, p)
	dev_t dev;
	int rw;
	struct proc *p;
d1537 1
a1537 3
mbpp_rw(dev, uio)
	dev_t dev;
	struct uio *uio;
d1571 2
a1572 1
			if (error) break;
d1591 2
a1592 1
				if (error) break;
d1612 2
a1613 1
			if (error) break;
d1653 1
a1653 2
mbpp_timeout(arg)
	void *arg;
d1662 1
a1662 2
mbpp_start(arg)
	void *arg;
d1671 1
a1671 4
mbpp_send(mp, ptr, len)
	struct mbpp_port *mp;
	caddr_t ptr;
	int len;
d1683 1
a1683 1
		cd1400_write_reg(cd, CD1400_CAR, 0);
d1686 1
a1686 1
		cd1400_write_reg(cd, CD1400_TBPR, 10);
d1690 1
a1690 1
		cd1400_write_reg(cd, CD1400_SRER, CD1400_SRER_TXRDY);
d1698 1
a1698 1
		cd1400_write_reg(cd, CD1400_CAR, 0);
d1701 1
a1701 1
		cd1400_write_reg(cd, CD1400_SRER, 0);
d1714 1
a1714 4
mbpp_recv(mp, ptr, len)
	struct mbpp_port *mp;
	caddr_t ptr;
	int len;
d1728 1
a1728 1
		cd1400_write_reg(cd, CD1400_CAR, 0);
d1732 2
a1733 2
		cd1400_write_reg(cd, CD1400_RCOR, rcor);
		cd1400_write_reg(cd, CD1400_RBPR, rbpr);
d1736 1
a1736 1
		cd1400_write_reg(cd, CD1400_COR3, MBPP_RX_FIFO_THRESHOLD);
d1741 1
a1741 1
		cd1400_write_reg(cd, CD1400_SRER, CD1400_SRER_RXDATA);
d1749 1
a1749 1
		cd1400_write_reg(cd, CD1400_CAR, 0);
d1752 1
a1752 1
		cd1400_write_reg(cd, CD1400_SRER, 0);
d1762 1
a1762 2
mbpp_hztoms(h)
	int h;
d1772 1
a1772 2
mbpp_mstohz(m)
	int m;
@


1.8
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.7 2003/03/27 17:39:05 jason Exp $	*/
d359 1
a359 1
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_iohandle) != 0) {
@


1.7
log
@const and static cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.6 2003/02/11 19:20:28 mickey Exp $	*/
d369 1
a369 1
	    magma_hard, sc);
@


1.6
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.5 2002/03/14 04:18:05 jason Exp $	*/
d81 1
a81 1
static struct magma_board_info supported_cards[] = {
d309 1
a309 1
	struct magma_board_info *card;
d330 1
a330 1
	struct magma_board_info *card;
@


1.5
log
@Use getpropstringA instead of getpropstring to fetch magma_prom property
to avoid clobbering sa->sa_name (similiar fix as sparc)
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.4 2002/01/25 02:37:43 jason Exp $	*/
d425 1
a425 1
		dprintf(("%s attach CD1400 %d addr 0x%x rev %x clock %dMhz\n",
@


1.4
log
@Add support for the "Magma 2+1HS Sp" (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.3 2002/01/12 21:41:17 jason Exp $	*/
d331 1
a331 1
	char *magma_prom, *clockstr;
d334 1
a334 1
	magma_prom = getpropstring(sa->sa_node, "magma_prom");
@


1.4.4.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d331 1
a331 1
	char magma_prom[40], *clockstr;
d334 1
a334 1
	getpropstringA(sa->sa_node, "magma_prom", magma_prom);
@


1.4.4.2
log
@Sync the SMP branch with 3.3
@
text
@d425 1
a425 1
		dprintf(("%s attach CD1400 %d addr 0x%x rev %x clock %dMHz\n",
@


1.4.4.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.4.4.2 2003/03/28 00:38:30 niklas Exp $	*/
d81 1
a81 1
static const struct magma_board_info supported_cards[] = {
d309 1
a309 1
	const struct magma_board_info *card;
d330 1
a330 1
	const struct magma_board_info *card;
@


1.4.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d209 4
a212 1
cd1400_compute_baud(speed_t speed, int clock, int *cor, int *bpr)
a230 5
#define	CD1400_READ_REG(cd,reg) \
    bus_space_read_1((cd)->cd_regt, (cd)->cd_regh, (reg))
#define	CD1400_WRITE_REG(cd,reg,value) \
    bus_space_write_1((cd)->cd_regt, (cd)->cd_regh, (reg), (value))

d235 17
a251 1
cd1400_write_ccr(struct cd1400 *cd, u_char cmd)
d253 2
a254 2
	while (CD1400_READ_REG(cd, CD1400_CCR))
		/*EMPTY*/;
d256 10
a265 1
	CD1400_WRITE_REG(cd, CD1400_CCR, cmd);
d272 3
a274 1
cd1400_enable_transmitter(struct cd1400 *cd, int channel)
d279 2
a280 2
	CD1400_WRITE_REG(cd, CD1400_CAR, channel);
	srer = CD1400_READ_REG(cd, CD1400_SRER);
d282 1
a282 1
	CD1400_WRITE_REG(cd, CD1400_SRER, srer);
d304 3
a306 1
magma_match(struct device *parent, void *vcf, void *aux)
d323 4
a326 1
magma_attach(struct device *parent, struct device *dev, void *aux)
d359 1
a359 1
	    0, 0, &sc->sc_iohandle) != 0) {
d369 1
a369 1
	    magma_hard, sc, dev->dv_xname);
d423 1
a423 1
		cd->cd_chiprev = CD1400_READ_REG(cd, CD1400_GFRCR);
d430 1
a430 1
		CD1400_WRITE_REG(cd, CD1400_GFRCR, 0x00);
d433 1
a433 2
		cd1400_write_ccr(cd,
		    CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);
d436 1
a436 1
		while (CD1400_READ_REG(cd, CD1400_GFRCR) != cd->cd_chiprev)
d440 1
a440 3
		CD1400_WRITE_REG(cd, CD1400_PPR,
		    ((cd->cd_clock * 1000000 / CD1400_PPR_PRESCALER + 500)
		    / 1000));
d442 3
a444 5
		/*
		 * The LC2+1Sp card is the only card that doesn't have a
		 * CD1190 for the parallel port, but uses channel 0 of the
		 * CD1400, so we make a note of it for later and set up the
		 * CD1400 for parallel mode operation.
d447 1
a447 1
			CD1400_WRITE_REG(cd, CD1400_GCR, CD1400_GCR_PARALLEL);
d462 1
a462 2
		dprintf(("%s attach CD1190 %d addr 0x%x (failed)\n",
		    sc->ms_dev.dv_xname, chip, cd->cd_reg));
d479 2
a480 1
magma_hard(void *arg)
d492 1
a492 1
		status |= CD1400_READ_REG(&sc->ms_cd1400[chip], CD1400_SVRR);
d507 1
a507 1
			n_chars = CD1400_READ_REG(cd, CD1400_RDCR);
d514 1
a514 1
				*mbpp->mp_ptr = CD1400_READ_REG(cd, CD1400_RDSR);
d526 1
a526 1
				line_stat = CD1400_READ_REG(cd, CD1400_RDSR);
d530 1
a530 1
				n_chars = CD1400_READ_REG(cd, CD1400_RDCR);
d536 2
a537 3
				*ptr++ = CD1400_READ_REG(cd, CD1400_RDSR);
				if (ptr == mtty->mp_rend)
					ptr = mtty->mp_rbuf;
d539 1
a539 2
					if (ptr == mtty->mp_rbuf)
						ptr = mtty->mp_rend;
d541 1
a541 2
					SET(mtty->mp_flags,
					    MTTYF_RING_OVERFLOW);
d550 1
a550 1
		CD1400_WRITE_REG(cd, CD1400_EOSRR, 0);	/* end service context */
d566 1
a566 1
		msvr = CD1400_READ_REG(cd, CD1400_MSVR2);
d575 1
a575 1
		CD1400_WRITE_REG(cd, CD1400_EOSRR, 0);	/* end service context */
d595 1
a595 1
					CD1400_WRITE_REG(cd, CD1400_TDR, *mbpp->mp_ptr);
d605 1
a605 1
				CD1400_WRITE_REG(cd, CD1400_SRER, 0);
d622 2
a623 2
					CD1400_WRITE_REG(cd, CD1400_TDR, 0);
					CD1400_WRITE_REG(cd, CD1400_TDR, 0x81);
d630 2
a631 2
					CD1400_WRITE_REG(cd, CD1400_TDR, 0);
					CD1400_WRITE_REG(cd, CD1400_TDR, 0x83);
d649 1
a649 1
						CD1400_WRITE_REG(cd, CD1400_TDR, ch);
d653 1
a653 1
					CD1400_WRITE_REG(cd, CD1400_TDR, ch);
d665 1
a665 1
				srer = CD1400_READ_REG(cd, CD1400_SRER);
d667 1
a667 1
				CD1400_WRITE_REG(cd, CD1400_SRER, srer);
d675 1
a675 1
		CD1400_WRITE_REG(cd, CD1400_EOSRR, 0);	/* end service context */
d698 2
a699 1
magma_soft(void *arg)
d716 1
a716 2
			if (!ISSET(tp->t_state, TS_ISOPEN))
				continue;
d773 1
a773 2
			if (!ISSET(mp->mp_flags, MBPPF_OPEN))
				continue;
d807 3
a809 1
mtty_match(struct device *parent, void *vcf, void *args)
d813 1
a813 2
	return (args == mtty_match && sc->ms_board->mb_nser &&
	    sc->ms_mtty == NULL);
d817 4
a820 1
mtty_attach(struct device *parent, struct device *dev, void *args)
d829 1
a829 2
	for (port = 0, chip = 0, chan = 0;
	     port < sc->ms_board->mb_nser; port++) {
d834 1
a834 4
		if (mp->mp_cd1400->cd_parmode && chan == 0) {
			/* skip channel 0 if parmode */
			chan = 1;
		}
d838 2
d846 1
a846 2
		if (mp->mp_rbuf == NULL)
			break;
d851 1
a851 2
		if (chan == 0)
			chip++;
d862 5
a866 1
mttyopen(dev_t dev, int flags, int mode, struct proc *p)
d876 1
a876 2
	if (card >= mtty_cd.cd_ndevs || (ms = mtty_cd.cd_devs[card]) == NULL
	    || port >= ms->ms_nports)
d907 1
a907 1
		CD1400_WRITE_REG(cd, CD1400_CAR, mp->mp_channel);
d911 1
a911 1
		CD1400_WRITE_REG(cd, CD1400_LIVR, port << 4);
d920 1
a920 1
		CD1400_WRITE_REG(cd, CD1400_SRER, CD1400_SRER_RXDATA | CD1400_SRER_MDMCH);
d957 5
a961 1
mttyclose(dev_t dev, int flag, int mode, struct proc *p)
d983 1
a983 1
		CD1400_WRITE_REG(cd, CD1400_CAR, mp->mp_channel);
d998 4
a1001 1
mttyread(dev_t dev, struct uio *uio, int flags)
d1014 4
a1017 1
mttywrite(dev_t dev, struct uio *uio, int flags)
d1030 2
a1031 1
mttytty(dev_t dev)
d1043 6
a1048 1
mttyioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
d1105 1
a1105 1
		if (suser(p, 0))
d1124 3
a1126 1
mttystop(struct tty *tp, int flags)
d1153 2
a1154 1
mtty_start(struct tty *tp)
d1203 4
a1206 1
mtty_modem_control(struct mtty_port *mp, int bits, int howto)
d1214 1
a1214 1
	CD1400_WRITE_REG(cd, CD1400_CAR, mp->mp_channel);
d1222 1
a1222 1
		msvr = CD1400_READ_REG(cd, CD1400_MSVR1);
d1226 1
a1226 1
		msvr = CD1400_READ_REG(cd, CD1400_MSVR2);
d1242 1
a1242 1
			CD1400_WRITE_REG(cd, CD1400_MSVR2,
d1245 1
a1245 1
		CD1400_WRITE_REG(cd, CD1400_MSVR1,
d1252 1
a1252 1
			CD1400_WRITE_REG(cd, CD1400_MSVR2, CD1400_MSVR2_DTR);
d1255 1
a1255 1
			CD1400_WRITE_REG(cd, CD1400_MSVR1, CD1400_MSVR1_RTS);
d1261 1
a1261 1
			CD1400_WRITE_REG(cd, CD1400_MSVR2, 0);
d1264 1
a1264 1
			CD1400_WRITE_REG(cd, CD1400_MSVR1, 0);
d1277 3
a1279 1
mtty_param(struct tty *tp, struct termios *t)
d1288 1
a1288 2
	if (t->c_ospeed &&
	    cd1400_compute_baud(t->c_ospeed, cd->cd_clock, &tcor, &tbpr))
d1291 1
a1291 2
	if (t->c_ispeed &&
	    cd1400_compute_baud(t->c_ispeed, cd->cd_clock, &rcor, &rbpr))
d1297 1
a1297 2
	(void)mtty_modem_control(mp, TIOCM_DTR,
	    (t->c_ospeed == 0 ? DMBIC : DMBIS));
d1300 1
a1300 1
	/* CD1400_WRITE_REG(cd, CD1400_CAR, mp->mp_channel); */
d1304 2
a1305 2
		CD1400_WRITE_REG(cd, CD1400_TCOR, tcor);
		CD1400_WRITE_REG(cd, CD1400_TBPR, tbpr);
d1310 2
a1311 2
		CD1400_WRITE_REG(cd, CD1400_RCOR, rcor);
		CD1400_WRITE_REG(cd, CD1400_RBPR, rbpr);
d1347 1
a1347 1
	CD1400_WRITE_REG(cd, CD1400_COR1, opt);
d1356 1
a1356 1
	CD1400_WRITE_REG(cd, CD1400_COR2, opt);
d1358 1
a1358 1
	CD1400_WRITE_REG(cd, CD1400_COR3, MTTY_RX_FIFO_THRESHOLD);
d1362 2
a1363 2
	CD1400_WRITE_REG(cd, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);
	CD1400_WRITE_REG(cd, CD1400_COR5, 0);
d1381 2
a1382 2
	CD1400_WRITE_REG(cd, CD1400_MCOR1, mcor1);
	CD1400_WRITE_REG(cd, CD1400_MCOR2, mcor2);
d1385 1
a1385 1
	CD1400_WRITE_REG(cd, CD1400_RTPR, 2);
d1402 1
a1402 1
 *	mbpppoll	do poll on mbpp
d1411 3
a1413 1
mbpp_match(struct device *parent, void *vcf, void *args)
d1422 4
a1425 1
mbpp_attach(struct device *parent, struct device *dev, void *args)
d1455 5
a1459 1
mbppopen(dev_t dev, int flags, int mode, struct proc *p)
d1491 1
a1491 1
		CD1400_WRITE_REG(cd, CD1400_CAR, 0);
d1493 1
a1493 1
		CD1400_WRITE_REG(cd, CD1400_LIVR, (1<<3));
d1507 5
a1511 1
mbppclose(dev_t dev, int flag, int mode, struct proc *p)
d1524 4
a1527 1
mbppread(dev_t dev, struct uio *uio, int flags)
d1536 4
a1539 1
mbppwrite(dev_t dev, struct uio *uio, int flags)
d1548 6
a1553 1
mbppioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
d1582 2
a1583 2
		CD1400_WRITE_REG(mp->mp_cd1400, CD1400_CAR, 0);
		*(int *)data = CD1400_READ_REG(mp->mp_cd1400, CD1400_PSVR);
d1594 1
a1594 1
 * poll routine
d1597 4
a1600 1
mbpppoll(dev_t dev, int events, struct proc *p)
d1602 1
a1602 1
	return (seltrue(dev, events, p));
d1606 3
a1608 1
mbpp_rw(dev_t dev, struct uio *uio)
d1642 1
a1642 2
			if (error)
				break;
d1661 1
a1661 2
				if (error)
					break;
d1681 1
a1681 2
			if (error)
				break;
d1721 2
a1722 1
mbpp_timeout(void *arg)
d1731 2
a1732 1
mbpp_start(void *arg)
d1741 4
a1744 1
mbpp_send(struct mbpp_port *mp, caddr_t ptr, int len)
d1756 1
a1756 1
		CD1400_WRITE_REG(cd, CD1400_CAR, 0);
d1759 1
a1759 1
		CD1400_WRITE_REG(cd, CD1400_TBPR, 10);
d1763 1
a1763 1
		CD1400_WRITE_REG(cd, CD1400_SRER, CD1400_SRER_TXRDY);
d1771 1
a1771 1
		CD1400_WRITE_REG(cd, CD1400_CAR, 0);
d1774 1
a1774 1
		CD1400_WRITE_REG(cd, CD1400_SRER, 0);
d1787 4
a1790 1
mbpp_recv(struct mbpp_port *mp, caddr_t ptr, int len)
d1804 1
a1804 1
		CD1400_WRITE_REG(cd, CD1400_CAR, 0);
d1808 2
a1809 2
		CD1400_WRITE_REG(cd, CD1400_RCOR, rcor);
		CD1400_WRITE_REG(cd, CD1400_RBPR, rbpr);
d1812 1
a1812 1
		CD1400_WRITE_REG(cd, CD1400_COR3, MBPP_RX_FIFO_THRESHOLD);
d1817 1
a1817 1
		CD1400_WRITE_REG(cd, CD1400_SRER, CD1400_SRER_RXDATA);
d1825 1
a1825 1
		CD1400_WRITE_REG(cd, CD1400_CAR, 0);
d1828 1
a1828 1
		CD1400_WRITE_REG(cd, CD1400_SRER, 0);
d1838 2
a1839 1
mbpp_hztoms(int h)
d1849 2
a1850 1
mbpp_mstohz(int m)
@


1.4.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.4 2002/01/25 02:37:43 jason Exp $	*/
@


1.4.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.4.2.1 2002/01/31 22:55:38 niklas Exp $	*/
d331 1
a331 1
	char magma_prom[40], *clockstr;
d334 1
a334 1
	getpropstringA(sa->sa_node, "magma_prom", magma_prom);
@


1.4.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 1
a81 1
static const struct magma_board_info supported_cards[] = {
d309 1
a309 1
	const struct magma_board_info *card;
d330 1
a330 1
	const struct magma_board_info *card;
d425 1
a425 1
		dprintf(("%s attach CD1400 %d addr 0x%x rev %x clock %dMHz\n",
@


1.3
log
@the 1190 and 1400 register maps aren't the same size don't treat them so
(basically this was a cut and pasto).
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.2 2002/01/12 21:30:56 jason Exp $	*/
d83 1
a83 1
		"MAGMA,4_Sp", "Magma 4 Sp", 4, 0,
d88 1
a88 1
		"MAGMA,8_Sp", "Magma 8 Sp", 8, 0,
d93 1
a93 1
		"MAGMA,_8HS_Sp", "Magma Fast 8 Sp", 8, 0,
d98 1
a98 1
		"MAGMA,_8SP_422", "Magma 8 Sp - 422", 8, 0,
d103 1
a103 1
		"MAGMA,12_Sp", "Magma 12 Sp", 12, 0,
d108 1
a108 1
		"MAGMA,16_Sp", "Magma 16 Sp", 16, 0,
d113 1
a113 1
		"MAGMA,16_Sp_2", "Magma 16 Sp", 16, 0,
d118 1
a118 1
		"MAGMA,16HS_Sp", "Magma Fast 16 Sp", 16, 0,
d123 1
a123 1
		"MAGMA,21_Sp", "Magma LC 2+1 Sp", 2, 1,
d128 1
a128 1
		"MAGMA,21HS_Sp", "Magma 2+1 Sp", 2, 1,
d133 1
a133 1
		"MAGMA,41_Sp", "Magma 4+1 Sp", 4, 1,
d138 1
a138 1
		"MAGMA,82_Sp", "Magma 8+2 Sp", 8, 2,
d143 1
a143 1
		"MAGMA,P1_Sp", "Magma P1 Sp", 0, 1,
d148 1
a148 1
		"MAGMA,P2_Sp", "Magma P2 Sp", 0, 2,
d153 6
a158 1
		NULL, NULL, 0, 0,
d309 1
d311 9
a319 2
	/* is it a magma Sp card? */
	return (strcmp("MAGMA_Sp", sa->sa_name) == 0);
d330 11
a340 7
	struct magma_board_info *card = supported_cards;
	char *magma_prom = getpropstring(sa->sa_node, "magma_prom");
	int chip;

	/* find the card type */
	while (card->mb_name && strcmp(magma_prom, card->mb_name))
		card++;
d342 1
a342 1
		printf(" %s (unsupported)\n", magma_prom);
d348 9
d411 2
a412 1
		char *str;
a419 11

		str = getpropstring(sa->sa_node, "clock");
		if (strlen(str) == 0)
			cd->cd_clock = 25;
		else {
			char *cp = str;

			cd->cd_clock = 0;
			while (*cp != '\0')
				cd->cd_clock = cd->cd_clock * 10 + *cp++ - '0';
		}
@


1.2
log
@House cleaning: removing some leftover sparc bits and such
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.1 2002/01/12 20:19:40 jason Exp $	*/
d441 2
a442 2
		    card->mb_cd1190[chip], CD1400_REGMAPSIZE, &cd->cd_regh)) {
			printf(": failed to map cd1400 regs\n");
@


1.1
log
@Port of Iain Hibbert's magma driver to sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: magma.c,v 1.9 2002/01/11 05:17:30 jason Exp $	*/
a68 13
/*
 * Select tty soft interrupt bit based on TTY ipl. (stole from zs.c)
 */
#if PIL_TTY == 1
# define IE_MSOFT IE_L1
#elif PIL_TTY == 4
# define IE_MSOFT IE_L4
#elif PIL_TTY == 6
# define IE_MSOFT IE_L6
#else
# error "no suitable software interrupt bit"
#endif

a319 1
	void *base;
d438 1
a438 1
	struct cd1190 *cd = &sc->ms_cd1190[chip];
d440 6
a445 1
		cd->cd_reg = base + card->mb_cd1190[chip];
@

