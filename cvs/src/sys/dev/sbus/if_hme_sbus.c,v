head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.10
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.4
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.15;
commitid	5gdEnqVoJuTuwdTu;

1.15
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.14;
commitid	nYggAidK85QbUFh2;

1.14
date	2013.08.07.01.06.40;	author bluhm;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.12.21.27.09;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.21.22.13.36;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.02.20.00.56;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.21.22.10.56;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.01.18.09.52;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.07.15.37.07;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.27.01.36.53;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.24.21.54.38;	author henric;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.17.01.29.20;	author henric;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.13.21.01.19;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.21.16.19.50;	author jason;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.38.30;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.56.32;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2003.05.19.22.14.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_hme_sbus.c,v 1.15 2014/08/11 12:45:45 mpi Exp $	*/
/*	$NetBSD: if_hme_sbus.c,v 1.6 2001/02/28 14:52:48 mrg Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * SBus front-end device driver for the HME ethernet device.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>

#include <dev/sbus/sbusvar.h>
#include <dev/ic/hmevar.h>
#include <dev/ofw/openfirm.h>

struct hmesbus_softc {
	struct	hme_softc	hsc_hme;	/* HME device */
};

int	hmematch_sbus(struct device *, void *, void *);
void	hmeattach_sbus(struct device *, struct device *, void *);

struct cfattach hme_sbus_ca = {
	sizeof(struct hmesbus_softc), hmematch_sbus, hmeattach_sbus
};

int
hmematch_sbus(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct sbus_attach_args *sa = aux;

	return (strcmp(cf->cf_driver->cd_name, sa->sa_name) == 0 ||
	    strcmp("SUNW,qfe", sa->sa_name) == 0 ||
	    strcmp("SUNW,hme", sa->sa_name) == 0);
}

void
hmeattach_sbus(struct device *parent, struct device *self, void *aux)
{
	struct sbus_attach_args *sa = aux;
	struct hmesbus_softc *hsc = (void *)self;
	struct hme_softc *sc = &hsc->hsc_hme;
	u_int32_t burst, sbusburst;
	/* XXX the following declaration should be elsewhere */
	extern void myetheraddr(u_char *);

	/* Pass on the bus tags */
	sc->sc_bustag = sa->sa_bustag;
	sc->sc_dmatag = sa->sa_dmatag;

	if (sa->sa_nintr < 1) {
		printf(": no interrupt\n");
		return;
	}

	if (sa->sa_nreg < 5) {
		printf(": only %d register sets\n", sa->sa_nreg);
		return;
	}

	/*
	 * Map five register banks:
	 *
	 *	bank 0: HME SEB registers
	 *	bank 1: HME ETX registers
	 *	bank 2: HME ERX registers
	 *	bank 3: HME MAC registers
	 *	bank 4: HME MIF registers
	 *
	 */
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    (bus_addr_t)sa->sa_reg[0].sbr_offset,
	    (bus_size_t)sa->sa_reg[0].sbr_size, 0, 0, &sc->sc_seb) != 0) {
		printf(": can't map registers\n");
		return;
	}
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[1].sbr_slot,
	    (bus_addr_t)sa->sa_reg[1].sbr_offset,
	    (bus_size_t)sa->sa_reg[1].sbr_size, 0, 0, &sc->sc_etx) != 0) {
		printf(": can't map registers\n");
		return;
	}
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[2].sbr_slot,
	    (bus_addr_t)sa->sa_reg[2].sbr_offset,
	    (bus_size_t)sa->sa_reg[2].sbr_size, 0, 0, &sc->sc_erx) != 0) {
		printf(": can't map registers\n");
		return;
	}
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[3].sbr_slot,
	    (bus_addr_t)sa->sa_reg[3].sbr_offset,
	    (bus_size_t)sa->sa_reg[3].sbr_size, 0, 0, &sc->sc_mac) != 0) {
		printf(": can't map registers\n");
		return;
	}
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[4].sbr_slot,
	    (bus_addr_t)sa->sa_reg[4].sbr_offset,
	    (bus_size_t)sa->sa_reg[4].sbr_size, 0, 0, &sc->sc_mif) != 0) {
		printf(": can't map registers\n");
		return;
	}

	if (OF_getprop(sa->sa_node, "local-mac-address",
	    sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN) <= 0)
		myetheraddr(sc->sc_arpcom.ac_enaddr);

	/*
	 * Get transfer burst size from PROM and pass it on
	 * to the back-end driver.
	 */
	sbusburst = ((struct sbus_softc *)parent)->sc_burst;
	if (sbusburst == 0)
		sbusburst = SBUS_BURST_32 - 1; /* 1->16 */

	burst = getpropint(sa->sa_node, "burst-sizes", -1);
	if (burst == -1)
		/* take SBus burst sizes */
		burst = sbusburst;

	/* Clamp at parent's burst sizes */
	burst &= sbusburst;

	/* Translate into plain numerical format */
	if ((burst & SBUS_BURST_64))
		sc->sc_burst = 64;
	else if ((burst & SBUS_BURST_32))
		sc->sc_burst = 32;
	else if ((burst & SBUS_BURST_16))
		sc->sc_burst = 16;
	else
		sc->sc_burst = 0;

	sc->sc_pci = 0; /* XXXXX should all be done in bus_dma. */

	/* Establish interrupt handler */
	bus_intr_establish(sa->sa_bustag, sa->sa_pri, IPL_NET, 0, hme_intr,
	    sc, self->dv_xname);

	hme_config(sc);
}
@


1.15
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.14 2013/08/07 01:06:40 bluhm Exp $	*/
a44 1
#include <net/if_dl.h>
@


1.14
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.13 2009/07/12 21:27:09 kettenis Exp $	*/
a47 1
#ifdef INET
a48 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a49 1
#endif
@


1.13
log
@Don't attach when the PROM didn't give us an interrupt.  Fix printed messages
in error paths while I'm there.  Eliminate a fairly useless local variable
as well.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.12 2008/06/26 05:42:18 ray Exp $	*/
a50 1
#include <netinet/in_var.h>
@


1.12
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.11 2006/12/21 22:13:36 jason Exp $	*/
d96 1
a96 2
	int node;
	/* XXX the following declarations should be elsewhere */
a98 2
	node = sa->sa_node;

d103 5
d109 1
a109 2
		printf("%s: only %d register sets\n",
			self->dv_xname, sa->sa_nreg);
d126 1
a126 1
		printf("%s @@ sbus: cannot map registers\n", self->dv_xname);
d132 1
a132 1
		printf("%s @@ sbus: cannot map registers\n", self->dv_xname);
d138 1
a138 1
		printf("%s @@ sbus: cannot map registers\n", self->dv_xname);
d144 1
a144 1
		printf("%s @@ sbus: cannot map registers\n", self->dv_xname);
d150 1
a150 1
		printf("%s @@ sbus: cannot map registers\n", self->dv_xname);
d166 1
a166 1
	burst = getpropint(node, "burst-sizes", -1);
d187 2
a188 3
	if (sa->sa_nintr != 0)
		(void)bus_intr_establish(sa->sa_bustag, sa->sa_pri, IPL_NET, 0,
					 hme_intr, sc, self->dv_xname);
@


1.11
log
@betetr yet, just nuke sc_enaddr all together, just fill in arpcom and
everybody is happy
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.10 2006/06/02 20:00:56 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.10
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.9 2005/10/21 22:10:56 brad Exp $	*/
d161 2
a162 2
	    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
		myetheraddr(sc->sc_enaddr);
@


1.9
log
@tidy up dmesg printing a bit, makes PCI hme only take 2 lines
per interface instead of 3.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.8 2005/04/01 18:09:52 brad Exp $	*/
a75 1
	struct	sbusdev		hsc_sbus;	/* SBus device */
a101 1
	struct sbusdev *sd = &hsc->hsc_sbus;
a158 3

	sd->sd_reset = (void *)hme_reset;
	sbus_establish(sd, self);
@


1.8
log
@handle burst size of 64
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.7 2003/07/07 15:37:07 jason Exp $	*/
a195 1
	hme_config(sc);
d201 2
@


1.7
log
@ansify and remove statics
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.6 2003/06/27 01:36:53 jason Exp $	*/
d186 8
a193 2
	sc->sc_burst =  (burst & SBUS_BURST_32) ? 32 :
			(burst & SBUS_BURST_16) ? 16 : 0;
@


1.6
log
@These don't need linear mappings either.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.5 2003/06/24 21:54:38 henric Exp $	*/
d87 1
a87 4
hmematch_sbus(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
d98 1
a98 3
hmeattach_sbus(parent, self, aux)
	struct device *parent, *self;
	void *aux;
@


1.5
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.4 2003/02/17 01:29:20 henric Exp $	*/
d136 3
a138 5
	if (sbus_bus_map(sa->sa_bustag,
			 sa->sa_reg[0].sbr_slot,
			 (bus_addr_t)sa->sa_reg[0].sbr_offset,
			 (bus_size_t)sa->sa_reg[0].sbr_size,
			 BUS_SPACE_MAP_LINEAR, 0, &sc->sc_seb) != 0) {
d142 3
a144 5
	if (sbus_bus_map(sa->sa_bustag,
			 sa->sa_reg[1].sbr_slot,
			 (bus_addr_t)sa->sa_reg[1].sbr_offset,
			 (bus_size_t)sa->sa_reg[1].sbr_size,
			 BUS_SPACE_MAP_LINEAR, 0, &sc->sc_etx) != 0) {
d148 3
a150 5
	if (sbus_bus_map(sa->sa_bustag,
			 sa->sa_reg[2].sbr_slot,
			 (bus_addr_t)sa->sa_reg[2].sbr_offset,
			 (bus_size_t)sa->sa_reg[2].sbr_size,
			 BUS_SPACE_MAP_LINEAR, 0, &sc->sc_erx) != 0) {
d154 3
a156 5
	if (sbus_bus_map(sa->sa_bustag,
			 sa->sa_reg[3].sbr_slot,
			 (bus_addr_t)sa->sa_reg[3].sbr_offset,
			 (bus_size_t)sa->sa_reg[3].sbr_size,
			 BUS_SPACE_MAP_LINEAR, 0, &sc->sc_mac) != 0) {
d160 3
a162 5
	if (sbus_bus_map(sa->sa_bustag,
			 sa->sa_reg[4].sbr_slot,
			 (bus_addr_t)sa->sa_reg[4].sbr_offset,
			 (bus_size_t)sa->sa_reg[4].sbr_size,
			 BUS_SPACE_MAP_LINEAR, 0, &sc->sc_mif) != 0) {
@


1.4
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.3 2002/03/14 01:27:02 millert Exp $	*/
d210 1
a210 1
					 hme_intr, sc);
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.2 2002/03/13 21:01:19 jason Exp $	*/
d137 1
a137 1
			 (bus_type_t)sa->sa_reg[0].sbr_slot,
d145 1
a145 1
			 (bus_type_t)sa->sa_reg[1].sbr_slot,
d153 1
a153 1
			 (bus_type_t)sa->sa_reg[2].sbr_slot,
d161 1
a161 1
			 (bus_type_t)sa->sa_reg[3].sbr_slot,
d169 1
a169 1
			 (bus_type_t)sa->sa_reg[4].sbr_slot,
@


1.2
log
@Try fetching the mac address from the local-mac-address property, and if
it fails, fall back to myetheraddr()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.1 2001/08/21 16:19:50 jason Exp $	*/
d79 2
a80 2
int	hmematch_sbus __P((struct device *, void *, void *));
void	hmeattach_sbus __P((struct device *, struct device *, void *));
d112 1
a112 1
	extern void myetheraddr __P((u_char *));
@


1.1
log
@sbus specific driver for hme (from netbsd)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 1
d180 3
a182 1
	myetheraddr(sc->sc_enaddr);
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_hme_sbus.c,v 1.1 2001/08/21 16:19:50 jason Exp $	*/
a71 1
#include <dev/ofw/openfirm.h>
d78 2
a79 2
int	hmematch_sbus(struct device *, void *, void *);
void	hmeattach_sbus(struct device *, struct device *, void *);
d111 1
a111 1
	extern void myetheraddr(u_char *);
d179 1
a179 3
	if (OF_getprop(sa->sa_node, "local-mac-address",
	    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
		myetheraddr(sc->sc_enaddr);
@


1.1.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d137 1
a137 1
			 sa->sa_reg[0].sbr_slot,
d145 1
a145 1
			 sa->sa_reg[1].sbr_slot,
d153 1
a153 1
			 sa->sa_reg[2].sbr_slot,
d161 1
a161 1
			 sa->sa_reg[3].sbr_slot,
d169 1
a169 1
			 sa->sa_reg[4].sbr_slot,
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.1.4.2
log
@Merge in -current from roughly a week ago
@
text
@a71 1
#include <dev/ofw/openfirm.h>
d78 2
a79 2
int	hmematch_sbus(struct device *, void *, void *);
void	hmeattach_sbus(struct device *, struct device *, void *);
d111 1
a111 1
	extern void myetheraddr(u_char *);
d179 1
a179 3
	if (OF_getprop(sa->sa_node, "local-mac-address",
	    sc->sc_enaddr, ETHER_ADDR_LEN) <= 0)
		myetheraddr(sc->sc_enaddr);
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d137 1
a137 1
			 sa->sa_reg[0].sbr_slot,
d145 1
a145 1
			 sa->sa_reg[1].sbr_slot,
d153 1
a153 1
			 sa->sa_reg[2].sbr_slot,
d161 1
a161 1
			 sa->sa_reg[3].sbr_slot,
d169 1
a169 1
			 sa->sa_reg[4].sbr_slot,
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d87 4
a90 1
hmematch_sbus(struct device *parent, void *vcf, void *aux)
d101 3
a103 1
hmeattach_sbus(struct device *parent, struct device *self, void *aux)
d136 5
a140 3
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    (bus_addr_t)sa->sa_reg[0].sbr_offset,
	    (bus_size_t)sa->sa_reg[0].sbr_size, 0, 0, &sc->sc_seb) != 0) {
d144 5
a148 3
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[1].sbr_slot,
	    (bus_addr_t)sa->sa_reg[1].sbr_offset,
	    (bus_size_t)sa->sa_reg[1].sbr_size, 0, 0, &sc->sc_etx) != 0) {
d152 5
a156 3
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[2].sbr_slot,
	    (bus_addr_t)sa->sa_reg[2].sbr_offset,
	    (bus_size_t)sa->sa_reg[2].sbr_size, 0, 0, &sc->sc_erx) != 0) {
d160 5
a164 3
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[3].sbr_slot,
	    (bus_addr_t)sa->sa_reg[3].sbr_offset,
	    (bus_size_t)sa->sa_reg[3].sbr_size, 0, 0, &sc->sc_mac) != 0) {
d168 5
a172 3
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[4].sbr_slot,
	    (bus_addr_t)sa->sa_reg[4].sbr_offset,
	    (bus_size_t)sa->sa_reg[4].sbr_size, 0, 0, &sc->sc_mif) != 0) {
d210 1
a210 1
					 hme_intr, sc, self->dv_xname);
@


