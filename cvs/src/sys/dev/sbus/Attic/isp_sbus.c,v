head	1.22;
access;
symbols
	OPENBSD_5_7:1.21.0.6
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.4
	UBC:1.2.0.2
	UBC_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.06.19.11.12.24;	author jmatthew;	state dead;
branches;
next	1.21;
commitid	I5HMIEQiHPSVn0jd;

1.21
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.20;
commitid	OBNa5kfxQ2UXoiIw;

1.20
date	2014.02.14.14.00.08;	author jmatthew;	state Exp;
branches;
next	1.19;

1.19
date	2014.02.10.22.41.27;	author jmatthew;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.22.23.19.55;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.02.16.05.16;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.02.15.47.37;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.01.20.49.24;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.24.11.38.40;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.01.15.49.25;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.10.19.49.31;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.02.20.00.56;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.02.17.10.03;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.24.21.54.38;	author henric;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.17.01.29.21;	author henric;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.17.01.19.49;	author mjacob;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.14.02.51.12;	author mjacob;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.10.06.02.03.24;	author jason;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.38.30;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.10.56.32;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.05.19.22.14.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@remove isp(4) now that the ql* family have replaced it
@
text
@/*	$OpenBSD: isp_sbus.c,v 1.21 2014/07/12 18:48:52 tedu Exp $	*/
/* $NetBSD: isp_sbus.c,v 1.46 2001/09/26 20:53:14 eeh Exp $ */
/*
 * SBus specific probe and attach routines for QLogic ISP SCSI adapters.
 *
 * Copyright (c) 1997, 2001 by Matthew Jacob
 * NASA AMES Research Center
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/queue.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>

#include <dev/ic/isp_openbsd.h>

#ifndef ISP_NOFIRMWARE
#define ISP_FIRMWARE_1000
#define ISP_FIRMWARE_2200
#endif

#if	defined(ISP_FIRMWARE_1000)
#include <dev/microcode/isp/asm_sbus.h>
#else
#define	ISP_1000_RISC_CODE	NULL
#endif

#if	defined(ISP_FIRMWARE_2200)
extern const u_int16_t isp_2200_risc_code[];
#define	ISP_2200_RISC_CODE	(u_int16_t *) isp_2200_risc_code
#else
#define	ISP_2200_RISC_CODE	NULL
#endif

#include <dev/sbus/sbusvar.h>

static int isp_sbus_intr(void *);
static int
isp_sbus_rd_isr(struct ispsoftc *, u_int32_t *, u_int16_t *, u_int16_t *);
static int
isp_sbus_rd_isr_2200(struct ispsoftc *, u_int32_t *, u_int16_t *, u_int16_t *);
static u_int32_t isp_sbus_rd_reg(struct ispsoftc *, int);
static void isp_sbus_wr_reg (struct ispsoftc *, int, u_int32_t);
static u_int32_t isp_sbus_rd_reg_2200(struct ispsoftc *, int);
static void isp_sbus_wr_reg_2200(struct ispsoftc *, int, u_int32_t);
static int isp_sbus_mbxdma(struct ispsoftc *);
static int isp_sbus_dmasetup(struct ispsoftc *, XS_T *, ispreq_t *, u_int32_t *,
    u_int32_t);
static void isp_sbus_dmateardown(struct ispsoftc *, XS_T *, u_int32_t);

static struct ispmdvec mdvec = {
	isp_sbus_rd_isr,
	isp_sbus_rd_reg,
	isp_sbus_wr_reg,
	isp_sbus_mbxdma,
	isp_sbus_dmasetup,
	isp_sbus_dmateardown,
	NULL,
	NULL,
	NULL,
	ISP_1000_RISC_CODE
};

static struct ispmdvec mdvec_2200 = {
	isp_sbus_rd_isr_2200,
	isp_sbus_rd_reg_2200,
	isp_sbus_wr_reg_2200,
	isp_sbus_mbxdma,
	isp_sbus_dmasetup,
	isp_sbus_dmateardown,
	NULL,
	NULL,
	NULL,
	ISP_2200_RISC_CODE
};

struct isp_sbussoftc {
	struct ispsoftc	sbus_isp;
	sdparam		sbus_dev;
	bus_space_tag_t	sbus_bustag;
	bus_space_handle_t sbus_reg;
	int		sbus_node;
	int		sbus_pri;
	struct ispmdvec	sbus_mdvec;
	bus_dmamap_t	*sbus_dmamap;
	int16_t		sbus_poff[_NREG_BLKS];
};


static int isp_match(struct device *, void *, void *);
static void isp_sbus_attach(struct device *, struct device *, void *);
struct cfattach isp_sbus_ca = {
	sizeof (struct isp_sbussoftc), isp_match, isp_sbus_attach
};

static int
isp_match(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	int rv;
#ifdef DEBUG
	static int oneshot = 1;
#endif
	struct sbus_attach_args *sa = aux;

	rv = (strcmp(cf->cf_driver->cd_name, sa->sa_name) == 0 ||
		strcmp("PTI,ptisp", sa->sa_name) == 0 ||
		strcmp("ptisp", sa->sa_name) == 0 ||
		strcmp("SUNW,isp", sa->sa_name) == 0 ||
		strcmp("SUNW,qlc", sa->sa_name) == 0 ||
		strcmp("QLGC,isp", sa->sa_name) == 0 ||
		strcmp("QLGC,qla", sa->sa_name) == 0);
#ifdef DEBUG
	if (rv && oneshot) {
		oneshot = 0;
		printf("QLogic ISP Driver, OpenBSD (sbus) Platform Version "
		    "%d.%d Core Version %d.%d\n",
		    ISP_PLATFORM_VERSION_MAJOR, ISP_PLATFORM_VERSION_MINOR,
		    ISP_CORE_VERSION_MAJOR, ISP_CORE_VERSION_MINOR);
	}
#endif
	return (rv);
}


static void
isp_sbus_attach(struct device *parent, struct device *self, void *aux)
{
	int freq, ispburst, sbusburst;
	struct sbus_attach_args *sa = aux;
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) self;
	struct ispsoftc *isp = &sbc->sbus_isp;

	printf(": %s\n", sa->sa_name);

	sbc->sbus_bustag = sa->sa_bustag;
	if (sa->sa_nintr != 0)
		sbc->sbus_pri = sa->sa_pri;
	sbc->sbus_mdvec = mdvec;

	if (sa->sa_npromvaddrs != 0) {
		if (bus_space_map(sa->sa_bustag, sa->sa_promvaddrs[0],
		    sa->sa_size,
		    BUS_SPACE_MAP_PROMADDRESS | BUS_SPACE_MAP_LINEAR,
		    &sbc->sbus_reg) == 0) {
			printf("%s: cannot map registers\n", self->dv_xname);
			return;
		}
	} else {
		if (sbus_bus_map(sa->sa_bustag, sa->sa_slot, sa->sa_offset,
				 sa->sa_size, BUS_SPACE_MAP_LINEAR, 0,
				 &sbc->sbus_reg) != 0) {
			printf("%s: cannot map registers\n", self->dv_xname);
			return;
		}
	}
	sbc->sbus_node = sa->sa_node;

	freq = getpropint(sa->sa_node, "clock-frequency", 0);
	if (freq) {
		/*
		 * Convert from HZ to MHz, rounding up.
		 */
		freq = (freq + 500000)/1000000;
#if	0
		printf("%s: %d MHz\n", self->dv_xname, freq);
#endif
	}
	sbc->sbus_mdvec.dv_clock = freq;

	DEFAULT_IID(isp) = getpropint(sa->sa_node, "scsi-initiator-id", 7);

	/*
	 * Now figure out what the proper burst sizes, etc., to use.
	 * Unfortunately, there is no ddi_dma_burstsizes here which
	 * walks up the tree finding the limiting burst size node (if
	 * any).
	 */
	sbusburst = ((struct sbus_softc *)parent)->sc_burst;
	if (sbusburst == 0)
		sbusburst = SBUS_BURST_32 - 1;
	ispburst = getpropint(sa->sa_node, "burst-sizes", -1);
	if (ispburst == -1) {
		ispburst = sbusburst;
	}
	ispburst &= sbusburst;
	ispburst &= ~(1 << 7);
	ispburst &= ~(1 << 6);
	sbc->sbus_mdvec.dv_conf1 =  0;
	if (ispburst & (1 << 5)) {
		sbc->sbus_mdvec.dv_conf1 = BIU_SBUS_CONF1_FIFO_32;
	} else if (ispburst & (1 << 4)) {
		sbc->sbus_mdvec.dv_conf1 = BIU_SBUS_CONF1_FIFO_16;
	} else if (ispburst & (1 << 3)) {
		sbc->sbus_mdvec.dv_conf1 =
		    BIU_SBUS_CONF1_BURST8 | BIU_SBUS_CONF1_FIFO_8;
	}
	if (sbc->sbus_mdvec.dv_conf1) {
		sbc->sbus_mdvec.dv_conf1 |= BIU_BURST_ENABLE;
	}

	/*
	 * Some early versions of the PTI SBus adapter
	 * would fail in trying to download (via poking)
	 * FW. We give up on them.
	 */
	if (strcmp("PTI,ptisp", sa->sa_name) == 0 ||
	    strcmp("ptisp", sa->sa_name) == 0) {
		sbc->sbus_mdvec.dv_ispfw = NULL;
	}

	isp->isp_mdvec = &sbc->sbus_mdvec;
	isp->isp_bustype = ISP_BT_SBUS;
	isp->isp_type = ISP_HA_SCSI_UNKNOWN;
	isp->isp_param = &sbc->sbus_dev;
	isp->isp_dmatag = sa->sa_dmatag;
	MEMZERO(isp->isp_param, sizeof (sdparam));

	sbc->sbus_poff[BIU_BLOCK >> _BLK_REG_SHFT] = BIU_REGS_OFF;
	sbc->sbus_poff[MBOX_BLOCK >> _BLK_REG_SHFT] = SBUS_MBOX_REGS_OFF;
	sbc->sbus_poff[SXP_BLOCK >> _BLK_REG_SHFT] = SBUS_SXP_REGS_OFF;
	sbc->sbus_poff[RISC_BLOCK >> _BLK_REG_SHFT] = SBUS_RISC_REGS_OFF;
	sbc->sbus_poff[DMA_BLOCK >> _BLK_REG_SHFT] = DMA_REGS_OFF;

	if (strcmp("SUNW,qlc", sa->sa_name) == 0 ||
	    strcmp("QLGC,qla", sa->sa_name) == 0) {
		isp->isp_mdvec = &mdvec_2200;
		isp->isp_bustype = ISP_BT_PCI;
		isp->isp_type = ISP_HA_FC_2200;
		isp->isp_param = malloc(sizeof(fcparam), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (isp->isp_param == NULL) {
			printf("%s: no mem for sdparam table\n",
			    self->dv_xname);
			return;
		}
		sbc->sbus_poff[BIU_BLOCK >> _BLK_REG_SHFT] =
		    0x100 + BIU_REGS_OFF;
		sbc->sbus_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =
		    0x100 + PCI_MBOX_REGS2100_OFF;
		sbc->sbus_poff[SXP_BLOCK >> _BLK_REG_SHFT] =
		    0x100 + PCI_SXP_REGS_OFF;
		sbc->sbus_poff[RISC_BLOCK >> _BLK_REG_SHFT] =
		    0x100 + PCI_RISC_REGS_OFF;
		sbc->sbus_poff[DMA_BLOCK >> _BLK_REG_SHFT] =
		    0x100 + DMA_REGS_OFF;
	}

	/* Establish interrupt channel */
	bus_intr_establish(sbc->sbus_bustag, sbc->sbus_pri, IPL_BIO, 0,
	    isp_sbus_intr, sbc, self->dv_xname);

	/*
	 * Set up logging levels.
	 */
#ifdef	ISP_LOGDEFAULT
	isp->isp_dblev = ISP_LOGDEFAULT;
#else
	isp->isp_dblev = ISP_LOGWARN|ISP_LOGERR;
#if 0
	isp->isp_dblev |= ISP_LOGDEBUG1|ISP_LOGDEBUG2;
#endif
#ifdef	DEBUG
	isp->isp_dblev |= ISP_LOGDEBUG0|ISP_LOGCONFIG|ISP_LOGINFO;
#endif
#endif

	isp->isp_confopts = self->dv_cfdata->cf_flags;
	isp->isp_role = ISP_DEFAULT_ROLES;

	/*
	 * There's no tool on sparc to set NVRAM for ISPs, so ignore
	 * it if we don't need to read WWNs from it.
	 */
	if (IS_SCSI(isp))
	    isp->isp_confopts |= ISP_CFG_NONVRAM;

	ISP_LOCK(isp);
	isp->isp_osinfo.no_mbox_ints = 1;
	isp_reset(isp);
	if (isp->isp_state != ISP_RESETSTATE) {
		ISP_UNLOCK(isp);
		return;
	}
	ISP_ENABLE_INTS(isp);
	isp_init(isp);
	if (isp->isp_state != ISP_INITSTATE) {
		isp_uninit(isp);
		ISP_UNLOCK(isp);
		return;
	}

	/*
	 * do generic attach.
	 */
	ISP_UNLOCK(isp);
	isp_attach(isp);
	if (isp->isp_state != ISP_RUNSTATE) {
		ISP_LOCK(isp);
		isp_uninit(isp);
		ISP_UNLOCK(isp);
	}
}

static int
isp_sbus_intr(void *arg)
{
	u_int32_t isr;
	u_int16_t sema, mbox;
	struct ispsoftc *isp = arg;

	isp->isp_intcnt++;
	if (ISP_READ_ISR(isp, &isr, &sema, &mbox) == 0) {
		isp->isp_intbogus++;
		return (0);
	} else {
		isp->isp_osinfo.onintstack = 1;
		isp_intr(isp, isr, sema, mbox);
		isp->isp_osinfo.onintstack = 0;
		return (1);
	}
}

#define	IspVirt2Off(a, x)	\
	(((struct isp_sbussoftc *)a)->sbus_poff[((x) & _BLK_REG_MASK) >> \
	_BLK_REG_SHFT] + ((x) & 0xff))

#define	BXR2(sbc, off)		\
	bus_space_read_2(sbc->sbus_bustag, sbc->sbus_reg, off)

static int
isp_sbus_rd_isr(struct ispsoftc *isp, u_int32_t *isrp,
    u_int16_t *semap, u_int16_t *mbp)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	u_int16_t isr, sema;

	isr = BXR2(sbc, IspVirt2Off(isp, BIU_ISR));
	sema = BXR2(sbc, IspVirt2Off(isp, BIU_SEMA));
	isp_prt(isp, ISP_LOGDEBUG3, "ISR 0x%x SEMA 0x%x", isr, sema);
	isr &= INT_PENDING_MASK(isp);
	sema &= BIU_SEMA_LOCK;
	if (isr == 0 && sema == 0) {
		return (0);
	}
	*isrp = isr;
	if ((*semap = sema) != 0) {
		*mbp = BXR2(sbc, IspVirt2Off(isp, OUTMAILBOX0));
	}
	return (1);
}

static int
isp_sbus_rd_isr_2200(struct ispsoftc *isp, u_int32_t *isrp,
    u_int16_t *semap, u_int16_t *mbp)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	u_int16_t isr, sema;

	isr = letoh16(BXR2(sbc, IspVirt2Off(isp, BIU_ISR)));
	sema = letoh16(BXR2(sbc, IspVirt2Off(isp, BIU_SEMA)));
	isp_prt(isp, ISP_LOGDEBUG3, "ISR 0x%x SEMA 0x%x", isr, sema);
	isr &= INT_PENDING_MASK(isp);
	sema &= BIU_SEMA_LOCK;
	if (isr == 0 && sema == 0) {
		return (0);
	}
	*isrp = isr;
	if ((*semap = sema) != 0) {
		*mbp = letoh16(BXR2(sbc, IspVirt2Off(isp, OUTMAILBOX0)));
	}
	return (1);
}

static u_int32_t
isp_sbus_rd_reg(struct ispsoftc *isp, int regoff)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	int offset = sbc->sbus_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	return (bus_space_read_2(sbc->sbus_bustag, sbc->sbus_reg, offset));
}

static void
isp_sbus_wr_reg(struct ispsoftc *isp, int regoff, u_int32_t val)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	int offset = sbc->sbus_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	bus_space_write_2(sbc->sbus_bustag, sbc->sbus_reg, offset, val);
}

static u_int32_t
isp_sbus_rd_reg_2200(struct ispsoftc *isp, int regoff)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	int offset = sbc->sbus_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	return (letoh16(bus_space_read_2(sbc->sbus_bustag, sbc->sbus_reg, offset)));
}

static void
isp_sbus_wr_reg_2200(struct ispsoftc *isp, int regoff, u_int32_t val)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	int offset = sbc->sbus_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];
	offset += (regoff & 0xff);
	bus_space_write_2(sbc->sbus_bustag, sbc->sbus_reg, offset, htole16(val));
}

static int
isp_sbus_mbxdma(struct ispsoftc *isp)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	bus_dma_segment_t seg;
	bus_addr_t addr;
	bus_size_t len;
	caddr_t base;
	size_t n;
	int rs, i, progress;

	if (isp->isp_rquest_dma)
		return (0);

	n = isp->isp_maxcmds * sizeof (XS_T *);
	isp->isp_xflist = (XS_T **) malloc(n, M_DEVBUF, M_WAITOK | M_ZERO);
	if (isp->isp_xflist == NULL) {
		isp_prt(isp, ISP_LOGERR, "cannot alloc xflist array");
		return (1);
	}

	n = sizeof (bus_dmamap_t) * isp->isp_maxcmds;
	sbc->sbus_dmamap = (bus_dmamap_t *) malloc(n, M_DEVBUF, M_WAITOK);
	if (sbc->sbus_dmamap == NULL) {
		free(isp->isp_xflist, M_DEVBUF, 0);
		isp->isp_xflist = NULL;
		isp_prt(isp, ISP_LOGERR, "cannot alloc dmamap array");
		return (1);
	}
	for (i = 0; i < isp->isp_maxcmds; i++) {
		/* Allocate a DMA handle */
		if (bus_dmamap_create(isp->isp_dmatag, MAXPHYS, 1, MAXPHYS, 0,
		    BUS_DMA_NOWAIT, &sbc->sbus_dmamap[i]) != 0) {
			isp_prt(isp, ISP_LOGERR, "cmd DMA maps create error");
			break;
		}
	}
	if (i < isp->isp_maxcmds) {
		while (--i >= 0) {
			bus_dmamap_destroy(isp->isp_dmatag,
			    sbc->sbus_dmamap[i]);
		}
		free(isp->isp_xflist, M_DEVBUF, 0);
		free(sbc->sbus_dmamap, M_DEVBUF, 0);
		isp->isp_xflist = NULL;
		sbc->sbus_dmamap = NULL;
		return (1);
	}

	/*
	 * Allocate and map the request, result queues, plus FC scratch area.
	 */
	progress = 0;
	len = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));
	len += ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
	if (IS_FC(isp)) {
		len += ISP2100_SCRLEN;
	}
	if (bus_dmamem_alloc(isp->isp_dmatag, len, 0, 0, &seg, 1, &rs,
	    BUS_DMA_NOWAIT)) {
		goto dmafail;
	}
	progress++;
	if (bus_dmamem_map(isp->isp_dmatag, &seg, rs, len,
	    &base, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
		goto dmafail;
	}
	progress++;
	if (bus_dmamap_create(isp->isp_dmatag, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &isp->isp_cdmap) != 0) {
		goto dmafail;
	}
	progress++;
	if (bus_dmamap_load(isp->isp_dmatag, isp->isp_cdmap,
	    base, len, NULL, BUS_DMA_NOWAIT) != 0) {
		goto dmafail;
	}
	progress++;
	addr = isp->isp_cdmap->dm_segs[0].ds_addr;
	isp->isp_rquest_dma = addr;
	addr += ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));
	isp->isp_result_dma = addr;

	if (IS_FC(isp)) {
		addr += ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
		FCPARAM(isp)->isp_scdma = addr;

	}

	isp->isp_rquest = base;
	base += ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp));
	isp->isp_result = base;
	if (IS_FC(isp)) {
		base += ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
		FCPARAM(isp)->isp_scratch = base;
	}
	return (0);

dmafail:
	isp_prt(isp, ISP_LOGERR, "Mailbox DMA Setup Failure");

	if (progress >= 4) {
		bus_dmamap_unload(isp->isp_dmatag, isp->isp_cdmap);
	}
	if (progress >= 3) {
		bus_dmamap_destroy(isp->isp_dmatag, isp->isp_cdmap);
	}
	if (progress >= 2) {
		bus_dmamem_unmap(isp->isp_dmatag, isp->isp_rquest, len);
	}
	if (progress >= 1) {
		bus_dmamem_free(isp->isp_dmatag, &seg, rs);
	}

	for (i = 0; i < isp->isp_maxcmds; i++) {
		bus_dmamap_destroy(isp->isp_dmatag, sbc->sbus_dmamap[i]);
	}
	free(sbc->sbus_dmamap, M_DEVBUF, 0);
	free(isp->isp_xflist, M_DEVBUF, 0);
	isp->isp_xflist = NULL;
	sbc->sbus_dmamap = NULL;
	return (1);
}

/*
 * Map a DMA request.
 * We're guaranteed that rq->req_handle is a value from 1 to isp->isp_maxcmds.
 */

static int
isp_sbus_dmasetup(struct ispsoftc *isp, XS_T *xs, ispreq_t *rq,
    u_int32_t *nxtip, u_int32_t optr)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	bus_dmamap_t dmap;
	u_int16_t nxti = *nxtip;
	ispreq_t *qep;
	int segcnt, seg, error, ovseg, seglim, drq;

	qep = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, isp->isp_reqidx);
	dmap = sbc->sbus_dmamap[isp_handle_index(rq->req_handle)];
	if (xs->datalen == 0) {
		rq->req_seg_count = 1;
		goto mbxsync;
	}

	if (xs->flags & SCSI_DATA_IN) {
		drq = REQFLAG_DATA_IN;
	} else {
		drq = REQFLAG_DATA_OUT;
	}

	if (IS_FC(isp)) {
		seglim = ISP_RQDSEG_T2;
		((ispreqt2_t *)rq)->req_totalcnt = xs->datalen;
		((ispreqt2_t *)rq)->req_flags |= drq;
	} else {
		rq->req_flags |= drq;
		if (XS_CDBLEN(xs) > 12)
			seglim = 0;
		else
			seglim = ISP_RQDSEG;
	}
	error = bus_dmamap_load(isp->isp_dmatag, dmap, xs->data, xs->datalen,
	    NULL, (xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT :
	    BUS_DMA_WAITOK | BUS_DMA_STREAMING);
	if (error) {
		XS_SETERR(xs, HBA_BOTCH);
		return (CMD_COMPLETE);
	}

	segcnt = dmap->dm_nsegs;

	isp_prt(isp, ISP_LOGDEBUG2, "%d byte %s %p in %d segs",
	    xs->datalen, (xs->flags & SCSI_DATA_IN)? "read to" :
	    "write from", xs->data, segcnt);

	for (seg = 0, rq->req_seg_count = 0;
	     seg < segcnt && rq->req_seg_count < seglim;
	     seg++, rq->req_seg_count++) {
		if (isp->isp_type & ISP_HA_FC) {
			ispreqt2_t *rq2 = (ispreqt2_t *)rq;
			rq2->req_dataseg[rq2->req_seg_count].ds_count =
			    dmap->dm_segs[seg].ds_len;
			rq2->req_dataseg[rq2->req_seg_count].ds_base =
			    dmap->dm_segs[seg].ds_addr;
		} else {
			rq->req_dataseg[rq->req_seg_count].ds_count =
			    dmap->dm_segs[seg].ds_len;
			rq->req_dataseg[rq->req_seg_count].ds_base =
			    dmap->dm_segs[seg].ds_addr;
		}
		isp_prt(isp, ISP_LOGDEBUG2, "seg0.[%d]={0x%lx,%lu}",
		    rq->req_seg_count, (long) dmap->dm_segs[seg].ds_addr,
		    (unsigned long) dmap->dm_segs[seg].ds_len);
	}

	if (seg == segcnt) {
		goto dmasync;
	}

	do {
		u_int16_t onxti;
		ispcontreq_t *crq, *cqe, local;

		crq = &local;

		cqe = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, nxti);
		onxti = nxti;
		nxti = ISP_NXT_QENTRY(onxti, RQUEST_QUEUE_LEN(isp));
		if (nxti == optr) {
			isp_prt(isp, ISP_LOGDEBUG0, "Request Queue Overflow++");
			bus_dmamap_unload(isp->isp_dmatag, dmap);
			XS_SETERR(xs, HBA_BOTCH);
			return (CMD_EAGAIN);
		}
		rq->req_header.rqs_entry_count++;
		bzero((void *)crq, sizeof (*crq));
		crq->req_header.rqs_entry_count = 1;
		crq->req_header.rqs_entry_type = RQSTYPE_DATASEG;

		for (ovseg = 0; seg < segcnt && ovseg < ISP_CDSEG;
		    rq->req_seg_count++, seg++, ovseg++) {
			crq->req_dataseg[ovseg].ds_count =
			    dmap->dm_segs[seg].ds_len;
			crq->req_dataseg[ovseg].ds_base =
			    dmap->dm_segs[seg].ds_addr;
			isp_prt(isp, ISP_LOGDEBUG2, "seg%d.[%d]={0x%lx,%lu}",
			    rq->req_header.rqs_entry_count - 1,
			    rq->req_seg_count, (long)dmap->dm_segs[seg].ds_addr,
			    (unsigned long) dmap->dm_segs[seg].ds_len);
		}
		isp_put_cont_req(isp, crq, cqe);
		MEMORYBARRIER(isp, SYNC_REQUEST, onxti, QENTRY_LEN);
	} while (seg < segcnt);

dmasync:
	bus_dmamap_sync(isp->isp_dmatag, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN) ?  BUS_DMASYNC_PREREAD :
	    BUS_DMASYNC_PREWRITE);

mbxsync:
	switch (rq->req_header.rqs_entry_type) {
	case RQSTYPE_REQUEST:
		isp_put_request(isp, rq, qep);
		break;
	case RQSTYPE_CMDONLY:
		isp_put_extended_request(isp, (ispextreq_t *)rq,
		    (ispextreq_t *)qep);
		break;
	case RQSTYPE_T2RQS:
		if (FCPARAM(isp)->isp_2klogin) {
			isp_put_request_t2e(isp,
			    (ispreqt2e_t *) rq, (ispreqt2e_t *) qep);
		} else {
			isp_put_request_t2(isp,
			    (ispreqt2_t *) rq, (ispreqt2_t *) qep);
		}
		break;
	case RQSTYPE_T3RQS:
		if (FCPARAM(isp)->isp_2klogin) {
			isp_put_request_t3e(isp,
			    (ispreqt3e_t *) rq, (ispreqt3e_t *) qep);
			break;
		}
		/* FALLTHROUGH */
	case RQSTYPE_A64:
		isp_put_request_t3(isp, (ispreqt3_t *) rq, (ispreqt3_t *) qep);
		break;
	}
	*nxtip = nxti;
	return (CMD_QUEUED);
}

static void
isp_sbus_dmateardown(struct ispsoftc *isp, XS_T *xs, u_int32_t handle)
{
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *)isp;
	bus_dmamap_t dmap = sbc->sbus_dmamap[isp_handle_index(handle)];
	bus_dmamap_sync(isp->isp_dmatag, dmap, 0, dmap->dm_mapsize,
	    (xs->flags & SCSI_DATA_IN)?
	    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(isp->isp_dmatag, dmap);
}
@


1.21
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.20 2014/02/14 14:00:08 jmatthew Exp $	*/
@


1.20
log
@florian@@ noticed that I missed some isp24xx code in the sbus glue
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.19 2014/02/10 22:41:27 jmatthew Exp $	*/
d465 1
a465 1
		free(isp->isp_xflist, M_DEVBUF);
d483 2
a484 2
		free(isp->isp_xflist, M_DEVBUF);
		free(sbc->sbus_dmamap, M_DEVBUF);
d558 2
a559 2
	free(sbc->sbus_dmamap, M_DEVBUF);
	free(isp->isp_xflist, M_DEVBUF);
@


1.19
log
@Build isp2xxx firmware into separate object files so we only include
one copy when both isp(4) and qla(4) are enabled.  This is a temporary
measure until qla(4) takes over completely.

looked at by miod@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.18 2011/04/22 23:19:55 deraadt Exp $	*/
a708 3
		break;
	case RQSTYPE_T7RQS:
		isp_put_request_t7(isp, (ispreqt7_t *) rq, (ispreqt7_t *) qep);
@


1.18
log
@Turning on SCSIDEBUG (for debugging other drivers, of course) should
not make these drivers spew millions of lines of output.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.17 2009/09/02 16:05:16 kettenis Exp $	*/
d59 1
a60 1
#include <dev/microcode/isp/asm_2200.h>
@


1.17
log
@Remove some out-of-date comments that are no longer present in the NetBSD
tree, and s/NetBSD/OpenBSD/ in a debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.16 2009/09/02 15:47:37 kettenis Exp $	*/
d290 1
a290 1
#ifdef	SCSIDEBUG
@


1.16
log
@Bring over some more glue from isp_pci.c; makes ISP2200 SBus FC cards actually
work.  Tested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.15 2009/09/01 20:49:24 kettenis Exp $	*/
a2 29

/*
 * This driver, which is contained in NetBSD in the files:
 *
 *	sys/dev/ic/isp.c
 *	sys/dev/ic/isp_inline.h
 *	sys/dev/ic/isp_netbsd.c
 *	sys/dev/ic/isp_netbsd.h
 *	sys/dev/ic/isp_target.c
 *	sys/dev/ic/isp_target.h
 *	sys/dev/ic/isp_tpublic.h
 *	sys/dev/ic/ispmbox.h
 *	sys/dev/ic/ispreg.h
 *	sys/dev/ic/ispvar.h
 *	sys/microcode/isp/asm_sbus.h
 *	sys/microcode/isp/asm_1040.h
 *	sys/microcode/isp/asm_1080.h
 *	sys/microcode/isp/asm_12160.h
 *	sys/microcode/isp/asm_2100.h
 *	sys/microcode/isp/asm_2200.h
 *	sys/pci/isp_pci.c
 *	sys/sbus/isp_sbus.c
 *
 * Is being actively maintained by Matthew Jacob (mjacob@@netbsd.org).
 * This driver also is shared source with FreeBSD, OpenBSD, Linux, Solaris,
 * Linux versions. This tends to be an interesting maintenance problem.
 *
 * Please coordinate with Matthew Jacob on changes you wish to make here.
 */
d146 1
a146 1
		printf("QLogic ISP Driver, NetBSD (sbus) Platform Version "
@


1.15
log
@Add initial support for ISP2200 SBus FC cards.  Doesn't quite work yet,
but it is an important first step.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.14 2009/06/24 11:38:40 deraadt Exp $	*/
d605 1
d607 1
a607 2
	int cansleep = (xs->flags & SCSI_NOSLEEP) == 0;
	int in = (xs->flags & SCSI_DATA_IN) != 0;
d610 1
d616 21
a636 8
	dmap = sbc->sbus_dmamap[isp_handle_index(rq->req_handle)];
	if (dmap->dm_nsegs != 0) {
		panic("%s: dma map already allocated", isp->isp_name);
		/* NOTREACHED */
	}
	if (bus_dmamap_load(isp->isp_dmatag, dmap, xs->data, xs->datalen,
	    NULL, (cansleep ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT) |
	    BUS_DMA_STREAMING) != 0) {
d641 1
a641 2
	bus_dmamap_sync(isp->isp_dmatag, dmap, 0, xs->datalen,
	    in? BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
d643 26
a668 4
	if (in) {
		rq->req_flags |= REQFLAG_DATA_IN;
	} else {
		rq->req_flags |= REQFLAG_DATA_OUT;
d671 1
a671 1
	if (XS_CDBLEN(xs) > 12) {
d673 1
a673 1
		ispcontreq_t local, *crq = &local, *cqe;
d675 6
a680 4
		onxti = *nxtip;
		cqe = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, onxti);
		*nxtip = ISP_NXT_QENTRY(onxti, RQUEST_QUEUE_LEN(isp));
		if (*nxtip == optr) {
d686 2
a687 2
		rq->req_seg_count = 2;
		MEMZERO((void *)crq, sizeof (*crq));
d689 13
a701 3
		crq->req_header.rqs_entry_type = RQSTYPE_DATASEG;  
		crq->req_dataseg[0].ds_count = xs->datalen;
		crq->req_dataseg[0].ds_base = dmap->dm_segs[0].ds_addr;
d704 6
a709 5
	} else {
		rq->req_seg_count = 1;
		rq->req_dataseg[0].ds_count = xs->datalen;
		rq->req_dataseg[0].ds_base = dmap->dm_segs[0].ds_addr;
	}
d712 2
a713 4
	if (XS_CDBLEN(xs) > 12) {
		isp_put_extended_request(isp,
		    (ispextreq_t *)rq, (ispextreq_t *) qep);
	} else {
d715 27
d743 1
d750 4
a753 11
	struct isp_sbussoftc *sbc = (struct isp_sbussoftc *) isp;
	bus_dmamap_t dmap;

	dmap = sbc->sbus_dmamap[isp_handle_index(handle)];

	if (dmap->dm_nsegs == 0) {
		panic("%s: dma map not already allocated", isp->isp_name);
		/* NOTREACHED */
	}
	bus_dmamap_sync(isp->isp_dmatag, dmap, 0,
	    xs->datalen, (xs->flags & SCSI_DATA_IN)?
@


1.14
log
@for the isp(4) driver, invert the meaning of the options which pull
firmwares into the smaller (and larger) media
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.13 2009/06/24 11:00:53 krw Exp $	*/
d78 1
d87 7
d99 2
d103 2
d120 14
a133 1
	(u_int16_t *) ISP_1000_RISC_CODE
d169 3
a171 1
		strcmp("QLGC,isp", sa->sa_name) == 0);
d284 24
d331 2
a332 1
	 * There's no tool on sparc to set NVRAM for ISPs, so ignore it.
d334 3
a336 1
	isp->isp_confopts |= ISP_CFG_NONVRAM;
d412 22
d452 18
d520 1
a520 1
	 * Allocate and map the request and response queues
d525 3
d553 6
d562 4
@


1.13
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.12 2008/06/01 15:49:25 kettenis Exp $	*/
d75 6
a80 1
#if	defined(ISP_COMPILE_FW) || defined(ISP_COMPILE_1000_FW)
d82 2
d85 1
a96 4

#ifndef	ISP_1000_RISC_CODE
#define	ISP_1000_RISC_CODE	NULL
#endif
@


1.12
log
@Make SCSI isp(4) use the same SCSI initiator ID as the prom on sparc/sparc64.

ok marco@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.11 2008/01/21 20:00:33 sobrado Exp $	*/
d82 3
a84 3
isp_sbus_rd_isr(struct ispsoftc *, u_int16_t *, u_int16_t *, u_int16_t *);
static u_int16_t isp_sbus_rd_reg(struct ispsoftc *, int);
static void isp_sbus_wr_reg (struct ispsoftc *, int, u_int16_t);
d86 3
a88 3
static int isp_sbus_dmasetup(struct ispsoftc *, XS_T *, ispreq_t *, u_int16_t *,
    u_int16_t);
static void isp_sbus_dmateardown(struct ispsoftc *, XS_T *, u_int16_t);
d286 1
a286 1
	ENABLE_INTS(isp);
d309 2
a310 1
	u_int16_t isr, sema, mbox;
d333 1
a333 1
isp_sbus_rd_isr(struct ispsoftc *isp, u_int16_t *isrp,
d354 1
a354 1
static u_int16_t
d364 1
a364 1
isp_sbus_wr_reg(struct ispsoftc *isp, int regoff, u_int16_t val)
d376 4
a379 2
	bus_dma_segment_t reqseg, rspseg;
	int reqrs, rsprs, i, progress;
d381 1
a381 1
	bus_size_t len;
d426 2
a427 1
	if (bus_dmamem_alloc(isp->isp_dmatag, len, 0, 0, &reqseg, 1, &reqrs,
d432 2
a433 2
	if (bus_dmamem_map(isp->isp_dmatag, &reqseg, reqrs, len,
	    (caddr_t *)&isp->isp_rquest, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
d438 1
a438 19
	    &isp->isp_rqdmap) != 0) {
		goto dmafail;
	}
	progress++;
	if (bus_dmamap_load(isp->isp_dmatag, isp->isp_rqdmap,
	    isp->isp_rquest, len, NULL, BUS_DMA_NOWAIT) != 0) {
		goto dmafail;
	}
	progress++;
	isp->isp_rquest_dma = isp->isp_rqdmap->dm_segs[0].ds_addr;

	len = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp));
	if (bus_dmamem_alloc(isp->isp_dmatag, len, 0, 0, &rspseg, 1, &rsprs,
	    BUS_DMA_NOWAIT)) {
		goto dmafail;
	}
	progress++;
	if (bus_dmamem_map(isp->isp_dmatag, &rspseg, rsprs, len,
	    (caddr_t *)&isp->isp_result, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {
d442 2
a443 2
	if (bus_dmamap_create(isp->isp_dmatag, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &isp->isp_rsdmap) != 0) {
d447 8
a454 6
	if (bus_dmamap_load(isp->isp_dmatag, isp->isp_rsdmap,
	    isp->isp_result, len, NULL, BUS_DMA_NOWAIT) != 0) {
		goto dmafail;
	}
	isp->isp_result_dma = isp->isp_rsdmap->dm_segs[0].ds_addr;

a459 14
	if (progress >= 8) {
		bus_dmamap_unload(isp->isp_dmatag, isp->isp_rsdmap);
	}
	if (progress >= 7) {
		bus_dmamap_destroy(isp->isp_dmatag, isp->isp_rsdmap);
	}
	if (progress >= 6) {
		bus_dmamem_unmap(isp->isp_dmatag,
		    isp->isp_result, ISP_QUEUE_SIZE(RESULT_QUEUE_LEN(isp)));
	}
	if (progress >= 5) {
		bus_dmamem_free(isp->isp_dmatag, &rspseg, rsprs);
	}

d461 1
a461 1
		bus_dmamap_unload(isp->isp_dmatag, isp->isp_rqdmap);
d464 1
a464 1
		bus_dmamap_destroy(isp->isp_dmatag, isp->isp_rqdmap);
d467 1
a467 2
		bus_dmamem_unmap(isp->isp_dmatag,
		    isp->isp_rquest, ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN(isp)));
d470 1
a470 1
		bus_dmamem_free(isp->isp_dmatag, &reqseg, reqrs);
d490 1
a490 1
    u_int16_t *nxtip, u_int16_t optr)
d563 1
a563 1
isp_sbus_dmateardown(struct ispsoftc *isp, XS_T *xs, u_int16_t handle)
@


1.11
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.10 2007/09/11 13:39:34 gilles Exp $	*/
a78 1
#include <sys/reboot.h>
d198 2
@


1.10
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.9 2007/09/10 19:49:31 gilles Exp $	*/
d33 1
a33 1
 * SBus specific probe and attach routines for Qlogic ISP SCSI adapters.
d145 1
a145 1
		printf("Qlogic ISP Driver, NetBSD (sbus) Platform Version "
@


1.9
log
@more MALLOC/FREE -> malloc/free and M_ZERO changes

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.8 2006/06/02 20:00:56 miod Exp $	*/
d383 1
a383 1
	isp->isp_xflist = (XS_T **) malloc(n, M_DEVBUF, M_WAITOK|M_ZERO);
@


1.8
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.7 2005/03/02 17:10:03 miod Exp $	*/
d383 1
a383 1
	isp->isp_xflist = (XS_T **) malloc(n, M_DEVBUF, M_WAITOK);
d388 1
a388 1
	MEMZERO(isp->isp_xflist, n);
@


1.7
log
@Dmesg nit
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.6 2003/06/24 21:54:38 henric Exp $	*/
a109 1
	struct sbusdev	sbus_sd;
a254 1
	sbus_establish(&sbc->sbus_sd, &sbc->sbus_isp.isp_osinfo._dev);
@


1.6
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.5 2003/02/17 01:29:21 henric Exp $	*/
d164 1
a164 1
	printf(" for %s\n", sa->sa_name);
@


1.5
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.4 2002/10/12 01:09:44 krw Exp $	*/
d255 1
a255 1
	    isp_sbus_intr, sbc);
@


1.4
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.3 2002/05/17 01:19:49 mjacob Exp $	*/
d172 7
a178 1
		sbc->sbus_reg = (bus_space_handle_t)sa->sa_promvaddrs[0];
@


1.3
log
@Handle the removal of 'const' from structure definition.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.2 2001/12/14 02:51:12 mjacob Exp $	*/
d528 1
a528 1
		panic("%s: dma map already allocated\n", isp->isp_name);
d593 1
a593 1
		panic("%s: dma map not already allocated\n", isp->isp_name);
@


1.2
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.1 2001/10/06 02:03:24 jason Exp $	*/
d105 1
a105 1
	ISP_1000_RISC_CODE
a600 1
/* %W% */
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.2 2001/12/14 02:51:12 mjacob Exp $	*/
d105 1
a105 1
	(u_int16_t *) ISP_1000_RISC_CODE
d601 1
@


1.2.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isp_sbus.c,v 1.2.2.1 2002/06/11 03:42:29 art Exp $	*/
d528 1
a528 1
		panic("%s: dma map already allocated", isp->isp_name);
d593 1
a593 1
		panic("%s: dma map not already allocated", isp->isp_name);
@


1.2.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d172 1
a172 7
		if (bus_space_map(sa->sa_bustag, sa->sa_promvaddrs[0],
		    sa->sa_size,
		    BUS_SPACE_MAP_PROMADDRESS | BUS_SPACE_MAP_LINEAR,
		    &sbc->sbus_reg) == 0) {
			printf("%s: cannot map registers\n", self->dv_xname);
			return;
		}
@


1.1
log
@add sbus frontend for isp
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a112 1
	bus_dma_tag_t	sbus_dmatag;
a117 2
	bus_dmamap_t	sbus_rquest_dmamap;
	bus_dmamap_t	sbus_result_dmamap;
a166 1
	sbc->sbus_dmatag = sa->sa_dmatag;
d238 2
a239 1
	bzero(isp->isp_param, sizeof (sdparam));
a305 1
	struct isp_sbussoftc *sbc = arg;
d307 6
a312 4
	bus_dmamap_sync(sbc->sbus_dmatag, sbc->sbus_result_dmamap, 0,
	    sbc->sbus_result_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
	if (ISP_READ_ISR(isp, &isr, &sema, &mbox)) {
		sbc->sbus_isp.isp_osinfo.onintstack = 1;
d314 1
a314 1
		sbc->sbus_isp.isp_osinfo.onintstack = 0;
a315 2
	} else {
		return (0);
a369 1
	bus_dma_tag_t dmatag = sbc->sbus_dmatag;
d384 1
a384 1
	bzero(isp->isp_xflist, n);
d395 1
a395 1
		if (bus_dmamap_create(dmatag, MAXPHYS, 1, MAXPHYS, 0,
d403 2
a404 1
			bus_dmamap_destroy(dmatag, sbc->sbus_dmamap[i]);
d418 1
a418 1
	if (bus_dmamem_alloc(dmatag, len, 0, 0, &reqseg, 1, &reqrs,
d423 1
a423 1
	if (bus_dmamem_map(dmatag, &reqseg, reqrs, len,
d428 2
a429 2
	if (bus_dmamap_create(dmatag, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &sbc->sbus_rquest_dmamap) != 0) {
d433 1
a433 1
	if (bus_dmamap_load(dmatag, sbc->sbus_rquest_dmamap,
d438 1
a438 1
	isp->isp_rquest_dma = sbc->sbus_rquest_dmamap->dm_segs[0].ds_addr;
d441 1
a441 1
	if (bus_dmamem_alloc(dmatag, len, 0, 0, &rspseg, 1, &rsprs,
d446 1
a446 1
	if (bus_dmamem_map(dmatag, &rspseg, rsprs, len,
d451 2
a452 2
	if (bus_dmamap_create(dmatag, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &sbc->sbus_result_dmamap) != 0) {
d456 1
a456 1
	if (bus_dmamap_load(dmatag, sbc->sbus_result_dmamap,
d460 1
a460 1
	isp->isp_result_dma = sbc->sbus_result_dmamap->dm_segs[0].ds_addr;
d468 1
a468 1
		bus_dmamap_unload(dmatag, sbc->sbus_result_dmamap);
d471 1
a471 1
		bus_dmamap_destroy(dmatag, sbc->sbus_result_dmamap);
d474 1
a474 1
		bus_dmamem_unmap(dmatag,
d478 1
a478 1
		bus_dmamem_free(dmatag, &rspseg, rsprs);
d482 1
a482 1
		bus_dmamap_unload(dmatag, sbc->sbus_rquest_dmamap);
d485 1
a485 1
		bus_dmamap_destroy(dmatag, sbc->sbus_rquest_dmamap);
d488 1
a488 1
		bus_dmamem_unmap(dmatag,
d492 1
a492 1
		bus_dmamem_free(dmatag, &reqseg, reqrs);
d496 1
a496 1
		bus_dmamap_destroy(dmatag, sbc->sbus_dmamap[i]);
d512 1
a512 1
    u_int16_t *iptrp, u_int16_t optr)
d516 1
a516 1
	ispcontreq_t *crq;
d520 1
d531 1
a531 1
	if (bus_dmamap_load(sbc->sbus_dmatag, dmap, xs->data, xs->datalen,
d538 1
a538 1
	bus_dmamap_sync(sbc->sbus_dmatag, dmap, 0, xs->datalen,
d548 7
a554 3
		crq = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, *iptrp);
		*iptrp = ISP_NXT_QENTRY(*iptrp, RQUEST_QUEUE_LEN(isp));
		if (*iptrp == optr) {
d556 1
a556 1
			bus_dmamap_unload(sbc->sbus_dmatag, dmap);
d561 1
a561 3
		rq->req_dataseg[0].ds_count = 0;
		rq->req_dataseg[0].ds_base =  0;
		bzero((void *)crq, sizeof (*crq));
d565 3
a567 2
		crq->req_dataseg[0].ds_base =  dmap->dm_segs[0].ds_addr;
		ISP_SBUSIFY_ISPHDR(isp, &crq->req_header)
d569 1
a571 1
		rq->req_seg_count = 1;
d575 6
a580 3
	ISP_SWIZZLE_REQUEST(isp, rq);
	bus_dmamap_sync(sbc->sbus_dmatag, sbc->sbus_rquest_dmamap, 0,
	     sbc->sbus_rquest_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);
d596 1
a596 1
	bus_dmamap_sync(sbc->sbus_dmatag, dmap, 0,
d599 1
a599 1
	bus_dmamap_unload(sbc->sbus_dmatag, dmap);
d601 1
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.1.4.2
log
@Merge in trunk
@
text
@d113 1
d119 2
d170 1
d242 1
a242 2
	isp->isp_dmatag = sa->sa_dmatag;
	MEMZERO(isp->isp_param, sizeof (sdparam));
d309 1
d311 4
a314 6
	isp->isp_intcnt++;
	if (ISP_READ_ISR(isp, &isr, &sema, &mbox) == 0) {
		isp->isp_intbogus++;
		return (0);
	} else {
		isp->isp_osinfo.onintstack = 1;
d316 1
a316 1
		isp->isp_osinfo.onintstack = 0;
d318 2
d374 1
d389 1
a389 1
	MEMZERO(isp->isp_xflist, n);
d400 1
a400 1
		if (bus_dmamap_create(isp->isp_dmatag, MAXPHYS, 1, MAXPHYS, 0,
d408 1
a408 2
			bus_dmamap_destroy(isp->isp_dmatag,
			    sbc->sbus_dmamap[i]);
d422 1
a422 1
	if (bus_dmamem_alloc(isp->isp_dmatag, len, 0, 0, &reqseg, 1, &reqrs,
d427 1
a427 1
	if (bus_dmamem_map(isp->isp_dmatag, &reqseg, reqrs, len,
d432 2
a433 2
	if (bus_dmamap_create(isp->isp_dmatag, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &isp->isp_rqdmap) != 0) {
d437 1
a437 1
	if (bus_dmamap_load(isp->isp_dmatag, isp->isp_rqdmap,
d442 1
a442 1
	isp->isp_rquest_dma = isp->isp_rqdmap->dm_segs[0].ds_addr;
d445 1
a445 1
	if (bus_dmamem_alloc(isp->isp_dmatag, len, 0, 0, &rspseg, 1, &rsprs,
d450 1
a450 1
	if (bus_dmamem_map(isp->isp_dmatag, &rspseg, rsprs, len,
d455 2
a456 2
	if (bus_dmamap_create(isp->isp_dmatag, len, 1, len, 0, BUS_DMA_NOWAIT,
	    &isp->isp_rsdmap) != 0) {
d460 1
a460 1
	if (bus_dmamap_load(isp->isp_dmatag, isp->isp_rsdmap,
d464 1
a464 1
	isp->isp_result_dma = isp->isp_rsdmap->dm_segs[0].ds_addr;
d472 1
a472 1
		bus_dmamap_unload(isp->isp_dmatag, isp->isp_rsdmap);
d475 1
a475 1
		bus_dmamap_destroy(isp->isp_dmatag, isp->isp_rsdmap);
d478 1
a478 1
		bus_dmamem_unmap(isp->isp_dmatag,
d482 1
a482 1
		bus_dmamem_free(isp->isp_dmatag, &rspseg, rsprs);
d486 1
a486 1
		bus_dmamap_unload(isp->isp_dmatag, isp->isp_rqdmap);
d489 1
a489 1
		bus_dmamap_destroy(isp->isp_dmatag, isp->isp_rqdmap);
d492 1
a492 1
		bus_dmamem_unmap(isp->isp_dmatag,
d496 1
a496 1
		bus_dmamem_free(isp->isp_dmatag, &reqseg, reqrs);
d500 1
a500 1
		bus_dmamap_destroy(isp->isp_dmatag, sbc->sbus_dmamap[i]);
d516 1
a516 1
    u_int16_t *nxtip, u_int16_t optr)
d520 1
a520 1
	ispreq_t *qep;
a523 1
	qep = (ispreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, isp->isp_reqidx);
d534 1
a534 1
	if (bus_dmamap_load(isp->isp_dmatag, dmap, xs->data, xs->datalen,
d541 1
a541 1
	bus_dmamap_sync(isp->isp_dmatag, dmap, 0, xs->datalen,
d551 3
a553 7
		u_int16_t onxti;
		ispcontreq_t local, *crq = &local, *cqe;

		onxti = *nxtip;
		cqe = (ispcontreq_t *) ISP_QUEUE_ENTRY(isp->isp_rquest, onxti);
		*nxtip = ISP_NXT_QENTRY(onxti, RQUEST_QUEUE_LEN(isp));
		if (*nxtip == optr) {
d555 1
a555 1
			bus_dmamap_unload(isp->isp_dmatag, dmap);
d560 3
a562 1
		MEMZERO((void *)crq, sizeof (*crq));
d566 2
a567 3
		crq->req_dataseg[0].ds_base = dmap->dm_segs[0].ds_addr;
		isp_put_cont_req(isp, crq, cqe);
		MEMORYBARRIER(isp, SYNC_REQUEST, onxti, QENTRY_LEN);
a568 1
		rq->req_seg_count = 1;
d571 1
d575 3
a577 6
	if (XS_CDBLEN(xs) > 12) {
		isp_put_extended_request(isp,
		    (ispextreq_t *)rq, (ispextreq_t *) qep);
	} else {
		isp_put_request(isp, rq, qep);
	}
d593 1
a593 1
	bus_dmamap_sync(isp->isp_dmatag, dmap, 0,
d596 1
a596 1
	bus_dmamap_unload(isp->isp_dmatag, dmap);
a597 1
/* %W% */
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d105 1
a105 1
	(u_int16_t *) ISP_1000_RISC_CODE
d172 1
a172 7
		if (bus_space_map(sa->sa_bustag, sa->sa_promvaddrs[0],
		    sa->sa_size,
		    BUS_SPACE_MAP_PROMADDRESS | BUS_SPACE_MAP_LINEAR,
		    &sbc->sbus_reg) == 0) {
			printf("%s: cannot map registers\n", self->dv_xname);
			return;
		}
d528 1
a528 1
		panic("%s: dma map already allocated", isp->isp_name);
d593 1
a593 1
		panic("%s: dma map not already allocated", isp->isp_name);
d601 1
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d255 1
a255 1
	    isp_sbus_intr, sbc, self->dv_xname);
@


