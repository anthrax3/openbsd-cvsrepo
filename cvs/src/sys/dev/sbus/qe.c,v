head	1.40;
access;
symbols
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.23.0.20
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.18
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.16
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.14
	OPENBSD_5_0:1.23.0.12
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.10
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.8
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.8
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.6.0.2
	UBC_BASE:1.6
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.40
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.39;
commitid	VyLWTsbepAOk7VQM;

1.39
date	2016.04.13.11.36.00;	author mpi;	state Exp;
branches;
next	1.38;
commitid	nHRUtEnkD6rbEjY0;

1.38
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.37;
commitid	J9apD0jq2AjFmqZc;

1.37
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.36;
commitid	f4dx5ry1aOiKJw33;

1.36
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.35;
commitid	B0kwmVGiD5DVx4kv;

1.35
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.34;
commitid	5gdEnqVoJuTuwdTu;

1.34
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.33;
commitid	5DvsamK0GblTp8ww;

1.33
date	2015.11.11.10.07.25;	author mpi;	state Exp;
branches;
next	1.32;
commitid	9FpLdI4B7Tx69D1N;

1.32
date	2015.10.25.13.13.06;	author mpi;	state Exp;
branches;
next	1.31;
commitid	SaArro4mM2Ab3ure;

1.31
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.30;
commitid	6vhYvh5CxZAHMnsN;

1.30
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.29;
commitid	9ERVupAoYqW4Iok9;

1.29
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.28;
commitid	MVWrtktB46JRxFWT;

1.28
date	2015.04.07.14.59.06;	author mpi;	state Exp;
branches;
next	1.27;
commitid	KvW3QlPLT9mb40b7;

1.27
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.26;
commitid	yM2VFFhpDTeFQlve;

1.26
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.25;
commitid	nYggAidK85QbUFh2;

1.25
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2013.08.07.01.06.40;	author bluhm;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.21.18.08.47;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.02.20.00.56;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.25.22.41.46;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.08.17.03.01;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.15.05.24.12;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.27.01.36.53;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.24.21.54.38;	author henric;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.18.32.41;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.27.17.39.05;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.17.01.29.21;	author henric;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.07.02.03.58;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.01.22.11.18;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.28.19.47.54;	author jason;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.11.28.05.42.24;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.27.02.33.15;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.12.19.48.11;	author jason;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.08.31.15.12.05;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.20.22.09.27;	author jason;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.12.05.01.02.38;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.03.28.00.38.30;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2003.06.07.11.02.32;	author ho;	state Exp;
branches;
next	1.3.4.8;

1.3.4.8
date	2004.02.19.10.56.32;	author niklas;	state Exp;
branches;
next	1.3.4.9;

1.3.4.9
date	2004.06.05.23.12.57;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.01.31.22.55.38;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.05.19.22.14.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.40
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: qe.c,v 1.39 2016/04/13 11:36:00 mpi Exp $	*/
/*	$NetBSD: qe.c,v 1.16 2001/03/30 17:30:18 christos Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1998 Jason L. Wright.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for the SBus qec+qe QuadEthernet board.
 *
 * This driver was written using the AMD MACE Am79C940 documentation, some
 * ideas gleaned from the S/Linux driver for this card, Solaris header files,
 * and a loan of a card from Paul Southworth of the Internet Engineering
 * Group (www.ieng.com).
 */

#define QEDEBUG

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>

#include <dev/sbus/sbusvar.h>
#include <dev/sbus/qecreg.h>
#include <dev/sbus/qecvar.h>
#include <dev/sbus/qereg.h>

struct qe_softc {
	struct	device	sc_dev;		/* base device */
	bus_space_tag_t	sc_bustag;	/* bus & dma tags */
	bus_dma_tag_t	sc_dmatag;
	bus_dmamap_t	sc_dmamap;
	struct	arpcom sc_arpcom;
	struct	ifmedia sc_ifmedia;	/* interface media */

	struct	qec_softc *sc_qec;	/* QEC parent */

	bus_space_handle_t	sc_qr;	/* QEC registers */
	bus_space_handle_t	sc_mr;	/* MACE registers */
	bus_space_handle_t	sc_cr;	/* channel registers */

	int	sc_channel;		/* channel number */
	u_int	sc_rev;			/* board revision */

	int	sc_burst;

	struct  qec_ring	sc_rb;	/* Packet Ring Buffer */

#ifdef QEDEBUG
	int	sc_debug;
#endif
};

int	qematch(struct device *, void *, void *);
void	qeattach(struct device *, struct device *, void *);

void	qeinit(struct qe_softc *);
void	qestart(struct ifnet *);
void	qestop(struct qe_softc *);
void	qewatchdog(struct ifnet *);
int	qeioctl(struct ifnet *, u_long, caddr_t);
void	qereset(struct qe_softc *);

int	qeintr(void *);
int	qe_eint(struct qe_softc *, u_int32_t);
int	qe_rint(struct qe_softc *);
int	qe_tint(struct qe_softc *);
void	qe_mcreset(struct qe_softc *);

int	qe_put(struct qe_softc *, int, struct mbuf *);
void	qe_read(struct qe_softc *, int, int);
struct mbuf	*qe_get(struct qe_softc *, int, int);

/* ifmedia callbacks */
void	qe_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int	qe_ifmedia_upd(struct ifnet *);

struct cfattach qe_ca = {
	sizeof(struct qe_softc), qematch, qeattach
};

struct cfdriver qe_cd = {
	NULL, "qe", DV_IFNET
};

int
qematch(parent, vcf, aux)
	struct device *parent;
	void *vcf;
	void *aux;
{
	struct cfdata *cf = vcf;
	struct sbus_attach_args *sa = aux;

	return (strcmp(cf->cf_driver->cd_name, sa->sa_name) == 0);
}

void
qeattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct sbus_attach_args *sa = aux;
	struct qec_softc *qec = (struct qec_softc *)parent;
	struct qe_softc *sc = (struct qe_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int node = sa->sa_node;
	bus_dma_tag_t dmatag = sa->sa_dmatag;
	bus_dma_segment_t seg;
	bus_size_t size;
	int rseg, error;
	extern void myetheraddr(u_char *);

	/* Pass on the bus tags */
	sc->sc_bustag = sa->sa_bustag;
	sc->sc_dmatag = sa->sa_dmatag;

	if (sa->sa_nreg < 2) {
		printf("%s: only %d register sets\n",
		    self->dv_xname, sa->sa_nreg);
		return;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    (bus_addr_t)sa->sa_reg[0].sbr_offset,
	    (bus_size_t)sa->sa_reg[0].sbr_size, 0, 0, &sc->sc_cr) != 0) {
		printf("%s: cannot map registers\n", self->dv_xname);
		return;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[1].sbr_slot,
	    (bus_addr_t)sa->sa_reg[1].sbr_offset,
	    (bus_size_t)sa->sa_reg[1].sbr_size, 0, 0, &sc->sc_mr) != 0) {
		printf("%s: cannot map registers\n", self->dv_xname);
		return;
	}

	sc->sc_rev = getpropint(node, "mace-version", -1);
	printf(" rev %x", sc->sc_rev);

	sc->sc_qec = qec;
	sc->sc_qr = qec->sc_regs;

	sc->sc_channel = getpropint(node, "channel#", -1);
	sc->sc_burst = qec->sc_burst;

	qestop(sc);

	/* Note: no interrupt level passed */
	if (bus_intr_establish(sa->sa_bustag, 0, IPL_NET, 0, qeintr, sc,
	    self->dv_xname) == NULL) {
		printf(": no interrupt established\n");
		return;
	}

	myetheraddr(sc->sc_arpcom.ac_enaddr);

	/*
	 * Allocate descriptor ring and buffers.
	 */

	/* for now, allocate as many bufs as there are ring descriptors */
	sc->sc_rb.rb_ntbuf = QEC_XD_RING_MAXSIZE;
	sc->sc_rb.rb_nrbuf = QEC_XD_RING_MAXSIZE;

	size =
	    QEC_XD_RING_MAXSIZE * sizeof(struct qec_xd) +
	    QEC_XD_RING_MAXSIZE * sizeof(struct qec_xd) +
	    sc->sc_rb.rb_ntbuf * QE_PKT_BUF_SZ +
	    sc->sc_rb.rb_nrbuf * QE_PKT_BUF_SZ;

	/* Get a DMA handle */
	if ((error = bus_dmamap_create(dmatag, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
		printf("%s: DMA map create error %d\n", self->dv_xname, error);
		return;
	}

	/* Allocate DMA buffer */
	if ((error = bus_dmamem_alloc(dmatag, size, 0, 0,
	    &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: DMA buffer alloc error %d\n",
			self->dv_xname, error);
		return;
	}

	/* Map DMA buffer in CPU addressable space */
	if ((error = bus_dmamem_map(dmatag, &seg, rseg, size,
	    &sc->sc_rb.rb_membase,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: DMA buffer map error %d\n",
		    self->dv_xname, error);
		bus_dmamem_free(dmatag, &seg, rseg);
		return;
	}

	/* Load the buffer */
	if ((error = bus_dmamap_load(dmatag, sc->sc_dmamap,
	    sc->sc_rb.rb_membase, size, NULL, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: DMA buffer map load error %d\n",
			self->dv_xname, error);
		bus_dmamem_unmap(dmatag, sc->sc_rb.rb_membase, size);
		bus_dmamem_free(dmatag, &seg, rseg);
		return;
	}
	sc->sc_rb.rb_dmabase = sc->sc_dmamap->dm_segs[0].ds_addr;

	/* Initialize media properties */
	ifmedia_init(&sc->sc_ifmedia, 0, qe_ifmedia_upd, qe_ifmedia_sts);
	ifmedia_add(&sc->sc_ifmedia,
	    IFM_MAKEWORD(IFM_ETHER,IFM_10_T,0,0), 0, NULL);
	ifmedia_add(&sc->sc_ifmedia,
	    IFM_MAKEWORD(IFM_ETHER,IFM_10_5,0,0), 0, NULL);
	ifmedia_add(&sc->sc_ifmedia,
	    IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,0), 0, NULL);
	ifmedia_set(&sc->sc_ifmedia, IFM_ETHER|IFM_AUTO);

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = qestart;
	ifp->if_ioctl = qeioctl;
	ifp->if_watchdog = qewatchdog;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX |
	    IFF_MULTICAST;

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
}

/*
 * Pull data off an interface.
 * Len is the length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present,
 * we copy into clusters.
 */
struct mbuf *
qe_get(sc, idx, totlen)
	struct qe_softc *sc;
	int idx, totlen;
{
	struct mbuf *m;
	struct mbuf *top, **mp;
	int len, pad, boff = 0;
	caddr_t bp;

	bp = sc->sc_rb.rb_rxbuf + (idx % sc->sc_rb.rb_nrbuf) * QE_PKT_BUF_SZ;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	m->m_data += pad;
	len = MHLEN - pad;
	top = NULL;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return (NULL);
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(bp + boff, mtod(m, caddr_t), len);
		boff += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}

/*
 * Routine to copy from mbuf chain to transmit buffer in
 * network buffer memory.
 */
__inline__ int
qe_put(sc, idx, m)
	struct qe_softc *sc;
	int idx;
	struct mbuf *m;
{
	struct mbuf *n;
	int len, tlen = 0, boff = 0;
	caddr_t bp;

	bp = sc->sc_rb.rb_txbuf + (idx % sc->sc_rb.rb_ntbuf) * QE_PKT_BUF_SZ;

	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			n = m_free(m);
			continue;
		}
		bcopy(mtod(m, caddr_t), bp+boff, len);
		boff += len;
		tlen += len;
		n = m_free(m);
	}
	return (tlen);
}

/*
 * Pass a packet to the higher levels.
 */
__inline__ void
qe_read(sc, idx, len)
	struct qe_softc *sc;
	int idx, len;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    len > ETHERMTU + sizeof(struct ether_header)) {

		printf("%s: invalid packet size %d; dropping\n",
		    ifp->if_xname, len);

		ifp->if_ierrors++;
		return;
	}

	/*
	 * Pull packet off interface.
	 */
	m = qe_get(sc, idx, len);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

/*
 * Start output on interface.
 * We make two assumptions here:
 *  1) that the current priority is set to splnet _before_ this code
 *     is called *and* is returned to the appropriate priority after
 *     return
 *  2) that the IFF_OACTIVE flag is checked before this code is called
 *     (i.e. that the output part of the interface is idle)
 */
void
qestart(ifp)
	struct ifnet *ifp;
{
	struct qe_softc *sc = (struct qe_softc *)ifp->if_softc;
	struct qec_xd *txd = sc->sc_rb.rb_txd;
	struct mbuf *m;
	unsigned int bix, len;
	unsigned int ntbuf = sc->sc_rb.rb_ntbuf;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	bix = sc->sc_rb.rb_tdhead;

	for (;;) {
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;


#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		len = qe_put(sc, bix, m);

		/*
		 * Initialize transmit registers and start transmission
		 */
		txd[bix].xd_flags = QEC_XD_OWN | QEC_XD_SOP | QEC_XD_EOP |
		    (len & QEC_XD_LENGTH);
		bus_space_write_4(sc->sc_bustag, sc->sc_cr, QE_CRI_CTRL,
		    QE_CR_CTRL_TWAKEUP);

		if (++bix == QEC_XD_RING_MAXSIZE)
			bix = 0;

		if (++sc->sc_rb.rb_td_nbusy == ntbuf) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
	}

	sc->sc_rb.rb_tdhead = bix;
}

void
qestop(sc)
	struct qe_softc *sc;
{	
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mr = sc->sc_mr;
	bus_space_handle_t cr = sc->sc_cr;
	int n;

	/* Stop the schwurst */
	bus_space_write_1(t, mr, QE_MRI_BIUCC, QE_MR_BIUCC_SWRST);
	for (n = 200; n > 0; n--) {
		if ((bus_space_read_1(t, mr, QE_MRI_BIUCC) &
		    QE_MR_BIUCC_SWRST) == 0)
			break;
		DELAY(20);
	}

	/* then reset */
	bus_space_write_4(t, cr, QE_CRI_CTRL, QE_CR_CTRL_RESET);
	for (n = 200; n > 0; n--) {
		if ((bus_space_read_4(t, cr, QE_CRI_CTRL) &
		    QE_CR_CTRL_RESET) == 0)
			break;
		DELAY(20);
	}
}

/*
 * Reset interface.
 */
void
qereset(sc)
	struct qe_softc *sc;
{
	int s;

	s = splnet();
	qestop(sc);
	qeinit(sc);
	splx(s);
}

void
qewatchdog(ifp)
	struct ifnet *ifp;
{
	struct qe_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	ifp->if_oerrors++;

	qereset(sc);
}

/*
 * Interrupt dispatch.
 */
int
qeintr(arg)
	void *arg;
{
	struct qe_softc *sc = (struct qe_softc *)arg;
	bus_space_tag_t t = sc->sc_bustag;
	u_int32_t qecstat, qestat;
	int r = 0;

	/* Read QEC status and channel status */
	qecstat = bus_space_read_4(t, sc->sc_qr, QEC_QRI_STAT);
#ifdef QEDEBUG
	if (sc->sc_debug) {
		printf("qe%d: intr: qecstat=%x\n", sc->sc_channel, qecstat);
	}
#endif

	/* Filter out status for this channel */
	qecstat = qecstat >> (4 * sc->sc_channel);
	if ((qecstat & 0xf) == 0)
		return (r);

	qestat = bus_space_read_4(t, sc->sc_cr, QE_CRI_STAT);

#ifdef QEDEBUG
	if (sc->sc_debug) {
		int i;
		bus_space_tag_t t = sc->sc_bustag;
		bus_space_handle_t mr = sc->sc_mr;

		printf("qe%d: intr: qestat=%b\n", sc->sc_channel,
		    qestat, QE_CR_STAT_BITS);

		printf("MACE registers:\n");
		for (i = 0 ; i < 32; i++) {
			printf("  m[%d]=%x,", i, bus_space_read_1(t, mr, i));
			if (((i+1) & 7) == 0)
				printf("\n");
		}
	}
#endif

	if (qestat & QE_CR_STAT_ALLERRORS) {
#ifdef QEDEBUG
		if (sc->sc_debug)
			printf("qe%d: eint: qestat=%b\n", sc->sc_channel,
			    qestat, QE_CR_STAT_BITS);
#endif
		r |= qe_eint(sc, qestat);
		if (r == -1)
			return (1);
	}

	if (qestat & QE_CR_STAT_TXIRQ)
		r |= qe_tint(sc);

	if (qestat & QE_CR_STAT_RXIRQ)
		r |= qe_rint(sc);

	return (1);
}

/*
 * Transmit interrupt.
 */
int
qe_tint(sc)
	struct qe_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	unsigned int bix, txflags;

	bix = sc->sc_rb.rb_tdtail;

	for (;;) {
		if (sc->sc_rb.rb_td_nbusy <= 0)
			break;

		txflags = sc->sc_rb.rb_txd[bix].xd_flags;

		if (txflags & QEC_XD_OWN)
			break;

		ifq_clr_oactive(&ifp->if_snd);

		if (++bix == QEC_XD_RING_MAXSIZE)
			bix = 0;

		--sc->sc_rb.rb_td_nbusy;
	}

	if (sc->sc_rb.rb_td_nbusy == 0)
		ifp->if_timer = 0;

	if (sc->sc_rb.rb_tdtail != bix) {
		sc->sc_rb.rb_tdtail = bix;
		if (ifq_is_oactive(&ifp->if_snd)) {
			ifq_clr_oactive(&ifp->if_snd);
			qestart(ifp);
		}
	}

	return (1);
}

/*
 * Receive interrupt.
 */
int
qe_rint(sc)
	struct qe_softc *sc;
{
	struct qec_xd *xd = sc->sc_rb.rb_rxd;
	unsigned int bix, len;
	unsigned int nrbuf = sc->sc_rb.rb_nrbuf;
#ifdef QEDEBUG
	int npackets = 0;
#endif

	bix = sc->sc_rb.rb_rdtail;

	/*
	 * Process all buffers with valid data.
	 */
	for (;;) {
		len = xd[bix].xd_flags;
		if (len & QEC_XD_OWN)
			break;

#ifdef QEDEBUG
		npackets++;
#endif

		len &= QEC_XD_LENGTH;
		len -= 4;
		qe_read(sc, bix, len);

		/* ... */
		xd[(bix+nrbuf) % QEC_XD_RING_MAXSIZE].xd_flags =
		    QEC_XD_OWN | (QE_PKT_BUF_SZ & QEC_XD_LENGTH);

		if (++bix == QEC_XD_RING_MAXSIZE)
			bix = 0;
	}
#ifdef QEDEBUG
	if (npackets == 0 && sc->sc_debug)
		printf("%s: rint: no packets; rb index %d; status 0x%x\n",
		    sc->sc_dev.dv_xname, bix, len);
#endif

	sc->sc_rb.rb_rdtail = bix;

	return (1);
}

/*
 * Error interrupt.
 */
int
qe_eint(sc, why)
	struct qe_softc *sc;
	u_int32_t why;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int r = 0, rst = 0;

	if (why & QE_CR_STAT_EDEFER) {
		printf("%s: excessive tx defers.\n", sc->sc_dev.dv_xname);
		r |= 1;
		ifp->if_oerrors++;
	}

	if (why & QE_CR_STAT_CLOSS) {
		ifp->if_oerrors++;
		r |= 1;
	}

	if (why & QE_CR_STAT_ERETRIES) {
		printf("%s: excessive tx retries\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		r |= 1;
		rst = 1;
	}


	if (why & QE_CR_STAT_LCOLL) {
		printf("%s: late tx transmission\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_FUFLOW) {
		printf("%s: tx fifo underflow\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_JERROR) {
		printf("%s: jabber seen\n", sc->sc_dev.dv_xname);
		r |= 1;
	}

	if (why & QE_CR_STAT_BERROR) {
		printf("%s: babble seen\n", sc->sc_dev.dv_xname);
		r |= 1;
	}

	if (why & QE_CR_STAT_TCCOFLOW) {
		ifp->if_collisions += 256;
		ifp->if_oerrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_TXDERROR) {
		printf("%s: tx descriptor is bad\n", sc->sc_dev.dv_xname);
		rst = 1;
		r |= 1;
	}

	if (why & QE_CR_STAT_TXLERR) {
		printf("%s: tx late error\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		rst = 1;
		r |= 1;
	}

	if (why & QE_CR_STAT_TXPERR) {
		printf("%s: tx dma parity error\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		rst = 1;
		r |= 1;
	}

	if (why & QE_CR_STAT_TXSERR) {
		printf("%s: tx dma sbus error ack\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		rst = 1;
		r |= 1;
	}

	if (why & QE_CR_STAT_RCCOFLOW) {
		ifp->if_collisions += 256;
		ifp->if_ierrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_RUOFLOW) {
		ifp->if_ierrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_MCOFLOW) {
		ifp->if_ierrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_RXFOFLOW) {
		printf("%s: rx fifo overflow\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
	}

	if (why & QE_CR_STAT_RLCOLL) {
		printf("%s: rx late collision\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		ifp->if_collisions++;
		r |= 1;
	}

	if (why & QE_CR_STAT_FCOFLOW) {
		ifp->if_ierrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_CECOFLOW) {
		ifp->if_ierrors += 256;
		r |= 1;
	}

	if (why & QE_CR_STAT_RXDROP) {
		printf("%s: rx packet dropped\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
	}

	if (why & QE_CR_STAT_RXSMALL) {
		printf("%s: rx buffer too small\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_RXLERR) {
		printf("%s: rx late error\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_RXPERR) {
		printf("%s: rx dma parity error\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
		rst = 1;
	}

	if (why & QE_CR_STAT_RXSERR) {
		printf("%s: rx dma sbus error ack\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		r |= 1;
		rst = 1;
	}

	if (r == 0)
		printf("%s: unexpected interrupt error: %08x\n",
			sc->sc_dev.dv_xname, why);

	if (rst) {
		printf("%s: resetting...\n", sc->sc_dev.dv_xname);
		qereset(sc);
		return (-1);
	}

	return (r);
}

int
qeioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct qe_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		qeinit(sc);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			qestop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			qeinit(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			qestop(sc);
			qeinit(sc);
		}
#ifdef QEDEBUG
		sc->sc_debug = (ifp->if_flags & IFF_DEBUG) != 0 ? 1 : 0;
#endif
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_ifmedia, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			qe_mcreset(sc);
		error = 0;
	}

	splx(s);
	return (error);
}


void
qeinit(sc)
	struct qe_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t cr = sc->sc_cr;
	bus_space_handle_t mr = sc->sc_mr;
	struct qec_softc *qec = sc->sc_qec;
	u_int32_t qecaddr;
	u_int8_t *ea;
	int s;

	s = splnet();

	qestop(sc);

	/*
	 * Allocate descriptor ring and buffers
	 */
	qec_meminit(&sc->sc_rb, QE_PKT_BUF_SZ);

	/* Channel registers: */
	bus_space_write_4(t, cr, QE_CRI_RXDS, (u_int32_t)sc->sc_rb.rb_rxddma);
	bus_space_write_4(t, cr, QE_CRI_TXDS, (u_int32_t)sc->sc_rb.rb_txddma);

	bus_space_write_4(t, cr, QE_CRI_RIMASK, 0);
	bus_space_write_4(t, cr, QE_CRI_TIMASK, 0);
	bus_space_write_4(t, cr, QE_CRI_QMASK, 0);
	bus_space_write_4(t, cr, QE_CRI_MMASK, QE_CR_MMASK_RXCOLL);
	bus_space_write_4(t, cr, QE_CRI_CCNT, 0);
	bus_space_write_4(t, cr, QE_CRI_PIPG, 0);

	qecaddr = sc->sc_channel * qec->sc_msize;
	bus_space_write_4(t, cr, QE_CRI_RXWBUF, qecaddr);
	bus_space_write_4(t, cr, QE_CRI_RXRBUF, qecaddr);
	bus_space_write_4(t, cr, QE_CRI_TXWBUF, qecaddr + qec->sc_rsize);
	bus_space_write_4(t, cr, QE_CRI_TXRBUF, qecaddr + qec->sc_rsize);

	/*
	 * When switching from mace<->qec always guarantee an sbus
	 * turnaround (if last op was read, perform a dummy write, and
	 * vice versa).
	 */
	bus_space_read_4(t, cr, QE_CRI_QMASK);

	/* MACE registers: */
	bus_space_write_1(t, mr, QE_MRI_PHYCC, QE_MR_PHYCC_ASEL);
	bus_space_write_1(t, mr, QE_MRI_XMTFC, QE_MR_XMTFC_APADXMT);
	bus_space_write_1(t, mr, QE_MRI_RCVFC, 0);

	/*
	 * Mask MACE's receive interrupt, since we're being notified
	 * by the QEC after DMA completes.
	 */
	bus_space_write_1(t, mr, QE_MRI_IMR,
	    QE_MR_IMR_CERRM | QE_MR_IMR_RCVINTM);

	bus_space_write_1(t, mr, QE_MRI_BIUCC,
	    QE_MR_BIUCC_BSWAP | QE_MR_BIUCC_64TS);

	bus_space_write_1(t, mr, QE_MRI_FIFOFC,
	    QE_MR_FIFOCC_TXF16 | QE_MR_FIFOCC_RXF32 |
	    QE_MR_FIFOCC_RFWU | QE_MR_FIFOCC_TFWU);

	bus_space_write_1(t, mr, QE_MRI_PLSCC, QE_MR_PLSCC_TP);

	/*
	 * Station address
	 */
	ea = sc->sc_arpcom.ac_enaddr;
	bus_space_write_1(t, mr, QE_MRI_IAC,
	    QE_MR_IAC_ADDRCHG | QE_MR_IAC_PHYADDR);
	bus_space_write_multi_1(t, mr, QE_MRI_PADR, ea, 6);

	/* Apply media settings */
	qe_ifmedia_upd(ifp);

	/*
	 * Clear Logical address filter
	 */
	bus_space_write_1(t, mr, QE_MRI_IAC,
	    QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
	bus_space_set_multi_1(t, mr, QE_MRI_LADRF, 0, 8);
	bus_space_write_1(t, mr, QE_MRI_IAC, 0);

	/* Clear missed packet count (register cleared on read) */
	(void)bus_space_read_1(t, mr, QE_MRI_MPC);

#if 0
	/* test register: */
	bus_space_write_1(t, mr, QE_MRI_UTR, 0);
#endif

	/* Reset multicast filter */
	qe_mcreset(sc);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	splx(s);
}

/*
 * Reset multicast filter.
 */
void
qe_mcreset(sc)
	struct qe_softc *sc;
{
	struct arpcom *ac = &sc->sc_arpcom;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t mr = sc->sc_mr;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t crc;
	u_int16_t hash[4];
	u_int8_t octet, maccc, *ladrp = (u_int8_t *)&hash[0];
	int i, j;

	/* We also enable transmitter & receiver here */
	maccc = QE_MR_MACCC_ENXMT | QE_MR_MACCC_ENRCV;

	if (ifp->if_flags & IFF_PROMISC) {
		maccc |= QE_MR_MACCC_PROM;
		bus_space_write_1(t, mr, QE_MRI_MACCC, maccc);
		return;
	}

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_ALLMULTI) {
		bus_space_write_1(t, mr, QE_MRI_IAC,
		    QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
		bus_space_set_multi_1(t, mr, QE_MRI_LADRF, 0xff, 8);
		bus_space_write_1(t, mr, QE_MRI_IAC, 0);
		bus_space_write_1(t, mr, QE_MRI_MACCC, maccc);
		return;
	}

	hash[3] = hash[2] = hash[1] = hash[0] = 0;

	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		crc = 0xffffffff;

		for (i = 0; i < ETHER_ADDR_LEN; i++) {
			octet = enm->enm_addrlo[i];

			for (j = 0; j < 8; j++) {
				if ((crc & 1) ^ (octet & 1)) {
					crc >>= 1;
					crc ^= MC_POLY_LE;
				}
				else
					crc >>= 1;
				octet >>= 1;
			}
		}

		crc >>= 26;
		hash[crc >> 4] |= 1 << (crc & 0xf);
		ETHER_NEXT_MULTI(step, enm);
	}

	bus_space_write_1(t, mr, QE_MRI_IAC,
	    QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
	bus_space_write_multi_1(t, mr, QE_MRI_LADRF, ladrp, 8);
	bus_space_write_1(t, mr, QE_MRI_IAC, 0);
	bus_space_write_1(t, mr, QE_MRI_MACCC, maccc);
}

/*
 * Get current media settings.
 */
void
qe_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct qe_softc *sc = ifp->if_softc;
	u_int8_t phycc;

	ifmr->ifm_active = IFM_ETHER | IFM_10_T;
	phycc = bus_space_read_1(sc->sc_bustag, sc->sc_mr, QE_MRI_PHYCC);
	if ((phycc & QE_MR_PHYCC_DLNKTST) == 0) {
		ifmr->ifm_status |= IFM_AVALID;
		if (phycc & QE_MR_PHYCC_LNKFL)
			ifmr->ifm_status &= ~IFM_ACTIVE;
		else
			ifmr->ifm_status |= IFM_ACTIVE;
	}
}

/*
 * Set media options.
 */
int
qe_ifmedia_upd(ifp)
	struct ifnet *ifp;
{
	struct qe_softc *sc = ifp->if_softc;
	uint64_t media = sc->sc_ifmedia.ifm_media;

	if (IFM_TYPE(media) != IFM_ETHER)
		return (EINVAL);

	if (IFM_SUBTYPE(media) != IFM_10_T)
		return (EINVAL);

	return (0);
}
@


1.39
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.38 2015/12/08 13:34:22 tedu Exp $	*/
a629 1
		ifp->if_opackets++;
@


1.38
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.37 2015/11/25 11:20:38 mpi Exp $	*/
a297 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.37
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.36 2015/11/25 03:09:59 dlg Exp $	*/
d296 1
a296 1
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS |
@


1.36
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.35 2015/11/24 17:11:40 mpi Exp $	*/
a82 1
#include <net/netisr.h>
@


1.35
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.34 2015/11/24 13:33:18 mpi Exp $	*/
d445 1
a445 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d482 1
a482 1
			ifp->if_flags |= IFF_OACTIVE;
d631 1
a631 1
		ifp->if_flags &= ~IFF_OACTIVE;
d645 2
a646 2
		if (ifp->if_flags & IFF_OACTIVE) {
			ifp->if_flags &= ~IFF_OACTIVE;
d1042 1
a1042 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.34
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.33 2015/11/11 10:07:25 mpi Exp $	*/
a82 1
#include <net/if_dl.h>
@


1.33
log
@Kill useless IFQ_POLL().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.32 2015/10/25 13:13:06 mpi Exp $	*/
a83 1
#include <net/if_types.h>
@


1.32
log
@arp_ifinit() is no longer needed and almost dead.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.31 2015/09/11 13:02:28 stsp Exp $	*/
d453 1
a453 1
		IFQ_POLL(&ifp->if_snd, m);
a456 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.31
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.30 2015/07/08 07:21:50 mpi Exp $	*/
a886 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d895 1
a895 9
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			qeinit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		default:
			qeinit(sc);
			break;
		}
@


1.30
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.29 2015/06/24 09:40:54 mpi Exp $	*/
d1159 1
a1159 1
	int media = sc->sc_ifmedia.ifm_media;
@


1.29
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.28 2015/04/07 14:59:06 mpi Exp $	*/
d382 1
a382 1
			MFREE(m, n);
d388 1
a388 1
		MFREE(m, n);
@


1.28
log
@Keep in sync with the sparc version: convert to if_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.27 2014/12/22 02:28:52 tedu Exp $	*/
a422 1
	ifp->if_ipackets++;
@


1.27
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.26 2014/08/11 12:45:45 mpi Exp $	*/
a320 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a330 1
	m->m_pkthdr.rcvif = ifp;
d402 1
d425 2
a426 10
#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
@


1.26
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.25 2013/11/26 09:50:33 mpi Exp $	*/
a906 1
#ifdef INET
a910 1
#endif /* INET */
@


1.25
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.24 2013/08/07 01:06:40 bluhm Exp $	*/
a87 1
#ifdef INET
a88 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a89 1
#endif
@


1.24
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.23 2008/11/28 02:44:18 brad Exp $	*/
d1101 3
a1116 20
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    ETHER_ADDR_LEN) != 0) {
			/*
			 * We must listen to a range of multicast
			 * addresses. For now, just accept all
			 * multicasts, rather than trying to set only
			 * those filter bits needed to match the range.
			 * (At this time, the only use of address
			 * ranges is for IP multicast routing, for
			 * which the range is big enough to require
			 * all bits set.)
			 */
			bus_space_write_1(t, mr, QE_MRI_IAC,
			    QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
			bus_space_set_multi_1(t, mr, QE_MRI_LADRF, 0xff, 8);
			bus_space_write_1(t, mr, QE_MRI_IAC, 0);
			ifp->if_flags |= IFF_ALLMULTI;
			break;
		}

@


1.23
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.22 2008/10/02 20:21:14 brad Exp $	*/
a90 1
#include <netinet/in_var.h>
@


1.22
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.21 2008/06/26 05:42:18 ray Exp $	*/
a952 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom):
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				qe_mcreset(sc);
			error = 0;
		}
		break;

d960 6
@


1.21
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.20 2006/06/21 18:08:47 jason Exp $	*/
a907 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d976 1
a976 2
		error = EINVAL;
		break;
@


1.20
log
@don't need #ifdef SUN4U any more
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.19 2006/06/02 20:00:56 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.19
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.18 2006/03/25 22:41:46 djm Exp $	*/
a523 3
#if defined(SUN4U) || defined(__GNUC__)
	(void)&t;
#endif
a581 3
#if defined(SUN4U) || defined(__GNUC__)
	(void)&t;
#endif
a1009 3
#if defined(SUN4U) || defined(__GNUC__)
	(void)&t;
#endif
a1115 4

#if defined(SUN4U) || defined(__GNUC__)
	(void)&t;
#endif
@


1.18
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.17 2005/06/08 17:03:01 henning Exp $	*/
a117 1
	struct	sbusdev sc_sd;		/* sbus device */
@


1.17
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.16 2005/01/15 05:24:12 brad Exp $	*/
d445 1
a445 1
		bpf_mtap(ifp->if_bpf, m);
d488 1
a488 1
			bpf_mtap(ifp->if_bpf, m);
@


1.16
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.15 2004/05/12 06:35:11 tedu Exp $	*/
a102 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a936 16
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else
				bcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			qeinit(sc);
			break;
		    }
#endif /* NS */
@


1.15
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.14 2003/06/27 01:36:53 jason Exp $	*/
d1004 2
a1005 1
			qe_mcreset(sc);
@


1.14
log
@These don't need linear mappings either.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.13 2003/06/24 21:54:38 henric Exp $	*/
a109 1
#include <net/bpfdesc.h>
@


1.13
log
@Add a "where" argument to the sparc64 interrupt code.  This lets us
associate a name with each interrupt handler.  This is not visible
outside the kernel (yet).

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.12 2003/06/02 18:32:41 jason Exp $	*/
d219 1
a219 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[0].sbr_slot,
d221 1
a221 2
	    (bus_size_t)sa->sa_reg[0].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_cr) != 0) {
d226 1
a226 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[1].sbr_slot,
d228 1
a228 2
	    (bus_size_t)sa->sa_reg[1].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_mr) != 0) {
@


1.12
log
@Nuke my clause 3 and 4 (and a couple of files jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.11 2003/03/27 17:39:05 jason Exp $	*/
d249 2
a250 2
	if (bus_intr_establish(sa->sa_bustag, 0, IPL_NET, 0, qeintr, sc) ==
	    NULL) {
@


1.11
log
@const and static cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.10 2003/02/17 01:29:21 henric Exp $	*/
a51 2
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.10
log
@
Add support for the Sun Enterprise 450
Reduce the size of a GENERIC kernel by ~190k
Remove the nasty pointer/bus_space_handle_t casts
Adds debug bus_space code including the ability to trace
    bus operations (it actually works now).

The following rules are now followed (and verfified by the debug
code):

1.  A "bus_space_handle_t" may only be used with the
    "bus_space_tag_t" that created it.
2.  Only "bus_space_map()" may create "bus_space_handle_t"s.
3.  A "bus_space_handle_t" may not be modified after it has
    been created (other than being destroyed by "bus_space_unmap()").


Thanks to help from mcbride, marc, jason, drahn, to anyone that might
have slipped my mind at the moment.

ok jason@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.9 2002/03/14 01:27:02 millert Exp $	*/
d167 3
a169 3
static int	qe_put(struct qe_softc *, int, struct mbuf *);
static void	qe_read(struct qe_softc *, int, int);
static struct mbuf	*qe_get(struct qe_softc *, int, int);
d341 1
a341 1
static __inline__ struct mbuf *
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.8 2002/03/07 02:03:58 jason Exp $	*/
d221 2
a222 2
	if (bus_space_map2(sa->sa_bustag,
	    (bus_type_t)sa->sa_reg[0].sbr_slot,
d230 2
a231 2
	if (bus_space_map2(sa->sa_bustag,
	    (bus_type_t)sa->sa_reg[1].sbr_slot,
@


1.8
log
@From watching source-changes@@netbsd.org: rb_dmabase needs to be initialized
-after- the call to bus_dmamem_map()
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.7 2002/01/01 22:11:18 jason Exp $	*/
d151 2
a152 2
int	qematch __P((struct device *, void *, void *));
void	qeattach __P((struct device *, struct device *, void *));
d154 16
a169 16
void	qeinit __P((struct qe_softc *));
void	qestart __P((struct ifnet *));
void	qestop __P((struct qe_softc *));
void	qewatchdog __P((struct ifnet *));
int	qeioctl __P((struct ifnet *, u_long, caddr_t));
void	qereset __P((struct qe_softc *));

int	qeintr __P((void *));
int	qe_eint __P((struct qe_softc *, u_int32_t));
int	qe_rint __P((struct qe_softc *));
int	qe_tint __P((struct qe_softc *));
void	qe_mcreset __P((struct qe_softc *));

static int	qe_put __P((struct qe_softc *, int, struct mbuf *));
static void	qe_read __P((struct qe_softc *, int, int));
static struct mbuf	*qe_get __P((struct qe_softc *, int, int));
d172 2
a173 2
void	qe_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
int	qe_ifmedia_upd __P((struct ifnet *));
d209 1
a209 1
	extern void myetheraddr __P((u_char *));
@


1.7
log
@don't whine about no carrier here either.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.6 2001/11/28 19:47:54 jason Exp $	*/
a286 1
	sc->sc_rb.rb_dmabase = sc->sc_dmamap->dm_segs[0].ds_addr;
d307 1
d488 4
a492 2
		if (m == 0)
			break;
d651 1
a651 1
	return (r);
a683 4
	sc->sc_rb.rb_tdtail = bix;

	qestart(ifp);

d686 8
@


1.6
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.5 2001/11/28 05:42:24 jason Exp $	*/
a759 1
		printf("%s: no carrier, link down?\n", sc->sc_dev.dv_xname);
@


1.6.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.7 2002/01/01 22:11:18 jason Exp $	*/
d760 1
@


1.6.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.6.2.1 2002/01/31 22:55:38 niklas Exp $	*/
d151 2
a152 2
int	qematch(struct device *, void *, void *);
void	qeattach(struct device *, struct device *, void *);
d154 16
a169 16
void	qeinit(struct qe_softc *);
void	qestart(struct ifnet *);
void	qestop(struct qe_softc *);
void	qewatchdog(struct ifnet *);
int	qeioctl(struct ifnet *, u_long, caddr_t);
void	qereset(struct qe_softc *);

int	qeintr(void *);
int	qe_eint(struct qe_softc *, u_int32_t);
int	qe_rint(struct qe_softc *);
int	qe_tint(struct qe_softc *);
void	qe_mcreset(struct qe_softc *);

static int	qe_put(struct qe_softc *, int, struct mbuf *);
static void	qe_read(struct qe_softc *, int, int);
static struct mbuf	*qe_get(struct qe_softc *, int, int);
d172 2
a173 2
void	qe_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int	qe_ifmedia_upd(struct ifnet *);
d209 1
a209 1
	extern void myetheraddr(u_char *);
d287 1
a307 1
	sc->sc_rb.rb_dmabase = sc->sc_dmamap->dm_segs[0].ds_addr;
d488 2
a489 2
		IFQ_POLL(&ifp->if_snd, m);
		if (m == NULL)
a491 2
		IFQ_DEQUEUE(&ifp->if_snd, m);

d649 1
a649 1
	return (1);
d682 4
a687 8

	if (sc->sc_rb.rb_tdtail != bix) {
		sc->sc_rb.rb_tdtail = bix;
		if (ifp->if_flags & IFF_OACTIVE) {
			ifp->if_flags &= ~IFF_OACTIVE;
			qestart(ifp);
		}
	}
@


1.6.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d167 3
a169 3
int	qe_put(struct qe_softc *, int, struct mbuf *);
void	qe_read(struct qe_softc *, int, int);
struct mbuf	*qe_get(struct qe_softc *, int, int);
d221 2
a222 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[0].sbr_slot,
d230 2
a231 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[1].sbr_slot,
d341 1
a341 1
struct mbuf *
@


1.5
log
@be sure to call ether_ioctl, like everyone else.
also, complain if we don't get an interrupt established.
current state: be doesn't interrupt, qe gets rx/tx sbus dma errors *sigh*
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.4 2001/11/27 02:33:15 jason Exp $	*/
d217 1
a217 1
			self->dv_xname, sa->sa_nreg);
d222 4
a225 4
			  (bus_type_t)sa->sa_reg[0].sbr_slot,
			  (bus_addr_t)sa->sa_reg[0].sbr_offset,
			  (bus_size_t)sa->sa_reg[0].sbr_size,
			  BUS_SPACE_MAP_LINEAR, 0, &sc->sc_cr) != 0) {
d231 4
a234 4
			  (bus_type_t)sa->sa_reg[1].sbr_slot,
			  (bus_addr_t)sa->sa_reg[1].sbr_offset,
			  (bus_size_t)sa->sa_reg[1].sbr_size,
			  BUS_SPACE_MAP_LINEAR, 0, &sc->sc_mr) != 0) {
d267 5
a271 4
	size =	QEC_XD_RING_MAXSIZE * sizeof(struct qec_xd) +
		QEC_XD_RING_MAXSIZE * sizeof(struct qec_xd) +
		sc->sc_rb.rb_ntbuf * QE_PKT_BUF_SZ +
		sc->sc_rb.rb_nrbuf * QE_PKT_BUF_SZ;
d275 1
a275 1
				    BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
d282 1
a282 1
				      &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
d291 2
a292 2
			            &sc->sc_rb.rb_membase,
			            BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
d294 1
a294 1
			self->dv_xname, error);
d301 1
a301 2
				     sc->sc_rb.rb_membase, size, NULL,
				     BUS_DMA_NOWAIT)) != 0) {
d312 1
a312 2
		    IFM_MAKEWORD(IFM_ETHER,IFM_10_T,0,0),
		    0, NULL);
d314 1
a314 2
		    IFM_MAKEWORD(IFM_ETHER,IFM_10_5,0,0),
		    0, NULL);
d316 1
a316 2
		    IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,0),
		    0, NULL);
d435 1
a435 1
			ifp->if_xname, len);
d510 1
a510 1
				    (len & QEC_XD_LENGTH);
d512 1
a512 1
				  QE_CR_CTRL_TWAKEUP);
d542 1
a542 1
			QE_MR_BIUCC_SWRST) == 0)
d551 1
a551 1
			QE_CR_CTRL_RESET) == 0)
d726 1
a726 1
			QEC_XD_OWN | (QE_PKT_BUF_SZ & QEC_XD_LENGTH);
d734 1
a734 1
			sc->sc_dev.dv_xname, bix, len);
d951 1
a951 1
					*(union ns_host *)LLADDR(ifp->if_sadl);
d954 1
a954 1
				      sizeof(sc->sc_arpcom.ac_enaddr));
a974 1

a981 1

d1085 1
a1085 1
			  QE_MR_IMR_CERRM | QE_MR_IMR_RCVINTM);
d1088 1
a1088 1
			  QE_MR_BIUCC_BSWAP | QE_MR_BIUCC_64TS);
d1091 2
a1092 2
			  QE_MR_FIFOCC_TXF16 | QE_MR_FIFOCC_RXF32 |
			  QE_MR_FIFOCC_RFWU | QE_MR_FIFOCC_TFWU);
d1101 1
a1101 1
			  QE_MR_IAC_ADDRCHG | QE_MR_IAC_PHYADDR);
d1111 1
a1111 1
			  QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
d1164 1
a1164 1
				  QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
d1176 1
a1176 1
			 ETHER_ADDR_LEN) != 0) {
d1188 1
a1188 1
				 QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
d1217 1
a1217 1
			  QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
@


1.4
log
@remove sc_enaddr and just put the ethernet address into arpcom.ac_enaddr.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.3 2001/09/12 19:48:11 jason Exp $	*/
d251 6
a256 1
	(void)bus_intr_establish(sa->sa_bustag, 0, IPL_NET, 0, qeintr, sc);
d931 5
@


1.3
log
@get sc_bustag and sc_dmatag from attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.2 2001/08/31 15:12:05 jason Exp $	*/
a145 3
	/* MAC address */
	u_int8_t sc_enaddr[6];

d252 1
a252 1
	myetheraddr(sc->sc_enaddr);
d330 1
a330 1
	printf(" address %s\n", ether_sprintf(sc->sc_enaddr));
d947 1
a947 1
				      sizeof(sc->sc_enaddr));
d1094 1
a1094 1
	ea = sc->sc_enaddr;
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current
@
text
@d146 3
d220 1
a220 1
		    self->dv_xname, sa->sa_nreg);
d225 4
a228 4
	    (bus_type_t)sa->sa_reg[0].sbr_slot,
	    (bus_addr_t)sa->sa_reg[0].sbr_offset,
	    (bus_size_t)sa->sa_reg[0].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_cr) != 0) {
d234 4
a237 4
	    (bus_type_t)sa->sa_reg[1].sbr_slot,
	    (bus_addr_t)sa->sa_reg[1].sbr_offset,
	    (bus_size_t)sa->sa_reg[1].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_mr) != 0) {
d254 2
a255 7
	if (bus_intr_establish(sa->sa_bustag, 0, IPL_NET, 0, qeintr, sc) ==
	    NULL) {
		printf(": no interrupt established\n");
		return;
	}

	myetheraddr(sc->sc_arpcom.ac_enaddr);
d265 4
a268 5
	size =
	    QEC_XD_RING_MAXSIZE * sizeof(struct qec_xd) +
	    QEC_XD_RING_MAXSIZE * sizeof(struct qec_xd) +
	    sc->sc_rb.rb_ntbuf * QE_PKT_BUF_SZ +
	    sc->sc_rb.rb_nrbuf * QE_PKT_BUF_SZ;
d272 1
a272 1
	    BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
d279 1
a279 1
	    &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
d288 2
a289 2
	    &sc->sc_rb.rb_membase,
	    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
d291 1
a291 1
		    self->dv_xname, error);
d298 2
a299 1
	    sc->sc_rb.rb_membase, size, NULL, BUS_DMA_NOWAIT)) != 0) {
d310 2
a311 1
	    IFM_MAKEWORD(IFM_ETHER,IFM_10_T,0,0), 0, NULL);
d313 2
a314 1
	    IFM_MAKEWORD(IFM_ETHER,IFM_10_5,0,0), 0, NULL);
d316 2
a317 1
	    IFM_MAKEWORD(IFM_ETHER,IFM_AUTO,0,0), 0, NULL);
d333 1
a333 1
	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d436 1
a436 1
		    ifp->if_xname, len);
d511 1
a511 1
		    (len & QEC_XD_LENGTH);
d513 1
a513 1
		    QE_CR_CTRL_TWAKEUP);
d543 1
a543 1
		    QE_MR_BIUCC_SWRST) == 0)
d552 1
a552 1
		    QE_CR_CTRL_RESET) == 0)
d727 1
a727 1
		    QEC_XD_OWN | (QE_PKT_BUF_SZ & QEC_XD_LENGTH);
d735 1
a735 1
		    sc->sc_dev.dv_xname, bix, len);
a929 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d947 1
a947 1
				    *(union ns_host *)LLADDR(ifp->if_sadl);
d950 1
a950 1
				    sizeof(sc->sc_arpcom.ac_enaddr));
d971 1
d979 1
d1083 1
a1083 1
	    QE_MR_IMR_CERRM | QE_MR_IMR_RCVINTM);
d1086 1
a1086 1
	    QE_MR_BIUCC_BSWAP | QE_MR_BIUCC_64TS);
d1089 2
a1090 2
	    QE_MR_FIFOCC_TXF16 | QE_MR_FIFOCC_RXF32 |
	    QE_MR_FIFOCC_RFWU | QE_MR_FIFOCC_TFWU);
d1097 1
a1097 1
	ea = sc->sc_arpcom.ac_enaddr;
d1099 1
a1099 1
	    QE_MR_IAC_ADDRCHG | QE_MR_IAC_PHYADDR);
d1109 1
a1109 1
	    QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
d1162 1
a1162 1
		    QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
d1174 1
a1174 1
		    ETHER_ADDR_LEN) != 0) {
d1186 1
a1186 1
			    QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
d1215 1
a1215 1
	    QE_MR_IAC_ADDRCHG | QE_MR_IAC_LOGADDR);
@


1.3.4.3
log
@Merge in trunk
@
text
@d760 1
@


1.3.4.4
log
@Merge in -current from roughly a week ago
@
text
@d151 2
a152 2
int	qematch(struct device *, void *, void *);
void	qeattach(struct device *, struct device *, void *);
d154 16
a169 16
void	qeinit(struct qe_softc *);
void	qestart(struct ifnet *);
void	qestop(struct qe_softc *);
void	qewatchdog(struct ifnet *);
int	qeioctl(struct ifnet *, u_long, caddr_t);
void	qereset(struct qe_softc *);

int	qeintr(void *);
int	qe_eint(struct qe_softc *, u_int32_t);
int	qe_rint(struct qe_softc *);
int	qe_tint(struct qe_softc *);
void	qe_mcreset(struct qe_softc *);

static int	qe_put(struct qe_softc *, int, struct mbuf *);
static void	qe_read(struct qe_softc *, int, int);
static struct mbuf	*qe_get(struct qe_softc *, int, int);
d172 2
a173 2
void	qe_ifmedia_sts(struct ifnet *, struct ifmediareq *);
int	qe_ifmedia_upd(struct ifnet *);
d209 1
a209 1
	extern void myetheraddr(u_char *);
d287 1
a307 1
	sc->sc_rb.rb_dmabase = sc->sc_dmamap->dm_segs[0].ds_addr;
d488 2
a489 2
		IFQ_POLL(&ifp->if_snd, m);
		if (m == NULL)
a491 2
		IFQ_DEQUEUE(&ifp->if_snd, m);

d649 1
a649 1
	return (1);
d682 4
a687 8

	if (sc->sc_rb.rb_tdtail != bix) {
		sc->sc_rb.rb_tdtail = bix;
		if (ifp->if_flags & IFF_OACTIVE) {
			ifp->if_flags &= ~IFF_OACTIVE;
			qestart(ifp);
		}
	}
@


1.3.4.5
log
@Sync the SMP branch with 3.3
@
text
@d221 2
a222 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[0].sbr_slot,
d230 2
a231 2
	if (sbus_bus_map(sa->sa_bustag,
	    sa->sa_reg[1].sbr_slot,
@


1.3.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.3.4.5 2003/03/28 00:38:30 niklas Exp $	*/
d167 3
a169 3
int	qe_put(struct qe_softc *, int, struct mbuf *);
void	qe_read(struct qe_softc *, int, int);
struct mbuf	*qe_get(struct qe_softc *, int, int);
d341 1
a341 1
struct mbuf *
@


1.3.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.3.4.6 2003/05/13 19:35:11 ho Exp $	*/
d52 2
@


1.3.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d219 2
a220 1
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
d222 2
a223 1
	    (bus_size_t)sa->sa_reg[0].sbr_size, 0, 0, &sc->sc_cr) != 0) {
d228 2
a229 1
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[1].sbr_slot,
d231 2
a232 1
	    (bus_size_t)sa->sa_reg[1].sbr_size, 0, 0, &sc->sc_mr) != 0) {
d249 2
a250 2
	if (bus_intr_establish(sa->sa_bustag, 0, IPL_NET, 0, qeintr, sc,
	    self->dv_xname) == NULL) {
@


1.3.4.9
log
@Merge with the trunk
@
text
@d110 1
@


1.2
log
@implement autoconf mechanism using device_register(); from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: qe.c,v 1.1 2001/08/20 22:09:27 jason Exp $	*/
d213 4
@


1.1
log
@add qec+qe stuff from NetBSD (originally from OpenBSD... funny circle, eh?)
including:
- OpenBSD style boot determination
- local version of media handling
- other local modifications, too.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a211 1
	struct bootpath *bp;
a329 5

	bp = sa->sa_bp;
	if (bp != NULL && strcmp(bp->name, qe_cd.cd_name) == 0 &&
	    sc->sc_dev.dv_unit == bp->val[1])
		bp->dev = &sc->sc_dev;
@

