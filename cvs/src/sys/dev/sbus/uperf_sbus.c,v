head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.34
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.32
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.22
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.30
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.28
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.26
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.24
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.20
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.18
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.16
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.14
	OPENBSD_5_0:1.8.0.12
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.10
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	SMP:1.2.0.4
	UBC:1.2.0.2
	UBC_SYNC_B:1.4;
locks; strict;
comment	@ * @;


1.8
date	2008.12.15.22.35.06;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.27.01.50.52;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.18.32.41;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.27.17.41.43;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.31.18.35.19;	author jason;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2002.01.30.23.58.03;	author jason;	state Exp;
branches;
next	;

1.2.2.1
date	2002.01.31.22.55.39;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.05.19.22.14.42;	author tedu;	state Exp;
branches;
next	;

1.2.4.1
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2003.03.28.00.38.30;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.06.07.11.02.32;	author ho;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Make the "machine xir" ddb command work on machines with uperf(4) on sbus(4).
@
text
@/*	$OpenBSD: uperf_sbus.c,v 1.7 2003/06/27 01:50:52 jason Exp $	*/

/*
 * Copyright (c) 2002 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>

#ifdef DDB
#include <machine/db_machdep.h>
#endif

#include <arch/sparc64/dev/uperfvar.h>
#include <dev/sun/uperfio.h>
#include <dev/sbus/sbusvar.h>
#include <dev/sbus/uperf_sbusreg.h>

int uperf_sbus_match(struct device *, void *, void *);
void uperf_sbus_attach(struct device *, struct device *, void *);

struct uperf_sbus_softc {
	struct uperf_softc	sc_usc;
	bus_space_tag_t		sc_bus_t;	/* direct register tag */
	bus_space_handle_t	sc_bus_h;	/* direct register handle */
};

struct cfattach uperf_sbus_ca = {
	sizeof(struct uperf_sbus_softc), uperf_sbus_match, uperf_sbus_attach
};

u_int32_t uperf_sbus_read_reg(struct uperf_sbus_softc *, bus_size_t);
void uperf_sbus_write_reg(struct uperf_sbus_softc *,
    bus_size_t, u_int32_t);

int uperf_sbus_getcnt(void *, int, u_int32_t *, u_int32_t *);
int uperf_sbus_clrcnt(void *, int);
int uperf_sbus_getcntsrc(void *, int, u_int *, u_int *);
int uperf_sbus_setcntsrc(void *, int, u_int, u_int);

#ifdef DDB
void uperf_sbus_xir(void *, int);
#endif

struct uperf_src uperf_sbus_srcs[] = {
	{ UPERFSRC_SYSCK, UPERF_CNT0|UPERF_CNT1, SEL0_SYSCK },
	{ UPERFSRC_PRALL, UPERF_CNT0|UPERF_CNT1, SEL0_PRALL },
	{ UPERFSRC_PRP0, UPERF_CNT0|UPERF_CNT1, SEL0_PRP0 },
	{ UPERFSRC_PRU2S, UPERF_CNT0|UPERF_CNT1, SEL0_PRUS },
	{ UPERFSRC_UPA128, UPERF_CNT0, SEL0_128BUSY },
	{ UPERFSRC_RP0, UPERF_CNT1, SEL1_RDP0 },
	{ UPERFSRC_UPA64, UPERF_CNT0, SEL0_64BUSY },
	{ UPERFSRC_P0CRMR, UPERF_CNT1, SEL1_CRMP0 },
	{ UPERFSRC_PIOS, UPERF_CNT0, SEL0_PIOSTALL },
	{ UPERFSRC_P0PIO, UPERF_CNT1, SEL1_PIOP0 },
	{ UPERFSRC_MEMRI, UPERF_CNT0|UPERF_CNT0, SEL0_MEMREQ },
	{ UPERFSRC_MCBUSY, UPERF_CNT0, SEL0_MCBUSY },
	{ UPERFSRC_MEMRC, UPERF_CNT1, SEL1_MRC},
	{ UPERFSRC_PXSH, UPERF_CNT0, SEL0_PENDSTALL },
	{ UPERFSRC_RDP0, UPERF_CNT0, SEL1_RDP1 },
	{ UPERFSRC_P0CWMR, UPERF_CNT0, SEL0_CWMRP0 },
	{ UPERFSRC_CRMP1, UPERF_CNT1, SEL1_CRMP1 },
	{ UPERFSRC_P1CWMR, UPERF_CNT0, SEL0_CWMRP1 },
	{ UPERFSRC_PIOP1, UPERF_CNT1, SEL1_PIOP1 },
	{ UPERFSRC_CIT, UPERF_CNT0, SEL0_CIT },
	{ UPERFSRC_CWXI, UPERF_CNT1, SEL1_CWXI },
	{ UPERFSRC_U2SDAT, UPERF_CNT0|UPERF_CNT1, SEL0_DACT },
	{ UPERFSRC_CRXI, UPERF_CNT0, SEL0_CRXI },
	{ -1, -1, 0 }
};

int
uperf_sbus_match(struct device *parent, void *vcf, void *aux)
{
	struct sbus_attach_args *sa = aux;

	return (strcmp(sa->sa_name, "sc") == 0);
}

void
uperf_sbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct sbus_attach_args *sa = aux;
	struct uperf_sbus_softc *sc = (struct uperf_sbus_softc *)self;
	char *model;
	u_int32_t id;

	sc->sc_bus_t = sa->sa_bustag;
	sc->sc_usc.usc_cookie = sc;
	sc->sc_usc.usc_getcntsrc = uperf_sbus_getcntsrc;
	sc->sc_usc.usc_setcntsrc = uperf_sbus_setcntsrc;
	sc->sc_usc.usc_clrcnt = uperf_sbus_clrcnt;
	sc->sc_usc.usc_getcnt = uperf_sbus_getcnt;
	sc->sc_usc.usc_srcs = uperf_sbus_srcs;

	if (sa->sa_nreg != 1) {
		printf(": expected 1 register, got %d\n", sa->sa_nreg);
		return;
	}

	if (sbus_bus_map(sc->sc_bus_t, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset, sa->sa_reg[0].sbr_size, 0, 0,
	    &sc->sc_bus_h) != 0) {
		printf(": couldn't map registers\n");
		return;
	}

	id = uperf_sbus_read_reg(sc, USC_ID);
	model = getpropstring(sa->sa_node, "model");
	if (model == NULL || strlen(model) == 0)
		model = "unknown";

	printf(": model %s (%x/%x) ports %d\n", model,
	    (id & USC_ID_IMPL_M) >> USC_ID_IMPL_S,
	    (id & USC_ID_VERS_M) >> USC_ID_VERS_S,
	    (id & USC_ID_UPANUM_M) >> USC_ID_UPANUM_S);

#ifdef DDB
	db_register_xir(uperf_sbus_xir, sc);
#endif
}

/*
 * Read from an indirect register
 */
u_int32_t
uperf_sbus_read_reg(struct uperf_sbus_softc *sc, bus_size_t r)
{
	u_int32_t v;
	int s;

	s = splhigh();
	bus_space_write_1(sc->sc_bus_t, sc->sc_bus_h, USC_ADDR, r);
	bus_space_barrier(sc->sc_bus_t, sc->sc_bus_h, USC_ADDR, 1,
	    BUS_SPACE_BARRIER_WRITE);

	/* Can't use multi reads because we have to gaurantee order */

	v = bus_space_read_1(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 0);
	bus_space_barrier(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 0, 1,
	    BUS_SPACE_BARRIER_READ);

	v <<= 8;
	v |= bus_space_read_1(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 1);
	bus_space_barrier(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 1, 1,
	    BUS_SPACE_BARRIER_READ);

	v <<= 8;
	v |= bus_space_read_1(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 2);
	bus_space_barrier(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 2, 1,
	    BUS_SPACE_BARRIER_READ);

	v <<= 8;
	v |= bus_space_read_1(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 3);
	bus_space_barrier(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 3, 1,
	    BUS_SPACE_BARRIER_READ);

	splx(s);
	return (v);
}

/*
 * Write to an indirect register
 */
void
uperf_sbus_write_reg(struct uperf_sbus_softc *sc, bus_size_t r, u_int32_t v)
{
	int s;

	s = splhigh();
	bus_space_write_1(sc->sc_bus_t, sc->sc_bus_h, USC_ADDR, r);
	bus_space_barrier(sc->sc_bus_t, sc->sc_bus_h, USC_ADDR, 1,
	    BUS_SPACE_BARRIER_WRITE);

	/* Can't use multi writes because we have to gaurantee order */

	bus_space_write_1(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 0,
	    (v >> 24) & 0xff);
	bus_space_barrier(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 0, 1,
	    BUS_SPACE_BARRIER_WRITE);

	bus_space_write_1(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 1,
	    (v >> 16) & 0xff);
	bus_space_barrier(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 1, 1,
	    BUS_SPACE_BARRIER_WRITE);

	bus_space_write_1(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 2,
	    (v >> 8) & 0xff);
	bus_space_barrier(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 2, 1,
	    BUS_SPACE_BARRIER_WRITE);

	bus_space_write_1(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 3,
	    (v >> 0) & 0xff);
	bus_space_barrier(sc->sc_bus_t, sc->sc_bus_h, USC_DATA + 3, 1,
	    BUS_SPACE_BARRIER_WRITE);
	splx(s);
}

int
uperf_sbus_clrcnt(void *vsc, int flags)
{
	struct uperf_sbus_softc *sc = vsc;
	u_int32_t clr = 0, oldsrc;

	if (flags & UPERF_CNT0)
		clr |= USC_PCTRL_CLR0;
	if (flags & UPERF_CNT1)
		clr |= USC_PCTRL_CLR1;
	if (clr) {
		oldsrc = uperf_sbus_read_reg(sc, USC_PERFCTRL);
		uperf_sbus_write_reg(sc, USC_PERFCTRL, clr | oldsrc);
	}
	return (0);
}

int
uperf_sbus_setcntsrc(void *vsc, int flags, u_int src0, u_int src1)
{
	struct uperf_sbus_softc *sc = vsc;
	u_int32_t src;

	src = uperf_sbus_read_reg(sc, USC_PERFCTRL);
	if (flags & UPERF_CNT0) {
		src &= ~USC_PCTRL_SEL0;
		src |= ((src0 << 0) & USC_PCTRL_SEL0) | USC_PCTRL_CLR0;
	}
	if (flags & UPERF_CNT1) {
		src &= ~USC_PCTRL_SEL1;
		src |= ((src1 << 8) & USC_PCTRL_SEL1) | USC_PCTRL_CLR1;
	}
	uperf_sbus_write_reg(sc, USC_PERFCTRL, src);
	return (0);
}

int
uperf_sbus_getcntsrc(void *vsc, int flags, u_int *srcp0, u_int *srcp1)
{
	struct uperf_sbus_softc *sc = vsc;
	u_int32_t src;

	src = uperf_sbus_read_reg(sc, USC_PERFCTRL);
	if (flags & UPERF_CNT0)
		*srcp0 = (src & USC_PCTRL_SEL0) >> 0;
	if (flags & UPERF_CNT1)
		*srcp1 = (src & USC_PCTRL_SEL1) >> 8;
	return (0);
}

int
uperf_sbus_getcnt(void *vsc, int flags, u_int32_t *cntp0, u_int32_t *cntp1)
{
	struct uperf_sbus_softc *sc = vsc;
	u_int32_t c0, c1;

	c0 = uperf_sbus_read_reg(sc, USC_PERF0);
	c1 = uperf_sbus_read_reg(sc, USC_PERFSHAD);
	if (flags & UPERF_CNT0)
		*cntp0 = c0;
	if (flags & UPERF_CNT1)
		*cntp1 = c1;
	return (0);
}

#ifdef DDB
void
uperf_sbus_xir(void *arg, int cpu)
{
	struct uperf_sbus_softc *sc = arg;

	uperf_sbus_write_reg(sc, USC_CTRL, USC_CTRL_XIR);
}
#endif
@


1.7
log
@ansi functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uperf_sbus.c,v 1.6 2003/06/02 18:32:41 jason Exp $	*/
d46 4
d77 4
d153 4
d299 10
@


1.6
log
@Nuke my clause 3 and 4 (and a couple of files jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: uperf_sbus.c,v 1.5 2003/03/27 17:41:43 jason Exp $	*/
d101 1
a101 3
uperf_sbus_match(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d109 1
a109 3
uperf_sbus_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d151 1
a151 3
uperf_sbus_read_reg(sc, r)
	struct uperf_sbus_softc *sc;
	bus_size_t r;
d190 1
a190 4
uperf_sbus_write_reg(sc, r, v)
	struct uperf_sbus_softc *sc;
	bus_size_t r;
	u_int32_t v;
d224 1
a224 3
uperf_sbus_clrcnt(vsc, flags)
	void *vsc;
	int flags;
d241 1
a241 4
uperf_sbus_setcntsrc(vsc, flags, src0, src1)
	void *vsc;
	int flags;
	u_int src0, src1;
d260 1
a260 4
uperf_sbus_getcntsrc(vsc, flags, srcp0, srcp1)
	void *vsc;
	int flags;
	u_int *srcp0, *srcp1;
d274 1
a274 4
uperf_sbus_getcnt(vsc, flags, cntp0, cntp1)
	void *vsc;
	int flags;
	u_int32_t *cntp0, *cntp1;
@


1.5
log
@don't need linear maps here either
@
text
@d1 1
a1 1
/*	$OpenBSD: uperf_sbus.c,v 1.4 2002/04/08 17:49:42 jason Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.4
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: uperf_sbus.c,v 1.3 2002/03/14 01:27:02 millert Exp $	*/
d139 2
a140 2
	    sa->sa_reg[0].sbr_offset, sa->sa_reg[0].sbr_size,
	    BUS_SPACE_MAP_LINEAR, 0, &sc->sc_bus_h) != 0) {
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uperf_sbus.c,v 1.2 2002/01/31 18:35:19 jason Exp $	*/
d32 5
@


1.2
log
@Move ioctl userland accessible stuff to <dev/sun/uperfio.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: uperf_sbus.c,v 1.1 2002/01/30 23:58:03 jason Exp $	*/
d51 2
a52 2
int uperf_sbus_match __P((struct device *, void *, void *));
void uperf_sbus_attach __P((struct device *, struct device *, void *));
d64 8
a71 8
u_int32_t uperf_sbus_read_reg __P((struct uperf_sbus_softc *, bus_size_t));
void uperf_sbus_write_reg __P((struct uperf_sbus_softc *,
    bus_size_t, u_int32_t));

int uperf_sbus_getcnt __P((void *, int, u_int32_t *, u_int32_t *));
int uperf_sbus_clrcnt __P((void *, int));
int uperf_sbus_getcntsrc __P((void *, int, u_int *, u_int *));
int uperf_sbus_setcntsrc __P((void *, int, u_int, u_int));
@


1.2.4.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 2
a52 2
int uperf_sbus_match(struct device *, void *, void *);
void uperf_sbus_attach(struct device *, struct device *, void *);
d64 8
a71 8
u_int32_t uperf_sbus_read_reg(struct uperf_sbus_softc *, bus_size_t);
void uperf_sbus_write_reg(struct uperf_sbus_softc *,
    bus_size_t, u_int32_t);

int uperf_sbus_getcnt(void *, int, u_int32_t *, u_int32_t *);
int uperf_sbus_clrcnt(void *, int);
int uperf_sbus_getcntsrc(void *, int, u_int *, u_int *);
int uperf_sbus_setcntsrc(void *, int, u_int, u_int);
@


1.2.4.2
log
@Sync the SMP branch with 3.3
@
text
@a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
@


1.2.4.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uperf_sbus.c,v 1.2.4.2 2003/03/28 00:38:30 niklas Exp $	*/
d139 2
a140 2
	    sa->sa_reg[0].sbr_offset, sa->sa_reg[0].sbr_size, 0, 0,
	    &sc->sc_bus_h) != 0) {
@


1.2.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uperf_sbus.c,v 1.2.4.3 2003/05/13 19:35:11 ho Exp $	*/
d15 5
@


1.2.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 3
a103 1
uperf_sbus_match(struct device *parent, void *vcf, void *aux)
d111 3
a113 1
uperf_sbus_attach(struct device *parent, struct device *self, void *aux)
d155 3
a157 1
uperf_sbus_read_reg(struct uperf_sbus_softc *sc, bus_size_t r)
d196 4
a199 1
uperf_sbus_write_reg(struct uperf_sbus_softc *sc, bus_size_t r, u_int32_t v)
d233 3
a235 1
uperf_sbus_clrcnt(void *vsc, int flags)
d252 4
a255 1
uperf_sbus_setcntsrc(void *vsc, int flags, u_int src0, u_int src1)
d274 4
a277 1
uperf_sbus_getcntsrc(void *vsc, int flags, u_int *srcp0, u_int *srcp1)
d291 4
a294 1
uperf_sbus_getcnt(void *vsc, int flags, u_int32_t *cntp0, u_int32_t *cntp1)
@


1.2.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: uperf_sbus.c,v 1.2 2002/01/31 18:35:19 jason Exp $	*/
@


1.2.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uperf_sbus.c,v 1.2.2.1 2002/01/31 22:55:39 niklas Exp $	*/
a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d51 2
a52 2
int uperf_sbus_match(struct device *, void *, void *);
void uperf_sbus_attach(struct device *, struct device *, void *);
d64 8
a71 8
u_int32_t uperf_sbus_read_reg(struct uperf_sbus_softc *, bus_size_t);
void uperf_sbus_write_reg(struct uperf_sbus_softc *,
    bus_size_t, u_int32_t);

int uperf_sbus_getcnt(void *, int, u_int32_t *, u_int32_t *);
int uperf_sbus_clrcnt(void *, int);
int uperf_sbus_getcntsrc(void *, int, u_int *, u_int *);
int uperf_sbus_setcntsrc(void *, int, u_int, u_int);
@


1.2.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d139 2
a140 2
	    sa->sa_reg[0].sbr_offset, sa->sa_reg[0].sbr_size, 0, 0,
	    &sc->sc_bus_h) != 0) {
@


1.1
log
@Driver for getting at performance counters.  These manifest them
selves as "sc at sbus" and a couple of registers on psycho (sabre
doesn't appear to have these registers).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
@

