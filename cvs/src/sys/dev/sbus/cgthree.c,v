head	1.45;
access;
symbols
	OPENBSD_6_2:1.45.0.18
	OPENBSD_6_2_BASE:1.45
	OPENBSD_6_1:1.45.0.16
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.45.0.12
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.45.0.10
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.45.0.8
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.45.0.6
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.44.0.20
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.18
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.16
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.14
	OPENBSD_5_0:1.44.0.12
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.44.0.10
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.8
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.4
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.6
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.43.0.8
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.6
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.4
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.43.0.2
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.40.0.6
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.40.0.4
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.35.0.6
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.35.0.4
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	SMP:1.11.0.2
	UBC_SYNC_B:1.25
	UBC:1.2.0.2
	UBC_BASE:1.2;
locks; strict;
comment	@ * @;


1.45
date	2013.10.20.20.07.30;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.27.17.23.03;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.17.22.18.16;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2006.07.25.21.23.32;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.06.02.20.00.56;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.15.18.40.17;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.07.16.44.52;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.01.21.23.36;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.29.22.07.40;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.01.19.24.47;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.03.21.02.13;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.27.01.36.53;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.18.17.35.30;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.17.19.47.45;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.02.18.32.41;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.31.21.01.59;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.28.03.18.03;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.27.18.11.38;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.12.19.41.20;	author henric;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.10.03.18.59;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.31.21.18.48;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.12.16.18.59;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.06.03.48.45;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.02.16.13.07;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.30.18.05.58;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.25.19.04.46;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.03.02.32.06;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.02.19.51.03;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.21.20.25.28;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.29.09.45.30;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.03.16.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.04.23.32.52;	author jason;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2002.02.24.18.51.29;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.23.05.47.50;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.07.04.48.15;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.05.20.13.17;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.05.18.34.39;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.06.00.49.41;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.04.08.22.13;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.04.05.42.30;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.05.05.34.22;	author jason;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.12.04.21.43.01;	author jason;	state Exp;
branches;
next	;

1.2.2.1
date	2002.01.31.22.55.38;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.05.19.22.14.42;	author tedu;	state Exp;
branches;
next	;

1.11.2.1
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.13.19.35.10;	author ho;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2003.06.07.11.02.32;	author ho;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2004.02.19.10.56.32;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@/*	$OpenBSD: cgthree.c,v 1.44 2008/12/27 17:23:03 miod Exp $	*/

/*
 * Copyright (c) 2001 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>
#include <machine/openfirm.h>

#include <dev/sbus/sbusvar.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>
#include <machine/fbvar.h>

#include <dev/ic/bt458reg.h>

#define	CGTHREE_CTRL_OFFSET	0x400000
#define	CGTHREE_CTRL_SIZE	(sizeof(u_int32_t) * 8)
#define	CGTHREE_VID_OFFSET	0x800000
#define	CGTHREE_VID_SIZE	(1024 * 1024)

union bt_cmap {
	u_int8_t cm_map[256][3];	/* 256 r/b/g entries */
	u_int32_t cm_chip[256 * 3 / 4];	/* the way the chip is loaded */
};

#define	BT_ADDR		0x00		/* map address register */
#define	BT_CMAP		0x04		/* colormap data register */
#define	BT_CTRL		0x08		/* control register */
#define	BT_OMAP		0x0c		/* overlay (cursor) map register */
#define	CG3_FBC_CTRL	0x10		/* control */
#define	CG3_FBC_STAT	0x11		/* status */
#define	CG3_FBC_START	0x12		/* cursor start */
#define	CG3_FBC_END	0x13		/* cursor end */
#define	CG3_FBC_VCTRL	0x14		/* 12 bytes of timing goo */

#define	BT_WRITE(sc, reg, val) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_ctrl_regs, (reg), (val))
#define	BT_READ(sc, reg) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_ctrl_regs, (reg))
#define	BT_BARRIER(sc,reg,flags) \
    bus_space_barrier((sc)->sc_bustag, (sc)->sc_ctrl_regs, (reg), \
	sizeof(u_int32_t), (flags))

#define	BT_D4M3(x)	((((x) >> 2) << 1) + ((x) >> 2)) /* (x / 4) * 3 */
#define	BT_D4M4(x)	((x) & ~3)			 /* (x / 4) * 4 */

#define	FBC_CTRL_IENAB		0x80	/* interrupt enable */
#define	FBC_CTRL_VENAB		0x40	/* video enable */
#define	FBC_CTRL_TIME		0x20	/* timing enable */
#define	FBC_CTRL_CURS		0x10	/* cursor compare enable */
#define	FBC_CTRL_XTAL		0x0c	/* xtal select (0,1,2,test): */
#define	FBC_CTRL_XTAL_0		0x00	/*  0 */
#define	FBC_CTRL_XTAL_1		0x04	/*  0 */
#define	FBC_CTRL_XTAL_2		0x08	/*  0 */
#define	FBC_CTRL_XTAL_TEST	0x0c	/*  0 */
#define	FBC_CTRL_DIV		0x03	/* divisor (1,2,3,4): */
#define	FBC_CTRL_DIV_1		0x00	/*  / 1 */
#define	FBC_CTRL_DIV_2		0x01	/*  / 2 */
#define	FBC_CTRL_DIV_3		0x02	/*  / 3 */
#define	FBC_CTRL_DIV_4		0x03	/*  / 4 */

#define	FBC_STAT_INTR		0x80	/* interrupt pending */
#define	FBC_STAT_RES		0x70	/* monitor sense: */
#define	FBC_STAT_RES_1024	0x10	/*  1024x768 */
#define	FBC_STAT_RES_1280	0x40	/*  1280x1024 */
#define	FBC_STAT_RES_1152	0x30	/*  1152x900 */
#define	FBC_STAT_RES_1152A	0x40	/*  1152x900x76, A */
#define	FBC_STAT_RES_1600	0x50	/*  1600x1200 */
#define	FBC_STAT_RES_1152B	0x60	/*  1152x900x86, B */
#define	FBC_STAT_ID		0x0f	/* id mask: */
#define	FBC_STAT_ID_COLOR	0x01	/*  color */
#define	FBC_STAT_ID_MONO	0x02	/*  monochrome */
#define	FBC_STAT_ID_MONOECL	0x03	/*  monochrome, ecl */

#define	FBC_READ(sc, reg) \
    bus_space_read_1((sc)->sc_bustag, (sc)->sc_ctrl_regs, (reg))
#define	FBC_WRITE(sc, reg, val) \
    bus_space_write_1((sc)->sc_bustag, (sc)->sc_ctrl_regs, (reg), (val))

struct cgthree_softc {
	struct sunfb sc_sunfb;
	bus_space_tag_t sc_bustag;
	bus_addr_t sc_paddr;
	bus_space_handle_t sc_ctrl_regs;
	bus_space_handle_t sc_vid_regs;
	int sc_nscreens;
	union bt_cmap sc_cmap;
	u_int sc_mode;
};

int cgthree_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t cgthree_mmap(void *, off_t, int);
int cgthree_is_console(int);
void cgthree_loadcmap(struct cgthree_softc *, u_int, u_int);
int cg3_bt_putcmap(union bt_cmap *, struct wsdisplay_cmap *);
int cg3_bt_getcmap(union bt_cmap *, struct wsdisplay_cmap *);
void cgthree_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
void cgthree_burner(void *, u_int, u_int);
void cgthree_reset(struct cgthree_softc *);

struct wsdisplay_accessops cgthree_accessops = {
	.ioctl = cgthree_ioctl,
	.mmap = cgthree_mmap,
	.burn_screen = cgthree_burner
};

int	cgthreematch(struct device *, void *, void *);
void	cgthreeattach(struct device *, struct device *, void *);

struct cfattach cgthree_ca = {
	sizeof (struct cgthree_softc), cgthreematch, cgthreeattach
};

struct cfdriver cgthree_cd = {
	NULL, "cgthree", DV_DULL
};

#define	CG3_TYPE_DEFAULT	0
#define	CG3_TYPE_76HZ		1
#define	CG3_TYPE_SMALL		2

struct cg3_videoctrl {
	u_int8_t	sense;
	u_int8_t	vctrl[12];
	u_int8_t	ctrl;
} cg3_videoctrl[] = {
	{	/* cpd-1790 */
		FBC_STAT_RES_1152 | FBC_STAT_ID_COLOR,
		{ 0xbb, 0x2b, 0x04, 0x14, 0xae, 0x03,
		  0xa8, 0x24, 0x01, 0x05, 0xff, 0x01 },
		FBC_CTRL_XTAL_0 | FBC_CTRL_DIV_1
	},
	{	/* gdm-20e20 */
		FBC_STAT_RES_1152A | FBC_STAT_ID_COLOR,
		{ 0xb7, 0x27, 0x03, 0x0f, 0xae, 0x03,
		  0xae, 0x2a, 0x01, 0x09, 0xff, 0x01 },
		FBC_CTRL_XTAL_1 | FBC_CTRL_DIV_1
	},
	{	/* defaults, should be last */
		0xff,
		{ 0xbb, 0x2b, 0x03, 0x0b, 0xb3, 0x03,
		  0xaf, 0x2b, 0x02, 0x0a, 0xff, 0x01 },
		0,
	},
};

int
cgthreematch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct sbus_attach_args *sa = aux;

	return (strcmp(cf->cf_driver->cd_name, sa->sa_name) == 0);
}

void    
cgthreeattach(struct device *parent, struct device *self, void *aux)
{
	struct cgthree_softc *sc = (struct cgthree_softc *)self;
	struct sbus_attach_args *sa = aux;
	int node, console;
	const char *nam;

	node = sa->sa_node;
	sc->sc_bustag = sa->sa_bustag;
	sc->sc_paddr = sbus_bus_addr(sa->sa_bustag, sa->sa_slot, sa->sa_offset);

	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, node, 0);

	if (sa->sa_nreg != 1) {
		printf(": expected %d registers, got %d\n", 1, sa->sa_nreg);
		goto fail;
	}

	/*
	 * Map just CTRL and video RAM.
	 */
	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGTHREE_CTRL_OFFSET,
	    CGTHREE_CTRL_SIZE, 0, 0, &sc->sc_ctrl_regs) != 0) {
		printf(": cannot map ctrl registers\n");
		goto fail_ctrl;
	}

	if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[0].sbr_slot,
	    sa->sa_reg[0].sbr_offset + CGTHREE_VID_OFFSET,
	    sc->sc_sunfb.sf_fbsize, BUS_SPACE_MAP_LINEAR,
	    0, &sc->sc_vid_regs) != 0) {
		printf(": cannot map vid registers\n");
		goto fail_vid;
	}

	nam = getpropstring(node, "model");
	if (*nam == '\0')
		nam = sa->sa_name;
	printf(": %s", nam);

	console = cgthree_is_console(node);

	cgthree_reset(sc);
	cgthree_burner(sc, 1, 0);

	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
	    sc->sc_vid_regs);
	sc->sc_sunfb.sf_ro.ri_hw = sc;

	printf(", %dx%d\n", sc->sc_sunfb.sf_width, sc->sc_sunfb.sf_height);

	fbwscons_init(&sc->sc_sunfb, 0, console);
	fbwscons_setcolormap(&sc->sc_sunfb, cgthree_setcolor);

	if (console)
		fbwscons_console_init(&sc->sc_sunfb, -1);

	fbwscons_attach(&sc->sc_sunfb, &cgthree_accessops, console);

	return;

fail_vid:
	bus_space_unmap(sa->sa_bustag, sc->sc_ctrl_regs, CGTHREE_CTRL_SIZE);
fail_ctrl:
fail:
;
}

int
cgthree_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct cgthree_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cm;
	int error;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG3;
		break;
	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (void *)data;
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cg3_bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		error = cg3_bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgthree_loadcmap(sc, cm->index, cm->count);
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return -1; /* not supported yet */
        }

	return (0);
}

#define	START		(128 * 1024 + 128 * 1024)
#define	NOOVERLAY	(0x04000000)

paddr_t
cgthree_mmap(void *v, off_t offset, int prot)
{
	struct cgthree_softc *sc = v;

	if (offset & PGOFSET || offset < 0)
		return (-1);

	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
		if (offset >= NOOVERLAY)
			offset -= NOOVERLAY;
		else if (offset >= START)
			offset -= START;
		else
			offset = 0;
		if (offset >= sc->sc_sunfb.sf_fbsize)
			return (-1);
		return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
		    CGTHREE_VID_OFFSET + offset, prot, BUS_SPACE_MAP_LINEAR));
	case WSDISPLAYIO_MODE_DUMBFB:
		if (offset < sc->sc_sunfb.sf_fbsize)
			return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
			    CGTHREE_VID_OFFSET + offset, prot,
			    BUS_SPACE_MAP_LINEAR));
		break;
	}
	return (-1);
}

int
cgthree_is_console(int node)
{
	extern int fbnode;

	return (fbnode == node);
}

void
cgthree_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct cgthree_softc *sc = v;
	union bt_cmap *bcm = &sc->sc_cmap;

	bcm->cm_map[index][0] = r;
	bcm->cm_map[index][1] = g;
	bcm->cm_map[index][2] = b;
	cgthree_loadcmap(sc, index, 1);
}

void
cgthree_loadcmap(struct cgthree_softc *sc, u_int start, u_int ncolors)
{
	u_int cstart;
	int count;

	cstart = BT_D4M3(start);
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	BT_WRITE(sc, BT_ADDR, BT_D4M4(start));
	while (--count >= 0) {
		BT_WRITE(sc, BT_CMAP, sc->sc_cmap.cm_chip[cstart]);
		cstart++;
	}
}

int
cg3_bt_getcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyout(&bcm->cm_map[index + i][0],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][1],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][2],
		    &rcm->blue[i], 1)) != 0)
			return (error);
	}
	return (0);
}

int
cg3_bt_putcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &bcm->cm_map[index + i][0], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &bcm->cm_map[index + i][1], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &bcm->cm_map[index + i][2], 1)) != 0)
			return (error);
	}
	return (0);
}

void
cgthree_reset(struct cgthree_softc *sc)
{
	int i, j;
	u_int8_t sts, ctrl;

	sts = FBC_READ(sc, CG3_FBC_STAT);
	ctrl = FBC_READ(sc, CG3_FBC_CTRL);

	if (ctrl & FBC_CTRL_TIME) {
		/* already initialized */
		return;
	}

	for (i = 0; i < nitems(cg3_videoctrl); i++) {
		if (cg3_videoctrl[i].sense == 0xff ||
		    (cg3_videoctrl[i].sense ==
		     (sts & (FBC_STAT_RES | FBC_STAT_ID)))) {
			for (j = 0; j < 12; j++)
				FBC_WRITE(sc, CG3_FBC_VCTRL + j,
				    cg3_videoctrl[i].vctrl[j]);
			ctrl &= ~(FBC_CTRL_XTAL | FBC_CTRL_DIV);
			ctrl |= cg3_videoctrl[i].ctrl |
			    FBC_CTRL_TIME;
			FBC_WRITE(sc, CG3_FBC_CTRL, ctrl);
			break;
		}
	}

	/* enable all the bit planes */
	BT_WRITE(sc, BT_ADDR, BT_RMR);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0xff);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/* no plane should blink */
	BT_WRITE(sc, BT_ADDR, BT_BMR);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/*
	 * enable the RAMDAC, disable blink, disable overlay 0 and 1,
	 * use 4:1 multiplexor.
	 */
	BT_WRITE(sc, BT_ADDR, BT_CR);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL,
	    (BTCR_MPLX_4 | BTCR_RAMENA | BTCR_BLINK_6464));
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	/* disable the D/A read pins */
	BT_WRITE(sc, BT_ADDR, BT_CTR);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);
}

void
cgthree_burner(void *vsc, u_int on, u_int flags)
{
	struct cgthree_softc *sc = vsc;
	int s;
	u_int8_t fbc;

	s = splhigh();
	fbc = FBC_READ(sc, CG3_FBC_CTRL);
	if (on)
		fbc |= FBC_CTRL_VENAB | FBC_CTRL_TIME;
	else {
		fbc &= ~FBC_CTRL_VENAB;
		if (flags & WSDISPLAY_BURN_VBLANK)
			fbc &= ~FBC_CTRL_TIME;
	}
	FBC_WRITE(sc, CG3_FBC_CTRL, fbc);
	splx(s);
}
@


1.44
log
@Sync the sparc64 fb* api with the recent changes done on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.43 2006/12/17 22:18:16 miod Exp $	*/
d141 3
a143 9
	cgthree_ioctl,
	cgthree_mmap,
	NULL,	/* alloc_screen */
	NULL,	/* free_screen */
	NULL,	/* show_screen */
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgthree_burner,
@


1.43
log
@Remove unnecessary <dev/wscons/wscons_raster.h> inclusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.42 2006/07/25 21:23:32 miod Exp $	*/
a130 5
int cgthree_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgthree_free_screen(void *, void *);
int cgthree_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
d143 3
a145 3
	cgthree_alloc_screen,
	cgthree_free_screen,
	cgthree_show_screen,
d173 1
a173 1
		0x31,
d179 1
a179 1
		0x41,
d254 1
a254 15
	/*
	 * If the framebuffer width is under 1024x768, which is the case for
	 * some clones on laptops, as well as with the VS10-EK, switch from
	 * the PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
	 */
	fbwscons_init(&sc->sc_sunfb, console &&
	    (sc->sc_sunfb.sf_width >= 1024) ? 0 : RI_CLEAR);

d257 2
a258 4
	if (console) {
		fbwscons_console_init(&sc->sc_sunfb,
		    sc->sc_sunfb.sf_width >= 1024 ? -1 : 0);
	}
a327 33
int
cgthree_alloc_screen(void *v, const struct wsscreen_descr *type,
    void **cookiep, int *curxp, int *curyp, long *attrp)
{
	struct cgthree_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return (ENOMEM);

	*cookiep = &sc->sc_sunfb.sf_ro;
	*curyp = 0;
	*curxp = 0;
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
	sc->sc_nscreens++;
	return (0);
}

void
cgthree_free_screen(void *v, void *cookie)
{
	struct cgthree_softc *sc = v;

	sc->sc_nscreens--;
}

int
cgthree_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return (0);
}

d454 1
a454 1
	for (i = 0; i <  sizeof(cg3_videoctrl)/sizeof(cg3_videoctrl[0]); i++) {
@


1.42
log
@Do not bother reading the existing colormap on attach, since we will
override it with the rasops one.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.41 2006/06/02 20:00:56 miod Exp $	*/
a49 1
#include <dev/wscons/wscons_raster.h>
@


1.41
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.40 2005/03/15 18:40:17 miod Exp $	*/
d212 1
a212 1
	int node, console, i;
a251 5

	BT_WRITE(sc, BT_ADDR, 0);
	for (i = 0; i < 256 * 3 / 4; i++)
		sc->sc_cmap.cm_chip[i] = BT_READ(sc, BT_CMAP);

@


1.40
log
@Take care of updating the PROMs view of the cursor position in the common fb
code, rather than doing this in only a subset of the fb drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.39 2005/03/07 16:44:52 miod Exp $	*/
a121 1
	struct sbusdev sc_sd;
a249 2

	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
@


1.39
log
@Do not bother passing the blanking routine to fbwscons_console_init(),
as fbwscons_attach() can find it on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.38 2005/03/01 21:23:36 miod Exp $	*/
a145 1
void cgthree_updatecursor(struct rasops_info *);
a285 1
		sc->sc_sunfb.sf_ro.ri_updatecursor = cgthree_updatecursor;
a578 11
}

void
cgthree_updatecursor(struct rasops_info *ri)
{
	struct cgthree_softc *sc = ri->ri_hw;

	if (sc->sc_sunfb.sf_crowp != NULL)
		*sc->sc_sunfb.sf_crowp = ri->ri_crow;
	if (sc->sc_sunfb.sf_ccolp != NULL)
		*sc->sc_sunfb.sf_ccolp = ri->ri_ccol;
@


1.38
log
@Display hardware name and display resolution at attach time, as done on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.37 2005/01/05 23:04:25 miod Exp $	*/
d289 1
a289 1
		    sc->sc_sunfb.sf_width >= 1024 ? -1 : 0, cgthree_burner);
@


1.37
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.36 2004/11/29 22:07:40 miod Exp $	*/
d214 2
a215 1
	int console, i;
d217 1
d221 1
a221 1
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, sa->sa_node, 0);
d246 6
a251 1
	console = cgthree_is_console(sa->sa_node);
d267 1
a267 1
	printf("\n");
@


1.36
log
@Move the struct wsscreen_descr from a per-driver global to a per-instance
field of the sunfb structure. This allows multiple instances of the same driver,
but with different resolutions (such as a couple of vigra or a TGX cgsix and
a TGX+ cgsix) to use distinct wsscreen_descr structures featuring different
resolution information.

Doing this allows more wsscreen_descr fiddling inside the sparc* fb api,
and results in some code shrinkage (about 4KB on sparc GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.35 2003/08/01 19:24:47 miod Exp $	*/
d339 2
@


1.35
log
@The Vigra VS10-EK is recognized as a cgthree clone, but due to its utterly
ridiculous resolution, we need to plug the "clear the screen and switch font"
trick here too.

[Thanks to Andrey Smagin for providing a card for testing]
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.34 2003/07/03 21:02:13 jason Exp $	*/
a131 13
struct wsscreen_descr cgthree_stdscreen = {
	"std",
};

const struct wsscreen_descr *cgthree_scrlist[] = {
	&cgthree_stdscreen,
	/* XXX other formats? */
};

struct wsscreen_list cgthree_screenlist = {
	sizeof(cgthree_scrlist) / sizeof(struct wsscreen_descr *), cgthree_scrlist
};

a213 1
	struct wsemuldisplaydev_attach_args waa;
a276 5
	cgthree_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgthree_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgthree_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgthree_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;

d281 1
a281 1
		fbwscons_console_init(&sc->sc_sunfb, &cgthree_stdscreen,
d285 1
a285 5
	waa.console = console;
	waa.scrdata = &cgthree_screenlist;
	waa.accessops = &cgthree_accessops;
	waa.accesscookie = sc;
	config_found(self, &waa, wsemuldisplaydevprint);
@


1.34
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.33 2003/06/27 01:36:53 jason Exp $	*/
d273 17
a289 1
	fbwscons_init(&sc->sc_sunfb, console ? 0 : RI_CLEAR);
a295 2
	printf("\n");

d300 2
a301 2
		fbwscons_console_init(&sc->sc_sunfb, &cgthree_stdscreen, -1,
		    cgthree_burner);
@


1.33
log
@These don't need linear mappings either.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.32 2003/06/18 17:35:30 miod Exp $	*/
d214 1
a214 3
cgthreematch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
d223 1
a223 3
cgthreeattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d306 1
a306 6
cgthree_ioctl(v, cmd, data, flags, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d361 2
a362 6
cgthree_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d379 1
a379 3
cgthree_free_screen(v, cookie)
	void *v;
	void *cookie;
d387 2
a388 6
cgthree_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d397 1
a397 4
cgthree_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d427 1
a427 2
cgthree_is_console(node)
	int node;
d447 1
a447 3
cgthree_loadcmap(sc, start, ncolors)
	struct cgthree_softc *sc;
	u_int start, ncolors;
d462 1
a462 3
cg3_bt_getcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d484 1
a484 3
cg3_bt_putcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
d506 1
a506 2
cgthree_reset(sc)
	struct cgthree_softc *sc;
d564 1
a564 3
cgthree_burner(vsc, on, flags)
	void *vsc;
	u_int on, flags;
d584 1
a584 2
cgthree_updatecursor(ri)
	struct rasops_info *ri;
@


1.32
log
@Switch to fbxxx() API.
cgsix tested and ok jason@@, the rest tested by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.31 2003/06/17 19:47:45 miod Exp $	*/
d249 1
a249 2
	    CGTHREE_CTRL_SIZE, BUS_SPACE_MAP_LINEAR,
	    0, &sc->sc_ctrl_regs) != 0) {
@


1.31
log
@A few typos in the Bt initialisation sequence were introduced in 1.29, and
curiously this only broke some cgthree clones, but not the genuine Sun's...
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.30 2003/06/02 18:32:41 jason Exp $	*/
d52 2
d121 1
a121 1
	struct device sc_dev;
a127 1
	int sc_width, sc_height, sc_depth, sc_linebytes;
a128 1
	struct rasops_info sc_rasops;
a129 1
	int *sc_crowp, *sc_ccolp;
a133 5
	0, 0,	/* will be filled in -- XXX shouldn't, it's global. */
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d156 1
a156 2
void cgthree_setcolor(struct cgthree_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t);
a159 1
static int a2int(char *, int);
a232 1
	long defattr;
d237 1
a237 4
	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);
d257 1
a257 1
	    sc->sc_linebytes * sc->sc_height, BUS_SPACE_MAP_LINEAR,
d265 1
a265 1
	sbus_establish(&sc->sc_sd, &sc->sc_dev);
d275 1
a275 5
	sc->sc_rasops.ri_depth = sc->sc_depth;
	sc->sc_rasops.ri_stride = sc->sc_linebytes;
	sc->sc_rasops.ri_flg = RI_CENTER |
	    (console ? 0 : RI_CLEAR);
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
d277 7
a283 14
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));

	cgthree_stdscreen.nrows = sc->sc_rasops.ri_rows;
	cgthree_stdscreen.ncols = sc->sc_rasops.ri_cols;
	cgthree_stdscreen.textops = &sc->sc_rasops.ri_ops;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
	sc->sc_rasops.ri_hw = sc;
d287 1
a287 9
	cgthree_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
	cgthree_setcolor(sc, 255, 0, 0, 0);
	cgthree_setcolor(sc, WSCOL_RED, 255, 0, 0);
	cgthree_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
	cgthree_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
	cgthree_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
	cgthree_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
	cgthree_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
	cgthree_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
d290 3
a292 10
		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_ccolp = sc->sc_crowp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;
		sc->sc_rasops.ri_updatecursor = cgthree_updatecursor;

		wsdisplay_cnattach(&cgthree_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
d332 3
a334 3
		wdf->height = sc->sc_height;
		wdf->width  = sc->sc_width;
		wdf->depth  = sc->sc_depth;
d338 1
a338 1
		*(u_int *)data = sc->sc_linebytes;
d383 1
a383 1
	*cookiep = &sc->sc_rasops;
d386 1
a386 1
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
d435 1
a435 1
		if (offset >= sc->sc_linebytes * sc->sc_height)
d440 1
a440 1
		if (offset < (sc->sc_linebytes * sc->sc_height))
a448 12
static int
a2int(char *cp, int deflt)
{
	int i = 0;

	if (*cp == '\0')
		return (deflt);
	while (*cp != '\0')
		i = i * 10 + *cp++ - '0';
	return (i);
}

d459 1
a459 4
cgthree_setcolor(sc, index, r, g, b)
	struct cgthree_softc *sc;
	u_int index;
	u_int8_t r, g, b;
d461 1
d622 4
a625 4
	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.30
log
@Nuke my clause 3 and 4 (and a couple of files jointly (c) with Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.29 2003/05/31 21:01:59 jason Exp $	*/
d636 1
a636 1
	    (BTCR_MPLX_4 | BTCR_RAMENA | BTCR_BLINK_6464) << 24);
d640 1
a640 1
	BT_WRITE(sc, BT_ADDR, BT_CTR << 24);
d642 1
a642 1
	BT_WRITE(sc, BT_CTRL, 0x00 << 24);
@


1.29
log
@real register definitions for the brooktree 451/457/458 on the cgsix and
cgthree.  ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.28 2003/03/28 03:18:03 jason Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.28
log
@Use the brand new types instead of WSDISPLAY_TYPE_UNKNOWN
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.27 2003/03/27 18:11:38 jason Exp $	*/
d57 1
d622 2
a623 1
	BT_WRITE(sc, BT_ADDR, 0x04);
d628 2
a629 1
	BT_WRITE(sc, BT_ADDR, 0x05);
d634 5
a638 1
	BT_WRITE(sc, BT_ADDR, 0x06);
d640 2
a641 1
	BT_WRITE(sc, BT_CTRL, 0x70);
d644 2
a645 1
	BT_WRITE(sc, BT_ADDR, 0x07);
d647 1
a647 1
	BT_WRITE(sc, BT_CTRL, 0x00);
@


1.27
log
@map vid mem based on linebytes and height
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.26 2003/02/12 19:41:20 henric Exp $	*/
d367 1
a367 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN;
@


1.26
log
@Labels must be followed by a statement.  (Pointed out by gcc3.)

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.25 2002/09/10 03:18:59 jason Exp $	*/
d250 5
d273 1
a273 1
	    CGTHREE_VID_SIZE, BUS_SPACE_MAP_LINEAR,
a279 5

	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);
@


1.25
log
@Register more wsscreen properties to take advantage of wsemul_sun changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.24 2002/08/31 21:18:48 jason Exp $	*/
d349 1
@


1.24
log
@Always setup the RAMDAC (even if we're not the console) so when the display
is cleared, it's cleared to a known color (white instead of whatever is put
in the ramdac by the prom, usually cyan).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.23 2002/08/12 16:18:59 jason Exp $	*/
d142 1
@


1.23
log
@Update rom cursor position if we're the console framebuffer
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.22 2002/08/06 03:48:45 jason Exp $	*/
d313 10
a323 10
		cgthree_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
		cgthree_setcolor(sc, 255, 0, 0, 0);
		cgthree_setcolor(sc, WSCOL_RED, 255, 0, 0);
		cgthree_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
		cgthree_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
		cgthree_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
		cgthree_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
		cgthree_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
		cgthree_setcolor(sc, WSCOL_WHITE, 255, 255, 255);

@


1.22
log
@Set RI_CLEAR if the card isn't the console framebuffer; based on discussion with miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.21 2002/08/02 16:13:07 millert Exp $	*/
d134 1
d169 1
d309 1
a313 2
		int *ccolp, *crowp;

d324 7
a330 6
		if (romgetcursoraddr(&crowp, &ccolp))
			ccolp = crowp = NULL;
		if (ccolp != NULL)
			sc->sc_rasops.ri_ccol = *ccolp;
		if (crowp != NULL)
			sc->sc_rasops.ri_crow = *crowp;
d660 12
@


1.21
log
@Do correct bounds checking in get/set/put cmap routines.  A few of
these check were already OK but have been modified for consistency.
Problem found by Silvio Cesare.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.20 2002/07/30 18:05:58 jason Exp $	*/
d290 2
a291 1
	sc->sc_rasops.ri_flg = RI_CENTER;
@


1.20
log
@handle dumbfb and mapped mode requests differently
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.19 2002/07/25 19:04:46 miod Exp $	*/
d546 1
a546 1
	if (index >= 256 || index + count > 256)
d570 1
a570 2
	if (index >= 256 || rcm->count > 256 ||
	    (rcm->index + rcm->count) > 256)
@


1.19
log
@Adapt the framebuffer code to the WSDISPLAY_TYPE constant changes, and
add the necessary magic for wsemul_sun color handling.

Initially based on a patch from jason@@, then some tinkering by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.18 2002/06/03 02:32:06 jason Exp $	*/
d133 1
d313 1
a313 1
		cgthree_setcolor(sc, 255, 255, 255, 255);
d364 3
d461 1
a461 1
	if (offset & PGOFSET)
d464 10
a473 1
	if (offset >= 0 && offset < (sc->sc_linebytes * sc->sc_height))
d476 7
a482 1

@


1.18
log
@Convert from rcons to rasops
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.17 2002/06/02 19:51:03 jason Exp $	*/
d304 1
a304 1
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, &defattr);
d420 1
a420 1
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, attrp);
@


1.17
log
@Turn off timing if WSDISPLAY_BURN_VBLANK is set (which in turn puts most
monitors in standby).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.16 2002/05/21 20:25:28 jason Exp $	*/
d56 1
a56 1
#include <dev/rcons/raster.h>
a130 2
	struct rcons sc_rcons;
	struct raster sc_raster;
d132 1
a132 11
};

struct wsdisplay_emulops cgthree_emulops = {
	rcons_cursor,
	rcons_mapchar,
	rcons_putchar,
	rcons_copycols,
	rcons_erasecols,
	rcons_copyrows,
	rcons_eraserows,
	rcons_alloc_attr
d287 4
a290 6
	sc->sc_rcons.rc_sp = &sc->sc_raster;
	sc->sc_raster.width = sc->sc_width;
	sc->sc_raster.height = sc->sc_height;
	sc->sc_raster.depth = sc->sc_depth;
	sc->sc_raster.linelongs = sc->sc_linebytes / 4;
	sc->sc_raster.pixels = (void *)bus_space_vaddr(sc->sc_bustag,
d292 13
a304 20

	if (console == 0 ||
	    romgetcursoraddr(&sc->sc_rcons.rc_crowp, &sc->sc_rcons.rc_ccolp)) {
		sc->sc_rcons.rc_crow = sc->sc_rcons.rc_ccol = -1;
		sc->sc_rcons.rc_crowp = &sc->sc_rcons.rc_crow;
		sc->sc_rcons.rc_ccolp = &sc->sc_rcons.rc_ccol;
	}

	sc->sc_rcons.rc_maxcol =
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80);
	sc->sc_rcons.rc_maxrow =
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34);

	rcons_init(&sc->sc_rcons,
	    sc->sc_rcons.rc_maxrow, sc->sc_rcons.rc_maxcol);

	cgthree_stdscreen.nrows = sc->sc_rcons.rc_maxrow;
	cgthree_stdscreen.ncols = sc->sc_rcons.rc_maxcol;
	cgthree_stdscreen.textops = &cgthree_emulops;
	rcons_alloc_attr(&sc->sc_rcons, 0, 0, 0, &defattr);
d309 2
d321 9
a329 2
		wsdisplay_cnattach(&cgthree_stdscreen, &sc->sc_rcons,
		    *sc->sc_rcons.rc_ccolp, *sc->sc_rcons.rc_crowp, defattr);
d416 5
a420 4
	*cookiep = &sc->sc_rcons;
	*curyp = *sc->sc_rcons.rc_crowp;
	*curxp = *sc->sc_rcons.rc_ccolp;
	rcons_alloc_attr(&sc->sc_rcons, 0, 0, 0, attrp);
@


1.16
log
@Enable the blanker now that the X stuff is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.15 2002/04/08 17:49:42 jason Exp $	*/
d637 1
a637 1
	u_int32_t fbc;
d642 2
a643 2
		fbc |= FBC_CTRL_VENAB;
	else
d645 3
@


1.15
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.14 2002/03/29 09:45:30 fgsch Exp $	*/
d190 1
a190 1
	NULL,	/* burner */
@


1.14
log
@o remove extra args in printf's.
o remove unneded struct.
o change error to match reality.

jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.13 2002/03/14 03:16:07 millert Exp $	*/
d32 5
@


1.13
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.12 2002/03/14 01:27:02 millert Exp $	*/
d265 2
a266 2
		printf(": cannot map bt registers\n", self->dv_xname);
		goto fail_bt;
d273 1
a273 1
		printf(": cannot map vid registers\n", self->dv_xname);
d349 1
a349 1
fail_bt:
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.11 2002/03/04 23:32:52 jason Exp $	*/
d163 2
a164 2
int cgthree_show_screen __P((void *, void *, int,
    void (*cb)(void *, int, int), void *));
@


1.11
log
@Disable the wscons burner functionality... I'm not in the mood to debug it right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.10 2002/02/24 18:51:29 jason Exp $	*/
d159 4
a162 4
int cgthree_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
int cgthree_alloc_screen __P((void *, const struct wsscreen_descr *, void **,
    int *, int *, long *));
void cgthree_free_screen __P((void *, void *));
d164 11
a174 11
    void (*cb) __P((void *, int, int)), void *));
paddr_t cgthree_mmap __P((void *, off_t, int));
int cgthree_is_console __P((int));
void cgthree_loadcmap __P((struct cgthree_softc *, u_int, u_int));
int cg3_bt_putcmap __P((union bt_cmap *, struct wsdisplay_cmap *));
int cg3_bt_getcmap __P((union bt_cmap *, struct wsdisplay_cmap *));
void cgthree_setcolor __P((struct cgthree_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t));
void cgthree_burner __P((void *, u_int, u_int));
void cgthree_reset __P((struct cgthree_softc *));
static int a2int __P((char *, int));
d188 2
a189 2
int	cgthreematch	__P((struct device *, void *, void *));
void	cgthreeattach	__P((struct device *, struct device *, void *));
d446 1
a446 1
	void (*cb) __P((void *, int, int));
@


1.11.2.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d159 16
a174 16
int cgthree_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgthree_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgthree_free_screen(void *, void *);
int cgthree_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgthree_mmap(void *, off_t, int);
int cgthree_is_console(int);
void cgthree_loadcmap(struct cgthree_softc *, u_int, u_int);
int cg3_bt_putcmap(union bt_cmap *, struct wsdisplay_cmap *);
int cg3_bt_getcmap(union bt_cmap *, struct wsdisplay_cmap *);
void cgthree_setcolor(struct cgthree_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t);
void cgthree_burner(void *, u_int, u_int);
void cgthree_reset(struct cgthree_softc *);
static int a2int(char *, int);
d188 2
a189 2
int	cgthreematch(struct device *, void *, void *);
void	cgthreeattach(struct device *, struct device *, void *);
d446 1
a446 1
	void (*cb)(void *, int, int);
@


1.11.2.2
log
@Sync the SMP branch with 3.3
@
text
@a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d51 1
a51 1
#include <dev/rasops/rasops.h>
d126 2
d129 11
a139 3
	struct rasops_info sc_rasops;
	u_int sc_mode;
	int *sc_crowp, *sc_ccolp;
a146 1
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
a173 1
void cgthree_updatecursor(struct rasops_info *);
d185 1
a185 1
	cgthree_burner,
d265 2
a266 2
		printf(": cannot map ctrl registers\n");
		goto fail_ctrl;
d273 1
a273 1
		printf(": cannot map vid registers\n");
d294 6
a299 5
	sc->sc_rasops.ri_depth = sc->sc_depth;
	sc->sc_rasops.ri_stride = sc->sc_linebytes;
	sc->sc_rasops.ri_flg = RI_CENTER |
	    (console ? 0 : RI_CLEAR);
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
d301 20
a320 14
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));

	cgthree_stdscreen.nrows = sc->sc_rasops.ri_rows;
	cgthree_stdscreen.ncols = sc->sc_rasops.ri_cols;
	cgthree_stdscreen.textops = &sc->sc_rasops.ri_ops;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
	sc->sc_rasops.ri_hw = sc;
a323 10
	cgthree_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
	cgthree_setcolor(sc, 255, 0, 0, 0);
	cgthree_setcolor(sc, WSCOL_RED, 255, 0, 0);
	cgthree_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
	cgthree_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
	cgthree_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
	cgthree_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
	cgthree_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
	cgthree_setcolor(sc, WSCOL_WHITE, 255, 255, 255);

d325 9
a333 7
		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_ccolp = sc->sc_crowp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;
		sc->sc_rasops.ri_updatecursor = cgthree_updatecursor;
d335 2
a336 2
		wsdisplay_cnattach(&cgthree_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
d349 1
a349 1
fail_ctrl:
a350 1
;
a369 3
	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		break;
d423 4
a426 5
	*cookiep = &sc->sc_rasops;
	*curyp = 0;
	*curxp = 0;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
d463 1
a463 1
	if (offset & PGOFSET || offset < 0)
d466 1
a466 10
	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
		if (offset >= NOOVERLAY)
			offset -= NOOVERLAY;
		else if (offset >= START)
			offset -= START;
		else
			offset = 0;
		if (offset >= sc->sc_linebytes * sc->sc_height)
			return (-1);
d469 1
a469 7
	case WSDISPLAYIO_MODE_DUMBFB:
		if (offset < (sc->sc_linebytes * sc->sc_height))
			return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
			    CGTHREE_VID_OFFSET + offset, prot,
			    BUS_SPACE_MAP_LINEAR));
		break;
	}
d533 1
a533 1
	if (index >= 256 || count > 256 - index)
d557 2
a558 1
	if (index >= 256 || count > 256 - index)
d632 1
a632 1
	u_int8_t fbc;
d637 2
a638 2
		fbc |= FBC_CTRL_VENAB | FBC_CTRL_TIME;
	else {
a639 3
		if (flags & WSDISPLAY_BURN_VBLANK)
			fbc &= ~FBC_CTRL_TIME;
	}
a641 12
}

void
cgthree_updatecursor(ri)
	struct rasops_info *ri;
{
	struct cgthree_softc *sc = ri->ri_hw;

	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.11.2.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.11.2.2 2003/03/28 00:38:29 niklas Exp $	*/
a249 5
	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);

d268 1
a268 1
	    sc->sc_linebytes * sc->sc_height, BUS_SPACE_MAP_LINEAR,
d276 5
d367 1
a367 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG3;
@


1.11.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.11.2.3 2003/05/13 19:35:10 ho Exp $	*/
d15 5
a56 1
#include <dev/ic/bt458reg.h>
d621 1
a621 2
	/* enable all the bit planes */
	BT_WRITE(sc, BT_ADDR, BT_RMR);
d626 1
a626 2
	/* no plane should blink */
	BT_WRITE(sc, BT_ADDR, BT_BMR);
d631 1
a631 5
	/*
	 * enable the RAMDAC, disable blink, disable overlay 0 and 1,
	 * use 4:1 multiplexor.
	 */
	BT_WRITE(sc, BT_ADDR, BT_CR);
d633 1
a633 2
	BT_WRITE(sc, BT_CTRL,
	    (BTCR_MPLX_4 | BTCR_RAMENA | BTCR_BLINK_6464) << 24);
d636 1
a636 2
	/* disable the D/A read pins */
	BT_WRITE(sc, BT_ADDR, BT_CTR << 24);
d638 1
a638 1
	BT_WRITE(sc, BT_CTRL, 0x00 << 24);
@


1.11.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a51 2
#include <machine/fbvar.h>

d119 1
a119 1
	struct sunfb sc_sunfb;
d126 1
d128 1
d130 1
d135 5
d162 2
a163 1
void cgthree_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
d167 1
d222 3
a224 1
cgthreematch(struct device *parent, void *vcf, void *aux)
d233 3
a235 1
cgthreeattach(struct device *parent, struct device *self, void *aux)
d241 1
d246 4
a249 1
	fb_setsize(&sc->sc_sunfb, 8, 1152, 900, sa->sa_node, 0);
d261 2
a262 1
	    CGTHREE_CTRL_SIZE, 0, 0, &sc->sc_ctrl_regs) != 0) {
d269 1
a269 1
	    sc->sc_sunfb.sf_fbsize, BUS_SPACE_MAP_LINEAR,
d277 1
a277 1
	sbus_establish(&sc->sc_sd, &sc->sc_sunfb.sf_dev);
d287 5
a291 1
	sc->sc_sunfb.sf_ro.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
d293 14
a306 1
	sc->sc_sunfb.sf_ro.ri_hw = sc;
d310 9
a318 19
	/*
	 * If the framebuffer width is under 1024x768, which is the case for
	 * some clones on laptops, as well as with the VS10-EK, switch from
	 * the PROM font to the more adequate 8x16 font here.
	 * However, we need to adjust two things in this case:
	 * - the display row should be overrided from the current PROM metrics,
	 *   to prevent us from overwriting the last few lines of text.
	 * - if the 80x34 screen would make a large margin appear around it,
	 *   choose to clear the screen rather than keeping old prom output in
	 *   the margins.
	 * XXX there should be a rasops "clear margins" feature
	 */
	fbwscons_init(&sc->sc_sunfb, console &&
	    (sc->sc_sunfb.sf_width >= 1024) ? 0 : RI_CLEAR);

	cgthree_stdscreen.capabilities = sc->sc_sunfb.sf_ro.ri_caps;
	cgthree_stdscreen.nrows = sc->sc_sunfb.sf_ro.ri_rows;
	cgthree_stdscreen.ncols = sc->sc_sunfb.sf_ro.ri_cols;
	cgthree_stdscreen.textops = &sc->sc_sunfb.sf_ro.ri_ops;
d320 8
a327 1
	fbwscons_setcolormap(&sc->sc_sunfb, cgthree_setcolor);
d329 2
a330 4
	if (console) {
		sc->sc_sunfb.sf_ro.ri_updatecursor = cgthree_updatecursor;
		fbwscons_console_init(&sc->sc_sunfb, &cgthree_stdscreen,
		    sc->sc_sunfb.sf_width >= 1024 ? -1 : 0, cgthree_burner);
d349 6
a354 1
cgthree_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
d370 3
a372 3
		wdf->height = sc->sc_sunfb.sf_height;
		wdf->width  = sc->sc_sunfb.sf_width;
		wdf->depth  = sc->sc_sunfb.sf_depth;
d376 1
a376 1
		*(u_int *)data = sc->sc_sunfb.sf_linebytes;
d409 6
a414 2
cgthree_alloc_screen(void *v, const struct wsscreen_descr *type,
    void **cookiep, int *curxp, int *curyp, long *attrp)
d421 1
a421 1
	*cookiep = &sc->sc_sunfb.sf_ro;
d424 1
a424 1
	sc->sc_sunfb.sf_ro.ri_ops.alloc_attr(&sc->sc_sunfb.sf_ro,
d431 3
a433 1
cgthree_free_screen(void *v, void *cookie)
d441 6
a446 2
cgthree_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
d455 4
a458 1
cgthree_mmap(void *v, off_t offset, int prot)
d473 1
a473 1
		if (offset >= sc->sc_sunfb.sf_fbsize)
d478 1
a478 1
		if (offset < sc->sc_sunfb.sf_fbsize)
d487 12
d500 2
a501 1
cgthree_is_console(int node)
d509 4
a512 1
cgthree_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
a513 1
	struct cgthree_softc *sc = v;
d523 3
a525 1
cgthree_loadcmap(struct cgthree_softc *sc, u_int start, u_int ncolors)
d540 3
a542 1
cg3_bt_getcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
d564 3
a566 1
cg3_bt_putcmap(union bt_cmap *bcm, struct wsdisplay_cmap *rcm)
d588 2
a589 1
cgthree_reset(struct cgthree_softc *sc)
d636 1
a636 1
	    (BTCR_MPLX_4 | BTCR_RAMENA | BTCR_BLINK_6464));
d640 1
a640 1
	BT_WRITE(sc, BT_ADDR, BT_CTR);
d642 1
a642 1
	BT_WRITE(sc, BT_CTRL, 0x00);
d647 3
a649 1
cgthree_burner(void *vsc, u_int on, u_int flags)
d669 2
a670 1
cgthree_updatecursor(struct rasops_info *ri)
d674 4
a677 4
	if (sc->sc_sunfb.sf_crowp != NULL)
		*sc->sc_sunfb.sf_crowp = ri->ri_crow;
	if (sc->sc_sunfb.sf_ccolp != NULL)
		*sc->sc_sunfb.sf_ccolp = ri->ri_ccol;
@


1.10
log
@Proper screenblank semantics
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.9 2002/02/23 05:47:50 jason Exp $	*/
d185 1
a185 1
	cgthree_burner,
@


1.9
log
@Add burner function so wscons can blank the fb
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.8 2002/02/07 04:48:15 jason Exp $	*/
d292 1
a292 1
	cgthree_burner(sc, 0, 0);
d636 1
a636 1
	if (!on)
@


1.8
log
@import some register defns from sparc
fully initialize and unblank framebuffer for non-console
use bus_space_vaddr()
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.7 2002/02/05 20:13:17 jason Exp $	*/
d172 1
a172 1
void cgthree_blank __P((struct cgthree_softc *, int));
d182 4
a185 1
	0 /* load_font */
d292 1
a292 1
	cgthree_blank(sc, 0);
d626 3
a628 3
cgthree_blank(sc, blank)
	struct cgthree_softc *sc;
	int blank;
d630 1
d636 3
a638 1
	if (blank)
a639 2
	else
		fbc |= FBC_CTRL_VENAB;
@


1.7
log
@Allow mmap as a dumb framebuffer (from offset 0).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.6 2002/02/05 18:34:39 jason Exp $	*/
d67 5
d77 3
a79 7

#define	BT_INIT(sc) do {					\
	BT_WRITE((sc), BT_ADDR, 0x06);	/* command reg */	\
	BT_WRITE((sc), BT_CTRL, 0x73);	/* overlay plane */	\
	BT_WRITE((sc), BT_ADDR, 0x04);  /* read mask */		\
	BT_WRITE((sc), BT_CTRL, 0xff);	/* color planes */	\
} while (0)
d84 33
d172 2
a173 1

d196 29
d276 4
a279 15
	sc->sc_depth = getpropint(sa->sa_node, "depth", -1);
	if (sc->sc_depth == -1)
		sc->sc_depth = 8;

	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", -1);
	if (sc->sc_linebytes == -1)
		sc->sc_linebytes = 1152;

	sc->sc_height = getpropint(sa->sa_node, "height", -1);
	if (sc->sc_height == -1)
		sc->sc_height = 900;

	sc->sc_width = getpropint(sa->sa_node, "width", -1);
	if (sc->sc_width == -1)
		sc->sc_width = 1152;
d283 2
d288 2
a289 1
	BT_INIT(sc);
d296 2
a297 1
	sc->sc_raster.pixels = (void *)sc->sc_vid_regs;
d569 69
@


1.6
log
@Implement vgafb_mmap() fully
From NetBSD: change bus_space_mmap() prototype to standard one
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.5 2002/01/06 00:49:41 jason Exp $	*/
a404 11
	if (offset < 0)
		return (-1);
	if ((u_int)offset >= NOOVERLAY)
		offset -= NOOVERLAY;
	else if ((u_int)offset >= START)
		offset -= START;
	else
		offset = 0;

	if (offset >= sc->sc_linebytes * sc->sc_height)
		return (-1);
d406 3
a408 2
	return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
	    CGTHREE_VID_OFFSET + offset, prot, BUS_SPACE_MAP_LINEAR));
@


1.5
log
@Claim to support WSSCREEN_WSCOLORS (drivers support it, but rcons doesn't
appear to).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.4 2002/01/04 08:22:13 jason Exp $	*/
a87 1
	bus_type_t sc_btype;
a183 1
	sc->sc_btype = (bus_type_t)sa->sa_slot;
a401 1
	bus_space_handle_t bh;
d417 2
a418 4
	if (bus_space_mmap(sc->sc_bustag, sc->sc_btype,
	    sc->sc_paddr + CGTHREE_VID_OFFSET + offset,
	    BUS_SPACE_MAP_LINEAR, &bh))
		return (-1);
d420 1
a420 1
	return ((paddr_t)bh);
@


1.4
log
@Add support for get/put colormap (mostly borrowed from sparc)
[XXX the bt458 stuff should be shared and will be later].
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.3 2002/01/04 05:42:30 jason Exp $	*/
d114 1
a114 1
	WSSCREEN_REVERSE
@


1.3
log
@mmap functionality for cgthee (mostly from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.2 2001/12/05 05:34:22 jason Exp $	*/
d58 25
d95 1
d134 5
d181 1
a181 1
	int console;
d194 1
a194 1
	 * Map just BT, FHC, THC, and video RAM.
d232 5
d266 11
a276 1
	if (console)
d279 1
d305 2
a322 1
#if 0
d324 6
a329 1
		return vgafb_getcmap(vc, (struct wsdisplay_cmap *)data);
d331 6
a336 2
		return vgafb_putcmap(vc, (struct wsdisplay_cmap *)data);
#endif
d447 80
@


1.2
log
@- fix initialization so that the cursor is initialized to be in the same
place the prom left it.
- remove some trial and error #if 0 stuff
- fix copyo's in a2int()
- ditch *_romcursoraddr for a direct call to romgetcursoraddr()
- allow this to attach (without panic()) if is is not the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.1 2001/12/04 21:43:01 jason Exp $	*/
d62 2
d154 2
d337 3
a345 1
#if 0
d347 1
a347 1
#endif
d351 18
a368 1
	return (-1);
@


1.2.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.5 2002/01/06 00:49:41 jason Exp $	*/
a57 25
union bt_cmap {
	u_int8_t cm_map[256][3];	/* 256 r/b/g entries */
	u_int32_t cm_chip[256 * 3 / 4];	/* the way the chip is loaded */
};

#define	BT_ADDR		0x00		/* map address register */
#define	BT_CMAP		0x04		/* colormap data register */
#define	BT_CTRL		0x08		/* control register */
#define	BT_OMAP		0x0c		/* overlay (cursor) map register */

#define	BT_WRITE(sc, reg, val) \
    bus_space_write_4((sc)->sc_bustag, (sc)->sc_ctrl_regs, (reg), (val))
#define	BT_READ(sc, reg) \
    bus_space_read_4((sc)->sc_bustag, (sc)->sc_ctrl_regs, (reg))

#define	BT_INIT(sc) do {					\
	BT_WRITE((sc), BT_ADDR, 0x06);	/* command reg */	\
	BT_WRITE((sc), BT_CTRL, 0x73);	/* overlay plane */	\
	BT_WRITE((sc), BT_ADDR, 0x04);  /* read mask */		\
	BT_WRITE((sc), BT_CTRL, 0xff);	/* color planes */	\
} while (0)

#define	BT_D4M3(x)	((((x) >> 2) << 1) + ((x) >> 2)) /* (x / 4) * 3 */
#define	BT_D4M4(x)	((x) & ~3)			 /* (x / 4) * 4 */

a61 2
	bus_addr_t sc_paddr;
	bus_type_t sc_btype;
a67 1
	union bt_cmap sc_cmap;
d86 1
a86 1
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
a105 5
void cgthree_loadcmap __P((struct cgthree_softc *, u_int, u_int));
int cg3_bt_putcmap __P((union bt_cmap *, struct wsdisplay_cmap *));
int cg3_bt_getcmap __P((union bt_cmap *, struct wsdisplay_cmap *));
void cgthree_setcolor __P((struct cgthree_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t));
d148 1
a148 1
	int console, i;
a151 2
	sc->sc_btype = (bus_type_t)sa->sa_slot;
	sc->sc_paddr = sbus_bus_addr(sa->sa_bustag, sa->sa_slot, sa->sa_offset);
d159 1
a159 1
	 * Map just CTRL and video RAM.
a196 5
	BT_WRITE(sc, BT_ADDR, 0);
	for (i = 0; i < 256 * 3 / 4; i++)
		sc->sc_cmap.cm_chip[i] = BT_READ(sc, BT_CMAP);
	BT_INIT(sc);

d226 1
a226 11
	if (console) {
		cgthree_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
		cgthree_setcolor(sc, 255, 255, 255, 255);
		cgthree_setcolor(sc, WSCOL_RED, 255, 0, 0);
		cgthree_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
		cgthree_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
		cgthree_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
		cgthree_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
		cgthree_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
		cgthree_setcolor(sc, WSCOL_WHITE, 255, 255, 255);

a228 1
	}
a253 2
	struct wsdisplay_cmap *cm;
	int error;
d270 1
d272 1
a272 6
		cm = (struct wsdisplay_cmap *)data;
		error = cg3_bt_getcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		break;

d274 2
a275 6
		cm = (struct wsdisplay_cmap *)data;
		error = cg3_bt_putcmap(&sc->sc_cmap, cm);
		if (error)
			return (error);
		cgthree_loadcmap(sc, cm->index, cm->count);
		break;
a332 3
#define	START		(128 * 1024 + 128 * 1024)
#define	NOOVERLAY	(0x04000000)

d339 1
d341 1
a341 1
	bus_space_handle_t bh;
d345 1
a345 18
	if (offset < 0)
		return (-1);
	if ((u_int)offset >= NOOVERLAY)
		offset -= NOOVERLAY;
	else if ((u_int)offset >= START)
		offset -= START;
	else
		offset = 0;

	if (offset >= sc->sc_linebytes * sc->sc_height)
		return (-1);

	if (bus_space_mmap(sc->sc_bustag, sc->sc_btype,
	    sc->sc_paddr + CGTHREE_VID_OFFSET + offset,
	    BUS_SPACE_MAP_LINEAR, &bh))
		return (-1);

	return ((paddr_t)bh);
a366 80
}

void
cgthree_setcolor(sc, index, r, g, b)
	struct cgthree_softc *sc;
	u_int index;
	u_int8_t r, g, b;
{
	union bt_cmap *bcm = &sc->sc_cmap;

	bcm->cm_map[index][0] = r;
	bcm->cm_map[index][1] = g;
	bcm->cm_map[index][2] = b;
	cgthree_loadcmap(sc, index, 1);
}

void
cgthree_loadcmap(sc, start, ncolors)
	struct cgthree_softc *sc;
	u_int start, ncolors;
{
	u_int cstart;
	int count;

	cstart = BT_D4M3(start);
	count = BT_D4M3(start + ncolors - 1) - BT_D4M3(start) + 3;
	BT_WRITE(sc, BT_ADDR, BT_D4M4(start));
	while (--count >= 0) {
		BT_WRITE(sc, BT_CMAP, sc->sc_cmap.cm_chip[cstart]);
		cstart++;
	}
}

int
cg3_bt_getcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || index + count > 256)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyout(&bcm->cm_map[index + i][0],
		    &rcm->red[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][1],
		    &rcm->green[i], 1)) != 0)
			return (error);
		if ((error = copyout(&bcm->cm_map[index + i][2],
		    &rcm->blue[i], 1)) != 0)
			return (error);
	}
	return (0);
}

int
cg3_bt_putcmap(bcm, rcm)
	union bt_cmap *bcm;
	struct wsdisplay_cmap *rcm;
{
	u_int index = rcm->index, count = rcm->count, i;
	int error;

	if (index >= 256 || rcm->count > 256 ||
	    (rcm->index + rcm->count) > 256)
		return (EINVAL);
	for (i = 0; i < count; i++) {
		if ((error = copyin(&rcm->red[i],
		    &bcm->cm_map[index + i][0], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->green[i],
		    &bcm->cm_map[index + i][1], 1)) != 0)
			return (error);
		if ((error = copyin(&rcm->blue[i],
		    &bcm->cm_map[index + i][2], 1)) != 0)
			return (error);
	}
	return (0);
@


1.2.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.2.2.1 2002/01/31 22:55:38 niklas Exp $	*/
a31 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d51 1
a51 1
#include <dev/rasops/rasops.h>
a66 5
#define	CG3_FBC_CTRL	0x10		/* control */
#define	CG3_FBC_STAT	0x11		/* status */
#define	CG3_FBC_START	0x12		/* cursor start */
#define	CG3_FBC_END	0x13		/* cursor end */
#define	CG3_FBC_VCTRL	0x14		/* 12 bytes of timing goo */
d72 7
a78 3
#define	BT_BARRIER(sc,reg,flags) \
    bus_space_barrier((sc)->sc_bustag, (sc)->sc_ctrl_regs, (reg), \
	sizeof(u_int32_t), (flags))
a82 33
#define	FBC_CTRL_IENAB		0x80	/* interrupt enable */
#define	FBC_CTRL_VENAB		0x40	/* video enable */
#define	FBC_CTRL_TIME		0x20	/* timing enable */
#define	FBC_CTRL_CURS		0x10	/* cursor compare enable */
#define	FBC_CTRL_XTAL		0x0c	/* xtal select (0,1,2,test): */
#define	FBC_CTRL_XTAL_0		0x00	/*  0 */
#define	FBC_CTRL_XTAL_1		0x04	/*  0 */
#define	FBC_CTRL_XTAL_2		0x08	/*  0 */
#define	FBC_CTRL_XTAL_TEST	0x0c	/*  0 */
#define	FBC_CTRL_DIV		0x03	/* divisor (1,2,3,4): */
#define	FBC_CTRL_DIV_1		0x00	/*  / 1 */
#define	FBC_CTRL_DIV_2		0x01	/*  / 2 */
#define	FBC_CTRL_DIV_3		0x02	/*  / 3 */
#define	FBC_CTRL_DIV_4		0x03	/*  / 4 */

#define	FBC_STAT_INTR		0x80	/* interrupt pending */
#define	FBC_STAT_RES		0x70	/* monitor sense: */
#define	FBC_STAT_RES_1024	0x10	/*  1024x768 */
#define	FBC_STAT_RES_1280	0x40	/*  1280x1024 */
#define	FBC_STAT_RES_1152	0x30	/*  1152x900 */
#define	FBC_STAT_RES_1152A	0x40	/*  1152x900x76, A */
#define	FBC_STAT_RES_1600	0x50	/*  1600x1200 */
#define	FBC_STAT_RES_1152B	0x60	/*  1152x900x86, B */
#define	FBC_STAT_ID		0x0f	/* id mask: */
#define	FBC_STAT_ID_COLOR	0x01	/*  color */
#define	FBC_STAT_ID_MONO	0x02	/*  monochrome */
#define	FBC_STAT_ID_MONOECL	0x03	/*  monochrome, ecl */

#define	FBC_READ(sc, reg) \
    bus_space_read_1((sc)->sc_bustag, (sc)->sc_ctrl_regs, (reg))
#define	FBC_WRITE(sc, reg, val) \
    bus_space_write_1((sc)->sc_bustag, (sc)->sc_ctrl_regs, (reg), (val))

d88 1
d93 2
d96 11
a106 1
	struct rasops_info sc_rasops;
d126 15
a140 16
int cgthree_ioctl(void *, u_long, caddr_t, int, struct proc *);
int cgthree_alloc_screen(void *, const struct wsscreen_descr *, void **,
    int *, int *, long *);
void cgthree_free_screen(void *, void *);
int cgthree_show_screen(void *, void *, int, void (*cb)(void *, int, int),
    void *);
paddr_t cgthree_mmap(void *, off_t, int);
int cgthree_is_console(int);
void cgthree_loadcmap(struct cgthree_softc *, u_int, u_int);
int cg3_bt_putcmap(union bt_cmap *, struct wsdisplay_cmap *);
int cg3_bt_getcmap(union bt_cmap *, struct wsdisplay_cmap *);
void cgthree_setcolor(struct cgthree_softc *, u_int,
    u_int8_t, u_int8_t, u_int8_t);
void cgthree_burner(void *, u_int, u_int);
void cgthree_reset(struct cgthree_softc *);
static int a2int(char *, int);
d148 1
a148 4
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	cgthree_burner,
d151 2
a152 2
int	cgthreematch(struct device *, void *, void *);
void	cgthreeattach(struct device *, struct device *, void *);
a161 29
#define	CG3_TYPE_DEFAULT	0
#define	CG3_TYPE_76HZ		1
#define	CG3_TYPE_SMALL		2

struct cg3_videoctrl {
	u_int8_t	sense;
	u_int8_t	vctrl[12];
	u_int8_t	ctrl;
} cg3_videoctrl[] = {
	{	/* cpd-1790 */
		0x31,
		{ 0xbb, 0x2b, 0x04, 0x14, 0xae, 0x03,
		  0xa8, 0x24, 0x01, 0x05, 0xff, 0x01 },
		FBC_CTRL_XTAL_0 | FBC_CTRL_DIV_1
	},
	{	/* gdm-20e20 */
		0x41,
		{ 0xb7, 0x27, 0x03, 0x0f, 0xae, 0x03,
		  0xae, 0x2a, 0x01, 0x09, 0xff, 0x01 },
		FBC_CTRL_XTAL_1 | FBC_CTRL_DIV_1
	},
	{	/* defaults, should be last */
		0xff,
		{ 0xbb, 0x2b, 0x03, 0x0b, 0xb3, 0x03,
		  0xaf, 0x2b, 0x02, 0x0a, 0xff, 0x01 },
		0,
	},
};

d185 1
d200 2
a201 2
		printf(": cannot map ctrl registers\n");
		goto fail_ctrl;
d208 1
a208 1
		printf(": cannot map vid registers\n");
d214 15
a228 4
	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);
a231 2
	cgthree_reset(sc);

d235 1
d237 13
a249 1
	cgthree_burner(sc, 1, 0);
d251 12
a262 18
	sc->sc_rasops.ri_depth = sc->sc_depth;
	sc->sc_rasops.ri_stride = sc->sc_linebytes;
	sc->sc_rasops.ri_flg = RI_CENTER;
	sc->sc_rasops.ri_bits = (void *)bus_space_vaddr(sc->sc_bustag,
	    sc->sc_vid_regs);
	sc->sc_rasops.ri_width = sc->sc_width;
	sc->sc_rasops.ri_height = sc->sc_height;
	sc->sc_rasops.ri_hw = sc;

	rasops_init(&sc->sc_rasops,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34),
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));

	cgthree_stdscreen.nrows = sc->sc_rasops.ri_rows;
	cgthree_stdscreen.ncols = sc->sc_rasops.ri_cols;
	cgthree_stdscreen.textops = &sc->sc_rasops.ri_ops;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, &defattr);
a266 2
		int *ccolp, *crowp;

d277 2
a278 9
		if (romgetcursoraddr(&crowp, &ccolp))
			ccolp = crowp = NULL;
		if (ccolp != NULL)
			sc->sc_rasops.ri_ccol = *ccolp;
		if (crowp != NULL)
			sc->sc_rasops.ri_crow = *crowp;

		wsdisplay_cnattach(&cgthree_stdscreen, &sc->sc_rasops,
		    sc->sc_rasops.ri_ccol, sc->sc_rasops.ri_crow, defattr);
d291 1
a291 1
fail_ctrl:
d365 4
a368 5
	*cookiep = &sc->sc_rasops;
	*curyp = 0;
	*curxp = 0;
	sc->sc_rasops.ri_ops.alloc_attr(&sc->sc_rasops,
	    WSCOL_WHITE, WSCOL_BLACK, WSATTR_WSCOLORS, attrp);
d388 1
a388 1
	void (*cb)(void *, int, int);
d404 1
d408 11
d420 4
a423 3
	if (offset >= 0 && offset < (sc->sc_linebytes * sc->sc_height))
		return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
		    CGTHREE_VID_OFFSET + offset, prot, BUS_SPACE_MAP_LINEAR));
d425 1
a425 1
	return (-1);
a526 73
}

void
cgthree_reset(sc)
	struct cgthree_softc *sc;
{
	int i, j;
	u_int8_t sts, ctrl;

	sts = FBC_READ(sc, CG3_FBC_STAT);
	ctrl = FBC_READ(sc, CG3_FBC_CTRL);

	if (ctrl & FBC_CTRL_TIME) {
		/* already initialized */
		return;
	}

	for (i = 0; i <  sizeof(cg3_videoctrl)/sizeof(cg3_videoctrl[0]); i++) {
		if (cg3_videoctrl[i].sense == 0xff ||
		    (cg3_videoctrl[i].sense ==
		     (sts & (FBC_STAT_RES | FBC_STAT_ID)))) {
			for (j = 0; j < 12; j++)
				FBC_WRITE(sc, CG3_FBC_VCTRL + j,
				    cg3_videoctrl[i].vctrl[j]);
			ctrl &= ~(FBC_CTRL_XTAL | FBC_CTRL_DIV);
			ctrl |= cg3_videoctrl[i].ctrl |
			    FBC_CTRL_TIME;
			FBC_WRITE(sc, CG3_FBC_CTRL, ctrl);
			break;
		}
	}

	BT_WRITE(sc, BT_ADDR, 0x04);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0xff);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	BT_WRITE(sc, BT_ADDR, 0x05);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	BT_WRITE(sc, BT_ADDR, 0x06);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x70);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);

	BT_WRITE(sc, BT_ADDR, 0x07);
	BT_BARRIER(sc, BT_ADDR, BUS_SPACE_BARRIER_WRITE);
	BT_WRITE(sc, BT_CTRL, 0x00);
	BT_BARRIER(sc, BT_CTRL, BUS_SPACE_BARRIER_WRITE);
}

void
cgthree_burner(vsc, on, flags)
	void *vsc;
	u_int on, flags;
{
	struct cgthree_softc *sc = vsc;
	int s;
	u_int8_t fbc;

	s = splhigh();
	fbc = FBC_READ(sc, CG3_FBC_CTRL);
	if (on)
		fbc |= FBC_CTRL_VENAB | FBC_CTRL_TIME;
	else {
		fbc &= ~FBC_CTRL_VENAB;
		if (flags & WSDISPLAY_BURN_VBLANK)
			fbc &= ~FBC_CTRL_TIME;
	}
	FBC_WRITE(sc, CG3_FBC_CTRL, fbc);
	splx(s);
@


1.2.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cgthree.c,v 1.2.2.2 2002/06/11 03:42:29 art Exp $	*/
a132 2
	u_int sc_mode;
	int *sc_crowp, *sc_ccolp;
a139 1
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
a166 1
void cgthree_updatecursor(struct rasops_info *);
d289 1
a289 2
	sc->sc_rasops.ri_flg = RI_CENTER |
	    (console ? 0 : RI_CLEAR);
d304 1
a304 2
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, &defattr);
	sc->sc_rasops.ri_hw = sc;
d308 2
a309 9
	cgthree_setcolor(sc, WSCOL_BLACK, 0, 0, 0);
	cgthree_setcolor(sc, 255, 0, 0, 0);
	cgthree_setcolor(sc, WSCOL_RED, 255, 0, 0);
	cgthree_setcolor(sc, WSCOL_GREEN, 0, 255, 0);
	cgthree_setcolor(sc, WSCOL_BROWN, 154, 85, 46);
	cgthree_setcolor(sc, WSCOL_BLUE, 0, 0, 255);
	cgthree_setcolor(sc, WSCOL_MAGENTA, 255, 255, 0);
	cgthree_setcolor(sc, WSCOL_CYAN, 0, 255, 255);
	cgthree_setcolor(sc, WSCOL_WHITE, 255, 255, 255);
d311 16
a326 8
	if (console) {
		if (romgetcursoraddr(&sc->sc_crowp, &sc->sc_ccolp))
			sc->sc_ccolp = sc->sc_crowp = NULL;
		if (sc->sc_ccolp != NULL)
			sc->sc_rasops.ri_ccol = *sc->sc_ccolp;
		if (sc->sc_crowp != NULL)
			sc->sc_rasops.ri_crow = *sc->sc_crowp;
		sc->sc_rasops.ri_updatecursor = cgthree_updatecursor;
a362 3
	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		break;
d420 1
a420 1
	    WSCOL_BLACK, WSCOL_WHITE, WSATTR_WSCOLORS, attrp);
d457 1
a457 1
	if (offset & PGOFSET || offset < 0)
d460 1
a460 10
	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
		if (offset >= NOOVERLAY)
			offset -= NOOVERLAY;
		else if (offset >= START)
			offset -= START;
		else
			offset = 0;
		if (offset >= sc->sc_linebytes * sc->sc_height)
			return (-1);
d463 1
a463 7
	case WSDISPLAYIO_MODE_DUMBFB:
		if (offset < (sc->sc_linebytes * sc->sc_height))
			return (bus_space_mmap(sc->sc_bustag, sc->sc_paddr,
			    CGTHREE_VID_OFFSET + offset, prot,
			    BUS_SPACE_MAP_LINEAR));
		break;
	}
d527 1
a527 1
	if (index >= 256 || count > 256 - index)
d551 2
a552 1
	if (index >= 256 || count > 256 - index)
a638 12
}

void
cgthree_updatecursor(ri)
	struct rasops_info *ri;
{
	struct cgthree_softc *sc = ri->ri_hw;

	if (sc->sc_crowp != NULL)
		*sc->sc_crowp = ri->ri_crow;
	if (sc->sc_ccolp != NULL)
		*sc->sc_ccolp = ri->ri_ccol;
@


1.2.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a249 5
	sc->sc_depth = getpropint(sa->sa_node, "depth", 8);
	sc->sc_linebytes = getpropint(sa->sa_node, "linebytes", 1152);
	sc->sc_height = getpropint(sa->sa_node, "height", 900);
	sc->sc_width = getpropint(sa->sa_node, "width", 1152);

d268 1
a268 1
	    sc->sc_linebytes * sc->sc_height, BUS_SPACE_MAP_LINEAR,
d276 5
a348 1
;
d366 1
a366 1
		*(u_int *)data = WSDISPLAY_TYPE_SUNCG3;
@


1.1
log
@skeleton driver for cgthree (at the same point as cgsix)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a104 1
int cgthree_romcursoraddr __P((int **, int **));
d204 3
a206 2
	sc->sc_rcons.rc_crow = sc->sc_rcons.rc_ccol = -1;
	if (cgthree_romcursoraddr(&sc->sc_rcons.rc_crowp, &sc->sc_rcons.rc_ccolp)) {
a210 11
#if 0
	sc->sc_rcons.rc_font = &console_font;
	sc->sc_rcons.rc_maxcol =
	    sc->sc_raster.width / sc->sc_rcons.rc_font->width;
	sc->sc_rcons.rc_maxrow =
	    sc->sc_raster.height / sc->sc_rcons.rc_font->height;
	sc->sc_rcons.rc_maxcol = min(sc->sc_rcons.rc_maxcol,
	    a2int(getpropstring(optionsnode, "screen-#columns"), 80));
	sc->sc_rcons.rc_maxrow = min(sc->sc_rcons.rc_maxrow,
	    a2int(getpropstring(optionsnode, "screen-#rows"), 34));
#else
a214 1
#endif
d216 2
a217 1
	rcons_init(&sc->sc_rcons, 160, 160);
d224 6
a233 5

	printf("\n");

	wsdisplay_cnattach(&cgthree_stdscreen, &sc->sc_rcons, 0, 0, defattr);

d305 2
a306 1
	*curxp = *curyp = 0;
d351 1
a351 1
	int i;
d356 1
a356 1
		i = i * 10 + *cp++ - '\0';
a357 16
}

int
cgthree_romcursoraddr(rowp, colp)
	int **rowp, **colp;
{
	int rx, cx;

	return (1);
	/*
	 * XXX these calls crash the machine... OF_interpret appears to
	 * be broken.
	 */
	OF_interpret("addr line#", 1, &rx);
	OF_interpret("addr column#", 1, &cx);
	return (0);
@

