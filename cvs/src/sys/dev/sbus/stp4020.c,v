head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.10
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.8
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.16.0.18
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.16
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.14
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.12
	OPENBSD_5_0:1.16.0.10
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.8
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.6
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.10
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.4
	SMP:1.4.0.8
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	UBC:1.4.0.4
	UBC_SYNC_B:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.19
date	2016.03.19.11.34.22;	author mpi;	state Exp;
branches;
next	1.18;
commitid	15xZY6veDWwRM6Iq;

1.18
date	2013.11.19.01.23.51;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2013.11.18.20.21.51;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.04.10.20.54.58;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.23.11.39.37;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.27.17.03.24;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.03.21.47.39;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.02.23.10.18;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.25.22.49.06;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.25.22.38.37;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.25.22.33.18;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.25.21.20.54;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.25.17.36.49;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.23.09.28.00;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.21.07.55.26;	author fgsch;	state Exp;
branches
	1.4.4.1
	1.4.8.1;
next	1.3;

1.3
date	2002.06.20.02.43.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.19.20.57.15;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.19.19.14.21;	author fgsch;	state Exp;
branches;
next	;

1.4.4.1
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	;

1.4.8.1
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	1.4.8.2;

1.4.8.2
date	2004.06.05.23.12.57;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Reduces the noise around the global ``ticks'' variable by renaming
all the local ones to ``nticks''.

ok stefan@@, deraadt@@
@
text
@/*	$OpenBSD: stp4020.c,v 1.18 2013/11/19 01:23:51 deraadt Exp $	*/
/*	$NetBSD: stp4020.c,v 1.23 2002/06/01 23:51:03 lukem Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Paul Kranenburg.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * STP4020: SBus/PCMCIA bridge supporting one Type-3 PCMCIA card, or up to
 * two Type-1 and Type-2 PCMCIA cards..
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/extent.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/device.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciachip.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/sbus/stp4020reg.h>
#include <dev/sbus/stp4020var.h>

/*
 * We use the three available windows per socket in a simple, fixed
 * arrangement. Each window maps (at full 1 MB size) one of the pcmcia
 * spaces into sbus space.
 */
#define STP_WIN_ATTR	0	/* index of the attribute memory space window */
#define	STP_WIN_MEM	1	/* index of the common memory space window */
#define	STP_WIN_IO	2	/* index of the io space window */

#ifdef STP4020_DEBUG
int stp4020_debug = 0;
#define DPRINTF(x)	do { if (stp4020_debug) printf x; } while(0)
#else
#define DPRINTF(x)
#endif

int	stp4020print(void *, const char *);
void	stp4020_map_window(struct stp4020_socket *, int, int);
void	stp4020_calc_speed(int, int, int *, int *);
void	stp4020_intr_dispatch(void *);

struct	cfdriver stp_cd = {
	NULL, "stp", DV_DULL
};

#ifdef STP4020_DEBUG
static void	stp4020_dump_regs(struct stp4020_socket *);
#endif

static u_int16_t stp4020_rd_sockctl(struct stp4020_socket *, int);
static void	stp4020_wr_sockctl(struct stp4020_socket *, int, u_int16_t);
static u_int16_t stp4020_rd_winctl(struct stp4020_socket *, int, int);
static void	stp4020_wr_winctl(struct stp4020_socket *, int, int, u_int16_t);

void	stp4020_delay(unsigned int);
void	stp4020_attach_socket(struct stp4020_socket *, int);
void	stp4020_create_event_thread(void *);
void	stp4020_event_thread(void *);
void	stp4020_queue_event(struct stp4020_softc *, int);

int	stp4020_chip_mem_alloc(pcmcia_chipset_handle_t, bus_size_t,
	    struct pcmcia_mem_handle *);
void	stp4020_chip_mem_free(pcmcia_chipset_handle_t,
	    struct pcmcia_mem_handle *);
int	stp4020_chip_mem_map(pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_mem_handle *, bus_size_t *, int *);
void	stp4020_chip_mem_unmap(pcmcia_chipset_handle_t, int);

int	stp4020_chip_io_alloc(pcmcia_chipset_handle_t,
	    bus_addr_t, bus_size_t, bus_size_t, struct pcmcia_io_handle *);
void	stp4020_chip_io_free(pcmcia_chipset_handle_t,
	    struct pcmcia_io_handle *);
int	stp4020_chip_io_map(pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_io_handle *, int *);
void	stp4020_chip_io_unmap(pcmcia_chipset_handle_t, int);

void	stp4020_chip_socket_enable(pcmcia_chipset_handle_t);
void	stp4020_chip_socket_disable(pcmcia_chipset_handle_t);
void	*stp4020_chip_intr_establish(pcmcia_chipset_handle_t,
	    struct pcmcia_function *, int, int (*) (void *), void *, char *);
void	stp4020_chip_intr_disestablish(pcmcia_chipset_handle_t, void *);
const char *stp4020_chip_intr_string(pcmcia_chipset_handle_t, void *);

/* Our PCMCIA chipset methods */
static struct pcmcia_chip_functions stp4020_functions = {
	stp4020_chip_mem_alloc,
	stp4020_chip_mem_free,
	stp4020_chip_mem_map,
	stp4020_chip_mem_unmap,

	stp4020_chip_io_alloc,
	stp4020_chip_io_free,
	stp4020_chip_io_map,
	stp4020_chip_io_unmap,

	stp4020_chip_intr_establish,
	stp4020_chip_intr_disestablish,
	stp4020_chip_intr_string,

	stp4020_chip_socket_enable,
	stp4020_chip_socket_disable
};


static __inline__ u_int16_t
stp4020_rd_sockctl(h, idx)
	struct stp4020_socket *h;
	int idx;
{
	int o = ((STP4020_SOCKREGS_SIZE * (h->sock)) + idx);
	return (bus_space_read_2(h->tag, h->regs, o));
}

static __inline__ void
stp4020_wr_sockctl(h, idx, v)
	struct stp4020_socket *h;
	int idx;
	u_int16_t v;
{
	int o = (STP4020_SOCKREGS_SIZE * (h->sock)) + idx;
	bus_space_write_2(h->tag, h->regs, o, v);
}

static __inline__ u_int16_t
stp4020_rd_winctl(h, win, idx)
	struct stp4020_socket *h;
	int win;
	int idx;
{
	int o = (STP4020_SOCKREGS_SIZE * (h->sock)) +
	    (STP4020_WINREGS_SIZE * win) + idx;
	return (bus_space_read_2(h->tag, h->regs, o));
}

static __inline__ void
stp4020_wr_winctl(h, win, idx, v)
	struct stp4020_socket *h;
	int win;
	int idx;
	u_int16_t v;
{
	int o = (STP4020_SOCKREGS_SIZE * (h->sock)) +
	    (STP4020_WINREGS_SIZE * win) + idx;
	bus_space_write_2(h->tag, h->regs, o, v);
}


int
stp4020print(aux, busname)
	void *aux;
	const char *busname;
{
	struct pcmciabus_attach_args *paa = aux;
	struct stp4020_socket *h = paa->pch;

	printf(" socket %d", h->sock);
	return (UNCONF);
}

/*
 * Attach all the sub-devices we can find
 */
void
stpattach_common(struct stp4020_softc *sc, int clockfreq)
{
	int i, rev;

	rev = stp4020_rd_sockctl(&sc->sc_socks[0], STP4020_ISR1_IDX) &
	    STP4020_ISR1_REV_M;
	printf(": rev %x\n", rev);

	sc->sc_pct = (pcmcia_chipset_tag_t)&stp4020_functions;

	/*
	 * Arrange that a kernel thread be created to handle
	 * insert/removal events.
	 */
	sc->events = 0;
	kthread_create_deferred(stp4020_create_event_thread, sc);

	for (i = 0; i < STP4020_NSOCK; i++) {
		struct stp4020_socket *h = &sc->sc_socks[i];
		h->sock = i;
		h->sc = sc;
#ifdef STP4020_DEBUG
		if (stp4020_debug)
			stp4020_dump_regs(h);
#endif
		stp4020_attach_socket(h, clockfreq);
	}
}

void
stp4020_attach_socket(h, speed)
	struct stp4020_socket *h;
	int speed;
{
	struct pcmciabus_attach_args paa;
	int v;

	/* no interrupt handlers yet */
	h->intrhandler = NULL;
	h->intrarg = NULL;
	h->softint = NULL;
	h->int_enable = h->int_disable = 0;

	/* Map all three windows */
	stp4020_map_window(h, STP_WIN_ATTR, speed);
	stp4020_map_window(h, STP_WIN_MEM, speed);
	stp4020_map_window(h, STP_WIN_IO, speed);

	/* Configure one pcmcia device per socket */
	paa.paa_busname = "pcmcia";
	paa.pct = (pcmcia_chipset_tag_t)h->sc->sc_pct;
	paa.pch = (pcmcia_chipset_handle_t)h;
	paa.iobase = 0;
	paa.iosize = STP4020_WINDOW_SIZE;

	h->pcmcia = config_found(&h->sc->sc_dev, &paa, stp4020print);

	if (h->pcmcia == NULL)
		return;

	/*
	 * There's actually a pcmcia bus attached; initialize the slot.
	 */

	/*
	 * Clear things up before we enable status change interrupts.
	 * This seems to not be fully initialized by the PROM.
	 */
	stp4020_wr_sockctl(h, STP4020_ICR1_IDX, 0);
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, 0);
	stp4020_wr_sockctl(h, STP4020_ISR1_IDX, 0x3fff);
	stp4020_wr_sockctl(h, STP4020_ISR0_IDX, 0x3fff);

	/*
	 * Enable socket status change interrupts.
	 * We use SB_INT[1] for status change interrupts.
	 */
	v = STP4020_ICR0_ALL_STATUS_IE | STP4020_ICR0_SCILVL_SB1;
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, v);

	/* Get live status bits from ISR0 */
	v = stp4020_rd_sockctl(h, STP4020_ISR0_IDX);
	h->sense = v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST);
	if (h->sense != 0) {
		h->flags |= STP4020_SOCKET_BUSY;
		pcmcia_card_attach(h->pcmcia);
	}
}


/*
 * Deferred thread creation callback.
 */
void
stp4020_create_event_thread(arg)
	void *arg;
{
	struct stp4020_softc *sc = arg;

	if (kthread_create(stp4020_event_thread, sc, &sc->event_thread,
	    sc->sc_dev.dv_xname)) {
		panic("%s: unable to create event thread", sc->sc_dev.dv_xname);
	}
}

/*
 * The actual event handling thread.
 */
void
stp4020_event_thread(arg)
	void *arg;
{
	struct stp4020_softc *sc = arg;
	int s, sense;
	unsigned int socket;

	for (;;) {
		struct stp4020_socket *h;

		s = splhigh();
		if ((socket = ffs(sc->events)) == 0) {
			splx(s);
			(void)tsleep(&sc->events, PWAIT, "stp4020_ev", 0);
			continue;
		}
		socket--;
		sc->events &= ~(1 << socket);
		splx(s);

		if (socket >= STP4020_NSOCK) {
#ifdef DEBUG
			printf("stp4020_event_thread: wayward socket number %d\n",
			    socket);
#endif
			continue;
		}

		h = &sc->sc_socks[socket];

		/* Read socket's ISR0 for the interrupt status bits */
		sense = stp4020_rd_sockctl(h, STP4020_ISR0_IDX) &
		    (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST);

		if (sense > h->sense) {
			/*
			 * If at least one more sensor is asserted, this is
			 * a card insertion.
			 */
			h->sense = sense;
			if ((h->flags & STP4020_SOCKET_BUSY) == 0) {
				h->flags |= STP4020_SOCKET_BUSY;
				pcmcia_card_attach(h->pcmcia);
			}
		} else if (sense < h->sense) {
			/*
			 * If at least one less sensor is asserted, this is
			 * a card removal.
			 */
			h->sense = sense;
			if (h->flags & STP4020_SOCKET_BUSY) {
				h->flags &= ~STP4020_SOCKET_BUSY;
				pcmcia_card_detach(h->pcmcia, DETACH_FORCE);
			}
		}
	}
}

void
stp4020_queue_event(sc, sock)
	struct stp4020_softc *sc;
	int sock;
{
	int s;

	s = splhigh();
	sc->events |= (1 << sock);
	splx(s);
	wakeup(&sc->events);
}

/*
 * Software interrupt called to invoke the real driver interrupt handler.
 */
void
stp4020_intr_dispatch(void *arg)
{
	struct stp4020_socket *h = (struct stp4020_socket *)arg;
	int s;

	/* invoke driver handler */
	h->intrhandler(h->intrarg);

	/* enable SBUS interrupts for PCMCIA interrupts again */
	s = splhigh();
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, h->int_enable);
	splx(s);
}

int
stp4020_statintr(arg)
	void *arg;
{
	struct stp4020_softc *sc = arg;
	int i, sense, r = 0;
	int s;

	/* protect hardware access against soft interrupts */
	s = splhigh();

	/*
	 * Check each socket for pending requests.
	 */
	for (i = 0 ; i < STP4020_NSOCK; i++) {
		struct stp4020_socket *h;
		int v;

		h = &sc->sc_socks[i];

		/* Read socket's ISR0 for the interrupt status bits */
		v = stp4020_rd_sockctl(h, STP4020_ISR0_IDX);
		sense = v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST);

#ifdef STP4020_DEBUG
		if (stp4020_debug != 0)
			printf("stp4020_statintr: ISR0=%b\n",
			    v, STP4020_ISR0_IOBITS);
#endif

		/* Ack all interrupts at once */
		stp4020_wr_sockctl(h, STP4020_ISR0_IDX,
		    STP4020_ISR0_ALL_STATUS_IRQ);

		if ((v & STP4020_ISR0_CDCHG) != 0) {
			r = 1;

			/*
			 * Card detect status changed. In an ideal world,
			 * both card detect sensors should be set if a card
			 * is in the slot, and clear if it is not.
			 *
			 * Unfortunately, it turns out that we can get the
			 * notification before both sensors are set (or
			 * clear).
			 *
			 * This can be very funny if only one sensor is set.
			 * Is this a removal or an insertion operation?
			 * Defer appropriate action to the worker thread.
			 */
			if (sense != h->sense)
				stp4020_queue_event(sc, i);

		}

		/* informational messages */
		if ((v & STP4020_ISR0_BVD1CHG) != 0) {
			DPRINTF(("stp4020[%d]: Battery change 1\n",
			    h->sock));
			r = 1;
		}

		if ((v & STP4020_ISR0_BVD2CHG) != 0) {
			DPRINTF(("stp4020[%d]: Battery change 2\n",
			    h->sock));
			r = 1;
		}

		if ((v & STP4020_ISR0_RDYCHG) != 0) {
			DPRINTF(("stp4020[%d]: Ready/Busy change\n",
			    h->sock));
			r = 1;
		}

		if ((v & STP4020_ISR0_WPCHG) != 0) {
			DPRINTF(("stp4020[%d]: Write protect change\n",
			    h->sock));
			r = 1;
		}

		if ((v & STP4020_ISR0_PCTO) != 0) {
			DPRINTF(("stp4020[%d]: Card access timeout\n",
			    h->sock));
			r = 1;
		}

		if ((v & STP4020_ISR0_SCINT) != 0) {
			DPRINTF(("stp4020[%d]: Status change\n",
			    h->sock));
			r = 1;
		}

		/*
		 * Not interrupts flag per se, but interrupts can occur when
		 * they are asserted, at least during our slot enable routine.
		 */
		if ((h->flags & STP4020_SOCKET_ENABLING) &&
		    (v & (STP4020_ISR0_WAITST | STP4020_ISR0_PWRON)))
			r = 1;
	}

	splx(s);

	return (r);
}

int
stp4020_iointr(arg)
	void *arg;
{
	struct stp4020_softc *sc = arg;
	int i, r = 0;
	int s;

	/* protect hardware access against soft interrupts */
	s = splhigh();

	/*
	 * Check each socket for pending requests.
	 */
	for (i = 0 ; i < STP4020_NSOCK; i++) {
		struct stp4020_socket *h;
		int v;

		h = &sc->sc_socks[i];
		v = stp4020_rd_sockctl(h, STP4020_ISR0_IDX);

		if ((v & STP4020_ISR0_IOINT) != 0) {
			/* we can not deny this is ours, no matter what the
			   card driver says. */
			r = 1;

			/* ack interrupt */
			stp4020_wr_sockctl(h, STP4020_ISR0_IDX, v);

			/* It's a card interrupt */
			if ((h->flags & STP4020_SOCKET_BUSY) == 0) {
				printf("stp4020[%d]: spurious interrupt?\n",
				    h->sock);
				continue;
			}
			/* Call card handler, if any */
			if (h->softint != NULL) {
				softintr_schedule(h->softint);

				/*
				 * Disable this sbus interrupt, until the
				 * softintr handler had a chance to run.
				 */
				stp4020_wr_sockctl(h, STP4020_ICR0_IDX,
				    h->int_disable);
			}
		}

	}

	splx(s);

	return (r);
}

/*
 * The function gets the sbus speed and a access time and calculates
 * values for the CMDLNG and CMDDLAY registers.
 */
void
stp4020_calc_speed(int bus_speed, int ns, int *length, int *delay)
{
	int result;

	if (ns < STP4020_MEM_SPEED_MIN)
		ns = STP4020_MEM_SPEED_MIN;
	else if (ns > STP4020_MEM_SPEED_MAX)
		ns = STP4020_MEM_SPEED_MAX;
	result = ns * (bus_speed / 1000);
	if (result % 1000000)
		result = result / 1000000 + 1;
	else
		result /= 1000000;
	*length = result;

	/* the sbus frequency range is limited, so we can keep this simple */
	*delay = ns <= STP4020_MEM_SPEED_MIN ? 1 : 2;
}

void
stp4020_map_window(struct stp4020_socket *h, int win, int speed)
{
	int v, length, delay;

	/*
	 * According to the PC Card standard 300ns access timing should be
	 * used for attribute memory access. Our pcmcia framework does not
	 * seem to propagate timing information, so we use that
	 * everywhere.
	 */
	stp4020_calc_speed(speed, 300, &length, &delay);

	/*
	 * Fill in the Address Space Select and Base Address
	 * fields of this windows control register 0.
	 */
	v = ((delay << STP4020_WCR0_CMDDLY_S) & STP4020_WCR0_CMDDLY_M) |
	    ((length << STP4020_WCR0_CMDLNG_S) & STP4020_WCR0_CMDLNG_M);
	switch (win) {
	case STP_WIN_ATTR:
		v |= STP4020_WCR0_ASPSEL_AM;
		break;
	case STP_WIN_MEM:
		v |= STP4020_WCR0_ASPSEL_CM;
		break;
	case STP_WIN_IO:
		v |= STP4020_WCR0_ASPSEL_IO;
		break;
	}
	v |= (STP4020_ADDR2PAGE(0) & STP4020_WCR0_BASE_M);
	stp4020_wr_winctl(h, win, STP4020_WCR0_IDX, v);
	stp4020_wr_winctl(h, win, STP4020_WCR1_IDX,
	    1 << STP4020_WCR1_WAITREQ_S);
}

int
stp4020_chip_mem_alloc(pch, size, pcmhp)
	pcmcia_chipset_handle_t pch;
	bus_size_t size;
	struct pcmcia_mem_handle *pcmhp;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;

	/* we can not do much here, defere work to _mem_map */
	pcmhp->memt = h->wintag;
	pcmhp->size = size;
	pcmhp->addr = 0;
	pcmhp->mhandle = 0;
	pcmhp->realsize = size;

	return (0);
}

void
stp4020_chip_mem_free(pch, pcmhp)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_mem_handle *pcmhp;
{
}

int
stp4020_chip_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)
	pcmcia_chipset_handle_t pch;
	int kind;
	bus_addr_t card_addr;
	bus_size_t size;
	struct pcmcia_mem_handle *pcmhp;
	bus_size_t *offsetp;
	int *windowp;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;
	int win = (kind & PCMCIA_MEM_ATTR) ? STP_WIN_ATTR : STP_WIN_MEM;

	pcmhp->memt = h->wintag;
	bus_space_subregion(h->wintag, h->windows[win].winaddr,
	    card_addr, size, &pcmhp->memh);
	pcmhp->size = size;
	pcmhp->realsize = STP4020_WINDOW_SIZE - card_addr;
	*offsetp = 0;
	*windowp = win;

	return (0);
}

void
stp4020_chip_mem_unmap(pch, win)
	pcmcia_chipset_handle_t pch;
	int win;
{
}

int
stp4020_chip_io_alloc(pch, start, size, align, pcihp)
	pcmcia_chipset_handle_t pch;
	bus_addr_t start;
	bus_size_t size;
	bus_size_t align;
	struct pcmcia_io_handle *pcihp;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;

	pcihp->iot = h->wintag;
	pcihp->ioh = h->windows[STP_WIN_IO].winaddr;
	pcihp->size = size;
	return (0);
}

void
stp4020_chip_io_free(pch, pcihp)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_io_handle *pcihp;
{
}

int
stp4020_chip_io_map(pch, width, offset, size, pcihp, windowp)
	pcmcia_chipset_handle_t pch;
	int width;
	bus_addr_t offset;
	bus_size_t size;
	struct pcmcia_io_handle *pcihp;
	int *windowp;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;

	pcihp->iot = h->wintag;
	bus_space_subregion(h->wintag, h->windows[STP_WIN_IO].winaddr,
	    offset, size, &pcihp->ioh);
	*windowp = 0;
	return (0);
}

void
stp4020_chip_io_unmap(pch, win)
	pcmcia_chipset_handle_t pch;
	int win;
{
}

void
stp4020_chip_socket_enable(pch)
	pcmcia_chipset_handle_t pch;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;
	int i, v;

	h->flags |= STP4020_SOCKET_ENABLING;

	/* this bit is mostly stolen from pcic_attach_card */

	/* Power down the socket to reset it, clear the card reset pin */
	stp4020_wr_sockctl(h, STP4020_ICR1_IDX, 0);

	/*
	 * wait 300ms until power fails (Tpf).  Then, wait 100ms since
	 * we are changing Vcc (Toff).
	 */
	stp4020_delay((300 + 100) * 1000);

	/* Power up the socket */
	v = STP4020_ICR1_MSTPWR;
	stp4020_wr_sockctl(h, STP4020_ICR1_IDX, v);

	/*
	 * wait 100ms until power raise (Tpr) and 20ms to become
	 * stable (Tsu(Vcc)).
	 *
	 * some machines require some more time to be settled
	 * (another 200ms is added here).
	 */
	stp4020_delay((100 + 20 + 200) * 1000);

	v |= STP4020_ICR1_PCIFOE | STP4020_ICR1_VPP1_VCC;
	stp4020_wr_sockctl(h, STP4020_ICR1_IDX, v);

	/*
	 * hold RESET at least 20us.
	 */
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, 
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) | STP4020_ICR0_RESET);
	delay(20);
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX,
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) & ~STP4020_ICR0_RESET);

	/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */
	stp4020_delay(20000);

	/* Wait for the chip to finish initializing (5 seconds max) */
	for (i = 10000; i > 0; i--) {
		v = stp4020_rd_sockctl(h, STP4020_ISR0_IDX);
		/* If the card has been removed, abort */
		if ((v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST)) == 0) {
			h->flags &= ~STP4020_SOCKET_ENABLING;
			return;
		}
		if ((v & STP4020_ISR0_RDYST) != 0)
			break;
		delay(500);
	}
	if (i <= 0) {
#ifdef STP4020_DEBUG
		printf("stp4020_chip_socket_enable: not ready: status %b\n",
		    v, STP4020_ISR0_IOBITS);
#endif
		h->flags &= ~STP4020_SOCKET_ENABLING;
		return;
	}

	v = stp4020_rd_sockctl(h, STP4020_ICR0_IDX);

	/*
	 * Check the card type.
	 * Enable socket I/O interrupts for IO cards.
	 * We use level SB_INT[0] for I/O interrupts.
	 */
	if (pcmcia_card_gettype(h->pcmcia) == PCMCIA_IFTYPE_IO) {
		v &= ~(STP4020_ICR0_IOILVL | STP4020_ICR0_IFTYPE);
		v |= STP4020_ICR0_IFTYPE_IO | STP4020_ICR0_IOIE |
		    STP4020_ICR0_IOILVL_SB0 | STP4020_ICR0_SPKREN;
		h->int_enable = v;
		h->int_disable = v & ~STP4020_ICR0_IOIE;
		DPRINTF(("%s: configuring card for IO usage\n",
		    h->sc->sc_dev.dv_xname));
	} else {
		v &= ~(STP4020_ICR0_IOILVL | STP4020_ICR0_IFTYPE |
		    STP4020_ICR0_SPKREN | STP4020_ICR0_IOIE);
		v |= STP4020_ICR0_IFTYPE_MEM;
		h->int_enable = h->int_disable = v;
		DPRINTF(("%s: configuring card for MEM ONLY usage\n",
		    h->sc->sc_dev.dv_xname));
	}
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, v);

	h->flags &= ~STP4020_SOCKET_ENABLING;
}

void
stp4020_chip_socket_disable(pch)
	pcmcia_chipset_handle_t pch;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;
	int v;

	/*
	 * Disable socket I/O interrupts.
	 */
	v = stp4020_rd_sockctl(h, STP4020_ICR0_IDX);
	v &= ~(STP4020_ICR0_IOILVL | STP4020_ICR0_IFTYPE |
	    STP4020_ICR0_SPKREN | STP4020_ICR0_IOIE);
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, v);

	/* Power down the socket */
	stp4020_wr_sockctl(h, STP4020_ICR1_IDX, 0);

	/*
	 * wait 300ms until power fails (Tpf).
	 */
	stp4020_delay(300 * 1000);
}

void *
stp4020_chip_intr_establish(pch, pf, ipl, handler, arg, xname)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_function *pf;
	int ipl;
	int (*handler) (void *);
	void *arg;
	char *xname;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;

	/*
	 * Note that this code relies on softintr_establish() to be
	 * used with real, hardware ipl values. All platforms with
	 * SBus support support this.
	 */
	h->intrhandler = handler;
	h->intrarg = arg;
	h->softint = softintr_establish(ipl, stp4020_intr_dispatch, h);

	return h->softint != NULL ? h : NULL;
}

void
stp4020_chip_intr_disestablish(pch, ih)
	pcmcia_chipset_handle_t pch;
	void *ih;
{
	struct stp4020_socket *h = (struct stp4020_socket *)pch;

	if (h->softint != NULL) {
		softintr_disestablish(h->softint);
		h->softint = NULL;
	}
	h->intrhandler = NULL;
	h->intrarg = NULL;
}

const char *
stp4020_chip_intr_string(pch, ih)
	pcmcia_chipset_handle_t pch;
	void *ih;
{
	if (ih == NULL)
		return ("couldn't establish interrupt");
	else
		return ("");	/* nothing for now */
}

/*
 * Delay and possibly yield CPU.
 * XXX - assumes a context
 */
void
stp4020_delay(ms)
	unsigned int ms;
{
	unsigned int nticks;

	/* Convert to nticks */
	nticks = (ms * hz) / 1000000;

	if (cold || nticks == 0) {
		delay(ms);
		return;
	}

#ifdef DEBUG
	if (nticks > 60 * hz)
		panic("stp4020: preposterous delay: %u", nticks);
#endif
	tsleep(&nticks, 0, "stp4020_delay", nticks);
}

#ifdef STP4020_DEBUG
void
stp4020_dump_regs(h)
	struct stp4020_socket *h;
{
	/*
	 * Dump control and status registers.
	 */
	printf("socket[%d] registers:\n"
	    "\tICR0=%b\n\tICR1=%b\n\tISR0=%b\n\tISR1=%x\n", h->sock,
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX), STP4020_ICR0_BITS,
	    stp4020_rd_sockctl(h, STP4020_ICR1_IDX), STP4020_ICR1_BITS,
	    stp4020_rd_sockctl(h, STP4020_ISR0_IDX), STP4020_ISR0_IOBITS,
	    stp4020_rd_sockctl(h, STP4020_ISR1_IDX));
}
#endif /* STP4020_DEBUG */
@


1.18
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.17 2013/11/18 20:21:51 deraadt Exp $	*/
d901 1
a901 1
	unsigned int ticks;
d903 2
a904 2
	/* Convert to ticks */
	ticks = (ms * hz) / 1000000;
d906 1
a906 1
	if (cold || ticks == 0) {
d912 2
a913 2
	if (ticks > 60 * hz)
		panic("stp4020: preposterous delay: %u", ticks);
d915 1
a915 1
	tsleep(&ticks, 0, "stp4020_delay", ticks);
@


1.17
log
@simplify kthread_create(). no more stdarg
ok matthew guenther mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.16 2009/04/10 20:54:58 miod Exp $	*/
d301 1
a301 1
		panic("%s: unable to create event thread", name);
@


1.16
log
@Use soft interrupts to dispatch pcmcia device interrupts; this ensures the
driver handlers get invoked at the right level. Parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.15 2008/06/26 05:42:18 ray Exp $	*/
a297 1
	const char *name = sc->sc_dev.dv_xname;
d300 1
a300 1
	    "%s", name)) {
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.14 2005/11/23 11:39:37 mickey Exp $	*/
d52 1
d76 1
d237 6
d381 18
d405 4
d500 2
d511 4
d541 3
a543 1
			if (h->intrhandler != NULL) {
d545 2
a546 4
				 * We ought to be at an higher ipl level
				 * than the callback, since the first
				 * interrupt of this device is usually
				 * higher than IPL_CLOCK.
d548 2
a549 2
				splassert(h->ipl);
				(*h->intrhandler)(h->intrarg);
d555 2
d804 2
d812 1
d856 5
d863 3
a865 2
	h->ipl = ipl;
	return (h);
d875 4
@


1.14
log
@use proper bus_size_t for register offsets and not bus_addr_t; uwe@@ miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.13 2005/01/27 17:03:24 millert Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@Add pcmcia_intr_string() to format the intr string for pcmcia attach
routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.12 2004/03/03 21:47:39 miod Exp $	*/
d107 1
a107 1
	    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *);
d621 1
a621 1
	bus_addr_t *offsetp;
@


1.12
log
@The socket number diagnostic check was simply crying out for unsigned
arithmetic...
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.11 2004/03/02 23:10:18 miod Exp $	*/
d123 1
d139 1
d837 11
@


1.11
log
@Rework the card insertion/removal detection logic:
- instead of queueing events each time the sense information changes,
  only remember that the slot needs attention
- when processing a slot needing attention, decide what to do depending upon
  its current sense information, rather than what it was when the change
  was detected
- handle the ``only one sensor asserted'' state happening during slow
  insertion or removal.

This makes the driver much more reactive to insertions and removals, and
also removes unnecessary attach/detach calls.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.10 2003/06/25 22:49:06 mickey Exp $	*/
d311 2
a312 1
	int s, sense, socket;
d327 1
a327 1
		if (socket < 0 || socket >= STP4020_NSOCK) {
@


1.10
log
@fix #if/ifdef issue and use u_int16_t instead of int where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.9 2003/06/25 22:38:37 miod Exp $	*/
d41 2
a42 1
 * STP4020: SBus/PCMCIA bridge supporting two Type-3 PCMCIA cards.
a47 1
#include <sys/malloc.h>
a78 14
/*
 * Event queue; events detected in an interrupt context go here
 * awaiting attention from our event handling thread.
 */
struct stp4020_event {
	SIMPLEQ_ENTRY(stp4020_event) se_q;
	int	se_type;
	int	se_sock;
};

/* Defined event types */
#define STP4020_EVENT_INSERTION	0
#define STP4020_EVENT_REMOVAL	1

d100 1
a100 1
void	stp4020_queue_event(struct stp4020_softc *, int, int);
d217 1
a217 1
	SIMPLEQ_INIT(&sc->events);
d279 5
a283 5
	if ((v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST)) == 0)
		return;

	pcmcia_card_attach(h->pcmcia);
	h->flags |= STP4020_SOCKET_BUSY;
d311 1
a311 2
	struct stp4020_event *e;
	int s;
d313 1
a313 1
	while (1) {
a314 1
		int n;
d317 1
a317 1
		if ((e = SIMPLEQ_FIRST(&sc->events)) == NULL) {
d319 1
a319 1
			(void)tsleep(&sc->events, PWAIT, "pcicev", 0);
d322 2
a323 1
		SIMPLEQ_REMOVE_HEAD(&sc->events, e, se_q);
d326 34
a359 16
		n = e->se_sock;
		if (n < 0 || n >= STP4020_NSOCK)
			panic("stp4020_event_thread: wayward socket number %d",
			    n);

		h = &sc->sc_socks[n];
		switch (e->se_type) {
		case STP4020_EVENT_INSERTION:
			pcmcia_card_attach(h->pcmcia);
			break;
		case STP4020_EVENT_REMOVAL:
			pcmcia_card_detach(h->pcmcia, DETACH_FORCE);
			break;
		default:
			panic("stp4020_event_thread: unknown event type %d",
			    e->se_type);
a360 1
		free(e, M_TEMP);
d365 1
a365 1
stp4020_queue_event(sc, sock, event)
d367 1
a367 1
	int sock, event;
a368 1
	struct stp4020_event *e;
a370 6
	e = malloc(sizeof(*e), M_TEMP, M_NOWAIT);
	if (e == NULL)
		panic("stp4020_queue_event: can't allocate event");

	e->se_type = event;
	e->se_sock = sock;
d372 1
a372 1
	SIMPLEQ_INSERT_TAIL(&sc->events, e, se_q);
d382 1
a382 1
	int i, r = 0;
d395 1
d408 2
d411 11
a421 1
			 * Card status change detect
d423 3
a425 17
			r = 1;
			if ((v & (STP4020_ISR0_CD1ST|STP4020_ISR0_CD2ST)) ==
			    (STP4020_ISR0_CD1ST|STP4020_ISR0_CD2ST)) {
				if ((h->flags & STP4020_SOCKET_BUSY) == 0) {
					stp4020_queue_event(sc, i,
					    STP4020_EVENT_INSERTION);
					h->flags |= STP4020_SOCKET_BUSY;
				}
			}
			if ((v & (STP4020_ISR0_CD1ST|STP4020_ISR0_CD2ST)) ==
			    0) {
				if ((h->flags & STP4020_SOCKET_BUSY) != 0) {
					stp4020_queue_event(sc, i,
					    STP4020_EVENT_REMOVAL);
					h->flags &= ~STP4020_SOCKET_BUSY;
				}
			}
d466 2
a467 2
		 * Not an interrupt flag per se, but interrupts occur when
		 * it is asserted, at least on sparc.
d469 2
a470 3
		if ((v & STP4020_ISR0_WAITST) != 0) {
			DPRINTF(("stp4020[%d]: Wait signal\n",
			    h->sock));
a471 1
		}
d511 4
a514 6
				 * Called without handling of it's requested
				 * protection level (h->ipl), since we have
				 * no general queuing mechanism available
				 * right now and we know for sure we are
				 * running at a higher protection level
				 * right now.
d516 1
d697 2
a724 2
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, 
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) | STP4020_ICR0_RESET);
d729 2
a731 2

	/* Clear reset flag */
d741 5
d755 1
d774 1
a774 2
		    STP4020_ICR0_SPKREN | STP4020_ICR0_IOILVL_SB0 |
		    STP4020_ICR0_IOILVL_SB1 | STP4020_ICR0_SPKREN);
d780 2
d795 2
a796 1
	v &= ~(STP4020_ICR0_IOIE | STP4020_ICR0_IOILVL);
d847 1
a847 1
	ticks = (ms * hz ) / 1000000;
d854 1
a854 1
#ifdef DIAGNOSTIC
@


1.9
log
@Acknowledge the status interrupt in some odd and usually rare cases, which
could render a sparc so crazy it would panic...
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.8 2003/06/25 22:33:18 mickey Exp $	*/
d72 1
a72 2

#if defined(STP4020_DEBUG)
d105 4
a108 4
static int	stp4020_rd_sockctl(struct stp4020_socket *, int);
static void	stp4020_wr_sockctl(struct stp4020_socket *, int, int);
static int	stp4020_rd_winctl(struct stp4020_socket *, int, int);
static void	stp4020_wr_winctl(struct stp4020_socket *, int, int, int);
d158 1
a158 1
static __inline__ int
d171 1
a171 1
	int v;
d177 1
a177 1
static __inline__ int
d193 1
a193 1
	int v;
@


1.8
log
@mimic delays pattern from i82365 on socket enable. actually pull the reset line before clearing it. this together makes some more cards work and unwedges my wedged wedgy on reboot alright; miod@@ ok and testing
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.7 2003/06/25 21:20:54 mickey Exp $	*/
d462 16
@


1.7
log
@fix all the _BITS and their use
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.6 2003/06/25 17:36:49 miod Exp $	*/
d709 3
d713 1
a713 1
	stp4020_delay((100 + 20) * 1000);
d717 2
d721 1
a721 1
	 * hold RESET at least 10us.
d723 1
a723 1
	delay(10);
d726 2
a727 3
	v = stp4020_rd_sockctl(h, STP4020_ICR0_IDX);
	v &= ~STP4020_ICR0_RESET;
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, v);
@


1.6
log
@Let the stp driver use different bus_space_tag_t for its own device access,
and for access to the pcmcia windows from the pcmcia drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.5 2003/06/23 09:28:00 miod Exp $	*/
d403 3
a405 6
		if (stp4020_debug != 0) {
			char bits[64];
			bitmask_snprintf(v, STP4020_ISR0_IOBITS,
			    bits, sizeof(bits));
			printf("stp4020_statintr: ISR0=%s\n", bits);
		}
d736 3
a738 6
#if STP4020_DEBUG
		char bits[64];
		bitmask_snprintf(stp4020_rd_sockctl(h, STP4020_ISR0_IDX),
		    STP4020_ISR0_IOBITS, bits, sizeof(bits));
		printf("stp4020_chip_socket_enable: not ready: status %s\n",
		    bits);
a847 1
	char bits[64];
d851 6
a856 16
	printf("socket[%d] registers:\n", h->sock);
	bitmask_snprintf(stp4020_rd_sockctl(h, STP4020_ICR0_IDX),
	    STP4020_ICR0_BITS, bits, sizeof(bits));
	printf("\tICR0=%s\n", bits);

	bitmask_snprintf(stp4020_rd_sockctl(h, STP4020_ICR1_IDX),
	    STP4020_ICR1_BITS, bits, sizeof(bits));
	printf("\tICR1=%s\n", bits);

	bitmask_snprintf(stp4020_rd_sockctl(h, STP4020_ISR0_IDX),
	    STP4020_ISR0_IOBITS, bits, sizeof(bits));
	printf("\tISR0=%s\n", bits);

	bitmask_snprintf(stp4020_rd_sockctl(h, STP4020_ISR1_IDX),
	    STP4020_ISR1_BITS, bits, sizeof(bits));
	printf("\tISR1=%s\n", bits);
@


1.5
log
@Split the stp driver into its core, and md attachment routines, and provide
attachment routines for sparc and sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.4 2002/06/21 07:55:26 fgsch Exp $	*/
d592 1
a592 1
	pcmhp->memt = h->tag;
d621 2
a622 2
	pcmhp->memt = h->tag;
	bus_space_subregion(h->tag, h->windows[win].winaddr,
d627 1
a627 1
	*windowp = 0;
d649 1
a649 1
	pcihp->iot = h->tag;
d673 2
a674 2
	pcihp->iot = h->tag;
	bus_space_subregion(h->tag, h->windows[STP_WIN_IO].winaddr,
@


1.4
log
@make this more quiet on card insertion.
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.3 2002/06/20 02:43:23 deraadt Exp $	*/
a58 1
#include <machine/intr.h>
a59 1
#include <dev/sbus/sbusvar.h>
d61 1
a93 36
/*
 * Per socket data.
 */
struct stp4020_socket {
	struct stp4020_softc	*sc;	/* Back link */
	int		flags;
#define STP4020_SOCKET_BUSY	0x0001
#define STP4020_SOCKET_SHUTDOWN	0x0002
	int		sock;		/* Socket number (0 or 1) */
	bus_space_tag_t	tag;		/* socket control space */
	bus_space_handle_t	regs;	/* 			*/
	struct device	*pcmcia;	/* Associated PCMCIA device */
	int		(*intrhandler)	/* Card driver interrupt handler */
			    (void *);
	void		*intrarg;	/* Card interrupt handler argument */
	int		ipl;		/* Interrupt level suggested by card */
	struct {
		bus_space_handle_t	winaddr;/* this window's address */
	} windows[STP4020_NWIN];

};

struct stp4020_softc {
	struct device	sc_dev;		/* Base device */
	struct sbusdev	sc_sd;		/* SBus device */
	bus_space_tag_t	sc_bustag;
	bus_dma_tag_t	sc_dmatag;
	pcmcia_chipset_tag_t	sc_pct;	/* Chipset methods */

	struct proc	*event_thread;		/* event handling thread */
	SIMPLEQ_HEAD(, stp4020_event)	events;	/* Pending events for thread */

	struct stp4020_socket sc_socks[STP4020_NSOCK];
};


a94 4
int	stpmatch(struct device *, void *, void *);
void	stpattach(struct device *, struct device *, void *);
int	stp4020_iointr(void *);
int	stp4020_statintr(void *);
d98 1
a98 5
struct cfattach stp_ca = {
	sizeof(struct stp4020_softc), stpmatch, stpattach
};

struct cfdriver stp_cd = {
a213 11
int
stpmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct sbus_attach_args *sa = aux;

	return (strcmp("SUNW,pcmcia", sa->sa_name) == 0);
}

d218 1
a218 3
stpattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d220 1
a220 79
	struct sbus_attach_args *sa = aux;
	struct stp4020_softc *sc = (void *)self;
	int node, rev;
	int i;
	bus_space_handle_t bh;

	node = sa->sa_node;

	/* Transfer bus tags */
	sc->sc_bustag = sa->sa_bustag;
	sc->sc_dmatag = sa->sa_dmatag;

	/* Set up per-socket static initialization */
	sc->sc_socks[0].sc = sc->sc_socks[1].sc = sc;
	sc->sc_socks[0].tag = sc->sc_socks[1].tag = sa->sa_bustag;

	if (sa->sa_nreg < 8) {
		printf(": only %d register sets\n", sa->sa_nreg);
		return;
	}

	if (sa->sa_nintr != 2) {
		printf(": expect 2 interrupt Sbus levels; got %d\n",
		    sa->sa_nintr);
		return;
	}

#define STP4020_BANK_PROM	0
#define STP4020_BANK_CTRL	4
	for (i = 0; i < 8; i++) {

		/*
		 * STP4020 Register address map:
		 *	bank  0:   Forth PROM
		 *	banks 1-3: socket 0, windows 0-2
		 *	bank  4:   control registers
		 *	banks 5-7: socket 1, windows 0-2
		 */

		if (i == STP4020_BANK_PROM)
			/* Skip the PROM */
			continue;

		if (sbus_bus_map(sa->sa_bustag, sa->sa_reg[i].sbr_slot,
		    sa->sa_reg[i].sbr_offset, sa->sa_reg[i].sbr_size,
		    BUS_SPACE_MAP_LINEAR, 0, &bh) != 0) {
			printf(": attach: cannot map registers\n");
			return;
		}

		if (i == STP4020_BANK_CTRL) {
			/*
			 * Copy tag and handle to both socket structures
			 * for easy access in control/status IO functions.
			 */
			sc->sc_socks[0].regs = sc->sc_socks[1].regs = bh;
		} else if (i < STP4020_BANK_CTRL) {
			/* banks 1-3 */
			sc->sc_socks[0].windows[i-1].winaddr = bh;
		} else {
			/* banks 5-7 */
			sc->sc_socks[1].windows[i-5].winaddr = bh;
		}
	}

	sbus_establish(&sc->sc_sd, &sc->sc_dev);

	/*
	 * We get to use two SBus interrupt levels.
	 * The higher level we use for status change interrupts;
	 * the lower level for PC card I/O.
	 */
	if (sa->sa_nintr != 0) {
		bus_intr_establish(sa->sa_bustag, sa->sa_intr[1].sbi_pri,
		    IPL_NONE, 0, stp4020_statintr, sc);

		bus_intr_establish(sa->sa_bustag, sa->sa_intr[0].sbi_pri,
		    IPL_NONE, 0, stp4020_iointr, sc);
	}
d243 1
a243 1
		stp4020_attach_socket(h, sa->sa_frequency);
d517 1
@


1.4.8.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
d61 1
a62 1
#include <dev/sbus/stp4020var.h>
d73 2
a74 1
#ifdef STP4020_DEBUG
d95 36
d132 4
d139 5
a143 1
struct	cfdriver stp_cd = {
d151 4
a154 4
static u_int16_t stp4020_rd_sockctl(struct stp4020_socket *, int);
static void	stp4020_wr_sockctl(struct stp4020_socket *, int, u_int16_t);
static u_int16_t stp4020_rd_winctl(struct stp4020_socket *, int, int);
static void	stp4020_wr_winctl(struct stp4020_socket *, int, int, u_int16_t);
d204 1
a204 1
static __inline__ u_int16_t
d217 1
a217 1
	u_int16_t v;
d223 1
a223 1
static __inline__ u_int16_t
d239 1
a239 1
	u_int16_t v;
d259 11
d274 3
a276 1
stpattach_common(struct stp4020_softc *sc, int clockfreq)
d278 79
a356 1
	int i, rev;
d379 1
a379 1
		stp4020_attach_socket(h, clockfreq);
d539 6
a544 3
		if (stp4020_debug != 0)
			printf("stp4020_statintr: ISR0=%b\n",
			    v, STP4020_ISR0_IOBITS);
a603 16

		if ((v & STP4020_ISR0_SCINT) != 0) {
			DPRINTF(("stp4020[%d]: Status change\n",
			    h->sock));
			r = 1;
		}

		/*
		 * Not an interrupt flag per se, but interrupts occur when
		 * it is asserted, at least on sparc.
		 */
		if ((v & STP4020_ISR0_WAITST) != 0) {
			DPRINTF(("stp4020[%d]: Wait signal\n",
			    h->sock));
			r = 1;
		}
a652 1

d727 1
a727 1
	pcmhp->memt = h->wintag;
d756 2
a757 2
	pcmhp->memt = h->wintag;
	bus_space_subregion(h->wintag, h->windows[win].winaddr,
d762 1
a762 1
	*windowp = win;
d784 1
a784 1
	pcihp->iot = h->wintag;
d808 2
a809 2
	pcihp->iot = h->wintag;
	bus_space_subregion(h->wintag, h->windows[STP_WIN_IO].winaddr,
a846 3
	 *
	 * some machines require some more time to be settled
	 * (another 200ms is added here).
d848 1
a848 1
	stp4020_delay((100 + 20 + 200) * 1000);
a851 2
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, 
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) | STP4020_ICR0_RESET);
d854 1
a854 1
	 * hold RESET at least 20us.
d856 1
a856 1
	delay(20);
d859 3
a861 2
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX,
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) & ~STP4020_ICR0_RESET);
d874 6
a879 3
#ifdef STP4020_DEBUG
		printf("stp4020_chip_socket_enable: not ready: status %b\n",
		    v, STP4020_ISR0_IOBITS);
d989 1
d993 16
a1008 6
	printf("socket[%d] registers:\n"
	    "\tICR0=%b\n\tICR1=%b\n\tISR0=%b\n\tISR1=%x\n", h->sock,
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX), STP4020_ICR0_BITS,
	    stp4020_rd_sockctl(h, STP4020_ICR1_IDX), STP4020_ICR1_BITS,
	    stp4020_rd_sockctl(h, STP4020_ISR0_IDX), STP4020_ISR0_IOBITS,
	    stp4020_rd_sockctl(h, STP4020_ISR1_IDX));
@


1.4.8.2
log
@Merge with the trunk
@
text
@d41 1
a41 2
 * STP4020: SBus/PCMCIA bridge supporting one Type-3 PCMCIA card, or up to
 * two Type-1 and Type-2 PCMCIA cards..
d47 1
d79 14
d114 1
a114 1
void	stp4020_queue_event(struct stp4020_softc *, int);
d231 1
a231 1
	sc->events = 0;
d293 5
a297 5
	h->sense = v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST);
	if (h->sense != 0) {
		h->flags |= STP4020_SOCKET_BUSY;
		pcmcia_card_attach(h->pcmcia);
	}
d325 2
a326 2
	int s, sense;
	unsigned int socket;
d328 1
a328 1
	for (;;) {
d330 1
d333 1
a333 1
		if ((socket = ffs(sc->events)) == 0) {
d335 1
a335 1
			(void)tsleep(&sc->events, PWAIT, "stp4020_ev", 0);
d338 1
a338 2
		socket--;
		sc->events &= ~(1 << socket);
d341 16
a356 34
		if (socket >= STP4020_NSOCK) {
#ifdef DEBUG
			printf("stp4020_event_thread: wayward socket number %d\n",
			    socket);
#endif
			continue;
		}

		h = &sc->sc_socks[socket];

		/* Read socket's ISR0 for the interrupt status bits */
		sense = stp4020_rd_sockctl(h, STP4020_ISR0_IDX) &
		    (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST);

		if (sense > h->sense) {
			/*
			 * If at least one more sensor is asserted, this is
			 * a card insertion.
			 */
			h->sense = sense;
			if ((h->flags & STP4020_SOCKET_BUSY) == 0) {
				h->flags |= STP4020_SOCKET_BUSY;
				pcmcia_card_attach(h->pcmcia);
			}
		} else if (sense < h->sense) {
			/*
			 * If at least one less sensor is asserted, this is
			 * a card removal.
			 */
			h->sense = sense;
			if (h->flags & STP4020_SOCKET_BUSY) {
				h->flags &= ~STP4020_SOCKET_BUSY;
				pcmcia_card_detach(h->pcmcia, DETACH_FORCE);
			}
d358 1
d363 1
a363 1
stp4020_queue_event(sc, sock)
d365 1
a365 1
	int sock;
d367 1
d370 6
d377 1
a377 1
	sc->events |= (1 << sock);
d387 1
a387 1
	int i, sense, r = 0;
a399 1
		sense = v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST);
a411 2
			r = 1;

d413 1
a413 11
			 * Card detect status changed. In an ideal world,
			 * both card detect sensors should be set if a card
			 * is in the slot, and clear if it is not.
			 *
			 * Unfortunately, it turns out that we can get the
			 * notification before both sensors are set (or
			 * clear).
			 *
			 * This can be very funny if only one sensor is set.
			 * Is this a removal or an insertion operation?
			 * Defer appropriate action to the worker thread.
d415 17
a431 3
			if (sense != h->sense)
				stp4020_queue_event(sc, i);

d472 2
a473 2
		 * Not interrupts flag per se, but interrupts can occur when
		 * they are asserted, at least during our slot enable routine.
d475 3
a477 2
		if ((h->flags & STP4020_SOCKET_ENABLING) &&
		    (v & (STP4020_ISR0_WAITST | STP4020_ISR0_PWRON)))
d479 1
d519 6
a524 4
				 * We ought to be at an higher ipl level
				 * than the callback, since the first
				 * interrupt of this device is usually
				 * higher than IPL_CLOCK.
a525 1
				splassert(h->ipl);
a705 2
	h->flags |= STP4020_SOCKET_ENABLING;

d732 2
a737 2
	stp4020_wr_sockctl(h, STP4020_ICR0_IDX, 
	    stp4020_rd_sockctl(h, STP4020_ICR0_IDX) | STP4020_ICR0_RESET);
d739 2
a749 5
		/* If the card has been removed, abort */
		if ((v & (STP4020_ISR0_CD1ST | STP4020_ISR0_CD2ST)) == 0) {
			h->flags &= ~STP4020_SOCKET_ENABLING;
			return;
		}
a758 1
		h->flags &= ~STP4020_SOCKET_ENABLING;
d777 2
a778 1
		    STP4020_ICR0_SPKREN | STP4020_ICR0_IOIE);
a783 2

	h->flags &= ~STP4020_SOCKET_ENABLING;
d797 1
a797 2
	v &= ~(STP4020_ICR0_IOILVL | STP4020_ICR0_IFTYPE |
	    STP4020_ICR0_SPKREN | STP4020_ICR0_IOIE);
d848 1
a848 1
	ticks = (ms * hz) / 1000000;
d855 1
a855 1
#ifdef DEBUG
@


1.4.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3
log
@rename nell to stp.  we do not always follow stupid solaris names
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.2 2002/06/19 20:57:15 fgsch Exp $	*/
d531 1
a531 1
		int v, cd_change = 0;
a554 1
			cd_change = 1;
d576 2
a577 4
			/* ignore if this is caused by insert or removal */
			if (!cd_change)
				printf("stp4020[%d]: Battery change 1\n",
				    h->sock);
d582 2
a583 4
			/* ignore if this is caused by insert or removal */
			if (!cd_change)
				printf("stp4020[%d]: Battery change 2\n",
				    h->sock);
d850 1
a850 1
	v |= STP4020_ICR1_PCIFOE|STP4020_ICR1_VPP1_VCC;
@


1.2
log
@- set the size correctly.
- a few minor cosmetical changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: stp4020.c,v 1.1 2002/06/19 19:14:21 fgsch Exp $	*/
d132 2
a133 2
int	stp4020match(struct device *, void *, void *);
void	stp4020attach(struct device *, struct device *, void *);
d139 2
a140 2
struct cfattach nell_ca = {
	sizeof(struct stp4020_softc), stp4020match, stp4020attach
d143 2
a144 2
struct cfdriver nell_cd = {
	NULL, "nell", DV_DULL
d260 1
a260 1
stp4020match(parent, match, aux)
d274 1
a274 1
stp4020attach(parent, self, aux)
@


1.1
log
@sbus pcmcia bridge driver (nell); from NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: stp4020.c,v 1.23 2002/06/01 23:51:03 lukem Exp $ */
d704 2
a705 2
	v = ((delay << STP4020_WCR0_CMDDLY_S)&STP4020_WCR0_CMDDLY_M) |
	    ((length << STP4020_WCR0_CMDLNG_S)&STP4020_WCR0_CMDLNG_M);
d791 1
@

