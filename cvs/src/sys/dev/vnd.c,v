head	1.165;
access;
symbols
	OPENBSD_6_2_BASE:1.165
	OPENBSD_6_1:1.163.0.4
	OPENBSD_6_1_BASE:1.163
	OPENBSD_6_0:1.158.0.2
	OPENBSD_6_0_BASE:1.158
	OPENBSD_5_9:1.157.0.2
	OPENBSD_5_9_BASE:1.157
	OPENBSD_5_8:1.155.0.6
	OPENBSD_5_8_BASE:1.155
	OPENBSD_5_7:1.155.0.4
	OPENBSD_5_7_BASE:1.155
	OPENBSD_5_6:1.153.0.4
	OPENBSD_5_6_BASE:1.153
	OPENBSD_5_5:1.152.0.4
	OPENBSD_5_5_BASE:1.152
	OPENBSD_5_4:1.150.0.2
	OPENBSD_5_4_BASE:1.150
	OPENBSD_5_3:1.149.0.6
	OPENBSD_5_3_BASE:1.149
	OPENBSD_5_2:1.149.0.4
	OPENBSD_5_2_BASE:1.149
	OPENBSD_5_1_BASE:1.149
	OPENBSD_5_1:1.149.0.2
	OPENBSD_5_0:1.148.0.2
	OPENBSD_5_0_BASE:1.148
	OPENBSD_4_9:1.107.0.2
	OPENBSD_4_9_BASE:1.107
	OPENBSD_4_8:1.100.0.2
	OPENBSD_4_8_BASE:1.100
	OPENBSD_4_7:1.95.0.2
	OPENBSD_4_7_BASE:1.95
	OPENBSD_4_6:1.93.0.4
	OPENBSD_4_6_BASE:1.93
	OPENBSD_4_5:1.90.0.2
	OPENBSD_4_5_BASE:1.90
	OPENBSD_4_4:1.88.0.2
	OPENBSD_4_4_BASE:1.88
	OPENBSD_4_3:1.84.0.2
	OPENBSD_4_3_BASE:1.84
	OPENBSD_4_2:1.79.0.2
	OPENBSD_4_2_BASE:1.79
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.62.0.2
	OPENBSD_4_0_BASE:1.62
	OPENBSD_3_9:1.58.0.2
	OPENBSD_3_9_BASE:1.58
	OPENBSD_3_8:1.56.0.2
	OPENBSD_3_8_BASE:1.56
	OPENBSD_3_7:1.53.0.2
	OPENBSD_3_7_BASE:1.53
	OPENBSD_3_6:1.52.0.2
	OPENBSD_3_6_BASE:1.52
	SMP_SYNC_A:1.46
	SMP_SYNC_B:1.46
	OPENBSD_3_5:1.45.0.2
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	UBC_SYNC_A:1.37
	OPENBSD_3_3:1.35.0.2
	OPENBSD_3_3_BASE:1.35
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	UBC_SYNC_B:1.34
	UBC:1.30.0.2
	UBC_BASE:1.30
	OPENBSD_3_0:1.27.0.6
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.4
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.23.0.10
	OPENBSD_2_7_BASE:1.23
	SMP:1.23.0.8
	SMP_BASE:1.23
	kame_19991208:1.23
	OPENBSD_2_6:1.23.0.6
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.23.0.4
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.23.0.2
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.21.0.2
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.165
date	2017.07.19.14.54.29;	author deraadt;	state Exp;
branches;
next	1.164;
commitid	bZVfcdmGxFUQSD5U;

1.164
date	2017.07.19.13.38.05;	author deraadt;	state Exp;
branches;
next	1.163;
commitid	0iKDXegiGSGV9FP5;

1.163
date	2017.01.21.05.42.04;	author guenther;	state Exp;
branches;
next	1.162;
commitid	CHRb0fCqa8XxUAMH;

1.162
date	2016.12.14.18.59.12;	author jca;	state Exp;
branches;
next	1.161;
commitid	FSTBjzZz3mbDmcPm;

1.161
date	2016.11.12.11.16.59;	author jca;	state Exp;
branches;
next	1.160;
commitid	307vh1PKlkEMsTeQ;

1.160
date	2016.11.12.10.59.37;	author jca;	state Exp;
branches;
next	1.159;
commitid	aVzxqkbPRVLX8l54;

1.159
date	2016.10.08.05.52.06;	author guenther;	state Exp;
branches;
next	1.158;
commitid	gFhAhnnQ2SlMacGa;

1.158
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.157;
commitid	gAjwyca5TfuoJAhn;

1.157
date	2015.08.26.22.36.18;	author deraadt;	state Exp;
branches;
next	1.156;
commitid	eIAy6MqrbTcCL9Ci;

1.156
date	2015.08.25.07.01.24;	author deraadt;	state Exp;
branches;
next	1.155;
commitid	uZTyvm19K5hpZnGp;

1.155
date	2014.12.13.21.05.32;	author doug;	state Exp;
branches;
next	1.154;
commitid	20ZyHa9gTJxHxhwD;

1.154
date	2014.10.17.02.05.06;	author tedu;	state Exp;
branches;
next	1.153;
commitid	BLOslqePzDqlwGRU;

1.153
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.152;
commitid	OBNa5kfxQ2UXoiIw;

1.152
date	2013.11.12.14.11.07;	author krw;	state Exp;
branches;
next	1.151;

1.151
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.150;

1.150
date	2013.06.11.16.42.14;	author deraadt;	state Exp;
branches;
next	1.149;

1.149
date	2011.08.26.04.36.42;	author matthew;	state Exp;
branches;
next	1.148;

1.148
date	2011.07.18.02.49.20;	author matthew;	state Exp;
branches;
next	1.147;

1.147
date	2011.07.12.22.51.21;	author deraadt;	state Exp;
branches;
next	1.146;

1.146
date	2011.07.08.20.10.34;	author matthew;	state Exp;
branches;
next	1.145;

1.145
date	2011.07.08.05.27.46;	author matthew;	state Exp;
branches;
next	1.144;

1.144
date	2011.07.08.05.11.21;	author matthew;	state Exp;
branches;
next	1.143;

1.143
date	2011.07.08.05.07.05;	author matthew;	state Exp;
branches;
next	1.142;

1.142
date	2011.07.06.17.28.00;	author matthew;	state Exp;
branches;
next	1.141;

1.141
date	2011.07.06.17.26.33;	author matthew;	state Exp;
branches;
next	1.140;

1.140
date	2011.07.06.05.12.46;	author matthew;	state Exp;
branches;
next	1.139;

1.139
date	2011.07.06.05.09.01;	author matthew;	state Exp;
branches;
next	1.138;

1.138
date	2011.07.06.04.49.36;	author matthew;	state Exp;
branches;
next	1.137;

1.137
date	2011.07.04.20.35.34;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2011.07.03.18.08.14;	author matthew;	state Exp;
branches;
next	1.135;

1.135
date	2011.07.03.17.42.42;	author matthew;	state Exp;
branches;
next	1.134;

1.134
date	2011.06.30.16.28.05;	author matthew;	state Exp;
branches;
next	1.133;

1.133
date	2011.06.21.01.47.15;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2011.06.20.22.14.17;	author tedu;	state Exp;
branches;
next	1.131;

1.131
date	2011.06.20.16.46.06;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2011.06.19.04.55.33;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2011.06.19.04.35.03;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2011.06.19.04.29.41;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2011.06.19.04.28.46;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2011.06.09.05.41.18;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.124;

1.124
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.123;

1.123
date	2011.06.02.19.18.21;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2011.06.02.19.17.24;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2011.06.02.19.16.28;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2011.06.02.19.12.02;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2011.06.02.19.10.19;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2011.06.02.19.09.29;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2011.06.02.16.14.40;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2011.05.31.17.35.35;	author matthew;	state Exp;
branches;
next	1.115;

1.115
date	2011.05.30.21.15.03;	author oga;	state Exp;
branches;
next	1.114;

1.114
date	2011.04.25.19.29.11;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2011.04.23.22.00.09;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2011.04.23.17.01.04;	author jsing;	state Exp;
branches;
next	1.111;

1.111
date	2011.04.23.14.57.01;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2011.04.22.21.28.56;	author miod;	state Exp;
branches;
next	1.109;

1.109
date	2011.04.18.16.50.22;	author thib;	state Exp;
branches;
next	1.108;

1.108
date	2011.04.02.15.24.03;	author thib;	state Exp;
branches;
next	1.107;

1.107
date	2011.02.15.20.02.11;	author thib;	state Exp;
branches;
next	1.106;

1.106
date	2011.01.06.17.32.42;	author thib;	state Exp;
branches;
next	1.105;

1.105
date	2011.01.05.15.35.43;	author thib;	state Exp;
branches;
next	1.104;

1.104
date	2010.12.22.13.12.14;	author jsing;	state Exp;
branches;
next	1.103;

1.103
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.102;

1.102
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.101;

1.101
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.100;

1.100
date	2010.07.22.14.34.06;	author thib;	state Exp;
branches;
next	1.99;

1.99
date	2010.07.01.17.48.33;	author thib;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.01.16.22.17;	author thib;	state Exp;
branches;
next	1.97;

1.97
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.96;

1.96
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.95;

1.95
date	2009.08.24.08.51.18;	author jasper;	state Exp;
branches;
next	1.94;

1.94
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.17.01.30.30;	author thib;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.04.05.57.27;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2009.06.03.22.09.30;	author thib;	state Exp;
branches;
next	1.90;

1.90
date	2008.09.03.23.24.25;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2008.08.14.17.10.29;	author jsing;	state Exp;
branches;
next	1.88;

1.88
date	2008.07.23.16.24.43;	author beck;	state Exp;
branches;
next	1.87;

1.87
date	2008.07.20.01.53.43;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2008.06.29.20.05.22;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2008.03.24.01.16.58;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2007.10.15.01.37.49;	author fgsch;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.29.07.08.02;	author fkr;	state Exp;
branches;
next	1.82;

1.82
date	2007.09.12.18.45.14;	author mk;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.11.13.39.33;	author gilles;	state Exp;
branches;
next	1.80;

1.80
date	2007.09.08.17.59.23;	author gilles;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.05.00.38.20;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.12.12.19.23;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.29.18.59.37;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2007.03.25.21.52.27;	author tedu;	state Exp;
branches;
next	1.71;

1.71
date	2007.03.25.18.02.37;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2007.02.26.11.25.23;	author pedro;	state Exp;
branches;
next	1.69;

1.69
date	2007.02.21.19.25.40;	author grunk;	state Exp;
branches;
next	1.68;

1.68
date	2007.02.01.01.02.05;	author pedro;	state Exp;
branches;
next	1.67;

1.67
date	2007.01.13.16.47.15;	author thib;	state Exp;
branches;
next	1.66;

1.66
date	2006.12.24.09.39.27;	author pedro;	state Exp;
branches;
next	1.65;

1.65
date	2006.10.05.18.29.26;	author thib;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.03.19.49.06;	author pedro;	state Exp;
branches;
next	1.63;

1.63
date	2006.09.20.13.51.19;	author pedro;	state Exp;
branches;
next	1.62;

1.62
date	2006.08.13.17.55.07;	author thib;	state Exp;
branches;
next	1.61;

1.61
date	2006.08.12.13.53.44;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2006.03.04.22.53.32;	author pedro;	state Exp;
branches;
next	1.58;

1.58
date	2006.01.22.00.40.02;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2005.12.29.20.02.03;	author pedro;	state Exp;
branches;
next	1.56;

1.56
date	2005.07.20.02.36.13;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2005.04.19.15.32.12;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.12.13.25.37;	author joris;	state Exp;
branches;
next	1.53;

1.53
date	2005.01.05.06.38.15;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2004.06.30.11.33.39;	author pedro;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.30.00.13.53;	author pedro;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.28.16.43.55;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.27.22.00.59;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.20.18.03.03;	author pedro;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.19.14.29.20;	author pedro;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.22.18.26.52;	author otto;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.04.01.22.50;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.03.22.03.23;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.15.02.52.10;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.15.02.45.46;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.17.23.05.39;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.11.03.31.07;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2003.08.15.20.32.16;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2003.06.02.23.28.01;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.19.12.59.13;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.06.22.01.43;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.25.09.13.35;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.24.13.10.52;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.23.22.47.16;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.07.00.11.14;	author niklas;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.11.27.05.27.11;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.15.23.15.15;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2000.07.05.07.27.12;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.26.19.00.25;	author provos;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.22.23.02.19;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.20.21.29.20;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	98.10.03.21.19.00;	author millert;	state Exp;
branches
	1.23.8.1;
next	1.22;

1.22
date	98.08.04.22.01.54;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	98.03.10.17.40.37;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.11.06.05.58.08;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	97.10.18.10.37.04;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.10.06.20.19.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.10.06.15.07.48;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	97.08.08.21.47.01;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	97.06.09.09.41.08;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.06.08.17.38.29;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.05.18.13.00.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.05.17.20.09.46;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.05.17.19.48.38;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.05.16.19.11.34;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.05.14.15.32.46;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.01.04.08.50.22;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.21.05.21.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.19.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.02.00.29.25;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.27.09.43.20;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.21.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.20.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches;
next	;

1.23.8.1
date	2001.05.14.22.23.04;	author niklas;	state Exp;
branches;
next	1.23.8.2;

1.23.8.2
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.23.8.3;

1.23.8.3
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.23.8.4;

1.23.8.4
date	2002.03.28.15.03.52;	author niklas;	state Exp;
branches;
next	1.23.8.5;

1.23.8.5
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.23.8.6;

1.23.8.6
date	2003.05.13.19.34.56;	author ho;	state Exp;
branches;
next	1.23.8.7;

1.23.8.7
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.23.8.8;

1.23.8.8
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	1.23.8.9;

1.23.8.9
date	2004.06.05.23.12.36;	author niklas;	state Exp;
branches;
next	;

1.30.2.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.165
log
@Avoid additional div0 in case both ntracks & nsectors passed in
via ioctl are 0.
Noticed by bluhm
ok bluhm millert
@
text
@/*	$OpenBSD: vnd.c,v 1.164 2017/07/19 13:38:05 deraadt Exp $	*/
/*	$NetBSD: vnd.c,v 1.26 1996/03/30 23:06:11 christos Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * There is a security issue involved with this driver.
 *
 * Once mounted all access to the contents of the "mapped" file via
 * the special file is controlled by the permissions on the special
 * file, the protection of the mapped file is ignored (effectively,
 * by using root credentials in all transactions).
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/errno.h>
#include <sys/limits.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/ioctl.h>
#include <sys/disklabel.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/stat.h>
#include <sys/vnode.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/conf.h>
#include <sys/dkio.h>
#include <sys/specdev.h>

#include <crypto/blf.h>

#include <dev/vndioctl.h>

#ifdef VNDDEBUG
int vnddebug = 0x00;
#define	VDB_FOLLOW	0x01
#define	VDB_INIT	0x02
#define	VDB_IO		0x04
#define	DNPRINTF(f, p...)	do { if ((f) & vnddebug) printf(p); } while (0)
#else
#define	DNPRINTF(f, p...)	/* nothing */
#endif	/* VNDDEBUG */

struct vnd_softc {
	struct device	 sc_dev;
	struct disk	 sc_dk;

	char		 sc_file[VNDNLEN];	/* file we're covering */
	int		 sc_flags;		/* flags */
	size_t		 sc_size;		/* size of vnd in sectors */
	size_t		 sc_secsize;		/* sector size in bytes */
	size_t		 sc_nsectors;		/* # of sectors per track */
	size_t		 sc_ntracks;		/* # of tracks per cylinder */
	struct vnode	*sc_vp;			/* vnode */
	struct ucred	*sc_cred;		/* credentials */
	blf_ctx		*sc_keyctx;		/* key context */
};

/* sc_flags */
#define	VNF_INITED	0x0001
#define	VNF_HAVELABEL	0x0002
#define	VNF_READONLY	0x0004

#define	VNDRW(v)	((v)->sc_flags & VNF_READONLY ? FREAD : FREAD|FWRITE)

struct vnd_softc *vnd_softc;
int numvnd = 0;

/* called by main() at boot time */
void	vndattach(int);

void	vndclear(struct vnd_softc *);
int	vndsetcred(struct vnd_softc *, struct ucred *);
int	vndgetdisklabel(dev_t, struct vnd_softc *, struct disklabel *, int);
void	vndencrypt(struct vnd_softc *, caddr_t, size_t, daddr_t, int);
void	vndencryptbuf(struct vnd_softc *, struct buf *, int);
size_t	vndbdevsize(struct vnode *, struct proc *);

void
vndencrypt(struct vnd_softc *sc, caddr_t addr, size_t size, daddr_t off,
    int encrypt)
{
	int i, bsize;
	u_char iv[8];

	bsize = dbtob(1);
	for (i = 0; i < size/bsize; i++) {
		memset(iv, 0, sizeof(iv));
		memcpy(iv, &off, sizeof(off));
		blf_ecb_encrypt(sc->sc_keyctx, iv, sizeof(iv));
		if (encrypt)
			blf_cbc_encrypt(sc->sc_keyctx, iv, addr, bsize);
		else
			blf_cbc_decrypt(sc->sc_keyctx, iv, addr, bsize);

		addr += bsize;
		off++;
	}
}

void
vndencryptbuf(struct vnd_softc *sc, struct buf *bp, int encrypt)
{
	vndencrypt(sc, bp->b_data, bp->b_bcount, bp->b_blkno, encrypt);
}

void
vndattach(int num)
{
	char *mem;
	int i;

	if (num <= 0)
		return;
	mem = mallocarray(num, sizeof(struct vnd_softc), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (mem == NULL) {
		printf("WARNING: no memory for vnode disks\n");
		return;
	}
	vnd_softc = (struct vnd_softc *)mem;
	for (i = 0; i < num; i++) {
		struct vnd_softc *sc = &vnd_softc[i];

		sc->sc_dev.dv_unit = i;
		snprintf(sc->sc_dev.dv_xname, sizeof(sc->sc_dev.dv_xname),
		    "vnd%d", i);
		disk_construct(&sc->sc_dk);
		device_ref(&sc->sc_dev);
	}
	numvnd = num;
}

int
vndopen(dev_t dev, int flags, int mode, struct proc *p)
{
	int unit = DISKUNIT(dev);
	struct vnd_softc *sc;
	int error = 0, part;

	DNPRINTF(VDB_FOLLOW, "vndopen(%x, %x, %x, %p)\n", dev, flags, mode, p);

	if (unit >= numvnd)
		return (ENXIO);
	sc = &vnd_softc[unit];

	if ((error = disk_lock(&sc->sc_dk)) != 0)
		return (error);

	if ((flags & FWRITE) && (sc->sc_flags & VNF_READONLY)) {
		error = EROFS;
		goto bad;
	}

	if ((sc->sc_flags & VNF_INITED) &&
	    (sc->sc_flags & VNF_HAVELABEL) == 0 &&
	    sc->sc_dk.dk_openmask == 0) {
		sc->sc_flags |= VNF_HAVELABEL;
		vndgetdisklabel(dev, sc, sc->sc_dk.dk_label, 0);
	}

	part = DISKPART(dev);
	error = disk_openpart(&sc->sc_dk, part, mode,
	    (sc->sc_flags & VNF_HAVELABEL) != 0);

bad:
	disk_unlock(&sc->sc_dk);
	return (error);
}

/*
 * Load the label information on the named device
 */
int
vndgetdisklabel(dev_t dev, struct vnd_softc *sc, struct disklabel *lp,
    int spoofonly)
{
	memset(lp, 0, sizeof(struct disklabel));

	lp->d_secsize = sc->sc_secsize;
	lp->d_nsectors = sc->sc_nsectors;
	lp->d_ntracks = sc->sc_ntracks;
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
	if (lp->d_secpercyl)
		lp->d_ncylinders = sc->sc_size / lp->d_secpercyl;

	strncpy(lp->d_typename, "vnd device", sizeof(lp->d_typename));
	lp->d_type = DTYPE_VND;
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
	DL_SETDSIZE(lp, sc->sc_size);
	lp->d_flags = 0;
	lp->d_version = 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	/* Call the generic disklabel extraction routine */
	return readdisklabel(DISKLABELDEV(dev), vndstrategy, lp, spoofonly);
}

int
vndclose(dev_t dev, int flags, int mode, struct proc *p)
{
	int unit = DISKUNIT(dev);
	struct vnd_softc *sc;
	int part;

	DNPRINTF(VDB_FOLLOW, "vndclose(%x, %x, %x, %p)\n", dev, flags, mode, p);

	if (unit >= numvnd)
		return (ENXIO);
	sc = &vnd_softc[unit];

	disk_lock_nointr(&sc->sc_dk);

	part = DISKPART(dev);

	disk_closepart(&sc->sc_dk, part, mode);

#if 0
	if (sc->sc_dk.dk_openmask == 0)
		sc->sc_flags &= ~VNF_HAVELABEL;
#endif

	disk_unlock(&sc->sc_dk);
	return (0);
}

void
vndstrategy(struct buf *bp)
{
	int unit = DISKUNIT(bp->b_dev);
	struct vnd_softc *sc;
	struct partition *p;
	off_t off;
	long origbcount;
	int s;

	DNPRINTF(VDB_FOLLOW, "vndstrategy(%p): unit %d\n", bp, unit);

	if (unit >= numvnd) {
		bp->b_error = ENXIO;
		goto bad;
	}
	sc = &vnd_softc[unit];

	if ((sc->sc_flags & VNF_HAVELABEL) == 0) {
		bp->b_error = ENXIO;
		goto bad;
	}

	/*
	 * Many of the distrib scripts assume they can issue arbitrary
	 * sized requests to raw vnd devices irrespective of the
	 * emulated disk geometry.
	 *
	 * To continue supporting this, round the block count up to a
	 * multiple of d_secsize for bounds_check_with_label(), and
	 * then restore afterwards.
	 *
	 * We only do this for non-encrypted vnd, because encryption
	 * requires operating on blocks at a time.
	 */
	origbcount = bp->b_bcount;
	if (sc->sc_keyctx == NULL) {
		u_int32_t secsize = sc->sc_dk.dk_label->d_secsize;
		bp->b_bcount = ((origbcount + secsize - 1) & ~(secsize - 1));
#ifdef DIAGNOSTIC
		if (bp->b_bcount != origbcount) {
			struct process *curpr = curproc->p_p;
			printf("%s: sloppy %s from proc %d (%s): "
			    "blkno %lld bcount %ld\n", sc->sc_dev.dv_xname,
			    (bp->b_flags & B_READ) ? "read" : "write",
			    curpr->ps_pid, curpr->ps_comm,
			    (long long)bp->b_blkno, origbcount);
		}
#endif
	}

	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) == -1) {
		bp->b_resid = bp->b_bcount = origbcount;
		goto done;
	}

	if (origbcount < bp->b_bcount)
		bp->b_bcount = origbcount;

	p = &sc->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
	off = DL_GETPOFFSET(p) * sc->sc_dk.dk_label->d_secsize +
	    (u_int64_t)bp->b_blkno * DEV_BSIZE;

	if (sc->sc_keyctx && !(bp->b_flags & B_READ))
		vndencryptbuf(sc, bp, 1);

	/*
	 * Use IO_NOLIMIT because upper layer has already checked I/O
	 * for limits, so there is no need to do it again.
	 */
	bp->b_error = vn_rdwr((bp->b_flags & B_READ) ? UIO_READ : UIO_WRITE,
	    sc->sc_vp, bp->b_data, bp->b_bcount, off, UIO_SYSSPACE, IO_NOLIMIT,
	    sc->sc_cred, &bp->b_resid, curproc);
	if (bp->b_error)
		bp->b_flags |= B_ERROR;

	/* Data in buffer cache needs to be in clear */
	if (sc->sc_keyctx)
		vndencryptbuf(sc, bp, 0);

	goto done;

 bad:
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:
	s = splbio();
	biodone(bp);
	splx(s);
}

/* ARGSUSED */
int
vndread(dev_t dev, struct uio *uio, int flags)
{
	return (physio(vndstrategy, dev, B_READ, minphys, uio));
}

/* ARGSUSED */
int
vndwrite(dev_t dev, struct uio *uio, int flags)
{
	return (physio(vndstrategy, dev, B_WRITE, minphys, uio));
}

size_t
vndbdevsize(struct vnode *vp, struct proc *p)
{
	struct partinfo pi;
	struct bdevsw *bsw;
	dev_t dev;

	dev = vp->v_rdev;
	bsw = bdevsw_lookup(dev);
	if (bsw->d_ioctl == NULL)
		return (0);
	if (bsw->d_ioctl(dev, DIOCGPART, (caddr_t)&pi, FREAD, p))
		return (0);
	DNPRINTF(VDB_INIT, "vndbdevsize: size %llu secsize %u\n",
	    DL_GETPSIZE(pi.part), pi.disklab->d_secsize);
	return (DL_GETPSIZE(pi.part));
}

/* ARGSUSED */
int
vndioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	int unit = DISKUNIT(dev);
	struct disklabel *lp;
	struct vnd_softc *sc;
	struct vnd_ioctl *vio;
	struct vnd_user *vnu;
	struct vattr vattr;
	struct nameidata nd;
	int error, part, pmask;

	DNPRINTF(VDB_FOLLOW, "vndioctl(%x, %lx, %p, %x, %p): unit %d\n",
	    dev, cmd, addr, flag, p, unit);

	error = suser(p, 0);
	if (error)
		return (error);
	if (unit >= numvnd)
		return (ENXIO);

	sc = &vnd_softc[unit];
	vio = (struct vnd_ioctl *)addr;
	switch (cmd) {

	case VNDIOCSET:
		if (sc->sc_flags & VNF_INITED)
			return (EBUSY);

		/* Geometry eventually has to fit into label fields */
		if (vio->vnd_secsize > UINT_MAX ||
		    vio->vnd_secsize == 0 ||
		    vio->vnd_ntracks > UINT_MAX ||
		    vio->vnd_nsectors > UINT_MAX)
			return (EINVAL);

		if ((error = disk_lock(&sc->sc_dk)) != 0)
			return (error);

		if ((error = copyinstr(vio->vnd_file, sc->sc_file,
		    sizeof(sc->sc_file), NULL))) {
			disk_unlock(&sc->sc_dk);
			return (error);
		}

		/* Set geometry for device. */
		sc->sc_secsize = vio->vnd_secsize;
		sc->sc_ntracks = vio->vnd_ntracks;
		sc->sc_nsectors = vio->vnd_nsectors;

		/*
		 * Open for read and write first. This lets vn_open() weed out
		 * directories, sockets, etc. so we don't have to worry about
		 * them.
		 */
		NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, vio->vnd_file, p);
		sc->sc_flags &= ~VNF_READONLY;
		error = vn_open(&nd, FREAD|FWRITE, 0);
		if (error == EROFS) {
			sc->sc_flags |= VNF_READONLY;
			error = vn_open(&nd, FREAD, 0);
		}
		if (error) {
			disk_unlock(&sc->sc_dk);
			return (error);
		}

		if (nd.ni_vp->v_type == VBLK)
			sc->sc_size = vndbdevsize(nd.ni_vp, p);
		else {
			error = VOP_GETATTR(nd.ni_vp, &vattr, p->p_ucred, p);
			if (error) {
				VOP_UNLOCK(nd.ni_vp, p);
				vn_close(nd.ni_vp, VNDRW(sc), p->p_ucred, p);
				disk_unlock(&sc->sc_dk);
				return (error);
			}
			sc->sc_size = vattr.va_size / sc->sc_secsize;
		}
		VOP_UNLOCK(nd.ni_vp, p);
		sc->sc_vp = nd.ni_vp;
		if ((error = vndsetcred(sc, p->p_ucred)) != 0) {
			(void) vn_close(nd.ni_vp, VNDRW(sc), p->p_ucred, p);
			disk_unlock(&sc->sc_dk);
			return (error);
		}

		if (vio->vnd_keylen > 0) {
			char key[BLF_MAXUTILIZED];

			if (vio->vnd_keylen > sizeof(key))
				vio->vnd_keylen = sizeof(key);

			if ((error = copyin(vio->vnd_key, key,
			    vio->vnd_keylen)) != 0) {
				(void) vn_close(nd.ni_vp, VNDRW(sc),
				    p->p_ucred, p);
				disk_unlock(&sc->sc_dk);
				return (error);
			}

			sc->sc_keyctx = malloc(sizeof(*sc->sc_keyctx), M_DEVBUF,
			    M_WAITOK);
			blf_key(sc->sc_keyctx, key, vio->vnd_keylen);
			explicit_bzero(key, vio->vnd_keylen);
		} else
			sc->sc_keyctx = NULL;

		vio->vnd_size = sc->sc_size * sc->sc_secsize;
		sc->sc_flags |= VNF_INITED;

		DNPRINTF(VDB_INIT, "vndioctl: SET vp %p size %llx\n",
		    sc->sc_vp, (unsigned long long)sc->sc_size);

		/* Attach the disk. */
		sc->sc_dk.dk_name = sc->sc_dev.dv_xname;
		disk_attach(&sc->sc_dev, &sc->sc_dk);

		disk_unlock(&sc->sc_dk);

		break;

	case VNDIOCCLR:
		if ((sc->sc_flags & VNF_INITED) == 0)
			return (ENXIO);

		if ((error = disk_lock(&sc->sc_dk)) != 0)
			return (error);

		/*
		 * Don't unconfigure if any other partitions are open
		 * or if both the character and block flavors of this
		 * partition are open.
		 */
		part = DISKPART(dev);
		pmask = (1 << part);
		if ((sc->sc_dk.dk_openmask & ~pmask) ||
		    ((sc->sc_dk.dk_bopenmask & pmask) &&
		    (sc->sc_dk.dk_copenmask & pmask))) {
			disk_unlock(&sc->sc_dk);
			return (EBUSY);
		}

		vndclear(sc);
		DNPRINTF(VDB_INIT, "vndioctl: CLRed\n");

		/* Free crypto key */
		if (sc->sc_keyctx) {
			explicit_bzero(sc->sc_keyctx, sizeof(*sc->sc_keyctx));
			free(sc->sc_keyctx, M_DEVBUF, sizeof(*sc->sc_keyctx));
		}

		/* Detach the disk. */
		disk_detach(&sc->sc_dk);
		disk_unlock(&sc->sc_dk);
		break;

	case VNDIOCGET:
		vnu = (struct vnd_user *)addr;

		if (vnu->vnu_unit == -1)
			vnu->vnu_unit = unit;
		if (vnu->vnu_unit >= numvnd)
			return (ENXIO);
		if (vnu->vnu_unit < 0)
			return (EINVAL);

		sc = &vnd_softc[vnu->vnu_unit];

		if (sc->sc_flags & VNF_INITED) {
			error = VOP_GETATTR(sc->sc_vp, &vattr, p->p_ucred, p);
			if (error)
				return (error);

			strlcpy(vnu->vnu_file, sc->sc_file,
			    sizeof(vnu->vnu_file));
			vnu->vnu_dev = vattr.va_fsid;
			vnu->vnu_ino = vattr.va_fileid;
		} else {
			vnu->vnu_dev = 0;
			vnu->vnu_ino = 0;
		}

		break;

	case DIOCRLDINFO:
		if ((sc->sc_flags & VNF_HAVELABEL) == 0)
			return (ENOTTY);
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		vndgetdisklabel(dev, sc, lp, 0);
		*(sc->sc_dk.dk_label) = *lp;
		free(lp, M_TEMP, sizeof(*lp));
		return (0);

	case DIOCGPDINFO:
		if ((sc->sc_flags & VNF_HAVELABEL) == 0)
			return (ENOTTY);
		vndgetdisklabel(dev, sc, (struct disklabel *)addr, 1);
		return (0);

	case DIOCGDINFO:
		if ((sc->sc_flags & VNF_HAVELABEL) == 0)
			return (ENOTTY);
		*(struct disklabel *)addr = *(sc->sc_dk.dk_label);
		return (0);

	case DIOCGPART:
		if ((sc->sc_flags & VNF_HAVELABEL) == 0)
			return (ENOTTY);
		((struct partinfo *)addr)->disklab = sc->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &sc->sc_dk.dk_label->d_partitions[DISKPART(dev)];
		return (0);

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((sc->sc_flags & VNF_HAVELABEL) == 0)
			return (ENOTTY);
		if ((flag & FWRITE) == 0)
			return (EBADF);

		if ((error = disk_lock(&sc->sc_dk)) != 0)
			return (error);

		error = setdisklabel(sc->sc_dk.dk_label,
		    (struct disklabel *)addr, /* sc->sc_dk.dk_openmask */ 0);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    vndstrategy, sc->sc_dk.dk_label);
		}

		disk_unlock(&sc->sc_dk);
		return (error);

	default:
		return (ENOTTY);
	}

	return (0);
}

/*
 * Duplicate the current processes' credentials.  Since we are called only
 * as the result of a SET ioctl and only root can do that, any future access
 * to this "disk" is essentially as root.  Note that credentials may change
 * if some other uid can write directly to the mapped file (NFS).
 */
int
vndsetcred(struct vnd_softc *sc, struct ucred *cred)
{
	void *buf;
	size_t size;
	int error;

	sc->sc_cred = crdup(cred);
	buf = malloc(DEV_BSIZE, M_TEMP, M_WAITOK);
	size = MIN(DEV_BSIZE, sc->sc_size * sc->sc_secsize);

	/* XXX: Horrible kludge to establish credentials for NFS */
	error = vn_rdwr(UIO_READ, sc->sc_vp, buf, size, 0, UIO_SYSSPACE, 0,
	    sc->sc_cred, NULL, curproc);

	free(buf, M_TEMP, DEV_BSIZE);
	return (error);
}

void
vndclear(struct vnd_softc *sc)
{
	struct vnode *vp = sc->sc_vp;
	struct proc *p = curproc;		/* XXX */

	DNPRINTF(VDB_FOLLOW, "vndclear(%p): vp %p\n", sc, vp);

	if (vp == NULL)
		panic("vndioctl: null vp");
	(void) vn_close(vp, VNDRW(sc), sc->sc_cred, p);
	crfree(sc->sc_cred);
	sc->sc_flags = 0;
	sc->sc_vp = NULL;
	sc->sc_cred = NULL;
	sc->sc_size = 0;
	memset(sc->sc_file, 0, sizeof(sc->sc_file));
}

daddr_t
vndsize(dev_t dev)
{
	/* We don't support swapping to vnd anymore. */
	return (-1);
}

int
vnddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{
	/* Not implemented. */
	return (ENXIO);
}
@


1.164
log
@Avoid division by zero of vnd_secsize
Found by Ilja Van Sprundel
ok claudio kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.163 2017/01/21 05:42:04 guenther Exp $	*/
d222 2
a223 1
	lp->d_ncylinders = sc->sc_size / lp->d_secpercyl;
@


1.163
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.162 2016/12/14 18:59:12 jca Exp $	*/
d422 1
@


1.162
log
@Kill compat for old VNDIOCSET; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.161 2016/11/12 11:16:59 jca Exp $	*/
d308 1
a308 1
			struct proc *curp = curproc;
d312 1
a312 1
			    curp->p_p->ps_pid, curp->p_comm,
@


1.161
log
@Revert unrelated bits that snuck in previous.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.160 2016/11/12 10:59:37 jca Exp $	*/
a398 1
	struct vnd_user60 *vnu60;
a544 29
		break;

	/* XXX kill after 6.1 */
	case VNDIOCGET60:
		vnu60 = (struct vnd_user60 *)addr;

		if (vnu60->vnu60_unit == -1)
			vnu60->vnu60_unit = unit;
		if (vnu60->vnu60_unit >= numvnd)
			return (ENXIO);
		if (vnu60->vnu60_unit < 0)
			return (EINVAL);

		sc = &vnd_softc[vnu60->vnu60_unit];

		if (sc->sc_flags & VNF_INITED) {
			error = VOP_GETATTR(sc->sc_vp, &vattr, p->p_ucred, p);
			if (error)
				return (error);

			strlcpy(vnu60->vnu60_file, sc->sc_file,
			    sizeof(vnu60->vnu60_file));
			vnu60->vnu60_dev = vattr.va_fsid;
			vnu60->vnu60_ino = vattr.va_fileid;
		} else {
			vnu60->vnu60_dev = 0;
			vnu60->vnu60_ino = 0;
		}

@


1.160
log
@Bump VNDNLEN from 90 to 1024 bytes, to avoid "VNDIOCSET: File name too long"

Introduce a new ioctl for VNDIOCSET, the old ioctl will stay around for
a bit to cope with old vnconfig/mount_vnd.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.159 2016/10/08 05:52:06 guenther Exp $	*/
d308 1
a308 1
			struct process *curpr = curproc->p_p;
d312 1
a312 1
			    curpr->ps_pid, curpr->ps_comm,
@


1.159
log
@Various printf claim to report the PID, so actually report that and not the TID

ok kettenis@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.158 2016/03/19 12:04:15 natano Exp $	*/
d308 1
a308 1
			struct proc *curp = curproc;
d312 1
a312 1
			    curp->p_p->ps_pid, curp->p_comm,
d399 1
d546 29
@


1.158
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.157 2015/08/26 22:36:18 deraadt Exp $	*/
d308 1
a308 1
			struct proc *pr = curproc;
d312 2
a313 2
			    pr->p_pid, pr->p_comm, (long long)bp->b_blkno,
			    origbcount);
@


1.157
log
@Simple size for free().  These are a pleasure to convert when the
allocation is clearly spelled out as ptr = malloc(sizeof(*ptr), ...)
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.156 2015/08/25 07:01:24 deraadt Exp $	*/
d462 1
a462 1
				VOP_UNLOCK(nd.ni_vp, 0, p);
d469 1
a469 1
		VOP_UNLOCK(nd.ni_vp, 0, p);
@


1.156
log
@obvious sizes for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.155 2014/12/13 21:05:32 doug Exp $	*/
d539 1
a539 1
			free(sc->sc_keyctx, M_DEVBUF, 0);
@


1.155
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.154 2014/10/17 02:05:06 tedu Exp $	*/
d581 1
a581 1
		free(lp, M_TEMP, 0);
d653 1
a653 1
	free(buf, M_TEMP, 0);
@


1.154
log
@convert old b functions to mem functions
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.153 2014/07/12 18:48:51 tedu Exp $	*/
a148 1
	u_long size;
d153 2
a154 2
	size = num * sizeof(struct vnd_softc);
	mem = malloc(size, M_DEVBUF, M_NOWAIT | M_ZERO);
@


1.153
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.152 2013/11/12 14:11:07 krw Exp $	*/
d126 2
a127 2
		bzero(iv, sizeof(iv));
		bcopy(&off, iv, sizeof(off));
d217 1
a217 1
	bzero(lp, sizeof(struct disklabel));
d674 1
a674 1
	bzero(sc->sc_file, sizeof(sc->sc_file));
@


1.152
log
@Use %llu+DL_GETPSIZE() to show partition size. Replace %li+(long) with
%u for u_int32_t d_secsize.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.151 2013/11/01 17:36:19 krw Exp $	*/
d540 1
a540 1
			free(sc->sc_keyctx, M_DEVBUF);
d582 1
a582 1
		free(lp, M_TEMP);
d654 1
a654 1
	free(buf, M_TEMP);
@


1.151
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.150 2013/06/11 16:42:14 deraadt Exp $	*/
d386 3
a388 3
	DNPRINTF(VDB_INIT, "vndbdevsize: size %li secsize %li\n",
	    (long)pi.part->p_size,(long)pi.disklab->d_secsize);
	return (pi.part->p_size);
@


1.150
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.149 2011/08/26 04:36:42 matthew Exp $	*/
d313 2
a314 1
			    pr->p_pid, pr->p_comm, bp->b_blkno, origbcount);
@


1.149
log
@Add a dmesg warning about sloppy disk I/O to vnd(4) devices to help
identify bad distrib scripts/tools.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.148 2011/07/18 02:49:20 matthew Exp $	*/
d113 1
a113 1
void	vndencrypt(struct vnd_softc *, caddr_t, size_t, daddr64_t, int);
d118 1
a118 1
vndencrypt(struct vnd_softc *sc, caddr_t addr, size_t size, daddr64_t off,
d676 1
a676 1
daddr64_t
d684 1
a684 1
vnddump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
@


1.148
log
@Revert vnd(4) to its older less strict behavior.

Verified by deraadt@@ to fix distrib/sgi/iso.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.147 2011/07/12 22:51:21 deraadt Exp $	*/
d307 9
@


1.147
log
@Range check vnd_secsize, vnd_ntracks, and vnd_nsectors so that later on
they do not get integer truncated on 64-bit machines.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.147 2011/07/10 18:49:40 deraadt Exp $	*/
d259 1
d262 1
d275 1
d291 20
a310 1
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) == -1)
d312 4
d606 1
a606 1
		    (struct disklabel *)addr, sc->sc_dk.dk_openmask);
@


1.146
log
@Ack, my last change used size_t for file offsets, but size_t is only
32-bit on 32-bit architectures; we need off_t to support >4GB vnd(4)
images.

Discovered by, tested, and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.145 2011/07/08 05:27:46 matthew Exp $	*/
d53 1
d385 6
d411 1
a411 1
		sc->sc_flags &= ~VNF_READONLY; 
@


1.145
log
@Refactor vnd(4) to use vn_rdwr() instead of setting up the uio/iovec
structs and calling vn_lock+VOP_READ/WRITE+VOP_UNLOCK.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.144 2011/07/08 05:11:21 matthew Exp $	*/
d271 1
a271 1
	size_t off;
@


1.144
log
@Validate DISKUNIT(dev) in vndstrategy() like we do in other
xxstrategy() methods, and punt in validating it in vndread() and
vndwrite() (also like we do in other xx{read,write}() methods...).
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.143 2011/07/08 05:07:05 matthew Exp $	*/
d270 3
a272 5
	int s, part;
	struct iovec aiov;
	struct uio auio;
	struct proc *p = curproc;
	daddr64_t off;
d290 14
a303 33
	part = DISKPART(bp->b_dev);
	off = DL_SECTOBLK(sc->sc_dk.dk_label,
	    DL_GETPOFFSET(&sc->sc_dk.dk_label->d_partitions[part]));
	aiov.iov_base = bp->b_data;
	auio.uio_resid = aiov.iov_len = bp->b_bcount;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_offset = dbtob((off_t)(bp->b_blkno + off));
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_procp = p;

	vn_lock(sc->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (bp->b_flags & B_READ) {
		auio.uio_rw = UIO_READ;
		bp->b_error = VOP_READ(sc->sc_vp, &auio, 0,
		    sc->sc_cred);
		if (sc->sc_keyctx)
			vndencryptbuf(sc, bp, 0);
	} else {
		if (sc->sc_keyctx)
			vndencryptbuf(sc, bp, 1);
		auio.uio_rw = UIO_WRITE;
		/*
		 * Upper layer has already checked I/O for
		 * limits, so there is no need to do it again.
		 */
		bp->b_error = VOP_WRITE(sc->sc_vp, &auio,
		    IO_NOLIMIT, sc->sc_cred);
		/* Data in buffer cache needs to be in clear */
		if (sc->sc_keyctx)
			vndencryptbuf(sc, bp, 0);
	}
	VOP_UNLOCK(sc->sc_vp, 0, p);
d306 5
a310 1
	bp->b_resid = auio.uio_resid;
d599 2
a600 3
	struct uio auio;
	struct iovec aiov;
	char *tmpbuf;
a601 1
	struct proc *p = curproc;
d604 2
a605 1
	tmpbuf = malloc(DEV_BSIZE, M_TEMP, M_WAITOK);
d608 2
a609 11
	aiov.iov_base = tmpbuf;
	aiov.iov_len = MIN(DEV_BSIZE, sc->sc_size * sc->sc_secsize);
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_offset = 0;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_resid = aiov.iov_len;
	vn_lock(sc->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);
	error = VOP_READ(sc->sc_vp, &auio, 0, sc->sc_cred);
	VOP_UNLOCK(sc->sc_vp, 0, p);
d611 1
a611 1
	free(tmpbuf, M_TEMP);
@


1.143
log
@Add a vndencryptbuf() function, and refactor vndstrategy() slightly to
use it instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.142 2011/07/06 17:28:00 matthew Exp $	*/
d269 1
a269 1
	struct vnd_softc *sc = &vnd_softc[unit];
d278 6
d286 1
a286 3
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		goto done;
d328 6
a333 1
done:
a338 1

a342 12
	int unit = DISKUNIT(dev);
	struct vnd_softc *sc;

	DNPRINTF(VDB_FOLLOW, "vndread(%x, %p)\n", dev, uio);

	if (unit >= numvnd)
		return (ENXIO);
	sc = &vnd_softc[unit];

	if ((sc->sc_flags & VNF_INITED) == 0)
		return (ENXIO);

a349 12
	int unit = DISKUNIT(dev);
	struct vnd_softc *sc;

	DNPRINTF(VDB_FOLLOW, "vndwrite(%x, %p)\n", dev, uio);

	if (unit >= numvnd)
		return (ENXIO);
	sc = &vnd_softc[unit];

	if ((sc->sc_flags & VNF_INITED) == 0)
		return (ENXIO);

@


1.142
log
@vndsize() can just return -1; we don't support swapping to vnd
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.141 2011/07/06 17:26:33 matthew Exp $	*/
d113 1
d139 6
d305 1
a305 2
			vndencrypt(sc,	bp->b_data,
			   bp->b_bcount, bp->b_blkno, 0);
d308 1
a308 2
			vndencrypt(sc, bp->b_data,
			   bp->b_bcount, bp->b_blkno, 1);
d318 1
a318 2
			vndencrypt(sc, bp->b_data,
			   bp->b_bcount, bp->b_blkno, 0);
@


1.141
log
@Compact the vnd sc_flags bits.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.140 2011/07/06 05:12:46 matthew Exp $	*/
d676 2
a677 6
	int unit = DISKUNIT(dev);
	struct vnd_softc *sc = &vnd_softc[unit];

	if (unit >= numvnd || (sc->sc_flags & VNF_INITED) == 0)
		return (-1);
	return (sc->sc_size * (sc->sc_secsize / DEV_BSIZE));
a682 1

@


1.140
log
@Eliminate some sanity checks in vndstrategy() that are now handled by
bounds_check_with_label().
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.139 2011/07/06 05:09:01 matthew Exp $	*/
d97 3
a99 3
#define	VNF_INITED	0x0002
#define	VNF_HAVELABEL	0x0400
#define	VNF_READONLY	0x2000
@


1.139
log
@vndstrategy() should fail if VNF_HAVELABEL isn't set.  This simplifies
the logic slightly and makes vnd(4) more like any other disk driver.

To avoid races, this means vndopen() can only set VNF_HAVELABEL if
dk_openmask == 0.  Otherwise, it's possible for userspace to open
rvnd0c, call VNDIOCSET, open vnd0a, then while vndreaddisklabel() (via
vndstrategy) is waiting for VOP_READ() to finish, you could issue a
read or write on the still open rvnd0c and have VNF_HAVELABEL set but
the disklabel might be in a weird state.

Note that this makes VNF_HAVELABEL nicely analogous to sd(4)/cd(4)'s
SDEV_MEDIA_LOADED flag, which is handled similarly in
{sd,cd}{open,close,strategy}.

ok dlg@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.138 2011/07/06 04:49:36 matthew Exp $	*/
d263 1
a263 2
	off_t bn;
	int sz, s, part;
d274 1
a274 16
		goto done;
	}

	/* Ensure that the requested block is sector aligned. */
	if (bp->b_blkno % DL_BLKSPERSEC(sc->sc_dk.dk_label) != 0) {
		bp->b_error = EINVAL;
		bp->b_flags |= B_ERROR;
		goto done;
	}

	bn = bp->b_blkno;
	bp->b_resid = bp->b_bcount;

	if (bn < 0) {
		bp->b_error = EINVAL;
		bp->b_flags |= B_ERROR;
a279 7

	/*
	 * bounds_check_with_label() changes bp->b_resid, reset it
	 */
	bp->b_resid = bp->b_bcount;

	sz = howmany(bp->b_bcount, sc->sc_dk.dk_label->d_secsize);
@


1.138
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.137 2011/07/04 20:35:34 deraadt Exp $	*/
a54 1
#include <sys/pool.h>
a59 1
#include <sys/mount.h>
d187 2
a188 1
	    (sc->sc_flags & VNF_HAVELABEL) == 0) {
a193 1

d251 3
d272 1
a272 1
	if ((sc->sc_flags & VNF_INITED) == 0) {
d294 7
a300 10
	/* If we have a label, do a boundary check. */
	if (sc->sc_flags & VNF_HAVELABEL) {
		if (bounds_check_with_label(bp, sc->sc_dk.dk_label) == -1)
			goto done;

		/*
		 * bounds_check_with_label() changes bp->b_resid, reset it
		 */
		bp->b_resid = bp->b_bcount;
	}
d302 1
a302 4
	if (sc->sc_flags & VNF_HAVELABEL)
		sz = howmany(bp->b_bcount, sc->sc_dk.dk_label->d_secsize);
	else
		sz = howmany(bp->b_bcount, DEV_BSIZE);
@


1.137
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.136 2011/07/03 18:08:14 matthew Exp $	*/
d295 1
a295 1
		if (bounds_check_with_label(bp, sc->sc_dk.dk_label) <= 0)
@


1.136
log
@Cleanup vnd(4) a bit now that it only has one mode of operation and
uses standard disk device numbering.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.135 2011/07/03 17:42:42 matthew Exp $	*/
d67 1
a69 2

#include <miscfs/specfs/specdev.h>
@


1.135
log
@Fix vnd(4) support for read-only files.  We can't clear sc_flags
before closing the vnode, because VNDRW() checks for the VNF_READONLY
bit and the vnode layer doesn't like it when you close a read-only
vnode with FREAD|FWRITE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.134 2011/06/30 16:28:05 matthew Exp $	*/
a74 1
int dovndcluster = 1;
a83 9
#define	vndunit(x)	DISKUNIT(makedev(major(x), minor(x)))
#define	VNDLABELDEV(dev)	\
	makedev(major(dev), DISKMINOR(vndunit(dev), RAW_PART))

struct vndbuf {
	struct buf	vb_buf;
	struct buf	*vb_obp;
};

a99 1
#define	VNF_ALIVE	0x0001
d128 1
a128 1
		bcopy((u_char *)&off, iv, sizeof(off));
d171 1
a171 1
	int unit = vndunit(dev);
d232 1
a232 1
	return readdisklabel(VNDLABELDEV(dev), vndstrategy, lp, spoofonly);
d238 1
a238 1
	int unit = vndunit(dev);
d261 1
a261 1
	int unit = vndunit(bp->b_dev);
d360 1
a360 1
	int unit = vndunit(dev);
d379 1
a379 1
	int unit = vndunit(dev);
d416 1
a416 1
	int unit = vndunit(dev);
d634 1
a634 1
				error = writedisklabel(VNDLABELDEV(dev),
d705 1
a705 1
	int unit = vndunit(dev);
@


1.134
log
@Refactor some common open/close/detach disk driver code into
subr_disk.c.  For now just the MI disk drivers.

ok deraadt@@, krw@@; jsing@@ liked the approach too
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.133 2011/06/21 01:47:15 deraadt Exp $	*/
a701 1
	sc->sc_flags = 0;
d706 1
@


1.133
log
@looks like the disk_lock method actually does work
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.132 2011/06/20 22:14:17 tedu Exp $	*/
d184 1
a184 1
	int error = 0, part, pmask;
a206 1
	pmask = 1 << part;
d208 2
a209 21
	/* Check that the partition exists. */
	if (part != RAW_PART &&
	    ((sc->sc_flags & VNF_HAVELABEL) == 0 ||
	    part >= sc->sc_dk.dk_label->d_npartitions ||
	    sc->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		error = ENXIO;
		goto bad;
	}

	/* Prevent our unit from being unconfigured while open. */
	switch (mode) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask |= pmask;
		break;

	case S_IFBLK:
		sc->sc_dk.dk_bopenmask |= pmask;
		break;
	}
	sc->sc_dk.dk_openmask =
	    sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;
d263 1
a263 12
	/* ...that much closer to allowing unconfiguration... */
	switch (mode) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask &= ~(1 << part);
		break;

	case S_IFBLK:
		sc->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	sc->sc_dk.dk_openmask =
	    sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;
@


1.132
log
@explicit_bzero for the crypto key
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.131 2011/06/20 16:46:06 deraadt Exp $	*/
a63 1
#include <sys/rwlock.h>
a106 1
	struct rwlock	 sc_rwlock;
a169 1
		rw_init(&sc->sc_rwlock, "vndlock");
d173 1
d192 1
a192 1
	if ((error = rw_enter(&sc->sc_rwlock, RW_WRITE|RW_INTR)) != 0)
d232 1
a232 1
	rw_exit_write(&sc->sc_rwlock);
d279 1
a279 1
	rw_enter(&sc->sc_rwlock, RW_WRITE);
d296 1
a296 1
	rw_exit_write(&sc->sc_rwlock);
d484 1
a484 1
		if ((error = rw_enter(&sc->sc_rwlock, RW_WRITE|RW_INTR)) != 0)
d489 1
a489 1
			rw_exit_write(&sc->sc_rwlock);
d511 1
a511 1
			rw_exit_write(&sc->sc_rwlock);
d522 1
a522 1
				rw_exit_write(&sc->sc_rwlock);
d531 1
a531 1
			rw_exit_write(&sc->sc_rwlock);
d545 1
a545 1
				rw_exit_write(&sc->sc_rwlock);
d566 1
a566 1
		rw_exit_write(&sc->sc_rwlock);
d574 1
a574 1
		if ((error = rw_enter(&sc->sc_rwlock, RW_WRITE|RW_INTR)) != 0)
d587 1
a587 1
			rw_exit_write(&sc->sc_rwlock);
d602 1
a602 1
		rw_exit_write(&sc->sc_rwlock);
d669 1
a669 1
		if ((error = rw_enter(&sc->sc_rwlock, RW_WRITE|RW_INTR)) != 0)
d680 1
a680 1
		rw_exit_write(&sc->sc_rwlock);
@


1.131
log
@for now, move back to a private rw_lock rather than the disk_lock.
we have problems with instantiating new disks
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.128 2011/06/19 04:29:41 deraadt Exp $	*/
d554 1
a554 1
			bzero(key, vio->vnd_keylen);
d598 1
a598 1
			bzero(sc->sc_keyctx, sizeof(*sc->sc_keyctx));
@


1.130
log
@Use disk_lock_nointr() in the xxclose() routines so that they cannot
be interrupted.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.129 2011/06/19 04:35:03 deraadt Exp $	*/
d64 1
d108 1
d172 1
a175 1
		disk_construct(&sc->sc_dk);
d194 1
a194 1
	if ((error = disk_lock(&sc->sc_dk)) != 0)
d234 1
a234 1
	disk_unlock(&sc->sc_dk);
d281 1
a281 1
	disk_lock_nointr(&sc->sc_dk);
d298 1
a298 1
	disk_unlock(&sc->sc_dk);
d486 1
a486 1
		if ((error = disk_lock(&sc->sc_dk)) != 0)
d491 1
a491 1
			disk_unlock(&sc->sc_dk);
d513 1
a513 1
			disk_unlock(&sc->sc_dk);
d524 1
a524 1
				disk_unlock(&sc->sc_dk);
d533 1
a533 1
			disk_unlock(&sc->sc_dk);
d547 1
a547 1
				disk_unlock(&sc->sc_dk);
d568 1
a568 1
		disk_unlock(&sc->sc_dk);
d576 1
a576 1
		if ((error = disk_lock(&sc->sc_dk)) != 0)
d589 1
a589 1
			disk_unlock(&sc->sc_dk);
d604 1
a604 1
		disk_unlock(&sc->sc_dk);
d671 1
a671 1
		if ((error = disk_lock(&sc->sc_dk)) != 0)
d682 1
a682 1
		disk_unlock(&sc->sc_dk);
@


1.129
log
@Use disk_lock/disk_unlock directly and in the same way in these drivers,
rather than using various wrappings.  Convert vnd to using the sc_dk
rwlock instead of using one of its own.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.128 2011/06/19 04:29:41 deraadt Exp $	*/
d271 1
a271 1
	int error = 0, part;
d279 1
a279 2
	if ((error = disk_lock(&sc->sc_dk)) != 0)
		return (error);
@


1.128
log
@and in debug code, too
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.127 2011/06/19 04:28:46 deraadt Exp $	*/
a63 1
#include <sys/rwlock.h>
a106 1
	struct rwlock	 sc_rwlock;
a128 3
#define vndlock(sc) rw_enter(&sc->sc_rwlock, RW_WRITE|RW_INTR)
#define vndunlock(sc) rw_exit_write(&sc->sc_rwlock)

a169 1
		rw_init(&sc->sc_rwlock, "vndlock");
d173 1
d192 1
a192 1
	if ((error = vndlock(sc)) != 0)
d232 1
a232 1
	vndunlock(sc);
d279 1
a279 1
	if ((error = vndlock(sc)) != 0)
d297 1
a297 1
	vndunlock(sc);
d485 1
a485 1
		if ((error = vndlock(sc)) != 0)
d490 1
a490 1
			vndunlock(sc);
d512 1
a512 1
			vndunlock(sc);
d523 1
a523 1
				vndunlock(sc);
d532 1
a532 1
			vndunlock(sc);
d546 1
a546 1
				vndunlock(sc);
d567 1
a567 1
		vndunlock(sc);
d575 1
a575 1
		if ((error = vndlock(sc)) != 0)
d588 1
a588 1
			vndunlock(sc);
d603 1
a603 1
		vndunlock(sc);
d670 1
a670 1
		if ((error = vndlock(sc)) != 0)
d681 1
a681 1
		vndunlock(sc);
@


1.127
log
@stop trying to be clever with the softc name
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.126 2011/06/09 05:41:18 deraadt Exp $	*/
d737 1
a737 1
	DNPRINTF(VDB_FOLLOW, "vndclear(%p): vp %p\n", vnd, vp);
@


1.126
log
@shorted code with a lovely goto
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.125 2011/06/05 18:40:33 matthew Exp $	*/
d135 1
a135 1
vndencrypt(struct vnd_softc *vnd, caddr_t addr, size_t size, daddr64_t off,
d145 1
a145 1
		blf_ecb_encrypt(vnd->sc_keyctx, iv, sizeof(iv));
d147 1
a147 1
			blf_cbc_encrypt(vnd->sc_keyctx, iv, addr, bsize);
d149 1
a149 1
			blf_cbc_decrypt(vnd->sc_keyctx, iv, addr, bsize);
d310 1
a310 1
	struct vnd_softc *vnd = &vnd_softc[unit];
d320 1
a320 1
	if ((vnd->sc_flags & VNF_INITED) == 0) {
d327 1
a327 1
	if (bp->b_blkno % DL_BLKSPERSEC(vnd->sc_dk.dk_label) != 0) {
d343 2
a344 2
	if (vnd->sc_flags & VNF_HAVELABEL) {
		if (bounds_check_with_label(bp, vnd->sc_dk.dk_label) <= 0)
d353 2
a354 2
	if (vnd->sc_flags & VNF_HAVELABEL)
		sz = howmany(bp->b_bcount, vnd->sc_dk.dk_label->d_secsize);
d359 2
a360 2
	off = DL_SECTOBLK(vnd->sc_dk.dk_label,
	    DL_GETPOFFSET(&vnd->sc_dk.dk_label->d_partitions[part]));
d369 1
a369 1
	vn_lock(vnd->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
d372 4
a375 4
		bp->b_error = VOP_READ(vnd->sc_vp, &auio, 0,
		    vnd->sc_cred);
		if (vnd->sc_keyctx)
			vndencrypt(vnd,	bp->b_data,
d378 2
a379 2
		if (vnd->sc_keyctx)
			vndencrypt(vnd, bp->b_data,
d386 2
a387 2
		bp->b_error = VOP_WRITE(vnd->sc_vp, &auio,
		    IO_NOLIMIT, vnd->sc_cred);
d389 2
a390 2
		if (vnd->sc_keyctx)
			vndencrypt(vnd, bp->b_data,
d393 1
a393 1
	VOP_UNLOCK(vnd->sc_vp, 0, p);
d466 1
a466 1
	struct vnd_softc *vnd;
d482 1
a482 1
	vnd = &vnd_softc[unit];
d487 1
a487 1
		if (vnd->sc_flags & VNF_INITED)
d490 1
a490 1
		if ((error = vndlock(vnd)) != 0)
d493 3
a495 3
		if ((error = copyinstr(vio->vnd_file, vnd->sc_file,
		    sizeof(vnd->sc_file), NULL))) {
			vndunlock(vnd);
d500 3
a502 3
		vnd->sc_secsize = vio->vnd_secsize;
		vnd->sc_ntracks = vio->vnd_ntracks;
		vnd->sc_nsectors = vio->vnd_nsectors;
d510 1
a510 1
		vnd->sc_flags &= ~VNF_READONLY; 
d513 1
a513 1
			vnd->sc_flags |= VNF_READONLY;
d517 1
a517 1
			vndunlock(vnd);
d522 1
a522 1
			vnd->sc_size = vndbdevsize(nd.ni_vp, p);
d527 2
a528 2
				vn_close(nd.ni_vp, VNDRW(vnd), p->p_ucred, p);
				vndunlock(vnd);
d531 1
a531 1
			vnd->sc_size = vattr.va_size / vnd->sc_secsize;
d534 4
a537 4
		vnd->sc_vp = nd.ni_vp;
		if ((error = vndsetcred(vnd, p->p_ucred)) != 0) {
			(void) vn_close(nd.ni_vp, VNDRW(vnd), p->p_ucred, p);
			vndunlock(vnd);
d549 1
a549 1
				(void) vn_close(nd.ni_vp, VNDRW(vnd),
d551 1
a551 1
				vndunlock(vnd);
d555 1
a555 1
			vnd->sc_keyctx = malloc(sizeof(*vnd->sc_keyctx), M_DEVBUF,
d557 1
a557 1
			blf_key(vnd->sc_keyctx, key, vio->vnd_keylen);
d560 1
a560 1
			vnd->sc_keyctx = NULL;
d562 2
a563 2
		vio->vnd_size = vnd->sc_size * vnd->sc_secsize;
		vnd->sc_flags |= VNF_INITED;
d566 1
a566 1
		    vnd->sc_vp, (unsigned long long)vnd->sc_size);
d569 2
a570 2
		vnd->sc_dk.dk_name = vnd->sc_dev.dv_xname;
		disk_attach(&vnd->sc_dev, &vnd->sc_dk);
d572 1
a572 1
		vndunlock(vnd);
d577 1
a577 1
		if ((vnd->sc_flags & VNF_INITED) == 0)
d580 1
a580 1
		if ((error = vndlock(vnd)) != 0)
d590 4
a593 4
		if ((vnd->sc_dk.dk_openmask & ~pmask) ||
		    ((vnd->sc_dk.dk_bopenmask & pmask) &&
		    (vnd->sc_dk.dk_copenmask & pmask))) {
			vndunlock(vnd);
d597 1
a597 1
		vndclear(vnd);
d601 3
a603 3
		if (vnd->sc_keyctx) {
			bzero(vnd->sc_keyctx, sizeof(*vnd->sc_keyctx));
			free(vnd->sc_keyctx, M_DEVBUF);
d607 2
a608 2
		disk_detach(&vnd->sc_dk);
		vndunlock(vnd);
d621 1
a621 1
		vnd = &vnd_softc[vnu->vnu_unit];
d623 2
a624 2
		if (vnd->sc_flags & VNF_INITED) {
			error = VOP_GETATTR(vnd->sc_vp, &vattr, p->p_ucred, p);
d628 1
a628 1
			strlcpy(vnu->vnu_file, vnd->sc_file,
d640 1
a640 1
		if ((vnd->sc_flags & VNF_HAVELABEL) == 0)
d643 2
a644 2
		vndgetdisklabel(dev, vnd, lp, 0);
		*(vnd->sc_dk.dk_label) = *lp;
d649 1
a649 1
		if ((vnd->sc_flags & VNF_HAVELABEL) == 0)
d651 1
a651 1
		vndgetdisklabel(dev, vnd, (struct disklabel *)addr, 1);
d655 1
a655 1
		if ((vnd->sc_flags & VNF_HAVELABEL) == 0)
d657 1
a657 1
		*(struct disklabel *)addr = *(vnd->sc_dk.dk_label);
d661 1
a661 1
		if ((vnd->sc_flags & VNF_HAVELABEL) == 0)
d663 1
a663 1
		((struct partinfo *)addr)->disklab = vnd->sc_dk.dk_label;
d665 1
a665 1
		    &vnd->sc_dk.dk_label->d_partitions[DISKPART(dev)];
d670 1
a670 1
		if ((vnd->sc_flags & VNF_HAVELABEL) == 0)
d675 1
a675 1
		if ((error = vndlock(vnd)) != 0)
d678 2
a679 2
		error = setdisklabel(vnd->sc_dk.dk_label,
		    (struct disklabel *)addr, vnd->sc_dk.dk_openmask);
d683 1
a683 1
				    vndstrategy, vnd->sc_dk.dk_label);
d686 1
a686 1
		vndunlock(vnd);
d703 1
a703 1
vndsetcred(struct vnd_softc *vnd, struct ucred *cred)
d711 1
a711 1
	vnd->sc_cred = crdup(cred);
d716 1
a716 1
	aiov.iov_len = MIN(DEV_BSIZE, vnd->sc_size * vnd->sc_secsize);
d723 3
a725 3
	vn_lock(vnd->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);
	error = VOP_READ(vnd->sc_vp, &auio, 0, vnd->sc_cred);
	VOP_UNLOCK(vnd->sc_vp, 0, p);
d732 1
a732 1
vndclear(struct vnd_softc *vnd)
d734 1
a734 1
	struct vnode *vp = vnd->sc_vp;
d739 1
a739 1
	vnd->sc_flags = 0;
d742 6
a747 6
	(void) vn_close(vp, VNDRW(vnd), vnd->sc_cred, p);
	crfree(vnd->sc_cred);
	vnd->sc_vp = NULL;
	vnd->sc_cred = NULL;
	vnd->sc_size = 0;
	bzero(vnd->sc_file, sizeof(vnd->sc_file));
d754 1
a754 1
	struct vnd_softc *vnd = &vnd_softc[unit];
d756 1
a756 1
	if (unit >= numvnd || (vnd->sc_flags & VNF_INITED) == 0)
d758 1
a758 1
	return (vnd->sc_size * (vnd->sc_secsize / DEV_BSIZE));
@


1.125
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.124 2011/06/03 21:14:11 matthew Exp $	*/
d323 1
a323 4
		s = splbio();
		biodone(bp);
		splx(s);
		return;
d330 1
a330 4
		s = splbio();
		biodone(bp);
		splx(s);
		return;
d339 1
a339 4
		s = splbio();
		biodone(bp);
		splx(s);
		return;
d344 2
a345 6
		if (bounds_check_with_label(bp, vnd->sc_dk.dk_label) <= 0) {
			s = splbio();
			biodone(bp);
			splx(s);
			return;
		}
d397 1
@


1.124
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.123 2011/06/02 19:18:21 deraadt Exp $	*/
a113 2
#define	VNF_LABELLING	0x0100
#define	VNF_WLABEL	0x0200
a688 1
		vnd->sc_flags |= VNF_LABELLING;
a697 1
		vnd->sc_flags &= ~VNF_LABELLING;
a699 9

	case DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			return (EBADF);
		if (*(int *)addr)
			vnd->sc_flags |= VNF_WLABEL;
		else
			vnd->sc_flags &= ~VNF_WLABEL;
		return (0);
@


1.123
log
@No need to set error to 0, when it is still 0 from the start of the function.
ok thib matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.122 2011/06/02 19:17:24 deraadt Exp $	*/
d355 1
a355 1
		if (bounds_check_with_label(bp, vnd->sc_dk.dk_label, 1) <= 0) {
@


1.122
log
@The vndbufpl is no longer used.
Spotted by matthew, verified by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.121 2011/06/02 19:16:28 deraadt Exp $	*/
a237 1
	error = 0;
@


1.121
log
@Initialize the dv_xname at attach time, so that we don't have to do
this work later.  Since the disk always has the same name (the different
between svnd and vnd went away), we don't need to do this late anymore.
Spotted with matthew.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.120 2011/06/02 19:12:02 deraadt Exp $	*/
a94 8
/*
 * struct vndbuf allocator
 */
struct pool     vndbufpl;

#define	getvndbuf()	pool_get(&vndbufpl, PR_WAITOK)
#define	putvndbuf(vbp)	pool_put(&vndbufpl, vbp);

a183 4

	pool_init(&vndbufpl, sizeof(struct vndbuf), 0, 0, 0, "vndbufpl", NULL);
	pool_setlowat(&vndbufpl, 16);
	pool_sethiwat(&vndbufpl, 1024);
@


1.120
log
@In vndclear(), clear all the flag bits.  Leaving around a VNF_WLABEL bit
is stupid (verified to be the case).  Other flag bits might have lived
longer than they should as well, with unknown consequences.
Spotted with matthew, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.119 2011/06/02 19:10:19 deraadt Exp $	*/
a105 1
	char		 sc_dk_name[16];
d183 7
a189 3
		rw_init(&vnd_softc[i].sc_rwlock, "vndlock");
		vnd_softc[i].sc_dev.dv_unit = i;
		device_ref(&vnd_softc[i].sc_dev);
a525 18
		/* Set device name. */
		bzero(vnd->sc_dev.dv_xname, sizeof(vnd->sc_dev.dv_xname));
		if (snprintf(vnd->sc_dev.dv_xname, sizeof(vnd->sc_dev.dv_xname),
		    "vnd%d", unit) >= sizeof(vnd->sc_dev.dv_xname)) {
			printf("VNDIOCSET: device name too long\n");
			vndunlock(vnd);
			return(ENXIO);
		}

		/* Set disk name depending on how we were created. */
		bzero(vnd->sc_dk_name, sizeof(vnd->sc_dk_name));
		if (snprintf(vnd->sc_dk_name, sizeof(vnd->sc_dk_name),
		    "vnd%d", unit) >= sizeof(vnd->sc_dk_name)) {
			printf("VNDIOCSET: disk name too long\n");
			vndunlock(vnd);
			return(ENXIO);
		}

d596 1
a596 1
		vnd->sc_dk.dk_name = vnd->sc_dk_name;
@


1.119
log
@Initialize the dv_unit, because disk_attach will want it later.  Before
we were probably only ever reading labels off vnd0.  Oops.
Spotted by matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.118 2011/06/02 19:09:29 deraadt Exp $	*/
d792 1
a792 1
	vnd->sc_flags &= ~VNF_INITED;
@


1.118
log
@Do not bzero the softc when doing VNDIOCCLR, because that trashes the
rw_lock and the device_ref
Discussed with thib and matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.117 2011/06/02 16:14:40 deraadt Exp $	*/
d185 1
@


1.117
log
@device_ref() by hand, since this is a pseudo-device and was not attached
through config_attach()
ok matthew jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.116 2011/05/31 17:35:35 matthew Exp $	*/
d494 1
a494 1
	int error, part, pmask, s;
a648 3

		/* This must be atomic. */
		s = splhigh();
a649 2
		bzero(vnd, sizeof(struct vnd_softc));
		splx(s);
d799 1
@


1.116
log
@Change a few of the more common disk drivers (sd, cd, wd, rd, and vnd)
to return EBUSY if the user tries to modify an open partition's offset
or size.  Only sadness can result if a user tries this, and rejecting
it prevents a race between sdstart() and sdstrategy().

Curiously, there was already code in the kernel and in disklabel(8) to
detect/handle this, but it was effectively disabled because the disk
drivers always used something like "/* sc->sc_dk.dk_openmask */ 0",
and this commented out code has existed since even r1.1 in NetBSD.

I had no problems building a release and messing around with
disklabel(8) for a bit with this diff.  Canarying the more common MI
disk drivers until we gain confidence that there aren't any
regressions, then we can switch the remaining drivers.

"I am surprised you got me convinced that this stuff is safe" deraadt@@
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.115 2011/05/30 21:15:03 oga Exp $	*/
d185 1
@


1.115
log
@Remove vndshutdown. It is unused.


``sure'' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.114 2011/04/25 19:29:11 deraadt Exp $	*/
d725 1
a725 1
		    (struct disklabel *)addr, /*vnd->sc_dk.dk_openmask : */0);
@


1.114
log
@Remove backwards compatibility for svnd.  All new operations must use the
vnd devices nodes, which impliment svnd functionality -- that being the only
thing which vnd now supports.  Confused?  Don't worry, it is documented.
ok krw thib
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.113 2011/04/23 22:00:09 miod Exp $	*/
a137 1
void	vndshutdown(void);
a784 10
}

void
vndshutdown(void)
{
	struct vnd_softc *vnd;

	for (vnd = &vnd_softc[0]; vnd < &vnd_softc[numvnd]; vnd++)
		if (vnd->sc_flags & VNF_INITED)
			vndclear(vnd);
@


1.113
log
@Remove now unused vndiodone(). ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.112 2011/04/23 17:01:04 jsing Exp $	*/
d86 1
a86 5
/*
 * vndunit is a bit weird.  have to reconstitute the dev_t for
 * DISKUNIT(), but with the minor masked off.
 */
#define	vndunit(x)	DISKUNIT(makedev(major(x), minor(x) & 0x7ff))
@


1.112
log
@The previous code only prevented the vnd from being opened for write in
both simple and non-simple mode. Restore this behaviour by removing the
openmask check.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.111 2011/04/23 14:57:01 deraadt Exp $	*/
a141 1
void	vndiodone(struct buf *);
a429 38

void
vndiodone(struct buf *bp)
{
	struct vndbuf *vbp = (struct vndbuf *) bp;
	struct buf *pbp = vbp->vb_obp;
	struct vnd_softc *vnd = &vnd_softc[vndunit(pbp->b_dev)];

	splassert(IPL_BIO);

	DNPRINTF(VDB_IO,
	    "vndiodone(%d): vbp %p vp %p blkno %lld addr %p cnt %lx\n",
	    vnd-vnd_softc, vbp, vbp->vb_buf.b_vp, vbp->vb_buf.b_blkno,
	    vbp->vb_buf.b_data, vbp->vb_buf.b_bcount);

	if (vbp->vb_buf.b_error) {
		DNPRINTF(VDB_IO, "vndiodone: vbp %p error %d\n", vbp,
		    vbp->vb_buf.b_error);

		pbp->b_flags |= (B_ERROR|B_INVAL);
		pbp->b_error = vbp->vb_buf.b_error;
		pbp->b_iodone = NULL;
		biodone(pbp);
		goto out;
	}

	pbp->b_resid -= vbp->vb_buf.b_bcount;

	if (pbp->b_resid == 0) {
		DNPRINTF(VDB_IO, "vndiodone: pbp %p iodone\n", pbp);
		biodone(pbp);
	}

out:
	putvndbuf(vbp);
	disk_unbusy(&vnd->sc_dk, (pbp->b_bcount - pbp->b_resid),
	    (pbp->b_flags & B_READ));
}
@


1.111
log
@backout the miod change since it is wrong
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.109 2011/04/18 16:50:22 thib Exp $	*/
a227 7

	/* Allow access to the raw device even if we are open. */
	if (sc->sc_dk.dk_openmask && !(part == RAW_PART) &&
	    !(mode == S_IFCHR)) {
		error = EBUSY;
		goto bad;
	}
@


1.110
log
@Fix regression in vndopen() behaviour introduced in previous commit.
@
text
@d229 3
a231 5
	/*
	 * If any partition is open, all succeeding openings must be of the
	 * same type or read-only.
	 */
	if (sc->sc_dk.dk_openmask && (flags & FWRITE)) {
@


1.109
log
@remove the old style by-pass-the-buffer-cache vnd code.
this will treat vndX the same as svndX.

ok and gcc2 fixes from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.108 2011/04/02 15:24:03 thib Exp $	*/
d229 5
a233 3
	/* Allow access to the raw device even if we are open. */
	if (sc->sc_dk.dk_openmask && !(part == RAW_PART) &&
	    !(mode == S_IFCHR)) {
@


1.108
log
@Remove bufqs from vnds, as the disk that houses the image
backing the vnd also has a bufq. So the buf is just passed
between the vnd bufq and the disk bufq (almost immediately).

Also see previous revision for more insight.

OK deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.106 2011/01/06 17:32:42 thib Exp $	*/
a35 4
 *
 * from: Utah $Hdr: vn.c 1.13 94/04/02$
 *
 *	@@(#)vn.c	8.6 (Berkeley) 4/1/94
d39 1
a39 10
 * Vnode disk driver.
 *
 * Block/character interface to a vnode.  Allows one to treat a file
 * as a disk (e.g. build a filesystem in it, mount it, etc.).
 *
 * NOTE 1: This uses either the VOP_BMAP/VOP_STRATEGY interface to the
 * vnode or simple VOP_READ/VOP_WRITE.  The former is suitable for swapping
 * as it doesn't distort the local buffer cache.  The latter is good for
 * building disk images as it keeps the cache consistent after the block
 * device is closed.
a40 1
 * NOTE 2: There is a security issue involved with this driver.
a90 3
#define	vndsimple(x)	(minor(x) & 0x800)

/* same as MAKEDISKDEV, preserving the vndsimple() property */
d92 1
a92 2
	makedev(major(dev), DISKMINOR(vndunit(dev), RAW_PART) | \
	    (vndsimple(dev) ? 0x800 : 0))
a129 1
#define	VNF_SIMPLE	0x1000
a140 1
void	vndstart(struct vnd_softc *, struct buf *);
a214 6
	if (!vndsimple(dev) && sc->sc_vp != NULL &&
	    (sc->sc_vp->v_type != VREG || sc->sc_keyctx != NULL)) {
		error = EINVAL;
		goto bad;
	}

d229 6
a234 14
	/*
	 * If any partition is open, all succeeding openings must be of the
	 * same type or read-only.
	 */
	if (sc->sc_dk.dk_openmask) {
		if (((sc->sc_flags & VNF_SIMPLE) != 0) !=
		    (vndsimple(dev) != 0) && (flags & FWRITE)) {
			error = EBUSY;
			goto bad;
		}
	} else if (vndsimple(dev))
		sc->sc_flags |= VNF_SIMPLE;
	else
		sc->sc_flags &= ~VNF_SIMPLE;
a328 13
/*
 * Two methods are used, the traditional buffercache bypassing and the
 * newer, cache-coherent on unmount, one.
 *
 * Former method:
 * Break the request into bsize pieces and submit using VOP_BMAP/VOP_STRATEGY.
 * Note that this driver can only be used for swapping over NFS on the hp
 * since nfs_strategy on the vax cannot handle u-areas and page tables.
 *
 * Latter method:
 * Repack the buffer into an uio structure and use VOP_READ/VOP_WRITE to
 * access the underlying file.
 */
a333 2
	struct vndbuf *nbp;
	int bsize;
d335 1
a335 3
	caddr_t addr;
	size_t resid;
	int sz, flags, error, s;
d339 1
d394 24
a417 116
	/* No bypassing of buffer cache?  */
	if (vndsimple(bp->b_dev)) {
		int part = DISKPART(bp->b_dev);
		daddr64_t off = DL_SECTOBLK(vnd->sc_dk.dk_label,
		    DL_GETPOFFSET(&vnd->sc_dk.dk_label->d_partitions[part]));
		aiov.iov_base = bp->b_data;
		auio.uio_resid = aiov.iov_len = bp->b_bcount;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_offset = dbtob((off_t)(bp->b_blkno + off));
		auio.uio_segflg = UIO_SYSSPACE;
		auio.uio_procp = p;

		vn_lock(vnd->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
		if (bp->b_flags & B_READ) {
			auio.uio_rw = UIO_READ;
			bp->b_error = VOP_READ(vnd->sc_vp, &auio, 0,
			    vnd->sc_cred);
			if (vnd->sc_keyctx)
				vndencrypt(vnd,	bp->b_data,
				   bp->b_bcount, bp->b_blkno, 0);
		} else {
			if (vnd->sc_keyctx)
				vndencrypt(vnd, bp->b_data,
				   bp->b_bcount, bp->b_blkno, 1);
			auio.uio_rw = UIO_WRITE;
			/*
			 * Upper layer has already checked I/O for
			 * limits, so there is no need to do it again.
			 */
			bp->b_error = VOP_WRITE(vnd->sc_vp, &auio,
			    IO_NOLIMIT, vnd->sc_cred);
			/* Data in buffer cache needs to be in clear */
			if (vnd->sc_keyctx)
				vndencrypt(vnd, bp->b_data,
				   bp->b_bcount, bp->b_blkno, 0);
		}
		VOP_UNLOCK(vnd->sc_vp, 0, p);
		if (bp->b_error)
			bp->b_flags |= B_ERROR;
		bp->b_resid = auio.uio_resid;
		s = splbio();
		biodone(bp);
		splx(s);

		return;
	}

	if (vnd->sc_vp->v_type != VREG || vnd->sc_keyctx != NULL) {
		bp->b_error = EINVAL;
		bp->b_flags |= B_ERROR;
		s = splbio();
		biodone(bp);
		splx(s);
		return;
	}

	/* The old-style buffercache bypassing method.  */
	bn += DL_SECTOBLK(vnd->sc_dk.dk_label,
	    DL_GETPOFFSET(&vnd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)]));
	bn = dbtob(bn);
	bsize = vnd->sc_vp->v_mount->mnt_stat.f_iosize;
	addr = bp->b_data;
	flags = bp->b_flags | B_CALL;
	for (resid = bp->b_resid; resid; resid -= sz) {
		struct vnode *vp;
		daddr64_t nbn;
		int off, nra;

		nra = 0;
		vn_lock(vnd->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);
		error = VOP_BMAP(vnd->sc_vp, bn / bsize, &vp, &nbn, &nra);
		VOP_UNLOCK(vnd->sc_vp, 0, p);
		if (error == 0 && (long)nbn == -1)
			error = EIO;
#ifdef VNDDEBUG
		if (!dovndcluster)
			nra = 0;
#endif

		if ((off = bn % bsize) != 0)
			sz = bsize - off;
		else
			sz = (1 + nra) * bsize;
		if (resid < sz)
			sz = resid;

		DNPRINTF(VDB_IO, "vndstrategy: vp %p/%p bn %x/%lld sz %x\n",
		    vnd->sc_vp, vp, bn, nbn, sz);

		s = splbio();
		nbp = getvndbuf();
		splx(s);
		nbp->vb_buf.b_flags = flags;
		nbp->vb_buf.b_bcount = sz;
		nbp->vb_buf.b_bufsize = bp->b_bufsize;
		nbp->vb_buf.b_error = 0;
		if (vp->v_type == VBLK || vp->v_type == VCHR)
			nbp->vb_buf.b_dev = vp->v_rdev;
		else
			nbp->vb_buf.b_dev = NODEV;
		nbp->vb_buf.b_data = addr;
		nbp->vb_buf.b_blkno = nbn + btodb(off);
		nbp->vb_buf.b_proc = bp->b_proc;
		nbp->vb_buf.b_iodone = vndiodone;
		nbp->vb_buf.b_vp = vp;
		nbp->vb_buf.b_dirtyoff = bp->b_dirtyoff;
		nbp->vb_buf.b_dirtyend = bp->b_dirtyend;
		nbp->vb_buf.b_validoff = bp->b_validoff;
		nbp->vb_buf.b_validend = bp->b_validend;
		LIST_INIT(&nbp->vb_buf.b_dep);
		nbp->vb_buf.b_bq = NULL;

		/* save a reference to the old buffer */
		nbp->vb_obp = bp;

d419 2
a420 9
		 * If there was an error or a hole in the file...punt.
		 * Note that we deal with this after the nbp allocation.
		 * This ensures that we properly clean up any operations
		 * that we have already fired off.
		 *
		 * XXX we could deal with holes here but it would be
		 * a hassle (in the write case).
		 * We must still however charge for the write even if there
		 * was an error.
d422 6
a427 16
		if (error) {
			nbp->vb_buf.b_error = error;
			nbp->vb_buf.b_flags |= B_ERROR;
			bp->b_resid -= (resid - sz);
			s = splbio();
			/* charge for the write */
			if ((nbp->vb_buf.b_flags & B_READ) == 0)
				nbp->vb_buf.b_vp->v_numoutput++;
			biodone(&nbp->vb_buf);
			splx(s);
			return;
		}

		vndstart(vnd, &nbp->vb_buf);
		bn += sz;
		addr += sz;
d429 7
a437 15
void
vndstart(struct vnd_softc *vnd, struct buf *bp)
{
	DNPRINTF(VDB_IO,
	    "vndstart(%d): bp %p vp %p blkno %lld addr %p cnt %lx\n",
	    vnd-vnd_softc, bp, bp->b_vp, bp->b_blkno, bp->b_data,
	    bp->b_bcount);

	/* Instrumentation. */
	disk_busy(&vnd->sc_dk);

	if ((bp->b_flags & B_READ) == 0)
		bp->b_vp->v_numoutput++;
	VOP_STRATEGY(bp);
}
a561 2
		if (!(vnd->sc_flags & VNF_SIMPLE) && vio->vnd_keylen)
			return (EINVAL);
d584 1
a584 2
		    "%svnd%d", ((vnd->sc_flags & VNF_SIMPLE) ? "s" : ""),
		    unit) >= sizeof(vnd->sc_dk_name)) {
a609 7
		}

		if (nd.ni_vp->v_type != VREG && !vndsimple(dev)) {
			VOP_UNLOCK(nd.ni_vp, 0, p);
			vn_close(nd.ni_vp, VNDRW(vnd), p->p_ucred, p);
			vndunlock(vnd);
			return (EINVAL);
@


1.107
log
@A vnd buf doesn't only go through the vnd bufq but also the bufq
for the device on which the vnd image resides on, this has the
effect that a bufq_done call is done in the context of the
underlaying bufq, setting b_bq to NULL, meaning there is never
a bufq_done call done for the vnd bufq so the outstanding count
never decreses.

Add one in vndiodone. This fixes the suspsend issues krw@@ was
running into.

ok tedu@@, krw@@
nod from miod@@ on the commit.
@
text
@a129 2
	struct bufq	 sc_bufq;

d160 1
a160 1
void	vndstart(struct vnd_softc *);
d446 24
a469 49
		/* Loop until all queued requests are handled.  */
		for (;;) {
			int part = DISKPART(bp->b_dev);
			daddr64_t off = DL_SECTOBLK(vnd->sc_dk.dk_label,
			    DL_GETPOFFSET(&vnd->sc_dk.dk_label->d_partitions[part]));
			aiov.iov_base = bp->b_data;
			auio.uio_resid = aiov.iov_len = bp->b_bcount;
			auio.uio_iov = &aiov;
			auio.uio_iovcnt = 1;
			auio.uio_offset = dbtob((off_t)(bp->b_blkno + off));
			auio.uio_segflg = UIO_SYSSPACE;
			auio.uio_procp = p;

			vn_lock(vnd->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
			if (bp->b_flags & B_READ) {
				auio.uio_rw = UIO_READ;
				bp->b_error = VOP_READ(vnd->sc_vp, &auio, 0,
				    vnd->sc_cred);
				if (vnd->sc_keyctx)
					vndencrypt(vnd,	bp->b_data,
					   bp->b_bcount, bp->b_blkno, 0);
			} else {
				if (vnd->sc_keyctx)
					vndencrypt(vnd, bp->b_data,
					   bp->b_bcount, bp->b_blkno, 1);
				auio.uio_rw = UIO_WRITE;
				/*
				 * Upper layer has already checked I/O for
				 * limits, so there is no need to do it again.
				 */
				bp->b_error = VOP_WRITE(vnd->sc_vp, &auio,
				    IO_NOLIMIT, vnd->sc_cred);
				/* Data in buffer cache needs to be in clear */
				if (vnd->sc_keyctx)
					vndencrypt(vnd, bp->b_data,
					   bp->b_bcount, bp->b_blkno, 0);
			}
			VOP_UNLOCK(vnd->sc_vp, 0, p);
			if (bp->b_error)
				bp->b_flags |= B_ERROR;
			bp->b_resid = auio.uio_resid;
			s = splbio();
			biodone(bp);
			splx(s);

			/* If nothing more is queued, we are done. */
			if (!bufq_peek(&vnd->sc_bufq))
				return;

d471 2
a472 2
			 * Dequeue now since lower level strategy
			 * routine might queue using same links.
d474 6
a479 4
			s = splbio();
			bp = bufq_dequeue(&vnd->sc_bufq);
			KASSERT(bp != NULL);
			splx(s);
d481 9
d584 1
a584 4
		bufq_queue(&vnd->sc_bufq, &nbp->vb_buf);
		s = splbio();
		vndstart(vnd);
		splx(s);
a589 6
/*
 * Feed requests sequentially.
 * We do it this way to keep from flooding NFS servers if we are connected
 * to an NFS file.  This places the burden on the client rather than the
 * server.
 */
d591 1
a591 1
vndstart(struct vnd_softc *vnd)
a592 10
	struct buf *bp;

	/*
	 * Dequeue now since lower level strategy routine might
	 * queue using same links
	 */
	bp = bufq_dequeue(&vnd->sc_bufq);
	if (bp == NULL)
		return;

a638 6
	/*
	 * A bufq_done call is actually done on this buf in the context
	 * of the bufq for the device on which the vnd image resides on.
	 * Meaning we have to do one ourselves too.
	 */
	bufq_done(&vnd->sc_bufq, bp);
a838 1
		bufq_init(&vnd->sc_bufq, BUFQ_DEFAULT);
a874 1
		bufq_destroy(&vnd->sc_bufq);
@


1.106
log
@init and destory the bufq in the ioctl handler, as
the softc is zero'ed when the vnd is unconfigured;
otherwise we blow up when configuring a vnd the second
time since the bufq structure is kaputt.

found by and OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.105 2011/01/05 15:35:43 thib Exp $	*/
d674 6
@


1.105
log
@cut vnd over to using bufq's again.

OK dlg@@, beck@@, krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.92 2009/06/04 05:57:27 krw Exp $	*/
a212 1
		bufq_init(&vnd_softc[i].sc_bufq, BUFQ_DEFAULT);
d874 1
d911 1
@


1.104
log
@When configuring a vnd(4) disk, populate the disk name based on the mode
in which it was configured. If this is a "safe" vnd disk the name should
be "svndX" whereas a standard vnd disk should be named "vndX".

ok deraadt@@ todd@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.102 2010/09/08 14:47:12 jsing Exp $	*/
d130 2
a139 1
	struct buf	 sc_tab;		/* transfer queue */
d213 1
d494 2
a495 2
			/* If nothing more is queued, we are done.  */
			if (!vnd->sc_tab.b_active)
d503 2
a504 3
			bp = vnd->sc_tab.b_actf;
			vnd->sc_tab.b_actf = bp->b_actf;
			vnd->sc_tab.b_active--;
d600 2
a601 4
		/*
		 * Just sort by block number
		 */
		nbp->vb_buf.b_cylinder = nbp->vb_buf.b_blkno;
a602 2
		disksort(&vnd->sc_tab, &nbp->vb_buf);
		vnd->sc_tab.b_active++;
d625 3
a627 2
	bp = vnd->sc_tab.b_actf;
	vnd->sc_tab.b_actf = bp->b_actf;
d676 2
a677 7

	if (vnd->sc_tab.b_active) {
		disk_unbusy(&vnd->sc_dk, (pbp->b_bcount - pbp->b_resid),
		    (pbp->b_flags & B_READ));
		if (!vnd->sc_tab.b_actf)
			vnd->sc_tab.b_active--;
	}
@


1.103
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d128 1
d784 1
d793 10
d880 1
a880 1
		vnd->sc_dk.dk_name = vnd->sc_dev.dv_xname;
@


1.102
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.100 2010/07/22 14:34:06 thib Exp $	*/
d702 1
a702 1
	return (physio(vndstrategy, NULL, dev, B_READ, minphys, uio));
d721 1
a721 1
	return (physio(vndstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.101
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d869 1
a869 1
		disk_attach(&vnd->sc_dk);
@


1.100
log
@Instead of trying to biowait on a buf that has errored, do the
right thing, throw it away by marking it as B_INVAL and setting
the B_ERROR flag and b_error to the errno that was returned.

B_RAW doesn't matter there.

Issue report my mlarkin@@, this diff tested and confirmed to
fix the issue by mlarkin also, thanks!

OK krw@@, beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.99 2010/07/01 17:48:33 thib Exp $	*/
a155 2
struct dkdriver vnddkdriver = { vndstrategy };

a867 1
		vnd->sc_dk.dk_driver = &vnddkdriver;
@


1.99
log
@leases have expired. (remove a comment).
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.98 2010/07/01 16:22:17 thib Exp $	*/
d663 5
a667 4
		pbp->b_flags |= B_ERROR;
		/* XXX does this matter here? */
		(&vbp->vb_buf)->b_flags |= B_RAW;
		pbp->b_error = biowait(&vbp->vb_buf);
d669 1
d671 7
d679 1
a685 5
	if (pbp->b_resid == 0) {
		DNPRINTF(VDB_IO, "vndiodone: pbp %p iodone\n", pbp);
		biodone(pbp);
	}

@


1.98
log
@for the allocated buf, set the b_bq flag to NULL so we do not
call bufq_done in biodone.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.97 2010/05/18 04:41:14 dlg Exp $	*/
a59 1
 * NOTE 3: Doesn't interact with leases, should it?
@


1.97
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.96 2010/04/23 15:25:21 jsing Exp $	*/
d573 1
@


1.96
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.94 2009/08/13 15:23:11 deraadt Exp $	*/
d82 1
@


1.95
log
@- fix format strings for values that are daddr64_t

ok otto@@, agreed by deraadt@@
@
text
@a318 2
	lp->d_rpm = 3600;
	lp->d_interleave = 1;
@


1.94
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.93 2009/06/17 01:30:30 thib Exp $	*/
d550 1
a550 1
		DNPRINTF(VDB_IO, "vndstrategy: vp %p/%p bn %x/%x sz %x\n",
d634 1
a634 1
	    "vndstart(%d): bp %p vp %p blkno %x addr %p cnt %lx\n",
d656 1
a656 1
	    "vndiodone(%d): vbp %p vp %p blkno %x addr %p cnt %lx\n",
@


1.93
log
@Revert bufq's. this is inline with the major midlayer reverts that
have been going on. this appears to bring us back to stable state.

lots of testing by oga and ariane and my self.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.92 2009/06/04 05:57:27 krw Exp $	*/
d166 1
a166 1
void	vndgetdisklabel(dev_t, struct vnd_softc *, struct disklabel *, int);
d303 1
a303 1
void
a306 2
	char *errstring = NULL;

d329 1
a329 6
	errstring = readdisklabel(VNDLABELDEV(dev), vndstrategy, lp, spoofonly);
	if (errstring) {
		DNPRINTF(VDB_IO, "%s: %s\n", sc->sc_dev.dv_xname,
		    errstring);
		return;
	}
@


1.92
log
@Add DIOCRLDINFO to those drivers previously deprived.

Noticed by & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.91 2009/06/03 22:09:30 thib Exp $	*/
a127 1
	int		 sc_active;		/* XXX */
d137 1
d502 2
a503 2
			/* If nothing more is queued, we are done. */
			if (!vnd->sc_active)
d511 3
a513 2
			bp = BUFQ_GET(vnd->sc_dk.dk_bufq);
			vnd->sc_active--;
d613 2
a614 2
		BUFQ_ADD(vnd->sc_dk.dk_bufq, &nbp->vb_buf);
		vnd->sc_active++;
d637 2
a638 3
	bp = BUFQ_GET(vnd->sc_dk.dk_bufq);
	if (bp == NULL)
		return;
d678 1
a678 1
	if (vnd->sc_active) {
d681 2
a682 2
		if (BUFQ_PEEK(vnd->sc_dk.dk_bufq) != NULL)
			vnd->sc_active--;
@


1.91
log
@add a flexible buffer queue (bufq) api, based on the never used
one by tedu@@. It doesn't do anything smart yet, it just uses
plain old disksort. we also keep the old method of queueing bufs
since some miods have crazy MD drivers that need some love.

ok beck@@, art@@
tested by many on many archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.89 2008/08/14 17:10:29 jsing Exp $	*/
d752 1
d948 9
@


1.90
log
@Replace -s (sector size) option with more general -t (disktype)
option which makes the vnd device emulate the geometry of the
specified disktab(5) entry. No change in behaviour or geometry
unless -t is used.

API for vnd configuration ioctl (VNDIOCSET) changes, so mount_vnd
must be in sync with kernel.

Tested & ok jsing@@ 'Lovely' deraadt@@
@
text
@d128 1
a137 1
	struct buf	 sc_tab;		/* transfer queue */
d502 2
a503 2
			/* If nothing more is queued, we are done.  */
			if (!vnd->sc_tab.b_active)
d511 2
a512 3
			bp = vnd->sc_tab.b_actf;
			vnd->sc_tab.b_actf = bp->b_actf;
			vnd->sc_tab.b_active--;
d612 2
a613 2
		disksort(&vnd->sc_tab, &nbp->vb_buf);
		vnd->sc_tab.b_active++;
d636 3
a638 2
	bp = vnd->sc_tab.b_actf;
	vnd->sc_tab.b_actf = bp->b_actf;
d678 1
a678 1
	if (vnd->sc_tab.b_active) {
d681 2
a682 2
		if (!vnd->sc_tab.b_actf)
			vnd->sc_tab.b_active--;
@


1.89
log
@Allow the sector size to be specified by the user when configuring a
vnd(4) device, via a new -s option to vnconfig/mount_vnd. This allows us
to create disklabels and file systems that are suitable for use on
devices that have a non-512 byte sector size (eg. CDROMs).

With help from krw@@ and feedback from pedro@@.

ok krw@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.87 2008/07/20 01:53:43 krw Exp $	*/
d133 2
d312 4
a315 4
	lp->d_ntracks = 1;
	lp->d_nsectors = 100;
	lp->d_ncylinders = sc->sc_size / 100;
	lp->d_secpercyl = 100;		/* lp->d_ntracks * lp->d_nsectors */
d795 4
a798 7
		/* Set sector size for device, if specified. */
		if (vio->vnd_secsize == 0)
			vnd->sc_secsize = DEV_BSIZE;
		else if (vio->vnd_secsize % DEV_BSIZE == 0)
			vnd->sc_secsize = vio->vnd_secsize;
		else
			return (EINVAL);
@


1.88
log
@
Correct cases of mishandling of pending reads and writes to prevent
them going negative - this consists of identifying a number of cases of
IO not going through the buffer cache and marking those buffers with
B_RAW - as well as fixing nfs_bio to show pending writes and reads through
the buffer cache via NFS

still has a problem with mishandling the counters I believe in the
async/sync fallback case where counters stay positive which will be
addressed seperately.

ok tedu@@ deraadt@@
@
text
@d131 2
a132 1
	size_t		 sc_size;		/* size of vnd in blocks */
d309 1
a309 1
	lp->d_secsize = DEV_BSIZE;
d411 10
d448 4
a451 1
	sz = howmany(bp->b_bcount, DEV_BSIZE);
d458 2
a459 2
			daddr64_t off = DL_GETPOFFSET(&vnd->sc_dk.dk_label->d_partitions[part]);

d526 2
a527 1
	bn += DL_GETPOFFSET(&vnd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)]);
a731 1
	long sscale;
d740 3
a742 4
	sscale = pi.disklab->d_secsize / DEV_BSIZE;
	DNPRINTF(VDB_INIT, "vndbdevsize: size %li secsize %li sscale %li\n",
	    (long)pi.part->p_size,(long)pi.disklab->d_secsize,sscale);
	return (pi.part->p_size * sscale);
d793 8
d835 1
a835 1
			vnd->sc_size = btodb(vattr.va_size); /* note truncation */
d866 1
a866 1
		vio->vnd_size = dbtob((off_t)vnd->sc_size);
d1028 1
a1028 1
	aiov.iov_len = MIN(DEV_BSIZE, dbtob((off_t)vnd->sc_size));
d1079 1
a1079 1
	return (vnd->sc_size);
@


1.87
log
@Add DIOCGPDINFO support. 'disklabel -d svnd0' now works.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.86 2008/06/29 20:05:22 krw Exp $	*/
d655 2
@


1.86
log
@Use DEV_BSIZE (defined as 512) instead of 512 when initializing the
disklabel's d_secsize.

ok millert@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.85 2008/03/24 01:16:58 krw Exp $	*/
d925 6
@


1.85
log
@Change XXgetdisklabel() to the 'normal' four parameter model to
prepare for adding missing DIOC* ioctl's.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.84 2007/10/15 01:37:49 fgsch Exp $	*/
d308 1
a308 1
	lp->d_secsize = 512;
@


1.84
log
@more remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.83 2007/09/29 07:08:02 fkr Exp $	*/
d163 1
a163 1
void	vndgetdisklabel(dev_t, struct vnd_softc *);
d248 1
a248 1
		vndgetdisklabel(dev, sc);
d301 2
a302 1
vndgetdisklabel(dev_t dev, struct vnd_softc *sc)
a303 1
	struct disklabel *lp = sc->sc_dk.dk_label;
d328 1
a328 1
	errstring = readdisklabel(VNDLABELDEV(dev), vndstrategy, lp, 0);
@


1.83
log
@make safe vnds work on block devices.
from Piotr Durlej, tested by henning@@, krw@@, thib@@ and myself
ok thib@@, grunk@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.82 2007/09/12 18:45:14 mk Exp $	*/
d520 1
a520 1
		int off, s, nra;
@


1.82
log
@There is no such word as `detatch'.

ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.81 2007/09/11 13:39:33 gilles Exp $	*/
d165 1
d234 6
d502 9
d710 20
d795 1
a795 2
		error = VOP_GETATTR(nd.ni_vp, &vattr, p->p_ucred, p);
		if (error) {
d797 1
a797 1
			(void) vn_close(nd.ni_vp, VNDRW(vnd), p->p_ucred, p);
d799 14
a812 1
			return (error);
a815 1
		vnd->sc_size = btodb(vattr.va_size);	/* note truncation */
@


1.81
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.80 2007/09/08 17:59:23 gilles Exp $	*/
d841 1
a841 1
		/* Detatch the disk. */
@


1.80
log
@more M_ZERO changes

ok pyr@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.79 2007/06/20 18:15:46 deraadt Exp $	*/
d201 1
a201 1
	mem = malloc(size, M_DEVBUF, M_NOWAIT|M_ZERO);
@


1.79
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.78 2007/06/08 05:27:58 deraadt Exp $	*/
d201 1
a201 1
	mem = malloc(size, M_DEVBUF, M_NOWAIT);
a205 1
	bzero(mem, size);
@


1.78
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.77 2007/06/06 17:15:13 deraadt Exp $	*/
a300 1
	bzero(sc->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
d322 1
a322 2
	errstring = readdisklabel(VNDLABELDEV(dev), vndstrategy, lp,
	    sc->sc_dk.dk_cpulabel, 0);
d418 1
a418 2
		if (bounds_check_with_label(bp, vnd->sc_dk.dk_label,
		    vnd->sc_dk.dk_cpulabel, 1) <= 0) {
d906 1
a906 2
		    (struct disklabel *)addr, /*vnd->sc_dk.dk_openmask : */0,
		    vnd->sc_dk.dk_cpulabel);
d910 1
a910 2
				    vndstrategy, vnd->sc_dk.dk_label,
				    vnd->sc_dk.dk_cpulabel);
@


1.77
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.76 2007/06/05 00:38:20 deraadt Exp $	*/
d316 1
@


1.76
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.75 2007/06/01 00:07:48 krw Exp $	*/
d164 1
a164 1
void	vndencrypt(struct vnd_softc *, caddr_t, size_t, daddr_t, int);
d170 1
a170 1
vndencrypt(struct vnd_softc *vnd, caddr_t addr, size_t size, daddr_t off,
d440 1
a440 1
			int off = DL_GETPOFFSET(&vnd->sc_dk.dk_label->d_partitions[part]);
d1000 1
a1000 1
int
d1012 1
a1012 1
vnddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
@


1.75
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.74 2007/05/12 12:19:23 krw Exp $	*/
d312 1
a312 1
	lp->d_secperunit = sc->sc_size;
d440 1
a440 1
			int off = vnd->sc_dk.dk_label->d_partitions[part].p_offset;
d499 1
a499 1
	bn += vnd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)].p_offset;
@


1.74
log
@Use VNDLABELDEV() and not DISKLABELDEV() in writedisklabel() since
VNDLABELDEV() is used in readdisklabel(). VNDLABELDEV() preserves the
vndsimple() property encoded in the device.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.73 2007/04/29 18:59:37 krw Exp $	*/
a315 5

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;
@


1.73
log
@Replace expansions of DISKLABELDEV() with DISKLABELDEV(). Shorter, and
more consistant. No change to code.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.72 2007/03/25 21:52:27 tedu Exp $	*/
d917 1
a917 1
				error = writedisklabel(DISKLABELDEV(dev),
@


1.72
log
@include rwlock.h ourselves, better than depending on it getting picked
up elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.71 2007/03/25 18:02:37 tedu Exp $	*/
d917 1
a917 2
				error = writedisklabel(MAKEDISKDEV(major(dev),
				    DISKUNIT(dev), RAW_PART),
@


1.71
log
@use a rwlock instead of the homegrown approach
ok art pedro thib
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.70 2007/02/26 11:25:23 pedro Exp $	*/
d79 1
@


1.70
log
@Don't enforce RLIMIT_FSIZE on vnd(4) I/O operations, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.69 2007/02/21 19:25:40 grunk Exp $	*/
d135 1
a140 2
#define	VNF_WANTED	0x0040
#define	VNF_LOCKED	0x0080
d165 2
a166 2
int	vndlock(struct vnd_softc *);
void	vndunlock(struct vnd_softc *);
d195 1
d207 3
a1021 34
}

/*
 * Wait interruptibly for an exclusive lock.
 *
 * XXX
 * Several drivers do this; it should be abstracted and made MP-safe.
 */
int
vndlock(struct vnd_softc *sc)
{
	int error;

	while ((sc->sc_flags & VNF_LOCKED) != 0) {
		sc->sc_flags |= VNF_WANTED;
		if ((error = tsleep(sc, PRIBIO | PCATCH, "vndlck", 0)) != 0)
			return (error);
	}
	sc->sc_flags |= VNF_LOCKED;
	return (0);
}

/*
 * Unlock and wake up any waiters.
 */
void
vndunlock(struct vnd_softc *sc)
{

	sc->sc_flags &= ~VNF_LOCKED;
	if ((sc->sc_flags & VNF_WANTED) != 0) {
		sc->sc_flags &= ~VNF_WANTED;
		wakeup(sc);
	}
@


1.69
log
@Don't use arbitrary 128 bytes as size of the blf key array if we know exactly
how much blowfish takes at max, which is 72 bytes.
Also define a constant for this in the include file, suggested by ray@@.

ok pedro@@ thib@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.68 2007/02/01 01:02:05 pedro Exp $	*/
d464 6
a469 2
				bp->b_error = VOP_WRITE(vnd->sc_vp, &auio, 0,
				    vnd->sc_cred);
@


1.68
log
@Don't throttle and serialize I/O operations, okay miod@@ krw@@
Fixes kern/5347
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.67 2007/01/13 16:47:15 thib Exp $	*/
d776 1
a776 1
			char key[128];
@


1.67
log
@Touch of clean up:
s/DEBUG/VNDDEBUG/ and introduce DNPRINTF, fold
all the #ifdef DEBUG <stuff> #endif into DNPRINTFs.
Use DTYPE_VND for the disklabel d_type member, dont
calcluate d_secpercyl from d_ntrack * d_nsectors, just
set it too 100 directly since we set d_ntrack and
d_nsectors to 1 and 100 respectivly.

testing and OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.66 2006/12/24 09:39:27 pedro Exp $	*/
a132 1
	int		 sc_maxactive;		/* max # of active requests */
a144 1
#define	VNF_BUSY	0x0800
a160 1
void	vndthrottle(struct vnd_softc *, struct vnode *);
d378 1
a378 3
 * access the underlying file.  Things are complicated by the fact that we
 * might get recursively called due to buffer flushes.  In those cases we
 * queue one write.
a437 19
		/*
		 * In order to avoid "locking against myself" panics, we
		 * must be prepared to queue operations during another I/O
		 * operation.  This situation comes up where a dirty cache
		 * buffer needs to be flushed in order to provide the current
		 * operation with a fresh buffer.
		 *
		 * XXX do we really need to protect stuff relating to this with
		 * splbio?
		 */
		if (vnd->sc_flags & VNF_BUSY) {
			s = splbio();
			bp->b_actf = vnd->sc_tab.b_actf;
			vnd->sc_tab.b_actf = bp;
			vnd->sc_tab.b_active++;
			splx(s);
			return;
		}

a451 1
			vnd->sc_flags |= VNF_BUSY;
a470 1
			vnd->sc_flags &= ~VNF_BUSY;
d581 2
a582 4
		if (vnd->sc_tab.b_active < vnd->sc_maxactive) {
			vnd->sc_tab.b_active++;
			vndstart(vnd);
		}
a583 1

d646 1
a646 3
		if (vnd->sc_tab.b_actf)
			vndstart(vnd);
		else
a795 1
		vndthrottle(vnd, vnd->sc_vp);
a967 16
}

/*
 * Set maxactive based on FS type
 */
void
vndthrottle(struct vnd_softc *vnd, struct vnode *vp)
{
#ifdef NFSCLIENT
	extern int (**nfsv2_vnodeop_p)(void *);

	if (vp->v_op == nfsv2_vnodeop_p)
		vnd->sc_maxactive = 2;
	else
#endif
		vnd->sc_maxactive = 8;
@


1.66
log
@ansify, no binary change, from Bret Lambert
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.65 2006/10/05 18:29:26 thib Exp $	*/
d88 1
a88 1
#ifdef DEBUG
d94 4
a97 1
#endif
d224 2
a225 4
#ifdef DEBUG
	if (vnddebug & VDB_FOLLOW)
		printf("vndopen(%x, %x, %x, %p)\n", dev, flags, mode, p);
#endif
d297 1
a297 1
	char *errstring;
d306 1
a306 5
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
	if (lp->d_secpercyl == 0) {
		lp->d_secpercyl = 100;
		/* as long as it's not 0 - readdisklabel divides by it (?) */
	}
d309 1
a309 1
	lp->d_type = DTYPE_SCSI;
d325 1
a325 3
	/*
	 * Call the generic disklabel extraction routine
	 */
d329 2
a330 1
		/*printf("%s: %s\n", sc->sc_dev.dv_xname, errstring);*/
d342 1
a342 4
#ifdef DEBUG
	if (vnddebug & VDB_FOLLOW)
		printf("vndclose(%x, %x, %x, %p)\n", dev, flags, mode, p);
#endif
d400 2
a401 4
#ifdef DEBUG
	if (vnddebug & VDB_FOLLOW)
		printf("vndstrategy(%p): unit %d\n", bp, unit);
#endif
d538 1
a538 1
#ifdef DEBUG
d549 3
a551 5
#ifdef DEBUG
		if (vnddebug & VDB_IO)
			printf("vndstrategy: vp %p/%p bn %x/%x sz %x\n",
			    vnd->sc_vp, vp, bn, nbn, sz);
#endif
d635 5
a639 6
#ifdef DEBUG
	if (vnddebug & VDB_IO)
		printf("vndstart(%d): bp %p vp %p blkno %x addr %p cnt %lx\n",
		    vnd-vnd_softc, bp, bp->b_vp, bp->b_blkno, bp->b_data,
		    bp->b_bcount);
#endif
d658 4
a661 6
#ifdef DEBUG
	if (vnddebug & VDB_IO)
		printf("vndiodone(%d): vbp %p vp %p blkno %x addr %p cnt %lx\n",
		    vnd-vnd_softc, vbp, vbp->vb_buf.b_vp, vbp->vb_buf.b_blkno,
		    vbp->vb_buf.b_data, vbp->vb_buf.b_bcount);
#endif
d664 3
a666 5
#ifdef DEBUG
		if (vnddebug & VDB_IO)
			printf("vndiodone: vbp %p error %d\n", vbp,
			    vbp->vb_buf.b_error);
#endif
d681 1
a681 4
#ifdef DEBUG
		if (vnddebug & VDB_IO)
			printf("vndiodone: pbp %p iodone\n", pbp);
#endif
d694 1
a694 4
#ifdef DEBUG
	if (vnddebug & VDB_FOLLOW)
		printf("vndread(%x, %p)\n", dev, uio);
#endif
d713 1
a713 4
#ifdef DEBUG
	if (vnddebug & VDB_FOLLOW)
		printf("vndwrite(%x, %p)\n", dev, uio);
#endif
d737 3
a739 5
#ifdef DEBUG
	if (vnddebug & VDB_FOLLOW)
		printf("vndioctl(%x, %lx, %p, %x, %p): unit %d\n",
		    dev, cmd, addr, flag, p, unit);
#endif
d830 3
a832 5
#ifdef DEBUG
		if (vnddebug & VDB_INIT)
			printf("vndioctl: SET vp %p size %llx\n",
			    vnd->sc_vp, (unsigned long long)vnd->sc_size);
#endif
d865 2
a866 4
#ifdef DEBUG
		if (vnddebug & VDB_INIT)
			printf("vndioctl: CLRed\n");
#endif
d1034 2
a1035 4
#ifdef DEBUG
	if (vnddebug & VDB_FOLLOW)
		printf("vndclear(%p): vp %p\n", vnd, vp);
#endif
@


1.65
log
@Always allow read-only opens on (s)vnd devices, despite the
type of the first open (svnd vs vnd).

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.64 2006/10/03 19:49:06 pedro Exp $	*/
d170 2
a171 6
vndencrypt(vnd, addr, size, off, encrypt)
	struct vnd_softc *vnd;
	caddr_t addr;
	size_t size;
	daddr_t off;
	int encrypt;
d192 1
a192 2
vndattach(num)
	int num;
d215 1
a215 4
vndopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d293 1
a293 3
vndgetdisklabel(dev, sc)
	dev_t dev;
	struct vnd_softc *sc;
d340 1
a340 4
vndclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d393 1
a393 2
vndstrategy(bp)
	struct buf *bp;
d636 1
a636 2
vndstart(vnd)
	struct vnd_softc *vnd;
d662 1
a662 2
vndiodone(bp)
	struct buf *bp;
d708 1
a708 4
vndread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d730 1
a730 4
vndwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d752 1
a752 6
vndioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d1005 1
a1005 3
vndsetcred(vnd, cred)
	struct vnd_softc *vnd;
	struct ucred *cred;
d1037 1
a1037 3
vndthrottle(vnd, vp)
	struct vnd_softc *vnd;
	struct vnode *vp;
d1050 1
a1050 1
vndshutdown()
d1060 1
a1060 2
vndclear(vnd)
	struct vnd_softc *vnd;
d1070 1
a1070 1
	if (vp == (struct vnode *)0)
d1074 2
a1075 2
	vnd->sc_vp = (struct vnode *)0;
	vnd->sc_cred = (struct ucred *)0;
d1080 1
a1080 2
vndsize(dev)
	dev_t dev;
d1091 1
a1091 5
vnddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
d1105 1
a1105 2
vndlock(sc)
	struct vnd_softc *sc;
d1122 1
a1122 2
vndunlock(sc)
	struct vnd_softc *sc;
@


1.64
log
@Introduce daddr64_t and use it for physical block numbers
Okay weingart@@, "I'm game with putting my name on it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.63 2006/09/20 13:51:19 pedro Exp $	*/
d256 1
a256 1
	 * same type.
d260 1
a260 1
		    (vndsimple(dev) != 0)) {
@


1.63
log
@Make vnd(4) work on read-only file systems, from Paul Stoeber, okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.62 2006/08/13 17:55:07 thib Exp $	*/
d552 1
a552 1
		daddr_t nbn;
@


1.62
log
@fix a panic when trying to fdisk vnd devices (not svnd) wich
are back by weird images (such as the ones qemu creates).

proplem found the hard way by msf@@

ok mickey@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.61 2006/08/12 13:53:44 krw Exp $	*/
d145 3
d240 5
d828 3
a830 4
		 * Always open for read and write.
		 * This is probably bogus, but it lets vn_open()
		 * weed out directories, sockets, etc. so we don't
		 * have to worry about them.
d833 7
a839 1
		if ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {
d843 1
d847 1
a847 1
			(void) vn_close(nd.ni_vp, FREAD|FWRITE, p->p_ucred, p);
d855 1
a855 1
			(void) vn_close(nd.ni_vp, FREAD|FWRITE, p->p_ucred, p);
d868 1
a868 1
				(void) vn_close(nd.ni_vp, FREAD|FWRITE,
d1104 1
a1104 1
	(void) vn_close(vp, FREAD|FWRITE, vnd->sc_cred, p);
@


1.61
log
@Setting d_secsize to DEV_BSIZE (or 1 << DEV_BSHIFT, or 512) and then
setting RAW_PART's p_size to d_secperunit * (d_secsize / DEV_BSIZE) is
a waste of a few ops. And p_size should be in sectors anyway.

Just set RAW_PART's p_size to d_secperunit to make usage consistant
across the tree.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.60 2006/03/15 20:20:41 miod Exp $	*/
d603 2
d611 3
@


1.60
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.59 2006/03/04 22:53:32 pedro Exp $	*/
d322 1
a322 2
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
@


1.59
log
@Disk interrupts can cause buffers to be returned to the vnd pool, so
splbio() is required when allocating. Fixes PR kern/5041, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.58 2006/01/22 00:40:02 miod Exp $	*/
a875 1
		dk_establish(&vnd->sc_dk, &vnd->sc_dev);
@


1.58
log
@b_cylin -> b_cylinder; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.57 2005/12/29 20:02:03 pedro Exp $	*/
d571 1
d573 1
@


1.57
log
@Correctly bounds check transfers passed to vndstrategy()
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.56 2005/07/20 02:36:13 tedu Exp $	*/
a95 2
#define	b_cylin	b_resid

d615 1
a615 1
		nbp->vb_buf.b_cylin = nbp->vb_buf.b_blkno;
@


1.56
log
@change sc_keyctx from void * to blf_ctx *.  there's no point for it to be
void and means we can't correctly use sizeof() on the target.
error report from frank denis in pr4290.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.55 2005/04/19 15:32:12 mickey Exp $	*/
a429 1
	sz = howmany(bp->b_bcount, DEV_BSIZE);
d431 1
d440 15
a454 7
	if (DISKPART(bp->b_dev) != RAW_PART &&
	    bounds_check_with_label(bp, vnd->sc_dk.dk_label,
	    vnd->sc_dk.dk_cpulabel, 1) <= 0) {
		s = splbio();
		biodone(bp);
		splx(s);
		return;
d456 2
@


1.55
log
@use pool for struct vndbug; tested by many and pedro@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.54 2005/04/12 13:25:37 joris Exp $	*/
d134 1
a134 1
	void		*sc_keyctx;		/* key context */
d846 1
a846 1
			vnd->sc_keyctx = malloc(sizeof(blf_ctx), M_DEVBUF,
@


1.54
log
@

simplify vndopen() a bit.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.53 2005/01/05 06:38:15 tedu Exp $	*/
d70 1
d115 7
a121 4
#define	getvndbuf()	\
	((struct vndbuf *)malloc(sizeof(struct vndbuf), M_DEVBUF, M_WAITOK))
#define	putvndbuf(vbp)	\
	free((caddr_t)(vbp), M_DEVBUF)
d212 4
@


1.53
log
@copyoutstr doesn't work so well with the kernel addresses
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.52 2004/06/30 11:33:39 pedro Exp $	*/
d277 1
a277 2
	vndunlock(sc);
	return (0);
@


1.52
log
@since we're not using 'len' for anything, nuke it and pass null to
copyin/copyout. suggested by millert@@, ok'd by him and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.51 2004/06/30 00:13:53 pedro Exp $	*/
d924 2
a925 4
			if ((error = copyoutstr(vnd->sc_file, vnu->vnu_file,
			    sizeof(vnu->vnu_file), NULL)))
				return (error);

@


1.51
log
@don't strlcpy() to user-space, use copyoutstr() instead. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.50 2004/06/28 16:43:55 deraadt Exp $	*/
a758 1
	size_t len;
d785 1
a785 1
		    sizeof(vnd->sc_file), &len))) {
d925 1
a925 1
			    sizeof(vnu->vnu_file), &len)))
@


1.50
log
@You *cannot* strlcpy from userland.  Pedro, go read this and find out what
you did wrong.  Bit in other changes that were backed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.48 2004/06/20 18:03:03 pedro Exp $	*/
d925 3
a927 2
			strlcpy(vnu->vnu_file, vnd->sc_file,
			    sizeof(vnu->vnu_file));
@


1.49
log
@back out crud that breaks the macppc
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.45 2004/03/04 01:22:50 tedu Exp $	*/
d474 1
a474 1
			auio.uio_procp = NULL;
d759 1
d785 6
a849 1
		strlcpy(vnd->sc_file, vio->vnd_file, sizeof(vnd->sc_file));
d852 2
a853 2
			printf("vndioctl: SET vp %p size %x\n",
			    vnd->sc_vp, vnd->sc_size);
d1015 1
a1015 1
	aiov.iov_len = min(DEV_BSIZE, dbtob(vnd->sc_size));
@


1.48
log
@add the VNDIOCGET ioctl to vnode disks, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.47 2004/06/19 14:29:20 pedro Exp $	*/
d474 1
a474 1
			auio.uio_procp = p;
d846 2
a847 2
			printf("vndioctl: SET vp %p size %llx\n",
			    vnd->sc_vp, (unsigned long long)vnd->sc_size);
d1009 1
a1009 1
	aiov.iov_len = MIN(DEV_BSIZE, dbtob((off_t)vnd->sc_size));
@


1.47
log
@save curproc for further reference, otherwise we may end up in lockmgr()
with no process context. ok miod@@. closes pr 3214.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.46 2004/05/22 18:26:52 otto Exp $	*/
d123 8
a130 7
	int		 sc_flags;	/* flags */
	size_t		 sc_size;	/* size of vnd in blocks */
	struct vnode	*sc_vp;		/* vnode */
	struct ucred	*sc_cred;	/* credentials */
	int		 sc_maxactive;	/* max # of active requests */
	struct buf	 sc_tab;	/* transfer queue */
	void		*sc_keyctx;	/* key context */
d755 1
d843 1
d900 29
@


1.46
log
@Do not truncate intermediate results computing aiov.iov_len in vndsetcred();
print size_t as unsigned long long.
ok tedu@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.45 2004/03/04 01:22:50 tedu Exp $	*/
d473 1
a473 1
			auio.uio_procp = NULL;
@


1.45
log
@3 buglets.
if keylen < 0, bad things happen.
large keys are useless, limit size and use stack for temp storage
bzero of keyctx is unrelated to keylen, wipe whole thing.
ok markus tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.44 2004/03/03 22:03:23 miod Exp $	*/
d843 2
a844 2
			printf("vndioctl: SET vp %p size %x\n",
			    vnd->sc_vp, vnd->sc_size);
d977 1
a977 1
	aiov.iov_len = min(DEV_BSIZE, dbtob(vnd->sc_size));
@


1.44
log
@Make sure than svnd read their disklabel as svnd, not vnd devices.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.43 2004/02/15 02:52:10 tedu Exp $	*/
d817 2
a818 2
		if (vio->vnd_keylen) {
			char *key;
d820 4
a823 2
			key = malloc(vio->vnd_keylen, M_TEMP, M_WAITOK);
			if ((error = copyin((caddr_t)vio->vnd_key, key,
a834 1
			free((caddr_t)key, M_TEMP);
d885 2
a886 2
			bzero(vnd->sc_keyctx, vio->vnd_keylen);
			free((caddr_t)vnd->sc_keyctx, M_DEVBUF);
@


1.43
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.42 2004/02/15 02:45:46 tedu Exp $	*/
a102 1
#define	MAKEVNDDEV(maj, unit, part)	MAKEDISKDEV(maj, unit, part)
d104 4
a107 1
#define	VNDLABELDEV(dev) (MAKEVNDDEV(major(dev), vndunit(dev), RAW_PART))
@


1.42
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.41 2003/10/17 23:05:39 tedu Exp $	*/
d90 3
a92 3
#define VDB_FOLLOW	0x01
#define VDB_INIT	0x02
#define VDB_IO		0x04
d95 1
a95 1
#define b_cylin	b_resid
d102 1
a102 1
#define vndsimple(x)	(minor(x) & 0x800)
d114 1
a114 1
#define putvndbuf(vbp)	\
d132 3
a134 3
#define VNF_INITED	0x0002
#define VNF_WANTED	0x0040
#define VNF_LOCKED	0x0080
d138 2
a139 2
#define VNF_BUSY	0x0800
#define VNF_SIMPLE	0x1000
d163 5
a167 5
     struct vnd_softc *vnd;
     caddr_t addr;
     size_t size;
     daddr_t off;
     int encrypt;
d171 1
a171 1
	
d481 1
a481 2
						   bp->b_bcount,
						   bp->b_blkno, 0);
d485 1
a485 2
						   bp->b_bcount, 
						   bp->b_blkno, 1);
d492 1
a492 2
						   bp->b_bcount,
						   bp->b_blkno, 0);
d522 1
a522 1
 	bsize = vnd->sc_vp->v_mount->mnt_stat.f_iosize;
d550 1
a550 1
			       vnd->sc_vp, vp, bn, nbn, sz);
d680 1
a680 1
        if (pbp->b_resid == 0) {
d682 2
a683 2
                if (vnddebug & VDB_IO)
                        printf("vndiodone: pbp %p iodone\n", pbp);
d685 2
a686 2
                biodone(pbp);
        }
d820 1
a820 1
					    vio->vnd_keylen)) != 0) {
d822 1
a822 1
						p->p_ucred, p);
d828 1
a828 1
						M_WAITOK);
d834 1
a834 1
			
@


1.41
log
@vndunit() wasn't quite right after last change, limiting vnds to 16.
apply fix from tom cosgrove to get the full range.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.40 2003/10/11 03:31:07 tedu Exp $	*/
a653 1
	long count;
a674 8
	count = pbp->b_bcount - pbp->b_resid;
	if (pbp->b_resid == 0) {
#ifdef DEBUG
		if (vnddebug & VDB_IO)
			printf("vndiodone: pbp %p iodone\n", pbp);
#endif
		biodone(pbp);
	}
d676 2
a677 1
		disk_unbusy(&vnd->sc_dk, count);
d683 8
@


1.40
log
@bump minor gap for svnd devices, so more vnds are allowed.
this change REQUIRES running MAKEDEV again after booting with a new kernel.
with a hint from tom cosgrove.  ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.39 2003/08/15 20:32:16 tedu Exp $	*/
d97 5
a101 1
#define	vndunit(x)	DISKUNIT(minor(x) & 0x7ff)
@


1.39
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.38 2003/06/02 23:28:01 millert Exp $	*/
d97 2
a98 2
#define	vndunit(x)	DISKUNIT((x) & 0x7f)
#define vndsimple(x)	((x) & 0x80)
@


1.38
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.37 2003/04/19 12:59:13 krw Exp $	*/
d760 1
a760 1
	error = suser(p->p_ucred, &p->p_acflag);
@


1.37
log
@Some string cleanup: sprintf -> snprintf and magic numbers to sizeof
(remember: d_[type|pack]name do not need terminating null).

Take the opportunity to introduce some paranoia and check the device
name lengths to make sure they fit, with appropriate errors if not.

ok tedu@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.36 2003/04/06 22:01:43 miod Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.36
log
@The return value for bounds_check_with_label() is not set in stone, and it
turns out that some arches will return (-1) in case of error, while others
will return (0).

Until we make our minds on this, make sure that callers of this function
properly handle 0 or (-1) as failure.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.35 2003/02/25 09:13:35 tedu Exp $	*/
d305 1
a305 1
	strncpy(lp->d_typename, "vnd device", 16);
d307 1
a307 1
	strncpy(lp->d_packname, "fictitious", 16);
d783 8
a847 2
		bzero(vnd->sc_dev.dv_xname, sizeof(vnd->sc_dev.dv_xname));
		sprintf(vnd->sc_dev.dv_xname, "vnd%d", unit);
@


1.35
log
@remove useless check.

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.34 2002/05/24 13:10:52 art Exp $	*/
d432 1
a432 1
	    vnd->sc_dk.dk_cpulabel, 1) == 0) {
@


1.34
log
@Make sure that b_iodone handlers are called at splbio (and splassert(IPL_BIO) in all known callers, just to make sure).
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.33 2002/05/23 22:47:16 art Exp $	*/
a1001 3

	if (vnd->sc_maxactive < 1)
		vnd->sc_maxactive = 1;
@


1.33
log
@Protect biodone calls with splbio.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.32 2002/03/14 01:26:52 millert Exp $	*/
a654 1
	int s;
d656 2
a657 1
	s = splbio();
a690 1
	splx(s);
@


1.32
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.31 2001/12/19 08:58:06 art Exp $	*/
d413 1
d415 1
d425 1
d427 1
d433 1
d435 1
d502 1
d504 1
d592 1
d594 1
@


1.31
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.30 2001/12/07 00:11:14 niklas Exp $	*/
d147 1
a147 1
void	vndattach __P((int));
d149 8
a156 8
void	vndclear __P((struct vnd_softc *));
void	vndstart __P((struct vnd_softc *));
int	vndsetcred __P((struct vnd_softc *, struct ucred *));
void	vndthrottle __P((struct vnd_softc *, struct vnode *));
void	vndiodone __P((struct buf *));
void	vndshutdown __P((void));
void	vndgetdisklabel __P((dev_t, struct vnd_softc *));
void	vndencrypt __P((struct vnd_softc *, caddr_t, size_t, daddr_t, int));
d158 2
a159 2
int	vndlock __P((struct vnd_softc *));
void	vndunlock __P((struct vnd_softc *));
d986 1
a986 1
	extern int (**nfsv2_vnodeop_p) __P((void *));
@


1.30
log
@Make vnds larger than 2G work, mostly by Daniel Lucq <daniel@@lucq.org>
toouches by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.29 2001/11/27 05:27:11 art Exp $	*/
d562 4
@


1.30.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.30 2001/12/07 00:11:14 niklas Exp $	*/
d147 1
a147 1
void	vndattach(int);
d149 8
a156 8
void	vndclear(struct vnd_softc *);
void	vndstart(struct vnd_softc *);
int	vndsetcred(struct vnd_softc *, struct ucred *);
void	vndthrottle(struct vnd_softc *, struct vnode *);
void	vndiodone(struct buf *);
void	vndshutdown(void);
void	vndgetdisklabel(dev_t, struct vnd_softc *);
void	vndencrypt(struct vnd_softc *, caddr_t, size_t, daddr_t, int);
d158 2
a159 2
int	vndlock(struct vnd_softc *);
void	vndunlock(struct vnd_softc *);
a412 1
		s = splbio();
a413 1
		splx(s);
a422 1
		s = splbio();
a423 1
		splx(s);
a428 1
		s = splbio();
a429 1
		splx(s);
a495 1
			s = splbio();
a496 1
			splx(s);
a579 1
			s = splbio();
a580 1
			splx(s);
d641 1
d643 1
a643 2
	splassert(IPL_BIO);

d677 1
d982 1
a982 1
	extern int (**nfsv2_vnodeop_p)(void *);
@


1.30.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d305 1
a305 1
	strncpy(lp->d_typename, "vnd device", sizeof(lp->d_typename));
d307 1
a307 1
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
d432 1
a432 1
	    vnd->sc_dk.dk_cpulabel, 1) <= 0) {
a778 8
		bzero(vnd->sc_dev.dv_xname, sizeof(vnd->sc_dev.dv_xname));
		if (snprintf(vnd->sc_dev.dv_xname, sizeof(vnd->sc_dev.dv_xname),
		    "vnd%d", unit) >= sizeof(vnd->sc_dev.dv_xname)) {
			printf("VNDIOCSET: device name too long\n");
			vndunlock(vnd);
			return(ENXIO);
		}

d836 2
d998 3
@


1.29
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.28 2001/11/15 23:15:15 art Exp $	*/
d122 1
a122 1
	size_t		 sc_size;	/* size of vnd */
d158 2
a159 2
static	int vndlock __P((struct vnd_softc *));
static	void vndunlock __P((struct vnd_softc *));
d192 1
a192 1
	register u_long size;
d392 1
a392 1
	register struct buf *bp;
d395 6
a400 5
	register struct vnd_softc *vnd = &vnd_softc[unit];
	register struct vndbuf *nbp;
	register int bn, bsize;
	register caddr_t addr;
	register size_t resid;
d463 1
a463 1
			auio.uio_offset = dbtob(bp->b_blkno + off);
d608 1
a608 1
	register struct vnd_softc *vnd;
d610 1
a610 1
	register struct buf *bp;
d637 3
a639 3
	register struct vndbuf *vbp = (struct vndbuf *) bp;
	register struct buf *pbp = vbp->vb_obp;
	register struct vnd_softc *vnd = &vnd_softc[vndunit(pbp->b_dev)];
d740 1
a740 1
	register struct vnd_softc *vnd;
d818 1
a818 1
		vio->vnd_size = dbtob(vnd->sc_size);
d944 1
a944 1
	register struct vnd_softc *vnd;
d978 1
a978 1
	register struct vnd_softc *vnd;
d997 1
a997 1
	register struct vnd_softc *vnd;
d1006 1
a1006 1
	register struct vnd_softc *vnd;
d1008 1
a1008 1
	register struct vnode *vp = vnd->sc_vp;
d1030 1
a1030 1
	register struct vnd_softc *vnd = &vnd_softc[unit];
d1055 1
a1055 1
static int
d1073 1
a1073 1
static void
@


1.28
log
@Remove creds from struct buf, move the creds that nfs need into the nfs node.
While in the area, convert nfs node allocation from malloc to pool and do
some cleanups.
Based on the UBC changes in NetBSD. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.27 2000/07/05 07:27:12 niklas Exp $	*/
a560 4
		nbp->vb_buf.b_dirtyoff = bp->b_dirtyoff;
		nbp->vb_buf.b_dirtyend = bp->b_dirtyend;
		nbp->vb_buf.b_validoff = bp->b_validoff;
		nbp->vb_buf.b_validend = bp->b_validend;
@


1.27
log
@Make return statements adhere to KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.26 2000/06/26 19:00:25 provos Exp $	*/
a560 2
		nbp->vb_buf.b_rcred = vnd->sc_cred;	/* XXX crdup? */
		nbp->vb_buf.b_wcred = vnd->sc_cred;	/* XXX crdup? */
@


1.26
log
@let svnd deal with sparse files, okay art@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.25 2000/06/22 23:02:19 fgsch Exp $	*/
d784 1
a784 1
			return(error);
d791 1
a791 1
			return(error);
d799 1
a799 1
			return(error);
d811 1
a811 1
				return(error);
d889 1
a889 1
		return 0;
d897 1
a897 1
		return 0;
d904 1
a904 1
			return EBADF;
d907 1
a907 1
			return error;
d923 1
a923 1
		return error;
d927 1
a927 1
			return EBADF;
d932 1
a932 1
		return 0;
d935 1
a935 1
		return(ENOTTY);
d1038 2
a1039 2
		return(-1);
	return(vnd->sc_size);
d1051 1
a1051 1
	return ENXIO;
@


1.25
log
@on unconfig, bzero the key before free; from aazubel@@core-sdi.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.24 2000/06/20 21:29:20 provos Exp $	*/
d645 1
d667 1
a667 1
	disk_unbusy(&vnd->sc_dk, (pbp->b_bcount - pbp->b_resid));
d675 7
a681 4
	if (vnd->sc_tab.b_actf)
		vndstart(vnd);
	else
		vnd->sc_tab.b_active--;
@


1.24
log
@add encryption for svnd's for Erich <hh@@cyberpass.net>.  You can do a
poor man's encrypted file system with this.  Blame the Greek. okay niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.23 1998/10/03 21:19:00 millert Exp $	*/
d866 2
a867 1
		if (vnd->sc_keyctx)
d869 1
@


1.23
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.22 1998/08/04 22:01:54 millert Exp $	*/
d85 2
d127 1
d156 1
d162 26
d472 4
d477 4
d484 5
d599 1
d765 2
d797 21
d865 3
@


1.23.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.27 2000/07/05 07:27:12 niklas Exp $	*/
a84 2
#include <crypto/blf.h>

a124 1
	void		*sc_keyctx;	/* key context */
a152 1
void	vndencrypt __P((struct vnd_softc *, caddr_t, size_t, daddr_t, int));
a157 26
vndencrypt(vnd, addr, size, off, encrypt)
     struct vnd_softc *vnd;
     caddr_t addr;
     size_t size;
     daddr_t off;
     int encrypt;
{
	int i, bsize;
	u_char iv[8];
	
	bsize = dbtob(1);
	for (i = 0; i < size/bsize; i++) {
		bzero(iv, sizeof(iv));
		bcopy((u_char *)&off, iv, sizeof(off));
		blf_ecb_encrypt(vnd->sc_keyctx, iv, sizeof(iv));
		if (encrypt)
			blf_cbc_encrypt(vnd->sc_keyctx, iv, addr, bsize);
		else
			blf_cbc_decrypt(vnd->sc_keyctx, iv, addr, bsize);

		addr += bsize;
		off++;
	}
}

void
a441 4
				if (vnd->sc_keyctx)
					vndencrypt(vnd,	bp->b_data,
						   bp->b_bcount,
						   bp->b_blkno, 0);
a442 4
				if (vnd->sc_keyctx)
					vndencrypt(vnd, bp->b_data,
						   bp->b_bcount, 
						   bp->b_blkno, 1);
a445 5
				/* Data in buffer cache needs to be in clear */
				if (vnd->sc_keyctx)
					vndencrypt(vnd, bp->b_data,
						   bp->b_bcount,
						   bp->b_blkno, 0);
a555 1

a600 1
	long count;
d622 1
a622 1
	count = pbp->b_bcount - pbp->b_resid;
d630 4
a633 7
	if (vnd->sc_tab.b_active) {
		disk_unbusy(&vnd->sc_dk, count);
		if (vnd->sc_tab.b_actf)
			vndstart(vnd);
		else
			vnd->sc_tab.b_active--;
	}
a720 2
		if (!(vnd->sc_flags & VNF_SIMPLE) && vio->vnd_keylen)
			return (EINVAL);
d734 1
a734 1
			return (error);
d741 1
a741 1
			return (error);
d749 1
a749 1
			return (error);
a750 21

		if (vio->vnd_keylen) {
			char *key;

			key = malloc(vio->vnd_keylen, M_TEMP, M_WAITOK);
			if ((error = copyin((caddr_t)vio->vnd_key, key,
					    vio->vnd_keylen)) != 0) {
				(void) vn_close(nd.ni_vp, FREAD|FWRITE,
						p->p_ucred, p);
				vndunlock(vnd);
				return (error);
			}

			vnd->sc_keyctx = malloc(sizeof(blf_ctx), M_DEVBUF,
						M_WAITOK);
			blf_key(vnd->sc_keyctx, key, vio->vnd_keylen);
			bzero(key, vio->vnd_keylen);
			free((caddr_t)key, M_TEMP);
		} else
			vnd->sc_keyctx = NULL;
			
a797 5
		/* Free crypto key */
		if (vnd->sc_keyctx) {
			bzero(vnd->sc_keyctx, vio->vnd_keylen);
			free((caddr_t)vnd->sc_keyctx, M_DEVBUF);
		}
d813 1
a813 1
		return (0);
d821 1
a821 1
		return (0);
d828 1
a828 1
			return (EBADF);
d831 1
a831 1
			return (error);
d847 1
a847 1
		return (error);
d851 1
a851 1
			return (EBADF);
d856 1
a856 1
		return (0);
d859 1
a859 1
		return (ENOTTY);
d962 2
a963 2
		return (-1);
	return (vnd->sc_size);
d975 1
a975 1
	return (ENXIO);
@


1.23.8.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.23.8.1 2001/05/14 22:23:04 niklas Exp $	*/
d561 6
@


1.23.8.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d122 1
a122 1
	size_t		 sc_size;	/* size of vnd in blocks */
d158 2
a159 2
int	vndlock __P((struct vnd_softc *));
void	vndunlock __P((struct vnd_softc *));
d192 1
a192 1
	u_long size;
d392 1
a392 1
	struct buf *bp;
d395 5
a399 6
	struct vnd_softc *vnd = &vnd_softc[unit];
	struct vndbuf *nbp;
	int bsize;
	off_t bn;
	caddr_t addr;
	size_t resid;
d462 1
a462 1
			auio.uio_offset = dbtob((off_t)(bp->b_blkno + off));
a560 4
		nbp->vb_buf.b_dirtyoff = bp->b_dirtyoff;
		nbp->vb_buf.b_dirtyend = bp->b_dirtyend;
		nbp->vb_buf.b_validoff = bp->b_validoff;
		nbp->vb_buf.b_validend = bp->b_validend;
d607 1
a607 1
	struct vnd_softc *vnd;
d609 1
a609 1
	struct buf *bp;
d636 3
a638 3
	struct vndbuf *vbp = (struct vndbuf *) bp;
	struct buf *pbp = vbp->vb_obp;
	struct vnd_softc *vnd = &vnd_softc[vndunit(pbp->b_dev)];
d739 1
a739 1
	struct vnd_softc *vnd;
d817 1
a817 1
		vio->vnd_size = dbtob((off_t)vnd->sc_size);
d943 1
a943 1
	struct vnd_softc *vnd;
d977 1
a977 1
	struct vnd_softc *vnd;
d996 1
a996 1
	struct vnd_softc *vnd;
d1005 1
a1005 1
	struct vnd_softc *vnd;
d1007 1
a1007 1
	struct vnode *vp = vnd->sc_vp;
d1029 1
a1029 1
	struct vnd_softc *vnd = &vnd_softc[unit];
d1054 1
a1054 1
int
d1072 1
a1072 1
void
@


1.23.8.4
log
@Merge in -current from roughly a week ago
@
text
@d147 1
a147 1
void	vndattach(int);
d149 8
a156 8
void	vndclear(struct vnd_softc *);
void	vndstart(struct vnd_softc *);
int	vndsetcred(struct vnd_softc *, struct ucred *);
void	vndthrottle(struct vnd_softc *, struct vnode *);
void	vndiodone(struct buf *);
void	vndshutdown(void);
void	vndgetdisklabel(dev_t, struct vnd_softc *);
void	vndencrypt(struct vnd_softc *, caddr_t, size_t, daddr_t, int);
d158 2
a159 2
int	vndlock(struct vnd_softc *);
void	vndunlock(struct vnd_softc *);
d986 1
a986 1
	extern int (**nfsv2_vnodeop_p)(void *);
@


1.23.8.5
log
@Sync the SMP branch with 3.3
@
text
@a412 1
		s = splbio();
a413 1
		splx(s);
a422 1
		s = splbio();
a423 1
		splx(s);
a428 1
		s = splbio();
a429 1
		splx(s);
a495 1
			s = splbio();
a496 1
			splx(s);
a583 1
			s = splbio();
a584 1
			splx(s);
d645 1
d647 1
a647 2
	splassert(IPL_BIO);

d681 1
d993 3
@


1.23.8.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.23.8.5 2003/03/28 00:38:10 niklas Exp $	*/
d305 1
a305 1
	strncpy(lp->d_typename, "vnd device", sizeof(lp->d_typename));
d307 1
a307 1
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
d432 1
a432 1
	    vnd->sc_dk.dk_cpulabel, 1) <= 0) {
a782 8
		bzero(vnd->sc_dev.dv_xname, sizeof(vnd->sc_dev.dv_xname));
		if (snprintf(vnd->sc_dev.dv_xname, sizeof(vnd->sc_dev.dv_xname),
		    "vnd%d", unit) >= sizeof(vnd->sc_dev.dv_xname)) {
			printf("VNDIOCSET: device name too long\n");
			vndunlock(vnd);
			return(ENXIO);
		}

d840 2
@


1.23.8.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.23.8.6 2003/05/13 19:34:56 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.23.8.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 2
a98 6
/*
 * vndunit is a bit weird.  have to reconstitute the dev_t for
 * DISKUNIT(), but with the minor masked off.
 */
#define	vndunit(x)	DISKUNIT(makedev(major(x), minor(x) & 0x7ff))
#define vndsimple(x)	(minor(x) & 0x800)
d760 1
a760 1
	error = suser(p, 0);
@


1.23.8.9
log
@Merge with the trunk
@
text
@d90 3
a92 3
#define	VDB_FOLLOW	0x01
#define	VDB_INIT	0x02
#define	VDB_IO		0x04
d95 1
a95 1
#define	b_cylin	b_resid
d102 2
a103 1
#define	vndsimple(x)	(minor(x) & 0x800)
d105 1
a105 4
/* same as MAKEDISKDEV, preserving the vndsimple() property */
#define	VNDLABELDEV(dev)	\
	makedev(major(dev), DISKMINOR(vndunit(dev), RAW_PART) | \
	    (vndsimple(dev) ? 0x800 : 0))
d114 1
a114 1
#define	putvndbuf(vbp)	\
d132 3
a134 3
#define	VNF_INITED	0x0002
#define	VNF_WANTED	0x0040
#define	VNF_LOCKED	0x0080
d138 2
a139 2
#define	VNF_BUSY	0x0800
#define	VNF_SIMPLE	0x1000
d163 5
a167 5
	struct vnd_softc *vnd;
	caddr_t addr;
	size_t size;
	daddr_t off;
	int encrypt;
d171 1
a171 1

d481 2
a482 1
					   bp->b_bcount, bp->b_blkno, 0);
d486 2
a487 1
					   bp->b_bcount, bp->b_blkno, 1);
d494 2
a495 1
					   bp->b_bcount, bp->b_blkno, 0);
d525 1
a525 1
	bsize = vnd->sc_vp->v_mount->mnt_stat.f_iosize;
d553 1
a553 1
			    vnd->sc_vp, vp, bn, nbn, sz);
d654 1
d676 1
a676 8
	if (vnd->sc_tab.b_active) {
		disk_unbusy(&vnd->sc_dk, (pbp->b_bcount - pbp->b_resid),
		    (pbp->b_flags & B_READ));
		if (vnd->sc_tab.b_actf)
			vndstart(vnd);
		else
			vnd->sc_tab.b_active--;
	}
d684 7
a690 1

d818 2
a819 2
		if (vio->vnd_keylen > 0) {
			char key[128];
d821 3
a823 5
			if (vio->vnd_keylen > sizeof(key))
				vio->vnd_keylen = sizeof(key);

			if ((error = copyin(vio->vnd_key, key,
			    vio->vnd_keylen)) != 0) {
d825 1
a825 1
				    p->p_ucred, p);
d831 1
a831 1
			    M_WAITOK);
d834 1
d837 1
a837 1

d843 2
a844 2
			printf("vndioctl: SET vp %p size %llx\n",
			    vnd->sc_vp, (unsigned long long)vnd->sc_size);
d885 2
a886 2
			bzero(vnd->sc_keyctx, sizeof(*vnd->sc_keyctx));
			free(vnd->sc_keyctx, M_DEVBUF);
d977 1
a977 1
	aiov.iov_len = MIN(DEV_BSIZE, dbtob((off_t)vnd->sc_size));
@


1.22
log
@make b_resid size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.21 1998/03/10 17:40:37 millert Exp $	*/
d297 1
a297 1
	    sc->sc_dk.dk_cpulabel);
@


1.21
log
@Clear dependcy list so we don't panic a soft updates kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.20 1997/11/06 05:58:08 csapuntz Exp $	*/
d367 1
a367 1
	register int bn, bsize, resid;
d369 1
@


1.20
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.19 1997/10/18 10:37:04 deraadt Exp $	*/
d523 1
@


1.19
log
@avoid "no disklabel" error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.18 1997/10/06 20:19:40 deraadt Exp $	*/
d372 1
d435 1
a435 1
			VOP_LOCK(vnd->sc_vp);
d447 1
a447 1
			VOP_UNLOCK(vnd->sc_vp);
d481 1
a481 1
		VOP_LOCK(vnd->sc_vp);
d483 1
a483 1
		VOP_UNLOCK(vnd->sc_vp);
d736 1
a736 1
			VOP_UNLOCK(nd.ni_vp);
d741 1
a741 1
		VOP_UNLOCK(nd.ni_vp);
d878 1
d892 1
a892 1
	VOP_LOCK(vnd->sc_vp);
d894 1
a894 1
	VOP_UNLOCK(vnd->sc_vp);
@


1.18
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.16 1997/08/08 21:47:01 niklas Exp $	*/
d299 1
a299 1
		printf("%s: %s\n", sc->sc_dev.dv_xname, errstring);
@


1.17
log
@VFS Lite2 Changes
@
text
@a371 1
	struct proc *p = curproc;
d434 1
a434 1
			vn_lock(vnd->sc_vp, LK_EXCLUSIVE | LK_RETRY, p);
d446 1
a446 1
			VOP_UNLOCK(vnd->sc_vp, 0, p);
d480 1
a480 1
		vn_lock(vnd->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);
d482 1
a482 1
		VOP_UNLOCK(vnd->sc_vp, 0, p);
d735 1
a735 1
			VOP_UNLOCK(nd.ni_vp, 0, p);
d740 1
a740 1
		VOP_UNLOCK(nd.ni_vp, 0, p);
a876 1
	struct proc *p = curproc;
d890 1
a890 1
	vn_lock(vnd->sc_vp, LK_RETRY | LK_EXCLUSIVE, p);
d892 1
a892 1
	VOP_UNLOCK(vnd->sc_vp, 0, p);
@


1.16
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.15 1997/06/09 09:41:08 deraadt Exp $	*/
d372 1
d435 1
a435 1
			VOP_LOCK(vnd->sc_vp);
d447 1
a447 1
			VOP_UNLOCK(vnd->sc_vp);
d481 1
a481 1
		VOP_LOCK(vnd->sc_vp);
d483 1
a483 1
		VOP_UNLOCK(vnd->sc_vp);
d736 1
a736 1
			VOP_UNLOCK(nd.ni_vp);
d741 1
a741 1
		VOP_UNLOCK(nd.ni_vp);
d878 1
d892 1
a892 1
	VOP_LOCK(vnd->sc_vp);
d894 1
a894 1
	VOP_UNLOCK(vnd->sc_vp);
@


1.15
log
@zone and constrain according to disklabel partition slots; part by gson@@araneus.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.14 1997/06/08 17:38:29 deraadt Exp $	*/
d394 2
a395 1
	    bounds_check_with_label(bp, vnd->sc_dk.dk_label, 1) == 0) {
@


1.14
log
@init d_secperunit nicely
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.13 1997/05/18 13:00:12 deraadt Exp $	*/
d387 8
a394 5
	if (bn < 0 || bn + sz > vnd->sc_size) {
		if (bn != vnd->sc_size) {
			bp->b_error = EINVAL;
			bp->b_flags |= B_ERROR;
		}
d422 3
d429 1
a429 1
			auio.uio_offset = dbtob(bp->b_blkno);
d468 1
@


1.13
log
@null uio_procp
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.12 1997/05/17 20:09:46 millert Exp $	*/
d268 1
a268 1
	lp->d_ncylinders = 100;
d278 1
a278 1
	lp->d_secperunit = 100 * 100;
@


1.12
log
@Make comment reflect reality and fix a typo
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.11 1997/05/17 19:48:38 deraadt Exp $	*/
d425 1
a425 8

			/*
			 * It seems we can get NULL proc pointers in bp->b_proc
			 * that causes a quota check in VOP_WRITE to fault.
			 * In that case chalk it up on curproc instead, for
			 * safety.
			 */
			auio.uio_procp = (bp->b_proc ? bp->b_proc : curproc);
@


1.11
log
@&proc0 should never be used
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.10 1997/05/16 19:11:34 niklas Exp $	*/
d429 1
a429 1
			 * In that case cahalk it up on proc0 instead, for
@


1.10
log
@Some buffers have NULL in b_proc when passed to vndstrategy,
however ffs_write needs a proc pointer in the uio structure, so fill in
&proc0 to avoid a NULL deref
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.9 1997/05/14 15:32:46 niklas Exp $	*/
d432 1
a432 1
			auio.uio_procp = (bp->b_proc ? bp->b_proc : &proc0);
@


1.9
log
@Add a new mode of operation: "safe" vnd, aka svnd, which goes
through the buffercache thus maintaining cache-coherency after unmount of
a mounted vnd.  This is good for diskimage creation, you should still use
the old vnds for swapping on, though
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.8 1997/01/04 08:50:22 deraadt Exp $	*/
d425 8
a432 1
			auio.uio_procp = bp->b_proc;
@


1.8
log
@readdisklabel() with correct dev_t
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.7 1996/12/21 05:21:13 deraadt Exp $	*/
d52 5
a56 3
 * NOTE 1: This uses the VOP_BMAP/VOP_STRATEGY interface to the vnode
 * instead of a simple VOP_RDWR.  We do this to avoid distorting the
 * local buffer cache.
d99 2
a100 1
#define	vndunit(x)	DISKUNIT(x)
d116 2
a117 2
	struct device	sc_dev;
	struct disk	sc_dk;
d128 9
a136 7
#define	VNF_ALIVE	0x001
#define VNF_INITED	0x002
#define VNF_WANTED	0x040
#define VNF_LOCKED	0x080
#define	VNF_LABELLING	0x100
#define	VNF_WLABEL	0x200
#define	VNF_HAVELABEL	0x100
d198 2
a199 1
	if ((sc->sc_flags & VNF_INITED) && (sc->sc_flags & VNF_HAVELABEL) == 0) {
d205 16
a220 1
	pmask = (1 << part);
d346 4
d353 6
d369 3
a371 1
	int sz, flags, error;
d383 1
d395 67
@


1.7
log
@add disklabel support
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.6 1996/04/21 22:19:59 deraadt Exp $	*/
d98 3
d147 1
a147 1
void	vndgetdisklabel __P((struct vnd_softc *));
d195 1
a195 1
		vndgetdisklabel(sc);
d234 2
a235 1
vndgetdisklabel(sc)
d275 2
a276 2
	errstring = readdisklabel(MAKEDISKDEV(0, sc->sc_dev.dv_unit, RAW_PART),
				  vndstrategy, lp, sc->sc_dk.dk_cpulabel);
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: vnd.c,v 1.5 1996/03/02 00:29:25 niklas Exp $	*/
d110 3
a118 2
	char		 sc_xname[8];	/* XXX external name */
	struct disk	 sc_dkdev;	/* generic disk device info */
d122 7
a128 4
#define	VNF_ALIVE	0x01
#define VNF_INITED	0x02
#define VNF_WANTED	0x40
#define VNF_LOCKED	0x80
d133 2
d144 1
a178 4
	/*
	 * XXX Should support disklabels.
	 */

d190 5
d198 9
d210 1
a210 1
		sc->sc_dkdev.dk_copenmask |= pmask;
d214 1
a214 1
		sc->sc_dkdev.dk_bopenmask |= pmask;
d217 2
a218 2
	sc->sc_dkdev.dk_openmask =
	    sc->sc_dkdev.dk_copenmask | sc->sc_dkdev.dk_bopenmask;
d222 55
d306 1
a306 1
		sc->sc_dkdev.dk_copenmask &= ~(1 << part);
d310 1
a310 1
		sc->sc_dkdev.dk_bopenmask &= ~(1 << part);
d313 2
a314 2
	sc->sc_dkdev.dk_openmask =
	    sc->sc_dkdev.dk_copenmask | sc->sc_dkdev.dk_bopenmask;
d471 1
a471 1
	disk_busy(&vnd->sc_dkdev);
d506 1
a506 1
	disk_unbusy(&vnd->sc_dkdev, (pbp->b_bcount - pbp->b_resid));
d573 1
a573 1
vndioctl(dev, cmd, data, flag, p)
d576 1
a576 1
	caddr_t data;
d590 1
a590 1
		    dev, cmd, data, flag, p, unit);
d599 1
a599 1
	vio = (struct vnd_ioctl *)data;
d645 6
a650 4
		bzero(vnd->sc_xname, sizeof(vnd->sc_xname));	/* XXX */
		sprintf(vnd->sc_xname, "vnd%d", unit);		/* XXX */
		vnd->sc_dkdev.dk_name = vnd->sc_xname;
		disk_attach(&vnd->sc_dkdev);
d670 3
a672 3
		if ((vnd->sc_dkdev.dk_openmask & ~pmask) ||
		    ((vnd->sc_dkdev.dk_bopenmask & pmask) &&
		    (vnd->sc_dkdev.dk_copenmask & pmask))) {
d684 1
a684 1
		disk_detach(&vnd->sc_dkdev);
d691 22
d714 18
a731 1
		break;
d733 8
a740 3
	/*
	 * XXX Should support disklabels.
	 */
@


1.5
log
@From NetBSD: sync with 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: vnd.c,v 1.24 1996/02/10 00:11:44 christos Exp $	*/
a76 1
#include <sys/conf.h>
d81 1
a128 4
/* {b,c}devsw[] function prototypes XXX: move them to dev_conf.h */
bdev_decl(vnd);
cdev_decl(vnd);

d393 1
a393 1
		printf("vndstart(%d): bp %p vp %p blkno %x addr %p cnt %x\n",
d418 1
a418 1
		printf("vndiodone(%d): vbp %p vp %p blkno %x addr %p cnt %x\n",
@


1.4
log
@From NetBSD: update to 960217 sources
@
text
@@


1.3
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 2
a2 1
/*	$NetBSD: vnd.c,v 1.23 1996/01/07 22:03:33 thorpej Exp $	*/
d129 3
a131 7
/* {b,c}devsw[] function prototypes */
dev_type_open(vndopen);
dev_type_close(vndclose);
dev_type_strategy(vndstrategy);
dev_type_ioctl(vndioctl);
dev_type_read(vndread);
dev_type_write(vndwrite);
d140 2
d182 1
a182 1
		printf("vndopen(%x, %x, %x, %x)\n", dev, flags, mode, p);
d188 1
a188 1
	if (error = vndlock(sc))
d223 1
a223 1
		printf("vndclose(%x, %x, %x, %x)\n", dev, flags, mode, p);
d230 1
a230 1
	if (error = vndlock(sc))
a266 1
	extern void vndiodone();
d270 1
a270 1
		printf("vndstrategy(%x): unit %d\n", bp, unit);
d309 1
a309 1
		if (off = bn % bsize)
d317 1
a317 1
			printf("vndstrategy: vp %x/%x bn %x/%x sz %x\n",
d397 1
a397 1
		printf("vndstart(%d): bp %x vp %x blkno %x addr %x cnt %x\n",
d411 2
a412 2
vndiodone(vbp)
	register struct vndbuf *vbp;
d414 1
d422 1
a422 1
		printf("vndiodone(%d): vbp %x vp %x blkno %x addr %x cnt %x\n",
d430 1
a430 1
			printf("vndiodone: vbp %x error %d\n", vbp,
d442 1
a442 1
			printf("vndiodone: pbp %x iodone\n", pbp);
d465 1
a465 1
		printf("vndread(%x, %x)\n", dev, uio);
d490 1
a490 1
		printf("vndwrite(%x, %x)\n", dev, uio);
d521 1
a521 1
		printf("vndioctl(%x, %lx, %x, %x, %x): unit %d\n",
d538 1
a538 1
		if (error = vndlock(vnd))
d548 1
a548 1
		if (error = vn_open(&nd, FREAD|FWRITE, 0)) {
d552 2
a553 1
		if (error = VOP_GETATTR(nd.ni_vp, &vattr, p->p_ucred, p)) {
d562 1
a562 1
		if (error = vndsetcred(vnd, p->p_ucred)) {
d572 1
a572 1
			printf("vndioctl: SET vp %x size %x\n",
d590 1
a590 1
		if (error = vndlock(vnd))
d614 1
a614 1
		disk_detatch(&vnd->sc_dkdev);
d680 1
a680 1
	extern int (**nfsv2_vnodeop_p)();
d711 1
a711 1
		printf("vndclear(%x): vp %x\n", vp);
@


1.2
log
@from netbsd:
Bring in several changes from the ccd:
        * Be a bit better with prototypes
        * Use struct dkdevice in vnd_softc.
        * Prevent the unit from being unconfigured while open.
        * Implement a simple locking mechanism and use it for sanity's
          sake.
Still needs more work; needs to support disklabels and the like.
@
text
@d1 1
a1 1
/*	$NetBSD: vnd.c,v 1.22 1995/11/06 20:28:09 thorpej Exp $	*/
a68 1
#include <sys/dkstat.h>
d115 2
a116 1
	struct dkdevice  sc_dkdev;	/* generic disk device info */
d403 4
d427 1
d439 1
d576 6
d612 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vnd.c,v 1.21 1995/10/05 06:20:57 mycroft Exp $	*/
a62 2
#include "vnd.h"
#if NVND > 0
d74 4
d116 1
d122 2
a124 4
#if 0	/* if you need static allocation */
struct vnd_softc vn_softc[NVND];
int numvnd = NVND;
#else
d126 12
a137 2
int numvnd;
#endif
d144 3
d174 6
d186 24
a209 2
		return(ENXIO);
	return(0);
d218 4
d226 25
a250 1
	return 0;
d448 1
d450 1
a450 1
vndread(dev, uio)
d453 1
d455 2
d462 8
d473 1
d475 1
a475 1
vndwrite(dev, uio)
d478 1
d480 2
d487 8
d512 1
a512 1
	int error;
d531 5
a535 1
			return(EBUSY);
d543 2
a544 1
		if (error = vn_open(&nd, FREAD|FWRITE, 0))
d546 1
d550 1
d558 1
d569 3
d576 19
a594 1
			return(ENXIO);
d600 7
d609 4
d616 2
a617 1
	return(0);
d731 36
a766 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

