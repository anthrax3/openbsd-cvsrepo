head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.48
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.38
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.46
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.44
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.42
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.40
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.36
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.34
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.32
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.30
	OPENBSD_5_0:1.4.0.28
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.26
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.24
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.20
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.22
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.18
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.16
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.8
	OPENBSD_3_4_BASE:1.2
	UBC:1.2.0.6
	UBC_SYNC_A:1.2
	SMP:1.2.0.4
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.4
date	2005.01.09.23.49.36;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.20.22.53.56;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.26.20.22.04;	author miod;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2003.02.15.23.50.02;	author miod;	state Exp;
branches;
next	;

1.2.4.1
date	2004.02.19.10.56.15;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Allow send_hil{,dev}_cmd to return failure, and handle this where
applicable.

During device probe, if a device does not answer commands, display a warning
message. This apparently happens on hp300 when the console is configured
as remote (i.e. serial console). Unplugging and replugging the device works
fine afterwards...
@
text
@/*	$OpenBSD: hilid.c,v 1.3 2003/12/20 22:53:56 miod Exp $	*/
/*
 * Copyright (c) 2003, Miodrag Vallat.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/ioctl.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>

#include <dev/hil/hilreg.h>
#include <dev/hil/hilvar.h>
#include <dev/hil/hildevs.h>

struct hilid_softc {
	struct hildev_softc sc_hildev;

	u_int8_t	sc_id[16];
};

int	hilidprobe(struct device *, void *, void *);
void	hilidattach(struct device *, struct device *, void *);
int	hiliddetach(struct device *, int);

struct cfdriver hilid_cd = {
	NULL, "hilid", DV_DULL
};

struct cfattach hilid_ca = {
	sizeof(struct hilid_softc), hilidprobe, hilidattach, hiliddetach,
};

int
hilidprobe(struct device *parent, void *match, void *aux)
{
	struct hil_attach_args *ha = aux;

	if (ha->ha_type != HIL_DEVICE_IDMODULE)
		return (0);

	return (1);
}

void
hilidattach(struct device *parent, struct device *self, void *aux)
{
	struct hilid_softc *sc = (void *)self;
	struct hil_attach_args *ha = aux;
	u_int i, len;

	sc->hd_code = ha->ha_code;
	sc->hd_type = ha->ha_type;
	sc->hd_infolen = ha->ha_infolen;
	bcopy(ha->ha_info, sc->hd_info, ha->ha_infolen);
	sc->hd_fn = NULL;

	printf("\n");

	bzero(sc->sc_id, sizeof(sc->sc_id));
	len = sizeof(sc->sc_id);
	printf("%s: security code", self->dv_xname);

	if (send_hildev_cmd((struct hildev_softc *)sc,
	    HIL_SECURITY, sc->sc_id, &len) == 0) {
		for (i = 0; i < sizeof(sc->sc_id); i++)
			printf(" %02x", sc->sc_id[i]);
		printf("\n");
	} else
		printf(" unavailable\n");
}

int
hiliddetach(struct device *self, int flags)
{
	return (0);
}
@


1.3
log
@Relax a redundant printf format specifier.
@
text
@d1 1
a1 1
/*	$OpenBSD: hilid.c,v 1.2 2003/02/26 20:22:04 miod Exp $	*/
a87 3
	send_hildev_cmd((struct hildev_softc *)sc,
	    HIL_SECURITY, sc->sc_id, &len);

a88 2
	for (i = 0; i < sizeof(sc->sc_id); i++)
		printf(" %02x", sc->sc_id[i]);
d90 7
a96 1
	printf("\n");
@


1.2
log
@New hil child devices attachment framework, that allow them to be detached
at runtime.

Handle reconfiguration notices from the loop, and do the necessary
detach/attach work so that our vision of the loop is in sync with reality.

Adapt all hil child devices to the above changes.

"This is not as plug'n'play as usb, but you get the same feeling anyways..."
@
text
@d1 1
a1 1
/*	$OpenBSD: hilid.c,v 1.1 2003/02/15 23:50:02 miod Exp $	*/
d93 1
a93 1
		printf(" %02.2x", sc->sc_id[i]);
@


1.2.4.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 1
a93 1
		printf(" %02x", sc->sc_id[i]);
@


1.1
log
@A simple and crude driver to play with the hil so-called ``ID module''
devices.

The ID module only purpose is to provide a small, unique, bitstring, which
was used for some copy-protection or licensing scheme under HP-UX.

Right now this driver is useless, as it provides no way to communicate
this information to userland, and only displays it while attaching, as such:
hilid0 at hil0 code 2: ID module
hilid0: security code 10 04 b4 41 ac 77 14 0f 41 00 00 00 00 00 00 00
hilid1 at hil0 code 3: ID module
hilid1: security code 10 04 b4 41 e3 b8 13 0f 41 00 00 00 00 00 00 00

Too bad it's not even good enough to feed the kernel random generator...
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
	struct device	sc_dev;
d50 1
d57 1
a57 1
	sizeof(struct hilid_softc), hilidprobe, hilidattach
d78 6
d88 1
a88 1
	send_hildev_cmd((struct hil_softc *)parent, ha->ha_code,
d91 1
a91 1
	printf("%s: security code", sc->sc_dev.dv_xname);
d96 6
@

