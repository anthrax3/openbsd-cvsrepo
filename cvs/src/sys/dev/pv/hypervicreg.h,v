head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.6
date	2016.11.07.16.49.42;	author mikeb;	state Exp;
branches;
next	1.5;
commitid	LE5BuZkjeSPpogsx;

1.5
date	2016.11.03.18.34.37;	author mikeb;	state Exp;
branches;
next	1.4;
commitid	4LLcBSZbIwL2zck6;

1.4
date	2016.11.03.12.56.02;	author mikeb;	state Exp;
branches;
next	1.3;
commitid	rkgL0JLF6ztmxNns;

1.3
date	2016.10.25.19.36.11;	author mikeb;	state Exp;
branches;
next	1.2;
commitid	tujUilLvS05dLN8J;

1.2
date	2016.10.12.16.23.35;	author mikeb;	state Exp;
branches;
next	1.1;
commitid	3tNzzGKXHGFXBdup;

1.1
date	2016.10.11.11.46.49;	author mikeb;	state Exp;
branches;
next	;
commitid	EdcKmtCuROaO2Xuz;


desc
@@


1.6
log
@Handle IP address information requests

This adds the last required bit of the KVP interface: providing
IP address info back to the Host on request.  Normally the Host
is not specifying the address family and in this case we prefer
to report back the first IPv4 address we can find and resort to
IPv6 only when no IPv4 addresses are configured.

It also appears that the 5th version of the message format is
not publicly documented yet and IP address information request
messages differ from the 4th version so we have to take the
negotiated protocol version down a notch.
@
text
@/*-
 * Copyright (c) 2016 Microsoft Corp.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: head/sys/dev/hyperv/utilities/vmbus_icreg.h 305281 2016-09-02 06:23:28Z sephe $
 */

#ifndef _DEV_PV_HYPERVIC_H_
#define _DEV_PV_HYPERVIC_H_

#define VMBUS_IC_BUFRINGSIZE		(4 * PAGE_SIZE)

#define VMBUS_ICMSG_TYPE_NEGOTIATE	0
#define VMBUS_ICMSG_TYPE_HEARTBEAT	1
#define VMBUS_ICMSG_TYPE_KVP		2
#define VMBUS_ICMSG_TYPE_SHUTDOWN	3
#define VMBUS_ICMSG_TYPE_TIMESYNC	4
#define VMBUS_ICMSG_TYPE_VSS		5

#define VMBUS_ICMSG_STATUS_OK		0x00000000
#define VMBUS_ICMSG_STATUS_FAIL		0x80004005

#define VMBUS_ICMSG_FLAG_TRANSACTION	1
#define VMBUS_ICMSG_FLAG_REQUEST	2
#define VMBUS_ICMSG_FLAG_RESPONSE	4

#define VMBUS_IC_VERSION(major, minor)	((major) | (((uint32_t)(minor)) << 16))
#define VMBUS_ICVER_MAJOR(ver)		((ver) & 0xffff)
#define VMBUS_ICVER_MINOR(ver)		(((ver) & 0xffff0000) >> 16)

struct vmbus_pipe_hdr {
	uint32_t		ph_flags;
	uint32_t		ph_msgsz;
} __packed;

struct vmbus_icmsg_hdr {
	struct vmbus_pipe_hdr	ic_pipe;
	uint32_t		ic_fwver;	/* framework version */
	uint16_t		ic_type;
	uint32_t		ic_msgver;	/* message version */
	uint16_t		ic_dsize;	/* data size */
	uint32_t		ic_status;	/* VMBUS_ICMSG_STATUS_ */
	uint8_t			ic_tid;
	uint8_t			ic_flags;	/* VMBUS_ICMSG_FLAG_ */
	uint8_t			ic_rsvd[2];
} __packed;

/* VMBUS_ICMSG_TYPE_NEGOTIATE */
struct vmbus_icmsg_negotiate {
	struct vmbus_icmsg_hdr	ic_hdr;
	uint16_t		ic_fwver_cnt;
	uint16_t		ic_msgver_cnt;
	uint32_t		ic_rsvd;
	/*
	 * This version array contains two set of supported
	 * versions:
	 * - The first set consists of #ic_fwver_cnt supported framework
	 *   versions.
	 * - The second set consists of #ic_msgver_cnt supported message
	 *   versions.
	 */
	uint32_t		ic_ver[0];
} __packed;

/* VMBUS_ICMSG_TYPE_HEARTBEAT */
struct vmbus_icmsg_heartbeat {
	struct vmbus_icmsg_hdr	ic_hdr;
	uint64_t		ic_seq;
	uint32_t		ic_rsvd[8];
} __packed;

/* VMBUS_ICMSG_TYPE_SHUTDOWN */
struct vmbus_icmsg_shutdown {
	struct vmbus_icmsg_hdr	ic_hdr;
	uint32_t		ic_code;
	uint32_t		ic_timeo;
	uint32_t 		ic_haltflags;
	uint8_t			ic_msg[2048];
} __packed;

/* VMBUS_ICMSG_TYPE_TIMESYNC */
struct vmbus_icmsg_timesync {
	struct vmbus_icmsg_hdr	ic_hdr;
	uint64_t		ic_hvtime;
	uint64_t		ic_vmtime;
	uint64_t		ic_rtt;
	uint8_t			ic_tsflags;	/* VMBUS_ICMSG_TS_FLAG_ */
} __packed;

#define VMBUS_ICMSG_TS_FLAG_SYNC	0x01
#define VMBUS_ICMSG_TS_FLAG_SAMPLE	0x02

/* Registry value types */
#define HV_KVP_REG_SZ			1
#define HV_KVP_REG_U32			4
#define HV_KVP_REG_U64			8

/* Hyper-V status codes */
#define HV_KVP_S_OK			0x00000000
#define HV_KVP_E_FAIL			0x80004005
#define HV_KVP_S_CONT			0x80070103

#define HV_KVP_MAX_VAL_SIZE		2048
#define HV_KVP_MAX_KEY_SIZE		512

enum hv_kvp_op {
	HV_KVP_OP_GET = 0,
	HV_KVP_OP_SET,
	HV_KVP_OP_DELETE,
	HV_KVP_OP_ENUMERATE,
	HV_KVP_OP_GET_IP_INFO,
	HV_KVP_OP_SET_IP_INFO,
	HV_KVP_OP_COUNT
};

enum hv_kvp_pool {
	HV_KVP_POOL_EXTERNAL = 0,
	HV_KVP_POOL_GUEST,
	HV_KVP_POOL_AUTO,
	HV_KVP_POOL_AUTO_EXTERNAL,
	HV_KVP_POOL_COUNT
};

union hv_kvp_hdr {
	struct {
		uint8_t		kvu_op;
		uint8_t		kvu_pool;
		uint16_t	kvu_pad;
	} req;
	struct {
		uint32_t	kvu_err;
	} rsp;
#define kvh_op			req.kvu_op
#define kvh_pool		req.kvu_pool
#define kvh_err			rsp.kvu_err
} __packed;

struct hv_kvp_msg_val {
	uint32_t		kvm_valtype;
	uint32_t		kvm_keylen;
	uint32_t		kvm_vallen;
	uint8_t			kvm_key[HV_KVP_MAX_KEY_SIZE];
	uint8_t			kvm_val[HV_KVP_MAX_VAL_SIZE];
} __packed;

struct hv_kvp_msg_enum {
	uint32_t		kvm_index;
	uint32_t		kvm_valtype;
	uint32_t		kvm_keylen;
	uint32_t		kvm_vallen;
	uint8_t			kvm_key[HV_KVP_MAX_KEY_SIZE];
	uint8_t			kvm_val[HV_KVP_MAX_VAL_SIZE];
} __packed;

struct hv_kvp_msg_del {
	uint32_t		kvm_keylen;
	uint8_t			kvm_key[HV_KVP_MAX_KEY_SIZE];
} __packed;

#define ADDR_FAMILY_NONE	0x00
#define ADDR_FAMILY_IPV4	0x01
#define ADDR_FAMILY_IPV6	0x02

#define MAX_MAC_ADDR_SIZE	256
#define MAX_IP_ADDR_SIZE	2048
#define MAX_GATEWAY_SIZE	1024

struct hv_kvp_msg_addr {
	uint8_t			kvm_mac[MAX_MAC_ADDR_SIZE];
	uint8_t			kvm_family;
	uint8_t			kvm_dhcp;
	uint8_t			kvm_addr[MAX_IP_ADDR_SIZE];
	uint8_t			kvm_netmask[MAX_IP_ADDR_SIZE];
	uint8_t			kvm_gateway[MAX_GATEWAY_SIZE];
	uint8_t			kvm_dns[MAX_IP_ADDR_SIZE];
} __packed;

union hv_kvp_msg {
	struct hv_kvp_msg_val	kvm_val;
	struct hv_kvp_msg_enum	kvm_enum;
	struct hv_kvp_msg_del	kvm_del;
};

struct vmbus_icmsg_kvp {
	struct vmbus_icmsg_hdr	ic_hdr;
	union hv_kvp_hdr	ic_kvh;
	union hv_kvp_msg	ic_kvm;
} __packed;

struct vmbus_icmsg_kvp_addr {
	struct vmbus_icmsg_hdr	ic_hdr;
	struct {
		struct {
			uint8_t	kvu_op;
			uint8_t	kvu_pool;
		} req;
	}			ic_kvh;
	struct hv_kvp_msg_addr	ic_kvm;
} __packed;

#endif	/* _DEV_PV_HYPERVIC_H_ */
@


1.5
log
@Support for key removal and value update operations

This change makes it possible for the Host to update the value
of an existing key via a Set operation as well as to remove the
key completely with a Delete message.
@
text
@d181 8
d190 1
a190 1
	uint16_t		kvm_mac[128];
a191 3
#define ADDR_FAMILY_NONE	 0x00
#define ADDR_FAMILY_IPV4	 0x01
#define ADDR_FAMILY_IPV6	 0x02
d193 4
a196 4
	uint16_t		kvm_addr[1024];
	uint16_t		kvm_net[1024];
	uint16_t		kvm_gw[512];
	uint16_t		kvm_dns[1024];
a202 1
	struct hv_kvp_msg_addr	kvm_addr;
d209 11
@


1.4
log
@Implement a Key-Value Pair exchange interface

The implemented abstraction allows us to query and set little
endian UTF-16 keys exchanged between the Host and the Guest via
a text based pvbus(4) interface.

All keys are attached to one of several key pools: Auto, Guest,
External or Guest/Parameters.  The hostctl(8) is able to modify
values for keys in the Auto pool as well as set new keys in the
Guest pool while the Host provides its keys in External and
Guest/Parameters pools.

Discussed with reyk@@
@
text
@d176 5
d197 1
@


1.3
log
@Channel API users should pick the bufring size

hvn(4) needs to be able to put up to 128 RNDIS data messages on the
channel ring each pointing up to 16 fragments in addition to a small
number of RNDIS control messages.  This simplifies accounting of
available TX descriptors in relation to the available space on the
channel ring and as a results prevents packet drops due to the ring
being full.
@
text
@d114 87
@


1.2
log
@Get rid of the ch_buf member that is not part of the channel API

Devices need to allocate appropriate input/output buffers for use
with the VMBus channel API themselves.  There's no reason to keep
pointers to these buffers in the channel structure.

This requires a bit of restructuring of the code attaching internal
devices however.
@
text
@d32 1
a32 1
#define VMBUS_IC_BUFRINGSIZE		PAGE_SIZE
@


1.1
log
@Move Hyper-V integration components into a separate source file

Input & OK reyk.
@
text
@d32 2
@

