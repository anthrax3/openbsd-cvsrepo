head	1.50;
access;
symbols
	OPENBSD_6_1:1.49.0.4
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.32.0.2
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29;
locks; strict;
comment	@ * @;


1.50
date	2017.07.14.19.09.52;	author mikeb;	state Exp;
branches;
next	1.49;
commitid	HOzKysZJg74DQ6ei;

1.49
date	2017.02.08.16.15.52;	author mikeb;	state Exp;
branches;
next	1.48;
commitid	gxSiomnJZTQK4vmq;

1.48
date	2017.02.06.21.58.29;	author mikeb;	state Exp;
branches;
next	1.47;
commitid	pnXIcMYhxO5V6vfF;

1.47
date	2017.02.06.21.52.02;	author mikeb;	state Exp;
branches;
next	1.46;
commitid	uLYJdmDVwCLofDEA;

1.46
date	2017.02.06.21.43.48;	author mikeb;	state Exp;
branches;
next	1.45;
commitid	NscjkKs6gyrHx1os;

1.45
date	2016.12.21.12.17.15;	author mikeb;	state Exp;
branches;
next	1.44;
commitid	UjXSBCfwZeftHnab;

1.44
date	2016.12.19.21.07.10;	author mikeb;	state Exp;
branches;
next	1.43;
commitid	Y4USgZxawPwLIGuG;

1.43
date	2016.12.09.17.24.55;	author mikeb;	state Exp;
branches;
next	1.42;
commitid	JcAbCgH7EdZVJZid;

1.42
date	2016.12.07.15.21.04;	author mikeb;	state Exp;
branches;
next	1.41;
commitid	AMLEifex6cUtuqNv;

1.41
date	2016.11.29.14.55.04;	author mikeb;	state Exp;
branches;
next	1.40;
commitid	tsMjTSHgEUUjCy08;

1.40
date	2016.11.29.13.55.33;	author mikeb;	state Exp;
branches;
next	1.39;
commitid	wUluX7TJ50t0yQ2U;

1.39
date	2016.10.06.17.00.25;	author mikeb;	state Exp;
branches;
next	1.38;
commitid	ZeSFkAmBHZTZgeoK;

1.38
date	2016.09.14.17.48.28;	author mikeb;	state Exp;
branches;
next	1.37;
commitid	3NQfXZDgsR52I33J;

1.37
date	2016.09.12.17.22.45;	author mikeb;	state Exp;
branches;
next	1.36;
commitid	X9qrKshOXVVM8uwX;

1.36
date	2016.08.17.17.18.38;	author mikeb;	state Exp;
branches;
next	1.35;
commitid	LrewzMGAAlhEne3g;

1.35
date	2016.08.03.17.14.41;	author mikeb;	state Exp;
branches;
next	1.34;
commitid	eQJxVHPRM6vI49O4;

1.34
date	2016.08.03.14.55.58;	author mikeb;	state Exp;
branches;
next	1.33;
commitid	YaeDVNUrMnvb9jV0;

1.33
date	2016.07.29.21.27.43;	author mikeb;	state Exp;
branches;
next	1.32;
commitid	qkYps3xdNFEayvHI;

1.32
date	2016.04.19.18.15.41;	author mikeb;	state Exp;
branches;
next	1.31;
commitid	3qNUUD4LouZDwEm4;

1.31
date	2016.04.19.13.55.19;	author mikeb;	state Exp;
branches;
next	1.30;
commitid	HxzkQ2JvETeHrLDy;

1.30
date	2016.04.19.12.39.31;	author mikeb;	state Exp;
branches;
next	1.29;
commitid	2egN98MvwADkTMbn;

1.29
date	2016.02.02.17.52.46;	author mikeb;	state Exp;
branches;
next	1.28;
commitid	9CqV2Pl3GitdAPFk;

1.28
date	2016.01.29.19.12.26;	author mikeb;	state Exp;
branches;
next	1.27;
commitid	edb9DtZGGKTN3qVe;

1.27
date	2016.01.29.19.04.30;	author mikeb;	state Exp;
branches;
next	1.26;
commitid	JnL9q61QcwW3tbUG;

1.26
date	2016.01.29.18.49.06;	author mikeb;	state Exp;
branches;
next	1.25;
commitid	Pre5L4C8fKqWmy3c;

1.25
date	2016.01.27.15.34.50;	author mikeb;	state Exp;
branches;
next	1.24;
commitid	apVoOQpQMj6Kzcxm;

1.24
date	2016.01.27.09.04.19;	author reyk;	state Exp;
branches;
next	1.23;
commitid	xjeRSSQ0SXSd3nFz;

1.23
date	2016.01.25.15.22.56;	author mikeb;	state Exp;
branches;
next	1.22;
commitid	fNd5qUc1O1ALVnQH;

1.22
date	2016.01.18.19.06.48;	author mikeb;	state Exp;
branches;
next	1.21;
commitid	Q6j68J9KFjTHDuDD;

1.21
date	2016.01.15.18.20.41;	author mikeb;	state Exp;
branches;
next	1.20;
commitid	iowr1UutJmouij7D;

1.20
date	2016.01.15.14.27.08;	author mikeb;	state Exp;
branches;
next	1.19;
commitid	dQDkEWTtzV0PvUhk;

1.19
date	2016.01.05.13.47.28;	author mikeb;	state Exp;
branches;
next	1.18;
commitid	nA7maMH5lF997jfw;

1.18
date	2016.01.04.16.05.43;	author mikeb;	state Exp;
branches;
next	1.17;
commitid	gST5qrnvalmZGhHz;

1.17
date	2015.12.22.22.19.46;	author mikeb;	state Exp;
branches;
next	1.16;
commitid	JtwCqhB3iy6hPLQv;

1.16
date	2015.12.22.22.16.53;	author mikeb;	state Exp;
branches;
next	1.15;
commitid	6HhBROM8QMXkOoyd;

1.15
date	2015.12.21.19.43.16;	author mikeb;	state Exp;
branches;
next	1.14;
commitid	MMVctmSuoodXjEmx;

1.14
date	2015.12.21.18.17.36;	author mikeb;	state Exp;
branches;
next	1.13;
commitid	iEb7l4w8l1M3rzzp;

1.13
date	2015.12.19.09.12.29;	author mikeb;	state Exp;
branches;
next	1.12;
commitid	eHm03WCGPUA4gBis;

1.12
date	2015.12.12.21.07.45;	author reyk;	state Exp;
branches;
next	1.11;
commitid	h86qK9FFdj1rQhW1;

1.11
date	2015.12.11.12.39.46;	author mikeb;	state Exp;
branches;
next	1.10;
commitid	870myquGU7uGt31P;

1.10
date	2015.12.09.14.20.53;	author mikeb;	state Exp;
branches;
next	1.9;
commitid	dvfqxtToBFhclEbT;

1.9
date	2015.12.09.14.20.06;	author mikeb;	state Exp;
branches;
next	1.8;
commitid	NhDER9bNMCkf94t4;

1.8
date	2015.12.09.01.24.06;	author mikeb;	state Exp;
branches;
next	1.7;
commitid	aBQTV958b1NgJ8BA;

1.7
date	2015.12.08.22.23.30;	author mikeb;	state Exp;
branches;
next	1.6;
commitid	UfaLQxXE4MAwWIqK;

1.6
date	2015.12.08.22.14.40;	author mikeb;	state Exp;
branches;
next	1.5;
commitid	TtYskjHMvQp6NRMk;

1.5
date	2015.12.08.20.33.30;	author mikeb;	state Exp;
branches;
next	1.4;
commitid	Z2250xyyYY3JunCq;

1.4
date	2015.12.08.20.07.04;	author mikeb;	state Exp;
branches;
next	1.3;
commitid	rfOMtvGygJd7etQG;

1.3
date	2015.12.08.19.29.22;	author mikeb;	state Exp;
branches;
next	1.2;

1.2
date	2015.12.08.19.17.00;	author mikeb;	state Exp;
branches;
next	1.1;

1.1
date	2015.12.08.18.46.25;	author mikeb;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Silence the interrupt source until the interrupt task has done its job

This small change significantly improves performance under load and halves
the number of received interrupts.
@
text
@/*	$OpenBSD: xenvar.h,v 1.49 2017/02/08 16:15:52 mikeb Exp $	*/

/*
 * Copyright (c) 2015 Mike Belopuhov
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _DEV_PV_XENVAR_H_
#define _DEV_PV_XENVAR_H_

static inline void
clear_bit(u_int b, volatile void *p)
{
	atomic_clearbits_int(((volatile u_int *)p) + (b >> 5), 1 << (b & 0x1f));
}

static inline void
set_bit(u_int b, volatile void *p)
{
	atomic_setbits_int(((volatile u_int *)p) + (b >> 5), 1 << (b & 0x1f));
}

static inline int
test_bit(u_int b, volatile void *p)
{
	return !!(((volatile u_int *)p)[b >> 5] & (1 << (b & 0x1f)));
}

#define XEN_MAX_NODE_LEN	64
#define XEN_MAX_BACKEND_LEN	128

struct xen_intsrc {
	SLIST_ENTRY(xen_intsrc)	 xi_entry;
	struct evcount		 xi_evcnt;
	evtchn_port_t		 xi_port;
	short			 xi_noclose;
	short			 xi_masked;
	struct refcnt		 xi_refcnt;
	struct task		 xi_task;
	struct taskq		*xi_taskq;
	void			(*xi_handler)(void *);
	void			*xi_ctx;
};

struct xen_gntent {
	grant_entry_t		*ge_table;
	grant_ref_t		 ge_start;
	short			 ge_reserved;
	short			 ge_next;
	short			 ge_free;
	struct mutex		 ge_lock;
};

struct xen_gntmap {
	grant_ref_t		 gm_ref;
	paddr_t			 gm_paddr;
};

struct xen_device {
	struct device		*dv_dev;
	char			 dv_unit[16];
	LIST_ENTRY(xen_device)	 dv_entry;
};
LIST_HEAD(xen_devices, xen_device);

struct xen_devlist {
	struct xen_softc	*dl_xen;
	char			 dl_node[XEN_MAX_NODE_LEN];
	struct task		 dl_task;
	struct xen_devices	 dl_devs;
	SLIST_ENTRY(xen_devlist) dl_entry;
};
SLIST_HEAD(xen_devlists, xen_devlist);

struct xen_softc {
	struct device		 sc_dev;
	uint32_t		 sc_base;
	void			*sc_hc;
	uint32_t		 sc_features;
#define  XENFEAT_CBVEC		(1<<8)

	struct shared_info	*sc_ipg;	/* HYPERVISOR_shared_info */

	uint32_t		 sc_flags;
#define  XSF_CBVEC		  0x0001

	uint32_t		 sc_unplug;

	uint64_t		 sc_irq;	/* IDT vector number */
	SLIST_HEAD(, xen_intsrc) sc_intrs;
	struct mutex		 sc_islck;

	struct xen_gntent	*sc_gnt;	/* grant table entries */
	struct mutex		 sc_gntlck;
	int			 sc_gntcnt;	/* number of allocated frames */
	int			 sc_gntmax;	/* number of allotted frames */

	/*
	 * Xenstore
	 */
	struct xs_softc		*sc_xs;		/* xenstore softc */
	struct task		 sc_ctltsk;	/* control task */
	struct xen_devlists	 sc_devlists;	/* device lists heads */
};

extern struct xen_softc		*xen_sc;

struct xen_attach_args {
	char			 xa_name[16];
	char			 xa_node[XEN_MAX_NODE_LEN];
	char			 xa_backend[XEN_MAX_BACKEND_LEN];
	int			 xa_domid;
	bus_dma_tag_t		 xa_dmat;
};

/*
 *  Hypercalls
 */
#define XC_MEMORY		12
#define XC_OEVTCHN		16
#define XC_VERSION		17
#define XC_GNTTAB		20
#define XC_EVTCHN		32
#define XC_HVM			34

int	xen_hypercall(struct xen_softc *, int, int, ...);
int	xen_hypercallv(struct xen_softc *, int, int, ulong *);

/*
 *  Interrupts
 */
typedef uint32_t xen_intr_handle_t;

void	xen_intr(void);
void	xen_intr_ack(void);
void	xen_intr_signal(xen_intr_handle_t);
void	xen_intr_schedule(xen_intr_handle_t);
void	xen_intr_barrier(xen_intr_handle_t);
int	xen_intr_establish(evtchn_port_t, xen_intr_handle_t *, int,
	    void (*)(void *), void *, char *);
int	xen_intr_disestablish(xen_intr_handle_t);
void	xen_intr_enable(void);
void	xen_intr_mask(xen_intr_handle_t);
int	xen_intr_unmask(xen_intr_handle_t);

/*
 * Miscellaneous
 */
#define XEN_UNPLUG_NIC		0x0001	/* disable emul. NICs */
#define XEN_UNPLUG_IDE		0x0002	/* disable emul. primary IDE */
#define XEN_UNPLUG_IDESEC	0x0004	/* disable emul. secondary IDE */

void	xen_unplug_emulated(void *, int);

/*
 *  XenStore
 */
#define XS_LIST			0x01
#define XS_READ			0x02
#define XS_WATCH		0x04
#define XS_TOPEN		0x06
#define XS_TCLOSE		0x07
#define XS_WRITE		0x0b
#define XS_RM			0x0d
#define XS_EVENT		0x0f
#define XS_ERROR		0x10
#define XS_MAX			0x16

struct xs_transaction {
	uint32_t		 xst_id;
	void			*xst_cookie;
};

int	xs_cmd(struct xs_transaction *, int, const char *, struct iovec **,
	    int *);
void	xs_resfree(struct xs_transaction *, struct iovec *, int);
int	xs_watch(void *, const char *, const char *, struct task *,
	    void (*)(void *), void *);
int	xs_getnum(void *, const char *, const char *, unsigned long long *);
int	xs_setnum(void *, const char *, const char *, unsigned long long);
int	xs_getprop(void *, const char *, const char *, char *, int);
int	xs_setprop(void *, const char *, const char *, char *, int);
int	xs_kvop(void *, int, char *, char *, size_t);

#define XEN_STATE_UNKNOWN	"0"
#define XEN_STATE_INITIALIZING	"1"
#define XEN_STATE_INITWAIT	"2"
#define XEN_STATE_INITIALIZED	"3"
#define XEN_STATE_CONNECTED	"4"
#define XEN_STATE_CLOSING	"5"
#define XEN_STATE_CLOSED	"6"
#define XEN_STATE_RECONFIGURING	"7"
#define XEN_STATE_RECONFIGURED	"8"

int	xs_await_transition(void *, const char *, const char *,
	    const char *, int);

#endif	/* _DEV_PV_XENVAR_H_ */
@


1.49
log
@Introduce Xen interrupt barriers

intr_barrier(9) is useful to make sure that after an interrupt is
masked, the interrupt handler for the device has finished executing
before proceeding with further device configuration.

However, since Xen interrupt handlers run in the thread context, we
need to make sure that they have finished as well.  By scheduling a
xen_barrier_task modelled after (or rather copied ;) ifq_barrier_task
we can ensure that the interrupt handler is no longer running.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.48 2017/02/06 21:58:29 mikeb Exp $	*/
d52 2
@


1.48
log
@Add proper locking for the interrupt source list

Now that we can attach and detach devices, we need to make sure we
can do so while interrupts are running.  Thankfully, in the meantime
the refcnt_init(9) API came around to help us out.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.47 2017/02/06 21:52:02 mikeb Exp $	*/
d147 1
@


1.47
log
@XST_POLL turned out to be pretty useless since it's only set when cold
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.46 2017/02/06 21:43:48 mikeb Exp $	*/
d49 1
d60 1
a60 1
	struct mutex		 ge_mtx;
d100 1
d103 1
a103 1
	struct mutex		 sc_gntmtx;
@


1.46
log
@Use separate compile time debug flags for xen, xnf and xbf
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.45 2016/12/21 12:17:15 mikeb Exp $	*/
a176 2
	uint32_t		 xst_flags;
#define XST_POLL		0x0001
@


1.45
log
@Remove the rwlock paranoia since we're under KERNEL_LOCK anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.44 2016/12/19 21:07:10 mikeb Exp $	*/
a20 8

/* #define XEN_DEBUG */

#ifdef XEN_DEBUG
#define DPRINTF(x...)		printf(x)
#else
#define DPRINTF(x...)
#endif
@


1.44
log
@Add experimental support for device hot-plugging

We're installing watches on all nodes under "device/" and re-scan
the subtree every time the watch is triggered looking for changes
in the output.  Tested with xnf(4) and xbf(4), helpful hints from
Roger Pau Monne, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.43 2016/12/09 17:24:55 mikeb Exp $	*/
a116 1

a117 1

a118 1
	struct rwlock		 sc_devlck;
d121 1
a121 1
extern struct xen_softc *xen_sc;
@


1.43
log
@New XenStore public API function to read numeric values

A need for a function to perform string to number conversion arose
when domain identifier needed to be read and converted to numerical
representation.  With xbf(4) the usage became broader as greater
values (such as the sector count) needed to be converted.  And as a
result another function was implemented to perform string to unsigned
long long conversion but unfortunately multiplication overflows were
not handled correctly.  This new version consolidates the code in
one place and exports a proper XenStore API function to get and set
numeric values.  The new atoull function borrows multiplication
overflow detection logic from the libc.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.42 2016/12/07 15:21:04 mikeb Exp $	*/
d48 3
d75 16
d119 3
a124 3

#define XEN_MAX_NODE_LEN	64
#define XEN_MAX_BACKEND_LEN	128
@


1.42
log
@Add a simple mechanism to poll for a change in the property value
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.41 2016/11/29 14:55:04 mikeb Exp $	*/
d179 2
@


1.41
log
@Stop exposing xen_softc to PV devices directly
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.40 2016/11/29 13:55:33 mikeb Exp $	*/
d30 18
a173 18
static __inline void
clear_bit(u_int b, volatile void *p)
{
	atomic_clearbits_int(((volatile u_int *)p) + (b >> 5), 1 << (b & 0x1f));
}

static __inline void
set_bit(u_int b, volatile void *p)
{
	atomic_setbits_int(((volatile u_int *)p) + (b >> 5), 1 << (b & 0x1f));
}

static __inline int
test_bit(u_int b, volatile void *p)
{
	return !!(((volatile u_int *)p)[b >> 5] & (1 << (b & 0x1f)));
}

d182 13
@


1.40
log
@Don't expose the xen_softc pointer in the XenStore transaction struct
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.39 2016/10/06 17:00:25 mikeb Exp $	*/
d64 3
a66 4
#define  XSF_CBVEC		 0x0001
#define  XSF_UNPLUG_NIC		 0x0002		/* disable emul. NICs */
#define  XSF_UNPLUG_IDE		 0x0004		/* disable emul. primary IDE */
#define  XSF_UNPLUG_IDESEC	 0x0008		/* disable emul. sec. IDE */
d86 3
a89 1
	void			*xa_parent;
d91 2
a92 2
	char			 xa_node[64];
	char			 xa_backend[128];
d127 9
d177 1
a177 1
int	xs_watch(struct xen_softc *, const char *, const char *, struct task *,
d179 2
a180 2
int	xs_getprop(struct xen_softc *, const char *, const char *, char *, int);
int	xs_setprop(struct xen_softc *, const char *, const char *, char *, int);
@


1.39
log
@Remove _ds_boundary abuse (again)

The logic behind this change is this: a single mbuf may reference
only a contiguous chunk of memory.  When this chunk crosses a page
boundary only the first part of it has a non-zero offset while all
other chunks start at the beginning of the page.

We take advantage of this fact and calculate the offset of a first
chunk as a simple "mtod(m, vaddr_t) & PAGE_MASK".
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.38 2016/09/14 17:48:28 mikeb Exp $	*/
d143 1
a143 1
	struct xs_softc		*xst_sc;
@


1.38
log
@Name include guard macros consistently within sys/dev/pv
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.37 2016/09/12 17:22:45 mikeb Exp $	*/
a94 9

/*
 * Grant table references don't convey the information about an actual
 * offset of the data within the page, however Xen needs to know it.
 * We (ab)use bus_dma_segment's _ds_boundary member to store it.  Please
 * note that we don't save or restore it's original value atm because
 * neither i386 nor amd64 bus_dmamap_unload(9) code needs it.
 */
#define ds_offset		 _ds_boundary
@


1.37
log
@Bring back the code that cached DMA fragment offset.

It's required to handle mbuf fragments spanning multiple pages.
Original commit message said:

Memorize the DMA segment's data offset within the page

Grant table references don't convey the information about an actual
offset of the data within the page, however Xen needs to know it.
We (ab)use bus_dma_segment's _ds_boundary member to store it and can
get away with not restoring it's original value atm because neither
i386 nor amd64 bus_dmamap_unload(9) code needs it.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.36 2016/08/17 17:18:38 mikeb Exp $	*/
d19 2
a20 2
#ifndef _XENVAR_H_
#define _XENVAR_H_
d182 1
a182 1
#endif	/* _XENVAR_H_ */
@


1.36
log
@Replace hand rolled atomic bit operations and use MI ones from DRM
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.35 2016/08/03 17:14:41 mikeb Exp $	*/
d95 9
@


1.35
log
@Use atomic operations to manipulate event masking bits
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.34 2016/08/03 14:55:58 mikeb Exp $	*/
d146 2
a147 2
static inline int
atomic_setbit_ptr(volatile void *ptr, int bit)
d149 2
a150 1
	int obit;
d152 4
a155 5
	__asm__ __volatile__ ("lock btsl %2,%1; sbbl %0,%0" :
	    "=r" (obit), "=m" (*(volatile long *)ptr) : "Ir" (bit) :
	    "memory");

	return (obit);
d158 2
a159 2
static inline int
atomic_clearbit_ptr(volatile void *ptr, int bit)
d161 1
a161 7
	int obit;

	__asm__ __volatile__ ("lock btrl %2,%1; sbbl %0,%0" :
	    "=r" (obit), "=m" (*(volatile long *)ptr) : "Ir" (bit) :
	    "memory");

	return (obit);
@


1.34
log
@Use an atomic operation to clear pending event bits

Pending event bits are located in a shared memory and are potentially
accessed by multiple CPUs running dom0 and the guest VM.  It appears
that a failure to synchronize changes to this shared memory leads to
race conditions resulting in the guest missing out on notifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.33 2016/07/29 21:27:43 mikeb Exp $	*/
d145 12
@


1.33
log
@Move xen interrupt handlers to dedicated task queues

Handling receive and transmit for multiple networking interfaces
in a "shared interrupt" within normal interrupt vector code path
introduces too much delay from the hypervisor POV which prevents
it from injecting further completion event interrupts for Rx and
Tx queues.

Additionally, Netfront backend driver includes a mechanism to
detect Rx ring stalls and "turn the carrier off" when the guest
is not replenishing the ring (e.g. due to missing completion
interrupts) that relies on guest waking up periodically and making
sure that the Rx ring completion handling is progressing.

Having tried both task queue + timeout and interrupts + timeout
approaches, it appears that using  the task queue is more flexible
and provides superior performance under heavy network load.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.32 2016/04/19 18:15:41 mikeb Exp $	*/
d145 12
@


1.32
log
@Bind event channels to backend domains

This is another piece of the QubesOS "chained VM" puzzle reported by
Marco Peereboom.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.31 2016/04/19 13:55:19 mikeb Exp $	*/
d31 7
a37 7
	SLIST_ENTRY(xen_intsrc)	  xi_entry;
	void			(*xi_handler)(void *);
	void			 *xi_arg;
	struct evcount		  xi_evcnt;
	evtchn_port_t		  xi_port;
	short			  xi_noclose;
	short			  xi_masked;
d117 1
@


1.31
log
@Pass down the backend-id property to children in the attach arguments
and pick it up in xnf(4) and print it in the dmesg line for now. We'll
need to pass it down to the Grant Table code.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.30 2016/04/19 12:39:31 mikeb Exp $	*/
d117 2
a118 2
int	xen_intr_establish(evtchn_port_t, xen_intr_handle_t *, void (*)(void *),
	    void *, char *);
@


1.30
log
@Remove the ds_offset hack since object offset within a page
is the same for both virtual and physical addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.29 2016/02/02 17:52:46 mikeb Exp $	*/
d92 1
@


1.29
log
@A few reliability improvements in the power management interface

Nathanael Rensen <nathanael at list ! polymorpheus ! com> came up with
a few improvements to the event watcher and power management interface,
namely:

 o Make sure to put our watcher on a list before issuing an XS_WATCH
   command since Xen will raise the event right after it's been set up.

 o The first time xen_control is called the "control/shutdown" node
   may not exist, so skip printing the error message in this case.

 o Acknowledge requests by writing back an empty string.

 o log(9) reboot and halt requests like vmt(4) does.

Huge thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.28 2016/01/29 19:12:26 mikeb Exp $	*/
a93 9

/*
 * Grant table references don't convey the information about an actual
 * offset of the data within the page, however Xen needs to know it.
 * We (ab)use bus_dma_segment's _ds_boundary member to store it.  Please
 * note that we don't save or restore it's original value atm because
 * neither i386 nor amd64 bus_dmamap_unload(9) code needs it.
 */
#define ds_offset		 _ds_boundary
@


1.28
log
@Add support for "control/shutdown" power management facility

At the moment only "poweroff" and "reboot" actions are supported.
Suspend/resume requires additional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.27 2016/01/29 19:04:30 mikeb Exp $	*/
d22 1
a22 1
#define XEN_DEBUG
@


1.27
log
@Add support for XS_WATCH: XenStore notification facility

After configuring a watch for the node, XenStore will asynchronously
notify the system when the value of the specified node changes with
an event message.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.26 2016/01/29 18:49:06 mikeb Exp $	*/
d81 2
@


1.26
log
@Cleanup XenStore API

Turns out that we want to let devices choose whether they're issuing
XenStore requests to the backend or frontend.  This also unifies the
the API somewhat as providing the xen softcore structure is now
mandatory.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.25 2016/01/27 15:34:50 mikeb Exp $	*/
d135 1
d140 1
d154 2
@


1.25
log
@Reimplement Grant Table metadata linking and enable dynamic allocation

Instead of pre-allocating maximum number of Grant Table frames allotted by
the hypervisor we switch over to allocating them dynamically when the need
arises.  At the same time we no longer link metadata entries representing
individual Grant Table frames as a list and use a table instead to speed
up reference lookups when establishing and removing mappings.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.24 2016/01/27 09:04:19 reyk Exp $	*/
d22 1
a22 1
/* #define XEN_DEBUG */
a150 2
int	xs_getprop(struct xen_attach_args *, const char *, char *, int);
int	xs_setprop(struct xen_attach_args *, const char *, char *, int);
d152 2
@


1.24
log
@Add a key-value interface to pvbus(4) that allows to get or set values
in the underlying information store of the host from the OpenBSD-VM's
userspace.  OpenBSD did not provide access to these stores before,
mostly because we did not want to add a custom tool and interface for
each hypervisor.  The pvbus(4) interface provides backends for
xen(4)'s XenStore and vmt(4)'s VMware Tools "guestinfo".  These
information stores are fairly different, XenStore is a "filesystem"
while vmt is a RPC, and the key-value abstraction limits them a bit
but provides the most wanted functionality.

Discussed with many
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.23 2016/01/25 15:22:56 mikeb Exp $	*/
a40 1
	SLIST_ENTRY(xen_gntent)	 ge_entry;
d72 2
a73 1
	SLIST_HEAD(, xen_gntent) sc_gnts;	/* grant table entries */
d75 1
@


1.23
log
@Don't count the total number of Xen upcalls
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.22 2016/01/18 19:06:48 mikeb Exp $	*/
d153 1
@


1.22
log
@Provide a Xen v3 API compatible fallback for event channel hypercalls
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.21 2016/01/15 18:20:41 mikeb Exp $	*/
a70 1
	struct evcount		 sc_evcnt;	/* upcall counter */
@


1.21
log
@Cleanup dmesg output, disable debugging; prodding and suggestions from reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.20 2016/01/15 14:27:08 mikeb Exp $	*/
d106 1
@


1.20
log
@Detach emulated network devices if Netfront driver is enabled

Xen doesn't provide a way for a guest to decide which model of
the interface is selected in the VM configuration and therefore
there's no simple way for Netfront and emulated devices to co-
exist on the same system.  Emulated em(4) or re(4) drivers will
take over if xnf(4) driver is disabled or not compiled in.

Idea and OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.19 2016/01/05 13:47:28 mikeb Exp $	*/
d22 1
a22 1
#define XEN_DEBUG
@


1.19
log
@Memorize the DMA segment's data offset within the page

Grant table references don't convey the information about an actual
offset of the data within the page, however Xen needs to know it.
We (ab)use bus_dma_segment's _ds_boundary member to store it and can
get away with not restoring it's original value atm because neither
i386 nor amd64 bus_dmamap_unload(9) code needs it.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.18 2016/01/04 16:05:43 mikeb Exp $	*/
d64 6
a69 1
	int			 sc_cbvec;	/* callback was installed */
@


1.18
log
@Preallocate Grant Table frames to simplify the code for now
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.17 2015/12/22 22:19:46 mikeb Exp $	*/
d87 9
@


1.17
log
@Make xs_setprop a bit more useful by removing property nodes
when NULL or zero length value was specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.16 2015/12/22 22:16:53 mikeb Exp $	*/
d70 1
a70 2
	int			 sc_gntcnt;	/* current number of pages */
	int			 sc_gntmax;	/* maximum number of pages */
@


1.16
log
@Implement a bus_dma(9) abstraction on top of Grant Table API
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.15 2015/12/21 19:43:16 mikeb Exp $	*/
d124 1
@


1.15
log
@Introduce xen_intr_mask and xen_intr_unmask primitives

Mask the event port during xen_intr_establish, but don't set the
masked flag in the intsrc.  By providing mask and unmask routines
we allow the device to decide when to perform these actions.  The
port will still be unmasked during xen_intr_enable.  This allows
netfront to fulfil the intr_barrier pattern requirements fairly
easily and at the same time should be sufficient for diskfront
that doesn't need to fiddle with interrupt masking.
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.14 2015/12/21 18:17:36 mikeb Exp $	*/
d36 17
a52 2
	int			  xi_noclose;
	int			  xi_masked;
d69 4
d86 1
@


1.14
log
@Cleanup hypercall subsystem type defines
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.13 2015/12/19 09:12:29 mikeb Exp $	*/
d93 2
@


1.13
log
@Add xs_setprop to set device properties
@
text
@d1 1
a1 1
/*	$OpenBSD: xenvar.h,v 1.12 2015/12/12 21:07:45 reyk Exp $	*/
d72 5
a76 4
#define memory_op		12
#define xen_version		17
#define event_channel_op	32
#define hvm_op			34
@


1.12
log
@Add OpenBSD CVS/RCS Ids.

mikeb@@ doesn't like the Ids, "somebody else has to add them".
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d114 1
@


1.11
log
@Let xs_getprop decide itself whether it's OK to sleep or not
@
text
@d1 2
@


1.10
log
@Implement a function to fetch device properties
@
text
@d111 1
a111 1
int	xs_getprop(struct xen_attach_args *, const char *, char *, int, int);
@


1.9
log
@Store the backend node in the attach argument structure
@
text
@d111 1
@


1.8
log
@Don't expose XenStore ops we don't know how to deal with
@
text
@d64 1
@


1.7
log
@Implements simple virtual device probing routine

Discussed with deraadt@@, kettenis@@, mpi@@, OK mlarkin, mpi
@
text
@d93 7
a99 25
enum {
	XS_DEBUG,
	XS_DIRECTORY,
	XS_READ,
	XS_GET_PERMS,
	XS_WATCH,
	XS_UNWATCH,
	XS_TRANSACTION_START,
	XS_TRANSACTION_END,
	XS_INTRODUCE,
	XS_RELEASE,
	XS_GET_DOMAIN_PATH,
	XS_WRITE,
	XS_MKDIR,
	XS_RM,
	XS_SET_PERMS,
	XS_WATCH_EVENT,
	XS_ERROR,
	XS_IS_DOMAIN_INTRODUCED,
	XS_RESUME,
	XS_SET_TARGET,
	XS_RESTRICT,
	XS_RESET_WATCHES,
	XS_MAX
};
@


1.6
log
@Driver for XenStore, the configuration storage

XenStore provides a hierarchical storage for Xen configuration
in a style of an OpenFirmware.  Itself it's an interrupt driven
producer/consumer interface with two 1kb rings for input and
output.

It's required in order to do virtual device discovery and device
configuration (fetch MAC address, various parameters).

With input from and OK mlarkin, reyk
@
text
@d60 6
@


1.5
log
@Add ability to establish virtual interrupts via Xen event
channel ports.

During boot, Xen will use polling mode, but once the system
enables interrupts after cpu_configure(), xen_intr_enable
will be called from the mountrook hook to unmask event ports.

OK mlarkin, mpi, reyk
@
text
@d51 5
d83 40
@


1.4
log
@Communicate the selected IDT vector to the Hypervisor

OK mlarkin, reyk
@
text
@d28 10
d48 3
d60 1
d65 13
@


1.3
log
@Allocate and hook up a "shared info page"

This page provides a matrix of pending events and some other
information like hypervisor timecounter.

OK mlarkin, reyk
@
text
@d36 2
@


1.2
log
@This brings in support for Xen hypercalls via an MI interface
and implements functions to fetch extended version and features.

OK mlarkin
@
text
@d34 2
@


1.1
log
@Xen basic infrastructure files and pvbus(4) attachment.

With input from and OK mpi, mlarkin, reyk
@
text
@d20 8
d31 3
d35 12
@
