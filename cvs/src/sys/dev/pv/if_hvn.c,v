head	1.35;
access;
symbols
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.2.0.2
	OPENBSD_6_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.35
date	2017.06.15.20.06.13;	author mikeb;	state Exp;
branches;
next	1.34;
commitid	SNHt4dx1wUTx3LCM;

1.34
date	2017.03.13.01.10.03;	author mikeb;	state Exp;
branches;
next	1.33;
commitid	7qXoPSATw8fQxunw;

1.33
date	2017.03.13.01.00.15;	author mikeb;	state Exp;
branches;
next	1.32;
commitid	knAVpjVB7fgmCUNq;

1.32
date	2017.01.24.03.57.35;	author dlg;	state Exp;
branches;
next	1.31;
commitid	PERtGPXCvlLRRBr8;

1.31
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.30;
commitid	VyLWTsbepAOk7VQM;

1.30
date	2017.01.18.17.22.46;	author mikeb;	state Exp;
branches;
next	1.29;
commitid	6wxHMFBy37rWTOXZ;

1.29
date	2017.01.05.13.23.51;	author mikeb;	state Exp;
branches;
next	1.28;
commitid	vrs26y2Cwl19Fr2D;

1.28
date	2016.11.23.09.37.43;	author mikeb;	state Exp;
branches;
next	1.27;
commitid	5XgIePKjlCwEuU2x;

1.27
date	2016.11.16.21.02.02;	author mikeb;	state Exp;
branches;
next	1.26;
commitid	1LY5ZLIeJi8Ykyi1;

1.26
date	2016.11.14.14.13.58;	author mikeb;	state Exp;
branches;
next	1.25;
commitid	CUa0iZiyVorN49m4;

1.25
date	2016.11.11.18.45.24;	author mikeb;	state Exp;
branches;
next	1.24;
commitid	yYjcNZNQF4aPIw60;

1.24
date	2016.11.10.17.44.34;	author mikeb;	state Exp;
branches;
next	1.23;
commitid	Irbs6Kc7oEaK3tYV;

1.23
date	2016.11.10.17.42.46;	author mikeb;	state Exp;
branches;
next	1.22;
commitid	IYEDOg6Pnu5NQ62u;

1.22
date	2016.11.10.12.15.30;	author mikeb;	state Exp;
branches;
next	1.21;
commitid	d44vi0uw1kGCmXrN;

1.21
date	2016.10.25.19.36.11;	author mikeb;	state Exp;
branches;
next	1.20;
commitid	tujUilLvS05dLN8J;

1.20
date	2016.10.14.16.59.53;	author mikeb;	state Exp;
branches;
next	1.19;
commitid	CXHZtaXi2vBCZIJ3;

1.19
date	2016.10.12.16.23.35;	author mikeb;	state Exp;
branches;
next	1.18;
commitid	3tNzzGKXHGFXBdup;

1.18
date	2016.10.06.15.40.20;	author mikeb;	state Exp;
branches;
next	1.17;
commitid	1nEymUHSDsqQdaNj;

1.17
date	2016.09.23.14.36.08;	author mikeb;	state Exp;
branches;
next	1.16;
commitid	A2rMcWqOyFRlSqf4;

1.16
date	2016.09.23.13.43.36;	author mikeb;	state Exp;
branches;
next	1.15;
commitid	5ZiI693UsPehCUMD;

1.15
date	2016.09.23.13.28.07;	author mikeb;	state Exp;
branches;
next	1.14;
commitid	pyW286HT4b1wDUmS;

1.14
date	2016.09.23.11.01.35;	author mikeb;	state Exp;
branches;
next	1.13;
commitid	NJQawlWXu4enbIXQ;

1.13
date	2016.09.23.10.52.30;	author mikeb;	state Exp;
branches;
next	1.12;
commitid	SE1jPLUbMZRunP4e;

1.12
date	2016.09.20.10.36.00;	author mikeb;	state Exp;
branches;
next	1.11;
commitid	n4mPBFRK1EFALrS8;

1.11
date	2016.09.20.10.28.19;	author mikeb;	state Exp;
branches;
next	1.10;
commitid	WiVtBGLuGrdzzoDr;

1.10
date	2016.09.16.22.44.32;	author mikeb;	state Exp;
branches;
next	1.9;
commitid	OAislz34JOv5HeEC;

1.9
date	2016.09.14.18.54.27;	author mikeb;	state Exp;
branches;
next	1.8;
commitid	1HivtI0ta9wGp4jr;

1.8
date	2016.09.14.18.52.12;	author mikeb;	state Exp;
branches;
next	1.7;
commitid	OQ4e616SGOoUzTtS;

1.7
date	2016.09.14.18.46.24;	author mikeb;	state Exp;
branches;
next	1.6;
commitid	ERZdJ4cj5pDaFTLk;

1.6
date	2016.08.18.15.56.54;	author mikeb;	state Exp;
branches;
next	1.5;
commitid	9jkJpFRCY0IWVjdN;

1.5
date	2016.08.16.14.43.31;	author mikeb;	state Exp;
branches;
next	1.4;
commitid	gjDTTLYz8B3N4PzV;

1.4
date	2016.08.05.11.37.57;	author mikeb;	state Exp;
branches;
next	1.3;
commitid	xZielPC41xzSqBoS;

1.3
date	2016.07.27.01.36.37;	author jsg;	state Exp;
branches;
next	1.2;
commitid	sYFqHAReKf2Le59i;

1.2
date	2016.07.21.10.21.00;	author mikeb;	state Exp;
branches;
next	1.1;
commitid	oQ0uYlEM533yeyFr;

1.1
date	2016.07.13.21.59.35;	author mikeb;	state Exp;
branches;
next	;
commitid	8jURlFl7WujRXJsd;


desc
@@


1.35
log
@Support executing NVSP and RNDIS commands during autoconf
@
text
@/*-
 * Copyright (c) 2009-2012,2016 Microsoft Corp.
 * Copyright (c) 2010-2012 Citrix Inc.
 * Copyright (c) 2012 NetApp Inc.
 * Copyright (c) 2016 Mike Belopuhov <mike@@esdenera.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * The OpenBSD port was done under funding by Esdenera Networks GmbH.
 */

#include "bpfilter.h"
#include "vlan.h"
#include "hyperv.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/atomic.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/pool.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/task.h>
#include <sys/timeout.h>

#include <machine/bus.h>

#include <uvm/uvm_extern.h>

#include <dev/pv/hypervreg.h>
#include <dev/pv/hypervvar.h>

#include <dev/rndis.h>
#include <dev/pv/ndis.h>
#include <dev/pv/if_hvnreg.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#define HVN_NVS_MSGSIZE			32
#define HVN_NVS_BUFSIZE			PAGE_SIZE

/*
 * RNDIS control interface
 */
#define HVN_RNDIS_CTLREQS		4
#define HVN_RNDIS_BUFSIZE		512

struct rndis_cmd {
	uint32_t			 rc_id;
	struct hvn_nvs_rndis		 rc_msg;
	void				*rc_req;
	bus_dmamap_t			 rc_dmap;
	bus_dma_segment_t		 rc_segs;
	int				 rc_nsegs;
	uint64_t			 rc_gpa;
	struct rndis_packet_msg		 rc_cmp;
	uint32_t			 rc_cmplen;
	uint8_t				 rc_cmpbuf[HVN_RNDIS_BUFSIZE];
	int				 rc_done;
	TAILQ_ENTRY(rndis_cmd)		 rc_entry;
};
TAILQ_HEAD(rndis_queue, rndis_cmd);

#define HVN_MAXMTU			(9 * 1024)

#define HVN_RNDIS_XFER_SIZE		2048

/*
 * Tx ring
 */
#define HVN_TX_DESC			256
#define HVN_TX_FRAGS			15		/* 31 is the max */
#define HVN_TX_FRAG_SIZE		PAGE_SIZE
#define HVN_TX_PKT_SIZE			16384

#define HVN_RNDIS_PKT_LEN					\
	(sizeof(struct rndis_packet_msg) +			\
	 sizeof(struct rndis_pktinfo) + NDIS_VLAN_INFO_SIZE +	\
	 sizeof(struct rndis_pktinfo) + NDIS_TXCSUM_INFO_SIZE)

struct hvn_tx_desc {
	uint32_t			 txd_id;
	int				 txd_ready;
	struct vmbus_gpa		 txd_sgl[HVN_TX_FRAGS + 1];
	int				 txd_nsge;
	struct mbuf			*txd_buf;
	bus_dmamap_t			 txd_dmap;
	struct vmbus_gpa		 txd_gpa;
	struct rndis_packet_msg		*txd_req;
};

struct hvn_softc {
	struct device			 sc_dev;
	struct hv_softc			*sc_hvsc;
	struct hv_channel		*sc_chan;
	bus_dma_tag_t			 sc_dmat;

	struct arpcom			 sc_ac;
	struct ifmedia			 sc_media;
	int				 sc_link_state;
	int				 sc_promisc;

	/* NVS protocol */
	int				 sc_proto;
	uint32_t			 sc_nvstid;
	uint8_t				 sc_nvsrsp[HVN_NVS_MSGSIZE];
	uint8_t				*sc_nvsbuf;
	int				 sc_nvsdone;

	/* RNDIS protocol */
	int				 sc_ndisver;
	uint32_t			 sc_rndisrid;
	struct rndis_queue		 sc_cntl_sq; /* submission queue */
	struct mutex			 sc_cntl_sqlck;
	struct rndis_queue		 sc_cntl_cq; /* completion queue */
	struct mutex			 sc_cntl_cqlck;
	struct rndis_queue		 sc_cntl_fq; /* free queue */
	struct mutex			 sc_cntl_fqlck;
	struct rndis_cmd		 sc_cntl_msgs[HVN_RNDIS_CTLREQS];
	struct hvn_nvs_rndis		 sc_data_msg;

	/* Rx ring */
	void				*sc_rx_ring;
	int				 sc_rx_size;
	uint32_t			 sc_rx_hndl;

	/* Tx ring */
	uint32_t			 sc_tx_next;
	uint32_t			 sc_tx_avail;
	struct hvn_tx_desc		 sc_tx_desc[HVN_TX_DESC];
	bus_dmamap_t			 sc_tx_rmap;
	void				*sc_tx_msgs;
	bus_dma_segment_t		 sc_tx_mseg;
};

int	hvn_match(struct device *, void *, void *);
void	hvn_attach(struct device *, struct device *, void *);
int	hvn_ioctl(struct ifnet *, u_long, caddr_t);
int	hvn_media_change(struct ifnet *);
void	hvn_media_status(struct ifnet *, struct ifmediareq *);
int	hvn_iff(struct hvn_softc *);
void	hvn_init(struct hvn_softc *);
void	hvn_stop(struct hvn_softc *);
void	hvn_start(struct ifqueue *);
int	hvn_encap(struct hvn_softc *, struct mbuf *, struct hvn_tx_desc **);
void	hvn_decap(struct hvn_softc *, struct hvn_tx_desc *);
void	hvn_txeof(struct hvn_softc *, uint64_t);
int	hvn_rx_ring_create(struct hvn_softc *);
int	hvn_rx_ring_destroy(struct hvn_softc *);
int	hvn_tx_ring_create(struct hvn_softc *);
void	hvn_tx_ring_destroy(struct hvn_softc *);
int	hvn_set_capabilities(struct hvn_softc *);
int	hvn_get_lladdr(struct hvn_softc *);
int	hvn_set_lladdr(struct hvn_softc *);
void	hvn_get_link_status(struct hvn_softc *);
void	hvn_link_status(struct hvn_softc *);

/* NSVP */
int	hvn_nvs_attach(struct hvn_softc *);
void	hvn_nvs_intr(void *);
int	hvn_nvs_cmd(struct hvn_softc *, void *, size_t, uint64_t, int);
int	hvn_nvs_ack(struct hvn_softc *, uint64_t);
void	hvn_nvs_detach(struct hvn_softc *);

/* RNDIS */
int	hvn_rndis_attach(struct hvn_softc *);
int	hvn_rndis_cmd(struct hvn_softc *, struct rndis_cmd *, int);
void	hvn_rndis_input(struct hvn_softc *, uint64_t, void *);
void	hvn_rxeof(struct hvn_softc *, caddr_t, uint32_t, struct mbuf_list *);
void	hvn_rndis_complete(struct hvn_softc *, caddr_t, uint32_t);
int	hvn_rndis_output(struct hvn_softc *, struct hvn_tx_desc *);
void	hvn_rndis_status(struct hvn_softc *, caddr_t, uint32_t);
int	hvn_rndis_query(struct hvn_softc *, uint32_t, void *, size_t *);
int	hvn_rndis_set(struct hvn_softc *, uint32_t, void *, size_t);
int	hvn_rndis_open(struct hvn_softc *);
int	hvn_rndis_close(struct hvn_softc *);
void	hvn_rndis_detach(struct hvn_softc *);

struct cfdriver hvn_cd = {
	NULL, "hvn", DV_IFNET
};

const struct cfattach hvn_ca = {
	sizeof(struct hvn_softc), hvn_match, hvn_attach
};

int
hvn_match(struct device *parent, void *match, void *aux)
{
	struct hv_attach_args *aa = aux;

	if (strcmp("network", aa->aa_ident))
		return (0);

	return (1);
}

void
hvn_attach(struct device *parent, struct device *self, void *aux)
{
	struct hv_attach_args *aa = aux;
	struct hvn_softc *sc = (struct hvn_softc *)self;
	struct ifnet *ifp = &sc->sc_ac.ac_if;

	sc->sc_hvsc = (struct hv_softc *)parent;
	sc->sc_chan = aa->aa_chan;
	sc->sc_dmat = aa->aa_dmat;

	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	printf(" channel %u: ", sc->sc_chan->ch_id);

	if (hvn_nvs_attach(sc)) {
		printf(": failed to init NVSP\n");
		return;
	}

	if (hvn_rx_ring_create(sc)) {
		printf(": failed to create Rx ring\n");
		goto detach;
	}

	if (hvn_tx_ring_create(sc)) {
		printf(": failed to create Tx ring\n");
		goto detach;
	}

	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_xflags = IFXF_MPSAFE;
	ifp->if_ioctl = hvn_ioctl;
	ifp->if_qstart = hvn_start;
	ifp->if_softc = sc;

	ifp->if_capabilities = IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 |
	    IFCAP_CSUM_TCPv6;
	if (sc->sc_ndisver >= NDIS_VERSION_6_30)
		ifp->if_capabilities |= IFCAP_CSUM_UDPv4 | IFCAP_CSUM_UDPv6;

	if (sc->sc_proto >= HVN_NVS_PROTO_VERSION_2) {
		ifp->if_hardmtu = HVN_MAXMTU;
#if NVLAN > 0
		ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU;
#endif
	}

	IFQ_SET_MAXLEN(&ifp->if_snd, HVN_TX_DESC - 1);

	ifmedia_init(&sc->sc_media, IFM_IMASK, hvn_media_change,
	    hvn_media_status);
	ifmedia_add(&sc->sc_media, IFM_ETHER | IFM_MANUAL, 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER | IFM_MANUAL);

	if_attach(ifp);

	if (hvn_rndis_attach(sc)) {
		printf(": failed to init RNDIS\n");
		goto detach;
	}

	if (hvn_set_capabilities(sc)) {
		printf(": failed to setup offloading\n");
		hvn_rndis_detach(sc);
		goto detach;
	}

	if (hvn_get_lladdr(sc)) {
		printf(": failed to obtain an ethernet address\n");
		hvn_rndis_detach(sc);
		goto detach;
	}

	DPRINTF("%s:", sc->sc_dev.dv_xname);
	printf(" channel %u: NVS %d.%d NDIS %d.%d, address %s\n",
	    sc->sc_chan->ch_id, sc->sc_proto >> 16, sc->sc_proto & 0xffff,
	    sc->sc_ndisver >> 16 , sc->sc_ndisver & 0xffff,
	    ether_sprintf(sc->sc_ac.ac_enaddr));

	ether_ifattach(ifp);
	return;

 detach:
	hvn_rx_ring_destroy(sc);
	hvn_tx_ring_destroy(sc);
	hvn_nvs_detach(sc);
	if (ifp->if_qstart)
		if_detach(ifp);
}

int
hvn_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct hvn_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			hvn_init(sc);
		break;
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				hvn_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				hvn_stop(sc);
		}
		break;
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, command);
		break;
	default:
		error = ether_ioctl(ifp, &sc->sc_ac, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			hvn_iff(sc);
		error = 0;
	}

	splx(s);

	return (error);
}

int
hvn_media_change(struct ifnet *ifp)
{
	return (0);
}

void
hvn_media_status(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct hvn_softc *sc = ifp->if_softc;

	hvn_get_link_status(sc);
	hvn_link_status(sc);

	ifmr->ifm_status = IFM_AVALID;
	ifmr->ifm_active = IFM_ETHER | IFM_MANUAL;
	if (sc->sc_link_state == LINK_STATE_UP)
		ifmr->ifm_status |= IFM_ACTIVE;
}

void
hvn_link_status(struct hvn_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;

	if (sc->sc_link_state != ifp->if_link_state) {
		ifp->if_link_state = sc->sc_link_state;
		if_link_state_change(ifp);
	}
}

int
hvn_iff(struct hvn_softc *sc)
{
	/* XXX */
	sc->sc_promisc = 0;

	return (0);
}

void
hvn_init(struct hvn_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;

	hvn_stop(sc);

	hvn_iff(sc);

	if (hvn_rndis_open(sc) == 0) {
		ifp->if_flags |= IFF_RUNNING;
		ifq_clr_oactive(&ifp->if_snd);
	}
}

void
hvn_stop(struct hvn_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;

	if (ifp->if_flags & IFF_RUNNING) {
		ifp->if_flags &= ~IFF_RUNNING;
		hvn_rndis_close(sc);
	}

	ifq_barrier(&ifp->if_snd);
	intr_barrier(sc->sc_chan);

	ifq_clr_oactive(&ifp->if_snd);
}

void
hvn_start(struct ifqueue *ifq)
{
	struct ifnet *ifp = ifq->ifq_if;
	struct hvn_softc *sc = ifp->if_softc;
	struct hvn_tx_desc *txd;
	struct mbuf *m;

	for (;;) {
		if (!sc->sc_tx_avail) {
			/* transient */
			ifq_set_oactive(ifq);
			break;
		}

		m = ifq_dequeue(ifq);
		if (m == NULL)
			break;

		if (hvn_encap(sc, m, &txd)) {
			/* the chain is too large */
			ifp->if_oerrors++;
			m_freem(m);
			continue;
		}

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		if (hvn_rndis_output(sc, txd)) {
			hvn_decap(sc, txd);
			ifp->if_oerrors++;
			m_freem(m);
			continue;
		}

		sc->sc_tx_next++;
	}
}

static inline char *
hvn_rndis_pktinfo_append(struct rndis_packet_msg *pkt, size_t pktsize,
    size_t datalen, uint32_t type)
{
	struct rndis_pktinfo *pi;
	size_t pi_size = sizeof(*pi) + datalen;
	char *cp;

	KASSERT(pkt->rm_pktinfooffset + pkt->rm_pktinfolen + pi_size <=
	    pktsize);

	cp = (char *)pkt + pkt->rm_pktinfooffset + pkt->rm_pktinfolen;
	pi = (struct rndis_pktinfo *)cp;
	pi->rm_size = pi_size;
	pi->rm_type = type;
	pi->rm_pktinfooffset = sizeof(*pi);
	pkt->rm_pktinfolen += pi_size;
	pkt->rm_dataoffset += pi_size;
	pkt->rm_len += pi_size;
	return ((char *)pi->rm_data);
}

int
hvn_encap(struct hvn_softc *sc, struct mbuf *m, struct hvn_tx_desc **txd0)
{
	struct hvn_tx_desc *txd;
	struct rndis_packet_msg *pkt;
	bus_dma_segment_t *seg;
	size_t pktlen;
	int i, rv;

	do {
		txd = &sc->sc_tx_desc[sc->sc_tx_next % HVN_TX_DESC];
		sc->sc_tx_next++;
	} while (!txd->txd_ready);
	txd->txd_ready = 0;

	pkt = txd->txd_req;
	memset(pkt, 0, HVN_RNDIS_PKT_LEN);
	pkt->rm_type = REMOTE_NDIS_PACKET_MSG;
	pkt->rm_len = sizeof(*pkt) + m->m_pkthdr.len;
	pkt->rm_dataoffset = RNDIS_DATA_OFFSET;
	pkt->rm_datalen = m->m_pkthdr.len;
	pkt->rm_pktinfooffset = sizeof(*pkt); /* adjusted below */
	pkt->rm_pktinfolen = 0;

	rv = bus_dmamap_load_mbuf(sc->sc_dmat, txd->txd_dmap, m, BUS_DMA_READ |
	    BUS_DMA_NOWAIT);
	switch (rv) {
	case 0:
		break;
	case EFBIG:
		if (m_defrag(m, M_NOWAIT) == 0 &&
		    bus_dmamap_load_mbuf(sc->sc_dmat, txd->txd_dmap, m,
		    BUS_DMA_READ | BUS_DMA_NOWAIT) == 0)
			break;
		/* FALLTHROUGH */
	default:
		DPRINTF("%s: failed to load mbuf\n", sc->sc_dev.dv_xname);
		return (-1);
	}
	txd->txd_buf = m;

#if NVLAN > 0
	if (m->m_flags & M_VLANTAG) {
		uint32_t vlan;
		char *cp;

		vlan = NDIS_VLAN_INFO(EVL_VLANOFTAG(m->m_pkthdr.ether_vtag),
		    EVL_PRIOFTAG(m->m_pkthdr.ether_vtag));
		cp = hvn_rndis_pktinfo_append(pkt, HVN_RNDIS_PKT_LEN,
		    NDIS_VLAN_INFO_SIZE, NDIS_PKTINFO_TYPE_VLAN);
		memcpy(cp, &vlan, NDIS_VLAN_INFO_SIZE);
	}
#endif

	if (m->m_pkthdr.csum_flags & (M_IPV4_CSUM_OUT | M_UDP_CSUM_OUT |
	    M_TCP_CSUM_OUT)) {
		uint32_t csum = NDIS_TXCSUM_INFO_IPV4;
		char *cp;

		if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
			csum |= NDIS_TXCSUM_INFO_IPCS;
		if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT)
			csum |= NDIS_TXCSUM_INFO_TCPCS;
		if (m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT)
			csum |= NDIS_TXCSUM_INFO_UDPCS;
		cp = hvn_rndis_pktinfo_append(pkt, HVN_RNDIS_PKT_LEN,
		    NDIS_TXCSUM_INFO_SIZE, NDIS_PKTINFO_TYPE_CSUM);
		memcpy(cp, &csum, NDIS_TXCSUM_INFO_SIZE);
	}

	pktlen = pkt->rm_pktinfooffset + pkt->rm_pktinfolen;
	pkt->rm_pktinfooffset -= RNDIS_HEADER_OFFSET;

	/* Attach an RNDIS message to the first slot */
	txd->txd_sgl[0].gpa_page = txd->txd_gpa.gpa_page;
	txd->txd_sgl[0].gpa_ofs = txd->txd_gpa.gpa_ofs;
	txd->txd_sgl[0].gpa_len = pktlen;
	txd->txd_nsge = txd->txd_dmap->dm_nsegs + 1;

	for (i = 0; i < txd->txd_dmap->dm_nsegs; i++) {
		seg = &txd->txd_dmap->dm_segs[i];
		txd->txd_sgl[1 + i].gpa_page = atop(seg->ds_addr);
		txd->txd_sgl[1 + i].gpa_ofs = seg->ds_addr & PAGE_MASK;
		txd->txd_sgl[1 + i].gpa_len = seg->ds_len;
	}

	*txd0 = txd;

	atomic_dec_int(&sc->sc_tx_avail);

	return (0);
}

void
hvn_decap(struct hvn_softc *sc, struct hvn_tx_desc *txd)
{
	bus_dmamap_sync(sc->sc_dmat, txd->txd_dmap, 0, 0,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, txd->txd_dmap);
	txd->txd_buf = NULL;
	txd->txd_nsge = 0;
	txd->txd_ready = 1;
	atomic_inc_int(&sc->sc_tx_avail);
}

void
hvn_txeof(struct hvn_softc *sc, uint64_t tid)
{
	struct hvn_tx_desc *txd;
	struct mbuf *m;
	uint32_t id = tid >> 32;

	if ((tid & 0xffffffffU) != 0)
		return;
	id -= HVN_NVS_CHIM_SIG;
	if (id > HVN_TX_DESC)
		panic("tx packet index too large: %u", id);

	txd = &sc->sc_tx_desc[id];

	if ((m = txd->txd_buf) == NULL)
		panic("%s: no mbuf @@%u\n", sc->sc_dev.dv_xname, id);
	txd->txd_buf = NULL;

	bus_dmamap_sync(sc->sc_dmat, txd->txd_dmap, 0, 0,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, txd->txd_dmap);
	m_freem(m);

	txd->txd_ready = 1;

	atomic_inc_int(&sc->sc_tx_avail);

}

int
hvn_rx_ring_create(struct hvn_softc *sc)
{
	struct hvn_nvs_rxbuf_conn cmd;
	struct hvn_nvs_rxbuf_conn_resp *rsp;
	uint64_t tid;

	if (sc->sc_proto <= HVN_NVS_PROTO_VERSION_2)
		sc->sc_rx_size = 15 * 1024 * 1024;	/* 15MB */
	else
		sc->sc_rx_size = 16 * 1024 * 1024; 	/* 16MB */
	sc->sc_rx_ring = km_alloc(sc->sc_rx_size, &kv_any, &kp_zero,
	    cold ? &kd_nowait : &kd_waitok);
	if (sc->sc_rx_ring == NULL) {
		DPRINTF("%s: failed to allocate Rx ring buffer\n",
		    sc->sc_dev.dv_xname);
		return (-1);
	}
	if (hv_handle_alloc(sc->sc_chan, sc->sc_rx_ring, sc->sc_rx_size,
	    &sc->sc_rx_hndl)) {
		DPRINTF("%s: failed to obtain a PA handle\n",
		    sc->sc_dev.dv_xname);
		goto errout;
	}

	memset(&cmd, 0, sizeof(cmd));
	cmd.nvs_type = HVN_NVS_TYPE_RXBUF_CONN;
	cmd.nvs_gpadl = sc->sc_rx_hndl;
	cmd.nvs_sig = HVN_NVS_RXBUF_SIG;

	tid = atomic_inc_int_nv(&sc->sc_nvstid);
	if (hvn_nvs_cmd(sc, &cmd, sizeof(cmd), tid, 100))
		goto errout;

	rsp = (struct hvn_nvs_rxbuf_conn_resp *)&sc->sc_nvsrsp;
	if (rsp->nvs_status != HVN_NVS_STATUS_OK) {
		DPRINTF("%s: failed to set up the Rx ring\n",
		    sc->sc_dev.dv_xname);
		goto errout;
	}
	if (rsp->nvs_nsect > 1) {
		DPRINTF("%s: invalid number of Rx ring sections: %u\n",
		    sc->sc_dev.dv_xname, rsp->nvs_nsect);
		hvn_rx_ring_destroy(sc);
		return (-1);
	}
	return (0);

 errout:
	if (sc->sc_rx_hndl) {
		hv_handle_free(sc->sc_chan, sc->sc_rx_hndl);
		sc->sc_rx_hndl = 0;
	}
	if (sc->sc_rx_ring) {
		km_free(sc->sc_rx_ring, sc->sc_rx_size, &kv_any, &kp_zero);
		sc->sc_rx_ring = NULL;
	}
	return (-1);
}

int
hvn_rx_ring_destroy(struct hvn_softc *sc)
{
	struct hvn_nvs_rxbuf_disconn cmd;
	uint64_t tid;

	if (sc->sc_rx_ring == NULL)
		return (0);

	memset(&cmd, 0, sizeof(cmd));
	cmd.nvs_type = HVN_NVS_TYPE_RXBUF_DISCONN;
	cmd.nvs_sig = HVN_NVS_RXBUF_SIG;

	tid = atomic_inc_int_nv(&sc->sc_nvstid);
	if (hvn_nvs_cmd(sc, &cmd, sizeof(cmd), tid, 0))
		return (-1);

	delay(100);

	hv_handle_free(sc->sc_chan, sc->sc_rx_hndl);

	sc->sc_rx_hndl = 0;

	km_free(sc->sc_rx_ring, sc->sc_rx_size, &kv_any, &kp_zero);
	sc->sc_rx_ring = NULL;

	return (0);
}

int
hvn_tx_ring_create(struct hvn_softc *sc)
{
	struct hvn_tx_desc *txd;
	bus_dma_segment_t *seg;
	size_t msgsize;
	int i, rsegs;
	paddr_t pa;

	msgsize = roundup(HVN_RNDIS_PKT_LEN, 128);

	/* Allocate memory to store RNDIS messages */
	if (bus_dmamem_alloc(sc->sc_dmat, msgsize * HVN_TX_DESC, PAGE_SIZE, 0,
	    &sc->sc_tx_mseg, 1, &rsegs, BUS_DMA_ZERO | BUS_DMA_WAITOK)) {
		DPRINTF("%s: failed to allocate memory for RDNIS messages\n",
		    sc->sc_dev.dv_xname);
		goto errout;
	}
	if (bus_dmamem_map(sc->sc_dmat, &sc->sc_tx_mseg, 1, msgsize *
	    HVN_TX_DESC, (caddr_t *)&sc->sc_tx_msgs, BUS_DMA_WAITOK)) {
		DPRINTF("%s: failed to establish mapping for RDNIS messages\n",
		    sc->sc_dev.dv_xname);
		goto errout;
	}
	if (bus_dmamap_create(sc->sc_dmat, msgsize * HVN_TX_DESC, 1,
	    msgsize * HVN_TX_DESC, 0, BUS_DMA_WAITOK, &sc->sc_tx_rmap)) {
		DPRINTF("%s: failed to create map for RDNIS messages\n",
		    sc->sc_dev.dv_xname);
		goto errout;
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_tx_rmap, sc->sc_tx_msgs,
	    msgsize * HVN_TX_DESC, NULL, BUS_DMA_WAITOK)) {
		DPRINTF("%s: failed to create map for RDNIS messages\n",
		    sc->sc_dev.dv_xname);
		goto errout;
	}

	for (i = 0; i < HVN_TX_DESC; i++) {
		txd = &sc->sc_tx_desc[i];
		if (bus_dmamap_create(sc->sc_dmat, HVN_TX_PKT_SIZE,
		    HVN_TX_FRAGS, HVN_TX_FRAG_SIZE, PAGE_SIZE,
		    BUS_DMA_WAITOK, &txd->txd_dmap)) {
			DPRINTF("%s: failed to create map for TX descriptors\n",
			    sc->sc_dev.dv_xname);
			goto errout;
		}
		seg = &sc->sc_tx_rmap->dm_segs[0];
		pa = seg->ds_addr + (msgsize * i);
		txd->txd_gpa.gpa_page = atop(pa);
		txd->txd_gpa.gpa_ofs = pa & PAGE_MASK;
		txd->txd_gpa.gpa_len = msgsize;
		txd->txd_req = (void *)((caddr_t)sc->sc_tx_msgs +
		    (msgsize * i));
		txd->txd_id = i + HVN_NVS_CHIM_SIG;
		txd->txd_ready = 1;
	}
	sc->sc_tx_avail = HVN_TX_DESC;

	return (0);

 errout:
	hvn_tx_ring_destroy(sc);
	return (-1);
}

void
hvn_tx_ring_destroy(struct hvn_softc *sc)
{
	struct hvn_tx_desc *txd;
	int i;

	for (i = 0; i < HVN_TX_DESC; i++) {
		txd = &sc->sc_tx_desc[i];
		if (txd->txd_dmap == NULL)
			continue;
		bus_dmamap_sync(sc->sc_dmat, txd->txd_dmap, 0, 0,
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, txd->txd_dmap);
		bus_dmamap_destroy(sc->sc_dmat, txd->txd_dmap);
		txd->txd_dmap = NULL;
		if (txd->txd_buf == NULL)
			continue;
		m_free(txd->txd_buf);
		txd->txd_buf = NULL;
	}
	if (sc->sc_tx_rmap) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_tx_rmap, 0, 0,
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, sc->sc_tx_rmap);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_tx_rmap);
	}
	if (sc->sc_tx_msgs) {
		size_t msgsize = roundup(HVN_RNDIS_PKT_LEN, 128);

		bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_tx_msgs,
		    msgsize * HVN_TX_DESC);
		bus_dmamem_free(sc->sc_dmat, &sc->sc_tx_mseg, 1);
	}
	sc->sc_tx_rmap = NULL;
	sc->sc_tx_msgs = NULL;
}

int
hvn_get_lladdr(struct hvn_softc *sc)
{
	char enaddr[ETHER_ADDR_LEN];
	size_t addrlen = ETHER_ADDR_LEN;
	int rv;

	rv = hvn_rndis_query(sc, OID_802_3_PERMANENT_ADDRESS,
	    enaddr, &addrlen);
	if (rv == 0 && addrlen == ETHER_ADDR_LEN)
		memcpy(sc->sc_ac.ac_enaddr, enaddr, ETHER_ADDR_LEN);
	return (rv);
}

int
hvn_set_lladdr(struct hvn_softc *sc)
{
	return (hvn_rndis_set(sc, OID_802_3_CURRENT_ADDRESS,
	    sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN));
}

void
hvn_get_link_status(struct hvn_softc *sc)
{
	uint32_t state;
	size_t len = sizeof(state);

	if (hvn_rndis_query(sc, OID_GEN_MEDIA_CONNECT_STATUS,
	    &state, &len) == 0)
		sc->sc_link_state = (state == NDIS_MEDIA_STATE_CONNECTED) ?
		    LINK_STATE_UP : LINK_STATE_DOWN;
}

int
hvn_nvs_attach(struct hvn_softc *sc)
{
	const uint32_t protos[] = {
		HVN_NVS_PROTO_VERSION_5, HVN_NVS_PROTO_VERSION_4,
		HVN_NVS_PROTO_VERSION_2, HVN_NVS_PROTO_VERSION_1
	};
	struct hvn_nvs_init cmd;
	struct hvn_nvs_init_resp *rsp;
	struct hvn_nvs_ndis_init ncmd;
	struct hvn_nvs_ndis_conf ccmd;
	uint32_t ndisver, ringsize;
	uint64_t tid;
	int i;

	sc->sc_nvsbuf = malloc(HVN_NVS_BUFSIZE, M_DEVBUF, M_ZERO |
	    (cold ? M_NOWAIT : M_WAITOK));
	if (sc->sc_nvsbuf == NULL) {
		DPRINTF("%s: failed to allocate channel data buffer\n",
		    sc->sc_dev.dv_xname);
		return (-1);
	}

	/* We need to be able to fit all RNDIS control and data messages */
	ringsize = HVN_RNDIS_CTLREQS *
	    (sizeof(struct hvn_nvs_rndis) + sizeof(struct vmbus_gpa)) +
	    HVN_TX_DESC * (sizeof(struct hvn_nvs_rndis) +
	    (HVN_TX_FRAGS + 1) * sizeof(struct vmbus_gpa));

	/* Associate our interrupt handler with the channel */
	if (hv_channel_open(sc->sc_chan, ringsize, NULL, 0,
	    hvn_nvs_intr, sc)) {
		DPRINTF("%s: failed to open channel\n", sc->sc_dev.dv_xname);
		free(sc->sc_nvsbuf, M_DEVBUF, HVN_NVS_BUFSIZE);
		return (-1);
	}

	hv_evcount_attach(sc->sc_chan, sc->sc_dev.dv_xname);

	memset(&cmd, 0, sizeof(cmd));
	cmd.nvs_type = HVN_NVS_TYPE_INIT;
	for (i = 0; i < nitems(protos); i++) {
		cmd.nvs_ver_min = cmd.nvs_ver_max = protos[i];
		tid = atomic_inc_int_nv(&sc->sc_nvstid);
		if (hvn_nvs_cmd(sc, &cmd, sizeof(cmd), tid, 100))
			return (-1);
		rsp = (struct hvn_nvs_init_resp *)&sc->sc_nvsrsp;
		if (rsp->nvs_status == HVN_NVS_STATUS_OK) {
			sc->sc_proto = protos[i];
			break;
		}
	}
	if (!sc->sc_proto) {
		DPRINTF("%s: failed to negotiate NVSP version\n",
		    sc->sc_dev.dv_xname);
		return (-1);
	}

	if (sc->sc_proto >= HVN_NVS_PROTO_VERSION_2) {
		memset(&ccmd, 0, sizeof(ccmd));
		ccmd.nvs_type = HVN_NVS_TYPE_NDIS_CONF;
		ccmd.nvs_mtu = HVN_MAXMTU;
		ccmd.nvs_caps = HVN_NVS_NDIS_CONF_VLAN;

		tid = atomic_inc_int_nv(&sc->sc_nvstid);
		if (hvn_nvs_cmd(sc, &ccmd, sizeof(ccmd), tid, 100))
			return (-1);
	}

	memset(&ncmd, 0, sizeof(ncmd));
	ncmd.nvs_type = HVN_NVS_TYPE_NDIS_INIT;
	if (sc->sc_proto <= HVN_NVS_PROTO_VERSION_4)
		ndisver = NDIS_VERSION_6_1;
	else
		ndisver = NDIS_VERSION_6_30;
	ncmd.nvs_ndis_major = (ndisver & 0xffff0000) >> 16;
	ncmd.nvs_ndis_minor = (ndisver & 0x0000ffff);

	tid = atomic_inc_int_nv(&sc->sc_nvstid);
	if (hvn_nvs_cmd(sc, &ncmd, sizeof(ncmd), tid, 100))
		return (-1);

	sc->sc_ndisver = ndisver;

	return (0);
}

void
hvn_nvs_intr(void *arg)
{
	struct hvn_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct vmbus_chanpkt_hdr *cph;
	struct hvn_nvs_hdr *nvs;
	uint64_t rid;
	uint32_t rlen;
	int rv;

	for (;;) {
		rv = hv_channel_recv(sc->sc_chan, sc->sc_nvsbuf,
		    HVN_NVS_BUFSIZE, &rlen, &rid, 1);
		if (rv != 0 || rlen == 0) {
			if (rv != EAGAIN)
				printf("%s: failed to receive an NVSP "
				    "packet\n", sc->sc_dev.dv_xname);
			break;
		}
		cph = (struct vmbus_chanpkt_hdr *)sc->sc_nvsbuf;
		nvs = (struct hvn_nvs_hdr *)VMBUS_CHANPKT_CONST_DATA(cph);

		if (cph->cph_type == VMBUS_CHANPKT_TYPE_COMP) {
			switch (nvs->nvs_type) {
			case HVN_NVS_TYPE_INIT_RESP:
			case HVN_NVS_TYPE_RXBUF_CONNRESP:
			case HVN_NVS_TYPE_CHIM_CONNRESP:
			case HVN_NVS_TYPE_SUBCH_RESP:
				/* copy the response back */
				memcpy(&sc->sc_nvsrsp, nvs, HVN_NVS_MSGSIZE);
				sc->sc_nvsdone = 1;
				wakeup_one(&sc->sc_nvsrsp);
				break;
			case HVN_NVS_TYPE_RNDIS_ACK:
				hvn_txeof(sc, cph->cph_tid);
				break;
			default:
				printf("%s: unhandled NVSP packet type %u "
				    "on completion\n", sc->sc_dev.dv_xname,
				    nvs->nvs_type);
			}
		} else if (cph->cph_type == VMBUS_CHANPKT_TYPE_RXBUF) {
			switch (nvs->nvs_type) {
			case HVN_NVS_TYPE_RNDIS:
				hvn_rndis_input(sc, cph->cph_tid, cph);
				break;
			default:
				printf("%s: unhandled NVSP packet type %u "
				    "on receive\n", sc->sc_dev.dv_xname,
				    nvs->nvs_type);
			}
		} else
			printf("%s: unknown NVSP packet type %u\n",
			    sc->sc_dev.dv_xname, cph->cph_type);
	}

	if (ifq_is_oactive(&ifp->if_snd))
		ifq_restart(&ifp->if_snd);
}

int
hvn_nvs_cmd(struct hvn_softc *sc, void *cmd, size_t cmdsize, uint64_t tid,
    int timo)
{
	struct hvn_nvs_hdr *hdr = cmd;
	int tries = 10;
	int rv, s;

	KERNEL_ASSERT_LOCKED();

	sc->sc_nvsdone = 0;

	do {
		rv = hv_channel_send(sc->sc_chan, cmd, cmdsize,
		    tid, VMBUS_CHANPKT_TYPE_INBAND,
		    timo ? VMBUS_CHANPKT_FLAG_RC : 0);
		if (rv == EAGAIN) {
			if (cold)
				delay(1000);
			else
				tsleep(cmd, PRIBIO, "nvsout", 1);
		} else if (rv) {
			DPRINTF("%s: NVSP operation %u send error %d\n",
			    sc->sc_dev.dv_xname, hdr->nvs_type, rv);
			return (rv);
		}
	} while (rv != 0 && --tries > 0);

	if (tries == 0 && rv != 0) {
		printf("%s: NVSP operation %u send error %d\n",
		    sc->sc_dev.dv_xname, hdr->nvs_type, rv);
		return (rv);
	}

	do {
		if (cold)
			delay(1000);
		else
			tsleep(sc, PRIBIO | PCATCH, "nvscmd", 1);
		s = splnet();
		hvn_nvs_intr(sc);
		splx(s);
	} while (--timo > 0 && sc->sc_nvsdone != 1);

	if (timo == 0 && sc->sc_nvsdone != 1) {
		printf("%s: NVSP operation %u timed out\n",
		    sc->sc_dev.dv_xname, hdr->nvs_type);
		return (ETIMEDOUT);
	}
	return (0);
}

int
hvn_nvs_ack(struct hvn_softc *sc, uint64_t tid)
{
	struct hvn_nvs_rndis_ack cmd;
	int tries = 5;
	int rv;

	cmd.nvs_type = HVN_NVS_TYPE_RNDIS_ACK;
	cmd.nvs_status = HVN_NVS_STATUS_OK;
	do {
		rv = hv_channel_send(sc->sc_chan, &cmd, sizeof(cmd),
		    tid, VMBUS_CHANPKT_TYPE_COMP, 0);
		if (rv == EAGAIN)
			delay(10);
		else if (rv) {
			DPRINTF("%s: NVSP acknowledgement error %d\n",
			    sc->sc_dev.dv_xname, rv);
			return (rv);
		}
	} while (rv != 0 && --tries > 0);
	return (rv);
}

void
hvn_nvs_detach(struct hvn_softc *sc)
{
	if (hv_channel_close(sc->sc_chan) == 0) {
		free(sc->sc_nvsbuf, M_DEVBUF, HVN_NVS_BUFSIZE);
		sc->sc_nvsbuf = NULL;
	}
}

static inline struct rndis_cmd *
hvn_alloc_cmd(struct hvn_softc *sc)
{
	struct rndis_cmd *rc;

	mtx_enter(&sc->sc_cntl_fqlck);
	while ((rc = TAILQ_FIRST(&sc->sc_cntl_fq)) == NULL)
		msleep(&sc->sc_cntl_fq, &sc->sc_cntl_fqlck,
		    PRIBIO, "nvsalloc", 1);
	TAILQ_REMOVE(&sc->sc_cntl_fq, rc, rc_entry);
	mtx_leave(&sc->sc_cntl_fqlck);
	return (rc);
}

static inline void
hvn_submit_cmd(struct hvn_softc *sc, struct rndis_cmd *rc)
{
	mtx_enter(&sc->sc_cntl_sqlck);
	TAILQ_INSERT_TAIL(&sc->sc_cntl_sq, rc, rc_entry);
	mtx_leave(&sc->sc_cntl_sqlck);
}

static inline struct rndis_cmd *
hvn_complete_cmd(struct hvn_softc *sc, uint32_t id)
{
	struct rndis_cmd *rc;

	mtx_enter(&sc->sc_cntl_sqlck);
	TAILQ_FOREACH(rc, &sc->sc_cntl_sq, rc_entry) {
		if (rc->rc_id == id) {
			TAILQ_REMOVE(&sc->sc_cntl_sq, rc, rc_entry);
			break;
		}
	}
	mtx_leave(&sc->sc_cntl_sqlck);
	if (rc != NULL) {
		mtx_enter(&sc->sc_cntl_cqlck);
		TAILQ_INSERT_TAIL(&sc->sc_cntl_cq, rc, rc_entry);
		mtx_leave(&sc->sc_cntl_cqlck);
	}
	return (rc);
}

static inline void
hvn_release_cmd(struct hvn_softc *sc, struct rndis_cmd *rc)
{
	mtx_enter(&sc->sc_cntl_cqlck);
	TAILQ_REMOVE(&sc->sc_cntl_cq, rc, rc_entry);
	mtx_leave(&sc->sc_cntl_cqlck);
}

static inline int
hvn_rollback_cmd(struct hvn_softc *sc, struct rndis_cmd *rc)
{
	struct rndis_cmd *rn;

	mtx_enter(&sc->sc_cntl_sqlck);
	TAILQ_FOREACH(rn, &sc->sc_cntl_sq, rc_entry) {
		if (rn == rc) {
			TAILQ_REMOVE(&sc->sc_cntl_sq, rc, rc_entry);
			mtx_leave(&sc->sc_cntl_sqlck);
			return (0);
		}
	}
	mtx_leave(&sc->sc_cntl_sqlck);
	return (-1);
}

static inline void
hvn_free_cmd(struct hvn_softc *sc, struct rndis_cmd *rc)
{
	memset(rc->rc_req, 0, sizeof(struct rndis_packet_msg));
	memset(&rc->rc_cmp, 0, sizeof(rc->rc_cmp));
	memset(&rc->rc_msg, 0, sizeof(rc->rc_msg));
	mtx_enter(&sc->sc_cntl_fqlck);
	TAILQ_INSERT_TAIL(&sc->sc_cntl_fq, rc, rc_entry);
	mtx_leave(&sc->sc_cntl_fqlck);
	wakeup(&sc->sc_cntl_fq);
}

int
hvn_rndis_attach(struct hvn_softc *sc)
{
	struct rndis_init_req *req;
	struct rndis_init_comp *cmp;
	struct rndis_cmd *rc;
	int i, rv;

	/* RNDIS control message queues */
	TAILQ_INIT(&sc->sc_cntl_sq);
	TAILQ_INIT(&sc->sc_cntl_cq);
	TAILQ_INIT(&sc->sc_cntl_fq);
	mtx_init(&sc->sc_cntl_sqlck, IPL_NET);
	mtx_init(&sc->sc_cntl_cqlck, IPL_NET);
	mtx_init(&sc->sc_cntl_fqlck, IPL_NET);

	for (i = 0; i < HVN_RNDIS_CTLREQS; i++) {
		rc = &sc->sc_cntl_msgs[i];
		if (bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1,
		    PAGE_SIZE, 0, BUS_DMA_WAITOK, &rc->rc_dmap)) {
			DPRINTF("%s: failed to create RNDIS command map\n",
			    sc->sc_dev.dv_xname);
			goto errout;
		}
		if (bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, PAGE_SIZE,
		    0, &rc->rc_segs, 1, &rc->rc_nsegs, BUS_DMA_NOWAIT |
		    BUS_DMA_ZERO)) {
			DPRINTF("%s: failed to allocate RNDIS command\n",
			    sc->sc_dev.dv_xname);
			bus_dmamap_destroy(sc->sc_dmat, rc->rc_dmap);
			goto errout;
		}
		if (bus_dmamem_map(sc->sc_dmat, &rc->rc_segs, rc->rc_nsegs,
		    PAGE_SIZE, (caddr_t *)&rc->rc_req, BUS_DMA_NOWAIT)) {
			DPRINTF("%s: failed to allocate RNDIS command\n",
			    sc->sc_dev.dv_xname);
			bus_dmamem_free(sc->sc_dmat, &rc->rc_segs,
			    rc->rc_nsegs);
			bus_dmamap_destroy(sc->sc_dmat, rc->rc_dmap);
			goto errout;
		}
		if (bus_dmamap_load(sc->sc_dmat, rc->rc_dmap, rc->rc_req,
		    PAGE_SIZE, NULL, BUS_DMA_WAITOK)) {
			DPRINTF("%s: failed to load RNDIS command map\n",
			    sc->sc_dev.dv_xname);
			bus_dmamem_free(sc->sc_dmat, &rc->rc_segs,
			    rc->rc_nsegs);
			bus_dmamap_destroy(sc->sc_dmat, rc->rc_dmap);
			goto errout;
		}
		rc->rc_gpa = atop(rc->rc_dmap->dm_segs[0].ds_addr);
		TAILQ_INSERT_TAIL(&sc->sc_cntl_fq, rc, rc_entry);
	}

	rc = hvn_alloc_cmd(sc);

	bus_dmamap_sync(sc->sc_dmat, rc->rc_dmap, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREREAD);

	rc->rc_id = atomic_inc_int_nv(&sc->sc_rndisrid);

	req = rc->rc_req;
	req->rm_type = REMOTE_NDIS_INITIALIZE_MSG;
	req->rm_len = sizeof(*req);
	req->rm_rid = rc->rc_id;
	req->rm_ver_major = RNDIS_VERSION_MAJOR;
	req->rm_ver_minor = RNDIS_VERSION_MINOR;
	req->rm_max_xfersz = HVN_RNDIS_XFER_SIZE;

	rc->rc_cmplen = sizeof(*cmp);

	bus_dmamap_sync(sc->sc_dmat, rc->rc_dmap, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE);

	if ((rv = hvn_rndis_cmd(sc, rc, 500)) != 0) {
		DPRINTF("%s: INITIALIZE_MSG failed, error %d\n",
		    sc->sc_dev.dv_xname, rv);
		hvn_free_cmd(sc, rc);
		goto errout;
	}
	cmp = (struct rndis_init_comp *)&rc->rc_cmp;
	if (cmp->rm_status != RNDIS_STATUS_SUCCESS) {
		DPRINTF("%s: failed to init RNDIS, error %#x\n",
		    sc->sc_dev.dv_xname, cmp->rm_status);
		hvn_free_cmd(sc, rc);
		goto errout;
	}

	hvn_free_cmd(sc, rc);

	/* Initialize RNDIS Data command */
	memset(&sc->sc_data_msg, 0, sizeof(sc->sc_data_msg));
	sc->sc_data_msg.nvs_type = HVN_NVS_TYPE_RNDIS;
	sc->sc_data_msg.nvs_rndis_mtype = HVN_NVS_RNDIS_MTYPE_DATA;
	sc->sc_data_msg.nvs_chim_idx = HVN_NVS_CHIM_IDX_INVALID;

	return (0);

errout:
	for (i = 0; i < HVN_RNDIS_CTLREQS; i++) {
		rc = &sc->sc_cntl_msgs[i];
		if (rc->rc_req == NULL)
			continue;
		TAILQ_REMOVE(&sc->sc_cntl_fq, rc, rc_entry);
		bus_dmamem_free(sc->sc_dmat, &rc->rc_segs, rc->rc_nsegs);
		rc->rc_req = NULL;
		bus_dmamap_destroy(sc->sc_dmat, rc->rc_dmap);
	}
	return (-1);
}

int
hvn_set_capabilities(struct hvn_softc *sc)
{
	struct ndis_offload_params params;
	size_t len = sizeof(params);

	memset(&params, 0, sizeof(params));

	params.ndis_hdr.ndis_type = NDIS_OBJTYPE_DEFAULT;
	if (sc->sc_ndisver < NDIS_VERSION_6_30) {
		params.ndis_hdr.ndis_rev = NDIS_OFFLOAD_PARAMS_REV_2;
		len = params.ndis_hdr.ndis_size = NDIS_OFFLOAD_PARAMS_SIZE_6_1;
	} else {
		params.ndis_hdr.ndis_rev = NDIS_OFFLOAD_PARAMS_REV_3;
		len = params.ndis_hdr.ndis_size = NDIS_OFFLOAD_PARAMS_SIZE;
	}

	params.ndis_ip4csum = NDIS_OFFLOAD_PARAM_TXRX;
	params.ndis_tcp4csum = NDIS_OFFLOAD_PARAM_TXRX;
	params.ndis_tcp6csum = NDIS_OFFLOAD_PARAM_TXRX;
	if (sc->sc_ndisver >= NDIS_VERSION_6_30) {
		params.ndis_udp4csum = NDIS_OFFLOAD_PARAM_TXRX;
		params.ndis_udp6csum = NDIS_OFFLOAD_PARAM_TXRX;
	}

	return (hvn_rndis_set(sc, OID_TCP_OFFLOAD_PARAMETERS, &params, len));
}

int
hvn_rndis_cmd(struct hvn_softc *sc, struct rndis_cmd *rc, int timo)
{
	struct hvn_nvs_rndis *msg = &rc->rc_msg;
	struct rndis_msghdr *hdr = rc->rc_req;
	struct vmbus_gpa sgl[1];
	int tries = 10;
	int rv, s;

	KERNEL_ASSERT_LOCKED();

	KASSERT(timo > 0);

	msg->nvs_type = HVN_NVS_TYPE_RNDIS;
	msg->nvs_rndis_mtype = HVN_NVS_RNDIS_MTYPE_CTRL;
	msg->nvs_chim_idx = HVN_NVS_CHIM_IDX_INVALID;

	sgl[0].gpa_page = rc->rc_gpa;
	sgl[0].gpa_len = hdr->rm_len;
	sgl[0].gpa_ofs = 0;

	rc->rc_done = 0;

	hvn_submit_cmd(sc, rc);

	do {
		rv = hv_channel_send_sgl(sc->sc_chan, sgl, 1, &rc->rc_msg,
		    sizeof(*msg), rc->rc_id);
		if (rv == EAGAIN) {
			if (cold)
				delay(100);
			else
				tsleep(rc, PRIBIO, "rndisout", 1);
		} else if (rv) {
			DPRINTF("%s: RNDIS operation %u send error %d\n",
			    sc->sc_dev.dv_xname, hdr->rm_type, rv);
			hvn_rollback_cmd(sc, rc);
			return (rv);
		}
	} while (rv != 0 && --tries > 0);

	if (tries == 0 && rv != 0) {
		printf("%s: RNDIS operation %u send error %d\n",
		    sc->sc_dev.dv_xname, hdr->rm_type, rv);
		return (rv);
	}

	bus_dmamap_sync(sc->sc_dmat, rc->rc_dmap, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTWRITE);

	do {
		if (cold)
			delay(1000);
		else
			tsleep(rc, PRIBIO | PCATCH, "rndiscmd", 1);
		s = splnet();
		hvn_nvs_intr(sc);
		splx(s);
	} while (--timo > 0 && rc->rc_done != 1);

	bus_dmamap_sync(sc->sc_dmat, rc->rc_dmap, 0, PAGE_SIZE,
	    BUS_DMASYNC_POSTREAD);

	if (rc->rc_done != 1) {
		rv = timo == 0 ? ETIMEDOUT : EINTR;
		if (hvn_rollback_cmd(sc, rc)) {
			hvn_release_cmd(sc, rc);
			rv = 0;
		} else if (rv == ETIMEDOUT) {
			printf("%s: RNDIS operation %u timed out\n",
			    sc->sc_dev.dv_xname, hdr->rm_type);
		}
		return (rv);
	}

	hvn_release_cmd(sc, rc);
	return (0);
}

void
hvn_rndis_input(struct hvn_softc *sc, uint64_t tid, void *arg)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct vmbus_chanpkt_prplist *cp = arg;
	uint32_t off, len, type;
	int i;

	if (sc->sc_rx_ring == NULL) {
		DPRINTF("%s: invalid rx ring\n", sc->sc_dev.dv_xname);
		return;
	}
	for (i = 0; i < cp->cp_range_cnt; i++) {
		off = cp->cp_range[i].gpa_ofs;
		len = cp->cp_range[i].gpa_len;

		KASSERT(off + len <= sc->sc_rx_size);
		KASSERT(len >= RNDIS_HEADER_OFFSET + 4);

		memcpy(&type, (caddr_t)sc->sc_rx_ring + off, sizeof(type));
		switch (type) {
		/* data message */
		case REMOTE_NDIS_PACKET_MSG:
			hvn_rxeof(sc, (caddr_t)sc->sc_rx_ring +
			    off, len, &ml);
			break;
		/* completion messages */
		case REMOTE_NDIS_INITIALIZE_CMPLT:
		case REMOTE_NDIS_QUERY_CMPLT:
		case REMOTE_NDIS_SET_CMPLT:
		case REMOTE_NDIS_RESET_CMPLT:
		case REMOTE_NDIS_KEEPALIVE_CMPLT:
			hvn_rndis_complete(sc, (caddr_t)sc->sc_rx_ring +
			    off, len);
			break;
		/* notification message */
		case REMOTE_NDIS_INDICATE_STATUS_MSG:
			hvn_rndis_status(sc, (caddr_t)sc->sc_rx_ring +
			    off, len);
			break;
		default:
			printf("%s: unhandled RNDIS message type %u\n",
			    sc->sc_dev.dv_xname, type);
		}
	}
	hvn_nvs_ack(sc, tid);

	if_input(ifp, &ml);
}

static inline struct mbuf *
hvn_devget(struct hvn_softc *sc, caddr_t buf, uint32_t len)
{
	struct mbuf *m;

	if (len + ETHER_ALIGN <= MHLEN)
		MGETHDR(m, M_NOWAIT, MT_DATA);
	else
		m = MCLGETI(NULL, M_NOWAIT, NULL, len + ETHER_ALIGN);
	if (m == NULL)
		return (NULL);
	m->m_len = m->m_pkthdr.len = len;
	m_adj(m, ETHER_ALIGN);

	if (m_copyback(m, 0, len, buf, M_NOWAIT)) {
		m_freem(m);
		return (NULL);
	}

	return (m);
}

void
hvn_rxeof(struct hvn_softc *sc, caddr_t buf, uint32_t len, struct mbuf_list *ml)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct rndis_packet_msg *pkt;
	struct rndis_pktinfo *pi;
	uint32_t csum, vlan;
	struct mbuf *m;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (len < sizeof(*pkt)) {
		printf("%s: data packet too short: %u\n",
		    sc->sc_dev.dv_xname, len);
		return;
	}

	pkt = (struct rndis_packet_msg *)buf;

	if (pkt->rm_dataoffset + pkt->rm_datalen > len) {
		printf("%s: data packet out of bounds: %u@@%u\n",
		    sc->sc_dev.dv_xname, pkt->rm_dataoffset, pkt->rm_datalen);
		return;
	}

	if ((m = hvn_devget(sc, buf + RNDIS_HEADER_OFFSET + pkt->rm_dataoffset,
	    pkt->rm_datalen)) == NULL) {
		ifp->if_ierrors++;
		return;
	}

	if (pkt->rm_pktinfooffset + pkt->rm_pktinfolen > len) {
		printf("%s: pktinfo is out of bounds: %u@@%u vs %u\n",
		    sc->sc_dev.dv_xname, pkt->rm_pktinfolen,
		    pkt->rm_pktinfooffset, len);
		goto done;
	}
	pi = (struct rndis_pktinfo *)((caddr_t)pkt + RNDIS_HEADER_OFFSET +
	    pkt->rm_pktinfooffset);
	while (pkt->rm_pktinfolen > 0) {
		if (pi->rm_size > pkt->rm_pktinfolen) {
			printf("%s: invalid pktinfo size: %u/%u\n",
			    sc->sc_dev.dv_xname, pi->rm_size,
			    pkt->rm_pktinfolen);
			break;
		}
		switch (pi->rm_type) {
		case NDIS_PKTINFO_TYPE_CSUM:
			memcpy(&csum, pi->rm_data, sizeof(csum));
			if (csum & NDIS_RXCSUM_INFO_IPCS_OK)
				m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;
			if (csum & NDIS_RXCSUM_INFO_TCPCS_OK)
				m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_OK;
			if (csum & NDIS_RXCSUM_INFO_UDPCS_OK)
				m->m_pkthdr.csum_flags |= M_UDP_CSUM_IN_OK;
			break;
		case NDIS_PKTINFO_TYPE_VLAN:
			memcpy(&vlan, pi->rm_data, sizeof(vlan));
#if NVLAN > 0
			if (vlan != 0xffffffff) {
				m->m_pkthdr.ether_vtag =
				    NDIS_VLAN_INFO_ID(vlan) |
				    (NDIS_VLAN_INFO_PRI(vlan) << EVL_PRIO_BITS);
				m->m_flags |= M_VLANTAG;
			}
#endif
			break;
		default:
			DPRINTF("%s: unhandled pktinfo type %u\n",
			    sc->sc_dev.dv_xname, pi->rm_type);
		}
		pkt->rm_pktinfolen -= pi->rm_size;
		pi = (struct rndis_pktinfo *)((caddr_t)pi + pi->rm_size);
	}

 done:
	ml_enqueue(ml, m);
}

void
hvn_rndis_complete(struct hvn_softc *sc, caddr_t buf, uint32_t len)
{
	struct rndis_cmd *rc;
	uint32_t id;

	memcpy(&id, buf + RNDIS_HEADER_OFFSET, sizeof(id));
	if ((rc = hvn_complete_cmd(sc, id)) != NULL) {
		if (len < rc->rc_cmplen)
			printf("%s: RNDIS response %u too short: %u\n",
			    sc->sc_dev.dv_xname, id, len);
		else
			memcpy(&rc->rc_cmp, buf, rc->rc_cmplen);
		if (len > rc->rc_cmplen &&
		    len - rc->rc_cmplen > HVN_RNDIS_BUFSIZE)
			printf("%s: RNDIS response %u too large: %u\n",
			    sc->sc_dev.dv_xname, id, len);
		else if (len > rc->rc_cmplen)
			memcpy(&rc->rc_cmpbuf, buf + rc->rc_cmplen,
			    len - rc->rc_cmplen);
		rc->rc_done = 1;
		wakeup_one(rc);
	} else
		DPRINTF("%s: failed to complete RNDIS request id %u\n",
		    sc->sc_dev.dv_xname, id);
}

int
hvn_rndis_output(struct hvn_softc *sc, struct hvn_tx_desc *txd)
{
	uint64_t rid = (uint64_t)txd->txd_id << 32;
	int rv;

	rv = hv_channel_send_sgl(sc->sc_chan, txd->txd_sgl, txd->txd_nsge,
	    &sc->sc_data_msg, sizeof(sc->sc_data_msg), rid);
	if (rv) {
		DPRINTF("%s: RNDIS data send error %d\n",
		    sc->sc_dev.dv_xname, rv);
		return (rv);
	}

	return (0);
}

void
hvn_rndis_status(struct hvn_softc *sc, caddr_t buf, uint32_t len)
{
	uint32_t status;

	memcpy(&status, buf + RNDIS_HEADER_OFFSET, sizeof(status));
	switch (status) {
	case RNDIS_STATUS_MEDIA_CONNECT:
		sc->sc_link_state = LINK_STATE_UP;
		break;
	case RNDIS_STATUS_MEDIA_DISCONNECT:
		sc->sc_link_state = LINK_STATE_DOWN;
		break;
	/* Ignore these */
	case RNDIS_STATUS_OFFLOAD_CURRENT_CONFIG:
		return;
	default:
		DPRINTF("%s: unhandled status %#x\n", sc->sc_dev.dv_xname,
		    status);
		return;
	}
	KERNEL_LOCK();
	hvn_link_status(sc);
	KERNEL_UNLOCK();
}

int
hvn_rndis_query(struct hvn_softc *sc, uint32_t oid, void *res, size_t *length)
{
	struct rndis_cmd *rc;
	struct rndis_query_req *req;
	struct rndis_query_comp *cmp;
	size_t olength = *length;
	int rv;

	rc = hvn_alloc_cmd(sc);

	bus_dmamap_sync(sc->sc_dmat, rc->rc_dmap, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREREAD);

	rc->rc_id = atomic_inc_int_nv(&sc->sc_rndisrid);

	req = rc->rc_req;
	req->rm_type = REMOTE_NDIS_QUERY_MSG;
	req->rm_len = sizeof(*req);
	req->rm_rid = rc->rc_id;
	req->rm_oid = oid;
	req->rm_infobufoffset = sizeof(*req) - RNDIS_HEADER_OFFSET;

	rc->rc_cmplen = sizeof(*cmp);

	bus_dmamap_sync(sc->sc_dmat, rc->rc_dmap, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE);

	if ((rv = hvn_rndis_cmd(sc, rc, 500)) != 0) {
		DPRINTF("%s: QUERY_MSG failed, error %d\n",
		    sc->sc_dev.dv_xname, rv);
		hvn_free_cmd(sc, rc);
		return (rv);
	}

	cmp = (struct rndis_query_comp *)&rc->rc_cmp;
	switch (cmp->rm_status) {
	case RNDIS_STATUS_SUCCESS:
		if (cmp->rm_infobuflen > olength) {
			rv = EINVAL;
			break;
		}
		memcpy(res, rc->rc_cmpbuf, cmp->rm_infobuflen);
		*length = cmp->rm_infobuflen;
		break;
	default:
		*length = 0;
		rv = EIO;
	}

	hvn_free_cmd(sc, rc);

	return (rv);
}

int
hvn_rndis_set(struct hvn_softc *sc, uint32_t oid, void *data, size_t length)
{
	struct rndis_cmd *rc;
	struct rndis_set_req *req;
	struct rndis_set_comp *cmp;
	int rv;

	rc = hvn_alloc_cmd(sc);

	bus_dmamap_sync(sc->sc_dmat, rc->rc_dmap, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREREAD);

	rc->rc_id = atomic_inc_int_nv(&sc->sc_rndisrid);

	req = rc->rc_req;
	req->rm_type = REMOTE_NDIS_SET_MSG;
	req->rm_len = sizeof(*req) + length;
	req->rm_rid = rc->rc_id;
	req->rm_oid = oid;
	req->rm_infobufoffset = sizeof(*req) - RNDIS_HEADER_OFFSET;

	rc->rc_cmplen = sizeof(*cmp);

	if (length > 0) {
		KASSERT(sizeof(*req) + length < PAGE_SIZE);
		req->rm_infobuflen = length;
		memcpy((caddr_t)(req + 1), data, length);
	}

	bus_dmamap_sync(sc->sc_dmat, rc->rc_dmap, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE);

	if ((rv = hvn_rndis_cmd(sc, rc, 500)) != 0) {
		DPRINTF("%s: SET_MSG failed, error %d\n",
		    sc->sc_dev.dv_xname, rv);
		hvn_free_cmd(sc, rc);
		return (rv);
	}

	cmp = (struct rndis_set_comp *)&rc->rc_cmp;
	if (cmp->rm_status != RNDIS_STATUS_SUCCESS)
		rv = EIO;

	hvn_free_cmd(sc, rc);

	return (rv);
}

int
hvn_rndis_open(struct hvn_softc *sc)
{
	uint32_t filter;
	int rv;

	if (sc->sc_promisc)
		filter = NDIS_PACKET_TYPE_PROMISCUOUS;
	else
		filter = NDIS_PACKET_TYPE_BROADCAST |
		    NDIS_PACKET_TYPE_ALL_MULTICAST |
		    NDIS_PACKET_TYPE_DIRECTED;

	rv = hvn_rndis_set(sc, OID_GEN_CURRENT_PACKET_FILTER,
	    &filter, sizeof(filter));
	if (rv)
		DPRINTF("%s: failed to set RNDIS filter to %#x\n",
		    sc->sc_dev.dv_xname, filter);
	return (rv);
}

int
hvn_rndis_close(struct hvn_softc *sc)
{
	uint32_t filter = 0;
	int rv;

	rv = hvn_rndis_set(sc, OID_GEN_CURRENT_PACKET_FILTER,
	    &filter, sizeof(filter));
	if (rv)
		DPRINTF("%s: failed to clear RNDIS filter\n",
		    sc->sc_dev.dv_xname);
	return (rv);
}

void
hvn_rndis_detach(struct hvn_softc *sc)
{
	struct rndis_cmd *rc;
	struct rndis_halt_req *req;
	int rv;

	rc = hvn_alloc_cmd(sc);

	bus_dmamap_sync(sc->sc_dmat, rc->rc_dmap, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREREAD);

	rc->rc_id = atomic_inc_int_nv(&sc->sc_rndisrid);

	req = rc->rc_req;
	req->rm_type = REMOTE_NDIS_HALT_MSG;
	req->rm_len = sizeof(*req);
	req->rm_rid = rc->rc_id;

	bus_dmamap_sync(sc->sc_dmat, rc->rc_dmap, 0, PAGE_SIZE,
	    BUS_DMASYNC_PREWRITE);

	if ((rv = hvn_rndis_cmd(sc, rc, 500)) != 0)
		DPRINTF("%s: HALT_MSG failed, error %d\n",
		    sc->sc_dev.dv_xname, rv);

	hvn_free_cmd(sc, rc);
}
@


1.34
log
@Fixup format strings in debug messages found by cppcheck
@
text
@d97 1
a97 1
	struct mutex			 rc_mtx;
d146 1
a146 1
	struct mutex			 sc_nvslck;
d249 1
a249 1
	DPRINTF("\n");
d580 1
a580 1
	/* Attach an RNDIS message into the first slot */
a904 2
	mtx_init(&sc->sc_nvslck, IPL_NET);

d984 1
d1020 5
a1024 1
	int rv;
d1031 2
a1032 2
			if (timo)
				tsleep(cmd, PRIBIO, "nvsout", timo / 10);
d1034 1
a1034 1
				delay(100);
d1042 20
a1061 8
	if (timo) {
		mtx_enter(&sc->sc_nvslck);
		rv = msleep(&sc->sc_nvsrsp, &sc->sc_nvslck, PRIBIO, "nvscmd",
		    timo);
		mtx_leave(&sc->sc_nvslck);
		if (rv == EWOULDBLOCK)
			printf("%s: NVSP operation %u timed out\n",
			    sc->sc_dev.dv_xname, hdr->nvs_type);
d1063 1
a1063 1
	return (rv);
d1079 1
a1079 1
			delay(100);
a1228 1
		mtx_init(&rc->rc_mtx, IPL_NET);
d1324 3
a1326 1
	int rv;
d1338 2
d1345 6
a1350 3
		if (rv == EAGAIN)
			tsleep(rc, PRIBIO, "rndisout", timo / 10);
		else if (rv) {
d1358 6
d1367 9
a1375 3
	mtx_enter(&rc->rc_mtx);
	rv = msleep(rc, &rc->rc_mtx, PRIBIO | PCATCH, "rndiscmd", timo);
	mtx_leave(&rc->rc_mtx);
d1380 2
a1381 6
	switch (rv) {
	case 0:
		hvn_release_cmd(sc, rc);
		break;
	case EINTR:
	case EWOULDBLOCK:
d1385 1
a1385 1
		} else if (rv == EWOULDBLOCK) {
d1389 1
a1389 1
		break;
d1391 3
a1393 1
	return (rv);
d1569 1
@


1.33
log
@Fixup format string and type issues found by cppcheck
@
text
@d683 1
a683 1
		DPRINTF("%s: invalid number of Rx ring sections: %d\n",
d1033 1
a1033 1
			DPRINTF("%s: NVSP operation %d send error %d\n",
d1239 1
a1239 1
		DPRINTF("%s: INITIALIZE_MSG failed, error %u\n",
d1330 1
a1330 1
			DPRINTF("%s: RNDIS operation %d send error %d\n",
d1676 1
a1676 1
		DPRINTF("%s: SET_MSG failed, error %u\n",
d1749 1
a1749 1
		DPRINTF("%s: HALT_MSG failed, error %u\n",
@


1.32
log
@add support for multiple transmit ifqueues per network interface.

an ifq to transmit a packet is picked by the current traffic
conditioner (ie, priq or hfsc) by providing an index into an array
of ifqs. by default interfaces get a single ifq but can ask for
more using if_attach_queues().

the vast majority of our drivers still think there's a 1:1 mapping
between interfaces and transmit queues, so their if_start routines
take an ifnet pointer instead of a pointer to the ifqueue struct.
instead of changing all the drivers in the tree, drivers can opt
into using an if_qstart routine and setting the IFXF_MPSAFE flag.
the stack provides a compatability wrapper from the new if_qstart
handler to the previous if_start handlers if IFXF_MPSAFE isnt set.

enabling hfsc on an interface configures it to transmit everything
through the first ifq. any other ifqs are left configured as priq,
but unused, when hfsc is enabled.

getting this in now so everyone can kick the tyres.

ok mpi@@ visa@@ (who provided some tweaks for cnmac).
@
text
@d311 1
a311 1
	printf(" channel %u: NVS %u.%u NDIS %u.%u, address %s\n",
d992 1
a992 1
				printf("%s: unhandled NVSP packet type %d "
d1002 1
a1002 1
				printf("%s: unhandled NVSP packet type %d "
d1045 1
a1045 1
			printf("%s: NVSP operation %d timed out\n",
d1357 1
a1357 1
			printf("%s: RNDIS operation %d timed out\n",
@


1.31
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d182 1
a182 1
void	hvn_start(struct ifnet *);
d269 1
a269 1
	ifp->if_start = hvn_start;
d323 1
a323 1
	if (ifp->if_start)
d444 1
a444 1
hvn_start(struct ifnet *ifp)
d446 1
a450 3
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

d454 1
a454 1
			ifq_set_oactive(&ifp->if_snd);
d458 1
a458 1
		m = ifq_dequeue(&ifp->if_snd);
@


1.30
log
@Fixup typos reported by Adam Jeanguenat <avj at fig ! 6v6 ! org>, thanks!
@
text
@a483 2

		ifp->if_opackets++;
@


1.29
log
@Checking whether mbuf list is empty is done by the if_input now
@
text
@d1049 1
a1049 1
			printf("%s: NVSP opertaion %d timed out\n",
d1361 1
a1361 1
			printf("%s: RNDIS opertaion %d timed out\n",
@


1.28
log
@Disable debugging output
@
text
@d1417 1
a1417 2
	if (MBUF_LIST_FIRST(&ml))
		if_input(ifp, &ml);
@


1.27
log
@Always attempt to restart the transmission when OACTIVE is set

There's not much point in adding an additional condition to the
ifq_restart call so just get rid of those bits.  Also while here,
remove a debugging message and make sure to cleanup the whole RNDIS
packet before sending it out to the hypervisor.
@
text
@a76 2
#define HVN_DEBUG			1

@


1.26
log
@Bump the number of TX descriptors to 256

By increasing the number of available TX descriptors we also get
a larger NVS message ring.  Altogether this results in about 30%
performance improvement.

While here, offset all TX descriptor IDs by a fixed amount so that
the Transaction ID 0 to descriptor ID mapping produces a non-zero
result making error handling more reliable.
@
text
@d187 1
a187 1
int	hvn_txeof(struct hvn_softc *, uint64_t);
d529 1
a529 1
	memset(pkt, 0, sizeof(*pkt));
d618 1
a618 1
int
d626 1
a626 1
		return (0);
a645 1
	return (1);
a899 2
	DPRINTF("%s: ring size %u (%u pages)\n", __func__, ringsize,
	    roundup(ringsize, PAGE_SIZE) / PAGE_SIZE);
d970 1
a970 1
	int rv, restart = 0;
d995 1
a995 1
				restart |= hvn_txeof(sc, cph->cph_tid);
d1017 1
a1017 1
	if (restart && ifq_is_oactive(&ifp->if_snd))
@


1.25
log
@Reorder atomic operations dealing with sc_tx_avail

The atomic decrement of the number of available descriptors must
be performed before sending the RNDIS message to the hypervisor
so that packet transmit completion that may execute in parallel
won't increase the value past the maximum.
@
text
@d111 1
a111 1
#define HVN_TX_DESC			128
d123 1
a123 1
	volatile int			 txd_ready;
a142 1

a143 1
	int				 sc_ringsize;
d547 1
d627 1
d791 1
a791 1
		txd->txd_id = i;
d884 1
a885 1
	uint32_t ndisver;
d897 1
a897 1
	sc->sc_ringsize = HVN_RNDIS_CTLREQS *
d901 2
d905 1
a905 1
	if (hv_channel_open(sc->sc_chan, sc->sc_ringsize, NULL, 0,
@


1.24
log
@Restart the IFQ transmit routine only once per interrupt
@
text
@d123 1
a123 1
	int				 txd_ready;
a487 3
		sc->sc_tx_next %= HVN_TX_DESC;

		atomic_dec_int(&sc->sc_tx_avail);
d524 2
a525 2
	txd = &sc->sc_tx_desc[sc->sc_tx_next];
	while (!txd->txd_ready) {
d527 2
a528 3
		sc->sc_tx_next %= HVN_TX_DESC;
		txd = &sc->sc_tx_desc[sc->sc_tx_next];
	}
d601 3
d616 1
@


1.23
log
@RNDIS data command is always the same and can be reused
@
text
@d189 1
a189 1
void	hvn_txeof(struct hvn_softc *, uint64_t);
d619 1
a619 1
void
a621 1
	struct ifnet *ifp = &sc->sc_ac.ac_if;
d626 2
a627 2
	if ((tid & 0xffffffff) != 0)
		return;
d646 1
a646 2
	if (ifq_is_oactive(&ifp->if_snd))
		ifq_restart(&ifp->if_snd);
d966 1
d971 1
a971 1
	int rv;
d996 1
a996 1
				hvn_txeof(sc, cph->cph_tid);
d1017 3
@


1.22
log
@Don't forget to set the descriptor ready flag after decapsulation
@
text
@a128 1
	struct hvn_nvs_rndis		 txd_cmd;
d162 1
d1259 6
d1553 1
a1553 1
	struct hvn_nvs_rndis *cmd = &txd->txd_cmd;
a1555 4
	cmd->nvs_type = HVN_NVS_TYPE_RNDIS;
	cmd->nvs_rndis_mtype = HVN_NVS_RNDIS_MTYPE_DATA;
	cmd->nvs_chim_idx = HVN_NVS_CHIM_IDX_INVALID;

d1557 1
a1557 1
	    &txd->txd_cmd, sizeof(*cmd), (uint64_t)txd->txd_id << 32);
d1570 1
a1570 1
	uint32_t sta;
d1572 2
a1573 2
	memcpy(&sta, buf + RNDIS_HEADER_OFFSET, sizeof(sta));
	switch (sta) {
d1584 2
a1585 1
		DPRINTF("%s: unhandled status %#x\n", sc->sc_dev.dv_xname, sta);
@


1.21
log
@Channel API users should pick the bufring size

hvn(4) needs to be able to put up to 128 RNDIS data messages on the
channel ring each pointing up to 16 fragments in addition to a small
number of RNDIS control messages.  This simplifies accounting of
available TX descriptors in relation to the available space on the
channel ring and as a results prevents packet drops due to the ring
being full.
@
text
@a526 1
	/* XXX use queues? */
d616 1
@


1.20
log
@Implement an operation to dequeue packets from the completion queue

Complete the RNDIS command submission API with a proper method of
command dequeuing from the completion queue.  Command timeout path
can be fully implemented now.

While here let the command completion wait interruptable.
@
text
@a78 1
#define HVN_NVS_BUFSIZE		  	PAGE_SIZE
d80 1
d86 1
a86 1
#define HVN_RNDIS_CMPBUFSZ		512
d98 1
a98 1
	uint8_t				 rc_cmpbuf[HVN_RNDIS_CMPBUFSZ];
d144 1
d146 1
d890 2
a891 3
	/* 4 page sized buffer for channel messages */
	sc->sc_nvsbuf = km_alloc(HVN_NVS_BUFSIZE, &kv_any, &kp_zero,
	    (cold ? &kd_nowait : &kd_waitok));
d898 6
d905 2
a906 1
	if (hv_channel_open(sc->sc_chan, NULL, 0, hvn_nvs_intr, sc)) {
d908 1
a908 1
		km_free(sc->sc_nvsbuf, HVN_NVS_BUFSIZE, &kv_any, &kp_zero);
d1034 1
a1034 1
				tsleep(cmd, PRIBIO, "hvnsend", timo / 10);
d1046 1
a1046 1
		rv = msleep(&sc->sc_nvsrsp, &sc->sc_nvslck, PRIBIO, "hvnvsp",
d1083 1
a1083 1
		km_free(sc->sc_nvsbuf, HVN_NVS_BUFSIZE, &kv_any, &kp_zero);
d1096 1
a1096 1
		    PRIBIO, "hvnrr", 1);
d1327 1
a1327 1
			tsleep(rc, PRIBIO, "hvnsendbuf", timo / 10);
d1331 1
d1340 1
a1340 1
	rv = msleep(rc, &rc->rc_mtx, PRIBIO | PCATCH, "rndisctl", timo);
d1532 1
a1532 1
		    len - rc->rc_cmplen > HVN_RNDIS_CMPBUFSZ)
@


1.19
log
@Get rid of the ch_buf member that is not part of the channel API

Devices need to allocate appropriate input/output buffers for use
with the VMBus channel API themselves.  There's no reason to keep
pointers to these buffers in the channel structure.

This requires a bit of restructuring of the code attaching internal
devices however.
@
text
@d1041 1
a1041 6
#ifdef HVN_DEBUG
		switch (rv) {
		case EINTR:
			rv = 0;
			break;
		case EWOULDBLOCK:
a1043 1
		}
a1044 1
#endif
d1123 8
d1331 1
a1331 1
	rv = msleep(rc, &rc->rc_mtx, PRIBIO, "rndisctl", timo);
a1336 1
#ifdef HVN_DEBUG
d1338 3
a1341 2
		rv = 0;
		break;
d1344 1
a1344 2
			/* failed to rollback? go for one sleep cycle */
			tsleep(rc, PRIBIO, "rndisctl2", 1);
d1346 3
a1348 1
			break;
d1350 1
a1350 2
		printf("%s: RNDIS opertaion %d timed out\n", sc->sc_dev.dv_xname,
		    hdr->rm_type);
a1351 1
#endif
@


1.18
log
@Enable hardware VLAN tagging

Turns out that hardware VLAN tagging is required to use VLANs at all
(while QinQ VLANs are not filtered regardless...). On top of that a
PowerShell command needs to be executed to configure Trunk mode on
virtual interfaces.  An example of such command is:

    Set-VMNetworkAdapterVlan -VMName OpenBSD -Trunk \
        -AllowedVlanIdList 10-100 -NativeVlanId 5

This will enable trunking mode on all hvn(4) interfaces.  An option
-VMNetworkAdapterName can be passed to turn trunking on one interface,
and although by default all networking interfaces have the same name
"Network Adapter", a "Rename-VMNetworkAdapter" command can be used
to rename them one by one.
@
text
@a895 1
	sc->sc_chan->ch_buflen = PAGE_SIZE * 4;
@


1.17
log
@Rework Per Packet Info handling

Per Packet Info is an NDIS meta information embedded in the RNDIS
message to communicate various offloading and scheduling operations
with the backend.  Due to various versions of NDIS supported by
Hyper-V some of the offloading features may or may not be available.

This commit brings support for IP and protocol checksum offloading
as well as initial code for hardware VLAN tagging and jumbo frames
where supported.
@
text
@d281 1
a281 1
#if NVLAN > 0 && notyet
@


1.16
log
@Setup checksum offloading instead of relying on the default configuraiton
@
text
@d2 1
a2 1
 * Copyright (c) 2009-2012 Microsoft Corp.
a87 4
#define HVN_RNDIS_MSG_LEN		\
	(sizeof(struct rndis_packet_msg) + NDIS_VLAN_INFO_SIZE + \
	 NDIS_RXCSUM_INFO_SIZE)

d112 1
a112 1
#define HVN_TX_FRAGS			31
d116 5
d494 22
d520 1
d522 2
a523 2
	size_t rlen;
	int i;
d533 8
a540 6
	memset(txd->txd_req, 0, sizeof(*txd->txd_req));
	txd->txd_req->rm_type = REMOTE_NDIS_PACKET_MSG;
	txd->txd_req->rm_dataoffset = RNDIS_DATA_OFFSET;
	txd->txd_req->rm_datalen = m->m_pkthdr.len;
	txd->txd_req->rm_pktinfooffset = RNDIS_DATA_OFFSET;
	rlen = sizeof(struct rndis_packet_msg);
d542 11
a552 2
	if (bus_dmamap_load_mbuf(sc->sc_dmat, txd->txd_dmap, m, BUS_DMA_READ |
	    BUS_DMA_NOWAIT)) {
d558 28
a585 1
	/* Per-packet info adjusts rlen */
d587 2
a588 2
	/* Final length value for the RNDIS header and data */
	txd->txd_req->rm_len = txd->txd_req->rm_datalen + rlen;
d593 1
a593 1
	txd->txd_sgl[0].gpa_len = rlen;
d747 1
a747 1
	msgsize = roundup(HVN_RNDIS_MSG_LEN, 128);
d830 1
a830 1
		size_t msgsize = roundup(HVN_RNDIS_MSG_LEN, 128);
d1431 1
a1431 2
hvn_rxeof(struct hvn_softc *sc, caddr_t buf, uint32_t len,
    struct mbuf_list *ml)
d1442 1
a1442 1
	if (len < RNDIS_HEADER_OFFSET + sizeof(*pkt)) {
d1462 6
a1470 6
		if (pkt->rm_pktinfooffset + pkt->rm_pktinfolen > len) {
			printf("%s: PI out of bounds: %u@@%u\n",
			    sc->sc_dev.dv_xname, pkt->rm_pktinfolen,
			    pkt->rm_pktinfooffset);
			break;
		}
d1472 1
a1472 1
			printf("%s: invalid PI size: %u/%u\n",
d1479 1
a1479 1
			memcpy(&csum, (caddr_t)pi + pi->rm_size, sizeof(csum));
d1488 1
a1488 1
			memcpy(&vlan, (caddr_t)pi + pi->rm_size, sizeof(vlan));
d1490 6
a1495 2
			m->m_pkthdr.ether_vtag = vlan & 0xffff;
			m->m_flags |= M_VLANTAG;
d1499 2
a1500 2
			DPRINTF("%s: unhandled PI %u\n", sc->sc_dev.dv_xname,
			    pi->rm_type);
d1506 1
@


1.15
log
@Configure NDIS VLAN and MTU parameters for NVSP 2 and newer backends
@
text
@d191 1
a272 1
#ifdef notyet
d274 8
a281 4
	    IFCAP_CSUM_UDPv4;
#endif
#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
d283 1
d299 6
d1202 28
@


1.14
log
@Improve error handling when we fail to send the RNDIS message
@
text
@d108 4
d810 1
d855 11
d1155 1
a1155 1
	req->rm_max_xfersz = 2048; /* XXX */
@


1.13
log
@Specify a page size boundary for Tx segments
@
text
@d464 1
d466 1
@


1.12
log
@Switch to the new NDIS header
@
text
@d699 2
a700 2
		    HVN_TX_FRAGS, HVN_TX_FRAG_SIZE, 0, BUS_DMA_WAITOK,
		    &txd->txd_dmap)) {
@


1.11
log
@Attach event counter
@
text
@d60 1
a60 1
#include <dev/pv/rndisreg.h>
d89 2
a90 2
	(sizeof(struct rndis_packet_msg) + RNDIS_VLAN_PPI_SIZE + \
	 RNDIS_CSUM_PPI_SIZE)
d790 2
a791 2
		sc->sc_link_state = (state == 0) ? LINK_STATE_UP :
		    LINK_STATE_DOWN;
d1318 1
a1318 2
	struct rndis_tcp_ip_csum_info *csum;
	struct ndis_8021q_info *vlan;
d1361 2
a1362 3
			csum = (struct rndis_tcp_ip_csum_info *)
			    ((caddr_t)pi + pi->rm_size);
			if (csum->recv.ip_csum_succeeded)
d1364 1
a1364 1
			if (csum->recv.tcp_csum_succeeded)
d1366 1
a1366 1
			if (csum->recv.udp_csum_succeeded)
d1370 1
a1370 2
			vlan = (struct ndis_8021q_info *)
			    ((caddr_t)pi + pi->rm_size);
d1372 1
a1372 1
			m->m_pkthdr.ether_vtag = vlan->vlan_id;
@


1.10
log
@Switch over to the generic RNDIS header
@
text
@d825 2
@


1.9
log
@Cleanup dmesg output
@
text
@d58 2
d89 2
a90 1
	(sizeof(struct rndis) + RNDIS_VLAN_PPI_SIZE + RNDIS_CSUM_PPI_SIZE)
d95 1
a95 1
	struct rndis			*rc_req;
d97 2
d100 1
a100 1
	struct rndis			 rc_cmp;
d125 1
a125 1
	struct rndis			*txd_req;
a182 1
void	hvn_rxeof(struct hvn_softc *, void *);
d202 2
a203 3
void	hvn_rndis_filter(struct hvn_softc *sc, uint64_t, void *);
void	hvn_rndis_input(struct hvn_softc *, caddr_t, uint32_t,
	    struct mbuf_list *);
a479 1
	struct rndis_pkt *pkt;
d492 6
a497 8
	memset(txd->txd_req, 0, HVN_RNDIS_MSG_LEN);
	txd->txd_req->msg_type = RNDIS_PACKET_MSG;

	pkt = (struct rndis_pkt *)&txd->txd_req->msg;
	pkt->data_offset = sizeof(struct rndis_pkt);
	pkt->data_length = m->m_pkthdr.len;
	pkt->pkt_info_offset = sizeof(struct rndis_pkt);
	rlen = RNDIS_MESSAGE_SIZE(*pkt);
d509 1
a509 1
	txd->txd_req->msg_len = pkt->data_length + rlen;
d710 1
a710 1
		txd->txd_req = (struct rndis *)((caddr_t)sc->sc_tx_msgs +
d768 1
a768 1
	rv = hvn_rndis_query(sc, RNDIS_OID_802_3_PERMANENT_ADDRESS,
d778 1
a778 1
	return (hvn_rndis_set(sc, RNDIS_OID_802_3_CURRENT_ADDRESS,
d788 1
a788 1
	if (hvn_rndis_query(sc, RNDIS_OID_GEN_MEDIA_CONNECT_STATUS,
d907 1
a907 1
				hvn_rndis_filter(sc, cph->cph_tid, cph);
d1058 1
a1058 1
	memset(rc->rc_req, 0, sizeof(*rc->rc_req));
d1091 10
a1100 3
		rc->rc_req = km_alloc(PAGE_SIZE, &kv_any, &kp_zero,
		    &kd_waitok);
		if (rc->rc_req == NULL) {
d1103 2
d1112 2
a1113 1
			km_free(rc->rc_req, PAGE_SIZE, &kv_any, &kp_zero);
a1126 3
	rc->rc_req->msg_type = RNDIS_INITIALIZE_MSG;
	rc->rc_req->msg_len = RNDIS_MESSAGE_SIZE(*req);
	rc->rc_cmplen = RNDIS_MESSAGE_SIZE(*cmp);
d1128 10
a1137 5
	req = (struct rndis_init_req *)&rc->rc_req->msg;
	req->request_id = rc->rc_id;
	req->major_version = RNDIS_MAJOR_VERSION;
	req->minor_version = RNDIS_MINOR_VERSION;
	req->max_xfer_size = 2048; /* XXX */
d1148 2
a1149 2
	cmp = (struct rndis_init_comp *)&rc->rc_cmp.msg;
	if (cmp->status != RNDIS_STATUS_SUCCESS) {
d1151 1
a1151 1
		    sc->sc_dev.dv_xname, cmp->status);
d1166 1
a1166 1
		km_free(rc->rc_req, PAGE_SIZE, &kv_any, &kp_zero);
d1177 1
d1189 1
a1189 1
	sgl[0].gpa_len = rc->rc_req->msg_len;
d1201 1
a1201 1
			    sc->sc_dev.dv_xname, rc->rc_req->msg_type, rv);
d1229 1
a1229 1
		    rc->rc_req->msg_type);
d1236 1
a1236 1
hvn_rndis_filter(struct hvn_softc *sc, uint64_t tid, void *arg)
d1253 1
a1253 1
		KASSERT(len >= RNDIS_HEADER_SIZE + 4);
d1258 2
a1259 2
		case RNDIS_PACKET_MSG:
			hvn_rndis_input(sc, (caddr_t)sc->sc_rx_ring +
d1263 5
a1267 5
		case RNDIS_INITIALIZE_CMPLT:
		case RNDIS_QUERY_CMPLT:
		case RNDIS_SET_CMPLT:
		case RNDIS_RESET_CMPLT:
		case RNDIS_KEEPALIVE_CMPLT:
d1272 1
a1272 1
		case RNDIS_INDICATE_STATUS_MSG:
d1310 1
a1310 1
hvn_rndis_input(struct hvn_softc *sc, caddr_t buf, uint32_t len,
d1314 2
a1315 2
	struct rndis_pkt *pkt;
	struct rndis_pkt_info *ppi;
d1323 1
a1323 1
	if (len < RNDIS_HEADER_SIZE + sizeof(*pkt)) {
d1329 1
a1329 1
	pkt = (struct rndis_pkt *)(buf + RNDIS_HEADER_SIZE);
d1331 1
a1331 1
	if (pkt->data_offset + pkt->data_length > len) {
d1333 1
a1333 1
		    sc->sc_dev.dv_xname, pkt->data_offset, pkt->data_length);
d1337 2
a1338 2
	if ((m = hvn_devget(sc, buf + RNDIS_HEADER_SIZE + pkt->data_offset,
	    pkt->data_length)) == NULL) {
d1343 7
a1349 5
	while (pkt->pkt_info_length > 0) {
		if (pkt->pkt_info_offset + pkt->pkt_info_length > len) {
			printf("%s: PPI out of bounds: %u@@%u\n",
			    sc->sc_dev.dv_xname, pkt->pkt_info_length,
			    pkt->pkt_info_offset);
d1352 4
a1355 6
		ppi = (struct rndis_pkt_info *)((caddr_t)pkt +
		    pkt->pkt_info_offset);
		if (ppi->size > pkt->pkt_info_length) {
			printf("%s: invalid PPI size: %u/%u\n",
			    sc->sc_dev.dv_xname, ppi->size,
			    pkt->pkt_info_length);
d1358 2
a1359 2
		switch (ppi->type) {
		case tcpip_chksum_info:
d1361 1
a1361 1
			    ((caddr_t)ppi + ppi->size);
d1369 1
a1369 1
		case ieee_8021q_info:
d1371 1
a1371 1
			    ((caddr_t)ppi + ppi->size);
d1378 2
a1379 2
			DPRINTF("%s: unhandled PPI %u\n", sc->sc_dev.dv_xname,
			    ppi->type);
d1381 2
a1382 1
		pkt->pkt_info_length -= ppi->size;
d1394 1
a1394 1
	memcpy(&id, buf + RNDIS_HEADER_SIZE, sizeof(id));
d1440 1
a1440 1
	memcpy(&sta, buf + RNDIS_HEADER_SIZE, sizeof(sta));
a1473 3
	rc->rc_req->msg_type = RNDIS_QUERY_MSG;
	rc->rc_req->msg_len = RNDIS_MESSAGE_SIZE(*req);
	rc->rc_cmplen = RNDIS_MESSAGE_SIZE(*cmp);
d1475 9
a1483 4
	req = (struct rndis_query_req *)&rc->rc_req->msg;
	req->request_id = rc->rc_id;
	req->oid = oid;
	req->info_buffer_offset = sizeof(*req);
d1495 2
a1496 2
	cmp = (struct rndis_query_comp *)&rc->rc_cmp.msg;
	switch (cmp->status) {
d1498 1
a1498 1
		if (cmp->info_buffer_length > olength) {
d1502 2
a1503 2
		memcpy(res, rc->rc_cmpbuf, cmp->info_buffer_length);
		*length = cmp->info_buffer_length;
a1527 3
	rc->rc_req->msg_type = RNDIS_SET_MSG;
	rc->rc_req->msg_len = RNDIS_MESSAGE_SIZE(*req) + length;
	rc->rc_cmplen = RNDIS_MESSAGE_SIZE(*cmp);
d1529 9
a1537 5
	req = (struct rndis_set_req *)&rc->rc_req->msg;
	memset(req, 0, sizeof(*req));
	req->request_id = rc->rc_id;
	req->oid = oid;
	req->info_buffer_offset = sizeof(*req);
d1540 2
a1541 2
		KASSERT(sizeof(*req) + length < sizeof(struct rndis));
		req->info_buffer_length = length;
d1555 2
a1556 2
	cmp = (struct rndis_set_comp *)&rc->rc_cmp.msg;
	if (cmp->status != RNDIS_STATUS_SUCCESS)
d1577 1
a1577 1
	rv = hvn_rndis_set(sc, RNDIS_OID_GEN_CURRENT_PACKET_FILTER,
d1591 1
a1591 1
	rv = hvn_rndis_set(sc, RNDIS_OID_GEN_CURRENT_PACKET_FILTER,
a1610 2
	rc->rc_req->msg_type = RNDIS_HALT_MSG;
	rc->rc_req->msg_len = RNDIS_MESSAGE_SIZE(*req);
d1612 5
a1616 2
	req = (struct rndis_halt_req *)&rc->rc_req->msg;
	req->request_id = rc->rc_id;
@


1.8
log
@Implement packet transmission through RNDIS scatter-gather interface
@
text
@d142 1
d293 4
a296 2
	DPRINTF("%s", sc->sc_dev.dv_xname);
	printf(": channel %u, address %s\n", sc->sc_chan->ch_id,
d859 1
a859 3
	DPRINTF("%s: NVSP %u.%u, NDIS %u.%u\n", sc->sc_dev.dv_xname,
	    sc->sc_proto >> 16, sc->sc_proto & 0xffff,
	    ndisver >> 16, ndisver & 0xffff);
a1142 2
	DPRINTF("%s: RNDIS %u.%u\n", sc->sc_dev.dv_xname,
	    cmp->major_version, cmp->minor_version);
@


1.7
log
@Remove contigious TX buffer, we're not going to use it
@
text
@d86 3
d94 1
a94 1
	uint64_t			 rc_pfn;
d107 15
d157 6
d174 2
d181 1
a181 1
int	hvn_tx_ring_destroy(struct hvn_softc *);
d201 1
d264 1
d267 1
d426 2
d434 7
a440 1
		m = ifq_deq_begin(&ifp->if_snd);
d444 6
a449 1
		ifq_deq_commit(&ifp->if_snd, m);
d456 63
a518 2
		m_freem(m);
		ifp->if_oerrors++;
d520 13
d539 23
d563 2
a564 1
	printf("%s: tx tid %llu\n", ifp->if_xname, tid);
d659 55
d715 4
d721 1
a721 1
int
d724 32
a755 1
	return (0);
d1106 1
a1106 1
		rc->rc_pfn = atop(rc->rc_dmap->dm_segs[0].ds_addr);
d1176 1
a1176 1
	sgl[0].gpa_page = rc->rc_pfn;
d1184 1
a1184 1
		    sizeof(struct hvn_nvs_rndis), rc->rc_id);
d1399 21
@


1.6
log
@Update NVS protocol structure definitions to the 2016 version

Microsoft has considerably cleaned up the style and it makes sense
to keep in sync with the maintained upstream version in FreeBSD.
@
text
@a138 3
	void				*sc_tx_ring;
	int				 sc_tx_size;
	uint32_t			 sc_tx_hndl;
a518 34
	struct hvn_nvs_chim_conn cmd;
	struct hvn_nvs_chim_conn_resp *rsp;
	uint64_t tid;

	sc->sc_tx_size = 15 * 1024 * 1024;	/* 15MB */
	sc->sc_tx_ring = km_alloc(sc->sc_tx_size, &kv_any, &kp_zero,
	    cold ? &kd_nowait : &kd_waitok);
	if (sc->sc_tx_ring == NULL) {
		DPRINTF("%s: failed to allocate Tx ring buffer\n",
		    sc->sc_dev.dv_xname);
		return (-1);
	}
	if (hv_handle_alloc(sc->sc_chan, sc->sc_tx_ring, sc->sc_tx_size,
	    &sc->sc_tx_hndl)) {
		DPRINTF("%s: failed to obtain a PA handle\n",
		    sc->sc_dev.dv_xname);
		goto errout;
	}

	memset(&cmd, 0, sizeof(cmd));
	cmd.nvs_type = HVN_NVS_TYPE_CHIM_CONN;
	cmd.nvs_gpadl = sc->sc_tx_hndl;
	cmd.nvs_sig = HVN_NVS_CHIM_SIG;

	tid = atomic_inc_int_nv(&sc->sc_nvstid);
	if (hvn_nvs_cmd(sc, &cmd, sizeof(cmd), tid, 100))
		goto errout;

	rsp = (struct hvn_nvs_chim_conn_resp *)&sc->sc_nvsrsp;
	if (rsp->nvs_status != HVN_NVS_STATUS_OK) {
		DPRINTF("%s: failed to set up the Tx ring\n",
		    sc->sc_dev.dv_xname);
		goto errout;
	}
a519 11

 errout:
	if (sc->sc_tx_hndl) {
		hv_handle_free(sc->sc_chan, sc->sc_tx_hndl);
		sc->sc_tx_hndl = 0;
	}
	if (sc->sc_tx_ring) {
		km_free(sc->sc_tx_ring, sc->sc_tx_size, &kv_any, &kp_zero);
		sc->sc_tx_ring = NULL;
	}
	return (-1);
a524 22
	struct hvn_nvs_chim_disconn cmd;
	uint64_t tid;

	if (sc->sc_tx_ring == NULL)
		return (0);

	memset(&cmd, 0, sizeof(cmd));
	cmd.nvs_type = HVN_NVS_TYPE_CHIM_DISCONN;
	cmd.nvs_sig = HVN_NVS_CHIM_SIG;

	tid = atomic_inc_int_nv(&sc->sc_nvstid);
	if (hvn_nvs_cmd(sc, &cmd, sizeof(cmd), tid, 0))
		return (-1);

	delay(100);

	hv_handle_free(sc->sc_chan, sc->sc_tx_hndl);

	sc->sc_tx_hndl = 0;

	km_free(sc->sc_tx_ring, sc->sc_tx_size, &kv_any, &kp_zero);
	sc->sc_tx_ring = NULL;
@


1.5
log
@Update Hyper-V structure definitions to the 2016 version

Microsoft has performed a significant clean up and stylistic improvement
of Hyper-V structure definitions and updated FreeBSD port.  We update to
stay in sync with the upstream and improve maintainability of this code
in the future.
@
text
@d77 3
d88 1
a94 1
	struct nvsp			 rc_nvsp;
a100 5
 * Rx ring
 */
#define HVN_RX_BUFID			0xcafe

/*
a103 1
#define HVN_TX_BUFID			0xface
d116 1
a116 1
	/* NVSP protocol */
d118 4
a121 5
	uint32_t			 sc_nvsptid;
	struct nvsp			 sc_nvsp;
	uint8_t				*sc_nvspbuf;
#define  HVN_NVSP_BUFSIZE		 (PAGE_SIZE * 4)
	struct mutex			 sc_nvsplck;
d165 5
a169 5
int	hvn_nvsp_attach(struct hvn_softc *);
void	hvn_nvsp_intr(void *);
int	hvn_nvsp_output(struct hvn_softc *, struct nvsp *, uint64_t, int);
int	hvn_nvsp_ack(struct hvn_softc *, struct nvsp *, uint64_t);
void	hvn_nvsp_detach(struct hvn_softc *);
d173 1
a173 1
int	hvn_rndis_ctloutput(struct hvn_softc *, struct rndis_cmd *, int);
d219 1
a219 1
	if (hvn_nvsp_attach(sc)) {
d276 1
a276 1
	hvn_nvsp_detach(sc);
d433 2
a434 3
	struct nvsp *pkt = &sc->sc_nvsp;
	struct nvsp_send_rx_buf *msg;
	struct nvsp_send_rx_buf_comp *cmp;
d437 1
a437 1
	if (sc->sc_proto <= NVSP_PROTOCOL_VERSION_2)
d455 4
a458 5
	memset(pkt, 0, sizeof(*pkt));
	pkt->msg_type = nvsp_type_send_rx_buf;
	msg = (struct nvsp_send_rx_buf *)&pkt->msg;
	msg->gpadl_handle = sc->sc_rx_hndl;
	msg->id = HVN_RX_BUFID;
d460 2
a461 2
	tid = atomic_inc_int_nv(&sc->sc_nvsptid);
	if (hvn_nvsp_output(sc, pkt, tid, 100))
d464 2
a465 2
	cmp = (struct nvsp_send_rx_buf_comp *)&pkt->msg;
	if (cmp->status != nvsp_status_success) {
d470 1
a470 1
	if (cmp->num_sections > 1) {
d472 1
a472 1
		    sc->sc_dev.dv_xname, cmp->num_sections);
d493 1
a493 2
	struct nvsp *pkt = &sc->sc_nvsp;
	struct nvsp_revoke_rx_buf *msg;
d499 3
a501 4
	memset(pkt, 0, sizeof(*pkt));
	pkt->msg_type = nvsp_type_revoke_rx_buf;
	msg = (struct nvsp_revoke_rx_buf *)&pkt->msg;
	msg->id = HVN_RX_BUFID;
d503 2
a504 2
	tid = atomic_inc_int_nv(&sc->sc_nvsptid);
	if (hvn_nvsp_output(sc, pkt, tid, 0))
d522 2
a523 3
	struct nvsp *pkt = &sc->sc_nvsp;
	struct nvsp_send_tx_buf *msg;
	struct nvsp_send_tx_buf_comp *cmp;
d541 4
a544 5
	memset(pkt, 0, sizeof(*pkt));
	pkt->msg_type = nvsp_type_send_tx_buf;
	msg = (struct nvsp_send_tx_buf *)&pkt->msg;
	msg->gpadl_handle = sc->sc_tx_hndl;
	msg->id = HVN_TX_BUFID;
d546 2
a547 2
	tid = atomic_inc_int_nv(&sc->sc_nvsptid);
	if (hvn_nvsp_output(sc, pkt, tid, 100))
d550 2
a551 2
	cmp = (struct nvsp_send_tx_buf_comp *)&pkt->msg;
	if (cmp->status != nvsp_status_success) {
d573 1
a573 2
	struct nvsp *pkt = &sc->sc_nvsp;
	struct nvsp_revoke_tx_buf *msg;
d579 3
a581 4
	memset(pkt, 0, sizeof(*pkt));
	pkt->msg_type = nvsp_type_revoke_tx_buf;
	msg = (struct nvsp_revoke_tx_buf *)&pkt->msg;
	msg->id = HVN_TX_BUFID;
d583 2
a584 2
	tid = atomic_inc_int_nv(&sc->sc_nvsptid);
	if (hvn_nvsp_output(sc, pkt, tid, 0))
a594 1

d632 1
a632 1
hvn_nvsp_attach(struct hvn_softc *sc)
d635 2
a636 2
		NVSP_PROTOCOL_VERSION_5, NVSP_PROTOCOL_VERSION_4,
		NVSP_PROTOCOL_VERSION_2, NVSP_PROTOCOL_VERSION_1
d638 3
a640 4
	struct nvsp *pkt = &sc->sc_nvsp;
	struct nvsp_init *init;
	struct nvsp_init_comp *cmp;
	struct nvsp_send_ndis_version *ver;
d646 1
a646 1
	sc->sc_nvspbuf = km_alloc(HVN_NVSP_BUFSIZE, &kv_any, &kp_zero,
d648 1
a648 1
	if (sc->sc_nvspbuf == NULL) {
d656 1
a656 1
	if (hv_channel_open(sc->sc_chan, NULL, 0, hvn_nvsp_intr, sc)) {
d658 1
a658 1
		km_free(sc->sc_nvspbuf, HVN_NVSP_BUFSIZE, &kv_any, &kp_zero);
d662 1
a662 5
	mtx_init(&sc->sc_nvsplck, IPL_NET);

	memset(pkt, 0, sizeof(*pkt));
	pkt->msg_type = nvsp_type_init;
	init = (struct nvsp_init *)&pkt->msg;
d664 2
d667 3
a669 3
		init->protocol_version = init->protocol_version_2 = protos[i];
		tid = atomic_inc_int_nv(&sc->sc_nvsptid);
		if (hvn_nvsp_output(sc, pkt, tid, 100))
d671 2
a672 2
		cmp = (struct nvsp_init_comp *)&pkt->msg;
		if (cmp->status == nvsp_status_success) {
d683 3
a685 4
	memset(pkt, 0, sizeof(*pkt));
	pkt->msg_type = nvsp_type_send_ndis_vers;
	ver = (struct nvsp_send_ndis_version *)&pkt->msg;
	if (sc->sc_proto <= NVSP_PROTOCOL_VERSION_4)
d689 2
a690 2
	ver->ndis_major_vers = (ndisver & 0xffff0000) >> 16;
	ver->ndis_minor_vers = (ndisver & 0x0000ffff);
d692 2
a693 2
	tid = atomic_inc_int_nv(&sc->sc_nvsptid);
	if (hvn_nvsp_output(sc, pkt, tid, 100))
d704 1
a704 1
hvn_nvsp_intr(void *arg)
d708 1
a708 1
	struct nvsp *pkt;
d714 2
a715 2
		rv = hv_channel_recv(sc->sc_chan, sc->sc_nvspbuf,
		    HVN_NVSP_BUFSIZE, &rlen, &rid, 1);
d722 2
a723 2
		cph = (struct vmbus_chanpkt_hdr *)sc->sc_nvspbuf;
		pkt = (struct nvsp *)VMBUS_CHANPKT_CONST_DATA(cph);
d726 5
a730 5
			switch (pkt->msg_type) {
			case nvsp_type_init_comp:
			case nvsp_type_send_rx_buf_comp:
			case nvsp_type_send_tx_buf_comp:
			case nvsp_type_subchannel:
d732 2
a733 2
				memcpy(&sc->sc_nvsp, pkt, sizeof(sc->sc_nvsp));
				wakeup_one(&sc->sc_nvsp);
d735 1
a735 1
			case nvsp_type_send_rndis_pkt_comp:
d741 1
a741 1
				    pkt->msg_type);
d744 2
a745 2
			switch (pkt->msg_type) {
			case nvsp_type_send_rndis_pkt:
d751 1
a751 1
				    pkt->msg_type);
d760 2
a761 1
hvn_nvsp_output(struct hvn_softc *sc, struct nvsp *pkt, uint64_t tid, int timo)
d763 1
d768 1
a768 1
		rv = hv_channel_send(sc->sc_chan, pkt, sizeof(*pkt),
d773 1
a773 1
				tsleep(pkt, PRIBIO, "hvnsend", timo / 10);
d778 1
a778 1
			    sc->sc_dev.dv_xname, pkt->msg_type, rv);
d784 2
a785 2
		mtx_enter(&sc->sc_nvsplck);
		rv = msleep(&sc->sc_nvsp, &sc->sc_nvsplck, PRIBIO, "hvnvsp",
d787 1
a787 1
		mtx_leave(&sc->sc_nvsplck);
d795 1
a795 1
			    sc->sc_dev.dv_xname, pkt->msg_type);
d803 1
a803 1
hvn_nvsp_ack(struct hvn_softc *sc, struct nvsp *pkt, uint64_t tid)
d805 1
d809 2
d812 1
a812 1
		rv = hv_channel_send(sc->sc_chan, pkt, sizeof(*pkt),
d826 1
a826 1
hvn_nvsp_detach(struct hvn_softc *sc)
d829 2
a830 2
		km_free(sc->sc_nvspbuf, HVN_NVSP_BUFSIZE, &kv_any, &kp_zero);
		sc->sc_nvspbuf = NULL;
d899 1
a899 1
	memset(&rc->rc_nvsp, 0, sizeof(rc->rc_nvsp));
d969 1
a969 1
	if ((rv = hvn_rndis_ctloutput(sc, rc, 500)) != 0) {
d1003 1
a1003 1
hvn_rndis_ctloutput(struct hvn_softc *sc, struct rndis_cmd *rc, int timo)
d1005 1
a1005 1
	struct nvsp_send_rndis_pkt *msg;
d1012 3
a1014 4
	rc->rc_nvsp.msg_type = nvsp_type_send_rndis_pkt;
	msg = (struct nvsp_send_rndis_pkt *)&rc->rc_nvsp.msg;
	msg->chan_type = 1; /* control */
	msg->send_buf_section_idx = NVSP_INVALID_SECTION_INDEX;
d1023 2
a1024 2
		rv = hv_channel_send_sgl(sc->sc_chan, sgl, 1, &rc->rc_nvsp,
		    sizeof(struct nvsp), rc->rc_id);
a1067 1
	struct nvsp pkt;
d1069 1
a1069 2
	struct nvsp_send_rndis_pkt_comp *cmp;
	uint32_t off, len, type, status = 0;
d1109 1
a1109 5
	memset(&pkt, 0, sizeof(pkt));
	pkt.msg_type = nvsp_type_send_rndis_pkt_comp;
	cmp = (struct nvsp_send_rndis_pkt_comp *)&pkt.msg;
	cmp->status = status;	/* XXX */
	hvn_nvsp_ack(sc, &pkt, tid);
d1292 1
a1292 1
	if ((rv = hvn_rndis_ctloutput(sc, rc, 500)) != 0) {
d1351 1
a1351 1
	if ((rv = hvn_rndis_ctloutput(sc, rc, 500)) != 0) {
d1423 1
a1423 1
	if ((rv = hvn_rndis_ctloutput(sc, rc, 500)) != 0)
@


1.4
log
@Trigger link state update only on media status updates
@
text
@d271 1
a271 1
	printf(": channel %u, address %s\n", sc->sc_chan->ch_relid,
d724 1
a724 1
	struct hv_pktdesc *d;
d739 2
a740 2
		d = (struct hv_pktdesc *)sc->sc_nvspbuf;
		pkt = (struct nvsp *)((char *)d + (d->offset << 3));
d742 1
a742 1
		if (d->type == HV_PKT_COMPLETION) {
d753 1
a753 1
				hvn_txeof(sc, d->tid);
d760 1
a760 1
		} else if (d->type == HV_PKT_DATA_USING_TRANSFER_PAGES) {
d763 1
a763 1
				hvn_rndis_filter(sc, d->tid, d + 1);
d772 1
a772 1
			    sc->sc_dev.dv_xname, d->type);
d784 2
a785 2
		    tid, HV_PKT_DATA_IN_BAND,
		    timo ? HV_PKTFLAG_COMPLETION_REQUESTED : 0);
d825 1
a825 1
		    tid, HV_PKT_COMPLETION, 0);
d1018 1
a1018 1
	struct hv_page_buffer pb[2];
d1029 3
a1031 3
	pb[0].pfn = rc->rc_pfn;
	pb[0].length = rc->rc_req->msg_len;
	pb[0].offset = 0;
d1036 1
a1036 1
		rv = hv_channel_sendbuf(sc->sc_chan, pb, 1, &rc->rc_nvsp,
d1082 1
a1082 1
	struct hv_transfer_page_header *hdr = arg;
a1086 5
	if (hdr->set_id != HVN_RX_BUFID) {
		DPRINTF("%s: transfer page invalid set id %#x\n",
		    sc->sc_dev.dv_xname, hdr->set_id);
		return;
	}
d1091 3
a1093 3
	for (i = 0; i < hdr->range_count; i++) {
		off = hdr->range[i].byte_offset;
		len = hdr->range[i].byte_count;
@


1.3
log
@zero sizeof a struct not sizeof the pointer to it
ok mikeb@@
@
text
@d4 1
a4 1
 * Copyright (c) 2012 NetApp Inc. 
d1280 1
a1280 1
		break;
@


1.2
log
@Remove a few debugging leftovers
@
text
@d678 1
a678 1
	memset(pkt, 0, sizeof(pkt));
d699 1
a699 1
	memset(pkt, 0, sizeof(pkt));
@


1.1
log
@A work-in-progress driver for the Hyper-V NetVSC

Network VSC is an RNDIS device using NVSP protocol to communicate
with the Hyper-V VMBus via VMBus channels and/or shared memory. The
code was ported from FreeBSD with some API changes and simplifications.

While the Rx path is nearly complete, packet transmition is not
implemented yet.

ok deraadt, mlarkin
@
text
@a156 1
void	hvn_intr(void *);
a425 18
#if 0
void
hvn_intr(void *arg)
{
	struct hvn_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	uint64_t rid;
	uint32_t rlen;
	int rv;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (ifq_is_oactive(&ifp->if_snd))
		ifq_restart(&ifp->if_snd);
}
#endif

a843 14
}

static inline void
hexdump(const char *header, void *data, size_t size)
{
	uint8_t *ptr = data;
	int i;

	for (i = 0; i < size; i++) {
		if ((i % 16) == 0)
			printf("%s%s+0x%02x:", i > 0 ? "\n" : "", header, i);
		printf(" %02x", ptr[i]);
	}
	printf("\n");
@

