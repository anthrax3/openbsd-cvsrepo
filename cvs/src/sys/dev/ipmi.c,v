head	1.99;
access;
symbols
	OPENBSD_6_2:1.99.0.2
	OPENBSD_6_2_BASE:1.99
	OPENBSD_6_1:1.97.0.6
	OPENBSD_6_1_BASE:1.97
	OPENBSD_6_0:1.97.0.2
	OPENBSD_6_0_BASE:1.97
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.76.0.4
	OPENBSD_5_8_BASE:1.76
	OPENBSD_5_7:1.75.0.4
	OPENBSD_5_7_BASE:1.75
	OPENBSD_5_6:1.72.0.4
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.69.0.6
	OPENBSD_5_5_BASE:1.69
	OPENBSD_5_4:1.69.0.2
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.67.0.2
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.65.0.10
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.8
	OPENBSD_5_0:1.65.0.6
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.65.0.4
	OPENBSD_4_9_BASE:1.65
	OPENBSD_4_8:1.65.0.2
	OPENBSD_4_8_BASE:1.65
	OPENBSD_4_7:1.64.0.6
	OPENBSD_4_7_BASE:1.64
	OPENBSD_4_6:1.64.0.8
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.64.0.4
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.64.0.2
	OPENBSD_4_4_BASE:1.64
	OPENBSD_4_3:1.63.0.2
	OPENBSD_4_3_BASE:1.63
	OPENBSD_4_2:1.58.0.2
	OPENBSD_4_2_BASE:1.58
	OPENBSD_4_1:1.52.0.2
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34;
locks; strict;
comment	@ * @;


1.99
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.98;
commitid	uRv5pa9QDlZaYgwD;

1.98
date	2017.06.29.03.48.44;	author tedu;	state Exp;
branches;
next	1.97;
commitid	H2cXhN3THj5d2LY8;

1.97
date	2016.06.07.01.31.54;	author tedu;	state Exp;
branches;
next	1.96;
commitid	37V3kDRiYRccnYvB;

1.96
date	2016.03.27.12.45.47;	author mpi;	state Exp;
branches;
next	1.95;
commitid	GAM2s6F8D2zk5Dn5;

1.95
date	2016.02.11.04.02.22;	author uebayasi;	state Exp;
branches;
next	1.94;
commitid	x4xSScO0LG67T7tV;

1.94
date	2016.02.07.12.19.14;	author uebayasi;	state Exp;
branches;
next	1.93;
commitid	EhXiweQcCg56MGOa;

1.93
date	2016.02.07.12.17.33;	author uebayasi;	state Exp;
branches;
next	1.92;
commitid	6EZfJRCExioItNFA;

1.92
date	2016.02.05.06.29.01;	author uebayasi;	state Exp;
branches;
next	1.91;
commitid	3lmLbhQAi8VhAKnD;

1.91
date	2016.01.25.06.36.47;	author uebayasi;	state Exp;
branches;
next	1.90;
commitid	GbFknLtpl29gHD6w;

1.90
date	2016.01.12.10.44.32;	author uebayasi;	state Exp;
branches;
next	1.89;
commitid	2n94FarOmfpYyZNn;

1.89
date	2016.01.12.09.11.59;	author uebayasi;	state Exp;
branches;
next	1.88;
commitid	KX10fciyr0aVdFSx;

1.88
date	2016.01.12.07.43.05;	author uebayasi;	state Exp;
branches;
next	1.87;
commitid	twYqn5Q980dnDO1x;

1.87
date	2016.01.11.14.39.23;	author uebayasi;	state Exp;
branches;
next	1.86;
commitid	Pwwmqwezym0OWqQW;

1.86
date	2016.01.11.14.29.40;	author uebayasi;	state Exp;
branches;
next	1.85;
commitid	Ki9TLE760hOsqGMk;

1.85
date	2016.01.11.14.08.58;	author uebayasi;	state Exp;
branches;
next	1.84;
commitid	wmThPxam6wsHRBpQ;

1.84
date	2016.01.11.13.12.50;	author uebayasi;	state Exp;
branches;
next	1.83;
commitid	tfMWiMZi9tyVx3x0;

1.83
date	2016.01.11.12.54.33;	author uebayasi;	state Exp;
branches;
next	1.82;
commitid	UVFzOm2R2VL1xXiZ;

1.82
date	2016.01.11.12.52.24;	author uebayasi;	state Exp;
branches;
next	1.81;
commitid	Z3y8iaOzwaqocFTo;

1.81
date	2016.01.10.14.44.09;	author uebayasi;	state Exp;
branches;
next	1.80;
commitid	po8dvr22XlY4PYv4;

1.80
date	2016.01.10.14.17.00;	author uebayasi;	state Exp;
branches;
next	1.79;
commitid	axdSZ8EnQF3lprlw;

1.79
date	2016.01.09.05.51.54;	author uebayasi;	state Exp;
branches;
next	1.78;
commitid	XChvptnbCX6Lw6oU;

1.78
date	2016.01.07.03.21.28;	author uebayasi;	state Exp;
branches;
next	1.77;
commitid	2RaCT9eqodaKuYnM;

1.77
date	2015.09.08.11.58.58;	author deraadt;	state Exp;
branches;
next	1.76;
commitid	0sUWn2kvvIbRxEXQ;

1.76
date	2015.06.21.00.15.12;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	ZaHl57a3hLLnZsK5;

1.75
date	2015.01.07.07.49.18;	author yasuoka;	state Exp;
branches;
next	1.74;
commitid	lvEE3wJ0kXDyefaX;

1.74
date	2014.12.10.12.27.57;	author mikeb;	state Exp;
branches;
next	1.73;
commitid	v6PAeA18rydwc5Vx;

1.73
date	2014.10.21.08.48.38;	author uebayasi;	state Exp;
branches;
next	1.72;
commitid	tAoC14dv0lNJZMn2;

1.72
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.71;
commitid	I19imNlAX05zJOED;

1.71
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	EF98ch02VpFassUi;

1.70
date	2014.05.04.18.18.36;	author sf;	state Exp;
branches;
next	1.69;

1.69
date	2013.07.03.15.10.57;	author bluhm;	state Exp;
branches;
next	1.68;

1.68
date	2013.04.10.01.35.55;	author guenther;	state Exp;
branches;
next	1.67;

1.67
date	2012.12.21.17.30.39;	author gsoares;	state Exp;
branches;
next	1.66;

1.66
date	2012.10.17.22.32.01;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2010.05.24.14.25.20;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2008.06.11.23.22.07;	author cnst;	state Exp;
branches;
next	1.63;

1.63
date	2008.02.16.05.20.31;	author cnst;	state Exp;
branches;
next	1.62;

1.62
date	2007.11.25.23.37.01;	author marco;	state Exp;
branches;
next	1.61;

1.61
date	2007.11.01.19.24.46;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.08.04.15.15;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2007.08.31.18.44.50;	author marco;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.29.06.36.56;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.29.06.28.23;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.29.05.54.00;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.13.18.57.56;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.08.05.48.18;	author marco;	state Exp;
branches;
next	1.53;

1.53
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2006.12.23.17.36.59;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2006.12.23.00.36.24;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.19.09.30.03;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2006.09.17.19.09.20;	author marco;	state Exp;
branches;
next	1.47;

1.47
date	2006.08.01.22.49.37;	author marco;	state Exp;
branches;
next	1.46;

1.46
date	2006.08.01.20.02.04;	author marco;	state Exp;
branches;
next	1.45;

1.45
date	2006.07.28.20.50.43;	author marco;	state Exp;
branches;
next	1.44;

1.44
date	2006.07.28.20.46.12;	author marco;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.28.20.41.02;	author jordan;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.21.20.55.26;	author alek;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.15.01.10.07;	author marco;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.15.00.46.55;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.12.02.11.53;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.08.22.51.18;	author gwk;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.06.15.04.38;	author wilfried;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.27.15.28.21;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.20.20.31.10;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.29.17.29.29;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.19.17.08.39;	author grange;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.18.04.46.04;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.05.21.28.29;	author marco;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.05.19.04.39;	author marco;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.05.17.38.00;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.05.17.09.15;	author marco;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.05.15.16.26;	author marco;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.04.23.51.16;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.16.03.16.47;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.13.04.00.18;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.13.03.49.32;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.13.03.36.12;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.30.18.02.53;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.28.23.47.42;	author jordan;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.22.04.28.14;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.24.18.36.21;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.21.16.44.24;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.20.02.02.20;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.19.23.47.44;	author jordan;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.19.23.28.28;	author jordan;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.19.23.00.22;	author jordan;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.19.22.35.39;	author jordan;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.19.22.06.59;	author jordan;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.19.22.01.08;	author jordan;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.19.21.52.30;	author jordan;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.19.21.43.09;	author jordan;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.18.23.26.33;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.18.23.11.00;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.18.23.08.23;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.17.23.54.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.17.22.56.53;	author jordan;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.05.02.02.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.04.21.59.41;	author marco;	state Exp;
branches;
next	;


desc
@@


1.99
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: ipmi.c,v 1.98 2017/06/29 03:48:44 tedu Exp $ */

/*
 * Copyright (c) 2015 Masao Uebayashi
 * Copyright (c) 2005 Jordan Hargrave
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/extent.h>
#include <sys/sensors.h>
#include <sys/malloc.h>
#include <sys/kthread.h>
#include <sys/task.h>

#include <machine/bus.h>
#include <machine/smbiosvar.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

#include <dev/ipmivar.h>
#include <dev/ipmi.h>

struct ipmi_sensor {
	u_int8_t	*i_sdr;
	int		i_num;
	int		stype;
	int		etype;
	struct		ksensor i_sensor;
	SLIST_ENTRY(ipmi_sensor) list;
};

int	ipmi_enabled = 0;

#define SENSOR_REFRESH_RATE (5 * hz)

#define SMBIOS_TYPE_IPMI	0x26

#define DEVNAME(s)  ((s)->sc_dev.dv_xname)

/*
 * Format of SMBIOS IPMI Flags
 *
 * bit0: interrupt trigger mode (1=level, 0=edge)
 * bit1: interrupt polarity (1=active high, 0=active low)
 * bit2: reserved
 * bit3: address LSB (1=odd,0=even)
 * bit4: interrupt (1=specified, 0=not specified)
 * bit5: reserved
 * bit6/7: register spacing (1,4,2,err)
 */
#define SMIPMI_FLAG_IRQLVL		(1L << 0)
#define SMIPMI_FLAG_IRQEN		(1L << 3)
#define SMIPMI_FLAG_ODDOFFSET		(1L << 4)
#define SMIPMI_FLAG_IFSPACING(x)	(((x)>>6)&0x3)
#define	 IPMI_IOSPACING_BYTE		 0
#define	 IPMI_IOSPACING_WORD		 2
#define	 IPMI_IOSPACING_DWORD		 1

#define IPMI_BTMSG_LEN			0
#define IPMI_BTMSG_NFLN			1
#define IPMI_BTMSG_SEQ			2
#define IPMI_BTMSG_CMD			3
#define IPMI_BTMSG_CCODE		4
#define IPMI_BTMSG_DATASND		4
#define IPMI_BTMSG_DATARCV		5

#define IPMI_MSG_NFLN			0
#define IPMI_MSG_CMD			1
#define IPMI_MSG_CCODE			2
#define IPMI_MSG_DATASND		2
#define IPMI_MSG_DATARCV		3

#define IPMI_SENSOR_TYPE_TEMP		0x0101
#define IPMI_SENSOR_TYPE_VOLT		0x0102
#define IPMI_SENSOR_TYPE_FAN		0x0104
#define IPMI_SENSOR_TYPE_INTRUSION	0x6F05
#define IPMI_SENSOR_TYPE_PWRSUPPLY	0x6F08

#define IPMI_NAME_UNICODE		0x00
#define IPMI_NAME_BCDPLUS		0x01
#define IPMI_NAME_ASCII6BIT		0x02
#define IPMI_NAME_ASCII8BIT		0x03

#define IPMI_ENTITY_PWRSUPPLY		0x0A

#define IPMI_INVALID_SENSOR		(1L << 5)
#define IPMI_DISABLED_SENSOR		(1L << 6)

#define IPMI_SDR_TYPEFULL		1
#define IPMI_SDR_TYPECOMPACT		2

#define byteof(x) ((x) >> 3)
#define bitof(x)  (1L << ((x) & 0x7))
#define TB(b,m)	  (data[2+byteof(b)] & bitof(b))

#ifdef IPMI_DEBUG
int	ipmi_dbg = 0;
#define dbg_printf(lvl, fmt...) \
	if (ipmi_dbg >= lvl) \
		printf(fmt);
#define dbg_dump(lvl, msg, len, buf) \
	if (len && ipmi_dbg >= lvl) \
		dumpb(msg, len, (const u_int8_t *)(buf));
#else
#define dbg_printf(lvl, fmt...)
#define dbg_dump(lvl, msg, len, buf)
#endif

long signextend(unsigned long, int);

SLIST_HEAD(ipmi_sensors_head, ipmi_sensor);
struct ipmi_sensors_head ipmi_sensor_list =
    SLIST_HEAD_INITIALIZER(ipmi_sensor_list);

void	dumpb(const char *, int, const u_int8_t *);

int	read_sensor(struct ipmi_softc *, struct ipmi_sensor *);
int	add_sdr_sensor(struct ipmi_softc *, u_int8_t *, int);
int	get_sdr_partial(struct ipmi_softc *, u_int16_t, u_int16_t,
	    u_int8_t, u_int8_t, void *, u_int16_t *);
int	get_sdr(struct ipmi_softc *, u_int16_t, u_int16_t *);

int	ipmi_sendcmd(struct ipmi_cmd *);
int	ipmi_recvcmd(struct ipmi_cmd *);
void	ipmi_cmd(struct ipmi_cmd *);
void	ipmi_cmd_poll(struct ipmi_cmd *);
void	ipmi_cmd_wait(struct ipmi_cmd *);
void	ipmi_cmd_wait_cb(void *);

int	ipmi_watchdog(void *, int);
void	ipmi_watchdog_tickle(void *);
void	ipmi_watchdog_set(void *);

int	ipmi_match(struct device *, void *, void *);
void	ipmi_attach(struct device *, struct device *, void *);
int	ipmi_activate(struct device *, int);
struct ipmi_softc *ipmilookup(dev_t dev);

int	ipmiopen(dev_t, int, int, struct proc *);
int	ipmiclose(dev_t, int, int, struct proc *);
int	ipmiioctl(dev_t, u_long, caddr_t, int, struct proc *);

long	ipow(long, int);
long	ipmi_convert(u_int8_t, struct sdrtype1 *, long);
int	ipmi_sensor_name(char *, int, u_int8_t, u_int8_t *, int);

/* BMC Helper Functions */
u_int8_t bmc_read(struct ipmi_softc *, int);
void	bmc_write(struct ipmi_softc *, int, u_int8_t);
int	bmc_io_wait(struct ipmi_softc *, struct ipmi_iowait *);

void	bt_buildmsg(struct ipmi_cmd *);
void	cmn_buildmsg(struct ipmi_cmd *);

int	getbits(u_int8_t *, int, int);
int	ipmi_sensor_type(int, int, int);

void	ipmi_smbios_probe(struct smbios_ipmi *, struct ipmi_attach_args *);
void	ipmi_refresh_sensors(struct ipmi_softc *sc);
int	ipmi_map_regs(struct ipmi_softc *sc, struct ipmi_attach_args *ia);
void	ipmi_unmap_regs(struct ipmi_softc *);

void	*scan_sig(long, long, int, int, const void *);

int	ipmi_sensor_status(struct ipmi_softc *, struct ipmi_sensor *,
    u_int8_t *);

int	 add_child_sensors(struct ipmi_softc *, u_int8_t *, int, int, int,
    int, int, int, const char *);

struct ipmi_if kcs_if = {
	"KCS",
	IPMI_IF_KCS_NREGS,
	cmn_buildmsg,
	kcs_sendmsg,
	kcs_recvmsg,
	kcs_reset,
	kcs_probe,
	IPMI_MSG_DATASND,
	IPMI_MSG_DATARCV,
};

struct ipmi_if smic_if = {
	"SMIC",
	IPMI_IF_SMIC_NREGS,
	cmn_buildmsg,
	smic_sendmsg,
	smic_recvmsg,
	smic_reset,
	smic_probe,
	IPMI_MSG_DATASND,
	IPMI_MSG_DATARCV,
};

struct ipmi_if bt_if = {
	"BT",
	IPMI_IF_BT_NREGS,
	bt_buildmsg,
	bt_sendmsg,
	bt_recvmsg,
	bt_reset,
	bt_probe,
	IPMI_BTMSG_DATASND,
	IPMI_BTMSG_DATARCV,
};

struct ipmi_if *ipmi_get_if(int);

struct ipmi_if *
ipmi_get_if(int iftype)
{
	switch (iftype) {
	case IPMI_IF_KCS:
		return (&kcs_if);
	case IPMI_IF_SMIC:
		return (&smic_if);
	case IPMI_IF_BT:
		return (&bt_if);
	}

	return (NULL);
}

/*
 * BMC Helper Functions
 */
u_int8_t
bmc_read(struct ipmi_softc *sc, int offset)
{
	return (bus_space_read_1(sc->sc_iot, sc->sc_ioh,
	    offset * sc->sc_if_iospacing));
}

void
bmc_write(struct ipmi_softc *sc, int offset, u_int8_t val)
{
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
	    offset * sc->sc_if_iospacing, val);
}

int
bmc_io_wait(struct ipmi_softc *sc, struct ipmi_iowait *a)
{
	volatile u_int8_t	v;
	int			count = 5000000; /* == 5s XXX can be shorter */

	while (count--) {
		v = bmc_read(sc, a->offset);
		if ((v & a->mask) == a->value)
			return v;

		delay(1);
	}

	dbg_printf(1, "%s: bmc_io_wait fails : *v=%.2x m=%.2x b=%.2x %s\n",
	    DEVNAME(sc), v, a->mask, a->value, a->lbl);
	return (-1);

}

#define RSSA_MASK 0xff
#define LUN_MASK 0x3
#define NETFN_LUN(nf,ln) (((nf) << 2) | ((ln) & LUN_MASK))

/*
 * BT interface
 */
#define _BT_CTRL_REG			0
#define	  BT_CLR_WR_PTR			(1L << 0)
#define	  BT_CLR_RD_PTR			(1L << 1)
#define	  BT_HOST2BMC_ATN		(1L << 2)
#define	  BT_BMC2HOST_ATN		(1L << 3)
#define	  BT_EVT_ATN			(1L << 4)
#define	  BT_HOST_BUSY			(1L << 6)
#define	  BT_BMC_BUSY			(1L << 7)

#define	  BT_READY	(BT_HOST_BUSY|BT_HOST2BMC_ATN|BT_BMC2HOST_ATN)

#define _BT_DATAIN_REG			1
#define _BT_DATAOUT_REG			1

#define _BT_INTMASK_REG			2
#define	 BT_IM_HIRQ_PEND		(1L << 1)
#define	 BT_IM_SCI_EN			(1L << 2)
#define	 BT_IM_SMI_EN			(1L << 3)
#define	 BT_IM_NMI2SMI			(1L << 4)

int bt_read(struct ipmi_softc *, int);
int bt_write(struct ipmi_softc *, int, uint8_t);

int
bt_read(struct ipmi_softc *sc, int reg)
{
	return bmc_read(sc, reg);
}

int
bt_write(struct ipmi_softc *sc, int reg, uint8_t data)
{
	struct ipmi_iowait a;

	a.offset = _BT_CTRL_REG;
	a.mask = BT_BMC_BUSY;
	a.value = 0;
	a.lbl = "bt_write";
	if (bmc_io_wait(sc, &a) < 0)
		return (-1);

	bmc_write(sc, reg, data);
	return (0);
}

int
bt_sendmsg(struct ipmi_cmd *c)
{
	struct ipmi_softc *sc = c->c_sc;
	struct ipmi_iowait a;
	int i;

	bt_write(sc, _BT_CTRL_REG, BT_CLR_WR_PTR);
	for (i = 0; i < c->c_txlen; i++)
		bt_write(sc, _BT_DATAOUT_REG, sc->sc_buf[i]);

	bt_write(sc, _BT_CTRL_REG, BT_HOST2BMC_ATN);
	a.offset = _BT_CTRL_REG;
	a.mask = BT_HOST2BMC_ATN | BT_BMC_BUSY;
	a.value = 0;
	a.lbl = "bt_sendwait";
	if (bmc_io_wait(sc, &a) < 0)
		return (-1);

	return (0);
}

int
bt_recvmsg(struct ipmi_cmd *c)
{
	struct ipmi_softc *sc = c->c_sc;
	struct ipmi_iowait a;
	u_int8_t len, v, i, j;

	a.offset = _BT_CTRL_REG;
	a.mask = BT_BMC2HOST_ATN;
	a.value = BT_BMC2HOST_ATN;
	a.lbl = "bt_recvwait";
	if (bmc_io_wait(sc, &a) < 0)
		return (-1);

	bt_write(sc, _BT_CTRL_REG, BT_HOST_BUSY);
	bt_write(sc, _BT_CTRL_REG, BT_BMC2HOST_ATN);
	bt_write(sc, _BT_CTRL_REG, BT_CLR_RD_PTR);
	len = bt_read(sc, _BT_DATAIN_REG);
	for (i = IPMI_BTMSG_NFLN, j = 0; i <= len; i++) {
		v = bt_read(sc, _BT_DATAIN_REG);
		if (i != IPMI_BTMSG_SEQ)
			*(sc->sc_buf + j++) = v;
	}
	bt_write(sc, _BT_CTRL_REG, BT_HOST_BUSY);
	c->c_rxlen = len - 1;

	return (0);
}

int
bt_reset(struct ipmi_softc *sc)
{
	return (-1);
}

int
bt_probe(struct ipmi_softc *sc)
{
	u_int8_t rv;

	rv = bmc_read(sc, _BT_CTRL_REG);
	rv &= BT_HOST_BUSY;
	rv |= BT_CLR_WR_PTR|BT_CLR_RD_PTR|BT_BMC2HOST_ATN|BT_HOST2BMC_ATN;
	bmc_write(sc, _BT_CTRL_REG, rv);

	rv = bmc_read(sc, _BT_INTMASK_REG);
	rv &= BT_IM_SCI_EN|BT_IM_SMI_EN|BT_IM_NMI2SMI;
	rv |= BT_IM_HIRQ_PEND;
	bmc_write(sc, _BT_INTMASK_REG, rv);

#if 0
	printf("bt_probe: %2x\n", v);
	printf(" WR    : %2x\n", v & BT_CLR_WR_PTR);
	printf(" RD    : %2x\n", v & BT_CLR_RD_PTR);
	printf(" H2B   : %2x\n", v & BT_HOST2BMC_ATN);
	printf(" B2H   : %2x\n", v & BT_BMC2HOST_ATN);
	printf(" EVT   : %2x\n", v & BT_EVT_ATN);
	printf(" HBSY  : %2x\n", v & BT_HOST_BUSY);
	printf(" BBSY  : %2x\n", v & BT_BMC_BUSY);
#endif
	return (0);
}

/*
 * SMIC interface
 */
#define _SMIC_DATAIN_REG		0
#define _SMIC_DATAOUT_REG		0

#define _SMIC_CTRL_REG			1
#define	  SMS_CC_GET_STATUS		 0x40
#define	  SMS_CC_START_TRANSFER		 0x41
#define	  SMS_CC_NEXT_TRANSFER		 0x42
#define	  SMS_CC_END_TRANSFER		 0x43
#define	  SMS_CC_START_RECEIVE		 0x44
#define	  SMS_CC_NEXT_RECEIVE		 0x45
#define	  SMS_CC_END_RECEIVE		 0x46
#define	  SMS_CC_TRANSFER_ABORT		 0x47

#define	  SMS_SC_READY			 0xc0
#define	  SMS_SC_WRITE_START		 0xc1
#define	  SMS_SC_WRITE_NEXT		 0xc2
#define	  SMS_SC_WRITE_END		 0xc3
#define	  SMS_SC_READ_START		 0xc4
#define	  SMS_SC_READ_NEXT		 0xc5
#define	  SMS_SC_READ_END		 0xc6

#define _SMIC_FLAG_REG			2
#define	  SMIC_BUSY			(1L << 0)
#define	  SMIC_SMS_ATN			(1L << 2)
#define	  SMIC_EVT_ATN			(1L << 3)
#define	  SMIC_SMI			(1L << 4)
#define	  SMIC_TX_DATA_RDY		(1L << 6)
#define	  SMIC_RX_DATA_RDY		(1L << 7)

int	smic_wait(struct ipmi_softc *, u_int8_t, u_int8_t, const char *);
int	smic_write_cmd_data(struct ipmi_softc *, u_int8_t, const u_int8_t *);
int	smic_read_data(struct ipmi_softc *, u_int8_t *);

int
smic_wait(struct ipmi_softc *sc, u_int8_t mask, u_int8_t val, const char *lbl)
{
	struct ipmi_iowait a;
	int v;

	/* Wait for expected flag bits */
	a.offset = _SMIC_FLAG_REG;
	a.mask = mask;
	a.value = val;
	a.lbl = "smicwait";
	v = bmc_io_wait(sc, &a);
	if (v < 0)
		return (-1);

	/* Return current status */
	v = bmc_read(sc, _SMIC_CTRL_REG);
	dbg_printf(99, "smic_wait = %.2x\n", v);
	return (v);
}

int
smic_write_cmd_data(struct ipmi_softc *sc, u_int8_t cmd, const u_int8_t *data)
{
	int	sts, v;

	dbg_printf(50, "smic_wcd: %.2x %.2x\n", cmd, data ? *data : -1);
	sts = smic_wait(sc, SMIC_TX_DATA_RDY | SMIC_BUSY, SMIC_TX_DATA_RDY,
	    "smic_write_cmd_data ready");
	if (sts < 0)
		return (sts);

	bmc_write(sc, _SMIC_CTRL_REG, cmd);
	if (data)
		bmc_write(sc, _SMIC_DATAOUT_REG, *data);

	/* Toggle BUSY bit, then wait for busy bit to clear */
	v = bmc_read(sc, _SMIC_FLAG_REG);
	bmc_write(sc, _SMIC_FLAG_REG, v | SMIC_BUSY);

	return (smic_wait(sc, SMIC_BUSY, 0, "smic_write_cmd_data busy"));
}

int
smic_read_data(struct ipmi_softc *sc, u_int8_t *data)
{
	int sts;

	sts = smic_wait(sc, SMIC_RX_DATA_RDY | SMIC_BUSY, SMIC_RX_DATA_RDY,
	    "smic_read_data");
	if (sts >= 0) {
		*data = bmc_read(sc, _SMIC_DATAIN_REG);
		dbg_printf(50, "smic_readdata: %.2x\n", *data);
	}
	return (sts);
}

#define ErrStat(a,b) if (a) printf(b);

int
smic_sendmsg(struct ipmi_cmd *c)
{
	struct ipmi_softc *sc = c->c_sc;
	int sts, idx;

	sts = smic_write_cmd_data(sc, SMS_CC_START_TRANSFER, &sc->sc_buf[0]);
	ErrStat(sts != SMS_SC_WRITE_START, "wstart");
	for (idx = 1; idx < c->c_txlen - 1; idx++) {
		sts = smic_write_cmd_data(sc, SMS_CC_NEXT_TRANSFER,
		    &sc->sc_buf[idx]);
		ErrStat(sts != SMS_SC_WRITE_NEXT, "write");
	}
	sts = smic_write_cmd_data(sc, SMS_CC_END_TRANSFER, &sc->sc_buf[idx]);
	if (sts != SMS_SC_WRITE_END) {
		dbg_printf(50, "smic_sendmsg %d/%d = %.2x\n", idx, c->c_txlen, sts);
		return (-1);
	}

	return (0);
}

int
smic_recvmsg(struct ipmi_cmd *c)
{
	struct ipmi_softc *sc = c->c_sc;
	int sts, idx;

	c->c_rxlen = 0;
	sts = smic_wait(sc, SMIC_RX_DATA_RDY, SMIC_RX_DATA_RDY, "smic_recvmsg");
	if (sts < 0)
		return (-1);

	sts = smic_write_cmd_data(sc, SMS_CC_START_RECEIVE, NULL);
	ErrStat(sts != SMS_SC_READ_START, "rstart");
	for (idx = 0;; ) {
		sts = smic_read_data(sc, &sc->sc_buf[idx++]);
		if (sts != SMS_SC_READ_START && sts != SMS_SC_READ_NEXT)
			break;
		smic_write_cmd_data(sc, SMS_CC_NEXT_RECEIVE, NULL);
	}
	ErrStat(sts != SMS_SC_READ_END, "rend");

	c->c_rxlen = idx;

	sts = smic_write_cmd_data(sc, SMS_CC_END_RECEIVE, NULL);
	if (sts != SMS_SC_READY) {
		dbg_printf(50, "smic_recvmsg %d/%d = %.2x\n", idx, c->c_maxrxlen, sts);
		return (-1);
	}

	return (0);
}

int
smic_reset(struct ipmi_softc *sc)
{
	return (-1);
}

int
smic_probe(struct ipmi_softc *sc)
{
	/* Flag register should not be 0xFF on a good system */
	if (bmc_read(sc, _SMIC_FLAG_REG) == 0xFF)
		return (-1);

	return (0);
}

/*
 * KCS interface
 */
#define _KCS_DATAIN_REGISTER		0
#define _KCS_DATAOUT_REGISTER		0
#define	  KCS_READ_NEXT			0x68

#define _KCS_COMMAND_REGISTER		1
#define	  KCS_GET_STATUS		0x60
#define	  KCS_WRITE_START		0x61
#define	  KCS_WRITE_END			0x62

#define _KCS_STATUS_REGISTER		1
#define	  KCS_OBF			(1L << 0)
#define	  KCS_IBF			(1L << 1)
#define	  KCS_SMS_ATN			(1L << 2)
#define	  KCS_CD			(1L << 3)
#define	  KCS_OEM1			(1L << 4)
#define	  KCS_OEM2			(1L << 5)
#define	  KCS_STATE_MASK		0xc0
#define	    KCS_IDLE_STATE		0x00
#define	    KCS_READ_STATE		0x40
#define	    KCS_WRITE_STATE		0x80
#define	    KCS_ERROR_STATE		0xC0

int	kcs_wait(struct ipmi_softc *, u_int8_t, u_int8_t, const char *);
int	kcs_write_cmd(struct ipmi_softc *, u_int8_t);
int	kcs_write_data(struct ipmi_softc *, u_int8_t);
int	kcs_read_data(struct ipmi_softc *, u_int8_t *);

int
kcs_wait(struct ipmi_softc *sc, u_int8_t mask, u_int8_t value, const char *lbl)
{
	struct ipmi_iowait a;
	int v;

	a.offset = _KCS_STATUS_REGISTER;
	a.mask = mask;
	a.value = value;
	a.lbl = lbl;
	v = bmc_io_wait(sc, &a);
	if (v < 0)
		return (v);

	/* Check if output buffer full, read dummy byte	 */
	if ((v & (KCS_OBF | KCS_STATE_MASK)) == (KCS_OBF | KCS_WRITE_STATE))
		bmc_read(sc, _KCS_DATAIN_REGISTER);

	/* Check for error state */
	if ((v & KCS_STATE_MASK) == KCS_ERROR_STATE) {
		bmc_write(sc, _KCS_COMMAND_REGISTER, KCS_GET_STATUS);
		while (bmc_read(sc, _KCS_STATUS_REGISTER) & KCS_IBF)
			continue;
		printf("%s: error code: %x\n", DEVNAME(sc),
		    bmc_read(sc, _KCS_DATAIN_REGISTER));
	}

	return (v & KCS_STATE_MASK);
}

int
kcs_write_cmd(struct ipmi_softc *sc, u_int8_t cmd)
{
	/* ASSERT: IBF and OBF are clear */
	dbg_printf(50, "kcswritecmd: %.2x\n", cmd);
	bmc_write(sc, _KCS_COMMAND_REGISTER, cmd);

	return (kcs_wait(sc, KCS_IBF, 0, "write_cmd"));
}

int
kcs_write_data(struct ipmi_softc *sc, u_int8_t data)
{
	/* ASSERT: IBF and OBF are clear */
	dbg_printf(50, "kcswritedata: %.2x\n", data);
	bmc_write(sc, _KCS_DATAOUT_REGISTER, data);

	return (kcs_wait(sc, KCS_IBF, 0, "write_data"));
}

int
kcs_read_data(struct ipmi_softc *sc, u_int8_t * data)
{
	int sts;

	sts = kcs_wait(sc, KCS_IBF | KCS_OBF, KCS_OBF, "read_data");
	if (sts != KCS_READ_STATE)
		return (sts);

	/* ASSERT: OBF is set read data, request next byte */
	*data = bmc_read(sc, _KCS_DATAIN_REGISTER);
	bmc_write(sc, _KCS_DATAOUT_REGISTER, KCS_READ_NEXT);

	dbg_printf(50, "kcsreaddata: %.2x\n", *data);

	return (sts);
}

/* Exported KCS functions */
int
kcs_sendmsg(struct ipmi_cmd *c)
{
	struct ipmi_softc *sc = c->c_sc;
	int idx, sts;

	/* ASSERT: IBF is clear */
	dbg_dump(50, "kcs sendmsg", c->c_txlen, sc->sc_buf);
	sts = kcs_write_cmd(sc, KCS_WRITE_START);
	for (idx = 0; idx < c->c_txlen; idx++) {
		if (idx == c->c_txlen - 1)
			sts = kcs_write_cmd(sc, KCS_WRITE_END);

		if (sts != KCS_WRITE_STATE)
			break;

		sts = kcs_write_data(sc, sc->sc_buf[idx]);
	}
	if (sts != KCS_READ_STATE) {
		dbg_printf(1, "kcs sendmsg = %d/%d <%.2x>\n", idx, c->c_txlen, sts);
		dbg_dump(1, "kcs_sendmsg", c->c_txlen, sc->sc_buf);
		return (-1);
	}

	return (0);
}

int
kcs_recvmsg(struct ipmi_cmd *c)
{
	struct ipmi_softc *sc = c->c_sc;
	int idx, sts;

	for (idx = 0; idx < c->c_maxrxlen; idx++) {
		sts = kcs_read_data(sc, &sc->sc_buf[idx]);
		if (sts != KCS_READ_STATE)
			break;
	}
	sts = kcs_wait(sc, KCS_IBF, 0, "recv");
	c->c_rxlen = idx;
	if (sts != KCS_IDLE_STATE) {
		dbg_printf(1, "kcs recvmsg = %d/%d <%.2x>\n", idx, c->c_maxrxlen, sts);
		return (-1);
	}

	dbg_dump(50, "kcs recvmsg", idx, sc->sc_buf);

	return (0);
}

int
kcs_reset(struct ipmi_softc *sc)
{
	return (-1);
}

int
kcs_probe(struct ipmi_softc *sc)
{
	u_int8_t v;

	v = bmc_read(sc, _KCS_STATUS_REGISTER);
	if ((v & KCS_STATE_MASK) == KCS_ERROR_STATE)
		return (1);
#if 0
	printf("kcs_probe: %2x\n", v);
	printf(" STS: %2x\n", v & KCS_STATE_MASK);
	printf(" ATN: %2x\n", v & KCS_SMS_ATN);
	printf(" C/D: %2x\n", v & KCS_CD);
	printf(" IBF: %2x\n", v & KCS_IBF);
	printf(" OBF: %2x\n", v & KCS_OBF);
#endif
	return (0);
}

/*
 * IPMI code
 */
#define READ_SMS_BUFFER		0x37
#define WRITE_I2C		0x50

#define GET_MESSAGE_CMD		0x33
#define SEND_MESSAGE_CMD	0x34

#define IPMB_CHANNEL_NUMBER	0

#define PUBLIC_BUS		0

#define MIN_I2C_PACKET_SIZE	3
#define MIN_IMB_PACKET_SIZE	7	/* one byte for cksum */

#define MIN_BTBMC_REQ_SIZE	4
#define MIN_BTBMC_RSP_SIZE	5
#define MIN_BMC_REQ_SIZE	2
#define MIN_BMC_RSP_SIZE	3

#define BMC_SA			0x20	/* BMC/ESM3 */
#define FPC_SA			0x22	/* front panel */
#define BP_SA			0xC0	/* Primary Backplane */
#define BP2_SA			0xC2	/* Secondary Backplane */
#define PBP_SA			0xC4	/* Peripheral Backplane */
#define DRAC_SA			0x28	/* DRAC-III */
#define DRAC3_SA		0x30	/* DRAC-III */
#define BMC_LUN			0
#define SMS_LUN			2

struct ipmi_request {
	u_int8_t	rsSa;
	u_int8_t	rsLun;
	u_int8_t	netFn;
	u_int8_t	cmd;
	u_int8_t	data_len;
	u_int8_t	*data;
};

struct ipmi_response {
	u_int8_t	cCode;
	u_int8_t	data_len;
	u_int8_t	*data;
};

struct ipmi_bmc_request {
	u_int8_t	bmc_nfLn;
	u_int8_t	bmc_cmd;
	u_int8_t	bmc_data_len;
	u_int8_t	bmc_data[1];
};

struct ipmi_bmc_response {
	u_int8_t	bmc_nfLn;
	u_int8_t	bmc_cmd;
	u_int8_t	bmc_cCode;
	u_int8_t	bmc_data_len;
	u_int8_t	bmc_data[1];
};

struct cfattach ipmi_ca = {
	sizeof(struct ipmi_softc), ipmi_match, ipmi_attach,
	NULL, ipmi_activate
};

struct cfdriver ipmi_cd = {
	NULL, "ipmi", DV_DULL
};

/* Scan memory for signature */
void *
scan_sig(long start, long end, int skip, int len, const void *data)
{
	void *va;

	while (start < end) {
		va = ISA_HOLE_VADDR(start);
		if (memcmp(va, data, len) == 0)
			return (va);

		start += skip;
	}

	return (NULL);
}

void
dumpb(const char *lbl, int len, const u_int8_t *data)
{
	int idx;

	printf("%s: ", lbl);
	for (idx = 0; idx < len; idx++)
		printf("%.2x ", data[idx]);

	printf("\n");
}

void
ipmi_smbios_probe(struct smbios_ipmi *pipmi, struct ipmi_attach_args *ia)
{

	dbg_printf(1, "ipmi_smbios_probe: %02x %02x %02x %02x %08llx %02x "
	    "%02x\n",
	    pipmi->smipmi_if_type,
	    pipmi->smipmi_if_rev,
	    pipmi->smipmi_i2c_address,
	    pipmi->smipmi_nvram_address,
	    pipmi->smipmi_base_address,
	    pipmi->smipmi_base_flags,
	    pipmi->smipmi_irq);

	ia->iaa_if_type = pipmi->smipmi_if_type;
	ia->iaa_if_rev = pipmi->smipmi_if_rev;
	ia->iaa_if_irq = (pipmi->smipmi_base_flags & SMIPMI_FLAG_IRQEN) ?
	    pipmi->smipmi_irq : -1;
	ia->iaa_if_irqlvl = (pipmi->smipmi_base_flags & SMIPMI_FLAG_IRQLVL) ?
	    IST_LEVEL : IST_EDGE;

	switch (SMIPMI_FLAG_IFSPACING(pipmi->smipmi_base_flags)) {
	case IPMI_IOSPACING_BYTE:
		ia->iaa_if_iospacing = 1;
		break;

	case IPMI_IOSPACING_DWORD:
		ia->iaa_if_iospacing = 4;
		break;

	case IPMI_IOSPACING_WORD:
		ia->iaa_if_iospacing = 2;
		break;

	default:
		ia->iaa_if_iospacing = 1;
		printf("ipmi: unknown register spacing\n");
	}

	/* Calculate base address (PCI BAR format) */
	if (pipmi->smipmi_base_address & 0x1) {
		ia->iaa_if_iotype = 'i';
		ia->iaa_if_iobase = pipmi->smipmi_base_address & ~0x1;
	} else {
		ia->iaa_if_iotype = 'm';
		ia->iaa_if_iobase = pipmi->smipmi_base_address & ~0xF;
	}
	if (pipmi->smipmi_base_flags & SMIPMI_FLAG_ODDOFFSET)
		ia->iaa_if_iobase++;

	if (pipmi->smipmi_base_flags == 0x7f) {
		/* IBM 325 eServer workaround */
		ia->iaa_if_iospacing = 1;
		ia->iaa_if_iobase = pipmi->smipmi_base_address;
		ia->iaa_if_iotype = 'i';
		return;
	}
}

/*
 * bt_buildmsg builds an IPMI message from a nfLun, cmd, and data
 * This is used by BT protocol
 */
void
bt_buildmsg(struct ipmi_cmd *c)
{
	struct ipmi_softc *sc = c->c_sc;
	u_int8_t *buf = sc->sc_buf;

	buf[IPMI_BTMSG_LEN] = c->c_txlen + (IPMI_BTMSG_DATASND - 1);
	buf[IPMI_BTMSG_NFLN] = NETFN_LUN(c->c_netfn, c->c_rslun);
	buf[IPMI_BTMSG_SEQ] = sc->sc_btseq++;
	buf[IPMI_BTMSG_CMD] = c->c_cmd;
	if (c->c_txlen && c->c_data)
		memcpy(buf + IPMI_BTMSG_DATASND, c->c_data, c->c_txlen);
}

/*
 * cmn_buildmsg builds an IPMI message from a nfLun, cmd, and data
 * This is used by both SMIC and KCS protocols
 */
void
cmn_buildmsg(struct ipmi_cmd *c)
{
	struct ipmi_softc *sc = c->c_sc;
	u_int8_t *buf = sc->sc_buf;

	buf[IPMI_MSG_NFLN] = NETFN_LUN(c->c_netfn, c->c_rslun);
	buf[IPMI_MSG_CMD] = c->c_cmd;
	if (c->c_txlen && c->c_data)
		memcpy(buf + IPMI_MSG_DATASND, c->c_data, c->c_txlen);
}

/* Send an IPMI command */
int
ipmi_sendcmd(struct ipmi_cmd *c)
{
	struct ipmi_softc	*sc = c->c_sc;
	int		rc = -1;

	dbg_printf(50, "ipmi_sendcmd: rssa=%.2x nfln=%.2x cmd=%.2x len=%.2x\n",
	    c->c_rssa, NETFN_LUN(c->c_netfn, c->c_rslun), c->c_cmd, c->c_txlen);
	dbg_dump(10, " send", c->c_txlen, c->c_data);
	if (c->c_rssa != BMC_SA) {
#if 0
		sc->sc_if->buildmsg(c);
		pI2C->bus = (sc->if_ver == 0x09) ?
		    PUBLIC_BUS :
		    IPMB_CHANNEL_NUMBER;

		imbreq->rsSa = rssa;
		imbreq->nfLn = NETFN_LUN(netfn, rslun);
		imbreq->cSum1 = -(imbreq->rsSa + imbreq->nfLn);
		imbreq->rqSa = BMC_SA;
		imbreq->seqLn = NETFN_LUN(sc->imb_seq++, SMS_LUN);
		imbreq->cmd = cmd;
		if (txlen)
			memcpy(imbreq->data, data, txlen);
		/* Set message checksum */
		imbreq->data[txlen] = cksum8(&imbreq->rqSa, txlen + 3);
#endif
		goto done;
	} else
		sc->sc_if->buildmsg(c);

	c->c_txlen += sc->sc_if->datasnd;
	rc = sc->sc_if->sendmsg(c);

done:
	return (rc);
}

/* Receive an IPMI command */
int
ipmi_recvcmd(struct ipmi_cmd *c)
{
	struct ipmi_softc *sc = c->c_sc;
	u_int8_t	*buf = sc->sc_buf, rc = 0;

	/* Receive message from interface, copy out result data */
	c->c_maxrxlen += sc->sc_if->datarcv;
	if (sc->sc_if->recvmsg(c) ||
	    c->c_rxlen < sc->sc_if->datarcv) {
		return (-1);
	}

	c->c_rxlen -= sc->sc_if->datarcv;
	if (c->c_rxlen > 0 && c->c_data)
		memcpy(c->c_data, buf + sc->sc_if->datarcv, c->c_rxlen);

	rc = buf[IPMI_MSG_CCODE];
#ifdef IPMI_DEBUG
	if (rc != 0)
		dbg_printf(1, "ipmi_recvcmd: nfln=%.2x cmd=%.2x err=%.2x\n",
		    buf[IPMI_MSG_NFLN], buf[IPMI_MSG_CMD], buf[IPMI_MSG_CCODE]);
#endif

	dbg_printf(50, "ipmi_recvcmd: nfln=%.2x cmd=%.2x err=%.2x len=%.2x\n",
	    buf[IPMI_MSG_NFLN], buf[IPMI_MSG_CMD], buf[IPMI_MSG_CCODE],
	    c->c_rxlen);
	dbg_dump(10, " recv", c->c_rxlen, c->c_data);

	return (rc);
}

void
ipmi_cmd(struct ipmi_cmd *c)
{
	if (cold || panicstr != NULL)
		ipmi_cmd_poll(c);
	else
		ipmi_cmd_wait(c);
}

void
ipmi_cmd_poll(struct ipmi_cmd *c)
{
	mtx_enter(&c->c_sc->sc_cmd_mtx);

	if (ipmi_sendcmd(c)) {
		panic("%s: sendcmd fails", DEVNAME(c->c_sc));
	}
	c->c_ccode = ipmi_recvcmd(c);

	mtx_leave(&c->c_sc->sc_cmd_mtx);
}

void
ipmi_cmd_wait(struct ipmi_cmd *c)
{
	struct task t;
	int res;

	task_set(&t, ipmi_cmd_wait_cb, c);
	res = task_add(c->c_sc->sc_cmd_taskq, &t);
	KASSERT(res == 1);

	tsleep(c, PWAIT, "ipmicmd", 0);

	res = task_del(c->c_sc->sc_cmd_taskq, &t);
	KASSERT(res == 0);
}

void
ipmi_cmd_wait_cb(void *arg)
{
	struct ipmi_cmd *c = arg;

	ipmi_cmd_poll(c);
	wakeup(c);
}

/* Read a partial SDR entry */
int
get_sdr_partial(struct ipmi_softc *sc, u_int16_t recordId, u_int16_t reserveId,
    u_int8_t offset, u_int8_t length, void *buffer, u_int16_t *nxtRecordId)
{
	u_int8_t	cmd[IPMI_GET_WDOG_MAX + 255];	/* 8 + max of length */
	int		len;

	((u_int16_t *) cmd)[0] = reserveId;
	((u_int16_t *) cmd)[1] = recordId;
	cmd[4] = offset;
	cmd[5] = length;

	struct ipmi_cmd	c;
	c.c_sc = sc;
	c.c_rssa = BMC_SA;
	c.c_rslun = BMC_LUN;
	c.c_netfn = STORAGE_NETFN;
	c.c_cmd = STORAGE_GET_SDR;
	c.c_txlen = IPMI_SET_WDOG_MAX;
	c.c_rxlen = 0;
	c.c_maxrxlen = 8 + length;
	c.c_data = cmd;
	ipmi_cmd(&c);
	len = c.c_rxlen;

	if (nxtRecordId)
		*nxtRecordId = *(uint16_t *) cmd;
	if (len > 2)
		memcpy(buffer, cmd + 2, len - 2);
	else
		return (1);

	return (0);
}

int maxsdrlen = 0x10;

/* Read an entire SDR; pass to add sensor */
int
get_sdr(struct ipmi_softc *sc, u_int16_t recid, u_int16_t *nxtrec)
{
	u_int16_t	resid = 0;
	int		len, sdrlen, offset;
	u_int8_t	*psdr;
	struct sdrhdr	shdr;

	/* Reserve SDR */
	struct ipmi_cmd	c;
	c.c_sc = sc;
	c.c_rssa = BMC_SA;
	c.c_rslun = BMC_LUN;
	c.c_netfn = STORAGE_NETFN;
	c.c_cmd = STORAGE_RESERVE_SDR;
	c.c_txlen = 0;
	c.c_maxrxlen = sizeof(resid);
	c.c_rxlen = 0;
	c.c_data = &resid;
	ipmi_cmd(&c);

	/* Get SDR Header */
	if (get_sdr_partial(sc, recid, resid, 0, sizeof shdr, &shdr, nxtrec)) {
		printf("%s: get header fails\n", DEVNAME(sc));
		return (1);
	}
	/* Allocate space for entire SDR Length of SDR in header does not
	 * include header length */
	sdrlen = sizeof(shdr) + shdr.record_length;
	psdr = malloc(sdrlen, M_DEVBUF, M_NOWAIT);
	if (psdr == NULL)
		return (1);

	memcpy(psdr, &shdr, sizeof(shdr));

	/* Read SDR Data maxsdrlen bytes at a time */
	for (offset = sizeof(shdr); offset < sdrlen; offset += maxsdrlen) {
		len = sdrlen - offset;
		if (len > maxsdrlen)
			len = maxsdrlen;

		if (get_sdr_partial(sc, recid, resid, offset, len,
		    psdr + offset, NULL)) {
			printf("%s: get chunk: %d,%d fails\n", DEVNAME(sc),
			    offset, len);
			free(psdr, M_DEVBUF, sdrlen);
			return (1);
		}
	}

	/* Add SDR to sensor list, if not wanted, free buffer */
	if (add_sdr_sensor(sc, psdr, sdrlen) == 0)
		free(psdr, M_DEVBUF, sdrlen);

	return (0);
}

int
getbits(u_int8_t *bytes, int bitpos, int bitlen)
{
	int	v;
	int	mask;

	bitpos += bitlen - 1;
	for (v = 0; bitlen--;) {
		v <<= 1;
		mask = 1L << (bitpos & 7);
		if (bytes[bitpos >> 3] & mask)
			v |= 1;
		bitpos--;
	}

	return (v);
}

/* Decode IPMI sensor name */
int
ipmi_sensor_name(char *name, int len, u_int8_t typelen, u_int8_t *bits,
    int bitslen)
{
	int	i, slen;
	char	bcdplus[] = "0123456789 -.:,_";

	slen = typelen & 0x1F;
	switch (typelen >> 6) {
	case IPMI_NAME_UNICODE:
		//unicode
		break;

	case IPMI_NAME_BCDPLUS:
		/* Characters are encoded in 4-bit BCDPLUS */
		if (len < slen * 2 + 1)
			slen = (len >> 1) - 1;
		if (slen > bitslen)
			return (0);
		for (i = 0; i < slen; i++) {
			*(name++) = bcdplus[bits[i] >> 4];
			*(name++) = bcdplus[bits[i] & 0xF];
		}
		break;

	case IPMI_NAME_ASCII6BIT:
		/* Characters are encoded in 6-bit ASCII
		 *   0x00 - 0x3F maps to 0x20 - 0x5F */
		/* XXX: need to calculate max len: slen = 3/4 * len */
		if (len < slen + 1)
			slen = len - 1;
		if (slen * 6 / 8 > bitslen)
			return (0);
		for (i = 0; i < slen * 8; i += 6) {
			*(name++) = getbits(bits, i, 6) + ' ';
		}
		break;

	case IPMI_NAME_ASCII8BIT:
		/* Characters are 8-bit ascii */
		if (len < slen + 1)
			slen = len - 1;
		if (slen > bitslen)
			return (0);
		while (slen--)
			*(name++) = *(bits++);
		break;
	}
	*name = 0;

	return (1);
}

/* Calculate val * 10^exp */
long
ipow(long val, int exp)
{
	while (exp > 0) {
		val *= 10;
		exp--;
	}

	while (exp < 0) {
		val /= 10;
		exp++;
	}

	return (val);
}

/* Sign extend a n-bit value */
long
signextend(unsigned long val, int bits)
{
	long msk = (1L << (bits-1))-1;

	return (-(val & ~msk) | val);
}

/* Convert IPMI reading from sensor factors */
long
ipmi_convert(u_int8_t v, struct sdrtype1 *s1, long adj)
{
	short	M, B;
	char	K1, K2;
	long	val;

	/* Calculate linear reading variables */
	M  = signextend((((short)(s1->m_tolerance & 0xC0)) << 2) + s1->m, 10);
	B  = signextend((((short)(s1->b_accuracy & 0xC0)) << 2) + s1->b, 10);
	K1 = signextend(s1->rbexp & 0xF, 4);
	K2 = signextend(s1->rbexp >> 4, 4);

	/* Calculate sensor reading:
	 *  y = L((M * v + (B * 10^K1)) * 10^(K2+adj)
	 *
	 * This commutes out to:
	 *  y = L(M*v * 10^(K2+adj) + B * 10^(K1+K2+adj)); */
	val = ipow(M * v, K2 + adj) + ipow(B, K1 + K2 + adj);

	/* Linearization function: y = f(x) 0 : y = x 1 : y = ln(x) 2 : y =
	 * log10(x) 3 : y = log2(x) 4 : y = e^x 5 : y = 10^x 6 : y = 2^x 7 : y
	 * = 1/x 8 : y = x^2 9 : y = x^3 10 : y = square root(x) 11 : y = cube
	 * root(x) */
	return (val);
}

int
ipmi_sensor_status(struct ipmi_softc *sc, struct ipmi_sensor *psensor,
    u_int8_t *reading)
{
	struct sdrtype1	*s1 = (struct sdrtype1 *)psensor->i_sdr;
	int		etype;

	/* Get reading of sensor */
	switch (psensor->i_sensor.type) {
	case SENSOR_TEMP:
		psensor->i_sensor.value = ipmi_convert(reading[0], s1, 6);
		psensor->i_sensor.value += 273150000;
		break;

	case SENSOR_VOLTS_DC:
		psensor->i_sensor.value = ipmi_convert(reading[0], s1, 6);
		break;

	case SENSOR_FANRPM:
		psensor->i_sensor.value = ipmi_convert(reading[0], s1, 0);
		if (((s1->units1>>3)&0x7) == 0x3)
			psensor->i_sensor.value *= 60; // RPS -> RPM
		break;
	default:
		break;
	}

	/* Return Sensor Status */
	etype = (psensor->etype << 8) + psensor->stype;
	switch (etype) {
	case IPMI_SENSOR_TYPE_TEMP:
	case IPMI_SENSOR_TYPE_VOLT:
	case IPMI_SENSOR_TYPE_FAN:
		/* non-recoverable threshold */
		if (reading[2] & ((1 << 5) | (1 << 2)))
			return (SENSOR_S_CRIT);
		/* critical threshold */
		else if (reading[2] & ((1 << 4) | (1 << 1)))
			return (SENSOR_S_CRIT);
		/* non-critical threshold */
		else if (reading[2] & ((1 << 3) | (1 << 0)))
			return (SENSOR_S_WARN);
		break;

	case IPMI_SENSOR_TYPE_INTRUSION:
		psensor->i_sensor.value = (reading[2] & 1) ? 1 : 0;
		if (reading[2] & 0x1)
			return (SENSOR_S_CRIT);
		break;

	case IPMI_SENSOR_TYPE_PWRSUPPLY:
		/* Reading: 1 = present+powered, 0 = otherwise */
		psensor->i_sensor.value = (reading[2] & 1) ? 1 : 0;
		if (reading[2] & 0x10) {
			/* XXX: Need sysctl type for Power Supply types
			 *   ok: power supply installed && powered
			 * warn: power supply installed && !powered
			 * crit: power supply !installed
			 */
			return (SENSOR_S_CRIT);
		}
		if (reading[2] & 0x08) {
			/* Power supply AC lost */
			return (SENSOR_S_WARN);
		}
		break;
	}

	return (SENSOR_S_OK);
}

int
read_sensor(struct ipmi_softc *sc, struct ipmi_sensor *psensor)
{
	struct sdrtype1	*s1 = (struct sdrtype1 *) psensor->i_sdr;
	u_int8_t	data[8];
	int		rv = -1;

	memset(data, 0, sizeof(data));
	data[0] = psensor->i_num;

	struct ipmi_cmd	c;
	c.c_sc = sc;
	c.c_rssa = s1->owner_id;
	c.c_rslun = s1->owner_lun;
	c.c_netfn = SE_NETFN;
	c.c_cmd = SE_GET_SENSOR_READING;
	c.c_txlen = 1;
	c.c_maxrxlen = sizeof(data);
	c.c_rxlen = 0;
	c.c_data = data;
	ipmi_cmd(&c);

	dbg_printf(10, "values=%.2x %.2x %.2x %.2x %s\n",
	    data[0],data[1],data[2],data[3], psensor->i_sensor.desc);
	psensor->i_sensor.flags &= ~SENSOR_FINVALID;
	if ((data[1] & IPMI_INVALID_SENSOR) ||
	    ((data[1] & IPMI_DISABLED_SENSOR) == 0 && data[0] == 0))
		psensor->i_sensor.flags |= SENSOR_FINVALID;
	psensor->i_sensor.status = ipmi_sensor_status(sc, psensor, data);
	rv = 0;
	return (rv);
}

int
ipmi_sensor_type(int type, int ext_type, int entity)
{
	switch (ext_type << 8L | type) {
	case IPMI_SENSOR_TYPE_TEMP:
		return (SENSOR_TEMP);

	case IPMI_SENSOR_TYPE_VOLT:
		return (SENSOR_VOLTS_DC);

	case IPMI_SENSOR_TYPE_FAN:
		return (SENSOR_FANRPM);

	case IPMI_SENSOR_TYPE_PWRSUPPLY:
		if (entity == IPMI_ENTITY_PWRSUPPLY)
			return (SENSOR_INDICATOR);
		break;

	case IPMI_SENSOR_TYPE_INTRUSION:
		return (SENSOR_INDICATOR);
	}

	return (-1);
}

/* Add Sensor to BSD Sysctl interface */
int
add_sdr_sensor(struct ipmi_softc *sc, u_int8_t *psdr, int sdrlen)
{
	int			rc;
	struct sdrtype1		*s1 = (struct sdrtype1 *)psdr;
	struct sdrtype2		*s2 = (struct sdrtype2 *)psdr;
	char			name[64];

	switch (s1->sdrhdr.record_type) {
	case IPMI_SDR_TYPEFULL:
		rc = ipmi_sensor_name(name, sizeof(name), s1->typelen,
		    s1->name, sdrlen - (int)offsetof(struct sdrtype1, name));
		if (rc == 0)
			return (0);
		rc = add_child_sensors(sc, psdr, 1, s1->sensor_num,
		    s1->sensor_type, s1->event_code, 0, s1->entity_id, name);
		break;

	case IPMI_SDR_TYPECOMPACT:
		rc = ipmi_sensor_name(name, sizeof(name), s2->typelen,
		    s2->name, sdrlen - (int)offsetof(struct sdrtype2, name));
		if (rc == 0)
			return (0);
		rc = add_child_sensors(sc, psdr, s2->share1 & 0xF,
		    s2->sensor_num, s2->sensor_type, s2->event_code,
		    s2->share2 & 0x7F, s2->entity_id, name);
		break;

	default:
		return (0);
	}

	return rc;
}

int
add_child_sensors(struct ipmi_softc *sc, u_int8_t *psdr, int count,
    int sensor_num, int sensor_type, int ext_type, int sensor_base,
    int entity, const char *name)
{
	int			typ, idx;
	struct ipmi_sensor	*psensor;
#ifdef IPMI_DEBUG
	struct sdrtype1		*s1 = (struct sdrtype1 *)psdr;
#endif

	typ = ipmi_sensor_type(sensor_type, ext_type, entity);
	if (typ == -1) {
		dbg_printf(5, "Unknown sensor type:%.2x et:%.2x sn:%.2x "
		    "name:%s\n", sensor_type, ext_type, sensor_num, name);
		return 0;
	}
	for (idx = 0; idx < count; idx++) {
		psensor = malloc(sizeof(*psensor), M_DEVBUF, M_NOWAIT | M_ZERO);
		if (psensor == NULL)
			break;

		/* Initialize BSD Sensor info */
		psensor->i_sdr = psdr;
		psensor->i_num = sensor_num + idx;
		psensor->stype = sensor_type;
		psensor->etype = ext_type;
		psensor->i_sensor.type = typ;
		if (count > 1)
			snprintf(psensor->i_sensor.desc,
			    sizeof(psensor->i_sensor.desc),
			    "%s - %d", name, sensor_base + idx);
		else
			strlcpy(psensor->i_sensor.desc, name,
			    sizeof(psensor->i_sensor.desc));

		dbg_printf(5, "add sensor:%.4x %.2x:%d ent:%.2x:%.2x %s\n",
		    s1->sdrhdr.record_id, s1->sensor_type,
		    typ, s1->entity_id, s1->entity_instance,
		    psensor->i_sensor.desc);
		if (read_sensor(sc, psensor) == 0) {
			SLIST_INSERT_HEAD(&ipmi_sensor_list, psensor, list);
			sensor_attach(&sc->sc_sensordev, &psensor->i_sensor);
			dbg_printf(5, "	 reading: %lld [%s]\n",
			    psensor->i_sensor.value,
			    psensor->i_sensor.desc);
		}
	}

	return (1);
}

/* Handle IPMI Timer - reread sensor values */
void
ipmi_refresh_sensors(struct ipmi_softc *sc)
{
	if (SLIST_EMPTY(&ipmi_sensor_list))
		return;

	sc->current_sensor = SLIST_NEXT(sc->current_sensor, list);
	if (sc->current_sensor == NULL)
		sc->current_sensor = SLIST_FIRST(&ipmi_sensor_list);

	if (read_sensor(sc, sc->current_sensor)) {
		dbg_printf(1, "%s: error reading: %s\n", DEVNAME(sc),
		    sc->current_sensor->i_sensor.desc);
		return;
	}
}

int
ipmi_map_regs(struct ipmi_softc *sc, struct ipmi_attach_args *ia)
{
	sc->sc_if = ipmi_get_if(ia->iaa_if_type);
	if (sc->sc_if == NULL)
		return (-1);

	if (ia->iaa_if_iotype == 'i')
		sc->sc_iot = ia->iaa_iot;
	else
		sc->sc_iot = ia->iaa_memt;

	sc->sc_if_rev = ia->iaa_if_rev;
	sc->sc_if_iospacing = ia->iaa_if_iospacing;
	if (bus_space_map(sc->sc_iot, ia->iaa_if_iobase,
	    sc->sc_if->nregs * sc->sc_if_iospacing,
	    0, &sc->sc_ioh)) {
		printf("%s: bus_space_map(%lx %x %x 0 %p) failed\n",
		    DEVNAME(sc),
		    (unsigned long)sc->sc_iot, ia->iaa_if_iobase,
		    sc->sc_if->nregs * sc->sc_if_iospacing, &sc->sc_ioh);
		return (-1);
	}
	return (0);
}

void
ipmi_unmap_regs(struct ipmi_softc *sc)
{
	bus_space_unmap(sc->sc_iot, sc->sc_ioh,
	    sc->sc_if->nregs * sc->sc_if_iospacing);
}

void
ipmi_poll_thread(void *arg)
{
	struct ipmi_thread	*thread = arg;
	struct ipmi_softc	*sc = thread->sc;
	u_int16_t		rec;

	/* Scan SDRs, add sensors */
	for (rec = 0; rec != 0xFFFF;) {
		if (get_sdr(sc, rec, &rec)) {
			ipmi_unmap_regs(sc);
			printf("%s: no SDRs IPMI disabled\n", DEVNAME(sc));
			goto done;
		}
		while (tsleep(sc, PWAIT, "ipmirun", 1) != EWOULDBLOCK)
			continue;
	}

	/* initialize sensor list for thread */
	if (SLIST_EMPTY(&ipmi_sensor_list))
		goto done;
	else
		sc->current_sensor = SLIST_FIRST(&ipmi_sensor_list);

	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));
	sensordev_install(&sc->sc_sensordev);

	while (thread->running) {
		ipmi_refresh_sensors(sc);
		tsleep(thread, PWAIT, "ipmi_poll", SENSOR_REFRESH_RATE);
	}

done:
	kthread_exit(0);
}

void
ipmi_create_thread(void *arg)
{
	struct ipmi_softc	*sc = arg;

	if (kthread_create(ipmi_poll_thread, sc->sc_thread, NULL,
	    DEVNAME(sc)) != 0) {
		printf("%s: unable to create run thread, ipmi disabled\n",
		    DEVNAME(sc));
		return;
	}
}

int
ipmi_probe(void *aux)
{
	struct ipmi_attach_args *ia = aux;
	struct dmd_ipmi *pipmi;
	struct smbtable tbl;

	tbl.cookie = 0;
	if (smbios_find_table(SMBIOS_TYPE_IPMIDEV, &tbl))
		ipmi_smbios_probe(tbl.tblhdr, ia);
	else {
		pipmi = (struct dmd_ipmi *)scan_sig(0xC0000L, 0xFFFFFL, 16, 4,
		    "IPMI");
		/* XXX hack to find Dell PowerEdge 8450 */
		if (pipmi == NULL) {
			/* no IPMI found */
			return (0);
		}

		/* we have an IPMI signature, fill in attach arg structure */
		ia->iaa_if_type = pipmi->dmd_if_type;
		ia->iaa_if_rev = pipmi->dmd_if_rev;
	}

	return (1);
}

int
ipmi_match(struct device *parent, void *match, void *aux)
{
	struct ipmi_softc	*sc;
	struct ipmi_attach_args *ia = aux;
	struct cfdata		*cf = match;
	u_int8_t		cmd[32];
	int			rv = 0;

	if (strcmp(ia->iaa_name, cf->cf_driver->cd_name))
		return (0);

	/* XXX local softc is wrong wrong wrong */
	sc = malloc(sizeof(*sc), M_TEMP, M_NOWAIT | M_ZERO);
	mtx_init(&sc->sc_cmd_mtx, IPL_NONE);
	strlcpy(sc->sc_dev.dv_xname, "ipmi0", sizeof(sc->sc_dev.dv_xname));

	/* Map registers */
	if (ipmi_map_regs(sc, ia) == 0) {
		sc->sc_if->probe(sc);

		/* Identify BMC device early to detect lying bios */
		struct ipmi_cmd c;
		c.c_sc = sc;
		c.c_rssa = BMC_SA;
		c.c_rslun = BMC_LUN;
		c.c_netfn = APP_NETFN;
		c.c_cmd = APP_GET_DEVICE_ID;
		c.c_txlen = 0;
		c.c_maxrxlen = sizeof(cmd);
		c.c_rxlen = 0;
		c.c_data = cmd;
		ipmi_cmd(&c);

		dbg_dump(1, "bmc data", c.c_rxlen, cmd);
		rv = 1; /* GETID worked, we got IPMI */
		ipmi_unmap_regs(sc);
	}

	free(sc, M_TEMP, sizeof(*sc));

	return (rv);
}

void
ipmi_attach(struct device *parent, struct device *self, void *aux)
{
	struct ipmi_softc	*sc = (void *) self;
	struct ipmi_attach_args *ia = aux;
	struct ipmi_cmd		*c = &sc->sc_ioctl.cmd;

	/* Map registers */
	ipmi_map_regs(sc, ia);

	sc->sc_thread = malloc(sizeof(struct ipmi_thread), M_DEVBUF, M_NOWAIT);
	if (sc->sc_thread == NULL) {
		printf(": unable to allocate thread\n");
		return;
	}
	sc->sc_thread->sc = sc;
	sc->sc_thread->running = 1;

	/* Setup threads */
	kthread_create_deferred(ipmi_create_thread, sc);

	printf(": version %d.%d interface %s %sbase 0x%x/%x spacing %d",
	    ia->iaa_if_rev >> 4, ia->iaa_if_rev & 0xF, sc->sc_if->name,
	    ia->iaa_if_iotype == 'i' ? "io" : "mem", ia->iaa_if_iobase,
	    ia->iaa_if_iospacing * sc->sc_if->nregs, ia->iaa_if_iospacing);
	if (ia->iaa_if_irq != -1)
		printf(" irq %d", ia->iaa_if_irq);
	printf("\n");

	/* setup flag to exclude iic */
	ipmi_enabled = 1;

	/* Setup Watchdog timer */
	sc->sc_wdog_period = 0;
	task_set(&sc->sc_wdog_tickle_task, ipmi_watchdog_tickle, sc);
	wdog_register(ipmi_watchdog, sc);

	rw_init(&sc->sc_ioctl.lock, DEVNAME(sc));
	sc->sc_ioctl.req.msgid = -1;
	c->c_sc = sc;
	c->c_ccode = -1;

	sc->sc_cmd_taskq = taskq_create("ipmicmd", 1, IPL_NONE, TASKQ_MPSAFE);
	mtx_init(&sc->sc_cmd_mtx, IPL_NONE);
}

int
ipmi_activate(struct device *self, int act)
{
	switch (act) {
	case DVACT_POWERDOWN:
		wdog_shutdown(self);
		break;
	}

	return (0);
}

struct ipmi_softc *
ipmilookup(dev_t dev)
{
	return (struct ipmi_softc *)device_lookup(&ipmi_cd, minor(dev));
}

int
ipmiopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct ipmi_softc	*sc = ipmilookup(dev);

	if (sc == NULL)
		return (ENXIO);
	return (0);
}

int
ipmiclose(dev_t dev, int flags, int mode, struct proc *p)
{
	struct ipmi_softc	*sc = ipmilookup(dev);

	if (sc == NULL)
		return (ENXIO);
	return (0);
}

int
ipmiioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *proc)
{
	struct ipmi_softc	*sc = ipmilookup(dev);
	struct ipmi_req		*req = (struct ipmi_req *)data;
	struct ipmi_recv	*recv = (struct ipmi_recv *)data;
	struct ipmi_cmd		*c = &sc->sc_ioctl.cmd;
	int			iv;
	int			len;
	u_char			ccode;
	int			rc = 0;

	if (sc == NULL)
		return (ENXIO);

	rw_enter_write(&sc->sc_ioctl.lock);

	c->c_maxrxlen = sizeof(sc->sc_ioctl.buf);
	c->c_data = sc->sc_ioctl.buf;

	switch (cmd) {
	case IPMICTL_SEND_COMMAND:
		if (req->msgid == -1) {
			rc = EINVAL;
			goto reset;
		}
		if (sc->sc_ioctl.req.msgid != -1) {
			rc = EBUSY;
			goto reset;
		}
		len = req->msg.data_len;
		if (len < 0) {
			rc = EINVAL;
			goto reset;
		}
		if (len > c->c_maxrxlen) {
			rc = E2BIG;
			goto reset;
		}
		sc->sc_ioctl.req = *req;
		c->c_ccode = -1;
		rc = copyin(req->msg.data, c->c_data, len);
		if (rc != 0)
			goto reset;
		KASSERT(c->c_ccode == -1);

		/* Execute a command synchronously. */
		c->c_netfn = req->msg.netfn;
		c->c_cmd = req->msg.cmd;
		c->c_txlen = req->msg.data_len;
		c->c_rxlen = 0;
		ipmi_cmd(c);

		KASSERT(c->c_ccode != -1);
		break;
	case IPMICTL_RECEIVE_MSG_TRUNC:
	case IPMICTL_RECEIVE_MSG:
		if (sc->sc_ioctl.req.msgid == -1) {
			rc = EINVAL;
			goto reset;
		}
		if (c->c_ccode == -1) {
			rc = EAGAIN;
			goto reset;
		}
		ccode = c->c_ccode & 0xff;
		rc = copyout(&ccode, recv->msg.data, 1);
		if (rc != 0)
			goto reset;

		/* Return a command result. */
		recv->recv_type = IPMI_RESPONSE_RECV_TYPE;
		recv->msgid = sc->sc_ioctl.req.msgid;
		recv->msg.netfn = sc->sc_ioctl.req.msg.netfn;
		recv->msg.cmd = sc->sc_ioctl.req.msg.cmd;
		recv->msg.data_len = c->c_rxlen + 1;

		rc = copyout(c->c_data, recv->msg.data + 1, c->c_rxlen);
		/* Always reset state after command completion. */
		goto reset;
	case IPMICTL_SET_MY_ADDRESS_CMD:
		iv = *(int *)data;
		if (iv < 0 || iv > RSSA_MASK) {
			rc = EINVAL;
			goto reset;
		}
		c->c_rssa = iv;
		break;
	case IPMICTL_GET_MY_ADDRESS_CMD:
		*(int *)data = c->c_rssa;
		break;
	case IPMICTL_SET_MY_LUN_CMD:
		iv = *(int *)data;
		if (iv < 0 || iv > LUN_MASK) {
			rc = EINVAL;
			goto reset;
		}
		c->c_rslun = iv;
		break;
	case IPMICTL_GET_MY_LUN_CMD:
		*(int *)data = c->c_rslun;
		break;
	case IPMICTL_SET_GETS_EVENTS_CMD:
		break;
	case IPMICTL_REGISTER_FOR_CMD:
	case IPMICTL_UNREGISTER_FOR_CMD:
	default:
		break;
	}
done:
	rw_exit_write(&sc->sc_ioctl.lock);
	return (rc);
reset:
	sc->sc_ioctl.req.msgid = -1;
	c->c_ccode = -1;
	goto done;
}

#define		MIN_PERIOD	10

int
ipmi_watchdog(void *arg, int period)
{
	struct ipmi_softc	*sc = arg;

	if (sc->sc_wdog_period == period) {
		if (period != 0) {
			struct task *t;
			int res;

			t = &sc->sc_wdog_tickle_task;
			(void)task_del(systq, t);
			res = task_add(systq, t);
			KASSERT(res == 1);
		}
		return (period);
	}

	if (period < MIN_PERIOD && period > 0)
		period = MIN_PERIOD;
	sc->sc_wdog_period = period;
	ipmi_watchdog_set(sc);
	printf("%s: watchdog %sabled\n", DEVNAME(sc),
	    (period == 0) ? "dis" : "en");
	return (period);
}

void
ipmi_watchdog_tickle(void *arg)
{
	struct ipmi_softc	*sc = arg;
	struct ipmi_cmd		c;

	c.c_sc = sc;
	c.c_rssa = BMC_SA;
	c.c_rslun = BMC_LUN;
	c.c_netfn = APP_NETFN;
	c.c_cmd = APP_RESET_WATCHDOG;
	c.c_txlen = 0;
	c.c_maxrxlen = 0;
	c.c_rxlen = 0;
	c.c_data = NULL;
	ipmi_cmd(&c);
}

void
ipmi_watchdog_set(void *arg)
{
	struct ipmi_softc	*sc = arg;
	uint8_t			wdog[IPMI_GET_WDOG_MAX];
	struct ipmi_cmd		c;

	c.c_sc = sc;
	c.c_rssa = BMC_SA;
	c.c_rslun = BMC_LUN;
	c.c_netfn = APP_NETFN;
	c.c_cmd = APP_GET_WATCHDOG_TIMER;
	c.c_txlen = 0;
	c.c_maxrxlen = IPMI_GET_WDOG_MAX;
	c.c_rxlen = 0;
	c.c_data = wdog;
	ipmi_cmd(&c);

	/* Period is 10ths/sec */
	uint16_t timo = htole16(sc->sc_wdog_period * 10);

	memcpy(&wdog[IPMI_SET_WDOG_TIMOL], &timo, 2);
	wdog[IPMI_SET_WDOG_TIMER] &= ~IPMI_WDOG_DONTSTOP;
	wdog[IPMI_SET_WDOG_TIMER] |= (sc->sc_wdog_period == 0) ?
	    0 : IPMI_WDOG_DONTSTOP;
	wdog[IPMI_SET_WDOG_ACTION] &= ~IPMI_WDOG_MASK;
	wdog[IPMI_SET_WDOG_ACTION] |= (sc->sc_wdog_period == 0) ?
	    IPMI_WDOG_DISABLED : IPMI_WDOG_REBOOT;

	c.c_cmd = APP_SET_WATCHDOG_TIMER;
	c.c_txlen = IPMI_SET_WDOG_MAX;
	c.c_maxrxlen = 0;
	c.c_rxlen = 0;
	c.c_data = wdog;
	ipmi_cmd(&c);
}
@


1.98
log
@set c.c_maxrxlen to something. apparently lost a line somewhere.
maybe it works now? :)
from Colin Stolley via Paul B. Henson
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.97 2016/06/07 01:31:54 tedu Exp $ */
a29 1
#include <sys/types.h>
@


1.97
log
@per trending style, add continue to empty loops.
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.96 2016/03/27 12:45:47 mpi Exp $ */
d1097 1
@


1.96
log
@Always sleep at same priority.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.95 2016/02/11 04:02:22 uebayasi Exp $ */
d643 1
a643 1
			;
@


1.95
log
@ipmi(4) - Check sensor name length more carefully

Don't blindly trust sensor name info returned from BMC.  Check them more
carefully.  Prevent DELL R210 II from panic'ing.

Problem reported & tested by sthen@@
Much feedback & close review & OK by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.94 2016/02/07 12:19:14 uebayasi Exp $ */
d1579 1
a1579 1
		while (tsleep(sc, PUSER + 1, "ipmirun", 1) != EWOULDBLOCK)
@


1.94
log
@Comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.93 2016/02/07 12:17:33 uebayasi Exp $ */
d146 1
a146 1
int	add_sdr_sensor(struct ipmi_softc *, u_int8_t *);
d173 1
a173 1
void	ipmi_sensor_name(char *, int, u_int8_t, u_int8_t *);
d1105 2
d1165 1
a1165 1
	if (add_sdr_sensor(sc, psdr) == 0)
d1190 3
a1192 2
void
ipmi_sensor_name(char *name, int len, u_int8_t typelen, u_int8_t *bits)
d1207 2
d1221 3
a1223 1
		for (i = 0; i < slen * 8; i += 6)
d1225 1
d1232 2
d1239 2
d1428 1
a1428 1
add_sdr_sensor(struct ipmi_softc *sc, u_int8_t *psdr)
d1437 4
a1440 1
		ipmi_sensor_name(name, sizeof(name), s1->typelen, s1->name);
d1446 4
a1449 1
		ipmi_sensor_name(name, sizeof(name), s2->typelen, s2->name);
@


1.93
log
@Remove a too strict assertion.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.92 2016/02/05 06:29:01 uebayasi Exp $ */
d1830 1
@


1.92
log
@Implement FreeBSD-compatible IOCTL to access BMC in ipmi(4)

Initial help & testing by jmatthew@@
Code review & input by mpi@@
Final review & OK by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.91 2016/01/25 06:36:47 uebayasi Exp $ */
d1882 1
a1882 2
			res = task_del(systq, t);
			KASSERT(res == 0);
@


1.91
log
@Replace magic numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.90 2016/01/12 10:44:32 uebayasi Exp $ */
d4 1
d35 1
a36 1
#include <sys/timeout.h>
a42 1
#include <machine/intr.h>
d49 1
a59 1
int	ipmi_nintr;
a142 2
struct timeout ipmi_timeout;

a152 1
void	ipmi_delay(struct ipmi_softc *, int);
a161 1
int	ipmi_intr(void *);
d165 5
d178 1
a178 4
int	bmc_io_wait(struct ipmi_softc *, int, u_int8_t, u_int8_t, const char *);
int	bmc_io_wait_cold(struct ipmi_softc *, int, u_int8_t, u_int8_t,
    const char *);
void	_bmc_io_wait(void *);
a268 55
void
_bmc_io_wait(void *arg)
{
	struct ipmi_softc	*sc = arg;
	struct ipmi_bmc_args	*a = sc->sc_iowait_args;

	*a->v = bmc_read(sc, a->offset);
	if ((*a->v & a->mask) == a->value) {
		sc->sc_wakeup = 0;
		wakeup(sc);
		return;
	}

	if (++sc->sc_retries > sc->sc_max_retries) {
		sc->sc_wakeup = 0;
		wakeup(sc);
		return;
	}

	timeout_add(&sc->sc_timeout, 1);
}

int
bmc_io_wait(struct ipmi_softc *sc, int offset, u_int8_t mask, u_int8_t value,
    const char *lbl)
{
	volatile u_int8_t	v;
	struct ipmi_bmc_args	args;

	if (cold)
		return (bmc_io_wait_cold(sc, offset, mask, value, lbl));

	sc->sc_retries = 0;
	sc->sc_wakeup = 1;

	args.offset = offset;
	args.mask = mask;
	args.value = value;
	args.v = &v;
	sc->sc_iowait_args = &args;

	_bmc_io_wait(sc);

	while (sc->sc_wakeup)
		tsleep(sc, PWAIT, lbl, 0);

	if (sc->sc_retries > sc->sc_max_retries) {
		dbg_printf(1, "%s: bmc_io_wait fails : v=%.2x m=%.2x "
		    "b=%.2x %s\n", DEVNAME(sc), v, mask, value, lbl);
		return (-1);
	}

	return (v);
}

d270 1
a270 2
bmc_io_wait_cold(struct ipmi_softc *sc, int offset, u_int8_t mask,
    u_int8_t value, const char *lbl)
d276 2
a277 2
		v = bmc_read(sc, offset);
		if ((v & mask) == value)
d283 2
a284 2
	dbg_printf(1, "%s: bmc_io_wait_cold fails : *v=%.2x m=%.2x b=%.2x %s\n",
	    DEVNAME(sc), v, mask, value, lbl);
d289 3
a291 1
#define NETFN_LUN(nf,ln) (((nf) << 2) | ((ln) & 0x3))
d328 7
a334 1
	if (bmc_io_wait(sc, _BT_CTRL_REG, BT_BMC_BUSY, 0, "bt_write") < 0)
d345 1
d353 5
a357 2
	if (bmc_io_wait(sc, _BT_CTRL_REG, BT_HOST2BMC_ATN | BT_BMC_BUSY, 0,
	    "bt_sendwait") < 0)
d367 1
d370 5
a374 2
	if (bmc_io_wait(sc, _BT_CTRL_REG, BT_BMC2HOST_ATN, BT_BMC2HOST_ATN,
	    "bt_recvwait") < 0)
d465 1
d469 5
a473 1
	v = bmc_io_wait(sc, _SMIC_FLAG_REG, mask, val, "smicwait");
d624 1
d627 5
a631 1
	v = bmc_io_wait(sc, _KCS_STATUS_REGISTER, mask, value, lbl);
d752 2
a991 2
	ipmi_delay(sc, 5); /* give bmc chance to digest command */

a1025 2
	ipmi_delay(sc, 5); /* give bmc chance to digest command */

a1029 11
ipmi_delay(struct ipmi_softc *sc, int period)
{
	/* period is in 10 ms increments */
	if (cold)
		delay(period * 10000);
	else
		while (tsleep(sc, PWAIT, "ipmicmd", period) != EWOULDBLOCK)
			continue;
}

void
a1042 1
	c->c_sc->sc_cmd = c;
a1046 1
	c->c_sc->sc_cmd = NULL;
d1097 1
a1362 3
	if (!cold)
		rw_enter_write(&sc->sc_lock);

a1385 2
	if (!cold)
		rw_exit_write(&sc->sc_lock);
a1495 14
/* Interrupt handler */
int
ipmi_intr(void *arg)
{
	struct ipmi_softc	*sc = (struct ipmi_softc *)arg;
	int			v;

	v = bmc_read(sc, _KCS_STATUS_REGISTER);
	if (v & KCS_OBF)
		++ipmi_nintr;

	return (0);
}

a1536 5
#if 0
	if (iaa->if_if_irq != -1)
		sc->ih = isa_intr_establish(-1, iaa->if_if_irq,
		    iaa->if_irqlvl, IPL_BIO, ipmi_intr, sc, DEVNAME(sc));
#endif
d1627 1
a1627 1
	struct ipmi_softc	sc;
d1637 3
a1639 2
	mtx_init(&sc.sc_cmd_mtx, IPL_NONE);
	strlcpy(sc.sc_dev.dv_xname, "ipmi0", sizeof(sc.sc_dev.dv_xname));
d1642 2
a1643 2
	if (ipmi_map_regs(&sc, ia) == 0) {
		sc.sc_if->probe(&sc);
d1647 1
a1647 1
		c.c_sc = &sc;
d1660 1
a1660 1
		ipmi_unmap_regs(&sc);
d1663 2
d1673 1
d1705 4
a1708 8
	/* lock around read_sensor so that no one messes with the bmc regs */
	rw_init(&sc->sc_lock, DEVNAME(sc));

	/* setup ticker */
	sc->sc_retries = 0;
	sc->sc_wakeup = 0;
	sc->sc_max_retries = 50; /* 50 * 1/100 = 0.5 seconds max */
	timeout_set(&sc->sc_timeout, _bmc_io_wait, sc);
d1726 143
a1902 1
	int			s;
a1904 2
	s = splsoftclock();

a1914 2

	splx(s);
a1921 1
	int			s;
a1923 2
	s = splsoftclock();

a1951 2

	splx(s);
@


1.90
log
@Use task to execute command except polling context.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1128 1
a1128 1
	u_int8_t	cmd[8 + 255];	/* 8 + max of length */
d1142 1
a1142 1
	c.c_txlen = 6;
@


1.89
log
@Use task to execute watchdog tickle.
@
text
@d156 4
a159 1
void	ipmi_cmd(void *);
d1075 1
a1075 1
ipmi_cmd(void *arg)
d1077 10
a1086 1
	struct ipmi_cmd		*c = arg;
d1094 27
d1707 1
d1779 3
@


1.88
log
@Refactor ipmi_watchdog(); split tickle and set into separate functions.
@
text
@d39 1
d1728 1
d1762 8
a1769 1
			ipmi_watchdog_tickle(sc);
@


1.87
log
@Make sendmsg() and recvmsg() functions take only struct ipmi_cmd *.
Handle interface specific command length more nicely.  No functional
changes.
@
text
@d158 2
a1756 3
	uint8_t			wdog[IPMI_GET_WDOG_MAX];
	int			s;
	struct ipmi_cmd		c;
d1760 1
a1760 15
			s = splsoftclock();

			/* tickle the watchdog */
			c.c_sc = sc;
			c.c_rssa = BMC_SA;
			c.c_rslun = BMC_LUN;
			c.c_netfn = APP_NETFN;
			c.c_cmd = APP_RESET_WATCHDOG;
			c.c_txlen = 0;
			c.c_maxrxlen = 0;
			c.c_rxlen = 0;
			c.c_data = NULL;
			ipmi_cmd(&c);

			splx(s);
d1767 37
d1819 1
a1819 1
	uint16_t timo = htole16(period * 10);
d1823 2
a1824 1
	wdog[IPMI_SET_WDOG_TIMER] |= (period == 0) ? 0 : IPMI_WDOG_DONTSTOP;
d1826 2
a1827 2
	wdog[IPMI_SET_WDOG_ACTION] |= (period == 0) ? IPMI_WDOG_DISABLED :
	    IPMI_WDOG_REBOOT;
a1836 5

	sc->sc_wdog_period = period;
	printf("%s: watchdog %sabled\n", DEVNAME(sc),
	    (period == 0) ? "dis" : "en");
	return (period);
@


1.86
log
@Allocate command data buffer on softc and use it from both ipmi_sendcmd()
and ipmi_recvcmd().  No functional changes.
@
text
@d203 2
d215 2
d227 2
d386 1
a386 1
bt_sendmsg(struct ipmi_softc *sc, int len, const u_int8_t *data)
d388 1
d392 2
a393 2
	for (i = 0; i < len; i++)
		bt_write(sc, _BT_DATAOUT_REG, data[i]);
d404 1
a404 1
bt_recvmsg(struct ipmi_softc *sc, int maxlen, int *rxlen, u_int8_t *data)
d406 2
a407 1
	u_int8_t len, v, i;
d417 1
a417 1
	for (i = IPMI_BTMSG_NFLN; i <= len; i++) {
d420 1
a420 1
			*(data++) = v;
d423 1
a423 1
	*rxlen = len - 1;
d553 1
a553 1
smic_sendmsg(struct ipmi_softc *sc, int len, const u_int8_t *data)
d555 1
d558 1
a558 1
	sts = smic_write_cmd_data(sc, SMS_CC_START_TRANSFER, &data[0]);
d560 1
a560 1
	for (idx = 1; idx < len - 1; idx++) {
d562 1
a562 1
		    &data[idx]);
d565 1
a565 1
	sts = smic_write_cmd_data(sc, SMS_CC_END_TRANSFER, &data[idx]);
d567 1
a567 1
		dbg_printf(50, "smic_sendmsg %d/%d = %.2x\n", idx, len, sts);
d575 1
a575 1
smic_recvmsg(struct ipmi_softc *sc, int maxlen, int *len, u_int8_t *data)
d577 1
d580 1
a580 1
	*len = 0;
d588 1
a588 1
		sts = smic_read_data(sc, &data[idx++]);
d595 1
a595 1
	*len = idx;
d599 1
a599 1
		dbg_printf(50, "smic_recvmsg %d/%d = %.2x\n", idx, maxlen, sts);
d717 1
a717 1
kcs_sendmsg(struct ipmi_softc *sc, int len, const u_int8_t * data)
d719 1
d723 1
a723 1
	dbg_dump(50, "kcs sendmsg", len, data);
d725 2
a726 2
	for (idx = 0; idx < len; idx++) {
		if (idx == len - 1)
d732 1
a732 1
		sts = kcs_write_data(sc, data[idx]);
d735 2
a736 2
		dbg_printf(1, "kcs sendmsg = %d/%d <%.2x>\n", idx, len, sts);
		dbg_dump(1, "kcs_sendmsg", len, data);
d744 1
a744 1
kcs_recvmsg(struct ipmi_softc *sc, int maxlen, int *rxlen, u_int8_t * data)
d746 1
d749 2
a750 2
	for (idx = 0; idx < maxlen; idx++) {
		sts = kcs_read_data(sc, &data[idx]);
d755 1
a755 1
	*rxlen = idx;
d757 1
a757 1
		dbg_printf(1, "kcs recvmsg = %d/%d <%.2x>\n", idx, maxlen, sts);
d761 1
a761 1
	dbg_dump(50, "kcs recvmsg", idx, data);
d957 1
a957 1
	buf[IPMI_BTMSG_LEN] = c->c_txlen + 3;
a962 4

	/* Block transfer needs 4 extra bytes: length/netfn/seq/cmd + data */
	c->c_txlen += IPMI_BTMSG_DATASND;
	c->c_maxrxlen += IPMI_BTMSG_DATARCV;
a978 4

	/* Common needs two extra bytes: nfLun/cmd + data */
	c->c_txlen += IPMI_MSG_DATASND;
	c->c_maxrxlen += IPMI_MSG_DATARCV;
d1013 2
a1014 1
	rc = sc->sc_if->sendmsg(sc, c->c_txlen, sc->sc_buf);
a1027 1
	int		rawlen;
d1030 3
a1032 2
	if (sc->sc_if->recvmsg(sc, c->c_maxrxlen + 3, &rawlen, buf) ||
	    rawlen < IPMI_MSG_DATARCV) {
d1036 1
a1036 1
	c->c_rxlen = rawlen - IPMI_MSG_DATARCV;
d1038 1
a1038 1
		memcpy(c->c_data, buf + IPMI_MSG_DATARCV, c->c_rxlen);
a1100 1
	c.c_maxrxlen = 8 + length;
a1101 1
	c.c_data = cmd;
@


1.85
log
@Refactor buildmsg() functions to take struct ipmi_cmd * instead of 6
arguments.  No functional changes.
@
text
@d176 2
a177 2
void	*bt_buildmsg(struct ipmi_cmd *);
void	*cmn_buildmsg(struct ipmi_cmd *);
d939 1
a939 1
void *
d943 1
a943 6
	u_int8_t *buf;

	/* Block transfer needs 4 extra bytes: length/netfn/seq/cmd + data */
	buf = malloc(c->c_txlen + 4, M_DEVBUF, M_NOWAIT);
	if (buf == NULL)
		return (NULL);
d952 3
a954 3
	c->c_txlen += 4;

	return (buf);
d961 1
a961 1
void *
d964 2
a965 6
	u_int8_t *buf;

	/* Common needs two extra bytes: nfLun/cmd + data */
	buf = malloc(c->c_txlen + 2, M_DEVBUF, M_NOWAIT);
	if (buf == NULL)
		return (NULL);
d972 3
a974 3
	c->c_txlen += 2;

	return (buf);
a981 1
	u_int8_t	*buf;
d989 1
a989 1
		buf = sc->sc_if->buildmsg(c);
d1007 1
a1007 1
		buf = sc->sc_if->buildmsg(c);
d1009 1
a1009 6
	if (buf == NULL) {
		printf("%s: sendcmd malloc fails\n", DEVNAME(sc));
		goto done;
	}
	rc = sc->sc_if->sendmsg(sc, c->c_txlen, buf);
	free(buf, M_DEVBUF, c->c_txlen);
d1022 1
a1022 1
	u_int8_t	*buf, rc = 0;
a1024 6
	/* Need three extra bytes: netfn/cmd/ccode + data */
	buf = malloc(c->c_maxrxlen + 3, M_DEVBUF, M_NOWAIT);
	if (buf == NULL) {
		printf("%s: ipmi_recvcmd: malloc fails\n", DEVNAME(sc));
		return (-1);
	}
a1027 1
		free(buf, M_DEVBUF, c->c_maxrxlen + 3);
a1046 2
	free(buf, M_DEVBUF, c->c_maxrxlen + 3);

d1663 1
@


1.84
log
@Introduce struct ipmi_cmd and have ipmi_cmd() function.  IPMI command
sequence is always a pair of send and receive; call both from ipmi_cmd().
By making ipmi_cmd() take only one argument struct ipmi_cmd *, this also
helps to prepare to call ipmi_cmd() as a task.

No functional changes intended.
@
text
@d176 2
a177 2
void	*bt_buildmsg(struct ipmi_softc *, int, int, int, const void *, int *);
void	*cmn_buildmsg(struct ipmi_softc *, int, int, int, const void *, int *);
d940 1
a940 2
bt_buildmsg(struct ipmi_softc *sc, int nfLun, int cmd, int len,
    const void *data, int *txlen)
d942 1
d946 1
a946 2
	*txlen = len + 4;
	buf = malloc(*txlen, M_DEVBUF, M_NOWAIT);
d950 2
a951 2
	buf[IPMI_BTMSG_LEN] = len + 3;
	buf[IPMI_BTMSG_NFLN] = nfLun;
d953 5
a957 3
	buf[IPMI_BTMSG_CMD] = cmd;
	if (len && data)
		memcpy(buf + IPMI_BTMSG_DATASND, data, len);
d967 1
a967 2
cmn_buildmsg(struct ipmi_softc *sc, int nfLun, int cmd, int len,
    const void *data, int *txlen)
d972 1
a972 2
	*txlen = len + 2;
	buf = malloc(*txlen, M_DEVBUF, M_NOWAIT);
d976 6
a981 4
	buf[IPMI_MSG_NFLN] = nfLun;
	buf[IPMI_MSG_CMD] = cmd;
	if (len && data)
		memcpy(buf + IPMI_MSG_DATASND, data, len);
d999 1
a999 2
		buf = sc->sc_if->buildmsg(sc, NETFN_LUN(APP_NETFN, BMC_LUN),
		    APP_SEND_MESSAGE, 7 + txlen, NULL, &txlen);
d1017 1
a1017 2
		buf = sc->sc_if->buildmsg(sc, NETFN_LUN(c->c_netfn, c->c_rslun), c->c_cmd,
		    c->c_txlen, c->c_data, &c->c_txlen);
@


1.83
log
@Remove useless sc_poll flag because it is always 1.  Remove unused global
ipmi_poll too.
@
text
@d152 2
a153 2
int	ipmi_sendcmd(struct ipmi_softc *, int, int, int, int, int, const void*);
int	ipmi_recvcmd(struct ipmi_softc *, int, int *, void *);
d155 1
a937 3
 *
 * Returns a buffer to an allocated message, txlen contains length
 *   of allocated message
a963 3
 *
 * Returns a buffer to an allocated message, txlen contains length
 *   of allocated message
d987 1
a987 2
ipmi_sendcmd(struct ipmi_softc *sc, int rssa, int rslun, int netfn, int cmd,
    int txlen, const void *data)
d989 1
d994 3
a996 3
	    rssa, NETFN_LUN(netfn, rslun), cmd, txlen);
	dbg_dump(10, " send", txlen, data);
	if (rssa != BMC_SA) {
d1017 2
a1018 2
		buf = sc->sc_if->buildmsg(sc, NETFN_LUN(netfn, rslun), cmd,
		    txlen, data, &txlen);
d1024 2
a1025 2
	rc = sc->sc_if->sendmsg(sc, txlen, buf);
	free(buf, M_DEVBUF, txlen);
d1033 1
d1035 1
a1035 1
ipmi_recvcmd(struct ipmi_softc *sc, int maxlen, int *rxlen, void *data)
d1037 1
d1042 1
a1042 1
	buf = malloc(maxlen + 3, M_DEVBUF, M_NOWAIT);
d1048 1
a1048 1
	if (sc->sc_if->recvmsg(sc, maxlen + 3, &rawlen, buf) ||
d1050 1
a1050 1
		free(buf, M_DEVBUF, maxlen + 3);
d1054 3
a1056 3
	*rxlen = rawlen - IPMI_MSG_DATARCV;
	if (*rxlen > 0 && data)
		memcpy(data, buf + IPMI_MSG_DATARCV, *rxlen);
d1067 2
a1068 2
	    *rxlen);
	dbg_dump(10, " recv", *rxlen, data);
d1070 1
a1070 1
	free(buf, M_DEVBUF, maxlen + 3);
d1088 13
d1113 14
a1126 9
	if (ipmi_sendcmd(sc, BMC_SA, 0, STORAGE_NETFN, STORAGE_GET_SDR, 6,
	    cmd)) {
		printf("%s: sendcmd fails\n", DEVNAME(sc));
		return (-1);
	}
	if (ipmi_recvcmd(sc, 8 + length, &len, cmd)) {
		printf("%s: getSdrPartial: recvcmd fails\n", DEVNAME(sc));
		return (-1);
	}
d1147 12
a1158 9
	if (ipmi_sendcmd(sc, BMC_SA, 0, STORAGE_NETFN, STORAGE_RESERVE_SDR,
	    0, NULL)) {
		printf("%s: reserve send fails\n", DEVNAME(sc));
		return (1);
	}
	if (ipmi_recvcmd(sc, sizeof(resid), &len, &resid)) {
		printf("%s: reserve recv fails\n", DEVNAME(sc));
		return (1);
	}
d1387 1
a1387 1
	int		rxlen, rv = -1;
a1393 3
	if (ipmi_sendcmd(sc, s1->owner_id, s1->owner_lun, SE_NETFN,
	    SE_GET_SENSOR_READING, 1, data))
		goto done;
d1395 11
a1405 2
	if (ipmi_recvcmd(sc, sizeof(data), &rxlen, data))
		goto done;
a1414 1
done:
d1601 1
a1601 1
	struct ipmi_softc 	*sc = thread->sc;
a1680 1
	int			len;
d1693 11
a1703 10
		if (ipmi_sendcmd(&sc, BMC_SA, 0, APP_NETFN, APP_GET_DEVICE_ID,
		    0, NULL)) {
			dbg_printf(1, ": unable to send get device id "
			    "command\n");
			goto unmap;
		}
		if (ipmi_recvcmd(&sc, sizeof(cmd), &len, cmd)) {
			dbg_printf(1, ": unable to retrieve device id\n");
			goto unmap;
		}
d1705 1
a1705 2
		dbg_dump(1, "bmc data", len, cmd);
unmap:
d1777 2
a1778 1
	int			s, rc, len;
d1783 1
d1785 11
a1795 3
			rc = ipmi_sendcmd(sc, BMC_SA, BMC_LUN, APP_NETFN,
			    APP_RESET_WATCHDOG, 0, NULL);
			rc = ipmi_recvcmd(sc, 0, &len, NULL);
d1805 11
a1815 4
	/* XXX what to do if poking wdog fails? */
	rc = ipmi_sendcmd(sc, BMC_SA, BMC_LUN, APP_NETFN,
	    APP_GET_WATCHDOG_TIMER, 0, NULL);
	rc = ipmi_recvcmd(sc, IPMI_GET_WDOG_MAX, &len, wdog);
d1827 6
a1832 3
	rc = ipmi_sendcmd(sc, BMC_SA, BMC_LUN, APP_NETFN,
	    APP_SET_WATCHDOG_TIMER, IPMI_SET_WDOG_MAX, wdog);
	rc = ipmi_recvcmd(sc, 0, &len, NULL);
@


1.82
log
@Read values from disabled sensors if possible.  From jmatthew@@.
@
text
@a58 1
int	ipmi_poll = 1;
d287 1
a287 1
	if (cold || sc->sc_poll)
d1084 1
a1084 1
	if (cold || sc->sc_poll)
a1521 3
	if (!ipmi_poll)
		return;

a1759 1
			sc->sc_poll = 1;
a1763 1
			sc->sc_poll = 0;
a1772 1
	sc->sc_poll = 1;
a1791 1
	sc->sc_poll = 0;
@


1.81
log
@Print a message to console when ipmi(4) watchdog is either enabled or
disabled.  Replace a magic number while here.
@
text
@d115 1
d1387 2
a1388 2
	if (data[1] & IPMI_INVALID_SENSOR) {
		/* Check if sensor is valid */
a1389 1
	}
@


1.80
log
@When stopping wdog (via wdog_shutdown() e.g. before entering shutdown),
clear DONTSTOP bits.  Without this, BMC records, at least on some NEC
servers, watchdog timer expiration event, which only confuses admins.

OK kettenis@@
@
text
@d1752 2
d1775 2
a1776 2
	if (period < 10 && period > 0)
		period = 10;
d1803 2
@


1.79
log
@Correct sensor threashold handling by properly checking response of Get Sensor
Reading Command.

Patch from jmatthew@@.  Extra review by kettenis@@.  Tested by me.
@
text
@d1787 2
@


1.78
log
@Copy received data only if it exists.  Avoid panics in odd situations.
@
text
@a187 1
int	ipmi_test_threshold(u_int8_t, u_int8_t, u_int8_t, u_int8_t, int);
a1293 13
ipmi_test_threshold(u_int8_t v, u_int8_t valid, u_int8_t hi, u_int8_t lo,
    int sign)
{
	dbg_printf(10, "thresh: %.2x %.2x %.2x %d %d\n", v, lo, hi,valid, sign);
	if (sign)
		return ((valid & 1 && lo != 0x00 && (int8_t)v <= (int8_t)lo) ||
		    (valid & 8 && hi != 0xFF && (int8_t)v >= (int8_t)hi));

	return ((valid & 1 && lo != 0x00 && v <= lo) ||
	    (valid & 8 && hi != 0xFF && v >= hi));
}

int
a1296 1
	u_int8_t	data[32];
d1298 1
a1298 2
	int		rxlen, etype;
	int		sign = s1->units1 >> 7 & 1;
d1326 2
a1327 12
		data[0] = psensor->i_num;
		if (ipmi_sendcmd(sc, s1->owner_id, s1->owner_lun,
		    SE_NETFN, SE_GET_SENSOR_THRESHOLD, 1, data) ||
		    ipmi_recvcmd(sc, sizeof(data), &rxlen, data))
			return (SENSOR_S_UNKNOWN);

		dbg_printf(25, "recvdata: %.2x %.2x %.2x %.2x %.2x %.2x %.2x\n",
		    data[0], data[1], data[2], data[3], data[4], data[5],
		    data[6]);

		if (ipmi_test_threshold(*reading, data[0] >> 2 ,
		    data[6], data[3], sign))
d1329 2
a1330 3

		if (ipmi_test_threshold(*reading, data[0] >> 1,
		    data[5], data[2], sign))
d1332 2
a1333 3

		if (ipmi_test_threshold(*reading, data[0] ,
		    data[4], data[1], sign))
a1334 1

@


1.77
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.76 2015/06/21 00:15:12 deraadt Exp $ */
d1115 2
a1116 1
	memcpy(buffer, cmd + 2, len - 2);
@


1.76
log
@memory leak on failure; from Maxime Villard
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.75 2015/01/07 07:49:18 yasuoka Exp $ */
d1031 1
a1031 1
	free(buf, M_DEVBUF, 0);
d1054 1
a1054 1
		free(buf, M_DEVBUF, 0);
d1074 1
a1074 1
	free(buf, M_DEVBUF, 0);
d1165 1
a1165 1
			free(psdr, M_DEVBUF, 0);
d1172 1
a1172 1
		free(psdr, M_DEVBUF, 0);
@


1.75
log
@Fix impi(4) to make watchdog work and not to panic.

diff from uebayasi jsg
ok uebayasi
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.74 2014/12/10 12:27:57 mikeb Exp $ */
d1053 2
a1054 1
	    rawlen < IPMI_MSG_DATARCV)
d1056 1
@


1.74
log
@Convert watchdog(4) devices to use autoconf(9) framework.

ok deraadt, tests on glxpcib and ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.73 2014/10/21 08:48:38 uebayasi Exp $ */
d288 1
a288 1
	if (cold)
d1052 2
a1053 1
	if (sc->sc_if->recvmsg(sc, maxlen + 3, &rawlen, buf))
d1083 1
a1083 1
	if (cold)
d1782 1
a1782 1
	struct ipmi_watchdog	wdog;
d1788 1
d1793 1
d1803 1
d1807 1
a1807 1
	rc = ipmi_recvcmd(sc, sizeof(wdog), &len, &wdog);
d1810 5
a1814 3
	wdog.wdog_timeout = htole32(period * 10);
	wdog.wdog_action &= ~IPMI_WDOG_MASK;
	wdog.wdog_action |= (period == 0) ? IPMI_WDOG_DISABLED :
d1818 1
a1818 1
	    APP_SET_WATCHDOG_TIMER, sizeof(wdog), &wdog);
d1821 1
@


1.73
log
@Style + typos in debug printfs.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d161 1
d839 2
a840 1
	sizeof(struct ipmi_softc), ipmi_match, ipmi_attach
d1763 12
@


1.72
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.71 2014/07/08 17:19:25 deraadt Exp $ */
d744 1
a744 1
		dbg_printf(1, "kcs read = %d/%d <%.2x>\n", idx, maxlen, sts);
d1060 1
a1060 1
		dbg_printf(1, "ipmi_recvmsg: nfln=%.2x cmd=%.2x err=%.2x\n",
d1083 2
a1084 1
		while (tsleep(sc, PWAIT, "ipmicmd", period) != EWOULDBLOCK);
d1615 2
a1616 1
		while (tsleep(sc, PUSER + 1, "ipmirun", 1) != EWOULDBLOCK);
@


1.71
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.70 2014/05/04 18:18:36 sf Exp $ */
d1029 1
a1029 1
	free(buf, M_DEVBUF);
d1069 1
a1069 1
	free(buf, M_DEVBUF);
d1159 1
a1159 1
			free(psdr, M_DEVBUF);
d1166 1
a1166 1
		free(psdr, M_DEVBUF);
@


1.70
log
@format string fix for bus_space_tag_t

bus_space_tag_t is a pointer everywhere, except on i386, where it's an int.
Cast to long.

ok kettenis@@
'Right idiom' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.69 2013/07/03 15:10:57 bluhm Exp $ */
a47 2

#include <uvm/uvm_extern.h>
@


1.69
log
@The ipmi threshold value may be negative.  Respect the sign bit
when checking wether an ipmi sensor is critial.
From Matthias Pitzl; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.68 2013/04/10 01:35:55 guenther Exp $ */
d1581 1
a1581 1
		printf("%s: bus_space_map(%x %x %x 0 %p) failed\n",
d1583 1
a1583 1
		    sc->sc_iot, ia->iaa_if_iobase,
@


1.68
log
@Fix various glitches in queue macro usage.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.67 2012/12/21 17:30:39 gsoares Exp $ */
d189 1
a189 1
int	ipmi_test_threshold(u_int8_t, u_int8_t, u_int8_t, u_int8_t);
d1290 2
a1291 1
ipmi_test_threshold(u_int8_t v, u_int8_t valid, u_int8_t hi, u_int8_t lo)
d1293 5
a1297 1
	dbg_printf(10, "thresh: %.2x %.2x %.2x %d\n", v, lo, hi,valid);
d1309 1
d1348 1
a1348 1
		    data[6], data[3]))
d1352 1
a1352 1
		    data[5], data[2]))
d1356 1
a1356 1
		    data[4], data[1]))
@


1.67
log
@tweak for malloc(9) calls:
- M_CANFAIL is useless here since that M_NOWAIT will return NULL immediately if no resources.

OK mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.66 2012/10/17 22:32:01 deraadt Exp $ */
d142 1
a142 1
    SLIST_HEAD_INITIALIZER(&ipmi_sensor_list);
@


1.66
log
@Swap arguments to wdog_register() since it is nicer, and prepare
wdog_shutdown() for external usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.65 2010/05/24 14:25:20 deraadt Exp $ */
d950 1
a950 1
	buf = malloc(*txlen, M_DEVBUF, M_NOWAIT|M_CANFAIL);
d979 1
a979 1
	buf = malloc(*txlen, M_DEVBUF, M_NOWAIT|M_CANFAIL);
d1046 1
a1046 1
	buf = malloc(maxlen + 3, M_DEVBUF, M_NOWAIT|M_CANFAIL);
d1145 1
a1145 1
	psdr = malloc(sdrlen, M_DEVBUF, M_NOWAIT|M_CANFAIL);
d1489 1
a1489 2
		psensor = malloc(sizeof(*psensor), M_DEVBUF,
		    M_NOWAIT | M_CANFAIL | M_ZERO);
d1721 1
a1721 2
	sc->sc_thread = malloc(sizeof(struct ipmi_thread), M_DEVBUF,
	    M_NOWAIT|M_CANFAIL);
@


1.65
log
@We sometimes compile kernels with -Wvariable-decl because it makes us
happier regarding potential kernel stack overflows, so just use the
(small) maximum buffer size in one case.
ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.64 2008/06/11 23:22:07 cnst Exp $ */
d1747 1
a1747 1
	wdog_register(sc, ipmi_watchdog);
@


1.64
log
@replace the last missing xname header before an error message in get_sdr(); ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.63 2008/02/16 05:20:31 cnst Exp $ */
d1093 1
a1093 1
	u_int8_t	cmd[8 + length];
@


1.63
log
@Call sensordev_install() iff we find and sensor_attach() the individual sensors.
The call got misplaced in ipmi.c#rev1.59 on 2007-08-31.
ok marco; tested todd
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.62 2007/11/25 23:37:01 marco Exp $ */
d1159 2
a1160 1
			printf(": get chunk: %d,%d fails\n", offset, len);
@


1.62
log
@KNF and remove a bad free right before kthread_exit
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.61 2007/11/01 19:24:46 deraadt Exp $ */
d1619 4
a1731 4

	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));
	sensordev_install(&sc->sc_sensordev);
@


1.61
log
@correct ipmi attach time failure messages (why this one machine fails...
still has to be looked at by marco when he has time)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.60 2007/10/08 04:15:15 krw Exp $ */
d1131 1
a1131 1
		return (-1);
d1135 1
a1135 1
		return (-1);
d1140 1
a1140 1
		return (-1);
d1147 1
a1147 1
		return -1;
d1160 2
a1161 1
			return (-1);
d1614 3
a1616 1
	if (!SLIST_EMPTY(&ipmi_sensor_list))
a1624 1
	free(thread, M_DEVBUF);
@


1.60
log
@More simple memset(,0,) -> M_ZERO changes. In this batch move to
size(*p) as the first malloc() parameter where p is declared locally
and thus easy to check. Add M_ZERO to gpe_table allocation in acpi.c
even though there is no obvious bzero or memset nearby.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.59 2007/08/31 18:44:50 marco Exp $ */
d1130 1
a1130 1
		printf(": reserve send fails\n");
d1134 1
a1134 1
		printf(": reserve recv fails\n");
d1139 1
a1139 1
		printf(": get header fails\n");
@


1.59
log
@Defer ipmi sensor creation after kernel goes multi user.  This removes the
annoying waiting period during kernel boots.

pushed for by deraadt and beck
Lots of testing todd, ckuethe and others
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.58 2007/05/29 06:36:56 claudio Exp $ */
d1487 2
a1488 2
		psensor = malloc(sizeof(struct ipmi_sensor), M_DEVBUF,
		    M_NOWAIT|M_CANFAIL);
a1490 2

		memset(psensor, 0, sizeof(struct ipmi_sensor));
@


1.58
log
@Correct fix for the last backout use strlcpy() to fill dv_xname. OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.57 2007/05/29 06:28:23 claudio Exp $ */
d185 1
a185 1
void	ipmi_unmap_regs(struct ipmi_softc *sc, struct ipmi_attach_args *ia);
d1591 1
a1591 1
ipmi_unmap_regs(struct ipmi_softc *sc, struct ipmi_attach_args *ia)
d1600 17
a1616 2
	struct ipmi_thread *thread = arg;
	struct ipmi_softc  *sc = thread->sc;
d1622 2
a1624 1

d1631 1
a1631 1
	struct ipmi_softc *sc = arg;
d1635 1
a1635 1
		printf("%s: unable to create polling thread, ipmi disabled\n",
d1702 1
a1702 1
		ipmi_unmap_regs(&sc, ia);
a1712 1
	u_int16_t		rec;
a1716 9
	/* Scan SDRs, add sensors */
	for (rec = 0; rec != 0xFFFF;) {
		if (get_sdr(sc, rec, &rec)) {
			/* IPMI may have been advertised, but it is stillborn */
			ipmi_unmap_regs(sc, ia);
			return;
		}
	}

a1724 4

	/* initialize sensor list for thread */
	if (!SLIST_EMPTY(&ipmi_sensor_list))
		sc->current_sensor = SLIST_FIRST(&ipmi_sensor_list);
@


1.57
log
@back out last commit. It helps to compile before commiting. OK beck@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.55 2007/04/13 18:57:56 reyk Exp $ */
d1665 2
@


1.56
log
@work around really bad softc abuse by marco; proper fixes for this will
be part of a later rototilling
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.56 2007/05/29 05:52:38 deraadt Exp $ */
a1665 1
	sc->sc_dev.dv_xname = "ipmi0";	/* XXX local softc is wrong wrong wrong */
@


1.55
log
@move the debugging messages into #ifdef IPMI_DEBUG, we do not need to
compile them by default.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.54 2007/04/08 05:48:18 marco Exp $ */
d1666 1
@


1.54
log
@x4100 machines need a hold off in between reads and write to the bmc
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.53 2007/03/22 16:55:31 deraadt Exp $ */
a60 1
int	ipmi_dbg = 0;
d125 2
d133 4
d1059 3
a1061 1
	if ((rc = buf[IPMI_MSG_CCODE]) != 0)
d1064 1
d1476 1
d1478 1
a1541 1

d1552 1
a1552 1
	if (read_sensor(sc, sc->current_sensor))
d1555 2
@


1.53
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.52 2006/12/23 17:46:39 deraadt Exp $ */
d1064 2
@


1.52
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.50 2006/12/23 00:36:24 deraadt Exp $ */
d56 1
a56 1
	struct		sensor i_sensor;
@


1.51
log
@if errors happen while reading the sdr list, give up on handling the
device as cleanly as possible.  ok marco
@
text
@a1487 2
		strlcpy(psensor->i_sensor.device, DEVNAME(sc),
		    sizeof(psensor->i_sensor.device));
d1502 1
a1502 1
			sensor_add(&psensor->i_sensor);
d1711 4
@


1.50
log
@wrong printing; ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.49 2006/09/19 09:30:03 mickey Exp $ */
d1686 12
a1705 8

	/* Map registers */
	ipmi_map_regs(sc, ia);

	/* Scan SDRs, add sensors */
	for (rec = 0; rec != 0xFFFF;)
		if (get_sdr(sc, rec, &rec))
			break;
@


1.49
log
@fix all malloc()s to nowait|canfail and do not ignore errors reading sensor status; marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.48 2006/09/17 19:09:20 marco Exp $ */
d1120 1
a1120 1
		printf("%s: reserve send fails\n", DEVNAME(sc));
d1124 1
a1124 1
		printf("%s: reserve recv fails\n", DEVNAME(sc));
d1129 1
a1129 1
		printf("%s: get header fails\n", DEVNAME(sc));
d1149 1
a1149 2
			printf("%s: get chunk : %d,%d fails\n", DEVNAME(sc),
			    offset, len);
@


1.48
log
@Move get ipmi id into the match function.  This prevents attach from being
called whenever there is no BMC and hence suppresses a ugly message when a
bios lied that it had ipmi.

tested beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.47 2006/08/01 22:49:37 marco Exp $ */
d362 1
a362 1
	return bmc_read(sc, reg);		
d399 1
a399 1
		return (-1);	
d409 1
a409 1
	}	
d945 1
a945 1
	buf = malloc(*txlen, M_DEVBUF, M_WAITOK);
d974 1
a974 1
	buf = malloc(*txlen, M_DEVBUF, M_WAITOK);
d1041 1
a1041 1
	buf = malloc(maxlen + 3, M_DEVBUF, M_WAITOK);
d1135 1
a1135 1
	psdr = malloc(sdrlen, M_DEVBUF, M_WAITOK);
a1293 2
	psensor->i_sensor.status = SENSOR_S_OK;

d1321 4
a1324 3
		ipmi_sendcmd(sc, s1->owner_id, s1->owner_lun,
		    SE_NETFN, SE_GET_SENSOR_THRESHOLD, 1, data);
		ipmi_recvcmd(sc, sizeof(data), &rxlen, data);
d1477 1
a1477 3
		    M_WAITOK);

		/* XXX get rid of this */
a1487 1
		psensor->i_sensor.status = SENSOR_S_OK;
d1545 1
a1545 1
		dbg_printf(1, "%s: error reading: %s\n", DEVNAME(sc), 
d1595 1
a1595 1
		tsleep(thread, PWAIT, "timeout", SENSOR_REFRESH_RATE);
d1687 2
a1688 1
	sc->sc_thread = malloc(sizeof(struct ipmi_thread), M_DEVBUF, M_NOWAIT);
d1759 1
@


1.47
log
@Add a wait between send and receive command.  Talked through with jordan.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.46 2006/08/01 20:02:04 marco Exp $ */
d325 1
a325 1
	printf("%s: bmc_io_wait_cold fails : *v=%.2x m=%.2x b=%.2x %s\n",
a1640 2

		return (1);
d1652 3
d1662 16
a1678 2

		return (1);
d1681 1
a1681 1
	return (0);
a1688 2
	u_int8_t		cmd[32];
	int			len;
a1700 16


	/* Identify BMC device */
	if (ipmi_sendcmd(sc, BMC_SA, 0, APP_NETFN, APP_GET_DEVICE_ID,
	    0, NULL)) {
		printf(": unable to send get device id " "command\n");
		ipmi_unmap_regs(sc, ia);
		return;
	}
	if (ipmi_recvcmd(sc, sizeof(cmd), &len, cmd)) {
		printf(": unable to retrieve device id\n");
		ipmi_unmap_regs(sc, ia);
		return;
	}

	dbg_dump(1, "bmc data", len, cmd);
@


1.46
log
@Silence intermittent read errors.
Fix a bug in bt where the "get id" command fails by giving the bmc some
extra time to gather the data.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.45 2006/07/28 20:50:43 marco Exp $ */
d151 1
d992 1
a992 1
	int		rc;
d1016 1
a1016 1
		return (-1);
d1023 1
a1023 1
		return (-1);
d1028 3
d1068 10
a1696 3

	delay(250000);

@


1.45
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.44 2006/07/28 20:46:12 marco Exp $ */
d301 2
a302 2
		printf("%s: bmc_io_wait fails : v=%.2x m=%.2x b=%.2x %s\n",
		    DEVNAME(sc), v, mask, value, lbl);
d720 1
a720 1
		dumpb("kcs_sendmsg", len, data);
d1535 1
a1535 1
		printf("%s: error reading: %s\n", DEVNAME(sc), 
d1675 1
d1677 3
a1679 2
	if (ipmi_sendcmd(sc, BMC_SA, 0, APP_NETFN, APP_GET_DEVICE_ID, 0, NULL)){
		printf(": unable to send get device id command\n");
d1683 3
d1691 1
d1727 1
a1727 1
	sc->sc_max_retries = 100; /* XXX 1 second the right value? */
@


1.44
log
@Only read 1 sensor at a time instead of all of them.  This should help
systems that have a burst of activity every 10 seconds.

Also lower the polling frequency from 10 to 5 seconds.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.43 2006/07/28 20:41:02 jordan Exp $ */
d385 1
a385 1
		"bt_sendwait") < 0)
d1755 2
a1756 1
	wdog.wdog_action |= (period == 0) ? IPMI_WDOG_DISABLED : IPMI_WDOG_REBOOT;
@


1.43
log
@Fix BT interface by waiting for BMC_BUSY on writes.

Found and ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.42 2006/05/21 20:55:26 alek Exp $ */
d65 1
a65 1
#define SENSOR_REFRESH_RATE (10 * hz)
d314 1
a314 1
	int			count = 100000; /* == 5s XXX can be shorter */
d320 2
a321 1
		delay(50);
d874 2
a875 1
	dbg_printf(1, "%02x %02x %02x %02x %08llx %02x %02x\n",
d1053 1
a1522 1
	struct	ipmi_sensor *psensor = NULL;
d1527 10
a1536 4
	SLIST_FOREACH(psensor, &ipmi_sensor_list, list)
		if (read_sensor(sc, psensor))
			printf("%s: error reading: %s\n", DEVNAME(sc), 
			    psensor->i_sensor.desc);
d1692 4
@


1.42
log
@Replace lockmgr with rwlock; help and ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.41 2006/05/15 01:10:07 marco Exp $ */
d354 19
d378 1
a378 4
	if (bmc_io_wait(sc, _BT_CTRL_REG, BT_READY, 0, "btsend") < 0)
		return -1;

	bmc_write(sc, _BT_CTRL_REG, BT_CLR_WR_PTR);
d380 1
a380 3
		bmc_write(sc, _BT_DATAOUT_REG, data[i]);

	bmc_write(sc, _BT_CTRL_REG, BT_HOST2BMC_ATN);
d382 3
a384 2
	if (bmc_io_wait(sc, _BT_CTRL_REG, BT_BMC2HOST_ATN, BT_BMC2HOST_ATN,
		"btswait") < 0)
d395 8
a402 4
	/* BT Result data: 0: len   1:nfln   2:seq   3:cmd   4:ccode
	 * 5:data... */
	bmc_write(sc, _BT_CTRL_REG, BT_HOST_BUSY|BT_CLR_RD_PTR);
	len = bmc_read(sc, _BT_DATAIN_REG);
d404 1
a404 2
		/* Ignore sequence number */
		v = bmc_read(sc, _BT_DATAIN_REG);
d407 2
a408 2
	}
	bmc_write(sc, _BT_CTRL_REG, BT_BMC2HOST_ATN | BT_HOST_BUSY);
d1095 1
a1095 1
	u_int16_t	resid;
@


1.41
log
@Add device name when printing out errors.  Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.40 2006/05/15 00:46:55 marco Exp $ */
d1345 1
a1345 1
		lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d1367 1
a1367 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d1686 1
a1686 1
	lockinit(&sc->sc_lock, PZERO, DEVNAME(sc), 0, 0);
@


1.40
log
@Make _bmc_io_wait 1 second instead of 500ms.
Prevent multiple reads and writes to the bmc at the same time which could
interrupt a complete bmc transaction.

tested by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.39 2006/05/12 02:11:53 deraadt Exp $ */
d301 2
a302 2
		printf("bmc_io_wait fails : v=%.2x m=%.2x b=%.2x %s\n",
		    v, mask, value, lbl);
d323 2
a324 2
	printf("bmc_io_wait_cold fails : *v=%.2x m=%.2x b=%.2x %s\n",
	    v, mask, value, lbl);
d636 2
a637 1
		printf(" error code: %x\n", bmc_read(sc, _KCS_DATAIN_REGISTER));
d1001 1
a1001 1
		printf("sendcmd malloc fails\n");
d1019 2
a1020 2
		printf("ipmi_recvcmd: malloc fails\n");
		return -1;
d1057 1
a1057 1
		printf("sendcmd fails\n");
d1061 1
a1061 1
		printf("getSdrPartial: recvcmd fails\n");
d1085 1
a1085 1
		printf("reserve send fails\n");
d1089 1
a1089 1
		printf("reserve recv fails\n");
d1094 1
a1094 1
		printf("get header fails\n");
d1114 2
a1115 1
			printf("get chunk : %d,%d fails\n", offset, len);
d1509 2
a1510 1
			printf("error reading: %s\n", psensor->i_sensor.desc);
d1530 2
a1531 1
		printf("ipmi: bus_space_map(%x %x %x 0 %p) failed\n",
@


1.39
log
@code we can read
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.38 2006/05/08 22:51:18 gwk Exp $ */
d1340 4
a1343 1
	int		rxlen;
d1349 1
a1349 1
		return (-1);
d1352 1
a1352 1
		return (-1);
d1362 5
a1366 2

	return (0);
d1681 3
d1687 1
a1687 1
	sc->sc_max_retries = 50; /* XXX 50ms the right value? */
@


1.38
log
@Add smbios support for i386 and amd64, fix ipmi to use this new functionallity,
hook up some sysctls to add system vendor/product/version and UUID reporting.

"get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.37 2006/05/06 15:04:38 wilfried Exp $ */
d634 2
a635 1
		while (bmc_read(sc, _KCS_STATUS_REGISTER) & KCS_IBF);
@


1.37
log
@if the fan data rate is per second convert it to per minute, ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.36 2006/04/27 15:28:21 mickey Exp $ */
d42 1
a140 1
void	smbios_ipmi_probe(void *, void *);
d176 1
a180 9
struct smbios_mem_map {
	vaddr_t		baseva;
	u_int8_t	*va;
	size_t		vsize;
	paddr_t		pa;
};

void	*smbios_map(paddr_t, size_t, struct smbios_mem_map *);
void	smbios_unmap(struct smbios_mem_map *);
a181 1
int	scan_smbios(u_int8_t, void (*)(void *, void *), void *);
a836 81
void *
smbios_map(paddr_t pa, size_t len, struct smbios_mem_map *handle)
{
	paddr_t pgstart = trunc_page(pa);
	paddr_t pgend	= round_page(pa + len);
	vaddr_t va = uvm_km_valloc(kernel_map, pgend-pgstart);

	if (va == 0)
		return NULL;

	handle->pa = pa;
	handle->baseva = va;
	handle->va = (u_int8_t *)(va + ((u_long)pa & PGOFSET));
	handle->vsize = pgend - pgstart;

	do {
		pmap_kenter_pa(va, pgstart, VM_PROT_READ);
		va += NBPG;
		pgstart += NBPG;
	} while (pgstart < pgend);

	return handle->va;
}

void
smbios_unmap(struct smbios_mem_map *handle)
{
	pmap_kremove(handle->baseva, handle->vsize);
	uvm_km_free(kernel_map, handle->baseva, handle->vsize);
}

/* Scan SMBIOS for table type */
int
scan_smbios(u_int8_t mtype, void (*smcb) (void *base, void *arg), void *arg)
{
	struct smbiosanchor	*romhdr;
	struct smhdr		*smhdr;
	u_int8_t		*offset;
	int			nmatch, num;
	struct smbios_mem_map	smm;

	/* Scan for SMBIOS Table Signature */
	romhdr = (struct smbiosanchor *)scan_sig(0xF0000, 0xFFFFF, 16, 4,
	    "_SM_");
	if (romhdr == NULL)
		return (0);

	dbg_printf(1, "SMBIOS Version %d.%d at 0x%lx, %d entries\n",
	    romhdr->smr_smbios_majver, romhdr->smr_smbios_minver,
	    romhdr->smr_table_address, romhdr->smr_count);

	/* Map SMBIOS Table start address */
	nmatch = 0;
	offset = smbios_map(romhdr->smr_table_address,
	    romhdr->smr_count * romhdr->smr_maxsize, &smm);
	if (offset == NULL)
		return (0);

	for (num = 0; num < romhdr->smr_count; num++) {
		smhdr = (struct smhdr *)offset;
		if (smhdr->smh_type == SMBIOS_TYPE_END ||
		    smhdr->smh_length == 0)
			break;

		/* found a match here */
		if (smhdr->smh_type == mtype) {
			smcb(&smhdr[1], arg);
			nmatch++;
		}
		/* Search for end of string table, marked by '\0\0' */
		offset += smhdr->smh_length;
		while (offset[0] || offset[1])
			offset++;

		offset += 2;
	}
	smbios_unmap(&smm);

	return (nmatch);
}

d850 1
a850 1
smbios_ipmi_probe(void *ptr, void *arg)
a851 2
	struct ipmi_attach_args *ia = arg;
	struct smbios_ipmi	*pipmi = (struct smbios_ipmi *)ptr;
d1572 2
d1575 4
a1578 4
	if (scan_smbios(SMBIOS_TYPE_IPMI, smbios_ipmi_probe, ia) == 0) {
		struct dmd_ipmi *pipmi;

		/* XXX hack to find Dell PowerEdge 8450 */
d1581 1
@


1.36
log
@from PAE work:
since we are only interested in the page offset bits
cast paddr_t to (smaller) u_long to shuddup gcc (;
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.35 2006/04/20 20:31:10 miod Exp $ */
d1363 2
@


1.35
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.34 2006/01/29 17:29:29 marco Exp $ */
d858 1
a858 1
	handle->va = (u_int8_t *)(va + (pa & PGOFSET));
@


1.34
log
@Disable iic whenever ipmi is enabled.  This fixes boxes like Sun x4200 that
freak out when more than one device driver touch the i2c devices.
Reported by: Srebrenko Sehic <ssehic at gmail dot com>

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.33 2006/01/19 17:08:39 grange Exp $ */
d1610 1
a1610 1
		printf("ipmi: bus_space_map(%x %x %x 0 %x) failed\n",
@


1.33
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.32 2006/01/18 04:46:04 marco Exp $ */
d62 1
d1753 3
@


1.32
log
@Fix false positives of ipmi on older machines.

ok jordan@@
tested by others
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.31 2006/01/05 21:28:29 marco Exp $ */
d1554 1
a1554 1
			SENSOR_ADD(&psensor->i_sensor);
@


1.31
log
@Kill all typedef struct goo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.30 2006/01/05 19:04:39 marco Exp $ */
d890 1
a890 1
		return (-1);
d901 1
a901 1
		return (-1);
@


1.30
log
@Work around flawed IBM 325 eServer IPMI implementation.

Help and ok deraadt@@ jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.29 2006/01/05 17:38:00 marco Exp $ */
d158 1
a158 1
long	ipmi_convert(u_int8_t, sdrtype1 *, long);
d790 1
a790 1
typedef struct {
d797 1
a797 1
} ipmi_request_;
d799 1
a799 1
typedef struct {
d803 1
a803 1
} ipmi_response_t;
d805 1
a805 1
typedef struct {
d810 1
a810 1
} ipmi_bmc_request_t;
d812 1
a812 1
typedef struct {
d818 1
a818 1
} ipmi_bmc_response_t;
d880 2
a881 2
	smbiosanchor_t		*romhdr;
	smhdr_t			*smhdr;
d887 2
a888 1
	romhdr = (smbiosanchor_t *) scan_sig(0xF0000, 0xFFFFF, 16, 4, "_SM_");
d904 1
a904 1
		smhdr = (smhdr_t *) offset;
d942 1
a942 1
	smbios_ipmi_t		*pipmi = (smbios_ipmi_t *)ptr;
d1169 1
a1169 1
	sdrhdr_t	shdr;
d1182 1
a1182 2
	if (get_sdr_partial(sc, recid, resid, 0, sizeof(sdrhdr_t), &shdr,
	    nxtrec)) {
d1305 1
a1305 1
ipmi_convert(u_int8_t v, sdrtype1 *s1, long adj)
d1343 2
a1344 2
	u_int8_t		data[32];
	sdrtype1	*s1 = (sdrtype1 *)psensor->i_sdr;
d1426 1
a1426 1
	sdrtype1	*s1 = (sdrtype1 *) psensor->i_sdr;
d1481 2
a1482 2
	sdrtype1		*s1 = (sdrtype1 *) psdr;
	sdrtype2		*s2 = (sdrtype2 *) psdr;
d1511 3
a1513 3
	int typ, idx;
	struct ipmi_sensor *psensor;
	sdrtype1 *s1 = (sdrtype1 *) psdr;
d1663 1
a1663 1
		dmd_ipmi_t *pipmi;
d1666 1
a1666 1
		pipmi = (dmd_ipmi_t *)scan_sig(0xC0000L, 0xFFFFFL, 16, 4,
@


1.29
log
@Better debug verbosity values.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.28 2006/01/05 17:09:15 marco Exp $ */
d943 9
d987 8
@


1.28
log
@Adjust debug levels.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.27 2006/01/05 15:16:26 marco Exp $ */
d1422 1
a1422 1
	dbg_printf(1, "values=%.2x %.2x %.2x %.2x %s\n",
d1500 1
a1500 1
		dbg_printf(1, "Unknown sensor type:%.2x et:%.2x sn:%.2x "
d1531 1
a1531 1
		dbg_printf(1, "add sensor:%.4x %.2x:%d ent:%.2x:%.2x %s\n",
d1538 1
a1538 1
			dbg_printf(1, "	 reading: %lld [%s]\n",
@


1.27
log
@I got the time scale wrong with the previous commit.  Now the advertised
50ms timeout is actually 50ms during runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.26 2006/01/04 23:51:16 marco Exp $ */
d653 1
a653 1
	dbg_printf(99, "kcswritecmd: %.2x\n", cmd);
d663 1
a663 1
	dbg_printf(99, "kcswritedata: %.2x\n", data);
d682 1
a682 1
	dbg_printf(99, "kcsreaddata: %.2x\n", *data);
d891 1
a891 1
	dbg_printf(99, "SMBIOS Version %d.%d at 0x%lx, %d entries\n",
d1044 1
a1044 1
	dbg_printf(10, "ipmi_sendcmd: rssa=%.2x nfln=%.2x cmd=%.2x len=%.2x\n",
d1104 1
a1104 1
	dbg_printf(10, "ipmi_recvcmd: nfln=%.2x cmd=%.2x err=%.2x len=%.2x\n",
d1361 1
a1361 1
		dbg_printf(10, "recvdata: %.2x %.2x %.2x %.2x %.2x %.2x %.2x\n",
@


1.26
log
@Adjust timeout values.  This was determined by using beck's ibm e325.

ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.25 2005/12/16 03:16:47 marco Exp $ */
d281 1
a281 1
	timeout_add(&sc->sc_timeout, 50);
d322 1
a322 1
	int			count = 100000;
d1743 1
a1743 1
	sc->sc_max_retries = 100000; /* XXX 5s the right value? */
@


1.25
log
@Fix 2 issues reported by beck.

1. Sun v20z rebooted dunring autoconf.  This was due to reading a byte and
   discarding it at an inapropriate time.
2. The Sun is so fast that it could exhaust the busy counter.  This has been
   replaced with a timeout/tsleep mechanism that is more predictable.  As
   a bonus we no longer busy wait in ipmi which should improve overall
   throughput.

ok beck@@ jordan@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.24 2005/12/13 04:00:18 marco Exp $ */
d322 1
a322 1
	int			count = 1000;
d1743 1
a1743 1
	sc->sc_max_retries = 1000; /* XXX 50ms the right value? */
@


1.24
log
@Add check for return value in recvcmd.
Unmap ipmi registers if attach fails.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.23 2005/12/13 03:49:32 deraadt Exp $	*/
d164 4
a167 2
int	bmc_io_wait(struct ipmi_softc *, int, u_int8_t, u_int8_t, long,
	    const char *);
d262 22
d285 2
a286 2
bmc_io_wait(struct ipmi_softc *sc, int offset, u_int8_t mask,
    u_int8_t value, long count, const char *lbl)
d288 35
a322 1
	volatile u_int8_t v;
a323 1
	/* Spin loop (ugly) */
d328 1
d330 2
a331 1
	printf("bmc_io_wait fails : v=%.2x m=%.2x b=%.2x %s\n",
d334 1
d367 1
a367 1
	if (bmc_io_wait(sc, _BT_CTRL_REG, BT_READY, 0, 0xFFFFF, "btsend") < 0)
d377 2
a378 2
		0xFFFFF, "btswait") < 0)
		return -1;
d480 1
a480 1
	v = bmc_io_wait(sc, _SMIC_FLAG_REG, mask, val, 0xFFFFF, "smicwait");
d631 1
a631 1
	v = bmc_io_wait(sc, _KCS_STATUS_REGISTER, mask, value, 0xFFFFF, lbl);
d636 1
a636 1
	if (value == 0 && (v & KCS_OBF))
d708 1
d711 1
a711 1
	return (sts != KCS_READ_STATE);
d726 1
a726 1
	if (sts != KCS_IDLE_STATE)
d728 2
d733 1
a733 1
	return (sts != KCS_IDLE_STATE);
d940 1
a940 1
	struct ipmi_attach_args	*ia = arg;
d1643 1
a1643 1
	struct ipmi_attach_args	*ia = aux;
d1670 1
a1670 1
	struct ipmi_attach_args	*ia = aux;
d1691 1
a1691 1
	struct ipmi_attach_args	*ia = aux;
d1739 6
@


1.23
log
@no need for device name before fail
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.22 2005/12/13 03:36:12 marco Exp $	*/
d1031 2
a1032 1
	sc->sc_if->recvmsg(sc, maxlen + 3, &rawlen, buf);
d1647 1
d1652 1
@


1.22
log
@Don't continue to poke ipmi registers if the ID command fails.
ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.21 2005/11/30 18:02:53 deraadt Exp $	*/
d1634 1
a1634 2
		printf("%s: unable to allocate thread\n",
		    DEVNAME(sc));
d1645 1
a1645 2
		printf("%s: unable to send get device id command\n",
		    DEVNAME(sc));
d1649 1
a1649 2
		printf("%s: unable to retrieve device id\n",
		    DEVNAME(sc));
@


1.21
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.20 2005/11/28 23:47:42 jordan Exp $	*/
d1645 10
a1654 2
	ipmi_sendcmd(sc, BMC_SA, 0, APP_NETFN, APP_GET_DEVICE_ID, 0, NULL);
	ipmi_recvcmd(sc, sizeof(cmd), &len, cmd);
@


1.20
log
@Added ipmi watchdog code, based on esm watchdog code by dlg@@
Added signextend function to cleanup conversion routine
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.19 2005/11/22 04:28:14 marco Exp $	*/
d1219 1
a1219 1
  	return (-(val & ~msk) | val);
a1669 1

d1674 1
a1674 1
	struct ipmi_watchdog     wdog;
d1682 1
a1682 1
					  APP_RESET_WATCHDOG, 0, NULL);
d1693 2
a1694 2
	rc = ipmi_sendcmd(sc, BMC_SA, BMC_LUN, APP_NETFN, 
			  APP_GET_WATCHDOG_TIMER, 0, NULL);
d1703 1
a1703 1
			  APP_SET_WATCHDOG_TIMER, sizeof(wdog), &wdog);
@


1.19
log
@Some BIOS' lie about location of ports.  Prevent panic by checking bus_space_map.

This works around bob's ipmi panic issue on the amd64 e325 IBM box.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.18 2005/10/24 18:36:21 marco Exp $	*/
d131 2
d151 2
d1213 9
d1230 5
a1234 18
	/* M is 10-bit value: check if negative */
	M = (((short)(s1->m_tolerance & 0xC0)) << 2) + s1->m;
	if (M & 0x200)
		M |= 0xFC00;

	/* B is 10-bit value; check if negative */
	B = (((short)(s1->b_accuracy & 0xC0)) << 2) + s1->b;
	if (B & 0x200)
		B |= 0xFC00;

	/* K1/K2 are 4-bit values; check if negative */
	K1 = s1->rbexp & 0xF;
	if (K1 & 0x8)
		K1 |= 0xF0;

	K2 = s1->rbexp >> 4;
	if (K2 & 0x8)
		K2 |= 0xF0;
d1664 47
@


1.18
log
@Remove panic if polling thread can not be created.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.17 2005/10/21 16:44:24 deraadt Exp $	*/
d1525 1
a1525 1
	bus_space_map(sc->sc_iot, ia->iaa_if_iobase,
d1527 6
a1532 1
	    0, &sc->sc_ioh);
@


1.17
log
@pretty up dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.16 2005/10/20 02:02:20 deraadt Exp $	*/
d1564 5
a1568 2
	    DEVNAME(sc)) != 0)
		panic("ipmi thread");
@


1.16
log
@KNF; marco ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmi.c,v 1.11 2005/10/19 22:06:59 jordan Exp $	*/
d193 1
a193 1
	"kcs",
d203 1
a203 1
	"smic",
d213 1
a213 1
	"bt",
d1163 1
a1163 1
		if (len < slen * 2 + 1) 
d1529 1
a1529 1
	if (iaa->if_if_irq != -1) {
d1531 1
a1531 4
		    iaa->if_irqlvl, IPL_BIO,
		    ipmi_intr, sc,
		    DEVNAME(sc));
	}
d1649 7
a1655 5
	printf(": version %d.%d interface %s %cbase 0x%x/%x spacing %d irq %d\n",
	    ia->iaa_if_rev >> 4, ia->iaa_if_rev & 0xF,
	    sc->sc_if->name, ia->iaa_if_iotype, ia->iaa_if_iobase,
	    ia->iaa_if_iospacing * sc->sc_if->nregs, ia->iaa_if_iospacing,
	    ia->iaa_if_irq);
@


1.15
log
@Fixup case statements to use #define's
suggested by deraadt
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.14 2005/10/19 23:28:28 jordan Exp $ */
a26 1
 *
d124 6
a129 2
#define dbg_printf(lvl,fmt...)	  if (ipmi_dbg >= lvl) { printf(fmt); }
#define dbg_dump(lvl,msg,len,buf) if (len && ipmi_dbg >= lvl) { dumpb(msg,len,(const u_int8_t *)(buf)); }
d158 1
a158 1
u_int8_t	bmc_read(struct ipmi_softc *, int);
d173 1
a173 2
struct smbios_mem_map
{
a229 1

a231 1

d265 1
a265 1
		if ((v & mask) == value) {
a266 1
		}
d307 1
a307 1
	for (i = 0; i < len; i++) {
a308 1
	}
d417 1
a417 1
	if (v < 0) 
d462 1
a462 1
#define ErrStat(a,b) if (a) { printf(b); }
d472 1
a472 1
		sts = smic_write_cmd_data(sc, SMS_CC_NEXT_TRANSFER, 
d474 1
a474 1
		ErrStat(sts != SMS_SC_WRITE_NEXT,"write");
d478 1
a478 1
		dbg_printf(50,"smic_sendmsg %d/%d = %.2x\n", idx, len, sts);
d481 1
a481 1
	
d492 1
a492 1
	if (sts < 0) {
a493 1
	}
d498 2
a499 2
		sts=smic_read_data(sc, &data[idx++]);
		if (sts != SMS_SC_READ_START && sts != SMS_SC_READ_NEXT) {
a500 1
		}
d506 2
a507 2
	
	sts=smic_write_cmd_data(sc, SMS_CC_END_RECEIVE, NULL);
d509 1
a509 1
		dbg_printf(50,"smic_recvmsg %d/%d = %.2x\n", idx, maxlen, sts);
d526 1
a526 1
	if (bmc_read(sc, _SMIC_FLAG_REG) == 0xFF) 
d642 1
a642 1
		dbg_printf(1,"kcs sendmsg = %d/%d <%.2x>\n", idx, len, sts);
d662 1
a662 1
		dbg_printf(1,"kcs read = %d/%d <%.2x>\n", idx, maxlen, sts);
d797 1
a797 1
	} while(pgstart < pgend);
d811 2
a812 1
scan_smbios(u_int8_t mtype, void (*smcb) (void *base, void *arg), void *arg) {
d824 3
a826 5
	dbg_printf(99,"SMBIOS Version %d.%d at 0x%lx, %d entries\n",
	    romhdr->smr_smbios_majver,
	    romhdr->smr_smbios_minver,
	    romhdr->smr_table_address,
	    romhdr->smr_count);
d909 1
a909 1
	if (pipmi->smipmi_base_flags & SMIPMI_FLAG_ODDOFFSET) {
a910 1
	}
d994 1
a994 1
		if (txlen) {
a995 1
		}
d1033 1
a1033 1
	if ((rc = buf[IPMI_MSG_CCODE]) != 0) {
a1035 1
	}
d1067 1
a1067 1
	if (nxtRecordId) {
a1068 1
	}
d1140 1
a1140 1
		if (bytes[bitpos >> 3] & mask) {
a1141 1
		}
d1177 1
a1177 1
		for (i = 0; i < slen * 8; i += 6) {
a1178 1
		}
d1253 1
a1253 1
	dbg_printf(10,"thresh: %.2x %.2x %.2x %d\n", v, lo, hi,valid);
d1288 1
a1288 1
	switch(etype) {
d1297 1
a1297 1
		dbg_printf(10,"recvdata: %.2x %.2x %.2x %.2x %.2x %.2x %.2x\n",
d1359 1
a1359 1
		data[0],data[1],data[2],data[3], psensor->i_sensor.desc);
d1407 1
a1407 1
		rc=add_child_sensors(sc, psdr, 1, s1->sensor_num,
d1413 3
a1415 7
		rc=add_child_sensors(sc, psdr,
		    s2->share1 & 0xF,
		    s2->sensor_num,
		    s2->sensor_type,
		    s2->event_code,
		    s2->share2 & 0x7F,
		    s2->entity_id, name);
d1437 1
a1437 2
			   "name:%s\n",
			   sensor_type, ext_type, sensor_num, name);
a1440 1

d1503 1
a1503 1
	if (!ipmi_poll) {
d1505 2
a1506 2
	}
	SLIST_FOREACH(psensor, &ipmi_sensor_list, list) {
a1508 2

	}
@


1.14
log
@Added readable case names for ipmi device types
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.13 2005/10/19 23:00:22 jordan Exp $ */
d85 3
d103 10
a112 5
#define IPMI_SENSOR_TYPE_TEMP           0x0101
#define IPMI_SENSOR_TYPE_VOLT           0x0102
#define IPMI_SENSOR_TYPE_FAN            0x0104
#define IPMI_SENSOR_TYPE_INTRUSION      0x6F05
#define IPMI_SENSOR_TYPE_PWRSUPPLY      0x6F08
d118 3
d889 1
a889 1
	case 0:
d893 1
a893 1
	case 1:
d897 1
a897 1
	case 2:
d1166 2
a1167 2
	switch (typelen & 0xC0) {
	case 0x00:
d1171 1
a1171 1
	case 0x40:
d1181 1
a1181 1
	case 0x80:
d1192 1
a1192 1
	case 0xC0:
d1416 1
a1416 1
	case 1:
d1422 1
a1422 1
	case 2:
@


1.13
log
@Added length test for ipmi_sensor_name string
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.12 2005/10/19 22:35:39 jordan Exp $ */
d100 5
a104 1
#define IPMI_INVALID_SENSOR		(1L << 5)
d108 2
a1267 4
	etype = psensor->etype;
	if (etype == 0x6F)
		etype = (etype << 8) + psensor->stype;

d1287 1
d1289 3
a1291 1
	case 0x01:  /* threshold */
d1315 1
a1315 1
	case 0x6F05: /* chassis intrusion */
d1321 1
a1321 1
	case 0x6F08: /* power supply */
d1374 1
a1374 1
	case 0x0101: /* temperature probes */
d1377 1
a1377 1
	case 0x0102: /* voltage probes	*/
d1380 1
a1380 1
	case 0x0104: /* fans */
d1383 1
a1383 1
	case 0x6F08: /* power supply */
d1388 1
a1388 1
	case 0x6F05: /* chassis intrusion */
@


1.12
log
@Changed poll to use kernel threads instead of in timer context
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.11 2005/10/19 22:06:59 jordan Exp $ */
d1156 2
d1167 3
d1177 2
@


1.11
log
@Added status for chassis intrusion (critical if open)
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.10 2005/10/19 22:01:08 jordan Exp $ */
d39 1
d68 2
a148 1
void	ipmi_refresh(void *arg);
d1451 1
a1451 1
		strlcpy(psensor->i_sensor.device, sc->sc_dev.dv_xname,
a1506 9
void
ipmi_refresh(void *arg)
{
	struct	ipmi_softc *sc = (struct ipmi_softc *)arg;

	ipmi_refresh_sensors(sc);
	timeout_add(&ipmi_timeout, SENSOR_REFRESH_RATE);
}

d1528 2
a1529 2
		    ipmi_intr, sc
		    sc->sc_dev.dv_xname);
d1542 25
d1623 9
d1645 2
a1646 3
	/* Setup timeout */
	timeout_set(&ipmi_timeout, ipmi_refresh, sc);
	timeout_add(&ipmi_timeout, SENSOR_REFRESH_RATE);
@


1.10
log
@Changed order of reading sensor vs sensor status, failed sensors had invalid
reading
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.9 2005/10/19 21:52:30 jordan Exp $ */
d1303 2
@


1.9
log
@Added code to properly read power supply installed/power state
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.8 2005/10/19 21:43:09 jordan Exp $ */
d1257 19
a1319 18
		break;
	}

	/* Get reading of sensor */
	switch (psensor->i_sensor.type) {
	case SENSOR_TEMP:
		psensor->i_sensor.value = ipmi_convert(reading[0], s1, 6);
		psensor->i_sensor.value += 273150000;
		break;

	case SENSOR_VOLTS_DC:
		psensor->i_sensor.value = ipmi_convert(reading[0], s1, 6);
		break;

	case SENSOR_FANRPM:
		psensor->i_sensor.value = ipmi_convert(reading[0], s1, 0);
		break;
	default:
@


1.8
log
@Added SMIC interface code
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.7 2005/10/18 23:26:33 marco Exp $ */
d1287 14
a1300 1
		psensor->i_sensor.value = (reading[2] & 0xE) ? 0 : 1;
@


1.7
log
@Use MI trunc_page() & round_page().  Suggested by miod@@ and grange@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.6 2005/10/18 23:11:00 marco Exp $ */
d364 16
d389 4
a392 1
#if 0
d396 11
a406 1
	return (inb(SMIC_CNTL_REGISTER(sc)));
d412 1
a412 1
	int	sts;
d414 1
d417 1
a417 1
	if (sts != 0)
d424 1
d434 2
d438 4
a441 6
	if (sts != SMIC_STATE_READ)
		return (sts);

	sts = bmc_read(sc, _SMIC_CNTL_REG);
	*data = bmc_read(sc, _SMIC_DATAIN_REG);

d444 2
a445 1
#endif
a449 1
#if 0
d453 5
a457 3
	for (idx = 0; idx < len - 1; idx++) {
		if (sts != SMIC_STATE_READ) break;
		sts = smic_write_cmd_data(sc, SMS_CC_NEXT_TRANSFER, &data[idx]);
d460 6
a465 2
#endif
	return (-1);
a470 1
#if 0
d473 6
d480 6
a485 2
	for (idx = 0;; idx++) {
		sts=smic_read_data(sc, &data[idx]);
d488 11
a498 3
	smic_write_cmd_data(sc, SMS_CC_END_RECEIVE, NULL);
#endif
	return (-1);
d510 5
a514 1
	return (-1);
@


1.6
log
@Document Dell PowerEdge 8450 hack
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.5 2005/10/18 23:08:23 marco Exp $ */
d708 2
a709 2
	paddr_t pgstart = i386_trunc_page(pa);
	paddr_t pgend	= i386_trunc_page(pa + len);
@


1.5
log
@Scan SMBIOS before calling config_attach() to prevent unnecessary kernel print.

Written with jordan@@ help.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.4 2005/10/17 23:54:21 deraadt Exp $ */
d1483 1
@


1.4
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.3 2005/10/17 22:56:53 jordan Exp $ */
d127 1
a127 1
int	ipmi_probe(struct device *, void *, void *);
d681 1
a681 1
	sizeof(struct ipmi_softc), ipmi_probe, ipmi_attach
d1476 1
a1476 1
ipmi_probe(struct device *parent, void *match, void *aux)
a1477 1
	struct ipmi_softc	sc;
a1478 4
	struct cfdata		*cf = match;

	if (strcmp(ia->iaa_name, cf->cf_driver->cd_name))
		return (0);
d1485 2
a1486 1
		if (pipmi == NULL)
d1488 1
d1490 1
d1493 2
d1496 14
@


1.3
log
@* Fix SMBIOS Table address
	mapped memory instead of ISA_HOLE_VADDR for SMBIOS tables in high memory
* Added ipmi_poll variable to control sensor polling
* Add Power Supply sensor type
* Fixed chassis intrusion reading
* Added Block-Transfer interface
	BT is transport protocol to BMC
* Fixed threshold values
	Bits in Sensor reading did not contain correct values for threshold
	vioation; must compare reading against actual threshold.
* KNF

ok: marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipmi.c,v 1.2 2005/10/05 02:02:11 deraadt Exp $ */
d165 1
a165 1
int	ipmi_sensor_status(struct ipmi_softc *, struct ipmi_sensor *,  
d168 1
a168 1
int	 add_child_sensors(struct ipmi_softc *, u_int8_t *, int, int, int, 
d202 1
d263 1
a263 1
#define	  BT_HOST2BMC_ATN		(1L << 2)	
d758 1
a758 1
	offset = smbios_map(romhdr->smr_table_address, 
d1123 1
a1123 1
	while (exp > 0) { 
d1128 1
a1128 1
	while (exp < 0) { 
d1163 1
a1163 1
	/* Calculate sensor reading: 
d1166 1
a1166 1
	 * This commutes out to: 
d1181 1
a1181 1
	return ((valid & 1 && lo != 0x00 && v <= lo) || 
a1184 1

d1202 1
a1202 1
		ipmi_sendcmd(sc, s1->owner_id, s1->owner_lun,  
d1208 1
a1208 1
		    data[6]); 
d1211 1
a1211 1
		    data[6], data[3])) 
a1306 1

d1325 2
a1326 2
		rc=add_child_sensors(sc, psdr, 
		    s2->share1 & 0xF, 
d1328 1
a1328 1
		    s2->sensor_type, 
d1353 1
a1353 1
			   "name:%s\n", 
@


1.2
log
@pretty print & minor knf; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d48 2
d53 2
d61 1
d67 31
a97 1
#define BIT(x) (1L << (x))
d99 1
a99 13
#define IPMI_BTMSG_LEN		0
#define IPMI_BTMSG_NFLN		1
#define IPMI_BTMSG_SEQ		2
#define IPMI_BTMSG_CMD		3
#define IPMI_BTMSG_CCODE	4
#define IPMI_BTMSG_DATAIN	4
#define IPMI_BTMSG_DATAOUT	5

#define IPMI_MSG_NFLN		0
#define IPMI_MSG_CMD		1
#define IPMI_MSG_CCODE		2
#define IPMI_MSG_DATAIN		2
#define IPMI_MSG_DATAOUT	3
d103 1
a103 1
#define TB(b,m)   (data[2+byteof(b)] & bitof(b))
d105 1
a105 1
#define dbg_printf(lvl,fmt...)    if (ipmi_dbg >= lvl) { printf(fmt); }
d135 2
a136 2
uint8_t	bmc_read(struct ipmi_softc *, int);
void	bmc_write(struct ipmi_softc *, int, uint8_t);
d144 1
a144 1
int	valid_sensor(int, int);
d146 2
a147 2
void    ipmi_refresh(void *arg);
void    ipmi_refresh_sensors(struct ipmi_softc *sc);
d149 21
a169 1
void    ipmi_unmap_regs(struct ipmi_softc *sc, struct ipmi_attach_args *ia);
d222 1
a222 1
uint8_t
d230 1
a230 1
bmc_write(struct ipmi_softc *sc, int offset, uint8_t val)
d260 9
a268 7
#define BT_CLR_WR_PTR			BIT(0)
#define BT_CLR_RD_PTR			BIT(1)
#define BT_HOST2BMC_ATN			BIT(2)
#define BT_BMC2HOST_ATN			BIT(3)
#define BT_EVT_ATN			BIT(4)
#define BT_HOST_BUSY			BIT(6)
#define BT_BMC_BUSY			BIT(7)
d272 1
d274 4
d284 3
d288 1
a288 1
	for (i = 0; i < len; i++)
d290 1
d293 5
d304 1
a304 1
	uint8_t len, v, i;
d308 1
d319 1
a319 4
#if 0
	data[IPMI_MSG_NFLN] = data[IPMI_BTMSG_
#endif
	    return (0);
d331 11
a341 1
	uint8_t v;
a342 1
	v = bmc_read(sc, _BT_CTRL_REG);
d353 1
a353 1
	return (-1);
d365 6
a370 6
#define  SMIC_BUSY			BIT(0)
#define  SMIC_SMS_ATN			BIT(2)
#define  SMIC_EVT_ATN			BIT(3)
#define  SMIC_SMI			BIT(4)
#define  SMIC_TX_DATA_RDY		BIT(6)
#define  SMIC_RX_DATA_RDY		BIT(7)
d409 1
d421 2
a422 1
	for (idx = 0; idx < len - 1; idx++)
d424 2
a425 2

	sts = smic_write_cmd(sc, SMS_CC_END_TRANSFER, &data[idx]);
d438 1
a438 1
		smic_read_data(sc, &data[idx]);
d463 1
a463 1
#define   KCS_READ_NEXT			0x68
d466 3
a468 3
#define   KCS_GET_STATUS		0x60
#define   KCS_WRITE_START		0x61
#define   KCS_WRITE_END		0x62
d471 11
a481 12
#define   KCS_OBF			BIT(0)
#define   KCS_IBF			BIT(1)
#define   KCS_SMS_ATN			BIT(2)
#define   KCS_CD			BIT(3)
#define   KCS_OEM1			BIT(4)
#define   KCS_OEM2			BIT(5)
#define   KCS_STATE_MASK		0xc0

#define KCS_IDLE_STATE		0x00
#define KCS_READ_STATE		0x40
#define KCS_WRITE_STATE		0x80
#define KCS_ERROR_STATE		0xC0
d497 1
a497 1
	/* Check if output buffer full, read dummy byte  */
d568 1
a568 1
		printf("kcs sendmsg = %d/%d <%.2x>\n", idx, len, sts);
d588 1
a588 1
		printf("kcs read = %d/%d <%.2x>\n", idx, maxlen, sts);
a686 3
void	*scan_sig(long, long, int, int, const void *);
int	scan_smbios(u_int8_t, void (*)(void *, void *), void *);

d704 31
d738 5
a742 4
	smbiosanchor_t	*romhdr;
	smhdr_t		*smhdr;
	u_int8_t	*offset;
	int		nmatch, num;
d749 1
a749 2
#if 0
	printf("Found SMBIOS Version %d.%d at 0x%lx, %d entries\n",
d754 2
a755 3
#endif
	/* XXX: Need to handle correctly if SMBIOS in high memory Get offset
	 * of SMBIOS Table entries */
d757 5
a761 1
	offset = ISA_HOLE_VADDR(romhdr->smr_table_address);
d780 1
d805 1
a805 1
	ia->iaa_if_irq = (pipmi->smipmi_base_flags & BIT(3)) ?
d807 1
a807 1
	ia->iaa_if_irqlvl = (pipmi->smipmi_base_flags & BIT(1)) ?
d810 1
a810 1
	switch (pipmi->smipmi_base_flags >> 6) {
d836 1
a836 1
	if (pipmi->smipmi_base_flags & BIT(4)) {
d849 1
a849 1
bt_buildmsg(struct ipmi_softc *sc, int netlun, int cmd, int len,
d861 1
a861 1
	buf[IPMI_BTMSG_NFLN] = netlun;
d865 1
a865 1
		memcpy(buf + IPMI_BTMSG_DATAIN, data, len);
d892 1
a892 1
		memcpy(buf + IPMI_MSG_DATAIN, data, len);
d958 1
a958 1
	*rxlen = rawlen - IPMI_MSG_DATAOUT;
d960 1
a960 1
		memcpy(data, buf + IPMI_MSG_DATAOUT, *rxlen);
a1093 1
		//bcdplus
d1102 2
a1103 3
		//6 - bit ascii
		/* Characters are encoded in 6-bit ASCII 0x00 - 0x3F maps to
		 * 0x20 - 0x5F */
d1110 1
a1110 1
		//8 - bit ascii
d1122 1
a1122 1
	while (exp > 0) {
d1127 1
a1127 1
	while (exp < 0) {
d1162 2
a1163 2
	/* Calculate sensor reading: y = L((M * v + (B * 10^K1)) *
	 * 10^(K2+adj));
d1165 2
a1166 1
	 * This commutes out to: y = L(M*v * 10^(K2+adj) + B * 10^(K1+K2+adj)); */
d1177 78
d1270 2
d1273 1
a1273 1
	if (data[1] & BIT(5)) {
d1277 1
a1277 29
	psensor->i_sensor.status = SENSOR_S_OK;
	if (s1->sdrhdr.record_type == 2) {
		/* Direct reading */
		psensor->i_sensor.value = data[0];
		return (0);
	}

	dbg_printf(1, "sensor state: %.02x %.02x %.02x %s\n",
	    rxlen, data[2], data[3], psensor->i_sensor.desc);
	/* ..XX.XX. X......X */
	if (data[2] & 0x36)
		psensor->i_sensor.status = SENSOR_S_CRIT;
	else
		if (data[2] & 0x81)
			psensor->i_sensor.status = SENSOR_S_WARN;

	switch (psensor->i_sensor.type) {
	case SENSOR_TEMP:
		psensor->i_sensor.value = ipmi_convert(data[0], s1, 6);
		psensor->i_sensor.value += 273150000;
		break;

	case SENSOR_VOLTS_DC:
		psensor->i_sensor.value = ipmi_convert(data[0], s1, 6);
		break;

	default:
		psensor->i_sensor.value = ipmi_convert(data[0], s1, 0);
	}
d1283 1
a1283 1
valid_sensor(int type, int btype)
d1285 2
a1286 2
	switch (type << 8L | btype) {
	case 0x0101:
d1289 1
a1289 1
	case 0x0201:
d1292 1
a1292 1
	case 0x0401:
d1295 6
a1300 1
	case 0x056F:
d1307 1
d1312 1
a1312 2
	struct ipmi_sensor	*psensor;
	int			typ, base, icnt, snum, idx;
d1320 2
a1321 9
		icnt = 1;
		snum = s1->sensor_num;
		typ = valid_sensor(s1->sensor_type, s1->event_code);
		if (typ == -1) {
			dbg_printf(1, "Unknown sensor type1: st:%.02x "
			    "et:%.02x sn:%.02x %s\n",
			    s1->sensor_type, s1->event_code, snum, name);
			return (0);
		}
d1326 7
a1332 11
		base = s2->share2 & 0x7F;
		icnt = s2->share1 & 0x0F;
		snum = s2->sensor_num;
		typ = valid_sensor(s2->sensor_type, s2->event_code);
		if (typ == -1) {
			dbg_printf(1, "Unknown sensor type2: st:%.02x "
			    "et:%.02x sn:%.02x %s\n",
			    s2->sensor_type, s2->event_code, snum, name);

			return (0);
		}
d1339 20
a1358 1
	for (idx = 0; idx < icnt; idx++) {
d1371 3
a1373 1
		psensor->i_num = snum + idx;
d1378 1
a1378 1
		if (icnt > 1)
d1381 1
a1381 1
			    "%s - %d", name, base + idx);
d1393 1
a1393 1
			dbg_printf(1, "  reading: %lld [%s]\n",
d1422 3
a1481 1
	int			rc;
d1498 3
a1500 2
	if (ipmi_map_regs(&sc, ia) != 0)
		return (0);
d1502 2
a1503 2
	rc = sc.sc_if->probe(&sc);
	ipmi_unmap_regs(&sc, ia);
d1505 1
a1505 1
	return (!rc);
@


1.1
log
@Add initial IPMI implementation.  Currently only the KCS retrieval method is
supported.  SMIC and BMC are being worked on.  IPMI will remain disabled for
now.

Code written by Jordan Hargrave <jordan underscore hargrave at hotmail dot com>

help grange@@ and deraadt@@
ok deraadt@@
@
text
@d55 2
a56 2
int     ipmi_nintr;
int     ipmi_dbg = 0;
d124 3
a126 3
void    ipmi_refresh_sensors(struct ipmi_softc * sc);
int     ipmi_map_regs(struct ipmi_softc * sc, struct ipmi_attach_args * ia);
void    ipmi_unmap_regs(struct ipmi_softc * sc, struct ipmi_attach_args * ia);
d179 2
a180 2
uint8_t 
bmc_read(struct ipmi_softc * sc, int offset)
d186 2
a187 2
void 
bmc_write(struct ipmi_softc * sc, int offset, uint8_t val)
d193 2
a194 2
int 
bmc_io_wait(struct ipmi_softc * sc, int offset, u_int8_t mask,
d229 2
a230 2
int 
bt_sendmsg(struct ipmi_softc * sc, int len, const u_int8_t * data)
d242 2
a243 2
int 
bt_recvmsg(struct ipmi_softc * sc, int maxlen, int *rxlen, u_int8_t * data)
d265 2
a266 2
int 
bt_reset(struct ipmi_softc * sc)
d271 2
a272 2
int 
bt_probe(struct ipmi_softc * sc)
d307 2
a308 2
int 
smic_wait(struct ipmi_softc * sc, u_int8_t mask, u_int8_t val, const char *lbl)
d313 2
a314 2
int 
smic_write_cmd_data(struct ipmi_softc * sc, u_int8_t cmd, const u_int8_t * data)
d316 1
a316 1
	int     sts;
d333 2
a334 2
int 
smic_read_data(struct ipmi_softc * sc, u_int8_t * data)
d347 2
a348 2
int 
smic_sendmsg(struct ipmi_softc * sc, int len, const u_int8_t * data)
d362 2
a363 2
int 
smic_recvmsg(struct ipmi_softc * sc, int maxlen, int *len, u_int8_t * data)
d378 2
a379 2
int 
smic_reset(struct ipmi_softc * sc)
d384 2
a385 2
int 
smic_probe(struct ipmi_softc * sc)
d421 1
a421 1
int 
d444 2
a445 2
int 
kcs_write_cmd(struct ipmi_softc * sc, u_int8_t cmd)
d454 2
a455 2
int 
kcs_write_data(struct ipmi_softc * sc, u_int8_t data)
d464 2
a465 2
int 
kcs_read_data(struct ipmi_softc * sc, u_int8_t * data)
d483 2
a484 2
int 
kcs_sendmsg(struct ipmi_softc * sc, int len, const u_int8_t * data)
d508 2
a509 2
int 
kcs_recvmsg(struct ipmi_softc * sc, int maxlen, int *rxlen, u_int8_t * data)
d528 2
a529 2
int 
kcs_reset(struct ipmi_softc * sc)
d534 2
a535 2
int 
kcs_probe(struct ipmi_softc * sc)
d686 2
a687 2
void 
dumpb(const char *lbl, int len, const u_int8_t * data)
d698 1
a698 1
void 
d750 1
a750 1
bt_buildmsg(struct ipmi_softc * sc, int netlun, int cmd, int len,
d779 1
a779 1
cmn_buildmsg(struct ipmi_softc * sc, int nfLun, int cmd, int len,
d799 2
a800 2
int 
ipmi_sendcmd(struct ipmi_softc * sc, int rssa, int rslun, int netfn, int cmd,
d844 2
a845 2
int 
ipmi_recvcmd(struct ipmi_softc * sc, int maxlen, int *rxlen, void *data)
d878 3
a880 3
int 
get_sdr_partial(struct ipmi_softc * sc, u_int16_t recordId, u_int16_t reserveId,
    u_int8_t offset, u_int8_t length, void *buffer, u_int16_t * nxtRecordId)
d909 2
a910 2
int 
get_sdr(struct ipmi_softc * sc, u_int16_t recid, u_int16_t * nxtrec)
d962 2
a963 2
int 
getbits(u_int8_t * bytes, int bitpos, int bitlen)
d982 2
a983 2
void 
ipmi_sensor_name(char *name, int len, u_int8_t typelen, u_int8_t * bits)
d992 1
a992 1
		    break;
d997 1
a997 1
		    for (i = 0; i < slen; i++) {
d1007 1
a1007 1
		    for (i = 0; i < slen * 8; i += 6) {
d1014 1
a1014 1
		    while (slen--)
d1022 1
a1022 1
long 
d1039 2
a1040 2
long 
ipmi_convert(u_int8_t v, sdrtype1 * s1, long adj)
d1067 1
a1067 1
	 * 
d1078 2
a1079 2
int 
read_sensor(struct ipmi_softc * sc, struct ipmi_sensor * psensor)
d1124 1
a1124 1
		
d1132 1
a1132 1
int 
d1153 2
a1154 2
int 
add_sdr_sensor(struct ipmi_softc * sc, u_int8_t * psdr)
d1238 1
a1238 1
int 
d1252 2
a1253 2
void 
ipmi_refresh_sensors(struct ipmi_softc * sc)
d1264 1
a1264 1
void 
d1273 2
a1274 2
int 
ipmi_map_regs(struct ipmi_softc * sc, struct ipmi_attach_args * ia)
d1301 2
a1302 2
void 
ipmi_unmap_regs(struct ipmi_softc * sc, struct ipmi_attach_args * ia)
d1308 2
a1309 2
int 
ipmi_probe(struct device * parent, void *match, void *aux)
d1340 2
a1341 2
void 
ipmi_attach(struct device * parent, struct device * self, void *aux)
d1366 4
a1369 9
	printf("\n%s: ver=%d.%d iface=%s %cbase=0x%x/%x spacing=%d irq=%d\n",
	    sc->sc_dev.dv_xname,
	    ia->iaa_if_rev >> 4,
	    ia->iaa_if_rev & 0xF,
	    sc->sc_if->name,
	    ia->iaa_if_iotype,
	    ia->iaa_if_iobase,
	    ia->iaa_if_iospacing * sc->sc_if->nregs,
	    ia->iaa_if_iospacing,
@

