head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.14
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.16
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.12
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.10
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.8
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.2.0.8
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.6
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.1.0.2
	OPENBSD_4_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.11.11.03.03.34;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.17.01.30.30;	author thib;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.03.22.09.30;	author thib;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.14.32.00;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.7
log
@replace disksort with bufqs.

i havent had any tests, so if there's any fallout ill deal with it when
people hit it. i wont feel guilty about it at all though.
@
text
@/*	$OpenBSD: flashvar.h,v 1.6 2013/05/30 16:15:01 deraadt Exp $	*/

/*
 * Copyright (c) 2005 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _FLASHVAR_H_
#define _FLASHVAR_H_

#ifdef _KERNEL

/* Flash controller descriptor structure */
struct flash_ctl_tag {
	u_int8_t (*reg8_read)(void *, int);
	int	 (*regx_read_page)(void *, caddr_t, caddr_t);
	void	 (*reg8_write)(void *, int, u_int8_t);
	int	 (*regx_write_page)(void *, caddr_t, caddr_t);
	void	 (*default_disklabel)(void *, dev_t, struct disklabel *);
	int	 (*safe_strategy)(void *, struct buf *);
};

/*
 * Pseudo-registers for a fictitious flash controller
 *
 * Note that logical levels are assumed for CE and WP bits.
 * Signals corresponding to these bits are usually negated.
 */
#define FLASH_REG_DATA		0x00
#define FLASH_REG_COL		0x01
#define FLASH_REG_ROW		0x02
#define FLASH_REG_CMD		0x03
#define FLASH_REG_ALE		0x04
#define FLASH_REG_CLE		0x05
#define FLASH_REG_CE		0x06
#define FLASH_REG_WP		0x07
#define FLASH_REG_READY		0x0f

/* Flash device descriptor structure */
struct flashdev {
	u_int16_t	 id;
	const char	*longname;
	u_long		 pagesize;	/* bytes per page */
	u_long		 oobsize;	/* OOB bytes per page */
	u_long		 blkpages;	/* pages per erasable block */
	u_long		 capacity;	/* pages per device */
};

#define FLASH_DEVICE(v,d)		((FLASH_VENDOR_##v << 8) | (d))

/* Flash device vendors */
#define FLASH_VENDOR_SAMSUNG		0xec

/* Flash devices */
#define FLASH_DEVICE_SAMSUNG_K9F2808U0C FLASH_DEVICE(SAMSUNG, 0x73)
#define FLASH_DEVICE_SAMSUNG_K9F1G08U0A FLASH_DEVICE(SAMSUNG, 0xf1)

/* Maximum sizes for all devices */
#define FLASH_MAXPAGESIZE	2048
#define FLASH_MAXOOBSIZE	64

/*
 * Should-be private softc structure for the generic flash driver.
 */
struct flash_softc {
	struct device		 sc_dev;
	/* Disk device information */
	struct disk		 sc_dk;
	struct bufq		 sc_bufq;
	struct buf		*sc_bp;
	int			 sc_flags;
	/* Flash controller tag */
	struct flash_ctl_tag	*sc_tag;
	void			*sc_cookie;
	/* Flash device characteristics */
	const struct flashdev	*sc_flashdev;
	int			 sc_maxwaitready;
	int			 sc_maxwaitcomplete;
};

/* Values for sc_flags */
#define FDK_LOADED		 0x00000001
#define FDK_SAFE		 0x00000002

/*
 * Similar to vnd(4) devices there are two kinds of flash devices.
 * Both device kinds share the same disklabel.
 *
 * ``Safe'' devices have bit 11 set in the minor number and use the
 * out-of-band page data to implement wear-leveling and transparent
 * management of bad block information. Block erasing and rewriting
 * is also handled transparently; arbitrary pages can be modified.
 *
 * ``Unsafe'' devices provide raw access to the flash pages. Access
 * to OOB page data is possible via ioctl()s only with these devices.
 * Erasing the containing flash block may be necessary before a page
 * can be writting successfully, but the block erase command is only
 * provided as an ioctl().
 */
#define flashsafe(x)	(minor(x) & 0x800)
#define flashunit(x)	DISKUNIT(makedev(major(x), minor(x) & 0x7ff))
#define flashpart(x)	DISKPART(makedev(major(x), minor(x) & 0x7ff))
#define flashlabeldev(x) (MAKEDISKDEV(major(x), flashunit(x), RAW_PART)\
			 |flashsafe(x))

void	 flashattach(struct flash_softc *, struct flash_ctl_tag *, void *);
int	 flashdetach(struct device *, int);

u_int8_t flash_reg8_read(struct flash_softc *, int);
void	 flash_reg8_read_page(struct flash_softc *, caddr_t, caddr_t);
void	 flash_reg8_write(struct flash_softc *, int, u_int8_t);
void	 flash_reg8_write_page(struct flash_softc *, caddr_t, caddr_t);
void	 flash_chip_enable(struct flash_softc *);
void	 flash_chip_disable(struct flash_softc *);
int	 flash_chip_reset(struct flash_softc *);
int	 flash_chip_identify(struct flash_softc *, u_int8_t *, u_int8_t *);
int	 flash_chip_erase_block(struct flash_softc *, long);
int	 flash_chip_read_block(struct flash_softc *, long, caddr_t);
int	 flash_chip_read_page(struct flash_softc *, long, caddr_t, caddr_t);
int	 flash_chip_read_oob(struct flash_softc *, long, caddr_t);
int	 flash_chip_write_block(struct flash_softc *, long, caddr_t, caddr_t);
int	 flash_chip_write_page(struct flash_softc *, long, caddr_t, caddr_t);
int	 flash_chip_verify_block(struct flash_softc *, long, caddr_t, caddr_t);
int	 flash_chip_verify_page(struct flash_softc *, long, caddr_t, caddr_t);

#endif /* _KERNEL */

/* XXX: define ioctl commands for OOB page data access and block erase. */

#endif /* _FLASHVAR_H_ */
@


1.6
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: flashvar.h,v 1.5 2009/10/13 19:33:16 pirofti Exp $	*/
d80 1
a80 1
	struct buf		 sc_q; 
@


1.5
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: flashvar.h,v 1.4 2009/06/17 01:30:30 thib Exp $	*/
a118 1
int	 flashactivate(struct device *, int);
@


1.4
log
@Revert bufq's. this is inline with the major midlayer reverts that
have been going on. this appears to bring us back to stable state.

lots of testing by oga and ariane and my self.
@
text
@d1 1
a1 1
/*	$OpenBSD: flashvar.h,v 1.3 2009/06/03 22:09:30 thib Exp $	*/
d119 1
a119 1
int	 flashactivate(struct device *, enum devact);
@


1.3
log
@add a flexible buffer queue (bufq) api, based on the never used
one by tedu@@. It doesn't do anything smart yet, it just uses
plain old disksort. we also keep the old method of queueing bufs
since some miods have crazy MD drivers that need some love.

ok beck@@, art@@
tested by many on many archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: flashvar.h,v 1.1 2006/11/25 14:32:00 uwe Exp $	*/
d80 1
@


1.2
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@a79 1
	struct buf		 sc_q;
@


1.1
log
@Initial NAND flash support for Zaurus, not enabled yet; prodded by many.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 1
a30 2
	void	 (*default_disklabel)(void *, dev_t, struct disklabel *,
	             struct cpu_disklabel *);
@

