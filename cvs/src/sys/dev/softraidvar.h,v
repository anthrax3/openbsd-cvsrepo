head	1.166;
access;
symbols
	OPENBSD_6_0:1.163.0.2
	OPENBSD_6_0_BASE:1.163
	OPENBSD_5_9:1.161.0.2
	OPENBSD_5_9_BASE:1.161
	OPENBSD_5_8:1.161.0.4
	OPENBSD_5_8_BASE:1.161
	OPENBSD_5_7:1.159.0.4
	OPENBSD_5_7_BASE:1.159
	OPENBSD_5_6:1.157.0.4
	OPENBSD_5_6_BASE:1.157
	OPENBSD_5_5:1.154.0.4
	OPENBSD_5_5_BASE:1.154
	OPENBSD_5_4:1.139.0.2
	OPENBSD_5_4_BASE:1.139
	OPENBSD_5_3:1.126.0.2
	OPENBSD_5_3_BASE:1.126
	OPENBSD_5_2:1.116.0.4
	OPENBSD_5_2_BASE:1.116
	OPENBSD_5_1_BASE:1.116
	OPENBSD_5_1:1.116.0.2
	OPENBSD_5_0:1.106.0.2
	OPENBSD_5_0_BASE:1.106
	OPENBSD_4_9:1.97.0.2
	OPENBSD_4_9_BASE:1.97
	OPENBSD_4_8:1.94.0.2
	OPENBSD_4_8_BASE:1.94
	OPENBSD_4_7:1.89.0.2
	OPENBSD_4_7_BASE:1.89
	OPENBSD_4_6:1.78.0.4
	OPENBSD_4_6_BASE:1.78
	OPENBSD_4_5:1.66.0.2
	OPENBSD_4_5_BASE:1.66
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.49.0.2
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32;
locks; strict;
comment	@ * @;


1.166
date	2016.12.24.22.49.38;	author yasuoka;	state Exp;
branches;
next	1.165;
commitid	jED5tqz3dldT5cC2;

1.165
date	2016.09.10.17.06.11;	author jsing;	state Exp;
branches;
next	1.164;
commitid	iP7RQ0ZDutjdGIFn;

1.164
date	2016.09.10.16.53.22;	author jsing;	state Exp;
branches;
next	1.163;
commitid	ndlwtBWcdxwcJuNH;

1.163
date	2016.05.31.15.19.12;	author jsing;	state Exp;
branches;
next	1.162;
commitid	cwFTIUrXuiupYWGN;

1.162
date	2016.04.04.18.48.39;	author krw;	state Exp;
branches;
next	1.161;
commitid	1ISokwrtQ24zRrhW;

1.161
date	2015.07.21.03.30.51;	author krw;	state Exp;
branches;
next	1.160;
commitid	TJiPw62Nfq0KhqBx;

1.160
date	2015.07.19.18.24.16;	author krw;	state Exp;
branches;
next	1.159;
commitid	soWovNPxU9gU33mQ;

1.159
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.158;
commitid	MyKPm9Q3dQu92BiX;

1.158
date	2014.10.07.20.23.32;	author tedu;	state Exp;
branches;
next	1.157;
commitid	1hbxZJRSxjvGk5Dm;

1.157
date	2014.07.20.18.05.21;	author mlarkin;	state Exp;
branches;
next	1.156;
commitid	F1K1yInguabWnn54;

1.156
date	2014.07.12.07.39.11;	author blambert;	state Exp;
branches;
next	1.155;
commitid	d0e1MLWWcCZIgJ1z;

1.155
date	2014.07.10.12.21.09;	author mpi;	state Exp;
branches;
next	1.154;
commitid	rMrMHPG4SqHlsP5W;

1.154
date	2014.01.22.09.42.13;	author jsing;	state Exp;
branches;
next	1.153;

1.153
date	2014.01.22.09.03.19;	author jsing;	state Exp;
branches;
next	1.152;

1.152
date	2014.01.22.05.11.36;	author jsing;	state Exp;
branches;
next	1.151;

1.151
date	2014.01.22.04.24.29;	author jsing;	state Exp;
branches;
next	1.150;

1.150
date	2014.01.21.05.11.12;	author jsing;	state Exp;
branches;
next	1.149;

1.149
date	2014.01.21.04.23.14;	author jsing;	state Exp;
branches;
next	1.148;

1.148
date	2014.01.21.03.50.44;	author jsing;	state Exp;
branches;
next	1.147;

1.147
date	2014.01.20.04.47.31;	author jsing;	state Exp;
branches;
next	1.146;

1.146
date	2014.01.20.04.38.59;	author jsing;	state Exp;
branches;
next	1.145;

1.145
date	2014.01.20.00.11.50;	author jsing;	state Exp;
branches;
next	1.144;

1.144
date	2014.01.18.09.33.53;	author jsing;	state Exp;
branches;
next	1.143;

1.143
date	2014.01.18.09.23.26;	author jsing;	state Exp;
branches;
next	1.142;

1.142
date	2014.01.18.09.01.01;	author jsing;	state Exp;
branches;
next	1.141;

1.141
date	2014.01.18.08.49.20;	author jsing;	state Exp;
branches;
next	1.140;

1.140
date	2013.11.04.21.02.57;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.138;

1.138
date	2013.05.21.15.01.54;	author jsing;	state Exp;
branches;
next	1.137;

1.137
date	2013.05.21.14.25.24;	author jsing;	state Exp;
branches;
next	1.136;

1.136
date	2013.04.26.15.45.35;	author jsing;	state Exp;
branches;
next	1.135;

1.135
date	2013.04.23.12.49.52;	author jsing;	state Exp;
branches;
next	1.134;

1.134
date	2013.04.21.13.00.21;	author jsing;	state Exp;
branches;
next	1.133;

1.133
date	2013.03.31.11.37.40;	author jsing;	state Exp;
branches;
next	1.132;

1.132
date	2013.03.30.14.41.36;	author jsing;	state Exp;
branches;
next	1.131;

1.131
date	2013.03.30.02.02.14;	author jsing;	state Exp;
branches;
next	1.130;

1.130
date	2013.03.29.12.00.59;	author jsing;	state Exp;
branches;
next	1.129;

1.129
date	2013.03.25.16.01.49;	author jsing;	state Exp;
branches;
next	1.128;

1.128
date	2013.03.10.09.05.12;	author jsing;	state Exp;
branches;
next	1.127;

1.127
date	2013.03.05.10.24.00;	author jsing;	state Exp;
branches;
next	1.126;

1.126
date	2013.01.18.09.39.03;	author jsing;	state Exp;
branches;
next	1.125;

1.125
date	2013.01.16.07.07.38;	author jsing;	state Exp;
branches;
next	1.124;

1.124
date	2013.01.16.07.06.29;	author jsing;	state Exp;
branches;
next	1.123;

1.123
date	2013.01.16.06.29.14;	author jsing;	state Exp;
branches;
next	1.122;

1.122
date	2013.01.15.09.51.22;	author jsing;	state Exp;
branches;
next	1.121;

1.121
date	2013.01.15.04.03.01;	author jsing;	state Exp;
branches;
next	1.120;

1.120
date	2013.01.15.03.47.10;	author jsing;	state Exp;
branches;
next	1.119;

1.119
date	2012.10.09.13.55.36;	author jsing;	state Exp;
branches;
next	1.118;

1.118
date	2012.10.09.11.57.33;	author jsing;	state Exp;
branches;
next	1.117;

1.117
date	2012.10.08.14.22.41;	author jsing;	state Exp;
branches;
next	1.116;

1.116
date	2012.01.28.14.40.04;	author jsing;	state Exp;
branches;
next	1.115;

1.115
date	2012.01.20.14.43.05;	author jsing;	state Exp;
branches;
next	1.114;

1.114
date	2012.01.11.14.10.51;	author jsing;	state Exp;
branches;
next	1.113;

1.113
date	2011.12.31.17.06.10;	author jsing;	state Exp;
branches;
next	1.112;

1.112
date	2011.12.28.16.19.52;	author jsing;	state Exp;
branches;
next	1.111;

1.111
date	2011.12.26.14.54.52;	author jsing;	state Exp;
branches;
next	1.110;

1.110
date	2011.11.11.12.32.11;	author jsing;	state Exp;
branches;
next	1.109;

1.109
date	2011.09.19.21.39.31;	author jsing;	state Exp;
branches;
next	1.108;

1.108
date	2011.09.18.19.40.49;	author jsing;	state Exp;
branches;
next	1.107;

1.107
date	2011.09.18.13.11.08;	author jsing;	state Exp;
branches;
next	1.106;

1.106
date	2011.07.07.03.50.00;	author tedu;	state Exp;
branches;
next	1.105;

1.105
date	2011.07.07.00.18.06;	author tedu;	state Exp;
branches;
next	1.104;

1.104
date	2011.07.06.17.32.47;	author jsing;	state Exp;
branches;
next	1.103;

1.103
date	2011.07.06.15.44.11;	author jsing;	state Exp;
branches;
next	1.102;

1.102
date	2011.07.05.19.02.47;	author oga;	state Exp;
branches;
next	1.101;

1.101
date	2011.07.02.17.39.12;	author jsing;	state Exp;
branches;
next	1.100;

1.100
date	2011.06.23.17.20.16;	author matthew;	state Exp;
branches;
next	1.99;

1.99
date	2011.04.05.19.52.02;	author krw;	state Exp;
branches;
next	1.98;

1.98
date	2011.03.15.13.29.41;	author jsing;	state Exp;
branches;
next	1.97;

1.97
date	2011.01.29.15.01.22;	author marco;	state Exp;
branches;
next	1.96;

1.96
date	2010.11.06.23.01.56;	author marco;	state Exp;
branches;
next	1.95;

1.95
date	2010.08.30.17.32.40;	author jsing;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.02.09.26.05;	author jsing;	state Exp;
branches;
next	1.93;

1.93
date	2010.07.02.09.20.26;	author jsing;	state Exp;
branches;
next	1.92;

1.92
date	2010.04.18.16.57.48;	author jsing;	state Exp;
branches;
next	1.91;

1.91
date	2010.03.28.16.38.57;	author jsing;	state Exp;
branches;
next	1.90;

1.90
date	2010.03.26.11.20.34;	author jsing;	state Exp;
branches;
next	1.89;

1.89
date	2010.02.13.21.19.26;	author jsing;	state Exp;
branches;
next	1.88;

1.88
date	2009.12.31.14.00.45;	author jsing;	state Exp;
branches;
next	1.87;

1.87
date	2009.12.15.13.19.37;	author jsing;	state Exp;
branches;
next	1.86;

1.86
date	2009.12.07.14.33.38;	author jsing;	state Exp;
branches;
next	1.85;

1.85
date	2009.12.07.14.27.12;	author jsing;	state Exp;
branches;
next	1.84;

1.84
date	2009.11.24.02.19.35;	author jsing;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.23.16.33.59;	author jsing;	state Exp;
branches;
next	1.82;

1.82
date	2009.11.22.17.01.18;	author jsing;	state Exp;
branches;
next	1.81;

1.81
date	2009.08.09.14.12.25;	author marco;	state Exp;
branches;
next	1.80;

1.80
date	2009.07.23.15.15.25;	author jordan;	state Exp;
branches;
next	1.79;

1.79
date	2009.07.12.16.31.56;	author jsing;	state Exp;
branches;
next	1.78;

1.78
date	2009.06.26.14.50.44;	author jsing;	state Exp;
branches;
next	1.77;

1.77
date	2009.06.24.12.06.00;	author jsing;	state Exp;
branches;
next	1.76;

1.76
date	2009.06.17.22.44.42;	author marco;	state Exp;
branches;
next	1.75;

1.75
date	2009.06.17.03.43.30;	author marco;	state Exp;
branches;
next	1.74;

1.74
date	2009.06.12.23.56.02;	author jordan;	state Exp;
branches;
next	1.73;

1.73
date	2009.06.11.19.42.59;	author marco;	state Exp;
branches;
next	1.72;

1.72
date	2009.06.10.03.24.02;	author marco;	state Exp;
branches;
next	1.71;

1.71
date	2009.06.03.21.04.36;	author marco;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.02.19.15.58;	author marco;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.02.05.49.35;	author marco;	state Exp;
branches;
next	1.68;

1.68
date	2009.06.02.00.58.16;	author marco;	state Exp;
branches;
next	1.67;

1.67
date	2009.05.11.14.06.21;	author jsing;	state Exp;
branches;
next	1.66;

1.66
date	2008.12.24.19.32.02;	author marco;	state Exp;
branches;
next	1.65;

1.65
date	2008.11.25.23.05.17;	author marco;	state Exp;
branches;
next	1.64;

1.64
date	2008.11.23.23.44.01;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.29.01.18.02;	author marco;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.20.21.57.51;	author djm;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.19.22.41.58;	author marco;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.25.17.43.09;	author thib;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.14.03.01.00;	author djm;	state Exp;
branches;
next	1.58;

1.58
date	2008.06.14.00.39.15;	author djm;	state Exp;
branches;
next	1.57;

1.57
date	2008.06.14.00.12.21;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2008.06.13.22.08.17;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2008.06.13.21.03.40;	author hshoexer;	state Exp;
branches;
next	1.54;

1.54
date	2008.06.13.18.27.42;	author djm;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.12.18.21.04;	author hshoexer;	state Exp;
branches;
next	1.52;

1.52
date	2008.06.12.18.13.27;	author hshoexer;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.12.00.19.15;	author marco;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.11.00.26.18;	author hshoexer;	state Exp;
branches;
next	1.49;

1.49
date	2008.02.22.23.00.04;	author hshoexer;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.17.22.56.20;	author marco;	state Exp;
branches;
next	1.47;

1.47
date	2008.02.17.20.39.22;	author hshoexer;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.15.05.29.25;	author ckuethe;	state Exp;
branches;
next	1.45;

1.45
date	2008.02.14.22.04.34;	author ckuethe;	state Exp;
branches;
next	1.44;

1.44
date	2008.02.07.15.08.49;	author marco;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.05.16.49.25;	author marco;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.05.16.15.35;	author marco;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.03.00.25.21;	author marco;	state Exp;
branches;
next	1.40;

1.40
date	2008.01.29.23.25.02;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2008.01.26.19.29.55;	author marco;	state Exp;
branches;
next	1.38;

1.38
date	2008.01.24.19.58.08;	author marco;	state Exp;
branches;
next	1.37;

1.37
date	2008.01.24.13.58.14;	author marco;	state Exp;
branches;
next	1.36;

1.36
date	2008.01.19.23.53.53;	author marco;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.27.17.21.52;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.27.16.37.05;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.26.13.49.26;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.06.23.06.02;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.02.00.53.35;	author marco;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.01.18.50.56;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.31.18.56.27;	author marco;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.31.05.49.26;	author grunk;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.30.15.59.35;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.30.13.55.47;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.29.23.20.02;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.29.18.35.00;	author marco;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.29.08.15.32;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.28.21.54.26;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.26.14.30.26;	author marco;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.24.13.15.31;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.23.21.27.13;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.08.23.54.37;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.01.22.53.51;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.23.20.11.31;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2007.04.22.04.05.36;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.22.00.41.31;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.22.00.06.09;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.21.23.39.18;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.21.23.05.19;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.19.02.44.29;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.14.21.28.08;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.12.03.31.54;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.11.22.05.09;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.30.23.15.30;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.27.04.05.22;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.19.22.33.15;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.19.14.33.28;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.19.03.02.08;	author marco;	state Exp;
branches;
next	;


desc
@@


1.166
log
@Make the boot programs support booting from softraid on 4K byte sector
disks.

test gonzalo
ok tom krw jsing
@
text
@/* $OpenBSD: softraidvar.h,v 1.165 2016/09/10 17:06:11 jsing Exp $ */
/*
 * Copyright (c) 2006 Marco Peereboom <marco@@peereboom.us>
 * Copyright (c) 2008 Chris Kuethe <ckuethe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef SOFTRAIDVAR_H
#define SOFTRAIDVAR_H

#define SR_META_VERSION		6	/* bump when sr_metadata changes */
#define SR_META_SIZE		64	/* save space at chunk beginning */
#define SR_META_OFFSET		16	/* skip 8192 bytes at chunk beginning */

#define SR_BOOT_OFFSET		(SR_META_OFFSET + SR_META_SIZE)
#define SR_BOOT_LOADER_SIZE	320	/* Size of boot loader storage. */
#define SR_BOOT_LOADER_OFFSET	SR_BOOT_OFFSET
#define SR_BOOT_BLOCKS_SIZE	128	/* Size of boot block storage. */
#define SR_BOOT_BLOCKS_OFFSET	(SR_BOOT_LOADER_OFFSET + SR_BOOT_LOADER_SIZE)
#define SR_BOOT_SIZE		(SR_BOOT_LOADER_SIZE + SR_BOOT_BLOCKS_SIZE)

#define SR_CRYPTO_MAXKEYBYTES	32	/* max bytes in a key (AES-XTS-256) */
#define SR_CRYPTO_MAXKEYS	32	/* max keys per volume */
#define SR_CRYPTO_KEYBITS	512	/* AES-XTS with 2 * 256 bit keys */
#define SR_CRYPTO_KEYBYTES	(SR_CRYPTO_KEYBITS >> 3)
#define SR_CRYPTO_KDFHINTBYTES	256	/* size of opaque KDF hint */
#define SR_CRYPTO_CHECKBYTES	64	/* size of generic key chksum struct */
#define SR_CRYPTO_KEY_BLKSHIFT	30	/* 0.5TB per key */

/*
 * sr_crypto_genkdf is a generic hint for the KDF performed in userland and
 * is not interpreted by the kernel.
 */
struct sr_crypto_genkdf {
	u_int32_t	len;
	u_int32_t	type;
#define SR_CRYPTOKDFT_INVALID		0
#define SR_CRYPTOKDFT_PKCS5_PBKDF2	1
#define SR_CRYPTOKDFT_KEYDISK		2
#define SR_CRYPTOKDFT_BCRYPT_PBKDF	3
};

/*
 * sr_crypto_pbkdf is a hint for a PBKDF performed in userland and is not
 * interpreted by the kernel.
 */
struct sr_crypto_pbkdf {
	struct sr_crypto_genkdf generic;
	u_int32_t	rounds;
	u_int8_t	salt[128];
};

/*
 * sr_crypto_kdfinfo is used to copy masking keys and KDF hints from/to
 * userland. The embedded hint structures are not interpreted by the kernel.
 */
struct sr_crypto_kdfinfo {
	u_int32_t	len;
	u_int32_t	flags;
#define SR_CRYPTOKDF_INVALID	(0)
#define SR_CRYPTOKDF_KEY	(1<<0)
#define SR_CRYPTOKDF_HINT	(1<<1)
	u_int8_t	maskkey[SR_CRYPTO_MAXKEYBYTES];
	union {
		struct sr_crypto_genkdf	generic;
		struct sr_crypto_pbkdf	pbkdf;
	}		_kdfhint;
#define genkdf		_kdfhint.generic
#define pbkdf		_kdfhint.pbkdf
};

#define SR_IOCTL_GET_KDFHINT		0x01	/* Get KDF hint. */
#define SR_IOCTL_CHANGE_PASSPHRASE	0x02	/* Change passphase. */

struct sr_crypto_kdfpair {
	struct sr_crypto_kdfinfo *kdfinfo1;
	u_int32_t	kdfsize1;
	struct sr_crypto_kdfinfo *kdfinfo2;
	u_int32_t	kdfsize2;
};

#if defined(_KERNEL) || defined(_STANDALONE)

#include <crypto/md5.h>

#define SR_META_V3_SIZE		64
#define SR_META_V3_OFFSET	16
#define SR_META_V3_DATA_OFFSET	(SR_META_V3_OFFSET + SR_META_V3_SIZE)

#define SR_META_F_NATIVE	0	/* Native metadata format. */
#define SR_META_F_INVALID	-1

#define SR_HEADER_SIZE		(SR_META_SIZE + SR_BOOT_SIZE)
#define SR_DATA_OFFSET		(SR_META_OFFSET + SR_HEADER_SIZE)

#define SR_HOTSPARE_LEVEL	0xffffffff
#define SR_HOTSPARE_VOLID	0xffffffff
#define SR_KEYDISK_LEVEL	0xfffffffe
#define SR_KEYDISK_VOLID	0xfffffffe

#define SR_UUID_MAX		16
struct sr_uuid {
	u_int8_t		sui_id[SR_UUID_MAX];
} __packed;

struct sr_disk {
	dev_t			sdk_devno;
	SLIST_ENTRY(sr_disk)	sdk_link;
};
SLIST_HEAD(sr_disk_head, sr_disk);

struct sr_metadata {
	struct sr_meta_invariant {
		/* do not change order of ssd_magic, ssd_version */
		u_int64_t	ssd_magic;	/* magic id */
#define	SR_MAGIC		0x4d4152436372616dLLU
		u_int32_t	ssd_version;	/* meta data version */
		u_int32_t	ssd_vol_flags;	/* volume specific flags. */
		struct sr_uuid	ssd_uuid;	/* unique identifier */

		/* chunks */
		u_int32_t	ssd_chunk_no;	/* number of chunks */
		u_int32_t	ssd_chunk_id;	/* chunk identifier */

		/* optional */
		u_int32_t	ssd_opt_no;	/* nr of optional md elements */
		u_int32_t	ssd_secsize;

		/* volume metadata */
		u_int32_t	ssd_volid;	/* volume id */
		u_int32_t	ssd_level;	/* raid level */
		int64_t		ssd_size;	/* virt disk size in blocks */
		char		ssd_vendor[8];	/* scsi vendor */
		char		ssd_product[16];/* scsi product */
		char		ssd_revision[4];/* scsi revision */
		/* optional volume members */
		u_int32_t	ssd_strip_size;	/* strip size */
	} _sdd_invariant;
#define ssdi			_sdd_invariant
	/* MD5 of invariant metadata */
	u_int8_t		ssd_checksum[MD5_DIGEST_LENGTH];
	char			ssd_devname[32];/* /dev/XXXXX */
	u_int32_t		ssd_meta_flags;
#define	SR_META_DIRTY		0x1
	u_int32_t		ssd_data_blkno;
	u_int64_t		ssd_ondisk;	/* on disk version counter */
	int64_t			ssd_rebuild;	/* last block of rebuild */
} __packed;

struct sr_meta_chunk {
	struct sr_meta_chunk_invariant {
		u_int32_t	scm_volid;	/* vd we belong to */
		u_int32_t	scm_chunk_id;	/* chunk id */
		char		scm_devname[32];/* /dev/XXXXX */
		int64_t		scm_size;	/* size of partition in blocks*/
		int64_t		scm_coerced_size; /* coerced sz of part in blk*/
		struct sr_uuid	scm_uuid;	/* unique identifier */
	} _scm_invariant;
#define scmi			_scm_invariant
	/* MD5 of invariant chunk metadata */
	u_int8_t		scm_checksum[MD5_DIGEST_LENGTH];
	u_int32_t		scm_status;	/* use bio bioc_disk status */
} __packed;

/*
 * Check that HMAC-SHA1_k(decrypted scm_key) == sch_mac, where
 * k = SHA1(masking key)
 */
struct sr_crypto_chk_hmac_sha1 {
	u_int8_t	sch_mac[20];
} __packed;

#define SR_OPT_INVALID		0x00
#define SR_OPT_CRYPTO		0x01
#define SR_OPT_BOOT		0x02
#define SR_OPT_KEYDISK		0x03

struct sr_meta_opt_hdr {
	u_int32_t	som_type;	/* optional metadata type. */
	u_int32_t	som_length;	/* optional metadata length. */
	u_int8_t	som_checksum[MD5_DIGEST_LENGTH];
} __packed;

struct sr_meta_crypto {
	struct sr_meta_opt_hdr	scm_hdr;
	u_int32_t		scm_alg;	/* vol crypto algorithm */
#define SR_CRYPTOA_AES_XTS_128	1
#define SR_CRYPTOA_AES_XTS_256	2
	u_int32_t		scm_flags;	/* key & kdfhint valid */
#define SR_CRYPTOF_INVALID	(0)
#define SR_CRYPTOF_KEY		(1<<0)
#define SR_CRYPTOF_KDFHINT	(1<<1)
	u_int32_t		scm_mask_alg;	/* disk key masking crypt alg */
#define SR_CRYPTOM_AES_ECB_256	1
	u_int32_t		scm_pad1;
	u_int8_t		scm_reserved[64];

	/* symmetric keys used for disk encryption */
	u_int8_t		scm_key[SR_CRYPTO_MAXKEYS][SR_CRYPTO_KEYBYTES];
	/* hint to kdf algorithm (opaque to kernel) */
	u_int8_t		scm_kdfhint[SR_CRYPTO_KDFHINTBYTES];

	u_int32_t		scm_check_alg;	/* key chksum algorithm */
#define SR_CRYPTOC_HMAC_SHA1		1
	u_int32_t		scm_pad2;
	union {
		struct sr_crypto_chk_hmac_sha1	chk_hmac_sha1;
		u_int8_t			chk_reserved2[64];
	}			_scm_chk;
#define	chk_hmac_sha1	_scm_chk.chk_hmac_sha1
} __packed;

#define SR_MAX_BOOT_DISKS 16
struct sr_meta_boot {
	struct sr_meta_opt_hdr	sbm_hdr;
	u_int32_t		sbm_bootblk_size;
	u_int32_t		sbm_bootldr_size;
	u_char			sbm_root_duid[8];
	u_char			sbm_boot_duid[SR_MAX_BOOT_DISKS][8];
} __packed;

struct sr_meta_keydisk {
	struct sr_meta_opt_hdr	skm_hdr;
	u_int8_t		skm_maskkey[SR_CRYPTO_MAXKEYBYTES];
} __packed;

#define SR_OLD_META_OPT_SIZE	2480
#define SR_OLD_META_OPT_OFFSET	8
#define SR_OLD_META_OPT_MD5	(SR_OLD_META_OPT_SIZE - MD5_DIGEST_LENGTH)

struct sr_meta_opt_item {
	struct sr_meta_opt_hdr	*omi_som;
	SLIST_ENTRY(sr_meta_opt_item) omi_link;
};

SLIST_HEAD(sr_meta_opt_head, sr_meta_opt_item);

struct sr_boot_chunk {
	struct sr_metadata *sbc_metadata;
	dev_t		sbc_mm;			/* Device major/minor. */

	u_int32_t	sbc_chunk_id;		/* Chunk ID. */
	u_int32_t	sbc_state;		/* Chunk state. */
	u_int32_t	sbc_disk;		/* Disk number. */
	int		sbc_part;		/* Partition number. */
	u_int64_t	sbc_ondisk;		/* Ondisk version. */

	void		*sbc_diskinfo;		/* MD disk information. */

	SLIST_ENTRY(sr_boot_chunk) sbc_link;
};

SLIST_HEAD(sr_boot_chunk_head, sr_boot_chunk);

struct sr_boot_volume {
	struct sr_uuid	sbv_uuid;		/* Volume UUID. */
	u_int32_t	sbv_level;		/* RAID Level. */
	u_int32_t	sbv_volid;		/* Volume ID. */
	u_int32_t	sbv_chunk_no;		/* Number of chunks. */
	u_int32_t	sbv_flags;		/* Volume specific flags. */
	u_int32_t	sbv_state;		/* Volume state. */
	int64_t		sbv_size;		/* Virtual disk size. */
	u_int32_t	sbv_secsize;		/* Sector size */
	u_int32_t	sbv_data_blkno;		/* Data offset. */
	u_int64_t	sbv_ondisk;		/* Ondisk version. */

	u_int32_t	sbv_chunks_found;	/* Number of chunks found. */
	u_int32_t	sbv_unit;		/* Disk unit number. */
	char		sbv_part;		/* Partition opened. */
	void		*sbv_diskinfo;		/* MD disk information. */

	u_int8_t	*sbv_keys;		/* Disk keys for volume. */
	u_int8_t	*sbv_maskkey;		/* Mask key for disk keys. */

	struct sr_boot_chunk_head sbv_chunks;	/* List of chunks. */
	struct sr_meta_opt_head sbv_meta_opt;	/* List of optional metadata. */

	SLIST_ENTRY(sr_boot_volume)	sbv_link;
};

SLIST_HEAD(sr_boot_volume_head, sr_boot_volume);

#endif /* _KERNEL | _STANDALONE */

#ifdef _KERNEL

#include <dev/biovar.h>

#include <sys/buf.h>
#include <sys/queue.h>
#include <sys/rwlock.h>
#include <sys/task.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#define DEVNAME(_s)     ((_s)->sc_dev.dv_xname)

/* #define SR_DEBUG */
#ifdef SR_DEBUG
extern u_int32_t		sr_debug;
#define DPRINTF(x...)		do { if (sr_debug) printf(x); } while(0)
#define DNPRINTF(n,x...)	do { if (sr_debug & n) printf(x); } while(0)
#define	SR_D_CMD		0x0001
#define	SR_D_INTR		0x0002
#define	SR_D_MISC		0x0004
#define	SR_D_IOCTL		0x0008
#define	SR_D_CCB		0x0010
#define	SR_D_WU			0x0020
#define	SR_D_META		0x0040
#define	SR_D_DIS		0x0080
#define	SR_D_STATE		0x0100
#define	SR_D_REBUILD		0x0200
#else
#define DPRINTF(x...)
#define DNPRINTF(n,x...)
#endif

#define	SR_MAXFER		MAXPHYS
#define	SR_MAX_LD		256
#define	SR_MAX_CMDS		16
#define	SR_MAX_STATES		7
#define SR_VM_IGNORE_DIRTY	1
#define SR_REBUILD_IO_SIZE	128 /* blocks */

extern struct sr_uuid	sr_bootuuid;
extern u_int8_t		sr_bootkey[SR_CRYPTO_MAXKEYBYTES];

/* forward define to prevent dependency goo */
struct sr_softc;

struct sr_ccb {
	struct buf		ccb_buf;	/* MUST BE FIRST!! */

	struct sr_workunit	*ccb_wu;
	struct sr_discipline	*ccb_dis;

	int			ccb_target;
	int			ccb_state;
#define SR_CCB_FREE		0
#define SR_CCB_INPROGRESS	1
#define SR_CCB_OK		2
#define SR_CCB_FAILED		3

	int			ccb_flags;
#define SR_CCBF_FREEBUF		(1<<0)		/* free ccb_buf.b_data */

	void			*ccb_opaque; /* discipline usable pointer */

	TAILQ_ENTRY(sr_ccb)	ccb_link;
};

TAILQ_HEAD(sr_ccb_list, sr_ccb);

struct sr_workunit {
	struct scsi_xfer	*swu_xs;
	struct sr_discipline	*swu_dis;

	int			swu_state;
#define SR_WU_FREE		0
#define SR_WU_INPROGRESS	1
#define SR_WU_OK		2
#define SR_WU_FAILED		3
#define SR_WU_PARTIALLYFAILED	4
#define SR_WU_DEFERRED		5
#define SR_WU_PENDING		6
#define SR_WU_RESTART		7
#define SR_WU_REQUEUE		8
#define SR_WU_CONSTRUCT		9

	int			swu_flags;	/* additional hints */
#define SR_WUF_REBUILD		(1<<0)		/* rebuild io */
#define SR_WUF_REBUILDIOCOMP	(1<<1)		/* rebuild io complete */
#define SR_WUF_FAIL		(1<<2)		/* RAID6: failure */
#define SR_WUF_FAILIOCOMP	(1<<3)
#define SR_WUF_WAKEUP		(1<<4)		/* Wakeup on I/O completion. */
#define SR_WUF_DISCIPLINE	(1<<5)		/* Discipline specific I/O. */
#define SR_WUF_FAKE		(1<<6)		/* Faked workunit. */

	/* workunit io range */
	daddr_t			swu_blk_start;
	daddr_t			swu_blk_end;

	/* number of ios that makes up the whole work unit */
	u_int32_t		swu_io_count;

	/* in flight totals */
	u_int32_t		swu_ios_complete;
	u_int32_t		swu_ios_failed;
	u_int32_t		swu_ios_succeeded;

	/* colliding wu */
	struct sr_workunit	*swu_collider;

	/* all ios that make up this workunit */
	struct sr_ccb_list	swu_ccb;

	/* task memory */
	struct task		swu_task;
	int			swu_cb_active;	/* in callback */

	TAILQ_ENTRY(sr_workunit) swu_link;	/* Link in processing queue. */
	TAILQ_ENTRY(sr_workunit) swu_next;	/* Next work unit in chain. */
};

TAILQ_HEAD(sr_wu_list, sr_workunit);

/* RAID 0 */
#define SR_RAID0_NOWU		16
struct sr_raid0 {
	int32_t			sr0_strip_bits;
};

/* RAID 1 */
#define SR_RAID1_NOWU		16
struct sr_raid1 {
	u_int32_t		sr1_counter;
};

/* RAID 5 */
#define SR_RAID5_NOWU		16
struct sr_raid5 {
	int32_t			sr5_strip_bits;
};

/* RAID 6 */
#define SR_RAID6_NOWU		16
struct sr_raid6 {
	int32_t			sr6_strip_bits;
};

/* CRYPTO */
TAILQ_HEAD(sr_crypto_wu_head, sr_crypto_wu);
#define SR_CRYPTO_NOWU		16

struct sr_crypto {
	struct sr_meta_crypto	*scr_meta;
	struct sr_chunk		*key_disk;

	int			scr_alg;
	int			scr_klen;

	/* XXX only keep scr_sid over time */
	u_int8_t		scr_key[SR_CRYPTO_MAXKEYS][SR_CRYPTO_KEYBYTES];
	u_int8_t		scr_maskkey[SR_CRYPTO_MAXKEYBYTES];
	u_int64_t		scr_sid[SR_CRYPTO_MAXKEYS];
};

#define SR_CONCAT_NOWU		16
struct sr_concat {
};

struct sr_chunk {
	struct sr_meta_chunk	src_meta;	/* chunk meta data */

	/* runtime data */
	dev_t			src_dev_mm;	/* major/minor */
	struct vnode		*src_vn;	/* vnode */

	/* helper members before metadata makes it onto the chunk  */
	int			src_meta_ondisk;/* set when meta is on disk */
	char			src_devname[32];
	u_char			src_duid[8];	/* Chunk disklabel UID. */
	int64_t			src_size;	/* in blocks */
	u_int32_t		src_secsize;

	SLIST_ENTRY(sr_chunk)	src_link;
};

SLIST_HEAD(sr_chunk_head, sr_chunk);

struct sr_volume {
	/* runtime data */
	struct sr_chunk_head	sv_chunk_list;	/* linked list of all chunks */
	struct sr_chunk		**sv_chunks;	/* array to same chunks */
	int64_t			sv_chunk_minsz; /* Size of smallest chunk. */
	int64_t			sv_chunk_maxsz; /* Size of largest chunk. */

	/* sensors */
	struct ksensor		sv_sensor;
	int			sv_sensor_attached;
};

struct sr_discipline {
	struct sr_softc		*sd_sc;		/* link back to sr softc */
	u_int8_t		sd_type;	/* type of discipline */
#define	SR_MD_RAID0		0
#define	SR_MD_RAID1		1
#define	SR_MD_RAID5		2
#define	SR_MD_CACHE		3
#define	SR_MD_CRYPTO		4
	/* AOE was 5 and 6. */
	/* SR_MD_RAID4 was 7. */
#define	SR_MD_RAID6		8
#define	SR_MD_CONCAT		9
	char			sd_name[10];	/* human readable dis name */
	u_int16_t		sd_target;	/* scsibus target discipline uses */

	u_int32_t		sd_capabilities;
#define SR_CAP_SYSTEM_DISK	0x00000001	/* Attaches as a system disk. */
#define SR_CAP_AUTO_ASSEMBLE	0x00000002	/* Can auto assemble. */
#define SR_CAP_REBUILD		0x00000004	/* Supports rebuild. */
#define SR_CAP_NON_COERCED	0x00000008	/* Uses non-coerced size. */
#define SR_CAP_REDUNDANT	0x00000010	/* Redundant copies of data. */

	union {
	    struct sr_raid0	mdd_raid0;
	    struct sr_raid1	mdd_raid1;
	    struct sr_raid5	mdd_raid5;
	    struct sr_raid6	mdd_raid6;
	    struct sr_concat	mdd_concat;
#ifdef CRYPTO
	    struct sr_crypto	mdd_crypto;
#endif /* CRYPTO */
	}			sd_dis_specific;/* dis specific members */
#define mds			sd_dis_specific

	struct taskq		*sd_taskq;

	/* discipline metadata */
	struct sr_metadata	*sd_meta;	/* in memory copy of metadata */
	void			*sd_meta_foreign; /* non native metadata */
	u_int32_t		sd_meta_flags;
	int			sd_meta_type;	/* metadata functions */
	struct sr_meta_opt_head sd_meta_opt; /* optional metadata. */

	int			sd_sync;
	int			sd_must_flush;

	int			sd_deleted;

	struct device		*sd_scsibus_dev;

	/* discipline volume */
	struct sr_volume	sd_vol;		/* volume associated */
	int			sd_vol_status;	/* runtime vol status */
	/* discipline resources */
	struct sr_ccb		*sd_ccb;
	struct sr_ccb_list	sd_ccb_freeq;
	u_int32_t		sd_max_ccb_per_wu;

	struct sr_wu_list	sd_wu;		/* all workunits */
	u_int32_t		sd_max_wu;
	int			sd_reb_active;	/* rebuild in progress */
	int			sd_reb_abort;	/* abort rebuild */
	int			sd_ready;	/* fully operational */

	struct sr_wu_list	sd_wu_freeq;	/* free wu queue */
	struct sr_wu_list	sd_wu_pendq;	/* pending wu queue */
	struct sr_wu_list	sd_wu_defq;	/* deferred wu queue */

	struct mutex		sd_wu_mtx;
	struct scsi_iopool	sd_iopool;

	/* discipline stats */
	int			sd_wu_pending;
	u_int64_t		sd_wu_collisions;

	/* discipline functions */
	int			(*sd_create)(struct sr_discipline *,
				    struct bioc_createraid *, int, int64_t);
	int			(*sd_assemble)(struct sr_discipline *,
				    struct bioc_createraid *, int, void *);
	int			(*sd_alloc_resources)(struct sr_discipline *);
	void			(*sd_free_resources)(struct sr_discipline *);
	int			(*sd_ioctl_handler)(struct sr_discipline *,
				    struct bioc_discipline *);
	int			(*sd_start_discipline)(struct sr_discipline *);
	void			(*sd_set_chunk_state)(struct sr_discipline *,
				    int, int);
	void			(*sd_set_vol_state)(struct sr_discipline *);
	int			(*sd_openings)(struct sr_discipline *);
	int			(*sd_meta_opt_handler)(struct sr_discipline *,
				    struct sr_meta_opt_hdr *);
	void			(*sd_rebuild)(struct sr_discipline *);

	/* SCSI emulation */
	struct scsi_sense_data	sd_scsi_sense;
	int			(*sd_scsi_rw)(struct sr_workunit *);
	void			(*sd_scsi_intr)(struct buf *);
	int			(*sd_scsi_wu_done)(struct sr_workunit *);
	void			(*sd_scsi_done)(struct sr_workunit *);
	int			(*sd_scsi_sync)(struct sr_workunit *);
	int			(*sd_scsi_tur)(struct sr_workunit *);
	int			(*sd_scsi_start_stop)(struct sr_workunit *);
	int			(*sd_scsi_inquiry)(struct sr_workunit *);
	int			(*sd_scsi_read_cap)(struct sr_workunit *);
	int			(*sd_scsi_req_sense)(struct sr_workunit *);

	/* background operation */
	struct proc		*sd_background_proc;

	/* Tasks. */
	struct task		sd_meta_save_task;
	struct task		sd_hotspare_rebuild_task;

	TAILQ_ENTRY(sr_discipline) sd_link;
};

TAILQ_HEAD(sr_discipline_list, sr_discipline);

struct sr_softc {
	struct device		sc_dev;

	struct rwlock		sc_lock;

	struct bio_status	sc_status;	/* Status and messages. */

	struct sr_chunk_head	sc_hotspare_list;	/* List of hotspares. */
	struct rwlock		sc_hs_lock;	/* Lock for hotspares list. */
	int			sc_hotspare_no; /* Number of hotspares. */

	struct ksensordev	sc_sensordev;
	struct sensor_task	*sc_sensor_task;

	struct scsi_link	sc_link;	/* scsi prototype link */
	struct scsibus_softc	*sc_scsibus;

	/* The target lookup has to be cheap since it happens for each I/O. */
	struct sr_discipline	*sc_targets[SR_MAX_LD];
	struct sr_discipline_list sc_dis_list;
};

/* hotplug */
void			sr_hotplug_register(struct sr_discipline *, void *);
void			sr_hotplug_unregister(struct sr_discipline *, void *);

/* Hotspare and rebuild. */
void			sr_hotspare_rebuild_callback(void *);

/* work units & ccbs */
int			sr_ccb_alloc(struct sr_discipline *);
void			sr_ccb_free(struct sr_discipline *);
struct sr_ccb		*sr_ccb_get(struct sr_discipline *);
void			sr_ccb_put(struct sr_ccb *);
struct sr_ccb		*sr_ccb_rw(struct sr_discipline *, int, daddr_t,
			    long, u_int8_t *, int, int);
void			sr_ccb_done(struct sr_ccb *);
int			sr_wu_alloc(struct sr_discipline *, int);
void			sr_wu_free(struct sr_discipline *);
void			*sr_wu_get(void *);
void			sr_wu_put(void *, void *);
void			sr_wu_init(struct sr_discipline *,
			    struct sr_workunit *);
void			sr_wu_enqueue_ccb(struct sr_workunit *,
			    struct sr_ccb *);
void			sr_wu_release_ccbs(struct sr_workunit *);
void			sr_wu_done(struct sr_workunit *);

/* misc functions */
void			sr_info(struct sr_softc *, const char *, ...);
void			sr_warn(struct sr_softc *, const char *, ...);
void			sr_error(struct sr_softc *, const char *, ...);
int32_t			sr_validate_stripsize(u_int32_t);
int			sr_meta_read(struct sr_discipline *);
int			sr_meta_native_read(struct sr_discipline *, dev_t,
			    struct sr_metadata *, void *);
int			sr_meta_validate(struct sr_discipline *, dev_t,
			    struct sr_metadata *, void *);
void			sr_meta_save_callback(void *);
int			sr_meta_save(struct sr_discipline *, u_int32_t);
void			sr_meta_getdevname(struct sr_softc *, dev_t, char *,
			    int);
void			sr_meta_opt_load(struct sr_softc *,
			    struct sr_metadata *, struct sr_meta_opt_head *);
void			*sr_block_get(struct sr_discipline *, long);
void			sr_block_put(struct sr_discipline *, void *, int);
void			sr_checksum(struct sr_softc *, void *, void *,
			    u_int32_t);
int			sr_validate_io(struct sr_workunit *, daddr_t *,
			    char *);
void			sr_schedule_wu(struct sr_workunit *);
void			sr_scsi_done(struct sr_discipline *,
			    struct scsi_xfer *);
struct sr_workunit	*sr_scsi_wu_get(struct sr_discipline *, int);
void			sr_scsi_wu_put(struct sr_discipline *,
			    struct sr_workunit *);
int			sr_chunk_in_use(struct sr_softc *, dev_t);
int			sr_rebuild_percent(struct sr_discipline *);

/* discipline functions */
int			sr_raid_inquiry(struct sr_workunit *);
int			sr_raid_read_cap(struct sr_workunit *);
int			sr_raid_tur(struct sr_workunit *);
int			sr_raid_request_sense( struct sr_workunit *);
int			sr_raid_start_stop(struct sr_workunit *);
int			sr_raid_sync(struct sr_workunit *);
void			sr_raid_intr(struct buf *);
void			sr_raid_startwu(struct sr_workunit *);
void			sr_raid_recreate_wu(struct sr_workunit *);

/* Discipline specific initialisation. */
void			sr_raid0_discipline_init(struct sr_discipline *);
void			sr_raid1_discipline_init(struct sr_discipline *);
void			sr_raid5_discipline_init(struct sr_discipline *);
void			sr_raid6_discipline_init(struct sr_discipline *);
void			sr_crypto_discipline_init(struct sr_discipline *);
void			sr_concat_discipline_init(struct sr_discipline *);

/* Crypto discipline hooks. */
int			sr_crypto_get_kdf(struct bioc_createraid *,
			    struct sr_discipline *);
int			sr_crypto_create_keys(struct sr_discipline *);
struct sr_chunk *	sr_crypto_create_key_disk(struct sr_discipline *, dev_t);
struct sr_chunk *	sr_crypto_read_key_disk(struct sr_discipline *, dev_t);

/* Hibernate I/O function */
int			sr_hibernate_io(dev_t dev, daddr_t blkno, vaddr_t addr,
			    size_t size, int op, void *page);

#ifdef SR_DEBUG
void			sr_dump_block(void *, int);
void			sr_dump_mem(u_int8_t *, int);
#endif

#endif /* _KERNEL */

#endif /* SOFTRAIDVAR_H */
@


1.165
log
@Ugh, too many initialisms...
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.164 2016/09/10 16:53:22 jsing Exp $ */
d274 1
@


1.164
log
@Clean up some softraid crypto code - rename struct sr_crypto_kdf_pbkdf2 to
sr_crypto_pbkdf (since it is useable for more than just pkcs5_pbkdf2) and
embed a struct sr_crypto_genkdf within it, rather than redeclaring the same
fields. Rename SR_CRYPTOKDFT_PBKDF2 to SR_CRYPTOKDFT_PCKS5_PBKDF2 and add
SR_CRYPTOKDFT_BCRYPT_PBKDF for upcoming changes.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.163 2016/05/31 15:19:12 jsing Exp $ */
d49 1
a49 1
#define SR_CRYPTOKDFT_PCKS5_PBKDF2	1
@


1.163
log
@Provide a function for calculting the rebuild percentage, rather than
having five copies of the same code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.162 2016/04/04 18:48:39 krw Exp $ */
d48 4
a51 3
#define SR_CRYPTOKDFT_INVALID	0
#define SR_CRYPTOKDFT_PBKDF2	1
#define SR_CRYPTOKDFT_KEYDISK	2
d55 2
a56 2
 * sr_crypto_genkdf_pbkdf2 is a hint for the PKCS#5 KDF performed in userland
 * and is not interpreted by the kernel.
d58 2
a59 3
struct sr_crypto_kdf_pbkdf2 {
	u_int32_t	len;
	u_int32_t	type;
d76 2
a77 2
		struct sr_crypto_genkdf		generic;
		struct sr_crypto_kdf_pbkdf2	pbkdf2;
d80 1
a80 1
#define pbkdf2		_kdfhint.pbkdf2
d87 1
a87 1
	void		*kdfinfo1;
d89 1
a89 1
	void		*kdfinfo2;
@


1.162
log
@Enable creation of softraid volumes using disks with non-512 byte
sectors. Volumes created will present a sector size equal to the
largest sector size of the constituent disks.

Softraid Metadata version cranks to 6 due to new field.

ok jsing@@ with tweaks that will follow soon.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.161 2015/07/21 03:30:51 krw Exp $ */
d690 1
@


1.161
log
@A few more daddr_t fixes. Rename 'phys_off' variables to 'offset'
since they are now relative to chunks. Use 'blkno' as normal variable
name for daddr_t items rather than mix of 'blkno, blk, offset.
Change field name ssd_data_offset to ssd_data_blkno since it is a
block and not byte quantity.

No intentional functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.160 2015/07/19 18:24:16 krw Exp $ */
d22 1
a22 1
#define SR_META_VERSION		5	/* bump when sr_metadata changes */
d138 1
a138 1
		u_int32_t	ssd_pad;
d476 1
@


1.160
log
@Stop passing daddr_t parameters for lengths. Use long since that's the type
of the destination fields.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.159 2015/01/27 03:17:36 dlg Exp $ */
d156 1
a156 1
	u_int32_t		ssd_data_offset;
d274 1
a274 1
	u_int32_t	sbv_data_offset;	/* Data offset. */
@


1.159
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.158 2014/10/07 20:23:32 tedu Exp $ */
d647 1
a647 1
			    daddr_t, u_int8_t *, int, int);
d676 1
a676 1
void			*sr_block_get(struct sr_discipline *, int);
@


1.158
log
@remove preliminary AOE (ata over ethernet) support. not finished after
many years and wide spread demand for support never materialized.
time to pack it in.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.157 2014/07/20 18:05:21 mlarkin Exp $ */
d639 1
a639 1
void			sr_hotspare_rebuild_callback(void *, void *);
d670 1
a670 1
void			sr_meta_save_callback(void *, void *);
@


1.157
log
@
Support hibernating to softraid crypto volumes.

much help and ok from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.156 2014/07/12 07:39:11 blambert Exp $ */
a459 11
#ifdef AOE
/* ata over ethernet */
#define SR_RAIDAOE_NOWU		2
struct sr_aoe {
	struct aoe_handler	*sra_ah;
	int			sra_tag;
	struct ifnet		*sra_ifp;
	struct ether_addr	sra_eaddr;
};
#endif /* AOE */

d502 1
a502 2
#define	SR_MD_AOE_INIT		5
#define	SR_MD_AOE_TARG		6
a524 3
#ifdef AOE
	    struct sr_aoe	mdd_aoe;
#endif /* AOE */
a707 2
void			sr_aoe_discipline_init(struct sr_discipline *);
void			sr_aoe_server_discipline_init(struct sr_discipline *);
@


1.156
log
@essentially mechanical conversion of softraid rebuild from
workq to taskq

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.155 2014/07/10 12:21:09 mpi Exp $ */
d732 4
@


1.155
log
@Stop using a shutdown hook for softraid(4) and explicitly shutdown
the disciplines right after vfs_shutdown().

This change is required in order to be able to set `cold' to 1 before
traversing the device (mainbus) tree for DVACT_POWERDOWN when halting
a machine.  Yes, this is ugly because sr_shutdown() needs to sleep.  But
at least it is obvious and hopefully somebody will be ofended and fix
it.

In order to properly flush the cache of the disks under softraid0,
sr_shutdown() now propagates DVACT_POWERDOWN for this particular subtree
of devices which are not under mainbus.  As a side effect sd(4) shutdown
hook should no longer be necessary.

Tested by stsp@@ and Jean-Philippe Ouellet.

ok deraadt@@, stsp@@, jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.154 2014/01/22 09:42:13 jsing Exp $ */
d620 1
@


1.154
log
@Add a debug flag for rebuild.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.153 2014/01/22 09:03:19 jsing Exp $ */
a627 2

	void			(*sc_shutdownhook)(void *);
@


1.153
log
@Make rebuild a discipline specific function pointer. For now, this defaults
to the existing rebuild code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.152 2014/01/22 05:11:36 jsing Exp $ */
d324 1
@


1.152
log
@Move sr_dump from the RAID5 code into shared code. Rename it to
sr_dump_block and place it under the debug define in the process.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.151 2014/01/22 04:24:29 jsing Exp $ */
d599 1
@


1.151
log
@Switch metadata saves from the system workq to the system taskq.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.150 2014/01/21 05:11:12 jsing Exp $ */
d733 1
@


1.150
log
@Instead of maintaining a completely separate list of crypto work units,
simply allocate larger work units and include the normal work unit struct
in the top of the crypto work unit struct.

This greatly simplifies the code and removes possible failure cases.

Discussed with dlg@@

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.149 2014/01/21 04:23:14 jsing Exp $ */
d615 3
@


1.149
log
@Allow for variable sized work units.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.148 2014/01/21 03:50:44 jsing Exp $ */
a446 2
	struct mutex		 scr_mutex;
	struct sr_crypto_wu_head scr_wus;
@


1.148
log
@Use a TAILQ for tracking work units, rather than an array. This will allow
for variable size work units. While here, remove some pointless checks.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.147 2014/01/20 04:47:31 jsing Exp $ */
d662 1
a662 1
int			sr_wu_alloc(struct sr_discipline *);
@


1.147
log
@Convert the softraid work unit workqs to taskqs.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.146 2014/01/20 04:38:59 jsing Exp $ */
d394 3
a401 3
	/* number of ios that makes up the whole work unit */
	u_int32_t		swu_io_count;

d412 2
a413 1
	TAILQ_ENTRY(sr_workunit) swu_link;
d568 1
a568 1
	struct sr_workunit	*sd_wu;		/* all workunits */
@


1.146
log
@Store the algorithm and key length in the discipline data structure,
instead of having multiple switch statements in various places.

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.145 2014/01/20 00:11:50 jsing Exp $ */
d302 1
d409 1
a409 2
	struct workq_task	swu_wqt;
	struct workq_task	swu_intr;
d543 1
a543 1
	struct workq		*sd_workq;
@


1.145
log
@Replace dedicated swu_fake variable with a work unit flag.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.144 2014/01/18 09:33:53 jsing Exp $ */
d450 3
@


1.144
log
@Move the block get/put routines into the common code, instead of having
RAID 6 borrow them from RAID 5.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.143 2014/01/18 09:23:26 jsing Exp $ */
d387 1
a388 1
	int			swu_fake;	/* faked wu */
@


1.143
log
@Rename softraid RAIDP to softraid RAID5.

Discussed with krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.142 2014/01/18 09:01:01 jsing Exp $ */
d685 2
@


1.142
log
@Remove the RAID 4 discipline from softraid. Anyone sensible would use RAID
5 instead of RAID 4, assuming both were functional.

Discussed with krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.141 2014/01/18 08:49:20 jsing Exp $ */
d429 4
a432 4
/* RAID 4 */
#define SR_RAIDP_NOWU		16
struct sr_raidp {
	int32_t			srp_strip_bits;
d528 1
a528 1
	    struct sr_raidp	mdd_raidp;
d711 1
a711 2
void			sr_raidp_discipline_init(struct sr_discipline *,
			    u_int8_t);
@


1.141
log
@Improve comments re KDF hints.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.140 2013/11/04 21:02:57 deraadt Exp $ */
d512 1
a512 1
#define	SR_MD_RAID4		7
@


1.140
log
@substantial namespace cleanup.  Might go a little bit too far, but we
can expose some of the kernel structures with split .h files if need be.
Discussed with various, including jsing.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.139 2013/06/11 16:42:13 deraadt Exp $ */
d41 4
a44 1
/* this is a generic hint for KDF done in userland, not interpreted by the kernel. */
d53 4
a56 1
/* this is a hint for KDF using PKCS#5.  Not interpreted by the kernel */
d65 2
a66 2
 * this structure is used to copy masking keys and KDF hints from/to userland.
 * the embedded hint structures are not interpreted by the kernel.
@


1.139
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.138 2013/05/21 15:01:54 jsing Exp $ */
d22 18
a39 2
#include <sys/socket.h>
#include <sys/vnode.h>
d41 47
a87 3
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
a90 4
#define SR_META_VERSION		5	/* bump when sr_metadata changes */
#define SR_META_SIZE		64	/* save space at chunk beginning */
#define SR_META_OFFSET		16	/* skip 8192 bytes at chunk beginning */

a97 7
#define SR_BOOT_OFFSET		(SR_META_OFFSET + SR_META_SIZE)
#define SR_BOOT_LOADER_SIZE	320	/* Size of boot loader storage. */
#define SR_BOOT_LOADER_OFFSET	SR_BOOT_OFFSET
#define SR_BOOT_BLOCKS_SIZE	128	/* Size of boot block storage. */
#define SR_BOOT_BLOCKS_OFFSET	(SR_BOOT_LOADER_OFFSET + SR_BOOT_LOADER_SIZE)
#define SR_BOOT_SIZE		(SR_BOOT_LOADER_SIZE + SR_BOOT_BLOCKS_SIZE)

a169 8
#define SR_CRYPTO_MAXKEYBYTES	32	/* max bytes in a key (AES-XTS-256) */
#define SR_CRYPTO_MAXKEYS	32	/* max keys per volume */
#define SR_CRYPTO_KEYBITS	512	/* AES-XTS with 2 * 256 bit keys */
#define SR_CRYPTO_KEYBYTES	(SR_CRYPTO_KEYBITS >> 3)
#define SR_CRYPTO_KDFHINTBYTES	256	/* size of opaque KDF hint */
#define SR_CRYPTO_CHECKBYTES	64	/* size of generic key chksum struct */
#define SR_CRYPTO_KEY_BLKSHIFT	30	/* 0.5TB per key */

a242 53
/* this is a generic hint for KDF done in userland, not interpreted by the kernel. */
struct sr_crypto_genkdf {
	u_int32_t	len;
	u_int32_t	type;
#define SR_CRYPTOKDFT_INVALID	0
#define SR_CRYPTOKDFT_PBKDF2	1
#define SR_CRYPTOKDFT_KEYDISK	2
};

/* this is a hint for KDF using PKCS#5.  Not interpreted by the kernel */
struct sr_crypto_kdf_pbkdf2 {
	u_int32_t	len;
	u_int32_t	type;
	u_int32_t	rounds;
	u_int8_t	salt[128];
};

/*
 * this structure is used to copy masking keys and KDF hints from/to userland.
 * the embedded hint structures are not interpreted by the kernel.
 */
struct sr_crypto_kdfinfo {
	u_int32_t	len;
	u_int32_t	flags;
#define SR_CRYPTOKDF_INVALID	(0)
#define SR_CRYPTOKDF_KEY	(1<<0)
#define SR_CRYPTOKDF_HINT	(1<<1)
	u_int8_t	maskkey[SR_CRYPTO_MAXKEYBYTES];
	union {
		struct sr_crypto_genkdf		generic;
		struct sr_crypto_kdf_pbkdf2	pbkdf2;
	}		_kdfhint;
#define genkdf		_kdfhint.generic
#define pbkdf2		_kdfhint.pbkdf2
};

#define SR_IOCTL_GET_KDFHINT		0x01	/* Get KDF hint. */
#define SR_IOCTL_CHANGE_PASSPHRASE	0x02	/* Change passphase. */

struct sr_crypto_kdfpair {
	void		*kdfinfo1;
	u_int32_t	kdfsize1;
	void		*kdfinfo2;
	u_int32_t	kdfsize2;
};

struct sr_aoe_config {
	char		nic[IFNAMSIZ];
	struct ether_addr dsteaddr;
	unsigned short	shelf;
	unsigned char	slot;
};

d287 2
d290 1
a293 1
#include <sys/pool.h>
d451 1
d460 1
@


1.138
log
@Provide a function that handles the scheduling of work units. This
simplifies the discipline code, avoids code duplication and moves the
scheduling logic into a single location.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.136 2013/04/26 15:45:35 jsing Exp $ */
d394 2
a395 2
	daddr64_t		swu_blk_start;
	daddr64_t		swu_blk_end;
d657 2
a658 2
struct sr_ccb		*sr_ccb_rw(struct sr_discipline *, int, daddr64_t,
			    daddr64_t, u_int8_t *, int, int);
d689 1
a689 1
int			sr_validate_io(struct sr_workunit *, daddr64_t *,
@


1.137
log
@Use a state to indicate that a work unit should only be constructed and not
scheduled, rather than trying to imply this from the rebuild flag.
@
text
@d691 1
a691 1
int			sr_check_io_collision(struct sr_workunit *);
@


1.136
log
@Add a SR_WUF_DISCIPLINE flag that identifies work units that have resulted
from discipline specific I/O. Such work units are not associated with a
SCSI xfer and are returned via sr_wu_put() on completion.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.135 2013/04/23 12:49:52 jsing Exp $ */
d382 1
@


1.135
log
@Rename ccb_flag to ccb_flags.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.134 2013/04/21 13:00:21 jsing Exp $ */
d389 1
@


1.134
log
@Convert RAID1 to the new work unit completion functions and generic
interrupt handler. Disciplines such as RAID1/4/5/6 need a way to intercept
I/O when the work unit is complete, but before the SCSI xfer is complete.
This is provided via a sd_scsi_wu_done hook, which enables work units to be
restarted or otherwise modified before the SCSI xfer completion occurs.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.133 2013/03/31 11:37:40 jsing Exp $ */
d358 1
a358 1
	int			ccb_flag;
@


1.133
log
@The return value of sd_free_resources() is never checked and all of the
implementations only ever returned zero. Change the return value from
int to void instead of pretending it might mean something.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.132 2013/03/30 14:41:36 jsing Exp $ */
d602 1
@


1.132
log
@Provide wrappers for scsi_io_get() and scsi_io_put(), that also include
the sd_sync check/wakeup. Remove some unnecessary NULL checks whilst here.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.131 2013/03/30 02:02:14 jsing Exp $ */
d587 1
a587 1
	int			(*sd_free_resources)(struct sr_discipline *);
@


1.131
log
@Provide a default discipline interrupt handling function and migrate all of
the disciplines that now have the same interrupt code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.130 2013/03/29 12:00:59 jsing Exp $ */
d691 3
@


1.130
log
@Decouple wakeups on work unit completion from the type of I/O being
performed.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.129 2013/03/25 16:01:49 jsing Exp $ */
d700 1
@


1.129
log
@Factor out the code that is used to recreate work units - one copy of the
code is sufficient.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.128 2013/03/10 09:05:12 jsing Exp $ */
d385 1
a385 1
#define SR_WUF_REBUILDIOCOMP	(1<<1)		/* rbuild io complete */
d388 1
@


1.128
log
@Rename sc_dis to sc_targets, since it is an array of targets that also
happen to be softraid disciplines.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.127 2013/03/05 10:24:00 jsing Exp $ */
d700 1
@


1.127
log
@Track attached softraid disciplines via a queue. This prevents the need to
scan the sparse SCSI targets array and simplifies code. Disciplines are
now also shutdown in reverse attach order, making manually stacked softraid
volumes somewhat more practical.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.126 2013/01/18 09:39:03 jsing Exp $ */
d637 1
a637 1
	struct sr_discipline	*sc_dis[SR_MAX_LD];
@


1.126
log
@Implement common workunit completion functions and handle the completion
via a workq callback. Also provide a discipline specific hook that allows
it to optionally handle the final part of the workunit completion.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.125 2013/01/16 07:07:38 jsing Exp $ */
d611 2
d615 2
d636 1
a636 4
	/*
	 * XXX expensive, alternative would be nice but has to be cheap
	 * since the target lookup happens on each IO
	 */
d638 1
@


1.125
log
@Add a function that handles the completion of a ccb.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.124 2013/01/16 07:06:29 jsing Exp $ */
d601 1
d663 1
@


1.124
log
@Add a new capability flag to identify disciplines where read failures are
not necessarily terminal (i.e. we have redundancy).

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.123 2013/01/16 06:29:14 jsing Exp $ */
d652 1
@


1.123
log
@Factor out code used to release ccbs from a workunit.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.122 2013/01/15 09:51:22 jsing Exp $ */
d522 1
@


1.122
log
@Implement a function that gets and correctly initialises a ccb for I/O,
along with a function that enqueues a ccb on a workunit.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.121 2013/01/15 04:03:01 jsing Exp $ */
d657 1
a657 1
void			sr_wu_ccb_enqueue(struct sr_workunit *,
d659 1
@


1.121
log
@Keep a function pointer to the per-discipline I/O interrupt handler in the
discipline data structure. To be used with an upcoming diff.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.120 2013/01/15 03:47:10 jsing Exp $ */
d649 2
d657 2
@


1.120
log
@Factor out workunit initialisation code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.119 2012/10/09 13:55:36 jsing Exp $ */
d599 1
@


1.119
log
@Teach amd64 boot(8) how to access a softraid crypto volume. This allows for
full disk encryption since the kernel can now be loaded directly from the
crypto volume, instead of needing to be on FFS.

This is currently disabled by default, however can be enabled by compiling
with boot(8) 'make -DBOOT_CRYPTO'.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.118 2012/10/09 11:57:33 jsing Exp $ */
d652 2
@


1.118
log
@Provide a mechanism for the kernel to directly pass a mask key through to
a crypto volume when it is assembling it.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.117 2012/10/08 14:22:41 jsing Exp $ */
d288 3
d292 1
@


1.117
log
@Provide a mechanism for the kernel to pass data through to the discipline
during volume assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.115 2012/01/20 14:43:05 jsing Exp $ */
d257 1
a257 1
	dev_t		sbc_mm;			
d334 3
@


1.116
log
@Only pass bio ioctls through to the softraid bio ioctl handler. Rename the
handler to emphasise that it is for bio ioctls only.

Discovered the hard way by dhill@@
@
text
@d576 1
a576 1
				    struct bioc_createraid *, int);
@


1.115
log
@Add bio(4) status interface structs and utility functions to softraid(4).
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.112 2011/12/28 16:19:52 jsing Exp $ */
a605 1
	int			(*sc_ioctl)(struct device *, u_long, caddr_t);
@


1.114
log
@Make sr_boot_chunk and sr_boot_volume accessible from userland. Add a
number of variables that are needed to detect and assemble volumes. A
sr_metadata struct can be allocated and used via the sbc_metadata
pointer, which we now do in the kernel boot probe/assembly code.
@
text
@d611 2
a613 1
	struct sr_chunk		**sc_hotspares;	/* Array to hotspare chunks. */
d648 3
@


1.113
log
@Implement a concatenating discipline for softraid.

Many thanks to Marco Peereboom for his assistance with testing and
debugging. Thanks also to Josh Grosse and Chris Jackman for testing.
@
text
@d255 39
a462 25

struct sr_boot_chunk {
	struct sr_metadata	sbc_metadata;
	dev_t			sbc_mm;
	u_int32_t		sbc_chunk_id;
	int			sbc_used;

	SLIST_ENTRY(sr_boot_chunk) sbc_link;
};

SLIST_HEAD(sr_boot_chunk_head, sr_boot_chunk);

struct sr_boot_volume {
	struct sr_uuid		sbv_uuid;	/* Volume UUID. */
	u_int32_t		sbv_level;	/* Level. */
	u_int32_t		sbv_volid;	/* Volume ID. */
	u_int32_t		sbv_chunk_no;	/* Number of chunks. */
	u_int32_t		sbv_dev_no;	/* Number of devs discovered. */

	struct sr_boot_chunk_head sbv_chunks;	/* List of chunks. */

	SLIST_ENTRY(sr_boot_volume)	sbv_link;
};

SLIST_HEAD(sr_boot_volume_head, sr_boot_volume);
@


1.112
log
@Cleanup the metadata initialisation process - have sr_meta_init()
initialise both the volume and chunk metadata before the discipline
specific sd_create() function is called. The sr_meta_init_complete()
function is then called to complete the initialisation based on values
provided by sd_create().
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.109 2011/09/19 21:39:31 jsing Exp $ */
d421 4
d492 1
d497 4
a500 3
#define SR_CAP_SYSTEM_DISK	0x00000001
#define SR_CAP_AUTO_ASSEMBLE	0x00000002
#define SR_CAP_REBUILD		0x00000004
d507 2
d510 1
d670 1
@


1.111
log
@Provide default set chunk state and set volume state functions which
cover the no redundancy/no rebuild case. Use these for the AOE, crypto and
RAID 0 disciplines.
@
text
@d468 2
@


1.110
log
@Remove unused sv_sensor_valid variable.
@
text
@a661 6
/* raid 1 */
/* XXX - currently (ab)used by AOE and CRYPTO. */
void			sr_raid1_set_chunk_state(struct sr_discipline *,
			    int, int);
void			sr_raid1_set_vol_state(struct sr_discipline *);

@


1.109
log
@When installboot is run on a softraid volume, add boot optional metadata
to store the DUID of the softraid volume and each of the chunks that it
is assembled from. This allows us to correctly identify the root disk.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.108 2011/09/18 19:40:49 jsing Exp $ */
a471 1
	int			sv_sensor_valid;
@


1.108
log
@Add support for variable length optional metadata in softraid(4). This
will allow new optional metadata types to be added without needing to
change the softraid metadata version.

Note that this commit changes the softraid metadata version, however
an upgrade from older metadata is handled automatically. A full backup
prior to upgrading is still strongly recommended.

With feedback from stsp@@ and marco.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.107 2011/09/18 13:11:08 jsing Exp $ */
d177 1
a179 1
	u_int64_t		sbm_root_uid;
d182 2
d456 1
@


1.107
log
@Rename the optional metadata handler function and factor out the optional
metadata handling code. This will simplify upcoming changes.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.105 2011/07/07 00:18:06 tedu Exp $ */
d31 1
a31 1
#define SR_META_VERSION		4	/* bump when sr_metadata changes */
d137 11
d149 1
d178 1
d185 1
d189 3
a191 20
struct sr_meta_opt {
	struct sr_meta_opt_invariant {
		u_int32_t	som_type;	/* optional type */
#define SR_OPT_INVALID		0x00
#define SR_OPT_CRYPTO		0x01
#define SR_OPT_BOOT		0x02
#define SR_OPT_KEYDISK		0x03
		u_int32_t	som_pad;
		union {
			struct sr_meta_crypto smm_crypto;
			struct sr_meta_boot smm_boot;
			struct sr_meta_keydisk smm_keydisk;
		}		som_meta;
	} _som_invariant;
#define somi			_som_invariant
#define somi_crypto		_som_invariant.smm_crypto
#define somi_boot		_som_invariant.smm_boot
	/* MD5 of invariant optional metadata */
	u_int8_t		som_checksum[MD5_DIGEST_LENGTH];
} __packed;
d194 1
a194 1
	struct sr_meta_opt	omi_om;
d560 1
a560 1
				    struct sr_meta_opt *);
@


1.106
log
@reorder two fields
@
text
@d562 1
a562 1
	int			(*sd_meta_opt_load)(struct sr_discipline *,
d633 2
@


1.105
log
@allow AOE config to be specified by userland.  ok marco.
use consistent network types as requested and ok deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.104 2011/07/06 17:32:47 jsing Exp $ */
d252 1
a253 1
	unsigned short	shelf;
@


1.104
log
@Use a single shutdown hook for the softraid controller instead of
having one per volume.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.103 2011/07/06 15:44:11 jsing Exp $ */
d22 7
a29 1
#include <sys/vnode.h>
d249 8
d419 1
a419 1
	char			sra_eaddr[6];
@


1.103
log
@Retain a reference to the registered sensor task so that we can unregister
it again.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.101 2011/07/02 17:39:12 jsing Exp $ */
a507 1
	void			(*sd_shutdownhook)(void *);
d569 1
@


1.102
log
@ENOMEM causing EIO errors is bad juju. Softraid crypto did this.

Instead of allocating a crypto op and the optional dma buffer on each
and every io, preallocate a list of softraid crypto wus that contain a
buffer of the max size we will use (MAXPHYS). since we know the number
of openings we have in advance this means that on each io we just pick
one, shorten the list of crypto descs, init any values then do the io.

ok jsing (who provided many useful comments. he also provided a smarter way of
handling the cryptop lists which is not in this diff but will be implemented
soonish), marco@@.

dlg@@ pointed out that this should probably use iopools but letting
disciplines allocate their own iopool involves more softraid rejigging
that will have to be done first. For now this is sufficient.
@
text
@d579 1
a579 1
	int			sc_sensors_running;
@


1.101
log
@Cleanup the softraid boot probe code. Rename the rather poorly named
sr_metadata_list struct to sr_boot_chunk and use a sr_metadata struct
rather than an array of u_int8_t when storing the metadata. Also rename
some variables to keep the boot volume/boot chunk consistency.

This diff also fixes a memory leak where the structures were never freed
for key disks. Otherwise there should be no functional change.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.99 2011/04/05 19:52:02 krw Exp $ */
d384 1
d386 1
d388 2
a391 3

	struct pool		sr_uiopl;
	struct pool		sr_iovpl;
@


1.100
log
@Simplify softraid(4) to behave like other HBAs by using a single
scsibus(4) for all attached disks, rather than one scsibus(4) per
disk.  This takes advantage of recent improvements in the SCSI
midlayer to better support hotplug devices, and also decouples
softraid(4) from scsibus(4) device unit numbers.

ok jsing@@, dlg@@, krw@@, deraadt@@; marco@@'s still unconvinced
@
text
@d407 5
a411 5
struct sr_metadata_list {
	u_int8_t		sml_metadata[SR_META_SIZE * 512];
	dev_t			sml_mm;
	u_int32_t		sml_chunk_id;
	int			sml_used;
d413 1
a413 1
	SLIST_ENTRY(sr_metadata_list) sml_link;
d416 1
a416 1
SLIST_HEAD(sr_metadata_list_head, sr_metadata_list);
d425 1
a425 1
	struct sr_metadata_list_head	sml;	/* List of metadata. */
@


1.99
log
@Iopoolification. Testing by marco@@.

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.98 2011/03/15 13:29:41 jsing Exp $ */
d277 1
a277 1
#define	SR_MAX_LD		1
d473 1
a473 2
	u_int8_t		sd_scsibus;	/* scsibus discipline uses */
	struct scsi_link	sd_link;	/* link to midlayer */
d580 2
a581 5
	/*
	 * during scsibus attach this is the discipline that is in use
	 * this variable is protected by sc_lock and splhigh
	 */
	struct sr_discipline	*sc_attach_dis;
d585 1
a585 1
	 * since the scsibus lookup happens on each IO
d587 1
a587 2
#define SR_MAXSCSIBUS		256
	struct sr_discipline	*sc_dis[SR_MAXSCSIBUS]; /* scsibus is u_int8_t */
@


1.98
log
@Attach one sensordev per softraid device rather than one sensordev per
discipline. This results in a drive sensor being attached for each volume
under the same sensordev, instead of having multiple sensordevs each with
a single drive. Fixes PR6576.

Tested by Mattieu Baptiste.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.96 2010/11/06 23:01:56 marco Exp $ */
d527 3
a529 1
	int			sd_wu_sleep;	/* wu sleepers counter */
d609 2
a610 2
struct sr_workunit	*sr_wu_get(struct sr_discipline *, int);
void			sr_wu_put(struct sr_workunit *);
@


1.97
log
@spaces that make my eyes bleed. no binary change.
@
text
@d456 1
a456 1
	struct ksensordev	sv_sensordev;
d576 1
d578 1
@


1.96
log
@Move raid1 and crypto io to a workq.  This is to avoid a potential VOP_
call while in interrupt context.

Contains an additional spl dance as found by thib.

Tested by many opn various arches.  Note that raid 0/4/5/6 have not been
moved over yet.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.95 2010/08/30 17:32:40 jsing Exp $ */
d58 1
a58 1
	SLIST_ENTRY(sr_disk) 	sdk_link;
d67 1
a67 1
		u_int32_t	ssd_version; 	/* meta data version */
d427 1
a427 1
	SLIST_ENTRY(sr_boot_volume)	sbv_link;	
@


1.95
log
@During boot probe walk disklist rather than alldevs. This avoids a race
where disks can be on alldevs, however they are not yet initialised and
have not yet called disk_attach() (in particular this means that dk_label
is a null pointer). Also, if we sleep restart the scan from the top of
the disklist in case things have changed whilst we slept.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.93 2010/07/02 09:20:26 jsing Exp $ */
d349 5
d492 2
@


1.94
log
@Rename the volume specific flags variable.

ok marco@@
@
text
@d56 6
@


1.93
log
@Determine the data offset using a variable specified within the softraid
metadata. This allows us to implement seamless transitions from the
previous metadata version to the current version, avoiding the need to
recreate the softraid volume.

Joint work with marco@@ during c2k10.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.90 2010/03/26 11:20:34 jsing Exp $ */
d62 1
a62 1
		u_int32_t	ssd_flags;
@


1.92
log
@Make key disks use their own optional metadata type, rather than reusing
crypto optional metadata.

ok marco@@
@
text
@d29 4
d89 1
a89 1
	u_int32_t		ssd_pad;
@


1.91
log
@Completely overhaul optional metadata handling, allowing for multiple
optional metadata per volume and discipline specific optional metadata
processing.

ok marco@@
@
text
@d155 4
d165 1
d170 1
@


1.90
log
@Add storage for the boot block and boot loader to the softraid metadata.
Also add a new optional metadata type for boot data. This is the first
step (of many) towards being able to boot from softraid volumes.

WARNING: This version of the softraid metadata is not compatible with
previous versions. As a result, any softraid volumes created with older
kernels will not assemble. Data on existing softraid volumes should be
backed up before upgrading. The volume should then be recreated and the
data restored.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.89 2010/02/13 21:19:26 jsing Exp $ */
d174 7
d365 1
a365 1
	struct sr_meta_crypto	scr_meta;
a412 1
	struct sr_meta_opt	src_opt;	/* optional metadata */
d477 1
d524 2
@


1.89
log
@Removed unused variable sml_vn.

ok @@marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.86 2009/12/07 14:33:38 jsing Exp $ */
d25 16
a40 4
#define SR_UUID_MAX		16
struct sr_uuid {
	u_int8_t		sui_id[SR_UUID_MAX];
} __packed;
d47 4
a50 6
#define SR_META_SIZE		64	/* save space at chunk beginning */
#define SR_META_OFFSET		16	/* skip 8192 bytes at chunk beginning */
#define SR_META_VERSION		3	/* bump when sr_metadata changes */

#define SR_META_F_NATIVE	0	/* Native metadata format. */
#define SR_META_F_INVALID	-1
d149 6
d160 1
d164 1
d169 1
@


1.88
log
@Add support for key disks. This allows a crypto volume to be constructed
without using a passphrase - instead the encryption mask key is stored on
the specified key disk partition (ideally being one on a removable device).
This also enables automatic assembly of crypto volumes at boot time.

ok marco@@
@
text
@a362 1
	struct vnode		*sml_vn;
@


1.87
log
@Factor out discipline specific create/assemble code.

"in, in, in!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.85 2009/12/07 14:27:12 jsing Exp $ */
d32 2
d38 4
d159 3
a161 2
#define SR_CRYPTOKDFT_INVALID	(0)
#define SR_CRYPTOKDFT_PBKDF2	(1<<0)
d340 1
d560 5
d567 2
d576 1
d607 2
@


1.86
log
@Cleanup discipline initialisation.

ok marco@@
@
text
@d478 4
@


1.85
log
@Define discipline capabilities using a set of flags.

"shiny!!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.83 2009/11/23 16:33:59 jsing Exp $ */
d570 2
a571 1
void			sr_raidp_discipline_init(struct sr_discipline *);
@


1.84
log
@Allow the passphrase to be changed on softraid crypto volumes. Ensure that
you backup your data and lock up your pets prior to using this.

Tested by todd@@

ok marco@@
@
text
@d423 5
a463 1
	int			sd_rebuild;	/* can we rebuild? */
@


1.83
log
@Improve discipline specific ioctl framework and attach to softraid ioctl.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.80 2009/07/23 15:15:25 jordan Exp $ */
d184 10
d545 3
@


1.82
log
@Add a framework for discipline specific ioctls.

ok marco@@
@
text
@d467 1
a467 1
				    u_long, caddr_t);
@


1.81
log
@Switch softraid to vnodes to prevent bad things from happening when using
d_open/d_close.

tested by many, ok jsing, thib, krw
@
text
@d466 2
@


1.80
log
@Adding disabled framework for RAID6
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.79 2009/07/12 16:31:56 jsing Exp $ */
d23 1
d345 1
d374 1
@


1.79
log
@Add support for global hotspares to softraid.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.77 2009/06/24 12:06:00 jsing Exp $ */
d267 2
d312 6
d405 1
d414 1
d549 1
@


1.78
log
@Overhaul sr_boot_assembly(). The original code had a number of problems,
including a "chunk id already in use" bug that occurred when assembling
more than one volume at boot. Volumes are now kept in order, as are the
chunks which they are assembled from. Duplicated chunk IDs are now handled
appropriately, with the chunk that has the most recent ondisk metadata
being used.

Also tested by nicm@@ who got bitten by the "chunk id already in use" bug.

ok marco@@
@
text
@d29 3
d480 5
d503 3
@


1.77
log
@Abort the current rebuild if the rebuild chunk disappears. Whilst here also
rename the abort flag so that it is more generalised.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.76 2009/06/17 22:44:42 marco Exp $ */
d333 1
d340 14
@


1.76
log
@Make openings variable instead of maxwu; needed for more exotic raid sets.
ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.75 2009/06/17 03:43:30 marco Exp $ */
d420 1
a420 1
	int			sd_going_down;	/* dive dive dive */
@


1.75
log
@Remove __packed from memory structure.  No idea what in the wolrd I was
smoking but it sure as heck wasn't good.

Issue found by jsing on sparc64; tested by jsing and me on various arches.
ok deraadt jsing
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.74 2009/06/12 23:56:02 jordan Exp $ */
d439 1
@


1.74
log
@Add flag for freeing ccb buffer on I/O completion
Needed for RAID4/RAID5 xor buffers
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.73 2009/06/11 19:42:59 marco Exp $ */
d242 1
a242 1
} __packed;
@


1.73
log
@Create a hotplug callback mechanism.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.72 2009/06/10 03:24:02 marco Exp $ */
d235 3
@


1.72
log
@Add framework for raid 4 & 5 so that we can work in tree.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.71 2009/06/03 21:04:36 marco Exp $ */
d418 1
d472 4
@


1.71
log
@Slay the running out of wu during rebuild dragon and some cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.70 2009/06/02 19:15:58 marco Exp $ */
d298 6
d375 1
d383 1
d503 1
@


1.70
log
@Make rebuilds restartable over reboots.
Abort rebuild and drain IO when shutting down.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.69 2009/06/02 05:49:35 marco Exp $ */
d259 2
a260 2
#define SR_WUF_REBUILD		(1<<0)
#define SR_WUF_REBUILDIOCOMP	(1<<1)
d414 1
d471 1
a471 1
struct sr_workunit	*sr_wu_get(struct sr_discipline *);
@


1.69
log
@Add an identifier that tells us if we can rebuild this discipline.
KNF & spelling too
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.68 2009/06/02 00:58:16 marco Exp $ */
d408 2
@


1.68
log
@First bits for rebuild.  Disabled for now.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.67 2009/05/11 14:06:21 jsing Exp $ */
d407 1
@


1.67
log
@Move the discipline initialisation code into discipline specific functions,
rather than initialising everything in softraid.c. This makes a discipline
more self-contained and reduces the number of function declarations needed
in softraidvar.h.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.65 2008/11/25 23:05:17 marco Exp $ */
d218 1
d258 4
d433 3
@


1.66
log
@This creates the notion of a non-disk softraid device.  The aoe target
is such a beast because it doesn't physically add a device to the OS but
exports a RAID partition.  It creates a kernel thread for each
exported aoe target.  Since it reuses all the goodies in softraid upon
reboot the metadata is discovered and therefore the partition is exported
at boot time.

ok tedu dlg
@
text
@d480 6
a485 8
/* raid 0 */
int			sr_raid0_alloc_resources(struct sr_discipline *);
int			sr_raid0_free_resources(struct sr_discipline *);
int			sr_raid0_rw(struct sr_workunit *);
void			sr_raid0_intr(struct buf *);
void			sr_raid0_set_chunk_state(struct sr_discipline *,
			    int, int);
void			sr_raid0_set_vol_state(struct sr_discipline *);
d488 1
a488 5
int			sr_raid1_alloc_resources(struct sr_discipline *);
int			sr_raid1_free_resources(struct sr_discipline *);
int			sr_raid1_rw(struct sr_workunit *);
void			sr_raid1_intr(struct buf *);
void			sr_raid1_recreate_wu(struct sr_workunit *);
d493 1
a493 4
/* crypto discipline */
int			sr_crypto_alloc_resources(struct sr_discipline *);
int			sr_crypto_free_resources(struct sr_discipline *);
int			sr_crypto_rw(struct sr_workunit *);
a496 9

/* aoe discipline */
int			sr_aoe_alloc_resources(struct sr_discipline *);
int			sr_aoe_free_resources(struct sr_discipline *);
int			sr_aoe_rw(struct sr_workunit *);
/* aoe target */
int			sr_aoe_server_alloc_resources(struct sr_discipline *);
int			sr_aoe_server_free_resources(struct sr_discipline *);
int			sr_aoe_server_start(struct sr_discipline *);
@


1.65
log
@Add generic sr_scsi_done function that does the spl dance
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.64 2008/11/23 23:44:01 tedu Exp $ */
d312 1
d362 2
a363 1
#define	SR_MD_AOE		5
a412 3
	int			(*sd_assemble_volume)(void *);
	int			(*sd_bringup_volume)(void *);
	int			(*sd_shutdown_volume)(void *);
d414 1
a414 1
	int			(*sd_quiesce_io)(struct sr_discipline *);
d511 4
@


1.64
log
@softraid support for ata over ethernet (aoe).  this includes a client and
part of a server.  there's no configuration yet, and several other drawbacks,
but it can be hammered into shape.  i haven't moved the code forward in a year,
and marco wants it in the tree to hack on.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.63 2008/07/29 01:18:02 marco Exp $ */
d469 2
@


1.63
log
@Add rebuild mark so that we can restart a rebuild upon clean shutdown.
Fix a typo while here.

The rebuild field was appended to the metadata so that we can automatically
update from v2 to v3.  The only visible difference will be that in the dmesg
the SCSI version number will go from 002 to 003.

ok deraad.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.62 2008/07/20 21:57:51 djm Exp $ */
d307 8
d361 1
d370 3
d505 5
@


1.62
log
@fill in variant and version components of the UUID
pretty-print the UUID in RFC4122 form
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.61 2008/07/19 22:41:58 marco Exp $ */
d31 1
a31 1
#define SR_META_VERSION		2	/* bump when sr_metadata changes */
d46 1
a46 1
		u_int32_t	ssd_opt_no;	/* nr of optional md * elements */
d67 1
@


1.61
log
@Full rewrite of metadata handling.  This fixes power failures and crashes
that caused illegal checksums.  The new metadata code is more or less ready
to deal with other vendor's metadata formats.

While here clean up the name space.

Fix thib's pool mess by adding removing bad flags in interrupt context.

tested on macppc, amd64, i386, sparc64 & hppa

sparc64 has issues with crypto however those do not seem to be softraid
specific.

help from okan@@ ckuethe@@ Will Backman and others
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.60 2008/06/25 17:43:09 thib Exp $ */
d24 1
a24 1
#define SR_UUID_MAX		4
d26 1
a26 1
	u_int32_t		sui_id[SR_UUID_MAX];
@


1.60
log
@
use pools for the uio and iovec allocations in sr_crypto_getcryptop()
instead of malloc;

OK hshoexer@@ and macro@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.59 2008/06/14 03:01:00 djm Exp $ */
d22 2
d29 1
a29 1
#define SR_META_SIZE		32	/* save space at chunk beginning */
d31 1
a31 1
#define SR_META_VERSION		1	/* bump when sr_metadata changes */
d33 3
a35 2
	/* do not change order of ssd_magic, ssd_version & ssd_checksum */
	u_int64_t		ssd_magic;	/* magic id */
d37 30
a66 30
	u_int8_t		ssd_version;	/* meta data version */
	u_int8_t		ssd_pad1[3];
	u_int32_t		ssd_flags;	/* flags */

	/* meta-data */
	u_int32_t		ssd_checksum;	/* xor of the structure */
	u_int32_t		ssd_size;	/* sizeof(sr_metadata) */
	u_int32_t		ssd_ondisk;	/* on disk version counter */
	u_int32_t		ssd_pad2;
	struct sr_uuid		ssd_uuid;	/* unique identifier */

	/* virtual disk data */
	u_int32_t		ssd_vd_ver;	/* vd structure version */
	u_int32_t		ssd_vd_size;	/* vd structure size */
	u_int32_t		ssd_vd_volid;	/* volume id */
	u_int32_t		ssd_vd_chk;	/* vd structure xor */

	/* chunk data */
	u_int32_t		ssd_chunk_ver;	/* chunk structure version */
	u_int32_t		ssd_chunk_no;	/* number of chunks */
	u_int32_t		ssd_chunk_size;	/* chunk structure size */
	u_int32_t		ssd_chunk_id;	/* chunk identifier */
	u_int32_t		ssd_chunk_chk;	/* chunk structure xor */
	u_int32_t		ssd_pad3;

	/* optional metadata */
	u_int32_t		ssd_opt_ver;	/* optinal meta version */
	u_int32_t		ssd_opt_no;	/* nr of optional md elements */
	u_int32_t		ssd_opt_size;	/* sizeof optional metadata */
	u_int32_t		ssd_opt_chk;	/* optional metadata xor */
d69 14
a82 14
#define SR_VOL_VERSION	2	/* bump when sr_vol_meta changes */
struct sr_vol_meta {
	u_int32_t		svm_volid;	/* volume id */
	u_int32_t		svm_status; 	/* use bioc_vol status */
	u_int32_t		svm_flags;	/* flags */
#define	SR_VOL_DIRTY		0x01
	u_int32_t		svm_level;	/* raid level */
	int64_t			svm_size;	/* virt disk size in blocks */
	char			svm_devname[32];/* /dev/XXXXX */
	char			svm_vendor[8];	/* scsi vendor */
	char			svm_product[16];/* scsi product */
	char			svm_revision[4];/* scsi revision */
	u_int32_t		svm_no_chunk;	/* number of chunks */
	struct sr_uuid 		svm_uuid;	/* volume unique identifier */
d84 14
a97 2
	/* optional members */
	u_int32_t		svm_strip_size;	/* strip size */
d100 10
a109 5
#define SR_CHUNK_VERSION	1	/* bump when sr_chunk_meta changes */
struct sr_chunk_meta {
	u_int32_t		scm_volid;	/* vd we belong to */
	u_int32_t		scm_chunk_id;	/* chunk id */
	u_int32_t		scm_status;	/* use bio bioc_disk status */
d111 15
a125 4
	char			scm_devname[32];/* /dev/XXXXX */
	int64_t			scm_size;	/* size of partition in blocks*/
	int64_t			scm_coerced_size; /* coerced sz of part in blk*/
	struct sr_uuid		scm_uuid;	/* unique identifier */
d128 15
a142 7
#define SR_CRYPTO_MAXKEYBYTES	32
#define SR_CRYPTO_MAXKEYS	32
#define SR_CRYPTO_KEYBITS	512	/* AES-XTS with 2 * 256 bit keys */
#define SR_CRYPTO_KEYBYTES	(SR_CRYPTO_KEYBITS >> 3)
#define SR_CRYPTO_KDFHINTBYTES	256
#define SR_CRYPTO_CHECKBYTES	64
#define SR_CRYPTO_KEY_BLKSHIFT	30	/* 0.5TB per key */
d144 1
d152 1
d161 2
a162 2
 * Check that HMAC-SHA1_k(decrypted scm_key) == sch_mac, where
 * k = SHA1(masking key)
a163 4
struct sr_crypto_chk_hmac_sha1 {
	u_int8_t	sch_mac[20];
};

a178 35
struct sr_crypto_metadata {
	u_int32_t		scm_alg;
#define SR_CRYPTOA_AES_XTS_128	1
#define SR_CRYPTOA_AES_XTS_256	2
	u_int32_t		scm_flags;
#define SR_CRYPTOF_INVALID	(0)
#define SR_CRYPTOF_KEY		(1<<0)
#define SR_CRYPTOF_KDFHINT	(1<<1)
	u_int32_t		scm_mask_alg;
#define SR_CRYPTOM_AES_ECB_256	1
	u_int8_t		scm_reserved[64];

	u_int8_t		scm_key[SR_CRYPTO_MAXKEYS][SR_CRYPTO_KEYBYTES];
	u_int8_t		scm_kdfhint[SR_CRYPTO_KDFHINTBYTES];

	u_int32_t		scm_check_alg;
#define SR_CRYPTOC_HMAC_SHA1		1
	union {
		struct sr_crypto_chk_hmac_sha1	chk_hmac_sha1;
		u_int8_t			chk_reserved2[64];
	}			_scm_chk;
#define	chk_hmac_sha1	_scm_chk.chk_hmac_sha1
};

#define SR_OPT_VERSION		1	/* bump when sr_opt_meta changes */
struct sr_opt_meta {
	u_int32_t		som_type;
#define SR_OPT_INVALID		0x00
#define SR_OPT_CRYPTO		0x01
	u_int32_t		som_pad;
	union {
		struct sr_crypto_metadata smm_crypto;
	}			som_meta;
};

a179 1

d183 1
d216 1
d295 1
a295 1
	struct sr_crypto_metadata scr_meta;
d297 4
d307 1
a307 1
	struct sr_metadata	*sml_metadata;
d317 2
a318 1
	struct sr_chunk_meta	src_meta;	/* chunk meta data */
a333 2
	struct sr_vol_meta	sv_meta;	/* meta data */

d365 1
d367 1
d379 1
a379 1

a439 4
struct pool;
extern struct pool	sr_uiopl;
extern struct pool	sr_iovpl;

d441 8
a448 8
int			sr_alloc_ccb(struct sr_discipline *);
void			sr_free_ccb(struct sr_discipline *);
struct sr_ccb		*sr_get_ccb(struct sr_discipline *);
void			sr_put_ccb(struct sr_ccb *);
int			sr_alloc_wu(struct sr_discipline *);
void			sr_free_wu(struct sr_discipline *);
struct sr_workunit	*sr_get_wu(struct sr_discipline *);
void			sr_put_wu(struct sr_workunit *);
d452 1
a452 1
void			sr_save_metadata_callback(void *, void *);
@


1.59
log
@Use multiple crypto keys per volume. Each key is used to encrypt at
most 0.5TB of disk. This is well below P1619-2007's recommendation
for AES-XTS of 1TB/key, but small enough so we can test that we
actually use multiple keys with inexpensive hardware.
We allocate 32 keys, so this will do for volumes up to 16TB.

Fix a crypto session leak in sr_crypto_free_resources()

much debugging help mshoexer@@; ok hshoexer@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.58 2008/06/14 00:39:15 djm Exp $ */
d431 4
@


1.58
log
@remove duplicate #defines; ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.57 2008/06/14 00:12:21 djm Exp $ */
d103 1
d296 1
a296 1
	u_int64_t		scr_sid/*[SR_CRYPTO_MAXKEYS]*/;
@


1.57
log
@implement a check code to determine whether the disk keys have
been correctly decrypted using the masking key.

The check code is a HMAC-SHA1 over the disk keys using a hash of
the masking key. It should be slow enough to provide no useful
brute force success oracle and should not leak significant data about
the masking key or disk keys.

ok hshoexer@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.56 2008/06/13 22:08:17 djm Exp $ */
a113 2
#define SR_CRYPTOKDFT_INVALID	(0)
#define SR_CRYPTOKDFT_PBKDF2	(1<<0)
@


1.56
log
@make the disk key masking algorithm a parameter and add some extra
reserved space in case we ever want to support a different scheme
ok hshoexer@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.55 2008/06/13 21:03:40 hshoexer Exp $ */
d102 1
d120 8
d157 8
@


1.55
log
@Implement pbkdf2 in in bioctl to derive master key from a passphrase.

ok marco djm
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.54 2008/06/13 18:27:42 djm Exp $ */
a118 1

d142 3
@


1.54
log
@rearrange on-disk structures to the top of the file, wrap kernel-only
parts in #ifdef _KERNEL; makes softraidvar.h usable from userland
ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.53 2008/06/12 18:21:04 hshoexer Exp $ */
d110 10
d127 6
a132 1
	struct sr_crypto_genkdf	kdfhint;
@


1.53
log
@wrap definitions for softraid crypto "ifdef CRYPTO".  Suggested by djm
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.52 2008/06/12 18:13:27 hshoexer Exp $ */
d22 124
a155 4
#ifdef CRYPTO
#include <crypto/rijndael.h>
#endif

a184 5
#define SR_UUID_MAX		4
struct sr_uuid {
	u_int32_t		sui_id[SR_UUID_MAX];
} __packed;

a256 36
#ifdef CRYPTO
#define SR_CRYPTO_MAXKEYS	32
#define SR_CRYPTO_KEYBITS	512	/* AES-XTS with 2 * 256 bit keys */
#define SR_CRYPTO_KEYBYTES	(SR_CRYPTO_KEYBITS >> 3)
#define SR_CRYPTO_KDFHINTBYTES	256

struct sr_crypto_genkdf {
	u_int32_t	len;
	u_int32_t	type;
#define SR_CRYPTOKDFT_INVALID	(0)
#define SR_CRYPTOKDFT_PBKDF2	(1<<0)
};

struct sr_crypto_kdfinfo {
	u_int32_t	len;
	u_int32_t	flags;
#define SR_CRYPTOKDF_INVALID	(0)
#define SR_CRYPTOKDF_KEY	(1<<0)
#define SR_CRYPTOKDF_HINT	(1<<1)
	u_int8_t	maskkey[AES_MAXKEYBYTES];
	struct sr_crypto_genkdf	kdfhint;
};

struct sr_crypto_metadata {
	u_int32_t		scm_alg;
#define SR_CRYPTOA_AES_XTS_128	1
#define SR_CRYPTOA_AES_XTS_256	2
	u_int32_t		scm_flags;
#define SR_CRYPTOF_INVALID	(0)
#define SR_CRYPTOF_KEY		(1<<0)
#define SR_CRYPTOF_KDFHINT	(1<<1)

	u_int8_t		scm_key[SR_CRYPTO_MAXKEYS][SR_CRYPTO_KEYBYTES];
	u_int8_t		scm_kdfhint[SR_CRYPTO_KDFHINTBYTES];
};

d262 1
a262 1
	u_int8_t		scr_maskkey[AES_MAXKEYBYTES];
a264 40
#endif	/* CRYPTO */

#define SR_META_SIZE		32	/* save space at chunk beginning */
#define SR_META_OFFSET		16	/* skip 8192 bytes at chunk beginning */
#define SR_META_VERSION		1	/* bump when sr_metadata changes */
struct sr_metadata {
	/* do not change order of ssd_magic, ssd_version & ssd_checksum */
	u_int64_t		ssd_magic;	/* magic id */
#define	SR_MAGIC		0x4d4152436372616dLLU
	u_int8_t		ssd_version;	/* meta data version */
	u_int8_t		ssd_pad1[3];
	u_int32_t		ssd_flags;	/* flags */

	/* meta-data */
	u_int32_t		ssd_checksum;	/* xor of the structure */
	u_int32_t		ssd_size;	/* sizeof(sr_metadata) */
	u_int32_t		ssd_ondisk;	/* on disk version counter */
	u_int32_t		ssd_pad2;
	struct sr_uuid		ssd_uuid;	/* unique identifier */

	/* virtual disk data */
	u_int32_t		ssd_vd_ver;	/* vd structure version */
	u_int32_t		ssd_vd_size;	/* vd structure size */
	u_int32_t		ssd_vd_volid;	/* volume id */
	u_int32_t		ssd_vd_chk;	/* vd structure xor */

	/* chunk data */
	u_int32_t		ssd_chunk_ver;	/* chunk structure version */
	u_int32_t		ssd_chunk_no;	/* number of chunks */
	u_int32_t		ssd_chunk_size;	/* chunk structure size */
	u_int32_t		ssd_chunk_id;	/* chunk identifier */
	u_int32_t		ssd_chunk_chk;	/* chunk structure xor */
	u_int32_t		ssd_pad3;

	/* optional metadata */
	u_int32_t		ssd_opt_ver;	/* optinal meta version */
	u_int32_t		ssd_opt_no;	/* nr of optional md elements */
	u_int32_t		ssd_opt_size;	/* sizeof optional metadata */
	u_int32_t		ssd_opt_chk;	/* optional metadata xor */
} __packed;
a275 23
#define SR_OPT_VERSION		1	/* bump when sr_opt_meta changes */
struct sr_opt_meta {
	u_int32_t		som_type;
#define SR_OPT_INVALID		0x00
#define SR_OPT_CRYPTO		0x01
	u_int32_t		som_pad;
	union {
		struct sr_crypto_metadata smm_crypto;
	}			som_meta;
};

#define SR_CHUNK_VERSION	1	/* bump when sr_chunk_meta changes */
struct sr_chunk_meta {
	u_int32_t		scm_volid;	/* vd we belong to */
	u_int32_t		scm_chunk_id;	/* chunk id */
	u_int32_t		scm_status;	/* use bio bioc_disk status */
	u_int32_t		scm_pad1;
	char			scm_devname[32];/* /dev/XXXXX */
	int64_t			scm_size;	/* size of partition in blocks*/
	int64_t			scm_coerced_size; /* coerced sz of part in blk*/
	struct sr_uuid		scm_uuid;	/* unique identifier */
} __packed;

a291 19
#define SR_VOL_VERSION	2	/* bump when sr_vol_meta changes */
struct sr_vol_meta {
	u_int32_t		svm_volid;	/* volume id */
	u_int32_t		svm_status; 	/* use bioc_vol status */
	u_int32_t		svm_flags;	/* flags */
#define	SR_VOL_DIRTY		0x01
	u_int32_t		svm_level;	/* raid level */
	int64_t			svm_size;	/* virt disk size in blocks */
	char			svm_devname[32];/* /dev/XXXXX */
	char			svm_vendor[8];	/* scsi vendor */
	char			svm_product[16];/* scsi product */
	char			svm_revision[4];/* scsi revision */
	u_int32_t		svm_no_chunk;	/* number of chunks */
	struct sr_uuid 		svm_uuid;	/* volume unique identifier */

	/* optional members */
	u_int32_t		svm_strip_size;	/* strip size */
} __packed;

d455 2
@


1.52
log
@Get mask keying for on-disk keys from user space and keep a "hint" for key
generation used by user space in the meta data.

Actually use the masking key for encryption and decryption of on-disk key
at run time.

ok djm marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.51 2008/06/12 00:19:15 marco Exp $ */
d32 1
d34 1
d142 1
d186 1
@


1.51
log
@Add delete volume functionality.

discussed with krw, kettenis & drahn
ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.50 2008/06/11 00:26:18 hshoexer Exp $ */
d32 2
d143 18
a160 1
#define SR_CRYPTO_KDFHINTBYTES	64
d180 1
d447 2
@


1.50
log
@Move first pieces of crypto softraid into the tree.  Still totally
disabled, of course, and still work in progress.

help by djm@@, ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.49 2008/02/22 23:00:04 hshoexer Exp $ */
d309 2
@


1.49
log
@Propper encryption of on-disk-keys, prodded/suggest by tedu@@ and djm@@
also use aes to generate proppper IVs

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.48 2008/02/17 22:56:20 marco Exp $ */
d139 1
a139 1
#define SR_CRYPTO_KEYBITS	128
d141 1
a141 2
#define SR_CRYPTO_ROUNDS	14
#define SR_CRYPTO_PBKDF2_ROUNDS	20000
d144 3
d150 1
a150 2
#define SR_CRYPTOF_SALT		(1<<1)
#define SR_CRYPTOF_PASSPHRASE	(1<<2)
d152 2
a153 5
	u_int32_t		scm_pad;
	u_int8_t		scm_key1[SR_CRYPTO_MAXKEYS][SR_CRYPTO_KEYBYTES];
	u_int8_t		scm_key2[SR_CRYPTO_MAXKEYS][SR_CRYPTO_KEYBYTES];
	u_int8_t		scm_salt[64];
	char			scm_passphrase[128]; /* _PASSWORD_LEN */
d158 1
a158 9
	/*
	 * [0] contains encrypted key & salt
	 * [1] contains password
	 */
	struct sr_crypto_metadata scr_meta[2];

	/* decrypted keys */
	u_int8_t		scr_key1[SR_CRYPTO_MAXKEYS][SR_CRYPTO_KEYBYTES];
	u_int8_t		scr_key2[SR_CRYPTO_MAXKEYS][SR_CRYPTO_KEYBYTES];
d160 2
a161 1
	u_int64_t		scr_sid;
d425 1
a425 2
int			sr_crypto_encrypt_key(struct sr_discipline *);
void			sr_crypto_create_keys(struct sr_discipline *);
@


1.48
log
@Add "in blocks" to disk size discriptors so that I don't have to read
code single time I look at it.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.47 2008/02/17 20:39:22 hshoexer Exp $ */
d139 1
a139 1
#define SR_CRYPTO_KEYBITS	256
@


1.47
log
@Add propper key encryption.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.46 2008/02/15 05:29:25 ckuethe Exp $ */
d240 2
a241 2
	int64_t			scm_size;	/* size of partition */
	int64_t			scm_coerced_size; /* coerced size of part */
d254 1
a254 1
	int64_t			src_size;
d268 1
a268 1
	int64_t			svm_size;	/* virtual disk size */
@


1.46
log
@Add myself to the copyrights, ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.45 2008/02/14 22:04:34 ckuethe Exp $ */
d142 1
@


1.45
log
@Actually implement the crypto.
ok tedu@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.44 2008/02/07 15:08:49 marco Exp $ */
d4 1
@


1.44
log
@Add optional metadata memebers.
Randomize Crypto password and add salt array.
Add mock key encryption functions.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.43 2008/02/05 16:49:25 marco Exp $ */
d137 5
d150 3
a152 2
	char			scm_key[64];
	char			scm_salt[64];
d164 4
a168 1
	char			scr_key[64]; /* unencrypted key */
d433 1
@


1.43
log
@Shave off a few more bytes by moving IO collision detection into a generic
fucntion.  Fix bug in the crypto code that could casuse data corruption as
a bonus, bad cut & past tedu!
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.42 2008/02/05 16:15:35 marco Exp $ */
d136 14
a149 1
/* RAID CRYPTO */
d152 8
a159 2
	u_int64_t		src_sid;
	char			src_key[64];
a213 1
	u_int32_t		som_pad;
d216 1
d218 1
a218 1
		struct sr_crypto	smm_crypto;
d423 5
@


1.42
log
@Create a generic function to validate IO instead of copying and pasting
same code in all disciplines.  This shaves of a few bytes.

crypto 3185 -> 2690
raid 0 2843 -> 2378
raid 1 3474 -> 2689
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.41 2008/02/03 00:25:21 marco Exp $ */
d370 1
@


1.41
log
@There is no such thing as RAIDCRYPTO so rename to CRYPTO
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.40 2008/01/29 23:25:02 marco Exp $ */
d368 2
@


1.40
log
@Improve performance dramatically by preventing severeal context switches.
Decrypt only once on entry or exit instead of on in and out regardless of
direction.

There is still room for improvement but this is the first stab.

Tested by many ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.39 2008/01/26 19:29:55 marco Exp $ */
d137 1
a137 1
#define SR_RAIDCRYPTO_NOWU		16
d270 1
a270 1
#define	SR_MD_RAIDCRYPTO	4
@


1.39
log
@Remove duplicate protos
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.38 2008/01/24 19:58:08 marco Exp $ */
d77 2
@


1.38
log
@Create chunk and state transition functions for RAID 0.
Move RAID 1 chunk and state transition functions into proper file.
Let Crypto use RAID 1 chunk and state transition functions for now but this
needs fixing.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.37 2008/01/24 13:58:14 marco Exp $ */
d33 1
a395 2
struct cryptop 		*sr_crypto_getcryptop(struct sr_workunit *, int);
void 			*sr_crypto_putcryptop(struct cryptop *);
a398 3
int			sr_crypto_rw2(struct cryptop *);
void			sr_crypto_intr(struct buf *);
int			sr_crypto_intr2(struct cryptop *);
@


1.37
log
@Add IO path to RAID 0 discipline.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.36 2008/01/19 23:53:53 marco Exp $ */
d362 4
a372 3
void			sr_raid_set_chunk_state(struct sr_discipline *,
			    int, int);
void			sr_raid_set_vol_state(struct sr_discipline *);
a373 1
int32_t			sr_validate_stripsize(u_int32_t);
d380 3
d390 3
d395 2
a396 2
struct cryptop *	sr_crypto_getcryptop(struct sr_workunit *, int);
void *			sr_crypto_putcryptop(struct cryptop *);
@


1.36
log
@Add initial scaffold for RAID 0.  No IO just yet.

Much prodding todd
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.35 2007/11/27 17:21:52 tedu Exp $ */
a32 1
/* #define SR_DEBUG */
d124 1
a124 1
	int32_t			sr0_stripbits;
@


1.35
log
@also move softraid raid1 into own file, ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.34 2007/11/27 16:37:05 tedu Exp $ */
d122 6
d229 1
a229 1
#define SR_VOL_VERSION	1	/* bump when sr_vol_meta changes */
d243 3
d274 1
d374 1
d376 7
a388 1

d399 1
a399 1
#endif
@


1.34
log
@split crypto functions out into their own file, so softraid.c is not such
a jungle.  ok deraadt marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.33 2007/11/26 13:49:26 tedu Exp $ */
d364 7
@


1.33
log
@rename RAID C to RAID CRYPTO.  makes marco happier
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.32 2007/06/06 23:06:02 deraadt Exp $ */
d18 3
d130 1
a130 1
struct sr_raidc {
d191 1
a191 1
		struct sr_raidc	smm_crypto;
d266 1
a266 1
	    struct sr_raidc	mdd_raidc;
d342 34
@


1.32
log
@correct format strings for large types; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.31 2007/06/06 17:15:13 deraadt Exp $ */
d125 2
a126 2
/* RAID C */
#define SR_RAIDC_NOWU		16
d256 1
a256 1
#define	SR_MD_RAIDC		4
@


1.31
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.30 2007/06/02 00:53:35 marco Exp $ */
d138 1
a138 1
#define	SR_MAGIC		0x4d4152436372616dllu
@


1.30
log
@Add optional metadata element.  This will be needed in the future for
certain disciplines.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.29 2007/06/01 18:50:56 marco Exp $ */
d199 2
a200 2
	u_quad_t		scm_size;	/* size of partition */
	u_quad_t		scm_coerced_size; /* coerced size of part */
d213 1
a213 1
	quad_t			src_size;
d227 1
a227 1
	u_quad_t		svm_size;	/* virtual disk size */
@


1.29
log
@Add additional flag to indicate that we have a metdadata io pending; this
way if we shut down the system we can make sure that it makes it onto disk
before scsibus detach.

ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.28 2007/05/31 18:56:27 marco Exp $ */
d119 13
d163 6
d181 11
a246 12
};

/* RAID 1 */
#define SR_RAID1_NOWU		16
struct sr_raid1 {
	u_int32_t		sr1_counter;
};

#define SR_RAIDC_NOWU		16
struct sr_raidc {
	u_int64_t		src_sid;
	char			src_key[64];
@


1.28
log
@Fix redundancy for RAID 1.  Now one can pull a disk and continue running.

help from drahn
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.27 2007/05/31 05:49:26 grunk Exp $ */
d254 2
@


1.27
log
@correct misspelled mail address in copyright statement, marco@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.26 2007/05/30 15:59:35 marco Exp $ */
d92 2
@


1.26
log
@Sync after the metadata is saved.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.25 2007/05/30 13:55:47 tedu Exp $ */
d3 1
a3 1
 * Copyright (c) 2006 Marco Peereboom <sro@@peereboom.us>
@


1.25
log
@add basic support for a crypto(9) backed raid C discipline
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.24 2007/05/29 23:20:02 marco Exp $ */
d93 1
@


1.24
log
@Add dirty bit for volumes
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.23 2007/05/29 18:35:00 marco Exp $ */
d222 6
d235 1
d242 1
@


1.23
log
@Add shutdownhook for all disciplines
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.22 2007/05/29 08:15:32 marco Exp $ */
d192 1
@


1.22
log
@Re-add sync.

ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.21 2007/05/28 21:54:26 marco Exp $ */
d212 1
d240 1
d242 2
@


1.21
log
@Make disk assembly smarter and add two qualifiers to it:
1) noautoassemble; when set the softraid volume will not be assembled during
   autoconf.
2) force; when set it will overwrite metadata on disk

While writing this I ran into 3 bugs that were fixed along the way
1) bcopy in sr_read_meta was copying data to the wrong pointer
2) in sr_read_meta the wrong metadata was coppied into the chunk
3) sr_free_discipline was freing a pointer that wasn't malloc'd

ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.20 2007/05/26 14:30:26 marco Exp $ */
d239 1
@


1.20
log
@Assemble disks at boot time.  This is not complete yet since it does not
order and roams volumes yet but is useful enough in most environments.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.19 2007/05/24 13:15:31 marco Exp $ */
d124 2
a125 1
	u_int8_t		ssd_pad1[7];
d238 1
@


1.19
log
@create separate function to validate metadata.
remove seeding of checksums.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.18 2007/05/23 21:27:13 marco Exp $ */
d147 10
@


1.18
log
@Remove all vnode dependencies so that we can bootstrap softraid volumes.
Code from tedu.

Replace all kernel string magic with dev_t passed in from bioctl.
Suggestion from beck and tedu.  Help from miod.

Fix chunk crc.

ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.17 2007/05/08 23:54:37 marco Exp $ */
a118 1
#define SR_META_CRCSEED		0xdeadbeef /* seed for crc in metadata */
@


1.17
log
@Assemble disk from user supplied metadata.
Verify all metada to make sure it is correct; this includes sorting the chunks
Add 2 new functions for printing uuid and metadata.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.16 2007/05/01 22:53:51 marco Exp $ */
d119 1
a164 1
	struct vnode		*src_dev_vn;	/* vnode */
d170 1
a170 1
	struct disklabel	src_label;
@


1.16
log
@Refactor metadata code; this is the first step to be able to bringup
devices at boot time.

Reset the metadata versions to 1 until this solidifies we wont change
these.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.15 2007/04/23 20:11:31 marco Exp $ */
d120 1
a120 1
	/* do not change order of ssd_magic, ssd_version */
@


1.15
log
@Add interesting runtime stats.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.14 2007/04/22 04:05:36 marco Exp $ */
d118 1
a118 1
#define SR_META_VERSION		2	/* bump when sr_metadata changes */
d136 1
a137 1
	u_int32_t		ssd_pad3;
d143 1
d145 1
d148 1
a148 1
#define SR_CHUNK_VERSION	2	/* bump when sr_chunk_meta changes */
d167 5
d177 1
a177 1
#define SR_VOL_VERSION	2	/* bump when sr_vol_meta changes */
@


1.14
log
@Add more debug output for metadata.
Spacing as well.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.13 2007/04/22 00:41:31 marco Exp $ */
d236 4
@


1.13
log
@Don't use SBLOCK_UFS1.  Don't call it SKIP either.

Pompted by deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.12 2007/04/22 00:06:09 marco Exp $ */
a175 2

#define SR_VDF_DIRTY		0x01
a176 1

a181 1

@


1.12
log
@Skip past SBLOCK_UFS1 to make sure that metadata does not destroy anything
filesystem related.

pointed out by deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.11 2007/04/21 23:39:18 marco Exp $ */
a22 1
#include <ufs/ffs/fs.h>
d117 1
a117 1
#define SR_FFS_SKIP		(SBLOCK_UFS1 >> 9)
@


1.11
log
@Remove big endian in metadata; prompted by deraadt.
Align metadata to 64 bit; from deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.10 2007/04/21 23:05:19 marco Exp $ */
d23 1
d118 1
@


1.10
log
@Add volumes to sensors.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.9 2007/04/19 02:44:29 marco Exp $ */
d116 2
a117 2
#define SR_META_SIZE		32  /* save space at chunk beginning */
#define SR_META_VERSION		1   /* bump when sr_metadata changes */
d119 1
a119 1
	/* do not change order of ssd_magic, ssd_version and ssd_big_endian */
d123 1
a123 2
	u_int8_t		ssd_big_endian;	/* set if big endian */
	u_int8_t		ssd_pad[2];
d129 2
a130 1
	struct sr_uuid	ssd_uuid;	/* unique identifier */
d136 1
d145 1
a145 1
#define SR_CHUNK_VERSION	1	/* bump when sr_chunk_meta changes */
d147 4
a150 2
	int			scm_volid;	/* vd we belong to */
	int			scm_chunk_id;	/* chunk id */
a151 1
	int			scm_status;	/* use bio bioc_disk status */
d169 1
a169 1
#define SR_VOL_VERSION	1	/* bump when sr_vol_meta changes */
d171 5
a175 3
	int			svm_volid;	/* volume id */
	int			svm_status; 	/* use bioc_vol status */
	int			svm_flags;	/* flags */
d178 2
a179 1
	int			svm_level;	/* raid level */
d183 2
a184 3
	char			svm_pad[4];
	char			svm_devname[32];/* /dev/XXXXX */
	int			svm_no_chunk;	/* number of chunks */
@


1.9
log
@Add initial metadata write function and hook it up.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.8 2007/04/14 21:28:08 tedu Exp $ */
d190 4
d264 2
d271 1
@


1.8
log
@shave some blocks off each chunk to make sure disklabel doesn't get eaten
this can also be used for softraid metadata
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.7 2007/04/12 03:31:54 marco Exp $ */
d116 1
a116 4
#define SR_META_PD		1   /* only 1 PD per metadata block */
#define SR_META_VD		1   /* only 1 VD per metadata block */
#define SR_META_DATA		1   /* only 1 metadata block per disk */
#define SR_META_FUDGE		32  /* save space at chunk beginning */
d213 3
@


1.7
log
@Add failure statistics per workunit.
Remove BIOC_SFAILED; we'll only use BIOC_SOFFLINE.
Call state change in interrupt handler when a chunk fails.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.6 2007/04/11 22:05:09 marco Exp $ */
d119 2
a120 2
#define SR_META_FUDGE		32  /* save some space at the end of chunk */
#define SR_META_VERSION		1 /* bump when sr_metadata changes */
@


1.6
log
@Add infrastructure to run with multiple openings.
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.5 2007/03/30 23:15:30 marco Exp $ */
d68 1
@


1.5
log
@Make volume state transitions work
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.4 2007/03/27 04:05:22 marco Exp $ */
d89 6
d104 5
a108 3
	/* index into all ios */
	/* XXX make this a list ? */
	struct sr_ccb		**swu_ios;
d224 1
a224 2
	struct sr_workunit	*sd_wu;
	struct sr_wu_list	sd_wu_freeq;
d226 4
@


1.4
log
@First stab at state transition code for volumes and chunks.
Minor cleanup as well.

prodded by jordan
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.3 2007/03/19 22:33:15 dlg Exp $ */
d52 1
a52 1
#define	SR_MAX_STATES		6
@


1.3
log
@the autoconf glue funcs (match/attach/etc) are only used inside softraid.c,
so prototype them there rather than in softraidvar.h.

shuffle these funcs a little bit while here to make it look more like
everything else.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.2 2007/03/19 14:33:28 dlg Exp $ */
d43 1
d52 1
d227 3
@


1.2
log
@attach softraid to the root of the device tree in a machine independant
way, rather than requiring some glue in each machines mainbus probe.

it is still commented out.

based on a discussion with miod@@ ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraidvar.h,v 1.1 2007/03/19 03:02:08 marco Exp $ */
a254 5

int		sr_probe(struct device *, void *, void *);
void		sr_attach(struct device *, struct device *, void *);
int		sr_detach(struct device *, int);
int		sr_activate(struct device *, enum devact);
@


1.1
log
@Add a new device that provides a framework for IO manipulation.  A very basic
implementation of a RAID 1 is included in this but it does not deal with
failures yet.  Disabled in GENERIC.

Suggestions from and ok beck@@ miod@@ krw@@ dlg@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a253 4
};

struct sr_attach_args {
	char 			*maa_name;
@

