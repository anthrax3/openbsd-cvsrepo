head	1.7;
access;
symbols
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	UBC:1.4.0.6
	UBC_SYNC_A:1.4
	SMP:1.4.0.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.7
date	2005.03.05.23.58.44;	author tdeval;	state dead;
branches;
next	1.6;

1.6
date	2004.04.08.16.08.21;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.15.02.38.38;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.08.06.33.38;	author tdeval;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2002.12.30.11.48.34;	author tdeval;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.13.21.35.11;	author tdeval;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.13.02.57.56;	author tdeval;	state Exp;
branches;
next	;

1.4.4.1
date	2004.06.05.23.12.57;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Clean up the tree from incomplete, unreliable and unsupported IEEE1394 code.
Ok deraadt@@, miod@@
@
text
@/*	$OpenBSD: sbp2.c,v 1.6 2004/04/08 16:08:21 henning Exp $	*/

/*
 * Copyright (c) 2002 Thierry Deval.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * sbp2.c
 *
 * Basic implementation of the ANSI NCITS 325-1998 Serial Bus Protocol2 (SBP-2).
 *
 * ANSI NCITS 325-1998
 * Information Technology - Serial Bus Protocol 2 (SBP-2)
 *
 * Defines a protocol for the transport of commands and data over high
 * performance serial bus, as specified in American National Standard for
 * High Performance Serial Bus, ANSI/IEEE 1394-1995. The transport protocol,
 * Serial Bus Protocol 2 or SBP-2, requires implementations to conform to the
 * requirements of the aforementioned standard as well as to International
 * Standard for Control and Status Register (CSR) Architecture for
 * Microcomputer Buses, ISO/IEC 13213:1994 (IEEE 1212-1994), and permits the
 * exchange of commands, data and status between initiators and targets
 * connected to Serial Bus.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/socket.h>
#ifdef	__NetBSD__
#include <sys/callout.h>
#else
#include <sys/timeout.h>
#endif
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#ifdef	__OpenBSD__
#include <sys/endian.h>
#endif

#if __NetBSD_Version__ >= 105010000 || !defined(__NetBSD__)
#include <uvm/uvm_extern.h>
#else
#include <vm/vm.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/rndvar.h>

#include <dev/ieee1394/ieee1394reg.h>
#include <dev/ieee1394/fwohcireg.h>
#include <dev/ieee1394/fwnodereg.h>
#include <dev/std/ieee1212reg.h>
#include <dev/std/sbp2reg.h>

#include <dev/ieee1394/ieee1394var.h>
#include <dev/ieee1394/fwohcivar.h>
#include <dev/ieee1394/fwnodevar.h>
#include <dev/std/ieee1212var.h>
#include <dev/std/sbp2var.h>

#if 0
void sbp2_print(struct p1212_dir *);
void sbp2_print_node(struct p1212_key *, void *);
#endif

void sbp2_login_send(struct ieee1394_abuf *, int);
void sbp2_status_resp(struct ieee1394_abuf *, int);
void sbp2_command_send(struct ieee1394_abuf *, int);
void sbp2_reconnect(struct ieee1394_softc *);
void sbp2_reconnect_send(struct ieee1394_abuf *, int);

#ifdef	SBP2_DEBUG
#include <sys/syslog.h>
extern int log_open;
int sbp2_oldlog;
#define	DPRINTF(x)	do {						\
	if (sbp2debug) {						\
		sbp2_oldlog = log_open; log_open = 1;			\
		addlog x; log_open = sbp2_oldlog;			\
	}								\
} while (0)
#define	DPRINTFN(n,x)	do {						\
	if (sbp2debug>(n)) {						\
		sbp2_oldlog = log_open; log_open = 1;			\
		addlog x; log_open = sbp2_oldlog;			\
	}								\
} while (0)
#ifdef	FW_MALLOC_DEBUG
#define	MPRINTF(x,y)	DPRINTF(("%s[%d]: %s 0x%08x\n",			\
			    __func__, __LINE__, (x), (u_int32_t)(y)))
#else	/* !FW_MALLOC_DEBUG */
#define	MPRINTF(x,y)
#endif	/* FW_MALLOC_DEBUG */

int	sbp2debug = 0;
#else	/* SBP2_DEBUG */
#define	DPRINTF(x)
#define	DPRINTFN(n,x)
#define	MPRINTF(x,y)
#endif	/* ! SBP2_DEBUG */

typedef struct sbp2_account {
	struct fwnode_softc	 *ac_softc;
	struct ieee1394_abuf	 *ac_status_ab;
	struct sbp2_task_management_orb *ac_mgmt_orb;
	struct sbp2_status_block *ac_status_block;
	void			 *ac_response_block;
	void			(*ac_cb)(void *,
					 struct sbp2_status_notification *);
	void			 *ac_cbarg;
	u_int64_t		  ac_mgmt_agent;
	u_int64_t		  ac_fetch_agent;
	u_int64_t		  ac_response;
	u_int64_t		  ac_status_fifo;
	u_int16_t		  ac_nodeid;
	u_int16_t		  ac_lun;
	u_int16_t		  ac_login;
	u_int16_t		  ac_reconnect_hold;
	u_int16_t		  ac_valid;
	SLIST_ENTRY(sbp2_account) ac_chain;
} sbp2_account;
static SLIST_HEAD(, sbp2_account) sbp2_ac_head;

typedef struct sbp2_orb_element {
	struct sbp2_account	 *elm_ac;
	struct ieee1394_abuf	 *elm_orb_ab;
	struct sbp2_command_orb	 *elm_orb;
	size_t			  elm_orblen;
	u_int32_t		  elm_hash;
	void			 *elm_data;
	size_t			  elm_datasize;
	void			(*elm_cb)(void *,
					  struct sbp2_status_notification *);
	void			 *elm_cbarg;
	TAILQ_ENTRY(sbp2_orb_element) elm_chain;
} sbp2_orb_element;
static TAILQ_HEAD(sbp2_orb_tq, sbp2_orb_element) sbp2_elm_head;

static int sbp2_ac_valid;

struct sbp2_account *sbp2_acfind(struct fwnode_softc *, int);
struct sbp2_orb_element *sbp2_elfind_hash(u_int32_t);
struct sbp2_orb_element *sbp2_elfind_orb(struct sbp2_command_orb *);
struct sbp2_orb_element *sbp2_elfind_first(struct sbp2_account *);
struct sbp2_orb_element *sbp2_elfind_last(struct sbp2_account *);

struct sbp2_account *
sbp2_acfind(struct fwnode_softc *sc, int lun)
{
	struct sbp2_account *ac;

	SLIST_FOREACH(ac, &sbp2_ac_head, ac_chain) {
		if (ac != NULL && ac->ac_softc == sc && ac->ac_lun == lun)
			break;
	}

	return (ac);
}

struct sbp2_orb_element *
sbp2_elfind_hash(u_int32_t hash)
{
	struct sbp2_orb_element *elm;

	TAILQ_FOREACH(elm, &sbp2_elm_head, elm_chain) {
		if (elm->elm_hash == hash)
			break;
	}

	return (elm);
}

struct sbp2_orb_element *
sbp2_elfind_orb(struct sbp2_command_orb *orb)
{
	struct sbp2_orb_element *elm;

	TAILQ_FOREACH(elm, &sbp2_elm_head, elm_chain) {
		if (elm->elm_orb == orb)
			break;
	}

	return (elm);
}

struct sbp2_orb_element *
sbp2_elfind_first(struct sbp2_account *ac)
{
	struct sbp2_orb_element *elm;

	TAILQ_FOREACH(elm, &sbp2_elm_head, elm_chain) {
		if (elm->elm_ac == ac)
			break;
	}

	return (elm);
}

struct sbp2_orb_element *
sbp2_elfind_last(struct sbp2_account *ac)
{
	struct sbp2_orb_element *elm;

	TAILQ_FOREACH_REVERSE(elm, &sbp2_elm_head, sbp2_orb_tq, elm_chain) {
		if (elm->elm_ac == ac)
			break;
	}

	return (elm);
}

void
sbp2_print_data(struct p1212_data *data)
{
	struct p1212_key *key = (struct p1212_key *)data;

	switch (key->key_value) {
	case SBP2_KEYVALUE_Command_Set:
		DPRINTF(("SBP2 Command Set: "));
		if (key->val == 0x104D8)
			DPRINTF(("SCSI 2\n"));
		else
			DPRINTF(("0x%08x\n", key->val));
		break;
	case SBP2_KEYVALUE_Unit_Characteristics:
		DPRINTF(("SBP2 Unit Characteristics: 0x%08x\n", key->val));
		break;
	case SBP2_KEYVALUE_Command_Set_Revision:
		DPRINTF(("SBP2 Command Set Revision: 0x%08x\n", key->val));
		break;
	case SBP2_KEYVALUE_Command_Set_Spec_Id:
		DPRINTF(("SBP2 Command Set Spec Id: 0x%08x\n", key->val));
		break;
	case SBP2_KEYVALUE_Firmware_Revision:
		DPRINTF(("SBP2 Firmware Revision: 0x%08x\n", key->val));
		break;
	case SBP2_KEYVALUE_Reconnect_Timeout:
		DPRINTF(("SBP2 Reconnect Timeout: 0x%08x\n", key->val));
		break;
	case SBP2_KEYVALUE_Unit_Unique_Id:
		DPRINTF(("SBP2 Unit Unique Id: 0x%08x\n", key->val));
		break;
	case P1212_KEYVALUE_Unit_Dependent_Info:
		if (key->key_type == P1212_KEYTYPE_Immediate)
			DPRINTF(("SBP2 Logical Unit Number: 0x%08x\n", key->val));
		else if (key->key_type == P1212_KEYTYPE_Offset)
			DPRINTF(("SBP2 Management Agent: 0x%08x\n", key->val));
		break;
	default:
		break;
	}
}

void
sbp2_print_dir(struct p1212_dir *dir)
{
	u_int8_t dir_type = ((struct p1212_key *)dir)->key_type;

	switch(dir_type) {
	case SBP2_KEYVALUE_Logical_Unit_Directory:
		DPRINTF(("Logical Unit "));
		break;
	default:
		break;
	}
}

int
sbp2_init(struct fwnode_softc *sc, struct p1212_dir *unitdir)
{
	struct p1212_key **key;
	struct p1212_dir *dir;
	struct sbp2_account *ac;
	int loc;

#ifdef	SBP2_DEBUG
	if (sbp2debug > 1)
		p1212_print(unitdir);
#endif

	key = p1212_find(unitdir, P1212_KEYTYPE_Offset,
	    SBP2_KEYVALUE_Management_Agent, 0);
	if (key == NULL) return (-1);

	if (!sbp2_ac_valid) {
		SLIST_INIT(&sbp2_ac_head);
		TAILQ_INIT(&sbp2_elm_head);
		sbp2_ac_valid = 1;
	}

	MALLOC(ac, struct sbp2_account *, sizeof(*ac), M_1394CTL, M_WAITOK);
	MPRINTF("MALLOC(1394CTL)", ac);
	bzero(ac, sizeof(*ac));

	loc = key[0]->val;
	DPRINTF(("%s: Node %d (sc 0x%08x):"
	    " UID %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
	    __func__, sc->sc_sc1394.sc1394_node_id, sc,
	    sc->sc_sc1394.sc1394_guid[0], sc->sc_sc1394.sc1394_guid[1],
	    sc->sc_sc1394.sc1394_guid[2], sc->sc_sc1394.sc1394_guid[3],
	    sc->sc_sc1394.sc1394_guid[4], sc->sc_sc1394.sc1394_guid[5],
	    sc->sc_sc1394.sc1394_guid[6], sc->sc_sc1394.sc1394_guid[7]));
	free(key, M_DEVBUF);
	MPRINTF("free(DEVBUF)", key);
	key = NULL;	/* XXX */

	ac->ac_softc = sc;
	ac->ac_nodeid = sc->sc_sc1394.sc1394_node_id;
	ac->ac_login = 0;
	ac->ac_mgmt_agent = CSR_BASE + 4 * loc;
	DPRINTF(("%s: mgmt_agent = 0x%012qx\n", __func__, ac->ac_mgmt_agent));

	if ((key = p1212_find(unitdir, P1212_KEYTYPE_Immediate,
	    SBP2_KEYVALUE_Logical_Unit_Number, 0)) != NULL) {
		ac->ac_lun = (*key)->val & 0xFFFF;
		free(key, M_DEVBUF);
		MPRINTF("free(DEVBUF)", key);
		key = NULL;	/* XXX */
	} else if ((key = p1212_find(unitdir, P1212_KEYTYPE_Directory,
	    SBP2_KEYVALUE_Logical_Unit_Directory, 0)) != NULL) {
		dir = (struct p1212_dir *)*key;
		free(key, M_DEVBUF);
		MPRINTF("free(DEVBUF)", key);
		key = NULL;	/* XXX */
		key = p1212_find(dir, P1212_KEYTYPE_Immediate,
		    SBP2_KEYVALUE_Logical_Unit_Number, 0);
		if (key != NULL) {
			ac->ac_lun = (*key)->val & 0xFFFF;
			free(key, M_DEVBUF);
			MPRINTF("free(DEVBUF)", key);
			key = NULL;	/* XXX */
		}
	}
	DPRINTF(("%s: lun = %04x\n", __func__, ac->ac_lun));

	SLIST_INSERT_HEAD(&sbp2_ac_head, ac, ac_chain);

	return (ac->ac_lun);
}

void
sbp2_clean(struct fwnode_softc *sc, struct p1212_dir *unitdir, int logout)
{
	struct sbp2_account *ac;
	struct sbp2_orb_element *elm;
	struct p1212_key **key;
	struct p1212_dir **dir,*d;
	int lun,i;

	DPRINTF(("%s: start\n", __func__));

	if ((key = p1212_find(unitdir, P1212_KEYTYPE_Immediate,
	    SBP2_KEYVALUE_Logical_Unit_Number, 0)) != NULL) {
		lun = (*key)->val & 0xFFFF;
		if ((ac = sbp2_acfind(sc, lun)) != NULL) {
			DPRINTF(("%s: clean lun %d\n", __func__, lun));
			i = 0;
			TAILQ_FOREACH_REVERSE(elm, &sbp2_elm_head, sbp2_orb_tq,
			    elm_chain) {
				DPRINTF(("%s%d", i++?" ":"", i));
				if (elm != NULL && elm->elm_ac == ac) {
					TAILQ_REMOVE(&sbp2_elm_head, elm,
					    elm_chain);
					FREE(elm, M_1394CTL);
					MPRINTF("FREE(1394CTL)", elm);
					//elm = NULL;	/* XXX */
				}
			}
			if (i) DPRINTF(("\n"));
			SLIST_REMOVE(&sbp2_ac_head, ac, sbp2_account, ac_chain);
			if (ac->ac_status_ab) {
				sc->sc1394_unreg(ac->ac_status_ab, FALSE);
				FREE(ac->ac_status_ab, M_1394DATA);
				MPRINTF("FREE(1394DATA)", ac->ac_status_ab);
				ac->ac_status_ab = NULL;	/* XXX */
			}
			if (ac->ac_status_block) {
				FREE(ac->ac_status_block, M_1394DATA);
				MPRINTF("FREE(1394DATA)", ac->ac_status_block);
				ac->ac_status_block = NULL;	/* XXX */
			}
			FREE(ac, M_1394CTL);
			MPRINTF("FREE(1394CTL)", ac);
			ac = NULL;	/* XXX */
		}
		free(key, M_DEVBUF);
		MPRINTF("free(DEVBUF)", key);
		key = NULL;	/* XXX */
	} else if ((key = p1212_find(unitdir, P1212_KEYTYPE_Directory,
	    SBP2_KEYVALUE_Logical_Unit_Directory, 0)) != NULL) {
		dir = (struct p1212_dir **)key;
		i = 0;
		d = dir[i++];
		while (d != NULL) {
			key = p1212_find(d, P1212_KEYTYPE_Immediate,
			    SBP2_KEYVALUE_Logical_Unit_Number, 0);
			if (key != NULL) {
				lun = (*key)->val & 0xFFFF;
				if ((ac = sbp2_acfind(sc, lun)) != NULL) {
					DPRINTF(("%s: clean lun %d\n",
					    __func__, lun));
					TAILQ_FOREACH(elm, &sbp2_elm_head,
					    elm_chain) {
						if (elm != NULL &&
						    elm->elm_ac == ac) {
							FREE(elm, M_1394CTL);
							MPRINTF("FREE(1394CTL)", elm);
							elm = NULL;	/* XXX */
						}
					}
					SLIST_REMOVE(&sbp2_ac_head, ac,
					    sbp2_account, ac_chain);
					if (ac->ac_status_ab) {
						sc->sc1394_unreg(ac
						    ->ac_status_ab, FALSE);
						FREE(ac->ac_status_ab,
						    M_1394DATA);
						MPRINTF("FREE(1394DATA)", ac->ac_status_ab);
						ac->ac_status_ab = NULL;	/* XXX */
					}
					if (ac->ac_status_block) {
						FREE(ac->ac_status_block,
						    M_1394DATA);
						MPRINTF("FREE(1394DATA)", ac->ac_status_block);
						ac->ac_status_block = NULL;	/* XXX */
					}
					FREE(ac, M_1394CTL);
					MPRINTF("FREE(1394CTL)", ac);
					ac = NULL;	/* XXX */
				}
				free(key, M_DEVBUF);
				MPRINTF("free(DEVBUF)", key);
				key = NULL;	/* XXX */
			}
			d = dir[i++];
		}
		free(dir, M_DEVBUF);
		MPRINTF("free(DEVBUF)", dir);
		dir = NULL;	/* XXX */
	} else {
		DPRINTF(("%s: no LUN in configrom 0x%08x ???\n", __func__,
		    (u_int32_t)sc->sc_configrom->root));
	}

	DPRINTF(("%s: end\n", __func__));
}

void
sbp2_login(struct fwnode_softc *sc, struct sbp2_login_orb *orb,
    void (*cb)(void *, struct sbp2_status_notification *), void *cbarg)
{
	struct ieee1394_abuf *ab, *ab2;
	struct sbp2_account *ac;
	u_int64_t addr;

	if ((ac = sbp2_acfind(sc, ntohs(orb->lun))) == NULL) {
		DPRINTF(("%s: destination not initialized\n", __func__));
		return;
	}

	DPRINTF(("%s:", __func__));

	ac->ac_mgmt_orb = (struct sbp2_task_management_orb *)orb;
	if (cb != NULL) {
		ac->ac_cb = cb;
		ac->ac_cbarg = cbarg;
	}

	MALLOC(ab, struct ieee1394_abuf *, sizeof(*ab), M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", ab);
	bzero(ab, sizeof(*ab));
	MALLOC(ab2, struct ieee1394_abuf *, sizeof(*ab2), M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", ab2);
	bzero(ab2, sizeof(*ab2));

	ab->ab_req = (struct ieee1394_softc *)sc;
	ab->ab_length = 8;
	ab->ab_retlen = 0;
	ab->ab_cb = NULL;
	ab->ab_cbarg = NULL;
	ab->ab_addr = ac->ac_mgmt_agent;
	ab->ab_tcode = IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK;

	ab->ab_data = malloc(8, M_1394DATA, M_WAITOK);
	MPRINTF("malloc(1394DATA)", ab->ab_data);

	addr = SBP2_MGMT_ORB +
	    ((u_int64_t)ac->ac_nodeid << SBP2_NODE_SHIFT) +
	    ((u_int64_t)ac->ac_lun << SBP2_LUN_SHIFT);
	ab->ab_data[0] = htonl((u_int32_t)(addr >> 32));
	ab->ab_data[1] = htonl((u_int32_t)(addr & 0xFFFFFFFF));
	DPRINTF((" CSR = 0x%012qx", ac->ac_mgmt_agent));
	DPRINTF((", ORB = 0x%012qx\n", addr));

	ab2->ab_length = sizeof(struct sbp2_login_orb);
	ab2->ab_tcode = IEEE1394_TCODE_READ_REQUEST_DATABLOCK;
	ab2->ab_retlen = 0;
	ab2->ab_data = NULL;
	ab2->ab_addr = addr;
	ab2->ab_cb = sbp2_login_send;
	ab2->ab_cbarg = ac;
	ab2->ab_req = (struct ieee1394_softc *)sc;

	sc->sc1394_inreg(ab2, FALSE);
	sc->sc1394_write(ab);
	DPRINTF(("%s: LOGIN submitted\n", __func__));
}

void
sbp2_login_send(struct ieee1394_abuf *ab, int rcode)
{
	struct fwnode_softc *sc = (struct fwnode_softc *)ab->ab_req;
	struct sbp2_account *ac = ab->ab_cbarg;
	struct sbp2_login_orb *login_orb;
	struct ieee1394_abuf *stat_ab, *resp_ab, *orb_ab;
	u_int64_t addr;
#ifdef	SBP2_DEBUG
	int i;
#endif	/* SBP2_DEBUG */

	/* Got a read so allocate the buffer and write out the response. */

	if (rcode || (ac == NULL)) {
		DPRINTF(("%s: Bad return code: %d\n", __func__, rcode));
		if (ab->ab_data) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;	/* XXX */
		}
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
		return;
	}

	MALLOC(orb_ab, struct ieee1394_abuf *, sizeof(*orb_ab),
	    M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", orb_ab);
	bcopy(ab, orb_ab, sizeof(*orb_ab));

	sc->sc1394_unreg(ab, FALSE);

	if (ab->ab_data) {
		free(ab->ab_data, M_1394DATA);
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;	/* XXX */
		orb_ab->ab_data = NULL;
	}
	FREE(ab, M_1394DATA);
	MPRINTF("FREE(1394DATA)", ab);
	ab = NULL;	/* XXX */

	MALLOC(resp_ab, struct ieee1394_abuf *, sizeof(*resp_ab),
	    M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", resp_ab);
	MALLOC(stat_ab, struct ieee1394_abuf *, sizeof(*stat_ab),
	    M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", stat_ab);
	bzero(resp_ab, sizeof(*resp_ab));
	bzero(stat_ab, sizeof(*stat_ab));

	/* Fill in a login packet. First 2 quads are 0 for password. */
	login_orb = (struct sbp2_login_orb *)ac->ac_mgmt_orb;

	/* Addr for response. */
	addr = SBP2_RESP_BLOCK +
	    ((u_int64_t)ac->ac_nodeid << SBP2_NODE_SHIFT) +
	    ((u_int64_t)ac->ac_lun << SBP2_LUN_SHIFT);
	resp_ab->ab_length = sizeof(struct sbp2_login_response);
	resp_ab->ab_tcode = IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK;
	resp_ab->ab_retlen = 0;
	resp_ab->ab_data = NULL;
	resp_ab->ab_addr = addr;
	resp_ab->ab_cb = sbp2_status_resp;
	resp_ab->ab_cbarg = ac;
	resp_ab->ab_req = orb_ab->ab_req;

	login_orb->login_response.hi = htons((u_int16_t)(addr >> 32));
	login_orb->login_response.lo = htonl((u_int32_t)(addr & 0xFFFFFFFF));
	DPRINTF(("%s: RESP_ORB = 0x%012qx", __func__, addr));

	sc->sc1394_inreg(resp_ab, FALSE);

	/* Set notify and exclusive use bits. */
	login_orb->options = htons(0x8000);
	login_orb->lun = htons(ac->ac_lun);

	/* Password length (0) and login response length (16) */
	login_orb->password_length = htons(0);
	login_orb->login_response_length = htons(16);

	/* Addr for status packet. */
#if 0
	addr = SBP2_STATUS_BLOCK +
	    ((u_int64_t)ac->ac_nodeid << SBP2_NODE_SHIFT) +
	    ((u_int64_t)ac->ac_lun << SBP2_LUN_SHIFT);
#else
	addr = SBP2_STATUS_BLOCK;
#endif
	stat_ab->ab_length = sizeof(struct sbp2_status_block);
	stat_ab->ab_tcode = IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK;
	stat_ab->ab_retlen = 0;
	stat_ab->ab_data = NULL;
	stat_ab->ab_addr = addr;
	stat_ab->ab_cb = sbp2_status_resp;
	stat_ab->ab_cbarg = ac;
	stat_ab->ab_req = orb_ab->ab_req;

	ac->ac_status_ab = stat_ab;
	sc->sc1394_inreg(stat_ab, FALSE);

	login_orb->status_fifo.hi = htons((u_int16_t)(addr >> 32));
	login_orb->status_fifo.lo = htonl((u_int32_t)(addr & 0xFFFFFFFF));
	DPRINTF((", STATUS_ORB = 0x%012qx", addr));

	orb_ab->ab_data = malloc(sizeof(*login_orb), M_1394DATA, M_WAITOK);
	MPRINTF("malloc(1394DATA)", orb_ab->ab_data);
	bcopy(login_orb, orb_ab->ab_data, sizeof(*login_orb));
#ifdef	SBP2_DEBUG
	for (i = 0; i < (sizeof(*login_orb) / 4); i++) {
		if ((i % 8) == 0) DPRINTFN(2, ("\n   "));
		DPRINTFN(2, (" %08x", ntohl(orb_ab->ab_data[i])));
	}
#endif	/* SBP2_DEBUG */
	DPRINTF(("\n"));

	orb_ab->ab_retlen = 0;
	orb_ab->ab_cb = NULL;
	orb_ab->ab_cbarg = NULL;
	orb_ab->ab_tcode = IEEE1394_TCODE_READ_RESPONSE_DATABLOCK;
	orb_ab->ab_length = sizeof(struct sbp2_login_orb);

	sc->sc1394_write(orb_ab);
}

void
sbp2_status_resp(struct ieee1394_abuf *ab, int rcode)
{
	struct fwnode_softc *sc = (struct fwnode_softc *)ab->ab_req;
	struct sbp2_account *ac = ab->ab_cbarg;
	struct sbp2_login_response *login_resp;
	struct sbp2_status_block *cmd_status;
	struct sbp2_status_notification *status_notify;
	struct sbp2_orb_element *elm;
	int resp, src, status, len, dead;
	u_int64_t csr, stat_addr = 0;
#ifdef	SBP2_DEBUG
	int i;
#endif	/* SBP2_DEBUG */

	if (!ac) {
		DPRINTF(("%s: Callback Arg is NULL\n", __func__));

		if (ab->ab_data) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;	/* XXX */
		}
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
		return;
	}
#if 0
	stat_addr = SBP2_STATUS_BLOCK +
	    ((u_int64_t)ac->ac_nodeid << SBP2_NODE_SHIFT) +
	    ((u_int64_t)ac->ac_lun << SBP2_LUN_SHIFT);
#else
	stat_addr = SBP2_STATUS_BLOCK;
#endif

	if (rcode) {
		DPRINTF(("%s: Bad return code: %d\n", __func__, rcode));

		if (ab->ab_data) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;	/* XXX */
		}
		if (ab->ab_addr != stat_addr) {
			FREE(ab, M_1394DATA);
			MPRINTF("FREE(1394DATA)", ab);
			ab = NULL;	/* XXX */
		}
		return;
	}

#ifdef	SBP2_DEBUG
	DPRINTF(("%s: CSR = 0x%012qx, ac = 0x%08x", __func__,
	    (quad_t)ab->ab_addr, (u_int32_t)ac));
	for (i = 0; i < (ab->ab_retlen / 4); i++) {
		if ((i % 8) == 0) DPRINTFN(2, ("\n   "));
		DPRINTFN(2, (" %08x", ntohl(ab->ab_data[i])));
	}
	DPRINTF(("\n"));
#endif	/* SBP2_DEBUG */

	if (ab->ab_addr == stat_addr) {
		MALLOC(cmd_status, struct sbp2_status_block *,
		    sizeof(*cmd_status), M_1394DATA, M_WAITOK);
		MPRINTF("MALLOC(1394DATA)", cmd_status);
		bzero(cmd_status, sizeof(*cmd_status));
		bcopy(ab->ab_data, cmd_status, ab->ab_retlen);

		/* Reset status ab for subsequent notifications. */
		ab->ab_retlen = 0;
		ab->ab_length = sizeof(*cmd_status);

		src = (cmd_status->flags >> 6) & 0x3;
		resp = (cmd_status->flags >> 4) & 0x3;
		dead = (cmd_status->flags >> 3) & 0x1;
		len = cmd_status->flags & 0x7;
		status = cmd_status->status;
		csr = ((u_int64_t)(ntohs(cmd_status->orb_offset_hi)) << 32) +
		    ntohl(cmd_status->orb_offset_lo);
		DPRINTF(("  status -- src: %d, resp: %d, dead: %d, len: %d, "
		    "status: %d\n  status -- csr: 0x%012qx\n", src, resp, dead,
		    (len + 1) * 4, status, (quad_t)csr));
		if (ac->ac_valid & 4) {
			DPRINTF(("Notify callback\n"));
			elm = sbp2_elfind_hash((u_int32_t)(csr >>
			    (SBP2_NODE_SHIFT - 8 * sizeof(u_int32_t))));
			if (elm == NULL) {
				DPRINTF(("%s: no element found for hash"
				    " 0x%08x\n", __func__,
				    (u_int32_t)(csr >> (SBP2_NODE_SHIFT -
				     8 * sizeof(u_int32_t)))));
				FREE(cmd_status, M_1394DATA);
				MPRINTF("FREE(1394DATA)", cmd_status);
				cmd_status = NULL;	/* XXX */
				goto leave;
			}
			MALLOC(status_notify, struct sbp2_status_notification *,
			    sizeof(*status_notify), M_1394CTL, M_WAITOK);
			MPRINTF("MALLOC(1394CTL)", status_notify);
			status_notify->origin = elm->elm_orb;
			status_notify->status = cmd_status;
			elm->elm_cb(elm->elm_cbarg, status_notify);
			FREE(status_notify, M_1394CTL);
			MPRINTF("FREE(1394CTL)", status_notify);
			status_notify = NULL;	/* XXX */
		} else if (((src & 2) == 0) && (resp == 0) && (dead == 0) &&
		    (status == 0) && (csr == (SBP2_MGMT_ORB +
		     ((u_int64_t)ac->ac_nodeid << SBP2_NODE_SHIFT) +
		     ((u_int64_t)ac->ac_lun << SBP2_LUN_SHIFT)))) {
			if (ac->ac_status_block) {
				FREE(ac->ac_status_block, M_1394DATA);
				MPRINTF("FREE(1394DATA)", ac->ac_status_block);
				ac->ac_status_block = NULL;	/* XXX */
			}
			ac->ac_status_block = cmd_status;
			DPRINTF(("Got a valid status\n"));
			ac->ac_valid |= 2;
		} else {
			FREE(cmd_status, M_1394DATA);
			MPRINTF("FREE(1394DATA)", cmd_status);
			cmd_status = NULL;	/* XXX */
		}

	} else if (ab->ab_addr == (SBP2_RESP_BLOCK +
	    ((u_int64_t)ac->ac_nodeid << SBP2_NODE_SHIFT) +
	    ((u_int64_t)ac->ac_lun << SBP2_LUN_SHIFT))) {
		login_resp = (struct sbp2_login_response *)ab->ab_data;

		ac->ac_response_block = login_resp;
		ac->ac_login = ntohs(login_resp->login_id);
		ac->ac_fetch_agent =
		    ((u_int64_t)(ntohs(login_resp->fetch_agent.hi)) << 32) +
		    ntohl(login_resp->fetch_agent.lo);
		ac->ac_reconnect_hold = ntohs(login_resp->reconnect_hold);

		sc->sc_sc1394.sc1394_callback.cb1394_busreset = sbp2_reconnect;

		DPRINTF(("Got a valid response\n"));
		DPRINTF(("Login ID : 0x%04x, Command Agent : 0x%012qx\n",
		    ac->ac_login, ac->ac_fetch_agent));

		ac->ac_valid |= 1;
	}
	if ((ac->ac_valid & 7) == 3) {
		DPRINTF(("Valid response : notify callback\n"));
		if (ac->ac_cb != NULL) {
			MALLOC(status_notify, struct sbp2_status_notification *,
			    sizeof(*status_notify), M_1394CTL, M_WAITOK);
			MPRINTF("MALLOC(1394CTL)", status_notify);
			status_notify->origin = ac->ac_mgmt_orb;
			status_notify->status = cmd_status;
			ac->ac_cb(ac->ac_cbarg, status_notify);
			FREE(status_notify, M_1394CTL);
			MPRINTF("FREE(1394CTL)", status_notify);
			status_notify = NULL;	/* XXX */
		}
		ac->ac_valid |= 4;
	}

	/*
	 * Leave the handler for status since unsolicited status will get sent
	 * to the addr specified in the login packet.
	 */

leave:
	if (ab->ab_data != NULL) {
		free(ab->ab_data, M_1394DATA);
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;
	}

	if (ab->ab_addr != stat_addr) {
		sc->sc1394_unreg(ab, FALSE);
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
	}

}

void
sbp2_query_logins(struct fwnode_softc *sc, struct sbp2_query_logins_orb *orb,
    void (*cb)(void *, struct sbp2_status_notification *), void *arg)
{
}

void
sbp2_command_add(struct fwnode_softc *sc, int lun,
    struct sbp2_command_orb *orb, int qlen, void *data,
    void (*cb)(void *, struct sbp2_status_notification *), void *cbarg)
{
	struct ieee1394_abuf *ab, *ab2;
	struct sbp2_account *ac;
	struct sbp2_orb_element *elm, *elast;
	u_int64_t addr;
	u_int32_t ehash;

	if ((ac = sbp2_acfind(sc, lun)) == NULL) {
		DPRINTF(("%s: destination not initialized\n", __func__));
		return;
	}

	DPRINTF(("%s:\n", __func__));

	/* Initialise orb address hash. */
	do {
		ehash = arc4random();
	} while (sbp2_elfind_hash(ehash) != TAILQ_END(&sbp2_elm_head));

	addr = SBP2_CMD_ORB +
	    ((u_int64_t)sc->sc_sc1394.sc1394_node_id << SBP2_NODE_SHIFT) +
	    ((u_int64_t)ehash << (SBP2_NODE_SHIFT - 8 * sizeof(u_int32_t)));
	orb->next_orb.flag = htons(SBP2_NULL_ORB);

	MALLOC(elm, struct sbp2_orb_element *, sizeof(*elm),
	    M_1394CTL, M_WAITOK);
	MPRINTF("MALLOC(1394CTL)", elm);
	bzero(elm, sizeof(*elm));
	elm->elm_hash = ehash;
	elm->elm_orb = orb;
	elm->elm_orblen = qlen;
	elm->elm_data = data;
	elm->elm_datasize = ntohs(orb->data_size);
	elm->elm_cb = cb;
	elm->elm_cbarg = cbarg;
	TAILQ_INSERT_TAIL(&sbp2_elm_head, elm, elm_chain);

	MALLOC(ab2, struct ieee1394_abuf *, sizeof(*ab2), M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", ab2);
	bzero(ab2, sizeof(*ab2));

	ab2->ab_length = sizeof(u_int32_t) * qlen;
	ab2->ab_tcode = IEEE1394_TCODE_READ_REQUEST_DATABLOCK;
	ab2->ab_retlen = 0;
	ab2->ab_data = NULL;
	ab2->ab_addr = addr;
	ab2->ab_cb = sbp2_command_send;
	ab2->ab_cbarg = ac;
	ab2->ab_req = (struct ieee1394_softc *)sc;

	elm->elm_orb_ab = ab2;
	sc->sc1394_inreg(ab2, FALSE);

	elast = sbp2_elfind_last(ac);
	if (elast != TAILQ_END(&sbp2_elm_head)) {
		DPRINTF(("%s: chaining to orb 0x%08x", __func__,
		    elast->elm_orb));
		elast->elm_orb->next_orb.flag = 0;
		elast->elm_orb->next_orb.hi = htons((u_int16_t)(addr >> 32));
		elast->elm_orb->next_orb.lo =
		    htonl((u_int32_t)(addr & 0xFFFFFFFF));
		sbp2_agent_tickle(sc, lun);
	} else {
		MALLOC(ab, struct ieee1394_abuf *, sizeof(*ab),
		    M_1394DATA, M_WAITOK);
		MPRINTF("MALLOC(1394DATA)", ab);
		bzero(ab, sizeof(*ab));

		ab->ab_req = (struct ieee1394_softc *)sc;
		ab->ab_length = 8;
		ab->ab_retlen = 0;
		ab->ab_cb = NULL;
		ab->ab_cbarg = NULL;
		ab->ab_addr = ac->ac_fetch_agent + SBP2_ORB_POINTER;
		ab->ab_tcode = IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK;

		ab->ab_data = malloc(8, M_1394DATA, M_WAITOK);
		MPRINTF("malloc(1394DATA)", ab->ab_data);
		ab->ab_data[0] = htonl((u_int32_t)(addr >> 32));
		ab->ab_data[1] = htonl((u_int32_t)(addr & 0xFFFFFFFF));
		ac->ac_valid |= 8;

		sbp2_agent_reset(sc, lun);

		DPRINTF(("%s: CSR = 0x%012qx", __func__, ab->ab_addr));
		sc->sc1394_write(ab);
	}

	DPRINTF((", ORB = 0x%012qx", addr));
	DPRINTF((", orb = 0x%08x", (u_int32_t)orb));
	DPRINTF((", ac = 0x%08x\n", (u_int32_t)ac));
	DPRINTF(("%s: COMMAND submitted\n", __func__));

	return;
}

void
sbp2_command_del(struct fwnode_softc *sc, int lun, struct sbp2_command_orb *orb)
{
	struct sbp2_account *ac;
	struct sbp2_orb_element *elm;

	if ((ac = sbp2_acfind(sc, lun)) == NULL) {
		DPRINTF(("%s: destination not initialized\n", __func__));
		return;
	}

	DPRINTF(("%s:", __func__));

	if ((elm = sbp2_elfind_orb(orb)) == TAILQ_END(&sbp2_elm_head)) {
#ifdef	SBP2_DEBUG
		DPRINTF((" ORB not found: 0x%08x\n", (u_int32_t)orb));
#endif	/* SBP2_DEBUG */
		return;
	}

	DPRINTF((" orb=0x%08x hash=0x%08x len=%d data=0x%08x size=%d\n",
	    (u_int32_t)(elm->elm_orb), elm->elm_hash, elm->elm_orblen,
	    (u_int32_t)(elm->elm_data), elm->elm_datasize));

	if (elm->elm_orb_ab != NULL) {
		sc->sc1394_unreg(elm->elm_orb_ab, FALSE);
		if (elm->elm_orb_ab->ab_data != NULL) {
			free(elm->elm_orb_ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", elm->elm_orb_ab->ab_data);
			elm->elm_orb_ab->ab_data = NULL;	/* XXX */
		}
		FREE(elm->elm_orb_ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", elm->elm_orb_ab);
		elm->elm_orb_ab = NULL;	/* XXX */
	}

	TAILQ_REMOVE(&sbp2_elm_head, elm, elm_chain);
	FREE(elm, M_1394CTL);
	MPRINTF("FREE(1394CTL)", elm);
	elm = NULL;	/* XXX */

	if (sbp2_elfind_last(ac) == TAILQ_END(&sbp2_elm_head))
		ac->ac_valid &= ~8;
}

void
sbp2_command_send(struct ieee1394_abuf *ab, int rcode)
{
	struct fwnode_softc *sc = (struct fwnode_softc *)ab->ab_req;
	struct sbp2_account *ac = ab->ab_cbarg;
	struct sbp2_orb_element *elm;
	struct ieee1394_abuf *cmd_ab;
	int i;

	/* Got a read so allocate the buffer and write out the response. */

	if (rcode || (ac == NULL)) {
#ifdef	SBP2_DEBUG
		DPRINTF(("%s: Bad return code: %d\n", __func__, rcode));
#endif	/* SBP2_DEBUG */
		if (ab->ab_data) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;	/* XXX */
		}
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
		return;
	}

	if (ab->ab_data != NULL) {
		free(ab->ab_data, M_1394DATA);
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;
	}

	if ((elm = sbp2_elfind_hash((u_int32_t)(ab->ab_addr >>
	     (SBP2_NODE_SHIFT - 8 * sizeof(u_int32_t)))))
	    == TAILQ_END(&sbp2_elm_head)) {
#ifdef	SBP2_DEBUG
		DPRINTF(("%s: ORB not found: 0x%012qx\n", __func__,
		    ab->ab_addr));
#endif	/* SBP2_DEBUG */
		if (ab->ab_data != NULL) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;	/* XXX */
		}
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
		return;
	}

	DPRINTF(("%s: orb=0x%08x hash=0x%08x len=%d data=0x%08x size=%d\n",
	    __func__, (u_int32_t)(elm->elm_orb), elm->elm_hash,
	    elm->elm_orblen, (u_int32_t)(elm->elm_data), elm->elm_datasize));

	MALLOC(cmd_ab, struct ieee1394_abuf *, sizeof(*cmd_ab),
	    M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", cmd_ab);
	bcopy(ab, cmd_ab, sizeof(*cmd_ab));

	cmd_ab->ab_retlen = 0;
	cmd_ab->ab_cb = NULL;
	cmd_ab->ab_cbarg = NULL;
	cmd_ab->ab_tcode = IEEE1394_TCODE_READ_RESPONSE_DATABLOCK;
	cmd_ab->ab_length = ab->ab_retlen;

	cmd_ab->ab_data = malloc(elm->elm_orblen * 4, M_1394DATA, M_WAITOK);
	MPRINTF("malloc(1394DATA)", cmd_ab->ab_data);
	bcopy(elm->elm_orb, cmd_ab->ab_data, elm->elm_orblen * 4);
	for (i = 0; i < elm->elm_orblen; i++) {
		if ((i % 8) == 0) DPRINTF(("   "));
		DPRINTF((" %08x", ntohl(cmd_ab->ab_data[i])));
		if ((i % 8) == 7 && i != (elm->elm_orblen - 1)) DPRINTF(("\n"));
	}
	DPRINTF(("\n"));

	sc->sc1394_write(cmd_ab);
}

void
sbp2_reconnect(struct ieee1394_softc *sc)
{
	struct ieee1394_abuf *ab, *orb_ab, *stat_ab;
	struct sbp2_account *ac;
	struct sbp2_reconnect_orb *orb;
	struct fwnode_softc *fwsc = (struct fwnode_softc *)sc;
	u_int16_t old_nodeid;
	u_int64_t addr;

	DPRINTF(("%s:", __func__));

	SLIST_FOREACH(ac, &sbp2_ac_head, ac_chain) {
		if (ac != NULL && ac->ac_softc == fwsc) {

			MALLOC(ab, struct ieee1394_abuf *, sizeof(*ab),
			    M_1394DATA, M_NOWAIT);
			MPRINTF("MALLOC(1394DATA)", ab);
			if (!ab) {
				printf("%s: memory allocation failure.\n",
				    __func__);
				return;
			}
			bzero(ab, sizeof(*ab));
			ab->ab_data = malloc(8, M_1394DATA, M_NOWAIT);
			MPRINTF("malloc(1394DATA)", ab->ab_data);
			if (!ab->ab_data) {
				printf("%s: memory allocation failure.\n",
				    __func__);
				FREE(ab, M_1394DATA);
				MPRINTF("FREE(1394DATA)", ab);
				return;
			}
			MALLOC(orb_ab, struct ieee1394_abuf *, sizeof(*orb_ab),
			    M_1394DATA, M_NOWAIT);
			MPRINTF("MALLOC(1394DATA)", orb_ab);
			if (!orb_ab) {
				printf("%s: memory allocation failure.\n",
				    __func__);
				free(ab->ab_data, M_1394DATA);
				MPRINTF("free(1394DATA)", ab->ab_data);
				FREE(ab, M_1394DATA);
				MPRINTF("FREE(1394DATA)", ab);
				return;
			}
			bzero(orb_ab, sizeof(*orb_ab));
			MALLOC(stat_ab, struct ieee1394_abuf *,
			    sizeof(*stat_ab), M_1394DATA, M_NOWAIT);
			MPRINTF("MALLOC(1394DATA)", stat_ab);
			if (!stat_ab) {
				printf("%s: memory allocation failure.\n",
				    __func__);
				FREE(orb_ab, M_1394DATA);
				MPRINTF("FREE(1394DATA)", orb_ab);
				free(ab->ab_data, M_1394DATA);
				MPRINTF("free(1394DATA)", ab->ab_data);
				FREE(ab, M_1394DATA);
				MPRINTF("FREE(1394DATA)", ab);
				return;
			}
			bzero(stat_ab, sizeof(*stat_ab));
			orb = malloc(sizeof(*orb), M_1394DATA, M_NOWAIT);
			MPRINTF("malloc(1394DATA)", orb);
			if (!orb) {
				printf("%s: memory allocation failure.\n",
				    __func__);
				FREE(stat_ab, M_1394DATA);
				MPRINTF("FREE(1394DATA)", stat_ab);
				FREE(orb_ab, M_1394DATA);
				MPRINTF("FREE(1394DATA)", orb_ab);
				free(ab->ab_data, M_1394DATA);
				MPRINTF("free(1394DATA)", ab->ab_data);
				FREE(ab, M_1394DATA);
				MPRINTF("FREE(1394DATA)", ab);
				return;
			}
			bzero(orb, sizeof(*orb));

			old_nodeid = ac->ac_nodeid;
			ac->ac_nodeid = sc->sc1394_node_id;
			//ac->ac_valid = 1;

			/* Re-register the status block with the new nodeid. */
			sc->sc1394_node_id = old_nodeid;
			fwsc->sc1394_unreg(ac->ac_status_ab, FALSE);
			sc->sc1394_node_id = ac->ac_nodeid;
			fwsc->sc1394_inreg(ac->ac_status_ab, FALSE);

			/* Register a transient status block. */
			addr = SBP2_STATUS_BLOCK +
			    ((u_int64_t)ac->ac_nodeid << SBP2_NODE_SHIFT) +
			    ((u_int64_t)ac->ac_lun << SBP2_LUN_SHIFT) +
			    SBP2_RECONNECT_OFFSET;
			stat_ab->ab_length = sizeof(struct sbp2_status_block);
			stat_ab->ab_tcode =
			    IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK;
			stat_ab->ab_retlen = 0;
			stat_ab->ab_data = NULL;
			stat_ab->ab_addr = addr;
			stat_ab->ab_cb = sbp2_status_resp;
			stat_ab->ab_cbarg = ac;
			stat_ab->ab_req = sc;

			fwsc->sc1394_inreg(stat_ab, FALSE);

			/* Construct the RECONNECT orb. */
			orb->options = htons(SBP2_ORB_RECONNECT);
			orb->login_id = htons(ac->ac_login);
			orb->status_fifo.hi =
			    htons((u_int16_t)(addr >> 32));
			orb->status_fifo.lo =
			    htonl((u_int32_t)(addr & 0xFFFFFFFF));

			addr = SBP2_MGMT_ORB +
			    ((u_int64_t)ac->ac_nodeid << SBP2_NODE_SHIFT) +
			    ((u_int64_t)ac->ac_lun << SBP2_LUN_SHIFT);
			orb_ab->ab_length = sizeof(struct sbp2_reconnect_orb);
			orb_ab->ab_tcode =
			    IEEE1394_TCODE_READ_REQUEST_DATABLOCK;
			orb_ab->ab_retlen = 0;
			orb_ab->ab_data = NULL;
			orb_ab->ab_addr = addr;
			orb_ab->ab_cb = sbp2_reconnect_send;
			orb_ab->ab_cbarg = orb;
			orb_ab->ab_req = sc;

			fwsc->sc1394_inreg(orb_ab, FALSE);

			/* Invoque the RECONNECT management command. */
			ab->ab_req = sc;
			ab->ab_length = 8;
			ab->ab_retlen = 0;
			ab->ab_cb = NULL;
			ab->ab_cbarg = NULL;
			ab->ab_addr = ac->ac_mgmt_agent;
			ab->ab_tcode = IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK;
			ab->ab_data[0] = htonl((u_int32_t)(addr >> 32));
			ab->ab_data[1] = htonl((u_int32_t)(addr & 0xFFFFFFFF));
			DPRINTF((" CSR = 0x%012qx", ac->ac_mgmt_agent));
			DPRINTF((", ORB = 0x%012qx\n", addr));

			fwsc->sc1394_write(ab);
			DPRINTF(("%s: %04x RECONNECT submitted\n", __func__,
			    ac->ac_login));
		}
	}
}

void
sbp2_reconnect_send(struct ieee1394_abuf *ab, int rcode)
{
	struct ieee1394_abuf *orb_ab;
	struct fwnode_softc *sc = (struct fwnode_softc *)ab->ab_req;

	if (rcode) {
		DPRINTF(("%s: Bad return code: %d\n", __func__, rcode));
		if (ab->ab_data > (u_int32_t *)1) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;	/* XXX */
		}
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
		return;
	}

	MALLOC(orb_ab, struct ieee1394_abuf *, sizeof(*orb_ab),
	    M_1394DATA, M_NOWAIT);
	MPRINTF("MALLOC(1394DATA)", orb_ab);
	if (!orb_ab) {
		printf("%s: memory allocation failure.\n",
		    __func__);
		return;
	}

	bcopy(ab, orb_ab, sizeof(*orb_ab));

	sc->sc1394_unreg(ab, FALSE);
	if (ab->ab_data) {
		free(ab->ab_data, M_1394DATA);
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;	/* XXX */
		orb_ab->ab_data = NULL;
	}
	FREE(ab, M_1394DATA);
	MPRINTF("FREE(1394DATA)", ab);
	ab = NULL;	/* XXX */

	if (!orb_ab->ab_cbarg) {
		DPRINTF(("%s: orb lost !\n", __func__));
		FREE(orb_ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", orb_ab);
		orb_ab = NULL;	/* XXX */
		return;
	}
	orb_ab->ab_data = (u_int32_t *)orb_ab->ab_cbarg;
	orb_ab->ab_length = sizeof(struct sbp2_reconnect_orb);
	orb_ab->ab_retlen = 0;
	orb_ab->ab_cb = NULL;
	orb_ab->ab_cbarg = NULL;
	orb_ab->ab_tcode = IEEE1394_TCODE_READ_RESPONSE_DATABLOCK;

	sc->sc1394_write(orb_ab);
}

void
sbp2_agent_reset(struct fwnode_softc *sc, int lun)
{
	struct ieee1394_abuf *ab;
	struct sbp2_account *ac;

	if ((ac = sbp2_acfind(sc, lun)) == NULL) {
		DPRINTF(("%s: destination not initialized\n", __func__));
		return;
	}

	DPRINTF(("%s:", __func__));

	MALLOC(ab, struct ieee1394_abuf *, sizeof(*ab), M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", ab);
	bzero(ab, sizeof(*ab));

	ab->ab_req = (struct ieee1394_softc *)sc;
	ab->ab_length = 4;
	ab->ab_retlen = 0;
	ab->ab_cb = NULL;
	ab->ab_cbarg = NULL;
	ab->ab_addr = ac->ac_fetch_agent + SBP2_AGENT_RESET;
	ab->ab_tcode = IEEE1394_TCODE_WRITE_REQUEST_QUADLET;

	ab->ab_data = malloc(4, M_1394DATA, M_WAITOK);
	MPRINTF("malloc(1394DATA)", ab->ab_data);
	ab->ab_data[0] = 0;
	DPRINTF((" CSR = 0x%012qx\n", ab->ab_addr));

	sc->sc1394_write(ab);
	DPRINTF(("%s: AGENT_RESET submitted\n", __func__));

}

void
sbp2_agent_tickle(struct fwnode_softc *sc, int lun)
{
	struct ieee1394_abuf *ab;
	struct sbp2_account *ac;

	if ((ac = sbp2_acfind(sc, lun)) == NULL) {
		DPRINTF(("%s: destination not initialized\n", __func__));
		return;
	}

	DPRINTF(("%s:", __func__));

	MALLOC(ab, struct ieee1394_abuf *, sizeof(*ab), M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", ab);
	bzero(ab, sizeof(*ab));

	ab->ab_req = (struct ieee1394_softc *)sc;
	ab->ab_length = 4;
	ab->ab_retlen = 0;
	ab->ab_cb = NULL;
	ab->ab_cbarg = NULL;
	ab->ab_addr = ac->ac_fetch_agent + SBP2_DOORBEL;
	ab->ab_tcode = IEEE1394_TCODE_WRITE_REQUEST_QUADLET;

	ab->ab_data = malloc(4, M_1394DATA, M_WAITOK);
	MPRINTF("malloc(1394DATA)", ab->ab_data);
	ab->ab_data[0] = 0;
	DPRINTF((" CSR = 0x%012qx\n", ab->ab_addr));

	sc->sc1394_write(ab);
	DPRINTF(("%s: DOORBEL submitted\n", __func__));

}

int
sbp2_agent_state(struct fwnode_softc *sc, int lun)
{
	return (0);
}

void
sbp2_task_management(struct fwnode_softc *sc,
    struct sbp2_task_management_orb *orb,
    void (*cb)(void *, struct sbp2_status_notification *), void *arg)
{
}

@


1.6
log
@swap the last two parameters to TAILQ_FOREACH_REVERSE. matches what FreeBSD
and NetBSD do.
ok millert@@ mcbride@@ markus@@ ho@@, checked to not affect ports by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbp2.c,v 1.5 2004/02/15 02:38:38 tedu Exp $	*/
@


1.5
log
@break in default switch cases
@
text
@d1 1
a1 1
/*	$OpenBSD: sbp2.c,v 1.4 2003/01/08 06:33:38 tdeval Exp $	*/
d228 1
a228 1
	TAILQ_FOREACH_REVERSE(elm, &sbp2_elm_head, elm_chain, sbp2_orb_tq) {
d382 2
a383 2
			TAILQ_FOREACH_REVERSE(elm, &sbp2_elm_head, elm_chain,
			    sbp2_orb_tq) {
@


1.4
log
@Sync debug info with code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbp2.c,v 1.3 2002/12/30 11:48:34 tdeval Exp $	*/
d274 1
d288 1
@


1.4.4.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d228 1
a228 1
	TAILQ_FOREACH_REVERSE(elm, &sbp2_elm_head, sbp2_orb_tq, elm_chain) {
a273 1
		break;
a286 1
		break;
d380 2
a381 2
			TAILQ_FOREACH_REVERSE(elm, &sbp2_elm_head, sbp2_orb_tq,
			    elm_chain) {
@


1.3
log
@Implement the reconnect callback. This will be called whenever an SBP2 node's
node_id changes, following a BusReset (happens when you add/remove a device
to/from the FireWire chain).

Re-work the ORB management to support concurrent node accesses.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbp2.c,v 1.2 2002/12/13 21:35:11 tdeval Exp $	*/
d748 2
a749 1
				    (u_int32_t)(csr & 0xFFFFFFFC)));
a1047 1

@


1.2
log
@Malloc debug cleaning (MPRINTF).
Uses option FW_MALLOC_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbp2.c,v 1.1 2002/12/13 02:57:56 tdeval Exp $	*/
d85 4
a88 2
int sbp2_print_data(struct p1212_data *);
int sbp2_print_dir(struct p1212_dir *);
d93 2
d126 22
d149 1
a149 1
	u_int32_t		  elm_hash;
d153 1
d161 1
a162 22
typedef struct sbp2_account {
	struct fwnode_softc	 *ac_softc;
	u_int16_t		  ac_lun;
	u_int16_t		  ac_login;
	u_int16_t		  ac_reconnect_hold;
	u_int16_t		  ac_valid;
	u_int64_t		  ac_mgmt_agent;
	u_int64_t		  ac_fetch_agent;
	u_int64_t		  ac_response;
	void			 *ac_response_block;
	u_int64_t		  ac_status_fifo;
	struct ieee1394_abuf	 *ac_status_ab;
	struct sbp2_status_block *ac_status_block;
	void			(*ac_cb)(void *,
					 struct sbp2_status_notification *);
	void			 *ac_cbarg;
	struct sbp2_task_management_orb *ac_mgmt_orb;
	TAILQ_HEAD(sbp2_orb_tq, sbp2_orb_element) ac_orb_head;
	SLIST_ENTRY(sbp2_account) ac_chain;
} sbp2_account;

static SLIST_HEAD(, sbp2_account) sbp2_ac_head;
d166 4
a169 3
struct sbp2_orb_element *sbp2_elfind_hash(struct sbp2_account *, u_int32_t);
struct sbp2_orb_element *sbp2_elfind_orb(struct sbp2_account *,
    struct sbp2_command_orb *);
d185 1
a185 1
sbp2_elfind_hash(struct sbp2_account *ac, u_int32_t hash)
d189 1
a189 1
	TAILQ_FOREACH(elm, &ac->ac_orb_head, elm_chain) {
d198 1
a198 1
sbp2_elfind_orb(struct sbp2_account *ac, struct sbp2_command_orb *orb)
d202 1
a202 1
	TAILQ_FOREACH(elm, &ac->ac_orb_head, elm_chain) {
d210 27
a236 1
int
d244 1
a244 1
		if (key->val == 0x104d8)
a273 1
		return 0;
a274 1
	return 1;
d277 1
a277 1
int
a286 1
		return 0;
a287 1
	return 1;
d298 5
d309 1
d318 3
a320 2
	DPRINTF(("%s: Node %d: UID %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
	    __func__, sc->sc_sc1394.sc1394_node_id,
d330 2
a331 1
	ac->ac_login = sc->sc_sc1394.sc1394_node_id;
d333 1
a333 1
	DPRINTF(("%s: mgmt_agent = 0x%016qx\n", __func__, ac->ac_mgmt_agent));
d337 1
a337 1
		ac->ac_lun = (*key)->val & 0xffff;
d350 1
a350 1
			ac->ac_lun = (*key)->val & 0xffff;
d356 1
a356 3
	DPRINTF(("%s: lun = %d\n", __func__, ac->ac_lun));

	TAILQ_INIT(&ac->ac_orb_head);
a372 4
#ifdef	SBP2_DEBUG
	if (sbp2debug)
		p1212_print(unitdir);
#endif
d376 1
a376 1
		lun = (*key)->val & 0xffff;
d380 1
a380 1
			TAILQ_FOREACH_REVERSE(elm, &ac->ac_orb_head, elm_chain,
d383 2
a384 2
				if (elm != NULL) {
					TAILQ_REMOVE(&ac->ac_orb_head, elm,
d420 1
a420 1
				lun = (*key)->val & 0xffff;
d424 1
a424 1
					TAILQ_FOREACH(elm, &ac->ac_orb_head,
d426 2
a427 1
						if (elm != NULL) {
d476 1
d508 8
a515 4
	ab->ab_data[0] = htonl((u_int32_t)(SBP2_LOGIN_ORB >> 32));
	ab->ab_data[1] = htonl((u_int32_t)(SBP2_LOGIN_ORB & 0xFFFFFFFF));
	DPRINTF((" CSR = 0x%016qx", ac->ac_mgmt_agent));
	DPRINTF((", ORB = 0x%016qx\n", SBP2_LOGIN_ORB + (u_int32_t)orb));
d521 1
a521 1
	ab2->ab_addr = SBP2_LOGIN_ORB;
a528 1
	return;
d538 1
d584 7
d595 1
a595 1
	resp_ab->ab_addr = SBP2_LOGIN_RESP;
d600 4
d606 16
d626 1
a626 1
	stat_ab->ab_addr = SBP2_LOGIN_STATUS;
d634 3
a636 20
	/* Fill in a login packet. First 2 quads are 0 for password. */
	login_orb = (struct sbp2_login_orb *)ac->ac_mgmt_orb;

	/* Addr for response. */
	login_orb->login_response.hi = htons((SBP2_LOGIN_RESP >> 32) & 0xffff);
	login_orb->login_response.lo = htonl(SBP2_LOGIN_RESP & 0xffffffff);
	DPRINTF(("%s: RESP_ORB = 0x%016qx", __func__, SBP2_LOGIN_RESP));

	/* Set notify and exclusive use bits. Login to lun 0 (XXX) */
	login_orb->options = htons(0x8000);
	login_orb->lun = htons(ac->ac_lun);

	/* Password length (0) and login response length (16) */
	login_orb->password_length = htons(0);
	login_orb->login_response_length = htons(16);

	/* Addr for status packet. */
	login_orb->status_fifo.hi = htons((SBP2_LOGIN_STATUS >> 32) & 0xffff);
	login_orb->status_fifo.lo = htonl(SBP2_LOGIN_STATUS & 0xffffffff);
	DPRINTF((", STATUS_ORB = 0x%016qx", SBP2_LOGIN_STATUS));
d668 1
a668 1
	u_int64_t csr;
d673 22
a694 1
	if (rcode || (ac == NULL)) {
d696 1
d702 1
a702 1
		if (ab->ab_addr != SBP2_LOGIN_STATUS) {
d711 2
a712 1
	DPRINTF(("%s: CSR = 0x%016qx", __func__, (quad_t)ab->ab_addr));
d720 1
a720 18
	if (ab->ab_addr == SBP2_LOGIN_RESP) {
		login_resp = (struct sbp2_login_response *)ab->ab_data;

//		ac->ac_response = ab->ab_addr;
		ac->ac_response_block = login_resp;
		ac->ac_login = ntohs(login_resp->login_id);
		ac->ac_fetch_agent =
		    ((u_int64_t)(ntohs(login_resp->fetch_agent.hi)) << 32) +
		    ntohl(login_resp->fetch_agent.lo);
		ac->ac_reconnect_hold = ntohs(login_resp->reconnect_hold);

		DPRINTF(("Got a valid response\n"));
		DPRINTF(("Login ID : 0x%04x, Command Agent : 0x%016qx\n",
		    ac->ac_login, ac->ac_fetch_agent));

		ac->ac_valid |= 1;
	}
	if (ab->ab_addr == SBP2_LOGIN_STATUS) {
d738 2
a739 2
		DPRINTF(("status -- src: %d, resp: %d, dead: %d, len: %d, "
		    "status: %d\nstatus -- csr: 0x%016qx\n", src, resp, dead,
d743 2
a744 2
			elm = sbp2_elfind_hash(ac,
			    (u_int32_t)(csr & 0xFFFFFFFF));
d748 1
a748 1
				    (u_int32_t)(csr & 0xFFFFFFFF)));
d764 3
a766 1
		    (status == 0) && (csr == SBP2_LOGIN_ORB)) {
d780 20
d801 1
a801 1
	if (ac->ac_valid == 3) {
d829 1
a829 1
	if (ab->ab_addr != SBP2_LOGIN_STATUS) {
d840 1
a840 1
    void (*cb)(struct sbp2_status_notification *))
d852 1
d860 1
a860 1
	DPRINTF(("%s:", __func__));
d864 2
a865 2
		ehash = arc4random() & 0xFFFFFFFC;	/* "quadlet" addr */
	} while (sbp2_elfind_hash(ac, ehash) != NULL);
d867 3
a870 5
	elast = TAILQ_LAST(&ac->ac_orb_head, sbp2_orb_tq);
	if (elast != TAILQ_END(&ac->ac_orb_head)) {
		elast->elm_orb->next_orb.hi = htons(SBP2_CMD_ORB >> 32);
		elast->elm_orb->next_orb.lo = htonl(ehash);
	}
d883 1
a883 1
	TAILQ_INSERT_TAIL(&ac->ac_orb_head, elm, elm_chain);
d893 1
a893 1
	ab2->ab_addr = SBP2_CMD_ORB + ehash;
d901 8
a908 1
	if (ac->ac_valid & 8) {
d926 2
a927 4
		ab->ab_data[0] = htonl((u_int32_t)(SBP2_CMD_ORB >> 32));
		ab->ab_data[1] = htonl(ehash);
		DPRINTF((" CSR = 0x%016qx", ab->ab_addr));
		DPRINTF((", ORB = 0x%016qx\n", SBP2_CMD_ORB + ehash));
d932 1
d936 3
d957 1
a957 1
	if ((elm = sbp2_elfind_orb(ac, orb)) == NULL) {
d964 2
a965 2
	DPRINTF((" orb=0x%08x len=%d data=0x%08x size=%d\n",
	    (u_int32_t)(elm->elm_orb), elm->elm_orblen,
d980 1
a980 1
	TAILQ_REMOVE(&ac->ac_orb_head, elm, elm_chain);
d985 1
a985 1
	if (TAILQ_EMPTY(&ac->ac_orb_head))
d994 1
a994 2
	struct sbp2_orb_element *elm, *next_elm;
	struct sbp2_command_orb *cmd_orb, *next_orb;
d1021 3
a1023 2
	if ((elm = sbp2_elfind_hash(ac, (u_int32_t)(ab->ab_addr & 0xFFFFFFFF)))
	    == NULL) {
d1025 1
a1025 1
		DPRINTF(("%s: ORB not found: 0x%016qx\n", __func__,
d1039 3
a1041 4
	DPRINTF(("%s: orb=0x%08x len=%d data=0x%08x size=%d (l=%d rl=%d)\n",
	    __func__, (u_int32_t)(elm->elm_orb), elm->elm_orblen,
	    (u_int32_t)(elm->elm_data), elm->elm_datasize,
	    ab->ab_length, ab->ab_retlen));
a1047 13
	/* Fill in a command packet. */
	cmd_orb = elm->elm_orb;
	if ((next_elm = TAILQ_NEXT(elm, elm_chain))
	    != TAILQ_END(&ac->ac_orb_head)) {
		next_orb = next_elm->elm_orb;
		cmd_orb->next_orb.flag = 0x0000;
		cmd_orb->next_orb.hi = htons(SBP2_CMD_ORB >> 32);
		cmd_orb->next_orb.lo = htonl(next_elm->elm_hash);
	} else {
		cmd_orb->next_orb.flag = htons(SBP2_NULL_ORB);
		cmd_orb->next_orb.hi = 0x0000;
		cmd_orb->next_orb.lo = 0x00000000;
	}
d1057 1
a1057 1
	bcopy(cmd_orb, cmd_ab->ab_data, elm->elm_orblen * 4);
d1069 206
d1302 1
a1302 1
	DPRINTF((" CSR = 0x%016qx\n", ab->ab_addr));
a1306 1
	return;
d1337 1
a1337 1
	DPRINTF((" CSR = 0x%016qx\n", ab->ab_addr));
a1341 1
	return;
d1353 1
a1353 1
    void (*cb)(struct sbp2_status_notification *))
@


1.1
log
@Add preliminary support for the Serial Bus Protocol II (SBP-2) standard.
As well as a first rough implementation of a SCSI over FireWire support,
following the SBP-2 standard.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a91 6
#ifdef	MALLOC_DEBUG
#include <dev/ieee1394/malloc_debug.h>		/* MPRINTF(x,y) */
#else	/* !MALLOC_DEBUG */
#define	MPRINTF(x,y)
#endif	/* MALLOC_DEBUG */

d108 7
d119 1
d279 1
a279 1
	//MPRINTF_OLD("MALLOC(1394CTL)", ac);
d290 1
a290 1
	//MPRINTF_OLD("free(DEVBUF)", key);
d302 1
a302 1
		//MPRINTF_OLD("free(DEVBUF)", key);
d308 1
a308 1
		//MPRINTF_OLD("free(DEVBUF)", key);
d315 1
a315 1
			//MPRINTF_OLD("free(DEVBUF)", key);
d356 1
a356 1
					//MPRINTF_OLD("FREE(1394CTL)", elm);
d365 1
a365 1
				//MPRINTF_OLD("FREE(1394DATA)", ac->ac_status_ab);
d370 1
a370 1
				//MPRINTF_OLD("FREE(1394DATA)", ac->ac_status_block);
d374 1
a374 1
			//MPRINTF_OLD("FREE(1394CTL)", ac);
d378 1
a378 1
		//MPRINTF_OLD("free(DEVBUF)", key);
d397 1
a397 1
							//MPRINTF_OLD("FREE(1394CTL)", elm);
d408 1
a408 1
						//MPRINTF_OLD("FREE(1394DATA)", ac->ac_status_ab);
d414 1
a414 1
						//MPRINTF_OLD("FREE(1394DATA)", ac->ac_status_block);
d418 1
a418 1
					//MPRINTF_OLD("FREE(1394CTL)", ac);
d422 1
a422 1
				//MPRINTF_OLD("free(DEVBUF)", key);
d428 1
a428 1
		//MPRINTF_OLD("free(DEVBUF)", dir);
d459 1
a459 1
	//MPRINTF_OLD("MALLOC(1394DATA)", ab);
d462 1
a462 1
	//MPRINTF_OLD("MALLOC(1394DATA)", ab2);
d474 1
a474 1
	//MPRINTF_OLD("malloc(1394DATA)", ab->ab_data);
d512 1
a512 1
			//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d516 1
a516 1
		//MPRINTF_OLD("FREE(1394DATA)", ab);
d523 1
a523 1
	//MPRINTF_OLD("MALLOC(1394DATA)", orb_ab);
d530 1
a530 1
		//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d535 1
a535 1
	//MPRINTF_OLD("FREE(1394DATA)", ab);
d540 1
a540 1
	//MPRINTF_OLD("MALLOC(1394DATA)", resp_ab);
d543 1
a543 1
	//MPRINTF_OLD("MALLOC(1394DATA)", stat_ab);
d592 1
a592 1
	//MPRINTF_OLD("malloc(1394DATA)", orb_ab->ab_data);
d630 1
a630 1
			//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d635 1
a635 1
			//MPRINTF_OLD("FREE(1394DATA)", ab);
d670 1
a670 1
		//MPRINTF_OLD("MALLOC(1394DATA)", cmd_status);
d697 1
a697 1
				//MPRINTF_OLD("FREE(1394DATA)", cmd_status);
d703 1
a703 1
			//MPRINTF_OLD("MALLOC(1394CTL)", status_notify);
d708 1
a708 1
			//MPRINTF_OLD("FREE(1394CTL)", status_notify);
d714 1
a714 1
				//MPRINTF_OLD("FREE(1394DATA)", ac->ac_status_block);
d722 1
a722 1
			//MPRINTF_OLD("FREE(1394DATA)", cmd_status);
d731 1
a731 1
			//MPRINTF_OLD("MALLOC(1394CTL)", status_notify);
d736 1
a736 1
			//MPRINTF_OLD("FREE(1394CTL)", status_notify);
d750 1
a750 1
		//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d757 1
a757 1
		//MPRINTF_OLD("FREE(1394DATA)", ab);
d800 1
a800 1
	//MPRINTF_OLD("MALLOC(1394CTL)", elm);
d812 1
a812 1
	//MPRINTF_OLD("MALLOC(1394DATA)", ab2);
d832 1
a832 1
		//MPRINTF_OLD("MALLOC(1394DATA)", ab);
d844 1
a844 1
		//MPRINTF_OLD("malloc(1394DATA)", ab->ab_data);
d889 1
a889 1
			//MPRINTF_OLD("free(1394DATA)", elm->elm_orb_ab->ab_data);
d893 1
a893 1
		//MPRINTF_OLD("FREE(1394DATA)", elm->elm_orb_ab);
d899 1
a899 1
	//MPRINTF_OLD("FREE(1394CTL)", elm);
d924 1
a924 1
			//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d928 1
a928 1
		//MPRINTF_OLD("FREE(1394DATA)", ab);
d935 1
a935 1
		//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d947 1
a947 1
			//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d951 1
a951 1
		//MPRINTF_OLD("FREE(1394DATA)", ab);
d963 1
a963 1
	//MPRINTF_OLD("MALLOC(1394DATA)", cmd_ab);
d987 1
a987 1
	//MPRINTF_OLD("malloc(1394DATA)", cmd_ab->ab_data);
d1013 1
a1013 1
	//MPRINTF_OLD("MALLOC(1394DATA)", ab);
d1025 1
a1025 1
	//MPRINTF_OLD("malloc(1394DATA)", ab->ab_data);
d1049 1
a1049 1
	//MPRINTF_OLD("MALLOC(1394DATA)", ab);
d1061 1
a1061 1
	//MPRINTF_OLD("malloc(1394DATA)", ab->ab_data);
@

