head	1.7;
access;
symbols
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	SMP:1.6.0.4
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	UBC:1.2.0.4
	UBC_SYNC_B:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2005.03.05.23.58.44;	author tdeval;	state dead;
branches;
next	1.6;

1.6
date	2003.01.12.12.06.28;	author tdeval;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.30.11.26.48;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.13.21.35.11;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.13.02.52.11;	author tdeval;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.26.13.50.56;	author tdeval;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.06.25.17.11.49;	author itojun;	state Exp;
branches;
next	;

1.2.4.1
date	2003.05.19.22.22.29;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Clean up the tree from incomplete, unreliable and unsupported IEEE1394 code.
Ok deraadt@@, miod@@
@
text
@/*	$OpenBSD: ieee1212.c,v 1.6 2003/01/12 12:06:28 tdeval Exp $	*/
/*	$NetBSD: ieee1212.c,v 1.3 2002/05/23 00:10:46 jmc Exp $	*/

/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by James Chacon.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>

#include <dev/std/ieee1212reg.h>
#include <dev/std/ieee1212var.h>
#include <dev/std/sbp2reg.h>
#include <dev/std/sbp2var.h>

static const char * const p1212_keytype_strings[] = P1212_KEYTYPE_STRINGS;
static const char * const p1212_keyvalue_strings[] = P1212_KEYVALUE_STRINGS;

u_int16_t p1212_calc_crc(u_int16_t, u_int32_t *, int, int);
int p1212_parse_directory(struct p1212_dir *, u_int32_t *, u_int32_t);
struct p1212_leafdata *p1212_parse_leaf(u_int32_t *);
int p1212_parse_textdir(struct p1212_com *, u_int32_t *);
struct p1212_textdata *p1212_parse_text_desc(u_int32_t *);
void p1212_print_node(struct p1212_key *, void *);
int p1212_validate_offset(u_int16_t, u_int32_t);
int p1212_validate_immed(u_int16_t, u_int32_t);
int p1212_validate_leaf(u_int16_t, u_int32_t);
int p1212_validate_dir(u_int16_t, u_int32_t);

#ifdef	P1212_DEBUG
#include <sys/syslog.h>
extern int log_open;
int p1212_oldlog;
#define	DPRINTF(x)	if (p1212debug) do {				\
	p1212_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = p1212_oldlog;				\
} while (0)
#define	DPRINTFN(n,x)	if (p1212debug>(n)) do {			\
	p1212_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = p1212_oldlog;				\
} while (0)
#ifdef	FW_MALLOC_DEBUG
#define	MPRINTF(x,y)	DPRINTF(("%s[%d]: %s 0x%08x\n",			\
			    __func__, __LINE__, (x), (u_int32_t)(y)))
#else	/* !FW_MALLOC_DEBUG */
#define	MPRINTF(x,y)
#endif	/* FW_MALLOC_DEBUG */

int	p1212debug = 0;
#else	/* P1212_DEBUG */
#define	DPRINTF(x)
#define	DPRINTFN(n,x)
#define	MPRINTF(x,y)
#endif	/* ! P1212_DEBUG */

/*
 * Routines to parse the ROM into a tree that's usable. Also verify integrity
 * vs. the P1212 standard
 */

/*
 * A buffer of u_int32_t's and a size in quads gets passed in. The output will
 * return -1 on error, or 0 on success and possibly reset *size to a larger
 * value.
 *
 * NOTE: Rom's are guarentee'd per the ISO spec to be contiguous but only the
 * first 1k is directly mapped. Anything past 1k is supposed to use a loop
 * around the indirect registers to read in the rom. This code only assumes the
 * buffer passed in represents a total rom regardless of end size. It is the
 * callers responsibility to treat a size > 1024 as a special case.
 */

int
p1212_iscomplete(u_int32_t *t, u_int32_t *size)
{
	u_int16_t infolen, crclen, len;
	u_int32_t newlen, offset, test;
	int complete, i, numdirs, type, val, *dirs;
#ifdef	__OpenBSD__
	int *p;
#endif	/* __OpenBSD__ */

	dirs = NULL;

	if (*size == 0) {
		DPRINTF(("Invalid size for ROM: %d\n", (unsigned int)*size));
		return -1;
	}

	infolen = P1212_ROMFMT_GET_INFOLEN((ntohl(t[0])));
	if (infolen <= 1) {
		DPRINTF(("ROM not initialized or minimal ROM: Info "
		    "length: %d\n", infolen));
		return -1;
	}
	crclen = P1212_ROMFMT_GET_CRCLEN((ntohl(t[0])));
	if (crclen < infolen) {
		DPRINTF(("CRC len less than info len. CRC len: %d, "
		    "Info len: %d\n", crclen, infolen));
		return -1;
	}

	/*
	 * Now loop through it to check if all the offsets referenced are
	 * within the image stored so far. If not, get those as well.
	 */

	offset = infolen + 1;

	/*
	 * Make sure at least the bus info block is in memory + the root dir
	 * header quad. Add 1 here since offset is an array offset and size is
	 * the total array size we want. If this is getting the root dir
	 * then add another since infolen doesn't end on the root dir entry but
	 * right before it.
	 */

	if ((*size == 1) || (*size < (offset + 1))) {
		*size = (crclen > infolen) ? crclen : infolen;
		if (crclen == infolen)
			(*size)++;
		(*size)++;
		return 0;
	}

	complete = 0;
	numdirs = 0;
	newlen = 0;

	while (!complete) {

		/*
		 * Make sure the whole directory is in memory. If not, bail now
		 * and read it in.
		 */

		newlen = P1212_DIRENT_GET_LEN((ntohl(t[offset])));
		if ((offset + newlen + 1) > *size) {
			newlen += offset + 1;
			break;
		}

		if (newlen == 0) {
			DPRINTF(("Impossible directory length of 0!\n"));
			return -1;
		}

		/*
		 * Starting with the first byte of the directory, read through
		 * and check the values found. On offsets and directories read
		 * them in if appropriate (always for offsets, if not in memory
		 * for leaf/directories).
		 */

		offset++;
		len = newlen;
		newlen = 0;
		for (i = 0; i < len; i++) {
			type = P1212_DIRENT_GET_KEYTYPE((ntohl(t[offset+i])));
			val = P1212_DIRENT_GET_VALUE((ntohl(t[offset+i])));
			switch (type) {
			case P1212_KEYTYPE_Immediate:
			case P1212_KEYTYPE_Offset:
				break;
			case P1212_KEYTYPE_Leaf:

				/*
				 * If a leaf is found, and it's beyond the
				 * current rom length and it's beyond the
				 * current newlen setting,
				 * then set newlen accordingly.
				 */

				test = offset + i + val + 1;
				if ((test > *size) && (test > newlen)) {
					newlen = test;
					break;
				}

				/*
				 * For leaf nodes just make sure the whole leaf
				 * length is in the buffer. There's no data
				 * inside of them that can refer to outside
				 * nodes. (Uless it's vendor specific and then
				 * you're on your own anyways).
				 */

				test--;
				infolen =
				    P1212_DIRENT_GET_LEN((ntohl(t[test])));
				test++;
				test += infolen;
				if ((test > *size) && (test > newlen)) {
					newlen = test;
				}
				break;

			case P1212_KEYTYPE_Directory:

				/* Make sure the first quad is in memory. */

				test = offset + i + val + 1;
				if ((test > *size) && (test > newlen)) {
					newlen = test;
					break;
				}

				/*
				 * Can't just walk the ROM looking at type
				 * codes since these are only valid on
				 * directory entries. So save any directories
				 * we find into a queue and the bottom of the
				 * while loop will pop the last one off and
				 * walk that directory.
				 */

				test--;
#ifdef	__NetBSD__
				dirs = realloc(dirs,
				    sizeof(int) * (numdirs + 1), M_DEVBUF,
				    M_WAITOK);
#else	/* __NetBSD__ */
				p = malloc(sizeof(int) * (numdirs + 1),
				    M_DEVBUF, M_WAITOK);
				MPRINTF("malloc(DEVBUF)", p);
				if (dirs != NULL) {
					bcopy(dirs, p, sizeof(int) * numdirs);
					free(dirs, M_DEVBUF);
					MPRINTF("free(DEVBUF)", dirs);
					dirs = NULL;	/* XXX */
				}
				dirs = p;
#endif	/* ! __NetBSD__ */
				dirs[numdirs++] = test;
				break;
			default:
				panic("Impossible type code: 0x%04hx",
				    (unsigned short)type);
				break;
			}
		}

		if (newlen) {
			/* Cleanup. */
			if (dirs) {
				free(dirs, M_DEVBUF);
				MPRINTF("free(DEVBUF)", dirs);
				dirs = NULL;	/* XXX */
			}
			break;
		}
		if (dirs != NULL) {
			offset = dirs[--numdirs];
			if (numdirs) {
#ifdef	__NetBSD__
				dirs = realloc(dirs, sizeof(int) * numdirs,
				    M_DEVBUF, M_WAITOK);
#else	/* __NetBSD__ */
				p = malloc(sizeof(int) * numdirs,
				    M_DEVBUF, M_WAITOK);
				MPRINTF("malloc(DEVBUF)", p);
				bcopy(dirs, p, sizeof(int) * numdirs);
				free(dirs, M_DEVBUF);
				MPRINTF("free(DEVBUF)", dirs);
				dirs = p;
#endif	/* ! __NetBSD__ */
			} else {
				free(dirs, M_DEVBUF);
				MPRINTF("free(DEVBUF)", dirs);
				dirs = NULL;
			}
		} else
			complete = 1;
	}

	if (newlen)
		*size = newlen;
	return 0;

}

struct p1212_rom *
p1212_parse(u_int32_t *t, u_int32_t size, u_int32_t mask)
{

	u_int16_t crc, romcrc, crc1, crc2;
	u_int32_t next, check;
	struct p1212_rom *rom;
	int i, crclen;

	check = size;

	if (p1212_iscomplete(t, &check) == -1) {
		DPRINTF(("ROM is not complete\n"));
		return NULL;
	}
	if (check != size) {
		DPRINTF(("ROM is not complete (check != size)\n"));
		return NULL;
	}

	/* Calculate both a good and known bad crc. */

	/* CRC's are calculated from everything except the first quad. */

	crclen = P1212_ROMFMT_GET_CRCLEN((ntohl(t[0])));
	romcrc = P1212_ROMFMT_GET_CRC((ntohl(t[0])));

	crc = p1212_calc_crc(0, &t[1], crclen, 0);

	if (crc != romcrc) {
		crc1 = p1212_calc_crc(0, &t[1], crclen, 1);
		crc2 = p1212_calc_crc(0, &t[1], crclen, 2);
		if ((crc1 != romcrc) && (crc2 != romcrc)) {
			DPRINTF(("Invalid ROM: CRC: 0x%04hx, Calculated "
			    "CRC: 0x%04hx, CRC1: 0x%04hx, CRC2: 0x%04hx\n",
			    (unsigned short)romcrc, (unsigned short)crc,
			    (unsigned short)crc1, (unsigned short)crc2));
#if 0	/* Continue anyway. We'll choke later if any entry is invalid. */
			return NULL;
#endif
		}
	}
	if (romcrc == crc2)
		DPRINTF(("%s: warning byte-swapping rom problems\n", __func__));

	/* Now, walk the ROM. */

	/* Get the initial offset for the root dir. */

	MALLOC(rom, struct p1212_rom *, sizeof(*rom), M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", rom);
	rom->len = P1212_ROMFMT_GET_INFOLEN((ntohl(t[0])));
	next = rom->len + 1;

	if ((rom->len < 1) || (rom->len > size)) {
		DPRINTF(("Invalid ROM info length: %d\n", rom->len));
		FREE(rom, M_DEVBUF);
		MPRINTF("FREE(DEVBUF)", rom);
		rom = NULL;	/* XXX */
		return NULL;
	}

	/* Exclude the quad which covers the bus name. */
	rom->len--;

	if (rom->len) {
		rom->data = malloc(sizeof(u_int32_t) * rom->len, M_DEVBUF,
		    M_WAITOK);
		MPRINTF("malloc(DEVBUF)", rom->data);
		/* Add 2 to account for info/crc and bus name skipped. */
		for (i = 0; i < rom->len; i++)
			rom->data[i] = t[i + 2];
	}

	/* The name field is always 4 bytes and always the 2nd field. */
	strncpy(rom->name, (char *)&t[1], 4);
	rom->name[4] = 0;

	/*
	 * Fill out the root directory. All these values are hardcoded so the
	 * parse/print/match routines have a standard layout to work against.
	 */

#ifdef	M_ZERO
	MALLOC(rom->root, struct p1212_dir *, sizeof(*rom->root),
	    M_DEVBUF, M_WAITOK|M_ZERO);
	MPRINTF("MALLOC(DEVBUF)", rom->root);
#else	/* M_ZERO */
	MALLOC(rom->root, struct p1212_dir *, sizeof(*rom->root),
	    M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", rom->root);
	bzero(rom->root, sizeof(*rom->root));
#endif	/* ! M_ZERO */
	rom->root->com.key.key_type = P1212_KEYTYPE_Directory;
	rom->root->com.key.key_value = 0;
	rom->root->com.key.key = (u_int8_t)P1212_KEYTYPE_Directory;
	rom->root->com.key.val = 0;
	TAILQ_INIT(&rom->root->data_root);
	TAILQ_INIT(&rom->root->subdir_root);

	if (p1212_parse_directory(rom->root, &t[next], mask)) {
		DPRINTF(("Parse error in ROM. Bailing\n"));
		p1212_free(rom);
		return NULL;
	}
	return rom;
}

int
p1212_parse_directory(struct p1212_dir *root, u_int32_t *addr, u_int32_t mask)
{
	struct p1212_dir *dir, *sdir;
	struct p1212_data *data;
	struct p1212_com *com;
	u_int32_t *t, desc;
	u_int16_t crclen, crc, crc1, crc2, romcrc;
	u_int8_t type, val;
	unsigned long size;
	int i, module_vendor_flag, module_sw_flag, node_sw_flag, unit_sw_flag;
	int node_capabilities_flag, offset, unit_location_flag, unitdir_cnt;
	int leafoff;
	int textcnt;
	int draft;
#ifdef	__OpenBSD__
	struct p1212_textdata **p;
#endif	/* __OpenBSD__ */

	t = addr;
	dir = root;

	module_vendor_flag = 0;
	module_sw_flag = 0;
	node_sw_flag = 0;
	node_capabilities_flag = 0;
	unitdir_cnt = 0;
	offset = 0;
	textcnt = 0;
	draft = 0;

	while (dir) {
		dir->match = 0;
		crclen = P1212_DIRENT_GET_LEN((ntohl(t[offset])));
		romcrc = P1212_DIRENT_GET_CRC((ntohl(t[offset])));

		crc = p1212_calc_crc(0, &t[offset + 1], crclen, 0);
		if (crc != romcrc) {
			crc1 = p1212_calc_crc(0, &t[offset + 1], crclen, 1);
			crc2 = p1212_calc_crc(0, &t[offset + 1], crclen, 2);
			if ((crc1 != romcrc) && (crc2 != romcrc)) {
				DPRINTF(("Invalid ROM: CRC: 0x%04hx, "
					    "Calculated CRC: "
					    "0x%04hx, CRC1: 0x%04hx",
					    ", CRC2: 0x%04hx\n",
					    (unsigned short)romcrc,
					    (unsigned short)crc,
					    (unsigned short)crc1,
					    (unsigned short)crc2));
				return 1;
			}
		}
		if (romcrc == crc2) {
			draft = 1;
			DPRINTF(("%s: warning byte-swapping rom problems"
			    " (off: 0x%04hx)\n", __func__, (u_int16_t)offset));
		}
		com = NULL;
		unit_sw_flag = 0;
		unit_location_flag = 0;
		offset++;

		if ((dir->parent == NULL) && dir->com.key.val) {
			DPRINTF(("Invalid root dir. key.val is 0x%0x and not"
			    " 0x0\n", dir->com.key.val));
			return 1;
		}

		for (i = offset; i < (offset + crclen); i++) {
			desc = ntohl(t[i]);
			type = P1212_DIRENT_GET_KEYTYPE(desc);
			val = P1212_DIRENT_GET_KEYVALUE(desc);

			/*
			 * Sanity check for valid types/locations/etc.
			 *
			 * See pages 79-100 of
			 * ISO/IEC 13213:1194(ANSI/IEEE Std 1212, 1994 edition)
			 * for specifics.
			 *
			 * XXX: These all really should be broken out into
			 * subroutines as it's grown large and complicated
			 * in certain cases.
			 */

			switch (val) {
			case P1212_KEYVALUE_Unit_Spec_Id:
			case P1212_KEYVALUE_Unit_Sw_Version:
			case P1212_KEYVALUE_Unit_Dependent_Info:
			case P1212_KEYVALUE_Unit_Location:
			case P1212_KEYVALUE_Unit_Poll_Mask:
				if (dir->parent == NULL) {
					DPRINTF(("Invalid ROM: %s is not "
					    "valid in the root directory.\n",
					    p1212_keyvalue_strings[val]));
					return 1;
				}
				break;
			default:
				if (dir->com.key.val ==
				    P1212_KEYVALUE_Unit_Directory) {
					DPRINTF(("Invalid ROM: %s is "
					    "not valid in a unit directory.\n",
					    p1212_keyvalue_strings[val]));
					return 1;
				}
				break;
			}

			switch (type) {
			case P1212_KEYTYPE_Immediate:
				if (p1212_validate_immed(val, mask)) {
					DPRINTF(("Invalid ROM: Can't have an "
					    "immediate type with %s value. Key"
					    " used at location 0x%0x in ROM\n",
					    p1212_keyvalue_strings[val],
					    (unsigned int)(&t[i]-&addr[0])));
					return 1;
				}
				break;
			case P1212_KEYTYPE_Offset:
				if (draft && val == 0)
					break;
				if (p1212_validate_offset(val, mask)) {
					DPRINTF(("Invalid ROM: Can't have "
					    "an offset type with key %s."
					    " Used at location 0x%0x in ROM\n",
					    p1212_keyvalue_strings[val],
					    (unsigned int)(&t[i]-&addr[0])));
					return 1;
				}
				break;
			case P1212_KEYTYPE_Leaf:
				if (p1212_validate_leaf(val, mask)) {
					DPRINTF(("Invalid ROM: Can't have a "
					    "leaf type with %s value. Key "
					    "used at location 0x%0x in ROM\n",
					    p1212_keyvalue_strings[val],
					    (unsigned int)(&t[i]-&addr[0])));
					return 1;
				}
				break;
			case P1212_KEYTYPE_Directory:
				if (p1212_validate_dir(val, mask)) {
					DPRINTF(("Invalid ROM: Can't have a "
					    "directory type with %s value. Key"
					    " used at location 0x%0x in ROM\n",
					    p1212_keyvalue_strings[val],
					    (unsigned int)(&t[i]-&addr[0])));
					return 1;
				}
				break;
			default:
				panic("Impossible type code: 0x%04hx",
				    (unsigned short)type);
				break;
			}

			/* Note flags for required fields. */

			if (val == P1212_KEYVALUE_Module_Vendor_Id) {
				module_vendor_flag = 1;
			}

			if (val == P1212_KEYVALUE_Node_Capabilities) {
				node_capabilities_flag = 1;
			}

			if (val == P1212_KEYVALUE_Unit_Sw_Version)
				unit_sw_flag = 1;

			if (val == P1212_KEYVALUE_Unit_Location)
				unit_location_flag = 1;

			/*
			 * This is just easier to spell out. You can't have
			 * a module sw version if you include a node sw version
			 * and vice-versa. Both aren't allowed if you have unit
			 * dirs.
			 */

			if (val == P1212_KEYVALUE_Module_Sw_Version) {
				if (node_sw_flag) {
					DPRINTF(("Can't have a module software"
					    " version along with a node "
					    "software version entry\n"));
					return 1;
				}
				if (!draft && unitdir_cnt) {
					DPRINTF(("Can't have unit directories "
					    "with module software version "
					    "defined.\n"));
					return 1;
				}
				module_sw_flag = 1;
			}

			if (val == P1212_KEYVALUE_Node_Sw_Version) {
				if (module_sw_flag) {
					DPRINTF(("Can't have a node software "
					    "version along with a module "
					    "software version entry\n"));
					return 1;
				}
				if (!draft && unitdir_cnt) {
					DPRINTF(("Can't have unit directories "
					    "with node software version "
					    "defined.\n"));
					return 1;
				}
				node_sw_flag = 1;
			}

			if (val == P1212_KEYVALUE_Unit_Directory) {
				if (!draft &&
				    (module_sw_flag || node_sw_flag)) {
					DPRINTF(("Can't have unit directories "
					    "with either module or node "
					    "software version defined.\n"));
					return 1;
				}
				unitdir_cnt++;
			}

			/*
			 * Text descriptors are special. They describe the
			 * last entry they follow. So they need to be included
			 * with it's struct and there's nothing in the spec
			 * preventing one from putting text descriptors after
			 * directory descriptors. Also they can be a single
			 * value or a list of them in a directory format so
			 * account for either. Finally if they're in a
			 * directory those can be the only types in a
			 * directory.
			 */

			if (val == P1212_KEYVALUE_Textual_Descriptor) {

				size = sizeof(*p);
				leafoff = P1212_DIRENT_GET_VALUE(desc);
				leafoff += i;

				if (com == NULL) {
					DPRINTF(("Can't have a text descriptor"
					    " as the first entry in a "
					    "directory\n"));
					return 1;
				}

				if (textcnt++ != 0) {
					DPRINTF(("Text descriptors can't "
					    "follow each other in a "
					    "directory\n"));
					return 1;
				}

				if (type == P1212_KEYTYPE_Leaf) {
#ifdef	__NetBSD__
					com->text = realloc(com->text,
					    size * (com->textcnt + 1),
					    M_DEVBUF, M_WAITOK);
#else	/* __NetBSD__ */
					p = malloc(size * (com->textcnt + 1),
					    M_DEVBUF, M_WAITOK);
					MPRINTF("malloc(DEVBUF)", p);
					if (com->text != NULL) {
						bcopy(com->text, p,
						    size * com->textcnt);
						free(com->text, M_DEVBUF);
						MPRINTF("free(DEVBUF)", com->text);
						com->text = NULL;	/* XXX */
					}
					com->text = p;
#endif	/* ! __NetBSD__ */
					com->text[com->textcnt] =
					    p1212_parse_text_desc(&t[leafoff]);
					if (com->text[com->textcnt] == NULL) {
						DPRINTF(("Got an error parsing"
						    " text descriptor at "
						    "offset 0x%0x\n",
						    &t[leafoff]-&addr[0]));
						free(com->text, M_DEVBUF);
						MPRINTF("free(DEVBUF)", com->text);
						com->text = NULL;	/* XXX */
						return 1;
					}
					com->textcnt++;
				} else {
					i = p1212_parse_textdir(com,
						&t[leafoff]);
					if (i)
						return 1;
					textcnt = 0;
				}
			} else
				textcnt = 0;

			if ((type != P1212_KEYTYPE_Directory) &&
			    (val != P1212_KEYVALUE_Textual_Descriptor)) {
#ifdef	M_ZERO
				MALLOC(data, struct p1212_data *, sizeof(*data),
				    M_DEVBUF, M_WAITOK|M_ZERO);
				MPRINTF("MALLOC(DEVBUF)", data);
#else	/* M_ZERO */
				MALLOC(data, struct p1212_data *, sizeof(*data),
				    M_DEVBUF, M_WAITOK);
				MPRINTF("MALLOC(DEVBUF)", data);
				bzero(data, sizeof(struct p1212_data));
#endif	/* ! M_ZERO */
				data->com.key.key_type = type;
				data->com.key.key_value = val;
				data->com.key.key =
				    P1212_DIRENT_GET_KEY((ntohl(t[i])));
				data->com.key.val =
				    P1212_DIRENT_GET_VALUE((ntohl(t[i])));
				com = &data->com;

				/*
				 * Don't try and read the offset. It may be
				 * a register or something special. Generally
				 * these are node specific so let the upper
				 * level code figure it out.
				 */

				if ((type == P1212_KEYTYPE_Immediate) ||
				    (type == P1212_KEYTYPE_Offset))
					data->val = data->com.key.val;

				data->leafdata = NULL;
				TAILQ_INSERT_TAIL(&dir->data_root, data, data);

				if (type == P1212_KEYTYPE_Leaf) {
					leafoff = i + data->com.key.val;
					data->leafdata =
					    p1212_parse_leaf(&t[leafoff]);
					if (data->leafdata == NULL) {
						DPRINTF(("Error parsing leaf\n"));
						return 1;
					}
				}
			}
			if (type == P1212_KEYTYPE_Directory) {

#ifdef	M_ZERO
				MALLOC(sdir, struct p1212_dir *, sizeof(*sdir),
					M_DEVBUF, M_WAITOK|M_ZERO);
				MPRINTF("MALLOC(DEVBUF)", sdir);
#else	/* M_ZERO */
				MALLOC(sdir, struct p1212_dir *, sizeof(*sdir),
					M_DEVBUF, M_WAITOK);
				MPRINTF("MALLOC(DEVBUF)", sdir);
				bzero(sdir, sizeof(struct p1212_dir));
#endif	/* ! M_ZERO */
				sdir->parent = dir;
				sdir->com.key.key_type = type;
				sdir->com.key.key_value = val;
				sdir->com.key.key =
				    P1212_DIRENT_GET_KEY((ntohl(t[i])));
				sdir->com.key.val =
				    P1212_DIRENT_GET_VALUE((ntohl(t[i])));
				com = &sdir->com;
				sdir->match = sdir->com.key.val + i;
				TAILQ_INIT(&sdir->data_root);
				TAILQ_INIT(&sdir->subdir_root);
				TAILQ_INSERT_TAIL(&dir->subdir_root, sdir,dir);
			}
		}

		/* More validity checks. */

		if (dir->parent == NULL) {
			if (module_vendor_flag == 0) {
				DPRINTF(("Missing module vendor entry in root "
				    "directory.\n"));
				return 1;
			}
#if 0			/* XXX : Not Mandatory */
			if (node_capabilities_flag == 0) {
				DPRINTF(("Missing node capabilities entry in "
				    "root directory.\n"));
				return 1;
			}
#endif
		} else {
			if ((unitdir_cnt > 1) && (unit_location_flag == 0)) {
				DPRINTF(("Must have a unit location in each "
				    "unit directory when more than one unit "
				    "directory exists.\n"));
				return 1;
			}
		}

		/*
		 * Ok, done with this directory and it's sanity checked. Now
		 * loop through and either find an unparsed subdir or one
		 * farther back up the chain.
		 */

		if (!TAILQ_EMPTY(&dir->subdir_root)) {
			sdir = TAILQ_FIRST(&dir->subdir_root);
		} else {
			do {
				sdir = TAILQ_NEXT(dir, dir);
				if (sdir == NULL) {
					dir = dir->parent;
				}
			} while ((sdir == NULL) && (dir != NULL));
		}
		if (dir) {
			dir = sdir;
			if (!dir->match) {
				DPRINTF(("Invalid subdir..Has no offset\n"));
				return 1;
			}
			offset = dir->match;
		}
	}
	return 0;
}

struct p1212_leafdata *
p1212_parse_leaf(u_int32_t *t)
{
	u_int16_t crclen, crc, crc1, crc2, romcrc;
	struct p1212_leafdata *leafdata;
	int i;

	crclen = P1212_DIRENT_GET_LEN((ntohl(t[0])));
	romcrc = P1212_DIRENT_GET_CRC((ntohl(t[0])));
	crc = p1212_calc_crc(0, &t[1], crclen, 0);
	crc1 = p1212_calc_crc(0,&t[1], crclen, 1);
	crc2 = p1212_calc_crc(0,&t[1], crclen, 2);
	if ((crc != romcrc) && (crc1 != romcrc) && (crc2 != romcrc)) {
		DPRINTF(("Invalid ROM: CRC: 0x%04hx, Calculated CRC: "
		    "0x%04hx, CRC1: 0x%04hx, CRC2: 0x%04hx\n",
		    (unsigned short)romcrc, (unsigned short)crc,
		    (unsigned short)crc1, (unsigned short)crc2));
		return NULL;
	}
	if (romcrc == crc2)
		DPRINTF(("%s: warning byte-swapping rom problems\n", __func__));
	t++;

	/*
	 * Most of these are vendor specific so don't bother trying to map them
	 * out. Anything which needs them later on can extract them.
	 */

	MALLOC(leafdata, struct p1212_leafdata *, sizeof(*leafdata),
	    M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", leafdata);
	leafdata->data = malloc((sizeof(u_int32_t) * crclen), M_DEVBUF,
	    M_WAITOK);
	MPRINTF("malloc(DEVBUF)", leafdata->data);
	leafdata->len = crclen;
	for (i = 0; i < crclen; i++)
		leafdata->data[i] = ntohl(t[i]);
	return leafdata;
}

int
p1212_parse_textdir(struct p1212_com *com, u_int32_t *addr)
{
	u_int32_t *t, entry, new;
	u_int16_t crclen, crc, crc1, crc2, romcrc;
	u_int8_t type, val;
#ifdef	__OpenBSD__
	struct p1212_textdata **p;
#endif	/* __OpenBSD__ */

	int i, size;

	/*
	 * A bit more complicated. A directory for a text descriptor can
	 * contain text descriptor leaf nodes only.
	 */

	com->text = NULL;
	size = sizeof(*p);

	crclen = P1212_DIRENT_GET_LEN((ntohl(t[0])));
	romcrc = P1212_DIRENT_GET_CRC((ntohl(t[0])));
	crc = p1212_calc_crc(0, &t[1], crclen, 0);
	crc1 = p1212_calc_crc(0,&t[1], crclen, 1);
	crc2 = p1212_calc_crc(0,&t[1], crclen, 2);
	if ((crc != romcrc) && (crc1 != romcrc) && (crc2 != romcrc)) {
		DPRINTF(("Invalid ROM: CRC: 0x%04hx, Calculated CRC: "
			    "0x%04hx, CRC1: 0x%04hx, CRC2: 0x%04hx\n",
			    (unsigned short)romcrc, (unsigned short)crc,
			    (unsigned short)crc1, (unsigned short)crc2));
		return 1;
	}
	if (romcrc == crc2)
		DPRINTF(("%s: warning byte-swapping rom problems\n", __func__));
	t++;
	for (i = 0; i < crclen; i++) {
		entry = ntohl(t[i]);

		type = P1212_DIRENT_GET_KEYTYPE(entry);
		val = P1212_DIRENT_GET_KEYVALUE(entry);
		if ((type != P1212_KEYTYPE_Leaf) ||
		    (val != P1212_KEYVALUE_Textual_Descriptor)) {
			DPRINTF(("Text descriptor directories can only "
			    "contain text descriptors. Type: %s, value: %s "
			    "isn't valid at offset 0x%0x\n",
			    p1212_keytype_strings[type],
			    p1212_keyvalue_strings[val], &t[i]-&addr[0]));
			return 1;
		}

		new = P1212_DIRENT_GET_VALUE(entry);
#ifdef	__NetBSD__
		com->text = realloc(com->text, size * (com->textcnt + 1),
		    M_DEVBUF, M_WAITOK);
#else	/* __NetBSD__ */
		p = malloc(size * (com->textcnt + 1), M_DEVBUF, M_WAITOK);
		MPRINTF("malloc(DEVBUF)", p);
		bzero(&p[com->textcnt], size);
		if (com->text != NULL) {
			bcopy(com->text, p, size * (com->textcnt));
			free(com->text, M_DEVBUF);
			MPRINTF("free(DEVBUF)", com->text);
			com->text = NULL;	/* XXX */
		}
		com->text = p;
#endif	/* ! __NetBSD__ */
		if ((com->text[i] = p1212_parse_text_desc(&t[i+new])) == NULL) {
			DPRINTF(("Got an error parsing text descriptor.\n"));
			if (com->textcnt == 0) {
				free(com->text, M_DEVBUF);
				MPRINTF("free(DEVBUF)", com->text);
				com->text = NULL;	/* XXX */
			}
			return 1;
		}
		com->textcnt++;
	}
	return 0;
}

struct p1212_textdata *
p1212_parse_text_desc(u_int32_t *addr)
{
	u_int32_t *t;
	u_int16_t crclen, crc, crc1, crc2, romcrc;
	struct p1212_textdata *text;
	int size;

	t = addr;

	crclen = P1212_DIRENT_GET_LEN((ntohl(t[0])));
	romcrc = P1212_DIRENT_GET_CRC((ntohl(t[0])));

	if (crclen < P1212_TEXT_Min_Leaf_Length) {
		DPRINTF(("Invalid ROM: text descriptor too short\n"));
		return NULL;
	}

	crc = p1212_calc_crc(0, &t[1], crclen, 0);
	if (crc != romcrc) {
		crc1 = p1212_calc_crc(0, &t[1], crclen, 1);
		crc2 = p1212_calc_crc(0, &t[1], crclen, 2);
		if ((crc1 != romcrc) && (crc2 != romcrc)) {
			DPRINTF(("Invalid ROM: CRC: 0x%04hx, Calculated CRC: "
			    "0x%04hx, CRC1: 0x%04hx, CRC1: 0x%04hx\n",
			    (unsigned short)romcrc, (unsigned short)crc,
			    (unsigned short)crc1, (unsigned short)crc2));
			return NULL;
		}
	}
	if (romcrc == crc2)
		DPRINTF(("%s: warning byte-swapping rom problems\n", __func__));

	t++;
	MALLOC(text, struct p1212_textdata *, sizeof(*text), M_DEVBUF,
	    M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", text);
	text->spec_type = P1212_TEXT_GET_Spec_Type((ntohl(t[0])));
	text->spec_id = P1212_TEXT_GET_Spec_Id((ntohl(t[0])));
	text->lang_id = ntohl(t[1]);

	t++;
	t++;
	crclen -= 2;
	size = (crclen * sizeof(u_int32_t));

#ifdef	M_ZERO
	text->text = malloc(size + 1, M_DEVBUF, M_WAITOK|M_ZERO);
	MPRINTF("malloc(DEVBUF)", text->text);
#else	/* M_ZERO */
	text->text = malloc(size + 1, M_DEVBUF, M_WAITOK);
	MPRINTF("malloc(DEVBUF)", text->text);
	bzero(text->text, size + 1);
#endif	/* ! M_ZERO */

	bcopy(&t[0], text->text, size);

	return text;
}

struct p1212_key **
p1212_find(struct p1212_dir *root, int type, int value, int flags)
{
	struct p1212_key **retkeys;
	struct p1212_dir *dir, *sdir, *parent;
	struct p1212_data *data;
	int numkeys;
#ifdef	__OpenBSD__
	struct p1212_key **p;
#endif	/* __OpenBSD__ */

	numkeys = 0;
	retkeys = NULL;

	if ((type < P1212_KEYTYPE_Immediate) ||
	    (type > P1212_KEYTYPE_Directory)) {
		DPRINTF(("p1212_find: invalid type - %d\n", type));
		return NULL;
	}

	if ((value < -1) ||
	    (value > (sizeof(p1212_keyvalue_strings) / sizeof(char *)))) {
		DPRINTF(("p1212_find: invalid value - %d\n", value));
		return NULL;
	}

	if (flags & ~(P1212_FIND_SEARCHALL | P1212_FIND_RETURNALL)) {
		DPRINTF(("p1212_find: invalid flags - %d\n", flags));
		return NULL;
	}

	/*
	 * Part of this is copied from p1212_walk to do depth first traversal
	 * without using recursion. Using the walk API would have made things
	 * more complicated in trying to build up the return struct otherwise.
	 */

	dir = root;
	sdir = NULL;

	parent = root->parent;
	root->parent = NULL;

	while (dir) {
		if (type == P1212_KEYTYPE_Directory) {
			TAILQ_FOREACH(sdir, &dir->subdir_root, dir) {
				if ((sdir->com.key.key_value == value) ||
				    (value == -1)) {
					numkeys++;
#ifdef	__NetBSD__
					retkeys = realloc(retkeys,
					    sizeof(struct p1212_key *) *
					    (numkeys + 1), M_DEVBUF, M_WAITOK);
#else	/* __NetBSD__ */
					p = malloc(sizeof(struct p1212_key *) *
					    (numkeys + 1), M_DEVBUF, M_WAITOK);
					MPRINTF("malloc(DEVBUF)", p);
					if (retkeys != NULL) {
						bcopy(retkeys, p, numkeys *
						    sizeof(struct p1212_key *));
						free(retkeys, M_DEVBUF);
						MPRINTF("free(DEVBUF)", retkeys);
						retkeys = NULL;	/* XXX */
					}
					retkeys = p;
#endif	/* ! __NetBSD__ */
					retkeys[numkeys - 1] = &sdir->com.key;
					retkeys[numkeys] = NULL;
					if ((flags & P1212_FIND_RETURNALL)
					    == 0) {
						root->parent = parent;
						return retkeys;
					}
				}
			}
		} else {
			TAILQ_FOREACH(data, &dir->data_root, data) {
				if (((data->com.key.key_type == type) &&
				     (data->com.key.key_value == value)) ||
				    ((data->com.key.key_type == type) &&
				     (value == -1))) {
					numkeys++;
#ifdef	__NetBSD__
					retkeys = realloc(retkeys,
					    sizeof(struct p1212_key *) *
					    (numkeys + 1), M_DEVBUF, M_WAITOK);
#else	/* __NetBSD__ */
					p = malloc(sizeof(struct p1212_key *) *
					    (numkeys + 1), M_DEVBUF, M_WAITOK);
					MPRINTF("malloc(DEVBUF)", p);
					if (retkeys != NULL) {
						bcopy(retkeys, p, numkeys *
						    sizeof(struct p1212_key *));
						free(retkeys, M_DEVBUF);
						MPRINTF("free(DEVBUF)", retkeys);
						retkeys = NULL;	/* XXX */
					}
					retkeys = p;
#endif	/* ! __NetBSD__ */
					retkeys[numkeys - 1] = &data->com.key;
					retkeys[numkeys] = NULL;
					if ((flags & P1212_FIND_RETURNALL)
					    == 0) {
						root->parent = parent;
						return retkeys;
					}
				}
			}
		}
		if (flags & P1212_FIND_SEARCHALL) {
			do {
				sdir = TAILQ_NEXT(dir, dir);
				if (sdir == NULL) {
					dir = dir->parent;
				}
			} while ((sdir == NULL) && (dir != NULL));
			dir = sdir;
		} else
			dir = NULL;
	}
	root->parent = parent;
	return retkeys;
}

void
p1212_walk(struct p1212_dir *root, void *arg,
    void (*func)(struct p1212_key *, void *))
{
	struct p1212_data *data;
	struct p1212_dir *sdir, *dir, *parent;

	dir = root;
	sdir = NULL;

	if (func == NULL) {
		DPRINTF(("p1212_walk: Passed in NULL function\n"));
		return;
	}
	if (root == NULL) {
		DPRINTF(("p1212_walk: Called with NULL root\n"));
		return;
	}

	/* Allow walking from any point. Just mark the starting point. */
	parent = root->parent;
	root->parent = NULL;

	/*
	 * Depth first traversal that doesn't use recursion.
	 *
	 * Call the function first for the directory node and then loop through
	 * all the data nodes and call the function for them.
	 *
	 * Finally, figure out the next possible directory node if one is
	 * available or bail out.
	 */

	while (dir) {
		func((struct p1212_key *) dir, arg);
		TAILQ_FOREACH(data, &dir->data_root, data)
			func((struct p1212_key *) data, arg);
		if (!TAILQ_EMPTY(&dir->subdir_root)) {
			sdir = TAILQ_FIRST(&dir->subdir_root);
		} else {
			do {
				sdir = TAILQ_NEXT(dir, dir);
				if (sdir == NULL) {
					dir = dir->parent;
				}
			} while ((sdir == NULL) && dir);
		}
		dir = sdir;
	}

	root->parent = parent;
}

void
p1212_print(struct p1212_dir *dir)
{
	int indent;

	indent = 0;

	p1212_walk(dir, &indent, p1212_print_node);
	printf("\n");
}

void
p1212_print_node(struct p1212_key *key, void *arg)
{

	struct p1212_data *data;
	struct p1212_dir *sdir, *dir;
	int i, j, *indent;

	indent = arg;

	if (key->key_type == P1212_KEYTYPE_Directory) {
		dir = (struct p1212_dir *) key;
		data = NULL;
	} else {
		data = (struct p1212_data *) key;
		dir = NULL;
	}

	/* Recompute the indent level on each directory. */
	if (dir) {
		*indent = 0;
		sdir = dir->parent;
		while (sdir != NULL) {
			(*indent)++;
			sdir = sdir->parent;
		}
	}

	if (dir && dir->parent)
		printf("\n");

	/* Set the indent string up. 4 spaces per level. */
	for (i = 0; i < (*indent * 4); i++)
		printf(" ");

	if (dir) {
		printf("Directory: ");
		if (dir->print)
			dir->print(dir);
		else {
			if (key->key_value >=
			    (sizeof(p1212_keyvalue_strings) / sizeof(char *)))
				printf("Unknown type 0x%04hx\n",
				    (unsigned short)key->key_value);
			else
				printf("%s\n",
				    p1212_keyvalue_strings[key->key_value]);
		}
		if (dir->com.textcnt) {
			for (i = 0; i < dir->com.textcnt; i++) {
				for (j = 0; j < (*indent * 4); j++)
					printf(" ");
				printf("Text descriptor: %s\n",
				    dir->com.text[i]->text);
			}
		}
		printf("\n");
	} else {
		if (data->print)
			data->print(data);
		else {
			if (key->key_value >=
			    (sizeof(p1212_keyvalue_strings) / sizeof(char *)))
				printf("Unknown type 0x%04hx: ",
				    (unsigned short)key->key_value);
			else
				printf("%s: ",
				    p1212_keyvalue_strings[key->key_value]);

			printf("0x%08x\n", key->val);
#ifdef	DIAGNOSTIC
			if ((data->com.key.key_type == P1212_KEYTYPE_Leaf) &&
			    (data->leafdata == NULL))
				panic("Invalid data node in configrom tree");
#endif	/* DIAGNOSTIC */

			if (data->leafdata) {
				for (i = 0; i < data->leafdata->len; i++) {
					for (j = 0; j < (*indent * 4); j++)
						printf(" ");
					printf ("Leaf data: 0x%08x\n",
					    data->leafdata->data[i]);
				}
			}
			if (data->com.textcnt)
				for (i = 0; i < data->com.textcnt; i++) {
					for (j = 0; j < (*indent * 4); j++)
						printf(" ");
					printf("Text descriptor: %s\n",
					    data->com.text[i]->text);
				}

		}
	}
}


void
p1212_free(struct p1212_rom *rom)
{
	struct p1212_dir *sdir, *dir;
	struct p1212_data *data;
	int i;

	dir = rom->root;

	/* Avoid recursing. Find the bottom most node and work back. */
	while (dir) {
		if (!TAILQ_EMPTY(&dir->subdir_root)) {
			sdir = TAILQ_FIRST(&dir->subdir_root);
			if (TAILQ_EMPTY(&sdir->subdir_root)) {
				TAILQ_REMOVE(&dir->subdir_root, sdir, dir);
				dir = sdir;
			}
			else {
				dir = sdir;
				continue;
			}
		} else {
			if (dir->parent)
				TAILQ_REMOVE(&dir->parent->subdir_root, dir,
				    dir);
		}

		while ((data = TAILQ_FIRST(&dir->data_root))) {
			if (data->leafdata) {
				if (data->leafdata->data) {
					free(data->leafdata->data, M_DEVBUF);
					MPRINTF("free(DEVBUF)", data->leafdata->data);
					data->leafdata->data = NULL;	/* XXX */
				}
				FREE(data->leafdata, M_DEVBUF);
				MPRINTF("FREE(DEVBUF)", data->leafdata);
				data->leafdata = NULL;	/* XXX */
			}
			TAILQ_REMOVE(&dir->data_root, data, data);
			if (data->com.textcnt) {
				for (i = 0; i < data->com.textcnt; i++) {
					free(data->com.text[i]->text, M_DEVBUF);
					MPRINTF("free(DEVBUF)", data->com.text[i]->text);
					data->com.text[i]->text = NULL;	/* XXX */
					FREE(data->com.text[i], M_DEVBUF);
					MPRINTF("FREE(DEVBUF)", data->com.text[i]);
					data->com.text[i] = NULL;	/* XXX */
				}
				free(data->com.text, M_DEVBUF);
				MPRINTF("free(DEVBUF)", data->com.text);
				data->com.text = NULL;	/* XXX */
			}
			FREE(data, M_DEVBUF);
			MPRINTF("FREE(DEVBUF)", data);
			data = NULL;	/* XXX */
		}
		sdir = dir;
		if (dir->parent)
			dir = dir->parent;
		else
			dir = NULL;
		if (sdir->com.textcnt) {
			for (i = 0; i < sdir->com.textcnt; i++) {
				FREE(sdir->com.text[i], M_DEVBUF);
				MPRINTF("FREE(DEVBUF)", sdir->com.text[i]);
				sdir->com.text[i] = NULL;	/* XXX */
			}
			free(sdir->com.text, M_DEVBUF);
			MPRINTF("free(DEVBUF)", sdir->com.text);
			sdir->com.text = NULL;	/* XXX */
		}
		FREE(sdir, M_DEVBUF);
		MPRINTF("FREE(DEVBUF)", sdir);
		sdir = NULL;	/* XXX */
	}
	if (rom->len) {
		free(rom->data, M_DEVBUF);
		MPRINTF("free(DEVBUF)", rom->data);
		rom->data = NULL;	/* XXX */
	}
	FREE(rom, M_DEVBUF);
	MPRINTF("FREE(DEVBUF)", rom);
	rom = NULL;	/* XXX */
}

/*
 * A fairly well published reference implementation of the CRC routine had
 * a typo in it and some devices may be using it rather than the correct one
 * in calculating their ROM CRC's. To compensate an interface for generating
 * either is provided.
 *
 * len is the number of u_int32_t entries, not bytes.
 */

u_int16_t
p1212_calc_crc(u_int16_t seed, u_int32_t *data, int len, int broke)
{
	u_int16_t sum, crc = seed;
	int i, shift;

	for (i = 0; i < len; i++) {
		for (shift = 28; shift >= 0; shift -= 4) {
			/*
			 * The 1st broken implementation doesn't do the
			 * last shift.
			 */
			if (shift == 0 && broke == 1)
				break;

			if (broke == 2)
				sum = ((crc >> 12) ^
				    (letoh32(data[i]) >> shift)) & 0xF;
			else
				sum = ((crc >> 12) ^
				    (ntohl(data[i]) >> shift)) & 0xF;
			crc = (crc << 4) ^ (sum << 12) ^ (sum << 5) ^ sum;
		}
	}

	if (broke == 2)
		return swap16(crc);
	else
		return (crc);
}

/*
 * This is almost identical to the standard autoconf *match idea except it
 * can match and attach multiple children in one pass.
 */

struct device **
p1212_match_units(struct device *sc, struct p1212_dir *dir,
    int (*print)(void *, const char *))
{
	struct p1212_dir **udirs;
	struct device **devret, *dev;
	int numdev, i;
#ifdef	__OpenBSD__
	struct device **p;
#endif	/* __OpenBSD__ */

	/*
	 * Setup typically return val. Always allocate one extra pointer for a
	 * NULL guard end pointer.
	 */

	numdev = 0;
	devret = malloc(sizeof(struct device *) * 2, M_DEVBUF, M_WAITOK);
	MPRINTF("malloc(DEVBUF)", devret);
	devret[0] = devret[1] = NULL;

	udirs = (struct p1212_dir **)p1212_find(dir, P1212_KEYTYPE_Directory,
	    P1212_KEYVALUE_Unit_Directory,
	    P1212_FIND_SEARCHALL|P1212_FIND_RETURNALL);

	if (udirs) {
		i = 0;
		do {
			dev = config_found_sm(sc, &udirs[i], print, NULL);
			if (dev && numdev) {
#ifdef	__NetBSD__
				devret = realloc(devret,
				    sizeof(struct device *) *
				    (numdev + 2), M_DEVBUF, M_WAITOK);
#else	/* __NetBSD__ */
				p = malloc(sizeof(struct device *) *
				    (numdev + 2), M_DEVBUF, M_WAITOK);
				MPRINTF("malloc(DEVBUF)", p);
				bcopy(devret, p,
				    numdev * sizeof(struct device *));
				free(devret, M_DEVBUF);
				MPRINTF("free(DEVBUF)", devret);
				devret = p;
#endif	/* ! __NetBSD__ */
				devret[numdev++] = dev;
				devret[numdev] = NULL;
			} else if (dev) {
				devret[0] = dev;
				numdev++;
			}
		} while (udirs[++i]);

		free(udirs, M_DEVBUF);
		MPRINTF("free(DEVBUF)", udirs);
		udirs = NULL;	/* XXX */
	}
	if (numdev == 0) {
		free(devret, M_DEVBUF);
		MPRINTF("free(DEVBUF)", devret);
		devret = NULL;	/* XXX */
		return NULL;
	}
	return devret;
}

/*
 * Make these their own functions as they have slightly complicated rules.
 *
 * For example:
 *
 * Under normal circumstances only the 2 extent types can be offset
 * types. However some spec's which use p1212 like SBP2 for
 * firewire/1394 will define a dependent info type as an offset value.
 * Allow the upper level code to flag this and pass it down during
 * parsing. The same thing applies to immediate types.
 */

int
p1212_validate_offset(u_int16_t val, u_int32_t mask)
{
	if ((val == P1212_KEYVALUE_Node_Units_Extent) ||
	    (val == P1212_KEYVALUE_Node_Memory_Extent) ||
	    ((mask & P1212_ALLOW_DEPENDENT_INFO_OFFSET_TYPE) &&
	     ((val == P1212_KEYVALUE_Unit_Dependent_Info) ||
	      (val == P1212_KEYVALUE_Node_Dependent_Info) ||
	      (val == P1212_KEYVALUE_Module_Dependent_Info))))
		return 0;
	return 1;
}

int
p1212_validate_immed(u_int16_t val, u_int32_t mask)
{
	switch (val) {
	case P1212_KEYVALUE_Textual_Descriptor:
	case P1212_KEYVALUE_Bus_Dependent_Info:
	case P1212_KEYVALUE_Module_Dependent_Info:
	case P1212_KEYVALUE_Node_Unique_Id:
	case P1212_KEYVALUE_Node_Dependent_Info:
	case P1212_KEYVALUE_Unit_Directory:
	case P1212_KEYVALUE_Unit_Dependent_Info:
	case P1212_KEYVALUE_Unit_Location:
		if ((mask & P1212_ALLOW_DEPENDENT_INFO_IMMED_TYPE) &&
		    ((val == P1212_KEYVALUE_Module_Dependent_Info) ||
		     (val == P1212_KEYVALUE_Node_Dependent_Info) ||
		     (val == P1212_KEYVALUE_Unit_Dependent_Info)))
			break;
		return 1;
		break;
	default:
		break;
	}
	return 0;
}

int
p1212_validate_leaf(u_int16_t val, u_int32_t mask)
{
	switch(val) {
	case P1212_KEYVALUE_Textual_Descriptor:
	case P1212_KEYVALUE_Bus_Dependent_Info:
	case P1212_KEYVALUE_Module_Dependent_Info:
	case P1212_KEYVALUE_Node_Unique_Id:
	case P1212_KEYVALUE_Node_Dependent_Info:
	case P1212_KEYVALUE_Unit_Dependent_Info:
	case P1212_KEYVALUE_Unit_Location:
		break;
	default:
		return 1;
		break;
	}
	return 0;
}

int
p1212_validate_dir(u_int16_t val, u_int32_t mask)
{
	switch(val) {
	case P1212_KEYVALUE_Textual_Descriptor:
	case P1212_KEYVALUE_Bus_Dependent_Info:
	case P1212_KEYVALUE_Module_Dependent_Info:
	case P1212_KEYVALUE_Node_Dependent_Info:
	case P1212_KEYVALUE_Unit_Directory:
	case P1212_KEYVALUE_Unit_Dependent_Info:
		break;
	default:
		if ((mask & P1212_ALLOW_VENDOR_DIRECTORY_TYPE) &&
		    (val == P1212_KEYVALUE_Module_Vendor_Id))
			break;
		return 1;
		break;
	}
	return 0;
}
@


1.6
log
@Cleaner equivalent to p1212_calc_crc() + some param shortcuts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee1212.c,v 1.5 2002/12/30 11:26:48 tdeval Exp $	*/
@


1.5
log
@Some devices have bad ConfigROM crc, but contain valid Unit entries.
So just ignore, and continue the auto-configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee1212.c,v 1.4 2002/12/13 21:35:11 tdeval Exp $	*/
d54 1
a54 1
u_int16_t p1212_calc_crc(u_int32_t, u_int32_t *, int, int);
d143 1
a143 1
	offset = P1212_ROMFMT_GET_INFOLEN((ntohl(t[0]))) + 1;
d324 1
a324 1
	int i;
d341 4
a344 2
	crc = p1212_calc_crc(0, &t[1], P1212_ROMFMT_GET_CRCLEN((ntohl(t[0]))),
		0);
a345 1
	romcrc = P1212_ROMFMT_GET_CRC((ntohl(t[0])));
d347 2
a348 4
		crc1 = p1212_calc_crc(0, &t[1],
		    P1212_ROMFMT_GET_CRCLEN((ntohl(t[0]))), 1);
		crc2 = p1212_calc_crc(0, &t[1],
		    P1212_ROMFMT_GET_CRCLEN((ntohl(t[0]))), 2);
d1405 1
a1405 1
p1212_calc_crc(u_int32_t crc, u_int32_t *data, int len, int broke)
d1407 2
a1408 3
	int shift;
	u_int32_t sum;
	int i;
d1411 8
a1418 1
		for (shift = 28; shift > 0; shift -= 4) {
d1421 1
a1421 1
				    (letoh32(data[i]) >> shift)) & 0x0000000f;
d1423 2
a1424 2
				sum = ((crc >> 12) ^ (ntohl(data[i]) >> shift))
				    & 0x0000000f;
a1426 15


		/* The broken implementation doesn't do the last shift. */
		switch (broke) {
		case 0:
			sum = ((crc >> 12) ^ ntohl(data[i])) & 0x0000000f;
			crc = (crc << 4) ^ (sum << 12) ^ (sum << 5) ^ sum;
			break;
		case 2:
			sum = ((crc >> 12) ^ letoh32(data[i])) & 0x0000000f;
			crc = (crc << 4) ^ (sum << 12) ^ (sum << 5) ^ sum;
			break;
		default:
			break;
		}
d1430 1
a1430 1
		return swap16((u_int16_t)crc);
d1432 1
a1432 1
		return (u_int16_t)crc;
@


1.4
log
@Malloc debug cleaning (MPRINTF).
Uses option FW_MALLOC_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee1212.c,v 1.3 2002/12/13 02:52:11 tdeval Exp $	*/
d355 1
d357 1
@


1.3
log
@Better memory balancing (between alloc/free),
some enhancements, lots of debugging, KNF...
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee1212.c,v 1.2 2002/06/26 13:50:56 tdeval Exp $	*/
d77 1
d80 3
d260 1
a260 1
				//MPRINTF_OLD("malloc(DEVBUF)", p);
d264 1
a264 1
					//MPRINTF_OLD("free(DEVBUF)", dirs);
d282 1
a282 1
				//MPRINTF_OLD("free(DEVBUF)", dirs);
d296 1
a296 1
				//MPRINTF_OLD("malloc(DEVBUF)", p);
d299 1
a299 1
				//MPRINTF_OLD("free(DEVBUF)", dirs);
d304 1
a304 1
				//MPRINTF_OLD("free(DEVBUF)", dirs);
d366 1
a366 1
	//MPRINTF_OLD("MALLOC(DEVBUF)", rom);
d373 1
a373 1
		//MPRINTF_OLD("FREE(DEVBUF)", rom);
d384 1
a384 1
		//MPRINTF_OLD("malloc(DEVBUF)", rom->data);
d402 1
a402 1
	//MPRINTF_OLD("MALLOC(DEVBUF)", rom->root);
d406 1
a406 1
	//MPRINTF_OLD("MALLOC(DEVBUF)", rom->root);
d688 1
a688 1
					//MPRINTF_OLD("malloc(DEVBUF)", p);
d693 1
a693 1
						//MPRINTF_OLD("free(DEVBUF)", com->text);
d706 1
a706 1
						//MPRINTF_OLD("free(DEVBUF)", com->text);
d726 1
a726 1
				//MPRINTF_OLD("MALLOC(DEVBUF)", data);
d730 1
a730 1
				//MPRINTF_OLD("MALLOC(DEVBUF)", data);
d770 1
a770 1
				//MPRINTF_OLD("MALLOC(DEVBUF)", sdir);
d774 1
a774 1
				//MPRINTF_OLD("MALLOC(DEVBUF)", sdir);
d874 1
a874 1
	//MPRINTF_OLD("MALLOC(DEVBUF)", leafdata);
d877 1
a877 1
	//MPRINTF_OLD("malloc(DEVBUF)", leafdata->data);
d940 1
a940 1
		//MPRINTF_OLD("malloc(DEVBUF)", p);
d945 1
a945 1
			//MPRINTF_OLD("free(DEVBUF)", com->text);
d954 1
a954 1
				//MPRINTF_OLD("free(DEVBUF)", com->text);
d1000 1
a1000 1
	//MPRINTF_OLD("MALLOC(DEVBUF)", text);
d1012 1
a1012 1
	//MPRINTF_OLD("malloc(DEVBUF)", text->text);
d1015 1
a1015 1
	//MPRINTF_OLD("malloc(DEVBUF)", text->text);
d1080 1
a1080 1
					//MPRINTF_OLD("malloc(DEVBUF)", p);
d1085 1
a1085 1
						//MPRINTF_OLD("free(DEVBUF)", retkeys);
d1113 1
a1113 1
					//MPRINTF_OLD("malloc(DEVBUF)", p);
d1118 1
a1118 1
						//MPRINTF_OLD("free(DEVBUF)", retkeys);
d1340 1
a1340 1
					//MPRINTF_OLD("free(DEVBUF)", data->leafdata->data);
d1344 1
a1344 1
				//MPRINTF_OLD("FREE(DEVBUF)", data->leafdata);
d1351 1
a1351 1
					//MPRINTF_OLD("free(DEVBUF)", data->com.text[i]->text);
d1354 1
a1354 1
					//MPRINTF_OLD("FREE(DEVBUF)", data->com.text[i]);
d1358 1
a1358 1
				//MPRINTF_OLD("free(DEVBUF)", data->com.text);
d1362 1
a1362 1
			//MPRINTF_OLD("FREE(DEVBUF)", data);
d1373 1
a1373 1
				//MPRINTF_OLD("FREE(DEVBUF)", sdir->com.text[i]);
d1377 1
a1377 1
			//MPRINTF_OLD("free(DEVBUF)", sdir->com.text);
d1381 1
a1381 1
		//MPRINTF_OLD("FREE(DEVBUF)", sdir);
d1386 1
a1386 1
		//MPRINTF_OLD("free(DEVBUF)", rom->data);
d1390 1
a1390 1
	//MPRINTF_OLD("FREE(DEVBUF)", rom);
d1466 1
a1466 1
	//MPRINTF_OLD("malloc(DEVBUF)", devret);
d1485 1
a1485 1
				//MPRINTF_OLD("malloc(DEVBUF)", p);
d1489 1
a1489 1
				//MPRINTF_OLD("free(DEVBUF)", devret);
d1501 1
a1501 1
		//MPRINTF_OLD("free(DEVBUF)", udirs);
d1506 1
a1506 1
		//MPRINTF_OLD("free(DEVBUF)", devret);
@


1.2
log
@pointer safeguards + some KNF
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee1212.c,v 1.1 2002/06/25 17:11:49 itojun Exp $	*/
d48 2
d51 2
a52 2
static const char * const p1212_keytype_strings[] = P1212_KEYTYPE_STRINGS ;
static const char * const p1212_keyvalue_strings[] = P1212_KEYVALUE_STRINGS ;   
d65 21
a85 8
#ifdef P1212_DEBUG
#define DPRINTF(x)      if (p1212debug) printf x
#define DPRINTFN(n,x)   if (p1212debug>(n)) printf x
int     p1212debug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif
d107 1
a107 1
	u_int16_t infolen, crclen, len;	
d110 1
a110 1
#ifdef __OpenBSD__
d112 1
a112 1
#endif
d133 1
a133 1
	
d138 1
a138 1
	
d148 1
a148 1
	
d160 1
a160 1
	
d162 1
a162 1
		
d173 1
a173 1
		
d197 1
a197 1
				
d204 1
a204 1
				
d210 1
a210 1
				
d220 1
a220 1
				infolen = 
d228 1
a228 1
				
d230 1
a230 1
				
d232 1
a232 1
				
d238 1
a238 1
				
d240 2
a241 2
				 * Can't just walk the ROM looking at type 
				 * codes since these are only valid on 
d244 1
a244 1
				 * while loop will pop the last one off and 
d247 1
a247 1
                
d253 1
a253 1
#else
d256 1
d260 2
d264 1
a264 1
#endif
d273 1
a273 1
		
d276 1
a276 1
			if (dirs) 
d278 3
d289 1
a289 1
#else
d292 1
d295 1
d297 1
a297 1
#endif
d300 1
d306 1
a306 1
	
d310 1
a310 1
		
d317 1
a317 1
	u_int16_t crc, romcrc, crc1;
d321 1
a321 1
	
d334 1
a334 1
	
d336 2
a337 2
	
	crc = p1212_calc_crc(0, &t[1], P1212_ROMFMT_GET_CRCLEN((ntohl(t[0]))), 
d339 1
a339 1
	
d344 3
a346 1
		if (crc1 != romcrc) {
d348 1
a348 1
			    "CRC: 0x%04hx, CRC1: 0x%04hx\n",
d350 1
a350 1
			    (unsigned short)crc1));
d354 2
d358 1
a358 1
	
d360 3
a362 2
	
	rom = malloc(sizeof(struct p1212_rom), M_DEVBUF, M_WAITOK);    
d368 3
a370 1
		free(rom, M_DEVBUF);
d373 1
a373 1
	
d380 1
d389 1
a389 1
	
d394 9
a402 5
	
#ifdef M_ZERO
	rom->root = malloc(sizeof(*rom->root), M_DEVBUF, M_WAITOK|M_ZERO);
#else
	rom->root = malloc(sizeof(*rom->root), M_DEVBUF, M_WAITOK);
d404 1
a404 1
#endif
d411 1
a411 1
	
d427 1
a427 1
	u_int16_t crclen, crc, crc1, romcrc;
d434 1
d437 2
a438 2
#endif
	
d449 1
d451 1
a451 1
	while (dir) {	    
d455 1
a455 1
		
d459 2
a460 1
			if (crc1 != romcrc) {
d463 2
a464 1
					    "0x%04hx, CRC1: 0x%04hx\n",
d467 2
a468 1
					    (unsigned short)crc1));
d472 5
d481 1
a481 1
		
d492 1
a492 1
			
d500 1
a500 1
			 * XXX: These all really should be broken out into 
d528 1
a528 1
				
d541 2
d545 1
a545 1
				            "an offset type with key %s."
d577 1
a577 1
					
d587 1
a587 1
			
d593 1
a593 1
			
d604 1
a604 1
				            " version along with a node "
d608 1
a608 1
				if (unitdir_cnt) {
d620 1
a620 1
				            "version along with a module "
d624 1
a624 1
				if (unitdir_cnt) {
d632 1
a632 1
			
d634 2
a635 1
				if (module_sw_flag || node_sw_flag) {
d643 1
a643 1
			
d651 2
a652 2
			 * account for either. Finally if they're in a 
			 * directory those can be the only types in a 
d658 1
a658 1
				size = sizeof(struct p1212_textdata *);
d681 1
a681 1
#else
d684 1
d689 2
d693 1
a693 1
#endif
d702 2
d708 1
a708 1
					i = p1212_parse_textdir(com, 
d719 2
a720 2
#ifdef M_ZERO
				data = malloc(sizeof(struct p1212_data),
d722 3
a724 2
#else
				data = malloc(sizeof(struct p1212_data),
d726 1
d728 1
a728 1
#endif
d737 1
a737 1
				/* 
d745 1
a745 1
				    (type == P1212_KEYTYPE_Offset)) 
d747 1
a747 1
				
d750 1
a750 1
				
d760 1
a760 1
			} 
d762 3
a764 3
			
#ifdef M_ZERO
				sdir = malloc(sizeof(struct p1212_dir), 
d766 3
a768 2
#else
				sdir = malloc(sizeof(struct p1212_dir), 
d770 1
d772 1
a772 1
#endif
d796 1
d802 1
d843 1
a843 1
	u_int16_t crclen, crc, crc1, romcrc;
d851 2
a852 1
	if ((crc != romcrc) && (crc1 != romcrc)) {
d854 3
a856 2
		    "0x%04hx, CRC1: 0x%04hx\n", (unsigned short)romcrc,
		    (unsigned short)crc, (unsigned short)crc1));
d859 2
d862 1
a862 1
	
d868 3
a870 1
	leafdata = malloc(sizeof(struct p1212_leafdata), M_DEVBUF, M_WAITOK);
d873 1
d884 1
a884 1
	u_int16_t crclen, crc, crc1, romcrc;
d886 1
a886 1
#ifdef __OpenBSD__
d888 1
a888 1
#endif
d896 1
a896 1
	
d898 2
a899 2
	size = sizeof(struct p1212_text *);
	
d904 2
a905 1
	if ((crc != romcrc) && (crc1 != romcrc)) {
d907 3
a909 2
			    "0x%04hx, CRC1: 0x%04hx\n", (unsigned short)romcrc,
			    (unsigned short)crc, (unsigned short)crc1));
d912 2
d917 1
a917 1
		
d931 1
a931 1
#ifdef __NetBSD__
d934 1
a934 1
#else
d936 1
d941 2
d945 1
a945 1
#endif
d948 1
a948 1
			if (com->textcnt == 0)
d950 3
d964 1
a964 1
	u_int16_t crclen, crc, crc1, romcrc;
d967 1
a967 1
	
d969 1
a969 1
	
d972 1
a972 1
		
d981 2
a982 1
		if (crc1 != romcrc) {
d984 3
a986 2
		            "0x%04hx, CRC1: 0x%04hx\n", (unsigned short)romcrc,
			    (unsigned short)crc, (unsigned short)crc1));
d990 2
d994 3
a996 1
	text = malloc(sizeof(struct p1212_textdata), M_DEVBUF, M_WAITOK);
d1006 1
a1006 1
#ifdef M_ZERO
d1008 2
a1009 1
#else
d1011 1
d1013 1
a1013 1
#endif
d1015 1
a1015 1
	memcpy(text->text, &t[0], size);
d1027 1
a1027 1
#ifdef __OpenBSD__
d1029 1
a1029 1
#endif
d1033 1
a1033 1
	
d1036 1
a1036 3
#ifdef DIAGNOSTIC
		printf("p1212_find: invalid type - %d\n", type);
#endif
d1042 1
a1042 3
#ifdef DIAGNOSTIC
		printf("p1212_find: invalid value - %d\n", value);
#endif
d1045 1
a1045 1
	
d1047 1
a1047 3
#ifdef DIAGNOSTIC
		printf("p1212_find: invalid flags - %d\n", flags);
#endif
d1056 1
a1056 1
	
d1073 1
a1073 1
#else
d1076 1
d1081 2
d1085 1
a1085 1
#endif
d1106 1
a1106 1
#else
d1109 1
d1114 2
d1118 1
a1118 1
#endif
d1144 1
a1144 1
void 
d1155 1
a1155 3
#ifdef DIAGNOSTIC
		printf("p1212_walk: Passed in NULL function\n");
#endif
d1159 1
a1159 3
#ifdef DIAGNOSTIC
		printf("p1212_walk: Called with NULL root\n");
#endif
d1162 1
a1162 1
	
d1166 1
a1166 1
	
d1179 1
a1179 1
		TAILQ_FOREACH(data, &dir->data_root, data) 
d1192 1
a1192 1
	} 
d1201 1
a1201 1
	
d1203 1
a1203 1
	
d1207 1
a1207 1
	
d1211 1
a1211 1
	
d1242 1
a1242 1
	
d1249 1
a1249 1
			    (sizeof(p1212_keyvalue_strings) / sizeof(char *))) 
d1270 1
a1270 1
			    (sizeof(p1212_keyvalue_strings) / sizeof(char *))) 
d1278 1
a1278 1
#ifdef DIAGNOSTIC
d1280 1
a1280 1
			    (data->leafdata == NULL)) 
d1282 2
a1283 2
#endif
				
d1292 1
a1292 1
			if (data->com.textcnt) 
d1299 1
a1299 1
			
d1313 1
a1313 1
	
d1331 1
a1331 1
		
d1334 1
a1334 1
				if (data->leafdata->data)
d1336 6
a1341 1
				free(data->leafdata, M_DEVBUF);
d1345 8
a1352 2
				for (i = 0; i < data->com.textcnt; i++)
					free(data->com.text[i], M_DEVBUF);
d1354 2
d1357 3
a1359 1
			free(data, M_DEVBUF);
d1362 1
a1362 1
		if (dir->parent) 
d1367 5
a1371 2
			for (i = 0; i < sdir->com.textcnt; i++)
				free(sdir->com.text[i], M_DEVBUF);
d1373 2
d1376 3
a1378 1
		free(sdir, M_DEVBUF);
d1380 1
a1380 1
	if (rom->len)
d1382 6
a1387 1
	free(rom, M_DEVBUF);
d1405 1
a1405 1
	
d1408 6
a1413 2
			sum = ((crc >> 12) ^ (ntohl(data[i]) >> shift)) &
			    0x0000000f;
d1416 2
a1417 2
		
		
d1419 2
a1420 1
		if (!broke) {
d1423 7
d1432 5
a1436 1
	return (u_int16_t)crc;
d1450 2
a1451 2
	int numdev;
#ifdef __OpenBSD__
d1453 2
a1454 2
#endif
	
d1456 1
a1456 1
	 * Setup typical return val. Always allocate one extra pointer for a
d1462 1
d1466 1
a1466 1
	    P1212_KEYVALUE_Unit_Directory, 
d1468 1
a1468 1
	
d1470 1
d1472 1
a1472 1
			dev = config_found_sm(sc, udirs, print, NULL);
d1478 1
a1478 1
#else
d1481 1
d1485 1
d1487 1
a1487 1
#endif
d1494 5
a1498 2
			udirs++;
		} while (*udirs);
d1502 2
d1509 1
a1509 1
/* 
d1516 2
a1517 2
 * firewire/1394 will define a dependent info type as an offset value.  
 * Allow the upper level code to flag this and pass it down during 
d1524 8
a1531 8
        if ((val == P1212_KEYVALUE_Node_Units_Extent) ||
            (val == P1212_KEYVALUE_Node_Memory_Extent) ||
            ((mask & P1212_ALLOW_DEPENDENT_INFO_OFFSET_TYPE) &&
             ((val == P1212_KEYVALUE_Unit_Dependent_Info) || 
              (val == P1212_KEYVALUE_Node_Dependent_Info) || 
              (val == P1212_KEYVALUE_Module_Dependent_Info))))
                return 0;
        return 1;
d1534 1
a1534 1
int      
@


1.2.4.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a47 2
#include <dev/std/sbp2reg.h>
#include <dev/std/sbp2var.h>
d49 2
a50 2
static const char * const p1212_keytype_strings[] = P1212_KEYTYPE_STRINGS;
static const char * const p1212_keyvalue_strings[] = P1212_KEYVALUE_STRINGS;
d52 1
a52 1
u_int16_t p1212_calc_crc(u_int16_t, u_int32_t *, int, int);
d63 8
a70 25
#ifdef	P1212_DEBUG
#include <sys/syslog.h>
extern int log_open;
int p1212_oldlog;
#define	DPRINTF(x)	if (p1212debug) do {				\
	p1212_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = p1212_oldlog;				\
} while (0)
#define	DPRINTFN(n,x)	if (p1212debug>(n)) do {			\
	p1212_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = p1212_oldlog;				\
} while (0)
#ifdef	FW_MALLOC_DEBUG
#define	MPRINTF(x,y)	DPRINTF(("%s[%d]: %s 0x%08x\n",			\
			    __func__, __LINE__, (x), (u_int32_t)(y)))
#else	/* !FW_MALLOC_DEBUG */
#define	MPRINTF(x,y)
#endif	/* FW_MALLOC_DEBUG */

int	p1212debug = 0;
#else	/* P1212_DEBUG */
#define	DPRINTF(x)
#define	DPRINTFN(n,x)
#define	MPRINTF(x,y)
#endif	/* ! P1212_DEBUG */
d92 1
a92 1
	u_int16_t infolen, crclen, len;
d95 1
a95 1
#ifdef	__OpenBSD__
d97 1
a97 1
#endif	/* __OpenBSD__ */
d118 1
a118 1

d123 2
a124 2

	offset = infolen + 1;
d133 1
a133 1

d145 1
a145 1

d147 1
a147 1

d158 1
a158 1

d182 1
a182 1

d189 1
a189 1

d195 1
a195 1

d205 1
a205 1
				infolen =
d213 1
a213 1

d215 1
a215 1

d217 1
a217 1

d223 1
a223 1

d225 2
a226 2
				 * Can't just walk the ROM looking at type
				 * codes since these are only valid on
d229 1
a229 1
				 * while loop will pop the last one off and
d232 1
a232 1

d238 1
a238 1
#else	/* __NetBSD__ */
a240 1
				MPRINTF("malloc(DEVBUF)", p);
a243 2
					MPRINTF("free(DEVBUF)", dirs);
					dirs = NULL;	/* XXX */
d246 1
a246 1
#endif	/* ! __NetBSD__ */
d255 1
a255 1

d258 1
a258 1
			if (dirs) {
a259 3
				MPRINTF("free(DEVBUF)", dirs);
				dirs = NULL;	/* XXX */
			}
d268 1
a268 1
#else	/* __NetBSD__ */
a270 1
				MPRINTF("malloc(DEVBUF)", p);
a272 1
				MPRINTF("free(DEVBUF)", dirs);
d274 1
a274 1
#endif	/* ! __NetBSD__ */
a276 1
				MPRINTF("free(DEVBUF)", dirs);
d282 1
a282 1

d286 1
a286 1

d293 1
a293 1
	u_int16_t crc, romcrc, crc1, crc2;
d296 2
a297 2
	int i, crclen;

d310 1
a310 1

d312 4
a315 2

	crclen = P1212_ROMFMT_GET_CRCLEN((ntohl(t[0])));
a316 3

	crc = p1212_calc_crc(0, &t[1], crclen, 0);

d318 3
a320 3
		crc1 = p1212_calc_crc(0, &t[1], crclen, 1);
		crc2 = p1212_calc_crc(0, &t[1], crclen, 2);
		if ((crc1 != romcrc) && (crc2 != romcrc)) {
d322 1
a322 1
			    "CRC: 0x%04hx, CRC1: 0x%04hx, CRC2: 0x%04hx\n",
d324 1
a324 2
			    (unsigned short)crc1, (unsigned short)crc2));
#if 0	/* Continue anyway. We'll choke later if any entry is invalid. */
a325 1
#endif
a327 2
	if (romcrc == crc2)
		DPRINTF(("%s: warning byte-swapping rom problems\n", __func__));
d330 1
a330 1

d332 2
a333 3

	MALLOC(rom, struct p1212_rom *, sizeof(*rom), M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", rom);
d339 1
a339 3
		FREE(rom, M_DEVBUF);
		MPRINTF("FREE(DEVBUF)", rom);
		rom = NULL;	/* XXX */
d342 1
a342 1

a348 1
		MPRINTF("malloc(DEVBUF)", rom->data);
d357 1
a357 1

d362 5
a366 9

#ifdef	M_ZERO
	MALLOC(rom->root, struct p1212_dir *, sizeof(*rom->root),
	    M_DEVBUF, M_WAITOK|M_ZERO);
	MPRINTF("MALLOC(DEVBUF)", rom->root);
#else	/* M_ZERO */
	MALLOC(rom->root, struct p1212_dir *, sizeof(*rom->root),
	    M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", rom->root);
d368 1
a368 1
#endif	/* ! M_ZERO */
d375 1
a375 1

d391 1
a391 1
	u_int16_t crclen, crc, crc1, crc2, romcrc;
a397 1
	int draft;
d400 2
a401 2
#endif	/* __OpenBSD__ */

a411 1
	draft = 0;
d413 1
a413 1
	while (dir) {
d417 1
a417 1

d421 1
a421 2
			crc2 = p1212_calc_crc(0, &t[offset + 1], crclen, 2);
			if ((crc1 != romcrc) && (crc2 != romcrc)) {
d424 1
a424 2
					    "0x%04hx, CRC1: 0x%04hx",
					    ", CRC2: 0x%04hx\n",
d427 1
a427 2
					    (unsigned short)crc1,
					    (unsigned short)crc2));
a430 5
		if (romcrc == crc2) {
			draft = 1;
			DPRINTF(("%s: warning byte-swapping rom problems"
			    " (off: 0x%04hx)\n", __func__, (u_int16_t)offset));
		}
d435 1
a435 1

d446 1
a446 1

d454 1
a454 1
			 * XXX: These all really should be broken out into
d482 1
a482 1

a494 2
				if (draft && val == 0)
					break;
d497 1
a497 1
					    "an offset type with key %s."
d529 1
a529 1

d539 1
a539 1

d545 1
a545 1

d556 1
a556 1
					    " version along with a node "
d560 1
a560 1
				if (!draft && unitdir_cnt) {
d572 1
a572 1
					    "version along with a module "
d576 1
a576 1
				if (!draft && unitdir_cnt) {
d584 1
a584 1

d586 1
a586 2
				if (!draft &&
				    (module_sw_flag || node_sw_flag)) {
d594 1
a594 1

d602 2
a603 2
			 * account for either. Finally if they're in a
			 * directory those can be the only types in a
d609 1
a609 1
				size = sizeof(*p);
d632 1
a632 1
#else	/* __NetBSD__ */
a634 1
					MPRINTF("malloc(DEVBUF)", p);
a638 2
						MPRINTF("free(DEVBUF)", com->text);
						com->text = NULL;	/* XXX */
d641 1
a641 1
#endif	/* ! __NetBSD__ */
a649 2
						MPRINTF("free(DEVBUF)", com->text);
						com->text = NULL;	/* XXX */
d654 1
a654 1
					i = p1212_parse_textdir(com,
d665 2
a666 2
#ifdef	M_ZERO
				MALLOC(data, struct p1212_data *, sizeof(*data),
d668 2
a669 3
				MPRINTF("MALLOC(DEVBUF)", data);
#else	/* M_ZERO */
				MALLOC(data, struct p1212_data *, sizeof(*data),
a670 1
				MPRINTF("MALLOC(DEVBUF)", data);
d672 1
a672 1
#endif	/* ! M_ZERO */
d681 1
a681 1
				/*
d689 1
a689 1
				    (type == P1212_KEYTYPE_Offset))
d691 1
a691 1

d694 1
a694 1

d704 1
a704 1
			}
d706 3
a708 3

#ifdef	M_ZERO
				MALLOC(sdir, struct p1212_dir *, sizeof(*sdir),
d710 2
a711 3
				MPRINTF("MALLOC(DEVBUF)", sdir);
#else	/* M_ZERO */
				MALLOC(sdir, struct p1212_dir *, sizeof(*sdir),
a712 1
				MPRINTF("MALLOC(DEVBUF)", sdir);
d714 1
a714 1
#endif	/* ! M_ZERO */
a737 1
#if 0			/* XXX : Not Mandatory */
a742 1
#endif
d783 1
a783 1
	u_int16_t crclen, crc, crc1, crc2, romcrc;
d791 1
a791 2
	crc2 = p1212_calc_crc(0,&t[1], crclen, 2);
	if ((crc != romcrc) && (crc1 != romcrc) && (crc2 != romcrc)) {
d793 2
a794 3
		    "0x%04hx, CRC1: 0x%04hx, CRC2: 0x%04hx\n",
		    (unsigned short)romcrc, (unsigned short)crc,
		    (unsigned short)crc1, (unsigned short)crc2));
a796 2
	if (romcrc == crc2)
		DPRINTF(("%s: warning byte-swapping rom problems\n", __func__));
d798 1
a798 1

d804 1
a804 3
	MALLOC(leafdata, struct p1212_leafdata *, sizeof(*leafdata),
	    M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", leafdata);
a806 1
	MPRINTF("malloc(DEVBUF)", leafdata->data);
d817 1
a817 1
	u_int16_t crclen, crc, crc1, crc2, romcrc;
d819 1
a819 1
#ifdef	__OpenBSD__
d821 1
a821 1
#endif	/* __OpenBSD__ */
d829 1
a829 1

d831 2
a832 2
	size = sizeof(*p);

d837 1
a837 2
	crc2 = p1212_calc_crc(0,&t[1], crclen, 2);
	if ((crc != romcrc) && (crc1 != romcrc) && (crc2 != romcrc)) {
d839 2
a840 3
			    "0x%04hx, CRC1: 0x%04hx, CRC2: 0x%04hx\n",
			    (unsigned short)romcrc, (unsigned short)crc,
			    (unsigned short)crc1, (unsigned short)crc2));
a842 2
	if (romcrc == crc2)
		DPRINTF(("%s: warning byte-swapping rom problems\n", __func__));
d846 1
a846 1

d860 1
a860 1
#ifdef	__NetBSD__
d863 1
a863 1
#else	/* __NetBSD__ */
a864 1
		MPRINTF("malloc(DEVBUF)", p);
a868 2
			MPRINTF("free(DEVBUF)", com->text);
			com->text = NULL;	/* XXX */
d871 1
a871 1
#endif	/* ! __NetBSD__ */
d874 1
a874 1
			if (com->textcnt == 0) {
a875 3
				MPRINTF("free(DEVBUF)", com->text);
				com->text = NULL;	/* XXX */
			}
d887 1
a887 1
	u_int16_t crclen, crc, crc1, crc2, romcrc;
d890 1
a890 1

d892 1
a892 1

d895 1
a895 1

d904 1
a904 2
		crc2 = p1212_calc_crc(0, &t[1], crclen, 2);
		if ((crc1 != romcrc) && (crc2 != romcrc)) {
d906 2
a907 3
			    "0x%04hx, CRC1: 0x%04hx, CRC1: 0x%04hx\n",
			    (unsigned short)romcrc, (unsigned short)crc,
			    (unsigned short)crc1, (unsigned short)crc2));
a910 2
	if (romcrc == crc2)
		DPRINTF(("%s: warning byte-swapping rom problems\n", __func__));
d913 1
a913 3
	MALLOC(text, struct p1212_textdata *, sizeof(*text), M_DEVBUF,
	    M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", text);
d923 1
a923 1
#ifdef	M_ZERO
d925 1
a925 2
	MPRINTF("malloc(DEVBUF)", text->text);
#else	/* M_ZERO */
a926 1
	MPRINTF("malloc(DEVBUF)", text->text);
d928 1
a928 1
#endif	/* ! M_ZERO */
d930 1
a930 1
	bcopy(&t[0], text->text, size);
d942 1
a942 1
#ifdef	__OpenBSD__
d944 1
a944 1
#endif	/* __OpenBSD__ */
d948 1
a948 1

d951 3
a953 1
		DPRINTF(("p1212_find: invalid type - %d\n", type));
d959 3
a961 1
		DPRINTF(("p1212_find: invalid value - %d\n", value));
d964 1
a964 1

d966 3
a968 1
		DPRINTF(("p1212_find: invalid flags - %d\n", flags));
d977 1
a977 1

d994 1
a994 1
#else	/* __NetBSD__ */
a996 1
					MPRINTF("malloc(DEVBUF)", p);
a1000 2
						MPRINTF("free(DEVBUF)", retkeys);
						retkeys = NULL;	/* XXX */
d1003 1
a1003 1
#endif	/* ! __NetBSD__ */
d1024 1
a1024 1
#else	/* __NetBSD__ */
a1026 1
					MPRINTF("malloc(DEVBUF)", p);
a1030 2
						MPRINTF("free(DEVBUF)", retkeys);
						retkeys = NULL;	/* XXX */
d1033 1
a1033 1
#endif	/* ! __NetBSD__ */
d1059 1
a1059 1
void
d1070 3
a1072 1
		DPRINTF(("p1212_walk: Passed in NULL function\n"));
d1076 3
a1078 1
		DPRINTF(("p1212_walk: Called with NULL root\n"));
d1081 1
a1081 1

d1085 1
a1085 1

d1098 1
a1098 1
		TAILQ_FOREACH(data, &dir->data_root, data)
d1111 1
a1111 1
	}
d1120 1
a1120 1

d1122 1
a1122 1

d1126 1
a1126 1

d1130 1
a1130 1

d1161 1
a1161 1

d1168 1
a1168 1
			    (sizeof(p1212_keyvalue_strings) / sizeof(char *)))
d1189 1
a1189 1
			    (sizeof(p1212_keyvalue_strings) / sizeof(char *)))
d1197 1
a1197 1
#ifdef	DIAGNOSTIC
d1199 1
a1199 1
			    (data->leafdata == NULL))
d1201 2
a1202 2
#endif	/* DIAGNOSTIC */

d1211 1
a1211 1
			if (data->com.textcnt)
d1218 1
a1218 1

d1232 1
a1232 1

d1250 1
a1250 1

d1253 1
a1253 1
				if (data->leafdata->data) {
d1255 1
a1255 6
					MPRINTF("free(DEVBUF)", data->leafdata->data);
					data->leafdata->data = NULL;	/* XXX */
				}
				FREE(data->leafdata, M_DEVBUF);
				MPRINTF("FREE(DEVBUF)", data->leafdata);
				data->leafdata = NULL;	/* XXX */
d1259 2
a1260 8
				for (i = 0; i < data->com.textcnt; i++) {
					free(data->com.text[i]->text, M_DEVBUF);
					MPRINTF("free(DEVBUF)", data->com.text[i]->text);
					data->com.text[i]->text = NULL;	/* XXX */
					FREE(data->com.text[i], M_DEVBUF);
					MPRINTF("FREE(DEVBUF)", data->com.text[i]);
					data->com.text[i] = NULL;	/* XXX */
				}
a1261 2
				MPRINTF("free(DEVBUF)", data->com.text);
				data->com.text = NULL;	/* XXX */
d1263 1
a1263 3
			FREE(data, M_DEVBUF);
			MPRINTF("FREE(DEVBUF)", data);
			data = NULL;	/* XXX */
d1266 1
a1266 1
		if (dir->parent)
d1271 2
a1272 5
			for (i = 0; i < sdir->com.textcnt; i++) {
				FREE(sdir->com.text[i], M_DEVBUF);
				MPRINTF("FREE(DEVBUF)", sdir->com.text[i]);
				sdir->com.text[i] = NULL;	/* XXX */
			}
a1273 2
			MPRINTF("free(DEVBUF)", sdir->com.text);
			sdir->com.text = NULL;	/* XXX */
d1275 1
a1275 3
		FREE(sdir, M_DEVBUF);
		MPRINTF("FREE(DEVBUF)", sdir);
		sdir = NULL;	/* XXX */
d1277 1
a1277 1
	if (rom->len) {
d1279 1
a1279 6
		MPRINTF("free(DEVBUF)", rom->data);
		rom->data = NULL;	/* XXX */
	}
	FREE(rom, M_DEVBUF);
	MPRINTF("FREE(DEVBUF)", rom);
	rom = NULL;	/* XXX */
d1292 1
a1292 1
p1212_calc_crc(u_int16_t seed, u_int32_t *data, int len, int broke)
d1294 4
a1297 3
	u_int16_t sum, crc = seed;
	int i, shift;

d1299 10
a1308 14
		for (shift = 28; shift >= 0; shift -= 4) {
			/*
			 * The 1st broken implementation doesn't do the
			 * last shift.
			 */
			if (shift == 0 && broke == 1)
				break;

			if (broke == 2)
				sum = ((crc >> 12) ^
				    (letoh32(data[i]) >> shift)) & 0xF;
			else
				sum = ((crc >> 12) ^
				    (ntohl(data[i]) >> shift)) & 0xF;
d1312 1
a1312 5

	if (broke == 2)
		return swap16(crc);
	else
		return (crc);
d1326 2
a1327 2
	int numdev, i;
#ifdef	__OpenBSD__
d1329 2
a1330 2
#endif	/* __OpenBSD__ */

d1332 1
a1332 1
	 * Setup typically return val. Always allocate one extra pointer for a
a1337 1
	MPRINTF("malloc(DEVBUF)", devret);
d1341 1
a1341 1
	    P1212_KEYVALUE_Unit_Directory,
d1343 1
a1343 1

a1344 1
		i = 0;
d1346 1
a1346 1
			dev = config_found_sm(sc, &udirs[i], print, NULL);
d1352 1
a1352 1
#else	/* __NetBSD__ */
a1354 1
				MPRINTF("malloc(DEVBUF)", p);
a1357 1
				MPRINTF("free(DEVBUF)", devret);
d1359 1
a1359 1
#endif	/* ! __NetBSD__ */
d1366 2
a1367 5
		} while (udirs[++i]);

		free(udirs, M_DEVBUF);
		MPRINTF("free(DEVBUF)", udirs);
		udirs = NULL;	/* XXX */
a1370 2
		MPRINTF("free(DEVBUF)", devret);
		devret = NULL;	/* XXX */
d1376 1
a1376 1
/*
d1383 2
a1384 2
 * firewire/1394 will define a dependent info type as an offset value.
 * Allow the upper level code to flag this and pass it down during
d1391 8
a1398 8
	if ((val == P1212_KEYVALUE_Node_Units_Extent) ||
	    (val == P1212_KEYVALUE_Node_Memory_Extent) ||
	    ((mask & P1212_ALLOW_DEPENDENT_INFO_OFFSET_TYPE) &&
	     ((val == P1212_KEYVALUE_Unit_Dependent_Info) ||
	      (val == P1212_KEYVALUE_Node_Dependent_Info) ||
	      (val == P1212_KEYVALUE_Module_Dependent_Info))))
		return 0;
	return 1;
d1401 1
a1401 1
int
@


1.1
log
@IEEE1394 infrastructure part.
IP-over-FW and SCSI over FW are being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 10
a61 10
static u_int16_t p1212_calc_crc(u_int32_t, u_int32_t *, int, int);
static int p1212_parse_directory(struct p1212_dir *, u_int32_t *, u_int32_t);
static struct p1212_leafdata *p1212_parse_leaf(u_int32_t *);
static int p1212_parse_textdir(struct p1212_com *, u_int32_t *);
static struct p1212_textdata *p1212_parse_text_desc(u_int32_t *);
static void p1212_print_node(struct p1212_key *, void *);
static int p1212_validate_offset(u_int16_t, u_int32_t);
static int p1212_validate_immed(u_int16_t, u_int32_t);
static int p1212_validate_leaf(u_int16_t, u_int32_t);
static int p1212_validate_dir(u_int16_t, u_int32_t);
d234 1
a234 1
#ifdef __NetBSD__
d241 4
a244 1
				bcopy(dirs, p, sizeof(int) * numdirs);
d262 1
a262 1
		if (dirs) {
d264 4
a267 3
#ifdef __NetBSD__
			dirs = realloc(dirs, sizeof(int) * numdirs, M_DEVBUF,
			    M_WAITOK);
d269 5
a273 4
			p = malloc(sizeof(int) * numdirs, M_DEVBUF,
			    M_WAITOK);
			bcopy(dirs, p, sizeof(int) * numdirs);
			dirs = p;
d275 4
d384 1
a384 1
static int
d397 4
d411 1
d620 1
a620 1
				if (com->textcnt != 0) {
d628 15
a642 3
					com->text =
					    malloc(size, M_DEVBUF, M_WAITOK);
					com->text[0] =
d644 1
a644 1
					if (com->text[0] == NULL) {
d652 1
a652 1
					com->textcnt = 1;
d658 1
d660 2
a661 1
			}
d780 1
a780 1
static struct p1212_leafdata *
d813 1
a813 1
static int
d858 1
a858 1
		
d865 5
a869 1
		bcopy(com->text, p, sizeof(com->textcnt));
d883 1
a883 1
static struct p1212_textdata *
d990 1
a990 1
#ifdef __NetBSD__
d993 1
a993 1
					    (numkeys + 1), M_WAITOK, M_DEVBUF);
d996 6
a1001 4
					    (numkeys + 1), M_WAITOK, M_DEVBUF);
					bcopy(retkeys, p,
					    sizeof(struct p1212_key *) *
					    numkeys);
d1020 1
a1020 1
#ifdef __NetBSD__
d1023 1
a1023 1
					    (numkeys + 1), M_WAITOK, M_DEVBUF);
d1026 6
a1031 4
					    (numkeys + 1), M_WAITOK, M_DEVBUF);
					bcopy(retkeys, p,
					    sizeof(struct p1212_key *) *
					    numkeys);
d1127 1
a1127 1
static void
d1291 1
a1291 1
static u_int16_t
d1338 1
a1338 1
	devret[1] = NULL;
d1348 1
a1348 1
#ifdef __NetBSD__
d1356 2
a1357 1
				    sizeof(struct device *) * (numdev + 1));
d1388 1
a1388 1
static int
d1401 1
a1401 1
static int      
d1426 1
a1426 1
static int
d1445 1
a1445 1
static int
@

