head	1.40;
access;
symbols
	OPENBSD_6_0:1.40.0.2
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.4
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.28.0.14
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.10
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.8
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20;
locks; strict;
comment	@ * @;


1.40
date	2016.07.03.20.05.44;	author mglocker;	state Exp;
branches;
next	1.39;
commitid	qyd7C1mIQD48GTJ0;

1.39
date	2016.06.01.09.48.20;	author mglocker;	state Exp;
branches;
next	1.38;
commitid	RaPpcmMm3TxnbPGc;

1.38
date	2016.02.08.17.21.10;	author stefan;	state Exp;
branches;
next	1.37;
commitid	InbYJPPqM3oe12YB;

1.37
date	2015.08.29.20.51.46;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	boRODGnkIREslCMf;

1.36
date	2015.07.17.23.29.14;	author jsg;	state Exp;
branches;
next	1.35;
commitid	uCRPPNaXnlKw5NpZ;

1.35
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.34;
commitid	C5iGb36LQxjM60Q3;

1.34
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.33;
commitid	P6Av4XGqOi3rFasL;

1.33
date	2014.10.18.08.01.34;	author armani;	state Exp;
branches;
next	1.32;
commitid	cdW1SBgN6rVYvZes;

1.32
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.31;
commitid	uzzBR7hz9ncd4O6G;

1.31
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.30;
commitid	OBNa5kfxQ2UXoiIw;

1.30
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	EF98ch02VpFassUi;

1.29
date	2014.03.28.17.57.11;	author mpi;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	2011.03.26.08.13.05;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.14.21.24.33;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.11.12.37.07;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2008.08.24.11.05.02;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.13.20.29.34;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.31.15.26.25;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.26.11.42.43;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.23.22.10.21;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.19.06.39.00;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.13.18.04.56;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.13.05.00.32;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.12.22.16.16;	author robert;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.12.21.20.00;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.11.01.27.30;	author robert;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.10.23.39.01;	author robert;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.09.20.51.31;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.09.17.13.35;	author robert;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.09.05.49.10;	author robert;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.07.22.14.57;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.05.20.50.28;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.30.06.37.38;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.26.17.51.18;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.25.07.47.47;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.24.19.37.34;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.09.19.49.55;	author robert;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Move videovar.h in to video.c since it isn't used anywhere else.

Suggested by mpi@@ diff from Patrick Keshishian.

ok mpi
@
text
@/*	$OpenBSD: video.c,v 1.39 2016/06/01 09:48:20 mglocker Exp $	*/

/*
 * Copyright (c) 2008 Robert Nagy <robert@@openbsd.org>
 * Copyright (c) 2008 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/poll.h>
#include <sys/device.h>
#include <sys/vnode.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/conf.h>
#include <sys/videoio.h>

#include <dev/video_if.h>

#include <uvm/uvm_extern.h>

#ifdef VIDEO_DEBUG
#define	DPRINTF(x)	do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

struct video_softc {
	struct device		 dev;
	void			*hw_hdl;	/* hardware driver handle */
	struct device		*sc_dev;	/* hardware device struct */
	struct video_hw_if	*hw_if;		/* hardware interface */
	char			 sc_dying;	/* device detached */
#define VIDEO_OPEN	0x01
	char			 sc_open;

	int			 sc_fsize;
	uint8_t			*sc_fbuffer;
	size_t			 sc_fbufferlen;
	int			 sc_vidmode;	/* access mode */
#define		VIDMODE_NONE	0
#define		VIDMODE_MMAP	1
#define		VIDMODE_READ	2
	int			 sc_frames_ready;

	struct selinfo		 sc_rsel;	/* read selector */
};

int	videoprobe(struct device *, void *, void *);
void	videoattach(struct device *, struct device *, void *);
int	videodetach(struct device *, int);
int	videoactivate(struct device *, int);
int	videoprint(void *, const char *);

void	video_intr(void *);

struct cfattach video_ca = {
	sizeof(struct video_softc), videoprobe, videoattach,
	videodetach, videoactivate
};

struct cfdriver video_cd = {
	NULL, "video", DV_DULL
};

int
videoprobe(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
videoattach(struct device *parent, struct device *self, void *aux)
{
	struct video_softc *sc = (void *)self;
	struct video_attach_args *sa = aux;

	printf("\n");
	sc->hw_if = sa->hwif;
	sc->hw_hdl = sa->hdl;
	sc->sc_dev = parent;
	sc->sc_fbufferlen = 0;

	if (sc->hw_if->get_bufsize)
		sc->sc_fbufferlen = (sc->hw_if->get_bufsize)(sc->hw_hdl);
	if (sc->sc_fbufferlen == 0) {
		printf("video: could not request frame buffer size\n");
		return;
	}

	sc->sc_fbuffer = malloc(sc->sc_fbufferlen, M_DEVBUF, M_NOWAIT);
	if (sc->sc_fbuffer == NULL) {
		printf("video: could not allocate frame buffer\n");
		return;
	}
}

int
videoopen(dev_t dev, int flags, int fmt, struct proc *p)
{
	int	unit;
	struct video_softc *sc;

	unit = VIDEOUNIT(dev);
	if (unit >= video_cd.cd_ndevs ||
	    (sc = video_cd.cd_devs[unit]) == NULL ||
	     sc->hw_if == NULL)
		return (ENXIO);

	if (sc->sc_open & VIDEO_OPEN)
		return (EBUSY);
	sc->sc_open |= VIDEO_OPEN;

	sc->sc_vidmode = VIDMODE_NONE;
	sc->sc_frames_ready = 0;

	if (sc->hw_if->open != NULL)
		return (sc->hw_if->open(sc->hw_hdl, flags, &sc->sc_fsize,
		    sc->sc_fbuffer, video_intr, sc));
	else
		return (0);
}

int
videoclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	struct video_softc *sc;
	int r = 0;

	sc = video_cd.cd_devs[VIDEOUNIT(dev)];

	if (sc->hw_if->close != NULL)
		r = sc->hw_if->close(sc->hw_hdl);

	sc->sc_open &= ~VIDEO_OPEN;

	return (r);
}

int
videoread(dev_t dev, struct uio *uio, int ioflag)
{
	struct video_softc *sc;
	int unit, error;
	size_t size;

	unit = VIDEOUNIT(dev);
	if (unit >= video_cd.cd_ndevs ||
	    (sc = video_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	if (sc->sc_dying)
		return (EIO);

	if (sc->sc_vidmode == VIDMODE_MMAP)
		return (EBUSY);

	/* start the stream if not already started */
	if (sc->sc_vidmode == VIDMODE_NONE && sc->hw_if->start_read) {
 		error = sc->hw_if->start_read(sc->hw_hdl);
 		if (error)
 			return (error);
		sc->sc_vidmode = VIDMODE_READ;
 	}
 
	DPRINTF(("resid=%d\n", uio->uio_resid));

	if (sc->sc_frames_ready < 1) {
		/* block userland read until a frame is ready */
		error = tsleep(sc, PWAIT | PCATCH, "vid_rd", 0);
		if (sc->sc_dying)
			error = EIO;
		if (error)
			return (error);
	}

	/* move no more than 1 frame to userland, as per specification */
	size = ulmin(uio->uio_resid, sc->sc_fsize);
	error = uiomove(sc->sc_fbuffer, size, uio);
	sc->sc_frames_ready--;
	if (error)
		return (error);

	DPRINTF(("uiomove successfully done (%zu bytes)\n", size));

	return (0);
}

int
videoioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct video_softc *sc;
	int unit, error;

	unit = VIDEOUNIT(dev);
	if (unit >= video_cd.cd_ndevs ||
	    (sc = video_cd.cd_devs[unit]) == NULL || sc->hw_if == NULL)
		return (ENXIO);

	DPRINTF(("video_ioctl(%d, '%c', %d)\n",
	    IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd & 0xff));

	error = EOPNOTSUPP;
	switch (cmd) {
	case VIDIOC_QUERYCAP:
		if (sc->hw_if->querycap)
			error = (sc->hw_if->querycap)(sc->hw_hdl,
			    (struct v4l2_capability *)data);
		break;
	case VIDIOC_ENUM_FMT:
		if (sc->hw_if->enum_fmt)
			error = (sc->hw_if->enum_fmt)(sc->hw_hdl,
			    (struct v4l2_fmtdesc *)data);
		break;
	case VIDIOC_ENUM_FRAMESIZES:
		if (sc->hw_if->enum_fsizes)
			error = (sc->hw_if->enum_fsizes)(sc->hw_hdl,
			    (struct v4l2_frmsizeenum *)data);
		break;
	case VIDIOC_ENUM_FRAMEINTERVALS:
		if (sc->hw_if->enum_fivals)
			error = (sc->hw_if->enum_fivals)(sc->hw_hdl,
			    (struct v4l2_frmivalenum *)data);
		break;
	case VIDIOC_S_FMT:
		if (!(flags & FWRITE))
			return (EACCES);
		if (sc->hw_if->s_fmt)
			error = (sc->hw_if->s_fmt)(sc->hw_hdl,
			    (struct v4l2_format *)data);
		break;
	case VIDIOC_G_FMT:
		if (sc->hw_if->g_fmt)
			error = (sc->hw_if->g_fmt)(sc->hw_hdl,
			    (struct v4l2_format *)data);
		break;
	case VIDIOC_S_PARM:
		if (sc->hw_if->s_parm)
			error = (sc->hw_if->s_parm)(sc->hw_hdl,
			    (struct v4l2_streamparm *)data);
		break;
	case VIDIOC_G_PARM:
		if (sc->hw_if->g_parm)
			error = (sc->hw_if->g_parm)(sc->hw_hdl,
			    (struct v4l2_streamparm *)data);
		break;
	case VIDIOC_ENUMINPUT:
		if (sc->hw_if->enum_input)
			error = (sc->hw_if->enum_input)(sc->hw_hdl,
			    (struct v4l2_input *)data);
		break;
	case VIDIOC_S_INPUT:
		if (sc->hw_if->s_input)
			error = (sc->hw_if->s_input)(sc->hw_hdl,
			    (int)*data);
		break;
	case VIDIOC_G_INPUT:
		if (sc->hw_if->g_input)
			error = (sc->hw_if->g_input)(sc->hw_hdl,
			    (int *)data);
		break;
	case VIDIOC_REQBUFS:
		if (sc->hw_if->reqbufs)
			error = (sc->hw_if->reqbufs)(sc->hw_hdl,
			    (struct v4l2_requestbuffers *)data);
		break;
	case VIDIOC_QUERYBUF:
		if (sc->hw_if->querybuf)
			error = (sc->hw_if->querybuf)(sc->hw_hdl,
			    (struct v4l2_buffer *)data);
		break;
	case VIDIOC_QBUF:
		if (sc->hw_if->qbuf)
			error = (sc->hw_if->qbuf)(sc->hw_hdl,
			    (struct v4l2_buffer *)data);
		break;
	case VIDIOC_DQBUF:
		if (!sc->hw_if->dqbuf)
			break;
		/* should have called mmap() before now */
		if (sc->sc_vidmode != VIDMODE_MMAP) {
			error = EINVAL;
			break;
		}
		error = (sc->hw_if->dqbuf)(sc->hw_hdl,
		    (struct v4l2_buffer *)data);
		sc->sc_frames_ready--;
		break;
	case VIDIOC_STREAMON:
		if (sc->hw_if->streamon)
			error = (sc->hw_if->streamon)(sc->hw_hdl,
			    (int)*data);
		break;
	case VIDIOC_STREAMOFF:
		if (sc->hw_if->streamoff)
			error = (sc->hw_if->streamoff)(sc->hw_hdl,
			    (int)*data);
		break;
	case VIDIOC_TRY_FMT:
		if (sc->hw_if->try_fmt)
			error = (sc->hw_if->try_fmt)(sc->hw_hdl,
			    (struct v4l2_format *)data);
		break;
	case VIDIOC_QUERYCTRL:
		if (sc->hw_if->queryctrl)
			error = (sc->hw_if->queryctrl)(sc->hw_hdl,
			    (struct v4l2_queryctrl *)data);
		break;
	case VIDIOC_G_CTRL:
		if (sc->hw_if->g_ctrl)
			error = (sc->hw_if->g_ctrl)(sc->hw_hdl,
			    (struct v4l2_control *)data);
		break;
	case VIDIOC_S_CTRL:
		if (sc->hw_if->s_ctrl)
			error = (sc->hw_if->s_ctrl)(sc->hw_hdl,
			    (struct v4l2_control *)data);
		break;
	default:
		error = (ENOTTY);
	}

	return (error);
}

int
videopoll(dev_t dev, int events, struct proc *p)
{
	int unit = VIDEOUNIT(dev);
	struct video_softc *sc;
	int error, revents = 0;

	if (unit >= video_cd.cd_ndevs ||
	    (sc = video_cd.cd_devs[unit]) == NULL)
		return (POLLERR);

	if (sc->sc_dying)
		return (POLLERR);

	DPRINTF(("%s: events=0x%x\n", __func__, events));

	if (events & (POLLIN | POLLRDNORM)) {
		if (sc->sc_frames_ready > 0)
			revents |= events & (POLLIN | POLLRDNORM);
	}
	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM)) {
			/*
			 * Start the stream in read() mode if not already
			 * started.  If the user wanted mmap() mode,
			 * he should have called mmap() before now.
			 */
			if (sc->sc_vidmode == VIDMODE_NONE &&
			    sc->hw_if->start_read) {
				error = sc->hw_if->start_read(sc->hw_hdl);
				if (error)
					return (POLLERR);
				sc->sc_vidmode = VIDMODE_READ;
			}
			selrecord(p, &sc->sc_rsel);
		}
	}

	DPRINTF(("%s: revents=0x%x\n", __func__, revents));

	return (revents);
}

paddr_t
videommap(dev_t dev, off_t off, int prot)
{
	struct video_softc *sc;
	int unit;
	caddr_t p;
	paddr_t pa;

	DPRINTF(("%s: off=%d, prot=%d\n", __func__, off, prot));

	unit = VIDEOUNIT(dev);
	if (unit >= video_cd.cd_ndevs ||
	    (sc = video_cd.cd_devs[unit]) == NULL)
		return (-1);

	if (sc->sc_dying)
		return (-1);

	if (sc->hw_if->mappage == NULL)
		return (-1);

	p = sc->hw_if->mappage(sc->hw_hdl, off, prot);
	if (p == NULL)
		return (-1);
	if (pmap_extract(pmap_kernel(), (vaddr_t)p, &pa) == FALSE)
		panic("videommap: invalid page");
	sc->sc_vidmode = VIDMODE_MMAP;

	return (pa);
}

int
video_submatch(struct device *parent, void *match, void *aux)
{
        struct cfdata *cf = match;

	return (cf->cf_driver == &video_cd);
}

/*
 * Called from hardware driver. This is where the MI video driver gets
 * probed/attached to the hardware driver
 */
struct device *
video_attach_mi(struct video_hw_if *rhwp, void *hdlp, struct device *dev)
{
	struct video_attach_args arg;

	arg.hwif = rhwp;
	arg.hdl = hdlp;
	return (config_found_sm(dev, &arg, videoprint, video_submatch));
}

void
video_intr(void *addr)
{
	struct video_softc *sc = (struct video_softc *)addr;

	DPRINTF(("video_intr sc=%p\n", sc));
	if (sc->sc_vidmode != VIDMODE_NONE)
		sc->sc_frames_ready++;
	else
		printf("%s: interrupt but no streams!\n", __func__);
	if (sc->sc_vidmode == VIDMODE_READ)
		wakeup(sc);
	selwakeup(&sc->sc_rsel);
}

int
videoprint(void *aux, const char *pnp)
{
	if (pnp != NULL)
		printf("video at %s", pnp);
	return (UNCONF);
}

int
videodetach(struct device *self, int flags)
{
	struct video_softc *sc = (struct video_softc *)self;
	int maj, mn;

	if (sc->sc_fbuffer != NULL)
		free(sc->sc_fbuffer, M_DEVBUF, sc->sc_fbufferlen);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == videoopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	return (0);
}

int
videoactivate(struct device *self, int act)
{
	struct video_softc *sc = (struct video_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
}
@


1.39
log
@New USB device driver for Audio/Video capture devices based on the
Fushicai USBTV007 chip.

The chip specific code has been written by Lubomir Rintel and Federico
Simoncelli.  Patrick Keshishian has ported it to OpenBSD and wrote the
remaining code based on uvideo(4).

Input and help also from mpi@@ and ratchov@@.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.38 2016/02/08 17:21:10 stefan Exp $	*/
a33 1
#include <dev/videovar.h>
d42 21
@


1.38
log
@Convert to uiomove. From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.37 2015/08/29 20:51:46 deraadt Exp $	*/
d395 8
d414 1
a414 1
	return (config_found(dev, &arg, videoprint));
@


1.37
log
@video sub-drivers will not return EINVAL in size variable.  (Well,
a broken USB driver could, then what happens?)  0 is the right error.
Also, keep track the size for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.36 2015/07/17 23:29:14 jsg Exp $	*/
d139 2
a140 1
	int unit, error, size;
d173 2
a174 5
	if (sc->sc_fsize < uio->uio_resid)
		size = sc->sc_fsize;
	else
		size = uio->uio_resid;
	error = uiomovei(sc->sc_fbuffer, size, uio);
d179 1
a179 1
	DPRINTF(("uiomove successfully done (%d bytes)\n", size));
@


1.36
log
@add missing braces to only call selrecord when intended to
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.35 2015/02/10 21:56:09 miod Exp $	*/
a71 1
	int video_buf_size = 0;
d77 1
d80 2
a81 2
		video_buf_size = (sc->hw_if->get_bufsize)(sc->hw_hdl);
	if (video_buf_size == EINVAL) {
d86 1
a86 1
	sc->sc_fbuffer = malloc(video_buf_size, M_DEVBUF, M_NOWAIT);
d441 1
a441 1
		free(sc->sc_fbuffer, M_DEVBUF, 0);
@


1.35
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.34 2014/12/16 18:30:03 tedu Exp $	*/
d344 1
a344 1
		if (events & (POLLIN | POLLRDNORM))
d358 1
@


1.34
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.33 2014/10/18 08:01:34 armani Exp $	*/
d176 1
a176 1
	error = uiomove(sc->sc_fbuffer, size, uio);
@


1.33
log
@Add VIDIOC_G_INPUT ioctl, some ports need it (at least ffmpeg)

ok ratchov@@, sthen@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.32 2014/09/14 14:17:24 jsg Exp $	*/
d35 2
@


1.32
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.31 2014/07/12 18:48:51 tedu Exp $	*/
d251 5
@


1.31
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.30 2014/07/08 17:19:25 deraadt Exp $	*/
a21 1
#include <sys/proc.h>
@


1.30
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.29 2014/03/28 17:57:11 mpi Exp $	*/
d434 1
a434 1
		free(sc->sc_fbuffer, M_DEVBUF);
@


1.29
log
@Reduce uvm include madness.  Use <uvm/uvm_extern.h> instead of
<uvm/uvm.h> if possible and remove double inclusions.

ok beck@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.28 2011/07/03 15:47:16 matthew Exp $	*/
a32 3

#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>
@


1.28
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 2
a2 1
/*	$OpenBSD: video.c,v 1.27 2011/03/26 08:13:05 jakemsr Exp $	*/
d33 2
a34 1
#include <uvm/uvm.h>
@


1.27
log
@support VIDIOC_S_PARM and VIDIOC_G_PARM.  these ioctls are used for
setting and and getting the frame interval.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.26 2010/12/26 15:41:00 miod Exp $	*/
a454 3
	case DVACT_ACTIVATE:
		break;

@


1.26
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.25 2010/07/14 21:24:33 jakemsr Exp $	*/
d233 10
@


1.25
log
@implement poll() for video(4)
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.24 2009/10/13 19:33:16 pirofti Exp $	*/
a377 1
#if defined(__powerpc__) || defined(__sparc64__)
a378 3
#else
	return (atop(pa));
#endif
@


1.24
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.23 2008/11/11 12:37:07 mglocker Exp $	*/
d25 1
d109 2
a110 1
	sc->sc_start_read = 0;
d149 18
a166 3
	/* start the stream */
	if (sc->hw_if->start_read && !sc->sc_start_read) {
		error = sc->hw_if->start_read(sc->hw_hdl);
a168 1
		sc->sc_start_read = 1;
d171 1
a171 8
	DPRINTF(("resid=%d\n", uio->uio_resid));

	/* block userland read until a frame is ready */
	error = tsleep(sc, PWAIT | PCATCH, "vid_rd", 0);
	if (error)
		return (error);

	/* move the frame to userland */
d177 1
d260 10
a269 3
		if (sc->hw_if->dqbuf)
			error = (sc->hw_if->dqbuf)(sc->hw_hdl,
			    (struct v4l2_buffer *)data);
d308 42
d376 1
d405 7
a411 1
	wakeup(sc);
@


1.23
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.22 2008/08/24 11:05:02 mglocker Exp $	*/
d46 1
a46 1
int	videoactivate(struct device *, enum devact);
d378 1
a378 1
videoactivate(struct device *self, enum devact act)
@


1.22
log
@Add support for processing unit (e.g. brightness) controls.  New V4L2
ioctls therefore are VIDIOC_QUERYCTRL, VIDIOC_G_CTRL, and VIDIOC_S_CTRL.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.21 2008/08/13 20:29:34 mglocker Exp $	*/
d69 1
a69 1
	struct video_softc *sc = (void *) self;
@


1.21
log
@Add VIDIOC_ENUM_FRAMESIZES ioctl.  This permits applications to query the
available formats and resolutions of a device (e.g. "luvcview -L").
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.20 2008/07/31 15:26:25 mglocker Exp $	*/
d273 10
@


1.20
log
@- Don't relay on bFormatIndex as an internal array index, since this
field is unreliable and can start with any number.  Use an own internal
array index instead.

- If the read buffer is too small, return a propper error to the calling
functions.  Just check the buffer size if we use the read(2) method since
it doesn't affect mmap(2).

Fixes kernel crashes seen with the M$ LifeCam NX-6000 and internal
(laptop) Sonix chipsets.

Tested by jcs@@ (Sonix) and myself (NX-6000).

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.19 2008/07/26 11:42:43 mglocker Exp $	*/
d201 10
@


1.19
log
@Since we are able to change the device image resolution on the fly in the
meantime, the memory allocation for the read(2) method for video(4)
is not right anymore, and can cause a buffer overflow.

We fix this by queuering the maximum available image size for a device at
attach time.  If the image size should exceed our video(4) buffer after a
video format change (which shouldn't happen), uvideo(4) will gracefully
fail.

Also tested by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.18 2008/07/23 22:10:21 mglocker Exp $	*/
d149 3
a152 1
		sc->hw_if->start_read(sc->hw_hdl);
@


1.18
log
@If /dev/video* is already used by an application, return EBUSY to other
applications.  Fixes a kernel panic.

Reported by ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.17 2008/07/19 06:39:00 mglocker Exp $	*/
d80 4
@


1.17
log
@In interrupt handler change printf -> DRPINTF.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.16 2008/06/13 18:04:56 mglocker Exp $	*/
d100 4
d117 1
d122 5
a126 3
		return (sc->hw_if->close(sc->hw_hdl));
	else
		return (0);
@


1.16
log
@Remove DEBUG #undef's we can turn it on/off in GENERIC like for all
other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.15 2008/06/13 05:00:32 mglocker Exp $	*/
d311 1
a311 1
	printf("video_intr sc=%p\n", sc);
@


1.15
log
@Add myself to the copyright since i fumbled around in those files, too.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.14 2008/06/12 22:16:16 robert Exp $	*/
a35 2

#undef VIDEO_DEBUG	/* XXX remove from here somewhen */
@


1.14
log
@disable debug printfs and descriptor dumps
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.13 2008/06/12 21:20:00 mglocker Exp $	*/
d4 1
@


1.13
log
@Wrap DPRINTF around #ifdef VIDEO_DEBUG, but leave debugging on by
default for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.12 2008/06/11 01:27:30 robert Exp $	*/
d36 1
a36 1
#define VIDEO_DEBUG	/* XXX remove from here somewhen */
@


1.12
log
@implement the VIDIOC_STREAMOFF ioctl and remove some unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.11 2008/06/10 23:39:01 robert Exp $	*/
d36 3
d40 3
@


1.11
log
@add VIDIOC_QUERYCTRL to the supported ioctls
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.10 2008/06/09 20:51:31 mglocker Exp $	*/
d229 5
@


1.10
log
@Let the driver switch between read() and mmap() depending on what
the userland application wants.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.9 2008/06/09 17:13:35 robert Exp $	*/
d235 5
@


1.9
log
@according to miod pmap_update() is not need after pmap_extract() at all,
so remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.8 2008/06/09 05:49:10 robert Exp $	*/
d95 2
d130 6
@


1.8
log
@Allocate the video buffer based on the maximum frame size that's reported
by the device instead of using the statically set VIDEO_BUF_SIZE.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.7 2008/06/07 22:14:57 mglocker Exp $	*/
a260 1
	pmap_update(pmap_kernel());
@


1.7
log
@Start to queue mmap frames.  Add VIDIOC_QBUF, VIDIOC_DQBUF,
VIDIOC_STREAMON for that purpose, too.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.6 2008/06/05 20:50:28 mglocker Exp $	*/
d66 1
d73 4
a76 1
	sc->sc_fbuffer = malloc(VIDEO_BUF_SIZE, M_DEVBUF, M_NOWAIT);
@


1.6
log
@Add some first mmap bits.

Help by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.5 2008/05/30 06:37:38 mglocker Exp $	*/
d204 5
d210 8
@


1.5
log
@Allocate static buffer for software frame buffer and make sure to not
overflow it.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.4 2008/05/26 17:51:18 mglocker Exp $	*/
d30 2
a183 5
	case VIDIOC_REQBUFS:
		if (sc->hw_if->reqbufs)
			error = (sc->hw_if->reqbufs)(sc->hw_hdl,
			    (struct v4l2_requestbuffers *)data);
		break;
d194 5
d200 3
d204 1
a204 1
	case VIDIOC_QBUF:
d223 4
d231 1
a231 1
		return (ENXIO);
d234 1
a234 1
		return (EIO);
d236 2
a237 1
	/* TODO */
d239 12
a250 1
	return (0);
@


1.4
log
@Add more ioctl's (still unfinished);  VIDIOC_ENUM_FMT, VIDIOC_ENUMINPUT,
VIDIOC_S_INPUT, VIDIOC_TRY_FMT.  Allows me at least to use a small V4L2
compatible webcam application to capture some images.
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.3 2008/05/25 07:47:47 mglocker Exp $	*/
d69 6
a88 6
	sc->sc_fsize = 0;
	/* XXX find proper size */
	sc->sc_fbuffer = malloc(32000, M_DEVBUF, M_NOWAIT);
	if (sc->sc_fbuffer == NULL)
		return (ENOMEM);

a102 3
	if (sc->sc_fbuffer != NULL)
		free(sc->sc_fbuffer, M_DEVBUF);

d266 1
a266 1
	/*struct video_softc *sc = (struct video_softc *)self;*/
d268 3
@


1.3
log
@Spacing.  Comments.  strncpy() -> strlcpy().
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.2 2008/05/24 19:37:34 mglocker Exp $	*/
d168 5
d190 10
d201 1
d203 6
@


1.2
log
@- Enable userland to read(2) video stream from /dev/video.
- Prepare for mmap(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: video.c,v 1.1 2008/04/09 19:49:55 robert Exp $	*/
d166 1
a166 1
				(struct v4l2_capability *)data);
d173 1
a173 1
				(struct v4l2_format *)data);
d178 1
a178 1
				(struct v4l2_format *)data);
d183 1
a183 1
				(struct v4l2_requestbuffers *)data);
@


1.1
log
@Initial import for uvideo(4) and video(4):

uvideo(4) is a driver for USB video device class devices including webcams,
camcorders and other cameras.

video(4) is a device-independent layer that implements the V4L2 (Video for Linux Two)
API.

These drivers are *really* work in progress so don't even try to use them just yet,
because the driver still has some issues, even if it can be used to capture simple
MJPEG videos.

ok mglocker@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 2
d42 2
d83 6
d90 2
a91 1
		return (sc->hw_if->open(sc->hw_hdl, flags));
d103 3
d113 35
d194 19
d225 9
@

