head	1.193;
access;
symbols
	OPENBSD_6_2_BASE:1.193
	OPENBSD_6_1:1.192.0.4
	OPENBSD_6_1_BASE:1.192
	OPENBSD_6_0:1.182.0.2
	OPENBSD_6_0_BASE:1.182
	OPENBSD_5_9:1.179.0.2
	OPENBSD_5_9_BASE:1.179
	OPENBSD_5_8:1.175.0.4
	OPENBSD_5_8_BASE:1.175
	OPENBSD_5_7:1.172.0.4
	OPENBSD_5_7_BASE:1.172
	OPENBSD_5_6:1.159.0.4
	OPENBSD_5_6_BASE:1.159
	OPENBSD_5_5:1.155.0.4
	OPENBSD_5_5_BASE:1.155
	OPENBSD_5_4:1.143.0.2
	OPENBSD_5_4_BASE:1.143
	OPENBSD_5_3:1.141.0.4
	OPENBSD_5_3_BASE:1.141
	OPENBSD_5_2:1.141.0.2
	OPENBSD_5_2_BASE:1.141
	OPENBSD_5_1_BASE:1.140
	OPENBSD_5_1:1.140.0.4
	OPENBSD_5_0:1.140.0.2
	OPENBSD_5_0_BASE:1.140
	OPENBSD_4_9:1.139.0.2
	OPENBSD_4_9_BASE:1.139
	OPENBSD_4_8:1.102.0.2
	OPENBSD_4_8_BASE:1.102
	OPENBSD_4_7:1.101.0.2
	OPENBSD_4_7_BASE:1.101
	OPENBSD_4_6:1.100.0.4
	OPENBSD_4_6_BASE:1.100
	OPENBSD_4_5:1.99.0.2
	OPENBSD_4_5_BASE:1.99
	OPENBSD_4_4:1.92.0.2
	OPENBSD_4_4_BASE:1.92
	OPENBSD_4_3:1.87.0.2
	OPENBSD_4_3_BASE:1.87
	OPENBSD_4_2:1.82.0.2
	OPENBSD_4_2_BASE:1.82
	OPENBSD_4_1:1.80.0.4
	OPENBSD_4_1_BASE:1.80
	OPENBSD_4_0:1.80.0.2
	OPENBSD_4_0_BASE:1.80
	OPENBSD_3_9:1.79.0.4
	OPENBSD_3_9_BASE:1.79
	OPENBSD_3_8:1.79.0.2
	OPENBSD_3_8_BASE:1.79
	OPENBSD_3_7:1.76.0.2
	OPENBSD_3_7_BASE:1.76
	OPENBSD_3_6:1.73.0.2
	OPENBSD_3_6_BASE:1.73
	SMP_SYNC_A:1.70
	SMP_SYNC_B:1.70
	OPENBSD_3_5:1.67.0.2
	OPENBSD_3_5_BASE:1.67
	OPENBSD_3_4:1.63.0.2
	OPENBSD_3_4_BASE:1.63
	UBC_SYNC_A:1.62
	OPENBSD_3_3:1.62.0.2
	OPENBSD_3_3_BASE:1.62
	OPENBSD_3_2:1.60.0.2
	OPENBSD_3_2_BASE:1.60
	OPENBSD_3_1:1.57.0.2
	OPENBSD_3_1_BASE:1.57
	UBC_SYNC_B:1.60
	UBC:1.50.0.4
	UBC_BASE:1.50
	OPENBSD_3_0:1.50.0.2
	OPENBSD_3_0_BASE:1.50
	OPENBSD_2_9_BASE:1.46
	OPENBSD_2_9:1.46.0.2
	OPENBSD_2_8:1.45.0.2
	OPENBSD_2_8_BASE:1.45
	OPENBSD_2_7:1.38.0.2
	OPENBSD_2_7_BASE:1.38
	SMP:1.33.0.4
	SMP_BASE:1.33
	kame_19991208:1.33
	OPENBSD_2_6:1.33.0.2
	OPENBSD_2_6_BASE:1.33
	OPENBSD_2_5:1.32.0.8
	OPENBSD_2_5_BASE:1.32
	OPENBSD_2_4:1.32.0.6
	OPENBSD_2_4_BASE:1.32
	OPENBSD_2_3:1.32.0.4
	OPENBSD_2_3_BASE:1.32
	OPENBSD_2_2:1.32.0.2
	OPENBSD_2_2_BASE:1.32
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9;
locks; strict;
comment	@ * @;


1.193
date	2017.07.30.21.40.14;	author deraadt;	state Exp;
branches;
next	1.192;
commitid	Eo8oZG13H2yjYlXS;

1.192
date	2017.03.15.15.24.24;	author deraadt;	state Exp;
branches;
next	1.191;
commitid	CQw8TaW2z3chherB;

1.191
date	2016.12.08.05.32.49;	author deraadt;	state Exp;
branches;
next	1.190;
commitid	jaNdO4LiE0jSDtqT;

1.190
date	2016.10.18.13.40.59;	author deraadt;	state Exp;
branches;
next	1.189;
commitid	zlYQi7y5C8jlnr65;

1.189
date	2016.10.07.15.59.36;	author tedu;	state Exp;
branches;
next	1.188;
commitid	INRYYDp4tKqkoMbj;

1.188
date	2016.10.07.15.50.12;	author tedu;	state Exp;
branches;
next	1.187;
commitid	vLyq5GDEYR4R6PZa;

1.187
date	2016.09.23.02.37.24;	author deraadt;	state Exp;
branches;
next	1.186;
commitid	vPBqWT42ZBJs4Zkl;

1.186
date	2016.09.22.22.04.02;	author deraadt;	state Exp;
branches;
next	1.185;
commitid	1SXdrTprzGaGq2t0;

1.185
date	2016.09.04.16.15.30;	author kettenis;	state Exp;
branches;
next	1.184;
commitid	o6CWyb2var0AwDgi;

1.184
date	2016.09.03.11.40.54;	author kettenis;	state Exp;
branches;
next	1.183;
commitid	Si2p98NfRBrBva9v;

1.183
date	2016.09.01.09.05.52;	author deraadt;	state Exp;
branches;
next	1.182;
commitid	D4EAsjXP8yRMw7ua;

1.182
date	2016.07.15.19.02.30;	author tom;	state Exp;
branches;
next	1.181;
commitid	ltUuT0vppwaa3KDr;

1.181
date	2016.05.23.15.48.59;	author deraadt;	state Exp;
branches;
next	1.180;
commitid	u827DKK0c0dFAF72;

1.180
date	2016.05.17.21.05.49;	author tedu;	state Exp;
branches;
next	1.179;
commitid	CCble4VU2BZwEtcg;

1.179
date	2016.02.19.19.15.59;	author stefan;	state Exp;
branches;
next	1.178;
commitid	xmkBc1jhKjKbZqcW;

1.178
date	2016.01.08.07.54.02;	author stefan;	state Exp;
branches;
next	1.177;
commitid	9yDLZqFZVmZfsevg;

1.177
date	2015.12.28.05.21.53;	author tedu;	state Exp;
branches;
next	1.176;
commitid	WQAn0AsN7XxYBhbD;

1.176
date	2015.10.27.11.13.06;	author mikeb;	state Exp;
branches;
next	1.175;
commitid	rHS5G6bPjACqG1kw;

1.175
date	2015.05.25.03.07.07;	author deraadt;	state Exp;
branches;
next	1.174;
commitid	ladC9EzK56nEZle8;

1.174
date	2015.05.04.09.38.05;	author jsg;	state Exp;
branches;
next	1.173;
commitid	LeFyUiHrWZgmgpmc;

1.173
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.172;
commitid	p4LJxGKbi0BU2cG6;

1.172
date	2015.02.17.22.34.59;	author tedu;	state Exp;
branches;
next	1.171;
commitid	5lgOiiJX9mZFx37W;

1.171
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.170;
commitid	C5iGb36LQxjM60Q3;

1.170
date	2015.02.07.01.19.40;	author deraadt;	state Exp;
branches;
next	1.169;
commitid	J7ySI1ZREP62T8hM;

1.169
date	2015.01.27.03.17.35;	author dlg;	state Exp;
branches;
next	1.168;
commitid	MyKPm9Q3dQu92BiX;

1.168
date	2014.12.23.20.32.05;	author tedu;	state Exp;
branches;
next	1.167;
commitid	NCahA5wbdXcUPHyt;

1.167
date	2014.12.23.20.29.23;	author tedu;	state Exp;
branches;
next	1.166;
commitid	MoiZroV3luZ9cdbC;

1.166
date	2014.12.19.04.00.00;	author tedu;	state Exp;
branches;
next	1.165;
commitid	bbJFJqHWQYuz1Ynl;

1.165
date	2014.12.19.02.29.40;	author tedu;	state Exp;
branches;
next	1.164;
commitid	isvEKSakPSOLFF20;

1.164
date	2014.12.18.16.27.30;	author deraadt;	state Exp;
branches;
next	1.163;
commitid	KtbVt5DtBuq9rG7s;

1.163
date	2014.10.24.20.02.07;	author tedu;	state Exp;
branches;
next	1.162;
commitid	je2c9J1n7CrlFg0H;

1.162
date	2014.10.20.00.48.57;	author tedu;	state Exp;
branches;
next	1.161;
commitid	CYuXNbTb69gM6qvK;

1.161
date	2014.10.20.00.40.19;	author tedu;	state Exp;
branches;
next	1.160;
commitid	j2oy76LRnv4igHv2;

1.160
date	2014.09.15.22.00.24;	author tedu;	state Exp;
branches;
next	1.159;
commitid	IfC1briEZdOcr2Cq;

1.159
date	2014.07.17.13.38.22;	author tedu;	state Exp;
branches;
next	1.158;
commitid	cENAaOH63yLs6sSX;

1.158
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.157;
commitid	OBNa5kfxQ2UXoiIw;

1.157
date	2014.06.14.18.01.42;	author deraadt;	state Exp;
branches;
next	1.156;
commitid	mGZAeMJ1mGoco6ZP;

1.156
date	2014.06.13.08.26.09;	author deraadt;	state Exp;
branches;
next	1.155;
commitid	CpYJ4dq5gv2iN1W3;

1.155
date	2014.02.05.05.54.58;	author tedu;	state Exp;
branches;
next	1.154;

1.154
date	2014.01.22.03.24.42;	author jsing;	state Exp;
branches;
next	1.153;

1.153
date	2014.01.19.23.52.54;	author deraadt;	state Exp;
branches;
next	1.152;

1.152
date	2014.01.19.00.39.40;	author deraadt;	state Exp;
branches;
next	1.151;

1.151
date	2014.01.19.00.24.01;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2013.12.28.02.58.17;	author deraadt;	state Exp;
branches;
next	1.149;

1.149
date	2013.12.22.16.06.12;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2013.12.11.19.34.11;	author guenther;	state Exp;
branches;
next	1.147;

1.147
date	2013.12.11.16.39.30;	author tedu;	state Exp;
branches;
next	1.146;

1.146
date	2013.12.11.04.45.54;	author tedu;	state Exp;
branches;
next	1.145;

1.145
date	2013.11.02.19.37.25;	author markus;	state Exp;
branches;
next	1.144;

1.144
date	2013.10.30.02.13.16;	author dlg;	state Exp;
branches;
next	1.143;

1.143
date	2013.07.09.08.57.24;	author blambert;	state Exp;
branches;
next	1.142;

1.142
date	2013.03.25.14.58.28;	author markus;	state Exp;
branches;
next	1.141;

1.141
date	2012.06.24.18.25.12;	author matthew;	state Exp;
branches;
next	1.140;

1.140
date	2011.07.06.14.49.30;	author nicm;	state Exp;
branches;
next	1.139;

1.139
date	2011.01.11.06.15.03;	author djm;	state Exp;
branches;
next	1.138;

1.138
date	2011.01.11.06.08.28;	author tedu;	state Exp;
branches;
next	1.137;

1.137
date	2011.01.10.06.08.38;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2011.01.10.06.05.23;	author deraadt;	state Exp;
branches;
next	1.135;

1.135
date	2011.01.10.05.40.06;	author tedu;	state Exp;
branches;
next	1.134;

1.134
date	2011.01.10.03.23.30;	author deraadt;	state Exp;
branches;
next	1.133;

1.133
date	2011.01.10.02.44.18;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2011.01.09.22.40.51;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2011.01.08.19.45.07;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2011.01.08.02.23.02;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2011.01.08.02.22.43;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2011.01.08.00.55.30;	author tedu;	state Exp;
branches;
next	1.127;

1.127
date	2011.01.07.23.13.48;	author tedu;	state Exp;
branches;
next	1.126;

1.126
date	2011.01.07.04.56.51;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2011.01.07.04.38.00;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2011.01.06.22.49.10;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	2011.01.06.15.41.50;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2011.01.04.19.42.22;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2011.01.01.19.43.04;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2011.01.01.01.41.02;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2010.12.31.22.45.18;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2010.12.31.22.40.19;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2010.12.31.22.39.11;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2010.12.31.22.38.07;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2010.12.31.22.32.20;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2010.12.30.22.05.45;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2010.12.29.20.11.17;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2010.12.29.18.28.16;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2010.12.29.18.23.12;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2010.12.29.18.21.42;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2010.12.29.18.19.42;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2010.12.29.18.16.59;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2010.12.29.17.51.48;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2010.12.24.06.23.36;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2010.12.22.18.16.24;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2010.11.21.22.58.40;	author tedu;	state Exp;
branches;
next	1.103;

1.103
date	2010.10.02.15.49.17;	author tedu;	state Exp;
branches;
next	1.102;

1.102
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.101;

1.101
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.05.04.43.23;	author guenther;	state Exp;
branches;
next	1.99;

1.99
date	2008.12.15.06.00.38;	author djm;	state Exp;
branches;
next	1.98;

1.98
date	2008.11.24.19.02.38;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2008.11.24.16.36.41;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2008.11.24.10.30.12;	author mpf;	state Exp;
branches;
next	1.95;

1.95
date	2008.10.15.03.30.57;	author djm;	state Exp;
branches;
next	1.94;

1.94
date	2008.10.10.20.13.11;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.92;

1.92
date	2008.06.11.19.38.00;	author djm;	state Exp;
branches;
next	1.91;

1.91
date	2008.06.10.03.11.30;	author djm;	state Exp;
branches;
next	1.90;

1.90
date	2008.06.09.23.03.16;	author djm;	state Exp;
branches;
next	1.89;

1.89
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.88;

1.88
date	2008.06.04.00.50.23;	author djm;	state Exp;
branches;
next	1.87;

1.87
date	2008.03.02.21.29.07;	author djm;	state Exp;
branches;
next	1.86;

1.86
date	2007.12.29.08.03.05;	author dlg;	state Exp;
branches;
next	1.85;

1.85
date	2007.10.15.23.20.56;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2007.10.15.01.01.47;	author djm;	state Exp;
branches;
next	1.83;

1.83
date	2007.10.09.17.05.19;	author gilles;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.17.21.22.04;	author jasper;	state Exp;
branches;
next	1.81;

1.81
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2006.04.11.14.31.52;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2005.07.31.05.13.08;	author djm;	state Exp;
branches;
next	1.78;

1.78
date	2005.07.07.00.11.24;	author djm;	state Exp;
branches;
next	1.77;

1.77
date	2005.05.27.16.33.27;	author ho;	state Exp;
branches;
next	1.76;

1.76
date	2005.03.04.17.09.21;	author robert;	state Exp;
branches;
next	1.75;

1.75
date	2005.01.27.18.18.20;	author mickey;	state Exp;
branches;
next	1.74;

1.74
date	2005.01.27.18.12.32;	author millert;	state Exp;
branches;
next	1.73;

1.73
date	2004.07.21.01.02.07;	author mickey;	state Exp;
branches
	1.73.2.1;
next	1.72;

1.72
date	2004.07.06.21.24.36;	author mickey;	state Exp;
branches;
next	1.71;

1.71
date	2004.07.05.20.57.50;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2004.05.07.14.42.27;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.02.20.34.43;	author mickey;	state Exp;
branches;
next	1.68;

1.68
date	2004.04.02.20.17.45;	author mickey;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.15.14.17.25;	author mickey;	state Exp;
branches
	1.67.2.1;
next	1.66;

1.66
date	2003.11.03.18.24.28;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2003.10.21.05.24.40;	author jmc;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2003.08.15.20.32.16;	author tedu;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2002.11.25.10.09.24;	author mickey;	state Exp;
branches;
next	1.61;

1.61
date	2002.11.11.19.53.24;	author mickey;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.19.03.03.28;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.14.00.07.57;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.27.01.59.58;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2002.04.01.08.25.58;	author mickey;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.21.23.02.22;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2002.01.31.00.16.42;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.10.18.49.07;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.03.09.23.22;	author nordin;	state Exp;
branches;
next	1.51;

1.51
date	2001.12.29.17.22.41;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.24.02.23.44;	author mickey;	state Exp;
branches
	1.50.4.1;
next	1.49;

1.49
date	2001.09.23.10.16.27;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.24.20.52.05;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.08.17.30.56;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2001.01.17.01.59.50;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2000.10.22.01.08.52;	author mickey;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2000.10.20.03.30.05;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2000.08.21.01.52.18;	author jason;	state Exp;
branches;
next	1.42;

1.42
date	2000.07.18.17.32.25;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2000.06.18.16.32.19;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2000.06.16.19.18.51;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2000.06.08.02.39.08;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2000.04.18.15.11.28;	author hugh;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2000.04.14.14.40.50;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.13.13.48.29;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.10.19.44.38;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2000.03.19.17.38.03;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	99.09.28.01.24.46;	author deraadt;	state Exp;
branches
	1.33.4.1;
next	1.32;

1.32
date	97.08.22.12.54.33;	author downsj;	state Exp;
branches;
next	1.31;

1.31
date	97.06.28.07.05.22;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	97.06.24.02.45.00;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	97.06.22.05.05.00;	author flipk;	state Exp;
branches;
next	1.28;

1.28
date	97.06.22.04.58.05;	author flipk;	state Exp;
branches;
next	1.27;

1.27
date	97.06.21.04.59.36;	author flipk;	state Exp;
branches;
next	1.26;

1.26
date	97.06.20.20.28.41;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	97.06.18.05.09.09;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	97.06.17.19.42.01;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.06.14.21.37.08;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.06.12.02.18.39;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	97.06.12.01.45.16;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.06.11.01.28.42;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.06.10.18.55.30;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.03.30.22.05.11;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.02.04.03.03.18;	author dm;	state Exp;
branches;
next	1.16;

1.16
date	97.01.15.22.33.53;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.01.15.02.03.53;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.01.05.11.08.58;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.01.01.16.16.13;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	96.12.28.19.06.28;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.10.19.13.25.58;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.10.18.12.28.21;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.09.29.16.42.00;	author dm;	state Exp;
branches;
next	1.8;

1.8
date	96.09.06.08.36.13;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.08.29.09.26.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.11.07.31.31;	author dm;	state Exp;
branches;
next	1.5;

1.5
date	96.08.11.06.41.38;	author dm;	state Exp;
branches;
next	1.4;

1.4
date	96.08.10.19.41.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.24.21.26.41;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.04.17.04.59.48;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.03.29.12.09.55;	author mickey;	state Exp;
branches;
next	;

1.33.4.1
date	2000.03.24.09.09.06;	author niklas;	state Exp;
branches;
next	1.33.4.2;

1.33.4.2
date	2001.05.14.22.23.02;	author niklas;	state Exp;
branches;
next	1.33.4.3;

1.33.4.3
date	2001.07.04.10.40.14;	author niklas;	state Exp;
branches;
next	1.33.4.4;

1.33.4.4
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.33.4.5;

1.33.4.5
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.33.4.6;

1.33.4.6
date	2002.03.28.15.03.52;	author niklas;	state Exp;
branches;
next	1.33.4.7;

1.33.4.7
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.33.4.8;

1.33.4.8
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	1.33.4.9;

1.33.4.9
date	2004.06.05.23.12.36;	author niklas;	state Exp;
branches;
next	;

1.38.2.1
date	2000.08.21.01.50.06;	author jason;	state Exp;
branches;
next	;

1.45.2.1
date	2001.01.23.03.45.04;	author jason;	state Exp;
branches;
next	;

1.50.4.1
date	2002.01.31.22.55.29;	author niklas;	state Exp;
branches;
next	1.50.4.2;

1.50.4.2
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	1.50.4.3;

1.50.4.3
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	1.50.4.4;

1.50.4.4
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;

1.63.2.1
date	2004.07.17.03.02.25;	author brad;	state Exp;
branches;
next	;

1.67.2.1
date	2004.07.17.02.57.54;	author brad;	state Exp;
branches;
next	1.67.2.2;

1.67.2.2
date	2005.02.27.00.51.33;	author brad;	state Exp;
branches;
next	;

1.73.2.1
date	2005.02.27.00.54.16;	author brad;	state Exp;
branches;
next	;


desc
@@


1.193
log
@clang (and newer gcc at high -O) are unaware that objects placed in strange
sections, such as __attribute__((section(".openbsd.randomdata"))), may be
non-zero.  In combination with "const" or "static" the compiler becomes even
more sure nothing can influence the object and assumes the value will be 0.
A few optimizations later, a security requirement has been removed.

Until a better annotation arrives in compilers, be warned:  Do not mix
const or static with these random objects, you won't get what you want.
Spotted in a regression test by bluhm, long discussion with kettenis.
@
text
@/*	$OpenBSD: rnd.c,v 1.192 2017/03/15 15:24:24 deraadt Exp $	*/

/*
 * Copyright (c) 2011 Theo de Raadt.
 * Copyright (c) 2008 Damien Miller.
 * Copyright (c) 1996, 1997, 2000-2002 Michael Shalayeff.
 * Copyright (c) 2013 Markus Friedl.
 * Copyright Theodore Ts'o, 1994, 1995, 1996, 1997, 1998, 1999.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, and the entire permission notice in its entirety,
 *    including the disclaimer of warranties.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * ALTERNATIVELY, this product may be distributed under the terms of
 * the GNU Public License, in which case the provisions of the GPL are
 * required INSTEAD OF the above restrictions.  (This clause is
 * necessary due to a potential bad interaction between the GPL and
 * the restrictions contained in a BSD-style copyright.)
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Computers are very predictable devices.  Hence it is extremely hard
 * to produce truly random numbers on a computer --- as opposed to
 * pseudo-random numbers, which can be easily generated by using an
 * algorithm.  Unfortunately, it is very easy for attackers to guess
 * the sequence of pseudo-random number generators, and for some
 * applications this is not acceptable.  Instead, we must try to
 * gather "environmental noise" from the computer's environment, which
 * must be hard for outside attackers to observe and use to
 * generate random numbers.  In a Unix environment, this is best done
 * from inside the kernel.
 *
 * Sources of randomness from the environment include inter-keyboard
 * timings, inter-interrupt timings from some interrupts, and other
 * events which are both (a) non-deterministic and (b) hard for an
 * outside observer to measure.  Randomness from these sources is
 * added to the "rnd states" queue; this is used as much of the
 * source material which is mixed on occasion using a CRC-like function
 * into the "entropy pool".  This is not cryptographically strong, but
 * it is adequate assuming the randomness is not chosen maliciously,
 * and it is very fast because the interrupt-time event is only to add
 * a small random token to the "rnd states" queue.
 *
 * When random bytes are desired, they are obtained by pulling from
 * the entropy pool and running a SHA512 hash. The SHA512 hash avoids
 * exposing the internal state of the entropy pool.  Even if it is
 * possible to analyze SHA512 in some clever way, as long as the amount
 * of data returned from the generator is less than the inherent
 * entropy in the pool, the output data is totally unpredictable.  For
 * this reason, the routine decreases its internal estimate of how many
 * bits of "true randomness" are contained in the entropy pool as it
 * outputs random numbers.
 *
 * If this estimate goes to zero, the SHA512 hash will continue to generate
 * output since there is no true risk because the SHA512 output is not
 * exported outside this subsystem.  It is next used as input to seed a
 * ChaCha20 stream cipher, which is re-seeded from time to time.  This
 * design provides very high amounts of output data from a potentially
 * small entropy base, at high enough speeds to encourage use of random
 * numbers in nearly any situation.  Before OpenBSD 5.5, the RC4 stream
 * cipher (also known as ARC4) was used instead of ChaCha20.
 *
 * The output of this single ChaCha20 engine is then shared amongst many
 * consumers in the kernel and userland via a few interfaces:
 * arc4random_buf(), arc4random(), arc4random_uniform(), randomread()
 * for the set of /dev/random nodes and the system call getentropy(),
 * which provides seeds for process-context pseudorandom generators.
 *
 * Acknowledgements:
 * =================
 *
 * Ideas for constructing this random number generator were derived
 * from Pretty Good Privacy's random number generator, and from private
 * discussions with Phil Karn.  Colin Plumb provided a faster random
 * number generator, which speeds up the mixing function of the entropy
 * pool, taken from PGPfone.  Dale Worley has also contributed many
 * useful ideas and suggestions to improve this driver.
 *
 * Any flaws in the design are solely my responsibility, and should
 * not be attributed to the Phil, Colin, or any of the authors of PGP.
 *
 * Further background information on this topic may be obtained from
 * RFC 1750, "Randomness Recommendations for Security", by Donald
 * Eastlake, Steve Crocker, and Jeff Schiller.
 *
 * Using a RC4 stream cipher as 2nd stage after the MD5 (now SHA512) output
 * is the result of work by David Mazieres.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/disk.h>
#include <sys/event.h>
#include <sys/limits.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>
#include <sys/timeout.h>
#include <sys/mutex.h>
#include <sys/task.h>
#include <sys/msgbuf.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <crypto/sha2.h>

#define KEYSTREAM_ONLY
#include <crypto/chacha_private.h>

#include <dev/rndvar.h>

#include <uvm/uvm_param.h>
#include <uvm/uvm_extern.h>

/*
 * For the purposes of better mixing, we use the CRC-32 polynomial as
 * well to make a twisted Generalized Feedback Shift Register
 *
 * (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR generators.  ACM
 * Transactions on Modeling and Computer Simulation 2(3):179-194.
 * Also see M. Matsumoto & Y. Kurita, 1994.  Twisted GFSR generators
 * II.  ACM Transactions on Modeling and Computer Simulation 4:254-266)
 *
 * Thanks to Colin Plumb for suggesting this.
 *
 * We have not analyzed the resultant polynomial to prove it primitive;
 * in fact it almost certainly isn't.  Nonetheless, the irreducible factors
 * of a random large-degree polynomial over GF(2) are more than large enough
 * that periodicity is not a concern.
 *
 * The input hash is much less sensitive than the output hash.  All
 * we want from it is to be a good non-cryptographic hash -
 * i.e. to not produce collisions when fed "random" data of the sort
 * we expect to see.  As long as the pool state differs for different
 * inputs, we have preserved the input entropy and done a good job.
 * The fact that an intelligent attacker can construct inputs that
 * will produce controlled alterations to the pool's state is not
 * important because we don't consider such inputs to contribute any
 * randomness.  The only property we need with respect to them is that
 * the attacker can't increase his/her knowledge of the pool's state.
 * Since all additions are reversible (knowing the final state and the
 * input, you can reconstruct the initial state), if an attacker has
 * any uncertainty about the initial state, he/she can only shuffle
 * that uncertainty about, but never cause any collisions (which would
 * decrease the uncertainty).
 *
 * The chosen system lets the state of the pool be (essentially) the input
 * modulo the generator polynomial.  Now, for random primitive polynomials,
 * this is a universal class of hash functions, meaning that the chance
 * of a collision is limited by the attacker's knowledge of the generator
 * polynomial, so if it is chosen at random, an attacker can never force
 * a collision.  Here, we use a fixed polynomial, but we *can* assume that
 * ###--> it is unknown to the processes generating the input entropy. <-###
 * Because of this important property, this is a good, collision-resistant
 * hash; hash collisions will occur no more often than chance.
 */

/*
 * Stirring polynomials over GF(2) for various pool sizes. Used in
 * add_entropy_words() below.
 *
 * The polynomial terms are chosen to be evenly spaced (minimum RMS
 * distance from evenly spaced; except for the last tap, which is 1 to
 * get the twisting happening as fast as possible.
 *
 * The resultant polynomial is:
 *   2^POOLWORDS + 2^POOL_TAP1 + 2^POOL_TAP2 + 2^POOL_TAP3 + 2^POOL_TAP4 + 1
 */
#define POOLWORDS	2048
#define POOLBYTES	(POOLWORDS*4)
#define POOLMASK	(POOLWORDS - 1)
#define	POOL_TAP1	1638
#define	POOL_TAP2	1231
#define	POOL_TAP3	819
#define	POOL_TAP4	411

struct mutex entropylock = MUTEX_INITIALIZER(IPL_HIGH);

/*
 * Raw entropy collection from device drivers; at interrupt context or not.
 * add_*_randomness() provide data which is put into the entropy queue.
 * Almost completely under the entropylock.
 */

#define QEVLEN (1024 / sizeof(struct rand_event))
#define QEVSLOW (QEVLEN * 3 / 4) /* yet another 0.75 for 60-minutes hour /-; */
#define QEVSBITS 10

#define KEYSZ	32
#define IVSZ	8
#define BLOCKSZ	64
#define RSBUFSZ	(16*BLOCKSZ)
#define EBUFSIZE KEYSZ + IVSZ

struct rand_event {
	u_int re_time;
	u_int re_val;
} rnd_event_space[QEVLEN];
/* index of next free slot */
u_int rnd_event_idx;

struct timeout rnd_timeout;

static u_int32_t entropy_pool[POOLWORDS];
u_int32_t entropy_pool0[POOLWORDS] __attribute__((section(".openbsd.randomdata")));
u_int	entropy_add_ptr;
u_char	entropy_input_rotate;

void	dequeue_randomness(void *);
void	add_entropy_words(const u_int32_t *, u_int);
void	extract_entropy(u_int8_t *)
    __attribute__((__bounded__(__minbytes__,1,EBUFSIZE)));

int	filt_randomread(struct knote *, long);
void	filt_randomdetach(struct knote *);
int	filt_randomwrite(struct knote *, long);

static void _rs_seed(u_char *, size_t);
static void _rs_clearseed(const void *p, size_t s);

struct filterops randomread_filtops =
	{ 1, NULL, filt_randomdetach, filt_randomread };
struct filterops randomwrite_filtops =
	{ 1, NULL, filt_randomdetach, filt_randomwrite };

static __inline struct rand_event *
rnd_get(void)
{
	if (rnd_event_idx == 0)
		return NULL;
	/* if it wrapped around, start dequeuing at the end */
	if (rnd_event_idx > QEVLEN)
		rnd_event_idx = QEVLEN;

	return &rnd_event_space[--rnd_event_idx];
}

static __inline struct rand_event *
rnd_put(void)
{
	u_int idx = rnd_event_idx++;

	/* allow wrapping. caller will use xor. */
	idx = idx % QEVLEN;

	return &rnd_event_space[idx];
}

static __inline u_int
rnd_qlen(void)
{
	return rnd_event_idx;
}

/*
 * This function adds entropy to the entropy pool by using timing
 * delays.  It uses the timer_rand_state structure to make an estimate
 * of how many bits of entropy this call has added to the pool.
 *
 * The number "val" is also added to the pool - it should somehow describe
 * the type of event which just happened.  Currently the values of 0-255
 * are for keyboard scan codes, 256 and upwards - for interrupts.
 */
void
enqueue_randomness(u_int state, u_int val)
{
	struct rand_event *rep;
	struct timespec	ts;

#ifdef DIAGNOSTIC
	if (state >= RND_SRC_NUM)
		return;
#endif

	if (timeout_initialized(&rnd_timeout))
		nanotime(&ts);

	val += state << 13;

	mtx_enter(&entropylock);

	rep = rnd_put();

	rep->re_time += ts.tv_nsec ^ (ts.tv_sec << 20);
	rep->re_val += val;

	if (rnd_qlen() > QEVSLOW/2 && timeout_initialized(&rnd_timeout) &&
	    !timeout_pending(&rnd_timeout))
		timeout_add(&rnd_timeout, 1);

	mtx_leave(&entropylock);
}

/*
 * This function adds a byte into the entropy pool.  It does not
 * update the entropy estimate.  The caller must do this if appropriate.
 *
 * The pool is stirred with a polynomial of degree POOLWORDS over GF(2);
 * see POOL_TAP[1-4] above
 *
 * Rotate the input word by a changing number of bits, to help assure
 * that all bits in the entropy get toggled.  Otherwise, if the pool
 * is consistently fed small numbers (such as keyboard scan codes)
 * then the upper bits of the entropy pool will frequently remain
 * untouched.
 */
void
add_entropy_words(const u_int32_t *buf, u_int n)
{
	/* derived from IEEE 802.3 CRC-32 */
	static const u_int32_t twist_table[8] = {
		0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
		0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278
	};

	for (; n--; buf++) {
		u_int32_t w = (*buf << entropy_input_rotate) |
		    (*buf >> ((32 - entropy_input_rotate) & 31));
		u_int i = entropy_add_ptr =
		    (entropy_add_ptr - 1) & POOLMASK;
		/*
		 * Normally, we add 7 bits of rotation to the pool.
		 * At the beginning of the pool, add an extra 7 bits
		 * rotation, so that successive passes spread the
		 * input bits across the pool evenly.
		 */
		entropy_input_rotate =
		    (entropy_input_rotate + (i ? 7 : 14)) & 31;

		/* XOR pool contents corresponding to polynomial terms */
		w ^= entropy_pool[(i + POOL_TAP1) & POOLMASK] ^
		     entropy_pool[(i + POOL_TAP2) & POOLMASK] ^
		     entropy_pool[(i + POOL_TAP3) & POOLMASK] ^
		     entropy_pool[(i + POOL_TAP4) & POOLMASK] ^
		     entropy_pool[(i + 1) & POOLMASK] ^
		     entropy_pool[i]; /* + 2^POOLWORDS */

		entropy_pool[i] = (w >> 3) ^ twist_table[w & 7];
	}
}

/*
 * Pulls entropy out of the queue and merges it into the pool
 * with the CRC.
 */
/* ARGSUSED */
void
dequeue_randomness(void *v)
{
	struct rand_event *rep;
	u_int32_t buf[2];

	mtx_enter(&entropylock);

	if (timeout_initialized(&rnd_timeout))
		timeout_del(&rnd_timeout);

	while ((rep = rnd_get())) {
		buf[0] = rep->re_time;
		buf[1] = rep->re_val;
		mtx_leave(&entropylock);

		add_entropy_words(buf, 2);

		mtx_enter(&entropylock);
	}
	mtx_leave(&entropylock);
}

/*
 * Grabs a chunk from the entropy_pool[] and slams it through SHA512 when
 * requested.
 */
void
extract_entropy(u_int8_t *buf)
{
	static u_int32_t extract_pool[POOLWORDS];
	u_char digest[SHA512_DIGEST_LENGTH];
	SHA2_CTX shactx;

#if SHA512_DIGEST_LENGTH < EBUFSIZE
#error "need more bigger hash output"
#endif

	/*
	 * INTENTIONALLY not protected by entropylock.  Races during
	 * memcpy() result in acceptable input data; races during
	 * SHA512Update() would create nasty data dependencies.  We
	 * do not rely on this as a benefit, but if it happens, cool.
	 */
	memcpy(extract_pool, entropy_pool, sizeof(extract_pool));

	/* Hash the pool to get the output */
	SHA512Init(&shactx);
	SHA512Update(&shactx, (u_int8_t *)extract_pool, sizeof(extract_pool));
	SHA512Final(digest, &shactx);

	/* Copy data to destination buffer */
	memcpy(buf, digest, EBUFSIZE);

	/* Modify pool so next hash will produce different results */
	add_timer_randomness(EBUFSIZE);
	dequeue_randomness(NULL);

	/* Wipe data from memory */
	explicit_bzero(extract_pool, sizeof(extract_pool));
	explicit_bzero(digest, sizeof(digest));
}

/* random keystream by ChaCha */

void arc4_reinit(void *v);		/* timeout to start reinit */
void arc4_init(void *);			/* actually do the reinit */

struct mutex rndlock = MUTEX_INITIALIZER(IPL_HIGH);
struct timeout arc4_timeout;
struct task arc4_task = TASK_INITIALIZER(arc4_init, NULL);

static chacha_ctx rs;		/* chacha context for random keystream */
/* keystream blocks (also chacha seed from boot) */
static u_char rs_buf[RSBUFSZ];
u_char rs_buf0[RSBUFSZ] __attribute__((section(".openbsd.randomdata")));
static size_t rs_have;		/* valid bytes at end of rs_buf */
static size_t rs_count;		/* bytes till reseed */

void
suspend_randomness(void)
{
	struct timespec ts;

	getnanotime(&ts);
	add_true_randomness(ts.tv_sec);
	add_true_randomness(ts.tv_nsec);

	dequeue_randomness(NULL);
	rs_count = 0;
	arc4random_buf(entropy_pool, sizeof(entropy_pool));
}

void
resume_randomness(char *buf, size_t buflen)
{
	struct timespec ts;

	if (buf && buflen)
		_rs_seed(buf, buflen);
	getnanotime(&ts);
	add_true_randomness(ts.tv_sec);
	add_true_randomness(ts.tv_nsec);

	dequeue_randomness(NULL);
	rs_count = 0;
}

static inline void _rs_rekey(u_char *dat, size_t datlen);

static inline void
_rs_init(u_char *buf, size_t n)
{
	KASSERT(n >= KEYSZ + IVSZ);
	chacha_keysetup(&rs, buf, KEYSZ * 8);
	chacha_ivsetup(&rs, buf + KEYSZ, NULL);
}

static void
_rs_seed(u_char *buf, size_t n)
{
	_rs_rekey(buf, n);

	/* invalidate rs_buf */
	rs_have = 0;
	memset(rs_buf, 0, RSBUFSZ);

	rs_count = 1600000;
}

static void
_rs_stir(int do_lock)
{
	struct timespec ts;
	u_int8_t buf[EBUFSIZE], *p;
	int i;

	/*
	 * Use SHA512 PRNG data and a system timespec; early in the boot
	 * process this is the best we can do -- some architectures do
	 * not collect entropy very well during this time, but may have
	 * clock information which is better than nothing.
	 */
	extract_entropy(buf);

	nanotime(&ts);
	for (p = (u_int8_t *)&ts, i = 0; i < sizeof(ts); i++)
		buf[i] ^= p[i];

	if (do_lock)
		mtx_enter(&rndlock);
	_rs_seed(buf, sizeof(buf));
	if (do_lock)
		mtx_leave(&rndlock);

	explicit_bzero(buf, sizeof(buf));
}

static inline void
_rs_stir_if_needed(size_t len)
{
	static int rs_initialized;

	if (!rs_initialized) {
		memcpy(entropy_pool, entropy_pool0, sizeof entropy_pool);
		memcpy(rs_buf, rs_buf0, sizeof rs_buf);
		/* seeds cannot be cleaned yet, random_start() will do so */
		_rs_init(rs_buf, KEYSZ + IVSZ);
		rs_count = 1024 * 1024 * 1024;	/* until main() runs */
		rs_initialized = 1;
	} else if (rs_count <= len)
		_rs_stir(0);
	else
		rs_count -= len;
}

static void
_rs_clearseed(const void *p, size_t s)
{
	struct kmem_dyn_mode kd_avoidalias;
	vaddr_t va = trunc_page((vaddr_t)p);
	vsize_t off = (vaddr_t)p - va;
	vsize_t len;
	vaddr_t rwva;
	paddr_t pa;

	while (s > 0) {
		pmap_extract(pmap_kernel(), va, &pa);

		memset(&kd_avoidalias, 0, sizeof kd_avoidalias);
		kd_avoidalias.kd_prefer = pa;
		kd_avoidalias.kd_waitok = 1;
		rwva = (vaddr_t)km_alloc(PAGE_SIZE, &kv_any, &kp_none,
		    &kd_avoidalias);
		if (!rwva)
			panic("_rs_clearseed");

		pmap_kenter_pa(rwva, pa, PROT_READ | PROT_WRITE);
		pmap_update(pmap_kernel());

		len = MIN(s, PAGE_SIZE - off);
		explicit_bzero((void *)(rwva + off), len);

		pmap_kremove(rwva, PAGE_SIZE);
		km_free((void *)rwva, PAGE_SIZE, &kv_any, &kp_none);

		va += PAGE_SIZE;
		s -= len;
		off = 0;
	}
}

static inline void
_rs_rekey(u_char *dat, size_t datlen)
{
#ifndef KEYSTREAM_ONLY
	memset(rs_buf, 0, RSBUFSZ);
#endif
	/* fill rs_buf with the keystream */
	chacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);
	/* mix in optional user provided data */
	if (dat) {
		size_t i, m;

		m = MIN(datlen, KEYSZ + IVSZ);
		for (i = 0; i < m; i++)
			rs_buf[i] ^= dat[i];
	}
	/* immediately reinit for backtracking resistance */
	_rs_init(rs_buf, KEYSZ + IVSZ);
	memset(rs_buf, 0, KEYSZ + IVSZ);
	rs_have = RSBUFSZ - KEYSZ - IVSZ;
}

static inline void
_rs_random_buf(void *_buf, size_t n)
{
	u_char *buf = (u_char *)_buf;
	size_t m;

	_rs_stir_if_needed(n);
	while (n > 0) {
		if (rs_have > 0) {
			m = MIN(n, rs_have);
			memcpy(buf, rs_buf + RSBUFSZ - rs_have, m);
			memset(rs_buf + RSBUFSZ - rs_have, 0, m);
			buf += m;
			n -= m;
			rs_have -= m;
		}
		if (rs_have == 0)
			_rs_rekey(NULL, 0);
	}
}

static inline void
_rs_random_u32(u_int32_t *val)
{
	_rs_stir_if_needed(sizeof(*val));
	if (rs_have < sizeof(*val))
		_rs_rekey(NULL, 0);
	memcpy(val, rs_buf + RSBUFSZ - rs_have, sizeof(*val));
	memset(rs_buf + RSBUFSZ - rs_have, 0, sizeof(*val));
	rs_have -= sizeof(*val);
}

/* Return one word of randomness from a ChaCha20 generator */
u_int32_t
arc4random(void)
{
	u_int32_t ret;

	mtx_enter(&rndlock);
	_rs_random_u32(&ret);
	mtx_leave(&rndlock);
	return ret;
}

/*
 * Fill a buffer of arbitrary length with ChaCha20-derived randomness.
 */
void
arc4random_buf(void *buf, size_t n)
{
	mtx_enter(&rndlock);
	_rs_random_buf(buf, n);
	mtx_leave(&rndlock);
}

/*
 * Calculate a uniformly distributed random number less than upper_bound
 * avoiding "modulo bias".
 *
 * Uniformity is achieved by generating new random numbers until the one
 * returned is outside the range [0, 2**32 % upper_bound).  This
 * guarantees the selected random number will be inside
 * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound)
 * after reduction modulo upper_bound.
 */
u_int32_t
arc4random_uniform(u_int32_t upper_bound)
{
	u_int32_t r, min;

	if (upper_bound < 2)
		return 0;

	/* 2**32 % x == (2**32 - x) % x */
	min = -upper_bound % upper_bound;

	/*
	 * This could theoretically loop forever but each retry has
	 * p > 0.5 (worst case, usually far better) of selecting a
	 * number inside the range we need, so it should rarely need
	 * to re-roll.
	 */
	for (;;) {
		r = arc4random();
		if (r >= min)
			break;
	}

	return r % upper_bound;
}

/* ARGSUSED */
void
arc4_init(void *null)
{
	_rs_stir(1);
}

/*
 * Called by timeout to mark arc4 for stirring,
 */
void
arc4_reinit(void *v)
{
	task_add(systq, &arc4_task);
	/* 10 minutes, per dm@@'s suggestion */
	timeout_add_sec(&arc4_timeout, 10 * 60);
}

/*
 * Start periodic services inside the random subsystem, which pull
 * entropy forward, hash it, and re-seed the random stream as needed.
 */
void
random_start(void)
{
#if !defined(NO_PROPOLICE)
	extern long __guard_local;

	if (__guard_local == 0)
		printf("warning: no entropy supplied by boot loader\n");
#endif

	_rs_clearseed(entropy_pool0, sizeof entropy_pool0);
	_rs_clearseed(rs_buf0, sizeof rs_buf0);

	/* Message buffer may contain data from previous boot */
	if (msgbufp->msg_magic == MSG_MAGIC)
		add_entropy_words((u_int32_t *)msgbufp->msg_bufc,
		    msgbufp->msg_bufs / sizeof(u_int32_t));

	dequeue_randomness(NULL);
	arc4_init(NULL);
	timeout_set(&arc4_timeout, arc4_reinit, NULL);
	arc4_reinit(NULL);
	timeout_set(&rnd_timeout, dequeue_randomness, NULL);
}

int
randomopen(dev_t dev, int flag, int mode, struct proc *p)
{
	return 0;
}

int
randomclose(dev_t dev, int flag, int mode, struct proc *p)
{
	return 0;
}

/*
 * Maximum number of bytes to serve directly from the main ChaCha
 * pool. Larger requests are served from a discrete ChaCha instance keyed
 * from the main pool.
 */
#define ARC4_MAIN_MAX_BYTES	2048

int
randomread(dev_t dev, struct uio *uio, int ioflag)
{
	u_char		lbuf[KEYSZ+IVSZ];
	chacha_ctx	lctx;
	size_t		total = uio->uio_resid;
	u_char		*buf;
	int		myctx = 0, ret = 0;

	if (uio->uio_resid == 0)
		return 0;

	buf = malloc(POOLBYTES, M_TEMP, M_WAITOK);
	if (total > ARC4_MAIN_MAX_BYTES) {
		arc4random_buf(lbuf, sizeof(lbuf));
		chacha_keysetup(&lctx, lbuf, KEYSZ * 8);
		chacha_ivsetup(&lctx, lbuf + KEYSZ, NULL);
		explicit_bzero(lbuf, sizeof(lbuf));
		myctx = 1;
	}

	while (ret == 0 && uio->uio_resid > 0) {
		size_t	n = ulmin(POOLBYTES, uio->uio_resid);

		if (myctx) {
#ifndef KEYSTREAM_ONLY
			memset(buf, 0, n);
#endif
			chacha_encrypt_bytes(&lctx, buf, buf, n);
		} else
			arc4random_buf(buf, n);
		ret = uiomove(buf, n, uio);
		if (ret == 0 && uio->uio_resid > 0)
			yield();
	}
	if (myctx)
		explicit_bzero(&lctx, sizeof(lctx));
	explicit_bzero(buf, POOLBYTES);
	free(buf, M_TEMP, POOLBYTES);
	return ret;
}

int
randomwrite(dev_t dev, struct uio *uio, int flags)
{
	int		ret = 0, newdata = 0;
	u_int32_t	*buf;

	if (uio->uio_resid == 0)
		return 0;

	buf = malloc(POOLBYTES, M_TEMP, M_WAITOK);

	while (ret == 0 && uio->uio_resid > 0) {
		size_t	n = ulmin(POOLBYTES, uio->uio_resid);

		ret = uiomove(buf, n, uio);
		if (ret != 0)
			break;
		while (n % sizeof(u_int32_t))
			((u_int8_t *)buf)[n++] = 0;
		add_entropy_words(buf, n / 4);
		if (uio->uio_resid > 0)
			yield();
		newdata = 1;
	}

	if (newdata)
		arc4_init(NULL);

	explicit_bzero(buf, POOLBYTES);
	free(buf, M_TEMP, POOLBYTES);
	return ret;
}

int
randomkqfilter(dev_t dev, struct knote *kn)
{
	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &randomread_filtops;
		break;
	case EVFILT_WRITE:
		kn->kn_fop = &randomwrite_filtops;
		break;
	default:
		return (EINVAL);
	}

	return (0);
}

void
filt_randomdetach(struct knote *kn)
{
}

int
filt_randomread(struct knote *kn, long hint)
{
	kn->kn_data = ARC4_MAIN_MAX_BYTES;
	return (1);
}

int
filt_randomwrite(struct knote *kn, long hint)
{
	kn->kn_data = POOLBYTES;
	return (1);
}

int
randomioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	switch (cmd) {
	case FIOASYNC:
		/* No async flag in softc so this is a no-op. */
		break;
	case FIONBIO:
		/* Handled in the upper FS layer. */
		break;
	default:
		return ENOTTY;
	}
	return 0;
}

int
sys_getentropy(struct proc *p, void *v, register_t *retval)
{
	struct sys_getentropy_args /* {
		syscallarg(void *) buf;
		syscallarg(size_t) nbyte;
	} */ *uap = v;
	char buf[256];
	int error;

	if (SCARG(uap, nbyte) > sizeof(buf))
		return (EIO);
	arc4random_buf(buf, SCARG(uap, nbyte));
	if ((error = copyout(buf, SCARG(uap, buf), SCARG(uap, nbyte))) != 0)
		return (error);
	explicit_bzero(buf, sizeof(buf));
	retval[0] = 0;
	return (0);
}
@


1.192
log
@spelling and whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.191 2016/12/08 05:32:49 deraadt Exp $	*/
d228 1
a228 1
static const u_int32_t entropy_pool0[POOLWORDS] __attribute__((section(".openbsd.randomdata")));
d445 1
a445 1
static const u_char rs_buf0[RSBUFSZ] __attribute__((section(".openbsd.randomdata")));
@


1.191
log
@fix spelling errors and typos, from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.190 2016/10/18 13:40:59 deraadt Exp $	*/
d145 1
a145 1
 * II.  ACM Transactions on Mdeling and Computer Simulation 4:254-266)
d265 1
a265 1
	
@


1.190
log
@when openbsd.randomdata was made readonly, the proto seed copy got done
too late, leading to poor rng in the kernel early on.  a behavioural
artifact in vmm spotted the issue.
ok tedu guenther mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.189 2016/10/07 15:59:36 tedu Exp $	*/
d189 1
a189 1
 * The reultant polynomial is:
d366 1
a366 1
 * Pulls entropy out of the queue and throws merges it into the pool
a633 1
	return;
@


1.189
log
@another unused variable bites the dust. spotted by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.188 2016/10/07 15:50:12 tedu Exp $	*/
a441 1
static int rs_initialized;
d531 2
d534 3
a584 7
	if (!rs_initialized) {
		memcpy(entropy_pool, entropy_pool0, sizeof entropy_pool);
		memcpy(rs_buf, rs_buf0, sizeof rs_buf);
		rs_initialized = 1;
		/* seeds cannot be cleaned yet, random_start() will do so */
	}

a735 1
	rs_initialized = 1;
@


1.188
log
@the old time delta code is no longer used. nothing reads these values.
remove it another relic of the superstitious past.
ok deraadt millert mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.187 2016/09/23 02:37:24 deraadt Exp $	*/
a291 1
	u_int	time;
a301 2

	time = (ts.tv_nsec >> 10) + (ts.tv_sec << 20);
@


1.187
log
@kern.arandom no longer exists
from rob pierce
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.186 2016/09/22 22:04:02 deraadt Exp $	*/
a206 7
struct timer_rand_state {	/* There is one of these per entropy source */
	u_int	last_time;
	u_int	last_delta;
	u_int	last_delta2;
	u_int	dont_count_entropy : 1;
	u_int	max_entropy : 1;
} rnd_states[RND_SRC_NUM];
a218 1
	struct timer_rand_state *re_state;
a289 2
	int	delta, delta2, delta3;
	struct timer_rand_state *p;
d292 1
a292 1
	u_int	time, nbits;
a301 1
	p = &rnd_states[state];
a304 51
	nbits = 0;

	/*
	 * Calculate the number of bits of randomness that we probably
	 * added.  We take into account the first and second order
	 * deltas in order to make our estimate.
	 */
	if (!p->dont_count_entropy) {
		delta  = time   - p->last_time;
		delta2 = delta  - p->last_delta;
		delta3 = delta2 - p->last_delta2;

		if (delta < 0) delta = -delta;
		if (delta2 < 0) delta2 = -delta2;
		if (delta3 < 0) delta3 = -delta3;
		if (delta > delta2) delta = delta2;
		if (delta > delta3) delta = delta3;
		delta3 = delta >>= 1;
		/*
		 * delta &= 0xfff;
		 * we don't do it since our time sheet is different from linux
		 */

		if (delta & 0xffff0000) {
			nbits = 16;
			delta >>= 16;
		}
		if (delta & 0xff00) {
			nbits += 8;
			delta >>= 8;
		}
		if (delta & 0xf0) {
			nbits += 4;
			delta >>= 4;
		}
		if (delta & 0xc) {
			nbits += 2;
			delta >>= 2;
		}
		if (delta & 2) {
			nbits += 1;
			delta >>= 1;
		}
		if (delta & 1)
			nbits++;
	} else if (p->max_entropy)
		nbits = 8 * sizeof(val) - 1;

	/* given the multi-order delta logic above, this should never happen */
	if (nbits >= 32)
		return;
a306 5
	if (!p->dont_count_entropy) {
		p->last_time = time;
		p->last_delta  = delta3;
		p->last_delta2 = delta2;
	}
a309 1
	rep->re_state = p;
a735 4

	rnd_states[RND_SRC_TIMER].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].max_entropy = 1;
@


1.186
log
@Stop pushing version & cfdata into as entropy, since the contents are
known and we rely on the bootpath to prime us anyways.
This also solves the issue raised by kettenis, of version potentially
being non-word aligned
ok kettenis djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.185 2016/09/04 16:15:30 kettenis Exp $	*/
d88 2
a89 3
 * for the set of /dev/random nodes, the sysctl kern.arandom, and the
 * system call getentropy(), which provides seeds for process-context
 * pseudorandom generators.
@


1.185
log
@Rototil the _rs_clearseed() function once more such that we don't map pages
beyond the end of .text/.rodata.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.184 2016/09/03 11:40:54 kettenis Exp $	*/
a808 8

	/* Provide some data from this kernel */
	add_entropy_words((u_int32_t *)version,
	    strlen(version) / sizeof(u_int32_t));

	/* Provide some data from this kernel */
	add_entropy_words((u_int32_t *)cfdata,
	    8192 / sizeof(u_int32_t));
@


1.184
log
@Since the initial entropy pool is 8192 bytes, we need three pages to create
the alias mapping when clearing it, since there is no guarantee the pool is
page aligned.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.183 2016/09/01 09:05:52 deraadt Exp $	*/
d620 1
d622 1
a622 2
	paddr_t pa[3];
	int i;
d624 2
a625 1
	KASSERT(s <= (nitems(pa) - 1) * PAGE_SIZE);
d627 21
a647 20
	for (i = 0; i < nitems(pa); i++, va += PAGE_SIZE)
		pmap_extract(pmap_kernel(), va, &pa[i]);

	memset(&kd_avoidalias, 0, sizeof kd_avoidalias);
	kd_avoidalias.kd_prefer = pa[0];
	kd_avoidalias.kd_waitok = 1;
	rwva = (vaddr_t)km_alloc(nitems(pa) * PAGE_SIZE, &kv_any, &kp_none,
	    &kd_avoidalias);
	if (!rwva)
		panic("_rs_clearseed");

	va = rwva;
	for (i = 0; i < nitems(pa); i++, va += PAGE_SIZE)
		pmap_kenter_pa(va, pa[i], PROT_READ | PROT_WRITE);
	pmap_update(pmap_kernel());

	explicit_bzero((void *)(rwva + off), s);

	pmap_kremove(rwva, nitems(pa) * PAGE_SIZE);
	km_free((void *)rwva, nitems(pa) * PAGE_SIZE, &kv_any, &kp_none);
@


1.183
log
@openbsd.randomdata became RO in userland due to the RELRO work.  We should
also do so in the kernel, which gains us RO ssp cookie, which will prevent
spraying attacks.

The random layer was openbsd.randomdata annotating working entropy/chacha
buffers which in turn required them to be RW.  To make that work again,
so we need to copy RO seeds to RW working buffers, and later clear the
RO seed buffers afterwards using a temporary RW mapping.

help & ok kettenis, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.182 2016/07/15 19:02:30 tom Exp $	*/
d619 6
a624 2
	vaddr_t rwa;
	paddr_t pa1, pa2;
d626 2
a627 2
	pmap_extract(pmap_kernel(), va, &pa1);
	pmap_extract(pmap_kernel(), va + PAGE_SIZE, &pa2);
d630 1
a630 1
	kd_avoidalias.kd_prefer = pa1;
d632 1
a632 1
	rwa = (vaddr_t)km_alloc(2 * PAGE_SIZE, &kv_any, &kp_none,
d634 1
a634 1
	if (!rwa)
d637 3
a639 2
	pmap_kenter_pa(rwa, pa1, PROT_READ | PROT_WRITE);
	pmap_kenter_pa(rwa + PAGE_SIZE, pa2, PROT_READ | PROT_WRITE);
d642 1
a642 1
	explicit_bzero(rwa + ((char *)p - va), s);
d644 2
a645 2
	pmap_kremove(rwa, 2 * PAGE_SIZE);
	km_free((void *)rwa, 2 * PAGE_SIZE, &kv_any, &kp_none);
@


1.182
log
@Remove unused re_nbits from dev/rnd.c

"another leftover of the bean counter"

od tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.181 2016/05/23 15:48:59 deraadt Exp $	*/
d136 3
d236 2
a237 1
u_int32_t entropy_pool[POOLWORDS] __attribute__((section(".openbsd.randomdata")));
d251 1
d517 2
a518 1
static u_char rs_buf[RSBUFSZ] __attribute__((section(".openbsd.randomdata")));
d614 29
d646 7
d795 3
@


1.181
log
@remove the sysctl kern.random counters, since none of the remaining
ones are capable of giving valuable works vs does-not-work evidence.
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.180 2016/05/17 21:05:49 tedu Exp $	*/
a224 1
	u_int re_nbits;
a373 1
	rep->re_nbits = nbits;
a441 1
	u_int nbits;
a450 1
		nbits = rep->re_nbits;
@


1.180
log
@Change the random event buffer from a queue to an endless ring. This way
we don't drop any events when the queue is full. They are instead mixed
into previous events.
The mixing function selected is addition instead of xor to reduce the
possibility that new values effectively erase existing ones.
Convert some types to u_int to ensure defined overflow.
ok deraadt djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.179 2016/02/19 19:15:59 stefan Exp $	*/
a232 1
struct rndstats rndstats;
a378 5
	rndstats.rnd_enqs++;
	rndstats.rnd_ed[nbits]++;
	rndstats.rnd_sc[state]++;
	rndstats.rnd_sb[state] += nbits;

a450 1
	rndstats.rnd_deqs++;
a459 1
		rndstats.rnd_total += nbits;
a592 1
	rndstats.arc4_nstirs++;
a674 1
	rndstats.arc4_reads += sizeof(ret);
a686 1
	rndstats.arc4_reads += n;
@


1.179
log
@Right shift by an amount larger than width of type is undefined behavior.
Pointed out by Martin Natano, slightly tweaked by me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.178 2016/01/08 07:54:02 stefan Exp $	*/
d230 1
a230 1
int rnd_event_idx;
d260 3
d270 4
a273 2
	if (rnd_event_idx == QEVLEN)
		return NULL;
d275 1
a275 1
	return &rnd_event_space[rnd_event_idx++];
d278 1
a278 1
static __inline int
a291 2
 * On the i386, this is assumed to be at most 16 bits, and the high bits
 * are used for a high-resolution timer.
d294 1
a294 1
enqueue_randomness(int state, int val)
d303 1
a303 1
	if (state < 0 || state >= RND_SRC_NUM)
a367 8
		/*
		 * the logic is to drop low-entropy entries,
		 * in hope for dequeuing to be more randomfull
		 */
		if (rnd_qlen() > QEVSLOW && nbits < QEVSBITS) {
			rndstats.rnd_drople++;
			goto done;
		}
d373 1
a373 4
	if ((rep = rnd_put()) == NULL) {
		rndstats.rnd_drops++;
		goto done;
	}
d377 2
a378 2
	rep->re_time = ts.tv_nsec ^ (ts.tv_sec << 20);
	rep->re_val = val;
d388 1
a388 1
done:
@


1.178
log
@Use uiomove() instead of uiomovei().
Diff from Martin Natano, thanks!

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.177 2015/12/28 05:21:53 tedu Exp $	*/
d424 1
a424 1
		    (*buf >> (32 - entropy_input_rotate));
@


1.177
log
@use ulmin when looking at uio_resid to prevent wrapping around.
from Martin Natano (and also reported by Stefan Kempf)
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.176 2015/10/27 11:13:06 mikeb Exp $	*/
d843 1
a843 1
		int	n = ulmin(POOLBYTES, uio->uio_resid);
d852 1
a852 1
		ret = uiomovei(buf, n, uio);
d875 1
a875 1
		int	n = ulmin(POOLBYTES, uio->uio_resid);
d877 1
a877 1
		ret = uiomovei(buf, n, uio);
@


1.176
log
@Sync chacha_ivsetup to the version in ssh so that we could
specify custom counter value when setting up Chacha context.

ok reyk djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.175 2015/05/25 03:07:07 deraadt Exp $	*/
d843 1
a843 1
		int	n = min(POOLBYTES, uio->uio_resid);
d875 1
a875 1
		int	n = min(POOLBYTES, uio->uio_resid);
@


1.175
log
@missing word in comment; Kyle Milz
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.174 2015/05/04 09:38:05 jsg Exp $	*/
d571 2
a572 2
	chacha_keysetup(&rs, buf, KEYSZ * 8, 0);
	chacha_ivsetup(&rs, buf + KEYSZ);
d836 2
a837 2
		chacha_keysetup(&lctx, lbuf, KEYSZ * 8, 0);
		chacha_ivsetup(&lctx, lbuf + KEYSZ);
@


1.174
log
@use the size of the buffer not the pointer in resume_randomness()
ok djm@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.173 2015/03/14 03:38:46 jsg Exp $	*/
d63 1
a63 1
 * and it very fast because the interrupt-time event is only to add
@


1.173
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.172 2015/02/17 22:34:59 tedu Exp $	*/
d556 1
a556 1
		_rs_seed(buf, sizeof(buf));
@


1.172
log
@the rnd event ringbuf calculations aren't correct, which may result in
failure to fire the collection timeout. discovered by markus.
the order of events here doesn't actually matter, so switch to a simple
stack, which is easier to understand. ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.171 2015/02/10 21:56:09 miod Exp $	*/
a114 1
#include <sys/conf.h>
@


1.171
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.170 2015/02/07 01:19:40 deraadt Exp $	*/
d230 2
a231 2
struct rand_event *rnd_event_head = rnd_event_space;
struct rand_event *rnd_event_tail = rnd_event_space;
d259 1
a259 3
	struct rand_event *p = rnd_event_tail;

	if (p == rnd_event_head)
d262 1
a262 6
	if (p + 1 >= &rnd_event_space[QEVLEN])
		rnd_event_tail = rnd_event_space;
	else
		rnd_event_tail++;

	return p;
d268 1
a268 6
	struct rand_event *p = rnd_event_head + 1;

	if (p >= &rnd_event_space[QEVLEN])
		p = rnd_event_space;

	if (p == rnd_event_tail)
d271 1
a271 1
	return rnd_event_head = p;
d277 1
a277 2
	int len = rnd_event_head - rnd_event_tail;
	return (len < 0)? -len : len;
@


1.170
log
@New framework that allows hibernate to pass in entropy from it's fresh
boot.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.169 2015/01/27 03:17:35 dlg Exp $	*/
d866 1
a866 1
		ret = uiomove(buf, n, uio);
d891 1
a891 1
		ret = uiomove(buf, n, uio);
@


1.169
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.168 2014/12/23 20:32:05 tedu Exp $	*/
d249 2
d565 1
a565 1
resume_randomness(void)
d569 2
@


1.168
log
@not necessary to zero hash context; the hash final functions all do that.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.167 2014/12/23 20:29:23 tedu Exp $	*/
d534 3
d539 1
a539 4
struct task arc4_task;

void arc4_reinit(void *v);		/* timeout to start reinit */
void arc4_init(void *, void *);		/* actually do the reinit */
d757 1
a757 1
arc4_init(void *v, void *w)
d806 1
a806 2
	arc4_init(NULL, NULL);
	task_set(&arc4_task, arc4_init, NULL, NULL);
d899 1
a899 1
		arc4_init(NULL, NULL);
@


1.167
log
@tmp is a bad name for a shactx
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.166 2014/12/19 04:00:00 tedu Exp $	*/
a528 1
	explicit_bzero(&shactx, sizeof(shactx));
@


1.166
log
@rename buffer to digest, more clear. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.165 2014/12/19 02:29:40 tedu Exp $	*/
d501 1
a501 1
	SHA2_CTX tmp;
d516 3
a518 3
	SHA512Init(&tmp);
	SHA512Update(&tmp, (u_int8_t *)extract_pool, sizeof(extract_pool));
	SHA512Final(digest, &tmp);
d529 1
a529 1
	explicit_bzero(&tmp, sizeof(tmp));
@


1.165
log
@sha512 produces enough output, we can simplify extraction by not looping.
ok deraadt djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.164 2014/12/18 16:27:30 deraadt Exp $	*/
d500 1
a500 1
	u_char buffer[SHA512_DIGEST_LENGTH];
d513 1
a513 2
	memcpy(extract_pool, entropy_pool,
	    sizeof(extract_pool));
d518 1
a518 1
	SHA512Final(buffer, &tmp);
d521 1
a521 1
	memcpy(buf, buffer, EBUFSIZE);
d530 1
a530 1
	explicit_bzero(buffer, sizeof(buffer));
@


1.164
log
@Create a suspend/resume infrastructure for the RNG.  At suspend time,
process all queued entropy and create a brand new pool to prevent
backtracking upon resume.  At resume time, process the entropy queue
(since other resume code paths which run earlier can enqueue entropy)
and force all higher to reseed.
ok reyk djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.163 2014/10/24 20:02:07 tedu Exp $	*/
d218 6
d242 2
a243 1
void	extract_entropy(u_int8_t *, int);
d497 1
a497 1
extract_entropy(u_int8_t *buf, int nbytes)
a501 1
	u_int i;
d503 12
a514 1
	add_timer_randomness(nbytes);
d516 4
a519 2
	while (nbytes) {
		i = MIN(nbytes, sizeof(buffer));
d521 2
a522 7
		/*
		 * INTENTIONALLY not protected by entropylock.  Races
		 * during bcopy() result in acceptable input data; races
		 * during SHA512Update() would create nasty data dependencies.
		 */
		bcopy(entropy_pool, extract_pool,
		    sizeof(extract_pool));
d524 3
a526 14
		/* Hash the pool to get the output */
		SHA512Init(&tmp);
		SHA512Update(&tmp, (u_int8_t *)extract_pool, sizeof(extract_pool));
		SHA512Final(buffer, &tmp);

		/* Copy data to destination buffer */
		bcopy(buffer, buf, i);
		nbytes -= i;
		buf += i;

		/* Modify pool so next hash will produce different results */
		add_timer_randomness(nbytes);
		dequeue_randomness(NULL);
	}
a542 4
#define KEYSZ	32
#define IVSZ	8
#define BLOCKSZ	64
#define RSBUFSZ	(16*BLOCKSZ)
d603 1
a603 1
	u_int8_t buf[KEYSZ + IVSZ], *p;
d612 1
a612 1
	extract_entropy((u_int8_t *)buf, sizeof buf);
@


1.163
log
@obvious sizes for free
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.162 2014/10/20 00:48:57 tedu Exp $	*/
d550 27
@


1.162
log
@typo; deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.161 2014/10/20 00:40:19 tedu Exp $	*/
d846 1
a846 1
	free(buf, M_TEMP, 0);
d879 1
a879 1
	free(buf, M_TEMP, 0);
@


1.161
log
@use SHA512 to hash entropy instead of MD5
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.160 2014/09/15 22:00:24 tedu Exp $	*/
d109 1
a109 1
 * Using a RC4 stream cipher as 2nd stage after the MD5 (now SH512) output
@


1.160
log
@update comments to reflect chacha20. from Max Fillinger
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.159 2014/07/17 13:38:22 tedu Exp $	*/
d67 1
a67 1
 * the entropy pool and running a MD5 hash. The MD5 hash avoids
d69 1
a69 1
 * possible to analyze MD5 in some clever way, as long as the amount
d76 2
a77 2
 * If this estimate goes to zero, the MD5 hash will continue to generate
 * output since there is no true risk because the MD5 output is not
d109 1
a109 1
 * Using a RC4 stream cipher as 2nd stage after the MD5 output
d130 1
a130 1
#include <crypto/md5.h>
d486 1
a486 1
 * Grabs a chunk from the entropy_pool[] and slams it through MD5 when
d493 2
a494 2
	u_char buffer[MD5_DIGEST_LENGTH];
	MD5_CTX tmp;
d505 1
a505 1
		 * during MD5Update() would create nasty data dependencies.
d511 3
a513 3
		MD5Init(&tmp);
		MD5Update(&tmp, (u_int8_t *)extract_pool, sizeof(extract_pool));
		MD5Final(buffer, &tmp);
d581 1
a581 1
	 * Use MD5 PRNG data and a system timespec; early in the boot
@


1.159
log
@zero entropy buf
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.158 2014/07/12 18:48:51 tedu Exp $	*/
d79 5
a83 6
 * RC4 stream cipher.  Attempts are made to follow best practice
 * regarding this stream cipher - the first chunk of output is discarded
 * and the cipher is re-seeded from time to time.  This design provides
 * very high amounts of output data from a potentially small entropy
 * base, at high enough speeds to encourage use of random numbers in
 * nearly any situation.
d85 1
a85 1
 * The output of this single RC4 engine is then shared amongst many
d88 3
a90 1
 * for the set of /dev/random nodes, and the sysctl kern.arandom.
d670 1
a670 1
/* Return one word of randomness from an RC4 generator */
d684 1
a684 1
 * Fill a buffer of arbitrary length with RC4-derived randomness.
@


1.158
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.157 2014/06/14 18:01:42 deraadt Exp $	*/
d949 1
@


1.157
log
@Change return value of getentropy() to int 0 for success.  Maximum
buffersize is enforced strictly, this supplies sufficient entropy
payload to act as seed material.  Discourage general use of this
API, but lock down this function name as the go-to for userland
PRNG seeding.  Improve documentation.
ok miod matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.156 2014/06/13 08:26:09 deraadt Exp $	*/
d845 1
a845 1
	free(buf, M_TEMP);
d878 1
a878 1
	free(buf, M_TEMP);
@


1.156
log
@Add new getentropy() system call.  Code and pressure from matthew.
I accepted that he's right (again) to seperate this out from heavy
sysctl API and this will simply a variety of things.  Functionname
is not used by anyone in the ports tree, so we guess we can use it.
Shocking that no application has a function called this.
ok matthew & others who pushed him to start this early on
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.155 2014/02/05 05:54:58 tedu Exp $	*/
a942 1
	size_t nbyte;
d944 4
a947 6
	nbyte = SCARG(uap, nbyte);
	if (nbyte > sizeof(buf))
		nbyte = sizeof(buf);

	arc4random_buf(buf, nbyte);
	if ((error = copyout(buf, SCARG(uap, buf), nbyte)) != 0)
d949 1
a949 2

	retval[0] = nbyte;
@


1.155
log
@tiny style adjustments
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.154 2014/01/22 03:24:42 jsing Exp $	*/
d126 2
d932 23
@


1.154
log
@Emit a warning if no entropy was supplied by the boot loader.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.153 2014/01/19 23:52:54 deraadt Exp $	*/
d808 1
a808 1
	u_char lbuf[KEYSZ+IVSZ];
d831 1
a831 1
			bzero(buf, n);
d836 1
a836 1
		ret = uiomove((caddr_t)buf, n, uio);
d858 1
a858 1
	while (!ret && uio->uio_resid > 0) {
d862 1
a862 1
		if (ret)
d867 1
a867 1
		if (ret == 0 && uio->uio_resid > 0)
@


1.153
log
@Refactor rnd startup so arc4random/arc4random_buf can create a chacha state
on first call, very early on, from boot-supplied entropy, then feed from
that.  Later when we have more subsystems ready, the main() can properly
initialize the entropy-driven model.  Lots of discussion with mikeb.
ok kettenis markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.152 2014/01/19 00:39:40 deraadt Exp $	*/
d753 7
@


1.152
log
@With the earlier initialization of the random subsystem, random_hostseed()
is no longer providing significant value.  The random subsystem is in
pretty good state, and moments later userland will feed the dmesg.
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.151 2014/01/19 00:24:01 deraadt Exp $	*/
d543 2
a544 1
static u_char rs_buf[RSBUFSZ];	/* keystream blocks */
d561 1
a561 8
	if (!rs_initialized) {
		rs_initialized = 1;
		rnd_states[RND_SRC_TIMER].dont_count_entropy = 1;
		rnd_states[RND_SRC_TRUE].dont_count_entropy = 1;
		rnd_states[RND_SRC_TRUE].max_entropy = 1;
		_rs_init(buf, n);
	} else
		_rs_rekey(buf, n);
d602 5
a606 1
	if (rs_count <= len || !rs_initialized)
a745 15
void
random_init(void)
{
	int off;

	/*
	 * MI code did not initialize us with a seed, so we are
	 * hitting the fall-back from kernel main().   Do the best
	 * we can... We assume there are at 8192 bytes mapped after
	 * version, because we want to pull some "code" in as well.
	 */
	for (off = 0; off < 8192 - KEYSZ - IVSZ; off += KEYSZ + IVSZ)
		_rs_seed((u_int8_t *)version + off, KEYSZ + IVSZ);
}

d753 13
a765 4
	/*
	 * At this point, the message buffer is mapped, and may contain
	 * some historical information still.
	 */
d770 1
@


1.151
log
@In random_start() we can assume the msg buffer is mapped, all systems do
it at startup, or in cpu_startup().  Improve comments to explain what is
happening here.
ok kettenis jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.150 2013/12/28 02:58:17 deraadt Exp $	*/
a783 10
}

void
random_hostseed(void)
{
	if (msgbufp == NULL || msgbufp->msg_magic != MSG_MAGIC)
		return;
	add_entropy_words((u_int32_t *)msgbufp->msg_bufc,
	    msgbufp->msg_bufs / sizeof(u_int32_t));
	arc4_init(NULL, NULL);
@


1.150
log
@Put the entropy_pool[] into the ELF .openbsd.randomdata segment.
Also allow random_init() to be called later, by moving a few
entropy control initializions into the lower-level _rs_seed() layer.
tested by jsing, phessler and a few others
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.149 2013/12/22 16:06:12 deraadt Exp $	*/
d763 4
d771 2
a772 4
	 * On a cold start the message buffer does not contain any
	 * unique information yet, just the copyright message and the
	 * kernel version string.  Unique information like MAC adresses
	 * will be added during autoconf.
d774 1
a774 1
	if (msgbufp && msgbufp->msg_magic == MSG_MAGIC)
@


1.149
log
@spacing; Loganaden Velvindron
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.148 2013/12/11 19:34:11 guenther Exp $	*/
d227 1
a227 1
u_int32_t entropy_pool[POOLWORDS];
d562 3
a752 4
	rnd_states[RND_SRC_TIMER].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].max_entropy = 1;

d754 4
a757 3
	 * Load some code as input data until we are more alive.
	 * NOTE: We assume there are at 8192 bytes mapped after version,
	 * because we want to pull some "code" in as well.
@


1.148
log
@Revert change to sha256: ramdisks don't build with this and the obvious
conf/files change isn't enough due to size limits
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.145 2013/11/02 19:37:25 markus Exp $	*/
d615 1
a615 1
	memset(rs_buf, 0,RSBUFSZ);
@


1.147
log
@update a few RC4 references to ChaCha. thanks sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.146 2013/12/11 04:45:54 tedu Exp $	*/
d67 1
a67 1
 * the entropy pool and running a SHA256 hash. The SHA256 hash avoids
d69 1
a69 1
 * possible to analyze SHA256 in some clever way, as long as the amount
d76 2
a77 2
 * If this estimate goes to zero, the SHA256 hash will continue to generate
 * output since there is no true risk because the SHA256 output is not
d79 1
a79 1
 * Chacha stream cipher.  Attempts are made to follow best practice
d86 1
a86 1
 * The output of this single Chacha engine is then shared amongst many
d108 2
a109 2
 * Using a RC4 (now ChaCha) stream cipher as 2nd stage after the MD5
 * (now SHA256) output is the result of work by David Mazieres.
d127 1
a127 1
#include <crypto/sha2.h>
d483 1
a483 1
 * Grabs a chunk from the entropy_pool[] and slams it through SHA2 when
d489 3
a491 3
	static u_int8_t extract_pool[POOLBYTES];
	u_char buffer[SHA256_DIGEST_LENGTH];
	SHA2_CTX tmp;
d502 1
a502 1
		 * during SHA256Update() would create nasty data dependencies.
d504 2
a505 1
		bcopy(entropy_pool, extract_pool, sizeof(extract_pool));
d508 3
a510 3
		SHA256Init(&tmp);
		SHA256Update(&tmp, extract_pool, sizeof(extract_pool));
		SHA256Final(buffer, &tmp);
d581 1
a581 1
	 * Use SHA256 PRNG data and a system timespec; early in the boot
d666 1
a666 1
/* Return one word of random data */
d679 3
a681 1
/* Fill a buffer of arbitrary length with random data */
@


1.146
log
@md5 smells bad. switch to sha256. ok deraadt matthew mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.145 2013/11/02 19:37:25 markus Exp $	*/
d79 1
a79 1
 * RC4 stream cipher.  Attempts are made to follow best practice
d86 1
a86 1
 * The output of this single RC4 engine is then shared amongst many
d108 2
a109 2
 * Using a RC4 stream cipher as 2nd stage after the MD5 (now SHA256) output
 * is the result of work by David Mazieres.
d665 1
a665 1
/* Return one word of randomness from an RC4 generator */
d678 1
a678 3
/*
 * Fill a buffer of arbitrary length with RC4-derived randomness.
 */
@


1.145
log
@replace rc4 with ChaCha20 here, too; ok djm, tedu, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.144 2013/10/30 02:13:16 dlg Exp $	*/
d67 1
a67 1
 * the entropy pool and running a MD5 hash. The MD5 hash avoids
d69 1
a69 1
 * possible to analyze MD5 in some clever way, as long as the amount
d76 2
a77 2
 * If this estimate goes to zero, the MD5 hash will continue to generate
 * output since there is no true risk because the MD5 output is not
d108 1
a108 1
 * Using a RC4 stream cipher as 2nd stage after the MD5 output
d127 1
a127 1
#include <crypto/md5.h>
d483 1
a483 1
 * Grabs a chunk from the entropy_pool[] and slams it through MD5 when
d489 3
a491 3
	static u_int32_t extract_pool[POOLWORDS];
	u_char buffer[MD5_DIGEST_LENGTH];
	MD5_CTX tmp;
d502 1
a502 1
		 * during MD5Update() would create nasty data dependencies.
d504 1
a504 2
		bcopy(entropy_pool, extract_pool,
		    sizeof(extract_pool));
d507 3
a509 3
		MD5Init(&tmp);
		MD5Update(&tmp, (u_int8_t *)extract_pool, sizeof(extract_pool));
		MD5Final(buffer, &tmp);
d580 1
a580 1
	 * Use MD5 PRNG data and a system timespec; early in the boot
@


1.144
log
@replace workq_add_task with the task api.

this guarantees the reliability of the arc4_reinit task being run by not
relying on a pool to give us memory in an interrupt context.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.143 2013/07/09 08:57:24 blambert Exp $	*/
d7 1
d128 3
a130 1
#include <crypto/arc4.h>
d528 1
a528 22
/*
 * Bytes of key material for each rc4 instance.
 */
#define	ARC4_KEY_BYTES		64

/*
 * Throw away a multiple of the first N words of output, as suggested
 * in the paper "Weaknesses in the Key Scheduling Algorithm of RC4"
 * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)  If the start
 * of a new RC stream is an event that a consumer could spot, we drop
 * the strictly recommended amount (ceil(n/log e) = 6).  If consumers
 * only see random sub-streams, we cheat and do less computation.
 */
#define	ARC4_STATE		256
#define	ARC4_DISCARD_SAFE	6
#define	ARC4_DISCARD_CHEAP	4

/*
 * Start with an unstable state so that rc4_getbytes() can
 * operate (poorly) before rc4_keysetup().
 */
struct rc4_ctx arc4random_state = { 0, 0, { 1, 2, 3, 4, 5, 6 } };
d537 129
d673 1
a673 1
	rc4_getbytes(&arc4random_state, (u_char *)&ret, sizeof(ret));
d686 1
a686 1
	rc4_getbytes(&arc4random_state, (u_char *)buf, n);
d731 1
a731 34
	struct rc4_ctx new_ctx;
	struct timespec ts;
	u_int8_t buf[ARC4_KEY_BYTES], *p;
	int i;

	/*
	 * Use MD5 PRNG data and a system timespec; early in the boot
	 * process this is the best we can do -- some architectures do
	 * not collect entropy very well during this time, but may have
	 * clock information which is better than nothing.
	 */
	extract_entropy((u_int8_t *)buf, sizeof buf);
	if (timeout_initialized(&rnd_timeout))
		nanotime(&ts);
	for (p = (u_int8_t *)&ts, i = 0; i < sizeof(ts); i++)
		buf[i] ^= p[i];

	/* Carry over some state from the previous PRNG instance */
	mtx_enter(&rndlock);
	if (rndstats.arc4_nstirs > 0)
		rc4_crypt(&arc4random_state, buf, buf, sizeof(buf));
	mtx_leave(&rndlock);

	rc4_keysetup(&new_ctx, buf, sizeof(buf));
	rc4_skip(&new_ctx, ARC4_STATE * ARC4_DISCARD_CHEAP);

	mtx_enter(&rndlock);
	bcopy(&new_ctx, &arc4random_state, sizeof(new_ctx));
	rndstats.rnd_used += sizeof(buf) * 8;
	rndstats.arc4_nstirs++;
	mtx_leave(&rndlock);

	explicit_bzero(buf, sizeof(buf));
	explicit_bzero(&new_ctx, sizeof(new_ctx));
d748 2
d759 2
a760 1
	rc4_keysetup(&arc4random_state, (u_int8_t *)&version, 8192);
d807 2
a808 2
 * Maximum number of bytes to serve directly from the main arc4random
 * pool. Larger requests are served from a discrete arc4 instance keyed
d816 2
a817 2
	u_char lbuf[ARC4_KEY_BYTES];
	struct rc4_ctx lctx;
d828 2
a829 2
		rc4_keysetup(&lctx, lbuf, sizeof(lbuf));
		rc4_skip(&lctx, ARC4_STATE * ARC4_DISCARD_SAFE);
d837 6
a842 3
		if (myctx)
			rc4_getbytes(&lctx, buf, n);
		else
@


1.143
log
@Fix a pair of aesthetic nits in dev/rnd.c:

fix language (feed -> fed) in a comment
16 -> MD5_DIGEST_LENGTH for legibility

No change to resulting object file.

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.142 2013/03/25 14:58:28 markus Exp $	*/
d123 1
a123 1
#include <sys/workq.h>
d550 1
d662 1
a662 1
	workq_add_task(NULL, 0, arc4_init, NULL, NULL);
d697 1
@


1.142
log
@reseed the random pool with 'dmesg' when more devices are attached
from hshoexer@@; ok tedu@@, "looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.141 2012/06/24 18:25:12 matthew Exp $	*/
d408 1
a408 1
 * is consistently feed small numbers (such as keyboard scan codes)
d487 1
a487 1
	u_char buffer[16];
@


1.141
log
@Change arc4random_uniform() to calculate ``2**32 % upper_bound'' as
``-upper_bound % upper_bound''.  Simplifies the code and makes it the
same on both ILP32 and LP64 architectures, and also slightly faster on
LP64 architectures by using a 32-bit remainder instead of a 64-bit
remainder.

Pointed out by Jorden Verwer on tech@@
ok deraadt; no objections from djm or otto
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.140 2011/07/06 14:49:30 nicm Exp $	*/
d393 1
a393 1
	    timeout_pending(&rnd_timeout))
d684 6
d699 10
@


1.140
log
@Add a new kqfilter for random which returns ARC4_MAIN_MAX_BYTES for read
and POOLBYTES for write.

looks right to deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.139 2011/01/11 06:15:03 djm Exp $	*/
d597 2
a598 11
#if (ULONG_MAX > 0xffffffffUL)
	min = 0x100000000UL % upper_bound;
#else
	/* Calculate (2**32 % upper_bound) avoiding 64-bit math */
	if (upper_bound > 0x80000000)
		min = 1 + ~upper_bound;		/* 2**32 - upper_bound */
	else {
		/* (2**32 - x) % x == 2**32 % x when x <= 2**31 */
		min = ((0xffffffff - upper_bound) + 1) % upper_bound;
	}
#endif
@


1.139
log
@bring back carrying over state from the previous RC4 instance when
rekeying; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.138 2011/01/11 06:08:28 tedu Exp $	*/
d115 1
d228 12
a239 3
void dequeue_randomness(void *);
void add_entropy_words(const u_int32_t *, u_int);
void extract_entropy(u_int8_t *buf, int nbytes);
d793 36
@


1.138
log
@all the bzeros in rnd are important, use explicit_bzero
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.137 2011/01/10 06:08:38 deraadt Exp $	*/
d634 6
@


1.137
log
@update the documentation regarding the *4 vs *6 decision for early RC4
stream discard.  this continues to be under discussion... at least this
moves the large-buffer transactions to using a *6 discard
discussed at length with djm and kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.134 2011/01/10 03:23:30 deraadt Exp $	*/
d510 3
a512 3
	bzero(extract_pool, sizeof(extract_pool));
	bzero(&tmp, sizeof(tmp));
	bzero(buffer, sizeof(buffer));
d644 2
a645 2
	bzero(buf, sizeof(buf));
	bzero(&new_ctx, sizeof(new_ctx));
d724 1
a724 1
		bzero(lbuf, sizeof(lbuf));
d740 2
a741 2
		bzero(&lctx, sizeof(lctx));
	bzero(buf, POOLBYTES);
d774 1
a774 1
	bzero(buf, POOLBYTES);
@


1.136
log
@move comment block regarding ARC4_MAIN_MAX_BYTES
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.135 2011/01/10 05:40:06 tedu Exp $	*/
d521 6
a526 3
 * Throw away the first N words of output, as suggested in the
 * paper "Weaknesses in the Key Scheduling Algorithm of RC4"
 * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)
d529 2
a530 1
#define	ARC4_PARANOIA		4
d636 1
a636 1
	rc4_skip(&new_ctx, ARC4_STATE * ARC4_PARANOIA);
d723 1
a723 1
		rc4_skip(&lctx, ARC4_STATE * ARC4_PARANOIA);
@


1.135
log
@randomread does its own rekeying now, so we don't need the large buf function.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.134 2011/01/10 03:23:30 deraadt Exp $	*/
a520 7
 * Maximum number of bytes to serve directly from the main arc4random
 * pool. Larger requests are served from discrete arc4 instances keyed
 * from the main pool.  Must be larger than ARC4_KEY_BYTES.
 */
#define ARC4_MAIN_MAX_BYTES	2048

/*
d695 7
@


1.134
log
@OK, this is getting silly, but we might as well zero the entropy buffer
supplied by root (it can be large enough to overwhelm the entropy buffer,
and we are doing a re-key almost immediately)
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.133 2011/01/10 02:44:18 deraadt Exp $	*/
a545 1
void arc4random_buf_large(void *, size_t);
a560 19
 * Return a "large" buffer of randomness using an independantly-keyed RC4
 * generator.
 */
void
arc4random_buf_large(void *buf, size_t n)
{
	u_char lbuf[ARC4_KEY_BYTES];
	struct rc4_ctx lctx;

	arc4random_buf(lbuf, sizeof(lbuf));

	rc4_keysetup(&lctx, lbuf, sizeof(lbuf));
	rc4_skip(&lctx, ARC4_STATE * ARC4_PARANOIA);
	rc4_getbytes(&lctx, (u_char *)buf, n);
	bzero(lbuf, sizeof(lbuf));
	bzero(&lctx, sizeof(lctx));
}

/*
a565 6
	/* Satisfy large requests via an independent ARC4 instance */
	if (n > ARC4_MAIN_MAX_BYTES) {
		arc4random_buf_large(buf, n);
		return;
	}

@


1.133
log
@zero another intermediate key storage area
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.132 2011/01/09 22:40:51 deraadt Exp $	*/
d796 1
@


1.132
log
@be more careful with nanotime() calls in early entropy storage, since
at least sparc may not have the clock mapped (found by miod).
while here, protect some more timeout_*() calls with timeout_initialized()
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.131 2011/01/08 19:45:07 deraadt Exp $	*/
d510 1
@


1.131
log
@split randomattach into random_init() and random_start(), so that we
can make attempts to load 'entropy' into the RC4.
ok miod ariane
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.130 2011/01/08 02:23:02 deraadt Exp $	*/
d293 2
a294 1
	nanotime(&ts);
d451 2
a452 1
	timeout_del(&rnd_timeout);
d658 2
a659 1
	nanotime(&ts);
a708 1
	timeout_set(&rnd_timeout, dequeue_randomness, NULL);
d710 1
a710 1

a711 1
	arc4_init(NULL, NULL);
d713 1
@


1.130
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.129 2011/01/08 02:22:43 deraadt Exp $	*/
d532 6
a538 1
struct rc4_ctx arc4random_state;
d685 1
a685 1
randomattach(void)
d691 11
@


1.129
log
@switch back from PAGE_SIZE for the sake of sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.128 2011/01/08 00:55:30 tedu Exp $	*/
d64 1
a64 1
 * 
d84 1
a84 1
 * 
d106 1
a106 1
 * 
d176 1
a176 1
 * 
d716 1
a716 1
	u_char	 	*buf;
d729 1
a729 1
	}	
@


1.128
log
@destatic.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.127 2011/01/07 23:13:48 tedu Exp $	*/
d722 1
a722 1
	buf = malloc(2 * PAGE_SIZE, M_TEMP, M_WAITOK);
d732 1
a732 1
		int	n = min(2 * PAGE_SIZE, uio->uio_resid);
d744 1
a744 1
	bzero(buf, 2 * PAGE_SIZE);
@


1.127
log
@some minor improvements to rnd.
1.  only support pool words == 2048.
2.  define the amount of key we use.
3.  define the amount of rc4 we skip.
4.  use arc4random_buf instead of reimplementing inline.
5.  bzero some more "secrets".
ok deraadt djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.126 2011/01/07 04:56:51 deraadt Exp $	*/
d227 3
a229 3
static void dequeue_randomness(void *);
static void add_entropy_words(const u_int32_t *, u_int);
static void extract_entropy(u_int8_t *buf, int nbytes);
d401 1
a401 1
static void
d441 1
a441 1
static void
d471 1
a471 1
static void
d536 3
a538 2
static void arc4_reinit(void *v);		/* timeout to start reinit */
static void arc4_init(void *, void *);		/* actually do the reinit */
d557 1
a557 1
static void
d636 1
a636 1
static void
d671 1
a671 1
static void
@


1.126
log
@substantial rewrite.  put a very thin mutex at the entropy-collection
side so that entropy events can come in from any kernel context.  place
a 2nd very thin mutex at the call-down path as well, so that any context can
request random data.  in the middle, meet with a bcopy that has no mutex,
but copying unlocked data is actually a benefit.
move the pool->MD5->RC4init sequence into a workq driven from a timeout,
so that we can do all the heavy work without any mutex held or IPL; only
grab the 2nd mutex to swap to a new RC4 state. (this workq design from tedu)
ok dlg tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.125 2011/01/07 04:38:00 deraadt Exp $	*/
d184 1
a184 1
#define POOLBITS	(POOLWORDS*32)
a186 1
#if POOLWORDS == 2048
a190 33
#elif POOLWORDS == 1024	/* also (819, 616, 410, 207, 2) */
#define	POOL_TAP1	817
#define	POOL_TAP2	615
#define	POOL_TAP3	412
#define	POOL_TAP4	204
#elif POOLWORDS == 512	/* also (409,307,206,102,2), (409,309,205,103,2) */
#define	POOL_TAP1	411
#define	POOL_TAP2	308
#define	POOL_TAP3	208
#define	POOL_TAP4	104
#elif POOLWORDS == 256
#define	POOL_TAP1	205
#define	POOL_TAP2	155
#define	POOL_TAP3	101
#define	POOL_TAP4	52
#elif POOLWORDS == 128	/* also (103, 78, 51, 27, 2) */
#define	POOL_TAP1	103
#define	POOL_TAP2	76
#define	POOL_TAP3	51
#define	POOL_TAP4	25
#elif POOLWORDS == 64
#define	POOL_TAP1	52
#define	POOL_TAP2	39
#define	POOL_TAP3	26
#define	POOL_TAP4	14
#elif POOLWORDS == 32
#define	POOL_TAP1	26
#define	POOL_TAP2	20
#define	POOL_TAP3	14
#define	POOL_TAP4	7
#else
#error No primitive polynomial available for chosen POOLWORDS
#endif
d513 5
d520 1
a520 1
 * from the main pool.
d525 3
a527 2
 * Key size (in bytes) for arc4 instances setup to serve requests larger
 * than ARC4_MAIN_MAX_BYTES.
d529 2
a530 1
#define ARC4_SUB_KEY_BYTES	(256 / 8)
d559 1
a559 1
	u_char lbuf[ARC4_SUB_KEY_BYTES];
d562 1
a562 4
	mtx_enter(&rndlock);
	rc4_getbytes(&arc4random_state, lbuf, sizeof(lbuf));
	rndstats.arc4_reads += n;
	mtx_leave(&rndlock);
d565 1
a565 1
	rc4_skip(&lctx, 256 * 4);
d640 1
a640 1
	u_int8_t buf[64], *p;
d655 1
a655 6
	/*
	 * Throw away the first N words of output, as suggested in the
	 * paper "Weaknesses in the Key Scheduling Algorithm of RC4"
	 * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)
	 */
	rc4_skip(&new_ctx, 256 * 4);
d662 3
d712 1
a712 1
	u_char lbuf[ARC4_SUB_KEY_BYTES];
d723 1
a723 5
		mtx_enter(&rndlock);
		rc4_getbytes(&arc4random_state, lbuf, sizeof(lbuf));
		rndstats.arc4_reads += sizeof(lbuf);
		mtx_leave(&rndlock);

d725 2
a726 1
		rc4_skip(&lctx, 256 * 4);
d741 3
a743 1

@


1.125
log
@since randomwrite() also has no blocking operations at all, we need to
do a yield, otherwise an accidental cat by root into /dev/random kind
of makes your machine hurt a lot.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.124 2011/01/06 22:49:10 deraadt Exp $	*/
d4 2
a6 1
 * Copyright (c) 2008 Damien Miller.
a42 7
 * This routine gathers environmental noise from device drivers, etc.,
 * and returns good random numbers, suitable for cryptographic or
 * other use.
 *
 * Theory of operation
 * ===================
 *
d58 14
a71 17
 * added to the "entropy pool", which is mixed using a CRC-like function.
 * This is not cryptographically strong, but it is adequate assuming
 * the randomness is not chosen maliciously, and it is fast enough that
 * the overhead of doing it on every interrupt is very reasonable.
 * As random bytes are mixed into the entropy pool, the routines keep
 * an *estimate* of how many bits of randomness have been stored into
 * the random number generator's internal state.
 *
 * When random bytes are desired, they are obtained by taking the MD5
 * hash of the content of the entropy pool.  The MD5 hash avoids
 * exposing the internal state of the entropy pool.  It is believed to
 * be computationally infeasible to derive any useful information
 * about the input of MD5 from its output.  Even if it is possible to
 * analyze MD5 in some clever way, as long as the amount of data
 * returned from the generator is less than the inherent entropy in
 * the pool, the output data is totally unpredictable.  For this
 * reason, the routine decreases its internal estimate of how many
a89 43
 * Exported interfaces ---- input
 * ==============================
 *
 * The current exported interfaces for gathering environmental noise
 * from the devices are:
 *
 *	void add_true_randomness(int data);
 *	void add_timer_randomness(int data);
 *	void add_mouse_randomness(int mouse_data);
 *	void add_net_randomness(int isr);
 *	void add_tty_randomness(int c);
 *	void add_disk_randomness(int n);
 *	void add_audio_randomness(int n);
 *	void add_video_randomness(int n);
 *
 * add_true_randomness() uses true random number generators present
 * on some cryptographic and system chipsets.  Entropy accounting
 * is not quitable, no timing is done, supplied 32 bits of pure entropy
 * are hashed into the pool plain and blindly, increasing the counter.
 *
 * add_timer_randomness() uses the random driver itselves timing,
 * measuring extract_entropy() and rndioctl() execution times.
 *
 * add_mouse_randomness() uses the mouse interrupt timing, as well as
 * the reported position of the mouse from the hardware.
 *
 * add_net_randomness() times the finishing time of net input.
 *
 * add_tty_randomness() uses the inter-keypress timing, as well as the
 * character as random inputs into the entropy pool.
 *
 * add_disk_randomness() times the finishing time of disk requests as well
 * as feeding both xfer size & time into the entropy pool.
 *
 * add_audio_randomness() times the finishing of audio codec dma
 * requests for both recording and playback, apparently supplies quite
 * a lot of entropy. I'd blame it on low resolution audio clock generators.
 *
 * All of these routines (except for add_true_randomness() of course)
 * try to estimate how many bits of randomness are in a particular
 * randomness source.  They do this by keeping track of the first and
 * second order deltas of the event timings.
 *
d122 1
d226 1
a226 12
static void dequeue_randomness(void *);

/* Master kernel random number pool. */
struct random_bucket {
	u_int	add_ptr;
	u_int	entropy_count;
	u_char	input_rotate;
	u_int32_t pool[POOLWORDS];
	u_int	tmo;
};
struct random_bucket random_state;
struct mutex rndlock;
d229 3
a231 11
 * This function adds a byte into the entropy pool.  It does not
 * update the entropy estimate.  The caller must do this if appropriate.
 *
 * The pool is stirred with a polynomial of degree POOLWORDS over GF(2);
 * see POOL_TAP[1-4] above
 *
 * Rotate the input word by a changing number of bits, to help assure
 * that all bits in the entropy get toggled.  Otherwise, if the pool
 * is consistently feed small numbers (such as keyboard scan codes)
 * then the upper bits of the entropy pool will frequently remain
 * untouched.
d233 1
a233 88
static void
add_entropy_words(const u_int32_t *buf, u_int n)
{
	/* derived from IEEE 802.3 CRC-32 */
	static const u_int32_t twist_table[8] = {
		0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
		0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278
	};

	for (; n--; buf++) {
		u_int32_t w = (*buf << random_state.input_rotate) |
		    (*buf >> (32 - random_state.input_rotate));
		u_int i = random_state.add_ptr =
		    (random_state.add_ptr - 1) & POOLMASK;
		/*
		 * Normally, we add 7 bits of rotation to the pool.
		 * At the beginning of the pool, add an extra 7 bits
		 * rotation, so that successive passes spread the
		 * input bits across the pool evenly.
		 */
		random_state.input_rotate =
		    (random_state.input_rotate + (i ? 7 : 14)) & 31;

		/* XOR pool contents corresponding to polynomial terms */
		w ^= random_state.pool[(i + POOL_TAP1) & POOLMASK] ^
		     random_state.pool[(i + POOL_TAP2) & POOLMASK] ^
		     random_state.pool[(i + POOL_TAP3) & POOLMASK] ^
		     random_state.pool[(i + POOL_TAP4) & POOLMASK] ^
		     random_state.pool[(i + 1) & POOLMASK] ^
		     random_state.pool[i]; /* + 2^POOLWORDS */

		random_state.pool[i] = (w >> 3) ^ twist_table[w & 7];
	}
}

/*
 * This function extracts randomness from the entropy pool, and
 * returns it in a buffer.  This function computes how many remaining
 * bits of entropy are left in the pool, but it does not restrict the
 * number of bytes that are actually obtained.
 */
static void
extract_entropy(u_int8_t *buf, int nbytes)
{
	u_char buffer[16];
	MD5_CTX tmp;
	u_int i;

	add_timer_randomness(nbytes);

	while (nbytes) {
		i = MIN(nbytes, sizeof(buffer));

		/* Hash the pool to get the output */
		MD5Init(&tmp);
		mtx_enter(&rndlock);
		MD5Update(&tmp, (u_int8_t*)random_state.pool,
		    sizeof(random_state.pool));
		if (random_state.entropy_count / 8 > i)
			random_state.entropy_count -= i * 8;
		else
			random_state.entropy_count = 0;
		mtx_leave(&rndlock);
		MD5Final(buffer, &tmp);

		/* Copy data to destination buffer */
		bcopy(buffer, buf, i);
		nbytes -= i;
		buf += i;

		/* Modify pool so next hash will produce different results */
		add_timer_randomness(nbytes);
		dequeue_randomness(NULL);
	}

	/* Wipe data from memory */
	bzero(&tmp, sizeof(tmp));
	bzero(buffer, sizeof(buffer));
}

/* Entropy crediting API and handling of entropy-bearing events */

#define QEVLEN (1024 / sizeof(struct rand_event))
#define QEVSLOW (QEVLEN * 3 / 4) /* yet another 0.75 for 60-minutes hour /-; */
#define QEVSBITS 10

/* There is one of these per entropy source */
struct timer_rand_state {
d239 5
a243 1
};
d250 1
a250 4
};

struct timer_rand_state rnd_states[RND_SRC_NUM];
struct rand_event rnd_event_space[QEVLEN];
d253 1
a255 1
int rnd_attached;
d257 8
a264 1
/* must be called at a proper spl, returns ptr to the next event */
a280 1
/* must be called at a proper spl, returns next available item */
a294 1
/* must be called at a proper spl, returns number of items in the queue */
d316 1
d327 2
a331 14
	if (!rnd_attached) {
		if ((rep = rnd_put()) == NULL) {
			rndstats.rnd_drops++;
			return;
		}

		rep->re_state = &rnd_states[RND_SRC_TIMER];
		rep->re_nbits = 0;
		rep->re_time = 0;
		rep->re_time = val;
		return;
	}

	nanotime(&ts);
a340 1
		int	delta, delta2, delta3;
d378 6
d385 2
d393 1
a393 1
			return;
d398 1
a398 6
	} else if (p->max_entropy)
		nbits = 8 * sizeof(val) - 1;

	/* given the multi-order delta logic above, this should never happen */
	if (nbits >= 32)
		return;
a399 1
	mtx_enter(&rndlock);
d402 1
a402 2
		mtx_leave(&rndlock);
		return;
d415 2
a416 2
	if (rnd_qlen() > QEVSLOW/2 && !random_state.tmo) {
		random_state.tmo++;
d418 49
a467 1
	mtx_leave(&rndlock);
d470 4
d482 2
d485 1
a486 2

	mtx_enter(&rndlock);
a487 1

d491 1
a491 1
		mtx_leave(&rndlock);
d495 1
d497 3
a499 3
		random_state.entropy_count += nbits;
		if (random_state.entropy_count > POOLBITS)
			random_state.entropy_count = POOLBITS;
d501 38
a538 1
		mtx_enter(&rndlock);
d541 3
a543 2
	random_state.tmo = 0;
	mtx_leave(&rndlock);
d559 2
a561 7
struct rc4_ctx arc4random_state;
int arc4random_initialized;

static void arc4_reinit(void *v);
static void arc4_stir(void);
static void arc4_reinit(void *v);
static void arc4maybeinit(void);
d563 2
a564 84
void
randomattach(void)
{
	mtx_init(&rndlock, IPL_HIGH);

	random_state.add_ptr = 0;
	random_state.entropy_count = 0;
	rnd_states[RND_SRC_TIMER].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].max_entropy = 1;

	if (msgbufp && msgbufp->msg_magic == MSG_MAGIC)
		add_entropy_words((u_int32_t *)msgbufp->msg_bufc,
		    msgbufp->msg_bufs / sizeof(u_int32_t));

	timeout_set(&rnd_timeout, dequeue_randomness, NULL);
	timeout_set(&arc4_timeout, arc4_reinit, NULL);
	arc4_reinit(NULL);

	rnd_attached = 1;
}

static void
arc4_stir(void)
{
	struct timespec ts;
	u_int8_t buf[64], *p;
	int i;

	/*
	 * Use MD5 PRNG data and a system timespec; early in the boot
	 * process this is the best we can do -- some architectures do
	 * not collect entropy very well during this time, but may have
	 * clock information which is better than nothing.
	 */
	extract_entropy((u_int8_t *)buf, sizeof buf);
	nanotime(&ts);
	for (p = (u_int8_t *)&ts, i = 0; i < sizeof(ts); i++)
		buf[i] ^= p[i];

	mtx_enter(&rndlock);
	rndstats.rnd_used += sizeof(buf) * 8;

	if (rndstats.arc4_nstirs > 0)
		rc4_crypt(&arc4random_state, buf, buf, sizeof(buf));

	rc4_keysetup(&arc4random_state, buf, sizeof(buf));
	rndstats.arc4_stirs += sizeof(buf);
	rndstats.arc4_nstirs++;

	/*
	 * Throw away the first N words of output, as suggested in the
	 * paper "Weaknesses in the Key Scheduling Algorithm of RC4"
	 * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)
	 */
	rc4_skip(&arc4random_state, 256 * 4);
	mtx_leave(&rndlock);
}

/*
 * Called by timeout to mark arc4 for stirring,
 * actual stirring happens on any access attempt.
 */
static void
arc4_reinit(void *v)
{
	arc4random_initialized = 0;
}

static void
arc4maybeinit(void)
{

	if (!arc4random_initialized) {
#ifdef DIAGNOSTIC
		if (!rnd_attached)
			panic("arc4maybeinit: premature");
#endif
		arc4random_initialized++;
		arc4_stir();
		/* 10 minutes, per dm@@'s suggestion */
		timeout_add_sec(&arc4_timeout, 10 * 60);
	}
}
a571 1
	arc4maybeinit();
a606 2
	arc4maybeinit();

d664 65
d793 1
a793 1
		u_int	n = min(POOLBYTES, uio->uio_resid);
d806 2
a807 5
	if (newdata) {
		mtx_enter(&rndlock);
		arc4random_initialized = 0;
		mtx_leave(&rndlock);
	}
@


1.124
log
@For very large operations in randomread(), use a local rc4 instance
much like arc4random_buf_large does, but without re-initializing it
every 8K.
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.123 2011/01/06 15:41:50 deraadt Exp $	*/
d897 2
@


1.123
log
@make all /dev/*random nodes respond; in fact, don't even worry about
the minor number at all.  The chances of an application ignoring the
error on /dev/random are *greater* than the risk of an application
getting bad data from it.
ok dlg tedu kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.122 2011/01/04 19:42:22 deraadt Exp $	*/
d840 5
a844 2
	int		ret = 0;
	u_int32_t 	*buf;
d849 11
a859 1
	buf = malloc(POOLBYTES, M_TEMP, M_WAITOK);
d862 1
a862 1
		int	n = min(POOLBYTES, uio->uio_resid);
d864 4
a867 1
		arc4random_buf(buf, n);
@


1.122
log
@in arc4_stir() only grab 64 bytes from the MD5 output.  Grabbing more
does not substantially increase the quality of the RC4 state. These
days we may have lots more userland libc's initializing themselves,
or lots of largebuf kernel calls which re-initialize their own RC4,
and thus deplete the MD5 more than originally intended.
discussed at length with tedu, djm, kjell and kettenis
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.121 2011/01/01 19:43:04 deraadt Exp $	*/
d828 1
a828 1
	return (minor(dev) < RND_NODEV ? 0 : ENXIO);
d848 1
a848 1
	while (!ret && uio->uio_resid > 0) {
d851 4
a854 17
		switch (minor(dev)) {
		case RND_RND:
			ret = EIO;	/* no chip -- error */
			break;
		case RND_SRND:
		case RND_URND:
		case RND_ARND:
			arc4random_buf(buf, n);
			break;
		default:
			ret = ENXIO;
		}
		if (n != 0 && ret == 0) {
			ret = uiomove((caddr_t)buf, n, uio);
			if (!ret && uio->uio_resid > 0)
				yield();
		}
a865 3

	if (minor(dev) == RND_RND)
		return ENXIO;
@


1.121
log
@Do not fold the MD5 in half.  This might have made sense to someone when
we were feeding the MD5 output direct to consumers, but now we only feed
the RC4, so the effect is to throw away half of the stretched data.
ok tedu djm, initial discussion started by kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.120 2011/01/01 01:41:02 deraadt Exp $	*/
d665 1
a665 1
	u_int8_t buf[256], *p;
@


1.120
log
@comment cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.119 2010/12/31 22:45:18 deraadt Exp $	*/
d354 1
a354 4
		if (nbytes < sizeof(buffer) / 2)
			i = nbytes;
		else
			i = sizeof(buffer) / 2;
a366 13

		/*
		 * In case the hash function has some recognizable
		 * output pattern, we fold it in half.
		 */
		buffer[0] ^= buffer[15];
		buffer[1] ^= buffer[14];
		buffer[2] ^= buffer[13];
		buffer[3] ^= buffer[12];
		buffer[4] ^= buffer[11];
		buffer[5] ^= buffer[10];
		buffer[6] ^= buffer[ 9];
		buffer[7] ^= buffer[ 8];
@


1.119
log
@make randomattach do the parts of it's job in the right order, then move
it to where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.118 2010/12/31 22:40:19 deraadt Exp $	*/
a3 2
 * rnd.c -- A strong random number generator
 *
a181 5
 * Master random number pool functions
 * -----------------------------------
 */

/*
d399 1
a399 4
/*
 * Kernel-side entropy crediting API and handling of entropy-bearing events
 * ------------------------------------------------------------------------
 */
a400 1
/* pIII/333 reported to have some drops w/ these numbers */
a633 5
 * Exported kernel CPRNG API: arc4random() and friends
 * ---------------------------------------------------
 */

/*
d715 1
a715 1
 * called by timeout to mark arc4 for stirring,
a839 5

/*
 * random, srandom, urandom, arandom char devices
 * -------------------------------------------------------
 */
@


1.118
log
@cleanup the ioctl function
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.117 2010/12/31 22:39:11 deraadt Exp $	*/
d666 27
a753 24
}

void
randomattach(void)
{
	if (rnd_attached)
		return;

	timeout_set(&rnd_timeout, dequeue_randomness, NULL);
	timeout_set(&arc4_timeout, arc4_reinit, NULL);

	random_state.add_ptr = 0;
	random_state.entropy_count = 0;
	rnd_states[RND_SRC_TIMER].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].max_entropy = 1;

	mtx_init(&rndlock, IPL_HIGH);
	arc4_reinit(NULL);

	if (msgbufp && msgbufp->msg_magic == MSG_MAGIC)
		add_entropy_words((u_int32_t *)msgbufp->msg_bufc,
		    msgbufp->msg_bufs / sizeof(u_int32_t));
	rnd_attached = 1;
@


1.117
log
@delete includes we do not need
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.116 2010/12/31 22:38:07 deraadt Exp $	*/
a946 2
	int	ret = 0;

d949 1
a949 1
		/* rnd has no async flag in softc so this is really a no-op. */
a950 1

a953 1

d955 1
a955 1
		ret = ENOTTY;
d957 1
a957 2

	return ret;
@


1.116
log
@further improvements describing what we are doing
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.115 2010/12/31 22:32:20 deraadt Exp $	*/
a165 1
#include <sys/endian.h>
a173 1
#include <sys/vnode.h>
@


1.115
log
@all random nodes have been arc4-based for a while, so none of them ever
block. the kq and poll code should have been replaced with "selltrue"
type code a while ago.
with and ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.114 2010/12/30 22:05:45 deraadt Exp $	*/
a43 2
 * (now, with legal B.S. out of the way.....)
 *
d86 10
a95 16
 * If this estimate goes to zero, the routine can still generate
 * random numbers; however, an attacker may (at least in theory) be
 * able to infer the future output of the generator from prior
 * outputs.  This requires successful cryptanalysis of MD5, which is
 * believed to be not feasible, but there is a remote possibility.
 * Nonetheless, these numbers should be useful for the vast majority
 * of purposes.
 *
 * However, this MD5 output is not exported outside the subsystem.  It
 * is next used as input to seed a RC4 stream cipher.  Attempts are
 * made to follow best practice regarding this stream cipher - the first
 * chunk of output is discarded and the cipher is re-seeded from time to
 * time.  This design provides very high amounts of output data from a
 * potentially small entropy base, at high enough speeds to encourage
 * use of random numbers in nearly any situation.
 *
d97 3
a99 3
 * consumers in the kernel and userland via various interfaces:
 * arc4random_buf(), arc4random(), arc4random_uniform(), the set of
 * /dev/random nodes, and the sysctl kern.arandom.
@


1.114
log
@be more cynical about boot-time entropy, and fold time and entropy data in.
ok djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.113 2010/12/29 20:11:17 deraadt Exp $	*/
a184 1
#include <sys/poll.h>
a301 1
	u_int	asleep;
a446 1
struct selinfo rnd_rsel;
a646 6
		if (random_state.asleep && random_state.entropy_count > 8) {
			random_state.asleep--;
			wakeup((void *)&random_state.asleep);
			selwakeup(&rnd_rsel);
		}

a868 14
void filt_rndrdetach(struct knote *kn);
int filt_rndread(struct knote *kn, long hint);

struct filterops rndread_filtops =
	{ 1, NULL, filt_rndrdetach, filt_rndread};

void filt_rndwdetach(struct knote *kn);
int filt_rndwrite(struct knote *kn, long hint);

struct filterops rndwrite_filtops =
	{ 1, NULL, filt_rndwdetach, filt_rndwrite};

struct selinfo rnd_wsel;

a915 68
}

int
randompoll(dev_t dev, int events, struct proc *p)
{
	int revents;

	revents = events & (POLLOUT | POLLWRNORM);	/* always writable */
	if (events & (POLLIN | POLLRDNORM)) {
		revents |= events & (POLLIN | POLLRDNORM);
	}

	return (revents);
}

int
randomkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &rnd_rsel.si_note;
		kn->kn_fop = &rndread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &rnd_wsel.si_note;
		kn->kn_fop = &rndwrite_filtops;
		break;
	default:
		return (1);
	}
	kn->kn_hook = (void *)&random_state;

	mtx_enter(&rndlock);
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	mtx_leave(&rndlock);

	return (0);
}

void
filt_rndrdetach(struct knote *kn)
{
	mtx_enter(&rndlock);
	SLIST_REMOVE(&rnd_rsel.si_note, kn, knote, kn_selnext);
	mtx_leave(&rndlock);
}

int
filt_rndread(struct knote *kn, long hint)
{
	kn->kn_data = (int)random_state.entropy_count;
	return random_state.entropy_count > 0;
}

void
filt_rndwdetach(struct knote *kn)
{
	mtx_enter(&rndlock);
	SLIST_REMOVE(&rnd_wsel.si_note, kn, knote, kn_selnext);
	mtx_leave(&rndlock);
}

int
filt_rndwrite(struct knote *kn, long hint)
{
	return (1);
@


1.113
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.112 2010/12/29 18:28:16 deraadt Exp $	*/
d179 1
d509 1
a509 1
	struct timespec	tv;
d533 2
a534 2
	nanotime(&tv);
	time = (tv.tv_nsec >> 10) + (tv.tv_sec << 20);
d609 1
a609 1
	rep->re_time = tv.tv_nsec ^ (tv.tv_sec << 20);
d688 14
a701 2
	u_int8_t buf[256];
	int len;
a702 4
	nanotime((struct timespec *) buf);
	len = sizeof(buf) - sizeof(struct timespec);
	extract_entropy((u_int8_t *)(buf + sizeof (struct timespec)), len);
	len += sizeof(struct timespec);
d704 2
d710 1
a710 1
	rndstats.arc4_stirs += len;
d1030 1
a1030 1
			((u_int8_t *) buf)[n++] = 0;
@


1.112
log
@Since there is only one random_state, we can access it directly without
the rs-> song and dance.  Exactly the same diff was written by djm.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.111 2010/12/29 18:23:12 deraadt Exp $	*/
d769 1
a769 1
	rc4_getbytes(&arc4random_state, (u_char*)&ret, sizeof(ret));
d792 1
a792 1
	rc4_getbytes(&lctx, (u_char*)buf, n);
d812 1
a812 1
	rc4_getbytes(&arc4random_state, (u_char*)buf, n);
d907 1
a907 1
		switch(minor(dev)) {
@


1.111
log
@arc4random_count is not used; other things inside rndstats do the accounting
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.110 2010/12/29 18:21:42 deraadt Exp $	*/
a364 1
	struct random_bucket *rs = &random_state;
d380 4
a383 3
		MD5Update(&tmp, (u_int8_t*)rs->pool, sizeof(rs->pool));
		if (rs->entropy_count / 8 > i)
			rs->entropy_count -= i * 8;
d385 1
a385 1
			rs->entropy_count = 0;
d409 1
a409 1
		dequeue_randomness(&random_state);
d623 1
a626 1
	struct random_bucket *rs = v;
d645 7
a651 7
		rs->entropy_count += nbits;
		if (rs->entropy_count > POOLBITS)
			rs->entropy_count = POOLBITS;

		if (rs->asleep && rs->entropy_count > 8) {
			rs->asleep--;
			wakeup((void *)&rs->asleep);
d658 1
a658 1
	rs->tmo = 0;
d743 1
a743 1
	timeout_set(&rnd_timeout, dequeue_randomness, &random_state);
d980 2
a981 4
	struct random_bucket *rs = (struct random_bucket *)kn->kn_hook;

	kn->kn_data = (int)rs->entropy_count;
	return rs->entropy_count > 0;
@


1.110
log
@the rnd_debug stuff was not useful
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.109 2010/12/29 18:19:42 deraadt Exp $	*/
a682 1
u_long arc4random_count = 0;
a698 1
	arc4random_count = 0;
a770 1
	arc4random_count += sizeof(ret);
a787 1
	arc4random_count += sizeof(lbuf);
a813 1
	arc4random_count += n;
@


1.109
log
@kill RND_ARND_OLD, and decrease RND_NODEV to account for it; ok djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.108 2010/12/29 18:16:59 deraadt Exp $	*/
a192 7
#ifdef	RNDEBUG
int	rnd_debug = 0x0000;
#define	RD_INPUT	0x000f	/* input data */
#define	RD_OUTPUT	0x00f0	/* output data */
#define	RD_WAIT		0x0100	/* sleep/wakeup for good data */
#endif

a649 6
#ifdef	RNDEBUG
			if (rnd_debug & RD_WAIT)
				printf("rnd: wakeup[%u]{%u}\n",
				    rs->asleep,
				    rs->entropy_count);
#endif
d742 1
a742 4
	if (rnd_attached) {
#ifdef RNDEBUG
		printf("random: second attach\n");
#endif
a743 1
	}
@


1.108
log
@Remove the get_random_bytes() API.
ok kjell djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.107 2010/12/29 17:51:48 deraadt Exp $	*/
a934 1
		case RND_ARND_OLD:
@


1.107
log
@the random ioctl stuff is not very useful.  I want to see all the
non-essential parts of rnd.c removed so that we can keep our eye on
what the code should be doing.
ok tedu who had a similar diff in the past
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.106 2010/12/24 06:23:36 deraadt Exp $	*/
a697 13
/*
 * This function returns some number of good random numbers but is quite
 * slow. Please use arc4random_buf() instead unless very high quality
 * randomness is required.
 * XXX: rename this
 */
void
get_random_bytes(void *buf, size_t nbytes)
{
	extract_entropy((u_int8_t *) buf, nbytes);
	rndstats.rnd_used += nbytes * 8;
}

d706 1
a706 1
	get_random_bytes(buf + sizeof (struct timespec), len);
a707 1

@


1.106
log
@try to update the monster comment at the top of this file to explain
what it is we are doing
ok djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.105 2010/12/22 18:16:24 deraadt Exp $	*/
a191 1
#include <dev/rndioctl.h>
a1076 1
	u_int	cnt;
a1086 46
	case RNDGETENTCNT:
		mtx_enter(&rndlock);
		*(u_int *)data = random_state.entropy_count;
		mtx_leave(&rndlock);
		break;
	case RNDADDTOENTCNT:
		if (suser(p, 0) != 0)
			ret = EPERM;
		else {
			cnt = *(u_int *)data;
			mtx_enter(&rndlock);
			random_state.entropy_count += cnt;
			if (random_state.entropy_count > POOLBITS)
				random_state.entropy_count = POOLBITS;
			mtx_leave(&rndlock);
		}
		break;
	case RNDZAPENTCNT:
		if (suser(p, 0) != 0)
			ret = EPERM;
		else {
			mtx_enter(&rndlock);
			random_state.entropy_count = 0;
			mtx_leave(&rndlock);
		}
		break;
	case RNDSTIRARC4:
		if (suser(p, 0) != 0)
			ret = EPERM;
		else if (random_state.entropy_count < 64)
			ret = EAGAIN;
		else {
			mtx_enter(&rndlock);
			arc4random_initialized = 0;
			mtx_leave(&rndlock);
		}
		break;
	case RNDCLRSTATS:
		if (suser(p, 0) != 0)
			ret = EPERM;
		else {
			mtx_enter(&rndlock);
			bzero(&rndstats, sizeof(rndstats));
			mtx_leave(&rndlock);
		}
		break;
@


1.105
log
@rewrite randomwrite() for clarity after discussion with mikeb
ok djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.104 2010/11/21 22:58:40 tedu Exp $	*/
a7 3
 *
 * Version 1.89, last modified 19-Sep-99
 *
d47 2
a48 5
 * and returns good random numbers, suitable for cryptographic use.
 * Besides the obvious cryptographic uses, these numbers are also good
 * for seeding TCP sequence numbers, and other places where it is
 * desirable to have numbers which are not only random, but hard to
 * predict by an attacker.
d96 12
a107 23
 * Exported interfaces ---- output
 * ===============================
 *
 * There are three exported interfaces.
 * The first set are designed to be used from within the kernel:
 *
 *	void get_random_bytes(void *buf, int nbytes);
 *
 * This interface will return the requested number of random bytes,
 * and place it in the requested buffer.
 *
 * Two other interfaces are two character devices /dev/random and
 * /dev/urandom.  /dev/random is suitable for use when very high
 * quality randomness is desired (for example, for key generation or
 * one-time pads), as it will only return a maximum of the number of
 * bits of randomness (as estimated by the random number generator)
 * contained in the entropy pool.
 *
 * The /dev/urandom device does not have this limit, and will return
 * as many bytes as were requested.  As more and more random bytes
 * requested without giving time for the entropy pool to recharge,
 * this will result in random numbers that are merely cryptographically
 * strong.  For many applications, however, this is acceptable.
a151 53
 * Ensuring unpredictability at system startup
 * ============================================
 *
 * When any operating system starts up, it will go through a sequence
 * of actions that are fairly predictable by an adversary, especially
 * if the start-up does not involve interaction with a human operator.
 * This reduces the actual number of bits of unpredictability in the
 * entropy pool below the value in entropy_count.  In order to
 * counteract this effect, it helps to carry information in the
 * entropy pool across shut-downs and start-ups.  To do this, put the
 * following lines in appropriate script which is run during the boot
 * sequence:
 *
 *	echo "Initializing random number generator..."
 *	# Carry a random seed from start-up to start-up
 *	# Load and then save 512 bytes, which is the size of the entropy pool
 *	if [ -f /etc/random-seed ]; then
 *		cat /etc/random-seed >/dev/urandom
 *	fi
 *	dd if=/dev/urandom of=/etc/random-seed count=1
 *
 * and the following lines in appropriate script which is run when
 * the system is shutting down:
 *
 *	# Carry a random seed from shut-down to start-up
 *	# Save 512 bytes, which is the size of the entropy pool
 *	echo "Saving random seed..."
 *	dd if=/dev/urandom of=/etc/random-seed count=1
 *
 * For example, on OpenBSD systems, the appropriate scripts are
 * usually /etc/rc.local and /etc/rc.shutdown, respectively.
 *
 * Effectively, these commands cause the contents of the entropy pool
 * to be saved at shutdown time and reloaded into the entropy pool at
 * start-up.  (The 'dd' in the addition to the bootup script is to
 * make sure that /etc/random-seed is different for every start-up,
 * even if the system crashes without executing rc.shutdown) Even with
 * complete knowledge of the start-up activities, predicting the state
 * of the entropy pool requires knowledge of the previous history of
 * the system.
 *
 * Configuring the random(4) driver under OpenBSD
 * ==============================================
 *
 * The special files for the random(4) driver should have been created
 * during the installation process.  However, if your system does not have
 * /dev/random and /dev/[s|u|p|a]random created already, they can be created
 * by using the MAKEDEV(8) script in /dev:
 *
 *	/dev/MAKEDEV random
 *
 * Check MAKEDEV for information about major and minor numbers.
 *
d168 3
@


1.104
log
@adding timer randomness in ioctl doesn't really help and looks suspicious.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.103 2010/10/02 15:49:17 tedu Exp $	*/
d1108 1
a1108 1
	int		ret = 0;
d1120 1
a1120 1
		u_short	n = min(POOLBYTES, uio->uio_resid);
d1122 7
a1128 6
		ret = uiomove((caddr_t)buf, n, uio);
		if (!ret) {
			while (n % sizeof(u_int32_t))
				((u_int8_t *) buf)[n++] = 0;
			add_entropy_words(buf, n / 4);
		}
d1131 2
a1132 1
	if (!ret)
d1134 2
@


1.103
log
@remove support for srandom and urandom.  direct everyone to arandom instead.
we do this to prevent people from opening a device that sounds good, but
doesn't have the properties they really need.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.102 2010/04/20 22:05:41 tedu Exp $	*/
a1142 2
	add_timer_randomness((u_long)p ^ (u_long)data ^ cmd);

a1201 1
	add_timer_randomness((u_long)p ^ (u_long)data ^ cmd);
@


1.102
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.101 2009/11/09 17:53:39 nicm Exp $	*/
d988 1
a988 1
	return (minor (dev) < RND_NODEV) ? 0 : ENXIO;
a1015 28
			if (random_state.entropy_count < 16 * 8) {
				if (ioflag & IO_NDELAY) {
					ret = EWOULDBLOCK;
					break;
				}
#ifdef	RNDEBUG
				if (rnd_debug & RD_WAIT)
					printf("rnd: sleep[%u]\n",
					    random_state.asleep);
#endif
				random_state.asleep++;
				rndstats.rnd_waits++;
				ret = tsleep(&random_state.asleep,
				    PWAIT | PCATCH, "rndrd", 0);
#ifdef	RNDEBUG
				if (rnd_debug & RD_WAIT)
					printf("rnd: awakened(%d)\n", ret);
#endif
				if (ret)
					break;
			}
			if (n > random_state.entropy_count / 8)
				n = random_state.entropy_count / 8;
			rndstats.rnd_reads++;
#ifdef	RNDEBUG
			if (rnd_debug & RD_OUTPUT)
				printf("rnd: %u possible output\n", n);
#endif
a1016 6
			get_random_bytes((char *)buf, n);
#ifdef	RNDEBUG
			if (rnd_debug & RD_OUTPUT)
				printf("rnd: %u bytes for output\n", n);
#endif
			break;
d1042 1
a1042 4
		if (minor(dev) == RND_SRND && random_state.entropy_count <= 0)
			selrecord(p, &rnd_rsel);
		else
			revents |= events & (POLLIN | POLLRDNORM);
d1130 1
a1130 2
	if ((minor(dev) == RND_ARND || minor(dev) == RND_ARND_OLD) &&
	    !ret)
@


1.101
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.100 2009/06/05 04:43:23 guenther Exp $	*/
a249 1
#include <sys/sysctl.h>
@


1.100
log
@Sanity check: we overrun the rnd_ed[] array if nbits is 32, but that
should be impossible given the multi-order delta logic

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.99 2008/12/15 06:00:38 djm Exp $	*/
a734 1
			KNOTE(&rnd_rsel.si_note, 0);
@


1.99
log
@remove i386-only inline assembler roll() function; gcc optimises the
equivalent C code into a rol instruction anyway (confirmed with
objdump -d); "nuke it" weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.98 2008/11/24 19:02:38 deraadt Exp $	*/
d670 4
@


1.98
log
@extra decl not needed; spotted by djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.97 2008/11/24 16:36:41 deraadt Exp $	*/
a383 12
/* Rotate bits in word 'w' by 'i' positions */
static __inline u_int32_t roll(u_int32_t w, int i)
{
	/* XXX amd64 too? */
#ifdef i386
	__asm ("roll %%cl, %0" : "+r" (w) : "c" (i));
#else
	w = (w << i) | (w >> (32 - i));
#endif
	return w;
}

d407 2
a408 1
		u_int32_t w = roll(*buf, random_state.input_rotate);
@


1.97
log
@allow entropy to be queued before randomattach() is called
worked on with djm
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.96 2008/11/24 10:30:12 mpf Exp $	*/
a606 2
		struct rand_event *rep;
		
@


1.96
log
@Seed the random pool with the dmesg buffer at randomattach().
This lets early arc4random() calls to return at least non-uniqe values
on different machines. The dmesg will have different MAC addresses,
etc. Also ignore the entropy count in arc4_stir, and just take what's
there. sizeof(struct timeval) should be sizof(struct timespec)
This was forgotten when we switched to nanotime.
With help from mickey.
OK djm@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.95 2008/10/15 03:30:57 djm Exp $	*/
a597 4
	/* XXX on sparc we get here before randomattach() */
	if (!rnd_attached)
		return;

d606 15
a863 4
	bzero(&rndstats, sizeof(rndstats));
	bzero(&rnd_event_space, sizeof(rnd_event_space));

	bzero(&arc4random_state, sizeof(arc4random_state));
@


1.95
log
@kernel/5592: yield() between copying out large chunks of random data to
userspace - mitigates an effective DoS since generating these can hog
the CPU at splhigh()

feedback & ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.94 2008/10/10 20:13:11 deraadt Exp $	*/
d254 1
d786 3
a788 5
	len = random_state.entropy_count / 8; /* XXX maybe a half? */
	if (len > sizeof(buf) - sizeof(struct timeval))
		len = sizeof(buf) - sizeof(struct timeval);
	get_random_bytes(buf + sizeof (struct timeval), len);
	len += sizeof(struct timeval);
d860 3
@


1.94
log
@minor 3 was /dev/prandom, which used random().  make that use the
arandom code, just like minor 4.  in fact, make them act exactly
the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.93 2008/09/10 14:01:23 blambert Exp $	*/
d1060 1
a1060 1
		if (n != 0 && ret == 0)
d1062 3
@


1.93
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.92 2008/06/11 19:38:00 djm Exp $	*/
d969 1
a969 1
 * random, srandom, urandom, prandom, arandom char devices
a1002 1
	int		i;
d1053 1
a1053 5
		case RND_PRND:
			i = (n + 3) / 4;
			while (i--)
				buf[i] = random() << 16 | (random() & 0xFFFF);
			break;
d1147 1
a1147 1
	if (minor(dev) == RND_RND || minor(dev) == RND_PRND)
d1166 2
a1167 1
	if (minor(dev) == RND_ARND && !ret)
@


1.92
log
@correct long since bitrotted comments

POOL_TAP5 is always 1 so unifdef it

no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.91 2008/06/10 03:11:30 djm Exp $	*/
a821 1
	extern int hz;
d831 1
a831 1
		timeout_add(&arc4_timeout, 10 * 60 * hz);
@


1.91
log
@reorder functions and variables in rnd.c so they are more logically
arranged. They are now layed out in four sections:

1. Master entropy pool maintenance (add_entropy_words & extract entropy)
2. Entropy crediting (add_*_randomness backend)
3. Exported kernel API: arc4random() and friends
4. /dev/*random char devices
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.90 2008/06/09 23:03:16 djm Exp $	*/
d317 9
a325 4
 * The pool is stirred with a primitive polynomial of degree 128
 * over GF(2), namely x^128 + x^99 + x^59 + x^31 + x^9 + x^7 + 1.
 * For a pool of size 64, try x^64+x^62+x^38+x^10+x^6+x+1.
 * XXX is this comment still accurate?
a334 1
#define	POOL_TAP5	1
a339 1
#define	POOL_TAP5	1
a344 1
#define	POOL_TAP5	1
a349 1
#define	POOL_TAP5	1
a354 1
#define	POOL_TAP5	1
a359 1
#define	POOL_TAP5	1
a364 1
#define	POOL_TAP5	1
d386 1
d399 8
a406 10
 * The pool is stirred with a primitive polynomial of degree 128
 * over GF(2), namely x^128 + x^99 + x^59 + x^31 + x^9 + x^7 + 1.
 * For a pool of size 64, try x^64+x^62+x^38+x^10+x^6+x+1.
 * XXX is this comment still accurate?
 *
 * We rotate the input word by a changing number of bits, to help
 * assure that all bits in the entropy get toggled.  Otherwise, if we
 * consistently feed the entropy pool small numbers (like jiffies and
 * scancodes, for example), the upper bits of the entropy pool don't
 * get affected. --- TYT, 10/11/95
d411 1
d430 1
a430 1
		/* XOR in the various POOL_TAPs */
d435 3
a437 2
		     random_state.pool[(i + POOL_TAP5) & POOLMASK] ^
		     random_state.pool[i];
@


1.90
log
@simplify math for arc4random_uniform() suggested by
Jinmei_Tatuya AT isc.org via jakob@@

empirically verified for entire domain of upper_bound
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.89 2008/06/09 07:07:16 djm Exp $	*/
d45 1
d106 1
a106 1
 * The first one is designed to be used from within the kernel:
d139 1
a239 2
#undef RNDEBUG

d269 2
a270 16
 * Maximum number of bytes to serve directly from the main arc4random
 * pool. Larger requests are served from discrete arc4 instances keyed
 * from the main pool.
 */
#define ARC4_MAIN_MAX_BYTES	2048

/*
 * Key size (in bytes) for arc4 instances setup to serve requests larger
 * than ARC4_MAIN_MAX_BYTES.
 */
#define ARC4_SUB_KEY_BYTES	(256 / 8)

/*
 * The pool is stirred with a primitive polynomial of degree 128
 * over GF(2), namely x^128 + x^99 + x^59 + x^31 + x^9 + x^7 + 1.
 * For a pool of size 64, try x^64+x^62+x^38+x^10+x^6+x+1.
a271 47
#define POOLBITS (POOLWORDS*32)
#define POOLBYTES (POOLWORDS*4)
#if POOLWORDS == 2048
#define	TAP1	1638
#define	TAP2	1231
#define	TAP3	819
#define	TAP4	411
#define	TAP5	1
#elif POOLWORDS == 1024	/* also (819, 616, 410, 207, 2) */
#define	TAP1	817
#define	TAP2	615
#define	TAP3	412
#define	TAP4	204
#define	TAP5	1
#elif POOLWORDS == 512	/* also (409,307,206,102,2), (409,309,205,103,2) */
#define	TAP1	411
#define	TAP2	308
#define	TAP3	208
#define	TAP4	104
#define	TAP5	1
#elif POOLWORDS == 256
#define	TAP1	205
#define	TAP2	155
#define	TAP3	101
#define	TAP4	52
#define	TAP5	1
#elif POOLWORDS == 128	/* also (103, 78, 51, 27, 2) */
#define	TAP1	103
#define	TAP2	76
#define	TAP3	51
#define	TAP4	25
#define	TAP5	1
#elif POOLWORDS == 64
#define	TAP1	52
#define	TAP2	39
#define	TAP3	26
#define	TAP4	14
#define	TAP5	1
#elif POOLWORDS == 32
#define	TAP1	26
#define	TAP2	20
#define	TAP3	14
#define	TAP4	7
#define	TAP5	1
#else
#error No primitive polynomial available for chosen POOLWORDS
#endif
d316 56
a371 4
/* pIII/333 reported to have some drops w/ these numbers */
#define QEVLEN (1024 / sizeof(struct rand_event))
#define QEVSLOW (QEVLEN * 3 / 4) /* yet another 0.75 for 60-minutes hour /-; */
#define QEVSBITS 10
d373 1
a373 1
/* There is actually only one of these, globally. */
d382 131
a529 4
struct timeout rnd_timeout, arc4_timeout;
struct random_bucket random_state;
struct rc4_ctx arc4random_state;
u_long arc4random_count = 0;
d534 3
a536 14
struct selinfo rnd_rsel, rnd_wsel;

void filt_rndrdetach(struct knote *kn);
int filt_rndread(struct knote *kn, long hint);

struct filterops rndread_filtops =
	{ 1, NULL, filt_rndrdetach, filt_rndread};

void filt_rndwdetach(struct knote *kn);
int filt_rndwrite(struct knote *kn, long hint);

struct filterops rndwrite_filtops =
	{ 1, NULL, filt_rndwdetach, filt_rndwrite};

a537 13
int arc4random_initialized;
struct rndstats rndstats;
struct mutex rndlock;

static __inline u_int32_t roll(u_int32_t w, int i)
{
#ifdef i386
	__asm ("roll %%cl, %0" : "+r" (w) : "c" (i));
#else
	w = (w << i) | (w >> (32 - i));
#endif
	return w;
}
d579 11
a589 9
void dequeue_randomness(void *);

static void add_entropy_words(const u_int32_t *, u_int n);
void extract_entropy(u_int8_t *, int);

void arc4_stir(void);
void arc4_reinit(void *v);
void arc4maybeinit(void);

d591 1
a591 1
arc4_stir(void)
d593 8
a600 2
	u_int8_t buf[256];
	int len;
d602 4
a605 6
	nanotime((struct timespec *) buf);
	len = random_state.entropy_count / 8; /* XXX maybe a half? */
	if (len > sizeof(buf) - sizeof(struct timeval))
		len = sizeof(buf) - sizeof(struct timeval);
	get_random_bytes(buf + sizeof (struct timeval), len);
	len += sizeof(struct timeval);
d607 2
a608 3
	mtx_enter(&rndlock);
	if (rndstats.arc4_nstirs > 0)
		rc4_crypt(&arc4random_state, buf, buf, sizeof(buf));
d610 3
a612 4
	rc4_keysetup(&arc4random_state, buf, sizeof(buf));
	arc4random_count = 0;
	rndstats.arc4_stirs += len;
	rndstats.arc4_nstirs++;
d615 190
a804 3
	 * Throw away the first N words of output, as suggested in the
	 * paper "Weaknesses in the Key Scheduling Algorithm of RC4"
	 * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)
d810 11
a820 1
void
a836 4
/*
 * called by timeout to mark arc4 for stirring,
 * actual stirring happens on any access attempt.
 */
d838 1
a838 1
arc4_reinit(void *v)
d840 24
a863 1
	arc4random_initialized = 0;
d866 1
d881 4
d904 3
d970 4
a973 9
void
randomattach(void)
{
	if (rnd_attached) {
#ifdef RNDEBUG
		printf("random: second attach\n");
#endif
		return;
	}
d975 2
a976 2
	timeout_set(&rnd_timeout, dequeue_randomness, &random_state);
	timeout_set(&arc4_timeout, arc4_reinit, NULL);
d978 2
a979 5
	random_state.add_ptr = 0;
	random_state.entropy_count = 0;
	rnd_states[RND_SRC_TIMER].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].max_entropy = 1;
d981 2
a982 2
	bzero(&rndstats, sizeof(rndstats));
	bzero(&rnd_event_space, sizeof(rnd_event_space));
d984 2
a985 3
	bzero(&arc4random_state, sizeof(arc4random_state));
	mtx_init(&rndlock, IPL_HIGH);
	arc4_reinit(NULL);
d987 1
a987 2
	rnd_attached = 1;
}
a998 288
}

/*
 * This function adds a byte into the entropy pool.  It does not
 * update the entropy estimate.  The caller must do this if appropriate.
 *
 * The pool is stirred with a primitive polynomial of degree 128
 * over GF(2), namely x^128 + x^99 + x^59 + x^31 + x^9 + x^7 + 1.
 * For a pool of size 64, try x^64+x^62+x^38+x^10+x^6+x+1.
 *
 * We rotate the input word by a changing number of bits, to help
 * assure that all bits in the entropy get toggled.  Otherwise, if we
 * consistently feed the entropy pool small numbers (like jiffies and
 * scancodes, for example), the upper bits of the entropy pool don't
 * get affected. --- TYT, 10/11/95
 */
static void
add_entropy_words(const u_int32_t *buf, u_int n)
{
	static const u_int32_t twist_table[8] = {
		0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
		0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278
	};

	for (; n--; buf++) {
		u_int32_t w = roll(*buf, random_state.input_rotate);
		u_int i = random_state.add_ptr =
		    (random_state.add_ptr - 1) & (POOLWORDS - 1);
		/*
		 * Normally, we add 7 bits of rotation to the pool.
		 * At the beginning of the pool, add an extra 7 bits
		 * rotation, so that successive passes spread the
		 * input bits across the pool evenly.
		 */
		random_state.input_rotate =
		    (random_state.input_rotate + (i? 7 : 14)) & 31;

		/* XOR in the various taps */
		w ^= random_state.pool[(i+TAP1) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP2) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP3) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP4) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP5) & (POOLWORDS-1)] ^
		     random_state.pool[i];
		random_state.pool[i] = (w >> 3) ^ twist_table[w & 7];
	}
}

/*
 * This function adds entropy to the entropy pool by using timing
 * delays.  It uses the timer_rand_state structure to make an estimate
 * of how many bits of entropy this call has added to the pool.
 *
 * The number "val" is also added to the pool - it should somehow describe
 * the type of event which just happened.  Currently the values of 0-255
 * are for keyboard scan codes, 256 and upwards - for interrupts.
 * On the i386, this is assumed to be at most 16 bits, and the high bits
 * are used for a high-resolution timer.
 *
 */
void
enqueue_randomness(int state, int val)
{
	struct timer_rand_state *p;
	struct rand_event *rep;
	struct timespec	tv;
	u_int	time, nbits;

	/* XXX on sparc we get here before randomattach() */
	if (!rnd_attached)
		return;

#ifdef DIAGNOSTIC
	if (state < 0 || state >= RND_SRC_NUM)
		return;
#endif

	p = &rnd_states[state];
	val += state << 13;

	nanotime(&tv);
	time = (tv.tv_nsec >> 10) + (tv.tv_sec << 20);
	nbits = 0;

	/*
	 * Calculate the number of bits of randomness that we probably
	 * added.  We take into account the first and second order
	 * deltas in order to make our estimate.
	 */
	if (!p->dont_count_entropy) {
		int	delta, delta2, delta3;
		delta  = time   - p->last_time;
		delta2 = delta  - p->last_delta;
		delta3 = delta2 - p->last_delta2;

		if (delta < 0) delta = -delta;
		if (delta2 < 0) delta2 = -delta2;
		if (delta3 < 0) delta3 = -delta3;
		if (delta > delta2) delta = delta2;
		if (delta > delta3) delta = delta3;
		delta3 = delta >>= 1;
		/*
		 * delta &= 0xfff;
		 * we don't do it since our time sheet is different from linux
		 */

		if (delta & 0xffff0000) {
			nbits = 16;
			delta >>= 16;
		}
		if (delta & 0xff00) {
			nbits += 8;
			delta >>= 8;
		}
		if (delta & 0xf0) {
			nbits += 4;
			delta >>= 4;
		}
		if (delta & 0xc) {
			nbits += 2;
			delta >>= 2;
		}
		if (delta & 2) {
			nbits += 1;
			delta >>= 1;
		}
		if (delta & 1)
			nbits++;

		/*
		 * the logic is to drop low-entropy entries,
		 * in hope for dequeuing to be more randomfull
		 */
		if (rnd_qlen() > QEVSLOW && nbits < QEVSBITS) {
			rndstats.rnd_drople++;
			return;
		}
		p->last_time = time;
		p->last_delta  = delta3;
		p->last_delta2 = delta2;
	} else if (p->max_entropy)
		nbits = 8 * sizeof(val) - 1;

	mtx_enter(&rndlock);
	if ((rep = rnd_put()) == NULL) {
		rndstats.rnd_drops++;
		mtx_leave(&rndlock);
		return;
	}

	rep->re_state = p;
	rep->re_nbits = nbits;
	rep->re_time = tv.tv_nsec ^ (tv.tv_sec << 20);
	rep->re_val = val;

	rndstats.rnd_enqs++;
	rndstats.rnd_ed[nbits]++;
	rndstats.rnd_sc[state]++;
	rndstats.rnd_sb[state] += nbits;

	if (rnd_qlen() > QEVSLOW/2 && !random_state.tmo) {
		random_state.tmo++;
		timeout_add(&rnd_timeout, 1);
	}
	mtx_leave(&rndlock);
}

void
dequeue_randomness(void *v)
{
	struct random_bucket *rs = v;
	struct rand_event *rep;
	u_int32_t buf[2];
	u_int nbits;

	timeout_del(&rnd_timeout);
	rndstats.rnd_deqs++;

	mtx_enter(&rndlock);
	while ((rep = rnd_get())) {

		buf[0] = rep->re_time;
		buf[1] = rep->re_val;
		nbits = rep->re_nbits;
		mtx_leave(&rndlock);

		add_entropy_words(buf, 2);

		rndstats.rnd_total += nbits;
		rs->entropy_count += nbits;
		if (rs->entropy_count > POOLBITS)
			rs->entropy_count = POOLBITS;

		if (rs->asleep && rs->entropy_count > 8) {
#ifdef	RNDEBUG
			if (rnd_debug & RD_WAIT)
				printf("rnd: wakeup[%u]{%u}\n",
				    rs->asleep,
				    rs->entropy_count);
#endif
			rs->asleep--;
			wakeup((void *)&rs->asleep);
			selwakeup(&rnd_rsel);
			KNOTE(&rnd_rsel.si_note, 0);
		}

		mtx_enter(&rndlock);
	}

	rs->tmo = 0;
	mtx_leave(&rndlock);
}

#if POOLWORDS % 16
#error extract_entropy() assumes that POOLWORDS is a multiple of 16 words.
#endif

/*
 * This function extracts randomness from the entropy pool, and
 * returns it in a buffer.  This function computes how many remaining
 * bits of entropy are left in the pool, but it does not restrict the
 * number of bytes that are actually obtained.
 */
void
extract_entropy(u_int8_t *buf, int nbytes)
{
	struct random_bucket *rs = &random_state;
	u_char buffer[16];
	MD5_CTX tmp;
	u_int i;

	add_timer_randomness(nbytes);

	while (nbytes) {
		if (nbytes < sizeof(buffer) / 2)
			i = nbytes;
		else
			i = sizeof(buffer) / 2;

		/* Hash the pool to get the output */
		MD5Init(&tmp);
		mtx_enter(&rndlock);
		MD5Update(&tmp, (u_int8_t*)rs->pool, sizeof(rs->pool));
		if (rs->entropy_count / 8 > i)
			rs->entropy_count -= i * 8;
		else
			rs->entropy_count = 0;
		mtx_leave(&rndlock);
		MD5Final(buffer, &tmp);

		/*
		 * In case the hash function has some recognizable
		 * output pattern, we fold it in half.
		 */
		buffer[0] ^= buffer[15];
		buffer[1] ^= buffer[14];
		buffer[2] ^= buffer[13];
		buffer[3] ^= buffer[12];
		buffer[4] ^= buffer[11];
		buffer[5] ^= buffer[10];
		buffer[6] ^= buffer[ 9];
		buffer[7] ^= buffer[ 8];

		/* Copy data to destination buffer */
		bcopy(buffer, buf, i);
		nbytes -= i;
		buf += i;

		/* Modify pool so next hash will produce different results */
		add_timer_randomness(nbytes);
		dequeue_randomness(&random_state);
	}

	/* Wipe data from memory */
	bzero(&tmp, sizeof(tmp));
	bzero(buffer, sizeof(buffer));
}

/*
 * This function is the exported kernel interface.  It returns some
 * number of good random numbers, suitable for seeding TCP sequence
 * numbers, etc.
 */
void
get_random_bytes(void *buf, size_t nbytes)
{
	extract_entropy((u_int8_t *) buf, nbytes);
	rndstats.rnd_used += nbytes * 8;
@


1.89
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.88 2008/06/04 00:50:23 djm Exp $	*/
d628 2
a629 2
		/* (2**32 - (x * 2)) % x == 2**32 % x when x <= 2**31 */
		min = ((0xffffffff - (upper_bound * 2)) + 1) % upper_bound;
@


1.88
log
@fix math screwup that reintroduced a bias for upper_bounds in range
(2^30,2^31). Nothing in the tree yet requests random numbers bounded
by this range.

report jakob!deraadt; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.87 2008/03/02 21:29:07 djm Exp $	*/
d567 1
a567 1
arc4random_bytes_large(void *buf, size_t n)
d586 1
a586 1
arc4random_bytes(void *buf, size_t n)
d592 1
a592 1
		arc4random_bytes_large(buf, n);
d1038 1
a1038 1
			arc4random_bytes(buf, n);
@


1.87
log
@Add a arc4random_uniform() that returns a uniformly distributed number
in the range 0 <= x < upper_bound

Please use this new API instead of "arc4random() % upper_bound", as it
avoids the "modulo bias" that favours small results when upper_bound is
not a power of two.

feedback deraadt@@ mcbride@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.86 2007/12/29 08:03:05 dlg Exp $	*/
d629 1
a629 1
		min = ((0xffffffff - (upper_bound << 2)) + 1) % upper_bound;
@


1.86
log
@switch from spls to mutexes for protecting the random state.

ok tedu@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.85 2007/10/15 23:20:56 djm Exp $	*/
d7 1
d245 1
d579 1
a579 1
       	rc4_skip(&lctx, 256 * 4);
d601 45
@


1.85
log
@zero the right object, not some hunk of stack; ok henric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.84 2007/10/15 01:01:47 djm Exp $	*/
d251 1
d431 1
d496 1
a496 1
	int s, len;
d505 1
a505 1
	s = splhigh();
d520 1
a520 1
	splx(s);
a552 1
	int s;
d556 1
a556 1
	s = splhigh();
d560 1
a560 1
	splx(s);
a566 1
	int s;
d570 1
a570 1
	s = splhigh();
d574 1
a574 1
	splx(s);
a585 2
	int s;

d594 1
a594 1
	s = splhigh();
d598 1
a598 1
	splx(s);
d624 1
a706 1
	int s;
d783 1
a783 1
	s = splhigh();
d786 1
a786 1
		splx(s);
d804 1
a804 1
	splx(s);
a813 1
	int s;
d818 1
a818 1
	s = splhigh();
d824 1
a824 1
		splx(s);
d846 1
a846 1
		s = splhigh();
d850 1
a850 1
	splx(s);
a869 1
	int s;
d881 1
a881 1
		s = splhigh();
d887 1
a887 1
		splx(s);
a1023 1
	int s;
d1039 1
a1039 1
	s = splhigh();
d1041 1
a1041 1
	splx(s);
d1049 1
a1049 2
	int s = splhigh();

d1051 1
a1051 1
	splx(s);
d1066 1
a1066 2
	int s = splhigh();

d1068 1
a1068 1
	splx(s);
d1112 1
a1112 1
	int	s, ret = 0;
d1127 1
a1127 1
		s = splhigh();
d1129 1
a1129 1
		splx(s);
d1136 1
a1136 1
			s = splhigh();
d1140 1
a1140 1
			splx(s);
d1147 1
a1147 1
			s = splhigh();
d1149 1
a1149 1
			splx(s);
d1158 1
a1158 1
			s = splhigh();
d1160 1
a1160 1
			splx(s);
d1167 1
a1167 1
			s = splhigh();
d1169 1
a1169 1
			splx(s);
@


1.84
log
@Switch arc4random to using routines from crypto/arc4.[ch], and rework
spl swizzling so we go to splhigh and back once per request instead of
once per byte.
Service large requests for arc4random_bytes using an independently keyed
generator rather than hogging the main one (at splhigh).
feedback from henric@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.83 2007/10/09 17:05:19 gilles Exp $	*/
d919 1
a919 1
	bzero(&buffer, sizeof(buffer));
@


1.83
log
@MALLOC -> malloc

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.82 2007/06/17 21:22:04 jasper Exp $	*/
d240 1
d253 1
d266 13
a397 7
struct arc4_stream {
	u_int8_t s[256];
	u_int	cnt;
	u_int8_t i;
	u_int8_t j;
};

d407 2
a408 1
struct arc4_stream arc4random_state;
a485 1
static u_int8_t arc4_getbyte(void);
a489 38
/* Arcfour random stream generator.  This code is derived from section
 * 17.1 of Applied Cryptography, second edition, which describes a
 * stream cipher allegedly compatible with RSA Labs "RC4" cipher (the
 * actual description of which is a trade secret).  The same algorithm
 * is used as a stream cipher called "arcfour" in Tatu Ylonen's ssh
 * package.
 *
 * The initialization function here has been modified to not discard
 * the old state, and its input always includes the time of day in
 * microseconds.  Moreover, bytes from the stream may at any point be
 * diverted to multiple processes or even kernel functions desiring
 * random numbers.  This increases the strength of the random stream,
 * but makes it impossible to use this code for encryption, since there
 * is no way to ever reproduce the same stream of random bytes.
 *
 * RC4 is a registered trademark of RSA Laboratories.
 */

static u_int8_t
arc4_getbyte(void)
{
	u_int8_t si, sj, ret;
	int s;

	s = splhigh();
	rndstats.arc4_reads++;
	arc4random_state.cnt++;
	arc4random_state.i++;
	si = arc4random_state.s[arc4random_state.i];
	arc4random_state.j += si;
	sj = arc4random_state.s[arc4random_state.j];
	arc4random_state.s[arc4random_state.i] = sj;
	arc4random_state.s[arc4random_state.j] = si;
	ret = arc4random_state.s[(si + sj) & 0xff];
	splx(s);
	return (ret);
}

d494 1
a494 3
	u_int8_t si;
	int n, s;
	int len;
d504 5
a508 11
	arc4random_state.i--;
	for (n = 0; n < 256; n++) {
		arc4random_state.i++;
		si = arc4random_state.s[arc4random_state.i];
		arc4random_state.j += si + buf[n % len];
		arc4random_state.s[arc4random_state.i] =
		    arc4random_state.s[arc4random_state.j];
		arc4random_state.s[arc4random_state.j] = si;
	}
	arc4random_state.j = arc4random_state.i;
	arc4random_state.cnt = 0;
a510 1
	splx(s);
d517 2
a518 2
	for (n = 0; n < 256 * 4; n++)
		arc4_getbyte();
d551 3
d555 26
a580 2
	return ((arc4_getbyte() << 24) | (arc4_getbyte() << 16)
		| (arc4_getbyte() << 8) | arc4_getbyte());
d586 1
a586 2
	u_int8_t *cp = buf;
	u_int8_t *end = cp + n;
d589 12
a600 2
	while (cp < end)
		*cp++ = arc4_getbyte();
a605 2
	int i;

d625 1
a625 2
	for (i = 0; i < 256; i++)
		arc4random_state.s[i] = i;
d995 1
a995 6
		{
			u_int8_t *cp = (u_int8_t *) buf;
			u_int8_t *end = cp + n;
			arc4maybeinit();
			while (cp < end)
				*cp++ = arc4_getbyte();
a996 1
		}
@


1.82
log
@ansify/de-register

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.81 2007/04/10 17:47:55 miod Exp $	*/
d950 1
a950 1
	MALLOC(buf, u_int32_t *, POOLBYTES, M_TEMP, M_WAITOK);
d1016 1
a1016 1
	FREE(buf, M_TEMP);
d1108 1
a1108 1
	MALLOC(buf, u_int32_t *, POOLBYTES, M_TEMP, M_WAITOK);
d1124 1
a1124 1
	FREE(buf, M_TEMP);
@


1.81
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.80 2006/04/11 14:31:52 djm Exp $	*/
d475 1
a475 1
void extract_entropy(register u_int8_t *, int);
d503 1
a503 1
	register u_int8_t si, sj, ret;
d524 2
a525 2
	register u_int8_t si;
	register int n, s;
d582 1
a582 2
arc4_reinit(v)
	void *v;
d638 1
a638 5
randomopen(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d644 1
a644 5
randomclose(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d664 1
a664 3
add_entropy_words(buf, n)
	const u_int32_t *buf;
	u_int n;
d672 2
a673 2
		register u_int32_t w = roll(*buf, random_state.input_rotate);
		register u_int i = random_state.add_ptr =
d708 1
a708 2
enqueue_randomness(state, val)
	int	state, val;
d710 2
a711 2
	register struct timer_rand_state *p;
	register struct rand_event *rep;
d738 1
a738 1
		register int	delta, delta2, delta3;
d816 1
a816 2
dequeue_randomness(v)
	void *v;
d819 1
a819 1
	register struct rand_event *rep;
d873 1
a873 3
extract_entropy(buf, nbytes)
	register u_int8_t *buf;
	int	nbytes;
d934 1
a934 3
get_random_bytes(buf, nbytes)
	void	*buf;
	size_t	nbytes;
d941 1
a941 4
randomread(dev, uio, ioflag)
	dev_t	dev;
	struct uio *uio;
	int	ioflag;
d1021 1
a1021 4
randompoll(dev, events, p)
	dev_t	dev;
	int	events;
	struct proc *p;
d1073 1
a1073 3
filt_rndread(kn, hint)
	struct knote *kn;
	long hint;
d1091 1
a1091 3
filt_rndwrite(kn, hint)
	struct knote *kn;
	long hint;
d1097 1
a1097 4
randomwrite(dev, uio, flags)
	dev_t	dev;
	struct uio *uio;
	int	flags;
d1129 1
a1129 6
randomioctl(dev, cmd, data, flag, p)
	dev_t	dev;
	u_long	cmd;
	caddr_t	data;
	int	flag;
	struct proc *p;
@


1.80
log
@make this use nanotime, not microtime; ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.79 2005/07/31 05:13:08 djm Exp $	*/
d490 1
a490 1
 * the old state, and it's input always includes the time of day in
@


1.79
log
@use monotonic time for repeat event detections; feedback and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.78 2005/07/07 00:11:24 djm Exp $	*/
d528 1
a528 1
	microtime((struct timeval *) buf);
d724 1
a724 1
	struct timeval	tv;
d740 2
a741 2
	microtime(&tv);
	time = tv.tv_usec + (tv.tv_sec << 20);
d812 1
a812 1
	rep->re_time = time;
@


1.78
log
@fix accounting bug on extraction - we were incorrectly subtracting many times
the amount requested from the pool's entropy estimate; ok mickey@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.77 2005/05/27 16:33:27 ho Exp $	*/
d741 1
a741 1
	time = tv.tv_usec ^ tv.tv_sec;
@


1.77
log
@De-inline a couple of long functions, which also makes them debugger-visible. 'makes sense' mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.76 2005/03/04 17:09:21 robert Exp $	*/
d892 3
d899 4
a902 2
		MD5_CTX tmp;
		int i, s;
d908 2
a909 2
		if (rs->entropy_count / 8 > nbytes)
			rs->entropy_count -= nbytes * 8;
a913 1
		bzero(&tmp, sizeof(tmp));
d929 1
a929 4
		if (nbytes < sizeof(buffer) / 2)
			bcopy(buffer, buf, i = nbytes);
		else
			bcopy(buffer, buf, i = sizeof(buffer) / 2);
d939 1
@


1.76
log
@Fix a variable name in a comment; from Clint <cruoho@@gmail.com>; ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.75 2005/01/27 18:18:20 mickey Exp $	*/
d475 1
a475 1
static __inline void extract_entropy(register u_int8_t *, int);
d478 1
a478 1
static __inline void arc4_stir(void);
d520 1
a520 1
static __inline void
d885 1
a885 1
static __inline void
@


1.75
log
@poll can ever deny reads for srandom only; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.74 2005/01/27 18:12:32 millert Exp $	*/
d711 1
a711 1
 * The number "num" is also added to the pool - it should somehow describe
@


1.74
log
@In randompoll() the write check was overriding the results of the read check.
OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.73 2004/07/21 01:02:07 mickey Exp $	*/
d1048 3
a1050 1
		if (random_state.entropy_count > 0)
a1051 2
		else
			selrecord(p, &rnd_rsel);
@


1.73
log
@remove a few inlines from funcs that are used more than once and make code bigger; asked by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.72 2004/07/06 21:24:36 mickey Exp $	*/
d1044 1
a1044 1
	int revents = 0;
d1046 1
a1052 2
	if (events & (POLLOUT | POLLWRNORM))
		revents = events & (POLLOUT | POLLWRNORM); /* always writable */
@


1.73.2.1
log
@MFC:
Fix by millert@@

In randompoll() the write check was overriding the results of the read check.

Fix by mickey@@

poll can ever deny reads for srandom only

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.73 2004/07/21 01:02:07 mickey Exp $	*/
d1044 1
a1044 1
	int revents;
a1045 1
	revents = events & (POLLOUT | POLLWRNORM);	/* always writable */
d1047 3
a1049 1
		if (minor(dev) == RND_SRND && random_state.entropy_count <= 0)
a1050 2
		else
			revents |= events & (POLLIN | POLLRDNORM);
d1052 2
@


1.72
log
@use MALLOC/FREE for fixed size buffer allocations
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.71 2004/07/05 20:57:50 millert Exp $	*/
d474 1
a474 1
static __inline void add_entropy_words(const u_int32_t *, u_int n);
d477 1
a477 1
static __inline u_int8_t arc4_getbyte(void);
d500 1
a500 1
static __inline u_int8_t
d672 1
a672 1
static __inline void
@


1.71
log
@Allocate buffers in randomread and randomwrite via malloc instead
of from the stack.  Keeps us from running out of kernel stack during
stack-heavy networking load.  The bug manifests as a panic during
bootup with an fpu-related assertion failure on i386.
Fix from Christopher Pascoe; commit requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.70 2004/05/07 14:42:27 millert Exp $	*/
d968 1
a968 1
	buf = malloc(POOLBYTES, M_TEMP, M_WAITOK);
d1034 1
a1034 1
	free(buf, M_TEMP);
d1137 1
a1137 1
	buf = malloc(POOLBYTES, M_TEMP, M_WAITOK);
d1153 1
a1153 1
	free(buf, M_TEMP);
@


1.70
log
@Replace RSA-derived md5 code with code derived from Colin Plumb's PD version.
This moves md5.c out of libkern and into sys/crypto where it belongs (as
requested by markus@@).  Note that md5.c is still mandatory (dev/rnd.c uses it).
Verified with IPsec + hmac-md5 and tcp md5sig. OK henning@@ and hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.69 2004/04/02 20:34:43 mickey Exp $	*/
d269 1
d961 3
a963 2
	int	ret = 0;
	int	i;
d968 2
d971 1
a971 2
		u_int32_t buf[ POOLWORDS ];
		int	n = min(sizeof(buf), uio->uio_resid);
d1033 2
d1128 2
a1129 1
	int	ret = 0;
d1137 2
d1140 1
a1140 2
		u_int32_t	buf[ POOLWORDS ];
		u_short		n = min(sizeof(buf),uio->uio_resid);
d1153 1
@


1.69
log
@repair linuxisms tested on hppa, sparc, vax and i386; from Sven Dehmlow <sven_dehmlow@@gmx.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.68 2004/04/02 20:17:45 mickey Exp $	*/
a246 1
#include <sys/md5k.h>
d250 2
@


1.68
log
@kill _8 api completely
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.67 2004/03/15 14:17:25 mickey Exp $	*/
d195 2
a196 2
 * For example, on many Linux systems, the appropriate scripts are
 * usually /etc/rc.d/rc.local and /etc/rc.d/rc.0, respectively.
d202 1
a202 1
 * even if the system crashes without executing rc.0.)  Even with
d207 1
a207 1
 * Configuring the /dev/random driver under Linux
d210 4
a213 4
 * The /dev/random driver under Linux uses minor numbers 8 and 9 of
 * the /dev/mem major number (#1).  So if your system does not have
 * /dev/random and /dev/urandom created already, they can be created
 * by using the commands:
d215 3
a217 2
 *	mknod /dev/random c 1 8
 *	mknod /dev/urandom c 1 9
@


1.67
log
@per popular demand panic on premature arc4 initializations (would have paniced anyway elsewhere)
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.66 2003/11/03 18:24:28 tedu Exp $	*/
a584 9
static int arc4random_8(void);

static int
arc4random_8(void)
{
	arc4maybeinit();
	return arc4_getbyte();
}

d1017 1
d1019 1
a1019 1
				*cp++ = arc4random_8();
@


1.67.2.1
log
@MFC:
Fix by millert@@

Allocate buffers in randomread and randomwrite via malloc instead
of from the stack.  Keeps us from running out of kernel stack during
stack-heavy networking load.  The bug manifests as a panic during
bootup with an fpu-related assertion failure on i386.
Fix from Christopher Pascoe; commit requested by deraadt@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.67 2004/03/15 14:17:25 mickey Exp $	*/
a266 1
#define POOLBYTES (POOLWORDS*4)
d967 2
a968 3
	int		ret = 0;
	int		i;
	u_int32_t 	*buf;
a972 2
	MALLOC(buf, u_int32_t *, POOLBYTES, M_TEMP, M_WAITOK);

d974 2
a975 1
		int	n = min(POOLBYTES, uio->uio_resid);
a1035 2

	FREE(buf, M_TEMP);
d1129 1
a1129 2
	int		ret = 0;
	u_int32_t	*buf;
a1136 2
	MALLOC(buf, u_int32_t *, POOLBYTES, M_TEMP, M_WAITOK);

d1138 2
a1139 1
		u_short	n = min(POOLBYTES, uio->uio_resid);
a1151 1
	FREE(buf, M_TEMP);
@


1.67.2.2
log
@MFC:
Fix by millert@@

In randompoll() the write check was overriding the results of the read check.

Fix by mickey@@

poll can ever deny reads for srandom only

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.67.2.1 2004/07/17 02:57:54 brad Exp $	*/
d1050 1
a1050 1
	int revents;
a1051 1
	revents = events & (POLLOUT | POLLWRNORM);	/* always writable */
d1053 3
a1055 1
		if (minor(dev) == RND_SRND && random_state.entropy_count <= 0)
a1056 2
		else
			revents |= events & (POLLIN | POLLRDNORM);
d1058 2
@


1.66
log
@add arc4random_bytes.  input ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.65 2003/10/21 05:24:40 jmc Exp $	*/
d563 4
@


1.65
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.64 2003/09/23 16:51:12 millert Exp $	*/
d596 11
@


1.64
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.63 2003/08/15 20:32:16 tedu Exp $	*/
d346 1
a346 1
 * modulo the generator polymnomial.  Now, for random primitive polynomials,
@


1.63
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.62 2002/11/25 10:09:24 mickey Exp $	*/
d249 1
d1025 1
a1025 1
randomselect(dev, rw, p)
d1027 1
a1027 1
	int	rw;
d1030 3
a1032 2
	switch (rw) {
	case FREAD:
d1034 1
a1034 1
			return (1);
a1036 3
		break;
	case FWRITE:
		return 1;
d1038 4
a1041 1
	return 0;
@


1.63.2.1
log
@MFC:
Fix by millert@@

Allocate buffers in randomread and randomwrite via malloc instead
of from the stack.  Keeps us from running out of kernel stack during
stack-heavy networking load.  The bug manifests as a panic during
bootup with an fpu-related assertion failure on i386.
Fix from Christopher Pascoe; commit requested by deraadt@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.63 2003/08/15 20:32:16 tedu Exp $	*/
a265 1
#define POOLBYTES (POOLWORDS*4)
d951 2
a952 3
	int		ret = 0;
	int		i;
	u_int32_t 	*buf;
a956 2
	MALLOC(buf, u_int32_t *, POOLBYTES, M_TEMP, M_WAITOK);

d958 2
a959 1
		int	n = min(POOLBYTES, uio->uio_resid);
a1019 2

	FREE(buf, M_TEMP);
d1112 1
a1112 2
	int		ret = 0;
	u_int32_t	*buf;
a1119 2
	MALLOC(buf, u_int32_t *, POOLBYTES, M_TEMP, M_WAITOK);

d1121 2
a1122 1
		u_short	n = min(POOLBYTES, uio->uio_resid);
a1134 1
	FREE(buf, M_TEMP);
@


1.62
log
@protect the arc4_getbyte() w/ an splhigh since
there by multiple pathways, where it worked
until read from userland in big buffers and some luck.
does not cause a memory trashing, but rather may
mess up the arc4 state such that it will not generate
one particular value until a stir. sigh.
was reported by multiple people over some time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.61 2002/11/11 19:53:24 mickey Exp $	*/
d1166 1
a1166 1
		if (suser(p->p_ucred, &p->p_acflag) != 0)
d1178 1
a1178 1
		if (suser(p->p_ucred, &p->p_acflag) != 0)
d1187 1
a1187 1
		if (suser(p->p_ucred, &p->p_acflag) != 0)
d1198 1
a1198 1
		if (suser(p->p_ucred, &p->p_acflag) != 0)
@


1.61
log
@grammar fixens from Andrey Smagin
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.60 2002/06/19 03:03:28 mickey Exp $	*/
d499 2
a500 1
	register u_int8_t si, sj;
d502 1
d511 3
a513 1
	return arc4random_state.s[(si + sj) & 0xff];
@


1.60
log
@add kqfilter for random, regress is coming
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.59 2002/06/14 00:07:57 mickey Exp $	*/
d4 1
a4 1
 * random.c -- A strong random number generator
d59 1
a59 1
 * pseudo-random numbers, which can easily generated by using a
d62 1
a62 1
 * applications this is not acceptable.  So instead, we must try to
d64 1
a64 1
 * must be hard for outside attackers to observe, and use that to
d71 2
a72 2
 * outside observer to measure.  Randomness from these sources are
 * added to an "entropy pool", which is mixed using a CRC-like function.
d81 1
a81 1
 * hash of the contents of the "entropy pool".  The MD5 hash avoids
d96 1
a96 1
 * not believed to be feasible, but there is a remote possibility.
d103 2
a104 2
 * There are three exported interfaces; the first is one designed to
 * be used from within the kernel:
d111 1
a111 1
 * The two other interfaces are two character devices /dev/random and
d119 1
a119 1
 * as many bytes as are requested.  As more and more random bytes are
d139 1
a139 1
 * on some cryptographic and system chipsets. entropy accounting
d152 1
a152 1
 * character as random inputs into the "entropy pool".
d159 1
a159 1
 * a lot of entropy, i'd blame on low resolution audio clock generators.
d162 3
a164 3
 * try to estimate how many bits of randomness a particular randomness
 * source.  They do this by keeping track of the first and second order
 * deltas of the event timings.
d176 1
a176 1
 * following lines an appropriate script which is run during the boot
d187 2
a188 2
 * and the following lines in an appropriate script which is run as
 * the system is shutdown:
d199 1
a199 1
 * to be saved at shut-down time and reloaded into the entropy pool at
d224 1
a224 1
 * number generator, which speed up the mixing function of the entropy
d229 1
a229 1
 * not be attributed to the Phil, Colin, or any of authors of PGP.
d329 2
a330 2
 * that we want of it is that it be a good non-cryptographic hash;
 * i.e. it not produce collisions when fed "random" data of the sort
d485 2
a486 2
 * The initialization function here has been modified not to discard
 * old state, and its input always includes the time of day in
d490 2
a491 2
 * but makes it impossible to use this code for encryption--There is
 * no way ever to reproduce the same stream of random bytes.
d645 1
a645 1
 * This function adds a byte into the entropy "pool".  It does not
d693 1
a693 1
 * This function adds entropy to the entropy "pool" by using timing
d698 2
a699 2
 * the type of event which just happened.  This is currently 0-255 for
 * keyboard scan codes, and 256 upwards for interrupts.
d731 1
a731 1
	 * Calculate number of bits of randomness we probably
d866 1
a866 1
 * This function extracts randomness from the "entropy pool", and
@


1.59
log
@from freebsd:
Throw away the first N words of output, as suggested in the
paper "Weaknesses in the Key Scheduling Algorithm of RC4"
by Fluher, Mantin, and Shamir.  (N = 256 in our case.)
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.58 2002/05/27 01:59:58 deraadt Exp $	*/
d6 1
a6 1
 * Copyright (c) 1996, 1997, 2000, 2001 Michael Shalayeff.
a43 1

d400 13
d850 2
d1027 5
a1031 1
		return random_state.entropy_count > 0;
d1036 64
@


1.58
log
@kill unused arc4random_8() API
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.57 2002/04/01 08:25:58 mickey Exp $	*/
d484 16
a529 6
}

static __inline u_int8_t
arc4_getbyte(void)
{
	register u_int8_t si, sj;
d531 7
a537 9
	rndstats.arc4_reads++;
	arc4random_state.cnt++;
	arc4random_state.i++;
	si = arc4random_state.s[arc4random_state.i];
	arc4random_state.j += si;
	sj = arc4random_state.s[arc4random_state.j];
	arc4random_state.s[arc4random_state.i] = sj;
	arc4random_state.s[arc4random_state.j] = si;
	return arc4random_state.s[(si + sj) & 0xff];
@


1.57
log
@a few typos from pechkin
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.56 2002/03/21 23:02:22 mickey Exp $	*/
d556 3
a558 1
int
@


1.56
log
@on extract: better spl granularity, make sure pool is updated between runs; later pt out by camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.55 2002/03/14 01:26:52 millert Exp $	*/
d315 1
a315 1
 * well to make a twisted Generalized Feedback Shift Reigster
d349 1
a349 1
 * polynomail, so if it is chosen at random, an attacker can never force
d477 1
a477 1
 * random numbers.  This increases the strenght of the random stream,
d547 1
a547 1
 * actuall stirring happens on any access attempt.
@


1.55
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.54 2002/01/31 00:16:42 mickey Exp $	*/
d869 1
a871 1
		splx(s);
d896 1
@


1.54
log
@drop the low drop bits number to 10 drop
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.53 2002/01/10 18:49:07 mickey Exp $	*/
d456 1
a456 1
void dequeue_randomness __P((void *));
d458 2
a459 2
static __inline void add_entropy_words __P((const u_int32_t *, u_int n));
static __inline void extract_entropy __P((register u_int8_t *, int));
d461 4
a464 4
static __inline u_int8_t arc4_getbyte __P((void));
static __inline void arc4_stir __P((void));
void arc4_reinit __P((void *v));
void arc4maybeinit __P((void));
@


1.53
log
@return ENOTTY not EINVAL in default: in *ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.52 2002/01/03 09:23:22 nordin Exp $	*/
d359 1
a359 1
#define QEVSBITS 12
@


1.52
log
@Restore entropy_count calculation. mickey@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.51 2001/12/29 17:22:41 mickey Exp $	*/
d1110 1
a1110 1
		ret = EINVAL;
@


1.51
log
@finer spl granularity, allowing ints to happen; pointed out and tested on vax by hugh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.50 2001/09/24 02:23:44 mickey Exp $	*/
d865 2
a866 2
		if (rs->entropy_count / 8 > i)
			rs->entropy_count -= i * 8;
@


1.50
log
@there was a possible overrun in prev folding length fix.
however i was lucky enough so it worked.
anyway, this fixes the problem and seems to run very
much alright on sparc at least.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.49 2001/09/23 10:16:27 mickey Exp $	*/
a852 1
	MD5_CTX tmp;
a856 5
	if (rs->entropy_count / 8 > nbytes)
		rs->entropy_count -= nbytes*8;
	else
		rs->entropy_count = 0;

d858 2
a859 1
		int i;
d863 1
d865 4
d870 2
a885 3
		/* Modify pool so next hash will produce different results */
		add_entropy_words((u_int32_t*)buffer, sizeof(buffer)/8);

d893 2
a898 1
	bzero(&tmp, sizeof(tmp));
d923 1
a923 1
	int	s, i;
a931 1
		s = splhigh();
a987 1
		splx(s);
@


1.50.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.54 2002/01/31 00:16:42 mickey Exp $	*/
d359 1
a359 1
#define QEVSBITS 10
d853 1
d858 5
d864 1
a864 2
		MD5_CTX tmp;
		int i, s;
a867 1
		s = splhigh();
a868 4
		if (rs->entropy_count / 8 > nbytes)
			rs->entropy_count -= nbytes * 8;
		else
			rs->entropy_count = 0;
a869 2
		bzero(&tmp, sizeof(tmp));
		splx(s);
d884 3
a893 2

		/* Modify pool so next hash will produce different results */
d898 1
d923 1
a923 1
	int	i;
d932 1
d989 1
d1112 1
a1112 1
		ret = ENOTTY;
@


1.50.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.50.4.1 2002/01/31 22:55:29 niklas Exp $	*/
d315 1
a315 1
 * well to make a twisted Generalized Feedback Shift Register
d349 1
a349 1
 * polynomial, so if it is chosen at random, an attacker can never force
d456 1
a456 1
void dequeue_randomness(void *);
d458 2
a459 2
static __inline void add_entropy_words(const u_int32_t *, u_int n);
static __inline void extract_entropy(register u_int8_t *, int);
d461 4
a464 4
static __inline u_int8_t arc4_getbyte(void);
static __inline void arc4_stir(void);
void arc4_reinit(void *v);
void arc4maybeinit(void);
d477 1
a477 1
 * random numbers.  This increases the strength of the random stream,
d547 1
a547 1
 * actual stirring happens on any access attempt.
d556 1
a556 3
static int arc4random_8(void);

static int
a868 1
		splx(s);
d871 1
a895 1
		dequeue_randomness(&random_state);
@


1.50.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.50.4.2 2002/06/11 03:42:15 art Exp $	*/
d6 1
a6 1
 * Copyright (c) 1996, 1997, 2000-2002 Michael Shalayeff.
d44 1
a400 13
struct selinfo rnd_rsel, rnd_wsel;

void filt_rndrdetach(struct knote *kn);
int filt_rndread(struct knote *kn, long hint);

struct filterops rndread_filtops =
	{ 1, NULL, filt_rndrdetach, filt_rndread};

void filt_rndwdetach(struct knote *kn);
int filt_rndwrite(struct knote *kn, long hint);

struct filterops rndwrite_filtops =
	{ 1, NULL, filt_rndwdetach, filt_rndwrite};
a483 16
static __inline u_int8_t
arc4_getbyte(void)
{
	register u_int8_t si, sj;

	rndstats.arc4_reads++;
	arc4random_state.cnt++;
	arc4random_state.i++;
	si = arc4random_state.s[arc4random_state.i];
	arc4random_state.j += si;
	sj = arc4random_state.s[arc4random_state.j];
	arc4random_state.s[arc4random_state.i] = sj;
	arc4random_state.s[arc4random_state.j] = si;
	return arc4random_state.s[(si + sj) & 0xff];
}

d514 6
d521 9
a529 7
	/*
	 * Throw away the first N words of output, as suggested in the
	 * paper "Weaknesses in the Key Scheduling Algorithm of RC4"
	 * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)
	 */
	for (n = 0; n < 256 * 4; n++)
		arc4_getbyte();
a829 2
			selwakeup(&rnd_rsel);
			KNOTE(&rnd_rsel.si_note, 0);
d1005 1
a1005 5
		if (random_state.entropy_count > 0)
			return (1);
		else
			selrecord(p, &rnd_rsel);
		break;
a1009 64
}

int
randomkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &rnd_rsel.si_note;
		kn->kn_fop = &rndread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &rnd_wsel.si_note;
		kn->kn_fop = &rndwrite_filtops;
		break;
	default:
		return (1);
	}
	kn->kn_hook = (void *)&random_state;

	s = splhigh();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
filt_rndrdetach(struct knote *kn)
{
	int s = splhigh();

	SLIST_REMOVE(&rnd_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_rndread(kn, hint)
	struct knote *kn;
	long hint;
{
	struct random_bucket *rs = (struct random_bucket *)kn->kn_hook;

	kn->kn_data = (int)rs->entropy_count;
	return rs->entropy_count > 0;
}

void
filt_rndwdetach(struct knote *kn)
{
	int s = splhigh();

	SLIST_REMOVE(&rnd_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_rndwrite(kn, hint)
	struct knote *kn;
	long hint;
{
	return (1);
@


1.50.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * rnd.c -- A strong random number generator
d59 1
a59 1
 * pseudo-random numbers, which can be easily generated by using an
d62 1
a62 1
 * applications this is not acceptable.  Instead, we must try to
d64 1
a64 1
 * must be hard for outside attackers to observe and use to
d71 2
a72 2
 * outside observer to measure.  Randomness from these sources is
 * added to the "entropy pool", which is mixed using a CRC-like function.
d81 1
a81 1
 * hash of the content of the entropy pool.  The MD5 hash avoids
d96 1
a96 1
 * believed to be not feasible, but there is a remote possibility.
d103 2
a104 2
 * There are three exported interfaces.
 * The first one is designed to be used from within the kernel:
d111 1
a111 1
 * Two other interfaces are two character devices /dev/random and
d119 1
a119 1
 * as many bytes as were requested.  As more and more random bytes
d139 1
a139 1
 * on some cryptographic and system chipsets.  Entropy accounting
d152 1
a152 1
 * character as random inputs into the entropy pool.
d159 1
a159 1
 * a lot of entropy. I'd blame it on low resolution audio clock generators.
d162 3
a164 3
 * try to estimate how many bits of randomness are in a particular
 * randomness source.  They do this by keeping track of the first and
 * second order deltas of the event timings.
d176 1
a176 1
 * following lines in appropriate script which is run during the boot
d187 2
a188 2
 * and the following lines in appropriate script which is run when
 * the system is shutting down:
d199 1
a199 1
 * to be saved at shutdown time and reloaded into the entropy pool at
d224 1
a224 1
 * number generator, which speeds up the mixing function of the entropy
d229 1
a229 1
 * not be attributed to the Phil, Colin, or any of the authors of PGP.
d329 2
a330 2
 * we want from it is to be a good non-cryptographic hash -
 * i.e. to not produce collisions when fed "random" data of the sort
d485 2
a486 2
 * The initialization function here has been modified to not discard
 * the old state, and it's input always includes the time of day in
d490 2
a491 2
 * but makes it impossible to use this code for encryption, since there
 * is no way to ever reproduce the same stream of random bytes.
d499 1
a499 2
	register u_int8_t si, sj, ret;
	int s;
a500 1
	s = splhigh();
d509 1
a509 3
	ret = arc4random_state.s[(si + sj) & 0xff];
	splx(s);
	return (ret);
d645 1
a645 1
 * This function adds a byte into the entropy pool.  It does not
d693 1
a693 1
 * This function adds entropy to the entropy pool by using timing
d698 2
a699 2
 * the type of event which just happened.  Currently the values of 0-255
 * are for keyboard scan codes, 256 and upwards - for interrupts.
d731 1
a731 1
	 * Calculate the number of bits of randomness that we probably
d866 1
a866 1
 * This function extracts randomness from the entropy pool, and
@


1.49
log
@oops, fix the after folding sizes
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.48 2001/06/24 20:52:05 mickey Exp $	*/
d864 1
a864 7
		register u_char *p = buf;
		register int i = sizeof(buffer)/2;

		if (i > nbytes) {
			i = nbytes;
			p = buffer;
		}
d869 1
a869 1
		MD5Final(p, &tmp);
d875 8
a882 8
		p[0] ^= p[15];
		p[1] ^= p[14];
		p[2] ^= p[13];
		p[3] ^= p[12];
		p[4] ^= p[11];
		p[5] ^= p[10];
		p[6] ^= p[ 9];
		p[7] ^= p[ 8];
d885 1
a885 1
		add_entropy_words((u_int32_t*)p, sizeof(buffer)/8);
d888 4
a891 2
		if (i < sizeof(buffer)/2)
			bcopy(buffer, buf, i);
@


1.48
log
@only run timeout if stirring happened, save cycles for mass energy conservation
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d865 1
a865 1
		register int i = sizeof(buffer);
d891 1
a891 1
		add_entropy_words((u_int32_t*)p, sizeof(buffer)/4);
d894 1
a894 1
		if (i < sizeof(buffer))
@


1.47
log
@reapply 1.39 once again, it seems i've fixed two bugs in it and it
works ok on sparc and i386 now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.46 2001/01/17 01:59:50 mickey Exp $	*/
d462 1
a462 1
void arc4_stir __P((void));
d464 1
d484 1
a484 1
void
d532 1
a532 1
static __inline void
d535 2
d540 2
d545 4
a552 2
	extern int hz;

a553 2
	/* 10 minutes, per dm@@'s suggestion */
	timeout_add(&arc4_timeout, 10 * 60 * hz);
d755 1
a755 1
		 * in hope for dequeuing to be more sourcefull
@


1.46
log
@advance through buffer, leftovers from singular version; from Henric Jungheim <henric@@aimnet.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.45 2000/10/22 01:08:52 mickey Exp $	*/
d6 1
a6 1
 * Copyright (c) 1996, 1997, 2000 Michael Shalayeff.
a231 7
 * The code for SHA transform was taken from Peter Gutmann's
 * implementation, which has been placed in the public domain.
 * The code for MD5 transform was taken from Colin Plumb's
 * implementation, which has been placed in the public domain.
 * The MD5 cryptographic checksum was devised by Ronald Rivest, and is
 * documented in RFC 1321, "The MD5 Message Digest Algorithm".
 *
d357 2
a358 2
#define QEVLEN 96
#define QEVSLOW 64 /* yet another 0.75 for 60-minutes hour /-; */
a367 1
	u_int	queued;
d376 2
a377 2
	u_char	dont_count_entropy : 1;
	u_char	max_entropy : 1;
a387 1
	struct rand_event *re_next;
d389 1
a389 1
	u_char re_nbits;
d399 2
a400 2
struct rand_event *rnd_event_q;
struct rand_event *rnd_event_free;
d416 40
d547 2
a548 1
	timeout_add(&arc4_timeout, 10*60*hz);
a569 2
	struct timeval tv;
	struct rand_event *rep;
d578 3
d589 1
a589 3
	rnd_event_free = rnd_event_space;
	for (rep = rnd_event_space; rep < &rnd_event_space[QEVLEN-1]; rep++)
		rep->re_next = rep + 1;
a591 3
	microtime(&tv);
	timeout_set(&rnd_timeout, dequeue_randomness, NULL);
	timeout_set(&arc4_timeout, arc4_reinit, NULL);
d593 1
a639 3
	u_int i;
	int new_rotate;
	u_int32_t w;
d642 2
a643 2
		w = roll(*buf, random_state.input_rotate);
		i = random_state.add_ptr =
d651 2
a652 4
		new_rotate = random_state.input_rotate + 14;
		if (i)
			new_rotate = random_state.input_rotate + 7;
		random_state.input_rotate = new_rotate & 31;
d655 6
a660 6
		w ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];
		w ^= random_state.pool[i];
d681 2
a682 1
	struct timer_rand_state *p;
d684 1
a684 1
	register struct rand_event *rep;
d686 4
a689 1
	u_int	time, nbits;
d752 1
a752 1
		if (random_state.queued > QEVSLOW && nbits < QEVSBITS) {
d763 1
a763 1
	if ((rep = rnd_event_free) == NULL) {
a767 1
	rnd_event_free = rep->re_next;
a773 5
	rep->re_next = rnd_event_q;
	rnd_event_q = rep;
	rep = rep->re_next;
	random_state.queued++;

d779 1
a779 1
	if (++random_state.queued > QEVSLOW/2 && !random_state.tmo) {
d790 1
d792 1
a792 1
	u_int32_t val, time;
d799 2
a800 9
	do {
		s = splhigh();
		if (rnd_event_q == NULL) {
			splx(s);
			break;
		}
		rep = rnd_event_q;
		rnd_event_q = rep->re_next;
		random_state.queued--;
d802 2
a803 2
		val = rep->re_val;
		time = rep->re_time;
a804 3

		rep->re_next = rnd_event_free;
		rnd_event_free = rep;
d807 1
a807 2
		add_entropy_words(&val, 1);
		add_entropy_words(&time, 1);
d810 3
a812 3
		random_state.entropy_count += nbits;
		if (random_state.entropy_count > POOLBITS)
			random_state.entropy_count = POOLBITS;
d814 1
a814 2
		if (random_state.entropy_count > 8 &&
		    random_state.asleep != 0) {
d818 2
a819 2
				    random_state.asleep,
				    random_state.entropy_count);
d821 2
a822 2
			random_state.asleep--;
			wakeup(&random_state.asleep);
a823 1
	} while(1);
d825 5
a829 1
	random_state.tmo = 0;
d847 1
d853 2
a854 6
	/* Redundant, but just in case... */
	if (random_state.entropy_count > POOLBITS)
		random_state.entropy_count = POOLBITS;

	if (random_state.entropy_count / 8 > nbytes)
		random_state.entropy_count -= nbytes*8;
d856 1
a856 1
		random_state.entropy_count = 0;
d869 1
a869 2
		MD5Update(&tmp, (u_int8_t*)random_state.pool,
		    sizeof(random_state.pool));
@


1.45
log
@oops; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.44 2000/10/20 03:30:05 mickey Exp $	*/
d615 1
a615 1
	while (n--) {
@


1.45.2.1
log
@Pull in patch from current:
Fix (mickey):
advance through buffer, leftovers from singular version; from Henric Jungheim <henric@@aimnet.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.45 2000/10/22 01:08:52 mickey Exp $	*/
d615 1
a615 1
	for (; n--; buf++) {
@


1.44
log
@fix ioctls; pointed out by Pawel Krawczyk <http://ceti.pl/~kravietz/>
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.43 2000/08/21 01:52:18 jason Exp $	*/
a1063 1
			printf("%d\n", cnt);
@


1.43
log
@fix indentation from 1.41 addition
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.42 2000/07/18 17:32:25 mickey Exp $	*/
d1040 1
a1040 1
	int	ret = 0;
d1055 3
a1057 2
		ret = copyout(&random_state.entropy_count, data,
		    sizeof(random_state.entropy_count));
d1063 3
a1065 1
			copyin(&cnt, data, sizeof(cnt));
d1069 1
d1075 2
a1076 1
		else
d1078 2
d1086 2
a1087 1
		else
d1089 2
d1095 2
a1096 1
		else
d1098 2
@


1.42
log
@do not call arc4_stir() on pool overflow.
calling it would hit perfomance in two evil ways,
by delaying queue processing and hitting on arc4
quality. basic idea was expressed by dm@@ some time ago
when we were investigating poor arc4 quality.
then, numbers showed how badly it hits on us.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.41 2000/06/18 16:32:19 millert Exp $	*/
d1046 1
a1046 1
        case FIOASYNC:
d1050 1
a1050 1
        case FIONBIO:
@


1.41
log
@Support FIONBIO and FIOASYNC.  FIOASYNC is more or less a no-op>
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.40 2000/06/16 19:18:51 deraadt Exp $	*/
a793 5
		/* Prevent overflow */
		if ((random_state.entropy_count + nbits) > POOLBITS &&
		    arc4random_state.cnt > 253)
			arc4_stir();

d797 1
a798 1
		rndstats.rnd_total += nbits;
@


1.40
log
@undo latest problem. breaks the sparc.  diff is too large, we are not debugging it for you
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.38 2000/04/18 15:11:28 hugh Exp $	*/
d1051 8
@


1.39
log
@replace linked lists for event queue with circular buffer,
which gives two advantages -- faster and smaller.
do not arc4_stir on pool overflow, it takes too much time, instead
just hash data in and keep entropy count trim.
some minor cleanups here and there.
fixes overdropping of entropy on non-idle system load.
provos@@ ok
@
text
@d232 7
d364 2
a365 2
#define QEVLEN (1024 / sizeof(struct rand_event))
#define QEVSLOW (QEVLEN * 3 / 4) /* yet another 0.75 for 60-minutes hour /-; */
d375 1
d396 1
d398 1
a398 1
	u_int re_nbits;
d408 2
a409 1
struct rand_event *rnd_event_head, *rnd_event_tail;
a424 40
/* must be called at a proper spl, returns ptr to the next event */
static __inline struct rand_event *
rnd_get(void)
{
	struct rand_event *p = rnd_event_tail;

	if (p == rnd_event_head)
		return NULL;

	if (p + 1 == &rnd_event_space[QEVLEN])
		rnd_event_tail = rnd_event_space;
	else
		rnd_event_tail++;

	return p;
}

/* must be called at a proper spl, returns next available item */
static __inline struct rand_event *
rnd_put(void)
{
	struct rand_event *p = rnd_event_head + 1;

	if (p == &rnd_event_space[QEVLEN])
		p = rnd_event_space;

	if (p == rnd_event_tail)
		return NULL;

	return rnd_event_head = p;
}

/* must be called at a proper spl, returns number of items in the queue */
static __inline int
rnd_qlen(void)
{
	int len = rnd_event_head - rnd_event_tail;
	return (len < 0)? -len : len;
}

d538 2
a554 1

d556 3
a558 2
	rnd_event_head = rnd_event_tail = rnd_event_space;

d561 3
a564 4

	timeout_set(&rnd_timeout, dequeue_randomness, &random_state);
	timeout_set(&arc4_timeout, arc4_reinit, NULL);

d611 3
d616 2
a617 2
		register u_int32_t w = roll(*buf, random_state.input_rotate);
		register u_int i = random_state.add_ptr =
d625 4
a628 2
		random_state.input_rotate =
		    (random_state.input_rotate + (i? 7 : 14)) & 31;
d631 6
a636 6
		w ^= random_state.pool[(i+TAP1) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP2) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP3) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP4) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP5) & (POOLWORDS-1)] ^
		     random_state.pool[i];
a656 1
	struct random_bucket *rs = &random_state;
d724 1
a724 1
		if (rnd_qlen() > QEVSLOW && nbits < QEVSBITS) {
d735 1
a735 1
	if ((rep = rnd_put()) == NULL) {
d740 1
d747 5
d757 1
a757 1
	if (rnd_qlen() > QEVSLOW/2 && !rs->tmo) {
a767 1
	struct random_bucket *rs = v;
d769 1
a769 1
	u_int32_t buf[2];
d776 9
a784 2
	s = splhigh();
	while ((rep = rnd_get())) {
d786 2
a787 2
		buf[0] = rep->re_time;
		buf[1] = rep->re_val;
d789 3
d794 4
a797 1
		add_entropy_words(buf, 2);
d799 4
d804 2
a805 3
		rs->entropy_count += nbits;
		if (rs->entropy_count > POOLBITS)
			rs->entropy_count = POOLBITS;
d807 2
a808 1
		if (rs->asleep && rs->entropy_count > 8) {
d812 2
a813 2
				    rs->asleep,
				    rs->entropy_count);
d815 2
a816 2
			rs->asleep--;
			wakeup((void *)&rs->asleep);
d818 1
d820 1
a820 5
		s = splhigh();
	}

	rs->tmo = 0;
	splx(s);
a837 1
	struct random_bucket *rs = &random_state;
d843 6
a848 2
	if (rs->entropy_count / 8 > nbytes)
		rs->entropy_count -= nbytes*8;
d850 1
a850 1
		rs->entropy_count = 0;
d863 2
a864 1
		MD5Update(&tmp, (u_int8_t*)rs->pool, sizeof(rs->pool));
@


1.38
log
@Double usage of random() in the pseudo device to avoid setting
every 32nd bit to zero in the output.  Checked by mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.37 2000/04/14 14:40:50 mickey Exp $	*/
a231 7
 * The code for SHA transform was taken from Peter Gutmann's
 * implementation, which has been placed in the public domain.
 * The code for MD5 transform was taken from Colin Plumb's
 * implementation, which has been placed in the public domain.
 * The MD5 cryptographic checksum was devised by Ronald Rivest, and is
 * documented in RFC 1321, "The MD5 Message Digest Algorithm".
 *
d357 2
a358 2
#define QEVLEN 96
#define QEVSLOW 64 /* yet another 0.75 for 60-minutes hour /-; */
a367 1
	u_int	queued;
a387 1
	struct rand_event *re_next;
d389 1
a389 1
	u_char re_nbits;
d399 1
a399 2
struct rand_event *rnd_event_q;
struct rand_event *rnd_event_free;
d415 40
a567 2
	struct timeval tv;
	struct rand_event *rep;
d583 1
d585 2
a586 3
	rnd_event_free = rnd_event_space;
	for (rep = rnd_event_space; rep < &rnd_event_space[QEVLEN-1]; rep++)
		rep->re_next = rep + 1;
d589 3
a591 2
	microtime(&tv);
	timeout_set(&rnd_timeout, dequeue_randomness, NULL);
d593 1
a593 1
	arc4_reinit(NULL);
a639 3
	u_int i;
	int new_rotate;
	u_int32_t w;
d642 2
a643 2
		w = roll(*buf, random_state.input_rotate);
		i = random_state.add_ptr =
d651 2
a652 4
		new_rotate = random_state.input_rotate + 14;
		if (i)
			new_rotate = random_state.input_rotate + 7;
		random_state.input_rotate = new_rotate & 31;
d655 6
a660 6
		w ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];
		w ^= random_state.pool[i];
d681 1
d749 1
a749 1
		if (random_state.queued > QEVSLOW && nbits < QEVSBITS) {
d760 1
a760 1
	if ((rep = rnd_event_free) == NULL) {
a764 1
	rnd_event_free = rep->re_next;
a770 5
	rep->re_next = rnd_event_q;
	rnd_event_q = rep;
	rep = rep->re_next;
	random_state.queued++;

d776 1
a776 1
	if (++random_state.queued > QEVSLOW/2 && !random_state.tmo) {
d787 1
d789 1
a789 1
	u_int32_t val, time;
d796 2
a797 9
	do {
		s = splhigh();
		if (rnd_event_q == NULL) {
			splx(s);
			break;
		}
		rep = rnd_event_q;
		rnd_event_q = rep->re_next;
		random_state.queued--;
d799 2
a800 2
		val = rep->re_val;
		time = rep->re_time;
a801 3

		rep->re_next = rnd_event_free;
		rnd_event_free = rep;
d804 1
a804 4
		/* Prevent overflow */
		if ((random_state.entropy_count + nbits) > POOLBITS &&
		    arc4random_state.cnt > 253)
			arc4_stir();
a805 4
		add_entropy_words(&val, 1);
		add_entropy_words(&time, 1);

		random_state.entropy_count += nbits;
d807 3
a809 2
		if (random_state.entropy_count > POOLBITS)
			random_state.entropy_count = POOLBITS;
d811 1
a811 2
		if (random_state.entropy_count > 8 &&
		    random_state.asleep != 0) {
d815 2
a816 2
				    random_state.asleep,
				    random_state.entropy_count);
d818 2
a819 2
			random_state.asleep--;
			wakeup(&random_state.asleep);
a820 1
	} while(1);
d822 5
a826 1
	random_state.tmo = 0;
d844 1
d850 2
a851 6
	/* Redundant, but just in case... */
	if (random_state.entropy_count > POOLBITS)
		random_state.entropy_count = POOLBITS;

	if (random_state.entropy_count / 8 > nbytes)
		random_state.entropy_count -= nbytes*8;
d853 1
a853 1
		random_state.entropy_count = 0;
d866 1
a866 2
		MD5Update(&tmp, (u_int8_t*)random_state.pool,
		    sizeof(random_state.pool));
@


1.38.2.1
log
@Pull in patch from current:
Patch (millert):
upport FIONBIO and FIOASYNC.  FIOASYNC is more or less a no-op>
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.41 2000/06/18 16:32:19 millert Exp $	*/
a1050 8
	case FIOASYNC:
		/* rnd has no async flag in softc so this is really a no-op. */
		break;

	case FIONBIO:
		/* Handled in the upper FS layer. */
		break;

@


1.37
log
@this should fix the alpha; closes PR kernel/1189
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.36 2000/04/13 13:48:29 mickey Exp $	*/
d970 1
a970 1
				buf[i] = random();
@


1.36
log
@better has when adding entropy to the pool.
bigger pool (4k).
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.35 2000/04/10 19:44:38 mickey Exp $	*/
d1048 1
a1048 1
	add_timer_randomness((int)p);
d1088 2
a1089 1
	add_timer_randomness((int)p);
@


1.35
log
@add support for more random sources.
make it easy to add more in the future.
make extract_entropy() faster.
more accurate stats.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.34 2000/03/19 17:38:03 mickey Exp $	*/
d6 1
a6 1
 * Copyright (c) 1996, 1997 Michael Shalayeff.
d8 1
a8 1
 * Version 1.00, last modified 26-May-96
d10 2
a11 1
 * Copyright Theodore Ts'o, 1994, 1995, 1996.  All rights reserved.
d131 3
a133 3
 * 	void add_true_randomness(int data);
 * 	void add_timer_randomness(int data);
 * 	void add_mouse_randomness(int mouse_data);
d136 2
a137 2
 * 	void add_disk_randomness(int n);
 * 	void add_audio_randomness(int n);
d223 5
a227 8
 * from the Pretty Good Privacy's random number generator, and from
 * private discussions with Phil Karn.  Colin Plumb provided a faster
 * random number generator, which speed up the mixing function of the
 * entropy pool, taken from PGP 3.0 (under development).  It has since
 * been modified by myself to provide better mixing in the case where
 * the input values to add_entropy_word() are mostly small numbers.
 * Dale Worley has also contributed many useful ideas and suggestions
 * to improve this driver.
d232 2
d235 2
a236 2
 * implementation, which has been placed in the public domain.  The
 * MD5 cryptographic checksum was devised by Ronald Rivest, and is
d274 30
a303 6
#if POOLWORDS == 128
#define TAP1    99     /* The polynomial taps */
#define TAP2    59
#define TAP3    31
#define TAP4    9
#define TAP5    7
d305 11
a315 5
#define TAP1    62      /* The polynomial taps */
#define TAP2    38
#define TAP3    10
#define TAP4    6
#define TAP5    1
d320 43
d383 1
d389 2
a392 2
	u_int8_t s[256];
	u_int	cnt;
d415 11
a425 1
void dequeue_randomness __P((void *v));
d427 1
a427 1
static __inline void add_entropy_words __P((const u_int32_t *, u_int));
d607 19
a625 7
	for (; n--; buf++) {

		register u_int32_t w = (*buf << random_state.input_rotate) |
			(*buf >> (32 - random_state.input_rotate));
		register u_int i = random_state.add_ptr =
		    (random_state.add_ptr - 1) & (POOLWORDS-1);

d627 2
a628 10
			random_state.input_rotate =
				(random_state.input_rotate + 7) & 31;
		else
			/*
			 * At the beginning of the pool, add an extra 7 bits
			 * rotation, so that successive passes spread the
			 * input bits across the pool evenly.
			 */
			random_state.input_rotate =
				(random_state.input_rotate + 14) & 31;
d637 1
a637 2
		/* Rotate w left 1 bit (stolen from SHA) and store */
		random_state.pool[i] = (w << 1) | (w >> 31);
d657 2
a658 1
	register struct timer_rand_state *p;
a659 1
	struct timeval	tv;
d664 1
a664 1
	if (state < 0 || RND_SRC_NUM <= state)
d681 4
a684 3
		register int	delta, delta2;
		delta = time - p->last_time;
		delta2 = delta - p->last_delta;
d688 1
d690 6
a695 1
		delta2 = delta >>= 1;
d729 2
a730 1
		p->last_delta = delta2;
d749 2
d758 1
a759 1
		random_state.tmo++;
d773 1
a773 1
	timeout_del(&rnd_timeout);	/* XXX just in case */
d840 1
a840 1
	
d842 1
a842 1
	
d881 1
a881 1
		add_entropy_words((u_int32_t *)p, sizeof(buffer)/4);
d1079 1
a1079 1
	case RNDCLRSTATS:	
@


1.34
log
@faster log2, more stats, lazy random stirring, more stats, less debug, help and ok from provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.33 1999/09/28 01:24:46 deraadt Exp $	*/
d9 1
a9 1
 * 
d24 1
a24 1
 * 
d30 1
a30 1
 * 
d45 2
a46 2
 * (now, with legal B.S. out of the way.....) 
 * 
d56 1
a56 1
 * 
d67 1
a67 1
 * 
d79 1
a79 1
 * 
d91 1
a91 1
 * 
d99 1
a99 1
 * 
d102 1
a102 1
 * 
d106 1
a106 1
 * 	void get_random_bytes(void *buf, int nbytes);
d110 1
a110 1
 * 
d117 1
a117 1
 * 
d126 1
a126 1
 * 
d129 5
a133 3
 * 
 * 	void add_mouse_randomness(u_int32_t mouse_data);
 * 	void add_net_randomness(int isr);
d135 11
a145 2
 * 	void add_disk_randomness(u_int32_t n);
 * 
d150 1
a150 1
 * 
d153 1
a153 1
 * 
d156 9
a164 4
 * 
 * All of these routines try to estimate how many bits of randomness a
 * particular randomness source.  They do this by keeping track of the
 * first and second order deltas of the event timings.
d168 1
a168 1
 * 
d177 1
a177 1
 * sequence: 
d182 1
a182 1
 * 	if [ -f /etc/random-seed ]; then
d184 1
a184 1
 * 	fi
d189 1
a189 1
 * 
d194 1
a194 1
 * 
d197 1
a197 1
 * 
d215 3
a217 3
 * 	mknod /dev/random c 1 8
 * 	mknod /dev/urandom c 1 9
 * 
d230 1
a230 1
 * 
d233 1
a233 1
 * 
d238 1
a238 1
 * 
d256 1
d290 4
a293 4
/* p60/256kL2 reported to have some drops w/ these numbers */
#define QEVLEN 40
#define QEVSLOW 32 /* yet another 0.75 for 60-minutes hour /-; */
#define QEVSBITS 6
d301 3
d310 2
a311 1
	u_char	dont_count_entropy:1;
d329 7
a335 4
/* tags for different random sources */
#define	ENT_NET		0x100
#define	ENT_DISK	0x200
#define ENT_TTY		0x300
d337 2
a339 12
static struct random_bucket random_state;
static int arc4random_uninitialized = 2;
static struct arc4_stream arc4_state;
static struct timer_rand_state mouse_timer_state;
static struct timer_rand_state extract_timer_state;
static struct timer_rand_state disk_timer_state;
static struct timer_rand_state net_timer_state;
static struct timer_rand_state tty_timer_state;
static struct rand_event event_space[QEVLEN];
static int rnd_attached = 0;
static struct rand_event *event_q = NULL;
static struct rand_event *event_free;
d341 1
a341 3
#ifndef MIN
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#endif
d343 1
a343 3
static __inline void add_entropy_word __P((const u_int32_t));
static void enqueue_randomness __P((register struct timer_rand_state*, u_int));
void dequeue_randomness __P((void *));
d345 1
a345 2
void	arc4_init __P((u_int8_t *, int));
static __inline void arc4_stir __P((void));
d347 2
d369 1
a369 1
arc4_init (register u_int8_t *data, int len)
d371 1
d373 2
a374 1
	register int n;
d376 9
a384 1
	arc4_state.i--;
d386 6
a391 5
		arc4_state.i = (arc4_state.i + 1) & 0xff;
		si = arc4_state.s[arc4_state.i];
		arc4_state.j = (arc4_state.j + si + data[n % len]) & 0xff;
		arc4_state.s[arc4_state.i] = arc4_state.s[arc4_state.j];
		arc4_state.s[arc4_state.j] = si;
d393 5
a397 2
	arc4_state.j = arc4_state.i;
	arc4_state.cnt = 0;
d401 1
a401 1
arc4_getbyte (void)
d406 8
a413 8
	arc4_state.cnt++;
	arc4_state.i = (arc4_state.i + 1) & 0xff;
	si = arc4_state.s[arc4_state.i];
	arc4_state.j = (arc4_state.j + si) & 0xff;
	sj = arc4_state.s[arc4_state.j];
	arc4_state.s[arc4_state.i] = sj;
	arc4_state.s[arc4_state.j] = si;
	return (arc4_state.s[(si + sj) & 0xff]);
d417 1
a417 1
arc4maybeinit (void)
d419 3
a421 6
	if (arc4random_uninitialized) {
		if (arc4random_uninitialized > 1
		    || random_state.entropy_count >= 128) {
			arc4random_uninitialized--;
			arc4_stir ();
		}
d425 10
d445 3
a447 15
	arc4maybeinit ();
	return ((arc4_getbyte () << 24) | (arc4_getbyte () << 16)
		| (arc4_getbyte () << 8) | arc4_getbyte ());
}

static __inline void
arc4_stir (void)
{
	u_int8_t buf[256];

	microtime ((struct timeval *) buf);
	get_random_bytes (buf + sizeof (struct timeval),
			  sizeof (buf) - sizeof (struct timeval));
	arc4_init (buf, sizeof (buf));
	rndstats.arc4_stirs++;
d466 3
a468 1
	extract_timer_state.dont_count_entropy = 1;
d471 3
a473 4

	bzero(&event_space, sizeof(event_space));
	event_free = event_space;
	for (rep = event_space; rep < &event_space[QEVLEN-1]; rep++)
d476 5
a480 3
		arc4_state.s[i] = i;
	microtime (&tv);
	arc4_init ((u_int8_t *) &tv, sizeof (tv));
d511 1
a511 1
 * 
d519 33
a551 30
add_entropy_word(input)
	const u_int32_t		input;
{
	u_int		i;
	u_int32_t	w;

	w = (input << random_state.input_rotate) |
		(input >> (32 - random_state.input_rotate));
	i = random_state.add_ptr = (random_state.add_ptr - 1) & (POOLWORDS-1);
	if (i)
		random_state.input_rotate =
			(random_state.input_rotate + 7) & 31;
	else
		/*
		 * At the beginning of the pool, add an extra 7 bits
		 * rotation, so that successive passes spread the
		 * input bits across the pool evenly.
		 */
		random_state.input_rotate =
			(random_state.input_rotate + 14) & 31;

	/* XOR in the various taps */
	w ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];
	w ^= random_state.pool[i];
	/* Rotate w left 1 bit (stolen from SHA) and store */
	random_state.pool[i] = (w << 1) | (w >> 31);
d566 1
a566 1
static void
d568 1
a568 2
	register struct timer_rand_state *state;
	u_int	val;
d570 2
a572 1
	register struct rand_event *rep;
d576 7
a582 1
	rndstats.rnd_enqs++;
d593 1
a593 1
	if (!state->dont_count_entropy) {
d595 2
a596 2
		delta = time - state->last_time;
		delta2 = delta - state->last_delta;
d600 2
a601 1
		delta2 = delta = MIN(delta, delta2) >> 1;
d626 5
a630 3
		rndstats.rnd_ed[nbits]++;

		if (rndstats.rnd_queued > QEVSLOW && nbits > QEVSBITS) {
d634 4
a637 3
		state->last_time = time;
		state->last_delta = delta2;
	}
d640 2
a641 1
	if ((rep = event_free) == NULL) {
a642 1
		rndstats.rnd_drops++;
d645 1
a645 1
	event_free = rep->re_next;
d647 1
a647 1
	rep->re_state = state;
d652 12
a663 3
	rep->re_next = event_q;
	event_q = rep;
	rep = rep->re_next;
a664 6
	rndstats.rnd_timer++;
	rndstats.rnd_queued++;

	if (rep == NULL)
		timeout(dequeue_randomness, NULL, 1);

d672 1
a672 1
	register u_int32_t val, time;
d676 1
d681 1
a681 1
		if (event_q == NULL) {
d683 1
a683 1
			return;
d685 4
a688 2
		rep = event_q;
		event_q = rep->re_next;
d692 3
a694 2
		rep->re_next = event_free;
		event_free = rep;
d699 1
a699 1
		    arc4_state.cnt > 253)
d702 2
a703 2
		add_entropy_word(val);
		add_entropy_word(time);
a709 1
		rndstats.rnd_queued--;
d711 1
a711 1
		    rndstats.rnd_asleep != 0) {
d714 3
a716 3
				printf("rnd: wakeup[%d]{%u}\n",
				       rndstats.rnd_asleep,
				       random_state.entropy_count);
d718 2
a719 2
			rndstats.rnd_asleep--;
			wakeup(&rndstats.rnd_asleep);
d723 1
a723 57
}

void
add_mouse_randomness(mouse_data)
	u_int32_t	mouse_data;
{
	/* Has randomattach run yet?  */
	if (!rnd_attached)
		return;

	rndstats.rnd_mouse++;
	enqueue_randomness(&mouse_timer_state, mouse_data);
}

void
add_net_randomness(isr)
	int	isr;
{
	/* Has randomattach run yet?  */
	if (!rnd_attached)
		return;

	rndstats.rnd_net++;
	enqueue_randomness(&net_timer_state, ENT_NET + isr);
}

void
add_disk_randomness(n)
	u_int32_t n;
{
	u_int8_t c;

	/* Has randomattach run yet?  */
	if (!rnd_attached)
		return;

	rndstats.rnd_disk++;
	c = n & 0xff;
	n >>= 8;
	c ^= n & 0xff;
	n >>= 8;
	c ^= n & 0xff;
	n >>= 8;
	c ^= n & 0xff;
	enqueue_randomness(&disk_timer_state, ENT_DISK + c);
}

void
add_tty_randomness(c)
	int	c;
{
	/* Has randomattach run yet?  */
	if (!rnd_attached)
		return;

	rndstats.rnd_tty++;
	enqueue_randomness(&tty_timer_state, ENT_TTY + c);
d729 1
a740 1
	int	i;
d742 1
d744 1
a744 1
	enqueue_randomness(&extract_timer_state, nbytes);
d747 1
a747 1
	if (random_state.entropy_count > POOLBITS) 
d750 1
a750 1
	if (random_state.entropy_count / 8 >= nbytes)
d756 8
d766 3
a768 13

		for (i = 0; i < POOLWORDS; i += 16)
			MD5Update(&tmp, (u_int8_t*)random_state.pool+i, 16);

		/* Modify pool so next hash will produce different results */
		for (i = 0; i < sizeof(tmp.buffer)/sizeof(tmp.buffer[0]); i++)
			add_entropy_word(tmp.buffer[i]);
		/*
		 * Run the MD5 Transform one more time, since we want
		 * to add at least minimal obscuring of the inputs to
		 * add_entropy_word().  --- TYT
		 */
		MD5Update(&tmp, (u_int8_t*)random_state.pool, 16);
d774 11
a784 7
		{
			register u_int8_t	*cp, *dp;
			cp = (u_int8_t *) &tmp.buffer;
			dp = cp + sizeof(tmp.buffer) - 1;
			while (cp < dp)
				*cp++ ^= *dp--;
		}
d787 2
a788 2
		i = MIN(nbytes, sizeof(tmp.buffer));
		bcopy((caddr_t)&tmp.buffer, buf, i);
d791 1
a791 1
		enqueue_randomness(&extract_timer_state, nbytes);
d796 1
d821 1
a821 1
	
d835 1
a835 1
			if (random_state.entropy_count < 8) {
d842 2
a843 2
					printf("rnd: sleep[%d]\n",
					    rndstats.rnd_asleep);
d845 1
a845 1
				rndstats.rnd_asleep++;
d847 2
a848 2
				ret = tsleep(&rndstats.rnd_asleep,
					     PWAIT | PCATCH, "rndrd", 0);
d856 2
a857 1
			n = min(n, random_state.entropy_count / 8);
d870 1
a870 1
		case RND_PRND:	
d876 1
a876 1
		    {
d882 3
a884 1
		    }
a927 1
			int	i;
d930 1
a930 3
			n >>= 2;
			for (i = 0; i < n; i++)
				add_entropy_word(buf[i]);
d935 1
a935 1
		arc4random_uninitialized = 2;
d948 1
a948 1
	int	ret;
d951 2
d960 7
a966 6
			return EPERM;
		copyin(&cnt, data, sizeof(cnt));
		random_state.entropy_count += cnt;
		if (random_state.entropy_count > POOLBITS)
			random_state.entropy_count = POOLBITS;
		ret = 0;
d970 3
a972 3
			return EPERM;
		random_state.entropy_count = 0;
		ret = 0;
d976 11
a986 5
			return EPERM;
		if (random_state.entropy_count < 64)
			return EAGAIN;
		arc4random_uninitialized = 2;
		ret = 0;
d991 1
@


1.33
log
@Set j = i after arc4random key schedule to be more like arc4 stream cipher;
from conversations between various people
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.32 1997/08/22 12:54:33 downsj Exp $	*/
d228 2
a230 1
#include <sys/types.h>
a231 1
#include <sys/kernel.h>
a232 1
#include <sys/device.h>
a235 2
#include <sys/proc.h>
#include <sys/user.h>
a240 2
#include <net/netisr.h>

d244 1
a244 1
#ifdef	DEBUG
d276 1
a276 1
#define QEVSBITS 4
d297 1
a297 1
	int	cnt;
d334 1
a334 1
static __inline int extract_entropy __P((register u_int8_t *, int));
d403 7
d411 1
a411 1
arc4random (void)
d427 1
d438 1
a438 1
#ifdef DEBUG
a544 1
	u_int	nbits = 0;
d548 1
a548 1
	u_int	time;
d554 2
d568 20
a587 2
		delta = MIN(delta, delta2) >> 1;
		for (nbits = 0; delta; nbits++)
d589 3
d593 3
a595 1
		if (rndstats.rnd_queued > QEVSLOW && nbits < QEVSBITS) {
d600 1
a600 1
		state->last_delta = delta;
d624 1
a624 1
		timeout(dequeue_randomness, (void *)0xdeadd00d, 1);
d670 1
a670 1
#ifdef	DEBUG
d749 1
a749 1
static __inline int
d754 1
a754 1
	int	ret, i;
a762 1
	ret = nbytes;
a806 2
	
	return ret;
d850 1
a850 1
#ifdef	DEBUG
d859 1
a859 1
#ifdef	DEBUG
d868 1
a868 1
#ifdef	DEBUG
d873 2
a874 2
			n = extract_entropy((char *)buf, n);
#ifdef	DEBUG
a887 1
			arc4maybeinit ();
d889 1
a889 1
				*cp++ = arc4_getbyte ();
d945 1
a945 1
		arc4_stir ();
d986 1
a986 1
		arc4_stir ();
@


1.33.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a227 2
#undef RNDEBUG

d229 1
d231 1
d233 1
d237 2
d244 2
d249 1
a249 1
#ifdef	RNDEBUG
d281 1
a281 1
#define QEVSBITS 6
d302 1
a302 1
	u_int	cnt;
d339 1
a339 1
static __inline void extract_entropy __P((register u_int8_t *, int));
a407 7
int
arc4random_8(void)
{
	arc4maybeinit();
	return arc4_getbyte();
}

d409 1
a409 1
arc4random(void)
a424 1
	rndstats.arc4_stirs++;
d435 1
a435 1
#ifdef RNDEBUG
d542 1
d546 1
a546 1
	u_int	time, nbits;
a551 2
	nbits = 0;

d564 2
a565 20
		delta2 = delta = MIN(delta, delta2) >> 1;

		if (delta & 0xffff0000) {
			nbits = 16;
			delta >>= 16;
		}
		if (delta & 0xff00) {
			nbits += 8;
			delta >>= 8;
		}
		if (delta & 0xf0) {
			nbits += 4;
			delta >>= 4;
		}
		if (delta & 0xc) {
			nbits += 2;
			delta >>= 2;
		}
		if (delta & 2) {
			nbits += 1;
a566 3
		}
		if (delta & 1)
			nbits++;
d568 1
a568 3
		rndstats.rnd_ed[nbits]++;

		if (rndstats.rnd_queued > QEVSLOW && nbits > QEVSBITS) {
d573 1
a573 1
		state->last_delta = delta2;
d597 1
a597 1
		timeout(dequeue_randomness, NULL, 1);
d643 1
a643 1
#ifdef	RNDEBUG
d722 1
a722 1
static __inline void
d727 1
a727 1
	int	i;
d736 1
d781 2
d826 1
a826 1
#ifdef	RNDEBUG
d835 1
a835 1
#ifdef	RNDEBUG
d844 1
a844 1
#ifdef	RNDEBUG
d849 2
a850 2
			get_random_bytes((char *)buf, n);
#ifdef	RNDEBUG
d864 1
d866 1
a866 1
				*cp++ = arc4random_8();
d922 1
a922 1
		arc4random_uninitialized = 2;
d963 1
a963 1
		arc4random_uninitialized = 2;
@


1.33.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.46 2001/01/17 01:59:50 mickey Exp $	*/
d6 1
a6 1
 * Copyright (c) 1996, 1997, 2000 Michael Shalayeff.
d8 3
a10 4
 * Version 1.89, last modified 19-Sep-99
 *
 * Copyright Theodore Ts'o, 1994, 1995, 1996, 1997, 1998, 1999.
 * All rights reserved.
d24 1
a24 1
 *
d30 1
a30 1
 *
d45 2
a46 2
 * (now, with legal B.S. out of the way.....)
 *
d56 1
a56 1
 *
d67 1
a67 1
 *
d79 1
a79 1
 *
d91 1
a91 1
 *
d99 1
a99 1
 *
d102 1
a102 1
 *
d106 1
a106 1
 *	void get_random_bytes(void *buf, int nbytes);
d110 1
a110 1
 *
d117 1
a117 1
 *
d126 1
a126 1
 *
d129 3
a131 5
 *
 *	void add_true_randomness(int data);
 *	void add_timer_randomness(int data);
 *	void add_mouse_randomness(int mouse_data);
 *	void add_net_randomness(int isr);
d133 2
a134 11
 *	void add_disk_randomness(int n);
 *	void add_audio_randomness(int n);
 *
 * add_true_randomness() uses true random number generators present
 * on some cryptographic and system chipsets. entropy accounting
 * is not quitable, no timing is done, supplied 32 bits of pure entropy
 * are hashed into the pool plain and blindly, increasing the counter.
 *
 * add_timer_randomness() uses the random driver itselves timing,
 * measuring extract_entropy() and rndioctl() execution times.
 *
d139 1
a139 1
 *
d142 1
a142 1
 *
d145 4
a148 9
 *
 * add_audio_randomness() times the finishing of audio codec dma
 * requests for both recording and playback, apparently supplies quite
 * a lot of entropy, i'd blame on low resolution audio clock generators.
 *
 * All of these routines (except for add_true_randomness() of course)
 * try to estimate how many bits of randomness a particular randomness
 * source.  They do this by keeping track of the first and second order
 * deltas of the event timings.
d152 1
a152 1
 *
d161 1
a161 1
 * sequence:
d166 1
a166 1
 *	if [ -f /etc/random-seed ]; then
d168 1
a168 1
 *	fi
d173 1
a173 1
 *
d178 1
a178 1
 *
d181 1
a181 1
 *
d199 3
a201 3
 *	mknod /dev/random c 1 8
 *	mknod /dev/urandom c 1 9
 *
d206 9
a214 6
 * from Pretty Good Privacy's random number generator, and from private
 * discussions with Phil Karn.  Colin Plumb provided a faster random
 * number generator, which speed up the mixing function of the entropy
 * pool, taken from PGPfone.  Dale Worley has also contributed many
 * useful ideas and suggestions to improve this driver.
 *
d217 1
a217 3
 *
 * The code for SHA transform was taken from Peter Gutmann's
 * implementation, which has been placed in the public domain.
d219 2
a220 2
 * implementation, which has been placed in the public domain.
 * The MD5 cryptographic checksum was devised by Ronald Rivest, and is
d222 1
a222 1
 *
a239 1
#include <sys/timeout.h>
d257 6
a262 30
#if POOLWORDS == 2048
#define	TAP1	1638
#define	TAP2	1231
#define	TAP3	819
#define	TAP4	411
#define	TAP5	1
#elif POOLWORDS == 1024	/* also (819, 616, 410, 207, 2) */
#define	TAP1	817
#define	TAP2	615
#define	TAP3	412
#define	TAP4	204
#define	TAP5	1
#elif POOLWORDS == 512	/* also (409,307,206,102,2), (409,309,205,103,2) */
#define	TAP1	411
#define	TAP2	308
#define	TAP3	208
#define	TAP4	104
#define	TAP5	1
#elif POOLWORDS == 256
#define	TAP1	205
#define	TAP2	155
#define	TAP3	101
#define	TAP4	52
#define	TAP5	1
#elif POOLWORDS == 128	/* also (103, 78, 51, 27, 2) */
#define	TAP1	103
#define	TAP2	76
#define	TAP3	51
#define	TAP4	25
#define	TAP5	1
d264 5
a268 11
#define	TAP1	52
#define	TAP2	39
#define	TAP3	26
#define	TAP4	14
#define	TAP5	1
#elif POOLWORDS == 32
#define	TAP1	26
#define	TAP2	20
#define	TAP3	14
#define	TAP4	7
#define	TAP5	1
d273 4
a276 47
/*
 * For the purposes of better mixing, we use the CRC-32 polynomial as
 * well to make a twisted Generalized Feedback Shift Reigster
 *
 * (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR generators.  ACM
 * Transactions on Modeling and Computer Simulation 2(3):179-194.
 * Also see M. Matsumoto & Y. Kurita, 1994.  Twisted GFSR generators
 * II.  ACM Transactions on Mdeling and Computer Simulation 4:254-266)
 *
 * Thanks to Colin Plumb for suggesting this.
 *
 * We have not analyzed the resultant polynomial to prove it primitive;
 * in fact it almost certainly isn't.  Nonetheless, the irreducible factors
 * of a random large-degree polynomial over GF(2) are more than large enough
 * that periodicity is not a concern.
 *
 * The input hash is much less sensitive than the output hash.  All
 * that we want of it is that it be a good non-cryptographic hash;
 * i.e. it not produce collisions when fed "random" data of the sort
 * we expect to see.  As long as the pool state differs for different
 * inputs, we have preserved the input entropy and done a good job.
 * The fact that an intelligent attacker can construct inputs that
 * will produce controlled alterations to the pool's state is not
 * important because we don't consider such inputs to contribute any
 * randomness.  The only property we need with respect to them is that
 * the attacker can't increase his/her knowledge of the pool's state.
 * Since all additions are reversible (knowing the final state and the
 * input, you can reconstruct the initial state), if an attacker has
 * any uncertainty about the initial state, he/she can only shuffle
 * that uncertainty about, but never cause any collisions (which would
 * decrease the uncertainty).
 *
 * The chosen system lets the state of the pool be (essentially) the input
 * modulo the generator polymnomial.  Now, for random primitive polynomials,
 * this is a universal class of hash functions, meaning that the chance
 * of a collision is limited by the attacker's knowledge of the generator
 * polynomail, so if it is chosen at random, an attacker can never force
 * a collision.  Here, we use a fixed polynomial, but we *can* assume that
 * ###--> it is unknown to the processes generating the input entropy. <-###
 * Because of this important property, this is a good, collision-resistant
 * hash; hash collisions will occur no more often than chance.
 */

/* pIII/333 reported to have some drops w/ these numbers */
#define QEVLEN 96
#define QEVSLOW 64 /* yet another 0.75 for 60-minutes hour /-; */
#define QEVSBITS 12
a283 3
	u_int	asleep;
	u_int	queued;
	u_int	tmo;
d290 1
a290 3
	u_int	last_delta2;
	u_char	dont_count_entropy : 1;
	u_char	max_entropy : 1;
d294 2
a297 2
	u_int8_t i;
	u_int8_t j;
d308 4
a311 7
struct timeout rnd_timeout, arc4_timeout;
struct random_bucket random_state;
struct arc4_stream arc4random_state;
struct timer_rand_state rnd_states[RND_SRC_NUM];
struct rand_event rnd_event_space[QEVLEN];
struct rand_event *rnd_event_q;
struct rand_event *rnd_event_free;
a312 2
int rnd_attached;
int arc4random_initialized;
d314 12
d327 2
a328 6
static __inline u_int32_t roll(u_int32_t w, int i)
{
#ifdef i386
	__asm ("roll %%cl, %0" : "+r" (w) : "c" (i));
#else
	w = (w << i) | (w >> (32 - i));
a329 2
	return w;
}
d331 2
a333 2

static __inline void add_entropy_words __P((const u_int32_t *, u_int n));
d335 2
a336 1

a337 2
void arc4_stir __P((void));
void arc4_reinit __P((void *v));
d358 1
a358 1
arc4_stir(void)
a359 1
	u_int8_t buf[256];
d361 1
a361 9
	register int n, s;
	int len;

	microtime((struct timeval *) buf);
	len = random_state.entropy_count / 8; /* XXX maybe a half? */
	if (len > sizeof(buf) - sizeof(struct timeval))
		len = sizeof(buf) - sizeof(struct timeval);
	get_random_bytes(buf + sizeof (struct timeval), len);
	len += sizeof(struct timeval);
d363 1
a363 2
	s = splhigh();
	arc4random_state.i--;
d365 5
a369 6
		arc4random_state.i++;
		si = arc4random_state.s[arc4random_state.i];
		arc4random_state.j += si + buf[n % len];
		arc4random_state.s[arc4random_state.i] =
		    arc4random_state.s[arc4random_state.j];
		arc4random_state.s[arc4random_state.j] = si;
d371 2
a372 5
	arc4random_state.j = arc4random_state.i;
	arc4random_state.cnt = 0;
	rndstats.arc4_stirs += len;
	rndstats.arc4_nstirs++;
	splx(s);
d376 1
a376 1
arc4_getbyte(void)
d381 8
a388 8
	arc4random_state.cnt++;
	arc4random_state.i++;
	si = arc4random_state.s[arc4random_state.i];
	arc4random_state.j += si;
	sj = arc4random_state.s[arc4random_state.j];
	arc4random_state.s[arc4random_state.i] = sj;
	arc4random_state.s[arc4random_state.j] = si;
	return arc4random_state.s[(si + sj) & 0xff];
d392 1
a392 1
arc4maybeinit(void)
d394 6
a399 3
	if (!arc4random_initialized) {
		arc4random_initialized++;
		arc4_stir();
a402 10
void
arc4_reinit(v)
	void *v;
{
	extern int hz;

	arc4random_initialized = 0;
	timeout_add(&arc4_timeout, 10*60*hz);
}

d413 15
a427 3
	arc4maybeinit();
	return ((arc4_getbyte() << 24) | (arc4_getbyte() << 16)
		| (arc4_getbyte() << 8) | arc4_getbyte());
d446 1
a446 3
	rnd_states[RND_SRC_TIMER].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].dont_count_entropy = 1;
	rnd_states[RND_SRC_TRUE].max_entropy = 1;
d449 4
a452 3
	bzero(&rnd_event_space, sizeof(rnd_event_space));
	rnd_event_free = rnd_event_space;
	for (rep = rnd_event_space; rep < &rnd_event_space[QEVLEN-1]; rep++)
d455 3
a457 5
		arc4random_state.s[i] = i;
	microtime(&tv);
	timeout_set(&rnd_timeout, dequeue_randomness, NULL);
	timeout_set(&arc4_timeout, arc4_reinit, NULL);
	arc4_reinit(NULL);
d488 1
a488 1
 *
d496 13
a508 16
add_entropy_words(buf, n)
	const u_int32_t *buf;
	u_int n;
{
	static const u_int32_t twist_table[8] = {
		0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
		0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278
	};
	u_int i;
	int new_rotate;
	u_int32_t w;

	for (; n--; buf++) {
		w = roll(*buf, random_state.input_rotate);
		i = random_state.add_ptr =
		    (random_state.add_ptr - 1) & (POOLWORDS - 1);
a509 1
		 * Normally, we add 7 bits of rotation to the pool.
d514 12
a525 14
		new_rotate = random_state.input_rotate + 14;
		if (i)
			new_rotate = random_state.input_rotate + 7;
		random_state.input_rotate = new_rotate & 31;

		/* XOR in the various taps */
		w ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];
		w ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];
		w ^= random_state.pool[i];
		random_state.pool[i] = (w >> 3) ^ twist_table[w & 7];
	}
d540 1
a540 1
void
d542 2
a543 1
	int	state, val;
a544 1
	struct timer_rand_state *p;
d550 1
a550 7
#ifdef DIAGNOSTIC
	if (state < 0 || state >= RND_SRC_NUM)
		return;
#endif

	p = &rnd_states[state];
	val += state << 13;
d561 4
a564 5
	if (!p->dont_count_entropy) {
		register int	delta, delta2, delta3;
		delta  = time   - p->last_time;
		delta2 = delta  - p->last_delta;
		delta3 = delta2 - p->last_delta2;
d568 1
a568 8
		if (delta3 < 0) delta3 = -delta3;
		if (delta > delta2) delta = delta2;
		if (delta > delta3) delta = delta3;
		delta3 = delta >>= 1;
		/*
		 * delta &= 0xfff;
		 * we don't do it since our time sheet is different from linux
		 */
d593 3
a595 5
		/*
		 * the logic is to drop low-entropy entries,
		 * in hope for dequeuing to be more sourcefull
		 */
		if (random_state.queued > QEVSLOW && nbits < QEVSBITS) {
d599 3
a601 5
		p->last_time = time;
		p->last_delta  = delta3;
		p->last_delta2 = delta2;
	} else if (p->max_entropy)
		nbits = 8 * sizeof(val) - 1;
d604 2
a605 1
	if ((rep = rnd_event_free) == NULL) {
a606 1
		splx(s);
d609 1
a609 1
	rnd_event_free = rep->re_next;
d611 1
a611 1
	rep->re_state = p;
d616 2
a617 2
	rep->re_next = rnd_event_q;
	rnd_event_q = rep;
d619 6
a624 1
	random_state.queued++;
a625 10
	rndstats.rnd_enqs++;
	rndstats.rnd_ed[nbits]++;
	rndstats.rnd_sc[state]++;
	rndstats.rnd_sb[state] += nbits;

	if (++random_state.queued > QEVSLOW/2 && !random_state.tmo) {
		random_state.tmo++;
		timeout_add(&rnd_timeout, 1);
	}
	splx(s);
d633 1
a633 1
	u_int32_t val, time;
a636 1
	timeout_del(&rnd_timeout);
d641 1
a641 1
		if (rnd_event_q == NULL) {
d643 1
a643 1
			break;
d645 2
a646 4
		rep = rnd_event_q;
		rnd_event_q = rep->re_next;
		random_state.queued--;

d650 3
d654 4
a657 3
		rep->re_next = rnd_event_free;
		rnd_event_free = rep;
		splx(s);
d659 2
a660 2
		add_entropy_words(&val, 1);
		add_entropy_words(&time, 1);
d662 1
a663 1
		random_state.entropy_count += nbits;
d667 1
d669 1
a669 1
		    random_state.asleep != 0) {
d672 3
a674 3
				printf("rnd: wakeup[%u]{%u}\n",
				    random_state.asleep,
				    random_state.entropy_count);
d676 2
a677 2
			random_state.asleep--;
			wakeup(&random_state.asleep);
d681 57
a737 1
	random_state.tmo = 0;
a742 1

d754 1
d756 3
a758 4
	u_char buffer[16];

	add_timer_randomness(nbytes);

d760 1
a760 1
	if (random_state.entropy_count > POOLBITS)
d763 1
a763 1
	if (random_state.entropy_count / 8 > nbytes)
d769 2
a770 2
		register u_char *p = buf;
		register int i = sizeof(buffer);
d772 2
a773 4
		if (i > nbytes) {
			i = nbytes;
			p = buffer;
		}
d775 9
a783 5
		/* Hash the pool to get the output */
		MD5Init(&tmp);
		MD5Update(&tmp, (u_int8_t*)random_state.pool,
		    sizeof(random_state.pool));
		MD5Final(p, &tmp);
d789 7
a795 11
		p[0] ^= p[15];
		p[1] ^= p[14];
		p[2] ^= p[13];
		p[3] ^= p[12];
		p[4] ^= p[11];
		p[5] ^= p[10];
		p[6] ^= p[ 9];
		p[7] ^= p[ 8];

		/* Modify pool so next hash will produce different results */
		add_entropy_words((u_int32_t*)p, sizeof(buffer)/4);
d798 2
a799 2
		if (i < sizeof(buffer))
			bcopy(buffer, buf, i);
d802 1
a802 1
		add_timer_randomness(nbytes);
a806 1
	bzero(&buffer, sizeof(buffer));
d831 1
a831 1

d845 1
a845 1
			if (random_state.entropy_count < 16 * 8) {
d852 2
a853 2
					printf("rnd: sleep[%u]\n",
					    random_state.asleep);
d855 1
a855 1
				random_state.asleep++;
d857 2
a858 2
				ret = tsleep(&random_state.asleep,
				    PWAIT | PCATCH, "rndrd", 0);
d866 1
a866 2
			if (n > random_state.entropy_count / 8)
				n = random_state.entropy_count / 8;
d879 1
a879 1
		case RND_PRND:
d882 1
a882 1
				buf[i] = random() << 16 | (random() & 0xFFFF);
d885 1
a885 1
		{
d891 1
a891 3
		}
		default:
			ret = ENXIO;
d935 1
d938 3
a940 1
			add_entropy_words(buf, n / 4);
d945 1
a945 1
		arc4random_initialized = 0;
d958 1
a958 1
	int	s, ret = 0;
a960 2
	add_timer_randomness((u_long)p ^ (u_long)data ^ cmd);

a961 8
	case FIOASYNC:
		/* rnd has no async flag in softc so this is really a no-op. */
		break;

	case FIONBIO:
		/* Handled in the upper FS layer. */
		break;

d963 2
a964 3
		s = splhigh();
		*(u_int *)data = random_state.entropy_count;
		splx(s);
d968 6
a973 9
			ret = EPERM;
		else {
			cnt = *(u_int *)data;
			s = splhigh();
			random_state.entropy_count += cnt;
			if (random_state.entropy_count > POOLBITS)
				random_state.entropy_count = POOLBITS;
			splx(s);
		}
d977 3
a979 6
			ret = EPERM;
		else {
			s = splhigh();
			random_state.entropy_count = 0;
			splx(s);
		}
d983 5
a987 17
			ret = EPERM;
		else if (random_state.entropy_count < 64)
			ret = EAGAIN;
		else {
			s = splhigh();
			arc4random_initialized = 0;
			splx(s);
		}
		break;
	case RNDCLRSTATS:
		if (suser(p->p_ucred, &p->p_acflag) != 0)
			ret = EPERM;
		else {
			s = splhigh();
			bzero(&rndstats, sizeof(rndstats));
			splx(s);
		}
a991 2

	add_timer_randomness((u_long)p ^ (u_long)data ^ cmd);
@


1.33.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.33.4.2 2001/05/14 22:23:02 niklas Exp $	*/
d6 1
a6 1
 * Copyright (c) 1996, 1997, 2000, 2001 Michael Shalayeff.
d232 7
d364 2
a365 2
#define QEVLEN (1024 / sizeof(struct rand_event))
#define QEVSLOW (QEVLEN * 3 / 4) /* yet another 0.75 for 60-minutes hour /-; */
d375 1
d384 2
a385 2
	u_int	dont_count_entropy : 1;
	u_int	max_entropy : 1;
d396 1
d398 1
a398 1
	u_int re_nbits;
d408 2
a409 2
struct rand_event *rnd_event_head = rnd_event_space;
struct rand_event *rnd_event_tail = rnd_event_space;
a424 40
/* must be called at a proper spl, returns ptr to the next event */
static __inline struct rand_event *
rnd_get(void)
{
	struct rand_event *p = rnd_event_tail;

	if (p == rnd_event_head)
		return NULL;

	if (p + 1 >= &rnd_event_space[QEVLEN])
		rnd_event_tail = rnd_event_space;
	else
		rnd_event_tail++;

	return p;
}

/* must be called at a proper spl, returns next available item */
static __inline struct rand_event *
rnd_put(void)
{
	struct rand_event *p = rnd_event_head + 1;

	if (p >= &rnd_event_space[QEVLEN])
		p = rnd_event_space;

	if (p == rnd_event_tail)
		return NULL;

	return rnd_event_head = p;
}

/* must be called at a proper spl, returns number of items in the queue */
static __inline int
rnd_qlen(void)
{
	int len = rnd_event_head - rnd_event_tail;
	return (len < 0)? -len : len;
}

d431 1
a431 1
static __inline void arc4_stir __P((void));
a432 1
void arc4maybeinit __P((void));
d452 1
a452 1
static __inline void
d500 1
a500 1
void
a502 2
	extern int hz;

a505 2
		/* 10 minutes, per dm@@'s suggestion */
		timeout_add(&arc4_timeout, 10 * 60 * hz);
a508 4
/*
 * called by timeout to mark arc4 for stirring,
 * actuall stirring happens on any access attempt.
 */
d513 2
d516 1
d538 2
a547 3
	timeout_set(&rnd_timeout, dequeue_randomness, &random_state);
	timeout_set(&arc4_timeout, arc4_reinit, NULL);

d556 3
a558 1

d561 3
a564 1

d611 3
d616 2
a617 2
		register u_int32_t w = roll(*buf, random_state.input_rotate);
		register u_int i = random_state.add_ptr =
d625 4
a628 2
		random_state.input_rotate =
		    (random_state.input_rotate + (i? 7 : 14)) & 31;
d631 6
a636 6
		w ^= random_state.pool[(i+TAP1) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP2) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP3) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP4) & (POOLWORDS-1)] ^
		     random_state.pool[(i+TAP5) & (POOLWORDS-1)] ^
		     random_state.pool[i];
d657 2
a658 1
	register struct timer_rand_state *p;
d660 1
a660 1
	struct timeval	tv;
a661 5
	int s;

	/* XXX on sparc we get here before randomattach() */
	if (!rnd_attached)
		return;
d722 1
a722 1
		 * in hope for dequeuing to be more randomfull
d724 1
a724 1
		if (rnd_qlen() > QEVSLOW && nbits < QEVSBITS) {
d735 1
a735 1
	if ((rep = rnd_put()) == NULL) {
d740 1
d747 5
d757 1
a757 1
	if (rnd_qlen() > QEVSLOW/2 && !random_state.tmo) {
a767 1
	struct random_bucket *rs = v;
d769 1
a769 1
	u_int32_t buf[2];
d776 9
a784 2
	s = splhigh();
	while ((rep = rnd_get())) {
d786 2
a787 2
		buf[0] = rep->re_time;
		buf[1] = rep->re_val;
d789 3
d794 2
a795 1
		add_entropy_words(buf, 2);
d798 3
a800 3
		rs->entropy_count += nbits;
		if (rs->entropy_count > POOLBITS)
			rs->entropy_count = POOLBITS;
d802 2
a803 1
		if (rs->asleep && rs->entropy_count > 8) {
d807 2
a808 2
				    rs->asleep,
				    rs->entropy_count);
d810 2
a811 2
			rs->asleep--;
			wakeup((void *)&rs->asleep);
d813 1
d815 1
a815 5
		s = splhigh();
	}

	rs->tmo = 0;
	splx(s);
a832 1
	struct random_bucket *rs = &random_state;
d838 6
a843 2
	if (rs->entropy_count / 8 > nbytes)
		rs->entropy_count -= nbytes*8;
d845 1
a845 1
		rs->entropy_count = 0;
d858 2
a859 1
		MD5Update(&tmp, (u_int8_t*)rs->pool, sizeof(rs->pool));
@


1.33.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.33.4.3 2001/07/04 10:40:14 niklas Exp $	*/
d864 7
a870 1
		int i;
d875 1
a875 1
		MD5Final(buffer, &tmp);
d881 8
a888 8
		buffer[0] ^= buffer[15];
		buffer[1] ^= buffer[14];
		buffer[2] ^= buffer[13];
		buffer[3] ^= buffer[12];
		buffer[4] ^= buffer[11];
		buffer[5] ^= buffer[10];
		buffer[6] ^= buffer[ 9];
		buffer[7] ^= buffer[ 8];
d891 1
a891 1
		add_entropy_words((u_int32_t*)buffer, sizeof(buffer)/8);
d894 2
a895 4
		if (nbytes < sizeof(buffer) / 2)
			bcopy(buffer, buf, i = nbytes);
		else
			bcopy(buffer, buf, i = sizeof(buffer) / 2);
@


1.33.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d359 1
a359 1
#define QEVSBITS 10
d853 1
d858 5
d864 1
a864 2
		MD5_CTX tmp;
		int i, s;
a867 1
		s = splhigh();
a868 4
		if (rs->entropy_count / 8 > nbytes)
			rs->entropy_count -= nbytes * 8;
		else
			rs->entropy_count = 0;
a869 2
		bzero(&tmp, sizeof(tmp));
		splx(s);
d884 3
a893 2

		/* Modify pool so next hash will produce different results */
d898 1
d923 1
a923 1
	int	i;
d932 1
d989 1
d1112 1
a1112 1
		ret = ENOTTY;
@


1.33.4.6
log
@Merge in -current from roughly a week ago
@
text
@d456 1
a456 1
void dequeue_randomness(void *);
d458 2
a459 2
static __inline void add_entropy_words(const u_int32_t *, u_int n);
static __inline void extract_entropy(register u_int8_t *, int);
d461 4
a464 4
static __inline u_int8_t arc4_getbyte(void);
static __inline void arc4_stir(void);
void arc4_reinit(void *v);
void arc4maybeinit(void);
@


1.33.4.7
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * rnd.c -- A strong random number generator
d6 1
a6 1
 * Copyright (c) 1996, 1997, 2000-2002 Michael Shalayeff.
d44 1
d60 1
a60 1
 * pseudo-random numbers, which can be easily generated by using an
d63 1
a63 1
 * applications this is not acceptable.  Instead, we must try to
d65 1
a65 1
 * must be hard for outside attackers to observe and use to
d72 2
a73 2
 * outside observer to measure.  Randomness from these sources is
 * added to the "entropy pool", which is mixed using a CRC-like function.
d82 1
a82 1
 * hash of the content of the entropy pool.  The MD5 hash avoids
d97 1
a97 1
 * believed to be not feasible, but there is a remote possibility.
d104 2
a105 2
 * There are three exported interfaces.
 * The first one is designed to be used from within the kernel:
d112 1
a112 1
 * Two other interfaces are two character devices /dev/random and
d120 1
a120 1
 * as many bytes as were requested.  As more and more random bytes
d140 1
a140 1
 * on some cryptographic and system chipsets.  Entropy accounting
d153 1
a153 1
 * character as random inputs into the entropy pool.
d160 1
a160 1
 * a lot of entropy. I'd blame it on low resolution audio clock generators.
d163 3
a165 3
 * try to estimate how many bits of randomness are in a particular
 * randomness source.  They do this by keeping track of the first and
 * second order deltas of the event timings.
d177 1
a177 1
 * following lines in appropriate script which is run during the boot
d188 2
a189 2
 * and the following lines in appropriate script which is run when
 * the system is shutting down:
d200 1
a200 1
 * to be saved at shutdown time and reloaded into the entropy pool at
d225 1
a225 1
 * number generator, which speeds up the mixing function of the entropy
d230 1
a230 1
 * not be attributed to the Phil, Colin, or any of the authors of PGP.
d315 1
a315 1
 * well to make a twisted Generalized Feedback Shift Register
d330 2
a331 2
 * we want from it is to be a good non-cryptographic hash -
 * i.e. to not produce collisions when fed "random" data of the sort
d349 1
a349 1
 * polynomial, so if it is chosen at random, an attacker can never force
a400 13
struct selinfo rnd_rsel, rnd_wsel;

void filt_rndrdetach(struct knote *kn);
int filt_rndread(struct knote *kn, long hint);

struct filterops rndread_filtops =
	{ 1, NULL, filt_rndrdetach, filt_rndread};

void filt_rndwdetach(struct knote *kn);
int filt_rndwrite(struct knote *kn, long hint);

struct filterops rndwrite_filtops =
	{ 1, NULL, filt_rndwdetach, filt_rndwrite};
d473 2
a474 2
 * The initialization function here has been modified to not discard
 * the old state, and it's input always includes the time of day in
d477 3
a479 3
 * random numbers.  This increases the strength of the random stream,
 * but makes it impossible to use this code for encryption, since there
 * is no way to ever reproduce the same stream of random bytes.
a483 20
static __inline u_int8_t
arc4_getbyte(void)
{
	register u_int8_t si, sj, ret;
	int s;

	s = splhigh();
	rndstats.arc4_reads++;
	arc4random_state.cnt++;
	arc4random_state.i++;
	si = arc4random_state.s[arc4random_state.i];
	arc4random_state.j += si;
	sj = arc4random_state.s[arc4random_state.j];
	arc4random_state.s[arc4random_state.i] = sj;
	arc4random_state.s[arc4random_state.j] = si;
	ret = arc4random_state.s[(si + sj) & 0xff];
	splx(s);
	return (ret);
}

d514 1
d516 14
a529 7
	/*
	 * Throw away the first N words of output, as suggested in the
	 * paper "Weaknesses in the Key Scheduling Algorithm of RC4"
	 * by Fluher, Mantin, and Shamir.  (N = 256 in our case.)
	 */
	for (n = 0; n < 256 * 4; n++)
		arc4_getbyte();
d547 1
a547 1
 * actual stirring happens on any access attempt.
d556 1
a556 3
static int arc4random_8(void);

static int
d623 1
a623 1
 * This function adds a byte into the entropy pool.  It does not
d671 1
a671 1
 * This function adds entropy to the entropy pool by using timing
d676 2
a677 2
 * the type of event which just happened.  Currently the values of 0-255
 * are for keyboard scan codes, 256 and upwards - for interrupts.
d709 1
a709 1
	 * Calculate the number of bits of randomness that we probably
a827 2
			selwakeup(&rnd_rsel);
			KNOTE(&rnd_rsel.si_note, 0);
d842 1
a842 1
 * This function extracts randomness from the entropy pool, and
a868 1
		splx(s);
d871 1
a895 1
		dequeue_randomness(&random_state);
d1002 1
a1002 5
		if (random_state.entropy_count > 0)
			return (1);
		else
			selrecord(p, &rnd_rsel);
		break;
a1006 64
}

int
randomkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &rnd_rsel.si_note;
		kn->kn_fop = &rndread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &rnd_wsel.si_note;
		kn->kn_fop = &rndwrite_filtops;
		break;
	default:
		return (1);
	}
	kn->kn_hook = (void *)&random_state;

	s = splhigh();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
filt_rndrdetach(struct knote *kn)
{
	int s = splhigh();

	SLIST_REMOVE(&rnd_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_rndread(kn, hint)
	struct knote *kn;
	long hint;
{
	struct random_bucket *rs = (struct random_bucket *)kn->kn_hook;

	kn->kn_data = (int)rs->entropy_count;
	return rs->entropy_count > 0;
}

void
filt_rndwdetach(struct knote *kn)
{
	int s = splhigh();

	SLIST_REMOVE(&rnd_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_rndwrite(kn, hint)
	struct knote *kn;
	long hint;
{
	return (1);
@


1.33.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a248 1
#include <sys/poll.h>
d345 1
a345 1
 * modulo the generator polynomial.  Now, for random primitive polynomials,
a597 11
arc4random_bytes(void *buf, size_t n)
{
	u_int8_t *cp = buf;
	u_int8_t *end = cp + n;

	arc4maybeinit();
	while (cp < end)
		*cp++ = arc4_getbyte();
}

void
d1024 1
a1024 1
randompoll(dev, events, p)
d1026 1
a1026 1
	int	events;
d1029 2
a1030 3
	int revents = 0;

	if (events & (POLLIN | POLLRDNORM)) {
d1032 1
a1032 1
			revents |= events & (POLLIN | POLLRDNORM);
d1035 3
d1039 1
a1039 4
	if (events & (POLLOUT | POLLWRNORM))
		revents = events & (POLLOUT | POLLWRNORM); /* always writable */

	return (revents);
d1166 1
a1166 1
		if (suser(p, 0) != 0)
d1178 1
a1178 1
		if (suser(p, 0) != 0)
d1187 1
a1187 1
		if (suser(p, 0) != 0)
d1198 1
a1198 1
		if (suser(p, 0) != 0)
@


1.33.4.9
log
@Merge with the trunk
@
text
@d195 2
a196 2
 * For example, on OpenBSD systems, the appropriate scripts are
 * usually /etc/rc.local and /etc/rc.shutdown, respectively.
d202 1
a202 1
 * even if the system crashes without executing rc.shutdown) Even with
d207 1
a207 1
 * Configuring the random(4) driver under OpenBSD
d210 4
a213 4
 * The special files for the random(4) driver should have been created
 * during the installation process.  However, if your system does not have
 * /dev/random and /dev/[s|u|p|a]random created already, they can be created
 * by using the MAKEDEV(8) script in /dev:
d215 2
a216 3
 *	/dev/MAKEDEV random
 *
 * Check MAKEDEV for information about major and minor numbers.
d246 1
a250 2
#include <crypto/md5.h>

a562 4
#ifdef DIAGNOSTIC
		if (!rnd_attached)
			panic("arc4maybeinit: premature");
#endif
d581 9
a1021 1
			arc4maybeinit();
d1023 1
a1023 1
				*cp++ = arc4_getbyte();
@


1.32
log
@nbits should probably actually be initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.31 1997/06/28 07:05:22 deraadt Exp $	*/
d376 1
@


1.31
log
@fix the types
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.30 1997/06/24 02:45:00 mickey Exp $	*/
d541 1
a541 1
	u_int	nbits;
@


1.30
log
@more accounting!
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.26 1997/06/20 20:28:41 mickey Exp $	*/
d293 1
a293 1
	u_long	last_time;
d309 1
a309 1
	u_long re_time;
d545 1
a545 1
	u_long	time;
@


1.29
log
@now where did that patch go?
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.28 1997/06/22 04:58:05 flipk Exp $	*/
a327 1
static int rnd_sleep = 0;
a328 1
static int rnd_enqueued = 0;
d567 1
a567 1
		if (rnd_enqueued > QEVSLOW && nbits < QEVSBITS) {
d593 1
a593 1
	rnd_enqueued++;
d596 1
a596 1
		timeout(dequeue_randomness, NULL, 1);
a624 1
		rnd_enqueued--;
d639 3
a641 2
		if (random_state.entropy_count > 8 && rnd_sleep != 0) {
			rnd_sleep--;
d645 2
a646 1
				       rnd_sleep, random_state.entropy_count);
d648 2
a649 1
			wakeup(&rnd_sleep);
d828 1
a828 1
					    rnd_sleep);
d830 1
a830 1
				rnd_sleep++;
d832 2
a833 2
				ret = tsleep(&rnd_sleep, PWAIT | PCATCH,
				    "rndrd", 0);
@


1.28
log
@wasn't a race after all. properly initialize event_q pointers so the
last one doesn't point off the end.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.26 1997/06/20 20:28:41 mickey Exp $	*/
d450 1
a450 1
	for (rep = event_space; rep < &event_space[QEVLEN]; rep++)
@


1.27
log
@revert, there's a nasty race condition here.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.18 1997/03/30 22:05:11 mickey Exp $	*/
d6 1
a6 1
 * Copyright (c) 1996 Michael Shalayeff.
d242 1
d278 5
d287 2
a288 2
	int	input_rotate;
	u_int32_t *pool;
d294 2
a295 2
	int	last_delta;
	int	dont_count_entropy:1;
d299 12
a310 3
	u_char	i;
	u_char	j;
	u_char	s[256];
d318 1
d321 1
a321 2
static struct arc4_stream arc4random_state;
static u_int32_t random_pool[POOLWORDS];
d327 1
d329 4
d338 7
a344 8
static __inline void add_entropy_word __P((struct random_bucket *,
	    const u_int32_t));
void	add_timer_randomness __P((struct random_bucket *,
	    struct timer_rand_state *, u_int));
static __inline int extract_entropy __P((struct random_bucket *, char *, int));
void	arc4_init __P((struct arc4_stream *, u_char *, int));
static __inline void arc4_stir (struct arc4_stream *);
static __inline u_char arc4_getbyte __P((struct arc4_stream *));
d365 1
a365 1
arc4_init (struct arc4_stream *as, u_char *data, int len)
d367 2
a368 2
	int n;
	u_char si;
d370 1
a370 1
	as->i--;
d372 5
a376 5
		as->i = (as->i + 1) & 0xff;
		si = as->s[as->i];
		as->j = (as->j + si + data[n % len]) & 0xff;
		as->s[as->i] = as->s[as->j];
		as->s[as->j] = si;
d378 1
d381 2
a382 2
static __inline u_char
arc4_getbyte (struct arc4_stream *as)
d384 1
a384 1
	u_char si, sj;
d386 9
a394 7
	as->i = (as->i + 1) & 0xff;
	si = as->s[as->i];
	as->j = (as->j + si) & 0xff;
	sj = as->s[as->j];
	as->s[as->i] = sj;
	as->s[as->j] = si;
	return (as->s[(si + sj) & 0xff]);
d397 1
a397 1
static inline void
d400 7
a406 7
  if (arc4random_uninitialized) {
    if (arc4random_uninitialized > 1
	|| random_state.entropy_count >= 128) {
      arc4random_uninitialized--;
      arc4_stir (&arc4random_state);
    }
  }
d412 14
a425 5
  arc4maybeinit ();
  return ((arc4_getbyte (&arc4random_state) << 24)
	  | (arc4_getbyte (&arc4random_state) << 16)
	  | (arc4_getbyte (&arc4random_state) << 8)
	  | arc4_getbyte (&arc4random_state));
d433 8
a443 1
	random_state.pool = random_pool;
d446 6
d453 1
a453 1
		arc4random_state.s[i] = i;
d455 2
a456 1
	arc4_init (&arc4random_state, (u_char *) &tv, sizeof (tv));
d494 1
a494 2
add_entropy_word(r, input)
	struct random_bucket	*r;
d500 3
a502 2
	w = (input << r->input_rotate) | (input >> (32 - r->input_rotate));
	i = r->add_ptr = (r->add_ptr - 1) & (POOLWORDS-1);
d504 2
a505 1
		r->input_rotate = (r->input_rotate + 7) & 31;
d512 2
a513 1
		r->input_rotate = (r->input_rotate + 14) & 31;
d516 6
a521 6
	w ^= r->pool[(i+TAP1)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP2)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP3)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP4)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP5)&(POOLWORDS-1)];
	w ^= r->pool[i];
d523 1
a523 1
	r->pool[i] = (w << 1) | (w >> 31);
d538 4
a541 5
void
add_timer_randomness(r, state, num)
	struct random_bucket	*r;
	struct timer_rand_state	*state;
	u_int	num;
a542 1
	int	delta, delta2;
d544 3
d548 2
a549 1
	struct timeval	tv;
a552 4

	add_entropy_word(r, (u_int32_t)num);
	add_entropy_word(r, time);

d559 1
a560 2
		state->last_time = time;

a561 1
		state->last_delta = delta;
d569 60
a628 2
		r->entropy_count += nbits;
	
d630 11
a640 3
		if (r->entropy_count > POOLBITS)
			r->entropy_count = POOLBITS;
	}
d642 2
a643 2
	if (r->entropy_count > 8 && rnd_sleep != 0) {
		rnd_sleep--;
d645 3
a647 3
		if (rnd_debug & RD_WAIT)
			printf("rnd: wakeup[%d]{%u}\n",
				rnd_sleep, r->entropy_count);
d649 4
a652 2
		wakeup(&rnd_sleep);
	}
d659 6
a664 1
	add_timer_randomness(&random_state, &mouse_timer_state, mouse_data);
d671 6
a676 1
	add_timer_randomness(&random_state, &net_timer_state, ENT_NET + isr);
d686 1
a686 1
	if (random_state.pool == NULL)
d689 1
d697 1
a697 1
	add_timer_randomness(&random_state, &disk_timer_state, ENT_DISK + c);
d705 1
a705 1
	if (random_state.pool == NULL)
d708 2
a709 1
	add_timer_randomness(&random_state, &tty_timer_state, ENT_TTY + c);
d722 2
a723 3
extract_entropy(r, buf, nbytes)
	struct random_bucket *r;
	char	*buf;
d729 1
a729 1
	add_timer_randomness(r, &extract_timer_state, nbytes);
d732 2
a733 2
	if (r->entropy_count > POOLBITS) 
		r->entropy_count = POOLBITS;
d736 2
a737 2
	if (r->entropy_count / 8 >= nbytes)
		r->entropy_count -= nbytes*8;
d739 1
a739 1
		r->entropy_count = 0;
d746 1
a746 1
			MD5Update(&tmp, (u_int8_t*)r->pool+i, 16);
d750 1
a750 1
			add_entropy_word(r, tmp.buffer[i]);
d756 1
a756 1
		MD5Update(&tmp, (u_int8_t*)r->pool, 16);
d775 1
a775 1
		add_timer_randomness(r, &extract_timer_state, nbytes);
d794 2
a795 1
	extract_entropy(&random_state, (char *) buf, nbytes);
d831 1
d842 1
d848 1
a848 1
			n = extract_entropy(&random_state, (char *)buf, n);
d861 2
a862 2
			u_char *cp = (u_char *) buf;
			u_char *end = cp + n;
d865 1
a865 1
				*cp++ = arc4_getbyte (&arc4random_state);
a890 11
static __inline void
arc4_stir (struct arc4_stream *as)
{
	u_char buf[256];

	microtime ((struct timeval *) buf);
	get_random_bytes (buf + sizeof (struct timeval),
			  sizeof (buf) - sizeof (struct timeval));
	arc4_init (&arc4random_state, buf, sizeof (buf));
}

d913 1
a913 1
				((u_char *) buf)[n++] = 0;
d916 1
a916 1
				add_entropy_word(&random_state, buf[i]);
d921 1
a921 1
		arc4_stir (&arc4random_state);
d962 1
a962 1
		arc4_stir (&arc4random_state);
@


1.26
log
@count properly (;
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.25 1997/06/18 05:09:09 mickey Exp $	*/
d6 1
a6 1
 * Copyright (c) 1996, 1997 Michael Shalayeff.
a241 1
#include <sys/sysctl.h>
a276 5
/* p60/256kL2 reported to have some drops w/ these numbers */
#define QEVLEN 40
#define QEVSLOW 32 /* yet another 0.75 for 60-minutes hour /-; */
#define QEVSBITS 4

d281 2
a282 2
	u_char	input_rotate;
	u_int32_t pool[POOLWORDS];
d288 2
a289 2
	u_int	last_delta;
	u_char	dont_count_entropy:1;
d293 3
a295 12
	u_int8_t i;
	u_int8_t j;
	u_int8_t s[256];
	int	cnt;
};

struct rand_event {
	struct rand_event *re_next;
	struct timer_rand_state *re_state;
	u_char re_nbits;
	u_long re_time;
	u_int re_val;
a302 1
struct rndstats rndstats;
d305 2
a306 1
static struct arc4_stream arc4_state;
a311 1
static struct rand_event event_space[QEVLEN];
a312 4
static int rnd_attached = 0;
static int rnd_enqueued = 0;
static struct rand_event *event_q = NULL;
static struct rand_event *event_free;
d318 8
a325 7
static __inline void add_entropy_word __P((const u_int32_t));
static void enqueue_randomness __P((register struct timer_rand_state*, u_int));
void dequeue_randomness __P((void *));
static __inline int extract_entropy __P((register u_int8_t *, int));
void	arc4_init __P((u_int8_t *, int));
static __inline void arc4_stir __P((void));
static __inline u_int8_t arc4_getbyte __P((void));
d346 1
a346 1
arc4_init (register u_int8_t *data, int len)
d348 2
a349 2
	register u_int8_t si;
	register int n;
d351 1
a351 1
	arc4_state.i--;
d353 5
a357 5
		arc4_state.i = (arc4_state.i + 1) & 0xff;
		si = arc4_state.s[arc4_state.i];
		arc4_state.j = (arc4_state.j + si + data[n % len]) & 0xff;
		arc4_state.s[arc4_state.i] = arc4_state.s[arc4_state.j];
		arc4_state.s[arc4_state.j] = si;
a358 1
	arc4_state.cnt = 0;
d361 2
a362 2
static __inline u_int8_t
arc4_getbyte (void)
d364 1
a364 1
	register u_int8_t si, sj;
d366 7
a372 9
	rndstats.arc4_reads++;
	arc4_state.cnt++;
	arc4_state.i = (arc4_state.i + 1) & 0xff;
	si = arc4_state.s[arc4_state.i];
	arc4_state.j = (arc4_state.j + si) & 0xff;
	sj = arc4_state.s[arc4_state.j];
	arc4_state.s[arc4_state.i] = sj;
	arc4_state.s[arc4_state.j] = si;
	return (arc4_state.s[(si + sj) & 0xff]);
d375 1
a375 1
static __inline void
d378 7
a384 7
	if (arc4random_uninitialized) {
		if (arc4random_uninitialized > 1
		    || random_state.entropy_count >= 128) {
			arc4random_uninitialized--;
			arc4_stir ();
		}
	}
d390 5
a394 14
	arc4maybeinit ();
	return ((arc4_getbyte () << 24) | (arc4_getbyte () << 16)
		| (arc4_getbyte () << 8) | arc4_getbyte ());
}

static __inline void
arc4_stir (void)
{
	u_int8_t buf[256];

	microtime ((struct timeval *) buf);
	get_random_bytes (buf + sizeof (struct timeval),
			  sizeof (buf) - sizeof (struct timeval));
	arc4_init (buf, sizeof (buf));
a401 8
	struct rand_event *rep;

	if (rnd_attached) {
#ifdef DEBUG
		printf("random: second attach\n");
#endif
		return;
	}
d405 1
a407 6
	bzero(&rndstats, sizeof(rndstats));

	bzero(&event_space, sizeof(event_space));
	event_free = event_space;
	for (rep = event_space; rep < &event_space[QEVLEN]; rep++)
		rep->re_next = rep + 1;
d409 1
a409 1
		arc4_state.s[i] = i;
d411 1
a411 2
	arc4_init ((u_int8_t *) &tv, sizeof (tv));
	rnd_attached = 1;
d449 2
a450 1
add_entropy_word(input)
d456 2
a457 3
	w = (input << random_state.input_rotate) |
		(input >> (32 - random_state.input_rotate));
	i = random_state.add_ptr = (random_state.add_ptr - 1) & (POOLWORDS-1);
d459 1
a459 2
		random_state.input_rotate =
			(random_state.input_rotate + 7) & 31;
d466 1
a466 2
		random_state.input_rotate =
			(random_state.input_rotate + 14) & 31;
d469 6
a474 6
	w ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];
	w ^= random_state.pool[i];
d476 1
a476 1
	random_state.pool[i] = (w << 1) | (w >> 31);
d491 5
a495 4
static void
enqueue_randomness(state, val)
	register struct timer_rand_state *state;
	u_int	val;
d497 1
d499 1
a500 5
	register struct rand_event *rep;
	int s;
	u_long	time;

	rndstats.rnd_enqs++;
d504 4
a513 1
		register int	delta, delta2;
d515 2
d518 1
d526 5
a530 13
		if (rnd_enqueued > QEVSLOW && nbits < QEVSBITS) {
			rndstats.rnd_drople++;
			return;
		}
		state->last_time = time;
		state->last_delta = delta;
	}

	s = splhigh();
	if ((rep = event_free) == NULL) {
		splx(s);
		rndstats.rnd_drops++;
		return;
a531 1
	event_free = rep->re_next;
d533 2
a534 59
	rep->re_state = state;
	rep->re_nbits = nbits;
	rep->re_time = time;
	rep->re_val = val;

	rep->re_next = event_q;
	event_q = rep;
	rep = rep->re_next;
	splx(s);
	rndstats.rnd_timer++;
	rnd_enqueued++;

	if (rep == NULL)
		timeout(dequeue_randomness, NULL, 1);

}

void
dequeue_randomness(v)
	void *v;
{
	register struct rand_event *rep;
	register u_int32_t val, time;
	u_int nbits;
	int s;

	rndstats.rnd_deqs++;

	do {
		s = splhigh();
		if (event_q == NULL) {
			splx(s);
			return;
		}
		rep = event_q;
		event_q = rep->re_next;
		val = rep->re_val;
		time = rep->re_time;
		nbits = rep->re_nbits;
		rep->re_next = event_free;
		event_free = rep;
		splx(s);
		rnd_enqueued--;

		/* Prevent overflow */
		if ((random_state.entropy_count + nbits) > POOLBITS &&
		    arc4_state.cnt > 253)
			arc4_stir();

		add_entropy_word(val);
		add_entropy_word(time);

		random_state.entropy_count += nbits;
		rndstats.rnd_total += nbits;
		if (random_state.entropy_count > POOLBITS)
			random_state.entropy_count = POOLBITS;

		if (random_state.entropy_count > 8 && rnd_sleep != 0) {
			rnd_sleep--;
d536 3
a538 3
			if (rnd_debug & RD_WAIT)
				printf("rnd: wakeup[%d]{%u}\n",
				       rnd_sleep, random_state.entropy_count);
d540 2
a541 4
			wakeup(&rnd_sleep);
		}
	} while(1);

d548 1
a548 6
	/* Has randomattach run yet?  */
	if (!rnd_attached)
		return;

	rndstats.rnd_mouse++;
	enqueue_randomness(&mouse_timer_state, mouse_data);
d555 1
a555 6
	/* Has randomattach run yet?  */
	if (!rnd_attached)
		return;

	rndstats.rnd_net++;
	enqueue_randomness(&net_timer_state, ENT_NET + isr);
d565 1
a565 1
	if (!rnd_attached)
a567 1
	rndstats.rnd_disk++;
d575 1
a575 1
	enqueue_randomness(&disk_timer_state, ENT_DISK + c);
d583 1
a583 1
	if (!rnd_attached)
d586 1
a586 2
	rndstats.rnd_tty++;
	enqueue_randomness(&tty_timer_state, ENT_TTY + c);
d599 3
a601 2
extract_entropy(buf, nbytes)
	register u_int8_t *buf;
d607 1
a607 1
	enqueue_randomness(&extract_timer_state, nbytes);
d610 2
a611 2
	if (random_state.entropy_count > POOLBITS) 
		random_state.entropy_count = POOLBITS;
d614 2
a615 2
	if (random_state.entropy_count / 8 >= nbytes)
		random_state.entropy_count -= nbytes*8;
d617 1
a617 1
		random_state.entropy_count = 0;
d624 1
a624 1
			MD5Update(&tmp, (u_int8_t*)random_state.pool+i, 16);
d628 1
a628 1
			add_entropy_word(tmp.buffer[i]);
d634 1
a634 1
		MD5Update(&tmp, (u_int8_t*)random_state.pool, 16);
d653 1
a653 1
		enqueue_randomness(&extract_timer_state, nbytes);
d672 1
a672 2
	extract_entropy((u_int8_t *) buf, nbytes);
	rndstats.rnd_used += nbytes * 8;
a707 1
				rndstats.rnd_waits++;
a717 1
			rndstats.rnd_reads++;
d723 1
a723 1
			n = extract_entropy((char *)buf, n);
d736 2
a737 2
			u_int8_t *cp = (u_int8_t *) buf;
			u_int8_t *end = cp + n;
d740 1
a740 1
				*cp++ = arc4_getbyte ();
d766 11
d799 1
a799 1
				((u_int8_t *) buf)[n++] = 0;
d802 1
a802 1
				add_entropy_word(buf[i]);
d807 1
a807 1
		arc4_stir ();
d848 1
a848 1
		arc4_stir ();
@


1.25
log
@s/u_char/u_int8_t/g, where reasonable
s/\(static.*arc4_[^(]+(\)[^,)]+\([^)]*)\)/\1\2/g
less cpu load, just in case
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.24 1997/06/17 19:42:01 mickey Exp $	*/
d387 1
d631 1
a631 1
		    arc4_state.cnt > 256)
@


1.24
log
@count slow queue low entropy drops
bigger queue
use queue overflows for arc4_stir()
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.23 1997/06/14 21:37:08 mickey Exp $	*/
d299 4
a302 3
	u_char	i;
	u_char	j;
	u_char	s[256];
d321 1
a321 1
static struct arc4_stream arc4random_state;
d341 2
a342 2
static __inline int extract_entropy __P((register char *, int));
void	arc4_init __P((struct arc4_stream *, u_char *, int));
d344 1
a344 1
static __inline u_char arc4_getbyte __P((register struct arc4_stream *));
d365 1
a365 1
arc4_init (struct arc4_stream *as, u_char *data, int len)
d367 2
a368 2
	int n;
	u_char si;
d370 1
a370 1
	as->i--;
d372 5
a376 5
		as->i = (as->i + 1) & 0xff;
		si = as->s[as->i];
		as->j = (as->j + si + data[n % len]) & 0xff;
		as->s[as->i] = as->s[as->j];
		as->s[as->j] = si;
d378 1
d381 2
a382 2
static __inline u_char
arc4_getbyte (register struct arc4_stream *as)
d384 1
a384 1
	register u_char si, sj;
d387 7
a393 7
	as->i = (as->i + 1) & 0xff;
	si = as->s[as->i];
	as->j = (as->j + si) & 0xff;
	sj = as->s[as->j];
	as->s[as->i] = sj;
	as->s[as->j] = si;
	return (as->s[(si + sj) & 0xff]);
d412 13
a424 4
	return ((arc4_getbyte (&arc4random_state) << 24)
		| (arc4_getbyte (&arc4random_state) << 16)
		| (arc4_getbyte (&arc4random_state) << 8)
		| arc4_getbyte (&arc4random_state));
d452 1
a452 1
		arc4random_state.s[i] = i;
d454 1
a454 1
	arc4_init (&arc4random_state, (u_char *) &tv, sizeof (tv));
d629 2
a630 1
		if ((random_state.entropy_count + nbits) > POOLBITS)
d722 1
a722 1
	register char	*buf;
d793 1
a793 1
	extract_entropy((char *) buf, nbytes);
d860 2
a861 2
			u_char *cp = (u_char *) buf;
			u_char *end = cp + n;
d864 1
a864 1
				*cp++ = arc4_getbyte (&arc4random_state);
a889 11
static __inline void
arc4_stir (void)
{
	u_char buf[256];

	microtime ((struct timeval *) buf);
	get_random_bytes (buf + sizeof (struct timeval),
			  sizeof (buf) - sizeof (struct timeval));
	arc4_init (&arc4random_state, buf, sizeof (buf));
}

d912 1
a912 1
				((u_char *) buf)[n++] = 0;
@


1.23
log
@split the treatment of the random events
event_q by flipk@@
spl fix by deraadt@@
gother statistics about whole processing
use 'sysctl kern.random' to view what had happened
also fix wrong vm.psstrings description
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.22 1997/06/12 02:18:39 mickey Exp $	*/
d278 3
a280 2
#define QEVLEN 32
#define QEVSLOW 16
d342 1
a342 1
static __inline void arc4_stir (register struct arc4_stream *);
d401 1
a401 1
			arc4_stir (&arc4random_state);
d423 7
a530 1
	int	delta, delta2;
d547 1
a548 2
		state->last_time = time;

a549 1
		state->last_delta = delta;
d558 1
a558 1
			rndstats.rnd_drops++;
d561 2
d595 2
d609 5
d615 1
d617 3
a619 2
		add_entropy_word((u_int32_t)rep->re_val);
		add_entropy_word(rep->re_time);
d621 2
a622 2
		random_state.entropy_count += rep->re_nbits;
		rndstats.rnd_total += rep->re_nbits;
d624 2
a625 1
		/* Prevent overflow */
a628 6
		s = splhigh();
		rep->re_next = event_free;
		event_free = rep;
		splx(s);
		rnd_enqueued--;

d879 1
a879 1
arc4_stir (register struct arc4_stream *as)
d919 1
a919 1
		arc4_stir (&arc4random_state);
d960 1
a960 1
		arc4_stir (&arc4random_state);
@


1.22
log
@little faster, smaller, safer
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.21 1997/06/12 01:45:16 mickey Exp $	*/
d242 1
d278 4
d303 8
d316 1
d325 1
d328 3
d337 2
a338 1
void	add_timer_randomness __P((struct timer_rand_state *, u_int));
d383 1
d393 1
a393 1
static inline void
d408 5
a412 5
  arc4maybeinit ();
  return ((arc4_getbyte (&arc4random_state) << 24)
	  | (arc4_getbyte (&arc4random_state) << 16)
	  | (arc4_getbyte (&arc4random_state) << 8)
	  | arc4_getbyte (&arc4random_state));
d420 1
d426 6
d518 4
a521 4
void
add_timer_randomness(state, num)
	struct timer_rand_state	*state;
	u_int	num;
d525 3
d529 2
a530 1
	struct timeval	tv;
a533 4

	add_entropy_word((u_int32_t)num);
	add_entropy_word(time);

d552 56
a607 2
		random_state.entropy_count += nbits;
	
a610 1
	}
d612 8
a619 2
	if (random_state.entropy_count > 8 && rnd_sleep != 0) {
		rnd_sleep--;
d621 3
a623 3
		if (rnd_debug & RD_WAIT)
			printf("rnd: wakeup[%d]{%u}\n",
				rnd_sleep, random_state.entropy_count);
d625 4
a628 2
		wakeup(&rnd_sleep);
	}
d639 2
a640 1
	add_timer_randomness(&mouse_timer_state, mouse_data);
d651 2
a652 1
	add_timer_randomness(&net_timer_state, ENT_NET + isr);
d665 1
d673 1
a673 1
	add_timer_randomness(&disk_timer_state, ENT_DISK + c);
d684 2
a685 1
	add_timer_randomness(&tty_timer_state, ENT_TTY + c);
d705 1
a705 1
	add_timer_randomness(&extract_timer_state, nbytes);
d751 1
a751 1
		add_timer_randomness(&extract_timer_state, nbytes);
d771 1
d807 1
d818 1
@


1.21
log
@back out recent changes....
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.18 1997/03/30 22:05:11 mickey Exp $	*/
d281 2
a282 2
	int	input_rotate;
	u_int32_t *pool;
d288 2
a289 2
	int	last_delta;
	int	dont_count_entropy:1;
a305 1
static u_int32_t random_pool[POOLWORDS];
d312 1
d318 3
a320 5
static __inline void add_entropy_word __P((struct random_bucket *,
	    const u_int32_t));
void	add_timer_randomness __P((struct random_bucket *,
	    struct timer_rand_state *, u_int));
static __inline int extract_entropy __P((struct random_bucket *, char *, int));
d322 2
a323 2
static __inline void arc4_stir (struct arc4_stream *);
static __inline u_char arc4_getbyte __P((struct arc4_stream *));
d360 1
a360 1
arc4_getbyte (struct arc4_stream *as)
d362 1
a362 1
	u_char si, sj;
d376 7
a382 7
  if (arc4random_uninitialized) {
    if (arc4random_uninitialized > 1
	|| random_state.entropy_count >= 128) {
      arc4random_uninitialized--;
      arc4_stir (&arc4random_state);
    }
  }
a402 1
	random_state.pool = random_pool;
d409 1
d447 1
a447 2
add_entropy_word(r, input)
	struct random_bucket	*r;
d453 3
a455 2
	w = (input << r->input_rotate) | (input >> (32 - r->input_rotate));
	i = r->add_ptr = (r->add_ptr - 1) & (POOLWORDS-1);
d457 2
a458 1
		r->input_rotate = (r->input_rotate + 7) & 31;
d465 2
a466 1
		r->input_rotate = (r->input_rotate + 14) & 31;
d469 6
a474 6
	w ^= r->pool[(i+TAP1)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP2)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP3)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP4)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP5)&(POOLWORDS-1)];
	w ^= r->pool[i];
d476 1
a476 1
	r->pool[i] = (w << 1) | (w >> 31);
d492 1
a492 2
add_timer_randomness(r, state, num)
	struct random_bucket	*r;
d504 2
a505 2
	add_entropy_word(r, (u_int32_t)num);
	add_entropy_word(r, time);
d525 1
a525 1
		r->entropy_count += nbits;
d528 2
a529 2
		if (r->entropy_count > POOLBITS)
			r->entropy_count = POOLBITS;
d532 1
a532 1
	if (r->entropy_count > 8 && rnd_sleep != 0) {
d537 1
a537 1
				rnd_sleep, r->entropy_count);
d547 5
a551 1
	add_timer_randomness(&random_state, &mouse_timer_state, mouse_data);
d558 5
a562 1
	add_timer_randomness(&random_state, &net_timer_state, ENT_NET + isr);
d572 1
a572 1
	if (random_state.pool == NULL)
d582 1
a582 1
	add_timer_randomness(&random_state, &disk_timer_state, ENT_DISK + c);
d590 1
a590 1
	if (random_state.pool == NULL)
d593 1
a593 1
	add_timer_randomness(&random_state, &tty_timer_state, ENT_TTY + c);
d606 2
a607 3
extract_entropy(r, buf, nbytes)
	struct random_bucket *r;
	char	*buf;
d613 1
a613 1
	add_timer_randomness(r, &extract_timer_state, nbytes);
d616 2
a617 2
	if (r->entropy_count > POOLBITS) 
		r->entropy_count = POOLBITS;
d620 2
a621 2
	if (r->entropy_count / 8 >= nbytes)
		r->entropy_count -= nbytes*8;
d623 1
a623 1
		r->entropy_count = 0;
d630 1
a630 1
			MD5Update(&tmp, (u_int8_t*)r->pool+i, 16);
d634 1
a634 1
			add_entropy_word(r, tmp.buffer[i]);
d640 1
a640 1
		MD5Update(&tmp, (u_int8_t*)r->pool, 16);
d659 1
a659 1
		add_timer_randomness(r, &extract_timer_state, nbytes);
d678 1
a678 1
	extract_entropy(&random_state, (char *) buf, nbytes);
d729 1
a729 1
			n = extract_entropy(&random_state, (char *)buf, n);
d773 1
a773 1
arc4_stir (struct arc4_stream *as)
d808 1
a808 1
				add_entropy_word(&random_state, buf[i]);
@


1.20
log
@oops, clean debug flags
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.19 1997/06/10 18:55:30 mickey Exp $	*/
a241 1
#include <sys/queue.h>
a252 1
#define RD_QUEUE	0x0200	/* event queuing */
d281 1
a281 1
	u_char	input_rotate;
d288 2
a289 2
	u_int	last_delta;
	u_char	dont_count_entropy:1;
a297 6
struct rand_event {
	struct timer_rand_state *re_state;
	struct timeval re_tv;
	u_int re_val;
};

d318 5
a322 2
static __inline void add_entropy_word __P((const u_int32_t));
static __inline int extract_entropy __P((register char *, int));
d324 2
a325 5
static __inline void arc4_stir __P((void));
static __inline u_char arc4_getbyte __P((register struct arc4_stream *));
static void __inline queue_randomness
	__P((register struct timer_rand_state *, u_int));
void unqueue_randomness __P((void *));
d362 1
a362 1
arc4_getbyte (register struct arc4_stream *as)
d364 1
a364 1
	register u_char si, sj;
d375 1
a375 1
static __inline void
d378 7
a384 5
	if (arc4random_uninitialized && (arc4random_uninitialized > 1 ||
					 random_state.entropy_count >= 128)) {
		arc4random_uninitialized--;
		arc4_stir ();
	}
d449 2
a450 1
add_entropy_word(input)
d453 2
a454 2
	register u_int i;
	register u_int32_t w;
d456 2
a457 3
	w = (input << random_state.input_rotate) |
		(input >> (32 - random_state.input_rotate));
	i = random_state.add_ptr = (random_state.add_ptr - 1) & (POOLWORDS-1);
d459 1
a459 1
		random_state.input_rotate = (random_state.input_rotate + 7) & 31;
d466 1
a466 1
		random_state.input_rotate = (random_state.input_rotate + 14) & 31;
d469 6
a474 6
	w ^= random_state.pool[(i+TAP1)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP2)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP3)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP4)&(POOLWORDS-1)];
	w ^= random_state.pool[(i+TAP5)&(POOLWORDS-1)];
	w ^= random_state.pool[i];
d476 1
a476 1
	random_state.pool[i] = (w << 1) | (w >> 31);
d492 4
a495 2
unqueue_randomness(ptr)
	void *ptr;
d497 1
a497 4
	struct rand_event *re = (struct rand_event *)ptr;
	struct timer_rand_state	*state = re->re_state;
	u_long	time = re->re_tv.tv_usec ^ re->re_tv.tv_sec;
	u_int	delta, delta2;
d499 2
d502 2
a503 2
	add_entropy_word((u_int32_t)re->re_val);
	add_entropy_word((u_int32_t)time);
d505 2
a506 5
#ifdef DEBUG
	if (rnd_debug & RD_QUEUE)
		printf("rnd: dequeuing %p\n", re);
#endif
	FREE(re, M_TEMP);
d526 2
a527 2
		random_state.entropy_count += nbits;

d529 2
a530 2
		if (random_state.entropy_count > POOLBITS)
			random_state.entropy_count = POOLBITS;
d533 1
a533 1
	if (random_state.entropy_count > 8 && rnd_sleep != 0) {
d538 1
a538 1
				rnd_sleep, random_state.entropy_count);
a543 22
/*
 * Queue event for future processing by unqueue_randomness
 *
 */
static __inline void
queue_randomness(state, val)
	register struct timer_rand_state *state;
	u_int val;
{
	register struct rand_event *re;
	MALLOC(re, struct rand_event *, sizeof(*re), M_TEMP, M_WAITOK);

	microtime(&re->re_tv);
	re->re_state = state;
	re->re_val = val;
#ifdef DEBUG
	if (rnd_debug & RD_QUEUE)
		printf("rnd: queuing %p\n", re);
#endif
	timeout(unqueue_randomness, re, 1);
}

d548 1
a548 5
	/* Has randomattach run yet?  */
	if (random_state.pool == NULL)
		return;

	queue_randomness(&mouse_timer_state, mouse_data);
d555 1
a555 5
	/* Has randomattach run yet?  */
	if (random_state.pool == NULL)
		return;

	queue_randomness(&net_timer_state, ENT_NET + isr);
d575 1
a575 1
	queue_randomness(&disk_timer_state, ENT_DISK + c);
d586 1
a586 1
	queue_randomness(&tty_timer_state, ENT_TTY + c);
d599 3
a601 2
extract_entropy(buf, nbytes)
	register char	*buf;
d607 1
a607 1
	queue_randomness(&extract_timer_state, nbytes);
d610 2
a611 2
	if (random_state.entropy_count > POOLBITS) 
		random_state.entropy_count = POOLBITS;
d614 2
a615 2
	if (random_state.entropy_count / 8 >= nbytes)
		random_state.entropy_count -= nbytes*8;
d617 1
a617 1
		random_state.entropy_count = 0;
d624 1
a624 1
			MD5Update(&tmp, (u_int8_t*)random_state.pool+i, 16);
d628 1
a628 1
			add_entropy_word(tmp.buffer[i]);
d634 1
a634 1
		MD5Update(&tmp, (u_int8_t*)random_state.pool, 16);
d653 1
a653 1
		queue_randomness(&extract_timer_state, nbytes);
d672 1
a672 1
	extract_entropy((char *) buf, nbytes);
d723 1
a723 1
			n = extract_entropy((char *)buf, n);
d767 1
a767 1
arc4_stir ()
d802 1
a802 1
				add_entropy_word(buf[i]);
d807 1
a807 1
		arc4_stir ();
d848 1
a848 1
		arc4_stir ();
@


1.19
log
@do the job out of the calling function's spl
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.18 1997/03/30 22:05:11 mickey Exp $	*/
d250 1
a250 1
int	rnd_debug = 0x0100;
@


1.18
log
@no more 2(two) md5 libs in kernel!
tested for rnd(4).... should work for ip too, since it's
the copy of ip_md*.
use sys/md5k.h for protos.... std iface forever!
hurray!
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.17 1997/02/04 03:03:18 dm Exp $	*/
d6 1
a6 1
 * Copyright (c) 1996 Michael Shalayeff.
d242 1
d250 1
a250 1
int	rnd_debug = 0x0000;
d254 1
d283 1
a283 1
	int	input_rotate;
d290 2
a291 2
	int	last_delta;
	int	dont_count_entropy:1;
d300 6
d326 2
a327 5
static __inline void add_entropy_word __P((struct random_bucket *,
	    const u_int32_t));
void	add_timer_randomness __P((struct random_bucket *,
	    struct timer_rand_state *, u_int));
static __inline int extract_entropy __P((struct random_bucket *, char *, int));
d329 5
a333 2
static __inline void arc4_stir (struct arc4_stream *);
static __inline u_char arc4_getbyte __P((struct arc4_stream *));
d370 1
a370 1
arc4_getbyte (struct arc4_stream *as)
d372 1
a372 1
	u_char si, sj;
d383 1
a383 1
static inline void
d386 5
a390 7
  if (arc4random_uninitialized) {
    if (arc4random_uninitialized > 1
	|| random_state.entropy_count >= 128) {
      arc4random_uninitialized--;
      arc4_stir (&arc4random_state);
    }
  }
d455 1
a455 2
add_entropy_word(r, input)
	struct random_bucket	*r;
d458 2
a459 2
	u_int		i;
	u_int32_t	w;
d461 3
a463 2
	w = (input << r->input_rotate) | (input >> (32 - r->input_rotate));
	i = r->add_ptr = (r->add_ptr - 1) & (POOLWORDS-1);
d465 1
a465 1
		r->input_rotate = (r->input_rotate + 7) & 31;
d472 1
a472 1
		r->input_rotate = (r->input_rotate + 14) & 31;
d475 6
a480 6
	w ^= r->pool[(i+TAP1)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP2)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP3)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP4)&(POOLWORDS-1)];
	w ^= r->pool[(i+TAP5)&(POOLWORDS-1)];
	w ^= r->pool[i];
d482 1
a482 1
	r->pool[i] = (w << 1) | (w >> 31);
d498 2
a499 4
add_timer_randomness(r, state, num)
	struct random_bucket	*r;
	struct timer_rand_state	*state;
	u_int	num;
d501 4
a504 1
	int	delta, delta2;
a505 2
	u_long	time;
	struct timeval	tv;
d507 2
a508 2
	microtime(&tv);
	time = tv.tv_usec ^ tv.tv_sec;
d510 5
a514 2
	add_entropy_word(r, (u_int32_t)num);
	add_entropy_word(r, time);
d534 2
a535 2
		r->entropy_count += nbits;
	
d537 2
a538 2
		if (r->entropy_count > POOLBITS)
			r->entropy_count = POOLBITS;
d541 1
a541 1
	if (r->entropy_count > 8 && rnd_sleep != 0) {
d546 1
a546 1
				rnd_sleep, r->entropy_count);
d552 22
d578 5
a582 1
	add_timer_randomness(&random_state, &mouse_timer_state, mouse_data);
d589 5
a593 1
	add_timer_randomness(&random_state, &net_timer_state, ENT_NET + isr);
d613 1
a613 1
	add_timer_randomness(&random_state, &disk_timer_state, ENT_DISK + c);
d624 1
a624 1
	add_timer_randomness(&random_state, &tty_timer_state, ENT_TTY + c);
d637 2
a638 3
extract_entropy(r, buf, nbytes)
	struct random_bucket *r;
	char	*buf;
d644 1
a644 1
	add_timer_randomness(r, &extract_timer_state, nbytes);
d647 2
a648 2
	if (r->entropy_count > POOLBITS) 
		r->entropy_count = POOLBITS;
d651 2
a652 2
	if (r->entropy_count / 8 >= nbytes)
		r->entropy_count -= nbytes*8;
d654 1
a654 1
		r->entropy_count = 0;
d661 1
a661 1
			MD5Update(&tmp, (u_int8_t*)r->pool+i, 16);
d665 1
a665 1
			add_entropy_word(r, tmp.buffer[i]);
d671 1
a671 1
		MD5Update(&tmp, (u_int8_t*)r->pool, 16);
d690 1
a690 1
		add_timer_randomness(r, &extract_timer_state, nbytes);
d709 1
a709 1
	extract_entropy(&random_state, (char *) buf, nbytes);
d760 1
a760 1
			n = extract_entropy(&random_state, (char *)buf, n);
d804 1
a804 1
arc4_stir (struct arc4_stream *as)
d839 1
a839 1
				add_entropy_word(&random_state, buf[i]);
d844 1
a844 1
		arc4_stir (&arc4random_state);
d885 1
a885 1
		arc4_stir (&arc4random_state);
@


1.17
log
@Make sure arc4random gets initialized eventually.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.16 1997/01/15 22:33:53 kstailey Exp $	*/
d241 1
a254 11
#ifdef	RND_USE_SHA
#define	HASH_BUFFER_SIZE	5
#define	HASH_TRANSFORM	SHATransform
#else	/* RND_USE_MD5 */
#ifndef	RND_USE_MD5
#define	RND_USE_MD5
#endif
#define	HASH_BUFFER_SIZE	4
#define	HASH_TRANSFORM	MD5Transform
#endif

d605 1
a605 1
	u_int32_t tmp[HASH_BUFFER_SIZE];
d621 2
a622 3
#ifdef	RND_USE_MD5
		MD5Init(tmp);
#endif
d624 2
a625 1
			HASH_TRANSFORM(tmp, r->pool+i);
d627 2
a628 7
		add_entropy_word(r, tmp[0]);
		add_entropy_word(r, tmp[1]);
		add_entropy_word(r, tmp[2]);
		add_entropy_word(r, tmp[3]);
#ifdef	RND_USE_SHA
		add_entropy_word(r, tmp[5]);
#endif
d634 1
a634 1
		HASH_TRANSFORM(tmp, r->pool);
d642 4
a645 6
			cp = (u_int8_t *) tmp;
			dp = cp + (HASH_BUFFER_SIZE*sizeof(tmp[0])) - 1;
			for (i=0; i < HASH_BUFFER_SIZE*sizeof(tmp[0])/2; i++) {
				*cp ^= *dp;
				cp++;  dp--;
			}
d649 2
a650 2
		i = MIN(nbytes, HASH_BUFFER_SIZE*sizeof(tmp[0]));
		bcopy((caddr_t)tmp, buf, i);
d657 1
a657 1
	bzero(tmp, sizeof(tmp));
@


1.16
log
@moved init of ret in randomioctl() to better location
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.15 1997/01/15 02:03:53 kstailey Exp $	*/
d314 2
a315 1
struct arc4_stream arc4random_state;
d334 1
d385 12
d400 1
d755 1
d786 1
a786 3
	int rsec = random_state.entropy_count >> 3;
	u_int buf[2 + POOLWORDS];
	int n = min (sizeof(buf) - 2 * sizeof (u_int), rsec);
d789 3
a791 3
	get_random_bytes (buf + 2, n);
	arc4_init (&arc4random_state, (u_char *) buf,
		   2 * sizeof (u_int) + n);
@


1.15
log
@prevent this warning:
rnd.c:823: warning: `ret' might be used uninitialized in this function
when compiling with -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.14 1997/01/05 11:08:58 niklas Exp $	*/
d823 1
a823 1
	int	ret = 0;
d838 1
@


1.14
log
@Remove lots of timer_state structs as they just ate memory and only a few was
ever used.  Now a single state is kept for net, tty and disk events resp.
Also, call the randomness from disk_unbusy instead of biodone, as biodone
gets a lot of virtual events (from virtual filesystems etc), and as a bonus:
feed xfer time and size into the entropy pool too.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.13 1997/01/01 16:16:13 mickey Exp $	*/
d823 1
a823 1
	int	ret;
d825 1
a825 1
	
@


1.13
log
@don't count on MFS in add_blkdev_randomness
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.12 1996/12/28 19:06:28 niklas Exp $	*/
d132 2
a133 5
 *	void add_tty_randomness(dev_t dev, int c);
 * 	void add_blkdev_randomness(int irq);
 * 
 * add_keyboard_randomness() uses the inter-keypress timing, as well as the
 * scancode as random inputs into the "entropy pool".
d138 4
a141 7
 * add_interrupt_randomness() uses the inter-interrupt timing as random
 * inputs to the entropy pool.  Note that not all interrupts are good
 * sources of randomness!  For example, the timer interrupts is not a
 * good choice, because the periodicity of the interrupts is to
 * regular, and hence predictable to an attacker.  Disk interrupts are
 * a better measure, since the timing of the disk interrupts are more
 * unpredictable.
d143 2
a144 1
 * add_blkdev_randomness() times the finishing time of block requests.
d234 1
d310 1
a310 1
#define	ENT_BLKDEV	0x200
d318 4
a321 4
static struct timer_rand_state net_timer_state[32];	/* XXX */
static struct timer_rand_state *blkdev_timer_state;
static struct timer_rand_state *tty_timer_state;
static int	rnd_sleep = 0;
d327 7
a333 6
static inline void add_entropy_word
	__P((struct random_bucket *r, const u_int32_t input));
static void add_timer_randomness __P((struct random_bucket *r,
	struct timer_rand_state *state, u_int num));
static inline int extract_entropy
	__P((struct random_bucket *r, char *buf, int nbytes));
d353 1
a353 1
static void
d369 1
a369 1
static inline u_char
a400 6
	blkdev_timer_state = malloc(nblkdev*sizeof(*blkdev_timer_state),
	    M_DEVBUF, M_WAITOK);
	bzero(blkdev_timer_state, nblkdev*sizeof(*blkdev_timer_state));
	tty_timer_state = malloc(nchrdev*sizeof(*tty_timer_state),
	    M_DEVBUF, M_WAITOK);
	bzero(tty_timer_state, nchrdev*sizeof(*tty_timer_state));
d443 1
a443 1
static inline void
d486 1
a486 1
static void
d495 1
d497 2
a498 6
	{
		struct timeval	tv;
		microtime(&tv);
		
		time = tv.tv_usec ^ tv.tv_sec;
	}
d500 1
a500 1
	add_entropy_word(r, (u_int32_t) num);
d550 1
a550 5
	if (isr >= sizeof(net_timer_state)/sizeof(*net_timer_state))
		return;

	add_timer_randomness(&random_state, &net_timer_state[isr],
	    ENT_NET + isr);
d554 2
a555 2
add_blkdev_randomness(dev)
	dev_t	dev;
d557 4
a560 6
	/*
	 * Happens before randomattach() has been run and then later
	 * when NODEV buffers get fed to biodone().  XXX Howcome?
	 * XXX don't count on mfs (major==255)
	 */
	if (dev == NODEV || major(dev) == 255 || blkdev_timer_state == NULL)
d563 8
a570 7
#ifdef DIAGNOSTIC
	if (major(dev) >= nblkdev)
		panic("add_blkdev_randomness(dev = 0x%x): bad device", dev);
#endif

	add_timer_randomness(&random_state, &blkdev_timer_state[major(dev)],
	    ENT_BLKDEV + major(dev));
d574 1
a574 2
add_tty_randomness(dev, c)
	dev_t	dev;
d577 2
a578 6
	/*
	 * XXX does this routine ever get called before randomattach?
	 * Well, this is a safety belt against that condition.  Should
	 * we check for NODEV too, like in the block device case?
	 */
	if (tty_timer_state == NULL)
d581 1
a581 8
#ifdef DIAGNOSTIC
	if (major(dev) >= nchrdev)
		panic("add_tty_randomness(dev = 0x%x, c = %d): bad device",
		    dev, c);
#endif

	add_timer_randomness(&random_state, &tty_timer_state[major(dev)],
	    ENT_TTY + c);
d593 1
a593 1
static inline int
d767 1
a767 1
static inline void
@


1.12
log
@Fix prerequisite test, still need to check why NODEV bufs comes here.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.11 1996/10/19 13:25:58 mickey Exp $	*/
d576 1
d578 1
a578 1
	if (dev == NODEV || blkdev_timer_state == NULL)
@


1.11
log
@random device is permanent now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.9 1996/09/29 16:42:00 dm Exp $	*/
d405 1
a405 1
				    M_DEVBUF, M_WAITOK);
d408 1
a408 1
				    M_DEVBUF, M_WAITOK);
d573 5
a577 1
	if (major(dev) <= nblkdev || blkdev_timer_state == NULL)
d580 5
d594 6
a599 1
	if (major(dev) <= nchrdev || tty_timer_state == NULL)
d601 6
@


1.10
log
@-Wall happieness
@
text
@a232 2
#include "random.h"
#if NRANDOM > 0
a330 3
/* called by main() at boot time */
void	randomattach __P((int num));

d396 1
a396 2
randomattach(num)
	int	num;
a400 3
	if (num > 1)
		panic("no more than one random device");

a865 1
#endif
@


1.9
log
@Short comment describing the origin of arc4.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.8 1996/09/06 08:36:13 mickey Exp $	*/
a321 1
static struct timer_rand_state keyboard_timer_state;
d333 10
d691 1
a691 1
	extract_entropy(&random_state, (char *) buf, nbytes, 0);
d742 1
a742 1
			n = extract_entropy(&random_state, buf, n);
@


1.8
log
@cleanup and sync w/ latest Linux source.
remove keyboard randomness entry point.
make Free ppl happy, remove suspicious piece.
missed: SHA neede in libkern, why not to put aRC4 there too?
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.7 1996/08/29 09:26:36 deraadt Exp $	*/
d333 18
@


1.7
log
@rnd -> random
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.6 1996/08/11 07:31:31 dm Exp $	*/
d4 2
d8 1
a8 34
 * This software derived from one contributed by Theodore Ts'o.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Theodore Ts'o.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *
 *
 * random.c -- A strong random number generator
 *
 * Version 0.96, last modified 29-Dec-95
d10 1
a10 1
 * Copyright Theodore Ts'o, 1994, 1995.  All rights reserved.
d51 1
a51 1
 * desireable to have numbers which are not only random, but hard to
d58 1
a58 1
 * to produce truely random numbers on a computer --- as opposed to
d96 1
a96 1
 * not believed to be feasible, but there is a remote possiblility.
a129 1
 * 	void add_keyboard_randomness(u_char scancode);
d131 3
a133 2
 * 	void add_interrupt_randomness(int irq);
 * 	void add_blkdev_randomness(dev_t dev);
d155 52
d217 2
d223 8
d260 11
a318 3
/* device functions prototypes: XXX move em to dev_conf.h */
cdev_decl(random);

d364 1
a364 1
u_long
d372 1
a372 1
	
d485 1
a485 1
	u_int32_t	time;
a533 11
add_keyboard_randomness(scancode)
	u_char	scancode;
{
#ifdef	DEBUG
	if (rnd_debug & RD_INPUT)
		printf("rnd: adding %02x from kbd\n", scancode);
#endif
	add_timer_randomness(&random_state, &keyboard_timer_state, scancode);
}

void
d590 1
a590 1
	u_int32_t tmp[4];
a596 3
	/* Why is this here?  Left in from Ted Ts'o.  Perhaps to limit time. */
	if (nbytes > 32768)
		nbytes = 32768;
d606 1
d608 1
d610 1
a610 1
			MD5Transform(tmp, r->pool+i);
d616 3
d624 16
a639 2
		MD5Transform(tmp, r->pool);
		
d641 1
a641 1
		i = MIN(nbytes, 16);
d645 1
d686 1
@


1.6
log
@Increased entropy through decreased typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.5 1996/08/11 06:41:38 dm Exp $	*/
d202 2
a203 2
#include "rnd.h"
#if NRND > 0
d278 1
a278 1
cdev_decl(rnd);
d335 1
a335 1
rndattach(num)
d342 1
a342 1
		panic("no more than one rnd device");
d362 1
a362 1
rndopen(dev, flag, mode, p)
d372 1
a372 1
rndclose(dev, flag, mode, p)
d623 1
a623 1
rndread(dev, uio, ioflag)
d697 1
a697 1
rndselect(dev, rw, p)
d725 1
a725 1
rndwrite(dev, uio, flags)
d760 1
a760 1
rndioctl(dev, cmd, data, flag, p)
@


1.5
log
@Added arc4random and /dev/arnd.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.4 1996/08/10 19:41:16 deraadt Exp $	*/
d281 1
a281 1
static struct arc4_stream arc4random_state;
d318 1
a318 1
	as->i = (as->i + si) & 0xff;
d325 1
a325 1
u_int
d368 1
a368 1
	return 0;
@


1.4
log
@indent nicely
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.3 1996/04/24 21:26:41 mickey Exp $	*/
d266 6
d281 1
d294 39
d338 3
d354 5
d680 8
d711 13
d746 2
a747 1
				buf[n++] = 0;
d752 4
d787 9
@


1.3
log
@Supply randomness source for the rnd device.
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.2 1996/04/17 04:59:48 mickey Exp $	*/
d466 1
a466 1
			     ENT_NET + isr);
d477 1
a477 1
			     ENT_BLKDEV + major(dev));
d489 1
a489 1
			     ENT_TTY + c);
d575 1
a575 1
	int	s;
d581 1
a581 1
		u_int32_t	buf[ POOLWORDS ];
d585 9
a593 10
		switch(minor(dev))
		{
			case RND_RND:
				break;
			case RND_SRND:
				if (random_state.entropy_count < 8) {
					if (ioflag & IO_NDELAY) {
						ret = EWOULDBLOCK;
						break;
					}
d595 3
a597 3
					if (rnd_debug & RD_WAIT)
						printf("rnd: sleep[%d]\n",
							rnd_sleep);
d599 3
a601 3
					rnd_sleep++;
					ret = tsleep(&rnd_sleep, PWAIT | PCATCH,
						     "rndrd", 0);
d603 2
a604 3
					if (rnd_debug & RD_WAIT)
						printf("rnd: awakened(%d)\n",
							ret);
d606 4
a609 4
					if (ret)
						break;
				}
				n = min(n, random_state.entropy_count / 8);
d611 2
a612 3
				if (rnd_debug & RD_OUTPUT)
					printf("rnd: %u possible output\n",
						n );
d614 2
a615 2
			case RND_URND:
				n = extract_entropy(&random_state, buf, n);
d617 2
a618 3
				if (rnd_debug & RD_OUTPUT)
					printf("rnd: %u bytes for output\n",
						n );
d620 6
a625 9
				break;
			case RND_PRND:	
				{
					int i = (n + 3) / 4;
					while(i--)
						buf[i] = random();
				}
				break;

a630 1

d641 4
a644 4
		case FREAD:
			return random_state.entropy_count > 0;
		case FWRITE:
			return 1;
a645 1
				
a675 1

d688 1
d691 19
a709 26

		case RNDGETENTCNT:
			ret = copyout(&random_state.entropy_count, data,
				      sizeof(random_state.entropy_count));
			break;

		case RNDADDTOENTCNT:
			if (suser(p->p_ucred, &p->p_acflag) != 0)
				return EPERM;
			{
				u_int	cnt;
				copyin(&cnt, data, sizeof(cnt));
				random_state.entropy_count += cnt;
			}
			if (random_state.entropy_count > POOLBITS)
				random_state.entropy_count = POOLBITS;
			break;

		case RNDZAPENTCNT:
			if (suser(p->p_ucred, &p->p_acflag) != 0)
				return EPERM;
			random_state.entropy_count = 0;
			break;

		default:
			ret = EINVAL;
a710 1

@


1.2
log
@Update w/ the fact of MD5 presence in the libkern.a
@
text
@d1 1
a1 1
/*	$OpenBSD: rnd.c,v 1.1 1996/03/29 12:09:55 mickey Exp $	*/
d269 1
a269 1
#define ENT_IRQ		0x300
d281 1
d301 3
d473 1
a473 1
	if (major(dev) >= nblkdev || blkdev_timer_state == NULL)
d478 12
@


1.1
log
@The random data source driver itself.
Initial commit.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a199 8
 * The code for MD5 transform was taken from Colin Plumb's
 * implementation, which has been placed in the public domain.  The
 * MD5 cryptographic checksum was devised by Ronald Rivest, and is
 * documented in RFC 1321, "The MD5 Message Digest Algorithm".
 * 
 * Further background information on this topic may be obtained from
 * RFC 1750, "Randomness Recommendations for Security", by Donald
 * Eastlake, Steve Crocker, and Jeff Schiller.
a475 118
/*
 * MD5 transform algorithm, taken from code written by Colin Plumb,
 * and put into the public domain
 *
 * QUESTION: Replace this with SHA, which as generally received better
 * reviews from the cryptographic community?
 */

/* The four core functions - F1 is optimized somewhat */

/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f, w, x, y, z, data, s) \
	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
static void
MD5Transform(buf, in)
	u_int32_t buf[4];
	u_int32_t const in[16];
{
	u_int32_t a, b, c, d;

	a = buf[0];
	b = buf[1];
	c = buf[2];
	d = buf[3];

	MD5STEP(F1, a, b, c, d, in[ 0]+0xd76aa478,  7);
	MD5STEP(F1, d, a, b, c, in[ 1]+0xe8c7b756, 12);
	MD5STEP(F1, c, d, a, b, in[ 2]+0x242070db, 17);
	MD5STEP(F1, b, c, d, a, in[ 3]+0xc1bdceee, 22);
	MD5STEP(F1, a, b, c, d, in[ 4]+0xf57c0faf,  7);
	MD5STEP(F1, d, a, b, c, in[ 5]+0x4787c62a, 12);
	MD5STEP(F1, c, d, a, b, in[ 6]+0xa8304613, 17);
	MD5STEP(F1, b, c, d, a, in[ 7]+0xfd469501, 22);
	MD5STEP(F1, a, b, c, d, in[ 8]+0x698098d8,  7);
	MD5STEP(F1, d, a, b, c, in[ 9]+0x8b44f7af, 12);
	MD5STEP(F1, c, d, a, b, in[10]+0xffff5bb1, 17);
	MD5STEP(F1, b, c, d, a, in[11]+0x895cd7be, 22);
	MD5STEP(F1, a, b, c, d, in[12]+0x6b901122,  7);
	MD5STEP(F1, d, a, b, c, in[13]+0xfd987193, 12);
	MD5STEP(F1, c, d, a, b, in[14]+0xa679438e, 17);
	MD5STEP(F1, b, c, d, a, in[15]+0x49b40821, 22);

	MD5STEP(F2, a, b, c, d, in[ 1]+0xf61e2562,  5);
	MD5STEP(F2, d, a, b, c, in[ 6]+0xc040b340,  9);
	MD5STEP(F2, c, d, a, b, in[11]+0x265e5a51, 14);
	MD5STEP(F2, b, c, d, a, in[ 0]+0xe9b6c7aa, 20);
	MD5STEP(F2, a, b, c, d, in[ 5]+0xd62f105d,  5);
	MD5STEP(F2, d, a, b, c, in[10]+0x02441453,  9);
	MD5STEP(F2, c, d, a, b, in[15]+0xd8a1e681, 14);
	MD5STEP(F2, b, c, d, a, in[ 4]+0xe7d3fbc8, 20);
	MD5STEP(F2, a, b, c, d, in[ 9]+0x21e1cde6,  5);
	MD5STEP(F2, d, a, b, c, in[14]+0xc33707d6,  9);
	MD5STEP(F2, c, d, a, b, in[ 3]+0xf4d50d87, 14);
	MD5STEP(F2, b, c, d, a, in[ 8]+0x455a14ed, 20);
	MD5STEP(F2, a, b, c, d, in[13]+0xa9e3e905,  5);
	MD5STEP(F2, d, a, b, c, in[ 2]+0xfcefa3f8,  9);
	MD5STEP(F2, c, d, a, b, in[ 7]+0x676f02d9, 14);
	MD5STEP(F2, b, c, d, a, in[12]+0x8d2a4c8a, 20);

	MD5STEP(F3, a, b, c, d, in[ 5]+0xfffa3942,  4);
	MD5STEP(F3, d, a, b, c, in[ 8]+0x8771f681, 11);
	MD5STEP(F3, c, d, a, b, in[11]+0x6d9d6122, 16);
	MD5STEP(F3, b, c, d, a, in[14]+0xfde5380c, 23);
	MD5STEP(F3, a, b, c, d, in[ 1]+0xa4beea44,  4);
	MD5STEP(F3, d, a, b, c, in[ 4]+0x4bdecfa9, 11);
	MD5STEP(F3, c, d, a, b, in[ 7]+0xf6bb4b60, 16);
	MD5STEP(F3, b, c, d, a, in[10]+0xbebfbc70, 23);
	MD5STEP(F3, a, b, c, d, in[13]+0x289b7ec6,  4);
	MD5STEP(F3, d, a, b, c, in[ 0]+0xeaa127fa, 11);
	MD5STEP(F3, c, d, a, b, in[ 3]+0xd4ef3085, 16);
	MD5STEP(F3, b, c, d, a, in[ 6]+0x04881d05, 23);
	MD5STEP(F3, a, b, c, d, in[ 9]+0xd9d4d039,  4);
	MD5STEP(F3, d, a, b, c, in[12]+0xe6db99e5, 11);
	MD5STEP(F3, c, d, a, b, in[15]+0x1fa27cf8, 16);
	MD5STEP(F3, b, c, d, a, in[ 2]+0xc4ac5665, 23);

	MD5STEP(F4, a, b, c, d, in[ 0]+0xf4292244,  6);
	MD5STEP(F4, d, a, b, c, in[ 7]+0x432aff97, 10);
	MD5STEP(F4, c, d, a, b, in[14]+0xab9423a7, 15);
	MD5STEP(F4, b, c, d, a, in[ 5]+0xfc93a039, 21);
	MD5STEP(F4, a, b, c, d, in[12]+0x655b59c3,  6);
	MD5STEP(F4, d, a, b, c, in[ 3]+0x8f0ccc92, 10);
	MD5STEP(F4, c, d, a, b, in[10]+0xffeff47d, 15);
	MD5STEP(F4, b, c, d, a, in[ 1]+0x85845dd1, 21);
	MD5STEP(F4, a, b, c, d, in[ 8]+0x6fa87e4f,  6);
	MD5STEP(F4, d, a, b, c, in[15]+0xfe2ce6e0, 10);
	MD5STEP(F4, c, d, a, b, in[ 6]+0xa3014314, 15);
	MD5STEP(F4, b, c, d, a, in[13]+0x4e0811a1, 21);
	MD5STEP(F4, a, b, c, d, in[ 4]+0xf7537e82,  6);
	MD5STEP(F4, d, a, b, c, in[11]+0xbd3af235, 10);
	MD5STEP(F4, c, d, a, b, in[ 2]+0x2ad7d2bb, 15);
	MD5STEP(F4, b, c, d, a, in[ 9]+0xeb86d391, 21);

	buf[0] += a;
	buf[1] += b;
	buf[2] += c;
	buf[3] += d;
}

#undef F1
#undef F2
#undef F3
#undef F4
#undef MD5STEP


d511 1
a511 4
		tmp[0] = 0x67452301;
		tmp[1] = 0xefcdab89;
		tmp[2] = 0x98badcfe;
		tmp[3] = 0x10325476;
@
