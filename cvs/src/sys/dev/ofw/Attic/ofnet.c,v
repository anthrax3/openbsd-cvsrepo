head	1.11;
access;
symbols
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.12
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2007.06.01.23.14.07;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.29.12.50.05;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.08.21.49.16;	author miod;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.06.25.04.47.33;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.20.19.39.42;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	99.10.28.04.25.25;	author rahnds;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	97.11.07.08.07.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.12.23.00.32.57;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.23.00.32.57;	author rahnds;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.25.31;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.07.04.10.41.48;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.10.31.03.22.44;	author nate;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2002.03.28.15.38.28;	author niklas;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove ofw devices which we don't use; that way of mixing devices is crazy
(means i also don not have to fix the daddr_t problems)
ok miod
@
text
@/*	$OpenBSD: ofnet.c,v 1.10 2006/03/15 20:20:41 miod Exp $	*/
/*	$NetBSD: ofnet.c,v 1.4 1996/10/16 19:33:21 ws Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "ofnet.h"
#include "bpfilter.h"

#include <sys/param.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>

#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <dev/ofw/openfirm.h>

#if NIPKDB_OFN > 0
#include <ipkdb/ipkdb.h>
#include <machine/ipkdb.h>

struct cfattach ipkdb_ofn_ca = {
	0, ipkdb_probe, ipkdb_attach
};

static struct ipkdb_if *kifp;
static struct ofn_softc *ipkdb_of;

static int ipkdbprobe(void *, void *);
#endif

struct ofn_softc {
	struct device sc_dev;
	int sc_phandle;
	int sc_ihandle;
	struct arpcom sc_arpcom;
	struct timeout sc_tmo;
	void *dmabuf;
};

static int ofnprobe(struct device *, void *, void *);
static void ofnattach(struct device *, struct device *, void *);

struct cfattach ofnet_ca = {
	sizeof(struct ofn_softc), ofnprobe, ofnattach
};

struct cfdriver ofnet_cd = {
	NULL, "ofnet", DV_IFNET
};

static void ofnread(struct ofn_softc *);
static void ofntimer(struct ofn_softc *);
static void ofninit(struct ofn_softc *);
static void ofnstop(struct ofn_softc *);

static void ofnstart(struct ifnet *);
static int ofnioctl(struct ifnet *, u_long, caddr_t);
static void ofnwatchdog(struct ifnet *);

static int
ofnprobe(struct device *parent, void *match, void *aux)
{
	struct ofprobe *ofp = aux;
	char type[32];
	int l;
	
#if NIPKDB_OFN > 0
	if (!parent)
		return ipkdbprobe(match, aux);
#endif
	if ((l = OF_getprop(ofp->phandle, "device_type", type, sizeof type - 1)) < 0)
		return 0;
	if (l >= sizeof type)
		return 0;
	type[l] = 0;
	if (strcmp(type, "network"))
		return 0;
	return 1;
}

static void
ofnattach(struct device *parent, struct device *self, void *aux)
{
	struct ofn_softc *of = (void *)self;
	struct ifnet *ifp = &of->sc_arpcom.ac_if;
	struct ofprobe *ofp = aux;
	char path[256];
	int l;
	
	of->sc_phandle = ofp->phandle;
#if NIPKDB_OFN > 0
	if (kifp
	    && kifp->unit - 1 == of->sc_dev.dv_unit
	    && OF_instance_to_package(kifp->port) == ofp->phandle)  {
		ipkdb_of = of;
		of->sc_ihandle = kifp->port;
	} else
#endif
	if ((l = OF_package_to_path(ofp->phandle, path, sizeof path - 1)) < 0
	    || l >= sizeof path
	    || (path[l] = 0, !(of->sc_ihandle = OF_open(path))))
		panic("ofnattach: unable to open");
printf("\nethernet dev: path %s\n", path);
	OF_call_method("dma-alloc", of->sc_ihandle, 1, 1, MAXPHYS,
		&(of->dmabuf));
	if (OF_getprop(ofp->phandle, "mac-address",
		       of->sc_arpcom.ac_enaddr, sizeof
			       (of->sc_arpcom.ac_enaddr)) < 0)
	{
		if (OF_getprop(ofp->phandle, "local-mac-address",
			       of->sc_arpcom.ac_enaddr, sizeof
				       (of->sc_arpcom.ac_enaddr)) < 0)
		{
			panic("ofnattach: no mac-address");
		}
	}
	printf(": address %s\n", ether_sprintf(of->sc_arpcom.ac_enaddr));
	
	bcopy(of->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = of;
	ifp->if_start = ofnstart;
	ifp->if_ioctl = ofnioctl;
	ifp->if_watchdog = ofnwatchdog;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;
	IFQ_SET_READY(&ifp->if_snd);

	timeout_set(&of->sc_tmo, ofntimer, of);

	if_attach(ifp);
	ether_ifattach(ifp);
}

static void
ofnread(struct ofn_softc *of)
{
	struct ifnet *ifp = &of->sc_arpcom.ac_if;
	struct mbuf *m, **mp, *head;
	int l, len;
	char *bufp;
	char *buf = of->dmabuf;

#if NIPKDB_OFN > 0
	ipkdbrint(kifp, ifp);
#endif	
	while (1) {
		if ((len = OF_read(of->sc_ihandle, buf, sizeof buf)) < 0) {
			if (len == -2)
				return;
			ifp->if_ierrors++;
			continue;
		}
		if (len < sizeof(struct ether_header)) {
			ifp->if_ierrors++;
			continue;
		}
		bufp = buf;
		
		/* Allocate a header mbuf */
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == 0) {
			ifp->if_ierrors++;
			continue;
		}
		m->m_pkthdr.rcvif = ifp;
		m->m_pkthdr.len = len;
		l = MHLEN;
		head = 0;
		mp = &head;
		
		while (len > 0) {
			if (head) {
				MGET(m, M_DONTWAIT, MT_DATA);
				if (m == 0) {
					ifp->if_ierrors++;
					m_freem(head);
					head = 0;
					break;
				}
				l = MLEN;
			}
			if (len >= MINCLSIZE) {
				MCLGET(m, M_DONTWAIT);
				if (m->m_flags & M_EXT)
					l = MCLBYTES;
			}
			m->m_len = l = min(len, l);
			bcopy(bufp, mtod(m, char *), l);
			bufp += l;
			len -= l;
			*mp = m;
			mp = &m->m_next;
		}
		if (head == 0)
			continue;

#if	NBPFILTER > 0
		if (ifp->if_bpf) {
			bpf->mtap(ifp->if_bpf, m);
#endif
		ifp->if_ipackets++;
		ether_input_mbuf(ifp, head);
	}
}

static void
ofntimer(struct ofn_softc *of)
{
	ofnread(of);
	timeout_add(&of->sc_tmo, 1);
}

static void
ofninit(struct ofn_softc *of)
{
	struct ifnet *ifp = &of->sc_arpcom.ac_if;

	if (ifp->if_flags & IFF_RUNNING)
		return;

	ifp->if_flags |= IFF_RUNNING;
	/* Start reading from interface */
	ofntimer(of);
	/* Attempt to start output */
	ofnstart(ifp);
}

static void
ofnstop(struct ofn_softc *of)
{
	timeout_del(&of->sc_tmo);
	of->sc_arpcom.ac_if.if_flags &= ~IFF_RUNNING;
}

static void
ofnstart(struct ifnet *ifp)
{
	struct ofn_softc *of = ifp->if_softc;
	struct mbuf *m, *m0;
	char *bufp;
	char *buf;
	int len;
	buf = of->dmabuf;
	
	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	for (;;) {
		/* First try reading any packets */
		ofnread(of);
		
		/* Now get the first packet on the queue */
		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (!m0)
			return;
		
		if (!(m0->m_flags & M_PKTHDR))
			panic("ofnstart: no header mbuf");
		len = m0->m_pkthdr.len;
		
		if (len > ETHERMTU + sizeof(struct ether_header)) {
			/* packet too large, toss it */
			ifp->if_oerrors++;
			m_freem(m0);
			continue;
		}

#if NPBFILTER > 0
		if (ifp->if_bpf)
			bpf_mtab(ifp->if_bpf, m0);
#endif
		for (bufp = buf; m = m0;) {
			bcopy(mtod(m, char *), bufp, m->m_len);
			bufp += m->m_len;
			MFREE(m, m0);
		}
		if (OF_write(of->sc_ihandle, buf, bufp - buf) != bufp - buf)
			ifp->if_oerrors++;
		else
			ifp->if_opackets++;
	}
}

static int
ofnioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ofn_softc *of = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr = (struct ifreq *)data;
	int error = 0;
	
	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		
		switch (ifa->ifa_addr->sa_family) {
#ifdef	INET
		case AF_INET:
			arp_ifinit(&of->sc_arpcom, ifa);
			break;
#endif
		default:
			break;
		}
		ofninit(of);
		break;
	case SIOCSIFFLAGS:
		if (!(ifp->if_flags & IFF_UP)
		    && (ifp->if_flags & IFF_RUNNING)) {
			/* If interface is down, but running, stop it. */
			ofnstop(of);
		} else if ((ifp->if_flags & IFF_UP)
			   && !(ifp->if_flags & IFF_RUNNING)) {
			/* If interface is up, but not running, start it. */
			ofninit(of);
		} else {
			/* Other flags are ignored. */
		}
		break;
	default:
		error = EINVAL;
		break;
	}
	return error;
}

static void
ofnwatchdog(struct ifnet *ifp)
{
	struct ofn_softc *of = ifp->if_softc;
	
	log(LOG_ERR, "%s: device timeout\n", of->sc_dev.dv_xname);
	of->sc_arpcom.ac_if.if_oerrors++;
	ofnstop(of);
	ofninit(of);
}

#if NIPKDB_OFN > 0
/* has not been updated to use dmabuf */
static void
ipkdbofstart(struct ipkdb_if *kip)
{
	int unit = kip->unit - 1;
	
	if (ipkdb_of)
		ipkdbattach(kip, &ipkdb_of->sc_arpcom);
}

static void
ipkdbofleave(struct ipkdb_if *kip)
{
}

static int
ipkdbofrcv(struct ipkdb_if *kip, u_char *buf, int poll)
{
	int l;
	
	do {
		l = OF_read(kip->port, buf, ETHERMTU);
		if (l < 0)
			l = 0;
	} while (!poll && !l);
	return l;
}

static void
ipkdbofsend(struct ipkdb_if *kip, u_char *buf, int l)
{
	OF_write(kip->port, buf, l);
}

static int
ipkdbprobe(void *match, void *aux)
{
	struct cfdata *cf = match;
	struct ipkdb_if *kip = aux;
	static char name[256];
	int len;
	int phandle;
	
	kip->unit = cf->cf_unit + 1;

	if (!(kip->port = OF_open("net")))
		return -1;
	if ((len = OF_instance_to_path(kip->port, name, sizeof name - 1)) < 0
	    || len >= sizeof name)
		return -1;
	name[len] = 0;
	if ((phandle = OF_instance_to_package(kip->port)) == -1)
		return -1;
	if ( OF_getprop(phandle, "local-mac-address", kip->myenetaddr, sizeof kip->myenetaddr) &&
	OF_getprop(phandle, "mac-address", kip->myenetaddr, sizeof kip->myenetaddr)
	    < 0)
		return -1;
	
	kip->flags |= IPKDB_MYHW;
	kip->name = name;
	kip->start = ipkdbofstart;
	kip->leave = ipkdbofleave;
	kip->receive = ipkdbofrcv;
	kip->send = ipkdbofsend;

	kifp = kip;
	
	return 0;
}
#endif
@


1.10
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.9 2004/11/29 12:50:05 jsg Exp $	*/
@


1.9
log
@knf/ansi. No binary change.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.8 2002/03/14 01:26:58 millert Exp $	*/
a166 2

	dk_establish(0, self);					/* XXX */
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.7 2002/03/12 09:51:20 kjc Exp $	*/
d97 1
a97 3
ofnprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d118 1
a118 3
ofnattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d172 1
a172 2
ofnread(of)
	struct ofn_softc *of;
d244 1
a244 2
ofntimer(of)
	struct ofn_softc *of;
d251 1
a251 2
ofninit(of)
	struct ofn_softc *of;
d266 1
a266 2
ofnstop(of)
	struct ofn_softc *of;
d273 1
a273 2
ofnstart(ifp)
	struct ifnet *ifp;
d322 1
a322 4
ofnioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d365 1
a365 2
ofnwatchdog(ifp)
	struct ifnet *ifp;
d378 1
a378 2
ipkdbofstart(kip)
	struct ipkdb_if *kip;
d387 1
a387 2
ipkdbofleave(kip)
	struct ipkdb_if *kip;
d392 1
a392 4
ipkdbofrcv(kip, buf, poll)
	struct ipkdb_if *kip;
	u_char *buf;
	int poll;
d405 1
a405 4
ipkdbofsend(kip, buf, l)
	struct ipkdb_if *kip;
	u_char *buf;
	int l;
d411 1
a411 2
ipkdbprobe(match, aux)
	void *match, *aux;
@


1.7
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.6 2001/08/08 21:49:16 miod Exp $	*/
d64 1
a64 1
static int ipkdbprobe __P((void *, void *));
d76 2
a77 2
static int ofnprobe __P((struct device *, void *, void *));
static void ofnattach __P((struct device *, struct device *, void *));
d87 8
a94 8
static void ofnread __P((struct ofn_softc *));
static void ofntimer __P((struct ofn_softc *));
static void ofninit __P((struct ofn_softc *));
static void ofnstop __P((struct ofn_softc *));

static void ofnstart __P((struct ifnet *));
static int ofnioctl __P((struct ifnet *, u_long, caddr_t));
static void ofnwatchdog __P((struct ifnet *));
@


1.6
log
@New timeouts, drahn@@ sez go ahead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.5 2001/06/25 04:47:33 fgsch Exp $	*/
d165 1
d299 1
a299 1
		IF_DEQUEUE(&ifp->if_snd, m0);
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.6 2001/08/08 21:49:16 miod Exp $	*/
d64 1
a64 1
static int ipkdbprobe(void *, void *);
d76 2
a77 2
static int ofnprobe(struct device *, void *, void *);
static void ofnattach(struct device *, struct device *, void *);
d87 8
a94 8
static void ofnread(struct ofn_softc *);
static void ofntimer(struct ofn_softc *);
static void ofninit(struct ofn_softc *);
static void ofnstop(struct ofn_softc *);

static void ofnstart(struct ifnet *);
static int ofnioctl(struct ifnet *, u_long, caddr_t);
static void ofnwatchdog(struct ifnet *);
a164 1
	IFQ_SET_READY(&ifp->if_snd);
d298 1
a298 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.5
log
@ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.4 2001/02/20 19:39:42 mickey Exp $	*/
d72 1
d166 2
d252 1
a252 1
	timeout(ofntimer, of, 1);
d275 1
a275 1
	untimeout(ofntimer, of);
@


1.4
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.3 1999/10/28 04:25:25 rahnds Exp $	*/
a175 1
	struct ether_header *eh;
a233 1
		eh = mtod(head, struct ether_header *);
a238 1
		m_adj(head, sizeof(struct ether_header));
d240 1
a240 1
		ether_input(ifp, eh, head);
@


1.3
log
@Sync up with some piece of reality, start supporting powerpc again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.2 1997/11/07 08:07:22 niklas Exp $	*/
a166 5

#if NBPFILTER > 0
	bpfattach(&of->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
		  sizeof(struct ether_header));
#endif
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.4 2001/02/20 19:39:42 mickey Exp $	*/
d167 5
@


1.3.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.3.2.1 2001/05/14 22:25:31 niklas Exp $	*/
d176 1
d235 1
d241 1
d243 1
a243 1
		ether_input_mbuf(ifp, head);
@


1.3.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.3.2.2 2001/07/04 10:41:48 niklas Exp $	*/
a71 1
	struct timeout sc_tmo;
a164 2
	timeout_set(&of->sc_tmo, ofntimer, of);

d249 1
a249 1
	timeout_add(&of->sc_tmo, 1);
d272 1
a272 1
	timeout_del(&of->sc_tmo);
@


1.3.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
a64 1
static int ipkdbprobe(void *, void *);
d76 2
a77 2
static int ofnprobe(struct device *, void *, void *);
static void ofnattach(struct device *, struct device *, void *);
d87 8
a94 8
static void ofnread(struct ofn_softc *);
static void ofntimer(struct ofn_softc *);
static void ofninit(struct ofn_softc *);
static void ofnstop(struct ofn_softc *);

static void ofnstart(struct ifnet *);
static int ofnioctl(struct ifnet *, u_long, caddr_t);
static void ofnwatchdog(struct ifnet *);
a164 1
	IFQ_SET_READY(&ifp->if_snd);
d298 1
a298 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: ofnet.c,v 1.4 1996/10/16 19:33:21 ws Exp $	*/
d72 1
d142 3
d146 10
a155 3
		       of->sc_arpcom.ac_enaddr, sizeof of->sc_arpcom.ac_enaddr)
	    < 0)
		panic("ofnattach: no max-address");
a175 2
static char buf[ETHERMTU + sizeof(struct ether_header)];

d185 1
d291 1
d293 1
d393 1
d455 2
a456 1
	if (OF_getprop(phandle, "mac-address", kip->myenetaddr, sizeof kip->myenetaddr)
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Import of Openfirmware device drivers for PowerPC port.
From NetBSD, with modification to get current time in kernel.
@
text
@@
