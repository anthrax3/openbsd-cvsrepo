head	1.7;
access;
symbols
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.12
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	powerpc_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2007.06.01.23.14.07;	author deraadt;	state dead;
branches;
next	1.6;

1.6
date	2004.11.29.12.50.05;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.08.22.34.24;	author deraadt;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	98.06.28.06.37.15;	author rahnds;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	97.11.07.08.07.23;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.12.23.00.32.56;	author rahnds;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.23.00.32.56;	author rahnds;	state Exp;
branches;
next	;

1.3.8.1
date	2001.05.14.22.25.31;	author niklas;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2002.03.28.15.38.28;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove ofw devices which we don't use; that way of mixing devices is crazy
(means i also don not have to fix the daddr_t problems)
ok miod
@
text
@/*	$OpenBSD: ofrtc.c,v 1.6 2004/11/29 12:50:05 jsg Exp $	*/
/*	$NetBSD: ofrtc.c,v 1.3 1996/10/13 01:38:14 christos Exp $	*/

/*
 * Copyright (C) 1996 Wolfgang Solfrank.
 * Copyright (C) 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>

#include <dev/ofw/openfirm.h>

struct ofrtc_softc {
	struct device sc_dev;
	int sc_phandle;
	int sc_ihandle;
};

static int ofrtcprobe(struct device *, void *, void *);
static void ofrtcattach(struct device *, struct device *, void *);

struct cfattach ofrtc_ca = {
	sizeof(struct ofrtc_softc), ofrtcprobe, ofrtcattach
};

struct cfdriver ofrtc_cd = {
	NULL, "ofrtc", DV_DULL
};

static int
ofrtcprobe(struct device *parent, void *match, void *aux)
{
	struct ofprobe *ofp = aux;
	char type[8];
	int l;
	
	if ((l = OF_getprop(ofp->phandle, "device_type", type, sizeof type - 1)) < 0)
		return 0;
	if (l >= sizeof type)
		return 0;
	
	return !strcmp(type, "rtc");
}

int OF_clock_read(int *sec, int *min, int *hour, int *day,
         int *mon, int *yr);
typedef int (clock_read_t)(int *sec, int *min, int *hour, int *day,
         int *mon, int *yr);
extern clock_read_t *clock_read;

static void
ofrtcattach(struct device *parent, struct device *self, void *aux)
{
	struct ofrtc_softc *of = (void *)self;
	struct ofprobe *ofp = aux;
	char name[32];
	int l;
	
	clock_read = &OF_clock_read;
	of->sc_phandle = ofp->phandle;
	of->sc_ihandle = 0;
	if ((l = OF_getprop(of->sc_phandle, "name", name, sizeof name - 1)) < 0)
		panic("Device without name?");
	if (l >= sizeof name)
		l = sizeof name - 1;
	name[l] = 0;
	printf(": %s\n", name);
}

int
ofrtcopen(dev_t dev, int flags, int fmt)
{
	struct ofrtc_softc *of;
	int unit = minor(dev);
	char path[256];
	int l;
	
	if (unit >= ofrtc_cd.cd_ndevs)
		return ENXIO;
	if (!(of = ofrtc_cd.cd_devs[unit]))
		return ENXIO;
	if (!of->sc_ihandle) {
		if ((l = OF_package_to_path(of->sc_phandle, path, sizeof path - 1)) < 0)
			return ENXIO;
		if (l >= sizeof path)
			return ENXIO;
		path[l] = 0;
		
		if (!(of->sc_ihandle = OF_open(path))) {
			if (of->sc_ihandle) {
				OF_close(of->sc_ihandle);
				of->sc_ihandle = 0;
			}
			return ENXIO;
		}

	}

	return 0;
}

int
ofrtcclose(dev_t dev, int flags, int fmt)
{
	return 0;
}

static void
twodigit(char *bp, int i)
{
	*bp++ = i / 10 + '0';
	*bp = i % 10 + '0';
}

static int
twodigits(char *bp)
{
	int i;
	
	i = *bp++ - '0';
	return i * 10 + *bp++ - '0';
}

int
ofrtcread(dev_t dev, struct uio *uio, int flag)
{
	struct ofrtc_softc *of = ofrtc_cd.cd_devs[minor(dev)];
	int date[6];
	char buf[14];
	int xlen;
	
	if (uio->uio_offset >= sizeof buf)
		return 0;
	
	if (OF_call_method("get-time", of->sc_ihandle, 0, 6,
	    date, date + 1, date + 2,
	    date + 3, date + 4, date + 5))
		return EIO;

	twodigit(buf, date[5] % 100);
	twodigit(buf + 2, date[4]);
	twodigit(buf + 4, date[3]);
	twodigit(buf + 6, date[2]);
	twodigit(buf + 8, date[1]);
	buf[10] = '.';
	twodigit(buf + 11, date[0]);
	buf[13] = '\n';
	
	xlen = sizeof(buf) - uio->uio_offset;
	if (xlen > uio->uio_resid)
		xlen = uio->uio_resid;
	
	return uiomove((caddr_t)buf, xlen, uio);
}

int
ofrtcwrite(dev_t dev, struct uio *uio, int flag)
{
	struct ofrtc_softc *of = ofrtc_cd.cd_devs[minor(dev)];
	char buf[14];
	int cnt, year, error;
	
	/*
	 * We require atomic updates!
	 */
	cnt = uio->uio_resid;
	if (uio->uio_offset || (cnt != sizeof buf && cnt != sizeof buf - 1))
		return EINVAL;
	
	if (error = uiomove((caddr_t)buf, sizeof buf, uio))
		return error;

	if (cnt == sizeof buf && buf[sizeof buf - 1] != '\n')
		return EINVAL;
	
	year = twodigits(buf) + 1900;
	if (year < 1970)
		year += 100;
	if (OF_call_method("set-time", of->sc_ihandle, 6, 0,
	    twodigits(buf + 11), twodigits(buf + 8), twodigits(buf + 6),
	    twodigits(buf + 4), twodigits(buf + 2), year))
		return EIO;
	return 0;
}



/* powerpc expects clock_read data in BCD, discuss this if it is improper */
#define TOBCD(x)        (((x) / 10 * 16) + ((x) % 10))
#define YEAR0		1900

int
OF_clock_read(int *sec, int *min, int *hour, int *day,
         int *mon, int *yr)
{
	struct ofrtc_softc *of;
        char path[256];
        int l;

	if (!(of = ofrtc_cd.cd_devs[0]))
		return 1;
	if ((l = OF_package_to_path(of->sc_phandle, path, sizeof path - 1)) < 0)
		return 1;
	if (l >= sizeof path)
		return 1;
	path[l] = 0;
	
	if (!(of->sc_ihandle = OF_open(path))) {
		if (of->sc_ihandle) {
			OF_close(of->sc_ihandle);
			of->sc_ihandle = 0;
		}
		return 1;
	}
	if (OF_call_method("get-time", of->sc_ihandle, 0, 6,
	    sec, min, hour, day, mon, yr))
		return 1;
#if 0
	printf("y:%d m:%d d:%d H:%d M:%d S:%d\n",
		*yr, *mon, *day, *hour, *min, *sec);
#endif
	*yr -= YEAR0; /* bsd expects 0 - 200, not something like 1998 */
	*yr = TOBCD(*yr);
	*mon = TOBCD(*mon);
	*day = TOBCD(*day);
	*hour = TOBCD(*hour);
	*min = TOBCD(*min);
	*sec = TOBCD(*sec);

	return 0;
}
@


1.6
log
@knf/ansi. No binary change.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofrtc.c,v 1.5 2002/03/14 01:26:58 millert Exp $	*/
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ofrtc.c,v 1.4 2000/08/08 22:34:24 deraadt Exp $	*/
d58 1
a58 3
ofrtcprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d79 1
a79 3
ofrtcattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d98 1
a98 4
ofrtcopen(dev, flags, fmt)
	dev_t dev;
	int flags;
	int fmt;
d130 1
a130 4
ofrtcclose(dev, flags, fmt)
	dev_t dev;
	int flags;
	int fmt;
d136 1
a136 3
twodigit(bp, i)
	char *bp;
	int i;
d143 1
a143 2
twodigits(bp)
	char *bp;
d152 1
a152 4
ofrtcread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d184 1
a184 4
ofrtcwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
@


1.4
log
@quiet
@
text
@d1 1
a1 1
/*	$OpenBSD: ofrtc.c,v 1.3 1998/06/28 06:37:15 rahnds Exp $	*/
d46 2
a47 2
static int ofrtcprobe __P((struct device *, void *, void *));
static void ofrtcattach __P((struct device *, struct device *, void *));
@


1.4.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ofrtc.c,v 1.4 2000/08/08 22:34:24 deraadt Exp $	*/
d46 2
a47 2
static int ofrtcprobe(struct device *, void *, void *);
static void ofrtcattach(struct device *, struct device *, void *);
@


1.3
log
@make the openfirmware clock reading routine compatible with the
"typical" hardware clock read routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofrtc.c,v 1.2 1997/11/07 08:07:23 niklas Exp $	*/
d179 2
a180 2
			   date, date + 1, date + 2,
			   date + 3, date + 4, date + 5))
d226 2
a227 2
			   twodigits(buf + 11), twodigits(buf + 8), twodigits(buf + 6),
			   twodigits(buf + 4), twodigits(buf + 2), year))
d262 3
a264 4
			sec, min, hour, day, mon, yr))
	{
	return 1;
	}
d267 1
@


1.3.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ofrtc.c,v 1.4 2000/08/08 22:34:24 deraadt Exp $	*/
d179 2
a180 2
	    date, date + 1, date + 2,
	    date + 3, date + 4, date + 5))
d226 2
a227 2
	    twodigits(buf + 11), twodigits(buf + 8), twodigits(buf + 6),
	    twodigits(buf + 4), twodigits(buf + 2), year))
d262 4
a265 3
	    sec, min, hour, day, mon, yr))
		return 1;
#if 0
a267 1
#endif
@


1.3.8.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 2
a47 2
static int ofrtcprobe(struct device *, void *, void *);
static void ofrtcattach(struct device *, struct device *, void *);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: ofrtc.c,v 1.3 1996/10/13 01:38:14 christos Exp $	*/
d233 5
d247 1
a247 1
		return 0;
d249 1
a249 1
		return 0;
d251 1
a251 1
		return 0;
d259 1
a259 1
		return 0;
d263 12
a274 1
		return 0;
d276 1
a276 1
	return 1;
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@Import of Openfirmware device drivers for PowerPC port.
From NetBSD, with modification to get current time in kernel.
@
text
@@
