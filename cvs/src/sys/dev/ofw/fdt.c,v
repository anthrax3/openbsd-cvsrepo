head	1.20;
access;
symbols
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17;
locks; strict;
comment	@ * @;


1.20
date	2017.03.12.11.44.42;	author kettenis;	state Exp;
branches;
next	1.19;
commitid	EI38NWUhFaLvENjQ;

1.19
date	2016.08.23.18.12.09;	author kettenis;	state Exp;
branches;
next	1.18;
commitid	QVPcH04Hp9qQOAgf;

1.18
date	2016.07.26.22.10.10;	author patrick;	state Exp;
branches;
next	1.17;
commitid	QHTy0YAECnrTlcSQ;

1.17
date	2016.07.09.12.31.05;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	dHtESIDokOOOkBsl;

1.16
date	2016.07.08.18.20.48;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	B8O72mjP7TKbWA2R;

1.15
date	2016.06.29.13.39.03;	author visa;	state Exp;
branches;
next	1.14;
commitid	0PNsCePSBnkTfbxY;

1.14
date	2016.06.14.14.35.27;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	isIPWu0Yw01HhvCt;

1.13
date	2016.06.14.10.03.51;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	hY1fXXVkwBC2K3rB;

1.12
date	2016.06.12.12.55.42;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	BaLLTMJpcKjC80FA;

1.11
date	2016.06.08.15.27.05;	author jsg;	state Exp;
branches;
next	1.10;
commitid	O8sdMmMKqczNQU5p;

1.10
date	2016.05.21.21.24.36;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	JypHiPUuFFLvJ1DT;

1.9
date	2016.05.16.21.12.17;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	YXa0iFXO6YiUN61p;

1.8
date	2016.04.06.12.10.04;	author patrick;	state Exp;
branches;
next	1.7;
commitid	SUgYGfTwbzwuM9CH;

1.7
date	2016.04.06.11.42.50;	author patrick;	state Exp;
branches;
next	1.6;
commitid	fpDaEw54cjvMNlmz;

1.6
date	2016.04.03.13.48.07;	author patrick;	state Exp;
branches;
next	1.5;
commitid	SvlUP6pS3VMK8Fw2;

1.5
date	2016.04.03.12.32.13;	author patrick;	state Exp;
branches;
next	1.4;
commitid	6gKqQgE2hd0iA1Fm;

1.4
date	2016.04.03.11.22.51;	author patrick;	state Exp;
branches;
next	1.3;
commitid	ymk3pAgWXKEs5Dsz;

1.3
date	2016.03.17.14.10.29;	author mpi;	state Exp;
branches;
next	1.2;
commitid	BkyhtHz31BkDsY8m;

1.2
date	2016.03.07.10.49.03;	author mpi;	state Exp;
branches;
next	1.1;
commitid	VP5MBFFk7HERmN5f;

1.1
date	2016.03.03.02.42.16;	author bmercer;	state Exp;
branches;
next	;
commitid	T6tioCndC2dgvM4T;


desc
@@


1.20
log
@Introduce OF_getindex() API and use it to replace multiple instances of
pretty much identical code.

ok visa@@
@
text
@/*	$OpenBSD: fdt.c,v 1.19 2016/08/23 18:12:09 kettenis Exp $	*/

/*
 * Copyright (c) 2009 Dariusz Swiderski <sfires@@sfires.net>
 * Copyright (c) 2009 Mark Kettenis <kettenis@@sfires.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/systm.h>
#include <sys/malloc.h>

#include <dev/ofw/fdt.h>
#include <dev/ofw/openfirm.h>

/* XXX */
#define OPROMMAXPARAM	32

unsigned int fdt_check_head(void *);
char	*fdt_get_str(u_int32_t);
void	*skip_property(u_int32_t *);
void	*skip_props(u_int32_t *);
void	*skip_node_name(u_int32_t *);
void	*skip_node(void *);
void	*skip_nops(u_int32_t *);
void	*fdt_parent_node_recurse(void *, void *);
void	*fdt_find_phandle_recurse(void *, uint32_t);
int	 fdt_node_property_int(void *, char *, int *);
int	 fdt_node_property_ints(void *, char *, int *, int);
int	 fdt_translate_reg(void *, struct fdt_reg *);
#ifdef DEBUG
void 	 fdt_print_node_recurse(void *, int);
#endif

static int tree_inited = 0;
static struct fdt tree;

unsigned int
fdt_check_head(void *fdt)
{
	struct fdt_head *fh;
	u_int32_t *ptr, *tok;

	fh = fdt;
	ptr = (u_int32_t *)fdt;

	if (betoh32(fh->fh_magic) != FDT_MAGIC)
		return 0;

	if (betoh32(fh->fh_version) > FDT_CODE_VERSION)
		return 0;

	tok = skip_nops(ptr + (betoh32(fh->fh_struct_off) / 4));
	if (betoh32(*tok) != FDT_NODE_BEGIN)
		return 0;

	/* check for end signature on version 17 blob */
	if ((betoh32(fh->fh_version) >= 17) &&
	    (betoh32(*(ptr + (betoh32(fh->fh_struct_off) / 4) +
	    (betoh32(fh->fh_struct_size) / 4) - 1)) != FDT_END))
		return 0;

	return betoh32(fh->fh_version);
}

/*
 * Initializes internal structures of module.
 * Has to be called once, preferably in machdep.c.
 */
int
fdt_init(void *fdt)
{
	int version;

	bzero(&tree, sizeof(struct fdt));
	tree_inited = 0;

	if (!fdt)
		return 0;

	if (!(version = fdt_check_head(fdt)))
		return 0;

	tree.header = (struct fdt_head *)fdt;
	tree.tree = (char *)fdt + betoh32(tree.header->fh_struct_off);
	tree.strings = (char *)fdt + betoh32(tree.header->fh_strings_off);
	tree.memory = (char *)fdt + betoh32(tree.header->fh_reserve_off);
	tree.version = version;
	tree.strings_size = betoh32(tree.header->fh_strings_size);
	tree_inited = 1;

	return version;
}

/*
 * Return the size of the FDT.
 */
size_t
fdt_get_size(void *fdt)
{
	if (!fdt)
		return 0;

	if (!fdt_check_head(fdt))
		return 0;

	return betoh32(((struct fdt_head *)fdt)->fh_size);
}

/*
 * Retrieve string pointer from strings table.
 */
char *
fdt_get_str(u_int32_t num)
{
	if (num > tree.strings_size)
		return NULL;
	return (tree.strings) ? (tree.strings + num) : NULL;
}

/*
 * Utility functions for skipping parts of tree.
 */

void *
skip_nops(u_int32_t *ptr)
{
	while (betoh32(*ptr) == FDT_NOP)
		ptr++;

	return ptr;
}

void *
skip_property(u_int32_t *ptr)
{
	u_int32_t size;

	size = betoh32(*(ptr + 1));
	/* move forward by magic + size + nameid + rounded up property size */
	ptr += 3 + roundup(size, sizeof(u_int32_t)) / sizeof(u_int32_t);

	return skip_nops(ptr);
}

void *
skip_props(u_int32_t *ptr)
{
	while (betoh32(*ptr) == FDT_PROPERTY) {
		ptr = skip_property(ptr);
	}
	return ptr;
}

void *
skip_node_name(u_int32_t *ptr)
{
	/* skip name, aligned to 4 bytes, this is NULL term., so must add 1 */
	ptr += roundup(strlen((char *)ptr) + 1,
	    sizeof(u_int32_t)) / sizeof(u_int32_t);

	return skip_nops(ptr);
}

/*
 * Retrieves node property, the returned pointer is inside the fdt tree,
 * so we should not modify content pointed by it directly.
 */
int
fdt_node_property(void *node, char *name, char **out)
{
	u_int32_t *ptr;
	u_int32_t nameid;
	char *tmp;
	
	if (!tree_inited)
		return -1;

	ptr = (u_int32_t *)node;

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return -1;

	ptr = skip_node_name(ptr + 1);

	while (betoh32(*ptr) == FDT_PROPERTY) {
		nameid = betoh32(*(ptr + 2)); /* id of name in strings table */
		tmp = fdt_get_str(nameid);
		if (!strcmp(name, tmp)) {
			*out = (char *)(ptr + 3); /* beginning of the value */
			return betoh32(*(ptr + 1)); /* size of value */
		}
		ptr = skip_property(ptr);
	}
	return -1;
}

/*
 * Retrieves next node, skipping all the children nodes of the pointed node,
 * returns pointer to next node, no matter if it exists or not.
 */
void *
skip_node(void *node)
{
	u_int32_t *ptr = node;

	ptr++;

	ptr = skip_node_name(ptr);
	ptr = skip_props(ptr);

	/* skip children */
	while (betoh32(*ptr) == FDT_NODE_BEGIN)
		ptr = skip_node(ptr);

	return skip_nops(ptr + 1);
}

/*
 * Retrieves next node, skipping all the children nodes of the pointed node,
 * returns pointer to next node if exists, otherwise returns NULL.
 * If passed 0 will return first node of the tree (root).
 */
void *
fdt_next_node(void *node)
{
	u_int32_t *ptr;

	if (!tree_inited)
		return NULL;

	ptr = node;

	if (node == NULL) {
		ptr = skip_nops(tree.tree);
		return (betoh32(*ptr) == FDT_NODE_BEGIN) ? ptr : NULL;
	}

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return NULL;

	ptr++;

	ptr = skip_node_name(ptr);
	ptr = skip_props(ptr);

	/* skip children */
	while (betoh32(*ptr) == FDT_NODE_BEGIN)
		ptr = skip_node(ptr);

	if (betoh32(*ptr) != FDT_NODE_END)
		return NULL;

	ptr = skip_nops(ptr + 1);

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return NULL;

	return ptr;
}

int
fdt_next_property(void *node, char *name, char **nextname)
{
	u_int32_t *ptr;
	u_int32_t nameid;
	
	if (!tree_inited)
		return 0;

	ptr = (u_int32_t *)node;

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return 0;

	ptr = skip_node_name(ptr + 1);

	while (betoh32(*ptr) == FDT_PROPERTY) {
		nameid = betoh32(*(ptr + 2)); /* id of name in strings table */
		if (strcmp(name, "") == 0) {
			*nextname = fdt_get_str(nameid);
			return 1;
		}
		if (strcmp(name, fdt_get_str(nameid)) == 0) {
			ptr = skip_property(ptr);
			if (betoh32(*ptr) != FDT_PROPERTY)
				break;
			nameid = betoh32(*(ptr + 2));
			*nextname = fdt_get_str(nameid);
			return 1;
		}
		ptr = skip_property(ptr);
	}
	*nextname = "";
	return 1;
}

/*
 * Retrieves node property as integers and puts them in the given
 * integer array.
 */
int
fdt_node_property_ints(void *node, char *name, int *out, int outlen)
{
	int *data;
	int i, inlen;

	inlen = fdt_node_property(node, name, (char **)&data) / sizeof(int);
	if (inlen <= 0)
		return -1;

	for (i = 0; i < inlen && i < outlen; i++)
		out[i] = betoh32(data[i]);

	return i;
}

/*
 * Retrieves node property as an integer.
 */
int
fdt_node_property_int(void *node, char *name, int *out)
{
	return fdt_node_property_ints(node, name, out, 1);
}

/*
 * Retrieves next node, skipping all the children nodes of the pointed node
 */
void *
fdt_child_node(void *node)
{
	u_int32_t *ptr;

	if (!tree_inited)
		return NULL;

	ptr = node;

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return NULL;

	ptr++;

	ptr = skip_node_name(ptr);
	ptr = skip_props(ptr);
	/* check if there is a child node */
	return (betoh32(*ptr) == FDT_NODE_BEGIN) ? (ptr) : NULL;
}

/*
 * Retrieves node name.
 */
char *
fdt_node_name(void *node)
{
	u_int32_t *ptr;

	if (!tree_inited)
		return NULL;

	ptr = node;

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return NULL;

	return (char *)(ptr + 1);
}

void *
fdt_find_node(char *name)
{
	void *node = fdt_next_node(0);
	const char *p = name;

	if (!tree_inited)
		return NULL;

	if (*p != '/')
		return NULL;

	while (*p) {
		void *child;
		const char *q;

		while (*p == '/')
			p++;
		if (*p == 0)
			return node;
		q = strchr(p, '/');
		if (q == NULL)
			q = p + strlen(p);

		for (child = fdt_child_node(node); child;
		     child = fdt_next_node(child)) {
			if (strncmp(p, fdt_node_name(child), q - p) == 0) {
				node = child;
				break;
			}
		}

		if (child == NULL)
			return NULL; /* No match found. */

		p = q;
	}

	return node;
}

void *
fdt_parent_node_recurse(void *pnode, void *child)
{
	void *node = fdt_child_node(pnode);
	void *tmp;

	while (node && (node != child)) {
		if ((tmp = fdt_parent_node_recurse(node, child)))
			return tmp;
		node = fdt_next_node(node);
	}
	return (node) ? pnode : NULL;
}

void *
fdt_parent_node(void *node)
{
	void *pnode = fdt_next_node(0);

	if (!tree_inited)
		return NULL;

	if (node == pnode)
		return NULL;

	return fdt_parent_node_recurse(pnode, node);
}

void *
fdt_find_phandle_recurse(void *node, uint32_t phandle)
{
	void *child;
	char *data;
	void *tmp;
	int len;

	len = fdt_node_property(node, "phandle", &data);
	if (len < 0)
		len = fdt_node_property(node, "linux,phandle", &data);

	if (len == sizeof(uint32_t) && bemtoh32(data) == phandle)
		return node;

	for (child = fdt_child_node(node); child; child = fdt_next_node(child))
		if ((tmp = fdt_find_phandle_recurse(child, phandle)))
			return tmp;

	return NULL;
}

void *
fdt_find_phandle(uint32_t phandle)
{
	return fdt_find_phandle_recurse(fdt_next_node(0), phandle);
}

/*
 * Translate memory address depending on parent's range.
 *
 * Ranges are a way of mapping one address to another.  This ranges attribute
 * is set on a node's parent.  This means if a node does not have a parent,
 * there's nothing to translate.  If it does have a parent and the parent does
 * not have a ranges attribute, there's nothing to translate either.
 *
 * If the parent has a ranges attribute and the attribute is not empty, the
 * node's memory address has to be in one of the given ranges.  This range is
 * then used to translate the memory address.
 *
 * If the parent has a ranges attribute, but the attribute is empty, there's
 * nothing to translate.  But it's not a translation barrier.  It can be treated
 * as a simple 1:1 mapping.
 *
 * Translation does not end here.  We need to check if the parent's parent also
 * has a ranges attribute and ask the same questions again.
 */
int
fdt_translate_reg(void *node, struct fdt_reg *reg)
{
	void *parent;
	int pac, psc, ac, sc, ret, rlen, rone, *range;
	uint64_t from, to, size;

	/* No parent, no translation. */
	parent = fdt_parent_node(node);
	if (parent == NULL)
		return 0;

	/* Extract ranges property from node. */
	rlen = fdt_node_property(node, "ranges", (char **)&range) / sizeof(int);

	/* No ranges means translation barrier. Translation stops here. */
	if (range == NULL)
		return 0;

	/* Empty ranges means 1:1 mapping. Continue translation on parent. */
	if (rlen <= 0)
		return fdt_translate_reg(parent, reg);

	/* We only support 32-bit (1), and 64-bit (2) wide addresses here. */
	ret = fdt_node_property_int(parent, "#address-cells", &pac);
	if (ret != 1 || pac <= 0 || pac > 2)
		return EINVAL;

	/* We only support 32-bit (1), and 64-bit (2) wide sizes here. */
	ret = fdt_node_property_int(parent, "#size-cells", &psc);
	if (ret != 1 || psc <= 0 || psc > 2)
		return EINVAL;

	/* We only support 32-bit (1), and 64-bit (2) wide addresses here. */
	ret = fdt_node_property_int(node, "#address-cells", &ac);
	if (ret <= 0)
		ac = pac;
	else if (ret > 1 || ac <= 0 || ac > 2)
		return EINVAL;

	/* We only support 32-bit (1), and 64-bit (2) wide sizes here. */
	ret = fdt_node_property_int(node, "#size-cells", &sc);
	if (ret <= 0)
		sc = psc;
	else if (ret > 1 || sc <= 0 || sc > 2)
		return EINVAL;

	/* Must have at least one range. */
	rone = pac + ac + sc;
	if (rlen < rone)
		return ESRCH;

	/* For each range. */
	for (; rlen >= rone; rlen -= rone, range += rone) {
		/* Extract from and size, so we can see if we fit. */
		from = betoh32(range[0]);
		if (ac == 2)
			from = (from << 32) + betoh32(range[1]);
		size = betoh32(range[ac + pac]);
		if (sc == 2)
			size = (size << 32) + betoh32(range[ac + pac + 1]);

		/* Try next, if we're not in the range. */
		if (reg->addr < from || (reg->addr + reg->size) > (from + size))
			continue;

		/* All good, extract to address and translate. */
		to = betoh32(range[ac]);
		if (pac == 2)
			to = (to << 32) + betoh32(range[ac + 1]);

		reg->addr -= from;
		reg->addr += to;
		return fdt_translate_reg(parent, reg);
	}

	/* To be successful, we must have returned in the for-loop. */
	return ESRCH;
}

/*
 * Parse the memory address and size of a node.
 */
int
fdt_get_reg(void *node, int idx, struct fdt_reg *reg)
{
	void *parent;
	int ac, sc, off, ret, *in, inlen;

	if (node == NULL || reg == NULL)
		return EINVAL;

	parent = fdt_parent_node(node);
	if (parent == NULL)
		return EINVAL;

	/* We only support 32-bit (1), and 64-bit (2) wide addresses here. */
	ret = fdt_node_property_int(parent, "#address-cells", &ac);
	if (ret != 1 || ac <= 0 || ac > 2)
		return EINVAL;

	/* We only support 32-bit (1), and 64-bit (2) wide sizes here. */
	ret = fdt_node_property_int(parent, "#size-cells", &sc);
	if (ret != 1 || sc <= 0 || sc > 2)
		return EINVAL;

	inlen = fdt_node_property(node, "reg", (char **)&in) / sizeof(int);
	if (inlen < ((idx + 1) * (ac + sc)))
		return EINVAL;

	off = idx * (ac + sc);

	reg->addr = betoh32(in[off]);
	if (ac == 2)
		reg->addr = (reg->addr << 32) + betoh32(in[off + 1]);

	reg->size = betoh32(in[off + ac]);
	if (sc == 2)
		reg->size = (reg->size << 32) + betoh32(in[off + ac + 1]);

	return fdt_translate_reg(parent, reg);
}

int
fdt_is_compatible(void *node, const char *name)
{
	char *data;
	int len;

	len = fdt_node_property(node, "compatible", &data);
	while (len > 0) {
		if (strcmp(data, name) == 0)
			return 1;
		len -= strlen(data) + 1;
		data += strlen(data) + 1;
	}

	return 0;
}

#ifdef DEBUG
/*
 * Debug methods for printing whole tree, particular odes and properies
 */
void *
fdt_print_property(void *node, int level)
{
	u_int32_t *ptr;
	char *tmp, *value;
	int cnt;
	u_int32_t nameid, size;

	ptr = (u_int32_t *)node;

	if (!tree_inited)
		return NULL;

	if (betoh32(*ptr) != FDT_PROPERTY)
		return ptr; /* should never happen */

	/* extract property name_id and size */
	size = betoh32(*++ptr);
	nameid = betoh32(*++ptr);

	for (cnt = 0; cnt < level; cnt++)
		printf("\t");

	tmp = fdt_get_str(nameid);
	printf("\t%s : ", tmp ? tmp : "NO_NAME");

	ptr++;
	value = (char *)ptr;

	if (!strcmp(tmp, "device_type") || !strcmp(tmp, "compatible") ||
	    !strcmp(tmp, "model") || !strcmp(tmp, "bootargs") ||
	    !strcmp(tmp, "linux,stdout-path")) {
		printf("%s", value);
	} else if (!strcmp(tmp, "clock-frequency") ||
	    !strcmp(tmp, "timebase-frequency")) {
		printf("%d", betoh32(*((unsigned int *)value)));
	} else {
		for (cnt = 0; cnt < size; cnt++) {
			if ((cnt % sizeof(u_int32_t)) == 0)
				printf(" ");
			printf("%02x", value[cnt]);
		}
	}
	ptr += roundup(size, sizeof(u_int32_t)) / sizeof(u_int32_t);
	printf("\n");

	return ptr;
}

void
fdt_print_node(void *node, int level)
{
	u_int32_t *ptr;
	int cnt;
	
	ptr = (u_int32_t *)node;

	if (betoh32(*ptr) != FDT_NODE_BEGIN)
		return;

	ptr++;

	for (cnt = 0; cnt < level; cnt++)
		printf("\t");
	printf("%s :\n", fdt_node_name(node));
	ptr = skip_node_name(ptr);

	while (betoh32(*ptr) == FDT_PROPERTY)
		ptr = fdt_print_property(ptr, level);
}

void
fdt_print_node_recurse(void *node, int level)
{
	void *child;

	fdt_print_node(node, level);
	for (child = fdt_child_node(node); child; child = fdt_next_node(child))
		fdt_print_node_recurse(child, level + 1);
}

void
fdt_print_tree(void)
{
	fdt_print_node_recurse(fdt_next_node(0), 0);
}
#endif

int
OF_peer(int handle)
{
	void *node = (char *)tree.header + handle;

	if (handle == 0)
		node = fdt_find_node("/");
	else
		node = fdt_next_node(node);
	return node ? ((char *)node - (char *)tree.header) : 0;
}

int
OF_child(int handle)
{
	void *node = (char *)tree.header + handle;

	node = fdt_child_node(node);
	return node ? ((char *)node - (char *)tree.header) : 0;
}

int
OF_parent(int handle)
{
	void *node = (char *)tree.header + handle;

	node = fdt_parent_node(node);
	return node ? ((char *)node - (char *)tree.header) : 0;
}

int
OF_finddevice(char *name)
{
	void *node;

	node = fdt_find_node(name);
	return node ? ((char *)node - (char *)tree.header) : -1;
}

int
OF_getnodebyname(int handle, const char *name)
{
	void *node = (char *)tree.header + handle;

	if (handle == 0)
		node = fdt_find_node("/");

	while (node) {
		if (strcmp(name, fdt_node_name(node)) == 0)
			break;

		node = fdt_next_node(node);
	}

	return node ? ((char *)node - (char *)tree.header) : 0;
}

int
OF_getnodebyphandle(uint32_t phandle)
{
	void *node;

	node = fdt_find_phandle(phandle);
	return node ? ((char *)node - (char *)tree.header) : 0;
}

int
OF_getproplen(int handle, char *prop)
{
	void *node = (char *)tree.header + handle;
	char *data, *name;
	int len;

	len = fdt_node_property(node, prop, &data);

	/*
	 * The "name" property is optional since version 16 of the
	 * flattened device tree specification, so we synthesize one
	 * from the unit name of the node if it is missing.
	 */
	if (len < 0 && strcmp(prop, "name") == 0) {
		name = fdt_node_name(node);
		data = strchr(name, '@@');
		if (data)
			len = data - name;
		else
			len = strlen(name);
		return len + 1;
	}

	return len;
}

int
OF_getprop(int handle, char *prop, void *buf, int buflen)
{
	void *node = (char *)tree.header + handle;
	char *data;
	int len;

	len = fdt_node_property(node, prop, &data);

	/*
	 * The "name" property is optional since version 16 of the
	 * flattened device tree specification, so we synthesize one
	 * from the unit name of the node if it is missing.
	 */
	if (len < 0 && strcmp(prop, "name") == 0) {
		data = fdt_node_name(node);
		if (data) {
			len = strlcpy(buf, data, buflen);
			data = strchr(buf, '@@');
			if (data) {
				*data = 0;
				len = data - (char *)buf;
			}
			return len + 1;
		}
	}

	if (len > 0)
		memcpy(buf, data, min(len, buflen));
	return len;
}

uint32_t
OF_getpropint(int handle, char *prop, uint32_t defval)
{
	uint32_t val;
	int len;
	
	len = OF_getprop(handle, prop, &val, sizeof(val));
	if (len != sizeof(val))
		return defval;

	return betoh32(val);
}

int
OF_getpropintarray(int handle, char *prop, uint32_t *buf, int buflen)
{
	int len;
	int i;

	len = OF_getprop(handle, prop, buf, buflen);
	if (len < 0 || (len % sizeof(uint32_t)))
		return -1;

	for (i = 0; i < len / sizeof(uint32_t); i++)
		buf[i] = betoh32(buf[i]);

	return len;
}

int
OF_nextprop(int handle, char *prop, void *nextprop)
{
	void *node = (char *)tree.header + handle;
	char *data;

	if (fdt_node_property(node, "name", &data) == -1) {
		if (strcmp(prop, "") == 0)
			return strlcpy(nextprop, "name", OPROMMAXPARAM);
		if (strcmp(prop, "name") == 0)
			prop = "";
	}

	if (fdt_next_property(node, prop, &data))
		return strlcpy(nextprop, data, OPROMMAXPARAM);
	return -1;
}

int
OF_is_compatible(int handle, const char *name)
{
	void *node = (char *)tree.header + handle;
	return (fdt_is_compatible(node, name));
}

int
OF_getindex(int handle, const char *entry, const char *prop)
{
	char *names;
	char *name;
	char *end;
	int idx = 0;
	int len;

	if (entry == NULL)
		return 0;

	len = OF_getproplen(handle, (char *)prop);
	if (len <= 0)
		return -1;

	names = malloc(len, M_TEMP, M_WAITOK);
	OF_getprop(handle, (char *)prop, names, len);
	end = names + len;
	name = names;
	while (name < end) {
		if (strcmp(name, entry) == 0) {
			free(names, M_TEMP, len);
			return idx;
		}
		name += strlen(name) + 1;
		idx++;
	}
	free(names, M_TEMP, len);
	return -1;
}
@


1.19
log
@Actually make fdt_find_node() return NULL if the node couldn't be found.

ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.18 2016/07/26 22:10:10 patrick Exp $	*/
a20 1
#include <sys/param.h>
d22 1
d908 31
@


1.18
log
@Rename struct fdt_memory to fdt_reg to match the member name
used in the fdt attach args and the device tree.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.17 2016/07/09 12:31:05 kettenis Exp $	*/
d412 3
@


1.17
log
@Add interfaces to look up a device tree node by phandle.

ok patrick@@, jsg@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.16 2016/07/08 18:20:48 kettenis Exp $	*/
d41 1
a41 1
int	 fdt_translate_memory_address(void *, struct fdt_memory *);
d495 1
a495 1
fdt_translate_memory_address(void *node, struct fdt_memory *mem)
d515 1
a515 1
		return fdt_translate_memory_address(parent, mem);
d557 1
a557 1
		if (mem->addr < from || (mem->addr + mem->size) > (from + size))
d565 3
a567 3
		mem->addr -= from;
		mem->addr += to;
		return fdt_translate_memory_address(parent, mem);
d578 1
a578 1
fdt_get_memory_address(void *node, int idx, struct fdt_memory *mem)
d583 1
a583 1
	if (node == NULL || mem == NULL)
d606 1
a606 1
	mem->addr = betoh32(in[off]);
d608 1
a608 1
		mem->addr = (mem->addr << 32) + betoh32(in[off + 1]);
d610 1
a610 1
	mem->size = betoh32(in[off + ac]);
d612 1
a612 1
		mem->size = (mem->size << 32) + betoh32(in[off + ac + 1]);
d614 1
a614 1
	return fdt_translate_memory_address(parent, mem);
@


1.16
log
@Fix check for "name" property.  Restores synthesised "name" proprties in
eeprom -p output that were lost in revision 1.13.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.15 2016/06/29 13:39:03 visa Exp $	*/
d38 1
d447 28
d780 9
@


1.15
log
@Make the fdt parser skip nop tokens. This is needed on some
octeon boards.

Feedback and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.14 2016/06/14 14:35:27 kettenis Exp $	*/
d848 1
a848 1
	if (fdt_node_property(node, "name", &data) == 0) {
@


1.14
log
@Make sure OF_getprop() returns the proper length for a synthesised "name"
property.

From Tom Cosgrove.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.13 2016/06/14 10:03:51 kettenis Exp $	*/
d36 1
d52 1
a52 1
	u_int32_t *ptr;
d63 2
a64 2
	if (betoh32(*(ptr + (betoh32(fh->fh_struct_off) / 4))) !=
	    FDT_NODE_BEGIN)
d134 10
d153 1
a153 1
	return ptr;
d169 1
a169 1
	return ptr + roundup(strlen((char *)ptr) + 1,
d171 2
d226 1
a226 1
	return (ptr + 1);
d245 1
a245 1
		ptr = tree.tree;
d264 3
a266 1
	if (betoh32(*(ptr + 1)) != FDT_NODE_BEGIN)
d269 1
a269 1
	return (ptr + 1);
@


1.13
log
@Make fdt_node_property() return -1 if the requested property can't be found
such that we can distinguish between non-existing properties and zero-length
properties.  This brings the FDT code in line with the real OFW
implementations.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.12 2016/06/12 12:55:42 kettenis Exp $	*/
d785 1
a785 1
			if (data)
d787 2
@


1.12
log
@Add OF_getpropint() and OF_getpropintarray().

ok visa@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.11 2016/06/08 15:27:05 jsg Exp $	*/
d174 1
a174 1
		return 0;
d179 1
a179 1
		return 0;
d192 1
a192 1
	return 0;
d753 1
a753 1
	if (len == 0 && strcmp(prop, "name") == 0) {
d780 1
a780 1
	if (len == 0 && strcmp(prop, "name") == 0) {
d816 1
a816 1
	if (len <0 || (len % sizeof(uint32_t)))
@


1.11
log
@Use fdt to find the console to initialise.  Try to use /chosen/stdout-path
if present otherwise fallback to /aliases/serial0.

Don't require a platform match to run the various console init functions
so the init functions will run for unknown board ids.

With and ok kettenis@@ on a earlier version.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.10 2016/05/21 21:24:36 kettenis Exp $	*/
d793 29
@


1.10
log
@Implement openprom(4) for armv7.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.9 2016/05/16 21:12:17 kettenis Exp $	*/
d573 17
d818 1
a818 12
	char *data;
	int len;

	len = fdt_node_property(node, "compatible", &data);
	while (len > 0) {
		if (strcmp(data, name) == 0)
			return 1;
		len -= strlen(data) + 1;
		data += strlen(data) + 1;
	}

	return 0;
@


1.9
log
@Introduce OF_is_compatible(9), a convenience function to check the "compatible"
property of an OFW/FDT node.

ok deraadt@@, pactrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.8 2016/04/06 12:10:04 patrick Exp $	*/
a19 1

d27 3
d257 36
d705 18
d726 19
a744 1
	char *data;
d746 1
a746 1
	return fdt_node_property(node, prop, &data);
d777 18
@


1.8
log
@Convert memory extract routine to return errno-based errors.

Also check that mem is not NULL, as its part of the FDT API
and should make sure it's not accessing a null pointer.

ok bmercer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.7 2016/04/06 11:42:50 patrick Exp $	*/
d704 19
@


1.7
log
@Add support for bus space translation.

The ranges property can be used to translate from one address space
to another.  This means that we cannot just use a controllers's reg
property to get the physical address, but have to use its parent's
ranges attribute to translate the address to another.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.6 2016/04/03 13:48:07 patrick Exp $	*/
d501 2
a502 2
	if (node == NULL)
		return 1;
d506 1
a506 1
		return 1;
d511 1
a511 1
		return 1;
d516 1
a516 1
		return 1;
d520 1
a520 1
		return 1;
@


1.6
log
@Remove erroneous whitespace added in previous change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.5 2016/04/03 12:32:13 patrick Exp $	*/
d37 1
d394 99
d532 1
a532 4
	/* TODO: translate memory address in ranges */
	//return fdt_translate_memory_address(parent, mem);

	return 0;
@


1.5
log
@Implement a way to extract memory information from a node.  This can be
used to extract information about how much RAM is available or where a
controller is in the address space and how big its IO space is.

Add a way to get the device tree's size.  This is helpful to find out
how much you need to copy if you want to move the tree somewhere else.

Also add helpers to easily retrieve integers from a property.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.4 2016/04/03 11:22:51 patrick Exp $	*/
d101 1
a101 1
 /*
@


1.4
log
@The callers of fdt_next_node() expect it to return NULL if a next node
cannot be found.  Due to implementation details, it used to return
a pointer to the next node, without checking if it actually exists.

Modify fdt_next_node() to only return a next node if it actually exists
and implement an internal skip_node() function that keeps the previous
behaviour.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.3 2016/03/17 14:10:29 mpi Exp $	*/
d35 2
d101 15
d255 29
d390 46
@


1.3
log
@Do not iterate all over the tree if OF_parent() is called on the root
node.  The root is the root, it has no parent.

From Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.2 2016/03/07 10:49:03 mpi Exp $	*/
d33 1
d176 24
a199 2
 * Retrieves next node, skipping all the children nodes of the pointed node
 * if passed 0 wil return first node of the tree (root)
d211 1
a211 1
	if (!node) {
d226 7
a232 1
		ptr = fdt_next_node(ptr);
d234 1
a234 1
	return (betoh32(*ptr) == FDT_NODE_END) ? (ptr + 1) : NULL;
@


1.2
log
@Fix end signature check, from Patrick Wildt.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.1 2016/03/03 02:42:16 bmercer Exp $	*/
d294 1
a294 1
	
d311 3
d434 1
a434 1
	
@


1.1
log
@Move fdt to a more centralized location so it can be used by arm as well. Diff from Patrick Wildt. Tested and OK dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdt.c,v 1.12 2016/02/28 12:39:40 mpi Exp $	*/
d62 2
a63 1
	    (betoh32(*(ptr + betoh32(fh->fh_struct_size))) != FDT_END))
@

