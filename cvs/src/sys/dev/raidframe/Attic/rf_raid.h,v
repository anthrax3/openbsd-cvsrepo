head	1.9;
access;
symbols
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.20
	OPENBSD_5_0:1.8.0.18
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.16
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.14
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.10
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.12
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.8
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.6
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.4
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.18
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.16
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.14
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.12
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.10
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.6.0.8
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.8;

1.8
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.08.16.07.44;	author peter;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2000.01.07.14.50.22;	author peter;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.08.04.13.10.55;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.33;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.13;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.41;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.13;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.6.8.1
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_raid.h,v 1.8 2007/04/10 17:47:55 miod Exp $	*/
/*	$NetBSD: rf_raid.h,v 1.12 2000/02/24 17:12:10 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*************************************************
 * rf_raid.h -- Main header file for RAID driver.
 *************************************************/


#ifndef	_RF__RF_RAID_H_
#define	_RF__RF_RAID_H_

#include "rf_archs.h"
#include "rf_types.h"
#include "rf_threadstuff.h"

#if	defined(__NetBSD__)
#include "rf_netbsd.h"
#elif	defined(__OpenBSD__)
#include "rf_openbsd.h"
#endif

#include <sys/disklabel.h>
#include <sys/types.h>

#include "rf_alloclist.h"
#include "rf_stripelocks.h"
#include "rf_layout.h"
#include "rf_disks.h"
#include "rf_debugMem.h"
#include "rf_diskqueue.h"
#include "rf_reconstruct.h"
#include "rf_acctrace.h"

#if	RF_INCLUDE_PARITYLOGGING > 0
#include "rf_paritylog.h"
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */

#define	RF_MAX_DISKS			128	/* Max disks per array. */
#define	RF_DEV2RAIDID(_dev)		(DISKUNIT(_dev))

#define	RF_COMPONENT_LABEL_VERSION_1	1
#define	RF_COMPONENT_LABEL_VERSION	2
#define	RF_RAID_DIRTY			0
#define	RF_RAID_CLEAN			1

/*
 * Each row in the array is a distinct parity group, so
 * each has its own status, which is one of the following.
 */
typedef enum RF_RowStatus_e {
	rf_rs_optimal,
	rf_rs_degraded,
	rf_rs_reconstructing,
	rf_rs_reconfigured
} RF_RowStatus_t;

struct RF_CumulativeStats_s {
	struct timeval		start;		/*
						 * The time when the stats were
						 * last started.
						 */
	struct timeval		stop;		/*
						 * The time when the stats were
						 * last stopped.
						 */
	long			sum_io_us;	/*
						 * Sum of all user response
						 * times (us).
						 */
	long			num_ios;	/*
						 * Total number of I/Os
						 * serviced.
						 */
	long			num_sect_moved;	/*
						 * Total number of sectors read
						 * or written.
						 */
};

struct RF_ThroughputStats_s {
	RF_DECLARE_MUTEX	(mutex);	/*
						 * A mutex used to lock the
						 * configuration stuff.
						 */
	struct timeval		 start;		/*
						 * Timer started when
						 * numOutstandingRequests
						 * moves from 0 to 1.
						 */
	struct timeval		 stop;		/*
						 * Timer stopped when
						 * numOutstandingRequests
						 * moves from 1 to 0.
						 */
	RF_uint64		 sum_io_us;	/*
						 * Total time timer is enabled.
						 */
	RF_uint64		 num_ios;	/*
						 * Total number of I/Os
						 * processed by RAIDframe.
						 */
	long			 num_out_ios;	/*
						 * Number of outstanding I/Os.
						 */
};

struct RF_Raid_s {
	/* This portion never changes, and can be accessed without locking */
	/*
	 * An exception is Disks[][].status, which requires locking when it is
	 * changed. XXX This is no longer true. numSpare and friends can
	 * change now.
	 */
	u_int			  numRow;	/*
						 * Number of rows of disks,
						 * typically == # of ranks.
						 */
	u_int			  numCol;	/*
						 * Number of columns of disks,
						 * typically == # of disks/rank.
						 */
	u_int			  numSpare;	/* Number of spare disks. */
	int			  maxQueueDepth;/* Max disk queue depth. */
	RF_SectorCount_t	  totalSectors;	/*
						 * Total number of sectors
						 * in the array.
						 */
	RF_SectorCount_t	  sectorsPerDisk;
						/*
						 * Number of sectors on each
						 * disk.
						 */
	u_int			  logBytesPerSector;
						/*
						 * Base-2 log of the number
						 * of bytes in a sector.
						 */
	u_int			  bytesPerSector;
						/* Bytes in a sector. */
	RF_int32		  sectorMask;	/* Mask of bytes-per-sector. */

	RF_RaidLayout_t		  Layout;	/*
						 * All information related to
						 * layout.
						 */
	RF_RaidDisk_t		**Disks;	/*
						 * All information related to
						 * physical disks.
						 */
	RF_DiskQueue_t		**Queues;	/*
						 * All information related to
						 * disk queues.
						 */
	RF_DiskQueueSW_t	 *qType;	/*
						 * Pointer to the DiskQueueSW
						 * used for the component
						 * queues.
						 */
	/*
	 * NOTE:  This is an anchor point via which the queues can be
	 * accessed, but the enqueue/dequeue routines in diskqueue.c use a
	 * local copy of this pointer for the actual accesses.
	 */
	/*
	 * The remainder of the structure can change, and therefore requires
	 * locking on reads and updates.
	 */
	RF_DECLARE_MUTEX	 (mutex);	/*
						 * Mutex used to serialize
						 * access to the fields below.
						 */
	RF_RowStatus_t		 *status;	/*
						 * The status of each row in
						 * the array.
						 */
	int			  valid;	/*
						 * Indicates successful
						 * configuration.
						 */
	RF_LockTableEntry_t	 *lockTable;	/* Stripe-lock table. */
	RF_LockTableEntry_t	 *quiesceLock;	/* Quiescence table. */
	int			  numFailures;	/*
						 * Total number of failures
						 * in the array.
						 */
	int			  numNewFailures;
						/*
						 * Number of *new* failures
						 * (that haven't caused a
						 * mod_counter update).
						 */

	int			  parity_good;	/*
						 * !0 if parity is known to be
						 * correct.
						 */
	int			  serial_number;/*
						 * A "serial number" for this
						 * set.
						 */
	int			  mod_counter;	/*
						 * Modification counter for
						 * component labels.
						 */
	int			  clean;	/*
						 * The clean bit for this array.
						 */

	int			  openings;	/*
						 * Number of I/Os that can be
						 * scheduled simultaneously
						 * (high-level - not a
				 		 * per-component limit).
						 */

	int			  maxOutstanding;
						/*
						 * maxOutstanding requests
						 * (per-component).
						 */
	int			  autoconfigure;
						/*
						 * Automatically configure
						 * this RAID set.
						 * 0 == no, 1 == yes
						 */
	int			  root_partition;
						/*
						 * Use this set as
						 * 0 == no, 1 == yes.
						 */
	int			  last_unit;	/*
						 * Last unit number (e.g. 0
						 * for /dev/raid0) of this
						 * component. Used for
						 * autoconfigure only.
						 */
	int			  config_order;	/*
						 * 0 .. n. The order in which
						 * the component should be
						 * auto-configured.
						 * E.g. 0 is will done first,
						 * (and would become raid0).
						 * This may be in conflict
						 * with last_unit !!?!
						 */
						/* Not currently used. */

	/*
	 * Cleanup stuff.
	 */
	RF_ShutdownList_t	 *shutdownList;	/* Shutdown activities. */
	RF_AllocListElem_t	 *cleanupList;	/*
						 * Memory to be freed at
						 * shutdown time.
						 */

	/*
	 * Recon stuff.
	 */
	RF_HeadSepLimit_t	  headSepLimit;
	int			  numFloatingReconBufs;
	int			  reconInProgress;
	RF_DECLARE_COND		 (waitForReconCond);
	RF_RaidReconDesc_t	 *reconDesc;	/* Reconstruction descriptor. */
	RF_ReconCtrl_t		**reconControl;	/*
						 * Reconstruction control
						 * structure pointers for each
						 * row in the array.
						 */

	/*
	 * Array-quiescence stuff.
	 */
	RF_DECLARE_MUTEX	 (access_suspend_mutex);
	RF_DECLARE_COND		 (quiescent_cond);
	RF_IoCount_t		  accesses_suspended;
	RF_IoCount_t		  accs_in_flight;
	int			  access_suspend_release;
	int			  waiting_for_quiescence;
	RF_CallbackDesc_t	 *quiesce_wait_list;

	/*
	 * Statistics.
	 */
#if	!defined(_KERNEL) && !defined(SIMULATE)
	RF_ThroughputStats_t	  throughputstats;
#endif	/* !_KERNEL && !SIMULATE */
	RF_CumulativeStats_t	  userstats;
	int			  parity_rewrite_stripes_done;
	int			  recon_stripes_done;
	int			  copyback_stripes_done;

	int			  recon_in_progress;
	int			  parity_rewrite_in_progress;
	int			  copyback_in_progress;

	/*
	 * Engine thread control.
	 */
	RF_DECLARE_MUTEX	 (node_queue_mutex);
	RF_DECLARE_COND		 (node_queue_cond);
	RF_DagNode_t		 *node_queue;
	RF_Thread_t		  parity_rewrite_thread;
	RF_Thread_t		  copyback_thread;
	RF_Thread_t		  engine_thread;
	RF_Thread_t		  recon_thread;
	RF_ThreadGroup_t	  engine_tg;
	int			  shutdown_engine;
	int			  dags_in_flight;	/* Debug. */

	/*
	 * PSS (Parity Stripe Status) stuff.
	 */
	RF_FreeList_t		 *pss_freelist;
	long			  pssTableSize;

	/*
	 * Reconstruction stuff.
	 */
	int			  procsInBufWait;
	int			  numFullReconBuffers;
	RF_AccTraceEntry_t	 *recon_tracerecs;
	unsigned long		  accumXorTimeUs;
	RF_ReconDoneProc_t	 *recon_done_procs;
	RF_DECLARE_MUTEX	 (recon_done_proc_mutex);
	/*
	 * nAccOutstanding, waitShutdown protected by desc freelist lock
	 * (This may seem strange, since that's a central serialization point
	 * for a per-array piece of data, but otherwise, it'd be an extra
	 * per-array lock, and that'd only be less efficient...)
	 */
	RF_DECLARE_COND		 (outstandingCond);
	int			  waitShutdown;
	int			  nAccOutstanding;

	RF_DiskId_t		**diskids;
	RF_DiskId_t		 *sparediskids;

	int			  raidid;
	RF_AccTotals_t		  acc_totals;
	int			  keep_acc_totals;

	struct raidcinfo	**raid_cinfo;	/* Array of component info. */

	int			  terminate_disk_queues;

	/*
	 * XXX
	 *
	 * Config-specific information should be moved
	 * somewhere else, or at least hung off this
	 * in some generic way.
	 */

	/* Used by rf_compute_workload_shift. */
	RF_RowCol_t		  hist_diskreq[RF_MAXROW][RF_MAXCOL];

	/* Used by declustering. */
	int			  noRotate;

#if	RF_INCLUDE_PARITYLOGGING > 0
	/* used by parity logging */
	RF_SectorCount_t	  regionLogCapacity;
	RF_ParityLogQueue_t	  parityLogPool;/*
						 * Pool of unused parity logs.
						 */
	RF_RegionInfo_t		 *regionInfo;	/* Array of region state. */
	int			  numParityLogs;
	int			  numSectorsPerLog;
	int			  regionParityRange;
	int			  logsInUse;	/* Debugging. */
	RF_ParityLogDiskQueue_t	  parityLogDiskQueue;
						/*
						 * State of parity logging
						 * disk work.
						 */
	RF_RegionBufferQueue_t	  regionBufferPool;
					 	/*
						 * buffers for holding region
						 * log.
						 */
	RF_RegionBufferQueue_t	  parityBufferPool;
						/*
						 * Buffers for holding parity.
						 */
	caddr_t			  parityLogBufferHeap;
						/*
						 * Pool of unused parity logs.
						 */
	RF_Thread_t		  pLogDiskThreadHandle;

#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
};

#endif	/* !_RF__RF_RAID_H_ */
@


1.8
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_raid.h,v 1.7 2002/12/16 07:01:04 tdeval Exp $	*/
@


1.7
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_raid.h,v 1.6 2000/08/08 16:07:44 peter Exp $	*/
d75 1
a75 1
 * each has it's own status, which is one of the following.
@


1.6
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_raid.h,v 1.5 2000/01/07 14:50:22 peter Exp $	*/
d3 1
d31 3
a33 3
/**********************************************
 * rf_raid.h -- main header file for RAID driver
 **********************************************/
d36 2
a37 2
#ifndef _RF__RF_RAID_H_
#define _RF__RF_RAID_H_
d43 1
a43 1
#if defined(__NetBSD__)
d45 1
a45 1
#elif defined(__OpenBSD__)
d61 1
a61 1
#if RF_INCLUDE_PARITYLOGGING > 0
d63 1
a63 1
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
d65 2
a66 2
#define RF_MAX_DISKS 128	/* max disks per array */
#define RF_DEV2RAIDID(_dev)  (DISKUNIT(_dev))
d68 4
a71 4
#define RF_COMPONENT_LABEL_VERSION_1 1
#define RF_COMPONENT_LABEL_VERSION 2
#define RF_RAID_DIRTY 0
#define RF_RAID_CLEAN 1
d82 1
a82 1
}       RF_RowStatus_t;
d85 20
a104 5
	struct timeval start;	/* the time when the stats were last started */
	struct timeval stop;	/* the time when the stats were last stopped */
	long    sum_io_us;	/* sum of all user response times (us) */
	long    num_ios;	/* total number of I/Os serviced */
	long    num_sect_moved;	/* total number of sectors read or written */
d108 24
a131 9
	RF_DECLARE_MUTEX(mutex)	/* a mutex used to lock the configuration
				 * stuff */
	struct timeval start;	/* timer started when numOutstandingRequests
				 * moves from 0 to 1 */
	struct timeval stop;	/* timer stopped when numOutstandingRequests
				 * moves from 1 to 0 */
	RF_uint64 sum_io_us;	/* total time timer is enabled */
	RF_uint64 num_ios;	/* total number of ios processed by RAIDframe */
	long    num_out_ios;	/* number of outstanding ios */
d136 52
a187 25
	/* an exception is Disks[][].status, which requires locking when it is
	 * changed.  XXX this is no longer true.  numSpare and friends can 
	 * change now. 
         */
	u_int   numRow;		/* number of rows of disks, typically == # of
				 * ranks */
	u_int   numCol;		/* number of columns of disks, typically == #
				 * of disks/rank */
	u_int   numSpare;	/* number of spare disks */
	int     maxQueueDepth;	/* max disk queue depth */
	RF_SectorCount_t totalSectors;	/* total number of sectors in the
					 * array */
	RF_SectorCount_t sectorsPerDisk;	/* number of sectors on each
						 * disk */
	u_int   logBytesPerSector;	/* base-2 log of the number of bytes
					 * in a sector */
	u_int   bytesPerSector;	/* bytes in a sector */
	RF_int32 sectorMask;	/* mask of bytes-per-sector */

	RF_RaidLayout_t Layout;	/* all information related to layout */
	RF_RaidDisk_t **Disks;	/* all information related to physical disks */
	RF_DiskQueue_t **Queues;/* all information related to disk queues */
	RF_DiskQueueSW_t *qType;/* pointer to the DiskQueueSW used for the
				   component queues. */
	/* NOTE:  This is an anchor point via which the queues can be
d189 135
a323 137
	 * local copy of this pointer for the actual accesses. */
	/* The remainder of the structure can change, and therefore requires
	 * locking on reads and updates */
	        RF_DECLARE_MUTEX(mutex)	/* mutex used to serialize access to
					 * the fields below */
	RF_RowStatus_t *status;	/* the status of each row in the array */
	int     valid;		/* indicates successful configuration */
	RF_LockTableEntry_t *lockTable;	/* stripe-lock table */
	RF_LockTableEntry_t *quiesceLock;	/* quiesnce table */
	int     numFailures;	/* total number of failures in the array */
	int     numNewFailures; /* number of *new* failures (that havn't 
				   caused a mod_counter update */

	int     parity_good;    /* !0 if parity is known to be correct */
	int     serial_number;  /* a "serial number" for this set */
	int     mod_counter;    /* modification counter for component labels */
	int     clean;          /* the clean bit for this array. */

	int     openings;       /* Number of IO's which can be scheduled
				   simultaneously (high-level - not a 
				   per-component limit)*/

	int maxOutstanding;   /* maxOutstanding requests (per-component) */
	int autoconfigure;    /* automatically configure this RAID set. 
				 0 == no, 1 == yes */
	int root_partition;   /* Use this set as /
				 0 == no, 1 == yes*/
	int last_unit;        /* last unit number (e.g. 0 for /dev/raid0) 
				 of this component.  Used for autoconfigure
				 only. */
	int config_order;     /* 0 .. n.  The order in which the component
				 should be auto-configured.  E.g. 0 is will 
				 done first, (and would become raid0).
				 This may be in conflict with last_unit!!?! */
	                      /* Not currently used. */

	/*
         * Cleanup stuff
         */
	RF_ShutdownList_t *shutdownList;	/* shutdown activities */
	RF_AllocListElem_t *cleanupList;	/* memory to be freed at
						 * shutdown time */

	/*
         * Recon stuff
         */
	RF_HeadSepLimit_t headSepLimit;
	int     numFloatingReconBufs;
	int     reconInProgress;
	        RF_DECLARE_COND(waitForReconCond)
	RF_RaidReconDesc_t *reconDesc;	/* reconstruction descriptor */
	RF_ReconCtrl_t **reconControl;	/* reconstruction control structure
					 * pointers for each row in the array */

	/*
         * Array-quiescence stuff
         */
	        RF_DECLARE_MUTEX(access_suspend_mutex)
	        RF_DECLARE_COND(quiescent_cond)
	RF_IoCount_t accesses_suspended;
	RF_IoCount_t accs_in_flight;
	int     access_suspend_release;
	int     waiting_for_quiescence;
	RF_CallbackDesc_t *quiesce_wait_list;

	/*
         * Statistics
         */
#if !defined(_KERNEL) && !defined(SIMULATE)
	RF_ThroughputStats_t throughputstats;
#endif				/* !_KERNEL && !SIMULATE */
	RF_CumulativeStats_t userstats;
	int     parity_rewrite_stripes_done;
	int     recon_stripes_done;
	int     copyback_stripes_done;

	int     recon_in_progress;
	int     parity_rewrite_in_progress;
	int     copyback_in_progress;

	/*
         * Engine thread control
         */
	RF_DECLARE_MUTEX(node_queue_mutex)
	RF_DECLARE_COND(node_queue_cond)
	RF_DagNode_t *node_queue;
	RF_Thread_t parity_rewrite_thread;
	RF_Thread_t copyback_thread;
	RF_Thread_t engine_thread;
	RF_Thread_t recon_thread;
	RF_ThreadGroup_t engine_tg;
	int     shutdown_engine;
	int     dags_in_flight;	/* debug */

	/*
         * PSS (Parity Stripe Status) stuff
         */
	RF_FreeList_t *pss_freelist;
	long    pssTableSize;

	/*
         * Reconstruction stuff
         */
	int     procsInBufWait;
	int     numFullReconBuffers;
	RF_AccTraceEntry_t *recon_tracerecs;
	unsigned long accumXorTimeUs;
	RF_ReconDoneProc_t *recon_done_procs;
	        RF_DECLARE_MUTEX(recon_done_proc_mutex)
	/*
         * nAccOutstanding, waitShutdown protected by desc freelist lock
         * (This may seem strange, since that's a central serialization point
         * for a per-array piece of data, but otherwise, it'd be an extra
         * per-array lock, and that'd only be less efficient...)
         */
	        RF_DECLARE_COND(outstandingCond)
	int     waitShutdown;
	int     nAccOutstanding;

	RF_DiskId_t **diskids;
	RF_DiskId_t *sparediskids;

	int     raidid;
	RF_AccTotals_t acc_totals;
	int     keep_acc_totals;

	struct raidcinfo **raid_cinfo;	/* array of component info */

	int     terminate_disk_queues;

	/*
         * XXX
         *
         * config-specific information should be moved
         * somewhere else, or at least hung off this
         * in some generic way
         */
d325 45
a369 2
	/* used by rf_compute_workload_shift */
	RF_RowCol_t hist_diskreq[RF_MAXROW][RF_MAXCOL];
d371 1
a371 2
	/* used by declustering */
	int     noRotate;
d373 17
a389 1
#if RF_INCLUDE_PARITYLOGGING > 0
d391 28
a418 15
	RF_SectorCount_t regionLogCapacity;
	RF_ParityLogQueue_t parityLogPool;	/* pool of unused parity logs */
	RF_RegionInfo_t *regionInfo;	/* array of region state */
	int     numParityLogs;
	int     numSectorsPerLog;
	int     regionParityRange;
	int     logsInUse;	/* debugging */
	RF_ParityLogDiskQueue_t parityLogDiskQueue;	/* state of parity
							 * logging disk work */
	RF_RegionBufferQueue_t regionBufferPool;	/* buffers for holding
							 * region log */
	RF_RegionBufferQueue_t parityBufferPool;	/* buffers for holding
							 * parity */
	caddr_t parityLogBufferHeap;	/* pool of unused parity logs */
	RF_Thread_t pLogDiskThreadHandle;
d420 1
a420 1
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
d422 2
a423 1
#endif				/* !_RF__RF_RAID_H_ */
@


1.6.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 3
a32 3
/*************************************************
 * rf_raid.h -- Main header file for RAID driver.
 *************************************************/
d35 2
a36 2
#ifndef	_RF__RF_RAID_H_
#define	_RF__RF_RAID_H_
d42 1
a42 1
#if	defined(__NetBSD__)
d44 1
a44 1
#elif	defined(__OpenBSD__)
d60 1
a60 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d62 1
a62 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d64 2
a65 2
#define	RF_MAX_DISKS			128	/* Max disks per array. */
#define	RF_DEV2RAIDID(_dev)		(DISKUNIT(_dev))
d67 4
a70 4
#define	RF_COMPONENT_LABEL_VERSION_1	1
#define	RF_COMPONENT_LABEL_VERSION	2
#define	RF_RAID_DIRTY			0
#define	RF_RAID_CLEAN			1
d81 1
a81 1
} RF_RowStatus_t;
d84 5
a88 20
	struct timeval		start;		/*
						 * The time when the stats were
						 * last started.
						 */
	struct timeval		stop;		/*
						 * The time when the stats were
						 * last stopped.
						 */
	long			sum_io_us;	/*
						 * Sum of all user response
						 * times (us).
						 */
	long			num_ios;	/*
						 * Total number of I/Os
						 * serviced.
						 */
	long			num_sect_moved;	/*
						 * Total number of sectors read
						 * or written.
						 */
d92 9
a100 24
	RF_DECLARE_MUTEX	(mutex);	/*
						 * A mutex used to lock the
						 * configuration stuff.
						 */
	struct timeval		 start;		/*
						 * Timer started when
						 * numOutstandingRequests
						 * moves from 0 to 1.
						 */
	struct timeval		 stop;		/*
						 * Timer stopped when
						 * numOutstandingRequests
						 * moves from 1 to 0.
						 */
	RF_uint64		 sum_io_us;	/*
						 * Total time timer is enabled.
						 */
	RF_uint64		 num_ios;	/*
						 * Total number of I/Os
						 * processed by RAIDframe.
						 */
	long			 num_out_ios;	/*
						 * Number of outstanding I/Os.
						 */
d105 25
a129 52
	/*
	 * An exception is Disks[][].status, which requires locking when it is
	 * changed. XXX This is no longer true. numSpare and friends can
	 * change now.
	 */
	u_int			  numRow;	/*
						 * Number of rows of disks,
						 * typically == # of ranks.
						 */
	u_int			  numCol;	/*
						 * Number of columns of disks,
						 * typically == # of disks/rank.
						 */
	u_int			  numSpare;	/* Number of spare disks. */
	int			  maxQueueDepth;/* Max disk queue depth. */
	RF_SectorCount_t	  totalSectors;	/*
						 * Total number of sectors
						 * in the array.
						 */
	RF_SectorCount_t	  sectorsPerDisk;
						/*
						 * Number of sectors on each
						 * disk.
						 */
	u_int			  logBytesPerSector;
						/*
						 * Base-2 log of the number
						 * of bytes in a sector.
						 */
	u_int			  bytesPerSector;
						/* Bytes in a sector. */
	RF_int32		  sectorMask;	/* Mask of bytes-per-sector. */

	RF_RaidLayout_t		  Layout;	/*
						 * All information related to
						 * layout.
						 */
	RF_RaidDisk_t		**Disks;	/*
						 * All information related to
						 * physical disks.
						 */
	RF_DiskQueue_t		**Queues;	/*
						 * All information related to
						 * disk queues.
						 */
	RF_DiskQueueSW_t	 *qType;	/*
						 * Pointer to the DiskQueueSW
						 * used for the component
						 * queues.
						 */
	/*
	 * NOTE:  This is an anchor point via which the queues can be
d131 137
a267 135
	 * local copy of this pointer for the actual accesses.
	 */
	/*
	 * The remainder of the structure can change, and therefore requires
	 * locking on reads and updates.
	 */
	RF_DECLARE_MUTEX	 (mutex);	/*
						 * Mutex used to serialize
						 * access to the fields below.
						 */
	RF_RowStatus_t		 *status;	/*
						 * The status of each row in
						 * the array.
						 */
	int			  valid;	/*
						 * Indicates successful
						 * configuration.
						 */
	RF_LockTableEntry_t	 *lockTable;	/* Stripe-lock table. */
	RF_LockTableEntry_t	 *quiesceLock;	/* Quiescence table. */
	int			  numFailures;	/*
						 * Total number of failures
						 * in the array.
						 */
	int			  numNewFailures;
						/*
						 * Number of *new* failures
						 * (that haven't caused a
						 * mod_counter update).
						 */

	int			  parity_good;	/*
						 * !0 if parity is known to be
						 * correct.
						 */
	int			  serial_number;/*
						 * A "serial number" for this
						 * set.
						 */
	int			  mod_counter;	/*
						 * Modification counter for
						 * component labels.
						 */
	int			  clean;	/*
						 * The clean bit for this array.
						 */

	int			  openings;	/*
						 * Number of I/Os that can be
						 * scheduled simultaneously
						 * (high-level - not a
				 		 * per-component limit).
						 */

	int			  maxOutstanding;
						/*
						 * maxOutstanding requests
						 * (per-component).
						 */
	int			  autoconfigure;
						/*
						 * Automatically configure
						 * this RAID set.
						 * 0 == no, 1 == yes
						 */
	int			  root_partition;
						/*
						 * Use this set as
						 * 0 == no, 1 == yes.
						 */
	int			  last_unit;	/*
						 * Last unit number (e.g. 0
						 * for /dev/raid0) of this
						 * component. Used for
						 * autoconfigure only.
						 */
	int			  config_order;	/*
						 * 0 .. n. The order in which
						 * the component should be
						 * auto-configured.
						 * E.g. 0 is will done first,
						 * (and would become raid0).
						 * This may be in conflict
						 * with last_unit !!?!
						 */
						/* Not currently used. */

	/*
	 * Cleanup stuff.
	 */
	RF_ShutdownList_t	 *shutdownList;	/* Shutdown activities. */
	RF_AllocListElem_t	 *cleanupList;	/*
						 * Memory to be freed at
						 * shutdown time.
						 */

	/*
	 * Recon stuff.
	 */
	RF_HeadSepLimit_t	  headSepLimit;
	int			  numFloatingReconBufs;
	int			  reconInProgress;
	RF_DECLARE_COND		 (waitForReconCond);
	RF_RaidReconDesc_t	 *reconDesc;	/* Reconstruction descriptor. */
	RF_ReconCtrl_t		**reconControl;	/*
						 * Reconstruction control
						 * structure pointers for each
						 * row in the array.
						 */

	/*
	 * Array-quiescence stuff.
	 */
	RF_DECLARE_MUTEX	 (access_suspend_mutex);
	RF_DECLARE_COND		 (quiescent_cond);
	RF_IoCount_t		  accesses_suspended;
	RF_IoCount_t		  accs_in_flight;
	int			  access_suspend_release;
	int			  waiting_for_quiescence;
	RF_CallbackDesc_t	 *quiesce_wait_list;

	/*
	 * Statistics.
	 */
#if	!defined(_KERNEL) && !defined(SIMULATE)
	RF_ThroughputStats_t	  throughputstats;
#endif	/* !_KERNEL && !SIMULATE */
	RF_CumulativeStats_t	  userstats;
	int			  parity_rewrite_stripes_done;
	int			  recon_stripes_done;
	int			  copyback_stripes_done;

	int			  recon_in_progress;
	int			  parity_rewrite_in_progress;
	int			  copyback_in_progress;
d269 2
a270 45
	/*
	 * Engine thread control.
	 */
	RF_DECLARE_MUTEX	 (node_queue_mutex);
	RF_DECLARE_COND		 (node_queue_cond);
	RF_DagNode_t		 *node_queue;
	RF_Thread_t		  parity_rewrite_thread;
	RF_Thread_t		  copyback_thread;
	RF_Thread_t		  engine_thread;
	RF_Thread_t		  recon_thread;
	RF_ThreadGroup_t	  engine_tg;
	int			  shutdown_engine;
	int			  dags_in_flight;	/* Debug. */

	/*
	 * PSS (Parity Stripe Status) stuff.
	 */
	RF_FreeList_t		 *pss_freelist;
	long			  pssTableSize;

	/*
	 * Reconstruction stuff.
	 */
	int			  procsInBufWait;
	int			  numFullReconBuffers;
	RF_AccTraceEntry_t	 *recon_tracerecs;
	unsigned long		  accumXorTimeUs;
	RF_ReconDoneProc_t	 *recon_done_procs;
	RF_DECLARE_MUTEX	 (recon_done_proc_mutex);
	/*
	 * nAccOutstanding, waitShutdown protected by desc freelist lock
	 * (This may seem strange, since that's a central serialization point
	 * for a per-array piece of data, but otherwise, it'd be an extra
	 * per-array lock, and that'd only be less efficient...)
	 */
	RF_DECLARE_COND		 (outstandingCond);
	int			  waitShutdown;
	int			  nAccOutstanding;

	RF_DiskId_t		**diskids;
	RF_DiskId_t		 *sparediskids;

	int			  raidid;
	RF_AccTotals_t		  acc_totals;
	int			  keep_acc_totals;
d272 2
a273 1
	struct raidcinfo	**raid_cinfo;	/* Array of component info. */
d275 1
a275 17
	int			  terminate_disk_queues;

	/*
	 * XXX
	 *
	 * Config-specific information should be moved
	 * somewhere else, or at least hung off this
	 * in some generic way.
	 */

	/* Used by rf_compute_workload_shift. */
	RF_RowCol_t		  hist_diskreq[RF_MAXROW][RF_MAXCOL];

	/* Used by declustering. */
	int			  noRotate;

#if	RF_INCLUDE_PARITYLOGGING > 0
d277 15
a291 28
	RF_SectorCount_t	  regionLogCapacity;
	RF_ParityLogQueue_t	  parityLogPool;/*
						 * Pool of unused parity logs.
						 */
	RF_RegionInfo_t		 *regionInfo;	/* Array of region state. */
	int			  numParityLogs;
	int			  numSectorsPerLog;
	int			  regionParityRange;
	int			  logsInUse;	/* Debugging. */
	RF_ParityLogDiskQueue_t	  parityLogDiskQueue;
						/*
						 * State of parity logging
						 * disk work.
						 */
	RF_RegionBufferQueue_t	  regionBufferPool;
					 	/*
						 * buffers for holding region
						 * log.
						 */
	RF_RegionBufferQueue_t	  parityBufferPool;
						/*
						 * Buffers for holding parity.
						 */
	caddr_t			  parityLogBufferHeap;
						/*
						 * Pool of unused parity logs.
						 */
	RF_Thread_t		  pLogDiskThreadHandle;
d293 1
a293 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d295 1
a295 2

#endif	/* !_RF__RF_RAID_H_ */
@


1.5
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_raid.h,v 1.4 1999/08/04 13:10:55 peter Exp $	*/
/*	$NetBSD: rf_raid.h,v 1.8 2000/01/05 02:57:29 oster Exp $	*/
d67 2
a68 1
#define RF_COMPONENT_LABEL_VERSION 1
d127 2
d141 2
d152 14
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_raid.h,v 1.6 2000/08/08 16:07:44 peter Exp $	*/
/*	$NetBSD: rf_raid.h,v 1.12 2000/02/24 17:12:10 oster Exp $	*/
d67 1
a67 2
#define RF_COMPONENT_LABEL_VERSION_1 1
#define RF_COMPONENT_LABEL_VERSION 2
a125 2
	RF_DiskQueueSW_t *qType;/* pointer to the DiskQueueSW used for the
				   component queues. */
a137 2
	int     numNewFailures; /* number of *new* failures (that havn't 
				   caused a mod_counter update */
a146 14

	int maxOutstanding;   /* maxOutstanding requests (per-component) */
	int autoconfigure;    /* automatically configure this RAID set. 
				 0 == no, 1 == yes */
	int root_partition;   /* Use this set as /
				 0 == no, 1 == yes*/
	int last_unit;        /* last unit number (e.g. 0 for /dev/raid0) 
				 of this component.  Used for autoconfigure
				 only. */
	int config_order;     /* 0 .. n.  The order in which the component
				 should be auto-configured.  E.g. 0 is will 
				 done first, (and would become raid0).
				 This may be in conflict with last_unit!!?! */
	                      /* Not currently used. */
@


1.5.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 3
a32 3
/*************************************************
 * rf_raid.h -- Main header file for RAID driver.
 *************************************************/
d35 2
a36 2
#ifndef	_RF__RF_RAID_H_
#define	_RF__RF_RAID_H_
d42 1
a42 1
#if	defined(__NetBSD__)
d44 1
a44 1
#elif	defined(__OpenBSD__)
d60 1
a60 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d62 1
a62 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d64 2
a65 2
#define	RF_MAX_DISKS			128	/* Max disks per array. */
#define	RF_DEV2RAIDID(_dev)		(DISKUNIT(_dev))
d67 4
a70 4
#define	RF_COMPONENT_LABEL_VERSION_1	1
#define	RF_COMPONENT_LABEL_VERSION	2
#define	RF_RAID_DIRTY			0
#define	RF_RAID_CLEAN			1
d81 1
a81 1
} RF_RowStatus_t;
d84 5
a88 20
	struct timeval		start;		/*
						 * The time when the stats were
						 * last started.
						 */
	struct timeval		stop;		/*
						 * The time when the stats were
						 * last stopped.
						 */
	long			sum_io_us;	/*
						 * Sum of all user response
						 * times (us).
						 */
	long			num_ios;	/*
						 * Total number of I/Os
						 * serviced.
						 */
	long			num_sect_moved;	/*
						 * Total number of sectors read
						 * or written.
						 */
d92 9
a100 24
	RF_DECLARE_MUTEX	(mutex);	/*
						 * A mutex used to lock the
						 * configuration stuff.
						 */
	struct timeval		 start;		/*
						 * Timer started when
						 * numOutstandingRequests
						 * moves from 0 to 1.
						 */
	struct timeval		 stop;		/*
						 * Timer stopped when
						 * numOutstandingRequests
						 * moves from 1 to 0.
						 */
	RF_uint64		 sum_io_us;	/*
						 * Total time timer is enabled.
						 */
	RF_uint64		 num_ios;	/*
						 * Total number of I/Os
						 * processed by RAIDframe.
						 */
	long			 num_out_ios;	/*
						 * Number of outstanding I/Os.
						 */
d105 25
a129 52
	/*
	 * An exception is Disks[][].status, which requires locking when it is
	 * changed. XXX This is no longer true. numSpare and friends can
	 * change now.
	 */
	u_int			  numRow;	/*
						 * Number of rows of disks,
						 * typically == # of ranks.
						 */
	u_int			  numCol;	/*
						 * Number of columns of disks,
						 * typically == # of disks/rank.
						 */
	u_int			  numSpare;	/* Number of spare disks. */
	int			  maxQueueDepth;/* Max disk queue depth. */
	RF_SectorCount_t	  totalSectors;	/*
						 * Total number of sectors
						 * in the array.
						 */
	RF_SectorCount_t	  sectorsPerDisk;
						/*
						 * Number of sectors on each
						 * disk.
						 */
	u_int			  logBytesPerSector;
						/*
						 * Base-2 log of the number
						 * of bytes in a sector.
						 */
	u_int			  bytesPerSector;
						/* Bytes in a sector. */
	RF_int32		  sectorMask;	/* Mask of bytes-per-sector. */

	RF_RaidLayout_t		  Layout;	/*
						 * All information related to
						 * layout.
						 */
	RF_RaidDisk_t		**Disks;	/*
						 * All information related to
						 * physical disks.
						 */
	RF_DiskQueue_t		**Queues;	/*
						 * All information related to
						 * disk queues.
						 */
	RF_DiskQueueSW_t	 *qType;	/*
						 * Pointer to the DiskQueueSW
						 * used for the component
						 * queues.
						 */
	/*
	 * NOTE:  This is an anchor point via which the queues can be
d131 137
a267 135
	 * local copy of this pointer for the actual accesses.
	 */
	/*
	 * The remainder of the structure can change, and therefore requires
	 * locking on reads and updates.
	 */
	RF_DECLARE_MUTEX	 (mutex);	/*
						 * Mutex used to serialize
						 * access to the fields below.
						 */
	RF_RowStatus_t		 *status;	/*
						 * The status of each row in
						 * the array.
						 */
	int			  valid;	/*
						 * Indicates successful
						 * configuration.
						 */
	RF_LockTableEntry_t	 *lockTable;	/* Stripe-lock table. */
	RF_LockTableEntry_t	 *quiesceLock;	/* Quiescence table. */
	int			  numFailures;	/*
						 * Total number of failures
						 * in the array.
						 */
	int			  numNewFailures;
						/*
						 * Number of *new* failures
						 * (that haven't caused a
						 * mod_counter update).
						 */

	int			  parity_good;	/*
						 * !0 if parity is known to be
						 * correct.
						 */
	int			  serial_number;/*
						 * A "serial number" for this
						 * set.
						 */
	int			  mod_counter;	/*
						 * Modification counter for
						 * component labels.
						 */
	int			  clean;	/*
						 * The clean bit for this array.
						 */

	int			  openings;	/*
						 * Number of I/Os that can be
						 * scheduled simultaneously
						 * (high-level - not a
				 		 * per-component limit).
						 */

	int			  maxOutstanding;
						/*
						 * maxOutstanding requests
						 * (per-component).
						 */
	int			  autoconfigure;
						/*
						 * Automatically configure
						 * this RAID set.
						 * 0 == no, 1 == yes
						 */
	int			  root_partition;
						/*
						 * Use this set as
						 * 0 == no, 1 == yes.
						 */
	int			  last_unit;	/*
						 * Last unit number (e.g. 0
						 * for /dev/raid0) of this
						 * component. Used for
						 * autoconfigure only.
						 */
	int			  config_order;	/*
						 * 0 .. n. The order in which
						 * the component should be
						 * auto-configured.
						 * E.g. 0 is will done first,
						 * (and would become raid0).
						 * This may be in conflict
						 * with last_unit !!?!
						 */
						/* Not currently used. */

	/*
	 * Cleanup stuff.
	 */
	RF_ShutdownList_t	 *shutdownList;	/* Shutdown activities. */
	RF_AllocListElem_t	 *cleanupList;	/*
						 * Memory to be freed at
						 * shutdown time.
						 */

	/*
	 * Recon stuff.
	 */
	RF_HeadSepLimit_t	  headSepLimit;
	int			  numFloatingReconBufs;
	int			  reconInProgress;
	RF_DECLARE_COND		 (waitForReconCond);
	RF_RaidReconDesc_t	 *reconDesc;	/* Reconstruction descriptor. */
	RF_ReconCtrl_t		**reconControl;	/*
						 * Reconstruction control
						 * structure pointers for each
						 * row in the array.
						 */

	/*
	 * Array-quiescence stuff.
	 */
	RF_DECLARE_MUTEX	 (access_suspend_mutex);
	RF_DECLARE_COND		 (quiescent_cond);
	RF_IoCount_t		  accesses_suspended;
	RF_IoCount_t		  accs_in_flight;
	int			  access_suspend_release;
	int			  waiting_for_quiescence;
	RF_CallbackDesc_t	 *quiesce_wait_list;

	/*
	 * Statistics.
	 */
#if	!defined(_KERNEL) && !defined(SIMULATE)
	RF_ThroughputStats_t	  throughputstats;
#endif	/* !_KERNEL && !SIMULATE */
	RF_CumulativeStats_t	  userstats;
	int			  parity_rewrite_stripes_done;
	int			  recon_stripes_done;
	int			  copyback_stripes_done;

	int			  recon_in_progress;
	int			  parity_rewrite_in_progress;
	int			  copyback_in_progress;
d269 2
a270 45
	/*
	 * Engine thread control.
	 */
	RF_DECLARE_MUTEX	 (node_queue_mutex);
	RF_DECLARE_COND		 (node_queue_cond);
	RF_DagNode_t		 *node_queue;
	RF_Thread_t		  parity_rewrite_thread;
	RF_Thread_t		  copyback_thread;
	RF_Thread_t		  engine_thread;
	RF_Thread_t		  recon_thread;
	RF_ThreadGroup_t	  engine_tg;
	int			  shutdown_engine;
	int			  dags_in_flight;	/* Debug. */

	/*
	 * PSS (Parity Stripe Status) stuff.
	 */
	RF_FreeList_t		 *pss_freelist;
	long			  pssTableSize;

	/*
	 * Reconstruction stuff.
	 */
	int			  procsInBufWait;
	int			  numFullReconBuffers;
	RF_AccTraceEntry_t	 *recon_tracerecs;
	unsigned long		  accumXorTimeUs;
	RF_ReconDoneProc_t	 *recon_done_procs;
	RF_DECLARE_MUTEX	 (recon_done_proc_mutex);
	/*
	 * nAccOutstanding, waitShutdown protected by desc freelist lock
	 * (This may seem strange, since that's a central serialization point
	 * for a per-array piece of data, but otherwise, it'd be an extra
	 * per-array lock, and that'd only be less efficient...)
	 */
	RF_DECLARE_COND		 (outstandingCond);
	int			  waitShutdown;
	int			  nAccOutstanding;

	RF_DiskId_t		**diskids;
	RF_DiskId_t		 *sparediskids;

	int			  raidid;
	RF_AccTotals_t		  acc_totals;
	int			  keep_acc_totals;
d272 2
a273 1
	struct raidcinfo	**raid_cinfo;	/* Array of component info. */
d275 1
a275 17
	int			  terminate_disk_queues;

	/*
	 * XXX
	 *
	 * Config-specific information should be moved
	 * somewhere else, or at least hung off this
	 * in some generic way.
	 */

	/* Used by rf_compute_workload_shift. */
	RF_RowCol_t		  hist_diskreq[RF_MAXROW][RF_MAXCOL];

	/* Used by declustering. */
	int			  noRotate;

#if	RF_INCLUDE_PARITYLOGGING > 0
d277 15
a291 28
	RF_SectorCount_t	  regionLogCapacity;
	RF_ParityLogQueue_t	  parityLogPool;/*
						 * Pool of unused parity logs.
						 */
	RF_RegionInfo_t		 *regionInfo;	/* Array of region state. */
	int			  numParityLogs;
	int			  numSectorsPerLog;
	int			  regionParityRange;
	int			  logsInUse;	/* Debugging. */
	RF_ParityLogDiskQueue_t	  parityLogDiskQueue;
						/*
						 * State of parity logging
						 * disk work.
						 */
	RF_RegionBufferQueue_t	  regionBufferPool;
					 	/*
						 * buffers for holding region
						 * log.
						 */
	RF_RegionBufferQueue_t	  parityBufferPool;
						/*
						 * Buffers for holding parity.
						 */
	caddr_t			  parityLogBufferHeap;
						/*
						 * Pool of unused parity logs.
						 */
	RF_Thread_t		  pLogDiskThreadHandle;
d293 1
a293 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d295 1
a295 2

#endif	/* !_RF__RF_RAID_H_ */
@


1.4
log
@* remove redundant rf_ccmn.h

* remove init call to rf_ConfigureEtimer() and rf_sys.c in which it is the
  only function. update conf/files to reflect this.

* update sources to make sure _KERNEL is used not KERNEL

* change rf_etimer.h to protect macros an include of sys/kernel.h with
  a check for _KERNEL - let raidctl compile again.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_raid.h,v 1.3 1999/07/30 14:45:33 peter Exp $	*/
/*	$NetBSD: rf_raid.h,v 1.6 1999/07/08 00:45:24 oster Exp $	*/
d184 7
d195 2
a196 2
	        RF_DECLARE_MUTEX(node_queue_mutex)
	        RF_DECLARE_COND(node_queue_cond)
d198 2
d201 1
a238 1
	struct proc *proc;	/* XXX shouldn't be needed here.. :-p */
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_raid.h,v 1.2 1999/02/16 00:03:13 niklas Exp $	*/
d182 1
a182 1
#endif				/* !KERNEL && !SIMULATE */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_raid.h,v 1.1 1999/01/11 14:29:41 niklas Exp $	*/
/*	$NetBSD: rf_raid.h,v 1.3 1999/02/05 00:06:15 oster Exp $	*/
d67 4
d105 3
a107 1
	 * changed */
d138 9
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_raid.h,v 1.1 1998/11/13 04:20:32 oster Exp $	*/
/*	$NetBSD: rf_raid.h,v 1.1 1998/11/13 04:20:32 oster Exp $	*/
a33 145
/*
 * :  
 * Log: rf_raid.h,v 
 * Revision 1.48  1996/08/20 22:33:54  jimz
 * make hist_diskreq a doubly-indexed array
 *
 * Revision 1.47  1996/07/15  05:40:41  jimz
 * some recon datastructure cleanup
 * better handling of multiple failures
 * added undocumented double-recon test
 *
 * Revision 1.46  1996/07/10  22:28:51  jimz
 * get rid of obsolete row statuses (dead,degraded2)
 *
 * Revision 1.45  1996/06/14  14:56:29  jimz
 * make engine threading stuff ifndef SIMULATE
 *
 * Revision 1.44  1996/06/14  14:16:54  jimz
 * move in engine node queue, atomicity control
 *
 * Revision 1.43  1996/06/12  04:41:26  jimz
 * tweaks to make genplot work with user-level driver
 * (mainly change stat collection)
 *
 * Revision 1.42  1996/06/11  10:57:17  jimz
 * add recon_done_procs, recon_done_proc_mutex
 *
 * Revision 1.41  1996/06/11  01:26:48  jimz
 * added mechanism for user-level to sync diskthread startup,
 * shutdown
 *
 * Revision 1.40  1996/06/10  14:18:58  jimz
 * move user, throughput stats into per-array structure
 *
 * Revision 1.39  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.38  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.37  1996/06/05  19:38:32  jimz
 * fixed up disk queueing types config
 * added sstf disk queueing
 * fixed exit bug on diskthreads (ref-ing bad mem)
 *
 * Revision 1.36  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.35  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.34  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.33  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.32  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.31  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.30  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.29  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.28  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.27  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.26  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.25  1996/05/02  14:57:55  jimz
 * add sectorMask
 *
 * Revision 1.24  1996/04/22  15:53:13  jimz
 * MAX_RAIDS -> NRAIDFRAME
 *
 * Revision 1.23  1995/12/14  18:39:46  jimz
 * convert to rf_types.h types
 *
 * Revision 1.22  1995/12/06  15:02:26  root
 * added copyright info
 *
 * Revision 1.21  1995/10/09  17:39:24  jimz
 * added info for tracking number of outstanding accesses
 * at user-level
 *
 * Revision 1.20  1995/09/30  20:37:46  jimz
 * added acc_totals to Raid for kernel
 *
 * Revision 1.19  1995/09/19  22:57:14  jimz
 * add cache of raidid for kernel
 *
 * Revision 1.18  1995/09/18  16:50:04  jimz
 * added RF_MAX_DISKS (for config ioctls)
 *
 * Revision 1.17  1995/09/07  19:02:31  jimz
 * mods to get raidframe to compile and link
 * in kernel environment
 *
 * Revision 1.16  1995/07/21  19:29:51  robby
 * added some info for the idler to the Raid
 *
 * Revision 1.15  1995/07/16  03:19:14  cfb
 * added cachePtr to *raidPtr
 *
 * Revision 1.14  1995/06/23  13:39:36  robby
 * updeated to prototypes in rf_layout.h
 *
 */
a37 4
#ifdef _KERNEL
#define KERNEL
#endif

a41 1
#ifdef _KERNEL
a46 1
#endif
a47 4
#ifdef KERNEL
/* XXX Needs to be added.  GO
#include <raidframe.h>
*/
a48 4
#else /* KERNEL */
#include <stdio.h>
#include <assert.h>
#endif /* KERNEL */
d62 1
a62 1
#endif /* RF_INCLUDE_PARITYLOGGING > 0 */
d64 1
a64 2
#define RF_MAX_DISKS 128 /* max disks per array */
#if defined(__NetBSD__) || defined(__OpenBSD__)
a65 3
#else
#define RF_DEV2RAIDID(_dev)  (minor(_dev)>>6)     /* convert dev_t to raid id */
#endif
d72 5
a76 5
  rf_rs_optimal,
  rf_rs_degraded,
  rf_rs_reconstructing,
  rf_rs_reconfigured
} RF_RowStatus_t;
d79 5
a83 5
  struct timeval start;     /* the time when the stats were last started*/
  struct timeval stop;      /* the time when the stats were last stopped */
  long sum_io_us;           /* sum of all user response times (us) */
  long num_ios;             /* total number of I/Os serviced */
  long num_sect_moved;      /* total number of sectors read or written */
d87 9
a95 6
  RF_DECLARE_MUTEX(mutex)/* a mutex used to lock the configuration stuff */
  struct timeval start;  /* timer started when numOutstandingRequests moves from 0 to 1 */
  struct timeval stop;   /* timer stopped when numOutstandingRequests moves from 1 to 0 */
  RF_uint64 sum_io_us;   /* total time timer is enabled */
  RF_uint64 num_ios;     /* total number of ios processed by RAIDframe */
  long num_out_ios;      /* number of outstanding ios */
a97 9
#ifdef SIMULATE
typedef struct RF_PendingRecon_s RF_PendingRecon_t;
struct RF_PendingRecon_s {
  RF_RowCol_t         row;
  RF_RowCol_t         col;
  RF_PendingRecon_t  *next;
};
#endif /* SIMULATE */

d99 126
a224 134
  /* This portion never changes, and can be accessed without locking */
  /* an exception is Disks[][].status, which requires locking when it is changed */
  u_int numRow;             /* number of rows of disks, typically == # of ranks */
  u_int numCol;             /* number of columns of disks, typically == # of disks/rank */
  u_int numSpare;           /* number of spare disks */
  int   maxQueueDepth;      /* max disk queue depth */
  RF_SectorCount_t  totalSectors;   /* total number of sectors in the array */
  RF_SectorCount_t  sectorsPerDisk; /* number of sectors on each disk */
  u_int logBytesPerSector;  /* base-2 log of the number of bytes in a sector */
  u_int bytesPerSector;     /* bytes in a sector */
  RF_int32  sectorMask;     /* mask of bytes-per-sector */

  RF_RaidLayout_t   Layout; /* all information related to layout */
  RF_RaidDisk_t   **Disks;  /* all information related to physical disks */
  RF_DiskQueue_t  **Queues; /* all information related to disk queues */
     /* NOTE:  This is an anchor point via which the queues can be accessed,
      * but the enqueue/dequeue routines in diskqueue.c use a local copy of
      * this pointer for the actual accesses.
      */
  /* The remainder of the structure can change, and therefore requires locking on reads and updates */
  RF_DECLARE_MUTEX(mutex)        /* mutex used to serialize access to the fields below */
  RF_RowStatus_t  *status;       /* the status of each row in the array */
  int              valid;        /* indicates successful configuration */
  RF_LockTableEntry_t *lockTable;   /* stripe-lock table */
  RF_LockTableEntry_t *quiesceLock; /* quiesnce table */
  int                  numFailures; /* total number of failures in the array */

  /*
   * Cleanup stuff
   */
  RF_ShutdownList_t  *shutdownList; /* shutdown activities */
  RF_AllocListElem_t *cleanupList;  /* memory to be freed at shutdown time */

  /*
   * Recon stuff
   */
  RF_HeadSepLimit_t headSepLimit;
  int numFloatingReconBufs;
  int reconInProgress;
#ifdef SIMULATE
  RF_PendingRecon_t *pendingRecon;
#endif /* SIMULATE */
  RF_DECLARE_COND(waitForReconCond)
  RF_RaidReconDesc_t *reconDesc; /* reconstruction descriptor */
  RF_ReconCtrl_t **reconControl; /* reconstruction control structure pointers for each row in the array */

#if !defined(KERNEL) && !defined(SIMULATE)
  /*
   * Disk thread stuff
   */
  int diskthreads_created;
  int diskthreads_running;
  int diskthreads_shutdown;
  RF_DECLARE_MUTEX(diskthread_count_mutex)
  RF_DECLARE_COND(diskthread_count_cond)
#endif /* !KERNEL && !SIMULATE */

  /*
   * Array-quiescence stuff
   */
  RF_DECLARE_MUTEX(access_suspend_mutex)
  RF_DECLARE_COND(quiescent_cond)
  RF_IoCount_t accesses_suspended;
  RF_IoCount_t accs_in_flight;
  int access_suspend_release;
  int waiting_for_quiescence;
  RF_CallbackDesc_t *quiesce_wait_list;

  /*
   * Statistics
   */
#if !defined(KERNEL) && !defined(SIMULATE)
  RF_ThroughputStats_t throughputstats;
#endif /* !KERNEL && !SIMULATE */
  RF_CumulativeStats_t userstats;

  /*
   * Engine thread control
   */
  RF_DECLARE_MUTEX(node_queue_mutex)
  RF_DECLARE_COND(node_queue_cond)
  RF_DagNode_t *node_queue;
#ifndef SIMULATE
  RF_Thread_t engine_thread;
  RF_ThreadGroup_t engine_tg;
#endif /* !SIMULATE */
  int shutdown_engine;
  int dags_in_flight; /* debug */

  /*
   * PSS (Parity Stripe Status) stuff
   */
  RF_FreeList_t *pss_freelist;
  long pssTableSize;

  /*
   * Reconstruction stuff
   */
  int procsInBufWait;
  int numFullReconBuffers;
  RF_AccTraceEntry_t *recon_tracerecs;
  unsigned long accumXorTimeUs;
  RF_ReconDoneProc_t *recon_done_procs;
  RF_DECLARE_MUTEX(recon_done_proc_mutex)

#if !defined(KERNEL) && !defined(SIMULATE)
  RF_Thread_t **diskthreads, *sparediskthreads;  /* thread descriptors for disk threads in user-level version */
#endif /* !KERNEL && !SIMULATE */

  /*
   * nAccOutstanding, waitShutdown protected by desc freelist lock
   * (This may seem strange, since that's a central serialization point
   * for a per-array piece of data, but otherwise, it'd be an extra
   * per-array lock, and that'd only be less efficient...)
   */
  RF_DECLARE_COND(outstandingCond)
  int waitShutdown;
  int nAccOutstanding;

  RF_DiskId_t **diskids;
  RF_DiskId_t  *sparediskids;

#ifdef KERNEL
	int           raidid;
#endif /* KERNEL */
	RF_AccTotals_t  acc_totals;
	int           keep_acc_totals;

#ifdef _KERNEL
        struct raidcinfo **raid_cinfo; /* array of component info */
        struct proc *proc; /* XXX shouldn't be needed here.. :-p */
#endif

  int terminate_disk_queues;
d226 2
a227 7
  /*
   * XXX
   *
   * config-specific information should be moved
   * somewhere else, or at least hung off this
   * in some generic way
   */
d229 2
a230 5
  /* used by rf_compute_workload_shift */
  RF_RowCol_t hist_diskreq[RF_MAXROW][RF_MAXCOL];

  /* used by declustering */
  int noRotate;
d233 16
a248 15
  /* used by parity logging */
  RF_SectorCount_t          regionLogCapacity;
  RF_ParityLogQueue_t       parityLogPool;       /* pool of unused parity logs */
  RF_RegionInfo_t          *regionInfo;          /* array of region state */
  int                       numParityLogs;
  int                       numSectorsPerLog;
  int                       regionParityRange;
  int                       logsInUse;           /* debugging */
  RF_ParityLogDiskQueue_t   parityLogDiskQueue;  /* state of parity logging disk work */
  RF_RegionBufferQueue_t    regionBufferPool;    /* buffers for holding region log */
  RF_RegionBufferQueue_t    parityBufferPool;    /* buffers for holding parity */
  caddr_t                   parityLogBufferHeap; /* pool of unused parity logs */
#ifndef SIMULATE
  RF_Thread_t               pLogDiskThreadHandle;
#endif /* !SIMULATE */
d250 1
a250 1
#endif /* RF_INCLUDE_PARITYLOGGING > 0 */
d252 1
a252 2

#endif /* !_RF__RF_RAID_H_ */
@

