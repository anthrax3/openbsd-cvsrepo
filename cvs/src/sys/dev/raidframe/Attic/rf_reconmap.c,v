head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.16
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.14
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.12
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.5;

1.5
date	2011.06.21.16.46.00;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.16.07.01.05;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.07.14.50.22;	author peter;	state Exp;
branches
	1.3.2.1
	1.3.12.1;
next	1.2;

1.2
date	99.02.16.00.03.21;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.46;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.3.12.1
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_reconmap.c,v 1.5 2011/06/21 16:46:00 tedu Exp $	*/
/*	$NetBSD: rf_reconmap.c,v 1.6 1999/08/14 21:44:24 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 * rf_reconmap.c
 *
 * Code to maintain a map of what sectors have/have not been reconstructed.
 *
 *****************************************************************************/

#include "rf_raid.h"
#include <sys/time.h>
#include "rf_general.h"
#include "rf_utils.h"

/*
 * Special pointer values indicating that a reconstruction unit
 * has been either totally reconstructed or not at all. Both
 * are illegal pointer values, so you have to be careful not to
 * dereference through them. RU_NOTHING must be zero, since
 * MakeReconMap uses bzero to initialize the structure. These are used
 * only at the head of the list.
 */
#define	RU_ALL		((RF_ReconMapListElem_t *) -1)
#define	RU_NOTHING	((RF_ReconMapListElem_t *) 0)

/* Used to mark the end of the list. */
#define	RU_NIL		((RF_ReconMapListElem_t *) 0)


void rf_compact_stat_entry(RF_Raid_t *, RF_ReconMap_t *, int);
void rf_crunch_list(RF_ReconMap_t *, RF_ReconMapListElem_t *);
RF_ReconMapListElem_t * rf_MakeReconMapListElem(RF_SectorNum_t, RF_SectorNum_t,
	RF_ReconMapListElem_t *);
void rf_FreeReconMapListElem(RF_ReconMap_t *, RF_ReconMapListElem_t *);
void rf_update_size(RF_ReconMap_t *, int);
void rf_PrintList(RF_ReconMapListElem_t *);


/*****************************************************************************
 *
 * Creates and initializes new Reconstruction map.
 *
 *****************************************************************************/

RF_ReconMap_t *
rf_MakeReconMap(
    RF_Raid_t		*raidPtr,
    RF_SectorCount_t	 ru_sectors,		/*
						 * Size of reconstruction unit
						 * in sectors.
						 */
    RF_SectorCount_t	 disk_sectors,		/* Size of disk in sectors. */
    RF_ReconUnitCount_t	 spareUnitsPerDisk	/*
						 * Zero unless distributed
						 * sparing.
						 */
)
{
	RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
	RF_ReconUnitCount_t num_rus = layoutPtr->stripeUnitsPerDisk /
	    layoutPtr->SUsPerRU;
	RF_ReconMap_t *p;
	int rc;

	RF_Malloc(p, sizeof(RF_ReconMap_t), (RF_ReconMap_t *));
	p->sectorsPerReconUnit = ru_sectors;
	p->sectorsInDisk = disk_sectors;

	p->totalRUs = num_rus;
	p->spareRUs = spareUnitsPerDisk;
	p->unitsLeft = num_rus - spareUnitsPerDisk;

	RF_Malloc(p->status, num_rus * sizeof(RF_ReconMapListElem_t *),
	    (RF_ReconMapListElem_t **));
	RF_ASSERT(p->status != (RF_ReconMapListElem_t **) NULL);

	bzero(p->status, num_rus *
	    sizeof(RF_ReconMapListElem_t *));

	p->size = sizeof(RF_ReconMap_t) + num_rus *
	    sizeof(RF_ReconMapListElem_t *);
	p->maxSize = p->size;

	rc = rf_mutex_init(&p->mutex);
	if (rc) {
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n",
		    __FILE__, __LINE__, rc);
		RF_Free(p->status, num_rus * sizeof(RF_ReconMapListElem_t *));
		RF_Free(p, sizeof(RF_ReconMap_t));
		return (NULL);
	}
	return (p);
}


/*****************************************************************************
 *
 * Marks a new set of sectors as reconstructed. All the possible mergings get
 * complicated. To simplify matters, the approach I take is to just dump
 * something into the list, and then clean it up (i.e. merge elements and
 * eliminate redundant ones) in a second pass over the list
 * (rf_compact_stat_entry()).
 * Not 100% efficient, since a structure can be allocated and then immediately
 * freed, but it keeps this code from becoming (more of) a nightmare of
 * special cases. The only thing that rf_compact_stat_entry() assumes is that
 * the list is sorted by startSector, and so this is the only condition I
 * maintain here. (MCH)
 *
 *****************************************************************************/

void
rf_ReconMapUpdate(RF_Raid_t *raidPtr, RF_ReconMap_t *mapPtr,
    RF_SectorNum_t startSector, RF_SectorNum_t stopSector)
{
	RF_SectorCount_t sectorsPerReconUnit = mapPtr->sectorsPerReconUnit;
	RF_SectorNum_t i, first_in_RU, last_in_RU;
	RF_ReconMapListElem_t *p, *pt;

	RF_LOCK_MUTEX(mapPtr->mutex);
	RF_ASSERT(startSector >= 0 && stopSector < mapPtr->sectorsInDisk &&
	    stopSector >= startSector);

	while (startSector <= stopSector) {
		i = startSector / mapPtr->sectorsPerReconUnit;
		first_in_RU = i * sectorsPerReconUnit;
		last_in_RU = first_in_RU + sectorsPerReconUnit - 1;
		p = mapPtr->status[i];
		if (p != RU_ALL) {
			if (p == RU_NOTHING || p->startSector > startSector) {
				/* Insert at front of list. */

				mapPtr->status[i] =
				    rf_MakeReconMapListElem(startSector,
				     RF_MIN(stopSector, last_in_RU),
				     (p == RU_NOTHING) ? NULL : p);
				rf_update_size(mapPtr,
				    sizeof(RF_ReconMapListElem_t));

			} else {/* General case. */
				do {	/* Search for place to insert. */
					pt = p;
					p = p->next;
				} while (p && (p->startSector < startSector));
				pt->next = rf_MakeReconMapListElem(startSector,
				    RF_MIN(stopSector, last_in_RU), p);
				rf_update_size(mapPtr,
				    sizeof(RF_ReconMapListElem_t));
			}
			rf_compact_stat_entry(raidPtr, mapPtr, i);
		}
		startSector = RF_MIN(stopSector, last_in_RU) + 1;
	}
	RF_UNLOCK_MUTEX(mapPtr->mutex);
}


/*****************************************************************************
 *
 * Performs whatever list compactions can be done, and frees any space
 * that is no longer necessary. Assumes only that the list is sorted
 * by startSector. rf_crunch_list() compacts a single list as much as possible,
 * and the second block of code deletes the entire list if possible.
 * rf_crunch_list() is also called from MakeReconMapAccessList().
 *
 * When a recon unit is detected to be fully reconstructed, we set the
 * corresponding bit in the parity stripe map so that the head follow
 * code will not select this parity stripe again. This is redundant (but
 * harmless) when rf_compact_stat_entry is called from the reconstruction
 * code, but necessary when called from the user-write code.
 *
 *****************************************************************************/

void
rf_compact_stat_entry(RF_Raid_t *raidPtr, RF_ReconMap_t *mapPtr, int i)
{
	RF_SectorCount_t sectorsPerReconUnit = mapPtr->sectorsPerReconUnit;
	RF_ReconMapListElem_t *p = mapPtr->status[i];

	rf_crunch_list(mapPtr, p);

	if ((p->startSector == i * sectorsPerReconUnit) &&
	    (p->stopSector == i * sectorsPerReconUnit +
	     sectorsPerReconUnit - 1)) {
		mapPtr->status[i] = RU_ALL;
		mapPtr->unitsLeft--;
		rf_FreeReconMapListElem(mapPtr, p);
	}
}

void
rf_crunch_list(RF_ReconMap_t *mapPtr, RF_ReconMapListElem_t *listPtr)
{
	RF_ReconMapListElem_t *pt, *p = listPtr;

	if (!p)
		return;
	pt = p;
	p = p->next;
	while (p) {
		if (pt->stopSector >= p->startSector - 1) {
			pt->stopSector = RF_MAX(pt->stopSector, p->stopSector);
			pt->next = p->next;
			rf_FreeReconMapListElem(mapPtr, p);
			p = pt->next;
		} else {
			pt = p;
			p = p->next;
		}
	}
}


/*****************************************************************************
 *
 * Allocate and fill a new list element.
 *
 *****************************************************************************/

RF_ReconMapListElem_t *
rf_MakeReconMapListElem(RF_SectorNum_t startSector, RF_SectorNum_t stopSector,
    RF_ReconMapListElem_t *next)
{
	RF_ReconMapListElem_t *p;

	RF_Malloc(p, sizeof(RF_ReconMapListElem_t), (RF_ReconMapListElem_t *));
	if (p == NULL)
		return (NULL);
	p->startSector = startSector;
	p->stopSector = stopSector;
	p->next = next;
	return (p);
}


/*****************************************************************************
 *
 * Free a list element.
 *
 *****************************************************************************/

void
rf_FreeReconMapListElem(RF_ReconMap_t *mapPtr, RF_ReconMapListElem_t *p)
{
	int delta;

	if (mapPtr) {
		delta = 0 - (int) sizeof(RF_ReconMapListElem_t);
		rf_update_size(mapPtr, delta);
	}
	RF_Free(p, sizeof(*p));
}


/*****************************************************************************
 *
 * Free an entire status structure. Inefficient, but can be called at any
 * time.
 *
 *****************************************************************************/

void
rf_FreeReconMap(RF_ReconMap_t *mapPtr)
{
	RF_ReconMapListElem_t *p, *q;
	RF_ReconUnitCount_t numRUs;
	RF_ReconUnitNum_t i;

	numRUs = mapPtr->sectorsInDisk / mapPtr->sectorsPerReconUnit;
	if (mapPtr->sectorsInDisk % mapPtr->sectorsPerReconUnit)
		numRUs++;

	for (i = 0; i < numRUs; i++) {
		p = mapPtr->status[i];
		while (p != RU_NOTHING && p != RU_ALL) {
			q = p;
			p = p->next;
			RF_Free(q, sizeof(*q));
		}
	}
	rf_mutex_destroy(&mapPtr->mutex);
	RF_Free(mapPtr->status, mapPtr->totalRUs *
	    sizeof(RF_ReconMapListElem_t *));
	RF_Free(mapPtr, sizeof(RF_ReconMap_t));
}


/*****************************************************************************
 *
 * Returns nonzero if the indicated RU has been reconstructed already.
 *
 *****************************************************************************/

int
rf_CheckRUReconstructed(RF_ReconMap_t *mapPtr, RF_SectorNum_t startSector)
{
	RF_ReconMapListElem_t *l;	/* Used for searching. */
	RF_ReconUnitNum_t i;

	i = startSector / mapPtr->sectorsPerReconUnit;
	l = mapPtr->status[i];
	return ((l == RU_ALL) ? 1 : 0);
}

RF_ReconUnitCount_t
rf_UnitsLeftToReconstruct(RF_ReconMap_t *mapPtr)
{
	RF_ASSERT(mapPtr != NULL);
	return (mapPtr->unitsLeft);
}

/* Updates the size fields of a status descriptor. */
void
rf_update_size(RF_ReconMap_t *mapPtr, int size)
{
	mapPtr->size += size;
	mapPtr->maxSize = RF_MAX(mapPtr->size, mapPtr->maxSize);
}

void
rf_PrintList(RF_ReconMapListElem_t *listPtr)
{
	while (listPtr) {
		printf("%d,%d -> ", (int) listPtr->startSector,
		    (int) listPtr->stopSector);
		listPtr = listPtr->next;
	}
	printf("\n");
}

void
rf_PrintReconMap(RF_Raid_t *raidPtr, RF_ReconMap_t *mapPtr, RF_RowCol_t frow,
    RF_RowCol_t fcol)
{
	RF_ReconUnitCount_t numRUs;
	RF_ReconMapListElem_t *p;
	RF_ReconUnitNum_t i;

	numRUs = mapPtr->totalRUs;
	if (mapPtr->sectorsInDisk % mapPtr->sectorsPerReconUnit)
		numRUs++;

	for (i = 0; i < numRUs; i++) {
		p = mapPtr->status[i];
		if (p == RU_ALL)
			/* printf("[%d] ALL.\n", i) */;
		else
			if (p == RU_NOTHING) {
				printf("%d: Unreconstructed.\n", i);
			} else {
				printf("%d: ", i);
				rf_PrintList(p);
			}
	}
}

void
rf_PrintReconSchedule(RF_ReconMap_t *mapPtr, struct timeval *starttime)
{
	static int old_pctg = -1;
	struct timeval tv, diff;
	int new_pctg;

	new_pctg = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 /
	    mapPtr->totalRUs);
	if (new_pctg != old_pctg) {
		RF_GETTIME(tv);
		RF_TIMEVAL_DIFF(starttime, &tv, &diff);
		printf("%d %d.%06d\n", (int) new_pctg, (int) diff.tv_sec,
		    (int) diff.tv_usec);
		old_pctg = new_pctg;
	}
}
@


1.5
log
@remove stupid casts, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconmap.c,v 1.4 2002/12/16 07:01:05 tdeval Exp $	*/
@


1.4
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconmap.c,v 1.3 2000/01/07 14:50:22 peter Exp $	*/
d105 1
a105 1
	(void) bzero((char *) p->status, num_rus *
@


1.3
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconmap.c,v 1.2 1999/02/16 00:03:21 niklas Exp $	*/
d3 1
d31 1
a31 1
/*************************************************************************
d34 1
a34 1
 * code to maintain a map of what sectors have/have not been reconstructed
d36 1
a36 1
 *************************************************************************/
d43 3
a45 2
/* special pointer values indicating that a reconstruction unit
 * has been either totally reconstructed or not at all.  Both
d47 2
a48 2
 * dereference through them.  RU_NOTHING must be zero, since
 * MakeReconMap uses bzero to initialize the structure.  These are used
d51 5
a55 2
#define RU_ALL      ((RF_ReconMapListElem_t *) -1)
#define RU_NOTHING  ((RF_ReconMapListElem_t *) 0)
a56 2
/* used to mark the end of the list */
#define RU_NIL      ((RF_ReconMapListElem_t *) 0)
d58 7
a65 12
static void 
compact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,
    int i);
static void crunch_list(RF_ReconMap_t * mapPtr, RF_ReconMapListElem_t * listPtr);
static RF_ReconMapListElem_t *
MakeReconMapListElem(RF_SectorNum_t startSector,
    RF_SectorNum_t stopSector, RF_ReconMapListElem_t * next);
static void 
FreeReconMapListElem(RF_ReconMap_t * mapPtr,
    RF_ReconMapListElem_t * p);
static void update_size(RF_ReconMap_t * mapPtr, int size);
static void PrintList(RF_ReconMapListElem_t * listPtr);
d67 1
a67 1
/*-----------------------------------------------------------------------------
d69 1
a69 1
 * Creates and initializes new Reconstruction map
d71 1
a71 1
 *-----------------------------------------------------------------------------*/
d74 12
a85 7
rf_MakeReconMap(raidPtr, ru_sectors, disk_sectors, spareUnitsPerDisk)
	RF_Raid_t *raidPtr;
	RF_SectorCount_t ru_sectors;	/* size of reconstruction unit in
					 * sectors */
	RF_SectorCount_t disk_sectors;	/* size of disk in sectors */
	RF_ReconUnitCount_t spareUnitsPerDisk;	/* zero unless distributed
						 * sparing */
d88 2
a89 1
	RF_ReconUnitCount_t num_rus = layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerRU;
d91 1
a91 1
	int     rc;
d101 2
a102 1
	RF_Malloc(p->status, num_rus * sizeof(RF_ReconMapListElem_t *), (RF_ReconMapListElem_t **));
d105 2
a106 1
	(void) bzero((char *) p->status, num_rus * sizeof(RF_ReconMapListElem_t *));
d108 2
a109 1
	p->size = sizeof(RF_ReconMap_t) + num_rus * sizeof(RF_ReconMapListElem_t *);
d114 2
a115 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d124 1
a124 1
/*-----------------------------------------------------------------------------
d126 2
a127 2
 * marks a new set of sectors as reconstructed.  All the possible mergings get
 * complicated.  To simplify matters, the approach I take is to just dump
d129 2
a130 1
 * eliminate redundant ones) in a second pass over the list (compact_stat_entry()).
d133 9
a141 12
 * special cases.  The only thing that compact_stat_entry() assumes is that the
 * list is sorted by startSector, and so this is the only condition I maintain
 * here.  (MCH)
 *
 *-----------------------------------------------------------------------------*/

void 
rf_ReconMapUpdate(raidPtr, mapPtr, startSector, stopSector)
	RF_Raid_t *raidPtr;
	RF_ReconMap_t *mapPtr;
	RF_SectorNum_t startSector;
	RF_SectorNum_t stopSector;
d148 2
a149 1
	RF_ASSERT(startSector >= 0 && stopSector < mapPtr->sectorsInDisk && stopSector >= startSector);
d157 2
a158 2
			if (p == RU_NOTHING || p->startSector > startSector) {	/* insert at front of
										 * list */
d160 6
a165 2
				mapPtr->status[i] = MakeReconMapListElem(startSector, RF_MIN(stopSector, last_in_RU), (p == RU_NOTHING) ? NULL : p);
				update_size(mapPtr, sizeof(RF_ReconMapListElem_t));
d167 2
a168 2
			} else {/* general case */
				do {	/* search for place to insert */
d172 4
a175 2
				pt->next = MakeReconMapListElem(startSector, RF_MIN(stopSector, last_in_RU), p);
				update_size(mapPtr, sizeof(RF_ReconMapListElem_t));
d177 1
a177 1
			compact_stat_entry(raidPtr, mapPtr, i);
d185 1
a185 2

/*-----------------------------------------------------------------------------
d187 3
a189 3
 * performs whatever list compactions can be done, and frees any space
 * that is no longer necessary.  Assumes only that the list is sorted
 * by startSector.  crunch_list() compacts a single list as much as possible,
d191 1
a191 1
 * crunch_list() is also called from MakeReconMapAccessList().
d195 8
a202 11
 * code will not select this parity stripe again.  This is redundant (but
 * harmless) when compact_stat_entry is called from the reconstruction code,
 * but necessary when called from the user-write code.
 *
 *-----------------------------------------------------------------------------*/

static void 
compact_stat_entry(raidPtr, mapPtr, i)
	RF_Raid_t *raidPtr;
	RF_ReconMap_t *mapPtr;
	int     i;
d207 1
a207 1
	crunch_list(mapPtr, p);
d210 2
a211 1
	    (p->stopSector == i * sectorsPerReconUnit + sectorsPerReconUnit - 1)) {
d214 1
a214 1
		FreeReconMapListElem(mapPtr, p);
d218 2
a219 4
static void 
crunch_list(mapPtr, listPtr)
	RF_ReconMap_t *mapPtr;
	RF_ReconMapListElem_t *listPtr;
d231 1
a231 1
			FreeReconMapListElem(mapPtr, p);
d239 3
a241 1
/*-----------------------------------------------------------------------------
d243 1
a243 1
 * Allocate and fill a new list element
d245 1
a245 1
 *-----------------------------------------------------------------------------*/
d247 3
a249 5
static RF_ReconMapListElem_t *
MakeReconMapListElem(
    RF_SectorNum_t startSector,
    RF_SectorNum_t stopSector,
    RF_ReconMapListElem_t * next)
d261 3
a263 1
/*-----------------------------------------------------------------------------
d265 1
a265 1
 * Free a list element
d267 1
a267 1
 *-----------------------------------------------------------------------------*/
d269 2
a270 4
static void 
FreeReconMapListElem(mapPtr, p)
	RF_ReconMap_t *mapPtr;
	RF_ReconMapListElem_t *p;
d272 1
a272 1
	int     delta;
d276 1
a276 1
		update_size(mapPtr, delta);
d280 3
a282 1
/*-----------------------------------------------------------------------------
d284 2
a285 1
 * Free an entire status structure.  Inefficient, but can be called at any time.
d287 4
a290 4
 *-----------------------------------------------------------------------------*/
void 
rf_FreeReconMap(mapPtr)
	RF_ReconMap_t *mapPtr;
d309 2
a310 1
	RF_Free(mapPtr->status, mapPtr->totalRUs * sizeof(RF_ReconMapListElem_t *));
d313 3
a315 1
/*-----------------------------------------------------------------------------
d317 1
a317 1
 * returns nonzero if the indicated RU has been reconstructed already
d319 1
a319 1
 *---------------------------------------------------------------------------*/
d321 2
a322 4
int 
rf_CheckRUReconstructed(mapPtr, startSector)
	RF_ReconMap_t *mapPtr;
	RF_SectorNum_t startSector;
d324 1
a324 1
	RF_ReconMapListElem_t *l;	/* used for searching */
d332 2
a333 3
RF_ReconUnitCount_t 
rf_UnitsLeftToReconstruct(mapPtr)
	RF_ReconMap_t *mapPtr;
d338 4
a341 5
/* updates the size fields of a status descriptor */
static void 
update_size(mapPtr, size)
	RF_ReconMap_t *mapPtr;
	int     size;
d347 2
a348 3
static void 
PrintList(listPtr)
	RF_ReconMapListElem_t *listPtr;
d351 2
a352 1
		printf("%d,%d -> ", (int) listPtr->startSector, (int) listPtr->stopSector);
d358 3
a360 6
void 
rf_PrintReconMap(raidPtr, mapPtr, frow, fcol)
	RF_Raid_t *raidPtr;
	RF_ReconMap_t *mapPtr;
	RF_RowCol_t frow;
	RF_RowCol_t fcol;
d372 2
a373 2
		if (p == RU_ALL)/* printf("[%d] ALL\n",i) */
			;
d376 1
a376 1
				printf("%d: Unreconstructed\n", i);
d379 1
a379 1
				PrintList(p);
d384 2
a385 4
void 
rf_PrintReconSchedule(mapPtr, starttime)
	RF_ReconMap_t *mapPtr;
	struct timeval *starttime;
d389 1
a389 1
	int     new_pctg;
d391 2
a392 1
	new_pctg = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);
d396 2
a397 1
		printf("%d %d.%06d\n", (int) new_pctg, (int) diff.tv_sec, (int) diff.tv_usec);
@


1.3.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d33 1
a33 1
 * Code to maintain a map of what sectors have/have not been reconstructed.
d35 1
a35 1
 *****************************************************************************/
d42 2
a43 3
/*
 * Special pointer values indicating that a reconstruction unit
 * has been either totally reconstructed or not at all. Both
d45 2
a46 2
 * dereference through them. RU_NOTHING must be zero, since
 * MakeReconMap uses bzero to initialize the structure. These are used
d49 2
a50 5
#define	RU_ALL		((RF_ReconMapListElem_t *) -1)
#define	RU_NOTHING	((RF_ReconMapListElem_t *) 0)

/* Used to mark the end of the list. */
#define	RU_NIL		((RF_ReconMapListElem_t *) 0)
d52 2
a54 7
void rf_compact_stat_entry(RF_Raid_t *, RF_ReconMap_t *, int);
void rf_crunch_list(RF_ReconMap_t *, RF_ReconMapListElem_t *);
RF_ReconMapListElem_t * rf_MakeReconMapListElem(RF_SectorNum_t, RF_SectorNum_t,
	RF_ReconMapListElem_t *);
void rf_FreeReconMapListElem(RF_ReconMap_t *, RF_ReconMapListElem_t *);
void rf_update_size(RF_ReconMap_t *, int);
void rf_PrintList(RF_ReconMapListElem_t *);
d56 12
d69 1
a69 1
/*****************************************************************************
d71 1
a71 1
 * Creates and initializes new Reconstruction map.
d73 1
a73 1
 *****************************************************************************/
d76 7
a82 12
rf_MakeReconMap(
    RF_Raid_t		*raidPtr,
    RF_SectorCount_t	 ru_sectors,		/*
						 * Size of reconstruction unit
						 * in sectors.
						 */
    RF_SectorCount_t	 disk_sectors,		/* Size of disk in sectors. */
    RF_ReconUnitCount_t	 spareUnitsPerDisk	/*
						 * Zero unless distributed
						 * sparing.
						 */
)
d85 1
a85 2
	RF_ReconUnitCount_t num_rus = layoutPtr->stripeUnitsPerDisk /
	    layoutPtr->SUsPerRU;
d87 1
a87 1
	int rc;
d97 1
a97 2
	RF_Malloc(p->status, num_rus * sizeof(RF_ReconMapListElem_t *),
	    (RF_ReconMapListElem_t **));
d100 1
a100 2
	(void) bzero((char *) p->status, num_rus *
	    sizeof(RF_ReconMapListElem_t *));
d102 1
a102 2
	p->size = sizeof(RF_ReconMap_t) + num_rus *
	    sizeof(RF_ReconMapListElem_t *);
d107 2
a108 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n",
		    __FILE__, __LINE__, rc);
d117 1
a117 1
/*****************************************************************************
d119 2
a120 2
 * Marks a new set of sectors as reconstructed. All the possible mergings get
 * complicated. To simplify matters, the approach I take is to just dump
d122 1
a122 2
 * eliminate redundant ones) in a second pass over the list
 * (rf_compact_stat_entry()).
d125 12
a136 9
 * special cases. The only thing that rf_compact_stat_entry() assumes is that
 * the list is sorted by startSector, and so this is the only condition I
 * maintain here. (MCH)
 *
 *****************************************************************************/

void
rf_ReconMapUpdate(RF_Raid_t *raidPtr, RF_ReconMap_t *mapPtr,
    RF_SectorNum_t startSector, RF_SectorNum_t stopSector)
d143 1
a143 2
	RF_ASSERT(startSector >= 0 && stopSector < mapPtr->sectorsInDisk &&
	    stopSector >= startSector);
d151 2
a152 2
			if (p == RU_NOTHING || p->startSector > startSector) {
				/* Insert at front of list. */
d154 2
a155 6
				mapPtr->status[i] =
				    rf_MakeReconMapListElem(startSector,
				     RF_MIN(stopSector, last_in_RU),
				     (p == RU_NOTHING) ? NULL : p);
				rf_update_size(mapPtr,
				    sizeof(RF_ReconMapListElem_t));
d157 2
a158 2
			} else {/* General case. */
				do {	/* Search for place to insert. */
d162 2
a163 4
				pt->next = rf_MakeReconMapListElem(startSector,
				    RF_MIN(stopSector, last_in_RU), p);
				rf_update_size(mapPtr,
				    sizeof(RF_ReconMapListElem_t));
d165 1
a165 1
			rf_compact_stat_entry(raidPtr, mapPtr, i);
d173 2
a174 1
/*****************************************************************************
d176 3
a178 3
 * Performs whatever list compactions can be done, and frees any space
 * that is no longer necessary. Assumes only that the list is sorted
 * by startSector. rf_crunch_list() compacts a single list as much as possible,
d180 1
a180 1
 * rf_crunch_list() is also called from MakeReconMapAccessList().
d184 11
a194 8
 * code will not select this parity stripe again. This is redundant (but
 * harmless) when rf_compact_stat_entry is called from the reconstruction
 * code, but necessary when called from the user-write code.
 *
 *****************************************************************************/

void
rf_compact_stat_entry(RF_Raid_t *raidPtr, RF_ReconMap_t *mapPtr, int i)
d199 1
a199 1
	rf_crunch_list(mapPtr, p);
d202 1
a202 2
	    (p->stopSector == i * sectorsPerReconUnit +
	     sectorsPerReconUnit - 1)) {
d205 1
a205 1
		rf_FreeReconMapListElem(mapPtr, p);
d209 4
a212 2
void
rf_crunch_list(RF_ReconMap_t *mapPtr, RF_ReconMapListElem_t *listPtr)
d224 1
a224 1
			rf_FreeReconMapListElem(mapPtr, p);
d232 1
a232 3


/*****************************************************************************
d234 1
a234 1
 * Allocate and fill a new list element.
d236 1
a236 1
 *****************************************************************************/
d238 5
a242 3
RF_ReconMapListElem_t *
rf_MakeReconMapListElem(RF_SectorNum_t startSector, RF_SectorNum_t stopSector,
    RF_ReconMapListElem_t *next)
d254 1
a254 3


/*****************************************************************************
d256 1
a256 1
 * Free a list element.
d258 1
a258 1
 *****************************************************************************/
d260 4
a263 2
void
rf_FreeReconMapListElem(RF_ReconMap_t *mapPtr, RF_ReconMapListElem_t *p)
d265 1
a265 1
	int delta;
d269 1
a269 1
		rf_update_size(mapPtr, delta);
d273 1
a273 3


/*****************************************************************************
d275 1
a275 2
 * Free an entire status structure. Inefficient, but can be called at any
 * time.
d277 4
a280 4
 *****************************************************************************/

void
rf_FreeReconMap(RF_ReconMap_t *mapPtr)
d299 1
a299 2
	RF_Free(mapPtr->status, mapPtr->totalRUs *
	    sizeof(RF_ReconMapListElem_t *));
d302 1
a302 3


/*****************************************************************************
d304 1
a304 1
 * Returns nonzero if the indicated RU has been reconstructed already.
d306 1
a306 1
 *****************************************************************************/
d308 4
a311 2
int
rf_CheckRUReconstructed(RF_ReconMap_t *mapPtr, RF_SectorNum_t startSector)
d313 1
a313 1
	RF_ReconMapListElem_t *l;	/* Used for searching. */
d321 3
a323 2
RF_ReconUnitCount_t
rf_UnitsLeftToReconstruct(RF_ReconMap_t *mapPtr)
d328 5
a332 4

/* Updates the size fields of a status descriptor. */
void
rf_update_size(RF_ReconMap_t *mapPtr, int size)
d338 3
a340 2
void
rf_PrintList(RF_ReconMapListElem_t *listPtr)
d343 1
a343 2
		printf("%d,%d -> ", (int) listPtr->startSector,
		    (int) listPtr->stopSector);
d349 6
a354 3
void
rf_PrintReconMap(RF_Raid_t *raidPtr, RF_ReconMap_t *mapPtr, RF_RowCol_t frow,
    RF_RowCol_t fcol)
d366 2
a367 2
		if (p == RU_ALL)
			/* printf("[%d] ALL.\n", i) */;
d370 1
a370 1
				printf("%d: Unreconstructed.\n", i);
d373 1
a373 1
				rf_PrintList(p);
d378 4
a381 2
void
rf_PrintReconSchedule(RF_ReconMap_t *mapPtr, struct timeval *starttime)
d385 1
a385 1
	int new_pctg;
d387 1
a387 2
	new_pctg = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 /
	    mapPtr->totalRUs);
d391 1
a391 2
		printf("%d %d.%06d\n", (int) new_pctg, (int) diff.tv_sec,
		    (int) diff.tv_usec);
@


1.3.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d33 1
a33 1
 * Code to maintain a map of what sectors have/have not been reconstructed.
d35 1
a35 1
 *****************************************************************************/
d42 2
a43 3
/*
 * Special pointer values indicating that a reconstruction unit
 * has been either totally reconstructed or not at all. Both
d45 2
a46 2
 * dereference through them. RU_NOTHING must be zero, since
 * MakeReconMap uses bzero to initialize the structure. These are used
d49 2
a50 5
#define	RU_ALL		((RF_ReconMapListElem_t *) -1)
#define	RU_NOTHING	((RF_ReconMapListElem_t *) 0)

/* Used to mark the end of the list. */
#define	RU_NIL		((RF_ReconMapListElem_t *) 0)
d52 2
a54 7
void rf_compact_stat_entry(RF_Raid_t *, RF_ReconMap_t *, int);
void rf_crunch_list(RF_ReconMap_t *, RF_ReconMapListElem_t *);
RF_ReconMapListElem_t * rf_MakeReconMapListElem(RF_SectorNum_t, RF_SectorNum_t,
	RF_ReconMapListElem_t *);
void rf_FreeReconMapListElem(RF_ReconMap_t *, RF_ReconMapListElem_t *);
void rf_update_size(RF_ReconMap_t *, int);
void rf_PrintList(RF_ReconMapListElem_t *);
d56 12
d69 1
a69 1
/*****************************************************************************
d71 1
a71 1
 * Creates and initializes new Reconstruction map.
d73 1
a73 1
 *****************************************************************************/
d76 7
a82 12
rf_MakeReconMap(
    RF_Raid_t		*raidPtr,
    RF_SectorCount_t	 ru_sectors,		/*
						 * Size of reconstruction unit
						 * in sectors.
						 */
    RF_SectorCount_t	 disk_sectors,		/* Size of disk in sectors. */
    RF_ReconUnitCount_t	 spareUnitsPerDisk	/*
						 * Zero unless distributed
						 * sparing.
						 */
)
d85 1
a85 2
	RF_ReconUnitCount_t num_rus = layoutPtr->stripeUnitsPerDisk /
	    layoutPtr->SUsPerRU;
d87 1
a87 1
	int rc;
d97 1
a97 2
	RF_Malloc(p->status, num_rus * sizeof(RF_ReconMapListElem_t *),
	    (RF_ReconMapListElem_t **));
d100 1
a100 2
	(void) bzero((char *) p->status, num_rus *
	    sizeof(RF_ReconMapListElem_t *));
d102 1
a102 2
	p->size = sizeof(RF_ReconMap_t) + num_rus *
	    sizeof(RF_ReconMapListElem_t *);
d107 2
a108 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n",
		    __FILE__, __LINE__, rc);
d117 1
a117 1
/*****************************************************************************
d119 2
a120 2
 * Marks a new set of sectors as reconstructed. All the possible mergings get
 * complicated. To simplify matters, the approach I take is to just dump
d122 1
a122 2
 * eliminate redundant ones) in a second pass over the list
 * (rf_compact_stat_entry()).
d125 12
a136 9
 * special cases. The only thing that rf_compact_stat_entry() assumes is that
 * the list is sorted by startSector, and so this is the only condition I
 * maintain here. (MCH)
 *
 *****************************************************************************/

void
rf_ReconMapUpdate(RF_Raid_t *raidPtr, RF_ReconMap_t *mapPtr,
    RF_SectorNum_t startSector, RF_SectorNum_t stopSector)
d143 1
a143 2
	RF_ASSERT(startSector >= 0 && stopSector < mapPtr->sectorsInDisk &&
	    stopSector >= startSector);
d151 2
a152 2
			if (p == RU_NOTHING || p->startSector > startSector) {
				/* Insert at front of list. */
d154 2
a155 6
				mapPtr->status[i] =
				    rf_MakeReconMapListElem(startSector,
				     RF_MIN(stopSector, last_in_RU),
				     (p == RU_NOTHING) ? NULL : p);
				rf_update_size(mapPtr,
				    sizeof(RF_ReconMapListElem_t));
d157 2
a158 2
			} else {/* General case. */
				do {	/* Search for place to insert. */
d162 2
a163 4
				pt->next = rf_MakeReconMapListElem(startSector,
				    RF_MIN(stopSector, last_in_RU), p);
				rf_update_size(mapPtr,
				    sizeof(RF_ReconMapListElem_t));
d165 1
a165 1
			rf_compact_stat_entry(raidPtr, mapPtr, i);
d173 2
a174 1
/*****************************************************************************
d176 3
a178 3
 * Performs whatever list compactions can be done, and frees any space
 * that is no longer necessary. Assumes only that the list is sorted
 * by startSector. rf_crunch_list() compacts a single list as much as possible,
d180 1
a180 1
 * rf_crunch_list() is also called from MakeReconMapAccessList().
d184 11
a194 8
 * code will not select this parity stripe again. This is redundant (but
 * harmless) when rf_compact_stat_entry is called from the reconstruction
 * code, but necessary when called from the user-write code.
 *
 *****************************************************************************/

void
rf_compact_stat_entry(RF_Raid_t *raidPtr, RF_ReconMap_t *mapPtr, int i)
d199 1
a199 1
	rf_crunch_list(mapPtr, p);
d202 1
a202 2
	    (p->stopSector == i * sectorsPerReconUnit +
	     sectorsPerReconUnit - 1)) {
d205 1
a205 1
		rf_FreeReconMapListElem(mapPtr, p);
d209 4
a212 2
void
rf_crunch_list(RF_ReconMap_t *mapPtr, RF_ReconMapListElem_t *listPtr)
d224 1
a224 1
			rf_FreeReconMapListElem(mapPtr, p);
d232 1
a232 3


/*****************************************************************************
d234 1
a234 1
 * Allocate and fill a new list element.
d236 1
a236 1
 *****************************************************************************/
d238 5
a242 3
RF_ReconMapListElem_t *
rf_MakeReconMapListElem(RF_SectorNum_t startSector, RF_SectorNum_t stopSector,
    RF_ReconMapListElem_t *next)
d254 1
a254 3


/*****************************************************************************
d256 1
a256 1
 * Free a list element.
d258 1
a258 1
 *****************************************************************************/
d260 4
a263 2
void
rf_FreeReconMapListElem(RF_ReconMap_t *mapPtr, RF_ReconMapListElem_t *p)
d265 1
a265 1
	int delta;
d269 1
a269 1
		rf_update_size(mapPtr, delta);
d273 1
a273 3


/*****************************************************************************
d275 1
a275 2
 * Free an entire status structure. Inefficient, but can be called at any
 * time.
d277 4
a280 4
 *****************************************************************************/

void
rf_FreeReconMap(RF_ReconMap_t *mapPtr)
d299 1
a299 2
	RF_Free(mapPtr->status, mapPtr->totalRUs *
	    sizeof(RF_ReconMapListElem_t *));
d302 1
a302 3


/*****************************************************************************
d304 1
a304 1
 * Returns nonzero if the indicated RU has been reconstructed already.
d306 1
a306 1
 *****************************************************************************/
d308 4
a311 2
int
rf_CheckRUReconstructed(RF_ReconMap_t *mapPtr, RF_SectorNum_t startSector)
d313 1
a313 1
	RF_ReconMapListElem_t *l;	/* Used for searching. */
d321 3
a323 2
RF_ReconUnitCount_t
rf_UnitsLeftToReconstruct(RF_ReconMap_t *mapPtr)
d328 5
a332 4

/* Updates the size fields of a status descriptor. */
void
rf_update_size(RF_ReconMap_t *mapPtr, int size)
d338 3
a340 2
void
rf_PrintList(RF_ReconMapListElem_t *listPtr)
d343 1
a343 2
		printf("%d,%d -> ", (int) listPtr->startSector,
		    (int) listPtr->stopSector);
d349 6
a354 3
void
rf_PrintReconMap(RF_Raid_t *raidPtr, RF_ReconMap_t *mapPtr, RF_RowCol_t frow,
    RF_RowCol_t fcol)
d366 2
a367 2
		if (p == RU_ALL)
			/* printf("[%d] ALL.\n", i) */;
d370 1
a370 1
				printf("%d: Unreconstructed.\n", i);
d373 1
a373 1
				rf_PrintList(p);
d378 4
a381 2
void
rf_PrintReconSchedule(RF_ReconMap_t *mapPtr, struct timeval *starttime)
d385 1
a385 1
	int new_pctg;
d387 1
a387 2
	new_pctg = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 /
	    mapPtr->totalRUs);
d391 1
a391 2
		printf("%d %d.%06d\n", (int) new_pctg, (int) diff.tv_sec,
		    (int) diff.tv_usec);
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconmap.c,v 1.1 1999/01/11 14:29:46 niklas Exp $	*/
/*	$NetBSD: rf_reconmap.c,v 1.4 1999/02/05 00:06:16 oster Exp $	*/
a40 1
#include "rf_sys.h"
d143 1
a143 1
	RF_ASSERT(startSector >= 0 && stopSector < mapPtr->sectorsInDisk && stopSector > startSector);
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconmap.c,v 1.1 1998/11/13 04:20:33 oster Exp $	*/
/*	$NetBSD: rf_reconmap.c,v 1.1 1998/11/13 04:20:33 oster Exp $	*/
a36 71
/* :  
 * Log: rf_reconmap.c,v 
 * Revision 1.23  1996/07/27 23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.22  1996/07/15  17:22:18  jimz
 * nit-pick code cleanup
 * resolve stdlib problems on DEC OSF
 *
 * Revision 1.21  1996/06/17  14:38:33  jimz
 * properly #if out RF_DEMO code
 * fix bug in MakeConfig that was causing weird behavior
 * in configuration routines (config was not zeroed at start)
 * clean up genplot handling of stacks
 *
 * Revision 1.20  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.19  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.18  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.17  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.16  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.15  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.14  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.13  1996/05/24  04:40:57  jimz
 * don't do recon meter demo stuff in kernel
 *
 * Revision 1.12  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.11  1996/05/20  16:14:50  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.10  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.9  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.8  1995/12/06  15:05:23  root
 * added copyright info
 *
 */

a40 3
#if RF_DEMO > 0
#include "rf_demo.h"
#endif /* RF_DEMO > 0 */
d57 12
a68 9
static void compact_stat_entry(RF_Raid_t *raidPtr, RF_ReconMap_t *mapPtr,
	int i);
static void crunch_list(RF_ReconMap_t *mapPtr, RF_ReconMapListElem_t *listPtr);
static RF_ReconMapListElem_t *MakeReconMapListElem(RF_SectorNum_t startSector,
	RF_SectorNum_t stopSector, RF_ReconMapListElem_t *next);
static void FreeReconMapListElem(RF_ReconMap_t *mapPtr,
	RF_ReconMapListElem_t *p);
static void update_size(RF_ReconMap_t *mapPtr, int size);
static void PrintList(RF_ReconMapListElem_t *listPtr);
d72 1
a72 1
 * Creates and initializes new Reconstruction map 
d76 39
a114 36
RF_ReconMap_t *rf_MakeReconMap(raidPtr, ru_sectors, disk_sectors, spareUnitsPerDisk)
  RF_Raid_t            *raidPtr;
  RF_SectorCount_t      ru_sectors;        /* size of reconstruction unit in sectors */
  RF_SectorCount_t      disk_sectors;      /* size of disk in sectors */
  RF_ReconUnitCount_t   spareUnitsPerDisk; /* zero unless distributed sparing */
{
  RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
  RF_ReconUnitCount_t num_rus = layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerRU;
  RF_ReconMap_t *p;
  int rc;

  RF_Malloc(p, sizeof(RF_ReconMap_t), (RF_ReconMap_t *));
  p->sectorsPerReconUnit = ru_sectors;
  p->sectorsInDisk = disk_sectors;

  p->totalRUs = num_rus;
  p->spareRUs = spareUnitsPerDisk;
  p->unitsLeft = num_rus - spareUnitsPerDisk;

  RF_Malloc(p->status, num_rus * sizeof(RF_ReconMapListElem_t *), (RF_ReconMapListElem_t **));
  RF_ASSERT(p->status != (RF_ReconMapListElem_t **) NULL);

  (void) bzero((char *) p->status, num_rus * sizeof(RF_ReconMapListElem_t *));

  p->size = sizeof(RF_ReconMap_t) + num_rus * sizeof(RF_ReconMapListElem_t *);
  p->maxSize = p->size;
    
  rc = rf_mutex_init(&p->mutex);
  if (rc) {
    RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    RF_Free(p->status, num_rus * sizeof(RF_ReconMapListElem_t *));
    RF_Free(p, sizeof(RF_ReconMap_t));
    return(NULL);
  }
  return(p);
d132 39
a170 36
void rf_ReconMapUpdate(raidPtr, mapPtr, startSector, stopSector)
  RF_Raid_t       *raidPtr;
  RF_ReconMap_t   *mapPtr;
  RF_SectorNum_t   startSector;
  RF_SectorNum_t   stopSector;
{
  RF_SectorCount_t sectorsPerReconUnit = mapPtr->sectorsPerReconUnit;
  RF_SectorNum_t i, first_in_RU, last_in_RU;
  RF_ReconMapListElem_t *p, *pt;

  RF_LOCK_MUTEX(mapPtr->mutex);
  RF_ASSERT(startSector >=0 && stopSector < mapPtr->sectorsInDisk && stopSector > startSector);

  while (startSector <= stopSector) {
    i = startSector/mapPtr->sectorsPerReconUnit;
    first_in_RU = i*sectorsPerReconUnit;
    last_in_RU  = first_in_RU + sectorsPerReconUnit -1 ;
    p = mapPtr->status[i];
    if (p!=RU_ALL) {
      if (p==RU_NOTHING || p->startSector > startSector ) {	/* insert at front of list */
	
	mapPtr->status[i] = MakeReconMapListElem(startSector, RF_MIN(stopSector,last_in_RU), (p==RU_NOTHING) ? NULL : p);
	update_size(mapPtr, sizeof(RF_ReconMapListElem_t));
	
      } else {						/* general case */
	do {						/* search for place to insert */
	  pt = p; p = p->next;
	} while (p && (p->startSector < startSector));
	pt->next = MakeReconMapListElem(startSector,RF_MIN(stopSector,last_in_RU),p);
	update_size(mapPtr, sizeof(RF_ReconMapListElem_t));
      }
      compact_stat_entry(raidPtr, mapPtr, i);
    }
    startSector = RF_MIN(stopSector, last_in_RU) +1;
  }
  RF_UNLOCK_MUTEX(mapPtr->mutex);
d191 41
a231 38
static void compact_stat_entry(raidPtr, mapPtr, i)
  RF_Raid_t      *raidPtr;
  RF_ReconMap_t  *mapPtr;
  int             i;
{
  RF_SectorCount_t sectorsPerReconUnit = mapPtr->sectorsPerReconUnit;
  RF_ReconMapListElem_t *p = mapPtr->status[i];

  crunch_list(mapPtr, p);

  if ((p->startSector == i*sectorsPerReconUnit) &&
      (p->stopSector == i*sectorsPerReconUnit +sectorsPerReconUnit -1)) {
    mapPtr->status[i] = RU_ALL;
    mapPtr->unitsLeft--;
    FreeReconMapListElem(mapPtr,p);
  }
}

static void crunch_list(mapPtr, listPtr)
  RF_ReconMap_t          *mapPtr;
  RF_ReconMapListElem_t  *listPtr;
{
  RF_ReconMapListElem_t *pt, *p = listPtr;

  if (!p) return;
  pt = p;  p = p->next;
  while (p) {
    if (pt->stopSector >= p->startSector-1) {
      pt->stopSector = RF_MAX(pt->stopSector, p->stopSector);
      pt->next = p->next;
      FreeReconMapListElem(mapPtr, p);
      p = pt->next;
    }
    else {
      pt = p;
      p = p->next;
    }
  }
a232 1

d234 1
a234 1
 * 
d239 15
a253 14
static RF_ReconMapListElem_t *MakeReconMapListElem(
  RF_SectorNum_t          startSector,
  RF_SectorNum_t          stopSector,
  RF_ReconMapListElem_t  *next)
{
  RF_ReconMapListElem_t *p;

  RF_Malloc(p, sizeof(RF_ReconMapListElem_t), (RF_ReconMapListElem_t *));
  if (p == NULL)
    return(NULL);
  p->startSector = startSector;
  p->stopSector = stopSector;
  p->next = next;
  return(p);
a254 1

d256 1
a256 1
 * 
d261 12
a272 11
static void FreeReconMapListElem(mapPtr,p)
  RF_ReconMap_t          *mapPtr;
  RF_ReconMapListElem_t  *p;
{
  int delta;

  if (mapPtr) {
    delta = 0 - (int)sizeof(RF_ReconMapListElem_t);
    update_size(mapPtr, delta);
  }
  RF_Free(p, sizeof(*p));
a273 1

d275 1
a275 1
 * 
d279 23
a301 21
void rf_FreeReconMap(mapPtr)
  RF_ReconMap_t  *mapPtr;
{
  RF_ReconMapListElem_t *p, *q;
  RF_ReconUnitCount_t numRUs;
  RF_ReconUnitNum_t i;

  numRUs = mapPtr->sectorsInDisk / mapPtr->sectorsPerReconUnit;
  if (mapPtr->sectorsInDisk % mapPtr->sectorsPerReconUnit)
    numRUs++;

  for (i=0; i<numRUs; i++) {
    p = mapPtr->status[i];
    while (p != RU_NOTHING && p != RU_ALL) {
      q = p; p = p->next;
      RF_Free(q, sizeof(*q));
    }
  }
  rf_mutex_destroy(&mapPtr->mutex);
  RF_Free(mapPtr->status, mapPtr->totalRUs * sizeof(RF_ReconMapListElem_t *));
  RF_Free(mapPtr, sizeof(RF_ReconMap_t));
a302 1

d309 4
a312 3
int rf_CheckRUReconstructed(mapPtr, startSector)
  RF_ReconMap_t   *mapPtr;
  RF_SectorNum_t   startSector;
d314 2
a315 2
  RF_ReconMapListElem_t *l;		/* used for searching */
  RF_ReconUnitNum_t i;
d317 3
a319 3
  i = startSector / mapPtr->sectorsPerReconUnit;
  l = mapPtr->status[i];
  return( (l == RU_ALL) ? 1 : 0 );
d322 3
a324 2
RF_ReconUnitCount_t rf_UnitsLeftToReconstruct(mapPtr)
  RF_ReconMap_t  *mapPtr;
d326 2
a327 2
  RF_ASSERT(mapPtr != NULL);
  return( mapPtr->unitsLeft );
a328 1

d330 65
a394 68
static void update_size(mapPtr, size)
  RF_ReconMap_t  *mapPtr;
  int             size;
{
  mapPtr->size += size;
  mapPtr->maxSize = RF_MAX(mapPtr->size, mapPtr->maxSize);
}

static void PrintList(listPtr)
  RF_ReconMapListElem_t  *listPtr;
{
  while (listPtr) {
    printf("%d,%d -> ",(int)listPtr->startSector,(int)listPtr->stopSector);
    listPtr = listPtr->next;
  }
  printf("\n");
}
    
void rf_PrintReconMap(raidPtr, mapPtr, frow, fcol)
  RF_Raid_t      *raidPtr;
  RF_ReconMap_t  *mapPtr;
  RF_RowCol_t     frow;
  RF_RowCol_t     fcol;
{
  RF_ReconUnitCount_t numRUs;
  RF_ReconMapListElem_t *p;
  RF_ReconUnitNum_t i;

  numRUs = mapPtr->totalRUs;
  if (mapPtr->sectorsInDisk % mapPtr->sectorsPerReconUnit)
    numRUs++;

  for (i=0; i<numRUs; i++) {
    p = mapPtr->status[i];
    if (p==RU_ALL) /*printf("[%d] ALL\n",i)*/;
    else if (p == RU_NOTHING) {
      printf("%d: Unreconstructed\n",i);
    } else {
      printf("%d: ", i);
      PrintList(p);
    }
  }
}

void rf_PrintReconSchedule(mapPtr, starttime)
  RF_ReconMap_t   *mapPtr;
  struct timeval  *starttime;
{
  static int old_pctg = -1;
  struct timeval tv, diff;
  int new_pctg;
  
  new_pctg = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);
  if (new_pctg != old_pctg) {
    RF_GETTIME(tv);
    RF_TIMEVAL_DIFF(starttime, &tv, &diff);
#if RF_DEMO > 0
    if (rf_demoMode) {
      rf_update_recon_meter(new_pctg);
    }
    else {
      printf("%d %d.%06d\n",new_pctg, diff.tv_sec, diff.tv_usec);
    }
#else /* RF_DEMO > 0 */
    printf("%d %d.%06d\n",(int)new_pctg, (int)diff.tv_sec, (int)diff.tv_usec);
#endif /* RF_DEMO > 0 */
    old_pctg = new_pctg;
  }
@

