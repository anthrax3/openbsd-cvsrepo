head	1.8;
access;
symbols
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.20
	OPENBSD_5_0:1.7.0.18
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.16
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.14
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.10
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.12
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.7;

1.7
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.09.15.10.20;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.08.16.07.42;	author peter;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.16.00.02.54;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.27;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.26.11;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.4.8.2;

1.4.8.2
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_layout.c,v 1.7 2007/04/10 17:47:55 miod Exp $	*/
/*	$NetBSD: rf_layout.c,v 1.6 2000/04/17 19:35:12 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * rf_layout.c -- Driver code dealing with layout and mapping issues.
 */

#include "rf_types.h"
#include "rf_archs.h"
#include "rf_raid.h"
#include "rf_configure.h"
#include "rf_dag.h"
#include "rf_desc.h"
#include "rf_decluster.h"
#include "rf_pq.h"
#include "rf_declusterPQ.h"
#include "rf_raid0.h"
#include "rf_raid1.h"
#include "rf_raid4.h"
#include "rf_raid5.h"
#include "rf_states.h"
#if	RF_INCLUDE_RAID5_RS > 0
#include "rf_raid5_rotatedspare.h"
#endif	/* RF_INCLUDE_RAID5_RS > 0 */
#if	RF_INCLUDE_CHAINDECLUSTER > 0
#include "rf_chaindecluster.h"
#endif	/* RF_INCLUDE_CHAINDECLUSTER > 0 */
#if	RF_INCLUDE_INTERDECLUSTER > 0
#include "rf_interdecluster.h"
#endif	/* RF_INCLUDE_INTERDECLUSTER > 0 */
#if	RF_INCLUDE_PARITYLOGGING > 0
#include "rf_paritylogging.h"
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
#if	RF_INCLUDE_EVENODD > 0
#include "rf_evenodd.h"
#endif	/* RF_INCLUDE_EVENODD > 0 */
#include "rf_general.h"
#include "rf_driver.h"
#include "rf_parityscan.h"
#include "rf_reconbuffer.h"
#include "rf_reconutil.h"

/*****************************************************************************
 *
 * The layout switch defines all the layouts that are supported.
 * Fields are:	layout ID, init routine, shutdown routine, map sector,
 *		map parity, identify stripe, dag selection, map stripeid
 *		to parity stripe id (optional), num faults tolerated,
 *		special flags.
 *
 *****************************************************************************/

static RF_AccessState_t DefaultStates[] = {
	rf_QuiesceState, rf_IncrAccessesCountState, rf_MapState,
	rf_LockState, rf_CreateDAGState, rf_ExecuteDAGState,
	rf_ProcessDAGState, rf_DecrAccessesCountState,
	rf_CleanupState, rf_LastState
};

#if	(defined(__NetBSD__) || defined(__OpenBSD__)) && !defined(_KERNEL)
/*
 * XXX Gross hack to shutup gcc -- It complains that DefaultStates is not
 * used when compiling this in userland... I hate to burst its bubble, but
 * DefaultStates is used all over the place here in the initialization of
 * lots of data structures. GO
 */
RF_AccessState_t *NothingAtAll = DefaultStates;
#endif

#if	(defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
/* XXX Remove static so GCC doesn't complain about these being unused ! */
int distSpareYes = 1;
int distSpareNo = 0;
#else
static int distSpareYes = 1;
static int distSpareNo = 0;
#endif

#ifdef	_KERNEL
#define	RF_NK2(a,b)
#else	/* _KERNEL */
#define	RF_NK2(a,b)	a,b,
#endif	/* !_KERNEL */

#if	RF_UTILITY > 0
#define	RF_NU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)
#else	/* RF_UTILITY > 0 */
#define	RF_NU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
#endif	/* RF_UTILITY > 0 */

static RF_LayoutSW_t mapsw[] = {
	/* Parity declustering. */
	{'T', "Parity declustering",
		RF_NK2(rf_MakeLayoutSpecificDeclustered, &distSpareNo)
		RF_NU(
		    rf_ConfigureDeclustered,
		    rf_MapSectorDeclustered, rf_MapParityDeclustered, NULL,
		    rf_IdentifyStripeDeclustered,
		    rf_RaidFiveDagSelect,
		    rf_MapSIDToPSIDDeclustered,
		    rf_GetDefaultHeadSepLimitDeclustered,
		    rf_GetDefaultNumFloatingReconBuffersDeclustered,
		    NULL, NULL,
		    rf_SubmitReconBufferBasic,
		    rf_VerifyParityBasic,
		    1,
		    DefaultStates,
		    0)
	},

	/* Parity declustering with distributed sparing. */
	{'D', "Distributed sparing parity declustering",
		RF_NK2(rf_MakeLayoutSpecificDeclustered, &distSpareYes)
		RF_NU(
		    rf_ConfigureDeclusteredDS,
		    rf_MapSectorDeclustered, rf_MapParityDeclustered, NULL,
		    rf_IdentifyStripeDeclustered,
		    rf_RaidFiveDagSelect,
		    rf_MapSIDToPSIDDeclustered,
		    rf_GetDefaultHeadSepLimitDeclustered,
		    rf_GetDefaultNumFloatingReconBuffersDeclustered,
		    rf_GetNumSpareRUsDeclustered, rf_InstallSpareTable,
		    rf_SubmitReconBufferBasic,
		    rf_VerifyParityBasic,
		    1,
		    DefaultStates,
		    RF_DISTRIBUTE_SPARE | RF_BD_DECLUSTERED)
	},

#if	RF_INCLUDE_DECL_PQ > 0
	/* Declustered P+Q. */
	{'Q', "Declustered P+Q",
		RF_NK2(rf_MakeLayoutSpecificDeclustered, &distSpareNo)
		RF_NU(
		    rf_ConfigureDeclusteredPQ,
		    rf_MapSectorDeclusteredPQ, rf_MapParityDeclusteredPQ,
		    rf_MapQDeclusteredPQ,
		    rf_IdentifyStripeDeclusteredPQ,
		    rf_PQDagSelect,
		    rf_MapSIDToPSIDDeclustered,
		    rf_GetDefaultHeadSepLimitDeclustered,
		    rf_GetDefaultNumFloatingReconBuffersPQ,
		    NULL, NULL,
		    NULL,
		    rf_VerifyParityBasic,
		    2,
		    DefaultStates,
		    0)
	},
#endif	/* RF_INCLUDE_DECL_PQ > 0 */

#if	RF_INCLUDE_RAID5_RS > 0
	/* RAID 5 with rotated sparing. */
	{'R', "RAID Level 5 rotated sparing",
		RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
		RF_NU(
		    rf_ConfigureRAID5_RS,
		    rf_MapSectorRAID5_RS, rf_MapParityRAID5_RS, NULL,
		    rf_IdentifyStripeRAID5_RS,
		    rf_RaidFiveDagSelect,
		    rf_MapSIDToPSIDRAID5_RS,
		    rf_GetDefaultHeadSepLimitRAID5,
		    rf_GetDefaultNumFloatingReconBuffersRAID5,
		    rf_GetNumSpareRUsRAID5_RS, NULL,
		    rf_SubmitReconBufferBasic,
		    rf_VerifyParityBasic,
		    1,
		    DefaultStates,
		    RF_DISTRIBUTE_SPARE)
	},
#endif	/* RF_INCLUDE_RAID5_RS > 0 */

#if	RF_INCLUDE_CHAINDECLUSTER > 0
	/* Chained Declustering. */
	{'C', "Chained Declustering",
		RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
		RF_NU(
		    rf_ConfigureChainDecluster,
		    rf_MapSectorChainDecluster, rf_MapParityChainDecluster,
		    NULL,
		    rf_IdentifyStripeChainDecluster,
		    rf_RAIDCDagSelect,
		    rf_MapSIDToPSIDChainDecluster,
		    NULL,
		    NULL,
		    rf_GetNumSpareRUsChainDecluster, NULL,
		    rf_SubmitReconBufferBasic,
		    rf_VerifyParityBasic,
		    1,
		    DefaultStates,
		    0)
	},
#endif	/* RF_INCLUDE_CHAINDECLUSTER > 0 */

#if	RF_INCLUDE_INTERDECLUSTER > 0
	/* Interleaved Declustering. */
	{'I', "Interleaved Declustering",
		RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
		RF_NU(
		    rf_ConfigureInterDecluster,
		    rf_MapSectorInterDecluster, rf_MapParityInterDecluster,
		    NULL,
		    rf_IdentifyStripeInterDecluster,
		    rf_RAIDIDagSelect,
		    rf_MapSIDToPSIDInterDecluster,
		    rf_GetDefaultHeadSepLimitInterDecluster,
		    rf_GetDefaultNumFloatingReconBuffersInterDecluster,
		    rf_GetNumSpareRUsInterDecluster, NULL,
		    rf_SubmitReconBufferBasic,
		    rf_VerifyParityBasic,
		    1,
		    DefaultStates,
		    RF_DISTRIBUTE_SPARE)
	},
#endif	/* RF_INCLUDE_INTERDECLUSTER > 0 */

#if	RF_INCLUDE_RAID0 > 0
	/* RAID level 0. */
	{'0', "RAID Level 0",
		RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
		RF_NU(
		    rf_ConfigureRAID0,
		    rf_MapSectorRAID0, rf_MapParityRAID0, NULL,
		    rf_IdentifyStripeRAID0,
		    rf_RAID0DagSelect,
		    rf_MapSIDToPSIDRAID0,
		    NULL,
		    NULL,
		    NULL, NULL,
		    NULL,
		    rf_VerifyParityRAID0,
		    0,
		    DefaultStates,
		    0)
	},
#endif	/* RF_INCLUDE_RAID0 > 0 */

#if	RF_INCLUDE_RAID1 > 0
	/* RAID level 1. */
	{'1', "RAID Level 1",
		RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
		RF_NU(
		    rf_ConfigureRAID1,
		    rf_MapSectorRAID1, rf_MapParityRAID1, NULL,
		    rf_IdentifyStripeRAID1,
		    rf_RAID1DagSelect,
		    rf_MapSIDToPSIDRAID1,
		    NULL,
		    NULL,
		    NULL, NULL,
		    rf_SubmitReconBufferRAID1,
		    rf_VerifyParityRAID1,
		    1,
		    DefaultStates,
		    0)
	},
#endif	/* RF_INCLUDE_RAID1 > 0 */

#if	RF_INCLUDE_RAID4 > 0
	/* RAID level 4. */
	{'4', "RAID Level 4",
		RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
		RF_NU(
		    rf_ConfigureRAID4,
		    rf_MapSectorRAID4, rf_MapParityRAID4, NULL,
		    rf_IdentifyStripeRAID4,
		    rf_RaidFiveDagSelect,
		    rf_MapSIDToPSIDRAID4,
		    rf_GetDefaultHeadSepLimitRAID4,
		    rf_GetDefaultNumFloatingReconBuffersRAID4,
		    NULL, NULL,
		    rf_SubmitReconBufferBasic,
		    rf_VerifyParityBasic,
		    1,
		    DefaultStates,
		    0)
	},
#endif	/* RF_INCLUDE_RAID4 > 0 */

#if	RF_INCLUDE_RAID5 > 0
	/* RAID level 5. */
	{'5', "RAID Level 5",
		RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
		RF_NU(
		    rf_ConfigureRAID5,
		    rf_MapSectorRAID5, rf_MapParityRAID5, NULL,
		    rf_IdentifyStripeRAID5,
		    rf_RaidFiveDagSelect,
		    rf_MapSIDToPSIDRAID5,
		    rf_GetDefaultHeadSepLimitRAID5,
		    rf_GetDefaultNumFloatingReconBuffersRAID5,
		    NULL, NULL,
		    rf_SubmitReconBufferBasic,
		    rf_VerifyParityBasic,
		    1,
		    DefaultStates,
		    0)
	},
#endif	/* RF_INCLUDE_RAID5 > 0 */

#if	RF_INCLUDE_EVENODD > 0
	/* Evenodd. */
	{'E', "EvenOdd",
		RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
		RF_NU(
		    rf_ConfigureEvenOdd,
		    rf_MapSectorRAID5, rf_MapParityEvenOdd, rf_MapEEvenOdd,
		    rf_IdentifyStripeEvenOdd,
		    rf_EODagSelect,
		    rf_MapSIDToPSIDRAID5,
		    NULL,
		    NULL,
		    NULL, NULL,
		    NULL,	/* No reconstruction, yet. */
		    rf_VerifyParityEvenOdd,
		    2,
		    DefaultStates,
		    0)
	},
#endif	/* RF_INCLUDE_EVENODD > 0 */

#if	RF_INCLUDE_EVENODD > 0
	/* Declustered Evenodd. */
	{'e', "Declustered EvenOdd",
		RF_NK2(rf_MakeLayoutSpecificDeclustered, &distSpareNo)
		RF_NU(
		    rf_ConfigureDeclusteredPQ,
		    rf_MapSectorDeclusteredPQ, rf_MapParityDeclusteredPQ,
		    rf_MapQDeclusteredPQ,
		    rf_IdentifyStripeDeclusteredPQ,
		    rf_EODagSelect,
		    rf_MapSIDToPSIDRAID5,
		    rf_GetDefaultHeadSepLimitDeclustered,
		    rf_GetDefaultNumFloatingReconBuffersPQ,
		    NULL, NULL,
		    NULL,	/* No reconstruction, yet. */
		    rf_VerifyParityEvenOdd,
		    2,
		    DefaultStates,
		    0)
	},
#endif	/* RF_INCLUDE_EVENODD > 0 */

#if	RF_INCLUDE_PARITYLOGGING > 0
	/* Parity logging. */
	{'L', "Parity logging",
		RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
		RF_NU(
		    rf_ConfigureParityLogging,
		    rf_MapSectorParityLogging, rf_MapParityParityLogging, NULL,
		    rf_IdentifyStripeParityLogging,
		    rf_ParityLoggingDagSelect,
		    rf_MapSIDToPSIDParityLogging,
		    rf_GetDefaultHeadSepLimitParityLogging,
		    rf_GetDefaultNumFloatingReconBuffersParityLogging,
		    NULL, NULL,
		    rf_SubmitReconBufferBasic,
		    NULL,
		    1,
		    DefaultStates,
		    0)
	},
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */

	/* End-of-list marker. */
	{'\0', NULL,
		RF_NK2(NULL, NULL)
		RF_NU(
		    NULL,
		    NULL, NULL, NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL, NULL,
		    NULL,
		    NULL,
		    0,
		    NULL,
		    0)
	}
};

RF_LayoutSW_t *
rf_GetLayout(RF_ParityConfig_t parityConfig)
{
	RF_LayoutSW_t *p;

	/* Look up the specific layout. */
	for (p = &mapsw[0]; p->parityConfig; p++)
		if (p->parityConfig == parityConfig)
			break;
	if (!p->parityConfig)
		return (NULL);
	RF_ASSERT(p->parityConfig == parityConfig);
	return (p);
}

#if	RF_UTILITY == 0
/*****************************************************************************
 *
 * ConfigureLayout
 *
 * Read the configuration file and set up the RAID layout parameters.
 * After reading common params, invokes the layout-specific configuration
 * routine to finish the configuration.
 *
 *****************************************************************************/
int
rf_ConfigureLayout(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	RF_ParityConfig_t parityConfig;
	RF_LayoutSW_t *p;
	int retval;

	layoutPtr->sectorsPerStripeUnit = cfgPtr->sectPerSU;
	layoutPtr->SUsPerPU = cfgPtr->SUsPerPU;
	layoutPtr->SUsPerRU = cfgPtr->SUsPerRU;
	parityConfig = cfgPtr->parityConfig;

	if (layoutPtr->sectorsPerStripeUnit <= 0) {
		RF_ERRORMSG2("raid%d: Invalid sectorsPerStripeUnit: %d.\n",
		    raidPtr->raidid, (int)layoutPtr->sectorsPerStripeUnit);
		return (EINVAL);
	}

	layoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk /
	    layoutPtr->sectorsPerStripeUnit;

	p = rf_GetLayout(parityConfig);
	if (p == NULL) {
		RF_ERRORMSG1("Unknown parity configuration '%c'", parityConfig);
		return (EINVAL);
	}
	RF_ASSERT(p->parityConfig == parityConfig);
	layoutPtr->map = p;

	/* Initialize the specific layout. */

	retval = (p->Configure) (listp, raidPtr, cfgPtr);

	if (retval)
		return (retval);

	layoutPtr->dataBytesPerStripe = layoutPtr->dataSectorsPerStripe <<
	    raidPtr->logBytesPerSector;
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;

	if (rf_forceNumFloatingReconBufs >= 0) {
		raidPtr->numFloatingReconBufs = rf_forceNumFloatingReconBufs;
	} else {
		raidPtr->numFloatingReconBufs =
		    rf_GetDefaultNumFloatingReconBuffers(raidPtr);
	}

	if (rf_forceHeadSepLimit >= 0) {
		raidPtr->headSepLimit = rf_forceHeadSepLimit;
	} else {
		raidPtr->headSepLimit = rf_GetDefaultHeadSepLimit(raidPtr);
	}

#ifdef	RAIDDEBUG
	if (raidPtr->headSepLimit >= 0) {
		printf("RAIDFRAME(%s): Using %ld floating recon bufs"
		    " with head sep limit %ld.\n", layoutPtr->map->configName,
		    (long) raidPtr->numFloatingReconBufs,
		    (long) raidPtr->headSepLimit);
	} else {
		printf("RAIDFRAME(%s): Using %ld floating recon bufs"
		    " with no head sep limit.\n", layoutPtr->map->configName,
		    (long) raidPtr->numFloatingReconBufs);
	}
#endif	/* RAIDDEBUG */

	return (0);
}

/*
 * Typically there is a 1-1 mapping between stripes and parity stripes.
 * However, the declustering code supports packing multiple stripes into
 * a single parity stripe, so as to increase the size of the reconstruction
 * unit without affecting the size of the stripe unit. This routine finds
 * the parity stripe identifier associated with a stripe ID. There is also
 * a RaidAddressToParityStripeID macro in layout.h
 */
RF_StripeNum_t
rf_MapStripeIDToParityStripeID(RF_RaidLayout_t *layoutPtr,
    RF_StripeNum_t stripeID, RF_ReconUnitNum_t *which_ru)
{
	RF_StripeNum_t parityStripeID;

	/* Quick exit in the common case of SUsPerPU == 1. */
	if ((layoutPtr->SUsPerPU == 1) || !layoutPtr->map->MapSIDToPSID) {
		*which_ru = 0;
		return (stripeID);
	} else {
		(layoutPtr->map->MapSIDToPSID) (layoutPtr, stripeID,
		    &parityStripeID, which_ru);
	}
	return (parityStripeID);
}
#endif	/* RF_UTILITY == 0 */
@


1.7
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_layout.c,v 1.6 2002/12/16 07:01:04 tdeval Exp $	*/
@


1.6
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_layout.c,v 1.5 2002/08/09 15:10:20 tdeval Exp $	*/
d90 1
a90 1
 * used when compiling this in userland... I hate to burst it's bubble, but
@


1.5
log
@Remove those noisy informational messages from dmesg.
Use the option RAIDDEBUG to get these.

Theo, thanks for suggesting.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_layout.c,v 1.4 2000/08/08 16:07:42 peter Exp $	*/
d3 1
d31 2
a32 1
/* rf_layout.c -- driver code dealing with layout and mapping issues
d49 1
a49 1
#if RF_INCLUDE_RAID5_RS > 0
d51 2
a52 2
#endif				/* RF_INCLUDE_RAID5_RS > 0 */
#if RF_INCLUDE_CHAINDECLUSTER > 0
d54 2
a55 2
#endif				/* RF_INCLUDE_CHAINDECLUSTER > 0 */
#if RF_INCLUDE_INTERDECLUSTER > 0
d57 2
a58 2
#endif				/* RF_INCLUDE_INTERDECLUSTER > 0 */
#if RF_INCLUDE_PARITYLOGGING > 0
d60 2
a61 2
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
#if RF_INCLUDE_EVENODD > 0
d63 1
a63 1
#endif				/* RF_INCLUDE_EVENODD > 0 */
d70 1
a70 1
/***********************************************************************
d72 22
a93 17
 * the layout switch defines all the layouts that are supported.
 *    fields are: layout ID, init routine, shutdown routine, map
 *    sector, map parity, identify stripe, dag selection, map stripeid
 *    to parity stripe id (optional), num faults tolerated, special
 *    flags.
 *
 ***********************************************************************/

static RF_AccessState_t DefaultStates[] = {rf_QuiesceState,
	rf_IncrAccessesCountState, rf_MapState, rf_LockState, rf_CreateDAGState,
	rf_ExecuteDAGState, rf_ProcessDAGState, rf_DecrAccessesCountState,
rf_CleanupState, rf_LastState};
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && !defined(_KERNEL)
/* XXX Gross hack to shutup gcc -- it complains that DefaultStates is not
used when compiling this in userland..  I hate to burst it's bubble, but
DefaultStates is used all over the place here in the initialization of
lots of data structures.  GO */
d97 4
a100 4
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
/* XXX Remove static so GCC doesn't complain about these being unused! */
int     distSpareYes = 1;
int     distSpareNo = 0;
d105 12
a116 11
#ifdef _KERNEL
#define RF_NK2(a,b)
#else				/* _KERNEL */
#define RF_NK2(a,b) a,b,
#endif				/* _KERNEL */

#if RF_UTILITY > 0
#define RF_NU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)
#else				/* RF_UTILITY > 0 */
#define RF_NU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
#endif				/* RF_UTILITY > 0 */
d119 1
a119 1
	/* parity declustering */
d138 1
a138 1
	/* parity declustering with distributed sparing */
d157 2
a158 2
#if RF_INCLUDE_DECL_PQ > 0
	/* declustered P+Q */
d163 2
a164 1
		    rf_MapSectorDeclusteredPQ, rf_MapParityDeclusteredPQ, rf_MapQDeclusteredPQ,
d177 1
a177 1
#endif				/* RF_INCLUDE_DECL_PQ > 0 */
d179 2
a180 2
#if RF_INCLUDE_RAID5_RS > 0
	/* RAID 5 with rotated sparing */
d198 1
a198 1
#endif				/* RF_INCLUDE_RAID5_RS > 0 */
d200 2
a201 2
#if RF_INCLUDE_CHAINDECLUSTER > 0
	/* Chained Declustering */
d206 2
a207 1
		    rf_MapSectorChainDecluster, rf_MapParityChainDecluster, NULL,
d220 1
a220 1
#endif				/* RF_INCLUDE_CHAINDECLUSTER > 0 */
d222 2
a223 2
#if RF_INCLUDE_INTERDECLUSTER > 0
	/* Interleaved Declustering */
d228 2
a229 1
		    rf_MapSectorInterDecluster, rf_MapParityInterDecluster, NULL,
d242 1
a242 1
#endif				/* RF_INCLUDE_INTERDECLUSTER > 0 */
d244 2
a245 2
#if RF_INCLUDE_RAID0 > 0
	/* RAID level 0 */
d263 1
a263 1
#endif				/* RF_INCLUDE_RAID0 > 0 */
d265 2
a266 2
#if RF_INCLUDE_RAID1 > 0
	/* RAID level 1 */
d284 1
a284 1
#endif				/* RF_INCLUDE_RAID1 > 0 */
d286 2
a287 2
#if RF_INCLUDE_RAID4 > 0
	/* RAID level 4 */
d305 1
a305 1
#endif				/* RF_INCLUDE_RAID4 > 0 */
d307 2
a308 2
#if RF_INCLUDE_RAID5 > 0
	/* RAID level 5 */
d326 1
a326 1
#endif				/* RF_INCLUDE_RAID5 > 0 */
d328 2
a329 2
#if RF_INCLUDE_EVENODD > 0
	/* Evenodd */
d341 1
a341 1
		    NULL,	/* no reconstruction, yet */
d347 1
a347 1
#endif				/* RF_INCLUDE_EVENODD > 0 */
d349 2
a350 2
#if RF_INCLUDE_EVENODD > 0
	/* Declustered Evenodd */
d355 2
a356 1
		    rf_MapSectorDeclusteredPQ, rf_MapParityDeclusteredPQ, rf_MapQDeclusteredPQ,
d363 1
a363 1
		    NULL,	/* no reconstruction, yet */
d369 1
a369 1
#endif				/* RF_INCLUDE_EVENODD > 0 */
d371 2
a372 2
#if RF_INCLUDE_PARITYLOGGING > 0
	/* parity logging */
d390 1
a390 1
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
d392 1
a392 1
	/* end-of-list marker */
d417 1
a417 1
	/* look up the specific layout */
d426 3
a428 2
#if RF_UTILITY == 0
/*****************************************************************************************
d430 1
a430 1
 * ConfigureLayout --
d432 8
a439 10
 * read the configuration file and set up the RAID layout parameters.  After reading
 * common params, invokes the layout-specific configuration routine to finish
 * the configuration.
 *
 ****************************************************************************************/
int 
rf_ConfigureLayout(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d444 1
a444 1
	int     retval;
d452 3
a454 4
		RF_ERRORMSG2("raid%d: Invalid sectorsPerStripeUnit: %d\n",
			     raidPtr->raidid, 
			     (int)layoutPtr->sectorsPerStripeUnit );
		return (EINVAL); 
d457 2
a458 1
	layoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk / layoutPtr->sectorsPerStripeUnit;
d468 1
a468 1
	/* initialize the specific layout */
d475 4
a478 2
	layoutPtr->dataBytesPerStripe = layoutPtr->dataSectorsPerStripe << raidPtr->logBytesPerSector;
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;
d483 2
a484 1
		raidPtr->numFloatingReconBufs = rf_GetDefaultNumFloatingReconBuffers(raidPtr);
d496 1
a496 1
		    " with head sep limit %ld\n", layoutPtr->map->configName,
d501 1
a501 1
		    " with no head sep limit\n", layoutPtr->map->configName,
d509 3
a511 2
/* typically there is a 1-1 mapping between stripes and parity stripes.
 * however, the declustering code supports packing multiple stripes into
d513 2
a514 2
 * unit without affecting the size of the stripe unit.  This routine finds
 * the parity stripe identifier associated with a stripe ID.  There is also
d517 3
a519 5
RF_StripeNum_t 
rf_MapStripeIDToParityStripeID(layoutPtr, stripeID, which_ru)
	RF_RaidLayout_t *layoutPtr;
	RF_StripeNum_t stripeID;
	RF_ReconUnitNum_t *which_ru;
d523 1
a523 1
	/* quick exit in the common case of SUsPerPU==1 */
d528 2
a529 1
		(layoutPtr->map->MapSIDToPSID) (layoutPtr, stripeID, &parityStripeID, which_ru);
d533 1
a533 1
#endif				/* RF_UTILITY == 0 */
@


1.4
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_layout.c,v 1.3 1999/07/30 14:45:32 peter Exp $	*/
d479 1
a479 4
	printf("RAIDFRAME: Configure (%s): total number of sectors is %lu (%lu MB)\n",
	    layoutPtr->map->configName,
	    (unsigned long) raidPtr->totalSectors,
	    (unsigned long) (raidPtr->totalSectors / 1024 * (1 << raidPtr->logBytesPerSector) / 1024));
d481 4
a484 2
		printf("RAIDFRAME(%s): Using %ld floating recon bufs with head sep limit %ld\n",
		    layoutPtr->map->configName, (long) raidPtr->numFloatingReconBufs, (long) raidPtr->headSepLimit);
d486 3
a488 2
		printf("RAIDFRAME(%s): Using %ld floating recon bufs with no head sep limit\n",
		    layoutPtr->map->configName, (long) raidPtr->numFloatingReconBufs);
d490 1
@


1.4.8.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_layout.c,v 1.4 2000/08/08 16:07:42 peter Exp $	*/
d479 4
a482 1
#ifdef	RAIDDEBUG
d484 2
a485 4
		printf("RAIDFRAME(%s): Using %ld floating recon bufs"
		    " with head sep limit %ld\n", layoutPtr->map->configName,
		    (long) raidPtr->numFloatingReconBufs,
		    (long) raidPtr->headSepLimit);
d487 2
a488 3
		printf("RAIDFRAME(%s): Using %ld floating recon bufs"
		    " with no head sep limit\n", layoutPtr->map->configName,
		    (long) raidPtr->numFloatingReconBufs);
a489 1
#endif	/* RAIDDEBUG */
@


1.4.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 2
/*
 * rf_layout.c -- Driver code dealing with layout and mapping issues.
d47 1
a47 1
#if	RF_INCLUDE_RAID5_RS > 0
d49 2
a50 2
#endif	/* RF_INCLUDE_RAID5_RS > 0 */
#if	RF_INCLUDE_CHAINDECLUSTER > 0
d52 2
a53 2
#endif	/* RF_INCLUDE_CHAINDECLUSTER > 0 */
#if	RF_INCLUDE_INTERDECLUSTER > 0
d55 2
a56 2
#endif	/* RF_INCLUDE_INTERDECLUSTER > 0 */
#if	RF_INCLUDE_PARITYLOGGING > 0
d58 2
a59 2
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
#if	RF_INCLUDE_EVENODD > 0
d61 1
a61 1
#endif	/* RF_INCLUDE_EVENODD > 0 */
d68 1
a68 1
/*****************************************************************************
d70 17
a86 22
 * The layout switch defines all the layouts that are supported.
 * Fields are:	layout ID, init routine, shutdown routine, map sector,
 *		map parity, identify stripe, dag selection, map stripeid
 *		to parity stripe id (optional), num faults tolerated,
 *		special flags.
 *
 *****************************************************************************/

static RF_AccessState_t DefaultStates[] = {
	rf_QuiesceState, rf_IncrAccessesCountState, rf_MapState,
	rf_LockState, rf_CreateDAGState, rf_ExecuteDAGState,
	rf_ProcessDAGState, rf_DecrAccessesCountState,
	rf_CleanupState, rf_LastState
};

#if	(defined(__NetBSD__) || defined(__OpenBSD__)) && !defined(_KERNEL)
/*
 * XXX Gross hack to shutup gcc -- It complains that DefaultStates is not
 * used when compiling this in userland... I hate to burst it's bubble, but
 * DefaultStates is used all over the place here in the initialization of
 * lots of data structures. GO
 */
d90 4
a93 4
#if	(defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
/* XXX Remove static so GCC doesn't complain about these being unused ! */
int distSpareYes = 1;
int distSpareNo = 0;
d98 11
a108 12

#ifdef	_KERNEL
#define	RF_NK2(a,b)
#else	/* _KERNEL */
#define	RF_NK2(a,b)	a,b,
#endif	/* !_KERNEL */

#if	RF_UTILITY > 0
#define	RF_NU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)
#else	/* RF_UTILITY > 0 */
#define	RF_NU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
#endif	/* RF_UTILITY > 0 */
d111 1
a111 1
	/* Parity declustering. */
d130 1
a130 1
	/* Parity declustering with distributed sparing. */
d149 2
a150 2
#if	RF_INCLUDE_DECL_PQ > 0
	/* Declustered P+Q. */
d155 1
a155 2
		    rf_MapSectorDeclusteredPQ, rf_MapParityDeclusteredPQ,
		    rf_MapQDeclusteredPQ,
d168 1
a168 1
#endif	/* RF_INCLUDE_DECL_PQ > 0 */
d170 2
a171 2
#if	RF_INCLUDE_RAID5_RS > 0
	/* RAID 5 with rotated sparing. */
d189 1
a189 1
#endif	/* RF_INCLUDE_RAID5_RS > 0 */
d191 2
a192 2
#if	RF_INCLUDE_CHAINDECLUSTER > 0
	/* Chained Declustering. */
d197 1
a197 2
		    rf_MapSectorChainDecluster, rf_MapParityChainDecluster,
		    NULL,
d210 1
a210 1
#endif	/* RF_INCLUDE_CHAINDECLUSTER > 0 */
d212 2
a213 2
#if	RF_INCLUDE_INTERDECLUSTER > 0
	/* Interleaved Declustering. */
d218 1
a218 2
		    rf_MapSectorInterDecluster, rf_MapParityInterDecluster,
		    NULL,
d231 1
a231 1
#endif	/* RF_INCLUDE_INTERDECLUSTER > 0 */
d233 2
a234 2
#if	RF_INCLUDE_RAID0 > 0
	/* RAID level 0. */
d252 1
a252 1
#endif	/* RF_INCLUDE_RAID0 > 0 */
d254 2
a255 2
#if	RF_INCLUDE_RAID1 > 0
	/* RAID level 1. */
d273 1
a273 1
#endif	/* RF_INCLUDE_RAID1 > 0 */
d275 2
a276 2
#if	RF_INCLUDE_RAID4 > 0
	/* RAID level 4. */
d294 1
a294 1
#endif	/* RF_INCLUDE_RAID4 > 0 */
d296 2
a297 2
#if	RF_INCLUDE_RAID5 > 0
	/* RAID level 5. */
d315 1
a315 1
#endif	/* RF_INCLUDE_RAID5 > 0 */
d317 2
a318 2
#if	RF_INCLUDE_EVENODD > 0
	/* Evenodd. */
d330 1
a330 1
		    NULL,	/* No reconstruction, yet. */
d336 1
a336 1
#endif	/* RF_INCLUDE_EVENODD > 0 */
d338 2
a339 2
#if	RF_INCLUDE_EVENODD > 0
	/* Declustered Evenodd. */
d344 1
a344 2
		    rf_MapSectorDeclusteredPQ, rf_MapParityDeclusteredPQ,
		    rf_MapQDeclusteredPQ,
d351 1
a351 1
		    NULL,	/* No reconstruction, yet. */
d357 1
a357 1
#endif	/* RF_INCLUDE_EVENODD > 0 */
d359 2
a360 2
#if	RF_INCLUDE_PARITYLOGGING > 0
	/* Parity logging. */
d378 1
a378 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d380 1
a380 1
	/* End-of-list marker. */
d405 1
a405 1
	/* Look up the specific layout. */
d414 2
a415 3

#if	RF_UTILITY == 0
/*****************************************************************************
d417 1
a417 1
 * ConfigureLayout
d419 10
a428 8
 * Read the configuration file and set up the RAID layout parameters.
 * After reading common params, invokes the layout-specific configuration
 * routine to finish the configuration.
 *
 *****************************************************************************/
int
rf_ConfigureLayout(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d433 1
a433 1
	int retval;
d441 4
a444 3
		RF_ERRORMSG2("raid%d: Invalid sectorsPerStripeUnit: %d.\n",
		    raidPtr->raidid, (int)layoutPtr->sectorsPerStripeUnit);
		return (EINVAL);
d447 1
a447 2
	layoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk /
	    layoutPtr->sectorsPerStripeUnit;
d457 1
a457 1
	/* Initialize the specific layout. */
d464 2
a465 4
	layoutPtr->dataBytesPerStripe = layoutPtr->dataSectorsPerStripe <<
	    raidPtr->logBytesPerSector;
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;
d470 1
a470 2
		raidPtr->numFloatingReconBufs =
		    rf_GetDefaultNumFloatingReconBuffers(raidPtr);
d482 1
a482 1
		    " with head sep limit %ld.\n", layoutPtr->map->configName,
d487 1
a487 1
		    " with no head sep limit.\n", layoutPtr->map->configName,
d495 2
a496 3
/*
 * Typically there is a 1-1 mapping between stripes and parity stripes.
 * However, the declustering code supports packing multiple stripes into
d498 2
a499 2
 * unit without affecting the size of the stripe unit. This routine finds
 * the parity stripe identifier associated with a stripe ID. There is also
d502 5
a506 3
RF_StripeNum_t
rf_MapStripeIDToParityStripeID(RF_RaidLayout_t *layoutPtr,
    RF_StripeNum_t stripeID, RF_ReconUnitNum_t *which_ru)
d510 1
a510 1
	/* Quick exit in the common case of SUsPerPU == 1. */
d515 1
a515 2
		(layoutPtr->map->MapSIDToPSID) (layoutPtr, stripeID,
		    &parityStripeID, which_ru);
d519 1
a519 1
#endif	/* RF_UTILITY == 0 */
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_layout.c,v 1.2 1999/02/16 00:02:54 niklas Exp $	*/
/*	$NetBSD: rf_layout.c,v 1.4 1999/07/19 01:35:19 oster Exp $	*/
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_layout.c,v 1.4 2000/08/08 16:07:42 peter Exp $	*/
/*	$NetBSD: rf_layout.c,v 1.6 2000/04/17 19:35:12 oster Exp $	*/
@


1.3.4.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 2
/*
 * rf_layout.c -- Driver code dealing with layout and mapping issues.
d47 1
a47 1
#if	RF_INCLUDE_RAID5_RS > 0
d49 2
a50 2
#endif	/* RF_INCLUDE_RAID5_RS > 0 */
#if	RF_INCLUDE_CHAINDECLUSTER > 0
d52 2
a53 2
#endif	/* RF_INCLUDE_CHAINDECLUSTER > 0 */
#if	RF_INCLUDE_INTERDECLUSTER > 0
d55 2
a56 2
#endif	/* RF_INCLUDE_INTERDECLUSTER > 0 */
#if	RF_INCLUDE_PARITYLOGGING > 0
d58 2
a59 2
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
#if	RF_INCLUDE_EVENODD > 0
d61 1
a61 1
#endif	/* RF_INCLUDE_EVENODD > 0 */
d68 1
a68 1
/*****************************************************************************
d70 17
a86 22
 * The layout switch defines all the layouts that are supported.
 * Fields are:	layout ID, init routine, shutdown routine, map sector,
 *		map parity, identify stripe, dag selection, map stripeid
 *		to parity stripe id (optional), num faults tolerated,
 *		special flags.
 *
 *****************************************************************************/

static RF_AccessState_t DefaultStates[] = {
	rf_QuiesceState, rf_IncrAccessesCountState, rf_MapState,
	rf_LockState, rf_CreateDAGState, rf_ExecuteDAGState,
	rf_ProcessDAGState, rf_DecrAccessesCountState,
	rf_CleanupState, rf_LastState
};

#if	(defined(__NetBSD__) || defined(__OpenBSD__)) && !defined(_KERNEL)
/*
 * XXX Gross hack to shutup gcc -- It complains that DefaultStates is not
 * used when compiling this in userland... I hate to burst it's bubble, but
 * DefaultStates is used all over the place here in the initialization of
 * lots of data structures. GO
 */
d90 4
a93 4
#if	(defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
/* XXX Remove static so GCC doesn't complain about these being unused ! */
int distSpareYes = 1;
int distSpareNo = 0;
d98 11
a108 12

#ifdef	_KERNEL
#define	RF_NK2(a,b)
#else	/* _KERNEL */
#define	RF_NK2(a,b)	a,b,
#endif	/* !_KERNEL */

#if	RF_UTILITY > 0
#define	RF_NU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)
#else	/* RF_UTILITY > 0 */
#define	RF_NU(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)	a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
#endif	/* RF_UTILITY > 0 */
d111 1
a111 1
	/* Parity declustering. */
d130 1
a130 1
	/* Parity declustering with distributed sparing. */
d149 2
a150 2
#if	RF_INCLUDE_DECL_PQ > 0
	/* Declustered P+Q. */
d155 1
a155 2
		    rf_MapSectorDeclusteredPQ, rf_MapParityDeclusteredPQ,
		    rf_MapQDeclusteredPQ,
d168 1
a168 1
#endif	/* RF_INCLUDE_DECL_PQ > 0 */
d170 2
a171 2
#if	RF_INCLUDE_RAID5_RS > 0
	/* RAID 5 with rotated sparing. */
d189 1
a189 1
#endif	/* RF_INCLUDE_RAID5_RS > 0 */
d191 2
a192 2
#if	RF_INCLUDE_CHAINDECLUSTER > 0
	/* Chained Declustering. */
d197 1
a197 2
		    rf_MapSectorChainDecluster, rf_MapParityChainDecluster,
		    NULL,
d210 1
a210 1
#endif	/* RF_INCLUDE_CHAINDECLUSTER > 0 */
d212 2
a213 2
#if	RF_INCLUDE_INTERDECLUSTER > 0
	/* Interleaved Declustering. */
d218 1
a218 2
		    rf_MapSectorInterDecluster, rf_MapParityInterDecluster,
		    NULL,
d231 1
a231 1
#endif	/* RF_INCLUDE_INTERDECLUSTER > 0 */
d233 2
a234 2
#if	RF_INCLUDE_RAID0 > 0
	/* RAID level 0. */
d252 1
a252 1
#endif	/* RF_INCLUDE_RAID0 > 0 */
d254 2
a255 2
#if	RF_INCLUDE_RAID1 > 0
	/* RAID level 1. */
d273 1
a273 1
#endif	/* RF_INCLUDE_RAID1 > 0 */
d275 2
a276 2
#if	RF_INCLUDE_RAID4 > 0
	/* RAID level 4. */
d294 1
a294 1
#endif	/* RF_INCLUDE_RAID4 > 0 */
d296 2
a297 2
#if	RF_INCLUDE_RAID5 > 0
	/* RAID level 5. */
d315 1
a315 1
#endif	/* RF_INCLUDE_RAID5 > 0 */
d317 2
a318 2
#if	RF_INCLUDE_EVENODD > 0
	/* Evenodd. */
d330 1
a330 1
		    NULL,	/* No reconstruction, yet. */
d336 1
a336 1
#endif	/* RF_INCLUDE_EVENODD > 0 */
d338 2
a339 2
#if	RF_INCLUDE_EVENODD > 0
	/* Declustered Evenodd. */
d344 1
a344 2
		    rf_MapSectorDeclusteredPQ, rf_MapParityDeclusteredPQ,
		    rf_MapQDeclusteredPQ,
d351 1
a351 1
		    NULL,	/* No reconstruction, yet. */
d357 1
a357 1
#endif	/* RF_INCLUDE_EVENODD > 0 */
d359 2
a360 2
#if	RF_INCLUDE_PARITYLOGGING > 0
	/* Parity logging. */
d378 1
a378 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d380 1
a380 1
	/* End-of-list marker. */
d405 1
a405 1
	/* Look up the specific layout. */
d414 2
a415 3

#if	RF_UTILITY == 0
/*****************************************************************************
d417 1
a417 1
 * ConfigureLayout
d419 10
a428 8
 * Read the configuration file and set up the RAID layout parameters.
 * After reading common params, invokes the layout-specific configuration
 * routine to finish the configuration.
 *
 *****************************************************************************/
int
rf_ConfigureLayout(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d433 1
a433 1
	int retval;
d441 4
a444 3
		RF_ERRORMSG2("raid%d: Invalid sectorsPerStripeUnit: %d.\n",
		    raidPtr->raidid, (int)layoutPtr->sectorsPerStripeUnit);
		return (EINVAL);
d447 1
a447 2
	layoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk /
	    layoutPtr->sectorsPerStripeUnit;
d457 1
a457 1
	/* Initialize the specific layout. */
d464 2
a465 4
	layoutPtr->dataBytesPerStripe = layoutPtr->dataSectorsPerStripe <<
	    raidPtr->logBytesPerSector;
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;
d470 1
a470 2
		raidPtr->numFloatingReconBufs =
		    rf_GetDefaultNumFloatingReconBuffers(raidPtr);
d479 4
a482 1
#ifdef	RAIDDEBUG
d484 2
a485 4
		printf("RAIDFRAME(%s): Using %ld floating recon bufs"
		    " with head sep limit %ld.\n", layoutPtr->map->configName,
		    (long) raidPtr->numFloatingReconBufs,
		    (long) raidPtr->headSepLimit);
d487 2
a488 3
		printf("RAIDFRAME(%s): Using %ld floating recon bufs"
		    " with no head sep limit.\n", layoutPtr->map->configName,
		    (long) raidPtr->numFloatingReconBufs);
a489 1
#endif	/* RAIDDEBUG */
d494 2
a495 3
/*
 * Typically there is a 1-1 mapping between stripes and parity stripes.
 * However, the declustering code supports packing multiple stripes into
d497 2
a498 2
 * unit without affecting the size of the stripe unit. This routine finds
 * the parity stripe identifier associated with a stripe ID. There is also
d501 5
a505 3
RF_StripeNum_t
rf_MapStripeIDToParityStripeID(RF_RaidLayout_t *layoutPtr,
    RF_StripeNum_t stripeID, RF_ReconUnitNum_t *which_ru)
d509 1
a509 1
	/* Quick exit in the common case of SUsPerPU == 1. */
d514 1
a514 2
		(layoutPtr->map->MapSIDToPSID) (layoutPtr, stripeID,
		    &parityStripeID, which_ru);
d518 1
a518 1
#endif	/* RF_UTILITY == 0 */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_layout.c,v 1.1 1999/01/11 14:29:27 niklas Exp $	*/
/*	$NetBSD: rf_layout.c,v 1.3 1999/02/05 00:06:12 oster Exp $	*/
d439 7
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_layout.c,v 1.1 1998/11/13 04:20:30 oster Exp $	*/
/*	$NetBSD: rf_layout.c,v 1.1 1998/11/13 04:20:30 oster Exp $	*/
a32 206
/*
 * :  
 * Log: rf_layout.c,v 
 * Revision 1.71  1996/08/20 22:41:30  jimz
 * add declustered evenodd
 *
 * Revision 1.70  1996/07/31  16:56:18  jimz
 * dataBytesPerStripe, sectorsPerDisk init arch-indep.
 *
 * Revision 1.69  1996/07/31  15:34:46  jimz
 * add EvenOdd
 *
 * Revision 1.68  1996/07/29  14:05:12  jimz
 * fix numPUs/numRUs confusion (everything is now numRUs)
 * clean up some commenting, return values
 *
 * Revision 1.67  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.66  1996/07/27  18:40:24  jimz
 * cleanup sweep
 *
 * Revision 1.65  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.64  1996/07/15  17:22:18  jimz
 * nit-pick code cleanup
 * resolve stdlib problems on DEC OSF
 *
 * Revision 1.63  1996/07/13  00:00:59  jimz
 * sanitized generalized reconstruction architecture
 * cleaned up head sep, rbuf problems
 *
 * Revision 1.62  1996/07/11  19:08:00  jimz
 * generalize reconstruction mechanism
 * allow raid1 reconstructs via copyback (done with array
 * quiesced, not online, therefore not disk-directed)
 *
 * Revision 1.61  1996/06/19  22:23:01  jimz
 * parity verification is now a layout-configurable thing
 * not all layouts currently support it (correctly, anyway)
 *
 * Revision 1.60  1996/06/19  17:53:48  jimz
 * move GetNumSparePUs, InstallSpareTable ops into layout switch
 *
 * Revision 1.59  1996/06/19  14:57:58  jimz
 * move layout-specific config parsing hooks into RF_LayoutSW_t
 * table in rf_layout.c
 *
 * Revision 1.58  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.57  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.56  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.55  1996/06/06  18:41:35  jimz
 * change interleaved declustering dag selection to an
 * interleaved-declustering-specific routine (so we can
 * use the partitioned mirror node)
 *
 * Revision 1.54  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.53  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.52  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.51  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.50  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.49  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.48  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.47  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.46  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.45  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.44  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.43  1996/02/22  16:46:35  amiri
 * modified chained declustering to use a seperate DAG selection routine
 *
 * Revision 1.42  1995/12/01  19:16:11  root
 * added copyright info
 *
 * Revision 1.41  1995/11/28  21:31:02  amiri
 * added Interleaved Declustering to switch table
 *
 * Revision 1.40  1995/11/20  14:35:17  arw
 * moved rf_StartThroughputStats in DefaultWrite and DefaultRead
 *
 * Revision 1.39  1995/11/19  16:28:46  wvcii
 * replaced LaunchDAGState with CreateDAGState, ExecuteDAGState
 *
 * Revision 1.38  1995/11/17  19:00:41  wvcii
 * added MapQ entries to switch table
 *
 * Revision 1.37  1995/11/17  16:58:13  amiri
 * Added the Chained Declustering architecture ('C'),
 * essentially a variant of mirroring.
 *
 * Revision 1.36  1995/11/16  16:16:10  amiri
 * Added RAID5 with rotated sparing ('R' configuration)
 *
 * Revision 1.35  1995/11/07  15:41:17  wvcii
 * modified state lists: DefaultStates, VSReadStates
 * necessary to support new states (LaunchDAGState, ProcessDAGState)
 *
 * Revision 1.34  1995/10/18  01:23:20  amiri
 * added ifndef SIMULATE wrapper around rf_StartThroughputStats()
 *
 * Revision 1.33  1995/10/13  15:05:46  arw
 * added rf_StartThroughputStats to DefaultRead and DefaultWrite
 *
 * Revision 1.32  1995/10/12  16:04:23  jimz
 * added config names to mapsw entires
 *
 * Revision 1.31  1995/10/04  03:57:48  wvcii
 * added raid level 1 to mapsw
 *
 * Revision 1.30  1995/09/07  01:26:55  jimz
 * Achive basic compilation in kernel. Kernel functionality
 * is not guaranteed at all, but it'll compile. Mostly. I hope.
 *
 * Revision 1.29  1995/07/28  21:43:42  robby
 * checkin after leaving for Rice. Bye
 *
 * Revision 1.28  1995/07/26  03:26:14  robby
 * *** empty log message ***
 *
 * Revision 1.27  1995/07/21  19:47:52  rachad
 * Added raid 0 /5 with caching architectures
 *
 * Revision 1.26  1995/07/21  19:29:27  robby
 * added virtual striping states
 *
 * Revision 1.25  1995/07/10  21:41:47  robby
 * switched to have my own virtual stripng write function from the cache
 *
 * Revision 1.24  1995/07/10  20:51:59  robby
 * added virtual striping states
 *
 * Revision 1.23  1995/07/10  16:57:42  robby
 * updated alloclistelem struct to the correct struct name
 *
 * Revision 1.22  1995/07/08  20:06:11  rachad
 * *** empty log message ***
 *
 * Revision 1.21  1995/07/08  19:43:16  cfb
 * *** empty log message ***
 *
 * Revision 1.20  1995/07/08  18:05:39  rachad
 * Linked up Claudsons code with the real cache
 *
 * Revision 1.19  1995/07/06  14:29:36  robby
 * added defaults states list to the layout switch
 *
 * Revision 1.18  1995/06/23  13:40:34  robby
 * updeated to prototypes in rf_layout.h
 *
 */

d49 1
a49 1
#endif /* RF_INCLUDE_RAID5_RS > 0 */
d52 1
a52 1
#endif /* RF_INCLUDE_CHAINDECLUSTER > 0 */
d55 1
a55 1
#endif /* RF_INCLUDE_INTERDECLUSTER > 0 */
d58 1
a58 1
#endif /* RF_INCLUDE_PARITYLOGGING > 0 */
d61 1
a61 1
#endif /* RF_INCLUDE_EVENODD > 0 */
d81 1
a81 2
	rf_CleanupState, rf_LastState};

d83 1
a83 1
/* XXX Gross hack to shutup gcc -- it complains that DefaultStates is not 
d92 2
a93 2
int distSpareYes = 1;
int distSpareNo  = 0;
d96 1
a96 1
static int distSpareNo  = 0;
d98 1
a98 1
#ifdef KERNEL
d100 1
a100 1
#else /* KERNEL */
d102 1
a102 1
#endif /* KERNEL */
d106 1
a106 1
#else /* RF_UTILITY > 0 */
d108 1
a108 1
#endif /* RF_UTILITY > 0 */
d113 15
a127 15
	RF_NK2(rf_MakeLayoutSpecificDeclustered, &distSpareNo)
	RF_NU(
	rf_ConfigureDeclustered,
	rf_MapSectorDeclustered, rf_MapParityDeclustered, NULL,
	rf_IdentifyStripeDeclustered,
	rf_RaidFiveDagSelect,
	rf_MapSIDToPSIDDeclustered,
	rf_GetDefaultHeadSepLimitDeclustered,
	rf_GetDefaultNumFloatingReconBuffersDeclustered,
	NULL, NULL,
	rf_SubmitReconBufferBasic,
	rf_VerifyParityBasic,
	1,
	DefaultStates,
	0)
d132 15
a146 15
	RF_NK2(rf_MakeLayoutSpecificDeclustered, &distSpareYes)
	RF_NU(
	rf_ConfigureDeclusteredDS,
	rf_MapSectorDeclustered, rf_MapParityDeclustered, NULL,
	rf_IdentifyStripeDeclustered,
	rf_RaidFiveDagSelect,
	rf_MapSIDToPSIDDeclustered,
	rf_GetDefaultHeadSepLimitDeclustered,
	rf_GetDefaultNumFloatingReconBuffersDeclustered,
	rf_GetNumSpareRUsDeclustered, rf_InstallSpareTable,
	rf_SubmitReconBufferBasic,
	rf_VerifyParityBasic,
	1,
	DefaultStates,
	RF_DISTRIBUTE_SPARE|RF_BD_DECLUSTERED)
d152 15
a166 15
	RF_NK2(rf_MakeLayoutSpecificDeclustered, &distSpareNo)
	RF_NU(
	rf_ConfigureDeclusteredPQ,
	rf_MapSectorDeclusteredPQ, rf_MapParityDeclusteredPQ, rf_MapQDeclusteredPQ,
	rf_IdentifyStripeDeclusteredPQ,
	rf_PQDagSelect,
	rf_MapSIDToPSIDDeclustered,
	rf_GetDefaultHeadSepLimitDeclustered,
	rf_GetDefaultNumFloatingReconBuffersPQ,
	NULL, NULL,
	NULL,
	rf_VerifyParityBasic,
	2,
	DefaultStates,
	0)
d168 1
a168 1
#endif /* RF_INCLUDE_DECL_PQ > 0 */
d173 15
a187 15
	RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
	RF_NU(
	rf_ConfigureRAID5_RS,
	rf_MapSectorRAID5_RS, rf_MapParityRAID5_RS, NULL,
	rf_IdentifyStripeRAID5_RS,
	rf_RaidFiveDagSelect,
	rf_MapSIDToPSIDRAID5_RS,
	rf_GetDefaultHeadSepLimitRAID5,
	rf_GetDefaultNumFloatingReconBuffersRAID5,
	rf_GetNumSpareRUsRAID5_RS, NULL,
	rf_SubmitReconBufferBasic,
	rf_VerifyParityBasic,
	1,
	DefaultStates,
	RF_DISTRIBUTE_SPARE)
d189 1
a189 1
#endif /* RF_INCLUDE_RAID5_RS > 0 */
d194 15
a208 15
	RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
	RF_NU(
	rf_ConfigureChainDecluster,
	rf_MapSectorChainDecluster, rf_MapParityChainDecluster, NULL,
	rf_IdentifyStripeChainDecluster,
	rf_RAIDCDagSelect,
	rf_MapSIDToPSIDChainDecluster,
	NULL,
	NULL,
	rf_GetNumSpareRUsChainDecluster, NULL,
	rf_SubmitReconBufferBasic,
	rf_VerifyParityBasic,
	1,
	DefaultStates,
	0)
d210 1
a210 1
#endif /* RF_INCLUDE_CHAINDECLUSTER > 0 */
d215 15
a229 15
	RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
	RF_NU(
	rf_ConfigureInterDecluster,
	rf_MapSectorInterDecluster, rf_MapParityInterDecluster, NULL,
	rf_IdentifyStripeInterDecluster,
	rf_RAIDIDagSelect,
	rf_MapSIDToPSIDInterDecluster,
	rf_GetDefaultHeadSepLimitInterDecluster,
	rf_GetDefaultNumFloatingReconBuffersInterDecluster,
	rf_GetNumSpareRUsInterDecluster, NULL,
	rf_SubmitReconBufferBasic,
	rf_VerifyParityBasic,
	1,
	DefaultStates,
	RF_DISTRIBUTE_SPARE)
d231 1
a231 1
#endif /* RF_INCLUDE_INTERDECLUSTER > 0 */
d236 15
a250 15
	RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
	RF_NU(
	rf_ConfigureRAID0,
	rf_MapSectorRAID0, rf_MapParityRAID0, NULL,
	rf_IdentifyStripeRAID0,
	rf_RAID0DagSelect,
	rf_MapSIDToPSIDRAID0,
	NULL,
	NULL,
	NULL, NULL,
	NULL,
	rf_VerifyParityRAID0,
	0,
	DefaultStates,
	0)
d252 1
a252 1
#endif /* RF_INCLUDE_RAID0 > 0 */
d257 15
a271 15
	RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
	RF_NU(
	rf_ConfigureRAID1,
	rf_MapSectorRAID1, rf_MapParityRAID1, NULL,
	rf_IdentifyStripeRAID1,
	rf_RAID1DagSelect,
	rf_MapSIDToPSIDRAID1,
	NULL,
	NULL,
	NULL, NULL,
	rf_SubmitReconBufferRAID1,
	rf_VerifyParityRAID1,
	1,
	DefaultStates,
	0)
d273 1
a273 1
#endif /* RF_INCLUDE_RAID1 > 0 */
d278 15
a292 15
	RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
	RF_NU(
	rf_ConfigureRAID4,
	rf_MapSectorRAID4, rf_MapParityRAID4, NULL,
	rf_IdentifyStripeRAID4,
	rf_RaidFiveDagSelect,
	rf_MapSIDToPSIDRAID4,
	rf_GetDefaultHeadSepLimitRAID4,
	rf_GetDefaultNumFloatingReconBuffersRAID4,
	NULL, NULL,
	rf_SubmitReconBufferBasic,
	rf_VerifyParityBasic,
	1,
	DefaultStates,
	0)
d294 1
a294 1
#endif /* RF_INCLUDE_RAID4 > 0 */
d299 15
a313 15
	RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
	RF_NU(
	rf_ConfigureRAID5,
	rf_MapSectorRAID5, rf_MapParityRAID5, NULL,
	rf_IdentifyStripeRAID5,
	rf_RaidFiveDagSelect,
	rf_MapSIDToPSIDRAID5,
	rf_GetDefaultHeadSepLimitRAID5,
	rf_GetDefaultNumFloatingReconBuffersRAID5,
	NULL, NULL,
	rf_SubmitReconBufferBasic,
	rf_VerifyParityBasic,
	1,
	DefaultStates,
	0)
d315 1
a315 1
#endif /* RF_INCLUDE_RAID5 > 0 */
d320 15
a334 15
	RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
	RF_NU(
	rf_ConfigureEvenOdd,
	rf_MapSectorRAID5, rf_MapParityEvenOdd, rf_MapEEvenOdd, 
	rf_IdentifyStripeEvenOdd,
	rf_EODagSelect,
	rf_MapSIDToPSIDRAID5,
	NULL,
	NULL,
	NULL, NULL,
	NULL, /* no reconstruction, yet */
	rf_VerifyParityEvenOdd,
	2,
	DefaultStates,
	0)
d336 1
a336 1
#endif /* RF_INCLUDE_EVENODD > 0 */
d341 15
a355 15
	RF_NK2(rf_MakeLayoutSpecificDeclustered, &distSpareNo)
	RF_NU(
	rf_ConfigureDeclusteredPQ,
	rf_MapSectorDeclusteredPQ, rf_MapParityDeclusteredPQ, rf_MapQDeclusteredPQ,
	rf_IdentifyStripeDeclusteredPQ,
	rf_EODagSelect,
	rf_MapSIDToPSIDRAID5,
	rf_GetDefaultHeadSepLimitDeclustered,
	rf_GetDefaultNumFloatingReconBuffersPQ,
	NULL, NULL,
	NULL, /* no reconstruction, yet */
	rf_VerifyParityEvenOdd,
	2,
	DefaultStates,
	0)
d357 1
a357 1
#endif /* RF_INCLUDE_EVENODD > 0 */
d362 15
a376 15
	RF_NK2(rf_MakeLayoutSpecificNULL, NULL)
	RF_NU(
	rf_ConfigureParityLogging,
	rf_MapSectorParityLogging, rf_MapParityParityLogging, NULL,
	rf_IdentifyStripeParityLogging,
	rf_ParityLoggingDagSelect,
	rf_MapSIDToPSIDParityLogging,
	rf_GetDefaultHeadSepLimitParityLogging,
	rf_GetDefaultNumFloatingReconBuffersParityLogging,
	NULL, NULL,
	rf_SubmitReconBufferBasic,
	NULL,
	1,
	DefaultStates,
	0)
d378 1
a378 1
#endif /* RF_INCLUDE_PARITYLOGGING > 0 */
d381 16
a396 16
	{ '\0', NULL,
	RF_NK2(NULL, NULL)
	RF_NU(
	NULL,
	NULL, NULL, NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL, NULL,
	NULL,
	NULL,
	0,
	NULL,
	0)
d400 2
a401 1
RF_LayoutSW_t *rf_GetLayout(RF_ParityConfig_t parityConfig)
d403 1
a403 1
  RF_LayoutSW_t *p;
d405 8
a412 8
  /* look up the specific layout */
  for (p=&mapsw[0]; p->parityConfig; p++) 
    if (p->parityConfig == parityConfig)
      break;
  if (!p->parityConfig)
    return(NULL);
  RF_ASSERT(p->parityConfig == parityConfig);
  return(p);
a413 1

d417 1
a417 1
 * ConfigureLayout -- 
d424 5
a428 4
int rf_ConfigureLayout(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
d430 26
a455 56
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  RF_ParityConfig_t parityConfig;
  RF_LayoutSW_t *p;
  int retval;

  layoutPtr->sectorsPerStripeUnit = cfgPtr->sectPerSU;
  layoutPtr->SUsPerPU             = cfgPtr->SUsPerPU;
  layoutPtr->SUsPerRU             = cfgPtr->SUsPerRU;
  parityConfig                    = cfgPtr->parityConfig;
    
  layoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk / layoutPtr->sectorsPerStripeUnit;

  p = rf_GetLayout(parityConfig);
  if (p == NULL) {
    RF_ERRORMSG1("Unknown parity configuration '%c'", parityConfig);
    return(EINVAL);
  }
  RF_ASSERT(p->parityConfig == parityConfig);
  layoutPtr->map = p;

  /* initialize the specific layout */

  retval = (p->Configure)(listp, raidPtr, cfgPtr);

  if (retval)
    return(retval);

  layoutPtr->dataBytesPerStripe = layoutPtr->dataSectorsPerStripe << raidPtr->logBytesPerSector;
  raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;

  if (rf_forceNumFloatingReconBufs >= 0) {
    raidPtr->numFloatingReconBufs = rf_forceNumFloatingReconBufs;
  }
  else {
    raidPtr->numFloatingReconBufs = rf_GetDefaultNumFloatingReconBuffers(raidPtr);
  }

  if (rf_forceHeadSepLimit >= 0) {
    raidPtr->headSepLimit = rf_forceHeadSepLimit;
  }
  else {
    raidPtr->headSepLimit = rf_GetDefaultHeadSepLimit(raidPtr);
  }

  printf("RAIDFRAME: Configure (%s): total number of sectors is %lu (%lu MB)\n",
     layoutPtr->map->configName,
     (unsigned long)raidPtr->totalSectors,
     (unsigned long)(raidPtr->totalSectors / 1024 * (1<<raidPtr->logBytesPerSector) / 1024));
  if (raidPtr->headSepLimit >= 0) {
    printf("RAIDFRAME(%s): Using %ld floating recon bufs with head sep limit %ld\n",
      layoutPtr->map->configName, (long)raidPtr->numFloatingReconBufs, (long)raidPtr->headSepLimit);
  }
  else {
    printf("RAIDFRAME(%s): Using %ld floating recon bufs with no head sep limit\n",
      layoutPtr->map->configName, (long)raidPtr->numFloatingReconBufs);
  }
d457 28
a484 1
  return(0);
d494 5
a498 4
RF_StripeNum_t rf_MapStripeIDToParityStripeID(layoutPtr, stripeID, which_ru)
  RF_RaidLayout_t    *layoutPtr;
  RF_StripeNum_t      stripeID;
  RF_ReconUnitNum_t  *which_ru;
d500 1
a500 1
  RF_StripeNum_t parityStripeID;
d502 8
a509 9
  /* quick exit in the common case of SUsPerPU==1 */
  if ((layoutPtr->SUsPerPU == 1) || !layoutPtr->map->MapSIDToPSID) {
    *which_ru = 0;
    return(stripeID);
  }
  else {
    (layoutPtr->map->MapSIDToPSID)(layoutPtr, stripeID, &parityStripeID, which_ru);
  }
  return(parityStripeID);
d511 1
a511 1
#endif /* RF_UTILITY == 0 */
@

