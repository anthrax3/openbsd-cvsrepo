head	1.14;
access;
symbols
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.12
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.10
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.6
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.22
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.20
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.18
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.16
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.14
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.12
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.10
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.8
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.6
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.4
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.10
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.9.0.8
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.6
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.13;

1.13
date	2011.06.21.16.46.00;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.09.15.10.20;	author tdeval;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.08.16.07.40;	author peter;	state Exp;
branches
	1.9.8.1;
next	1.8;

1.8
date	2000.01.11.18.02.21;	author peter;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.01.08.20.57.12;	author peter;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.07.14.50.21;	author peter;	state Exp;
branches;
next	1.5;

1.5
date	99.08.04.13.10.54;	author peter;	state Exp;
branches;
next	1.4;

1.4
date	99.08.03.13.56.37;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.41;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.18;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.26.11;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.9.8.1
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.9.8.2;

1.9.8.2
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_driver.c,v 1.13 2011/06/21 16:46:00 tedu Exp $	*/
/*	$NetBSD: rf_driver.c,v 1.37 2000/06/04 02:05:13 oster Exp $	*/

/*
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Greg Oster
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author:	Mark Holland, Khalil Amiri, Claudson Bornstein,
 *		William V. Courtright II, Robby Findler, Daniel Stodolsky,
 *		Rachad Youssef, Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 *
 * rf_driver.c -- Main setup, teardown, and access routines for the RAID
 *		  driver
 *
 * All routines are prefixed with rf_ (RAIDframe), to avoid conficts.
 *
 *****************************************************************************/

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#ifdef	__NetBSD__
#include <sys/vnode.h>
#endif


#include "rf_archs.h"
#include "rf_threadstuff.h"


#include <sys/errno.h>

#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_aselect.h"
#include "rf_diskqueue.h"
#include "rf_parityscan.h"
#include "rf_alloclist.h"
#include "rf_dagutils.h"
#include "rf_utils.h"
#include "rf_etimer.h"
#include "rf_acctrace.h"
#include "rf_configure.h"
#include "rf_general.h"
#include "rf_desc.h"
#include "rf_states.h"
#include "rf_freelist.h"
#include "rf_decluster.h"
#include "rf_map.h"
#include "rf_revent.h"
#include "rf_callback.h"
#include "rf_engine.h"
#include "rf_memchunk.h"
#include "rf_mcpair.h"
#include "rf_nwayxor.h"
#include "rf_debugprint.h"
#include "rf_copyback.h"
#include "rf_driver.h"
#include "rf_options.h"
#include "rf_shutdown.h"
#include "rf_kintf.h"

#include <sys/buf.h>

/* rad == RF_RaidAccessDesc_t */
static RF_FreeList_t *rf_rad_freelist;
#define	RF_MAX_FREE_RAD		128
#define	RF_RAD_INC		 16
#define	RF_RAD_INITIAL		 32

/* Debug variables. */
char	rf_panicbuf[2048];	/*
				 * A buffer to hold an error msg when we panic.
				 */

/* Main configuration routines. */
static int raidframe_booted = 0;

void rf_ConfigureDebug(RF_Config_t *);
void rf_set_debug_option(char *, long);
void rf_UnconfigureArray(void);
int  rf_init_rad(RF_RaidAccessDesc_t *);
void rf_clean_rad(RF_RaidAccessDesc_t *);
void rf_ShutdownRDFreeList(void *);
int  rf_ConfigureRDFreeList(RF_ShutdownList_t **);

RF_DECLARE_MUTEX(rf_printf_mutex);	/*
					 * Debug only: Avoids interleaved
					 * printfs by different stripes.
					 */

#define	SIGNAL_QUIESCENT_COND(_raid_)	wakeup(&((_raid_)->accesses_suspended))
#define	WAIT_FOR_QUIESCENCE(_raid_)					\
	tsleep(&((_raid_)->accesses_suspended), PRIBIO, "RAIDframe quiesce", 0);

#define	IO_BUF_ERR(bp, err)						\
do {									\
	bp->b_flags |= B_ERROR;						\
	bp->b_resid = bp->b_bcount;					\
	bp->b_error = err;						\
	biodone(bp);							\
} while (0)

static int configureCount = 0;	/* Number of active configurations. */
static int isconfigged = 0;	/*
				 * Is basic RAIDframe (non per-array)
				 * stuff configured ?
				 */
RF_DECLARE_STATIC_MUTEX(configureMutex);	/*
						 * Used to lock the
						 * configuration stuff.
						 */
static RF_ShutdownList_t *globalShutdown;	/* Non array-specific stuff. */
int  rf_ConfigureRDFreeList(RF_ShutdownList_t **);


/* Called at system boot time. */
int
rf_BootRaidframe(void)
{
	int rc;

	if (raidframe_booted)
		return (EBUSY);
	raidframe_booted = 1;

	rc = rf_mutex_init(&configureMutex);
	if (rc) {
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n",
		    __FILE__, __LINE__, rc);
		RF_PANIC();
	}
	configureCount = 0;
	isconfigged = 0;
	globalShutdown = NULL;
	return (0);
}


/*
 * This function is really just for debugging user-level stuff: It
 * frees up all memory, other RAIDframe resources that might otherwise
 * be kept around. This is used with systems like "sentinel" to detect
 * memory leaks.
 */
int
rf_UnbootRaidframe(void)
{
	int rc;

	RF_LOCK_MUTEX(configureMutex);
	if (configureCount) {
		RF_UNLOCK_MUTEX(configureMutex);
		return (EBUSY);
	}
	raidframe_booted = 0;
	RF_UNLOCK_MUTEX(configureMutex);
	rc = rf_mutex_destroy(&configureMutex);
	if (rc) {
		RF_ERRORMSG3("Unable to destroy mutex file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
		RF_PANIC();
	}
	return (0);
}


/*
 * Called whenever an array is shutdown.
 */
void
rf_UnconfigureArray(void)
{
	int rc;

	RF_LOCK_MUTEX(configureMutex);
	if (--configureCount == 0) {	/*
					 * If no active configurations, shut
					 * everything down.
					 */
		isconfigged = 0;

		rc = rf_ShutdownList(&globalShutdown);
		if (rc) {
			RF_ERRORMSG1("RAIDFRAME: unable to do global shutdown,"
			    " rc=%d.\n", rc);
		}

		/*
		 * We must wait until now, because the AllocList module
		 * uses the DebugMem module.
		 */
		if (rf_memDebug)
			rf_print_unfreed();
	}
	RF_UNLOCK_MUTEX(configureMutex);
}


/*
 * Called to shut down an array.
 */
int
rf_Shutdown(RF_Raid_t *raidPtr)
{
	if (!raidPtr->valid) {
		RF_ERRORMSG("Attempt to shut down unconfigured RAIDframe"
		    " driver. Aborting shutdown.\n");
		return (EINVAL);
	}
	/*
	 * Wait for outstanding IOs to land.
	 * As described in rf_raid.h, we use the rad_freelist lock
	 * to protect the per-array info about outstanding descs,
	 * since we need to do freelist locking anyway, and this
	 * cuts down on the amount of serialization we've got going
	 * on.
	 */
	RF_FREELIST_DO_LOCK(rf_rad_freelist);
	if (raidPtr->waitShutdown) {
		RF_FREELIST_DO_UNLOCK(rf_rad_freelist);
		return (EBUSY);
	}
	raidPtr->waitShutdown = 1;
	while (raidPtr->nAccOutstanding) {
		RF_WAIT_COND(raidPtr->outstandingCond, RF_FREELIST_MUTEX_OF(rf_rad_freelist));
	}
	RF_FREELIST_DO_UNLOCK(rf_rad_freelist);

	/* Wait for any parity re-writes to stop... */
	while (raidPtr->parity_rewrite_in_progress) {
		printf("Waiting for parity re-write to exit...\n");
		tsleep(&raidPtr->parity_rewrite_in_progress, PRIBIO,
		       "rfprwshutdown", 0);
	}

	raidPtr->valid = 0;

	rf_update_component_labels(raidPtr, RF_FINAL_COMPONENT_UPDATE);

	rf_UnconfigureVnodes(raidPtr);

	rf_ShutdownList(&raidPtr->shutdownList);

	rf_UnconfigureArray();

	return (0);
}

#define	DO_INIT_CONFIGURE(f)						\
do {									\
	rc = f (&globalShutdown);					\
	if (rc) {							\
		RF_ERRORMSG2("RAIDFRAME: failed %s with %d.\n",		\
		    RF_STRING(f), rc);					\
		rf_ShutdownList(&globalShutdown);			\
		configureCount--;					\
		RF_UNLOCK_MUTEX(configureMutex);			\
		return(rc);						\
	}								\
} while (0)

#define	DO_RAID_FAIL()							\
do {									\
	rf_UnconfigureVnodes(raidPtr);					\
	rf_ShutdownList(&raidPtr->shutdownList);			\
	rf_UnconfigureArray();						\
} while (0)

#define	DO_RAID_INIT_CONFIGURE(f)					\
do {									\
	rc = (f)(&raidPtr->shutdownList, raidPtr, cfgPtr);		\
	if (rc) {							\
		RF_ERRORMSG2("RAIDFRAME: failed %s with %d.\n",		\
		    RF_STRING(f), rc);					\
		DO_RAID_FAIL();						\
		return(rc);						\
	}								\
} while (0)

#define	DO_RAID_MUTEX(_m_)						\
do {									\
	rc = rf_create_managed_mutex(&raidPtr->shutdownList, (_m_));	\
	if (rc) {							\
		RF_ERRORMSG3("Unable to init mutex file %s line %d"	\
		    " rc=%d.\n", __FILE__, __LINE__, rc);		\
		DO_RAID_FAIL();						\
		return(rc);						\
	}								\
} while (0)

#define	DO_RAID_COND(_c_)						\
do {									\
	rc = rf_create_managed_cond(&raidPtr->shutdownList, (_c_));	\
	if (rc) {							\
		RF_ERRORMSG3("Unable to init cond file %s line %d"	\
		    " rc=%d.\n", __FILE__, __LINE__, rc);		\
		DO_RAID_FAIL();						\
		return(rc);						\
	}								\
} while (0)

int
rf_Configure(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr, RF_AutoConfig_t *ac)
{
	RF_RowCol_t row, col;
	int i, rc;

	/*
	 * XXX This check can probably be removed now, since
	 * RAIDFRAME_CONFIGURE now checks to make sure that the
	 * RAID set is not already valid.
	 */
	if (raidPtr->valid) {
		RF_ERRORMSG("RAIDframe configuration not shut down."
		    " Aborting configure.\n");
		return (EINVAL);
	}
	RF_LOCK_MUTEX(configureMutex);
	configureCount++;
	if (isconfigged == 0) {
		rc = rf_create_managed_mutex(&globalShutdown, &rf_printf_mutex);
		if (rc) {
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			    " rc=%d.\n", __FILE__, __LINE__, rc);
			rf_ShutdownList(&globalShutdown);
			return (rc);
		}
		/* Initialize globals. */
#ifdef	RAIDDEBUG
		printf("RAIDFRAME: protectedSectors is %ld.\n",
		       rf_protectedSectors);
#endif	/* RAIDDEBUG */

		rf_clear_debug_print_buffer();

		DO_INIT_CONFIGURE(rf_ConfigureAllocList);

		/*
		 * Yes, this does make debugging general to the whole
		 * system instead of being array specific. Bummer, drag.
		 */
		rf_ConfigureDebug(cfgPtr);
		DO_INIT_CONFIGURE(rf_ConfigureDebugMem);
		DO_INIT_CONFIGURE(rf_ConfigureAccessTrace);
		DO_INIT_CONFIGURE(rf_ConfigureMapModule);
		DO_INIT_CONFIGURE(rf_ConfigureReconEvent);
		DO_INIT_CONFIGURE(rf_ConfigureCallback);
		DO_INIT_CONFIGURE(rf_ConfigureMemChunk);
		DO_INIT_CONFIGURE(rf_ConfigureRDFreeList);
		DO_INIT_CONFIGURE(rf_ConfigureNWayXor);
		DO_INIT_CONFIGURE(rf_ConfigureStripeLockFreeList);
		DO_INIT_CONFIGURE(rf_ConfigureMCPair);
		DO_INIT_CONFIGURE(rf_ConfigureDAGs);
		DO_INIT_CONFIGURE(rf_ConfigureDAGFuncs);
		DO_INIT_CONFIGURE(rf_ConfigureDebugPrint);
		DO_INIT_CONFIGURE(rf_ConfigureReconstruction);
		DO_INIT_CONFIGURE(rf_ConfigureCopyback);
		DO_INIT_CONFIGURE(rf_ConfigureDiskQueueSystem);
		isconfigged = 1;
	}
	RF_UNLOCK_MUTEX(configureMutex);

	DO_RAID_MUTEX(&raidPtr->mutex);
	/*
	 * Set up the cleanup list. Do this after ConfigureDebug so that
	 * value of memDebug will be set.
	 */

	rf_MakeAllocList(raidPtr->cleanupList);
	if (raidPtr->cleanupList == NULL) {
		DO_RAID_FAIL();
		return (ENOMEM);
	}
	rc = rf_ShutdownCreate(&raidPtr->shutdownList,
	    (void (*) (void *)) rf_FreeAllocList, raidPtr->cleanupList);
	if (rc) {
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
		DO_RAID_FAIL();
		return (rc);
	}
	raidPtr->numRow = cfgPtr->numRow;
	raidPtr->numCol = cfgPtr->numCol;
	raidPtr->numSpare = cfgPtr->numSpare;

	/*
	 * XXX We don't even pretend to support more than one row in the
	 * kernel...
	 */
	if (raidPtr->numRow != 1) {
		RF_ERRORMSG("Only one row supported in kernel.\n");
		DO_RAID_FAIL();
		return (EINVAL);
	}
	RF_CallocAndAdd(raidPtr->status, raidPtr->numRow,
	    sizeof(RF_RowStatus_t), (RF_RowStatus_t *), raidPtr->cleanupList);
	if (raidPtr->status == NULL) {
		DO_RAID_FAIL();
		return (ENOMEM);
	}
	RF_CallocAndAdd(raidPtr->reconControl, raidPtr->numRow,
	    sizeof(RF_ReconCtrl_t *), (RF_ReconCtrl_t **), raidPtr->cleanupList);
	if (raidPtr->reconControl == NULL) {
		DO_RAID_FAIL();
		return (ENOMEM);
	}
	for (i = 0; i < raidPtr->numRow; i++) {
		raidPtr->status[i] = rf_rs_optimal;
		raidPtr->reconControl[i] = NULL;
	}

	DO_RAID_INIT_CONFIGURE(rf_ConfigureEngine);
	DO_RAID_INIT_CONFIGURE(rf_ConfigureStripeLocks);

	DO_RAID_COND(&raidPtr->outstandingCond);

	raidPtr->nAccOutstanding = 0;
	raidPtr->waitShutdown = 0;

	DO_RAID_MUTEX(&raidPtr->access_suspend_mutex);
	DO_RAID_COND(&raidPtr->quiescent_cond);

	DO_RAID_COND(&raidPtr->waitForReconCond);

	DO_RAID_MUTEX(&raidPtr->recon_done_proc_mutex);

	if (ac != NULL) {
		/*
		 * We have an AutoConfig structure... Don't do the
		 * normal disk configuration... call the auto config
		 * stuff.
		 */
		rf_AutoConfigureDisks(raidPtr, cfgPtr, ac);
	} else {
		DO_RAID_INIT_CONFIGURE(rf_ConfigureDisks);
		DO_RAID_INIT_CONFIGURE(rf_ConfigureSpareDisks);
	}
	/*
	 * Do this after ConfigureDisks & ConfigureSpareDisks to be sure
	 * devno is set.
	 */
	DO_RAID_INIT_CONFIGURE(rf_ConfigureDiskQueues);

	DO_RAID_INIT_CONFIGURE(rf_ConfigureLayout);

	DO_RAID_INIT_CONFIGURE(rf_ConfigurePSStatus);

	for (row = 0; row < raidPtr->numRow; row++) {
		for (col = 0; col < raidPtr->numCol; col++) {
			/*
			 * XXX Better distribution.
			 */
			raidPtr->hist_diskreq[row][col] = 0;
		}
	}

	raidPtr->numNewFailures = 0;
	raidPtr->copyback_in_progress = 0;
	raidPtr->parity_rewrite_in_progress = 0;
	raidPtr->recon_in_progress = 0;
	raidPtr->maxOutstanding = cfgPtr->maxOutstandingDiskReqs;

	/*
	 * Autoconfigure and root_partition will actually get filled in
	 * after the config is done.
	 */
	raidPtr->autoconfigure = 0;
	raidPtr->root_partition = 0;
	raidPtr->last_unit = raidPtr->raidid;
	raidPtr->config_order = 0;

	if (rf_keepAccTotals) {
		raidPtr->keep_acc_totals = 1;
	}
	rf_StartUserStats(raidPtr);

	raidPtr->valid = 1;
	return (0);
}

int
rf_init_rad(RF_RaidAccessDesc_t *desc)
{
	int rc;

	rc = rf_mutex_init(&desc->mutex);
	if (rc) {
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n", __FILE__,
		    __LINE__, rc);
		return (rc);
	}
	rc = rf_cond_init(&desc->cond);
	if (rc) {
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d.\n", __FILE__,
		    __LINE__, rc);
		rf_mutex_destroy(&desc->mutex);
		return (rc);
	}
	return (0);
}

void
rf_clean_rad(RF_RaidAccessDesc_t *desc)
{
	rf_mutex_destroy(&desc->mutex);
	rf_cond_destroy(&desc->cond);
}

void
rf_ShutdownRDFreeList(void *ignored)
{
	RF_FREELIST_DESTROY_CLEAN(rf_rad_freelist, next,
	    (RF_RaidAccessDesc_t *), rf_clean_rad);
}

int
rf_ConfigureRDFreeList(RF_ShutdownList_t **listp)
{
	int rc;

	RF_FREELIST_CREATE(rf_rad_freelist, RF_MAX_FREE_RAD,
	    RF_RAD_INC, sizeof(RF_RaidAccessDesc_t));
	if (rf_rad_freelist == NULL) {
		return (ENOMEM);
	}
	rc = rf_ShutdownCreate(listp, rf_ShutdownRDFreeList, NULL);
	if (rc) {
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d.\n", __FILE__,
		    __LINE__, rc);
		rf_ShutdownRDFreeList(NULL);
		return (rc);
	}
	RF_FREELIST_PRIME_INIT(rf_rad_freelist, RF_RAD_INITIAL, next,
	    (RF_RaidAccessDesc_t *), rf_init_rad);
	return (0);
}

RF_RaidAccessDesc_t *
rf_AllocRaidAccDesc(
    RF_Raid_t			 *raidPtr,
    RF_IoType_t			  type,
    RF_RaidAddr_t		  raidAddress,
    RF_SectorCount_t		  numBlocks,
    caddr_t			  bufPtr,
    void			 *bp,
    RF_DagHeader_t		**paramDAG,
    RF_AccessStripeMapHeader_t	**paramASM,
    RF_RaidAccessFlags_t	  flags,
    void			(*cbF) (struct buf *),
    void			 *cbA,
    RF_AccessState_t		 *states
)
{
	RF_RaidAccessDesc_t *desc;

	RF_FREELIST_GET_INIT_NOUNLOCK(rf_rad_freelist, desc, next,
	    (RF_RaidAccessDesc_t *), rf_init_rad);
	if (raidPtr->waitShutdown) {
		/*
		 * Actually, we're shutting the array down. Free the desc
		 * and return NULL.
		 */
		RF_FREELIST_DO_UNLOCK(rf_rad_freelist);
		RF_FREELIST_FREE_CLEAN(rf_rad_freelist, desc, next,
		    rf_clean_rad);
		return (NULL);
	}
	raidPtr->nAccOutstanding++;
	RF_FREELIST_DO_UNLOCK(rf_rad_freelist);

	desc->raidPtr = (void *) raidPtr;
	desc->type = type;
	desc->raidAddress = raidAddress;
	desc->numBlocks = numBlocks;
	desc->bufPtr = bufPtr;
	desc->bp = bp;
	desc->paramDAG = paramDAG;
	desc->paramASM = paramASM;
	desc->flags = flags;
	desc->states = states;
	desc->state = 0;

	desc->status = 0;
	bzero(&desc->tracerec, sizeof(RF_AccTraceEntry_t));
	desc->callbackFunc = (void (*) (RF_CBParam_t)) cbF;	/* XXX */
	desc->callbackArg = cbA;
	desc->next = NULL;
	desc->head = desc;
	desc->numPending = 0;
	desc->cleanupList = NULL;
	rf_MakeAllocList(desc->cleanupList);
	return (desc);
}

void
rf_FreeRaidAccDesc(RF_RaidAccessDesc_t * desc)
{
	RF_Raid_t *raidPtr = desc->raidPtr;

	RF_ASSERT(desc);

	rf_FreeAllocList(desc->cleanupList);
	RF_FREELIST_FREE_CLEAN_NOUNLOCK(rf_rad_freelist, desc, next, rf_clean_rad);
	raidPtr->nAccOutstanding--;
	if (raidPtr->waitShutdown) {
		RF_SIGNAL_COND(raidPtr->outstandingCond);
	}
	RF_FREELIST_DO_UNLOCK(rf_rad_freelist);
}


/********************************************************************
 * Main routine for performing an access.
 * Accesses are retried until a DAG can not be selected. This occurs
 * when either the DAG library is incomplete or there are too many
 * failures in a parity group.
 ********************************************************************/
int
rf_DoAccess(
    RF_Raid_t			 *raidPtr,
    RF_IoType_t			  type,		/* Should be read or write. */
    int				  async_flag,	/*
						 * Should be RF_TRUE
						 * or RF_FALSE.
						 */
    RF_RaidAddr_t		  raidAddress,
    RF_SectorCount_t		  numBlocks,
    caddr_t			  bufPtr,
    void			 *bp_in,	/*
						 * It's a buf pointer.
						 * void * to facilitate
						 * ignoring it outside
						 * the kernel.
						 */
    RF_DagHeader_t		**paramDAG,
    RF_AccessStripeMapHeader_t	**paramASM,
    RF_RaidAccessFlags_t	  flags,
    RF_RaidAccessDesc_t		**paramDesc,
    void			(*cbF) (struct buf *),
    void			 *cbA
)
{
	RF_RaidAccessDesc_t *desc;
	caddr_t lbufPtr = bufPtr;
	struct buf *bp = (struct buf *) bp_in;

	raidAddress += rf_raidSectorOffset;

	if (!raidPtr->valid) {
		RF_ERRORMSG("RAIDframe driver not successfully configured."
		    " Rejecting access.\n");
		IO_BUF_ERR(bp, EINVAL);
		return (EINVAL);
	}

	if (rf_accessDebug) {

		printf("logBytes is: %d %d %d.\n", raidPtr->raidid,
		    raidPtr->logBytesPerSector,
		    (int) rf_RaidAddressToByte(raidPtr, numBlocks));
		printf("raid%d: %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx.\n", raidPtr->raidid,
		    (type == RF_IO_TYPE_READ) ? "READ" : "WRITE", (int) raidAddress,
		    (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress),
		    (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress + numBlocks - 1),
		    (int) numBlocks,
		    (int) rf_RaidAddressToByte(raidPtr, numBlocks),
		    (long) bufPtr);
	}
	if (raidAddress + numBlocks > raidPtr->totalSectors) {

		printf("DoAccess: raid addr %lu too large to access %lu sectors. Max legal addr is %lu.\n",
		    (u_long) raidAddress, (u_long) numBlocks, (u_long) raidPtr->totalSectors);

			IO_BUF_ERR(bp, ENOSPC);
			return (ENOSPC);
	}
	desc = rf_AllocRaidAccDesc(raidPtr, type, raidAddress,
	    numBlocks, lbufPtr, bp, paramDAG, paramASM,
	    flags, cbF, cbA, raidPtr->Layout.map->states);

	if (desc == NULL) {
		return (ENOMEM);
	}
	RF_ETIMER_START(desc->tracerec.tot_timer);

	desc->async_flag = async_flag;

	rf_ContinueRaidAccess(desc);

	return (0);
}


/* Force the array into reconfigured mode without doing reconstruction. */
int
rf_SetReconfiguredMode(RF_Raid_t *raidPtr, int row, int col)
{
	if (!(raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
		printf("Can't set reconfigured mode in dedicated-spare"
		    " array.\n");
		RF_PANIC();
	}
	RF_LOCK_MUTEX(raidPtr->mutex);
	raidPtr->numFailures++;
	raidPtr->Disks[row][col].status = rf_ds_dist_spared;
	raidPtr->status[row] = rf_rs_reconfigured;
	rf_update_component_labels(raidPtr, RF_NORMAL_COMPONENT_UPDATE);
	/*
	 * Install spare table only if declustering + distributed sparing
	 * architecture.
	 */
	if (raidPtr->Layout.map->flags & RF_BD_DECLUSTERED)
		rf_InstallSpareTable(raidPtr, row, col);
	RF_UNLOCK_MUTEX(raidPtr->mutex);
	return (0);
}

extern int fail_row, fail_col, fail_time;
extern int delayed_recon;

int
rf_FailDisk(RF_Raid_t *raidPtr, int frow, int fcol, int initRecon)
{
	printf("raid%d: Failing disk r%d c%d.\n", raidPtr->raidid, frow, fcol);
	RF_LOCK_MUTEX(raidPtr->mutex);
	raidPtr->numFailures++;
	raidPtr->Disks[frow][fcol].status = rf_ds_failed;
	raidPtr->status[frow] = rf_rs_degraded;
	rf_update_component_labels(raidPtr, RF_NORMAL_COMPONENT_UPDATE);
	RF_UNLOCK_MUTEX(raidPtr->mutex);
	if (initRecon)
		rf_ReconstructFailedDisk(raidPtr, frow, fcol);
	return (0);
}


/*
 * Releases a thread that is waiting for the array to become quiesced.
 * access_suspend_mutex should be locked upon calling this.
 */
void
rf_SignalQuiescenceLock(RF_Raid_t *raidPtr, RF_RaidReconDesc_t *reconDesc)
{
	if (rf_quiesceDebug) {
		printf("raid%d: Signalling quiescence lock.\n",
		       raidPtr->raidid);
	}
	raidPtr->access_suspend_release = 1;

	if (raidPtr->waiting_for_quiescence) {
		SIGNAL_QUIESCENT_COND(raidPtr);
	}
}


/*
 * Suspends all new requests to the array. No effect on accesses that are
 * in flight.
 */
int
rf_SuspendNewRequestsAndWait(RF_Raid_t *raidPtr)
{
	if (rf_quiesceDebug)
		printf("Suspending new reqs.\n");

	RF_LOCK_MUTEX(raidPtr->access_suspend_mutex);
	raidPtr->accesses_suspended++;
	raidPtr->waiting_for_quiescence = (raidPtr->accs_in_flight == 0) ? 0 : 1;

	if (raidPtr->waiting_for_quiescence) {
		raidPtr->access_suspend_release = 0;
		while (!raidPtr->access_suspend_release) {
			printf("Suspending: Waiting for Quiescence.\n");
			WAIT_FOR_QUIESCENCE(raidPtr);
			raidPtr->waiting_for_quiescence = 0;
		}
	}
	printf("Quiescence reached...\n");

	RF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);
	return (raidPtr->waiting_for_quiescence);
}


/* Wake up everyone waiting for quiescence to be released. */
void
rf_ResumeNewRequests(RF_Raid_t *raidPtr)
{
	RF_CallbackDesc_t *t, *cb;

	if (rf_quiesceDebug)
		printf("Resuming new reqs.\n");

	RF_LOCK_MUTEX(raidPtr->access_suspend_mutex);
	raidPtr->accesses_suspended--;
	if (raidPtr->accesses_suspended == 0)
		cb = raidPtr->quiesce_wait_list;
	else
		cb = NULL;
	raidPtr->quiesce_wait_list = NULL;
	RF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);

	while (cb) {
		t = cb;
		cb = cb->next;
		(t->callbackFunc) (t->callbackArg);
		rf_FreeCallbackDesc(t);
	}
}


/*****************************************************************************
 *
 * Debug routines.
 *
 *****************************************************************************/

void
rf_set_debug_option(char *name, long val)
{
	RF_DebugName_t *p;

	for (p = rf_debugNames; p->name; p++) {
		if (!strcmp(p->name, name)) {
			*(p->ptr) = val;
			printf("[Set debug variable %s to %ld]\n", name, val);
			return;
		}
	}
	RF_ERRORMSG1("Unknown debug string \"%s\"\n", name);
}


/* Would like to use sscanf here, but apparently not available in kernel. */
/*ARGSUSED*/
void
rf_ConfigureDebug(RF_Config_t *cfgPtr)
{
	char *val_p, *name_p, *white_p;
	long val;
	int i;

	rf_ResetDebugOptions();
	for (i = 0; cfgPtr->debugVars[i][0] && i < RF_MAXDBGV; i++) {
		name_p = rf_find_non_white(&cfgPtr->debugVars[i][0]);
		white_p = rf_find_white(name_p);	/*
							 * Skip to start of 2nd
							 * word.
							 */
		val_p = rf_find_non_white(white_p);
		if (*val_p == '0' && *(val_p + 1) == 'x')
			val = rf_htoi(val_p + 2);
		else
			val = rf_atoi(val_p);
		*white_p = '\0';
		rf_set_debug_option(name_p, val);
	}
}


/* Performance monitoring stuff. */

#if	!defined(_KERNEL) && !defined(SIMULATE)

/*
 * Throughput stats currently only used in user-level RAIDframe.
 */

int
rf_InitThroughputStats(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	int rc;

	/* These used by user-level RAIDframe only. */
	rc = rf_create_managed_mutex(listp, &raidPtr->throughputstats.mutex);
	if (rc) {
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n",
		    __FILE__, __LINE__, rc);
		return (rc);
	}
	raidPtr->throughputstats.sum_io_us = 0;
	raidPtr->throughputstats.num_ios = 0;
	raidPtr->throughputstats.num_out_ios = 0;
	return (0);
}

void
rf_StartThroughputStats(RF_Raid_t *raidPtr)
{
	RF_LOCK_MUTEX(raidPtr->throughputstats.mutex);
	raidPtr->throughputstats.num_ios++;
	raidPtr->throughputstats.num_out_ios++;
	if (raidPtr->throughputstats.num_out_ios == 1)
		RF_GETTIME(raidPtr->throughputstats.start);
	RF_UNLOCK_MUTEX(raidPtr->throughputstats.mutex);
}

void
rf_StopThroughputStats(RF_Raid_t *raidPtr)
{
	struct timeval diff;

	RF_LOCK_MUTEX(raidPtr->throughputstats.mutex);
	raidPtr->throughputstats.num_out_ios--;
	if (raidPtr->throughputstats.num_out_ios == 0) {
		RF_GETTIME(raidPtr->throughputstats.stop);
		RF_TIMEVAL_DIFF(&raidPtr->throughputstats.start,
		    &raidPtr->throughputstats.stop, &diff);
		raidPtr->throughputstats.sum_io_us += RF_TIMEVAL_TO_US(diff);
	}
	RF_UNLOCK_MUTEX(raidPtr->throughputstats.mutex);
}

void
rf_PrintThroughputStats(RF_Raid_t *raidPtr)
{
	RF_ASSERT(raidPtr->throughputstats.num_out_ios == 0);
	if (raidPtr->throughputstats.sum_io_us != 0) {
		printf("[Througphut: %8.2f IOs/second]\n",
		    raidPtr->throughputstats.num_ios /
		    (raidPtr->throughputstats.sum_io_us / 1000000.0));
	}
}

#endif	/* !_KERNEL && !SIMULATE */

void
rf_StartUserStats(RF_Raid_t *raidPtr)
{
	RF_GETTIME(raidPtr->userstats.start);
	raidPtr->userstats.sum_io_us = 0;
	raidPtr->userstats.num_ios = 0;
	raidPtr->userstats.num_sect_moved = 0;
}

void
rf_StopUserStats(RF_Raid_t *raidPtr)
{
	RF_GETTIME(raidPtr->userstats.stop);
}

void
rf_UpdateUserStats(
    RF_Raid_t	*raidPtr,
    int		 rt,		/* Response time in us. */
    int		 numsect	/* Number of sectors for this access. */
)
{
	raidPtr->userstats.sum_io_us += rt;
	raidPtr->userstats.num_ios++;
	raidPtr->userstats.num_sect_moved += numsect;
}

void
rf_PrintUserStats(RF_Raid_t *raidPtr)
{
	long    elapsed_us, mbs, mbs_frac;
	struct timeval diff;

	RF_TIMEVAL_DIFF(&raidPtr->userstats.start, &raidPtr->userstats.stop,
	    &diff);
	elapsed_us = RF_TIMEVAL_TO_US(diff);

	/* 2000 sectors per megabyte, 10000000 microseconds per second. */
	if (elapsed_us)
		mbs = (raidPtr->userstats.num_sect_moved / 2000) /
		    (elapsed_us / 1000000);
	else
		mbs = 0;

	/* This computes only the first digit of the fractional mb/s moved. */
	if (elapsed_us) {
		mbs_frac = ((raidPtr->userstats.num_sect_moved / 200) /
		    (elapsed_us / 1000000)) - (mbs * 10);
	} else {
		mbs_frac = 0;
	}

	printf("Number of I/Os:             %ld\n",
	    raidPtr->userstats.num_ios);
	printf("Elapsed time (us):          %ld\n",
	    elapsed_us);
	printf("User I/Os per second:       %ld\n",
	    RF_DB0_CHECK(raidPtr->userstats.num_ios, (elapsed_us / 1000000)));
	printf("Average user response time: %ld us\n",
	    RF_DB0_CHECK(raidPtr->userstats.sum_io_us,
	     raidPtr->userstats.num_ios));
	printf("Total sectors moved:        %ld\n",
	    raidPtr->userstats.num_sect_moved);
	printf("Average access size (sect): %ld\n",
	    RF_DB0_CHECK(raidPtr->userstats.num_sect_moved,
	    raidPtr->userstats.num_ios));
	printf("Achieved data rate:         %ld.%ld MB/sec\n",
	    mbs, mbs_frac);
}
@


1.13
log
@remove stupid casts, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_driver.c,v 1.12 2008/06/26 05:42:17 ray Exp $	*/
@


1.12
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_driver.c,v 1.11 2002/12/16 07:01:03 tdeval Exp $	*/
d639 1
a639 1
	bzero((char *) &desc->tracerec, sizeof(RF_AccTraceEntry_t));
@


1.11
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_driver.c,v 1.10 2002/08/09 15:10:20 tdeval Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.10
log
@Remove those noisy informational messages from dmesg.
Use the option RAIDDEBUG to get these.

Theo, thanks for suggesting.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_driver.c,v 1.9 2000/08/08 16:07:40 peter Exp $	*/
d3 2
a4 1
/*-
d21 2
a22 2
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
d44 3
a46 2
 * Author: Mark Holland, Khalil Amiri, Claudson Bornstein, William V. Courtright II,
 *         Robby Findler, Daniel Stodolsky, Rachad Youssef, Jim Zelenka
d69 1
a69 1
/******************************************************************************
d71 2
a72 1
 * rf_driver.c -- main setup, teardown, and access routines for the RAID driver
d74 1
a74 1
 * all routines are prefixed with rf_ (raidframe), to avoid conficts.
d76 1
a76 1
 ******************************************************************************/
d83 1
a83 1
#ifdef __NetBSD__
d128 8
a135 3
#define RF_MAX_FREE_RAD 128
#define RF_RAD_INC       16
#define RF_RAD_INITIAL   32
d137 2
a138 2
/* debug variables */
char    rf_panicbuf[2048];	/* a buffer to hold an error msg when we panic */
d140 36
a175 2
/* main configuration routines */
static int raidframe_booted = 0;
a176 29
static void rf_ConfigureDebug(RF_Config_t * cfgPtr);
static void set_debug_option(char *name, long val);
static void rf_UnconfigureArray(void);
static int init_rad(RF_RaidAccessDesc_t *);
static void clean_rad(RF_RaidAccessDesc_t *);
static void rf_ShutdownRDFreeList(void *);
static int rf_ConfigureRDFreeList(RF_ShutdownList_t **);

RF_DECLARE_MUTEX(rf_printf_mutex)	/* debug only:  avoids interleaved
					 * printfs by different stripes */

#define SIGNAL_QUIESCENT_COND(_raid_)  wakeup(&((_raid_)->accesses_suspended))
#define WAIT_FOR_QUIESCENCE(_raid_) \
	tsleep(&((_raid_)->accesses_suspended),PRIBIO,"raidframe quiesce", 0);

#define IO_BUF_ERR(bp, err) { \
	bp->b_flags |= B_ERROR; \
	bp->b_resid = bp->b_bcount; \
	bp->b_error = err; \
	biodone(bp); \
}

static int configureCount = 0;	/* number of active configurations */
static int isconfigged = 0;	/* is basic raidframe (non per-array)
					 * stuff configged */
RF_DECLARE_STATIC_MUTEX(configureMutex)	/* used to lock the configuration
					 * stuff */
static RF_ShutdownList_t *globalShutdown;	/* non array-specific stuff */
static int rf_ConfigureRDFreeList(RF_ShutdownList_t ** listp);
d178 1
a178 1
/* called at system boot time */
d180 1
a180 1
rf_BootRaidframe()
d182 1
a182 1
	int     rc;
d190 2
a191 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d199 2
d202 2
a203 2
 * This function is really just for debugging user-level stuff: it
 * frees up all memory, other RAIDframe resources which might otherwise
d207 2
a208 2
int 
rf_UnbootRaidframe()
d210 1
a210 1
	int     rc;
d221 2
a222 2
		RF_ERRORMSG3("Unable to destroy mutex file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d227 2
d230 1
a230 1
 * Called whenever an array is shutdown
d232 2
a233 2
static void 
rf_UnconfigureArray()
d235 1
a235 1
	int     rc;
d238 4
a241 2
	if (--configureCount == 0) {	/* if no active configurations, shut
					 * everything down */
d246 2
a247 1
			RF_ERRORMSG1("RAIDFRAME: unable to do global shutdown, rc=%d\n", rc);
d251 3
a253 3
	         * We must wait until now, because the AllocList module
	         * uses the DebugMem module.
	         */
d259 2
d264 2
a265 3
int 
rf_Shutdown(raidPtr)
	RF_Raid_t *raidPtr;
d268 2
a269 1
		RF_ERRORMSG("Attempt to shut down unconfigured RAIDframe driver.  Aborting shutdown\n");
d273 7
a279 7
         * wait for outstanding IOs to land
         * As described in rf_raid.h, we use the rad_freelist lock
         * to protect the per-array info about outstanding descs
         * since we need to do freelist locking anyway, and this
         * cuts down on the amount of serialization we've got going
         * on.
         */
d311 55
a365 51
#define DO_INIT_CONFIGURE(f) { \
	rc = f (&globalShutdown); \
	if (rc) { \
		RF_ERRORMSG2("RAIDFRAME: failed %s with %d\n", RF_STRING(f), rc); \
		rf_ShutdownList(&globalShutdown); \
		configureCount--; \
		RF_UNLOCK_MUTEX(configureMutex); \
		return(rc); \
	} \
}

#define DO_RAID_FAIL() { \
	rf_UnconfigureVnodes(raidPtr); \
	rf_ShutdownList(&raidPtr->shutdownList); \
	rf_UnconfigureArray(); \
}

#define DO_RAID_INIT_CONFIGURE(f) { \
	rc = f (&raidPtr->shutdownList, raidPtr, cfgPtr); \
	if (rc) { \
		RF_ERRORMSG2("RAIDFRAME: failed %s with %d\n", RF_STRING(f), rc); \
		DO_RAID_FAIL(); \
		return(rc); \
	} \
}

#define DO_RAID_MUTEX(_m_) { \
	rc = rf_create_managed_mutex(&raidPtr->shutdownList, (_m_)); \
	if (rc) { \
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", \
			__FILE__, __LINE__, rc); \
		DO_RAID_FAIL(); \
		return(rc); \
	} \
}

#define DO_RAID_COND(_c_) { \
	rc = rf_create_managed_cond(&raidPtr->shutdownList, (_c_)); \
	if (rc) { \
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", \
			__FILE__, __LINE__, rc); \
		DO_RAID_FAIL(); \
		return(rc); \
	} \
}

int 
rf_Configure(raidPtr, cfgPtr, ac)
	RF_Raid_t *raidPtr;
	RF_Config_t *cfgPtr;
	RF_AutoConfig_t *ac;
d368 1
a368 1
	int     i, rc;
d370 5
a374 4
	/* XXX This check can probably be removed now, since 
	   RAIDFRAME_CONFIGURRE now checks to make sure that the
	   RAID set is not already valid
	*/
d376 2
a377 1
		RF_ERRORMSG("RAIDframe configuration not shut down.  Aborting configure.\n");
d385 2
a386 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
			    __LINE__, rc);
d390 1
a390 1
		/* initialize globals */
d392 1
a392 1
		printf("RAIDFRAME: protectedSectors is %ld\n", 
d401 2
a402 2
	         * Yes, this does make debugging general to the whole
	         * system instead of being array specific. Bummer, drag.  
d426 4
a429 2
	/* set up the cleanup list.  Do this after ConfigureDebug so that
	 * value of memDebug will be set */
d437 1
a437 2
	    (void (*) (void *)) rf_FreeAllocList,
	    raidPtr->cleanupList);
d439 2
a440 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d448 4
a451 2
	/* XXX we don't even pretend to support more than one row in the
	 * kernel... */
d457 2
a458 2
	RF_CallocAndAdd(raidPtr->status, raidPtr->numRow, sizeof(RF_RowStatus_t),
	    (RF_RowStatus_t *), raidPtr->cleanupList);
d489 6
a494 4
	if (ac!=NULL) {
		/* We have an AutoConfig structure..  Don't do the
		   normal disk configuration... call the auto config
		   stuff */
d500 4
a503 2
	/* do this after ConfigureDisks & ConfigureSpareDisks to be sure dev
	 * no. is set */
d513 2
a514 2
		         * XXX better distribution
		         */
d525 4
a528 2
	/* autoconfigure and root_partition will actually get filled in 
	   after the config is done */
d543 2
a544 3
static int 
init_rad(desc)
	RF_RaidAccessDesc_t *desc;
d546 1
a546 1
	int     rc;
d550 1
a550 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
d556 1
a556 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", __FILE__,
d564 2
a565 3
static void 
clean_rad(desc)
	RF_RaidAccessDesc_t *desc;
d571 2
a572 3
static void 
rf_ShutdownRDFreeList(ignored)
	void   *ignored;
d574 2
a575 1
	RF_FREELIST_DESTROY_CLEAN(rf_rad_freelist, next, (RF_RaidAccessDesc_t *), clean_rad);
d578 2
a579 3
static int 
rf_ConfigureRDFreeList(listp)
	RF_ShutdownList_t **listp;
d581 1
a581 1
	int     rc;
d590 1
a590 1
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n", __FILE__,
d596 1
a596 1
	    (RF_RaidAccessDesc_t *), init_rad);
d602 13
a614 12
    RF_Raid_t * raidPtr,
    RF_IoType_t type,
    RF_RaidAddr_t raidAddress,
    RF_SectorCount_t numBlocks,
    caddr_t bufPtr,
    void *bp,
    RF_DagHeader_t ** paramDAG,
    RF_AccessStripeMapHeader_t ** paramASM,
    RF_RaidAccessFlags_t flags,
    void (*cbF) (struct buf *),
    void *cbA,
    RF_AccessState_t * states)
d618 2
a619 1
	RF_FREELIST_GET_INIT_NOUNLOCK(rf_rad_freelist, desc, next, (RF_RaidAccessDesc_t *), init_rad);
d622 3
a624 3
	         * Actually, we're shutting the array down. Free the desc
	         * and return NULL.
	         */
d626 2
a627 1
		RF_FREELIST_FREE_CLEAN(rf_rad_freelist, desc, next, clean_rad);
d657 1
a657 1
void 
d665 1
a665 1
	RF_FREELIST_FREE_CLEAN_NOUNLOCK(rf_rad_freelist, desc, next, clean_rad);
d672 3
a674 1
/*********************************************************************
d676 1
a676 1
 * Accesses are retried until a DAG can not be selected.  This occurs
d680 1
a680 1
int 
d682 22
a703 18
    RF_Raid_t * raidPtr,
    RF_IoType_t type,
    int async_flag,
    RF_RaidAddr_t raidAddress,
    RF_SectorCount_t numBlocks,
    caddr_t bufPtr,
    void *bp_in,
    RF_DagHeader_t ** paramDAG,
    RF_AccessStripeMapHeader_t ** paramASM,
    RF_RaidAccessFlags_t flags,
    RF_RaidAccessDesc_t ** paramDesc,
    void (*cbF) (struct buf *),
    void *cbA)
/*
type should be read or write
async_flag should be RF_TRUE or RF_FALSE
bp_in is a buf pointer.  void * to facilitate ignoring it outside the kernel
*/
d712 2
a713 1
		RF_ERRORMSG("RAIDframe driver not successfully configured.  Rejecting access.\n");
d720 1
a720 1
		printf("logBytes is: %d %d %d\n", raidPtr->raidid,
d723 1
a723 1
		printf("raid%d: %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx\n", raidPtr->raidid,
d733 1
a733 1
		printf("DoAccess: raid addr %lu too large to access %lu sectors.  Max legal addr is %lu\n",
d754 5
a758 6
/* force the array into reconfigured mode without doing reconstruction */
int 
rf_SetReconfiguredMode(raidPtr, row, col)
	RF_Raid_t *raidPtr;
	int     row;
	int     col;
d761 2
a762 1
		printf("Can't set reconfigured mode in dedicated-spare array\n");
d770 4
a773 2
	/* install spare table only if declustering + distributed sparing
	 * architecture. */
d783 2
a784 6
int 
rf_FailDisk(
    RF_Raid_t * raidPtr,
    int frow,
    int fcol,
    int initRecon)
d786 1
a786 1
	printf("raid%d: Failing disk r%d c%d\n", raidPtr->raidid, frow, fcol);
d797 5
a801 2
/* releases a thread that is waiting for the array to become quiesced.
 * access_suspend_mutex should be locked upon calling this
d803 2
a804 4
void 
rf_SignalQuiescenceLock(raidPtr, reconDesc)
	RF_Raid_t *raidPtr;
	RF_RaidReconDesc_t *reconDesc;
d807 1
a807 1
		printf("raid%d: Signalling quiescence lock\n", 
d816 8
a823 4
/* suspends all new requests to the array.  No effect on accesses that are in flight.  */
int 
rf_SuspendNewRequestsAndWait(raidPtr)
	RF_Raid_t *raidPtr;
d826 1
a826 1
		printf("Suspending new reqs\n");
d835 1
a835 1
			printf("Suspending: Waiting for Quiescence\n");
d840 1
a840 1
	printf("Quiescence reached..\n");
d845 5
a849 4
/* wake up everyone waiting for quiescence to be released */
void 
rf_ResumeNewRequests(raidPtr)
	RF_Raid_t *raidPtr;
d854 1
a854 1
		printf("Resuming new reqs\n");
d872 3
a874 1
/*****************************************************************************************
d876 1
a876 1
 * debug routines
d878 1
a878 1
 ****************************************************************************************/
d880 2
a881 4
static void 
set_debug_option(name, val)
	char   *name;
	long    val;
d896 1
a896 1
/* would like to use sscanf here, but apparently not available in kernel */
d898 6
a903 7
static void 
rf_ConfigureDebug(cfgPtr)
	RF_Config_t *cfgPtr;
{
	char   *val_p, *name_p, *white_p;
	long    val;
	int     i;
d908 4
a911 2
		white_p = rf_find_white(name_p);	/* skip to start of 2nd
							 * word */
d918 1
a918 1
		set_debug_option(name_p, val);
a920 1
/* performance monitoring stuff */
d922 4
a925 1
#if !defined(_KERNEL) && !defined(SIMULATE)
d928 1
a928 1
 * Throughput stats currently only used in user-level RAIDframe
d931 3
a933 5
static int 
rf_InitThroughputStats(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d935 1
a935 1
	int     rc;
d937 1
a937 1
	/* these used by user-level raidframe only */
d940 2
a941 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d950 2
a951 2
void 
rf_StartThroughputStats(RF_Raid_t * raidPtr)
d961 2
a962 2
static void 
rf_StopThroughputStats(RF_Raid_t * raidPtr)
d970 2
a971 1
		RF_TIMEVAL_DIFF(&raidPtr->throughputstats.start, &raidPtr->throughputstats.stop, &diff);
d977 2
a978 2
static void 
rf_PrintThroughputStats(RF_Raid_t * raidPtr)
d982 3
a984 2
		printf("[Througphut: %8.2f IOs/second]\n", raidPtr->throughputstats.num_ios
		    / (raidPtr->throughputstats.sum_io_us / 1000000.0));
a986 1
#endif				/* !_KERNEL && !SIMULATE */
d988 4
a991 2
void 
rf_StartUserStats(RF_Raid_t * raidPtr)
d999 2
a1000 2
void 
rf_StopUserStats(RF_Raid_t * raidPtr)
d1005 6
a1010 5
void 
rf_UpdateUserStats(raidPtr, rt, numsect)
	RF_Raid_t *raidPtr;
	int     rt;		/* resp time in us */
	int     numsect;	/* number of sectors for this access */
d1017 2
a1018 2
void 
rf_PrintUserStats(RF_Raid_t * raidPtr)
d1023 2
a1024 1
	RF_TIMEVAL_DIFF(&raidPtr->userstats.start, &raidPtr->userstats.stop, &diff);
d1027 1
a1027 1
	/* 2000 sectors per megabyte, 10000000 microseconds per second */
d1029 2
a1030 1
		mbs = (raidPtr->userstats.num_sect_moved / 2000) / (elapsed_us / 1000000);
d1034 1
a1034 1
	/* this computes only the first digit of the fractional mb/s moved */
d1036 2
a1037 2
		mbs_frac = ((raidPtr->userstats.num_sect_moved / 200) / (elapsed_us / 1000000))
		    - (mbs * 10);
d1042 16
a1057 7
	printf("Number of I/Os:             %ld\n", raidPtr->userstats.num_ios);
	printf("Elapsed time (us):          %ld\n", elapsed_us);
	printf("User I/Os per second:       %ld\n", RF_DB0_CHECK(raidPtr->userstats.num_ios, (elapsed_us / 1000000)));
	printf("Average user response time: %ld us\n", RF_DB0_CHECK(raidPtr->userstats.sum_io_us, raidPtr->userstats.num_ios));
	printf("Total sectors moved:        %ld\n", raidPtr->userstats.num_sect_moved);
	printf("Average access size (sect): %ld\n", RF_DB0_CHECK(raidPtr->userstats.num_sect_moved, raidPtr->userstats.num_ios));
	printf("Achieved data rate:         %ld.%ld MB/sec\n", mbs, mbs_frac);
@


1.9
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_driver.c,v 1.8 2000/01/11 18:02:21 peter Exp $	*/
d363 1
d366 1
@


1.9.8.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_driver.c,v 1.9 2000/08/08 16:07:40 peter Exp $	*/
a362 1
#ifdef	RAIDDEBUG
a364 1
#endif	/* RAIDDEBUG */
@


1.9.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 2

/*
d20 2
a21 2
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
d43 2
a44 3
 * Author:	Mark Holland, Khalil Amiri, Claudson Bornstein,
 *		William V. Courtright II, Robby Findler, Daniel Stodolsky,
 *		Rachad Youssef, Jim Zelenka
d67 1
a67 1
/*****************************************************************************
d69 1
a69 2
 * rf_driver.c -- Main setup, teardown, and access routines for the RAID
 *		  driver
d71 1
a71 1
 * All routines are prefixed with rf_ (RAIDframe), to avoid conficts.
d73 1
a73 1
 *****************************************************************************/
d80 1
a80 1
#ifdef	__NetBSD__
d125 3
a127 8
#define	RF_MAX_FREE_RAD		128
#define	RF_RAD_INC		 16
#define	RF_RAD_INITIAL		 32

/* Debug variables. */
char	rf_panicbuf[2048];	/*
				 * A buffer to hold an error msg when we panic.
				 */
d129 4
a132 1
/* Main configuration routines. */
d135 29
a163 37
void rf_ConfigureDebug(RF_Config_t *);
void rf_set_debug_option(char *, long);
void rf_UnconfigureArray(void);
int  rf_init_rad(RF_RaidAccessDesc_t *);
void rf_clean_rad(RF_RaidAccessDesc_t *);
void rf_ShutdownRDFreeList(void *);
int  rf_ConfigureRDFreeList(RF_ShutdownList_t **);

RF_DECLARE_MUTEX(rf_printf_mutex);	/*
					 * Debug only: Avoids interleaved
					 * printfs by different stripes.
					 */

#define	SIGNAL_QUIESCENT_COND(_raid_)	wakeup(&((_raid_)->accesses_suspended))
#define	WAIT_FOR_QUIESCENCE(_raid_)					\
	tsleep(&((_raid_)->accesses_suspended), PRIBIO, "RAIDframe quiesce", 0);

#define	IO_BUF_ERR(bp, err)						\
do {									\
	bp->b_flags |= B_ERROR;						\
	bp->b_resid = bp->b_bcount;					\
	bp->b_error = err;						\
	biodone(bp);							\
} while (0)

static int configureCount = 0;	/* Number of active configurations. */
static int isconfigged = 0;	/*
				 * Is basic RAIDframe (non per-array)
				 * stuff configured ?
				 */
RF_DECLARE_STATIC_MUTEX(configureMutex);	/*
						 * Used to lock the
						 * configuration stuff.
						 */
static RF_ShutdownList_t *globalShutdown;	/* Non array-specific stuff. */
int  rf_ConfigureRDFreeList(RF_ShutdownList_t **);

d165 1
a165 1
/* Called at system boot time. */
d167 1
a167 1
rf_BootRaidframe(void)
d169 1
a169 1
	int rc;
d177 2
a178 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n",
		    __FILE__, __LINE__, rc);
a185 2


d187 2
a188 2
 * This function is really just for debugging user-level stuff: It
 * frees up all memory, other RAIDframe resources that might otherwise
d192 2
a193 2
int
rf_UnbootRaidframe(void)
d195 1
a195 1
	int rc;
d206 2
a207 2
		RF_ERRORMSG3("Unable to destroy mutex file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
a211 2


d213 1
a213 1
 * Called whenever an array is shutdown.
d215 2
a216 2
void
rf_UnconfigureArray(void)
d218 1
a218 1
	int rc;
d221 2
a222 4
	if (--configureCount == 0) {	/*
					 * If no active configurations, shut
					 * everything down.
					 */
d227 1
a227 2
			RF_ERRORMSG1("RAIDFRAME: unable to do global shutdown,"
			    " rc=%d.\n", rc);
d231 3
a233 3
		 * We must wait until now, because the AllocList module
		 * uses the DebugMem module.
		 */
a238 2


d242 3
a244 2
int
rf_Shutdown(RF_Raid_t *raidPtr)
d247 1
a247 2
		RF_ERRORMSG("Attempt to shut down unconfigured RAIDframe"
		    " driver. Aborting shutdown.\n");
d251 7
a257 7
	 * Wait for outstanding IOs to land.
	 * As described in rf_raid.h, we use the rad_freelist lock
	 * to protect the per-array info about outstanding descs,
	 * since we need to do freelist locking anyway, and this
	 * cuts down on the amount of serialization we've got going
	 * on.
	 */
d289 51
a339 55
#define	DO_INIT_CONFIGURE(f)						\
do {									\
	rc = f (&globalShutdown);					\
	if (rc) {							\
		RF_ERRORMSG2("RAIDFRAME: failed %s with %d.\n",		\
		    RF_STRING(f), rc);					\
		rf_ShutdownList(&globalShutdown);			\
		configureCount--;					\
		RF_UNLOCK_MUTEX(configureMutex);			\
		return(rc);						\
	}								\
} while (0)

#define	DO_RAID_FAIL()							\
do {									\
	rf_UnconfigureVnodes(raidPtr);					\
	rf_ShutdownList(&raidPtr->shutdownList);			\
	rf_UnconfigureArray();						\
} while (0)

#define	DO_RAID_INIT_CONFIGURE(f)					\
do {									\
	rc = (f)(&raidPtr->shutdownList, raidPtr, cfgPtr);		\
	if (rc) {							\
		RF_ERRORMSG2("RAIDFRAME: failed %s with %d.\n",		\
		    RF_STRING(f), rc);					\
		DO_RAID_FAIL();						\
		return(rc);						\
	}								\
} while (0)

#define	DO_RAID_MUTEX(_m_)						\
do {									\
	rc = rf_create_managed_mutex(&raidPtr->shutdownList, (_m_));	\
	if (rc) {							\
		RF_ERRORMSG3("Unable to init mutex file %s line %d"	\
		    " rc=%d.\n", __FILE__, __LINE__, rc);		\
		DO_RAID_FAIL();						\
		return(rc);						\
	}								\
} while (0)

#define	DO_RAID_COND(_c_)						\
do {									\
	rc = rf_create_managed_cond(&raidPtr->shutdownList, (_c_));	\
	if (rc) {							\
		RF_ERRORMSG3("Unable to init cond file %s line %d"	\
		    " rc=%d.\n", __FILE__, __LINE__, rc);		\
		DO_RAID_FAIL();						\
		return(rc);						\
	}								\
} while (0)

int
rf_Configure(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr, RF_AutoConfig_t *ac)
d342 1
a342 1
	int i, rc;
d344 4
a347 5
	/*
	 * XXX This check can probably be removed now, since
	 * RAIDFRAME_CONFIGURE now checks to make sure that the
	 * RAID set is not already valid.
	 */
d349 1
a349 2
		RF_ERRORMSG("RAIDframe configuration not shut down."
		    " Aborting configure.\n");
d357 2
a358 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			    " rc=%d.\n", __FILE__, __LINE__, rc);
d362 1
a362 1
		/* Initialize globals. */
d364 1
a364 1
		printf("RAIDFRAME: protectedSectors is %ld.\n",
d373 2
a374 2
		 * Yes, this does make debugging general to the whole
		 * system instead of being array specific. Bummer, drag.
d398 2
a399 4
	/*
	 * Set up the cleanup list. Do this after ConfigureDebug so that
	 * value of memDebug will be set.
	 */
d407 2
a408 1
	    (void (*) (void *)) rf_FreeAllocList, raidPtr->cleanupList);
d410 2
a411 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
d419 2
a420 4
	/*
	 * XXX We don't even pretend to support more than one row in the
	 * kernel...
	 */
d426 2
a427 2
	RF_CallocAndAdd(raidPtr->status, raidPtr->numRow,
	    sizeof(RF_RowStatus_t), (RF_RowStatus_t *), raidPtr->cleanupList);
d458 4
a461 6
	if (ac != NULL) {
		/*
		 * We have an AutoConfig structure... Don't do the
		 * normal disk configuration... call the auto config
		 * stuff.
		 */
d467 2
a468 4
	/*
	 * Do this after ConfigureDisks & ConfigureSpareDisks to be sure
	 * devno is set.
	 */
d478 2
a479 2
			 * XXX Better distribution.
			 */
d490 2
a491 4
	/*
	 * Autoconfigure and root_partition will actually get filled in
	 * after the config is done.
	 */
d506 3
a508 2
int
rf_init_rad(RF_RaidAccessDesc_t *desc)
d510 1
a510 1
	int rc;
d514 1
a514 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n", __FILE__,
d520 1
a520 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d.\n", __FILE__,
d528 3
a530 2
void
rf_clean_rad(RF_RaidAccessDesc_t *desc)
d536 3
a538 2
void
rf_ShutdownRDFreeList(void *ignored)
d540 1
a540 2
	RF_FREELIST_DESTROY_CLEAN(rf_rad_freelist, next,
	    (RF_RaidAccessDesc_t *), rf_clean_rad);
d543 3
a545 2
int
rf_ConfigureRDFreeList(RF_ShutdownList_t **listp)
d547 1
a547 1
	int rc;
d556 1
a556 1
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d.\n", __FILE__,
d562 1
a562 1
	    (RF_RaidAccessDesc_t *), rf_init_rad);
d568 12
a579 13
    RF_Raid_t			 *raidPtr,
    RF_IoType_t			  type,
    RF_RaidAddr_t		  raidAddress,
    RF_SectorCount_t		  numBlocks,
    caddr_t			  bufPtr,
    void			 *bp,
    RF_DagHeader_t		**paramDAG,
    RF_AccessStripeMapHeader_t	**paramASM,
    RF_RaidAccessFlags_t	  flags,
    void			(*cbF) (struct buf *),
    void			 *cbA,
    RF_AccessState_t		 *states
)
d583 1
a583 2
	RF_FREELIST_GET_INIT_NOUNLOCK(rf_rad_freelist, desc, next,
	    (RF_RaidAccessDesc_t *), rf_init_rad);
d586 3
a588 3
		 * Actually, we're shutting the array down. Free the desc
		 * and return NULL.
		 */
d590 1
a590 2
		RF_FREELIST_FREE_CLEAN(rf_rad_freelist, desc, next,
		    rf_clean_rad);
d620 1
a620 1
void
d628 1
a628 1
	RF_FREELIST_FREE_CLEAN_NOUNLOCK(rf_rad_freelist, desc, next, rf_clean_rad);
d635 1
a635 3


/********************************************************************
d637 1
a637 1
 * Accesses are retried until a DAG can not be selected. This occurs
d641 1
a641 1
int
d643 18
a660 22
    RF_Raid_t			 *raidPtr,
    RF_IoType_t			  type,		/* Should be read or write. */
    int				  async_flag,	/*
						 * Should be RF_TRUE
						 * or RF_FALSE.
						 */
    RF_RaidAddr_t		  raidAddress,
    RF_SectorCount_t		  numBlocks,
    caddr_t			  bufPtr,
    void			 *bp_in,	/*
						 * It's a buf pointer.
						 * void * to facilitate
						 * ignoring it outside
						 * the kernel.
						 */
    RF_DagHeader_t		**paramDAG,
    RF_AccessStripeMapHeader_t	**paramASM,
    RF_RaidAccessFlags_t	  flags,
    RF_RaidAccessDesc_t		**paramDesc,
    void			(*cbF) (struct buf *),
    void			 *cbA
)
d669 1
a669 2
		RF_ERRORMSG("RAIDframe driver not successfully configured."
		    " Rejecting access.\n");
d676 1
a676 1
		printf("logBytes is: %d %d %d.\n", raidPtr->raidid,
d679 1
a679 1
		printf("raid%d: %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx.\n", raidPtr->raidid,
d689 1
a689 1
		printf("DoAccess: raid addr %lu too large to access %lu sectors. Max legal addr is %lu.\n",
d710 6
a715 5


/* Force the array into reconfigured mode without doing reconstruction. */
int
rf_SetReconfiguredMode(RF_Raid_t *raidPtr, int row, int col)
d718 1
a718 2
		printf("Can't set reconfigured mode in dedicated-spare"
		    " array.\n");
d726 2
a727 4
	/*
	 * Install spare table only if declustering + distributed sparing
	 * architecture.
	 */
d737 6
a742 2
int
rf_FailDisk(RF_Raid_t *raidPtr, int frow, int fcol, int initRecon)
d744 1
a744 1
	printf("raid%d: Failing disk r%d c%d.\n", raidPtr->raidid, frow, fcol);
d755 2
a756 5


/*
 * Releases a thread that is waiting for the array to become quiesced.
 * access_suspend_mutex should be locked upon calling this.
d758 4
a761 2
void
rf_SignalQuiescenceLock(RF_Raid_t *raidPtr, RF_RaidReconDesc_t *reconDesc)
d764 1
a764 1
		printf("raid%d: Signalling quiescence lock.\n",
d773 4
a776 8


/*
 * Suspends all new requests to the array. No effect on accesses that are
 * in flight.
 */
int
rf_SuspendNewRequestsAndWait(RF_Raid_t *raidPtr)
d779 1
a779 1
		printf("Suspending new reqs.\n");
d788 1
a788 1
			printf("Suspending: Waiting for Quiescence.\n");
d793 1
a793 1
	printf("Quiescence reached...\n");
d798 4
a801 5


/* Wake up everyone waiting for quiescence to be released. */
void
rf_ResumeNewRequests(RF_Raid_t *raidPtr)
d806 1
a806 1
		printf("Resuming new reqs.\n");
d824 1
a824 3


/*****************************************************************************
d826 1
a826 1
 * Debug routines.
d828 1
a828 1
 *****************************************************************************/
d830 4
a833 2
void
rf_set_debug_option(char *name, long val)
d848 1
a848 1
/* Would like to use sscanf here, but apparently not available in kernel. */
d850 7
a856 6
void
rf_ConfigureDebug(RF_Config_t *cfgPtr)
{
	char *val_p, *name_p, *white_p;
	long val;
	int i;
d861 2
a862 4
		white_p = rf_find_white(name_p);	/*
							 * Skip to start of 2nd
							 * word.
							 */
d869 1
a869 1
		rf_set_debug_option(name_p, val);
d872 1
d874 1
a874 4

/* Performance monitoring stuff. */

#if	!defined(_KERNEL) && !defined(SIMULATE)
d877 1
a877 1
 * Throughput stats currently only used in user-level RAIDframe.
d880 5
a884 3
int
rf_InitThroughputStats(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d886 1
a886 1
	int rc;
d888 1
a888 1
	/* These used by user-level RAIDframe only. */
d891 2
a892 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n",
		    __FILE__, __LINE__, rc);
d901 2
a902 2
void
rf_StartThroughputStats(RF_Raid_t *raidPtr)
d912 2
a913 2
void
rf_StopThroughputStats(RF_Raid_t *raidPtr)
d921 1
a921 2
		RF_TIMEVAL_DIFF(&raidPtr->throughputstats.start,
		    &raidPtr->throughputstats.stop, &diff);
d927 2
a928 2
void
rf_PrintThroughputStats(RF_Raid_t *raidPtr)
d932 2
a933 3
		printf("[Througphut: %8.2f IOs/second]\n",
		    raidPtr->throughputstats.num_ios /
		    (raidPtr->throughputstats.sum_io_us / 1000000.0));
d936 1
d938 2
a939 4
#endif	/* !_KERNEL && !SIMULATE */

void
rf_StartUserStats(RF_Raid_t *raidPtr)
d947 2
a948 2
void
rf_StopUserStats(RF_Raid_t *raidPtr)
d953 5
a957 6
void
rf_UpdateUserStats(
    RF_Raid_t	*raidPtr,
    int		 rt,		/* Response time in us. */
    int		 numsect	/* Number of sectors for this access. */
)
d964 2
a965 2
void
rf_PrintUserStats(RF_Raid_t *raidPtr)
d970 1
a970 2
	RF_TIMEVAL_DIFF(&raidPtr->userstats.start, &raidPtr->userstats.stop,
	    &diff);
d973 1
a973 1
	/* 2000 sectors per megabyte, 10000000 microseconds per second. */
d975 1
a975 2
		mbs = (raidPtr->userstats.num_sect_moved / 2000) /
		    (elapsed_us / 1000000);
d979 1
a979 1
	/* This computes only the first digit of the fractional mb/s moved. */
d981 2
a982 2
		mbs_frac = ((raidPtr->userstats.num_sect_moved / 200) /
		    (elapsed_us / 1000000)) - (mbs * 10);
d987 7
a993 16
	printf("Number of I/Os:             %ld\n",
	    raidPtr->userstats.num_ios);
	printf("Elapsed time (us):          %ld\n",
	    elapsed_us);
	printf("User I/Os per second:       %ld\n",
	    RF_DB0_CHECK(raidPtr->userstats.num_ios, (elapsed_us / 1000000)));
	printf("Average user response time: %ld us\n",
	    RF_DB0_CHECK(raidPtr->userstats.sum_io_us,
	     raidPtr->userstats.num_ios));
	printf("Total sectors moved:        %ld\n",
	    raidPtr->userstats.num_sect_moved);
	printf("Average access size (sect): %ld\n",
	    RF_DB0_CHECK(raidPtr->userstats.num_sect_moved,
	    raidPtr->userstats.num_ios));
	printf("Achieved data rate:         %ld.%ld MB/sec\n",
	    mbs, mbs_frac);
@


1.8
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_driver.c,v 1.7 2000/01/08 20:57:12 peter Exp $	*/
/*	$NetBSD: rf_driver.c,v 1.27 2000/01/09 03:44:33 oster Exp $	*/
a142 2
void rf_UnconfigureVnodes( RF_Raid_t * );
 
d269 7
d278 1
a278 1
	rf_update_component_labels(raidPtr);
a288 38
void
rf_UnconfigureVnodes( raidPtr )
	RF_Raid_t *raidPtr;
{
	int r,c; 
	struct proc *p;

	/* We take this opportunity to close the vnodes like we should.. */

	p = raidPtr->engine_thread;

	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			printf("Closing vnode for row: %d col: %d\n", r, c);
			if (raidPtr->raid_cinfo[r][c].ci_vp) {
				VOP_UNLOCK(raidPtr->raid_cinfo[r][c].ci_vp, 0, p);
 				(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,
 				    FREAD | FWRITE, p->p_ucred, p);
				raidPtr->raid_cinfo[r][c].ci_vp = NULL;
			} else {
				printf("vnode was NULL\n");
			}

		}
	}
	for (r = 0; r < raidPtr->numSpare; r++) {
		printf("Closing vnode for spare: %d\n", r);
		if (raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp) {
			VOP_UNLOCK(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp, 0, p);
			(void) vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp,
			    FREAD | FWRITE, p->p_ucred, p);
			raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;
		} else {
			printf("vnode was NULL\n");
		}
	}
}

d336 1
a336 1
rf_Configure(raidPtr, cfgPtr)
d339 1
a342 1
	int     unit;
d344 4
d363 2
a364 1
		printf("RAIDFRAME: protectedSectors is %ld\n", rf_protectedSectors);
d369 1
d371 3
a373 3
	         * Yes, this does make debugging general to the whole system instead
	         * of being array specific. Bummer, drag.
	         */
a394 9
	/*
         * Null out the entire raid descriptor to avoid problems when we reconfig.
         * This also clears the valid bit.
         */
	/* XXX this clearing should be moved UP to outside of here.... that,
	 * or rf_Configure() needs to take more arguments... XXX */
	unit = raidPtr->raidid;
	bzero((char *) raidPtr, sizeof(RF_Raid_t));
	raidPtr->raidid = unit;
d455 10
a464 2
	DO_RAID_INIT_CONFIGURE(rf_ConfigureDisks);
	DO_RAID_INIT_CONFIGURE(rf_ConfigureSpareDisks);
d482 13
d723 1
d747 1
d786 1
a786 1
			printf("Suspending: Waiting for Quiesence\n");
d791 1
a791 1
	printf("Quiesence reached..\n");
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_driver.c,v 1.9 2000/08/08 16:07:40 peter Exp $	*/
/*	$NetBSD: rf_driver.c,v 1.37 2000/06/04 02:05:13 oster Exp $	*/
d143 2
a270 7
	/* Wait for any parity re-writes to stop... */
	while (raidPtr->parity_rewrite_in_progress) {
		printf("Waiting for parity re-write to exit...\n");
		tsleep(&raidPtr->parity_rewrite_in_progress, PRIBIO,
		       "rfprwshutdown", 0);
	}

d273 1
a273 1
	rf_update_component_labels(raidPtr, RF_FINAL_COMPONENT_UPDATE);
d284 38
d369 1
a369 1
rf_Configure(raidPtr, cfgPtr, ac)
a371 1
	RF_AutoConfig_t *ac;
d375 1
a376 4
	/* XXX This check can probably be removed now, since 
	   RAIDFRAME_CONFIGURRE now checks to make sure that the
	   RAID set is not already valid
	*/
d392 1
a392 2
		printf("RAIDFRAME: protectedSectors is %ld\n", 
		       rf_protectedSectors);
a396 1

d398 3
a400 3
	         * Yes, this does make debugging general to the whole
	         * system instead of being array specific. Bummer, drag.  
		 */
d422 9
d491 2
a492 10

	if (ac!=NULL) {
		/* We have an AutoConfig structure..  Don't do the
		   normal disk configuration... call the auto config
		   stuff */
		rf_AutoConfigureDisks(raidPtr, cfgPtr, ac);
	} else {
		DO_RAID_INIT_CONFIGURE(rf_ConfigureDisks);
		DO_RAID_INIT_CONFIGURE(rf_ConfigureSpareDisks);
	}
a509 13
	raidPtr->numNewFailures = 0;
	raidPtr->copyback_in_progress = 0;
	raidPtr->parity_rewrite_in_progress = 0;
	raidPtr->recon_in_progress = 0;
	raidPtr->maxOutstanding = cfgPtr->maxOutstandingDiskReqs;

	/* autoconfigure and root_partition will actually get filled in 
	   after the config is done */
	raidPtr->autoconfigure = 0;
	raidPtr->root_partition = 0;
	raidPtr->last_unit = raidPtr->raidid;
	raidPtr->config_order = 0;

a737 1
	rf_update_component_labels(raidPtr, RF_NORMAL_COMPONENT_UPDATE);
a760 1
	rf_update_component_labels(raidPtr, RF_NORMAL_COMPONENT_UPDATE);
d799 1
a799 1
			printf("Suspending: Waiting for Quiescence\n");
d804 1
a804 1
	printf("Quiescence reached..\n");
@


1.8.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 2

/*
d20 2
a21 2
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
d43 2
a44 3
 * Author:	Mark Holland, Khalil Amiri, Claudson Bornstein,
 *		William V. Courtright II, Robby Findler, Daniel Stodolsky,
 *		Rachad Youssef, Jim Zelenka
d67 1
a67 1
/*****************************************************************************
d69 1
a69 2
 * rf_driver.c -- Main setup, teardown, and access routines for the RAID
 *		  driver
d71 1
a71 1
 * All routines are prefixed with rf_ (RAIDframe), to avoid conficts.
d73 1
a73 1
 *****************************************************************************/
d80 1
a80 1
#ifdef	__NetBSD__
d125 3
a127 8
#define	RF_MAX_FREE_RAD		128
#define	RF_RAD_INC		 16
#define	RF_RAD_INITIAL		 32

/* Debug variables. */
char	rf_panicbuf[2048];	/*
				 * A buffer to hold an error msg when we panic.
				 */
d129 4
a132 1
/* Main configuration routines. */
d135 29
a163 37
void rf_ConfigureDebug(RF_Config_t *);
void rf_set_debug_option(char *, long);
void rf_UnconfigureArray(void);
int  rf_init_rad(RF_RaidAccessDesc_t *);
void rf_clean_rad(RF_RaidAccessDesc_t *);
void rf_ShutdownRDFreeList(void *);
int  rf_ConfigureRDFreeList(RF_ShutdownList_t **);

RF_DECLARE_MUTEX(rf_printf_mutex);	/*
					 * Debug only: Avoids interleaved
					 * printfs by different stripes.
					 */

#define	SIGNAL_QUIESCENT_COND(_raid_)	wakeup(&((_raid_)->accesses_suspended))
#define	WAIT_FOR_QUIESCENCE(_raid_)					\
	tsleep(&((_raid_)->accesses_suspended), PRIBIO, "RAIDframe quiesce", 0);

#define	IO_BUF_ERR(bp, err)						\
do {									\
	bp->b_flags |= B_ERROR;						\
	bp->b_resid = bp->b_bcount;					\
	bp->b_error = err;						\
	biodone(bp);							\
} while (0)

static int configureCount = 0;	/* Number of active configurations. */
static int isconfigged = 0;	/*
				 * Is basic RAIDframe (non per-array)
				 * stuff configured ?
				 */
RF_DECLARE_STATIC_MUTEX(configureMutex);	/*
						 * Used to lock the
						 * configuration stuff.
						 */
static RF_ShutdownList_t *globalShutdown;	/* Non array-specific stuff. */
int  rf_ConfigureRDFreeList(RF_ShutdownList_t **);

d165 1
a165 1
/* Called at system boot time. */
d167 1
a167 1
rf_BootRaidframe(void)
d169 1
a169 1
	int rc;
d177 2
a178 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n",
		    __FILE__, __LINE__, rc);
a185 2


d187 2
a188 2
 * This function is really just for debugging user-level stuff: It
 * frees up all memory, other RAIDframe resources that might otherwise
d192 2
a193 2
int
rf_UnbootRaidframe(void)
d195 1
a195 1
	int rc;
d206 2
a207 2
		RF_ERRORMSG3("Unable to destroy mutex file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
a211 2


d213 1
a213 1
 * Called whenever an array is shutdown.
d215 2
a216 2
void
rf_UnconfigureArray(void)
d218 1
a218 1
	int rc;
d221 2
a222 4
	if (--configureCount == 0) {	/*
					 * If no active configurations, shut
					 * everything down.
					 */
d227 1
a227 2
			RF_ERRORMSG1("RAIDFRAME: unable to do global shutdown,"
			    " rc=%d.\n", rc);
d231 3
a233 3
		 * We must wait until now, because the AllocList module
		 * uses the DebugMem module.
		 */
a238 2


d242 3
a244 2
int
rf_Shutdown(RF_Raid_t *raidPtr)
d247 1
a247 2
		RF_ERRORMSG("Attempt to shut down unconfigured RAIDframe"
		    " driver. Aborting shutdown.\n");
d251 7
a257 7
	 * Wait for outstanding IOs to land.
	 * As described in rf_raid.h, we use the rad_freelist lock
	 * to protect the per-array info about outstanding descs,
	 * since we need to do freelist locking anyway, and this
	 * cuts down on the amount of serialization we've got going
	 * on.
	 */
d289 51
a339 55
#define	DO_INIT_CONFIGURE(f)						\
do {									\
	rc = f (&globalShutdown);					\
	if (rc) {							\
		RF_ERRORMSG2("RAIDFRAME: failed %s with %d.\n",		\
		    RF_STRING(f), rc);					\
		rf_ShutdownList(&globalShutdown);			\
		configureCount--;					\
		RF_UNLOCK_MUTEX(configureMutex);			\
		return(rc);						\
	}								\
} while (0)

#define	DO_RAID_FAIL()							\
do {									\
	rf_UnconfigureVnodes(raidPtr);					\
	rf_ShutdownList(&raidPtr->shutdownList);			\
	rf_UnconfigureArray();						\
} while (0)

#define	DO_RAID_INIT_CONFIGURE(f)					\
do {									\
	rc = (f)(&raidPtr->shutdownList, raidPtr, cfgPtr);		\
	if (rc) {							\
		RF_ERRORMSG2("RAIDFRAME: failed %s with %d.\n",		\
		    RF_STRING(f), rc);					\
		DO_RAID_FAIL();						\
		return(rc);						\
	}								\
} while (0)

#define	DO_RAID_MUTEX(_m_)						\
do {									\
	rc = rf_create_managed_mutex(&raidPtr->shutdownList, (_m_));	\
	if (rc) {							\
		RF_ERRORMSG3("Unable to init mutex file %s line %d"	\
		    " rc=%d.\n", __FILE__, __LINE__, rc);		\
		DO_RAID_FAIL();						\
		return(rc);						\
	}								\
} while (0)

#define	DO_RAID_COND(_c_)						\
do {									\
	rc = rf_create_managed_cond(&raidPtr->shutdownList, (_c_));	\
	if (rc) {							\
		RF_ERRORMSG3("Unable to init cond file %s line %d"	\
		    " rc=%d.\n", __FILE__, __LINE__, rc);		\
		DO_RAID_FAIL();						\
		return(rc);						\
	}								\
} while (0)

int
rf_Configure(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr, RF_AutoConfig_t *ac)
d342 1
a342 1
	int i, rc;
d344 4
a347 5
	/*
	 * XXX This check can probably be removed now, since
	 * RAIDFRAME_CONFIGURE now checks to make sure that the
	 * RAID set is not already valid.
	 */
d349 1
a349 2
		RF_ERRORMSG("RAIDframe configuration not shut down."
		    " Aborting configure.\n");
d357 2
a358 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			    " rc=%d.\n", __FILE__, __LINE__, rc);
d362 2
a363 3
		/* Initialize globals. */
#ifdef	RAIDDEBUG
		printf("RAIDFRAME: protectedSectors is %ld.\n",
a364 1
#endif	/* RAIDDEBUG */
d371 2
a372 2
		 * Yes, this does make debugging general to the whole
		 * system instead of being array specific. Bummer, drag.
d396 2
a397 4
	/*
	 * Set up the cleanup list. Do this after ConfigureDebug so that
	 * value of memDebug will be set.
	 */
d405 2
a406 1
	    (void (*) (void *)) rf_FreeAllocList, raidPtr->cleanupList);
d408 2
a409 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
d417 2
a418 4
	/*
	 * XXX We don't even pretend to support more than one row in the
	 * kernel...
	 */
d424 2
a425 2
	RF_CallocAndAdd(raidPtr->status, raidPtr->numRow,
	    sizeof(RF_RowStatus_t), (RF_RowStatus_t *), raidPtr->cleanupList);
d456 4
a459 6
	if (ac != NULL) {
		/*
		 * We have an AutoConfig structure... Don't do the
		 * normal disk configuration... call the auto config
		 * stuff.
		 */
d465 2
a466 4
	/*
	 * Do this after ConfigureDisks & ConfigureSpareDisks to be sure
	 * devno is set.
	 */
d476 2
a477 2
			 * XXX Better distribution.
			 */
d488 2
a489 4
	/*
	 * Autoconfigure and root_partition will actually get filled in
	 * after the config is done.
	 */
d504 3
a506 2
int
rf_init_rad(RF_RaidAccessDesc_t *desc)
d508 1
a508 1
	int rc;
d512 1
a512 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n", __FILE__,
d518 1
a518 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d.\n", __FILE__,
d526 3
a528 2
void
rf_clean_rad(RF_RaidAccessDesc_t *desc)
d534 3
a536 2
void
rf_ShutdownRDFreeList(void *ignored)
d538 1
a538 2
	RF_FREELIST_DESTROY_CLEAN(rf_rad_freelist, next,
	    (RF_RaidAccessDesc_t *), rf_clean_rad);
d541 3
a543 2
int
rf_ConfigureRDFreeList(RF_ShutdownList_t **listp)
d545 1
a545 1
	int rc;
d554 1
a554 1
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d.\n", __FILE__,
d560 1
a560 1
	    (RF_RaidAccessDesc_t *), rf_init_rad);
d566 12
a577 13
    RF_Raid_t			 *raidPtr,
    RF_IoType_t			  type,
    RF_RaidAddr_t		  raidAddress,
    RF_SectorCount_t		  numBlocks,
    caddr_t			  bufPtr,
    void			 *bp,
    RF_DagHeader_t		**paramDAG,
    RF_AccessStripeMapHeader_t	**paramASM,
    RF_RaidAccessFlags_t	  flags,
    void			(*cbF) (struct buf *),
    void			 *cbA,
    RF_AccessState_t		 *states
)
d581 1
a581 2
	RF_FREELIST_GET_INIT_NOUNLOCK(rf_rad_freelist, desc, next,
	    (RF_RaidAccessDesc_t *), rf_init_rad);
d584 3
a586 3
		 * Actually, we're shutting the array down. Free the desc
		 * and return NULL.
		 */
d588 1
a588 2
		RF_FREELIST_FREE_CLEAN(rf_rad_freelist, desc, next,
		    rf_clean_rad);
d618 1
a618 1
void
d626 1
a626 1
	RF_FREELIST_FREE_CLEAN_NOUNLOCK(rf_rad_freelist, desc, next, rf_clean_rad);
d633 1
a633 3


/********************************************************************
d635 1
a635 1
 * Accesses are retried until a DAG can not be selected. This occurs
d639 1
a639 1
int
d641 18
a658 22
    RF_Raid_t			 *raidPtr,
    RF_IoType_t			  type,		/* Should be read or write. */
    int				  async_flag,	/*
						 * Should be RF_TRUE
						 * or RF_FALSE.
						 */
    RF_RaidAddr_t		  raidAddress,
    RF_SectorCount_t		  numBlocks,
    caddr_t			  bufPtr,
    void			 *bp_in,	/*
						 * It's a buf pointer.
						 * void * to facilitate
						 * ignoring it outside
						 * the kernel.
						 */
    RF_DagHeader_t		**paramDAG,
    RF_AccessStripeMapHeader_t	**paramASM,
    RF_RaidAccessFlags_t	  flags,
    RF_RaidAccessDesc_t		**paramDesc,
    void			(*cbF) (struct buf *),
    void			 *cbA
)
d667 1
a667 2
		RF_ERRORMSG("RAIDframe driver not successfully configured."
		    " Rejecting access.\n");
d674 1
a674 1
		printf("logBytes is: %d %d %d.\n", raidPtr->raidid,
d677 1
a677 1
		printf("raid%d: %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx.\n", raidPtr->raidid,
d687 1
a687 1
		printf("DoAccess: raid addr %lu too large to access %lu sectors. Max legal addr is %lu.\n",
d708 6
a713 5


/* Force the array into reconfigured mode without doing reconstruction. */
int
rf_SetReconfiguredMode(RF_Raid_t *raidPtr, int row, int col)
d716 1
a716 2
		printf("Can't set reconfigured mode in dedicated-spare"
		    " array.\n");
d724 2
a725 4
	/*
	 * Install spare table only if declustering + distributed sparing
	 * architecture.
	 */
d735 6
a740 2
int
rf_FailDisk(RF_Raid_t *raidPtr, int frow, int fcol, int initRecon)
d742 1
a742 1
	printf("raid%d: Failing disk r%d c%d.\n", raidPtr->raidid, frow, fcol);
d753 2
a754 5


/*
 * Releases a thread that is waiting for the array to become quiesced.
 * access_suspend_mutex should be locked upon calling this.
d756 4
a759 2
void
rf_SignalQuiescenceLock(RF_Raid_t *raidPtr, RF_RaidReconDesc_t *reconDesc)
d762 1
a762 1
		printf("raid%d: Signalling quiescence lock.\n",
d771 4
a774 8


/*
 * Suspends all new requests to the array. No effect on accesses that are
 * in flight.
 */
int
rf_SuspendNewRequestsAndWait(RF_Raid_t *raidPtr)
d777 1
a777 1
		printf("Suspending new reqs.\n");
d786 1
a786 1
			printf("Suspending: Waiting for Quiescence.\n");
d791 1
a791 1
	printf("Quiescence reached...\n");
d796 4
a799 5


/* Wake up everyone waiting for quiescence to be released. */
void
rf_ResumeNewRequests(RF_Raid_t *raidPtr)
d804 1
a804 1
		printf("Resuming new reqs.\n");
d822 1
a822 3


/*****************************************************************************
d824 1
a824 1
 * Debug routines.
d826 1
a826 1
 *****************************************************************************/
d828 4
a831 2
void
rf_set_debug_option(char *name, long val)
d846 1
a846 1
/* Would like to use sscanf here, but apparently not available in kernel. */
d848 7
a854 6
void
rf_ConfigureDebug(RF_Config_t *cfgPtr)
{
	char *val_p, *name_p, *white_p;
	long val;
	int i;
d859 2
a860 4
		white_p = rf_find_white(name_p);	/*
							 * Skip to start of 2nd
							 * word.
							 */
d867 1
a867 1
		rf_set_debug_option(name_p, val);
d870 1
d872 1
a872 4

/* Performance monitoring stuff. */

#if	!defined(_KERNEL) && !defined(SIMULATE)
d875 1
a875 1
 * Throughput stats currently only used in user-level RAIDframe.
d878 5
a882 3
int
rf_InitThroughputStats(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d884 1
a884 1
	int rc;
d886 1
a886 1
	/* These used by user-level RAIDframe only. */
d889 2
a890 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d.\n",
		    __FILE__, __LINE__, rc);
d899 2
a900 2
void
rf_StartThroughputStats(RF_Raid_t *raidPtr)
d910 2
a911 2
void
rf_StopThroughputStats(RF_Raid_t *raidPtr)
d919 1
a919 2
		RF_TIMEVAL_DIFF(&raidPtr->throughputstats.start,
		    &raidPtr->throughputstats.stop, &diff);
d925 2
a926 2
void
rf_PrintThroughputStats(RF_Raid_t *raidPtr)
d930 2
a931 3
		printf("[Througphut: %8.2f IOs/second]\n",
		    raidPtr->throughputstats.num_ios /
		    (raidPtr->throughputstats.sum_io_us / 1000000.0));
d934 1
d936 2
a937 4
#endif	/* !_KERNEL && !SIMULATE */

void
rf_StartUserStats(RF_Raid_t *raidPtr)
d945 2
a946 2
void
rf_StopUserStats(RF_Raid_t *raidPtr)
d951 5
a955 6
void
rf_UpdateUserStats(
    RF_Raid_t	*raidPtr,
    int		 rt,		/* Response time in us. */
    int		 numsect	/* Number of sectors for this access. */
)
d962 2
a963 2
void
rf_PrintUserStats(RF_Raid_t *raidPtr)
d968 1
a968 2
	RF_TIMEVAL_DIFF(&raidPtr->userstats.start, &raidPtr->userstats.stop,
	    &diff);
d971 1
a971 1
	/* 2000 sectors per megabyte, 10000000 microseconds per second. */
d973 1
a973 2
		mbs = (raidPtr->userstats.num_sect_moved / 2000) /
		    (elapsed_us / 1000000);
d977 1
a977 1
	/* This computes only the first digit of the fractional mb/s moved. */
d979 2
a980 2
		mbs_frac = ((raidPtr->userstats.num_sect_moved / 200) /
		    (elapsed_us / 1000000)) - (mbs * 10);
d985 7
a991 16
	printf("Number of I/Os:             %ld\n",
	    raidPtr->userstats.num_ios);
	printf("Elapsed time (us):          %ld\n",
	    elapsed_us);
	printf("User I/Os per second:       %ld\n",
	    RF_DB0_CHECK(raidPtr->userstats.num_ios, (elapsed_us / 1000000)));
	printf("Average user response time: %ld us\n",
	    RF_DB0_CHECK(raidPtr->userstats.sum_io_us,
	     raidPtr->userstats.num_ios));
	printf("Total sectors moved:        %ld\n",
	    raidPtr->userstats.num_sect_moved);
	printf("Average access size (sect): %ld\n",
	    RF_DB0_CHECK(raidPtr->userstats.num_sect_moved,
	    raidPtr->userstats.num_ios));
	printf("Achieved data rate:         %ld.%ld MB/sec\n",
	    mbs, mbs_frac);
@


1.7
log
@sync with NetBSD
- remove unused are from IO_BUF_ERR in rf_driver.c
- remove unused define in rf_stripelocks.c
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_driver.c,v 1.6 2000/01/07 14:50:21 peter Exp $	*/
/*	$NetBSD: rf_driver.c,v 1.20 2000/01/07 03:03:44 oster Exp $	*/
a96 1
#include "rf_threadid.h"
a107 1
#include "rf_diskthreads.h"
d119 1
a119 1
#include "rf_cpuutil.h"
a144 6
/* XXX move these to their own .h file! */
int raidwrite_component_label(dev_t, struct vnode *, RF_ComponentLabel_t *);
int raidread_component_label(dev_t, struct vnode *, RF_ComponentLabel_t *);
int raidmarkclean(dev_t dev, struct vnode *b_vp,int);
void rf_update_component_labels( RF_Raid_t *);

a146 2
RF_DECLARE_GLOBAL_THREADID	/* declarations for threadid.h */

d159 2
a160 2
	static int configureCount = 0;	/* number of active configurations */
	static int isconfigged = 0;	/* is basic raidframe (non per-array)
d164 2
a165 4
	static RF_ShutdownList_t *globalShutdown;	/* non array-specific
							 * stuff */

	static int rf_ConfigureRDFreeList(RF_ShutdownList_t ** listp);
a176 3
	rf_setup_threadid();
	rf_assign_threadid();

a230 1
		rf_shutdown_threadid();
a417 1
		DO_INIT_CONFIGURE(rf_ConfigureCpuMonitor);
a629 1
	rf_get_threadid(desc->tid);
a674 1
	int     tid;
a686 1
	rf_get_threadid(tid);
d692 1
a692 1
		printf("[%d] %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx\n", tid,
d756 1
a756 4
	int     tid;

	rf_get_threadid(tid);
	printf("[%d] Failing disk r%d c%d\n", tid, frow, fcol);
a773 2
	int     tid;

d775 2
a776 2
		rf_get_threadid(tid);
		printf("[%d] Signalling quiescence lock\n", tid);
@


1.6
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_driver.c,v 1.5 1999/08/04 13:10:54 peter Exp $	*/
/*	$NetBSD: rf_driver.c,v 1.19 1999/12/07 02:54:08 oster Exp $	*/
d162 1
a162 1
#define IO_BUF_ERR(bp, err, unit) { \
d702 1
a702 1
		IO_BUF_ERR(bp, EINVAL, raidPtr->raidid);
d725 1
a725 1
			IO_BUF_ERR(bp, ENOSPC, raidPtr->raidid);
@


1.5
log
@* remove redundant rf_ccmn.h

* remove init call to rf_ConfigureEtimer() and rf_sys.c in which it is the
  only function. update conf/files to reflect this.

* update sources to make sure _KERNEL is used not KERNEL

* change rf_etimer.h to protect macros an include of sys/kernel.h with
  a check for _KERNEL - let raidctl compile again.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_driver.c,v 1.4 1999/08/03 13:56:37 peter Exp $	*/
/*	$NetBSD: rf_driver.c,v 1.12 1999/07/19 01:36:07 oster Exp $	*/
a117 3
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
#include "rf_camlayer.h"
#endif
a120 1
#include "rf_sys.h"
a124 8
#if DKUSAGE > 0
#include <sys/dkusage.h>
#include <io/common/iotypes.h>
#include <io/cam/dec_cam.h>
#include <io/cam/cam.h>
#include <io/cam/pdrv.h>
#endif				/* DKUSAGE > 0 */

a161 9
#if DKUSAGE > 0
#define IO_BUF_ERR(bp, err, unit) { \
	bp->b_flags |= B_ERROR; \
	bp->b_resid = bp->b_bcount; \
	bp->b_error = err; \
	RF_DKU_END_IO(unit, bp); \
	biodone(bp); \
}
#else
a165 1
	RF_DKU_END_IO(unit); \
a167 1
#endif				/* DKUSAGE > 0 */
a188 4
#if RF_DEBUG_ATOMIC > 0
	rf_atent_init();
#endif				/* RF_DEBUG_ATOMIC > 0 */

a226 3
#if RF_DEBUG_ATOMIC > 0
	rf_atent_shutdown();
#endif				/* RF_DEBUG_ATOMIC > 0 */
d309 1
a309 1
	p = raidPtr->proc;	/* XXX */
a391 1
	struct proc *p;
a427 3
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
		DO_INIT_CONFIGURE(rf_ConfigureCamLayer);
#endif
a445 1
	p = raidPtr->proc;	/* XXX save these... */
a447 1
	raidPtr->proc = p;	/* XXX and then recover them.. */
a696 7
#if DFSTRACE > 0
	struct {
		RF_uint64 raidAddr;
		int     numBlocks;
		char    type;
	}       dfsrecord;
#endif				/* DFSTRACE > 0 */
a704 8
#if defined(_KERNEL) && DFSTRACE > 0
	if (rf_DFSTraceAccesses) {
		dfsrecord.raidAddr = raidAddress;
		dfsrecord.numBlocks = numBlocks;
		dfsrecord.type = type;
		dfs_log(DFS_NOTE, (char *) &dfsrecord, sizeof(dfsrecord), 0);
	}
#endif				/* _KERNEL && DFSTRACE > 0 */
a724 1
		if (type == RF_IO_TYPE_READ) {
a726 4
		} else {
			IO_BUF_ERR(bp, ENOSPC, raidPtr->raidid);
			return (ENOSPC);
		}
@


1.4
log
@* rf_reconstruct.c: adopt nilkas' suggestion regard statics and
__inline__ - this is a proof of concept and will cover the raidframe
source as a whole over coming updates. Update namespace of function to
prefix with rf_ - comments again welcome.

* overall: rework the macros in rf_etimer.h and the resultant changes
to their use to count microseconds and not clock ticks. Restore the code
in rf_revent.c to a similar strcuture to before the previous commit,
and use the system timers to govern resource usage.

Tested with local i386/IDE and the reconstruction of a disk in my
array - performance has improved for reconstruction at no noticable
CPU cost.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_driver.c,v 1.3 1999/07/30 14:45:32 peter Exp $	*/
a443 1
		DO_INIT_CONFIGURE(rf_ConfigureEtimer);
d748 1
a748 1
#if defined(KERNEL) && DFSTRACE > 0
d755 1
a755 1
#endif				/* KERNEL && DFSTRACE > 0 */
d1028 1
a1028 1
#endif				/* !KERNEL && !SIMULATE */
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_driver.c,v 1.2 1999/02/16 00:02:41 niklas Exp $	*/
a966 2
#define TIMEVAL_TO_US(t) (((long) t.tv_sec) * 1000000L + (long) t.tv_usec)

d1015 1
a1015 1
		raidPtr->throughputstats.sum_io_us += TIMEVAL_TO_US(diff);
d1064 1
a1064 1
	elapsed_us = TIMEVAL_TO_US(diff);
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 38
a38 2
/*	$OpenBSD: rf_driver.c,v 1.1 1999/01/11 14:29:18 niklas Exp $	*/
/*	$NetBSD: rf_driver.c,v 1.6 1999/02/05 00:06:10 oster Exp $	*/
d157 7
d172 1
a172 1
	tsleep(&((_raid_)->accesses_suspended),PRIBIO|PCATCH,"raidframe quiesce", 0);
d203 2
a204 1
	int     rf_BootRaidframe()
a293 4
	int     r, c;

	struct proc *p;

d319 17
d345 4
a348 2
				(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,
				    FREAD | FWRITE, p->p_ucred, p);
d358 1
d361 1
a365 8



	rf_ShutdownList(&raidPtr->shutdownList);

	rf_UnconfigureArray();

	return (0);
d380 1
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_driver.c,v 1.2 1998/11/13 13:45:15 drochner Exp $	*/
/*	$NetBSD: rf_driver.c,v 1.2 1998/11/13 13:45:15 drochner Exp $	*/
a38 552
/*
 * :  
 * Log: rf_driver.c,v 
 * Revision 1.147  1996/08/21 04:12:46  jimz
 * added hook for starting out req_hist w/ more distributed values
 * (currently not done)
 *
 * Revision 1.146  1996/07/29  14:05:12  jimz
 * fix numPUs/numRUs confusion (everything is now numRUs)
 * clean up some commenting, return values
 *
 * Revision 1.145  1996/07/28  20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.144  1996/07/27  18:40:24  jimz
 * cleanup sweep
 *
 * Revision 1.143  1996/07/22  21:11:53  jimz
 * fix formatting on DoAccess error msg
 *
 * Revision 1.142  1996/07/19  16:10:06  jimz
 * added call to rf_ResetDebugOptions() in rf_ConfigureDebug()
 *
 * Revision 1.141  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.140  1996/07/17  21:00:58  jimz
 * clean up timer interface, tracing
 *
 * Revision 1.139  1996/07/15  05:40:41  jimz
 * some recon datastructure cleanup
 * better handling of multiple failures
 * added undocumented double-recon test
 *
 * Revision 1.138  1996/07/11  19:08:00  jimz
 * generalize reconstruction mechanism
 * allow raid1 reconstructs via copyback (done with array
 * quiesced, not online, therefore not disk-directed)
 *
 * Revision 1.137  1996/07/10  22:28:00  jimz
 * get rid of obsolete row statuses (dead,degraded2)
 *
 * Revision 1.136  1996/06/17  14:38:33  jimz
 * properly #if out RF_DEMO code
 * fix bug in MakeConfig that was causing weird behavior
 * in configuration routines (config was not zeroed at start)
 * clean up genplot handling of stacks
 *
 * Revision 1.135  1996/06/17  03:20:32  jimz
 * move out raidframe_attr_default
 * don't monkey with stack sizes
 *
 * Revision 1.134  1996/06/14  23:15:38  jimz
 * attempt to deal with thread GC problem
 *
 * Revision 1.133  1996/06/14  21:24:08  jimz
 * new ConfigureEtimer init
 * moved out timer vars
 *
 * Revision 1.132  1996/06/14  16:19:03  jimz
 * remove include of pdllib.h (beginning of PDL cleanup)
 *
 * Revision 1.131  1996/06/14  14:35:24  jimz
 * clean up dfstrace protection
 *
 * Revision 1.130  1996/06/14  14:16:09  jimz
 * engine config is now array-specific
 *
 * Revision 1.129  1996/06/13  19:08:10  jimz
 * add debug var to force keep_acc_totals on
 *
 * Revision 1.128  1996/06/11  10:57:08  jimz
 * init recon_done_proc_mutex
 *
 * Revision 1.127  1996/06/10  14:18:58  jimz
 * move user, throughput stats into per-array structure
 *
 * Revision 1.126  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.125  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.124  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.123  1996/06/05  19:38:32  jimz
 * fixed up disk queueing types config
 * added sstf disk queueing
 * fixed exit bug on diskthreads (ref-ing bad mem)
 *
 * Revision 1.122  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.121  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.120  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.119  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.118  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.117  1996/05/30  16:28:33  jimz
 * typo in rf_SignalQuiescenceLock() fixed
 *
 * Revision 1.116  1996/05/30  12:59:18  jimz
 * make etimer happier, more portable
 *
 * Revision 1.115  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.114  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.113  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.112  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.111  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.110  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.109  1996/05/23  00:39:56  jimz
 * demoMode -> rf_demoMode
 *
 * Revision 1.108  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.107  1996/05/21  14:30:04  jimz
 * idler_desc_mutex should be ifndef SIMULATE
 *
 * Revision 1.106  1996/05/20  19:31:12  jimz
 * add atomic debug (mutex and cond leak finder) stuff
 *
 * Revision 1.105  1996/05/20  16:12:45  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.104  1996/05/18  20:09:41  jimz
 * bit of cleanup to compile cleanly in kernel, once again
 *
 * Revision 1.103  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.102  1996/05/16  21:20:51  jimz
 * use FREELIST stuff to manage access descriptors
 *
 * Revision 1.101  1996/05/16  14:21:10  jimz
 * remove bogus copies from write path on user
 *
 * Revision 1.100  1996/05/15  22:33:54  jimz
 * appropriately #ifdef cache stuff
 *
 * Revision 1.99  1996/05/08  21:34:41  jimz
 * #if 0 ShutdownCache() and ConfigureCache()
 *
 * Revision 1.98  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.97  1996/05/07  19:02:58  wvcii
 * corrected header comment of rf_DoAccess()
 * reordered free of desc in FreeRaidAccDesc()  The desc is now
 * freed last.
 *
 * Revision 1.96  1996/05/07  17:40:50  jimz
 * add doDebug
 *
 * Revision 1.95  1996/05/06  21:35:23  jimz
 * fixed ordering of cleanup and removed extra decrement of configureCount
 *
 * Revision 1.94  1996/05/06  18:44:14  jimz
 * reorder cleanup to not blow alloclist out from under various modules
 * zero raidPtr contents on config
 *
 * Revision 1.93  1996/05/04  17:06:53  jimz
 * Fail the I/O with ENOSPC if reading past end of the array in the kernel.
 *
 * Revision 1.92  1996/05/03  19:44:22  wvcii
 * debug vars degDagDebug and enableAtomicRMW now defined
 * in this file.
 *
 * Revision 1.91  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.90  1995/12/08  15:07:03  arw
 * cache code cleanup
 *
 * Revision 1.89  1995/12/06  20:53:58  wvcii
 * created debug var forceParityLogReint
 * this variable forces reintegration of all parity logs at shutdown
 *
 * Revision 1.88  1995/12/01  15:59:10  root
 * added copyright info
 *
 * Revision 1.87  1995/11/28  21:34:02  amiri
 * modified SetReconfiguredMode so that it installs the
 * spare table only if arch is declustered based on block designs
 *
 * Revision 1.86  1995/11/21  23:06:11  amiri
 * added division by zero check in printing
 * throughput stats.
 *
 * Revision 1.85  1995/11/19  16:27:25  wvcii
 * disableParityVerify now defined locally, only read from config
 * file for !KERNEL compiles
 *
 * Revision 1.84  1995/11/17  15:08:31  wvcii
 * added debug var disableParityVerify
 * used in RealLoopTest to disable parity verification
 *
 * Revision 1.83  1995/11/07  15:48:43  wvcii
 * deleted debug vars: suppressAtomicRMW, enableRollAway, concatDagDebug
 * deleted debug vars: debugSelectUnit, debugSelectBlock
 * added debug var: enableAtomicRMW
 *
 * Revision 1.82  1995/10/18  19:28:45  amiri
 * added support for reconstruction demos in the
 * simulator, by updating some simulator
 * variables in Faildisk.
 *
 * Revision 1.81  1995/10/09  18:36:33  jimz
 * move rf_StopThroughputStats() into FreeAccDesc()
 * changed throughput output print format
 * added user-level copy to write path to emulate kernel hack
 *
 * Revision 1.80  1995/10/09  18:07:47  wvcii
 * moved call to rf_StopThroughputStats to rf_states.c
 *
 * Revision 1.79  1995/10/09  17:38:53  jimz
 * quiesce an array for user-level testing before shutting it down
 * (should this also be done in the kernel?)
 *
 * Revision 1.78  1995/10/09  15:35:43  wvcii
 * added code to measure throughput in user mode
 *
 * Revision 1.77  1995/10/05  06:18:59  jimz
 * Changed DDEventRequest() to take additional arg, used by simulator
 * to cache diskid so queue length can be decremented on io complete
 * (this is a hack to get around the fact that the event mechanism
 * assumes it can dereference arbitrary handles on enqueued events)
 *
 * Revision 1.76  1995/10/04  07:25:10  jimz
 * turn off bigstacks by default
 *
 * Revision 1.75  1995/10/04  07:24:34  jimz
 * code for bigstacks in user process
 *
 * Revision 1.74  1995/09/26  21:42:51  wvcii
 * removed calls to ConfigureCache, ShutdownCache when building kernel
 * kernel currently does not support any cached architectures
 *
 * Revision 1.73  1995/09/20  21:05:35  jimz
 * add missing unit arg to IO_BUF_ERR() in non-kernel case
 *
 * Revision 1.72  1995/09/19  23:02:44  jimz
 * call RF_DKU_END_IO in the appropriate places
 *
 * Revision 1.71  1995/09/07  19:02:31  jimz
 * mods to get raidframe to compile and link
 * in kernel environment
 *
 * Revision 1.70  1995/09/06  19:24:01  wvcii
 * added debug vars enableRollAway and debugRecovery
 *
 * Revision 1.69  1995/08/24  19:25:36  rachad
 * Fixes to LSS GC in the simulater
 *
 * Revision 1.68  1995/07/28  21:43:42  robby
 * checkin after leaving for Rice. Bye
 *
 * Revision 1.67  1995/07/26  18:06:52  cfb
 * *** empty log message ***
 *
 * Revision 1.66  1995/07/26  03:25:24  robby
 * fixed accesses mutex and updated call to ConfigureCache
 *
 * Revision 1.65  1995/07/25  14:36:52  rachad
 * *** empty log message ***
 *
 * Revision 1.64  1995/07/21  19:29:05  robby
 * added total_accesses
 *
 * Revision 1.63  1995/07/20  19:43:35  cfb
 * *** empty log message ***
 *
 * Revision 1.62  1995/07/20  16:10:24  rachad
 * *** empty log message ***
 *
 * Revision 1.61  1995/07/20  03:36:53  rachad
 * Added suport for cache warming
 *
 * Revision 1.60  1995/07/17  22:31:31  cfb
 * *** empty log message ***
 *
 * Revision 1.59  1995/07/16  17:02:23  cfb
 * *** empty log message ***
 *
 * Revision 1.58  1995/07/16  15:19:27  cfb
 * *** empty log message ***
 *
 * Revision 1.57  1995/07/16  03:17:01  cfb
 * *** empty log message ***
 *
 * Revision 1.56  1995/07/13  16:11:59  cfb
 * *** empty log message ***
 *
 * Revision 1.55  1995/07/13  15:42:40  cfb
 * added cacheDebug variable ...
 *
 * Revision 1.54  1995/07/13  14:28:27  rachad
 * *** empty log message ***
 *
 * Revision 1.53  1995/07/10  21:48:52  robby
 * added virtualStripingWarnings
 *
 * Revision 1.52  1995/07/10  20:41:13  rachad
 * *** empty log message ***
 *
 * Revision 1.51  1995/07/09  19:46:49  cfb
 * Added cache Shutdown
 *
 * Revision 1.50  1995/07/08  21:38:53  rachad
 * Added support for interactive traces
 * in the simulator
 *
 * Revision 1.49  1995/07/08  18:05:39  rachad
 * Linked up Claudsons code with the real cache
 *
 * Revision 1.48  1995/07/07  16:00:22  cfb
 * Added initialization of cacheDesc to AllocRaidAccDesc
 *
 * Revision 1.47  1995/07/06  14:22:37  rachad
 * Merge complete
 *
 * Revision 1.46.50.2  1995/06/21  17:48:30  robby
 * test
 *
 * Revision 1.46.50.1  1995/06/21  17:34:49  robby
 * branching to work on "meta-dag" capabilities
 *
 * Revision 1.46.10.5  1995/07/03  21:58:34  holland
 * added support for suppressing both stripe locks & large writes
 *
 * Revision 1.46.10.4  1995/06/27  03:42:48  holland
 * typo fix
 *
 * Revision 1.46.10.3  1995/06/27  03:31:42  holland
 * prototypes
 *
 * Revision 1.46.10.2  1995/06/27  03:17:57  holland
 * fixed callback bug in kernel rf_DoAccess
 *
 * Revision 1.46.10.1  1995/06/25  14:32:44  holland
 * initial checkin on new branch
 *
 * Revision 1.46  1995/06/13  17:52:41  holland
 * added UserStats stuff
 *
 * Revision 1.45  1995/06/13  16:03:41  rachad
 * *** empty log message ***
 *
 * Revision 1.44  1995/06/12  15:54:40  rachad
 * Added garbege collection for log structured storage
 *
 * Revision 1.43  1995/06/09  18:01:09  holland
 * various changes related to in-kernel recon, multiple-row arrays,
 * trace extraction from kernel, etc.
 *
 * Revision 1.42  1995/06/08  19:52:28  rachad
 * *** empty log message ***
 *
 * Revision 1.41  1995/06/08  00:11:49  robby
 * added a debug variable -- showVirtualSizeRequirements
 *
 * Revision 1.40  1995/06/05  00:33:30  holland
 * protectedSectors bug fix
 *
 * Revision 1.39  1995/06/01  22:45:03  holland
 * made compilation of parity logging and virtual striping
 * stuff conditional on some constants defined in rf_archs.h
 *
 * Revision 1.38  1995/06/01  21:52:37  holland
 * replaced NULL sizes in calls to Free() by -1, and caused this
 * to suppress the size-mismatch error
 *
 * Revision 1.37  1995/05/26  20:04:54  wvcii
 * modified parity logging debug vars
 *
 * Revision 1.36  95/05/21  15:32:41  wvcii
 * added debug vars: parityLogDebug, numParityRegions, numParityLogs,
 * numReintegrationThreads
 * 
 * Revision 1.35  95/05/19  20:58:21  holland
 * cleanups on error cases in rf_DoAccess
 * 
 * Revision 1.34  1995/05/16  17:35:53  holland
 * added rf_copyback_in_progress.  this is debug-only.
 *
 * Revision 1.33  1995/05/15  12:25:35  holland
 * bug fix in test code: no stripe locks were getting acquired in RAID0 mode
 *
 * Revision 1.32  1995/05/10  18:54:12  holland
 * bug fixes related to deadlock problem at time of disk failure
 * eliminated read-op-write code
 * beefed up parity checking in loop test
 * various small changes & new ASSERTs
 *
 * Revision 1.31  1995/05/02  22:49:02  holland
 * add shutdown calls for each architecture
 *
 * Revision 1.30  1995/05/01  14:43:37  holland
 * merged changes from Bill
 *
 * Revision 1.29  1995/05/01  13:28:00  holland
 * parity range locks, locking disk requests, recon+parityscan in kernel, etc.
 *
 * Revision 1.28  1995/04/24  13:25:51  holland
 * rewrite to move disk queues, recon, & atomic RMW to kernel
 *
 * Revision 1.27  1995/04/06  14:47:56  rachad
 * merge completed
 *
 * Revision 1.26  1995/04/03  20:32:35  rachad
 * added reconstruction to simulator
 *
 * Revision 1.25.10.2  1995/04/03  20:41:00  holland
 * misc changes related to distributed sparing
 *
 * Revision 1.25.10.1  1995/03/17  20:04:01  holland
 * initial checkin on new branch
 *
 * Revision 1.25  1995/03/15  20:34:30  holland
 * changes for distributed sparing.
 *
 * Revision 1.24  1995/03/09  19:53:05  rachad
 * *** empty log message ***
 *
 * Revision 1.23  1995/03/03  18:36:16  rachad
 *  Simulator mechanism added
 *
 * Revision 1.22  1995/03/01  20:25:48  holland
 * kernelization changes
 *
 * Revision 1.21  1995/02/17  19:39:56  holland
 * added size param to all calls to Free().
 * this is ignored at user level, but necessary in the kernel.
 *
 * Revision 1.20  1995/02/17  13:37:49  holland
 * kernelization changes -- not yet complete
 *
 * Revision 1.19  1995/02/10  18:08:07  holland
 * fixed a few things I broke during kernelization
 *
 * Revision 1.18  1995/02/10  17:34:10  holland
 * kernelization changes
 *
 * Revision 1.17  1995/02/04  15:51:35  holland
 * kernelization changes
 *
 * Revision 1.16  1995/02/03  22:31:36  holland
 * many changes related to kernelization
 *
 * Revision 1.15  1995/02/01  15:13:05  holland
 * moved #include of general.h out of raid.h and into each file
 *
 * Revision 1.14  1995/02/01  14:25:19  holland
 * began changes for kernelization:
 *      changed all instances of mutex_t and cond_t to DECLARE macros
 *      converted configuration code to use config structure
 *
 * Revision 1.13  1995/01/30  14:53:46  holland
 * extensive changes related to making DoIO non-blocking
 *
 * Revision 1.12  1995/01/25  00:26:21  holland
 * eliminated support for aio
 *
 * Revision 1.11  1995/01/24  23:58:46  holland
 * multi-way recon XOR, plus various small changes
 *
 * Revision 1.10  1995/01/11  19:27:02  holland
 * various changes related to performance tuning
 *
 * Revision 1.9  1994/12/05  15:29:09  holland
 * added trace run time limitation (maxTraceRunTimeSec)
 *
 * Revision 1.8  1994/12/05  04:18:12  holland
 * various new control vars in the config file
 *
 * Revision 1.7  1994/11/29  23:11:36  holland
 * tracerec bug on dag retry fixed
 *
 * Revision 1.6  1994/11/29  22:11:38  danner
 * holland updates
 *
 * Revision 1.5  1994/11/29  21:09:47  danner
 * Detailed tracing support (holland).
 *
 * Revision 1.4  1994/11/29  20:36:02  danner
 * Added suppressAtomicRMW option.
 *
 * Revision 1.3  1994/11/21  15:34:06  danner
 * Added ConfigureAllocList() call.
 * 
 */

#ifdef _KERNEL
#define KERNEL
#endif

#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
d44 1
a44 1
#ifdef __NETBSD__
a46 1
#endif
a47 6
#ifdef KERNEL
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
#include <dkusage.h>
#include <dfstrace.h>
#endif /* !__NetBSD__ && !__OpenBSD__ */
#endif /* KERNEL */
a51 4
#ifndef KERNEL
#include <stdio.h>
#include <stdlib.h>
#endif /* KERNEL */
a90 5
#ifdef SIMULATE
#include "rf_diskevent.h"
#endif /* SIMULATE */

#ifdef KERNEL
a91 8
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
#include <io/common/devdriver.h>
#endif /* !__NetBSD__ && !__OpenBSD__ */

#if DFSTRACE > 0
#include <sys/dfs_log.h>
#include <sys/dfstracebuf.h>
#endif /* DFSTRACE > 0 */
d99 1
a99 6
#endif /* DKUSAGE > 0 */
#endif /* KERNEL */

#if RF_DEMO > 0
#include "rf_demo.h"
#endif /* RF_DEMO > 0 */
d108 1
a108 1
char rf_panicbuf[2048];       /* a buffer to hold an error msg when we panic */ 
d113 1
a113 1
static void rf_ConfigureDebug(RF_Config_t *cfgPtr);
d122 3
a124 2
RF_DECLARE_MUTEX(rf_printf_mutex)          /* debug only:  avoids interleaved printfs by different stripes */
RF_DECLARE_GLOBAL_THREADID                 /* declarations for threadid.h */
a125 5
#if !defined(KERNEL) && !defined(SIMULATE)
static int rf_InitThroughputStats(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr, RF_Config_t *cfgPtr);
static void rf_StopThroughputStats(RF_Raid_t *raidPtr);
static void rf_PrintThroughputStats(RF_Raid_t *raidPtr);
#endif /* !KERNEL && !SIMULATE */
a126 1
#ifdef KERNEL
a127 5
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
#define WAIT_FOR_QUIESCENCE(_raid_) \
  mpsleep(&((_raid_)->accesses_suspended), PZERO, "raidframe quiesce", 0, \
      (void *) simple_lock_addr((_raid_)->access_suspend_mutex), MS_LOCK_SIMPLE)
#else
a130 1
#endif
d147 1
a147 12
#endif /* DKUSAGE > 0 */
#else /* KERNEL */

#define SIGNAL_QUIESCENT_COND(_raid_)  RF_SIGNAL_COND((_raid_)->quiescent_cond)
#define WAIT_FOR_QUIESCENCE(_raid_)    RF_WAIT_COND((_raid_)->quiescent_cond, (_raid_)->access_suspend_mutex)
#define IO_BUF_ERR(bp, err, unit)

#endif /* KERNEL */

static int configureCount=0;         /* number of active configurations */
static int isconfigged=0;            /* is basic raidframe (non per-array) stuff configged */
RF_DECLARE_STATIC_MUTEX(configureMutex) /* used to lock the configuration stuff */
d149 7
a155 1
static RF_ShutdownList_t *globalShutdown; /* non array-specific stuff */
d157 1
a157 1
static int rf_ConfigureRDFreeList(RF_ShutdownList_t **listp);
d160 1
a160 1
int rf_BootRaidframe()
d162 1
a162 4
#if 0
  long stacksize;
#endif
  int rc;
d164 3
a166 3
  if (raidframe_booted)
    return(EBUSY);
  raidframe_booted = 1;
d169 2
a170 2
  rf_atent_init();
#endif /* RF_DEBUG_ATOMIC > 0 */
d172 2
a173 2
  rf_setup_threadid();
  rf_assign_threadid();
d175 10
a184 29
#if !defined(KERNEL) && !defined(SIMULATE)
  if (RF_THREAD_ATTR_CREATE(raidframe_attr_default)) {
    fprintf(stderr, "Unable to create default thread attr\n");
    exit(1);
  }
#if 0
  stacksize = RF_THREAD_ATTR_GETSTACKSIZE(raidframe_attr_default);
  if (stacksize < 0) {
    fprintf(stderr, "Unable to get stack size of default thread attr\n");
    exit(1);
  }
  stacksize += 16384;
  rc = RF_THREAD_ATTR_SETSTACKSIZE(raidframe_attr_default, stacksize);
  if (rc) {
    fprintf(stderr, "Unable to set stack size of default thread attr\n");
    exit(1);
  }
#endif /* 0 */
#endif /* !KERNEL && !SIMULATE */
  rc = rf_mutex_init(&configureMutex);
  if (rc) {
    RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    RF_PANIC();
  }
  configureCount = 0;
  isconfigged = 0;
  globalShutdown = NULL;
  return(0);
a185 1

d192 2
a193 1
int rf_UnbootRaidframe()
d195 1
a195 1
	int rc;
d200 1
a200 1
		return(EBUSY);
d207 1
a207 1
			__LINE__, rc);
d212 2
a213 2
#endif /* RF_DEBUG_ATOMIC > 0 */
	return(0);
a214 1

d218 2
a219 1
static void rf_UnconfigureArray()
d221 1
a221 1
  int rc;
d223 19
a241 19
  RF_LOCK_MUTEX(configureMutex);
  if (--configureCount == 0) {              /* if no active configurations, shut everything down */
    isconfigged = 0;

    rc = rf_ShutdownList(&globalShutdown);
    if (rc) {
      RF_ERRORMSG1("RAIDFRAME: unable to do global shutdown, rc=%d\n", rc);
    }

    rf_shutdown_threadid();

    /*
     * We must wait until now, because the AllocList module
     * uses the DebugMem module.
     */
    if (rf_memDebug)
      rf_print_unfreed();
  }
  RF_UNLOCK_MUTEX(configureMutex);
a242 1

d246 3
a248 2
int rf_Shutdown(raidPtr)
  RF_Raid_t   *raidPtr;
d250 29
a278 4
#if !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(_KERNEL)
  int rc;
#endif
  int r,c;
d280 1
a280 3
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  struct proc *p;
#endif
d282 23
a304 61
  if (!raidPtr->valid) {
    RF_ERRORMSG("Attempt to shut down unconfigured RAIDframe driver.  Aborting shutdown\n");
    return(EINVAL);
  }

  /*
   * wait for outstanding IOs to land
   * As described in rf_raid.h, we use the rad_freelist lock
   * to protect the per-array info about outstanding descs
   * since we need to do freelist locking anyway, and this
   * cuts down on the amount of serialization we've got going
   * on.
   */
  RF_FREELIST_DO_LOCK(rf_rad_freelist);
  if (raidPtr->waitShutdown) {
    RF_FREELIST_DO_UNLOCK(rf_rad_freelist);
    return(EBUSY);
  }
  raidPtr->waitShutdown = 1;
  while (raidPtr->nAccOutstanding) {
    RF_WAIT_COND(raidPtr->outstandingCond, RF_FREELIST_MUTEX_OF(rf_rad_freelist));
  }
  RF_FREELIST_DO_UNLOCK(rf_rad_freelist);

#if !defined(KERNEL) && !defined(SIMULATE)
  rf_PrintThroughputStats(raidPtr);
#endif /* !KERNEL && !SIMULATE */

  raidPtr->valid = 0;

#if !defined(KERNEL) && !defined(SIMULATE)
  rf_TerminateDiskQueues(raidPtr);           /* tell all disk queues to release any waiting threads */
  rf_ShutdownDiskThreads(raidPtr);           /* wait for all threads to exit */
#endif /* !KERNEL && !SIMULATE */

#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  /* We take this opportunity to close the vnodes like we should.. */

  p = raidPtr->proc; /* XXX */

  for(r=0;r<raidPtr->numRow;r++) {
	  for(c=0;c<raidPtr->numCol;c++) {
		  printf("Closing vnode for row: %d col: %d\n",r,c);
		  if (raidPtr->raid_cinfo[r][c].ci_vp) {
			  (void)vn_close(raidPtr->raid_cinfo[r][c].ci_vp, 
					 FREAD|FWRITE,  p->p_ucred, p); 
		  } else {
			  printf("vnode was NULL\n");
		  }
		  
	  }
  }
  for(r=0;r<raidPtr->numSpare;r++) {
	  printf("Closing vnode for spare: %d\n",r);
	  if (raidPtr->raid_cinfo[0][raidPtr->numCol+r].ci_vp) {
		  (void)vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol+r].ci_vp,
				 FREAD|FWRITE,  p->p_ucred, p); 
	  } else {
		  printf("vnode was NULL\n");
	  }
  }
a306 1
#endif
d308 1
a308 1
  rf_ShutdownList(&raidPtr->shutdownList);
d310 1
a310 1
  rf_UnconfigureArray();
d312 1
a312 1
  return(0);
d360 46
a405 52
int rf_Configure(raidPtr, cfgPtr)
  RF_Raid_t    *raidPtr;
  RF_Config_t  *cfgPtr;
{
  RF_RowCol_t row, col;
  int i, rc;
  int unit;
  struct proc *p;

  if (raidPtr->valid) {
    RF_ERRORMSG("RAIDframe configuration not shut down.  Aborting configure.\n");
    return(EINVAL);
  }

  RF_LOCK_MUTEX(configureMutex);
  configureCount++;
  if (isconfigged == 0) {
    rc = rf_create_managed_mutex(&globalShutdown, &rf_printf_mutex);
    if (rc) {
      RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
        __LINE__, rc);
      rf_ShutdownList(&globalShutdown);
      return(rc);
    }

    /* initialize globals */
    printf("RAIDFRAME: protectedSectors is %ld\n",rf_protectedSectors);

    rf_clear_debug_print_buffer();

    DO_INIT_CONFIGURE(rf_ConfigureAllocList);
    DO_INIT_CONFIGURE(rf_ConfigureEtimer);
    /*
     * Yes, this does make debugging general to the whole system instead
     * of being array specific. Bummer, drag.
     */
    rf_ConfigureDebug(cfgPtr);
    DO_INIT_CONFIGURE(rf_ConfigureDebugMem);
#ifdef SIMULATE
    rf_default_disk_names();
    DO_INIT_CONFIGURE(rf_DDEventInit);
#endif /* SIMULATE */
    DO_INIT_CONFIGURE(rf_ConfigureAccessTrace);
    DO_INIT_CONFIGURE(rf_ConfigureMapModule);
    DO_INIT_CONFIGURE(rf_ConfigureReconEvent);
    DO_INIT_CONFIGURE(rf_ConfigureCallback);
    DO_INIT_CONFIGURE(rf_ConfigureMemChunk);
    DO_INIT_CONFIGURE(rf_ConfigureRDFreeList);
    DO_INIT_CONFIGURE(rf_ConfigureNWayXor);
    DO_INIT_CONFIGURE(rf_ConfigureStripeLockFreeList);
    DO_INIT_CONFIGURE(rf_ConfigureMCPair);
#ifndef SIMULATE
d407 1
a407 1
    DO_INIT_CONFIGURE(rf_ConfigureCamLayer);
d409 87
a495 29
#endif /* !SIMULATE */
    DO_INIT_CONFIGURE(rf_ConfigureDAGs);
    DO_INIT_CONFIGURE(rf_ConfigureDAGFuncs);
    DO_INIT_CONFIGURE(rf_ConfigureDebugPrint);
    DO_INIT_CONFIGURE(rf_ConfigureReconstruction);
    DO_INIT_CONFIGURE(rf_ConfigureCopyback);
    DO_INIT_CONFIGURE(rf_ConfigureDiskQueueSystem);
    DO_INIT_CONFIGURE(rf_ConfigureCpuMonitor);
    isconfigged = 1;
  }
  RF_UNLOCK_MUTEX(configureMutex);

  /*
   * Null out the entire raid descriptor to avoid problems when we reconfig.
   * This also clears the valid bit.
   */
  /* XXX this clearing should be moved UP to outside of here.... that, or 
     rf_Configure() needs to take more arguments... XXX */
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  unit = raidPtr->raidid;
  p = raidPtr->proc;   /* XXX save these... */
#endif
  bzero((char *)raidPtr, sizeof(RF_Raid_t));
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  raidPtr->raidid = unit;
  raidPtr->proc = p;   /* XXX and then recover them..*/
#endif
  DO_RAID_MUTEX(&raidPtr->mutex);
  /* set up the cleanup list.  Do this after ConfigureDebug so that value of memDebug will be set */
d497 1
a497 29
  rf_MakeAllocList(raidPtr->cleanupList);
  if (raidPtr->cleanupList == NULL) {
    DO_RAID_FAIL();
    return(ENOMEM);
  }

  rc = rf_ShutdownCreate(&raidPtr->shutdownList, 
			 (void (*)(void *))rf_FreeAllocList, 
			 raidPtr->cleanupList);
  if (rc) {
    RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
      __FILE__, __LINE__, rc);
    DO_RAID_FAIL();
    return(rc);
  }

  raidPtr->numRow = cfgPtr->numRow;
  raidPtr->numCol = cfgPtr->numCol;
  raidPtr->numSpare = cfgPtr->numSpare;

#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  /* XXX we don't even pretend to support more than one row 
     in the kernel... */
  if (raidPtr->numRow != 1) {
	  RF_ERRORMSG("Only one row supported in kernel.\n");
	  DO_RAID_FAIL();
	  return(EINVAL);
  }
#endif
d499 1
d501 8
d510 4
a513 62
  RF_CallocAndAdd(raidPtr->status, raidPtr->numRow, sizeof(RF_RowStatus_t),
    (RF_RowStatus_t *), raidPtr->cleanupList);
  if (raidPtr->status == NULL) {
    DO_RAID_FAIL();
    return(ENOMEM);
  }

  RF_CallocAndAdd(raidPtr->reconControl, raidPtr->numRow,
    sizeof(RF_ReconCtrl_t *), (RF_ReconCtrl_t **), raidPtr->cleanupList);
  if (raidPtr->reconControl == NULL) {
    DO_RAID_FAIL();
    return(ENOMEM);
  }
  for (i=0; i<raidPtr->numRow; i++) {
    raidPtr->status[i] = rf_rs_optimal;
    raidPtr->reconControl[i] = NULL;
  }

  DO_RAID_INIT_CONFIGURE(rf_ConfigureEngine);
#if !defined(KERNEL) && !defined(SIMULATE)
  DO_RAID_INIT_CONFIGURE(rf_InitThroughputStats);
#endif /* !KERNEL && !SIMULATE */

  DO_RAID_INIT_CONFIGURE(rf_ConfigureStripeLocks);

  DO_RAID_COND(&raidPtr->outstandingCond);

  raidPtr->nAccOutstanding = 0;
  raidPtr->waitShutdown = 0;

  DO_RAID_MUTEX(&raidPtr->access_suspend_mutex);
  DO_RAID_COND(&raidPtr->quiescent_cond);

  DO_RAID_COND(&raidPtr->waitForReconCond);

  DO_RAID_MUTEX(&raidPtr->recon_done_proc_mutex);
  DO_RAID_INIT_CONFIGURE(rf_ConfigureDisks);
  DO_RAID_INIT_CONFIGURE(rf_ConfigureSpareDisks);
  /* do this after ConfigureDisks & ConfigureSpareDisks to be sure dev no. is set */
  DO_RAID_INIT_CONFIGURE(rf_ConfigureDiskQueues);
#ifndef KERNEL
  DO_RAID_INIT_CONFIGURE(rf_ConfigureDiskThreads);
#endif /* !KERNEL */

  DO_RAID_INIT_CONFIGURE(rf_ConfigureLayout);

  DO_RAID_INIT_CONFIGURE(rf_ConfigurePSStatus);

  for(row=0;row<raidPtr->numRow;row++) {
    for(col=0;col<raidPtr->numCol;col++) {
      /*
       * XXX better distribution
       */
      raidPtr->hist_diskreq[row][col] = 0;
    }
  }

  if (rf_keepAccTotals) {
    raidPtr->keep_acc_totals = 1;
  }

  rf_StartUserStats(raidPtr);
d515 2
a516 2
  raidPtr->valid = 1;
  return(0);
d519 3
a521 2
static int init_rad(desc)
  RF_RaidAccessDesc_t  *desc;
d523 1
a523 1
	int rc;
d528 2
a529 2
			__LINE__, rc);
		return(rc);
d534 1
a534 1
			__LINE__, rc);
d536 1
a536 1
		return(rc);
d538 1
a538 1
	return(0);
d541 3
a543 2
static void clean_rad(desc)
  RF_RaidAccessDesc_t  *desc;
d549 3
a551 2
static void rf_ShutdownRDFreeList(ignored)
  void  *ignored;
d553 1
a553 1
	RF_FREELIST_DESTROY_CLEAN(rf_rad_freelist,next,(RF_RaidAccessDesc_t *),clean_rad);
d556 3
a558 2
static int rf_ConfigureRDFreeList(listp)
  RF_ShutdownList_t **listp;
d560 1
a560 1
	int rc;
d563 1
a563 1
		RF_RAD_INC, sizeof(RF_RaidAccessDesc_t));
d565 1
a565 1
		return(ENOMEM);
d570 1
a570 1
			__LINE__, rc);
d572 33
a604 1
		return(rc);
d606 2
a607 87
	RF_FREELIST_PRIME_INIT(rf_rad_freelist, RF_RAD_INITIAL,next,
		(RF_RaidAccessDesc_t *),init_rad);
	return(0);
}

RF_RaidAccessDesc_t *rf_AllocRaidAccDesc(
  RF_Raid_t                    *raidPtr,
  RF_IoType_t                   type,
  RF_RaidAddr_t                 raidAddress,
  RF_SectorCount_t              numBlocks,
  caddr_t                       bufPtr,
  void                         *bp,
  RF_DagHeader_t              **paramDAG,
  RF_AccessStripeMapHeader_t  **paramASM,
  RF_RaidAccessFlags_t          flags,
  void                        (*cbF)(struct buf *),
  void                         *cbA,
  RF_AccessState_t             *states)
{
  RF_RaidAccessDesc_t *desc;

  RF_FREELIST_GET_INIT_NOUNLOCK(rf_rad_freelist,desc,next,(RF_RaidAccessDesc_t *),init_rad);
  if (raidPtr->waitShutdown) {
    /*
     * Actually, we're shutting the array down. Free the desc
     * and return NULL.
     */
    RF_FREELIST_DO_UNLOCK(rf_rad_freelist);
    RF_FREELIST_FREE_CLEAN(rf_rad_freelist,desc,next,clean_rad);
    return(NULL);
  }
  raidPtr->nAccOutstanding++;
  RF_FREELIST_DO_UNLOCK(rf_rad_freelist);
  
  desc->raidPtr     = (void*)raidPtr;
  desc->type        = type;
  desc->raidAddress = raidAddress;
  desc->numBlocks   = numBlocks;
  desc->bufPtr      = bufPtr;
  desc->bp          = bp;
  desc->paramDAG    = paramDAG;
  desc->paramASM    = paramASM;
  desc->flags       = flags;
  desc -> states    = states;
  desc -> state     = 0;

  desc->status      = 0;
  bzero((char *)&desc->tracerec, sizeof(RF_AccTraceEntry_t));
  desc->callbackFunc= (void (*)(RF_CBParam_t))cbF; /* XXX */
  desc->callbackArg = cbA;
  desc->next        = NULL;
  desc->head	    = desc;
  desc->numPending  = 0;
  desc->cleanupList = NULL;
  rf_MakeAllocList(desc->cleanupList);
  rf_get_threadid(desc->tid);
#ifdef SIMULATE
  desc->owner = rf_GetCurrentOwner();
#endif /* SIMULATE */
  return(desc);
}

void rf_FreeRaidAccDesc(RF_RaidAccessDesc_t *desc)
{
  RF_Raid_t *raidPtr = desc->raidPtr;

  RF_ASSERT(desc);

#if !defined(KERNEL) && !defined(SIMULATE)
  rf_StopThroughputStats(raidPtr);
#endif /* !KERNEL && !SIMULATE */

  rf_FreeAllocList(desc->cleanupList);
  RF_FREELIST_FREE_CLEAN_NOUNLOCK(rf_rad_freelist,desc,next,clean_rad);
    raidPtr->nAccOutstanding--;
    if (raidPtr->waitShutdown) {
      RF_SIGNAL_COND(raidPtr->outstandingCond);
    }
  RF_FREELIST_DO_UNLOCK(rf_rad_freelist);
}

#ifdef JIMZ
#define THREAD_NUMDESC 1024
#define THREAD_NUM 600
static RF_RaidAccessDesc_t *dest_hist[THREAD_NUM*THREAD_NUMDESC];
int jimz_access_num[THREAD_NUM];
#endif /* JIMZ */
d609 40
d655 15
a669 14
int rf_DoAccess(
  RF_Raid_t                    *raidPtr,
  RF_IoType_t                   type,
  int                           async_flag,
  RF_RaidAddr_t                 raidAddress, 
  RF_SectorCount_t              numBlocks,
  caddr_t                       bufPtr,
  void                         *bp_in,
  RF_DagHeader_t              **paramDAG,
  RF_AccessStripeMapHeader_t  **paramASM,
  RF_RaidAccessFlags_t          flags,
  RF_RaidAccessDesc_t         **paramDesc,
  void                        (*cbF)(struct buf *),
  void                         *cbA)
d676 4
a679 5
  int tid;
  RF_RaidAccessDesc_t *desc;
  caddr_t lbufPtr = bufPtr;
#ifdef KERNEL
  struct buf *bp = (struct buf *) bp_in;
d681 53
a733 13
  struct { RF_uint64 raidAddr; int numBlocks; char type;} dfsrecord;  
#endif /* DFSTRACE > 0 */
#else /* KERNEL */
  void *bp = bp_in;
#endif /* KERNEL */

  raidAddress += rf_raidSectorOffset;

  if (!raidPtr->valid) {
    RF_ERRORMSG("RAIDframe driver not successfully configured.  Rejecting access.\n");
    IO_BUF_ERR(bp, EINVAL, raidPtr->raidid);
    return(EINVAL);
  } 
d735 8
a742 82
#if defined(KERNEL) && DFSTRACE > 0
  if (rf_DFSTraceAccesses) {
    dfsrecord.raidAddr  = raidAddress;
    dfsrecord.numBlocks = numBlocks;
    dfsrecord.type      = type;
    dfs_log(DFS_NOTE, (char *) &dfsrecord, sizeof(dfsrecord), 0);
  }
#endif /* KERNEL && DFSTRACE > 0 */

  rf_get_threadid(tid);
  if (rf_accessDebug) {

	  printf("logBytes is: %d %d %d\n",raidPtr->raidid,
		 raidPtr->logBytesPerSector,
		 (int)rf_RaidAddressToByte(raidPtr,numBlocks));
    printf("[%d] %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx\n",tid,
	   (type==RF_IO_TYPE_READ) ? "READ":"WRITE", (int)raidAddress, 
	   (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress),
	   (int) rf_RaidAddressToStripeID(&raidPtr->Layout, raidAddress+numBlocks-1),
	   (int) numBlocks, 
	   (int) rf_RaidAddressToByte(raidPtr,numBlocks), 
	   (long) bufPtr);
  }

  if (raidAddress + numBlocks > raidPtr->totalSectors) {

    printf("DoAccess: raid addr %lu too large to access %lu sectors.  Max legal addr is %lu\n",
           (u_long)raidAddress,(u_long)numBlocks,(u_long)raidPtr->totalSectors);

#ifdef KERNEL
    if (type == RF_IO_TYPE_READ) {
      IO_BUF_ERR(bp, ENOSPC, raidPtr->raidid);
      return(ENOSPC);
    } else {
      IO_BUF_ERR(bp, ENOSPC, raidPtr->raidid);
      return(ENOSPC);
    }
#elif defined(SIMULATE)
    RF_PANIC();
#else /* SIMULATE */
    return(EIO);
#endif /* SIMULATE */
  }

#if !defined(KERNEL) && !defined(SIMULATE)
  rf_StartThroughputStats(raidPtr);
#endif /* !KERNEL && !SIMULATE */

  desc = rf_AllocRaidAccDesc(raidPtr, type, raidAddress,
			  numBlocks, lbufPtr, bp, paramDAG, paramASM,
			  flags, cbF, cbA, raidPtr->Layout.map->states);

  if (desc == NULL) {
    return(ENOMEM);
  }
#ifdef JIMZ
  dest_hist[(tid*THREAD_NUMDESC)+jimz_access_num[tid]]; jimz_access_num[tid]++;
#endif /* JIMZ */

  RF_ETIMER_START(desc->tracerec.tot_timer);

#ifdef SIMULATE
  /* simulator uses paramDesc to continue dag from test function */
  desc->async_flag=async_flag;

  *paramDesc=desc;
  
  return(0);
#endif /* SIMULATE */

  rf_ContinueRaidAccess(desc);

#ifndef KERNEL
  if (!(flags & RF_DAG_NONBLOCKING_IO)) {
    RF_LOCK_MUTEX(desc->mutex);
    while (!(desc->flags & RF_DAG_ACCESS_COMPLETE)) {
      RF_WAIT_COND(desc->cond, desc->mutex);
    }
    RF_UNLOCK_MUTEX(desc->mutex);
    rf_FreeRaidAccDesc(desc);
  }
#endif /* !KERNEL */
d744 1
a744 1
  return(0);
a745 1

d747 20
a766 18
int rf_SetReconfiguredMode(raidPtr, row, col)
  RF_Raid_t  *raidPtr;
  int         row;
  int         col;
{
  if (!(raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
    printf("Can't set reconfigured mode in dedicated-spare array\n");
    RF_PANIC();
  }
  RF_LOCK_MUTEX(raidPtr->mutex);
  raidPtr->numFailures++;
  raidPtr->Disks[row][col].status = rf_ds_dist_spared;
  raidPtr->status[row] = rf_rs_reconfigured;
  /* install spare table only if declustering + distributed sparing architecture. */
  if ( raidPtr->Layout.map->flags & RF_BD_DECLUSTERED )
     rf_InstallSpareTable(raidPtr, row, col);
  RF_UNLOCK_MUTEX(raidPtr->mutex);
  return(0);
d772 19
a790 47
int rf_FailDisk(
  RF_Raid_t  *raidPtr,
  int         frow,
  int         fcol,
  int         initRecon)
{
  int tid;

  rf_get_threadid(tid);
  printf("[%d] Failing disk r%d c%d\n",tid,frow,fcol);
  RF_LOCK_MUTEX(raidPtr->mutex);
  raidPtr->numFailures++;
  raidPtr->Disks[frow][fcol].status = rf_ds_failed;
  raidPtr->status[frow] = rf_rs_degraded;
  RF_UNLOCK_MUTEX(raidPtr->mutex);
#ifdef SIMULATE
#if RF_DEMO > 0
  if (rf_demoMode) {
    rf_demo_update_mode (RF_DEMO_DEGRADED);
    fail_col = fcol; fail_row = frow; 
    fail_time = rf_CurTime(); /* XXX */
    if (initRecon)
      delayed_recon = RF_TRUE;
  }
  else {
    if (initRecon)
      rf_ReconstructFailedDisk(raidPtr, frow, fcol);
  }
#else /* RF_DEMO > 0 */
  if (initRecon)
    rf_ReconstructFailedDisk(raidPtr, frow, fcol);
#endif /* RF_DEMO > 0 */
#else /* SIMULATE */
  if (initRecon)
    rf_ReconstructFailedDisk(raidPtr, frow, fcol);
#endif /* SIMULATE */
  return(0);
}

#ifdef SIMULATE
extern RF_Owner_t recon_owner;

void rf_ScheduleContinueReconstructFailedDisk(reconDesc)
  RF_RaidReconDesc_t  *reconDesc;
{
  rf_DDEventRequest(rf_CurTime(), rf_ContinueReconstructFailedDisk,
    (void *) reconDesc, recon_owner, -4, -4, reconDesc->raidPtr, NULL);
a791 2
#endif /* SIMULATE */

d795 16
a810 21
void rf_SignalQuiescenceLock(raidPtr, reconDesc)
  RF_Raid_t           *raidPtr;
  RF_RaidReconDesc_t  *reconDesc;
{
  int tid;

  if (rf_quiesceDebug) {
    rf_get_threadid(tid);
    printf("[%d] Signalling quiescence lock\n", tid);
  }
  raidPtr->access_suspend_release = 1;

  if (raidPtr->waiting_for_quiescence) {
#ifndef SIMULATE
    SIGNAL_QUIESCENT_COND(raidPtr);
#else /* !SIMULATE */
    if (reconDesc) {
      rf_ScheduleContinueReconstructFailedDisk(reconDesc);
    }
#endif /* !SIMULATE */
  }
a811 1

d813 20
a832 5
int rf_SuspendNewRequestsAndWait(raidPtr)
  RF_Raid_t  *raidPtr;
{
  if (rf_quiesceDebug)
    printf("Suspending new reqs\n");
d834 2
a835 18
  RF_LOCK_MUTEX(raidPtr->access_suspend_mutex);
  raidPtr->accesses_suspended++;
  raidPtr->waiting_for_quiescence = (raidPtr->accs_in_flight == 0) ? 0 : 1;
  
#ifndef SIMULATE
  if (raidPtr->waiting_for_quiescence) {
    raidPtr->access_suspend_release=0;
    while (!raidPtr->access_suspend_release) {
	    printf("Suspending: Waiting for Quiescence\n");
      WAIT_FOR_QUIESCENCE(raidPtr);
      raidPtr->waiting_for_quiescence = 0;
    }
  }
  printf("Quiescence reached..\n");
#endif /* !SIMULATE */

  RF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);
  return (raidPtr->waiting_for_quiescence);
a836 1

d838 24
a861 23
void rf_ResumeNewRequests(raidPtr)
  RF_Raid_t  *raidPtr;
{
  RF_CallbackDesc_t *t, *cb;

  if (rf_quiesceDebug)
    printf("Resuming new reqs\n");
  
  RF_LOCK_MUTEX(raidPtr->access_suspend_mutex);
  raidPtr->accesses_suspended--;
  if (raidPtr->accesses_suspended == 0)
    cb = raidPtr->quiesce_wait_list;
  else
    cb = NULL;
  raidPtr->quiesce_wait_list = NULL;
  RF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);
  
  while (cb) {
    t = cb;
    cb = cb->next;
    (t->callbackFunc)(t->callbackArg);
    rf_FreeCallbackDesc(t);
  }
a862 1

d869 15
a883 14
static void set_debug_option(name, val)
  char  *name;
  long   val;
{
  RF_DebugName_t *p;

  for (p = rf_debugNames; p->name; p++) {
    if (!strcmp(p->name, name)) {
      *(p->ptr) = val;
      printf("[Set debug variable %s to %ld]\n",name,val);
      return;
    }
  }
  RF_ERRORMSG1("Unknown debug string \"%s\"\n",name);
d889 21
a909 17
static void rf_ConfigureDebug(cfgPtr)
  RF_Config_t  *cfgPtr;
{
  char *val_p, *name_p, *white_p;
  long val;
  int i;

  rf_ResetDebugOptions();
  for (i=0; cfgPtr->debugVars[i][0] && i < RF_MAXDBGV; i++) {
    name_p  = rf_find_non_white(&cfgPtr->debugVars[i][0]);
    white_p = rf_find_white(name_p);                                   /* skip to start of 2nd word */
    val_p   = rf_find_non_white(white_p);
    if (*val_p == '0' && *(val_p+1) == 'x') val = rf_htoi(val_p+2);
    else val = rf_atoi(val_p);
    *white_p = '\0';
    set_debug_option(name_p, val);
  }
a910 1

d915 1
a915 1
#if !defined(KERNEL) && !defined(SIMULATE)
d921 5
a925 4
static int rf_InitThroughputStats(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
d927 1
a927 1
  int rc;
d929 37
a965 11
  /* these used by user-level raidframe only */
  rc = rf_create_managed_mutex(listp, &raidPtr->throughputstats.mutex);
  if (rc) {
    RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    return(rc);
  }
  raidPtr->throughputstats.sum_io_us = 0;
  raidPtr->throughputstats.num_ios = 0;
  raidPtr->throughputstats.num_out_ios = 0;
  return(0);
d968 2
a969 1
void rf_StartThroughputStats(RF_Raid_t *raidPtr)
d971 5
a975 29
  RF_LOCK_MUTEX(raidPtr->throughputstats.mutex);
  raidPtr->throughputstats.num_ios++;
  raidPtr->throughputstats.num_out_ios++;
  if (raidPtr->throughputstats.num_out_ios == 1)
    RF_GETTIME(raidPtr->throughputstats.start);
  RF_UNLOCK_MUTEX(raidPtr->throughputstats.mutex);
}

static void rf_StopThroughputStats(RF_Raid_t *raidPtr)
{
  struct timeval diff;

  RF_LOCK_MUTEX(raidPtr->throughputstats.mutex);
  raidPtr->throughputstats.num_out_ios--;
  if (raidPtr->throughputstats.num_out_ios == 0) {
    RF_GETTIME(raidPtr->throughputstats.stop);
    RF_TIMEVAL_DIFF(&raidPtr->throughputstats.start, &raidPtr->throughputstats.stop, &diff);
    raidPtr->throughputstats.sum_io_us += TIMEVAL_TO_US(diff);
  }
  RF_UNLOCK_MUTEX(raidPtr->throughputstats.mutex);  
}

static void rf_PrintThroughputStats(RF_Raid_t *raidPtr)
{
  RF_ASSERT(raidPtr->throughputstats.num_out_ios == 0);
  if ( raidPtr->throughputstats.sum_io_us != 0 ) {
     printf("[Througphut: %8.2f IOs/second]\n", raidPtr->throughputstats.num_ios
       / (raidPtr->throughputstats.sum_io_us / 1000000.0));
  }
d977 1
d979 2
a980 3
#endif /* !KERNEL && !SIMULATE */

void rf_StartUserStats(RF_Raid_t *raidPtr)
d982 4
a985 4
  RF_GETTIME(raidPtr->userstats.start);
  raidPtr->userstats.sum_io_us = 0;
  raidPtr->userstats.num_ios = 0;
  raidPtr->userstats.num_sect_moved = 0;
d988 2
a989 1
void rf_StopUserStats(RF_Raid_t *raidPtr)
d991 1
a991 1
  RF_GETTIME(raidPtr->userstats.stop);
d994 5
a998 4
void rf_UpdateUserStats(raidPtr, rt, numsect)
  RF_Raid_t  *raidPtr;
  int         rt;       /* resp time in us */
  int         numsect;  /* number of sectors for this access */
d1000 3
a1002 3
  raidPtr->userstats.sum_io_us += rt;
  raidPtr->userstats.num_ios++;
  raidPtr->userstats.num_sect_moved += numsect;
d1005 2
a1006 1
void rf_PrintUserStats(RF_Raid_t *raidPtr)
d1008 2
a1009 2
  long elapsed_us, mbs, mbs_frac;
  struct timeval diff;
d1011 2
a1012 2
  RF_TIMEVAL_DIFF(&raidPtr->userstats.start, &raidPtr->userstats.stop, &diff);
  elapsed_us = TIMEVAL_TO_US(diff);
d1014 5
a1018 5
  /* 2000 sectors per megabyte, 10000000 microseconds per second */
  if (elapsed_us)
    mbs = (raidPtr->userstats.num_sect_moved / 2000) / (elapsed_us / 1000000);
  else
    mbs = 0;
d1020 7
a1026 8
  /* this computes only the first digit of the fractional mb/s moved */
  if (elapsed_us) {
    mbs_frac = ((raidPtr->userstats.num_sect_moved / 200) / (elapsed_us / 1000000))
      - (mbs * 10);
  }
  else {
    mbs_frac = 0;
  }
d1028 7
a1034 7
  printf("Number of I/Os:             %ld\n",raidPtr->userstats.num_ios);
  printf("Elapsed time (us):          %ld\n",elapsed_us);
  printf("User I/Os per second:       %ld\n",RF_DB0_CHECK(raidPtr->userstats.num_ios, (elapsed_us/1000000)));
  printf("Average user response time: %ld us\n",RF_DB0_CHECK(raidPtr->userstats.sum_io_us, raidPtr->userstats.num_ios));
  printf("Total sectors moved:        %ld\n",raidPtr->userstats.num_sect_moved);
  printf("Average access size (sect): %ld\n",RF_DB0_CHECK(raidPtr->userstats.num_sect_moved, raidPtr->userstats.num_ios));
  printf("Achieved data rate:         %ld.%ld MB/sec\n",mbs,mbs_frac);
@

