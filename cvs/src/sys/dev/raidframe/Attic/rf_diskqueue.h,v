head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.38
	OPENBSD_5_0:1.5.0.36
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.34
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.32
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.28
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.5;

1.5
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.08.16.07.40;	author peter;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	2000.01.11.18.02.21;	author peter;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.02.16.00.02.40;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.17;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.26.10;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_diskqueue.h,v 1.5 2002/12/16 07:01:03 tdeval Exp $	*/
/*	$NetBSD: rf_diskqueue.h,v 1.5 2000/02/13 04:53:57 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 *
 * rf_diskqueue.h -- Header file for disk queues.
 *
 * See comments in rf_diskqueue.c
 *
 *****************************************************************************/


#ifndef	_RF__RF_DISKQUEUE_H_
#define	_RF__RF_DISKQUEUE_H_

#include "rf_threadstuff.h"
#include "rf_acctrace.h"
#include "rf_alloclist.h"
#include "rf_types.h"
#include "rf_etimer.h"


#if	defined(__NetBSD__)
#include "rf_netbsd.h"
#elif	defined(__OpenBSD__)
#include "rf_openbsd.h"
#endif


#define	RF_IO_NORMAL_PRIORITY	1
#define	RF_IO_LOW_PRIORITY	0

/* The data held by a disk queue entry. */
struct RF_DiskQueueData_s {
	RF_SectorNum_t	  sectorOffset;	/* Sector offset into the disk. */
	RF_SectorCount_t  numSector;	/* Number of sectors to read/write. */
	RF_IoType_t	  type;		/* Read/write/nop. */
	caddr_t		  buf;		/* Buffer pointer. */
	RF_StripeNum_t	  parityStripeID;
					/*
					 * The RAID parity stripe ID this
					 * access is for.
					 */
	RF_ReconUnitNum_t which_ru;	/* Which RU within this parity stripe */
	int		  priority;	/* The priority of this request. */
	int		(*CompleteFunc) (void *, int);
					/*
					 * Function to be called upon
					 * completion.
					 */
	int		(*AuxFunc) (void *,...);
					/*
					 * Function called upon completion
					 * of the first I/O of a Read_Op_Write
					 * pair.
					 */
	void		 *argument;	/*
					 * Argument to be passed to
					 * CompleteFunc.
					 */
	RF_Raid_t	 *raidPtr;	/* Needed for simulation. */
	RF_AccTraceEntry_t *tracerec;	/* Perf mon only. */
	RF_Etimer_t	  qtime;	/*
					 * Perf mon only - time request is
					 * in queue.
					 */
	long		  entryTime;
	RF_DiskQueueData_t *next;
	RF_DiskQueueData_t *prev;
	caddr_t		  buf2;		/* For read-op-write. */
	dev_t		  dev;		/*
					 * The device number for in-kernel
					 * version.
					 */
	RF_DiskQueue_t	 *queue;	/*
					 * The disk queue to which this req
					 * is targeted.
					 */
	RF_DiskQueueDataFlags_t flags;	/* Flags controlling operation. */

	struct proc	 *b_proc;	/*
					 * The b_proc from the original bp
					 * passed into the driver for this I/O.
					 */
	struct buf	 *bp;		/* A bp to use to get this I/O done. */
};
#define	RF_LOCK_DISK_QUEUE	0x01
#define	RF_UNLOCK_DISK_QUEUE	0x02

/*
 * Note: "Create" returns type-specific queue header pointer cast to (void *).
 */
struct RF_DiskQueueSW_s {
	RF_DiskQueueType_t queueType;
	void		*(*Create) (RF_SectorCount_t, RF_AllocListElem_t *,
			    RF_ShutdownList_t **);
					/*
					 * Creation routine -- one call per
					 * queue in system.
					 */
	void		 (*Enqueue) (void *, RF_DiskQueueData_t *, int);
					/* Enqueue routine. */
	RF_DiskQueueData_t *(*Dequeue) (void *);
					/* Dequeue routine. */
	RF_DiskQueueData_t *(*Peek) (void *);
					/* Peek at head of queue. */

	/*
	 * The rest are optional:  they improve performance, but the driver
	 * will deal with it if they don't exist.
	 */
	int		 (*Promote) (void *, RF_StripeNum_t, RF_ReconUnitNum_t);
					/*
					 * Promotes priority of tagged
					 * accesses.
					 */
};

struct RF_DiskQueue_s {
	RF_DiskQueueSW_t  *qPtr;	/* Access point to queue functions. */
	void		  *qHdr;	/* Queue header, of whatever type. */
	RF_DECLARE_MUTEX(mutex);	/* Mutex locking data structures. */
	RF_DECLARE_COND(cond);		/*
					 * Condition variable for
					 * synchronization.
					 */
	long		   numOutstanding;
					/*
					 * Number of I/Os currently
					 * outstanding on disk.
					 */
	long		   maxOutstanding;
					/*
					 * Max number of I/Os that can be
					 * outstanding on a disk.
					 * (in-kernel only)
					 */
	int		   curPriority;	/*
					 * The priority of accs all that are
					 * currently outstanding.
					 */
	long		   queueLength;	/* Number of requests in queue. */
	RF_DiskQueueData_t *nextLockingOp;
					/*
					 * A locking op that has arrived at
					 * the head of the queue & is waiting
					 * for drainage.
					 */
	RF_DiskQueueData_t *unlockingOp;/*
					 * Used at user level to communicate
					 * unlocking op b/w user (or dag exec)
					 * & disk threads.
					 */
	int		   numWaiting;	/*
					 * Number of threads waiting on
					 * this variable.
					 * (user-level only)
					 */
	RF_DiskQueueFlags_t flags;	/* Terminate, locked. */
	RF_Raid_t	  *raidPtr;	/* Associated array. */
	dev_t		   dev;		/* Device number for kernel version. */
	RF_SectorNum_t	   last_deq_sector;
					/*
					 * Last sector number dequeued or
					 * dispatched.
					 */
	int		   row, col;	/* Debug only. */
	struct raidcinfo  *rf_cinfo;	/* Disks component info... */
};

/* No new accs allowed until queue is explicitly unlocked. */
#define	RF_DQ_LOCKED	0x02

/* Macros setting & returning information about queues and requests. */
#define	RF_QUEUE_LOCKED(_q)		((_q)->flags & RF_DQ_LOCKED)
#define	RF_QUEUE_EMPTY(_q)		(((_q)->numOutstanding == 0) &&	\
					 ((_q)->nextLockingOp == NULL) && \
					 !RF_QUEUE_LOCKED(_q))
#define	RF_QUEUE_FULL(_q)		((_q)->numOutstanding ==	\
					 (_q)->maxOutstanding)

#define	RF_LOCK_QUEUE(_q)		(_q)->flags |= RF_DQ_LOCKED
#define	RF_UNLOCK_QUEUE(_q)		(_q)->flags &= ~RF_DQ_LOCKED

#define	RF_LOCK_QUEUE_MUTEX(_q_,_wh_)	RF_LOCK_MUTEX((_q_)->mutex)
#define	RF_UNLOCK_QUEUE_MUTEX(_q_,_wh_)	RF_UNLOCK_MUTEX((_q_)->mutex)

#define	RF_LOCKING_REQ(_r)		((_r)->flags & RF_LOCK_DISK_QUEUE)
#define	RF_UNLOCKING_REQ(_r)		((_r)->flags & RF_UNLOCK_DISK_QUEUE)

/* Whether it is ok to dispatch a regular request. */
#define	RF_OK_TO_DISPATCH(_q_,_r_)					\
	(RF_QUEUE_EMPTY(_q_) ||						\
	( !RF_QUEUE_FULL(_q_) && ((_r_)->priority >= (_q_)->curPriority)))

int  rf_ConfigureDiskQueueSystem(RF_ShutdownList_t **);

void rf_TerminateDiskQueues(RF_Raid_t *);

int  rf_ConfigureDiskQueues(RF_ShutdownList_t **, RF_Raid_t *, RF_Config_t *);

void rf_DiskIOEnqueue(RF_DiskQueue_t *, RF_DiskQueueData_t *, int);

void rf_DiskIOComplete(RF_DiskQueue_t *, RF_DiskQueueData_t *, int);

int  rf_DiskIOPromote(RF_DiskQueue_t *, RF_StripeNum_t, RF_ReconUnitNum_t);

RF_DiskQueueData_t *rf_CreateDiskQueueData(RF_IoType_t, RF_SectorNum_t,
	RF_SectorCount_t, caddr_t, RF_StripeNum_t, RF_ReconUnitNum_t,
	int (*) (void *, int), void *, RF_DiskQueueData_t *,
	RF_AccTraceEntry_t *, void *, RF_DiskQueueDataFlags_t, void *);

RF_DiskQueueData_t *rf_CreateDiskQueueDataFull(RF_IoType_t, RF_SectorNum_t,
	RF_SectorCount_t, caddr_t, RF_StripeNum_t, RF_ReconUnitNum_t,
	int (*) (void *, int), void *, RF_DiskQueueData_t *,
	RF_AccTraceEntry_t *, int, int (*) (void *,...), caddr_t, void *,
	RF_DiskQueueDataFlags_t, void *);

void rf_FreeDiskQueueData(RF_DiskQueueData_t *);

int  rf_ConfigureDiskQueue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t,
	RF_RowCol_t, RF_DiskQueueSW_t *, RF_SectorCount_t, dev_t, int,
	RF_ShutdownList_t **, RF_AllocListElem_t *);

#endif	/* ! _RF__RF_DISKQUEUE_H_ */
@


1.5
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_diskqueue.h,v 1.4 2000/08/08 16:07:40 peter Exp $	*/
@


1.4
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_diskqueue.h,v 1.3 2000/01/11 18:02:21 peter Exp $	*/
d3 1
d31 1
a31 1
/*****************************************************************************************
d33 1
a33 1
 * rf_diskqueue.h -- header file for disk queues
d35 1
a35 1
 * see comments in rf_diskqueue.c
d37 1
a37 1
 ****************************************************************************************/
d40 2
a41 2
#ifndef _RF__RF_DISKQUEUE_H_
#define _RF__RF_DISKQUEUE_H_
d50 1
a50 1
#if defined(__NetBSD__)
d52 1
a52 1
#elif defined(__OpenBSD__)
d57 2
a58 2
#define RF_IO_NORMAL_PRIORITY 1
#define RF_IO_LOW_PRIORITY    0
d60 1
a60 1
/* the data held by a disk queue entry */
d62 33
a94 18
	RF_SectorNum_t sectorOffset;	/* sector offset into the disk */
	RF_SectorCount_t numSector;	/* number of sectors to read/write */
	RF_IoType_t type;	/* read/write/nop */
	caddr_t buf;		/* buffer pointer */
	RF_StripeNum_t parityStripeID;	/* the RAID parity stripe ID this
					 * access is for */
	RF_ReconUnitNum_t which_ru;	/* which RU within this parity stripe */
	int     priority;	/* the priority of this request */
	int     (*CompleteFunc) (void *, int);	/* function to be called upon
						 * completion */
	int     (*AuxFunc) (void *,...);	/* function called upon
						 * completion of the first I/O
						 * of a Read_Op_Write pair */
	void   *argument;	/* argument to be passed to CompleteFunc */
	RF_Raid_t *raidPtr;	/* needed for simulation */
	RF_AccTraceEntry_t *tracerec;	/* perf mon only */
	RF_Etimer_t qtime;	/* perf mon only - time request is in queue */
	long    entryTime;
d97 16
a112 9
	caddr_t buf2;		/* for read-op-write */
	dev_t   dev;		/* the device number for in-kernel version */
	RF_DiskQueue_t *queue;	/* the disk queue to which this req is
				 * targeted */
	RF_DiskQueueDataFlags_t flags;	/* flags controlling operation */

	struct proc *b_proc;	/* the b_proc from the original bp passed into
				 * the driver for this I/O */
	struct buf *bp;		/* a bp to use to get this I/O done */
d114 2
a115 2
#define RF_LOCK_DISK_QUEUE   0x01
#define RF_UNLOCK_DISK_QUEUE 0x02
d117 3
a119 1
/* note: "Create" returns type-specific queue header pointer cast to (void *) */
d122 22
a143 11
	void   *(*Create) (RF_SectorCount_t, RF_AllocListElem_t *, RF_ShutdownList_t **);	/* creation routine --
												 * one call per queue in
												 * system */
	void    (*Enqueue) (void *, RF_DiskQueueData_t *, int);	/* enqueue routine */
	RF_DiskQueueData_t *(*Dequeue) (void *);	/* dequeue routine */
	RF_DiskQueueData_t *(*Peek) (void *);	/* peek at head of queue */

	/* the rest are optional:  they improve performance, but the driver
	 * will deal with it if they don't exist */
	int     (*Promote) (void *, RF_StripeNum_t, RF_ReconUnitNum_t);	/* promotes priority of
									 * tagged accesses */
d147 49
a195 29
	RF_DiskQueueSW_t *qPtr;	/* access point to queue functions */
	void   *qHdr;		/* queue header, of whatever type */
	        RF_DECLARE_MUTEX(mutex)	/* mutex locking data structures */
	        RF_DECLARE_COND(cond)	/* condition variable for
					 * synchronization */
	long    numOutstanding;	/* number of I/Os currently outstanding on
				 * disk */
	long    maxOutstanding;	/* max # of I/Os that can be outstanding on a
				 * disk (in-kernel only) */
	int     curPriority;	/* the priority of accs all that are currently
				 * outstanding */
	long    queueLength;	/* number of requests in queue */
	RF_DiskQueueData_t *nextLockingOp;	/* a locking op that has
						 * arrived at the head of the
						 * queue & is waiting for
						 * drainage */
	RF_DiskQueueData_t *unlockingOp;	/* used at user level to
						 * communicate unlocking op
						 * b/w user (or dag exec) &
						 * disk threads */
	int     numWaiting;	/* number of threads waiting on this variable.
				 * user-level only */
	RF_DiskQueueFlags_t flags;	/* terminate, locked */
	RF_Raid_t *raidPtr;	/* associated array */
	dev_t   dev;		/* device number for kernel version */
	RF_SectorNum_t last_deq_sector;	/* last sector number dequeued or
					 * dispatched */
	int     row, col;	/* debug only */
	struct raidcinfo *rf_cinfo;	/* disks component info.. */
a196 2
#define RF_DQ_LOCKED  0x02	/* no new accs allowed until queue is
				 * explicitly unlocked */
d198 53
a250 68
/* macros setting & returning information about queues and requests */
#define RF_QUEUE_LOCKED(_q)                 ((_q)->flags & RF_DQ_LOCKED)
#define RF_QUEUE_EMPTY(_q)                  (((_q)->numOutstanding == 0) && ((_q)->nextLockingOp == NULL) && !RF_QUEUE_LOCKED(_q))
#define RF_QUEUE_FULL(_q)                   ((_q)->numOutstanding == (_q)->maxOutstanding)

#define RF_LOCK_QUEUE(_q)                   (_q)->flags |= RF_DQ_LOCKED
#define RF_UNLOCK_QUEUE(_q)                 (_q)->flags &= ~RF_DQ_LOCKED

#define RF_LOCK_QUEUE_MUTEX(_q_,_wh_)   RF_LOCK_MUTEX((_q_)->mutex)
#define RF_UNLOCK_QUEUE_MUTEX(_q_,_wh_) RF_UNLOCK_MUTEX((_q_)->mutex)

#define RF_LOCKING_REQ(_r)                  ((_r)->flags & RF_LOCK_DISK_QUEUE)
#define RF_UNLOCKING_REQ(_r)                ((_r)->flags & RF_UNLOCK_DISK_QUEUE)

/* whether it is ok to dispatch a regular request */
#define RF_OK_TO_DISPATCH(_q_,_r_) \
  (RF_QUEUE_EMPTY(_q_) || \
    (!RF_QUEUE_FULL(_q_) && ((_r_)->priority >= (_q_)->curPriority)))

int     rf_ConfigureDiskQueueSystem(RF_ShutdownList_t ** listp);

void    rf_TerminateDiskQueues(RF_Raid_t * raidPtr);

int 
rf_ConfigureDiskQueues(RF_ShutdownList_t ** listp, RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr);

void    rf_DiskIOEnqueue(RF_DiskQueue_t * queue, RF_DiskQueueData_t * req, int pri);


void    rf_DiskIOComplete(RF_DiskQueue_t * queue, RF_DiskQueueData_t * req, int status);

int 
rf_DiskIOPromote(RF_DiskQueue_t * queue, RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru);

RF_DiskQueueData_t *
rf_CreateDiskQueueData(RF_IoType_t typ, RF_SectorNum_t ssect, 
		       RF_SectorCount_t nsect, caddr_t buf,
		       RF_StripeNum_t parityStripeID, 
		       RF_ReconUnitNum_t which_ru,
		       int (*wakeF) (void *, int),
		       void *arg, RF_DiskQueueData_t * next, 
		       RF_AccTraceEntry_t * tracerec,
		       void *raidPtr, RF_DiskQueueDataFlags_t flags, 
		       void *kb_proc);

RF_DiskQueueData_t *
rf_CreateDiskQueueDataFull(RF_IoType_t typ, RF_SectorNum_t ssect, 
			   RF_SectorCount_t nsect, caddr_t buf,
			   RF_StripeNum_t parityStripeID, 
			   RF_ReconUnitNum_t which_ru,
			   int (*wakeF) (void *, int),
			   void *arg, RF_DiskQueueData_t * next, 
			   RF_AccTraceEntry_t * tracerec,
			   int priority, int (*AuxFunc) (void *,...), 
			   caddr_t buf2, void *raidPtr, 
			   RF_DiskQueueDataFlags_t flags, void *kb_proc);

void    
rf_FreeDiskQueueData(RF_DiskQueueData_t * p);

int 
rf_ConfigureDiskQueue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t, 
		      RF_RowCol_t, RF_DiskQueueSW_t *,
		      RF_SectorCount_t, dev_t, int, 
		      RF_ShutdownList_t **,
		      RF_AllocListElem_t *);
d252 1
a252 1
#endif				/* !_RF__RF_DISKQUEUE_H_ */
@


1.4.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d32 1
a32 1
 * rf_diskqueue.h -- Header file for disk queues.
d34 1
a34 1
 * See comments in rf_diskqueue.c
d36 1
a36 1
 *****************************************************************************/
d39 2
a40 2
#ifndef	_RF__RF_DISKQUEUE_H_
#define	_RF__RF_DISKQUEUE_H_
d49 1
a49 1
#if	defined(__NetBSD__)
d51 1
a51 1
#elif	defined(__OpenBSD__)
d56 2
a57 2
#define	RF_IO_NORMAL_PRIORITY	1
#define	RF_IO_LOW_PRIORITY	0
d59 1
a59 1
/* The data held by a disk queue entry. */
d61 18
a78 33
	RF_SectorNum_t	  sectorOffset;	/* Sector offset into the disk. */
	RF_SectorCount_t  numSector;	/* Number of sectors to read/write. */
	RF_IoType_t	  type;		/* Read/write/nop. */
	caddr_t		  buf;		/* Buffer pointer. */
	RF_StripeNum_t	  parityStripeID;
					/*
					 * The RAID parity stripe ID this
					 * access is for.
					 */
	RF_ReconUnitNum_t which_ru;	/* Which RU within this parity stripe */
	int		  priority;	/* The priority of this request. */
	int		(*CompleteFunc) (void *, int);
					/*
					 * Function to be called upon
					 * completion.
					 */
	int		(*AuxFunc) (void *,...);
					/*
					 * Function called upon completion
					 * of the first I/O of a Read_Op_Write
					 * pair.
					 */
	void		 *argument;	/*
					 * Argument to be passed to
					 * CompleteFunc.
					 */
	RF_Raid_t	 *raidPtr;	/* Needed for simulation. */
	RF_AccTraceEntry_t *tracerec;	/* Perf mon only. */
	RF_Etimer_t	  qtime;	/*
					 * Perf mon only - time request is
					 * in queue.
					 */
	long		  entryTime;
d81 9
a89 16
	caddr_t		  buf2;		/* For read-op-write. */
	dev_t		  dev;		/*
					 * The device number for in-kernel
					 * version.
					 */
	RF_DiskQueue_t	 *queue;	/*
					 * The disk queue to which this req
					 * is targeted.
					 */
	RF_DiskQueueDataFlags_t flags;	/* Flags controlling operation. */

	struct proc	 *b_proc;	/*
					 * The b_proc from the original bp
					 * passed into the driver for this I/O.
					 */
	struct buf	 *bp;		/* A bp to use to get this I/O done. */
d91 2
a92 2
#define	RF_LOCK_DISK_QUEUE	0x01
#define	RF_UNLOCK_DISK_QUEUE	0x02
d94 1
a94 3
/*
 * Note: "Create" returns type-specific queue header pointer cast to (void *).
 */
d97 11
a107 22
	void		*(*Create) (RF_SectorCount_t, RF_AllocListElem_t *,
			    RF_ShutdownList_t **);
					/*
					 * Creation routine -- one call per
					 * queue in system.
					 */
	void		 (*Enqueue) (void *, RF_DiskQueueData_t *, int);
					/* Enqueue routine. */
	RF_DiskQueueData_t *(*Dequeue) (void *);
					/* Dequeue routine. */
	RF_DiskQueueData_t *(*Peek) (void *);
					/* Peek at head of queue. */

	/*
	 * The rest are optional:  they improve performance, but the driver
	 * will deal with it if they don't exist.
	 */
	int		 (*Promote) (void *, RF_StripeNum_t, RF_ReconUnitNum_t);
					/*
					 * Promotes priority of tagged
					 * accesses.
					 */
d111 29
a139 49
	RF_DiskQueueSW_t  *qPtr;	/* Access point to queue functions. */
	void		  *qHdr;	/* Queue header, of whatever type. */
	RF_DECLARE_MUTEX(mutex);	/* Mutex locking data structures. */
	RF_DECLARE_COND(cond);		/*
					 * Condition variable for
					 * synchronization.
					 */
	long		   numOutstanding;
					/*
					 * Number of I/Os currently
					 * outstanding on disk.
					 */
	long		   maxOutstanding;
					/*
					 * Max number of I/Os that can be
					 * outstanding on a disk.
					 * (in-kernel only)
					 */
	int		   curPriority;	/*
					 * The priority of accs all that are
					 * currently outstanding.
					 */
	long		   queueLength;	/* Number of requests in queue. */
	RF_DiskQueueData_t *nextLockingOp;
					/*
					 * A locking op that has arrived at
					 * the head of the queue & is waiting
					 * for drainage.
					 */
	RF_DiskQueueData_t *unlockingOp;/*
					 * Used at user level to communicate
					 * unlocking op b/w user (or dag exec)
					 * & disk threads.
					 */
	int		   numWaiting;	/*
					 * Number of threads waiting on
					 * this variable.
					 * (user-level only)
					 */
	RF_DiskQueueFlags_t flags;	/* Terminate, locked. */
	RF_Raid_t	  *raidPtr;	/* Associated array. */
	dev_t		   dev;		/* Device number for kernel version. */
	RF_SectorNum_t	   last_deq_sector;
					/*
					 * Last sector number dequeued or
					 * dispatched.
					 */
	int		   row, col;	/* Debug only. */
	struct raidcinfo  *rf_cinfo;	/* Disks component info... */
d141 2
d144 68
a211 53
/* No new accs allowed until queue is explicitly unlocked. */
#define	RF_DQ_LOCKED	0x02

/* Macros setting & returning information about queues and requests. */
#define	RF_QUEUE_LOCKED(_q)		((_q)->flags & RF_DQ_LOCKED)
#define	RF_QUEUE_EMPTY(_q)		(((_q)->numOutstanding == 0) &&	\
					 ((_q)->nextLockingOp == NULL) && \
					 !RF_QUEUE_LOCKED(_q))
#define	RF_QUEUE_FULL(_q)		((_q)->numOutstanding ==	\
					 (_q)->maxOutstanding)

#define	RF_LOCK_QUEUE(_q)		(_q)->flags |= RF_DQ_LOCKED
#define	RF_UNLOCK_QUEUE(_q)		(_q)->flags &= ~RF_DQ_LOCKED

#define	RF_LOCK_QUEUE_MUTEX(_q_,_wh_)	RF_LOCK_MUTEX((_q_)->mutex)
#define	RF_UNLOCK_QUEUE_MUTEX(_q_,_wh_)	RF_UNLOCK_MUTEX((_q_)->mutex)

#define	RF_LOCKING_REQ(_r)		((_r)->flags & RF_LOCK_DISK_QUEUE)
#define	RF_UNLOCKING_REQ(_r)		((_r)->flags & RF_UNLOCK_DISK_QUEUE)

/* Whether it is ok to dispatch a regular request. */
#define	RF_OK_TO_DISPATCH(_q_,_r_)					\
	(RF_QUEUE_EMPTY(_q_) ||						\
	( !RF_QUEUE_FULL(_q_) && ((_r_)->priority >= (_q_)->curPriority)))

int  rf_ConfigureDiskQueueSystem(RF_ShutdownList_t **);

void rf_TerminateDiskQueues(RF_Raid_t *);

int  rf_ConfigureDiskQueues(RF_ShutdownList_t **, RF_Raid_t *, RF_Config_t *);

void rf_DiskIOEnqueue(RF_DiskQueue_t *, RF_DiskQueueData_t *, int);

void rf_DiskIOComplete(RF_DiskQueue_t *, RF_DiskQueueData_t *, int);

int  rf_DiskIOPromote(RF_DiskQueue_t *, RF_StripeNum_t, RF_ReconUnitNum_t);

RF_DiskQueueData_t *rf_CreateDiskQueueData(RF_IoType_t, RF_SectorNum_t,
	RF_SectorCount_t, caddr_t, RF_StripeNum_t, RF_ReconUnitNum_t,
	int (*) (void *, int), void *, RF_DiskQueueData_t *,
	RF_AccTraceEntry_t *, void *, RF_DiskQueueDataFlags_t, void *);

RF_DiskQueueData_t *rf_CreateDiskQueueDataFull(RF_IoType_t, RF_SectorNum_t,
	RF_SectorCount_t, caddr_t, RF_StripeNum_t, RF_ReconUnitNum_t,
	int (*) (void *, int), void *, RF_DiskQueueData_t *,
	RF_AccTraceEntry_t *, int, int (*) (void *,...), caddr_t, void *,
	RF_DiskQueueDataFlags_t, void *);

void rf_FreeDiskQueueData(RF_DiskQueueData_t *);

int  rf_ConfigureDiskQueue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t,
	RF_RowCol_t, RF_DiskQueueSW_t *, RF_SectorCount_t, dev_t, int,
	RF_ShutdownList_t **, RF_AllocListElem_t *);
d213 1
a213 1
#endif	/* ! _RF__RF_DISKQUEUE_H_ */
@


1.3
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_diskqueue.h,v 1.2 1999/02/16 00:02:40 niklas Exp $	*/
/*	$NetBSD: rf_diskqueue.h,v 1.4 2000/01/08 23:02:16 oster Exp $	*/
d181 9
a189 14
rf_CreateDiskQueueData(RF_IoType_t typ,
    RF_SectorNum_t ssect, RF_SectorCount_t nsect, caddr_t buf,
    RF_StripeNum_t parityStripeID, RF_ReconUnitNum_t which_ru,
    int (*wakeF) (void *, int),
    void *arg, RF_DiskQueueData_t * next, RF_AccTraceEntry_t * tracerec,
    void *raidPtr, RF_DiskQueueDataFlags_t flags, void *kb_proc);

	RF_DiskQueueData_t *rf_CreateDiskQueueDataFull(RF_IoType_t typ,
            RF_SectorNum_t ssect, RF_SectorCount_t nsect, caddr_t buf,
            RF_StripeNum_t parityStripeID, RF_ReconUnitNum_t which_ru,
            int (*wakeF) (void *, int),
            void *arg, RF_DiskQueueData_t * next, RF_AccTraceEntry_t * tracerec,
            int priority, int (*AuxFunc) (void *,...), caddr_t buf2,
            void *raidPtr, RF_DiskQueueDataFlags_t flags, void *kb_proc);
d191 21
a211 1
	void    rf_FreeDiskQueueData(RF_DiskQueueData_t * p);
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_diskqueue.h,v 1.4 2000/08/08 16:07:40 peter Exp $	*/
/*	$NetBSD: rf_diskqueue.h,v 1.5 2000/02/13 04:53:57 oster Exp $	*/
d181 14
a194 9
rf_CreateDiskQueueData(RF_IoType_t typ, RF_SectorNum_t ssect, 
		       RF_SectorCount_t nsect, caddr_t buf,
		       RF_StripeNum_t parityStripeID, 
		       RF_ReconUnitNum_t which_ru,
		       int (*wakeF) (void *, int),
		       void *arg, RF_DiskQueueData_t * next, 
		       RF_AccTraceEntry_t * tracerec,
		       void *raidPtr, RF_DiskQueueDataFlags_t flags, 
		       void *kb_proc);
d196 1
a196 21
RF_DiskQueueData_t *
rf_CreateDiskQueueDataFull(RF_IoType_t typ, RF_SectorNum_t ssect, 
			   RF_SectorCount_t nsect, caddr_t buf,
			   RF_StripeNum_t parityStripeID, 
			   RF_ReconUnitNum_t which_ru,
			   int (*wakeF) (void *, int),
			   void *arg, RF_DiskQueueData_t * next, 
			   RF_AccTraceEntry_t * tracerec,
			   int priority, int (*AuxFunc) (void *,...), 
			   caddr_t buf2, void *raidPtr, 
			   RF_DiskQueueDataFlags_t flags, void *kb_proc);

void    
rf_FreeDiskQueueData(RF_DiskQueueData_t * p);

int 
rf_ConfigureDiskQueue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t, 
		      RF_RowCol_t, RF_DiskQueueSW_t *,
		      RF_SectorCount_t, dev_t, int, 
		      RF_ShutdownList_t **,
		      RF_AllocListElem_t *);
@


1.3.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d32 1
a32 1
 * rf_diskqueue.h -- Header file for disk queues.
d34 1
a34 1
 * See comments in rf_diskqueue.c
d36 1
a36 1
 *****************************************************************************/
d39 2
a40 2
#ifndef	_RF__RF_DISKQUEUE_H_
#define	_RF__RF_DISKQUEUE_H_
d49 1
a49 1
#if	defined(__NetBSD__)
d51 1
a51 1
#elif	defined(__OpenBSD__)
d56 2
a57 2
#define	RF_IO_NORMAL_PRIORITY	1
#define	RF_IO_LOW_PRIORITY	0
d59 1
a59 1
/* The data held by a disk queue entry. */
d61 18
a78 33
	RF_SectorNum_t	  sectorOffset;	/* Sector offset into the disk. */
	RF_SectorCount_t  numSector;	/* Number of sectors to read/write. */
	RF_IoType_t	  type;		/* Read/write/nop. */
	caddr_t		  buf;		/* Buffer pointer. */
	RF_StripeNum_t	  parityStripeID;
					/*
					 * The RAID parity stripe ID this
					 * access is for.
					 */
	RF_ReconUnitNum_t which_ru;	/* Which RU within this parity stripe */
	int		  priority;	/* The priority of this request. */
	int		(*CompleteFunc) (void *, int);
					/*
					 * Function to be called upon
					 * completion.
					 */
	int		(*AuxFunc) (void *,...);
					/*
					 * Function called upon completion
					 * of the first I/O of a Read_Op_Write
					 * pair.
					 */
	void		 *argument;	/*
					 * Argument to be passed to
					 * CompleteFunc.
					 */
	RF_Raid_t	 *raidPtr;	/* Needed for simulation. */
	RF_AccTraceEntry_t *tracerec;	/* Perf mon only. */
	RF_Etimer_t	  qtime;	/*
					 * Perf mon only - time request is
					 * in queue.
					 */
	long		  entryTime;
d81 9
a89 16
	caddr_t		  buf2;		/* For read-op-write. */
	dev_t		  dev;		/*
					 * The device number for in-kernel
					 * version.
					 */
	RF_DiskQueue_t	 *queue;	/*
					 * The disk queue to which this req
					 * is targeted.
					 */
	RF_DiskQueueDataFlags_t flags;	/* Flags controlling operation. */

	struct proc	 *b_proc;	/*
					 * The b_proc from the original bp
					 * passed into the driver for this I/O.
					 */
	struct buf	 *bp;		/* A bp to use to get this I/O done. */
d91 2
a92 2
#define	RF_LOCK_DISK_QUEUE	0x01
#define	RF_UNLOCK_DISK_QUEUE	0x02
d94 1
a94 3
/*
 * Note: "Create" returns type-specific queue header pointer cast to (void *).
 */
d97 11
a107 22
	void		*(*Create) (RF_SectorCount_t, RF_AllocListElem_t *,
			    RF_ShutdownList_t **);
					/*
					 * Creation routine -- one call per
					 * queue in system.
					 */
	void		 (*Enqueue) (void *, RF_DiskQueueData_t *, int);
					/* Enqueue routine. */
	RF_DiskQueueData_t *(*Dequeue) (void *);
					/* Dequeue routine. */
	RF_DiskQueueData_t *(*Peek) (void *);
					/* Peek at head of queue. */

	/*
	 * The rest are optional:  they improve performance, but the driver
	 * will deal with it if they don't exist.
	 */
	int		 (*Promote) (void *, RF_StripeNum_t, RF_ReconUnitNum_t);
					/*
					 * Promotes priority of tagged
					 * accesses.
					 */
d111 29
a139 49
	RF_DiskQueueSW_t  *qPtr;	/* Access point to queue functions. */
	void		  *qHdr;	/* Queue header, of whatever type. */
	RF_DECLARE_MUTEX(mutex);	/* Mutex locking data structures. */
	RF_DECLARE_COND(cond);		/*
					 * Condition variable for
					 * synchronization.
					 */
	long		   numOutstanding;
					/*
					 * Number of I/Os currently
					 * outstanding on disk.
					 */
	long		   maxOutstanding;
					/*
					 * Max number of I/Os that can be
					 * outstanding on a disk.
					 * (in-kernel only)
					 */
	int		   curPriority;	/*
					 * The priority of accs all that are
					 * currently outstanding.
					 */
	long		   queueLength;	/* Number of requests in queue. */
	RF_DiskQueueData_t *nextLockingOp;
					/*
					 * A locking op that has arrived at
					 * the head of the queue & is waiting
					 * for drainage.
					 */
	RF_DiskQueueData_t *unlockingOp;/*
					 * Used at user level to communicate
					 * unlocking op b/w user (or dag exec)
					 * & disk threads.
					 */
	int		   numWaiting;	/*
					 * Number of threads waiting on
					 * this variable.
					 * (user-level only)
					 */
	RF_DiskQueueFlags_t flags;	/* Terminate, locked. */
	RF_Raid_t	  *raidPtr;	/* Associated array. */
	dev_t		   dev;		/* Device number for kernel version. */
	RF_SectorNum_t	   last_deq_sector;
					/*
					 * Last sector number dequeued or
					 * dispatched.
					 */
	int		   row, col;	/* Debug only. */
	struct raidcinfo  *rf_cinfo;	/* Disks component info... */
d141 2
d144 68
a211 53
/* No new accs allowed until queue is explicitly unlocked. */
#define	RF_DQ_LOCKED	0x02

/* Macros setting & returning information about queues and requests. */
#define	RF_QUEUE_LOCKED(_q)		((_q)->flags & RF_DQ_LOCKED)
#define	RF_QUEUE_EMPTY(_q)		(((_q)->numOutstanding == 0) &&	\
					 ((_q)->nextLockingOp == NULL) && \
					 !RF_QUEUE_LOCKED(_q))
#define	RF_QUEUE_FULL(_q)		((_q)->numOutstanding ==	\
					 (_q)->maxOutstanding)

#define	RF_LOCK_QUEUE(_q)		(_q)->flags |= RF_DQ_LOCKED
#define	RF_UNLOCK_QUEUE(_q)		(_q)->flags &= ~RF_DQ_LOCKED

#define	RF_LOCK_QUEUE_MUTEX(_q_,_wh_)	RF_LOCK_MUTEX((_q_)->mutex)
#define	RF_UNLOCK_QUEUE_MUTEX(_q_,_wh_)	RF_UNLOCK_MUTEX((_q_)->mutex)

#define	RF_LOCKING_REQ(_r)		((_r)->flags & RF_LOCK_DISK_QUEUE)
#define	RF_UNLOCKING_REQ(_r)		((_r)->flags & RF_UNLOCK_DISK_QUEUE)

/* Whether it is ok to dispatch a regular request. */
#define	RF_OK_TO_DISPATCH(_q_,_r_)					\
	(RF_QUEUE_EMPTY(_q_) ||						\
	( !RF_QUEUE_FULL(_q_) && ((_r_)->priority >= (_q_)->curPriority)))

int  rf_ConfigureDiskQueueSystem(RF_ShutdownList_t **);

void rf_TerminateDiskQueues(RF_Raid_t *);

int  rf_ConfigureDiskQueues(RF_ShutdownList_t **, RF_Raid_t *, RF_Config_t *);

void rf_DiskIOEnqueue(RF_DiskQueue_t *, RF_DiskQueueData_t *, int);

void rf_DiskIOComplete(RF_DiskQueue_t *, RF_DiskQueueData_t *, int);

int  rf_DiskIOPromote(RF_DiskQueue_t *, RF_StripeNum_t, RF_ReconUnitNum_t);

RF_DiskQueueData_t *rf_CreateDiskQueueData(RF_IoType_t, RF_SectorNum_t,
	RF_SectorCount_t, caddr_t, RF_StripeNum_t, RF_ReconUnitNum_t,
	int (*) (void *, int), void *, RF_DiskQueueData_t *,
	RF_AccTraceEntry_t *, void *, RF_DiskQueueDataFlags_t, void *);

RF_DiskQueueData_t *rf_CreateDiskQueueDataFull(RF_IoType_t, RF_SectorNum_t,
	RF_SectorCount_t, caddr_t, RF_StripeNum_t, RF_ReconUnitNum_t,
	int (*) (void *, int), void *, RF_DiskQueueData_t *,
	RF_AccTraceEntry_t *, int, int (*) (void *,...), caddr_t, void *,
	RF_DiskQueueDataFlags_t, void *);

void rf_FreeDiskQueueData(RF_DiskQueueData_t *);

int  rf_ConfigureDiskQueue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t,
	RF_RowCol_t, RF_DiskQueueSW_t *, RF_SectorCount_t, dev_t, int,
	RF_ShutdownList_t **, RF_AllocListElem_t *);
d213 1
a213 1
#endif	/* ! _RF__RF_DISKQUEUE_H_ */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_diskqueue.h,v 1.1 1999/01/11 14:29:17 niklas Exp $	*/
/*	$NetBSD: rf_diskqueue.h,v 1.3 1999/02/05 00:06:09 oster Exp $	*/
d75 1
a75 1
	void   *raidPtr;	/* needed for simulation */
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_diskqueue.h,v 1.1 1998/11/13 04:20:29 oster Exp $	*/
/*	$NetBSD: rf_diskqueue.h,v 1.1 1998/11/13 04:20:29 oster Exp $	*/
a36 125
/*
 *
 * :  
 *
 * Log: rf_diskqueue.h,v 
 * Revision 1.31  1996/08/07 21:08:49  jimz
 * b_proc -> kb_proc (IRIX complained)
 *
 * Revision 1.30  1996/06/18  20:53:11  jimz
 * fix up disk queueing (remove configure routine,
 * add shutdown list arg to create routines)
 *
 * Revision 1.29  1996/06/13  20:38:19  jimz
 * fix queue type in DiskQueueData
 *
 * Revision 1.28  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.27  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.26  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.25  1996/06/06  17:29:12  jimz
 * track arm position of last I/O dequeued
 *
 * Revision 1.24  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.23  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.22  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.21  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.20  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.19  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.18  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.17  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.16  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.15  1996/05/10  19:39:31  jimz
 * add prev pointer to DiskQueueData
 *
 * Revision 1.14  1996/05/10  16:24:04  jimz
 * mark old defines as deprecated, add RF_ defines
 *
 * Revision 1.13  1995/12/01  15:59:04  root
 * added copyright info
 *
 * Revision 1.12  1995/11/07  16:26:44  wvcii
 * added Peek() function to diskqueuesw
 *
 * Revision 1.11  1995/10/05  02:33:15  jimz
 * made queue lens longs (less instructions to read :-)
 *
 * Revision 1.10  1995/10/04  07:07:07  wvcii
 * queue->numOutstanding now valid for user & sim
 * user tested & verified, sim untested
 *
 * Revision 1.9  1995/09/12  00:21:37  wvcii
 * added support for tracing disk queue time
 *
 * Revision 1.8  95/04/24  13:25:51  holland
 * rewrite to move disk queues, recon, & atomic RMW to kernel
 * 
 * Revision 1.6.10.2  1995/04/03  20:13:56  holland
 * added numOutstanding and maxOutstanding to support moving
 * disk queues into kernel code
 *
 * Revision 1.6.10.1  1995/04/03  20:03:56  holland
 * initial checkin on branch
 *
 * Revision 1.6  1995/03/03  18:34:33  rachad
 * Simulator mechanism added
 *
 * Revision 1.5  1995/03/01  20:25:48  holland
 * kernelization changes
 *
 * Revision 1.4  1995/02/03  22:31:36  holland
 * many changes related to kernelization
 *
 * Revision 1.3  1995/02/01  14:25:19  holland
 * began changes for kernelization:
 *      changed all instances of mutex_t and cond_t to DECLARE macros
 *      converted configuration code to use config structure
 *
 * Revision 1.2  1994/11/29  20:36:02  danner
 * Added symbolic constants for io_type (e.g,IO_TYPE_READ)
 * and support for READ_OP_WRITE
 *
 */
a48 1
#ifdef _KERNEL
a53 1
#endif
d61 29
a89 28
  RF_SectorNum_t           sectorOffset;   /* sector offset into the disk */
  RF_SectorCount_t         numSector;      /* number of sectors to read/write */
  RF_IoType_t              type;           /* read/write/nop */
  caddr_t                  buf;            /* buffer pointer */
  RF_StripeNum_t           parityStripeID; /* the RAID parity stripe ID this access is for */
  RF_ReconUnitNum_t        which_ru;       /* which RU within this parity stripe */
  int                      priority;       /* the priority of this request */
  int                    (*CompleteFunc)(void *,int);/* function to be called upon completion */
  int                    (*AuxFunc)(void *,...); /* function called upon completion of the first I/O of a Read_Op_Write pair*/
  void                    *argument;       /* argument to be passed to CompleteFunc */
#ifdef SIMULATE
  RF_Owner_t               owner;          /* which task is responsible for this request */
#endif /* SIMULATE */
  void                    *raidPtr;        /* needed for simulation */
  RF_AccTraceEntry_t      *tracerec;       /* perf mon only */
  RF_Etimer_t              qtime;          /* perf mon only - time request is in queue */
  long                     entryTime;
  RF_DiskQueueData_t      *next;
  RF_DiskQueueData_t      *prev;
  caddr_t                  buf2;   /* for read-op-write */
  dev_t                    dev;    /* the device number for in-kernel version */
  RF_DiskQueue_t          *queue;  /* the disk queue to which this req is targeted */
  RF_DiskQueueDataFlags_t  flags;  /* flags controlling operation */
  
#ifdef KERNEL
  struct proc             *b_proc;  /* the b_proc from the original bp passed into the driver for this I/O */
  struct buf              *bp;      /* a bp to use to get this I/O done */
#endif /* KERNEL */
a90 1

d96 12
a107 8
  RF_DiskQueueType_t     queueType;
  void                *(*Create)(RF_SectorCount_t, RF_AllocListElem_t *, RF_ShutdownList_t **);    /* creation routine -- one call per queue in system */
  void                 (*Enqueue)(void *,RF_DiskQueueData_t * ,int);   /* enqueue routine */
  RF_DiskQueueData_t  *(*Dequeue)(void *);   /* dequeue routine */
  RF_DiskQueueData_t  *(*Peek)(void *);      /* peek at head of queue */

  /* the rest are optional:  they improve performance, but the driver will deal with it if they don't exist */
  int                  (*Promote)(void *, RF_StripeNum_t, RF_ReconUnitNum_t);   /* promotes priority of tagged accesses */
d111 29
a139 19
  RF_DiskQueueSW_t    *qPtr;             /* access point to queue functions */
  void                *qHdr;             /* queue header, of whatever type */
  RF_DECLARE_MUTEX(mutex)                /* mutex locking data structures */
  RF_DECLARE_COND(cond)                  /* condition variable for synchronization */
  long                 numOutstanding;   /* number of I/Os currently outstanding on disk */
  long                 maxOutstanding;   /* max # of I/Os that can be outstanding on a disk (in-kernel only) */
  int                  curPriority;      /* the priority of accs all that are currently outstanding */
  long                 queueLength;      /* number of requests in queue */
  RF_DiskQueueData_t  *nextLockingOp;    /* a locking op that has arrived at the head of the queue & is waiting for drainage */
  RF_DiskQueueData_t  *unlockingOp;      /* used at user level to communicate unlocking op b/w user (or dag exec) & disk threads */
  int                  numWaiting;       /* number of threads waiting on this variable.  user-level only */
  RF_DiskQueueFlags_t  flags;            /* terminate, locked */
  RF_Raid_t           *raidPtr;          /* associated array */
  dev_t                dev;              /* device number for kernel version */
  RF_SectorNum_t       last_deq_sector;  /* last sector number dequeued or dispatched */
  int                  row, col;         /* debug only */
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  struct raidcinfo *rf_cinfo;      /* disks component info.. */
#endif
d141 2
a142 2

#define RF_DQ_LOCKED  0x02  /* no new accs allowed until queue is explicitly unlocked */
d163 10
a172 1
int rf_ConfigureDiskQueueSystem(RF_ShutdownList_t **listp);
d174 1
a174 1
void rf_TerminateDiskQueues(RF_Raid_t *raidPtr);
d176 3
a178 2
int rf_ConfigureDiskQueues(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
	RF_Config_t *cfgPtr);
d180 7
a186 1
void rf_DiskIOEnqueue(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req, int pri);
d188 7
a194 27
#if !defined(KERNEL) && !defined(SIMULATE)
void rf_BroadcastOnQueue(RF_DiskQueue_t *queue);
#endif /* !KERNEL && !SIMULATE */

#ifndef KERNEL
RF_DiskQueueData_t *rf_DiskIODequeue(RF_DiskQueue_t *queue);
#else /* !KERNEL */
void rf_DiskIOComplete(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req, int status);
#endif /* !KERNEL */

int rf_DiskIOPromote(RF_DiskQueue_t *queue, RF_StripeNum_t parityStripeID,
	RF_ReconUnitNum_t which_ru);

RF_DiskQueueData_t *rf_CreateDiskQueueData(RF_IoType_t typ,
	RF_SectorNum_t ssect, RF_SectorCount_t nsect, caddr_t buf,
	RF_StripeNum_t parityStripeID, RF_ReconUnitNum_t which_ru, 
        int (*wakeF)(void *, int),
	void *arg, RF_DiskQueueData_t *next, RF_AccTraceEntry_t *tracerec,
	void *raidPtr, RF_DiskQueueDataFlags_t flags, void *kb_proc);

RF_DiskQueueData_t *rf_CreateDiskQueueDataFull(RF_IoType_t typ,
	RF_SectorNum_t ssect, RF_SectorCount_t nsect, caddr_t buf,
	RF_StripeNum_t parityStripeID, RF_ReconUnitNum_t which_ru, 
        int (*wakeF)(void *, int),
	void *arg, RF_DiskQueueData_t *next, RF_AccTraceEntry_t *tracerec,
	int priority, int (*AuxFunc)(void *,...), caddr_t buf2,
	void *raidPtr, RF_DiskQueueDataFlags_t flags, void *kb_proc);
d196 1
a196 1
void rf_FreeDiskQueueData(RF_DiskQueueData_t *p);
d198 1
a198 1
#endif /* !_RF__RF_DISKQUEUE_H_ */
@

