head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.38
	OPENBSD_5_0:1.4.0.36
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.16
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.14
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.12
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.4;

1.4
date	2002.12.16.07.01.05;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.11.18.02.23;	author peter;	state Exp;
branches
	1.3.2.1
	1.3.12.1;
next	1.2;

1.2
date	99.02.16.00.03.27;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.50;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.3.12.1
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_sstf.c,v 1.4 2002/12/16 07:01:05 tdeval Exp $	*/
/*	$NetBSD: rf_sstf.c,v 1.4 2000/01/08 23:45:05 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 *
 * sstf.c --  Prioritized shortest seek time first disk queueing code.
 *
 *****************************************************************************/

#include "rf_alloclist.h"
#include "rf_stripelocks.h"
#include "rf_layout.h"
#include "rf_diskqueue.h"
#include "rf_sstf.h"
#include "rf_debugMem.h"
#include "rf_general.h"
#include "rf_options.h"
#include "rf_raid.h"
#include "rf_types.h"

#define	DIR_LEFT	1
#define	DIR_RIGHT	2
#define	DIR_EITHER	3

#define	SNUM_DIFF(_a_,_b_)						\
	(((_a_) > (_b_)) ? ((_a_) - (_b_)) : ((_b_) - (_a_)))

#define	QSUM(_sstfq_)							\
	(((_sstfq_)->lopri.qlen) + ((_sstfq_)->left.qlen) +		\
	 ((_sstfq_)->right.qlen))


void rf_do_sstf_ord_q(RF_DiskQueueData_t **, RF_DiskQueueData_t **,
	RF_DiskQueueData_t *);
void rf_do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);
RF_DiskQueueData_t *rf_closest_to_arm(RF_SstfQ_t *, RF_SectorNum_t,
	int *, int);


void
rf_do_sstf_ord_q(RF_DiskQueueData_t **queuep, RF_DiskQueueData_t **tailp,
    RF_DiskQueueData_t *req)
{
	RF_DiskQueueData_t *r, *s;

	if (*queuep == NULL) {
		*queuep = req;
		*tailp = req;
		req->next = NULL;
		req->prev = NULL;
		return;
	}
	if (req->sectorOffset <= (*queuep)->sectorOffset) {
		req->next = *queuep;
		req->prev = NULL;
		(*queuep)->prev = req;
		*queuep = req;
		return;
	}
	if (req->sectorOffset > (*tailp)->sectorOffset) {
		/* Optimization. */
		r = NULL;
		s = *tailp;
		goto q_at_end;
	}
	for (s = NULL, r = *queuep; r; s = r, r = r->next) {
		if (r->sectorOffset >= req->sectorOffset) {
			/* Insert after s, before r. */
			RF_ASSERT(s);
			req->next = r;
			r->prev = req;
			s->next = req;
			req->prev = s;
			return;
		}
	}
q_at_end:
	/* Insert after s, at end of queue. */
	RF_ASSERT(r == NULL);
	RF_ASSERT(s);
	RF_ASSERT(s == (*tailp));
	req->next = NULL;
	req->prev = s;
	s->next = req;
	*tailp = req;
}

/* For removing from head-of-queue. */
#define	DO_HEAD_DEQ(_r_,_q_)						\
do {									\
	_r_ = (_q_)->queue;						\
	RF_ASSERT((_r_) != NULL);					\
	(_q_)->queue = (_r_)->next;					\
	(_q_)->qlen--;							\
	if ((_q_)->qlen == 0) {						\
		RF_ASSERT((_r_) == (_q_)->qtail);			\
		RF_ASSERT((_q_)->queue == NULL);			\
		(_q_)->qtail = NULL;					\
	} else {							\
		RF_ASSERT((_q_)->queue->prev == (_r_));			\
		(_q_)->queue->prev = NULL;				\
	}								\
} while (0)

/* For removing from end-of-queue. */
#define	DO_TAIL_DEQ(_r_,_q_)						\
do {									\
	_r_ = (_q_)->qtail;						\
	RF_ASSERT((_r_) != NULL);					\
	(_q_)->qtail = (_r_)->prev;					\
	(_q_)->qlen--;							\
	if ((_q_)->qlen == 0) {						\
		RF_ASSERT((_r_) == (_q_)->queue);			\
		RF_ASSERT((_q_)->qtail == NULL);			\
		(_q_)->queue = NULL;					\
	} else {							\
		RF_ASSERT((_q_)->qtail->next == (_r_));			\
		(_q_)->qtail->next = NULL;				\
	}								\
} while (0)

#define	DO_BEST_DEQ(_l_,_r_,_q_)					\
do {									\
	if (SNUM_DIFF((_q_)->queue->sectorOffset,_l_)			\
		< SNUM_DIFF((_q_)->qtail->sectorOffset,_l_))		\
	{								\
		DO_HEAD_DEQ(_r_,_q_);					\
	} else {							\
		DO_TAIL_DEQ(_r_,_q_);					\
	}								\
} while (0)

RF_DiskQueueData_t *
rf_closest_to_arm(RF_SstfQ_t *queue, RF_SectorNum_t arm_pos, int *dir,
    int allow_reverse)
{
	RF_SectorNum_t best_pos_l = 0, this_pos_l = 0, last_pos = 0;
	RF_SectorNum_t best_pos_r = 0, this_pos_r = 0;
	RF_DiskQueueData_t *r, *best_l, *best_r;

	best_r = best_l = NULL;
	for (r = queue->queue; r; r = r->next) {
		if (r->sectorOffset < arm_pos) {
			if (best_l == NULL) {
				best_l = r;
				last_pos = best_pos_l = this_pos_l;
			} else {
				this_pos_l = arm_pos - r->sectorOffset;
				if (this_pos_l < best_pos_l) {
					best_l = r;
					last_pos = best_pos_l = this_pos_l;
				} else {
					last_pos = this_pos_l;
				}
			}
		} else {
			if (best_r == NULL) {
				best_r = r;
				last_pos = best_pos_r = this_pos_r;
			} else {
				this_pos_r = r->sectorOffset - arm_pos;
				if (this_pos_r < best_pos_r) {
					best_r = r;
					last_pos = best_pos_r = this_pos_r;
				} else {
					last_pos = this_pos_r;
				}
				if (this_pos_r > last_pos) {
					/* Getting farther away. */
					break;
				}
			}
		}
	}
	if ((best_r == NULL) && (best_l == NULL))
		return (NULL);
	if ((*dir == DIR_RIGHT) && best_r)
		return (best_r);
	if ((*dir == DIR_LEFT) && best_l)
		return (best_l);
	if (*dir == DIR_EITHER) {
		if (best_l == NULL)
			return (best_r);
		if (best_r == NULL)
			return (best_l);
		if (best_pos_r < best_pos_l)
			return (best_r);
		else
			return (best_l);
	}
	/*
	 * Nothing in the direction we want to go. Reverse or
	 * reset the arm. We know we have an I/O in the other
	 * direction.
	 */
	if (allow_reverse) {
		if (*dir == DIR_RIGHT) {
			*dir = DIR_LEFT;
			return (best_l);
		} else {
			*dir = DIR_RIGHT;
			return (best_r);
		}
	}
	/*
	 * Reset (beginning of queue).
	 */
	RF_ASSERT(*dir == DIR_RIGHT);
	return (queue->queue);
}

void *
rf_SstfCreate(RF_SectorCount_t sect_per_disk, RF_AllocListElem_t *cl_list,
    RF_ShutdownList_t **listp)
{
	RF_Sstf_t *sstfq;

	RF_CallocAndAdd(sstfq, 1, sizeof(RF_Sstf_t), (RF_Sstf_t *), cl_list);
	sstfq->dir = DIR_EITHER;
	sstfq->allow_reverse = 1;
	return ((void *) sstfq);
}

void *
rf_ScanCreate(RF_SectorCount_t sect_per_disk, RF_AllocListElem_t *cl_list,
    RF_ShutdownList_t **listp)
{
	RF_Sstf_t *scanq;

	RF_CallocAndAdd(scanq, 1, sizeof(RF_Sstf_t), (RF_Sstf_t *), cl_list);
	scanq->dir = DIR_RIGHT;
	scanq->allow_reverse = 1;
	return ((void *) scanq);
}

void *
rf_CscanCreate(RF_SectorCount_t sect_per_disk, RF_AllocListElem_t *cl_list,
    RF_ShutdownList_t **listp)
{
	RF_Sstf_t *cscanq;

	RF_CallocAndAdd(cscanq, 1, sizeof(RF_Sstf_t), (RF_Sstf_t *), cl_list);
	cscanq->dir = DIR_RIGHT;
	return ((void *) cscanq);
}

void
rf_SstfEnqueue(void *qptr, RF_DiskQueueData_t *req, int priority)
{
	RF_Sstf_t *sstfq;

	sstfq = (RF_Sstf_t *) qptr;

	if (priority == RF_IO_LOW_PRIORITY) {
		if (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {
			RF_DiskQueue_t *dq;
			dq = (RF_DiskQueue_t *) req->queue;
			printf("raid%d: ENQ lopri %d,%d queues are %d,%d,%d.\n",
			       req->raidPtr->raidid, dq->row, dq->col,
			       sstfq->left.qlen, sstfq->right.qlen,
			       sstfq->lopri.qlen);
		}
		rf_do_sstf_ord_q(&sstfq->lopri.queue, &sstfq->lopri.qtail, req);
		sstfq->lopri.qlen++;
	} else {
		if (req->sectorOffset < sstfq->last_sector) {
			rf_do_sstf_ord_q(&sstfq->left.queue,
			    &sstfq->left.qtail, req);
			sstfq->left.qlen++;
		} else {
			rf_do_sstf_ord_q(&sstfq->right.queue,
			    &sstfq->right.qtail, req);
			sstfq->right.qlen++;
		}
	}
}

void
rf_do_dequeue(RF_SstfQ_t *queue, RF_DiskQueueData_t *req)
{
	RF_DiskQueueData_t *req2;

	if (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {
		printf("raid%d: rf_do_dequeue.\n", req->raidPtr->raidid);
	}
	if (req == queue->queue) {
		DO_HEAD_DEQ(req2, queue);
		RF_ASSERT(req2 == req);
	} else
		if (req == queue->qtail) {
			DO_TAIL_DEQ(req2, queue);
			RF_ASSERT(req2 == req);
		} else {
			/* Dequeue from middle of list. */
			RF_ASSERT(req->next);
			RF_ASSERT(req->prev);
			queue->qlen--;
			req->next->prev = req->prev;
			req->prev->next = req->next;
			req->next = req->prev = NULL;
		}
}

RF_DiskQueueData_t *
rf_SstfDequeue(void *qptr)
{
	RF_DiskQueueData_t *req = NULL;
	RF_Sstf_t *sstfq;

	sstfq = (RF_Sstf_t *) qptr;

	if (rf_sstfDebug) {
		RF_DiskQueue_t *dq;
		dq = (RF_DiskQueue_t *) req->queue;
		RF_ASSERT(QSUM(sstfq) == dq->queueLength);
		printf("raid%d: sstf: Dequeue %d,%d queues are %d,%d,%d.\n",
		       req->raidPtr->raidid, dq->row, dq->col,
		       sstfq->left.qlen, sstfq->right.qlen, sstfq->lopri.qlen);
	}
	if (sstfq->left.queue == NULL) {
		RF_ASSERT(sstfq->left.qlen == 0);
		if (sstfq->right.queue == NULL) {
			RF_ASSERT(sstfq->right.qlen == 0);
			if (sstfq->lopri.queue == NULL) {
				RF_ASSERT(sstfq->lopri.qlen == 0);
				return (NULL);
			}
			if (rf_sstfDebug) {
				printf("raid%d: sstf: check for close lopri.\n",
				       req->raidPtr->raidid);
			}
			req = rf_closest_to_arm(&sstfq->lopri,
			    sstfq->last_sector, &sstfq->dir,
			    sstfq->allow_reverse);
			if (rf_sstfDebug) {
				printf("raid%d: sstf: rf_closest_to_arm said"
				       " %lx.\n", req->raidPtr->raidid,
				       (long) req);
			}
			if (req == NULL)
				return (NULL);
			rf_do_dequeue(&sstfq->lopri, req);
		} else {
			DO_BEST_DEQ(sstfq->last_sector, req, &sstfq->right);
		}
	} else {
		if (sstfq->right.queue == NULL) {
			RF_ASSERT(sstfq->right.qlen == 0);
			DO_BEST_DEQ(sstfq->last_sector, req, &sstfq->left);
		} else {
			if (SNUM_DIFF(sstfq->last_sector,
			     sstfq->right.queue->sectorOffset) <
			    SNUM_DIFF(sstfq->last_sector,
			     sstfq->left.qtail->sectorOffset)) {
				DO_HEAD_DEQ(req, &sstfq->right);
			} else {
				DO_TAIL_DEQ(req, &sstfq->left);
			}
		}
	}
	RF_ASSERT(req);
	sstfq->last_sector = req->sectorOffset;
	return (req);
}

RF_DiskQueueData_t *
rf_ScanDequeue(void *qptr)
{
	RF_DiskQueueData_t *req = NULL;
	RF_Sstf_t *scanq;

	scanq = (RF_Sstf_t *) qptr;

	if (rf_scanDebug) {
		RF_DiskQueue_t *dq;
		dq = (RF_DiskQueue_t *) req->queue;
		RF_ASSERT(QSUM(scanq) == dq->queueLength);
		printf("raid%d: scan: Dequeue %d,%d queues are %d,%d,%d.\n",
		       req->raidPtr->raidid, dq->row, dq->col,
		       scanq->left.qlen, scanq->right.qlen, scanq->lopri.qlen);
	}
	if (scanq->left.queue == NULL) {
		RF_ASSERT(scanq->left.qlen == 0);
		if (scanq->right.queue == NULL) {
			RF_ASSERT(scanq->right.qlen == 0);
			if (scanq->lopri.queue == NULL) {
				RF_ASSERT(scanq->lopri.qlen == 0);
				return (NULL);
			}
			req = rf_closest_to_arm(&scanq->lopri,
			    scanq->last_sector, &scanq->dir,
			    scanq->allow_reverse);
			if (req == NULL)
				return (NULL);
			rf_do_dequeue(&scanq->lopri, req);
		} else {
			scanq->dir = DIR_RIGHT;
			DO_HEAD_DEQ(req, &scanq->right);
		}
	} else
		if (scanq->right.queue == NULL) {
			RF_ASSERT(scanq->right.qlen == 0);
			RF_ASSERT(scanq->left.queue);
			scanq->dir = DIR_LEFT;
			DO_TAIL_DEQ(req, &scanq->left);
		} else {
			RF_ASSERT(scanq->right.queue);
			RF_ASSERT(scanq->left.queue);
			if (scanq->dir == DIR_RIGHT) {
				DO_HEAD_DEQ(req, &scanq->right);
			} else {
				DO_TAIL_DEQ(req, &scanq->left);
			}
		}
	RF_ASSERT(req);
	scanq->last_sector = req->sectorOffset;
	return (req);
}

RF_DiskQueueData_t *
rf_CscanDequeue(void *qptr)
{
	RF_DiskQueueData_t *req = NULL;
	RF_Sstf_t *cscanq;

	cscanq = (RF_Sstf_t *) qptr;

	RF_ASSERT(cscanq->dir == DIR_RIGHT);
	if (rf_cscanDebug) {
		RF_DiskQueue_t *dq;
		dq = (RF_DiskQueue_t *) req->queue;
		RF_ASSERT(QSUM(cscanq) == dq->queueLength);
		printf("raid%d: scan: Dequeue %d,%d queues are %d,%d,%d.\n",
		       req->raidPtr->raidid, dq->row, dq->col,
		       cscanq->left.qlen, cscanq->right.qlen,
		       cscanq->lopri.qlen);
	}
	if (cscanq->right.queue) {
		DO_HEAD_DEQ(req, &cscanq->right);
	} else {
		RF_ASSERT(cscanq->right.qlen == 0);
		if (cscanq->left.queue == NULL) {
			RF_ASSERT(cscanq->left.qlen == 0);
			if (cscanq->lopri.queue == NULL) {
				RF_ASSERT(cscanq->lopri.qlen == 0);
				return (NULL);
			}
			req = rf_closest_to_arm(&cscanq->lopri,
			    cscanq->last_sector, &cscanq->dir,
			    cscanq->allow_reverse);
			if (req == NULL)
				return (NULL);
			rf_do_dequeue(&cscanq->lopri, req);
		} else {
			/*
			 * There's I/Os to the left of the arm. Swing
			 * on back (swap queues).
			 */
			cscanq->right = cscanq->left;
			cscanq->left.qlen = 0;
			cscanq->left.queue = cscanq->left.qtail = NULL;
			DO_HEAD_DEQ(req, &cscanq->right);
		}
	}
	RF_ASSERT(req);
	cscanq->last_sector = req->sectorOffset;
	return (req);
}

RF_DiskQueueData_t *
rf_SstfPeek(void *qptr)
{
	RF_DiskQueueData_t *req;
	RF_Sstf_t *sstfq;

	sstfq = (RF_Sstf_t *) qptr;

	if ((sstfq->left.queue == NULL) && (sstfq->right.queue == NULL)) {
		req = rf_closest_to_arm(&sstfq->lopri, sstfq->last_sector,
		    &sstfq->dir, sstfq->allow_reverse);
	} else {
		if (sstfq->left.queue == NULL)
			req = sstfq->right.queue;
		else {
			if (sstfq->right.queue == NULL)
				req = sstfq->left.queue;
			else {
				if (SNUM_DIFF(sstfq->last_sector,
				     sstfq->right.queue->sectorOffset) <
				    SNUM_DIFF(sstfq->last_sector,
				     sstfq->left.qtail->sectorOffset)) {
					req = sstfq->right.queue;
				} else {
					req = sstfq->left.qtail;
				}
			}
		}
	}
	if (req == NULL) {
		RF_ASSERT(QSUM(sstfq) == 0);
	}
	return (req);
}

RF_DiskQueueData_t *
rf_ScanPeek(void *qptr)
{
	RF_DiskQueueData_t *req;
	RF_Sstf_t *scanq;
	int dir;

	scanq = (RF_Sstf_t *) qptr;
	dir = scanq->dir;

	if (scanq->left.queue == NULL) {
		RF_ASSERT(scanq->left.qlen == 0);
		if (scanq->right.queue == NULL) {
			RF_ASSERT(scanq->right.qlen == 0);
			if (scanq->lopri.queue == NULL) {
				RF_ASSERT(scanq->lopri.qlen == 0);
				return (NULL);
			}
			req = rf_closest_to_arm(&scanq->lopri,
			    scanq->last_sector, &dir, scanq->allow_reverse);
		} else {
			req = scanq->right.queue;
		}
	} else
		if (scanq->right.queue == NULL) {
			RF_ASSERT(scanq->right.qlen == 0);
			RF_ASSERT(scanq->left.queue);
			req = scanq->left.qtail;
		} else {
			RF_ASSERT(scanq->right.queue);
			RF_ASSERT(scanq->left.queue);
			if (scanq->dir == DIR_RIGHT) {
				req = scanq->right.queue;
			} else {
				req = scanq->left.qtail;
			}
		}
	if (req == NULL) {
		RF_ASSERT(QSUM(scanq) == 0);
	}
	return (req);
}

RF_DiskQueueData_t *
rf_CscanPeek(void *qptr)
{
	RF_DiskQueueData_t *req;
	RF_Sstf_t *cscanq;

	cscanq = (RF_Sstf_t *) qptr;

	RF_ASSERT(cscanq->dir == DIR_RIGHT);
	if (cscanq->right.queue) {
		req = cscanq->right.queue;
	} else {
		RF_ASSERT(cscanq->right.qlen == 0);
		if (cscanq->left.queue == NULL) {
			RF_ASSERT(cscanq->left.qlen == 0);
			if (cscanq->lopri.queue == NULL) {
				RF_ASSERT(cscanq->lopri.qlen == 0);
				return (NULL);
			}
			req = rf_closest_to_arm(&cscanq->lopri,
			    cscanq->last_sector, &cscanq->dir,
			    cscanq->allow_reverse);
		} else {
			/*
			 * There's I/Os to the left of the arm. We'll end
			 * up swinging on back.
			 */
			req = cscanq->left.queue;
		}
	}
	if (req == NULL) {
		RF_ASSERT(QSUM(cscanq) == 0);
	}
	return (req);
}

int
rf_SstfPromote(void *qptr, RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru)
{
	RF_DiskQueueData_t *r, *next;
	RF_Sstf_t *sstfq;
	int n;

	sstfq = (RF_Sstf_t *) qptr;

	n = 0;
	if (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {
		printf("raid%d: promote %ld %d  queues are %d,%d,%d.\n",
		       r->raidPtr->raidid, (long) parityStripeID,
		       (int) which_ru, sstfq->left.qlen, sstfq->right.qlen,
		       sstfq->lopri.qlen);
	}
	for (r = sstfq->lopri.queue; r; r = next) {
		next = r->next;
		if (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {
			printf("raid%d: check promote %lx.\n",
			       r->raidPtr->raidid, (long) r);
		}
		if ((r->parityStripeID == parityStripeID)
		    && (r->which_ru == which_ru)) {
			rf_do_dequeue(&sstfq->lopri, r);
			rf_SstfEnqueue(qptr, r, RF_IO_NORMAL_PRIORITY);
			n++;
		}
	}
	if (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {
		printf("raid%d: promoted %d matching I/Os queues are"
		       " %d,%d,%d.\n", r->raidPtr->raidid, n, sstfq->left.qlen,
		       sstfq->right.qlen, sstfq->lopri.qlen);
	}
	return (n);
}
@


1.4
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_sstf.c,v 1.3 2000/01/11 18:02:23 peter Exp $	*/
@


1.3
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_sstf.c,v 1.2 1999/02/16 00:03:27 niklas Exp $	*/
d3 1
d31 1
a31 1
/*******************************************************************************
d33 1
a33 1
 * sstf.c --  prioritized shortest seek time first disk queueing code
d35 1
a35 1
 ******************************************************************************/
d48 3
a50 5
#define DIR_LEFT   1
#define DIR_RIGHT  2
#define DIR_EITHER 3

#define SNUM_DIFF(_a_,_b_) (((_a_)>(_b_))?((_a_)-(_b_)):((_b_)-(_a_)))
d52 2
a53 1
#define QSUM(_sstfq_) (((_sstfq_)->lopri.qlen)+((_sstfq_)->left.qlen)+((_sstfq_)->right.qlen))
d55 3
a58 4
static void 
do_sstf_ord_q(RF_DiskQueueData_t **,
    RF_DiskQueueData_t **,
    RF_DiskQueueData_t *);
d60 5
a64 6
static RF_DiskQueueData_t *
closest_to_arm(RF_SstfQ_t *,
    RF_SectorNum_t,
    int *,
    int);
static void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);
d67 3
a69 5
static void 
do_sstf_ord_q(queuep, tailp, req)
	RF_DiskQueueData_t **queuep;
	RF_DiskQueueData_t **tailp;
	RF_DiskQueueData_t *req;
d88 1
a88 1
		/* optimization */
d95 1
a95 1
			/* insert after s, before r */
d105 1
a105 1
	/* insert after s, at end of queue */
d114 49
a162 51
/* for removing from head-of-queue */
#define DO_HEAD_DEQ(_r_,_q_) { \
	_r_ = (_q_)->queue; \
	RF_ASSERT((_r_) != NULL); \
	(_q_)->queue = (_r_)->next; \
	(_q_)->qlen--; \
	if ((_q_)->qlen == 0) { \
		RF_ASSERT((_r_) == (_q_)->qtail); \
		RF_ASSERT((_q_)->queue == NULL); \
		(_q_)->qtail = NULL; \
	} \
	else { \
		RF_ASSERT((_q_)->queue->prev == (_r_)); \
		(_q_)->queue->prev = NULL; \
	} \
}

/* for removing from end-of-queue */
#define DO_TAIL_DEQ(_r_,_q_) { \
	_r_ = (_q_)->qtail; \
	RF_ASSERT((_r_) != NULL); \
	(_q_)->qtail = (_r_)->prev; \
	(_q_)->qlen--; \
	if ((_q_)->qlen == 0) { \
		RF_ASSERT((_r_) == (_q_)->queue); \
		RF_ASSERT((_q_)->qtail == NULL); \
		(_q_)->queue = NULL; \
	} \
	else { \
		RF_ASSERT((_q_)->qtail->next == (_r_)); \
		(_q_)->qtail->next = NULL; \
	} \
}

#define DO_BEST_DEQ(_l_,_r_,_q_) { \
	if (SNUM_DIFF((_q_)->queue->sectorOffset,_l_) \
		< SNUM_DIFF((_q_)->qtail->sectorOffset,_l_)) \
	{ \
		DO_HEAD_DEQ(_r_,_q_); \
	} \
	else { \
		DO_TAIL_DEQ(_r_,_q_); \
	} \
}

static RF_DiskQueueData_t *
closest_to_arm(queue, arm_pos, dir, allow_reverse)
	RF_SstfQ_t *queue;
	RF_SectorNum_t arm_pos;
	int    *dir;
	int     allow_reverse;
d196 1
a196 1
					/* getting farther away */
d239 3
a241 5
void   *
rf_SstfCreate(sect_per_disk, cl_list, listp)
	RF_SectorCount_t sect_per_disk;
	RF_AllocListElem_t *cl_list;
	RF_ShutdownList_t **listp;
d251 3
a253 5
void   *
rf_ScanCreate(sect_per_disk, cl_list, listp)
	RF_SectorCount_t sect_per_disk;
	RF_AllocListElem_t *cl_list;
	RF_ShutdownList_t **listp;
d263 3
a265 5
void   *
rf_CscanCreate(sect_per_disk, cl_list, listp)
	RF_SectorCount_t sect_per_disk;
	RF_AllocListElem_t *cl_list;
	RF_ShutdownList_t **listp;
d274 2
a275 5
void 
rf_SstfEnqueue(qptr, req, priority)
	void   *qptr;
	RF_DiskQueueData_t *req;
	int     priority;
d285 2
a286 3
			printf("raid%d: ENQ lopri %d,%d queues are %d,%d,%d\n",
			       req->raidPtr->raidid,
			       dq->row, dq->col, 
d288 1
a288 1
			    sstfq->lopri.qlen);
d290 1
a290 1
		do_sstf_ord_q(&sstfq->lopri.queue, &sstfq->lopri.qtail, req);
d294 2
a295 1
			do_sstf_ord_q(&sstfq->left.queue, &sstfq->left.qtail, req);
d298 2
a299 1
			do_sstf_ord_q(&sstfq->right.queue, &sstfq->right.qtail, req);
d305 2
a306 4
static void 
do_dequeue(queue, req)
	RF_SstfQ_t *queue;
	RF_DiskQueueData_t *req;
d311 1
a311 1
		printf("raid%d: do_dequeue\n", req->raidPtr->raidid);
d321 1
a321 1
			/* dequeue from middle of list */
d332 1
a332 2
rf_SstfDequeue(qptr)
	void   *qptr;
d343 2
a344 2
		printf("raid%d: sstf: Dequeue %d,%d queues are %d,%d,%d\n",
		       req->raidPtr->raidid, dq->row, dq->col, 
d356 1
a356 1
				printf("raid%d: sstf: check for close lopri",
d359 3
a361 2
			req = closest_to_arm(&sstfq->lopri, sstfq->last_sector,
			    &sstfq->dir, sstfq->allow_reverse);
d363 3
a365 2
				printf("raid%d: sstf: closest_to_arm said %lx",
				       req->raidPtr->raidid, (long) req);
d369 1
a369 1
			do_dequeue(&sstfq->lopri, req);
d378 4
a381 2
			if (SNUM_DIFF(sstfq->last_sector, sstfq->right.queue->sectorOffset)
			    < SNUM_DIFF(sstfq->last_sector, sstfq->left.qtail->sectorOffset)) {
d394 1
a394 2
rf_ScanDequeue(qptr)
	void   *qptr;
d405 2
a406 2
		printf("raid%d: scan: Dequeue %d,%d queues are %d,%d,%d\n", 
		       req->raidPtr->raidid, dq->row, dq->col, 
d417 3
a419 2
			req = closest_to_arm(&scanq->lopri, scanq->last_sector,
			    &scanq->dir, scanq->allow_reverse);
d422 1
a422 1
			do_dequeue(&scanq->lopri, req);
d448 1
a448 2
rf_CscanDequeue(qptr)
	void   *qptr;
d460 1
a460 1
		printf("raid%d: scan: Dequeue %d,%d queues are %d,%d,%d\n", 
d463 1
a463 1
		    cscanq->lopri.qlen);
d475 3
a477 2
			req = closest_to_arm(&cscanq->lopri, cscanq->last_sector,
			    &cscanq->dir, cscanq->allow_reverse);
d480 1
a480 1
			do_dequeue(&cscanq->lopri, req);
d498 1
a498 2
rf_SstfPeek(qptr)
	void   *qptr;
d506 2
a507 2
		req = closest_to_arm(&sstfq->lopri, sstfq->last_sector, &sstfq->dir,
		    sstfq->allow_reverse);
d515 4
a518 2
				if (SNUM_DIFF(sstfq->last_sector, sstfq->right.queue->sectorOffset)
				    < SNUM_DIFF(sstfq->last_sector, sstfq->left.qtail->sectorOffset)) {
d533 1
a533 2
rf_ScanPeek(qptr)
	void   *qptr;
d537 1
a537 1
	int     dir;
d550 2
a551 2
			req = closest_to_arm(&scanq->lopri, scanq->last_sector,
			    &dir, scanq->allow_reverse);
d576 1
a576 2
rf_CscanPeek(qptr)
	void   *qptr;
d594 3
a596 2
			req = closest_to_arm(&cscanq->lopri, cscanq->last_sector,
			    &cscanq->dir, cscanq->allow_reverse);
d611 3
a613 5
int 
rf_SstfPromote(qptr, parityStripeID, which_ru)
	void   *qptr;
	RF_StripeNum_t parityStripeID;
	RF_ReconUnitNum_t which_ru;
d617 1
a617 1
	int     n;
d623 4
a626 6
		printf("raid%d: promote %ld %d  queues are %d,%d,%d\n",
		       r->raidPtr->raidid, (long) parityStripeID, 
		       (int) which_ru,
		    sstfq->left.qlen,
		    sstfq->right.qlen,
		    sstfq->lopri.qlen);
d631 1
a631 1
			printf("raid%d: check promote %lx\n",
d636 1
a636 1
			do_dequeue(&sstfq->lopri, r);
d642 2
a643 2
		printf("raid%d: promoted %d matching I/Os queues are %d,%d,%d\n",
		       r->raidPtr->raidid, n, sstfq->left.qlen, 
@


1.3.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d32 1
a32 1
 * sstf.c --  Prioritized shortest seek time first disk queueing code.
d34 1
a34 1
 *****************************************************************************/
d47 5
a51 3
#define	DIR_LEFT	1
#define	DIR_RIGHT	2
#define	DIR_EITHER	3
d53 1
a53 2
#define	SNUM_DIFF(_a_,_b_)						\
	(((_a_) > (_b_)) ? ((_a_) - (_b_)) : ((_b_) - (_a_)))
a54 3
#define	QSUM(_sstfq_)							\
	(((_sstfq_)->lopri.qlen) + ((_sstfq_)->left.qlen) +		\
	 ((_sstfq_)->right.qlen))
d56 4
d61 6
a66 5
void rf_do_sstf_ord_q(RF_DiskQueueData_t **, RF_DiskQueueData_t **,
	RF_DiskQueueData_t *);
void rf_do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);
RF_DiskQueueData_t *rf_closest_to_arm(RF_SstfQ_t *, RF_SectorNum_t,
	int *, int);
d69 5
a73 3
void
rf_do_sstf_ord_q(RF_DiskQueueData_t **queuep, RF_DiskQueueData_t **tailp,
    RF_DiskQueueData_t *req)
d92 1
a92 1
		/* Optimization. */
d99 1
a99 1
			/* Insert after s, before r. */
d109 1
a109 1
	/* Insert after s, at end of queue. */
d118 51
a168 49

/* For removing from head-of-queue. */
#define	DO_HEAD_DEQ(_r_,_q_)						\
do {									\
	_r_ = (_q_)->queue;						\
	RF_ASSERT((_r_) != NULL);					\
	(_q_)->queue = (_r_)->next;					\
	(_q_)->qlen--;							\
	if ((_q_)->qlen == 0) {						\
		RF_ASSERT((_r_) == (_q_)->qtail);			\
		RF_ASSERT((_q_)->queue == NULL);			\
		(_q_)->qtail = NULL;					\
	} else {							\
		RF_ASSERT((_q_)->queue->prev == (_r_));			\
		(_q_)->queue->prev = NULL;				\
	}								\
} while (0)

/* For removing from end-of-queue. */
#define	DO_TAIL_DEQ(_r_,_q_)						\
do {									\
	_r_ = (_q_)->qtail;						\
	RF_ASSERT((_r_) != NULL);					\
	(_q_)->qtail = (_r_)->prev;					\
	(_q_)->qlen--;							\
	if ((_q_)->qlen == 0) {						\
		RF_ASSERT((_r_) == (_q_)->queue);			\
		RF_ASSERT((_q_)->qtail == NULL);			\
		(_q_)->queue = NULL;					\
	} else {							\
		RF_ASSERT((_q_)->qtail->next == (_r_));			\
		(_q_)->qtail->next = NULL;				\
	}								\
} while (0)

#define	DO_BEST_DEQ(_l_,_r_,_q_)					\
do {									\
	if (SNUM_DIFF((_q_)->queue->sectorOffset,_l_)			\
		< SNUM_DIFF((_q_)->qtail->sectorOffset,_l_))		\
	{								\
		DO_HEAD_DEQ(_r_,_q_);					\
	} else {							\
		DO_TAIL_DEQ(_r_,_q_);					\
	}								\
} while (0)

RF_DiskQueueData_t *
rf_closest_to_arm(RF_SstfQ_t *queue, RF_SectorNum_t arm_pos, int *dir,
    int allow_reverse)
d202 1
a202 1
					/* Getting farther away. */
d245 5
a249 3
void *
rf_SstfCreate(RF_SectorCount_t sect_per_disk, RF_AllocListElem_t *cl_list,
    RF_ShutdownList_t **listp)
d259 5
a263 3
void *
rf_ScanCreate(RF_SectorCount_t sect_per_disk, RF_AllocListElem_t *cl_list,
    RF_ShutdownList_t **listp)
d273 5
a277 3
void *
rf_CscanCreate(RF_SectorCount_t sect_per_disk, RF_AllocListElem_t *cl_list,
    RF_ShutdownList_t **listp)
d286 5
a290 2
void
rf_SstfEnqueue(void *qptr, RF_DiskQueueData_t *req, int priority)
d300 3
a302 2
			printf("raid%d: ENQ lopri %d,%d queues are %d,%d,%d.\n",
			       req->raidPtr->raidid, dq->row, dq->col,
d304 1
a304 1
			       sstfq->lopri.qlen);
d306 1
a306 1
		rf_do_sstf_ord_q(&sstfq->lopri.queue, &sstfq->lopri.qtail, req);
d310 1
a310 2
			rf_do_sstf_ord_q(&sstfq->left.queue,
			    &sstfq->left.qtail, req);
d313 1
a313 2
			rf_do_sstf_ord_q(&sstfq->right.queue,
			    &sstfq->right.qtail, req);
d319 4
a322 2
void
rf_do_dequeue(RF_SstfQ_t *queue, RF_DiskQueueData_t *req)
d327 1
a327 1
		printf("raid%d: rf_do_dequeue.\n", req->raidPtr->raidid);
d337 1
a337 1
			/* Dequeue from middle of list. */
d348 2
a349 1
rf_SstfDequeue(void *qptr)
d360 2
a361 2
		printf("raid%d: sstf: Dequeue %d,%d queues are %d,%d,%d.\n",
		       req->raidPtr->raidid, dq->row, dq->col,
d373 1
a373 1
				printf("raid%d: sstf: check for close lopri.\n",
d376 2
a377 3
			req = rf_closest_to_arm(&sstfq->lopri,
			    sstfq->last_sector, &sstfq->dir,
			    sstfq->allow_reverse);
d379 2
a380 3
				printf("raid%d: sstf: rf_closest_to_arm said"
				       " %lx.\n", req->raidPtr->raidid,
				       (long) req);
d384 1
a384 1
			rf_do_dequeue(&sstfq->lopri, req);
d393 2
a394 4
			if (SNUM_DIFF(sstfq->last_sector,
			     sstfq->right.queue->sectorOffset) <
			    SNUM_DIFF(sstfq->last_sector,
			     sstfq->left.qtail->sectorOffset)) {
d407 2
a408 1
rf_ScanDequeue(void *qptr)
d419 2
a420 2
		printf("raid%d: scan: Dequeue %d,%d queues are %d,%d,%d.\n",
		       req->raidPtr->raidid, dq->row, dq->col,
d431 2
a432 3
			req = rf_closest_to_arm(&scanq->lopri,
			    scanq->last_sector, &scanq->dir,
			    scanq->allow_reverse);
d435 1
a435 1
			rf_do_dequeue(&scanq->lopri, req);
d461 2
a462 1
rf_CscanDequeue(void *qptr)
d474 1
a474 1
		printf("raid%d: scan: Dequeue %d,%d queues are %d,%d,%d.\n",
d477 1
a477 1
		       cscanq->lopri.qlen);
d489 2
a490 3
			req = rf_closest_to_arm(&cscanq->lopri,
			    cscanq->last_sector, &cscanq->dir,
			    cscanq->allow_reverse);
d493 1
a493 1
			rf_do_dequeue(&cscanq->lopri, req);
d511 2
a512 1
rf_SstfPeek(void *qptr)
d520 2
a521 2
		req = rf_closest_to_arm(&sstfq->lopri, sstfq->last_sector,
		    &sstfq->dir, sstfq->allow_reverse);
d529 2
a530 4
				if (SNUM_DIFF(sstfq->last_sector,
				     sstfq->right.queue->sectorOffset) <
				    SNUM_DIFF(sstfq->last_sector,
				     sstfq->left.qtail->sectorOffset)) {
d545 2
a546 1
rf_ScanPeek(void *qptr)
d550 1
a550 1
	int dir;
d563 2
a564 2
			req = rf_closest_to_arm(&scanq->lopri,
			    scanq->last_sector, &dir, scanq->allow_reverse);
d589 2
a590 1
rf_CscanPeek(void *qptr)
d608 2
a609 3
			req = rf_closest_to_arm(&cscanq->lopri,
			    cscanq->last_sector, &cscanq->dir,
			    cscanq->allow_reverse);
d624 5
a628 3
int
rf_SstfPromote(void *qptr, RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru)
d632 1
a632 1
	int n;
d638 6
a643 4
		printf("raid%d: promote %ld %d  queues are %d,%d,%d.\n",
		       r->raidPtr->raidid, (long) parityStripeID,
		       (int) which_ru, sstfq->left.qlen, sstfq->right.qlen,
		       sstfq->lopri.qlen);
d648 1
a648 1
			printf("raid%d: check promote %lx.\n",
d653 1
a653 1
			rf_do_dequeue(&sstfq->lopri, r);
d659 2
a660 2
		printf("raid%d: promoted %d matching I/Os queues are"
		       " %d,%d,%d.\n", r->raidPtr->raidid, n, sstfq->left.qlen,
@


1.3.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d32 1
a32 1
 * sstf.c --  Prioritized shortest seek time first disk queueing code.
d34 1
a34 1
 *****************************************************************************/
d47 5
a51 3
#define	DIR_LEFT	1
#define	DIR_RIGHT	2
#define	DIR_EITHER	3
d53 1
a53 2
#define	SNUM_DIFF(_a_,_b_)						\
	(((_a_) > (_b_)) ? ((_a_) - (_b_)) : ((_b_) - (_a_)))
a54 3
#define	QSUM(_sstfq_)							\
	(((_sstfq_)->lopri.qlen) + ((_sstfq_)->left.qlen) +		\
	 ((_sstfq_)->right.qlen))
d56 4
d61 6
a66 5
void rf_do_sstf_ord_q(RF_DiskQueueData_t **, RF_DiskQueueData_t **,
	RF_DiskQueueData_t *);
void rf_do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);
RF_DiskQueueData_t *rf_closest_to_arm(RF_SstfQ_t *, RF_SectorNum_t,
	int *, int);
d69 5
a73 3
void
rf_do_sstf_ord_q(RF_DiskQueueData_t **queuep, RF_DiskQueueData_t **tailp,
    RF_DiskQueueData_t *req)
d92 1
a92 1
		/* Optimization. */
d99 1
a99 1
			/* Insert after s, before r. */
d109 1
a109 1
	/* Insert after s, at end of queue. */
d118 51
a168 49

/* For removing from head-of-queue. */
#define	DO_HEAD_DEQ(_r_,_q_)						\
do {									\
	_r_ = (_q_)->queue;						\
	RF_ASSERT((_r_) != NULL);					\
	(_q_)->queue = (_r_)->next;					\
	(_q_)->qlen--;							\
	if ((_q_)->qlen == 0) {						\
		RF_ASSERT((_r_) == (_q_)->qtail);			\
		RF_ASSERT((_q_)->queue == NULL);			\
		(_q_)->qtail = NULL;					\
	} else {							\
		RF_ASSERT((_q_)->queue->prev == (_r_));			\
		(_q_)->queue->prev = NULL;				\
	}								\
} while (0)

/* For removing from end-of-queue. */
#define	DO_TAIL_DEQ(_r_,_q_)						\
do {									\
	_r_ = (_q_)->qtail;						\
	RF_ASSERT((_r_) != NULL);					\
	(_q_)->qtail = (_r_)->prev;					\
	(_q_)->qlen--;							\
	if ((_q_)->qlen == 0) {						\
		RF_ASSERT((_r_) == (_q_)->queue);			\
		RF_ASSERT((_q_)->qtail == NULL);			\
		(_q_)->queue = NULL;					\
	} else {							\
		RF_ASSERT((_q_)->qtail->next == (_r_));			\
		(_q_)->qtail->next = NULL;				\
	}								\
} while (0)

#define	DO_BEST_DEQ(_l_,_r_,_q_)					\
do {									\
	if (SNUM_DIFF((_q_)->queue->sectorOffset,_l_)			\
		< SNUM_DIFF((_q_)->qtail->sectorOffset,_l_))		\
	{								\
		DO_HEAD_DEQ(_r_,_q_);					\
	} else {							\
		DO_TAIL_DEQ(_r_,_q_);					\
	}								\
} while (0)

RF_DiskQueueData_t *
rf_closest_to_arm(RF_SstfQ_t *queue, RF_SectorNum_t arm_pos, int *dir,
    int allow_reverse)
d202 1
a202 1
					/* Getting farther away. */
d245 5
a249 3
void *
rf_SstfCreate(RF_SectorCount_t sect_per_disk, RF_AllocListElem_t *cl_list,
    RF_ShutdownList_t **listp)
d259 5
a263 3
void *
rf_ScanCreate(RF_SectorCount_t sect_per_disk, RF_AllocListElem_t *cl_list,
    RF_ShutdownList_t **listp)
d273 5
a277 3
void *
rf_CscanCreate(RF_SectorCount_t sect_per_disk, RF_AllocListElem_t *cl_list,
    RF_ShutdownList_t **listp)
d286 5
a290 2
void
rf_SstfEnqueue(void *qptr, RF_DiskQueueData_t *req, int priority)
d300 3
a302 2
			printf("raid%d: ENQ lopri %d,%d queues are %d,%d,%d.\n",
			       req->raidPtr->raidid, dq->row, dq->col,
d304 1
a304 1
			       sstfq->lopri.qlen);
d306 1
a306 1
		rf_do_sstf_ord_q(&sstfq->lopri.queue, &sstfq->lopri.qtail, req);
d310 1
a310 2
			rf_do_sstf_ord_q(&sstfq->left.queue,
			    &sstfq->left.qtail, req);
d313 1
a313 2
			rf_do_sstf_ord_q(&sstfq->right.queue,
			    &sstfq->right.qtail, req);
d319 4
a322 2
void
rf_do_dequeue(RF_SstfQ_t *queue, RF_DiskQueueData_t *req)
d327 1
a327 1
		printf("raid%d: rf_do_dequeue.\n", req->raidPtr->raidid);
d337 1
a337 1
			/* Dequeue from middle of list. */
d348 2
a349 1
rf_SstfDequeue(void *qptr)
d360 2
a361 2
		printf("raid%d: sstf: Dequeue %d,%d queues are %d,%d,%d.\n",
		       req->raidPtr->raidid, dq->row, dq->col,
d373 1
a373 1
				printf("raid%d: sstf: check for close lopri.\n",
d376 2
a377 3
			req = rf_closest_to_arm(&sstfq->lopri,
			    sstfq->last_sector, &sstfq->dir,
			    sstfq->allow_reverse);
d379 2
a380 3
				printf("raid%d: sstf: rf_closest_to_arm said"
				       " %lx.\n", req->raidPtr->raidid,
				       (long) req);
d384 1
a384 1
			rf_do_dequeue(&sstfq->lopri, req);
d393 2
a394 4
			if (SNUM_DIFF(sstfq->last_sector,
			     sstfq->right.queue->sectorOffset) <
			    SNUM_DIFF(sstfq->last_sector,
			     sstfq->left.qtail->sectorOffset)) {
d407 2
a408 1
rf_ScanDequeue(void *qptr)
d419 2
a420 2
		printf("raid%d: scan: Dequeue %d,%d queues are %d,%d,%d.\n",
		       req->raidPtr->raidid, dq->row, dq->col,
d431 2
a432 3
			req = rf_closest_to_arm(&scanq->lopri,
			    scanq->last_sector, &scanq->dir,
			    scanq->allow_reverse);
d435 1
a435 1
			rf_do_dequeue(&scanq->lopri, req);
d461 2
a462 1
rf_CscanDequeue(void *qptr)
d474 1
a474 1
		printf("raid%d: scan: Dequeue %d,%d queues are %d,%d,%d.\n",
d477 1
a477 1
		       cscanq->lopri.qlen);
d489 2
a490 3
			req = rf_closest_to_arm(&cscanq->lopri,
			    cscanq->last_sector, &cscanq->dir,
			    cscanq->allow_reverse);
d493 1
a493 1
			rf_do_dequeue(&cscanq->lopri, req);
d511 2
a512 1
rf_SstfPeek(void *qptr)
d520 2
a521 2
		req = rf_closest_to_arm(&sstfq->lopri, sstfq->last_sector,
		    &sstfq->dir, sstfq->allow_reverse);
d529 2
a530 4
				if (SNUM_DIFF(sstfq->last_sector,
				     sstfq->right.queue->sectorOffset) <
				    SNUM_DIFF(sstfq->last_sector,
				     sstfq->left.qtail->sectorOffset)) {
d545 2
a546 1
rf_ScanPeek(void *qptr)
d550 1
a550 1
	int dir;
d563 2
a564 2
			req = rf_closest_to_arm(&scanq->lopri,
			    scanq->last_sector, &dir, scanq->allow_reverse);
d589 2
a590 1
rf_CscanPeek(void *qptr)
d608 2
a609 3
			req = rf_closest_to_arm(&cscanq->lopri,
			    cscanq->last_sector, &cscanq->dir,
			    cscanq->allow_reverse);
d624 5
a628 3
int
rf_SstfPromote(void *qptr, RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru)
d632 1
a632 1
	int n;
d638 6
a643 4
		printf("raid%d: promote %ld %d  queues are %d,%d,%d.\n",
		       r->raidPtr->raidid, (long) parityStripeID,
		       (int) which_ru, sstfq->left.qlen, sstfq->right.qlen,
		       sstfq->lopri.qlen);
d648 1
a648 1
			printf("raid%d: check promote %lx.\n",
d653 1
a653 1
			rf_do_dequeue(&sstfq->lopri, r);
d659 2
a660 2
		printf("raid%d: promoted %d matching I/Os queues are"
		       " %d,%d,%d.\n", r->raidPtr->raidid, n, sstfq->left.qlen,
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_sstf.c,v 1.1 1999/01/11 14:29:50 niklas Exp $	*/
/*	$NetBSD: rf_sstf.c,v 1.3 1999/02/05 00:06:17 oster Exp $	*/
a42 1
#include "rf_threadid.h"
d44 2
a298 2
			int     tid;
			rf_get_threadid(tid);
d300 4
a303 2
			printf("[%d] ENQ lopri %d,%d queues are %d,%d,%d\n",
			    tid, dq->row, dq->col, sstfq->left.qlen, sstfq->right.qlen,
d327 1
a327 3
		int     tid;
		rf_get_threadid(tid);
		printf("[%d] do_dequeue\n", tid);
a357 2
		int     tid;
		rf_get_threadid(tid);
d360 3
a362 3
		printf("[%d] sstf: Dequeue %d,%d queues are %d,%d,%d\n", tid,
		    dq->row, dq->col, sstfq->left.qlen, sstfq->right.qlen,
		    sstfq->lopri.qlen);
d373 2
a374 3
				int     tid;
				rf_get_threadid(tid);
				printf("[%d] sstf: check for close lopri", tid);
d379 2
a380 3
				int     tid;
				rf_get_threadid(tid);
				printf("[%d] sstf: closest_to_arm said %lx", tid, (long) req);
a416 2
		int     tid;
		rf_get_threadid(tid);
d419 3
a421 3
		printf("[%d] scan: Dequeue %d,%d queues are %d,%d,%d\n", tid,
		    dq->row, dq->col, scanq->left.qlen, scanq->right.qlen,
		    scanq->lopri.qlen);
a471 2
		int     tid;
		rf_get_threadid(tid);
d474 3
a476 2
		printf("[%d] scan: Dequeue %d,%d queues are %d,%d,%d\n", tid,
		    dq->row, dq->col, cscanq->left.qlen, cscanq->right.qlen,
d638 3
a640 4
		int     tid;
		rf_get_threadid(tid);
		printf("[%d] promote %ld %d  queues are %d,%d,%d\n",
		    tid, (long) parityStripeID, (int) which_ru,
d648 2
a649 3
			int     tid;
			rf_get_threadid(tid);
			printf("[%d] check promote %lx\n", tid, (long) r);
d659 3
a661 4
		int     tid;
		rf_get_threadid(tid);
		printf("[%d] promoted %d matching I/Os queues are %d,%d,%d\n",
		    tid, n, sstfq->left.qlen, sstfq->right.qlen, sstfq->lopri.qlen);
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_sstf.c,v 1.1 1998/11/13 04:20:34 oster Exp $	*/
/*	$NetBSD: rf_sstf.c,v 1.1 1998/11/13 04:20:34 oster Exp $	*/
a35 29
/*
 * :  
 * Log: rf_sstf.c,v 
 * Revision 1.7  1996/06/19 14:09:56  jimz
 * SstfPeek wasn't calling closest_to_arm() properly- would bogart
 * low priority I/Os
 *
 * Revision 1.6  1996/06/18  20:53:11  jimz
 * fix up disk queueing (remove configure routine,
 * add shutdown list arg to create routines)
 *
 * Revision 1.5  1996/06/13  20:42:13  jimz
 * add scan, cscan
 *
 * Revision 1.4  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.3  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.2  1996/06/06  01:11:35  jimz
 * fixed many priority-related bugs
 *
 * Revision 1.1  1996/06/05  19:17:40  jimz
 * Initial revision
 *
 */

d55 18
a72 15
static void do_sstf_ord_q(RF_DiskQueueData_t  **,
			  RF_DiskQueueData_t  **,
			  RF_DiskQueueData_t   *);

static RF_DiskQueueData_t *closest_to_arm(RF_SstfQ_t *,
					  RF_SectorNum_t,
					  int *,
					  int);
static void do_dequeue(RF_SstfQ_t          *, RF_DiskQueueData_t  *);


static void do_sstf_ord_q(queuep, tailp, req)
  RF_DiskQueueData_t  **queuep;
  RF_DiskQueueData_t  **tailp;
  RF_DiskQueueData_t   *req;
d96 1
a96 1
	for(s=NULL,r=*queuep;r;s=r,r=r->next) {
a116 1

d162 6
a167 5
static RF_DiskQueueData_t *closest_to_arm(queue, arm_pos, dir, allow_reverse)
  RF_SstfQ_t      *queue;
  RF_SectorNum_t   arm_pos;
  int             *dir;
  int              allow_reverse;
d169 2
a170 2
	RF_SectorNum_t best_pos_l=0, this_pos_l=0, last_pos=0;
	RF_SectorNum_t best_pos_r=0, this_pos_r=0;
d174 1
a174 1
	for(r=queue->queue;r;r=r->next) {
d179 1
a179 2
			}
			else {
d184 1
a184 2
				}
				else {
d188 1
a188 2
		}
		else {
d192 1
a192 2
			}
			else {
d197 1
a197 2
				}
				else {
d208 1
a208 1
		return(NULL);
d210 1
a210 1
		return(best_r);
d212 1
a212 1
		return(best_l);
d215 1
a215 1
			return(best_r);
d217 1
a217 1
			return(best_l);
d219 1
a219 1
			return(best_r);
d221 1
a221 1
			return(best_l);
d231 2
a232 3
			return(best_l);
		}
		else {
d234 1
a234 1
			return(best_r);
d241 1
a241 1
	return(queue->queue);
d244 5
a248 4
void *rf_SstfCreate(sect_per_disk, cl_list, listp)
  RF_SectorCount_t      sect_per_disk;
  RF_AllocListElem_t   *cl_list;
  RF_ShutdownList_t   **listp;
d255 1
a255 1
	return((void *)sstfq);
d258 5
a262 4
void *rf_ScanCreate(sect_per_disk, cl_list, listp)
  RF_SectorCount_t      sect_per_disk;
  RF_AllocListElem_t   *cl_list;
  RF_ShutdownList_t   **listp;
d269 1
a269 1
	return((void *)scanq);
d272 5
a276 4
void *rf_CscanCreate(sect_per_disk, cl_list, listp)
  RF_SectorCount_t      sect_per_disk;
  RF_AllocListElem_t   *cl_list;
  RF_ShutdownList_t   **listp;
d282 1
a282 1
	return((void *)cscanq);
d285 5
a289 4
void rf_SstfEnqueue(qptr, req, priority)
  void                *qptr;
  RF_DiskQueueData_t  *req;
  int                  priority;
d293 1
a293 1
	sstfq = (RF_Sstf_t *)qptr;
d298 1
a298 1
			int tid;
d300 1
a300 1
			dq = (RF_DiskQueue_t *)req->queue;
d302 2
a303 2
				tid, dq->row, dq->col, sstfq->left.qlen, sstfq->right.qlen,
				sstfq->lopri.qlen);
d307 1
a307 2
	}
	else {
d311 1
a311 2
		}
		else {
d318 4
a321 3
static void do_dequeue(queue, req)
  RF_SstfQ_t          *queue;
  RF_DiskQueueData_t  *req;
d323 1
a323 1
	RF_DiskQueueData_t  *req2;
d326 1
a326 1
		int tid;
d331 1
a331 1
		DO_HEAD_DEQ(req2,queue);
d333 13
a345 14
	}
	else if (req == queue->qtail) {
		DO_TAIL_DEQ(req2,queue);
		RF_ASSERT(req2 == req);
	}
	else {
		/* dequeue from middle of list */
		RF_ASSERT(req->next);
		RF_ASSERT(req->prev);
		queue->qlen--;
		req->next->prev = req->prev;
		req->prev->next = req->next;
		req->next = req->prev = NULL;
	}
d348 3
a350 2
RF_DiskQueueData_t *rf_SstfDequeue(qptr)
  void  *qptr;
d352 1
a352 1
	RF_DiskQueueData_t *req=NULL;
d355 1
a355 1
	sstfq = (RF_Sstf_t *)qptr;
d359 1
a359 1
		int tid;
d361 2
a362 2
		dq = (RF_DiskQueue_t *)req->queue;
		RF_ASSERT(QSUM(sstfq)==dq->queueLength);
d364 2
a365 2
			dq->row, dq->col, sstfq->left.qlen, sstfq->right.qlen,
			sstfq->lopri.qlen);
d373 1
a373 1
				return(NULL);
d376 1
a376 1
				int tid;
d381 1
a381 1
				&sstfq->dir, sstfq->allow_reverse);
d383 1
a383 1
				int tid;
d385 1
a385 1
				printf("[%d] sstf: closest_to_arm said %lx", tid, (long)req);
d388 1
a388 1
				return(NULL);
d390 2
d393 1
a393 5
		else {
			DO_BEST_DEQ(sstfq->last_sector,req,&sstfq->right);
		}
	}
	else {
d396 7
a402 10
			DO_BEST_DEQ(sstfq->last_sector,req,&sstfq->left);
		}
		else {
			if (SNUM_DIFF(sstfq->last_sector,sstfq->right.queue->sectorOffset)
				< SNUM_DIFF(sstfq->last_sector,sstfq->left.qtail->sectorOffset))
			{
				DO_HEAD_DEQ(req,&sstfq->right);
			}
			else {
				DO_TAIL_DEQ(req,&sstfq->left);
d408 1
a408 1
	return(req);
d411 3
a413 2
RF_DiskQueueData_t *rf_ScanDequeue(qptr)
  void  *qptr;
d415 1
a415 1
	RF_DiskQueueData_t *req=NULL;
d418 1
a418 1
	scanq = (RF_Sstf_t *)qptr;
d422 1
a422 1
		int tid;
d424 2
a425 2
		dq = (RF_DiskQueue_t *)req->queue;
		RF_ASSERT(QSUM(scanq)==dq->queueLength);
d427 2
a428 2
			dq->row, dq->col, scanq->left.qlen, scanq->right.qlen,
			scanq->lopri.qlen);
d436 1
a436 1
				return(NULL);
d439 1
a439 1
				&scanq->dir, scanq->allow_reverse);
d441 1
a441 1
				return(NULL);
d443 1
a443 2
		}
		else {
d445 1
a445 1
			DO_HEAD_DEQ(req,&scanq->right);
d447 14
a460 12
	}
	else if (scanq->right.queue == NULL) {
		RF_ASSERT(scanq->right.qlen == 0);
		RF_ASSERT(scanq->left.queue);
		scanq->dir = DIR_LEFT;
		DO_TAIL_DEQ(req,&scanq->left);
	}
	else {
		RF_ASSERT(scanq->right.queue);
		RF_ASSERT(scanq->left.queue);
		if (scanq->dir == DIR_RIGHT) {
			DO_HEAD_DEQ(req,&scanq->right);
a461 4
		else {
			DO_TAIL_DEQ(req,&scanq->left);
		}
	}
d464 1
a464 1
	return(req);
d467 3
a469 2
RF_DiskQueueData_t *rf_CscanDequeue(qptr)
  void  *qptr;
d471 1
a471 1
	RF_DiskQueueData_t *req=NULL;
d474 1
a474 1
	cscanq = (RF_Sstf_t *)qptr;
d479 1
a479 1
		int tid;
d481 2
a482 2
		dq = (RF_DiskQueue_t *)req->queue;
		RF_ASSERT(QSUM(cscanq)==dq->queueLength);
d484 2
a485 2
			dq->row, dq->col, cscanq->left.qlen, cscanq->right.qlen,
			cscanq->lopri.qlen);
d488 2
a489 3
		DO_HEAD_DEQ(req,&cscanq->right);
	}
	else {
d495 1
a495 1
				return(NULL);
d498 1
a498 1
				&cscanq->dir, cscanq->allow_reverse);
d500 1
a500 1
				return(NULL);
d502 1
a502 2
		}
		else {
d510 1
a510 1
			DO_HEAD_DEQ(req,&cscanq->right);
d515 1
a515 1
	return(req);
d518 3
a520 2
RF_DiskQueueData_t *rf_SstfPeek(qptr)
  void  *qptr;
d525 1
a525 1
	sstfq = (RF_Sstf_t *)qptr;
d529 2
a530 3
			sstfq->allow_reverse);
	}
	else {
d537 2
a538 3
				if (SNUM_DIFF(sstfq->last_sector,sstfq->right.queue->sectorOffset)
					<SNUM_DIFF(sstfq->last_sector,sstfq->left.qtail->sectorOffset))
				{
d540 1
a540 2
				}
				else {
d549 1
a549 1
	return(req);
d552 3
a554 2
RF_DiskQueueData_t *rf_ScanPeek(qptr)
  void  *qptr;
d558 1
a558 1
	int dir;
d560 1
a560 1
	scanq = (RF_Sstf_t *)qptr;
d569 1
a569 1
				return(NULL);
d572 2
a573 3
				&dir, scanq->allow_reverse);
		}
		else {
d576 4
a579 13
	}
	else if (scanq->right.queue == NULL) {
		RF_ASSERT(scanq->right.qlen == 0);
		RF_ASSERT(scanq->left.queue);
		req = scanq->left.qtail;
	}
	else {
		RF_ASSERT(scanq->right.queue);
		RF_ASSERT(scanq->left.queue);
		if (scanq->dir == DIR_RIGHT) {
			req = scanq->right.queue;
		}
		else {
d581 8
a589 1
	}
d593 1
a593 1
	return(req);
d596 3
a598 2
RF_DiskQueueData_t *rf_CscanPeek(qptr)
  void  *qptr;
d603 1
a603 1
	cscanq = (RF_Sstf_t *)qptr;
d608 1
a608 2
	}
	else {
d614 1
a614 1
				return(NULL);
d617 2
a618 3
				&cscanq->dir, cscanq->allow_reverse);
		}
		else {
d629 1
a629 1
	return(req);
d632 5
a636 4
int rf_SstfPromote(qptr, parityStripeID, which_ru)
  void               *qptr;
  RF_StripeNum_t      parityStripeID;
  RF_ReconUnitNum_t   which_ru;
d640 1
a640 1
	int n;
d642 1
a642 1
	sstfq = (RF_Sstf_t *)qptr;
d646 1
a646 1
		int tid;
d649 4
a652 4
		       tid, (long)parityStripeID, (int)which_ru, 
		       sstfq->left.qlen, 
		       sstfq->right.qlen,
		       sstfq->lopri.qlen);
d654 1
a654 1
	for(r=sstfq->lopri.queue;r;r=next) {
d657 1
a657 1
			int tid;
d659 1
a659 1
			printf("[%d] check promote %lx\n", tid, (long)r);
d662 1
a662 2
			&& (r->which_ru == which_ru))
		{
d669 1
a669 1
		int tid;
d672 1
a672 1
			tid, n, sstfq->left.qlen, sstfq->right.qlen, sstfq->lopri.qlen);
d674 1
a674 1
	return(n);
@

