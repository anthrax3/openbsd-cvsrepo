head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.38
	OPENBSD_5_0:1.5.0.36
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.34
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.32
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.28
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.16
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.14
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.12
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.10
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.5;

1.5
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.4.2.1
	1.4.12.1;
next	1.3;

1.3
date	2000.01.07.14.50.22;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.34;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.4.12.1
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_paritylog.c,v 1.5 2002/12/16 07:01:04 tdeval Exp $	*/
/*	$NetBSD: rf_paritylog.c,v 1.5 2000/01/07 03:41:01 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: William V. Courtright II
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * Code for manipulating in-core parity logs.
 */

#include "rf_archs.h"

#if	RF_INCLUDE_PARITYLOGGING > 0

/*
 * Append-only log for recording parity "update" and "overwrite" records.
 */

#include "rf_types.h"
#include "rf_threadstuff.h"
#include "rf_mcpair.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagfuncs.h"
#include "rf_desc.h"
#include "rf_layout.h"
#include "rf_diskqueue.h"
#include "rf_etimer.h"
#include "rf_paritylog.h"
#include "rf_general.h"
#include "rf_map.h"
#include "rf_paritylogging.h"
#include "rf_paritylogDiskMgr.h"

RF_CommonLogData_t *rf_AllocParityLogCommonData(RF_Raid_t *);
void rf_FreeParityLogCommonData(RF_CommonLogData_t *);
RF_ParityLogData_t *rf_AllocParityLogData(RF_Raid_t *);
void rf_FreeParityLogData(RF_ParityLogData_t *);
void rf_EnqueueParityLogData(RF_ParityLogData_t *, RF_ParityLogData_t **,
	RF_ParityLogData_t **);
RF_ParityLogData_t *rf_DequeueParityLogData(RF_Raid_t *, RF_ParityLogData_t **,
	RF_ParityLogData_t **, int);
void rf_RequeueParityLogData(RF_ParityLogData_t *, RF_ParityLogData_t **,
	RF_ParityLogData_t **);
RF_ParityLogData_t *rf_DequeueMatchingLogData(RF_Raid_t *,
	RF_ParityLogData_t **, RF_ParityLogData_t **);
RF_ParityLog_t *rf_AcquireParityLog(RF_ParityLogData_t *, int);
void rf_ReintLog(RF_Raid_t *, int, RF_ParityLog_t *);
void rf_FlushLog(RF_Raid_t *, RF_ParityLog_t *);
int  rf_DumpParityLogToDisk(int, RF_ParityLogData_t *);

RF_CommonLogData_t *
rf_AllocParityLogCommonData(RF_Raid_t *raidPtr)
{
	RF_CommonLogData_t *common = NULL;
	int rc;

	/*
	 * Return a struct for holding common parity log information from the
	 * free list (rf_parityLogDiskQueue.freeCommonList). If the free list
	 * is empty, call RF_Malloc to create a new structure. NON-BLOCKING
	 */

	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	if (raidPtr->parityLogDiskQueue.freeCommonList) {
		common = raidPtr->parityLogDiskQueue.freeCommonList;
		raidPtr->parityLogDiskQueue.freeCommonList =
		    raidPtr->parityLogDiskQueue.freeCommonList->next;
		RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	} else {
		RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
		RF_Malloc(common, sizeof(RF_CommonLogData_t),
		    (RF_CommonLogData_t *));
		rc = rf_mutex_init(&common->mutex);
		if (rc) {
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			    " rc=%d\n", __FILE__, __LINE__, rc);
			RF_Free(common, sizeof(RF_CommonLogData_t));
			common = NULL;
		}
	}
	common->next = NULL;
	return (common);
}

void
rf_FreeParityLogCommonData(RF_CommonLogData_t *common)
{
	RF_Raid_t *raidPtr;

	/*
	 * Insert a single struct for holding parity log information (data)
	 * into the free list (rf_parityLogDiskQueue.freeCommonList).
	 * NON-BLOCKING
	 */

	raidPtr = common->raidPtr;
	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	common->next = raidPtr->parityLogDiskQueue.freeCommonList;
	raidPtr->parityLogDiskQueue.freeCommonList = common;
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
}

RF_ParityLogData_t *
rf_AllocParityLogData(RF_Raid_t *raidPtr)
{
	RF_ParityLogData_t *data = NULL;

	/*
	 * Return a struct for holding parity log information from the free
	 * list (rf_parityLogDiskQueue.freeList). If the free list is empty,
	 * call RF_Malloc to create a new structure. NON-BLOCKING
	 */

	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	if (raidPtr->parityLogDiskQueue.freeDataList) {
		data = raidPtr->parityLogDiskQueue.freeDataList;
		raidPtr->parityLogDiskQueue.freeDataList =
		    raidPtr->parityLogDiskQueue.freeDataList->next;
		RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	} else {
		RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
		RF_Malloc(data, sizeof(RF_ParityLogData_t),
		    (RF_ParityLogData_t *));
	}
	data->next = NULL;
	data->prev = NULL;
	return (data);
}


void
rf_FreeParityLogData(RF_ParityLogData_t *data)
{
	RF_ParityLogData_t *nextItem;
	RF_Raid_t *raidPtr;

	/*
	 * Insert a linked list of structs for holding parity log information
	 * (data) into the free list (parityLogDiskQueue.freeList).
	 * NON-BLOCKING
	 */

	raidPtr = data->common->raidPtr;
	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	while (data) {
		nextItem = data->next;
		data->next = raidPtr->parityLogDiskQueue.freeDataList;
		raidPtr->parityLogDiskQueue.freeDataList = data;
		data = nextItem;
	}
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
}


void
rf_EnqueueParityLogData(RF_ParityLogData_t *data, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail)
{
	RF_Raid_t *raidPtr;

	/*
	 * Insert an in-core parity log (*data) into the head of a disk queue
	 * (*head, *tail). NON-BLOCKING
	 */

	raidPtr = data->common->raidPtr;
	if (rf_parityLogDebug)
		printf("[enqueueing parity log data, region %d,"
		    " raidAddress %d, numSector %d]\n", data->regionID,
		    (int) data->diskAddress.raidAddress,
		    (int) data->diskAddress.numSector);
	RF_ASSERT(data->prev == NULL);
	RF_ASSERT(data->next == NULL);
	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	if (*head) {
		/* Insert into head of queue. */
		RF_ASSERT((*head)->prev == NULL);
		RF_ASSERT((*tail)->next == NULL);
		data->next = *head;
		(*head)->prev = data;
		*head = data;
	} else {
		/* Insert into empty list. */
		RF_ASSERT(*head == NULL);
		RF_ASSERT(*tail == NULL);
		*head = data;
		*tail = data;
	}
	RF_ASSERT((*head)->prev == NULL);
	RF_ASSERT((*tail)->next == NULL);
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
}

RF_ParityLogData_t *
rf_DequeueParityLogData(RF_Raid_t *raidPtr, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail, int ignoreLocks)
{
	RF_ParityLogData_t *data;

	/*
	 * Remove and return an in-core parity log from the tail of a disk
	 * queue (*head, *tail). NON-BLOCKING
	 */

	/* Remove from tail, preserving FIFO order. */
	if (!ignoreLocks)
		RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	data = *tail;
	if (data) {
		if (*head == *tail) {
			/* Removing last item from queue. */
			*head = NULL;
			*tail = NULL;
		} else {
			*tail = (*tail)->prev;
			(*tail)->next = NULL;
			RF_ASSERT((*head)->prev == NULL);
			RF_ASSERT((*tail)->next == NULL);
		}
		data->next = NULL;
		data->prev = NULL;
		if (rf_parityLogDebug)
			printf("[dequeueing parity log data, region %d,"
			    " raidAddress %d, numSector %d]\n", data->regionID,
			    (int) data->diskAddress.raidAddress,
			    (int) data->diskAddress.numSector);
	}
	if (*head) {
		RF_ASSERT((*head)->prev == NULL);
		RF_ASSERT((*tail)->next == NULL);
	}
	if (!ignoreLocks)
		RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	return (data);
}


void
rf_RequeueParityLogData(RF_ParityLogData_t *data, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail)
{
	RF_Raid_t *raidPtr;

	/*
	 * Insert an in-core parity log (*data) into the tail of a disk queue
	 * (*head, *tail). NON-BLOCKING
	 */

	raidPtr = data->common->raidPtr;
	RF_ASSERT(data);
	if (rf_parityLogDebug)
		printf("[requeueing parity log data, region %d,"
		    " raidAddress %d, numSector %d]\n", data->regionID,
		    (int) data->diskAddress.raidAddress,
		    (int) data->diskAddress.numSector);
	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	if (*tail) {
		/* Append to tail of list. */
		data->prev = *tail;
		data->next = NULL;
		(*tail)->next = data;
		*tail = data;
	} else {
		/* Inserting into an empty list. */
		*head = data;
		*tail = data;
		(*head)->prev = NULL;
		(*tail)->next = NULL;
	}
	RF_ASSERT((*head)->prev == NULL);
	RF_ASSERT((*tail)->next == NULL);
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
}

RF_ParityLogData_t *
rf_CreateParityLogData(RF_ParityRecordType_t operation, RF_PhysDiskAddr_t *pda,
    caddr_t bufPtr, RF_Raid_t *raidPtr,
    int (*wakeFunc) (RF_DagNode_t * node, int status),
    void *wakeArg, RF_AccTraceEntry_t *tracerec, RF_Etimer_t startTime)
{
	RF_ParityLogData_t *data, *resultHead = NULL, *resultTail = NULL;
	RF_CommonLogData_t *common;
	RF_PhysDiskAddr_t *diskAddress;
	int boundary, offset = 0;

	/*
	 * Return an initialized struct of info to be logged. Build one item
	 * per physical disk address, one item per region.
	 *
	 * NON-BLOCKING
	 */

	diskAddress = pda;
	common = rf_AllocParityLogCommonData(raidPtr);
	RF_ASSERT(common);

	common->operation = operation;
	common->bufPtr = bufPtr;
	common->raidPtr = raidPtr;
	common->wakeFunc = wakeFunc;
	common->wakeArg = wakeArg;
	common->tracerec = tracerec;
	common->startTime = startTime;
	common->cnt = 0;

	if (rf_parityLogDebug)
		printf("[entering CreateParityLogData]\n");
	while (diskAddress) {
		common->cnt++;
		data = rf_AllocParityLogData(raidPtr);
		RF_ASSERT(data);
		data->common = common;
		data->next = NULL;
		data->prev = NULL;
		data->regionID = rf_MapRegionIDParityLogging(raidPtr,
		    diskAddress->startSector);
		if (data->regionID == rf_MapRegionIDParityLogging(raidPtr,
		    diskAddress->startSector + diskAddress->numSector - 1)) {
			/* Disk address does not cross a region boundary. */
			data->diskAddress = *diskAddress;
			data->bufOffset = offset;
			offset = offset + diskAddress->numSector;
			rf_EnqueueParityLogData(data, &resultHead, &resultTail);
			/* Adjust disk address. */
			diskAddress = diskAddress->next;
		} else {
			/* Disk address crosses a region boundary. */
			/* Find address where region is crossed. */
			boundary = 0;
			while (data->regionID ==
			    rf_MapRegionIDParityLogging(raidPtr,
			     diskAddress->startSector + boundary))
				boundary++;

			/* Enter data before the boundary. */
			data->diskAddress = *diskAddress;
			data->diskAddress.numSector = boundary;
			data->bufOffset = offset;
			offset += boundary;
			rf_EnqueueParityLogData(data, &resultHead, &resultTail);
			/* Adjust disk address. */
			diskAddress->startSector += boundary;
			diskAddress->numSector -= boundary;
		}
	}
	if (rf_parityLogDebug)
		printf("[leaving CreateParityLogData]\n");
	return (resultHead);
}


RF_ParityLogData_t *
rf_SearchAndDequeueParityLogData(RF_Raid_t *raidPtr, int regionID,
    RF_ParityLogData_t **head, RF_ParityLogData_t **tail, int ignoreLocks)
{
	RF_ParityLogData_t *w;

	/*
	 * Remove and return an in-core parity log from a specified region
	 * (regionID). If a matching log is not found, return NULL.
	 *
	 * NON-BLOCKING
	 */

	/*
	 * walk backward through a list, looking for an entry with a matching
	 * region ID.
	 */
	if (!ignoreLocks)
		RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	w = (*tail);
	while (w) {
		if (w->regionID == regionID) {
			/* Remove an element from the list. */
			if (w == *tail) {
				if (*head == *tail) {
					/* Removing only element in the list. */
					*head = NULL;
					*tail = NULL;
				} else {
					/* Removing last item in the list. */
					*tail = (*tail)->prev;
					(*tail)->next = NULL;
					RF_ASSERT((*head)->prev == NULL);
					RF_ASSERT((*tail)->next == NULL);
				}
			} else {
				if (w == *head) {
					/* Removing first item in the list. */
					*head = (*head)->next;
					(*head)->prev = NULL;
					RF_ASSERT((*head)->prev == NULL);
					RF_ASSERT((*tail)->next == NULL);
				} else {
					/*
					 * Removing an item from the middle of
					 * the list.
					 */
					w->prev->next = w->next;
					w->next->prev = w->prev;
					RF_ASSERT((*head)->prev == NULL);
					RF_ASSERT((*tail)->next == NULL);
				}
			}
			w->prev = NULL;
			w->next = NULL;
			if (rf_parityLogDebug)
				printf("[dequeueing parity log data,"
				    " region %d, raidAddress %d,"
				    " numSector %d]\n", w->regionID,
				    (int) w->diskAddress.raidAddress,
				    (int) w->diskAddress.numSector);
			return (w);
		} else
			w = w->prev;
	}
	if (!ignoreLocks)
		RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	return (NULL);
}

RF_ParityLogData_t *
rf_DequeueMatchingLogData(RF_Raid_t *raidPtr, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail)
{
	RF_ParityLogData_t *logDataList, *logData;
	int regionID;

	/*
	 * Remove and return an in-core parity log from the tail of a disk
	 * queue (*head, *tail). Then remove all matching (identical
	 * regionIDs) logData and return as a linked list.
	 *
	 * NON-BLOCKING
	 */

	logDataList = rf_DequeueParityLogData(raidPtr, head, tail, RF_TRUE);
	if (logDataList) {
		regionID = logDataList->regionID;
		logData = logDataList;
		logData->next = rf_SearchAndDequeueParityLogData(raidPtr,
		    regionID, head, tail, RF_TRUE);
		while (logData->next) {
			logData = logData->next;
			logData->next =
			    rf_SearchAndDequeueParityLogData(raidPtr, regionID,
			     head, tail, RF_TRUE);
		}
	}
	return (logDataList);
}


RF_ParityLog_t *
rf_AcquireParityLog(RF_ParityLogData_t *logData, int finish)
{
	RF_ParityLog_t *log = NULL;
	RF_Raid_t *raidPtr;

	/*
	 * Grab a log buffer from the pool and return it. If no buffers are
	 * available, return NULL. NON-BLOCKING
	 */
	raidPtr = logData->common->raidPtr;
	RF_LOCK_MUTEX(raidPtr->parityLogPool.mutex);
	if (raidPtr->parityLogPool.parityLogs) {
		log = raidPtr->parityLogPool.parityLogs;
		raidPtr->parityLogPool.parityLogs =
		    raidPtr->parityLogPool.parityLogs->next;
		log->regionID = logData->regionID;
		log->numRecords = 0;
		log->next = NULL;
		raidPtr->logsInUse++;
		RF_ASSERT(raidPtr->logsInUse >= 0 &&
		    raidPtr->logsInUse <= raidPtr->numParityLogs);
	} else {
		/*
		 * No logs available, so place ourselves on the queue of work
		 * waiting on log buffers this is done while
		 * parityLogPool.mutex is held, to ensure synchronization with
		 * ReleaseParityLogs.
		 */
		if (rf_parityLogDebug)
			printf("[blocked on log, region %d, finish %d]\n",
			    logData->regionID, finish);
		if (finish)
			rf_RequeueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.logBlockHead,
			    &raidPtr->parityLogDiskQueue.logBlockTail);
		else
			rf_EnqueueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.logBlockHead,
			    &raidPtr->parityLogDiskQueue.logBlockTail);
	}
	RF_UNLOCK_MUTEX(raidPtr->parityLogPool.mutex);
	return (log);
}

void
rf_ReleaseParityLogs(RF_Raid_t *raidPtr, RF_ParityLog_t *firstLog)
{
	RF_ParityLogData_t *logDataList;
	RF_ParityLog_t *log, *lastLog;
	int cnt;

	/*
	 * Insert a linked list of parity logs (firstLog) to the free list
	 * (parityLogPool.parityLogPool)
	 *
	 * NON-BLOCKING
	 */

	RF_ASSERT(firstLog);

	/*
	 * Before returning logs to global free list, service all requests
	 * which are blocked on logs. Holding mutexes for parityLogPool and
	 * parityLogDiskQueue forces synchronization with rf_AcquireParityLog().
	 */
	RF_LOCK_MUTEX(raidPtr->parityLogPool.mutex);
	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	logDataList = rf_DequeueMatchingLogData(raidPtr,
	    &raidPtr->parityLogDiskQueue.logBlockHead,
	    &raidPtr->parityLogDiskQueue.logBlockTail);
	log = firstLog;
	if (firstLog)
		firstLog = firstLog->next;
	log->numRecords = 0;
	log->next = NULL;
	while (logDataList && log) {
		RF_UNLOCK_MUTEX(raidPtr->parityLogPool.mutex);
		RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
		rf_ParityLogAppend(logDataList, RF_TRUE, &log, RF_FALSE);
		if (rf_parityLogDebug)
			printf("[finishing up buf-blocked log data,"
			    " region %d]\n", logDataList->regionID);
		if (log == NULL) {
			log = firstLog;
			if (firstLog) {
				firstLog = firstLog->next;
				log->numRecords = 0;
				log->next = NULL;
			}
		}
		RF_LOCK_MUTEX(raidPtr->parityLogPool.mutex);
		RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
		if (log)
			logDataList = rf_DequeueMatchingLogData(raidPtr,
			    &raidPtr->parityLogDiskQueue.logBlockHead,
			    &raidPtr->parityLogDiskQueue.logBlockTail);
	}
	/* Return remaining logs to pool. */
	if (log) {
		log->next = firstLog;
		firstLog = log;
	}
	if (firstLog) {
		lastLog = firstLog;
		raidPtr->logsInUse--;
		RF_ASSERT(raidPtr->logsInUse >= 0 &&
		    raidPtr->logsInUse <= raidPtr->numParityLogs);
		while (lastLog->next) {
			lastLog = lastLog->next;
			raidPtr->logsInUse--;
			RF_ASSERT(raidPtr->logsInUse >= 0 &&
			    raidPtr->logsInUse <= raidPtr->numParityLogs);
		}
		lastLog->next = raidPtr->parityLogPool.parityLogs;
		raidPtr->parityLogPool.parityLogs = firstLog;
		cnt = 0;
		log = raidPtr->parityLogPool.parityLogs;
		while (log) {
			cnt++;
			log = log->next;
		}
		RF_ASSERT(cnt + raidPtr->logsInUse == raidPtr->numParityLogs);
	}
	RF_UNLOCK_MUTEX(raidPtr->parityLogPool.mutex);
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
}

void
rf_ReintLog(RF_Raid_t *raidPtr, int regionID, RF_ParityLog_t *log)
{
	RF_ASSERT(log);

	/*
	 * Insert an in-core parity log (log) into the disk queue of
	 * reintegration work. Set the flag (reintInProgress) for the
	 * specified region (regionID) to indicate that reintegration is in
	 * progress for this region. NON-BLOCKING
	 */

	RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
	/* Cleared when reint complete. */
	raidPtr->regionInfo[regionID].reintInProgress = RF_TRUE;

	if (rf_parityLogDebug)
		printf("[requesting reintegration of region %d]\n",
		    log->regionID);
	/* Move record to reintegration queue. */
	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	log->next = raidPtr->parityLogDiskQueue.reintQueue;
	raidPtr->parityLogDiskQueue.reintQueue = log;
	RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	RF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);
}

void
rf_FlushLog(RF_Raid_t *raidPtr, RF_ParityLog_t *log)
{
	/*
	 * Insert a core log (log) into a list of logs
	 * (parityLogDiskQueue.flushQueue) waiting to be written to disk.
	 * NON-BLOCKING
	 */

	RF_ASSERT(log);
	RF_ASSERT(log->numRecords == raidPtr->numSectorsPerLog);
	RF_ASSERT(log->next == NULL);
	/* Move log to flush queue. */
	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	log->next = raidPtr->parityLogDiskQueue.flushQueue;
	raidPtr->parityLogDiskQueue.flushQueue = log;
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	RF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);
}

int
rf_DumpParityLogToDisk(int finish, RF_ParityLogData_t *logData)
{
	int i, diskCount, regionID = logData->regionID;
	RF_ParityLog_t *log;
	RF_Raid_t *raidPtr;

	raidPtr = logData->common->raidPtr;

	/*
	 * Move a core log to disk. If the log disk is full, initiate
	 * reintegration.
	 *
	 * Return (0) if we can enqueue the dump immediately, otherwise return
	 * (1) to indicate we are blocked on reintegration and control of the
	 * thread should be relinquished.
	 *
	 * Caller must hold regionInfo[regionID].mutex.
	 *
	 * NON-BLOCKING
	 */

	if (rf_parityLogDebug)
		printf("[dumping parity log to disk, region %d]\n", regionID);
	log = raidPtr->regionInfo[regionID].coreLog;
	RF_ASSERT(log->numRecords == raidPtr->numSectorsPerLog);
	RF_ASSERT(log->next == NULL);

	/* If reintegration is in progress, must queue work. */
	RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
	if (raidPtr->regionInfo[regionID].reintInProgress) {
		/*
		 * Can not proceed since this region is currently being
		 * reintegrated. We can not block, so queue remaining work and
		 * return.
		 */
		if (rf_parityLogDebug)
			printf("[region %d waiting on reintegration]\n",
			    regionID);
		/*
		 * XXX Not sure about the use of finish - shouldn't this
		 * always be "Enqueue" ?
		 */
		if (finish)
			rf_RequeueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.reintBlockHead,
			    &raidPtr->parityLogDiskQueue.reintBlockTail);
		else
			rf_EnqueueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.reintBlockHead,
			    &raidPtr->parityLogDiskQueue.reintBlockTail);
		RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
		return (1);	/* Relenquish control of this thread. */
	}
	RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
	raidPtr->regionInfo[regionID].coreLog = NULL;
	if ((raidPtr->regionInfo[regionID].diskCount) <
	    raidPtr->regionInfo[regionID].capacity)
		/*
		 * IMPORTANT !!!  This loop bound assumes region disk holds an
		 * integral number of core logs.
		 */
	{
		/* Update disk map for this region. */
		diskCount = raidPtr->regionInfo[regionID].diskCount;
		for (i = 0; i < raidPtr->numSectorsPerLog; i++) {
			raidPtr->regionInfo[regionID].diskMap[i + diskCount]
			    .operation = log->records[i].operation;
			raidPtr->regionInfo[regionID].diskMap[i + diskCount]
			    .parityAddr = log->records[i].parityAddr;
		}
		log->diskOffset = diskCount;
		raidPtr->regionInfo[regionID].diskCount +=
		    raidPtr->numSectorsPerLog;
		rf_FlushLog(raidPtr, log);
	} else {
		/*
		 * No room for log on disk, send it to disk manager and
		 * request reintegration.
		 */
		RF_ASSERT(raidPtr->regionInfo[regionID].diskCount ==
		    raidPtr->regionInfo[regionID].capacity);
		rf_ReintLog(raidPtr, regionID, log);
	}
	if (rf_parityLogDebug)
		printf("[finished dumping parity log to disk, region %d]\n",
		    regionID);
	return (0);
}

int
rf_ParityLogAppend(RF_ParityLogData_t *logData, int finish,
    RF_ParityLog_t **incomingLog, int clearReintFlag)
{
	int regionID, logItem, itemDone;
	RF_ParityLogData_t *item;
	int punt, done = RF_FALSE;
	RF_ParityLog_t *log;
	RF_Raid_t *raidPtr;
	RF_Etimer_t timer;
	int (*wakeFunc) (RF_DagNode_t * node, int status);
	void *wakeArg;

	/*
	 * Add parity to the appropriate log, one sector at a time. This
	 * routine is called is called by dag functions ParityLogUpdateFunc
	 * and ParityLogOverwriteFunc and therefore MUST BE NONBLOCKING.
	 *
	 * Parity to be logged is contained in a linked-list (logData). When
	 * this routine returns, every sector in the list will be in one of
	 * three places: 1) entered into the parity log 2) queued, waiting on
	 * reintegration 3) queued, waiting on a core log.
	 *
	 * Blocked work is passed to the ParityLoggingDiskManager for
	 * completion. Later, as conditions which required the block are
	 * removed, the work reenters this routine with the "finish" parameter
	 * set to "RF_TRUE."
	 *
	 * NON-BLOCKING
	 */

	raidPtr = logData->common->raidPtr;
	/* Lock the region for the first item in logData. */
	RF_ASSERT(logData != NULL);
	regionID = logData->regionID;
	RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	RF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);

	if (clearReintFlag) {
		/*
		 * Enable flushing for this region. Holding both locks
		 * provides a synchronization barrier with
		 * rf_DumpParityLogToDisk.
		 */
		RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
		RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
		RF_ASSERT(raidPtr->regionInfo[regionID].reintInProgress ==
		    RF_TRUE);
		raidPtr->regionInfo[regionID].diskCount = 0;
		raidPtr->regionInfo[regionID].reintInProgress = RF_FALSE;
		/* Flushing is now enabled. */
		RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
		RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	}
	/* Process each item in logData. */
	while (logData) {
		/* Remove an item from logData. */
		item = logData;
		logData = logData->next;
		item->next = NULL;
		item->prev = NULL;

		if (rf_parityLogDebug)
			printf("[appending parity log data, region %d,"
			    " raidAddress %d, numSector %d]\n", item->regionID,
			    (int) item->diskAddress.raidAddress,
			    (int) item->diskAddress.numSector);

		/* See if we moved to a new region. */
		if (regionID != item->regionID) {
			RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
			regionID = item->regionID;
			RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
			RF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);
		}
		punt = RF_FALSE;/*
				 * Set to RF_TRUE if work is blocked. This
				 * can happen in one of two ways: 1) no core
				 * log (rf_AcquireParityLog) 2) waiting on
				 * reintegration (rf_DumpParityLogToDisk).
				 * If punt is RF_TRUE, the dataItem was queued,
				 * so skip to next item.
				 */

		/*
		 * Process item, one sector at a time, until all sectors
		 * processed or we punt.
		 */
		if (item->diskAddress.numSector > 0)
			done = RF_FALSE;
		else
			RF_ASSERT(0);
		while (!punt && !done) {
			/* Verify that a core log exists for this region. */
			if (!raidPtr->regionInfo[regionID].coreLog) {
				/*
				 * Attempt to acquire a parity log. If
				 * acquisition fails, queue remaining work in
				 * data item and move to nextItem.
				 */
				if (incomingLog) {
					if (*incomingLog) {
						RF_ASSERT((*incomingLog)->next
						    == NULL);
						raidPtr->regionInfo[regionID]
						    .coreLog = *incomingLog;
						raidPtr->regionInfo[regionID]
						    .coreLog->regionID =
						     regionID;
						*incomingLog = NULL;
					} else
						raidPtr->regionInfo[regionID]
						    .coreLog =
						     rf_AcquireParityLog(item,
						      finish);
				} else
					raidPtr->regionInfo[regionID].coreLog =
					    rf_AcquireParityLog(item, finish);
				/*
				 * Note: rf_AcquireParityLog either returns
				 * a log or enqueues currentItem.
				 */
			}
			if (!raidPtr->regionInfo[regionID].coreLog)
				punt = RF_TRUE;	/* Failed to find a core log. */
			else {
				RF_ASSERT(raidPtr->regionInfo[regionID].coreLog
				    ->next == NULL);
				/*
				 * Verify that the log has room for new
				 * entries.
				 */
				/*
				 * If log is full, dump it to disk and grab a
				 * new log.
				 */
				if (raidPtr->regionInfo[regionID].coreLog
				    ->numRecords == raidPtr->numSectorsPerLog)
				{
					/* Log is full, dump it to disk. */
					if (rf_DumpParityLogToDisk(finish,
					    item))
						/*
						 * Dump unsuccessful, blocked
						 * on reintegration.
						 */
						punt = RF_TRUE;
					else {
						/* Dump was successful. */
					  if (incomingLog) {
							if (*incomingLog) {
								RF_ASSERT(
							(*incomingLog)->next ==
								    NULL);
								raidPtr->
						regionInfo[regionID].coreLog =
								   *incomingLog;
								raidPtr->
						regionInfo[regionID].coreLog->
							    regionID = regionID;
								*incomingLog =
								    NULL;
							} else
								raidPtr->
						regionInfo[regionID].coreLog =
						 rf_AcquireParityLog(item,
						     finish);
						} else
							raidPtr->regionInfo
							    [regionID].coreLog =
						 rf_AcquireParityLog(item,
						     finish);
						/*
						 * If a core log is not
						 * available, must queue work
						 * and return.
						 */
						if (!raidPtr->regionInfo
						    [regionID].coreLog)
							/*
							 * Blocked on log
							 * availability.
							 */
							punt = RF_TRUE;
					}
				}
			}
			/*
			 * If we didn't punt on this item, attempt to add a
			 * sector to the core log.
			 */
			if (!punt) {
				RF_ASSERT(raidPtr->regionInfo[regionID].coreLog
				    ->next == NULL);
				/*
				 * At this point, we have a core log with
				 * enough room for a sector.
				 */
				/* Copy a sector into the log. */
				log = raidPtr->regionInfo[regionID].coreLog;
				RF_ASSERT(log->numRecords <
				    raidPtr->numSectorsPerLog);
				logItem = log->numRecords++;
				log->records[logItem].parityAddr =
				    item->diskAddress;
				RF_ASSERT(log->records[logItem].parityAddr
				    .startSector >=
				    raidPtr->regionInfo[regionID]
				    .parityStartAddr);
				RF_ASSERT(log->records[logItem].parityAddr
				    .startSector <
				    raidPtr->regionInfo[regionID]
				    .parityStartAddr +
				    raidPtr->regionInfo[regionID]
				    .numSectorsParity);
				log->records[logItem].parityAddr.numSector = 1;
				log->records[logItem].operation =
				    item->common->operation;
				bcopy((item->common->bufPtr +
				    (item->bufOffset++ * (1 <<
				    item->common->raidPtr->logBytesPerSector))),
				    log->bufPtr + (logItem * (1 <<
				    item->common->raidPtr->logBytesPerSector)),
				    (1 << item->common->raidPtr
				     ->logBytesPerSector));
				item->diskAddress.numSector--;
				item->diskAddress.startSector++;
				if (item->diskAddress.numSector == 0)
					done = RF_TRUE;
			}
		}

		if (!punt) {
			/*
			 * Processed this item completely, decrement count of
			 * items to be processed.
			 */
			RF_ASSERT(item->diskAddress.numSector == 0);
			RF_LOCK_MUTEX(item->common->mutex);
			item->common->cnt--;
			if (item->common->cnt == 0)
				itemDone = RF_TRUE;
			else
				itemDone = RF_FALSE;
			RF_UNLOCK_MUTEX(item->common->mutex);
			if (itemDone) {
				/*
				 * Finished processing all log data for this
				 * IO Return structs to free list and invoke
				 * wakeup function.
				 */
				/* Grab initial value of timer. */
				timer = item->common->startTime;
				RF_ETIMER_STOP(timer);
				RF_ETIMER_EVAL(timer);
				item->common->tracerec->plog_us +=
				    RF_ETIMER_VAL_US(timer);
				if (rf_parityLogDebug)
					printf("[waking process for region"
					    " %d]\n", item->regionID);
				wakeFunc = item->common->wakeFunc;
				wakeArg = item->common->wakeArg;
				rf_FreeParityLogCommonData(item->common);
				rf_FreeParityLogData(item);
				(wakeFunc) (wakeArg, 0);
			} else
				rf_FreeParityLogData(item);
		}
	}
	RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	if (rf_parityLogDebug)
		printf("[exiting ParityLogAppend]\n");
	return (0);
}


void
rf_EnableParityLogging(RF_Raid_t *raidPtr)
{
	int regionID;

	for (regionID = 0; regionID < rf_numParityRegions; regionID++) {
		RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
		raidPtr->regionInfo[regionID].loggingEnabled = RF_TRUE;
		RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	}
	if (rf_parityLogDebug)
		printf("[parity logging enabled]\n");
}
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.5
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_paritylog.c,v 1.4 2000/01/11 18:02:22 peter Exp $	*/
@


1.4
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_paritylog.c,v 1.3 2000/01/07 14:50:22 peter Exp $	*/
d3 1
d31 2
a32 2
/* Code for manipulating in-core parity logs
 *
d37 1
a37 1
#if RF_INCLUDE_PARITYLOGGING > 0
d40 1
a40 1
 * Append-only log for recording parity "update" and "overwrite" records
d59 19
a77 2
static RF_CommonLogData_t *
AllocParityLogCommonData(RF_Raid_t * raidPtr)
d80 1
a80 1
	int     rc;
d82 5
a86 3
	/* Return a struct for holding common parity log information from the
	 * free list (rf_parityLogDiskQueue.freeCommonList).  If the free list
	 * is empty, call RF_Malloc to create a new structure. NON-BLOCKING */
d91 2
a92 1
		raidPtr->parityLogDiskQueue.freeCommonList = raidPtr->parityLogDiskQueue.freeCommonList->next;
d96 2
a97 1
		RF_Malloc(common, sizeof(RF_CommonLogData_t), (RF_CommonLogData_t *));
d100 2
a101 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
			    __LINE__, rc);
d110 2
a111 2
static void 
FreeParityLogCommonData(RF_CommonLogData_t * common)
d115 2
a116 1
	/* Insert a single struct for holding parity log information (data)
d118 2
a119 1
	 * NON-BLOCKING */
d128 2
a129 2
static RF_ParityLogData_t *
AllocParityLogData(RF_Raid_t * raidPtr)
d133 5
a137 3
	/* Return a struct for holding parity log information from the free
	 * list (rf_parityLogDiskQueue.freeList).  If the free list is empty,
	 * call RF_Malloc to create a new structure. NON-BLOCKING */
d142 2
a143 1
		raidPtr->parityLogDiskQueue.freeDataList = raidPtr->parityLogDiskQueue.freeDataList->next;
d147 2
a148 1
		RF_Malloc(data, sizeof(RF_ParityLogData_t), (RF_ParityLogData_t *));
d156 2
a157 2
static void 
FreeParityLogData(RF_ParityLogData_t * data)
d162 2
a163 1
	/* Insert a linked list of structs for holding parity log information
d165 2
a166 1
	 * NON-BLOCKING */
d180 3
a182 5
static void 
EnqueueParityLogData(
    RF_ParityLogData_t * data,
    RF_ParityLogData_t ** head,
    RF_ParityLogData_t ** tail)
d186 4
a189 2
	/* Insert an in-core parity log (*data) into the head of a disk queue
	 * (*head, *tail). NON-BLOCKING */
d193 4
a196 1
		printf("[enqueueing parity log data, region %d, raidAddress %d, numSector %d]\n", data->regionID, (int) data->diskAddress.raidAddress, (int) data->diskAddress.numSector);
d201 1
a201 1
		/* insert into head of queue */
d208 1
a208 1
		/* insert into empty list */
d219 3
a221 6
static RF_ParityLogData_t *
DequeueParityLogData(
    RF_Raid_t * raidPtr,
    RF_ParityLogData_t ** head,
    RF_ParityLogData_t ** tail,
    int ignoreLocks)
d225 4
a228 2
	/* Remove and return an in-core parity log from the tail of a disk
	 * queue (*head, *tail). NON-BLOCKING */
d230 1
a230 1
	/* remove from tail, preserving FIFO order */
d236 1
a236 1
			/* removing last item from queue */
d248 4
a251 1
			printf("[dequeueing parity log data, region %d, raidAddress %d, numSector %d]\n", data->regionID, (int) data->diskAddress.raidAddress, (int) data->diskAddress.numSector);
d263 3
a265 5
static void 
RequeueParityLogData(
    RF_ParityLogData_t * data,
    RF_ParityLogData_t ** head,
    RF_ParityLogData_t ** tail)
d269 4
a272 2
	/* Insert an in-core parity log (*data) into the tail of a disk queue
	 * (*head, *tail). NON-BLOCKING */
d277 4
a280 1
		printf("[requeueing parity log data, region %d, raidAddress %d, numSector %d]\n", data->regionID, (int) data->diskAddress.raidAddress, (int) data->diskAddress.numSector);
d283 1
a283 1
		/* append to tail of list */
d289 1
a289 1
		/* inserting into an empty list */
d301 2
a302 5
rf_CreateParityLogData(
    RF_ParityRecordType_t operation,
    RF_PhysDiskAddr_t * pda,
    caddr_t bufPtr,
    RF_Raid_t * raidPtr,
d304 1
a304 3
    void *wakeArg,
    RF_AccTraceEntry_t * tracerec,
    RF_Etimer_t startTime)
d309 1
a309 1
	int     boundary, offset = 0;
d311 2
a312 1
	/* Return an initialized struct of info to be logged. Build one item
d314 3
a316 2
	 * 
	 * NON-BLOCKING */
d319 1
a319 1
	common = AllocParityLogCommonData(raidPtr);
d335 1
a335 1
		data = AllocParityLogData(raidPtr);
d340 5
a344 3
		data->regionID = rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector);
		if (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + diskAddress->numSector - 1)) {
			/* disk address does not cross a region boundary */
d348 2
a349 2
			EnqueueParityLogData(data, &resultHead, &resultTail);
			/* adjust disk address */
d352 2
a353 2
			/* disk address crosses a region boundary */
			/* find address where region is crossed */
d355 3
a357 1
			while (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + boundary))
d360 1
a360 1
			/* enter data before the boundary */
d365 2
a366 2
			EnqueueParityLogData(data, &resultHead, &resultTail);
			/* adjust disk address */
d378 2
a379 6
rf_SearchAndDequeueParityLogData(
    RF_Raid_t * raidPtr,
    int regionID,
    RF_ParityLogData_t ** head,
    RF_ParityLogData_t ** tail,
    int ignoreLocks)
d383 2
a384 1
	/* Remove and return an in-core parity log from a specified region
d386 8
a393 5
	 * 
	 * NON-BLOCKING. */

	/* walk backward through a list, looking for an entry with a matching
	 * region ID */
d399 1
a399 1
			/* remove an element from the list */
d402 1
a402 1
					/* removing only element in the list */
d406 1
a406 1
					/* removing last item in the list */
d414 1
a414 1
					/* removing first item in the list */
d420 4
a423 2
					/* removing an item from the middle of
					 * the list */
d433 5
a437 1
				printf("[dequeueing parity log data, region %d, raidAddress %d, numSector %d]\n", w->regionID, (int) w->diskAddress.raidAddress, (int) w->diskAddress.numSector);
d447 3
a449 5
static RF_ParityLogData_t *
DequeueMatchingLogData(
    RF_Raid_t * raidPtr,
    RF_ParityLogData_t ** head,
    RF_ParityLogData_t ** tail)
d452 1
a452 1
	int     regionID;
d454 3
a456 2
	/* Remove and return an in-core parity log from the tail of a disk
	 * queue (*head, *tail).  Then remove all matching (identical
d458 3
a460 2
	 * 
	 * NON-BLOCKING */
d462 1
a462 1
	logDataList = DequeueParityLogData(raidPtr, head, tail, RF_TRUE);
d466 2
a467 1
		logData->next = rf_SearchAndDequeueParityLogData(raidPtr, regionID, head, tail, RF_TRUE);
d470 3
a472 1
			logData->next = rf_SearchAndDequeueParityLogData(raidPtr, regionID, head, tail, RF_TRUE);
d479 2
a480 4
static RF_ParityLog_t *
AcquireParityLog(
    RF_ParityLogData_t * logData,
    int finish)
d485 4
a488 2
	/* Grab a log buffer from the pool and return it. If no buffers are
	 * available, return NULL. NON-BLOCKING */
d493 2
a494 1
		raidPtr->parityLogPool.parityLogs = raidPtr->parityLogPool.parityLogs->next;
d499 2
a500 1
		RF_ASSERT(raidPtr->logsInUse >= 0 && raidPtr->logsInUse <= raidPtr->numParityLogs);
d502 2
a503 1
		/* no logs available, so place ourselves on the queue of work
d506 2
a507 1
		 * ReleaseParityLogs. */
d509 2
a510 1
			printf("[blocked on log, region %d, finish %d]\n", logData->regionID, finish);
d512 3
a514 1
			RequeueParityLogData(logData, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);
d516 3
a518 1
			EnqueueParityLogData(logData, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);
d524 2
a525 4
void 
rf_ReleaseParityLogs(
    RF_Raid_t * raidPtr,
    RF_ParityLog_t * firstLog)
d529 1
a529 1
	int     cnt;
d531 2
a532 1
	/* Insert a linked list of parity logs (firstLog) to the free list
d534 3
a536 2
	 * 
	 * NON-BLOCKING. */
d540 5
a544 3
	/* Before returning logs to global free list, service all requests
	 * which are blocked on logs.  Holding mutexes for parityLogPool and
	 * parityLogDiskQueue forces synchronization with AcquireParityLog(). */
d547 3
a549 1
	logDataList = DequeueMatchingLogData(raidPtr, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);
d560 2
a561 1
			printf("[finishing up buf-blocked log data, region %d]\n", logDataList->regionID);
d573 3
a575 1
			logDataList = DequeueMatchingLogData(raidPtr, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);
d577 1
a577 1
	/* return remaining logs to pool */
d585 2
a586 1
		RF_ASSERT(raidPtr->logsInUse >= 0 && raidPtr->logsInUse <= raidPtr->numParityLogs);
d590 2
a591 1
			RF_ASSERT(raidPtr->logsInUse >= 0 && raidPtr->logsInUse <= raidPtr->numParityLogs);
d607 2
a608 5
static void 
ReintLog(
    RF_Raid_t * raidPtr,
    int regionID,
    RF_ParityLog_t * log)
d612 3
a614 2
	/* Insert an in-core parity log (log) into the disk queue of
	 * reintegration work.  Set the flag (reintInProgress) for the
d616 2
a617 1
	 * progress for this region. NON-BLOCKING */
d620 2
a621 2
	raidPtr->regionInfo[regionID].reintInProgress = RF_TRUE;	/* cleared when reint
									 * complete */
d624 3
a626 2
		printf("[requesting reintegration of region %d]\n", log->regionID);
	/* move record to reintegration queue */
d635 2
a636 4
static void 
FlushLog(
    RF_Raid_t * raidPtr,
    RF_ParityLog_t * log)
d638 2
a639 1
	/* insert a core log (log) into a list of logs
d641 2
a642 1
	 * NON-BLOCKING */
d647 1
a647 1
	/* move log to flush queue */
d655 2
a656 4
static int 
DumpParityLogToDisk(
    int finish,
    RF_ParityLogData_t * logData)
d658 1
a658 1
	int     i, diskCount, regionID = logData->regionID;
d664 2
a665 1
	/* Move a core log to disk.  If the log disk is full, initiate
d667 1
a667 1
	 * 
d671 5
a675 4
	 * 
	 * Caller must hold regionInfo[regionID].mutex
	 * 
	 * NON-BLOCKING */
d683 1
a683 1
	/* if reintegration is in progress, must queue work */
d686 2
a687 1
		/* Can not proceed since this region is currently being
d689 2
a690 1
		 * return */
d692 6
a697 3
			printf("[region %d waiting on reintegration]\n", regionID);
		/* XXX not sure about the use of finish - shouldn't this
		 * always be "Enqueue"? */
d699 3
a701 1
			RequeueParityLogData(logData, &raidPtr->parityLogDiskQueue.reintBlockHead, &raidPtr->parityLogDiskQueue.reintBlockTail);
d703 3
a705 1
			EnqueueParityLogData(logData, &raidPtr->parityLogDiskQueue.reintBlockHead, &raidPtr->parityLogDiskQueue.reintBlockTail);
d707 1
a707 1
		return (1);	/* relenquish control of this thread */
d711 6
a716 3
	if ((raidPtr->regionInfo[regionID].diskCount) < raidPtr->regionInfo[regionID].capacity)
		/* IMPORTANT!! this loop bound assumes region disk holds an
		 * integral number of core logs */
d718 1
a718 1
		/* update disk map for this region */
d721 4
a724 2
			raidPtr->regionInfo[regionID].diskMap[i + diskCount].operation = log->records[i].operation;
			raidPtr->regionInfo[regionID].diskMap[i + diskCount].parityAddr = log->records[i].parityAddr;
d727 3
a729 2
		raidPtr->regionInfo[regionID].diskCount += raidPtr->numSectorsPerLog;
		FlushLog(raidPtr, log);
d731 7
a737 4
		/* no room for log on disk, send it to disk manager and
		 * request reintegration */
		RF_ASSERT(raidPtr->regionInfo[regionID].diskCount == raidPtr->regionInfo[regionID].capacity);
		ReintLog(raidPtr, regionID, log);
d740 2
a741 1
		printf("[finished dumping parity log to disk, region %d]\n", regionID);
d745 3
a747 6
int 
rf_ParityLogAppend(
    RF_ParityLogData_t * logData,
    int finish,
    RF_ParityLog_t ** incomingLog,
    int clearReintFlag)
d749 1
a749 1
	int     regionID, logItem, itemDone;
d751 1
a751 1
	int     punt, done = RF_FALSE;
d755 2
a756 2
	int     (*wakeFunc) (RF_DagNode_t * node, int status);
	void   *wakeArg;
d758 2
a759 1
	/* Add parity to the appropriate log, one sector at a time. This
d762 2
a763 2
	 * 
	 * Parity to be logged is contained in a linked-list (logData).  When
d766 9
a774 7
	 * reintegration 3) queued, waiting on a core log
	 * 
	 * Blocked work is passed to the ParityLoggingDiskManager for completion.
	 * Later, as conditions which required the block are removed, the work
	 * reenters this routine with the "finish" parameter set to "RF_TRUE."
	 * 
	 * NON-BLOCKING */
d777 1
a777 1
	/* lock the region for the first item in logData */
d784 5
a788 2
		/* Enable flushing for this region.  Holding both locks
		 * provides a synchronization barrier with DumpParityLogToDisk */
d791 2
a792 1
		RF_ASSERT(raidPtr->regionInfo[regionID].reintInProgress == RF_TRUE);
d795 2
a796 2
		RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);	/* flushing is now
										 * enabled */
d799 1
a799 1
	/* process each item in logData */
d801 1
a801 1
		/* remove an item from logData */
d808 4
a811 1
			printf("[appending parity log data, region %d, raidAddress %d, numSector %d]\n", item->regionID, (int) item->diskAddress.raidAddress, (int) item->diskAddress.numSector);
d813 1
a813 1
		/* see if we moved to a new region */
d820 2
a821 1
		punt = RF_FALSE;/* Set to RF_TRUE if work is blocked.  This
d823 10
a832 7
				 * log (AcquireParityLog) 2) waiting on
				 * reintegration (DumpParityLogToDisk) If punt
				 * is RF_TRUE, the dataItem was queued, so
				 * skip to next item. */

		/* process item, one sector at a time, until all sectors
		 * processed or we punt */
d838 1
a838 1
			/* verify that a core log exists for this region */
d840 2
a841 1
				/* Attempt to acquire a parity log. If
d843 2
a844 1
				 * data item and move to nextItem. */
d847 7
a853 3
						RF_ASSERT((*incomingLog)->next == NULL);
						raidPtr->regionInfo[regionID].coreLog = *incomingLog;
						raidPtr->regionInfo[regionID].coreLog->regionID = regionID;
d856 4
a859 1
						raidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);
d861 6
a866 3
					raidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);
				/* Note: AcquireParityLog either returns a log
				 * or enqueues currentItem */
d869 1
a869 1
				punt = RF_TRUE;	/* failed to find a core log */
d871 21
a891 11
				RF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);
				/* verify that the log has room for new
				 * entries */
				/* if log is full, dump it to disk and grab a
				 * new log */
				if (raidPtr->regionInfo[regionID].coreLog->numRecords == raidPtr->numSectorsPerLog) {
					/* log is full, dump it to disk */
					if (DumpParityLogToDisk(finish, item))
						punt = RF_TRUE;	/* dump unsuccessful,
								 * blocked on
								 * reintegration */
d893 1
a893 1
						/* dump was successful */
d896 11
a906 4
								RF_ASSERT((*incomingLog)->next == NULL);
								raidPtr->regionInfo[regionID].coreLog = *incomingLog;
								raidPtr->regionInfo[regionID].coreLog->regionID = regionID;
								*incomingLog = NULL;
d908 4
a911 1
								raidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);
d913 6
a918 2
							raidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);
						/* if a core log is not
d920 9
a928 4
						 * and return */
						if (!raidPtr->regionInfo[regionID].coreLog)
							punt = RF_TRUE;	/* blocked on log
									 * availability */
d932 4
a935 2
			/* if we didn't punt on this item, attempt to add a
			 * sector to the core log */
d937 7
a943 4
				RF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);
				/* at this point, we have a core log with
				 * enough room for a sector */
				/* copy a sector into the log */
d945 2
a946 1
				RF_ASSERT(log->numRecords < raidPtr->numSectorsPerLog);
d948 12
a959 3
				log->records[logItem].parityAddr = item->diskAddress;
				RF_ASSERT(log->records[logItem].parityAddr.startSector >= raidPtr->regionInfo[regionID].parityStartAddr);
				RF_ASSERT(log->records[logItem].parityAddr.startSector < raidPtr->regionInfo[regionID].parityStartAddr + raidPtr->regionInfo[regionID].numSectorsParity);
d961 9
a969 2
				log->records[logItem].operation = item->common->operation;
				bcopy((item->common->bufPtr + (item->bufOffset++ * (1 << item->common->raidPtr->logBytesPerSector))), log->bufPtr + (logItem * (1 << item->common->raidPtr->logBytesPerSector)), (1 << item->common->raidPtr->logBytesPerSector));
d978 4
a981 2
			/* Processed this item completely, decrement count of
			 * items to be processed. */
d991 2
a992 1
				/* Finished processing all log data for this
d994 4
a997 3
				 * wakeup function. */
				timer = item->common->startTime;	/* grab initial value of
									 * timer */
d1000 2
a1001 1
				item->common->tracerec->plog_us += RF_ETIMER_VAL_US(timer);
d1003 2
a1004 1
					printf("[waking process for region %d]\n", item->regionID);
d1007 2
a1008 2
				FreeParityLogCommonData(item->common);
				FreeParityLogData(item);
d1011 1
a1011 1
				FreeParityLogData(item);
d1021 2
a1022 2
void 
rf_EnableParityLogging(RF_Raid_t * raidPtr)
d1024 1
a1024 1
	int     regionID;
d1034 1
a1034 1
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.4.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 2
a31 2
/*
 * Code for manipulating in-core parity logs.
d36 1
a36 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d39 1
a39 1
 * Append-only log for recording parity "update" and "overwrite" records.
d58 2
a59 19
RF_CommonLogData_t *rf_AllocParityLogCommonData(RF_Raid_t *);
void rf_FreeParityLogCommonData(RF_CommonLogData_t *);
RF_ParityLogData_t *rf_AllocParityLogData(RF_Raid_t *);
void rf_FreeParityLogData(RF_ParityLogData_t *);
void rf_EnqueueParityLogData(RF_ParityLogData_t *, RF_ParityLogData_t **,
	RF_ParityLogData_t **);
RF_ParityLogData_t *rf_DequeueParityLogData(RF_Raid_t *, RF_ParityLogData_t **,
	RF_ParityLogData_t **, int);
void rf_RequeueParityLogData(RF_ParityLogData_t *, RF_ParityLogData_t **,
	RF_ParityLogData_t **);
RF_ParityLogData_t *rf_DequeueMatchingLogData(RF_Raid_t *,
	RF_ParityLogData_t **, RF_ParityLogData_t **);
RF_ParityLog_t *rf_AcquireParityLog(RF_ParityLogData_t *, int);
void rf_ReintLog(RF_Raid_t *, int, RF_ParityLog_t *);
void rf_FlushLog(RF_Raid_t *, RF_ParityLog_t *);
int  rf_DumpParityLogToDisk(int, RF_ParityLogData_t *);

RF_CommonLogData_t *
rf_AllocParityLogCommonData(RF_Raid_t *raidPtr)
d62 1
a62 1
	int rc;
d64 3
a66 5
	/*
	 * Return a struct for holding common parity log information from the
	 * free list (rf_parityLogDiskQueue.freeCommonList). If the free list
	 * is empty, call RF_Malloc to create a new structure. NON-BLOCKING
	 */
d71 1
a71 2
		raidPtr->parityLogDiskQueue.freeCommonList =
		    raidPtr->parityLogDiskQueue.freeCommonList->next;
d75 1
a75 2
		RF_Malloc(common, sizeof(RF_CommonLogData_t),
		    (RF_CommonLogData_t *));
d78 2
a79 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			    " rc=%d\n", __FILE__, __LINE__, rc);
d88 2
a89 2
void
rf_FreeParityLogCommonData(RF_CommonLogData_t *common)
d93 1
a93 2
	/*
	 * Insert a single struct for holding parity log information (data)
d95 1
a95 2
	 * NON-BLOCKING
	 */
d104 2
a105 2
RF_ParityLogData_t *
rf_AllocParityLogData(RF_Raid_t *raidPtr)
d109 3
a111 5
	/*
	 * Return a struct for holding parity log information from the free
	 * list (rf_parityLogDiskQueue.freeList). If the free list is empty,
	 * call RF_Malloc to create a new structure. NON-BLOCKING
	 */
d116 1
a116 2
		raidPtr->parityLogDiskQueue.freeDataList =
		    raidPtr->parityLogDiskQueue.freeDataList->next;
d120 1
a120 2
		RF_Malloc(data, sizeof(RF_ParityLogData_t),
		    (RF_ParityLogData_t *));
d128 2
a129 2
void
rf_FreeParityLogData(RF_ParityLogData_t *data)
d134 1
a134 2
	/*
	 * Insert a linked list of structs for holding parity log information
d136 1
a136 2
	 * NON-BLOCKING
	 */
d150 5
a154 3
void
rf_EnqueueParityLogData(RF_ParityLogData_t *data, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail)
d158 2
a159 4
	/*
	 * Insert an in-core parity log (*data) into the head of a disk queue
	 * (*head, *tail). NON-BLOCKING
	 */
d163 1
a163 4
		printf("[enqueueing parity log data, region %d,"
		    " raidAddress %d, numSector %d]\n", data->regionID,
		    (int) data->diskAddress.raidAddress,
		    (int) data->diskAddress.numSector);
d168 1
a168 1
		/* Insert into head of queue. */
d175 1
a175 1
		/* Insert into empty list. */
d186 6
a191 3
RF_ParityLogData_t *
rf_DequeueParityLogData(RF_Raid_t *raidPtr, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail, int ignoreLocks)
d195 2
a196 4
	/*
	 * Remove and return an in-core parity log from the tail of a disk
	 * queue (*head, *tail). NON-BLOCKING
	 */
d198 1
a198 1
	/* Remove from tail, preserving FIFO order. */
d204 1
a204 1
			/* Removing last item from queue. */
d216 1
a216 4
			printf("[dequeueing parity log data, region %d,"
			    " raidAddress %d, numSector %d]\n", data->regionID,
			    (int) data->diskAddress.raidAddress,
			    (int) data->diskAddress.numSector);
d228 5
a232 3
void
rf_RequeueParityLogData(RF_ParityLogData_t *data, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail)
d236 2
a237 4
	/*
	 * Insert an in-core parity log (*data) into the tail of a disk queue
	 * (*head, *tail). NON-BLOCKING
	 */
d242 1
a242 4
		printf("[requeueing parity log data, region %d,"
		    " raidAddress %d, numSector %d]\n", data->regionID,
		    (int) data->diskAddress.raidAddress,
		    (int) data->diskAddress.numSector);
d245 1
a245 1
		/* Append to tail of list. */
d251 1
a251 1
		/* Inserting into an empty list. */
d263 5
a267 2
rf_CreateParityLogData(RF_ParityRecordType_t operation, RF_PhysDiskAddr_t *pda,
    caddr_t bufPtr, RF_Raid_t *raidPtr,
d269 3
a271 1
    void *wakeArg, RF_AccTraceEntry_t *tracerec, RF_Etimer_t startTime)
d276 1
a276 1
	int boundary, offset = 0;
d278 1
a278 2
	/*
	 * Return an initialized struct of info to be logged. Build one item
d280 2
a281 3
	 *
	 * NON-BLOCKING
	 */
d284 1
a284 1
	common = rf_AllocParityLogCommonData(raidPtr);
d300 1
a300 1
		data = rf_AllocParityLogData(raidPtr);
d305 3
a307 5
		data->regionID = rf_MapRegionIDParityLogging(raidPtr,
		    diskAddress->startSector);
		if (data->regionID == rf_MapRegionIDParityLogging(raidPtr,
		    diskAddress->startSector + diskAddress->numSector - 1)) {
			/* Disk address does not cross a region boundary. */
d311 2
a312 2
			rf_EnqueueParityLogData(data, &resultHead, &resultTail);
			/* Adjust disk address. */
d315 2
a316 2
			/* Disk address crosses a region boundary. */
			/* Find address where region is crossed. */
d318 1
a318 3
			while (data->regionID ==
			    rf_MapRegionIDParityLogging(raidPtr,
			     diskAddress->startSector + boundary))
d321 1
a321 1
			/* Enter data before the boundary. */
d326 2
a327 2
			rf_EnqueueParityLogData(data, &resultHead, &resultTail);
			/* Adjust disk address. */
d339 6
a344 2
rf_SearchAndDequeueParityLogData(RF_Raid_t *raidPtr, int regionID,
    RF_ParityLogData_t **head, RF_ParityLogData_t **tail, int ignoreLocks)
d348 1
a348 2
	/*
	 * Remove and return an in-core parity log from a specified region
d350 5
a354 8
	 *
	 * NON-BLOCKING
	 */

	/*
	 * walk backward through a list, looking for an entry with a matching
	 * region ID.
	 */
d360 1
a360 1
			/* Remove an element from the list. */
d363 1
a363 1
					/* Removing only element in the list. */
d367 1
a367 1
					/* Removing last item in the list. */
d375 1
a375 1
					/* Removing first item in the list. */
d381 2
a382 4
					/*
					 * Removing an item from the middle of
					 * the list.
					 */
d392 1
a392 5
				printf("[dequeueing parity log data,"
				    " region %d, raidAddress %d,"
				    " numSector %d]\n", w->regionID,
				    (int) w->diskAddress.raidAddress,
				    (int) w->diskAddress.numSector);
d402 5
a406 3
RF_ParityLogData_t *
rf_DequeueMatchingLogData(RF_Raid_t *raidPtr, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail)
d409 1
a409 1
	int regionID;
d411 2
a412 3
	/*
	 * Remove and return an in-core parity log from the tail of a disk
	 * queue (*head, *tail). Then remove all matching (identical
d414 2
a415 3
	 *
	 * NON-BLOCKING
	 */
d417 1
a417 1
	logDataList = rf_DequeueParityLogData(raidPtr, head, tail, RF_TRUE);
d421 1
a421 2
		logData->next = rf_SearchAndDequeueParityLogData(raidPtr,
		    regionID, head, tail, RF_TRUE);
d424 1
a424 3
			logData->next =
			    rf_SearchAndDequeueParityLogData(raidPtr, regionID,
			     head, tail, RF_TRUE);
d431 4
a434 2
RF_ParityLog_t *
rf_AcquireParityLog(RF_ParityLogData_t *logData, int finish)
d439 2
a440 4
	/*
	 * Grab a log buffer from the pool and return it. If no buffers are
	 * available, return NULL. NON-BLOCKING
	 */
d445 1
a445 2
		raidPtr->parityLogPool.parityLogs =
		    raidPtr->parityLogPool.parityLogs->next;
d450 1
a450 2
		RF_ASSERT(raidPtr->logsInUse >= 0 &&
		    raidPtr->logsInUse <= raidPtr->numParityLogs);
d452 1
a452 2
		/*
		 * No logs available, so place ourselves on the queue of work
d455 1
a455 2
		 * ReleaseParityLogs.
		 */
d457 1
a457 2
			printf("[blocked on log, region %d, finish %d]\n",
			    logData->regionID, finish);
d459 1
a459 3
			rf_RequeueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.logBlockHead,
			    &raidPtr->parityLogDiskQueue.logBlockTail);
d461 1
a461 3
			rf_EnqueueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.logBlockHead,
			    &raidPtr->parityLogDiskQueue.logBlockTail);
d467 4
a470 2
void
rf_ReleaseParityLogs(RF_Raid_t *raidPtr, RF_ParityLog_t *firstLog)
d474 1
a474 1
	int cnt;
d476 1
a476 2
	/*
	 * Insert a linked list of parity logs (firstLog) to the free list
d478 2
a479 3
	 *
	 * NON-BLOCKING
	 */
d483 3
a485 5
	/*
	 * Before returning logs to global free list, service all requests
	 * which are blocked on logs. Holding mutexes for parityLogPool and
	 * parityLogDiskQueue forces synchronization with rf_AcquireParityLog().
	 */
d488 1
a488 3
	logDataList = rf_DequeueMatchingLogData(raidPtr,
	    &raidPtr->parityLogDiskQueue.logBlockHead,
	    &raidPtr->parityLogDiskQueue.logBlockTail);
d499 1
a499 2
			printf("[finishing up buf-blocked log data,"
			    " region %d]\n", logDataList->regionID);
d511 1
a511 3
			logDataList = rf_DequeueMatchingLogData(raidPtr,
			    &raidPtr->parityLogDiskQueue.logBlockHead,
			    &raidPtr->parityLogDiskQueue.logBlockTail);
d513 1
a513 1
	/* Return remaining logs to pool. */
d521 1
a521 2
		RF_ASSERT(raidPtr->logsInUse >= 0 &&
		    raidPtr->logsInUse <= raidPtr->numParityLogs);
d525 1
a525 2
			RF_ASSERT(raidPtr->logsInUse >= 0 &&
			    raidPtr->logsInUse <= raidPtr->numParityLogs);
d541 5
a545 2
void
rf_ReintLog(RF_Raid_t *raidPtr, int regionID, RF_ParityLog_t *log)
d549 2
a550 3
	/*
	 * Insert an in-core parity log (log) into the disk queue of
	 * reintegration work. Set the flag (reintInProgress) for the
d552 1
a552 2
	 * progress for this region. NON-BLOCKING
	 */
d555 2
a556 2
	/* Cleared when reint complete. */
	raidPtr->regionInfo[regionID].reintInProgress = RF_TRUE;
d559 2
a560 3
		printf("[requesting reintegration of region %d]\n",
		    log->regionID);
	/* Move record to reintegration queue. */
d569 4
a572 2
void
rf_FlushLog(RF_Raid_t *raidPtr, RF_ParityLog_t *log)
d574 1
a574 2
	/*
	 * Insert a core log (log) into a list of logs
d576 1
a576 2
	 * NON-BLOCKING
	 */
d581 1
a581 1
	/* Move log to flush queue. */
d589 4
a592 2
int
rf_DumpParityLogToDisk(int finish, RF_ParityLogData_t *logData)
d594 1
a594 1
	int i, diskCount, regionID = logData->regionID;
d600 1
a600 2
	/*
	 * Move a core log to disk. If the log disk is full, initiate
d602 1
a602 1
	 *
d606 4
a609 5
	 *
	 * Caller must hold regionInfo[regionID].mutex.
	 *
	 * NON-BLOCKING
	 */
d617 1
a617 1
	/* If reintegration is in progress, must queue work. */
d620 1
a620 2
		/*
		 * Can not proceed since this region is currently being
d622 1
a622 2
		 * return.
		 */
d624 3
a626 6
			printf("[region %d waiting on reintegration]\n",
			    regionID);
		/*
		 * XXX Not sure about the use of finish - shouldn't this
		 * always be "Enqueue" ?
		 */
d628 1
a628 3
			rf_RequeueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.reintBlockHead,
			    &raidPtr->parityLogDiskQueue.reintBlockTail);
d630 1
a630 3
			rf_EnqueueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.reintBlockHead,
			    &raidPtr->parityLogDiskQueue.reintBlockTail);
d632 1
a632 1
		return (1);	/* Relenquish control of this thread. */
d636 3
a638 6
	if ((raidPtr->regionInfo[regionID].diskCount) <
	    raidPtr->regionInfo[regionID].capacity)
		/*
		 * IMPORTANT !!!  This loop bound assumes region disk holds an
		 * integral number of core logs.
		 */
d640 1
a640 1
		/* Update disk map for this region. */
d643 2
a644 4
			raidPtr->regionInfo[regionID].diskMap[i + diskCount]
			    .operation = log->records[i].operation;
			raidPtr->regionInfo[regionID].diskMap[i + diskCount]
			    .parityAddr = log->records[i].parityAddr;
d647 2
a648 3
		raidPtr->regionInfo[regionID].diskCount +=
		    raidPtr->numSectorsPerLog;
		rf_FlushLog(raidPtr, log);
d650 4
a653 7
		/*
		 * No room for log on disk, send it to disk manager and
		 * request reintegration.
		 */
		RF_ASSERT(raidPtr->regionInfo[regionID].diskCount ==
		    raidPtr->regionInfo[regionID].capacity);
		rf_ReintLog(raidPtr, regionID, log);
d656 1
a656 2
		printf("[finished dumping parity log to disk, region %d]\n",
		    regionID);
d660 6
a665 3
int
rf_ParityLogAppend(RF_ParityLogData_t *logData, int finish,
    RF_ParityLog_t **incomingLog, int clearReintFlag)
d667 1
a667 1
	int regionID, logItem, itemDone;
d669 1
a669 1
	int punt, done = RF_FALSE;
d673 2
a674 2
	int (*wakeFunc) (RF_DagNode_t * node, int status);
	void *wakeArg;
d676 1
a676 2
	/*
	 * Add parity to the appropriate log, one sector at a time. This
d679 2
a680 2
	 *
	 * Parity to be logged is contained in a linked-list (logData). When
d683 7
a689 9
	 * reintegration 3) queued, waiting on a core log.
	 *
	 * Blocked work is passed to the ParityLoggingDiskManager for
	 * completion. Later, as conditions which required the block are
	 * removed, the work reenters this routine with the "finish" parameter
	 * set to "RF_TRUE."
	 *
	 * NON-BLOCKING
	 */
d692 1
a692 1
	/* Lock the region for the first item in logData. */
d699 2
a700 5
		/*
		 * Enable flushing for this region. Holding both locks
		 * provides a synchronization barrier with
		 * rf_DumpParityLogToDisk.
		 */
d703 1
a703 2
		RF_ASSERT(raidPtr->regionInfo[regionID].reintInProgress ==
		    RF_TRUE);
d706 2
a707 2
		/* Flushing is now enabled. */
		RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
d710 1
a710 1
	/* Process each item in logData. */
d712 1
a712 1
		/* Remove an item from logData. */
d719 1
a719 4
			printf("[appending parity log data, region %d,"
			    " raidAddress %d, numSector %d]\n", item->regionID,
			    (int) item->diskAddress.raidAddress,
			    (int) item->diskAddress.numSector);
d721 1
a721 1
		/* See if we moved to a new region. */
d728 1
a728 2
		punt = RF_FALSE;/*
				 * Set to RF_TRUE if work is blocked. This
d730 7
a736 10
				 * log (rf_AcquireParityLog) 2) waiting on
				 * reintegration (rf_DumpParityLogToDisk).
				 * If punt is RF_TRUE, the dataItem was queued,
				 * so skip to next item.
				 */

		/*
		 * Process item, one sector at a time, until all sectors
		 * processed or we punt.
		 */
d742 1
a742 1
			/* Verify that a core log exists for this region. */
d744 1
a744 2
				/*
				 * Attempt to acquire a parity log. If
d746 1
a746 2
				 * data item and move to nextItem.
				 */
d749 3
a751 7
						RF_ASSERT((*incomingLog)->next
						    == NULL);
						raidPtr->regionInfo[regionID]
						    .coreLog = *incomingLog;
						raidPtr->regionInfo[regionID]
						    .coreLog->regionID =
						     regionID;
d754 1
a754 4
						raidPtr->regionInfo[regionID]
						    .coreLog =
						     rf_AcquireParityLog(item,
						      finish);
d756 3
a758 6
					raidPtr->regionInfo[regionID].coreLog =
					    rf_AcquireParityLog(item, finish);
				/*
				 * Note: rf_AcquireParityLog either returns
				 * a log or enqueues currentItem.
				 */
d761 1
a761 1
				punt = RF_TRUE;	/* Failed to find a core log. */
d763 11
a773 21
				RF_ASSERT(raidPtr->regionInfo[regionID].coreLog
				    ->next == NULL);
				/*
				 * Verify that the log has room for new
				 * entries.
				 */
				/*
				 * If log is full, dump it to disk and grab a
				 * new log.
				 */
				if (raidPtr->regionInfo[regionID].coreLog
				    ->numRecords == raidPtr->numSectorsPerLog)
				{
					/* Log is full, dump it to disk. */
					if (rf_DumpParityLogToDisk(finish,
					    item))
						/*
						 * Dump unsuccessful, blocked
						 * on reintegration.
						 */
						punt = RF_TRUE;
d775 1
a775 1
						/* Dump was successful. */
d778 4
a781 11
								RF_ASSERT(
							(*incomingLog)->next ==
								    NULL);
								raidPtr->
						regionInfo[regionID].coreLog =
								   *incomingLog;
								raidPtr->
						regionInfo[regionID].coreLog->
							    regionID = regionID;
								*incomingLog =
								    NULL;
d783 1
a783 4
								raidPtr->
						regionInfo[regionID].coreLog =
						 rf_AcquireParityLog(item,
						     finish);
d785 2
a786 6
							raidPtr->regionInfo
							    [regionID].coreLog =
						 rf_AcquireParityLog(item,
						     finish);
						/*
						 * If a core log is not
d788 4
a791 9
						 * and return.
						 */
						if (!raidPtr->regionInfo
						    [regionID].coreLog)
							/*
							 * Blocked on log
							 * availability.
							 */
							punt = RF_TRUE;
d795 2
a796 4
			/*
			 * If we didn't punt on this item, attempt to add a
			 * sector to the core log.
			 */
d798 4
a801 7
				RF_ASSERT(raidPtr->regionInfo[regionID].coreLog
				    ->next == NULL);
				/*
				 * At this point, we have a core log with
				 * enough room for a sector.
				 */
				/* Copy a sector into the log. */
d803 1
a803 2
				RF_ASSERT(log->numRecords <
				    raidPtr->numSectorsPerLog);
d805 3
a807 12
				log->records[logItem].parityAddr =
				    item->diskAddress;
				RF_ASSERT(log->records[logItem].parityAddr
				    .startSector >=
				    raidPtr->regionInfo[regionID]
				    .parityStartAddr);
				RF_ASSERT(log->records[logItem].parityAddr
				    .startSector <
				    raidPtr->regionInfo[regionID]
				    .parityStartAddr +
				    raidPtr->regionInfo[regionID]
				    .numSectorsParity);
d809 2
a810 9
				log->records[logItem].operation =
				    item->common->operation;
				bcopy((item->common->bufPtr +
				    (item->bufOffset++ * (1 <<
				    item->common->raidPtr->logBytesPerSector))),
				    log->bufPtr + (logItem * (1 <<
				    item->common->raidPtr->logBytesPerSector)),
				    (1 << item->common->raidPtr
				     ->logBytesPerSector));
d819 2
a820 4
			/*
			 * Processed this item completely, decrement count of
			 * items to be processed.
			 */
d830 1
a830 2
				/*
				 * Finished processing all log data for this
d832 3
a834 4
				 * wakeup function.
				 */
				/* Grab initial value of timer. */
				timer = item->common->startTime;
d837 1
a837 2
				item->common->tracerec->plog_us +=
				    RF_ETIMER_VAL_US(timer);
d839 1
a839 2
					printf("[waking process for region"
					    " %d]\n", item->regionID);
d842 2
a843 2
				rf_FreeParityLogCommonData(item->common);
				rf_FreeParityLogData(item);
d846 1
a846 1
				rf_FreeParityLogData(item);
d856 2
a857 2
void
rf_EnableParityLogging(RF_Raid_t *raidPtr)
d859 1
a859 1
	int regionID;
d869 1
a869 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.4.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 2
a31 2
/*
 * Code for manipulating in-core parity logs.
d36 1
a36 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d39 1
a39 1
 * Append-only log for recording parity "update" and "overwrite" records.
d58 2
a59 19
RF_CommonLogData_t *rf_AllocParityLogCommonData(RF_Raid_t *);
void rf_FreeParityLogCommonData(RF_CommonLogData_t *);
RF_ParityLogData_t *rf_AllocParityLogData(RF_Raid_t *);
void rf_FreeParityLogData(RF_ParityLogData_t *);
void rf_EnqueueParityLogData(RF_ParityLogData_t *, RF_ParityLogData_t **,
	RF_ParityLogData_t **);
RF_ParityLogData_t *rf_DequeueParityLogData(RF_Raid_t *, RF_ParityLogData_t **,
	RF_ParityLogData_t **, int);
void rf_RequeueParityLogData(RF_ParityLogData_t *, RF_ParityLogData_t **,
	RF_ParityLogData_t **);
RF_ParityLogData_t *rf_DequeueMatchingLogData(RF_Raid_t *,
	RF_ParityLogData_t **, RF_ParityLogData_t **);
RF_ParityLog_t *rf_AcquireParityLog(RF_ParityLogData_t *, int);
void rf_ReintLog(RF_Raid_t *, int, RF_ParityLog_t *);
void rf_FlushLog(RF_Raid_t *, RF_ParityLog_t *);
int  rf_DumpParityLogToDisk(int, RF_ParityLogData_t *);

RF_CommonLogData_t *
rf_AllocParityLogCommonData(RF_Raid_t *raidPtr)
d62 1
a62 1
	int rc;
d64 3
a66 5
	/*
	 * Return a struct for holding common parity log information from the
	 * free list (rf_parityLogDiskQueue.freeCommonList). If the free list
	 * is empty, call RF_Malloc to create a new structure. NON-BLOCKING
	 */
d71 1
a71 2
		raidPtr->parityLogDiskQueue.freeCommonList =
		    raidPtr->parityLogDiskQueue.freeCommonList->next;
d75 1
a75 2
		RF_Malloc(common, sizeof(RF_CommonLogData_t),
		    (RF_CommonLogData_t *));
d78 2
a79 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			    " rc=%d\n", __FILE__, __LINE__, rc);
d88 2
a89 2
void
rf_FreeParityLogCommonData(RF_CommonLogData_t *common)
d93 1
a93 2
	/*
	 * Insert a single struct for holding parity log information (data)
d95 1
a95 2
	 * NON-BLOCKING
	 */
d104 2
a105 2
RF_ParityLogData_t *
rf_AllocParityLogData(RF_Raid_t *raidPtr)
d109 3
a111 5
	/*
	 * Return a struct for holding parity log information from the free
	 * list (rf_parityLogDiskQueue.freeList). If the free list is empty,
	 * call RF_Malloc to create a new structure. NON-BLOCKING
	 */
d116 1
a116 2
		raidPtr->parityLogDiskQueue.freeDataList =
		    raidPtr->parityLogDiskQueue.freeDataList->next;
d120 1
a120 2
		RF_Malloc(data, sizeof(RF_ParityLogData_t),
		    (RF_ParityLogData_t *));
d128 2
a129 2
void
rf_FreeParityLogData(RF_ParityLogData_t *data)
d134 1
a134 2
	/*
	 * Insert a linked list of structs for holding parity log information
d136 1
a136 2
	 * NON-BLOCKING
	 */
d150 5
a154 3
void
rf_EnqueueParityLogData(RF_ParityLogData_t *data, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail)
d158 2
a159 4
	/*
	 * Insert an in-core parity log (*data) into the head of a disk queue
	 * (*head, *tail). NON-BLOCKING
	 */
d163 1
a163 4
		printf("[enqueueing parity log data, region %d,"
		    " raidAddress %d, numSector %d]\n", data->regionID,
		    (int) data->diskAddress.raidAddress,
		    (int) data->diskAddress.numSector);
d168 1
a168 1
		/* Insert into head of queue. */
d175 1
a175 1
		/* Insert into empty list. */
d186 6
a191 3
RF_ParityLogData_t *
rf_DequeueParityLogData(RF_Raid_t *raidPtr, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail, int ignoreLocks)
d195 2
a196 4
	/*
	 * Remove and return an in-core parity log from the tail of a disk
	 * queue (*head, *tail). NON-BLOCKING
	 */
d198 1
a198 1
	/* Remove from tail, preserving FIFO order. */
d204 1
a204 1
			/* Removing last item from queue. */
d216 1
a216 4
			printf("[dequeueing parity log data, region %d,"
			    " raidAddress %d, numSector %d]\n", data->regionID,
			    (int) data->diskAddress.raidAddress,
			    (int) data->diskAddress.numSector);
d228 5
a232 3
void
rf_RequeueParityLogData(RF_ParityLogData_t *data, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail)
d236 2
a237 4
	/*
	 * Insert an in-core parity log (*data) into the tail of a disk queue
	 * (*head, *tail). NON-BLOCKING
	 */
d242 1
a242 4
		printf("[requeueing parity log data, region %d,"
		    " raidAddress %d, numSector %d]\n", data->regionID,
		    (int) data->diskAddress.raidAddress,
		    (int) data->diskAddress.numSector);
d245 1
a245 1
		/* Append to tail of list. */
d251 1
a251 1
		/* Inserting into an empty list. */
d263 5
a267 2
rf_CreateParityLogData(RF_ParityRecordType_t operation, RF_PhysDiskAddr_t *pda,
    caddr_t bufPtr, RF_Raid_t *raidPtr,
d269 3
a271 1
    void *wakeArg, RF_AccTraceEntry_t *tracerec, RF_Etimer_t startTime)
d276 1
a276 1
	int boundary, offset = 0;
d278 1
a278 2
	/*
	 * Return an initialized struct of info to be logged. Build one item
d280 2
a281 3
	 *
	 * NON-BLOCKING
	 */
d284 1
a284 1
	common = rf_AllocParityLogCommonData(raidPtr);
d300 1
a300 1
		data = rf_AllocParityLogData(raidPtr);
d305 3
a307 5
		data->regionID = rf_MapRegionIDParityLogging(raidPtr,
		    diskAddress->startSector);
		if (data->regionID == rf_MapRegionIDParityLogging(raidPtr,
		    diskAddress->startSector + diskAddress->numSector - 1)) {
			/* Disk address does not cross a region boundary. */
d311 2
a312 2
			rf_EnqueueParityLogData(data, &resultHead, &resultTail);
			/* Adjust disk address. */
d315 2
a316 2
			/* Disk address crosses a region boundary. */
			/* Find address where region is crossed. */
d318 1
a318 3
			while (data->regionID ==
			    rf_MapRegionIDParityLogging(raidPtr,
			     diskAddress->startSector + boundary))
d321 1
a321 1
			/* Enter data before the boundary. */
d326 2
a327 2
			rf_EnqueueParityLogData(data, &resultHead, &resultTail);
			/* Adjust disk address. */
d339 6
a344 2
rf_SearchAndDequeueParityLogData(RF_Raid_t *raidPtr, int regionID,
    RF_ParityLogData_t **head, RF_ParityLogData_t **tail, int ignoreLocks)
d348 1
a348 2
	/*
	 * Remove and return an in-core parity log from a specified region
d350 5
a354 8
	 *
	 * NON-BLOCKING
	 */

	/*
	 * walk backward through a list, looking for an entry with a matching
	 * region ID.
	 */
d360 1
a360 1
			/* Remove an element from the list. */
d363 1
a363 1
					/* Removing only element in the list. */
d367 1
a367 1
					/* Removing last item in the list. */
d375 1
a375 1
					/* Removing first item in the list. */
d381 2
a382 4
					/*
					 * Removing an item from the middle of
					 * the list.
					 */
d392 1
a392 5
				printf("[dequeueing parity log data,"
				    " region %d, raidAddress %d,"
				    " numSector %d]\n", w->regionID,
				    (int) w->diskAddress.raidAddress,
				    (int) w->diskAddress.numSector);
d402 5
a406 3
RF_ParityLogData_t *
rf_DequeueMatchingLogData(RF_Raid_t *raidPtr, RF_ParityLogData_t **head,
    RF_ParityLogData_t **tail)
d409 1
a409 1
	int regionID;
d411 2
a412 3
	/*
	 * Remove and return an in-core parity log from the tail of a disk
	 * queue (*head, *tail). Then remove all matching (identical
d414 2
a415 3
	 *
	 * NON-BLOCKING
	 */
d417 1
a417 1
	logDataList = rf_DequeueParityLogData(raidPtr, head, tail, RF_TRUE);
d421 1
a421 2
		logData->next = rf_SearchAndDequeueParityLogData(raidPtr,
		    regionID, head, tail, RF_TRUE);
d424 1
a424 3
			logData->next =
			    rf_SearchAndDequeueParityLogData(raidPtr, regionID,
			     head, tail, RF_TRUE);
d431 4
a434 2
RF_ParityLog_t *
rf_AcquireParityLog(RF_ParityLogData_t *logData, int finish)
d439 2
a440 4
	/*
	 * Grab a log buffer from the pool and return it. If no buffers are
	 * available, return NULL. NON-BLOCKING
	 */
d445 1
a445 2
		raidPtr->parityLogPool.parityLogs =
		    raidPtr->parityLogPool.parityLogs->next;
d450 1
a450 2
		RF_ASSERT(raidPtr->logsInUse >= 0 &&
		    raidPtr->logsInUse <= raidPtr->numParityLogs);
d452 1
a452 2
		/*
		 * No logs available, so place ourselves on the queue of work
d455 1
a455 2
		 * ReleaseParityLogs.
		 */
d457 1
a457 2
			printf("[blocked on log, region %d, finish %d]\n",
			    logData->regionID, finish);
d459 1
a459 3
			rf_RequeueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.logBlockHead,
			    &raidPtr->parityLogDiskQueue.logBlockTail);
d461 1
a461 3
			rf_EnqueueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.logBlockHead,
			    &raidPtr->parityLogDiskQueue.logBlockTail);
d467 4
a470 2
void
rf_ReleaseParityLogs(RF_Raid_t *raidPtr, RF_ParityLog_t *firstLog)
d474 1
a474 1
	int cnt;
d476 1
a476 2
	/*
	 * Insert a linked list of parity logs (firstLog) to the free list
d478 2
a479 3
	 *
	 * NON-BLOCKING
	 */
d483 3
a485 5
	/*
	 * Before returning logs to global free list, service all requests
	 * which are blocked on logs. Holding mutexes for parityLogPool and
	 * parityLogDiskQueue forces synchronization with rf_AcquireParityLog().
	 */
d488 1
a488 3
	logDataList = rf_DequeueMatchingLogData(raidPtr,
	    &raidPtr->parityLogDiskQueue.logBlockHead,
	    &raidPtr->parityLogDiskQueue.logBlockTail);
d499 1
a499 2
			printf("[finishing up buf-blocked log data,"
			    " region %d]\n", logDataList->regionID);
d511 1
a511 3
			logDataList = rf_DequeueMatchingLogData(raidPtr,
			    &raidPtr->parityLogDiskQueue.logBlockHead,
			    &raidPtr->parityLogDiskQueue.logBlockTail);
d513 1
a513 1
	/* Return remaining logs to pool. */
d521 1
a521 2
		RF_ASSERT(raidPtr->logsInUse >= 0 &&
		    raidPtr->logsInUse <= raidPtr->numParityLogs);
d525 1
a525 2
			RF_ASSERT(raidPtr->logsInUse >= 0 &&
			    raidPtr->logsInUse <= raidPtr->numParityLogs);
d541 5
a545 2
void
rf_ReintLog(RF_Raid_t *raidPtr, int regionID, RF_ParityLog_t *log)
d549 2
a550 3
	/*
	 * Insert an in-core parity log (log) into the disk queue of
	 * reintegration work. Set the flag (reintInProgress) for the
d552 1
a552 2
	 * progress for this region. NON-BLOCKING
	 */
d555 2
a556 2
	/* Cleared when reint complete. */
	raidPtr->regionInfo[regionID].reintInProgress = RF_TRUE;
d559 2
a560 3
		printf("[requesting reintegration of region %d]\n",
		    log->regionID);
	/* Move record to reintegration queue. */
d569 4
a572 2
void
rf_FlushLog(RF_Raid_t *raidPtr, RF_ParityLog_t *log)
d574 1
a574 2
	/*
	 * Insert a core log (log) into a list of logs
d576 1
a576 2
	 * NON-BLOCKING
	 */
d581 1
a581 1
	/* Move log to flush queue. */
d589 4
a592 2
int
rf_DumpParityLogToDisk(int finish, RF_ParityLogData_t *logData)
d594 1
a594 1
	int i, diskCount, regionID = logData->regionID;
d600 1
a600 2
	/*
	 * Move a core log to disk. If the log disk is full, initiate
d602 1
a602 1
	 *
d606 4
a609 5
	 *
	 * Caller must hold regionInfo[regionID].mutex.
	 *
	 * NON-BLOCKING
	 */
d617 1
a617 1
	/* If reintegration is in progress, must queue work. */
d620 1
a620 2
		/*
		 * Can not proceed since this region is currently being
d622 1
a622 2
		 * return.
		 */
d624 3
a626 6
			printf("[region %d waiting on reintegration]\n",
			    regionID);
		/*
		 * XXX Not sure about the use of finish - shouldn't this
		 * always be "Enqueue" ?
		 */
d628 1
a628 3
			rf_RequeueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.reintBlockHead,
			    &raidPtr->parityLogDiskQueue.reintBlockTail);
d630 1
a630 3
			rf_EnqueueParityLogData(logData,
			    &raidPtr->parityLogDiskQueue.reintBlockHead,
			    &raidPtr->parityLogDiskQueue.reintBlockTail);
d632 1
a632 1
		return (1);	/* Relenquish control of this thread. */
d636 3
a638 6
	if ((raidPtr->regionInfo[regionID].diskCount) <
	    raidPtr->regionInfo[regionID].capacity)
		/*
		 * IMPORTANT !!!  This loop bound assumes region disk holds an
		 * integral number of core logs.
		 */
d640 1
a640 1
		/* Update disk map for this region. */
d643 2
a644 4
			raidPtr->regionInfo[regionID].diskMap[i + diskCount]
			    .operation = log->records[i].operation;
			raidPtr->regionInfo[regionID].diskMap[i + diskCount]
			    .parityAddr = log->records[i].parityAddr;
d647 2
a648 3
		raidPtr->regionInfo[regionID].diskCount +=
		    raidPtr->numSectorsPerLog;
		rf_FlushLog(raidPtr, log);
d650 4
a653 7
		/*
		 * No room for log on disk, send it to disk manager and
		 * request reintegration.
		 */
		RF_ASSERT(raidPtr->regionInfo[regionID].diskCount ==
		    raidPtr->regionInfo[regionID].capacity);
		rf_ReintLog(raidPtr, regionID, log);
d656 1
a656 2
		printf("[finished dumping parity log to disk, region %d]\n",
		    regionID);
d660 6
a665 3
int
rf_ParityLogAppend(RF_ParityLogData_t *logData, int finish,
    RF_ParityLog_t **incomingLog, int clearReintFlag)
d667 1
a667 1
	int regionID, logItem, itemDone;
d669 1
a669 1
	int punt, done = RF_FALSE;
d673 2
a674 2
	int (*wakeFunc) (RF_DagNode_t * node, int status);
	void *wakeArg;
d676 1
a676 2
	/*
	 * Add parity to the appropriate log, one sector at a time. This
d679 2
a680 2
	 *
	 * Parity to be logged is contained in a linked-list (logData). When
d683 7
a689 9
	 * reintegration 3) queued, waiting on a core log.
	 *
	 * Blocked work is passed to the ParityLoggingDiskManager for
	 * completion. Later, as conditions which required the block are
	 * removed, the work reenters this routine with the "finish" parameter
	 * set to "RF_TRUE."
	 *
	 * NON-BLOCKING
	 */
d692 1
a692 1
	/* Lock the region for the first item in logData. */
d699 2
a700 5
		/*
		 * Enable flushing for this region. Holding both locks
		 * provides a synchronization barrier with
		 * rf_DumpParityLogToDisk.
		 */
d703 1
a703 2
		RF_ASSERT(raidPtr->regionInfo[regionID].reintInProgress ==
		    RF_TRUE);
d706 2
a707 2
		/* Flushing is now enabled. */
		RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
d710 1
a710 1
	/* Process each item in logData. */
d712 1
a712 1
		/* Remove an item from logData. */
d719 1
a719 4
			printf("[appending parity log data, region %d,"
			    " raidAddress %d, numSector %d]\n", item->regionID,
			    (int) item->diskAddress.raidAddress,
			    (int) item->diskAddress.numSector);
d721 1
a721 1
		/* See if we moved to a new region. */
d728 1
a728 2
		punt = RF_FALSE;/*
				 * Set to RF_TRUE if work is blocked. This
d730 7
a736 10
				 * log (rf_AcquireParityLog) 2) waiting on
				 * reintegration (rf_DumpParityLogToDisk).
				 * If punt is RF_TRUE, the dataItem was queued,
				 * so skip to next item.
				 */

		/*
		 * Process item, one sector at a time, until all sectors
		 * processed or we punt.
		 */
d742 1
a742 1
			/* Verify that a core log exists for this region. */
d744 1
a744 2
				/*
				 * Attempt to acquire a parity log. If
d746 1
a746 2
				 * data item and move to nextItem.
				 */
d749 3
a751 7
						RF_ASSERT((*incomingLog)->next
						    == NULL);
						raidPtr->regionInfo[regionID]
						    .coreLog = *incomingLog;
						raidPtr->regionInfo[regionID]
						    .coreLog->regionID =
						     regionID;
d754 1
a754 4
						raidPtr->regionInfo[regionID]
						    .coreLog =
						     rf_AcquireParityLog(item,
						      finish);
d756 3
a758 6
					raidPtr->regionInfo[regionID].coreLog =
					    rf_AcquireParityLog(item, finish);
				/*
				 * Note: rf_AcquireParityLog either returns
				 * a log or enqueues currentItem.
				 */
d761 1
a761 1
				punt = RF_TRUE;	/* Failed to find a core log. */
d763 11
a773 21
				RF_ASSERT(raidPtr->regionInfo[regionID].coreLog
				    ->next == NULL);
				/*
				 * Verify that the log has room for new
				 * entries.
				 */
				/*
				 * If log is full, dump it to disk and grab a
				 * new log.
				 */
				if (raidPtr->regionInfo[regionID].coreLog
				    ->numRecords == raidPtr->numSectorsPerLog)
				{
					/* Log is full, dump it to disk. */
					if (rf_DumpParityLogToDisk(finish,
					    item))
						/*
						 * Dump unsuccessful, blocked
						 * on reintegration.
						 */
						punt = RF_TRUE;
d775 1
a775 1
						/* Dump was successful. */
d778 4
a781 11
								RF_ASSERT(
							(*incomingLog)->next ==
								    NULL);
								raidPtr->
						regionInfo[regionID].coreLog =
								   *incomingLog;
								raidPtr->
						regionInfo[regionID].coreLog->
							    regionID = regionID;
								*incomingLog =
								    NULL;
d783 1
a783 4
								raidPtr->
						regionInfo[regionID].coreLog =
						 rf_AcquireParityLog(item,
						     finish);
d785 2
a786 6
							raidPtr->regionInfo
							    [regionID].coreLog =
						 rf_AcquireParityLog(item,
						     finish);
						/*
						 * If a core log is not
d788 4
a791 9
						 * and return.
						 */
						if (!raidPtr->regionInfo
						    [regionID].coreLog)
							/*
							 * Blocked on log
							 * availability.
							 */
							punt = RF_TRUE;
d795 2
a796 4
			/*
			 * If we didn't punt on this item, attempt to add a
			 * sector to the core log.
			 */
d798 4
a801 7
				RF_ASSERT(raidPtr->regionInfo[regionID].coreLog
				    ->next == NULL);
				/*
				 * At this point, we have a core log with
				 * enough room for a sector.
				 */
				/* Copy a sector into the log. */
d803 1
a803 2
				RF_ASSERT(log->numRecords <
				    raidPtr->numSectorsPerLog);
d805 3
a807 12
				log->records[logItem].parityAddr =
				    item->diskAddress;
				RF_ASSERT(log->records[logItem].parityAddr
				    .startSector >=
				    raidPtr->regionInfo[regionID]
				    .parityStartAddr);
				RF_ASSERT(log->records[logItem].parityAddr
				    .startSector <
				    raidPtr->regionInfo[regionID]
				    .parityStartAddr +
				    raidPtr->regionInfo[regionID]
				    .numSectorsParity);
d809 2
a810 9
				log->records[logItem].operation =
				    item->common->operation;
				bcopy((item->common->bufPtr +
				    (item->bufOffset++ * (1 <<
				    item->common->raidPtr->logBytesPerSector))),
				    log->bufPtr + (logItem * (1 <<
				    item->common->raidPtr->logBytesPerSector)),
				    (1 << item->common->raidPtr
				     ->logBytesPerSector));
d819 2
a820 4
			/*
			 * Processed this item completely, decrement count of
			 * items to be processed.
			 */
d830 1
a830 2
				/*
				 * Finished processing all log data for this
d832 3
a834 4
				 * wakeup function.
				 */
				/* Grab initial value of timer. */
				timer = item->common->startTime;
d837 1
a837 2
				item->common->tracerec->plog_us +=
				    RF_ETIMER_VAL_US(timer);
d839 1
a839 2
					printf("[waking process for region"
					    " %d]\n", item->regionID);
d842 2
a843 2
				rf_FreeParityLogCommonData(item->common);
				rf_FreeParityLogData(item);
d846 1
a846 1
				rf_FreeParityLogData(item);
d856 2
a857 2
void
rf_EnableParityLogging(RF_Raid_t *raidPtr)
d859 1
a859 1
	int regionID;
d869 1
a869 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.3
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylog.c,v 1.2 1999/02/16 00:03:04 niklas Exp $	*/
/*	$NetBSD: rf_paritylog.c,v 1.4 1999/08/13 03:41:57 oster Exp $	*/
a53 1
#include "rf_threadid.h"
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylog.c,v 1.1 1999/01/11 14:29:34 niklas Exp $	*/
/*	$NetBSD: rf_paritylog.c,v 1.3 1999/02/05 00:06:13 oster Exp $	*/
a57 1
#include "rf_sys.h"
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylog.c,v 1.1 1998/11/13 04:20:31 oster Exp $	*/
/*	$NetBSD: rf_paritylog.c,v 1.1 1998/11/13 04:20:31 oster Exp $	*/
a31 101
 * :  
 * Log: rf_paritylog.c,v 
 * Revision 1.27  1996/07/28 20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.26  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.25  1996/07/17  21:00:58  jimz
 * clean up timer interface, tracing
 *
 * Revision 1.24  1996/06/11  10:18:59  jimz
 * AllocParityLogCommonData() was freeing the common pointer immediately
 * after allocating this. It appeared that this free really belonged
 * inside one of the failure cases (for backing out), so I moved it
 * in there.
 *
 * Revision 1.23  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.22  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.21  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.20  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.19  1996/05/30  12:59:18  jimz
 * make etimer happier, more portable
 *
 * Revision 1.18  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.17  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.16  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.15  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.14  1996/05/20  16:16:59  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.13  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.12  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.11  1995/12/06  20:54:44  wvcii
 * added prototyping
 *
 * Revision 1.10  1995/11/30  16:05:37  wvcii
 * added copyright info
 *
 * Revision 1.9  1995/10/08  20:41:28  wvcii
 * fixed bug in allocation of CommonLogData (was allocating incorrect size)
 *
 * Revision 1.8  1995/09/07  15:52:12  jimz
 * noop compile when INCLUDE_PARITYLOGGING not defined
 *
 * Revision 1.7  1995/09/06  19:17:36  wvcii
 * moved code for reintegration to rf_paritylogDiskMgr.c
 *
 * Revision 1.6  95/07/07  00:16:06  wvcii
 * this version free from deadlock, fails parity verification
 * 
 * Revision 1.5  1995/06/09  13:14:24  wvcii
 * code is now nonblocking
 *
 * Revision 1.4  95/06/01  17:01:59  wvcii
 * code debug
 * 
 * Revision 1.3  95/05/31  13:08:23  wvcii
 * code debug
 * 
 * Revision 1.2  95/05/21  15:42:15  wvcii
 * code debug
 * 
 * Revision 1.1  95/05/18  10:43:54  wvcii
 * Initial revision
 * 
d60 32
a91 1
static RF_CommonLogData_t *AllocParityLogCommonData(RF_Raid_t *raidPtr)
d93 1
a93 2
  RF_CommonLogData_t *common = NULL;
  int rc;
d95 238
a332 154
  /* Return a struct for holding common parity log information from the free
     list (rf_parityLogDiskQueue.freeCommonList).  If the free list is empty, call
     RF_Malloc to create a new structure.
     NON-BLOCKING */

  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  if (raidPtr->parityLogDiskQueue.freeCommonList)
    {
      common = raidPtr->parityLogDiskQueue.freeCommonList;
      raidPtr->parityLogDiskQueue.freeCommonList = raidPtr->parityLogDiskQueue.freeCommonList->next;
      RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
    }
  else
    {
      RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
      RF_Malloc(common, sizeof(RF_CommonLogData_t), (RF_CommonLogData_t *));
      rc = rf_mutex_init(&common->mutex);
      if (rc) {
        RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
          __LINE__, rc);
        RF_Free(common, sizeof(RF_CommonLogData_t));
        common = NULL;
      }
    }
  common->next = NULL;
  return(common);
}

static void FreeParityLogCommonData(RF_CommonLogData_t *common)
{
  RF_Raid_t *raidPtr;

  /* Insert a single struct for holding parity log information
     (data) into the free list (rf_parityLogDiskQueue.freeCommonList).
     NON-BLOCKING */

  raidPtr = common->raidPtr;
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  common->next = raidPtr->parityLogDiskQueue.freeCommonList;
  raidPtr->parityLogDiskQueue.freeCommonList = common;
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
}

static RF_ParityLogData_t *AllocParityLogData(RF_Raid_t *raidPtr)
{
  RF_ParityLogData_t *data = NULL;

  /* Return a struct for holding parity log information from the free
     list (rf_parityLogDiskQueue.freeList).  If the free list is empty, call
     RF_Malloc to create a new structure.
     NON-BLOCKING */
  
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  if (raidPtr->parityLogDiskQueue.freeDataList)
    {
      data = raidPtr->parityLogDiskQueue.freeDataList;
      raidPtr->parityLogDiskQueue.freeDataList = raidPtr->parityLogDiskQueue.freeDataList->next;
      RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
    }
  else
    {
      RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
      RF_Malloc(data, sizeof(RF_ParityLogData_t), (RF_ParityLogData_t *));
    }
  data->next = NULL;
  data->prev = NULL;
  return(data);
}


static void FreeParityLogData(RF_ParityLogData_t *data)
{
  RF_ParityLogData_t *nextItem;
  RF_Raid_t *raidPtr;

  /* Insert a linked list of structs for holding parity log
     information (data) into the free list (parityLogDiskQueue.freeList).
     NON-BLOCKING */

  raidPtr = data->common->raidPtr;
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  while (data)
    {
      nextItem = data->next;
      data->next = raidPtr->parityLogDiskQueue.freeDataList;
      raidPtr->parityLogDiskQueue.freeDataList = data;
      data = nextItem;
    }
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
}


static void EnqueueParityLogData(
  RF_ParityLogData_t   *data,
  RF_ParityLogData_t  **head,
  RF_ParityLogData_t  **tail)
{
  RF_Raid_t *raidPtr;

  /* Insert an in-core parity log (*data) into the head of
     a disk queue (*head, *tail).
     NON-BLOCKING */

  raidPtr = data->common->raidPtr;
  if (rf_parityLogDebug)
    printf("[enqueueing parity log data, region %d, raidAddress %d, numSector %d]\n",data->regionID,(int)data->diskAddress.raidAddress, (int)data->diskAddress.numSector);
  RF_ASSERT(data->prev == NULL);
  RF_ASSERT(data->next == NULL);
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  if (*head)
    {
      /* insert into head of queue */
      RF_ASSERT((*head)->prev == NULL);
      RF_ASSERT((*tail)->next == NULL);
      data->next = *head;
      (*head)->prev = data;
      *head = data;
    }
  else
    {
      /* insert into empty list */
      RF_ASSERT(*head == NULL);
      RF_ASSERT(*tail == NULL);
      *head = data;
      *tail = data;
    }
  RF_ASSERT((*head)->prev == NULL);
  RF_ASSERT((*tail)->next == NULL);
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
}

static RF_ParityLogData_t *DequeueParityLogData(
  RF_Raid_t            *raidPtr,
  RF_ParityLogData_t  **head,
  RF_ParityLogData_t  **tail,
  int                   ignoreLocks)
{
  RF_ParityLogData_t *data;

  /* Remove and return an in-core parity log from the tail of
     a disk queue (*head, *tail).
     NON-BLOCKING */

  /* remove from tail, preserving FIFO order */
  if (!ignoreLocks)
    RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  data = *tail;
  if (data)
    {
      if (*head == *tail)
	{
	  /* removing last item from queue */
	  *head = NULL;
	  *tail = NULL;
d334 94
a427 113
      else
	{
	  *tail = (*tail)->prev;
	  (*tail)->next = NULL;
	  RF_ASSERT((*head)->prev == NULL);
	  RF_ASSERT((*tail)->next == NULL);
	}
      data->next = NULL;
      data->prev = NULL;
      if (rf_parityLogDebug)
	printf("[dequeueing parity log data, region %d, raidAddress %d, numSector %d]\n",data->regionID,(int)data->diskAddress.raidAddress, (int)data->diskAddress.numSector);
    }
  if (*head)
    {
      RF_ASSERT((*head)->prev == NULL);
      RF_ASSERT((*tail)->next == NULL);
    }
  if (!ignoreLocks)
    RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  return(data);
}


static void RequeueParityLogData(
  RF_ParityLogData_t   *data,
  RF_ParityLogData_t  **head,
  RF_ParityLogData_t  **tail)
{
  RF_Raid_t *raidPtr;

  /* Insert an in-core parity log (*data) into the tail of
     a disk queue (*head, *tail).
     NON-BLOCKING */

  raidPtr = data->common->raidPtr;
  RF_ASSERT(data);
  if (rf_parityLogDebug)
    printf("[requeueing parity log data, region %d, raidAddress %d, numSector %d]\n",data->regionID,(int)data->diskAddress.raidAddress, (int) data->diskAddress.numSector);
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  if (*tail)
    {
      /* append to tail of list */
      data->prev = *tail;
      data->next = NULL;
      (*tail)->next = data;
      *tail = data;
    }
  else
    {
      /* inserting into an empty list */
      *head = data;
      *tail = data;
      (*head)->prev = NULL;
      (*tail)->next = NULL;
    }
  RF_ASSERT((*head)->prev == NULL);
  RF_ASSERT((*tail)->next == NULL);
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
}

RF_ParityLogData_t *rf_CreateParityLogData(
  RF_ParityRecordType_t    operation,
  RF_PhysDiskAddr_t       *pda,
  caddr_t                  bufPtr,
  RF_Raid_t               *raidPtr,
  int                    (*wakeFunc)(RF_DagNode_t *node, int status),
  void                    *wakeArg,
  RF_AccTraceEntry_t      *tracerec,
  RF_Etimer_t              startTime)
{
  RF_ParityLogData_t *data, *resultHead = NULL, *resultTail = NULL;
  RF_CommonLogData_t *common;
  RF_PhysDiskAddr_t *diskAddress;
  int boundary, offset = 0;

  /* Return an initialized struct of info to be logged.
     Build one item per physical disk address, one item per region.

     NON-BLOCKING */

  diskAddress = pda;
  common = AllocParityLogCommonData(raidPtr);
  RF_ASSERT(common);

  common->operation = operation;
  common->bufPtr = bufPtr;
  common->raidPtr = raidPtr;
  common->wakeFunc = wakeFunc;
  common->wakeArg = wakeArg;
  common->tracerec = tracerec;
  common->startTime = startTime;
  common->cnt = 0;

  if (rf_parityLogDebug)
    printf("[entering CreateParityLogData]\n");
  while (diskAddress)
    {
      common->cnt++;
      data = AllocParityLogData(raidPtr);
      RF_ASSERT(data);
      data->common = common;
      data->next = NULL;
      data->prev = NULL;
      data->regionID = rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector);
      if (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + diskAddress->numSector - 1))
	{
	  /* disk address does not cross a region boundary */
	  data->diskAddress = *diskAddress;
	  data->bufOffset = offset;
	  offset = offset + diskAddress->numSector;
	  EnqueueParityLogData(data, &resultHead, &resultTail);
	  /* adjust disk address */
	  diskAddress = diskAddress->next;
d429 1
a429 22
      else
	{
	  /* disk address crosses a region boundary */
	  /* find address where region is crossed */
	  boundary = 0;
	  while (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + boundary))
	    boundary++;

	  /* enter data before the boundary */
	  data->diskAddress = *diskAddress;
	  data->diskAddress.numSector = boundary;
	  data->bufOffset = offset;
	  offset += boundary;
	  EnqueueParityLogData(data, &resultHead, &resultTail);
	  /* adjust disk address */
	  diskAddress->startSector += boundary;
	  diskAddress->numSector -= boundary;
	}
    }
  if (rf_parityLogDebug)
    printf("[leaving CreateParityLogData]\n");
  return(resultHead);
d433 31
a463 99
RF_ParityLogData_t *rf_SearchAndDequeueParityLogData(
  RF_Raid_t            *raidPtr,
  int                   regionID,
  RF_ParityLogData_t  **head,
  RF_ParityLogData_t  **tail,
  int                   ignoreLocks)
{
  RF_ParityLogData_t *w;

  /* Remove and return an in-core parity log from a specified region (regionID).
     If a matching log is not found, return NULL.

     NON-BLOCKING.
     */

  /* walk backward through a list, looking for an entry with a matching region ID */
  if (!ignoreLocks)
    RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  w = (*tail);
  while (w)
    {
      if (w->regionID == regionID)
	{
	  /* remove an element from the list */
	  if (w == *tail)
	    {
	      if (*head == *tail)
		{
		  /* removing only element in the list */
		  *head = NULL;
		  *tail = NULL;
		}
	      else
		{
		  /* removing last item in the list */
		  *tail = (*tail)->prev;
		  (*tail)->next = NULL;
		  RF_ASSERT((*head)->prev == NULL);
		  RF_ASSERT((*tail)->next == NULL);
		}
	    }
	  else
	    {
	      if (w == *head)
		{
		  /* removing first item in the list */
		  *head = (*head)->next;
		  (*head)->prev = NULL;
		  RF_ASSERT((*head)->prev == NULL);
		  RF_ASSERT((*tail)->next == NULL);
		}
	      else
		{
		  /* removing an item from the middle of the list */
		  w->prev->next = w->next;
		  w->next->prev = w->prev;
		  RF_ASSERT((*head)->prev == NULL);
		  RF_ASSERT((*tail)->next == NULL);
		}
	    }
	  w->prev = NULL;
	  w->next = NULL;
	  if (rf_parityLogDebug)
	    printf("[dequeueing parity log data, region %d, raidAddress %d, numSector %d]\n",w->regionID,(int)w->diskAddress.raidAddress,(int) w->diskAddress.numSector);
	  return(w);
	}
      else
	w = w->prev;
    }
  if (!ignoreLocks)
    RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  return(NULL);
}

static RF_ParityLogData_t *DequeueMatchingLogData(
  RF_Raid_t            *raidPtr,
  RF_ParityLogData_t  **head,
  RF_ParityLogData_t  **tail)
{
  RF_ParityLogData_t *logDataList, *logData;
  int regionID;

  /* Remove and return an in-core parity log from the tail of
     a disk queue (*head, *tail).  Then remove all matching
     (identical regionIDs) logData and return as a linked list.

     NON-BLOCKING
     */

  logDataList = DequeueParityLogData(raidPtr, head, tail, RF_TRUE);
  if (logDataList)
    {
      regionID = logDataList->regionID;
      logData = logDataList;
      logData->next = rf_SearchAndDequeueParityLogData(raidPtr, regionID, head, tail, RF_TRUE);
      while (logData->next)
	{
	  logData = logData->next;
	  logData->next = rf_SearchAndDequeueParityLogData(raidPtr, regionID, head, tail, RF_TRUE);
d465 2
a466 2
    }
  return(logDataList);
d469 15
d485 5
a489 88
static RF_ParityLog_t *AcquireParityLog(
  RF_ParityLogData_t  *logData,
  int                  finish)
{
  RF_ParityLog_t *log = NULL;
  RF_Raid_t *raidPtr;

  /* Grab a log buffer from the pool and return it.
     If no buffers are available, return NULL.
     NON-BLOCKING
     */
  raidPtr = logData->common->raidPtr;
  RF_LOCK_MUTEX(raidPtr->parityLogPool.mutex);
  if (raidPtr->parityLogPool.parityLogs)
    {
      log = raidPtr->parityLogPool.parityLogs;
      raidPtr->parityLogPool.parityLogs = raidPtr->parityLogPool.parityLogs->next;
      log->regionID = logData->regionID;
      log->numRecords = 0;
      log->next = NULL;
      raidPtr->logsInUse++;
      RF_ASSERT(raidPtr->logsInUse >= 0 && raidPtr->logsInUse <= raidPtr->numParityLogs);
    }
  else
    {
      /* no logs available, so place ourselves on the queue of work waiting on log buffers
	 this is done while parityLogPool.mutex is held, to ensure synchronization
	 with ReleaseParityLogs.
	 */
      if (rf_parityLogDebug)
	printf("[blocked on log, region %d, finish %d]\n", logData->regionID, finish);
      if (finish)
	RequeueParityLogData(logData, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);
      else
	EnqueueParityLogData(logData, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);
    }
  RF_UNLOCK_MUTEX(raidPtr->parityLogPool.mutex);
  return(log);
}

void rf_ReleaseParityLogs(
  RF_Raid_t       *raidPtr,
  RF_ParityLog_t  *firstLog)
{
  RF_ParityLogData_t *logDataList;
  RF_ParityLog_t *log, *lastLog;
  int cnt;

  /* Insert a linked list of parity logs (firstLog) to 
     the free list (parityLogPool.parityLogPool)

     NON-BLOCKING.
     */

  RF_ASSERT(firstLog);

  /* Before returning logs to global free list, service all
     requests which are blocked on logs.  Holding mutexes for parityLogPool and parityLogDiskQueue
     forces synchronization with AcquireParityLog().
     */
  RF_LOCK_MUTEX(raidPtr->parityLogPool.mutex);
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  logDataList = DequeueMatchingLogData(raidPtr, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);
  log = firstLog;
  if (firstLog)
    firstLog = firstLog->next;
  log->numRecords = 0;
  log->next = NULL;
  while (logDataList && log)
    {
      RF_UNLOCK_MUTEX(raidPtr->parityLogPool.mutex);
      RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
      rf_ParityLogAppend(logDataList, RF_TRUE, &log, RF_FALSE);
      if (rf_parityLogDebug)
	printf("[finishing up buf-blocked log data, region %d]\n", logDataList->regionID);
      if (log == NULL)
	{
	  log = firstLog;
	  if (firstLog)
	    {
	      firstLog = firstLog->next;
	      log->numRecords = 0;
	      log->next = NULL;
	    }
	}
      RF_LOCK_MUTEX(raidPtr->parityLogPool.mutex);
      RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
      if (log)
d491 47
a537 26
    }
  /* return remaining logs to pool */
  if (log)
    {
      log->next = firstLog;
      firstLog = log;
    }
  if (firstLog)
    {
      lastLog = firstLog;
      raidPtr->logsInUse--;
      RF_ASSERT(raidPtr->logsInUse >= 0 && raidPtr->logsInUse <= raidPtr->numParityLogs);
      while (lastLog->next)
	{
	  lastLog = lastLog->next;
	  raidPtr->logsInUse--;
	  RF_ASSERT(raidPtr->logsInUse >= 0 && raidPtr->logsInUse <= raidPtr->numParityLogs);
	}
      lastLog->next = raidPtr->parityLogPool.parityLogs;
      raidPtr->parityLogPool.parityLogs = firstLog;
      cnt = 0;
      log = raidPtr->parityLogPool.parityLogs;
      while (log)
	{
	  cnt++;
	  log = log->next;
d539 3
a541 186
      RF_ASSERT(cnt + raidPtr->logsInUse == raidPtr->numParityLogs);
    }
  RF_UNLOCK_MUTEX(raidPtr->parityLogPool.mutex);
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
}

static void ReintLog(
  RF_Raid_t       *raidPtr,
  int              regionID,
  RF_ParityLog_t  *log)
{
  RF_ASSERT(log);

  /* Insert an in-core parity log (log) into the disk queue of reintegration
     work.  Set the flag (reintInProgress) for the specified region (regionID)
     to indicate that reintegration is in progress for this region.
     NON-BLOCKING
     */

  RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
  raidPtr->regionInfo[regionID].reintInProgress = RF_TRUE;  /* cleared when reint complete */

  if (rf_parityLogDebug)
    printf("[requesting reintegration of region %d]\n", log->regionID);
  /* move record to reintegration queue */
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  log->next = raidPtr->parityLogDiskQueue.reintQueue;
  raidPtr->parityLogDiskQueue.reintQueue = log;
  RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  RF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);
}

static void FlushLog(
  RF_Raid_t       *raidPtr,
  RF_ParityLog_t  *log)
{
  /* insert a core log (log) into a list of logs (parityLogDiskQueue.flushQueue)
     waiting to be written to disk.
     NON-BLOCKING
     */

  RF_ASSERT(log);
  RF_ASSERT(log->numRecords == raidPtr->numSectorsPerLog);
  RF_ASSERT(log->next == NULL);
  /* move log to flush queue */
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  log->next = raidPtr->parityLogDiskQueue.flushQueue;
  raidPtr->parityLogDiskQueue.flushQueue = log;
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  RF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);
}

static int DumpParityLogToDisk(
  int                  finish,
  RF_ParityLogData_t  *logData)
{
  int i, diskCount, regionID = logData->regionID;
  RF_ParityLog_t *log;
  RF_Raid_t *raidPtr;

  raidPtr = logData->common->raidPtr;

  /* Move a core log to disk.  If the log disk is full, initiate
     reintegration.

     Return (0) if we can enqueue the dump immediately, otherwise
     return (1) to indicate we are blocked on reintegration and
     control of the thread should be relinquished.

     Caller must hold regionInfo[regionID].mutex

     NON-BLOCKING
     */

  if (rf_parityLogDebug)
    printf("[dumping parity log to disk, region %d]\n", regionID);
  log = raidPtr->regionInfo[regionID].coreLog;
  RF_ASSERT(log->numRecords == raidPtr->numSectorsPerLog);
  RF_ASSERT(log->next == NULL);

  /* if reintegration is in progress, must queue work */
  RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
  if (raidPtr->regionInfo[regionID].reintInProgress)
    {
      /* Can not proceed since this region is currently being reintegrated.
	 We can not block, so queue remaining work and return */
      if (rf_parityLogDebug)
	printf("[region %d waiting on reintegration]\n",regionID);
      /* XXX not sure about the use of finish - shouldn't this always be "Enqueue"? */
      if (finish)
	RequeueParityLogData(logData, &raidPtr->parityLogDiskQueue.reintBlockHead, &raidPtr->parityLogDiskQueue.reintBlockTail);
      else
	EnqueueParityLogData(logData, &raidPtr->parityLogDiskQueue.reintBlockHead, &raidPtr->parityLogDiskQueue.reintBlockTail);
      RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
      return(1);  /* relenquish control of this thread */
    }
  RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
  raidPtr->regionInfo[regionID].coreLog = NULL;
  if ((raidPtr->regionInfo[regionID].diskCount) < raidPtr->regionInfo[regionID].capacity)
    /* IMPORTANT!! this loop bound assumes region disk holds an integral number of core logs */
    {
      /* update disk map for this region */
      diskCount = raidPtr->regionInfo[regionID].diskCount;
      for (i = 0; i < raidPtr->numSectorsPerLog; i++)
	{
	  raidPtr->regionInfo[regionID].diskMap[i + diskCount].operation = log->records[i].operation;
	  raidPtr->regionInfo[regionID].diskMap[i + diskCount].parityAddr = log->records[i].parityAddr;
	}
      log->diskOffset = diskCount;
      raidPtr->regionInfo[regionID].diskCount += raidPtr->numSectorsPerLog;
      FlushLog(raidPtr, log);
    }
  else
    {
      /* no room for log on disk, send it to disk manager and request reintegration */
      RF_ASSERT(raidPtr->regionInfo[regionID].diskCount == raidPtr->regionInfo[regionID].capacity);
      ReintLog(raidPtr, regionID, log);
    }
  if (rf_parityLogDebug)
    printf("[finished dumping parity log to disk, region %d]\n", regionID);
  return(0);
}

int rf_ParityLogAppend(
  RF_ParityLogData_t   *logData,
  int                   finish,
  RF_ParityLog_t      **incomingLog,
  int                   clearReintFlag)
{
  int regionID, logItem, itemDone;
  RF_ParityLogData_t *item;
  int punt, done = RF_FALSE;
  RF_ParityLog_t *log;
  RF_Raid_t *raidPtr;
  RF_Etimer_t timer;
  int (*wakeFunc)(RF_DagNode_t *node, int status);
  void *wakeArg;

  /* Add parity to the appropriate log, one sector at a time.
     This routine is called is called by dag functions ParityLogUpdateFunc
     and ParityLogOverwriteFunc and therefore MUST BE NONBLOCKING.

     Parity to be logged is contained in a linked-list (logData).  When
     this routine returns, every sector in the list will be in one of
     three places:
       1) entered into the parity log
       2) queued, waiting on reintegration
       3) queued, waiting on a core log

     Blocked work is passed to the ParityLoggingDiskManager for completion.
     Later, as conditions which required the block are removed, the work
     reenters this routine with the "finish" parameter set to "RF_TRUE."

     NON-BLOCKING
     */

  raidPtr = logData->common->raidPtr;
  /* lock the region for the first item in logData */
  RF_ASSERT(logData != NULL);
  regionID = logData->regionID;
  RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
  RF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);

  if (clearReintFlag)
    {
      /* Enable flushing for this region.  Holding both locks provides
	 a synchronization barrier with DumpParityLogToDisk
	 */
      RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
      RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
      RF_ASSERT(raidPtr->regionInfo[regionID].reintInProgress == RF_TRUE);
      raidPtr->regionInfo[regionID].diskCount = 0;
      raidPtr->regionInfo[regionID].reintInProgress = RF_FALSE;
      RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex); /* flushing is now enabled */
      RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
    }

  /* process each item in logData */
  while (logData)
    {
      /* remove an item from logData */
      item = logData;
      logData = logData->next;
      item->next = NULL;
      item->prev = NULL;
d543 276
a818 2
      if (rf_parityLogDebug)
	printf("[appending parity log data, region %d, raidAddress %d, numSector %d]\n",item->regionID,(int)item->diskAddress.raidAddress, (int)item->diskAddress.numSector);
d820 8
a827 65
      /* see if we moved to a new region */
      if (regionID != item->regionID)
	{
	  RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	  regionID = item->regionID;
	  RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	  RF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);
	}

      punt = RF_FALSE;  /* Set to RF_TRUE if work is blocked.  This can happen in one of two ways:
		          1) no core log (AcquireParityLog)
			  2) waiting on reintegration (DumpParityLogToDisk)
			If punt is RF_TRUE, the dataItem was queued, so skip to next item.
			*/

      /* process item, one sector at a time, until all sectors processed or we punt */
      if (item->diskAddress.numSector > 0)
	done = RF_FALSE;
      else
	RF_ASSERT(0);
      while (!punt && !done)
	{
	  /* verify that a core log exists for this region */
	  if (!raidPtr->regionInfo[regionID].coreLog)
	    {
	      /* Attempt to acquire a parity log.
		 If acquisition fails, queue remaining work in data item and move to nextItem.
		 */
	      if (incomingLog) {
		if (*incomingLog)
		  {
		    RF_ASSERT((*incomingLog)->next == NULL);
		    raidPtr->regionInfo[regionID].coreLog = *incomingLog;
		    raidPtr->regionInfo[regionID].coreLog->regionID = regionID;
		    *incomingLog = NULL;
		  }
		else
		  raidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);
	      } else
		raidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);
	      /* Note: AcquireParityLog either returns a log or enqueues currentItem */
	    }
	  if (!raidPtr->regionInfo[regionID].coreLog)
	    punt = RF_TRUE; /* failed to find a core log */
	  else
	    {
	      RF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);
	      /* verify that the log has room for new entries */
	      /* if log is full, dump it to disk and grab a new log */
	      if (raidPtr->regionInfo[regionID].coreLog->numRecords == raidPtr->numSectorsPerLog)
		{
		  /* log is full, dump it to disk */
		  if (DumpParityLogToDisk(finish, item))
		    punt = RF_TRUE; /* dump unsuccessful, blocked on reintegration */
		  else
		    {
		      /* dump was successful */
		      if (incomingLog) {
			if (*incomingLog)
			  {
			    RF_ASSERT((*incomingLog)->next == NULL);
			    raidPtr->regionInfo[regionID].coreLog = *incomingLog;
			    raidPtr->regionInfo[regionID].coreLog->regionID = regionID;
			    *incomingLog = NULL;
			  }
d829 21
a849 29
			  raidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);
		      } else
			raidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);
		      /* if a core log is not available, must queue work and return */
		      if (!raidPtr->regionInfo[regionID].coreLog)
			punt = RF_TRUE; /* blocked on log availability */
		    }
		}
	    }
	  /* if we didn't punt on this item, attempt to add a sector to the core log */
	  if (!punt)
	    {
	      RF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);
	      /* at this point, we have a core log with enough room for a sector */
	      /* copy a sector into the log */
	      log = raidPtr->regionInfo[regionID].coreLog;
	      RF_ASSERT(log->numRecords < raidPtr->numSectorsPerLog);
	      logItem = log->numRecords++;
	      log->records[logItem].parityAddr = item->diskAddress;
	      RF_ASSERT(log->records[logItem].parityAddr.startSector >= raidPtr->regionInfo[regionID].parityStartAddr);
	      RF_ASSERT(log->records[logItem].parityAddr.startSector < raidPtr->regionInfo[regionID].parityStartAddr + raidPtr->regionInfo[regionID].numSectorsParity);
	      log->records[logItem].parityAddr.numSector = 1;
	      log->records[logItem].operation = item->common->operation;
	      bcopy((item->common->bufPtr + (item->bufOffset++ * (1<<item->common->raidPtr->logBytesPerSector))), log->bufPtr + (logItem * (1<<item->common->raidPtr->logBytesPerSector)), (1<<item->common->raidPtr->logBytesPerSector));
	      item->diskAddress.numSector--;
	      item->diskAddress.startSector++;
	      if (item->diskAddress.numSector == 0)
		done = RF_TRUE;
	    }
d851 5
a856 39
      if (!punt)
	{
	  /* Processed this item completely, decrement count of items
	     to be processed.
	     */
	  RF_ASSERT(item->diskAddress.numSector == 0);
	  RF_LOCK_MUTEX(item->common->mutex);
	  item->common->cnt--;
	  if (item->common->cnt == 0)
	    itemDone = RF_TRUE;
	  else
	    itemDone = RF_FALSE;
	  RF_UNLOCK_MUTEX(item->common->mutex);
	  if (itemDone)
	    {
	      /* Finished processing all log data for this IO
		 Return structs to free list and invoke wakeup function.
		 */
	      timer = item->common->startTime;  /* grab initial value of timer */
	      RF_ETIMER_STOP(timer);
	      RF_ETIMER_EVAL(timer);
	      item->common->tracerec->plog_us += RF_ETIMER_VAL_US(timer);
	      if (rf_parityLogDebug)
		printf("[waking process for region %d]\n", item->regionID);
	      wakeFunc = item->common->wakeFunc;
	      wakeArg = item->common->wakeArg;
	      FreeParityLogCommonData(item->common);
	      FreeParityLogData(item);
	      (wakeFunc)(wakeArg, 0);
	    }
	  else
	    FreeParityLogData(item);
	}
    }
  RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
  if (rf_parityLogDebug)
    printf("[exiting ParityLogAppend]\n");
  return(0);
}
d858 4
d863 7
a869 11
void rf_EnableParityLogging(RF_Raid_t *raidPtr)
{
  int regionID;

  for (regionID = 0; regionID < rf_numParityRegions; regionID++) {
    RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
    raidPtr->regionInfo[regionID].loggingEnabled = RF_TRUE;
    RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
  }
  if (rf_parityLogDebug)
    printf("[parity logging enabled]\n");
d871 1
a871 2

#endif /* RF_INCLUDE_PARITYLOGGING > 0 */
@

