head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.38
	OPENBSD_5_0:1.4.0.36
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.16
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.14
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.12
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.4;

1.4
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.3.2.1
	1.3.12.1;
next	1.2;

1.2
date	99.02.16.00.03.08;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.37;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.3.12.1
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_parityloggingdags.c,v 1.4 2002/12/16 07:01:04 tdeval Exp $	*/
/*	$NetBSD: rf_parityloggingdags.c,v 1.4 2000/01/07 03:41:04 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: William V. Courtright II
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include "rf_archs.h"

#if	RF_INCLUDE_PARITYLOGGING > 0

/*
 * DAGs specific to parity logging are created here.
 */

#include "rf_types.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagutils.h"
#include "rf_dagfuncs.h"
#include "rf_debugMem.h"
#include "rf_paritylog.h"
#include "rf_memchunk.h"
#include "rf_general.h"

#include "rf_parityloggingdags.h"

/*****************************************************************************
 *
 * Creates a DAG to perform a large-write operation:
 *
 *         / Rod \     / Wnd \
 * H -- NIL- Rod - NIL - Wnd ------ NIL - T
 *         \ Rod /     \ Xor - Lpo /
 *
 * The writes are not done until the reads complete because if they were done
 * in parallel, a failure on one of the reads could leave the parity in an
 * inconsistent state, so that the retry with a new DAG would produce
 * erroneous parity.
 *
 * Note:  This DAG has the nasty property that none of the buffers allocated
 *        for reading old data can be freed until the XOR node fires.
 *        Need to fix this.
 *
 * The last two arguments are the number of faults tolerated, and function
 * for the redundancy calculation. The undo for the redundancy calc is assumed
 * to be null.
 *
 *****************************************************************************/

void
rf_CommonCreateParityLoggingLargeWriteDAG(RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList, int nfaults,
    int (*redFunc) (RF_DagNode_t *))
{
	RF_DagNode_t *nodes, *wndNodes, *rodNodes = NULL, *syncNode, *xorNode;
	RF_DagNode_t *lpoNode, *blockNode, *unblockNode, *termNode;
	int nWndNodes, nRodNodes, i;
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	RF_AccessStripeMapHeader_t *new_asm_h[2];
	int nodeNum, asmNum;
	RF_ReconUnitNum_t which_ru;
	char *sosBuffer, *eosBuffer;
	RF_PhysDiskAddr_t *pda;
	RF_StripeNum_t parityStripeID =
	    rf_RaidAddressToParityStripeID(&(raidPtr->Layout),
	     asmap->raidAddress, &which_ru);

	if (rf_dagDebug)
		printf("[Creating parity-logging large-write DAG]\n");
	RF_ASSERT(nfaults == 1); /* This arch only single fault tolerant. */
	dag_h->creator = "ParityLoggingLargeWriteDAG";

	/* Alloc the Wnd nodes, the xor node, and the Lpo node. */
	nWndNodes = asmap->numStripeUnitsAccessed;
	RF_CallocAndAdd(nodes, nWndNodes + 6, sizeof(RF_DagNode_t),
	    (RF_DagNode_t *), allocList);
	i = 0;
	wndNodes = &nodes[i];
	i += nWndNodes;
	xorNode = &nodes[i];
	i += 1;
	lpoNode = &nodes[i];
	i += 1;
	blockNode = &nodes[i];
	i += 1;
	syncNode = &nodes[i];
	i += 1;
	unblockNode = &nodes[i];
	i += 1;
	termNode = &nodes[i];
	i += 1;

	dag_h->numCommitNodes = nWndNodes + 1;
	dag_h->numCommits = 0;
	dag_h->numSuccedents = 1;

	rf_MapUnaccessedPortionOfStripe(raidPtr, layoutPtr, asmap, dag_h,
	    new_asm_h, &nRodNodes, &sosBuffer, &eosBuffer, allocList);
	if (nRodNodes > 0)
		RF_CallocAndAdd(rodNodes, nRodNodes, sizeof(RF_DagNode_t),
		    (RF_DagNode_t *), allocList);

	/* Begin node initialization. */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nRodNodes + 1, 0, 0, 0, dag_h,
	    "Nil", allocList);
	rf_InitNode(unblockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, nWndNodes + 1, 0, 0, dag_h,
	    "Nil", allocList);
	rf_InitNode(syncNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nWndNodes + 1, nRodNodes + 1,
	    0, 0, dag_h, "Nil", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);

	/* Initialize the Rod nodes. */
	for (nodeNum = asmNum = 0; asmNum < 2; asmNum++) {
		if (new_asm_h[asmNum]) {
			pda = new_asm_h[asmNum]->stripeMap->physInfo;
			while (pda) {
				rf_InitNode(&rodNodes[nodeNum], rf_wait,
				    RF_FALSE, rf_DiskReadFunc,
				    rf_DiskReadUndoFunc, rf_GenericWakeupFunc,
				    1, 1, 4, 0, dag_h, "Rod", allocList);
				rodNodes[nodeNum].params[0].p = pda;
				rodNodes[nodeNum].params[1].p = pda->bufPtr;
				rodNodes[nodeNum].params[2].v = parityStripeID;
				rodNodes[nodeNum].params[3].v =
				    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
				     0, 0, which_ru);
				nodeNum++;
				pda = pda->next;
			}
		}
	}
	RF_ASSERT(nodeNum == nRodNodes);

	/* Initialize the wnd nodes. */
	pda = asmap->physInfo;
	for (i = 0; i < nWndNodes; i++) {
		rf_InitNode(&wndNodes[i], rf_wait, RF_TRUE, rf_DiskWriteFunc,
		    rf_DiskWriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Wnd", allocList);
		RF_ASSERT(pda != NULL);
		wndNodes[i].params[0].p = pda;
		wndNodes[i].params[1].p = pda->bufPtr;
		wndNodes[i].params[2].v = parityStripeID;
		wndNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
		pda = pda->next;
	}

	/* Initialize the redundancy node. */
	rf_InitNode(xorNode, rf_wait, RF_TRUE, redFunc, rf_NullNodeUndoFunc,
	    NULL, 1, 1, 2 * (nWndNodes + nRodNodes) + 1, 1, dag_h,
	    "Xr ", allocList);
	xorNode->flags |= RF_DAGNODE_FLAG_YIELD;
	for (i = 0; i < nWndNodes; i++) {
		/* pda */
		xorNode->params[2 * i + 0] = wndNodes[i].params[0];
		/* buf ptr */
		xorNode->params[2 * i + 1] = wndNodes[i].params[1];
	}
	for (i = 0; i < nRodNodes; i++) {
		xorNode->params[2 * (nWndNodes + i) + 0] =
		    rodNodes[i].params[0];	/* pda */
		xorNode->params[2 * (nWndNodes + i) + 1] =
		    rodNodes[i].params[1];	/* buf ptr */
	}
	/* Xor node needs to get at RAID information. */
	xorNode->params[2 * (nWndNodes + nRodNodes)].p = raidPtr;

	/*
	 * Look for an Rod node that reads a complete SU. If none, alloc a
	 * buffer to receive the parity info. Note that we can't use a new
	 * data buffer because it will not have gotten written when the xor
	 * occurs.
	 */
	for (i = 0; i < nRodNodes; i++)
		if (((RF_PhysDiskAddr_t *) rodNodes[i].params[0].p)
		    ->numSector == raidPtr->Layout.sectorsPerStripeUnit)
			break;
	if (i == nRodNodes) {
		RF_CallocAndAdd(xorNode->results[0], 1,
		    rf_RaidAddressToByte(raidPtr,
		     raidPtr->Layout.sectorsPerStripeUnit), (void *),
		    allocList);
	} else {
		xorNode->results[0] = rodNodes[i].params[1].p;
	}

	/* Initialize the Lpo node. */
	rf_InitNode(lpoNode, rf_wait, RF_FALSE, rf_ParityLogOverwriteFunc,
	    rf_ParityLogOverwriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 2, 0,
	    dag_h, "Lpo", allocList);

	lpoNode->params[0].p = asmap->parityInfo;
	lpoNode->params[1].p = xorNode->results[0];
	/* parityInfo must describe entire parity unit. */
	RF_ASSERT(asmap->parityInfo->next == NULL);

	/* Connect nodes to form graph. */

	/* Connect dag header to block node. */
	RF_ASSERT(dag_h->numSuccedents == 1);
	RF_ASSERT(blockNode->numAntecedents == 0);
	dag_h->succedents[0] = blockNode;

	/* Connect the block node to the Rod nodes. */
	RF_ASSERT(blockNode->numSuccedents == nRodNodes + 1);
	for (i = 0; i < nRodNodes; i++) {
		RF_ASSERT(rodNodes[i].numAntecedents == 1);
		blockNode->succedents[i] = &rodNodes[i];
		rodNodes[i].antecedents[0] = blockNode;
		rodNodes[i].antType[0] = rf_control;
	}

	/* Connect the block node to the sync node. */
	/* necessary if nRodNodes == 0 */
	RF_ASSERT(syncNode->numAntecedents == nRodNodes + 1);
	blockNode->succedents[nRodNodes] = syncNode;
	syncNode->antecedents[0] = blockNode;
	syncNode->antType[0] = rf_control;

	/* Connect the Rod nodes to the syncNode. */
	for (i = 0; i < nRodNodes; i++) {
		rodNodes[i].succedents[0] = syncNode;
		syncNode->antecedents[1 + i] = &rodNodes[i];
		syncNode->antType[1 + i] = rf_control;
	}

	/* Connect the sync node to the xor node. */
	RF_ASSERT(syncNode->numSuccedents == nWndNodes + 1);
	RF_ASSERT(xorNode->numAntecedents == 1);
	syncNode->succedents[0] = xorNode;
	xorNode->antecedents[0] = syncNode;
	xorNode->antType[0] = rf_trueData;	/* Carry forward from sync. */

	/* Connect the sync node to the Wnd nodes. */
	for (i = 0; i < nWndNodes; i++) {
		RF_ASSERT(wndNodes->numAntecedents == 1);
		syncNode->succedents[1 + i] = &wndNodes[i];
		wndNodes[i].antecedents[0] = syncNode;
		wndNodes[i].antType[0] = rf_control;
	}

	/* Connect the xor node to the Lpo node. */
	RF_ASSERT(xorNode->numSuccedents == 1);
	RF_ASSERT(lpoNode->numAntecedents == 1);
	xorNode->succedents[0] = lpoNode;
	lpoNode->antecedents[0] = xorNode;
	lpoNode->antType[0] = rf_trueData;

	/* Connect the Wnd nodes to the unblock node. */
	RF_ASSERT(unblockNode->numAntecedents == nWndNodes + 1);
	for (i = 0; i < nWndNodes; i++) {
		RF_ASSERT(wndNodes->numSuccedents == 1);
		wndNodes[i].succedents[0] = unblockNode;
		unblockNode->antecedents[i] = &wndNodes[i];
		unblockNode->antType[i] = rf_control;
	}

	/* Connect the Lpo node to the unblock node. */
	RF_ASSERT(lpoNode->numSuccedents == 1);
	lpoNode->succedents[0] = unblockNode;
	unblockNode->antecedents[nWndNodes] = lpoNode;
	unblockNode->antType[nWndNodes] = rf_control;

	/* Connect unblock node to terminator. */
	RF_ASSERT(unblockNode->numSuccedents == 1);
	RF_ASSERT(termNode->numAntecedents == 1);
	RF_ASSERT(termNode->numSuccedents == 0);
	unblockNode->succedents[0] = termNode;
	termNode->antecedents[0] = unblockNode;
	termNode->antType[0] = rf_control;
}


/*****************************************************************************
 *
 * Creates a DAG to perform a small-write operation (either raid 5 or pq),
 * which is as follows:
 *
 *				       Header
 *				          |
 *				        Block
 *				    / |  ... \   \
 *				   /  |       \   \
 *				Rod  Rod      Rod  Rop
 *				 | \ /| \    / |  \/ |
 *				 |    |        |  /\ |
 *				Wnd  Wnd      Wnd   X
 *				 |    \       /     |
 *				 |     \     /      |
 *				  \     \   /      Lpo
 *				   \     \ /       /
 *				    +-> Unblock <-+
 *				          |
 *				          T
 *
 *
 * R = Read, W = Write, X = Xor, o = old, n = new, d = data, p = parity.
 * When the access spans a stripe unit boundary and is less than one SU in
 * size, there will be two Rop -- X -- Wnp branches. I call this the
 * "double-XOR" case.
 * The second output from each Rod node goes to the X node. In the double-XOR
 * case, there are exactly 2 Rod nodes, and each sends one output to one X
 * node.
 * There is one Rod -- Wnd -- T branch for each stripe unit being updated.
 *
 * The block and unblock nodes are unused. See comment above
 * CreateFaultFreeReadDAG.
 *
 * Note:  This DAG ignores all the optimizations related to making the RMWs
 *        atomic.
 *        It also has the nasty property that none of the buffers allocated
 *        for reading old data & parity can be freed until the XOR node fires.
 *        Need to fix this.
 *
 * A null qfuncs indicates single fault tolerant.
 *****************************************************************************/

void
rf_CommonCreateParityLoggingSmallWriteDAG(RF_Raid_t *raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList,
    RF_RedFuncs_t *pfuncs, RF_RedFuncs_t *qfuncs)
{
	RF_DagNode_t *xorNodes, *blockNode, *unblockNode, *nodes;
	RF_DagNode_t *readDataNodes, *readParityNodes;
	RF_DagNode_t *writeDataNodes, *lpuNodes;
	RF_DagNode_t *unlockDataNodes = NULL, *termNode;
	RF_PhysDiskAddr_t *pda = asmap->physInfo;
	int numDataNodes = asmap->numStripeUnitsAccessed;
	int numParityNodes = (asmap->parityInfo->next) ? 2 : 1;
	int i, j, nNodes, totalNumNodes;
	RF_ReconUnitNum_t which_ru;
	int (*func) (RF_DagNode_t * node), (*undoFunc) (RF_DagNode_t * node);
	int (*qfunc) (RF_DagNode_t * node);
	char*name, *qname;
	RF_StripeNum_t parityStripeID =
	    rf_RaidAddressToParityStripeID(&(raidPtr->Layout),
	     asmap->raidAddress, &which_ru);
	long nfaults = qfuncs ? 2 : 1;
	int lu_flag = (rf_enableAtomicRMW) ? 1 : 0;	/* Lock/unlock flag. */

	if (rf_dagDebug)
		printf("[Creating parity-logging small-write DAG]\n");
	RF_ASSERT(numDataNodes > 0);
	RF_ASSERT(nfaults == 1);
	dag_h->creator = "ParityLoggingSmallWriteDAG";

	/*
	 * DAG creation occurs in three steps:
	 * 1. Count the number of nodes in the DAG.
	 * 2. Create the nodes.
	 * 3. Initialize the nodes.
	 * 4. Connect the nodes.
	 */

	/* Step 1. Compute number of nodes in the graph. */

	/*
	 * Number of nodes: a read and write for each data unit, a redundancy
	 * computation node for each parity node, a read and Lpu for each
	 * parity unit, a block and unblock node (2), a terminator node if
	 * atomic RMW, an unlock node for each data and redundancy unit.
	 */
	totalNumNodes = (2 * numDataNodes) + numParityNodes +
	    (2 * numParityNodes) + 3;
	if (lu_flag)
		totalNumNodes += numDataNodes;

	nNodes = numDataNodes + numParityNodes;

	dag_h->numCommitNodes = numDataNodes + numParityNodes;
	dag_h->numCommits = 0;
	dag_h->numSuccedents = 1;

	/* Step 2. Create the nodes. */
	RF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),
	    (RF_DagNode_t *), allocList);
	i = 0;
	blockNode = &nodes[i];
	i += 1;
	unblockNode = &nodes[i];
	i += 1;
	readDataNodes = &nodes[i];
	i += numDataNodes;
	readParityNodes = &nodes[i];
	i += numParityNodes;
	writeDataNodes = &nodes[i];
	i += numDataNodes;
	lpuNodes = &nodes[i];
	i += numParityNodes;
	xorNodes = &nodes[i];
	i += numParityNodes;
	termNode = &nodes[i];
	i += 1;
	if (lu_flag) {
		unlockDataNodes = &nodes[i];
		i += numDataNodes;
	}
	RF_ASSERT(i == totalNumNodes);

	/* Step 3. Initialize the nodes. */
	/* Initialize block node (Nil). */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nNodes, 0, 0, 0, dag_h,
	    "Nil", allocList);

	/* Initialize unblock node (Nil). */
	rf_InitNode(unblockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, nNodes, 0, 0, dag_h,
	    "Nil", allocList);

	/* Initialize terminatory node (Trm). */
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);

	/* Initialize nodes which read old data (Rod). */
	for (i = 0; i < numDataNodes; i++) {
		rf_InitNode(&readDataNodes[i], rf_wait, RF_FALSE,
		    rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc,
		    nNodes, 1, 4, 0, dag_h, "Rod", allocList);
		RF_ASSERT(pda != NULL);
		/* Physical disk addr desc. */
		readDataNodes[i].params[0].p = pda;
		readDataNodes[i].params[1].p = rf_AllocBuffer(raidPtr, dag_h,
		    pda, allocList);	/* Buffer to hold old data. */
		readDataNodes[i].params[2].v = parityStripeID;
		readDataNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, lu_flag,
		    0, which_ru);
		pda = pda->next;
		readDataNodes[i].propList[0] = NULL;
		readDataNodes[i].propList[1] = NULL;
	}

	/* Initialize nodes which read old parity (Rop). */
	pda = asmap->parityInfo;
	i = 0;
	for (i = 0; i < numParityNodes; i++) {
		RF_ASSERT(pda != NULL);
		rf_InitNode(&readParityNodes[i], rf_wait, RF_FALSE,
		    rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc,
		    nNodes, 1, 4, 0, dag_h, "Rop", allocList);
		readParityNodes[i].params[0].p = pda;
		readParityNodes[i].params[1].p = rf_AllocBuffer(raidPtr, dag_h,
		    pda, allocList);	/* Buffer to hold old parity. */
		readParityNodes[i].params[2].v = parityStripeID;
		readParityNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
		readParityNodes[i].propList[0] = NULL;
		pda = pda->next;
	}

	/* Initialize nodes which write new data (Wnd). */
	pda = asmap->physInfo;
	for (i = 0; i < numDataNodes; i++) {
		RF_ASSERT(pda != NULL);
		rf_InitNode(&writeDataNodes[i], rf_wait, RF_TRUE,
		    rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
		    rf_GenericWakeupFunc, 1, nNodes, 4, 0, dag_h,
		    "Wnd", allocList);
		/* Physical disk addr desc. */
		writeDataNodes[i].params[0].p = pda;
		/* Buffer holding new data to be written. */
		writeDataNodes[i].params[1].p = pda->bufPtr;
		writeDataNodes[i].params[2].v = parityStripeID;
		writeDataNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);

		if (lu_flag) {
			/* Initialize node to unlock the disk queue. */
			rf_InitNode(&unlockDataNodes[i], rf_wait, RF_FALSE,
			    rf_DiskUnlockFunc, rf_DiskUnlockUndoFunc,
			    rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h,
			    "Und", allocList);
			/* Physical disk addr desc. */
			unlockDataNodes[i].params[0].p = pda;
			unlockDataNodes[i].params[1].v =
			    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0,
			    lu_flag, which_ru);
		}
		pda = pda->next;
	}


	/* Initialize nodes which compute new parity. */
	/*
	 * We use the simple XOR func in the double-XOR case, and when we're
	 * accessing only a portion of one stripe unit. The distinction
	 * between the two is that the regular XOR func assumes that the
	 * targbuf is a full SU in size, and examines the pda associated with
	 * the buffer to decide where within the buffer to XOR the data,
	 * whereas the simple XOR func just XORs the data into the start of
	 * the buffer.
	 */
	if ((numParityNodes == 2) || ((numDataNodes == 1) &&
	    (asmap->totalSectorsAccessed <
	     raidPtr->Layout.sectorsPerStripeUnit))) {
		func = pfuncs->simple;
		undoFunc = rf_NullNodeUndoFunc;
		name = pfuncs->SimpleName;
		if (qfuncs) {
			qfunc = qfuncs->simple;
			qname = qfuncs->SimpleName;
		}
	} else {
		func = pfuncs->regular;
		undoFunc = rf_NullNodeUndoFunc;
		name = pfuncs->RegularName;
		if (qfuncs) {
			qfunc = qfuncs->regular;
			qname = qfuncs->RegularName;
		}
	}
	/*
	 * Initialize the xor nodes: params are {pda,buf} from {Rod,Wnd,Rop}
	 * nodes, and raidPtr.
	 */
	if (numParityNodes == 2) {	/* Double-XOR case. */
		for (i = 0; i < numParityNodes; i++) {
			rf_InitNode(&xorNodes[i], rf_wait, RF_TRUE, func,
			    undoFunc, NULL, 1, nNodes, 7, 1, dag_h, name,
			    allocList);	/* No wakeup func for XOR. */
			xorNodes[i].flags |= RF_DAGNODE_FLAG_YIELD;
			xorNodes[i].params[0] = readDataNodes[i].params[0];
			xorNodes[i].params[1] = readDataNodes[i].params[1];
			xorNodes[i].params[2] = readParityNodes[i].params[0];
			xorNodes[i].params[3] = readParityNodes[i].params[1];
			xorNodes[i].params[4] = writeDataNodes[i].params[0];
			xorNodes[i].params[5] = writeDataNodes[i].params[1];
			xorNodes[i].params[6].p = raidPtr;
			/* Use old parity buf as target buf. */
			xorNodes[i].results[0] = readParityNodes[i].params[1].p;
		}
	} else {
		/* There is only one xor node in this case. */
		rf_InitNode(&xorNodes[0], rf_wait, RF_TRUE, func, undoFunc,
		    NULL, 1, nNodes,
		    (2 * (numDataNodes + numDataNodes + 1) + 1), 1,
		    dag_h, name, allocList);
		xorNodes[0].flags |= RF_DAGNODE_FLAG_YIELD;
		for (i = 0; i < numDataNodes + 1; i++) {
			/* Set up params related to Rod and Rop nodes. */
			xorNodes[0].params[2 * i + 0] =
			    readDataNodes[i].params[0];	/* pda */
			xorNodes[0].params[2 * i + 1] =
			    readDataNodes[i].params[1];	/* Buffer pointer */
		}
		for (i = 0; i < numDataNodes; i++) {
			/* Set up params related to Wnd and Wnp nodes. */
			xorNodes[0].params[2 * (numDataNodes + 1 + i) + 0] =
			    writeDataNodes[i].params[0]; /* pda */
			xorNodes[0].params[2 * (numDataNodes + 1 + i) + 1] =
			    writeDataNodes[i].params[1]; /* Buffer pointer */
		}
		xorNodes[0].params[2 * (numDataNodes + numDataNodes + 1)].p =
		    raidPtr;	/* Xor node needs to get at RAID information. */
		xorNodes[0].results[0] = readParityNodes[0].params[1].p;
	}

	/* Initialize the log node(s). */
	pda = asmap->parityInfo;
	for (i = 0; i < numParityNodes; i++) {
		RF_ASSERT(pda);
		rf_InitNode(&lpuNodes[i], rf_wait, RF_FALSE,
		    rf_ParityLogUpdateFunc, rf_ParityLogUpdateUndoFunc,
		    rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h, "Lpu", allocList);
		lpuNodes[i].params[0].p = pda;	/* PhysDiskAddr of parity. */
		/* Buffer pointer to parity. */
		lpuNodes[i].params[1].p = xorNodes[i].results[0];
		pda = pda->next;
	}


	/* Step 4. Connect the nodes. */

	/* Connect header to block node. */
	RF_ASSERT(dag_h->numSuccedents == 1);
	RF_ASSERT(blockNode->numAntecedents == 0);
	dag_h->succedents[0] = blockNode;

	/* Connect block node to read old data nodes. */
	RF_ASSERT(blockNode->numSuccedents == (numDataNodes + numParityNodes));
	for (i = 0; i < numDataNodes; i++) {
		blockNode->succedents[i] = &readDataNodes[i];
		RF_ASSERT(readDataNodes[i].numAntecedents == 1);
		readDataNodes[i].antecedents[0] = blockNode;
		readDataNodes[i].antType[0] = rf_control;
	}

	/* Connect block node to read old parity nodes. */
	for (i = 0; i < numParityNodes; i++) {
		blockNode->succedents[numDataNodes + i] = &readParityNodes[i];
		RF_ASSERT(readParityNodes[i].numAntecedents == 1);
		readParityNodes[i].antecedents[0] = blockNode;
		readParityNodes[i].antType[0] = rf_control;
	}

	/* Connect read old data nodes to write new data nodes. */
	for (i = 0; i < numDataNodes; i++) {
		RF_ASSERT(readDataNodes[i].numSuccedents ==
		          numDataNodes + numParityNodes);
		for (j = 0; j < numDataNodes; j++) {
			RF_ASSERT(writeDataNodes[j].numAntecedents ==
			          numDataNodes + numParityNodes);
			readDataNodes[i].succedents[j] = &writeDataNodes[j];
			writeDataNodes[j].antecedents[i] = &readDataNodes[i];
			if (i == j)
				writeDataNodes[j].antType[i] = rf_antiData;
			else
				writeDataNodes[j].antType[i] = rf_control;
		}
	}

	/* Connect read old data nodes to xor nodes. */
	for (i = 0; i < numDataNodes; i++)
		for (j = 0; j < numParityNodes; j++) {
			RF_ASSERT(xorNodes[j].numAntecedents ==
			          numDataNodes + numParityNodes);
			readDataNodes[i].succedents[numDataNodes + j] =
			    &xorNodes[j];
			xorNodes[j].antecedents[i] = &readDataNodes[i];
			xorNodes[j].antType[i] = rf_trueData;
		}

	/* Connect read old parity nodes to write new data nodes. */
	for (i = 0; i < numParityNodes; i++) {
		RF_ASSERT(readParityNodes[i].numSuccedents ==
		          numDataNodes + numParityNodes);
		for (j = 0; j < numDataNodes; j++) {
			readParityNodes[i].succedents[j] = &writeDataNodes[j];
			writeDataNodes[j].antecedents[numDataNodes + i] =
			    &readParityNodes[i];
			writeDataNodes[j].antType[numDataNodes + i] =
			    rf_control;
		}
	}

	/* Connect read old parity nodes to xor nodes. */
	for (i = 0; i < numParityNodes; i++)
		for (j = 0; j < numParityNodes; j++) {
			readParityNodes[i].succedents[numDataNodes + j] =
			    &xorNodes[j];
			xorNodes[j].antecedents[numDataNodes + i] =
			    &readParityNodes[i];
			xorNodes[j].antType[numDataNodes + i] = rf_trueData;
		}

	/* Connect xor nodes to write new parity nodes. */
	for (i = 0; i < numParityNodes; i++) {
		RF_ASSERT(xorNodes[i].numSuccedents == 1);
		RF_ASSERT(lpuNodes[i].numAntecedents == 1);
		xorNodes[i].succedents[0] = &lpuNodes[i];
		lpuNodes[i].antecedents[0] = &xorNodes[i];
		lpuNodes[i].antType[0] = rf_trueData;
	}

	for (i = 0; i < numDataNodes; i++) {
		if (lu_flag) {
			/* Connect write new data nodes to unlock nodes. */
			RF_ASSERT(writeDataNodes[i].numSuccedents == 1);
			RF_ASSERT(unlockDataNodes[i].numAntecedents == 1);
			writeDataNodes[i].succedents[0] = &unlockDataNodes[i];
			unlockDataNodes[i].antecedents[0] = &writeDataNodes[i];
			unlockDataNodes[i].antType[0] = rf_control;

			/* Connect unlock nodes to unblock node. */
			RF_ASSERT(unlockDataNodes[i].numSuccedents == 1);
			RF_ASSERT(unblockNode->numAntecedents ==
			          (numDataNodes + (nfaults * numParityNodes)));
			unlockDataNodes[i].succedents[0] = unblockNode;
			unblockNode->antecedents[i] = &unlockDataNodes[i];
			unblockNode->antType[i] = rf_control;
		} else {
			/* Connect write new data nodes to unblock node. */
			RF_ASSERT(writeDataNodes[i].numSuccedents == 1);
			RF_ASSERT(unblockNode->numAntecedents ==
			          (numDataNodes + (nfaults * numParityNodes)));
			writeDataNodes[i].succedents[0] = unblockNode;
			unblockNode->antecedents[i] = &writeDataNodes[i];
			unblockNode->antType[i] = rf_control;
		}
	}

	/* Connect write new parity nodes to unblock node. */
	for (i = 0; i < numParityNodes; i++) {
		RF_ASSERT(lpuNodes[i].numSuccedents == 1);
		lpuNodes[i].succedents[0] = unblockNode;
		unblockNode->antecedents[numDataNodes + i] = &lpuNodes[i];
		unblockNode->antType[numDataNodes + i] = rf_control;
	}

	/* Connect unblock node to terminator. */
	RF_ASSERT(unblockNode->numSuccedents == 1);
	RF_ASSERT(termNode->numAntecedents == 1);
	RF_ASSERT(termNode->numSuccedents == 0);
	unblockNode->succedents[0] = termNode;
	termNode->antecedents[0] = unblockNode;
	termNode->antType[0] = rf_control;
}


void
rf_CreateParityLoggingSmallWriteDAG(RF_Raid_t *raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList,
    RF_RedFuncs_t *pfuncs, RF_RedFuncs_t *qfuncs)
{
	dag_h->creator = "ParityLoggingSmallWriteDAG";
	rf_CommonCreateParityLoggingSmallWriteDAG(raidPtr, asmap, dag_h, bp,
	    flags, allocList, &rf_xorFuncs, NULL);
}


void
rf_CreateParityLoggingLargeWriteDAG(RF_Raid_t *raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList, int nfaults,
    int (*redFunc) (RF_DagNode_t *))
{
	dag_h->creator = "ParityLoggingSmallWriteDAG";
	rf_CommonCreateParityLoggingLargeWriteDAG(raidPtr, asmap, dag_h, bp,
	    flags, allocList, 1, rf_RegularXorFunc);
}
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.4
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_parityloggingdags.c,v 1.3 2000/01/11 18:02:22 peter Exp $	*/
@


1.3
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_parityloggingdags.c,v 1.2 1999/02/16 00:03:08 niklas Exp $	*/
d3 1
d33 1
a33 1
#if RF_INCLUDE_PARITYLOGGING > 0
d36 1
a36 1
  DAGs specific to parity logging are created here
d51 1
a51 1
/******************************************************************************
d53 1
a53 1
 * creates a DAG to perform a large-write operation:
d59 12
a70 9
 * The writes are not done until the reads complete because if they were done in
 * parallel, a failure on one of the reads could leave the parity in an inconsistent
 * state, so that the retry with a new DAG would produce erroneous parity.
 *
 * Note:  this DAG has the nasty property that none of the buffers allocated for reading
 *        old data can be freed until the XOR node fires.  Need to fix this.
 *
 * The last two arguments are the number of faults tolerated, and function for the
 * redundancy calculation. The undo for the redundancy calc is assumed to be null
d74 4
a77 9
void 
rf_CommonCreateParityLoggingLargeWriteDAG(
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList,
    int nfaults,
d80 3
a82 3
	RF_DagNode_t *nodes, *wndNodes, *rodNodes = NULL, *syncNode, *xorNode,
	       *lpoNode, *blockNode, *unblockNode, *termNode;
	int     nWndNodes, nRodNodes, i;
d85 1
a85 1
	int     nodeNum, asmNum;
d87 1
a87 1
	char   *sosBuffer, *eosBuffer;
d89 3
a91 1
	RF_StripeNum_t parityStripeID = rf_RaidAddressToParityStripeID(&(raidPtr->Layout), asmap->raidAddress, &which_ru);
d95 1
a95 1
	RF_ASSERT(nfaults == 1);/* this arch only single fault tolerant */
d98 1
a98 1
	/* alloc the Wnd nodes, the xor node, and the Lpo node */
d100 2
a101 1
	RF_CallocAndAdd(nodes, nWndNodes + 6, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
d122 2
a123 1
	rf_MapUnaccessedPortionOfStripe(raidPtr, layoutPtr, asmap, dag_h, new_asm_h, &nRodNodes, &sosBuffer, &eosBuffer, allocList);
d125 2
a126 1
		RF_CallocAndAdd(rodNodes, nRodNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
d128 12
a139 5
	/* begin node initialization */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, nRodNodes + 1, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(unblockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, 1, nWndNodes + 1, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(syncNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, nWndNodes + 1, nRodNodes + 1, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d141 1
a141 1
	/* initialize the Rod nodes */
d146 4
a149 1
				rf_InitNode(&rodNodes[nodeNum], rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rod", allocList);
d153 3
a155 1
				rodNodes[nodeNum].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d163 1
a163 1
	/* initialize the wnd nodes */
d166 3
a168 1
		rf_InitNode(&wndNodes[i], rf_wait, RF_TRUE, rf_DiskWriteFunc, rf_DiskWriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Wnd", allocList);
d173 2
a174 1
		wndNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d178 4
a181 2
	/* initialize the redundancy node */
	rf_InitNode(xorNode, rf_wait, RF_TRUE, redFunc, rf_NullNodeUndoFunc, NULL, 1, 1, 2 * (nWndNodes + nRodNodes) + 1, 1, dag_h, "Xr ", allocList);
d184 4
a187 2
		xorNode->params[2 * i + 0] = wndNodes[i].params[0];	/* pda */
		xorNode->params[2 * i + 1] = wndNodes[i].params[1];	/* buf ptr */
d190 4
a193 2
		xorNode->params[2 * (nWndNodes + i) + 0] = rodNodes[i].params[0];	/* pda */
		xorNode->params[2 * (nWndNodes + i) + 1] = rodNodes[i].params[1];	/* buf ptr */
d195 2
a196 2
	xorNode->params[2 * (nWndNodes + nRodNodes)].p = raidPtr;	/* xor node needs to get
									 * at RAID information */
d198 2
a199 1
	/* look for an Rod node that reads a complete SU.  If none, alloc a
d202 2
a203 1
	 * occurs. */
d205 2
a206 1
		if (((RF_PhysDiskAddr_t *) rodNodes[i].params[0].p)->numSector == raidPtr->Layout.sectorsPerStripeUnit)
d209 4
a212 1
		RF_CallocAndAdd(xorNode->results[0], 1, rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit), (void *), allocList);
d217 4
a220 2
	/* initialize the Lpo node */
	rf_InitNode(lpoNode, rf_wait, RF_FALSE, rf_ParityLogOverwriteFunc, rf_ParityLogOverwriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h, "Lpo", allocList);
d224 2
a225 3
	RF_ASSERT(asmap->parityInfo->next == NULL);	/* parityInfo must
							 * describe entire
							 * parity unit */
d227 1
a227 1
	/* connect nodes to form graph */
d229 1
a229 1
	/* connect dag header to block node */
d234 1
a234 1
	/* connect the block node to the Rod nodes */
d243 1
a243 1
	/* connect the block node to the sync node */
d250 1
a250 1
	/* connect the Rod nodes to the syncNode */
d257 1
a257 1
	/* connect the sync node to the xor node */
d262 1
a262 1
	xorNode->antType[0] = rf_trueData;	/* carry forward from sync */
d264 1
a264 1
	/* connect the sync node to the Wnd nodes */
d272 1
a272 1
	/* connect the xor node to the Lpo node */
d279 1
a279 1
	/* connect the Wnd nodes to the unblock node */
d288 1
a288 1
	/* connect the Lpo node to the unblock node */
d294 1
a294 1
	/* connect unblock node to terminator */
d304 1
a304 3


/******************************************************************************
d306 2
a307 1
 * creates a DAG to perform a small-write operation (either raid 5 or pq), which is as follows:
d309 16
a324 16
 *                                     Header
 *                                       |
 *                                     Block
 *                                 / |  ... \   \
 *                                /  |       \   \
 *                             Rod  Rod      Rod  Rop
 *                             | \ /| \    / |  \/ |
 *                             |    |        |  /\ |
 *                             Wnd  Wnd      Wnd   X
 *                              |    \       /     |
 *                              |     \     /      |
 *                               \     \   /      Lpo
 *                                \     \ /       /
 *                                 +-> Unblock <-+
 *                                       |
 *                                       T
d328 6
a333 4
 * When the access spans a stripe unit boundary and is less than one SU in size, there will
 * be two Rop -- X -- Wnp branches.  I call this the "double-XOR" case.
 * The second output from each Rod node goes to the X node.  In the double-XOR
 * case, there are exactly 2 Rod nodes, and each sends one output to one X node.
d336 2
a337 1
 * The block and unblock nodes are unused.  See comment above CreateFaultFreeReadDAG.
d339 5
a343 3
 * Note:  this DAG ignores all the optimizations related to making the RMWs atomic.
 *        it also has the nasty property that none of the buffers allocated for reading
 *        old data & parity can be freed until the XOR node fires.  Need to fix this.
d345 1
a345 1
 * A null qfuncs indicates single fault tolerant
d348 5
a352 10
void 
rf_CommonCreateParityLoggingSmallWriteDAG(
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList,
    RF_RedFuncs_t * pfuncs,
    RF_RedFuncs_t * qfuncs)
d359 3
a361 3
	int     numDataNodes = asmap->numStripeUnitsAccessed;
	int     numParityNodes = (asmap->parityInfo->next) ? 2 : 1;
	int     i, j, nNodes, totalNumNodes;
d363 8
a370 6
	int     (*func) (RF_DagNode_t * node), (*undoFunc) (RF_DagNode_t * node);
	int     (*qfunc) (RF_DagNode_t * node);
	char   *name, *qname;
	RF_StripeNum_t parityStripeID = rf_RaidAddressToParityStripeID(&(raidPtr->Layout), asmap->raidAddress, &which_ru);
	long    nfaults = qfuncs ? 2 : 1;
	int     lu_flag = (rf_enableAtomicRMW) ? 1 : 0;	/* lock/unlock flag */
d378 18
a395 11
	/* DAG creation occurs in three steps: 1. count the number of nodes in
	 * the DAG 2. create the nodes 3. initialize the nodes 4. connect the
	 * nodes */

	/* Step 1. compute number of nodes in the graph */

	/* number of nodes: a read and write for each data unit a redundancy
	 * computation node for each parity node a read and Lpu for each
	 * parity unit a block and unblock node (2) a terminator node if
	 * atomic RMW an unlock node for each data unit, redundancy unit */
	totalNumNodes = (2 * numDataNodes) + numParityNodes + (2 * numParityNodes) + 3;
d405 3
a407 2
	/* Step 2. create the nodes */
	RF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
d431 14
a444 9
	/* Step 3. initialize the nodes */
	/* initialize block node (Nil) */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, nNodes, 0, 0, 0, dag_h, "Nil", allocList);

	/* initialize unblock node (Nil) */
	rf_InitNode(unblockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, 1, nNodes, 0, 0, dag_h, "Nil", allocList);

	/* initialize terminatory node (Trm) */
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d446 1
a446 1
	/* initialize nodes which read old data (Rod) */
d448 3
a450 1
		rf_InitNode(&readDataNodes[i], rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc, nNodes, 1, 4, 0, dag_h, "Rod", allocList);
d452 4
a455 4
		readDataNodes[i].params[0].p = pda;	/* physical disk addr
							 * desc */
		readDataNodes[i].params[1].p = rf_AllocBuffer(raidPtr, dag_h, pda, allocList);	/* buffer to hold old
												 * data */
d457 3
a459 1
		readDataNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, lu_flag, 0, which_ru);
d465 1
a465 1
	/* initialize nodes which read old parity (Rop) */
d470 3
a472 1
		rf_InitNode(&readParityNodes[i], rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc, nNodes, 1, 4, 0, dag_h, "Rop", allocList);
d474 2
a475 2
		readParityNodes[i].params[1].p = rf_AllocBuffer(raidPtr, dag_h, pda, allocList);	/* buffer to hold old
													 * parity */
d477 2
a478 1
		readParityNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d483 1
a483 1
	/* initialize nodes which write new data (Wnd) */
d487 8
a494 5
		rf_InitNode(&writeDataNodes[i], rf_wait, RF_TRUE, rf_DiskWriteFunc, rf_DiskWriteUndoFunc, rf_GenericWakeupFunc, 1, nNodes, 4, 0, dag_h, "Wnd", allocList);
		writeDataNodes[i].params[0].p = pda;	/* physical disk addr
							 * desc */
		writeDataNodes[i].params[1].p = pda->bufPtr;	/* buffer holding new
								 * data to be written */
d496 2
a497 1
		writeDataNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d500 10
a509 5
			/* initialize node to unlock the disk queue */
			rf_InitNode(&unlockDataNodes[i], rf_wait, RF_FALSE, rf_DiskUnlockFunc, rf_DiskUnlockUndoFunc, rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h, "Und", allocList);
			unlockDataNodes[i].params[0].p = pda;	/* physical disk addr
								 * desc */
			unlockDataNodes[i].params[1].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, lu_flag, which_ru);
d515 4
a518 3
	/* initialize nodes which compute new parity */
	/* we use the simple XOR func in the double-XOR case, and when we're
	 * accessing only a portion of one stripe unit. the distinction
d523 5
a527 2
	 * the buffer. */
	if ((numParityNodes == 2) || ((numDataNodes == 1) && (asmap->totalSectorsAccessed < raidPtr->Layout.sectorsPerStripeUnit))) {
d544 5
a548 3
	/* initialize the xor nodes: params are {pda,buf} from {Rod,Wnd,Rop}
	 * nodes, and raidPtr  */
	if (numParityNodes == 2) {	/* double-xor case */
d550 3
a552 2
			rf_InitNode(&xorNodes[i], rf_wait, RF_TRUE, func, undoFunc, NULL, 1, nNodes, 7, 1, dag_h, name, allocList);	/* no wakeup func for
																	 * xor */
d561 2
a562 2
			xorNodes[i].results[0] = readParityNodes[i].params[1].p;	/* use old parity buf as
											 * target buf */
d565 5
a569 2
		/* there is only one xor node in this case */
		rf_InitNode(&xorNodes[0], rf_wait, RF_TRUE, func, undoFunc, NULL, 1, nNodes, (2 * (numDataNodes + numDataNodes + 1) + 1), 1, dag_h, name, allocList);
d572 5
a576 3
			/* set up params related to Rod and Rop nodes */
			xorNodes[0].params[2 * i + 0] = readDataNodes[i].params[0];	/* pda */
			xorNodes[0].params[2 * i + 1] = readDataNodes[i].params[1];	/* buffer pointer */
d579 5
a583 3
			/* set up params related to Wnd and Wnp nodes */
			xorNodes[0].params[2 * (numDataNodes + 1 + i) + 0] = writeDataNodes[i].params[0];	/* pda */
			xorNodes[0].params[2 * (numDataNodes + 1 + i) + 1] = writeDataNodes[i].params[1];	/* buffer pointer */
d585 2
a586 2
		xorNodes[0].params[2 * (numDataNodes + numDataNodes + 1)].p = raidPtr;	/* xor node needs to get
											 * at RAID information */
d590 1
a590 1
	/* initialize the log node(s) */
d594 6
a599 4
		rf_InitNode(&lpuNodes[i], rf_wait, RF_FALSE, rf_ParityLogUpdateFunc, rf_ParityLogUpdateUndoFunc, rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h, "Lpu", allocList);
		lpuNodes[i].params[0].p = pda;	/* PhysDiskAddr of parity */
		lpuNodes[i].params[1].p = xorNodes[i].results[0];	/* buffer pointer to
									 * parity */
d604 1
a604 1
	/* Step 4. connect the nodes */
d606 1
a606 1
	/* connect header to block node */
d611 1
a611 1
	/* connect block node to read old data nodes */
d620 1
a620 1
	/* connect block node to read old parity nodes */
d628 1
a628 1
	/* connect read old data nodes to write new data nodes */
d630 2
a631 1
		RF_ASSERT(readDataNodes[i].numSuccedents == numDataNodes + numParityNodes);
d633 2
a634 1
			RF_ASSERT(writeDataNodes[j].numAntecedents == numDataNodes + numParityNodes);
d644 1
a644 1
	/* connect read old data nodes to xor nodes */
d647 4
a650 2
			RF_ASSERT(xorNodes[j].numAntecedents == numDataNodes + numParityNodes);
			readDataNodes[i].succedents[numDataNodes + j] = &xorNodes[j];
d655 1
a655 1
	/* connect read old parity nodes to write new data nodes */
d657 2
a658 1
		RF_ASSERT(readParityNodes[i].numSuccedents == numDataNodes + numParityNodes);
d661 4
a664 2
			writeDataNodes[j].antecedents[numDataNodes + i] = &readParityNodes[i];
			writeDataNodes[j].antType[numDataNodes + i] = rf_control;
d668 1
a668 1
	/* connect read old parity nodes to xor nodes */
d671 4
a674 2
			readParityNodes[i].succedents[numDataNodes + j] = &xorNodes[j];
			xorNodes[j].antecedents[numDataNodes + i] = &readParityNodes[i];
d678 1
a678 1
	/* connect xor nodes to write new parity nodes */
d689 1
a689 1
			/* connect write new data nodes to unlock nodes */
d696 1
a696 1
			/* connect unlock nodes to unblock node */
d698 2
a699 1
			RF_ASSERT(unblockNode->numAntecedents == (numDataNodes + (nfaults * numParityNodes)));
d704 1
a704 1
			/* connect write new data nodes to unblock node */
d706 2
a707 1
			RF_ASSERT(unblockNode->numAntecedents == (numDataNodes + (nfaults * numParityNodes)));
d714 1
a714 1
	/* connect write new parity nodes to unblock node */
d722 1
a722 1
	/* connect unblock node to terminator */
d732 5
a736 10
void 
rf_CreateParityLoggingSmallWriteDAG(
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList,
    RF_RedFuncs_t * pfuncs,
    RF_RedFuncs_t * qfuncs)
d739 2
a740 1
	rf_CommonCreateParityLoggingSmallWriteDAG(raidPtr, asmap, dag_h, bp, flags, allocList, &rf_xorFuncs, NULL);
d744 4
a747 9
void 
rf_CreateParityLoggingLargeWriteDAG(
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList,
    int nfaults,
d751 2
a752 1
	rf_CommonCreateParityLoggingLargeWriteDAG(raidPtr, asmap, dag_h, bp, flags, allocList, 1, rf_RegularXorFunc);
d754 1
a754 1
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.3.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d32 1
a32 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d35 1
a35 1
 * DAGs specific to parity logging are created here.
d50 1
a50 1
/*****************************************************************************
d52 1
a52 1
 * Creates a DAG to perform a large-write operation:
d58 9
a66 12
 * The writes are not done until the reads complete because if they were done
 * in parallel, a failure on one of the reads could leave the parity in an
 * inconsistent state, so that the retry with a new DAG would produce
 * erroneous parity.
 *
 * Note:  This DAG has the nasty property that none of the buffers allocated
 *        for reading old data can be freed until the XOR node fires.
 *        Need to fix this.
 *
 * The last two arguments are the number of faults tolerated, and function
 * for the redundancy calculation. The undo for the redundancy calc is assumed
 * to be null.
d70 9
a78 4
void
rf_CommonCreateParityLoggingLargeWriteDAG(RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList, int nfaults,
d81 3
a83 3
	RF_DagNode_t *nodes, *wndNodes, *rodNodes = NULL, *syncNode, *xorNode;
	RF_DagNode_t *lpoNode, *blockNode, *unblockNode, *termNode;
	int nWndNodes, nRodNodes, i;
d86 1
a86 1
	int nodeNum, asmNum;
d88 1
a88 1
	char *sosBuffer, *eosBuffer;
d90 1
a90 3
	RF_StripeNum_t parityStripeID =
	    rf_RaidAddressToParityStripeID(&(raidPtr->Layout),
	     asmap->raidAddress, &which_ru);
d94 1
a94 1
	RF_ASSERT(nfaults == 1); /* This arch only single fault tolerant. */
d97 1
a97 1
	/* Alloc the Wnd nodes, the xor node, and the Lpo node. */
d99 1
a99 2
	RF_CallocAndAdd(nodes, nWndNodes + 6, sizeof(RF_DagNode_t),
	    (RF_DagNode_t *), allocList);
d120 1
a120 2
	rf_MapUnaccessedPortionOfStripe(raidPtr, layoutPtr, asmap, dag_h,
	    new_asm_h, &nRodNodes, &sosBuffer, &eosBuffer, allocList);
d122 1
a122 2
		RF_CallocAndAdd(rodNodes, nRodNodes, sizeof(RF_DagNode_t),
		    (RF_DagNode_t *), allocList);
d124 5
a128 12
	/* Begin node initialization. */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nRodNodes + 1, 0, 0, 0, dag_h,
	    "Nil", allocList);
	rf_InitNode(unblockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, nWndNodes + 1, 0, 0, dag_h,
	    "Nil", allocList);
	rf_InitNode(syncNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nWndNodes + 1, nRodNodes + 1,
	    0, 0, dag_h, "Nil", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d130 1
a130 1
	/* Initialize the Rod nodes. */
d135 1
a135 4
				rf_InitNode(&rodNodes[nodeNum], rf_wait,
				    RF_FALSE, rf_DiskReadFunc,
				    rf_DiskReadUndoFunc, rf_GenericWakeupFunc,
				    1, 1, 4, 0, dag_h, "Rod", allocList);
d139 1
a139 3
				rodNodes[nodeNum].params[3].v =
				    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
				     0, 0, which_ru);
d147 1
a147 1
	/* Initialize the wnd nodes. */
d150 1
a150 3
		rf_InitNode(&wndNodes[i], rf_wait, RF_TRUE, rf_DiskWriteFunc,
		    rf_DiskWriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Wnd", allocList);
d155 1
a155 2
		wndNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d159 2
a160 4
	/* Initialize the redundancy node. */
	rf_InitNode(xorNode, rf_wait, RF_TRUE, redFunc, rf_NullNodeUndoFunc,
	    NULL, 1, 1, 2 * (nWndNodes + nRodNodes) + 1, 1, dag_h,
	    "Xr ", allocList);
d163 2
a164 4
		/* pda */
		xorNode->params[2 * i + 0] = wndNodes[i].params[0];
		/* buf ptr */
		xorNode->params[2 * i + 1] = wndNodes[i].params[1];
d167 2
a168 4
		xorNode->params[2 * (nWndNodes + i) + 0] =
		    rodNodes[i].params[0];	/* pda */
		xorNode->params[2 * (nWndNodes + i) + 1] =
		    rodNodes[i].params[1];	/* buf ptr */
d170 2
a171 2
	/* Xor node needs to get at RAID information. */
	xorNode->params[2 * (nWndNodes + nRodNodes)].p = raidPtr;
d173 1
a173 2
	/*
	 * Look for an Rod node that reads a complete SU. If none, alloc a
d176 1
a176 2
	 * occurs.
	 */
d178 1
a178 2
		if (((RF_PhysDiskAddr_t *) rodNodes[i].params[0].p)
		    ->numSector == raidPtr->Layout.sectorsPerStripeUnit)
d181 1
a181 4
		RF_CallocAndAdd(xorNode->results[0], 1,
		    rf_RaidAddressToByte(raidPtr,
		     raidPtr->Layout.sectorsPerStripeUnit), (void *),
		    allocList);
d186 2
a187 4
	/* Initialize the Lpo node. */
	rf_InitNode(lpoNode, rf_wait, RF_FALSE, rf_ParityLogOverwriteFunc,
	    rf_ParityLogOverwriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 2, 0,
	    dag_h, "Lpo", allocList);
d191 3
a193 2
	/* parityInfo must describe entire parity unit. */
	RF_ASSERT(asmap->parityInfo->next == NULL);
d195 1
a195 1
	/* Connect nodes to form graph. */
d197 1
a197 1
	/* Connect dag header to block node. */
d202 1
a202 1
	/* Connect the block node to the Rod nodes. */
d211 1
a211 1
	/* Connect the block node to the sync node. */
d218 1
a218 1
	/* Connect the Rod nodes to the syncNode. */
d225 1
a225 1
	/* Connect the sync node to the xor node. */
d230 1
a230 1
	xorNode->antType[0] = rf_trueData;	/* Carry forward from sync. */
d232 1
a232 1
	/* Connect the sync node to the Wnd nodes. */
d240 1
a240 1
	/* Connect the xor node to the Lpo node. */
d247 1
a247 1
	/* Connect the Wnd nodes to the unblock node. */
d256 1
a256 1
	/* Connect the Lpo node to the unblock node. */
d262 1
a262 1
	/* Connect unblock node to terminator. */
d272 3
a274 1
/*****************************************************************************
d276 1
a276 2
 * Creates a DAG to perform a small-write operation (either raid 5 or pq),
 * which is as follows:
d278 16
a293 16
 *				       Header
 *				          |
 *				        Block
 *				    / |  ... \   \
 *				   /  |       \   \
 *				Rod  Rod      Rod  Rop
 *				 | \ /| \    / |  \/ |
 *				 |    |        |  /\ |
 *				Wnd  Wnd      Wnd   X
 *				 |    \       /     |
 *				 |     \     /      |
 *				  \     \   /      Lpo
 *				   \     \ /       /
 *				    +-> Unblock <-+
 *				          |
 *				          T
d297 4
a300 6
 * When the access spans a stripe unit boundary and is less than one SU in
 * size, there will be two Rop -- X -- Wnp branches. I call this the
 * "double-XOR" case.
 * The second output from each Rod node goes to the X node. In the double-XOR
 * case, there are exactly 2 Rod nodes, and each sends one output to one X
 * node.
d303 1
a303 2
 * The block and unblock nodes are unused. See comment above
 * CreateFaultFreeReadDAG.
d305 3
a307 5
 * Note:  This DAG ignores all the optimizations related to making the RMWs
 *        atomic.
 *        It also has the nasty property that none of the buffers allocated
 *        for reading old data & parity can be freed until the XOR node fires.
 *        Need to fix this.
d309 1
a309 1
 * A null qfuncs indicates single fault tolerant.
d312 10
a321 5
void
rf_CommonCreateParityLoggingSmallWriteDAG(RF_Raid_t *raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList,
    RF_RedFuncs_t *pfuncs, RF_RedFuncs_t *qfuncs)
d328 3
a330 3
	int numDataNodes = asmap->numStripeUnitsAccessed;
	int numParityNodes = (asmap->parityInfo->next) ? 2 : 1;
	int i, j, nNodes, totalNumNodes;
d332 6
a337 8
	int (*func) (RF_DagNode_t * node), (*undoFunc) (RF_DagNode_t * node);
	int (*qfunc) (RF_DagNode_t * node);
	char*name, *qname;
	RF_StripeNum_t parityStripeID =
	    rf_RaidAddressToParityStripeID(&(raidPtr->Layout),
	     asmap->raidAddress, &which_ru);
	long nfaults = qfuncs ? 2 : 1;
	int lu_flag = (rf_enableAtomicRMW) ? 1 : 0;	/* Lock/unlock flag. */
d345 11
a355 18
	/*
	 * DAG creation occurs in three steps:
	 * 1. Count the number of nodes in the DAG.
	 * 2. Create the nodes.
	 * 3. Initialize the nodes.
	 * 4. Connect the nodes.
	 */

	/* Step 1. Compute number of nodes in the graph. */

	/*
	 * Number of nodes: a read and write for each data unit, a redundancy
	 * computation node for each parity node, a read and Lpu for each
	 * parity unit, a block and unblock node (2), a terminator node if
	 * atomic RMW, an unlock node for each data and redundancy unit.
	 */
	totalNumNodes = (2 * numDataNodes) + numParityNodes +
	    (2 * numParityNodes) + 3;
d365 2
a366 3
	/* Step 2. Create the nodes. */
	RF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),
	    (RF_DagNode_t *), allocList);
d390 9
a398 14
	/* Step 3. Initialize the nodes. */
	/* Initialize block node (Nil). */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nNodes, 0, 0, 0, dag_h,
	    "Nil", allocList);

	/* Initialize unblock node (Nil). */
	rf_InitNode(unblockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, nNodes, 0, 0, dag_h,
	    "Nil", allocList);

	/* Initialize terminatory node (Trm). */
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d400 1
a400 1
	/* Initialize nodes which read old data (Rod). */
d402 1
a402 3
		rf_InitNode(&readDataNodes[i], rf_wait, RF_FALSE,
		    rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc,
		    nNodes, 1, 4, 0, dag_h, "Rod", allocList);
d404 4
a407 4
		/* Physical disk addr desc. */
		readDataNodes[i].params[0].p = pda;
		readDataNodes[i].params[1].p = rf_AllocBuffer(raidPtr, dag_h,
		    pda, allocList);	/* Buffer to hold old data. */
d409 1
a409 3
		readDataNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, lu_flag,
		    0, which_ru);
d415 1
a415 1
	/* Initialize nodes which read old parity (Rop). */
d420 1
a420 3
		rf_InitNode(&readParityNodes[i], rf_wait, RF_FALSE,
		    rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc,
		    nNodes, 1, 4, 0, dag_h, "Rop", allocList);
d422 2
a423 2
		readParityNodes[i].params[1].p = rf_AllocBuffer(raidPtr, dag_h,
		    pda, allocList);	/* Buffer to hold old parity. */
d425 1
a425 2
		readParityNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d430 1
a430 1
	/* Initialize nodes which write new data (Wnd). */
d434 5
a438 8
		rf_InitNode(&writeDataNodes[i], rf_wait, RF_TRUE,
		    rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
		    rf_GenericWakeupFunc, 1, nNodes, 4, 0, dag_h,
		    "Wnd", allocList);
		/* Physical disk addr desc. */
		writeDataNodes[i].params[0].p = pda;
		/* Buffer holding new data to be written. */
		writeDataNodes[i].params[1].p = pda->bufPtr;
d440 1
a440 2
		writeDataNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d443 5
a447 10
			/* Initialize node to unlock the disk queue. */
			rf_InitNode(&unlockDataNodes[i], rf_wait, RF_FALSE,
			    rf_DiskUnlockFunc, rf_DiskUnlockUndoFunc,
			    rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h,
			    "Und", allocList);
			/* Physical disk addr desc. */
			unlockDataNodes[i].params[0].p = pda;
			unlockDataNodes[i].params[1].v =
			    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0,
			    lu_flag, which_ru);
d453 3
a455 4
	/* Initialize nodes which compute new parity. */
	/*
	 * We use the simple XOR func in the double-XOR case, and when we're
	 * accessing only a portion of one stripe unit. The distinction
d460 2
a461 5
	 * the buffer.
	 */
	if ((numParityNodes == 2) || ((numDataNodes == 1) &&
	    (asmap->totalSectorsAccessed <
	     raidPtr->Layout.sectorsPerStripeUnit))) {
d478 3
a480 5
	/*
	 * Initialize the xor nodes: params are {pda,buf} from {Rod,Wnd,Rop}
	 * nodes, and raidPtr.
	 */
	if (numParityNodes == 2) {	/* Double-XOR case. */
d482 2
a483 3
			rf_InitNode(&xorNodes[i], rf_wait, RF_TRUE, func,
			    undoFunc, NULL, 1, nNodes, 7, 1, dag_h, name,
			    allocList);	/* No wakeup func for XOR. */
d492 2
a493 2
			/* Use old parity buf as target buf. */
			xorNodes[i].results[0] = readParityNodes[i].params[1].p;
d496 2
a497 5
		/* There is only one xor node in this case. */
		rf_InitNode(&xorNodes[0], rf_wait, RF_TRUE, func, undoFunc,
		    NULL, 1, nNodes,
		    (2 * (numDataNodes + numDataNodes + 1) + 1), 1,
		    dag_h, name, allocList);
d500 3
a502 5
			/* Set up params related to Rod and Rop nodes. */
			xorNodes[0].params[2 * i + 0] =
			    readDataNodes[i].params[0];	/* pda */
			xorNodes[0].params[2 * i + 1] =
			    readDataNodes[i].params[1];	/* Buffer pointer */
d505 3
a507 5
			/* Set up params related to Wnd and Wnp nodes. */
			xorNodes[0].params[2 * (numDataNodes + 1 + i) + 0] =
			    writeDataNodes[i].params[0]; /* pda */
			xorNodes[0].params[2 * (numDataNodes + 1 + i) + 1] =
			    writeDataNodes[i].params[1]; /* Buffer pointer */
d509 2
a510 2
		xorNodes[0].params[2 * (numDataNodes + numDataNodes + 1)].p =
		    raidPtr;	/* Xor node needs to get at RAID information. */
d514 1
a514 1
	/* Initialize the log node(s). */
d518 4
a521 6
		rf_InitNode(&lpuNodes[i], rf_wait, RF_FALSE,
		    rf_ParityLogUpdateFunc, rf_ParityLogUpdateUndoFunc,
		    rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h, "Lpu", allocList);
		lpuNodes[i].params[0].p = pda;	/* PhysDiskAddr of parity. */
		/* Buffer pointer to parity. */
		lpuNodes[i].params[1].p = xorNodes[i].results[0];
d526 1
a526 1
	/* Step 4. Connect the nodes. */
d528 1
a528 1
	/* Connect header to block node. */
d533 1
a533 1
	/* Connect block node to read old data nodes. */
d542 1
a542 1
	/* Connect block node to read old parity nodes. */
d550 1
a550 1
	/* Connect read old data nodes to write new data nodes. */
d552 1
a552 2
		RF_ASSERT(readDataNodes[i].numSuccedents ==
		          numDataNodes + numParityNodes);
d554 1
a554 2
			RF_ASSERT(writeDataNodes[j].numAntecedents ==
			          numDataNodes + numParityNodes);
d564 1
a564 1
	/* Connect read old data nodes to xor nodes. */
d567 2
a568 4
			RF_ASSERT(xorNodes[j].numAntecedents ==
			          numDataNodes + numParityNodes);
			readDataNodes[i].succedents[numDataNodes + j] =
			    &xorNodes[j];
d573 1
a573 1
	/* Connect read old parity nodes to write new data nodes. */
d575 1
a575 2
		RF_ASSERT(readParityNodes[i].numSuccedents ==
		          numDataNodes + numParityNodes);
d578 2
a579 4
			writeDataNodes[j].antecedents[numDataNodes + i] =
			    &readParityNodes[i];
			writeDataNodes[j].antType[numDataNodes + i] =
			    rf_control;
d583 1
a583 1
	/* Connect read old parity nodes to xor nodes. */
d586 2
a587 4
			readParityNodes[i].succedents[numDataNodes + j] =
			    &xorNodes[j];
			xorNodes[j].antecedents[numDataNodes + i] =
			    &readParityNodes[i];
d591 1
a591 1
	/* Connect xor nodes to write new parity nodes. */
d602 1
a602 1
			/* Connect write new data nodes to unlock nodes. */
d609 1
a609 1
			/* Connect unlock nodes to unblock node. */
d611 1
a611 2
			RF_ASSERT(unblockNode->numAntecedents ==
			          (numDataNodes + (nfaults * numParityNodes)));
d616 1
a616 1
			/* Connect write new data nodes to unblock node. */
d618 1
a618 2
			RF_ASSERT(unblockNode->numAntecedents ==
			          (numDataNodes + (nfaults * numParityNodes)));
d625 1
a625 1
	/* Connect write new parity nodes to unblock node. */
d633 1
a633 1
	/* Connect unblock node to terminator. */
d643 10
a652 5
void
rf_CreateParityLoggingSmallWriteDAG(RF_Raid_t *raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList,
    RF_RedFuncs_t *pfuncs, RF_RedFuncs_t *qfuncs)
d655 1
a655 2
	rf_CommonCreateParityLoggingSmallWriteDAG(raidPtr, asmap, dag_h, bp,
	    flags, allocList, &rf_xorFuncs, NULL);
d659 9
a667 4
void
rf_CreateParityLoggingLargeWriteDAG(RF_Raid_t *raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList, int nfaults,
d671 1
a671 2
	rf_CommonCreateParityLoggingLargeWriteDAG(raidPtr, asmap, dag_h, bp,
	    flags, allocList, 1, rf_RegularXorFunc);
d673 1
a673 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.3.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d32 1
a32 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d35 1
a35 1
 * DAGs specific to parity logging are created here.
d50 1
a50 1
/*****************************************************************************
d52 1
a52 1
 * Creates a DAG to perform a large-write operation:
d58 9
a66 12
 * The writes are not done until the reads complete because if they were done
 * in parallel, a failure on one of the reads could leave the parity in an
 * inconsistent state, so that the retry with a new DAG would produce
 * erroneous parity.
 *
 * Note:  This DAG has the nasty property that none of the buffers allocated
 *        for reading old data can be freed until the XOR node fires.
 *        Need to fix this.
 *
 * The last two arguments are the number of faults tolerated, and function
 * for the redundancy calculation. The undo for the redundancy calc is assumed
 * to be null.
d70 9
a78 4
void
rf_CommonCreateParityLoggingLargeWriteDAG(RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList, int nfaults,
d81 3
a83 3
	RF_DagNode_t *nodes, *wndNodes, *rodNodes = NULL, *syncNode, *xorNode;
	RF_DagNode_t *lpoNode, *blockNode, *unblockNode, *termNode;
	int nWndNodes, nRodNodes, i;
d86 1
a86 1
	int nodeNum, asmNum;
d88 1
a88 1
	char *sosBuffer, *eosBuffer;
d90 1
a90 3
	RF_StripeNum_t parityStripeID =
	    rf_RaidAddressToParityStripeID(&(raidPtr->Layout),
	     asmap->raidAddress, &which_ru);
d94 1
a94 1
	RF_ASSERT(nfaults == 1); /* This arch only single fault tolerant. */
d97 1
a97 1
	/* Alloc the Wnd nodes, the xor node, and the Lpo node. */
d99 1
a99 2
	RF_CallocAndAdd(nodes, nWndNodes + 6, sizeof(RF_DagNode_t),
	    (RF_DagNode_t *), allocList);
d120 1
a120 2
	rf_MapUnaccessedPortionOfStripe(raidPtr, layoutPtr, asmap, dag_h,
	    new_asm_h, &nRodNodes, &sosBuffer, &eosBuffer, allocList);
d122 1
a122 2
		RF_CallocAndAdd(rodNodes, nRodNodes, sizeof(RF_DagNode_t),
		    (RF_DagNode_t *), allocList);
d124 5
a128 12
	/* Begin node initialization. */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nRodNodes + 1, 0, 0, 0, dag_h,
	    "Nil", allocList);
	rf_InitNode(unblockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, nWndNodes + 1, 0, 0, dag_h,
	    "Nil", allocList);
	rf_InitNode(syncNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nWndNodes + 1, nRodNodes + 1,
	    0, 0, dag_h, "Nil", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d130 1
a130 1
	/* Initialize the Rod nodes. */
d135 1
a135 4
				rf_InitNode(&rodNodes[nodeNum], rf_wait,
				    RF_FALSE, rf_DiskReadFunc,
				    rf_DiskReadUndoFunc, rf_GenericWakeupFunc,
				    1, 1, 4, 0, dag_h, "Rod", allocList);
d139 1
a139 3
				rodNodes[nodeNum].params[3].v =
				    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
				     0, 0, which_ru);
d147 1
a147 1
	/* Initialize the wnd nodes. */
d150 1
a150 3
		rf_InitNode(&wndNodes[i], rf_wait, RF_TRUE, rf_DiskWriteFunc,
		    rf_DiskWriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Wnd", allocList);
d155 1
a155 2
		wndNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d159 2
a160 4
	/* Initialize the redundancy node. */
	rf_InitNode(xorNode, rf_wait, RF_TRUE, redFunc, rf_NullNodeUndoFunc,
	    NULL, 1, 1, 2 * (nWndNodes + nRodNodes) + 1, 1, dag_h,
	    "Xr ", allocList);
d163 2
a164 4
		/* pda */
		xorNode->params[2 * i + 0] = wndNodes[i].params[0];
		/* buf ptr */
		xorNode->params[2 * i + 1] = wndNodes[i].params[1];
d167 2
a168 4
		xorNode->params[2 * (nWndNodes + i) + 0] =
		    rodNodes[i].params[0];	/* pda */
		xorNode->params[2 * (nWndNodes + i) + 1] =
		    rodNodes[i].params[1];	/* buf ptr */
d170 2
a171 2
	/* Xor node needs to get at RAID information. */
	xorNode->params[2 * (nWndNodes + nRodNodes)].p = raidPtr;
d173 1
a173 2
	/*
	 * Look for an Rod node that reads a complete SU. If none, alloc a
d176 1
a176 2
	 * occurs.
	 */
d178 1
a178 2
		if (((RF_PhysDiskAddr_t *) rodNodes[i].params[0].p)
		    ->numSector == raidPtr->Layout.sectorsPerStripeUnit)
d181 1
a181 4
		RF_CallocAndAdd(xorNode->results[0], 1,
		    rf_RaidAddressToByte(raidPtr,
		     raidPtr->Layout.sectorsPerStripeUnit), (void *),
		    allocList);
d186 2
a187 4
	/* Initialize the Lpo node. */
	rf_InitNode(lpoNode, rf_wait, RF_FALSE, rf_ParityLogOverwriteFunc,
	    rf_ParityLogOverwriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 2, 0,
	    dag_h, "Lpo", allocList);
d191 3
a193 2
	/* parityInfo must describe entire parity unit. */
	RF_ASSERT(asmap->parityInfo->next == NULL);
d195 1
a195 1
	/* Connect nodes to form graph. */
d197 1
a197 1
	/* Connect dag header to block node. */
d202 1
a202 1
	/* Connect the block node to the Rod nodes. */
d211 1
a211 1
	/* Connect the block node to the sync node. */
d218 1
a218 1
	/* Connect the Rod nodes to the syncNode. */
d225 1
a225 1
	/* Connect the sync node to the xor node. */
d230 1
a230 1
	xorNode->antType[0] = rf_trueData;	/* Carry forward from sync. */
d232 1
a232 1
	/* Connect the sync node to the Wnd nodes. */
d240 1
a240 1
	/* Connect the xor node to the Lpo node. */
d247 1
a247 1
	/* Connect the Wnd nodes to the unblock node. */
d256 1
a256 1
	/* Connect the Lpo node to the unblock node. */
d262 1
a262 1
	/* Connect unblock node to terminator. */
d272 3
a274 1
/*****************************************************************************
d276 1
a276 2
 * Creates a DAG to perform a small-write operation (either raid 5 or pq),
 * which is as follows:
d278 16
a293 16
 *				       Header
 *				          |
 *				        Block
 *				    / |  ... \   \
 *				   /  |       \   \
 *				Rod  Rod      Rod  Rop
 *				 | \ /| \    / |  \/ |
 *				 |    |        |  /\ |
 *				Wnd  Wnd      Wnd   X
 *				 |    \       /     |
 *				 |     \     /      |
 *				  \     \   /      Lpo
 *				   \     \ /       /
 *				    +-> Unblock <-+
 *				          |
 *				          T
d297 4
a300 6
 * When the access spans a stripe unit boundary and is less than one SU in
 * size, there will be two Rop -- X -- Wnp branches. I call this the
 * "double-XOR" case.
 * The second output from each Rod node goes to the X node. In the double-XOR
 * case, there are exactly 2 Rod nodes, and each sends one output to one X
 * node.
d303 1
a303 2
 * The block and unblock nodes are unused. See comment above
 * CreateFaultFreeReadDAG.
d305 3
a307 5
 * Note:  This DAG ignores all the optimizations related to making the RMWs
 *        atomic.
 *        It also has the nasty property that none of the buffers allocated
 *        for reading old data & parity can be freed until the XOR node fires.
 *        Need to fix this.
d309 1
a309 1
 * A null qfuncs indicates single fault tolerant.
d312 10
a321 5
void
rf_CommonCreateParityLoggingSmallWriteDAG(RF_Raid_t *raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList,
    RF_RedFuncs_t *pfuncs, RF_RedFuncs_t *qfuncs)
d328 3
a330 3
	int numDataNodes = asmap->numStripeUnitsAccessed;
	int numParityNodes = (asmap->parityInfo->next) ? 2 : 1;
	int i, j, nNodes, totalNumNodes;
d332 6
a337 8
	int (*func) (RF_DagNode_t * node), (*undoFunc) (RF_DagNode_t * node);
	int (*qfunc) (RF_DagNode_t * node);
	char*name, *qname;
	RF_StripeNum_t parityStripeID =
	    rf_RaidAddressToParityStripeID(&(raidPtr->Layout),
	     asmap->raidAddress, &which_ru);
	long nfaults = qfuncs ? 2 : 1;
	int lu_flag = (rf_enableAtomicRMW) ? 1 : 0;	/* Lock/unlock flag. */
d345 11
a355 18
	/*
	 * DAG creation occurs in three steps:
	 * 1. Count the number of nodes in the DAG.
	 * 2. Create the nodes.
	 * 3. Initialize the nodes.
	 * 4. Connect the nodes.
	 */

	/* Step 1. Compute number of nodes in the graph. */

	/*
	 * Number of nodes: a read and write for each data unit, a redundancy
	 * computation node for each parity node, a read and Lpu for each
	 * parity unit, a block and unblock node (2), a terminator node if
	 * atomic RMW, an unlock node for each data and redundancy unit.
	 */
	totalNumNodes = (2 * numDataNodes) + numParityNodes +
	    (2 * numParityNodes) + 3;
d365 2
a366 3
	/* Step 2. Create the nodes. */
	RF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),
	    (RF_DagNode_t *), allocList);
d390 9
a398 14
	/* Step 3. Initialize the nodes. */
	/* Initialize block node (Nil). */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nNodes, 0, 0, 0, dag_h,
	    "Nil", allocList);

	/* Initialize unblock node (Nil). */
	rf_InitNode(unblockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, nNodes, 0, 0, dag_h,
	    "Nil", allocList);

	/* Initialize terminatory node (Trm). */
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d400 1
a400 1
	/* Initialize nodes which read old data (Rod). */
d402 1
a402 3
		rf_InitNode(&readDataNodes[i], rf_wait, RF_FALSE,
		    rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc,
		    nNodes, 1, 4, 0, dag_h, "Rod", allocList);
d404 4
a407 4
		/* Physical disk addr desc. */
		readDataNodes[i].params[0].p = pda;
		readDataNodes[i].params[1].p = rf_AllocBuffer(raidPtr, dag_h,
		    pda, allocList);	/* Buffer to hold old data. */
d409 1
a409 3
		readDataNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, lu_flag,
		    0, which_ru);
d415 1
a415 1
	/* Initialize nodes which read old parity (Rop). */
d420 1
a420 3
		rf_InitNode(&readParityNodes[i], rf_wait, RF_FALSE,
		    rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc,
		    nNodes, 1, 4, 0, dag_h, "Rop", allocList);
d422 2
a423 2
		readParityNodes[i].params[1].p = rf_AllocBuffer(raidPtr, dag_h,
		    pda, allocList);	/* Buffer to hold old parity. */
d425 1
a425 2
		readParityNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d430 1
a430 1
	/* Initialize nodes which write new data (Wnd). */
d434 5
a438 8
		rf_InitNode(&writeDataNodes[i], rf_wait, RF_TRUE,
		    rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
		    rf_GenericWakeupFunc, 1, nNodes, 4, 0, dag_h,
		    "Wnd", allocList);
		/* Physical disk addr desc. */
		writeDataNodes[i].params[0].p = pda;
		/* Buffer holding new data to be written. */
		writeDataNodes[i].params[1].p = pda->bufPtr;
d440 1
a440 2
		writeDataNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d443 5
a447 10
			/* Initialize node to unlock the disk queue. */
			rf_InitNode(&unlockDataNodes[i], rf_wait, RF_FALSE,
			    rf_DiskUnlockFunc, rf_DiskUnlockUndoFunc,
			    rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h,
			    "Und", allocList);
			/* Physical disk addr desc. */
			unlockDataNodes[i].params[0].p = pda;
			unlockDataNodes[i].params[1].v =
			    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0,
			    lu_flag, which_ru);
d453 3
a455 4
	/* Initialize nodes which compute new parity. */
	/*
	 * We use the simple XOR func in the double-XOR case, and when we're
	 * accessing only a portion of one stripe unit. The distinction
d460 2
a461 5
	 * the buffer.
	 */
	if ((numParityNodes == 2) || ((numDataNodes == 1) &&
	    (asmap->totalSectorsAccessed <
	     raidPtr->Layout.sectorsPerStripeUnit))) {
d478 3
a480 5
	/*
	 * Initialize the xor nodes: params are {pda,buf} from {Rod,Wnd,Rop}
	 * nodes, and raidPtr.
	 */
	if (numParityNodes == 2) {	/* Double-XOR case. */
d482 2
a483 3
			rf_InitNode(&xorNodes[i], rf_wait, RF_TRUE, func,
			    undoFunc, NULL, 1, nNodes, 7, 1, dag_h, name,
			    allocList);	/* No wakeup func for XOR. */
d492 2
a493 2
			/* Use old parity buf as target buf. */
			xorNodes[i].results[0] = readParityNodes[i].params[1].p;
d496 2
a497 5
		/* There is only one xor node in this case. */
		rf_InitNode(&xorNodes[0], rf_wait, RF_TRUE, func, undoFunc,
		    NULL, 1, nNodes,
		    (2 * (numDataNodes + numDataNodes + 1) + 1), 1,
		    dag_h, name, allocList);
d500 3
a502 5
			/* Set up params related to Rod and Rop nodes. */
			xorNodes[0].params[2 * i + 0] =
			    readDataNodes[i].params[0];	/* pda */
			xorNodes[0].params[2 * i + 1] =
			    readDataNodes[i].params[1];	/* Buffer pointer */
d505 3
a507 5
			/* Set up params related to Wnd and Wnp nodes. */
			xorNodes[0].params[2 * (numDataNodes + 1 + i) + 0] =
			    writeDataNodes[i].params[0]; /* pda */
			xorNodes[0].params[2 * (numDataNodes + 1 + i) + 1] =
			    writeDataNodes[i].params[1]; /* Buffer pointer */
d509 2
a510 2
		xorNodes[0].params[2 * (numDataNodes + numDataNodes + 1)].p =
		    raidPtr;	/* Xor node needs to get at RAID information. */
d514 1
a514 1
	/* Initialize the log node(s). */
d518 4
a521 6
		rf_InitNode(&lpuNodes[i], rf_wait, RF_FALSE,
		    rf_ParityLogUpdateFunc, rf_ParityLogUpdateUndoFunc,
		    rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h, "Lpu", allocList);
		lpuNodes[i].params[0].p = pda;	/* PhysDiskAddr of parity. */
		/* Buffer pointer to parity. */
		lpuNodes[i].params[1].p = xorNodes[i].results[0];
d526 1
a526 1
	/* Step 4. Connect the nodes. */
d528 1
a528 1
	/* Connect header to block node. */
d533 1
a533 1
	/* Connect block node to read old data nodes. */
d542 1
a542 1
	/* Connect block node to read old parity nodes. */
d550 1
a550 1
	/* Connect read old data nodes to write new data nodes. */
d552 1
a552 2
		RF_ASSERT(readDataNodes[i].numSuccedents ==
		          numDataNodes + numParityNodes);
d554 1
a554 2
			RF_ASSERT(writeDataNodes[j].numAntecedents ==
			          numDataNodes + numParityNodes);
d564 1
a564 1
	/* Connect read old data nodes to xor nodes. */
d567 2
a568 4
			RF_ASSERT(xorNodes[j].numAntecedents ==
			          numDataNodes + numParityNodes);
			readDataNodes[i].succedents[numDataNodes + j] =
			    &xorNodes[j];
d573 1
a573 1
	/* Connect read old parity nodes to write new data nodes. */
d575 1
a575 2
		RF_ASSERT(readParityNodes[i].numSuccedents ==
		          numDataNodes + numParityNodes);
d578 2
a579 4
			writeDataNodes[j].antecedents[numDataNodes + i] =
			    &readParityNodes[i];
			writeDataNodes[j].antType[numDataNodes + i] =
			    rf_control;
d583 1
a583 1
	/* Connect read old parity nodes to xor nodes. */
d586 2
a587 4
			readParityNodes[i].succedents[numDataNodes + j] =
			    &xorNodes[j];
			xorNodes[j].antecedents[numDataNodes + i] =
			    &readParityNodes[i];
d591 1
a591 1
	/* Connect xor nodes to write new parity nodes. */
d602 1
a602 1
			/* Connect write new data nodes to unlock nodes. */
d609 1
a609 1
			/* Connect unlock nodes to unblock node. */
d611 1
a611 2
			RF_ASSERT(unblockNode->numAntecedents ==
			          (numDataNodes + (nfaults * numParityNodes)));
d616 1
a616 1
			/* Connect write new data nodes to unblock node. */
d618 1
a618 2
			RF_ASSERT(unblockNode->numAntecedents ==
			          (numDataNodes + (nfaults * numParityNodes)));
d625 1
a625 1
	/* Connect write new parity nodes to unblock node. */
d633 1
a633 1
	/* Connect unblock node to terminator. */
d643 10
a652 5
void
rf_CreateParityLoggingSmallWriteDAG(RF_Raid_t *raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList,
    RF_RedFuncs_t *pfuncs, RF_RedFuncs_t *qfuncs)
d655 1
a655 2
	rf_CommonCreateParityLoggingSmallWriteDAG(raidPtr, asmap, dag_h, bp,
	    flags, allocList, &rf_xorFuncs, NULL);
d659 9
a667 4
void
rf_CreateParityLoggingLargeWriteDAG(RF_Raid_t *raidPtr,
    RF_AccessStripeMap_t *asmap, RF_DagHeader_t *dag_h, void *bp,
    RF_RaidAccessFlags_t flags, RF_AllocListElem_t *allocList, int nfaults,
d671 1
a671 2
	rf_CommonCreateParityLoggingLargeWriteDAG(raidPtr, asmap, dag_h, bp,
	    flags, allocList, 1, rf_RegularXorFunc);
d673 1
a673 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_parityloggingdags.c,v 1.1 1999/01/11 14:29:37 niklas Exp $	*/
/*	$NetBSD: rf_parityloggingdags.c,v 1.3 1999/02/05 00:06:14 oster Exp $	*/
a42 1
#include "rf_threadid.h"
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_parityloggingdags.c,v 1.1 1998/11/13 04:20:32 oster Exp $	*/
/*	$NetBSD: rf_parityloggingdags.c,v 1.1 1998/11/13 04:20:32 oster Exp $	*/
a29 115
/*
 * Log: rf_parityloggingdags.c,v 
 * Revision 1.27  1996/07/28 20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.26  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.25  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.24  1996/06/11  13:47:21  jimz
 * fix up for in-kernel compilation
 *
 * Revision 1.23  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.22  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.21  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.20  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.19  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.18  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.17  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.16  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.15  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.14  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.13  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.12  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.11  1996/05/03  19:42:02  wvcii
 * added includes for dag library
 *
 * Revision 1.10  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.9  1995/12/06  20:55:24  wvcii
 * added prototyping
 * fixed bug in dag header numSuccedents count for both small and large dags
 *
 * Revision 1.8  1995/11/30  16:08:01  wvcii
 * added copyright info
 *
 * Revision 1.7  1995/11/07  15:29:05  wvcii
 * reorganized code, adding comments and asserts
 * dag creation routines now generate term node
 * encoded commit point, barrier, and antecedence types into dags
 *
 * Revision 1.6  1995/09/07  15:52:06  jimz
 * noop compile when INCLUDE_PARITYLOGGING not defined
 *
 * Revision 1.5  1995/06/15  13:51:53  robby
 * updated some wrong prototypes (after prototyping rf_dagutils.h)
 *
 * Revision 1.4  1995/06/09  13:15:05  wvcii
 * code is now nonblocking
 *
 * Revision 1.3  95/05/31  13:09:14  wvcii
 * code debug
 * 
 * Revision 1.2  1995/05/21  15:34:14  wvcii
 * code debug
 *
 * Revision 1.1  95/05/16  14:36:53  wvcii
 * Initial revision
 * 
 *
 */

d71 10
a80 9
void rf_CommonCreateParityLoggingLargeWriteDAG(
  RF_Raid_t              *raidPtr,
  RF_AccessStripeMap_t   *asmap,
  RF_DagHeader_t         *dag_h,
  void                   *bp,
  RF_RaidAccessFlags_t    flags,
  RF_AllocListElem_t     *allocList,
  int                     nfaults,
  int                   (*redFunc)(RF_DagNode_t *))
d82 188
a269 177
  RF_DagNode_t *nodes, *wndNodes, *rodNodes=NULL, *syncNode, *xorNode, *lpoNode, *blockNode, *unblockNode, *termNode;
  int nWndNodes, nRodNodes, i;
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  RF_AccessStripeMapHeader_t *new_asm_h[2];
  int nodeNum, asmNum;
  RF_ReconUnitNum_t which_ru;
  char *sosBuffer, *eosBuffer;
  RF_PhysDiskAddr_t *pda;
  RF_StripeNum_t parityStripeID = rf_RaidAddressToParityStripeID(&(raidPtr->Layout), asmap->raidAddress, &which_ru);

  if (rf_dagDebug)
    printf("[Creating parity-logging large-write DAG]\n");
  RF_ASSERT(nfaults == 1); /* this arch only single fault tolerant */
  dag_h->creator = "ParityLoggingLargeWriteDAG";

  /* alloc the Wnd nodes, the xor node, and the Lpo node */
  nWndNodes = asmap->numStripeUnitsAccessed;
  RF_CallocAndAdd(nodes, nWndNodes + 6, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
  i = 0;
  wndNodes    = &nodes[i]; i += nWndNodes;
  xorNode     = &nodes[i]; i += 1;
  lpoNode     = &nodes[i]; i += 1;
  blockNode   = &nodes[i]; i += 1;
  syncNode    = &nodes[i]; i += 1;
  unblockNode = &nodes[i]; i += 1;
  termNode    = &nodes[i]; i += 1;

  dag_h->numCommitNodes = nWndNodes + 1;
  dag_h->numCommits = 0;
  dag_h->numSuccedents = 1;

  rf_MapUnaccessedPortionOfStripe(raidPtr, layoutPtr, asmap, dag_h, new_asm_h, &nRodNodes, &sosBuffer, &eosBuffer, allocList);
  if (nRodNodes > 0)
    RF_CallocAndAdd(rodNodes, nRodNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);

  /* begin node initialization */
  rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, nRodNodes + 1, 0, 0, 0, dag_h, "Nil", allocList);
  rf_InitNode(unblockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, 1, nWndNodes + 1, 0, 0, dag_h, "Nil", allocList);
  rf_InitNode(syncNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, nWndNodes + 1, nRodNodes + 1, 0, 0, dag_h, "Nil", allocList);
  rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);

  /* initialize the Rod nodes */
  for (nodeNum = asmNum = 0; asmNum < 2; asmNum++) {
    if (new_asm_h[asmNum]) {
      pda = new_asm_h[asmNum]->stripeMap->physInfo;
      while (pda) {
	rf_InitNode(&rodNodes[nodeNum], rf_wait, RF_FALSE, rf_DiskReadFunc,rf_DiskReadUndoFunc,rf_GenericWakeupFunc,1,1,4,0, dag_h, "Rod", allocList);
	rodNodes[nodeNum].params[0].p = pda;
	rodNodes[nodeNum].params[1].p = pda->bufPtr;
	rodNodes[nodeNum].params[2].v = parityStripeID;
	rodNodes[nodeNum].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
	nodeNum++;
	pda=pda->next;
      }
    }
  }
  RF_ASSERT(nodeNum == nRodNodes);

  /* initialize the wnd nodes */
  pda = asmap->physInfo;
  for (i=0; i < nWndNodes; i++) {
    rf_InitNode(&wndNodes[i], rf_wait, RF_TRUE, rf_DiskWriteFunc, rf_DiskWriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Wnd", allocList);
    RF_ASSERT(pda != NULL);
    wndNodes[i].params[0].p = pda;
    wndNodes[i].params[1].p = pda->bufPtr;
    wndNodes[i].params[2].v = parityStripeID;
    wndNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
    pda = pda->next;
  }

  /* initialize the redundancy node */
  rf_InitNode(xorNode, rf_wait, RF_TRUE, redFunc, rf_NullNodeUndoFunc, NULL, 1, 1, 2*(nWndNodes+nRodNodes)+1, 1, dag_h, "Xr ", allocList);
  xorNode->flags |= RF_DAGNODE_FLAG_YIELD;
  for (i=0; i < nWndNodes; i++) {
    xorNode->params[2*i+0] = wndNodes[i].params[0];         /* pda */
    xorNode->params[2*i+1] = wndNodes[i].params[1];         /* buf ptr */
  }
  for (i=0; i < nRodNodes; i++) {
    xorNode->params[2*(nWndNodes+i)+0] = rodNodes[i].params[0];         /* pda */
    xorNode->params[2*(nWndNodes+i)+1] = rodNodes[i].params[1];         /* buf ptr */
  }
  xorNode->params[2*(nWndNodes+nRodNodes)].p = raidPtr;  /* xor node needs to get at RAID information */
  
  /* look for an Rod node that reads a complete SU.  If none, alloc a buffer to receive the parity info.
   * Note that we can't use a new data buffer because it will not have gotten written when the xor occurs.
   */
  for (i = 0; i < nRodNodes; i++)
    if (((RF_PhysDiskAddr_t *) rodNodes[i].params[0].p)->numSector == raidPtr->Layout.sectorsPerStripeUnit)
      break;
  if (i == nRodNodes) {
    RF_CallocAndAdd(xorNode->results[0], 1, rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit), (void *), allocList);
  }
  else {
    xorNode->results[0] = rodNodes[i].params[1].p;
  }

  /* initialize the Lpo node */
  rf_InitNode(lpoNode, rf_wait, RF_FALSE, rf_ParityLogOverwriteFunc, rf_ParityLogOverwriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h, "Lpo", allocList);

  lpoNode->params[0].p = asmap->parityInfo;
  lpoNode->params[1].p = xorNode->results[0];
  RF_ASSERT(asmap->parityInfo->next == NULL);        /* parityInfo must describe entire parity unit */

  /* connect nodes to form graph */

  /* connect dag header to block node */
  RF_ASSERT(dag_h->numSuccedents == 1);
  RF_ASSERT(blockNode->numAntecedents == 0);
  dag_h->succedents[0] = blockNode;

  /* connect the block node to the Rod nodes */
  RF_ASSERT(blockNode->numSuccedents == nRodNodes + 1);
  for (i = 0; i < nRodNodes; i++) {
    RF_ASSERT(rodNodes[i].numAntecedents == 1);
    blockNode->succedents[i] = &rodNodes[i];
    rodNodes[i].antecedents[0] = blockNode;
    rodNodes[i].antType[0] = rf_control;
  }

  /* connect the block node to the sync node */
  /* necessary if nRodNodes == 0 */
  RF_ASSERT(syncNode->numAntecedents == nRodNodes + 1);
  blockNode->succedents[nRodNodes] = syncNode;
  syncNode->antecedents[0] = blockNode;
  syncNode->antType[0] = rf_control;

  /* connect the Rod nodes to the syncNode */
  for (i = 0; i < nRodNodes; i++) {
    rodNodes[i].succedents[0] = syncNode;
    syncNode->antecedents[1 + i] = &rodNodes[i];
    syncNode->antType[1 + i] = rf_control;
  }

  /* connect the sync node to the xor node */
  RF_ASSERT(syncNode->numSuccedents == nWndNodes + 1);
  RF_ASSERT(xorNode->numAntecedents == 1);
  syncNode->succedents[0] = xorNode;
  xorNode->antecedents[0] = syncNode;
  xorNode->antType[0] = rf_trueData; /* carry forward from sync */

  /* connect the sync node to the Wnd nodes */
  for (i = 0; i < nWndNodes; i++) {
    RF_ASSERT(wndNodes->numAntecedents == 1);
    syncNode->succedents[1 + i] = &wndNodes[i];
    wndNodes[i].antecedents[0] = syncNode;
    wndNodes[i].antType[0] = rf_control;
  }

  /* connect the xor node to the Lpo node */
  RF_ASSERT(xorNode->numSuccedents == 1);
  RF_ASSERT(lpoNode->numAntecedents == 1);
  xorNode->succedents[0] = lpoNode;
  lpoNode->antecedents[0]= xorNode;
  lpoNode->antType[0] = rf_trueData;

  /* connect the Wnd nodes to the unblock node */
  RF_ASSERT(unblockNode->numAntecedents == nWndNodes + 1);
  for (i = 0; i < nWndNodes; i++) {
    RF_ASSERT(wndNodes->numSuccedents == 1);
    wndNodes[i].succedents[0] = unblockNode;
    unblockNode->antecedents[i] = &wndNodes[i];
    unblockNode->antType[i] = rf_control;
  }

  /* connect the Lpo node to the unblock node */
  RF_ASSERT(lpoNode->numSuccedents == 1);
  lpoNode->succedents[0] = unblockNode;
  unblockNode->antecedents[nWndNodes] = lpoNode;
  unblockNode->antType[nWndNodes] = rf_control;

  /* connect unblock node to terminator */
  RF_ASSERT(unblockNode->numSuccedents == 1);
  RF_ASSERT(termNode->numAntecedents == 1);
  RF_ASSERT(termNode->numSuccedents == 0);
  unblockNode->succedents[0] = termNode;
  termNode->antecedents[0] = unblockNode;
  termNode->antType[0] = rf_control;
d282 2
a283 2
 *                                 / |  ... \   \    
 *                                /  |       \   \   
d285 5
a289 5
 *                             | \ /| \    / |  \/ | 
 *                             |    |        |  /\ | 
 *                             Wnd  Wnd      Wnd   X 
 *                              |    \       /     | 
 *                              |     \     /      | 
d291 2
a292 2
 *                                \     \ /       /  
 *                                 +-> Unblock <-+   
d295 1
a295 1
 *                                        
d313 10
a322 9
void rf_CommonCreateParityLoggingSmallWriteDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList,
  RF_RedFuncs_t         *pfuncs,
  RF_RedFuncs_t         *qfuncs)
d324 317
a640 294
  RF_DagNode_t *xorNodes, *blockNode, *unblockNode, *nodes;
  RF_DagNode_t *readDataNodes, *readParityNodes;
  RF_DagNode_t *writeDataNodes, *lpuNodes;
  RF_DagNode_t *unlockDataNodes=NULL, *termNode;
  RF_PhysDiskAddr_t *pda = asmap->physInfo;
  int numDataNodes = asmap->numStripeUnitsAccessed;
  int numParityNodes = (asmap->parityInfo->next) ? 2 : 1;
  int i, j, nNodes, totalNumNodes;
  RF_ReconUnitNum_t which_ru;
  int (*func)(RF_DagNode_t *node), (*undoFunc)(RF_DagNode_t *node);
  int (*qfunc)(RF_DagNode_t *node);
  char *name, *qname;
  RF_StripeNum_t parityStripeID = rf_RaidAddressToParityStripeID(&(raidPtr->Layout), asmap->raidAddress, &which_ru);
  long nfaults = qfuncs ? 2 : 1;
  int lu_flag = (rf_enableAtomicRMW) ? 1 : 0;          /* lock/unlock flag */

  if (rf_dagDebug) printf("[Creating parity-logging small-write DAG]\n");
  RF_ASSERT(numDataNodes > 0);
  RF_ASSERT(nfaults == 1);
  dag_h->creator = "ParityLoggingSmallWriteDAG";

  /* DAG creation occurs in three steps:
     1. count the number of nodes in the DAG
     2. create the nodes
     3. initialize the nodes
     4. connect the nodes
   */

  /* Step 1. compute number of nodes in the graph */

  /* number of nodes:
      a read and write for each data unit
      a redundancy computation node for each parity node
      a read and Lpu for each parity unit
      a block and unblock node (2)
      a terminator node
      if atomic RMW
        an unlock node for each data unit, redundancy unit
  */
  totalNumNodes = (2 * numDataNodes) + numParityNodes + (2 * numParityNodes) + 3;
  if (lu_flag)
    totalNumNodes += numDataNodes;

  nNodes     = numDataNodes + numParityNodes;

  dag_h->numCommitNodes = numDataNodes + numParityNodes;
  dag_h->numCommits = 0;
  dag_h->numSuccedents = 1;

  /* Step 2. create the nodes */
  RF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
  i = 0;
  blockNode         = &nodes[i]; i += 1;
  unblockNode       = &nodes[i]; i += 1;
  readDataNodes     = &nodes[i]; i += numDataNodes;
  readParityNodes   = &nodes[i]; i += numParityNodes;
  writeDataNodes    = &nodes[i]; i += numDataNodes;
  lpuNodes          = &nodes[i]; i += numParityNodes;
  xorNodes          = &nodes[i]; i += numParityNodes;
  termNode          = &nodes[i]; i += 1;
  if (lu_flag) {
    unlockDataNodes = &nodes[i]; i += numDataNodes;
  }
  RF_ASSERT(i == totalNumNodes);
  
  /* Step 3. initialize the nodes */
  /* initialize block node (Nil) */
  rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, nNodes, 0, 0, 0, dag_h, "Nil", allocList);

  /* initialize unblock node (Nil) */
  rf_InitNode(unblockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, 1, nNodes, 0, 0, dag_h, "Nil", allocList);

  /* initialize terminatory node (Trm) */
  rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);

  /* initialize nodes which read old data (Rod) */
  for (i = 0; i < numDataNodes; i++) {
    rf_InitNode(&readDataNodes[i], rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc, nNodes, 1, 4, 0, dag_h, "Rod", allocList);
    RF_ASSERT(pda != NULL);
    readDataNodes[i].params[0].p = pda; /* physical disk addr desc */
    readDataNodes[i].params[1].p = rf_AllocBuffer(raidPtr, dag_h, pda, allocList);  /* buffer to hold old data */
    readDataNodes[i].params[2].v = parityStripeID;
    readDataNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, lu_flag, 0, which_ru);
    pda=pda->next;
    readDataNodes[i].propList[0] = NULL;
    readDataNodes[i].propList[1] = NULL;
  }

  /* initialize nodes which read old parity (Rop) */
  pda = asmap->parityInfo; i = 0;
  for (i = 0; i < numParityNodes; i++) {
    RF_ASSERT(pda != NULL);
    rf_InitNode(&readParityNodes[i], rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc, nNodes, 1, 4, 0, dag_h, "Rop", allocList);
    readParityNodes[i].params[0].p = pda;
    readParityNodes[i].params[1].p = rf_AllocBuffer(raidPtr, dag_h, pda, allocList);    /* buffer to hold old parity */
    readParityNodes[i].params[2].v = parityStripeID;
    readParityNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
    readParityNodes[i].propList[0] = NULL;
    pda=pda->next;
  }

  /* initialize nodes which write new data (Wnd) */
  pda = asmap->physInfo;
  for (i=0; i < numDataNodes; i++) {
    RF_ASSERT(pda != NULL);
    rf_InitNode(&writeDataNodes[i], rf_wait, RF_TRUE, rf_DiskWriteFunc, rf_DiskWriteUndoFunc, rf_GenericWakeupFunc, 1, nNodes, 4, 0, dag_h, "Wnd", allocList);
    writeDataNodes[i].params[0].p = pda;                    /* physical disk addr desc */
    writeDataNodes[i].params[1].p = pda->bufPtr;   /* buffer holding new data to be written */
    writeDataNodes[i].params[2].v = parityStripeID;
    writeDataNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);

    if (lu_flag) {
      /* initialize node to unlock the disk queue */
      rf_InitNode(&unlockDataNodes[i], rf_wait, RF_FALSE, rf_DiskUnlockFunc, rf_DiskUnlockUndoFunc, rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h, "Und", allocList);
      unlockDataNodes[i].params[0].p = pda; /* physical disk addr desc */
      unlockDataNodes[i].params[1].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, lu_flag, which_ru);
    }
    pda = pda->next;
  }


  /* initialize nodes which compute new parity */
  /* we use the simple XOR func in the double-XOR case, and when we're accessing only a portion of one stripe unit.
   * the distinction between the two is that the regular XOR func assumes that the targbuf is a full SU in size,
   * and examines the pda associated with the buffer to decide where within the buffer to XOR the data, whereas
   * the simple XOR func just XORs the data into the start of the buffer.
   */
  if ((numParityNodes==2) || ((numDataNodes == 1) && (asmap->totalSectorsAccessed < raidPtr->Layout.sectorsPerStripeUnit))) {
    func = pfuncs->simple; undoFunc = rf_NullNodeUndoFunc; name = pfuncs->SimpleName;
    if (qfuncs)
      { qfunc = qfuncs->simple; qname = qfuncs->SimpleName;}
  } else {
    func = pfuncs->regular; undoFunc = rf_NullNodeUndoFunc; name = pfuncs->RegularName;
    if (qfuncs) { qfunc = qfuncs->regular; qname = qfuncs->RegularName;}
  }
  /* initialize the xor nodes: params are {pda,buf} from {Rod,Wnd,Rop} nodes, and raidPtr  */
  if (numParityNodes==2) {        /* double-xor case */
    for (i=0; i < numParityNodes; i++) {
      rf_InitNode(&xorNodes[i], rf_wait, RF_TRUE, func, undoFunc, NULL, 1, nNodes, 7, 1, dag_h, name, allocList);  /* no wakeup func for xor */
      xorNodes[i].flags |= RF_DAGNODE_FLAG_YIELD;
      xorNodes[i].params[0] = readDataNodes[i].params[0];
      xorNodes[i].params[1] = readDataNodes[i].params[1];
      xorNodes[i].params[2] = readParityNodes[i].params[0];
      xorNodes[i].params[3] = readParityNodes[i].params[1];
      xorNodes[i].params[4] = writeDataNodes[i].params[0];
      xorNodes[i].params[5] = writeDataNodes[i].params[1];
      xorNodes[i].params[6].p = raidPtr;
      xorNodes[i].results[0] = readParityNodes[i].params[1].p;   /* use old parity buf as target buf */
    }
  }
  else {
    /* there is only one xor node in this case */
    rf_InitNode(&xorNodes[0], rf_wait, RF_TRUE, func, undoFunc, NULL, 1, nNodes, (2 * (numDataNodes + numDataNodes + 1) + 1), 1, dag_h, name, allocList);
    xorNodes[0].flags |= RF_DAGNODE_FLAG_YIELD;
    for (i=0; i < numDataNodes + 1; i++) {
      /* set up params related to Rod and Rop nodes */
      xorNodes[0].params[2*i+0] = readDataNodes[i].params[0];    /* pda */
      xorNodes[0].params[2*i+1] = readDataNodes[i].params[1];    /* buffer pointer */
    }
    for (i=0; i < numDataNodes; i++) {
      /* set up params related to Wnd and Wnp nodes */
      xorNodes[0].params[2*(numDataNodes+1+i)+0] = writeDataNodes[i].params[0]; /* pda */
      xorNodes[0].params[2*(numDataNodes+1+i)+1] = writeDataNodes[i].params[1]; /* buffer pointer */
    }
    xorNodes[0].params[2*(numDataNodes+numDataNodes+1)].p = raidPtr;  /* xor node needs to get at RAID information */
    xorNodes[0].results[0] = readParityNodes[0].params[1].p;
  }

  /* initialize the log node(s) */
  pda = asmap->parityInfo;
  for (i = 0;  i < numParityNodes; i++) {
    RF_ASSERT(pda);
    rf_InitNode(&lpuNodes[i], rf_wait, RF_FALSE, rf_ParityLogUpdateFunc, rf_ParityLogUpdateUndoFunc, rf_GenericWakeupFunc, 1, 1, 2, 0, dag_h, "Lpu", allocList);
    lpuNodes[i].params[0].p = pda;                    /* PhysDiskAddr of parity */
    lpuNodes[i].params[1].p = xorNodes[i].results[0]; /* buffer pointer to parity */
    pda = pda->next;
  }
  

  /* Step 4. connect the nodes */

  /* connect header to block node */
  RF_ASSERT(dag_h->numSuccedents == 1);
  RF_ASSERT(blockNode->numAntecedents == 0);
  dag_h->succedents[0] = blockNode;

  /* connect block node to read old data nodes */
  RF_ASSERT(blockNode->numSuccedents == (numDataNodes + numParityNodes));
  for (i = 0; i < numDataNodes; i++) {
    blockNode->succedents[i] = &readDataNodes[i];
    RF_ASSERT(readDataNodes[i].numAntecedents == 1);
    readDataNodes[i].antecedents[0]= blockNode;
    readDataNodes[i].antType[0] = rf_control;
  }
  
  /* connect block node to read old parity nodes */
  for (i = 0; i < numParityNodes; i++) {
    blockNode->succedents[numDataNodes + i] = &readParityNodes[i];
    RF_ASSERT(readParityNodes[i].numAntecedents == 1);
    readParityNodes[i].antecedents[0] = blockNode;
    readParityNodes[i].antType[0] = rf_control;
  }

  /* connect read old data nodes to write new data nodes */
  for (i = 0; i < numDataNodes; i++) {
    RF_ASSERT(readDataNodes[i].numSuccedents == numDataNodes + numParityNodes);
    for (j = 0; j < numDataNodes; j++) {
      RF_ASSERT(writeDataNodes[j].numAntecedents == numDataNodes + numParityNodes);
      readDataNodes[i].succedents[j] = &writeDataNodes[j];
      writeDataNodes[j].antecedents[i] = &readDataNodes[i];
      if (i == j)
	writeDataNodes[j].antType[i] = rf_antiData;
      else
	writeDataNodes[j].antType[i] = rf_control;
    }
  }

  /* connect read old data nodes to xor nodes */
  for (i = 0; i < numDataNodes; i++)
    for (j = 0; j < numParityNodes; j++){
      RF_ASSERT(xorNodes[j].numAntecedents == numDataNodes + numParityNodes);
      readDataNodes[i].succedents[numDataNodes + j] = &xorNodes[j];
      xorNodes[j].antecedents[i] = &readDataNodes[i];
      xorNodes[j].antType[i] = rf_trueData;
    }

  /* connect read old parity nodes to write new data nodes */
  for (i = 0; i < numParityNodes; i++) {
    RF_ASSERT(readParityNodes[i].numSuccedents == numDataNodes + numParityNodes);
    for (j = 0; j < numDataNodes; j++) {
      readParityNodes[i].succedents[j] = &writeDataNodes[j];
      writeDataNodes[j].antecedents[numDataNodes + i] = &readParityNodes[i];
      writeDataNodes[j].antType[numDataNodes + i] = rf_control;
    }
  }

  /* connect read old parity nodes to xor nodes */
  for (i = 0; i < numParityNodes; i++)
    for (j = 0; j < numParityNodes; j++) {
      readParityNodes[i].succedents[numDataNodes + j] = &xorNodes[j];
      xorNodes[j].antecedents[numDataNodes + i] = &readParityNodes[i];
      xorNodes[j].antType[numDataNodes + i] = rf_trueData;
    }

  /* connect xor nodes to write new parity nodes */
  for (i = 0; i < numParityNodes; i++) {
    RF_ASSERT(xorNodes[i].numSuccedents == 1);
    RF_ASSERT(lpuNodes[i].numAntecedents == 1);
    xorNodes[i].succedents[0] = &lpuNodes[i];
    lpuNodes[i].antecedents[0] = &xorNodes[i];
    lpuNodes[i].antType[0] = rf_trueData;
  }

  for (i = 0; i < numDataNodes; i++) {
    if (lu_flag) {
      /* connect write new data nodes to unlock nodes */
      RF_ASSERT(writeDataNodes[i].numSuccedents == 1);
      RF_ASSERT(unlockDataNodes[i].numAntecedents == 1);
      writeDataNodes[i].succedents[0] = &unlockDataNodes[i];
      unlockDataNodes[i].antecedents[0] = &writeDataNodes[i];
      unlockDataNodes[i].antType[0] = rf_control;

      /* connect unlock nodes to unblock node */
      RF_ASSERT(unlockDataNodes[i].numSuccedents == 1);
      RF_ASSERT(unblockNode->numAntecedents == (numDataNodes + (nfaults * numParityNodes)));
      unlockDataNodes[i].succedents[0] = unblockNode;
      unblockNode->antecedents[i] = &unlockDataNodes[i];
      unblockNode->antType[i] = rf_control;
    }
    else {
      /* connect write new data nodes to unblock node */
      RF_ASSERT(writeDataNodes[i].numSuccedents == 1);
      RF_ASSERT(unblockNode->numAntecedents == (numDataNodes + (nfaults * numParityNodes)));
      writeDataNodes[i].succedents[0] = unblockNode;
      unblockNode->antecedents[i] = &writeDataNodes[i];
      unblockNode->antType[i] = rf_control;
    }
  }

  /* connect write new parity nodes to unblock node */
  for (i = 0; i < numParityNodes; i++) {
    RF_ASSERT(lpuNodes[i].numSuccedents == 1);
    lpuNodes[i].succedents[0] = unblockNode;
    unblockNode->antecedents[numDataNodes + i] = &lpuNodes[i];
    unblockNode->antType[numDataNodes + i] = rf_control;
  }

  /* connect unblock node to terminator */
  RF_ASSERT(unblockNode->numSuccedents == 1);
  RF_ASSERT(termNode->numAntecedents == 1);
  RF_ASSERT(termNode->numSuccedents == 0);
  unblockNode->succedents[0] = termNode;
  termNode->antecedents[0] = unblockNode;
  termNode->antType[0] = rf_control;
d644 10
a653 9
void rf_CreateParityLoggingSmallWriteDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList,
  RF_RedFuncs_t         *pfuncs,
  RF_RedFuncs_t         *qfuncs)
d655 2
a656 2
  dag_h->creator = "ParityLoggingSmallWriteDAG";
  rf_CommonCreateParityLoggingSmallWriteDAG(raidPtr, asmap, dag_h, bp, flags, allocList, &rf_xorFuncs, NULL);
d660 10
a669 9
void rf_CreateParityLoggingLargeWriteDAG(
  RF_Raid_t              *raidPtr,
  RF_AccessStripeMap_t   *asmap,
  RF_DagHeader_t         *dag_h,
  void                   *bp,
  RF_RaidAccessFlags_t    flags,
  RF_AllocListElem_t     *allocList,
  int                     nfaults,
  int                   (*redFunc)(RF_DagNode_t *))
d671 2
a672 2
  dag_h->creator = "ParityLoggingSmallWriteDAG";
  rf_CommonCreateParityLoggingLargeWriteDAG(raidPtr, asmap, dag_h, bp, flags, allocList, 1, rf_RegularXorFunc);
d674 1
a674 2

#endif /* RF_INCLUDE_PARITYLOGGING > 0 */
@

