head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.38
	OPENBSD_5_0:1.5.0.36
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.34
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.32
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.28
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.10
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.5;

1.5
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.09.17.20.07;	author fgsch;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.08.04.13.10.54;	author peter;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.16.00.02.47;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.24;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_geniq.c,v 1.5 2002/12/16 07:01:04 tdeval Exp $	*/
/*	$NetBSD: rf_geniq.c,v 1.3 1999/02/05 00:06:12 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Daniel Stodolsky
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * rf_geniq.c -- Code which implements Reed-Solomon encoding for RAID level 6.
 */


#define	RF_UTILITY	1
#include "rf_pqdeg.h"

/*
 * five bit lfsr
 * poly - feedback connections
 *
 * val  = value;
 */
int
lsfr_shift(unsigned val, unsigned poly)
{
	unsigned new;
	unsigned int i;
	unsigned high = (val >> 4) & 1;
	unsigned bit;

	new = (poly & 1) ? high : 0;

	for (i = 1; i <= 4; i++) {
		bit = (val >> (i - 1)) & 1;
		if (poly & (1 << i))	/* There is a feedback connection. */
			new = new | ((bit ^ high) << i);
		else
			new = new | (bit << i);
	}
	return new;
}


/* Generate Q matrices for the data. */

RF_ua32_t rf_qfor[32];

int
main(void)
{
	unsigned int i, j, l, a, b;
	unsigned int val;
	unsigned int r;
	unsigned int m, p, q;

	RF_ua32_t k;

	printf("/*\n");
	printf(" * rf_invertq.h\n");
	printf(" */\n");
	printf("/*\n");
	printf(" * GENERATED FILE -- DO NOT EDIT\n");
	printf(" */\n");
	printf("\n");
	printf("#ifndef\t_RF__RF_INVERTQ_H_\n");
	printf("#define\t_RF__RF_INVERTQ_H_\n");
	printf("\n");
	printf("/*\n");
	printf(" * rf_geniq.c must include rf_archs.h before including\n");
	printf(" * this file (to get VPATH magic right with the way we\n");
	printf(" * generate this file in kernel trees).\n");
	printf(" */\n");
	printf("/* #include \"rf_archs.h\" */\n");
	printf("\n");
	printf("#if\t(RF_INCLUDE_PQ > 0) || (RF_INCLUDE_RAID6 > 0)\n");
	printf("\n");
	printf("#define\tRF_Q_COLS\t32\n");
	printf("RF_ua32_t rf_rn = {");
	k[0] = 1;
	for (j = 0; j < 31; j++)
		k[j + 1] = lsfr_shift(k[j], 5);
	for (j = 0; j < 32; j++)
		printf("%d, ", k[j]);
	printf("};\n");

	printf("RF_ua32_t rf_qfor[32] = {\n");
	for (i = 0; i < 32; i++) {
		printf("/* i = %d */\t{0, ", i);
		rf_qfor[i][0] = 0;
		for (j = 1; j < 32; j++) {
			val = j;
			for (l = 0; l < i; l++)
				val = lsfr_shift(val, 5);
			rf_qfor[i][j] = val;
			printf("%d, ", val);
		}
		printf("},\n");
	}
	printf("};\n");
	printf("#define\tRF_Q_DATA_COL(col_num)\trf_rn[col_num],"
	    " rf_qfor[28-(col_num)]\n");

	/* generate the inverse tables. (i,j,p,q) */
	/* The table just stores a. Get b back from the parity */
	printf("#ifdef\t_KERNEL\n");
	printf("RF_ua1024_t rf_qinv[1];\t/* don't compile monster table"
	    " into kernel */\n");
	printf("#elif\tdefined(NO_PQ)\n");
	printf("RF_ua1024_t rf_qinv[29*29];\n");
	printf("#else\t/* !_KERNEL && NO_PQ */\n");
	printf("RF_ua1024_t rf_qinv[29*29] = {\n");
	for (i = 0; i < 29; i++) {
		for (j = 0; j < 29; j++) {
			printf("/* i %d, j %d */\t{", i, j);
			if (i == j)
				for (l = 0; l < 1023; l++)
					printf("0, ");
			else {
				for (p = 0; p < 32; p++)
					for (q = 0; q < 32; q++) {
						/*
						 * What are a, b such that a ^
						 * b == p; and qfor[(28-i)][a
						 * ^ rf_rn[i+1]] ^
						 * qfor[(28-j)][b ^
						 * rf_rn[j+1]] == q. Solve by
						 * guessing a. Then testing.
						 */
						for (a = 0; a < 32; a++) {
							b = a ^ p;
							if ((rf_qfor[28 - i]
							     [a ^ k[i + 1]] ^
							    rf_qfor[28 - j]
							     [b ^ k[j + 1]]) ==
							    q)
								break;
						}
						if (a == 32)
							printf("unable to solve"
							    " %d %d %d %d\n",
							    i, j, p, q);
						printf("%d, ", a);
					}
			}
			printf("},\n");
		}
	}
	printf("};\n");
	printf("\n#endif\t/* (RF_INCLUDE_PQ > 0) || (RF_INCLUDE_RAID6 > 0) */"
	    "\n\n");
	printf("#endif\t/* !_KERNEL && NO_PQ */\n");
	printf("#endif\t/* !_RF__RF_INVERTQ_H_ */\n");
	exit(0);
}
@


1.5
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_geniq.c,v 1.4 2001/07/09 17:20:07 fgsch Exp $	*/
@


1.4
log
@More lame OpenBSD tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
d31 2
a32 2
/* rf_geniq.c
 *  code which implements Reed-Solomon encoding for RAID level 6
d36 1
a36 1
#define RF_UTILITY 1
d40 7
a46 8
   five bit lfsr
   poly - feedback connections

   val  = value;
*/
int 
lsfr_shift(val, poly)
	unsigned val, poly;
d57 1
a57 1
		if (poly & (1 << i))	/* there is a feedback connection */
d64 3
a66 1
/* generate Q matricies for the data */
d70 2
a71 2
void 
main()
d87 2
a88 2
	printf("#ifndef _RF__RF_INVERTQ_H_\n");
	printf("#define _RF__RF_INVERTQ_H_\n");
d93 1
a93 1
	printf(" * generate this file in kernel trees)\n");
d97 1
a97 1
	printf("#if (RF_INCLUDE_PQ > 0) || (RF_INCLUDE_RAID6 > 0)\n");
d99 2
a100 2
	printf("#define RF_Q_COLS 32\n");
	printf("RF_ua32_t rf_rn = {\n");
d110 1
a110 1
		printf("/* i = %d */ { 0, ", i);
d122 2
a123 1
	printf("#define RF_Q_DATA_COL(col_num) rf_rn[col_num],rf_qfor[28-(col_num)]\n");
d127 4
a130 3
	printf("#ifdef _KERNEL\n");
	printf("RF_ua1024_t rf_qinv[1];        /* don't compile monster table into kernel */\n");
	printf("#elif defined(NO_PQ)\n");
d132 1
a132 1
	printf("#else /* !_KERNEL && NO_PQ */\n");
d136 1
a136 1
			printf("/* i %d, j %d */{ ", i, j);
d143 3
a145 2
						/* What are a, b such that a ^
						 * b =  p; and qfor[(28-i)][a
d148 3
a150 2
						 * rf_rn[j+1]] =  q. Solve by
						 * guessing a. Then testing. */
d153 5
a157 1
							if ((rf_qfor[28 - i][a ^ k[i + 1]] ^ rf_qfor[28 - j][b ^ k[j + 1]]) == q)
d161 4
a164 2
							printf("unable to solve %d %d %d %d\n", i, j, p, q);
						printf("%d,", a);
d171 4
a174 3
	printf("\n#endif /* (RF_INCLUDE_PQ > 0) || (RF_INCLUDE_RAID6 > 0) */\n\n");
	printf("#endif /* !_KERNEL && NO_PQ */\n");
	printf("#endif /* !_RF__RF_INVERTQ_H_ */\n");
@


1.4.4.1
log
@sync
@
text
@a2 1

d30 2
a31 2
/*
 * rf_geniq.c -- Code which implements Reed-Solomon encoding for RAID level 6.
d35 1
a35 1
#define	RF_UTILITY	1
d39 8
a46 7
 * five bit lfsr
 * poly - feedback connections
 *
 * val  = value;
 */
int
lsfr_shift(unsigned val, unsigned poly)
d57 1
a57 1
		if (poly & (1 << i))	/* There is a feedback connection. */
d64 1
a64 3


/* Generate Q matrices for the data. */
d68 2
a69 2
int
main(void)
d85 2
a86 2
	printf("#ifndef\t_RF__RF_INVERTQ_H_\n");
	printf("#define\t_RF__RF_INVERTQ_H_\n");
d91 1
a91 1
	printf(" * generate this file in kernel trees).\n");
d95 1
a95 1
	printf("#if\t(RF_INCLUDE_PQ > 0) || (RF_INCLUDE_RAID6 > 0)\n");
d97 2
a98 2
	printf("#define\tRF_Q_COLS\t32\n");
	printf("RF_ua32_t rf_rn = {");
d108 1
a108 1
		printf("/* i = %d */\t{0, ", i);
d120 1
a120 2
	printf("#define\tRF_Q_DATA_COL(col_num)\trf_rn[col_num],"
	    " rf_qfor[28-(col_num)]\n");
d124 3
a126 4
	printf("#ifdef\t_KERNEL\n");
	printf("RF_ua1024_t rf_qinv[1];\t/* don't compile monster table"
	    " into kernel */\n");
	printf("#elif\tdefined(NO_PQ)\n");
d128 1
a128 1
	printf("#else\t/* !_KERNEL && NO_PQ */\n");
d132 1
a132 1
			printf("/* i %d, j %d */\t{", i, j);
d139 2
a140 3
						/*
						 * What are a, b such that a ^
						 * b == p; and qfor[(28-i)][a
d143 2
a144 3
						 * rf_rn[j+1]] == q. Solve by
						 * guessing a. Then testing.
						 */
d147 1
a147 5
							if ((rf_qfor[28 - i]
							     [a ^ k[i + 1]] ^
							    rf_qfor[28 - j]
							     [b ^ k[j + 1]]) ==
							    q)
d151 2
a152 4
							printf("unable to solve"
							    " %d %d %d %d\n",
							    i, j, p, q);
						printf("%d, ", a);
d159 3
a161 4
	printf("\n#endif\t/* (RF_INCLUDE_PQ > 0) || (RF_INCLUDE_RAID6 > 0) */"
	    "\n\n");
	printf("#endif\t/* !_KERNEL && NO_PQ */\n");
	printf("#endif\t/* !_RF__RF_INVERTQ_H_ */\n");
@


1.3
log
@* remove redundant rf_ccmn.h

* remove init call to rf_ConfigureEtimer() and rf_sys.c in which it is the
  only function. update conf/files to reflect this.

* update sources to make sure _KERNEL is used not KERNEL

* change rf_etimer.h to protect macros an include of sys/kernel.h with
  a check for _KERNEL - let raidctl compile again.
@
text
@d1 1
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Sync the SMP branch with 3.3
@
text
@a2 1

d30 2
a31 2
/*
 * rf_geniq.c -- Code which implements Reed-Solomon encoding for RAID level 6.
d35 1
a35 1
#define	RF_UTILITY	1
d39 8
a46 7
 * five bit lfsr
 * poly - feedback connections
 *
 * val  = value;
 */
int
lsfr_shift(unsigned val, unsigned poly)
d57 1
a57 1
		if (poly & (1 << i))	/* There is a feedback connection. */
d64 1
a64 3


/* Generate Q matrices for the data. */
d68 2
a69 2
int
main(void)
d85 2
a86 2
	printf("#ifndef\t_RF__RF_INVERTQ_H_\n");
	printf("#define\t_RF__RF_INVERTQ_H_\n");
d91 1
a91 1
	printf(" * generate this file in kernel trees).\n");
d95 1
a95 1
	printf("#if\t(RF_INCLUDE_PQ > 0) || (RF_INCLUDE_RAID6 > 0)\n");
d97 2
a98 2
	printf("#define\tRF_Q_COLS\t32\n");
	printf("RF_ua32_t rf_rn = {");
d108 1
a108 1
		printf("/* i = %d */\t{0, ", i);
d120 1
a120 2
	printf("#define\tRF_Q_DATA_COL(col_num)\trf_rn[col_num],"
	    " rf_qfor[28-(col_num)]\n");
d124 3
a126 4
	printf("#ifdef\t_KERNEL\n");
	printf("RF_ua1024_t rf_qinv[1];\t/* don't compile monster table"
	    " into kernel */\n");
	printf("#elif\tdefined(NO_PQ)\n");
d128 1
a128 1
	printf("#else\t/* !_KERNEL && NO_PQ */\n");
d132 1
a132 1
			printf("/* i %d, j %d */\t{", i, j);
d139 2
a140 3
						/*
						 * What are a, b such that a ^
						 * b == p; and qfor[(28-i)][a
d143 2
a144 3
						 * rf_rn[j+1]] == q. Solve by
						 * guessing a. Then testing.
						 */
d147 1
a147 5
							if ((rf_qfor[28 - i]
							     [a ^ k[i + 1]] ^
							    rf_qfor[28 - j]
							     [b ^ k[j + 1]]) ==
							    q)
d151 2
a152 4
							printf("unable to solve"
							    " %d %d %d %d\n",
							    i, j, p, q);
						printf("%d, ", a);
d159 3
a161 4
	printf("\n#endif\t/* (RF_INCLUDE_PQ > 0) || (RF_INCLUDE_RAID6 > 0) */"
	    "\n\n");
	printf("#endif\t/* !_KERNEL && NO_PQ */\n");
	printf("#endif\t/* !_RF__RF_INVERTQ_H_ */\n");
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d123 1
a123 1
	printf("#ifdef KERNEL\n");
d127 1
a127 1
	printf("#else /* !KERNEL && NO_PQ */\n");
d159 1
a159 1
	printf("#endif /* !KERNEL && NO_PQ */\n");
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 1
a1 1
/*	$NetBSD: rf_geniq.c,v 1.1 1998/11/13 04:20:30 oster Exp $	*/
a32 32
/* :  
 * Log: rf_geniq.c,v 
 * Revision 1.12  1996/07/29 16:37:00  jimz
 * remove archs.h include to avoid VPATH problems in kernel
 * rf_invertq.c now must include archs.h before invertq.h
 *
 * Revision 1.11  1996/07/29  15:04:16  jimz
 * correct rf_archs.h path for kernel
 *
 * Revision 1.10  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.9  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.8  1996/07/15  17:22:18  jimz
 * nit-pick code cleanup
 * resolve stdlib problems on DEC OSF
 *
 * Revision 1.7  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.6  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.5  1995/12/01  18:29:18  root
 * added copyright info
 *
 */
d43 3
a45 2
int lsfr_shift(val,poly)
unsigned val, poly;
d47 15
a61 16
  unsigned new;
  unsigned int i;
  unsigned high = (val >> 4) & 1;
  unsigned bit;

  new = (poly & 1) ? high : 0;
  
  for (i=1; i <=4; i++)
    {
      bit = (val >> (i-1)) & 1;
      if (poly & (1<<i))  /* there is a feedback connection */
	new = new | ((bit ^ high)<<i); 
      else
	new = new | (bit << i);
    }
  return new;
a62 1

d67 2
a68 1
void main()
d70 47
a116 47
  unsigned int i,j,l,a,b;
  unsigned int val;
  unsigned int r;
  unsigned int m,p,q;

  RF_ua32_t k;

  printf("/*\n");
  printf(" * rf_invertq.h\n");
  printf(" */\n");
  printf("/*\n");
  printf(" * GENERATED FILE -- DO NOT EDIT\n");
  printf(" */\n");
  printf("\n");
  printf("#ifndef _RF__RF_INVERTQ_H_\n");
  printf("#define _RF__RF_INVERTQ_H_\n");
  printf("\n");
  printf("/*\n");
  printf(" * rf_geniq.c must include rf_archs.h before including\n");
  printf(" * this file (to get VPATH magic right with the way we\n");
  printf(" * generate this file in kernel trees)\n");
  printf(" */\n");
  printf("/* #include \"rf_archs.h\" */\n");
  printf("\n");
  printf("#if (RF_INCLUDE_PQ > 0) || (RF_INCLUDE_RAID6 > 0)\n");
  printf("\n");
  printf("#define RF_Q_COLS 32\n");
  printf("RF_ua32_t rf_rn = {\n");
  k[0] = 1;
  for (j=0 ; j < 31; j++)
    k[j+1] = lsfr_shift(k[j],5);
  for (j=0; j < 32; j++)
    printf("%d, ",k[j]);
  printf("};\n");

  printf("RF_ua32_t rf_qfor[32] = {\n");
  for (i=0; i < 32; i++)
    {
      printf("/* i = %d */ { 0, ",i);
      rf_qfor[i][0] = 0;
      for (j=1; j < 32; j++)
	{
	  val = j;
	  for (l=0; l < i; l++)
	    val = lsfr_shift(val,5);
	  rf_qfor[i][j] = val;
	  printf("%d, ",val);
d118 38
a155 42
      printf("},\n");
    }
  printf("};\n");
  printf("#define RF_Q_DATA_COL(col_num) rf_rn[col_num],rf_qfor[28-(col_num)]\n");

  /* generate the inverse tables. (i,j,p,q) */
  /* The table just stores a. Get b back from
     the parity */
  printf("#ifdef KERNEL\n");
  printf("RF_ua1024_t rf_qinv[1];        /* don't compile monster table into kernel */\n");
  printf("#elif defined(NO_PQ)\n");
  printf("RF_ua1024_t rf_qinv[29*29];\n");
  printf("#else /* !KERNEL && NO_PQ */\n");
  printf("RF_ua1024_t rf_qinv[29*29] = {\n");
  for (i=0; i < 29; i++)
    {
      for (j =0; j < 29; j++)
	{
	  printf("/* i %d, j %d */{ ",i,j);
	  if (i==j)
	    for (l=0; l < 1023; l++) printf("0, ");
	  else
	    {
	      for (p=0; p < 32; p++)
		for (q=0; q < 32; q++)
		  {
		    /* What are a, b such that 
		       a ^ b =  p; and
		       qfor[(28-i)][a ^ rf_rn[i+1]] ^ qfor[(28-j)][b ^ rf_rn[j+1]] =  q.
		       Solve by guessing a. Then testing.
		       */
		    for ( a =0 ; a < 32; a++ )
		      {
			b = a ^ p;
			if ( (rf_qfor[28-i][a^ k[i+1]] ^ rf_qfor[28-j][b ^ k[j+1]]) == q )
			  break;
		      }
		    if (a == 32) printf("unable to solve %d %d %d %d\n",i,j,p,q); 
		    printf("%d,",a);
		  }
	    }
	  printf("},\n");
d157 5
a161 6
    }
  printf("};\n");
  printf("\n#endif /* (RF_INCLUDE_PQ > 0) || (RF_INCLUDE_RAID6 > 0) */\n\n");
  printf("#endif /* !KERNEL && NO_PQ */\n");
  printf("#endif /* !_RF__RF_INVERTQ_H_ */\n");
  exit(0);
@

