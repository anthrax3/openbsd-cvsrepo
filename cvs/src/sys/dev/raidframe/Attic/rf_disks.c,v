head	1.17;
access;
symbols
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.12
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.10
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.6.0.8
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.16;

1.16
date	2011.04.14.20.59.35;	author pea;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.23.18.49.39;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.23.13.49.35;	author naddy;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.05.00.38.22;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.13.00.30.08;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.27.20.13.27;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.19.14.32.00;	author tdeval;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.08.16.07.40;	author peter;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2000.01.11.18.02.21;	author peter;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.01.07.14.50.21;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.40;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.17;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.10;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.13.19.35.09;	author ho;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2004.02.19.10.56.31;	author niklas;	state Exp;
branches;
next	;

1.6.8.1
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_disks.c,v 1.16 2011/04/14 20:59:35 pea Exp $	*/
/*	$NetBSD: rf_disks.c,v 1.31 2000/06/02 01:17:14 oster Exp $	*/

/*
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Greg Oster
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/***************************************************************
 * rf_disks.c -- Code to perform operations on the actual disks.
 ***************************************************************/

#include "rf_types.h"
#include "rf_raid.h"
#include "rf_alloclist.h"
#include "rf_utils.h"
#include "rf_configure.h"
#include "rf_general.h"
#include "rf_options.h"
#include "rf_kintf.h"

#if defined(__NetBSD__)
#include "rf_netbsd.h"
#elif defined(__OpenBSD__)
#include "rf_openbsd.h"
#endif

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/fcntl.h>
#ifdef	__NETBSD__
#include <sys/vnode.h>
#endif	/* __NETBSD__ */

int  rf_AllocDiskStructures(RF_Raid_t *, RF_Config_t *);
void rf_print_label_status(RF_Raid_t *, int, int, char *,
	RF_ComponentLabel_t *);
int  rf_check_label_vitals(RF_Raid_t *, int, int, char *,
	RF_ComponentLabel_t *, int, int);

#define	DPRINTF6(a,b,c,d,e,f)	if (rf_diskDebug) printf(a,b,c,d,e,f)
#define	DPRINTF7(a,b,c,d,e,f,g)	if (rf_diskDebug) printf(a,b,c,d,e,f,g)

/****************************************************************************
 *
 * Initialize the disks comprising the array.
 *
 * We want the spare disks to have regular row,col numbers so that we can
 * easily substitue a spare for a failed disk. But, the driver code assumes
 * throughout that the array contains numRow by numCol _non-spare_ disks, so
 * it's not clear how to fit in the spares. This is an unfortunate holdover
 * from raidSim. The quick and dirty fix is to make row zero bigger than the
 * rest, and put all the spares in it. This probably needs to get changed
 * eventually.
 *
 ****************************************************************************/
int
rf_ConfigureDisks(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	RF_RaidDisk_t **disks;
	RF_SectorCount_t min_numblks = (RF_SectorCount_t) 0x7FFFFFFFFFFFLL;
	RF_RowCol_t r, c;
	int bs, ret;
	unsigned i, count, foundone = 0, numFailuresThisRow;
	int force;

	force = cfgPtr->force;

 	ret = rf_AllocDiskStructures(raidPtr, cfgPtr);
 	if (ret)
		goto fail;

 	disks = raidPtr->Disks;

	for (r = 0; r < raidPtr->numRow; r++) {
		numFailuresThisRow = 0;
		for (c = 0; c < raidPtr->numCol; c++) {
			ret = rf_ConfigureDisk(raidPtr,
			    &cfgPtr->devnames[r][c][0], &disks[r][c], r, c);

			if (ret)
				goto fail;

			if (disks[r][c].status == rf_ds_optimal) {
				raidread_component_label(
					 raidPtr->raid_cinfo[r][c].ci_dev,
					 raidPtr->raid_cinfo[r][c].ci_vp,
					 &raidPtr->raid_cinfo[r][c].ci_label);
			}

			if (disks[r][c].status != rf_ds_optimal) {
				numFailuresThisRow++;
			} else {
				if (disks[r][c].numBlocks < min_numblks)
					min_numblks = disks[r][c].numBlocks;
				DPRINTF7("Disk at row %d col %d: dev %s"
				    " numBlocks %ld blockSize %d (%ld MB)\n",
				    r, c, disks[r][c].devname,
				    (long int) disks[r][c].numBlocks,
				    disks[r][c].blockSize,
				    (long int) disks[r][c].numBlocks *
				     disks[r][c].blockSize / 1024 / 1024);
			}
		}
		/* XXX Fix for n-fault tolerant. */
		/*
		 * XXX This should probably check to see how many failures
		 * we can handle for this configuration !
		 */
		if (numFailuresThisRow > 0)
			raidPtr->status[r] = rf_rs_degraded;
	}
	/*
	 * All disks must be the same size & have the same block size, bs must
	 * be a power of 2.
	 */
	bs = 0;
	for (foundone = r = 0; !foundone && r < raidPtr->numRow; r++) {
		for (c = 0; !foundone && c < raidPtr->numCol; c++) {
			if (disks[r][c].status == rf_ds_optimal) {
				bs = disks[r][c].blockSize;
				foundone = 1;
			}
		}
	}
	if (!foundone) {
		RF_ERRORMSG("RAIDFRAME: Did not find any live disks in"
		    " the array.\n");
		ret = EINVAL;
		goto fail;
	}
	for (count = 0, i = 1; i; i <<= 1)
		if (bs & i)
			count++;
	if (count != 1) {
		RF_ERRORMSG1("Error: block size on disks (%d) must be a"
		    " power of 2.\n", bs);
		ret = EINVAL;
		goto fail;
	}

	if (rf_CheckLabels(raidPtr, cfgPtr)) {
		printf("raid%d: There were fatal errors\n", raidPtr->raidid);
		if (force != 0) {
			printf("raid%d: Fatal errors being ignored.\n",
			    raidPtr->raidid);
		} else {
			ret = EINVAL;
			goto fail;
		}
	}

	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			if (disks[r][c].status == rf_ds_optimal) {
				if (disks[r][c].blockSize != bs) {
					RF_ERRORMSG2("Error: block size of"
					    " disk at r %d c %d different from"
					    " disk at r 0 c 0.\n", r, c);
					ret = EINVAL;
					goto fail;
				}
				if (disks[r][c].numBlocks != min_numblks) {
					RF_ERRORMSG3("WARNING: truncating disk"
					    " at r %d c %d to %d blocks.\n",
					    r, c, (int) min_numblks);
					disks[r][c].numBlocks = min_numblks;
				}
			}
		}
	}

	raidPtr->sectorsPerDisk = min_numblks;
	raidPtr->logBytesPerSector = ffs(bs) - 1;
	raidPtr->bytesPerSector = bs;
	raidPtr->sectorMask = bs - 1;
	return (0);

fail:
	rf_UnconfigureVnodes(raidPtr);

	return (ret);
}


/****************************************************************************
 * Set up the data structures describing the spare disks in the array.
 * Recall from the above comment that the spare disk descriptors are stored
 * in row zero, which is specially expanded to hold them.
 ****************************************************************************/
int
rf_ConfigureSpareDisks(RF_ShutdownList_t ** listp, RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
{
	int i, ret;
	unsigned int bs;
	RF_RaidDisk_t *disks;
	int num_spares_done;

	num_spares_done = 0;

	/*
	 * The space for the spares should have already been allocated by
	 * ConfigureDisks().
	 */

	disks = &raidPtr->Disks[0][raidPtr->numCol];
	for (i = 0; i < raidPtr->numSpare; i++) {
		ret = rf_ConfigureDisk(raidPtr, &cfgPtr->spare_names[i][0],
		    &disks[i], 0, raidPtr->numCol + i);
		if (ret)
			goto fail;
		if (disks[i].status != rf_ds_optimal) {
			RF_ERRORMSG1("Warning: spare disk %s failed TUR\n",
			    &cfgPtr->spare_names[i][0]);
		} else {
			/* Change status to spare. */
			disks[i].status = rf_ds_spare;
			DPRINTF6("Spare Disk %d: dev %s numBlocks %ld"
			    " blockSize %d (%ld MB).\n", i, disks[i].devname,
			    (long int) disks[i].numBlocks, disks[i].blockSize,
			    (long int) disks[i].numBlocks *
			    disks[i].blockSize / 1024 / 1024);
		}
		num_spares_done++;
	}

	/* Check sizes and block sizes on spare disks. */
	bs = 1 << raidPtr->logBytesPerSector;
	for (i = 0; i < raidPtr->numSpare; i++) {
		if (disks[i].blockSize != bs) {
			RF_ERRORMSG3("Block size of %d on spare disk %s is"
			    " not the same as on other disks (%d).\n",
			    disks[i].blockSize, disks[i].devname, bs);
			ret = EINVAL;
			goto fail;
		}
		if (disks[i].numBlocks < raidPtr->sectorsPerDisk) {
			RF_ERRORMSG3("Spare disk %s (%llu blocks) is too small"
			    " to serve as a spare (need %llu blocks).\n",
			    disks[i].devname, disks[i].numBlocks,
			    raidPtr->sectorsPerDisk);
			ret = EINVAL;
			goto fail;
		} else
			if (disks[i].numBlocks > raidPtr->sectorsPerDisk) {
				RF_ERRORMSG2("Warning: truncating spare disk"
				    " %s to %llu blocks.\n", disks[i].devname,
				    raidPtr->sectorsPerDisk);

				disks[i].numBlocks = raidPtr->sectorsPerDisk;
			}
	}

	return (0);

fail:

	/*
	 * Release the hold on the main components. We've failed to allocate
	 * a spare, and since we're failing, we need to free things...
	 *
	 * XXX Failing to allocate a spare is *not* that big of a deal...
	 * We *can* survive without it, if need be, esp. if we get hot
	 * adding working.
	 * If we don't fail out here, then we need a way to remove this spare...
	 * That should be easier to do here than if we are "live"...
	 */

	rf_UnconfigureVnodes(raidPtr);

	return (ret);
}

int
rf_AllocDiskStructures(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr)
{
	RF_RaidDisk_t **disks;
	int ret;
	int r;

	RF_CallocAndAdd(disks, raidPtr->numRow, sizeof(RF_RaidDisk_t *),
	    (RF_RaidDisk_t **), raidPtr->cleanupList);
	if (disks == NULL) {
		ret = ENOMEM;
		goto fail;
	}
	raidPtr->Disks = disks;
	/* Get space for the device-specific stuff... */
	RF_CallocAndAdd(raidPtr->raid_cinfo, raidPtr->numRow,
	    sizeof(struct raidcinfo *), (struct raidcinfo **),
	    raidPtr->cleanupList);
	if (raidPtr->raid_cinfo == NULL) {
		ret = ENOMEM;
		goto fail;
	}

	for (r = 0; r < raidPtr->numRow; r++) {
		/*
		 * We allocate RF_MAXSPARE on the first row so that we
		 * have room to do hot-swapping of spares.
		 */
		RF_CallocAndAdd(disks[r], raidPtr->numCol +
		    ((r == 0) ? RF_MAXSPARE : 0), sizeof(RF_RaidDisk_t),
		    (RF_RaidDisk_t *), raidPtr->cleanupList);
		if (disks[r] == NULL) {
			ret = ENOMEM;
			goto fail;
		}
		/* Get more space for device specific stuff... */
		RF_CallocAndAdd(raidPtr->raid_cinfo[r], raidPtr->numCol +
		    ((r == 0) ? raidPtr->numSpare : 0),
		    sizeof(struct raidcinfo), (struct raidcinfo *),
		    raidPtr->cleanupList);
		if (raidPtr->raid_cinfo[r] == NULL) {
			ret = ENOMEM;
			goto fail;
		}
	}
	return(0);
fail:
	rf_UnconfigureVnodes(raidPtr);

	return(ret);
}


/* Configure a single disk during auto-configuration at boot. */
int
rf_AutoConfigureDisks(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr,
    RF_AutoConfig_t *auto_config)
{
	RF_RaidDisk_t **disks;
	RF_RaidDisk_t *diskPtr;
	RF_RowCol_t r, c;
	RF_SectorCount_t min_numblks = (RF_SectorCount_t) 0x7FFFFFFFFFFFLL;
	int bs, ret;
	int numFailuresThisRow;
	int force;
	RF_AutoConfig_t *ac;
	int parity_good;
	int mod_counter;
	int mod_counter_found;

#if	DEBUG
	printf("Starting autoconfiguration of RAID set...\n");
#endif	/* DEBUG */
	force = cfgPtr->force;

	ret = rf_AllocDiskStructures(raidPtr, cfgPtr);
	if (ret)
		goto fail;

	disks = raidPtr->Disks;

	/* Assume the parity will be fine... */
	parity_good = RF_RAID_CLEAN;

	/* Check for mod_counters that are too low. */
	mod_counter_found = 0;
	ac = auto_config;
	while(ac!=NULL) {
		if (mod_counter_found == 0) {
			mod_counter = ac->clabel->mod_counter;
			mod_counter_found = 1;
		} else {
			if (ac->clabel->mod_counter > mod_counter) {
				mod_counter = ac->clabel->mod_counter;
			}
		}
		ac->flag = 0; /* Clear the general purpose flag. */
		ac = ac->next;
	}

	for (r = 0; r < raidPtr->numRow; r++) {
		numFailuresThisRow = 0;
		for (c = 0; c < raidPtr->numCol; c++) {
			diskPtr = &disks[r][c];

			/* Find this row/col in the autoconfig. */
#if	DEBUG
			printf("Looking for %d,%d in autoconfig.\n", r, c);
#endif	/* DEBUG */
			ac = auto_config;
			while(ac!=NULL) {
				if (ac->clabel == NULL) {
					/* Big-time bad news. */
					goto fail;
				}
				if ((ac->clabel->row == r) &&
				    (ac->clabel->column == c) &&
				    (ac->clabel->mod_counter == mod_counter)) {
					/* It's this one... */
					/*
					 * Flag it as 'used', so we don't
					 * free it later.
					 */
					ac->flag = 1;
#if	DEBUG
					printf("Found: %s at %d,%d.\n",
					    ac->devname, r, c);
#endif	/* DEBUG */

					break;
				}
				ac = ac->next;
			}

			if (ac == NULL) {
				/*
				 * We didn't find an exact match with a
				 * correct mod_counter above...  Can we
				 * find one with an incorrect mod_counter
				 * to use instead ?  (This one, if we find
				 * it, will be marked as failed once the
				 * set configures)
				 */

				ac = auto_config;
				while(ac!=NULL) {
					if (ac->clabel == NULL) {
						/* Big-time bad news. */
						goto fail;
					}
					if ((ac->clabel->row == r) &&
					    (ac->clabel->column == c)) {
						/*
						 * It's this one...
						 * Flag it as 'used', so we
						 * don't free it later.
						 */
						ac->flag = 1;
#if	DEBUG
						printf("Found(low mod_counter)"
						    ": %s at %d,%d.\n",
						    ac->devname, r, c);
#endif	/* DEBUG */

						break;
					}
					ac = ac->next;
				}
			}



			if (ac!=NULL) {
				/* Found it. Configure it... */
				diskPtr->blockSize = ac->clabel->blockSize;
				diskPtr->numBlocks = ac->clabel->numBlocks;
				/*
				 * Note: rf_protectedSectors is already
				 * factored into numBlocks here.
				 */
				raidPtr->raid_cinfo[r][c].ci_vp = ac->vp;
				raidPtr->raid_cinfo[r][c].ci_dev = ac->dev;

				memcpy(&raidPtr->raid_cinfo[r][c].ci_label,
				    ac->clabel, sizeof(*ac->clabel));
				snprintf(diskPtr->devname,
				    sizeof diskPtr->devname, "/dev/%s",
				    ac->devname);

				/*
				 * Note the fact that this component was
				 * autoconfigured. You'll need this info
				 * later. Trust me :)
				 */
				diskPtr->auto_configured = 1;
				diskPtr->dev = ac->dev;

				/*
				 * We allow the user to specify that
				 * only a fraction of the disks should
				 * be used. This is just for debug: it
				 * speeds up the parity scan.
				 */

				diskPtr->numBlocks = diskPtr->numBlocks *
					rf_sizePercentage / 100;

				/*
				 * XXX These will get set multiple times,
				 * but since we're autoconfiguring, they'd
				 * better be always the same each time !
				 * If not, this is the least of your worries.
				 */

				bs = diskPtr->blockSize;
				min_numblks = diskPtr->numBlocks;

				/*
				 * This gets done multiple times, but that's
				 * fine -- the serial number will be the same
				 * for all components, guaranteed.
				 */
				raidPtr->serial_number =
				    ac->clabel->serial_number;
				/*
				 * Check the last time the label
				 * was modified.
				 */
				if (ac->clabel->mod_counter != mod_counter) {
					/*
					 * Even though we've filled in all
					 * of the above, we don't trust
					 * this component since it's
					 * modification counter is not
					 * in sync with the rest, and we really
					 * consider it to be failed.
					 */
					disks[r][c].status = rf_ds_failed;
					numFailuresThisRow++;
				} else {
					if (ac->clabel->clean != RF_RAID_CLEAN)
					{
						parity_good = RF_RAID_DIRTY;
					}
				}
			} else {
				/*
				 * Didn't find it at all !!!
				 * Component must really be dead.
				 */
				disks[r][c].status = rf_ds_failed;
				snprintf(disks[r][c].devname,
				    sizeof disks[r][c].devname, "component%d",
				    r * raidPtr->numCol + c);
				numFailuresThisRow++;
			}
		}
		/* XXX Fix for n-fault tolerant. */
		/*
		 * XXX This should probably check to see how many failures
		 * we can handle for this configuration !
		 */
		if (numFailuresThisRow > 0)
			raidPtr->status[r] = rf_rs_degraded;
	}

	/* Close the device for the ones that didn't get used. */

	ac = auto_config;
	while(ac != NULL) {
		if (ac->flag == 0) {
			VOP_CLOSE(ac->vp, FREAD, NOCRED, curproc);
			vput(ac->vp);
			ac->vp = NULL;
#if	DEBUG
			printf("Released %s from auto-config set.\n",
			    ac->devname);
#endif  /* DEBUG */
		}
		ac = ac->next;
	}

	raidPtr->mod_counter = mod_counter;

	/* Note the state of the parity, if any. */
	raidPtr->parity_good = parity_good;
	raidPtr->sectorsPerDisk = min_numblks;
	raidPtr->logBytesPerSector = ffs(bs) - 1;
	raidPtr->bytesPerSector = bs;
	raidPtr->sectorMask = bs - 1;
	return (0);

fail:

	rf_UnconfigureVnodes(raidPtr);

	return (ret);

}

/* Configure a single disk in the array. */
int
rf_ConfigureDisk(RF_Raid_t *raidPtr, char *buf, RF_RaidDisk_t *diskPtr,
    RF_RowCol_t row, RF_RowCol_t col)
{
	char *p;
	int retcode;

	struct partinfo dpart;
	struct vnode *vp;
	struct vattr va;
	struct proc *proc;
	int error;

	retcode = 0;
	p = rf_find_non_white(buf);
	if (*buf != '\0' && p[strlen(p) - 1] == '\n') {
		/* Strip off the newline. */
		p[strlen(p) - 1] = '\0';
	}
	(void) strlcpy(diskPtr->devname, p, sizeof diskPtr->devname);

	proc = raidPtr->engine_thread;

	/* Let's start by claiming the component is fine and well... */
	diskPtr->status = rf_ds_optimal;

	raidPtr->raid_cinfo[row][col].ci_vp = NULL;
	raidPtr->raid_cinfo[row][col].ci_dev = 0;

	error = raidlookup(diskPtr->devname, curproc, &vp);
	if (error) {
		printf("raidlookup on device: %s failed !\n", diskPtr->devname);
		if (error == ENXIO) {
			/* The component isn't there...  Must be dead :-( */
			diskPtr->status = rf_ds_failed;
		} else {
			return (error);
		}
	}
	if (diskPtr->status == rf_ds_optimal) {

		if ((error = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {
			return (error);
		}
		error = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart, FREAD,
		    proc->p_ucred, proc);
		if (error) {
			return (error);
		}
		diskPtr->blockSize = dpart.disklab->d_secsize;

		diskPtr->numBlocks = DL_GETPSIZE(dpart.part) - rf_protectedSectors;
 		diskPtr->partitionSize = DL_GETPSIZE(dpart.part);

		raidPtr->raid_cinfo[row][col].ci_vp = vp;
		raidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;

 		/* This component was not automatically configured. */
 		diskPtr->auto_configured = 0;
		diskPtr->dev = va.va_rdev;

		/*
		 * We allow the user to specify that only a fraction of the
		 * disks should be used. This is just for debug: it speeds up
		 * the parity scan.
		 */
		diskPtr->numBlocks = diskPtr->numBlocks * rf_sizePercentage
		    / 100;
	}
	return (0);
}

void
rf_print_label_status(RF_Raid_t *raidPtr, int row, int column, char *dev_name,
    RF_ComponentLabel_t *ci_label)
{

	printf("raid%d: Component %s being configured at row: %d col: %d\n",
	    raidPtr->raidid, dev_name, row, column);
	printf("         Row: %d Column: %d Num Rows: %d Num Columns: %d\n",
	    ci_label->row, ci_label->column, ci_label->num_rows,
	    ci_label->num_columns);
	printf("         Version: %d Serial Number: %d Mod Counter: %d\n",
	    ci_label->version, ci_label->serial_number, ci_label->mod_counter);
	printf("         Clean: %s Status: %d\n",
	    ci_label->clean ? "Yes" : "No", ci_label->status);
}

int
rf_check_label_vitals(RF_Raid_t *raidPtr, int row, int column, char *dev_name,
    RF_ComponentLabel_t *ci_label, int serial_number, int mod_counter)
{
	int fatal_error = 0;

	if (serial_number != ci_label->serial_number) {
		printf("%s has a different serial number: %d %d.\n",
		    dev_name, serial_number, ci_label->serial_number);
		fatal_error = 1;
	}
	if (mod_counter != ci_label->mod_counter) {
		printf("%s has a different modfication count: %d %d.\n",
		    dev_name, mod_counter, ci_label->mod_counter);
	}

	if (row != ci_label->row) {
		printf("Row out of alignment for: %s.\n", dev_name);
		fatal_error = 1;
	}
	if (column != ci_label->column) {
		printf("Column out of alignment for: %s.\n", dev_name);
		fatal_error = 1;
	}
	if (raidPtr->numRow != ci_label->num_rows) {
		printf("Number of rows do not match for: %s.\n", dev_name);
		fatal_error = 1;
	}
	if (raidPtr->numCol != ci_label->num_columns) {
		printf("Number of columns do not match for: %s.\n", dev_name);
		fatal_error = 1;
	}
	if (ci_label->clean == 0) {
		/* It's not clean, but that's not fatal. */
		printf("%s is not clean !\n", dev_name);
	}
	return(fatal_error);
}


/*
 *
 * rf_CheckLabels() - Check all the component labels for consistency.
 * Return an error if there is anything major amiss.
 *
 */

int
rf_CheckLabels(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr)
{
	int r, c;
	char *dev_name;
	RF_ComponentLabel_t *ci_label;
	int serial_number = 0;
	int mod_number = 0;
	int fatal_error = 0;
	int mod_values[4];
	int mod_count[4];
	int ser_values[4];
	int ser_count[4];
	int num_ser;
	int num_mod;
	int i;
	int found;
	int hosed_row;
	int hosed_column;
	int too_fatal;
	int parity_good;
	int force;

	hosed_row = -1;
	hosed_column = -1;
	too_fatal = 0;
	force = cfgPtr->force;

	/*
	 * We're going to try to be a little intelligent here. If one
	 * component's label is bogus, and we can identify that it's the
	 * *only* one that's gone, we'll mark it as "failed" and allow
	 * the configuration to proceed. This will be the *only* case
	 * that we'll proceed if there would be (otherwise) fatal errors.
	 *
	 * Basically we simply keep a count of how many components had
	 * what serial number. If all but one agree, we simply mark
	 * the disagreeing component as being failed, and allow
	 * things to come up "normally".
	 *
	 * We do this first for serial numbers, and then for "mod_counter".
	 *
	 */

	num_ser = 0;
	num_mod = 0;
	for (r = 0; r < raidPtr->numRow && !fatal_error; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			ci_label = &raidPtr->raid_cinfo[r][c].ci_label;
			found = 0;
			for(i = 0; i < num_ser; i++) {
				if (ser_values[i] == ci_label->serial_number) {
					ser_count[i]++;
					found = 1;
					break;
				}
			}
			if (!found) {
				ser_values[num_ser] = ci_label->serial_number;
				ser_count[num_ser] = 1;
				num_ser++;
				if (num_ser > 2) {
					fatal_error = 1;
					break;
				}
			}
			found = 0;
			for(i = 0; i < num_mod; i++) {
				if (mod_values[i] == ci_label->mod_counter) {
					mod_count[i]++;
					found = 1;
					break;
				}
			}
			if (!found) {
				mod_values[num_mod] = ci_label->mod_counter;
				mod_count[num_mod] = 1;
				num_mod++;
				if (num_mod > 2) {
					fatal_error = 1;
					break;
				}
			}
		}
	}
#if	DEBUG
	printf("raid%d: Summary of serial numbers:\n", raidPtr->raidid);
	for(i = 0; i < num_ser; i++) {
		printf("%d %d\n", ser_values[i], ser_count[i]);
	}
	printf("raid%d: Summary of mod counters:\n", raidPtr->raidid);
	for(i = 0; i < num_mod; i++) {
		printf("%d %d\n", mod_values[i], mod_count[i]);
	}
#endif  /* DEBUG */
	serial_number = ser_values[0];
	if (num_ser == 2) {
		if ((ser_count[0] == 1) || (ser_count[1] == 1)) {
			/* Locate the maverick component. */
			if (ser_count[1] > ser_count[0]) {
				serial_number = ser_values[1];
			}
			for (r = 0; r < raidPtr->numRow; r++) {
				for (c = 0; c < raidPtr->numCol; c++) {
					ci_label =
					    &raidPtr->raid_cinfo[r][c].ci_label;
					if (serial_number !=
					    ci_label->serial_number) {
						hosed_row = r;
						hosed_column = c;
						break;
					}
				}
			}
			printf("Hosed component: %s.\n",
			    &cfgPtr->devnames[hosed_row][hosed_column][0]);
			if (!force) {
				/*
				 * We'll fail this component, as if there are
				 * other major errors, we aren't forcing things
				 * and we'll abort the config anyways.
				 */
				raidPtr->Disks[hosed_row][hosed_column].status
				    = rf_ds_failed;
				raidPtr->numFailures++;
				raidPtr->status[hosed_row] = rf_rs_degraded;
			}
		} else {
			too_fatal = 1;
		}
		if (cfgPtr->parityConfig == '0') {
			/*
			 * We've identified two different serial numbers.
			 * RAID 0 can't cope with that, so we'll punt.
			 */
			too_fatal = 1;
		}

	}

	/*
	 * Record the serial number for later. If we bail later, setting
	 * this doesn't matter, otherwise we've got the best guess at the
	 * correct serial number.
	 */
	raidPtr->serial_number = serial_number;

	mod_number = mod_values[0];
	if (num_mod == 2) {
		if ((mod_count[0] == 1) || (mod_count[1] == 1)) {
			/* Locate the maverick component. */
			if (mod_count[1] > mod_count[0]) {
				mod_number = mod_values[1];
			} else if (mod_count[1] < mod_count[0]) {
				mod_number = mod_values[0];
			} else {
				/*
				 * Counts of different modification values
				 * are the same. Assume greater value is
				 * the correct one, all other things
				 * considered.
				 */
				if (mod_values[0] > mod_values[1]) {
					mod_number = mod_values[0];
				} else {
					mod_number = mod_values[1];
				}

			}
			for (r = 0; r < raidPtr->numRow && !too_fatal; r++) {
				for (c = 0; c < raidPtr->numCol; c++) {
					ci_label =
					    &raidPtr->raid_cinfo[r][c].ci_label;
					if (mod_number !=
					    ci_label->mod_counter) {
						if ((hosed_row == r) &&
						    (hosed_column == c)) {
							/*
							 * Same one. Can
							 * deal with it.
							 */
						} else {
							hosed_row = r;
							hosed_column = c;
							if (num_ser != 1) {
								too_fatal = 1;
								break;
							}
						}
					}
				}
			}
			printf("Hosed component: %s.\n",
			    &cfgPtr->devnames[hosed_row][hosed_column][0]);
			if (!force) {
				/*
				 * We'll fail this component, as if there are
				 * other major errors, we aren't forcing things
				 * and we'll abort the config anyways.
				 */
				if (raidPtr
				    ->Disks[hosed_row][hosed_column].status !=
				    rf_ds_failed) {
					raidPtr->Disks[hosed_row]
					    [hosed_column].status =
					    rf_ds_failed;
					raidPtr->numFailures++;
					raidPtr->status[hosed_row] =
					    rf_rs_degraded;
				}
			}
		} else {
			too_fatal = 1;
		}
		if (cfgPtr->parityConfig == '0') {
			/*
			 * We've identified two different mod counters.
			 * RAID 0 can't cope with that, so we'll punt.
			 */
			too_fatal = 1;
		}
	}

	raidPtr->mod_counter = mod_number;

	if (too_fatal) {
		/*
		 * We've had both a serial number mismatch, and a mod_counter
		 * mismatch -- and they involved two different components !!!
		 * Bail -- make things fail so that the user must force
		 * the issue...
		 */
		hosed_row = -1;
		hosed_column = -1;
	}

	if (num_ser > 2) {
		printf("raid%d: Too many different serial numbers !\n",
		    raidPtr->raidid);
	}

	if (num_mod > 2) {
		printf("raid%d: Too many different mod counters !\n",
		    raidPtr->raidid);
	}

	/*
	 * We start by assuming the parity will be good, and flee from
	 * that notion at the slightest sign of trouble.
	 */

	parity_good = RF_RAID_CLEAN;
	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			dev_name = &cfgPtr->devnames[r][c][0];
			ci_label = &raidPtr->raid_cinfo[r][c].ci_label;

			if ((r == hosed_row) && (c == hosed_column)) {
				printf("raid%d: Ignoring %s.\n",
				    raidPtr->raidid, dev_name);
			} else {
				rf_print_label_status(raidPtr, r, c, dev_name,
				    ci_label);
				if (rf_check_label_vitals(raidPtr, r, c,
				     dev_name, ci_label, serial_number,
				     mod_number)) {
					fatal_error = 1;
				}
				if (ci_label->clean != RF_RAID_CLEAN) {
					parity_good = RF_RAID_DIRTY;
				}
			}
		}
	}
	if (fatal_error) {
		parity_good = RF_RAID_DIRTY;
	}

	/* We note the state of the parity. */
	raidPtr->parity_good = parity_good;

	return(fatal_error);
}

int
rf_add_hot_spare(RF_Raid_t *raidPtr, RF_SingleComponent_t *sparePtr)
{
	RF_RaidDisk_t *disks;
	RF_DiskQueue_t *spareQueues;
	int ret;
	unsigned int bs;
	int spare_number;

#if 0
	printf("Just in rf_add_hot_spare: %d.\n", raidPtr->numSpare);
	printf("Num col: %d.\n", raidPtr->numCol);
#endif
	if (raidPtr->numSpare >= RF_MAXSPARE) {
		RF_ERRORMSG1("Too many spares: %d.\n", raidPtr->numSpare);
		return(EINVAL);
 	}

	RF_LOCK_MUTEX(raidPtr->mutex);

	/* The beginning of the spares... */
	disks = &raidPtr->Disks[0][raidPtr->numCol];

	spare_number = raidPtr->numSpare;

	ret = rf_ConfigureDisk(raidPtr, sparePtr->component_name,
	    &disks[spare_number], 0, raidPtr->numCol + spare_number);

	if (ret)
		goto fail;
	if (disks[spare_number].status != rf_ds_optimal) {
		RF_ERRORMSG1("Warning: spare disk %s failed TUR.\n",
		    sparePtr->component_name);
		ret = EINVAL;
		goto fail;
	} else {
		disks[spare_number].status = rf_ds_spare;
		DPRINTF6("Spare Disk %d: dev %s numBlocks %ld blockSize %d"
		    " (%ld MB).\n", spare_number, disks[spare_number].devname,
		    (long int) disks[spare_number].numBlocks,
		    disks[spare_number].blockSize,
		    (long int) disks[spare_number].numBlocks *
		     disks[spare_number].blockSize / 1024 / 1024);
	}


	/* Check sizes and block sizes on the spare disk. */
	bs = 1 << raidPtr->logBytesPerSector;
	if (disks[spare_number].blockSize != bs) {
		RF_ERRORMSG3("Block size of %d on spare disk %s is not"
		    " the same as on other disks (%d).\n",
		    disks[spare_number].blockSize,
		    disks[spare_number].devname, bs);
		ret = EINVAL;
		goto fail;
	}
	if (disks[spare_number].numBlocks < raidPtr->sectorsPerDisk) {
		RF_ERRORMSG3("Spare disk %s (%llu blocks) is too small to serve"
		    " as a spare (need %llu blocks).\n",
		    disks[spare_number].devname, disks[spare_number].numBlocks,
		    raidPtr->sectorsPerDisk);
		ret = EINVAL;
		goto fail;
	} else {
		if (disks[spare_number].numBlocks >
		    raidPtr->sectorsPerDisk) {
			RF_ERRORMSG2("Warning: truncating spare disk %s to %llu"
			    " blocks.\n", disks[spare_number].devname,
			    raidPtr->sectorsPerDisk);

			disks[spare_number].numBlocks = raidPtr->sectorsPerDisk;
		}
	}

	spareQueues = &raidPtr->Queues[0][raidPtr->numCol];
	ret = rf_ConfigureDiskQueue(raidPtr, &spareQueues[spare_number],
	    0, raidPtr->numCol + spare_number, raidPtr->qType,
	    raidPtr->sectorsPerDisk, raidPtr->Disks[0][raidPtr->numCol +
	     spare_number].dev, raidPtr->maxOutstanding,
	    &raidPtr->shutdownList, raidPtr->cleanupList);


	raidPtr->numSpare++;
	RF_UNLOCK_MUTEX(raidPtr->mutex);
	return (0);

fail:
	RF_UNLOCK_MUTEX(raidPtr->mutex);
	return(ret);
}

int
rf_remove_hot_spare(RF_Raid_t *raidPtr, RF_SingleComponent_t *sparePtr)
{
	int spare_number;

	if (raidPtr->numSpare == 0) {
		printf("No spares to remove !\n");
		return(EINVAL);
	}

	spare_number = sparePtr->column;

	return(EINVAL);	/* XXX Not implemented yet. */
#if 0
	if (spare_number < 0 || spare_number > raidPtr->numSpare) {
		return(EINVAL);
	}

	/* Verify that this spare isn't in use... */

	/* It's gone... */

	raidPtr->numSpare--;

	return (0);
#endif
}

int
rf_delete_component(RF_Raid_t *raidPtr, RF_SingleComponent_t *component)
{
	RF_RaidDisk_t *disks;

	if ((component->row < 0) ||
	    (component->row >= raidPtr->numRow) ||
	    (component->column < 0) ||
	    (component->column >= raidPtr->numCol)) {
		return(EINVAL);
	}

	disks = &raidPtr->Disks[component->row][component->column];

	/* 1. This component must be marked as 'failed'. */

	return(EINVAL); /* Not implemented yet. */
}

int
rf_incorporate_hot_spare(RF_Raid_t *raidPtr, RF_SingleComponent_t *component)
{

	/*
	 * Issues here include how to 'move' this in if there is IO
	 * taking place (e.g. component queues and such).
	 */

	return(EINVAL); /* Not implemented yet. */
}
@


1.16
log
@Make RAIDFRAME compile

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.15 2010/09/23 18:49:39 oga Exp $	*/
@


1.15
log
@The only sensible argument for VOP_* calls that take a struct proc pointer is
curproc. A bunch of callers were passing in 0 (not even NULL, 0) as this
pointer, which was fine until the called vnode function tried to do
something with it. Typically, this code was then copy/pasted to various
parts of the tree.

Accept the facts of life and switch all of these over to passing curproc
for now until the argument can be removed.

Discovered by stsp trying to create a softraid on top of a vnd, which
crashed with a NULL deref in vndioctl.

softraid bits tested by mikeb and jsing. raidframe bits tested by pea,
matthieu and naddy. The rest tested by at least thib, jsing and myself.

ok thib@@, jsing@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.14 2010/05/23 13:49:35 naddy Exp $	*/
d658 1
a658 1
	raidPtr->raid_cinfo[row][col].ci_dev = NULL;
@


1.14
log
@missing dkio.h includes; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.13 2008/06/26 05:42:17 ray Exp $	*/
d601 1
a601 1
			VOP_CLOSE(ac->vp, FREAD, NOCRED, 0);
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.12 2007/06/05 00:38:22 deraadt Exp $	*/
d83 1
@


1.12
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.11 2006/10/13 00:30:08 cloder Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@Get rid of another potentially unsafe pattern of foo[strlen(foo) - 1] = ...
OK krw, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.10 2003/11/27 20:13:27 henning Exp $	*/
d688 2
a689 2
		diskPtr->numBlocks = dpart.part->p_size - rf_protectedSectors;
 		diskPtr->partitionSize = dpart.part->p_size;
@


1.10
log
@on behalf of tdeval@@:
fix several errnous error messages (hah)
partitially from PR3566
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.9 2003/04/27 11:22:54 ho Exp $	*/
d652 1
a652 1
	if (p[strlen(p) - 1] == '\n') {
@


1.9
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.8 2003/01/19 14:32:00 tdeval Exp $	*/
d300 4
a303 4
			RF_ERRORMSG3("Spare disk %s (%d blocks) is too small"
			    " to serve as a spare (need %ld blocks).\n",
			    disks[i].devname, disks[i].blockSize,
			    (long int) raidPtr->sectorsPerDisk);
d309 2
a310 2
				    " %s to %ld blocks.\n", disks[i].devname,
				    (long int) raidPtr->sectorsPerDisk);
d1113 4
a1116 4
		RF_ERRORMSG3("Spare disk %s (%d blocks) is too small to serve"
		    " as a spare (need %ld blocks).\n",
		    disks[spare_number].devname, disks[spare_number].blockSize,
		    (long int) raidPtr->sectorsPerDisk);
d1122 1
a1122 1
			RF_ERRORMSG2("Warning: truncating spare disk %s to %ld"
d1124 1
a1124 1
			    (long int) raidPtr->sectorsPerDisk);
@


1.8
log
@Temporary fix for PR#3069 (thanks for the report, Alex Cichowski), until
I find time to really follow all cases.
At least it works here, and doesn't add new problems, it seems.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.7 2002/12/16 07:01:03 tdeval Exp $	*/
d521 2
a522 1
				sprintf(diskPtr->devname, "/dev/%s",
d587 2
a588 1
				sprintf(disks[r][c].devname, "component%d",
d656 1
a656 1
	(void) strcpy(diskPtr->devname, p);
@


1.7
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.6 2000/08/08 16:07:40 peter Exp $	*/
a655 1
#if 0
a656 3
#else
	proc = curproc;
#endif
d664 1
a664 1
	error = raidlookup(diskPtr->devname, proc, &vp);
@


1.6
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.5 2000/01/11 18:02:21 peter Exp $	*/
d3 2
a4 1
/*-
d21 2
a22 2
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
d67 1
a67 1
 * rf_disks.c -- code to perform operations on the actual disks
d91 1
a91 1
#ifdef __NETBSD__
d93 1
a93 1
#endif
d95 5
a99 5
static int rf_AllocDiskStructures(RF_Raid_t *, RF_Config_t *);
static void rf_print_label_status( RF_Raid_t *, int, int, char *, 
				  RF_ComponentLabel_t *);
static int rf_check_label_vitals( RF_Raid_t *, int, int, char *, 
				  RF_ComponentLabel_t *, int, int );
d101 2
a102 2
#define DPRINTF6(a,b,c,d,e,f) if (rf_diskDebug) printf(a,b,c,d,e,f)
#define DPRINTF7(a,b,c,d,e,f,g) if (rf_diskDebug) printf(a,b,c,d,e,f,g)
d106 1
a106 1
 * initialize the disks comprising the array
d108 6
a113 6
 * We want the spare disks to have regular row,col numbers so that we can 
 * easily substitue a spare for a failed disk.  But, the driver code assumes 
 * throughout that the array contains numRow by numCol _non-spare_ disks, so 
 * it's not clear how to fit in the spares.  This is an unfortunate holdover
 * from raidSim.  The quick and dirty fix is to make row zero bigger than the 
 * rest, and put all the spares in it.  This probably needs to get changed 
d117 3
a119 5
int 
rf_ConfigureDisks( listp, raidPtr, cfgPtr )
	RF_ShutdownList_t **listp;
	RF_Raid_t *raidPtr;
	RF_Config_t *cfgPtr;
d124 1
a124 1
	int     bs, ret;
d126 1
a126 1
	int	force;
d129 1
a129 1
 
d135 1
a135 1
 
d139 2
a140 3
			ret = rf_ConfigureDisk(raidPtr, 
					       &cfgPtr->devnames[r][c][0],
					       &disks[r][c], r, c);
d157 2
a158 1
				DPRINTF7("Disk at row %d col %d: dev %s numBlocks %ld blockSize %d (%ld MB)\n",
d163 1
a163 1
					 disks[r][c].blockSize / 1024 / 1024);
d166 5
a170 3
		/* XXX fix for n-fault tolerant */
		/* XXX this should probably check to see how many failures
		   we can handle for this configuration! */
d174 4
a177 2
	/* all disks must be the same size & have the same block size, bs must
	 * be a power of 2 */
d188 2
a189 1
		RF_ERRORMSG("RAIDFRAME: Did not find any live disks in the array.\n");
d197 2
a198 1
		RF_ERRORMSG1("Error: block size on disks (%d) must be a power of 2\n", bs);
d203 1
a203 1
	if (rf_CheckLabels( raidPtr, cfgPtr )) {
d207 1
a207 1
			       raidPtr->raidid);
d211 1
a211 1
		} 
d218 3
a220 1
					RF_ERRORMSG2("Error: block size of disk at r %d c %d different from disk at r 0 c 0\n", r, c);
d225 2
a226 1
					RF_ERRORMSG3("WARNING: truncating disk at r %d c %d to %d blocks\n",
d241 1
a241 1
	rf_UnconfigureVnodes( raidPtr );
d248 2
a249 2
 * set up the data structures describing the spare disks in the array
 * recall from the above comment that the spare disk descriptors are stored
d252 3
a254 5
int 
rf_ConfigureSpareDisks( listp, raidPtr, cfgPtr )
	RF_ShutdownList_t ** listp;
	RF_Raid_t * raidPtr;
	RF_Config_t * cfgPtr;
d256 1
a256 1
	int     i, ret;
d259 1
a259 1
	int     num_spares_done;
d263 4
a266 2
	/* The space for the spares should have already been allocated by
	 * ConfigureDisks() */
d271 1
a271 1
				       &disks[i], 0, raidPtr->numCol + i);
d275 2
a276 2
			RF_ERRORMSG1("Warning: spare disk %s failed TUR\n", 
				     &cfgPtr->spare_names[i][0]);
d278 4
a281 4
			disks[i].status = rf_ds_spare;	/* change status to
							 * spare */
			DPRINTF6("Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\n", i,
			    disks[i].devname,
d283 2
a284 2
			    (long int) disks[i].numBlocks * 
				 disks[i].blockSize / 1024 / 1024);
d289 1
a289 1
	/* check sizes and block sizes on spare disks */
d293 3
a295 1
			RF_ERRORMSG3("Block size of %d on spare disk %s is not the same as on other disks (%d)\n", disks[i].blockSize, disks[i].devname, bs);
d300 4
a303 3
			RF_ERRORMSG3("Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\n",
				     disks[i].devname, disks[i].blockSize, 
				     (long int) raidPtr->sectorsPerDisk);
d308 3
a310 1
				RF_ERRORMSG2("Warning: truncating spare disk %s to %ld blocks\n", disks[i].devname, (long int) raidPtr->sectorsPerDisk);
d320 10
a329 2
	/* Release the hold on the main components.  We've failed to allocate
	 * a spare, and since we're failing, we need to free things.. 
d331 1
a331 6
	 XXX failing to allocate a spare is *not* that big of a deal... 
	 We *can* survive without it, if need be, esp. if we get hot
	 adding working.  
	 If we don't fail out here, then we need a way to remove this spare... 
	 that should be easier to do here than if we are "live"... 
	 */
a332 2
	rf_UnconfigureVnodes( raidPtr );
	
d336 2
a337 4
static int
rf_AllocDiskStructures(raidPtr, cfgPtr)
	RF_Raid_t *raidPtr;
 	RF_Config_t *cfgPtr;
d343 2
a344 2
	RF_CallocAndAdd(disks, raidPtr->numRow, sizeof(RF_RaidDisk_t *), 
			(RF_RaidDisk_t **), raidPtr->cleanupList);
d350 1
a350 1
	/* get space for the device-specific stuff... */
d360 7
a366 6
		/* We allocate RF_MAXSPARE on the first row so that we
		   have room to do hot-swapping of spares */
		RF_CallocAndAdd(disks[r], raidPtr->numCol 
				+ ((r == 0) ? RF_MAXSPARE : 0), 
				sizeof(RF_RaidDisk_t), (RF_RaidDisk_t *), 
				raidPtr->cleanupList);
d371 3
a373 3
		/* get more space for device specific stuff.. */
		RF_CallocAndAdd(raidPtr->raid_cinfo[r],
		    raidPtr->numCol + ((r == 0) ? raidPtr->numSpare : 0),
d382 2
a383 2
fail:	
	rf_UnconfigureVnodes( raidPtr );
d389 1
a389 1
/* configure a single disk during auto-configuration at boot */
d391 2
a392 4
rf_AutoConfigureDisks(raidPtr, cfgPtr, auto_config)
	RF_Raid_t *raidPtr;
	RF_Config_t *cfgPtr;
	RF_AutoConfig_t *auto_config;
d396 1
a396 1
	RF_RowCol_t r, c;	
d406 1
a406 1
#if DEBUG
d408 1
a408 1
#endif
d417 1
a417 1
	/* assume the parity will be fine.. */
d420 1
a420 1
	/* Check for mod_counters that are too low */
d424 1
a424 1
		if (mod_counter_found==0) {
d432 1
a432 1
		ac->flag = 0; /* clear the general purpose flag */
d441 4
a444 4
			/* find this row/col in the autoconfig */
#if DEBUG
			printf("Looking for %d,%d in autoconfig\n",r,c);
#endif
d447 2
a448 2
				if (ac->clabel==NULL) {
					/* big-time bad news. */
d454 5
a458 3
					/* it's this one... */
					/* flag it as 'used', so we don't
					   free it later. */
d460 5
a464 5
#if DEBUG
					printf("Found: %s at %d,%d\n",
					       ac->devname,r,c);
#endif
					
d467 1
a467 1
				ac=ac->next;
d470 9
a478 8
			if (ac==NULL) {
				/* we didn't find an exact match with a 
				   correct mod_counter above... can we
				   find one with an incorrect mod_counter
				   to use instead?  (this one, if we find
				   it, will be marked as failed once the 
				   set configures) 
				*/
d482 2
a483 2
					if (ac->clabel==NULL) {
						/* big-time bad news. */
d488 5
a492 3
						/* it's this one... 
						   flag it as 'used', so we 
						   don't free it later. */
d494 6
a499 5
#if DEBUG
						printf("Found(low mod_counter): %s at %d,%d\n",
						       ac->devname,r,c);
#endif
						
d502 1
a502 1
					ac=ac->next;
d509 1
a509 1
				/* Found it.  Configure it.. */
d512 4
a515 2
				/* Note: rf_protectedSectors is already 
				   factored into numBlocks here */
d520 9
a528 7
				       ac->clabel, sizeof(*ac->clabel));
				sprintf(diskPtr->devname, "/dev/%s", 
					ac->devname);
				
				/* note the fact that this component was
				   autoconfigured.  You'll need this info
				   later.  Trust me :) */
d531 3
a533 3
			
				/* 
				 * we allow the user to specify that
d535 2
a536 2
				 * be used this is just for debug: it
				 * speeds up the parity scan 
d539 1
a539 1
				diskPtr->numBlocks = diskPtr->numBlocks * 
d542 6
a547 4
				/* XXX these will get set multiple times, 
				   but since we're autoconfiguring, they'd
				   better be always the same each time!
				   If not, this is the least of your worries */
d552 20
a571 15
				/* this gets done multiple times, but that's
				   fine -- the serial number will be the same
				   for all components, guaranteed */
				raidPtr->serial_number = 
					ac->clabel->serial_number;
				/* check the last time the label
				   was modified */
				if (ac->clabel->mod_counter !=
				    mod_counter) {
					/* Even though we've filled in all
					   of the above, we don't trust
					   this component since it's 
					   modification counter is not
					   in sync with the rest, and we really
					   consider it to be failed.  */
d575 2
a576 2
					if (ac->clabel->clean != 
					    RF_RAID_CLEAN) {
d581 4
a584 2
				/* Didn't find it at all!! 
				   Component must really be dead */
d586 2
a587 2
				sprintf(disks[r][c].devname,"component%d",
					r * raidPtr->numCol + c);
d591 5
a595 3
		/* XXX fix for n-fault tolerant */
		/* XXX this should probably check to see how many failures
		   we can handle for this configuration! */
d600 1
a600 1
	/* close the device for the ones that didn't get used */
d603 1
a603 1
	while(ac!=NULL) {
d608 1
a608 1
#if DEBUG 
d610 2
a611 2
			       ac->devname);
#endif
d618 1
a618 1
	/* note the state of the parity, if any */
d627 2
a628 2
	
	rf_UnconfigureVnodes( raidPtr );
d634 4
a637 8
/* configure a single disk in the array */
int 
rf_ConfigureDisk(raidPtr, buf, diskPtr, row, col)
	RF_Raid_t *raidPtr;
	char   *buf;
	RF_RaidDisk_t *diskPtr;
	RF_RowCol_t row;
	RF_RowCol_t col;
d639 2
a640 2
	char   *p;
	int     retcode;
d646 1
a646 1
	int     error;
d651 1
a651 1
		/* strip off the newline */
d670 1
a670 1
		printf("raidlookup on device: %s failed!\n", diskPtr->devname);
d672 1
a672 1
			/* the component isn't there... must be dead :-( */
d683 2
a684 2
		error = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,
		    FREAD, proc->p_ucred, proc);
d692 1
a692 1
 
d696 1
a696 1
 		/* This component was not automatically configured */
d700 7
a706 5
		/* we allow the user to specify that only a fraction of the
		 * disks should be used this is just for debug:  it speeds up
		 * the parity scan */
		diskPtr->numBlocks = diskPtr->numBlocks * 
			rf_sizePercentage / 100;
d711 3
a713 7
static void
rf_print_label_status( raidPtr, row, column, dev_name, ci_label )
	RF_Raid_t *raidPtr;
	int row;
	int column;
	char *dev_name;
	RF_ComponentLabel_t *ci_label;
d716 2
a717 2
	printf("raid%d: Component %s being configured at row: %d col: %d\n", 
	       raidPtr->raidid, dev_name, row, column );
d719 2
a720 2
	       ci_label->row, ci_label->column, 
	       ci_label->num_rows, ci_label->num_columns);
d722 1
a722 2
	       ci_label->version, ci_label->serial_number,
	       ci_label->mod_counter);
d724 1
a724 1
	       ci_label->clean ? "Yes" : "No", ci_label->status );
d727 3
a729 9
static int rf_check_label_vitals( raidPtr, row, column, dev_name, ci_label,
				  serial_number, mod_counter )
	RF_Raid_t *raidPtr;
	int row;
	int column;
	char *dev_name;
	RF_ComponentLabel_t *ci_label;
	int serial_number;
	int mod_counter;
d734 2
a735 2
		printf("%s has a different serial number: %d %d\n", 
		       dev_name, serial_number, ci_label->serial_number);
d739 2
a740 2
		printf("%s has a different modfication count: %d %d\n",
		       dev_name, mod_counter, ci_label->mod_counter);
d742 1
a742 1
	
d744 1
a744 1
		printf("Row out of alignment for: %s\n", dev_name); 
d748 1
a748 1
		printf("Column out of alignment for: %s\n", dev_name);
d752 1
a752 1
		printf("Number of rows do not match for: %s\n", dev_name);
d756 1
a756 1
		printf("Number of columns do not match for: %s\n", dev_name);
d760 2
a761 2
		/* it's not clean, but that's not fatal */
		printf("%s is not clean!\n", dev_name);
d767 5
a771 5
/* 

   rf_CheckLabels() - check all the component labels for consistency.
   Return an error if there is anything major amiss.

d774 2
a775 4
int 
rf_CheckLabels( raidPtr, cfgPtr )
	RF_Raid_t *raidPtr;
	RF_Config_t *cfgPtr;
d777 1
a777 1
	int r,c;
d802 14
a815 14
	/* 
	   We're going to try to be a little intelligent here.  If one 
	   component's label is bogus, and we can identify that it's the
	   *only* one that's gone, we'll mark it as "failed" and allow
	   the configuration to proceed.  This will be the *only* case
	   that we'll proceed if there would be (otherwise) fatal errors.
	   
	   Basically we simply keep a count of how many components had
	   what serial number.  If all but one agree, we simply mark
	   the disagreeing component as being failed, and allow 
	   things to come up "normally".
	   
	   We do this first for serial numbers, and then for "mod_counter".

d820 1
a820 1
	for (r = 0; r < raidPtr->numRow && !fatal_error ; r++) {
d823 2
a824 2
			found=0;
			for(i=0;i<num_ser;i++) {
d827 1
a827 1
					found=1;
d835 1
a835 1
				if (num_ser>2) {
d840 2
a841 2
			found=0;
			for(i=0;i<num_mod;i++) {
d844 1
a844 1
					found=1;
d849 1
a849 1
			        mod_values[num_mod] = ci_label->mod_counter;
d852 1
a852 1
				if (num_mod>2) {
d859 1
a859 1
#if DEBUG
d861 1
a861 1
	for(i=0;i<num_ser;i++) {
d865 1
a865 1
	for(i=0;i<num_mod;i++) {
d868 1
a868 1
#endif
d872 1
a872 1
			/* Locate the maverick component */
d875 1
a875 1
			} 
d878 3
a880 2
				ci_label = &raidPtr->raid_cinfo[r][c].ci_label;
					if (serial_number != 
d888 2
a889 2
			printf("Hosed component: %s\n",
			       &cfgPtr->devnames[hosed_row][hosed_column][0]);
d891 5
a895 3
				/* we'll fail this component, as if there are
				   other major errors, we arn't forcing things
				   and we'll abort the config anyways */
d897 1
a897 1
					= rf_ds_failed;
d905 4
a908 2
			/* We've identified two different serial numbers. 
			   RAID 0 can't cope with that, so we'll punt */
d912 1
a912 1
	} 
d914 5
a918 3
	/* record the serial number for later.  If we bail later, setting
	   this doesn't matter, otherwise we've got the best guess at the 
	   correct serial number */
d924 1
a924 1
			/* Locate the maverick component */
d930 6
a935 4
				/* counts of different modification values
				   are the same.   Assume greater value is 
				   the correct one, all other things 
				   considered */
d941 1
a941 1
				
d943 1
a943 1
			for (r = 0; r < raidPtr->numRow && !too_fatal ; r++) {
d945 3
a947 2
					ci_label = &raidPtr->raid_cinfo[r][c].ci_label;
					if (mod_number != 
d949 6
a954 4
						if ( ( hosed_row == r ) &&
						     ( hosed_column == c )) {
							/* same one.  Can
							   deal with it.  */
d966 2
a967 2
			printf("Hosed component: %s\n",
			       &cfgPtr->devnames[hosed_row][hosed_column][0]);
d969 11
a979 6
				/* we'll fail this component, as if there are
				   other major errors, we arn't forcing things
				   and we'll abort the config anyways */
				if (raidPtr->Disks[hosed_row][hosed_column].status != rf_ds_failed) {
					raidPtr->Disks[hosed_row][hosed_column].status
						= rf_ds_failed;
d981 2
a982 1
					raidPtr->status[hosed_row] = rf_rs_degraded;
d989 4
a992 2
			/* We've identified two different mod counters.
			   RAID 0 can't cope with that, so we'll punt */
d995 1
a995 1
	} 
d1000 6
a1005 4
		/* we've had both a serial number mismatch, and a mod_counter
		   mismatch -- and they involved two different components!!
		   Bail -- make things fail so that the user must force
		   the issue... */
d1011 2
a1012 2
		printf("raid%d: Too many different serial numbers!\n", 
		       raidPtr->raidid);
d1016 2
a1017 2
		printf("raid%d: Too many different mod counters!\n", 
		       raidPtr->raidid);
d1020 4
a1023 2
	/* we start by assuming the parity will be good, and flee from
	   that notion at the slightest sign of trouble */
d1032 8
a1039 9
				printf("raid%d: Ignoring %s\n",
				       raidPtr->raidid, dev_name);
			} else {			
				rf_print_label_status( raidPtr, r, c, 
						       dev_name, ci_label );
				if (rf_check_label_vitals( raidPtr, r, c, 
							   dev_name, ci_label,
							   serial_number, 
							   mod_number )) {
d1052 1
a1052 1
	/* we note the state of the parity */
d1055 1
a1055 1
	return(fatal_error);	
d1059 1
a1059 3
rf_add_hot_spare(raidPtr, sparePtr)
	RF_Raid_t *raidPtr;
	RF_SingleComponent_t *sparePtr;
d1068 2
a1069 2
	printf("Just in rf_add_hot_spare: %d\n",raidPtr->numSpare);
	printf("Num col: %d\n",raidPtr->numCol);
d1072 1
a1072 1
		RF_ERRORMSG1("Too many spares: %d\n", raidPtr->numSpare);
d1078 1
a1078 1
	/* the beginning of the spares... */
d1084 1
a1084 2
			       &disks[spare_number], 0,
			       raidPtr->numCol + spare_number);
d1089 3
a1091 3
		RF_ERRORMSG1("Warning: spare disk %s failed TUR\n", 
			     sparePtr->component_name);
		ret=EINVAL;
d1095 6
a1100 6
		DPRINTF6("Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\n", spare_number,
			 disks[spare_number].devname,
			 (long int) disks[spare_number].numBlocks, 
			 disks[spare_number].blockSize,
			 (long int) disks[spare_number].numBlocks * 
			 disks[spare_number].blockSize / 1024 / 1024);
a1101 1
	
d1103 2
a1104 1
	/* check sizes and block sizes on the spare disk */
d1107 4
a1110 1
		RF_ERRORMSG3("Block size of %d on spare disk %s is not the same as on other disks (%d)\n", disks[spare_number].blockSize, disks[spare_number].devname, bs);
d1115 4
a1118 4
		RF_ERRORMSG3("Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\n",
			     disks[spare_number].devname, 
			     disks[spare_number].blockSize, 
			     (long int) raidPtr->sectorsPerDisk);
d1122 1
a1122 1
		if (disks[spare_number].numBlocks > 
d1124 4
a1127 3
			RF_ERRORMSG2("Warning: truncating spare disk %s to %ld blocks\n", disks[spare_number].devname, 
				     (long int) raidPtr->sectorsPerDisk);
			
d1133 6
a1138 10
	ret = rf_ConfigureDiskQueue( raidPtr, &spareQueues[spare_number],
				 0, raidPtr->numCol + spare_number, 
				 raidPtr->qType,
				 raidPtr->sectorsPerDisk,
				 raidPtr->Disks[0][raidPtr->numCol + 
						  spare_number].dev,
				 raidPtr->maxOutstanding,
				 &raidPtr->shutdownList,
				 raidPtr->cleanupList);
				 
d1150 1
a1150 3
rf_remove_hot_spare(raidPtr,sparePtr)
	RF_Raid_t *raidPtr;
	RF_SingleComponent_t *sparePtr;
d1154 2
a1155 3

	if (raidPtr->numSpare==0) {
		printf("No spares to remove!\n");
d1161 1
a1161 1
	return(EINVAL); /* XXX not implemented yet */
d1167 1
a1167 1
	/* verify that this spare isn't in use... */
d1169 1
a1169 1
	/* it's gone.. */
d1178 1
a1178 3
rf_delete_component(raidPtr,component)
	RF_Raid_t *raidPtr;
	RF_SingleComponent_t *component;
d1182 1
a1182 1
	if ((component->row < 0) || 
d1184 1
a1184 1
	    (component->column < 0) || 
d1191 1
a1191 1
	/* 1. This component must be marked as 'failed' */
d1197 1
a1197 3
rf_incorporate_hot_spare(raidPtr,component)
	RF_Raid_t *raidPtr;
	RF_SingleComponent_t *component;
d1200 4
a1203 2
	/* Issues here include how to 'move' this in if there is IO 
	   taking place (e.g. component queues and such) */
@


1.6.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 2

/*
d20 2
a21 2
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
d66 1
a66 1
 * rf_disks.c -- Code to perform operations on the actual disks.
d90 1
a90 1
#ifdef	__NETBSD__
d92 1
a92 1
#endif	/* __NETBSD__ */
d94 5
a98 5
int  rf_AllocDiskStructures(RF_Raid_t *, RF_Config_t *);
void rf_print_label_status(RF_Raid_t *, int, int, char *,
	RF_ComponentLabel_t *);
int  rf_check_label_vitals(RF_Raid_t *, int, int, char *,
	RF_ComponentLabel_t *, int, int);
d100 2
a101 2
#define	DPRINTF6(a,b,c,d,e,f)	if (rf_diskDebug) printf(a,b,c,d,e,f)
#define	DPRINTF7(a,b,c,d,e,f,g)	if (rf_diskDebug) printf(a,b,c,d,e,f,g)
d105 1
a105 1
 * Initialize the disks comprising the array.
d107 6
a112 6
 * We want the spare disks to have regular row,col numbers so that we can
 * easily substitue a spare for a failed disk. But, the driver code assumes
 * throughout that the array contains numRow by numCol _non-spare_ disks, so
 * it's not clear how to fit in the spares. This is an unfortunate holdover
 * from raidSim. The quick and dirty fix is to make row zero bigger than the
 * rest, and put all the spares in it. This probably needs to get changed
d116 5
a120 3
int
rf_ConfigureDisks(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d125 1
a125 1
	int bs, ret;
d127 1
a127 1
	int force;
d130 1
a130 1

d136 1
a136 1

d140 3
a142 2
			ret = rf_ConfigureDisk(raidPtr,
			    &cfgPtr->devnames[r][c][0], &disks[r][c], r, c);
d159 1
a159 2
				DPRINTF7("Disk at row %d col %d: dev %s"
				    " numBlocks %ld blockSize %d (%ld MB)\n",
d164 1
a164 1
				     disks[r][c].blockSize / 1024 / 1024);
d167 3
a169 5
		/* XXX Fix for n-fault tolerant. */
		/*
		 * XXX This should probably check to see how many failures
		 * we can handle for this configuration !
		 */
d173 2
a174 4
	/*
	 * All disks must be the same size & have the same block size, bs must
	 * be a power of 2.
	 */
d185 1
a185 2
		RF_ERRORMSG("RAIDFRAME: Did not find any live disks in"
		    " the array.\n");
d193 1
a193 2
		RF_ERRORMSG1("Error: block size on disks (%d) must be a"
		    " power of 2.\n", bs);
d198 1
a198 1
	if (rf_CheckLabels(raidPtr, cfgPtr)) {
d202 1
a202 1
			    raidPtr->raidid);
d206 1
a206 1
		}
d213 1
a213 3
					RF_ERRORMSG2("Error: block size of"
					    " disk at r %d c %d different from"
					    " disk at r 0 c 0.\n", r, c);
d218 1
a218 2
					RF_ERRORMSG3("WARNING: truncating disk"
					    " at r %d c %d to %d blocks.\n",
d233 1
a233 1
	rf_UnconfigureVnodes(raidPtr);
d240 2
a241 2
 * Set up the data structures describing the spare disks in the array.
 * Recall from the above comment that the spare disk descriptors are stored
d244 5
a248 3
int
rf_ConfigureSpareDisks(RF_ShutdownList_t ** listp, RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d250 1
a250 1
	int i, ret;
d253 1
a253 1
	int num_spares_done;
d257 2
a258 4
	/*
	 * The space for the spares should have already been allocated by
	 * ConfigureDisks().
	 */
d263 1
a263 1
		    &disks[i], 0, raidPtr->numCol + i);
d267 2
a268 2
			RF_ERRORMSG1("Warning: spare disk %s failed TUR\n",
			    &cfgPtr->spare_names[i][0]);
d270 4
a273 4
			/* Change status to spare. */
			disks[i].status = rf_ds_spare;
			DPRINTF6("Spare Disk %d: dev %s numBlocks %ld"
			    " blockSize %d (%ld MB).\n", i, disks[i].devname,
d275 2
a276 2
			    (long int) disks[i].numBlocks *
			    disks[i].blockSize / 1024 / 1024);
d281 1
a281 1
	/* Check sizes and block sizes on spare disks. */
d285 1
a285 3
			RF_ERRORMSG3("Block size of %d on spare disk %s is"
			    " not the same as on other disks (%d).\n",
			    disks[i].blockSize, disks[i].devname, bs);
d290 3
a292 4
			RF_ERRORMSG3("Spare disk %s (%d blocks) is too small"
			    " to serve as a spare (need %ld blocks).\n",
			    disks[i].devname, disks[i].blockSize,
			    (long int) raidPtr->sectorsPerDisk);
d297 1
a297 3
				RF_ERRORMSG2("Warning: truncating spare disk"
				    " %s to %ld blocks.\n", disks[i].devname,
				    (long int) raidPtr->sectorsPerDisk);
d307 8
a314 9
	/*
	 * Release the hold on the main components. We've failed to allocate
	 * a spare, and since we're failing, we need to free things...
	 *
	 * XXX Failing to allocate a spare is *not* that big of a deal...
	 * We *can* survive without it, if need be, esp. if we get hot
	 * adding working.
	 * If we don't fail out here, then we need a way to remove this spare...
	 * That should be easier to do here than if we are "live"...
d317 2
a318 2
	rf_UnconfigureVnodes(raidPtr);

d322 4
a325 2
int
rf_AllocDiskStructures(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr)
d331 2
a332 2
	RF_CallocAndAdd(disks, raidPtr->numRow, sizeof(RF_RaidDisk_t *),
	    (RF_RaidDisk_t **), raidPtr->cleanupList);
d338 1
a338 1
	/* Get space for the device-specific stuff... */
d348 6
a353 7
		/*
		 * We allocate RF_MAXSPARE on the first row so that we
		 * have room to do hot-swapping of spares.
		 */
		RF_CallocAndAdd(disks[r], raidPtr->numCol +
		    ((r == 0) ? RF_MAXSPARE : 0), sizeof(RF_RaidDisk_t),
		    (RF_RaidDisk_t *), raidPtr->cleanupList);
d358 3
a360 3
		/* Get more space for device specific stuff... */
		RF_CallocAndAdd(raidPtr->raid_cinfo[r], raidPtr->numCol +
		    ((r == 0) ? raidPtr->numSpare : 0),
d369 2
a370 2
fail:
	rf_UnconfigureVnodes(raidPtr);
d376 1
a376 1
/* Configure a single disk during auto-configuration at boot. */
d378 4
a381 2
rf_AutoConfigureDisks(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr,
    RF_AutoConfig_t *auto_config)
d385 1
a385 1
	RF_RowCol_t r, c;
d395 1
a395 1
#if	DEBUG
d397 1
a397 1
#endif	/* DEBUG */
d406 1
a406 1
	/* Assume the parity will be fine... */
d409 1
a409 1
	/* Check for mod_counters that are too low. */
d413 1
a413 1
		if (mod_counter_found == 0) {
d421 1
a421 1
		ac->flag = 0; /* Clear the general purpose flag. */
d430 4
a433 4
			/* Find this row/col in the autoconfig. */
#if	DEBUG
			printf("Looking for %d,%d in autoconfig.\n", r, c);
#endif	/* DEBUG */
d436 2
a437 2
				if (ac->clabel == NULL) {
					/* Big-time bad news. */
d443 3
a445 5
					/* It's this one... */
					/*
					 * Flag it as 'used', so we don't
					 * free it later.
					 */
d447 5
a451 5
#if	DEBUG
					printf("Found: %s at %d,%d.\n",
					    ac->devname, r, c);
#endif	/* DEBUG */

d454 1
a454 1
				ac = ac->next;
d457 8
a464 9
			if (ac == NULL) {
				/*
				 * We didn't find an exact match with a
				 * correct mod_counter above...  Can we
				 * find one with an incorrect mod_counter
				 * to use instead ?  (This one, if we find
				 * it, will be marked as failed once the
				 * set configures)
				 */
d468 2
a469 2
					if (ac->clabel == NULL) {
						/* Big-time bad news. */
d474 3
a476 5
						/*
						 * It's this one...
						 * Flag it as 'used', so we
						 * don't free it later.
						 */
d478 5
a482 6
#if	DEBUG
						printf("Found(low mod_counter)"
						    ": %s at %d,%d.\n",
						    ac->devname, r, c);
#endif	/* DEBUG */

d485 1
a485 1
					ac = ac->next;
d492 1
a492 1
				/* Found it. Configure it... */
d495 2
a496 4
				/*
				 * Note: rf_protectedSectors is already
				 * factored into numBlocks here.
				 */
d501 7
a507 10
				    ac->clabel, sizeof(*ac->clabel));
				snprintf(diskPtr->devname,
				    sizeof diskPtr->devname, "/dev/%s",
				    ac->devname);

				/*
				 * Note the fact that this component was
				 * autoconfigured. You'll need this info
				 * later. Trust me :)
				 */
d510 3
a512 3

				/*
				 * We allow the user to specify that
d514 2
a515 2
				 * be used. This is just for debug: it
				 * speeds up the parity scan.
d518 1
a518 1
				diskPtr->numBlocks = diskPtr->numBlocks *
d521 4
a524 6
				/*
				 * XXX These will get set multiple times,
				 * but since we're autoconfiguring, they'd
				 * better be always the same each time !
				 * If not, this is the least of your worries.
				 */
d529 15
a543 20
				/*
				 * This gets done multiple times, but that's
				 * fine -- the serial number will be the same
				 * for all components, guaranteed.
				 */
				raidPtr->serial_number =
				    ac->clabel->serial_number;
				/*
				 * Check the last time the label
				 * was modified.
				 */
				if (ac->clabel->mod_counter != mod_counter) {
					/*
					 * Even though we've filled in all
					 * of the above, we don't trust
					 * this component since it's
					 * modification counter is not
					 * in sync with the rest, and we really
					 * consider it to be failed.
					 */
d547 2
a548 2
					if (ac->clabel->clean != RF_RAID_CLEAN)
					{
d553 2
a554 4
				/*
				 * Didn't find it at all !!!
				 * Component must really be dead.
				 */
d556 2
a557 3
				snprintf(disks[r][c].devname,
				    sizeof disks[r][c].devname, "component%d",
				    r * raidPtr->numCol + c);
d561 3
a563 5
		/* XXX Fix for n-fault tolerant. */
		/*
		 * XXX This should probably check to see how many failures
		 * we can handle for this configuration !
		 */
d568 1
a568 1
	/* Close the device for the ones that didn't get used. */
d571 1
a571 1
	while(ac != NULL) {
d576 1
a576 1
#if	DEBUG
d578 2
a579 2
			    ac->devname);
#endif  /* DEBUG */
d586 1
a586 1
	/* Note the state of the parity, if any. */
d595 2
a596 2

	rf_UnconfigureVnodes(raidPtr);
d602 8
a609 4
/* Configure a single disk in the array. */
int
rf_ConfigureDisk(RF_Raid_t *raidPtr, char *buf, RF_RaidDisk_t *diskPtr,
    RF_RowCol_t row, RF_RowCol_t col)
d611 2
a612 2
	char *p;
	int retcode;
d618 1
a618 1
	int error;
d623 1
a623 1
		/* Strip off the newline. */
d626 1
a626 1
	(void) strlcpy(diskPtr->devname, p, sizeof diskPtr->devname);
d628 1
d630 3
d640 1
a640 1
	error = raidlookup(diskPtr->devname, curproc, &vp);
d642 1
a642 1
		printf("raidlookup on device: %s failed !\n", diskPtr->devname);
d644 1
a644 1
			/* The component isn't there...  Must be dead :-( */
d655 2
a656 2
		error = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart, FREAD,
		    proc->p_ucred, proc);
d664 1
a664 1

d668 1
a668 1
 		/* This component was not automatically configured. */
d672 5
a676 7
		/*
		 * We allow the user to specify that only a fraction of the
		 * disks should be used. This is just for debug: it speeds up
		 * the parity scan.
		 */
		diskPtr->numBlocks = diskPtr->numBlocks * rf_sizePercentage
		    / 100;
d681 7
a687 3
void
rf_print_label_status(RF_Raid_t *raidPtr, int row, int column, char *dev_name,
    RF_ComponentLabel_t *ci_label)
d690 2
a691 2
	printf("raid%d: Component %s being configured at row: %d col: %d\n",
	    raidPtr->raidid, dev_name, row, column);
d693 2
a694 2
	    ci_label->row, ci_label->column, ci_label->num_rows,
	    ci_label->num_columns);
d696 2
a697 1
	    ci_label->version, ci_label->serial_number, ci_label->mod_counter);
d699 1
a699 1
	    ci_label->clean ? "Yes" : "No", ci_label->status);
d702 9
a710 3
int
rf_check_label_vitals(RF_Raid_t *raidPtr, int row, int column, char *dev_name,
    RF_ComponentLabel_t *ci_label, int serial_number, int mod_counter)
d715 2
a716 2
		printf("%s has a different serial number: %d %d.\n",
		    dev_name, serial_number, ci_label->serial_number);
d720 2
a721 2
		printf("%s has a different modfication count: %d %d.\n",
		    dev_name, mod_counter, ci_label->mod_counter);
d723 1
a723 1

d725 1
a725 1
		printf("Row out of alignment for: %s.\n", dev_name);
d729 1
a729 1
		printf("Column out of alignment for: %s.\n", dev_name);
d733 1
a733 1
		printf("Number of rows do not match for: %s.\n", dev_name);
d737 1
a737 1
		printf("Number of columns do not match for: %s.\n", dev_name);
d741 2
a742 2
		/* It's not clean, but that's not fatal. */
		printf("%s is not clean !\n", dev_name);
d748 5
a752 5
/*
 *
 * rf_CheckLabels() - Check all the component labels for consistency.
 * Return an error if there is anything major amiss.
 *
d755 4
a758 2
int
rf_CheckLabels(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr)
d760 1
a760 1
	int r, c;
d785 14
a798 14
	/*
	 * We're going to try to be a little intelligent here. If one
	 * component's label is bogus, and we can identify that it's the
	 * *only* one that's gone, we'll mark it as "failed" and allow
	 * the configuration to proceed. This will be the *only* case
	 * that we'll proceed if there would be (otherwise) fatal errors.
	 *
	 * Basically we simply keep a count of how many components had
	 * what serial number. If all but one agree, we simply mark
	 * the disagreeing component as being failed, and allow
	 * things to come up "normally".
	 *
	 * We do this first for serial numbers, and then for "mod_counter".
	 *
d803 1
a803 1
	for (r = 0; r < raidPtr->numRow && !fatal_error; r++) {
d806 2
a807 2
			found = 0;
			for(i = 0; i < num_ser; i++) {
d810 1
a810 1
					found = 1;
d818 1
a818 1
				if (num_ser > 2) {
d823 2
a824 2
			found = 0;
			for(i = 0; i < num_mod; i++) {
d827 1
a827 1
					found = 1;
d832 1
a832 1
				mod_values[num_mod] = ci_label->mod_counter;
d835 1
a835 1
				if (num_mod > 2) {
d842 1
a842 1
#if	DEBUG
d844 1
a844 1
	for(i = 0; i < num_ser; i++) {
d848 1
a848 1
	for(i = 0; i < num_mod; i++) {
d851 1
a851 1
#endif  /* DEBUG */
d855 1
a855 1
			/* Locate the maverick component. */
d858 1
a858 1
			}
d861 2
a862 3
					ci_label =
					    &raidPtr->raid_cinfo[r][c].ci_label;
					if (serial_number !=
d870 2
a871 2
			printf("Hosed component: %s.\n",
			    &cfgPtr->devnames[hosed_row][hosed_column][0]);
d873 3
a875 5
				/*
				 * We'll fail this component, as if there are
				 * other major errors, we aren't forcing things
				 * and we'll abort the config anyways.
				 */
d877 1
a877 1
				    = rf_ds_failed;
d885 2
a886 4
			/*
			 * We've identified two different serial numbers.
			 * RAID 0 can't cope with that, so we'll punt.
			 */
d890 1
a890 1
	}
d892 3
a894 5
	/*
	 * Record the serial number for later. If we bail later, setting
	 * this doesn't matter, otherwise we've got the best guess at the
	 * correct serial number.
	 */
d900 1
a900 1
			/* Locate the maverick component. */
d906 4
a909 6
				/*
				 * Counts of different modification values
				 * are the same. Assume greater value is
				 * the correct one, all other things
				 * considered.
				 */
d915 1
a915 1

d917 1
a917 1
			for (r = 0; r < raidPtr->numRow && !too_fatal; r++) {
d919 2
a920 3
					ci_label =
					    &raidPtr->raid_cinfo[r][c].ci_label;
					if (mod_number !=
d922 4
a925 6
						if ((hosed_row == r) &&
						    (hosed_column == c)) {
							/*
							 * Same one. Can
							 * deal with it.
							 */
d937 2
a938 2
			printf("Hosed component: %s.\n",
			    &cfgPtr->devnames[hosed_row][hosed_column][0]);
d940 6
a945 11
				/*
				 * We'll fail this component, as if there are
				 * other major errors, we aren't forcing things
				 * and we'll abort the config anyways.
				 */
				if (raidPtr
				    ->Disks[hosed_row][hosed_column].status !=
				    rf_ds_failed) {
					raidPtr->Disks[hosed_row]
					    [hosed_column].status =
					    rf_ds_failed;
d947 1
a947 2
					raidPtr->status[hosed_row] =
					    rf_rs_degraded;
d954 2
a955 4
			/*
			 * We've identified two different mod counters.
			 * RAID 0 can't cope with that, so we'll punt.
			 */
d958 1
a958 1
	}
d963 4
a966 6
		/*
		 * We've had both a serial number mismatch, and a mod_counter
		 * mismatch -- and they involved two different components !!!
		 * Bail -- make things fail so that the user must force
		 * the issue...
		 */
d972 2
a973 2
		printf("raid%d: Too many different serial numbers !\n",
		    raidPtr->raidid);
d977 2
a978 2
		printf("raid%d: Too many different mod counters !\n",
		    raidPtr->raidid);
d981 2
a982 4
	/*
	 * We start by assuming the parity will be good, and flee from
	 * that notion at the slightest sign of trouble.
	 */
d991 9
a999 8
				printf("raid%d: Ignoring %s.\n",
				    raidPtr->raidid, dev_name);
			} else {
				rf_print_label_status(raidPtr, r, c, dev_name,
				    ci_label);
				if (rf_check_label_vitals(raidPtr, r, c,
				     dev_name, ci_label, serial_number,
				     mod_number)) {
d1012 1
a1012 1
	/* We note the state of the parity. */
d1015 1
a1015 1
	return(fatal_error);
d1019 3
a1021 1
rf_add_hot_spare(RF_Raid_t *raidPtr, RF_SingleComponent_t *sparePtr)
d1030 2
a1031 2
	printf("Just in rf_add_hot_spare: %d.\n", raidPtr->numSpare);
	printf("Num col: %d.\n", raidPtr->numCol);
d1034 1
a1034 1
		RF_ERRORMSG1("Too many spares: %d.\n", raidPtr->numSpare);
d1040 1
a1040 1
	/* The beginning of the spares... */
d1046 2
a1047 1
	    &disks[spare_number], 0, raidPtr->numCol + spare_number);
d1052 3
a1054 3
		RF_ERRORMSG1("Warning: spare disk %s failed TUR.\n",
		    sparePtr->component_name);
		ret = EINVAL;
d1058 6
a1063 6
		DPRINTF6("Spare Disk %d: dev %s numBlocks %ld blockSize %d"
		    " (%ld MB).\n", spare_number, disks[spare_number].devname,
		    (long int) disks[spare_number].numBlocks,
		    disks[spare_number].blockSize,
		    (long int) disks[spare_number].numBlocks *
		     disks[spare_number].blockSize / 1024 / 1024);
d1065 1
d1067 1
a1067 2

	/* Check sizes and block sizes on the spare disk. */
d1070 1
a1070 4
		RF_ERRORMSG3("Block size of %d on spare disk %s is not"
		    " the same as on other disks (%d).\n",
		    disks[spare_number].blockSize,
		    disks[spare_number].devname, bs);
d1075 4
a1078 4
		RF_ERRORMSG3("Spare disk %s (%d blocks) is too small to serve"
		    " as a spare (need %ld blocks).\n",
		    disks[spare_number].devname, disks[spare_number].blockSize,
		    (long int) raidPtr->sectorsPerDisk);
d1082 1
a1082 1
		if (disks[spare_number].numBlocks >
d1084 3
a1086 4
			RF_ERRORMSG2("Warning: truncating spare disk %s to %ld"
			    " blocks.\n", disks[spare_number].devname,
			    (long int) raidPtr->sectorsPerDisk);

d1092 10
a1101 6
	ret = rf_ConfigureDiskQueue(raidPtr, &spareQueues[spare_number],
	    0, raidPtr->numCol + spare_number, raidPtr->qType,
	    raidPtr->sectorsPerDisk, raidPtr->Disks[0][raidPtr->numCol +
	     spare_number].dev, raidPtr->maxOutstanding,
	    &raidPtr->shutdownList, raidPtr->cleanupList);

d1113 3
a1115 1
rf_remove_hot_spare(RF_Raid_t *raidPtr, RF_SingleComponent_t *sparePtr)
d1119 3
a1121 2
	if (raidPtr->numSpare == 0) {
		printf("No spares to remove !\n");
d1127 1
a1127 1
	return(EINVAL);	/* XXX Not implemented yet. */
d1133 1
a1133 1
	/* Verify that this spare isn't in use... */
d1135 1
a1135 1
	/* It's gone... */
d1144 3
a1146 1
rf_delete_component(RF_Raid_t *raidPtr, RF_SingleComponent_t *component)
d1150 1
a1150 1
	if ((component->row < 0) ||
d1152 1
a1152 1
	    (component->column < 0) ||
d1159 1
a1159 1
	/* 1. This component must be marked as 'failed'. */
d1165 3
a1167 1
rf_incorporate_hot_spare(RF_Raid_t *raidPtr, RF_SingleComponent_t *component)
d1170 2
a1171 4
	/*
	 * Issues here include how to 'move' this in if there is IO
	 * taking place (e.g. component queues and such).
	 */
@


1.5
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_disks.c,v 1.4 2000/01/07 14:50:21 peter Exp $	*/
/*	$NetBSD: rf_disks.c,v 1.14 2000/01/09 01:29:28 oster Exp $	*/
d78 6
d94 5
a98 3
/* XXX these should be in a header file somewhere */
void rf_UnconfigureVnodes( RF_Raid_t * );
int rf_CheckLabels( RF_Raid_t *, RF_Config_t *);
a126 1
	int     num_rows_done, num_cols_done;
a128 2
	num_rows_done = 0;
	num_cols_done = 0;
d131 2
a132 4
	RF_CallocAndAdd(disks, raidPtr->numRow, sizeof(RF_RaidDisk_t *), 
			(RF_RaidDisk_t **), raidPtr->cleanupList);
	if (disks == NULL) {
		ret = ENOMEM;
a133 2
	}
	raidPtr->Disks = disks;
d135 2
a136 8
	/* get space for the device-specific stuff... */
	RF_CallocAndAdd(raidPtr->raid_cinfo, raidPtr->numRow,
	    sizeof(struct raidcinfo *), (struct raidcinfo **),
	    raidPtr->cleanupList);
	if (raidPtr->raid_cinfo == NULL) {
		ret = ENOMEM;
		goto fail;
	}
a138 19
		/* We allocate RF_MAXSPARE on the first row so that we
		   have room to do hot-swapping of spares */
		RF_CallocAndAdd(disks[r], raidPtr->numCol 
				+ ((r == 0) ? RF_MAXSPARE : 0), 
				sizeof(RF_RaidDisk_t), (RF_RaidDisk_t *), 
				raidPtr->cleanupList);
		if (disks[r] == NULL) {
			ret = ENOMEM;
			goto fail;
		}
		/* get more space for device specific stuff.. */
		RF_CallocAndAdd(raidPtr->raid_cinfo[r],
		    raidPtr->numCol + ((r == 0) ? raidPtr->numSpare : 0),
		    sizeof(struct raidcinfo), (struct raidcinfo *),
		    raidPtr->cleanupList);
		if (raidPtr->raid_cinfo[r] == NULL) {
			ret = ENOMEM;
			goto fail;
		}
d143 1
a165 1
			num_cols_done++;
a171 1
		num_rows_done++;
d318 3
d322 51
a372 1
	return (ret);
d376 225
d663 2
a664 1

d668 2
a680 3
static void rf_print_label_status( RF_Raid_t *, int, int, char *, 
				  RF_ComponentLabel_t *);

a701 2
static int rf_check_label_vitals( RF_Raid_t *, int, int, char *, 
				  RF_ComponentLabel_t *, int, int );
a1017 7
int config_disk_queue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t, 
		      RF_RowCol_t, RF_DiskQueueSW_t *,
		      RF_SectorCount_t, dev_t, int, 
		      RF_ShutdownList_t **,
		      RF_AllocListElem_t *);

int rf_add_hot_spare(RF_Raid_t *, RF_SingleComponent_t *);
d1029 1
d1032 1
d1092 1
a1092 1
	ret = config_disk_queue( raidPtr, &spareQueues[spare_number],
d1094 1
a1094 1
				 raidPtr->Queues[0][0].qPtr, /* XXX */
d1096 3
a1098 2
				 raidPtr->Disks[0][raidPtr->numCol + spare_number].dev,
				 raidPtr->Queues[0][0].maxOutstanding, /* XXX */
d1141 33
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_disks.c,v 1.6 2000/08/08 16:07:40 peter Exp $	*/
/*	$NetBSD: rf_disks.c,v 1.31 2000/06/02 01:17:14 oster Exp $	*/
a77 6
#if defined(__NetBSD__)
#include "rf_netbsd.h"
#elif defined(__OpenBSD__)
#include "rf_openbsd.h"
#endif

d88 3
a90 5
static int rf_AllocDiskStructures(RF_Raid_t *, RF_Config_t *);
static void rf_print_label_status( RF_Raid_t *, int, int, char *, 
				  RF_ComponentLabel_t *);
static int rf_check_label_vitals( RF_Raid_t *, int, int, char *, 
				  RF_ComponentLabel_t *, int, int );
d119 1
d122 2
d126 4
a129 2
 	ret = rf_AllocDiskStructures(raidPtr, cfgPtr);
 	if (ret)
d131 2
d134 8
a141 2
 	disks = raidPtr->Disks;
 
d144 19
a166 1

d189 1
d196 1
d343 1
a343 1
	
a346 8
static int
rf_AllocDiskStructures(raidPtr, cfgPtr)
	RF_Raid_t *raidPtr;
 	RF_Config_t *cfgPtr;
{
	RF_RaidDisk_t **disks;
	int ret;
	int r;
a347 270
	RF_CallocAndAdd(disks, raidPtr->numRow, sizeof(RF_RaidDisk_t *), 
			(RF_RaidDisk_t **), raidPtr->cleanupList);
	if (disks == NULL) {
		ret = ENOMEM;
		goto fail;
	}
	raidPtr->Disks = disks;
	/* get space for the device-specific stuff... */
	RF_CallocAndAdd(raidPtr->raid_cinfo, raidPtr->numRow,
	    sizeof(struct raidcinfo *), (struct raidcinfo **),
	    raidPtr->cleanupList);
	if (raidPtr->raid_cinfo == NULL) {
		ret = ENOMEM;
		goto fail;
	}

	for (r = 0; r < raidPtr->numRow; r++) {
		/* We allocate RF_MAXSPARE on the first row so that we
		   have room to do hot-swapping of spares */
		RF_CallocAndAdd(disks[r], raidPtr->numCol 
				+ ((r == 0) ? RF_MAXSPARE : 0), 
				sizeof(RF_RaidDisk_t), (RF_RaidDisk_t *), 
				raidPtr->cleanupList);
		if (disks[r] == NULL) {
			ret = ENOMEM;
			goto fail;
		}
		/* get more space for device specific stuff.. */
		RF_CallocAndAdd(raidPtr->raid_cinfo[r],
		    raidPtr->numCol + ((r == 0) ? raidPtr->numSpare : 0),
		    sizeof(struct raidcinfo), (struct raidcinfo *),
		    raidPtr->cleanupList);
		if (raidPtr->raid_cinfo[r] == NULL) {
			ret = ENOMEM;
			goto fail;
		}
	}
	return(0);
fail:	
	rf_UnconfigureVnodes( raidPtr );

	return(ret);
}


/* configure a single disk during auto-configuration at boot */
int
rf_AutoConfigureDisks(raidPtr, cfgPtr, auto_config)
	RF_Raid_t *raidPtr;
	RF_Config_t *cfgPtr;
	RF_AutoConfig_t *auto_config;
{
	RF_RaidDisk_t **disks;
	RF_RaidDisk_t *diskPtr;
	RF_RowCol_t r, c;	
	RF_SectorCount_t min_numblks = (RF_SectorCount_t) 0x7FFFFFFFFFFFLL;
	int bs, ret;
	int numFailuresThisRow;
	int force;
	RF_AutoConfig_t *ac;
	int parity_good;
	int mod_counter;
	int mod_counter_found;

#if DEBUG
	printf("Starting autoconfiguration of RAID set...\n");
#endif
	force = cfgPtr->force;

	ret = rf_AllocDiskStructures(raidPtr, cfgPtr);
	if (ret)
		goto fail;

	disks = raidPtr->Disks;

	/* assume the parity will be fine.. */
	parity_good = RF_RAID_CLEAN;

	/* Check for mod_counters that are too low */
	mod_counter_found = 0;
	ac = auto_config;
	while(ac!=NULL) {
		if (mod_counter_found==0) {
			mod_counter = ac->clabel->mod_counter;
			mod_counter_found = 1;
		} else {
			if (ac->clabel->mod_counter > mod_counter) {
				mod_counter = ac->clabel->mod_counter;
			}
		}
		ac->flag = 0; /* clear the general purpose flag */
		ac = ac->next;
	}

	for (r = 0; r < raidPtr->numRow; r++) {
		numFailuresThisRow = 0;
		for (c = 0; c < raidPtr->numCol; c++) {
			diskPtr = &disks[r][c];

			/* find this row/col in the autoconfig */
#if DEBUG
			printf("Looking for %d,%d in autoconfig\n",r,c);
#endif
			ac = auto_config;
			while(ac!=NULL) {
				if (ac->clabel==NULL) {
					/* big-time bad news. */
					goto fail;
				}
				if ((ac->clabel->row == r) &&
				    (ac->clabel->column == c) &&
				    (ac->clabel->mod_counter == mod_counter)) {
					/* it's this one... */
					/* flag it as 'used', so we don't
					   free it later. */
					ac->flag = 1;
#if DEBUG
					printf("Found: %s at %d,%d\n",
					       ac->devname,r,c);
#endif
					
					break;
				}
				ac=ac->next;
			}

			if (ac==NULL) {
				/* we didn't find an exact match with a 
				   correct mod_counter above... can we
				   find one with an incorrect mod_counter
				   to use instead?  (this one, if we find
				   it, will be marked as failed once the 
				   set configures) 
				*/

				ac = auto_config;
				while(ac!=NULL) {
					if (ac->clabel==NULL) {
						/* big-time bad news. */
						goto fail;
					}
					if ((ac->clabel->row == r) &&
					    (ac->clabel->column == c)) {
						/* it's this one... 
						   flag it as 'used', so we 
						   don't free it later. */
						ac->flag = 1;
#if DEBUG
						printf("Found(low mod_counter): %s at %d,%d\n",
						       ac->devname,r,c);
#endif
						
						break;
					}
					ac=ac->next;
				}
			}



			if (ac!=NULL) {
				/* Found it.  Configure it.. */
				diskPtr->blockSize = ac->clabel->blockSize;
				diskPtr->numBlocks = ac->clabel->numBlocks;
				/* Note: rf_protectedSectors is already 
				   factored into numBlocks here */
				raidPtr->raid_cinfo[r][c].ci_vp = ac->vp;
				raidPtr->raid_cinfo[r][c].ci_dev = ac->dev;

				memcpy(&raidPtr->raid_cinfo[r][c].ci_label,
				       ac->clabel, sizeof(*ac->clabel));
				sprintf(diskPtr->devname, "/dev/%s", 
					ac->devname);
				
				/* note the fact that this component was
				   autoconfigured.  You'll need this info
				   later.  Trust me :) */
				diskPtr->auto_configured = 1;
				diskPtr->dev = ac->dev;
			
				/* 
				 * we allow the user to specify that
				 * only a fraction of the disks should
				 * be used this is just for debug: it
				 * speeds up the parity scan 
				 */

				diskPtr->numBlocks = diskPtr->numBlocks * 
					rf_sizePercentage / 100;

				/* XXX these will get set multiple times, 
				   but since we're autoconfiguring, they'd
				   better be always the same each time!
				   If not, this is the least of your worries */

				bs = diskPtr->blockSize;
				min_numblks = diskPtr->numBlocks;

				/* this gets done multiple times, but that's
				   fine -- the serial number will be the same
				   for all components, guaranteed */
				raidPtr->serial_number = 
					ac->clabel->serial_number;
				/* check the last time the label
				   was modified */
				if (ac->clabel->mod_counter !=
				    mod_counter) {
					/* Even though we've filled in all
					   of the above, we don't trust
					   this component since it's 
					   modification counter is not
					   in sync with the rest, and we really
					   consider it to be failed.  */
					disks[r][c].status = rf_ds_failed;
					numFailuresThisRow++;
				} else {
					if (ac->clabel->clean != 
					    RF_RAID_CLEAN) {
						parity_good = RF_RAID_DIRTY;
					}
				}
			} else {
				/* Didn't find it at all!! 
				   Component must really be dead */
				disks[r][c].status = rf_ds_failed;
				sprintf(disks[r][c].devname,"component%d",
					r * raidPtr->numCol + c);
				numFailuresThisRow++;
			}
		}
		/* XXX fix for n-fault tolerant */
		/* XXX this should probably check to see how many failures
		   we can handle for this configuration! */
		if (numFailuresThisRow > 0)
			raidPtr->status[r] = rf_rs_degraded;
	}

	/* close the device for the ones that didn't get used */

	ac = auto_config;
	while(ac!=NULL) {
		if (ac->flag == 0) {
			VOP_CLOSE(ac->vp, FREAD, NOCRED, 0);
			vput(ac->vp);
			ac->vp = NULL;
#if DEBUG 
			printf("Released %s from auto-config set.\n",
			       ac->devname);
#endif
		}
		ac = ac->next;
	}

	raidPtr->mod_counter = mod_counter;

	/* note the state of the parity, if any */
	raidPtr->parity_good = parity_good;
	raidPtr->sectorsPerDisk = min_numblks;
	raidPtr->logBytesPerSector = ffs(bs) - 1;
	raidPtr->bytesPerSector = bs;
	raidPtr->sectorMask = bs - 1;
	return (0);

fail:
	
	rf_UnconfigureVnodes( raidPtr );

	return (ret);

}
d410 1
a410 2
 		diskPtr->partitionSize = dpart.part->p_size;
 
a413 2
 		/* This component was not automatically configured */
 		diskPtr->auto_configured = 0;
d425 3
d449 2
d767 7
a784 1
#if 0
a786 1
#endif
d846 1
a846 1
	ret = rf_ConfigureDiskQueue( raidPtr, &spareQueues[spare_number],
d848 1
a848 1
				 raidPtr->qType,
d850 2
a851 3
				 raidPtr->Disks[0][raidPtr->numCol + 
						  spare_number].dev,
				 raidPtr->maxOutstanding,
a893 33
}

int
rf_delete_component(raidPtr,component)
	RF_Raid_t *raidPtr;
	RF_SingleComponent_t *component;
{
	RF_RaidDisk_t *disks;

	if ((component->row < 0) || 
	    (component->row >= raidPtr->numRow) ||
	    (component->column < 0) || 
	    (component->column >= raidPtr->numCol)) {
		return(EINVAL);
	}

	disks = &raidPtr->Disks[component->row][component->column];

	/* 1. This component must be marked as 'failed' */

	return(EINVAL); /* Not implemented yet. */
}

int
rf_incorporate_hot_spare(raidPtr,component)
	RF_Raid_t *raidPtr;
	RF_SingleComponent_t *component;
{

	/* Issues here include how to 'move' this in if there is IO 
	   taking place (e.g. component queues and such) */

	return(EINVAL); /* Not implemented yet. */
@


1.5.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 2

/*
d20 2
a21 2
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
d66 1
a66 1
 * rf_disks.c -- Code to perform operations on the actual disks.
d90 1
a90 1
#ifdef	__NETBSD__
d92 1
a92 1
#endif	/* __NETBSD__ */
d94 5
a98 5
int  rf_AllocDiskStructures(RF_Raid_t *, RF_Config_t *);
void rf_print_label_status(RF_Raid_t *, int, int, char *,
	RF_ComponentLabel_t *);
int  rf_check_label_vitals(RF_Raid_t *, int, int, char *,
	RF_ComponentLabel_t *, int, int);
d100 2
a101 2
#define	DPRINTF6(a,b,c,d,e,f)	if (rf_diskDebug) printf(a,b,c,d,e,f)
#define	DPRINTF7(a,b,c,d,e,f,g)	if (rf_diskDebug) printf(a,b,c,d,e,f,g)
d105 1
a105 1
 * Initialize the disks comprising the array.
d107 6
a112 6
 * We want the spare disks to have regular row,col numbers so that we can
 * easily substitue a spare for a failed disk. But, the driver code assumes
 * throughout that the array contains numRow by numCol _non-spare_ disks, so
 * it's not clear how to fit in the spares. This is an unfortunate holdover
 * from raidSim. The quick and dirty fix is to make row zero bigger than the
 * rest, and put all the spares in it. This probably needs to get changed
d116 5
a120 3
int
rf_ConfigureDisks(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d125 1
a125 1
	int bs, ret;
d127 1
a127 1
	int force;
d130 1
a130 1

d136 1
a136 1

d140 3
a142 2
			ret = rf_ConfigureDisk(raidPtr,
			    &cfgPtr->devnames[r][c][0], &disks[r][c], r, c);
d159 1
a159 2
				DPRINTF7("Disk at row %d col %d: dev %s"
				    " numBlocks %ld blockSize %d (%ld MB)\n",
d164 1
a164 1
				     disks[r][c].blockSize / 1024 / 1024);
d167 3
a169 5
		/* XXX Fix for n-fault tolerant. */
		/*
		 * XXX This should probably check to see how many failures
		 * we can handle for this configuration !
		 */
d173 2
a174 4
	/*
	 * All disks must be the same size & have the same block size, bs must
	 * be a power of 2.
	 */
d185 1
a185 2
		RF_ERRORMSG("RAIDFRAME: Did not find any live disks in"
		    " the array.\n");
d193 1
a193 2
		RF_ERRORMSG1("Error: block size on disks (%d) must be a"
		    " power of 2.\n", bs);
d198 1
a198 1
	if (rf_CheckLabels(raidPtr, cfgPtr)) {
d202 1
a202 1
			    raidPtr->raidid);
d206 1
a206 1
		}
d213 1
a213 3
					RF_ERRORMSG2("Error: block size of"
					    " disk at r %d c %d different from"
					    " disk at r 0 c 0.\n", r, c);
d218 1
a218 2
					RF_ERRORMSG3("WARNING: truncating disk"
					    " at r %d c %d to %d blocks.\n",
d233 1
a233 1
	rf_UnconfigureVnodes(raidPtr);
d240 2
a241 2
 * Set up the data structures describing the spare disks in the array.
 * Recall from the above comment that the spare disk descriptors are stored
d244 5
a248 3
int
rf_ConfigureSpareDisks(RF_ShutdownList_t ** listp, RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d250 1
a250 1
	int i, ret;
d253 1
a253 1
	int num_spares_done;
d257 2
a258 4
	/*
	 * The space for the spares should have already been allocated by
	 * ConfigureDisks().
	 */
d263 1
a263 1
		    &disks[i], 0, raidPtr->numCol + i);
d267 2
a268 2
			RF_ERRORMSG1("Warning: spare disk %s failed TUR\n",
			    &cfgPtr->spare_names[i][0]);
d270 4
a273 4
			/* Change status to spare. */
			disks[i].status = rf_ds_spare;
			DPRINTF6("Spare Disk %d: dev %s numBlocks %ld"
			    " blockSize %d (%ld MB).\n", i, disks[i].devname,
d275 2
a276 2
			    (long int) disks[i].numBlocks *
			    disks[i].blockSize / 1024 / 1024);
d281 1
a281 1
	/* Check sizes and block sizes on spare disks. */
d285 1
a285 3
			RF_ERRORMSG3("Block size of %d on spare disk %s is"
			    " not the same as on other disks (%d).\n",
			    disks[i].blockSize, disks[i].devname, bs);
d290 3
a292 4
			RF_ERRORMSG3("Spare disk %s (%d blocks) is too small"
			    " to serve as a spare (need %ld blocks).\n",
			    disks[i].devname, disks[i].blockSize,
			    (long int) raidPtr->sectorsPerDisk);
d297 1
a297 3
				RF_ERRORMSG2("Warning: truncating spare disk"
				    " %s to %ld blocks.\n", disks[i].devname,
				    (long int) raidPtr->sectorsPerDisk);
d307 8
a314 9
	/*
	 * Release the hold on the main components. We've failed to allocate
	 * a spare, and since we're failing, we need to free things...
	 *
	 * XXX Failing to allocate a spare is *not* that big of a deal...
	 * We *can* survive without it, if need be, esp. if we get hot
	 * adding working.
	 * If we don't fail out here, then we need a way to remove this spare...
	 * That should be easier to do here than if we are "live"...
d317 2
a318 2
	rf_UnconfigureVnodes(raidPtr);

d322 4
a325 2
int
rf_AllocDiskStructures(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr)
d331 2
a332 2
	RF_CallocAndAdd(disks, raidPtr->numRow, sizeof(RF_RaidDisk_t *),
	    (RF_RaidDisk_t **), raidPtr->cleanupList);
d338 1
a338 1
	/* Get space for the device-specific stuff... */
d348 6
a353 7
		/*
		 * We allocate RF_MAXSPARE on the first row so that we
		 * have room to do hot-swapping of spares.
		 */
		RF_CallocAndAdd(disks[r], raidPtr->numCol +
		    ((r == 0) ? RF_MAXSPARE : 0), sizeof(RF_RaidDisk_t),
		    (RF_RaidDisk_t *), raidPtr->cleanupList);
d358 3
a360 3
		/* Get more space for device specific stuff... */
		RF_CallocAndAdd(raidPtr->raid_cinfo[r], raidPtr->numCol +
		    ((r == 0) ? raidPtr->numSpare : 0),
d369 2
a370 2
fail:
	rf_UnconfigureVnodes(raidPtr);
d376 1
a376 1
/* Configure a single disk during auto-configuration at boot. */
d378 4
a381 2
rf_AutoConfigureDisks(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr,
    RF_AutoConfig_t *auto_config)
d385 1
a385 1
	RF_RowCol_t r, c;
d395 1
a395 1
#if	DEBUG
d397 1
a397 1
#endif	/* DEBUG */
d406 1
a406 1
	/* Assume the parity will be fine... */
d409 1
a409 1
	/* Check for mod_counters that are too low. */
d413 1
a413 1
		if (mod_counter_found == 0) {
d421 1
a421 1
		ac->flag = 0; /* Clear the general purpose flag. */
d430 4
a433 4
			/* Find this row/col in the autoconfig. */
#if	DEBUG
			printf("Looking for %d,%d in autoconfig.\n", r, c);
#endif	/* DEBUG */
d436 2
a437 2
				if (ac->clabel == NULL) {
					/* Big-time bad news. */
d443 3
a445 5
					/* It's this one... */
					/*
					 * Flag it as 'used', so we don't
					 * free it later.
					 */
d447 5
a451 5
#if	DEBUG
					printf("Found: %s at %d,%d.\n",
					    ac->devname, r, c);
#endif	/* DEBUG */

d454 1
a454 1
				ac = ac->next;
d457 8
a464 9
			if (ac == NULL) {
				/*
				 * We didn't find an exact match with a
				 * correct mod_counter above...  Can we
				 * find one with an incorrect mod_counter
				 * to use instead ?  (This one, if we find
				 * it, will be marked as failed once the
				 * set configures)
				 */
d468 2
a469 2
					if (ac->clabel == NULL) {
						/* Big-time bad news. */
d474 3
a476 5
						/*
						 * It's this one...
						 * Flag it as 'used', so we
						 * don't free it later.
						 */
d478 5
a482 6
#if	DEBUG
						printf("Found(low mod_counter)"
						    ": %s at %d,%d.\n",
						    ac->devname, r, c);
#endif	/* DEBUG */

d485 1
a485 1
					ac = ac->next;
d492 1
a492 1
				/* Found it. Configure it... */
d495 2
a496 4
				/*
				 * Note: rf_protectedSectors is already
				 * factored into numBlocks here.
				 */
d501 7
a507 9
				    ac->clabel, sizeof(*ac->clabel));
				sprintf(diskPtr->devname, "/dev/%s",
				    ac->devname);

				/*
				 * Note the fact that this component was
				 * autoconfigured. You'll need this info
				 * later. Trust me :)
				 */
d510 3
a512 3

				/*
				 * We allow the user to specify that
d514 2
a515 2
				 * be used. This is just for debug: it
				 * speeds up the parity scan.
d518 1
a518 1
				diskPtr->numBlocks = diskPtr->numBlocks *
d521 4
a524 6
				/*
				 * XXX These will get set multiple times,
				 * but since we're autoconfiguring, they'd
				 * better be always the same each time !
				 * If not, this is the least of your worries.
				 */
d529 15
a543 20
				/*
				 * This gets done multiple times, but that's
				 * fine -- the serial number will be the same
				 * for all components, guaranteed.
				 */
				raidPtr->serial_number =
				    ac->clabel->serial_number;
				/*
				 * Check the last time the label
				 * was modified.
				 */
				if (ac->clabel->mod_counter != mod_counter) {
					/*
					 * Even though we've filled in all
					 * of the above, we don't trust
					 * this component since it's
					 * modification counter is not
					 * in sync with the rest, and we really
					 * consider it to be failed.
					 */
d547 2
a548 2
					if (ac->clabel->clean != RF_RAID_CLEAN)
					{
d553 2
a554 4
				/*
				 * Didn't find it at all !!!
				 * Component must really be dead.
				 */
d556 2
a557 2
				sprintf(disks[r][c].devname, "component%d",
				    r * raidPtr->numCol + c);
d561 3
a563 5
		/* XXX Fix for n-fault tolerant. */
		/*
		 * XXX This should probably check to see how many failures
		 * we can handle for this configuration !
		 */
d568 1
a568 1
	/* Close the device for the ones that didn't get used. */
d571 1
a571 1
	while(ac != NULL) {
d576 1
a576 1
#if	DEBUG
d578 2
a579 2
			    ac->devname);
#endif  /* DEBUG */
d586 1
a586 1
	/* Note the state of the parity, if any. */
d595 2
a596 2

	rf_UnconfigureVnodes(raidPtr);
d602 8
a609 4
/* Configure a single disk in the array. */
int
rf_ConfigureDisk(RF_Raid_t *raidPtr, char *buf, RF_RaidDisk_t *diskPtr,
    RF_RowCol_t row, RF_RowCol_t col)
d611 2
a612 2
	char *p;
	int retcode;
d618 1
a618 1
	int error;
d623 1
a623 1
		/* Strip off the newline. */
d628 1
d630 3
d640 1
a640 1
	error = raidlookup(diskPtr->devname, curproc, &vp);
d642 1
a642 1
		printf("raidlookup on device: %s failed !\n", diskPtr->devname);
d644 1
a644 1
			/* The component isn't there...  Must be dead :-( */
d655 2
a656 2
		error = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart, FREAD,
		    proc->p_ucred, proc);
d664 1
a664 1

d668 1
a668 1
 		/* This component was not automatically configured. */
d672 5
a676 7
		/*
		 * We allow the user to specify that only a fraction of the
		 * disks should be used. This is just for debug: it speeds up
		 * the parity scan.
		 */
		diskPtr->numBlocks = diskPtr->numBlocks * rf_sizePercentage
		    / 100;
d681 7
a687 3
void
rf_print_label_status(RF_Raid_t *raidPtr, int row, int column, char *dev_name,
    RF_ComponentLabel_t *ci_label)
d690 2
a691 2
	printf("raid%d: Component %s being configured at row: %d col: %d\n",
	    raidPtr->raidid, dev_name, row, column);
d693 2
a694 2
	    ci_label->row, ci_label->column, ci_label->num_rows,
	    ci_label->num_columns);
d696 2
a697 1
	    ci_label->version, ci_label->serial_number, ci_label->mod_counter);
d699 1
a699 1
	    ci_label->clean ? "Yes" : "No", ci_label->status);
d702 9
a710 3
int
rf_check_label_vitals(RF_Raid_t *raidPtr, int row, int column, char *dev_name,
    RF_ComponentLabel_t *ci_label, int serial_number, int mod_counter)
d715 2
a716 2
		printf("%s has a different serial number: %d %d.\n",
		    dev_name, serial_number, ci_label->serial_number);
d720 2
a721 2
		printf("%s has a different modfication count: %d %d.\n",
		    dev_name, mod_counter, ci_label->mod_counter);
d723 1
a723 1

d725 1
a725 1
		printf("Row out of alignment for: %s.\n", dev_name);
d729 1
a729 1
		printf("Column out of alignment for: %s.\n", dev_name);
d733 1
a733 1
		printf("Number of rows do not match for: %s.\n", dev_name);
d737 1
a737 1
		printf("Number of columns do not match for: %s.\n", dev_name);
d741 2
a742 2
		/* It's not clean, but that's not fatal. */
		printf("%s is not clean !\n", dev_name);
d748 5
a752 5
/*
 *
 * rf_CheckLabels() - Check all the component labels for consistency.
 * Return an error if there is anything major amiss.
 *
d755 4
a758 2
int
rf_CheckLabels(RF_Raid_t *raidPtr, RF_Config_t *cfgPtr)
d760 1
a760 1
	int r, c;
d785 14
a798 14
	/*
	 * We're going to try to be a little intelligent here. If one
	 * component's label is bogus, and we can identify that it's the
	 * *only* one that's gone, we'll mark it as "failed" and allow
	 * the configuration to proceed. This will be the *only* case
	 * that we'll proceed if there would be (otherwise) fatal errors.
	 *
	 * Basically we simply keep a count of how many components had
	 * what serial number. If all but one agree, we simply mark
	 * the disagreeing component as being failed, and allow
	 * things to come up "normally".
	 *
	 * We do this first for serial numbers, and then for "mod_counter".
	 *
d803 1
a803 1
	for (r = 0; r < raidPtr->numRow && !fatal_error; r++) {
d806 2
a807 2
			found = 0;
			for(i = 0; i < num_ser; i++) {
d810 1
a810 1
					found = 1;
d818 1
a818 1
				if (num_ser > 2) {
d823 2
a824 2
			found = 0;
			for(i = 0; i < num_mod; i++) {
d827 1
a827 1
					found = 1;
d832 1
a832 1
				mod_values[num_mod] = ci_label->mod_counter;
d835 1
a835 1
				if (num_mod > 2) {
d842 1
a842 1
#if	DEBUG
d844 1
a844 1
	for(i = 0; i < num_ser; i++) {
d848 1
a848 1
	for(i = 0; i < num_mod; i++) {
d851 1
a851 1
#endif  /* DEBUG */
d855 1
a855 1
			/* Locate the maverick component. */
d858 1
a858 1
			}
d861 2
a862 3
					ci_label =
					    &raidPtr->raid_cinfo[r][c].ci_label;
					if (serial_number !=
d870 2
a871 2
			printf("Hosed component: %s.\n",
			    &cfgPtr->devnames[hosed_row][hosed_column][0]);
d873 3
a875 5
				/*
				 * We'll fail this component, as if there are
				 * other major errors, we aren't forcing things
				 * and we'll abort the config anyways.
				 */
d877 1
a877 1
				    = rf_ds_failed;
d885 2
a886 4
			/*
			 * We've identified two different serial numbers.
			 * RAID 0 can't cope with that, so we'll punt.
			 */
d890 1
a890 1
	}
d892 3
a894 5
	/*
	 * Record the serial number for later. If we bail later, setting
	 * this doesn't matter, otherwise we've got the best guess at the
	 * correct serial number.
	 */
d900 1
a900 1
			/* Locate the maverick component. */
d906 4
a909 6
				/*
				 * Counts of different modification values
				 * are the same. Assume greater value is
				 * the correct one, all other things
				 * considered.
				 */
d915 1
a915 1

d917 1
a917 1
			for (r = 0; r < raidPtr->numRow && !too_fatal; r++) {
d919 2
a920 3
					ci_label =
					    &raidPtr->raid_cinfo[r][c].ci_label;
					if (mod_number !=
d922 4
a925 6
						if ((hosed_row == r) &&
						    (hosed_column == c)) {
							/*
							 * Same one. Can
							 * deal with it.
							 */
d937 2
a938 2
			printf("Hosed component: %s.\n",
			    &cfgPtr->devnames[hosed_row][hosed_column][0]);
d940 6
a945 11
				/*
				 * We'll fail this component, as if there are
				 * other major errors, we aren't forcing things
				 * and we'll abort the config anyways.
				 */
				if (raidPtr
				    ->Disks[hosed_row][hosed_column].status !=
				    rf_ds_failed) {
					raidPtr->Disks[hosed_row]
					    [hosed_column].status =
					    rf_ds_failed;
d947 1
a947 2
					raidPtr->status[hosed_row] =
					    rf_rs_degraded;
d954 2
a955 4
			/*
			 * We've identified two different mod counters.
			 * RAID 0 can't cope with that, so we'll punt.
			 */
d958 1
a958 1
	}
d963 4
a966 6
		/*
		 * We've had both a serial number mismatch, and a mod_counter
		 * mismatch -- and they involved two different components !!!
		 * Bail -- make things fail so that the user must force
		 * the issue...
		 */
d972 2
a973 2
		printf("raid%d: Too many different serial numbers !\n",
		    raidPtr->raidid);
d977 2
a978 2
		printf("raid%d: Too many different mod counters !\n",
		    raidPtr->raidid);
d981 2
a982 4
	/*
	 * We start by assuming the parity will be good, and flee from
	 * that notion at the slightest sign of trouble.
	 */
d991 9
a999 8
				printf("raid%d: Ignoring %s.\n",
				    raidPtr->raidid, dev_name);
			} else {
				rf_print_label_status(raidPtr, r, c, dev_name,
				    ci_label);
				if (rf_check_label_vitals(raidPtr, r, c,
				     dev_name, ci_label, serial_number,
				     mod_number)) {
d1012 1
a1012 1
	/* We note the state of the parity. */
d1015 1
a1015 1
	return(fatal_error);
d1019 3
a1021 1
rf_add_hot_spare(RF_Raid_t *raidPtr, RF_SingleComponent_t *sparePtr)
d1030 2
a1031 2
	printf("Just in rf_add_hot_spare: %d.\n", raidPtr->numSpare);
	printf("Num col: %d.\n", raidPtr->numCol);
d1034 1
a1034 1
		RF_ERRORMSG1("Too many spares: %d.\n", raidPtr->numSpare);
d1040 1
a1040 1
	/* The beginning of the spares... */
d1046 2
a1047 1
	    &disks[spare_number], 0, raidPtr->numCol + spare_number);
d1052 3
a1054 3
		RF_ERRORMSG1("Warning: spare disk %s failed TUR.\n",
		    sparePtr->component_name);
		ret = EINVAL;
d1058 6
a1063 6
		DPRINTF6("Spare Disk %d: dev %s numBlocks %ld blockSize %d"
		    " (%ld MB).\n", spare_number, disks[spare_number].devname,
		    (long int) disks[spare_number].numBlocks,
		    disks[spare_number].blockSize,
		    (long int) disks[spare_number].numBlocks *
		     disks[spare_number].blockSize / 1024 / 1024);
d1065 1
d1067 1
a1067 2

	/* Check sizes and block sizes on the spare disk. */
d1070 1
a1070 4
		RF_ERRORMSG3("Block size of %d on spare disk %s is not"
		    " the same as on other disks (%d).\n",
		    disks[spare_number].blockSize,
		    disks[spare_number].devname, bs);
d1075 4
a1078 4
		RF_ERRORMSG3("Spare disk %s (%d blocks) is too small to serve"
		    " as a spare (need %ld blocks).\n",
		    disks[spare_number].devname, disks[spare_number].blockSize,
		    (long int) raidPtr->sectorsPerDisk);
d1082 1
a1082 1
		if (disks[spare_number].numBlocks >
d1084 3
a1086 4
			RF_ERRORMSG2("Warning: truncating spare disk %s to %ld"
			    " blocks.\n", disks[spare_number].devname,
			    (long int) raidPtr->sectorsPerDisk);

d1092 10
a1101 6
	ret = rf_ConfigureDiskQueue(raidPtr, &spareQueues[spare_number],
	    0, raidPtr->numCol + spare_number, raidPtr->qType,
	    raidPtr->sectorsPerDisk, raidPtr->Disks[0][raidPtr->numCol +
	     spare_number].dev, raidPtr->maxOutstanding,
	    &raidPtr->shutdownList, raidPtr->cleanupList);

d1113 3
a1115 1
rf_remove_hot_spare(RF_Raid_t *raidPtr, RF_SingleComponent_t *sparePtr)
d1119 3
a1121 2
	if (raidPtr->numSpare == 0) {
		printf("No spares to remove !\n");
d1127 1
a1127 1
	return(EINVAL);	/* XXX Not implemented yet. */
d1133 1
a1133 1
	/* Verify that this spare isn't in use... */
d1135 1
a1135 1
	/* It's gone... */
d1144 3
a1146 1
rf_delete_component(RF_Raid_t *raidPtr, RF_SingleComponent_t *component)
d1150 1
a1150 1
	if ((component->row < 0) ||
d1152 1
a1152 1
	    (component->column < 0) ||
d1159 1
a1159 1
	/* 1. This component must be marked as 'failed'. */
d1165 3
a1167 1
rf_incorporate_hot_spare(RF_Raid_t *raidPtr, RF_SingleComponent_t *component)
d1170 2
a1171 4
	/*
	 * Issues here include how to 'move' this in if there is IO
	 * taking place (e.g. component queues and such).
	 */
@


1.5.2.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_disks.c,v 1.5.2.2 2003/03/28 00:38:27 niklas Exp $	*/
d521 1
a521 2
				snprintf(diskPtr->devname,
				    sizeof diskPtr->devname, "/dev/%s",
d586 1
a586 2
				snprintf(disks[r][c].devname,
				    sizeof disks[r][c].devname, "component%d",
d654 1
a654 1
	(void) strlcpy(diskPtr->devname, p, sizeof diskPtr->devname);
@


1.5.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d300 4
a303 4
			RF_ERRORMSG3("Spare disk %s (%llu blocks) is too small"
			    " to serve as a spare (need %llu blocks).\n",
			    disks[i].devname, disks[i].numBlocks,
			    raidPtr->sectorsPerDisk);
d309 2
a310 2
				    " %s to %llu blocks.\n", disks[i].devname,
				    raidPtr->sectorsPerDisk);
d1113 4
a1116 4
		RF_ERRORMSG3("Spare disk %s (%llu blocks) is too small to serve"
		    " as a spare (need %llu blocks).\n",
		    disks[spare_number].devname, disks[spare_number].numBlocks,
		    raidPtr->sectorsPerDisk);
d1122 1
a1122 1
			RF_ERRORMSG2("Warning: truncating spare disk %s to %llu"
d1124 1
a1124 1
			    raidPtr->sectorsPerDisk);
@


1.4
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_disks.c,v 1.3 1999/07/30 14:45:32 peter Exp $	*/
/*	$NetBSD: rf_disks.c,v 1.13 1999/08/14 03:10:03 oster Exp $	*/
d76 1
a88 3
int raidlookup __P((char *, struct proc * p, struct vnode **));
int raidwrite_component_label(dev_t, struct vnode *, RF_ComponentLabel_t *);
int raidread_component_label(dev_t, struct vnode *, RF_ComponentLabel_t *);
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_disks.c,v 1.2 1999/02/16 00:02:40 niklas Exp $	*/
/*	$NetBSD: rf_disks.c,v 1.10 1999/06/04 02:02:39 oster Exp $	*/
a74 3
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
#include "rf_camlayer.h"
#endif
a75 1
#include "rf_sys.h"
d377 5
a381 1
	proc = raidPtr->proc;	/* XXX Yes, this is not nice.. */
d447 2
a448 2
	printf("         Clean: %d Status: %d\n",
	       ci_label->clean, ci_label->status );
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 37
a37 2
/*	$OpenBSD: rf_disks.c,v 1.1 1999/01/11 14:29:17 niklas Exp $	*/
/*	$NetBSD: rf_disks.c,v 1.5 1999/02/05 00:06:09 oster Exp $	*/
d91 1
d93 4
a96 1

d101 1
a101 1
/****************************************************************************************
d105 7
a111 6
 * We want the spare disks to have regular row,col numbers so that we can easily
 * substitue a spare for a failed disk.  But, the driver code assumes throughout
 * that the array contains numRow by numCol _non-spare_ disks, so it's not clear
 * how to fit in the spares.  This is an unfortunate holdover from raidSim.  The
 * quick and dirty fix is to make row zero bigger than the rest, and put all the
 * spares in it.  This probably needs to get changed eventually.
d113 1
a113 1
 ***************************************************************************************/
d115 4
a118 4
rf_ConfigureDisks(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
a124 1
	RF_DiskOp_t *rdcap_op = NULL, *tur_op = NULL;
d126 1
a126 10

	struct proc *proc = 0;
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
	ret = rf_SCSI_AllocReadCapacity(&rdcap_op);
	if (ret)
		goto fail;
	ret = rf_SCSI_AllocTUR(&tur_op);
	if (ret)
		goto fail;
#endif				/* !__NetBSD__ && !__OpenBSD__ */
d130 4
a133 3


	RF_CallocAndAdd(disks, raidPtr->numRow, sizeof(RF_RaidDisk_t *), (RF_RaidDisk_t **), raidPtr->cleanupList);
a139 3

	proc = raidPtr->proc;	/* Blah XXX */

d150 6
a155 1
		RF_CallocAndAdd(disks[r], raidPtr->numCol + ((r == 0) ? raidPtr->numSpare : 0), sizeof(RF_RaidDisk_t), (RF_RaidDisk_t *), raidPtr->cleanupList);
d170 3
a172 3
			ret = rf_ConfigureDisk(raidPtr, &cfgPtr->devnames[r][c][0],
			    &disks[r][c], rdcap_op, tur_op,
			    cfgPtr->devs[r][c], r, c);
d175 8
d192 2
a193 1
				    (long int) disks[r][c].numBlocks * disks[r][c].blockSize / 1024 / 1024);
d198 2
a203 8
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
	/* we do nothing */
#else
	rf_SCSI_FreeDiskOp(rdcap_op, 1);
	rdcap_op = NULL;
	rf_SCSI_FreeDiskOp(tur_op, 0);
	tur_op = NULL;
#endif
d228 12
d264 1
a265 26
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)

	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			/* Cleanup.. */
#ifdef DEBUG
			printf("Cleaning up row: %d col: %d\n", r, c);
#endif
			if (raidPtr->raid_cinfo[r][c].ci_vp) {
				(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,
				    FREAD | FWRITE, proc->p_ucred, proc);
			}
		}
	}
	/* Space allocated for raid_vpp will get cleaned up at some other
	 * point */
	/* XXX Need more #ifdefs in the above... */

#else

	if (rdcap_op)
		rf_SCSI_FreeDiskOp(rdcap_op, 1);
	if (tur_op)
		rf_SCSI_FreeDiskOp(tur_op, 0);

#endif
d270 1
a270 1
/****************************************************************************************
d274 1
a274 1
 ***************************************************************************************/
d276 4
a279 4
rf_ConfigureSpareDisks(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d281 2
a282 4
	char    buf[256];
	int     r, c, i, ret;
	RF_DiskOp_t *rdcap_op = NULL, *tur_op = NULL;
	unsigned bs;
a285 11
	struct proc *proc;

#if !defined(__NetBSD__) && !defined(__OpenBSD__)
	ret = rf_SCSI_AllocReadCapacity(&rdcap_op);
	if (ret)
		goto fail;
	ret = rf_SCSI_AllocTUR(&tur_op);
	if (ret)
		goto fail;
#endif				/* !__NetBSD__ && !__OpenBSD__ */

a287 1
	proc = raidPtr->proc;
d294 1
a294 2
		    &disks[i], rdcap_op, tur_op,
		    cfgPtr->spare_devs[i], 0, raidPtr->numCol + i);
d298 2
a299 1
			RF_ERRORMSG1("Warning: spare disk %s failed TUR\n", buf);
d306 2
a307 1
			    (long int) disks[i].numBlocks * disks[i].blockSize / 1024 / 1024);
a310 8
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && (_KERNEL)

#else
	rf_SCSI_FreeDiskOp(rdcap_op, 1);
	rdcap_op = NULL;
	rf_SCSI_FreeDiskOp(tur_op, 0);
	tur_op = NULL;
#endif
d322 2
a323 1
			    disks[i].devname, disks[i].blockSize, (long int) raidPtr->sectorsPerDisk);
a336 1
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
d339 1
a339 14
	 * a spare, and since we're failing, we need to free things.. */

	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			/* Cleanup.. */
#ifdef DEBUG
			printf("Cleaning up row: %d col: %d\n", r, c);
#endif
			if (raidPtr->raid_cinfo[r][c].ci_vp) {
				(void) vn_close(raidPtr->raid_cinfo[r][c].ci_vp,
				    FREAD | FWRITE, proc->p_ucred, proc);
			}
		}
	}
d341 6
a346 10
	for (i = 0; i < raidPtr->numSpare; i++) {
		/* Cleanup.. */
#ifdef DEBUG
		printf("Cleaning up spare: %d\n", i);
#endif
		if (raidPtr->raid_cinfo[0][raidPtr->numCol + i].ci_vp) {
			(void) vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol + i].ci_vp,
			    FREAD | FWRITE, proc->p_ucred, proc);
		}
	}
d348 1
a348 8
#else

	if (rdcap_op)
		rf_SCSI_FreeDiskOp(rdcap_op, 1);
	if (tur_op)
		rf_SCSI_FreeDiskOp(tur_op, 0);

#endif
d357 2
a358 2
rf_ConfigureDisk(raidPtr, buf, diskPtr, rdcap_op, tur_op, dev, row, col)
	RF_Raid_t *raidPtr;	/* We need this down here too!! GO */
a360 3
	RF_DiskOp_t *rdcap_op;
	RF_DiskOp_t *tur_op;
	dev_t   dev;		/* device number used only in kernel */
a380 29
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
	/* get bus, target, lun */
	retcode = rf_extract_ids(p, &busid, &targid, &lun);
	if (retcode)
		return (retcode);

	/* required in kernel, nop at user level */
	retcode = rf_SCSI_OpenUnit(dev);
	if (retcode)
		return (retcode);

	diskPtr->dev = dev;
	if (rf_SCSI_DoTUR(tur_op, (u_char) busid, (u_char) targid, (u_char) lun, dev)) {
		RF_ERRORMSG1("Disk %s failed TUR.  Marked as dead.\n", diskPtr->devname);
		diskPtr->status = rf_ds_failed;
	} else {
		diskPtr->status = rf_ds_optimal;
		retcode = rf_SCSI_DoReadCapacity(raidPtr, rdcap_op, busid, targid, lun, dev,
		    &diskPtr->numBlocks, &diskPtr->blockSize, diskPtr->devname);
		if (retcode)
			return (retcode);

		/* we allow the user to specify that only a fraction of the
		 * disks should be used this is just for debug:  it speeds up
		 * the parity scan */
		diskPtr->numBlocks = diskPtr->numBlocks * rf_sizePercentage / 100;
	}
#endif

a383 1
	/* XXX not the case if the disk is toast.. */
a385 1

d393 1
a393 1
			/* XXX the component isn't there... must be dead :-( */
d416 1
a416 5
#if 0
		diskPtr->dev = dev;
#endif

		diskPtr->dev = va.va_rdev;	/* XXX or the above? */
d421 8
a428 1
		diskPtr->numBlocks = diskPtr->numBlocks * rf_sizePercentage / 100;
d430 64
d495 365
d861 35
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_disks.c,v 1.2 1998/12/03 15:06:25 oster Exp $	*/
/*	$NetBSD: rf_disks.c,v 1.2 1998/12/03 15:06:25 oster Exp $	*/
a33 96
/* :  
 * Log: rf_disks.c,v 
 * Revision 1.32  1996/07/27 18:40:24  jimz
 * cleanup sweep
 *
 * Revision 1.31  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.30  1996/07/19  16:11:21  jimz
 * pass devname to DoReadCapacity
 *
 * Revision 1.29  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.28  1996/07/10  22:28:38  jimz
 * get rid of obsolete row statuses (dead,degraded2)
 *
 * Revision 1.27  1996/06/10  12:06:14  jimz
 * don't do any SCSI op stuff in simulator at all
 *
 * Revision 1.26  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.25  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.24  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.23  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.22  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.21  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.20  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.19  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.18  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.17  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.16  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.15  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.14  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.13  1996/05/02  14:57:43  jimz
 * initialize sectorMask
 *
 * Revision 1.12  1995/12/01  15:57:04  root
 * added copyright info
 *
 */

a45 1
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
d56 1
a56 2
int raidlookup __P((char *, struct proc *p, struct vnode **));
#endif
a57 4
#ifdef SIMULATE
static char disk_db_file_name[120], disk_type_name[120];
static double init_offset;
#endif /* SIMULATE  */
a61 2
#include "rf_ccmn.h"

d74 5
a78 4
int rf_ConfigureDisks(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
d80 7
a86 7
  RF_RaidDisk_t **disks;
  RF_SectorCount_t min_numblks = (RF_SectorCount_t)0x7FFFFFFFFFFFLL;
  RF_RowCol_t r, c;
  int bs, ret;
  unsigned i, count, foundone=0, numFailuresThisRow;
  RF_DiskOp_t *rdcap_op = NULL, *tur_op = NULL;
  int num_rows_done,num_cols_done;
d88 1
a88 4
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
	struct proc *proc = 0;  
#endif
#ifndef SIMULATE
d90 18
a107 19
  ret = rf_SCSI_AllocReadCapacity(&rdcap_op);
  if (ret)
    goto fail;
  ret = rf_SCSI_AllocTUR(&tur_op);
  if (ret)
    goto fail;
#endif /* !__NetBSD__ && !__OpenBSD__ */
#endif /* !SIMULATE */

  num_rows_done = 0;
  num_cols_done = 0;


  RF_CallocAndAdd(disks, raidPtr->numRow, sizeof(RF_RaidDisk_t *), (RF_RaidDisk_t **), raidPtr->cleanupList);
  if (disks == NULL) {
    ret = ENOMEM;
    goto fail;
  }
  raidPtr->Disks = disks;
a108 1
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
d110 1
a110 1
  proc = raidPtr->proc; /* Blah XXX */
d112 19
a130 22
  /* get space for the device-specific stuff... */
  RF_CallocAndAdd(raidPtr->raid_cinfo, raidPtr->numRow, 
		  sizeof(struct raidcinfo *), (struct raidcinfo **),
		  raidPtr->cleanupList);
  if (raidPtr->raid_cinfo == NULL) {
	  ret = ENOMEM;
	  goto fail;
  }
#endif

  for (r=0; r<raidPtr->numRow; r++) {
    numFailuresThisRow = 0;
    RF_CallocAndAdd(disks[r], raidPtr->numCol + ((r==0) ? raidPtr->numSpare : 0), sizeof(RF_RaidDisk_t), (RF_RaidDisk_t *), raidPtr->cleanupList);
    if (disks[r] == NULL) {
      ret = ENOMEM;
      goto fail;
    }

    /* get more space for device specific stuff.. */
    RF_CallocAndAdd(raidPtr->raid_cinfo[r], 
		    raidPtr->numCol + ((r==0) ? raidPtr->numSpare : 0), 
		    sizeof(struct raidcinfo), (struct raidcinfo *), 
d132 28
a159 32
    if (raidPtr->raid_cinfo[r] == NULL) {
      ret = ENOMEM;
      goto fail;
    }


    for (c=0; c<raidPtr->numCol; c++) {
      ret = rf_ConfigureDisk(raidPtr,&cfgPtr->devnames[r][c][0], 
			     &disks[r][c], rdcap_op, tur_op, 
			     cfgPtr->devs[r][c],r,c);
      if (ret)
        goto fail;
      if (disks[r][c].status != rf_ds_optimal) {
        numFailuresThisRow++;
      }
      else {
        if (disks[r][c].numBlocks < min_numblks)
          min_numblks = disks[r][c].numBlocks;
        DPRINTF7("Disk at row %d col %d: dev %s numBlocks %ld blockSize %d (%ld MB)\n",
          r,c,disks[r][c].devname,
		 (long int) disks[r][c].numBlocks,
		 disks[r][c].blockSize,
		 (long int) disks[r][c].numBlocks * disks[r][c].blockSize / 1024 / 1024);
      }
      num_cols_done++;
    }
    /* XXX fix for n-fault tolerant */
    if (numFailuresThisRow > 0)
      raidPtr->status[r] = rf_rs_degraded;
    num_rows_done++;
  }
#ifndef SIMULATE
d161 1
a161 1
  /* we do nothing */
d163 51
a213 48
  rf_SCSI_FreeDiskOp(rdcap_op, 1); rdcap_op = NULL;
  rf_SCSI_FreeDiskOp(tur_op, 0);   tur_op   = NULL;
#endif
#endif /* !SIMULATE */
  /* all disks must be the same size & have the same block size, bs must be a power of 2 */
  bs = 0;
  for (foundone=r=0; !foundone && r<raidPtr->numRow; r++) {
    for (c=0; !foundone && c<raidPtr->numCol; c++) {
      if (disks[r][c].status == rf_ds_optimal) {
        bs = disks[r][c].blockSize;
        foundone = 1;
      }
    }
  }
  if (!foundone) {
    RF_ERRORMSG("RAIDFRAME: Did not find any live disks in the array.\n");
    ret = EINVAL;
    goto fail;
  }
  for (count=0,i=1; i; i<<=1) if (bs & i)
    count++;
  if (count != 1) {
    RF_ERRORMSG1("Error: block size on disks (%d) must be a power of 2\n",bs);
    ret = EINVAL;
    goto fail;
  }
  for (r=0; r<raidPtr->numRow; r++) {
    for (c=0; c<raidPtr->numCol; c++) {
      if (disks[r][c].status == rf_ds_optimal) {
	if (disks[r][c].blockSize != bs) {
	  RF_ERRORMSG2("Error: block size of disk at r %d c %d different from disk at r 0 c 0\n",r,c);
	  ret = EINVAL;
	  goto fail;
	}
	if (disks[r][c].numBlocks != min_numblks) {
	  RF_ERRORMSG3("WARNING: truncating disk at r %d c %d to %d blocks\n",
		       r,c,(int) min_numblks);
	  disks[r][c].numBlocks = min_numblks;
	}
      }
    }
  }

  raidPtr->sectorsPerDisk = min_numblks;
  raidPtr->logBytesPerSector = ffs(bs) - 1;
  raidPtr->bytesPerSector = bs;
  raidPtr->sectorMask = bs-1;
  return(0);
a216 1
#ifndef SIMULATE
d219 3
a221 3
  for(r=0;r<raidPtr->numRow;r++) {
	  for(c=0;c<raidPtr->numCol;c++) {
		  /* Cleanup.. */
d223 1
a223 1
		  printf("Cleaning up row: %d col: %d\n",r,c);
d225 9
a233 8
		  if (raidPtr->raid_cinfo[r][c].ci_vp) {
			  (void)vn_close(raidPtr->raid_cinfo[r][c].ci_vp, 
					 FREAD|FWRITE, proc->p_ucred, proc);
		  }
	  }
  }
  /* Space allocated for raid_vpp will get cleaned up at some other point */
  /* XXX Need more #ifdefs in the above... */
d235 1
a235 1
#else 
d237 4
a240 2
  if (rdcap_op) rf_SCSI_FreeDiskOp(rdcap_op, 1);
  if (tur_op)   rf_SCSI_FreeDiskOp(tur_op, 0);
d243 1
a243 2
#endif /* !SIMULATE */
  return(ret);
d252 5
a256 4
int rf_ConfigureSpareDisks(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
d258 6
a263 6
  char buf[256];
  int r,c,i, ret;
  RF_DiskOp_t *rdcap_op = NULL, *tur_op = NULL;
  unsigned bs;
  RF_RaidDisk_t *disks;
  int num_spares_done;
d265 1
a265 3
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
	struct proc *proc;  
#endif
a266 1
#ifndef SIMULATE
d268 33
a300 36
  ret = rf_SCSI_AllocReadCapacity(&rdcap_op);
  if (ret)
    goto fail;
  ret = rf_SCSI_AllocTUR(&tur_op);
  if (ret)
    goto fail;
#endif /* !__NetBSD__ && !__OpenBSD__ */
#endif /* !SIMULATE */

  num_spares_done = 0;

#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  proc = raidPtr->proc;
  /* The space for the spares should have already been 
     allocated by ConfigureDisks() */
#endif

  disks = &raidPtr->Disks[0][raidPtr->numCol];
  for (i=0; i<raidPtr->numSpare; i++) {
    ret = rf_ConfigureDisk(raidPtr,&cfgPtr->spare_names[i][0], 
			   &disks[i], rdcap_op, tur_op, 
			   cfgPtr->spare_devs[i],0,raidPtr->numCol+i);
    if (ret)
      goto fail;
    if (disks[i].status != rf_ds_optimal) {
      RF_ERRORMSG1("Warning: spare disk %s failed TUR\n",buf);
    } else {
      disks[i].status = rf_ds_spare;      /* change status to spare */
      DPRINTF6("Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\n",i,
	       disks[i].devname,
	       (long int) disks[i].numBlocks,disks[i].blockSize,
	       (long int) disks[i].numBlocks * disks[i].blockSize / 1024 / 1024);
    }
    num_spares_done++;
  }
#ifndef SIMULATE
d304 26
a329 4
  rf_SCSI_FreeDiskOp(rdcap_op, 1); rdcap_op = NULL;
  rf_SCSI_FreeDiskOp(tur_op, 0);   tur_op   = NULL;
#endif
#endif /* !SIMULATE */
d331 1
a331 21
  /* check sizes and block sizes on spare disks */
  bs = 1 << raidPtr->logBytesPerSector;
  for (i=0; i<raidPtr->numSpare; i++) {
    if (disks[i].blockSize != bs) {
      RF_ERRORMSG3("Block size of %d on spare disk %s is not the same as on other disks (%d)\n",disks[i].blockSize, disks[i].devname, bs);
      ret = EINVAL;
      goto fail;
    }
    if (disks[i].numBlocks < raidPtr->sectorsPerDisk) {
	    RF_ERRORMSG3("Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\n", 
		disks[i].devname, disks[i].blockSize, (long int)raidPtr->sectorsPerDisk);
      ret = EINVAL;
      goto fail;
    } else if (disks[i].numBlocks > raidPtr->sectorsPerDisk) {
	    RF_ERRORMSG2("Warning: truncating spare disk %s to %ld blocks\n",disks[i].devname, (long int) raidPtr->sectorsPerDisk);

      disks[i].numBlocks = raidPtr->sectorsPerDisk;
    }
  }
  
  return(0);
a333 1
#ifndef SIMULATE
d336 2
a337 2
  /* Release the hold on the main components.  We've failed to allocate a 
     spare, and since we're failing, we need to free things.. */
d339 3
a341 3
  for(r=0;r<raidPtr->numRow;r++) {
	  for(c=0;c<raidPtr->numCol;c++) {
		  /* Cleanup.. */
d343 1
a343 1
		  printf("Cleaning up row: %d col: %d\n",r,c);
d345 6
a350 6
		  if (raidPtr->raid_cinfo[r][c].ci_vp) {
			  (void)vn_close(raidPtr->raid_cinfo[r][c].ci_vp, 
					 FREAD|FWRITE, proc->p_ucred, proc);
		  }
	  }
  }
d352 2
a353 2
  for(i=0;i<raidPtr->numSpare;i++) {
	  /* Cleanup.. */
d355 1
a355 1
	  printf("Cleaning up spare: %d\n",i);
d357 5
a361 5
	  if (raidPtr->raid_cinfo[0][raidPtr->numCol+i].ci_vp) {
		  (void)vn_close(raidPtr->raid_cinfo[0][raidPtr->numCol+i].ci_vp, 
				 FREAD|FWRITE, proc->p_ucred, proc);
	  }
  }
d363 1
a363 1
#else 
d365 4
a368 2
  if (rdcap_op) rf_SCSI_FreeDiskOp(rdcap_op, 1);
  if (tur_op)   rf_SCSI_FreeDiskOp(tur_op, 0);
d372 1
a372 2
#endif /* !SIMULATE */
  return(ret);
d378 10
a387 9
int rf_ConfigureDisk(raidPtr, buf, diskPtr, rdcap_op, tur_op, dev, row, col)
  RF_Raid_t      *raidPtr;  /* We need this down here too!! GO */
  char           *buf;
  RF_RaidDisk_t  *diskPtr;
  RF_DiskOp_t    *rdcap_op;
  RF_DiskOp_t    *tur_op;
  dev_t           dev;      /* device number used only in kernel */
  RF_RowCol_t     row;
  RF_RowCol_t     col;
d389 2
a390 10
  char *p;
#ifdef SIMULATE
  double	init_offset;
#else /* SIMULATE  */
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  int retcode;
#else
  int busid, targid, lun, retcode;
#endif
#endif /* SIMULATE  */
a391 1
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
d396 1
a396 2
	int error;
#endif
d398 7
a404 18
retcode = 0;
  p = rf_find_non_white(buf);
  if (p[strlen(p)-1] == '\n') {
    /* strip off the newline */
    p[strlen(p)-1] = '\0';
  }
  (void) strcpy(diskPtr->devname, p);

#ifdef SIMULATE

  init_offset = 0.0;
  rf_InitDisk(&diskPtr->diskState, disk_db_file_name,diskPtr->devname,0,0,init_offset,row,col);
  rf_GeometryDoReadCapacity(&diskPtr->diskState, &diskPtr->numBlocks, &diskPtr->blockSize);
  diskPtr->numBlocks = diskPtr->numBlocks * rf_sizePercentage / 100;
  
  /* we allow the user to specify that only a fraction of the disks should be used
   * this is just for debug:  it speeds up the parity scan
   */
a405 1
#else /* SIMULATE */
d407 26
a432 26
  /* get bus, target, lun */
  retcode = rf_extract_ids(p, &busid, &targid, &lun);
  if (retcode)
    return(retcode);

  /* required in kernel, nop at user level */
  retcode = rf_SCSI_OpenUnit(dev);
  if (retcode)
    return(retcode);

  diskPtr->dev = dev;
  if (rf_SCSI_DoTUR(tur_op, (u_char)busid, (u_char)targid, (u_char)lun, dev)) {
    RF_ERRORMSG1("Disk %s failed TUR.  Marked as dead.\n",diskPtr->devname);
    diskPtr->status = rf_ds_failed;
  } else {
    diskPtr->status = rf_ds_optimal;
    retcode = rf_SCSI_DoReadCapacity(raidPtr,rdcap_op, busid, targid, lun, dev,
      &diskPtr->numBlocks, &diskPtr->blockSize, diskPtr->devname);
    if (retcode)
      return(retcode);
    
    /* we allow the user to specify that only a fraction of the disks should be used
     * this is just for debug:  it speeds up the parity scan
     */
    diskPtr->numBlocks = diskPtr->numBlocks * rf_sizePercentage / 100;
  }
a433 42
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  
  proc = raidPtr->proc;  /* XXX Yes, this is not nice.. */
  
  /* Let's start by claiming the component is fine and well... */
  /* XXX not the case if the disk is toast.. */
  diskPtr->status = rf_ds_optimal; 


  raidPtr->raid_cinfo[row][col].ci_vp = NULL;
  raidPtr->raid_cinfo[row][col].ci_dev = NULL;

  error = raidlookup(diskPtr->devname, proc, &vp);
  if (error) {
	  printf("raidlookup on device: %s failed!\n",diskPtr->devname);
	  if (error == ENXIO) {
		  /* XXX the component isn't there... must be dead :-( */
		  diskPtr->status = rf_ds_failed;
	  } else {
		  return(error);
	  }
  }

  if (diskPtr->status == rf_ds_optimal) {

	  if ((error = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {
		  return(error);
	  } 

	  error = VOP_IOCTL(vp, DIOCGPART, (caddr_t)&dpart, 
			    FREAD, proc->p_ucred, proc);
	  if (error) {
		  return(error);
	  } 


	  diskPtr->blockSize = dpart.disklab->d_secsize;
	  
	  diskPtr->numBlocks = dpart.part->p_size - rf_protectedSectors;
	  
	  raidPtr->raid_cinfo[row][col].ci_vp = vp;
	  raidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;
d435 1
a435 3
#if 0
	  diskPtr->dev = dev;
#endif
d437 19
a455 1
	  diskPtr->dev = va.va_rdev; /* XXX or the above? */
d457 9
a465 6
	  /* we allow the user to specify that only a fraction of the disks should be used
	   * this is just for debug:  it speeds up the parity scan
	   */
	  diskPtr->numBlocks = diskPtr->numBlocks * rf_sizePercentage / 100;
    
  }
d467 1
a467 2
#endif /* !__NetBSD__ && !__OpenBSD__ */
#endif /* SIMULATE */
d469 2
a470 2
  return(0);
}
d472 3
a474 1
#ifdef SIMULATE
d476 1
a476 5
void rf_default_disk_names()
{
    sprintf(disk_db_file_name,"disk.db");
    sprintf(disk_type_name,"HP2247");
}
d478 4
a481 5
void rf_set_disk_db_name(s)
 char  *s;
{
    strcpy(disk_db_file_name,s);
}
d483 2
a484 4
void rf_set_disk_type_name(s)
 char  *s;
{
    strcpy(disk_type_name,s);
a485 2

#endif /* SIMULATE */
@

