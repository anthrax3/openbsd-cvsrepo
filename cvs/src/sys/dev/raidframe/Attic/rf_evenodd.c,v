head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.34
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.32
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.28
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.16
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.14
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.12
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.10
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.6;

1.6
date	2011.06.21.16.46.00;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.4.2.1
	1.4.12.1;
next	1.3;

1.3
date	2000.01.07.14.50.21;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.44;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.21;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.4.12.1
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_evenodd.c,v 1.6 2011/06/21 16:46:00 tedu Exp $	*/
/*	$NetBSD: rf_evenodd.c,v 1.4 2000/01/07 03:40:59 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chang-Ming Wu
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 *
 * rf_evenodd.c -- implements EVENODD array architecture
 *
 *****************************************************************************/

#include "rf_archs.h"

#if	RF_INCLUDE_EVENODD > 0

#include "rf_types.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagffrd.h"
#include "rf_dagffwr.h"
#include "rf_dagdegrd.h"
#include "rf_dagdegwr.h"
#include "rf_dagutils.h"
#include "rf_dagfuncs.h"
#include "rf_etimer.h"
#include "rf_general.h"
#include "rf_evenodd.h"
#include "rf_configure.h"
#include "rf_parityscan.h"
#include "rf_utils.h"
#include "rf_map.h"
#include "rf_pq.h"
#include "rf_mcpair.h"
#include "rf_evenodd.h"
#include "rf_evenodd_dagfuncs.h"
#include "rf_evenodd_dags.h"
#include "rf_engine.h"

typedef struct RF_EvenOddConfigInfo_s {
	RF_RowCol_t **stripeIdentifier;	/*
					 * Filled in at config time & used by
					 * IdentifyStripe.
					 */
}	RF_EvenOddConfigInfo_t;

int
rf_ConfigureEvenOdd(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
	RF_EvenOddConfigInfo_t *info;
	RF_RowCol_t i, j, startdisk;

	RF_MallocAndAdd(info, sizeof(RF_EvenOddConfigInfo_t),
	    (RF_EvenOddConfigInfo_t *), raidPtr->cleanupList);
	layoutPtr->layoutSpecificInfo = (void *) info;

	RF_ASSERT(raidPtr->numRow == 1);

	info->stripeIdentifier = rf_make_2d_array(raidPtr->numCol,
	    raidPtr->numCol, raidPtr->cleanupList);
	startdisk = 0;
	for (i = 0; i < raidPtr->numCol; i++) {
		for (j = 0; j < raidPtr->numCol; j++) {
			info->stripeIdentifier[i][j] = (startdisk + j) %
			    raidPtr->numCol;
		}
		if ((startdisk -= 2) < 0)
			startdisk += raidPtr->numCol;
	}

	/* Fill in the remaining layout parameters. */
	layoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
	layoutPtr->numDataCol = raidPtr->numCol - 2;	/*
							 * ORIG:
							 * layoutPtr->numDataCol
							 * = raidPtr->numCol-1;
							 */
#if	RF_EO_MATRIX_DIM > 17
	if (raidPtr->numCol <= 17) {
		printf("Number of stripe units in a parity stripe is smaller"
		    " than 17. Please\ndefine the macro RF_EO_MATRIX_DIM in"
		    " file rf_evenodd_dagfuncs.h to\nbe 17 to increase"
		    " performance.\n");
		return (EINVAL);
	}
#elif	RF_EO_MATRIX_DIM == 17
	if (raidPtr->numCol > 17) {
		printf("Number of stripe units in a parity stripe is bigger"
		    " than 17. Please\ndefine the macro RF_EO_MATRIX_DIM in"
		    " file rf_evenodd_dagfuncs.h to\nbe 257 for encoding and"
		    " decoding functions to work.\n");
		return (EINVAL);
	}
#endif
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
	layoutPtr->numParityCol = 2;
	layoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;

	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;

	return (0);
}

int
rf_GetDefaultNumFloatingReconBuffersEvenOdd(RF_Raid_t *raidPtr)
{
	return (20);
}

RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitEvenOdd(RF_Raid_t *raidPtr)
{
	return (10);
}

void
rf_IdentifyStripeEvenOdd(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
{
	RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout,
	    addr);
	RF_EvenOddConfigInfo_t *info =
	    (RF_EvenOddConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;

	*outRow = 0;
	*diskids = info->stripeIdentifier[stripeID % raidPtr->numCol];
}


/*
 * The layout of stripe unit on the disks are:	c0 c1 c2 c3 c4
 *
 *						 0  1  2  E  P
 *						 5  E  P  3  4
 *						 P  6  7  8  E
 *	 					10 11  E  P  9
 *						 E  P 12 13 14
 *						....
 *
 * We use the MapSectorRAID5 to map data information because the routine can
 * be shown to map exactly the layout of data stripe unit as shown above,
 * although we have 2 redundant information now.
 * But for E and P, we use rf_MapEEvenOdd and rf_MapParityEvenOdd which are
 * different method from raid-5.
 */


void
rf_MapParityEvenOdd(
    RF_Raid_t		*raidPtr,
    RF_RaidAddr_t	 raidSector,
    RF_RowCol_t		*row,
    RF_RowCol_t		*col,
    RF_SectorNum_t	*diskSector,
    int			 remap
)
{
	RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
	RF_StripeNum_t endSUIDofthisStrip =
	    (SUID / raidPtr->Layout.numDataCol + 1) *
	    raidPtr->Layout.numDataCol - 1;

	*row = 0;
	*col = (endSUIDofthisStrip + 2) % raidPtr->numCol;
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
	    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
}

void
rf_MapEEvenOdd(
    RF_Raid_t		*raidPtr,
    RF_RaidAddr_t	 raidSector,
    RF_RowCol_t		*row,
    RF_RowCol_t		*col,
    RF_SectorNum_t	*diskSector,
    int			 remap
)
{
	RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
	RF_StripeNum_t endSUIDofthisStrip =
	    (SUID / raidPtr->Layout.numDataCol + 1) *
	    raidPtr->Layout.numDataCol - 1;

	*row = 0;
	*col = (endSUIDofthisStrip + 1) % raidPtr->numCol;
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
	    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
}

void
rf_EODagSelect(
    RF_Raid_t		*raidPtr,
    RF_IoType_t		 type,
    RF_AccessStripeMap_t *asmap,
    RF_VoidFuncPtr	*createFunc
)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	unsigned ndfail = asmap->numDataFailed;
	unsigned npfail = asmap->numParityFailed + asmap->numQFailed;
	unsigned ntfail = npfail + ndfail;

	RF_ASSERT(RF_IO_IS_R_OR_W(type));
	if (ntfail > 2) {
		RF_ERRORMSG("more than two disks failed in a single group !"
		    "  Aborting I/O operation.\n");
		 /* *infoFunc = */ *createFunc = NULL;
		return;
	}
	/* Ok, we can do this I/O. */
	if (type == RF_IO_TYPE_READ) {
		switch (ndfail) {
		case 0:
			/* Fault free read. */
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateFaultFreeReadDAG;	/* Same as raid 5. */
			break;
		case 1:
			/* Lost a single data unit. */
			/*
			 * Two cases:
			 * (1) Parity is not lost. Do a normal raid 5
			 * reconstruct read.
			 * (2) Parity is lost. Do a reconstruct read using "e".
			 */
			if (ntfail == 2) {	/* Also lost redundancy. */
				if (asmap->failedPDAs[1]->type ==
				    RF_PDA_TYPE_PARITY)
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_110_CreateReadDAG;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_101_CreateReadDAG;
			} else {
				/*
				 * P and E are ok. But is there a failure in
				 * some unaccessed data unit ?
				 */
				if (rf_NumFailedDataUnitsInStripe(raidPtr,
				    asmap) == 2)
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_200_CreateReadDAG;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_100_CreateReadDAG;
			}
			break;
		case 2:
			/* *createFunc = rf_EO_200_CreateReadDAG; */
			*createFunc = NULL;
			break;
		}
		return;
	}
	/* A write. */
	switch (ntfail) {
	case 0:		/* Fault free. */
		if (rf_suppressLocksAndLargeWrites ||
		    (((asmap->numStripeUnitsAccessed <=
		       (layoutPtr->numDataCol / 2)) &&
		      (layoutPtr->numDataCol != 1)) ||
		     (asmap->parityInfo->next != NULL) ||
		     (asmap->qInfo->next != NULL) ||
		     rf_CheckStripeForFailures(raidPtr, asmap))) {

			*createFunc = (RF_VoidFuncPtr) rf_EOCreateSmallWriteDAG;
		} else {
			*createFunc = (RF_VoidFuncPtr) rf_EOCreateLargeWriteDAG;
		}
		break;

	case 1:		/* Single disk fault. */
		if (npfail == 1) {
			RF_ASSERT((asmap->failedPDAs[0]->type ==
			    RF_PDA_TYPE_PARITY) ||
			    (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));
			if (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {
				/*
				 * q died, treat like normal mode raid5
				 * write.
				 */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    (asmap->parityInfo->next != NULL) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_001_CreateSmallWriteDAG;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_001_CreateLargeWriteDAG;
			} else {
				/* Parity died, small write only updating Q. */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    (asmap->qInfo->next != NULL) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_010_CreateSmallWriteDAG;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_010_CreateLargeWriteDAG;
			}
		} else {	/*
				 * Data missing. Do a P reconstruct write if
				 * only a single data unit is lost in the
				 * stripe, otherwise a reconstruct write which
				 * is employing both P and E units.
				 */
			if (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)
			{
				if (asmap->numStripeUnitsAccessed == 1)
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_200_CreateWriteDAG;
				else
					/*
					 * No direct support for this case now,
					 * like that in Raid-5.
					 */
					*createFunc = NULL;
			} else {
				if (asmap->numStripeUnitsAccessed != 1 &&
				    asmap->failedPDAs[0]->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					/*
					 * No direct support for this case now,
					 * like that in Raid-5.
					 */
					*createFunc = NULL;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_100_CreateWriteDAG;
			}
		}
		break;

	case 2:		/* Two disk faults. */
		switch (npfail) {
		case 2:	/* Both p and q dead. */
			*createFunc = (RF_VoidFuncPtr) rf_EO_011_CreateWriteDAG;
			break;
		case 1:	/* Either p or q and dead data. */
			RF_ASSERT(asmap->failedPDAs[0]->type ==
			    RF_PDA_TYPE_DATA);
			RF_ASSERT((asmap->failedPDAs[1]->type ==
			    RF_PDA_TYPE_PARITY) ||
			    (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));
			if (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q) {
				if (asmap->numStripeUnitsAccessed != 1 &&
				    asmap->failedPDAs[0]->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					/*
					 * In both PQ and EvenOdd, no direct
					 * support for this case now, like that
					 * in Raid-5.
					 */
					*createFunc = NULL;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_101_CreateWriteDAG;
			} else {
				if (asmap->numStripeUnitsAccessed != 1 &&
				    asmap->failedPDAs[0]->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					/*
					 * No direct support for this case,
					 * like that in Raid-5.
					 */
					*createFunc = NULL;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_110_CreateWriteDAG;
			}
			break;
		case 0:	/* Double data loss. */
			/*
			 * if(asmap->failedPDAs[0]->numSector +
			 * asmap->failedPDAs[1]->numSector == 2 *
			 * layoutPtr->sectorsPerStripeUnit ) createFunc =
			 * rf_EOCreateLargeWriteDAG; else
			 */
			*createFunc = NULL;	/*
						 * Currently, in Evenodd, no
						 * support for simultaneous
						 * access of both failed SUs.
						 */
			break;
		}
		break;

	default:	/* More than 2 disk faults. */
		*createFunc = NULL;
		RF_PANIC();
	}
	return;
}


int
rf_VerifyParityEvenOdd(
	RF_Raid_t		*raidPtr,
	RF_RaidAddr_t		 raidAddr,
	RF_PhysDiskAddr_t	*parityPDA,
	int			 correct_it,
	RF_RaidAccessFlags_t	 flags
)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	RF_RaidAddr_t startAddr =
	    rf_RaidAddressOfPrevStripeBoundary(layoutPtr, raidAddr);
	RF_SectorCount_t numsector = parityPDA->numSector;
	int numbytes = rf_RaidAddressToByte(raidPtr, numsector);
	int bytesPerStripe = numbytes * layoutPtr->numDataCol;
	RF_DagHeader_t *rd_dag_h, *wr_dag_h;	/* Read, write dag. */
	RF_DagNode_t *blockNode, *unblockNode, *wrBlock, *wrUnblock;
	RF_AccessStripeMapHeader_t *asm_h;
	RF_AccessStripeMap_t *asmap;
	RF_AllocListElem_t *alloclist;
	RF_PhysDiskAddr_t *pda;
	char *pbuf, *buf, *end_p, *p;
	char *redundantbuf2;
	int redundantTwoErr = 0, redundantOneErr = 0;
	int parity_cant_correct = RF_FALSE, red2_cant_correct = RF_FALSE,
	    parity_corrected = RF_FALSE, red2_corrected = RF_FALSE;
	int i, retcode;
	RF_ReconUnitNum_t which_ru;
	RF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr,
	    raidAddr, &which_ru);
	int stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;
	RF_AccTraceEntry_t tracerec;
	RF_MCPair_t *mcpair;

	retcode = RF_PARITY_OKAY;

	mcpair = rf_AllocMCPair();
	rf_MakeAllocList(alloclist);
	RF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol +
	    layoutPtr->numParityCol), (char *), alloclist);
	/* Use calloc to make sure buffer is zeroed. */
	RF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);
	end_p = buf + bytesPerStripe;
	/* Use calloc to make sure buffer is zeroed. */
	RF_CallocAndAdd(redundantbuf2, 1, numbytes, (char *), alloclist);

	rd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf,
	    rf_DiskReadFunc, rf_DiskReadUndoFunc, "Rod", alloclist, flags,
	    RF_IO_NORMAL_PRIORITY);
	blockNode = rd_dag_h->succedents[0];
	unblockNode = blockNode->succedents[0]->succedents[0];

	/* Map the stripe and fill in the PDAs in the dag. */
	asm_h = rf_MapAccess(raidPtr, startAddr,
	    layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);
	asmap = asm_h->stripeMap;

	for (pda = asmap->physInfo, i = 0; i < layoutPtr->numDataCol;
	     i++, pda = pda->next) {
		RF_ASSERT(pda);
		rf_RangeRestrictPDA(raidPtr, parityPDA, pda, 0, 1);
		RF_ASSERT(pda->numSector != 0);
		if (rf_TryToRedirectPDA(raidPtr, pda, 0))
			/*
			 * No way to verify parity if disk is dead.
			 * Return w/ good status.
			 */
			goto out;
		blockNode->succedents[i]->params[0].p = pda;
		blockNode->succedents[i]->params[2].v = psID;
		blockNode->succedents[i]->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
	}

	RF_ASSERT(!asmap->parityInfo->next);
	rf_RangeRestrictPDA(raidPtr, parityPDA, asmap->parityInfo, 0, 1);
	RF_ASSERT(asmap->parityInfo->numSector != 0);
	if (rf_TryToRedirectPDA(raidPtr, asmap->parityInfo, 1))
		goto out;
	blockNode->succedents[layoutPtr->numDataCol]->params[0].p =
	    asmap->parityInfo;

	RF_ASSERT(!asmap->qInfo->next);
	rf_RangeRestrictPDA(raidPtr, parityPDA, asmap->qInfo, 0, 1);
	RF_ASSERT(asmap->qInfo->numSector != 0);
	if (rf_TryToRedirectPDA(raidPtr, asmap->qInfo, 1))
		goto out;
	/*
	 * If disk is dead, b/c no reconstruction is implemented right now,
	 * the function "rf_TryToRedirectPDA" always return one, which causes
	 * go to out and return w/ good status.
	 */
	blockNode->succedents[layoutPtr->numDataCol + 1]->params[0].p =
	    asmap->qInfo;

	/* Fire off the DAG. */
	bzero(&tracerec, sizeof(tracerec));
	rd_dag_h->tracerec = &tracerec;

	if (rf_verifyParityDebug) {
		printf("Parity verify read dag:\n");
		rf_PrintDAGList(rd_dag_h);
	}
	RF_LOCK_MUTEX(mcpair->mutex);
	mcpair->flag = 0;
	rf_DispatchDAG(rd_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,
	    (void *) mcpair);
	while (!mcpair->flag)
		RF_WAIT_COND(mcpair->cond, mcpair->mutex);
	RF_UNLOCK_MUTEX(mcpair->mutex);
	if (rd_dag_h->status != rf_enable) {
		RF_ERRORMSG("Unable to verify parity:  can't read"
		    " the stripe\n");
		retcode = RF_PARITY_COULD_NOT_VERIFY;
		goto out;
	}
	for (p = buf, i = 0; p < end_p; p += numbytes, i++) {
		rf_e_encToBuf(raidPtr, i, p, RF_EO_MATRIX_DIM - 2,
		    redundantbuf2, numsector);
		/*
		 * The corresponding columns in EvenOdd encoding Matrix for
		 * these p pointers that point to the databuffer in a full
		 * stripe are sequential from 0 to layoutPtr->numDataCol-1.
		 */
		rf_bxor(p, pbuf, numbytes, NULL);
	}
	RF_ASSERT(i == layoutPtr->numDataCol);

	for (i = 0; i < numbytes; i++) {
		if (pbuf[i] != buf[bytesPerStripe + i]) {
			if (!correct_it) {
				RF_ERRORMSG3("Parity verify error: byte %d of"
				    " parity is 0x%x should be 0x%x\n", i,
				    (u_char) buf[bytesPerStripe + i],
				    (u_char) pbuf[i]);
			}
		}
		redundantOneErr = 1;
		break;
	}

	for (i = 0; i < numbytes; i++) {
		if (redundantbuf2[i] != buf[bytesPerStripe + numbytes + i]) {
			if (!correct_it) {
				RF_ERRORMSG3("Parity verify error: byte %d of"
				    " second redundant information is 0x%x"
				    " should be 0x%x\n", i,
				    (u_char) buf[bytesPerStripe + numbytes + i],
				    (u_char) redundantbuf2[i]);
			}
			redundantTwoErr = 1;
			break;
		}
	}
	if (redundantOneErr || redundantTwoErr)
		retcode = RF_PARITY_BAD;

	/* Correct the first redundant disk, ie parity if it is error. */
	if (redundantOneErr && correct_it) {
		wr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf,
		    rf_DiskWriteFunc, rf_DiskWriteUndoFunc, "Wnp", alloclist,
		    flags, RF_IO_NORMAL_PRIORITY);
		wrBlock = wr_dag_h->succedents[0];
		wrUnblock = wrBlock->succedents[0]->succedents[0];
		wrBlock->succedents[0]->params[0].p = asmap->parityInfo;
		wrBlock->succedents[0]->params[2].v = psID;
		wrBlock->succedents[0]->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
		bzero(&tracerec, sizeof(tracerec));
		wr_dag_h->tracerec = &tracerec;
		if (rf_verifyParityDebug) {
			printf("Parity verify write dag:\n");
			rf_PrintDAGList(wr_dag_h);
		}
		RF_LOCK_MUTEX(mcpair->mutex);
		mcpair->flag = 0;
		rf_DispatchDAG(wr_dag_h,
		    (void (*) (void *)) rf_MCPairWakeupFunc, (void *) mcpair);
		while (!mcpair->flag)
			RF_WAIT_COND(mcpair->cond, mcpair->mutex);
		RF_UNLOCK_MUTEX(mcpair->mutex);
		if (wr_dag_h->status != rf_enable) {
			RF_ERRORMSG("Unable to correct parity in VerifyParity:"
			    " can't write the stripe\n");
			parity_cant_correct = RF_TRUE;
		} else {
			parity_corrected = RF_TRUE;
		}
		rf_FreeDAG(wr_dag_h);
	}
	if (redundantTwoErr && correct_it) {
		wr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes,
		    redundantbuf2, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
		    "Wnred2", alloclist, flags, RF_IO_NORMAL_PRIORITY);
		wrBlock = wr_dag_h->succedents[0];
		wrUnblock = wrBlock->succedents[0]->succedents[0];
		wrBlock->succedents[0]->params[0].p = asmap->qInfo;
		wrBlock->succedents[0]->params[2].v = psID;
		wrBlock->succedents[0]->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
		bzero(&tracerec, sizeof(tracerec));
		wr_dag_h->tracerec = &tracerec;
		if (rf_verifyParityDebug) {
			printf("Dag of write new second redundant information"
			    " in parity verify :\n");
			rf_PrintDAGList(wr_dag_h);
		}
		RF_LOCK_MUTEX(mcpair->mutex);
		mcpair->flag = 0;
		rf_DispatchDAG(wr_dag_h,
		    (void (*) (void *)) rf_MCPairWakeupFunc, (void *) mcpair);
		while (!mcpair->flag)
			RF_WAIT_COND(mcpair->cond, mcpair->mutex);
		RF_UNLOCK_MUTEX(mcpair->mutex);
		if (wr_dag_h->status != rf_enable) {
			RF_ERRORMSG("Unable to correct second redundant"
			    " information in VerifyParity: can't write the"
			    " stripe\n");
			red2_cant_correct = RF_TRUE;
		} else {
			red2_corrected = RF_TRUE;
		}
		rf_FreeDAG(wr_dag_h);
	}
	if ((redundantOneErr && parity_cant_correct) ||
	    (redundantTwoErr && red2_cant_correct))
		retcode = RF_PARITY_COULD_NOT_CORRECT;
	if ((retcode = RF_PARITY_BAD) && parity_corrected && red2_corrected)
		retcode = RF_PARITY_CORRECTED;


out:
	rf_FreeAccessStripeMap(asm_h);
	rf_FreeAllocList(alloclist);
	rf_FreeDAG(rd_dag_h);
	rf_FreeMCPair(mcpair);
	return (retcode);
}
#endif	/* RF_INCLUDE_EVENODD > 0 */
@


1.6
log
@remove stupid casts, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_evenodd.c,v 1.5 2002/12/16 07:01:03 tdeval Exp $	*/
@


1.5
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_evenodd.c,v 1.4 2000/01/11 18:02:22 peter Exp $	*/
d532 1
a532 1
	bzero((char *) &tracerec, sizeof(tracerec));
d604 1
a604 1
		bzero((char *) &tracerec, sizeof(tracerec));
d636 1
a636 1
		bzero((char *) &tracerec, sizeof(tracerec));
@


1.4
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_evenodd.c,v 1.3 2000/01/07 14:50:21 peter Exp $	*/
d3 1
d31 1
a31 1
/*****************************************************************************************
d35 1
a35 1
 ****************************************************************************************/
d39 1
a39 1
#if RF_INCLUDE_EVENODD > 0
d65 9
a73 9
	RF_RowCol_t **stripeIdentifier;	/* filled in at config time & used by
					 * IdentifyStripe */
}       RF_EvenOddConfigInfo_t;

int 
rf_ConfigureEvenOdd(listp, raidPtr, cfgPtr)
	RF_ShutdownList_t **listp;
	RF_Raid_t *raidPtr;
	RF_Config_t *cfgPtr;
d79 2
a80 1
	RF_MallocAndAdd(info, sizeof(RF_EvenOddConfigInfo_t), (RF_EvenOddConfigInfo_t *), raidPtr->cleanupList);
d85 2
a86 1
	info->stripeIdentifier = rf_make_2d_array(raidPtr->numCol, raidPtr->numCol, raidPtr->cleanupList);
d90 2
a91 1
			info->stripeIdentifier[i][j] = (startdisk + j) % raidPtr->numCol;
d97 1
a97 1
	/* fill in the remaining layout parameters */
d99 4
a102 2
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;
	layoutPtr->numDataCol = raidPtr->numCol - 2;	/* ORIG:
d104 3
a106 2
							 * = raidPtr->numCol-1;  */
#if RF_EO_MATRIX_DIM > 17
d108 4
a111 3
		printf("Number of stripe units in a parity stripe is smaller than 17. Please\n");
		printf("define the macro RF_EO_MATRIX_DIM in file rf_evenodd_dagfuncs.h to \n");
		printf("be 17 to increase performance. \n");
d114 1
a114 1
#elif RF_EO_MATRIX_DIM == 17
d116 4
a119 3
		printf("Number of stripe units in a parity stripe is bigger than 17. Please\n");
		printf("define the macro RF_EO_MATRIX_DIM in file rf_evenodd_dagfuncs.h to \n");
		printf("be 257 for encoding and decoding functions to work. \n");
d123 2
a124 1
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d127 2
a128 1
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;
d130 2
a131 1
	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d136 2
a137 2
int 
rf_GetDefaultNumFloatingReconBuffersEvenOdd(RF_Raid_t * raidPtr)
d142 2
a143 2
RF_HeadSepLimit_t 
rf_GetDefaultHeadSepLimitEvenOdd(RF_Raid_t * raidPtr)
d148 3
a150 6
void 
rf_IdentifyStripeEvenOdd(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t addr,
    RF_RowCol_t ** diskids,
    RF_RowCol_t * outRow)
d152 4
a155 2
	RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, addr);
	RF_EvenOddConfigInfo_t *info = (RF_EvenOddConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
a159 1
/* The layout of stripe unit on the disks are:      c0 c1 c2 c3 c4
d161 17
a177 11
 						     0  1  2  E  P
						     5  E  P  3  4
						     P  6  7  8  E
	 					    10 11  E  P  9
						     E  P 12 13 14
						     ....

  We use the MapSectorRAID5 to map data information because the routine can be shown to map exactly
  the layout of data stripe unit as shown above although we have 2 redundant information now.
  But for E and P, we use rf_MapEEvenOdd and rf_MapParityEvenOdd which are different method from raid-5.
*/
d180 1
a180 1
void 
d182 7
a188 6
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d191 3
a193 1
	RF_StripeNum_t endSUIDofthisStrip = (SUID / raidPtr->Layout.numDataCol + 1) * raidPtr->Layout.numDataCol - 1;
d197 2
a198 1
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
d202 1
a202 1
void 
d204 7
a210 6
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d213 3
a215 1
	RF_StripeNum_t endSUIDofthisStrip = (SUID / raidPtr->Layout.numDataCol + 1) * raidPtr->Layout.numDataCol - 1;
d219 2
a220 1
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
d224 1
a224 1
void 
d226 5
a230 4
    RF_Raid_t * raidPtr,
    RF_IoType_t type,
    RF_AccessStripeMap_t * asmap,
    RF_VoidFuncPtr * createFunc)
d239 2
a240 1
		RF_ERRORMSG("more than two disks failed in a single group!  Aborting I/O operation.\n");
d244 1
a244 1
	/* ok, we can do this I/O */
d248 3
a250 2
			/* fault free read */
			*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;	/* same as raid 5 */
d253 12
a264 7
			/* lost a single data unit */
			/* two cases: (1) parity is not lost. do a normal raid
			 * 5 reconstruct read. (2) parity is lost. do a
			 * reconstruct read using "e". */
			if (ntfail == 2) {	/* also lost redundancy */
				if (asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY)
					*createFunc = (RF_VoidFuncPtr) rf_EO_110_CreateReadDAG;
d266 2
a267 1
					*createFunc = (RF_VoidFuncPtr) rf_EO_101_CreateReadDAG;
d269 8
a276 4
				/* P and E are ok. But is there a failure in
				 * some unaccessed data unit? */
				if (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)
					*createFunc = (RF_VoidFuncPtr) rf_EO_200_CreateReadDAG;
d278 2
a279 1
					*createFunc = (RF_VoidFuncPtr) rf_EO_100_CreateReadDAG;
d289 1
a289 1
	/* a write */
d291 1
a291 1
	case 0:		/* fault free */
d293 6
a298 2
		    (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||
			(asmap->parityInfo->next != NULL) || (asmap->qInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {
d306 1
a306 1
	case 1:		/* single disk fault */
d308 16
a323 7
			RF_ASSERT((asmap->failedPDAs[0]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));
			if (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {	/* q died, treat like
										 * normal mode raid5
										 * write. */
				if (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))
				    || (asmap->parityInfo->next != NULL) || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))
					*createFunc = (RF_VoidFuncPtr) rf_EO_001_CreateSmallWriteDAG;
d325 12
a336 5
					*createFunc = (RF_VoidFuncPtr) rf_EO_001_CreateLargeWriteDAG;
			} else {/* parity died, small write only updating Q */
				if (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))
				    || (asmap->qInfo->next != NULL) || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))
					*createFunc = (RF_VoidFuncPtr) rf_EO_010_CreateSmallWriteDAG;
d338 2
a339 1
					*createFunc = (RF_VoidFuncPtr) rf_EO_010_CreateLargeWriteDAG;
d341 2
a342 1
		} else {	/* data missing. Do a P reconstruct write if
d345 4
a348 2
				 * employnig both P and E units. */
			if (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2) {
d350 2
a351 1
					*createFunc = (RF_VoidFuncPtr) rf_EO_200_CreateWriteDAG;
d353 5
a357 3
					*createFunc = NULL;	/* No direct support for
								 * this case now, like
								 * that in Raid-5  */
d359 8
a366 4
				if (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)
					*createFunc = NULL;	/* No direct support for
								 * this case now, like
								 * that in Raid-5  */
d368 2
a369 1
					*createFunc = (RF_VoidFuncPtr) rf_EO_100_CreateWriteDAG;
d374 1
a374 1
	case 2:		/* two disk faults */
d376 1
a376 1
		case 2:	/* both p and q dead */
d379 6
a384 3
		case 1:	/* either p or q and dead data */
			RF_ASSERT(asmap->failedPDAs[0]->type == RF_PDA_TYPE_DATA);
			RF_ASSERT((asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));
d386 9
a394 6
				if (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)
					*createFunc = NULL;	/* In both PQ and
								 * EvenOdd, no direct
								 * support for this case
								 * now, like that in
								 * Raid-5  */
d396 2
a397 1
					*createFunc = (RF_VoidFuncPtr) rf_EO_101_CreateWriteDAG;
d399 8
a406 4
				if (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)
					*createFunc = NULL;	/* No direct support for
								 * this case, like that
								 * in Raid-5  */
d408 2
a409 1
					*createFunc = (RF_VoidFuncPtr) rf_EO_110_CreateWriteDAG;
d412 3
a414 2
		case 0:	/* double data loss */
			/* if(asmap->failedPDAs[0]->numSector +
d417 4
a420 2
			 * rf_EOCreateLargeWriteDAG; else    							 */
			*createFunc = NULL;	/* currently, in Evenodd, No
d422 2
a423 1
						 * access of both failed SUs */
d428 1
a428 1
	default:		/* more than 2 disk faults */
d436 8
a443 7
int 
rf_VerifyParityEvenOdd(raidPtr, raidAddr, parityPDA, correct_it, flags)
	RF_Raid_t *raidPtr;
	RF_RaidAddr_t raidAddr;
	RF_PhysDiskAddr_t *parityPDA;
	int     correct_it;
	RF_RaidAccessFlags_t flags;
d446 2
a447 1
	RF_RaidAddr_t startAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, raidAddr);
d449 3
a451 3
	int     numbytes = rf_RaidAddressToByte(raidPtr, numsector);
	int     bytesPerStripe = numbytes * layoutPtr->numDataCol;
	RF_DagHeader_t *rd_dag_h, *wr_dag_h;	/* read, write dag */
d457 6
a462 6
	char   *pbuf, *buf, *end_p, *p;
	char   *redundantbuf2;
	int     redundantTwoErr = 0, redundantOneErr = 0;
	int     parity_cant_correct = RF_FALSE, red2_cant_correct = RF_FALSE,
	        parity_corrected = RF_FALSE, red2_corrected = RF_FALSE;
	int     i, retcode;
d464 3
a466 2
	RF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr, raidAddr, &which_ru);
	int     stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;
d474 4
a477 3
	RF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol + layoutPtr->numParityCol), (char *), alloclist);
	RF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);	/* use calloc to make
									 * sure buffer is zeroed */
d479 2
a480 2
	RF_CallocAndAdd(redundantbuf2, 1, numbytes, (char *), alloclist);	/* use calloc to make
										 * sure buffer is zeroed */
d482 3
a484 2
	rd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf, rf_DiskReadFunc, rf_DiskReadUndoFunc,
	    "Rod", alloclist, flags, RF_IO_NORMAL_PRIORITY);
d488 3
a490 2
	/* map the stripe and fill in the PDAs in the dag */
	asm_h = rf_MapAccess(raidPtr, startAddr, layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);
d493 2
a494 1
	for (pda = asmap->physInfo, i = 0; i < layoutPtr->numDataCol; i++, pda = pda->next) {
d499 5
a503 2
			goto out;	/* no way to verify parity if disk is
					 * dead.  return w/ good status */
d506 2
a507 1
		blockNode->succedents[i]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d515 2
a516 1
	blockNode->succedents[layoutPtr->numDataCol]->params[0].p = asmap->parityInfo;
d523 7
a529 4
	/* if disk is dead, b/c no reconstruction is implemented right now,
	 * the function "rf_TryToRedirectPDA" always return one, which cause
	 * go to out and return w/ good status   */
	blockNode->succedents[layoutPtr->numDataCol + 1]->params[0].p = asmap->qInfo;
d531 1
a531 1
	/* fire off the DAG */
d547 2
a548 1
		RF_ERRORMSG("Unable to verify parity:  can't read the stripe\n");
d553 7
a559 4
		rf_e_encToBuf(raidPtr, i, p, RF_EO_MATRIX_DIM - 2, redundantbuf2, numsector);
		/* the corresponding columes in EvenOdd encoding Matrix for
		 * these p pointers which point to the databuffer in a full
		 * stripe are sequentially from 0 to layoutPtr->numDataCol-1 */
d567 4
a570 2
				RF_ERRORMSG3("Parity verify error: byte %d of parity is 0x%x should be 0x%x\n",
				    i, (u_char) buf[bytesPerStripe + i], (u_char) pbuf[i]);
d580 5
a584 2
				RF_ERRORMSG3("Parity verify error: byte %d of second redundant information is 0x%x should be 0x%x\n",
				    i, (u_char) buf[bytesPerStripe + numbytes + i], (u_char) redundantbuf2[i]);
d593 1
a593 1
	/* correct the first redundant disk, ie parity if it is error    */
d595 3
a597 2
		wr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
		    "Wnp", alloclist, flags, RF_IO_NORMAL_PRIORITY);
d602 2
a603 1
		wrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d612 2
a613 2
		rf_DispatchDAG(wr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,
		    (void *) mcpair);
d618 2
a619 1
			RF_ERRORMSG("Unable to correct parity in VerifyParity:  can't write the stripe\n");
d627 2
a628 1
		wr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, redundantbuf2, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
d634 2
a635 1
		wrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d639 2
a640 1
			printf("Dag of write new second redundant information in parity verify :\n");
d645 2
a646 2
		rf_DispatchDAG(wr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,
		    (void *) mcpair);
d651 3
a653 1
			RF_ERRORMSG("Unable to correct second redundant information in VerifyParity:  can't write the stripe\n");
d674 1
a674 1
#endif				/* RF_INCLUDE_EVENODD > 0 */
@


1.4.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d34 1
a34 1
 *****************************************************************************/
d38 1
a38 1
#if	RF_INCLUDE_EVENODD > 0
d64 9
a72 9
	RF_RowCol_t **stripeIdentifier;	/*
					 * Filled in at config time & used by
					 * IdentifyStripe.
					 */
}	RF_EvenOddConfigInfo_t;

int
rf_ConfigureEvenOdd(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d78 1
a78 2
	RF_MallocAndAdd(info, sizeof(RF_EvenOddConfigInfo_t),
	    (RF_EvenOddConfigInfo_t *), raidPtr->cleanupList);
d83 1
a83 2
	info->stripeIdentifier = rf_make_2d_array(raidPtr->numCol,
	    raidPtr->numCol, raidPtr->cleanupList);
d87 1
a87 2
			info->stripeIdentifier[i][j] = (startdisk + j) %
			    raidPtr->numCol;
d93 1
a93 1
	/* Fill in the remaining layout parameters. */
d95 2
a96 4
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
	layoutPtr->numDataCol = raidPtr->numCol - 2;	/*
							 * ORIG:
d98 2
a99 3
							 * = raidPtr->numCol-1;
							 */
#if	RF_EO_MATRIX_DIM > 17
d101 3
a103 4
		printf("Number of stripe units in a parity stripe is smaller"
		    " than 17. Please\ndefine the macro RF_EO_MATRIX_DIM in"
		    " file rf_evenodd_dagfuncs.h to\nbe 17 to increase"
		    " performance.\n");
d106 1
a106 1
#elif	RF_EO_MATRIX_DIM == 17
d108 3
a110 4
		printf("Number of stripe units in a parity stripe is bigger"
		    " than 17. Please\ndefine the macro RF_EO_MATRIX_DIM in"
		    " file rf_evenodd_dagfuncs.h to\nbe 257 for encoding and"
		    " decoding functions to work.\n");
d114 1
a114 2
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
d117 1
a117 2
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;
d119 1
a119 2
	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d124 2
a125 2
int
rf_GetDefaultNumFloatingReconBuffersEvenOdd(RF_Raid_t *raidPtr)
d130 2
a131 2
RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitEvenOdd(RF_Raid_t *raidPtr)
d136 6
a141 3
void
rf_IdentifyStripeEvenOdd(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
d143 2
a144 4
	RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout,
	    addr);
	RF_EvenOddConfigInfo_t *info =
	    (RF_EvenOddConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d149 1
d151 11
a161 17

/*
 * The layout of stripe unit on the disks are:	c0 c1 c2 c3 c4
 *
 *						 0  1  2  E  P
 *						 5  E  P  3  4
 *						 P  6  7  8  E
 *	 					10 11  E  P  9
 *						 E  P 12 13 14
 *						....
 *
 * We use the MapSectorRAID5 to map data information because the routine can
 * be shown to map exactly the layout of data stripe unit as shown above,
 * although we have 2 redundant information now.
 * But for E and P, we use rf_MapEEvenOdd and rf_MapParityEvenOdd which are
 * different method from raid-5.
 */
d164 1
a164 1
void
d166 6
a171 7
    RF_Raid_t		*raidPtr,
    RF_RaidAddr_t	 raidSector,
    RF_RowCol_t		*row,
    RF_RowCol_t		*col,
    RF_SectorNum_t	*diskSector,
    int			 remap
)
d174 1
a174 3
	RF_StripeNum_t endSUIDofthisStrip =
	    (SUID / raidPtr->Layout.numDataCol + 1) *
	    raidPtr->Layout.numDataCol - 1;
d178 1
a178 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d182 1
a182 1
void
d184 6
a189 7
    RF_Raid_t		*raidPtr,
    RF_RaidAddr_t	 raidSector,
    RF_RowCol_t		*row,
    RF_RowCol_t		*col,
    RF_SectorNum_t	*diskSector,
    int			 remap
)
d192 1
a192 3
	RF_StripeNum_t endSUIDofthisStrip =
	    (SUID / raidPtr->Layout.numDataCol + 1) *
	    raidPtr->Layout.numDataCol - 1;
d196 1
a196 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d200 1
a200 1
void
d202 4
a205 5
    RF_Raid_t		*raidPtr,
    RF_IoType_t		 type,
    RF_AccessStripeMap_t *asmap,
    RF_VoidFuncPtr	*createFunc
)
d214 1
a214 2
		RF_ERRORMSG("more than two disks failed in a single group !"
		    "  Aborting I/O operation.\n");
d218 1
a218 1
	/* Ok, we can do this I/O. */
d222 2
a223 3
			/* Fault free read. */
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateFaultFreeReadDAG;	/* Same as raid 5. */
d226 7
a232 12
			/* Lost a single data unit. */
			/*
			 * Two cases:
			 * (1) Parity is not lost. Do a normal raid 5
			 * reconstruct read.
			 * (2) Parity is lost. Do a reconstruct read using "e".
			 */
			if (ntfail == 2) {	/* Also lost redundancy. */
				if (asmap->failedPDAs[1]->type ==
				    RF_PDA_TYPE_PARITY)
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_110_CreateReadDAG;
d234 1
a234 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_101_CreateReadDAG;
d236 4
a239 8
				/*
				 * P and E are ok. But is there a failure in
				 * some unaccessed data unit ?
				 */
				if (rf_NumFailedDataUnitsInStripe(raidPtr,
				    asmap) == 2)
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_200_CreateReadDAG;
d241 1
a241 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_100_CreateReadDAG;
d251 1
a251 1
	/* A write. */
d253 1
a253 1
	case 0:		/* Fault free. */
d255 2
a256 6
		    (((asmap->numStripeUnitsAccessed <=
		       (layoutPtr->numDataCol / 2)) &&
		      (layoutPtr->numDataCol != 1)) ||
		     (asmap->parityInfo->next != NULL) ||
		     (asmap->qInfo->next != NULL) ||
		     rf_CheckStripeForFailures(raidPtr, asmap))) {
d264 1
a264 1
	case 1:		/* Single disk fault. */
d266 7
a272 16
			RF_ASSERT((asmap->failedPDAs[0]->type ==
			    RF_PDA_TYPE_PARITY) ||
			    (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));
			if (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {
				/*
				 * q died, treat like normal mode raid5
				 * write.
				 */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    (asmap->parityInfo->next != NULL) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_001_CreateSmallWriteDAG;
d274 5
a278 12
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_001_CreateLargeWriteDAG;
			} else {
				/* Parity died, small write only updating Q. */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    (asmap->qInfo->next != NULL) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_010_CreateSmallWriteDAG;
d280 1
a280 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_010_CreateLargeWriteDAG;
d282 1
a282 2
		} else {	/*
				 * Data missing. Do a P reconstruct write if
d285 2
a286 4
				 * is employing both P and E units.
				 */
			if (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)
			{
d288 1
a288 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_200_CreateWriteDAG;
d290 3
a292 5
					/*
					 * No direct support for this case now,
					 * like that in Raid-5.
					 */
					*createFunc = NULL;
d294 4
a297 8
				if (asmap->numStripeUnitsAccessed != 1 &&
				    asmap->failedPDAs[0]->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					/*
					 * No direct support for this case now,
					 * like that in Raid-5.
					 */
					*createFunc = NULL;
d299 1
a299 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_100_CreateWriteDAG;
d304 1
a304 1
	case 2:		/* Two disk faults. */
d306 1
a306 1
		case 2:	/* Both p and q dead. */
d309 3
a311 6
		case 1:	/* Either p or q and dead data. */
			RF_ASSERT(asmap->failedPDAs[0]->type ==
			    RF_PDA_TYPE_DATA);
			RF_ASSERT((asmap->failedPDAs[1]->type ==
			    RF_PDA_TYPE_PARITY) ||
			    (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));
d313 6
a318 9
				if (asmap->numStripeUnitsAccessed != 1 &&
				    asmap->failedPDAs[0]->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					/*
					 * In both PQ and EvenOdd, no direct
					 * support for this case now, like that
					 * in Raid-5.
					 */
					*createFunc = NULL;
d320 1
a320 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_101_CreateWriteDAG;
d322 4
a325 8
				if (asmap->numStripeUnitsAccessed != 1 &&
				    asmap->failedPDAs[0]->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					/*
					 * No direct support for this case,
					 * like that in Raid-5.
					 */
					*createFunc = NULL;
d327 1
a327 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_110_CreateWriteDAG;
d330 2
a331 3
		case 0:	/* Double data loss. */
			/*
			 * if(asmap->failedPDAs[0]->numSector +
d334 2
a335 4
			 * rf_EOCreateLargeWriteDAG; else
			 */
			*createFunc = NULL;	/*
						 * Currently, in Evenodd, no
d337 1
a337 2
						 * access of both failed SUs.
						 */
d342 1
a342 1
	default:	/* More than 2 disk faults. */
d350 7
a356 8
int
rf_VerifyParityEvenOdd(
	RF_Raid_t		*raidPtr,
	RF_RaidAddr_t		 raidAddr,
	RF_PhysDiskAddr_t	*parityPDA,
	int			 correct_it,
	RF_RaidAccessFlags_t	 flags
)
d359 1
a359 2
	RF_RaidAddr_t startAddr =
	    rf_RaidAddressOfPrevStripeBoundary(layoutPtr, raidAddr);
d361 3
a363 3
	int numbytes = rf_RaidAddressToByte(raidPtr, numsector);
	int bytesPerStripe = numbytes * layoutPtr->numDataCol;
	RF_DagHeader_t *rd_dag_h, *wr_dag_h;	/* Read, write dag. */
d369 6
a374 6
	char *pbuf, *buf, *end_p, *p;
	char *redundantbuf2;
	int redundantTwoErr = 0, redundantOneErr = 0;
	int parity_cant_correct = RF_FALSE, red2_cant_correct = RF_FALSE,
	    parity_corrected = RF_FALSE, red2_corrected = RF_FALSE;
	int i, retcode;
d376 2
a377 3
	RF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr,
	    raidAddr, &which_ru);
	int stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;
d385 3
a387 4
	RF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol +
	    layoutPtr->numParityCol), (char *), alloclist);
	/* Use calloc to make sure buffer is zeroed. */
	RF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);
d389 2
a390 2
	/* Use calloc to make sure buffer is zeroed. */
	RF_CallocAndAdd(redundantbuf2, 1, numbytes, (char *), alloclist);
d392 2
a393 3
	rd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf,
	    rf_DiskReadFunc, rf_DiskReadUndoFunc, "Rod", alloclist, flags,
	    RF_IO_NORMAL_PRIORITY);
d397 2
a398 3
	/* Map the stripe and fill in the PDAs in the dag. */
	asm_h = rf_MapAccess(raidPtr, startAddr,
	    layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);
d401 1
a401 2
	for (pda = asmap->physInfo, i = 0; i < layoutPtr->numDataCol;
	     i++, pda = pda->next) {
d406 2
a407 5
			/*
			 * No way to verify parity if disk is dead.
			 * Return w/ good status.
			 */
			goto out;
d410 1
a410 2
		blockNode->succedents[i]->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d418 1
a418 2
	blockNode->succedents[layoutPtr->numDataCol]->params[0].p =
	    asmap->parityInfo;
d425 4
a428 7
	/*
	 * If disk is dead, b/c no reconstruction is implemented right now,
	 * the function "rf_TryToRedirectPDA" always return one, which causes
	 * go to out and return w/ good status.
	 */
	blockNode->succedents[layoutPtr->numDataCol + 1]->params[0].p =
	    asmap->qInfo;
d430 1
a430 1
	/* Fire off the DAG. */
d446 1
a446 2
		RF_ERRORMSG("Unable to verify parity:  can't read"
		    " the stripe\n");
d451 4
a454 7
		rf_e_encToBuf(raidPtr, i, p, RF_EO_MATRIX_DIM - 2,
		    redundantbuf2, numsector);
		/*
		 * The corresponding columns in EvenOdd encoding Matrix for
		 * these p pointers that point to the databuffer in a full
		 * stripe are sequential from 0 to layoutPtr->numDataCol-1.
		 */
d462 2
a463 4
				RF_ERRORMSG3("Parity verify error: byte %d of"
				    " parity is 0x%x should be 0x%x\n", i,
				    (u_char) buf[bytesPerStripe + i],
				    (u_char) pbuf[i]);
d473 2
a474 5
				RF_ERRORMSG3("Parity verify error: byte %d of"
				    " second redundant information is 0x%x"
				    " should be 0x%x\n", i,
				    (u_char) buf[bytesPerStripe + numbytes + i],
				    (u_char) redundantbuf2[i]);
d483 1
a483 1
	/* Correct the first redundant disk, ie parity if it is error. */
d485 2
a486 3
		wr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf,
		    rf_DiskWriteFunc, rf_DiskWriteUndoFunc, "Wnp", alloclist,
		    flags, RF_IO_NORMAL_PRIORITY);
d491 1
a491 2
		wrBlock->succedents[0]->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d500 2
a501 2
		rf_DispatchDAG(wr_dag_h,
		    (void (*) (void *)) rf_MCPairWakeupFunc, (void *) mcpair);
d506 1
a506 2
			RF_ERRORMSG("Unable to correct parity in VerifyParity:"
			    " can't write the stripe\n");
d514 1
a514 2
		wr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes,
		    redundantbuf2, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
d520 1
a520 2
		wrBlock->succedents[0]->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d524 1
a524 2
			printf("Dag of write new second redundant information"
			    " in parity verify :\n");
d529 2
a530 2
		rf_DispatchDAG(wr_dag_h,
		    (void (*) (void *)) rf_MCPairWakeupFunc, (void *) mcpair);
d535 1
a535 3
			RF_ERRORMSG("Unable to correct second redundant"
			    " information in VerifyParity: can't write the"
			    " stripe\n");
d556 1
a556 1
#endif	/* RF_INCLUDE_EVENODD > 0 */
@


1.4.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d34 1
a34 1
 *****************************************************************************/
d38 1
a38 1
#if	RF_INCLUDE_EVENODD > 0
d64 9
a72 9
	RF_RowCol_t **stripeIdentifier;	/*
					 * Filled in at config time & used by
					 * IdentifyStripe.
					 */
}	RF_EvenOddConfigInfo_t;

int
rf_ConfigureEvenOdd(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d78 1
a78 2
	RF_MallocAndAdd(info, sizeof(RF_EvenOddConfigInfo_t),
	    (RF_EvenOddConfigInfo_t *), raidPtr->cleanupList);
d83 1
a83 2
	info->stripeIdentifier = rf_make_2d_array(raidPtr->numCol,
	    raidPtr->numCol, raidPtr->cleanupList);
d87 1
a87 2
			info->stripeIdentifier[i][j] = (startdisk + j) %
			    raidPtr->numCol;
d93 1
a93 1
	/* Fill in the remaining layout parameters. */
d95 2
a96 4
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
	layoutPtr->numDataCol = raidPtr->numCol - 2;	/*
							 * ORIG:
d98 2
a99 3
							 * = raidPtr->numCol-1;
							 */
#if	RF_EO_MATRIX_DIM > 17
d101 3
a103 4
		printf("Number of stripe units in a parity stripe is smaller"
		    " than 17. Please\ndefine the macro RF_EO_MATRIX_DIM in"
		    " file rf_evenodd_dagfuncs.h to\nbe 17 to increase"
		    " performance.\n");
d106 1
a106 1
#elif	RF_EO_MATRIX_DIM == 17
d108 3
a110 4
		printf("Number of stripe units in a parity stripe is bigger"
		    " than 17. Please\ndefine the macro RF_EO_MATRIX_DIM in"
		    " file rf_evenodd_dagfuncs.h to\nbe 257 for encoding and"
		    " decoding functions to work.\n");
d114 1
a114 2
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
d117 1
a117 2
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;
d119 1
a119 2
	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d124 2
a125 2
int
rf_GetDefaultNumFloatingReconBuffersEvenOdd(RF_Raid_t *raidPtr)
d130 2
a131 2
RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitEvenOdd(RF_Raid_t *raidPtr)
d136 6
a141 3
void
rf_IdentifyStripeEvenOdd(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
d143 2
a144 4
	RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout,
	    addr);
	RF_EvenOddConfigInfo_t *info =
	    (RF_EvenOddConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d149 1
d151 11
a161 17

/*
 * The layout of stripe unit on the disks are:	c0 c1 c2 c3 c4
 *
 *						 0  1  2  E  P
 *						 5  E  P  3  4
 *						 P  6  7  8  E
 *	 					10 11  E  P  9
 *						 E  P 12 13 14
 *						....
 *
 * We use the MapSectorRAID5 to map data information because the routine can
 * be shown to map exactly the layout of data stripe unit as shown above,
 * although we have 2 redundant information now.
 * But for E and P, we use rf_MapEEvenOdd and rf_MapParityEvenOdd which are
 * different method from raid-5.
 */
d164 1
a164 1
void
d166 6
a171 7
    RF_Raid_t		*raidPtr,
    RF_RaidAddr_t	 raidSector,
    RF_RowCol_t		*row,
    RF_RowCol_t		*col,
    RF_SectorNum_t	*diskSector,
    int			 remap
)
d174 1
a174 3
	RF_StripeNum_t endSUIDofthisStrip =
	    (SUID / raidPtr->Layout.numDataCol + 1) *
	    raidPtr->Layout.numDataCol - 1;
d178 1
a178 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d182 1
a182 1
void
d184 6
a189 7
    RF_Raid_t		*raidPtr,
    RF_RaidAddr_t	 raidSector,
    RF_RowCol_t		*row,
    RF_RowCol_t		*col,
    RF_SectorNum_t	*diskSector,
    int			 remap
)
d192 1
a192 3
	RF_StripeNum_t endSUIDofthisStrip =
	    (SUID / raidPtr->Layout.numDataCol + 1) *
	    raidPtr->Layout.numDataCol - 1;
d196 1
a196 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d200 1
a200 1
void
d202 4
a205 5
    RF_Raid_t		*raidPtr,
    RF_IoType_t		 type,
    RF_AccessStripeMap_t *asmap,
    RF_VoidFuncPtr	*createFunc
)
d214 1
a214 2
		RF_ERRORMSG("more than two disks failed in a single group !"
		    "  Aborting I/O operation.\n");
d218 1
a218 1
	/* Ok, we can do this I/O. */
d222 2
a223 3
			/* Fault free read. */
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateFaultFreeReadDAG;	/* Same as raid 5. */
d226 7
a232 12
			/* Lost a single data unit. */
			/*
			 * Two cases:
			 * (1) Parity is not lost. Do a normal raid 5
			 * reconstruct read.
			 * (2) Parity is lost. Do a reconstruct read using "e".
			 */
			if (ntfail == 2) {	/* Also lost redundancy. */
				if (asmap->failedPDAs[1]->type ==
				    RF_PDA_TYPE_PARITY)
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_110_CreateReadDAG;
d234 1
a234 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_101_CreateReadDAG;
d236 4
a239 8
				/*
				 * P and E are ok. But is there a failure in
				 * some unaccessed data unit ?
				 */
				if (rf_NumFailedDataUnitsInStripe(raidPtr,
				    asmap) == 2)
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_200_CreateReadDAG;
d241 1
a241 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_100_CreateReadDAG;
d251 1
a251 1
	/* A write. */
d253 1
a253 1
	case 0:		/* Fault free. */
d255 2
a256 6
		    (((asmap->numStripeUnitsAccessed <=
		       (layoutPtr->numDataCol / 2)) &&
		      (layoutPtr->numDataCol != 1)) ||
		     (asmap->parityInfo->next != NULL) ||
		     (asmap->qInfo->next != NULL) ||
		     rf_CheckStripeForFailures(raidPtr, asmap))) {
d264 1
a264 1
	case 1:		/* Single disk fault. */
d266 7
a272 16
			RF_ASSERT((asmap->failedPDAs[0]->type ==
			    RF_PDA_TYPE_PARITY) ||
			    (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));
			if (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {
				/*
				 * q died, treat like normal mode raid5
				 * write.
				 */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    (asmap->parityInfo->next != NULL) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_001_CreateSmallWriteDAG;
d274 5
a278 12
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_001_CreateLargeWriteDAG;
			} else {
				/* Parity died, small write only updating Q. */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    (asmap->qInfo->next != NULL) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_010_CreateSmallWriteDAG;
d280 1
a280 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_010_CreateLargeWriteDAG;
d282 1
a282 2
		} else {	/*
				 * Data missing. Do a P reconstruct write if
d285 2
a286 4
				 * is employing both P and E units.
				 */
			if (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)
			{
d288 1
a288 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_200_CreateWriteDAG;
d290 3
a292 5
					/*
					 * No direct support for this case now,
					 * like that in Raid-5.
					 */
					*createFunc = NULL;
d294 4
a297 8
				if (asmap->numStripeUnitsAccessed != 1 &&
				    asmap->failedPDAs[0]->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					/*
					 * No direct support for this case now,
					 * like that in Raid-5.
					 */
					*createFunc = NULL;
d299 1
a299 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_100_CreateWriteDAG;
d304 1
a304 1
	case 2:		/* Two disk faults. */
d306 1
a306 1
		case 2:	/* Both p and q dead. */
d309 3
a311 6
		case 1:	/* Either p or q and dead data. */
			RF_ASSERT(asmap->failedPDAs[0]->type ==
			    RF_PDA_TYPE_DATA);
			RF_ASSERT((asmap->failedPDAs[1]->type ==
			    RF_PDA_TYPE_PARITY) ||
			    (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));
d313 6
a318 9
				if (asmap->numStripeUnitsAccessed != 1 &&
				    asmap->failedPDAs[0]->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					/*
					 * In both PQ and EvenOdd, no direct
					 * support for this case now, like that
					 * in Raid-5.
					 */
					*createFunc = NULL;
d320 1
a320 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_101_CreateWriteDAG;
d322 4
a325 8
				if (asmap->numStripeUnitsAccessed != 1 &&
				    asmap->failedPDAs[0]->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					/*
					 * No direct support for this case,
					 * like that in Raid-5.
					 */
					*createFunc = NULL;
d327 1
a327 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_EO_110_CreateWriteDAG;
d330 2
a331 3
		case 0:	/* Double data loss. */
			/*
			 * if(asmap->failedPDAs[0]->numSector +
d334 2
a335 4
			 * rf_EOCreateLargeWriteDAG; else
			 */
			*createFunc = NULL;	/*
						 * Currently, in Evenodd, no
d337 1
a337 2
						 * access of both failed SUs.
						 */
d342 1
a342 1
	default:	/* More than 2 disk faults. */
d350 7
a356 8
int
rf_VerifyParityEvenOdd(
	RF_Raid_t		*raidPtr,
	RF_RaidAddr_t		 raidAddr,
	RF_PhysDiskAddr_t	*parityPDA,
	int			 correct_it,
	RF_RaidAccessFlags_t	 flags
)
d359 1
a359 2
	RF_RaidAddr_t startAddr =
	    rf_RaidAddressOfPrevStripeBoundary(layoutPtr, raidAddr);
d361 3
a363 3
	int numbytes = rf_RaidAddressToByte(raidPtr, numsector);
	int bytesPerStripe = numbytes * layoutPtr->numDataCol;
	RF_DagHeader_t *rd_dag_h, *wr_dag_h;	/* Read, write dag. */
d369 6
a374 6
	char *pbuf, *buf, *end_p, *p;
	char *redundantbuf2;
	int redundantTwoErr = 0, redundantOneErr = 0;
	int parity_cant_correct = RF_FALSE, red2_cant_correct = RF_FALSE,
	    parity_corrected = RF_FALSE, red2_corrected = RF_FALSE;
	int i, retcode;
d376 2
a377 3
	RF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr,
	    raidAddr, &which_ru);
	int stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;
d385 3
a387 4
	RF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol +
	    layoutPtr->numParityCol), (char *), alloclist);
	/* Use calloc to make sure buffer is zeroed. */
	RF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);
d389 2
a390 2
	/* Use calloc to make sure buffer is zeroed. */
	RF_CallocAndAdd(redundantbuf2, 1, numbytes, (char *), alloclist);
d392 2
a393 3
	rd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf,
	    rf_DiskReadFunc, rf_DiskReadUndoFunc, "Rod", alloclist, flags,
	    RF_IO_NORMAL_PRIORITY);
d397 2
a398 3
	/* Map the stripe and fill in the PDAs in the dag. */
	asm_h = rf_MapAccess(raidPtr, startAddr,
	    layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);
d401 1
a401 2
	for (pda = asmap->physInfo, i = 0; i < layoutPtr->numDataCol;
	     i++, pda = pda->next) {
d406 2
a407 5
			/*
			 * No way to verify parity if disk is dead.
			 * Return w/ good status.
			 */
			goto out;
d410 1
a410 2
		blockNode->succedents[i]->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d418 1
a418 2
	blockNode->succedents[layoutPtr->numDataCol]->params[0].p =
	    asmap->parityInfo;
d425 4
a428 7
	/*
	 * If disk is dead, b/c no reconstruction is implemented right now,
	 * the function "rf_TryToRedirectPDA" always return one, which causes
	 * go to out and return w/ good status.
	 */
	blockNode->succedents[layoutPtr->numDataCol + 1]->params[0].p =
	    asmap->qInfo;
d430 1
a430 1
	/* Fire off the DAG. */
d446 1
a446 2
		RF_ERRORMSG("Unable to verify parity:  can't read"
		    " the stripe\n");
d451 4
a454 7
		rf_e_encToBuf(raidPtr, i, p, RF_EO_MATRIX_DIM - 2,
		    redundantbuf2, numsector);
		/*
		 * The corresponding columns in EvenOdd encoding Matrix for
		 * these p pointers that point to the databuffer in a full
		 * stripe are sequential from 0 to layoutPtr->numDataCol-1.
		 */
d462 2
a463 4
				RF_ERRORMSG3("Parity verify error: byte %d of"
				    " parity is 0x%x should be 0x%x\n", i,
				    (u_char) buf[bytesPerStripe + i],
				    (u_char) pbuf[i]);
d473 2
a474 5
				RF_ERRORMSG3("Parity verify error: byte %d of"
				    " second redundant information is 0x%x"
				    " should be 0x%x\n", i,
				    (u_char) buf[bytesPerStripe + numbytes + i],
				    (u_char) redundantbuf2[i]);
d483 1
a483 1
	/* Correct the first redundant disk, ie parity if it is error. */
d485 2
a486 3
		wr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf,
		    rf_DiskWriteFunc, rf_DiskWriteUndoFunc, "Wnp", alloclist,
		    flags, RF_IO_NORMAL_PRIORITY);
d491 1
a491 2
		wrBlock->succedents[0]->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d500 2
a501 2
		rf_DispatchDAG(wr_dag_h,
		    (void (*) (void *)) rf_MCPairWakeupFunc, (void *) mcpair);
d506 1
a506 2
			RF_ERRORMSG("Unable to correct parity in VerifyParity:"
			    " can't write the stripe\n");
d514 1
a514 2
		wr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes,
		    redundantbuf2, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
d520 1
a520 2
		wrBlock->succedents[0]->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d524 1
a524 2
			printf("Dag of write new second redundant information"
			    " in parity verify :\n");
d529 2
a530 2
		rf_DispatchDAG(wr_dag_h,
		    (void (*) (void *)) rf_MCPairWakeupFunc, (void *) mcpair);
d535 1
a535 3
			RF_ERRORMSG("Unable to correct second redundant"
			    " information in VerifyParity: can't write the"
			    " stripe\n");
d556 1
a556 1
#endif	/* RF_INCLUDE_EVENODD > 0 */
@


1.3
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_evenodd.c,v 1.2 1999/02/16 00:02:44 niklas Exp $	*/
/*	$NetBSD: rf_evenodd.c,v 1.3 1999/08/13 03:41:56 oster Exp $	*/
a48 1
#include "rf_threadid.h"
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_evenodd.c,v 1.1 1999/01/11 14:29:21 niklas Exp $	*/
/*	$NetBSD: rf_evenodd.c,v 1.2 1999/02/05 00:06:11 oster Exp $	*/
a58 1
#include "rf_sys.h"
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_evenodd.c,v 1.1 1998/11/13 04:20:29 oster Exp $	*/
/*	$NetBSD: rf_evenodd.c,v 1.1 1998/11/13 04:20:29 oster Exp $	*/
d66 28
a93 2
  RF_RowCol_t **stripeIdentifier;                    /* filled in at config time & used by IdentifyStripe */
} RF_EvenOddConfigInfo_t;
d95 6
a100 27
int rf_ConfigureEvenOdd(listp, raidPtr, cfgPtr)
  RF_ShutdownList_t  **listp;
  RF_Raid_t           *raidPtr;
  RF_Config_t         *cfgPtr;
{
  RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
  RF_EvenOddConfigInfo_t *info;
  RF_RowCol_t i, j, startdisk;
  
  RF_MallocAndAdd(info, sizeof(RF_EvenOddConfigInfo_t), (RF_EvenOddConfigInfo_t *), raidPtr->cleanupList);
  layoutPtr->layoutSpecificInfo = (void *) info;

  RF_ASSERT(raidPtr->numRow == 1);

  info->stripeIdentifier = rf_make_2d_array(raidPtr->numCol, raidPtr->numCol, raidPtr->cleanupList);
  startdisk = 0;
  for (i=0; i<raidPtr->numCol; i++) {
    for (j=0; j<raidPtr->numCol; j++) {
      info->stripeIdentifier[i][j] = (startdisk + j) % raidPtr->numCol;
    }
    if ((startdisk -= 2) < 0) startdisk += raidPtr->numCol; 
  }

  /* fill in the remaining layout parameters */
  layoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;
  layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;
  layoutPtr->numDataCol = raidPtr->numCol-2; /*  ORIG: layoutPtr->numDataCol = raidPtr->numCol-1;  */
d102 6
a107 6
  if (raidPtr->numCol <= 17){
      printf("Number of stripe units in a parity stripe is smaller than 17. Please\n");
      printf("define the macro RF_EO_MATRIX_DIM in file rf_evenodd_dagfuncs.h to \n");
      printf("be 17 to increase performance. \n");
      return(EINVAL); 
  }
d109 6
a114 6
  if (raidPtr->numCol > 17) {
      printf("Number of stripe units in a parity stripe is bigger than 17. Please\n");
      printf("define the macro RF_EO_MATRIX_DIM in file rf_evenodd_dagfuncs.h to \n");
      printf("be 257 for encoding and decoding functions to work. \n");
      return(EINVAL);
  }
d116 4
a119 4
  layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
  layoutPtr->numParityCol = 2;
  layoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;
  raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;
d121 1
a121 1
  raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d123 1
a123 1
  return(0);
d126 2
a127 1
int rf_GetDefaultNumFloatingReconBuffersEvenOdd(RF_Raid_t *raidPtr)
d129 1
a129 1
  return(20);
d132 2
a133 1
RF_HeadSepLimit_t rf_GetDefaultHeadSepLimitEvenOdd(RF_Raid_t *raidPtr)
d135 1
a135 1
  return(10);
d138 6
a143 5
void rf_IdentifyStripeEvenOdd(
  RF_Raid_t        *raidPtr,
  RF_RaidAddr_t     addr,
  RF_RowCol_t     **diskids,
  RF_RowCol_t      *outRow)
d145 2
a146 2
  RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, addr);
  RF_EvenOddConfigInfo_t *info = (RF_EvenOddConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d148 2
a149 2
  *outRow = 0;
  *diskids = info->stripeIdentifier[ stripeID % raidPtr->numCol ];
d151 1
a151 2

/* The layout of stripe unit on the disks are:      c0 c1 c2 c3 c4  
d160 1
a160 1
  We use the MapSectorRAID5 to map data information because the routine can be shown to map exactly 
d166 8
a173 7
void rf_MapParityEvenOdd(
	RF_Raid_t 	*raidPtr, 
	RF_RaidAddr_t 	 raidSector, 
	RF_RowCol_t 	*row,   
	RF_RowCol_t 	*col, 
	RF_SectorNum_t  *diskSector,  
	int  	  	 remap)
d175 2
a176 2
  RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
  RF_StripeNum_t endSUIDofthisStrip = (SUID/raidPtr->Layout.numDataCol + 1)*raidPtr->Layout.numDataCol - 1;
d178 4
a181 4
  *row = 0;        
  *col = ( endSUIDofthisStrip + 2)%raidPtr->numCol;
  *diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d184 8
a191 7
void rf_MapEEvenOdd(
  RF_Raid_t       *raidPtr,
  RF_RaidAddr_t    raidSector,
  RF_RowCol_t     *row,
  RF_RowCol_t     *col,
  RF_SectorNum_t  *diskSector,
  int              remap)
d193 2
a194 2
  RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
  RF_StripeNum_t endSUIDofthisStrip = (SUID/raidPtr->Layout.numDataCol + 1)*raidPtr->Layout.numDataCol - 1;
d196 4
a199 4
  *row = 0;        
  *col = ( endSUIDofthisStrip + 1)%raidPtr->numCol;
  *diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d202 6
a207 5
void rf_EODagSelect(
  RF_Raid_t             *raidPtr,
  RF_IoType_t            type,
  RF_AccessStripeMap_t  *asmap,
  RF_VoidFuncPtr *createFunc)
d209 140
a348 151
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  unsigned ndfail = asmap->numDataFailed;
  unsigned npfail = asmap->numParityFailed +asmap->numQFailed;
  unsigned ntfail = npfail + ndfail;

  RF_ASSERT(RF_IO_IS_R_OR_W(type));
  if (ntfail > 2) 
    {
      RF_ERRORMSG("more than two disks failed in a single group!  Aborting I/O operation.\n");
      /* *infoFunc = */ *createFunc = NULL;
      return;
    }

  /* ok, we can do this I/O */
  if (type == RF_IO_TYPE_READ)
    {
      switch (ndfail)
	{
	case 0:
	  /* fault free read */
	  *createFunc = (RF_VoidFuncPtr)rf_CreateFaultFreeReadDAG;   /* same as raid 5 */
	  break;
	case 1:
	  /* lost a single data unit */
	  /* two cases:
	        (1) parity is not lost.
		    do a normal raid 5 reconstruct read.
		(2) parity is lost.
		    do a reconstruct read using "e".
          */
	  if (ntfail == 2) /* also lost redundancy */
	    {
	      if (asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) 
		*createFunc = (RF_VoidFuncPtr)rf_EO_110_CreateReadDAG; 
	      else
		*createFunc = (RF_VoidFuncPtr)rf_EO_101_CreateReadDAG; 
	    }
	  else
	    {
	      /* P and E are ok. But is there a failure
		 in some unaccessed data unit?
              */
	      if (rf_NumFailedDataUnitsInStripe(raidPtr,asmap)==2)
		*createFunc = (RF_VoidFuncPtr)rf_EO_200_CreateReadDAG; 
	      else
		  *createFunc = (RF_VoidFuncPtr)rf_EO_100_CreateReadDAG; 
	    }
	  break;
	case 2:
	  /* *createFunc = rf_EO_200_CreateReadDAG; */
	  *createFunc = NULL;
	  break;
	}
      return;
    }

  /* a write */
  switch (ntfail)
    {
    case 0: /* fault free */
      if (rf_suppressLocksAndLargeWrites ||
	  (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||
	   (asmap->parityInfo->next != NULL) || (asmap->qInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {
	
	*createFunc = (RF_VoidFuncPtr)rf_EOCreateSmallWriteDAG;
      }
      else {
	*createFunc = (RF_VoidFuncPtr)rf_EOCreateLargeWriteDAG;
      }
      break;

    case 1: /* single disk fault */
      if (npfail==1) 
	{
	  RF_ASSERT ((asmap->failedPDAs[0]->type == RF_PDA_TYPE_PARITY) ||  (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));
	  if (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q)
	    { /* q died, treat like normal mode raid5 write.*/
	      if (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))
		  || (asmap->parityInfo->next!=NULL) || rf_NumFailedDataUnitsInStripe(raidPtr,asmap))
		*createFunc = (RF_VoidFuncPtr)rf_EO_001_CreateSmallWriteDAG;
	      else
		*createFunc = (RF_VoidFuncPtr)rf_EO_001_CreateLargeWriteDAG;
	    }
	  else
	    { /* parity died, small write only updating Q */
	      if (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))
		  || (asmap->qInfo->next!=NULL) || rf_NumFailedDataUnitsInStripe(raidPtr,asmap))
		*createFunc = (RF_VoidFuncPtr)rf_EO_010_CreateSmallWriteDAG;
	      else
		*createFunc = (RF_VoidFuncPtr)rf_EO_010_CreateLargeWriteDAG;
	    }
	}
      else
	{ /* data missing. 
	     Do a P reconstruct write if only a single data unit
	     is lost in the stripe, otherwise a reconstruct
	     write which employnig both P and E units. */
	  if (rf_NumFailedDataUnitsInStripe(raidPtr,asmap)==2)
	  {  
            if (asmap->numStripeUnitsAccessed == 1)
              *createFunc = (RF_VoidFuncPtr)rf_EO_200_CreateWriteDAG;
            else
              *createFunc = NULL;  /* No direct support for this case now, like that in Raid-5  */
          }
	  else
          {
            if (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)
                   *createFunc = NULL; /* No direct support for this case now, like that in Raid-5  */
            else   *createFunc = (RF_VoidFuncPtr)rf_EO_100_CreateWriteDAG;
          }
	}
      break;

    case 2: /* two disk faults */
      switch (npfail)
	{
	case 2: /* both p and q dead */
	  *createFunc = (RF_VoidFuncPtr)rf_EO_011_CreateWriteDAG;
	  break;
	case 1: /* either p or q and dead data */
	  RF_ASSERT(asmap->failedPDAs[0]->type == RF_PDA_TYPE_DATA);
	  RF_ASSERT ((asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) ||  (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));
	  if (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q)
          {
	    if(asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)
                *createFunc = NULL; /* In both PQ and EvenOdd, no direct support for this case now, like that in Raid-5  */
	    else
	        *createFunc = (RF_VoidFuncPtr)rf_EO_101_CreateWriteDAG;
          }
	  else
          {
            if (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)
                *createFunc = NULL; /* No direct support for this case, like that in Raid-5  */
            else
	        *createFunc = (RF_VoidFuncPtr)rf_EO_110_CreateWriteDAG;
	  }
	  break;
	case 0: /* double data loss */
        /*  if(asmap->failedPDAs[0]->numSector + asmap->failedPDAs[1]->numSector == 2 * layoutPtr->sectorsPerStripeUnit )
                *createFunc = rf_EOCreateLargeWriteDAG;
            else    							*/
	        *createFunc = NULL; /* currently, in Evenodd, No support for simultaneous access of both failed SUs */
	  break;
	}
      break;

    default:  /* more than 2 disk faults */
      *createFunc = NULL;
      RF_PANIC();
    }
  return;
d352 7
a358 6
int rf_VerifyParityEvenOdd(raidPtr, raidAddr, parityPDA, correct_it, flags)
  RF_Raid_t             *raidPtr;
  RF_RaidAddr_t          raidAddr;
  RF_PhysDiskAddr_t     *parityPDA;
  int                    correct_it;
  RF_RaidAccessFlags_t   flags;
d360 189
a548 186
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  RF_RaidAddr_t startAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, raidAddr);
  RF_SectorCount_t numsector = parityPDA->numSector;
  int numbytes  = rf_RaidAddressToByte(raidPtr, numsector);
  int bytesPerStripe = numbytes * layoutPtr->numDataCol;
  RF_DagHeader_t *rd_dag_h, *wr_dag_h;          /* read, write dag */
  RF_DagNode_t *blockNode, *unblockNode, *wrBlock, *wrUnblock;
  RF_AccessStripeMapHeader_t *asm_h;
  RF_AccessStripeMap_t *asmap;
  RF_AllocListElem_t *alloclist;
  RF_PhysDiskAddr_t *pda;
  char *pbuf, *buf, *end_p, *p;
  char *redundantbuf2;
  int redundantTwoErr = 0,  redundantOneErr = 0; 
  int parity_cant_correct = RF_FALSE, red2_cant_correct = RF_FALSE, parity_corrected = RF_FALSE, red2_corrected = RF_FALSE;
  int i, retcode;
  RF_ReconUnitNum_t which_ru;
  RF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr, raidAddr, &which_ru);
  int stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;
  RF_AccTraceEntry_t tracerec;
  RF_MCPair_t *mcpair;

  retcode = RF_PARITY_OKAY;

  mcpair = rf_AllocMCPair();
  rf_MakeAllocList(alloclist);
  RF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol + layoutPtr->numParityCol), (char *), alloclist);
  RF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);     /* use calloc to make sure buffer is zeroed */
  end_p = buf + bytesPerStripe;
  RF_CallocAndAdd(redundantbuf2, 1, numbytes, (char *), alloclist);  /* use calloc to make sure buffer is zeroed */

  rd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf, rf_DiskReadFunc, rf_DiskReadUndoFunc,
			   "Rod", alloclist, flags, RF_IO_NORMAL_PRIORITY);
  blockNode = rd_dag_h->succedents[0];
  unblockNode = blockNode->succedents[0]->succedents[0];

  /* map the stripe and fill in the PDAs in the dag */
  asm_h = rf_MapAccess(raidPtr, startAddr, layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);
  asmap = asm_h->stripeMap;
  
  for (pda=asmap->physInfo,i=0; i<layoutPtr->numDataCol; i++,pda=pda->next) {
    RF_ASSERT(pda);
    rf_RangeRestrictPDA(raidPtr, parityPDA, pda, 0, 1);
    RF_ASSERT(pda->numSector != 0);
    if (rf_TryToRedirectPDA(raidPtr, pda, 0)) goto out;   /* no way to verify parity if disk is dead.  return w/ good status */
    blockNode->succedents[i]->params[0].p = pda;
    blockNode->succedents[i]->params[2].v = psID;
    blockNode->succedents[i]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
  }

  RF_ASSERT(!asmap->parityInfo->next);
  rf_RangeRestrictPDA(raidPtr, parityPDA, asmap->parityInfo, 0, 1);
  RF_ASSERT(asmap->parityInfo->numSector != 0);
  if (rf_TryToRedirectPDA(raidPtr, asmap->parityInfo, 1))
    goto out;
  blockNode->succedents[ layoutPtr->numDataCol ]->params[0].p = asmap->parityInfo;

  RF_ASSERT(!asmap->qInfo->next);
  rf_RangeRestrictPDA(raidPtr, parityPDA, asmap->qInfo, 0, 1);
  RF_ASSERT(asmap->qInfo->numSector != 0);
  if (rf_TryToRedirectPDA(raidPtr, asmap->qInfo, 1)) goto out; 
  /* 
   * if disk is dead, b/c no reconstruction is implemented right now,
   * the function "rf_TryToRedirectPDA" always return one, which cause
   * go to out and return w/ good status   
   */
  blockNode->succedents[ layoutPtr->numDataCol +1  ]->params[0].p = asmap->qInfo;

  /* fire off the DAG */
  bzero((char *)&tracerec,sizeof(tracerec));
  rd_dag_h->tracerec = &tracerec;

  if (rf_verifyParityDebug) {
    printf("Parity verify read dag:\n");
    rf_PrintDAGList(rd_dag_h);
  }

  RF_LOCK_MUTEX(mcpair->mutex);
  mcpair->flag = 0;
  rf_DispatchDAG(rd_dag_h, (void (*)(void *))rf_MCPairWakeupFunc, 
		 (void *) mcpair);
  while (!mcpair->flag) RF_WAIT_COND(mcpair->cond, mcpair->mutex);
  RF_UNLOCK_MUTEX(mcpair->mutex);
  if (rd_dag_h->status != rf_enable) {
    RF_ERRORMSG("Unable to verify parity:  can't read the stripe\n");
    retcode = RF_PARITY_COULD_NOT_VERIFY;
    goto out;
  }

  for (p=buf, i=0; p<end_p; p+=numbytes, i++) {
    rf_e_encToBuf(raidPtr, i, p, RF_EO_MATRIX_DIM - 2, redundantbuf2, numsector);
    /* 
     * the corresponding columes in EvenOdd encoding Matrix for these p pointers which point 
     * to the databuffer in a full stripe are sequentially from 0 to layoutPtr->numDataCol-1 
     */
    rf_bxor(p, pbuf, numbytes, NULL);
  }
  RF_ASSERT(i==layoutPtr->numDataCol);

  for (i=0; i<numbytes; i++) {
    if (pbuf[i] != buf[bytesPerStripe+i]) {
      if (!correct_it) {
        RF_ERRORMSG3("Parity verify error: byte %d of parity is 0x%x should be 0x%x\n",
            i,(u_char) buf[bytesPerStripe+i],(u_char) pbuf[i]);
      }
    }
    redundantOneErr = 1;
    break;
  }

  for (i=0; i<numbytes; i++) {
    if (redundantbuf2[i] != buf[bytesPerStripe+numbytes+i]) {
      if (!correct_it) {
        RF_ERRORMSG3("Parity verify error: byte %d of second redundant information is 0x%x should be 0x%x\n",
            i,(u_char) buf[bytesPerStripe+numbytes+i],(u_char) redundantbuf2[i]);
      }
      redundantTwoErr = 1;
      break;
    }
  }
  if (redundantOneErr || redundantTwoErr )
    retcode = RF_PARITY_BAD;

  /*  correct the first redundant disk, ie parity if it is error    */
  if (redundantOneErr && correct_it) {    
    wr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
			     "Wnp", alloclist, flags, RF_IO_NORMAL_PRIORITY);
    wrBlock = wr_dag_h->succedents[0]; wrUnblock = wrBlock->succedents[0]->succedents[0];
    wrBlock->succedents[0]->params[0].p = asmap->parityInfo;
    wrBlock->succedents[0]->params[2].v = psID;
    wrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
    bzero((char *)&tracerec,sizeof(tracerec));
    wr_dag_h->tracerec = &tracerec;
    if (rf_verifyParityDebug) {
      printf("Parity verify write dag:\n");
      rf_PrintDAGList(wr_dag_h);
    }
    RF_LOCK_MUTEX(mcpair->mutex);
    mcpair->flag = 0;
    rf_DispatchDAG(wr_dag_h, (void (*)(void *))rf_MCPairWakeupFunc, 
		   (void *) mcpair);
    while (!mcpair->flag)
      RF_WAIT_COND(mcpair->cond, mcpair->mutex);
    RF_UNLOCK_MUTEX(mcpair->mutex);
    if (wr_dag_h->status != rf_enable) {
      RF_ERRORMSG("Unable to correct parity in VerifyParity:  can't write the stripe\n");
      parity_cant_correct = RF_TRUE;
    } else {
      parity_corrected = RF_TRUE;
    }
    rf_FreeDAG(wr_dag_h);
  }

  if (redundantTwoErr && correct_it) {
    wr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, redundantbuf2, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
                             "Wnred2", alloclist, flags, RF_IO_NORMAL_PRIORITY);
    wrBlock = wr_dag_h->succedents[0]; wrUnblock = wrBlock->succedents[0]->succedents[0];
    wrBlock->succedents[0]->params[0].p = asmap->qInfo;
    wrBlock->succedents[0]->params[2].v = psID;
    wrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
    bzero((char *)&tracerec,sizeof(tracerec));
    wr_dag_h->tracerec = &tracerec;
    if (rf_verifyParityDebug) {
      printf("Dag of write new second redundant information in parity verify :\n");
      rf_PrintDAGList(wr_dag_h);
    }
    RF_LOCK_MUTEX(mcpair->mutex);
    mcpair->flag = 0;
    rf_DispatchDAG(wr_dag_h, (void (*)(void *))rf_MCPairWakeupFunc, 
		   (void *) mcpair);
    while (!mcpair->flag)
      RF_WAIT_COND(mcpair->cond, mcpair->mutex);
    RF_UNLOCK_MUTEX(mcpair->mutex);
    if (wr_dag_h->status != rf_enable) {
      RF_ERRORMSG("Unable to correct second redundant information in VerifyParity:  can't write the stripe\n");
      red2_cant_correct = RF_TRUE;
    } else {
      red2_corrected = RF_TRUE;
    }
    rf_FreeDAG(wr_dag_h);
  }
  if ( (redundantOneErr && parity_cant_correct) || 
       (redundantTwoErr && red2_cant_correct ))
      retcode = RF_PARITY_COULD_NOT_CORRECT;
  if ( (retcode = RF_PARITY_BAD) && parity_corrected && red2_corrected )
      retcode = RF_PARITY_CORRECTED;
d552 5
a556 5
  rf_FreeAccessStripeMap(asm_h);
  rf_FreeAllocList(alloclist);
  rf_FreeDAG(rd_dag_h);
  rf_FreeMCPair(mcpair);
  return(retcode);
d558 1
a558 2

#endif /* RF_INCLUDE_EVENODD > 0 */
@

