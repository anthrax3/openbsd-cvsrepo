head	1.9;
access;
symbols
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.18
	OPENBSD_5_0:1.8.0.16
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.14
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.12
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.8
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.20
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.18
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.16
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.14
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.12
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.10
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.6.0.8
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.8;

1.8
date	2007.09.09.16.50.23;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.08.16.07.40;	author peter;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2000.01.11.18.02.21;	author peter;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.08.04.13.10.54;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.17;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.10;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.6.8.1
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_diskqueue.c,v 1.8 2007/09/09 16:50:23 krw Exp $	*/
/*	$NetBSD: rf_diskqueue.c,v 1.13 2000/03/04 04:22:34 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 *
 * rf_diskqueue.c -- Higher-level disk queue code.
 *
 * The routines here are a generic wrapper around the actual queueing
 * routines. The code here implements thread scheduling, synchronization,
 * and locking ops (see below) on top of the lower-level queueing code.
 *
 * To support atomic RMW, we implement "locking operations". When a
 * locking op is dispatched to the lower levels of the driver, the
 * queue is locked, and no further I/Os are dispatched until the queue
 * receives & completes a corresponding "unlocking operation". This
 * code relies on the higher layers to guarantee that a locking op
 * will always be eventually followed by an unlocking op. The model
 * is that the higher layers are structured so locking and unlocking
 * ops occur in pairs, i.e.  an unlocking op cannot be generated until
 * after a locking op reports completion. There is no good way to
 * check to see that an unlocking op "corresponds" to the op that
 * currently has the queue locked, so we make no such attempt. Since
 * by definition there can be only one locking op outstanding on a
 * disk, this should not be a problem.
 *
 * In the kernel, we allow multiple I/Os to be concurrently dispatched
 * to the disk driver. In order to support locking ops in this
 * environment, when we decide to do a locking op, we stop dispatching
 * new I/Os and wait until all dispatched I/Os have completed before
 * dispatching the locking op.
 *
 * Unfortunately, the code is different in the 3 different operating
 * states (user level, kernel, simulator). In the kernel, I/O is
 * non-blocking, and we have no disk threads to dispatch for us.
 * Therefore, we have to dispatch new I/Os to the scsi driver at the
 * time of enqueue, and also at the time of completion. At user
 * level, I/O is blocking, and so only the disk threads may dispatch
 * I/Os. Thus at user level, all we can do at enqueue time is enqueue
 * and wake up the disk thread to do the dispatch.
 *
 *****************************************************************************/

#include "rf_types.h"
#include "rf_threadstuff.h"
#include "rf_raid.h"
#include "rf_diskqueue.h"
#include "rf_alloclist.h"
#include "rf_acctrace.h"
#include "rf_etimer.h"
#include "rf_configure.h"
#include "rf_general.h"
#include "rf_freelist.h"
#include "rf_debugprint.h"
#include "rf_shutdown.h"
#include "rf_cvscan.h"
#include "rf_sstf.h"
#include "rf_fifo.h"
#include "rf_kintf.h"

int  rf_init_dqd(RF_DiskQueueData_t *);
void rf_clean_dqd(RF_DiskQueueData_t *);
void rf_ShutdownDiskQueueSystem(void *);

#define	Dprintf1(s,a)							\
	if (rf_queueDebug)						\
		rf_debug_printf(s,(void *)((unsigned long)a),		\
		    NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define	Dprintf2(s,a,b)							\
	if (rf_queueDebug)						\
		rf_debug_printf(s,(void *)((unsigned long)a),		\
		    (void *)((unsigned long)b),				\
		    NULL,NULL,NULL,NULL,NULL,NULL)
#define	Dprintf3(s,a,b,c)						\
	if (rf_queueDebug)						\
		rf_debug_printf(s,(void *)((unsigned long)a),		\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    NULL,NULL,NULL,NULL,NULL)

/*****************************************************************************
 *
 * The disk queue switch defines all the functions used in the
 * different queueing disciplines queue ID, init routine, enqueue
 * routine, dequeue routine.
 *
 *****************************************************************************/

static RF_DiskQueueSW_t diskqueuesw[] = {
	{"fifo",		/* FIFO */
		rf_FifoCreate,
		rf_FifoEnqueue,
		rf_FifoDequeue,
		rf_FifoPeek,
		rf_FifoPromote},

	{"cvscan",		/* cvscan */
		rf_CvscanCreate,
		rf_CvscanEnqueue,
		rf_CvscanDequeue,
		rf_CvscanPeek,
		rf_CvscanPromote},

	{"sstf",		/* shortest seek time first */
		rf_SstfCreate,
		rf_SstfEnqueue,
		rf_SstfDequeue,
		rf_SstfPeek,
		rf_SstfPromote},

	{"scan",		/* SCAN (two-way elevator) */
		rf_ScanCreate,
		rf_SstfEnqueue,
		rf_ScanDequeue,
		rf_ScanPeek,
		rf_SstfPromote},

	{"cscan",		/* CSCAN (one-way elevator) */
		rf_CscanCreate,
		rf_SstfEnqueue,
		rf_CscanDequeue,
		rf_CscanPeek,
		rf_SstfPromote},

};
#define	NUM_DISK_QUEUE_TYPES	(sizeof(diskqueuesw)/sizeof(RF_DiskQueueSW_t))

static RF_FreeList_t *rf_dqd_freelist;

#define	RF_MAX_FREE_DQD		256
#define	RF_DQD_INC		 16
#define	RF_DQD_INITIAL		 64

#include <sys/buf.h>

int
rf_init_dqd(RF_DiskQueueData_t *dqd)
{

	dqd->bp = malloc(sizeof(struct buf), M_RAIDFRAME, M_NOWAIT | M_ZERO);
	if (dqd->bp == NULL) {
		return (ENOMEM);
	}

	return (0);
}

void
rf_clean_dqd(RF_DiskQueueData_t *dqd)
{
	free(dqd->bp, M_RAIDFRAME);
}

/* Configure a single disk queue. */
int
rf_ConfigureDiskQueue(
	RF_Raid_t		 *raidPtr,
	RF_DiskQueue_t		 *diskqueue,
	/* row & col -- Debug only.  BZZT not any more... */
	RF_RowCol_t		  r,
	RF_RowCol_t		  c,
	RF_DiskQueueSW_t	 *p,
	RF_SectorCount_t	  sectPerDisk,
	dev_t			  dev,
	int			  maxOutstanding,
	RF_ShutdownList_t	**listp,
	RF_AllocListElem_t	 *clList
)
{
	int rc;

	diskqueue->row = r;
	diskqueue->col = c;
	diskqueue->qPtr = p;
	diskqueue->qHdr = (p->Create) (sectPerDisk, clList, listp);
	diskqueue->dev = dev;
	diskqueue->numOutstanding = 0;
	diskqueue->queueLength = 0;
	diskqueue->maxOutstanding = maxOutstanding;
	diskqueue->curPriority = RF_IO_NORMAL_PRIORITY;
	diskqueue->nextLockingOp = NULL;
	diskqueue->unlockingOp = NULL;
	diskqueue->numWaiting = 0;
	diskqueue->flags = 0;
	diskqueue->raidPtr = raidPtr;
	diskqueue->rf_cinfo = &raidPtr->raid_cinfo[r][c];
	rc = rf_create_managed_mutex(listp, &diskqueue->mutex);
	if (rc) {
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
		return (rc);
	}
	rc = rf_create_managed_cond(listp, &diskqueue->cond);
	if (rc) {
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
		return (rc);
	}
	return (0);
}

void
rf_ShutdownDiskQueueSystem(void *ignored)
{
	RF_FREELIST_DESTROY_CLEAN(rf_dqd_freelist, next,
	    (RF_DiskQueueData_t *), rf_clean_dqd);
}

int
rf_ConfigureDiskQueueSystem(RF_ShutdownList_t **listp)
{
	int rc;

	RF_FREELIST_CREATE(rf_dqd_freelist, RF_MAX_FREE_DQD, RF_DQD_INC,
	    sizeof(RF_DiskQueueData_t));
	if (rf_dqd_freelist == NULL)
		return (ENOMEM);
	rc = rf_ShutdownCreate(listp, rf_ShutdownDiskQueueSystem, NULL);
	if (rc) {
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d\n", __FILE__, __LINE__, rc);
		rf_ShutdownDiskQueueSystem(NULL);
		return (rc);
	}
	RF_FREELIST_PRIME_INIT(rf_dqd_freelist, RF_DQD_INITIAL, next,
	    (RF_DiskQueueData_t *), rf_init_dqd);
	return (0);
}

int
rf_ConfigureDiskQueues(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	RF_DiskQueue_t **diskQueues, *spareQueues;
	RF_DiskQueueSW_t *p;
	RF_RowCol_t r, c;
	int rc, i;

	raidPtr->maxQueueDepth = cfgPtr->maxOutstandingDiskReqs;

	for (p = NULL, i = 0; i < NUM_DISK_QUEUE_TYPES; i++) {
		if (!strcmp(diskqueuesw[i].queueType, cfgPtr->diskQueueType)) {
			p = &diskqueuesw[i];
			break;
		}
	}
	if (p == NULL) {
		RF_ERRORMSG2("Unknown queue type \"%s\".  Using %s\n",
		    cfgPtr->diskQueueType, diskqueuesw[0].queueType);
		p = &diskqueuesw[0];
	}
	raidPtr->qType = p;
	RF_CallocAndAdd(diskQueues, raidPtr->numRow, sizeof(RF_DiskQueue_t *),
	    (RF_DiskQueue_t **), raidPtr->cleanupList);
	if (diskQueues == NULL) {
		return (ENOMEM);
	}
	raidPtr->Queues = diskQueues;
	for (r = 0; r < raidPtr->numRow; r++) {
		RF_CallocAndAdd(diskQueues[r], raidPtr->numCol +
				 ((r == 0) ? RF_MAXSPARE : 0),
				sizeof(RF_DiskQueue_t), (RF_DiskQueue_t *),
				raidPtr->cleanupList);
		if (diskQueues[r] == NULL)
			return (ENOMEM);
		for (c = 0; c < raidPtr->numCol; c++) {
			rc = rf_ConfigureDiskQueue(raidPtr, &diskQueues[r][c],
			    r, c, p, raidPtr->sectorsPerDisk,
			    raidPtr->Disks[r][c].dev,
			    cfgPtr->maxOutstandingDiskReqs, listp,
			    raidPtr->cleanupList);
			if (rc)
				return (rc);
		}
	}

	spareQueues = &raidPtr->Queues[0][raidPtr->numCol];
	for (r = 0; r < raidPtr->numSpare; r++) {
		rc = rf_ConfigureDiskQueue(raidPtr, &spareQueues[r], 0,
		    raidPtr->numCol + r, p, raidPtr->sectorsPerDisk,
		    raidPtr->Disks[0][raidPtr->numCol + r].dev,
		    cfgPtr->maxOutstandingDiskReqs, listp,
		    raidPtr->cleanupList);
		if (rc)
			return (rc);
	}
	return (0);
}

/*
 * Enqueue a disk I/O
 *
 * Unfortunately, we have to do things differently in the different
 * environments (simulator, user-level, kernel).
 * At user level, all I/O is blocking, so we have 1 or more threads/disk
 * and the thread that enqueues is different from the thread that dequeues.
 * In the kernel, I/O is non-blocking and so we'd like to have multiple
 * I/Os outstanding on the physical disks when possible.
 *
 * When any request arrives at a queue, we have two choices:
 *    dispatch it to the lower levels
 *    queue it up
 *
 * Kernel rules for when to do what:
 *    locking request:	Queue empty => dispatch and lock queue,
 *			else queue it.
 *    unlocking req  :	Always dispatch it.
 *    normal req     :	Queue empty => dispatch it & set priority.
 *			Queue not full & priority is ok => dispatch it
 *			else queue it.
 *
 * User-level rules:
 *    Always enqueue. In the special case of an unlocking op, enqueue
 *    in a special way that will cause the unlocking op to be the next
 *    thing dequeued.
 *
 * Simulator rules:
 *    Do the same as at user level, with the sleeps and wakeups suppressed.
 */
void
rf_DiskIOEnqueue(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req, int pri)
{
	RF_ETIMER_START(req->qtime);
	RF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);
	req->priority = pri;

	if (rf_queueDebug && (req->numSector == 0)) {
		printf("Warning: Enqueueing zero-sector access\n");
	}
	/*
         * Kernel.
         */
	RF_LOCK_QUEUE_MUTEX(queue, "DiskIOEnqueue");
	/* Locking request. */
	if (RF_LOCKING_REQ(req)) {
		if (RF_QUEUE_EMPTY(queue)) {
			Dprintf3("Dispatching pri %d locking op to r %d c %d"
			    " (queue empty)\n", pri, queue->row, queue->col);
			RF_LOCK_QUEUE(queue);
			rf_DispatchKernelIO(queue, req);
		} else {
			/*
			 * Increment count of number of requests waiting
			 * in this queue.
			 */
			queue->queueLength++;
			Dprintf3("Enqueueing pri %d locking op to r %d c %d"
			    " (queue not empty)\n", pri, queue->row,
			    queue->col);
			req->queue = (void *) queue;
			(queue->qPtr->Enqueue) (queue->qHdr, req, pri);
		}
	} else {
	/* Unlocking request. */
		if (RF_UNLOCKING_REQ(req)) {
			/*
			 * We'll do the actual unlock when this
			 * I/O completes.
			 */
			Dprintf3("Dispatching pri %d unlocking op to r %d"
			    " c %d\n", pri, queue->row, queue->col);
			RF_ASSERT(RF_QUEUE_LOCKED(queue));
			rf_DispatchKernelIO(queue, req);
		} else {
	/* Normal request. */
			if (RF_OK_TO_DISPATCH(queue, req)) {
				Dprintf3("Dispatching pri %d regular op to"
				    " r %d c %d (ok to dispatch)\n", pri,
				    queue->row, queue->col);
				rf_DispatchKernelIO(queue, req);
			} else {
				/*
				 * Increment count of number of requests
				 * waiting in this queue.
				 */
				queue->queueLength++;
				Dprintf3("Enqueueing pri %d regular op to"
				    " r %d c %d (not ok to dispatch)\n", pri,
				    queue->row, queue->col);
				req->queue = (void *) queue;
				(queue->qPtr->Enqueue) (queue->qHdr, req, pri);
			}
		}
	}
	RF_UNLOCK_QUEUE_MUTEX(queue, "DiskIOEnqueue");
}


/* Get the next set of I/Os started, kernel version only. */
void
rf_DiskIOComplete(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req, int status)
{
	int done = 0;

	RF_LOCK_QUEUE_MUTEX(queue, "DiskIOComplete");

	/*
	 * Unlock the queue:
	 * (1) after an unlocking req completes.
	 * (2) after a locking req fails.
	 */
	if (RF_UNLOCKING_REQ(req) || (RF_LOCKING_REQ(req) && status)) {
		Dprintf2("DiskIOComplete: unlocking queue at r %d c %d\n",
		    queue->row, queue->col);
		RF_ASSERT(RF_QUEUE_LOCKED(queue) &&
		    (queue->unlockingOp == NULL));
		RF_UNLOCK_QUEUE(queue);
	}
	queue->numOutstanding--;
	RF_ASSERT(queue->numOutstanding >= 0);

	/*
	 * Dispatch requests to the disk until we find one that we can't.
	 * No reason to continue once we've filled up the queue.
	 * No reason to even start if the queue is locked.
	 */

	while (!done && !RF_QUEUE_FULL(queue) && !RF_QUEUE_LOCKED(queue)) {
		if (queue->nextLockingOp) {
			req = queue->nextLockingOp;
			queue->nextLockingOp = NULL;
			Dprintf3("DiskIOComplete: a pri %d locking req was"
			    " pending at r %d c %d\n", req->priority,
			    queue->row, queue->col);
		} else {
			req = (queue->qPtr->Dequeue) (queue->qHdr);
			if (req != NULL) {
				Dprintf3("DiskIOComplete: extracting pri %d"
				    " req from queue at r %d c %d\n",
				    req->priority, queue->row, queue->col);
			} else {
				Dprintf1("DiskIOComplete: no more requests"
				    " to extract.\n", "");
			}
		}
		if (req) {
			/*
			 * Decrement count of number of requests waiting
			 * in this queue.
			 */
			queue->queueLength--;
			RF_ASSERT(queue->queueLength >= 0);
		}
		if (!req)
			done = 1;
		else {
			if (RF_LOCKING_REQ(req)) {
				if (RF_QUEUE_EMPTY(queue)) {
					/* Dispatch it. */
					Dprintf3("DiskIOComplete: dispatching"
					    " pri %d locking req to r %d c %d"
					    " (queue empty)\n", req->priority,
					    queue->row, queue->col);
					RF_LOCK_QUEUE(queue);
					rf_DispatchKernelIO(queue, req);
					done = 1;
				} else {
					/*
					 * Put it aside to wait for
					 * the queue to drain.
					 */
					Dprintf3("DiskIOComplete: postponing"
					    " pri %d locking req to r %d"
					    " c %d\n", req->priority,
					    queue->row, queue->col);
					RF_ASSERT(queue->nextLockingOp == NULL);
					queue->nextLockingOp = req;
					done = 1;
				}
			} else {
				if (RF_UNLOCKING_REQ(req)) {
					/*
					 * Should not happen:
					 * Unlocking ops should not get queued.
					 */
					/* Support it anyway for the future. */
					RF_ASSERT(RF_QUEUE_LOCKED(queue));
					Dprintf3("DiskIOComplete: dispatching"
					    " pri %d unl req to r %d c %d"
					    " (SHOULD NOT SEE THIS)\n",
					    req->priority, queue->row,
					    queue->col);
					rf_DispatchKernelIO(queue, req);
					done = 1;
				} else {
					if (RF_OK_TO_DISPATCH(queue, req)) {
						Dprintf3("DiskIOComplete:"
						    " dispatching pri %d"
						    " regular req to r %d"
						    " c %d (ok to dispatch)\n",
						    req->priority, queue->row,
						    queue->col);
						rf_DispatchKernelIO(queue, req);
					} else {
						/*
						 * We can't dispatch it,
						 * so just re-enqueue
						 * it.
						 */
						/*
						 * Potential trouble here if
						 * disk queues batch reqs.
						 */
						Dprintf3("DiskIOComplete:"
						    " re-enqueueing pri %d"
						    " regular req to r %d"
						    " c %d\n", req->priority,
						    queue->row, queue->col);
						queue->queueLength++;
						(queue->qPtr->Enqueue)
						    (queue->qHdr, req,
						    req->priority);
						done = 1;
					}
				}
			}
		}
	}

	RF_UNLOCK_QUEUE_MUTEX(queue, "DiskIOComplete");
}

/* Promote accesses tagged with the given parityStripeID from low priority
 * to normal priority. This promotion is optional, meaning that a queue
 * need not implement it. If there is no promotion routine associated with
 * a queue, this routine does nothing and returns -1.
 */
int
rf_DiskIOPromote(RF_DiskQueue_t *queue, RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru)
{
	int retval;

	if (!queue->qPtr->Promote)
		return (-1);
	RF_LOCK_QUEUE_MUTEX(queue, "DiskIOPromote");
	retval = (queue->qPtr->Promote) (queue->qHdr, parityStripeID, which_ru);
	RF_UNLOCK_QUEUE_MUTEX(queue, "DiskIOPromote");
	return (retval);
}

RF_DiskQueueData_t *
rf_CreateDiskQueueData(
	RF_IoType_t		  typ,
	RF_SectorNum_t		  ssect,
	RF_SectorCount_t	  nsect,
	caddr_t			  buf,
	RF_StripeNum_t		  parityStripeID,
	RF_ReconUnitNum_t	  which_ru,
	int			(*wakeF) (void *, int),
	void			 *arg,
	RF_DiskQueueData_t	 *next,
	RF_AccTraceEntry_t	 *tracerec,
	void			 *raidPtr,
	RF_DiskQueueDataFlags_t	  flags,
	void			 *kb_proc
)
{
	RF_DiskQueueData_t *p;

	RF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *),
	    rf_init_dqd);

	p->sectorOffset = ssect + rf_protectedSectors;
	p->numSector = nsect;
	p->type = typ;
	p->buf = buf;
	p->parityStripeID = parityStripeID;
	p->which_ru = which_ru;
	p->CompleteFunc = wakeF;
	p->argument = arg;
	p->next = next;
	p->tracerec = tracerec;
	p->priority = RF_IO_NORMAL_PRIORITY;
	p->AuxFunc = NULL;
	p->buf2 = NULL;
	p->raidPtr = raidPtr;
	p->flags = flags;
	p->b_proc = kb_proc;
	return (p);
}

RF_DiskQueueData_t *
rf_CreateDiskQueueDataFull(
	RF_IoType_t		  typ,
	RF_SectorNum_t		  ssect,
	RF_SectorCount_t	  nsect,
	caddr_t			  buf,
	RF_StripeNum_t		  parityStripeID,
	RF_ReconUnitNum_t	  which_ru,
	int			(*wakeF) (void *, int),
	void			 *arg,
	RF_DiskQueueData_t	 *next,
	RF_AccTraceEntry_t	 *tracerec,
	int			  priority,
	int			(*AuxFunc) (void *,...),
	caddr_t			  buf2,
	void			 *raidPtr,
	RF_DiskQueueDataFlags_t	  flags,
	void			 *kb_proc
)
{
	RF_DiskQueueData_t *p;

	RF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *),
	    rf_init_dqd);

	p->sectorOffset = ssect + rf_protectedSectors;
	p->numSector = nsect;
	p->type = typ;
	p->buf = buf;
	p->parityStripeID = parityStripeID;
	p->which_ru = which_ru;
	p->CompleteFunc = wakeF;
	p->argument = arg;
	p->next = next;
	p->tracerec = tracerec;
	p->priority = priority;
	p->AuxFunc = AuxFunc;
	p->buf2 = buf2;
	p->raidPtr = raidPtr;
	p->flags = flags;
	p->b_proc = kb_proc;
	return (p);
}

void
rf_FreeDiskQueueData(RF_DiskQueueData_t *p)
{
	RF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, rf_clean_dqd);
}
@


1.8
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_diskqueue.c,v 1.7 2002/12/16 07:01:03 tdeval Exp $	*/
@


1.7
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_diskqueue.c,v 1.6 2000/08/08 16:07:40 peter Exp $	*/
d166 1
a166 2
	dqd->bp = (struct buf *) malloc(sizeof(struct buf), M_RAIDFRAME,
	    M_NOWAIT);
a169 2
	/* If you don't do it, nobody else will... */
	memset(dqd->bp, 0, sizeof(struct buf));
@


1.6
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_diskqueue.c,v 1.5 2000/01/11 18:02:21 peter Exp $	*/
d3 1
d31 1
a31 1
/****************************************************************************
d33 1
a33 1
 * rf_diskqueue.c -- higher-level disk queue code
d35 2
a36 2
 * the routines here are a generic wrapper around the actual queueing
 * routines.  The code here implements thread scheduling, synchronization,
d39 1
a39 1
 * to support atomic RMW, we implement "locking operations".  When a
d42 1
a42 1
 * receives & completes a corresponding "unlocking operation".  This
d44 1
a44 1
 * will always be eventually followed by an unlocking op.  The model
d47 1
a47 1
 * after a locking op reports completion.  There is no good way to
d49 1
a49 1
 * currently has the queue locked, so we make no such attempt.  Since
d54 1
a54 1
 * to the disk driver.  In order to support locking ops in this
d60 1
a60 1
 * states (user level, kernel, simulator).  In the kernel, I/O is
d63 1
a63 1
 * time of enqueue, and also at the time of completion.  At user
d65 1
a65 1
 * I/Os.  Thus at user level, all we can do at enqueue time is enqueue
d68 1
a68 1
 ****************************************************************************/
d87 19
a105 7
static int init_dqd(RF_DiskQueueData_t *);
static void clean_dqd(RF_DiskQueueData_t *);
static void rf_ShutdownDiskQueueSystem(void *);

#define Dprintf1(s,a)         if (rf_queueDebug) rf_debug_printf(s,(void *)((unsigned long)a),NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf2(s,a,b)       if (rf_queueDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf3(s,a,b,c)     if (rf_queueDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),NULL,NULL,NULL,NULL,NULL)
d109 1
a109 1
 * the disk queue switch defines all the functions used in the
d111 1
a111 1
 * routine, dequeue routine
d113 1
a113 1
 ****************************************************************************/
d121 1
a121 1
	rf_FifoPromote},
d128 1
a128 1
	rf_CvscanPromote},
d135 1
a135 1
	rf_SstfPromote},
d142 1
a142 1
	rf_SstfPromote},
d149 1
a149 1
	rf_SstfPromote},
d152 1
a152 1
#define NUM_DISK_QUEUE_TYPES (sizeof(diskqueuesw)/sizeof(RF_DiskQueueSW_t))
d156 3
a158 3
#define RF_MAX_FREE_DQD 256
#define RF_DQD_INC       16
#define RF_DQD_INITIAL   64
d162 2
a163 3
static int 
init_dqd(dqd)
	RF_DiskQueueData_t *dqd;
d166 2
a167 2
	dqd->bp = (struct buf *) malloc(sizeof(struct buf), 
					M_RAIDFRAME, M_NOWAIT);
d171 3
a173 2
	memset(dqd->bp, 0, sizeof(struct buf));	/* if you don't do it, nobody
						 * else will.. */
d177 2
a178 3
static void 
clean_dqd(dqd)
	RF_DiskQueueData_t *dqd;
a181 1
/* configures a single disk queue */
d183 2
a184 1
int 
d186 12
a197 11
      RF_Raid_t * raidPtr,
      RF_DiskQueue_t * diskqueue,
      RF_RowCol_t r,		/* row & col -- debug only.  BZZT not any
				 * more... */
      RF_RowCol_t c,
      RF_DiskQueueSW_t * p,
      RF_SectorCount_t sectPerDisk,
      dev_t dev,
      int maxOutstanding,
      RF_ShutdownList_t ** listp,
      RF_AllocListElem_t * clList)
d199 1
a199 1
	int     rc;
d218 2
a219 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d224 2
a225 2
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d231 2
a232 3
static void 
rf_ShutdownDiskQueueSystem(ignored)
	void   *ignored;
d234 2
a235 1
	RF_FREELIST_DESTROY_CLEAN(rf_dqd_freelist, next, (RF_DiskQueueData_t *), clean_dqd);
d238 2
a239 3
int 
rf_ConfigureDiskQueueSystem(listp)
	RF_ShutdownList_t **listp;
d241 1
a241 1
	int     rc;
d243 2
a244 2
	RF_FREELIST_CREATE(rf_dqd_freelist, RF_MAX_FREE_DQD,
	    RF_DQD_INC, sizeof(RF_DiskQueueData_t));
d249 2
a250 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d255 1
a255 1
	    (RF_DiskQueueData_t *), init_dqd);
d259 3
a261 5
int 
rf_ConfigureDiskQueues(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d266 1
a266 1
	int     rc, i;
d277 2
a278 1
		RF_ERRORMSG2("Unknown queue type \"%s\".  Using %s\n", cfgPtr->diskQueueType, diskqueuesw[0].queueType);
d282 2
a283 1
	RF_CallocAndAdd(diskQueues, raidPtr->numRow, sizeof(RF_DiskQueue_t *), (RF_DiskQueue_t **), raidPtr->cleanupList);
d289 3
a291 3
		RF_CallocAndAdd(diskQueues[r], raidPtr->numCol + 
				 ((r == 0) ? RF_MAXSPARE : 0), 
				sizeof(RF_DiskQueue_t), (RF_DiskQueue_t *), 
d297 4
a300 5
						   r, c, p,
						   raidPtr->sectorsPerDisk, 
						   raidPtr->Disks[r][c].dev,
						   cfgPtr->maxOutstandingDiskReqs, 
						   listp, raidPtr->cleanupList);
d308 2
a309 3
		rc = rf_ConfigureDiskQueue(raidPtr, &spareQueues[r],
		    0, raidPtr->numCol + r, p,
		    raidPtr->sectorsPerDisk,
d318 3
a320 1
/* Enqueue a disk I/O
d329 1
a329 1
 * when any request arrives at a queue, we have two choices:
d333 7
a339 7
 * kernel rules for when to do what:
 *    locking request:  queue empty => dispatch and lock queue,
 *                      else queue it
 *    unlocking req  :  always dispatch it
 *    normal req     :  queue empty => dispatch it & set priority
 *                      queue not full & priority is ok => dispatch it
 *                      else queue it
d341 2
a342 2
 * user-level rules:
 *    always enqueue.  In the special case of an unlocking op, enqueue
d346 1
a346 1
 * simulator rules:
d349 2
a350 5
void 
rf_DiskIOEnqueue(queue, req, pri)
	RF_DiskQueue_t *queue;
	RF_DiskQueueData_t *req;
	int     pri;
d360 1
a360 1
         * kernel
d363 1
a363 1
	/* locking request */
d366 2
a367 1
			Dprintf3("Dispatching pri %d locking op to r %d c %d (queue empty)\n", pri, queue->row, queue->col);
d371 8
a378 4
			queue->queueLength++;	/* increment count of number
						 * of requests waiting in this
						 * queue */
			Dprintf3("Enqueueing pri %d locking op to r %d c %d (queue not empty)\n", pri, queue->row, queue->col);
d382 9
a390 6
	}
	/* unlocking request */
	else
		if (RF_UNLOCKING_REQ(req)) {	/* we'll do the actual unlock
						 * when this I/O completes */
			Dprintf3("Dispatching pri %d unlocking op to r %d c %d\n", pri, queue->row, queue->col);
d393 2
a394 3
		}
	/* normal request */
		else
d396 3
a398 1
				Dprintf3("Dispatching pri %d regular op to r %d c %d (ok to dispatch)\n", pri, queue->row, queue->col);
d401 8
a408 4
				queue->queueLength++;	/* increment count of
							 * number of requests
							 * waiting in this queue */
				Dprintf3("Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\n", pri, queue->row, queue->col);
d412 2
d418 3
a420 6
/* get the next set of I/Os started, kernel version only */
void 
rf_DiskIOComplete(queue, req, status)
	RF_DiskQueue_t *queue;
	RF_DiskQueueData_t *req;
	int     status;
d422 1
a422 1
	int     done = 0;
d426 5
a430 2
	/* unlock the queue: (1) after an unlocking req completes (2) after a
	 * locking req fails */
d432 4
a435 2
		Dprintf2("DiskIOComplete: unlocking queue at r %d c %d\n", queue->row, queue->col);
		RF_ASSERT(RF_QUEUE_LOCKED(queue) && (queue->unlockingOp == NULL));
d441 5
a445 3
	/* dispatch requests to the disk until we find one that we can't. */
	/* no reason to continue once we've filled up the queue */
	/* no reason to even start if the queue is locked */
d451 3
a453 1
			Dprintf3("DiskIOComplete: a pri %d locking req was pending at r %d c %d\n", req->priority, queue->row, queue->col);
d457 3
a459 1
				Dprintf3("DiskIOComplete: extracting pri %d req from queue at r %d c %d\n", req->priority, queue->row, queue->col);
d461 2
a462 1
				Dprintf1("DiskIOComplete: no more requests to extract.\n", "");
d466 5
a470 3
			queue->queueLength--;	/* decrement count of number
						 * of requests waiting in this
						 * queue */
d475 1
a475 1
		else
d477 6
a482 2
				if (RF_QUEUE_EMPTY(queue)) {	/* dispatch it */
					Dprintf3("DiskIOComplete: dispatching pri %d locking req to r %d c %d (queue empty)\n", req->priority, queue->row, queue->col);
d486 9
a494 3
				} else {	/* put it aside to wait for
						 * the queue to drain */
					Dprintf3("DiskIOComplete: postponing pri %d locking req to r %d c %d\n", req->priority, queue->row, queue->col);
d499 13
a511 7
			} else
				if (RF_UNLOCKING_REQ(req)) {	/* should not happen:
								 * unlocking ops should
								 * not get queued */
					RF_ASSERT(RF_QUEUE_LOCKED(queue));	/* support it anyway for
										 * the future */
					Dprintf3("DiskIOComplete: dispatching pri %d unl req to r %d c %d (SHOULD NOT SEE THIS)\n", req->priority, queue->row, queue->col);
d514 1
a514 1
				} else
d516 6
a521 1
						Dprintf3("DiskIOComplete: dispatching pri %d regular req to r %d c %d (ok to dispatch)\n", req->priority, queue->row, queue->col);
d523 15
a537 6
					} else {	/* we can't dispatch it,
							 * so just re-enqueue
							 * it.  */
						/* potential trouble here if
						 * disk queues batch reqs */
						Dprintf3("DiskIOComplete: re-enqueueing pri %d regular req to r %d c %d\n", req->priority, queue->row, queue->col);
d539 3
a541 1
						(queue->qPtr->Enqueue) (queue->qHdr, req, req->priority);
d544 3
d551 4
a554 3
/* promotes accesses tagged with the given parityStripeID from low priority
 * to normal priority.  This promotion is optional, meaning that a queue
 * need not implement it.  If there is no promotion routine associated with
d557 3
a559 5
int 
rf_DiskIOPromote(queue, parityStripeID, which_ru)
	RF_DiskQueue_t *queue;
	RF_StripeNum_t parityStripeID;
	RF_ReconUnitNum_t which_ru;
d561 1
a561 1
	int     retval;
d573 14
a586 13
    RF_IoType_t typ,
    RF_SectorNum_t ssect,
    RF_SectorCount_t nsect,
    caddr_t buf,
    RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru,
    int (*wakeF) (void *, int),
    void *arg,
    RF_DiskQueueData_t * next,
    RF_AccTraceEntry_t * tracerec,
    void *raidPtr,
    RF_DiskQueueDataFlags_t flags,
    void *kb_proc)
d590 2
a591 1
	RF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);
d614 17
a630 16
    RF_IoType_t typ,
    RF_SectorNum_t ssect,
    RF_SectorCount_t nsect,
    caddr_t buf,
    RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru,
    int (*wakeF) (void *, int),
    void *arg,
    RF_DiskQueueData_t * next,
    RF_AccTraceEntry_t * tracerec,
    int priority,
    int (*AuxFunc) (void *,...),
    caddr_t buf2,
    void *raidPtr,
    RF_DiskQueueDataFlags_t flags,
    void *kb_proc)
d634 2
a635 1
	RF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);
d656 2
a657 3
void 
rf_FreeDiskQueueData(p)
	RF_DiskQueueData_t *p;
d659 1
a659 1
	RF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, clean_dqd);
@


1.6.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d32 1
a32 1
 * rf_diskqueue.c -- Higher-level disk queue code.
d34 2
a35 2
 * The routines here are a generic wrapper around the actual queueing
 * routines. The code here implements thread scheduling, synchronization,
d38 1
a38 1
 * To support atomic RMW, we implement "locking operations". When a
d41 1
a41 1
 * receives & completes a corresponding "unlocking operation". This
d43 1
a43 1
 * will always be eventually followed by an unlocking op. The model
d46 1
a46 1
 * after a locking op reports completion. There is no good way to
d48 1
a48 1
 * currently has the queue locked, so we make no such attempt. Since
d53 1
a53 1
 * to the disk driver. In order to support locking ops in this
d59 1
a59 1
 * states (user level, kernel, simulator). In the kernel, I/O is
d62 1
a62 1
 * time of enqueue, and also at the time of completion. At user
d64 1
a64 1
 * I/Os. Thus at user level, all we can do at enqueue time is enqueue
d67 1
a67 1
 *****************************************************************************/
d86 7
a92 19
int  rf_init_dqd(RF_DiskQueueData_t *);
void rf_clean_dqd(RF_DiskQueueData_t *);
void rf_ShutdownDiskQueueSystem(void *);

#define	Dprintf1(s,a)							\
	if (rf_queueDebug)						\
		rf_debug_printf(s,(void *)((unsigned long)a),		\
		    NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define	Dprintf2(s,a,b)							\
	if (rf_queueDebug)						\
		rf_debug_printf(s,(void *)((unsigned long)a),		\
		    (void *)((unsigned long)b),				\
		    NULL,NULL,NULL,NULL,NULL,NULL)
#define	Dprintf3(s,a,b,c)						\
	if (rf_queueDebug)						\
		rf_debug_printf(s,(void *)((unsigned long)a),		\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    NULL,NULL,NULL,NULL,NULL)
d96 1
a96 1
 * The disk queue switch defines all the functions used in the
d98 1
a98 1
 * routine, dequeue routine.
d100 1
a100 1
 *****************************************************************************/
d108 1
a108 1
		rf_FifoPromote},
d115 1
a115 1
		rf_CvscanPromote},
d122 1
a122 1
		rf_SstfPromote},
d129 1
a129 1
		rf_SstfPromote},
d136 1
a136 1
		rf_SstfPromote},
d139 1
a139 1
#define	NUM_DISK_QUEUE_TYPES	(sizeof(diskqueuesw)/sizeof(RF_DiskQueueSW_t))
d143 3
a145 3
#define	RF_MAX_FREE_DQD		256
#define	RF_DQD_INC		 16
#define	RF_DQD_INITIAL		 64
d149 3
a151 2
int
rf_init_dqd(RF_DiskQueueData_t *dqd)
d154 2
a155 2
	dqd->bp = (struct buf *) malloc(sizeof(struct buf), M_RAIDFRAME,
	    M_NOWAIT);
d159 2
a160 3
	/* If you don't do it, nobody else will... */
	memset(dqd->bp, 0, sizeof(struct buf));

d164 3
a166 2
void
rf_clean_dqd(RF_DiskQueueData_t *dqd)
d170 1
d172 1
a172 2
/* Configure a single disk queue. */
int
d174 11
a184 12
	RF_Raid_t		 *raidPtr,
	RF_DiskQueue_t		 *diskqueue,
	/* row & col -- Debug only.  BZZT not any more... */
	RF_RowCol_t		  r,
	RF_RowCol_t		  c,
	RF_DiskQueueSW_t	 *p,
	RF_SectorCount_t	  sectPerDisk,
	dev_t			  dev,
	int			  maxOutstanding,
	RF_ShutdownList_t	**listp,
	RF_AllocListElem_t	 *clList
)
d186 1
a186 1
	int rc;
d205 2
a206 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d211 2
a212 2
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d218 3
a220 2
void
rf_ShutdownDiskQueueSystem(void *ignored)
d222 1
a222 2
	RF_FREELIST_DESTROY_CLEAN(rf_dqd_freelist, next,
	    (RF_DiskQueueData_t *), rf_clean_dqd);
d225 3
a227 2
int
rf_ConfigureDiskQueueSystem(RF_ShutdownList_t **listp)
d229 1
a229 1
	int rc;
d231 2
a232 2
	RF_FREELIST_CREATE(rf_dqd_freelist, RF_MAX_FREE_DQD, RF_DQD_INC,
	    sizeof(RF_DiskQueueData_t));
d237 2
a238 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d\n", __FILE__, __LINE__, rc);
d243 1
a243 1
	    (RF_DiskQueueData_t *), rf_init_dqd);
d247 5
a251 3
int
rf_ConfigureDiskQueues(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d256 1
a256 1
	int rc, i;
d267 1
a267 2
		RF_ERRORMSG2("Unknown queue type \"%s\".  Using %s\n",
		    cfgPtr->diskQueueType, diskqueuesw[0].queueType);
d271 1
a271 2
	RF_CallocAndAdd(diskQueues, raidPtr->numRow, sizeof(RF_DiskQueue_t *),
	    (RF_DiskQueue_t **), raidPtr->cleanupList);
d277 3
a279 3
		RF_CallocAndAdd(diskQueues[r], raidPtr->numCol +
				 ((r == 0) ? RF_MAXSPARE : 0),
				sizeof(RF_DiskQueue_t), (RF_DiskQueue_t *),
d285 5
a289 4
			    r, c, p, raidPtr->sectorsPerDisk,
			    raidPtr->Disks[r][c].dev,
			    cfgPtr->maxOutstandingDiskReqs, listp,
			    raidPtr->cleanupList);
d297 3
a299 2
		rc = rf_ConfigureDiskQueue(raidPtr, &spareQueues[r], 0,
		    raidPtr->numCol + r, p, raidPtr->sectorsPerDisk,
d308 1
a308 3

/*
 * Enqueue a disk I/O
d317 1
a317 1
 * When any request arrives at a queue, we have two choices:
d321 7
a327 7
 * Kernel rules for when to do what:
 *    locking request:	Queue empty => dispatch and lock queue,
 *			else queue it.
 *    unlocking req  :	Always dispatch it.
 *    normal req     :	Queue empty => dispatch it & set priority.
 *			Queue not full & priority is ok => dispatch it
 *			else queue it.
d329 2
a330 2
 * User-level rules:
 *    Always enqueue. In the special case of an unlocking op, enqueue
d334 1
a334 1
 * Simulator rules:
d337 5
a341 2
void
rf_DiskIOEnqueue(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req, int pri)
d351 1
a351 1
         * Kernel.
d354 1
a354 1
	/* Locking request. */
d357 1
a357 2
			Dprintf3("Dispatching pri %d locking op to r %d c %d"
			    " (queue empty)\n", pri, queue->row, queue->col);
d361 4
a364 8
			/*
			 * Increment count of number of requests waiting
			 * in this queue.
			 */
			queue->queueLength++;
			Dprintf3("Enqueueing pri %d locking op to r %d c %d"
			    " (queue not empty)\n", pri, queue->row,
			    queue->col);
d368 6
a373 9
	} else {
	/* Unlocking request. */
		if (RF_UNLOCKING_REQ(req)) {
			/*
			 * We'll do the actual unlock when this
			 * I/O completes.
			 */
			Dprintf3("Dispatching pri %d unlocking op to r %d"
			    " c %d\n", pri, queue->row, queue->col);
d376 3
a378 2
		} else {
	/* Normal request. */
d380 1
a380 3
				Dprintf3("Dispatching pri %d regular op to"
				    " r %d c %d (ok to dispatch)\n", pri,
				    queue->row, queue->col);
d383 4
a386 8
				/*
				 * Increment count of number of requests
				 * waiting in this queue.
				 */
				queue->queueLength++;
				Dprintf3("Enqueueing pri %d regular op to"
				    " r %d c %d (not ok to dispatch)\n", pri,
				    queue->row, queue->col);
a389 2
		}
	}
d394 6
a399 3
/* Get the next set of I/Os started, kernel version only. */
void
rf_DiskIOComplete(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req, int status)
d401 1
a401 1
	int done = 0;
d405 2
a406 5
	/*
	 * Unlock the queue:
	 * (1) after an unlocking req completes.
	 * (2) after a locking req fails.
	 */
d408 2
a409 4
		Dprintf2("DiskIOComplete: unlocking queue at r %d c %d\n",
		    queue->row, queue->col);
		RF_ASSERT(RF_QUEUE_LOCKED(queue) &&
		    (queue->unlockingOp == NULL));
d415 3
a417 5
	/*
	 * Dispatch requests to the disk until we find one that we can't.
	 * No reason to continue once we've filled up the queue.
	 * No reason to even start if the queue is locked.
	 */
d423 1
a423 3
			Dprintf3("DiskIOComplete: a pri %d locking req was"
			    " pending at r %d c %d\n", req->priority,
			    queue->row, queue->col);
d427 1
a427 3
				Dprintf3("DiskIOComplete: extracting pri %d"
				    " req from queue at r %d c %d\n",
				    req->priority, queue->row, queue->col);
d429 1
a429 2
				Dprintf1("DiskIOComplete: no more requests"
				    " to extract.\n", "");
d433 3
a435 5
			/*
			 * Decrement count of number of requests waiting
			 * in this queue.
			 */
			queue->queueLength--;
d440 1
a440 1
		else {
d442 2
a443 6
				if (RF_QUEUE_EMPTY(queue)) {
					/* Dispatch it. */
					Dprintf3("DiskIOComplete: dispatching"
					    " pri %d locking req to r %d c %d"
					    " (queue empty)\n", req->priority,
					    queue->row, queue->col);
d447 3
a449 9
				} else {
					/*
					 * Put it aside to wait for
					 * the queue to drain.
					 */
					Dprintf3("DiskIOComplete: postponing"
					    " pri %d locking req to r %d"
					    " c %d\n", req->priority,
					    queue->row, queue->col);
d454 7
a460 13
			} else {
				if (RF_UNLOCKING_REQ(req)) {
					/*
					 * Should not happen:
					 * Unlocking ops should not get queued.
					 */
					/* Support it anyway for the future. */
					RF_ASSERT(RF_QUEUE_LOCKED(queue));
					Dprintf3("DiskIOComplete: dispatching"
					    " pri %d unl req to r %d c %d"
					    " (SHOULD NOT SEE THIS)\n",
					    req->priority, queue->row,
					    queue->col);
d463 1
a463 1
				} else {
d465 1
a465 6
						Dprintf3("DiskIOComplete:"
						    " dispatching pri %d"
						    " regular req to r %d"
						    " c %d (ok to dispatch)\n",
						    req->priority, queue->row,
						    queue->col);
d467 6
a472 15
					} else {
						/*
						 * We can't dispatch it,
						 * so just re-enqueue
						 * it.
						 */
						/*
						 * Potential trouble here if
						 * disk queues batch reqs.
						 */
						Dprintf3("DiskIOComplete:"
						    " re-enqueueing pri %d"
						    " regular req to r %d"
						    " c %d\n", req->priority,
						    queue->row, queue->col);
d474 1
a474 3
						(queue->qPtr->Enqueue)
						    (queue->qHdr, req,
						    req->priority);
a476 3
				}
			}
		}
d481 3
a483 4

/* Promote accesses tagged with the given parityStripeID from low priority
 * to normal priority. This promotion is optional, meaning that a queue
 * need not implement it. If there is no promotion routine associated with
d486 5
a490 3
int
rf_DiskIOPromote(RF_DiskQueue_t *queue, RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru)
d492 1
a492 1
	int retval;
d504 13
a516 14
	RF_IoType_t		  typ,
	RF_SectorNum_t		  ssect,
	RF_SectorCount_t	  nsect,
	caddr_t			  buf,
	RF_StripeNum_t		  parityStripeID,
	RF_ReconUnitNum_t	  which_ru,
	int			(*wakeF) (void *, int),
	void			 *arg,
	RF_DiskQueueData_t	 *next,
	RF_AccTraceEntry_t	 *tracerec,
	void			 *raidPtr,
	RF_DiskQueueDataFlags_t	  flags,
	void			 *kb_proc
)
d520 1
a520 2
	RF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *),
	    rf_init_dqd);
d543 16
a558 17
	RF_IoType_t		  typ,
	RF_SectorNum_t		  ssect,
	RF_SectorCount_t	  nsect,
	caddr_t			  buf,
	RF_StripeNum_t		  parityStripeID,
	RF_ReconUnitNum_t	  which_ru,
	int			(*wakeF) (void *, int),
	void			 *arg,
	RF_DiskQueueData_t	 *next,
	RF_AccTraceEntry_t	 *tracerec,
	int			  priority,
	int			(*AuxFunc) (void *,...),
	caddr_t			  buf2,
	void			 *raidPtr,
	RF_DiskQueueDataFlags_t	  flags,
	void			 *kb_proc
)
d562 1
a562 2
	RF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *),
	    rf_init_dqd);
d583 3
a585 2
void
rf_FreeDiskQueueData(RF_DiskQueueData_t *p)
d587 1
a587 1
	RF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, rf_clean_dqd);
@


1.5
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_diskqueue.c,v 1.4 1999/08/04 13:10:54 peter Exp $	*/
/*	$NetBSD: rf_diskqueue.c,v 1.8 2000/01/07 03:43:39 oster Exp $	*/
d30 1
a30 1
/****************************************************************************************
d38 28
a65 24
 * to support atomic RMW, we implement "locking operations".  When a locking op
 * is dispatched to the lower levels of the driver, the queue is locked, and no further
 * I/Os are dispatched until the queue receives & completes a corresponding "unlocking
 * operation".  This code relies on the higher layers to guarantee that a locking
 * op will always be eventually followed by an unlocking op.  The model is that
 * the higher layers are structured so locking and unlocking ops occur in pairs, i.e.
 * an unlocking op cannot be generated until after a locking op reports completion.
 * There is no good way to check to see that an unlocking op "corresponds" to the
 * op that currently has the queue locked, so we make no such attempt.  Since by
 * definition there can be only one locking op outstanding on a disk, this should
 * not be a problem.
 *
 * In the kernel, we allow multiple I/Os to be concurrently dispatched to the disk
 * driver.  In order to support locking ops in this environment, when we decide to
 * do a locking op, we stop dispatching new I/Os and wait until all dispatched I/Os
 * have completed before dispatching the locking op.
 *
 * Unfortunately, the code is different in the 3 different operating states
 * (user level, kernel, simulator).  In the kernel, I/O is non-blocking, and
 * we have no disk threads to dispatch for us.  Therefore, we have to dispatch
 * new I/Os to the scsi driver at the time of enqueue, and also at the time
 * of completion.  At user level, I/O is blocking, and so only the disk threads
 * may dispatch I/Os.  Thus at user level, all we can do at enqueue time is
 * enqueue and wake up the disk thread to do the dispatch.
d67 1
a67 1
 ***************************************************************************************/
d84 1
a88 3
/* From rf_kintf.c */
int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);

a92 6
#define Dprintf4(s,a,b,c,d)   if (rf_queueDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),NULL,NULL,NULL,NULL)
#define Dprintf5(s,a,b,c,d,e) if (rf_queueDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),NULL,NULL,NULL)


#define SIGNAL_DISK_QUEUE(_q_,_wh_)
#define WAIT_DISK_QUEUE(_q_,_wh_)
d94 1
a94 1
/*****************************************************************************************
d96 3
a98 3
 * the disk queue switch defines all the functions used in the different queueing
 * disciplines
 *    queue ID, init routine, enqueue routine, dequeue routine
d100 1
a100 1
 ****************************************************************************************/
a137 9
#if !defined(_KERNEL) && RF_INCLUDE_QUEUE_RANDOM > 0
	/* to make a point to Chris :-> */
	{"random",		/* random */
		rf_FifoCreate,
		rf_FifoEnqueue,
		rf_RandomDequeue,
		rf_RandomPeek,
	rf_FifoPromote},
#endif				/* !_KERNEL && RF_INCLUDE_QUEUE_RANDOM > 0 */
d153 3
a155 3
	/* XXX not sure if the following malloc is appropriate... probably not
	 * quite... */
	dqd->bp = (struct buf *) malloc(sizeof(struct buf), M_RAIDFRAME, M_NOWAIT);
d171 1
a171 5
int config_disk_queue(RF_Raid_t *, RF_DiskQueue_t *, RF_RowCol_t, 
		      RF_RowCol_t, RF_DiskQueueSW_t *,
		      RF_SectorCount_t, dev_t, int, 
		      RF_ShutdownList_t **,
		      RF_AllocListElem_t *);
d173 4
a176 4
config_disk_queue(
    RF_Raid_t * raidPtr,
    RF_DiskQueue_t * diskqueue,
    RF_RowCol_t r,		/* row & col -- debug only.  BZZT not any
d178 7
a184 7
    RF_RowCol_t c,
    RF_DiskQueueSW_t * p,
    RF_SectorCount_t sectPerDisk,
    dev_t dev,
    int maxOutstanding,
    RF_ShutdownList_t ** listp,
    RF_AllocListElem_t * clList)
d270 1
d284 6
a289 3
			rc = config_disk_queue(raidPtr, &diskQueues[r][c], r, c, p,
			    raidPtr->sectorsPerDisk, raidPtr->Disks[r][c].dev,
			    cfgPtr->maxOutstandingDiskReqs, listp, raidPtr->cleanupList);
d297 1
a297 1
		rc = config_disk_queue(raidPtr, &spareQueues[r],
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_diskqueue.c,v 1.6 2000/08/08 16:07:40 peter Exp $	*/
/*	$NetBSD: rf_diskqueue.c,v 1.13 2000/03/04 04:22:34 oster Exp $	*/
d30 1
a30 1
/****************************************************************************
d38 24
a61 28
 * to support atomic RMW, we implement "locking operations".  When a
 * locking op is dispatched to the lower levels of the driver, the
 * queue is locked, and no further I/Os are dispatched until the queue
 * receives & completes a corresponding "unlocking operation".  This
 * code relies on the higher layers to guarantee that a locking op
 * will always be eventually followed by an unlocking op.  The model
 * is that the higher layers are structured so locking and unlocking
 * ops occur in pairs, i.e.  an unlocking op cannot be generated until
 * after a locking op reports completion.  There is no good way to
 * check to see that an unlocking op "corresponds" to the op that
 * currently has the queue locked, so we make no such attempt.  Since
 * by definition there can be only one locking op outstanding on a
 * disk, this should not be a problem.
 *
 * In the kernel, we allow multiple I/Os to be concurrently dispatched
 * to the disk driver.  In order to support locking ops in this
 * environment, when we decide to do a locking op, we stop dispatching
 * new I/Os and wait until all dispatched I/Os have completed before
 * dispatching the locking op.
 *
 * Unfortunately, the code is different in the 3 different operating
 * states (user level, kernel, simulator).  In the kernel, I/O is
 * non-blocking, and we have no disk threads to dispatch for us.
 * Therefore, we have to dispatch new I/Os to the scsi driver at the
 * time of enqueue, and also at the time of completion.  At user
 * level, I/O is blocking, and so only the disk threads may dispatch
 * I/Os.  Thus at user level, all we can do at enqueue time is enqueue
 * and wake up the disk thread to do the dispatch.
d63 1
a63 1
 ****************************************************************************/
a79 1
#include "rf_kintf.h"
d84 3
d91 6
d98 1
a98 1
/*****************************************************************************
d100 3
a102 3
 * the disk queue switch defines all the functions used in the
 * different queueing disciplines queue ID, init routine, enqueue
 * routine, dequeue routine
d104 1
a104 1
 ****************************************************************************/
d142 9
d166 3
a168 3

	dqd->bp = (struct buf *) malloc(sizeof(struct buf), 
					M_RAIDFRAME, M_NOWAIT);
d184 5
a188 1

d190 4
a193 4
rf_ConfigureDiskQueue(
      RF_Raid_t * raidPtr,
      RF_DiskQueue_t * diskqueue,
      RF_RowCol_t r,		/* row & col -- debug only.  BZZT not any
d195 7
a201 7
      RF_RowCol_t c,
      RF_DiskQueueSW_t * p,
      RF_SectorCount_t sectPerDisk,
      dev_t dev,
      int maxOutstanding,
      RF_ShutdownList_t ** listp,
      RF_AllocListElem_t * clList)
a286 1
	raidPtr->qType = p;
d300 3
a302 6
			rc = rf_ConfigureDiskQueue(raidPtr, &diskQueues[r][c],
						   r, c, p,
						   raidPtr->sectorsPerDisk, 
						   raidPtr->Disks[r][c].dev,
						   cfgPtr->maxOutstandingDiskReqs, 
						   listp, raidPtr->cleanupList);
d310 1
a310 1
		rc = rf_ConfigureDiskQueue(raidPtr, &spareQueues[r],
@


1.5.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d32 1
a32 1
 * rf_diskqueue.c -- Higher-level disk queue code.
d34 2
a35 2
 * The routines here are a generic wrapper around the actual queueing
 * routines. The code here implements thread scheduling, synchronization,
d38 1
a38 1
 * To support atomic RMW, we implement "locking operations". When a
d41 1
a41 1
 * receives & completes a corresponding "unlocking operation". This
d43 1
a43 1
 * will always be eventually followed by an unlocking op. The model
d46 1
a46 1
 * after a locking op reports completion. There is no good way to
d48 1
a48 1
 * currently has the queue locked, so we make no such attempt. Since
d53 1
a53 1
 * to the disk driver. In order to support locking ops in this
d59 1
a59 1
 * states (user level, kernel, simulator). In the kernel, I/O is
d62 1
a62 1
 * time of enqueue, and also at the time of completion. At user
d64 1
a64 1
 * I/Os. Thus at user level, all we can do at enqueue time is enqueue
d67 1
a67 1
 *****************************************************************************/
d86 7
a92 19
int  rf_init_dqd(RF_DiskQueueData_t *);
void rf_clean_dqd(RF_DiskQueueData_t *);
void rf_ShutdownDiskQueueSystem(void *);

#define	Dprintf1(s,a)							\
	if (rf_queueDebug)						\
		rf_debug_printf(s,(void *)((unsigned long)a),		\
		    NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define	Dprintf2(s,a,b)							\
	if (rf_queueDebug)						\
		rf_debug_printf(s,(void *)((unsigned long)a),		\
		    (void *)((unsigned long)b),				\
		    NULL,NULL,NULL,NULL,NULL,NULL)
#define	Dprintf3(s,a,b,c)						\
	if (rf_queueDebug)						\
		rf_debug_printf(s,(void *)((unsigned long)a),		\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    NULL,NULL,NULL,NULL,NULL)
d96 1
a96 1
 * The disk queue switch defines all the functions used in the
d98 1
a98 1
 * routine, dequeue routine.
d100 1
a100 1
 *****************************************************************************/
d108 1
a108 1
		rf_FifoPromote},
d115 1
a115 1
		rf_CvscanPromote},
d122 1
a122 1
		rf_SstfPromote},
d129 1
a129 1
		rf_SstfPromote},
d136 1
a136 1
		rf_SstfPromote},
d139 1
a139 1
#define	NUM_DISK_QUEUE_TYPES	(sizeof(diskqueuesw)/sizeof(RF_DiskQueueSW_t))
d143 3
a145 3
#define	RF_MAX_FREE_DQD		256
#define	RF_DQD_INC		 16
#define	RF_DQD_INITIAL		 64
d149 3
a151 2
int
rf_init_dqd(RF_DiskQueueData_t *dqd)
d154 2
a155 2
	dqd->bp = (struct buf *) malloc(sizeof(struct buf), M_RAIDFRAME,
	    M_NOWAIT);
d159 2
a160 3
	/* If you don't do it, nobody else will... */
	memset(dqd->bp, 0, sizeof(struct buf));

d164 3
a166 2
void
rf_clean_dqd(RF_DiskQueueData_t *dqd)
d170 1
d172 1
a172 2
/* Configure a single disk queue. */
int
d174 11
a184 12
	RF_Raid_t		 *raidPtr,
	RF_DiskQueue_t		 *diskqueue,
	/* row & col -- Debug only.  BZZT not any more... */
	RF_RowCol_t		  r,
	RF_RowCol_t		  c,
	RF_DiskQueueSW_t	 *p,
	RF_SectorCount_t	  sectPerDisk,
	dev_t			  dev,
	int			  maxOutstanding,
	RF_ShutdownList_t	**listp,
	RF_AllocListElem_t	 *clList
)
d186 1
a186 1
	int rc;
d205 2
a206 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d211 2
a212 2
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d218 3
a220 2
void
rf_ShutdownDiskQueueSystem(void *ignored)
d222 1
a222 2
	RF_FREELIST_DESTROY_CLEAN(rf_dqd_freelist, next,
	    (RF_DiskQueueData_t *), rf_clean_dqd);
d225 3
a227 2
int
rf_ConfigureDiskQueueSystem(RF_ShutdownList_t **listp)
d229 1
a229 1
	int rc;
d231 2
a232 2
	RF_FREELIST_CREATE(rf_dqd_freelist, RF_MAX_FREE_DQD, RF_DQD_INC,
	    sizeof(RF_DiskQueueData_t));
d237 2
a238 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d\n", __FILE__, __LINE__, rc);
d243 1
a243 1
	    (RF_DiskQueueData_t *), rf_init_dqd);
d247 5
a251 3
int
rf_ConfigureDiskQueues(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d256 1
a256 1
	int rc, i;
d267 1
a267 2
		RF_ERRORMSG2("Unknown queue type \"%s\".  Using %s\n",
		    cfgPtr->diskQueueType, diskqueuesw[0].queueType);
d271 1
a271 2
	RF_CallocAndAdd(diskQueues, raidPtr->numRow, sizeof(RF_DiskQueue_t *),
	    (RF_DiskQueue_t **), raidPtr->cleanupList);
d277 3
a279 3
		RF_CallocAndAdd(diskQueues[r], raidPtr->numCol +
				 ((r == 0) ? RF_MAXSPARE : 0),
				sizeof(RF_DiskQueue_t), (RF_DiskQueue_t *),
d285 5
a289 4
			    r, c, p, raidPtr->sectorsPerDisk,
			    raidPtr->Disks[r][c].dev,
			    cfgPtr->maxOutstandingDiskReqs, listp,
			    raidPtr->cleanupList);
d297 3
a299 2
		rc = rf_ConfigureDiskQueue(raidPtr, &spareQueues[r], 0,
		    raidPtr->numCol + r, p, raidPtr->sectorsPerDisk,
d308 1
a308 3

/*
 * Enqueue a disk I/O
d317 1
a317 1
 * When any request arrives at a queue, we have two choices:
d321 7
a327 7
 * Kernel rules for when to do what:
 *    locking request:	Queue empty => dispatch and lock queue,
 *			else queue it.
 *    unlocking req  :	Always dispatch it.
 *    normal req     :	Queue empty => dispatch it & set priority.
 *			Queue not full & priority is ok => dispatch it
 *			else queue it.
d329 2
a330 2
 * User-level rules:
 *    Always enqueue. In the special case of an unlocking op, enqueue
d334 1
a334 1
 * Simulator rules:
d337 5
a341 2
void
rf_DiskIOEnqueue(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req, int pri)
d351 1
a351 1
         * Kernel.
d354 1
a354 1
	/* Locking request. */
d357 1
a357 2
			Dprintf3("Dispatching pri %d locking op to r %d c %d"
			    " (queue empty)\n", pri, queue->row, queue->col);
d361 4
a364 8
			/*
			 * Increment count of number of requests waiting
			 * in this queue.
			 */
			queue->queueLength++;
			Dprintf3("Enqueueing pri %d locking op to r %d c %d"
			    " (queue not empty)\n", pri, queue->row,
			    queue->col);
d368 6
a373 9
	} else {
	/* Unlocking request. */
		if (RF_UNLOCKING_REQ(req)) {
			/*
			 * We'll do the actual unlock when this
			 * I/O completes.
			 */
			Dprintf3("Dispatching pri %d unlocking op to r %d"
			    " c %d\n", pri, queue->row, queue->col);
d376 3
a378 2
		} else {
	/* Normal request. */
d380 1
a380 3
				Dprintf3("Dispatching pri %d regular op to"
				    " r %d c %d (ok to dispatch)\n", pri,
				    queue->row, queue->col);
d383 4
a386 8
				/*
				 * Increment count of number of requests
				 * waiting in this queue.
				 */
				queue->queueLength++;
				Dprintf3("Enqueueing pri %d regular op to"
				    " r %d c %d (not ok to dispatch)\n", pri,
				    queue->row, queue->col);
a389 2
		}
	}
d394 6
a399 3
/* Get the next set of I/Os started, kernel version only. */
void
rf_DiskIOComplete(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req, int status)
d401 1
a401 1
	int done = 0;
d405 2
a406 5
	/*
	 * Unlock the queue:
	 * (1) after an unlocking req completes.
	 * (2) after a locking req fails.
	 */
d408 2
a409 4
		Dprintf2("DiskIOComplete: unlocking queue at r %d c %d\n",
		    queue->row, queue->col);
		RF_ASSERT(RF_QUEUE_LOCKED(queue) &&
		    (queue->unlockingOp == NULL));
d415 3
a417 5
	/*
	 * Dispatch requests to the disk until we find one that we can't.
	 * No reason to continue once we've filled up the queue.
	 * No reason to even start if the queue is locked.
	 */
d423 1
a423 3
			Dprintf3("DiskIOComplete: a pri %d locking req was"
			    " pending at r %d c %d\n", req->priority,
			    queue->row, queue->col);
d427 1
a427 3
				Dprintf3("DiskIOComplete: extracting pri %d"
				    " req from queue at r %d c %d\n",
				    req->priority, queue->row, queue->col);
d429 1
a429 2
				Dprintf1("DiskIOComplete: no more requests"
				    " to extract.\n", "");
d433 3
a435 5
			/*
			 * Decrement count of number of requests waiting
			 * in this queue.
			 */
			queue->queueLength--;
d440 1
a440 1
		else {
d442 2
a443 6
				if (RF_QUEUE_EMPTY(queue)) {
					/* Dispatch it. */
					Dprintf3("DiskIOComplete: dispatching"
					    " pri %d locking req to r %d c %d"
					    " (queue empty)\n", req->priority,
					    queue->row, queue->col);
d447 3
a449 9
				} else {
					/*
					 * Put it aside to wait for
					 * the queue to drain.
					 */
					Dprintf3("DiskIOComplete: postponing"
					    " pri %d locking req to r %d"
					    " c %d\n", req->priority,
					    queue->row, queue->col);
d454 7
a460 13
			} else {
				if (RF_UNLOCKING_REQ(req)) {
					/*
					 * Should not happen:
					 * Unlocking ops should not get queued.
					 */
					/* Support it anyway for the future. */
					RF_ASSERT(RF_QUEUE_LOCKED(queue));
					Dprintf3("DiskIOComplete: dispatching"
					    " pri %d unl req to r %d c %d"
					    " (SHOULD NOT SEE THIS)\n",
					    req->priority, queue->row,
					    queue->col);
d463 1
a463 1
				} else {
d465 1
a465 6
						Dprintf3("DiskIOComplete:"
						    " dispatching pri %d"
						    " regular req to r %d"
						    " c %d (ok to dispatch)\n",
						    req->priority, queue->row,
						    queue->col);
d467 6
a472 15
					} else {
						/*
						 * We can't dispatch it,
						 * so just re-enqueue
						 * it.
						 */
						/*
						 * Potential trouble here if
						 * disk queues batch reqs.
						 */
						Dprintf3("DiskIOComplete:"
						    " re-enqueueing pri %d"
						    " regular req to r %d"
						    " c %d\n", req->priority,
						    queue->row, queue->col);
d474 1
a474 3
						(queue->qPtr->Enqueue)
						    (queue->qHdr, req,
						    req->priority);
a476 3
				}
			}
		}
d481 3
a483 4

/* Promote accesses tagged with the given parityStripeID from low priority
 * to normal priority. This promotion is optional, meaning that a queue
 * need not implement it. If there is no promotion routine associated with
d486 5
a490 3
int
rf_DiskIOPromote(RF_DiskQueue_t *queue, RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru)
d492 1
a492 1
	int retval;
d504 13
a516 14
	RF_IoType_t		  typ,
	RF_SectorNum_t		  ssect,
	RF_SectorCount_t	  nsect,
	caddr_t			  buf,
	RF_StripeNum_t		  parityStripeID,
	RF_ReconUnitNum_t	  which_ru,
	int			(*wakeF) (void *, int),
	void			 *arg,
	RF_DiskQueueData_t	 *next,
	RF_AccTraceEntry_t	 *tracerec,
	void			 *raidPtr,
	RF_DiskQueueDataFlags_t	  flags,
	void			 *kb_proc
)
d520 1
a520 2
	RF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *),
	    rf_init_dqd);
d543 16
a558 17
	RF_IoType_t		  typ,
	RF_SectorNum_t		  ssect,
	RF_SectorCount_t	  nsect,
	caddr_t			  buf,
	RF_StripeNum_t		  parityStripeID,
	RF_ReconUnitNum_t	  which_ru,
	int			(*wakeF) (void *, int),
	void			 *arg,
	RF_DiskQueueData_t	 *next,
	RF_AccTraceEntry_t	 *tracerec,
	int			  priority,
	int			(*AuxFunc) (void *,...),
	caddr_t			  buf2,
	void			 *raidPtr,
	RF_DiskQueueDataFlags_t	  flags,
	void			 *kb_proc
)
d562 1
a562 2
	RF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *),
	    rf_init_dqd);
d583 3
a585 2
void
rf_FreeDiskQueueData(RF_DiskQueueData_t *p)
d587 1
a587 1
	RF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, rf_clean_dqd);
@


1.4
log
@* remove redundant rf_ccmn.h

* remove init call to rf_ConfigureEtimer() and rf_sys.c in which it is the
  only function. update conf/files to reflect this.

* update sources to make sure _KERNEL is used not KERNEL

* change rf_etimer.h to protect macros an include of sys/kernel.h with
  a check for _KERNEL - let raidctl compile again.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_diskqueue.c,v 1.3 1999/07/30 14:45:32 peter Exp $	*/
/*	$NetBSD: rf_diskqueue.c,v 1.7 1999/06/04 01:51:00 oster Exp $	*/
a66 1
#include "rf_threadid.h"
a355 2
	int     tid;

a356 1
	rf_get_threadid(tid);
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_diskqueue.c,v 1.2 1999/02/16 00:02:39 niklas Exp $	*/
d151 1
a151 1
#endif				/* !KERNEL && RF_INCLUDE_QUEUE_RANDOM > 0 */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_diskqueue.c,v 1.1 1999/01/11 14:29:17 niklas Exp $	*/
/*	$NetBSD: rf_diskqueue.c,v 1.6 1999/02/05 00:06:09 oster Exp $	*/
d185 6
a190 1
static int 
d294 4
a297 1
		RF_CallocAndAdd(diskQueues[r], raidPtr->numCol + ((r == 0) ? raidPtr->numSpare : 0), sizeof(RF_DiskQueue_t), (RF_DiskQueue_t *), raidPtr->cleanupList);
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_diskqueue.c,v 1.2 1998/12/03 14:58:24 oster Exp $	*/
/*	$NetBSD: rf_diskqueue.c,v 1.2 1998/12/03 14:58:24 oster Exp $	*/
d35 1
a35 1
 * routines.  The code here implements thread scheduling, synchronization, 
d58 3
a60 3
 * new I/Os to the scsi driver at the time of enqueue, and also at the time 
 * of completion.  At user level, I/O is blocking, and so only the disk threads 
 * may dispatch I/Os.  Thus at user level, all we can do at enqueue time is 
a64 152
/*
 * :  
 *
 * Log: rf_diskqueue.c,v 
 * Revision 1.50  1996/08/07 21:08:38  jimz
 * b_proc -> kb_proc
 *
 * Revision 1.49  1996/07/05  20:36:14  jimz
 * make rf_ConfigureDiskQueueSystem return 0
 *
 * Revision 1.48  1996/06/18  20:53:11  jimz
 * fix up disk queueing (remove configure routine,
 * add shutdown list arg to create routines)
 *
 * Revision 1.47  1996/06/14  14:16:36  jimz
 * fix handling of bogus queue type
 *
 * Revision 1.46  1996/06/13  20:41:44  jimz
 * add scan, cscan, random queueing
 *
 * Revision 1.45  1996/06/11  01:27:50  jimz
 * Fixed bug where diskthread shutdown would crash or hang. This
 * turned out to be two distinct bugs:
 * (1) [crash] The thread shutdown code wasn't properly waiting for
 * all the diskthreads to complete. This caused diskthreads that were
 * exiting+cleaning up to unlock a destroyed mutex.
 * (2) [hang] TerminateDiskQueues wasn't locking, and DiskIODequeue
 * only checked for termination _after_ a wakeup if the queues were
 * empty. This was a race where the termination wakeup could be lost
 * by the dequeueing thread, and the system would hang waiting for the
 * thread to exit, while the thread waited for an I/O or a signal to
 * check the termination flag.
 *
 * Revision 1.44  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.43  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.42  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.41  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.40  1996/06/06  17:28:04  jimz
 * track sector number of last I/O dequeued
 *
 * Revision 1.39  1996/06/06  01:14:13  jimz
 * fix crashing bug when tracerec is NULL (ie, from copyback)
 * initialize req->queue
 *
 * Revision 1.38  1996/06/05  19:38:32  jimz
 * fixed up disk queueing types config
 * added sstf disk queueing
 * fixed exit bug on diskthreads (ref-ing bad mem)
 *
 * Revision 1.37  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.36  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.35  1996/05/30  12:59:18  jimz
 * make etimer happier, more portable
 *
 * Revision 1.34  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.33  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.32  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.31  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.30  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.29  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.28  1996/05/20  16:14:29  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.27  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.26  1996/05/16  19:21:49  wvcii
 * fixed typo in init_dqd
 *
 * Revision 1.25  1996/05/16  16:02:51  jimz
 * switch to RF_FREELIST stuff for DiskQueueData
 *
 * Revision 1.24  1996/05/10  16:24:14  jimz
 * new cvscan function names
 *
 * Revision 1.23  1996/05/01  16:27:54  jimz
 * don't use ccmn bp management
 *
 * Revision 1.22  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.21  1995/12/01  15:59:59  root
 * added copyright info
 *
 * Revision 1.20  1995/11/07  16:27:20  wvcii
 * added Peek() function to diskqueuesw
 * non-locking accesses are never blocked (assume clients enforce proper
 * respect for lock acquisition)
 *
 * Revision 1.19  1995/10/05  18:56:52  jimz
 * fix req handling in IOComplete
 *
 * Revision 1.18  1995/10/04  20:13:50  wvcii
 * added asserts to monitor numOutstanding queueLength
 *
 * Revision 1.17  1995/10/04  07:43:52  wvcii
 * queue->numOutstanding now valid for user & sim
 * added queue->queueLength
 * user tested & verified, sim untested
 *
 * Revision 1.16  1995/09/12  00:21:19  wvcii
 * added support for tracing disk queue time
 *
 */

a81 8
#ifdef SIMULATE
#include "rf_diskevent.h"
#endif /* SIMULATE */

#if !defined(__NetBSD__) && !defined(__OpenBSD__)
extern struct buf *ubc_bufget();
#endif

d86 1
a86 1
int rf_DispatchKernelIO(RF_DiskQueue_t *,RF_DiskQueueData_t *);
a94 19
#if !defined(KERNEL) && !defined(SIMULATE)

/* queue must be locked before invoking this */
#define SIGNAL_DISK_QUEUE(_q_,_wh_)  \
{                                    \
  if ( (_q_)->numWaiting > 0) {      \
    (_q_)->numWaiting--;             \
    RF_SIGNAL_COND( ((_q_)->cond) );    \
  }                                  \
}

/* queue must be locked before invoking this */
#define WAIT_DISK_QUEUE(_q_,_wh_)                                         \
{                                                                         \
  (_q_)->numWaiting++;                                                    \
  RF_WAIT_COND( ((_q_)->cond), ((_q_)->mutex) );                             \
}

#else /* !defined(KERNEL) && !defined(SIMULATE) */
a98 2
#endif /* !defined(KERNEL) && !defined(SIMULATE) */

d108 5
a112 5
	{"fifo", /* FIFO */
	rf_FifoCreate,
	rf_FifoEnqueue,
	rf_FifoDequeue,
	rf_FifoPeek,
d115 12
a126 12
	{"cvscan", /* cvscan */
	rf_CvscanCreate,
	rf_CvscanEnqueue,
	rf_CvscanDequeue,
	rf_CvscanPeek,
	rf_CvscanPromote },

	{"sstf", /* shortest seek time first */
	rf_SstfCreate,
	rf_SstfEnqueue,
	rf_SstfDequeue,
	rf_SstfPeek,
d129 5
a133 5
	{"scan", /* SCAN (two-way elevator) */
	rf_ScanCreate,
	rf_SstfEnqueue,
	rf_ScanDequeue,
	rf_ScanPeek,
d136 5
a140 5
	{"cscan", /* CSCAN (one-way elevator) */
	rf_CscanCreate,
	rf_SstfEnqueue,
	rf_CscanDequeue,
	rf_CscanPeek,
d143 1
a143 1
#if !defined(KERNEL) && RF_INCLUDE_QUEUE_RANDOM > 0
d145 5
a149 5
	{"random", /* random */
	rf_FifoCreate,
	rf_FifoEnqueue,
	rf_RandomDequeue,
	rf_RandomPeek,
d151 1
a151 1
#endif /* !KERNEL && RF_INCLUDE_QUEUE_RANDOM > 0 */
a160 2
#if defined(__NetBSD__) || defined(__OpenBSD__)
#ifdef _KERNEL
a161 2
#endif
#endif
d163 7
a169 13
static int init_dqd(dqd)
  RF_DiskQueueData_t  *dqd;
{
#ifdef KERNEL
#if defined(__NetBSD__) || defined(__OpenBSD__)
	/* XXX not sure if the following malloc is appropriate... probably not quite... */
	dqd->bp = (struct buf *) malloc( sizeof(struct buf), M_DEVBUF, M_NOWAIT);
	memset(dqd->bp,0,sizeof(struct buf)); /* if you don't do it, nobody else will.. */
	/* XXX */
	/* printf("NEED TO IMPLEMENT THIS BETTER!\n"); */
#else
	dqd->bp = ubc_bufget();
#endif
d171 1
a171 1
		return(ENOMEM);
d173 3
a175 2
#endif /* KERNEL */
	return(0);
d178 3
a180 2
static void clean_dqd(dqd)
  RF_DiskQueueData_t  *dqd;
d182 48
a229 8
#ifdef KERNEL
#if defined(__NetBSD__) || defined(__OpenBSD__)
	/* printf("NEED TO IMPLEMENT THIS BETTER(2)!\n"); */
	/* XXX ? */
	free( dqd->bp, M_DEVBUF );
#else
    ubc_buffree(dqd->bp);
#endif
d231 5
a235 1
#endif /* KERNEL */
d238 3
a240 80
/* configures a single disk queue */
static int config_disk_queue(
  RF_Raid_t            *raidPtr,
  RF_DiskQueue_t       *diskqueue,
  RF_RowCol_t           r, /* row & col -- debug only.  BZZT not any more... */
  RF_RowCol_t           c,
  RF_DiskQueueSW_t     *p,
  RF_SectorCount_t      sectPerDisk,
  dev_t                 dev,
  int                   maxOutstanding,
  RF_ShutdownList_t   **listp,
  RF_AllocListElem_t   *clList)
{
  int rc;

  diskqueue->row = r;
  diskqueue->col = c;
  diskqueue->qPtr = p;
  diskqueue->qHdr = (p->Create)(sectPerDisk, clList, listp);
  diskqueue->dev  = dev;
  diskqueue->numOutstanding = 0;
  diskqueue->queueLength = 0;
  diskqueue->maxOutstanding = maxOutstanding;
  diskqueue->curPriority    = RF_IO_NORMAL_PRIORITY;
  diskqueue->nextLockingOp  = NULL;
  diskqueue->unlockingOp    = NULL;
  diskqueue->numWaiting=0;
  diskqueue->flags = 0;
  diskqueue->raidPtr = raidPtr;
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  diskqueue->rf_cinfo = &raidPtr->raid_cinfo[r][c];
#endif
  rc = rf_create_managed_mutex(listp, &diskqueue->mutex);
  if (rc) {
    RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    return(rc);
  }
  rc = rf_create_managed_cond(listp, &diskqueue->cond);
  if (rc) {
    RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    return(rc);
  }
  return(0);
}

static void rf_ShutdownDiskQueueSystem(ignored)
  void  *ignored;
{
  RF_FREELIST_DESTROY_CLEAN(rf_dqd_freelist,next,(RF_DiskQueueData_t *),clean_dqd);
}

int rf_ConfigureDiskQueueSystem(listp)
  RF_ShutdownList_t  **listp;
{
  int rc;

  RF_FREELIST_CREATE(rf_dqd_freelist, RF_MAX_FREE_DQD,
    RF_DQD_INC, sizeof(RF_DiskQueueData_t));
  if (rf_dqd_freelist == NULL)
    return(ENOMEM);
  rc = rf_ShutdownCreate(listp, rf_ShutdownDiskQueueSystem, NULL);
  if (rc) {
    RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
      __FILE__, __LINE__, rc);
    rf_ShutdownDiskQueueSystem(NULL);
    return(rc);
  }
  RF_FREELIST_PRIME_INIT(rf_dqd_freelist, RF_DQD_INITIAL,next,
    (RF_DiskQueueData_t *),init_dqd);
  return(0);
}

#ifndef KERNEL
/* this is called prior to shutdown to wakeup everyone waiting on a disk queue
 * and tell them to exit
 */
void rf_TerminateDiskQueues(raidPtr)
  RF_Raid_t  *raidPtr;
d242 58
a299 1
  RF_RowCol_t r, c;
d301 12
a312 64
  raidPtr->terminate_disk_queues = 1;
  for (r=0; r<raidPtr->numRow; r++) {
    for (c=0; c<raidPtr->numCol + ((r==0) ? raidPtr->numSpare : 0); c++) {
      RF_LOCK_QUEUE_MUTEX(&raidPtr->Queues[r][c], "TerminateDiskQueues");
      RF_BROADCAST_COND(raidPtr->Queues[r][c].cond);
      RF_UNLOCK_QUEUE_MUTEX(&raidPtr->Queues[r][c], "TerminateDiskQueues");
    }
  }
}
#endif /* !KERNEL */

int rf_ConfigureDiskQueues(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
{
  RF_DiskQueue_t **diskQueues, *spareQueues;
  RF_DiskQueueSW_t *p;
  RF_RowCol_t r, c;
  int rc, i;

  raidPtr->maxQueueDepth = cfgPtr->maxOutstandingDiskReqs;

  for(p=NULL,i=0;i<NUM_DISK_QUEUE_TYPES;i++) {
    if (!strcmp(diskqueuesw[i].queueType, cfgPtr->diskQueueType)) {
      p = &diskqueuesw[i];
      break;
    }
  }
  if (p == NULL) {
    RF_ERRORMSG2("Unknown queue type \"%s\".  Using %s\n",cfgPtr->diskQueueType, diskqueuesw[0].queueType);
    p = &diskqueuesw[0];
  }

  RF_CallocAndAdd(diskQueues, raidPtr->numRow, sizeof(RF_DiskQueue_t *), (RF_DiskQueue_t **), raidPtr->cleanupList);
  if (diskQueues == NULL) {
    return(ENOMEM);
  }
  raidPtr->Queues = diskQueues;
  for (r=0; r<raidPtr->numRow; r++) {
    RF_CallocAndAdd(diskQueues[r], raidPtr->numCol + ((r==0) ? raidPtr->numSpare : 0), sizeof(RF_DiskQueue_t), (RF_DiskQueue_t *), raidPtr->cleanupList);
    if (diskQueues[r] == NULL)
      return(ENOMEM);
    for (c=0; c<raidPtr->numCol; c++) {
      rc = config_disk_queue(raidPtr, &diskQueues[r][c], r, c, p,
        raidPtr->sectorsPerDisk, raidPtr->Disks[r][c].dev,
        cfgPtr->maxOutstandingDiskReqs, listp, raidPtr->cleanupList);
      if (rc)
        return(rc);
    }
  }

  spareQueues = &raidPtr->Queues[0][raidPtr->numCol];
  for (r=0; r<raidPtr->numSpare; r++) {
	  rc = config_disk_queue(raidPtr, &spareQueues[r], 
				 0, raidPtr->numCol+r, p,
				 raidPtr->sectorsPerDisk, 
				 raidPtr->Disks[0][raidPtr->numCol+r].dev,
				 cfgPtr->maxOutstandingDiskReqs, listp, 
				 raidPtr->cleanupList);
    if (rc)
      return(rc);
  }
  return(0);
a313 1

d343 57
a399 174
void rf_DiskIOEnqueue(queue, req, pri)
  RF_DiskQueue_t      *queue;
  RF_DiskQueueData_t  *req;
  int                  pri;
{
  int tid;

  RF_ETIMER_START(req->qtime);
  rf_get_threadid(tid);
  RF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);
  req->priority = pri;

  if (rf_queueDebug && (req->numSector == 0)) {
    printf("Warning: Enqueueing zero-sector access\n");
  }
  
#ifdef KERNEL
  /*
   * kernel
   */
  RF_LOCK_QUEUE_MUTEX( queue, "DiskIOEnqueue" );
  /* locking request */
  if (RF_LOCKING_REQ(req)) {
    if (RF_QUEUE_EMPTY(queue)) {
      Dprintf3("Dispatching pri %d locking op to r %d c %d (queue empty)\n",pri,queue->row, queue->col);
      RF_LOCK_QUEUE(queue);
      rf_DispatchKernelIO(queue, req);
    } else {
      queue->queueLength++;  /* increment count of number of requests waiting in this queue */
      Dprintf3("Enqueueing pri %d locking op to r %d c %d (queue not empty)\n",pri,queue->row, queue->col);
      req->queue = (void *)queue;
      (queue->qPtr->Enqueue)(queue->qHdr, req, pri);
    }
  }
  /* unlocking request */
  else if (RF_UNLOCKING_REQ(req)) {           /* we'll do the actual unlock when this I/O completes */
    Dprintf3("Dispatching pri %d unlocking op to r %d c %d\n",pri,queue->row, queue->col);
    RF_ASSERT(RF_QUEUE_LOCKED(queue));
    rf_DispatchKernelIO(queue, req);
  }
  /* normal request */
  else if (RF_OK_TO_DISPATCH(queue, req)) {
    Dprintf3("Dispatching pri %d regular op to r %d c %d (ok to dispatch)\n",pri,queue->row, queue->col);
    rf_DispatchKernelIO(queue, req);
  } else {
    queue->queueLength++;  /* increment count of number of requests waiting in this queue */
    Dprintf3("Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\n",pri,queue->row, queue->col);
    req->queue = (void *)queue;
    (queue->qPtr->Enqueue)(queue->qHdr, req, pri);
  }
  RF_UNLOCK_QUEUE_MUTEX( queue, "DiskIOEnqueue" );
  
#else /* KERNEL */
  /*
   * user-level
   */
  RF_LOCK_QUEUE_MUTEX( queue, "DiskIOEnqueue" );
  queue->queueLength++;  /* increment count of number of requests waiting in this queue */
  /* unlocking request */
  if (RF_UNLOCKING_REQ(req)) {
    Dprintf4("[%d] enqueueing pri %d unlocking op & signalling r %d c %d\n", tid, pri, queue->row, queue->col);
    RF_ASSERT(RF_QUEUE_LOCKED(queue) && queue->unlockingOp == NULL);
    queue->unlockingOp = req;
  }
  /* locking and normal requests */
  else {
    req->queue = (void *)queue;
    Dprintf5("[%d] enqueueing pri %d %s op & signalling r %d c %d\n", tid, pri,
	     (RF_LOCKING_REQ(req)) ? "locking" : "regular",queue->row,queue->col);
    (queue->qPtr->Enqueue)(queue->qHdr, req, pri);
  }
  SIGNAL_DISK_QUEUE( queue, "DiskIOEnqueue");
  RF_UNLOCK_QUEUE_MUTEX( queue, "DiskIOEnqueue" );
#endif /* KERNEL */
}
    
#if !defined(KERNEL) && !defined(SIMULATE)
/* user-level only: tell all threads to wake up & recheck the queue */
void rf_BroadcastOnQueue(queue)
  RF_DiskQueue_t *queue;
{
  int i;

  if (queue->maxOutstanding > 1) for (i=0; i<queue->maxOutstanding; i++) {
    SIGNAL_DISK_QUEUE(queue, "BroadcastOnQueue" );
  }
}
#endif /* !KERNEL && !SIMULATE */

#ifndef KERNEL /* not used in kernel */

RF_DiskQueueData_t *rf_DiskIODequeue(queue)
  RF_DiskQueue_t *queue;
{
  RF_DiskQueueData_t *p, *headItem;
  int tid;

  rf_get_threadid(tid);
  RF_LOCK_QUEUE_MUTEX( queue, "DiskIODequeue" );
  for (p=NULL; !p; ) {
    if (queue->unlockingOp) {
      /* unlocking request */
      RF_ASSERT(RF_QUEUE_LOCKED(queue));
      p = queue->unlockingOp;
      queue->unlockingOp = NULL;
      Dprintf4("[%d] dequeueing pri %d unlocking op r %d c %d\n", tid, p->priority, queue->row,queue->col);
    }
    else {
      headItem = (queue->qPtr->Peek)(queue->qHdr);
      if (headItem) {
        if (RF_LOCKING_REQ(headItem)) {
          /* locking request */
          if (!RF_QUEUE_LOCKED(queue)) {
            /* queue isn't locked, so dequeue the request & lock the queue */
            p = (queue->qPtr->Dequeue)( queue->qHdr );
            if (p)
              Dprintf4("[%d] dequeueing pri %d locking op r %d c %d\n", tid, p->priority, queue->row, queue->col);
            else
              Dprintf3("[%d] no dequeue -- raw queue empty r %d c %d\n", tid, queue->row, queue->col);
          }
          else {
            /* queue already locked, no dequeue occurs */
            Dprintf3("[%d] no dequeue -- queue is locked r %d c %d\n", tid, queue->row, queue->col);
            p = NULL;
          }
        }
        else {
          /* normal request, always dequeue and assume caller already has lock (if needed) */
          p = (queue->qPtr->Dequeue)( queue->qHdr );
          if (p)
            Dprintf4("[%d] dequeueing pri %d regular op r %d c %d\n", tid, p->priority, queue->row, queue->col);
          else
            Dprintf3("[%d] no dequeue -- raw queue empty r %d c %d\n", tid, queue->row, queue->col);
        }
      }
      else {
        Dprintf3("[%d] no dequeue -- raw queue empty r %d c %d\n", tid, queue->row, queue->col);
      }
    }

    if (queue->raidPtr->terminate_disk_queues) {
      p = NULL;
      break;
    }
#ifdef SIMULATE
    break;		/* in simulator, return NULL on empty queue instead of blocking */
#else /* SIMULATE */
    if (!p) {
      Dprintf3("[%d] nothing to dequeue: waiting r %d c %d\n", tid, queue->row, queue->col);
      WAIT_DISK_QUEUE( queue, "DiskIODequeue" );
    }
#endif /* SIMULATE */
  }

  if (p) {
    queue->queueLength--;  /* decrement count of number of requests waiting in this queue */
    RF_ASSERT(queue->queueLength >= 0);
    queue->numOutstanding++;
    queue->last_deq_sector = p->sectorOffset;
    /* record the amount of time this request spent in the disk queue */
    RF_ETIMER_STOP(p->qtime);
    RF_ETIMER_EVAL(p->qtime);
    if (p->tracerec)
      p->tracerec->diskqueue_us += RF_ETIMER_VAL_US(p->qtime);
  }

  if (p && RF_LOCKING_REQ(p)) {
    RF_ASSERT(!RF_QUEUE_LOCKED(queue));
    Dprintf3("[%d] locking queue r %d c %d\n",tid,queue->row,queue->col);
    RF_LOCK_QUEUE(queue);
  }
  RF_UNLOCK_QUEUE_MUTEX( queue, "DiskIODequeue" );
  
  return(p);
a401 1
#else /* !KERNEL */
d404 85
a488 73
void rf_DiskIOComplete(queue, req, status)
  RF_DiskQueue_t      *queue;
  RF_DiskQueueData_t  *req;
  int                  status;
{
  int done=0;

  RF_LOCK_QUEUE_MUTEX( queue, "DiskIOComplete" );

  /* unlock the queue:
     (1) after an unlocking req completes
     (2) after a locking req fails
  */
  if (RF_UNLOCKING_REQ(req) || (RF_LOCKING_REQ(req) && status)) {
    Dprintf2("DiskIOComplete: unlocking queue at r %d c %d\n", queue->row, queue->col);
    RF_ASSERT(RF_QUEUE_LOCKED(queue) && (queue->unlockingOp == NULL));
    RF_UNLOCK_QUEUE(queue);
  }

  queue->numOutstanding--;
  RF_ASSERT(queue->numOutstanding >= 0);

  /* dispatch requests to the disk until we find one that we can't. */
  /* no reason to continue once we've filled up the queue */
  /* no reason to even start if the queue is locked */
  
  while (!done && !RF_QUEUE_FULL(queue) && !RF_QUEUE_LOCKED(queue)) {
    if (queue->nextLockingOp) {
      req = queue->nextLockingOp; queue->nextLockingOp = NULL;
      Dprintf3("DiskIOComplete: a pri %d locking req was pending at r %d c %d\n",req->priority,queue->row, queue->col);
    } else {
      req = (queue->qPtr->Dequeue)( queue->qHdr );
      if (req != NULL) {
	      Dprintf3("DiskIOComplete: extracting pri %d req from queue at r %d c %d\n",req->priority,queue->row, queue->col);
      } else {
	      Dprintf1("DiskIOComplete: no more requests to extract.\n","");
      }
    }
    if (req) {
	queue->queueLength--;  /* decrement count of number of requests waiting in this queue */
	RF_ASSERT(queue->queueLength >= 0);
    }
    if (!req) done=1;
    else if (RF_LOCKING_REQ(req)) {
      if (RF_QUEUE_EMPTY(queue)) {                   					/* dispatch it */
	Dprintf3("DiskIOComplete: dispatching pri %d locking req to r %d c %d (queue empty)\n",req->priority,queue->row, queue->col);
	RF_LOCK_QUEUE(queue);
	rf_DispatchKernelIO(queue, req);
	done = 1;
      } else {                         		           /* put it aside to wait for the queue to drain */
	Dprintf3("DiskIOComplete: postponing pri %d locking req to r %d c %d\n",req->priority,queue->row, queue->col);
	RF_ASSERT(queue->nextLockingOp == NULL);
	queue->nextLockingOp = req;
	done = 1;
      }
    } else if (RF_UNLOCKING_REQ(req)) {      	/* should not happen: unlocking ops should not get queued */
      RF_ASSERT(RF_QUEUE_LOCKED(queue)); 			               /* support it anyway for the future */
      Dprintf3("DiskIOComplete: dispatching pri %d unl req to r %d c %d (SHOULD NOT SEE THIS)\n",req->priority,queue->row, queue->col);
      rf_DispatchKernelIO(queue, req);
      done = 1;
    } else if (RF_OK_TO_DISPATCH(queue, req)) {
      Dprintf3("DiskIOComplete: dispatching pri %d regular req to r %d c %d (ok to dispatch)\n",req->priority,queue->row, queue->col);
      rf_DispatchKernelIO(queue, req);
    } else {                                   		  /* we can't dispatch it, so just re-enqueue it.  */
      /* potential trouble here if disk queues batch reqs */
      Dprintf3("DiskIOComplete: re-enqueueing pri %d regular req to r %d c %d\n",req->priority,queue->row, queue->col);
      queue->queueLength++; 
      (queue->qPtr->Enqueue)(queue->qHdr, req, req->priority);
      done = 1;
    }
  }
  
  RF_UNLOCK_QUEUE_MUTEX( queue, "DiskIOComplete" );
a489 2
#endif /* !KERNEL */

d495 100
a594 106
int rf_DiskIOPromote(queue, parityStripeID, which_ru)
  RF_DiskQueue_t     *queue;
  RF_StripeNum_t      parityStripeID;
  RF_ReconUnitNum_t   which_ru;
{
  int retval;
  
  if (!queue->qPtr->Promote)
    return(-1);
  RF_LOCK_QUEUE_MUTEX( queue, "DiskIOPromote" );
  retval = (queue->qPtr->Promote)( queue->qHdr, parityStripeID, which_ru );
  RF_UNLOCK_QUEUE_MUTEX( queue, "DiskIOPromote" );
  return(retval);
}

RF_DiskQueueData_t *rf_CreateDiskQueueData(
  RF_IoType_t                typ,
  RF_SectorNum_t             ssect,
  RF_SectorCount_t           nsect,
  caddr_t                    buf,
  RF_StripeNum_t             parityStripeID,
  RF_ReconUnitNum_t          which_ru,
  int                      (*wakeF)(void *,int),
  void                      *arg,
  RF_DiskQueueData_t        *next,
  RF_AccTraceEntry_t        *tracerec,
  void                      *raidPtr,
  RF_DiskQueueDataFlags_t    flags,
  void                      *kb_proc)
{
  RF_DiskQueueData_t *p;

  RF_FREELIST_GET_INIT(rf_dqd_freelist,p,next,(RF_DiskQueueData_t *),init_dqd);

  p->sectorOffset  = ssect + rf_protectedSectors;
  p->numSector     = nsect;
  p->type          = typ;
  p->buf           = buf;
  p->parityStripeID= parityStripeID;
  p->which_ru      = which_ru;
  p->CompleteFunc  = wakeF;
  p->argument      = arg;
  p->next          = next;
  p->tracerec      = tracerec;
  p->priority      = RF_IO_NORMAL_PRIORITY;
  p->AuxFunc       = NULL;
  p->buf2          = NULL;
#ifdef SIMULATE
  p->owner         = rf_GetCurrentOwner();
#endif /* SIMULATE */
  p->raidPtr       = raidPtr;
  p->flags         = flags;
#ifdef KERNEL
  p->b_proc        = kb_proc;
#endif /* KERNEL */
  return(p);
}

RF_DiskQueueData_t *rf_CreateDiskQueueDataFull(
  RF_IoType_t                typ,
  RF_SectorNum_t             ssect,
  RF_SectorCount_t           nsect,
  caddr_t                    buf,
  RF_StripeNum_t             parityStripeID,
  RF_ReconUnitNum_t          which_ru,
  int                      (*wakeF)(void *,int),
  void                      *arg,
  RF_DiskQueueData_t        *next,
  RF_AccTraceEntry_t        *tracerec,
  int                        priority,
  int                      (*AuxFunc)(void *,...),
  caddr_t                    buf2,
  void                      *raidPtr,
  RF_DiskQueueDataFlags_t    flags,
  void                      *kb_proc)
{
  RF_DiskQueueData_t *p;

  RF_FREELIST_GET_INIT(rf_dqd_freelist,p,next,(RF_DiskQueueData_t *),init_dqd);

  p->sectorOffset  = ssect + rf_protectedSectors;
  p->numSector     = nsect;
  p->type          = typ;
  p->buf           = buf;
  p->parityStripeID= parityStripeID;
  p->which_ru      = which_ru;
  p->CompleteFunc  = wakeF;
  p->argument      = arg;
  p->next          = next;
  p->tracerec      = tracerec;
  p->priority      = priority;
  p->AuxFunc       = AuxFunc;
  p->buf2          = buf2;
#ifdef SIMULATE
  p->owner         = rf_GetCurrentOwner();
#endif /* SIMULATE */
  p->raidPtr       = raidPtr;
  p->flags         = flags;
#ifdef KERNEL
  p->b_proc        = kb_proc;
#endif /* KERNEL */
  return(p);
}

void rf_FreeDiskQueueData(p)
  RF_DiskQueueData_t  *p;
d596 1
a596 1
	RF_FREELIST_FREE_CLEAN(rf_dqd_freelist,p,next,clean_dqd);
@

