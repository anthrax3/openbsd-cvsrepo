head	1.9;
access;
symbols
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.34
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.32
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.28
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.30
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.26
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.24
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.22
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.20
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.18
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.16
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.14
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.12
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.10
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.6.0.8
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.8;

1.8
date	2011.06.21.16.46.00;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.08.16.07.41;	author peter;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.01.07.14.50.21;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.10.29.08.57.17;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.44;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.21;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.11;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.6.8.1
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_evenodd_dagfuncs.c,v 1.8 2011/06/21 16:46:00 tedu Exp $	*/
/*	$NetBSD: rf_evenodd_dagfuncs.c,v 1.6 2000/03/30 12:45:40 augustss Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: ChangMing Wu
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * Code for RAID-EVENODD architecture.
 */

#include "rf_types.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagffrd.h"
#include "rf_dagffwr.h"
#include "rf_dagdegrd.h"
#include "rf_dagdegwr.h"
#include "rf_dagutils.h"
#include "rf_dagfuncs.h"
#include "rf_etimer.h"
#include "rf_general.h"
#include "rf_configure.h"
#include "rf_parityscan.h"
#include "rf_evenodd.h"
#include "rf_evenodd_dagfuncs.h"

/* These redundant functions are for small write. */
RF_RedFuncs_t rf_EOSmallWritePFuncs = {
	rf_RegularXorFunc, "Regular Old-New P",
	rf_SimpleXorFunc, "Simple Old-New P"
};
RF_RedFuncs_t rf_EOSmallWriteEFuncs = {
	rf_RegularONEFunc, "Regular Old-New E",
	rf_SimpleONEFunc, "Regular Old-New E"
};
/* These redundant functions are for degraded read. */
RF_RedFuncs_t rf_eoPRecoveryFuncs = {
	rf_RecoveryXorFunc, "Recovery Xr",
	rf_RecoveryXorFunc, "Recovery Xr"
};
RF_RedFuncs_t rf_eoERecoveryFuncs = {
	rf_RecoveryEFunc, "Recovery E Func",
	rf_RecoveryEFunc, "Recovery E Func"
};


/*****************************************************************************
 *   The following encoding node functions is used in
 *   EO_000_CreateLargeWriteDAG.
 *****************************************************************************/
int
rf_RegularPEFunc(RF_DagNode_t *node)
{
	rf_RegularESubroutine(node, node->results[1]);
	rf_RegularXorFunc(node);	/* Do the wakeup here ! */
#if 1
	return (0);		/* XXX This was missing... GO */
#endif
}


/*****************************************************************************
 *  For EO_001_CreateSmallWriteDAG, there are (i) RegularONEFunc() and
 *  (ii) SimpleONEFunc() to be used. The previous case is when write accesses
 *  at least sectors of full stripe unit.
 *  The later function is used when the write accesses two stripe units but
 *  with total sectors less than sectors per SU. In this case, the access of
 *  parity and 'E' are shown as disconnected areas in their stripe unit and
 *  parity write and 'E' write are both divided into two distinct writes
 *  (totally four). This simple old-new write and regular old-new write happen
 *  as in RAID-5.
 *****************************************************************************/

/*
 * Algorithm:
 *   1. Store the difference of old data and new data in the Rod buffer.
 *   2. Then encode this buffer into the buffer that already have old 'E'
 *	information inside it, the result can be shown to be the new 'E'
 *	information.
 *   3. Xor the Wnd buffer into the difference buffer to recover the original
 *	old data.
 * Here we have another alternative: to allocate a temporary buffer for
 * storing the difference of old data and new data, then encode temp buf
 * into old 'E' buf to form new 'E', but this approach takes the same speed
 * as the previous, and needs more memory.
 */
int
rf_RegularONEFunc(RF_DagNode_t *node)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;
	int EpdaIndex = (node->numParams - 1) / 2 - 1;	/*
							 * The parameter of node
							 * where you can find
							 * e-pda.
							 */
	int i, k, retcode = 0;
	int suoffset, length;
	RF_RowCol_t scol;
	char *srcbuf, *destbuf;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;
	RF_PhysDiskAddr_t *pda, *EPDA = (RF_PhysDiskAddr_t *)
	    node->params[EpdaIndex].p;
	/* Generally zero. */
	int ESUOffset = rf_StripeUnitOffset(layoutPtr, EPDA->startSector);

	RF_ASSERT(EPDA->type == RF_PDA_TYPE_Q);
	RF_ASSERT(ESUOffset == 0);

	RF_ETIMER_START(timer);

	/*
	 * Xor the Wnd buffer into Rod buffer. The difference of old data and
	 * new data is stored in Rod buffer.
	 */
	for (k = 0; k < EpdaIndex; k += 2) {
		length = rf_RaidAddressToByte(raidPtr,
		    ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);
		retcode = rf_bxor(node->params[k + EpdaIndex + 3].p,
		    node->params[k + 1].p, length, node->dagHdr->bp);
	}
	/*
	 * Start to encode the buffer, storing the difference of old data and
	 * new data into 'E' buffer.
	 */
	for (i = 0; i < EpdaIndex; i += 2)
		if (node->params[i + 1].p != node->results[0]) {
			/* results[0] is buf ptr of E. */
			pda = (RF_PhysDiskAddr_t *) node->params[i].p;
			srcbuf = (char *) node->params[i + 1].p;
			scol = rf_EUCol(layoutPtr, pda->raidAddress);
			suoffset = rf_StripeUnitOffset(layoutPtr,
			    pda->startSector);
			destbuf = ((char *) node->results[0]) +
			    rf_RaidAddressToByte(raidPtr, suoffset);
			rf_e_encToBuf(raidPtr, scol, srcbuf,
			    RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);
		}
	/*
	 * Recover the original old data to be used by parity encoding
	 * function in XorNode.
	 */
	for (k = 0; k < EpdaIndex; k += 2) {
		length = rf_RaidAddressToByte(raidPtr,
		    ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);
		retcode = rf_bxor(node->params[k + EpdaIndex + 3].p,
		    node->params[k + 1].p, length, node->dagHdr->bp);
	}
	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->q_us += RF_ETIMER_VAL_US(timer);
	rf_GenericWakeupFunc(node, 0);
#if 1
	return (0);		/* XXX This was missing... GO */
#endif
}

int
rf_SimpleONEFunc(RF_DagNode_t *node)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;
	RF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;
	int retcode = 0;
	char *srcbuf, *destbuf;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	int length;
	RF_RowCol_t scol;
	RF_Etimer_t timer;

	RF_ASSERT(((RF_PhysDiskAddr_t *) node->params[2].p)->type ==
	    RF_PDA_TYPE_Q);
	if (node->dagHdr->status == rf_enable) {
		RF_ETIMER_START(timer);
		/* This is a pda of writeDataNodes. */
		length = rf_RaidAddressToByte(raidPtr,
		    ((RF_PhysDiskAddr_t *) node->params[4].p)->numSector);
		/* bxor to buffer of readDataNodes. */
		retcode = rf_bxor(node->params[5].p, node->params[1].p,
		    length, node->dagHdr->bp);
		/*
		 * Find out the corresponding column in encoding matrix for
		 * write column to be encoded into redundant disk 'E'.
		 */
		scol = rf_EUCol(layoutPtr, pda->raidAddress);
		srcbuf = node->params[1].p;
		destbuf = node->params[3].p;
		/* Start encoding process. */
		rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2,
		    destbuf, pda->numSector);
		rf_bxor(node->params[5].p, node->params[1].p, length,
		    node->dagHdr->bp);
		RF_ETIMER_STOP(timer);
		RF_ETIMER_EVAL(timer);
		tracerec->q_us += RF_ETIMER_VAL_US(timer);

	}
	return (rf_GenericWakeupFunc(node, retcode));	/*
							 * Call wake func
							 * explicitly since no
							 * I/O in this node.
							 */
}


/*
 * Called by rf_RegularPEFunc(node) and rf_RegularEFunc(node)
 * in f.f. large write.
 */
void
rf_RegularESubroutine(RF_DagNode_t *node, char *ebuf)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;
	RF_PhysDiskAddr_t *pda;
	int i, suoffset;
	RF_RowCol_t scol;
	char *srcbuf, *destbuf;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;

	RF_ETIMER_START(timer);
	for (i = 0; i < node->numParams - 2; i += 2) {
		RF_ASSERT(node->params[i + 1].p != ebuf);
		pda = (RF_PhysDiskAddr_t *) node->params[i].p;
		suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
		scol = rf_EUCol(layoutPtr, pda->raidAddress);
		srcbuf = (char *) node->params[i + 1].p;
		destbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset);
		rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2,
		    destbuf, pda->numSector);
	}
	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->xor_us += RF_ETIMER_VAL_US(timer);
}


/*****************************************************************************
 *			 Used in  EO_001_CreateLargeWriteDAG.
 *****************************************************************************/
int
rf_RegularEFunc(RF_DagNode_t *node)
{
	rf_RegularESubroutine(node, node->results[0]);
	rf_GenericWakeupFunc(node, 0);
#if 1
	return (0);		/* XXX This was missing... GO */
#endif
}


/*****************************************************************************
 * This degraded function allow only two cases:
 *   1. When write accesses the full failed stripe unit, then the access can
 *	be more than one stripe unit.
 *   2. When write accesses only part of the failed SU, we assume accesses of
 *	more than one stripe unit are not allowed so that the write can be
 *	dealt with like a large write.
 * The following function is based on these assumptions. So except in the
 * second case, it looks the same as a large write encoding function. But
 * this is not exactly the normal way of doing a degraded write, since
 * RAIDframe has to break cases of accesses other than the above two into
 * smaller accesses. We may have to change DegrESubroutin in the future.
 *****************************************************************************/
void
rf_DegrESubroutine(RF_DagNode_t *node, char *ebuf)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;
	RF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;
	RF_PhysDiskAddr_t *pda;
	int i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	RF_RowCol_t scol;
	char *srcbuf, *destbuf;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;

	RF_ETIMER_START(timer);
	for (i = 0; i < node->numParams - 2; i += 2) {
		RF_ASSERT(node->params[i + 1].p != ebuf);
		pda = (RF_PhysDiskAddr_t *) node->params[i].p;
		suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
		scol = rf_EUCol(layoutPtr, pda->raidAddress);
		srcbuf = (char *) node->params[i + 1].p;
		destbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);
		rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);
	}

	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->q_us += RF_ETIMER_VAL_US(timer);
}


/*****************************************************************************
 * This function is used in case where one data disk failed and both redundant
 * disks are alive. It is used in the EO_100_CreateWriteDAG. Note: if there is
 * another disk failed in the stripe but not accessed at this time, then we
 * should, instead, use the rf_EOWriteDoubleRecoveryFunc().
 *****************************************************************************/
int
rf_Degraded_100_EOFunc(RF_DagNode_t *node)
{
	rf_DegrESubroutine(node, node->results[1]);
	rf_RecoveryXorFunc(node);	/* Does the wakeup here ! */
#if 1
	return (0);		/* XXX This was missing... Should these be
				 * void functions ??? GO */
#endif
}


/*****************************************************************************
 * This function is to encode one sector in one of the data disks to the E
 * disk. However, in evenodd this function can also be used as decoding
 * function to recover data from dead disk in the case of parity failure and
 * a single data failure.
 *****************************************************************************/
void
rf_e_EncOneSect(RF_RowCol_t srcLogicCol, char *srcSecbuf,
    RF_RowCol_t destLogicCol, char *destSecbuf, int bytesPerSector)
{
	int S_index;		/*
				 * Index of the EU in the src col which need
				 * be Xored into all EUs in a dest sector.
				 */
	int numRowInEncMatrix = (RF_EO_MATRIX_DIM) - 1;
	RF_RowCol_t j, indexInDest;	/*
					 * Row index of an encoding unit in
					 * the destination column of encoding
					 * matrix.
					 */
	RF_RowCol_t indexInSrc;	/*
				 * Row index of an encoding unit in the source
				 * column used for recovery.
				 */
	int bytesPerEU = bytesPerSector / numRowInEncMatrix;

#if	RF_EO_MATRIX_DIM > 17
	int shortsPerEU = bytesPerEU / sizeof(short);
	short  *destShortBuf, *srcShortBuf1, *srcShortBuf2;
	short temp1;
#elif	RF_EO_MATRIX_DIM == 17
	int longsPerEU = bytesPerEU / sizeof(long);
	long *destLongBuf, *srcLongBuf1, *srcLongBuf2;
	long temp1;
#endif

#if	RF_EO_MATRIX_DIM > 17
	RF_ASSERT(sizeof(short) == 2 || sizeof(short) == 1);
	RF_ASSERT(bytesPerEU % sizeof(short) == 0);
#elif	RF_EO_MATRIX_DIM == 17
	RF_ASSERT(sizeof(long) == 8 || sizeof(long) == 4);
	RF_ASSERT(bytesPerEU % sizeof(long) == 0);
#endif

	S_index = rf_EO_Mod((RF_EO_MATRIX_DIM - 1 + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);
#if	RF_EO_MATRIX_DIM > 17
	srcShortBuf1 = (short *) (srcSecbuf + S_index * bytesPerEU);
#elif	RF_EO_MATRIX_DIM == 17
	srcLongBuf1 = (long *) (srcSecbuf + S_index * bytesPerEU);
#endif

	for (indexInDest = 0; indexInDest < numRowInEncMatrix; indexInDest++) {
		indexInSrc = rf_EO_Mod((indexInDest + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);

#if	RF_EO_MATRIX_DIM > 17
		destShortBuf = (short *) (destSecbuf + indexInDest * bytesPerEU);
		srcShortBuf2 = (short *) (srcSecbuf + indexInSrc * bytesPerEU);
		for (j = 0; j < shortsPerEU; j++) {
			temp1 = destShortBuf[j] ^ srcShortBuf1[j];
			/* Note: S_index won't be at the end row for any src
			 * col ! */
			if (indexInSrc != RF_EO_MATRIX_DIM - 1)
				destShortBuf[j] = (srcShortBuf2[j]) ^ temp1;
			/* if indexInSrc is at the end row, ie.
			 * RF_EO_MATRIX_DIM -1, then all elements are zero ! */
			else
				destShortBuf[j] = temp1;
		}

#elif	RF_EO_MATRIX_DIM == 17
		destLongBuf = (long *) (destSecbuf + indexInDest * bytesPerEU);
		srcLongBuf2 = (long *) (srcSecbuf + indexInSrc * bytesPerEU);
		for (j = 0; j < longsPerEU; j++) {
			temp1 = destLongBuf[j] ^ srcLongBuf1[j];
			if (indexInSrc != RF_EO_MATRIX_DIM - 1)
				destLongBuf[j] = (srcLongBuf2[j]) ^ temp1;
			else
				destLongBuf[j] = temp1;
		}
#endif
	}
}

void
rf_e_encToBuf(RF_Raid_t *raidPtr, RF_RowCol_t srcLogicCol, char *srcbuf,
    RF_RowCol_t destLogicCol, char *destbuf, int numSector)
{
	int i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);

	for (i = 0; i < numSector; i++) {
		rf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);
		srcbuf += bytesPerSector;
		destbuf += bytesPerSector;
	}
}


/*****************************************************************************
 * when parity die and one data die, We use second redundant information, 'E',
 * to recover the data in dead disk. This function is used in the recovery node of
 * for EO_110_CreateReadDAG
 *****************************************************************************/
int
rf_RecoveryEFunc(RF_DagNode_t *node)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;
	RF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;
	RF_RowCol_t scol;	/* source logical column */
	RF_RowCol_t fcol = rf_EUCol(layoutPtr, failedPDA->raidAddress);	/* logical column of
									 * failed SU */
	int i;
	RF_PhysDiskAddr_t *pda;
	int suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char *srcbuf, *destbuf;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;

	bzero(node->results[0], rf_RaidAddressToByte(raidPtr, failedPDA->numSector));
	if (node->dagHdr->status == rf_enable) {
		RF_ETIMER_START(timer);
		for (i = 0; i < node->numParams - 2; i += 2)
			if (node->params[i + 1].p != node->results[0]) {
				pda = (RF_PhysDiskAddr_t *) node->params[i].p;
				if (i == node->numParams - 4)
					scol = RF_EO_MATRIX_DIM - 2;	/* the colume of
									 * redundant E */
				else
					scol = rf_EUCol(layoutPtr, pda->raidAddress);
				srcbuf = (char *) node->params[i + 1].p;
				suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
				destbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);
				rf_e_encToBuf(raidPtr, scol, srcbuf, fcol, destbuf, pda->numSector);
			}
		RF_ETIMER_STOP(timer);
		RF_ETIMER_EVAL(timer);
		tracerec->xor_us += RF_ETIMER_VAL_US(timer);
	}
	return (rf_GenericWakeupFunc(node, 0));	/* node execute successfully */
}


/*****************************************************************************
 * This function is used in the case where one data and the parity have filed.
 * (in EO_110_CreateWriteDAG)
 *****************************************************************************/
int
rf_EO_DegradedWriteEFunc(RF_DagNode_t *node)
{
	rf_DegrESubroutine(node, node->results[0]);
	rf_GenericWakeupFunc(node, 0);
#if 1
	return (0);		/* XXX Yet another one !!! GO */
#endif
}



/*****************************************************************************
 *	THE FUNCTION IS FOR DOUBLE DEGRADED READ AND WRITE CASES.
 *****************************************************************************/

void
rf_doubleEOdecode(RF_Raid_t *raidPtr, char **rrdbuf, char **dest,
    RF_RowCol_t *fcol, char *pbuf, char *ebuf)
{
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &(raidPtr->Layout);
	int i, j, k, f1, f2, row;
	int rrdrow, erow, count = 0;
	int bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
	int numRowInEncMatrix = (RF_EO_MATRIX_DIM) - 1;
#if 0
	int pcol = (RF_EO_MATRIX_DIM) - 1;
#endif
	int ecol = (RF_EO_MATRIX_DIM) - 2;
	int bytesPerEU = bytesPerSector / numRowInEncMatrix;
	int numDataCol = layoutPtr->numDataCol;
#if	RF_EO_MATRIX_DIM > 17
	int shortsPerEU = bytesPerEU / sizeof(short);
	short *rrdbuf_current, *pbuf_current, *ebuf_current;
	short *dest_smaller, *dest_smaller_current;
	short *dest_larger, *dest_larger_current;
	short *temp;
	short *P;

	RF_ASSERT(bytesPerEU % sizeof(short) == 0);
	RF_Malloc(P, bytesPerEU, (short *));
	RF_Malloc(temp, bytesPerEU, (short *));
#elif	RF_EO_MATRIX_DIM == 17
	int longsPerEU = bytesPerEU / sizeof(long);
	long *rrdbuf_current, *pbuf_current, *ebuf_current;
	long *dest_smaller, *dest_smaller_current;
	long *dest_larger, *dest_larger_current;
	long *temp;
	long *P;

	RF_ASSERT(bytesPerEU % sizeof(long) == 0);
	RF_Malloc(P, bytesPerEU, (long *));
	RF_Malloc(temp, bytesPerEU, (long *));
#endif
	RF_ASSERT(*((long *) dest[0]) == 0);
	RF_ASSERT(*((long *) dest[1]) == 0);
	bzero(P, bytesPerEU);
	bzero(temp, bytesPerEU);
	RF_ASSERT(*P == 0);
	/*
	 * Calculate the 'P' parameter, which, not parity, is the Xor of all
	 * elements in the last two column, ie. 'E' and 'parity' columns, see
	 * the Ref. paper by Blaum, et al 1993.
	 */
	for (i = 0; i < numRowInEncMatrix; i++)
		for (k = 0; k < longsPerEU; k++) {
#if	RF_EO_MATRIX_DIM > 17
			ebuf_current = ((short *) ebuf) + i * shortsPerEU + k;
			pbuf_current = ((short *) pbuf) + i * shortsPerEU + k;
#elif	RF_EO_MATRIX_DIM == 17
			ebuf_current = ((long *) ebuf) + i * longsPerEU + k;
			pbuf_current = ((long *) pbuf) + i * longsPerEU + k;
#endif
			P[k] ^= *ebuf_current;
			P[k] ^= *pbuf_current;
		}
	RF_ASSERT(fcol[0] != fcol[1]);
	if (fcol[0] < fcol[1]) {
#if	RF_EO_MATRIX_DIM > 17
		dest_smaller = (short *) (dest[0]);
		dest_larger = (short *) (dest[1]);
#elif	RF_EO_MATRIX_DIM == 17
		dest_smaller = (long *) (dest[0]);
		dest_larger = (long *) (dest[1]);
#endif
		f1 = fcol[0];
		f2 = fcol[1];
	} else {
#if	RF_EO_MATRIX_DIM > 17
		dest_smaller = (short *) (dest[1]);
		dest_larger = (short *) (dest[0]);
#elif	RF_EO_MATRIX_DIM == 17
		dest_smaller = (long *) (dest[1]);
		dest_larger = (long *) (dest[0]);
#endif
		f1 = fcol[1];
		f2 = fcol[0];
	}
	row = (RF_EO_MATRIX_DIM) - 1;
	while ((row = rf_EO_Mod((row + f1 - f2), RF_EO_MATRIX_DIM)) !=
	    ((RF_EO_MATRIX_DIM) - 1)) {
#if	RF_EO_MATRIX_DIM > 17
		dest_larger_current = dest_larger + row * shortsPerEU;
		dest_smaller_current = dest_smaller + row * shortsPerEU;
#elif	RF_EO_MATRIX_DIM == 17
		dest_larger_current = dest_larger + row * longsPerEU;
		dest_smaller_current = dest_smaller + row * longsPerEU;
#endif
		/*
		 * Do the diagonal recovery. Initially, temp[k] = (failed 1),
		 * which is the failed data in the column that has smaller
		 * col index.
		 */
		/* Step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3)) */
		for (j = 0; j < numDataCol; j++) {
			if (j == f1 || j == f2)
				continue;
			rrdrow = rf_EO_Mod((row + f2 - j), RF_EO_MATRIX_DIM);
			if (rrdrow != (RF_EO_MATRIX_DIM) - 1) {
#if	RF_EO_MATRIX_DIM > 17
				rrdbuf_current = (short *) (rrdbuf[j]) +
				    rrdrow * shortsPerEU;
				for (k = 0; k < shortsPerEU; k++)
					temp[k] ^= *(rrdbuf_current + k);
#elif	RF_EO_MATRIX_DIM == 17
				rrdbuf_current = (long *) (rrdbuf[j]) +
				    rrdrow * longsPerEU;
				for (k = 0; k < longsPerEU; k++)
					temp[k] ^= *(rrdbuf_current + k);
#endif
			}
		}
		/*
		 * Step 2:  ^E(erow,m-2), If erow is at the bottom row, don't
		 * Xor into it.  E(erow,m-2) = (principle diagonal) ^ (failed
		 * 1) ^ (failed 2) ^ (SUM of nonfailed in-diagonal
		 * A(rrdrow,0..m-3))
		 * After this step, temp[k] = (principle diagonal) ^ (failed 2).
		 */

		erow = rf_EO_Mod((row + f2 - ecol), (RF_EO_MATRIX_DIM));
		if (erow != (RF_EO_MATRIX_DIM) - 1) {
#if	RF_EO_MATRIX_DIM > 17
			ebuf_current = (short *) ebuf + shortsPerEU * erow;
			for (k = 0; k < shortsPerEU; k++)
				temp[k] ^= *(ebuf_current + k);
#elif	RF_EO_MATRIX_DIM == 17
			ebuf_current = (long *) ebuf + longsPerEU * erow;
			for (k = 0; k < longsPerEU; k++)
				temp[k] ^= *(ebuf_current + k);
#endif
		}
		/*
		 * Step 3: ^P to obtain the failed data (failed 2). P can be
		 * proved to be actually (principal diagonal). After this
		 * step, temp[k] = (failed 2), the failed data to be recovered.
		 */
#if	RF_EO_MATRIX_DIM > 17
		for (k = 0; k < shortsPerEU; k++)
			temp[k] ^= P[k];
		/* Put the data into the destination buffer. */
		for (k = 0; k < shortsPerEU; k++)
			dest_larger_current[k] = temp[k];
#elif	RF_EO_MATRIX_DIM == 17
		for (k = 0; k < longsPerEU; k++)
			temp[k] ^= P[k];
		/* Put the data into the destination buffer. */
		for (k = 0; k < longsPerEU; k++)
			dest_larger_current[k] = temp[k];
#endif

		/* THE FOLLOWING DO THE HORIZONTAL XOR. */
		/*
		 * Step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data
		 * columns.
		 */
		for (j = 0; j < numDataCol; j++) {
			if (j == f1 || j == f2)
				continue;
#if	RF_EO_MATRIX_DIM > 17
			rrdbuf_current = (short *) (rrdbuf[j]) +
			    row * shortsPerEU;
			for (k = 0; k < shortsPerEU; k++)
				temp[k] ^= *(rrdbuf_current + k);
#elif	RF_EO_MATRIX_DIM == 17
			rrdbuf_current = (long *) (rrdbuf[j]) +
			    row * longsPerEU;
			for (k = 0; k < longsPerEU; k++)
				temp[k] ^= *(rrdbuf_current + k);
#endif
		}
		/* Step 2: ^A(row,m-1) */
		/* Step 3: Put the data into the destination buffer. */
#if	RF_EO_MATRIX_DIM > 17
		pbuf_current = (short *) pbuf + shortsPerEU * row;
		for (k = 0; k < shortsPerEU; k++)
			temp[k] ^= *(pbuf_current + k);
		for (k = 0; k < shortsPerEU; k++)
			dest_smaller_current[k] = temp[k];
#elif	RF_EO_MATRIX_DIM == 17
		pbuf_current = (long *) pbuf + longsPerEU * row;
		for (k = 0; k < longsPerEU; k++)
			temp[k] ^= *(pbuf_current + k);
		for (k = 0; k < longsPerEU; k++)
			dest_smaller_current[k] = temp[k];
#endif
		count++;
	}
	/*
	 * Check if all Encoding Unit in the data buffer have been decoded ?
	 * According to EvenOdd theory, if "RF_EO_MATRIX_DIM" is a prime
	 * number, this algorithm will covered all buffer.
	 */
	RF_ASSERT(count == numRowInEncMatrix);
	RF_Free((char *) P, bytesPerEU);
	RF_Free((char *) temp, bytesPerEU);
}


/*****************************************************************************
 *	This function is called by double degraded read EO_200_CreateReadDAG.
 *****************************************************************************/
int
rf_EvenOddDoubleRecoveryFunc(RF_DagNode_t *node)
{
	int ndataParam = 0;
	int np = node->numParams;
	RF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *)
	    node->params[np - 1].p;
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 2].p;
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);
	int i, prm, sector, nresults = node->numResults;
	RF_SectorCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;
	unsigned sosAddr;
	int two = 0, mallc_one = 0, mallc_two = 0;	/*
							 * Flags to indicate if
							 * memory is allocated.
							 */
	int bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
	RF_PhysDiskAddr_t *ppda, *ppda2, *epda, *epda2, *pda, *pda0, *pda1,
	    npda;
	RF_RowCol_t fcol[2], fsuoff[2], fsuend[2],
	    numDataCol = layoutPtr->numDataCol;
	char **buf, *ebuf, *pbuf, *dest[2];
	long *suoff = NULL, *suend = NULL, *prmToCol = NULL, psuoff, esuoff;
	RF_SectorNum_t startSector, endSector;
	RF_Etimer_t timer;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;

	RF_ETIMER_START(timer);

	/*
	 * Find out the number of parameters that are pdas for data
	 * information.
	 */
	for (i = 0; i <= np; i++)
		if (((RF_PhysDiskAddr_t *) node->params[i].p)->type !=
		    RF_PDA_TYPE_DATA) {
			ndataParam = i;
			break;
		}
	RF_Malloc(buf, numDataCol * sizeof(char *), (char **));
	if (ndataParam != 0) {
		RF_Malloc(suoff, ndataParam * sizeof(long), (long *));
		RF_Malloc(suend, ndataParam * sizeof(long), (long *));
		RF_Malloc(prmToCol, ndataParam * sizeof(long), (long *));
	}
	if (asmap->failedPDAs[1] &&
	    (asmap->failedPDAs[1]->numSector +
	     asmap->failedPDAs[0]->numSector) < secPerSU) {
		RF_ASSERT(0);	/* Currently, no support for this situation. */
		ppda = node->params[np - 6].p;
		ppda2 = node->params[np - 5].p;
		RF_ASSERT(ppda2->type == RF_PDA_TYPE_PARITY);
		epda = node->params[np - 4].p;
		epda2 = node->params[np - 3].p;
		RF_ASSERT(epda2->type == RF_PDA_TYPE_Q);
		two = 1;
	} else {
		ppda = node->params[np - 4].p;
		epda = node->params[np - 3].p;
		psuoff = rf_StripeUnitOffset(layoutPtr, ppda->startSector);
		esuoff = rf_StripeUnitOffset(layoutPtr, epda->startSector);
		RF_ASSERT(psuoff == esuoff);
	}
	/*
	 * The followings have three goals:
	 *   1. Determine the startSector to begin decoding and endSector
	 *	to end decoding.
	 *   2. Determine the column numbers of the two failed disks.
	 *   3. Determine the offset and end offset of the access within
	 *	each failed stripe unit.
	 */
	if (nresults == 1) {
		/* Find the startSector to begin decoding. */
		pda = node->results[0];
		bzero(pda->bufPtr, bytesPerSector * pda->numSector);
		fsuoff[0] = rf_StripeUnitOffset(layoutPtr, pda->startSector);
		fsuend[0] = fsuoff[0] + pda->numSector;
		startSector = fsuoff[0];
		endSector = fsuend[0];

		/* Find out the column of failed disk being accessed. */
		fcol[0] = rf_EUCol(layoutPtr, pda->raidAddress);

		/* Find out the other failed column not accessed. */
		sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
		    asmap->raidAddress);
		for (i = 0; i < numDataCol; i++) {
			npda.raidAddress = sosAddr + (i * secPerSU);
			(raidPtr->Layout.map->MapSector) (raidPtr,
			    npda.raidAddress, &(npda.row), &(npda.col),
			    &(npda.startSector), 0);
			/* Skip over dead disks. */
			if (RF_DEAD_DISK(raidPtr
			    ->Disks[npda.row][npda.col].status))
				if (i != fcol[0])
					break;
		}
		RF_ASSERT(i < numDataCol);
		fcol[1] = i;
	} else {
		RF_ASSERT(nresults == 2);
		pda0 = node->results[0];
		bzero(pda0->bufPtr, bytesPerSector * pda0->numSector);
		pda1 = node->results[1];
		bzero(pda1->bufPtr, bytesPerSector * pda1->numSector);
		/*
		 * Determine the failed column numbers of the two failed
		 * disks.
		 */
		fcol[0] = rf_EUCol(layoutPtr, pda0->raidAddress);
		fcol[1] = rf_EUCol(layoutPtr, pda1->raidAddress);
		/*
		 * Determine the offset and end offset of the access within
		 * each failed stripe unit.
		 */
		fsuoff[0] = rf_StripeUnitOffset(layoutPtr, pda0->startSector);
		fsuend[0] = fsuoff[0] + pda0->numSector;
		fsuoff[1] = rf_StripeUnitOffset(layoutPtr, pda1->startSector);
		fsuend[1] = fsuoff[1] + pda1->numSector;
		/* Determine the startSector to begin decoding. */
		startSector = RF_MIN(pda0->startSector, pda1->startSector);
		/* Determine the endSector to end decoding. */
		endSector = RF_MAX(fsuend[0], fsuend[1]);
	}
	/*
	 * Assign the beginning sector and the end sector for each parameter.
	 * Find out the corresponding column # for each parameter.
	 */
	for (prm = 0; prm < ndataParam; prm++) {
		pda = node->params[prm].p;
		suoff[prm] = rf_StripeUnitOffset(layoutPtr, pda->startSector);
		suend[prm] = suoff[prm] + pda->numSector;
		prmToCol[prm] = rf_EUCol(layoutPtr, pda->raidAddress);
	}
	/*
	 * 'sector' is the sector for the current decoding algorithm. For each
	 * sector in the failed SU
	 * 1. Find out the corresponding parameters that cover the current
	 *    sector and that are needed for the decoding of this sector in
	 *    failed SU.
	 * 2. Find out if sector is in the shadow of any accessed failed SU.
	 *    If not, malloc a temporary space of a sector in size.
	 */
	for (sector = startSector; sector < endSector; sector++) {
		if (nresults == 2)
			if (!(fsuoff[0] <= sector && sector < fsuend[0]) &&
			    !(fsuoff[1] <= sector && sector < fsuend[1]))
				continue;
		for (prm = 0; prm < ndataParam; prm++)
			if (suoff[prm] <= sector && sector < suend[prm])
				buf[(prmToCol[prm])] = ((RF_PhysDiskAddr_t *)
				    node->params[prm].p)->bufPtr +
				    rf_RaidAddressToByte(raidPtr,
				     sector - suoff[prm]);
		/*
		 * Find out if sector is in the shadow of any accessed failed
		 * SU. If yes, assign dest[0], dest[1] to point at suitable
		 * position of the buffer corresponding to failed SUs. If no,
		 * malloc a temporary space of a sector in size for
		 * destination of decoding.
		 */
		RF_ASSERT(nresults == 1 || nresults == 2);
		if (nresults == 1) {
			dest[0] = ((RF_PhysDiskAddr_t *)
			    node->results[0])->bufPtr +
			    rf_RaidAddressToByte(raidPtr, sector - fsuoff[0]);
			/* Always malloc temp buffer to dest[1]. */
			RF_Malloc(dest[1], bytesPerSector, (char *));
			bzero(dest[1], bytesPerSector);
			mallc_two = 1;
		} else {
			if (fsuoff[0] <= sector && sector < fsuend[0])
				dest[0] = ((RF_PhysDiskAddr_t *)
				    node->results[0])->bufPtr +
				    rf_RaidAddressToByte(raidPtr,
				     sector - fsuoff[0]);
			else {
				RF_Malloc(dest[0], bytesPerSector, (char *));
				bzero(dest[0], bytesPerSector);
				mallc_one = 1;
			}
			if (fsuoff[1] <= sector && sector < fsuend[1])
				dest[1] = ((RF_PhysDiskAddr_t *)
				    node->results[1])->bufPtr +
				    rf_RaidAddressToByte(raidPtr,
				     sector - fsuoff[1]);
			else {
				RF_Malloc(dest[1], bytesPerSector, (char *));
				bzero(dest[1], bytesPerSector);
				mallc_two = 1;
			}
			RF_ASSERT(mallc_one == 0 || mallc_two == 0);
		}
		pbuf = ppda->bufPtr + rf_RaidAddressToByte(raidPtr,
		    sector - psuoff);
		ebuf = epda->bufPtr + rf_RaidAddressToByte(raidPtr,
		    sector - esuoff);
		/*
		 * After finish finding all needed sectors, call doubleEOdecode
		 * function for decoding one sector to destination.
		 */
		rf_doubleEOdecode(raidPtr, buf, dest, fcol, pbuf, ebuf);
		/*
		 * Free all allocated memory, and mark flag to indicate no
		 * memory is being allocated.
		 */
		if (mallc_one == 1)
			RF_Free(dest[0], bytesPerSector);
		if (mallc_two == 1)
			RF_Free(dest[1], bytesPerSector);
		mallc_one = mallc_two = 0;
	}
	RF_Free(buf, numDataCol * sizeof(char *));
	if (ndataParam != 0) {
		RF_Free(suoff, ndataParam * sizeof(long));
		RF_Free(suend, ndataParam * sizeof(long));
		RF_Free(prmToCol, ndataParam * sizeof(long));
	}
	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	if (tracerec) {
		tracerec->q_us += RF_ETIMER_VAL_US(timer);
	}
	rf_GenericWakeupFunc(node, 0);
#if 1
	return (0);		/* XXX Is this even close !!?!?!!? GO */
#endif
}


/*
 * Currently, only access of one of the two failed SU is allowed in this
 * function. Also, asmap->numStripeUnitsAccessed is limited to be one,
 * the RAIDframe will break large access into many accesses of single
 * stripe unit.
 */

int
rf_EOWriteDoubleRecoveryFunc(RF_DagNode_t *node)
{
	int np = node->numParams;
	RF_AccessStripeMap_t *asmap =
	    (RF_AccessStripeMap_t *) node->params[np - 1].p;
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 2].p;
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &(raidPtr->Layout);
	RF_SectorNum_t sector;
	RF_RowCol_t col, scol;
	int prm, i, j;
	RF_SectorCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;
	unsigned sosAddr;
	unsigned bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
	RF_int64 numbytes;
	RF_SectorNum_t startSector, endSector;
	RF_PhysDiskAddr_t *ppda, *epda, *pda, *fpda, npda;
	RF_RowCol_t fcol[2], numDataCol = layoutPtr->numDataCol;
	char **buf;		/*
				 * buf[0], buf[1], buf[2], ... etc, point to
				 * buffer storing data read from col0, col1,
				 * col2.
				 */
	char *ebuf, *pbuf, *dest[2], *olddata[2];
	RF_Etimer_t timer;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;

	RF_ASSERT(asmap->numDataFailed == 1);	/*
						 * Currently only support this
						 * case, the other failed SU
						 * is not being accessed.
						 */
	RF_ETIMER_START(timer);
	RF_Malloc(buf, numDataCol * sizeof(char *), (char **));

	ppda = node->results[0];	/*
					 * Instead of being buffers,
					 * node->results[0] and [1]
					 * are Ppda and Epda.
					 */
	epda = node->results[1];
	fpda = asmap->failedPDAs[0];

	/* First, recovery the failed old SU using EvenOdd double decoding. */
	/* Determine the startSector and endSector for decoding. */
	startSector = rf_StripeUnitOffset(layoutPtr, fpda->startSector);
	endSector = startSector + fpda->numSector;
	/*
	 * Assign buf[col] pointers to point to each non-failed column and
	 * initialize the pbuf and ebuf to point at the beginning of each
	 * source buffers and destination buffers. */
	for (prm = 0; prm < numDataCol - 2; prm++) {
		pda = (RF_PhysDiskAddr_t *) node->params[prm].p;
		col = rf_EUCol(layoutPtr, pda->raidAddress);
		buf[col] = pda->bufPtr;
	}
	/*
	 * pbuf and ebuf: They will change values as double recovery decoding
	 * goes on.
	 */
	pbuf = ppda->bufPtr;
	ebuf = epda->bufPtr;
	/*
	 * Find out the logical column numbers in the encoding matrix of the
	 * two failed columns.
	 */
	fcol[0] = rf_EUCol(layoutPtr, fpda->raidAddress);

	/* Find out the other failed column not accessed this time. */
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
	    asmap->raidAddress);
	for (i = 0; i < numDataCol; i++) {
		npda.raidAddress = sosAddr + (i * secPerSU);
		(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress,
		    &(npda.row), &(npda.col), &(npda.startSector), 0);
		/* Skip over dead disks. */
		if (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))
			if (i != fcol[0])
				break;
	}
	RF_ASSERT(i < numDataCol);
	fcol[1] = i;
	/* Assign temporary space to put recovered failed SU. */
	numbytes = fpda->numSector * bytesPerSector;
	RF_Malloc(olddata[0], numbytes, (char *));
	RF_Malloc(olddata[1], numbytes, (char *));
	dest[0] = olddata[0];
	dest[1] = olddata[1];
	bzero(olddata[0], numbytes);
	bzero(olddata[1], numbytes);
	/*
	 * Begin the recovery decoding, initially buf[j], ebuf, pbuf, dest[j]
	 * have already pointed at the beginning of each source buffers and
	 * destination buffers.
	 */
	for (sector = startSector, i = 0; sector < endSector; sector++, i++) {
		rf_doubleEOdecode(raidPtr, buf, dest, fcol, pbuf, ebuf);
		for (j = 0; j < numDataCol; j++)
			if ((j != fcol[0]) && (j != fcol[1]))
				buf[j] += bytesPerSector;
		dest[0] += bytesPerSector;
		dest[1] += bytesPerSector;
		ebuf += bytesPerSector;
		pbuf += bytesPerSector;
	}
	/*
	 * After recovery, the buffer pointed by olddata[0] is the old failed
	 * data. With new writing data and this old data, use small write to
	 * calculate the new redundant informations.
	 */
	/*
	 * node->params[ 0, ... PDAPerDisk * (numDataCol - 2)-1 ] are Pdas of
	 * Rrd; params[ PDAPerDisk*(numDataCol - 2), ... PDAPerDisk*numDataCol
	 * -1 ] are Pdas of Rp, ( Rp2 ), Re, ( Re2 ) ; params[
	 * PDAPerDisk*numDataCol, ... PDAPerDisk*numDataCol
	 * +asmap->numStripeUnitsAccessed -asmap->numDataFailed-1] are Pdas of
	 * wudNodes; For current implementation, we assume the simplest case:
	 * asmap->numStripeUnitsAccessed == 1 and asmap->numDataFailed == 1
	 * ie. PDAPerDisk = 1 then node->params[numDataCol] must be the new
	 * data to be written to the failed disk. We first bxor the new data
	 * into the old recovered data, then do the same things as small
	 * write.
	 */

	rf_bxor(((RF_PhysDiskAddr_t *) node->params[numDataCol].p)->bufPtr,
	    olddata[0], numbytes, node->dagHdr->bp);
	/* Do new 'E' calculation. */
	/*
	 * Find out the corresponding column in encoding matrix for write
	 * column to be encoded into redundant disk 'E'.
	 */
	scol = rf_EUCol(layoutPtr, fpda->raidAddress);
	/*
	 * olddata[0] now is source buffer pointer; epda->bufPtr is the dest
	 * buffer pointer.
	 */
	rf_e_encToBuf(raidPtr, scol, olddata[0], RF_EO_MATRIX_DIM - 2,
	    epda->bufPtr, fpda->numSector);

	/* Do new 'P' calculation. */
	rf_bxor(olddata[0], ppda->bufPtr, numbytes, node->dagHdr->bp);
	/* Free the allocated buffer. */
	RF_Free(olddata[0], numbytes);
	RF_Free(olddata[1], numbytes);
	RF_Free(buf, numDataCol * sizeof(char *));

	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	if (tracerec) {
		tracerec->q_us += RF_ETIMER_VAL_US(timer);
	}
	rf_GenericWakeupFunc(node, 0);
	return (0);
}
@


1.8
log
@remove stupid casts, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_evenodd_dagfuncs.c,v 1.7 2002/12/16 07:01:04 tdeval Exp $	*/
@


1.7
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_evenodd_dagfuncs.c,v 1.6 2000/08/08 16:07:41 peter Exp $	*/
d457 1
a457 1
	bzero((char *) node->results[0], rf_RaidAddressToByte(raidPtr, failedPDA->numSector));
d541 2
a542 2
	bzero((char *) P, bytesPerEU);
	bzero((char *) temp, bytesPerEU);
@


1.6
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_evenodd_dagfuncs.c,v 1.5 2000/01/11 18:02:22 peter Exp $	*/
d3 1
d32 1
a32 1
 * Code for RAID-EVENODD  architecture.
d51 26
a76 12
/* These redundant functions are for small write */
RF_RedFuncs_t rf_EOSmallWritePFuncs = {rf_RegularXorFunc, "Regular Old-New P", rf_SimpleXorFunc, "Simple Old-New P"};
RF_RedFuncs_t rf_EOSmallWriteEFuncs = {rf_RegularONEFunc, "Regular Old-New E", rf_SimpleONEFunc, "Regular Old-New E"};
/* These redundant functions are for degraded read */
RF_RedFuncs_t rf_eoPRecoveryFuncs = {rf_RecoveryXorFunc, "Recovery Xr", rf_RecoveryXorFunc, "Recovery Xr"};
RF_RedFuncs_t rf_eoERecoveryFuncs = {rf_RecoveryEFunc, "Recovery E Func", rf_RecoveryEFunc, "Recovery E Func"};
/**********************************************************************************************
 *   the following encoding node functions is used in  EO_000_CreateLargeWriteDAG
 **********************************************************************************************/
int 
rf_RegularPEFunc(node)
	RF_DagNode_t *node;
d79 1
a79 1
	rf_RegularXorFunc(node);/* does the wakeup here! */
d86 27
a112 21
/************************************************************************************************
 *  For EO_001_CreateSmallWriteDAG, there are (i)RegularONEFunc() and (ii)SimpleONEFunc() to
 *  be used. The previous case is when write access at least sectors of full stripe unit.
 *  The later function is used when the write access two stripe units but with total sectors
 *  less than sectors per SU. In this case, the access of parity and 'E' are shown as disconnected
 *  areas in their stripe unit and  parity write and 'E' write are both devided into two distinct
 *  writes( totally four). This simple old-new write and regular old-new write happen as in RAID-5
 ************************************************************************************************/

/* Algorithm:
     1. Store the difference of old data and new data in the Rod buffer.
     2. then encode this buffer into the buffer which already have old 'E' information inside it,
	the result can be shown to be the new 'E' information.
     3. xor the Wnd buffer into the difference buffer to recover the  original old data.
   Here we have another alternative: to allocate a temporary buffer for storing the difference of
   old data and new data, then encode temp buf into old 'E' buf to form new 'E', but this approach
   take the same speed as the previous, and need more memory.
*/
int 
rf_RegularONEFunc(node)
	RF_DagNode_t *node;
d116 7
a122 5
	int     EpdaIndex = (node->numParams - 1) / 2 - 1;	/* the parameter of node
								 * where you can find
								 * e-pda */
	int     i, k, retcode = 0;
	int     suoffset, length;
d124 1
a124 1
	char   *srcbuf, *destbuf;
d127 4
a130 2
	RF_PhysDiskAddr_t *pda, *EPDA = (RF_PhysDiskAddr_t *) node->params[EpdaIndex].p;
	int     ESUOffset = rf_StripeUnitOffset(layoutPtr, EPDA->startSector);	/* generally zero  */
d137 4
a140 2
	/* Xor the Wnd buffer into Rod buffer, the difference of old data and
	 * new data is stored in Rod buffer */
d142 4
a145 2
		length = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);
		retcode = rf_bxor(node->params[k + EpdaIndex + 3].p, node->params[k + 1].p, length, node->dagHdr->bp);
d147 4
a150 2
	/* Start to encoding the buffer storing the difference of old data and
	 * new data into 'E' buffer  */
d152 2
a153 2
		if (node->params[i + 1].p != node->results[0]) {	/* results[0] is buf ptr
									 * of E */
d157 6
a162 3
			suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
			destbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset);
			rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);
d164 4
a167 2
	/* Recover the original old data to be used by parity encoding
	 * function in XorNode */
d169 4
a172 2
		length = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);
		retcode = rf_bxor(node->params[k + EpdaIndex + 3].p, node->params[k + 1].p, length, node->dagHdr->bp);
d179 1
a179 1
	return (0);		/* XXX this was missing.. GO */
d183 2
a184 3
int 
rf_SimpleONEFunc(node)
	RF_DagNode_t *node;
d189 2
a190 2
	int     retcode = 0;
	char   *srcbuf, *destbuf;
d192 1
a192 1
	int     length;
d196 2
a197 1
	RF_ASSERT(((RF_PhysDiskAddr_t *) node->params[2].p)->type == RF_PDA_TYPE_Q);
d200 10
a209 6
		length = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[4].p)->numSector);	/* this is a pda of
														 * writeDataNodes */
		/* bxor to buffer of readDataNodes */
		retcode = rf_bxor(node->params[5].p, node->params[1].p, length, node->dagHdr->bp);
		/* find out the corresponding colume in encoding matrix for
		 * write colume to be encoded into redundant disk 'E' */
d213 5
a217 3
		/* Start encoding process */
		rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);
		rf_bxor(node->params[5].p, node->params[1].p, length, node->dagHdr->bp);
d223 2
a224 1
	return (rf_GenericWakeupFunc(node, retcode));	/* call wake func
d226 2
a227 1
							 * I/O in this node */
d231 6
a236 5
/****** called by rf_RegularPEFunc(node) and rf_RegularEFunc(node) in f.f. large write  ********/
void 
rf_RegularESubroutine(node, ebuf)
	RF_DagNode_t *node;
	char   *ebuf;
d241 1
a241 1
	int     i, suoffset;
d243 1
a243 1
	char   *srcbuf, *destbuf;
d255 2
a256 1
		rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);
d264 5
a268 6
/*******************************************************************************************
 *			 Used in  EO_001_CreateLargeWriteDAG
 ******************************************************************************************/
int 
rf_RegularEFunc(node)
	RF_DagNode_t *node;
d273 1
a273 1
	return (0);		/* XXX this was missing?.. GO */
d276 17
a292 17
/*******************************************************************************************
 * This degraded function allow only two case:
 *  1. when write access the full failed stripe unit, then the access can be more than
 *     one tripe units.
 *  2. when write access only part of the failed SU, we assume accesses of more than
 *     one stripe unit is not allowed so that the write can be dealt with like a
 *     large write.
 *  The following function is based on these assumptions. So except in the second case,
 *  it looks the same as a large write encodeing function. But this is not exactly the
 *  normal way for doing a degraded write, since raidframe have to break cases of access
 *  other than the above two into smaller accesses. We may have to change
 *  DegrESubroutin in the future.
 *******************************************************************************************/
void 
rf_DegrESubroutine(node, ebuf)
	RF_DagNode_t *node;
	char   *ebuf;
d298 1
a298 1
	int     i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
d300 1
a300 1
	char   *srcbuf, *destbuf;
d321 8
a328 9
/**************************************************************************************
 * This function is used in case where one data disk failed and both redundant disks
 * alive. It is used in the EO_100_CreateWriteDAG. Note: if there is another disk
 * failed in the stripe but not accessed at this time, then we should, instead, use
 * the rf_EOWriteDoubleRecoveryFunc().
 **************************************************************************************/
int 
rf_Degraded_100_EOFunc(node)
	RF_DagNode_t *node;
d331 1
a331 1
	rf_RecoveryXorFunc(node);	/* does the wakeup here! */
d333 2
a334 2
	return (0);		/* XXX this was missing... SHould these be
				 * void functions??? GO */
a336 22
/**************************************************************************************
 * This function is to encode one sector in one of the data disks to the E disk.
 * However, in evenodd this function can also be used as decoding function to recover
 * data from dead disk in the case of parity failure and a single data failure.
 **************************************************************************************/
void 
rf_e_EncOneSect(
    RF_RowCol_t srcLogicCol,
    char *srcSecbuf,
    RF_RowCol_t destLogicCol,
    char *destSecbuf,
    int bytesPerSector)
{
	int     S_index;	/* index of the EU in the src col which need
				 * be Xored into all EUs in a dest sector */
	int     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;
	RF_RowCol_t j, indexInDest,	/* row index of an encoding unit in
					 * the destination colume of encoding
					 * matrix */
	        indexInSrc;	/* row index of an encoding unit in the source
				 * colume used for recovery */
	int     bytesPerEU = bytesPerSector / numRowInEncMatix;
d338 29
a366 2
#if RF_EO_MATRIX_DIM > 17
	int     shortsPerEU = bytesPerEU / sizeof(short);
d369 3
a371 3
#elif RF_EO_MATRIX_DIM == 17
	int     longsPerEU = bytesPerEU / sizeof(long);
	long   *destLongBuf, *srcLongBuf1, *srcLongBuf2;
d375 1
a375 1
#if RF_EO_MATRIX_DIM > 17
d378 1
a378 1
#elif RF_EO_MATRIX_DIM == 17
d384 1
a384 1
#if RF_EO_MATRIX_DIM > 17
d386 1
a386 1
#elif RF_EO_MATRIX_DIM == 17
d390 1
a390 1
	for (indexInDest = 0; indexInDest < numRowInEncMatix; indexInDest++) {
d393 1
a393 1
#if RF_EO_MATRIX_DIM > 17
d398 2
a399 2
			/* note: S_index won't be at the end row for any src
			 * col! */
d403 1
a403 1
			 * RF_EO_MATRIX_DIM -1, then all elements are zero! */
d408 1
a408 1
#elif RF_EO_MATRIX_DIM == 17
d422 3
a424 8
void 
rf_e_encToBuf(
    RF_Raid_t * raidPtr,
    RF_RowCol_t srcLogicCol,
    char *srcbuf,
    RF_RowCol_t destLogicCol,
    char *destbuf,
    int numSector)
d426 1
a426 1
	int     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
d434 3
a436 1
/**************************************************************************************
d440 3
a442 4
 **************************************************************************************/
int 
rf_RecoveryEFunc(node)
	RF_DagNode_t *node;
d447 2
a448 2
	RF_RowCol_t scol,	/* source logical column */
	        fcol = rf_EUCol(layoutPtr, failedPDA->raidAddress);	/* logical column of
d450 1
a450 1
	int     i;
d452 2
a453 2
	int     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char   *srcbuf, *destbuf;
d479 3
a481 1
/**************************************************************************************
d483 4
a486 4
 * (in EO_110_CreateWriteDAG )
 **************************************************************************************/
int 
rf_EO_DegradedWriteEFunc(RF_DagNode_t * node)
d491 1
a491 1
	return (0);		/* XXX Yet another one!! GO */
d497 7
a503 12
/**************************************************************************************
 *  		THE FUNCTION IS FOR DOUBLE DEGRADED READ AND WRITE CASES
 **************************************************************************************/

void 
rf_doubleEOdecode(
    RF_Raid_t * raidPtr,
    char **rrdbuf,
    char **dest,
    RF_RowCol_t * fcol,
    char *pbuf,
    char *ebuf)
d505 5
a509 5
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);
	int     i, j, k, f1, f2, row;
	int     rrdrow, erow, count = 0;
	int     bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
	int     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;
d511 1
a511 1
	int     pcol = (RF_EO_MATRIX_DIM) - 1;
d513 8
a520 7
	int     ecol = (RF_EO_MATRIX_DIM) - 2;
	int     bytesPerEU = bytesPerSector / numRowInEncMatix;
	int     numDataCol = layoutPtr->numDataCol;
#if RF_EO_MATRIX_DIM > 17
	int     shortsPerEU = bytesPerEU / sizeof(short);
	short  *rrdbuf_current, *pbuf_current, *ebuf_current;
	short  *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;
d522 1
a522 1
	short  *P;
d527 5
a531 4
#elif RF_EO_MATRIX_DIM == 17
	int     longsPerEU = bytesPerEU / sizeof(long);
	long   *rrdbuf_current, *pbuf_current, *ebuf_current;
	long   *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;
d533 1
a533 1
	long   *P;
d544 6
a549 4
	/* calculate the 'P' parameter, which, not parity, is the Xor of all
	 * elements in the last two column, ie. 'E' and 'parity' colume, see
	 * the Ref. paper by Blaum, et al 1993  */
	for (i = 0; i < numRowInEncMatix; i++)
d551 1
a551 1
#if RF_EO_MATRIX_DIM > 17
d554 1
a554 1
#elif RF_EO_MATRIX_DIM == 17
d563 1
a563 1
#if RF_EO_MATRIX_DIM > 17
d566 1
a566 1
#elif RF_EO_MATRIX_DIM == 17
d573 1
a573 1
#if RF_EO_MATRIX_DIM > 17
d576 1
a576 1
#elif RF_EO_MATRIX_DIM == 17
d584 3
a586 2
	while ((row = rf_EO_Mod((row + f1 - f2), RF_EO_MATRIX_DIM)) != ((RF_EO_MATRIX_DIM) - 1)) {
#if RF_EO_MATRIX_DIM > 17
d589 1
a589 1
#elif RF_EO_MATRIX_DIM == 17
d593 6
a598 3
		/**    Do the diagonal recovery. Initially, temp[k] = (failed 1),
		       which is the failed data in the colume which has smaller col index. **/
		/* step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3))         */
d604 3
a606 2
#if RF_EO_MATRIX_DIM > 17
				rrdbuf_current = (short *) (rrdbuf[j]) + rrdrow * shortsPerEU;
d609 3
a611 2
#elif RF_EO_MATRIX_DIM == 17
				rrdbuf_current = (long *) (rrdbuf[j]) + rrdrow * longsPerEU;
d617 7
a623 5
		/* step 2:  ^E(erow,m-2), If erow is at the buttom row, don't
		 * Xor into it  E(erow,m-2) = (principle diagonal) ^ (failed
		 * 1) ^ (failed 2) ^ ( SUM of nonfailed in-diagonal
		 * A(rrdrow,0..m-3) ) After this step, temp[k] = (principle
		 * diagonal) ^ (failed 2)       */
d627 1
a627 1
#if RF_EO_MATRIX_DIM > 17
d631 1
a631 1
#elif RF_EO_MATRIX_DIM == 17
d637 6
a642 4
		/* step 3: ^P to obtain the failed data (failed 2).  P can be
		 * proved to be actually  (principle diagonal)  After this
		 * step, temp[k] = (failed 2), the failed data to be recovered */
#if RF_EO_MATRIX_DIM > 17
d645 1
a645 1
		/* Put the data to the destination buffer                              */
d648 1
a648 1
#elif RF_EO_MATRIX_DIM == 17
d651 1
a651 1
		/* Put the data to the destination buffer                              */
d656 5
a660 3
		/**          THE FOLLOWING DO THE HORIZONTAL XOR                **/
		/* step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data
		 * columes    */
d664 3
a666 2
#if RF_EO_MATRIX_DIM > 17
			rrdbuf_current = (short *) (rrdbuf[j]) + row * shortsPerEU;
d669 3
a671 2
#elif RF_EO_MATRIX_DIM == 17
			rrdbuf_current = (long *) (rrdbuf[j]) + row * longsPerEU;
d676 3
a678 3
		/* step 2: ^A(row,m-1) */
		/* step 3: Put the data to the destination buffer                             	 */
#if RF_EO_MATRIX_DIM > 17
d684 1
a684 1
#elif RF_EO_MATRIX_DIM == 17
d693 6
a698 4
	/* Check if all Encoding Unit in the data buffer have been decoded,
	 * according EvenOdd theory, if "RF_EO_MATRIX_DIM" is a prime number,
	 * this algorithm will covered all buffer 				 */
	RF_ASSERT(count == numRowInEncMatix);
d704 10
a713 12
/***************************************************************************************
* 	This function is called by double degragded read
* 	EO_200_CreateReadDAG
*
***************************************************************************************/
int 
rf_EvenOddDoubleRecoveryFunc(node)
	RF_DagNode_t *node;
{
	int     ndataParam = 0;
	int     np = node->numParams;
	RF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np - 1].p;
d716 1
a716 1
	int     i, prm, sector, nresults = node->numResults;
d719 5
a723 3
	int     two = 0, mallc_one = 0, mallc_two = 0;	/* flags to indicate if
							 * memory is allocated */
	int     bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
d725 5
a729 4
	        npda;
	RF_RowCol_t fcol[2], fsuoff[2], fsuend[2], numDataCol = layoutPtr->numDataCol;
	char  **buf, *ebuf, *pbuf, *dest[2];
	long   *suoff = NULL, *suend = NULL, *prmToCol = NULL, psuoff, esuoff;
d736 4
a739 2
	/* Find out the number of parameters which are pdas for data
	 * information */
d741 2
a742 1
		if (((RF_PhysDiskAddr_t *) node->params[i].p)->type != RF_PDA_TYPE_DATA) {
d753 3
a755 2
	    (asmap->failedPDAs[1]->numSector + asmap->failedPDAs[0]->numSector < secPerSU)) {
		RF_ASSERT(0);	/* currently, no support for this situation */
d771 7
a777 5
            the followings have three goals:
            1. determine the startSector to begin decoding and endSector to end decoding.
            2. determine the colume numbers of the two failed disks.
            3. determine the offset and end offset of the access within each failed stripe unit.
         */
d779 1
a779 1
		/* find the startSector to begin decoding */
d787 1
a787 1
		/* find out the column of failed disk being accessed */
d790 3
a792 2
		/* find out the other failed colume not accessed */
		sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);
d795 6
a800 3
			(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);
			/* skip over dead disks */
			if (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))
d812 4
a815 2
		/* determine the failed colume numbers of the two failed
		 * disks. */
d818 4
a821 2
		/* determine the offset and end offset of the access within
		 * each failed stripe unit. */
d826 1
a826 1
		/* determine the startSector to begin decoding */
d828 1
a828 1
		/* determine the endSector to end decoding */
d832 3
a834 3
	      assign the beginning sector and the end sector for each parameter
	      find out the corresponding colume # for each parameter
        */
d841 9
a849 6
	/* 'sector' is the sector for the current decoding algorithm. For each
	 * sector in the failed SU, find out the corresponding parameters that
	 * cover the current sector and that are needed for decoding of this
	 * sector in failed SU. 2.  Find out if sector is in the shadow of any
	 * accessed failed SU. If not, malloc a temporary space of a sector in
	 * size. */
d852 2
a853 1
			if (!(fsuoff[0] <= sector && sector < fsuend[0]) && !(fsuoff[1] <= sector && sector < fsuend[1]))
d857 6
a862 3
				buf[(prmToCol[prm])] = ((RF_PhysDiskAddr_t *) node->params[prm].p)->bufPtr +
				    rf_RaidAddressToByte(raidPtr, sector - suoff[prm]);
		/* find out if sector is in the shadow of any accessed failed
d864 1
a864 1
		 * position of the buffer corresponding to failed SUs. if no,
d866 2
a867 1
		 * destination of decoding. */
d870 4
a873 2
			dest[0] = ((RF_PhysDiskAddr_t *) node->results[0])->bufPtr + rf_RaidAddressToByte(raidPtr, sector - fsuoff[0]);
			/* Always malloc temp buffer to dest[1]  */
d879 4
a882 1
				dest[0] = ((RF_PhysDiskAddr_t *) node->results[0])->bufPtr + rf_RaidAddressToByte(raidPtr, sector - fsuoff[0]);
d889 4
a892 1
				dest[1] = ((RF_PhysDiskAddr_t *) node->results[1])->bufPtr + rf_RaidAddressToByte(raidPtr, sector - fsuoff[1]);
d900 4
a903 2
		pbuf = ppda->bufPtr + rf_RaidAddressToByte(raidPtr, sector - psuoff);
		ebuf = epda->bufPtr + rf_RaidAddressToByte(raidPtr, sector - esuoff);
d905 3
a907 3
	         * After finish finding all needed sectors, call doubleEOdecode function for decoding
	         * one sector to destination.
	         */
d909 4
a912 2
		/* free all allocated memory, and mark flag to indicate no
		 * memory is being allocated */
d932 1
a932 1
	return (0);		/* XXX is this even close!!?!?!!? GO */
d937 5
a941 3
/* currently, only access of one of the two failed SU is allowed in this function.
 * also, asmap->numStripeUnitsAccessed is limited to be one, the RaidFrame will break large access into
 * many accesses of single stripe unit.
d944 2
a945 3
int 
rf_EOWriteDoubleRecoveryFunc(node)
	RF_DagNode_t *node;
d947 3
a949 2
	int     np = node->numParams;
	RF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np - 1].p;
d951 1
a951 1
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);
d954 1
a954 1
	int     prm, i, j;
d962 2
a963 1
	char  **buf;		/* buf[0], buf[1], buf[2], ...etc. point to
d965 3
a967 2
				 * col2 */
	char   *ebuf, *pbuf, *dest[2], *olddata[2];
d971 2
a972 1
	RF_ASSERT(asmap->numDataFailed == 1);	/* currently only support this
d974 2
a975 1
						 * is not being accessed */
d979 5
a983 2
	ppda = node->results[0];/* Instead of being buffers, node->results[0]
				 * and [1] are Ppda and Epda  */
d987 2
a988 2
	/* First, recovery the failed old SU using EvenOdd double decoding      */
	/* determine the startSector and endSector for decoding */
d991 2
a992 1
	/* Assign buf[col] pointers to point to each non-failed colume  and
d994 1
a994 1
	 * source buffers and destination buffers */
d1000 4
a1003 2
	/* pbuf and ebuf:  they will change values as double recovery decoding
	 * goes on */
d1006 4
a1009 2
	/* find out the logical colume numbers in the encoding matrix of the
	 * two failed columes */
d1012 3
a1014 2
	/* find out the other failed colume not accessed this time */
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);
d1017 3
a1019 2
		(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);
		/* skip over dead disks */
d1026 1
a1026 1
	/* assign temporary space to put recovered failed SU */
d1034 2
a1035 1
	/* Begin the recovery decoding, initially buf[j],  ebuf, pbuf, dest[j]
d1037 2
a1038 1
	 * destination buffers */
d1049 2
a1050 1
	/* after recovery, the buffer pointed by olddata[0] is the old failed
d1052 4
a1055 2
	 * calculate the new redundant informations */
	/* node->params[ 0, ... PDAPerDisk * (numDataCol - 2)-1 ] are Pdas of
d1065 2
a1066 1
	 * write. */
d1068 7
a1074 4
	rf_bxor(((RF_PhysDiskAddr_t *) node->params[numDataCol].p)->bufPtr, olddata[0], numbytes, node->dagHdr->bp);
	/* do new 'E' calculation  */
	/* find out the corresponding colume in encoding matrix for write
	 * colume to be encoded into redundant disk 'E' */
d1076 6
a1081 3
	/* olddata[0] now is source buffer pointer; epda->bufPtr is the dest
	 * buffer pointer               */
	rf_e_encToBuf(raidPtr, scol, olddata[0], RF_EO_MATRIX_DIM - 2, epda->bufPtr, fpda->numSector);
d1083 1
a1083 1
	/* do new 'P' calculation  */
d1085 1
a1085 1
	/* Free the allocated buffer  */
@


1.6.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d31 1
a31 1
 * Code for RAID-EVENODD architecture.
d50 12
a61 26
/* These redundant functions are for small write. */
RF_RedFuncs_t rf_EOSmallWritePFuncs = {
	rf_RegularXorFunc, "Regular Old-New P",
	rf_SimpleXorFunc, "Simple Old-New P"
};
RF_RedFuncs_t rf_EOSmallWriteEFuncs = {
	rf_RegularONEFunc, "Regular Old-New E",
	rf_SimpleONEFunc, "Regular Old-New E"
};
/* These redundant functions are for degraded read. */
RF_RedFuncs_t rf_eoPRecoveryFuncs = {
	rf_RecoveryXorFunc, "Recovery Xr",
	rf_RecoveryXorFunc, "Recovery Xr"
};
RF_RedFuncs_t rf_eoERecoveryFuncs = {
	rf_RecoveryEFunc, "Recovery E Func",
	rf_RecoveryEFunc, "Recovery E Func"
};


/*****************************************************************************
 *   The following encoding node functions is used in
 *   EO_000_CreateLargeWriteDAG.
 *****************************************************************************/
int
rf_RegularPEFunc(RF_DagNode_t *node)
d64 1
a64 1
	rf_RegularXorFunc(node);	/* Do the wakeup here ! */
d71 21
a91 27
/*****************************************************************************
 *  For EO_001_CreateSmallWriteDAG, there are (i) RegularONEFunc() and
 *  (ii) SimpleONEFunc() to be used. The previous case is when write accesses
 *  at least sectors of full stripe unit.
 *  The later function is used when the write accesses two stripe units but
 *  with total sectors less than sectors per SU. In this case, the access of
 *  parity and 'E' are shown as disconnected areas in their stripe unit and
 *  parity write and 'E' write are both divided into two distinct writes
 *  (totally four). This simple old-new write and regular old-new write happen
 *  as in RAID-5.
 *****************************************************************************/

/*
 * Algorithm:
 *   1. Store the difference of old data and new data in the Rod buffer.
 *   2. Then encode this buffer into the buffer that already have old 'E'
 *	information inside it, the result can be shown to be the new 'E'
 *	information.
 *   3. Xor the Wnd buffer into the difference buffer to recover the original
 *	old data.
 * Here we have another alternative: to allocate a temporary buffer for
 * storing the difference of old data and new data, then encode temp buf
 * into old 'E' buf to form new 'E', but this approach takes the same speed
 * as the previous, and needs more memory.
 */
int
rf_RegularONEFunc(RF_DagNode_t *node)
d95 5
a99 7
	int EpdaIndex = (node->numParams - 1) / 2 - 1;	/*
							 * The parameter of node
							 * where you can find
							 * e-pda.
							 */
	int i, k, retcode = 0;
	int suoffset, length;
d101 1
a101 1
	char *srcbuf, *destbuf;
d104 2
a105 4
	RF_PhysDiskAddr_t *pda, *EPDA = (RF_PhysDiskAddr_t *)
	    node->params[EpdaIndex].p;
	/* Generally zero. */
	int ESUOffset = rf_StripeUnitOffset(layoutPtr, EPDA->startSector);
d112 2
a113 4
	/*
	 * Xor the Wnd buffer into Rod buffer. The difference of old data and
	 * new data is stored in Rod buffer.
	 */
d115 2
a116 4
		length = rf_RaidAddressToByte(raidPtr,
		    ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);
		retcode = rf_bxor(node->params[k + EpdaIndex + 3].p,
		    node->params[k + 1].p, length, node->dagHdr->bp);
d118 2
a119 4
	/*
	 * Start to encode the buffer, storing the difference of old data and
	 * new data into 'E' buffer.
	 */
d121 2
a122 2
		if (node->params[i + 1].p != node->results[0]) {
			/* results[0] is buf ptr of E. */
d126 3
a128 6
			suoffset = rf_StripeUnitOffset(layoutPtr,
			    pda->startSector);
			destbuf = ((char *) node->results[0]) +
			    rf_RaidAddressToByte(raidPtr, suoffset);
			rf_e_encToBuf(raidPtr, scol, srcbuf,
			    RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);
d130 2
a131 4
	/*
	 * Recover the original old data to be used by parity encoding
	 * function in XorNode.
	 */
d133 2
a134 4
		length = rf_RaidAddressToByte(raidPtr,
		    ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);
		retcode = rf_bxor(node->params[k + EpdaIndex + 3].p,
		    node->params[k + 1].p, length, node->dagHdr->bp);
d141 1
a141 1
	return (0);		/* XXX This was missing... GO */
d145 3
a147 2
int
rf_SimpleONEFunc(RF_DagNode_t *node)
d152 2
a153 2
	int retcode = 0;
	char *srcbuf, *destbuf;
d155 1
a155 1
	int length;
d159 1
a159 2
	RF_ASSERT(((RF_PhysDiskAddr_t *) node->params[2].p)->type ==
	    RF_PDA_TYPE_Q);
d162 6
a167 10
		/* This is a pda of writeDataNodes. */
		length = rf_RaidAddressToByte(raidPtr,
		    ((RF_PhysDiskAddr_t *) node->params[4].p)->numSector);
		/* bxor to buffer of readDataNodes. */
		retcode = rf_bxor(node->params[5].p, node->params[1].p,
		    length, node->dagHdr->bp);
		/*
		 * Find out the corresponding column in encoding matrix for
		 * write column to be encoded into redundant disk 'E'.
		 */
d171 3
a173 5
		/* Start encoding process. */
		rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2,
		    destbuf, pda->numSector);
		rf_bxor(node->params[5].p, node->params[1].p, length,
		    node->dagHdr->bp);
d179 1
a179 2
	return (rf_GenericWakeupFunc(node, retcode));	/*
							 * Call wake func
d181 1
a181 2
							 * I/O in this node.
							 */
d185 5
a189 6
/*
 * Called by rf_RegularPEFunc(node) and rf_RegularEFunc(node)
 * in f.f. large write.
 */
void
rf_RegularESubroutine(RF_DagNode_t *node, char *ebuf)
d194 1
a194 1
	int i, suoffset;
d196 1
a196 1
	char *srcbuf, *destbuf;
d208 1
a208 2
		rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2,
		    destbuf, pda->numSector);
d216 6
a221 5
/*****************************************************************************
 *			 Used in  EO_001_CreateLargeWriteDAG.
 *****************************************************************************/
int
rf_RegularEFunc(RF_DagNode_t *node)
d226 1
a226 1
	return (0);		/* XXX This was missing... GO */
d229 17
a245 17


/*****************************************************************************
 * This degraded function allow only two cases:
 *   1. When write accesses the full failed stripe unit, then the access can
 *	be more than one stripe unit.
 *   2. When write accesses only part of the failed SU, we assume accesses of
 *	more than one stripe unit are not allowed so that the write can be
 *	dealt with like a large write.
 * The following function is based on these assumptions. So except in the
 * second case, it looks the same as a large write encoding function. But
 * this is not exactly the normal way of doing a degraded write, since
 * RAIDframe has to break cases of accesses other than the above two into
 * smaller accesses. We may have to change DegrESubroutin in the future.
 *****************************************************************************/
void
rf_DegrESubroutine(RF_DagNode_t *node, char *ebuf)
d251 1
a251 1
	int i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
d253 1
a253 1
	char *srcbuf, *destbuf;
d274 9
a282 8
/*****************************************************************************
 * This function is used in case where one data disk failed and both redundant
 * disks are alive. It is used in the EO_100_CreateWriteDAG. Note: if there is
 * another disk failed in the stripe but not accessed at this time, then we
 * should, instead, use the rf_EOWriteDoubleRecoveryFunc().
 *****************************************************************************/
int
rf_Degraded_100_EOFunc(RF_DagNode_t *node)
d285 1
a285 1
	rf_RecoveryXorFunc(node);	/* Does the wakeup here ! */
d287 2
a288 2
	return (0);		/* XXX This was missing... Should these be
				 * void functions ??? GO */
d291 22
d314 2
a315 29

/*****************************************************************************
 * This function is to encode one sector in one of the data disks to the E
 * disk. However, in evenodd this function can also be used as decoding
 * function to recover data from dead disk in the case of parity failure and
 * a single data failure.
 *****************************************************************************/
void
rf_e_EncOneSect(RF_RowCol_t srcLogicCol, char *srcSecbuf,
    RF_RowCol_t destLogicCol, char *destSecbuf, int bytesPerSector)
{
	int S_index;		/*
				 * Index of the EU in the src col which need
				 * be Xored into all EUs in a dest sector.
				 */
	int numRowInEncMatrix = (RF_EO_MATRIX_DIM) - 1;
	RF_RowCol_t j, indexInDest;	/*
					 * Row index of an encoding unit in
					 * the destination column of encoding
					 * matrix.
					 */
	RF_RowCol_t indexInSrc;	/*
				 * Row index of an encoding unit in the source
				 * column used for recovery.
				 */
	int bytesPerEU = bytesPerSector / numRowInEncMatrix;

#if	RF_EO_MATRIX_DIM > 17
	int shortsPerEU = bytesPerEU / sizeof(short);
d318 3
a320 3
#elif	RF_EO_MATRIX_DIM == 17
	int longsPerEU = bytesPerEU / sizeof(long);
	long *destLongBuf, *srcLongBuf1, *srcLongBuf2;
d324 1
a324 1
#if	RF_EO_MATRIX_DIM > 17
d327 1
a327 1
#elif	RF_EO_MATRIX_DIM == 17
d333 1
a333 1
#if	RF_EO_MATRIX_DIM > 17
d335 1
a335 1
#elif	RF_EO_MATRIX_DIM == 17
d339 1
a339 1
	for (indexInDest = 0; indexInDest < numRowInEncMatrix; indexInDest++) {
d342 1
a342 1
#if	RF_EO_MATRIX_DIM > 17
d347 2
a348 2
			/* Note: S_index won't be at the end row for any src
			 * col ! */
d352 1
a352 1
			 * RF_EO_MATRIX_DIM -1, then all elements are zero ! */
d357 1
a357 1
#elif	RF_EO_MATRIX_DIM == 17
d371 8
a378 3
void
rf_e_encToBuf(RF_Raid_t *raidPtr, RF_RowCol_t srcLogicCol, char *srcbuf,
    RF_RowCol_t destLogicCol, char *destbuf, int numSector)
d380 1
a380 1
	int i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
d388 1
a388 3


/*****************************************************************************
d392 4
a395 3
 *****************************************************************************/
int
rf_RecoveryEFunc(RF_DagNode_t *node)
d400 2
a401 2
	RF_RowCol_t scol;	/* source logical column */
	RF_RowCol_t fcol = rf_EUCol(layoutPtr, failedPDA->raidAddress);	/* logical column of
d403 1
a403 1
	int i;
d405 2
a406 2
	int suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char *srcbuf, *destbuf;
d432 1
a432 3


/*****************************************************************************
d434 4
a437 4
 * (in EO_110_CreateWriteDAG)
 *****************************************************************************/
int
rf_EO_DegradedWriteEFunc(RF_DagNode_t *node)
d442 1
a442 1
	return (0);		/* XXX Yet another one !!! GO */
d448 12
a459 7
/*****************************************************************************
 *	THE FUNCTION IS FOR DOUBLE DEGRADED READ AND WRITE CASES.
 *****************************************************************************/

void
rf_doubleEOdecode(RF_Raid_t *raidPtr, char **rrdbuf, char **dest,
    RF_RowCol_t *fcol, char *pbuf, char *ebuf)
d461 5
a465 5
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &(raidPtr->Layout);
	int i, j, k, f1, f2, row;
	int rrdrow, erow, count = 0;
	int bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
	int numRowInEncMatrix = (RF_EO_MATRIX_DIM) - 1;
d467 1
a467 1
	int pcol = (RF_EO_MATRIX_DIM) - 1;
d469 7
a475 8
	int ecol = (RF_EO_MATRIX_DIM) - 2;
	int bytesPerEU = bytesPerSector / numRowInEncMatrix;
	int numDataCol = layoutPtr->numDataCol;
#if	RF_EO_MATRIX_DIM > 17
	int shortsPerEU = bytesPerEU / sizeof(short);
	short *rrdbuf_current, *pbuf_current, *ebuf_current;
	short *dest_smaller, *dest_smaller_current;
	short *dest_larger, *dest_larger_current;
d477 1
a477 1
	short *P;
d482 4
a485 5
#elif	RF_EO_MATRIX_DIM == 17
	int longsPerEU = bytesPerEU / sizeof(long);
	long *rrdbuf_current, *pbuf_current, *ebuf_current;
	long *dest_smaller, *dest_smaller_current;
	long *dest_larger, *dest_larger_current;
d487 1
a487 1
	long *P;
d498 4
a501 6
	/*
	 * Calculate the 'P' parameter, which, not parity, is the Xor of all
	 * elements in the last two column, ie. 'E' and 'parity' columns, see
	 * the Ref. paper by Blaum, et al 1993.
	 */
	for (i = 0; i < numRowInEncMatrix; i++)
d503 1
a503 1
#if	RF_EO_MATRIX_DIM > 17
d506 1
a506 1
#elif	RF_EO_MATRIX_DIM == 17
d515 1
a515 1
#if	RF_EO_MATRIX_DIM > 17
d518 1
a518 1
#elif	RF_EO_MATRIX_DIM == 17
d525 1
a525 1
#if	RF_EO_MATRIX_DIM > 17
d528 1
a528 1
#elif	RF_EO_MATRIX_DIM == 17
d536 2
a537 3
	while ((row = rf_EO_Mod((row + f1 - f2), RF_EO_MATRIX_DIM)) !=
	    ((RF_EO_MATRIX_DIM) - 1)) {
#if	RF_EO_MATRIX_DIM > 17
d540 1
a540 1
#elif	RF_EO_MATRIX_DIM == 17
d544 3
a546 6
		/*
		 * Do the diagonal recovery. Initially, temp[k] = (failed 1),
		 * which is the failed data in the column that has smaller
		 * col index.
		 */
		/* Step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3)) */
d552 2
a553 3
#if	RF_EO_MATRIX_DIM > 17
				rrdbuf_current = (short *) (rrdbuf[j]) +
				    rrdrow * shortsPerEU;
d556 2
a557 3
#elif	RF_EO_MATRIX_DIM == 17
				rrdbuf_current = (long *) (rrdbuf[j]) +
				    rrdrow * longsPerEU;
d563 5
a567 7
		/*
		 * Step 2:  ^E(erow,m-2), If erow is at the bottom row, don't
		 * Xor into it.  E(erow,m-2) = (principle diagonal) ^ (failed
		 * 1) ^ (failed 2) ^ (SUM of nonfailed in-diagonal
		 * A(rrdrow,0..m-3))
		 * After this step, temp[k] = (principle diagonal) ^ (failed 2).
		 */
d571 1
a571 1
#if	RF_EO_MATRIX_DIM > 17
d575 1
a575 1
#elif	RF_EO_MATRIX_DIM == 17
d581 4
a584 6
		/*
		 * Step 3: ^P to obtain the failed data (failed 2). P can be
		 * proved to be actually (principal diagonal). After this
		 * step, temp[k] = (failed 2), the failed data to be recovered.
		 */
#if	RF_EO_MATRIX_DIM > 17
d587 1
a587 1
		/* Put the data into the destination buffer. */
d590 1
a590 1
#elif	RF_EO_MATRIX_DIM == 17
d593 1
a593 1
		/* Put the data into the destination buffer. */
d598 3
a600 5
		/* THE FOLLOWING DO THE HORIZONTAL XOR. */
		/*
		 * Step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data
		 * columns.
		 */
d604 2
a605 3
#if	RF_EO_MATRIX_DIM > 17
			rrdbuf_current = (short *) (rrdbuf[j]) +
			    row * shortsPerEU;
d608 2
a609 3
#elif	RF_EO_MATRIX_DIM == 17
			rrdbuf_current = (long *) (rrdbuf[j]) +
			    row * longsPerEU;
d614 3
a616 3
		/* Step 2: ^A(row,m-1) */
		/* Step 3: Put the data into the destination buffer. */
#if	RF_EO_MATRIX_DIM > 17
d622 1
a622 1
#elif	RF_EO_MATRIX_DIM == 17
d631 4
a634 6
	/*
	 * Check if all Encoding Unit in the data buffer have been decoded ?
	 * According to EvenOdd theory, if "RF_EO_MATRIX_DIM" is a prime
	 * number, this algorithm will covered all buffer.
	 */
	RF_ASSERT(count == numRowInEncMatrix);
d640 12
a651 10
/*****************************************************************************
 *	This function is called by double degraded read EO_200_CreateReadDAG.
 *****************************************************************************/
int
rf_EvenOddDoubleRecoveryFunc(RF_DagNode_t *node)
{
	int ndataParam = 0;
	int np = node->numParams;
	RF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *)
	    node->params[np - 1].p;
d654 1
a654 1
	int i, prm, sector, nresults = node->numResults;
d657 3
a659 5
	int two = 0, mallc_one = 0, mallc_two = 0;	/*
							 * Flags to indicate if
							 * memory is allocated.
							 */
	int bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
d661 4
a664 5
	    npda;
	RF_RowCol_t fcol[2], fsuoff[2], fsuend[2],
	    numDataCol = layoutPtr->numDataCol;
	char **buf, *ebuf, *pbuf, *dest[2];
	long *suoff = NULL, *suend = NULL, *prmToCol = NULL, psuoff, esuoff;
d671 2
a672 4
	/*
	 * Find out the number of parameters that are pdas for data
	 * information.
	 */
d674 1
a674 2
		if (((RF_PhysDiskAddr_t *) node->params[i].p)->type !=
		    RF_PDA_TYPE_DATA) {
d685 2
a686 3
	    (asmap->failedPDAs[1]->numSector +
	     asmap->failedPDAs[0]->numSector) < secPerSU) {
		RF_ASSERT(0);	/* Currently, no support for this situation. */
d702 5
a706 7
	 * The followings have three goals:
	 *   1. Determine the startSector to begin decoding and endSector
	 *	to end decoding.
	 *   2. Determine the column numbers of the two failed disks.
	 *   3. Determine the offset and end offset of the access within
	 *	each failed stripe unit.
	 */
d708 1
a708 1
		/* Find the startSector to begin decoding. */
d716 1
a716 1
		/* Find out the column of failed disk being accessed. */
d719 2
a720 3
		/* Find out the other failed column not accessed. */
		sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
		    asmap->raidAddress);
d723 3
a725 6
			(raidPtr->Layout.map->MapSector) (raidPtr,
			    npda.raidAddress, &(npda.row), &(npda.col),
			    &(npda.startSector), 0);
			/* Skip over dead disks. */
			if (RF_DEAD_DISK(raidPtr
			    ->Disks[npda.row][npda.col].status))
d737 2
a738 4
		/*
		 * Determine the failed column numbers of the two failed
		 * disks.
		 */
d741 2
a742 4
		/*
		 * Determine the offset and end offset of the access within
		 * each failed stripe unit.
		 */
d747 1
a747 1
		/* Determine the startSector to begin decoding. */
d749 1
a749 1
		/* Determine the endSector to end decoding. */
d753 3
a755 3
	 * Assign the beginning sector and the end sector for each parameter.
	 * Find out the corresponding column # for each parameter.
	 */
d762 6
a767 9
	/*
	 * 'sector' is the sector for the current decoding algorithm. For each
	 * sector in the failed SU
	 * 1. Find out the corresponding parameters that cover the current
	 *    sector and that are needed for the decoding of this sector in
	 *    failed SU.
	 * 2. Find out if sector is in the shadow of any accessed failed SU.
	 *    If not, malloc a temporary space of a sector in size.
	 */
d770 1
a770 2
			if (!(fsuoff[0] <= sector && sector < fsuend[0]) &&
			    !(fsuoff[1] <= sector && sector < fsuend[1]))
d774 3
a776 6
				buf[(prmToCol[prm])] = ((RF_PhysDiskAddr_t *)
				    node->params[prm].p)->bufPtr +
				    rf_RaidAddressToByte(raidPtr,
				     sector - suoff[prm]);
		/*
		 * Find out if sector is in the shadow of any accessed failed
d778 1
a778 1
		 * position of the buffer corresponding to failed SUs. If no,
d780 1
a780 2
		 * destination of decoding.
		 */
d783 2
a784 4
			dest[0] = ((RF_PhysDiskAddr_t *)
			    node->results[0])->bufPtr +
			    rf_RaidAddressToByte(raidPtr, sector - fsuoff[0]);
			/* Always malloc temp buffer to dest[1]. */
d790 1
a790 4
				dest[0] = ((RF_PhysDiskAddr_t *)
				    node->results[0])->bufPtr +
				    rf_RaidAddressToByte(raidPtr,
				     sector - fsuoff[0]);
d797 1
a797 4
				dest[1] = ((RF_PhysDiskAddr_t *)
				    node->results[1])->bufPtr +
				    rf_RaidAddressToByte(raidPtr,
				     sector - fsuoff[1]);
d805 2
a806 4
		pbuf = ppda->bufPtr + rf_RaidAddressToByte(raidPtr,
		    sector - psuoff);
		ebuf = epda->bufPtr + rf_RaidAddressToByte(raidPtr,
		    sector - esuoff);
d808 3
a810 3
		 * After finish finding all needed sectors, call doubleEOdecode
		 * function for decoding one sector to destination.
		 */
d812 2
a813 4
		/*
		 * Free all allocated memory, and mark flag to indicate no
		 * memory is being allocated.
		 */
d833 1
a833 1
	return (0);		/* XXX Is this even close !!?!?!!? GO */
d838 3
a840 5
/*
 * Currently, only access of one of the two failed SU is allowed in this
 * function. Also, asmap->numStripeUnitsAccessed is limited to be one,
 * the RAIDframe will break large access into many accesses of single
 * stripe unit.
d843 3
a845 2
int
rf_EOWriteDoubleRecoveryFunc(RF_DagNode_t *node)
d847 2
a848 3
	int np = node->numParams;
	RF_AccessStripeMap_t *asmap =
	    (RF_AccessStripeMap_t *) node->params[np - 1].p;
d850 1
a850 1
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &(raidPtr->Layout);
d853 1
a853 1
	int prm, i, j;
d861 1
a861 2
	char **buf;		/*
				 * buf[0], buf[1], buf[2], ... etc, point to
d863 2
a864 3
				 * col2.
				 */
	char *ebuf, *pbuf, *dest[2], *olddata[2];
d868 1
a868 2
	RF_ASSERT(asmap->numDataFailed == 1);	/*
						 * Currently only support this
d870 1
a870 2
						 * is not being accessed.
						 */
d874 2
a875 5
	ppda = node->results[0];	/*
					 * Instead of being buffers,
					 * node->results[0] and [1]
					 * are Ppda and Epda.
					 */
d879 2
a880 2
	/* First, recovery the failed old SU using EvenOdd double decoding. */
	/* Determine the startSector and endSector for decoding. */
d883 1
a883 2
	/*
	 * Assign buf[col] pointers to point to each non-failed column and
d885 1
a885 1
	 * source buffers and destination buffers. */
d891 2
a892 4
	/*
	 * pbuf and ebuf: They will change values as double recovery decoding
	 * goes on.
	 */
d895 2
a896 4
	/*
	 * Find out the logical column numbers in the encoding matrix of the
	 * two failed columns.
	 */
d899 2
a900 3
	/* Find out the other failed column not accessed this time. */
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
	    asmap->raidAddress);
d903 2
a904 3
		(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress,
		    &(npda.row), &(npda.col), &(npda.startSector), 0);
		/* Skip over dead disks. */
d911 1
a911 1
	/* Assign temporary space to put recovered failed SU. */
d919 1
a919 2
	/*
	 * Begin the recovery decoding, initially buf[j], ebuf, pbuf, dest[j]
d921 1
a921 2
	 * destination buffers.
	 */
d932 1
a932 2
	/*
	 * After recovery, the buffer pointed by olddata[0] is the old failed
d934 2
a935 4
	 * calculate the new redundant informations.
	 */
	/*
	 * node->params[ 0, ... PDAPerDisk * (numDataCol - 2)-1 ] are Pdas of
d945 1
a945 2
	 * write.
	 */
d947 4
a950 7
	rf_bxor(((RF_PhysDiskAddr_t *) node->params[numDataCol].p)->bufPtr,
	    olddata[0], numbytes, node->dagHdr->bp);
	/* Do new 'E' calculation. */
	/*
	 * Find out the corresponding column in encoding matrix for write
	 * column to be encoded into redundant disk 'E'.
	 */
d952 3
a954 6
	/*
	 * olddata[0] now is source buffer pointer; epda->bufPtr is the dest
	 * buffer pointer.
	 */
	rf_e_encToBuf(raidPtr, scol, olddata[0], RF_EO_MATRIX_DIM - 2,
	    epda->bufPtr, fpda->numSector);
d956 1
a956 1
	/* Do new 'P' calculation. */
d958 1
a958 1
	/* Free the allocated buffer. */
@


1.5
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_evenodd_dagfuncs.c,v 1.4 2000/01/07 14:50:21 peter Exp $	*/
/*	$NetBSD: rf_evenodd_dagfuncs.c,v 1.4 2000/01/07 03:41:00 oster Exp $	*/
d317 1
a317 1
	register short temp1;
d321 1
a321 1
	register long temp1;
d476 1
a476 1
	register short *temp;
d486 1
a486 1
	register long *temp;
d716 1
a716 1
		/* find out the the column of failed disk being accessed */
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_evenodd_dagfuncs.c,v 1.6 2000/08/08 16:07:41 peter Exp $	*/
/*	$NetBSD: rf_evenodd_dagfuncs.c,v 1.6 2000/03/30 12:45:40 augustss Exp $	*/
d317 1
a317 1
	short temp1;
d321 1
a321 1
	long temp1;
d476 1
a476 1
	short *temp;
d486 1
a486 1
	long *temp;
d716 1
a716 1
		/* find out the column of failed disk being accessed */
@


1.5.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d31 1
a31 1
 * Code for RAID-EVENODD architecture.
d50 12
a61 26
/* These redundant functions are for small write. */
RF_RedFuncs_t rf_EOSmallWritePFuncs = {
	rf_RegularXorFunc, "Regular Old-New P",
	rf_SimpleXorFunc, "Simple Old-New P"
};
RF_RedFuncs_t rf_EOSmallWriteEFuncs = {
	rf_RegularONEFunc, "Regular Old-New E",
	rf_SimpleONEFunc, "Regular Old-New E"
};
/* These redundant functions are for degraded read. */
RF_RedFuncs_t rf_eoPRecoveryFuncs = {
	rf_RecoveryXorFunc, "Recovery Xr",
	rf_RecoveryXorFunc, "Recovery Xr"
};
RF_RedFuncs_t rf_eoERecoveryFuncs = {
	rf_RecoveryEFunc, "Recovery E Func",
	rf_RecoveryEFunc, "Recovery E Func"
};


/*****************************************************************************
 *   The following encoding node functions is used in
 *   EO_000_CreateLargeWriteDAG.
 *****************************************************************************/
int
rf_RegularPEFunc(RF_DagNode_t *node)
d64 1
a64 1
	rf_RegularXorFunc(node);	/* Do the wakeup here ! */
d71 21
a91 27
/*****************************************************************************
 *  For EO_001_CreateSmallWriteDAG, there are (i) RegularONEFunc() and
 *  (ii) SimpleONEFunc() to be used. The previous case is when write accesses
 *  at least sectors of full stripe unit.
 *  The later function is used when the write accesses two stripe units but
 *  with total sectors less than sectors per SU. In this case, the access of
 *  parity and 'E' are shown as disconnected areas in their stripe unit and
 *  parity write and 'E' write are both divided into two distinct writes
 *  (totally four). This simple old-new write and regular old-new write happen
 *  as in RAID-5.
 *****************************************************************************/

/*
 * Algorithm:
 *   1. Store the difference of old data and new data in the Rod buffer.
 *   2. Then encode this buffer into the buffer that already have old 'E'
 *	information inside it, the result can be shown to be the new 'E'
 *	information.
 *   3. Xor the Wnd buffer into the difference buffer to recover the original
 *	old data.
 * Here we have another alternative: to allocate a temporary buffer for
 * storing the difference of old data and new data, then encode temp buf
 * into old 'E' buf to form new 'E', but this approach takes the same speed
 * as the previous, and needs more memory.
 */
int
rf_RegularONEFunc(RF_DagNode_t *node)
d95 5
a99 7
	int EpdaIndex = (node->numParams - 1) / 2 - 1;	/*
							 * The parameter of node
							 * where you can find
							 * e-pda.
							 */
	int i, k, retcode = 0;
	int suoffset, length;
d101 1
a101 1
	char *srcbuf, *destbuf;
d104 2
a105 4
	RF_PhysDiskAddr_t *pda, *EPDA = (RF_PhysDiskAddr_t *)
	    node->params[EpdaIndex].p;
	/* Generally zero. */
	int ESUOffset = rf_StripeUnitOffset(layoutPtr, EPDA->startSector);
d112 2
a113 4
	/*
	 * Xor the Wnd buffer into Rod buffer. The difference of old data and
	 * new data is stored in Rod buffer.
	 */
d115 2
a116 4
		length = rf_RaidAddressToByte(raidPtr,
		    ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);
		retcode = rf_bxor(node->params[k + EpdaIndex + 3].p,
		    node->params[k + 1].p, length, node->dagHdr->bp);
d118 2
a119 4
	/*
	 * Start to encode the buffer, storing the difference of old data and
	 * new data into 'E' buffer.
	 */
d121 2
a122 2
		if (node->params[i + 1].p != node->results[0]) {
			/* results[0] is buf ptr of E. */
d126 3
a128 6
			suoffset = rf_StripeUnitOffset(layoutPtr,
			    pda->startSector);
			destbuf = ((char *) node->results[0]) +
			    rf_RaidAddressToByte(raidPtr, suoffset);
			rf_e_encToBuf(raidPtr, scol, srcbuf,
			    RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);
d130 2
a131 4
	/*
	 * Recover the original old data to be used by parity encoding
	 * function in XorNode.
	 */
d133 2
a134 4
		length = rf_RaidAddressToByte(raidPtr,
		    ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);
		retcode = rf_bxor(node->params[k + EpdaIndex + 3].p,
		    node->params[k + 1].p, length, node->dagHdr->bp);
d141 1
a141 1
	return (0);		/* XXX This was missing... GO */
d145 3
a147 2
int
rf_SimpleONEFunc(RF_DagNode_t *node)
d152 2
a153 2
	int retcode = 0;
	char *srcbuf, *destbuf;
d155 1
a155 1
	int length;
d159 1
a159 2
	RF_ASSERT(((RF_PhysDiskAddr_t *) node->params[2].p)->type ==
	    RF_PDA_TYPE_Q);
d162 6
a167 10
		/* This is a pda of writeDataNodes. */
		length = rf_RaidAddressToByte(raidPtr,
		    ((RF_PhysDiskAddr_t *) node->params[4].p)->numSector);
		/* bxor to buffer of readDataNodes. */
		retcode = rf_bxor(node->params[5].p, node->params[1].p,
		    length, node->dagHdr->bp);
		/*
		 * Find out the corresponding column in encoding matrix for
		 * write column to be encoded into redundant disk 'E'.
		 */
d171 3
a173 5
		/* Start encoding process. */
		rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2,
		    destbuf, pda->numSector);
		rf_bxor(node->params[5].p, node->params[1].p, length,
		    node->dagHdr->bp);
d179 1
a179 2
	return (rf_GenericWakeupFunc(node, retcode));	/*
							 * Call wake func
d181 1
a181 2
							 * I/O in this node.
							 */
d185 5
a189 6
/*
 * Called by rf_RegularPEFunc(node) and rf_RegularEFunc(node)
 * in f.f. large write.
 */
void
rf_RegularESubroutine(RF_DagNode_t *node, char *ebuf)
d194 1
a194 1
	int i, suoffset;
d196 1
a196 1
	char *srcbuf, *destbuf;
d208 1
a208 2
		rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2,
		    destbuf, pda->numSector);
d216 6
a221 5
/*****************************************************************************
 *			 Used in  EO_001_CreateLargeWriteDAG.
 *****************************************************************************/
int
rf_RegularEFunc(RF_DagNode_t *node)
d226 1
a226 1
	return (0);		/* XXX This was missing... GO */
d229 17
a245 17


/*****************************************************************************
 * This degraded function allow only two cases:
 *   1. When write accesses the full failed stripe unit, then the access can
 *	be more than one stripe unit.
 *   2. When write accesses only part of the failed SU, we assume accesses of
 *	more than one stripe unit are not allowed so that the write can be
 *	dealt with like a large write.
 * The following function is based on these assumptions. So except in the
 * second case, it looks the same as a large write encoding function. But
 * this is not exactly the normal way of doing a degraded write, since
 * RAIDframe has to break cases of accesses other than the above two into
 * smaller accesses. We may have to change DegrESubroutin in the future.
 *****************************************************************************/
void
rf_DegrESubroutine(RF_DagNode_t *node, char *ebuf)
d251 1
a251 1
	int i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
d253 1
a253 1
	char *srcbuf, *destbuf;
d274 9
a282 8
/*****************************************************************************
 * This function is used in case where one data disk failed and both redundant
 * disks are alive. It is used in the EO_100_CreateWriteDAG. Note: if there is
 * another disk failed in the stripe but not accessed at this time, then we
 * should, instead, use the rf_EOWriteDoubleRecoveryFunc().
 *****************************************************************************/
int
rf_Degraded_100_EOFunc(RF_DagNode_t *node)
d285 1
a285 1
	rf_RecoveryXorFunc(node);	/* Does the wakeup here ! */
d287 2
a288 2
	return (0);		/* XXX This was missing... Should these be
				 * void functions ??? GO */
d291 22
d314 2
a315 29

/*****************************************************************************
 * This function is to encode one sector in one of the data disks to the E
 * disk. However, in evenodd this function can also be used as decoding
 * function to recover data from dead disk in the case of parity failure and
 * a single data failure.
 *****************************************************************************/
void
rf_e_EncOneSect(RF_RowCol_t srcLogicCol, char *srcSecbuf,
    RF_RowCol_t destLogicCol, char *destSecbuf, int bytesPerSector)
{
	int S_index;		/*
				 * Index of the EU in the src col which need
				 * be Xored into all EUs in a dest sector.
				 */
	int numRowInEncMatrix = (RF_EO_MATRIX_DIM) - 1;
	RF_RowCol_t j, indexInDest;	/*
					 * Row index of an encoding unit in
					 * the destination column of encoding
					 * matrix.
					 */
	RF_RowCol_t indexInSrc;	/*
				 * Row index of an encoding unit in the source
				 * column used for recovery.
				 */
	int bytesPerEU = bytesPerSector / numRowInEncMatrix;

#if	RF_EO_MATRIX_DIM > 17
	int shortsPerEU = bytesPerEU / sizeof(short);
d318 3
a320 3
#elif	RF_EO_MATRIX_DIM == 17
	int longsPerEU = bytesPerEU / sizeof(long);
	long *destLongBuf, *srcLongBuf1, *srcLongBuf2;
d324 1
a324 1
#if	RF_EO_MATRIX_DIM > 17
d327 1
a327 1
#elif	RF_EO_MATRIX_DIM == 17
d333 1
a333 1
#if	RF_EO_MATRIX_DIM > 17
d335 1
a335 1
#elif	RF_EO_MATRIX_DIM == 17
d339 1
a339 1
	for (indexInDest = 0; indexInDest < numRowInEncMatrix; indexInDest++) {
d342 1
a342 1
#if	RF_EO_MATRIX_DIM > 17
d347 2
a348 2
			/* Note: S_index won't be at the end row for any src
			 * col ! */
d352 1
a352 1
			 * RF_EO_MATRIX_DIM -1, then all elements are zero ! */
d357 1
a357 1
#elif	RF_EO_MATRIX_DIM == 17
d371 8
a378 3
void
rf_e_encToBuf(RF_Raid_t *raidPtr, RF_RowCol_t srcLogicCol, char *srcbuf,
    RF_RowCol_t destLogicCol, char *destbuf, int numSector)
d380 1
a380 1
	int i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
d388 1
a388 3


/*****************************************************************************
d392 4
a395 3
 *****************************************************************************/
int
rf_RecoveryEFunc(RF_DagNode_t *node)
d400 2
a401 2
	RF_RowCol_t scol;	/* source logical column */
	RF_RowCol_t fcol = rf_EUCol(layoutPtr, failedPDA->raidAddress);	/* logical column of
d403 1
a403 1
	int i;
d405 2
a406 2
	int suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char *srcbuf, *destbuf;
d432 1
a432 3


/*****************************************************************************
d434 4
a437 4
 * (in EO_110_CreateWriteDAG)
 *****************************************************************************/
int
rf_EO_DegradedWriteEFunc(RF_DagNode_t *node)
d442 1
a442 1
	return (0);		/* XXX Yet another one !!! GO */
d448 12
a459 7
/*****************************************************************************
 *	THE FUNCTION IS FOR DOUBLE DEGRADED READ AND WRITE CASES.
 *****************************************************************************/

void
rf_doubleEOdecode(RF_Raid_t *raidPtr, char **rrdbuf, char **dest,
    RF_RowCol_t *fcol, char *pbuf, char *ebuf)
d461 5
a465 5
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &(raidPtr->Layout);
	int i, j, k, f1, f2, row;
	int rrdrow, erow, count = 0;
	int bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
	int numRowInEncMatrix = (RF_EO_MATRIX_DIM) - 1;
d467 1
a467 1
	int pcol = (RF_EO_MATRIX_DIM) - 1;
d469 7
a475 8
	int ecol = (RF_EO_MATRIX_DIM) - 2;
	int bytesPerEU = bytesPerSector / numRowInEncMatrix;
	int numDataCol = layoutPtr->numDataCol;
#if	RF_EO_MATRIX_DIM > 17
	int shortsPerEU = bytesPerEU / sizeof(short);
	short *rrdbuf_current, *pbuf_current, *ebuf_current;
	short *dest_smaller, *dest_smaller_current;
	short *dest_larger, *dest_larger_current;
d477 1
a477 1
	short *P;
d482 4
a485 5
#elif	RF_EO_MATRIX_DIM == 17
	int longsPerEU = bytesPerEU / sizeof(long);
	long *rrdbuf_current, *pbuf_current, *ebuf_current;
	long *dest_smaller, *dest_smaller_current;
	long *dest_larger, *dest_larger_current;
d487 1
a487 1
	long *P;
d498 4
a501 6
	/*
	 * Calculate the 'P' parameter, which, not parity, is the Xor of all
	 * elements in the last two column, ie. 'E' and 'parity' columns, see
	 * the Ref. paper by Blaum, et al 1993.
	 */
	for (i = 0; i < numRowInEncMatrix; i++)
d503 1
a503 1
#if	RF_EO_MATRIX_DIM > 17
d506 1
a506 1
#elif	RF_EO_MATRIX_DIM == 17
d515 1
a515 1
#if	RF_EO_MATRIX_DIM > 17
d518 1
a518 1
#elif	RF_EO_MATRIX_DIM == 17
d525 1
a525 1
#if	RF_EO_MATRIX_DIM > 17
d528 1
a528 1
#elif	RF_EO_MATRIX_DIM == 17
d536 2
a537 3
	while ((row = rf_EO_Mod((row + f1 - f2), RF_EO_MATRIX_DIM)) !=
	    ((RF_EO_MATRIX_DIM) - 1)) {
#if	RF_EO_MATRIX_DIM > 17
d540 1
a540 1
#elif	RF_EO_MATRIX_DIM == 17
d544 3
a546 6
		/*
		 * Do the diagonal recovery. Initially, temp[k] = (failed 1),
		 * which is the failed data in the column that has smaller
		 * col index.
		 */
		/* Step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3)) */
d552 2
a553 3
#if	RF_EO_MATRIX_DIM > 17
				rrdbuf_current = (short *) (rrdbuf[j]) +
				    rrdrow * shortsPerEU;
d556 2
a557 3
#elif	RF_EO_MATRIX_DIM == 17
				rrdbuf_current = (long *) (rrdbuf[j]) +
				    rrdrow * longsPerEU;
d563 5
a567 7
		/*
		 * Step 2:  ^E(erow,m-2), If erow is at the bottom row, don't
		 * Xor into it.  E(erow,m-2) = (principle diagonal) ^ (failed
		 * 1) ^ (failed 2) ^ (SUM of nonfailed in-diagonal
		 * A(rrdrow,0..m-3))
		 * After this step, temp[k] = (principle diagonal) ^ (failed 2).
		 */
d571 1
a571 1
#if	RF_EO_MATRIX_DIM > 17
d575 1
a575 1
#elif	RF_EO_MATRIX_DIM == 17
d581 4
a584 6
		/*
		 * Step 3: ^P to obtain the failed data (failed 2). P can be
		 * proved to be actually (principal diagonal). After this
		 * step, temp[k] = (failed 2), the failed data to be recovered.
		 */
#if	RF_EO_MATRIX_DIM > 17
d587 1
a587 1
		/* Put the data into the destination buffer. */
d590 1
a590 1
#elif	RF_EO_MATRIX_DIM == 17
d593 1
a593 1
		/* Put the data into the destination buffer. */
d598 3
a600 5
		/* THE FOLLOWING DO THE HORIZONTAL XOR. */
		/*
		 * Step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data
		 * columns.
		 */
d604 2
a605 3
#if	RF_EO_MATRIX_DIM > 17
			rrdbuf_current = (short *) (rrdbuf[j]) +
			    row * shortsPerEU;
d608 2
a609 3
#elif	RF_EO_MATRIX_DIM == 17
			rrdbuf_current = (long *) (rrdbuf[j]) +
			    row * longsPerEU;
d614 3
a616 3
		/* Step 2: ^A(row,m-1) */
		/* Step 3: Put the data into the destination buffer. */
#if	RF_EO_MATRIX_DIM > 17
d622 1
a622 1
#elif	RF_EO_MATRIX_DIM == 17
d631 4
a634 6
	/*
	 * Check if all Encoding Unit in the data buffer have been decoded ?
	 * According to EvenOdd theory, if "RF_EO_MATRIX_DIM" is a prime
	 * number, this algorithm will covered all buffer.
	 */
	RF_ASSERT(count == numRowInEncMatrix);
d640 12
a651 10
/*****************************************************************************
 *	This function is called by double degraded read EO_200_CreateReadDAG.
 *****************************************************************************/
int
rf_EvenOddDoubleRecoveryFunc(RF_DagNode_t *node)
{
	int ndataParam = 0;
	int np = node->numParams;
	RF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *)
	    node->params[np - 1].p;
d654 1
a654 1
	int i, prm, sector, nresults = node->numResults;
d657 3
a659 5
	int two = 0, mallc_one = 0, mallc_two = 0;	/*
							 * Flags to indicate if
							 * memory is allocated.
							 */
	int bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
d661 4
a664 5
	    npda;
	RF_RowCol_t fcol[2], fsuoff[2], fsuend[2],
	    numDataCol = layoutPtr->numDataCol;
	char **buf, *ebuf, *pbuf, *dest[2];
	long *suoff = NULL, *suend = NULL, *prmToCol = NULL, psuoff, esuoff;
d671 2
a672 4
	/*
	 * Find out the number of parameters that are pdas for data
	 * information.
	 */
d674 1
a674 2
		if (((RF_PhysDiskAddr_t *) node->params[i].p)->type !=
		    RF_PDA_TYPE_DATA) {
d685 2
a686 3
	    (asmap->failedPDAs[1]->numSector +
	     asmap->failedPDAs[0]->numSector) < secPerSU) {
		RF_ASSERT(0);	/* Currently, no support for this situation. */
d702 5
a706 7
	 * The followings have three goals:
	 *   1. Determine the startSector to begin decoding and endSector
	 *	to end decoding.
	 *   2. Determine the column numbers of the two failed disks.
	 *   3. Determine the offset and end offset of the access within
	 *	each failed stripe unit.
	 */
d708 1
a708 1
		/* Find the startSector to begin decoding. */
d716 1
a716 1
		/* Find out the column of failed disk being accessed. */
d719 2
a720 3
		/* Find out the other failed column not accessed. */
		sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
		    asmap->raidAddress);
d723 3
a725 6
			(raidPtr->Layout.map->MapSector) (raidPtr,
			    npda.raidAddress, &(npda.row), &(npda.col),
			    &(npda.startSector), 0);
			/* Skip over dead disks. */
			if (RF_DEAD_DISK(raidPtr
			    ->Disks[npda.row][npda.col].status))
d737 2
a738 4
		/*
		 * Determine the failed column numbers of the two failed
		 * disks.
		 */
d741 2
a742 4
		/*
		 * Determine the offset and end offset of the access within
		 * each failed stripe unit.
		 */
d747 1
a747 1
		/* Determine the startSector to begin decoding. */
d749 1
a749 1
		/* Determine the endSector to end decoding. */
d753 3
a755 3
	 * Assign the beginning sector and the end sector for each parameter.
	 * Find out the corresponding column # for each parameter.
	 */
d762 6
a767 9
	/*
	 * 'sector' is the sector for the current decoding algorithm. For each
	 * sector in the failed SU
	 * 1. Find out the corresponding parameters that cover the current
	 *    sector and that are needed for the decoding of this sector in
	 *    failed SU.
	 * 2. Find out if sector is in the shadow of any accessed failed SU.
	 *    If not, malloc a temporary space of a sector in size.
	 */
d770 1
a770 2
			if (!(fsuoff[0] <= sector && sector < fsuend[0]) &&
			    !(fsuoff[1] <= sector && sector < fsuend[1]))
d774 3
a776 6
				buf[(prmToCol[prm])] = ((RF_PhysDiskAddr_t *)
				    node->params[prm].p)->bufPtr +
				    rf_RaidAddressToByte(raidPtr,
				     sector - suoff[prm]);
		/*
		 * Find out if sector is in the shadow of any accessed failed
d778 1
a778 1
		 * position of the buffer corresponding to failed SUs. If no,
d780 1
a780 2
		 * destination of decoding.
		 */
d783 2
a784 4
			dest[0] = ((RF_PhysDiskAddr_t *)
			    node->results[0])->bufPtr +
			    rf_RaidAddressToByte(raidPtr, sector - fsuoff[0]);
			/* Always malloc temp buffer to dest[1]. */
d790 1
a790 4
				dest[0] = ((RF_PhysDiskAddr_t *)
				    node->results[0])->bufPtr +
				    rf_RaidAddressToByte(raidPtr,
				     sector - fsuoff[0]);
d797 1
a797 4
				dest[1] = ((RF_PhysDiskAddr_t *)
				    node->results[1])->bufPtr +
				    rf_RaidAddressToByte(raidPtr,
				     sector - fsuoff[1]);
d805 2
a806 4
		pbuf = ppda->bufPtr + rf_RaidAddressToByte(raidPtr,
		    sector - psuoff);
		ebuf = epda->bufPtr + rf_RaidAddressToByte(raidPtr,
		    sector - esuoff);
d808 3
a810 3
		 * After finish finding all needed sectors, call doubleEOdecode
		 * function for decoding one sector to destination.
		 */
d812 2
a813 4
		/*
		 * Free all allocated memory, and mark flag to indicate no
		 * memory is being allocated.
		 */
d833 1
a833 1
	return (0);		/* XXX Is this even close !!?!?!!? GO */
d838 3
a840 5
/*
 * Currently, only access of one of the two failed SU is allowed in this
 * function. Also, asmap->numStripeUnitsAccessed is limited to be one,
 * the RAIDframe will break large access into many accesses of single
 * stripe unit.
d843 3
a845 2
int
rf_EOWriteDoubleRecoveryFunc(RF_DagNode_t *node)
d847 2
a848 3
	int np = node->numParams;
	RF_AccessStripeMap_t *asmap =
	    (RF_AccessStripeMap_t *) node->params[np - 1].p;
d850 1
a850 1
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &(raidPtr->Layout);
d853 1
a853 1
	int prm, i, j;
d861 1
a861 2
	char **buf;		/*
				 * buf[0], buf[1], buf[2], ... etc, point to
d863 2
a864 3
				 * col2.
				 */
	char *ebuf, *pbuf, *dest[2], *olddata[2];
d868 1
a868 2
	RF_ASSERT(asmap->numDataFailed == 1);	/*
						 * Currently only support this
d870 1
a870 2
						 * is not being accessed.
						 */
d874 2
a875 5
	ppda = node->results[0];	/*
					 * Instead of being buffers,
					 * node->results[0] and [1]
					 * are Ppda and Epda.
					 */
d879 2
a880 2
	/* First, recovery the failed old SU using EvenOdd double decoding. */
	/* Determine the startSector and endSector for decoding. */
d883 1
a883 2
	/*
	 * Assign buf[col] pointers to point to each non-failed column and
d885 1
a885 1
	 * source buffers and destination buffers. */
d891 2
a892 4
	/*
	 * pbuf and ebuf: They will change values as double recovery decoding
	 * goes on.
	 */
d895 2
a896 4
	/*
	 * Find out the logical column numbers in the encoding matrix of the
	 * two failed columns.
	 */
d899 2
a900 3
	/* Find out the other failed column not accessed this time. */
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
	    asmap->raidAddress);
d903 2
a904 3
		(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress,
		    &(npda.row), &(npda.col), &(npda.startSector), 0);
		/* Skip over dead disks. */
d911 1
a911 1
	/* Assign temporary space to put recovered failed SU. */
d919 1
a919 2
	/*
	 * Begin the recovery decoding, initially buf[j], ebuf, pbuf, dest[j]
d921 1
a921 2
	 * destination buffers.
	 */
d932 1
a932 2
	/*
	 * After recovery, the buffer pointed by olddata[0] is the old failed
d934 2
a935 4
	 * calculate the new redundant informations.
	 */
	/*
	 * node->params[ 0, ... PDAPerDisk * (numDataCol - 2)-1 ] are Pdas of
d945 1
a945 2
	 * write.
	 */
d947 4
a950 7
	rf_bxor(((RF_PhysDiskAddr_t *) node->params[numDataCol].p)->bufPtr,
	    olddata[0], numbytes, node->dagHdr->bp);
	/* Do new 'E' calculation. */
	/*
	 * Find out the corresponding column in encoding matrix for write
	 * column to be encoded into redundant disk 'E'.
	 */
d952 3
a954 6
	/*
	 * olddata[0] now is source buffer pointer; epda->bufPtr is the dest
	 * buffer pointer.
	 */
	rf_e_encToBuf(raidPtr, scol, olddata[0], RF_EO_MATRIX_DIM - 2,
	    epda->bufPtr, fpda->numSector);
d956 1
a956 1
	/* Do new 'P' calculation. */
d958 1
a958 1
	/* Free the allocated buffer. */
@


1.4
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_evenodd_dagfuncs.c,v 1.3 1999/10/29 08:57:17 todd Exp $	*/
/*	$NetBSD: rf_evenodd_dagfuncs.c,v 1.3 1999/08/13 03:41:56 oster Exp $	*/
a42 1
#include "rf_threadid.h"
@


1.3
log
@writen->written
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_evenodd_dagfuncs.c,v 1.2 1999/02/16 00:02:44 niklas Exp $	*/
/*	$NetBSD: rf_evenodd_dagfuncs.c,v 1.2 1999/02/05 00:06:11 oster Exp $	*/
a47 1
#include "rf_sys.h"
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_evenodd_dagfuncs.c,v 1.1 1999/01/11 14:29:21 niklas Exp $	*/
d945 1
a945 1
	 * data to be writen to the failed disk. We first bxor the new data
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_evenodd_dagfuncs.c,v 1.1 1998/11/13 04:20:29 oster Exp $	*/
/*	$NetBSD: rf_evenodd_dagfuncs.c,v 1.1 1998/11/13 04:20:29 oster Exp $	*/
d53 2
a54 3
RF_RedFuncs_t rf_EOSmallWritePFuncs = { rf_RegularXorFunc, "Regular Old-New P", rf_SimpleXorFunc, "Simple Old-New P" };
RF_RedFuncs_t rf_EOSmallWriteEFuncs = { rf_RegularONEFunc, "Regular Old-New E", rf_SimpleONEFunc, "Regular Old-New E" }; 

d56 2
a57 3
RF_RedFuncs_t rf_eoPRecoveryFuncs =  { rf_RecoveryXorFunc, "Recovery Xr", rf_RecoveryXorFunc, "Recovery Xr"};
RF_RedFuncs_t rf_eoERecoveryFuncs = { rf_RecoveryEFunc, "Recovery E Func", rf_RecoveryEFunc, "Recovery E Func" };

d59 1
a59 1
 *   the following encoding node functions is used in  EO_000_CreateLargeWriteDAG 
d61 3
a63 2
int rf_RegularPEFunc(node)
  RF_DagNode_t  *node;
d65 2
a66 2
   rf_RegularESubroutine(node,node->results[1]);   
   rf_RegularXorFunc(node);    /* does the wakeup here! */
d68 1
a68 1
   return(0); /* XXX This was missing... GO */
d82 1
a82 1
/* Algorithm: 
d84 1
a84 1
     2. then encode this buffer into the buffer which already have old 'E' information inside it, 
d87 2
a88 2
   Here we have another alternative: to allocate a temporary buffer for storing the difference of 
   old data and new data, then encode temp buf into old 'E' buf to form new 'E', but this approach 
d91 51
a141 43
int rf_RegularONEFunc(node)
  RF_DagNode_t  *node;
{
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams-1].p;
  RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &raidPtr->Layout;
  int EpdaIndex = (node->numParams-1)/2 - 1; /* the parameter of node where you can find e-pda */ 
  int i, k, retcode = 0;
  int suoffset, length;
  RF_RowCol_t scol;
  char *srcbuf, *destbuf;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;
  RF_PhysDiskAddr_t *pda, *EPDA = (RF_PhysDiskAddr_t *) node->params[EpdaIndex].p; 
  int ESUOffset = rf_StripeUnitOffset(layoutPtr, EPDA->startSector); /* generally zero  */

  RF_ASSERT( EPDA->type == RF_PDA_TYPE_Q );
  RF_ASSERT(ESUOffset == 0);

  RF_ETIMER_START(timer);
 
  /* Xor the Wnd buffer into Rod buffer, the difference of old data and new data is stored in Rod buffer */
  for( k=0; k< EpdaIndex; k += 2) {
   length = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *)node->params[k].p)->numSector );
   retcode = rf_bxor( node->params[k+EpdaIndex+3].p, node->params[k+1].p, length, node->dagHdr->bp);   
  }
  /* Start to encoding the buffer storing the difference of old data and new data into 'E' buffer  */
  for (i=0; i<EpdaIndex; i+=2) if (node->params[i+1].p != node->results[0]) { /* results[0] is buf ptr of E */
    pda = (RF_PhysDiskAddr_t *) node->params[i].p;
    srcbuf = (char *) node->params[i+1].p;
    scol = rf_EUCol(layoutPtr, pda->raidAddress );
    suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
    destbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr,suoffset); 
    rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);
  }
  /* Recover the original old data to be used by parity encoding function in XorNode */
  for( k=0; k< EpdaIndex; k += 2) {
   length = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *)node->params[k].p)->numSector );
   retcode = rf_bxor( node->params[k+EpdaIndex+3].p, node->params[k+1].p, length, node->dagHdr->bp);
  }
  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  tracerec->q_us += RF_ETIMER_VAL_US(timer);
  rf_GenericWakeupFunc(node, 0);  
d143 1
a143 1
  return(0); /* XXX this was missing.. GO */
d147 37
a183 30
int rf_SimpleONEFunc(node)
  RF_DagNode_t   *node;
{
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams-1].p;
  RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &raidPtr->Layout;
  RF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;
  int retcode = 0;
  char *srcbuf, *destbuf;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  int length;
  RF_RowCol_t scol;
  RF_Etimer_t timer;

  RF_ASSERT( ((RF_PhysDiskAddr_t *)node->params[2].p)->type == RF_PDA_TYPE_Q );
  if (node->dagHdr->status == rf_enable) { 
     RF_ETIMER_START(timer);
     length = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *)node->params[4].p)->numSector );/* this is a pda of writeDataNodes */
     /* bxor to buffer of readDataNodes */
     retcode = rf_bxor( node->params[5].p, node->params[1].p, length, node->dagHdr->bp);
     /* find out the corresponding colume in encoding matrix for write colume to be encoded into redundant disk 'E' */
     scol = rf_EUCol(layoutPtr, pda->raidAddress ); 
     srcbuf = node->params[1].p;
     destbuf = node->params[3].p;
     /* Start encoding process */
     rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);   
     rf_bxor( node->params[5].p, node->params[1].p, length, node->dagHdr->bp);
     RF_ETIMER_STOP(timer); RF_ETIMER_EVAL(timer); tracerec->q_us += RF_ETIMER_VAL_US(timer); 

  }
  return(rf_GenericWakeupFunc(node, retcode));     /* call wake func explicitly since no I/O in this node */
d188 27
a214 26
void rf_RegularESubroutine(node, ebuf)
  RF_DagNode_t  *node;
  char          *ebuf;
{
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams-1].p;
  RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &raidPtr->Layout;
  RF_PhysDiskAddr_t *pda;
  int i, suoffset;
  RF_RowCol_t scol;
  char *srcbuf, *destbuf;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;

  RF_ETIMER_START(timer);
  for (i=0; i<node->numParams-2; i+=2) {
    RF_ASSERT( node->params[i+1].p != ebuf );
    pda = (RF_PhysDiskAddr_t *) node->params[i].p;
    suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
    scol = rf_EUCol(layoutPtr, pda->raidAddress );
    srcbuf = (char *) node->params[i+1].p;
    destbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset );
    rf_e_encToBuf(raidPtr,  scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);
  }
  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  tracerec->xor_us += RF_ETIMER_VAL_US(timer);
d219 1
a219 1
 *			 Used in  EO_001_CreateLargeWriteDAG                      
d221 3
a223 2
int rf_RegularEFunc(node)  
  RF_DagNode_t  *node;
d225 2
a226 2
   rf_RegularESubroutine(node, node->results[0]);  
   rf_GenericWakeupFunc(node, 0);
d228 1
a228 1
   return(0); /* XXX this was missing?.. GO */
a230 1

d232 2
a233 2
 * This degraded function allow only two case: 
 *  1. when write access the full failed stripe unit, then the access can be more than 
d235 4
a238 4
 *  2. when write access only part of the failed SU, we assume accesses of more than 
 *     one stripe unit is not allowed so that the write can be dealt with like a 
 *     large write. 
 *  The following function is based on these assumptions. So except in the second case, 
d240 3
a242 3
 *  normal way for doing a degraded write, since raidframe have to break cases of access 
 *  other than the above two into smaller accesses. We may have to change 
 *  DegrESubroutin in the future.  
d244 29
a272 26
void rf_DegrESubroutine(node, ebuf)
  RF_DagNode_t  *node;
  char          *ebuf;
{
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams-1].p;
  RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &raidPtr->Layout;
  RF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams-2].p;
  RF_PhysDiskAddr_t *pda;
  int i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
  RF_RowCol_t scol;
  char *srcbuf, *destbuf;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;

  RF_ETIMER_START(timer);
  for (i=0; i<node->numParams-2; i+=2) {
    RF_ASSERT( node->params[i+1].p != ebuf );
    pda = (RF_PhysDiskAddr_t *) node->params[i].p;
    suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
    scol = rf_EUCol(layoutPtr, pda->raidAddress );
    srcbuf = (char *) node->params[i+1].p;
    destbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset-failedSUOffset);
    rf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);
  }

  RF_ETIMER_STOP(timer); RF_ETIMER_EVAL(timer); tracerec->q_us += RF_ETIMER_VAL_US(timer);
d277 1
a277 1
 * This function is used in case where one data disk failed and both redundant disks 
d282 3
a284 2
int rf_Degraded_100_EOFunc(node)
  RF_DagNode_t  *node;
d286 2
a287 2
  rf_DegrESubroutine(node, node->results[1]);
  rf_RecoveryXorFunc(node);  /* does the wakeup here! */
d289 2
a290 1
  return(0); /* XXX this was missing... SHould these be void functions??? GO */
a292 1

d295 1
a295 1
 * However, in evenodd this function can also be used as decoding function to recover 
d298 7
a304 6
void rf_e_EncOneSect(
  RF_RowCol_t   srcLogicCol,
  char         *srcSecbuf,
  RF_RowCol_t   destLogicCol,
  char         *destSecbuf,
  int           bytesPerSector)
d306 9
a314 5
  int S_index;  /* index of the EU in the src col which need be Xored into all EUs in a dest sector */
  int numRowInEncMatix = (RF_EO_MATRIX_DIM) -1; 
  RF_RowCol_t j, indexInDest,   /* row index of an encoding unit in the destination colume of encoding matrix */
              indexInSrc;  /* row index of an encoding unit in the source colume used for recovery */
  int bytesPerEU = bytesPerSector/numRowInEncMatix;
d317 3
a319 3
  int shortsPerEU = bytesPerEU/sizeof(short);
  short *destShortBuf, *srcShortBuf1, *srcShortBuf2;
  register short temp1;
d321 3
a323 3
  int longsPerEU = bytesPerEU/sizeof(long);
  long *destLongBuf, *srcLongBuf1, *srcLongBuf2;
  register long temp1;
d327 2
a328 2
  RF_ASSERT( sizeof(short) == 2 || sizeof(short) == 1 );
  RF_ASSERT( bytesPerEU % sizeof(short) == 0 );
d330 2
a331 2
  RF_ASSERT( sizeof(long) == 8 || sizeof(long) == 4 );
  RF_ASSERT( bytesPerEU % sizeof(long) == 0);
d334 1
a334 1
  S_index = rf_EO_Mod( ( RF_EO_MATRIX_DIM -1 + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);
d336 1
a336 1
  srcShortBuf1 = (short *)(srcSecbuf + S_index * bytesPerEU);
d338 1
a338 1
  srcLongBuf1 = (long *)(srcSecbuf + S_index * bytesPerEU);
d341 2
a342 2
  for( indexInDest = 0; indexInDest < numRowInEncMatix ; indexInDest++){
     indexInSrc = rf_EO_Mod( (indexInDest + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM );
d345 13
a357 9
     destShortBuf = (short *)(destSecbuf + indexInDest * bytesPerEU);
     srcShortBuf2 = (short *)(srcSecbuf + indexInSrc * bytesPerEU);
     for(j=0; j < shortsPerEU; j++) {
        temp1 = destShortBuf[j]^srcShortBuf1[j];
        /* note: S_index won't be at the end row for any src col! */
        if(indexInSrc != RF_EO_MATRIX_DIM -1) destShortBuf[j] = (srcShortBuf2[j])^temp1;
        /* if indexInSrc is at the end row, ie. RF_EO_MATRIX_DIM -1, then all elements are zero! */
	else destShortBuf[j] = temp1;
     }
d360 9
a368 7
     destLongBuf = (long *)(destSecbuf + indexInDest * bytesPerEU);
     srcLongBuf2 = (long *)(srcSecbuf + indexInSrc * bytesPerEU);
     for(j=0; j < longsPerEU; j++) {
        temp1 = destLongBuf[j]^srcLongBuf1[j];
        if(indexInSrc != RF_EO_MATRIX_DIM -1) destLongBuf[j] = (srcLongBuf2[j])^temp1;
        else destLongBuf[j] = temp1;
     }
d370 1
a370 1
  }
d373 8
a380 7
void rf_e_encToBuf(
  RF_Raid_t    *raidPtr,
  RF_RowCol_t   srcLogicCol,
  char         *srcbuf,
  RF_RowCol_t   destLogicCol,
  char         *destbuf,
  int           numSector)
d382 1
a382 1
  int i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);
d384 5
a388 6
  for (i=0; i < numSector; i++)
  {
     rf_e_EncOneSect( srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);
     srcbuf += bytesPerSector; 
     destbuf += bytesPerSector; 
  }
d390 4
a393 5

/**************************************************************************************  
 * when parity die and one data die, We use second redundant information, 'E', 
 * to recover the data in dead disk. This function is used in the recovery node of 
 * for EO_110_CreateReadDAG 
d395 38
a432 32
int rf_RecoveryEFunc(node)   
  RF_DagNode_t  *node;
{
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams-1].p;
  RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &raidPtr->Layout;
  RF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams-2].p;
  RF_RowCol_t scol, /*source logical column*/ 
              fcol = rf_EUCol(layoutPtr, failedPDA->raidAddress ); /* logical column of failed SU */
  int i;
  RF_PhysDiskAddr_t *pda;
  int suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr,failedPDA->startSector);
  char *srcbuf, *destbuf;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;

  bzero( (char *)node->results[0], rf_RaidAddressToByte(raidPtr,failedPDA->numSector));
  if (node->dagHdr->status == rf_enable) {
    RF_ETIMER_START(timer);
    for (i=0; i<node->numParams-2; i+=2) if (node->params[i+1].p != node->results[0]) {
      pda = (RF_PhysDiskAddr_t *) node->params[i].p;
      if( i == node->numParams - 4 ) scol = RF_EO_MATRIX_DIM - 2; /* the colume of redundant E */
      else scol = rf_EUCol(layoutPtr, pda->raidAddress ); 
      srcbuf = (char *) node->params[i+1].p;
      suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
      destbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr,suoffset-failedSUOffset);
      rf_e_encToBuf(raidPtr,  scol, srcbuf, fcol, destbuf, pda->numSector);
    }          
    RF_ETIMER_STOP(timer);
    RF_ETIMER_EVAL(timer);
    tracerec->xor_us += RF_ETIMER_VAL_US(timer);
  }
  return (rf_GenericWakeupFunc(node, 0)); /* node execute successfully */
a433 1

d438 2
a439 1
int rf_EO_DegradedWriteEFunc(RF_DagNode_t *node)
d441 2
a442 2
  rf_DegrESubroutine(node, node->results[0]);
  rf_GenericWakeupFunc(node, 0);
d444 1
a444 1
  return(0); /* XXX Yet another one!! GO */
d449 1
a449 1
                                                       
d454 14
a467 13
void rf_doubleEOdecode(
  RF_Raid_t     *raidPtr,
  char         **rrdbuf,
  char         **dest,
  RF_RowCol_t   *fcol,
  char          *pbuf,
  char          *ebuf)
{
  RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &(raidPtr->Layout);
  int i, j, k, f1, f2, row;
  int rrdrow, erow, count = 0;
  int bytesPerSector = rf_RaidAddressToByte(raidPtr, 1 );
  int numRowInEncMatix = (RF_EO_MATRIX_DIM) -1;
d469 1
a469 1
  int pcol = (RF_EO_MATRIX_DIM) - 1; 
d471 168
a638 153
  int ecol = (RF_EO_MATRIX_DIM) - 2;
  int bytesPerEU = bytesPerSector/numRowInEncMatix;
  int numDataCol  = layoutPtr->numDataCol;
#if RF_EO_MATRIX_DIM > 17
  int shortsPerEU = bytesPerEU/sizeof(short);
  short *rrdbuf_current, *pbuf_current, *ebuf_current;
  short *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;
  register short *temp;
  short *P;

  RF_ASSERT( bytesPerEU % sizeof(short) == 0);
  RF_Malloc(P, bytesPerEU, (short *));
  RF_Malloc(temp, bytesPerEU, (short *));
#elif RF_EO_MATRIX_DIM == 17
  int longsPerEU = bytesPerEU/sizeof(long);
  long *rrdbuf_current, *pbuf_current, *ebuf_current; 
  long *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;
  register long *temp;
  long *P;

  RF_ASSERT( bytesPerEU % sizeof(long) == 0);
  RF_Malloc(P, bytesPerEU, (long *));
  RF_Malloc(temp, bytesPerEU, (long *));
#endif
  RF_ASSERT( *((long *)dest[0]) == 0);
  RF_ASSERT( *((long *)dest[1]) == 0);
  bzero((char *)P, bytesPerEU);  
  bzero((char *)temp, bytesPerEU);
  RF_ASSERT( *P == 0 );
  /* calculate the 'P' parameter, which, not parity, is the Xor of all elements in 
     the last two column, ie. 'E' and 'parity' colume, see the Ref. paper by Blaum, et al 1993  */
  for( i=0; i< numRowInEncMatix; i++) 
       for( k=0; k< longsPerEU; k++) { 
#if RF_EO_MATRIX_DIM > 17
            ebuf_current = ((short *)ebuf) + i*shortsPerEU + k;
            pbuf_current = ((short *)pbuf) + i*shortsPerEU + k;
#elif RF_EO_MATRIX_DIM == 17
            ebuf_current = ((long *)ebuf) + i*longsPerEU + k;
            pbuf_current = ((long *)pbuf) + i*longsPerEU + k;
#endif
            P[k] ^= *ebuf_current;
            P[k] ^= *pbuf_current;
       }
  RF_ASSERT( fcol[0] != fcol[1] );
  if( fcol[0] < fcol[1] ) { 
#if RF_EO_MATRIX_DIM > 17
        dest_smaller = (short *)(dest[0]);
        dest_larger = (short *)(dest[1]);
#elif RF_EO_MATRIX_DIM == 17
	dest_smaller = (long *)(dest[0]); 
	dest_larger = (long *)(dest[1]); 
#endif
	f1 = fcol[0]; 
	f2 = fcol[1]; 
  }
  else { 
#if RF_EO_MATRIX_DIM > 17
        dest_smaller = (short *)(dest[1]);
        dest_larger = (short *)(dest[0]);
#elif RF_EO_MATRIX_DIM == 17
	dest_smaller = (long *)(dest[1]); 
	dest_larger = (long *)(dest[0]); 
#endif
	f1 = fcol[1]; 
	f2 = fcol[0]; 
  }
  row = (RF_EO_MATRIX_DIM) -1;
  while( (row = rf_EO_Mod( (row+f1-f2), RF_EO_MATRIX_DIM )) != ( (RF_EO_MATRIX_DIM) -1) )
  {   
#if RF_EO_MATRIX_DIM > 17
       dest_larger_current = dest_larger + row*shortsPerEU;
       dest_smaller_current = dest_smaller + row*shortsPerEU;
#elif RF_EO_MATRIX_DIM == 17
       dest_larger_current = dest_larger + row*longsPerEU;
       dest_smaller_current = dest_smaller + row*longsPerEU;
#endif
       /**    Do the diagonal recovery. Initially, temp[k] = (failed 1), 
	      which is the failed data in the colume which has smaller col index. **/
       /*   step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3))         */
       for( j=0; j< numDataCol; j++)
       {     
             if( j == f1 || j == f2 ) continue;
             rrdrow = rf_EO_Mod( (row+f2-j), RF_EO_MATRIX_DIM );
	     if ( rrdrow != (RF_EO_MATRIX_DIM) -1 ) {
#if RF_EO_MATRIX_DIM > 17
                 rrdbuf_current = (short *)(rrdbuf[j]) + rrdrow * shortsPerEU;
                 for (k=0; k< shortsPerEU; k++) temp[k] ^= *(rrdbuf_current + k);
#elif RF_EO_MATRIX_DIM == 17
	         rrdbuf_current = (long *)(rrdbuf[j]) + rrdrow * longsPerEU;
                 for (k=0; k< longsPerEU; k++) temp[k] ^= *(rrdbuf_current + k);
#endif
	     }
       }         
       /*   step 2:  ^E(erow,m-2), If erow is at the buttom row, don't Xor into it  
	    E(erow,m-2) = (principle diagonal) ^ (failed 1) ^ (failed 2)
                        ^ ( SUM of nonfailed in-diagonal A(rrdrow,0..m-3) ) 
            After this step, temp[k] = (principle diagonal) ^ (failed 2)       */

       erow = rf_EO_Mod( (row+f2-ecol), (RF_EO_MATRIX_DIM) );
       if ( erow != (RF_EO_MATRIX_DIM) -1) {  
#if RF_EO_MATRIX_DIM > 17
           ebuf_current = (short *)ebuf + shortsPerEU * erow;
           for (k=0; k< shortsPerEU; k++) temp[k] ^= *(ebuf_current+k);
#elif RF_EO_MATRIX_DIM == 17
           ebuf_current = (long *)ebuf + longsPerEU * erow;
           for (k=0; k< longsPerEU; k++) temp[k] ^= *(ebuf_current+k);
#endif
       }
       /*   step 3: ^P to obtain the failed data (failed 2).  
	    P can be proved to be actually  (principle diagonal)  
            After this step, temp[k] = (failed 2), the failed data to be recovered */
#if RF_EO_MATRIX_DIM > 17
       for (k=0; k< shortsPerEU; k++) temp[k] ^= P[k];
       /*   Put the data to the destination buffer                              */
       for (k=0; k< shortsPerEU; k++) dest_larger_current[k] = temp[k];
#elif RF_EO_MATRIX_DIM == 17
       for (k=0; k< longsPerEU; k++) temp[k] ^= P[k];
       /*   Put the data to the destination buffer                              */
       for (k=0; k< longsPerEU; k++) dest_larger_current[k] = temp[k];
#endif

       /**          THE FOLLOWING DO THE HORIZONTAL XOR                **/ 
       /*   step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data columes    */ 
       for (j=0; j< numDataCol; j++)      
       {
             if( j == f1 || j == f2 ) continue;
#if RF_EO_MATRIX_DIM > 17
             rrdbuf_current = (short *)(rrdbuf[j]) + row * shortsPerEU;
             for (k=0; k< shortsPerEU; k++) temp[k] ^= *(rrdbuf_current+k);
#elif RF_EO_MATRIX_DIM == 17
	     rrdbuf_current = (long *)(rrdbuf[j]) + row * longsPerEU;
             for (k=0; k< longsPerEU; k++) temp[k] ^= *(rrdbuf_current+k);
#endif
       } 
       /*   step 2: ^A(row,m-1) */
       /*   step 3: Put the data to the destination buffer                             	*/
#if RF_EO_MATRIX_DIM > 17
       pbuf_current = (short *)pbuf + shortsPerEU * row;
       for (k=0; k< shortsPerEU; k++) temp[k] ^= *(pbuf_current+k);
       for (k=0; k< shortsPerEU; k++) dest_smaller_current[k] = temp[k];
#elif RF_EO_MATRIX_DIM == 17
       pbuf_current = (long *)pbuf + longsPerEU * row;
       for (k=0; k< longsPerEU; k++) temp[k] ^= *(pbuf_current+k);      
       for (k=0; k< longsPerEU; k++) dest_smaller_current[k] = temp[k];
#endif
       count++;  
  }
  /*        Check if all Encoding Unit in the data buffer have been decoded, 
	    according EvenOdd theory, if "RF_EO_MATRIX_DIM" is a prime number, 
	    this algorithm will covered all buffer 				 */
  RF_ASSERT( count == numRowInEncMatix );
  RF_Free((char *)P, bytesPerEU);
  RF_Free((char *)temp, bytesPerEU);
d640 1
a640 1
 
d644 1
a644 1
* 	EO_200_CreateReadDAG 								      
d647 187
a833 167
int rf_EvenOddDoubleRecoveryFunc(node)
  RF_DagNode_t  *node;
{
  int ndataParam = 0; 
  int np = node->numParams;
  RF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np-1].p;
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np-2].p;
  RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &(raidPtr->Layout);
  int i, prm, sector, nresults = node->numResults;
  RF_SectorCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;
  unsigned sosAddr;
  int two = 0, mallc_one= 0, mallc_two = 0;    /* flags to indicate if memory is allocated */
  int bytesPerSector = rf_RaidAddressToByte(raidPtr, 1 );
  RF_PhysDiskAddr_t *ppda,*ppda2,*epda,*epda2,*pda, *pda0, *pda1, npda;
  RF_RowCol_t fcol[2], fsuoff[2], fsuend[2], numDataCol = layoutPtr->numDataCol;
  char **buf, *ebuf, *pbuf, *dest[2];
  long *suoff=NULL, *suend=NULL, *prmToCol=NULL, psuoff, esuoff;
  RF_SectorNum_t startSector, endSector;
  RF_Etimer_t timer;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;

  RF_ETIMER_START(timer);

  /* Find out the number of parameters which are pdas for data information */
  for (i = 0; i<= np; i++) 
     if( ((RF_PhysDiskAddr_t *)node->params[i].p)->type != RF_PDA_TYPE_DATA) {ndataParam = i ; break; }

  RF_Malloc(buf, numDataCol*sizeof(char *), (char **));
  if (ndataParam != 0 ){
      RF_Malloc(suoff, ndataParam*sizeof(long), (long *) );
      RF_Malloc(suend, ndataParam*sizeof(long), (long *) );
      RF_Malloc(prmToCol, ndataParam*sizeof(long), (long *) );
  }

  if (asmap->failedPDAs[1] &&
      (asmap->failedPDAs[1]->numSector + asmap->failedPDAs[0]->numSector < secPerSU)) {
      RF_ASSERT(0); /* currently, no support for this situation */
      ppda  = node->params[np-6].p;
      ppda2 = node->params[np-5].p;
      RF_ASSERT( ppda2->type == RF_PDA_TYPE_PARITY );
      epda  = node->params[np-4].p;
      epda2 = node->params[np-3].p;
      RF_ASSERT( epda2->type == RF_PDA_TYPE_Q );
      two = 1;
  } 
  else {
      ppda = node->params[np-4].p;
      epda = node->params[np-3].p;
      psuoff = rf_StripeUnitOffset(layoutPtr, ppda->startSector);
      esuoff = rf_StripeUnitOffset(layoutPtr, epda->startSector);
      RF_ASSERT( psuoff == esuoff );
  }
  /*
      the followings have three goals:
      1. determine the startSector to begin decoding and endSector to end decoding.
      2. determine the colume numbers of the two failed disks. 
      3. determine the offset and end offset of the access within each failed stripe unit.
   */
  if( nresults == 1 ) {  
      /* find the startSector to begin decoding */
      pda = node->results[0]; 
      bzero(pda->bufPtr, bytesPerSector*pda->numSector );
      fsuoff[0] = rf_StripeUnitOffset(layoutPtr, pda->startSector );
      fsuend[0] = fsuoff[0] + pda->numSector;
      startSector = fsuoff[0];
      endSector = fsuend[0];

      /* find out the the column of failed disk being accessed */
      fcol[0] = rf_EUCol(layoutPtr, pda->raidAddress ); 

      /* find out the other failed colume not accessed */
      sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);
      for (i=0; i < numDataCol; i++) {
          npda.raidAddress = sosAddr + (i * secPerSU);
          (raidPtr->Layout.map->MapSector)(raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);
          /* skip over dead disks */
          if (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))
              if (i != fcol[0]) break;
      }
      RF_ASSERT (i < numDataCol);
      fcol[1] = i;
  }
  else {
      RF_ASSERT (  nresults == 2 );
      pda0 = node->results[0];  bzero(pda0->bufPtr, bytesPerSector*pda0->numSector );
      pda1 = node->results[1];  bzero(pda1->bufPtr, bytesPerSector*pda1->numSector );
      /* determine the failed colume numbers of the two failed disks. */
      fcol[0] = rf_EUCol(layoutPtr, pda0->raidAddress );
      fcol[1] = rf_EUCol(layoutPtr, pda1->raidAddress );
      /*  determine the offset and end offset of the access within each failed stripe unit. */
      fsuoff[0] = rf_StripeUnitOffset(layoutPtr, pda0->startSector );
      fsuend[0] = fsuoff[0] + pda0->numSector;
      fsuoff[1] = rf_StripeUnitOffset(layoutPtr, pda1->startSector );
      fsuend[1] = fsuoff[1] + pda1->numSector;
      /*  determine the startSector to begin decoding */
      startSector = RF_MIN( pda0->startSector, pda1->startSector );
      /*  determine the endSector to end decoding */
      endSector = RF_MAX( fsuend[0], fsuend[1] );
  }
  /*
	assign the beginning sector and the end sector for each parameter 
	find out the corresponding colume # for each parameter
  */
  for( prm=0; prm < ndataParam; prm++ ) {
      pda = node->params[prm].p;
      suoff[prm] = rf_StripeUnitOffset(layoutPtr, pda->startSector);
      suend[prm] = suoff[prm] + pda->numSector;
      prmToCol[prm] = rf_EUCol(layoutPtr, pda->raidAddress );
  }
  /* 'sector' is the sector for the current decoding algorithm. For each sector in the failed SU,
     find out the corresponding parameters that cover the current sector and that are needed for 
     decoding of this sector in failed SU. 2.  Find out if sector is in the shadow of any accessed 
     failed SU. If not, malloc a temporary space of a sector in size.
  */
  for( sector = startSector; sector < endSector; sector++ ){
     if ( nresults == 2 )
	  if( !(fsuoff[0]<=sector && sector<fsuend[0]) && !(fsuoff[1]<=sector && sector<fsuend[1]) )continue;
     for( prm=0; prm < ndataParam; prm++ )
          if( suoff[prm] <= sector && sector < suend[prm] )
               buf[(prmToCol[prm])] = ((RF_PhysDiskAddr_t *)node->params[prm].p)->bufPtr + 
					rf_RaidAddressToByte(raidPtr, sector-suoff[prm]);
     /* find out if sector is in the shadow of any accessed failed SU. If yes, assign dest[0], dest[1] to point 
	 at suitable position of the buffer corresponding to failed SUs. if no, malloc a temporary space of 
	 a sector in size for destination of decoding. 
      */
     RF_ASSERT( nresults == 1 || nresults == 2 );
     if ( nresults == 1) {
           dest[0] = ((RF_PhysDiskAddr_t *)node->results[0])->bufPtr + rf_RaidAddressToByte(raidPtr, sector-fsuoff[0]);
           /* Always malloc temp buffer to dest[1]  */
           RF_Malloc( dest[1], bytesPerSector, (char *) ); 
	   bzero(dest[1],bytesPerSector); mallc_two = 1; }
      else {
           if( fsuoff[0] <= sector && sector < fsuend[0] )
                  dest[0] = ((RF_PhysDiskAddr_t *)node->results[0])->bufPtr + rf_RaidAddressToByte(raidPtr, sector-fsuoff[0]);
           else { RF_Malloc( dest[0], bytesPerSector, (char *) ); 
		  bzero(dest[0],bytesPerSector); mallc_one = 1; } 
           if( fsuoff[1] <= sector && sector < fsuend[1] )
                  dest[1] = ((RF_PhysDiskAddr_t *)node->results[1])->bufPtr + rf_RaidAddressToByte(raidPtr, sector-fsuoff[1]);
           else { RF_Malloc( dest[1], bytesPerSector, (char *) ); 
                  bzero(dest[1],bytesPerSector); mallc_two = 1; }
           RF_ASSERT( mallc_one == 0 || mallc_two == 0 );
      }
      pbuf = ppda->bufPtr + rf_RaidAddressToByte(raidPtr, sector-psuoff );
      ebuf = epda->bufPtr + rf_RaidAddressToByte(raidPtr, sector-esuoff );
      /*
       * After finish finding all needed sectors, call doubleEOdecode function for decoding 
       * one sector to destination.
       */
      rf_doubleEOdecode(raidPtr, buf, dest, fcol, pbuf, ebuf ); 
      /* free all allocated memory, and mark flag to indicate no memory is being allocated */
      if( mallc_one == 1) RF_Free( dest[0], bytesPerSector );
      if( mallc_two == 1) RF_Free( dest[1], bytesPerSector );
      mallc_one = mallc_two = 0;
  }
  RF_Free(buf, numDataCol*sizeof(char *));
  if (ndataParam != 0){
      RF_Free(suoff, ndataParam*sizeof(long));
      RF_Free(suend, ndataParam*sizeof(long));
      RF_Free(prmToCol, ndataParam*sizeof(long));
  }

  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  if (tracerec) {
    tracerec->q_us += RF_ETIMER_VAL_US(timer);
  }
  rf_GenericWakeupFunc(node,0);
d835 1
a835 1
  return(0); /* XXX is this even close!!?!?!!? GO */
d840 2
a841 2
/* currently, only access of one of the two failed SU is allowed in this function.  
 * also, asmap->numStripeUnitsAccessed is limited to be one, the RaidFrame will break large access into 
d845 127
a971 113
int rf_EOWriteDoubleRecoveryFunc(node)
  RF_DagNode_t  *node;
{
  int np = node->numParams;
  RF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np-1].p;
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np-2].p;
  RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &(raidPtr->Layout);
  RF_SectorNum_t sector;
  RF_RowCol_t col, scol;
  int prm, i, j;
  RF_SectorCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;
  unsigned sosAddr;
  unsigned bytesPerSector = rf_RaidAddressToByte(raidPtr, 1 );
  RF_int64 numbytes;
  RF_SectorNum_t startSector, endSector;
  RF_PhysDiskAddr_t *ppda,*epda,*pda, *fpda, npda;
  RF_RowCol_t fcol[2], numDataCol = layoutPtr->numDataCol;
  char **buf; /* buf[0], buf[1], buf[2], ...etc. point to buffer storing data read from col0, col1, col2 */ 
  char *ebuf, *pbuf, *dest[2], *olddata[2];
  RF_Etimer_t timer;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;

  RF_ASSERT( asmap->numDataFailed == 1 ); /* currently only support this case, the other failed SU is not being accessed */
  RF_ETIMER_START(timer);
  RF_Malloc(buf, numDataCol*sizeof(char *), (char **));

  ppda = node->results[0];            /* Instead of being buffers, node->results[0] and [1] are Ppda and Epda  */
  epda = node->results[1];
  fpda = asmap->failedPDAs[0];

  /* First, recovery the failed old SU using EvenOdd double decoding      */
  /* determine the startSector and endSector for decoding */
  startSector = rf_StripeUnitOffset(layoutPtr, fpda->startSector );
  endSector = startSector + fpda->numSector;
  /* Assign buf[col] pointers to point to each non-failed colume  and initialize the pbuf 
     and ebuf to point at the beginning of each source buffers and destination buffers */
  for( prm=0; prm < numDataCol-2; prm++ ) {
      pda = (RF_PhysDiskAddr_t *)node->params[prm].p;
      col = rf_EUCol(layoutPtr, pda->raidAddress );
      buf[col] = pda->bufPtr;
  }
  /*  pbuf and ebuf:  they will change values as double recovery decoding goes on */
  pbuf = ppda->bufPtr;   
  ebuf = epda->bufPtr;
  /* find out the logical colume numbers in the encoding matrix of the two failed columes */
  fcol[0] = rf_EUCol(layoutPtr, fpda->raidAddress );

  /* find out the other failed colume not accessed this time */
  sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);
  for (i=0; i < numDataCol; i++) {
      npda.raidAddress = sosAddr + (i * secPerSU);
      (raidPtr->Layout.map->MapSector)(raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);
      /* skip over dead disks */
      if (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))
      if (i != fcol[0]) break;
  }
  RF_ASSERT (i < numDataCol);
  fcol[1] = i;
  /* assign temporary space to put recovered failed SU */
  numbytes = fpda->numSector * bytesPerSector;
  RF_Malloc(olddata[0], numbytes, (char *) ); 
  RF_Malloc(olddata[1], numbytes, (char *) ); 
  dest[0] = olddata[0]; 
  dest[1] = olddata[1]; 
  bzero(olddata[0], numbytes);
  bzero(olddata[1], numbytes);
  /* Begin the recovery decoding, initially buf[j],  ebuf, pbuf, dest[j] have already 
     pointed at the beginning of each source buffers and destination buffers */
  for( sector = startSector, i=0; sector < endSector; sector++ , i++){
      rf_doubleEOdecode(raidPtr, buf, dest, fcol, pbuf, ebuf );
      for (j=0; j < numDataCol; j++) 
           if( ( j != fcol[0]) && ( j != fcol[1] ) ) buf[j] += bytesPerSector;
      dest[0] += bytesPerSector;
      dest[1] += bytesPerSector;
      ebuf += bytesPerSector;
      pbuf += bytesPerSector;
  }
  /* after recovery, the buffer pointed by olddata[0] is the old failed data.
     With new writing data and this old data, use small write to calculate 
     the new redundant informations 
   */
  /*  node->params[ 0, ... PDAPerDisk * (numDataCol - 2)-1 ] are Pdas of Rrd; 
            params[ PDAPerDisk*(numDataCol - 2), ... PDAPerDisk*numDataCol -1 ] are Pdas of Rp, ( Rp2 ), Re, ( Re2 ) ; 
            params[ PDAPerDisk*numDataCol, ... PDAPerDisk*numDataCol +asmap->numStripeUnitsAccessed -asmap->numDataFailed-1]
      	            are Pdas of wudNodes; 
      For current implementation, we assume the simplest case:
           asmap->numStripeUnitsAccessed == 1 and asmap->numDataFailed == 1 ie. PDAPerDisk = 1 
      then node->params[numDataCol] must be the new data to be writen to the failed disk. We first bxor the new data 
      into the old recovered data, then do the same things as small write.
   */
 
  rf_bxor( ((RF_PhysDiskAddr_t *)node->params[numDataCol].p)->bufPtr, olddata[0], numbytes, node->dagHdr->bp);
  /*  do new 'E' calculation  */
  /*  find out the corresponding colume in encoding matrix for write colume to be encoded into redundant disk 'E' */
  scol = rf_EUCol(layoutPtr, fpda->raidAddress );
  /*  olddata[0] now is source buffer pointer; epda->bufPtr is the dest buffer pointer               */
  rf_e_encToBuf(raidPtr, scol, olddata[0], RF_EO_MATRIX_DIM - 2, epda->bufPtr, fpda->numSector);

  /*  do new 'P' calculation  */
   rf_bxor( olddata[0], ppda->bufPtr, numbytes, node->dagHdr->bp);
  /* Free the allocated buffer  */
  RF_Free( olddata[0], numbytes );
  RF_Free( olddata[1], numbytes );
  RF_Free( buf, numDataCol*sizeof(char *));

  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  if (tracerec) {
    tracerec->q_us += RF_ETIMER_VAL_US(timer);
  }

  rf_GenericWakeupFunc(node,0);
  return(0);
@

