head	1.9;
access;
symbols
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.38
	OPENBSD_5_0:1.8.0.36
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.34
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.32
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.28
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.30
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.26
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.24
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.22
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.20
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.18
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.16
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.14
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.12
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.10
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.8
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.8;

1.8
date	2002.12.16.07.01.05;	author tdeval;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.08.16.07.45;	author peter;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2000.01.11.18.02.23;	author peter;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.01.07.14.50.23;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.33;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.54;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.14;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.03.28.15.03.52;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.6.8.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.6.8.2;

1.6.8.2
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_threadstuff.h,v 1.8 2002/12/16 07:01:05 tdeval Exp $	*/
/*	$NetBSD: rf_threadstuff.h,v 1.8 2000/06/11 03:35:38 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland, Daniel Stodolsky, Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * threadstuff.h -- Definitions for threads, locks, and synchronization.
 *
 * The purpose of this file is provide some illusion of portability.
 * If the functions below can be implemented with the same semantics on
 * some new system, then at least the synchronization and thread control
 * part of the code should not require modification to port to a new machine.
 * The only other place where the pthread package is explicitly used is
 * threadid.h
 *
 * This file should be included above stdio.h to get some necessary defines.
 *
 */

#ifndef	_RF__RF_THREADSTUFF_H_
#define	_RF__RF_THREADSTUFF_H_

#include "rf_types.h"
#include <sys/types.h>
#include <sys/param.h>
#ifdef	_KERNEL
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/kthread.h>
#endif

#define	rf_create_managed_mutex(a,b)					\
	_rf_create_managed_mutex(a,b,__FILE__,__LINE__)
#define	rf_create_managed_cond(a,b)					\
	_rf_create_managed_cond(a,b,__FILE__,__LINE__)
#define	rf_init_managed_threadgroup(a,b)				\
	_rf_init_managed_threadgroup(a,b,__FILE__,__LINE__)
#define	rf_init_threadgroup(a)						\
	_rf_init_threadgroup(a,__FILE__,__LINE__)
#define	rf_destroy_threadgroup(a)					\
	_rf_destroy_threadgroup(a,__FILE__,__LINE__)

int _rf_init_threadgroup(RF_ThreadGroup_t *, char *, int);
int _rf_destroy_threadgroup(RF_ThreadGroup_t *, char *, int);
int _rf_init_managed_threadgroup(RF_ShutdownList_t **, RF_ThreadGroup_t *,
    char *, int);

#include <sys/lock.h>
#define	decl_simple_lock_data(a,b)	a struct simplelock b
#define	simple_lock_addr(a)		((struct simplelock *)&(a))

typedef struct proc	*RF_Thread_t;
typedef void		*RF_ThreadArg_t;

#define	RF_DECLARE_MUTEX(_m_)		decl_simple_lock_data(,(_m_))
#define	RF_DECLARE_STATIC_MUTEX(_m_)	decl_simple_lock_data(static,(_m_))
#define	RF_DECLARE_EXTERN_MUTEX(_m_)	decl_simple_lock_data(extern,(_m_))

#define	RF_DECLARE_COND(_c_)		int _c_
#define	RF_DECLARE_STATIC_COND(_c_)	static int _c_
#define	RF_DECLARE_EXTERN_COND(_c_)	extern int _c_

#define	RF_LOCK_MUTEX(_m_)		simple_lock(&(_m_))
#define	RF_UNLOCK_MUTEX(_m_)		simple_unlock(&(_m_))

/*
 * In Net- and OpenBSD, kernel threads are simply processes that share several
 * substructures and never run in userspace.
 */
#define	RF_WAIT_COND(_c_,_m_)	do {					\
	RF_UNLOCK_MUTEX(_m_);						\
	tsleep(&_c_, PRIBIO, "rfwcond", 0);				\
	RF_LOCK_MUTEX(_m_);						\
} while (0)
#define	RF_SIGNAL_COND(_c_)	wakeup(&(_c_))
#define	RF_BROADCAST_COND(_c_)	wakeup(&(_c_))
#define	RF_CREATE_THREAD(_handle_, _func_, _arg_, _name_)		\
	kthread_create((void (*)(void *))(_func_), (void *)(_arg_),	\
	    (struct proc **)&(_handle_), _name_)

struct RF_ThreadGroup_s {
	int			 created;
	int			 running;
	int			 shutdown;
	RF_DECLARE_MUTEX	(mutex);
	RF_DECLARE_COND		(cond);
};

/*
 * Someone has started a thread in the group.
 */
#define	RF_THREADGROUP_STARTED(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	(_g_)->created++;						\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)

/*
 * Thread announcing that it is now running.
 */
#define	RF_THREADGROUP_RUNNING(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	(_g_)->running++;						\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
	RF_SIGNAL_COND((_g_)->cond);					\
} while (0)

/*
 * Thread announcing that it is now done.
 */
#define	RF_THREADGROUP_DONE(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	(_g_)->shutdown++;						\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
	RF_SIGNAL_COND((_g_)->cond);					\
} while (0)

/*
 * Wait for all threads to start running.
 */
#define	RF_THREADGROUP_WAIT_START(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	while((_g_)->running < (_g_)->created) {			\
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex);		\
	}								\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)

/*
 * Wait for all threads to stop running.
 */
#if	!defined(__NetBSD__) && !defined(__OpenBSD__)
#define	RF_THREADGROUP_WAIT_STOP(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	RF_ASSERT((_g_)->running == (_g_)->created);			\
	while((_g_)->shutdown < (_g_)->running) {			\
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex);		\
	}								\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)
#else
 /*
  * XXX Note that we've removed the assert. That should be put back in once
  * we actually get something like a kernel thread running.
  */
#define	RF_THREADGROUP_WAIT_STOP(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	while((_g_)->shutdown < (_g_)->running) {			\
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex);		\
	}								\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)
#endif


int  rf_mutex_init(struct simplelock *);
int  rf_mutex_destroy(struct simplelock *);
int _rf_create_managed_mutex(RF_ShutdownList_t **, struct simplelock *,
	char *, int);
int _rf_create_managed_cond(RF_ShutdownList_t ** listp, int *, char *, int);

int  rf_cond_init(int *);
int  rf_cond_destroy(int *);

#endif	/* !_RF__RF_THREADSTUFF_H_ */
@


1.8
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_threadstuff.h,v 1.7 2002/03/14 01:27:02 millert Exp $	*/
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_threadstuff.h,v 1.6 2000/08/08 16:07:45 peter Exp $	*/
d3 1
d32 1
a32 1
 * threadstuff.h -- definitions for threads, locks, and synchronization
d38 1
a38 1
 * the only other place where the pthread package is explicitly used is
d41 1
a41 1
 * this file should be included above stdio.h to get some necessary defines.
d45 2
a46 2
#ifndef _RF__RF_THREADSTUFF_H_
#define _RF__RF_THREADSTUFF_H_
d51 1
a51 1
#ifdef _KERNEL
d57 15
a71 11
#define rf_create_managed_mutex(a,b) _rf_create_managed_mutex(a,b,__FILE__,__LINE__)
#define rf_create_managed_cond(a,b) _rf_create_managed_cond(a,b,__FILE__,__LINE__)
#define rf_init_managed_threadgroup(a,b) _rf_init_managed_threadgroup(a,b,__FILE__,__LINE__)
#define rf_init_threadgroup(a) _rf_init_threadgroup(a,__FILE__,__LINE__)
#define rf_destroy_threadgroup(a) _rf_destroy_threadgroup(a,__FILE__,__LINE__)

int     _rf_init_threadgroup(RF_ThreadGroup_t * g, char *file, int line);
int     _rf_destroy_threadgroup(RF_ThreadGroup_t * g, char *file, int line);
int
_rf_init_managed_threadgroup(RF_ShutdownList_t ** listp,
    RF_ThreadGroup_t * g, char *file, int line);
d74 2
a75 2
#define decl_simple_lock_data(a,b) a struct simplelock b;
#define simple_lock_addr(a) ((struct simplelock *)&(a))
d77 2
a78 2
typedef struct proc *RF_Thread_t;
typedef void *RF_ThreadArg_t;
d80 3
a82 3
#define RF_DECLARE_MUTEX(_m_)           decl_simple_lock_data(,(_m_))
#define RF_DECLARE_STATIC_MUTEX(_m_)    decl_simple_lock_data(static,(_m_))
#define RF_DECLARE_EXTERN_MUTEX(_m_)    decl_simple_lock_data(extern,(_m_))
d84 3
a86 3
#define RF_DECLARE_COND(_c_)            int _c_;
#define RF_DECLARE_STATIC_COND(_c_)     static int _c_;
#define RF_DECLARE_EXTERN_COND(_c_)     extern int _c_;
d88 2
a89 2
#define RF_LOCK_MUTEX(_m_)              simple_lock(&(_m_))
#define RF_UNLOCK_MUTEX(_m_)            simple_unlock(&(_m_))
d92 1
a92 1
 * In Net- and OpenBSD, kernel threads are simply processes which share several
d95 9
a103 9
#define RF_WAIT_COND(_c_,_m_)           { \
	RF_UNLOCK_MUTEX(_m_); \
	tsleep(&_c_, PRIBIO, "rfwcond", 0); \
	RF_LOCK_MUTEX(_m_); \
}
#define RF_SIGNAL_COND(_c_)            wakeup(&(_c_))
#define RF_BROADCAST_COND(_c_)         wakeup(&(_c_))
#define	RF_CREATE_THREAD(_handle_, _func_, _arg_, _name_) \
	kthread_create((void (*)(void *))(_func_), (void *)(_arg_), \
d107 5
a111 5
	int     created;
	int     running;
	int     shutdown;
	        RF_DECLARE_MUTEX(mutex)
	        RF_DECLARE_COND(cond)
d113 1
d115 1
a115 1
 * Someone has started a thread in the group
d117 5
a121 5
#define RF_THREADGROUP_STARTED(_g_) { \
	RF_LOCK_MUTEX((_g_)->mutex); \
	(_g_)->created++; \
	RF_UNLOCK_MUTEX((_g_)->mutex); \
}
d124 1
a124 1
 * Thread announcing that it is now running
d126 6
a131 6
#define RF_THREADGROUP_RUNNING(_g_) { \
	RF_LOCK_MUTEX((_g_)->mutex); \
	(_g_)->running++; \
	RF_UNLOCK_MUTEX((_g_)->mutex); \
	RF_SIGNAL_COND((_g_)->cond); \
}
d134 1
a134 1
 * Thread announcing that it is now done
d136 6
a141 6
#define RF_THREADGROUP_DONE(_g_) { \
	RF_LOCK_MUTEX((_g_)->mutex); \
	(_g_)->shutdown++; \
	RF_UNLOCK_MUTEX((_g_)->mutex); \
	RF_SIGNAL_COND((_g_)->cond); \
}
d144 1
a144 1
 * Wait for all threads to start running
d146 7
a152 7
#define RF_THREADGROUP_WAIT_START(_g_) { \
	RF_LOCK_MUTEX((_g_)->mutex); \
	while((_g_)->running < (_g_)->created) { \
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex); \
	} \
	RF_UNLOCK_MUTEX((_g_)->mutex); \
}
d155 1
a155 1
 * Wait for all threads to stop running
d157 9
a165 9
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
#define RF_THREADGROUP_WAIT_STOP(_g_) { \
	RF_LOCK_MUTEX((_g_)->mutex); \
	RF_ASSERT((_g_)->running == (_g_)->created); \
	while((_g_)->shutdown < (_g_)->running) { \
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex); \
	} \
	RF_UNLOCK_MUTEX((_g_)->mutex); \
}
d167 11
a177 9
 /* XXX Note that we've removed the assert.  That should get put back in once
  * we actually get something like a kernel thread running */
#define RF_THREADGROUP_WAIT_STOP(_g_) { \
	RF_LOCK_MUTEX((_g_)->mutex); \
	while((_g_)->shutdown < (_g_)->running) { \
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex); \
	} \
	RF_UNLOCK_MUTEX((_g_)->mutex); \
}
d181 10
a190 12
int     rf_mutex_init(struct simplelock *);
int     rf_mutex_destroy(struct simplelock *);
int 
_rf_create_managed_mutex(RF_ShutdownList_t **, struct simplelock *,
    char *, int);
int 
_rf_create_managed_cond(RF_ShutdownList_t ** listp, int *,
    char *file, int line);

int     rf_cond_init(int *c);
int     rf_cond_destroy(int *c);
#endif				/* !_RF__RF_THREADSTUFF_H_ */
@


1.6
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_threadstuff.h,v 1.5 2000/01/11 18:02:23 peter Exp $	*/
d98 1
a98 1
	kthread_create((void (*) __P((void *)))(_func_), (void *)(_arg_), \
@


1.6.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_threadstuff.h,v 1.6 2000/08/08 16:07:45 peter Exp $	*/
d98 1
a98 1
	kthread_create((void (*)(void *))(_func_), (void *)(_arg_), \
@


1.6.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d31 1
a31 1
 * threadstuff.h -- Definitions for threads, locks, and synchronization.
d37 1
a37 1
 * The only other place where the pthread package is explicitly used is
d40 1
a40 1
 * This file should be included above stdio.h to get some necessary defines.
d44 2
a45 2
#ifndef	_RF__RF_THREADSTUFF_H_
#define	_RF__RF_THREADSTUFF_H_
d50 1
a50 1
#ifdef	_KERNEL
d56 11
a66 15
#define	rf_create_managed_mutex(a,b)					\
	_rf_create_managed_mutex(a,b,__FILE__,__LINE__)
#define	rf_create_managed_cond(a,b)					\
	_rf_create_managed_cond(a,b,__FILE__,__LINE__)
#define	rf_init_managed_threadgroup(a,b)				\
	_rf_init_managed_threadgroup(a,b,__FILE__,__LINE__)
#define	rf_init_threadgroup(a)						\
	_rf_init_threadgroup(a,__FILE__,__LINE__)
#define	rf_destroy_threadgroup(a)					\
	_rf_destroy_threadgroup(a,__FILE__,__LINE__)

int _rf_init_threadgroup(RF_ThreadGroup_t *, char *, int);
int _rf_destroy_threadgroup(RF_ThreadGroup_t *, char *, int);
int _rf_init_managed_threadgroup(RF_ShutdownList_t **, RF_ThreadGroup_t *,
    char *, int);
d69 2
a70 2
#define	decl_simple_lock_data(a,b)	a struct simplelock b
#define	simple_lock_addr(a)		((struct simplelock *)&(a))
d72 2
a73 2
typedef struct proc	*RF_Thread_t;
typedef void		*RF_ThreadArg_t;
d75 3
a77 3
#define	RF_DECLARE_MUTEX(_m_)		decl_simple_lock_data(,(_m_))
#define	RF_DECLARE_STATIC_MUTEX(_m_)	decl_simple_lock_data(static,(_m_))
#define	RF_DECLARE_EXTERN_MUTEX(_m_)	decl_simple_lock_data(extern,(_m_))
d79 3
a81 3
#define	RF_DECLARE_COND(_c_)		int _c_
#define	RF_DECLARE_STATIC_COND(_c_)	static int _c_
#define	RF_DECLARE_EXTERN_COND(_c_)	extern int _c_
d83 2
a84 2
#define	RF_LOCK_MUTEX(_m_)		simple_lock(&(_m_))
#define	RF_UNLOCK_MUTEX(_m_)		simple_unlock(&(_m_))
d87 1
a87 1
 * In Net- and OpenBSD, kernel threads are simply processes that share several
d90 9
a98 9
#define	RF_WAIT_COND(_c_,_m_)	do {					\
	RF_UNLOCK_MUTEX(_m_);						\
	tsleep(&_c_, PRIBIO, "rfwcond", 0);				\
	RF_LOCK_MUTEX(_m_);						\
} while (0)
#define	RF_SIGNAL_COND(_c_)	wakeup(&(_c_))
#define	RF_BROADCAST_COND(_c_)	wakeup(&(_c_))
#define	RF_CREATE_THREAD(_handle_, _func_, _arg_, _name_)		\
	kthread_create((void (*)(void *))(_func_), (void *)(_arg_),	\
d102 5
a106 5
	int			 created;
	int			 running;
	int			 shutdown;
	RF_DECLARE_MUTEX	(mutex);
	RF_DECLARE_COND		(cond);
a107 1

d109 1
a109 1
 * Someone has started a thread in the group.
d111 5
a115 5
#define	RF_THREADGROUP_STARTED(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	(_g_)->created++;						\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)
d118 1
a118 1
 * Thread announcing that it is now running.
d120 6
a125 6
#define	RF_THREADGROUP_RUNNING(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	(_g_)->running++;						\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
	RF_SIGNAL_COND((_g_)->cond);					\
} while (0)
d128 1
a128 1
 * Thread announcing that it is now done.
d130 6
a135 6
#define	RF_THREADGROUP_DONE(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	(_g_)->shutdown++;						\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
	RF_SIGNAL_COND((_g_)->cond);					\
} while (0)
d138 1
a138 1
 * Wait for all threads to start running.
d140 7
a146 7
#define	RF_THREADGROUP_WAIT_START(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	while((_g_)->running < (_g_)->created) {			\
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex);		\
	}								\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)
d149 1
a149 1
 * Wait for all threads to stop running.
d151 9
a159 9
#if	!defined(__NetBSD__) && !defined(__OpenBSD__)
#define	RF_THREADGROUP_WAIT_STOP(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	RF_ASSERT((_g_)->running == (_g_)->created);			\
	while((_g_)->shutdown < (_g_)->running) {			\
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex);		\
	}								\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)
d161 9
a169 11
 /*
  * XXX Note that we've removed the assert. That should be put back in once
  * we actually get something like a kernel thread running.
  */
#define	RF_THREADGROUP_WAIT_STOP(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	while((_g_)->shutdown < (_g_)->running) {			\
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex);		\
	}								\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)
d173 12
a184 10
int  rf_mutex_init(struct simplelock *);
int  rf_mutex_destroy(struct simplelock *);
int _rf_create_managed_mutex(RF_ShutdownList_t **, struct simplelock *,
	char *, int);
int _rf_create_managed_cond(RF_ShutdownList_t ** listp, int *, char *, int);

int  rf_cond_init(int *);
int  rf_cond_destroy(int *);

#endif	/* !_RF__RF_THREADSTUFF_H_ */
@


1.5
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_threadstuff.h,v 1.4 2000/01/07 14:50:23 peter Exp $	*/
/*	$NetBSD: rf_threadstuff.h,v 1.7 2000/01/09 01:34:29 oster Exp $	*/
a88 3
 *
 * XXX Note, Net- and OpenBSD does not yet have a wakeup_one(), so we always
 * XXX get Thundering Herd when a condition occurs.
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_threadstuff.h,v 1.6 2000/08/08 16:07:45 peter Exp $	*/
/*	$NetBSD: rf_threadstuff.h,v 1.8 2000/06/11 03:35:38 oster Exp $	*/
d89 3
@


1.5.2.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d98 1
a98 1
	kthread_create((void (*)(void *))(_func_), (void *)(_arg_), \
@


1.5.2.3
log
@Sync the SMP branch with 3.3
@
text
@a2 1

d31 1
a31 1
 * threadstuff.h -- Definitions for threads, locks, and synchronization.
d37 1
a37 1
 * The only other place where the pthread package is explicitly used is
d40 1
a40 1
 * This file should be included above stdio.h to get some necessary defines.
d44 2
a45 2
#ifndef	_RF__RF_THREADSTUFF_H_
#define	_RF__RF_THREADSTUFF_H_
d50 1
a50 1
#ifdef	_KERNEL
d56 11
a66 15
#define	rf_create_managed_mutex(a,b)					\
	_rf_create_managed_mutex(a,b,__FILE__,__LINE__)
#define	rf_create_managed_cond(a,b)					\
	_rf_create_managed_cond(a,b,__FILE__,__LINE__)
#define	rf_init_managed_threadgroup(a,b)				\
	_rf_init_managed_threadgroup(a,b,__FILE__,__LINE__)
#define	rf_init_threadgroup(a)						\
	_rf_init_threadgroup(a,__FILE__,__LINE__)
#define	rf_destroy_threadgroup(a)					\
	_rf_destroy_threadgroup(a,__FILE__,__LINE__)

int _rf_init_threadgroup(RF_ThreadGroup_t *, char *, int);
int _rf_destroy_threadgroup(RF_ThreadGroup_t *, char *, int);
int _rf_init_managed_threadgroup(RF_ShutdownList_t **, RF_ThreadGroup_t *,
    char *, int);
d69 2
a70 2
#define	decl_simple_lock_data(a,b)	a struct simplelock b
#define	simple_lock_addr(a)		((struct simplelock *)&(a))
d72 2
a73 2
typedef struct proc	*RF_Thread_t;
typedef void		*RF_ThreadArg_t;
d75 3
a77 3
#define	RF_DECLARE_MUTEX(_m_)		decl_simple_lock_data(,(_m_))
#define	RF_DECLARE_STATIC_MUTEX(_m_)	decl_simple_lock_data(static,(_m_))
#define	RF_DECLARE_EXTERN_MUTEX(_m_)	decl_simple_lock_data(extern,(_m_))
d79 3
a81 3
#define	RF_DECLARE_COND(_c_)		int _c_
#define	RF_DECLARE_STATIC_COND(_c_)	static int _c_
#define	RF_DECLARE_EXTERN_COND(_c_)	extern int _c_
d83 2
a84 2
#define	RF_LOCK_MUTEX(_m_)		simple_lock(&(_m_))
#define	RF_UNLOCK_MUTEX(_m_)		simple_unlock(&(_m_))
d87 1
a87 1
 * In Net- and OpenBSD, kernel threads are simply processes that share several
d90 9
a98 9
#define	RF_WAIT_COND(_c_,_m_)	do {					\
	RF_UNLOCK_MUTEX(_m_);						\
	tsleep(&_c_, PRIBIO, "rfwcond", 0);				\
	RF_LOCK_MUTEX(_m_);						\
} while (0)
#define	RF_SIGNAL_COND(_c_)	wakeup(&(_c_))
#define	RF_BROADCAST_COND(_c_)	wakeup(&(_c_))
#define	RF_CREATE_THREAD(_handle_, _func_, _arg_, _name_)		\
	kthread_create((void (*)(void *))(_func_), (void *)(_arg_),	\
d102 5
a106 5
	int			 created;
	int			 running;
	int			 shutdown;
	RF_DECLARE_MUTEX	(mutex);
	RF_DECLARE_COND		(cond);
a107 1

d109 1
a109 1
 * Someone has started a thread in the group.
d111 5
a115 5
#define	RF_THREADGROUP_STARTED(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	(_g_)->created++;						\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)
d118 1
a118 1
 * Thread announcing that it is now running.
d120 6
a125 6
#define	RF_THREADGROUP_RUNNING(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	(_g_)->running++;						\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
	RF_SIGNAL_COND((_g_)->cond);					\
} while (0)
d128 1
a128 1
 * Thread announcing that it is now done.
d130 6
a135 6
#define	RF_THREADGROUP_DONE(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	(_g_)->shutdown++;						\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
	RF_SIGNAL_COND((_g_)->cond);					\
} while (0)
d138 1
a138 1
 * Wait for all threads to start running.
d140 7
a146 7
#define	RF_THREADGROUP_WAIT_START(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	while((_g_)->running < (_g_)->created) {			\
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex);		\
	}								\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)
d149 1
a149 1
 * Wait for all threads to stop running.
d151 9
a159 9
#if	!defined(__NetBSD__) && !defined(__OpenBSD__)
#define	RF_THREADGROUP_WAIT_STOP(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	RF_ASSERT((_g_)->running == (_g_)->created);			\
	while((_g_)->shutdown < (_g_)->running) {			\
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex);		\
	}								\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)
d161 9
a169 11
 /*
  * XXX Note that we've removed the assert. That should be put back in once
  * we actually get something like a kernel thread running.
  */
#define	RF_THREADGROUP_WAIT_STOP(_g_)	do {				\
	RF_LOCK_MUTEX((_g_)->mutex);					\
	while((_g_)->shutdown < (_g_)->running) {			\
		RF_WAIT_COND((_g_)->cond, (_g_)->mutex);		\
	}								\
	RF_UNLOCK_MUTEX((_g_)->mutex);					\
} while (0)
d173 12
a184 10
int  rf_mutex_init(struct simplelock *);
int  rf_mutex_destroy(struct simplelock *);
int _rf_create_managed_mutex(RF_ShutdownList_t **, struct simplelock *,
	char *, int);
int _rf_create_managed_cond(RF_ShutdownList_t ** listp, int *, char *, int);

int  rf_cond_init(int *);
int  rf_cond_destroy(int *);

#endif	/* !_RF__RF_THREADSTUFF_H_ */
@


1.4
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_threadstuff.h,v 1.3 1999/07/30 14:45:33 peter Exp $	*/
/*	$NetBSD: rf_threadstuff.h,v 1.6 2000/01/05 02:57:28 oster Exp $	*/
d185 2
a186 2
int     rf_cond_init(int *c);	/* XXX need to write?? */
int     rf_cond_destroy(int *c);/* XXX need to write?? */
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_threadstuff.h,v 1.2 1999/02/16 00:03:32 niklas Exp $	*/
/*	$NetBSD: rf_threadstuff.h,v 1.5 1999/07/06 21:51:22 thorpej Exp $	*/
d100 1
a100 1
#define	RF_CREATE_THREAD(_handle_, _func_, _arg_) \
d102 1
a102 1
	    (struct proc **)&(_handle_), "raid")
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_threadstuff.h,v 1.1 1999/01/11 14:29:54 niklas Exp $	*/
/*	$NetBSD: rf_threadstuff.h,v 1.3 1999/02/05 00:06:18 oster Exp $	*/
d95 1
a95 1
	tsleep(&_c_, PRIBIO | PCATCH, "rfwcond", 0); \
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_threadstuff.h,v 1.1 1998/11/13 04:20:35 oster Exp $	*/
/*	$NetBSD: rf_threadstuff.h,v 1.1 1998/11/13 04:20:35 oster Exp $	*/
a43 88
/* :  
 * Log: rf_threadstuff.h,v 
 * Revision 1.38  1996/08/12 22:37:47  jimz
 * add AIX stuff for user driver
 *
 * Revision 1.37  1996/08/11  00:47:09  jimz
 * make AIX friendly
 *
 * Revision 1.36  1996/07/23  22:06:59  jimz
 * add rf_destroy_threadgroup
 *
 * Revision 1.35  1996/07/23  21:31:16  jimz
 * add init_threadgroup
 *
 * Revision 1.34  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.33  1996/07/15  17:22:18  jimz
 * nit-pick code cleanup
 * resolve stdlib problems on DEC OSF
 *
 * Revision 1.32  1996/06/17  03:01:11  jimz
 * get rid of JOIN stuff
 *
 * Revision 1.31  1996/06/14  23:15:38  jimz
 * attempt to deal with thread GC problem
 *
 * Revision 1.30  1996/06/11  18:12:36  jimz
 * get rid of JOIN operations
 * use ThreadGroup stuff instead
 * fix some allocation/deallocation and sync bugs
 *
 * Revision 1.29  1996/06/11  13:48:10  jimz
 * make kernel RF_THREAD_CREATE give back happier return vals
 *
 * Revision 1.28  1996/06/10  16:40:01  jimz
 * break user-level stuff out into lib+apps
 *
 * Revision 1.27  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.26  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.25  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.24  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.23  1996/05/20  19:31:54  jimz
 * add atomic debug (mutex and cond leak finder) stuff
 *
 * Revision 1.22  1996/05/20  16:24:49  jimz
 * get happy in simulator
 *
 * Revision 1.21  1996/05/20  16:15:07  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.20  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.19  1996/05/09  17:16:53  jimz
 * correct arg to JOIN_THREAD
 *
 * Revision 1.18  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.17  1995/12/06  15:15:21  root
 * added copyright info
 *
 */

d48 7
d62 5
a66 124
int _rf_init_threadgroup(RF_ThreadGroup_t *g, char *file, int line);
int _rf_destroy_threadgroup(RF_ThreadGroup_t *g, char *file, int line);
int _rf_init_managed_threadgroup(RF_ShutdownList_t **listp,
	RF_ThreadGroup_t *g, char *file, int line);

#ifndef SIMULATE /* will null all this calls */
#ifndef KERNEL

#if defined(__osf__) || defined(AIX)
#include <pthread.h>
#endif /* __osf__ || AIX */

#define RF_DEBUG_ATOMIC 0

#if RF_DEBUG_ATOMIC > 0
#define RF_ATENT_M 1
#define RF_ATENT_C 2
typedef struct RF_ATEnt_s RF_ATEnt_t;
struct RF_ATEnt_s {
	char            *file;
	int              line;
	pthread_mutex_t  m;
	pthread_cond_t   c;
	int              type;
	int              otype;
	RF_ATEnt_t      *next;
	RF_ATEnt_t      *prev;
};

#define RF_DECLARE_MUTEX(_m_)                RF_ATEnt_t *_m_;
#define RF_DECLARE_STATIC_MUTEX(_m_)  static RF_ATEnt_t *_m_;
#define RF_DECLARE_EXTERN_MUTEX(_m_)  extern RF_ATEnt_t *_m_;
#define RF_DECLARE_COND(_c_)                 RF_ATEnt_t *_c_;
#define RF_DECLARE_STATIC_COND(_c_)   static RF_ATEnt_t *_c_;
#define RF_DECLARE_EXTERN_COND(_c_)   extern RF_ATEnt_t *_c_;

int _rf_mutex_init(RF_ATEnt_t **m, char *file, int line);
int _rf_mutex_destroy(RF_ATEnt_t **m, char *file, int line);
int _rf_cond_init(RF_ATEnt_t **c, char *file, int line);
int _rf_cond_destroy(RF_ATEnt_t **c, char *file, int line);
void rf_atent_init(void);
void rf_atent_shutdown(void);

#define rf_mutex_init(_m_) _rf_mutex_init(_m_,__FILE__,__LINE__)
#define rf_mutex_destroy(_m_) _rf_mutex_destroy(_m_,__FILE__,__LINE__)
#define rf_cond_init(_m_) _rf_cond_init(_m_,__FILE__,__LINE__)
#define rf_cond_destroy(_m_) _rf_cond_destroy(_m_,__FILE__,__LINE__)

#define RF_LOCK_MUTEX(_a_)     {RF_ASSERT((_a_)->type == RF_ATENT_M); pthread_mutex_lock(&((_a_)->m));}
#define RF_UNLOCK_MUTEX(_a_)   {RF_ASSERT((_a_)->type == RF_ATENT_M); pthread_mutex_unlock(&((_a_)->m));}

#define RF_WAIT_COND(_c_,_m_)  { \
	RF_ASSERT((_c_)->type == RF_ATENT_C); \
	RF_ASSERT((_m_)->type == RF_ATENT_M); \
	pthread_cond_wait( &((_c_)->c), &((_m_)->m) ); \
}
#define RF_SIGNAL_COND(_c_)    {RF_ASSERT((_c_)->type == RF_ATENT_C); pthread_cond_signal( &((_c_)->c));}
#define RF_BROADCAST_COND(_c_) {RF_ASSERT((_c_)->type == RF_ATENT_C); pthread_cond_broadcast(&((_c_)->c));}

#else /* RF_DEBUG_ATOMIC > 0 */

/* defining these as macros allows us to NULL them out in the kernel */
#define RF_DECLARE_MUTEX(_m_)                pthread_mutex_t _m_;
#define RF_DECLARE_STATIC_MUTEX(_m_)  static pthread_mutex_t _m_;
#define RF_DECLARE_EXTERN_MUTEX(_m_)  extern pthread_mutex_t _m_;
#define RF_DECLARE_COND(_c_)                 pthread_cond_t  _c_;
#define RF_DECLARE_STATIC_COND(_c_)   static pthread_cond_t  _c_;
#define RF_DECLARE_EXTERN_COND(_c_)   extern pthread_cond_t  _c_;

int rf_mutex_init(pthread_mutex_t *m);
int rf_mutex_destroy(pthread_mutex_t *m);
int rf_cond_init(pthread_cond_t *c);
int rf_cond_destroy(pthread_cond_t *c);

#define RF_LOCK_MUTEX(_m_)     {pthread_mutex_lock(&(_m_));}
#define RF_UNLOCK_MUTEX(_m_)   pthread_mutex_unlock(&(_m_))

#define RF_WAIT_COND(_c_,_m_)  pthread_cond_wait( &(_c_), &(_m_) )
#define RF_SIGNAL_COND(_c_)    pthread_cond_signal( &(_c_) )
#define RF_BROADCAST_COND(_c_) pthread_cond_broadcast(&(_c_))

#endif /* RF_DEBUG_ATOMIC > 0 */

int _rf_create_managed_mutex(RF_ShutdownList_t **listp, pthread_mutex_t *m, char *file, int line);
int _rf_create_managed_cond(RF_ShutdownList_t **listp, pthread_cond_t *c, char *file, int line);

typedef pthread_t       RF_Thread_t;
#ifdef __osf__
typedef pthread_addr_t  RF_ThreadArg_t;        /* the argument to a thread function */
#else /* __osf__ */
typedef void *RF_ThreadArg_t;        /* the argument to a thread function */
#endif /* __osf__ */
typedef pthread_attr_t  RF_ThreadAttr_t;     /* a thread creation attribute structure */

#ifdef __osf__
#define RF_EXIT_THREAD(_status_)                  pthread_exit( (pthread_addr_t) (_status_) )
#else /* __osf__ */
#define RF_EXIT_THREAD(_status_)                  pthread_exit( (void *) (_status_) )
#endif /* __osf__ */
#define RF_DELAY_THREAD(_secs_, _msecs_)          {struct timespec interval;                   \
						interval.tv_sec = (_secs_);                 \
						interval.tv_nsec = (_msecs_)*1000000;       \
						pthread_delay_np(&interval);                \
					       }
#define RF_DELAY_THREAD_TS(_ts_) pthread_delay_np(&(_ts_))

#ifdef __osf__
#define RF_THREAD_ATTR_CREATE(_attr_)            pthread_attr_create( &(_attr_) )
#define RF_THREAD_ATTR_DELETE(_attr_)            pthread_attr_delete( &(_attr_) )
#endif /* __osf__ */
#ifdef AIX
#define RF_THREAD_ATTR_CREATE(_attr_)            pthread_attr_init( &(_attr_) )
#define RF_THREAD_ATTR_DELETE(_attr_)            pthread_attr_destroy( &(_attr_) )
#endif /* AIX */
#define RF_THREAD_ATTR_SETSTACKSIZE(_attr_,_sz_) pthread_attr_setstacksize(&(_attr_), (long) (_sz_))
#define RF_THREAD_ATTR_GETSTACKSIZE(_attr_)      pthread_attr_getstacksize(_attr_)
#define RF_THREAD_ATTR_SETSCHED(_attr_,_sched_)  pthread_attr_setsched(&(_attr_), (_sched_))
#define RF_CREATE_ATTR_THREAD(_handle_, _attr_, _func_, _arg_) \
  pthread_create(&(_handle_), (_attr_), (pthread_startroutine_t) (_func_), (_arg_))


extern pthread_attr_t raidframe_attr_default;
int rf_thread_create(RF_Thread_t *thread, pthread_attr_t attr,
  void (*func)(), RF_ThreadArg_t arg);
a67 5
#define RF_CREATE_THREAD(_handle_, _func_, _arg_)  \
  rf_thread_create(&(_handle_), raidframe_attr_default, (_func_), (_arg_))

#else   /* KERNEL */
#if defined(__NetBSD__) || defined(__OpenBSD__)
a70 7
#else
#include <kern/task.h>
#include <kern/thread.h>
#include <kern/lock.h>
#include <kern/sched_prim.h>
#define decl_simple_lock_data(a,b) a int (b);
#endif /* __NetBSD__ || __OpenBSD__ */
a71 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a72 3
#else
typedef thread_t RF_Thread_t;
#endif
a85 4

#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/types.h>
#include <sys/kthread.h>
a102 57
#else /* ! __NetBSD__ && ! __OpenBSD__ */
/*
 * Digital UNIX/Mach threads.
 */
#define RF_WAIT_COND(_c_,_m_)           { \
	assert_wait((vm_offset_t)&(_c_), TRUE); \
	RF_UNLOCK_MUTEX(_m_); \
	thread_block(); \
	RF_LOCK_MUTEX(_m_); \
}
#define RF_SIGNAL_COND(_c_)            thread_wakeup_one(((vm_offset_t)&(_c_)))
#define RF_BROADCAST_COND(_c_)         thread_wakeup(((vm_offset_t)&(_c_)))
extern task_t first_task;
#define RF_CREATE_THREAD(_handle_, _func_, _arg_) \
	(((_handle_ = kernel_thread_w_arg(first_task, (void (*)())_func_, (void *)(_arg_))) != THREAD_NULL) ? 0 : ENOMEM)
#endif /* __NetBSD__ || __OpenBSD__ */
#endif /* KERNEL */
#else /* SIMULATE */

#define RF_DECLARE_MUTEX(_m_)        int _m_;
#define RF_DECLARE_STATIC_MUTEX(_m_) static int _m_;
#define RF_DECLARE_EXTERN_MUTEX(_m_) extern int _m_;
#define RF_DECLARE_COND(_c_)         int _c_;
#define RF_DECLARE_STATIC_COND(_c_)  static int _c_;
#define RF_DECLARE_EXTERN_COND(_c_)  extern int _c_;

extern int rf_mutex_init(int *m);
extern int rf_mutex_destroy(int *m);
extern int rf_cond_init(int *c);
extern int rf_cond_destroy(int *c);

int rf_mutex_init(int *m);
int rf_mutex_destroy(int *m);
int _rf_create_managed_mutex(RF_ShutdownList_t **listp, int *m, char *file, int line);
int _rf_create_managed_cond(RF_ShutdownList_t **listp, int *m, char *file, int line);

typedef void  *RF_ThreadArg_t;        /* the argument to a thread function */

#define RF_LOCK_MUTEX(_m_)
#define RF_UNLOCK_MUTEX(_m_)

#define RF_WAIT_COND(_c_,_m_)
#define RF_SIGNAL_COND(_c_)
#define RF_BROADCAST_COND(_c_)

#define RF_EXIT_THREAD(_status_)
#define RF_DELAY_THREAD(_secs_, _msecs_)

#define RF_THREAD_ATTR_CREATE(_attr_) ;
#define RF_THREAD_ATTR_DELETE(_attr_) ;
#define RF_THREAD_ATTR_SETSTACKSIZE(_attr_,_sz_) ;
#define RF_THREAD_ATTR_SETSCHED(_attr_,_sched_)  ;
#define RF_CREATE_ATTR_THREAD(_handle_, _attr_, _func_, _arg_) ;

#define RF_CREATE_THREAD(_handle_, _func_, _arg_)  1

#endif /* SIMULATE */
d105 5
a109 5
  int  created;
  int  running;
  int  shutdown;
  RF_DECLARE_MUTEX(mutex)
  RF_DECLARE_COND(cond)
a110 1

d164 2
a165 2
  /* XXX Note that we've removed the assert.  That should get put back
     in once we actually get something like a kernel thread running */
a174 8
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)

int rf_mutex_init(struct simplelock *);
int rf_mutex_destroy(struct simplelock *);
int _rf_create_managed_mutex(RF_ShutdownList_t **, struct simplelock *, 
			     char *, int);
int _rf_create_managed_cond(RF_ShutdownList_t **listp, int *, 
			    char *file, int line);
d176 12
a187 4
int rf_cond_init(int *c); /* XXX need to write?? */
int rf_cond_destroy(int *c); /* XXX need to write?? */
#endif
#endif /* !_RF__RF_THREADSTUFF_H_ */
@

