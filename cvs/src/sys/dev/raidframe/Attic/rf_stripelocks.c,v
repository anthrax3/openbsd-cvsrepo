head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.18
	OPENBSD_5_0:1.6.0.16
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.14
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.12
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.8
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.10
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.16
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.14
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.12
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.10
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.6;

1.6
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.16.07.01.05;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.11.18.02.23;	author peter;	state Exp;
branches
	1.4.2.1
	1.4.12.1;
next	1.3;

1.3
date	2000.01.08.20.57.13;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.51;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.4.12.1
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_stripelocks.c,v 1.6 2007/11/26 09:28:33 martynas Exp $	*/
/*	$NetBSD: rf_stripelocks.c,v 1.5 2000/01/08 23:45:05 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Authors: Mark Holland, Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * stripelocks.c -- Code to lock stripes for read and write access.
 *
 * The code distinguishes between read locks and write locks. There can be
 * as many readers to given stripe as desired. When a write request comes
 * in, no further readers are allowed to enter, and all subsequent requests
 * are queued in FIFO order. When the number of readers goes to zero, the
 * writer is given the lock. When a writer releases the lock, the list of
 * queued requests is scanned, and all readers up to the next writer are
 * given the lock.
 *
 * The lock table size must be one less than a power of two, but HASH_STRIPEID
 * is the only function that requires this.
 *
 * The code now supports "range locks". When you ask to lock a stripe, you
 * specify a range of addresses in that stripe that you want to lock. When
 * you acquire the lock, you've locked only this range of addresses, and
 * other threads can concurrently read/write any non-overlapping portions
 * of the stripe. The "addresses" that you lock are abstract in that you
 * can pass in anything you like. The expectation is that you'll pass in
 * the range of physical disk offsets of the parity bits you're planning
 * to update. The idea behind this, of course, is to allow sub-stripe
 * locking. The implementation is perhaps not the best imaginable; in the
 * worst case a lock release is O(n^2) in the total number of outstanding
 * requests to a given stripe. Note that if you're striping with a
 * stripe unit size equal to an entire disk (i.e. not striping), there will
 * be only one stripe and you may spend some significant number of cycles
 * searching through stripe lock descriptors.
 */

#include "rf_types.h"
#include "rf_raid.h"
#include "rf_stripelocks.h"
#include "rf_alloclist.h"
#include "rf_general.h"
#include "rf_freelist.h"
#include "rf_debugprint.h"
#include "rf_driver.h"
#include "rf_shutdown.h"

#define	Dprintf1(s,a)							\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    NULL, NULL, NULL, NULL, NULL, NULL, NULL)
#define	Dprintf2(s,a,b)							\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), NULL, NULL, NULL, NULL, NULL, NULL)
#define	Dprintf3(s,a,b,c)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    NULL, NULL, NULL, NULL, NULL)
#define	Dprintf4(s,a,b,c,d)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), NULL, NULL, NULL, NULL)
#define	Dprintf5(s,a,b,c,d,e)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    NULL, NULL, NULL)
#define	Dprintf6(s,a,b,c,d,e,f)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    (void *)((unsigned long)f), NULL, NULL)
#define	Dprintf7(s,a,b,c,d,e,f,g)					\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    (void *)((unsigned long)f), (void *)((unsigned long)g), NULL)
#define	Dprintf8(s,a,b,c,d,e,f,g,h)					\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    (void *)((unsigned long)f), (void *)((unsigned long)g),	\
	    (void *)((unsigned long)h))

#define	FLUSH

#define	HASH_STRIPEID(_sid_)	((_sid_) & (rf_lockTableSize-1))

void rf_AddToWaitersQueue(RF_LockTableEntry_t *, RF_StripeLockDesc_t *,
	RF_LockReqDesc_t *);
RF_StripeLockDesc_t *rf_AllocStripeLockDesc(RF_StripeNum_t);
void rf_FreeStripeLockDesc(RF_StripeLockDesc_t *);
void rf_PrintLockedStripes(RF_LockTableEntry_t *);

/*
 * Determines if two ranges overlap. Always yields false if either start
 * value is negative.
 */
#define	SINGLE_RANGE_OVERLAP(_strt1,_stop1,_strt2,_stop2)		\
	((_strt1 >= 0) && (_strt2 >= 0) &&				\
	 (RF_MAX(_strt1, _strt2) <= RF_MIN(_stop1, _stop2)))

/*
 * Determines if any of the ranges specified in the two lock descriptors
 * overlap each other.
 */
#define	RANGE_OVERLAP(_cand,_pred)					\
	(SINGLE_RANGE_OVERLAP((_cand)->start,  (_cand)->stop,		\
			      (_pred)->start,  (_pred)->stop) ||	\
	 SINGLE_RANGE_OVERLAP((_cand)->start2, (_cand)->stop2,		\
			      (_pred)->start,  (_pred)->stop) ||	\
	 SINGLE_RANGE_OVERLAP((_cand)->start,  (_cand)->stop,		\
			      (_pred)->start2, (_pred)->stop2) ||	\
	 SINGLE_RANGE_OVERLAP((_cand)->start2, (_cand)->stop2,		\
			      (_pred)->start2, (_pred)->stop2))

/*
 * Determines if a candidate lock request conflicts with a predecessor
 * lock req. Note that the arguments are not interchangeable.
 * The rules are:
 *  A candidate read conflicts with a predecessor write if any ranges overlap.
 *  A candidate write conflicts with a predecessor read if any ranges overlap.
 *  A candidate write conflicts with a predecessor write if any ranges overlap.
 */
#define	STRIPELOCK_CONFLICT(_cand,_pred)				\
	(RANGE_OVERLAP((_cand), (_pred)) &&				\
	 (((((_cand)->type == RF_IO_TYPE_READ) &&			\
	    ((_pred)->type == RF_IO_TYPE_WRITE)) ||			\
	   (((_cand)->type == RF_IO_TYPE_WRITE) &&			\
	    ((_pred)->type == RF_IO_TYPE_READ)) ||			\
	   (((_cand)->type == RF_IO_TYPE_WRITE) &&			\
	    ((_pred)->type == RF_IO_TYPE_WRITE)))))

static RF_FreeList_t *rf_stripelock_freelist;
#define	RF_MAX_FREE_STRIPELOCK		128
#define	RF_STRIPELOCK_INC		  8
#define	RF_STRIPELOCK_INITIAL		 32

void rf_ShutdownStripeLockFreeList(void *);
void rf_RaidShutdownStripeLocks(void *);

void
rf_ShutdownStripeLockFreeList(void *ignored)
{
	RF_FREELIST_DESTROY(rf_stripelock_freelist, next,
	    (RF_StripeLockDesc_t *));
}

int
rf_ConfigureStripeLockFreeList(RF_ShutdownList_t **listp)
{
	unsigned mask;
	int rc;

	RF_FREELIST_CREATE(rf_stripelock_freelist, RF_MAX_FREE_STRIPELOCK,
	    RF_STRIPELOCK_INITIAL, sizeof(RF_StripeLockDesc_t));
	rc = rf_ShutdownCreate(listp, rf_ShutdownStripeLockFreeList, NULL);
	if (rc) {
		RF_ERRORMSG3("Unable to add to shutdown list file %s"
		    " line %d rc=%d.\n", __FILE__, __LINE__, rc);
		rf_ShutdownStripeLockFreeList(NULL);
		return (rc);
	}
	RF_FREELIST_PRIME(rf_stripelock_freelist, RF_STRIPELOCK_INITIAL, next,
	    (RF_StripeLockDesc_t *));
	for (mask = 0x1; mask; mask <<= 1)
		if (rf_lockTableSize == mask)
			break;
	if (!mask) {
		printf("[WARNING:  lock table size must be a power of two."
		    " Setting to %d.]\n", RF_DEFAULT_LOCK_TABLE_SIZE);
		rf_lockTableSize = RF_DEFAULT_LOCK_TABLE_SIZE;
	}
	return (0);
}

RF_LockTableEntry_t *
rf_MakeLockTable(void)
{
	RF_LockTableEntry_t *lockTable;
	int i, rc;

	RF_Calloc(lockTable, ((int) rf_lockTableSize),
	    sizeof(RF_LockTableEntry_t), (RF_LockTableEntry_t *));
	if (lockTable == NULL)
		return (NULL);
	for (i = 0; i < rf_lockTableSize; i++) {
		rc = rf_mutex_init(&lockTable[i].mutex);
		if (rc) {
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			    " rc=%d.\n", __FILE__, __LINE__, rc);
			/* XXX Clean up other mutexes. */
			return (NULL);
		}
	}
	return (lockTable);
}

void
rf_ShutdownStripeLocks(RF_LockTableEntry_t *lockTable)
{
	int i;

	if (rf_stripeLockDebug) {
		rf_PrintLockedStripes(lockTable);
	}
	for (i = 0; i < rf_lockTableSize; i++) {
		rf_mutex_destroy(&lockTable[i].mutex);
	}
	RF_Free(lockTable, rf_lockTableSize * sizeof(RF_LockTableEntry_t));
}

void
rf_RaidShutdownStripeLocks(void *arg)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) arg;
	rf_ShutdownStripeLocks(raidPtr->lockTable);
}

int
rf_ConfigureStripeLocks(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	int rc;

	raidPtr->lockTable = rf_MakeLockTable();
	if (raidPtr->lockTable == NULL)
		return (ENOMEM);
	rc = rf_ShutdownCreate(listp, rf_RaidShutdownStripeLocks, raidPtr);
	if (rc) {
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
		rf_ShutdownStripeLocks(raidPtr->lockTable);
		return (rc);
	}
	return (0);
}

/*
 * Returns 0 if you've got the lock, and non-zero if you have to wait.
 * If and only if you have to wait, we'll cause cbFunc to get invoked
 * with cbArg when you are granted the lock. We store a tag in *releaseTag
 * that you need to give back to us when you release the lock.
 */
int
rf_AcquireStripeLock(RF_LockTableEntry_t *lockTable, RF_StripeNum_t stripeID,
    RF_LockReqDesc_t *lockReqDesc)
{
	RF_StripeLockDesc_t *lockDesc;
	RF_LockReqDesc_t *p;
	int tid = 0, hashval = HASH_STRIPEID(stripeID);
	int retcode = 0;

	RF_ASSERT(RF_IO_IS_R_OR_W(lockReqDesc->type));

	if (rf_stripeLockDebug) {
		if (stripeID == -1)
			Dprintf1("[%d] Lock acquisition suppressed"
			    " (stripeID == -1).\n", tid);
		else {
			Dprintf8("[%d] Trying to acquire stripe lock table"
			    " 0x%lx SID %ld type %c range %ld-%ld, range2"
			    " %ld-%ld hashval %d.\n", tid,
			    (unsigned long) lockTable, stripeID,
			    lockReqDesc->type, lockReqDesc->start,
			    lockReqDesc->stop, lockReqDesc->start2,
			    lockReqDesc->stop2);
			Dprintf3("[%d] lock %ld hashval %d.\n", tid, stripeID,
			    hashval);
			FLUSH;
		}
	}
	if (stripeID == -1)
		return (0);
	lockReqDesc->next = NULL;	/* Just to be sure. */

	RF_LOCK_MUTEX(lockTable[hashval].mutex);
	for (lockDesc = lockTable[hashval].descList; lockDesc;
	     lockDesc = lockDesc->next) {
		if (lockDesc->stripeID == stripeID)
			break;
	}

	if (!lockDesc) {
		/* No entry in table => no one reading or writing. */
		lockDesc = rf_AllocStripeLockDesc(stripeID);
		lockDesc->next = lockTable[hashval].descList;
		lockTable[hashval].descList = lockDesc;
		if (lockReqDesc->type == RF_IO_TYPE_WRITE)
			lockDesc->nWriters++;
		lockDesc->granted = lockReqDesc;
		if (rf_stripeLockDebug) {
			Dprintf7("[%d] no one waiting: lock %ld %c %ld-%ld"
			    " %ld-%ld granted.\n", tid, stripeID,
			    lockReqDesc->type,
			    lockReqDesc->start, lockReqDesc->stop,
			    lockReqDesc->start2, lockReqDesc->stop2);
			FLUSH;
		}
	} else {

		if (lockReqDesc->type == RF_IO_TYPE_WRITE)
			lockDesc->nWriters++;

		if (lockDesc->nWriters == 0) {
			/*
			 * No need to search any lists if there are no writers
			 * anywhere.
			 */
			lockReqDesc->next = lockDesc->granted;
			lockDesc->granted = lockReqDesc;
			if (rf_stripeLockDebug) {
				Dprintf7("[%d] no writers: lock %ld %c %ld-%ld"
				    " %ld-%ld granted.\n", tid,
				    stripeID, lockReqDesc->type,
				    lockReqDesc->start, lockReqDesc->stop,
				    lockReqDesc->start2, lockReqDesc->stop2);
				FLUSH;
			}
		} else {
			/*
			 * Search the granted & waiting lists for a conflict.
			 * Stop searching as soon as we find one.
			 */
			retcode = 0;
			for (p = lockDesc->granted; p; p = p->next)
				if (STRIPELOCK_CONFLICT(lockReqDesc, p)) {
					retcode = 1;
					break;
				}
			if (!retcode)
				for (p = lockDesc->waitersH; p; p = p->next)
					if (STRIPELOCK_CONFLICT(lockReqDesc, p))
					{
						retcode = 2;
						break;
					}
			if (!retcode) {
				/* No conflicts found => grant lock */
				lockReqDesc->next = lockDesc->granted;
				lockDesc->granted = lockReqDesc;
				if (rf_stripeLockDebug) {
					Dprintf7("[%d] no conflicts: lock %ld"
					    " %c %ld-%ld %ld-%ld granted.\n",
					    tid, stripeID, lockReqDesc->type,
					    lockReqDesc->start,
					    lockReqDesc->stop,
					    lockReqDesc->start2,
					    lockReqDesc->stop2);
					FLUSH;
				}
			} else {
				if (rf_stripeLockDebug) {
					Dprintf6("[%d] conflict: lock %ld %c"
					    " %ld-%ld hashval=%d not"
					    " granted.\n", tid, stripeID,
					    lockReqDesc->type,
					    lockReqDesc->start,
					    lockReqDesc->stop,
					    hashval);
					Dprintf3("[%d] lock %ld retcode=%d.\n",
					    tid, stripeID, retcode);
					FLUSH;
				}
				/* Conflict => the current access must wait. */
				rf_AddToWaitersQueue(lockTable, lockDesc,
				    lockReqDesc);
			}
		}
	}

	RF_UNLOCK_MUTEX(lockTable[hashval].mutex);
	return (retcode);
}

void
rf_ReleaseStripeLock(RF_LockTableEntry_t *lockTable, RF_StripeNum_t stripeID,
    RF_LockReqDesc_t *lockReqDesc)
{
	RF_StripeLockDesc_t *lockDesc, *ld_t;
	RF_LockReqDesc_t *lr, *lr_t, *callbacklist, *t;
	RF_IoType_t type = lockReqDesc->type;
	int tid = 0, hashval = HASH_STRIPEID(stripeID);
	int release_it, consider_it;
	RF_LockReqDesc_t *candidate, *candidate_t, *predecessor;

	RF_ASSERT(RF_IO_IS_R_OR_W(type));

	if (rf_stripeLockDebug) {
		if (stripeID == -1)
			Dprintf1("[%d] Lock release suppressed"
			    " (stripeID == -1).\n", tid);
		else {
			Dprintf8("[%d] Releasing stripe lock on stripe ID %ld,"
			    " type %c range %ld-%ld %ld-%ld table 0x%lx.\n",
			    tid, stripeID, lockReqDesc->type,
			    lockReqDesc->start, lockReqDesc->stop,
			    lockReqDesc->start2, lockReqDesc->stop2,
			    lockTable);
			FLUSH;
		}
	}
	if (stripeID == -1)
		return;

	RF_LOCK_MUTEX(lockTable[hashval].mutex);

	/* Find the stripe lock descriptor. */
	for (ld_t = NULL, lockDesc = lockTable[hashval].descList;
	     lockDesc; ld_t = lockDesc, lockDesc = lockDesc->next) {
		if (lockDesc->stripeID == stripeID)
			break;
	}
	RF_ASSERT(lockDesc);	/*
				 * Major error to release a lock that doesn't
				 * exist.
				 */

	/* Find the stripe lock request descriptor & delete it from the list. */
	for (lr_t = NULL, lr = lockDesc->granted; lr; lr_t = lr, lr = lr->next)
		if (lr == lockReqDesc)
			break;

	RF_ASSERT(lr && (lr == lockReqDesc));	/*
						 * Major error to release a
						 * lock that hasn't been
						 * granted.
						 */
	if (lr_t)
		lr_t->next = lr->next;
	else {
		RF_ASSERT(lr == lockDesc->granted);
		lockDesc->granted = lr->next;
	}
	lr->next = NULL;

	if (lockReqDesc->type == RF_IO_TYPE_WRITE)
		lockDesc->nWriters--;

	/*
	 * Search through the waiters list to see if anyone needs to be woken
	 * up. For each such descriptor in the wait list, we check it against
	 * everything granted and against everything _in front_ of it in the
	 * waiters queue. If it conflicts with none of these, we release it.
	 *
	 * DON'T TOUCH THE TEMPLINK POINTER OF ANYTHING IN THE GRANTED LIST
	 * HERE.
	 * This will roach the case where the callback tries to acquire a new
	 * lock in the same stripe. There are some asserts to try and detect
	 * this.
	 *
	 * We apply 2 performance optimizations:
	 * (1) If releasing this lock results in no more writers to this
	 *     stripe, we just release everybody waiting, since we place no
	 *     restrictions on the number of concurrent reads.
	 * (2) We consider as candidates for wakeup only those waiters that
	 *     have a range overlap with either the descriptor being woken up
	 *     or with something in the callbacklist (i.e. something we've
	 *     just now woken up).
	 * This allows us to avoid the long evaluation for some descriptors.
	 */

	callbacklist = NULL;
	if (lockDesc->nWriters == 0) {	/* Performance tweak (1). */
		while (lockDesc->waitersH) {

			lr = lockDesc->waitersH;	/*
							 * Delete from waiters
							 * list.
							 */
			lockDesc->waitersH = lr->next;

			RF_ASSERT(lr->type == RF_IO_TYPE_READ);

			lr->next = lockDesc->granted;	/*
							 * Add to granted list.
							 */
			lockDesc->granted = lr;

			RF_ASSERT(!lr->templink);
			lr->templink = callbacklist;	/*
							 * Put on callback list
							 * so that we'll invoke
							 * callback below.
							 */
			callbacklist = lr;
			if (rf_stripeLockDebug) {
				Dprintf8("[%d] No writers: granting lock"
				    " stripe ID %ld, type %c range %ld-%l"
				    "d %ld-%ld table 0x%lx.\n", tid, stripeID,
				    lr->type, lr->start, lr->stop,
				    lr->start2, lr->stop2,
				    (unsigned long) lockTable);
				FLUSH;
			}
		}
		lockDesc->waitersT = NULL;	/*
						 * We've purged the whole
						 * waiters list.
						 */

	} else
		for (candidate_t = NULL, candidate = lockDesc->waitersH;
		     candidate;) {

			/* Performance tweak (2). */
			consider_it = 0;
			if (RANGE_OVERLAP(lockReqDesc, candidate))
				consider_it = 1;
			else
				for (t = callbacklist; t; t = t->templink)
					if (RANGE_OVERLAP(t, candidate)) {
						consider_it = 1;
						break;
					}
			if (!consider_it) {
				if (rf_stripeLockDebug) {
					Dprintf8("[%d] No overlap: rejecting"
					    " candidate stripeID %ld, type %c"
					    " range %ld-%ld %ld-%ld table"
					    " 0x%lx.\n", tid, stripeID,
					    candidate->type,
					    candidate->start, candidate->stop,
					    candidate->start2, candidate->stop2,
					    (unsigned long) lockTable);
					FLUSH;
				}
				candidate_t = candidate;
				candidate = candidate->next;
				continue;
			}
			/*
			 * We have a candidate for release. Check to make
			 * sure it is not blocked by any granted locks.
			 */
			release_it = 1;
			for (predecessor = lockDesc->granted; predecessor;
			     predecessor = predecessor->next) {
				if (STRIPELOCK_CONFLICT(candidate, predecessor))
				{
					if (rf_stripeLockDebug) {
						Dprintf8("[%d] Conflicts with"
						    " granted lock: rejecting"
						    " candidate stripeID %ld,"
						    " type %c range %ld-%ld"
						    " %ld-%ld table 0x%lx.\n",
						    tid, stripeID,
						    candidate->type,
						    candidate->start,
						    candidate->stop,
						    candidate->start2,
						    candidate->stop2,
						    (unsigned long) lockTable);
						FLUSH;
					}
					release_it = 0;
					break;
				}
			}

			/*
			 * Now check to see if the candidate is blocked by any
			 * waiters that occur before it in the wait queue.
			 */
			if (release_it)
				for (predecessor = lockDesc->waitersH;
				     predecessor != candidate;
				     predecessor = predecessor->next) {
					if (STRIPELOCK_CONFLICT(candidate,
					    predecessor)) {
						if (rf_stripeLockDebug) {
							Dprintf8("[%d]"
							    " Conflicts with"
							    " waiting lock:"
							    " rejecting"
							    " candidate"
							    " stripeID %ld,"
							    " type %c"
							    " range %ld-%ld"
							    " %ld-%ld"
							    " table 0x%lx.\n",
							    tid, stripeID,
							    candidate->type,
							    candidate->start,
							    candidate->stop,
							    candidate->start2,
							    candidate->stop2,
							    (unsigned long)
							     lockTable);
							FLUSH;
						}
						release_it = 0;
						break;
					}
				}

			/* Release it if indicated. */
			if (release_it) {
				if (rf_stripeLockDebug) {
					Dprintf8("[%d] Granting lock to"
					    " candidate stripeID %ld, type %c"
					    " range %ld-%ld %ld-%ld table"
					    " 0x%lx.\n", tid, stripeID,
					    candidate->type,
					    candidate->start, candidate->stop,
					    candidate->start2, candidate->stop2,
					    (unsigned long) lockTable);
					FLUSH;
				}
				if (candidate_t) {
					candidate_t->next = candidate->next;
					if (lockDesc->waitersT == candidate)
						/*
						 * Cannot be waitersH
						 * since candidate_t is
						 * not NULL.
						 */
						lockDesc->waitersT =
						    candidate_t;
				} else {
					RF_ASSERT(candidate ==
					    lockDesc->waitersH);
					lockDesc->waitersH =
					    lockDesc->waitersH->next;
					if (!lockDesc->waitersH)
						lockDesc->waitersT = NULL;
				}
				/* Move it to the granted list. */
				candidate->next = lockDesc->granted;
				lockDesc->granted = candidate;

				RF_ASSERT(!candidate->templink);
				/*
				 * Put it on the list of things to be called
				 * after we release the mutex.
				 */
				candidate->templink = callbacklist;
				callbacklist = candidate;

				if (!candidate_t)
					candidate = lockDesc->waitersH;
				else
					/*
					 * Continue with the rest of the list.
					 */
					candidate = candidate_t->next;
			} else {
				candidate_t = candidate;
				/* Continue with the rest of the list. */
				candidate = candidate->next;
			}
		}

	/* Delete the descriptor if no one is waiting or active. */
	if (!lockDesc->granted && !lockDesc->waitersH) {
		RF_ASSERT(lockDesc->nWriters == 0);
		if (rf_stripeLockDebug) {
			Dprintf3("[%d] Last lock released (table 0x%lx):"
			    " deleting desc for stripeID %ld.\n", tid,
			    (unsigned long) lockTable, stripeID);
			FLUSH;
		}
		if (ld_t)
			ld_t->next = lockDesc->next;
		else {
			RF_ASSERT(lockDesc == lockTable[hashval].descList);
			lockTable[hashval].descList = lockDesc->next;
		}
		rf_FreeStripeLockDesc(lockDesc);
		lockDesc = NULL;	/* Only for the ASSERT below. */
	}
	RF_UNLOCK_MUTEX(lockTable[hashval].mutex);

	/*
	 * Now that we've unlocked the mutex, invoke the callback on all the
	 * descriptors in the list.
	 */
	RF_ASSERT(!((callbacklist) && (!lockDesc)));	/*
							 * If we deleted the
							 * descriptor, we should
							 * have no callbacks to
							 * do.
							 */
	for (candidate = callbacklist; candidate;) {
		t = candidate;
		candidate = candidate->templink;
		t->templink = NULL;
		(t->cbFunc) (t->cbArg);
	}
}

/* Must have the indicated lock table mutex upon entry. */
void
rf_AddToWaitersQueue(RF_LockTableEntry_t *lockTable,
    RF_StripeLockDesc_t *lockDesc, RF_LockReqDesc_t *lockReqDesc)
{
	int tid;

	if (rf_stripeLockDebug) {
		Dprintf3("[%d] Waiting on lock for stripe %ld table 0x%lx.\n",
		    tid, lockDesc->stripeID, (unsigned long) lockTable);
		FLUSH;
	}
	if (!lockDesc->waitersH) {
		lockDesc->waitersH = lockDesc->waitersT = lockReqDesc;
	} else {
		lockDesc->waitersT->next = lockReqDesc;
		lockDesc->waitersT = lockReqDesc;
	}
}

RF_StripeLockDesc_t *
rf_AllocStripeLockDesc(RF_StripeNum_t stripeID)
{
	RF_StripeLockDesc_t *p;

	RF_FREELIST_GET(rf_stripelock_freelist, p, next,
	    (RF_StripeLockDesc_t *));
	if (p) {
		p->stripeID = stripeID;
	}
	return (p);
}

void
rf_FreeStripeLockDesc(RF_StripeLockDesc_t *p)
{
	RF_FREELIST_FREE(rf_stripelock_freelist, p, next);
}

void
rf_PrintLockedStripes(RF_LockTableEntry_t *lockTable)
{
	int i, j, foundone = 0, did;
	RF_StripeLockDesc_t *p;
	RF_LockReqDesc_t *q;

	RF_LOCK_MUTEX(rf_printf_mutex);
	printf("Locked stripes:\n");
	for (i = 0; i < rf_lockTableSize; i++)
		if (lockTable[i].descList) {
			foundone = 1;
			for (p = lockTable[i].descList; p; p = p->next) {
				printf("Stripe ID 0x%lx (%d) nWriters %d\n",
				    (long) p->stripeID, (int) p->stripeID,
				    p->nWriters);

				if (!(p->granted))
					printf("Granted: (none)\n");
				else
					printf("Granted:\n");
				for (did = 1, j = 0, q = p->granted; q;
				     j++, q = q->next) {
					printf("  %c(%ld-%ld", q->type,
					    (long) q->start, (long) q->stop);
					if (q->start2 != -1)
						printf(",%ld-%ld) ",
						    (long) q->start2,
						    (long) q->stop2);
					else
						printf(") ");
					if (j && !(j % 4)) {
						printf("\n");
						did = 1;
					} else
						did = 0;
				}
				if (!did)
					printf("\n");

				if (!(p->waitersH))
					printf("Waiting: (none)\n");
				else
					printf("Waiting:\n");
				for (did = 1, j = 0, q = p->waitersH; q;
				     j++, q = q->next) {
					printf("%c(%ld-%ld", q->type,
					    (long) q->start, (long) q->stop);
					if (q->start2 != -1)
						printf(",%ld-%ld) ",
						    (long) q->start2,
						    (long) q->stop2);
					else
						printf(") ");
					if (j && !(j % 4)) {
						printf("\n         ");
						did = 1;
					} else
						did = 0;
				}
				if (!did)
					printf("\n");
			}
		}
	if (!foundone)
		printf("(none)\n");
	else
		printf("\n");
	RF_UNLOCK_MUTEX(rf_printf_mutex);
}
@


1.6
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_stripelocks.c,v 1.5 2002/12/16 07:01:05 tdeval Exp $	*/
@


1.5
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_stripelocks.c,v 1.4 2000/01/11 18:02:23 peter Exp $	*/
d280 1
a280 1
			Dprintf1("[%d] Lock acquisition supressed"
d413 1
a413 1
			Dprintf1("[%d] Lock release supressed"
@


1.4
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_stripelocks.c,v 1.3 2000/01/08 20:57:13 peter Exp $	*/
d3 1
d32 1
a32 1
 * stripelocks.c -- code to lock stripes for read and write access
d37 1
a37 1
 * are queued in FIFO order. When a the number of readers goes to zero, the
d39 1
a39 1
 * queued requests is scanned, and all readersq up to the next writer are
d50 1
a50 1
 * can pass in anything you like.  The expectation is that you'll pass in
d55 1
a55 1
 * requests to a given stripe.  Note that if you're striping with a
d71 45
a115 28
#define Dprintf1(s,a)         rf_debug_printf(s,(void *)((unsigned long)a),NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf2(s,a,b)       rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf3(s,a,b,c)     rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),NULL,NULL,NULL,NULL,NULL)
#define Dprintf4(s,a,b,c,d)   rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),NULL,NULL,NULL,NULL)
#define Dprintf5(s,a,b,c,d,e) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),NULL,NULL,NULL)
#define Dprintf6(s,a,b,c,d,e,f) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),NULL,NULL)
#define Dprintf7(s,a,b,c,d,e,f,g) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),(void *)((unsigned long)g),NULL)
#define Dprintf8(s,a,b,c,d,e,f,g,h) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),(void *)((unsigned long)g),(void *)((unsigned long)h))

#define FLUSH

#define HASH_STRIPEID(_sid_)  ( (_sid_) & (rf_lockTableSize-1) )

static void AddToWaitersQueue(RF_LockTableEntry_t * lockTable, RF_StripeLockDesc_t * lockDesc, RF_LockReqDesc_t * lockReqDesc);
static RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);
static void FreeStripeLockDesc(RF_StripeLockDesc_t * p);
static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);

/* determines if two ranges overlap.  always yields false if either start value is negative  */
#define SINGLE_RANGE_OVERLAP(_strt1, _stop1, _strt2, _stop2)                                     \
  ( (_strt1 >= 0) && (_strt2 >= 0) && (RF_MAX(_strt1, _strt2) <= RF_MIN(_stop1, _stop2)) )

/* determines if any of the ranges specified in the two lock descriptors overlap each other */
#define RANGE_OVERLAP(_cand, _pred)                                                  \
  ( SINGLE_RANGE_OVERLAP((_cand)->start,  (_cand)->stop,  (_pred)->start,  (_pred)->stop ) ||    \
    SINGLE_RANGE_OVERLAP((_cand)->start2, (_cand)->stop2, (_pred)->start,  (_pred)->stop ) ||    \
    SINGLE_RANGE_OVERLAP((_cand)->start,  (_cand)->stop,  (_pred)->start2, (_pred)->stop2) ||    \
    SINGLE_RANGE_OVERLAP((_cand)->start2, (_cand)->stop2, (_pred)->start2, (_pred)->stop2) )
d117 25
a141 2
/* Determines if a candidate lock request conflicts with a predecessor lock req.
 * Note that the arguments are not interchangeable.
d143 3
a145 3
 *      a candidate read conflicts with a predecessor write if any ranges overlap
 *      a candidate write conflicts with a predecessor read if any ranges overlap
 *      a candidate write conflicts with a predecessor write if any ranges overlap
d147 8
a154 7
#define STRIPELOCK_CONFLICT(_cand, _pred)                                        \
  RANGE_OVERLAP((_cand), (_pred)) &&                                        \
  ( ( (((_cand)->type == RF_IO_TYPE_READ) && ((_pred)->type == RF_IO_TYPE_WRITE)) ||                      \
      (((_cand)->type == RF_IO_TYPE_WRITE) && ((_pred)->type == RF_IO_TYPE_READ)) ||                      \
      (((_cand)->type == RF_IO_TYPE_WRITE) && ((_pred)->type == RF_IO_TYPE_WRITE))                         \
    )                                                                            \
  )
d157 3
a159 3
#define RF_MAX_FREE_STRIPELOCK 128
#define RF_STRIPELOCK_INC        8
#define RF_STRIPELOCK_INITIAL   32
d161 2
a162 2
static void rf_ShutdownStripeLockFreeList(void *);
static void rf_RaidShutdownStripeLocks(void *);
d164 2
a165 3
static void 
rf_ShutdownStripeLockFreeList(ignored)
	void   *ignored;
d167 2
a168 1
	RF_FREELIST_DESTROY(rf_stripelock_freelist, next, (RF_StripeLockDesc_t *));
d171 2
a172 3
int 
rf_ConfigureStripeLockFreeList(listp)
	RF_ShutdownList_t **listp;
d175 1
a175 1
	int     rc;
d181 2
a182 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d192 2
a193 1
		printf("[WARNING:  lock table size must be a power of two.  Setting to %d.]\n", RF_DEFAULT_LOCK_TABLE_SIZE);
d200 1
a200 1
rf_MakeLockTable()
d203 1
a203 1
	int     i, rc;
d205 2
a206 1
	RF_Calloc(lockTable, ((int) rf_lockTableSize), sizeof(RF_LockTableEntry_t), (RF_LockTableEntry_t *));
d212 3
a214 3
			RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
			    __LINE__, rc);
			/* XXX clean up other mutexes */
d221 2
a222 2
void 
rf_ShutdownStripeLocks(RF_LockTableEntry_t * lockTable)
d224 1
a224 1
	int     i;
d227 1
a227 1
		PrintLockedStripes(lockTable);
d235 2
a236 3
static void 
rf_RaidShutdownStripeLocks(arg)
	void   *arg;
d242 3
a244 5
int 
rf_ConfigureStripeLocks(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d246 1
a246 1
	int     rc;
d253 2
a254 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d260 5
a264 3
/* returns 0 if you've got the lock, and non-zero if you have to wait.
 * if and only if you have to wait, we'll cause cbFunc to get invoked
 * with cbArg when you are granted the lock.  We store a tag in *releaseTag
d267 3
a269 5
int 
rf_AcquireStripeLock(
    RF_LockTableEntry_t * lockTable,
    RF_StripeNum_t stripeID,
    RF_LockReqDesc_t * lockReqDesc)
d273 2
a274 2
	int     tid = 0, hashval = HASH_STRIPEID(stripeID);
	int     retcode = 0;
d280 2
a281 1
			Dprintf1("[%d] Lock acquisition supressed (stripeID == -1)\n", tid);
d283 9
a291 4
			Dprintf8("[%d] Trying to acquire stripe lock table 0x%lx SID %ld type %c range %ld-%ld, range2 %ld-%ld hashval %d\n",
			    tid, (unsigned long) lockTable, stripeID, lockReqDesc->type, lockReqDesc->start,
			    lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2);
			Dprintf3("[%d] lock %ld hashval %d\n", tid, stripeID, hashval);
d297 1
a297 1
	lockReqDesc->next = NULL;	/* just to be sure */
d300 2
a301 1
	for (lockDesc = lockTable[hashval].descList; lockDesc; lockDesc = lockDesc->next) {
d306 3
a308 3
	if (!lockDesc) {	/* no entry in table => no one reading or
				 * writing */
		lockDesc = AllocStripeLockDesc(stripeID);
d315 5
a319 2
			Dprintf7("[%d] no one waiting: lock %ld %c %ld-%ld %ld-%ld granted\n",
			    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2);
d327 5
a331 3
		if (lockDesc->nWriters == 0) {	/* no need to search any lists
						 * if there are no writers
						 * anywhere */
d335 5
a339 2
				Dprintf7("[%d] no writers: lock %ld %c %ld-%ld %ld-%ld granted\n",
				    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2);
d343 4
a346 3

			/* search the granted & waiting lists for a conflict.
			 * stop searching as soon as we find one */
d355 2
a356 1
					if (STRIPELOCK_CONFLICT(lockReqDesc, p)) {
d361 2
a362 2
				lockReqDesc->next = lockDesc->granted;	/* no conflicts found =>
									 * grant lock */
d365 7
a371 3
					Dprintf7("[%d] no conflicts: lock %ld %c %ld-%ld %ld-%ld granted\n",
					    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop,
					    lockReqDesc->start2, lockReqDesc->stop2);
d376 6
a381 2
					Dprintf6("[%d] conflict: lock %ld %c %ld-%ld hashval=%d not granted\n",
					    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop,
d383 2
a384 1
					Dprintf3("[%d] lock %ld retcode=%d\n", tid, stripeID, retcode);
d387 3
a389 3
				AddToWaitersQueue(lockTable, lockDesc, lockReqDesc);	/* conflict => the
											 * current access must
											 * wait */
d398 3
a400 5
void 
rf_ReleaseStripeLock(
    RF_LockTableEntry_t * lockTable,
    RF_StripeNum_t stripeID,
    RF_LockReqDesc_t * lockReqDesc)
d405 2
a406 2
	int     tid = 0, hashval = HASH_STRIPEID(stripeID);
	int     release_it, consider_it;
d413 2
a414 1
			Dprintf1("[%d] Lock release supressed (stripeID == -1)\n", tid);
d416 6
a421 2
			Dprintf8("[%d] Releasing stripe lock on stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
			    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2, lockTable);
d430 3
a432 2
	/* find the stripe lock descriptor */
	for (ld_t = NULL, lockDesc = lockTable[hashval].descList; lockDesc; ld_t = lockDesc, lockDesc = lockDesc->next) {
d436 4
a439 2
	RF_ASSERT(lockDesc);	/* major error to release a lock that doesn't
				 * exist */
d441 1
a441 1
	/* find the stripe lock request descriptor & delete it from the list */
d446 2
a447 1
	RF_ASSERT(lr && (lr == lockReqDesc));	/* major error to release a
d449 2
a450 1
						 * granted */
d462 3
a464 2
	/* search through the waiters list to see if anyone needs to be woken
	 * up. for each such descriptor in the wait list, we check it against
d466 4
a469 3
	 * waiters queue.  If it conflicts with none of these, we release it.
	 * 
	 * DON'T TOUCH THE TEMPLINK POINTER OF ANYTHING IN THE GRANTED LIST HERE.
d471 1
a471 1
	 * lock in the same stripe.  There are some asserts to try and detect
d473 11
a483 9
	 * 
	 * We apply 2 performance optimizations: (1) if releasing this lock
	 * results in no more writers to this stripe, we just release
	 * everybody waiting, since we place no restrictions on the number of
	 * concurrent reads. (2) we consider as candidates for wakeup only
	 * those waiters that have a range overlap with either the descriptor
	 * being woken up or with something in the callbacklist (i.e.
	 * something we've just now woken up). This allows us to avoid the
	 * long evaluation for some descriptors. */
d486 1
a486 1
	if (lockDesc->nWriters == 0) {	/* performance tweak (1) */
d489 4
a492 2
			lr = lockDesc->waitersH;	/* delete from waiters
							 * list */
d497 3
a499 1
			lr->next = lockDesc->granted;	/* add to granted list */
d503 2
a504 1
			lr->templink = callbacklist;	/* put on callback list
d506 2
a507 1
							 * callback below */
d510 6
a515 2
				Dprintf8("[%d] No writers: granting lock stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
				    tid, stripeID, lr->type, lr->start, lr->stop, lr->start2, lr->stop2, (unsigned long) lockTable);
d519 4
a522 2
		lockDesc->waitersT = NULL;	/* we've purged the whole
						 * waiters list */
d525 2
a526 1
		for (candidate_t = NULL, candidate = lockDesc->waitersH; candidate;) {
d528 1
a528 1
			/* performance tweak (2) */
d540 7
a546 2
					Dprintf8("[%d] No overlap: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
					    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,
d554 4
a557 2
			/* we have a candidate for release.  check to make
			 * sure it is not blocked by any granted locks */
d559 4
a562 2
			for (predecessor = lockDesc->granted; predecessor; predecessor = predecessor->next) {
				if (STRIPELOCK_CONFLICT(candidate, predecessor)) {
d564 11
a574 2
						Dprintf8("[%d] Conflicts with granted lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
						    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,
d583 4
a586 2
			/* now check to see if the candidate is blocked by any
			 * waiters that occur before it it the wait queue */
d588 5
a592 2
				for (predecessor = lockDesc->waitersH; predecessor != candidate; predecessor = predecessor->next) {
					if (STRIPELOCK_CONFLICT(candidate, predecessor)) {
d594 18
a611 3
							Dprintf8("[%d] Conflicts with waiting lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
							    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,
							    (unsigned long) lockTable);
d619 1
a619 1
			/* release it if indicated */
d622 7
a628 2
					Dprintf8("[%d] Granting lock to candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
					    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,
d635 7
a641 3
						lockDesc->waitersT = candidate_t;	/* cannot be waitersH
											 * since candidate_t is
											 * not NULL */
d643 4
a646 2
					RF_ASSERT(candidate == lockDesc->waitersH);
					lockDesc->waitersH = lockDesc->waitersH->next;
d650 2
a651 2
				candidate->next = lockDesc->granted;	/* move it to the
									 * granted list */
d655 5
a659 4
				candidate->templink = callbacklist;	/* put it on the list of
									 * things to be called
									 * after we release the
									 * mutex */
d665 4
a668 2
					candidate = candidate_t->next;	/* continue with the
									 * rest of the list */
d671 2
a672 2
				candidate = candidate->next;	/* continue with the
								 * rest of the list */
d676 1
a676 1
	/* delete the descriptor if no one is waiting or active */
d680 3
a682 1
			Dprintf3("[%d] Last lock released (table 0x%lx): deleting desc for stripeID %ld\n", tid, (unsigned long) lockTable, stripeID);
d691 2
a692 2
		FreeStripeLockDesc(lockDesc);
		lockDesc = NULL;/* only for the ASSERT below */
d696 6
a701 3
	/* now that we've unlocked the mutex, invoke the callback on all the
	 * descriptors in the list */
	RF_ASSERT(!((callbacklist) && (!lockDesc)));	/* if we deleted the
d704 2
a705 1
							 * do */
d713 5
a717 6
/* must have the indicated lock table mutex upon entry */
static void 
AddToWaitersQueue(
    RF_LockTableEntry_t * lockTable,
    RF_StripeLockDesc_t * lockDesc,
    RF_LockReqDesc_t * lockReqDesc)
d719 1
a719 1
	int     tid;
d722 2
a723 1
		Dprintf3("[%d] Waiting on lock for stripe %ld table 0x%lx\n", tid, lockDesc->stripeID, (unsigned long) lockTable);
d734 2
a735 2
static RF_StripeLockDesc_t *
AllocStripeLockDesc(RF_StripeNum_t stripeID)
d739 2
a740 1
	RF_FREELIST_GET(rf_stripelock_freelist, p, next, (RF_StripeLockDesc_t *));
d747 2
a748 2
static void 
FreeStripeLockDesc(RF_StripeLockDesc_t * p)
d753 2
a754 3
static void 
PrintLockedStripes(lockTable)
	RF_LockTableEntry_t *lockTable;
d756 1
a756 1
	int     i, j, foundone = 0, did;
d767 2
a768 1
				    (long) p->stripeID, (int) p->stripeID, p->nWriters);
d774 4
a777 2
				for (did = 1, j = 0, q = p->granted; q; j++, q = q->next) {
					printf("  %c(%ld-%ld", q->type, (long) q->start, (long) q->stop);
d779 2
a780 1
						printf(",%ld-%ld) ", (long) q->start2,
d797 4
a800 2
				for (did = 1, j = 0, q = p->waitersH; q; j++, q = q->next) {
					printf("%c(%ld-%ld", q->type, (long) q->start, (long) q->stop);
d802 3
a804 1
						printf(",%ld-%ld) ", (long) q->start2, (long) q->stop2);
@


1.4.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d31 1
a31 1
 * stripelocks.c -- Code to lock stripes for read and write access.
d36 1
a36 1
 * are queued in FIFO order. When the number of readers goes to zero, the
d38 1
a38 1
 * queued requests is scanned, and all readers up to the next writer are
d49 1
a49 1
 * can pass in anything you like. The expectation is that you'll pass in
d54 1
a54 1
 * requests to a given stripe. Note that if you're striping with a
d70 28
a97 45
#define	Dprintf1(s,a)							\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    NULL, NULL, NULL, NULL, NULL, NULL, NULL)
#define	Dprintf2(s,a,b)							\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), NULL, NULL, NULL, NULL, NULL, NULL)
#define	Dprintf3(s,a,b,c)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    NULL, NULL, NULL, NULL, NULL)
#define	Dprintf4(s,a,b,c,d)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), NULL, NULL, NULL, NULL)
#define	Dprintf5(s,a,b,c,d,e)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    NULL, NULL, NULL)
#define	Dprintf6(s,a,b,c,d,e,f)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    (void *)((unsigned long)f), NULL, NULL)
#define	Dprintf7(s,a,b,c,d,e,f,g)					\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    (void *)((unsigned long)f), (void *)((unsigned long)g), NULL)
#define	Dprintf8(s,a,b,c,d,e,f,g,h)					\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    (void *)((unsigned long)f), (void *)((unsigned long)g),	\
	    (void *)((unsigned long)h))

#define	FLUSH

#define	HASH_STRIPEID(_sid_)	((_sid_) & (rf_lockTableSize-1))

void rf_AddToWaitersQueue(RF_LockTableEntry_t *, RF_StripeLockDesc_t *,
	RF_LockReqDesc_t *);
RF_StripeLockDesc_t *rf_AllocStripeLockDesc(RF_StripeNum_t);
void rf_FreeStripeLockDesc(RF_StripeLockDesc_t *);
void rf_PrintLockedStripes(RF_LockTableEntry_t *);
d99 2
a100 25
/*
 * Determines if two ranges overlap. Always yields false if either start
 * value is negative.
 */
#define	SINGLE_RANGE_OVERLAP(_strt1,_stop1,_strt2,_stop2)		\
	((_strt1 >= 0) && (_strt2 >= 0) &&				\
	 (RF_MAX(_strt1, _strt2) <= RF_MIN(_stop1, _stop2)))

/*
 * Determines if any of the ranges specified in the two lock descriptors
 * overlap each other.
 */
#define	RANGE_OVERLAP(_cand,_pred)					\
	(SINGLE_RANGE_OVERLAP((_cand)->start,  (_cand)->stop,		\
			      (_pred)->start,  (_pred)->stop) ||	\
	 SINGLE_RANGE_OVERLAP((_cand)->start2, (_cand)->stop2,		\
			      (_pred)->start,  (_pred)->stop) ||	\
	 SINGLE_RANGE_OVERLAP((_cand)->start,  (_cand)->stop,		\
			      (_pred)->start2, (_pred)->stop2) ||	\
	 SINGLE_RANGE_OVERLAP((_cand)->start2, (_cand)->stop2,		\
			      (_pred)->start2, (_pred)->stop2))

/*
 * Determines if a candidate lock request conflicts with a predecessor
 * lock req. Note that the arguments are not interchangeable.
d102 3
a104 3
 *  A candidate read conflicts with a predecessor write if any ranges overlap.
 *  A candidate write conflicts with a predecessor read if any ranges overlap.
 *  A candidate write conflicts with a predecessor write if any ranges overlap.
d106 7
a112 8
#define	STRIPELOCK_CONFLICT(_cand,_pred)				\
	(RANGE_OVERLAP((_cand), (_pred)) &&				\
	 (((((_cand)->type == RF_IO_TYPE_READ) &&			\
	    ((_pred)->type == RF_IO_TYPE_WRITE)) ||			\
	   (((_cand)->type == RF_IO_TYPE_WRITE) &&			\
	    ((_pred)->type == RF_IO_TYPE_READ)) ||			\
	   (((_cand)->type == RF_IO_TYPE_WRITE) &&			\
	    ((_pred)->type == RF_IO_TYPE_WRITE)))))
d115 3
a117 3
#define	RF_MAX_FREE_STRIPELOCK		128
#define	RF_STRIPELOCK_INC		  8
#define	RF_STRIPELOCK_INITIAL		 32
d119 2
a120 2
void rf_ShutdownStripeLockFreeList(void *);
void rf_RaidShutdownStripeLocks(void *);
d122 3
a124 2
void
rf_ShutdownStripeLockFreeList(void *ignored)
d126 1
a126 2
	RF_FREELIST_DESTROY(rf_stripelock_freelist, next,
	    (RF_StripeLockDesc_t *));
d129 3
a131 2
int
rf_ConfigureStripeLockFreeList(RF_ShutdownList_t **listp)
d134 1
a134 1
	int rc;
d140 2
a141 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s"
		    " line %d rc=%d.\n", __FILE__, __LINE__, rc);
d151 1
a151 2
		printf("[WARNING:  lock table size must be a power of two."
		    " Setting to %d.]\n", RF_DEFAULT_LOCK_TABLE_SIZE);
d158 1
a158 1
rf_MakeLockTable(void)
d161 1
a161 1
	int i, rc;
d163 1
a163 2
	RF_Calloc(lockTable, ((int) rf_lockTableSize),
	    sizeof(RF_LockTableEntry_t), (RF_LockTableEntry_t *));
d169 3
a171 3
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			    " rc=%d.\n", __FILE__, __LINE__, rc);
			/* XXX Clean up other mutexes. */
d178 2
a179 2
void
rf_ShutdownStripeLocks(RF_LockTableEntry_t *lockTable)
d181 1
a181 1
	int i;
d184 1
a184 1
		rf_PrintLockedStripes(lockTable);
d192 3
a194 2
void
rf_RaidShutdownStripeLocks(void *arg)
d200 5
a204 3
int
rf_ConfigureStripeLocks(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d206 1
a206 1
	int rc;
d213 2
a214 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
d220 3
a222 5

/*
 * Returns 0 if you've got the lock, and non-zero if you have to wait.
 * If and only if you have to wait, we'll cause cbFunc to get invoked
 * with cbArg when you are granted the lock. We store a tag in *releaseTag
d225 5
a229 3
int
rf_AcquireStripeLock(RF_LockTableEntry_t *lockTable, RF_StripeNum_t stripeID,
    RF_LockReqDesc_t *lockReqDesc)
d233 2
a234 2
	int tid = 0, hashval = HASH_STRIPEID(stripeID);
	int retcode = 0;
d240 1
a240 2
			Dprintf1("[%d] Lock acquisition supressed"
			    " (stripeID == -1).\n", tid);
d242 4
a245 9
			Dprintf8("[%d] Trying to acquire stripe lock table"
			    " 0x%lx SID %ld type %c range %ld-%ld, range2"
			    " %ld-%ld hashval %d.\n", tid,
			    (unsigned long) lockTable, stripeID,
			    lockReqDesc->type, lockReqDesc->start,
			    lockReqDesc->stop, lockReqDesc->start2,
			    lockReqDesc->stop2);
			Dprintf3("[%d] lock %ld hashval %d.\n", tid, stripeID,
			    hashval);
d251 1
a251 1
	lockReqDesc->next = NULL;	/* Just to be sure. */
d254 1
a254 2
	for (lockDesc = lockTable[hashval].descList; lockDesc;
	     lockDesc = lockDesc->next) {
d259 3
a261 3
	if (!lockDesc) {
		/* No entry in table => no one reading or writing. */
		lockDesc = rf_AllocStripeLockDesc(stripeID);
d268 2
a269 5
			Dprintf7("[%d] no one waiting: lock %ld %c %ld-%ld"
			    " %ld-%ld granted.\n", tid, stripeID,
			    lockReqDesc->type,
			    lockReqDesc->start, lockReqDesc->stop,
			    lockReqDesc->start2, lockReqDesc->stop2);
d277 3
a279 5
		if (lockDesc->nWriters == 0) {
			/*
			 * No need to search any lists if there are no writers
			 * anywhere.
			 */
d283 2
a284 5
				Dprintf7("[%d] no writers: lock %ld %c %ld-%ld"
				    " %ld-%ld granted.\n", tid,
				    stripeID, lockReqDesc->type,
				    lockReqDesc->start, lockReqDesc->stop,
				    lockReqDesc->start2, lockReqDesc->stop2);
d288 3
a290 4
			/*
			 * Search the granted & waiting lists for a conflict.
			 * Stop searching as soon as we find one.
			 */
d299 1
a299 2
					if (STRIPELOCK_CONFLICT(lockReqDesc, p))
					{
d304 2
a305 2
				/* No conflicts found => grant lock */
				lockReqDesc->next = lockDesc->granted;
d308 3
a310 7
					Dprintf7("[%d] no conflicts: lock %ld"
					    " %c %ld-%ld %ld-%ld granted.\n",
					    tid, stripeID, lockReqDesc->type,
					    lockReqDesc->start,
					    lockReqDesc->stop,
					    lockReqDesc->start2,
					    lockReqDesc->stop2);
d315 2
a316 6
					Dprintf6("[%d] conflict: lock %ld %c"
					    " %ld-%ld hashval=%d not"
					    " granted.\n", tid, stripeID,
					    lockReqDesc->type,
					    lockReqDesc->start,
					    lockReqDesc->stop,
d318 1
a318 2
					Dprintf3("[%d] lock %ld retcode=%d.\n",
					    tid, stripeID, retcode);
d321 3
a323 3
				/* Conflict => the current access must wait. */
				rf_AddToWaitersQueue(lockTable, lockDesc,
				    lockReqDesc);
d332 5
a336 3
void
rf_ReleaseStripeLock(RF_LockTableEntry_t *lockTable, RF_StripeNum_t stripeID,
    RF_LockReqDesc_t *lockReqDesc)
d341 2
a342 2
	int tid = 0, hashval = HASH_STRIPEID(stripeID);
	int release_it, consider_it;
d349 1
a349 2
			Dprintf1("[%d] Lock release supressed"
			    " (stripeID == -1).\n", tid);
d351 2
a352 6
			Dprintf8("[%d] Releasing stripe lock on stripe ID %ld,"
			    " type %c range %ld-%ld %ld-%ld table 0x%lx.\n",
			    tid, stripeID, lockReqDesc->type,
			    lockReqDesc->start, lockReqDesc->stop,
			    lockReqDesc->start2, lockReqDesc->stop2,
			    lockTable);
d361 2
a362 3
	/* Find the stripe lock descriptor. */
	for (ld_t = NULL, lockDesc = lockTable[hashval].descList;
	     lockDesc; ld_t = lockDesc, lockDesc = lockDesc->next) {
d366 2
a367 4
	RF_ASSERT(lockDesc);	/*
				 * Major error to release a lock that doesn't
				 * exist.
				 */
d369 1
a369 1
	/* Find the stripe lock request descriptor & delete it from the list. */
d374 1
a374 2
	RF_ASSERT(lr && (lr == lockReqDesc));	/*
						 * Major error to release a
d376 1
a376 2
						 * granted.
						 */
d388 2
a389 3
	/*
	 * Search through the waiters list to see if anyone needs to be woken
	 * up. For each such descriptor in the wait list, we check it against
d391 3
a393 4
	 * waiters queue. If it conflicts with none of these, we release it.
	 *
	 * DON'T TOUCH THE TEMPLINK POINTER OF ANYTHING IN THE GRANTED LIST
	 * HERE.
d395 1
a395 1
	 * lock in the same stripe. There are some asserts to try and detect
d397 9
a405 11
	 *
	 * We apply 2 performance optimizations:
	 * (1) If releasing this lock results in no more writers to this
	 *     stripe, we just release everybody waiting, since we place no
	 *     restrictions on the number of concurrent reads.
	 * (2) We consider as candidates for wakeup only those waiters that
	 *     have a range overlap with either the descriptor being woken up
	 *     or with something in the callbacklist (i.e. something we've
	 *     just now woken up).
	 * This allows us to avoid the long evaluation for some descriptors.
	 */
d408 1
a408 1
	if (lockDesc->nWriters == 0) {	/* Performance tweak (1). */
d411 2
a412 4
			lr = lockDesc->waitersH;	/*
							 * Delete from waiters
							 * list.
							 */
d417 1
a417 3
			lr->next = lockDesc->granted;	/*
							 * Add to granted list.
							 */
d421 1
a421 2
			lr->templink = callbacklist;	/*
							 * Put on callback list
d423 1
a423 2
							 * callback below.
							 */
d426 2
a427 6
				Dprintf8("[%d] No writers: granting lock"
				    " stripe ID %ld, type %c range %ld-%l"
				    "d %ld-%ld table 0x%lx.\n", tid, stripeID,
				    lr->type, lr->start, lr->stop,
				    lr->start2, lr->stop2,
				    (unsigned long) lockTable);
d431 2
a432 4
		lockDesc->waitersT = NULL;	/*
						 * We've purged the whole
						 * waiters list.
						 */
d435 1
a435 2
		for (candidate_t = NULL, candidate = lockDesc->waitersH;
		     candidate;) {
d437 1
a437 1
			/* Performance tweak (2). */
d449 2
a450 7
					Dprintf8("[%d] No overlap: rejecting"
					    " candidate stripeID %ld, type %c"
					    " range %ld-%ld %ld-%ld table"
					    " 0x%lx.\n", tid, stripeID,
					    candidate->type,
					    candidate->start, candidate->stop,
					    candidate->start2, candidate->stop2,
d458 2
a459 4
			/*
			 * We have a candidate for release. Check to make
			 * sure it is not blocked by any granted locks.
			 */
d461 2
a462 4
			for (predecessor = lockDesc->granted; predecessor;
			     predecessor = predecessor->next) {
				if (STRIPELOCK_CONFLICT(candidate, predecessor))
				{
d464 2
a465 11
						Dprintf8("[%d] Conflicts with"
						    " granted lock: rejecting"
						    " candidate stripeID %ld,"
						    " type %c range %ld-%ld"
						    " %ld-%ld table 0x%lx.\n",
						    tid, stripeID,
						    candidate->type,
						    candidate->start,
						    candidate->stop,
						    candidate->start2,
						    candidate->stop2,
d474 2
a475 4
			/*
			 * Now check to see if the candidate is blocked by any
			 * waiters that occur before it in the wait queue.
			 */
d477 2
a478 5
				for (predecessor = lockDesc->waitersH;
				     predecessor != candidate;
				     predecessor = predecessor->next) {
					if (STRIPELOCK_CONFLICT(candidate,
					    predecessor)) {
d480 3
a482 18
							Dprintf8("[%d]"
							    " Conflicts with"
							    " waiting lock:"
							    " rejecting"
							    " candidate"
							    " stripeID %ld,"
							    " type %c"
							    " range %ld-%ld"
							    " %ld-%ld"
							    " table 0x%lx.\n",
							    tid, stripeID,
							    candidate->type,
							    candidate->start,
							    candidate->stop,
							    candidate->start2,
							    candidate->stop2,
							    (unsigned long)
							     lockTable);
d490 1
a490 1
			/* Release it if indicated. */
d493 2
a494 7
					Dprintf8("[%d] Granting lock to"
					    " candidate stripeID %ld, type %c"
					    " range %ld-%ld %ld-%ld table"
					    " 0x%lx.\n", tid, stripeID,
					    candidate->type,
					    candidate->start, candidate->stop,
					    candidate->start2, candidate->stop2,
d501 3
a503 7
						/*
						 * Cannot be waitersH
						 * since candidate_t is
						 * not NULL.
						 */
						lockDesc->waitersT =
						    candidate_t;
d505 2
a506 4
					RF_ASSERT(candidate ==
					    lockDesc->waitersH);
					lockDesc->waitersH =
					    lockDesc->waitersH->next;
d510 2
a511 2
				/* Move it to the granted list. */
				candidate->next = lockDesc->granted;
d515 4
a518 5
				/*
				 * Put it on the list of things to be called
				 * after we release the mutex.
				 */
				candidate->templink = callbacklist;
d524 2
a525 4
					/*
					 * Continue with the rest of the list.
					 */
					candidate = candidate_t->next;
d528 2
a529 2
				/* Continue with the rest of the list. */
				candidate = candidate->next;
d533 1
a533 1
	/* Delete the descriptor if no one is waiting or active. */
d537 1
a537 3
			Dprintf3("[%d] Last lock released (table 0x%lx):"
			    " deleting desc for stripeID %ld.\n", tid,
			    (unsigned long) lockTable, stripeID);
d546 2
a547 2
		rf_FreeStripeLockDesc(lockDesc);
		lockDesc = NULL;	/* Only for the ASSERT below. */
d551 3
a553 6
	/*
	 * Now that we've unlocked the mutex, invoke the callback on all the
	 * descriptors in the list.
	 */
	RF_ASSERT(!((callbacklist) && (!lockDesc)));	/*
							 * If we deleted the
d556 1
a556 2
							 * do.
							 */
d564 6
a569 5

/* Must have the indicated lock table mutex upon entry. */
void
rf_AddToWaitersQueue(RF_LockTableEntry_t *lockTable,
    RF_StripeLockDesc_t *lockDesc, RF_LockReqDesc_t *lockReqDesc)
d571 1
a571 1
	int tid;
d574 1
a574 2
		Dprintf3("[%d] Waiting on lock for stripe %ld table 0x%lx.\n",
		    tid, lockDesc->stripeID, (unsigned long) lockTable);
d585 2
a586 2
RF_StripeLockDesc_t *
rf_AllocStripeLockDesc(RF_StripeNum_t stripeID)
d590 1
a590 2
	RF_FREELIST_GET(rf_stripelock_freelist, p, next,
	    (RF_StripeLockDesc_t *));
d597 2
a598 2
void
rf_FreeStripeLockDesc(RF_StripeLockDesc_t *p)
d603 3
a605 2
void
rf_PrintLockedStripes(RF_LockTableEntry_t *lockTable)
d607 1
a607 1
	int i, j, foundone = 0, did;
d618 1
a618 2
				    (long) p->stripeID, (int) p->stripeID,
				    p->nWriters);
d624 2
a625 4
				for (did = 1, j = 0, q = p->granted; q;
				     j++, q = q->next) {
					printf("  %c(%ld-%ld", q->type,
					    (long) q->start, (long) q->stop);
d627 1
a627 2
						printf(",%ld-%ld) ",
						    (long) q->start2,
d644 2
a645 4
				for (did = 1, j = 0, q = p->waitersH; q;
				     j++, q = q->next) {
					printf("%c(%ld-%ld", q->type,
					    (long) q->start, (long) q->stop);
d647 1
a647 3
						printf(",%ld-%ld) ",
						    (long) q->start2,
						    (long) q->stop2);
@


1.4.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d31 1
a31 1
 * stripelocks.c -- Code to lock stripes for read and write access.
d36 1
a36 1
 * are queued in FIFO order. When the number of readers goes to zero, the
d38 1
a38 1
 * queued requests is scanned, and all readers up to the next writer are
d49 1
a49 1
 * can pass in anything you like. The expectation is that you'll pass in
d54 1
a54 1
 * requests to a given stripe. Note that if you're striping with a
d70 28
a97 45
#define	Dprintf1(s,a)							\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    NULL, NULL, NULL, NULL, NULL, NULL, NULL)
#define	Dprintf2(s,a,b)							\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), NULL, NULL, NULL, NULL, NULL, NULL)
#define	Dprintf3(s,a,b,c)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    NULL, NULL, NULL, NULL, NULL)
#define	Dprintf4(s,a,b,c,d)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), NULL, NULL, NULL, NULL)
#define	Dprintf5(s,a,b,c,d,e)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    NULL, NULL, NULL)
#define	Dprintf6(s,a,b,c,d,e,f)						\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    (void *)((unsigned long)f), NULL, NULL)
#define	Dprintf7(s,a,b,c,d,e,f,g)					\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    (void *)((unsigned long)f), (void *)((unsigned long)g), NULL)
#define	Dprintf8(s,a,b,c,d,e,f,g,h)					\
	rf_debug_printf(s, (void *)((unsigned long)a),			\
	    (void *)((unsigned long)b), (void *)((unsigned long)c),	\
	    (void *)((unsigned long)d), (void *)((unsigned long)e),	\
	    (void *)((unsigned long)f), (void *)((unsigned long)g),	\
	    (void *)((unsigned long)h))

#define	FLUSH

#define	HASH_STRIPEID(_sid_)	((_sid_) & (rf_lockTableSize-1))

void rf_AddToWaitersQueue(RF_LockTableEntry_t *, RF_StripeLockDesc_t *,
	RF_LockReqDesc_t *);
RF_StripeLockDesc_t *rf_AllocStripeLockDesc(RF_StripeNum_t);
void rf_FreeStripeLockDesc(RF_StripeLockDesc_t *);
void rf_PrintLockedStripes(RF_LockTableEntry_t *);
d99 2
a100 25
/*
 * Determines if two ranges overlap. Always yields false if either start
 * value is negative.
 */
#define	SINGLE_RANGE_OVERLAP(_strt1,_stop1,_strt2,_stop2)		\
	((_strt1 >= 0) && (_strt2 >= 0) &&				\
	 (RF_MAX(_strt1, _strt2) <= RF_MIN(_stop1, _stop2)))

/*
 * Determines if any of the ranges specified in the two lock descriptors
 * overlap each other.
 */
#define	RANGE_OVERLAP(_cand,_pred)					\
	(SINGLE_RANGE_OVERLAP((_cand)->start,  (_cand)->stop,		\
			      (_pred)->start,  (_pred)->stop) ||	\
	 SINGLE_RANGE_OVERLAP((_cand)->start2, (_cand)->stop2,		\
			      (_pred)->start,  (_pred)->stop) ||	\
	 SINGLE_RANGE_OVERLAP((_cand)->start,  (_cand)->stop,		\
			      (_pred)->start2, (_pred)->stop2) ||	\
	 SINGLE_RANGE_OVERLAP((_cand)->start2, (_cand)->stop2,		\
			      (_pred)->start2, (_pred)->stop2))

/*
 * Determines if a candidate lock request conflicts with a predecessor
 * lock req. Note that the arguments are not interchangeable.
d102 3
a104 3
 *  A candidate read conflicts with a predecessor write if any ranges overlap.
 *  A candidate write conflicts with a predecessor read if any ranges overlap.
 *  A candidate write conflicts with a predecessor write if any ranges overlap.
d106 7
a112 8
#define	STRIPELOCK_CONFLICT(_cand,_pred)				\
	(RANGE_OVERLAP((_cand), (_pred)) &&				\
	 (((((_cand)->type == RF_IO_TYPE_READ) &&			\
	    ((_pred)->type == RF_IO_TYPE_WRITE)) ||			\
	   (((_cand)->type == RF_IO_TYPE_WRITE) &&			\
	    ((_pred)->type == RF_IO_TYPE_READ)) ||			\
	   (((_cand)->type == RF_IO_TYPE_WRITE) &&			\
	    ((_pred)->type == RF_IO_TYPE_WRITE)))))
d115 3
a117 3
#define	RF_MAX_FREE_STRIPELOCK		128
#define	RF_STRIPELOCK_INC		  8
#define	RF_STRIPELOCK_INITIAL		 32
d119 2
a120 2
void rf_ShutdownStripeLockFreeList(void *);
void rf_RaidShutdownStripeLocks(void *);
d122 3
a124 2
void
rf_ShutdownStripeLockFreeList(void *ignored)
d126 1
a126 2
	RF_FREELIST_DESTROY(rf_stripelock_freelist, next,
	    (RF_StripeLockDesc_t *));
d129 3
a131 2
int
rf_ConfigureStripeLockFreeList(RF_ShutdownList_t **listp)
d134 1
a134 1
	int rc;
d140 2
a141 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s"
		    " line %d rc=%d.\n", __FILE__, __LINE__, rc);
d151 1
a151 2
		printf("[WARNING:  lock table size must be a power of two."
		    " Setting to %d.]\n", RF_DEFAULT_LOCK_TABLE_SIZE);
d158 1
a158 1
rf_MakeLockTable(void)
d161 1
a161 1
	int i, rc;
d163 1
a163 2
	RF_Calloc(lockTable, ((int) rf_lockTableSize),
	    sizeof(RF_LockTableEntry_t), (RF_LockTableEntry_t *));
d169 3
a171 3
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			    " rc=%d.\n", __FILE__, __LINE__, rc);
			/* XXX Clean up other mutexes. */
d178 2
a179 2
void
rf_ShutdownStripeLocks(RF_LockTableEntry_t *lockTable)
d181 1
a181 1
	int i;
d184 1
a184 1
		rf_PrintLockedStripes(lockTable);
d192 3
a194 2
void
rf_RaidShutdownStripeLocks(void *arg)
d200 5
a204 3
int
rf_ConfigureStripeLocks(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d206 1
a206 1
	int rc;
d213 2
a214 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
d220 3
a222 5

/*
 * Returns 0 if you've got the lock, and non-zero if you have to wait.
 * If and only if you have to wait, we'll cause cbFunc to get invoked
 * with cbArg when you are granted the lock. We store a tag in *releaseTag
d225 5
a229 3
int
rf_AcquireStripeLock(RF_LockTableEntry_t *lockTable, RF_StripeNum_t stripeID,
    RF_LockReqDesc_t *lockReqDesc)
d233 2
a234 2
	int tid = 0, hashval = HASH_STRIPEID(stripeID);
	int retcode = 0;
d240 1
a240 2
			Dprintf1("[%d] Lock acquisition supressed"
			    " (stripeID == -1).\n", tid);
d242 4
a245 9
			Dprintf8("[%d] Trying to acquire stripe lock table"
			    " 0x%lx SID %ld type %c range %ld-%ld, range2"
			    " %ld-%ld hashval %d.\n", tid,
			    (unsigned long) lockTable, stripeID,
			    lockReqDesc->type, lockReqDesc->start,
			    lockReqDesc->stop, lockReqDesc->start2,
			    lockReqDesc->stop2);
			Dprintf3("[%d] lock %ld hashval %d.\n", tid, stripeID,
			    hashval);
d251 1
a251 1
	lockReqDesc->next = NULL;	/* Just to be sure. */
d254 1
a254 2
	for (lockDesc = lockTable[hashval].descList; lockDesc;
	     lockDesc = lockDesc->next) {
d259 3
a261 3
	if (!lockDesc) {
		/* No entry in table => no one reading or writing. */
		lockDesc = rf_AllocStripeLockDesc(stripeID);
d268 2
a269 5
			Dprintf7("[%d] no one waiting: lock %ld %c %ld-%ld"
			    " %ld-%ld granted.\n", tid, stripeID,
			    lockReqDesc->type,
			    lockReqDesc->start, lockReqDesc->stop,
			    lockReqDesc->start2, lockReqDesc->stop2);
d277 3
a279 5
		if (lockDesc->nWriters == 0) {
			/*
			 * No need to search any lists if there are no writers
			 * anywhere.
			 */
d283 2
a284 5
				Dprintf7("[%d] no writers: lock %ld %c %ld-%ld"
				    " %ld-%ld granted.\n", tid,
				    stripeID, lockReqDesc->type,
				    lockReqDesc->start, lockReqDesc->stop,
				    lockReqDesc->start2, lockReqDesc->stop2);
d288 3
a290 4
			/*
			 * Search the granted & waiting lists for a conflict.
			 * Stop searching as soon as we find one.
			 */
d299 1
a299 2
					if (STRIPELOCK_CONFLICT(lockReqDesc, p))
					{
d304 2
a305 2
				/* No conflicts found => grant lock */
				lockReqDesc->next = lockDesc->granted;
d308 3
a310 7
					Dprintf7("[%d] no conflicts: lock %ld"
					    " %c %ld-%ld %ld-%ld granted.\n",
					    tid, stripeID, lockReqDesc->type,
					    lockReqDesc->start,
					    lockReqDesc->stop,
					    lockReqDesc->start2,
					    lockReqDesc->stop2);
d315 2
a316 6
					Dprintf6("[%d] conflict: lock %ld %c"
					    " %ld-%ld hashval=%d not"
					    " granted.\n", tid, stripeID,
					    lockReqDesc->type,
					    lockReqDesc->start,
					    lockReqDesc->stop,
d318 1
a318 2
					Dprintf3("[%d] lock %ld retcode=%d.\n",
					    tid, stripeID, retcode);
d321 3
a323 3
				/* Conflict => the current access must wait. */
				rf_AddToWaitersQueue(lockTable, lockDesc,
				    lockReqDesc);
d332 5
a336 3
void
rf_ReleaseStripeLock(RF_LockTableEntry_t *lockTable, RF_StripeNum_t stripeID,
    RF_LockReqDesc_t *lockReqDesc)
d341 2
a342 2
	int tid = 0, hashval = HASH_STRIPEID(stripeID);
	int release_it, consider_it;
d349 1
a349 2
			Dprintf1("[%d] Lock release supressed"
			    " (stripeID == -1).\n", tid);
d351 2
a352 6
			Dprintf8("[%d] Releasing stripe lock on stripe ID %ld,"
			    " type %c range %ld-%ld %ld-%ld table 0x%lx.\n",
			    tid, stripeID, lockReqDesc->type,
			    lockReqDesc->start, lockReqDesc->stop,
			    lockReqDesc->start2, lockReqDesc->stop2,
			    lockTable);
d361 2
a362 3
	/* Find the stripe lock descriptor. */
	for (ld_t = NULL, lockDesc = lockTable[hashval].descList;
	     lockDesc; ld_t = lockDesc, lockDesc = lockDesc->next) {
d366 2
a367 4
	RF_ASSERT(lockDesc);	/*
				 * Major error to release a lock that doesn't
				 * exist.
				 */
d369 1
a369 1
	/* Find the stripe lock request descriptor & delete it from the list. */
d374 1
a374 2
	RF_ASSERT(lr && (lr == lockReqDesc));	/*
						 * Major error to release a
d376 1
a376 2
						 * granted.
						 */
d388 2
a389 3
	/*
	 * Search through the waiters list to see if anyone needs to be woken
	 * up. For each such descriptor in the wait list, we check it against
d391 3
a393 4
	 * waiters queue. If it conflicts with none of these, we release it.
	 *
	 * DON'T TOUCH THE TEMPLINK POINTER OF ANYTHING IN THE GRANTED LIST
	 * HERE.
d395 1
a395 1
	 * lock in the same stripe. There are some asserts to try and detect
d397 9
a405 11
	 *
	 * We apply 2 performance optimizations:
	 * (1) If releasing this lock results in no more writers to this
	 *     stripe, we just release everybody waiting, since we place no
	 *     restrictions on the number of concurrent reads.
	 * (2) We consider as candidates for wakeup only those waiters that
	 *     have a range overlap with either the descriptor being woken up
	 *     or with something in the callbacklist (i.e. something we've
	 *     just now woken up).
	 * This allows us to avoid the long evaluation for some descriptors.
	 */
d408 1
a408 1
	if (lockDesc->nWriters == 0) {	/* Performance tweak (1). */
d411 2
a412 4
			lr = lockDesc->waitersH;	/*
							 * Delete from waiters
							 * list.
							 */
d417 1
a417 3
			lr->next = lockDesc->granted;	/*
							 * Add to granted list.
							 */
d421 1
a421 2
			lr->templink = callbacklist;	/*
							 * Put on callback list
d423 1
a423 2
							 * callback below.
							 */
d426 2
a427 6
				Dprintf8("[%d] No writers: granting lock"
				    " stripe ID %ld, type %c range %ld-%l"
				    "d %ld-%ld table 0x%lx.\n", tid, stripeID,
				    lr->type, lr->start, lr->stop,
				    lr->start2, lr->stop2,
				    (unsigned long) lockTable);
d431 2
a432 4
		lockDesc->waitersT = NULL;	/*
						 * We've purged the whole
						 * waiters list.
						 */
d435 1
a435 2
		for (candidate_t = NULL, candidate = lockDesc->waitersH;
		     candidate;) {
d437 1
a437 1
			/* Performance tweak (2). */
d449 2
a450 7
					Dprintf8("[%d] No overlap: rejecting"
					    " candidate stripeID %ld, type %c"
					    " range %ld-%ld %ld-%ld table"
					    " 0x%lx.\n", tid, stripeID,
					    candidate->type,
					    candidate->start, candidate->stop,
					    candidate->start2, candidate->stop2,
d458 2
a459 4
			/*
			 * We have a candidate for release. Check to make
			 * sure it is not blocked by any granted locks.
			 */
d461 2
a462 4
			for (predecessor = lockDesc->granted; predecessor;
			     predecessor = predecessor->next) {
				if (STRIPELOCK_CONFLICT(candidate, predecessor))
				{
d464 2
a465 11
						Dprintf8("[%d] Conflicts with"
						    " granted lock: rejecting"
						    " candidate stripeID %ld,"
						    " type %c range %ld-%ld"
						    " %ld-%ld table 0x%lx.\n",
						    tid, stripeID,
						    candidate->type,
						    candidate->start,
						    candidate->stop,
						    candidate->start2,
						    candidate->stop2,
d474 2
a475 4
			/*
			 * Now check to see if the candidate is blocked by any
			 * waiters that occur before it in the wait queue.
			 */
d477 2
a478 5
				for (predecessor = lockDesc->waitersH;
				     predecessor != candidate;
				     predecessor = predecessor->next) {
					if (STRIPELOCK_CONFLICT(candidate,
					    predecessor)) {
d480 3
a482 18
							Dprintf8("[%d]"
							    " Conflicts with"
							    " waiting lock:"
							    " rejecting"
							    " candidate"
							    " stripeID %ld,"
							    " type %c"
							    " range %ld-%ld"
							    " %ld-%ld"
							    " table 0x%lx.\n",
							    tid, stripeID,
							    candidate->type,
							    candidate->start,
							    candidate->stop,
							    candidate->start2,
							    candidate->stop2,
							    (unsigned long)
							     lockTable);
d490 1
a490 1
			/* Release it if indicated. */
d493 2
a494 7
					Dprintf8("[%d] Granting lock to"
					    " candidate stripeID %ld, type %c"
					    " range %ld-%ld %ld-%ld table"
					    " 0x%lx.\n", tid, stripeID,
					    candidate->type,
					    candidate->start, candidate->stop,
					    candidate->start2, candidate->stop2,
d501 3
a503 7
						/*
						 * Cannot be waitersH
						 * since candidate_t is
						 * not NULL.
						 */
						lockDesc->waitersT =
						    candidate_t;
d505 2
a506 4
					RF_ASSERT(candidate ==
					    lockDesc->waitersH);
					lockDesc->waitersH =
					    lockDesc->waitersH->next;
d510 2
a511 2
				/* Move it to the granted list. */
				candidate->next = lockDesc->granted;
d515 4
a518 5
				/*
				 * Put it on the list of things to be called
				 * after we release the mutex.
				 */
				candidate->templink = callbacklist;
d524 2
a525 4
					/*
					 * Continue with the rest of the list.
					 */
					candidate = candidate_t->next;
d528 2
a529 2
				/* Continue with the rest of the list. */
				candidate = candidate->next;
d533 1
a533 1
	/* Delete the descriptor if no one is waiting or active. */
d537 1
a537 3
			Dprintf3("[%d] Last lock released (table 0x%lx):"
			    " deleting desc for stripeID %ld.\n", tid,
			    (unsigned long) lockTable, stripeID);
d546 2
a547 2
		rf_FreeStripeLockDesc(lockDesc);
		lockDesc = NULL;	/* Only for the ASSERT below. */
d551 3
a553 6
	/*
	 * Now that we've unlocked the mutex, invoke the callback on all the
	 * descriptors in the list.
	 */
	RF_ASSERT(!((callbacklist) && (!lockDesc)));	/*
							 * If we deleted the
d556 1
a556 2
							 * do.
							 */
d564 6
a569 5

/* Must have the indicated lock table mutex upon entry. */
void
rf_AddToWaitersQueue(RF_LockTableEntry_t *lockTable,
    RF_StripeLockDesc_t *lockDesc, RF_LockReqDesc_t *lockReqDesc)
d571 1
a571 1
	int tid;
d574 1
a574 2
		Dprintf3("[%d] Waiting on lock for stripe %ld table 0x%lx.\n",
		    tid, lockDesc->stripeID, (unsigned long) lockTable);
d585 2
a586 2
RF_StripeLockDesc_t *
rf_AllocStripeLockDesc(RF_StripeNum_t stripeID)
d590 1
a590 2
	RF_FREELIST_GET(rf_stripelock_freelist, p, next,
	    (RF_StripeLockDesc_t *));
d597 2
a598 2
void
rf_FreeStripeLockDesc(RF_StripeLockDesc_t *p)
d603 3
a605 2
void
rf_PrintLockedStripes(RF_LockTableEntry_t *lockTable)
d607 1
a607 1
	int i, j, foundone = 0, did;
d618 1
a618 2
				    (long) p->stripeID, (int) p->stripeID,
				    p->nWriters);
d624 2
a625 4
				for (did = 1, j = 0, q = p->granted; q;
				     j++, q = q->next) {
					printf("  %c(%ld-%ld", q->type,
					    (long) q->start, (long) q->stop);
d627 1
a627 2
						printf(",%ld-%ld) ",
						    (long) q->start2,
d644 2
a645 4
				for (did = 1, j = 0, q = p->waitersH; q;
				     j++, q = q->next) {
					printf("%c(%ld-%ld", q->type,
					    (long) q->start, (long) q->stop);
d647 1
a647 3
						printf(",%ld-%ld) ",
						    (long) q->start2,
						    (long) q->stop2);
@


1.3
log
@sync with NetBSD
- remove unused are from IO_BUF_ERR in rf_driver.c
- remove unused define in rf_stripelocks.c
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_stripelocks.c,v 1.2 1999/02/16 00:03:28 niklas Exp $	*/
/*	$NetBSD: rf_stripelocks.c,v 1.4 2000/01/07 03:04:41 oster Exp $	*/
a63 1
#include "rf_threadid.h"
a238 1
		rf_get_threadid(tid);
a347 1
		rf_get_threadid(tid);
a573 1
		rf_get_threadid(tid);
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_stripelocks.c,v 1.1 1999/01/11 14:29:51 niklas Exp $	*/
/*	$NetBSD: rf_stripelocks.c,v 1.3 1999/02/05 00:06:17 oster Exp $	*/
a82 1
#define MAX_FREELIST 100
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_stripelocks.c,v 1.1 1998/11/13 04:20:34 oster Exp $	*/
/*	$NetBSD: rf_stripelocks.c,v 1.1 1998/11/13 04:20:34 oster Exp $	*/
a29 87
/* :  
 * Log: rf_stripelocks.c,v 
 * Revision 1.35  1996/06/10 12:50:57  jimz
 * Add counters to freelists to track number of allocations, frees,
 * grows, max size, etc. Adjust a couple sets of PRIME params based
 * on the results.
 *
 * Revision 1.34  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.33  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.32  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.31  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.30  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.29  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.28  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.27  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.26  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.25  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.24  1996/05/20  16:15:00  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.23  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.22  1996/05/16  22:28:11  jimz
 * misc cleanup
 *
 * Revision 1.21  1996/05/15  23:39:52  jimz
 * remove #if 0 code
 *
 * Revision 1.20  1996/05/15  23:37:38  jimz
 * convert to using RF_FREELIST stuff for StripeLockDesc allocation
 *
 * Revision 1.19  1996/05/08  18:00:53  jimz
 * fix number of args to debug printf
 *
 * Revision 1.18  1996/05/06  22:33:07  jimz
 * added better debug info
 *
 * Revision 1.17  1996/05/06  22:09:01  wvcii
 * added copyright info and change log
 *
 */

a59 4
#ifdef _KERNEL
#define KERNEL
#endif

a79 3
#ifndef KERNEL
#define FLUSH fflush(stdout)
#else /* !KERNEL */
a80 1
#endif /* !KERNEL */
d85 1
a85 1
static void AddToWaitersQueue(RF_LockTableEntry_t *lockTable, RF_StripeLockDesc_t *lockDesc, RF_LockReqDesc_t *lockReqDesc);
d87 2
a88 2
static void FreeStripeLockDesc(RF_StripeLockDesc_t *p);
static void PrintLockedStripes(RF_LockTableEntry_t *lockTable);
d124 3
a126 2
static void rf_ShutdownStripeLockFreeList(ignored)
  void  *ignored;
d128 1
a128 1
	RF_FREELIST_DESTROY(rf_stripelock_freelist,next,(RF_StripeLockDesc_t *));
d131 3
a133 2
int rf_ConfigureStripeLockFreeList(listp)
  RF_ShutdownList_t  **listp;
d136 1
a136 1
	int rc;
d139 1
a139 1
		RF_STRIPELOCK_INITIAL,sizeof(RF_StripeLockDesc_t));
d143 1
a143 1
			__FILE__, __LINE__, rc);
d145 1
a145 1
		return(rc);
d147 4
a150 4
	RF_FREELIST_PRIME(rf_stripelock_freelist,RF_STRIPELOCK_INITIAL,next,
		(RF_StripeLockDesc_t *));
	for (mask=0x1; mask; mask<<=1)
		if (rf_lockTableSize==mask)
d153 1
a153 1
		printf("[WARNING:  lock table size must be a power of two.  Setting to %d.]\n",RF_DEFAULT_LOCK_TABLE_SIZE);
d156 1
a156 1
	return(0);
d159 2
a160 1
RF_LockTableEntry_t *rf_MakeLockTable()
d163 1
a163 1
	int i, rc;
d167 2
a168 2
		return(NULL);
	for (i=0; i<rf_lockTableSize; i++) {
d171 2
a172 2
		    RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
		      __LINE__, rc);
d174 1
a174 1
			return(NULL);
d177 1
a177 1
	return(lockTable);
d180 2
a181 1
void rf_ShutdownStripeLocks(RF_LockTableEntry_t *lockTable)
d183 1
a183 1
	int i;
d188 1
a188 1
	for (i=0; i<rf_lockTableSize; i++) {
d191 1
a191 1
	RF_Free(lockTable, rf_lockTableSize*sizeof(RF_LockTableEntry_t));
d194 3
a196 2
static void rf_RaidShutdownStripeLocks(arg)
  void  *arg;
d198 1
a198 1
	RF_Raid_t *raidPtr = (RF_Raid_t *)arg;
d202 5
a206 4
int rf_ConfigureStripeLocks(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
d208 1
a208 1
	int rc;
d212 1
a212 1
		return(ENOMEM);
d216 1
a216 1
			__FILE__, __LINE__, rc);
d218 1
a218 1
		return(rc);
d220 1
a220 1
	return(0);
a221 1

d227 13
a239 58
int rf_AcquireStripeLock(
  RF_LockTableEntry_t  *lockTable,
  RF_StripeNum_t        stripeID,
  RF_LockReqDesc_t     *lockReqDesc)
{
  RF_StripeLockDesc_t *lockDesc;
  RF_LockReqDesc_t    *p;
  int tid=0, hashval = HASH_STRIPEID(stripeID);
  int retcode = 0;

  RF_ASSERT(RF_IO_IS_R_OR_W(lockReqDesc->type));

  if (rf_stripeLockDebug) {
    rf_get_threadid(tid);
    if (stripeID == -1) Dprintf1("[%d] Lock acquisition supressed (stripeID == -1)\n",tid);
    else {
      Dprintf8("[%d] Trying to acquire stripe lock table 0x%lx SID %ld type %c range %ld-%ld, range2 %ld-%ld hashval %d\n",
        tid, (unsigned long) lockTable, stripeID, lockReqDesc->type, lockReqDesc->start,
        lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2);
      Dprintf3("[%d] lock %ld hashval %d\n", tid, stripeID, hashval);
      FLUSH;
    }
  }
  if (stripeID == -1) return(0);
  lockReqDesc->next = NULL;                       /* just to be sure */
  
  RF_LOCK_MUTEX(lockTable[hashval].mutex);
  for (lockDesc = lockTable[hashval].descList; lockDesc; lockDesc=lockDesc->next) {
    if (lockDesc->stripeID == stripeID) break;
  }
  
  if (!lockDesc) {            /* no entry in table => no one reading or writing */
    lockDesc = AllocStripeLockDesc(stripeID);
    lockDesc->next = lockTable[hashval].descList;
    lockTable[hashval].descList = lockDesc;
    if (lockReqDesc->type == RF_IO_TYPE_WRITE) lockDesc->nWriters++;
    lockDesc->granted = lockReqDesc;
    if (rf_stripeLockDebug) {Dprintf7("[%d] no one waiting: lock %ld %c %ld-%ld %ld-%ld granted\n",
				tid,stripeID,lockReqDesc->type,lockReqDesc->start,lockReqDesc->stop,lockReqDesc->start2,lockReqDesc->stop2); FLUSH;}
  } else {

    if (lockReqDesc->type == RF_IO_TYPE_WRITE) lockDesc->nWriters++;
    
    if (lockDesc->nWriters == 0) {                        /* no need to search any lists if there are no writers anywhere */
      lockReqDesc->next = lockDesc->granted;
      lockDesc->granted = lockReqDesc;
      if (rf_stripeLockDebug) {Dprintf7("[%d] no writers: lock %ld %c %ld-%ld %ld-%ld granted\n",
				  tid,stripeID,lockReqDesc->type,lockReqDesc->start,lockReqDesc->stop,lockReqDesc->start2,lockReqDesc->stop2); FLUSH;}
    } else {

      /* search the granted & waiting lists for a conflict.  stop searching as soon as we find one */
      retcode = 0;
      for (p = lockDesc->granted; p; p=p->next) if (STRIPELOCK_CONFLICT(lockReqDesc, p)) {retcode = 1; break;}
      if (!retcode) for (p = lockDesc->waitersH; p; p=p->next) if (STRIPELOCK_CONFLICT(lockReqDesc, p)) {retcode = 2; break;}

      if (!retcode) {
	lockReqDesc->next = lockDesc->granted;                                   /* no conflicts found => grant lock */
	lockDesc->granted = lockReqDesc;
d241 88
a328 4
		Dprintf7("[%d] no conflicts: lock %ld %c %ld-%ld %ld-%ld granted\n",
			tid,stripeID,lockReqDesc->type,lockReqDesc->start,lockReqDesc->stop,
			lockReqDesc->start2,lockReqDesc->stop2);
		FLUSH;
d330 20
a349 1
      } else {
d351 215
a565 5
		Dprintf6("[%d] conflict: lock %ld %c %ld-%ld hashval=%d not granted\n",
				tid,stripeID,lockReqDesc->type,lockReqDesc->start,lockReqDesc->stop,
				hashval);
		Dprintf3("[%d] lock %ld retcode=%d\n", tid, stripeID, retcode);
		FLUSH;
a566 180
	AddToWaitersQueue(lockTable, lockDesc, lockReqDesc);                     /* conflict => the current access must wait */
      }
    }
  }

  RF_UNLOCK_MUTEX(lockTable[hashval].mutex);
  return(retcode);
}

void rf_ReleaseStripeLock(
  RF_LockTableEntry_t  *lockTable,
  RF_StripeNum_t        stripeID,
  RF_LockReqDesc_t     *lockReqDesc)
{
  RF_StripeLockDesc_t *lockDesc, *ld_t;
  RF_LockReqDesc_t    *lr, *lr_t, *callbacklist, *t;
  RF_IoType_t type = lockReqDesc->type;
  int tid=0, hashval = HASH_STRIPEID(stripeID);
  int release_it, consider_it;
  RF_LockReqDesc_t *candidate, *candidate_t, *predecessor;

  RF_ASSERT(RF_IO_IS_R_OR_W(type));

  if (rf_stripeLockDebug) {
    rf_get_threadid(tid);
    if (stripeID == -1) Dprintf1("[%d] Lock release supressed (stripeID == -1)\n",tid);
    else {Dprintf8("[%d] Releasing stripe lock on stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
		 tid,stripeID,lockReqDesc->type,lockReqDesc->start,lockReqDesc->stop,lockReqDesc->start2,lockReqDesc->stop2, lockTable); FLUSH;}
  }

  if (stripeID == -1) return;
  
  RF_LOCK_MUTEX(lockTable[hashval].mutex);

  /* find the stripe lock descriptor */
  for (ld_t = NULL, lockDesc = lockTable[hashval].descList; lockDesc; ld_t = lockDesc, lockDesc=lockDesc->next) {
    if (lockDesc->stripeID == stripeID) break;
  }
  RF_ASSERT(lockDesc);                                    /* major error to release a lock that doesn't exist */

  /* find the stripe lock request descriptor & delete it from the list */
  for (lr_t = NULL, lr = lockDesc->granted; lr; lr_t = lr, lr=lr->next) if (lr == lockReqDesc) break;
  
  RF_ASSERT(lr && (lr == lockReqDesc));                            /* major error to release a lock that hasn't been granted */
  if (lr_t) lr_t->next = lr->next; else {
    RF_ASSERT(lr == lockDesc->granted);
    lockDesc->granted = lr->next;
  }
  lr->next = NULL;
  
  if (lockReqDesc->type == RF_IO_TYPE_WRITE) lockDesc->nWriters--;

  /* search through the waiters list to see if anyone needs to be woken up.
   * for each such descriptor in the wait list, we check it against everything granted and against
   * everything _in front_ of it in the waiters queue.  If it conflicts with none of these, we release it.
   *
   * DON'T TOUCH THE TEMPLINK POINTER OF ANYTHING IN THE GRANTED LIST HERE.  This will roach the case where
   * the callback tries to acquire a new lock in the same stripe.  There are some asserts to try and detect this.
   *
   * We apply 2 performance optimizations:
   * (1) if releasing this lock results in no more writers to this stripe, we just release everybody waiting,
   * since we place no restrictions on the number of concurrent reads.
   * (2) we consider as candidates for wakeup only those waiters that have a range overlap with either
   * the descriptor being woken up or with something in the callbacklist (i.e. something we've just now woken up).
   * This allows us to avoid the long evaluation for some descriptors.
   */
  
  callbacklist = NULL;
  if (lockDesc->nWriters == 0) {                          /* performance tweak (1) */
    while (lockDesc->waitersH) {
      
      lr = lockDesc->waitersH;                            /* delete from waiters list */
      lockDesc->waitersH = lr->next;
      
      RF_ASSERT(lr->type == RF_IO_TYPE_READ);
      
      lr->next = lockDesc->granted;                       /* add to granted list */
      lockDesc->granted = lr;

      RF_ASSERT(!lr->templink);
      lr->templink = callbacklist;                        /* put on callback list so that we'll invoke callback below */
      callbacklist = lr;
      if (rf_stripeLockDebug) {Dprintf8("[%d] No writers: granting lock stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
				     tid,stripeID,lr->type,lr->start,lr->stop,lr->start2,lr->stop2,(unsigned long) lockTable); FLUSH;}
    }
    lockDesc->waitersT = NULL;                            /* we've purged the whole waiters list */
      
  } else for (candidate_t = NULL, candidate = lockDesc->waitersH; candidate; ) {
  
    /* performance tweak (2) */
    consider_it = 0;
    if (RANGE_OVERLAP(lockReqDesc, candidate)) consider_it = 1;
    else for (t = callbacklist; t; t=t->templink) if (RANGE_OVERLAP(t, candidate)) {
      consider_it = 1;
      break;
    }
    if (!consider_it) {
      if (rf_stripeLockDebug) {Dprintf8("[%d] No overlap: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
				     tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,
				     (unsigned long) lockTable); FLUSH;}
      candidate_t = candidate; candidate = candidate->next;
      continue;
    }
    
    
    /* we have a candidate for release.  check to make sure it is not blocked by any granted locks */
    release_it = 1;
    for (predecessor = lockDesc->granted; predecessor; predecessor = predecessor->next) {
      if (STRIPELOCK_CONFLICT(candidate, predecessor)) {
	if (rf_stripeLockDebug) {
	  Dprintf8("[%d] Conflicts with granted lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
		   tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,
		   (unsigned long) lockTable); FLUSH;
	}
	release_it = 0; break;
      }
    }
    
    /* now check to see if the candidate is blocked by any waiters that occur before it it the wait queue */
    if (release_it) for (predecessor = lockDesc->waitersH; predecessor != candidate; predecessor = predecessor->next) {
      if (STRIPELOCK_CONFLICT(candidate, predecessor)) {
	if (rf_stripeLockDebug) {
	  Dprintf8("[%d] Conflicts with waiting lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
		   tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,
		   (unsigned long) lockTable); FLUSH;
	}
	release_it = 0; break;
      }
    }
    
    /* release it if indicated */
    if (release_it) {
      if (rf_stripeLockDebug) {Dprintf8("[%d] Granting lock to candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n",
				     tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,
				     (unsigned long) lockTable); FLUSH;}
      if (candidate_t) {
	candidate_t->next = candidate->next;
	if (lockDesc->waitersT == candidate) lockDesc->waitersT = candidate_t;       /* cannot be waitersH since candidate_t is not NULL */
      } else {
	RF_ASSERT(candidate == lockDesc->waitersH);
	lockDesc->waitersH = lockDesc->waitersH->next;
	if (!lockDesc->waitersH) lockDesc->waitersT = NULL;
      }
      candidate->next = lockDesc->granted;                    /* move it to the granted list */
      lockDesc->granted = candidate;
      
      RF_ASSERT(!candidate->templink);
      candidate->templink = callbacklist;                     /* put it on the list of things to be called after we release the mutex */
      callbacklist = candidate;
      
      if (!candidate_t) candidate = lockDesc->waitersH; else candidate = candidate_t->next;     /* continue with the rest of the list */
    } else {
      candidate_t = candidate; candidate = candidate->next;                                     /* continue with the rest of the list */
    }
  }

  /* delete the descriptor if no one is waiting or active */
  if (!lockDesc->granted && !lockDesc->waitersH) {
    RF_ASSERT(lockDesc->nWriters == 0);
    if (rf_stripeLockDebug) {
      Dprintf3("[%d] Last lock released (table 0x%lx): deleting desc for stripeID %ld\n",tid,(unsigned long) lockTable, stripeID); FLUSH;
    }
    if (ld_t) ld_t->next = lockDesc->next; else {
      RF_ASSERT(lockDesc == lockTable[hashval].descList);
      lockTable[hashval].descList = lockDesc->next;
    }
    FreeStripeLockDesc(lockDesc);
    lockDesc = NULL;                                                               /* only for the ASSERT below */
  }
	
  RF_UNLOCK_MUTEX(lockTable[hashval].mutex);

  /* now that we've unlocked the mutex, invoke the callback on all the descriptors in the list */
  RF_ASSERT(!( (callbacklist) && (!lockDesc) ));                   /* if we deleted the descriptor, we should have no callbacks to do */
  for (candidate = callbacklist; candidate; ) {
    t = candidate;
    candidate = candidate->templink;
    t->templink = NULL;
    (t->cbFunc)(t->cbArg);
  }
d568 8
d577 11
a587 18
/* must have the indicated lock table mutex upon entry */
static void AddToWaitersQueue(
  RF_LockTableEntry_t  *lockTable,
  RF_StripeLockDesc_t  *lockDesc,
  RF_LockReqDesc_t     *lockReqDesc)
{
  int tid;

  if (rf_stripeLockDebug) {
    rf_get_threadid(tid);
    Dprintf3("[%d] Waiting on lock for stripe %ld table 0x%lx\n", tid, lockDesc->stripeID, (unsigned long) lockTable); FLUSH;
  }
  if (!lockDesc->waitersH) {
    lockDesc->waitersH = lockDesc->waitersT = lockReqDesc;
  } else {
    lockDesc->waitersT->next = lockReqDesc;
    lockDesc->waitersT = lockReqDesc;
  }
d590 2
a591 1
static RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID)
d595 1
a595 1
	RF_FREELIST_GET(rf_stripelock_freelist,p,next,(RF_StripeLockDesc_t *));
d599 1
a599 1
	return(p);
d602 2
a603 1
static void FreeStripeLockDesc(RF_StripeLockDesc_t *p)
d605 1
a605 1
	RF_FREELIST_FREE(rf_stripelock_freelist,p,next);
d608 62
a669 35
static void PrintLockedStripes(lockTable)
  RF_LockTableEntry_t  *lockTable;
{
  int i, j, foundone = 0, did;
  RF_StripeLockDesc_t *p;
  RF_LockReqDesc_t *q;

  RF_LOCK_MUTEX(rf_printf_mutex);
  printf("Locked stripes:\n");
  for (i=0; i<rf_lockTableSize; i++) if (lockTable[i].descList) {
    foundone = 1;
    for (p = lockTable[i].descList; p; p=p->next) {
      printf("Stripe ID 0x%lx (%d) nWriters %d\n",
	     (long)p->stripeID, (int)p->stripeID, p->nWriters);
      
      if (! (p->granted) ) printf("Granted: (none)\n"); else printf("Granted:\n");
      for (did=1,j=0,q = p->granted; q; j++,q=q->next) {
	printf("  %c(%ld-%ld",q->type,(long)q->start,(long)q->stop);
	if (q->start2 != -1) printf(",%ld-%ld) ",(long)q->start2,
				    (long)q->stop2); else printf(") ");
	if (j && !(j%4)) {printf("\n"); did=1;} else did=0;
      }
      if (!did) printf("\n");
      
      if (! (p->waitersH) ) printf("Waiting: (none)\n"); else printf("Waiting:\n");
      for (did=1,j=0,q = p->waitersH; q; j++,q=q->next) {
	printf("%c(%ld-%ld",q->type,(long)q->start,(long)q->stop);
	if (q->start2 != -1) printf(",%ld-%ld) ",(long)q->start2,(long)q->stop2); else printf(") ");
	if (j && !(j%4)) {printf("\n         "); did=1;} else did=0;
      }
      if (!did) printf("\n");
    }
  }
  if (!foundone) printf("(none)\n"); else printf("\n");
  RF_UNLOCK_MUTEX(rf_printf_mutex);
@

