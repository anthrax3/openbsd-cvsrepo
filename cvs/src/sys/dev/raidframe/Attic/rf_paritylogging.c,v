head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.38
	OPENBSD_5_0:1.6.0.36
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.34
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.32
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.28
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.30
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.26
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.24
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.22
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.20
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.12
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.10
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.8
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.6;

1.6
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.08.16.07.44;	author peter;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.01.07.14.50.22;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.06;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.35;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.14.22.26.13;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.5.8.1
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_paritylogging.c,v 1.6 2002/12/16 07:01:04 tdeval Exp $	*/
/*	$NetBSD: rf_paritylogging.c,v 1.10 2000/02/12 16:06:27 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: William V. Courtright II
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */


/*
 * Parity logging configuration, dag selection, and mapping is implemented here.
 */

#include "rf_archs.h"

#if	RF_INCLUDE_PARITYLOGGING > 0

#include "rf_types.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagutils.h"
#include "rf_dagfuncs.h"
#include "rf_dagffrd.h"
#include "rf_dagffwr.h"
#include "rf_dagdegrd.h"
#include "rf_dagdegwr.h"
#include "rf_paritylog.h"
#include "rf_paritylogDiskMgr.h"
#include "rf_paritylogging.h"
#include "rf_parityloggingdags.h"
#include "rf_general.h"
#include "rf_map.h"
#include "rf_utils.h"
#include "rf_shutdown.h"

typedef struct RF_ParityLoggingConfigInfo_s {
	RF_RowCol_t **stripeIdentifier;	/*
					 * Filled in at config time & used by
					 * IdentifyStripe.
					 */
} RF_ParityLoggingConfigInfo_t;

void rf_FreeRegionInfo(RF_Raid_t *, RF_RegionId_t);
void rf_FreeParityLogQueue(RF_Raid_t *, RF_ParityLogQueue_t *);
void rf_FreeRegionBufferQueue(RF_RegionBufferQueue_t *);
void rf_ShutdownParityLogging(RF_ThreadArg_t);
void rf_ShutdownParityLoggingRegionInfo(RF_ThreadArg_t);
void rf_ShutdownParityLoggingPool(RF_ThreadArg_t);
void rf_ShutdownParityLoggingRegionBufferPool(RF_ThreadArg_t);
void rf_ShutdownParityLoggingParityBufferPool(RF_ThreadArg_t);
void rf_ShutdownParityLoggingDiskQueue(RF_ThreadArg_t);


int
rf_ConfigureParityLogging(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	int i, j, startdisk, rc;
	RF_SectorCount_t totalLogCapacity, fragmentation, lastRegionCapacity;
	RF_SectorCount_t parityBufferCapacity, maxRegionParityRange;
	RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
	RF_ParityLoggingConfigInfo_t *info;
	RF_ParityLog_t *l = NULL, *next;
	caddr_t lHeapPtr;

	if (rf_numParityRegions <= 0)
		return(EINVAL);

	/*
	 * We create multiple entries on the shutdown list here, since
	 * this configuration routine is fairly complicated in and of
	 * itself, and this makes backing out of a failed configuration
	 * much simpler.
	 */

	raidPtr->numSectorsPerLog = RF_DEFAULT_NUM_SECTORS_PER_LOG;

	/* Create a parity logging configuration structure. */
	RF_MallocAndAdd(info, sizeof(RF_ParityLoggingConfigInfo_t),
			(RF_ParityLoggingConfigInfo_t *),
			raidPtr->cleanupList);
	if (info == NULL)
		return (ENOMEM);
	layoutPtr->layoutSpecificInfo = (void *) info;

	RF_ASSERT(raidPtr->numRow == 1);

	/*
	 * The stripe identifier must identify the disks in each stripe, IN
	 * THE ORDER THAT THEY APPEAR IN THE STRIPE.
	 */
	info->stripeIdentifier = rf_make_2d_array((raidPtr->numCol),
						  (raidPtr->numCol),
						  raidPtr->cleanupList);
	if (info->stripeIdentifier == NULL)
		return (ENOMEM);

	startdisk = 0;
	for (i = 0; i < (raidPtr->numCol); i++) {
		for (j = 0; j < (raidPtr->numCol); j++) {
			info->stripeIdentifier[i][j] = (startdisk + j) %
			    (raidPtr->numCol - 1);
		}
		if ((--startdisk) < 0)
			startdisk = raidPtr->numCol - 1 - 1;
	}

	/* Fill in the remaining layout parameters. */
	layoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
	layoutPtr->numParityCol = 1;
	layoutPtr->numParityLogCol = 1;
	layoutPtr->numDataCol = raidPtr->numCol - layoutPtr->numParityCol -
	    layoutPtr->numParityLogCol;
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
	layoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;

	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;

	/*
	 * Configure parity log parameters.
	 *
	 * Parameter			Comment/constraints
	 * ------------------------------------------------
	 * numParityRegions*		All regions (except possibly last)
	 *				of equal size.
	 * totalInCoreLogCapacity*	Amount of memory in bytes available
	 *				for in-core logs (default 1 MB).
	 * numSectorsPerLog#		Capacity of an in-core log in sectors
	 *				(1 * disk track).
	 * numParityLogs		Total number of in-core logs,
	 *				should be at least numParityRegions.
	 * regionLogCapacity		Size of a region log (except possibly
	 *				last one) in sectors.
	 * totalLogCapacity		Total amount of log space in sectors.
	 *
	 * Where '*' denotes a user settable parameter.
	 * Note that logs are fixed to be the size of a disk track,
	 * value #defined in rf_paritylog.h.
	 *
	 */

	totalLogCapacity = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit * layoutPtr->numParityLogCol;
	raidPtr->regionLogCapacity = totalLogCapacity / rf_numParityRegions;
	if (rf_parityLogDebug)
		printf("bytes per sector %d\n", raidPtr->bytesPerSector);

	/*
	 * Reduce fragmentation within a disk region by adjusting the number
	 * of regions in an attempt to allow an integral number of logs to fit
	 * into a disk region.
	 */
	fragmentation = raidPtr->regionLogCapacity % raidPtr->numSectorsPerLog;
	if (fragmentation > 0)
		for (i = 1; i < (raidPtr->numSectorsPerLog / 2); i++) {
			if (((totalLogCapacity / (rf_numParityRegions + i)) %
			     raidPtr->numSectorsPerLog) < fragmentation) {
				rf_numParityRegions++;
				raidPtr->regionLogCapacity = totalLogCapacity /
				    rf_numParityRegions;
				fragmentation = raidPtr->regionLogCapacity %
				    raidPtr->numSectorsPerLog;
			}
			if (((totalLogCapacity / (rf_numParityRegions - i)) %
			     raidPtr->numSectorsPerLog) < fragmentation) {
				rf_numParityRegions--;
				raidPtr->regionLogCapacity = totalLogCapacity /
				    rf_numParityRegions;
				fragmentation = raidPtr->regionLogCapacity %
				    raidPtr->numSectorsPerLog;
			}
		}
	/* Ensure integral number of regions per log. */
	raidPtr->regionLogCapacity = (raidPtr->regionLogCapacity /
	    raidPtr->numSectorsPerLog) * raidPtr->numSectorsPerLog;

	raidPtr->numParityLogs = rf_totalInCoreLogCapacity /
	    (raidPtr->bytesPerSector * raidPtr->numSectorsPerLog);
	/*
	 * To avoid deadlock, must ensure that enough logs exist for each
	 * region to have one simultaneously.
	 */
	if (raidPtr->numParityLogs < rf_numParityRegions)
		raidPtr->numParityLogs = rf_numParityRegions;

	/* Create region information structs. */
	printf("Allocating %d bytes for in-core parity region info\n",
	       (int) (rf_numParityRegions * sizeof(RF_RegionInfo_t)));
	RF_Malloc(raidPtr->regionInfo,
		  (rf_numParityRegions * sizeof(RF_RegionInfo_t)),
		  (RF_RegionInfo_t *));
	if (raidPtr->regionInfo == NULL)
		return (ENOMEM);

	/* Last region may not be full capacity. */
	lastRegionCapacity = raidPtr->regionLogCapacity;
	while ((rf_numParityRegions - 1) * raidPtr->regionLogCapacity +
	       lastRegionCapacity > totalLogCapacity)
		lastRegionCapacity = lastRegionCapacity -
		    raidPtr->numSectorsPerLog;

	raidPtr->regionParityRange = raidPtr->sectorsPerDisk /
	    rf_numParityRegions;
	maxRegionParityRange = raidPtr->regionParityRange;

	/* I can't remember why this line is in the code -wvcii 6/30/95. */
	/* if (raidPtr->sectorsPerDisk % rf_numParityRegions > 0)
	 *	regionParityRange++; */

	/* Build pool of unused parity logs. */
	printf("Allocating %d bytes for %d parity logs\n",
	       raidPtr->numParityLogs * raidPtr->numSectorsPerLog *
	       raidPtr->bytesPerSector,
	       raidPtr->numParityLogs);
	RF_Malloc(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs *
		  raidPtr->numSectorsPerLog * raidPtr->bytesPerSector,
		  (caddr_t));
	if (raidPtr->parityLogBufferHeap == NULL)
		return (ENOMEM);
	lHeapPtr = raidPtr->parityLogBufferHeap;
	rc = rf_mutex_init(&raidPtr->parityLogPool.mutex);
	if (rc) {
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
			     __FILE__, __LINE__, rc);
		RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs *
			raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
		return (ENOMEM);
	}
	for (i = 0; i < raidPtr->numParityLogs; i++) {
		if (i == 0) {
			RF_Calloc(raidPtr->parityLogPool.parityLogs, 1,
				  sizeof(RF_ParityLog_t), (RF_ParityLog_t *));
			if (raidPtr->parityLogPool.parityLogs == NULL) {
				RF_Free(raidPtr->parityLogBufferHeap,
					raidPtr->numParityLogs *
					raidPtr->numSectorsPerLog *
					raidPtr->bytesPerSector);
				return (ENOMEM);
			}
			l = raidPtr->parityLogPool.parityLogs;
		} else {
			RF_Calloc(l->next, 1, sizeof(RF_ParityLog_t),
				  (RF_ParityLog_t *));
			if (l->next == NULL) {
				RF_Free(raidPtr->parityLogBufferHeap,
					raidPtr->numParityLogs *
					raidPtr->numSectorsPerLog *
					raidPtr->bytesPerSector);
				for (l = raidPtr->parityLogPool.parityLogs;
				     l;
				     l = next) {
					next = l->next;
					if (l->records)
						RF_Free(l->records,
						    (raidPtr->numSectorsPerLog *
						 sizeof(RF_ParityLogRecord_t)));
					RF_Free(l, sizeof(RF_ParityLog_t));
				}
				return (ENOMEM);
			}
			l = l->next;
		}
		l->bufPtr = lHeapPtr;
		lHeapPtr += raidPtr->numSectorsPerLog *
		    raidPtr->bytesPerSector;
		RF_Malloc(l->records, (raidPtr->numSectorsPerLog *
				       sizeof(RF_ParityLogRecord_t)),
			  (RF_ParityLogRecord_t *));
		if (l->records == NULL) {
			RF_Free(raidPtr->parityLogBufferHeap,
				raidPtr->numParityLogs *
				raidPtr->numSectorsPerLog *
				raidPtr->bytesPerSector);
			for (l = raidPtr->parityLogPool.parityLogs;
			     l;
			     l = next) {
				next = l->next;
				if (l->records)
					RF_Free(l->records,
						(raidPtr->numSectorsPerLog *
						 sizeof(RF_ParityLogRecord_t)));
				RF_Free(l, sizeof(RF_ParityLog_t));
			}
			return (ENOMEM);
		}
	}
	rc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingPool, raidPtr);
	if (rc) {
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
		rf_ShutdownParityLoggingPool(raidPtr);
		return (rc);
	}
	/* Build pool of region buffers. */
	rc = rf_mutex_init(&raidPtr->regionBufferPool.mutex);
	if (rc) {
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
			     __FILE__, __LINE__, rc);
		return (ENOMEM);
	}
	rc = rf_cond_init(&raidPtr->regionBufferPool.cond);
	if (rc) {
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
			     __FILE__, __LINE__, rc);
		rf_mutex_destroy(&raidPtr->regionBufferPool.mutex);
		return (ENOMEM);
	}
	raidPtr->regionBufferPool.bufferSize = raidPtr->regionLogCapacity *
	    raidPtr->bytesPerSector;
	printf("regionBufferPool.bufferSize %d\n",
	       raidPtr->regionBufferPool.bufferSize);

	/* For now, only one region at a time may be reintegrated. */
	raidPtr->regionBufferPool.totalBuffers = 1;

	raidPtr->regionBufferPool.availableBuffers =
	    raidPtr->regionBufferPool.totalBuffers;
	raidPtr->regionBufferPool.availBuffersIndex = 0;
	raidPtr->regionBufferPool.emptyBuffersIndex = 0;
	printf("Allocating %d bytes for regionBufferPool\n",
	       (int) (raidPtr->regionBufferPool.totalBuffers *
		      sizeof(caddr_t)));
	RF_Malloc(raidPtr->regionBufferPool.buffers,
		  raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t),
		  (caddr_t *));
	if (raidPtr->regionBufferPool.buffers == NULL) {
		rf_mutex_destroy(&raidPtr->regionBufferPool.mutex);
		rf_cond_destroy(&raidPtr->regionBufferPool.cond);
		return (ENOMEM);
	}
	for (i = 0; i < raidPtr->regionBufferPool.totalBuffers; i++) {
		printf("Allocating %d bytes for regionBufferPool#%d\n",
		       (int) (raidPtr->regionBufferPool.bufferSize *
			      sizeof(char)), i);
		RF_Malloc(raidPtr->regionBufferPool.buffers[i],
			  raidPtr->regionBufferPool.bufferSize * sizeof(char),
			  (caddr_t));
		if (raidPtr->regionBufferPool.buffers[i] == NULL) {
			rf_mutex_destroy(&raidPtr->regionBufferPool.mutex);
			rf_cond_destroy(&raidPtr->regionBufferPool.cond);
			for (j = 0; j < i; j++) {
				RF_Free(raidPtr->regionBufferPool.buffers[i],
					raidPtr->regionBufferPool.bufferSize *
					sizeof(char));
			}
			RF_Free(raidPtr->regionBufferPool.buffers,
				raidPtr->regionBufferPool.totalBuffers *
				sizeof(caddr_t));
			return (ENOMEM);
		}
		printf("raidPtr->regionBufferPool.buffers[%d] = %lx\n", i,
		    (long) raidPtr->regionBufferPool.buffers[i]);
	}
	rc = rf_ShutdownCreate(listp,
			       rf_ShutdownParityLoggingRegionBufferPool,
			       raidPtr);
	if (rc) {
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
		rf_ShutdownParityLoggingRegionBufferPool(raidPtr);
		return (rc);
	}
	/* Build pool of parity buffers. */
	parityBufferCapacity = maxRegionParityRange;
	rc = rf_mutex_init(&raidPtr->parityBufferPool.mutex);
	if (rc) {
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
			     __FILE__, __LINE__, rc);
		return (rc);
	}
	rc = rf_cond_init(&raidPtr->parityBufferPool.cond);
	if (rc) {
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
			     __FILE__, __LINE__, rc);
		rf_mutex_destroy(&raidPtr->parityBufferPool.mutex);
		return (ENOMEM);
	}
	raidPtr->parityBufferPool.bufferSize = parityBufferCapacity *
	    raidPtr->bytesPerSector;
	printf("parityBufferPool.bufferSize %d\n",
	       raidPtr->parityBufferPool.bufferSize);

	/* For now, only one region at a time may be reintegrated. */
	raidPtr->parityBufferPool.totalBuffers = 1;

	raidPtr->parityBufferPool.availableBuffers =
	    raidPtr->parityBufferPool.totalBuffers;
	raidPtr->parityBufferPool.availBuffersIndex = 0;
	raidPtr->parityBufferPool.emptyBuffersIndex = 0;
	printf("Allocating %d bytes for parityBufferPool of %d units\n",
	       (int) (raidPtr->parityBufferPool.totalBuffers *
		      sizeof(caddr_t)),
	       raidPtr->parityBufferPool.totalBuffers);
	RF_Malloc(raidPtr->parityBufferPool.buffers,
		  raidPtr->parityBufferPool.totalBuffers * sizeof(caddr_t),
		  (caddr_t *));
	if (raidPtr->parityBufferPool.buffers == NULL) {
		rf_mutex_destroy(&raidPtr->parityBufferPool.mutex);
		rf_cond_destroy(&raidPtr->parityBufferPool.cond);
		return (ENOMEM);
	}
	for (i = 0; i < raidPtr->parityBufferPool.totalBuffers; i++) {
		printf("Allocating %d bytes for parityBufferPool#%d\n",
		       (int) (raidPtr->parityBufferPool.bufferSize *
			      sizeof(char)), i);
		RF_Malloc(raidPtr->parityBufferPool.buffers[i],
			  raidPtr->parityBufferPool.bufferSize * sizeof(char),
			  (caddr_t));
		if (raidPtr->parityBufferPool.buffers == NULL) {
			rf_mutex_destroy(&raidPtr->parityBufferPool.mutex);
			rf_cond_destroy(&raidPtr->parityBufferPool.cond);
			for (j = 0; j < i; j++) {
				RF_Free(raidPtr->parityBufferPool.buffers[i],
					raidPtr->regionBufferPool.bufferSize *
					sizeof(char));
			}
			RF_Free(raidPtr->parityBufferPool.buffers,
				raidPtr->regionBufferPool.totalBuffers *
				sizeof(caddr_t));
			return (ENOMEM);
		}
		printf("parityBufferPool.buffers[%d] = %lx\n", i,
		    (long) raidPtr->parityBufferPool.buffers[i]);
	}
	rc = rf_ShutdownCreate(listp,
			       rf_ShutdownParityLoggingParityBufferPool,
			       raidPtr);
	if (rc) {
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
		rf_ShutdownParityLoggingParityBufferPool(raidPtr);
		return (rc);
	}
	/* Initialize parityLogDiskQueue. */
	rc = rf_create_managed_mutex(listp,
				     &raidPtr->parityLogDiskQueue.mutex);
	if (rc) {
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
			     __FILE__, __LINE__, rc);
		return (rc);
	}
	rc = rf_create_managed_cond(listp, &raidPtr->parityLogDiskQueue.cond);
	if (rc) {
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
			     __FILE__, __LINE__, rc);
		return (rc);
	}
	raidPtr->parityLogDiskQueue.flushQueue = NULL;
	raidPtr->parityLogDiskQueue.reintQueue = NULL;
	raidPtr->parityLogDiskQueue.bufHead = NULL;
	raidPtr->parityLogDiskQueue.bufTail = NULL;
	raidPtr->parityLogDiskQueue.reintHead = NULL;
	raidPtr->parityLogDiskQueue.reintTail = NULL;
	raidPtr->parityLogDiskQueue.logBlockHead = NULL;
	raidPtr->parityLogDiskQueue.logBlockTail = NULL;
	raidPtr->parityLogDiskQueue.reintBlockHead = NULL;
	raidPtr->parityLogDiskQueue.reintBlockTail = NULL;
	raidPtr->parityLogDiskQueue.freeDataList = NULL;
	raidPtr->parityLogDiskQueue.freeCommonList = NULL;

	rc = rf_ShutdownCreate(listp,
			       rf_ShutdownParityLoggingDiskQueue,
			       raidPtr);
	if (rc) {
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
		return (rc);
	}
	for (i = 0; i < rf_numParityRegions; i++) {
		rc = rf_mutex_init(&raidPtr->regionInfo[i].mutex);
		if (rc) {
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
				     " rc=%d\n", __FILE__, __LINE__, rc);
			for (j = 0; j < i; j++)
				rf_FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo,
				(rf_numParityRegions *
				 sizeof(RF_RegionInfo_t)));
			return (ENOMEM);
		}
		rc = rf_mutex_init(&raidPtr->regionInfo[i].reintMutex);
		if (rc) {
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
				     " rc=%d\n", __FILE__, __LINE__, rc);
			rf_mutex_destroy(&raidPtr->regionInfo[i].mutex);
			for (j = 0; j < i; j++)
				rf_FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo,
				(rf_numParityRegions *
				 sizeof(RF_RegionInfo_t)));
			return (ENOMEM);
		}
		raidPtr->regionInfo[i].reintInProgress = RF_FALSE;
		raidPtr->regionInfo[i].regionStartAddr =
		    raidPtr->regionLogCapacity * i;
		raidPtr->regionInfo[i].parityStartAddr =
		    raidPtr->regionParityRange * i;
		if (i < rf_numParityRegions - 1) {
			raidPtr->regionInfo[i].capacity =
			    raidPtr->regionLogCapacity;
			raidPtr->regionInfo[i].numSectorsParity =
			    raidPtr->regionParityRange;
		} else {
			raidPtr->regionInfo[i].capacity = lastRegionCapacity;
			raidPtr->regionInfo[i].numSectorsParity =
			    raidPtr->sectorsPerDisk -
			    raidPtr->regionParityRange * i;
			if (raidPtr->regionInfo[i].numSectorsParity >
			    maxRegionParityRange)
				maxRegionParityRange =
				    raidPtr->regionInfo[i].numSectorsParity;
		}
		raidPtr->regionInfo[i].diskCount = 0;
		RF_ASSERT(raidPtr->regionInfo[i].capacity +
			  raidPtr->regionInfo[i].regionStartAddr <=
			  totalLogCapacity);
		RF_ASSERT(raidPtr->regionInfo[i].parityStartAddr +
			  raidPtr->regionInfo[i].numSectorsParity <=
			  raidPtr->sectorsPerDisk);
		printf("Allocating %d bytes for region %d\n",
		       (int) (raidPtr->regionInfo[i].capacity *
			   sizeof(RF_DiskMap_t)), i);
		RF_Malloc(raidPtr->regionInfo[i].diskMap,
			  (raidPtr->regionInfo[i].capacity *
			   sizeof(RF_DiskMap_t)),
			  (RF_DiskMap_t *));
		if (raidPtr->regionInfo[i].diskMap == NULL) {
			rf_mutex_destroy(&raidPtr->regionInfo[i].mutex);
			rf_mutex_destroy(&raidPtr->regionInfo[i].reintMutex);
			for (j = 0; j < i; j++)
				rf_FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo,
				(rf_numParityRegions *
				 sizeof(RF_RegionInfo_t)));
			return (ENOMEM);
		}
		raidPtr->regionInfo[i].loggingEnabled = RF_FALSE;
		raidPtr->regionInfo[i].coreLog = NULL;
	}
	rc = rf_ShutdownCreate(listp,
			       rf_ShutdownParityLoggingRegionInfo,
			       raidPtr);
	if (rc) {
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
		rf_ShutdownParityLoggingRegionInfo(raidPtr);
		return (rc);
	}
	RF_ASSERT(raidPtr->parityLogDiskQueue.threadState == 0);
	raidPtr->parityLogDiskQueue.threadState = RF_PLOG_CREATED;
	rc = RF_CREATE_THREAD(raidPtr->pLogDiskThreadHandle,
			      rf_ParityLoggingDiskManager, raidPtr, "rf_log");
	if (rc) {
		raidPtr->parityLogDiskQueue.threadState = 0;
		RF_ERRORMSG3("Unable to create parity logging disk thread"
			     " file %s line %d rc=%d\n",
			     __FILE__, __LINE__, rc);
		return (ENOMEM);
	}
	/* Wait for thread to start. */
	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	while (!(raidPtr->parityLogDiskQueue.threadState & RF_PLOG_RUNNING)) {
		RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond,
			     raidPtr->parityLogDiskQueue.mutex);
	}
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);

	rc = rf_ShutdownCreate(listp, rf_ShutdownParityLogging, raidPtr);
	if (rc) {
		RF_ERRORMSG1("Got rc=%d adding parity logging shutdown"
			     " event.\n", rc);
		rf_ShutdownParityLogging(raidPtr);
		return (rc);
	}
	if (rf_parityLogDebug) {
		printf("\t\t\tsize of disk log in sectors: %d\n",
		       (int) totalLogCapacity);
		printf("\t\t\ttotal number of parity regions is %d\n",
		       (int) rf_numParityRegions);
		printf("\t\t\tnominal sectors of log per parity region is %d\n",
		       (int) raidPtr->regionLogCapacity);
		printf("\t\t\tnominal region fragmentation is %d sectors\n",
		       (int) fragmentation);
		printf("\t\t\ttotal number of parity logs is %d\n",
		       raidPtr->numParityLogs);
		printf("\t\t\tparity log size is %d sectors\n",
		       raidPtr->numSectorsPerLog);
		printf("\t\t\ttotal in-core log space is %d bytes\n",
		       (int) rf_totalInCoreLogCapacity);
	}
	rf_EnableParityLogging(raidPtr);

	return (0);
}


void
rf_FreeRegionInfo(RF_Raid_t *raidPtr, RF_RegionId_t regionID)
{
	RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	RF_Free(raidPtr->regionInfo[regionID].diskMap,
		(raidPtr->regionInfo[regionID].capacity *
		 sizeof(RF_DiskMap_t)));
	if (!rf_forceParityLogReint && raidPtr->regionInfo[regionID].coreLog) {
		rf_ReleaseParityLogs(raidPtr,
				     raidPtr->regionInfo[regionID].coreLog);
		raidPtr->regionInfo[regionID].coreLog = NULL;
	} else {
		RF_ASSERT(raidPtr->regionInfo[regionID].coreLog == NULL);
		RF_ASSERT(raidPtr->regionInfo[regionID].diskCount == 0);
	}
	RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	rf_mutex_destroy(&raidPtr->regionInfo[regionID].mutex);
	rf_mutex_destroy(&raidPtr->regionInfo[regionID].reintMutex);
}


void
rf_FreeParityLogQueue(RF_Raid_t *raidPtr, RF_ParityLogQueue_t *queue)
{
	RF_ParityLog_t *l1, *l2;

	RF_LOCK_MUTEX(queue->mutex);
	l1 = queue->parityLogs;
	while (l1) {
		l2 = l1;
		l1 = l2->next;
		RF_Free(l2->records, (raidPtr->numSectorsPerLog *
				      sizeof(RF_ParityLogRecord_t)));
		RF_Free(l2, sizeof(RF_ParityLog_t));
	}
	RF_UNLOCK_MUTEX(queue->mutex);
	rf_mutex_destroy(&queue->mutex);
}


void
rf_FreeRegionBufferQueue(RF_RegionBufferQueue_t *queue)
{
	int i;

	RF_LOCK_MUTEX(queue->mutex);
	if (queue->availableBuffers != queue->totalBuffers) {
		printf("Attempt to free region queue that is still in use !\n");
		RF_ASSERT(0);
	}
	for (i = 0; i < queue->totalBuffers; i++)
		RF_Free(queue->buffers[i], queue->bufferSize);
	RF_Free(queue->buffers, queue->totalBuffers * sizeof(caddr_t));
	RF_UNLOCK_MUTEX(queue->mutex);
	rf_mutex_destroy(&queue->mutex);
}


void
rf_ShutdownParityLoggingRegionInfo(RF_ThreadArg_t arg)
{
	RF_Raid_t *raidPtr;
	RF_RegionId_t i;

	raidPtr = (RF_Raid_t *) arg;
	if (rf_parityLogDebug) {
		printf("raid%d: ShutdownParityLoggingRegionInfo\n",
		       raidPtr->raidid);
	}
	/* Free region information structs. */
	for (i = 0; i < rf_numParityRegions; i++)
		rf_FreeRegionInfo(raidPtr, i);
	RF_Free(raidPtr->regionInfo, (rf_numParityRegions *
				      sizeof(raidPtr->regionInfo)));
	raidPtr->regionInfo = NULL;
}


void
rf_ShutdownParityLoggingPool(RF_ThreadArg_t arg)
{
	RF_Raid_t *raidPtr;

	raidPtr = (RF_Raid_t *) arg;
	if (rf_parityLogDebug) {
		printf("raid%d: ShutdownParityLoggingPool\n", raidPtr->raidid);
	}
	/* Free contents of parityLogPool. */
	rf_FreeParityLogQueue(raidPtr, &raidPtr->parityLogPool);
	RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs *
		raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
}


void
rf_ShutdownParityLoggingRegionBufferPool(RF_ThreadArg_t arg)
{
	RF_Raid_t *raidPtr;

	raidPtr = (RF_Raid_t *) arg;
	if (rf_parityLogDebug) {
		printf("raid%d: ShutdownParityLoggingRegionBufferPool\n",
		       raidPtr->raidid);
	}
	rf_FreeRegionBufferQueue(&raidPtr->regionBufferPool);
}


void
rf_ShutdownParityLoggingParityBufferPool(RF_ThreadArg_t arg)
{
	RF_Raid_t *raidPtr;

	raidPtr = (RF_Raid_t *) arg;
	if (rf_parityLogDebug) {
		printf("raid%d: ShutdownParityLoggingParityBufferPool\n",
		       raidPtr->raidid);
	}
	rf_FreeRegionBufferQueue(&raidPtr->parityBufferPool);
}


void
rf_ShutdownParityLoggingDiskQueue(RF_ThreadArg_t arg)
{
	RF_ParityLogData_t *d;
	RF_CommonLogData_t *c;
	RF_Raid_t *raidPtr;

	raidPtr = (RF_Raid_t *) arg;
	if (rf_parityLogDebug) {
		printf("raid%d: ShutdownParityLoggingDiskQueue\n",
		       raidPtr->raidid);
	}
	/* Free disk manager stuff. */
	RF_ASSERT(raidPtr->parityLogDiskQueue.bufHead == NULL);
	RF_ASSERT(raidPtr->parityLogDiskQueue.bufTail == NULL);
	RF_ASSERT(raidPtr->parityLogDiskQueue.reintHead == NULL);
	RF_ASSERT(raidPtr->parityLogDiskQueue.reintTail == NULL);
	while (raidPtr->parityLogDiskQueue.freeDataList) {
		d = raidPtr->parityLogDiskQueue.freeDataList;
		raidPtr->parityLogDiskQueue.freeDataList =
		    raidPtr->parityLogDiskQueue.freeDataList->next;
		RF_Free(d, sizeof(RF_ParityLogData_t));
	}
	while (raidPtr->parityLogDiskQueue.freeCommonList) {
		c = raidPtr->parityLogDiskQueue.freeCommonList;
		rf_mutex_destroy(&c->mutex);
		raidPtr->parityLogDiskQueue.freeCommonList =
		    raidPtr->parityLogDiskQueue.freeCommonList->next;
		RF_Free(c, sizeof(RF_CommonLogData_t));
	}
}


void
rf_ShutdownParityLogging(RF_ThreadArg_t arg)
{
	RF_Raid_t *raidPtr;

	raidPtr = (RF_Raid_t *) arg;
	if (rf_parityLogDebug) {
		printf("raid%d: ShutdownParityLogging\n", raidPtr->raidid);
	}
	/* Shutdown disk thread. */
	/*
	 * This has the desirable side-effect of forcing all regions to be
	 * reintegrated. This is necessary since all parity log maps are
	 * currently held in volatile memory.
	 */

	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	raidPtr->parityLogDiskQueue.threadState |= RF_PLOG_TERMINATE;
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	RF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);
	/*
	 * pLogDiskThread will now terminate when queues are cleared.
	 * Now wait for it to be done.
	 */
	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	while (!(raidPtr->parityLogDiskQueue.threadState & RF_PLOG_SHUTDOWN)) {
		RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond,
			     raidPtr->parityLogDiskQueue.mutex);
	}
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	if (rf_parityLogDebug) {
		printf("raid%d: ShutdownParityLogging done"
		       " (thread completed)\n", raidPtr->raidid);
	}
}


int
rf_GetDefaultNumFloatingReconBuffersParityLogging(RF_Raid_t *raidPtr)
{
	return (20);
}


RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitParityLogging(RF_Raid_t *raidPtr)
{
	return (10);
}


/* Return the region ID for a given RAID address. */
RF_RegionId_t
rf_MapRegionIDParityLogging(RF_Raid_t *raidPtr, RF_SectorNum_t address)
{
	RF_RegionId_t regionID;

	/* regionID = address / (raidPtr->regionParityRange *
	 *     raidPtr->Layout.numDataCol); */
	regionID = address / raidPtr->regionParityRange;
	if (regionID == rf_numParityRegions) {
		/* Last region may be larger than other regions. */
		regionID--;
	}
	RF_ASSERT(address >= raidPtr->regionInfo[regionID].parityStartAddr);
	RF_ASSERT(address < raidPtr->regionInfo[regionID].parityStartAddr +
		  raidPtr->regionInfo[regionID].numSectorsParity);
	RF_ASSERT(regionID < rf_numParityRegions);
	return (regionID);
}


/* Given a logical RAID sector, determine physical disk address of data. */
void
rf_MapSectorParityLogging(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
{
	RF_StripeNum_t SUID = raidSector /
		raidPtr->Layout.sectorsPerStripeUnit;
	*row = 0;
	/* *col = (SUID % (raidPtr->numCol -
	 *     raidPtr->Layout.numParityLogCol)); */
	*col = SUID % raidPtr->Layout.numDataCol;
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
	    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
}


/* Given a logical RAID sector, determine physical disk address of parity. */
void
rf_MapParityParityLogging(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
{
	RF_StripeNum_t SUID = raidSector /
	    raidPtr->Layout.sectorsPerStripeUnit;

	*row = 0;
	/* *col =
	 *     raidPtr->Layout.numDataCol-(SUID / raidPtr->Layout.numDataCol) %
	 *      (raidPtr->numCol - raidPtr->Layout.numParityLogCol); */
	*col = raidPtr->Layout.numDataCol;
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
	    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
}


/*
 * Given a regionID and sector offset, determine the physical disk address
 * of the parity log.
 */
void
rf_MapLogParityLogging(RF_Raid_t *raidPtr, RF_RegionId_t regionID,
    RF_SectorNum_t regionOffset, RF_RowCol_t *row, RF_RowCol_t *col,
    RF_SectorNum_t *startSector)
{
	*row = 0;
	*col = raidPtr->numCol - 1;
	*startSector =
	    raidPtr->regionInfo[regionID].regionStartAddr + regionOffset;
}


/*
 * Given a regionID, determine the physical disk address of the logged
 * parity for that region.
 */
void
rf_MapRegionParity(RF_Raid_t *raidPtr, RF_RegionId_t regionID,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *startSector,
    RF_SectorCount_t *numSector)
{
	*row = 0;
	*col = raidPtr->numCol - 2;
	*startSector = raidPtr->regionInfo[regionID].parityStartAddr;
	*numSector = raidPtr->regionInfo[regionID].numSectorsParity;
}


/*
 * Given a logical RAID address, determine the participating disks in
 * the stripe.
 */
void
rf_IdentifyStripeParityLogging(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
{
	RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout,
							   addr);
	RF_ParityLoggingConfigInfo_t *info = (RF_ParityLoggingConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
	*outRow = 0;
	*diskids = info->stripeIdentifier[stripeID % raidPtr->numCol];
}


void
rf_MapSIDToPSIDParityLogging(RF_RaidLayout_t *layoutPtr,
    RF_StripeNum_t stripeID, RF_StripeNum_t *psID, RF_ReconUnitNum_t *which_ru)
{
	*which_ru = 0;
	*psID = stripeID;
}


/*
 * Select an algorithm for performing an access. Returns two pointers,
 * one to a function that will return information about the DAG, and
 * another to a function that will create the dag.
 */
void
rf_ParityLoggingDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmp, RF_VoidFuncPtr *createFunc)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	RF_PhysDiskAddr_t *failedPDA = NULL;
	RF_RowCol_t frow, fcol;
	RF_RowStatus_t rstat;
	int prior_recon;

	RF_ASSERT(RF_IO_IS_R_OR_W(type));

	if (asmp->numDataFailed + asmp->numParityFailed > 1) {
		RF_ERRORMSG("Multiple disks failed in a single group !"
			    "  Aborting I/O operation.\n");
		 /* *infoFunc = */ *createFunc = NULL;
		return;
	} else
		if (asmp->numDataFailed + asmp->numParityFailed == 1) {

			/*
			 * If under recon & already reconstructed, redirect
			 * the access to the spare drive and eliminate the
			 * failure indication.
			 */
			failedPDA = asmp->failedPDAs[0];
			frow = failedPDA->row;
			fcol = failedPDA->col;
			rstat = raidPtr->status[failedPDA->row];
			prior_recon = (rstat == rf_rs_reconfigured) ||
			    ((rstat == rf_rs_reconstructing) ?
			     rf_CheckRUReconstructed(raidPtr->reconControl[frow]
			      ->reconMap, failedPDA->startSector) : 0);
			if (prior_recon) {
				RF_RowCol_t or = failedPDA->row;
				RF_RowCol_t oc = failedPDA->col;
				RF_SectorNum_t oo = failedPDA->startSector;
				if (layoutPtr->map->flags &
				    RF_DISTRIBUTE_SPARE) {
					/* Redirect to dist spare space. */

					if (failedPDA == asmp->parityInfo) {

						/* Parity has failed. */
						(layoutPtr->map->MapParity)
						    (raidPtr,
						     failedPDA->raidAddress,
						     &failedPDA->row,
						     &failedPDA->col,
						     &failedPDA->startSector,
						     RF_REMAP);

						if (asmp->parityInfo->next) {
							/*
							 * Redir 2nd component,
							 * if any.
							 */
							RF_PhysDiskAddr_t *p =
							 asmp->parityInfo->next;
							RF_SectorNum_t SUoffs =
							    p->startSector %
						layoutPtr->sectorsPerStripeUnit;
							p->row = failedPDA->row;
							p->col = failedPDA->col;
							/*
							 * Cheating:
							 * startSector is not
							 * really a RAID
							 * address.
							 */
							p->startSector =
			    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
				failedPDA->startSector) + SUoffs;
						}
					} else
						if (asmp->parityInfo->next &&
						    failedPDA ==
						    asmp->parityInfo->next) {
							/*
							 * Should not ever
							 * happen.
							 */
							RF_ASSERT(0);
						} else {
							/* Data has failed. */
							(layoutPtr->map
							 ->MapSector)
							    (raidPtr,
							 failedPDA->raidAddress,
							    &failedPDA->row,
							    &failedPDA->col,
							&failedPDA->startSector,
							    RF_REMAP);
						}

				} else {
					/* Redirect to dedicated spare space. */

					failedPDA->row =
					    raidPtr->Disks[frow][fcol].spareRow;
					failedPDA->col =
					    raidPtr->Disks[frow][fcol].spareCol;

					/*
					 * The parity may have two distinct
					 * components, both of which may need
					 * to be redirected.
					 */
					if (asmp->parityInfo->next) {
						if (failedPDA ==
						    asmp->parityInfo) {
							failedPDA->next->row =
							    failedPDA->row;
							failedPDA->next->col =
							    failedPDA->col;
						} else {
							if (failedPDA ==
							    asmp->parityInfo
							     ->next) {
								/*
								 * Paranoid:
								 * Should never
								 * occur.
								 */
								asmp->parityInfo
								->row =
								 failedPDA->row;
								asmp->parityInfo
								->col =
								 failedPDA->col;
							}
						}
					}
				}

				RF_ASSERT(failedPDA->col != -1);

				if (rf_dagDebug || rf_mapDebug) {
					printf("raid%d: Redirected type '%c'"
					       " r %d c %d o %ld -> r %d c %d"
					       " o %ld\n", raidPtr->raidid,
					       type, or, oc, (long) oo,
					       failedPDA->row, failedPDA->col,
					       (long) failedPDA->startSector);
				}
				asmp->numDataFailed = asmp->numParityFailed = 0;
			}
		}
	if (type == RF_IO_TYPE_READ) {

		if (asmp->numDataFailed == 0)
			*createFunc =
			    (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;
		else
			*createFunc =
			    (RF_VoidFuncPtr) rf_CreateRaidFiveDegradedReadDAG;

	} else {


		/*
		 * If mirroring, always use large writes. If the access
		 * requires two distinct parity updates, always do a small
		 * write. If the stripe contains a failure but the access
		 * does not, do a small write. The first conditional
		 * (numStripeUnitsAccessed <= numDataCol/2) uses a
		 * less-than-or-equal rather than just a less-than because
		 * when G is 3 or 4, numDataCol/2 is 1, and I want
		 * single-stripe-unit updates to use just one disk.
		 */
		if ((asmp->numDataFailed + asmp->numParityFailed) == 0) {
			if (((asmp->numStripeUnitsAccessed <=
			      (layoutPtr->numDataCol / 2)) &&
			     (layoutPtr->numDataCol != 1)) ||
			    (asmp->parityInfo->next != NULL) ||
			    rf_CheckStripeForFailures(raidPtr, asmp)) {
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateParityLoggingSmallWriteDAG;
			} else
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateParityLoggingLargeWriteDAG;
		} else
			if (asmp->numParityFailed == 1)
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateNonRedundantWriteDAG;
			else
				if (asmp->numStripeUnitsAccessed != 1 &&
				    failedPDA->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					*createFunc = NULL;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_CreateDegradedWriteDAG;
	}
}
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.6
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_paritylogging.c,v 1.5 2000/08/08 16:07:44 peter Exp $	*/
@


1.5
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_paritylogging.c,v 1.4 2000/01/11 18:02:22 peter Exp $	*/
d3 1
d33 1
a33 1
  parity logging configuration, dag selection, and mapping is implemented here
d38 1
a38 1
#if RF_INCLUDE_PARITYLOGGING > 0
d59 20
a78 17
	RF_RowCol_t **stripeIdentifier;	/* filled in at config time & used by
					 * IdentifyStripe */
}       RF_ParityLoggingConfigInfo_t;

static void FreeRegionInfo(RF_Raid_t * raidPtr, RF_RegionId_t regionID);
static void rf_ShutdownParityLogging(RF_ThreadArg_t arg);
static void rf_ShutdownParityLoggingRegionInfo(RF_ThreadArg_t arg);
static void rf_ShutdownParityLoggingPool(RF_ThreadArg_t arg);
static void rf_ShutdownParityLoggingRegionBufferPool(RF_ThreadArg_t arg);
static void rf_ShutdownParityLoggingParityBufferPool(RF_ThreadArg_t arg);
static void rf_ShutdownParityLoggingDiskQueue(RF_ThreadArg_t arg);

int 
rf_ConfigureParityLogging(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d80 1
a80 1
	int     i, j, startdisk, rc;
d92 5
a96 5
         * We create multiple entries on the shutdown list here, since
         * this configuration routine is fairly complicated in and of
         * itself, and this makes backing out of a failed configuration
         * much simpler.
         */
d100 3
a102 3
	/* create a parity logging configuration structure */
	RF_MallocAndAdd(info, sizeof(RF_ParityLoggingConfigInfo_t), 
			(RF_ParityLoggingConfigInfo_t *), 
d110 6
a115 4
	/* the stripe identifier must identify the disks in each stripe, IN
	 * THE ORDER THAT THEY APPEAR IN THE STRIPE. */
	info->stripeIdentifier = rf_make_2d_array((raidPtr->numCol), 
						  (raidPtr->numCol), 
d123 2
a124 2
			info->stripeIdentifier[i][j] = (startdisk + j) % 
				(raidPtr->numCol - 1);
d130 1
a130 1
	/* fill in the remaining layout parameters */
d132 2
a133 2
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << 
		raidPtr->logBytesPerSector;
d136 4
a139 4
	layoutPtr->numDataCol = raidPtr->numCol - layoutPtr->numParityCol - 
		layoutPtr->numParityLogCol;
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * 
		layoutPtr->sectorsPerStripeUnit;
d141 2
a142 2
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * 
		layoutPtr->sectorsPerStripeUnit;
d144 2
a145 2
	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * 
		layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d147 21
a167 20
	/* configure parity log parameters
	 * 
	 * parameter               comment/constraints 
	 * ------------------------------------------- 
	 * numParityRegions*       all regions (except possibly last) 
	 *                         of equal size 
	 * totalInCoreLogCapacity* amount of memory in bytes available 
	 *                         for in-core logs (default 1 MB) 
	 * numSectorsPerLog#       capacity of an in-core log in sectors 
	 *                         (1 * disk track)
	 * numParityLogs           total number of in-core logs,
	 *                         should be at least numParityRegions 
	 * regionLogCapacity       size of a region log (except possibly 
	 *                         last one) in sectors 
	 * totalLogCapacity        total amount of log space in sectors
	 * 
	 * where '*' denotes a user settable parameter. 
	 * Note that logs are fixed to be the size of a disk track, 
	 * value #defined in rf_paritylog.h
	 * 
d170 2
a171 1
	totalLogCapacity = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit * layoutPtr->numParityLogCol;
d176 2
a177 1
	/* reduce fragmentation within a disk region by adjusting the number
d179 2
a180 1
	 * into a disk region */
d184 1
a184 1
			if (((totalLogCapacity / (rf_numParityRegions + i)) % 
d188 3
a190 3
					rf_numParityRegions;
				fragmentation = raidPtr->regionLogCapacity % 
					raidPtr->numSectorsPerLog;
d192 1
a192 1
			if (((totalLogCapacity / (rf_numParityRegions - i)) % 
d196 3
a198 3
					rf_numParityRegions;
				fragmentation = raidPtr->regionLogCapacity % 
					raidPtr->numSectorsPerLog;
d201 10
a210 9
	/* ensure integral number of regions per log */
	raidPtr->regionLogCapacity = (raidPtr->regionLogCapacity / 
				      raidPtr->numSectorsPerLog) * 
		raidPtr->numSectorsPerLog;

	raidPtr->numParityLogs = rf_totalInCoreLogCapacity / 
		(raidPtr->bytesPerSector * raidPtr->numSectorsPerLog);
	/* to avoid deadlock, must ensure that enough logs exist for each
	 * region to have one simultaneously */
d214 1
a214 1
	/* create region information structs */
d217 2
a218 2
	RF_Malloc(raidPtr->regionInfo, 
		  (rf_numParityRegions * sizeof(RF_RegionInfo_t)), 
d223 1
a223 1
	/* last region may not be full capacity */
d225 1
a225 1
	while ((rf_numParityRegions - 1) * raidPtr->regionLogCapacity + 
d227 2
a228 2
		lastRegionCapacity = lastRegionCapacity - 
			raidPtr->numSectorsPerLog;
d230 2
a231 2
	raidPtr->regionParityRange = raidPtr->sectorsPerDisk / 
		rf_numParityRegions;
d234 3
a236 3
/* i can't remember why this line is in the code -wvcii 6/30/95 */
/*  if (raidPtr->sectorsPerDisk % rf_numParityRegions > 0)
    regionParityRange++; */
d238 1
a238 1
	/* build pool of unused parity logs */
d240 1
a240 1
	       raidPtr->numParityLogs * raidPtr->numSectorsPerLog * 
d243 2
a244 2
	RF_Malloc(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * 
		  raidPtr->numSectorsPerLog * raidPtr->bytesPerSector, 
d251 1
a251 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", 
d253 1
a253 1
		RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * 
d259 1
a259 1
			RF_Calloc(raidPtr->parityLogPool.parityLogs, 1, 
d262 3
a264 3
				RF_Free(raidPtr->parityLogBufferHeap, 
					raidPtr->numParityLogs * 
					raidPtr->numSectorsPerLog * 
d270 1
a270 1
			RF_Calloc(l->next, 1, sizeof(RF_ParityLog_t), 
d273 3
a275 3
				RF_Free(raidPtr->parityLogBufferHeap, 
					raidPtr->numParityLogs * 
					raidPtr->numSectorsPerLog * 
d277 1
a277 1
				for (l = raidPtr->parityLogPool.parityLogs; 
d282 3
a284 1
						RF_Free(l->records, (raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t)));
d292 4
a295 4
		lHeapPtr += raidPtr->numSectorsPerLog * 
			raidPtr->bytesPerSector;
		RF_Malloc(l->records, (raidPtr->numSectorsPerLog * 
				       sizeof(RF_ParityLogRecord_t)), 
d298 3
a300 3
			RF_Free(raidPtr->parityLogBufferHeap, 
				raidPtr->numParityLogs * 
				raidPtr->numSectorsPerLog * 
d302 2
a303 2
			for (l = raidPtr->parityLogPool.parityLogs; 
			     l; 
d307 2
a308 2
					RF_Free(l->records, 
						(raidPtr->numSectorsPerLog * 
d317 2
a318 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d322 1
a322 1
	/* build pool of region buffers */
d325 1
a325 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", 
d331 1
a331 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", 
d336 3
a338 3
	raidPtr->regionBufferPool.bufferSize = raidPtr->regionLogCapacity * 
		raidPtr->bytesPerSector;
	printf("regionBufferPool.bufferSize %d\n", 
d341 2
a342 2
	/* for now, only one region at a time may be reintegrated */
	raidPtr->regionBufferPool.totalBuffers = 1;	
d344 2
a345 2
	raidPtr->regionBufferPool.availableBuffers = 
		raidPtr->regionBufferPool.totalBuffers;
d349 1
a349 1
	       (int) (raidPtr->regionBufferPool.totalBuffers * 
d351 2
a352 2
	RF_Malloc(raidPtr->regionBufferPool.buffers, 
		  raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t), 
d361 1
a361 1
		       (int) (raidPtr->regionBufferPool.bufferSize * 
d363 1
a363 1
		RF_Malloc(raidPtr->regionBufferPool.buffers[i], 
d370 1
a370 1
				RF_Free(raidPtr->regionBufferPool.buffers[i], 
d374 2
a375 2
			RF_Free(raidPtr->regionBufferPool.buffers, 
				raidPtr->regionBufferPool.totalBuffers * 
d382 1
a382 1
	rc = rf_ShutdownCreate(listp, 
d386 2
a387 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d391 1
a391 1
	/* build pool of parity buffers */
d395 1
a395 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", 
d401 1
a401 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", 
d406 3
a408 3
	raidPtr->parityBufferPool.bufferSize = parityBufferCapacity * 
		raidPtr->bytesPerSector;
	printf("parityBufferPool.bufferSize %d\n", 
d411 2
a412 2
	/* for now, only one region at a time may be reintegrated */
	raidPtr->parityBufferPool.totalBuffers = 1;	
d414 2
a415 2
	raidPtr->parityBufferPool.availableBuffers = 
		raidPtr->parityBufferPool.totalBuffers;
d419 1
a419 1
	       (int) (raidPtr->parityBufferPool.totalBuffers * 
d421 3
a423 3
	       raidPtr->parityBufferPool.totalBuffers );
	RF_Malloc(raidPtr->parityBufferPool.buffers, 
		  raidPtr->parityBufferPool.totalBuffers * sizeof(caddr_t), 
d432 3
a434 3
		       (int) (raidPtr->parityBufferPool.bufferSize * 
			      sizeof(char)),i);
		RF_Malloc(raidPtr->parityBufferPool.buffers[i], 
d441 2
a442 2
				RF_Free(raidPtr->parityBufferPool.buffers[i], 
					raidPtr->regionBufferPool.bufferSize * 
d445 2
a446 2
			RF_Free(raidPtr->parityBufferPool.buffers, 
				raidPtr->regionBufferPool.totalBuffers * 
d453 2
a454 2
	rc = rf_ShutdownCreate(listp, 
			       rf_ShutdownParityLoggingParityBufferPool, 
d457 2
a458 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d462 2
a463 2
	/* initialize parityLogDiskQueue */
	rc = rf_create_managed_mutex(listp, 
d466 1
a466 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", 
d472 1
a472 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", 
d489 2
a490 2
	rc = rf_ShutdownCreate(listp, 
			       rf_ShutdownParityLoggingDiskQueue, 
d493 2
a494 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d500 2
a501 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
			    __LINE__, rc);
d503 3
a505 3
				FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo, 
				(rf_numParityRegions * 
d511 2
a512 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
			    __LINE__, rc);
d515 3
a517 3
				FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo, 
				(rf_numParityRegions * 
d522 4
a525 4
		raidPtr->regionInfo[i].regionStartAddr = 
			raidPtr->regionLogCapacity * i;
		raidPtr->regionInfo[i].parityStartAddr = 
			raidPtr->regionParityRange * i;
d527 4
a530 4
			raidPtr->regionInfo[i].capacity = 
				raidPtr->regionLogCapacity;
			raidPtr->regionInfo[i].numSectorsParity = 
				raidPtr->regionParityRange;
d532 5
a536 6
			raidPtr->regionInfo[i].capacity = 
				lastRegionCapacity;
			raidPtr->regionInfo[i].numSectorsParity = 
				raidPtr->sectorsPerDisk - 
				raidPtr->regionParityRange * i;
			if (raidPtr->regionInfo[i].numSectorsParity > 
d538 2
a539 2
				maxRegionParityRange = 
					raidPtr->regionInfo[i].numSectorsParity;
d542 2
a543 2
		RF_ASSERT(raidPtr->regionInfo[i].capacity + 
			  raidPtr->regionInfo[i].regionStartAddr <= 
d545 2
a546 2
		RF_ASSERT(raidPtr->regionInfo[i].parityStartAddr + 
			  raidPtr->regionInfo[i].numSectorsParity <= 
d551 1
a551 1
		RF_Malloc(raidPtr->regionInfo[i].diskMap, 
d553 1
a553 1
			   sizeof(RF_DiskMap_t)), 
d559 3
a561 3
				FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo, 
				(rf_numParityRegions * 
d569 1
a569 1
			       rf_ShutdownParityLoggingRegionInfo, 
d572 2
a573 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d579 2
a580 2
	rc = RF_CREATE_THREAD(raidPtr->pLogDiskThreadHandle, 
			      rf_ParityLoggingDiskManager, raidPtr,"rf_log");
d583 3
a585 2
		RF_ERRORMSG3("Unable to create parity logging disk thread file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d588 1
a588 1
	/* wait for thread to start */
d591 1
a591 1
		RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, 
d598 2
a599 1
		RF_ERRORMSG1("Got rc=%d adding parity logging shutdown event\n", rc);
d604 14
a617 8
		printf("                            size of disk log in sectors: %d\n",
		    (int) totalLogCapacity);
		printf("                            total number of parity regions is %d\n", (int) rf_numParityRegions);
		printf("                            nominal sectors of log per parity region is %d\n", (int) raidPtr->regionLogCapacity);
		printf("                            nominal region fragmentation is %d sectors\n", (int) fragmentation);
		printf("                            total number of parity logs is %d\n", raidPtr->numParityLogs);
		printf("                            parity log size is %d sectors\n", raidPtr->numSectorsPerLog);
		printf("                            total in-core log space is %d bytes\n", (int) rf_totalInCoreLogCapacity);
d624 3
a626 4
static void 
FreeRegionInfo(
    RF_Raid_t * raidPtr,
    RF_RegionId_t regionID)
d629 2
a630 2
	RF_Free(raidPtr->regionInfo[regionID].diskMap, 
		(raidPtr->regionInfo[regionID].capacity * 
d633 1
a633 1
		rf_ReleaseParityLogs(raidPtr, 
d646 2
a647 4
static void 
FreeParityLogQueue(
    RF_Raid_t * raidPtr,
    RF_ParityLogQueue_t * queue)
d656 1
a656 1
		RF_Free(l2->records, (raidPtr->numSectorsPerLog * 
d665 2
a666 2
static void 
FreeRegionBufferQueue(RF_RegionBufferQueue_t * queue)
d668 1
a668 1
	int     i;
d672 1
a672 1
		printf("Attempt to free region queue which is still in use!\n");
d682 2
a683 1
static void 
d691 1
a691 1
		printf("raid%d: ShutdownParityLoggingRegionInfo\n", 
d694 1
a694 1
	/* free region information structs */
d696 2
a697 2
		FreeRegionInfo(raidPtr, i);
	RF_Free(raidPtr->regionInfo, (rf_numParityRegions * 
d702 2
a703 1
static void 
d712 3
a714 3
	/* free contents of parityLogPool */
	FreeParityLogQueue(raidPtr, &raidPtr->parityLogPool);
	RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * 
d718 2
a719 1
static void 
d726 1
a726 1
		printf("raid%d: ShutdownParityLoggingRegionBufferPool\n", 
d729 1
a729 1
	FreeRegionBufferQueue(&raidPtr->regionBufferPool);
d732 2
a733 1
static void 
d743 1
a743 1
	FreeRegionBufferQueue(&raidPtr->parityBufferPool);
d746 2
a747 1
static void 
d759 1
a759 1
	/* free disk manager stuff */
d766 2
a767 2
		raidPtr->parityLogDiskQueue.freeDataList = 
			raidPtr->parityLogDiskQueue.freeDataList->next;
d773 2
a774 2
		raidPtr->parityLogDiskQueue.freeCommonList = 
			raidPtr->parityLogDiskQueue.freeCommonList->next;
d779 2
a780 1
static void 
d789 6
a794 4
	/* shutdown disk thread */
	/* This has the desirable side-effect of forcing all regions to be
	 * reintegrated.  This is necessary since all parity log maps are
	 * currently held in volatile memory. */
d801 3
a803 3
         * pLogDiskThread will now terminate when queues are cleared
         * now wait for it to be done
         */
d806 1
a806 1
		RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, 
d811 2
a812 1
		printf("raid%d: ShutdownParityLogging done (thread completed)\n", raidPtr->raidid);
d816 3
a818 2
int 
rf_GetDefaultNumFloatingReconBuffersParityLogging(RF_Raid_t * raidPtr)
d823 3
a825 2
RF_HeadSepLimit_t 
rf_GetDefaultHeadSepLimitParityLogging(RF_Raid_t * raidPtr)
d829 5
a833 5
/* return the region ID for a given RAID address */
RF_RegionId_t 
rf_MapRegionIDParityLogging(
    RF_Raid_t * raidPtr,
    RF_SectorNum_t address)
d837 2
a838 1
/*  regionID = address / (raidPtr->regionParityRange * raidPtr->Layout.numDataCol); */
d841 1
a841 1
		/* last region may be larger than other regions */
d845 1
a845 1
	RF_ASSERT(address < raidPtr->regionInfo[regionID].parityStartAddr + 
d852 4
a855 9
/* given a logical RAID sector, determine physical disk address of data */
void 
rf_MapSectorParityLogging(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d857 1
a857 1
	RF_StripeNum_t SUID = raidSector / 
d861 1
a861 1
	 * raidPtr->Layout.numParityLogCol)); */
d863 2
a864 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * 
		raidPtr->Layout.sectorsPerStripeUnit +
d869 4
a872 9
/* given a logical RAID sector, determine physical disk address of parity  */
void 
rf_MapParityParityLogging(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d874 2
a875 2
	RF_StripeNum_t SUID = raidSector / 
		raidPtr->Layout.sectorsPerStripeUnit;
d879 2
a880 2
	 * raidPtr->Layout.numDataCol-(SUID/raidPtr->Layout.numDataCol)%(raidPt
	 * r->numCol - raidPtr->Layout.numParityLogCol); */
d882 2
a883 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * 
		raidPtr->Layout.sectorsPerStripeUnit +
d888 8
a895 9
/* given a regionID and sector offset, determine the physical disk address of the parity log */
void 
rf_MapLogParityLogging(
    RF_Raid_t * raidPtr,
    RF_RegionId_t regionID,
    RF_SectorNum_t regionOffset,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * startSector)
d899 2
a900 1
	*startSector = raidPtr->regionInfo[regionID].regionStartAddr + regionOffset;
d904 8
a911 10
/* given a regionID, determine the physical disk address of the logged
   parity for that region */
void 
rf_MapRegionParity(
    RF_Raid_t * raidPtr,
    RF_RegionId_t regionID,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * startSector,
    RF_SectorCount_t * numSector)
d920 7
a926 8
/* given a logical RAID address, determine the participating disks in
   the stripe */
void 
rf_IdentifyStripeParityLogging(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t addr,
    RF_RowCol_t ** diskids,
    RF_RowCol_t * outRow)
d928 1
a928 1
	RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, 
d930 2
a931 2
	RF_ParityLoggingConfigInfo_t *info = (RF_ParityLoggingConfigInfo_t *) 
		raidPtr->Layout.layoutSpecificInfo;
d937 3
a939 6
void 
rf_MapSIDToPSIDParityLogging(
    RF_RaidLayout_t * layoutPtr,
    RF_StripeNum_t stripeID,
    RF_StripeNum_t * psID,
    RF_ReconUnitNum_t * which_ru)
d946 2
a947 1
/* select an algorithm for performing an access.  Returns two pointers,
d951 3
a953 6
void 
rf_ParityLoggingDagSelect(
    RF_Raid_t * raidPtr,
    RF_IoType_t type,
    RF_AccessStripeMap_t * asmp,
    RF_VoidFuncPtr * createFunc)
d959 1
a959 1
	int     prior_recon;
d964 2
a965 1
		RF_ERRORMSG("Multiple disks failed in a single group!  Aborting I/O operation.\n");
d971 2
a972 1
			/* if under recon & already reconstructed, redirect
d974 2
a975 1
			 * failure indication */
d980 4
a983 4
			prior_recon = (rstat == rf_rs_reconfigured) || (
			    (rstat == rf_rs_reconstructing) ?
			    rf_CheckRUReconstructed(raidPtr->reconControl[frow]->reconMap, failedPDA->startSector) : 0
			    );
d985 2
a986 1
				RF_RowCol_t or = failedPDA->row, oc = failedPDA->col;
d988 3
a990 3
				if (layoutPtr->map->flags & 
				    RF_DISTRIBUTE_SPARE) {	
					/* redirect to dist spare space */
d994 19
a1012 8
						/* parity has failed */
						(layoutPtr->map->MapParity) (raidPtr, failedPDA->raidAddress, &failedPDA->row,
						    &failedPDA->col, &failedPDA->startSector, RF_REMAP);

						if (asmp->parityInfo->next) {	/* redir 2nd component,
										 * if any */
							RF_PhysDiskAddr_t *p = asmp->parityInfo->next;
							RF_SectorNum_t SUoffs = p->startSector % layoutPtr->sectorsPerStripeUnit;
d1015 9
a1023 4
							p->startSector = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->startSector) +
							    SUoffs;	/* cheating:
									 * startSector is not
									 * really a RAID address */
d1026 8
a1033 3
						if (asmp->parityInfo->next && failedPDA == asmp->parityInfo->next) {
							RF_ASSERT(0);	/* should not ever
									 * happen */
d1035 9
a1043 5

							/* data has failed */
							(layoutPtr->map->MapSector) (raidPtr, failedPDA->raidAddress, &failedPDA->row,
							    &failedPDA->col, &failedPDA->startSector, RF_REMAP);

d1046 2
a1047 2
				} else {	
					/* redirect to dedicated spare space */
d1049 4
a1052 2
					failedPDA->row = raidPtr->Disks[frow][fcol].spareRow;
					failedPDA->col = raidPtr->Disks[frow][fcol].spareCol;
d1054 2
a1055 1
					/* the parity may have two distinct
d1057 2
a1058 1
					 * to be redirected */
d1060 21
a1080 7
						if (failedPDA == asmp->parityInfo) {
							failedPDA->next->row = failedPDA->row;
							failedPDA->next->col = failedPDA->col;
						} else
							if (failedPDA == asmp->parityInfo->next) {	/* paranoid:  should never occur */
								asmp->parityInfo->row = failedPDA->row;
								asmp->parityInfo->col = failedPDA->col;
d1082 1
d1089 6
a1094 2
					printf("raid%d: Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\n",
					    raidPtr->raidid, type, or, oc, (long) oo, failedPDA->row, failedPDA->col, (long) failedPDA->startSector);
d1102 2
a1103 1
			*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;
d1105 2
a1106 1
			*createFunc = (RF_VoidFuncPtr) rf_CreateRaidFiveDegradedReadDAG;
d1111 2
a1112 1
		/* if mirroring, always use large writes.  If the access
d1114 1
a1114 1
		 * write.  If the stripe contains a failure but the access
d1119 2
a1120 1
		 * single-stripe-unit updates to use just one disk. */
d1122 2
a1123 2
			if (((asmp->numStripeUnitsAccessed <= 
			      (layoutPtr->numDataCol / 2)) && 
d1125 1
a1125 1
			    (asmp->parityInfo->next != NULL) || 
d1127 2
a1128 1
				*createFunc = (RF_VoidFuncPtr) rf_CreateParityLoggingSmallWriteDAG;
d1130 2
a1131 1
				*createFunc = (RF_VoidFuncPtr) rf_CreateParityLoggingLargeWriteDAG;
d1134 2
a1135 1
				*createFunc = (RF_VoidFuncPtr) rf_CreateNonRedundantWriteDAG;
d1137 3
a1139 1
				if (asmp->numStripeUnitsAccessed != 1 && failedPDA->numSector != layoutPtr->sectorsPerStripeUnit)
d1142 2
a1143 1
					*createFunc = (RF_VoidFuncPtr) rf_CreateDegradedWriteDAG;
d1146 1
a1146 1
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.5.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d32 1
a32 1
 * Parity logging configuration, dag selection, and mapping is implemented here.
d37 1
a37 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d58 17
a74 20
	RF_RowCol_t **stripeIdentifier;	/*
					 * Filled in at config time & used by
					 * IdentifyStripe.
					 */
} RF_ParityLoggingConfigInfo_t;

void rf_FreeRegionInfo(RF_Raid_t *, RF_RegionId_t);
void rf_FreeParityLogQueue(RF_Raid_t *, RF_ParityLogQueue_t *);
void rf_FreeRegionBufferQueue(RF_RegionBufferQueue_t *);
void rf_ShutdownParityLogging(RF_ThreadArg_t);
void rf_ShutdownParityLoggingRegionInfo(RF_ThreadArg_t);
void rf_ShutdownParityLoggingPool(RF_ThreadArg_t);
void rf_ShutdownParityLoggingRegionBufferPool(RF_ThreadArg_t);
void rf_ShutdownParityLoggingParityBufferPool(RF_ThreadArg_t);
void rf_ShutdownParityLoggingDiskQueue(RF_ThreadArg_t);


int
rf_ConfigureParityLogging(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d76 1
a76 1
	int i, j, startdisk, rc;
d88 5
a92 5
	 * We create multiple entries on the shutdown list here, since
	 * this configuration routine is fairly complicated in and of
	 * itself, and this makes backing out of a failed configuration
	 * much simpler.
	 */
d96 3
a98 3
	/* Create a parity logging configuration structure. */
	RF_MallocAndAdd(info, sizeof(RF_ParityLoggingConfigInfo_t),
			(RF_ParityLoggingConfigInfo_t *),
d106 4
a109 6
	/*
	 * The stripe identifier must identify the disks in each stripe, IN
	 * THE ORDER THAT THEY APPEAR IN THE STRIPE.
	 */
	info->stripeIdentifier = rf_make_2d_array((raidPtr->numCol),
						  (raidPtr->numCol),
d117 2
a118 2
			info->stripeIdentifier[i][j] = (startdisk + j) %
			    (raidPtr->numCol - 1);
d124 1
a124 1
	/* Fill in the remaining layout parameters. */
d126 2
a127 2
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
d130 4
a133 4
	layoutPtr->numDataCol = raidPtr->numCol - layoutPtr->numParityCol -
	    layoutPtr->numParityLogCol;
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
d135 2
a136 2
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;
d138 2
a139 2
	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d141 20
a160 21
	/*
	 * Configure parity log parameters.
	 *
	 * Parameter			Comment/constraints
	 * ------------------------------------------------
	 * numParityRegions*		All regions (except possibly last)
	 *				of equal size.
	 * totalInCoreLogCapacity*	Amount of memory in bytes available
	 *				for in-core logs (default 1 MB).
	 * numSectorsPerLog#		Capacity of an in-core log in sectors
	 *				(1 * disk track).
	 * numParityLogs		Total number of in-core logs,
	 *				should be at least numParityRegions.
	 * regionLogCapacity		Size of a region log (except possibly
	 *				last one) in sectors.
	 * totalLogCapacity		Total amount of log space in sectors.
	 *
	 * Where '*' denotes a user settable parameter.
	 * Note that logs are fixed to be the size of a disk track,
	 * value #defined in rf_paritylog.h.
	 *
d163 1
a163 2
	totalLogCapacity = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit * layoutPtr->numParityLogCol;
d168 1
a168 2
	/*
	 * Reduce fragmentation within a disk region by adjusting the number
d170 1
a170 2
	 * into a disk region.
	 */
d174 1
a174 1
			if (((totalLogCapacity / (rf_numParityRegions + i)) %
d178 3
a180 3
				    rf_numParityRegions;
				fragmentation = raidPtr->regionLogCapacity %
				    raidPtr->numSectorsPerLog;
d182 1
a182 1
			if (((totalLogCapacity / (rf_numParityRegions - i)) %
d186 3
a188 3
				    rf_numParityRegions;
				fragmentation = raidPtr->regionLogCapacity %
				    raidPtr->numSectorsPerLog;
d191 9
a199 10
	/* Ensure integral number of regions per log. */
	raidPtr->regionLogCapacity = (raidPtr->regionLogCapacity /
	    raidPtr->numSectorsPerLog) * raidPtr->numSectorsPerLog;

	raidPtr->numParityLogs = rf_totalInCoreLogCapacity /
	    (raidPtr->bytesPerSector * raidPtr->numSectorsPerLog);
	/*
	 * To avoid deadlock, must ensure that enough logs exist for each
	 * region to have one simultaneously.
	 */
d203 1
a203 1
	/* Create region information structs. */
d206 2
a207 2
	RF_Malloc(raidPtr->regionInfo,
		  (rf_numParityRegions * sizeof(RF_RegionInfo_t)),
d212 1
a212 1
	/* Last region may not be full capacity. */
d214 1
a214 1
	while ((rf_numParityRegions - 1) * raidPtr->regionLogCapacity +
d216 2
a217 2
		lastRegionCapacity = lastRegionCapacity -
		    raidPtr->numSectorsPerLog;
d219 2
a220 2
	raidPtr->regionParityRange = raidPtr->sectorsPerDisk /
	    rf_numParityRegions;
d223 3
a225 3
	/* I can't remember why this line is in the code -wvcii 6/30/95. */
	/* if (raidPtr->sectorsPerDisk % rf_numParityRegions > 0)
	 *	regionParityRange++; */
d227 1
a227 1
	/* Build pool of unused parity logs. */
d229 1
a229 1
	       raidPtr->numParityLogs * raidPtr->numSectorsPerLog *
d232 2
a233 2
	RF_Malloc(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs *
		  raidPtr->numSectorsPerLog * raidPtr->bytesPerSector,
d240 1
a240 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
d242 1
a242 1
		RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs *
d248 1
a248 1
			RF_Calloc(raidPtr->parityLogPool.parityLogs, 1,
d251 3
a253 3
				RF_Free(raidPtr->parityLogBufferHeap,
					raidPtr->numParityLogs *
					raidPtr->numSectorsPerLog *
d259 1
a259 1
			RF_Calloc(l->next, 1, sizeof(RF_ParityLog_t),
d262 3
a264 3
				RF_Free(raidPtr->parityLogBufferHeap,
					raidPtr->numParityLogs *
					raidPtr->numSectorsPerLog *
d266 1
a266 1
				for (l = raidPtr->parityLogPool.parityLogs;
d271 1
a271 3
						RF_Free(l->records,
						    (raidPtr->numSectorsPerLog *
						 sizeof(RF_ParityLogRecord_t)));
d279 4
a282 4
		lHeapPtr += raidPtr->numSectorsPerLog *
		    raidPtr->bytesPerSector;
		RF_Malloc(l->records, (raidPtr->numSectorsPerLog *
				       sizeof(RF_ParityLogRecord_t)),
d285 3
a287 3
			RF_Free(raidPtr->parityLogBufferHeap,
				raidPtr->numParityLogs *
				raidPtr->numSectorsPerLog *
d289 2
a290 2
			for (l = raidPtr->parityLogPool.parityLogs;
			     l;
d294 2
a295 2
					RF_Free(l->records,
						(raidPtr->numSectorsPerLog *
d304 2
a305 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
d309 1
a309 1
	/* Build pool of region buffers. */
d312 1
a312 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
d318 1
a318 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
d323 3
a325 3
	raidPtr->regionBufferPool.bufferSize = raidPtr->regionLogCapacity *
	    raidPtr->bytesPerSector;
	printf("regionBufferPool.bufferSize %d\n",
d328 2
a329 2
	/* For now, only one region at a time may be reintegrated. */
	raidPtr->regionBufferPool.totalBuffers = 1;
d331 2
a332 2
	raidPtr->regionBufferPool.availableBuffers =
	    raidPtr->regionBufferPool.totalBuffers;
d336 1
a336 1
	       (int) (raidPtr->regionBufferPool.totalBuffers *
d338 2
a339 2
	RF_Malloc(raidPtr->regionBufferPool.buffers,
		  raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t),
d348 1
a348 1
		       (int) (raidPtr->regionBufferPool.bufferSize *
d350 1
a350 1
		RF_Malloc(raidPtr->regionBufferPool.buffers[i],
d357 1
a357 1
				RF_Free(raidPtr->regionBufferPool.buffers[i],
d361 2
a362 2
			RF_Free(raidPtr->regionBufferPool.buffers,
				raidPtr->regionBufferPool.totalBuffers *
d369 1
a369 1
	rc = rf_ShutdownCreate(listp,
d373 2
a374 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
d378 1
a378 1
	/* Build pool of parity buffers. */
d382 1
a382 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
d388 1
a388 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
d393 3
a395 3
	raidPtr->parityBufferPool.bufferSize = parityBufferCapacity *
	    raidPtr->bytesPerSector;
	printf("parityBufferPool.bufferSize %d\n",
d398 2
a399 2
	/* For now, only one region at a time may be reintegrated. */
	raidPtr->parityBufferPool.totalBuffers = 1;
d401 2
a402 2
	raidPtr->parityBufferPool.availableBuffers =
	    raidPtr->parityBufferPool.totalBuffers;
d406 1
a406 1
	       (int) (raidPtr->parityBufferPool.totalBuffers *
d408 3
a410 3
	       raidPtr->parityBufferPool.totalBuffers);
	RF_Malloc(raidPtr->parityBufferPool.buffers,
		  raidPtr->parityBufferPool.totalBuffers * sizeof(caddr_t),
d419 3
a421 3
		       (int) (raidPtr->parityBufferPool.bufferSize *
			      sizeof(char)), i);
		RF_Malloc(raidPtr->parityBufferPool.buffers[i],
d428 2
a429 2
				RF_Free(raidPtr->parityBufferPool.buffers[i],
					raidPtr->regionBufferPool.bufferSize *
d432 2
a433 2
			RF_Free(raidPtr->parityBufferPool.buffers,
				raidPtr->regionBufferPool.totalBuffers *
d440 2
a441 2
	rc = rf_ShutdownCreate(listp,
			       rf_ShutdownParityLoggingParityBufferPool,
d444 2
a445 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
d449 2
a450 2
	/* Initialize parityLogDiskQueue. */
	rc = rf_create_managed_mutex(listp,
d453 1
a453 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
d459 1
a459 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
d476 2
a477 2
	rc = rf_ShutdownCreate(listp,
			       rf_ShutdownParityLoggingDiskQueue,
d480 2
a481 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
d487 2
a488 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
				     " rc=%d\n", __FILE__, __LINE__, rc);
d490 3
a492 3
				rf_FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo,
				(rf_numParityRegions *
d498 2
a499 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
				     " rc=%d\n", __FILE__, __LINE__, rc);
d502 3
a504 3
				rf_FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo,
				(rf_numParityRegions *
d509 4
a512 4
		raidPtr->regionInfo[i].regionStartAddr =
		    raidPtr->regionLogCapacity * i;
		raidPtr->regionInfo[i].parityStartAddr =
		    raidPtr->regionParityRange * i;
d514 4
a517 4
			raidPtr->regionInfo[i].capacity =
			    raidPtr->regionLogCapacity;
			raidPtr->regionInfo[i].numSectorsParity =
			    raidPtr->regionParityRange;
d519 6
a524 5
			raidPtr->regionInfo[i].capacity = lastRegionCapacity;
			raidPtr->regionInfo[i].numSectorsParity =
			    raidPtr->sectorsPerDisk -
			    raidPtr->regionParityRange * i;
			if (raidPtr->regionInfo[i].numSectorsParity >
d526 2
a527 2
				maxRegionParityRange =
				    raidPtr->regionInfo[i].numSectorsParity;
d530 2
a531 2
		RF_ASSERT(raidPtr->regionInfo[i].capacity +
			  raidPtr->regionInfo[i].regionStartAddr <=
d533 2
a534 2
		RF_ASSERT(raidPtr->regionInfo[i].parityStartAddr +
			  raidPtr->regionInfo[i].numSectorsParity <=
d539 1
a539 1
		RF_Malloc(raidPtr->regionInfo[i].diskMap,
d541 1
a541 1
			   sizeof(RF_DiskMap_t)),
d547 3
a549 3
				rf_FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo,
				(rf_numParityRegions *
d557 1
a557 1
			       rf_ShutdownParityLoggingRegionInfo,
d560 2
a561 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
d567 2
a568 2
	rc = RF_CREATE_THREAD(raidPtr->pLogDiskThreadHandle,
			      rf_ParityLoggingDiskManager, raidPtr, "rf_log");
d571 2
a572 3
		RF_ERRORMSG3("Unable to create parity logging disk thread"
			     " file %s line %d rc=%d\n",
			     __FILE__, __LINE__, rc);
d575 1
a575 1
	/* Wait for thread to start. */
d578 1
a578 1
		RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond,
d585 1
a585 2
		RF_ERRORMSG1("Got rc=%d adding parity logging shutdown"
			     " event.\n", rc);
d590 8
a597 14
		printf("\t\t\tsize of disk log in sectors: %d\n",
		       (int) totalLogCapacity);
		printf("\t\t\ttotal number of parity regions is %d\n",
		       (int) rf_numParityRegions);
		printf("\t\t\tnominal sectors of log per parity region is %d\n",
		       (int) raidPtr->regionLogCapacity);
		printf("\t\t\tnominal region fragmentation is %d sectors\n",
		       (int) fragmentation);
		printf("\t\t\ttotal number of parity logs is %d\n",
		       raidPtr->numParityLogs);
		printf("\t\t\tparity log size is %d sectors\n",
		       raidPtr->numSectorsPerLog);
		printf("\t\t\ttotal in-core log space is %d bytes\n",
		       (int) rf_totalInCoreLogCapacity);
d604 4
a607 3

void
rf_FreeRegionInfo(RF_Raid_t *raidPtr, RF_RegionId_t regionID)
d610 2
a611 2
	RF_Free(raidPtr->regionInfo[regionID].diskMap,
		(raidPtr->regionInfo[regionID].capacity *
d614 1
a614 1
		rf_ReleaseParityLogs(raidPtr,
d627 4
a630 2
void
rf_FreeParityLogQueue(RF_Raid_t *raidPtr, RF_ParityLogQueue_t *queue)
d639 1
a639 1
		RF_Free(l2->records, (raidPtr->numSectorsPerLog *
d648 2
a649 2
void
rf_FreeRegionBufferQueue(RF_RegionBufferQueue_t *queue)
d651 1
a651 1
	int i;
d655 1
a655 1
		printf("Attempt to free region queue that is still in use !\n");
d665 1
a665 2

void
d673 1
a673 1
		printf("raid%d: ShutdownParityLoggingRegionInfo\n",
d676 1
a676 1
	/* Free region information structs. */
d678 2
a679 2
		rf_FreeRegionInfo(raidPtr, i);
	RF_Free(raidPtr->regionInfo, (rf_numParityRegions *
d684 1
a684 2

void
d693 3
a695 3
	/* Free contents of parityLogPool. */
	rf_FreeParityLogQueue(raidPtr, &raidPtr->parityLogPool);
	RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs *
d699 1
a699 2

void
d706 1
a706 1
		printf("raid%d: ShutdownParityLoggingRegionBufferPool\n",
d709 1
a709 1
	rf_FreeRegionBufferQueue(&raidPtr->regionBufferPool);
d712 1
a712 2

void
d722 1
a722 1
	rf_FreeRegionBufferQueue(&raidPtr->parityBufferPool);
d725 1
a725 2

void
d737 1
a737 1
	/* Free disk manager stuff. */
d744 2
a745 2
		raidPtr->parityLogDiskQueue.freeDataList =
		    raidPtr->parityLogDiskQueue.freeDataList->next;
d751 2
a752 2
		raidPtr->parityLogDiskQueue.freeCommonList =
		    raidPtr->parityLogDiskQueue.freeCommonList->next;
d757 1
a757 2

void
d766 4
a769 6
	/* Shutdown disk thread. */
	/*
	 * This has the desirable side-effect of forcing all regions to be
	 * reintegrated. This is necessary since all parity log maps are
	 * currently held in volatile memory.
	 */
d776 3
a778 3
	 * pLogDiskThread will now terminate when queues are cleared.
	 * Now wait for it to be done.
	 */
d781 1
a781 1
		RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond,
d786 1
a786 2
		printf("raid%d: ShutdownParityLogging done"
		       " (thread completed)\n", raidPtr->raidid);
d790 2
a791 3

int
rf_GetDefaultNumFloatingReconBuffersParityLogging(RF_Raid_t *raidPtr)
d796 2
a797 3

RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitParityLogging(RF_Raid_t *raidPtr)
d801 5
a805 5


/* Return the region ID for a given RAID address. */
RF_RegionId_t
rf_MapRegionIDParityLogging(RF_Raid_t *raidPtr, RF_SectorNum_t address)
d809 1
a809 2
	/* regionID = address / (raidPtr->regionParityRange *
	 *     raidPtr->Layout.numDataCol); */
d812 1
a812 1
		/* Last region may be larger than other regions. */
d816 1
a816 1
	RF_ASSERT(address < raidPtr->regionInfo[regionID].parityStartAddr +
d823 9
a831 4
/* Given a logical RAID sector, determine physical disk address of data. */
void
rf_MapSectorParityLogging(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d833 1
a833 1
	RF_StripeNum_t SUID = raidSector /
d837 1
a837 1
	 *     raidPtr->Layout.numParityLogCol)); */
d839 2
a840 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d845 9
a853 4
/* Given a logical RAID sector, determine physical disk address of parity. */
void
rf_MapParityParityLogging(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d855 2
a856 2
	RF_StripeNum_t SUID = raidSector /
	    raidPtr->Layout.sectorsPerStripeUnit;
d860 2
a861 2
	 *     raidPtr->Layout.numDataCol-(SUID / raidPtr->Layout.numDataCol) %
	 *      (raidPtr->numCol - raidPtr->Layout.numParityLogCol); */
d863 2
a864 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d869 9
a877 8
/*
 * Given a regionID and sector offset, determine the physical disk address
 * of the parity log.
 */
void
rf_MapLogParityLogging(RF_Raid_t *raidPtr, RF_RegionId_t regionID,
    RF_SectorNum_t regionOffset, RF_RowCol_t *row, RF_RowCol_t *col,
    RF_SectorNum_t *startSector)
d881 1
a881 2
	*startSector =
	    raidPtr->regionInfo[regionID].regionStartAddr + regionOffset;
d885 10
a894 8
/*
 * Given a regionID, determine the physical disk address of the logged
 * parity for that region.
 */
void
rf_MapRegionParity(RF_Raid_t *raidPtr, RF_RegionId_t regionID,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *startSector,
    RF_SectorCount_t *numSector)
d903 8
a910 7
/*
 * Given a logical RAID address, determine the participating disks in
 * the stripe.
 */
void
rf_IdentifyStripeParityLogging(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
d912 1
a912 1
	RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout,
d914 2
a915 2
	RF_ParityLoggingConfigInfo_t *info = (RF_ParityLoggingConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
d921 6
a926 3
void
rf_MapSIDToPSIDParityLogging(RF_RaidLayout_t *layoutPtr,
    RF_StripeNum_t stripeID, RF_StripeNum_t *psID, RF_ReconUnitNum_t *which_ru)
d933 1
a933 2
/*
 * Select an algorithm for performing an access. Returns two pointers,
d937 6
a942 3
void
rf_ParityLoggingDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmp, RF_VoidFuncPtr *createFunc)
d948 1
a948 1
	int prior_recon;
d953 1
a953 2
		RF_ERRORMSG("Multiple disks failed in a single group !"
			    "  Aborting I/O operation.\n");
d959 1
a959 2
			/*
			 * If under recon & already reconstructed, redirect
d961 1
a961 2
			 * failure indication.
			 */
d966 4
a969 4
			prior_recon = (rstat == rf_rs_reconfigured) ||
			    ((rstat == rf_rs_reconstructing) ?
			     rf_CheckRUReconstructed(raidPtr->reconControl[frow]
			      ->reconMap, failedPDA->startSector) : 0);
d971 1
a971 2
				RF_RowCol_t or = failedPDA->row;
				RF_RowCol_t oc = failedPDA->col;
d973 3
a975 3
				if (layoutPtr->map->flags &
				    RF_DISTRIBUTE_SPARE) {
					/* Redirect to dist spare space. */
d979 8
a986 19
						/* Parity has failed. */
						(layoutPtr->map->MapParity)
						    (raidPtr,
						     failedPDA->raidAddress,
						     &failedPDA->row,
						     &failedPDA->col,
						     &failedPDA->startSector,
						     RF_REMAP);

						if (asmp->parityInfo->next) {
							/*
							 * Redir 2nd component,
							 * if any.
							 */
							RF_PhysDiskAddr_t *p =
							 asmp->parityInfo->next;
							RF_SectorNum_t SUoffs =
							    p->startSector %
						layoutPtr->sectorsPerStripeUnit;
d989 4
a992 9
							/*
							 * Cheating:
							 * startSector is not
							 * really a RAID
							 * address.
							 */
							p->startSector =
			    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
				failedPDA->startSector) + SUoffs;
d995 3
a997 8
						if (asmp->parityInfo->next &&
						    failedPDA ==
						    asmp->parityInfo->next) {
							/*
							 * Should not ever
							 * happen.
							 */
							RF_ASSERT(0);
d999 5
a1003 9
							/* Data has failed. */
							(layoutPtr->map
							 ->MapSector)
							    (raidPtr,
							 failedPDA->raidAddress,
							    &failedPDA->row,
							    &failedPDA->col,
							&failedPDA->startSector,
							    RF_REMAP);
d1006 2
a1007 2
				} else {
					/* Redirect to dedicated spare space. */
d1009 2
a1010 4
					failedPDA->row =
					    raidPtr->Disks[frow][fcol].spareRow;
					failedPDA->col =
					    raidPtr->Disks[frow][fcol].spareCol;
d1012 1
a1012 2
					/*
					 * The parity may have two distinct
d1014 1
a1014 2
					 * to be redirected.
					 */
d1016 7
a1022 21
						if (failedPDA ==
						    asmp->parityInfo) {
							failedPDA->next->row =
							    failedPDA->row;
							failedPDA->next->col =
							    failedPDA->col;
						} else {
							if (failedPDA ==
							    asmp->parityInfo
							     ->next) {
								/*
								 * Paranoid:
								 * Should never
								 * occur.
								 */
								asmp->parityInfo
								->row =
								 failedPDA->row;
								asmp->parityInfo
								->col =
								 failedPDA->col;
a1023 1
						}
d1030 2
a1031 6
					printf("raid%d: Redirected type '%c'"
					       " r %d c %d o %ld -> r %d c %d"
					       " o %ld\n", raidPtr->raidid,
					       type, or, oc, (long) oo,
					       failedPDA->row, failedPDA->col,
					       (long) failedPDA->startSector);
d1039 1
a1039 2
			*createFunc =
			    (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;
d1041 1
a1041 2
			*createFunc =
			    (RF_VoidFuncPtr) rf_CreateRaidFiveDegradedReadDAG;
d1046 1
a1046 2
		/*
		 * If mirroring, always use large writes. If the access
d1048 1
a1048 1
		 * write. If the stripe contains a failure but the access
d1053 1
a1053 2
		 * single-stripe-unit updates to use just one disk.
		 */
d1055 2
a1056 2
			if (((asmp->numStripeUnitsAccessed <=
			      (layoutPtr->numDataCol / 2)) &&
d1058 1
a1058 1
			    (asmp->parityInfo->next != NULL) ||
d1060 1
a1060 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateParityLoggingSmallWriteDAG;
d1062 1
a1062 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateParityLoggingLargeWriteDAG;
d1065 1
a1065 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateNonRedundantWriteDAG;
d1067 1
a1067 3
				if (asmp->numStripeUnitsAccessed != 1 &&
				    failedPDA->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
d1070 1
a1070 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_CreateDegradedWriteDAG;
d1073 1
a1073 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.4
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylogging.c,v 1.3 2000/01/07 14:50:22 peter Exp $	*/
/*	$NetBSD: rf_paritylogging.c,v 1.8 2000/01/09 04:35:13 oster Exp $	*/
d204 2
d228 4
d335 3
d347 3
d405 4
d418 3
d536 3
@


1.4.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylogging.c,v 1.5 2000/08/08 16:07:44 peter Exp $	*/
/*	$NetBSD: rf_paritylogging.c,v 1.10 2000/02/12 16:06:27 oster Exp $	*/
a203 2
	printf("Allocating %d bytes for in-core parity region info\n",
	       (int) (rf_numParityRegions * sizeof(RF_RegionInfo_t)));
a225 4
	printf("Allocating %d bytes for %d parity logs\n",
	       raidPtr->numParityLogs * raidPtr->numSectorsPerLog * 
	       raidPtr->bytesPerSector,
	       raidPtr->numParityLogs);
a328 3
	printf("Allocating %d bytes for regionBufferPool\n",
	       (int) (raidPtr->regionBufferPool.totalBuffers * 
		      sizeof(caddr_t)));
a337 3
		printf("Allocating %d bytes for regionBufferPool#%d\n",
		       (int) (raidPtr->regionBufferPool.bufferSize * 
			      sizeof(char)), i);
a392 4
	printf("Allocating %d bytes for parityBufferPool of %d units\n",
	       (int) (raidPtr->parityBufferPool.totalBuffers * 
		      sizeof(caddr_t)),
	       raidPtr->parityBufferPool.totalBuffers );
a401 3
		printf("Allocating %d bytes for parityBufferPool#%d\n",
		       (int) (raidPtr->parityBufferPool.bufferSize * 
			      sizeof(char)),i);
a516 3
		printf("Allocating %d bytes for region %d\n",
		       (int) (raidPtr->regionInfo[i].capacity *
			   sizeof(RF_DiskMap_t)), i);
@


1.4.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d32 1
a32 1
 * Parity logging configuration, dag selection, and mapping is implemented here.
d37 1
a37 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d58 17
a74 20
	RF_RowCol_t **stripeIdentifier;	/*
					 * Filled in at config time & used by
					 * IdentifyStripe.
					 */
} RF_ParityLoggingConfigInfo_t;

void rf_FreeRegionInfo(RF_Raid_t *, RF_RegionId_t);
void rf_FreeParityLogQueue(RF_Raid_t *, RF_ParityLogQueue_t *);
void rf_FreeRegionBufferQueue(RF_RegionBufferQueue_t *);
void rf_ShutdownParityLogging(RF_ThreadArg_t);
void rf_ShutdownParityLoggingRegionInfo(RF_ThreadArg_t);
void rf_ShutdownParityLoggingPool(RF_ThreadArg_t);
void rf_ShutdownParityLoggingRegionBufferPool(RF_ThreadArg_t);
void rf_ShutdownParityLoggingParityBufferPool(RF_ThreadArg_t);
void rf_ShutdownParityLoggingDiskQueue(RF_ThreadArg_t);


int
rf_ConfigureParityLogging(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d76 1
a76 1
	int i, j, startdisk, rc;
d88 5
a92 5
	 * We create multiple entries on the shutdown list here, since
	 * this configuration routine is fairly complicated in and of
	 * itself, and this makes backing out of a failed configuration
	 * much simpler.
	 */
d96 3
a98 3
	/* Create a parity logging configuration structure. */
	RF_MallocAndAdd(info, sizeof(RF_ParityLoggingConfigInfo_t),
			(RF_ParityLoggingConfigInfo_t *),
d106 4
a109 6
	/*
	 * The stripe identifier must identify the disks in each stripe, IN
	 * THE ORDER THAT THEY APPEAR IN THE STRIPE.
	 */
	info->stripeIdentifier = rf_make_2d_array((raidPtr->numCol),
						  (raidPtr->numCol),
d117 2
a118 2
			info->stripeIdentifier[i][j] = (startdisk + j) %
			    (raidPtr->numCol - 1);
d124 1
a124 1
	/* Fill in the remaining layout parameters. */
d126 2
a127 2
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
d130 4
a133 4
	layoutPtr->numDataCol = raidPtr->numCol - layoutPtr->numParityCol -
	    layoutPtr->numParityLogCol;
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
d135 2
a136 2
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;
d138 2
a139 2
	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d141 20
a160 21
	/*
	 * Configure parity log parameters.
	 *
	 * Parameter			Comment/constraints
	 * ------------------------------------------------
	 * numParityRegions*		All regions (except possibly last)
	 *				of equal size.
	 * totalInCoreLogCapacity*	Amount of memory in bytes available
	 *				for in-core logs (default 1 MB).
	 * numSectorsPerLog#		Capacity of an in-core log in sectors
	 *				(1 * disk track).
	 * numParityLogs		Total number of in-core logs,
	 *				should be at least numParityRegions.
	 * regionLogCapacity		Size of a region log (except possibly
	 *				last one) in sectors.
	 * totalLogCapacity		Total amount of log space in sectors.
	 *
	 * Where '*' denotes a user settable parameter.
	 * Note that logs are fixed to be the size of a disk track,
	 * value #defined in rf_paritylog.h.
	 *
d163 1
a163 2
	totalLogCapacity = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit * layoutPtr->numParityLogCol;
d168 1
a168 2
	/*
	 * Reduce fragmentation within a disk region by adjusting the number
d170 1
a170 2
	 * into a disk region.
	 */
d174 1
a174 1
			if (((totalLogCapacity / (rf_numParityRegions + i)) %
d178 3
a180 3
				    rf_numParityRegions;
				fragmentation = raidPtr->regionLogCapacity %
				    raidPtr->numSectorsPerLog;
d182 1
a182 1
			if (((totalLogCapacity / (rf_numParityRegions - i)) %
d186 3
a188 3
				    rf_numParityRegions;
				fragmentation = raidPtr->regionLogCapacity %
				    raidPtr->numSectorsPerLog;
d191 9
a199 10
	/* Ensure integral number of regions per log. */
	raidPtr->regionLogCapacity = (raidPtr->regionLogCapacity /
	    raidPtr->numSectorsPerLog) * raidPtr->numSectorsPerLog;

	raidPtr->numParityLogs = rf_totalInCoreLogCapacity /
	    (raidPtr->bytesPerSector * raidPtr->numSectorsPerLog);
	/*
	 * To avoid deadlock, must ensure that enough logs exist for each
	 * region to have one simultaneously.
	 */
d203 1
a203 1
	/* Create region information structs. */
d206 2
a207 2
	RF_Malloc(raidPtr->regionInfo,
		  (rf_numParityRegions * sizeof(RF_RegionInfo_t)),
d212 1
a212 1
	/* Last region may not be full capacity. */
d214 1
a214 1
	while ((rf_numParityRegions - 1) * raidPtr->regionLogCapacity +
d216 2
a217 2
		lastRegionCapacity = lastRegionCapacity -
		    raidPtr->numSectorsPerLog;
d219 2
a220 2
	raidPtr->regionParityRange = raidPtr->sectorsPerDisk /
	    rf_numParityRegions;
d223 3
a225 3
	/* I can't remember why this line is in the code -wvcii 6/30/95. */
	/* if (raidPtr->sectorsPerDisk % rf_numParityRegions > 0)
	 *	regionParityRange++; */
d227 1
a227 1
	/* Build pool of unused parity logs. */
d229 1
a229 1
	       raidPtr->numParityLogs * raidPtr->numSectorsPerLog *
d232 2
a233 2
	RF_Malloc(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs *
		  raidPtr->numSectorsPerLog * raidPtr->bytesPerSector,
d240 1
a240 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
d242 1
a242 1
		RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs *
d248 1
a248 1
			RF_Calloc(raidPtr->parityLogPool.parityLogs, 1,
d251 3
a253 3
				RF_Free(raidPtr->parityLogBufferHeap,
					raidPtr->numParityLogs *
					raidPtr->numSectorsPerLog *
d259 1
a259 1
			RF_Calloc(l->next, 1, sizeof(RF_ParityLog_t),
d262 3
a264 3
				RF_Free(raidPtr->parityLogBufferHeap,
					raidPtr->numParityLogs *
					raidPtr->numSectorsPerLog *
d266 1
a266 1
				for (l = raidPtr->parityLogPool.parityLogs;
d271 1
a271 3
						RF_Free(l->records,
						    (raidPtr->numSectorsPerLog *
						 sizeof(RF_ParityLogRecord_t)));
d279 4
a282 4
		lHeapPtr += raidPtr->numSectorsPerLog *
		    raidPtr->bytesPerSector;
		RF_Malloc(l->records, (raidPtr->numSectorsPerLog *
				       sizeof(RF_ParityLogRecord_t)),
d285 3
a287 3
			RF_Free(raidPtr->parityLogBufferHeap,
				raidPtr->numParityLogs *
				raidPtr->numSectorsPerLog *
d289 2
a290 2
			for (l = raidPtr->parityLogPool.parityLogs;
			     l;
d294 2
a295 2
					RF_Free(l->records,
						(raidPtr->numSectorsPerLog *
d304 2
a305 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
d309 1
a309 1
	/* Build pool of region buffers. */
d312 1
a312 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
d318 1
a318 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
d323 3
a325 3
	raidPtr->regionBufferPool.bufferSize = raidPtr->regionLogCapacity *
	    raidPtr->bytesPerSector;
	printf("regionBufferPool.bufferSize %d\n",
d328 2
a329 2
	/* For now, only one region at a time may be reintegrated. */
	raidPtr->regionBufferPool.totalBuffers = 1;
d331 2
a332 2
	raidPtr->regionBufferPool.availableBuffers =
	    raidPtr->regionBufferPool.totalBuffers;
d336 1
a336 1
	       (int) (raidPtr->regionBufferPool.totalBuffers *
d338 2
a339 2
	RF_Malloc(raidPtr->regionBufferPool.buffers,
		  raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t),
d348 1
a348 1
		       (int) (raidPtr->regionBufferPool.bufferSize *
d350 1
a350 1
		RF_Malloc(raidPtr->regionBufferPool.buffers[i],
d357 1
a357 1
				RF_Free(raidPtr->regionBufferPool.buffers[i],
d361 2
a362 2
			RF_Free(raidPtr->regionBufferPool.buffers,
				raidPtr->regionBufferPool.totalBuffers *
d369 1
a369 1
	rc = rf_ShutdownCreate(listp,
d373 2
a374 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
d378 1
a378 1
	/* Build pool of parity buffers. */
d382 1
a382 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
d388 1
a388 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
d393 3
a395 3
	raidPtr->parityBufferPool.bufferSize = parityBufferCapacity *
	    raidPtr->bytesPerSector;
	printf("parityBufferPool.bufferSize %d\n",
d398 2
a399 2
	/* For now, only one region at a time may be reintegrated. */
	raidPtr->parityBufferPool.totalBuffers = 1;
d401 2
a402 2
	raidPtr->parityBufferPool.availableBuffers =
	    raidPtr->parityBufferPool.totalBuffers;
d406 1
a406 1
	       (int) (raidPtr->parityBufferPool.totalBuffers *
d408 3
a410 3
	       raidPtr->parityBufferPool.totalBuffers);
	RF_Malloc(raidPtr->parityBufferPool.buffers,
		  raidPtr->parityBufferPool.totalBuffers * sizeof(caddr_t),
d419 3
a421 3
		       (int) (raidPtr->parityBufferPool.bufferSize *
			      sizeof(char)), i);
		RF_Malloc(raidPtr->parityBufferPool.buffers[i],
d428 2
a429 2
				RF_Free(raidPtr->parityBufferPool.buffers[i],
					raidPtr->regionBufferPool.bufferSize *
d432 2
a433 2
			RF_Free(raidPtr->parityBufferPool.buffers,
				raidPtr->regionBufferPool.totalBuffers *
d440 2
a441 2
	rc = rf_ShutdownCreate(listp,
			       rf_ShutdownParityLoggingParityBufferPool,
d444 2
a445 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
d449 2
a450 2
	/* Initialize parityLogDiskQueue. */
	rc = rf_create_managed_mutex(listp,
d453 1
a453 1
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n",
d459 1
a459 1
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n",
d476 2
a477 2
	rc = rf_ShutdownCreate(listp,
			       rf_ShutdownParityLoggingDiskQueue,
d480 2
a481 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
d487 2
a488 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
				     " rc=%d\n", __FILE__, __LINE__, rc);
d490 3
a492 3
				rf_FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo,
				(rf_numParityRegions *
d498 2
a499 2
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
				     " rc=%d\n", __FILE__, __LINE__, rc);
d502 3
a504 3
				rf_FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo,
				(rf_numParityRegions *
d509 4
a512 4
		raidPtr->regionInfo[i].regionStartAddr =
		    raidPtr->regionLogCapacity * i;
		raidPtr->regionInfo[i].parityStartAddr =
		    raidPtr->regionParityRange * i;
d514 4
a517 4
			raidPtr->regionInfo[i].capacity =
			    raidPtr->regionLogCapacity;
			raidPtr->regionInfo[i].numSectorsParity =
			    raidPtr->regionParityRange;
d519 6
a524 5
			raidPtr->regionInfo[i].capacity = lastRegionCapacity;
			raidPtr->regionInfo[i].numSectorsParity =
			    raidPtr->sectorsPerDisk -
			    raidPtr->regionParityRange * i;
			if (raidPtr->regionInfo[i].numSectorsParity >
d526 2
a527 2
				maxRegionParityRange =
				    raidPtr->regionInfo[i].numSectorsParity;
d530 2
a531 2
		RF_ASSERT(raidPtr->regionInfo[i].capacity +
			  raidPtr->regionInfo[i].regionStartAddr <=
d533 2
a534 2
		RF_ASSERT(raidPtr->regionInfo[i].parityStartAddr +
			  raidPtr->regionInfo[i].numSectorsParity <=
d539 1
a539 1
		RF_Malloc(raidPtr->regionInfo[i].diskMap,
d541 1
a541 1
			   sizeof(RF_DiskMap_t)),
d547 3
a549 3
				rf_FreeRegionInfo(raidPtr, j);
			RF_Free(raidPtr->regionInfo,
				(rf_numParityRegions *
d557 1
a557 1
			       rf_ShutdownParityLoggingRegionInfo,
d560 2
a561 2
		RF_ERRORMSG3("Unable to create shutdown entry file %s line %d"
			     " rc=%d\n", __FILE__, __LINE__, rc);
d567 2
a568 2
	rc = RF_CREATE_THREAD(raidPtr->pLogDiskThreadHandle,
			      rf_ParityLoggingDiskManager, raidPtr, "rf_log");
d571 2
a572 3
		RF_ERRORMSG3("Unable to create parity logging disk thread"
			     " file %s line %d rc=%d\n",
			     __FILE__, __LINE__, rc);
d575 1
a575 1
	/* Wait for thread to start. */
d578 1
a578 1
		RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond,
d585 1
a585 2
		RF_ERRORMSG1("Got rc=%d adding parity logging shutdown"
			     " event.\n", rc);
d590 8
a597 14
		printf("\t\t\tsize of disk log in sectors: %d\n",
		       (int) totalLogCapacity);
		printf("\t\t\ttotal number of parity regions is %d\n",
		       (int) rf_numParityRegions);
		printf("\t\t\tnominal sectors of log per parity region is %d\n",
		       (int) raidPtr->regionLogCapacity);
		printf("\t\t\tnominal region fragmentation is %d sectors\n",
		       (int) fragmentation);
		printf("\t\t\ttotal number of parity logs is %d\n",
		       raidPtr->numParityLogs);
		printf("\t\t\tparity log size is %d sectors\n",
		       raidPtr->numSectorsPerLog);
		printf("\t\t\ttotal in-core log space is %d bytes\n",
		       (int) rf_totalInCoreLogCapacity);
d604 4
a607 3

void
rf_FreeRegionInfo(RF_Raid_t *raidPtr, RF_RegionId_t regionID)
d610 2
a611 2
	RF_Free(raidPtr->regionInfo[regionID].diskMap,
		(raidPtr->regionInfo[regionID].capacity *
d614 1
a614 1
		rf_ReleaseParityLogs(raidPtr,
d627 4
a630 2
void
rf_FreeParityLogQueue(RF_Raid_t *raidPtr, RF_ParityLogQueue_t *queue)
d639 1
a639 1
		RF_Free(l2->records, (raidPtr->numSectorsPerLog *
d648 2
a649 2
void
rf_FreeRegionBufferQueue(RF_RegionBufferQueue_t *queue)
d651 1
a651 1
	int i;
d655 1
a655 1
		printf("Attempt to free region queue that is still in use !\n");
d665 1
a665 2

void
d673 1
a673 1
		printf("raid%d: ShutdownParityLoggingRegionInfo\n",
d676 1
a676 1
	/* Free region information structs. */
d678 2
a679 2
		rf_FreeRegionInfo(raidPtr, i);
	RF_Free(raidPtr->regionInfo, (rf_numParityRegions *
d684 1
a684 2

void
d693 3
a695 3
	/* Free contents of parityLogPool. */
	rf_FreeParityLogQueue(raidPtr, &raidPtr->parityLogPool);
	RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs *
d699 1
a699 2

void
d706 1
a706 1
		printf("raid%d: ShutdownParityLoggingRegionBufferPool\n",
d709 1
a709 1
	rf_FreeRegionBufferQueue(&raidPtr->regionBufferPool);
d712 1
a712 2

void
d722 1
a722 1
	rf_FreeRegionBufferQueue(&raidPtr->parityBufferPool);
d725 1
a725 2

void
d737 1
a737 1
	/* Free disk manager stuff. */
d744 2
a745 2
		raidPtr->parityLogDiskQueue.freeDataList =
		    raidPtr->parityLogDiskQueue.freeDataList->next;
d751 2
a752 2
		raidPtr->parityLogDiskQueue.freeCommonList =
		    raidPtr->parityLogDiskQueue.freeCommonList->next;
d757 1
a757 2

void
d766 4
a769 6
	/* Shutdown disk thread. */
	/*
	 * This has the desirable side-effect of forcing all regions to be
	 * reintegrated. This is necessary since all parity log maps are
	 * currently held in volatile memory.
	 */
d776 3
a778 3
	 * pLogDiskThread will now terminate when queues are cleared.
	 * Now wait for it to be done.
	 */
d781 1
a781 1
		RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond,
d786 1
a786 2
		printf("raid%d: ShutdownParityLogging done"
		       " (thread completed)\n", raidPtr->raidid);
d790 2
a791 3

int
rf_GetDefaultNumFloatingReconBuffersParityLogging(RF_Raid_t *raidPtr)
d796 2
a797 3

RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitParityLogging(RF_Raid_t *raidPtr)
d801 5
a805 5


/* Return the region ID for a given RAID address. */
RF_RegionId_t
rf_MapRegionIDParityLogging(RF_Raid_t *raidPtr, RF_SectorNum_t address)
d809 1
a809 2
	/* regionID = address / (raidPtr->regionParityRange *
	 *     raidPtr->Layout.numDataCol); */
d812 1
a812 1
		/* Last region may be larger than other regions. */
d816 1
a816 1
	RF_ASSERT(address < raidPtr->regionInfo[regionID].parityStartAddr +
d823 9
a831 4
/* Given a logical RAID sector, determine physical disk address of data. */
void
rf_MapSectorParityLogging(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d833 1
a833 1
	RF_StripeNum_t SUID = raidSector /
d837 1
a837 1
	 *     raidPtr->Layout.numParityLogCol)); */
d839 2
a840 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d845 9
a853 4
/* Given a logical RAID sector, determine physical disk address of parity. */
void
rf_MapParityParityLogging(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d855 2
a856 2
	RF_StripeNum_t SUID = raidSector /
	    raidPtr->Layout.sectorsPerStripeUnit;
d860 2
a861 2
	 *     raidPtr->Layout.numDataCol-(SUID / raidPtr->Layout.numDataCol) %
	 *      (raidPtr->numCol - raidPtr->Layout.numParityLogCol); */
d863 2
a864 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d869 9
a877 8
/*
 * Given a regionID and sector offset, determine the physical disk address
 * of the parity log.
 */
void
rf_MapLogParityLogging(RF_Raid_t *raidPtr, RF_RegionId_t regionID,
    RF_SectorNum_t regionOffset, RF_RowCol_t *row, RF_RowCol_t *col,
    RF_SectorNum_t *startSector)
d881 1
a881 2
	*startSector =
	    raidPtr->regionInfo[regionID].regionStartAddr + regionOffset;
d885 10
a894 8
/*
 * Given a regionID, determine the physical disk address of the logged
 * parity for that region.
 */
void
rf_MapRegionParity(RF_Raid_t *raidPtr, RF_RegionId_t regionID,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *startSector,
    RF_SectorCount_t *numSector)
d903 8
a910 7
/*
 * Given a logical RAID address, determine the participating disks in
 * the stripe.
 */
void
rf_IdentifyStripeParityLogging(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
d912 1
a912 1
	RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout,
d914 2
a915 2
	RF_ParityLoggingConfigInfo_t *info = (RF_ParityLoggingConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
d921 6
a926 3
void
rf_MapSIDToPSIDParityLogging(RF_RaidLayout_t *layoutPtr,
    RF_StripeNum_t stripeID, RF_StripeNum_t *psID, RF_ReconUnitNum_t *which_ru)
d933 1
a933 2
/*
 * Select an algorithm for performing an access. Returns two pointers,
d937 6
a942 3
void
rf_ParityLoggingDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmp, RF_VoidFuncPtr *createFunc)
d948 1
a948 1
	int prior_recon;
d953 1
a953 2
		RF_ERRORMSG("Multiple disks failed in a single group !"
			    "  Aborting I/O operation.\n");
d959 1
a959 2
			/*
			 * If under recon & already reconstructed, redirect
d961 1
a961 2
			 * failure indication.
			 */
d966 4
a969 4
			prior_recon = (rstat == rf_rs_reconfigured) ||
			    ((rstat == rf_rs_reconstructing) ?
			     rf_CheckRUReconstructed(raidPtr->reconControl[frow]
			      ->reconMap, failedPDA->startSector) : 0);
d971 1
a971 2
				RF_RowCol_t or = failedPDA->row;
				RF_RowCol_t oc = failedPDA->col;
d973 3
a975 3
				if (layoutPtr->map->flags &
				    RF_DISTRIBUTE_SPARE) {
					/* Redirect to dist spare space. */
d979 8
a986 19
						/* Parity has failed. */
						(layoutPtr->map->MapParity)
						    (raidPtr,
						     failedPDA->raidAddress,
						     &failedPDA->row,
						     &failedPDA->col,
						     &failedPDA->startSector,
						     RF_REMAP);

						if (asmp->parityInfo->next) {
							/*
							 * Redir 2nd component,
							 * if any.
							 */
							RF_PhysDiskAddr_t *p =
							 asmp->parityInfo->next;
							RF_SectorNum_t SUoffs =
							    p->startSector %
						layoutPtr->sectorsPerStripeUnit;
d989 4
a992 9
							/*
							 * Cheating:
							 * startSector is not
							 * really a RAID
							 * address.
							 */
							p->startSector =
			    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
				failedPDA->startSector) + SUoffs;
d995 3
a997 8
						if (asmp->parityInfo->next &&
						    failedPDA ==
						    asmp->parityInfo->next) {
							/*
							 * Should not ever
							 * happen.
							 */
							RF_ASSERT(0);
d999 5
a1003 9
							/* Data has failed. */
							(layoutPtr->map
							 ->MapSector)
							    (raidPtr,
							 failedPDA->raidAddress,
							    &failedPDA->row,
							    &failedPDA->col,
							&failedPDA->startSector,
							    RF_REMAP);
d1006 2
a1007 2
				} else {
					/* Redirect to dedicated spare space. */
d1009 2
a1010 4
					failedPDA->row =
					    raidPtr->Disks[frow][fcol].spareRow;
					failedPDA->col =
					    raidPtr->Disks[frow][fcol].spareCol;
d1012 1
a1012 2
					/*
					 * The parity may have two distinct
d1014 1
a1014 2
					 * to be redirected.
					 */
d1016 7
a1022 21
						if (failedPDA ==
						    asmp->parityInfo) {
							failedPDA->next->row =
							    failedPDA->row;
							failedPDA->next->col =
							    failedPDA->col;
						} else {
							if (failedPDA ==
							    asmp->parityInfo
							     ->next) {
								/*
								 * Paranoid:
								 * Should never
								 * occur.
								 */
								asmp->parityInfo
								->row =
								 failedPDA->row;
								asmp->parityInfo
								->col =
								 failedPDA->col;
a1023 1
						}
d1030 2
a1031 6
					printf("raid%d: Redirected type '%c'"
					       " r %d c %d o %ld -> r %d c %d"
					       " o %ld\n", raidPtr->raidid,
					       type, or, oc, (long) oo,
					       failedPDA->row, failedPDA->col,
					       (long) failedPDA->startSector);
d1039 1
a1039 2
			*createFunc =
			    (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;
d1041 1
a1041 2
			*createFunc =
			    (RF_VoidFuncPtr) rf_CreateRaidFiveDegradedReadDAG;
d1046 1
a1046 2
		/*
		 * If mirroring, always use large writes. If the access
d1048 1
a1048 1
		 * write. If the stripe contains a failure but the access
d1053 1
a1053 2
		 * single-stripe-unit updates to use just one disk.
		 */
d1055 2
a1056 2
			if (((asmp->numStripeUnitsAccessed <=
			      (layoutPtr->numDataCol / 2)) &&
d1058 1
a1058 1
			    (asmp->parityInfo->next != NULL) ||
d1060 1
a1060 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateParityLoggingSmallWriteDAG;
d1062 1
a1062 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateParityLoggingLargeWriteDAG;
d1065 1
a1065 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateNonRedundantWriteDAG;
d1067 1
a1067 3
				if (asmp->numStripeUnitsAccessed != 1 &&
				    failedPDA->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
d1070 1
a1070 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_CreateDegradedWriteDAG;
d1073 1
a1073 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.3
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylogging.c,v 1.2 1999/02/16 00:03:06 niklas Exp $	*/
/*	$NetBSD: rf_paritylogging.c,v 1.4 2000/01/05 02:57:29 oster Exp $	*/
a47 1
#include "rf_threadid.h"
d84 3
d97 3
a99 1
	RF_MallocAndAdd(info, sizeof(RF_ParityLoggingConfigInfo_t), (RF_ParityLoggingConfigInfo_t *), raidPtr->cleanupList);
d108 3
a110 1
	info->stripeIdentifier = rf_make_2d_array((raidPtr->numCol), (raidPtr->numCol), raidPtr->cleanupList);
d117 2
a118 1
			info->stripeIdentifier[i][j] = (startdisk + j) % (raidPtr->numCol - 1);
d126 2
a127 1
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;
d130 4
a133 2
	layoutPtr->numDataCol = raidPtr->numCol - layoutPtr->numParityCol - layoutPtr->numParityLogCol;
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d135 2
a136 1
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;
d138 2
a139 1
	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d143 13
a155 9
	 * parameter               comment/constraints ----------------
	 * ------------------- numParityRegions        all regions (except
	 * possibly last) of equal size totalInCoreLogCapacity  amount of
	 * memory in bytes available for in-core logs (default 1 MB) #
	 * numSectorsPerLog        capacity of an in-core log in sectors (1
	 * disk track) numParityLogs           total number of in-core logs,
	 * should be at least numParityRegions regionLogCapacity       size of
	 * a region log (except possibly last one) in sectors totalLogCapacity
	 * total amount of log space in sectors
d157 3
a159 2
	 * denotes a user settable parameter. # logs are fixed to be the size of
	 * a disk track, value #defined in rf_paritylog.h
d174 2
a175 1
			if (((totalLogCapacity / (rf_numParityRegions + i)) % raidPtr->numSectorsPerLog) < fragmentation) {
d177 4
a180 2
				raidPtr->regionLogCapacity = totalLogCapacity / rf_numParityRegions;
				fragmentation = raidPtr->regionLogCapacity % raidPtr->numSectorsPerLog;
d182 2
a183 1
			if (((totalLogCapacity / (rf_numParityRegions - i)) % raidPtr->numSectorsPerLog) < fragmentation) {
d185 4
a188 2
				raidPtr->regionLogCapacity = totalLogCapacity / rf_numParityRegions;
				fragmentation = raidPtr->regionLogCapacity % raidPtr->numSectorsPerLog;
d192 3
a194 1
	raidPtr->regionLogCapacity = (raidPtr->regionLogCapacity / raidPtr->numSectorsPerLog) * raidPtr->numSectorsPerLog;
d196 2
a197 1
	raidPtr->numParityLogs = rf_totalInCoreLogCapacity / (raidPtr->bytesPerSector * raidPtr->numSectorsPerLog);
d204 3
a206 1
	RF_Malloc(raidPtr->regionInfo, (rf_numParityRegions * sizeof(RF_RegionInfo_t)), (RF_RegionInfo_t *));
d212 4
a215 2
	while ((rf_numParityRegions - 1) * raidPtr->regionLogCapacity + lastRegionCapacity > totalLogCapacity)
		lastRegionCapacity = lastRegionCapacity - raidPtr->numSectorsPerLog;
d217 2
a218 1
	raidPtr->regionParityRange = raidPtr->sectorsPerDisk / rf_numParityRegions;
d226 3
a228 1
	RF_Malloc(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector, (caddr_t));
d234 4
a237 3
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
		RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
d242 2
a243 1
			RF_Calloc(raidPtr->parityLogPool.parityLogs, 1, sizeof(RF_ParityLog_t), (RF_ParityLog_t *));
d245 4
a248 1
				RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
d253 2
a254 1
			RF_Calloc(l->next, 1, sizeof(RF_ParityLog_t), (RF_ParityLog_t *));
d256 7
a262 2
				RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
				for (l = raidPtr->parityLogPool.parityLogs; l; l = next) {
d273 5
a277 2
		lHeapPtr += raidPtr->numSectorsPerLog * raidPtr->bytesPerSector;
		RF_Malloc(l->records, (raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t)), (RF_ParityLogRecord_t *));
d279 7
a285 2
			RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
			for (l = raidPtr->parityLogPool.parityLogs; l; l = next) {
d288 3
a290 1
					RF_Free(l->records, (raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t)));
d306 2
a307 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d312 2
a313 2
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d317 10
a326 6
	raidPtr->regionBufferPool.bufferSize = raidPtr->regionLogCapacity * raidPtr->bytesPerSector;
	printf("regionBufferPool.bufferSize %d\n", raidPtr->regionBufferPool.bufferSize);
	raidPtr->regionBufferPool.totalBuffers = 1;	/* for now, only one
							 * region at a time may
							 * be reintegrated */
	raidPtr->regionBufferPool.availableBuffers = raidPtr->regionBufferPool.totalBuffers;
d329 3
a331 1
	RF_Malloc(raidPtr->regionBufferPool.buffers, raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t), (caddr_t *));
d338 4
a341 2
		RF_Malloc(raidPtr->regionBufferPool.buffers[i], raidPtr->regionBufferPool.bufferSize * sizeof(char), (caddr_t));
		if (raidPtr->regionBufferPool.buffers == NULL) {
d345 3
a347 1
				RF_Free(raidPtr->regionBufferPool.buffers[i], raidPtr->regionBufferPool.bufferSize * sizeof(char));
d349 3
a351 1
			RF_Free(raidPtr->regionBufferPool.buffers, raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t));
d357 3
a359 1
	rc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingRegionBufferPool, raidPtr);
d370 2
a371 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d376 2
a377 2
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d381 10
a390 6
	raidPtr->parityBufferPool.bufferSize = parityBufferCapacity * raidPtr->bytesPerSector;
	printf("parityBufferPool.bufferSize %d\n", raidPtr->parityBufferPool.bufferSize);
	raidPtr->parityBufferPool.totalBuffers = 1;	/* for now, only one
							 * region at a time may
							 * be reintegrated */
	raidPtr->parityBufferPool.availableBuffers = raidPtr->parityBufferPool.totalBuffers;
d393 3
a395 1
	RF_Malloc(raidPtr->parityBufferPool.buffers, raidPtr->parityBufferPool.totalBuffers * sizeof(caddr_t), (caddr_t *));
d402 3
a404 1
		RF_Malloc(raidPtr->parityBufferPool.buffers[i], raidPtr->parityBufferPool.bufferSize * sizeof(char), (caddr_t));
d409 3
a411 1
				RF_Free(raidPtr->parityBufferPool.buffers[i], raidPtr->regionBufferPool.bufferSize * sizeof(char));
d413 3
a415 1
			RF_Free(raidPtr->parityBufferPool.buffers, raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t));
d421 3
a423 1
	rc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingParityBufferPool, raidPtr);
d431 2
a432 1
	rc = rf_create_managed_mutex(listp, &raidPtr->parityLogDiskQueue.mutex);
d434 2
a435 2
		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d440 2
a441 2
		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d457 3
a459 1
	rc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingDiskQueue, raidPtr);
d472 3
a474 1
			RF_Free(raidPtr->regionInfo, (rf_numParityRegions * sizeof(RF_RegionInfo_t)));
d484 3
a486 1
			RF_Free(raidPtr->regionInfo, (rf_numParityRegions * sizeof(RF_RegionInfo_t)));
d490 4
a493 2
		raidPtr->regionInfo[i].regionStartAddr = raidPtr->regionLogCapacity * i;
		raidPtr->regionInfo[i].parityStartAddr = raidPtr->regionParityRange * i;
d495 4
a498 2
			raidPtr->regionInfo[i].capacity = raidPtr->regionLogCapacity;
			raidPtr->regionInfo[i].numSectorsParity = raidPtr->regionParityRange;
d500 9
a508 4
			raidPtr->regionInfo[i].capacity = lastRegionCapacity;
			raidPtr->regionInfo[i].numSectorsParity = raidPtr->sectorsPerDisk - raidPtr->regionParityRange * i;
			if (raidPtr->regionInfo[i].numSectorsParity > maxRegionParityRange)
				maxRegionParityRange = raidPtr->regionInfo[i].numSectorsParity;
d511 10
a520 3
		RF_ASSERT(raidPtr->regionInfo[i].capacity + raidPtr->regionInfo[i].regionStartAddr <= totalLogCapacity);
		RF_ASSERT(raidPtr->regionInfo[i].parityStartAddr + raidPtr->regionInfo[i].numSectorsParity <= raidPtr->sectorsPerDisk);
		RF_Malloc(raidPtr->regionInfo[i].diskMap, (raidPtr->regionInfo[i].capacity * sizeof(RF_DiskMap_t)), (RF_DiskMap_t *));
d526 3
a528 1
			RF_Free(raidPtr->regionInfo, (rf_numParityRegions * sizeof(RF_RegionInfo_t)));
d534 3
a536 1
	rc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingRegionInfo, raidPtr);
d545 2
a546 1
	rc = RF_CREATE_THREAD(raidPtr->pLogDiskThreadHandle, rf_ParityLoggingDiskManager, raidPtr,"rf_log");
d556 2
a557 1
		RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, raidPtr->parityLogDiskQueue.mutex);
d588 3
a590 1
	RF_Free(raidPtr->regionInfo[regionID].diskMap, (raidPtr->regionInfo[regionID].capacity * sizeof(RF_DiskMap_t)));
d592 2
a593 1
		rf_ReleaseParityLogs(raidPtr, raidPtr->regionInfo[regionID].coreLog);
d617 2
a618 1
		RF_Free(l2->records, (raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t)));
d651 2
a652 3
		int     tid;
		rf_get_threadid(tid);
		printf("[%d] ShutdownParityLoggingRegionInfo\n", tid);
d657 2
a658 1
	RF_Free(raidPtr->regionInfo, (rf_numParityRegions * sizeof(raidPtr->regionInfo)));
d669 1
a669 3
		int     tid;
		rf_get_threadid(tid);
		printf("[%d] ShutdownParityLoggingPool\n", tid);
d673 2
a674 1
	RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
d684 2
a685 3
		int     tid;
		rf_get_threadid(tid);
		printf("[%d] ShutdownParityLoggingRegionBufferPool\n", tid);
d697 2
a698 3
		int     tid;
		rf_get_threadid(tid);
		printf("[%d] ShutdownParityLoggingParityBufferPool\n", tid);
d712 2
a713 3
		int     tid;
		rf_get_threadid(tid);
		printf("[%d] ShutdownParityLoggingDiskQueue\n", tid);
d722 2
a723 1
		raidPtr->parityLogDiskQueue.freeDataList = raidPtr->parityLogDiskQueue.freeDataList->next;
d729 2
a730 1
		raidPtr->parityLogDiskQueue.freeCommonList = raidPtr->parityLogDiskQueue.freeCommonList->next;
d742 1
a742 3
		int     tid;
		rf_get_threadid(tid);
		printf("[%d] ShutdownParityLogging\n", tid);
d759 2
a760 1
		RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, raidPtr->parityLogDiskQueue.mutex);
d764 1
a764 3
		int     tid;
		rf_get_threadid(tid);
		printf("[%d] ShutdownParityLogging done (thread completed)\n", tid);
d794 2
a795 1
	RF_ASSERT(address < raidPtr->regionInfo[regionID].parityStartAddr + raidPtr->regionInfo[regionID].numSectorsParity);
d811 2
a812 1
	RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
d817 2
a818 1
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
d833 2
a834 1
	RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
d841 2
a842 1
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
d863 2
a864 1
/* given a regionID, determine the physical disk address of the logged parity for that region */
d881 2
a882 1
/* given a logical RAID address, determine the participating disks in the stripe */
d890 4
a893 2
	RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, addr);
	RF_ParityLoggingConfigInfo_t *info = (RF_ParityLoggingConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
a926 1
	int     tid;
d951 3
a953 2
				if (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {	/* redirect to dist
											 * spare space */
d984 2
a985 2
				} else {	/* redirect to dedicated spare
						 * space */
d998 1
a998 2
							if (failedPDA == asmp->parityInfo->next) {	/* paranoid:  should
													 * never occur */
d1008 2
a1009 3
					rf_get_threadid(tid);
					printf("[%d] Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\n",
					    tid, type, or, oc, (long) oo, failedPDA->row, failedPDA->col, (long) failedPDA->startSector);
d1033 5
a1037 2
			if (((asmp->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||
			    (asmp->parityInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmp)) {
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylogging.c,v 1.1 1999/01/11 14:29:35 niklas Exp $	*/
/*	$NetBSD: rf_paritylogging.c,v 1.3 1999/02/05 00:06:14 oster Exp $	*/
d436 1
a436 1
	rc = RF_CREATE_THREAD(raidPtr->pLogDiskThreadHandle, rf_ParityLoggingDiskManager, raidPtr);
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylogging.c,v 1.1 1998/11/13 04:20:32 oster Exp $	*/
/*	$NetBSD: rf_paritylogging.c,v 1.1 1998/11/13 04:20:32 oster Exp $	*/
a29 159
/* :  
 * Log: rf_paritylogging.c,v 
 * Revision 1.42  1996/11/05 21:10:40  jimz
 * failed pda generalization
 *
 * Revision 1.41  1996/07/31  16:56:18  jimz
 * dataBytesPerStripe, sectorsPerDisk init arch-indep.
 *
 * Revision 1.40  1996/07/28  20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.39  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.38  1996/07/13  00:00:59  jimz
 * sanitized generalized reconstruction architecture
 * cleaned up head sep, rbuf problems
 *
 * Revision 1.37  1996/06/17  03:24:14  jimz
 * switch to new shutdown function typing
 *
 * Revision 1.36  1996/06/14  23:15:38  jimz
 * attempt to deal with thread GC problem
 *
 * Revision 1.35  1996/06/11  13:48:30  jimz
 * get it to compile in-kernel
 *
 * Revision 1.34  1996/06/11  10:16:35  jimz
 * Check return values on array configuration- back out if failed.
 * Reorder shutdown to avoid using deallocated resources.
 * Get rid of bogus join op in shutdown.
 *
 * Revision 1.33  1996/06/10  18:29:17  wvcii
 * fixed bug in rf_IdentifyStripeParityLogging
 * - added array initialization
 *
 * Revision 1.32  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.31  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.30  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.29  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.28  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.27  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.26  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.25  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.24  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.23  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.22  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.21  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.20  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.19  1996/05/20  16:16:30  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.18  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.17  1996/05/03  19:47:11  wvcii
 * added includes of new dag library
 *
 * Revision 1.16  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.15  1995/12/06  20:57:43  wvcii
 * added prototypes
 * reintegration of logs on shutdown now conditional on forceParityLogReint
 *
 * Revision 1.14  1995/11/30  16:06:42  wvcii
 * added copyright info
 *
 * Revision 1.13  1995/11/17  19:01:29  wvcii
 * added prototyping to MapParity
 *
 * Revision 1.12  1995/11/07  15:36:03  wvcii
 * changed ParityLoggingDagSelect prototype
 * function no longer returns numHdrSucc, numTermAnt
 *
 * Revision 1.11  1995/10/08  20:42:54  wvcii
 * lots of random debugging - debugging incomplete
 *
 * Revision 1.10  1995/09/07  01:26:55  jimz
 * Achive basic compilation in kernel. Kernel functionality
 * is not guaranteed at all, but it'll compile. Mostly. I hope.
 *
 * Revision 1.9  1995/09/06  19:21:17  wvcii
 * explicit shutdown (forced reintegration) for simulator version
 *
 * Revision 1.8  1995/07/08  18:19:16  rachad
 * Parity verifies can not be done in the simulator.
 *
 * Revision 1.7  1995/07/07  00:17:20  wvcii
 * this version free from deadlock, fails parity verification
 *
 * Revision 1.6  1995/06/23  13:39:59  robby
 * updeated to prototypes in rf_layout.h
 *
 * Revision 1.5  1995/06/09  13:14:56  wvcii
 * code is now nonblocking
 *
 * Revision 1.4  95/06/01  17:02:23  wvcii
 * code debug
 * 
 * Revision 1.3  95/05/31  13:08:57  wvcii
 * code debug
 * 
 * Revision 1.2  95/05/21  15:35:00  wvcii
 * code debug
 * 
 *
 *
 */
d59 3
a61 2
  RF_RowCol_t  **stripeIdentifier;  /* filled in at config time & used by IdentifyStripe */
} RF_ParityLoggingConfigInfo_t;
d63 1
a63 1
static void FreeRegionInfo(RF_Raid_t *raidPtr, RF_RegionId_t regionID);
d71 115
a185 117
int rf_ConfigureParityLogging(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
{
  int i, j, startdisk, rc;
  RF_SectorCount_t totalLogCapacity, fragmentation, lastRegionCapacity;
  RF_SectorCount_t parityBufferCapacity, maxRegionParityRange;
  RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
  RF_ParityLoggingConfigInfo_t *info;
  RF_ParityLog_t *l=NULL, *next;
  caddr_t lHeapPtr;

  /*
   * We create multiple entries on the shutdown list here, since
   * this configuration routine is fairly complicated in and of
   * itself, and this makes backing out of a failed configuration
   * much simpler.
   */

  raidPtr->numSectorsPerLog = RF_DEFAULT_NUM_SECTORS_PER_LOG;

  /* create a parity logging configuration structure */
  RF_MallocAndAdd(info, sizeof(RF_ParityLoggingConfigInfo_t), (RF_ParityLoggingConfigInfo_t *), raidPtr->cleanupList);
  if (info == NULL)
    return(ENOMEM);
  layoutPtr->layoutSpecificInfo = (void *) info;

  RF_ASSERT(raidPtr->numRow == 1);
  
  /* the stripe identifier must identify the disks in each stripe,
   * IN THE ORDER THAT THEY APPEAR IN THE STRIPE.
   */
  info->stripeIdentifier = rf_make_2d_array((raidPtr->numCol), (raidPtr->numCol), raidPtr->cleanupList);
  if (info->stripeIdentifier == NULL)
    return(ENOMEM);

  startdisk = 0;
  for (i=0; i<(raidPtr->numCol); i++)
    {
      for (j=0; j<(raidPtr->numCol); j++)
	{
	  info->stripeIdentifier[i][j] = (startdisk + j) % (raidPtr->numCol - 1);
	}
      if ((--startdisk) < 0)
	startdisk = raidPtr->numCol-1-1;
    }

  /* fill in the remaining layout parameters */
  layoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;
  layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;
  layoutPtr->numParityCol = 1;
  layoutPtr->numParityLogCol = 1;
  layoutPtr->numDataCol = raidPtr->numCol - layoutPtr->numParityCol - layoutPtr->numParityLogCol;
  layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
  layoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;
  raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;

  raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;

  /* configure parity log parameters

     parameter               comment/constraints
     ----------------        -------------------
   * numParityRegions        all regions (except possibly last) of equal size
   * totalInCoreLogCapacity  amount of memory in bytes available for in-core logs (default 1 MB)
   # numSectorsPerLog        capacity of an in-core log in sectors (1 disk track)
     numParityLogs           total number of in-core logs, should be at least numParityRegions
     regionLogCapacity       size of a region log (except possibly last one) in sectors
     totalLogCapacity        total amount of log space in sectors

   * denotes a user settable parameter.
   # logs are fixed to be the size of a disk track, value #defined in rf_paritylog.h

  */

  totalLogCapacity = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit * layoutPtr->numParityLogCol;
  raidPtr->regionLogCapacity = totalLogCapacity / rf_numParityRegions;
  if (rf_parityLogDebug)
    printf("bytes per sector %d\n", raidPtr->bytesPerSector);

  /* reduce fragmentation within a disk region by adjusting the number of regions
     in an attempt to allow an integral number of logs to fit into a disk region */
  fragmentation = raidPtr->regionLogCapacity % raidPtr->numSectorsPerLog;
  if (fragmentation > 0)
    for (i = 1; i < (raidPtr->numSectorsPerLog / 2); i++)
      {
	if (((totalLogCapacity / (rf_numParityRegions + i)) % raidPtr->numSectorsPerLog) < fragmentation)
	  {
	    rf_numParityRegions++;
	    raidPtr->regionLogCapacity = totalLogCapacity / rf_numParityRegions;
	    fragmentation = raidPtr->regionLogCapacity % raidPtr->numSectorsPerLog;
	  }
	if (((totalLogCapacity / (rf_numParityRegions - i)) % raidPtr->numSectorsPerLog) < fragmentation)
	  {
	    rf_numParityRegions--;
	    raidPtr->regionLogCapacity = totalLogCapacity / rf_numParityRegions;
	    fragmentation = raidPtr->regionLogCapacity % raidPtr->numSectorsPerLog;
	  }
      }
  /* ensure integral number of regions per log */
  raidPtr->regionLogCapacity = (raidPtr->regionLogCapacity / raidPtr->numSectorsPerLog) * raidPtr->numSectorsPerLog;

  raidPtr->numParityLogs = rf_totalInCoreLogCapacity / (raidPtr->bytesPerSector * raidPtr->numSectorsPerLog);
  /* to avoid deadlock, must ensure that enough logs exist for each region to have one simultaneously */
  if (raidPtr->numParityLogs < rf_numParityRegions)
    raidPtr->numParityLogs = rf_numParityRegions;

  /* create region information structs */
  RF_Malloc(raidPtr->regionInfo, (rf_numParityRegions * sizeof(RF_RegionInfo_t)), (RF_RegionInfo_t *));
  if (raidPtr->regionInfo == NULL)
    return(ENOMEM);

  /* last region may not be full capacity */
  lastRegionCapacity = raidPtr->regionLogCapacity;
  while ((rf_numParityRegions - 1) * raidPtr->regionLogCapacity + lastRegionCapacity > totalLogCapacity)
    lastRegionCapacity = lastRegionCapacity - raidPtr->numSectorsPerLog;
d187 2
a188 2
  raidPtr->regionParityRange = raidPtr->sectorsPerDisk / rf_numParityRegions;
  maxRegionParityRange = raidPtr->regionParityRange;
d194 255
a448 283
  /* build pool of unused parity logs */
  RF_Malloc(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector, (caddr_t));
  if (raidPtr->parityLogBufferHeap == NULL)
    return(ENOMEM);
  lHeapPtr = raidPtr->parityLogBufferHeap;
  rc = rf_mutex_init(&raidPtr->parityLogPool.mutex);
  if (rc) {
    RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
    return(ENOMEM);
  }
  for (i = 0; i < raidPtr->numParityLogs; i++)
    {
      if (i == 0)
	{
	  RF_Calloc(raidPtr->parityLogPool.parityLogs, 1, sizeof(RF_ParityLog_t), (RF_ParityLog_t *));
          if (raidPtr->parityLogPool.parityLogs == NULL) {
            RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
            return(ENOMEM);
          }
	  l = raidPtr->parityLogPool.parityLogs;
	}
      else
	{
	  RF_Calloc(l->next, 1, sizeof(RF_ParityLog_t), (RF_ParityLog_t *));
          if (l->next == NULL) {
            RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
            for(l=raidPtr->parityLogPool.parityLogs;l;l=next) {
              next = l->next;
              if (l->records)
                RF_Free(l->records, (raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t)));
              RF_Free(l, sizeof(RF_ParityLog_t));
            }
            return(ENOMEM);
          }
	  l = l->next;
	}
      l->bufPtr = lHeapPtr;
      lHeapPtr += raidPtr->numSectorsPerLog * raidPtr->bytesPerSector;
      RF_Malloc(l->records, (raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t)), (RF_ParityLogRecord_t *));
      if (l->records == NULL) {
        RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
        for(l=raidPtr->parityLogPool.parityLogs;l;l=next) {
          next = l->next;
          if (l->records)
            RF_Free(l->records, (raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t)));
          RF_Free(l, sizeof(RF_ParityLog_t));
        }
        return(ENOMEM);
      }
    }
  rc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingPool, raidPtr);
  if (rc) {
    RF_ERRORMSG3("Unable to create shutdown entry file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    rf_ShutdownParityLoggingPool(raidPtr);
    return(rc);
  }

  /* build pool of region buffers */
  rc = rf_mutex_init(&raidPtr->regionBufferPool.mutex);
  if (rc) {
    RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    return(ENOMEM);
  }
  rc = rf_cond_init(&raidPtr->regionBufferPool.cond);
  if (rc) {
    RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    rf_mutex_destroy(&raidPtr->regionBufferPool.mutex);
    return(ENOMEM);
  }
  raidPtr->regionBufferPool.bufferSize = raidPtr->regionLogCapacity * raidPtr->bytesPerSector;
  printf("regionBufferPool.bufferSize %d\n",raidPtr->regionBufferPool.bufferSize);
  raidPtr->regionBufferPool.totalBuffers = 1;  /* for now, only one region at a time may be reintegrated */
  raidPtr->regionBufferPool.availableBuffers = raidPtr->regionBufferPool.totalBuffers;
  raidPtr->regionBufferPool.availBuffersIndex = 0;
  raidPtr->regionBufferPool.emptyBuffersIndex = 0;
  RF_Malloc(raidPtr->regionBufferPool.buffers, raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t), (caddr_t *));
  if (raidPtr->regionBufferPool.buffers == NULL) {
    rf_mutex_destroy(&raidPtr->regionBufferPool.mutex);
    rf_cond_destroy(&raidPtr->regionBufferPool.cond);
    return(ENOMEM);
  }
  for (i = 0; i < raidPtr->regionBufferPool.totalBuffers; i++) {
    RF_Malloc(raidPtr->regionBufferPool.buffers[i], raidPtr->regionBufferPool.bufferSize * sizeof(char), (caddr_t));
    if (raidPtr->regionBufferPool.buffers == NULL) {
      rf_mutex_destroy(&raidPtr->regionBufferPool.mutex);
      rf_cond_destroy(&raidPtr->regionBufferPool.cond);
      for(j=0;j<i;j++) {
        RF_Free(raidPtr->regionBufferPool.buffers[i], raidPtr->regionBufferPool.bufferSize * sizeof(char));
      }
      RF_Free(raidPtr->regionBufferPool.buffers, raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t));
      return(ENOMEM);
    }
    printf("raidPtr->regionBufferPool.buffers[%d] = %lx\n", i, 
	   (long)raidPtr->regionBufferPool.buffers[i]);
  }
  rc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingRegionBufferPool, raidPtr);
  if (rc) {
    RF_ERRORMSG3("Unable to create shutdown entry file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    rf_ShutdownParityLoggingRegionBufferPool(raidPtr);
    return(rc);
  }

  /* build pool of parity buffers */
  parityBufferCapacity = maxRegionParityRange;
  rc = rf_mutex_init(&raidPtr->parityBufferPool.mutex);
  if (rc) {
    RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    return(rc);
  }
  rc = rf_cond_init(&raidPtr->parityBufferPool.cond);
  if (rc) {
    RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    rf_mutex_destroy(&raidPtr->parityBufferPool.mutex);
    return(ENOMEM);
  }
  raidPtr->parityBufferPool.bufferSize = parityBufferCapacity * raidPtr->bytesPerSector;
  printf("parityBufferPool.bufferSize %d\n",raidPtr->parityBufferPool.bufferSize);
  raidPtr->parityBufferPool.totalBuffers = 1;  /* for now, only one region at a time may be reintegrated */
  raidPtr->parityBufferPool.availableBuffers = raidPtr->parityBufferPool.totalBuffers;
  raidPtr->parityBufferPool.availBuffersIndex = 0;
  raidPtr->parityBufferPool.emptyBuffersIndex = 0;
  RF_Malloc(raidPtr->parityBufferPool.buffers, raidPtr->parityBufferPool.totalBuffers * sizeof(caddr_t), (caddr_t *));
  if (raidPtr->parityBufferPool.buffers == NULL) {
    rf_mutex_destroy(&raidPtr->parityBufferPool.mutex);
    rf_cond_destroy(&raidPtr->parityBufferPool.cond);
    return(ENOMEM);
  }
  for (i = 0; i < raidPtr->parityBufferPool.totalBuffers; i++) {
    RF_Malloc(raidPtr->parityBufferPool.buffers[i], raidPtr->parityBufferPool.bufferSize * sizeof(char), (caddr_t));
    if (raidPtr->parityBufferPool.buffers == NULL) {
      rf_mutex_destroy(&raidPtr->parityBufferPool.mutex);
      rf_cond_destroy(&raidPtr->parityBufferPool.cond);
      for(j=0;j<i;j++) {
        RF_Free(raidPtr->parityBufferPool.buffers[i], raidPtr->regionBufferPool.bufferSize * sizeof(char));
      }
      RF_Free(raidPtr->parityBufferPool.buffers, raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t));
      return(ENOMEM);
    }
    printf("parityBufferPool.buffers[%d] = %lx\n", i, 
	   (long)raidPtr->parityBufferPool.buffers[i]);
  }
  rc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingParityBufferPool, raidPtr);
  if (rc) {
    RF_ERRORMSG3("Unable to create shutdown entry file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    rf_ShutdownParityLoggingParityBufferPool(raidPtr);
    return(rc);
  }

  /* initialize parityLogDiskQueue */
  rc = rf_create_managed_mutex(listp, &raidPtr->parityLogDiskQueue.mutex);
  if (rc) {
    RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    return(rc);
  }
  rc = rf_create_managed_cond(listp, &raidPtr->parityLogDiskQueue.cond);
  if (rc) {
    RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    return(rc);
  }
  raidPtr->parityLogDiskQueue.flushQueue = NULL;
  raidPtr->parityLogDiskQueue.reintQueue = NULL;
  raidPtr->parityLogDiskQueue.bufHead = NULL;
  raidPtr->parityLogDiskQueue.bufTail = NULL;
  raidPtr->parityLogDiskQueue.reintHead = NULL;
  raidPtr->parityLogDiskQueue.reintTail = NULL;
  raidPtr->parityLogDiskQueue.logBlockHead = NULL;
  raidPtr->parityLogDiskQueue.logBlockTail = NULL;
  raidPtr->parityLogDiskQueue.reintBlockHead = NULL;
  raidPtr->parityLogDiskQueue.reintBlockTail = NULL;
  raidPtr->parityLogDiskQueue.freeDataList = NULL;
  raidPtr->parityLogDiskQueue.freeCommonList = NULL;

  rc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingDiskQueue, raidPtr);
  if (rc) {
    RF_ERRORMSG3("Unable to create shutdown entry file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    return(rc);
  }

  for (i = 0; i < rf_numParityRegions; i++)
    {
      rc = rf_mutex_init(&raidPtr->regionInfo[i].mutex);
      if (rc) {
        RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
          __LINE__, rc);
        for(j=0;j<i;j++)
          FreeRegionInfo(raidPtr, j);
        RF_Free(raidPtr->regionInfo, (rf_numParityRegions * sizeof(RF_RegionInfo_t)));
        return(ENOMEM);
      }
      rc = rf_mutex_init(&raidPtr->regionInfo[i].reintMutex);
      if (rc) {
        RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
          __LINE__, rc);
        rf_mutex_destroy(&raidPtr->regionInfo[i].mutex);
        for(j=0;j<i;j++)
          FreeRegionInfo(raidPtr, j);
        RF_Free(raidPtr->regionInfo, (rf_numParityRegions * sizeof(RF_RegionInfo_t)));
        return(ENOMEM);
      }
      raidPtr->regionInfo[i].reintInProgress = RF_FALSE;
      raidPtr->regionInfo[i].regionStartAddr = raidPtr->regionLogCapacity * i;
      raidPtr->regionInfo[i].parityStartAddr = raidPtr->regionParityRange * i;
      if (i < rf_numParityRegions - 1)
	{
	  raidPtr->regionInfo[i].capacity = raidPtr->regionLogCapacity;
	  raidPtr->regionInfo[i].numSectorsParity = raidPtr->regionParityRange;
	}
      else
	{
	  raidPtr->regionInfo[i].capacity = lastRegionCapacity;
	  raidPtr->regionInfo[i].numSectorsParity = raidPtr->sectorsPerDisk - raidPtr->regionParityRange * i;
	  if (raidPtr->regionInfo[i].numSectorsParity > maxRegionParityRange)
	    maxRegionParityRange = raidPtr->regionInfo[i].numSectorsParity;
	}
      raidPtr->regionInfo[i].diskCount = 0;
      RF_ASSERT(raidPtr->regionInfo[i].capacity + raidPtr->regionInfo[i].regionStartAddr <= totalLogCapacity);
      RF_ASSERT(raidPtr->regionInfo[i].parityStartAddr + raidPtr->regionInfo[i].numSectorsParity <= raidPtr->sectorsPerDisk);
      RF_Malloc(raidPtr->regionInfo[i].diskMap, (raidPtr->regionInfo[i].capacity * sizeof(RF_DiskMap_t)), (RF_DiskMap_t *));
      if (raidPtr->regionInfo[i].diskMap == NULL) {
        rf_mutex_destroy(&raidPtr->regionInfo[i].mutex);
        rf_mutex_destroy(&raidPtr->regionInfo[i].reintMutex);
        for(j=0;j<i;j++)
          FreeRegionInfo(raidPtr, j);
        RF_Free(raidPtr->regionInfo, (rf_numParityRegions * sizeof(RF_RegionInfo_t)));
        return(ENOMEM);
      }
      raidPtr->regionInfo[i].loggingEnabled = RF_FALSE;
      raidPtr->regionInfo[i].coreLog = NULL;
    }
  rc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingRegionInfo, raidPtr);
  if (rc) {
    RF_ERRORMSG3("Unable to create shutdown entry file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    rf_ShutdownParityLoggingRegionInfo(raidPtr);
    return(rc);
  }

  RF_ASSERT(raidPtr->parityLogDiskQueue.threadState == 0);
  raidPtr->parityLogDiskQueue.threadState = RF_PLOG_CREATED;
  rc = RF_CREATE_THREAD(raidPtr->pLogDiskThreadHandle, rf_ParityLoggingDiskManager, raidPtr);
  if (rc) {
    raidPtr->parityLogDiskQueue.threadState = 0;
    RF_ERRORMSG3("Unable to create parity logging disk thread file %s line %d rc=%d\n",
      __FILE__, __LINE__, rc);
    return(ENOMEM);
  }
  /* wait for thread to start */
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  while(!(raidPtr->parityLogDiskQueue.threadState&RF_PLOG_RUNNING)) {
    RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, raidPtr->parityLogDiskQueue.mutex);
  }
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);

  rc = rf_ShutdownCreate(listp, rf_ShutdownParityLogging, raidPtr);
  if (rc) {
    RF_ERRORMSG1("Got rc=%d adding parity logging shutdown event\n", rc);
    rf_ShutdownParityLogging(raidPtr);
    return(rc);
  }

  if (rf_parityLogDebug)
    {
      printf("                            size of disk log in sectors: %d\n", 
	     (int)totalLogCapacity);
      printf("                            total number of parity regions is %d\n", (int)rf_numParityRegions);
      printf("                            nominal sectors of log per parity region is %d\n", (int)raidPtr->regionLogCapacity);
      printf("                            nominal region fragmentation is %d sectors\n",(int)fragmentation);
      printf("                            total number of parity logs is %d\n", raidPtr->numParityLogs);
      printf("                            parity log size is %d sectors\n", raidPtr->numSectorsPerLog);
      printf("                            total in-core log space is %d bytes\n", (int) rf_totalInCoreLogCapacity);
    }
d450 17
a466 1
  rf_EnableParityLogging(raidPtr);
d468 1
a468 1
  return(0);
d471 17
a487 17
static void FreeRegionInfo(
  RF_Raid_t      *raidPtr,
  RF_RegionId_t   regionID)
{
  RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
  RF_Free(raidPtr->regionInfo[regionID].diskMap, (raidPtr->regionInfo[regionID].capacity * sizeof(RF_DiskMap_t)));
  if (!rf_forceParityLogReint && raidPtr->regionInfo[regionID].coreLog) {
    rf_ReleaseParityLogs(raidPtr, raidPtr->regionInfo[regionID].coreLog);
    raidPtr->regionInfo[regionID].coreLog = NULL;
  }
  else {
    RF_ASSERT(raidPtr->regionInfo[regionID].coreLog == NULL);
    RF_ASSERT(raidPtr->regionInfo[regionID].diskCount == 0);
  }
  RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
  rf_mutex_destroy(&raidPtr->regionInfo[regionID].mutex);
  rf_mutex_destroy(&raidPtr->regionInfo[regionID].reintMutex);
d491 17
a507 17
static void FreeParityLogQueue(
  RF_Raid_t            *raidPtr,
  RF_ParityLogQueue_t  *queue)
{
  RF_ParityLog_t *l1, *l2;

  RF_LOCK_MUTEX(queue->mutex);
  l1 = queue->parityLogs;
  while (l1)
    {
      l2 = l1;
      l1 = l2->next;
      RF_Free(l2->records, (raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t)));
      RF_Free(l2, sizeof(RF_ParityLog_t));
    }
  RF_UNLOCK_MUTEX(queue->mutex);
  rf_mutex_destroy(&queue->mutex);
d511 2
a512 1
static void FreeRegionBufferQueue(RF_RegionBufferQueue_t *queue)
d514 1
a514 1
  int i;
d516 45
a560 11
  RF_LOCK_MUTEX(queue->mutex);
  if (queue->availableBuffers != queue->totalBuffers)
    {
      printf("Attempt to free region queue which is still in use!\n");
      RF_ASSERT(0);
    }
  for (i = 0; i < queue->totalBuffers; i++)
    RF_Free(queue->buffers[i], queue->bufferSize);
  RF_Free(queue->buffers, queue->totalBuffers * sizeof(caddr_t));
  RF_UNLOCK_MUTEX(queue->mutex);
  rf_mutex_destroy(&queue->mutex);
d563 2
a564 1
static void rf_ShutdownParityLoggingRegionInfo(RF_ThreadArg_t arg)
d566 1
a566 2
  RF_Raid_t *raidPtr;
  RF_RegionId_t i;
d568 7
a574 11
  raidPtr = (RF_Raid_t *)arg;
  if (rf_parityLogDebug) {
    int tid;
    rf_get_threadid(tid);
    printf("[%d] ShutdownParityLoggingRegionInfo\n", tid);
  }
  /* free region information structs */
  for (i = 0; i < rf_numParityRegions; i++)
    FreeRegionInfo(raidPtr, i);
  RF_Free(raidPtr->regionInfo, (rf_numParityRegions * sizeof(raidPtr->regionInfo)));
  raidPtr->regionInfo = NULL;
d577 2
a578 1
static void rf_ShutdownParityLoggingPool(RF_ThreadArg_t arg)
d580 1
a580 1
  RF_Raid_t *raidPtr;
d582 7
a588 9
  raidPtr = (RF_Raid_t *)arg;
  if (rf_parityLogDebug) {
    int tid;
    rf_get_threadid(tid);
    printf("[%d] ShutdownParityLoggingPool\n", tid);
  }
  /* free contents of parityLogPool */
  FreeParityLogQueue(raidPtr, &raidPtr->parityLogPool);
  RF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * raidPtr->numSectorsPerLog * raidPtr->bytesPerSector);
d591 2
a592 1
static void rf_ShutdownParityLoggingRegionBufferPool(RF_ThreadArg_t arg)
d594 3
a596 1
  RF_Raid_t *raidPtr;
d598 22
a619 7
  raidPtr = (RF_Raid_t *)arg;
  if (rf_parityLogDebug) {
    int tid;
    rf_get_threadid(tid);
    printf("[%d] ShutdownParityLoggingRegionBufferPool\n", tid);
  }
  FreeRegionBufferQueue(&raidPtr->regionBufferPool);
d622 2
a623 1
static void rf_ShutdownParityLoggingParityBufferPool(RF_ThreadArg_t arg)
d625 1
a625 1
  RF_Raid_t *raidPtr;
d627 29
a655 7
  raidPtr = (RF_Raid_t *)arg;
  if (rf_parityLogDebug) {
    int tid;
    rf_get_threadid(tid);
    printf("[%d] ShutdownParityLoggingParityBufferPool\n", tid);
  }
  FreeRegionBufferQueue(&raidPtr->parityBufferPool);
d658 2
a659 1
static void rf_ShutdownParityLoggingDiskQueue(RF_ThreadArg_t arg)
d661 1
a661 28
  RF_ParityLogData_t *d;
  RF_CommonLogData_t *c;
  RF_Raid_t *raidPtr;

  raidPtr = (RF_Raid_t *)arg;
  if (rf_parityLogDebug) {
    int tid;
    rf_get_threadid(tid);
    printf("[%d] ShutdownParityLoggingDiskQueue\n", tid);
  }
  /* free disk manager stuff */
  RF_ASSERT(raidPtr->parityLogDiskQueue.bufHead == NULL);
  RF_ASSERT(raidPtr->parityLogDiskQueue.bufTail == NULL);
  RF_ASSERT(raidPtr->parityLogDiskQueue.reintHead == NULL);
  RF_ASSERT(raidPtr->parityLogDiskQueue.reintTail == NULL);
  while (raidPtr->parityLogDiskQueue.freeDataList)
    {
      d = raidPtr->parityLogDiskQueue.freeDataList;
      raidPtr->parityLogDiskQueue.freeDataList = raidPtr->parityLogDiskQueue.freeDataList->next;
      RF_Free(d, sizeof(RF_ParityLogData_t));
    }
  while (raidPtr->parityLogDiskQueue.freeCommonList)
    {
      c = raidPtr->parityLogDiskQueue.freeCommonList;
      rf_mutex_destroy(&c->mutex);
      raidPtr->parityLogDiskQueue.freeCommonList = raidPtr->parityLogDiskQueue.freeCommonList->next;
      RF_Free(c, sizeof(RF_CommonLogData_t));
    }
d664 2
a665 1
static void rf_ShutdownParityLogging(RF_ThreadArg_t arg)
d667 1
a667 41
  RF_Raid_t *raidPtr;

  raidPtr = (RF_Raid_t *)arg;
  if (rf_parityLogDebug) {
    int tid;
    rf_get_threadid(tid);
    printf("[%d] ShutdownParityLogging\n", tid);
  }
#ifndef SIMULATE
  /* shutdown disk thread */
  /* This has the desirable side-effect of forcing all regions to be
     reintegrated.  This is necessary since all parity log maps are
     currently held in volatile memory. */

  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  raidPtr->parityLogDiskQueue.threadState |= RF_PLOG_TERMINATE;
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  RF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);
  /*
   * pLogDiskThread will now terminate when queues are cleared
   * now wait for it to be done
   */
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  while(!(raidPtr->parityLogDiskQueue.threadState&RF_PLOG_SHUTDOWN)) {
    RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, raidPtr->parityLogDiskQueue.mutex);
  }
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
#else /* !SIMULATE */
  /* explicitly call shutdown routines which force reintegration */
  rf_ShutdownLogging(raidPtr);
#endif /* !SIMULATE */
  if (rf_parityLogDebug) {
    int tid;
    rf_get_threadid(tid);
    printf("[%d] ShutdownParityLogging done (thread completed)\n", tid);
  }
}

int rf_GetDefaultNumFloatingReconBuffersParityLogging(RF_Raid_t *raidPtr)
{
  return(20);
a668 6

RF_HeadSepLimit_t rf_GetDefaultHeadSepLimitParityLogging(RF_Raid_t *raidPtr)
{
  return(10);
}

d670 4
a673 3
RF_RegionId_t rf_MapRegionIDParityLogging(
  RF_Raid_t       *raidPtr,
  RF_SectorNum_t   address)
d675 1
a675 1
  RF_RegionId_t regionID;
d678 9
a686 10
  regionID = address / raidPtr->regionParityRange;
  if (regionID == rf_numParityRegions)
    {
      /* last region may be larger than other regions */
      regionID--;
    }
  RF_ASSERT(address >= raidPtr->regionInfo[regionID].parityStartAddr);
  RF_ASSERT(address < raidPtr->regionInfo[regionID].parityStartAddr + raidPtr->regionInfo[regionID].numSectorsParity);
  RF_ASSERT(regionID < rf_numParityRegions);
  return(regionID);
d691 16
a706 14
void rf_MapSectorParityLogging(
  RF_Raid_t         *raidPtr,
  RF_RaidAddr_t      raidSector,
  RF_RowCol_t       *row,
  RF_RowCol_t       *col,
  RF_SectorNum_t    *diskSector,
  int                remap)
{
  RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
  *row = 0;
  /* *col = (SUID % (raidPtr->numCol - raidPtr->Layout.numParityLogCol)); */
  *col = SUID % raidPtr->Layout.numDataCol;
  *diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d711 18
a728 15
void rf_MapParityParityLogging(
  RF_Raid_t       *raidPtr,
  RF_RaidAddr_t    raidSector,
  RF_RowCol_t     *row,
  RF_RowCol_t     *col,
  RF_SectorNum_t  *diskSector,
  int              remap)
{
  RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;

  *row = 0;
  /* *col = raidPtr->Layout.numDataCol-(SUID/raidPtr->Layout.numDataCol)%(raidPtr->numCol - raidPtr->Layout.numParityLogCol); */
  *col = raidPtr->Layout.numDataCol;
  *diskSector =(SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d733 12
a744 11
void rf_MapLogParityLogging(
  RF_Raid_t       *raidPtr,
  RF_RegionId_t    regionID,
  RF_SectorNum_t   regionOffset,
  RF_RowCol_t     *row,
  RF_RowCol_t     *col,
  RF_SectorNum_t  *startSector)
{
  *row = 0;
  *col = raidPtr->numCol - 1;
  *startSector = raidPtr->regionInfo[regionID].regionStartAddr + regionOffset;
d749 13
a761 12
void rf_MapRegionParity(
  RF_Raid_t         *raidPtr,
  RF_RegionId_t      regionID,
  RF_RowCol_t       *row,
  RF_RowCol_t       *col,
  RF_SectorNum_t    *startSector,
  RF_SectorCount_t  *numSector)
{
  *row = 0;
  *col = raidPtr->numCol - 2;
  *startSector = raidPtr->regionInfo[regionID].parityStartAddr;
  *numSector = raidPtr->regionInfo[regionID].numSectorsParity;
d766 11
a776 10
void rf_IdentifyStripeParityLogging(
  RF_Raid_t        *raidPtr,
  RF_RaidAddr_t     addr,
  RF_RowCol_t     **diskids,
  RF_RowCol_t      *outRow)
{
  RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, addr);
  RF_ParityLoggingConfigInfo_t *info = (RF_ParityLoggingConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
  *outRow = 0;
  *diskids = info->stripeIdentifier[ stripeID % raidPtr->numCol ];
d780 6
a785 5
void rf_MapSIDToPSIDParityLogging(
  RF_RaidLayout_t    *layoutPtr,
  RF_StripeNum_t      stripeID,
  RF_StripeNum_t     *psID,
  RF_ReconUnitNum_t  *which_ru)
d787 2
a788 2
  *which_ru = 0;
  *psID = stripeID;
d796 134
a929 127
void rf_ParityLoggingDagSelect(
  RF_Raid_t             *raidPtr,
  RF_IoType_t            type,
  RF_AccessStripeMap_t  *asmp,
  RF_VoidFuncPtr        *createFunc)
{
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  RF_PhysDiskAddr_t *failedPDA=NULL;
  RF_RowCol_t frow, fcol;
  RF_RowStatus_t rstat;
  int prior_recon;
  int tid;
  
  RF_ASSERT(RF_IO_IS_R_OR_W(type));

  if (asmp->numDataFailed + asmp->numParityFailed > 1) {
    RF_ERRORMSG("Multiple disks failed in a single group!  Aborting I/O operation.\n");
    /* *infoFunc = */ *createFunc = NULL;
    return;
  } else if (asmp->numDataFailed + asmp->numParityFailed == 1) {
    
    /* if under recon & already reconstructed, redirect the access to the spare drive 
     * and eliminate the failure indication 
     */
    failedPDA = asmp->failedPDAs[0];
    frow = failedPDA->row; fcol = failedPDA->col;
    rstat = raidPtr->status[failedPDA->row];
    prior_recon = (rstat == rf_rs_reconfigured) || (
      (rstat == rf_rs_reconstructing) ?
      rf_CheckRUReconstructed(raidPtr->reconControl[frow]->reconMap, failedPDA->startSector) : 0
      );
    if (prior_recon) {
      RF_RowCol_t or = failedPDA->row,oc=failedPDA->col;
      RF_SectorNum_t oo=failedPDA->startSector;
      if (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {         /* redirect to dist spare space */

        if (failedPDA == asmp->parityInfo) {

          /* parity has failed */
          (layoutPtr->map->MapParity)(raidPtr, failedPDA->raidAddress, &failedPDA->row, 
                                      &failedPDA->col, &failedPDA->startSector, RF_REMAP);

          if (asmp->parityInfo->next) {                          /* redir 2nd component, if any */
            RF_PhysDiskAddr_t *p = asmp->parityInfo->next;
            RF_SectorNum_t SUoffs = p->startSector % layoutPtr->sectorsPerStripeUnit;
            p->row = failedPDA->row;
            p->col = failedPDA->col;
            p->startSector = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->startSector) +
                             SUoffs;    /* cheating:  startSector is not really a RAID address */
          }

        } else if (asmp->parityInfo->next && failedPDA == asmp->parityInfo->next) {
          RF_ASSERT(0);            /* should not ever happen */
        } else {

          /* data has failed */
          (layoutPtr->map->MapSector)(raidPtr, failedPDA->raidAddress, &failedPDA->row, 
                                      &failedPDA->col, &failedPDA->startSector, RF_REMAP);

        }

      } else {                                                 /* redirect to dedicated spare space */

        failedPDA->row = raidPtr->Disks[frow][fcol].spareRow;
        failedPDA->col = raidPtr->Disks[frow][fcol].spareCol;

        /* the parity may have two distinct components, both of which may need to be redirected */
        if (asmp->parityInfo->next) {
          if (failedPDA == asmp->parityInfo) {
            failedPDA->next->row = failedPDA->row;
            failedPDA->next->col = failedPDA->col;
          } else if (failedPDA == asmp->parityInfo->next) {    /* paranoid:  should never occur */
            asmp->parityInfo->row = failedPDA->row;
            asmp->parityInfo->col = failedPDA->col;
          }
        }
      }

      RF_ASSERT(failedPDA->col != -1);
       
      if (rf_dagDebug || rf_mapDebug) {
        rf_get_threadid(tid);
        printf("[%d] Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\n",
             tid,type,or,oc,(long)oo,failedPDA->row,failedPDA->col,(long)failedPDA->startSector);
      }
      
      asmp->numDataFailed = asmp->numParityFailed = 0;
    }

  }

  
  if (type == RF_IO_TYPE_READ) {

    if (asmp->numDataFailed == 0)
      *createFunc = (RF_VoidFuncPtr)rf_CreateFaultFreeReadDAG;
    else
      *createFunc = (RF_VoidFuncPtr)rf_CreateRaidFiveDegradedReadDAG;
    
  }
  else {

    
    /* if mirroring, always use large writes.  If the access requires two distinct parity updates,
     * always do a small write.  If the stripe contains a failure but the access does not, do a
     * small write.
     * The first conditional (numStripeUnitsAccessed <= numDataCol/2) uses a less-than-or-equal
     * rather than just a less-than because when G is 3 or 4, numDataCol/2 is 1, and I want
     * single-stripe-unit updates to use just one disk.
     */
    if ( (asmp->numDataFailed + asmp->numParityFailed) == 0) {
      if (((asmp->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol!=1)) ||
          (asmp->parityInfo->next!=NULL) || rf_CheckStripeForFailures(raidPtr, asmp)) {
	*createFunc = (RF_VoidFuncPtr)rf_CreateParityLoggingSmallWriteDAG;
      }
      else
        *createFunc = (RF_VoidFuncPtr)rf_CreateParityLoggingLargeWriteDAG;
    } 
    else
      if (asmp->numParityFailed == 1)
        *createFunc = (RF_VoidFuncPtr)rf_CreateNonRedundantWriteDAG;
      else
        if (asmp->numStripeUnitsAccessed != 1 && failedPDA->numSector != layoutPtr->sectorsPerStripeUnit)
          *createFunc = NULL;
        else
          *createFunc = (RF_VoidFuncPtr)rf_CreateDegradedWriteDAG;
  }
d931 1
a931 2

#endif /* RF_INCLUDE_PARITYLOGGING > 0 */
@

