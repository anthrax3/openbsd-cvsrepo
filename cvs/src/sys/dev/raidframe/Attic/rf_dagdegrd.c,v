head	1.8;
access;
symbols
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.18
	OPENBSD_5_0:1.7.0.16
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.14
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.12
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.8
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.10
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.16
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.14
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.12
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.10
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.7;

1.7
date	2007.11.25.16.40.04;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.09.22.10.05;	author mk;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.11.18.02.20;	author peter;	state Exp;
branches
	1.4.2.1
	1.4.12.1;
next	1.3;

1.3
date	2000.01.07.14.50.20;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.29;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.06;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.4.12.1
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_dagdegrd.c,v 1.7 2007/11/25 16:40:04 jmc Exp $	*/
/*	$NetBSD: rf_dagdegrd.c,v 1.5 2000/01/07 03:40:57 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland, Daniel Stodolsky, William V. Courtright II
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * rf_dagdegrd.c
 *
 * Code for creating degraded read DAGs.
 */

#include "rf_types.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagutils.h"
#include "rf_dagfuncs.h"
#include "rf_debugMem.h"
#include "rf_memchunk.h"
#include "rf_general.h"
#include "rf_dagdegrd.h"


/*****************************************************************************
 *
 * General comments on DAG creation:
 *
 * All DAGs in this file use roll-away error recovery. Each DAG has a single
 * commit node, usually called "Cmt". If an error occurs before the Cmt node
 * is reached, the execution engine will halt forward execution and work
 * backward through the graph, executing the undo functions. Assuming that
 * each node in the graph prior to the Cmt node are undoable and atomic - or -
 * does not make changes to permanent state, the graph will fail atomically.
 * If an error occurs after the Cmt node executes, the engine will roll-forward
 * through the graph, blindly executing nodes until it reaches the end.
 * If a graph reaches the end, it is assumed to have completed successfully.
 *
 * A graph has only 1 Cmt node.
 *
 *****************************************************************************/


/*****************************************************************************
 *
 * The following wrappers map the standard DAG creation interface to the
 * DAG creation routines. Additionally, these wrappers enable experimentation
 * with new DAG structures by providing an extra level of indirection, allowing
 * the DAG creation routines to be replaced at this single point.
 *
 *****************************************************************************/

void
rf_CreateRaidFiveDegradedReadDAG(
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList)
{
	rf_CreateDegradedReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
	    &rf_xorRecoveryFuncs);
}


/*****************************************************************************
 *
 * DAG creation code begins here.
 *
 *****************************************************************************/


/*****************************************************************************
 * Create a degraded read DAG for RAID level 1.
 *
 * Hdr -> Nil -> R(p/s)d -> Commit -> Trm
 *
 * The "Rd" node reads data from the surviving disk in the mirror pair.
 *   Rpd - read of primary copy
 *   Rsd - read of secondary copy
 *
 * Parameters:	raidPtr	  - description of the physical array
 *		asmap	  - logical & physical addresses for this access
 *		bp	  - buffer ptr (for holding write data)
 *		flags	  - general flags (e.g. disk locking)
 *		allocList - list of memory allocated in DAG creation
 *****************************************************************************/

void
rf_CreateRaidOneDegradedReadDAG(
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList)
{
	RF_DagNode_t *nodes, *rdNode, *blockNode, *commitNode, *termNode;
	RF_StripeNum_t parityStripeID;
	RF_ReconUnitNum_t which_ru;
	RF_PhysDiskAddr_t *pda;
	int useMirror, i;

	useMirror = 0;
	parityStripeID = rf_RaidAddressToParityStripeID(&(raidPtr->Layout),
	    asmap->raidAddress, &which_ru);
	if (rf_dagDebug) {
		printf("[Creating RAID level 1 degraded read DAG]\n");
	}
	dag_h->creator = "RaidOneDegradedReadDAG";
	/* Alloc the Wnd nodes and the Wmir node. */
	if (asmap->numDataFailed == 0)
		useMirror = RF_FALSE;
	else
		useMirror = RF_TRUE;

	/* Total number of nodes = 1 + (block + commit + terminator). */
	RF_CallocAndAdd(nodes, 4, sizeof(RF_DagNode_t), (RF_DagNode_t *),
	    allocList);
	i = 0;
	rdNode = &nodes[i];
	i++;
	blockNode = &nodes[i];
	i++;
	commitNode = &nodes[i];
	i++;
	termNode = &nodes[i];
	i++;

	/*
	 * This dag can not commit until the commit node is reached. Errors
	 * prior to the commit point imply the dag has failed and must be
	 * retried.
	 */
	dag_h->numCommitNodes = 1;
	dag_h->numCommits = 0;
	dag_h->numSuccedents = 1;

	/* Initialize the block, commit, and terminator nodes. */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);

	pda = asmap->physInfo;
	RF_ASSERT(pda != NULL);
	/* parityInfo must describe entire parity unit. */
	RF_ASSERT(asmap->parityInfo->next == NULL);

	/* Initialize the data node. */
	if (!useMirror) {
		/* Read primary copy of data. */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rpd", allocList);
		rdNode->params[0].p = pda;
		rdNode->params[1].p = pda->bufPtr;
		rdNode->params[2].v = parityStripeID;
		rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
		    0, 0, which_ru);
	} else {
		/* Read secondary copy of data. */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rsd", allocList);
		rdNode->params[0].p = asmap->parityInfo;
		rdNode->params[1].p = pda->bufPtr;
		rdNode->params[2].v = parityStripeID;
		rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
		    0, 0, which_ru);
	}

	/* Connect header to block node. */
	RF_ASSERT(dag_h->numSuccedents == 1);
	RF_ASSERT(blockNode->numAntecedents == 0);
	dag_h->succedents[0] = blockNode;

	/* Connect block node to rdnode. */
	RF_ASSERT(blockNode->numSuccedents == 1);
	RF_ASSERT(rdNode->numAntecedents == 1);
	blockNode->succedents[0] = rdNode;
	rdNode->antecedents[0] = blockNode;
	rdNode->antType[0] = rf_control;

	/* Connect rdnode to commit node. */
	RF_ASSERT(rdNode->numSuccedents == 1);
	RF_ASSERT(commitNode->numAntecedents == 1);
	rdNode->succedents[0] = commitNode;
	commitNode->antecedents[0] = rdNode;
	commitNode->antType[0] = rf_control;

	/* Connect commit node to terminator. */
	RF_ASSERT(commitNode->numSuccedents == 1);
	RF_ASSERT(termNode->numAntecedents == 1);
	RF_ASSERT(termNode->numSuccedents == 0);
	commitNode->succedents[0] = termNode;
	termNode->antecedents[0] = commitNode;
	termNode->antType[0] = rf_control;
}


/*****************************************************************************
 *
 * Create a DAG to perform a degraded-mode read of data within one stripe.
 * This DAG is as follows:
 *
 * Hdr -> Block -> Rud -> Xor -> Cmt -> T
 *		-> Rrd ->
 *		-> Rp -->
 *
 * Each R node is a successor of the L node.
 * One successor arc from each R node goes to C, and the other to X.
 * There is one Rud for each chunk of surviving user data requested by the
 * user, and one Rrd for each chunk of surviving user data _not_ being read by
 * the user.
 * R = read, ud = user data, rd = recovery (surviving) data, p = parity
 * X = XOR, C = Commit, T = terminate
 *
 * The block node guarantees a single source node.
 *
 * Note:  The target buffer for the XOR node is set to the actual user buffer
 * where the failed data is supposed to end up. This buffer is zero'd by the
 * code here. Thus, if you create a degraded read dag, use it, and then
 * re-use, you have to be sure to zero the target buffer prior to the re-use.
 *
 * The recfunc argument at the end specifies the name and function used for
 * the redundancy recovery function.
 *
 *****************************************************************************/

void
rf_CreateDegradedReadDAG(
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList,
    RF_RedFuncs_t		*recFunc)
{
	RF_DagNode_t *nodes, *rudNodes, *rrdNodes, *xorNode, *blockNode;
	RF_DagNode_t *commitNode, *rpNode, *termNode;
	int nNodes, nRrdNodes, nRudNodes, nXorBufs, i;
	int j, paramNum;
	RF_SectorCount_t sectorsPerSU;
	RF_ReconUnitNum_t which_ru;
	char *overlappingPDAs;		/* A temporary array of flags. */
	RF_AccessStripeMapHeader_t *new_asm_h[2];
	RF_PhysDiskAddr_t *pda, *parityPDA;
	RF_StripeNum_t parityStripeID;
	RF_PhysDiskAddr_t *failedPDA;
	RF_RaidLayout_t *layoutPtr;
	char *rpBuf;

	layoutPtr = &(raidPtr->Layout);
	/*
	 * failedPDA points to the pda within the asm that targets
	 * the failed disk.
	 */
	failedPDA = asmap->failedPDAs[0];
	parityStripeID = rf_RaidAddressToParityStripeID(layoutPtr,
	    asmap->raidAddress, &which_ru);
	sectorsPerSU = layoutPtr->sectorsPerStripeUnit;

	if (rf_dagDebug) {
		printf("[Creating degraded read DAG]\n");
	}
	RF_ASSERT(asmap->numDataFailed == 1);
	dag_h->creator = "DegradedReadDAG";

	/*
	 * Generate two ASMs identifying the surviving data we need
	 * in order to recover the lost data.
	 */

	/* overlappingPDAs array must be zero'd. */
	RF_Calloc(overlappingPDAs, asmap->numStripeUnitsAccessed,
	    sizeof(char), (char *));
	rf_GenerateFailedAccessASMs(raidPtr, asmap, failedPDA, dag_h,
	    new_asm_h, &nXorBufs, &rpBuf, overlappingPDAs, allocList);

	/*
	 * Create all the nodes at once.
	 *
	 * -1 because no access is generated for the failed pda.
	 */
	nRudNodes = asmap->numStripeUnitsAccessed - 1;
	nRrdNodes = ((new_asm_h[0]) ?
	    new_asm_h[0]->stripeMap->numStripeUnitsAccessed : 0) +
	    ((new_asm_h[1]) ?
	    new_asm_h[1]->stripeMap->numStripeUnitsAccessed : 0);
	nNodes = 5 + nRudNodes + nRrdNodes;	/*
						 * lock, unlock, xor, Rp,
						 * Rud, Rrd
						 */
	RF_CallocAndAdd(nodes, nNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *),
	    allocList);
	i = 0;
	blockNode = &nodes[i];
	i++;
	commitNode = &nodes[i];
	i++;
	xorNode = &nodes[i];
	i++;
	rpNode = &nodes[i];
	i++;
	termNode = &nodes[i];
	i++;
	rudNodes = &nodes[i];
	i += nRudNodes;
	rrdNodes = &nodes[i];
	i += nRrdNodes;
	RF_ASSERT(i == nNodes);

	/* Initialize nodes. */
	dag_h->numCommitNodes = 1;
	dag_h->numCommits = 0;
	/*
	 * This dag can not commit until the commit node is reached.
	 * Errors prior to the commit point imply the dag has failed.
	 */
	dag_h->numSuccedents = 1;

	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nRudNodes + nRrdNodes + 1, 0, 0, 0,
	    dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
	rf_InitNode(xorNode, rf_wait, RF_FALSE, recFunc->simple,
	    rf_NullNodeUndoFunc, NULL, 1, nRudNodes + nRrdNodes + 1,
	    2 * nXorBufs + 2, 1, dag_h, recFunc->SimpleName, allocList);

	/* Fill in the Rud nodes. */
	for (pda = asmap->physInfo, i = 0; i < nRudNodes;
	     i++, pda = pda->next) {
		if (pda == failedPDA) {
			i--;
			continue;
		}
		rf_InitNode(&rudNodes[i], rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rud", allocList);
		RF_ASSERT(pda);
		rudNodes[i].params[0].p = pda;
		rudNodes[i].params[1].p = pda->bufPtr;
		rudNodes[i].params[2].v = parityStripeID;
		rudNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
	}

	/* Fill in the Rrd nodes. */
	i = 0;
	if (new_asm_h[0]) {
		for (pda = new_asm_h[0]->stripeMap->physInfo;
		     i < new_asm_h[0]->stripeMap->numStripeUnitsAccessed;
		     i++, pda = pda->next) {
			rf_InitNode(&rrdNodes[i], rf_wait, RF_FALSE,
			    rf_DiskReadFunc, rf_DiskReadUndoFunc,
			    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
			    "Rrd", allocList);
			RF_ASSERT(pda);
			rrdNodes[i].params[0].p = pda;
			rrdNodes[i].params[1].p = pda->bufPtr;
			rrdNodes[i].params[2].v = parityStripeID;
			rrdNodes[i].params[3].v =
			    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0,
			    which_ru);
		}
	}
	if (new_asm_h[1]) {
		for (j = 0, pda = new_asm_h[1]->stripeMap->physInfo;
		    j < new_asm_h[1]->stripeMap->numStripeUnitsAccessed;
		    j++, pda = pda->next) {
			rf_InitNode(&rrdNodes[i + j], rf_wait, RF_FALSE,
			    rf_DiskReadFunc, rf_DiskReadUndoFunc,
			    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
			    "Rrd", allocList);
			RF_ASSERT(pda);
			rrdNodes[i + j].params[0].p = pda;
			rrdNodes[i + j].params[1].p = pda->bufPtr;
			rrdNodes[i + j].params[2].v = parityStripeID;
			rrdNodes[i + j].params[3].v =
			    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0,
			    which_ru);
		}
	}
	/* Make a PDA for the parity unit. */
	RF_MallocAndAdd(parityPDA, sizeof(RF_PhysDiskAddr_t),
	    (RF_PhysDiskAddr_t *), allocList);
	parityPDA->row = asmap->parityInfo->row;
	parityPDA->col = asmap->parityInfo->col;
	parityPDA->startSector = ((asmap->parityInfo->startSector /
	    sectorsPerSU) * sectorsPerSU) +
	    (failedPDA->startSector % sectorsPerSU);
	parityPDA->numSector = failedPDA->numSector;

	/* Initialize the Rp node. */
	rf_InitNode(rpNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
	    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
	    "Rp ", allocList);
	rpNode->params[0].p = parityPDA;
	rpNode->params[1].p = rpBuf;
	rpNode->params[2].v = parityStripeID;
	rpNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0,
	    which_ru);

	/*
	 * The last and nastiest step is to assign all
	 * the parameters of the Xor node.
	 */
	paramNum = 0;
	for (i = 0; i < nRrdNodes; i++) {
		/* All the Rrd nodes need to be xored together. */
		xorNode->params[paramNum++] = rrdNodes[i].params[0];
		xorNode->params[paramNum++] = rrdNodes[i].params[1];
	}
	for (i = 0; i < nRudNodes; i++) {
		/* Any Rud nodes that overlap the failed access need to be
		 * xored in. */
		if (overlappingPDAs[i]) {
			RF_MallocAndAdd(pda, sizeof(RF_PhysDiskAddr_t),
			    (RF_PhysDiskAddr_t *), allocList);
			bcopy((char *) rudNodes[i].params[0].p, (char *) pda,
			    sizeof(RF_PhysDiskAddr_t));
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda,
			    RF_RESTRICT_DOBUFFER, 0);
			xorNode->params[paramNum++].p = pda;
			xorNode->params[paramNum++].p = pda->bufPtr;
		}
	}
	RF_Free(overlappingPDAs, asmap->numStripeUnitsAccessed * sizeof(char));

	/* Install parity pda as last set of params to be xor'd. */
	xorNode->params[paramNum++].p = parityPDA;
	xorNode->params[paramNum++].p = rpBuf;

	/*
	 * The last 2 params to the recovery xor node are
	 * the failed PDA and the raidPtr.
	 */
	xorNode->params[paramNum++].p = failedPDA;
	xorNode->params[paramNum++].p = raidPtr;
	RF_ASSERT(paramNum == 2 * nXorBufs + 2);

	/*
	 * The xor node uses results[0] as the target buffer.
	 * Set pointer and zero the buffer. In the kernel, this
	 * may be a user buffer in which case we have to remap it.
	 */
	xorNode->results[0] = failedPDA->bufPtr;
	RF_BZERO(bp, failedPDA->bufPtr, rf_RaidAddressToByte(raidPtr,
	    failedPDA->numSector));

	/* Connect nodes to form graph. */
	/* Connect the header to the block node. */
	RF_ASSERT(dag_h->numSuccedents == 1);
	RF_ASSERT(blockNode->numAntecedents == 0);
	dag_h->succedents[0] = blockNode;

	/* Connect the block node to the read nodes. */
	RF_ASSERT(blockNode->numSuccedents == (1 + nRrdNodes + nRudNodes));
	RF_ASSERT(rpNode->numAntecedents == 1);
	blockNode->succedents[0] = rpNode;
	rpNode->antecedents[0] = blockNode;
	rpNode->antType[0] = rf_control;
	for (i = 0; i < nRrdNodes; i++) {
		RF_ASSERT(rrdNodes[i].numSuccedents == 1);
		blockNode->succedents[1 + i] = &rrdNodes[i];
		rrdNodes[i].antecedents[0] = blockNode;
		rrdNodes[i].antType[0] = rf_control;
	}
	for (i = 0; i < nRudNodes; i++) {
		RF_ASSERT(rudNodes[i].numSuccedents == 1);
		blockNode->succedents[1 + nRrdNodes + i] = &rudNodes[i];
		rudNodes[i].antecedents[0] = blockNode;
		rudNodes[i].antType[0] = rf_control;
	}

	/* Connect the read nodes to the xor node. */
	RF_ASSERT(xorNode->numAntecedents == (1 + nRrdNodes + nRudNodes));
	RF_ASSERT(rpNode->numSuccedents == 1);
	rpNode->succedents[0] = xorNode;
	xorNode->antecedents[0] = rpNode;
	xorNode->antType[0] = rf_trueData;
	for (i = 0; i < nRrdNodes; i++) {
		RF_ASSERT(rrdNodes[i].numSuccedents == 1);
		rrdNodes[i].succedents[0] = xorNode;
		xorNode->antecedents[1 + i] = &rrdNodes[i];
		xorNode->antType[1 + i] = rf_trueData;
	}
	for (i = 0; i < nRudNodes; i++) {
		RF_ASSERT(rudNodes[i].numSuccedents == 1);
		rudNodes[i].succedents[0] = xorNode;
		xorNode->antecedents[1 + nRrdNodes + i] = &rudNodes[i];
		xorNode->antType[1 + nRrdNodes + i] = rf_trueData;
	}

	/* Connect the xor node to the commit node. */
	RF_ASSERT(xorNode->numSuccedents == 1);
	RF_ASSERT(commitNode->numAntecedents == 1);
	xorNode->succedents[0] = commitNode;
	commitNode->antecedents[0] = xorNode;
	commitNode->antType[0] = rf_control;

	/* Connect the termNode to the commit node. */
	RF_ASSERT(commitNode->numSuccedents == 1);
	RF_ASSERT(termNode->numAntecedents == 1);
	RF_ASSERT(termNode->numSuccedents == 0);
	commitNode->succedents[0] = termNode;
	termNode->antType[0] = rf_control;
	termNode->antecedents[0] = commitNode;
}


/*****************************************************************************
 * Create a degraded read DAG for Chained Declustering.
 *
 * Hdr -> Nil -> R(p/s)d -> Cmt -> Trm
 *
 * The "Rd" node reads data from the surviving disk in the mirror pair
 *   Rpd - read of primary copy
 *   Rsd - read of secondary copy
 *
 * Parameters:  raidPtr	  - description of the physical array
 *		asmap	  - logical & physical addresses for this access
 *		bp	  - buffer ptr (for holding write data)
 *		flags	  - general flags (e.g. disk locking)
 *		allocList - list of memory allocated in DAG creation
 *****************************************************************************/

void
rf_CreateRaidCDegradedReadDAG(
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList
)
{
	RF_DagNode_t *nodes, *rdNode, *blockNode, *commitNode, *termNode;
	RF_StripeNum_t parityStripeID;
	int useMirror, i, shiftable;
	RF_ReconUnitNum_t which_ru;
	RF_PhysDiskAddr_t *pda;

	if ((asmap->numDataFailed + asmap->numParityFailed) == 0) {
		shiftable = RF_TRUE;
	} else {
		shiftable = RF_FALSE;
	}
	useMirror = 0;
	parityStripeID = rf_RaidAddressToParityStripeID(&(raidPtr->Layout),
	    asmap->raidAddress, &which_ru);

	if (rf_dagDebug) {
		printf("[Creating RAID C degraded read DAG]\n");
	}
	dag_h->creator = "RaidCDegradedReadDAG";
	/* Alloc the Wnd nodes and the Wmir node. */
	if (asmap->numDataFailed == 0)
		useMirror = RF_FALSE;
	else
		useMirror = RF_TRUE;

	/* total number of nodes = 1 + (block + commit + terminator) */
	RF_CallocAndAdd(nodes, 4, sizeof(RF_DagNode_t), (RF_DagNode_t *),
	    allocList);
	i = 0;
	rdNode = &nodes[i];
	i++;
	blockNode = &nodes[i];
	i++;
	commitNode = &nodes[i];
	i++;
	termNode = &nodes[i];
	i++;

	/*
	 * This dag can not commit until the commit node is reached.
	 * Errors prior to the commit point imply the dag has failed
	 * and must be retried.
	 */
	dag_h->numCommitNodes = 1;
	dag_h->numCommits = 0;
	dag_h->numSuccedents = 1;

	/* initialize the block, commit, and terminator nodes */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);

	pda = asmap->physInfo;
	RF_ASSERT(pda != NULL);
	/* ParityInfo must describe entire parity unit. */
	RF_ASSERT(asmap->parityInfo->next == NULL);

	/* Initialize the data node. */
	if (!useMirror) {
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rpd", allocList);
		if (shiftable && rf_compute_workload_shift(raidPtr, pda)) {
			/* Shift this read to the next disk in line. */
			rdNode->params[0].p = asmap->parityInfo;
			rdNode->params[1].p = pda->bufPtr;
			rdNode->params[2].v = parityStripeID;
			rdNode->params[3].v = RF_CREATE_PARAM3(
			    RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
		} else {
			/* Read primary copy. */
			rdNode->params[0].p = pda;
			rdNode->params[1].p = pda->bufPtr;
			rdNode->params[2].v = parityStripeID;
			rdNode->params[3].v = RF_CREATE_PARAM3(
			    RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
		}
	} else {
		/* Read secondary copy of data. */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rsd", allocList);
		rdNode->params[0].p = asmap->parityInfo;
		rdNode->params[1].p = pda->bufPtr;
		rdNode->params[2].v = parityStripeID;
		rdNode->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
	}

	/* Connect header to block node. */
	RF_ASSERT(dag_h->numSuccedents == 1);
	RF_ASSERT(blockNode->numAntecedents == 0);
	dag_h->succedents[0] = blockNode;

	/* Connect block node to rdnode. */
	RF_ASSERT(blockNode->numSuccedents == 1);
	RF_ASSERT(rdNode->numAntecedents == 1);
	blockNode->succedents[0] = rdNode;
	rdNode->antecedents[0] = blockNode;
	rdNode->antType[0] = rf_control;

	/* Connect rdnode to commit node. */
	RF_ASSERT(rdNode->numSuccedents == 1);
	RF_ASSERT(commitNode->numAntecedents == 1);
	rdNode->succedents[0] = commitNode;
	commitNode->antecedents[0] = rdNode;
	commitNode->antType[0] = rf_control;

	/* Connect commit node to terminator. */
	RF_ASSERT(commitNode->numSuccedents == 1);
	RF_ASSERT(termNode->numAntecedents == 1);
	RF_ASSERT(termNode->numSuccedents == 0);
	commitNode->succedents[0] = termNode;
	termNode->antecedents[0] = commitNode;
	termNode->antType[0] = rf_control;
}

/*
 * XXX move this elsewhere ?
 */
void
rf_DD_GenerateFailedAccessASMs(
    RF_Raid_t			 *raidPtr,
    RF_AccessStripeMap_t	 *asmap,
    RF_PhysDiskAddr_t		**pdap,
    int				 *nNodep,
    RF_PhysDiskAddr_t		**pqpdap,
    int				 *nPQNodep,
    RF_AllocListElem_t		 *allocList
)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	int PDAPerDisk, i;
	RF_SectorCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;
	int numDataCol = layoutPtr->numDataCol;
	int state;
	RF_SectorNum_t suoff, suend;
	unsigned firstDataCol, napdas, count;
	RF_SectorNum_t fone_start, fone_end, ftwo_start = 0, ftwo_end = 0;
	RF_PhysDiskAddr_t *fone = asmap->failedPDAs[0];
	RF_PhysDiskAddr_t *ftwo = asmap->failedPDAs[1];
	RF_PhysDiskAddr_t *pda_p;
	RF_PhysDiskAddr_t *phys_p;
	RF_RaidAddr_t sosAddr;

	/*
	 * Determine how many pda's we will have to generate per unaccessed
	 * stripe. If there is only one failed data unit, it is one; if two,
	 * possibly two, depending whether they overlap.
	 */

	fone_start = rf_StripeUnitOffset(layoutPtr, fone->startSector);
	fone_end = fone_start + fone->numSector;

#define	CONS_PDA(if,start,num)		do {				\
	pda_p->row = asmap->if->row;					\
	pda_p->col = asmap->if->col;					\
	pda_p->startSector = ((asmap->if->startSector / secPerSU) *	\
	    secPerSU) + start;						\
	pda_p->numSector = num;						\
	pda_p->next = NULL;						\
	RF_MallocAndAdd(pda_p->bufPtr,					\
	    rf_RaidAddressToByte(raidPtr,num),(char *), allocList);	\
} while (0)

	if (asmap->numDataFailed == 1) {
		PDAPerDisk = 1;
		state = 1;
		RF_MallocAndAdd(*pqpdap, 2 * sizeof(RF_PhysDiskAddr_t),
		    (RF_PhysDiskAddr_t *), allocList);
		pda_p = *pqpdap;
		/* Build p. */
		CONS_PDA(parityInfo, fone_start, fone->numSector);
		pda_p->type = RF_PDA_TYPE_PARITY;
		pda_p++;
		/* Build q. */
		CONS_PDA(qInfo, fone_start, fone->numSector);
		pda_p->type = RF_PDA_TYPE_Q;
	} else {
		ftwo_start = rf_StripeUnitOffset(layoutPtr, ftwo->startSector);
		ftwo_end = ftwo_start + ftwo->numSector;
		if (fone->numSector + ftwo->numSector > secPerSU) {
			PDAPerDisk = 1;
			state = 2;
			RF_MallocAndAdd(*pqpdap, 2 * sizeof(RF_PhysDiskAddr_t),
			    (RF_PhysDiskAddr_t *), allocList);
			pda_p = *pqpdap;
			CONS_PDA(parityInfo, 0, secPerSU);
			pda_p->type = RF_PDA_TYPE_PARITY;
			pda_p++;
			CONS_PDA(qInfo, 0, secPerSU);
			pda_p->type = RF_PDA_TYPE_Q;
		} else {
			PDAPerDisk = 2;
			state = 3;
			/* Four of them, fone, then ftwo. */
			RF_MallocAndAdd(*pqpdap, 4 * sizeof(RF_PhysDiskAddr_t),
			    (RF_PhysDiskAddr_t *), allocList);
			pda_p = *pqpdap;
			CONS_PDA(parityInfo, fone_start, fone->numSector);
			pda_p->type = RF_PDA_TYPE_PARITY;
			pda_p++;
			CONS_PDA(qInfo, fone_start, fone->numSector);
			pda_p->type = RF_PDA_TYPE_Q;
			pda_p++;
			CONS_PDA(parityInfo, ftwo_start, ftwo->numSector);
			pda_p->type = RF_PDA_TYPE_PARITY;
			pda_p++;
			CONS_PDA(qInfo, ftwo_start, ftwo->numSector);
			pda_p->type = RF_PDA_TYPE_Q;
		}
	}
	/* Figure out number of nonaccessed pda. */
	napdas = PDAPerDisk * (numDataCol - asmap->numStripeUnitsAccessed -
	    (ftwo == NULL ? 1 : 0));
	*nPQNodep = PDAPerDisk;

	/*
	 * Sweep over the over accessed pda's, figuring out the number of
	 * additional pda's to generate. Of course, skip the failed ones.
	 */

	count = 0;
	for (pda_p = asmap->physInfo; pda_p; pda_p = pda_p->next) {
		if ((pda_p == fone) || (pda_p == ftwo))
			continue;
		suoff = rf_StripeUnitOffset(layoutPtr, pda_p->startSector);
		suend = suoff + pda_p->numSector;
		switch (state) {
		case 1:	/* One failed PDA to overlap. */
			/*
			 * If a PDA doesn't contain the failed unit, it can
			 * only miss the start or end, not both.
			 */
			if ((suoff > fone_start) || (suend < fone_end))
				count++;
			break;
		case 2:	/* Whole stripe. */
			if (suoff)			/* Leak at begining. */
				count++;
			if (suend < numDataCol)		/* Leak at end. */
				count++;
			break;
		case 3:	/* Two disjoint units. */
			if ((suoff > fone_start) || (suend < fone_end))
				count++;
			if ((suoff > ftwo_start) || (suend < ftwo_end))
				count++;
			break;
		default:
			RF_PANIC();
		}
	}

	napdas += count;
	*nNodep = napdas;
	if (napdas == 0)
		return;		/* short circuit */

	/* Allocate up our list of pda's. */

	RF_CallocAndAdd(pda_p, napdas, sizeof(RF_PhysDiskAddr_t),
	    (RF_PhysDiskAddr_t *), allocList);
	*pdap = pda_p;

	/* Link them together. */
	for (i = 0; i < (napdas - 1); i++)
		pda_p[i].next = pda_p + (i + 1);

	/* March through the one's up to the first accessed disk. */
	firstDataCol = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
	    asmap->physInfo->raidAddress) % numDataCol;
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
	    asmap->raidAddress);
	for (i = 0; i < firstDataCol; i++) {
		if ((pda_p - (*pdap)) == napdas)
			continue;
		pda_p->type = RF_PDA_TYPE_DATA;
		pda_p->raidAddress = sosAddr + (i * secPerSU);
		(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress,
		    &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		/* Skip over dead disks. */
		if (RF_DEAD_DISK(raidPtr->Disks[pda_p->row][pda_p->col].status))
			continue;
		switch (state) {
		case 1:	/* Fone. */
			pda_p->numSector = fone->numSector;
			pda_p->raidAddress += fone_start;
			pda_p->startSector += fone_start;
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
			break;
		case 2:	/* Full stripe. */
			pda_p->numSector = secPerSU;
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, secPerSU),
			    (char *), allocList);
			break;
		case 3:	/* Two slabs. */
			pda_p->numSector = fone->numSector;
			pda_p->raidAddress += fone_start;
			pda_p->startSector += fone_start;
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
			pda_p++;
			pda_p->type = RF_PDA_TYPE_DATA;
			pda_p->raidAddress = sosAddr + (i * secPerSU);
			(raidPtr->Layout.map->MapSector) (raidPtr,
			    pda_p->raidAddress, &(pda_p->row), &(pda_p->col),
			    &(pda_p->startSector), 0);
			pda_p->numSector = ftwo->numSector;
			pda_p->raidAddress += ftwo_start;
			pda_p->startSector += ftwo_start;
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
			break;
		default:
			RF_PANIC();
		}
		pda_p++;
	}

	/* March through the touched stripe units. */
	for (phys_p = asmap->physInfo; phys_p; phys_p = phys_p->next, i++) {
		if ((phys_p == asmap->failedPDAs[0]) ||
		    (phys_p == asmap->failedPDAs[1]))
			continue;
		suoff = rf_StripeUnitOffset(layoutPtr, phys_p->startSector);
		suend = suoff + phys_p->numSector;
		switch (state) {
		case 1:	/* Single buffer. */
			if (suoff > fone_start) {
				RF_ASSERT(suend >= fone_end);
				/*
				 * The data read starts after the mapped
				 * access, snip off the begining.
				 */
				pda_p->numSector = suoff - fone_start;
				pda_p->raidAddress = sosAddr + (i * secPerSU)
				    + fone_start;
				(raidPtr->Layout.map->MapSector) (raidPtr,
				    pda_p->raidAddress, &(pda_p->row),
				    &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr,
				    rf_RaidAddressToByte(raidPtr,
				    pda_p->numSector), (char *), allocList);
				pda_p++;
			}
			if (suend < fone_end) {
				RF_ASSERT(suoff <= fone_start);
				/*
				 * The data read stops before the end of the
				 * failed access, extend.
				 */
				pda_p->numSector = fone_end - suend;
				pda_p->raidAddress = sosAddr + (i * secPerSU)
				    + suend;	/* off by one? */
				(raidPtr->Layout.map->MapSector) (raidPtr,
				    pda_p->raidAddress, &(pda_p->row),
				    &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr,
				    rf_RaidAddressToByte(raidPtr,
				    pda_p->numSector), (char *), allocList);
				pda_p++;
			}
			break;
		case 2:	/* Whole stripe unit. */
			RF_ASSERT((suoff == 0) || (suend == secPerSU));
			if (suend < secPerSU) {
				/* Short read, snip from end on. */
				pda_p->numSector = secPerSU - suend;
				pda_p->raidAddress = sosAddr + (i * secPerSU)
				    + suend;	/* off by one? */
				(raidPtr->Layout.map->MapSector) (raidPtr,
				    pda_p->raidAddress, &(pda_p->row),
				    &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr,
				    rf_RaidAddressToByte(raidPtr,
				    pda_p->numSector), (char *), allocList);
				pda_p++;
			} else
				if (suoff > 0) {
					/* Short at front. */
					pda_p->numSector = suoff;
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU);
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
					pda_p++;
				}
			break;
		case 3:	/* Two nonoverlapping failures. */
			if ((suoff > fone_start) || (suend < fone_end)) {
				if (suoff > fone_start) {
					RF_ASSERT(suend >= fone_end);
					/*
					 * The data read starts after the
					 * mapped access, snip off the
					 * begining.
					 */
					pda_p->numSector = suoff - fone_start;
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) + fone_start;
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
					pda_p++;
				}
				if (suend < fone_end) {
					RF_ASSERT(suoff <= fone_start);
					/*
					 * The data read stops before the end
					 * of the failed access, extend.
					 */
					pda_p->numSector = fone_end - suend;
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) +
					    suend;	/* Off by one ? */
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
					pda_p++;
				}
			}
			if ((suoff > ftwo_start) || (suend < ftwo_end)) {
				if (suoff > ftwo_start) {
					RF_ASSERT(suend >= ftwo_end);
					/*
					 * The data read starts after the
					 * mapped access, snip off the
					 * begining.
					 */
					pda_p->numSector = suoff - ftwo_start;
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) + ftwo_start;
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
					pda_p++;
				}
				if (suend < ftwo_end) {
					RF_ASSERT(suoff <= ftwo_start);
					/*
					 * The data read stops before the end
					 * of the failed access, extend.
					 */
					pda_p->numSector = ftwo_end - suend;
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) +
					    suend;	/* Off by one ? */
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
					pda_p++;
				}
			}
			break;
		default:
			RF_PANIC();
		}
	}

	/* After the last accessed disk. */
	for (; i < numDataCol; i++) {
		if ((pda_p - (*pdap)) == napdas)
			continue;
		pda_p->type = RF_PDA_TYPE_DATA;
		pda_p->raidAddress = sosAddr + (i * secPerSU);
		(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress,
		    &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		/* Skip over dead disks. */
		if (RF_DEAD_DISK(raidPtr->Disks[pda_p->row][pda_p->col].status))
			continue;
		switch (state) {
		case 1:	/* Fone. */
			pda_p->numSector = fone->numSector;
			pda_p->raidAddress += fone_start;
			pda_p->startSector += fone_start;
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
			break;
		case 2:	/* Full stripe. */
			pda_p->numSector = secPerSU;
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, secPerSU),
			    (char *), allocList);
			break;
		case 3:	/* Two slabs. */
			pda_p->numSector = fone->numSector;
			pda_p->raidAddress += fone_start;
			pda_p->startSector += fone_start;
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
			pda_p++;
			pda_p->type = RF_PDA_TYPE_DATA;
			pda_p->raidAddress = sosAddr + (i * secPerSU);
			(raidPtr->Layout.map->MapSector) (raidPtr,
			    pda_p->raidAddress, &(pda_p->row), &(pda_p->col),
			    &(pda_p->startSector), 0);
			pda_p->numSector = ftwo->numSector;
			pda_p->raidAddress += ftwo_start;
			pda_p->startSector += ftwo_start;
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
			break;
		default:
			RF_PANIC();
		}
		pda_p++;
	}

	RF_ASSERT(pda_p - *pdap == napdas);
	return;
}

#define	INIT_DISK_NODE(node,name)	do {				\
	rf_InitNode(node, rf_wait, RF_FALSE, rf_DiskReadFunc,		\
	    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 2,1,4,0,		\
	    dag_h, name, allocList);					\
	(node)->succedents[0] = unblockNode;				\
	(node)->succedents[1] = recoveryNode;				\
	(node)->antecedents[0] = blockNode;				\
	(node)->antType[0] = rf_control;				\
} while (0)

#define	DISK_NODE_PARAMS(_node_,_p_)	do {				\
	(_node_).params[0].p = _p_ ;					\
	(_node_).params[1].p = (_p_)->bufPtr;				\
	(_node_).params[2].v = parityStripeID;				\
	(_node_).params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,	\
	    0, 0, which_ru);						\
} while (0)

void
rf_DoubleDegRead(
    RF_Raid_t			 *raidPtr,
    RF_AccessStripeMap_t	 *asmap,
    RF_DagHeader_t		 *dag_h,
    void			 *bp,
    RF_RaidAccessFlags_t	  flags,
    RF_AllocListElem_t		 *allocList,
    char			 *redundantReadNodeName,
    char			 *recoveryNodeName,
    int				(*recovFunc) (RF_DagNode_t *)
)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	RF_DagNode_t *nodes, *rudNodes, *rrdNodes, *recoveryNode, *blockNode,
	    *unblockNode, *rpNodes, *rqNodes, *termNode;
	RF_PhysDiskAddr_t *pda, *pqPDAs;
	RF_PhysDiskAddr_t *npdas;
	int nNodes, nRrdNodes, nRudNodes, i;
	RF_ReconUnitNum_t which_ru;
	int nReadNodes, nPQNodes;
	RF_PhysDiskAddr_t *failedPDA = asmap->failedPDAs[0];
	RF_PhysDiskAddr_t *failedPDAtwo = asmap->failedPDAs[1];
	RF_StripeNum_t parityStripeID = rf_RaidAddressToParityStripeID(
	    layoutPtr, asmap->raidAddress, &which_ru);

	if (rf_dagDebug)
		printf("[Creating Double Degraded Read DAG]\n");
	rf_DD_GenerateFailedAccessASMs(raidPtr, asmap, &npdas, &nRrdNodes,
	    &pqPDAs, &nPQNodes, allocList);

	nRudNodes = asmap->numStripeUnitsAccessed - (asmap->numDataFailed);
	nReadNodes = nRrdNodes + nRudNodes + 2 * nPQNodes;
	nNodes = 4 /* Block, unblock, recovery, term. */ + nReadNodes;

	RF_CallocAndAdd(nodes, nNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *),
	    allocList);
	i = 0;
	blockNode = &nodes[i];
	i += 1;
	unblockNode = &nodes[i];
	i += 1;
	recoveryNode = &nodes[i];
	i += 1;
	termNode = &nodes[i];
	i += 1;
	rudNodes = &nodes[i];
	i += nRudNodes;
	rrdNodes = &nodes[i];
	i += nRrdNodes;
	rpNodes = &nodes[i];
	i += nPQNodes;
	rqNodes = &nodes[i];
	i += nPQNodes;
	RF_ASSERT(i == nNodes);

	dag_h->numSuccedents = 1;
	dag_h->succedents[0] = blockNode;
	dag_h->creator = "DoubleDegRead";
	dag_h->numCommits = 0;
	dag_h->numCommitNodes = 1;	/* Unblock. */

	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 2, 0, 0, dag_h, "Trm", allocList);
	termNode->antecedents[0] = unblockNode;
	termNode->antType[0] = rf_control;
	termNode->antecedents[1] = recoveryNode;
	termNode->antType[1] = rf_control;

	/*
	 * Init the block and unblock nodes.
	 * The block node has all nodes except itself, unblock and
	 * recovery as successors.
	 * Similarly for predecessors of the unblock.
	 */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nReadNodes, 0, 0, 0, dag_h,
	    "Nil", allocList);
	rf_InitNode(unblockNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, nReadNodes, 0, 0, dag_h,
	    "Nil", allocList);

	for (i = 0; i < nReadNodes; i++) {
		blockNode->succedents[i] = rudNodes + i;
		unblockNode->antecedents[i] = rudNodes + i;
		unblockNode->antType[i] = rf_control;
	}
	unblockNode->succedents[0] = termNode;

	/*
	 * The recovery node has all the reads as predecessors, and the term
	 * node as successors. It gets a pda as a param from each of the read
	 * nodes plus the raidPtr. For each failed unit is has a result pda.
	 */
	rf_InitNode(recoveryNode, rf_wait, RF_FALSE, recovFunc,
	    rf_NullNodeUndoFunc, NULL,
	    1,				/* successors */
	    nReadNodes,			/* preds */
	    nReadNodes + 2,		/* params */
	    asmap->numDataFailed,	/* results */
	    dag_h, recoveryNodeName, allocList);

	recoveryNode->succedents[0] = termNode;
	for (i = 0; i < nReadNodes; i++) {
		recoveryNode->antecedents[i] = rudNodes + i;
		recoveryNode->antType[i] = rf_trueData;
	}

	/*
	 * Build the read nodes, then come back and fill in recovery params
	 * and results.
	 */
	pda = asmap->physInfo;
	for (i = 0; i < nRudNodes; pda = pda->next) {
		if ((pda == failedPDA) || (pda == failedPDAtwo))
			continue;
		INIT_DISK_NODE(rudNodes + i, "Rud");
		RF_ASSERT(pda);
		DISK_NODE_PARAMS(rudNodes[i], pda);
		i++;
	}

	pda = npdas;
	for (i = 0; i < nRrdNodes; i++, pda = pda->next) {
		INIT_DISK_NODE(rrdNodes + i, "Rrd");
		RF_ASSERT(pda);
		DISK_NODE_PARAMS(rrdNodes[i], pda);
	}

	/* Redundancy pdas. */
	pda = pqPDAs;
	INIT_DISK_NODE(rpNodes, "Rp");
	RF_ASSERT(pda);
	DISK_NODE_PARAMS(rpNodes[0], pda);
	pda++;
	INIT_DISK_NODE(rqNodes, redundantReadNodeName);
	RF_ASSERT(pda);
	DISK_NODE_PARAMS(rqNodes[0], pda);
	if (nPQNodes == 2) {
		pda++;
		INIT_DISK_NODE(rpNodes + 1, "Rp");
		RF_ASSERT(pda);
		DISK_NODE_PARAMS(rpNodes[1], pda);
		pda++;
		INIT_DISK_NODE(rqNodes + 1, redundantReadNodeName);
		RF_ASSERT(pda);
		DISK_NODE_PARAMS(rqNodes[1], pda);
	}
	/* Fill in recovery node params. */
	for (i = 0; i < nReadNodes; i++)
		recoveryNode->params[i] = rudNodes[i].params[0]; /* pda */
	recoveryNode->params[i++].p = (void *) raidPtr;
	recoveryNode->params[i++].p = (void *) asmap;
	recoveryNode->results[0] = failedPDA;
	if (asmap->numDataFailed == 2)
		recoveryNode->results[1] = failedPDAtwo;

	/* Zero fill the target data buffers ? */
}
@


1.7
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagdegrd.c,v 1.6 2006/07/09 22:10:05 mk Exp $	*/
@


1.6
log
@I don't think we're talking about animals in here, so
s/wether/whether/g.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagdegrd.c,v 1.5 2002/12/16 07:01:03 tdeval Exp $	*/
d1233 1
a1233 1
	    1,				/* succesors */
@


1.5
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagdegrd.c,v 1.4 2000/01/11 18:02:20 peter Exp $	*/
d720 1
a720 1
	 * possibly two, depending wether they overlap.
@


1.4
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagdegrd.c,v 1.3 2000/01/07 14:50:20 peter Exp $	*/
d3 1
d34 1
a34 1
 * code for creating degraded read DAGs
d48 1
a48 1
/******************************************************************************
d52 2
a53 2
 * All DAGs in this file use roll-away error recovery.  Each DAG has a single
 * commit node, usually called "Cmt."  If an error occurs before the Cmt node
d55 1
a55 1
 * backward through the graph, executing the undo functions.  Assuming that
d64 1
a64 1
 */
d67 1
a67 1
/******************************************************************************
d70 1
a70 1
 * DAG creation routines.  Additionally, these wrappers enable experimentation
d73 2
a74 1
 */
d76 1
a76 1
void 
d78 6
a83 6
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList)
d90 3
a92 1
/******************************************************************************
d94 1
a94 2
 * DAG creation code begins here
 */
d97 2
a98 2
/******************************************************************************
 * Create a degraded read DAG for RAID level 1
d102 1
a102 1
 * The "Rd" node reads data from the surviving disk in the mirror pair
d106 5
a110 5
 * Parameters:  raidPtr   - description of the physical array
 *              asmap     - logical & physical addresses for this access
 *              bp        - buffer ptr (for holding write data)
 *              flags     - general flags (e.g. disk locking)
 *              allocList - list of memory allocated in DAG creation
d113 1
a113 1
void 
d115 6
a120 6
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList)
d126 1
a126 1
	int     useMirror, i;
d135 1
a135 1
	/* alloc the Wnd nodes and the Wmir node */
d141 3
a143 2
	/* total number of nodes = 1 + (block + commit + terminator) */
	RF_CallocAndAdd(nodes, 4, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
d154 2
a155 1
	/* this dag can not commit until the commit node is reached.   errors
d157 2
a158 1
	 * retried */
d163 7
a169 7
	/* initialize the block, commit, and terminator nodes */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
	    NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
	    NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,
	    NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d173 1
a173 1
	/* parityInfo must describe entire parity unit */
d176 1
a176 1
	/* initialize the data node */
d178 4
a181 3
		/* read primary copy of data */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc,
		    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rpd", allocList);
d185 2
a186 1
		rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d188 4
a191 3
		/* read secondary copy of data */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc,
		    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rsd", allocList);
d195 2
a196 1
		rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d199 1
a199 1
	/* connect header to block node */
d204 1
a204 1
	/* connect block node to rdnode */
d211 1
a211 1
	/* connect rdnode to commit node */
d218 1
a218 1
	/* connect commit node to terminator */
d228 1
a228 2

/******************************************************************************
d230 1
a230 1
 * creates a DAG to perform a degraded-mode read of data within one stripe.
d234 2
a235 2
 *              -> Rrd ->
 *              -> Rp -->
d237 2
a238 2
 * Each R node is a successor of the L node
 * One successor arc from each R node goes to C, and the other to X
d241 1
a241 1
 * the user
d248 2
a249 2
 * where the failed data is supposed to end up.  This buffer is zero'd by the
 * code here.  Thus, if you create a degraded read dag, use it, and then
d253 1
a253 2
 * the redundancy
 * recovery function.
d257 1
a257 1
void 
d259 7
a265 7
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList,
    RF_RedFuncs_t * recFunc)
d269 2
a270 2
	int     nNodes, nRrdNodes, nRudNodes, nXorBufs, i;
	int     j, paramNum;
d273 1
a273 1
	char   *overlappingPDAs;/* a temporary array of flags */
d279 1
a279 1
	char   *rpBuf;
d282 4
a285 2
	/* failedPDA points to the pda within the asm that targets the failed
	 * disk */
d298 9
a306 8
         * generate two ASMs identifying the surviving data we need
         * in order to recover the lost data
         */

	/* overlappingPDAs array must be zero'd */
	RF_Calloc(overlappingPDAs, asmap->numStripeUnitsAccessed, sizeof(char), (char *));
	rf_GenerateFailedAccessASMs(raidPtr, asmap, failedPDA, dag_h, new_asm_h, &nXorBufs,
	    &rpBuf, overlappingPDAs, allocList);
d309 4
a312 4
         * create all the nodes at once
         *
         * -1 because no access is generated for the failed pda
         */
d314 8
a321 4
	nRrdNodes = ((new_asm_h[0]) ? new_asm_h[0]->stripeMap->numStripeUnitsAccessed : 0) +
	    ((new_asm_h[1]) ? new_asm_h[1]->stripeMap->numStripeUnitsAccessed : 0);
	nNodes = 5 + nRudNodes + nRrdNodes;	/* lock, unlock, xor, Rp, Rud,
						 * Rrd */
d341 1
a341 1
	/* initialize nodes */
d344 4
a347 2
	/* this dag can not commit until the commit node is reached errors
	 * prior to the commit point imply the dag has failed */
d350 14
a363 12
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
	    NULL, nRudNodes + nRrdNodes + 1, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
	    NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,
	    NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
	rf_InitNode(xorNode, rf_wait, RF_FALSE, recFunc->simple, rf_NullNodeUndoFunc,
	    NULL, 1, nRudNodes + nRrdNodes + 1, 2 * nXorBufs + 2, 1, dag_h,
	    recFunc->SimpleName, allocList);

	/* fill in the Rud nodes */
	for (pda = asmap->physInfo, i = 0; i < nRudNodes; i++, pda = pda->next) {
d369 2
a370 2
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
		    "Rud", allocList);
d375 2
a376 1
		rudNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d379 1
a379 1
	/* fill in the Rrd nodes */
d383 6
a388 5
		    i < new_asm_h[0]->stripeMap->numStripeUnitsAccessed;
		    i++, pda = pda->next) {
			rf_InitNode(&rrdNodes[i], rf_wait, RF_FALSE, rf_DiskReadFunc,
			    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
			    dag_h, "Rrd", allocList);
d393 3
a395 1
			rrdNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d402 4
a405 3
			rf_InitNode(&rrdNodes[i + j], rf_wait, RF_FALSE, rf_DiskReadFunc,
			    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
			    dag_h, "Rrd", allocList);
d410 3
a412 1
			rrdNodes[i + j].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d415 3
a417 2
	/* make a PDA for the parity unit */
	RF_MallocAndAdd(parityPDA, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *), allocList);
d420 3
a422 2
	parityPDA->startSector = ((asmap->parityInfo->startSector / sectorsPerSU)
	    * sectorsPerSU) + (failedPDA->startSector % sectorsPerSU);
d425 4
a428 3
	/* initialize the Rp node */
	rf_InitNode(rpNode, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc,
	    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rp ", allocList);
d432 2
a433 1
	rpNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d436 3
a438 3
         * the last and nastiest step is to assign all
         * the parameters of the Xor node
         */
d441 1
a441 1
		/* all the Rrd nodes need to be xored together */
d446 2
a447 2
		/* any Rud nodes that overlap the failed access need to be
		 * xored in */
d449 6
a454 3
			RF_MallocAndAdd(pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *), allocList);
			bcopy((char *) rudNodes[i].params[0].p, (char *) pda, sizeof(RF_PhysDiskAddr_t));
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda, RF_RESTRICT_DOBUFFER, 0);
d461 1
a461 1
	/* install parity pda as last set of params to be xor'd */
d466 3
a468 3
         * the last 2 params to the recovery xor node are
         * the failed PDA and the raidPtr
         */
d474 4
a477 4
         * The xor node uses results[0] as the target buffer.
         * Set pointer and zero the buffer. In the kernel, this
         * may be a user buffer in which case we have to remap it.
         */
d480 1
a480 1
		failedPDA->numSector));
d482 2
a483 2
	/* connect nodes to form graph */
	/* connect the header to the block node */
d488 1
a488 1
	/* connect the block node to the read nodes */
d507 1
a507 1
	/* connect the read nodes to the xor node */
d526 1
a526 1
	/* connect the xor node to the commit node */
d533 1
a533 1
	/* connect the termNode to the commit node */
d543 2
a544 2
/******************************************************************************
 * Create a degraded read DAG for Chained Declustering
d552 5
a556 5
 * Parameters:  raidPtr   - description of the physical array
 *              asmap     - logical & physical addresses for this access
 *              bp        - buffer ptr (for holding write data)
 *              flags     - general flags (e.g. disk locking)
 *              allocList - list of memory allocated in DAG creation
d559 1
a559 1
void 
d561 7
a567 6
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList)
d571 1
a571 1
	int     useMirror, i, shiftable;
d588 1
a588 1
	/* alloc the Wnd nodes and the Wmir node */
d595 2
a596 1
	RF_CallocAndAdd(nodes, 4, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
d608 4
a611 4
         * This dag can not commit until the commit node is reached.
         * Errors prior to the commit point imply the dag has failed
         * and must be retried.
         */
d617 6
a622 6
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
	    NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
	    NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,
	    NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d626 1
a626 1
	/* parityInfo must describe entire parity unit */
d629 1
a629 1
	/* initialize the data node */
d631 3
a633 2
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc,
		    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rpd", allocList);
d635 1
a635 1
			/* shift this read to the next disk in line */
d639 2
a640 1
			rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d642 1
a642 1
			/* read primary copy */
d646 2
a647 1
			rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d650 4
a653 3
		/* read secondary copy of data */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc,
		    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rsd", allocList);
d657 2
a658 1
		rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d661 1
a661 1
	/* connect header to block node */
d666 1
a666 1
	/* connect block node to rdnode */
d673 1
a673 1
	/* connect rdnode to commit node */
d680 1
a680 1
	/* connect commit node to terminator */
d688 1
d690 1
a690 1
 * XXX move this elsewhere?
d692 1
a692 1
void 
d694 8
a701 7
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_PhysDiskAddr_t ** pdap,
    int *nNodep,
    RF_PhysDiskAddr_t ** pqpdap,
    int *nPQNodep,
    RF_AllocListElem_t * allocList)
d704 1
a704 1
	int     PDAPerDisk, i;
d706 2
a707 2
	int     numDataCol = layoutPtr->numDataCol;
	int     state;
d711 2
a712 1
	RF_PhysDiskAddr_t *fone = asmap->failedPDAs[0], *ftwo = asmap->failedPDAs[1];
d717 2
a718 1
	/* determine how many pda's we will have to generate per unaccess
d720 2
a721 1
	 * possibly two, depending wether they overlap. */
d726 10
a735 6
#define CONS_PDA(if,start,num) \
  pda_p->row = asmap->if->row;    pda_p->col = asmap->if->col; \
  pda_p->startSector = ((asmap->if->startSector / secPerSU) * secPerSU) + start; \
  pda_p->numSector = num; \
  pda_p->next = NULL; \
  RF_MallocAndAdd(pda_p->bufPtr,rf_RaidAddressToByte(raidPtr,num),(char *), allocList)
d740 2
a741 1
		RF_MallocAndAdd(*pqpdap, 2 * sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *), allocList);
d743 1
a743 1
		/* build p */
d747 1
a747 1
		/* build q */
d756 2
a757 1
			RF_MallocAndAdd(*pqpdap, 2 * sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *), allocList);
d767 3
a769 2
			/* four of them, fone, then ftwo */
			RF_MallocAndAdd(*pqpdap, 4 * sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *), allocList);
d784 3
a786 2
	/* figure out number of nonaccessed pda */
	napdas = PDAPerDisk * (numDataCol - asmap->numStripeUnitsAccessed - (ftwo == NULL ? 1 : 0));
d789 4
a792 2
	/* sweep over the over accessed pda's, figuring out the number of
	 * additional pda's to generate. Of course, skip the failed ones */
d801 5
a805 3
		case 1:	/* one failed PDA to overlap */
			/* if a PDA doesn't contain the failed unit, it can
			 * only miss the start or end, not both */
d809 2
a810 2
		case 2:	/* whole stripe */
			if (suoff)	/* leak at begining */
d812 1
a812 1
			if (suend < numDataCol)	/* leak at end */
d815 1
a815 1
		case 3:	/* two disjoint units */
d831 1
a831 1
	/* allocate up our list of pda's */
d833 2
a834 1
	RF_CallocAndAdd(pda_p, napdas, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *), allocList);
d837 1
a837 1
	/* linkem together */
d841 5
a845 3
	/* march through the one's up to the first accessed disk */
	firstDataCol = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), asmap->physInfo->raidAddress) % numDataCol;
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);
d851 3
a853 2
		(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		/* skip over dead disks */
d857 1
a857 1
		case 1:	/* fone */
d861 3
a863 1
			RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d865 1
a865 1
		case 2:	/* full stripe */
d867 3
a869 1
			RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, secPerSU), (char *), allocList);
d871 1
a871 1
		case 3:	/* two slabs */
d875 3
a877 1
			RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d881 3
a883 1
			(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
d887 3
a889 1
			RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d897 1
a897 1
	/* march through the touched stripe units */
d899 2
a900 1
		if ((phys_p == asmap->failedPDAs[0]) || (phys_p == asmap->failedPDAs[1]))
d905 1
a905 1
		case 1:	/* single buffer */
d908 4
a911 2
				/* The data read starts after the mapped
				 * access, snip off the begining */
d913 8
a920 3
				pda_p->raidAddress = sosAddr + (i * secPerSU) + fone_start;
				(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d925 4
a928 2
				/* The data read stops before the end of the
				 * failed access, extend */
d930 8
a937 3
				pda_p->raidAddress = sosAddr + (i * secPerSU) + suend;	/* off by one? */
				(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d941 1
a941 1
		case 2:	/* whole stripe unit */
d943 2
a944 2
			if (suend < secPerSU) {	/* short read, snip from end
						 * on */
d946 8
a953 3
				pda_p->raidAddress = sosAddr + (i * secPerSU) + suend;	/* off by one? */
				(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d956 2
a957 1
				if (suoff > 0) {	/* short at front */
d959 10
a968 3
					pda_p->raidAddress = sosAddr + (i * secPerSU);
					(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d972 1
a972 1
		case 3:	/* two nonoverlapping failures */
d976 2
a977 1
					/* The data read starts after the
d979 2
a980 1
					 * begining */
d982 10
a991 3
					pda_p->raidAddress = sosAddr + (i * secPerSU) + fone_start;
					(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d996 4
a999 2
					/* The data read stops before the end
					 * of the failed access, extend */
d1001 11
a1011 3
					pda_p->raidAddress = sosAddr + (i * secPerSU) + suend;	/* off by one? */
					(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d1018 2
a1019 1
					/* The data read starts after the
d1021 2
a1022 1
					 * begining */
d1024 10
a1033 3
					pda_p->raidAddress = sosAddr + (i * secPerSU) + ftwo_start;
					(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d1038 4
a1041 2
					/* The data read stops before the end
					 * of the failed access, extend */
d1043 11
a1053 3
					pda_p->raidAddress = sosAddr + (i * secPerSU) + suend;	/* off by one? */
					(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d1063 1
a1063 1
	/* after the last accessed disk */
d1069 3
a1071 2
		(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		/* skip over dead disks */
d1075 1
a1075 1
		case 1:	/* fone */
d1079 3
a1081 1
			RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d1083 1
a1083 1
		case 2:	/* full stripe */
d1085 3
a1087 1
			RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, secPerSU), (char *), allocList);
d1089 1
a1089 1
		case 3:	/* two slabs */
d1093 3
a1095 1
			RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
d1099 3
a1101 1
			(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
d1105 3
a1107 1
			RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr, pda_p->numSector), (char *), allocList);
a1117 12
#define INIT_DISK_NODE(node,name) \
rf_InitNode(node, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 2,1,4,0, dag_h, name, allocList); \
(node)->succedents[0] = unblockNode; \
(node)->succedents[1] = recoveryNode; \
(node)->antecedents[0] = blockNode; \
(node)->antType[0] = rf_control

#define DISK_NODE_PARAMS(_node_,_p_) \
  (_node_).params[0].p = _p_ ; \
  (_node_).params[1].p = (_p_)->bufPtr; \
  (_node_).params[2].v = parityStripeID; \
  (_node_).params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru)
d1119 19
a1137 1
void 
d1139 10
a1148 9
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList,
    char *redundantReadNodeName,
    char *recoveryNodeName,
    int (*recovFunc) (RF_DagNode_t *))
d1152 1
a1152 1
	       *unblockNode, *rpNodes, *rqNodes, *termNode;
d1155 1
a1155 1
	int     nNodes, nRrdNodes, nRudNodes, i;
d1157 1
a1157 1
	int     nReadNodes, nPQNodes;
d1160 2
a1161 1
	RF_StripeNum_t parityStripeID = rf_RaidAddressToParityStripeID(layoutPtr, asmap->raidAddress, &which_ru);
d1165 2
a1166 1
	rf_DD_GenerateFailedAccessASMs(raidPtr, asmap, &npdas, &nRrdNodes, &pqPDAs, &nPQNodes, allocList);
d1170 1
a1170 1
	nNodes = 4 /* block, unblock, recovery, term */ + nReadNodes;
d1172 2
a1173 1
	RF_CallocAndAdd(nodes, nNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
d1197 1
a1197 1
	dag_h->numCommitNodes = 1;	/* unblock */
d1199 2
a1200 1
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc, NULL, 0, 2, 0, 0, dag_h, "Trm", allocList);
d1206 12
a1217 5
	/* init the block and unblock nodes */
	/* The block node has all nodes except itself, unblock and recovery as
	 * successors. Similarly for predecessors of the unblock. */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, nReadNodes, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(unblockNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, 1, nReadNodes, 0, 0, dag_h, "Nil", allocList);
d1226 2
a1227 1
	/* The recovery node has all the reads as predecessors, and the term
d1229 7
a1235 5
	 * nodes plus the raidPtr. For each failed unit is has a result pda. */
	rf_InitNode(recoveryNode, rf_wait, RF_FALSE, recovFunc, rf_NullNodeUndoFunc, NULL,
	    1,			/* succesors */
	    nReadNodes,		/* preds */
	    nReadNodes + 2,	/* params */
d1245 4
a1248 2
	/* build the read nodes, then come back and fill in recovery params
	 * and results */
d1266 1
a1266 1
	/* redundancy pdas */
d1285 1
a1285 1
	/* fill in recovery node params */
d1287 1
a1287 1
		recoveryNode->params[i] = rudNodes[i].params[0];	/* pda */
d1294 1
a1294 1
	/* zero fill the target data buffers? */
@


1.4.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d33 1
a33 1
 * Code for creating degraded read DAGs.
d47 1
a47 1
/*****************************************************************************
d51 2
a52 2
 * All DAGs in this file use roll-away error recovery. Each DAG has a single
 * commit node, usually called "Cmt". If an error occurs before the Cmt node
d54 1
a54 1
 * backward through the graph, executing the undo functions. Assuming that
d63 1
a63 1
 *****************************************************************************/
d66 1
a66 1
/*****************************************************************************
d69 1
a69 1
 * DAG creation routines. Additionally, these wrappers enable experimentation
d72 1
a72 2
 *
 *****************************************************************************/
d74 1
a74 1
void
d76 6
a81 6
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList)
d88 1
a88 1
/*****************************************************************************
d90 2
a91 3
 * DAG creation code begins here.
 *
 *****************************************************************************/
d94 2
a95 2
/*****************************************************************************
 * Create a degraded read DAG for RAID level 1.
d99 1
a99 1
 * The "Rd" node reads data from the surviving disk in the mirror pair.
d103 5
a107 5
 * Parameters:	raidPtr	  - description of the physical array
 *		asmap	  - logical & physical addresses for this access
 *		bp	  - buffer ptr (for holding write data)
 *		flags	  - general flags (e.g. disk locking)
 *		allocList - list of memory allocated in DAG creation
d110 1
a110 1
void
d112 6
a117 6
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList)
d123 1
a123 1
	int useMirror, i;
d132 1
a132 1
	/* Alloc the Wnd nodes and the Wmir node. */
d138 2
a139 3
	/* Total number of nodes = 1 + (block + commit + terminator). */
	RF_CallocAndAdd(nodes, 4, sizeof(RF_DagNode_t), (RF_DagNode_t *),
	    allocList);
d150 1
a150 2
	/*
	 * This dag can not commit until the commit node is reached. Errors
d152 1
a152 2
	 * retried.
	 */
d157 7
a163 7
	/* Initialize the block, commit, and terminator nodes. */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d167 1
a167 1
	/* parityInfo must describe entire parity unit. */
d170 1
a170 1
	/* Initialize the data node. */
d172 3
a174 4
		/* Read primary copy of data. */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rpd", allocList);
d178 1
a178 2
		rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
		    0, 0, which_ru);
d180 3
a182 4
		/* Read secondary copy of data. */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rsd", allocList);
d186 1
a186 2
		rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
		    0, 0, which_ru);
d189 1
a189 1
	/* Connect header to block node. */
d194 1
a194 1
	/* Connect block node to rdnode. */
d201 1
a201 1
	/* Connect rdnode to commit node. */
d208 1
a208 1
	/* Connect commit node to terminator. */
d218 2
a219 1
/*****************************************************************************
d221 1
a221 1
 * Create a DAG to perform a degraded-mode read of data within one stripe.
d225 2
a226 2
 *		-> Rrd ->
 *		-> Rp -->
d228 2
a229 2
 * Each R node is a successor of the L node.
 * One successor arc from each R node goes to C, and the other to X.
d232 1
a232 1
 * the user.
d239 2
a240 2
 * where the failed data is supposed to end up. This buffer is zero'd by the
 * code here. Thus, if you create a degraded read dag, use it, and then
d244 2
a245 1
 * the redundancy recovery function.
d249 1
a249 1
void
d251 7
a257 7
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList,
    RF_RedFuncs_t		*recFunc)
d261 2
a262 2
	int nNodes, nRrdNodes, nRudNodes, nXorBufs, i;
	int j, paramNum;
d265 1
a265 1
	char *overlappingPDAs;		/* A temporary array of flags. */
d271 1
a271 1
	char *rpBuf;
d274 2
a275 4
	/*
	 * failedPDA points to the pda within the asm that targets
	 * the failed disk.
	 */
d288 8
a295 9
	 * Generate two ASMs identifying the surviving data we need
	 * in order to recover the lost data.
	 */

	/* overlappingPDAs array must be zero'd. */
	RF_Calloc(overlappingPDAs, asmap->numStripeUnitsAccessed,
	    sizeof(char), (char *));
	rf_GenerateFailedAccessASMs(raidPtr, asmap, failedPDA, dag_h,
	    new_asm_h, &nXorBufs, &rpBuf, overlappingPDAs, allocList);
d298 4
a301 4
	 * Create all the nodes at once.
	 *
	 * -1 because no access is generated for the failed pda.
	 */
d303 4
a306 8
	nRrdNodes = ((new_asm_h[0]) ?
	    new_asm_h[0]->stripeMap->numStripeUnitsAccessed : 0) +
	    ((new_asm_h[1]) ?
	    new_asm_h[1]->stripeMap->numStripeUnitsAccessed : 0);
	nNodes = 5 + nRudNodes + nRrdNodes;	/*
						 * lock, unlock, xor, Rp,
						 * Rud, Rrd
						 */
d326 1
a326 1
	/* Initialize nodes. */
d329 2
a330 4
	/*
	 * This dag can not commit until the commit node is reached.
	 * Errors prior to the commit point imply the dag has failed.
	 */
d333 12
a344 14
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nRudNodes + nRrdNodes + 1, 0, 0, 0,
	    dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
	rf_InitNode(xorNode, rf_wait, RF_FALSE, recFunc->simple,
	    rf_NullNodeUndoFunc, NULL, 1, nRudNodes + nRrdNodes + 1,
	    2 * nXorBufs + 2, 1, dag_h, recFunc->SimpleName, allocList);

	/* Fill in the Rud nodes. */
	for (pda = asmap->physInfo, i = 0; i < nRudNodes;
	     i++, pda = pda->next) {
d350 2
a351 2
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rud", allocList);
d356 1
a356 2
		rudNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d359 1
a359 1
	/* Fill in the Rrd nodes. */
d363 5
a367 6
		     i < new_asm_h[0]->stripeMap->numStripeUnitsAccessed;
		     i++, pda = pda->next) {
			rf_InitNode(&rrdNodes[i], rf_wait, RF_FALSE,
			    rf_DiskReadFunc, rf_DiskReadUndoFunc,
			    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
			    "Rrd", allocList);
d372 1
a372 3
			rrdNodes[i].params[3].v =
			    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0,
			    which_ru);
d379 3
a381 4
			rf_InitNode(&rrdNodes[i + j], rf_wait, RF_FALSE,
			    rf_DiskReadFunc, rf_DiskReadUndoFunc,
			    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
			    "Rrd", allocList);
d386 1
a386 3
			rrdNodes[i + j].params[3].v =
			    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0,
			    which_ru);
d389 2
a390 3
	/* Make a PDA for the parity unit. */
	RF_MallocAndAdd(parityPDA, sizeof(RF_PhysDiskAddr_t),
	    (RF_PhysDiskAddr_t *), allocList);
d393 2
a394 3
	parityPDA->startSector = ((asmap->parityInfo->startSector /
	    sectorsPerSU) * sectorsPerSU) +
	    (failedPDA->startSector % sectorsPerSU);
d397 3
a399 4
	/* Initialize the Rp node. */
	rf_InitNode(rpNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
	    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
	    "Rp ", allocList);
d403 1
a403 2
	rpNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0,
	    which_ru);
d406 3
a408 3
	 * The last and nastiest step is to assign all
	 * the parameters of the Xor node.
	 */
d411 1
a411 1
		/* All the Rrd nodes need to be xored together. */
d416 2
a417 2
		/* Any Rud nodes that overlap the failed access need to be
		 * xored in. */
d419 3
a421 6
			RF_MallocAndAdd(pda, sizeof(RF_PhysDiskAddr_t),
			    (RF_PhysDiskAddr_t *), allocList);
			bcopy((char *) rudNodes[i].params[0].p, (char *) pda,
			    sizeof(RF_PhysDiskAddr_t));
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda,
			    RF_RESTRICT_DOBUFFER, 0);
d428 1
a428 1
	/* Install parity pda as last set of params to be xor'd. */
d433 3
a435 3
	 * The last 2 params to the recovery xor node are
	 * the failed PDA and the raidPtr.
	 */
d441 4
a444 4
	 * The xor node uses results[0] as the target buffer.
	 * Set pointer and zero the buffer. In the kernel, this
	 * may be a user buffer in which case we have to remap it.
	 */
d447 1
a447 1
	    failedPDA->numSector));
d449 2
a450 2
	/* Connect nodes to form graph. */
	/* Connect the header to the block node. */
d455 1
a455 1
	/* Connect the block node to the read nodes. */
d474 1
a474 1
	/* Connect the read nodes to the xor node. */
d493 1
a493 1
	/* Connect the xor node to the commit node. */
d500 1
a500 1
	/* Connect the termNode to the commit node. */
d510 2
a511 2
/*****************************************************************************
 * Create a degraded read DAG for Chained Declustering.
d519 5
a523 5
 * Parameters:  raidPtr	  - description of the physical array
 *		asmap	  - logical & physical addresses for this access
 *		bp	  - buffer ptr (for holding write data)
 *		flags	  - general flags (e.g. disk locking)
 *		allocList - list of memory allocated in DAG creation
d526 1
a526 1
void
d528 6
a533 7
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList
)
d537 1
a537 1
	int useMirror, i, shiftable;
d554 1
a554 1
	/* Alloc the Wnd nodes and the Wmir node. */
d561 1
a561 2
	RF_CallocAndAdd(nodes, 4, sizeof(RF_DagNode_t), (RF_DagNode_t *),
	    allocList);
d573 4
a576 4
	 * This dag can not commit until the commit node is reached.
	 * Errors prior to the commit point imply the dag has failed
	 * and must be retried.
	 */
d582 6
a587 6
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d591 1
a591 1
	/* ParityInfo must describe entire parity unit. */
d594 1
a594 1
	/* Initialize the data node. */
d596 2
a597 3
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rpd", allocList);
d599 1
a599 1
			/* Shift this read to the next disk in line. */
d603 1
a603 2
			rdNode->params[3].v = RF_CREATE_PARAM3(
			    RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d605 1
a605 1
			/* Read primary copy. */
d609 1
a609 2
			rdNode->params[3].v = RF_CREATE_PARAM3(
			    RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d612 3
a614 4
		/* Read secondary copy of data. */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rsd", allocList);
d618 1
a618 2
		rdNode->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d621 1
a621 1
	/* Connect header to block node. */
d626 1
a626 1
	/* Connect block node to rdnode. */
d633 1
a633 1
	/* Connect rdnode to commit node. */
d640 1
a640 1
	/* Connect commit node to terminator. */
a647 1

d649 1
a649 1
 * XXX move this elsewhere ?
d651 1
a651 1
void
d653 7
a659 8
    RF_Raid_t			 *raidPtr,
    RF_AccessStripeMap_t	 *asmap,
    RF_PhysDiskAddr_t		**pdap,
    int				 *nNodep,
    RF_PhysDiskAddr_t		**pqpdap,
    int				 *nPQNodep,
    RF_AllocListElem_t		 *allocList
)
d662 1
a662 1
	int PDAPerDisk, i;
d664 2
a665 2
	int numDataCol = layoutPtr->numDataCol;
	int state;
d669 1
a669 2
	RF_PhysDiskAddr_t *fone = asmap->failedPDAs[0];
	RF_PhysDiskAddr_t *ftwo = asmap->failedPDAs[1];
d674 1
a674 2
	/*
	 * Determine how many pda's we will have to generate per unaccessed
d676 1
a676 2
	 * possibly two, depending wether they overlap.
	 */
d681 6
a686 10
#define	CONS_PDA(if,start,num)		do {				\
	pda_p->row = asmap->if->row;					\
	pda_p->col = asmap->if->col;					\
	pda_p->startSector = ((asmap->if->startSector / secPerSU) *	\
	    secPerSU) + start;						\
	pda_p->numSector = num;						\
	pda_p->next = NULL;						\
	RF_MallocAndAdd(pda_p->bufPtr,					\
	    rf_RaidAddressToByte(raidPtr,num),(char *), allocList);	\
} while (0)
d691 1
a691 2
		RF_MallocAndAdd(*pqpdap, 2 * sizeof(RF_PhysDiskAddr_t),
		    (RF_PhysDiskAddr_t *), allocList);
d693 1
a693 1
		/* Build p. */
d697 1
a697 1
		/* Build q. */
d706 1
a706 2
			RF_MallocAndAdd(*pqpdap, 2 * sizeof(RF_PhysDiskAddr_t),
			    (RF_PhysDiskAddr_t *), allocList);
d716 2
a717 3
			/* Four of them, fone, then ftwo. */
			RF_MallocAndAdd(*pqpdap, 4 * sizeof(RF_PhysDiskAddr_t),
			    (RF_PhysDiskAddr_t *), allocList);
d732 2
a733 3
	/* Figure out number of nonaccessed pda. */
	napdas = PDAPerDisk * (numDataCol - asmap->numStripeUnitsAccessed -
	    (ftwo == NULL ? 1 : 0));
d736 2
a737 4
	/*
	 * Sweep over the over accessed pda's, figuring out the number of
	 * additional pda's to generate. Of course, skip the failed ones.
	 */
d746 3
a748 5
		case 1:	/* One failed PDA to overlap. */
			/*
			 * If a PDA doesn't contain the failed unit, it can
			 * only miss the start or end, not both.
			 */
d752 2
a753 2
		case 2:	/* Whole stripe. */
			if (suoff)			/* Leak at begining. */
d755 1
a755 1
			if (suend < numDataCol)		/* Leak at end. */
d758 1
a758 1
		case 3:	/* Two disjoint units. */
d774 1
a774 1
	/* Allocate up our list of pda's. */
d776 1
a776 2
	RF_CallocAndAdd(pda_p, napdas, sizeof(RF_PhysDiskAddr_t),
	    (RF_PhysDiskAddr_t *), allocList);
d779 1
a779 1
	/* Link them together. */
d783 3
a785 5
	/* March through the one's up to the first accessed disk. */
	firstDataCol = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
	    asmap->physInfo->raidAddress) % numDataCol;
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
	    asmap->raidAddress);
d791 2
a792 3
		(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress,
		    &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		/* Skip over dead disks. */
d796 1
a796 1
		case 1:	/* Fone. */
d800 1
a800 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d802 1
a802 1
		case 2:	/* Full stripe. */
d804 1
a804 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, secPerSU),
			    (char *), allocList);
d806 1
a806 1
		case 3:	/* Two slabs. */
d810 1
a810 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d814 1
a814 3
			(raidPtr->Layout.map->MapSector) (raidPtr,
			    pda_p->raidAddress, &(pda_p->row), &(pda_p->col),
			    &(pda_p->startSector), 0);
d818 1
a818 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d826 1
a826 1
	/* March through the touched stripe units. */
d828 1
a828 2
		if ((phys_p == asmap->failedPDAs[0]) ||
		    (phys_p == asmap->failedPDAs[1]))
d833 1
a833 1
		case 1:	/* Single buffer. */
d836 2
a837 4
				/*
				 * The data read starts after the mapped
				 * access, snip off the begining.
				 */
d839 3
a841 8
				pda_p->raidAddress = sosAddr + (i * secPerSU)
				    + fone_start;
				(raidPtr->Layout.map->MapSector) (raidPtr,
				    pda_p->raidAddress, &(pda_p->row),
				    &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr,
				    rf_RaidAddressToByte(raidPtr,
				    pda_p->numSector), (char *), allocList);
d846 2
a847 4
				/*
				 * The data read stops before the end of the
				 * failed access, extend.
				 */
d849 3
a851 8
				pda_p->raidAddress = sosAddr + (i * secPerSU)
				    + suend;	/* off by one? */
				(raidPtr->Layout.map->MapSector) (raidPtr,
				    pda_p->raidAddress, &(pda_p->row),
				    &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr,
				    rf_RaidAddressToByte(raidPtr,
				    pda_p->numSector), (char *), allocList);
d855 1
a855 1
		case 2:	/* Whole stripe unit. */
d857 2
a858 2
			if (suend < secPerSU) {
				/* Short read, snip from end on. */
d860 3
a862 8
				pda_p->raidAddress = sosAddr + (i * secPerSU)
				    + suend;	/* off by one? */
				(raidPtr->Layout.map->MapSector) (raidPtr,
				    pda_p->raidAddress, &(pda_p->row),
				    &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr,
				    rf_RaidAddressToByte(raidPtr,
				    pda_p->numSector), (char *), allocList);
d865 1
a865 2
				if (suoff > 0) {
					/* Short at front. */
d867 3
a869 10
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU);
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
d873 1
a873 1
		case 3:	/* Two nonoverlapping failures. */
d877 1
a877 2
					/*
					 * The data read starts after the
d879 1
a879 2
					 * begining.
					 */
d881 3
a883 10
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) + fone_start;
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
d888 2
a889 4
					/*
					 * The data read stops before the end
					 * of the failed access, extend.
					 */
d891 3
a893 11
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) +
					    suend;	/* Off by one ? */
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
d900 1
a900 2
					/*
					 * The data read starts after the
d902 1
a902 2
					 * begining.
					 */
d904 3
a906 10
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) + ftwo_start;
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
d911 2
a912 4
					/*
					 * The data read stops before the end
					 * of the failed access, extend.
					 */
d914 3
a916 11
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) +
					    suend;	/* Off by one ? */
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
d926 1
a926 1
	/* After the last accessed disk. */
d932 2
a933 3
		(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress,
		    &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		/* Skip over dead disks. */
d937 1
a937 1
		case 1:	/* Fone. */
d941 1
a941 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d943 1
a943 1
		case 2:	/* Full stripe. */
d945 1
a945 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, secPerSU),
			    (char *), allocList);
d947 1
a947 1
		case 3:	/* Two slabs. */
d951 1
a951 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d955 1
a955 3
			(raidPtr->Layout.map->MapSector) (raidPtr,
			    pda_p->raidAddress, &(pda_p->row), &(pda_p->col),
			    &(pda_p->startSector), 0);
d959 1
a959 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d970 12
d983 1
a983 19
#define	INIT_DISK_NODE(node,name)	do {				\
	rf_InitNode(node, rf_wait, RF_FALSE, rf_DiskReadFunc,		\
	    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 2,1,4,0,		\
	    dag_h, name, allocList);					\
	(node)->succedents[0] = unblockNode;				\
	(node)->succedents[1] = recoveryNode;				\
	(node)->antecedents[0] = blockNode;				\
	(node)->antType[0] = rf_control;				\
} while (0)

#define	DISK_NODE_PARAMS(_node_,_p_)	do {				\
	(_node_).params[0].p = _p_ ;					\
	(_node_).params[1].p = (_p_)->bufPtr;				\
	(_node_).params[2].v = parityStripeID;				\
	(_node_).params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,	\
	    0, 0, which_ru);						\
} while (0)

void
d985 9
a993 10
    RF_Raid_t			 *raidPtr,
    RF_AccessStripeMap_t	 *asmap,
    RF_DagHeader_t		 *dag_h,
    void			 *bp,
    RF_RaidAccessFlags_t	  flags,
    RF_AllocListElem_t		 *allocList,
    char			 *redundantReadNodeName,
    char			 *recoveryNodeName,
    int				(*recovFunc) (RF_DagNode_t *)
)
d997 1
a997 1
	    *unblockNode, *rpNodes, *rqNodes, *termNode;
d1000 1
a1000 1
	int nNodes, nRrdNodes, nRudNodes, i;
d1002 1
a1002 1
	int nReadNodes, nPQNodes;
d1005 1
a1005 2
	RF_StripeNum_t parityStripeID = rf_RaidAddressToParityStripeID(
	    layoutPtr, asmap->raidAddress, &which_ru);
d1009 1
a1009 2
	rf_DD_GenerateFailedAccessASMs(raidPtr, asmap, &npdas, &nRrdNodes,
	    &pqPDAs, &nPQNodes, allocList);
d1013 1
a1013 1
	nNodes = 4 /* Block, unblock, recovery, term. */ + nReadNodes;
d1015 1
a1015 2
	RF_CallocAndAdd(nodes, nNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *),
	    allocList);
d1039 1
a1039 1
	dag_h->numCommitNodes = 1;	/* Unblock. */
d1041 1
a1041 2
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 2, 0, 0, dag_h, "Trm", allocList);
d1047 5
a1051 12
	/*
	 * Init the block and unblock nodes.
	 * The block node has all nodes except itself, unblock and
	 * recovery as successors.
	 * Similarly for predecessors of the unblock.
	 */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nReadNodes, 0, 0, 0, dag_h,
	    "Nil", allocList);
	rf_InitNode(unblockNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, nReadNodes, 0, 0, dag_h,
	    "Nil", allocList);
d1060 1
a1060 2
	/*
	 * The recovery node has all the reads as predecessors, and the term
d1062 5
a1066 7
	 * nodes plus the raidPtr. For each failed unit is has a result pda.
	 */
	rf_InitNode(recoveryNode, rf_wait, RF_FALSE, recovFunc,
	    rf_NullNodeUndoFunc, NULL,
	    1,				/* succesors */
	    nReadNodes,			/* preds */
	    nReadNodes + 2,		/* params */
d1076 2
a1077 4
	/*
	 * Build the read nodes, then come back and fill in recovery params
	 * and results.
	 */
d1095 1
a1095 1
	/* Redundancy pdas. */
d1114 1
a1114 1
	/* Fill in recovery node params. */
d1116 1
a1116 1
		recoveryNode->params[i] = rudNodes[i].params[0]; /* pda */
d1123 1
a1123 1
	/* Zero fill the target data buffers ? */
@


1.4.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d33 1
a33 1
 * Code for creating degraded read DAGs.
d47 1
a47 1
/*****************************************************************************
d51 2
a52 2
 * All DAGs in this file use roll-away error recovery. Each DAG has a single
 * commit node, usually called "Cmt". If an error occurs before the Cmt node
d54 1
a54 1
 * backward through the graph, executing the undo functions. Assuming that
d63 1
a63 1
 *****************************************************************************/
d66 1
a66 1
/*****************************************************************************
d69 1
a69 1
 * DAG creation routines. Additionally, these wrappers enable experimentation
d72 1
a72 2
 *
 *****************************************************************************/
d74 1
a74 1
void
d76 6
a81 6
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList)
d88 1
a88 1
/*****************************************************************************
d90 2
a91 3
 * DAG creation code begins here.
 *
 *****************************************************************************/
d94 2
a95 2
/*****************************************************************************
 * Create a degraded read DAG for RAID level 1.
d99 1
a99 1
 * The "Rd" node reads data from the surviving disk in the mirror pair.
d103 5
a107 5
 * Parameters:	raidPtr	  - description of the physical array
 *		asmap	  - logical & physical addresses for this access
 *		bp	  - buffer ptr (for holding write data)
 *		flags	  - general flags (e.g. disk locking)
 *		allocList - list of memory allocated in DAG creation
d110 1
a110 1
void
d112 6
a117 6
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList)
d123 1
a123 1
	int useMirror, i;
d132 1
a132 1
	/* Alloc the Wnd nodes and the Wmir node. */
d138 2
a139 3
	/* Total number of nodes = 1 + (block + commit + terminator). */
	RF_CallocAndAdd(nodes, 4, sizeof(RF_DagNode_t), (RF_DagNode_t *),
	    allocList);
d150 1
a150 2
	/*
	 * This dag can not commit until the commit node is reached. Errors
d152 1
a152 2
	 * retried.
	 */
d157 7
a163 7
	/* Initialize the block, commit, and terminator nodes. */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d167 1
a167 1
	/* parityInfo must describe entire parity unit. */
d170 1
a170 1
	/* Initialize the data node. */
d172 3
a174 4
		/* Read primary copy of data. */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rpd", allocList);
d178 1
a178 2
		rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
		    0, 0, which_ru);
d180 3
a182 4
		/* Read secondary copy of data. */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rsd", allocList);
d186 1
a186 2
		rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
		    0, 0, which_ru);
d189 1
a189 1
	/* Connect header to block node. */
d194 1
a194 1
	/* Connect block node to rdnode. */
d201 1
a201 1
	/* Connect rdnode to commit node. */
d208 1
a208 1
	/* Connect commit node to terminator. */
d218 2
a219 1
/*****************************************************************************
d221 1
a221 1
 * Create a DAG to perform a degraded-mode read of data within one stripe.
d225 2
a226 2
 *		-> Rrd ->
 *		-> Rp -->
d228 2
a229 2
 * Each R node is a successor of the L node.
 * One successor arc from each R node goes to C, and the other to X.
d232 1
a232 1
 * the user.
d239 2
a240 2
 * where the failed data is supposed to end up. This buffer is zero'd by the
 * code here. Thus, if you create a degraded read dag, use it, and then
d244 2
a245 1
 * the redundancy recovery function.
d249 1
a249 1
void
d251 7
a257 7
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList,
    RF_RedFuncs_t		*recFunc)
d261 2
a262 2
	int nNodes, nRrdNodes, nRudNodes, nXorBufs, i;
	int j, paramNum;
d265 1
a265 1
	char *overlappingPDAs;		/* A temporary array of flags. */
d271 1
a271 1
	char *rpBuf;
d274 2
a275 4
	/*
	 * failedPDA points to the pda within the asm that targets
	 * the failed disk.
	 */
d288 8
a295 9
	 * Generate two ASMs identifying the surviving data we need
	 * in order to recover the lost data.
	 */

	/* overlappingPDAs array must be zero'd. */
	RF_Calloc(overlappingPDAs, asmap->numStripeUnitsAccessed,
	    sizeof(char), (char *));
	rf_GenerateFailedAccessASMs(raidPtr, asmap, failedPDA, dag_h,
	    new_asm_h, &nXorBufs, &rpBuf, overlappingPDAs, allocList);
d298 4
a301 4
	 * Create all the nodes at once.
	 *
	 * -1 because no access is generated for the failed pda.
	 */
d303 4
a306 8
	nRrdNodes = ((new_asm_h[0]) ?
	    new_asm_h[0]->stripeMap->numStripeUnitsAccessed : 0) +
	    ((new_asm_h[1]) ?
	    new_asm_h[1]->stripeMap->numStripeUnitsAccessed : 0);
	nNodes = 5 + nRudNodes + nRrdNodes;	/*
						 * lock, unlock, xor, Rp,
						 * Rud, Rrd
						 */
d326 1
a326 1
	/* Initialize nodes. */
d329 2
a330 4
	/*
	 * This dag can not commit until the commit node is reached.
	 * Errors prior to the commit point imply the dag has failed.
	 */
d333 12
a344 14
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nRudNodes + nRrdNodes + 1, 0, 0, 0,
	    dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
	rf_InitNode(xorNode, rf_wait, RF_FALSE, recFunc->simple,
	    rf_NullNodeUndoFunc, NULL, 1, nRudNodes + nRrdNodes + 1,
	    2 * nXorBufs + 2, 1, dag_h, recFunc->SimpleName, allocList);

	/* Fill in the Rud nodes. */
	for (pda = asmap->physInfo, i = 0; i < nRudNodes;
	     i++, pda = pda->next) {
d350 2
a351 2
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rud", allocList);
d356 1
a356 2
		rudNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d359 1
a359 1
	/* Fill in the Rrd nodes. */
d363 5
a367 6
		     i < new_asm_h[0]->stripeMap->numStripeUnitsAccessed;
		     i++, pda = pda->next) {
			rf_InitNode(&rrdNodes[i], rf_wait, RF_FALSE,
			    rf_DiskReadFunc, rf_DiskReadUndoFunc,
			    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
			    "Rrd", allocList);
d372 1
a372 3
			rrdNodes[i].params[3].v =
			    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0,
			    which_ru);
d379 3
a381 4
			rf_InitNode(&rrdNodes[i + j], rf_wait, RF_FALSE,
			    rf_DiskReadFunc, rf_DiskReadUndoFunc,
			    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
			    "Rrd", allocList);
d386 1
a386 3
			rrdNodes[i + j].params[3].v =
			    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0,
			    which_ru);
d389 2
a390 3
	/* Make a PDA for the parity unit. */
	RF_MallocAndAdd(parityPDA, sizeof(RF_PhysDiskAddr_t),
	    (RF_PhysDiskAddr_t *), allocList);
d393 2
a394 3
	parityPDA->startSector = ((asmap->parityInfo->startSector /
	    sectorsPerSU) * sectorsPerSU) +
	    (failedPDA->startSector % sectorsPerSU);
d397 3
a399 4
	/* Initialize the Rp node. */
	rf_InitNode(rpNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
	    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
	    "Rp ", allocList);
d403 1
a403 2
	rpNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0,
	    which_ru);
d406 3
a408 3
	 * The last and nastiest step is to assign all
	 * the parameters of the Xor node.
	 */
d411 1
a411 1
		/* All the Rrd nodes need to be xored together. */
d416 2
a417 2
		/* Any Rud nodes that overlap the failed access need to be
		 * xored in. */
d419 3
a421 6
			RF_MallocAndAdd(pda, sizeof(RF_PhysDiskAddr_t),
			    (RF_PhysDiskAddr_t *), allocList);
			bcopy((char *) rudNodes[i].params[0].p, (char *) pda,
			    sizeof(RF_PhysDiskAddr_t));
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda,
			    RF_RESTRICT_DOBUFFER, 0);
d428 1
a428 1
	/* Install parity pda as last set of params to be xor'd. */
d433 3
a435 3
	 * The last 2 params to the recovery xor node are
	 * the failed PDA and the raidPtr.
	 */
d441 4
a444 4
	 * The xor node uses results[0] as the target buffer.
	 * Set pointer and zero the buffer. In the kernel, this
	 * may be a user buffer in which case we have to remap it.
	 */
d447 1
a447 1
	    failedPDA->numSector));
d449 2
a450 2
	/* Connect nodes to form graph. */
	/* Connect the header to the block node. */
d455 1
a455 1
	/* Connect the block node to the read nodes. */
d474 1
a474 1
	/* Connect the read nodes to the xor node. */
d493 1
a493 1
	/* Connect the xor node to the commit node. */
d500 1
a500 1
	/* Connect the termNode to the commit node. */
d510 2
a511 2
/*****************************************************************************
 * Create a degraded read DAG for Chained Declustering.
d519 5
a523 5
 * Parameters:  raidPtr	  - description of the physical array
 *		asmap	  - logical & physical addresses for this access
 *		bp	  - buffer ptr (for holding write data)
 *		flags	  - general flags (e.g. disk locking)
 *		allocList - list of memory allocated in DAG creation
d526 1
a526 1
void
d528 6
a533 7
    RF_Raid_t			*raidPtr,
    RF_AccessStripeMap_t	*asmap,
    RF_DagHeader_t		*dag_h,
    void			*bp,
    RF_RaidAccessFlags_t	 flags,
    RF_AllocListElem_t		*allocList
)
d537 1
a537 1
	int useMirror, i, shiftable;
d554 1
a554 1
	/* Alloc the Wnd nodes and the Wmir node. */
d561 1
a561 2
	RF_CallocAndAdd(nodes, 4, sizeof(RF_DagNode_t), (RF_DagNode_t *),
	    allocList);
d573 4
a576 4
	 * This dag can not commit until the commit node is reached.
	 * Errors prior to the commit point imply the dag has failed
	 * and must be retried.
	 */
d582 6
a587 6
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d591 1
a591 1
	/* ParityInfo must describe entire parity unit. */
d594 1
a594 1
	/* Initialize the data node. */
d596 2
a597 3
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rpd", allocList);
d599 1
a599 1
			/* Shift this read to the next disk in line. */
d603 1
a603 2
			rdNode->params[3].v = RF_CREATE_PARAM3(
			    RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d605 1
a605 1
			/* Read primary copy. */
d609 1
a609 2
			rdNode->params[3].v = RF_CREATE_PARAM3(
			    RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d612 3
a614 4
		/* Read secondary copy of data. */
		rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc,
		    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
		    dag_h, "Rsd", allocList);
d618 1
a618 2
		rdNode->params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
d621 1
a621 1
	/* Connect header to block node. */
d626 1
a626 1
	/* Connect block node to rdnode. */
d633 1
a633 1
	/* Connect rdnode to commit node. */
d640 1
a640 1
	/* Connect commit node to terminator. */
a647 1

d649 1
a649 1
 * XXX move this elsewhere ?
d651 1
a651 1
void
d653 7
a659 8
    RF_Raid_t			 *raidPtr,
    RF_AccessStripeMap_t	 *asmap,
    RF_PhysDiskAddr_t		**pdap,
    int				 *nNodep,
    RF_PhysDiskAddr_t		**pqpdap,
    int				 *nPQNodep,
    RF_AllocListElem_t		 *allocList
)
d662 1
a662 1
	int PDAPerDisk, i;
d664 2
a665 2
	int numDataCol = layoutPtr->numDataCol;
	int state;
d669 1
a669 2
	RF_PhysDiskAddr_t *fone = asmap->failedPDAs[0];
	RF_PhysDiskAddr_t *ftwo = asmap->failedPDAs[1];
d674 1
a674 2
	/*
	 * Determine how many pda's we will have to generate per unaccessed
d676 1
a676 2
	 * possibly two, depending wether they overlap.
	 */
d681 6
a686 10
#define	CONS_PDA(if,start,num)		do {				\
	pda_p->row = asmap->if->row;					\
	pda_p->col = asmap->if->col;					\
	pda_p->startSector = ((asmap->if->startSector / secPerSU) *	\
	    secPerSU) + start;						\
	pda_p->numSector = num;						\
	pda_p->next = NULL;						\
	RF_MallocAndAdd(pda_p->bufPtr,					\
	    rf_RaidAddressToByte(raidPtr,num),(char *), allocList);	\
} while (0)
d691 1
a691 2
		RF_MallocAndAdd(*pqpdap, 2 * sizeof(RF_PhysDiskAddr_t),
		    (RF_PhysDiskAddr_t *), allocList);
d693 1
a693 1
		/* Build p. */
d697 1
a697 1
		/* Build q. */
d706 1
a706 2
			RF_MallocAndAdd(*pqpdap, 2 * sizeof(RF_PhysDiskAddr_t),
			    (RF_PhysDiskAddr_t *), allocList);
d716 2
a717 3
			/* Four of them, fone, then ftwo. */
			RF_MallocAndAdd(*pqpdap, 4 * sizeof(RF_PhysDiskAddr_t),
			    (RF_PhysDiskAddr_t *), allocList);
d732 2
a733 3
	/* Figure out number of nonaccessed pda. */
	napdas = PDAPerDisk * (numDataCol - asmap->numStripeUnitsAccessed -
	    (ftwo == NULL ? 1 : 0));
d736 2
a737 4
	/*
	 * Sweep over the over accessed pda's, figuring out the number of
	 * additional pda's to generate. Of course, skip the failed ones.
	 */
d746 3
a748 5
		case 1:	/* One failed PDA to overlap. */
			/*
			 * If a PDA doesn't contain the failed unit, it can
			 * only miss the start or end, not both.
			 */
d752 2
a753 2
		case 2:	/* Whole stripe. */
			if (suoff)			/* Leak at begining. */
d755 1
a755 1
			if (suend < numDataCol)		/* Leak at end. */
d758 1
a758 1
		case 3:	/* Two disjoint units. */
d774 1
a774 1
	/* Allocate up our list of pda's. */
d776 1
a776 2
	RF_CallocAndAdd(pda_p, napdas, sizeof(RF_PhysDiskAddr_t),
	    (RF_PhysDiskAddr_t *), allocList);
d779 1
a779 1
	/* Link them together. */
d783 3
a785 5
	/* March through the one's up to the first accessed disk. */
	firstDataCol = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
	    asmap->physInfo->raidAddress) % numDataCol;
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
	    asmap->raidAddress);
d791 2
a792 3
		(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress,
		    &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		/* Skip over dead disks. */
d796 1
a796 1
		case 1:	/* Fone. */
d800 1
a800 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d802 1
a802 1
		case 2:	/* Full stripe. */
d804 1
a804 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, secPerSU),
			    (char *), allocList);
d806 1
a806 1
		case 3:	/* Two slabs. */
d810 1
a810 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d814 1
a814 3
			(raidPtr->Layout.map->MapSector) (raidPtr,
			    pda_p->raidAddress, &(pda_p->row), &(pda_p->col),
			    &(pda_p->startSector), 0);
d818 1
a818 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d826 1
a826 1
	/* March through the touched stripe units. */
d828 1
a828 2
		if ((phys_p == asmap->failedPDAs[0]) ||
		    (phys_p == asmap->failedPDAs[1]))
d833 1
a833 1
		case 1:	/* Single buffer. */
d836 2
a837 4
				/*
				 * The data read starts after the mapped
				 * access, snip off the begining.
				 */
d839 3
a841 8
				pda_p->raidAddress = sosAddr + (i * secPerSU)
				    + fone_start;
				(raidPtr->Layout.map->MapSector) (raidPtr,
				    pda_p->raidAddress, &(pda_p->row),
				    &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr,
				    rf_RaidAddressToByte(raidPtr,
				    pda_p->numSector), (char *), allocList);
d846 2
a847 4
				/*
				 * The data read stops before the end of the
				 * failed access, extend.
				 */
d849 3
a851 8
				pda_p->raidAddress = sosAddr + (i * secPerSU)
				    + suend;	/* off by one? */
				(raidPtr->Layout.map->MapSector) (raidPtr,
				    pda_p->raidAddress, &(pda_p->row),
				    &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr,
				    rf_RaidAddressToByte(raidPtr,
				    pda_p->numSector), (char *), allocList);
d855 1
a855 1
		case 2:	/* Whole stripe unit. */
d857 2
a858 2
			if (suend < secPerSU) {
				/* Short read, snip from end on. */
d860 3
a862 8
				pda_p->raidAddress = sosAddr + (i * secPerSU)
				    + suend;	/* off by one? */
				(raidPtr->Layout.map->MapSector) (raidPtr,
				    pda_p->raidAddress, &(pda_p->row),
				    &(pda_p->col), &(pda_p->startSector), 0);
				RF_MallocAndAdd(pda_p->bufPtr,
				    rf_RaidAddressToByte(raidPtr,
				    pda_p->numSector), (char *), allocList);
d865 1
a865 2
				if (suoff > 0) {
					/* Short at front. */
d867 3
a869 10
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU);
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
d873 1
a873 1
		case 3:	/* Two nonoverlapping failures. */
d877 1
a877 2
					/*
					 * The data read starts after the
d879 1
a879 2
					 * begining.
					 */
d881 3
a883 10
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) + fone_start;
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
d888 2
a889 4
					/*
					 * The data read stops before the end
					 * of the failed access, extend.
					 */
d891 3
a893 11
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) +
					    suend;	/* Off by one ? */
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
d900 1
a900 2
					/*
					 * The data read starts after the
d902 1
a902 2
					 * begining.
					 */
d904 3
a906 10
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) + ftwo_start;
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
d911 2
a912 4
					/*
					 * The data read stops before the end
					 * of the failed access, extend.
					 */
d914 3
a916 11
					pda_p->raidAddress = sosAddr +
					    (i * secPerSU) +
					    suend;	/* Off by one ? */
					(raidPtr->Layout.map->MapSector)
					    (raidPtr, pda_p->raidAddress,
					    &(pda_p->row), &(pda_p->col),
					    &(pda_p->startSector), 0);
					RF_MallocAndAdd(pda_p->bufPtr,
					    rf_RaidAddressToByte(raidPtr,
					    pda_p->numSector), (char *),
					    allocList);
d926 1
a926 1
	/* After the last accessed disk. */
d932 2
a933 3
		(raidPtr->Layout.map->MapSector) (raidPtr, pda_p->raidAddress,
		    &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		/* Skip over dead disks. */
d937 1
a937 1
		case 1:	/* Fone. */
d941 1
a941 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d943 1
a943 1
		case 2:	/* Full stripe. */
d945 1
a945 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, secPerSU),
			    (char *), allocList);
d947 1
a947 1
		case 3:	/* Two slabs. */
d951 1
a951 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d955 1
a955 3
			(raidPtr->Layout.map->MapSector) (raidPtr,
			    pda_p->raidAddress, &(pda_p->row), &(pda_p->col),
			    &(pda_p->startSector), 0);
d959 1
a959 3
			RF_MallocAndAdd(pda_p->bufPtr,
			    rf_RaidAddressToByte(raidPtr, pda_p->numSector),
			    (char *), allocList);
d970 12
d983 1
a983 19
#define	INIT_DISK_NODE(node,name)	do {				\
	rf_InitNode(node, rf_wait, RF_FALSE, rf_DiskReadFunc,		\
	    rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 2,1,4,0,		\
	    dag_h, name, allocList);					\
	(node)->succedents[0] = unblockNode;				\
	(node)->succedents[1] = recoveryNode;				\
	(node)->antecedents[0] = blockNode;				\
	(node)->antType[0] = rf_control;				\
} while (0)

#define	DISK_NODE_PARAMS(_node_,_p_)	do {				\
	(_node_).params[0].p = _p_ ;					\
	(_node_).params[1].p = (_p_)->bufPtr;				\
	(_node_).params[2].v = parityStripeID;				\
	(_node_).params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,	\
	    0, 0, which_ru);						\
} while (0)

void
d985 9
a993 10
    RF_Raid_t			 *raidPtr,
    RF_AccessStripeMap_t	 *asmap,
    RF_DagHeader_t		 *dag_h,
    void			 *bp,
    RF_RaidAccessFlags_t	  flags,
    RF_AllocListElem_t		 *allocList,
    char			 *redundantReadNodeName,
    char			 *recoveryNodeName,
    int				(*recovFunc) (RF_DagNode_t *)
)
d997 1
a997 1
	    *unblockNode, *rpNodes, *rqNodes, *termNode;
d1000 1
a1000 1
	int nNodes, nRrdNodes, nRudNodes, i;
d1002 1
a1002 1
	int nReadNodes, nPQNodes;
d1005 1
a1005 2
	RF_StripeNum_t parityStripeID = rf_RaidAddressToParityStripeID(
	    layoutPtr, asmap->raidAddress, &which_ru);
d1009 1
a1009 2
	rf_DD_GenerateFailedAccessASMs(raidPtr, asmap, &npdas, &nRrdNodes,
	    &pqPDAs, &nPQNodes, allocList);
d1013 1
a1013 1
	nNodes = 4 /* Block, unblock, recovery, term. */ + nReadNodes;
d1015 1
a1015 2
	RF_CallocAndAdd(nodes, nNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *),
	    allocList);
d1039 1
a1039 1
	dag_h->numCommitNodes = 1;	/* Unblock. */
d1041 1
a1041 2
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 2, 0, 0, dag_h, "Trm", allocList);
d1047 5
a1051 12
	/*
	 * Init the block and unblock nodes.
	 * The block node has all nodes except itself, unblock and
	 * recovery as successors.
	 * Similarly for predecessors of the unblock.
	 */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, nReadNodes, 0, 0, 0, dag_h,
	    "Nil", allocList);
	rf_InitNode(unblockNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, nReadNodes, 0, 0, dag_h,
	    "Nil", allocList);
d1060 1
a1060 2
	/*
	 * The recovery node has all the reads as predecessors, and the term
d1062 5
a1066 7
	 * nodes plus the raidPtr. For each failed unit is has a result pda.
	 */
	rf_InitNode(recoveryNode, rf_wait, RF_FALSE, recovFunc,
	    rf_NullNodeUndoFunc, NULL,
	    1,				/* succesors */
	    nReadNodes,			/* preds */
	    nReadNodes + 2,		/* params */
d1076 2
a1077 4
	/*
	 * Build the read nodes, then come back and fill in recovery params
	 * and results.
	 */
d1095 1
a1095 1
	/* Redundancy pdas. */
d1114 1
a1114 1
	/* Fill in recovery node params. */
d1116 1
a1116 1
		recoveryNode->params[i] = rudNodes[i].params[0]; /* pda */
d1123 1
a1123 1
	/* Zero fill the target data buffers ? */
@


1.3
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagdegrd.c,v 1.2 1999/02/16 00:02:29 niklas Exp $	*/
/*	$NetBSD: rf_dagdegrd.c,v 1.4 1999/08/13 03:41:53 oster Exp $	*/
a40 1
#include "rf_threadid.h"
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagdegrd.c,v 1.1 1999/01/11 14:29:06 niklas Exp $	*/
/*	$NetBSD: rf_dagdegrd.c,v 1.3 1999/02/05 00:06:07 oster Exp $	*/
a45 1
#include "rf_sys.h"
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagdegrd.c,v 1.1 1998/11/13 04:20:27 oster Exp $	*/
/*	$NetBSD: rf_dagdegrd.c,v 1.1 1998/11/13 04:20:27 oster Exp $	*/
a33 90
 *
 * :  
 * Log: rf_dagdegrd.c,v 
 * Revision 1.20  1996/11/05 21:10:40  jimz
 * failed pda generalization
 *
 * Revision 1.19  1996/08/19  23:30:36  jimz
 * fix chained declustered accesses in degraded mode when mirror copy is failed
 * (workload shifting not allowed when there are no duplicate copies extant)
 *
 * Revision 1.18  1996/07/31  16:29:01  jimz
 * asm/asmap re-fix (EO merge)
 *
 * Revision 1.17  1996/07/31  15:34:34  jimz
 * evenodd changes; bugfixes for double-degraded archs, generalize
 * some formerly PQ-only functions
 *
 * Revision 1.16  1996/07/28  20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.15  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.14  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.13  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.12  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.11  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.10  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.9  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.8  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.7  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.6  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.5  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.4  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.3  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.2  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.1  1996/05/03  19:22:23  wvcii
 * Initial revision
 *
d52 1
a52 1
 * 
d76 8
a83 7
void rf_CreateRaidFiveDegradedReadDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList)
d85 2
a86 2
  rf_CreateDegradedReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
    &rf_xorRecoveryFuncs);
d108 1
a108 1
 *              flags     - general flags (e.g. disk locking) 
d112 8
a119 7
void rf_CreateRaidOneDegradedReadDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList)
d121 96
a216 93
  RF_DagNode_t *nodes, *rdNode, *blockNode, *commitNode, *termNode;
  RF_StripeNum_t parityStripeID;
  RF_ReconUnitNum_t which_ru;
  RF_PhysDiskAddr_t *pda;
  int useMirror, i;

  useMirror = 0;
  parityStripeID = rf_RaidAddressToParityStripeID(&(raidPtr->Layout),
    asmap->raidAddress, &which_ru);
  if (rf_dagDebug) {
    printf("[Creating RAID level 1 degraded read DAG]\n");
  }
  dag_h->creator = "RaidOneDegradedReadDAG";
  /* alloc the Wnd nodes and the Wmir node */
  if (asmap->numDataFailed == 0)
    useMirror = RF_FALSE;
  else
    useMirror = RF_TRUE;

  /* total number of nodes = 1 + (block + commit + terminator) */
  RF_CallocAndAdd(nodes, 4, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
  i = 0;
  rdNode      = &nodes[i]; i++;
  blockNode   = &nodes[i]; i++;
  commitNode = &nodes[i]; i++;
  termNode    = &nodes[i]; i++;

  /* this dag can not commit until the commit node is reached.   errors prior
   * to the commit point imply the dag has failed and must be retried
   */
  dag_h->numCommitNodes = 1;
  dag_h->numCommits = 0;
  dag_h->numSuccedents = 1;

  /* initialize the block, commit, and terminator nodes */
  rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
    NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
  rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
    NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
  rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,
    NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);

  pda = asmap->physInfo;
  RF_ASSERT(pda != NULL);
  /* parityInfo must describe entire parity unit */
  RF_ASSERT(asmap->parityInfo->next == NULL);

  /* initialize the data node */
  if (!useMirror) {
    /* read primary copy of data */
    rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc,
      rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rpd", allocList);
    rdNode->params[0].p = pda;
    rdNode->params[1].p = pda->bufPtr;
    rdNode->params[2].v = parityStripeID;
    rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
  }
  else {
    /* read secondary copy of data */
    rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc,
      rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rsd", allocList);
    rdNode->params[0].p = asmap->parityInfo;
    rdNode->params[1].p = pda->bufPtr;
    rdNode->params[2].v = parityStripeID;
    rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
  }

  /* connect header to block node */
  RF_ASSERT(dag_h->numSuccedents == 1);
  RF_ASSERT(blockNode->numAntecedents == 0);
  dag_h->succedents[0] = blockNode;

  /* connect block node to rdnode */
  RF_ASSERT(blockNode->numSuccedents == 1);
  RF_ASSERT(rdNode->numAntecedents == 1);
  blockNode->succedents[0] = rdNode;
  rdNode->antecedents[0] = blockNode;
  rdNode->antType[0] = rf_control;

  /* connect rdnode to commit node */
  RF_ASSERT(rdNode->numSuccedents == 1);
  RF_ASSERT(commitNode->numAntecedents == 1);
  rdNode->succedents[0] = commitNode;
  commitNode->antecedents[0] = rdNode;
  commitNode->antType[0] = rf_control;

  /* connect commit node to terminator */
  RF_ASSERT(commitNode->numSuccedents == 1);
  RF_ASSERT(termNode->numAntecedents == 1);
  RF_ASSERT(termNode->numSuccedents == 0);
  commitNode->succedents[0] = termNode;
  termNode->antecedents[0] = commitNode;
  termNode->antType[0] = rf_control;
d247 1
a247 1
 * recovery function. 
d251 9
a259 8
void rf_CreateDegradedReadDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList,
  RF_RedFuncs_t         *recFunc)
d261 248
a508 240
  RF_DagNode_t *nodes, *rudNodes, *rrdNodes, *xorNode, *blockNode;
  RF_DagNode_t *commitNode, *rpNode, *termNode;
  int nNodes, nRrdNodes, nRudNodes, nXorBufs, i;
  int j, paramNum;
  RF_SectorCount_t sectorsPerSU;
  RF_ReconUnitNum_t which_ru;
  char *overlappingPDAs; /* a temporary array of flags */
  RF_AccessStripeMapHeader_t *new_asm_h[2];
  RF_PhysDiskAddr_t *pda, *parityPDA;
  RF_StripeNum_t parityStripeID;
  RF_PhysDiskAddr_t *failedPDA;
  RF_RaidLayout_t *layoutPtr;
  char *rpBuf;

  layoutPtr = &(raidPtr->Layout);
  /* failedPDA points to the pda within the asm that targets the failed disk */
  failedPDA = asmap->failedPDAs[0];
  parityStripeID = rf_RaidAddressToParityStripeID(layoutPtr,
    asmap->raidAddress, &which_ru);
  sectorsPerSU = layoutPtr->sectorsPerStripeUnit;

  if (rf_dagDebug) {
    printf("[Creating degraded read DAG]\n");
  }

  RF_ASSERT( asmap->numDataFailed == 1 );
  dag_h->creator = "DegradedReadDAG";

  /*
   * generate two ASMs identifying the surviving data we need
   * in order to recover the lost data
   */

  /* overlappingPDAs array must be zero'd */
  RF_Calloc(overlappingPDAs, asmap->numStripeUnitsAccessed, sizeof(char), (char *));
  rf_GenerateFailedAccessASMs(raidPtr, asmap, failedPDA, dag_h, new_asm_h, &nXorBufs,
    &rpBuf, overlappingPDAs, allocList);

  /*
   * create all the nodes at once
   *
   * -1 because no access is generated for the failed pda
   */
  nRudNodes = asmap->numStripeUnitsAccessed-1;
  nRrdNodes = ((new_asm_h[0]) ? new_asm_h[0]->stripeMap->numStripeUnitsAccessed : 0) +
              ((new_asm_h[1]) ? new_asm_h[1]->stripeMap->numStripeUnitsAccessed : 0);
  nNodes = 5 + nRudNodes + nRrdNodes; /* lock, unlock, xor, Rp, Rud, Rrd */
  RF_CallocAndAdd(nodes, nNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *),
    allocList);
  i = 0;
  blockNode   = &nodes[i]; i++;
  commitNode  = &nodes[i]; i++;
  xorNode     = &nodes[i]; i++;
  rpNode      = &nodes[i]; i++;
  termNode    = &nodes[i]; i++;
  rudNodes    = &nodes[i]; i += nRudNodes;
  rrdNodes    = &nodes[i]; i += nRrdNodes;
  RF_ASSERT(i == nNodes);

  /* initialize nodes */
  dag_h->numCommitNodes = 1;
  dag_h->numCommits = 0;
  /* this dag can not commit until the commit node is reached
   * errors prior to the commit point imply the dag has failed
   */
  dag_h->numSuccedents = 1;

  rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
    NULL, nRudNodes+nRrdNodes+1, 0, 0, 0, dag_h, "Nil", allocList);
  rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
    NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
  rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,
    NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
  rf_InitNode(xorNode, rf_wait, RF_FALSE, recFunc->simple, rf_NullNodeUndoFunc,
    NULL, 1, nRudNodes+nRrdNodes+1, 2*nXorBufs+2, 1, dag_h, 
	recFunc->SimpleName, allocList);

  /* fill in the Rud nodes */
  for (pda=asmap->physInfo, i=0; i<nRudNodes; i++, pda=pda->next) {
    if (pda == failedPDA) {i--; continue;}
    rf_InitNode(&rudNodes[i], rf_wait, RF_FALSE, rf_DiskReadFunc,
      rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h,
      "Rud", allocList);
    RF_ASSERT(pda);
    rudNodes[i].params[0].p = pda;
    rudNodes[i].params[1].p = pda->bufPtr;
    rudNodes[i].params[2].v = parityStripeID;
    rudNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
  }

  /* fill in the Rrd nodes */
  i = 0;
  if (new_asm_h[0]) {
    for (pda=new_asm_h[0]->stripeMap->physInfo;
         i<new_asm_h[0]->stripeMap->numStripeUnitsAccessed;
         i++, pda=pda->next)
    {
      rf_InitNode(&rrdNodes[i], rf_wait, RF_FALSE, rf_DiskReadFunc,
        rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
        dag_h, "Rrd", allocList);
      RF_ASSERT(pda);
      rrdNodes[i].params[0].p = pda;
      rrdNodes[i].params[1].p = pda->bufPtr;
      rrdNodes[i].params[2].v = parityStripeID;
      rrdNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
    }
  }
  if (new_asm_h[1]) {
    for (j=0,pda=new_asm_h[1]->stripeMap->physInfo;
         j<new_asm_h[1]->stripeMap->numStripeUnitsAccessed;
         j++, pda=pda->next)
    {
      rf_InitNode(&rrdNodes[i+j], rf_wait, RF_FALSE, rf_DiskReadFunc,
        rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0,
        dag_h, "Rrd", allocList);
      RF_ASSERT(pda);
      rrdNodes[i+j].params[0].p = pda;
      rrdNodes[i+j].params[1].p = pda->bufPtr;
      rrdNodes[i+j].params[2].v = parityStripeID;
      rrdNodes[i+j].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
    }
  }

  /* make a PDA for the parity unit */
  RF_MallocAndAdd(parityPDA, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *), allocList);
  parityPDA->row = asmap->parityInfo->row;
  parityPDA->col = asmap->parityInfo->col;
  parityPDA->startSector = ((asmap->parityInfo->startSector / sectorsPerSU)
    * sectorsPerSU) + (failedPDA->startSector % sectorsPerSU);
  parityPDA->numSector = failedPDA->numSector;

  /* initialize the Rp node */
  rf_InitNode(rpNode, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc,
    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rp ", allocList);
  rpNode->params[0].p = parityPDA;
  rpNode->params[1].p = rpBuf;
  rpNode->params[2].v = parityStripeID;
  rpNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);

  /*
   * the last and nastiest step is to assign all
   * the parameters of the Xor node
   */
  paramNum=0;
  for (i=0; i<nRrdNodes; i++) {
    /* all the Rrd nodes need to be xored together */
    xorNode->params[paramNum++] = rrdNodes[i].params[0];
    xorNode->params[paramNum++] = rrdNodes[i].params[1];
  }
  for (i=0; i<nRudNodes; i++) {
    /* any Rud nodes that overlap the failed access need to be xored in */
    if (overlappingPDAs[i]) {
      RF_MallocAndAdd(pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *), allocList);
      bcopy((char *)rudNodes[i].params[0].p, (char *)pda, sizeof(RF_PhysDiskAddr_t));
      rf_RangeRestrictPDA(raidPtr, failedPDA, pda, RF_RESTRICT_DOBUFFER, 0);
      xorNode->params[paramNum++].p = pda;
      xorNode->params[paramNum++].p = pda->bufPtr;
    }
  }
  RF_Free(overlappingPDAs, asmap->numStripeUnitsAccessed * sizeof(char));

  /* install parity pda as last set of params to be xor'd */
  xorNode->params[paramNum++].p = parityPDA;
  xorNode->params[paramNum++].p = rpBuf;

  /*
   * the last 2 params to the recovery xor node are
   * the failed PDA and the raidPtr
   */
  xorNode->params[paramNum++].p = failedPDA;
  xorNode->params[paramNum++].p = raidPtr;
  RF_ASSERT( paramNum == 2*nXorBufs+2 );

  /*
   * The xor node uses results[0] as the target buffer.
   * Set pointer and zero the buffer. In the kernel, this
   * may be a user buffer in which case we have to remap it.
   */
  xorNode->results[0] = failedPDA->bufPtr;
  RF_BZERO(bp, failedPDA->bufPtr, rf_RaidAddressToByte(raidPtr,
    failedPDA->numSector));

  /* connect nodes to form graph */
  /* connect the header to the block node */
  RF_ASSERT(dag_h->numSuccedents == 1);
  RF_ASSERT(blockNode->numAntecedents == 0);
  dag_h->succedents[0] = blockNode;

  /* connect the block node to the read nodes */
  RF_ASSERT(blockNode->numSuccedents == (1 + nRrdNodes + nRudNodes));
  RF_ASSERT(rpNode->numAntecedents == 1);
  blockNode->succedents[0] = rpNode;
  rpNode->antecedents[0] = blockNode;
  rpNode->antType[0] = rf_control;
  for (i = 0; i < nRrdNodes; i++) {
    RF_ASSERT(rrdNodes[i].numSuccedents == 1);
    blockNode->succedents[1 + i] = &rrdNodes[i];
    rrdNodes[i].antecedents[0] = blockNode;
    rrdNodes[i].antType[0] = rf_control;
  }
  for (i = 0; i < nRudNodes; i++) {
    RF_ASSERT(rudNodes[i].numSuccedents == 1);
    blockNode->succedents[1 + nRrdNodes + i] = &rudNodes[i];
    rudNodes[i].antecedents[0] = blockNode;
    rudNodes[i].antType[0] = rf_control;
  }

  /* connect the read nodes to the xor node */
  RF_ASSERT(xorNode->numAntecedents == (1 + nRrdNodes + nRudNodes));
  RF_ASSERT(rpNode->numSuccedents == 1);
  rpNode->succedents[0] = xorNode;
  xorNode->antecedents[0] = rpNode;
  xorNode->antType[0] = rf_trueData;
  for (i = 0; i < nRrdNodes; i++) {
    RF_ASSERT(rrdNodes[i].numSuccedents == 1);
    rrdNodes[i].succedents[0] = xorNode;
    xorNode->antecedents[1 + i] = &rrdNodes[i];
    xorNode->antType[1 + i] = rf_trueData;
  }
  for (i = 0; i < nRudNodes; i++) {
    RF_ASSERT(rudNodes[i].numSuccedents == 1);
    rudNodes[i].succedents[0] = xorNode;
    xorNode->antecedents[1 + nRrdNodes + i] = &rudNodes[i];
    xorNode->antType[1 + nRrdNodes + i] = rf_trueData;
  }

  /* connect the xor node to the commit node */
  RF_ASSERT(xorNode->numSuccedents == 1);
  RF_ASSERT(commitNode->numAntecedents == 1);
  xorNode->succedents[0] = commitNode;
  commitNode->antecedents[0] = xorNode;
  commitNode->antType[0] = rf_control;

  /* connect the termNode to the commit node */
  RF_ASSERT(commitNode->numSuccedents == 1);
  RF_ASSERT(termNode->numAntecedents == 1);
  RF_ASSERT(termNode->numSuccedents == 0);
  commitNode->succedents[0] = termNode;
  termNode->antType[0] = rf_control;
  termNode->antecedents[0]  = commitNode;
d524 1
a524 1
 *              flags     - general flags (e.g. disk locking) 
d528 8
a535 7
void rf_CreateRaidCDegradedReadDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList)
d537 112
a648 111
  RF_DagNode_t *nodes, *rdNode, *blockNode, *commitNode, *termNode;
  RF_StripeNum_t parityStripeID;
  int useMirror, i, shiftable;
  RF_ReconUnitNum_t which_ru;
  RF_PhysDiskAddr_t *pda;

  if ((asmap->numDataFailed + asmap->numParityFailed) == 0) {
    shiftable = RF_TRUE;
  }
  else {
    shiftable = RF_FALSE;
  }
  useMirror = 0;
  parityStripeID = rf_RaidAddressToParityStripeID(&(raidPtr->Layout),
    asmap->raidAddress, &which_ru);

  if (rf_dagDebug) {
    printf("[Creating RAID C degraded read DAG]\n");
  }
  dag_h->creator = "RaidCDegradedReadDAG";
  /* alloc the Wnd nodes and the Wmir node */
  if (asmap->numDataFailed == 0)
    useMirror = RF_FALSE;
  else
    useMirror = RF_TRUE;

  /* total number of nodes = 1 + (block + commit + terminator) */
  RF_CallocAndAdd(nodes, 4, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
  i = 0;
  rdNode      = &nodes[i]; i++;
  blockNode   = &nodes[i]; i++;
  commitNode = &nodes[i]; i++;
  termNode    = &nodes[i]; i++;

  /*
   * This dag can not commit until the commit node is reached.
   * Errors prior to the commit point imply the dag has failed
   * and must be retried.
   */
  dag_h->numCommitNodes = 1;
  dag_h->numCommits = 0;
  dag_h->numSuccedents = 1;

  /* initialize the block, commit, and terminator nodes */
  rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
    NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
  rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
    NULL, 1, 1, 0, 0, dag_h, "Cmt", allocList);
  rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,
    NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);

  pda = asmap->physInfo;
  RF_ASSERT(pda != NULL);
  /* parityInfo must describe entire parity unit */
  RF_ASSERT(asmap->parityInfo->next == NULL);

  /* initialize the data node */
  if (!useMirror) {
    rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc,
      rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rpd", allocList);
    if (shiftable && rf_compute_workload_shift(raidPtr, pda)) {
     /* shift this read to the next disk in line */
  	 rdNode->params[0].p = asmap->parityInfo;
   	 rdNode->params[1].p = pda->bufPtr;
	 rdNode->params[2].v = parityStripeID;
	 rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
	}
    else {
      /* read primary copy */
      rdNode->params[0].p = pda;  
      rdNode->params[1].p = pda->bufPtr;
      rdNode->params[2].v = parityStripeID;
      rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
    }
  }
  else {
    /* read secondary copy of data */
    rf_InitNode(rdNode, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc,
      rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, "Rsd", allocList);
    rdNode->params[0].p = asmap->parityInfo;
    rdNode->params[1].p = pda->bufPtr;
    rdNode->params[2].v = parityStripeID;
    rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);
  }

  /* connect header to block node */
  RF_ASSERT(dag_h->numSuccedents == 1);
  RF_ASSERT(blockNode->numAntecedents == 0);
  dag_h->succedents[0] = blockNode;

  /* connect block node to rdnode */
  RF_ASSERT(blockNode->numSuccedents == 1);
  RF_ASSERT(rdNode->numAntecedents == 1);
  blockNode->succedents[0] = rdNode;
  rdNode->antecedents[0] = blockNode;
  rdNode->antType[0] = rf_control;

  /* connect rdnode to commit node */
  RF_ASSERT(rdNode->numSuccedents == 1);
  RF_ASSERT(commitNode->numAntecedents == 1);
  rdNode->succedents[0] = commitNode;
  commitNode->antecedents[0] = rdNode;
  commitNode->antType[0] = rf_control;

  /* connect commit node to terminator */
  RF_ASSERT(commitNode->numSuccedents == 1);
  RF_ASSERT(termNode->numAntecedents == 1);
  RF_ASSERT(termNode->numSuccedents == 0);
  commitNode->succedents[0] = termNode;
  termNode->antecedents[0] = commitNode;
  termNode->antType[0] = rf_control;
a649 1

d653 9
a661 8
void rf_DD_GenerateFailedAccessASMs(
  RF_Raid_t              *raidPtr,
  RF_AccessStripeMap_t   *asmap,
  RF_PhysDiskAddr_t     **pdap,
  int                    *nNodep,
  RF_PhysDiskAddr_t     **pqpdap,
  int                    *nPQNodep,
  RF_AllocListElem_t     *allocList)
d663 16
a678 16
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  int PDAPerDisk,i;
  RF_SectorCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;
  int numDataCol = layoutPtr->numDataCol;
  int state;
  RF_SectorNum_t suoff, suend;
  unsigned firstDataCol, napdas, count;
  RF_SectorNum_t fone_start, fone_end, ftwo_start = 0, ftwo_end = 0;
  RF_PhysDiskAddr_t *fone = asmap->failedPDAs[0], *ftwo = asmap->failedPDAs[1];
  RF_PhysDiskAddr_t *pda_p;
  RF_PhysDiskAddr_t *phys_p;
  RF_RaidAddr_t sosAddr;

  /* determine how many pda's we will have to generate per unaccess stripe.
     If there is only one failed data unit, it is one; if two, possibly two,
     depending wether they overlap. */
d680 2
a681 2
  fone_start = rf_StripeUnitOffset(layoutPtr,fone->startSector);
  fone_end = fone_start + fone->numSector;
d690 8
a697 196
  if (asmap->numDataFailed==1)
    {
      PDAPerDisk = 1;
      state = 1;
      RF_MallocAndAdd(*pqpdap,2*sizeof(RF_PhysDiskAddr_t),(RF_PhysDiskAddr_t *), allocList);
      pda_p = *pqpdap;
      /* build p */
      CONS_PDA(parityInfo,fone_start,fone->numSector);
      pda_p->type = RF_PDA_TYPE_PARITY;
      pda_p++;
      /* build q */
      CONS_PDA(qInfo,fone_start,fone->numSector);
      pda_p->type = RF_PDA_TYPE_Q;
    }
  else
    {
      ftwo_start = rf_StripeUnitOffset(layoutPtr,ftwo->startSector);
      ftwo_end = ftwo_start + ftwo->numSector;    
      if (fone->numSector + ftwo->numSector > secPerSU)
	{
	  PDAPerDisk = 1;
	  state = 2;
	  RF_MallocAndAdd(*pqpdap,2*sizeof(RF_PhysDiskAddr_t),(RF_PhysDiskAddr_t *), allocList);
	  pda_p = *pqpdap;
	  CONS_PDA(parityInfo,0,secPerSU);
	  pda_p->type = RF_PDA_TYPE_PARITY;
	  pda_p++;
	  CONS_PDA(qInfo,0,secPerSU);
	  pda_p->type = RF_PDA_TYPE_Q;
	}
      else
	{
	  PDAPerDisk = 2;
	  state = 3;
	  /* four of them, fone, then ftwo */
	  RF_MallocAndAdd(*pqpdap,4*sizeof(RF_PhysDiskAddr_t),(RF_PhysDiskAddr_t *), allocList);
	  pda_p = *pqpdap;
	  CONS_PDA(parityInfo,fone_start,fone->numSector);
	  pda_p->type = RF_PDA_TYPE_PARITY;
	  pda_p++;
	  CONS_PDA(qInfo,fone_start,fone->numSector);
	  pda_p->type = RF_PDA_TYPE_Q;
	  pda_p++;
	  CONS_PDA(parityInfo,ftwo_start,ftwo->numSector);
	  pda_p->type = RF_PDA_TYPE_PARITY;
	  pda_p++;
	  CONS_PDA(qInfo,ftwo_start,ftwo->numSector);
	  pda_p->type = RF_PDA_TYPE_Q;
	}
    }
  /* figure out number of nonaccessed pda */
  napdas = PDAPerDisk * (numDataCol - asmap->numStripeUnitsAccessed - (ftwo==NULL ? 1 : 0));
  *nPQNodep = PDAPerDisk;

  /* sweep over the over accessed pda's, figuring out the number of
     additional pda's to generate. Of course, skip the failed ones */

  count = 0;
  for ( pda_p=asmap->physInfo; pda_p; pda_p= pda_p->next)
    {
      if ((pda_p == fone) || (pda_p == ftwo))
	continue;
      suoff = rf_StripeUnitOffset(layoutPtr,pda_p->startSector);
      suend = suoff + pda_p->numSector;
      switch (state)
	{
	case 1: /* one failed PDA to overlap */
	  /* if a PDA doesn't contain the failed unit, it can
	     only miss the start or end, not both */
	  if ((suoff > fone_start) || (suend <fone_end))
	    count++;
	  break;
	case 2: /* whole stripe */
	  if (suoff) /* leak at begining */
	    count++;
	  if (suend < numDataCol) /* leak at end */
	    count++;
	  break;
	case 3: /* two disjoint units */
	  if ((suoff > fone_start) || (suend <fone_end))
	    count++;
	  if ((suoff > ftwo_start) || (suend <ftwo_end))
	    count++;
	  break;
	default:
	  RF_PANIC();
	}
    }

  napdas += count;
  *nNodep = napdas;
  if (napdas == 0) return; /* short circuit */

  /* allocate up our list of pda's */
     
  RF_CallocAndAdd(pda_p, napdas, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *), allocList);
  *pdap = pda_p;
    
  /* linkem together */
  for (i=0; i < (napdas-1); i++)
    pda_p[i].next = pda_p+(i+1);

  /* march through the one's up to the first accessed disk */
  firstDataCol = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),asmap->physInfo->raidAddress) % numDataCol;
  sosAddr      = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);
  for (i=0; i < firstDataCol; i++)
    {
      if ((pda_p - (*pdap)) == napdas) 
	continue;
      pda_p->type = RF_PDA_TYPE_DATA;
      pda_p->raidAddress = sosAddr + (i * secPerSU);
      (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
      /* skip over dead disks */
      if (RF_DEAD_DISK(raidPtr->Disks[pda_p->row][pda_p->col].status)) 
	continue;
      switch (state)
	{
	case 1: /* fone */
	  pda_p->numSector = fone->numSector;
	  pda_p->raidAddress += fone_start;
	  pda_p->startSector += fone_start;
	  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
	  break;
	case 2: /* full stripe */
	  pda_p->numSector = secPerSU;
	  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,secPerSU), (char *), allocList);
	  break;
	case 3: /* two slabs */
	  pda_p->numSector = fone->numSector;
	  pda_p->raidAddress += fone_start;
	  pda_p->startSector += fone_start;
	  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
	  pda_p++;
          pda_p->type = RF_PDA_TYPE_DATA;
          pda_p->raidAddress = sosAddr + (i * secPerSU);
          (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
	  pda_p->numSector = ftwo->numSector;
	  pda_p->raidAddress += ftwo_start;
	  pda_p->startSector += ftwo_start;
	  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
	  break;
	default:
	  RF_PANIC();
	}
      pda_p++;
    }

  /* march through the touched stripe units */
  for (phys_p = asmap->physInfo; phys_p; phys_p = phys_p->next, i++)
    {
      if ((phys_p == asmap->failedPDAs[0]) || (phys_p == asmap->failedPDAs[1]))
	continue;
      suoff = rf_StripeUnitOffset(layoutPtr,phys_p->startSector);
      suend = suoff + phys_p->numSector;
      switch(state)
	{
	case 1: /* single buffer */
	  if (suoff > fone_start)
	    { 
	      RF_ASSERT( suend >= fone_end );
	      /* The data read starts after the mapped access,
		 snip off the begining */
	      pda_p->numSector = suoff - fone_start;
	      pda_p->raidAddress = sosAddr + (i*secPerSU) + fone_start;
	      (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
	      RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
	      pda_p++;
	    }
	  if (suend < fone_end)
	    {
	      RF_ASSERT ( suoff <= fone_start);
	      /* The data read stops before the end of the failed access, extend */
	      pda_p->numSector = fone_end - suend;
	      pda_p->raidAddress = sosAddr + (i*secPerSU) + suend; /* off by one? */
	      (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
	      RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
	      pda_p++;
	    }
	  break;
	case 2: /* whole stripe unit */
	  RF_ASSERT( (suoff == 0) || (suend == secPerSU));
	  if (suend < secPerSU)
	    { /* short read, snip from end on */
	      pda_p->numSector = secPerSU - suend;
	      pda_p->raidAddress = sosAddr + (i*secPerSU) + suend; /* off by one? */
	      (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
	      RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
	      pda_p++;
	    }
	  else
	    if (suoff > 0)
	      { /* short at front */
		pda_p->numSector = suoff;
		pda_p->raidAddress = sosAddr + (i*secPerSU);
		(raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
d699 33
a731 15
	      }
	  break;
	case 3: /* two nonoverlapping failures */
	  if ((suoff > fone_start) || (suend <fone_end))
	    {
	      if (suoff > fone_start)
		{ 
		  RF_ASSERT( suend >= fone_end );
		  /* The data read starts after the mapped access,
		     snip off the begining */
		  pda_p->numSector = suoff - fone_start;
		  pda_p->raidAddress = sosAddr + (i*secPerSU) + fone_start;
		  (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
		  pda_p++;
d733 35
a767 9
	      if (suend < fone_end)
		{
		  RF_ASSERT ( suoff <= fone_start);
		  /* The data read stops before the end of the failed access, extend */
		  pda_p->numSector = fone_end - suend;
		  pda_p->raidAddress = sosAddr + (i*secPerSU) + suend; /* off by one? */
		  (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
		  pda_p++;
d769 55
a823 13
	    }
	  if ((suoff > ftwo_start) || (suend <ftwo_end))
	    {
	      if (suoff > ftwo_start)
		{ 
		  RF_ASSERT( suend >= ftwo_end );
		  /* The data read starts after the mapped access,
		     snip off the begining */
		  pda_p->numSector = suoff - ftwo_start;
		  pda_p->raidAddress = sosAddr + (i*secPerSU) + ftwo_start;
		  (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
		  pda_p++;
d825 100
a924 9
	      if (suend < ftwo_end)
		{
		  RF_ASSERT ( suoff <= ftwo_start);
		  /* The data read stops before the end of the failed access, extend */
		  pda_p->numSector = ftwo_end - suend;
		  pda_p->raidAddress = sosAddr + (i*secPerSU) + suend; /* off by one? */
		  (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
		  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
		  pda_p++;
a925 46
	    }
	  break;
	default:
	  RF_PANIC();
        }
    }

  /* after the last accessed disk */
  for (; i < numDataCol; i++ )
    {
      if ((pda_p - (*pdap)) == napdas) 
	continue;
      pda_p->type = RF_PDA_TYPE_DATA;
      pda_p->raidAddress = sosAddr + (i * secPerSU);
      (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
      /* skip over dead disks */
      if (RF_DEAD_DISK(raidPtr->Disks[pda_p->row][pda_p->col].status)) 
	continue;
      switch (state)
	{
	case 1: /* fone */
	  pda_p->numSector = fone->numSector;
	  pda_p->raidAddress += fone_start;
	  pda_p->startSector += fone_start;
	  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
	  break;
	case 2: /* full stripe */
	  pda_p->numSector = secPerSU;
	  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,secPerSU), (char *), allocList);
	  break;
	case 3: /* two slabs */
	  pda_p->numSector = fone->numSector;
	  pda_p->raidAddress += fone_start;
	  pda_p->startSector += fone_start;
	  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
	  pda_p++;
          pda_p->type = RF_PDA_TYPE_DATA;
          pda_p->raidAddress = sosAddr + (i * secPerSU);
          (raidPtr->Layout.map->MapSector)(raidPtr,pda_p->raidAddress, &(pda_p->row), &(pda_p->col), &(pda_p->startSector), 0);
	  pda_p->numSector = ftwo->numSector;
	  pda_p->raidAddress += ftwo_start;
	  pda_p->startSector += ftwo_start;
	  RF_MallocAndAdd(pda_p->bufPtr, rf_RaidAddressToByte(raidPtr,pda_p->numSector), (char *), allocList);
	  break;
	default:
	  RF_PANIC();
a926 2
      pda_p++;
    }
d928 43
a970 2
  RF_ASSERT  (pda_p - *pdap == napdas);
  return;
a971 1

d985 11
a995 10
void rf_DoubleDegRead(
  RF_Raid_t              *raidPtr,
  RF_AccessStripeMap_t   *asmap,
  RF_DagHeader_t         *dag_h,
  void                   *bp,
  RF_RaidAccessFlags_t    flags,
  RF_AllocListElem_t     *allocList,
  char                   *redundantReadNodeName,
  char                   *recoveryNodeName,
  int                   (*recovFunc)(RF_DagNode_t *))
d997 127
a1123 121
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  RF_DagNode_t *nodes, *rudNodes, *rrdNodes, *recoveryNode, *blockNode, *unblockNode, *rpNodes, *rqNodes, *termNode;
  RF_PhysDiskAddr_t *pda, *pqPDAs;
  RF_PhysDiskAddr_t *npdas;
  int nNodes, nRrdNodes, nRudNodes, i;
  RF_ReconUnitNum_t which_ru;
  int nReadNodes, nPQNodes;
  RF_PhysDiskAddr_t *failedPDA = asmap->failedPDAs[0];      
  RF_PhysDiskAddr_t *failedPDAtwo = asmap->failedPDAs[1];    
  RF_StripeNum_t parityStripeID = rf_RaidAddressToParityStripeID(layoutPtr, asmap->raidAddress, &which_ru);

  if (rf_dagDebug) printf("[Creating Double Degraded Read DAG]\n");
  rf_DD_GenerateFailedAccessASMs(raidPtr, asmap, &npdas, &nRrdNodes, &pqPDAs, &nPQNodes,allocList);

  nRudNodes = asmap->numStripeUnitsAccessed - (asmap->numDataFailed);
  nReadNodes = nRrdNodes + nRudNodes + 2*nPQNodes;
  nNodes = 4 /* block, unblock, recovery, term */ + nReadNodes;

  RF_CallocAndAdd(nodes, nNodes, sizeof(RF_DagNode_t), (RF_DagNode_t *), allocList);
  i = 0;
  blockNode    = &nodes[i]; i += 1;
  unblockNode  = &nodes[i]; i += 1;
  recoveryNode = &nodes[i]; i += 1;
  termNode     = &nodes[i]; i += 1;
  rudNodes     = &nodes[i]; i += nRudNodes;
  rrdNodes     = &nodes[i]; i += nRrdNodes;
  rpNodes      = &nodes[i]; i += nPQNodes;
  rqNodes      = &nodes[i]; i += nPQNodes;
  RF_ASSERT(i == nNodes);

  dag_h->numSuccedents = 1;
  dag_h->succedents[0] = blockNode;
  dag_h->creator = "DoubleDegRead";
  dag_h->numCommits = 0;
  dag_h->numCommitNodes = 1; /*unblock */

  rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc, NULL, 0, 2, 0, 0, dag_h, "Trm", allocList);
  termNode->antecedents[0]  = unblockNode;
  termNode->antType[0] = rf_control;
  termNode->antecedents[1]  = recoveryNode;
  termNode->antType[1] = rf_control;

  /* init the block and unblock nodes */
  /* The block node has all nodes except itself, unblock and recovery as successors. Similarly for 
     predecessors of the unblock. */
  rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, nReadNodes, 0, 0, 0, dag_h, "Nil", allocList);
  rf_InitNode(unblockNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc, NULL, 1, nReadNodes, 0, 0, dag_h, "Nil", allocList);
  
  for (i=0; i < nReadNodes; i++)
    {
      blockNode->succedents[i] = rudNodes+i;
      unblockNode->antecedents[i] = rudNodes+i;
      unblockNode->antType[i] = rf_control;
    }
  unblockNode->succedents[0] = termNode;

  /* The recovery node has all the reads as predecessors, and the term node as successors. It gets a pda as a param
     from each of the read nodes plus the raidPtr.
     For each failed unit is has a result pda. */
  rf_InitNode(recoveryNode, rf_wait, RF_FALSE, recovFunc, rf_NullNodeUndoFunc, NULL, 
	   1, /* succesors */
	   nReadNodes, /* preds */ 
	   nReadNodes+2, /* params */
	   asmap->numDataFailed, /* results */
	   dag_h, recoveryNodeName, allocList);
  
  recoveryNode->succedents[0] = termNode;
  for (i=0; i < nReadNodes; i++) {
    recoveryNode->antecedents[i] = rudNodes+i;
    recoveryNode->antType[i] = rf_trueData;
  }
  
  /* build the read nodes, then come back and fill in recovery params and results */
  pda = asmap->physInfo;
  for (i=0; i < nRudNodes; pda = pda->next)
    {
      if ((pda == failedPDA) || (pda == failedPDAtwo))
	continue;
      INIT_DISK_NODE(rudNodes+i,"Rud");
      RF_ASSERT(pda);
      DISK_NODE_PARAMS(rudNodes[i],pda);
      i++;
    }

  pda = npdas;
  for (i=0; i < nRrdNodes; i++, pda = pda->next)
    {
      INIT_DISK_NODE(rrdNodes+i,"Rrd");
      RF_ASSERT(pda);
      DISK_NODE_PARAMS(rrdNodes[i],pda);
    }
  
  /* redundancy pdas */
  pda = pqPDAs;
  INIT_DISK_NODE(rpNodes,"Rp");
  RF_ASSERT(pda);
  DISK_NODE_PARAMS(rpNodes[0],pda);
  pda++;
  INIT_DISK_NODE(rqNodes,redundantReadNodeName );
  RF_ASSERT(pda);
  DISK_NODE_PARAMS(rqNodes[0],pda);
  if (nPQNodes==2)
    {
      pda++;
      INIT_DISK_NODE(rpNodes+1,"Rp");
      RF_ASSERT(pda);
      DISK_NODE_PARAMS(rpNodes[1],pda);
      pda++;
      INIT_DISK_NODE( rqNodes+1,redundantReadNodeName );
      RF_ASSERT(pda);
      DISK_NODE_PARAMS(rqNodes[1],pda);
    }

  /* fill in recovery node params */
  for (i=0; i < nReadNodes; i++)
    recoveryNode->params[i] = rudNodes[i].params[0]; /* pda */
  recoveryNode->params[i++].p = (void *) raidPtr;
  recoveryNode->params[i++].p = (void *) asmap;
  recoveryNode->results[0] = failedPDA;
  if (asmap->numDataFailed ==2 )
    recoveryNode->results[1] = failedPDAtwo;
d1125 1
a1125 1
  /* zero fill the target data buffers? */
@

