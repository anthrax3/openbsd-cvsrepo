head	1.19;
access;
symbols
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.10
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.14
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.12
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.10
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.8
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.12
	UBC:1.10.0.6
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.18;

1.18
date	2011.06.21.16.46.00;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.23.13.49.35;	author naddy;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.05.00.38.22;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.26.15.07.26;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.19.14.27.01;	author tdeval;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.16.07.01.05;	author tdeval;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.09.15.10.20;	author tdeval;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.02;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.02.09.06.26;	author peter;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	2000.08.08.16.07.45;	author peter;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.11.18.02.23;	author peter;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.01.11.14.51.37;	author peter;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.07.14.50.22;	author peter;	state Exp;
branches;
next	1.5;

1.5
date	99.08.04.13.10.55;	author peter;	state Exp;
branches;
next	1.4;

1.4
date	99.08.03.13.56.37;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.33;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.46;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.26.14;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.03.28.15.03.52;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2004.02.19.10.56.31;	author niklas;	state Exp;
branches;
next	;

1.10.6.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.10.6.2;

1.10.6.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	1.10.6.3;

1.10.6.3
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_reconstruct.c,v 1.18 2011/06/21 16:46:00 tedu Exp $	*/
/*	$NetBSD: rf_reconstruct.c,v 1.26 2000/06/04 02:05:13 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/**************************************************************
 *
 * rf_reconstruct.c -- Code to perform on-line reconstruction.
 *
 **************************************************************/

#include "rf_types.h"
#include <sys/time.h>
#include <sys/buf.h>
#include <sys/errno.h>

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/fcntl.h>
#if	__NETBSD__
#include <sys/vnode.h>
#endif

#include "rf_raid.h"
#include "rf_reconutil.h"
#include "rf_revent.h"
#include "rf_reconbuffer.h"
#include "rf_acctrace.h"
#include "rf_etimer.h"
#include "rf_dag.h"
#include "rf_desc.h"
#include "rf_general.h"
#include "rf_freelist.h"
#include "rf_debugprint.h"
#include "rf_driver.h"
#include "rf_utils.h"
#include "rf_shutdown.h"

#include "rf_kintf.h"

/*
 * Setting these to -1 causes them to be set to their default values if not set
 * by debug options.
 */

#define	Dprintf(s)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);	\
} while (0)
#define	Dprintf1(s,a)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
#define	Dprintf2(s,a,b)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
#define	Dprintf3(s,a,b,c)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    NULL, NULL, NULL, NULL, NULL);			\
} while (0)
#define	Dprintf4(s,a,b,c,d)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    NULL, NULL, NULL, NULL);				\
} while (0)
#define	Dprintf5(s,a,b,c,d,e)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    (void *)((unsigned long)e),				\
		    NULL, NULL, NULL);					\
} while (0)
#define	Dprintf6(s,a,b,c,d,e,f)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    (void *)((unsigned long)e),				\
		    (void *)((unsigned long)f),				\
		    NULL, NULL);					\
} while (0)
#define	Dprintf7(s,a,b,c,d,e,f,g)					\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    (void *)((unsigned long)e),				\
		    (void *)((unsigned long)f),				\
		    (void *)((unsigned long)g),				\
		    NULL);						\
} while (0)

#define	DDprintf1(s,a)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
#define	DDprintf2(s,a,b)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)

static RF_FreeList_t *rf_recond_freelist;
#define	RF_MAX_FREE_RECOND	4
#define	RF_RECOND_INC		1

RF_RaidReconDesc_t *rf_AllocRaidReconDesc(RF_Raid_t *,
	RF_RowCol_t, RF_RowCol_t, RF_RaidDisk_t *, int,
	RF_RowCol_t, RF_RowCol_t);
int  rf_ProcessReconEvent(RF_Raid_t *, RF_RowCol_t, RF_ReconEvent_t *);
int  rf_IssueNextReadRequest(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_TryToRead(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ComputePSDiskOffsets(RF_Raid_t *, RF_StripeNum_t,
	RF_RowCol_t, RF_RowCol_t, RF_SectorNum_t *, RF_SectorNum_t *,
	RF_RowCol_t *, RF_RowCol_t *, RF_SectorNum_t *);
int  rf_ReconReadDoneProc(void *, int);
int  rf_ReconWriteDoneProc(void *, int);
void rf_CheckForNewMinHeadSep(RF_Raid_t *, RF_RowCol_t, RF_HeadSepLimit_t);
int  rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *,
	RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);
void rf_ForceReconReadDoneProc(void *, int);
void rf_ShutdownReconstruction(void *);

/*
 * These functions are inlined on gcc. If they are used more than
 * once, it is strongly advised to un-line them.
 */
void rf_FreeReconDesc(RF_RaidReconDesc_t *);
int  rf_IssueNextWriteRequest(RF_Raid_t *, RF_RowCol_t);
int  rf_CheckForcedOrBlockedReconstruction(RF_Raid_t *,
	RF_ReconParityStripeStatus_t *, RF_PerDiskReconCtrl_t *,
	RF_RowCol_t, RF_RowCol_t, RF_StripeNum_t, RF_ReconUnitNum_t);
void rf_SignalReconDone(RF_Raid_t *);

struct RF_ReconDoneProc_s {
	void			(*proc) (RF_Raid_t *, void *);
	void			 *arg;
	RF_ReconDoneProc_t	 *next;
};

static RF_FreeList_t *rf_rdp_freelist;
#define	RF_MAX_FREE_RDP		4
#define	RF_RDP_INC		1

void
rf_SignalReconDone(RF_Raid_t *raidPtr)
{
	RF_ReconDoneProc_t *p;

	RF_LOCK_MUTEX(raidPtr->recon_done_proc_mutex);
	for (p = raidPtr->recon_done_procs; p; p = p->next) {
		p->proc(raidPtr, p->arg);
	}
	RF_UNLOCK_MUTEX(raidPtr->recon_done_proc_mutex);
}

int
rf_RegisterReconDoneProc(RF_Raid_t *raidPtr, void (*proc) (RF_Raid_t *, void *),
    void *arg, RF_ReconDoneProc_t **handlep)
{
	RF_ReconDoneProc_t *p;

	RF_FREELIST_GET(rf_rdp_freelist, p, next, (RF_ReconDoneProc_t *));
	if (p == NULL)
		return (ENOMEM);
	p->proc = proc;
	p->arg = arg;
	RF_LOCK_MUTEX(raidPtr->recon_done_proc_mutex);
	p->next = raidPtr->recon_done_procs;
	raidPtr->recon_done_procs = p;
	RF_UNLOCK_MUTEX(raidPtr->recon_done_proc_mutex);
	if (handlep)
		*handlep = p;
	return (0);
}

/*****************************************************************************
 *
 * Sets up the parameters that will be used by the reconstruction process.
 * Currently there are none, except for those that the layout-specific
 * configuration (e.g. rf_ConfigureDeclustered) routine sets up.
 *
 * In the kernel, we fire off the recon thread.
 *
 *****************************************************************************/
void
rf_ShutdownReconstruction(void *ignored)
{
	RF_FREELIST_DESTROY(rf_recond_freelist, next, (RF_RaidReconDesc_t *));
	RF_FREELIST_DESTROY(rf_rdp_freelist, next, (RF_ReconDoneProc_t *));
}

int
rf_ConfigureReconstruction(RF_ShutdownList_t **listp)
{
	int rc;

	RF_FREELIST_CREATE(rf_recond_freelist, RF_MAX_FREE_RECOND,
	    RF_RECOND_INC, sizeof(RF_RaidReconDesc_t));
	if (rf_recond_freelist == NULL)
		return (ENOMEM);
	RF_FREELIST_CREATE(rf_rdp_freelist, RF_MAX_FREE_RDP,
	    RF_RDP_INC, sizeof(RF_ReconDoneProc_t));
	if (rf_rdp_freelist == NULL) {
		RF_FREELIST_DESTROY(rf_recond_freelist, next,
		    (RF_RaidReconDesc_t *));
		return (ENOMEM);
	}
	rc = rf_ShutdownCreate(listp, rf_ShutdownReconstruction, NULL);
	if (rc) {
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
		rf_ShutdownReconstruction(NULL);
		return (rc);
	}
	return (0);
}

RF_RaidReconDesc_t *
rf_AllocRaidReconDesc(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col,
    RF_RaidDisk_t *spareDiskPtr, int numDisksDone, RF_RowCol_t srow,
    RF_RowCol_t scol)
{

	RF_RaidReconDesc_t *reconDesc;

	RF_FREELIST_GET(rf_recond_freelist, reconDesc, next,
	    (RF_RaidReconDesc_t *));

	reconDesc->raidPtr = raidPtr;
	reconDesc->row = row;
	reconDesc->col = col;
	reconDesc->spareDiskPtr = spareDiskPtr;
	reconDesc->numDisksDone = numDisksDone;
	reconDesc->srow = srow;
	reconDesc->scol = scol;
	reconDesc->state = 0;
	reconDesc->next = NULL;

	return (reconDesc);
}

void
rf_FreeReconDesc(RF_RaidReconDesc_t *reconDesc)
{
#if	RF_RECON_STATS > 0
	printf("RAIDframe: %qu recon event waits, %qu recon delays.\n",
	    reconDesc->numReconEventWaits, reconDesc->numReconExecDelays);
#endif	/* RF_RECON_STATS > 0 */

	printf("RAIDframe: %qu max exec ticks.\n",
	    reconDesc->maxReconExecTicks);

#if	(RF_RECON_STATS > 0) || defined(_KERNEL)
	printf("\n");
#endif	/* (RF_RECON_STATS > 0) || _KERNEL */
	RF_FREELIST_FREE(rf_recond_freelist, reconDesc, next);
}


/*****************************************************************************
 *
 * Primary routine to reconstruct a failed disk. This should be called from
 * within its own thread. It won't return until reconstruction completes,
 * fails, or is aborted.
 *
 *****************************************************************************/
int
rf_ReconstructFailedDisk(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
{
	RF_LayoutSW_t *lp;
	int rc;

	lp = raidPtr->Layout.map;
	if (lp->SubmitReconBuffer) {
		/*
		 * The current infrastructure only supports reconstructing one
		 * disk at a time for each array.
		 */
		RF_LOCK_MUTEX(raidPtr->mutex);
		while (raidPtr->reconInProgress) {
			RF_WAIT_COND(raidPtr->waitForReconCond, raidPtr->mutex);
		}
		raidPtr->reconInProgress++;
		RF_UNLOCK_MUTEX(raidPtr->mutex);
		rc = rf_ReconstructFailedDiskBasic(raidPtr, row, col);
		RF_LOCK_MUTEX(raidPtr->mutex);
		raidPtr->reconInProgress--;
		RF_UNLOCK_MUTEX(raidPtr->mutex);
	} else {
		RF_ERRORMSG1("RECON: no way to reconstruct failed disk for"
		    " arch %c.\n", lp->parityConfig);
		rc = EIO;
	}
	RF_SIGNAL_COND(raidPtr->waitForReconCond);
	wakeup(&raidPtr->waitForReconCond);	/*
						 * XXX Methinks this will be
						 * needed at some point... GO
						 */
	return (rc);
}

int
rf_ReconstructFailedDiskBasic(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_RowCol_t col)
{
	RF_ComponentLabel_t c_label;
	RF_RaidDisk_t *spareDiskPtr = NULL;
	RF_RaidReconDesc_t *reconDesc;
	RF_RowCol_t srow, scol;
	int numDisksDone = 0, rc;

	/* First look for a spare drive onto which to reconstruct the data. */
	/*
	 * Spare disk descriptors are stored in row 0. This may have to
	 * change eventually.
	 */

	RF_LOCK_MUTEX(raidPtr->mutex);
	RF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);

	if (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {
		if (raidPtr->status[row] != rf_rs_degraded) {
			RF_ERRORMSG2("Unable to reconstruct disk at row %d"
			    " col %d because status not degraded.\n", row, col);
			RF_UNLOCK_MUTEX(raidPtr->mutex);
			return (EINVAL);
		}
		srow = row;
		scol = (-1);
	} else {
		srow = 0;
		for (scol = raidPtr->numCol;
		     scol < raidPtr->numCol + raidPtr->numSpare; scol++) {
			if (raidPtr->Disks[srow][scol].status == rf_ds_spare) {
				spareDiskPtr = &raidPtr->Disks[srow][scol];
				spareDiskPtr->status = rf_ds_used_spare;
				break;
			}
		}
		if (!spareDiskPtr) {
			RF_ERRORMSG2("Unable to reconstruct disk at row %d"
			    " col %d because no spares are available.\n",
			    row, col);
			RF_UNLOCK_MUTEX(raidPtr->mutex);
			return (ENOSPC);
		}
		printf("RECON: initiating reconstruction on row %d col %d"
		    " -> spare at row %d col %d.\n", row, col, srow, scol);
	}
	RF_UNLOCK_MUTEX(raidPtr->mutex);

	reconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col,
	    spareDiskPtr, numDisksDone, srow, scol);
	raidPtr->reconDesc = (void *) reconDesc;
#if	RF_RECON_STATS > 0
	reconDesc->hsStallCount = 0;
	reconDesc->numReconExecDelays = 0;
	reconDesc->numReconEventWaits = 0;
#endif	/* RF_RECON_STATS > 0 */
	reconDesc->reconExecTimerRunning = 0;
	reconDesc->reconExecTicks = 0;
	reconDesc->maxReconExecTicks = 0;
	rc = rf_ContinueReconstructFailedDisk(reconDesc);

	if (!rc) {
		/* Fix up the component label. */
		/* Don't actually need the read here... */
		raidread_component_label(
		    raidPtr->raid_cinfo[srow][scol].ci_dev,
		    raidPtr->raid_cinfo[srow][scol].ci_vp,
		    &c_label);

		raid_init_component_label(raidPtr, &c_label);
		c_label.row = row;
		c_label.column = col;
		c_label.clean = RF_RAID_DIRTY;
		c_label.status = rf_ds_optimal;

		/* XXXX MORE NEEDED HERE. */

		raidwrite_component_label(
		    raidPtr->raid_cinfo[srow][scol].ci_dev,
		    raidPtr->raid_cinfo[srow][scol].ci_vp,
		    &c_label);

	}
	return (rc);
}

/*
 *
 * Allow reconstructing a disk in-place -- i.e. component /dev/sd2e goes AWOL,
 * and you don't get a spare until the next Monday. With this function
 * (and hot-swappable drives) you can now put your new disk containing
 * /dev/sd2e on the bus, scsictl it alive, and then use raidctl(8) to
 * rebuild the data "on the spot".
 *
 */

int
rf_ReconstructInPlace(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
{
	RF_RaidDisk_t *spareDiskPtr = NULL;
	RF_RaidReconDesc_t *reconDesc;
	RF_LayoutSW_t *lp;
	RF_RaidDisk_t *badDisk;
	RF_ComponentLabel_t c_label;
	int numDisksDone = 0, rc;
	struct partinfo dpart;
	struct vnode *vp;
	struct vattr va;
	struct proc *proc;
	int retcode;
	int ac;

	lp = raidPtr->Layout.map;
	if (lp->SubmitReconBuffer) {
		/*
		 * The current infrastructure only supports reconstructing one
		 * disk at a time for each array.
		 */
		RF_LOCK_MUTEX(raidPtr->mutex);
		if ((raidPtr->Disks[row][col].status == rf_ds_optimal) &&
		    (raidPtr->numFailures > 0)) {
			/* XXX 0 above shouldn't be constant !!! */
			/*
			 * Some component other than this has failed.
			 * Let's not make things worse than they already
			 * are...
			 */
#ifdef	RAIDDEBUG
			printf("RAIDFRAME: Unable to reconstruct to disk at:\n"
			    "      Row: %d Col: %d   Too many failures.\n",
			    row, col);
#endif	/* RAIDDEBUG */
			RF_UNLOCK_MUTEX(raidPtr->mutex);
			return (EINVAL);
		}
		if (raidPtr->Disks[row][col].status == rf_ds_reconstructing) {
#ifdef	RAIDDEBUG
			printf("RAIDFRAME: Unable to reconstruct to disk at:\n"
			    "      Row: %d Col: %d   Reconstruction already"
			    " occurring !\n", row, col);
#endif	/* RAIDDEBUG */

			RF_UNLOCK_MUTEX(raidPtr->mutex);
			return (EINVAL);
		}


		if (raidPtr->Disks[row][col].status != rf_ds_failed) {
			/* "It's gone..." */
			raidPtr->numFailures++;
			raidPtr->Disks[row][col].status = rf_ds_failed;
			raidPtr->status[row] = rf_rs_degraded;
			rf_update_component_labels(raidPtr,
			    RF_NORMAL_COMPONENT_UPDATE);
		}

		while (raidPtr->reconInProgress) {
			RF_WAIT_COND(raidPtr->waitForReconCond, raidPtr->mutex);
		}

		raidPtr->reconInProgress++;

		/*
		 * First look for a spare drive onto which to reconstruct
		 * the data. Spare disk descriptors are stored in row 0.
		 * This may have to change eventually.
		 */

		/*
		 * Actually, we don't care if it's failed or not...
		 * On a RAID set with correct parity, this function
		 * should be callable on any component without ill effects.
		 */
		/*
		 * RF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);
		 */

		if (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {
			RF_ERRORMSG2("Unable to reconstruct to disk at row %d"
			    " col %d: operation not supported for"
			    " RF_DISTRIBUTE_SPARE.\n", row, col);

			raidPtr->reconInProgress--;
			RF_UNLOCK_MUTEX(raidPtr->mutex);
			return (EINVAL);
		}

		/*
		 * XXX Need goop here to see if the disk is alive,
		 * and, if not, make it so...
		 */

		badDisk = &raidPtr->Disks[row][col];

		proc = raidPtr->recon_thread;

		/*
		 * This device may have been opened successfully the
		 * first time. Close it before trying to open it again...
		 */

		if (raidPtr->raid_cinfo[row][col].ci_vp != NULL) {
			printf("Closing the opened device: %s\n",
			    raidPtr->Disks[row][col].devname);
			vp = raidPtr->raid_cinfo[row][col].ci_vp;
			ac = raidPtr->Disks[row][col].auto_configured;
			rf_close_component(raidPtr, vp, ac);
			raidPtr->raid_cinfo[row][col].ci_vp = NULL;
		}
		/*
		 * Note that this disk was *not* auto_configured (any longer).
		 */
		raidPtr->Disks[row][col].auto_configured = 0;

		printf("About to (re-)open the device for rebuilding: %s\n",
		    raidPtr->Disks[row][col].devname);

		retcode = raidlookup(raidPtr->Disks[row][col].devname,
		    proc, &vp);

		if (retcode) {
			printf("raid%d: rebuilding: raidlookup on device: %s"
			    " failed: %d !\n", raidPtr->raidid,
			    raidPtr->Disks[row][col].devname, retcode);

			/*
			 * XXX the component isn't responding properly...
			 * Must still be dead :-(
			 */
			raidPtr->reconInProgress--;
			RF_UNLOCK_MUTEX(raidPtr->mutex);
			return(retcode);

		} else {

			/*
			 * Ok, so we can at least do a lookup...
			 * How about actually getting a vp for it ?
			 */

			if ((retcode =
			     VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {
				raidPtr->reconInProgress--;
				RF_UNLOCK_MUTEX(raidPtr->mutex);
				return(retcode);
			}
			retcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,
			    FREAD, proc->p_ucred, proc);
			if (retcode) {
				raidPtr->reconInProgress--;
				RF_UNLOCK_MUTEX(raidPtr->mutex);
				return(retcode);
			}
			raidPtr->Disks[row][col].blockSize =
			    dpart.disklab->d_secsize;

			raidPtr->Disks[row][col].numBlocks =
			    DL_GETPSIZE(dpart.part) - rf_protectedSectors;

			raidPtr->raid_cinfo[row][col].ci_vp = vp;
			raidPtr->raid_cinfo[row][col].ci_dev = va.va_rdev;

			raidPtr->Disks[row][col].dev = va.va_rdev;

			/*
			 * We allow the user to specify that only a
			 * fraction of the disks should be used this is
			 * just for debug:  it speeds up the parity scan.
			 */
			raidPtr->Disks[row][col].numBlocks =
			    raidPtr->Disks[row][col].numBlocks *
			    rf_sizePercentage / 100;
		}

		spareDiskPtr = &raidPtr->Disks[row][col];
		spareDiskPtr->status = rf_ds_used_spare;

		printf("RECON: Initiating in-place reconstruction on\n");
		printf("       row %d col %d -> spare at row %d col %d.\n",
		    row, col, row, col);

		RF_UNLOCK_MUTEX(raidPtr->mutex);

		reconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col,
		    spareDiskPtr, numDisksDone, row, col);
		raidPtr->reconDesc = (void *) reconDesc;
#if	RF_RECON_STATS > 0
		reconDesc->hsStallCount = 0;
		reconDesc->numReconExecDelays = 0;
		reconDesc->numReconEventWaits = 0;
#endif	/* RF_RECON_STATS > 0 */
		reconDesc->reconExecTimerRunning = 0;
		reconDesc->reconExecTicks = 0;
		reconDesc->maxReconExecTicks = 0;
		rc = rf_ContinueReconstructFailedDisk(reconDesc);

		RF_LOCK_MUTEX(raidPtr->mutex);
		raidPtr->reconInProgress--;
		RF_UNLOCK_MUTEX(raidPtr->mutex);

	} else {
		RF_ERRORMSG1("RECON: no way to reconstruct failed disk for"
		    " arch %c.\n", lp->parityConfig);
		rc = EIO;
	}
	RF_LOCK_MUTEX(raidPtr->mutex);

	if (!rc) {
		/*
		 * Need to set these here, as at this point it'll be claiming
		 * that the disk is in rf_ds_spared !  But we know better :-)
		 */

		raidPtr->Disks[row][col].status = rf_ds_optimal;
		raidPtr->status[row] = rf_rs_optimal;

		/* Fix up the component label. */
		/* Don't actually need the read here... */
		raidread_component_label(
		    raidPtr->raid_cinfo[row][col].ci_dev,
		    raidPtr->raid_cinfo[row][col].ci_vp,
		    &c_label);

		raid_init_component_label(raidPtr, &c_label);

		c_label.row = row;
		c_label.column = col;

		raidwrite_component_label(raidPtr->raid_cinfo[row][col].ci_dev,
		    raidPtr->raid_cinfo[row][col].ci_vp, &c_label);

	}
	RF_UNLOCK_MUTEX(raidPtr->mutex);
	RF_SIGNAL_COND(raidPtr->waitForReconCond);
	wakeup(&raidPtr->waitForReconCond);
	return (rc);
}


int
rf_ContinueReconstructFailedDisk(RF_RaidReconDesc_t *reconDesc)
{
	RF_Raid_t *raidPtr = reconDesc->raidPtr;
	RF_RowCol_t row = reconDesc->row;
	RF_RowCol_t col = reconDesc->col;
	RF_RowCol_t srow = reconDesc->srow;
	RF_RowCol_t scol = reconDesc->scol;
	RF_ReconMap_t *mapPtr;

	RF_ReconEvent_t *event;
	struct timeval etime, elpsd;
	unsigned long xor_s, xor_resid_us;
	int retcode, i, ds;

	switch (reconDesc->state) {
	case 0:
		raidPtr->accumXorTimeUs = 0;

		/* Create one trace record per physical disk. */
		RF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol *
		    sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));

		/*
		 * Quiesce the array prior to starting recon. This is needed
		 * to assure no nasty interactions with pending user writes.
		 * We need to do this before we change the disk or row status.
		 */
		reconDesc->state = 1;

		Dprintf("RECON: begin request suspend.\n");
		retcode = rf_SuspendNewRequestsAndWait(raidPtr);
		Dprintf("RECON: end request suspend.\n");
		rf_StartUserStats(raidPtr);	/*
						 * Zero out the stats kept on
						 * user accs.
						 */
		/* Fall through to state 1. */
	case 1:
		RF_LOCK_MUTEX(raidPtr->mutex);

		/*
		 * Create the reconstruction control pointer and install it in
		 * the right slot.
		 */
		raidPtr->reconControl[row] =
		    rf_MakeReconControl(reconDesc, row, col, srow, scol);
		mapPtr = raidPtr->reconControl[row]->reconMap;
		raidPtr->status[row] = rf_rs_reconstructing;
		raidPtr->Disks[row][col].status = rf_ds_reconstructing;
		raidPtr->Disks[row][col].spareRow = srow;
		raidPtr->Disks[row][col].spareCol = scol;

		RF_UNLOCK_MUTEX(raidPtr->mutex);

		RF_GETTIME(raidPtr->reconControl[row]->starttime);

		/*
		 * Now start up the actual reconstruction: issue a read for
		 * each surviving disk.
		 */

		reconDesc->numDisksDone = 0;
		for (i = 0; i < raidPtr->numCol; i++) {
			if (i != col) {
				/*
				 * Find and issue the next I/O on the
				 * indicated disk.
				 */
				if (rf_IssueNextReadRequest(raidPtr, row, i)) {
					Dprintf2("RECON: done issuing for r%d"
					    " c%d.\n", row, i);
					reconDesc->numDisksDone++;
				}
			}
		}

		reconDesc->state = 2;

	case 2:
		Dprintf("RECON: resume requests.\n");
		rf_ResumeNewRequests(raidPtr);

		reconDesc->state = 3;

	case 3:

		/*
		 * Process reconstruction events until all disks report that
		 * they've completed all work.
		 */
		mapPtr = raidPtr->reconControl[row]->reconMap;

		while (reconDesc->numDisksDone < raidPtr->numCol - 1) {

			event = rf_GetNextReconEvent(reconDesc, row,
			   (void (*) (void *)) rf_ContinueReconstructFailedDisk,
			    reconDesc);
			RF_ASSERT(event);

			if (rf_ProcessReconEvent(raidPtr, row, event))
				reconDesc->numDisksDone++;
			raidPtr->reconControl[row]->numRUsTotal =
				mapPtr->totalRUs;
			raidPtr->reconControl[row]->numRUsComplete =
				mapPtr->totalRUs -
				rf_UnitsLeftToReconstruct(mapPtr);

			raidPtr->reconControl[row]->percentComplete =
			    (raidPtr->reconControl[row]->numRUsComplete * 100 /
			     raidPtr->reconControl[row]->numRUsTotal);
			if (rf_prReconSched) {
				rf_PrintReconSchedule(
				    raidPtr->reconControl[row]->reconMap,
				    &(raidPtr->reconControl[row]->starttime));
			}
		}

		reconDesc->state = 4;

	case 4:
		mapPtr = raidPtr->reconControl[row]->reconMap;
		if (rf_reconDebug) {
			printf("RECON: all reads completed.\n");
		}
		/*
		 * At this point all the reads have completed. We now wait
		 * for any pending writes to complete, and then we're done.
		 */

		while (rf_UnitsLeftToReconstruct(
		    raidPtr->reconControl[row]->reconMap) > 0) {

			event = rf_GetNextReconEvent(reconDesc, row,
			   (void (*) (void *)) rf_ContinueReconstructFailedDisk,
			    reconDesc);
			RF_ASSERT(event);

			/* Ignore return code. */
			(void) rf_ProcessReconEvent(raidPtr, row, event);
			raidPtr->reconControl[row]->percentComplete =
			    100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 /
			    mapPtr->totalRUs);
			if (rf_prReconSched) {
				rf_PrintReconSchedule(
				    raidPtr->reconControl[row]->reconMap,
				    &(raidPtr->reconControl[row]->starttime));
			}
		}
		reconDesc->state = 5;

	case 5:
		/*
		 * Success:  mark the dead disk as reconstructed. We quiesce
		 * the array here to assure no nasty interactions with pending
		 * user accesses, when we free up the psstatus structure as
		 * part of FreeReconControl().
		 */

		reconDesc->state = 6;

		retcode = rf_SuspendNewRequestsAndWait(raidPtr);
		rf_StopUserStats(raidPtr);
		rf_PrintUserStats(raidPtr);	/*
						 * Print out the stats on user
						 * accs accumulated during
						 * recon.
						 */

		/* Fall through to state 6. */
	case 6:
		RF_LOCK_MUTEX(raidPtr->mutex);
		raidPtr->numFailures--;
		ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE);
		raidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared :
							 rf_ds_spared;
		raidPtr->status[row] = (ds) ? rf_rs_reconfigured :
					      rf_rs_optimal;
		RF_UNLOCK_MUTEX(raidPtr->mutex);
		RF_GETTIME(etime);
		RF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime),
		    &etime, &elpsd);

		/*
		 * XXX -- Why is state 7 different from state 6 if there is no
		 * return() here ? -- XXX Note that I set elpsd above & use it
		 * below, so if you put a return here you'll have to fix this.
		 * (also, FreeReconControl is called below).
		 */

	case 7:

		rf_ResumeNewRequests(raidPtr);

		printf("Reconstruction of disk at row %d col %d completed.\n",
		    row, col);
		xor_s = raidPtr->accumXorTimeUs / 1000000;
		xor_resid_us = raidPtr->accumXorTimeUs % 1000000;
		printf("Recon time was %d.%06d seconds, accumulated XOR time"
		    " was %ld us (%ld.%06ld).\n", (int) elpsd.tv_sec,
		    (int) elpsd.tv_usec, raidPtr->accumXorTimeUs, xor_s,
		    xor_resid_us);
		printf("  (start time %d sec %d usec, end time %d sec %d"
		    " usec)\n",
		    (int) raidPtr->reconControl[row]->starttime.tv_sec,
		    (int) raidPtr->reconControl[row]->starttime.tv_usec,
		    (int) etime.tv_sec, (int) etime.tv_usec);

#if	RF_RECON_STATS > 0
		printf("Total head-sep stall count was %d.\n",
		    (int) reconDesc->hsStallCount);
#endif	/* RF_RECON_STATS > 0 */
		rf_FreeReconControl(raidPtr, row);
		RF_Free(raidPtr->recon_tracerecs, raidPtr->numCol *
		    sizeof(RF_AccTraceEntry_t));
		rf_FreeReconDesc(reconDesc);

	}

	rf_SignalReconDone(raidPtr);
	return (0);
}


/*****************************************************************************
 * Do the right thing upon each reconstruction event.
 * Returns nonzero if and only if there is nothing left unread on the
 * indicated disk.
 *****************************************************************************/
int
rf_ProcessReconEvent(RF_Raid_t *raidPtr, RF_RowCol_t frow,
    RF_ReconEvent_t *event)
{
	int retcode = 0, submitblocked;
	RF_ReconBuffer_t *rbuf;
	RF_SectorCount_t sectorsPerRU;

	Dprintf1("RECON: rf_ProcessReconEvent type %d.\n", event->type);

	switch (event->type) {

		/* A read I/O has completed. */
	case RF_REVENT_READDONE:
		rbuf = raidPtr->reconControl[frow]
		    ->perDiskInfo[event->col].rbuf;
		Dprintf3("RECON: READDONE EVENT: row %d col %d psid %ld.\n",
		    frow, event->col, rbuf->parityStripeID);
		Dprintf7("RECON: done read  psid %ld buf %lx  %02x %02x %02x"
		    " %02x %02x.\n", rbuf->parityStripeID, rbuf->buffer,
		    rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,
		    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff,
		    rbuf->buffer[4] & 0xff);
		rf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);
		submitblocked = rf_SubmitReconBuffer(rbuf, 0, 0);
		Dprintf1("RECON: submitblocked=%d.\n", submitblocked);
		if (!submitblocked)
			retcode = rf_IssueNextReadRequest(raidPtr, frow,
			    event->col);
		break;

		/* A write I/O has completed. */
	case RF_REVENT_WRITEDONE:
		if (rf_floatingRbufDebug) {
			rf_CheckFloatingRbufCount(raidPtr, 1);
		}
		sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit *
		    raidPtr->Layout.SUsPerRU;
		rbuf = (RF_ReconBuffer_t *) event->arg;
		rf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);
		Dprintf3("RECON: WRITEDONE EVENT: psid %d ru %d"
		    " (%d %% complete).\n",
		    rbuf->parityStripeID, rbuf->which_ru,
		    raidPtr->reconControl[frow]->percentComplete);
		rf_ReconMapUpdate(raidPtr, raidPtr->reconControl[frow]
		    ->reconMap, rbuf->failedDiskSectorOffset,
		    rbuf->failedDiskSectorOffset + sectorsPerRU - 1);
		rf_RemoveFromActiveReconTable(raidPtr, frow,
		    rbuf->parityStripeID, rbuf->which_ru);

		if (rbuf->type == RF_RBUF_TYPE_FLOATING) {
			RF_LOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);
			raidPtr->numFullReconBuffers--;
			rf_ReleaseFloatingReconBuffer(raidPtr, frow, rbuf);
			RF_UNLOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);
		} else
			if (rbuf->type == RF_RBUF_TYPE_FORCED)
				rf_FreeReconBuffer(rbuf);
			else
				RF_ASSERT(0);
		break;

		/* A buffer-stall condition has been cleared. */
	case RF_REVENT_BUFCLEAR:
		Dprintf2("RECON: BUFCLEAR EVENT: row %d col %d.\n", frow,
		    event->col);
		submitblocked = rf_SubmitReconBuffer(raidPtr
		    ->reconControl[frow]->perDiskInfo[event->col].rbuf, 0,
		    (int) (long) event->arg);
		RF_ASSERT(!submitblocked);	/*
						 * We wouldn't have gotten the
						 * BUFCLEAR event if we
						 * couldn't submit.
						 */
		retcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);
		break;

		/* A user-write reconstruction blockage has been cleared. */
	case RF_REVENT_BLOCKCLEAR:
		DDprintf2("RECON: BLOCKCLEAR EVENT: row %d col %d.\n",
		    frow, event->col);
		retcode = rf_TryToRead(raidPtr, frow, event->col);
		break;

		/*
		 * A max-head-separation reconstruction blockage has been
		 * cleared.
		 */
	case RF_REVENT_HEADSEPCLEAR:
		Dprintf2("RECON: HEADSEPCLEAR EVENT: row %d col %d.\n",
		    frow, event->col);
		retcode = rf_TryToRead(raidPtr, frow, event->col);
		break;

		/* A buffer has become ready to write. */
	case RF_REVENT_BUFREADY:
		Dprintf2("RECON: BUFREADY EVENT: row %d col %d.\n",
		    frow, event->col);
		retcode = rf_IssueNextWriteRequest(raidPtr, frow);
		if (rf_floatingRbufDebug) {
			rf_CheckFloatingRbufCount(raidPtr, 1);
		}
		break;

		/*
		 * We need to skip the current RU entirely because it got
		 * recon'd while we were waiting for something else to happen.
		 */
	case RF_REVENT_SKIP:
		DDprintf2("RECON: SKIP EVENT: row %d col %d.\n",
		    frow, event->col);
		retcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);
		break;

		/*
		 * A forced-reconstruction read access has completed. Just
		 * submit the buffer.
		 */
	case RF_REVENT_FORCEDREADDONE:
		rbuf = (RF_ReconBuffer_t *) event->arg;
		rf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);
		DDprintf2("RECON: FORCEDREADDONE EVENT: row %d col %d.\n",
		    frow, event->col);
		submitblocked = rf_SubmitReconBuffer(rbuf, 1, 0);
		RF_ASSERT(!submitblocked);
		break;

	default:
		RF_PANIC();
	}
	rf_FreeReconEventDesc(event);
	return (retcode);
}

/*****************************************************************************
 *
 * Find the next thing that's needed on the indicated disk, and issue
 * a read request for it. We assume that the reconstruction buffer
 * associated with this process is free to receive the data. If
 * reconstruction is blocked on the indicated RU, we issue a
 * blockage-release request instead of a physical disk read request.
 * If the current disk gets too far ahead of the others, we issue a
 * head-separation wait request and return.
 *
 * ctrl->{ru_count, curPSID, diskOffset} and
 * rbuf->failedDiskSectorOffset are maintained to point to the unit
 * we're currently accessing. Note that this deviates from the
 * standard C idiom of having counters point to the next thing to be
 * accessed. This allows us to easily retry when we're blocked by
 * head separation or reconstruction-blockage events.
 *
 * Returns nonzero if and only if there is nothing left unread on the
 * indicated disk.
 *
 *****************************************************************************/
int
rf_IssueNextReadRequest(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
{
	RF_PerDiskReconCtrl_t *ctrl =
	    &raidPtr->reconControl[row]->perDiskInfo[col];
	RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
	RF_ReconBuffer_t *rbuf = ctrl->rbuf;
	RF_ReconUnitCount_t RUsPerPU =
	    layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;
	RF_SectorCount_t sectorsPerRU =
	    layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;
	int do_new_check = 0, retcode = 0, status;

	/*
	 * If we are currently the slowest disk, mark that we have to do a new
	 * check.
	 */
	if (ctrl->headSepCounter <=
	    raidPtr->reconControl[row]->minHeadSepCounter)
		do_new_check = 1;

	while (1) {

		ctrl->ru_count++;
		if (ctrl->ru_count < RUsPerPU) {
			ctrl->diskOffset += sectorsPerRU;
			rbuf->failedDiskSectorOffset += sectorsPerRU;
		} else {
			ctrl->curPSID++;
			ctrl->ru_count = 0;
			/* code left over from when head-sep was based on
			 * parity stripe id */
			if (ctrl->curPSID >=
			    raidPtr->reconControl[row]->lastPSID) {
				rf_CheckForNewMinHeadSep(raidPtr, row,
				    ++(ctrl->headSepCounter));
				return (1);	/* Finito ! */
			}
			/*
			 * Find the disk offsets of the start of the parity
			 * stripe on both the current disk and the failed
			 * disk. Skip this entire parity stripe if either disk
			 * does not appear in the indicated PS.
			 */
			status = rf_ComputePSDiskOffsets(raidPtr,
			    ctrl->curPSID, row, col, &ctrl->diskOffset,
			    &rbuf->failedDiskSectorOffset, &rbuf->spRow,
			    &rbuf->spCol, &rbuf->spOffset);
			if (status) {
				ctrl->ru_count = RUsPerPU - 1;
				continue;
			}
		}
		rbuf->which_ru = ctrl->ru_count;

		/* Skip this RU if it's already been reconstructed. */
		if (rf_CheckRUReconstructed(raidPtr->reconControl[row]
		    ->reconMap, rbuf->failedDiskSectorOffset)) {
			Dprintf2("Skipping psid %ld ru %d: already"
			    " reconstructed.\n", ctrl->curPSID, ctrl->ru_count);
			continue;
		}
		break;
	}
	ctrl->headSepCounter++;
	if (do_new_check)	/* Update min if needed. */
		rf_CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);


	/*
	 * At this point, we have definitely decided what to do, and we have
	 * only to see if we can actually do it now.
	 */
	rbuf->parityStripeID = ctrl->curPSID;
	rbuf->which_ru = ctrl->ru_count;
	bzero(&raidPtr->recon_tracerecs[col],
	    sizeof(raidPtr->recon_tracerecs[col]));
	raidPtr->recon_tracerecs[col].reconacc = 1;
	RF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);
	retcode = rf_TryToRead(raidPtr, row, col);
	return (retcode);
}

/*
 * Tries to issue the next read on the indicated disk. We may be
 * blocked by (a) the heads being too far apart, or (b) recon on the
 * indicated RU being blocked due to a write by a user thread. In
 * this case, we issue a head-sep or blockage wait request, which will
 * cause this same routine to be invoked again later when the blockage
 * has cleared.
 */

int
rf_TryToRead(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
{
	RF_PerDiskReconCtrl_t *ctrl =
	    &raidPtr->reconControl[row]->perDiskInfo[col];
	RF_SectorCount_t sectorsPerRU =
	    raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;
	RF_StripeNum_t psid = ctrl->curPSID;
	RF_ReconUnitNum_t which_ru = ctrl->ru_count;
	RF_DiskQueueData_t *req;
	int status, created = 0;
	RF_ReconParityStripeStatus_t *pssPtr;

	/*
	 * If the current disk is too far ahead of the others, issue a
	 * head-separation wait and return.
	 */
	if (rf_CheckHeadSeparation(raidPtr, ctrl, row, col,
	    ctrl->headSepCounter, which_ru))
		return (0);
	RF_LOCK_PSS_MUTEX(raidPtr, row, psid);
	pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]
	    ->pssTable, psid, which_ru, RF_PSS_CREATE, &created);

	/*
	 * If recon is blocked on the indicated parity stripe, issue a
	 * block-wait request and return. This also must mark the indicated RU
	 * in the stripe as under reconstruction if not blocked.
	 */
	status = rf_CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl,
	    row, col, psid, which_ru);
	if (status == RF_PSS_RECON_BLOCKED) {
		Dprintf2("RECON: Stalling psid %ld ru %d: recon blocked.\n",
		    psid, which_ru);
		goto out;
	} else
		if (status == RF_PSS_FORCED_ON_WRITE) {
			rf_CauseReconEvent(raidPtr, row, col, NULL,
			    RF_REVENT_SKIP);
			goto out;
		}
	/*
	 * Make one last check to be sure that the indicated RU didn't get
	 * reconstructed while we were waiting for something else to happen.
	 * This is unfortunate in that it causes us to make this check twice
	 * in the normal case. Might want to make some attempt to re-work
	 * this so that we only do this check if we've definitely blocked on
	 * one of the above checks. When this condition is detected, we may
	 * have just created a bogus status entry, which we need to delete.
	 */
	if (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap,
	    ctrl->rbuf->failedDiskSectorOffset)) {
		Dprintf2("RECON: Skipping psid %ld ru %d: prior recon after"
		    " stall.\n", psid, which_ru);
		if (created)
			rf_PSStatusDelete(raidPtr,
			    raidPtr->reconControl[row]->pssTable, pssPtr);
		rf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);
		goto out;
	}
	/* Found something to read. Issue the I/O. */
	Dprintf5("RECON: Read for psid %ld on row %d col %d offset %ld"
	    " buf %lx.\n", psid, row, col, ctrl->diskOffset,
	    ctrl->rbuf->buffer);
	RF_ETIMER_STOP(raidPtr->recon_tracerecs[col].recon_timer);
	RF_ETIMER_EVAL(raidPtr->recon_tracerecs[col].recon_timer);
	raidPtr->recon_tracerecs[col].specific.recon.recon_start_to_fetch_us =
	    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[col].recon_timer);
	RF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);

	/*
	 * Should be ok to use a NULL proc pointer here, all the bufs we use
	 * should be in kernel space.
	 */
	req = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset,
	    sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,
	    rf_ReconReadDoneProc, (void *) ctrl, NULL,
	    &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);

	RF_ASSERT(req);		/* XXX -- Fix this. -- XXX */

	ctrl->rbuf->arg = (void *) req;
	rf_DiskIOEnqueue(&raidPtr->Queues[row][col], req, RF_IO_RECON_PRIORITY);
	pssPtr->issued[col] = 1;

out:
	RF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);
	return (0);
}


/*
 * Given a parity stripe ID, we want to find out whether both the
 * current disk and the failed disk exist in that parity stripe. If
 * not, we want to skip this whole PS. If so, we want to find the
 * disk offset of the start of the PS on both the current disk and the
 * failed disk.
 *
 * This works by getting a list of disks comprising the indicated
 * parity stripe, and searching the list for the current and failed
 * disks. Once we've decided they both exist in the parity stripe, we
 * need to decide whether each is data or parity, so that we'll know
 * which mapping function to call to get the corresponding disk
 * offsets.
 *
 * This is kind of unpleasant, but doing it this way allows the
 * reconstruction code to use parity stripe IDs rather than physical
 * disks address to march through the failed disk, which greatly
 * simplifies a lot of code, as well as eliminating the need for a
 * reverse-mapping function. I also think it will execute faster,
 * since the calls to the mapping module are kept to a minimum.
 *
 * ASSUMES THAT THE STRIPE IDENTIFIER IDENTIFIES THE DISKS COMPRISING
 * THE STRIPE IN THE CORRECT ORDER.
 */

int
rf_ComputePSDiskOffsets(
    RF_Raid_t		*raidPtr,	/* RAID descriptor. */
    RF_StripeNum_t	 psid,		/* Parity stripe identifier. */
    RF_RowCol_t		 row,		/*
					 * Row and column of disk to find
					 * the offsets for.
					 */
    RF_RowCol_t		 col,
    RF_SectorNum_t	*outDiskOffset,
    RF_SectorNum_t	*outFailedDiskSectorOffset,
    RF_RowCol_t		*spRow,		/*
					 * OUT: Row,col of spare unit for
					 * failed unit.
					 */
    RF_RowCol_t		*spCol,
    RF_SectorNum_t	*spOffset	/*
					 * OUT: Offset into disk containing
					 * spare unit.
					 */
)
{
	RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
	RF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;
	RF_RaidAddr_t sosRaidAddress;	/* start-of-stripe */
	RF_RowCol_t *diskids;
	u_int i, j, k, i_offset, j_offset;
	RF_RowCol_t prow, pcol;
	int testcol, testrow;
	RF_RowCol_t stripe;
	RF_SectorNum_t poffset;
	char i_is_parity = 0, j_is_parity = 0;
	RF_RowCol_t stripeWidth =
	    layoutPtr->numDataCol + layoutPtr->numParityCol;

	/* Get a listing of the disks comprising that stripe. */
	sosRaidAddress = rf_ParityStripeIDToRaidAddress(layoutPtr, psid);
	(layoutPtr->map->IdentifyStripe) (raidPtr, sosRaidAddress, &diskids,
	    &stripe);
	RF_ASSERT(diskids);

	/*
	 * Reject this entire parity stripe if it does not contain the
	 * indicated disk or it does not contain the failed disk.
	 */
	if (row != stripe)
		goto skipit;
	for (i = 0; i < stripeWidth; i++) {
		if (col == diskids[i])
			break;
	}
	if (i == stripeWidth)
		goto skipit;
	for (j = 0; j < stripeWidth; j++) {
		if (fcol == diskids[j])
			break;
	}
	if (j == stripeWidth) {
		goto skipit;
	}
	/* Find out which disk the parity is on. */
	(layoutPtr->map->MapParity) (raidPtr, sosRaidAddress, &prow, &pcol,
	    &poffset, RF_DONT_REMAP);

	/* Find out if either the current RU or the failed RU is parity. */
	/*
	 * Also, if the parity occurs in this stripe prior to the data and/or
	 * failed col, we need to decrement i and/or j.
	 */
	for (k = 0; k < stripeWidth; k++)
		if (diskids[k] == pcol)
			break;
	RF_ASSERT(k < stripeWidth);
	i_offset = i;
	j_offset = j;
	if (k < i)
		i_offset--;
	else
		if (k == i) {
			i_is_parity = 1;
			i_offset = 0;
		}		/*
				 * Set offsets to zero to disable multiply
				 * below.
				 */
	if (k < j)
		j_offset--;
	else
		if (k == j) {
			j_is_parity = 1;
			j_offset = 0;
		}
	/*
	 * At this point, [ij]_is_parity tells us whether the [current,failed]
	 * disk is parity at the start of this RU, and, if data, "[ij]_offset"
	 * tells us how far into the stripe the [current,failed] disk is.
	 */

	/*
	 * Call the mapping routine to get the offset into the current disk,
	 * repeat for failed disk.
	 */
	if (i_is_parity)
		layoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outDiskOffset, RF_DONT_REMAP);
	else
		layoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outDiskOffset, RF_DONT_REMAP);

	RF_ASSERT(row == testrow && col == testcol);

	if (j_is_parity)
		layoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outFailedDiskSectorOffset, RF_DONT_REMAP);
	else
		layoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outFailedDiskSectorOffset, RF_DONT_REMAP);
	RF_ASSERT(row == testrow && fcol == testcol);

	/* Now locate the spare unit for the failed unit. */
	if (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {
		if (j_is_parity)
			layoutPtr->map->MapParity(raidPtr, sosRaidAddress +
			    j_offset * layoutPtr->sectorsPerStripeUnit, spRow,
			    spCol, spOffset, RF_REMAP);
		else
			layoutPtr->map->MapSector(raidPtr, sosRaidAddress +
			    j_offset * layoutPtr->sectorsPerStripeUnit, spRow,
			    spCol, spOffset, RF_REMAP);
	} else {
		*spRow = raidPtr->reconControl[row]->spareRow;
		*spCol = raidPtr->reconControl[row]->spareCol;
		*spOffset = *outFailedDiskSectorOffset;
	}

	return (0);

skipit:
	Dprintf3("RECON: Skipping psid %ld: nothing needed from r%d c%d.\n",
	    psid, row, col);
	return (1);
}


/*
 * This is called when a buffer has become ready to write to the replacement
 * disk.
 */
int
rf_IssueNextWriteRequest(RF_Raid_t *raidPtr, RF_RowCol_t row)
{
	RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
	RF_SectorCount_t sectorsPerRU =
	    layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;
	RF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;
	RF_ReconBuffer_t *rbuf;
	RF_DiskQueueData_t *req;

	rbuf = rf_GetFullReconBuffer(raidPtr->reconControl[row]);
	RF_ASSERT(rbuf);	/*
				 * There must be one available, or we wouldn't
				 * have gotten the event that sent us here.
				 */
	RF_ASSERT(rbuf->pssPtr);

	rbuf->pssPtr->writeRbuf = rbuf;
	rbuf->pssPtr = NULL;

	Dprintf7("RECON: New write (r %d c %d offs %d) for psid %ld ru %d"
	    " (failed disk offset %ld) buf %lx.\n",
	    rbuf->spRow, rbuf->spCol, rbuf->spOffset, rbuf->parityStripeID,
	    rbuf->which_ru, rbuf->failedDiskSectorOffset, rbuf->buffer);
	Dprintf6("RECON: new write psid %ld   %02x %02x %02x %02x %02x.\n",
	    rbuf->parityStripeID, rbuf->buffer[0] & 0xff,
	    rbuf->buffer[1] & 0xff, rbuf->buffer[2] & 0xff,
	    rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);

	/*
	 * Should be ok to use a NULL b_proc here b/c all addrs should be in
	 * kernel space.
	 */
	req = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, rbuf->spOffset,
	    sectorsPerRU, rbuf->buffer, rbuf->parityStripeID, rbuf->which_ru,
	    rf_ReconWriteDoneProc, (void *) rbuf, NULL,
	    &raidPtr->recon_tracerecs[fcol], (void *) raidPtr, 0, NULL);

	RF_ASSERT(req);		/* XXX -- Fix this. -- XXX */

	rbuf->arg = (void *) req;
	rf_DiskIOEnqueue(&raidPtr->Queues[rbuf->spRow][rbuf->spCol], req,
	    RF_IO_RECON_PRIORITY);

	return (0);
}

/*
 * This gets called upon the completion of a reconstruction read
 * operation. The arg is a pointer to the per-disk reconstruction
 * control structure for the process that just finished a read.
 *
 * Called at interrupt context in the kernel, so don't do anything
 * illegal here.
 */
int
rf_ReconReadDoneProc(void *arg, int status)
{
	RF_PerDiskReconCtrl_t *ctrl = (RF_PerDiskReconCtrl_t *) arg;
	RF_Raid_t *raidPtr = ctrl->reconCtrl->reconDesc->raidPtr;

	if (status) {
		/*
		 * XXX
		 */
		printf("Recon read failed !\n");
		RF_PANIC();
	}
	RF_ETIMER_STOP(raidPtr->recon_tracerecs[ctrl->col].recon_timer);
	RF_ETIMER_EVAL(raidPtr->recon_tracerecs[ctrl->col].recon_timer);
	raidPtr->recon_tracerecs[ctrl->col].specific.recon.
	   recon_fetch_to_return_us =
	     RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[ctrl->col].recon_timer);
	RF_ETIMER_START(raidPtr->recon_tracerecs[ctrl->col].recon_timer);

	rf_CauseReconEvent(raidPtr, ctrl->row, ctrl->col, NULL,
	    RF_REVENT_READDONE);
	return (0);
}


/*
 * This gets called upon the completion of a reconstruction write operation.
 * The arg is a pointer to the rbuf that was just written.
 *
 * Called at interrupt context in the kernel, so don't do anything illegal here.
 */
int
rf_ReconWriteDoneProc(void *arg, int status)
{
	RF_ReconBuffer_t *rbuf = (RF_ReconBuffer_t *) arg;

	Dprintf2("Reconstruction completed on psid %ld ru %d.\n",
	    rbuf->parityStripeID, rbuf->which_ru);
	if (status) {
		/* fprintf(stderr, "Recon write failed !\n"); */
		printf("Recon write failed !\n");
		RF_PANIC();
	}
	rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col,
	    arg, RF_REVENT_WRITEDONE);
	return (0);
}


/*
 * Computes a new minimum head sep, and wakes up anyone who needs to
 * be woken as a result.
 */
void
rf_CheckForNewMinHeadSep(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_HeadSepLimit_t hsCtr)
{
	RF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];
	RF_HeadSepLimit_t new_min;
	RF_RowCol_t i;
	RF_CallbackDesc_t *p;
	/* From the definition of a minimum. */
	RF_ASSERT(hsCtr >= reconCtrlPtr->minHeadSepCounter);


	RF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);

	new_min = ~(1L << (8 * sizeof(long) - 1));	/* 0x7FFF....FFF */
	for (i = 0; i < raidPtr->numCol; i++)
		if (i != reconCtrlPtr->fcol) {
			if (reconCtrlPtr->perDiskInfo[i].headSepCounter <
			    new_min)
				new_min =
				    reconCtrlPtr->perDiskInfo[i].headSepCounter;
		}
	/* Set the new minimum and wake up anyone who can now run again. */
	if (new_min != reconCtrlPtr->minHeadSepCounter) {
		reconCtrlPtr->minHeadSepCounter = new_min;
		Dprintf1("RECON:  new min head pos counter val is %ld.\n",
		    new_min);
		while (reconCtrlPtr->headSepCBList) {
			if (reconCtrlPtr->headSepCBList->callbackArg.v >
			    new_min)
				break;
			p = reconCtrlPtr->headSepCBList;
			reconCtrlPtr->headSepCBList = p->next;
			p->next = NULL;
			rf_CauseReconEvent(raidPtr, p->row, p->col, NULL,
			    RF_REVENT_HEADSEPCLEAR);
			rf_FreeCallbackDesc(p);
		}

	}
	RF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);
}

/*
 * Checks to see that the maximum head separation will not be violated
 * if we initiate a reconstruction I/O on the indicated disk.
 * Limiting the maximum head separation between two disks eliminates
 * the nasty buffer-stall conditions that occur when one disk races
 * ahead of the others and consumes all of the floating recon buffers.
 * This code is complex and unpleasant but it's necessary to avoid
 * some very nasty, albeit fairly rare, reconstruction behavior.
 *
 * Returns non-zero if and only if we have to stop working on the
 * indicated disk due to a head-separation delay.
 */
int
rf_CheckHeadSeparation(
    RF_Raid_t			*raidPtr,
    RF_PerDiskReconCtrl_t	*ctrl,
    RF_RowCol_t			 row,
    RF_RowCol_t			 col,
    RF_HeadSepLimit_t		 hsCtr,
    RF_ReconUnitNum_t		 which_ru
)
{
	RF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];
	RF_CallbackDesc_t *cb, *p, *pt;
	int retval = 0;

	/*
	 * If we're too far ahead of the slowest disk, stop working on this
	 * disk until the slower ones catch up. We do this by scheduling a
	 * wakeup callback for the time when the slowest disk has caught up.
	 * We define "caught up" with 20% hysteresis, i.e. the head separation
	 * must have fallen to at most 80% of the max allowable head
	 * separation before we'll wake up.
	 */
	RF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);
	if ((raidPtr->headSepLimit >= 0) &&
	    ((ctrl->headSepCounter - reconCtrlPtr->minHeadSepCounter) >
	     raidPtr->headSepLimit)) {
		Dprintf6("raid%d: RECON: head sep stall: row %d col %d hsCtr"
		    " %ld minHSCtr %ld limit %ld.\n",
		    raidPtr->raidid, row, col, ctrl->headSepCounter,
		    reconCtrlPtr->minHeadSepCounter, raidPtr->headSepLimit);
		cb = rf_AllocCallbackDesc();
		/*
		 * The minHeadSepCounter value we have to get to before we'll
		 * wake up. Build in 20% hysteresis.
		 */
		cb->callbackArg.v = (ctrl->headSepCounter -
		    raidPtr->headSepLimit + raidPtr->headSepLimit / 5);
		cb->row = row;
		cb->col = col;
		cb->next = NULL;

		/*
		 * Insert this callback descriptor into the sorted list of
		 * pending head-sep callbacks.
		 */
		p = reconCtrlPtr->headSepCBList;
		if (!p)
			reconCtrlPtr->headSepCBList = cb;
		else
			if (cb->callbackArg.v < p->callbackArg.v) {
				cb->next = reconCtrlPtr->headSepCBList;
				reconCtrlPtr->headSepCBList = cb;
			} else {
				for (pt = p, p = p->next;
				    p && (p->callbackArg.v < cb->callbackArg.v);
				    pt = p, p = p->next);
				cb->next = p;
				pt->next = cb;
			}
		retval = 1;
#if	RF_RECON_STATS > 0
		ctrl->reconCtrl->reconDesc->hsStallCount++;
#endif	/* RF_RECON_STATS > 0 */
	}
	RF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);

	return (retval);
}



/*
 * Checks to see if reconstruction has been either forced or blocked
 * by a user operation. If forced, we skip this RU entirely. Else if
 * blocked, put ourselves on the wait list. Else return 0.
 *
 * ASSUMES THE PSS MUTEX IS LOCKED UPON ENTRY.
 */
int
rf_CheckForcedOrBlockedReconstruction(
    RF_Raid_t			 *raidPtr,
    RF_ReconParityStripeStatus_t *pssPtr,
    RF_PerDiskReconCtrl_t	 *ctrl,
    RF_RowCol_t			  row,
    RF_RowCol_t			  col,
    RF_StripeNum_t		  psid,
    RF_ReconUnitNum_t		  which_ru
)
{
	RF_CallbackDesc_t *cb;
	int retcode = 0;

	if ((pssPtr->flags & RF_PSS_FORCED_ON_READ) ||
	    (pssPtr->flags & RF_PSS_FORCED_ON_WRITE))
		retcode = RF_PSS_FORCED_ON_WRITE;
	else
		if (pssPtr->flags & RF_PSS_RECON_BLOCKED) {
			Dprintf4("RECON: row %d col %d blocked at psid %ld"
			    " ru %d.\n", row, col, psid, which_ru);
			cb = rf_AllocCallbackDesc();	/*
							 * Append ourselves to
							 * the blockage-wait
							 * list.
							 */
			cb->row = row;
			cb->col = col;
			cb->next = pssPtr->blockWaitList;
			pssPtr->blockWaitList = cb;
			retcode = RF_PSS_RECON_BLOCKED;
		}
	if (!retcode)
		pssPtr->flags |= RF_PSS_UNDER_RECON;	/*
							 * Mark this RU as under
							 * reconstruction.
							 */

	return (retcode);
}


/*
 * If reconstruction is currently ongoing for the indicated stripeID,
 * reconstruction is forced to completion and we return non-zero to
 * indicate that the caller must wait. If not, then reconstruction is
 * blocked on the indicated stripe and the routine returns zero. If
 * and only if we return non-zero, we'll cause the cbFunc to get
 * invoked with the cbArg when the reconstruction has completed.
 */
int
rf_ForceOrBlockRecon(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap,
	void (*cbFunc) (RF_Raid_t *, void *), void *cbArg)
{
	RF_RowCol_t row = asmap->physInfo->row;	/*
						 * Which row of the array
						 * we're working on.
						 */
	RF_StripeNum_t stripeID = asmap->stripeID;	/*
							 * The stripe ID we're
							 * forcing recon on.
							 */
	RF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit *
	    raidPtr->Layout.SUsPerRU;		/* Num sects in one RU. */
	RF_ReconParityStripeStatus_t *pssPtr;	/*
						 * A pointer to the parity
						 * stripe status structure.
						 */
	RF_StripeNum_t psid;			/* Parity stripe id. */
	RF_SectorNum_t offset, fd_offset;	/*
						 * Disk offset, failed-disk
						 * offset.
						 */
	RF_RowCol_t *diskids;
	RF_RowCol_t stripe;
	RF_ReconUnitNum_t which_ru;	/* RU within parity stripe. */
	RF_RowCol_t fcol, diskno, i;
	RF_ReconBuffer_t *new_rbuf;	/* Ptr to newly allocated rbufs. */
	RF_DiskQueueData_t *req;	/* Disk I/O req to be enqueued. */
	RF_CallbackDesc_t *cb;
	int created = 0, nPromoted;

	psid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID,
	    &which_ru);

	RF_LOCK_PSS_MUTEX(raidPtr, row, psid);

	pssPtr = rf_LookupRUStatus(raidPtr,
	    raidPtr->reconControl[row]->pssTable, psid, which_ru,
	    RF_PSS_CREATE | RF_PSS_RECON_BLOCKED, &created);

	/* If recon is not ongoing on this PS, just return. */
	if (!(pssPtr->flags & RF_PSS_UNDER_RECON)) {
		RF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);
		return (0);
	}
	/*
	 * Otherwise, we have to wait for reconstruction to complete on this
	 * RU.
	 */
	/*
	 * In order to avoid waiting for a potentially large number of
	 * low-priority accesses to complete, we force a normal-priority (i.e.
	 * not low-priority) reconstruction on this RU.
	 */
	if (!(pssPtr->flags & RF_PSS_FORCED_ON_WRITE) &&
	    !(pssPtr->flags & RF_PSS_FORCED_ON_READ)) {
		DDprintf1("Forcing recon on psid %ld.\n", psid);
		/* Mark this RU as under forced recon. */
		pssPtr->flags |= RF_PSS_FORCED_ON_WRITE;
		/* Clear the blockage that we just set. */
		pssPtr->flags &= ~RF_PSS_RECON_BLOCKED;
		fcol = raidPtr->reconControl[row]->fcol;

		/*
		 * Get a listing of the disks comprising the indicated stripe.
		 */
		(raidPtr->Layout.map->IdentifyStripe) (raidPtr,
		    asmap->raidAddress, &diskids, &stripe);
		RF_ASSERT(row == stripe);

		/*
		 * For previously issued reads, elevate them to normal
		 * priority. If the I/O has already completed, it won't be
		 * found in the queue, and hence this will be a no-op. For
		 * unissued reads, allocate buffers and issue new reads. The
		 * fact that we've set the FORCED bit means that the regular
		 * recon procs will not re-issue these reqs.
		 */
		for (i = 0; i < raidPtr->Layout.numDataCol +
		    raidPtr->Layout.numParityCol; i++)
			if ((diskno = diskids[i]) != fcol) {
				if (pssPtr->issued[diskno]) {
					nPromoted = rf_DiskIOPromote(&raidPtr
					    ->Queues[row][diskno], psid,
					    which_ru);
					if (rf_reconDebug && nPromoted)
						printf("raid%d: promoted read"
						    " from row %d col %d.\n",
						    raidPtr->raidid, row,
						    diskno);
				} else {
					/* Create new buf. */
					new_rbuf = rf_MakeReconBuffer(raidPtr,
					    row, diskno, RF_RBUF_TYPE_FORCED);
					/* Find offsets & spare locationp */
					rf_ComputePSDiskOffsets(raidPtr, psid,
					    row, diskno, &offset, &fd_offset,
					    &new_rbuf->spRow, &new_rbuf->spCol,
					    &new_rbuf->spOffset);
					new_rbuf->parityStripeID = psid;
					/* Fill in the buffer. */
					new_rbuf->which_ru = which_ru;
					new_rbuf->failedDiskSectorOffset =
					    fd_offset;
					new_rbuf->priority =
					    RF_IO_NORMAL_PRIORITY;

					/*
					 * Use NULL b_proc b/c all addrs
					 * should be in kernel space.
					 */
					req = rf_CreateDiskQueueData(
					    RF_IO_TYPE_READ, offset +
					    which_ru * sectorsPerRU,
					    sectorsPerRU, new_rbuf->buffer,
					    psid, which_ru, (int (*)
					    (void *, int))
					      rf_ForceReconReadDoneProc,
					    (void *) new_rbuf, NULL,
					    NULL, (void *) raidPtr, 0, NULL);

					RF_ASSERT(req);	/*
							 * XXX -- Fix this. --
							 * XXX
							 */

					new_rbuf->arg = req;
					/* Enqueue the I/O. */
					rf_DiskIOEnqueue(&raidPtr
					    ->Queues[row][diskno], req,
					    RF_IO_NORMAL_PRIORITY);
					Dprintf3("raid%d: Issued new read req"
					    " on row %d col %d.\n",
					    raidPtr->raidid, row, diskno);
				}
			}
		/*
		 * If the write is sitting in the disk queue, elevate its
		 * priority.
		 */
		if (rf_DiskIOPromote(&raidPtr->Queues[row][fcol],
		    psid, which_ru))
			printf("raid%d: promoted write to row %d col %d.\n",
			    raidPtr->raidid, row, fcol);
	}
	/*
	 * Install a callback descriptor to be invoked when recon completes on
	 * this parity stripe.
	 */
	cb = rf_AllocCallbackDesc();
	/*
	 * XXX The following is bogus... These functions don't really match !!!
	 * GO
	 */
	cb->callbackFunc = (void (*) (RF_CBParam_t)) cbFunc;
	cb->callbackArg.p = (void *) cbArg;
	cb->next = pssPtr->procWaitList;
	pssPtr->procWaitList = cb;
	DDprintf2("raid%d: Waiting for forced recon on psid %ld.\n",
	    raidPtr->raidid, psid);

	RF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);
	return (1);
}


/*
 * Called upon the completion of a forced reconstruction read.
 * All we do is schedule the FORCEDREADONE event.
 * Called at interrupt context in the kernel, so don't do anything illegal here.
 */
void
rf_ForceReconReadDoneProc(void *arg, int status)
{
	RF_ReconBuffer_t *rbuf = arg;

	if (status) {
		/* fprintf(stderr, "Forced recon read failed !\n"); */
		printf("Forced recon read failed !\n");
		RF_PANIC();
	}
	rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col,
	    (void *) rbuf, RF_REVENT_FORCEDREADDONE);
}


/* Releases a block on the reconstruction of the indicated stripe. */
int
rf_UnblockRecon(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap)
{
	RF_RowCol_t row = asmap->origRow;
	RF_StripeNum_t stripeID = asmap->stripeID;
	RF_ReconParityStripeStatus_t *pssPtr;
	RF_ReconUnitNum_t which_ru;
	RF_StripeNum_t psid;
	int created = 0;
	RF_CallbackDesc_t *cb;

	psid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID,
	    &which_ru);
	RF_LOCK_PSS_MUTEX(raidPtr, row, psid);
	pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]
	    ->pssTable, psid, which_ru, RF_PSS_NONE, &created);

	/*
	 * When recon is forced, the pss desc can get deleted before we get
	 * back to unblock recon. But, this can _only_ happen when recon is
	 * forced. It would be good to put some kind of sanity check here, but
	 * how to decide if recon was just forced or not ?
	 */
	if (!pssPtr) {
		/*
		 * printf("Warning: no pss descriptor upon unblock on psid %ld"
		 *     " RU %d.\n", psid, which_ru);
		 */
		if (rf_reconDebug || rf_pssDebug)
			printf("Warning: no pss descriptor upon unblock on"
			    " psid %ld RU %d.\n", (long) psid, which_ru);
		goto out;
	}
	pssPtr->blockCount--;
	Dprintf3("raid%d: unblocking recon on psid %ld: blockcount is %d.\n",
	    raidPtr->raidid, psid, pssPtr->blockCount);
	if (pssPtr->blockCount == 0) {
		/* If recon blockage has been released. */

		/*
		 * Unblock recon before calling CauseReconEvent in case
		 * CauseReconEvent causes us to try to issue a new read before
		 * returning here.
		 */
		pssPtr->flags &= ~RF_PSS_RECON_BLOCKED;


		while (pssPtr->blockWaitList) {
			/*
			 * Spin through the block-wait list and
			 * release all the waiters.
			 */
			cb = pssPtr->blockWaitList;
			pssPtr->blockWaitList = cb->next;
			cb->next = NULL;
			rf_CauseReconEvent(raidPtr, cb->row, cb->col, NULL,
			    RF_REVENT_BLOCKCLEAR);
			rf_FreeCallbackDesc(cb);
		}
		if (!(pssPtr->flags & RF_PSS_UNDER_RECON)) {
			/* If no recon was requested while recon was blocked. */
			rf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]
			    ->pssTable, pssPtr);
		}
	}
out:
	RF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);
	return (0);
}
@


1.18
log
@remove stupid casts, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.17 2010/05/23 13:49:35 naddy Exp $	*/
@


1.17
log
@missing dkio.h includes; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.16 2007/06/05 00:38:22 deraadt Exp $	*/
d1168 1
a1168 1
	bzero((char *) &raidPtr->recon_tracerecs[col],
@


1.16
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.15 2003/10/26 15:07:26 jmc Exp $	*/
d47 1
@


1.15
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.14 2003/01/19 14:27:01 tdeval Exp $	*/
d626 1
a626 1
			    dpart.part->p_size - rf_protectedSectors;
@


1.14
log
@Wording.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.13 2002/12/16 07:01:05 tdeval Exp $	*/
d508 1
a508 1
			    " occuring !\n", row, col);
@


1.13
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.12 2002/08/09 15:10:20 tdeval Exp $	*/
d571 1
a571 1
			printf("Closing the open device: %s\n",
d646 1
a646 1
		printf("RECON: initiating in-place reconstruction on\n");
@


1.12
log
@Remove those noisy informational messages from dmesg.
Use the option RAIDDEBUG to get these.

Theo, thanks for suggesting.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.11 2002/03/14 01:27:02 millert Exp $	*/
d3 1
d31 1
a31 1
/************************************************************
d33 1
a33 1
 * rf_reconstruct.c -- code to perform on-line reconstruction
d35 1
a35 1
 ************************************************************/
d48 1
a48 1
#if __NETBSD__
d69 4
a72 1
/* setting these to -1 causes them to be set to their default values if not set by debug options */
d74 92
a165 11
#define Dprintf(s)         if (rf_reconDebug) rf_debug_printf(s,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf1(s,a)         if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf2(s,a,b)       if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf3(s,a,b,c)     if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),NULL,NULL,NULL,NULL,NULL)
#define Dprintf4(s,a,b,c,d)   if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),NULL,NULL,NULL,NULL)
#define Dprintf5(s,a,b,c,d,e) if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),NULL,NULL,NULL)
#define Dprintf6(s,a,b,c,d,e,f) if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),NULL,NULL)
#define Dprintf7(s,a,b,c,d,e,f,g) if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),(void *)((unsigned long)g),NULL)

#define DDprintf1(s,a)         if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define DDprintf2(s,a,b)       if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),NULL,NULL,NULL,NULL,NULL,NULL)
d168 2
a169 2
#define RF_MAX_FREE_RECOND  4
#define RF_RECOND_INC       1
d171 11
a181 7
RF_RaidReconDesc_t *rf_AllocRaidReconDesc(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t, RF_RaidDisk_t *, int, RF_RowCol_t, RF_RowCol_t);
int rf_ProcessReconEvent(RF_Raid_t *, RF_RowCol_t, RF_ReconEvent_t *);
int rf_IssueNextReadRequest(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int rf_TryToRead(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int rf_ComputePSDiskOffsets(RF_Raid_t *, RF_StripeNum_t, RF_RowCol_t, RF_RowCol_t, RF_SectorNum_t *, RF_SectorNum_t *, RF_RowCol_t *, RF_RowCol_t *, RF_SectorNum_t *);
int rf_ReconReadDoneProc(void *, int);
int rf_ReconWriteDoneProc(void *, int);
d183 2
a184 1
int rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);
d189 2
a190 2
 * these functions are inlined on gcc. If they are used more than
 * once, it is strongly advised to un-line them
d193 4
a196 2
int rf_IssueNextWriteRequest(RF_Raid_t *, RF_RowCol_t);
int rf_CheckForcedOrBlockedReconstruction(RF_Raid_t *, RF_ReconParityStripeStatus_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_StripeNum_t, RF_ReconUnitNum_t);
d200 3
a202 3
	void    (*proc) (RF_Raid_t *, void *);
	void   *arg;
	RF_ReconDoneProc_t *next;
d206 2
a207 2
#define RF_MAX_FREE_RDP 4
#define RF_RDP_INC      1
d209 2
a210 2
void 
rf_SignalReconDone(RF_Raid_t * raidPtr)
d221 3
a223 6
int 
rf_RegisterReconDoneProc(
    RF_Raid_t * raidPtr,
    void (*proc) (RF_Raid_t *, void *),
    void *arg,
    RF_ReconDoneProc_t ** handlep)
d240 2
a241 1
/**************************************************************************
d243 2
a244 2
 * sets up the parameters that will be used by the reconstruction process
 * currently there are none, except for those that the layout-specific
d247 1
a247 1
 * in the kernel, we fire off the recon thread.
d249 3
a251 4
 **************************************************************************/
void 
rf_ShutdownReconstruction(ignored)
	void   *ignored;
d257 2
a258 3
int 
rf_ConfigureReconstruction(listp)
	RF_ShutdownList_t **listp;
d260 1
a260 1
	int     rc;
d269 2
a270 1
		RF_FREELIST_DESTROY(rf_recond_freelist, next, (RF_RaidReconDesc_t *));
d275 2
a276 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d284 3
a286 8
rf_AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
	RF_RowCol_t col;
	RF_RaidDisk_t *spareDiskPtr;
	int     numDisksDone;
	RF_RowCol_t srow;
	RF_RowCol_t scol;
d291 2
a292 1
	RF_FREELIST_GET(rf_recond_freelist, reconDesc, next, (RF_RaidReconDesc_t *));
d307 2
a308 3
void 
rf_FreeReconDesc(reconDesc)
	RF_RaidReconDesc_t *reconDesc;
d310 2
a311 2
#if RF_RECON_STATS > 0
	printf("RAIDframe: %qu recon event waits, %qu recon delays\n",
d313 1
a313 1
#endif /* RF_RECON_STATS > 0 */
d315 2
a316 1
	printf("RAIDframe: %qu max exec ticks\n", reconDesc->maxReconExecTicks);
d318 1
a318 1
#if (RF_RECON_STATS > 0) || defined(_KERNEL)
d320 1
a320 1
#endif /* (RF_RECON_STATS > 0) || _KERNEL */
d325 1
a325 1
/***********************************************************************
d327 2
a328 2
 * primary routine to reconstruct a failed disk.  This should be called from
 * within its own thread.  It won't return until reconstruction completes,
d331 3
a333 6
 ***********************************************************************/
int 
rf_ReconstructFailedDisk(raidPtr, row, col)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
	RF_RowCol_t col;
d336 1
a336 1
	int     rc;
d341 3
a343 3
	         * The current infrastructure only supports reconstructing one
	         * disk at a time for each array.
	         */
d355 2
a356 2
		RF_ERRORMSG1("RECON: no way to reconstruct failed disk for arch %c\n",
		    lp->parityConfig);
d360 4
a363 2
	wakeup(&raidPtr->waitForReconCond);	/* XXX Methinks this will be
						 * needed at some point... GO */
d367 3
a369 5
int 
rf_ReconstructFailedDiskBasic(raidPtr, row, col)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
	RF_RowCol_t col;
d375 1
a375 1
	int     numDisksDone = 0, rc;
d377 5
a381 3
	/* first look for a spare drive onto which to reconstruct the data */
	/* spare disk descriptors are stored in row 0.  This may have to
	 * change eventually */
d388 2
a389 1
			RF_ERRORMSG2("Unable to reconstruct disk at row %d col %d because status not degraded\n", row, col);
d397 2
a398 1
		for (scol = raidPtr->numCol; scol < raidPtr->numCol + raidPtr->numSpare; scol++) {
d406 3
a408 1
			RF_ERRORMSG2("Unable to reconstruct disk at row %d col %d because no spares are available\n", row, col);
d412 2
a413 1
		printf("RECON: initiating reconstruction on row %d col %d -> spare at row %d col %d\n", row, col, srow, scol);
d417 2
a418 1
	reconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol);
d420 1
a420 1
#if RF_RECON_STATS > 0
d424 1
a424 1
#endif				/* RF_RECON_STATS > 0 */
d431 2
a432 2
		/* fix up the component label */
		/* Don't actually need the read here.. */
d434 5
a438 5
                        raidPtr->raid_cinfo[srow][scol].ci_dev,
			raidPtr->raid_cinfo[srow][scol].ci_vp,
			&c_label);
		
		raid_init_component_label( raidPtr, &c_label);
d444 2
a445 2
		/* XXXX MORE NEEDED HERE */
		
d447 4
a450 4
                        raidPtr->raid_cinfo[srow][scol].ci_dev,
			raidPtr->raid_cinfo[srow][scol].ci_vp,
			&c_label);
		
d455 9
a463 9
/* 

   Allow reconstructing a disk in-place -- i.e. component /dev/sd2e goes AWOL,
   and you don't get a spare until the next Monday.  With this function 
   (and hot-swappable drives) you can now put your new disk containing 
   /dev/sd2e on the bus, scsictl it alive, and then use raidctl(8) to
   rebuild the data "on the spot".

*/
d466 1
a466 4
rf_ReconstructInPlace(raidPtr, row, col)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
	RF_RowCol_t col;
d473 1
a473 1
	int     numDisksDone = 0, rc;
d484 3
a486 3
	         * The current infrastructure only supports reconstructing one
	         * disk at a time for each array.
	         */
d489 7
a495 5
		    (raidPtr->numFailures > 0)) { 
			/* XXX 0 above shouldn't be constant!!! */
			/* some component other than this has failed.
			   Let's not make things worse than they already
			   are... */
d497 3
a499 3
			printf("RAIDFRAME: Unable to reconstruct to disk at:\n");
			printf("      Row: %d Col: %d   Too many failures.\n",
			       row, col);
d506 3
a508 2
			printf("RAIDFRAME: Unable to reconstruct to disk at:\n");
			printf("      Row: %d Col: %d   Reconstruction already occuring!\n", row, col);
d521 2
a522 2
			rf_update_component_labels(raidPtr, 
						   RF_NORMAL_COMPONENT_UPDATE);
d531 5
d537 7
a543 8
		/* first look for a spare drive onto which to reconstruct 
		   the data.  spare disk descriptors are stored in row 0. 
		   This may have to change eventually */

		/* Actually, we don't care if it's failed or not... 
		   On a RAID set with correct parity, this function
		   should be callable on any component without ill affects. */
		/* RF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);
d547 3
a549 1
			RF_ERRORMSG2("Unable to reconstruct to disk at row %d col %d: operation not supported for RF_DISTRIBUTE_SPARE\n", row, col);
d554 1
a554 5
		}			

		/* XXX need goop here to see if the disk is alive,
		   and, if not, make it so...  */
		
d556 4
d565 4
a568 2
		/* This device may have been opened successfully the 
		   first time. Close it before trying to open it again.. */
d572 1
a572 1
			       raidPtr->Disks[row][col].devname);
d578 3
a580 1
		/* note that this disk was *not* auto_configured (any longer)*/
d584 5
a588 5
		       raidPtr->Disks[row][col].devname);
		
		retcode = raidlookup(raidPtr->Disks[row][col].devname, 
				     proc, &vp);
	
d590 8
a597 6
			printf("raid%d: rebuilding: raidlookup on device: %s failed: %d!\n",
			       raidPtr->raidid,
			       raidPtr->Disks[row][col].devname, retcode);

			/* XXX the component isn't responding properly... 
			   must be still dead :-( */
d604 4
a607 2
			/* Ok, so we can at least do a lookup... 
			   How about actually getting a vp for it? */
d609 2
a610 2
			if ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, 
						   proc)) != 0) {
d616 1
a616 1
					    FREAD, proc->p_ucred, proc);
d623 4
a626 1
				dpart.disklab->d_secsize;
a627 3
			raidPtr->Disks[row][col].numBlocks = 
				dpart.part->p_size - rf_protectedSectors;
			
d630 1
a630 1
			
d632 6
a637 5
			
			/* we allow the user to specify that only a 
			   fraction of the disks should be used this is 
			   just for debug:  it speeds up
			 * the parity scan */
d639 2
a640 2
				raidPtr->Disks[row][col].numBlocks *
				rf_sizePercentage / 100;
a642 2


d647 2
a648 2
		printf("       row %d col %d -> spare at row %d col %d\n", 
		       row, col, row, col);
d651 3
a653 4
		
		reconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col, 
					       spareDiskPtr, numDisksDone, 
					       row, col);
d655 1
a655 1
#if RF_RECON_STATS > 0
d659 1
a659 1
#endif				/* RF_RECON_STATS > 0 */
d670 2
a671 2
		RF_ERRORMSG1("RECON: no way to reconstruct failed disk for arch %c\n",
			     lp->parityConfig);
d675 1
a675 1
	
d677 5
a681 3
		/* Need to set these here, as at this point it'll be claiming
		   that the disk is in rf_ds_spared!  But we know better :-) */
		
d684 7
a690 6
		
		/* fix up the component label */
		/* Don't actually need the read here.. */
		raidread_component_label(raidPtr->raid_cinfo[row][col].ci_dev,
					 raidPtr->raid_cinfo[row][col].ci_vp,
					 &c_label);
d696 1
a696 1
		
d698 1
a698 2
					  raidPtr->raid_cinfo[row][col].ci_vp,
					  &c_label);
d703 1
a703 1
	wakeup(&raidPtr->waitForReconCond);	
d708 2
a709 3
int 
rf_ContinueReconstructFailedDisk(reconDesc)
	RF_RaidReconDesc_t *reconDesc;
d721 1
a721 1
	int     retcode, i, ds;
d727 3
a729 2
		/* create one trace record per physical disk */
		RF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d731 2
a732 1
		/* quiesce the array prior to starting recon.  this is needed
d734 2
a735 1
		 * We need to do this before we change the disk or row status. */
d738 1
a738 1
		Dprintf("RECON: begin request suspend\n");
d740 6
a745 4
		Dprintf("RECON: end request suspend\n");
		rf_StartUserStats(raidPtr);	/* zero out the stats kept on
						 * user accs */
		/* fall through to state 1 */
d749 6
a754 3
		/* create the reconstruction control pointer and install it in
		 * the right slot */
		raidPtr->reconControl[row] = rf_MakeReconControl(reconDesc, row, col, srow, scol);
d765 4
a768 2
		/* now start up the actual reconstruction: issue a read for
		 * each surviving disk */
d773 4
a776 2
				/* find and issue the next I/O on the
				 * indicated disk */
d778 2
a779 1
					Dprintf2("RECON: done issuing for r%d c%d\n", row, i);
d788 1
a788 1
		Dprintf("RECON: resume requests\n");
a790 1

d795 4
a798 2
		/* process reconstruction events until all disks report that
		 * they've completed all work */
d803 3
a805 1
			event = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);
d810 1
a810 1
			raidPtr->reconControl[row]->numRUsTotal = 
d812 2
a813 2
			raidPtr->reconControl[row]->numRUsComplete = 
				mapPtr->totalRUs - 
d816 3
a818 2
			raidPtr->reconControl[row]->percentComplete = 
				(raidPtr->reconControl[row]->numRUsComplete * 100 / raidPtr->reconControl[row]->numRUsTotal);
d820 3
a822 1
				rf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));
d831 1
a831 1
			printf("RECON: all reads completed\n");
d833 4
a836 2
		/* at this point all the reads have completed.  We now wait
		 * for any pending writes to complete, and then we're done */
d838 2
a839 1
		while (rf_UnitsLeftToReconstruct(raidPtr->reconControl[row]->reconMap) > 0) {
d841 3
a843 1
			event = rf_GetNextReconEvent(reconDesc, row, (void (*) (void *)) rf_ContinueReconstructFailedDisk, reconDesc);
d846 5
a850 2
			(void) rf_ProcessReconEvent(raidPtr, row, event);	/* ignore return code */
			raidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);
d852 3
a854 1
				rf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));
d860 2
a861 1
		/* Success:  mark the dead disk as reconstructed.  We quiesce
d863 3
a865 2
		 * user accesses when we free up the psstatus structure as
		 * part of FreeReconControl() */
d871 2
a872 1
		rf_PrintUserStats(raidPtr);	/* print out the stats on user
d874 2
a875 1
						 * recon */
d877 1
a877 1
		/* fall through to state 6 */
d882 4
a885 2
		raidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared : rf_ds_spared;
		raidPtr->status[row] = (ds) ? rf_rs_reconfigured : rf_rs_optimal;
d888 2
a889 1
		RF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime), &etime, &elpsd);
d891 3
a893 2
		/* XXX -- why is state 7 different from state 6 if there is no
		 * return() here? -- XXX Note that I set elpsd above & use it
d895 2
a896 1
		 * (also, FreeReconControl is called below) */
d902 2
a903 2
		printf("Reconstruction of disk at row %d col %d completed\n", 
		       row, col);
d906 6
a911 3
		printf("Recon time was %d.%06d seconds, accumulated XOR time was %ld us (%ld.%06ld)\n",
		    (int) elpsd.tv_sec, (int) elpsd.tv_usec, raidPtr->accumXorTimeUs, xor_s, xor_resid_us);
		printf("  (start time %d sec %d usec, end time %d sec %d usec)\n",
d916 2
a917 2
#if RF_RECON_STATS > 0
		printf("Total head-sep stall count was %d\n",
d919 1
a919 1
#endif				/* RF_RECON_STATS > 0 */
d921 2
a922 1
		RF_Free(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t));
d930 2
d933 3
a935 3
 * do the right thing upon each reconstruction event.
 * returns nonzero if and only if there is nothing left unread on the 
 * indicated disk
d937 3
a939 5
int 
rf_ProcessReconEvent(raidPtr, frow, event)
	RF_Raid_t *raidPtr;
	RF_RowCol_t frow;
	RF_ReconEvent_t *event;
d941 1
a941 1
	int     retcode = 0, submitblocked;
d945 2
a946 1
	Dprintf1("RECON: rf_ProcessReconEvent type %d\n", event->type);
d949 1
a949 1
		/* a read I/O has completed */
d951 3
a953 2
		rbuf = raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf;
		Dprintf3("RECON: READDONE EVENT: row %d col %d psid %ld\n",
d955 5
a959 3
		Dprintf7("RECON: done read  psid %ld buf %lx  %02x %02x %02x %02x %02x\n",
		    rbuf->parityStripeID, rbuf->buffer, rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,
		    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);
d962 1
a962 1
		Dprintf1("RECON: submitblocked=%d\n", submitblocked);
d964 2
a965 1
			retcode = rf_IssueNextReadRequest(raidPtr, frow, event->col);
d968 1
a968 1
		/* a write I/O has completed */
d973 2
a974 1
		sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;
d977 9
a985 5
		Dprintf3("RECON: WRITEDONE EVENT: psid %d ru %d (%d %% complete)\n",
		    rbuf->parityStripeID, rbuf->which_ru, raidPtr->reconControl[frow]->percentComplete);
		rf_ReconMapUpdate(raidPtr, raidPtr->reconControl[frow]->reconMap,
		    rbuf->failedDiskSectorOffset, rbuf->failedDiskSectorOffset + sectorsPerRU - 1);
		rf_RemoveFromActiveReconTable(raidPtr, frow, rbuf->parityStripeID, rbuf->which_ru);
d999 9
a1007 5
	case RF_REVENT_BUFCLEAR:	/* A buffer-stall condition has been
					 * cleared */
		Dprintf2("RECON: BUFCLEAR EVENT: row %d col %d\n", frow, event->col);
		submitblocked = rf_SubmitReconBuffer(raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf, 0, (int) (long) event->arg);
		RF_ASSERT(!submitblocked);	/* we wouldn't have gotten the
d1009 2
a1010 1
						 * couldn't submit */
d1014 4
a1017 3
	case RF_REVENT_BLOCKCLEAR:	/* A user-write reconstruction
					 * blockage has been cleared */
		DDprintf2("RECON: BLOCKCLEAR EVENT: row %d col %d\n", frow, event->col);
d1021 7
a1027 4
	case RF_REVENT_HEADSEPCLEAR:	/* A max-head-separation
					 * reconstruction blockage has been
					 * cleared */
		Dprintf2("RECON: HEADSEPCLEAR EVENT: row %d col %d\n", frow, event->col);
d1031 1
a1031 1
		/* a buffer has become ready to write */
d1033 2
a1034 1
		Dprintf2("RECON: BUFREADY EVENT: row %d col %d\n", frow, event->col);
d1041 4
a1044 2
		/* we need to skip the current RU entirely because it got
		 * recon'd while we were waiting for something else to happen */
d1046 2
a1047 1
		DDprintf2("RECON: SKIP EVENT: row %d col %d\n", frow, event->col);
d1051 4
a1054 2
		/* a forced-reconstruction read access has completed.  Just
		 * submit the buffer */
d1058 2
a1059 1
		DDprintf2("RECON: FORCEDREADDONE EVENT: row %d col %d\n", frow, event->col);
d1073 3
a1075 3
 * find the next thing that's needed on the indicated disk, and issue
 * a read request for it.  We assume that the reconstruction buffer
 * associated with this process is free to receive the data.  If
d1083 1
a1083 1
 * we're currently accessing.  Note that this deviates from the
d1085 1
a1085 1
 * accessed.  This allows us to easily retry when we're blocked by
d1088 2
a1089 2
 * returns nonzero if and only if there is nothing left unread on the
 * indicated disk
d1092 2
a1093 5
int 
rf_IssueNextReadRequest(raidPtr, row, col)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
	RF_RowCol_t col;
d1095 2
a1096 1
	RF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];
d1099 12
a1110 7
	RF_ReconUnitCount_t RUsPerPU = layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;
	RF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;
	int     do_new_check = 0, retcode = 0, status;

	/* if we are currently the slowest disk, mark that we have to do a new
	 * check */
	if (ctrl->headSepCounter <= raidPtr->reconControl[row]->minHeadSepCounter)
d1124 5
a1128 3
			if (ctrl->curPSID >= raidPtr->reconControl[row]->lastPSID) {
				rf_CheckForNewMinHeadSep(raidPtr, row, ++(ctrl->headSepCounter));
				return (1);	/* finito! */
d1130 2
a1131 1
			/* find the disk offsets of the start of the parity
d1133 7
a1139 4
			 * disk. skip this entire parity stripe if either disk
			 * does not appear in the indicated PS */
			status = rf_ComputePSDiskOffsets(raidPtr, ctrl->curPSID, row, col, &ctrl->diskOffset, &rbuf->failedDiskSectorOffset,
			    &rbuf->spRow, &rbuf->spCol, &rbuf->spOffset);
d1147 5
a1151 3
		/* skip this RU if it's already been reconstructed */
		if (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, rbuf->failedDiskSectorOffset)) {
			Dprintf2("Skipping psid %ld ru %d: already reconstructed\n", ctrl->curPSID, ctrl->ru_count);
d1157 2
a1158 2
	if (do_new_check)
		rf_CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);	/* update min if needed */
d1161 4
a1164 2
	/* at this point, we have definitely decided what to do, and we have
	 * only to see if we can actually do it now */
d1167 2
a1168 1
	bzero((char *) &raidPtr->recon_tracerecs[col], sizeof(raidPtr->recon_tracerecs[col]));
d1176 1
a1176 1
 * tries to issue the next read on the indicated disk.  We may be
d1178 1
a1178 1
 * indicated RU being blocked due to a write by a user thread.  In
d1181 1
a1181 1
 * has cleared.  
d1184 2
a1185 5
int 
rf_TryToRead(raidPtr, row, col)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
	RF_RowCol_t col;
d1187 4
a1190 2
	RF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];
	RF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;
d1194 1
a1194 1
	int     status, created = 0;
d1197 6
a1202 3
	/* if the current disk is too far ahead of the others, issue a
	 * head-separation wait and return */
	if (rf_CheckHeadSeparation(raidPtr, ctrl, row, col, ctrl->headSepCounter, which_ru))
d1205 2
a1206 1
	pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE, &created);
d1208 7
a1214 4
	/* if recon is blocked on the indicated parity stripe, issue a
	 * block-wait request and return. this also must mark the indicated RU
	 * in the stripe as under reconstruction if not blocked. */
	status = rf_CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl, row, col, psid, which_ru);
d1216 2
a1217 1
		Dprintf2("RECON: Stalling psid %ld ru %d: recon blocked\n", psid, which_ru);
d1221 2
a1222 1
			rf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);
d1225 2
a1226 1
	/* make one last check to be sure that the indicated RU didn't get
d1229 1
a1229 1
	 * in the normal case.  Might want to make some attempt to re-work
d1231 7
a1237 4
	 * one of the above checks.  When this condition is detected, we may
	 * have just created a bogus status entry, which we need to delete. */
	if (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, ctrl->rbuf->failedDiskSectorOffset)) {
		Dprintf2("RECON: Skipping psid %ld ru %d: prior recon after stall\n", psid, which_ru);
d1239 2
a1240 1
			rf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);
d1244 4
a1247 3
	/* found something to read.  issue the I/O */
	Dprintf5("RECON: Read for psid %ld on row %d col %d offset %ld buf %lx\n",
	    psid, row, col, ctrl->diskOffset, ctrl->rbuf->buffer);
d1254 8
a1261 4
	/* should be ok to use a NULL proc pointer here, all the bufs we use
	 * should be in kernel space */
	req = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset, sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,
	    rf_ReconReadDoneProc, (void *) ctrl, NULL, &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);
d1263 1
a1263 1
	RF_ASSERT(req);		/* XXX -- fix this -- XXX */
d1276 3
a1278 3
 * given a parity stripe ID, we want to find out whether both the
 * current disk and the failed disk exist in that parity stripe.  If
 * not, we want to skip this whole PS.  If so, we want to find the
d1282 1
a1282 1
 * this works by getting a list of disks comprising the indicated
d1284 1
a1284 1
 * disks.  Once we've decided they both exist in the parity stripe, we
d1289 1
a1289 1
 * this is kind of unpleasant, but doing it this way allows the
d1293 1
a1293 1
 * reverse-mapping function.  I also think it will execute faster,
d1297 2
a1298 1
 * THE STRIPE IN THE CORRECT ORDER */
d1300 1
a1300 1
int 
d1302 20
a1321 11
    RF_Raid_t * raidPtr,	/* raid descriptor */
    RF_StripeNum_t psid,	/* parity stripe identifier */
    RF_RowCol_t row,		/* row and column of disk to find the offsets
				 * for */
    RF_RowCol_t col,
    RF_SectorNum_t * outDiskOffset,
    RF_SectorNum_t * outFailedDiskSectorOffset,
    RF_RowCol_t * spRow,	/* OUT: row,col of spare unit for failed unit */
    RF_RowCol_t * spCol,
    RF_SectorNum_t * spOffset)
{				/* OUT: offset into disk containing spare unit */
d1326 1
a1326 1
	u_int   i, j, k, i_offset, j_offset;
d1328 1
a1328 1
	int     testcol, testrow;
d1331 3
a1333 2
	char    i_is_parity = 0, j_is_parity = 0;
	RF_RowCol_t stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;
d1335 1
a1335 1
	/* get a listing of the disks comprising that stripe */
d1337 2
a1338 1
	(layoutPtr->map->IdentifyStripe) (raidPtr, sosRaidAddress, &diskids, &stripe);
d1341 4
a1344 2
	/* reject this entire parity stripe if it does not contain the
	 * indicated disk or it does not contain the failed disk */
d1360 9
a1368 6
	/* find out which disk the parity is on */
	(layoutPtr->map->MapParity) (raidPtr, sosRaidAddress, &prow, &pcol, &poffset, RF_DONT_REMAP);

	/* find out if either the current RU or the failed RU is parity */
	/* also, if the parity occurs in this stripe prior to the data and/or
	 * failed col, we need to decrement i and/or j */
d1381 4
a1384 2
		}		/* set offsets to zero to disable multiply
				 * below */
d1392 2
a1393 1
	/* at this point, [ij]_is_parity tells us whether the [current,failed]
d1395 2
a1396 1
	 * tells us how far into the stripe the [current,failed] disk is. */
d1398 4
a1401 2
	/* call the mapping routine to get the offset into the current disk,
	 * repeat for failed disk. */
d1403 3
a1405 1
		layoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);
d1407 3
a1409 1
		layoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);
d1414 3
a1416 1
		layoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);
d1418 3
a1420 1
		layoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);
d1423 1
a1423 1
	/* now locate the spare unit for the failed unit */
d1426 3
a1428 1
			layoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);
d1430 3
a1432 1
			layoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);
d1442 1
a1442 1
	Dprintf3("RECON: Skipping psid %ld: nothing needed from r%d c%d\n",
d1446 8
a1453 5
/* this is called when a buffer has become ready to write to the replacement disk */
int 
rf_IssueNextWriteRequest(raidPtr, row)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
d1456 2
a1457 1
	RF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;
d1463 4
a1466 2
	RF_ASSERT(rbuf);	/* there must be one available, or we wouldn't
				 * have gotten the event that sent us here */
d1472 2
a1473 1
	Dprintf7("RECON: New write (r %d c %d offs %d) for psid %ld ru %d (failed disk offset %ld) buf %lx\n",
d1476 9
a1484 6
	Dprintf6("RECON: new write psid %ld   %02x %02x %02x %02x %02x\n",
	    rbuf->parityStripeID, rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,
	    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);

	/* should be ok to use a NULL b_proc here b/c all addrs should be in
	 * kernel space */
d1486 1
a1486 2
	    sectorsPerRU, rbuf->buffer,
	    rbuf->parityStripeID, rbuf->which_ru,
d1488 1
a1488 2
	    &raidPtr->recon_tracerecs[fcol],
	    (void *) raidPtr, 0, NULL);
d1490 1
a1490 1
	RF_ASSERT(req);		/* XXX -- fix this -- XXX */
d1493 2
a1494 1
	rf_DiskIOEnqueue(&raidPtr->Queues[rbuf->spRow][rbuf->spCol], req, RF_IO_RECON_PRIORITY);
d1500 2
a1501 2
 * this gets called upon the completion of a reconstruction read
 * operation the arg is a pointer to the per-disk reconstruction
d1504 2
a1505 2
 * called at interrupt context in the kernel, so don't do anything
 * illegal here.  
d1507 2
a1508 4
int 
rf_ReconReadDoneProc(arg, status)
	void   *arg;
	int     status;
d1515 3
a1517 3
	         * XXX
	         */
		printf("Recon read failed!\n");
d1522 3
a1524 2
	raidPtr->recon_tracerecs[ctrl->col].specific.recon.recon_fetch_to_return_us =
	    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[ctrl->col].recon_timer);
d1527 2
a1528 1
	rf_CauseReconEvent(raidPtr, ctrl->row, ctrl->col, NULL, RF_REVENT_READDONE);
d1531 5
a1535 2
/* this gets called upon the completion of a reconstruction write operation.
 * the arg is a pointer to the rbuf that was just written
d1537 1
a1537 1
 * called at interrupt context in the kernel, so don't do anything illegal here.
d1539 2
a1540 4
int 
rf_ReconWriteDoneProc(arg, status)
	void   *arg;
	int     status;
d1544 2
a1545 1
	Dprintf2("Reconstruction completed on psid %ld ru %d\n", rbuf->parityStripeID, rbuf->which_ru);
d1547 2
a1548 2
		printf("Recon write failed!\n");	/* fprintf(stderr,"Recon
							 * write failed!\n"); */
d1551 2
a1552 1
	rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col, arg, RF_REVENT_WRITEDONE);
d1557 3
a1559 3
/* 
 * computes a new minimum head sep, and wakes up anyone who needs to
 * be woken as a result 
d1561 3
a1563 5
void 
rf_CheckForNewMinHeadSep(raidPtr, row, hsCtr)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
	RF_HeadSepLimit_t hsCtr;
d1569 2
a1570 2
	RF_ASSERT(hsCtr >= reconCtrlPtr->minHeadSepCounter);	/* from the definition
								 * of a minimum */
d1578 4
a1581 2
			if (reconCtrlPtr->perDiskInfo[i].headSepCounter < new_min)
				new_min = reconCtrlPtr->perDiskInfo[i].headSepCounter;
d1583 1
a1583 1
	/* set the new minimum and wake up anyone who can now run again */
d1586 2
a1587 1
		Dprintf1("RECON:  new min head pos counter val is %ld\n", new_min);
d1589 2
a1590 1
			if (reconCtrlPtr->headSepCBList->callbackArg.v > new_min)
d1595 2
a1596 1
			rf_CauseReconEvent(raidPtr, p->row, p->col, NULL, RF_REVENT_HEADSEPCLEAR);
d1605 1
a1605 1
 * checks to see that the maximum head separation will not be violated
d1613 2
a1614 2
 * returns non-zero if and only if we have to stop working on the
 * indicated disk due to a head-separation delay.  
d1616 1
a1616 1
int 
d1618 7
a1624 6
    RF_Raid_t * raidPtr,
    RF_PerDiskReconCtrl_t * ctrl,
    RF_RowCol_t row,
    RF_RowCol_t col,
    RF_HeadSepLimit_t hsCtr,
    RF_ReconUnitNum_t which_ru)
d1628 1
a1628 1
	int     retval = 0;
d1630 3
a1632 2
	/* if we're too far ahead of the slowest disk, stop working on this
	 * disk until the slower ones catch up.  We do this by scheduling a
a1636 1
	 * 
d1640 6
a1645 5
	    ((ctrl->headSepCounter - reconCtrlPtr->minHeadSepCounter) > raidPtr->headSepLimit)) {
		Dprintf6("raid%d: RECON: head sep stall: row %d col %d hsCtr %ld minHSCtr %ld limit %ld\n",
			 raidPtr->raidid, row, col, ctrl->headSepCounter, 
			 reconCtrlPtr->minHeadSepCounter, 
			 raidPtr->headSepLimit);
d1647 6
a1652 3
		/* the minHeadSepCounter value we have to get to before we'll
		 * wake up.  build in 20% hysteresis. */
		cb->callbackArg.v = (ctrl->headSepCounter - raidPtr->headSepLimit + raidPtr->headSepLimit / 5);
d1657 4
a1660 2
		/* insert this callback descriptor into the sorted list of
		 * pending head-sep callbacks */
d1669 3
a1671 1
				for (pt = p, p = p->next; p && (p->callbackArg.v < cb->callbackArg.v); pt = p, p = p->next);
d1676 1
a1676 1
#if RF_RECON_STATS > 0
d1678 1
a1678 1
#endif				/* RF_RECON_STATS > 0 */
d1684 7
a1690 4
/* 
 * checks to see if reconstruction has been either forced or blocked
 * by a user operation.  if forced, we skip this RU entirely.  else if
 * blocked, put ourselves on the wait list.  else return 0.
d1692 1
a1692 1
 * ASSUMES THE PSS MUTEX IS LOCKED UPON ENTRY
d1694 1
a1694 1
int 
d1696 8
a1703 7
    RF_Raid_t * raidPtr,
    RF_ReconParityStripeStatus_t * pssPtr,
    RF_PerDiskReconCtrl_t * ctrl,
    RF_RowCol_t row,
    RF_RowCol_t col,
    RF_StripeNum_t psid,
    RF_ReconUnitNum_t which_ru)
d1706 1
a1706 1
	int     retcode = 0;
d1708 2
a1709 1
	if ((pssPtr->flags & RF_PSS_FORCED_ON_READ) || (pssPtr->flags & RF_PSS_FORCED_ON_WRITE))
d1713 4
a1716 2
			Dprintf4("RECON: row %d col %d blocked at psid %ld ru %d\n", row, col, psid, which_ru);
			cb = rf_AllocCallbackDesc();	/* append ourselves to
d1718 2
a1719 1
							 * list */
d1727 4
a1730 2
		pssPtr->flags |= RF_PSS_UNDER_RECON;	/* mark this RU as under
							 * reconstruction */
d1734 2
d1737 1
a1737 1
 * if reconstruction is currently ongoing for the indicated stripeID,
d1739 2
a1740 2
 * indicate that the caller must wait.  If not, then reconstruction is
 * blocked on the indicated stripe and the routine returns zero.  If
d1742 1
a1742 1
 * invoked with the cbArg when the reconstruction has completed.  
d1744 23
a1766 17
int 
rf_ForceOrBlockRecon(raidPtr, asmap, cbFunc, cbArg)
	RF_Raid_t *raidPtr;
	RF_AccessStripeMap_t *asmap;
	void    (*cbFunc) (RF_Raid_t *, void *);
	void   *cbArg;
{
	RF_RowCol_t row = asmap->physInfo->row;	/* which row of the array
						 * we're working on */
	RF_StripeNum_t stripeID = asmap->stripeID;	/* the stripe ID we're
							 * forcing recon on */
	RF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;	/* num sects in one RU */
	RF_ReconParityStripeStatus_t *pssPtr;	/* a pointer to the parity
						 * stripe status structure */
	RF_StripeNum_t psid;	/* parity stripe id */
	RF_SectorNum_t offset, fd_offset;	/* disk offset, failed-disk
						 * offset */
d1769 1
a1769 1
	RF_ReconUnitNum_t which_ru;	/* RU within parity stripe */
d1771 2
a1772 2
	RF_ReconBuffer_t *new_rbuf;	/* ptr to newly allocated rbufs */
	RF_DiskQueueData_t *req;/* disk I/O req to be enqueued */
d1774 1
a1774 1
	int     created = 0, nPromoted;
d1776 2
a1777 1
	psid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID, &which_ru);
d1781 3
a1783 1
	pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE | RF_PSS_RECON_BLOCKED, &created);
d1785 1
a1785 1
	/* if recon is not ongoing on this PS, just return */
d1790 6
a1795 3
	/* otherwise, we have to wait for reconstruction to complete on this
	 * RU. */
	/* In order to avoid waiting for a potentially large number of
d1797 9
a1805 7
	 * not low-priority) reconstruction on this RU. */
	if (!(pssPtr->flags & RF_PSS_FORCED_ON_WRITE) && !(pssPtr->flags & RF_PSS_FORCED_ON_READ)) {
		DDprintf1("Forcing recon on psid %ld\n", psid);
		pssPtr->flags |= RF_PSS_FORCED_ON_WRITE;	/* mark this RU as under
								 * forced recon */
		pssPtr->flags &= ~RF_PSS_RECON_BLOCKED;	/* clear the blockage
							 * that we just set */
d1808 5
a1812 2
		/* get a listing of the disks comprising the indicated stripe */
		(raidPtr->Layout.map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &stripe);
d1815 3
a1817 2
		/* For previously issued reads, elevate them to normal
		 * priority.  If the I/O has already completed, it won't be
d1819 1
a1819 1
		 * unissued reads, allocate buffers and issue new reads.  The
d1821 4
a1824 2
		 * recon procs will not re-issue these reqs */
		for (i = 0; i < raidPtr->Layout.numDataCol + raidPtr->Layout.numParityCol; i++)
d1827 3
a1829 1
					nPromoted = rf_DiskIOPromote(&raidPtr->Queues[row][diskno], psid, which_ru);
d1831 4
a1834 1
						printf("raid%d: promoted read from row %d col %d\n", raidPtr->raidid, row, diskno);
d1836 10
a1845 5
					new_rbuf = rf_MakeReconBuffer(raidPtr, row, diskno, RF_RBUF_TYPE_FORCED);	/* create new buf */
					rf_ComputePSDiskOffsets(raidPtr, psid, row, diskno, &offset, &fd_offset,
					    &new_rbuf->spRow, &new_rbuf->spCol, &new_rbuf->spOffset);	/* find offsets & spare
													 * location */
					new_rbuf->parityStripeID = psid;	/* fill in the buffer */
d1847 17
a1863 7
					new_rbuf->failedDiskSectorOffset = fd_offset;
					new_rbuf->priority = RF_IO_NORMAL_PRIORITY;

					/* use NULL b_proc b/c all addrs
					 * should be in kernel space */
					req = rf_CreateDiskQueueData(RF_IO_TYPE_READ, offset + which_ru * sectorsPerRU, sectorsPerRU, new_rbuf->buffer,
					    psid, which_ru, (int (*) (void *, int)) rf_ForceReconReadDoneProc, (void *) new_rbuf, NULL,
d1866 4
a1869 2
					RF_ASSERT(req);	/* XXX -- fix this --
							 * XXX */
d1872 7
a1878 2
					rf_DiskIOEnqueue(&raidPtr->Queues[row][diskno], req, RF_IO_NORMAL_PRIORITY);	/* enqueue the I/O */
					Dprintf3("raid%d: Issued new read req on row %d col %d\n", raidPtr->raidid, row, diskno);
d1881 13
a1893 8
		/* if the write is sitting in the disk queue, elevate its
		 * priority */
		if (rf_DiskIOPromote(&raidPtr->Queues[row][fcol], psid, which_ru))
			printf("raid%d: promoted write to row %d col %d\n", 
			       raidPtr->raidid, row, fcol);
	}
	/* install a callback descriptor to be invoked when recon completes on
	 * this parity stripe. */
d1895 4
a1898 2
	/* XXX the following is bogus.. These functions don't really match!!
	 * GO */
d1903 2
a1904 2
	DDprintf2("raid%d: Waiting for forced recon on psid %ld\n", 
		  raidPtr->raidid, psid);
d1909 6
a1914 3
/* called upon the completion of a forced reconstruction read.
 * all we do is schedule the FORCEDREADONE event.
 * called at interrupt context in the kernel, so don't do anything illegal here.
d1916 2
a1917 4
void 
rf_ForceReconReadDoneProc(arg, status)
	void   *arg;
	int     status;
d1922 2
a1923 3
		printf("Forced recon read failed!\n");	/* fprintf(stderr,"Forced
							 *  recon read
							 * failed!\n"); */
d1926 2
a1927 1
	rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col, (void *) rbuf, RF_REVENT_FORCEDREADDONE);
d1929 5
a1933 5
/* releases a block on the reconstruction of the indicated stripe */
int 
rf_UnblockRecon(raidPtr, asmap)
	RF_Raid_t *raidPtr;
	RF_AccessStripeMap_t *asmap;
d1940 1
a1940 1
	int     created = 0;
d1943 2
a1944 1
	psid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID, &which_ru);
d1946 2
a1947 1
	pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_NONE, &created);
d1949 2
a1950 1
	/* When recon is forced, the pss desc can get deleted before we get
d1953 2
a1954 1
	 * how to decide if recon was just forced or not? */
d1956 4
a1959 2
		/* printf("Warning: no pss descriptor upon unblock on psid %ld
		 * RU %d\n",psid,which_ru); */
d1961 2
a1962 1
			printf("Warning: no pss descriptor upon unblock on psid %ld RU %d\n", (long) psid, which_ru);
d1966 4
a1969 3
	Dprintf3("raid%d: unblocking recon on psid %ld: blockcount is %d\n",
		 raidPtr->raidid, psid, pssPtr->blockCount);
	if (pssPtr->blockCount == 0) {	/* if recon blockage has been released */
d1971 2
a1972 1
		/* unblock recon before calling CauseReconEvent in case
d1974 2
a1975 1
		 * returning here. */
d1979 5
a1983 3
		while (pssPtr->blockWaitList) {	
			/* spin through the block-wait list and
			   release all the waiters */
d1987 2
a1988 1
			rf_CauseReconEvent(raidPtr, cb->row, cb->col, NULL, RF_REVENT_BLOCKCLEAR);
d1992 3
a1994 2
			/* if no recon was requested while recon was blocked */
			rf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.10 2001/01/02 09:06:26 peter Exp $	*/
d407 1
d411 1
d416 1
d419 1
@


1.10
log
@Fix PR/1489 - apply patch supplied - thanks Michael Joosten <joost@@c-lab.de>

The whole issue of processes and threads need looking at, as NetBSD
and OpenBSD do things slightly differently - think extra arg to
VOP_XXX calls for one.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.9 2000/08/08 16:07:45 peter Exp $	*/
d86 5
a90 5
RF_RaidReconDesc_t *rf_AllocRaidReconDesc __P((RF_Raid_t *, RF_RowCol_t, RF_RowCol_t, RF_RaidDisk_t *, int, RF_RowCol_t, RF_RowCol_t));
int rf_ProcessReconEvent __P((RF_Raid_t *, RF_RowCol_t, RF_ReconEvent_t *));
int rf_IssueNextReadRequest __P((RF_Raid_t *, RF_RowCol_t, RF_RowCol_t));
int rf_TryToRead __P((RF_Raid_t *, RF_RowCol_t, RF_RowCol_t));
int rf_ComputePSDiskOffsets __P((RF_Raid_t *, RF_StripeNum_t, RF_RowCol_t, RF_RowCol_t, RF_SectorNum_t *, RF_SectorNum_t *, RF_RowCol_t *, RF_RowCol_t *, RF_SectorNum_t *));
d95 2
a96 2
void rf_ForceReconReadDoneProc __P((void *, int));
void rf_ShutdownReconstruction __P((void *));
d102 4
a105 4
void rf_FreeReconDesc __P((RF_RaidReconDesc_t *));
int rf_IssueNextWriteRequest __P((RF_Raid_t *, RF_RowCol_t));
int rf_CheckForcedOrBlockedReconstruction __P((RF_Raid_t *, RF_ReconParityStripeStatus_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_StripeNum_t, RF_ReconUnitNum_t));
void rf_SignalReconDone __P((RF_Raid_t *));
@


1.10.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.10 2001/01/02 09:06:26 peter Exp $	*/
d86 5
a90 5
RF_RaidReconDesc_t *rf_AllocRaidReconDesc(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t, RF_RaidDisk_t *, int, RF_RowCol_t, RF_RowCol_t);
int rf_ProcessReconEvent(RF_Raid_t *, RF_RowCol_t, RF_ReconEvent_t *);
int rf_IssueNextReadRequest(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int rf_TryToRead(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int rf_ComputePSDiskOffsets(RF_Raid_t *, RF_StripeNum_t, RF_RowCol_t, RF_RowCol_t, RF_SectorNum_t *, RF_SectorNum_t *, RF_RowCol_t *, RF_RowCol_t *, RF_SectorNum_t *);
d95 2
a96 2
void rf_ForceReconReadDoneProc(void *, int);
void rf_ShutdownReconstruction(void *);
d102 4
a105 4
void rf_FreeReconDesc(RF_RaidReconDesc_t *);
int rf_IssueNextWriteRequest(RF_Raid_t *, RF_RowCol_t);
int rf_CheckForcedOrBlockedReconstruction(RF_Raid_t *, RF_ReconParityStripeStatus_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_StripeNum_t, RF_ReconUnitNum_t);
void rf_SignalReconDone(RF_Raid_t *);
@


1.10.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.10.6.1 2002/06/11 03:42:28 art Exp $	*/
a406 1
#ifdef	RAIDDEBUG
a409 1
#endif	/* RAIDDEBUG */
a413 1
#ifdef	RAIDDEBUG
a415 1
#endif	/* RAIDDEBUG */
@


1.10.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/**************************************************************
d32 1
a32 1
 * rf_reconstruct.c -- Code to perform on-line reconstruction.
d34 1
a34 1
 **************************************************************/
d47 1
a47 1
#if	__NETBSD__
d68 10
a77 4
/*
 * Setting these to -1 causes them to be set to their default values if not set
 * by debug options.
 */
d79 2
a80 92
#define	Dprintf(s)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);	\
} while (0)
#define	Dprintf1(s,a)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
#define	Dprintf2(s,a,b)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
#define	Dprintf3(s,a,b,c)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    NULL, NULL, NULL, NULL, NULL);			\
} while (0)
#define	Dprintf4(s,a,b,c,d)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    NULL, NULL, NULL, NULL);				\
} while (0)
#define	Dprintf5(s,a,b,c,d,e)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    (void *)((unsigned long)e),				\
		    NULL, NULL, NULL);					\
} while (0)
#define	Dprintf6(s,a,b,c,d,e,f)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    (void *)((unsigned long)e),				\
		    (void *)((unsigned long)f),				\
		    NULL, NULL);					\
} while (0)
#define	Dprintf7(s,a,b,c,d,e,f,g)					\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    (void *)((unsigned long)e),				\
		    (void *)((unsigned long)f),				\
		    (void *)((unsigned long)g),				\
		    NULL);						\
} while (0)

#define	DDprintf1(s,a)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
#define	DDprintf2(s,a,b)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
d83 2
a84 2
#define	RF_MAX_FREE_RECOND	4
#define	RF_RECOND_INC		1
d86 7
a92 11
RF_RaidReconDesc_t *rf_AllocRaidReconDesc(RF_Raid_t *,
	RF_RowCol_t, RF_RowCol_t, RF_RaidDisk_t *, int,
	RF_RowCol_t, RF_RowCol_t);
int  rf_ProcessReconEvent(RF_Raid_t *, RF_RowCol_t, RF_ReconEvent_t *);
int  rf_IssueNextReadRequest(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_TryToRead(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ComputePSDiskOffsets(RF_Raid_t *, RF_StripeNum_t,
	RF_RowCol_t, RF_RowCol_t, RF_SectorNum_t *, RF_SectorNum_t *,
	RF_RowCol_t *, RF_RowCol_t *, RF_SectorNum_t *);
int  rf_ReconReadDoneProc(void *, int);
int  rf_ReconWriteDoneProc(void *, int);
d94 1
a94 2
int  rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *,
	RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);
d99 2
a100 2
 * These functions are inlined on gcc. If they are used more than
 * once, it is strongly advised to un-line them.
d103 2
a104 4
int  rf_IssueNextWriteRequest(RF_Raid_t *, RF_RowCol_t);
int  rf_CheckForcedOrBlockedReconstruction(RF_Raid_t *,
	RF_ReconParityStripeStatus_t *, RF_PerDiskReconCtrl_t *,
	RF_RowCol_t, RF_RowCol_t, RF_StripeNum_t, RF_ReconUnitNum_t);
d108 3
a110 3
	void			(*proc) (RF_Raid_t *, void *);
	void			 *arg;
	RF_ReconDoneProc_t	 *next;
d114 2
a115 2
#define	RF_MAX_FREE_RDP		4
#define	RF_RDP_INC		1
d117 2
a118 2
void
rf_SignalReconDone(RF_Raid_t *raidPtr)
d129 6
a134 3
int
rf_RegisterReconDoneProc(RF_Raid_t *raidPtr, void (*proc) (RF_Raid_t *, void *),
    void *arg, RF_ReconDoneProc_t **handlep)
d151 1
a151 2

/*****************************************************************************
d153 2
a154 2
 * Sets up the parameters that will be used by the reconstruction process.
 * Currently there are none, except for those that the layout-specific
d157 1
a157 1
 * In the kernel, we fire off the recon thread.
d159 4
a162 3
 *****************************************************************************/
void
rf_ShutdownReconstruction(void *ignored)
d168 3
a170 2
int
rf_ConfigureReconstruction(RF_ShutdownList_t **listp)
d172 1
a172 1
	int rc;
d181 1
a181 2
		RF_FREELIST_DESTROY(rf_recond_freelist, next,
		    (RF_RaidReconDesc_t *));
d186 2
a187 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
d195 8
a202 3
rf_AllocRaidReconDesc(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col,
    RF_RaidDisk_t *spareDiskPtr, int numDisksDone, RF_RowCol_t srow,
    RF_RowCol_t scol)
d207 1
a207 2
	RF_FREELIST_GET(rf_recond_freelist, reconDesc, next,
	    (RF_RaidReconDesc_t *));
d222 3
a224 2
void
rf_FreeReconDesc(RF_RaidReconDesc_t *reconDesc)
d226 2
a227 2
#if	RF_RECON_STATS > 0
	printf("RAIDframe: %qu recon event waits, %qu recon delays.\n",
d229 1
a229 1
#endif	/* RF_RECON_STATS > 0 */
d231 1
a231 2
	printf("RAIDframe: %qu max exec ticks.\n",
	    reconDesc->maxReconExecTicks);
d233 1
a233 1
#if	(RF_RECON_STATS > 0) || defined(_KERNEL)
d235 1
a235 1
#endif	/* (RF_RECON_STATS > 0) || _KERNEL */
d240 1
a240 1
/*****************************************************************************
d242 2
a243 2
 * Primary routine to reconstruct a failed disk. This should be called from
 * within its own thread. It won't return until reconstruction completes,
d246 6
a251 3
 *****************************************************************************/
int
rf_ReconstructFailedDisk(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
d254 1
a254 1
	int rc;
d259 3
a261 3
		 * The current infrastructure only supports reconstructing one
		 * disk at a time for each array.
		 */
d273 2
a274 2
		RF_ERRORMSG1("RECON: no way to reconstruct failed disk for"
		    " arch %c.\n", lp->parityConfig);
d278 2
a279 4
	wakeup(&raidPtr->waitForReconCond);	/*
						 * XXX Methinks this will be
						 * needed at some point... GO
						 */
d283 5
a287 3
int
rf_ReconstructFailedDiskBasic(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_RowCol_t col)
d293 1
a293 1
	int numDisksDone = 0, rc;
d295 3
a297 5
	/* First look for a spare drive onto which to reconstruct the data. */
	/*
	 * Spare disk descriptors are stored in row 0. This may have to
	 * change eventually.
	 */
d304 1
a304 2
			RF_ERRORMSG2("Unable to reconstruct disk at row %d"
			    " col %d because status not degraded.\n", row, col);
d312 1
a312 2
		for (scol = raidPtr->numCol;
		     scol < raidPtr->numCol + raidPtr->numSpare; scol++) {
d320 1
a320 3
			RF_ERRORMSG2("Unable to reconstruct disk at row %d"
			    " col %d because no spares are available.\n",
			    row, col);
d324 1
a324 2
		printf("RECON: initiating reconstruction on row %d col %d"
		    " -> spare at row %d col %d.\n", row, col, srow, scol);
d328 1
a328 2
	reconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col,
	    spareDiskPtr, numDisksDone, srow, scol);
d330 1
a330 1
#if	RF_RECON_STATS > 0
d334 1
a334 1
#endif	/* RF_RECON_STATS > 0 */
d341 2
a342 2
		/* Fix up the component label. */
		/* Don't actually need the read here... */
d344 5
a348 5
		    raidPtr->raid_cinfo[srow][scol].ci_dev,
		    raidPtr->raid_cinfo[srow][scol].ci_vp,
		    &c_label);

		raid_init_component_label(raidPtr, &c_label);
d354 2
a355 2
		/* XXXX MORE NEEDED HERE. */

d357 4
a360 4
		    raidPtr->raid_cinfo[srow][scol].ci_dev,
		    raidPtr->raid_cinfo[srow][scol].ci_vp,
		    &c_label);

d365 9
a373 9
/*
 *
 * Allow reconstructing a disk in-place -- i.e. component /dev/sd2e goes AWOL,
 * and you don't get a spare until the next Monday. With this function
 * (and hot-swappable drives) you can now put your new disk containing
 * /dev/sd2e on the bus, scsictl it alive, and then use raidctl(8) to
 * rebuild the data "on the spot".
 *
 */
d376 4
a379 1
rf_ReconstructInPlace(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
d386 1
a386 1
	int numDisksDone = 0, rc;
d397 3
a399 3
		 * The current infrastructure only supports reconstructing one
		 * disk at a time for each array.
		 */
d402 5
a406 7
		    (raidPtr->numFailures > 0)) {
			/* XXX 0 above shouldn't be constant !!! */
			/*
			 * Some component other than this has failed.
			 * Let's not make things worse than they already
			 * are...
			 */
d408 3
a410 3
			printf("RAIDFRAME: Unable to reconstruct to disk at:\n"
			    "      Row: %d Col: %d   Too many failures.\n",
			    row, col);
d417 2
a418 3
			printf("RAIDFRAME: Unable to reconstruct to disk at:\n"
			    "      Row: %d Col: %d   Reconstruction already"
			    " occuring !\n", row, col);
d431 2
a432 2
			rf_update_component_labels(raidPtr,
			    RF_NORMAL_COMPONENT_UPDATE);
a440 5
		/*
		 * First look for a spare drive onto which to reconstruct
		 * the data. Spare disk descriptors are stored in row 0.
		 * This may have to change eventually.
		 */
d442 8
a449 7
		/*
		 * Actually, we don't care if it's failed or not...
		 * On a RAID set with correct parity, this function
		 * should be callable on any component without ill effects.
		 */
		/*
		 * RF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);
d453 1
a453 3
			RF_ERRORMSG2("Unable to reconstruct to disk at row %d"
			    " col %d: operation not supported for"
			    " RF_DISTRIBUTE_SPARE.\n", row, col);
d458 5
a462 1
		}
a463 4
		/*
		 * XXX Need goop here to see if the disk is alive,
		 * and, if not, make it so...
		 */
d469 2
a470 4
		/*
		 * This device may have been opened successfully the
		 * first time. Close it before trying to open it again...
		 */
d473 2
a474 2
			printf("Closing the opened device: %s\n",
			    raidPtr->Disks[row][col].devname);
d480 1
a480 3
		/*
		 * Note that this disk was *not* auto_configured (any longer).
		 */
d484 9
a492 4
		    raidPtr->Disks[row][col].devname);

		retcode = raidlookup(raidPtr->Disks[row][col].devname,
		    proc, &vp);
d494 2
a495 9
		if (retcode) {
			printf("raid%d: rebuilding: raidlookup on device: %s"
			    " failed: %d !\n", raidPtr->raidid,
			    raidPtr->Disks[row][col].devname, retcode);

			/*
			 * XXX the component isn't responding properly...
			 * Must still be dead :-(
			 */
d502 2
a503 4
			/*
			 * Ok, so we can at least do a lookup...
			 * How about actually getting a vp for it ?
			 */
d505 2
a506 2
			if ((retcode =
			     VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {
d512 1
a512 1
			    FREAD, proc->p_ucred, proc);
d519 1
a519 4
			    dpart.disklab->d_secsize;

			raidPtr->Disks[row][col].numBlocks =
			    dpart.part->p_size - rf_protectedSectors;
d521 3
d526 1
a526 1

d528 5
a532 6

			/*
			 * We allow the user to specify that only a
			 * fraction of the disks should be used this is
			 * just for debug:  it speeds up the parity scan.
			 */
d534 2
a535 2
			    raidPtr->Disks[row][col].numBlocks *
			    rf_sizePercentage / 100;
d538 2
d543 3
a545 3
		printf("RECON: Initiating in-place reconstruction on\n");
		printf("       row %d col %d -> spare at row %d col %d.\n",
		    row, col, row, col);
d548 4
a551 3

		reconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col,
		    spareDiskPtr, numDisksDone, row, col);
d553 1
a553 1
#if	RF_RECON_STATS > 0
d557 1
a557 1
#endif	/* RF_RECON_STATS > 0 */
d568 2
a569 2
		RF_ERRORMSG1("RECON: no way to reconstruct failed disk for"
		    " arch %c.\n", lp->parityConfig);
d573 1
a573 1

d575 3
a577 5
		/*
		 * Need to set these here, as at this point it'll be claiming
		 * that the disk is in rf_ds_spared !  But we know better :-)
		 */

d580 6
a585 7

		/* Fix up the component label. */
		/* Don't actually need the read here... */
		raidread_component_label(
		    raidPtr->raid_cinfo[row][col].ci_dev,
		    raidPtr->raid_cinfo[row][col].ci_vp,
		    &c_label);
d591 1
a591 1

d593 2
a594 1
		    raidPtr->raid_cinfo[row][col].ci_vp, &c_label);
d599 1
a599 1
	wakeup(&raidPtr->waitForReconCond);
d604 3
a606 2
int
rf_ContinueReconstructFailedDisk(RF_RaidReconDesc_t *reconDesc)
d618 1
a618 1
	int retcode, i, ds;
d624 2
a625 3
		/* Create one trace record per physical disk. */
		RF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol *
		    sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d627 1
a627 2
		/*
		 * Quiesce the array prior to starting recon. This is needed
d629 1
a629 2
		 * We need to do this before we change the disk or row status.
		 */
d632 1
a632 1
		Dprintf("RECON: begin request suspend.\n");
d634 4
a637 6
		Dprintf("RECON: end request suspend.\n");
		rf_StartUserStats(raidPtr);	/*
						 * Zero out the stats kept on
						 * user accs.
						 */
		/* Fall through to state 1. */
d641 3
a643 6
		/*
		 * Create the reconstruction control pointer and install it in
		 * the right slot.
		 */
		raidPtr->reconControl[row] =
		    rf_MakeReconControl(reconDesc, row, col, srow, scol);
d654 2
a655 4
		/*
		 * Now start up the actual reconstruction: issue a read for
		 * each surviving disk.
		 */
d660 2
a661 4
				/*
				 * Find and issue the next I/O on the
				 * indicated disk.
				 */
d663 1
a663 2
					Dprintf2("RECON: done issuing for r%d"
					    " c%d.\n", row, i);
d672 1
a672 1
		Dprintf("RECON: resume requests.\n");
d675 1
d680 2
a681 4
		/*
		 * Process reconstruction events until all disks report that
		 * they've completed all work.
		 */
d686 1
a686 3
			event = rf_GetNextReconEvent(reconDesc, row,
			   (void (*) (void *)) rf_ContinueReconstructFailedDisk,
			    reconDesc);
d691 1
a691 1
			raidPtr->reconControl[row]->numRUsTotal =
d693 2
a694 2
			raidPtr->reconControl[row]->numRUsComplete =
				mapPtr->totalRUs -
d697 2
a698 3
			raidPtr->reconControl[row]->percentComplete =
			    (raidPtr->reconControl[row]->numRUsComplete * 100 /
			     raidPtr->reconControl[row]->numRUsTotal);
d700 1
a700 3
				rf_PrintReconSchedule(
				    raidPtr->reconControl[row]->reconMap,
				    &(raidPtr->reconControl[row]->starttime));
d709 1
a709 1
			printf("RECON: all reads completed.\n");
d711 2
a712 4
		/*
		 * At this point all the reads have completed. We now wait
		 * for any pending writes to complete, and then we're done.
		 */
d714 1
a714 2
		while (rf_UnitsLeftToReconstruct(
		    raidPtr->reconControl[row]->reconMap) > 0) {
d716 1
a716 3
			event = rf_GetNextReconEvent(reconDesc, row,
			   (void (*) (void *)) rf_ContinueReconstructFailedDisk,
			    reconDesc);
d719 2
a720 5
			/* Ignore return code. */
			(void) rf_ProcessReconEvent(raidPtr, row, event);
			raidPtr->reconControl[row]->percentComplete =
			    100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 /
			    mapPtr->totalRUs);
d722 1
a722 3
				rf_PrintReconSchedule(
				    raidPtr->reconControl[row]->reconMap,
				    &(raidPtr->reconControl[row]->starttime));
d728 1
a728 2
		/*
		 * Success:  mark the dead disk as reconstructed. We quiesce
d730 2
a731 3
		 * user accesses, when we free up the psstatus structure as
		 * part of FreeReconControl().
		 */
d737 1
a737 2
		rf_PrintUserStats(raidPtr);	/*
						 * Print out the stats on user
d739 1
a739 2
						 * recon.
						 */
d741 1
a741 1
		/* Fall through to state 6. */
d746 2
a747 4
		raidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared :
							 rf_ds_spared;
		raidPtr->status[row] = (ds) ? rf_rs_reconfigured :
					      rf_rs_optimal;
d750 1
a750 2
		RF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime),
		    &etime, &elpsd);
d752 2
a753 3
		/*
		 * XXX -- Why is state 7 different from state 6 if there is no
		 * return() here ? -- XXX Note that I set elpsd above & use it
d755 1
a755 2
		 * (also, FreeReconControl is called below).
		 */
d761 2
a762 2
		printf("Reconstruction of disk at row %d col %d completed.\n",
		    row, col);
d765 3
a767 6
		printf("Recon time was %d.%06d seconds, accumulated XOR time"
		    " was %ld us (%ld.%06ld).\n", (int) elpsd.tv_sec,
		    (int) elpsd.tv_usec, raidPtr->accumXorTimeUs, xor_s,
		    xor_resid_us);
		printf("  (start time %d sec %d usec, end time %d sec %d"
		    " usec)\n",
d772 2
a773 2
#if	RF_RECON_STATS > 0
		printf("Total head-sep stall count was %d.\n",
d775 1
a775 1
#endif	/* RF_RECON_STATS > 0 */
d777 1
a777 2
		RF_Free(raidPtr->recon_tracerecs, raidPtr->numCol *
		    sizeof(RF_AccTraceEntry_t));
a784 2


d786 3
a788 3
 * Do the right thing upon each reconstruction event.
 * Returns nonzero if and only if there is nothing left unread on the
 * indicated disk.
d790 5
a794 3
int
rf_ProcessReconEvent(RF_Raid_t *raidPtr, RF_RowCol_t frow,
    RF_ReconEvent_t *event)
d796 1
a796 1
	int retcode = 0, submitblocked;
d800 1
a800 2
	Dprintf1("RECON: rf_ProcessReconEvent type %d.\n", event->type);

d803 1
a803 1
		/* A read I/O has completed. */
d805 2
a806 3
		rbuf = raidPtr->reconControl[frow]
		    ->perDiskInfo[event->col].rbuf;
		Dprintf3("RECON: READDONE EVENT: row %d col %d psid %ld.\n",
d808 3
a810 5
		Dprintf7("RECON: done read  psid %ld buf %lx  %02x %02x %02x"
		    " %02x %02x.\n", rbuf->parityStripeID, rbuf->buffer,
		    rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,
		    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff,
		    rbuf->buffer[4] & 0xff);
d813 1
a813 1
		Dprintf1("RECON: submitblocked=%d.\n", submitblocked);
d815 1
a815 2
			retcode = rf_IssueNextReadRequest(raidPtr, frow,
			    event->col);
d818 1
a818 1
		/* A write I/O has completed. */
d823 1
a823 2
		sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit *
		    raidPtr->Layout.SUsPerRU;
d826 5
a830 9
		Dprintf3("RECON: WRITEDONE EVENT: psid %d ru %d"
		    " (%d %% complete).\n",
		    rbuf->parityStripeID, rbuf->which_ru,
		    raidPtr->reconControl[frow]->percentComplete);
		rf_ReconMapUpdate(raidPtr, raidPtr->reconControl[frow]
		    ->reconMap, rbuf->failedDiskSectorOffset,
		    rbuf->failedDiskSectorOffset + sectorsPerRU - 1);
		rf_RemoveFromActiveReconTable(raidPtr, frow,
		    rbuf->parityStripeID, rbuf->which_ru);
d844 5
a848 9
		/* A buffer-stall condition has been cleared. */
	case RF_REVENT_BUFCLEAR:
		Dprintf2("RECON: BUFCLEAR EVENT: row %d col %d.\n", frow,
		    event->col);
		submitblocked = rf_SubmitReconBuffer(raidPtr
		    ->reconControl[frow]->perDiskInfo[event->col].rbuf, 0,
		    (int) (long) event->arg);
		RF_ASSERT(!submitblocked);	/*
						 * We wouldn't have gotten the
d850 1
a850 2
						 * couldn't submit.
						 */
d854 3
a856 4
		/* A user-write reconstruction blockage has been cleared. */
	case RF_REVENT_BLOCKCLEAR:
		DDprintf2("RECON: BLOCKCLEAR EVENT: row %d col %d.\n",
		    frow, event->col);
d860 4
a863 7
		/*
		 * A max-head-separation reconstruction blockage has been
		 * cleared.
		 */
	case RF_REVENT_HEADSEPCLEAR:
		Dprintf2("RECON: HEADSEPCLEAR EVENT: row %d col %d.\n",
		    frow, event->col);
d867 1
a867 1
		/* A buffer has become ready to write. */
d869 1
a869 2
		Dprintf2("RECON: BUFREADY EVENT: row %d col %d.\n",
		    frow, event->col);
d876 2
a877 4
		/*
		 * We need to skip the current RU entirely because it got
		 * recon'd while we were waiting for something else to happen.
		 */
d879 1
a879 2
		DDprintf2("RECON: SKIP EVENT: row %d col %d.\n",
		    frow, event->col);
d883 2
a884 4
		/*
		 * A forced-reconstruction read access has completed. Just
		 * submit the buffer.
		 */
d888 1
a888 2
		DDprintf2("RECON: FORCEDREADDONE EVENT: row %d col %d.\n",
		    frow, event->col);
d902 3
a904 3
 * Find the next thing that's needed on the indicated disk, and issue
 * a read request for it. We assume that the reconstruction buffer
 * associated with this process is free to receive the data. If
d912 1
a912 1
 * we're currently accessing. Note that this deviates from the
d914 1
a914 1
 * accessed. This allows us to easily retry when we're blocked by
d917 2
a918 2
 * Returns nonzero if and only if there is nothing left unread on the
 * indicated disk.
d921 5
a925 2
int
rf_IssueNextReadRequest(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
d927 1
a927 2
	RF_PerDiskReconCtrl_t *ctrl =
	    &raidPtr->reconControl[row]->perDiskInfo[col];
d930 7
a936 12
	RF_ReconUnitCount_t RUsPerPU =
	    layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;
	RF_SectorCount_t sectorsPerRU =
	    layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;
	int do_new_check = 0, retcode = 0, status;

	/*
	 * If we are currently the slowest disk, mark that we have to do a new
	 * check.
	 */
	if (ctrl->headSepCounter <=
	    raidPtr->reconControl[row]->minHeadSepCounter)
d950 3
a952 5
			if (ctrl->curPSID >=
			    raidPtr->reconControl[row]->lastPSID) {
				rf_CheckForNewMinHeadSep(raidPtr, row,
				    ++(ctrl->headSepCounter));
				return (1);	/* Finito ! */
d954 1
a954 2
			/*
			 * Find the disk offsets of the start of the parity
d956 4
a959 7
			 * disk. Skip this entire parity stripe if either disk
			 * does not appear in the indicated PS.
			 */
			status = rf_ComputePSDiskOffsets(raidPtr,
			    ctrl->curPSID, row, col, &ctrl->diskOffset,
			    &rbuf->failedDiskSectorOffset, &rbuf->spRow,
			    &rbuf->spCol, &rbuf->spOffset);
d967 3
a969 5
		/* Skip this RU if it's already been reconstructed. */
		if (rf_CheckRUReconstructed(raidPtr->reconControl[row]
		    ->reconMap, rbuf->failedDiskSectorOffset)) {
			Dprintf2("Skipping psid %ld ru %d: already"
			    " reconstructed.\n", ctrl->curPSID, ctrl->ru_count);
d975 2
a976 2
	if (do_new_check)	/* Update min if needed. */
		rf_CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);
d979 2
a980 4
	/*
	 * At this point, we have definitely decided what to do, and we have
	 * only to see if we can actually do it now.
	 */
d983 1
a983 2
	bzero((char *) &raidPtr->recon_tracerecs[col],
	    sizeof(raidPtr->recon_tracerecs[col]));
d991 1
a991 1
 * Tries to issue the next read on the indicated disk. We may be
d993 1
a993 1
 * indicated RU being blocked due to a write by a user thread. In
d996 1
a996 1
 * has cleared.
d999 5
a1003 2
int
rf_TryToRead(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
d1005 2
a1006 4
	RF_PerDiskReconCtrl_t *ctrl =
	    &raidPtr->reconControl[row]->perDiskInfo[col];
	RF_SectorCount_t sectorsPerRU =
	    raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;
d1010 1
a1010 1
	int status, created = 0;
d1013 3
a1015 6
	/*
	 * If the current disk is too far ahead of the others, issue a
	 * head-separation wait and return.
	 */
	if (rf_CheckHeadSeparation(raidPtr, ctrl, row, col,
	    ctrl->headSepCounter, which_ru))
d1018 1
a1018 2
	pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]
	    ->pssTable, psid, which_ru, RF_PSS_CREATE, &created);
d1020 4
a1023 7
	/*
	 * If recon is blocked on the indicated parity stripe, issue a
	 * block-wait request and return. This also must mark the indicated RU
	 * in the stripe as under reconstruction if not blocked.
	 */
	status = rf_CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl,
	    row, col, psid, which_ru);
d1025 1
a1025 2
		Dprintf2("RECON: Stalling psid %ld ru %d: recon blocked.\n",
		    psid, which_ru);
d1029 1
a1029 2
			rf_CauseReconEvent(raidPtr, row, col, NULL,
			    RF_REVENT_SKIP);
d1032 1
a1032 2
	/*
	 * Make one last check to be sure that the indicated RU didn't get
d1035 1
a1035 1
	 * in the normal case. Might want to make some attempt to re-work
d1037 4
a1040 7
	 * one of the above checks. When this condition is detected, we may
	 * have just created a bogus status entry, which we need to delete.
	 */
	if (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap,
	    ctrl->rbuf->failedDiskSectorOffset)) {
		Dprintf2("RECON: Skipping psid %ld ru %d: prior recon after"
		    " stall.\n", psid, which_ru);
d1042 1
a1042 2
			rf_PSStatusDelete(raidPtr,
			    raidPtr->reconControl[row]->pssTable, pssPtr);
d1046 3
a1048 4
	/* Found something to read. Issue the I/O. */
	Dprintf5("RECON: Read for psid %ld on row %d col %d offset %ld"
	    " buf %lx.\n", psid, row, col, ctrl->diskOffset,
	    ctrl->rbuf->buffer);
d1055 4
a1058 8
	/*
	 * Should be ok to use a NULL proc pointer here, all the bufs we use
	 * should be in kernel space.
	 */
	req = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset,
	    sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,
	    rf_ReconReadDoneProc, (void *) ctrl, NULL,
	    &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);
d1060 1
a1060 1
	RF_ASSERT(req);		/* XXX -- Fix this. -- XXX */
d1073 3
a1075 3
 * Given a parity stripe ID, we want to find out whether both the
 * current disk and the failed disk exist in that parity stripe. If
 * not, we want to skip this whole PS. If so, we want to find the
d1079 1
a1079 1
 * This works by getting a list of disks comprising the indicated
d1081 1
a1081 1
 * disks. Once we've decided they both exist in the parity stripe, we
d1086 1
a1086 1
 * This is kind of unpleasant, but doing it this way allows the
d1090 1
a1090 1
 * reverse-mapping function. I also think it will execute faster,
d1094 1
a1094 2
 * THE STRIPE IN THE CORRECT ORDER.
 */
d1096 1
a1096 1
int
d1098 11
a1108 20
    RF_Raid_t		*raidPtr,	/* RAID descriptor. */
    RF_StripeNum_t	 psid,		/* Parity stripe identifier. */
    RF_RowCol_t		 row,		/*
					 * Row and column of disk to find
					 * the offsets for.
					 */
    RF_RowCol_t		 col,
    RF_SectorNum_t	*outDiskOffset,
    RF_SectorNum_t	*outFailedDiskSectorOffset,
    RF_RowCol_t		*spRow,		/*
					 * OUT: Row,col of spare unit for
					 * failed unit.
					 */
    RF_RowCol_t		*spCol,
    RF_SectorNum_t	*spOffset	/*
					 * OUT: Offset into disk containing
					 * spare unit.
					 */
)
{
d1113 1
a1113 1
	u_int i, j, k, i_offset, j_offset;
d1115 1
a1115 1
	int testcol, testrow;
d1118 2
a1119 3
	char i_is_parity = 0, j_is_parity = 0;
	RF_RowCol_t stripeWidth =
	    layoutPtr->numDataCol + layoutPtr->numParityCol;
d1121 1
a1121 1
	/* Get a listing of the disks comprising that stripe. */
d1123 1
a1123 2
	(layoutPtr->map->IdentifyStripe) (raidPtr, sosRaidAddress, &diskids,
	    &stripe);
d1126 2
a1127 4
	/*
	 * Reject this entire parity stripe if it does not contain the
	 * indicated disk or it does not contain the failed disk.
	 */
d1143 6
a1148 9
	/* Find out which disk the parity is on. */
	(layoutPtr->map->MapParity) (raidPtr, sosRaidAddress, &prow, &pcol,
	    &poffset, RF_DONT_REMAP);

	/* Find out if either the current RU or the failed RU is parity. */
	/*
	 * Also, if the parity occurs in this stripe prior to the data and/or
	 * failed col, we need to decrement i and/or j.
	 */
d1161 2
a1162 4
		}		/*
				 * Set offsets to zero to disable multiply
				 * below.
				 */
d1170 1
a1170 2
	/*
	 * At this point, [ij]_is_parity tells us whether the [current,failed]
d1172 1
a1172 2
	 * tells us how far into the stripe the [current,failed] disk is.
	 */
d1174 2
a1175 4
	/*
	 * Call the mapping routine to get the offset into the current disk,
	 * repeat for failed disk.
	 */
d1177 1
a1177 3
		layoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outDiskOffset, RF_DONT_REMAP);
d1179 1
a1179 3
		layoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outDiskOffset, RF_DONT_REMAP);
d1184 1
a1184 3
		layoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outFailedDiskSectorOffset, RF_DONT_REMAP);
d1186 1
a1186 3
		layoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outFailedDiskSectorOffset, RF_DONT_REMAP);
d1189 1
a1189 1
	/* Now locate the spare unit for the failed unit. */
d1192 1
a1192 3
			layoutPtr->map->MapParity(raidPtr, sosRaidAddress +
			    j_offset * layoutPtr->sectorsPerStripeUnit, spRow,
			    spCol, spOffset, RF_REMAP);
d1194 1
a1194 3
			layoutPtr->map->MapSector(raidPtr, sosRaidAddress +
			    j_offset * layoutPtr->sectorsPerStripeUnit, spRow,
			    spCol, spOffset, RF_REMAP);
d1204 1
a1204 1
	Dprintf3("RECON: Skipping psid %ld: nothing needed from r%d c%d.\n",
d1208 5
a1212 8


/*
 * This is called when a buffer has become ready to write to the replacement
 * disk.
 */
int
rf_IssueNextWriteRequest(RF_Raid_t *raidPtr, RF_RowCol_t row)
d1215 1
a1215 2
	RF_SectorCount_t sectorsPerRU =
	    layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;
d1221 2
a1222 4
	RF_ASSERT(rbuf);	/*
				 * There must be one available, or we wouldn't
				 * have gotten the event that sent us here.
				 */
d1228 1
a1228 2
	Dprintf7("RECON: New write (r %d c %d offs %d) for psid %ld ru %d"
	    " (failed disk offset %ld) buf %lx.\n",
d1231 6
a1236 9
	Dprintf6("RECON: new write psid %ld   %02x %02x %02x %02x %02x.\n",
	    rbuf->parityStripeID, rbuf->buffer[0] & 0xff,
	    rbuf->buffer[1] & 0xff, rbuf->buffer[2] & 0xff,
	    rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);

	/*
	 * Should be ok to use a NULL b_proc here b/c all addrs should be in
	 * kernel space.
	 */
d1238 2
a1239 1
	    sectorsPerRU, rbuf->buffer, rbuf->parityStripeID, rbuf->which_ru,
d1241 2
a1242 1
	    &raidPtr->recon_tracerecs[fcol], (void *) raidPtr, 0, NULL);
d1244 1
a1244 1
	RF_ASSERT(req);		/* XXX -- Fix this. -- XXX */
d1247 1
a1247 2
	rf_DiskIOEnqueue(&raidPtr->Queues[rbuf->spRow][rbuf->spCol], req,
	    RF_IO_RECON_PRIORITY);
d1253 2
a1254 2
 * This gets called upon the completion of a reconstruction read
 * operation. The arg is a pointer to the per-disk reconstruction
d1257 2
a1258 2
 * Called at interrupt context in the kernel, so don't do anything
 * illegal here.
d1260 4
a1263 2
int
rf_ReconReadDoneProc(void *arg, int status)
d1270 3
a1272 3
		 * XXX
		 */
		printf("Recon read failed !\n");
d1277 2
a1278 3
	raidPtr->recon_tracerecs[ctrl->col].specific.recon.
	   recon_fetch_to_return_us =
	     RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[ctrl->col].recon_timer);
d1281 1
a1281 2
	rf_CauseReconEvent(raidPtr, ctrl->row, ctrl->col, NULL,
	    RF_REVENT_READDONE);
d1284 2
a1285 5


/*
 * This gets called upon the completion of a reconstruction write operation.
 * The arg is a pointer to the rbuf that was just written.
d1287 1
a1287 1
 * Called at interrupt context in the kernel, so don't do anything illegal here.
d1289 4
a1292 2
int
rf_ReconWriteDoneProc(void *arg, int status)
d1296 1
a1296 2
	Dprintf2("Reconstruction completed on psid %ld ru %d.\n",
	    rbuf->parityStripeID, rbuf->which_ru);
d1298 2
a1299 2
		/* fprintf(stderr, "Recon write failed !\n"); */
		printf("Recon write failed !\n");
d1302 1
a1302 2
	rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col,
	    arg, RF_REVENT_WRITEDONE);
d1307 3
a1309 3
/*
 * Computes a new minimum head sep, and wakes up anyone who needs to
 * be woken as a result.
d1311 5
a1315 3
void
rf_CheckForNewMinHeadSep(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_HeadSepLimit_t hsCtr)
d1321 2
a1322 2
	/* From the definition of a minimum. */
	RF_ASSERT(hsCtr >= reconCtrlPtr->minHeadSepCounter);
d1330 2
a1331 4
			if (reconCtrlPtr->perDiskInfo[i].headSepCounter <
			    new_min)
				new_min =
				    reconCtrlPtr->perDiskInfo[i].headSepCounter;
d1333 1
a1333 1
	/* Set the new minimum and wake up anyone who can now run again. */
d1336 1
a1336 2
		Dprintf1("RECON:  new min head pos counter val is %ld.\n",
		    new_min);
d1338 1
a1338 2
			if (reconCtrlPtr->headSepCBList->callbackArg.v >
			    new_min)
d1343 1
a1343 2
			rf_CauseReconEvent(raidPtr, p->row, p->col, NULL,
			    RF_REVENT_HEADSEPCLEAR);
d1352 1
a1352 1
 * Checks to see that the maximum head separation will not be violated
d1360 2
a1361 2
 * Returns non-zero if and only if we have to stop working on the
 * indicated disk due to a head-separation delay.
d1363 1
a1363 1
int
d1365 6
a1370 7
    RF_Raid_t			*raidPtr,
    RF_PerDiskReconCtrl_t	*ctrl,
    RF_RowCol_t			 row,
    RF_RowCol_t			 col,
    RF_HeadSepLimit_t		 hsCtr,
    RF_ReconUnitNum_t		 which_ru
)
d1374 1
a1374 1
	int retval = 0;
d1376 2
a1377 3
	/*
	 * If we're too far ahead of the slowest disk, stop working on this
	 * disk until the slower ones catch up. We do this by scheduling a
d1382 1
d1386 5
a1390 6
	    ((ctrl->headSepCounter - reconCtrlPtr->minHeadSepCounter) >
	     raidPtr->headSepLimit)) {
		Dprintf6("raid%d: RECON: head sep stall: row %d col %d hsCtr"
		    " %ld minHSCtr %ld limit %ld.\n",
		    raidPtr->raidid, row, col, ctrl->headSepCounter,
		    reconCtrlPtr->minHeadSepCounter, raidPtr->headSepLimit);
d1392 3
a1394 6
		/*
		 * The minHeadSepCounter value we have to get to before we'll
		 * wake up. Build in 20% hysteresis.
		 */
		cb->callbackArg.v = (ctrl->headSepCounter -
		    raidPtr->headSepLimit + raidPtr->headSepLimit / 5);
d1399 2
a1400 4
		/*
		 * Insert this callback descriptor into the sorted list of
		 * pending head-sep callbacks.
		 */
d1409 1
a1409 3
				for (pt = p, p = p->next;
				    p && (p->callbackArg.v < cb->callbackArg.v);
				    pt = p, p = p->next);
d1414 1
a1414 1
#if	RF_RECON_STATS > 0
d1416 1
a1416 1
#endif	/* RF_RECON_STATS > 0 */
d1422 4
a1425 7



/*
 * Checks to see if reconstruction has been either forced or blocked
 * by a user operation. If forced, we skip this RU entirely. Else if
 * blocked, put ourselves on the wait list. Else return 0.
d1427 1
a1427 1
 * ASSUMES THE PSS MUTEX IS LOCKED UPON ENTRY.
d1429 1
a1429 1
int
d1431 7
a1437 8
    RF_Raid_t			 *raidPtr,
    RF_ReconParityStripeStatus_t *pssPtr,
    RF_PerDiskReconCtrl_t	 *ctrl,
    RF_RowCol_t			  row,
    RF_RowCol_t			  col,
    RF_StripeNum_t		  psid,
    RF_ReconUnitNum_t		  which_ru
)
d1440 1
a1440 1
	int retcode = 0;
d1442 1
a1442 2
	if ((pssPtr->flags & RF_PSS_FORCED_ON_READ) ||
	    (pssPtr->flags & RF_PSS_FORCED_ON_WRITE))
d1446 2
a1447 4
			Dprintf4("RECON: row %d col %d blocked at psid %ld"
			    " ru %d.\n", row, col, psid, which_ru);
			cb = rf_AllocCallbackDesc();	/*
							 * Append ourselves to
d1449 1
a1449 2
							 * list.
							 */
d1457 2
a1458 4
		pssPtr->flags |= RF_PSS_UNDER_RECON;	/*
							 * Mark this RU as under
							 * reconstruction.
							 */
a1461 2


d1463 1
a1463 1
 * If reconstruction is currently ongoing for the indicated stripeID,
d1465 2
a1466 2
 * indicate that the caller must wait. If not, then reconstruction is
 * blocked on the indicated stripe and the routine returns zero. If
d1468 1
a1468 1
 * invoked with the cbArg when the reconstruction has completed.
d1470 17
a1486 23
int
rf_ForceOrBlockRecon(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap,
	void (*cbFunc) (RF_Raid_t *, void *), void *cbArg)
{
	RF_RowCol_t row = asmap->physInfo->row;	/*
						 * Which row of the array
						 * we're working on.
						 */
	RF_StripeNum_t stripeID = asmap->stripeID;	/*
							 * The stripe ID we're
							 * forcing recon on.
							 */
	RF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit *
	    raidPtr->Layout.SUsPerRU;		/* Num sects in one RU. */
	RF_ReconParityStripeStatus_t *pssPtr;	/*
						 * A pointer to the parity
						 * stripe status structure.
						 */
	RF_StripeNum_t psid;			/* Parity stripe id. */
	RF_SectorNum_t offset, fd_offset;	/*
						 * Disk offset, failed-disk
						 * offset.
						 */
d1489 1
a1489 1
	RF_ReconUnitNum_t which_ru;	/* RU within parity stripe. */
d1491 2
a1492 2
	RF_ReconBuffer_t *new_rbuf;	/* Ptr to newly allocated rbufs. */
	RF_DiskQueueData_t *req;	/* Disk I/O req to be enqueued. */
d1494 1
a1494 1
	int created = 0, nPromoted;
d1496 1
a1496 2
	psid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID,
	    &which_ru);
d1500 1
a1500 3
	pssPtr = rf_LookupRUStatus(raidPtr,
	    raidPtr->reconControl[row]->pssTable, psid, which_ru,
	    RF_PSS_CREATE | RF_PSS_RECON_BLOCKED, &created);
d1502 1
a1502 1
	/* If recon is not ongoing on this PS, just return. */
d1507 3
a1509 6
	/*
	 * Otherwise, we have to wait for reconstruction to complete on this
	 * RU.
	 */
	/*
	 * In order to avoid waiting for a potentially large number of
d1511 7
a1517 9
	 * not low-priority) reconstruction on this RU.
	 */
	if (!(pssPtr->flags & RF_PSS_FORCED_ON_WRITE) &&
	    !(pssPtr->flags & RF_PSS_FORCED_ON_READ)) {
		DDprintf1("Forcing recon on psid %ld.\n", psid);
		/* Mark this RU as under forced recon. */
		pssPtr->flags |= RF_PSS_FORCED_ON_WRITE;
		/* Clear the blockage that we just set. */
		pssPtr->flags &= ~RF_PSS_RECON_BLOCKED;
d1520 2
a1521 5
		/*
		 * Get a listing of the disks comprising the indicated stripe.
		 */
		(raidPtr->Layout.map->IdentifyStripe) (raidPtr,
		    asmap->raidAddress, &diskids, &stripe);
d1524 2
a1525 3
		/*
		 * For previously issued reads, elevate them to normal
		 * priority. If the I/O has already completed, it won't be
d1527 1
a1527 1
		 * unissued reads, allocate buffers and issue new reads. The
d1529 2
a1530 4
		 * recon procs will not re-issue these reqs.
		 */
		for (i = 0; i < raidPtr->Layout.numDataCol +
		    raidPtr->Layout.numParityCol; i++)
d1533 1
a1533 3
					nPromoted = rf_DiskIOPromote(&raidPtr
					    ->Queues[row][diskno], psid,
					    which_ru);
d1535 1
a1535 4
						printf("raid%d: promoted read"
						    " from row %d col %d.\n",
						    raidPtr->raidid, row,
						    diskno);
d1537 5
a1541 10
					/* Create new buf. */
					new_rbuf = rf_MakeReconBuffer(raidPtr,
					    row, diskno, RF_RBUF_TYPE_FORCED);
					/* Find offsets & spare locationp */
					rf_ComputePSDiskOffsets(raidPtr, psid,
					    row, diskno, &offset, &fd_offset,
					    &new_rbuf->spRow, &new_rbuf->spCol,
					    &new_rbuf->spOffset);
					new_rbuf->parityStripeID = psid;
					/* Fill in the buffer. */
d1543 7
a1549 17
					new_rbuf->failedDiskSectorOffset =
					    fd_offset;
					new_rbuf->priority =
					    RF_IO_NORMAL_PRIORITY;

					/*
					 * Use NULL b_proc b/c all addrs
					 * should be in kernel space.
					 */
					req = rf_CreateDiskQueueData(
					    RF_IO_TYPE_READ, offset +
					    which_ru * sectorsPerRU,
					    sectorsPerRU, new_rbuf->buffer,
					    psid, which_ru, (int (*)
					    (void *, int))
					      rf_ForceReconReadDoneProc,
					    (void *) new_rbuf, NULL,
d1552 2
a1553 4
					RF_ASSERT(req);	/*
							 * XXX -- Fix this. --
							 * XXX
							 */
d1556 2
a1557 7
					/* Enqueue the I/O. */
					rf_DiskIOEnqueue(&raidPtr
					    ->Queues[row][diskno], req,
					    RF_IO_NORMAL_PRIORITY);
					Dprintf3("raid%d: Issued new read req"
					    " on row %d col %d.\n",
					    raidPtr->raidid, row, diskno);
d1560 8
a1567 13
		/*
		 * If the write is sitting in the disk queue, elevate its
		 * priority.
		 */
		if (rf_DiskIOPromote(&raidPtr->Queues[row][fcol],
		    psid, which_ru))
			printf("raid%d: promoted write to row %d col %d.\n",
			    raidPtr->raidid, row, fcol);
	}
	/*
	 * Install a callback descriptor to be invoked when recon completes on
	 * this parity stripe.
	 */
d1569 2
a1570 4
	/*
	 * XXX The following is bogus... These functions don't really match !!!
	 * GO
	 */
d1575 2
a1576 2
	DDprintf2("raid%d: Waiting for forced recon on psid %ld.\n",
	    raidPtr->raidid, psid);
d1581 3
a1583 6


/*
 * Called upon the completion of a forced reconstruction read.
 * All we do is schedule the FORCEDREADONE event.
 * Called at interrupt context in the kernel, so don't do anything illegal here.
d1585 4
a1588 2
void
rf_ForceReconReadDoneProc(void *arg, int status)
d1593 3
a1595 2
		/* fprintf(stderr, "Forced recon read failed !\n"); */
		printf("Forced recon read failed !\n");
d1598 1
a1598 2
	rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col,
	    (void *) rbuf, RF_REVENT_FORCEDREADDONE);
d1600 5
a1604 5


/* Releases a block on the reconstruction of the indicated stripe. */
int
rf_UnblockRecon(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap)
d1611 1
a1611 1
	int created = 0;
d1614 1
a1614 2
	psid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID,
	    &which_ru);
d1616 1
a1616 2
	pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]
	    ->pssTable, psid, which_ru, RF_PSS_NONE, &created);
d1618 1
a1618 2
	/*
	 * When recon is forced, the pss desc can get deleted before we get
d1621 1
a1621 2
	 * how to decide if recon was just forced or not ?
	 */
d1623 2
a1624 4
		/*
		 * printf("Warning: no pss descriptor upon unblock on psid %ld"
		 *     " RU %d.\n", psid, which_ru);
		 */
d1626 1
a1626 2
			printf("Warning: no pss descriptor upon unblock on"
			    " psid %ld RU %d.\n", (long) psid, which_ru);
d1630 3
a1632 4
	Dprintf3("raid%d: unblocking recon on psid %ld: blockcount is %d.\n",
	    raidPtr->raidid, psid, pssPtr->blockCount);
	if (pssPtr->blockCount == 0) {
		/* If recon blockage has been released. */
d1634 1
a1634 2
		/*
		 * Unblock recon before calling CauseReconEvent in case
d1636 1
a1636 2
		 * returning here.
		 */
d1640 3
a1642 5
		while (pssPtr->blockWaitList) {
			/*
			 * Spin through the block-wait list and
			 * release all the waiters.
			 */
d1646 1
a1646 2
			rf_CauseReconEvent(raidPtr, cb->row, cb->col, NULL,
			    RF_REVENT_BLOCKCLEAR);
d1650 2
a1651 3
			/* If no recon was requested while recon was blocked. */
			rf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]
			    ->pssTable, pssPtr);
@


1.9
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.8 2000/01/11 18:02:23 peter Exp $	*/
d463 1
a463 1
		proc = raidPtr->engine_thread;
@


1.8
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconstruct.c,v 1.7 2000/01/11 14:51:37 peter Exp $	*/
/*	$NetBSD: rf_reconstruct.c,v 1.14 2000/01/09 03:14:33 oster Exp $	*/
d348 1
a348 3
		c_label.version = RF_COMPONENT_LABEL_VERSION; 
		c_label.mod_counter = raidPtr->mod_counter;
		c_label.serial_number = raidPtr->serial_number;
a350 2
		c_label.num_rows = raidPtr->numRow;
		c_label.num_columns = raidPtr->numCol;
d353 2
d392 1
d427 2
d471 3
a473 3
			VOP_UNLOCK(raidPtr->raid_cinfo[row][col].ci_vp, 0, proc);
			(void) vn_close(raidPtr->raid_cinfo[row][col].ci_vp,
					FREAD | FWRITE, proc->p_ucred, proc);
d476 3
d582 3
a584 4
		
		c_label.version = RF_COMPONENT_LABEL_VERSION; 
		c_label.mod_counter = raidPtr->mod_counter;
		c_label.serial_number = raidPtr->serial_number;
a586 4
		c_label.num_rows = raidPtr->numRow;
		c_label.num_columns = raidPtr->numCol;
		c_label.clean = RF_RAID_DIRTY;
		c_label.status = rf_ds_optimal;
d687 8
a694 1
			raidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);
d757 2
a758 1
		printf("Reconstruction of disk at row %d col %d completed and spare disk reassigned\n", row, col);
d907 1
a907 1
 * rbuf->failedDiskSectorOffset are maintained to point the the unit
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconstruct.c,v 1.10 2001/01/02 09:06:26 peter Exp $	*/
/*	$NetBSD: rf_reconstruct.c,v 1.26 2000/06/04 02:05:13 oster Exp $	*/
d348 3
a350 1
		raid_init_component_label( raidPtr, &c_label);
d353 2
a356 2

		/* XXXX MORE NEEDED HERE */
a393 1
	int ac;
a427 2
			rf_update_component_labels(raidPtr, 
						   RF_NORMAL_COMPONENT_UPDATE);
d462 1
a462 1
		proc = raidPtr->recon_thread;
d470 3
a472 3
			vp = raidPtr->raid_cinfo[row][col].ci_vp;
			ac = raidPtr->Disks[row][col].auto_configured;
			rf_close_component(raidPtr, vp, ac);
a474 3
		/* note that this disk was *not* auto_configured (any longer)*/
		raidPtr->Disks[row][col].auto_configured = 0;

d578 4
a581 3

		raid_init_component_label(raidPtr, &c_label);

d584 4
d688 1
a688 8
			raidPtr->reconControl[row]->numRUsTotal = 
				mapPtr->totalRUs;
			raidPtr->reconControl[row]->numRUsComplete = 
				mapPtr->totalRUs - 
				rf_UnitsLeftToReconstruct(mapPtr);

			raidPtr->reconControl[row]->percentComplete = 
				(raidPtr->reconControl[row]->numRUsComplete * 100 / raidPtr->reconControl[row]->numRUsTotal);
d751 1
a751 2
		printf("Reconstruction of disk at row %d col %d completed\n", 
		       row, col);
d900 1
a900 1
 * rbuf->failedDiskSectorOffset are maintained to point to the unit
@


1.8.2.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 5
a90 5
RF_RaidReconDesc_t *rf_AllocRaidReconDesc(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t, RF_RaidDisk_t *, int, RF_RowCol_t, RF_RowCol_t);
int rf_ProcessReconEvent(RF_Raid_t *, RF_RowCol_t, RF_ReconEvent_t *);
int rf_IssueNextReadRequest(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int rf_TryToRead(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int rf_ComputePSDiskOffsets(RF_Raid_t *, RF_StripeNum_t, RF_RowCol_t, RF_RowCol_t, RF_SectorNum_t *, RF_SectorNum_t *, RF_RowCol_t *, RF_RowCol_t *, RF_SectorNum_t *);
d95 2
a96 2
void rf_ForceReconReadDoneProc(void *, int);
void rf_ShutdownReconstruction(void *);
d102 4
a105 4
void rf_FreeReconDesc(RF_RaidReconDesc_t *);
int rf_IssueNextWriteRequest(RF_Raid_t *, RF_RowCol_t);
int rf_CheckForcedOrBlockedReconstruction(RF_Raid_t *, RF_ReconParityStripeStatus_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_StripeNum_t, RF_ReconUnitNum_t);
void rf_SignalReconDone(RF_Raid_t *);
@


1.8.2.3
log
@Sync the SMP branch with 3.3
@
text
@a2 1

d30 1
a30 1
/**************************************************************
d32 1
a32 1
 * rf_reconstruct.c -- Code to perform on-line reconstruction.
d34 1
a34 1
 **************************************************************/
d47 1
a47 1
#if	__NETBSD__
d68 10
a77 4
/*
 * Setting these to -1 causes them to be set to their default values if not set
 * by debug options.
 */
d79 2
a80 92
#define	Dprintf(s)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);	\
} while (0)
#define	Dprintf1(s,a)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
#define	Dprintf2(s,a,b)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
#define	Dprintf3(s,a,b,c)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    NULL, NULL, NULL, NULL, NULL);			\
} while (0)
#define	Dprintf4(s,a,b,c,d)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    NULL, NULL, NULL, NULL);				\
} while (0)
#define	Dprintf5(s,a,b,c,d,e)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    (void *)((unsigned long)e),				\
		    NULL, NULL, NULL);					\
} while (0)
#define	Dprintf6(s,a,b,c,d,e,f)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    (void *)((unsigned long)e),				\
		    (void *)((unsigned long)f),				\
		    NULL, NULL);					\
} while (0)
#define	Dprintf7(s,a,b,c,d,e,f,g)					\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    (void *)((unsigned long)d),				\
		    (void *)((unsigned long)e),				\
		    (void *)((unsigned long)f),				\
		    (void *)((unsigned long)g),				\
		    NULL);						\
} while (0)

#define	DDprintf1(s,a)							\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
#define	DDprintf2(s,a,b)						\
do {									\
	if (rf_reconDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    NULL, NULL, NULL, NULL, NULL, NULL);		\
} while (0)
d83 2
a84 2
#define	RF_MAX_FREE_RECOND	4
#define	RF_RECOND_INC		1
d86 7
a92 11
RF_RaidReconDesc_t *rf_AllocRaidReconDesc(RF_Raid_t *,
	RF_RowCol_t, RF_RowCol_t, RF_RaidDisk_t *, int,
	RF_RowCol_t, RF_RowCol_t);
int  rf_ProcessReconEvent(RF_Raid_t *, RF_RowCol_t, RF_ReconEvent_t *);
int  rf_IssueNextReadRequest(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_TryToRead(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ComputePSDiskOffsets(RF_Raid_t *, RF_StripeNum_t,
	RF_RowCol_t, RF_RowCol_t, RF_SectorNum_t *, RF_SectorNum_t *,
	RF_RowCol_t *, RF_RowCol_t *, RF_SectorNum_t *);
int  rf_ReconReadDoneProc(void *, int);
int  rf_ReconWriteDoneProc(void *, int);
d94 1
a94 2
int  rf_CheckHeadSeparation(RF_Raid_t *, RF_PerDiskReconCtrl_t *,
	RF_RowCol_t, RF_RowCol_t, RF_HeadSepLimit_t, RF_ReconUnitNum_t);
d99 2
a100 2
 * These functions are inlined on gcc. If they are used more than
 * once, it is strongly advised to un-line them.
d103 2
a104 4
int  rf_IssueNextWriteRequest(RF_Raid_t *, RF_RowCol_t);
int  rf_CheckForcedOrBlockedReconstruction(RF_Raid_t *,
	RF_ReconParityStripeStatus_t *, RF_PerDiskReconCtrl_t *,
	RF_RowCol_t, RF_RowCol_t, RF_StripeNum_t, RF_ReconUnitNum_t);
d108 3
a110 3
	void			(*proc) (RF_Raid_t *, void *);
	void			 *arg;
	RF_ReconDoneProc_t	 *next;
d114 2
a115 2
#define	RF_MAX_FREE_RDP		4
#define	RF_RDP_INC		1
d117 2
a118 2
void
rf_SignalReconDone(RF_Raid_t *raidPtr)
d129 6
a134 3
int
rf_RegisterReconDoneProc(RF_Raid_t *raidPtr, void (*proc) (RF_Raid_t *, void *),
    void *arg, RF_ReconDoneProc_t **handlep)
d151 1
a151 2

/*****************************************************************************
d153 2
a154 2
 * Sets up the parameters that will be used by the reconstruction process.
 * Currently there are none, except for those that the layout-specific
d157 1
a157 1
 * In the kernel, we fire off the recon thread.
d159 4
a162 3
 *****************************************************************************/
void
rf_ShutdownReconstruction(void *ignored)
d168 3
a170 2
int
rf_ConfigureReconstruction(RF_ShutdownList_t **listp)
d172 1
a172 1
	int rc;
d181 1
a181 2
		RF_FREELIST_DESTROY(rf_recond_freelist, next,
		    (RF_RaidReconDesc_t *));
d186 2
a187 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d.\n", __FILE__, __LINE__, rc);
d195 8
a202 3
rf_AllocRaidReconDesc(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col,
    RF_RaidDisk_t *spareDiskPtr, int numDisksDone, RF_RowCol_t srow,
    RF_RowCol_t scol)
d207 1
a207 2
	RF_FREELIST_GET(rf_recond_freelist, reconDesc, next,
	    (RF_RaidReconDesc_t *));
d222 3
a224 2
void
rf_FreeReconDesc(RF_RaidReconDesc_t *reconDesc)
d226 2
a227 2
#if	RF_RECON_STATS > 0
	printf("RAIDframe: %qu recon event waits, %qu recon delays.\n",
d229 1
a229 1
#endif	/* RF_RECON_STATS > 0 */
d231 1
a231 2
	printf("RAIDframe: %qu max exec ticks.\n",
	    reconDesc->maxReconExecTicks);
d233 1
a233 1
#if	(RF_RECON_STATS > 0) || defined(_KERNEL)
d235 1
a235 1
#endif	/* (RF_RECON_STATS > 0) || _KERNEL */
d240 1
a240 1
/*****************************************************************************
d242 2
a243 2
 * Primary routine to reconstruct a failed disk. This should be called from
 * within its own thread. It won't return until reconstruction completes,
d246 6
a251 3
 *****************************************************************************/
int
rf_ReconstructFailedDisk(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
d254 1
a254 1
	int rc;
d259 3
a261 3
		 * The current infrastructure only supports reconstructing one
		 * disk at a time for each array.
		 */
d273 2
a274 2
		RF_ERRORMSG1("RECON: no way to reconstruct failed disk for"
		    " arch %c.\n", lp->parityConfig);
d278 2
a279 4
	wakeup(&raidPtr->waitForReconCond);	/*
						 * XXX Methinks this will be
						 * needed at some point... GO
						 */
d283 5
a287 3
int
rf_ReconstructFailedDiskBasic(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_RowCol_t col)
d293 1
a293 1
	int numDisksDone = 0, rc;
d295 3
a297 5
	/* First look for a spare drive onto which to reconstruct the data. */
	/*
	 * Spare disk descriptors are stored in row 0. This may have to
	 * change eventually.
	 */
d304 1
a304 2
			RF_ERRORMSG2("Unable to reconstruct disk at row %d"
			    " col %d because status not degraded.\n", row, col);
d312 1
a312 2
		for (scol = raidPtr->numCol;
		     scol < raidPtr->numCol + raidPtr->numSpare; scol++) {
d320 1
a320 3
			RF_ERRORMSG2("Unable to reconstruct disk at row %d"
			    " col %d because no spares are available.\n",
			    row, col);
d324 1
a324 2
		printf("RECON: initiating reconstruction on row %d col %d"
		    " -> spare at row %d col %d.\n", row, col, srow, scol);
d328 1
a328 2
	reconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col,
	    spareDiskPtr, numDisksDone, srow, scol);
d330 1
a330 1
#if	RF_RECON_STATS > 0
d334 1
a334 1
#endif	/* RF_RECON_STATS > 0 */
d341 2
a342 2
		/* Fix up the component label. */
		/* Don't actually need the read here... */
d344 5
a348 5
		    raidPtr->raid_cinfo[srow][scol].ci_dev,
		    raidPtr->raid_cinfo[srow][scol].ci_vp,
		    &c_label);

		raid_init_component_label(raidPtr, &c_label);
d354 2
a355 2
		/* XXXX MORE NEEDED HERE. */

d357 4
a360 4
		    raidPtr->raid_cinfo[srow][scol].ci_dev,
		    raidPtr->raid_cinfo[srow][scol].ci_vp,
		    &c_label);

d365 9
a373 9
/*
 *
 * Allow reconstructing a disk in-place -- i.e. component /dev/sd2e goes AWOL,
 * and you don't get a spare until the next Monday. With this function
 * (and hot-swappable drives) you can now put your new disk containing
 * /dev/sd2e on the bus, scsictl it alive, and then use raidctl(8) to
 * rebuild the data "on the spot".
 *
 */
d376 4
a379 1
rf_ReconstructInPlace(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
d386 1
a386 1
	int numDisksDone = 0, rc;
d397 3
a399 3
		 * The current infrastructure only supports reconstructing one
		 * disk at a time for each array.
		 */
d402 8
a409 12
		    (raidPtr->numFailures > 0)) {
			/* XXX 0 above shouldn't be constant !!! */
			/*
			 * Some component other than this has failed.
			 * Let's not make things worse than they already
			 * are...
			 */
#ifdef	RAIDDEBUG
			printf("RAIDFRAME: Unable to reconstruct to disk at:\n"
			    "      Row: %d Col: %d   Too many failures.\n",
			    row, col);
#endif	/* RAIDDEBUG */
d414 2
a415 5
#ifdef	RAIDDEBUG
			printf("RAIDFRAME: Unable to reconstruct to disk at:\n"
			    "      Row: %d Col: %d   Reconstruction already"
			    " occuring !\n", row, col);
#endif	/* RAIDDEBUG */
d427 2
a428 2
			rf_update_component_labels(raidPtr,
			    RF_NORMAL_COMPONENT_UPDATE);
a436 5
		/*
		 * First look for a spare drive onto which to reconstruct
		 * the data. Spare disk descriptors are stored in row 0.
		 * This may have to change eventually.
		 */
d438 8
a445 7
		/*
		 * Actually, we don't care if it's failed or not...
		 * On a RAID set with correct parity, this function
		 * should be callable on any component without ill effects.
		 */
		/*
		 * RF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed);
d449 1
a449 3
			RF_ERRORMSG2("Unable to reconstruct to disk at row %d"
			    " col %d: operation not supported for"
			    " RF_DISTRIBUTE_SPARE.\n", row, col);
d454 5
a458 1
		}
a459 4
		/*
		 * XXX Need goop here to see if the disk is alive,
		 * and, if not, make it so...
		 */
d465 2
a466 4
		/*
		 * This device may have been opened successfully the
		 * first time. Close it before trying to open it again...
		 */
d469 2
a470 2
			printf("Closing the opened device: %s\n",
			    raidPtr->Disks[row][col].devname);
d476 1
a476 3
		/*
		 * Note that this disk was *not* auto_configured (any longer).
		 */
d480 9
a488 4
		    raidPtr->Disks[row][col].devname);

		retcode = raidlookup(raidPtr->Disks[row][col].devname,
		    proc, &vp);
d490 2
a491 9
		if (retcode) {
			printf("raid%d: rebuilding: raidlookup on device: %s"
			    " failed: %d !\n", raidPtr->raidid,
			    raidPtr->Disks[row][col].devname, retcode);

			/*
			 * XXX the component isn't responding properly...
			 * Must still be dead :-(
			 */
d498 2
a499 4
			/*
			 * Ok, so we can at least do a lookup...
			 * How about actually getting a vp for it ?
			 */
d501 2
a502 2
			if ((retcode =
			     VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {
d508 1
a508 1
			    FREAD, proc->p_ucred, proc);
d515 1
a515 4
			    dpart.disklab->d_secsize;

			raidPtr->Disks[row][col].numBlocks =
			    dpart.part->p_size - rf_protectedSectors;
d517 3
d522 1
a522 1

d524 5
a528 6

			/*
			 * We allow the user to specify that only a
			 * fraction of the disks should be used this is
			 * just for debug:  it speeds up the parity scan.
			 */
d530 2
a531 2
			    raidPtr->Disks[row][col].numBlocks *
			    rf_sizePercentage / 100;
d534 2
d539 3
a541 3
		printf("RECON: Initiating in-place reconstruction on\n");
		printf("       row %d col %d -> spare at row %d col %d.\n",
		    row, col, row, col);
d544 4
a547 3

		reconDesc = rf_AllocRaidReconDesc((void *) raidPtr, row, col,
		    spareDiskPtr, numDisksDone, row, col);
d549 1
a549 1
#if	RF_RECON_STATS > 0
d553 1
a553 1
#endif	/* RF_RECON_STATS > 0 */
d564 2
a565 2
		RF_ERRORMSG1("RECON: no way to reconstruct failed disk for"
		    " arch %c.\n", lp->parityConfig);
d569 1
a569 1

d571 3
a573 5
		/*
		 * Need to set these here, as at this point it'll be claiming
		 * that the disk is in rf_ds_spared !  But we know better :-)
		 */

d576 6
a581 7

		/* Fix up the component label. */
		/* Don't actually need the read here... */
		raidread_component_label(
		    raidPtr->raid_cinfo[row][col].ci_dev,
		    raidPtr->raid_cinfo[row][col].ci_vp,
		    &c_label);
d587 1
a587 1

d589 2
a590 1
		    raidPtr->raid_cinfo[row][col].ci_vp, &c_label);
d595 1
a595 1
	wakeup(&raidPtr->waitForReconCond);
d600 3
a602 2
int
rf_ContinueReconstructFailedDisk(RF_RaidReconDesc_t *reconDesc)
d614 1
a614 1
	int retcode, i, ds;
d620 2
a621 3
		/* Create one trace record per physical disk. */
		RF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol *
		    sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d623 1
a623 2
		/*
		 * Quiesce the array prior to starting recon. This is needed
d625 1
a625 2
		 * We need to do this before we change the disk or row status.
		 */
d628 1
a628 1
		Dprintf("RECON: begin request suspend.\n");
d630 4
a633 6
		Dprintf("RECON: end request suspend.\n");
		rf_StartUserStats(raidPtr);	/*
						 * Zero out the stats kept on
						 * user accs.
						 */
		/* Fall through to state 1. */
d637 3
a639 6
		/*
		 * Create the reconstruction control pointer and install it in
		 * the right slot.
		 */
		raidPtr->reconControl[row] =
		    rf_MakeReconControl(reconDesc, row, col, srow, scol);
d650 2
a651 4
		/*
		 * Now start up the actual reconstruction: issue a read for
		 * each surviving disk.
		 */
d656 2
a657 4
				/*
				 * Find and issue the next I/O on the
				 * indicated disk.
				 */
d659 1
a659 2
					Dprintf2("RECON: done issuing for r%d"
					    " c%d.\n", row, i);
d668 1
a668 1
		Dprintf("RECON: resume requests.\n");
d671 1
d676 2
a677 4
		/*
		 * Process reconstruction events until all disks report that
		 * they've completed all work.
		 */
d682 1
a682 3
			event = rf_GetNextReconEvent(reconDesc, row,
			   (void (*) (void *)) rf_ContinueReconstructFailedDisk,
			    reconDesc);
d687 1
a687 1
			raidPtr->reconControl[row]->numRUsTotal =
d689 2
a690 2
			raidPtr->reconControl[row]->numRUsComplete =
				mapPtr->totalRUs -
d693 2
a694 3
			raidPtr->reconControl[row]->percentComplete =
			    (raidPtr->reconControl[row]->numRUsComplete * 100 /
			     raidPtr->reconControl[row]->numRUsTotal);
d696 1
a696 3
				rf_PrintReconSchedule(
				    raidPtr->reconControl[row]->reconMap,
				    &(raidPtr->reconControl[row]->starttime));
d705 1
a705 1
			printf("RECON: all reads completed.\n");
d707 2
a708 4
		/*
		 * At this point all the reads have completed. We now wait
		 * for any pending writes to complete, and then we're done.
		 */
d710 1
a710 2
		while (rf_UnitsLeftToReconstruct(
		    raidPtr->reconControl[row]->reconMap) > 0) {
d712 1
a712 3
			event = rf_GetNextReconEvent(reconDesc, row,
			   (void (*) (void *)) rf_ContinueReconstructFailedDisk,
			    reconDesc);
d715 2
a716 5
			/* Ignore return code. */
			(void) rf_ProcessReconEvent(raidPtr, row, event);
			raidPtr->reconControl[row]->percentComplete =
			    100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 /
			    mapPtr->totalRUs);
d718 1
a718 3
				rf_PrintReconSchedule(
				    raidPtr->reconControl[row]->reconMap,
				    &(raidPtr->reconControl[row]->starttime));
d724 1
a724 2
		/*
		 * Success:  mark the dead disk as reconstructed. We quiesce
d726 2
a727 3
		 * user accesses, when we free up the psstatus structure as
		 * part of FreeReconControl().
		 */
d733 1
a733 2
		rf_PrintUserStats(raidPtr);	/*
						 * Print out the stats on user
d735 1
a735 2
						 * recon.
						 */
d737 1
a737 1
		/* Fall through to state 6. */
d742 2
a743 4
		raidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared :
							 rf_ds_spared;
		raidPtr->status[row] = (ds) ? rf_rs_reconfigured :
					      rf_rs_optimal;
d746 1
a746 2
		RF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime),
		    &etime, &elpsd);
d748 2
a749 3
		/*
		 * XXX -- Why is state 7 different from state 6 if there is no
		 * return() here ? -- XXX Note that I set elpsd above & use it
d751 1
a751 2
		 * (also, FreeReconControl is called below).
		 */
d757 2
a758 2
		printf("Reconstruction of disk at row %d col %d completed.\n",
		    row, col);
d761 3
a763 6
		printf("Recon time was %d.%06d seconds, accumulated XOR time"
		    " was %ld us (%ld.%06ld).\n", (int) elpsd.tv_sec,
		    (int) elpsd.tv_usec, raidPtr->accumXorTimeUs, xor_s,
		    xor_resid_us);
		printf("  (start time %d sec %d usec, end time %d sec %d"
		    " usec)\n",
d768 2
a769 2
#if	RF_RECON_STATS > 0
		printf("Total head-sep stall count was %d.\n",
d771 1
a771 1
#endif	/* RF_RECON_STATS > 0 */
d773 1
a773 2
		RF_Free(raidPtr->recon_tracerecs, raidPtr->numCol *
		    sizeof(RF_AccTraceEntry_t));
a780 2


d782 3
a784 3
 * Do the right thing upon each reconstruction event.
 * Returns nonzero if and only if there is nothing left unread on the
 * indicated disk.
d786 5
a790 3
int
rf_ProcessReconEvent(RF_Raid_t *raidPtr, RF_RowCol_t frow,
    RF_ReconEvent_t *event)
d792 1
a792 1
	int retcode = 0, submitblocked;
d796 1
a796 2
	Dprintf1("RECON: rf_ProcessReconEvent type %d.\n", event->type);

d799 1
a799 1
		/* A read I/O has completed. */
d801 2
a802 3
		rbuf = raidPtr->reconControl[frow]
		    ->perDiskInfo[event->col].rbuf;
		Dprintf3("RECON: READDONE EVENT: row %d col %d psid %ld.\n",
d804 3
a806 5
		Dprintf7("RECON: done read  psid %ld buf %lx  %02x %02x %02x"
		    " %02x %02x.\n", rbuf->parityStripeID, rbuf->buffer,
		    rbuf->buffer[0] & 0xff, rbuf->buffer[1] & 0xff,
		    rbuf->buffer[2] & 0xff, rbuf->buffer[3] & 0xff,
		    rbuf->buffer[4] & 0xff);
d809 1
a809 1
		Dprintf1("RECON: submitblocked=%d.\n", submitblocked);
d811 1
a811 2
			retcode = rf_IssueNextReadRequest(raidPtr, frow,
			    event->col);
d814 1
a814 1
		/* A write I/O has completed. */
d819 1
a819 2
		sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit *
		    raidPtr->Layout.SUsPerRU;
d822 5
a826 9
		Dprintf3("RECON: WRITEDONE EVENT: psid %d ru %d"
		    " (%d %% complete).\n",
		    rbuf->parityStripeID, rbuf->which_ru,
		    raidPtr->reconControl[frow]->percentComplete);
		rf_ReconMapUpdate(raidPtr, raidPtr->reconControl[frow]
		    ->reconMap, rbuf->failedDiskSectorOffset,
		    rbuf->failedDiskSectorOffset + sectorsPerRU - 1);
		rf_RemoveFromActiveReconTable(raidPtr, frow,
		    rbuf->parityStripeID, rbuf->which_ru);
d840 5
a844 9
		/* A buffer-stall condition has been cleared. */
	case RF_REVENT_BUFCLEAR:
		Dprintf2("RECON: BUFCLEAR EVENT: row %d col %d.\n", frow,
		    event->col);
		submitblocked = rf_SubmitReconBuffer(raidPtr
		    ->reconControl[frow]->perDiskInfo[event->col].rbuf, 0,
		    (int) (long) event->arg);
		RF_ASSERT(!submitblocked);	/*
						 * We wouldn't have gotten the
d846 1
a846 2
						 * couldn't submit.
						 */
d850 3
a852 4
		/* A user-write reconstruction blockage has been cleared. */
	case RF_REVENT_BLOCKCLEAR:
		DDprintf2("RECON: BLOCKCLEAR EVENT: row %d col %d.\n",
		    frow, event->col);
d856 4
a859 7
		/*
		 * A max-head-separation reconstruction blockage has been
		 * cleared.
		 */
	case RF_REVENT_HEADSEPCLEAR:
		Dprintf2("RECON: HEADSEPCLEAR EVENT: row %d col %d.\n",
		    frow, event->col);
d863 1
a863 1
		/* A buffer has become ready to write. */
d865 1
a865 2
		Dprintf2("RECON: BUFREADY EVENT: row %d col %d.\n",
		    frow, event->col);
d872 2
a873 4
		/*
		 * We need to skip the current RU entirely because it got
		 * recon'd while we were waiting for something else to happen.
		 */
d875 1
a875 2
		DDprintf2("RECON: SKIP EVENT: row %d col %d.\n",
		    frow, event->col);
d879 2
a880 4
		/*
		 * A forced-reconstruction read access has completed. Just
		 * submit the buffer.
		 */
d884 1
a884 2
		DDprintf2("RECON: FORCEDREADDONE EVENT: row %d col %d.\n",
		    frow, event->col);
d898 3
a900 3
 * Find the next thing that's needed on the indicated disk, and issue
 * a read request for it. We assume that the reconstruction buffer
 * associated with this process is free to receive the data. If
d908 1
a908 1
 * we're currently accessing. Note that this deviates from the
d910 1
a910 1
 * accessed. This allows us to easily retry when we're blocked by
d913 2
a914 2
 * Returns nonzero if and only if there is nothing left unread on the
 * indicated disk.
d917 5
a921 2
int
rf_IssueNextReadRequest(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
d923 1
a923 2
	RF_PerDiskReconCtrl_t *ctrl =
	    &raidPtr->reconControl[row]->perDiskInfo[col];
d926 7
a932 12
	RF_ReconUnitCount_t RUsPerPU =
	    layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;
	RF_SectorCount_t sectorsPerRU =
	    layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;
	int do_new_check = 0, retcode = 0, status;

	/*
	 * If we are currently the slowest disk, mark that we have to do a new
	 * check.
	 */
	if (ctrl->headSepCounter <=
	    raidPtr->reconControl[row]->minHeadSepCounter)
d946 3
a948 5
			if (ctrl->curPSID >=
			    raidPtr->reconControl[row]->lastPSID) {
				rf_CheckForNewMinHeadSep(raidPtr, row,
				    ++(ctrl->headSepCounter));
				return (1);	/* Finito ! */
d950 1
a950 2
			/*
			 * Find the disk offsets of the start of the parity
d952 4
a955 7
			 * disk. Skip this entire parity stripe if either disk
			 * does not appear in the indicated PS.
			 */
			status = rf_ComputePSDiskOffsets(raidPtr,
			    ctrl->curPSID, row, col, &ctrl->diskOffset,
			    &rbuf->failedDiskSectorOffset, &rbuf->spRow,
			    &rbuf->spCol, &rbuf->spOffset);
d963 3
a965 5
		/* Skip this RU if it's already been reconstructed. */
		if (rf_CheckRUReconstructed(raidPtr->reconControl[row]
		    ->reconMap, rbuf->failedDiskSectorOffset)) {
			Dprintf2("Skipping psid %ld ru %d: already"
			    " reconstructed.\n", ctrl->curPSID, ctrl->ru_count);
d971 2
a972 2
	if (do_new_check)	/* Update min if needed. */
		rf_CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);
d975 2
a976 4
	/*
	 * At this point, we have definitely decided what to do, and we have
	 * only to see if we can actually do it now.
	 */
d979 1
a979 2
	bzero((char *) &raidPtr->recon_tracerecs[col],
	    sizeof(raidPtr->recon_tracerecs[col]));
d987 1
a987 1
 * Tries to issue the next read on the indicated disk. We may be
d989 1
a989 1
 * indicated RU being blocked due to a write by a user thread. In
d992 1
a992 1
 * has cleared.
d995 5
a999 2
int
rf_TryToRead(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col)
d1001 2
a1002 4
	RF_PerDiskReconCtrl_t *ctrl =
	    &raidPtr->reconControl[row]->perDiskInfo[col];
	RF_SectorCount_t sectorsPerRU =
	    raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;
d1006 1
a1006 1
	int status, created = 0;
d1009 3
a1011 6
	/*
	 * If the current disk is too far ahead of the others, issue a
	 * head-separation wait and return.
	 */
	if (rf_CheckHeadSeparation(raidPtr, ctrl, row, col,
	    ctrl->headSepCounter, which_ru))
d1014 1
a1014 2
	pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]
	    ->pssTable, psid, which_ru, RF_PSS_CREATE, &created);
d1016 4
a1019 7
	/*
	 * If recon is blocked on the indicated parity stripe, issue a
	 * block-wait request and return. This also must mark the indicated RU
	 * in the stripe as under reconstruction if not blocked.
	 */
	status = rf_CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl,
	    row, col, psid, which_ru);
d1021 1
a1021 2
		Dprintf2("RECON: Stalling psid %ld ru %d: recon blocked.\n",
		    psid, which_ru);
d1025 1
a1025 2
			rf_CauseReconEvent(raidPtr, row, col, NULL,
			    RF_REVENT_SKIP);
d1028 1
a1028 2
	/*
	 * Make one last check to be sure that the indicated RU didn't get
d1031 1
a1031 1
	 * in the normal case. Might want to make some attempt to re-work
d1033 4
a1036 7
	 * one of the above checks. When this condition is detected, we may
	 * have just created a bogus status entry, which we need to delete.
	 */
	if (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap,
	    ctrl->rbuf->failedDiskSectorOffset)) {
		Dprintf2("RECON: Skipping psid %ld ru %d: prior recon after"
		    " stall.\n", psid, which_ru);
d1038 1
a1038 2
			rf_PSStatusDelete(raidPtr,
			    raidPtr->reconControl[row]->pssTable, pssPtr);
d1042 3
a1044 4
	/* Found something to read. Issue the I/O. */
	Dprintf5("RECON: Read for psid %ld on row %d col %d offset %ld"
	    " buf %lx.\n", psid, row, col, ctrl->diskOffset,
	    ctrl->rbuf->buffer);
d1051 4
a1054 8
	/*
	 * Should be ok to use a NULL proc pointer here, all the bufs we use
	 * should be in kernel space.
	 */
	req = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset,
	    sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,
	    rf_ReconReadDoneProc, (void *) ctrl, NULL,
	    &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);
d1056 1
a1056 1
	RF_ASSERT(req);		/* XXX -- Fix this. -- XXX */
d1069 3
a1071 3
 * Given a parity stripe ID, we want to find out whether both the
 * current disk and the failed disk exist in that parity stripe. If
 * not, we want to skip this whole PS. If so, we want to find the
d1075 1
a1075 1
 * This works by getting a list of disks comprising the indicated
d1077 1
a1077 1
 * disks. Once we've decided they both exist in the parity stripe, we
d1082 1
a1082 1
 * This is kind of unpleasant, but doing it this way allows the
d1086 1
a1086 1
 * reverse-mapping function. I also think it will execute faster,
d1090 1
a1090 2
 * THE STRIPE IN THE CORRECT ORDER.
 */
d1092 1
a1092 1
int
d1094 11
a1104 20
    RF_Raid_t		*raidPtr,	/* RAID descriptor. */
    RF_StripeNum_t	 psid,		/* Parity stripe identifier. */
    RF_RowCol_t		 row,		/*
					 * Row and column of disk to find
					 * the offsets for.
					 */
    RF_RowCol_t		 col,
    RF_SectorNum_t	*outDiskOffset,
    RF_SectorNum_t	*outFailedDiskSectorOffset,
    RF_RowCol_t		*spRow,		/*
					 * OUT: Row,col of spare unit for
					 * failed unit.
					 */
    RF_RowCol_t		*spCol,
    RF_SectorNum_t	*spOffset	/*
					 * OUT: Offset into disk containing
					 * spare unit.
					 */
)
{
d1109 1
a1109 1
	u_int i, j, k, i_offset, j_offset;
d1111 1
a1111 1
	int testcol, testrow;
d1114 2
a1115 3
	char i_is_parity = 0, j_is_parity = 0;
	RF_RowCol_t stripeWidth =
	    layoutPtr->numDataCol + layoutPtr->numParityCol;
d1117 1
a1117 1
	/* Get a listing of the disks comprising that stripe. */
d1119 1
a1119 2
	(layoutPtr->map->IdentifyStripe) (raidPtr, sosRaidAddress, &diskids,
	    &stripe);
d1122 2
a1123 4
	/*
	 * Reject this entire parity stripe if it does not contain the
	 * indicated disk or it does not contain the failed disk.
	 */
d1139 6
a1144 9
	/* Find out which disk the parity is on. */
	(layoutPtr->map->MapParity) (raidPtr, sosRaidAddress, &prow, &pcol,
	    &poffset, RF_DONT_REMAP);

	/* Find out if either the current RU or the failed RU is parity. */
	/*
	 * Also, if the parity occurs in this stripe prior to the data and/or
	 * failed col, we need to decrement i and/or j.
	 */
d1157 2
a1158 4
		}		/*
				 * Set offsets to zero to disable multiply
				 * below.
				 */
d1166 1
a1166 2
	/*
	 * At this point, [ij]_is_parity tells us whether the [current,failed]
d1168 1
a1168 2
	 * tells us how far into the stripe the [current,failed] disk is.
	 */
d1170 2
a1171 4
	/*
	 * Call the mapping routine to get the offset into the current disk,
	 * repeat for failed disk.
	 */
d1173 1
a1173 3
		layoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outDiskOffset, RF_DONT_REMAP);
d1175 1
a1175 3
		layoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outDiskOffset, RF_DONT_REMAP);
d1180 1
a1180 3
		layoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outFailedDiskSectorOffset, RF_DONT_REMAP);
d1182 1
a1182 3
		layoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset *
		    layoutPtr->sectorsPerStripeUnit, &testrow, &testcol,
		    outFailedDiskSectorOffset, RF_DONT_REMAP);
d1185 1
a1185 1
	/* Now locate the spare unit for the failed unit. */
d1188 1
a1188 3
			layoutPtr->map->MapParity(raidPtr, sosRaidAddress +
			    j_offset * layoutPtr->sectorsPerStripeUnit, spRow,
			    spCol, spOffset, RF_REMAP);
d1190 1
a1190 3
			layoutPtr->map->MapSector(raidPtr, sosRaidAddress +
			    j_offset * layoutPtr->sectorsPerStripeUnit, spRow,
			    spCol, spOffset, RF_REMAP);
d1200 1
a1200 1
	Dprintf3("RECON: Skipping psid %ld: nothing needed from r%d c%d.\n",
d1204 5
a1208 8


/*
 * This is called when a buffer has become ready to write to the replacement
 * disk.
 */
int
rf_IssueNextWriteRequest(RF_Raid_t *raidPtr, RF_RowCol_t row)
d1211 1
a1211 2
	RF_SectorCount_t sectorsPerRU =
	    layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;
d1217 2
a1218 4
	RF_ASSERT(rbuf);	/*
				 * There must be one available, or we wouldn't
				 * have gotten the event that sent us here.
				 */
d1224 1
a1224 2
	Dprintf7("RECON: New write (r %d c %d offs %d) for psid %ld ru %d"
	    " (failed disk offset %ld) buf %lx.\n",
d1227 6
a1232 9
	Dprintf6("RECON: new write psid %ld   %02x %02x %02x %02x %02x.\n",
	    rbuf->parityStripeID, rbuf->buffer[0] & 0xff,
	    rbuf->buffer[1] & 0xff, rbuf->buffer[2] & 0xff,
	    rbuf->buffer[3] & 0xff, rbuf->buffer[4] & 0xff);

	/*
	 * Should be ok to use a NULL b_proc here b/c all addrs should be in
	 * kernel space.
	 */
d1234 2
a1235 1
	    sectorsPerRU, rbuf->buffer, rbuf->parityStripeID, rbuf->which_ru,
d1237 2
a1238 1
	    &raidPtr->recon_tracerecs[fcol], (void *) raidPtr, 0, NULL);
d1240 1
a1240 1
	RF_ASSERT(req);		/* XXX -- Fix this. -- XXX */
d1243 1
a1243 2
	rf_DiskIOEnqueue(&raidPtr->Queues[rbuf->spRow][rbuf->spCol], req,
	    RF_IO_RECON_PRIORITY);
d1249 2
a1250 2
 * This gets called upon the completion of a reconstruction read
 * operation. The arg is a pointer to the per-disk reconstruction
d1253 2
a1254 2
 * Called at interrupt context in the kernel, so don't do anything
 * illegal here.
d1256 4
a1259 2
int
rf_ReconReadDoneProc(void *arg, int status)
d1266 3
a1268 3
		 * XXX
		 */
		printf("Recon read failed !\n");
d1273 2
a1274 3
	raidPtr->recon_tracerecs[ctrl->col].specific.recon.
	   recon_fetch_to_return_us =
	     RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[ctrl->col].recon_timer);
d1277 1
a1277 2
	rf_CauseReconEvent(raidPtr, ctrl->row, ctrl->col, NULL,
	    RF_REVENT_READDONE);
d1280 2
a1281 5


/*
 * This gets called upon the completion of a reconstruction write operation.
 * The arg is a pointer to the rbuf that was just written.
d1283 1
a1283 1
 * Called at interrupt context in the kernel, so don't do anything illegal here.
d1285 4
a1288 2
int
rf_ReconWriteDoneProc(void *arg, int status)
d1292 1
a1292 2
	Dprintf2("Reconstruction completed on psid %ld ru %d.\n",
	    rbuf->parityStripeID, rbuf->which_ru);
d1294 2
a1295 2
		/* fprintf(stderr, "Recon write failed !\n"); */
		printf("Recon write failed !\n");
d1298 1
a1298 2
	rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col,
	    arg, RF_REVENT_WRITEDONE);
d1303 3
a1305 3
/*
 * Computes a new minimum head sep, and wakes up anyone who needs to
 * be woken as a result.
d1307 5
a1311 3
void
rf_CheckForNewMinHeadSep(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_HeadSepLimit_t hsCtr)
d1317 2
a1318 2
	/* From the definition of a minimum. */
	RF_ASSERT(hsCtr >= reconCtrlPtr->minHeadSepCounter);
d1326 2
a1327 4
			if (reconCtrlPtr->perDiskInfo[i].headSepCounter <
			    new_min)
				new_min =
				    reconCtrlPtr->perDiskInfo[i].headSepCounter;
d1329 1
a1329 1
	/* Set the new minimum and wake up anyone who can now run again. */
d1332 1
a1332 2
		Dprintf1("RECON:  new min head pos counter val is %ld.\n",
		    new_min);
d1334 1
a1334 2
			if (reconCtrlPtr->headSepCBList->callbackArg.v >
			    new_min)
d1339 1
a1339 2
			rf_CauseReconEvent(raidPtr, p->row, p->col, NULL,
			    RF_REVENT_HEADSEPCLEAR);
d1348 1
a1348 1
 * Checks to see that the maximum head separation will not be violated
d1356 2
a1357 2
 * Returns non-zero if and only if we have to stop working on the
 * indicated disk due to a head-separation delay.
d1359 1
a1359 1
int
d1361 6
a1366 7
    RF_Raid_t			*raidPtr,
    RF_PerDiskReconCtrl_t	*ctrl,
    RF_RowCol_t			 row,
    RF_RowCol_t			 col,
    RF_HeadSepLimit_t		 hsCtr,
    RF_ReconUnitNum_t		 which_ru
)
d1370 1
a1370 1
	int retval = 0;
d1372 2
a1373 3
	/*
	 * If we're too far ahead of the slowest disk, stop working on this
	 * disk until the slower ones catch up. We do this by scheduling a
d1378 1
d1382 5
a1386 6
	    ((ctrl->headSepCounter - reconCtrlPtr->minHeadSepCounter) >
	     raidPtr->headSepLimit)) {
		Dprintf6("raid%d: RECON: head sep stall: row %d col %d hsCtr"
		    " %ld minHSCtr %ld limit %ld.\n",
		    raidPtr->raidid, row, col, ctrl->headSepCounter,
		    reconCtrlPtr->minHeadSepCounter, raidPtr->headSepLimit);
d1388 3
a1390 6
		/*
		 * The minHeadSepCounter value we have to get to before we'll
		 * wake up. Build in 20% hysteresis.
		 */
		cb->callbackArg.v = (ctrl->headSepCounter -
		    raidPtr->headSepLimit + raidPtr->headSepLimit / 5);
d1395 2
a1396 4
		/*
		 * Insert this callback descriptor into the sorted list of
		 * pending head-sep callbacks.
		 */
d1405 1
a1405 3
				for (pt = p, p = p->next;
				    p && (p->callbackArg.v < cb->callbackArg.v);
				    pt = p, p = p->next);
d1410 1
a1410 1
#if	RF_RECON_STATS > 0
d1412 1
a1412 1
#endif	/* RF_RECON_STATS > 0 */
d1418 4
a1421 7



/*
 * Checks to see if reconstruction has been either forced or blocked
 * by a user operation. If forced, we skip this RU entirely. Else if
 * blocked, put ourselves on the wait list. Else return 0.
d1423 1
a1423 1
 * ASSUMES THE PSS MUTEX IS LOCKED UPON ENTRY.
d1425 1
a1425 1
int
d1427 7
a1433 8
    RF_Raid_t			 *raidPtr,
    RF_ReconParityStripeStatus_t *pssPtr,
    RF_PerDiskReconCtrl_t	 *ctrl,
    RF_RowCol_t			  row,
    RF_RowCol_t			  col,
    RF_StripeNum_t		  psid,
    RF_ReconUnitNum_t		  which_ru
)
d1436 1
a1436 1
	int retcode = 0;
d1438 1
a1438 2
	if ((pssPtr->flags & RF_PSS_FORCED_ON_READ) ||
	    (pssPtr->flags & RF_PSS_FORCED_ON_WRITE))
d1442 2
a1443 4
			Dprintf4("RECON: row %d col %d blocked at psid %ld"
			    " ru %d.\n", row, col, psid, which_ru);
			cb = rf_AllocCallbackDesc();	/*
							 * Append ourselves to
d1445 1
a1445 2
							 * list.
							 */
d1453 2
a1454 4
		pssPtr->flags |= RF_PSS_UNDER_RECON;	/*
							 * Mark this RU as under
							 * reconstruction.
							 */
a1457 2


d1459 1
a1459 1
 * If reconstruction is currently ongoing for the indicated stripeID,
d1461 2
a1462 2
 * indicate that the caller must wait. If not, then reconstruction is
 * blocked on the indicated stripe and the routine returns zero. If
d1464 1
a1464 1
 * invoked with the cbArg when the reconstruction has completed.
d1466 17
a1482 23
int
rf_ForceOrBlockRecon(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap,
	void (*cbFunc) (RF_Raid_t *, void *), void *cbArg)
{
	RF_RowCol_t row = asmap->physInfo->row;	/*
						 * Which row of the array
						 * we're working on.
						 */
	RF_StripeNum_t stripeID = asmap->stripeID;	/*
							 * The stripe ID we're
							 * forcing recon on.
							 */
	RF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit *
	    raidPtr->Layout.SUsPerRU;		/* Num sects in one RU. */
	RF_ReconParityStripeStatus_t *pssPtr;	/*
						 * A pointer to the parity
						 * stripe status structure.
						 */
	RF_StripeNum_t psid;			/* Parity stripe id. */
	RF_SectorNum_t offset, fd_offset;	/*
						 * Disk offset, failed-disk
						 * offset.
						 */
d1485 1
a1485 1
	RF_ReconUnitNum_t which_ru;	/* RU within parity stripe. */
d1487 2
a1488 2
	RF_ReconBuffer_t *new_rbuf;	/* Ptr to newly allocated rbufs. */
	RF_DiskQueueData_t *req;	/* Disk I/O req to be enqueued. */
d1490 1
a1490 1
	int created = 0, nPromoted;
d1492 1
a1492 2
	psid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID,
	    &which_ru);
d1496 1
a1496 3
	pssPtr = rf_LookupRUStatus(raidPtr,
	    raidPtr->reconControl[row]->pssTable, psid, which_ru,
	    RF_PSS_CREATE | RF_PSS_RECON_BLOCKED, &created);
d1498 1
a1498 1
	/* If recon is not ongoing on this PS, just return. */
d1503 3
a1505 6
	/*
	 * Otherwise, we have to wait for reconstruction to complete on this
	 * RU.
	 */
	/*
	 * In order to avoid waiting for a potentially large number of
d1507 7
a1513 9
	 * not low-priority) reconstruction on this RU.
	 */
	if (!(pssPtr->flags & RF_PSS_FORCED_ON_WRITE) &&
	    !(pssPtr->flags & RF_PSS_FORCED_ON_READ)) {
		DDprintf1("Forcing recon on psid %ld.\n", psid);
		/* Mark this RU as under forced recon. */
		pssPtr->flags |= RF_PSS_FORCED_ON_WRITE;
		/* Clear the blockage that we just set. */
		pssPtr->flags &= ~RF_PSS_RECON_BLOCKED;
d1516 2
a1517 5
		/*
		 * Get a listing of the disks comprising the indicated stripe.
		 */
		(raidPtr->Layout.map->IdentifyStripe) (raidPtr,
		    asmap->raidAddress, &diskids, &stripe);
d1520 2
a1521 3
		/*
		 * For previously issued reads, elevate them to normal
		 * priority. If the I/O has already completed, it won't be
d1523 1
a1523 1
		 * unissued reads, allocate buffers and issue new reads. The
d1525 2
a1526 4
		 * recon procs will not re-issue these reqs.
		 */
		for (i = 0; i < raidPtr->Layout.numDataCol +
		    raidPtr->Layout.numParityCol; i++)
d1529 1
a1529 3
					nPromoted = rf_DiskIOPromote(&raidPtr
					    ->Queues[row][diskno], psid,
					    which_ru);
d1531 1
a1531 4
						printf("raid%d: promoted read"
						    " from row %d col %d.\n",
						    raidPtr->raidid, row,
						    diskno);
d1533 5
a1537 10
					/* Create new buf. */
					new_rbuf = rf_MakeReconBuffer(raidPtr,
					    row, diskno, RF_RBUF_TYPE_FORCED);
					/* Find offsets & spare locationp */
					rf_ComputePSDiskOffsets(raidPtr, psid,
					    row, diskno, &offset, &fd_offset,
					    &new_rbuf->spRow, &new_rbuf->spCol,
					    &new_rbuf->spOffset);
					new_rbuf->parityStripeID = psid;
					/* Fill in the buffer. */
d1539 7
a1545 17
					new_rbuf->failedDiskSectorOffset =
					    fd_offset;
					new_rbuf->priority =
					    RF_IO_NORMAL_PRIORITY;

					/*
					 * Use NULL b_proc b/c all addrs
					 * should be in kernel space.
					 */
					req = rf_CreateDiskQueueData(
					    RF_IO_TYPE_READ, offset +
					    which_ru * sectorsPerRU,
					    sectorsPerRU, new_rbuf->buffer,
					    psid, which_ru, (int (*)
					    (void *, int))
					      rf_ForceReconReadDoneProc,
					    (void *) new_rbuf, NULL,
d1548 2
a1549 4
					RF_ASSERT(req);	/*
							 * XXX -- Fix this. --
							 * XXX
							 */
d1552 2
a1553 7
					/* Enqueue the I/O. */
					rf_DiskIOEnqueue(&raidPtr
					    ->Queues[row][diskno], req,
					    RF_IO_NORMAL_PRIORITY);
					Dprintf3("raid%d: Issued new read req"
					    " on row %d col %d.\n",
					    raidPtr->raidid, row, diskno);
d1556 8
a1563 13
		/*
		 * If the write is sitting in the disk queue, elevate its
		 * priority.
		 */
		if (rf_DiskIOPromote(&raidPtr->Queues[row][fcol],
		    psid, which_ru))
			printf("raid%d: promoted write to row %d col %d.\n",
			    raidPtr->raidid, row, fcol);
	}
	/*
	 * Install a callback descriptor to be invoked when recon completes on
	 * this parity stripe.
	 */
d1565 2
a1566 4
	/*
	 * XXX The following is bogus... These functions don't really match !!!
	 * GO
	 */
d1571 2
a1572 2
	DDprintf2("raid%d: Waiting for forced recon on psid %ld.\n",
	    raidPtr->raidid, psid);
d1577 3
a1579 6


/*
 * Called upon the completion of a forced reconstruction read.
 * All we do is schedule the FORCEDREADONE event.
 * Called at interrupt context in the kernel, so don't do anything illegal here.
d1581 4
a1584 2
void
rf_ForceReconReadDoneProc(void *arg, int status)
d1589 3
a1591 2
		/* fprintf(stderr, "Forced recon read failed !\n"); */
		printf("Forced recon read failed !\n");
d1594 1
a1594 2
	rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col,
	    (void *) rbuf, RF_REVENT_FORCEDREADDONE);
d1596 5
a1600 5


/* Releases a block on the reconstruction of the indicated stripe. */
int
rf_UnblockRecon(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap)
d1607 1
a1607 1
	int created = 0;
d1610 1
a1610 2
	psid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID,
	    &which_ru);
d1612 1
a1612 2
	pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]
	    ->pssTable, psid, which_ru, RF_PSS_NONE, &created);
d1614 1
a1614 2
	/*
	 * When recon is forced, the pss desc can get deleted before we get
d1617 1
a1617 2
	 * how to decide if recon was just forced or not ?
	 */
d1619 2
a1620 4
		/*
		 * printf("Warning: no pss descriptor upon unblock on psid %ld"
		 *     " RU %d.\n", psid, which_ru);
		 */
d1622 1
a1622 2
			printf("Warning: no pss descriptor upon unblock on"
			    " psid %ld RU %d.\n", (long) psid, which_ru);
d1626 3
a1628 4
	Dprintf3("raid%d: unblocking recon on psid %ld: blockcount is %d.\n",
	    raidPtr->raidid, psid, pssPtr->blockCount);
	if (pssPtr->blockCount == 0) {
		/* If recon blockage has been released. */
d1630 1
a1630 2
		/*
		 * Unblock recon before calling CauseReconEvent in case
d1632 1
a1632 2
		 * returning here.
		 */
d1636 3
a1638 5
		while (pssPtr->blockWaitList) {
			/*
			 * Spin through the block-wait list and
			 * release all the waiters.
			 */
d1642 1
a1642 2
			rf_CauseReconEvent(raidPtr, cb->row, cb->col, NULL,
			    RF_REVENT_BLOCKCLEAR);
d1646 2
a1647 3
			/* If no recon was requested while recon was blocked. */
			rf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]
			    ->pssTable, pssPtr);
@


1.8.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d508 1
a508 1
			    " occurring !\n", row, col);
@


1.7
log
@remove 'INTEGRATE' macro that did static __inline__ in advance of doing
more work on the whole code base
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconstruct.c,v 1.6 2000/01/07 14:50:22 peter Exp $	*/
/*	$NetBSD: rf_reconstruct.c,v 1.9 2000/01/05 02:57:29 oster Exp $	*/
a54 1
#include "rf_threadid.h"
a63 1
#include "rf_cpuutil.h"
a77 1
#define Dprintf8(s,a,b,c,d,e,f,g,h) if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),(void *)((unsigned long)g),(void *)((unsigned long)h))
a80 11
#define DDprintf3(s,a,b,c)     if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),NULL,NULL,NULL,NULL,NULL)
#define DDprintf4(s,a,b,c,d)   if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),NULL,NULL,NULL,NULL)
#define DDprintf5(s,a,b,c,d,e) if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),NULL,NULL,NULL)
#define DDprintf6(s,a,b,c,d,e,f) if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),NULL,NULL)
#define DDprintf7(s,a,b,c,d,e,f,g) if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),(void *)((unsigned long)g),NULL)
#define DDprintf8(s,a,b,c,d,e,f,g,h) if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),(void *)((unsigned long)g),(void *)((unsigned long)h))

#if 0
static RF_Thread_t recon_thr_handle;
static int recon_thread_initialized = 0;
#endif
a106 5
/* XXX these should be in a .h file somewhere */
int raidlookup __P((char *, struct proc *, struct vnode **));
int raidwrite_component_label(dev_t, struct vnode *, RF_ComponentLabel_t *);
int raidread_component_label(dev_t, struct vnode *, RF_ComponentLabel_t *);

d151 1
a151 1
/*****************************************************************************************
d159 1
a159 1
 ****************************************************************************************/
a190 6
#if 0
	if (!recon_thread_initialized) {
		RF_CREATE_THREAD(recon_thr_handle, rf_ReconKernelThread, NULL, "raid_recon");
		recon_thread_initialized = 1;
	}
#endif
d653 1
a653 1
		rf_start_cpu_monitor();
a717 2
		rf_stop_cpu_monitor();

d760 1
a760 1
		rf_print_cpu_util("reconstruction");
d774 1
a774 1
/*****************************************************************************************
d776 3
a778 2
 * returns nonzero if and only if there is nothing left unread on the indicated disk
 ****************************************************************************************/
d889 16
a904 1
/*****************************************************************************************
d906 2
a907 12
 * find the next thing that's needed on the indicated disk, and issue a read
 * request for it.  We assume that the reconstruction buffer associated with this
 * process is free to receive the data.  If reconstruction is blocked on the
 * indicated RU, we issue a blockage-release request instead of a physical disk
 * read request.  If the current disk gets too far ahead of the others, we issue
 * a head-separation wait request and return.
 *
 * ctrl->{ru_count, curPSID, diskOffset} and rbuf->failedDiskSectorOffset are
 * maintained to point the the unit we're currently accessing.  Note that this deviates
 * from the standard C idiom of having counters point to the next thing to be
 * accessed.  This allows us to easily retry when we're blocked by head separation
 * or reconstruction-blockage events.
d909 1
a909 2
 * returns nonzero if and only if there is nothing left unread on the indicated disk
 ****************************************************************************************/
d978 8
a985 4
/* tries to issue the next read on the indicated disk.  We may be blocked by (a) the heads being too
 * far apart, or (b) recon on the indicated RU being blocked due to a write by a user thread.
 * In this case, we issue a head-sep or blockage wait request, which will cause this same routine
 * to be invoked again later when the blockage has cleared.
d987 1
d1061 12
a1072 9
/* given a parity stripe ID, we want to find out whether both the current disk and the
 * failed disk exist in that parity stripe.  If not, we want to skip this whole PS.
 * If so, we want to find the disk offset of the start of the PS on both the current
 * disk and the failed disk.
 *
 * this works by getting a list of disks comprising the indicated parity stripe, and
 * searching the list for the current and failed disks.  Once we've decided they both
 * exist in the parity stripe, we need to decide whether each is data or parity,
 * so that we'll know which mapping function to call to get the corresponding disk
d1075 6
a1080 5
 * this is kind of unpleasant, but doing it this way allows the reconstruction code
 * to use parity stripe IDs rather than physical disks address to march through the
 * failed disk, which greatly simplifies a lot of code, as well as eliminating the
 * need for a reverse-mapping function.  I also think it will execute faster, since
 * the calls to the mapping module are kept to a minimum.
d1082 3
a1084 3
 * ASSUMES THAT THE STRIPE IDENTIFIER IDENTIFIES THE DISKS COMPRISING THE STRIPE
 * IN THE CORRECT ORDER
 */
d1240 5
a1244 3
/* this gets called upon the completion of a reconstruction read operation
 * the arg is a pointer to the per-disk reconstruction control structure
 * for the process that just finished a read.
d1246 2
a1247 1
 * called at interrupt context in the kernel, so don't do anything illegal here.
d1296 4
a1299 1
/* computes a new minimum head sep, and wakes up anyone who needs to be woken as a result */
d1339 9
a1347 7
/* checks to see that the maximum head separation will not be violated
 * if we initiate a reconstruction I/O on the indicated disk.  Limiting the
 * maximum head separation between two disks eliminates the nasty buffer-stall
 * conditions that occur when one disk races ahead of the others and consumes
 * all of the floating recon buffers.  This code is complex and unpleasant
 * but it's necessary to avoid some very nasty, albeit fairly rare,
 * reconstruction behavior.
d1349 2
a1350 2
 * returns non-zero if and only if we have to stop working on the indicated disk
 * due to a head-separation delay.
d1363 1
a1363 1
	int     retval = 0, tid;
a1372 1
	rf_get_threadid(tid);
d1376 4
a1379 2
		Dprintf6("[%d] RECON: head sep stall: row %d col %d hsCtr %ld minHSCtr %ld limit %ld\n",
		    tid, row, col, ctrl->headSepCounter, reconCtrlPtr->minHeadSepCounter, raidPtr->headSepLimit);
d1411 4
a1414 4
/* checks to see if reconstruction has been either forced or blocked by a user operation.
 * if forced, we skip this RU entirely.
 * else if blocked, put ourselves on the wait list.
 * else return 0.
d1451 7
a1457 5
/* if reconstruction is currently ongoing for the indicated stripeID, reconstruction
 * is forced to completion and we return non-zero to indicate that the caller must
 * wait.  If not, then reconstruction is blocked on the indicated stripe and the
 * routine returns zero.  If and only if we return non-zero, we'll cause the cbFunc
 * to get invoked with the cbArg when the reconstruction has completed.
a1477 1
	int     tid;
a1484 1
	rf_get_threadid(tid);
d1524 1
a1524 1
						printf("[%d] promoted read from row %d col %d\n", tid, row, diskno);
d1546 1
a1546 1
					Dprintf3("[%d] Issued new read req on row %d col %d\n", tid, row, diskno);
d1552 2
a1553 1
			printf("[%d] promoted write to row %d col %d\n", tid, row, fcol);
d1564 2
a1565 1
	DDprintf2("[%d] Waiting for forced recon on psid %ld\n", tid, psid);
d1600 1
a1600 1
	int     tid, created = 0;
a1602 1
	rf_get_threadid(tid);
d1619 2
a1620 1
	Dprintf3("[%d] unblocking recon on psid %ld: blockcount is %d\n", tid, psid, pssPtr->blockCount);
d1629 3
a1631 3
		while (pssPtr->blockWaitList) {	/* spin through the block-wait
						 * list and release all the
						 * waiters */
d1638 2
a1639 3
		if (!(pssPtr->flags & RF_PSS_UNDER_RECON)) {	/* if no recon was
								 * requested while recon
								 * was blocked */
@


1.6
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.5 1999/08/04 13:10:55 peter Exp $	*/
a69 6
#if defined(__GNUC__) && !defined(DDB)
#define INTEGRATE static __inline__
#else
#define INTEGRATE
#endif

d116 4
a119 4
INTEGRATE void rf_FreeReconDesc __P((RF_RaidReconDesc_t *));
INTEGRATE int rf_IssueNextWriteRequest __P((RF_Raid_t *, RF_RowCol_t));
INTEGRATE int rf_CheckForcedOrBlockedReconstruction __P((RF_Raid_t *, RF_ReconParityStripeStatus_t *, RF_PerDiskReconCtrl_t *, RF_RowCol_t, RF_RowCol_t, RF_StripeNum_t, RF_ReconUnitNum_t));
INTEGRATE void rf_SignalReconDone __P((RF_Raid_t *));
d136 1
a136 1
INTEGRATE void 
d247 1
a247 1
INTEGRATE void 
d1211 1
a1211 1
INTEGRATE int 
d1422 1
a1422 1
INTEGRATE int 
@


1.5
log
@* remove redundant rf_ccmn.h

* remove init call to rf_ConfigureEtimer() and rf_sys.c in which it is the
  only function. update conf/files to reflect this.

* update sources to make sure _KERNEL is used not KERNEL

* change rf_etimer.h to protect macros an include of sys/kernel.h with
  a check for _KERNEL - let raidctl compile again.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconstruct.c,v 1.4 1999/08/03 13:56:37 peter Exp $	*/
/*	$NetBSD: rf_reconstruct.c,v 1.5 1999/03/02 03:18:49 oster Exp $	*/
a66 1
#include "rf_sys.h"
d97 1
d100 1
d216 1
d218 1
a218 1
		RF_CREATE_THREAD(recon_thr_handle, rf_ReconKernelThread, NULL);
d221 1
d262 1
a262 1
	printf("RAIDframe: %qu max exec uSec\n", reconDesc->maxReconExecuSecs);
d300 3
a307 3
	RF_LOCK_MUTEX(raidPtr->mutex);
	raidPtr->reconInProgress--;
	RF_UNLOCK_MUTEX(raidPtr->mutex);
d367 2
a368 2
	reconDesc->reconExecuSecs = 0;
	reconDesc->maxReconExecuSecs = 0;
d465 2
d481 1
d493 1
a493 1
		proc = raidPtr->proc;	/* XXX Yes, this is not nice.. */
d518 2
a519 2
			   must be
			   * still dead :-( */
d530 1
d537 1
a569 2
		raidPtr->reconInProgress++;

d582 2
a583 2
		reconDesc->reconExecuSecs = 0;
		reconDesc->maxReconExecuSecs = 0;
d585 5
a595 1
	raidPtr->reconInProgress--;
@


1.4
log
@* rf_reconstruct.c: adopt nilkas' suggestion regard statics and
__inline__ - this is a proof of concept and will cover the raidframe
source as a whole over coming updates. Update namespace of function to
prefix with rf_ - comments again welcome.

* overall: rework the macros in rf_etimer.h and the resultant changes
to their use to count microseconds and not clock ticks. Restore the code
in rf_revent.c to a similar strcuture to before the previous commit,
and use the system timers to govern resource usage.

Tested with local i386/IDE and the reconstruction of a disk in my
array - performance has improved for reconstruction at no noticable
CPU cost.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.3 1999/07/30 14:45:33 peter Exp $	*/
d261 1
a261 1
#if (RF_RECON_STATS > 0) || defined(KERNEL)
d263 1
a263 1
#endif /* (RF_RECON_STATS > 0) || KERNEL */
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.c,v 1.2 1999/02/16 00:03:22 niklas Exp $	*/
d71 6
d105 11
a115 33
static RF_RaidReconDesc_t *
AllocRaidReconDesc(RF_Raid_t * raidPtr,
    RF_RowCol_t row, RF_RowCol_t col, RF_RaidDisk_t * spareDiskPtr,
    int numDisksDone, RF_RowCol_t srow, RF_RowCol_t scol);
static void FreeReconDesc(RF_RaidReconDesc_t * reconDesc);
static int 
ProcessReconEvent(RF_Raid_t * raidPtr, RF_RowCol_t frow,
    RF_ReconEvent_t * event);
static int 
IssueNextReadRequest(RF_Raid_t * raidPtr, RF_RowCol_t row,
    RF_RowCol_t col);
static int TryToRead(RF_Raid_t * raidPtr, RF_RowCol_t row, RF_RowCol_t col);
static int 
ComputePSDiskOffsets(RF_Raid_t * raidPtr, RF_StripeNum_t psid,
    RF_RowCol_t row, RF_RowCol_t col, RF_SectorNum_t * outDiskOffset,
    RF_SectorNum_t * outFailedDiskSectorOffset, RF_RowCol_t * spRow,
    RF_RowCol_t * spCol, RF_SectorNum_t * spOffset);
static int IssueNextWriteRequest(RF_Raid_t * raidPtr, RF_RowCol_t row);
static int ReconReadDoneProc(void *arg, int status);
static int ReconWriteDoneProc(void *arg, int status);
static void 
CheckForNewMinHeadSep(RF_Raid_t * raidPtr, RF_RowCol_t row,
    RF_HeadSepLimit_t hsCtr);
static int 
CheckHeadSeparation(RF_Raid_t * raidPtr, RF_PerDiskReconCtrl_t * ctrl,
    RF_RowCol_t row, RF_RowCol_t col, RF_HeadSepLimit_t hsCtr,
    RF_ReconUnitNum_t which_ru);
static int 
CheckForcedOrBlockedReconstruction(RF_Raid_t * raidPtr,
    RF_ReconParityStripeStatus_t * pssPtr, RF_PerDiskReconCtrl_t * ctrl,
    RF_RowCol_t row, RF_RowCol_t col, RF_StripeNum_t psid,
    RF_ReconUnitNum_t which_ru);
static void ForceReconReadDoneProc(void *arg, int status);
d117 8
a124 1
static void rf_ShutdownReconstruction(void *);
d141 2
a142 2
static void 
SignalReconDone(RF_Raid_t * raidPtr)
d184 1
a184 1
static void 
d222 2
a223 2
static RF_RaidReconDesc_t *
AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)
d250 2
a251 2
static void 
FreeReconDesc(reconDesc)
d255 6
a260 5
	printf("RAIDframe: %lu recon event waits, %lu recon delays\n",
	    (long) reconDesc->numReconEventWaits, (long) reconDesc->numReconExecDelays);
#endif				/* RF_RECON_STATS > 0 */
	printf("RAIDframe: %lu max exec ticks\n",
	    (long) reconDesc->maxReconExecTicks);
d263 1
a263 1
#endif				/* (RF_RECON_STATS > 0) || KERNEL */
d268 1
a268 1
/*****************************************************************************************
d273 2
a274 1
 ****************************************************************************************/
d356 1
a356 1
	reconDesc = AllocRaidReconDesc((void *) raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol);
d364 2
a365 2
	reconDesc->reconExecTicks = 0;
	reconDesc->maxReconExecTicks = 0;
d493 1
a493 1
			printf("Closed the open device: %s\n",
d507 2
a508 1
			printf("raid%d: rebuilding: raidlookup on device: %s failed: %d!\n",raidPtr->raidid,
d566 1
a566 1
		reconDesc = AllocRaidReconDesc((void *) raidPtr, row, col, 
d576 2
a577 2
		reconDesc->reconExecTicks = 0;
		reconDesc->maxReconExecTicks = 0;
a638 2


a639 1

a654 1

a655 1

a656 1

d680 1
a680 1
				if (IssueNextReadRequest(raidPtr, row, i)) {
d687 2
a701 2


d707 1
a707 1
			if (ProcessReconEvent(raidPtr, row, event))
a714 2


a716 1

d730 1
a730 1
			(void) ProcessReconEvent(raidPtr, row, event);	/* ignore return code */
a745 2


a755 3



d790 1
a790 1
		FreeReconDesc(reconDesc);
d794 1
a794 1
	SignalReconDone(raidPtr);
d801 2
a802 2
static int 
ProcessReconEvent(raidPtr, frow, event)
d811 1
a811 1
	Dprintf1("RECON: ProcessReconEvent type %d\n", event->type);
d826 1
a826 1
			retcode = IssueNextReadRequest(raidPtr, frow, event->col);
d862 1
a862 1
		retcode = IssueNextReadRequest(raidPtr, frow, event->col);
d868 1
a868 1
		retcode = TryToRead(raidPtr, frow, event->col);
d875 1
a875 1
		retcode = TryToRead(raidPtr, frow, event->col);
d881 1
a881 1
		retcode = IssueNextWriteRequest(raidPtr, frow);
d891 1
a891 1
		retcode = IssueNextReadRequest(raidPtr, frow, event->col);
d928 2
a929 2
static int 
IssueNextReadRequest(raidPtr, row, col)
d958 1
a958 1
				CheckForNewMinHeadSep(raidPtr, row, ++(ctrl->headSepCounter));
d965 1
a965 1
			status = ComputePSDiskOffsets(raidPtr, ctrl->curPSID, row, col, &ctrl->diskOffset, &rbuf->failedDiskSectorOffset,
d983 1
a983 1
		CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);	/* update min if needed */
d993 1
a993 1
	retcode = TryToRead(raidPtr, row, col);
d1001 2
a1002 2
static int 
TryToRead(raidPtr, row, col)
d1017 1
a1017 1
	if (CheckHeadSeparation(raidPtr, ctrl, row, col, ctrl->headSepCounter, which_ru))
d1025 1
a1025 1
	status = CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl, row, col, psid, which_ru);
d1060 1
a1060 1
	    ReconReadDoneProc, (void *) ctrl, NULL, &raidPtr->recon_tracerecs[col], (void *) raidPtr, 0, NULL);
d1094 2
a1095 2
static int 
ComputePSDiskOffsets(
d1207 2
a1208 2
static int 
IssueNextWriteRequest(raidPtr, row)
d1238 1
a1238 1
	    ReconWriteDoneProc, (void *) rbuf, NULL,
d1255 2
a1256 2
static int 
ReconReadDoneProc(arg, status)
d1284 2
a1285 2
static int 
ReconWriteDoneProc(arg, status)
d1303 2
a1304 2
static void 
CheckForNewMinHeadSep(raidPtr, row, hsCtr)
d1353 2
a1354 2
static int 
CheckHeadSeparation(
d1418 2
a1419 2
static int 
CheckForcedOrBlockedReconstruction(
d1527 1
a1527 1
					ComputePSDiskOffsets(raidPtr, psid, row, diskno, &offset, &fd_offset,
d1538 1
a1538 1
					    psid, which_ru, (int (*) (void *, int)) ForceReconReadDoneProc, (void *) new_rbuf, NULL,
d1572 2
a1573 2
static void 
ForceReconReadDoneProc(arg, status)
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconstruct.c,v 1.1 1999/01/11 14:29:46 niklas Exp $	*/
/*	$NetBSD: rf_reconstruct.c,v 1.4 1999/02/05 00:06:16 oster Exp $	*/
d40 11
d135 4
d324 1
d374 250
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconstruct.c,v 1.1 1998/11/13 04:20:33 oster Exp $	*/
/*	$NetBSD: rf_reconstruct.c,v 1.1 1998/11/13 04:20:33 oster Exp $	*/
a35 183
/*
 * :  
 * Log: rf_reconstruct.c,v 
 * Revision 1.65  1996/08/06 22:24:56  jimz
 * get rid of sys/buf.h on linux
 *
 * Revision 1.64  1996/07/30  04:28:53  jimz
 * include rf_types.h first
 *
 * Revision 1.63  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.62  1996/07/17  21:00:58  jimz
 * clean up timer interface, tracing
 *
 * Revision 1.61  1996/07/15  05:40:41  jimz
 * some recon datastructure cleanup
 * better handling of multiple failures
 * added undocumented double-recon test
 *
 * Revision 1.60  1996/07/15  02:57:18  jimz
 * added debugging (peek at first couple bytes of recon buffers
 * as they go by)
 *
 * Revision 1.59  1996/07/13  00:00:59  jimz
 * sanitized generalized reconstruction architecture
 * cleaned up head sep, rbuf problems
 *
 * Revision 1.58  1996/07/11  19:08:00  jimz
 * generalize reconstruction mechanism
 * allow raid1 reconstructs via copyback (done with array
 * quiesced, not online, therefore not disk-directed)
 *
 * Revision 1.57  1996/06/17  14:38:33  jimz
 * properly #if out RF_DEMO code
 * fix bug in MakeConfig that was causing weird behavior
 * in configuration routines (config was not zeroed at start)
 * clean up genplot handling of stacks
 *
 * Revision 1.56  1996/06/17  03:24:59  jimz
 * include shutdown.h for define of now-macroized ShutdownCreate
 *
 * Revision 1.55  1996/06/11  10:58:36  jimz
 * get rid of simulator-testcode artifacts
 * add generic ReconDoneProc mechanism instead
 *
 * Revision 1.54  1996/06/10  14:18:58  jimz
 * move user, throughput stats into per-array structure
 *
 * Revision 1.53  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.52  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.51  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.50  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.49  1996/06/06  01:24:36  jimz
 * don't get rid of reconCtrlPtr until we're done with it
 *
 * Revision 1.48  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.47  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.46  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.45  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.44  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.43  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.42  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.41  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.40  1996/05/24  04:40:40  jimz
 * don't do demoMode stuff in kernel
 *
 * Revision 1.39  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.38  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.37  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.36  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.35  1996/05/01  16:28:16  jimz
 * don't include ccmn.h
 *
 * Revision 1.34  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.33  1995/12/06  15:05:09  root
 * added copyright info
 *
 * Revision 1.32  1995/11/17  19:04:11  wvcii
 * added prototyping to ComputePSDiskOffsets
 * prow and pcol now type int (were u_int)
 *
 * Revision 1.31  1995/11/17  01:39:35  amiri
 * isolated some demo related stuff
 *
 * Revision 1.30  1995/10/18  19:33:14  amiri
 * removed fflush (stdin/stdout) calls from ReconstructFailedDisk
 *
 * Revision 1.29  1995/10/11  10:20:33  jimz
 * #if 0'd problem code for sigmetrics
 *
 * Revision 1.28  1995/10/10  23:18:15  amiri
 * added fflushes to stdin/stdout before requesting
 * input in demo mode.
 *
 * Revision 1.27  1995/10/10  19:24:47  amiri
 * took out update_mode (for demo) from
 * KERNEL source.
 *
 * Revision 1.26  1995/10/09  23:35:48  amiri
 * added support for more meters in recon. demo
 *
 * Revision 1.25  1995/07/03  18:14:30  holland
 * changed the way the number of floating recon bufs &
 * the head sep limit get set
 *
 * Revision 1.24  1995/07/02  15:07:42  holland
 * bug fixes related to getting distributed sparing numbers
 *
 * Revision 1.23  1995/06/23  13:36:36  robby
 * updeated to prototypes in rf_layout.h
 *
*/

#ifdef _KERNEL
#define KERNEL
#endif

a37 1
#ifndef LINUX
a38 1
#endif /* !LINUX */
a57 5
#if RF_DEMO > 0
#include "rf_demo.h"
#endif /* RF_DEMO > 0 */

#ifdef KERNEL
a58 1
#endif /* KERNEL */
d81 2
a82 4
#ifdef KERNEL
static RF_Thread_t      recon_thr_handle;
static int              recon_thread_initialized = 0;
#endif /* KERNEL */
d88 18
a105 14
static RF_RaidReconDesc_t *AllocRaidReconDesc(RF_Raid_t *raidPtr,
	RF_RowCol_t row, RF_RowCol_t col, RF_RaidDisk_t *spareDiskPtr,
	int numDisksDone, RF_RowCol_t srow, RF_RowCol_t scol);
static void FreeReconDesc(RF_RaidReconDesc_t *reconDesc);
static int ProcessReconEvent(RF_Raid_t *raidPtr, RF_RowCol_t frow,
	RF_ReconEvent_t *event);
static int IssueNextReadRequest(RF_Raid_t *raidPtr, RF_RowCol_t row,
	RF_RowCol_t col);
static int TryToRead(RF_Raid_t *raidPtr, RF_RowCol_t row, RF_RowCol_t col);
static int ComputePSDiskOffsets(RF_Raid_t *raidPtr, RF_StripeNum_t psid,
	RF_RowCol_t row, RF_RowCol_t col, RF_SectorNum_t *outDiskOffset,
	RF_SectorNum_t *outFailedDiskSectorOffset, RF_RowCol_t *spRow,
	RF_RowCol_t *spCol, RF_SectorNum_t *spOffset);
static int IssueNextWriteRequest(RF_Raid_t *raidPtr, RF_RowCol_t row);
d108 12
a119 9
static void CheckForNewMinHeadSep(RF_Raid_t *raidPtr, RF_RowCol_t row,
	RF_HeadSepLimit_t hsCtr);
static int CheckHeadSeparation(RF_Raid_t *raidPtr, RF_PerDiskReconCtrl_t *ctrl,
	RF_RowCol_t row, RF_RowCol_t col, RF_HeadSepLimit_t hsCtr,
	RF_ReconUnitNum_t which_ru);
static int CheckForcedOrBlockedReconstruction(RF_Raid_t *raidPtr,
	RF_ReconParityStripeStatus_t *pssPtr, RF_PerDiskReconCtrl_t *ctrl,
	RF_RowCol_t row, RF_RowCol_t col, RF_StripeNum_t psid,
	RF_ReconUnitNum_t which_ru);
d126 3
a128 3
  void                (*proc)(RF_Raid_t *, void *);
  void                 *arg;
  RF_ReconDoneProc_t   *next;
d135 2
a136 1
static void SignalReconDone(RF_Raid_t *raidPtr)
d138 1
a138 1
  RF_ReconDoneProc_t *p;
d140 5
a144 27
  RF_LOCK_MUTEX(raidPtr->recon_done_proc_mutex);
  for(p=raidPtr->recon_done_procs;p;p=p->next) {
    p->proc(raidPtr, p->arg);
  }
  RF_UNLOCK_MUTEX(raidPtr->recon_done_proc_mutex);
}

int rf_RegisterReconDoneProc(
  RF_Raid_t            *raidPtr,
  void                (*proc)(RF_Raid_t *, void *),
  void                 *arg,
  RF_ReconDoneProc_t  **handlep)
{
  RF_ReconDoneProc_t *p;

  RF_FREELIST_GET(rf_rdp_freelist,p,next,(RF_ReconDoneProc_t *));
  if (p == NULL)
    return(ENOMEM);
  p->proc = proc;
  p->arg = arg;
  RF_LOCK_MUTEX(raidPtr->recon_done_proc_mutex);
  p->next = raidPtr->recon_done_procs;
  raidPtr->recon_done_procs = p;
  RF_UNLOCK_MUTEX(raidPtr->recon_done_proc_mutex);
  if (handlep)
    *handlep = p;
  return(0);
d147 22
d178 47
a224 2
static void rf_ShutdownReconstruction(ignored)
  void  *ignored;
a225 3
  RF_FREELIST_DESTROY(rf_recond_freelist,next,(RF_RaidReconDesc_t *));
  RF_FREELIST_DESTROY(rf_rdp_freelist,next,(RF_ReconDoneProc_t *));
}
d227 13
a239 56
int rf_ConfigureReconstruction(listp)
  RF_ShutdownList_t  **listp;
{
  int rc;

  RF_FREELIST_CREATE(rf_recond_freelist, RF_MAX_FREE_RECOND,
    RF_RECOND_INC, sizeof(RF_RaidReconDesc_t));
  if (rf_recond_freelist == NULL)
    return(ENOMEM);
  RF_FREELIST_CREATE(rf_rdp_freelist, RF_MAX_FREE_RDP,
    RF_RDP_INC, sizeof(RF_ReconDoneProc_t));
  if (rf_rdp_freelist == NULL) {
    RF_FREELIST_DESTROY(rf_recond_freelist,next,(RF_RaidReconDesc_t *));
    return(ENOMEM);
  }
  rc = rf_ShutdownCreate(listp, rf_ShutdownReconstruction, NULL);
  if (rc) {
    RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
      __FILE__, __LINE__, rc);
    rf_ShutdownReconstruction(NULL);
    return(rc);
  }

#ifdef KERNEL
  if (!recon_thread_initialized) {
	  RF_CREATE_THREAD(recon_thr_handle, rf_ReconKernelThread, NULL); 
	  recon_thread_initialized = 1;
  }
#endif /* KERNEL */

  return(0);
}

static RF_RaidReconDesc_t *AllocRaidReconDesc(raidPtr, row, col, spareDiskPtr, numDisksDone, srow, scol)
  RF_Raid_t      *raidPtr;
  RF_RowCol_t     row;
  RF_RowCol_t     col;
  RF_RaidDisk_t  *spareDiskPtr;
  int             numDisksDone;
  RF_RowCol_t     srow;
  RF_RowCol_t     scol;
{
  
  RF_RaidReconDesc_t *reconDesc;  

  RF_FREELIST_GET(rf_recond_freelist,reconDesc,next,(RF_RaidReconDesc_t *));

  reconDesc->raidPtr     = raidPtr;
  reconDesc->row         = row;
  reconDesc->col         = col;
  reconDesc->spareDiskPtr=spareDiskPtr;
  reconDesc->numDisksDone=numDisksDone; 
  reconDesc->srow=srow; 
  reconDesc->scol=scol;
  reconDesc->state      = 0;
  reconDesc->next       = NULL;
d241 1
a241 1
  return(reconDesc);
d244 3
a246 2
static void FreeReconDesc(reconDesc)
  RF_RaidReconDesc_t  *reconDesc;
d249 5
a253 7
  printf("RAIDframe: %lu recon event waits, %lu recon delays\n",
    (long)reconDesc->numReconEventWaits, (long)reconDesc->numReconExecDelays);
#endif /* RF_RECON_STATS > 0 */
#ifdef KERNEL
  printf("RAIDframe: %lu max exec ticks\n", 
	 (long)reconDesc->maxReconExecTicks);
#endif /* KERNEL */
d255 3
a257 3
  printf("\n");
#endif /* (RF_RECON_STATS > 0) || KERNEL */
  RF_FREELIST_FREE(rf_recond_freelist,reconDesc,next);
d267 79
a345 118
int rf_ReconstructFailedDisk(raidPtr, row, col)
  RF_Raid_t    *raidPtr;
  RF_RowCol_t   row;
  RF_RowCol_t   col;
{
#ifdef SIMULATE
  RF_PendingRecon_t *pend;
  RF_RowCol_t r, c;
#endif /* SIMULATE */
  RF_LayoutSW_t *lp;
  int rc;

  lp = raidPtr->Layout.map;
  if (lp->SubmitReconBuffer) {
    /*
     * The current infrastructure only supports reconstructing one
     * disk at a time for each array.
     */
#ifdef SIMULATE
    if (raidPtr->reconInProgress) {
      RF_Malloc(pend, sizeof(RF_PendingRecon_t), (RF_PendingRecon_t *));
      pend->row = row;
      pend->col = col;
      pend->next = raidPtr->pendingRecon;
      raidPtr->pendingRecon = pend;
      /* defer until current recon completes */
      return(0);
    }
    raidPtr->reconInProgress++;
#else /* SIMULATE */
    RF_LOCK_MUTEX(raidPtr->mutex);
    while (raidPtr->reconInProgress) {
      RF_WAIT_COND(raidPtr->waitForReconCond, raidPtr->mutex);
    }
    raidPtr->reconInProgress++;
    RF_UNLOCK_MUTEX(raidPtr->mutex);
#endif /* SIMULATE */
    rc = rf_ReconstructFailedDiskBasic(raidPtr, row, col);
  }
  else {
    RF_ERRORMSG1("RECON: no way to reconstruct failed disk for arch %c\n",
      lp->parityConfig);
    rc = EIO;
  }
#ifdef SIMULATE
  pend = raidPtr->pendingRecon;
  if (pend) {
    /* launch next recon */
    raidPtr->pendingRecon = pend->next;
    r = pend->row;
    c = pend->col;
    RF_Free(pend, sizeof(RF_PendingRecon_t));
    return(rf_ReconstructFailedDisk(raidPtr, r, c));
  }
#else /* SIMULATE */
  RF_LOCK_MUTEX(raidPtr->mutex);
  raidPtr->reconInProgress--;
  RF_UNLOCK_MUTEX(raidPtr->mutex);
  RF_SIGNAL_COND(raidPtr->waitForReconCond);
#if 1
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  wakeup(&raidPtr->waitForReconCond); /* XXX Methinks this will be needed
					at some point... GO*/
#endif
#endif
#endif /* SIMULATE */
  return(rc);
}

int rf_ReconstructFailedDiskBasic(raidPtr, row, col)
  RF_Raid_t    *raidPtr;
  RF_RowCol_t   row;
  RF_RowCol_t   col;
{
  RF_RaidDisk_t *spareDiskPtr = NULL;
  RF_RaidReconDesc_t *reconDesc;
  RF_RowCol_t srow, scol;
  int numDisksDone=0, rc;

  /* first look for a spare drive onto which to reconstruct the data */
  /* spare disk descriptors are stored in row 0.  This may have to change eventually */

  RF_LOCK_MUTEX(raidPtr->mutex);
  RF_ASSERT (raidPtr->Disks[row][col].status == rf_ds_failed);

  if (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {
    if (raidPtr->status[row] != rf_rs_degraded) {
      RF_ERRORMSG2("Unable to reconstruct disk at row %d col %d because status not degraded\n",row,col);
      RF_UNLOCK_MUTEX(raidPtr->mutex);
      return(EINVAL);
    }
    srow = row;
    scol = (-1);
  }
  else {
    srow = 0;
    for (scol=raidPtr->numCol; scol<raidPtr->numCol + raidPtr->numSpare; scol++) {
      if (raidPtr->Disks[srow][scol].status == rf_ds_spare) {
        spareDiskPtr = &raidPtr->Disks[srow][scol];
        spareDiskPtr->status = rf_ds_used_spare;
        break;
      }
    }
    if (!spareDiskPtr) {
      RF_ERRORMSG2("Unable to reconstruct disk at row %d col %d because no spares are available\n",row,col);
      RF_UNLOCK_MUTEX(raidPtr->mutex);
      return(ENOSPC);
    }

#if RF_DEMO > 0
    if (!rf_demoMode) {
#endif /* RF_DEMO > 0 */
      printf("RECON: initiating reconstruction on row %d col %d -> spare at row %d col %d\n",row, col, srow, scol);
#if RF_DEMO > 0
    }
#endif /* RF_DEMO > 0 */
  }
  RF_UNLOCK_MUTEX(raidPtr->mutex);
d347 2
a348 2
  reconDesc = AllocRaidReconDesc((void *) raidPtr, row, col,spareDiskPtr, numDisksDone, srow , scol);
  raidPtr->reconDesc = (void *) reconDesc;
d350 188
a537 232
  reconDesc->hsStallCount = 0;
  reconDesc->numReconExecDelays = 0;
  reconDesc->numReconEventWaits = 0;
#endif /* RF_RECON_STATS > 0 */
#ifdef KERNEL
  reconDesc->reconExecTimerRunning = 0;
  reconDesc->reconExecTicks = 0;
  reconDesc->maxReconExecTicks = 0;
#endif /* KERNEL */
#if RF_DEMO > 0 && !defined(SIMULATE)
  if (rf_demoMode) {
    char cbuf[10]; 
    printf("About to start reconstruction, hit return to continue:");
    gets(cbuf);
  }
#endif /* RF_DEMO > 0 && !SIMULATE */
  rc = rf_ContinueReconstructFailedDisk(reconDesc);
  return(rc);
}


int rf_ContinueReconstructFailedDisk(reconDesc)
  RF_RaidReconDesc_t  *reconDesc;
{
  RF_Raid_t             *raidPtr=reconDesc->raidPtr;   
  RF_RowCol_t            row=reconDesc->row;
  RF_RowCol_t            col=reconDesc->col;
  RF_RowCol_t            srow=reconDesc->srow; 
  RF_RowCol_t            scol=reconDesc->scol;
  RF_ReconMap_t         *mapPtr;

  RF_ReconEvent_t *event;
  struct timeval etime, elpsd;
  unsigned long xor_s, xor_resid_us;
  int retcode,i, ds;

  switch (reconDesc->state)
    {
      
      
    case 0:     

      raidPtr->accumXorTimeUs = 0;

      /* create one trace record per physical disk */
      RF_Malloc(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
      
      /* quiesce the array prior to starting recon.  this is needed to assure no nasty interactions
       * with pending user writes.  We need to do this before we change the disk or row status.
       */
      reconDesc->state=1;

      Dprintf("RECON: begin request suspend\n");      
      retcode =  rf_SuspendNewRequestsAndWait(raidPtr);
      Dprintf("RECON: end request suspend\n");      
      rf_StartUserStats(raidPtr);              /* zero out the stats kept on user accs */

#ifdef SIMULATE
      if (retcode) return(0);
#endif /* SIMULATE */

      /* fall through to state 1 */

    case 1:

      RF_LOCK_MUTEX(raidPtr->mutex);
      
      /* create the reconstruction control pointer and install it in the right slot */
      raidPtr->reconControl[row] = rf_MakeReconControl(reconDesc, row, col, srow, scol);
      mapPtr=raidPtr->reconControl[row]->reconMap;
      raidPtr->status[row] = rf_rs_reconstructing;
      raidPtr->Disks[row][col].status = rf_ds_reconstructing;
      raidPtr->Disks[row][col].spareRow = srow;
      raidPtr->Disks[row][col].spareCol = scol;
      
      RF_UNLOCK_MUTEX(raidPtr->mutex);

      RF_GETTIME(raidPtr->reconControl[row]->starttime);
#if RF_DEMO > 0
      if (rf_demoMode) {
         rf_demo_update_mode(RF_DEMO_RECON);
         rf_startup_recon_demo(rf_demoMeterVpos, raidPtr->numCol,
           raidPtr->Layout.numDataCol+raidPtr->Layout.numParityCol, 0);
      }
#endif /* RF_DEMO > 0 */

      /* now start up the actual reconstruction: issue a read for each surviving disk */
      rf_start_cpu_monitor();
      reconDesc->numDisksDone = 0;
      for (i=0; i<raidPtr->numCol; i++) {
        if (i != col) {
          /* find and issue the next I/O on the indicated disk */
	  if (IssueNextReadRequest(raidPtr, row, i)) {
            Dprintf2("RECON: done issuing for r%d c%d\n", row, i);
            reconDesc->numDisksDone++;
          }
        }
      }

    case 2:
      Dprintf("RECON: resume requests\n");
      rf_ResumeNewRequests(raidPtr);


      reconDesc->state=3;

    case 3:

      /* process reconstruction events until all disks report that they've completed all work */
      mapPtr=raidPtr->reconControl[row]->reconMap;


      
      while (reconDesc->numDisksDone < raidPtr->numCol-1) {

	event = rf_GetNextReconEvent(reconDesc, row, (void (*)(void *))rf_ContinueReconstructFailedDisk,reconDesc);
#ifdef SIMULATE
	if (event==NULL) {return(0);}
#else /* SIMULATE */
	RF_ASSERT(event);
#endif /* SIMULATE */

	if (ProcessReconEvent(raidPtr, row, event)) reconDesc->numDisksDone++;
	raidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);
#if RF_DEMO > 0
	if (rf_prReconSched || rf_demoMode)
#else /* RF_DEMO > 0 */
	if (rf_prReconSched)
#endif /* RF_DEMO > 0 */
	{
	  rf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));
	}
      }
      


      reconDesc->state=4;
      

    case 4:
      mapPtr=raidPtr->reconControl[row]->reconMap;
      if (rf_reconDebug) {
	printf("RECON: all reads completed\n");
      }
      

      
      /* at this point all the reads have completed.  We now wait for any pending writes
       * to complete, and then we're done
       */

      while (rf_UnitsLeftToReconstruct(raidPtr->reconControl[row]->reconMap) > 0) {
	
	event = rf_GetNextReconEvent(reconDesc, row, (void (*)(void *))rf_ContinueReconstructFailedDisk,reconDesc);
#ifdef SIMULATE
	if (event==NULL) {return(0);}
#else /* SIMULATE */
	RF_ASSERT(event);
#endif /* SIMULATE */
	
	(void) ProcessReconEvent(raidPtr, row, event);         /* ignore return code */
	raidPtr->reconControl[row]->percentComplete = 100 - (rf_UnitsLeftToReconstruct(mapPtr) * 100 / mapPtr->totalRUs);
#if RF_DEMO > 0
	if (rf_prReconSched || rf_demoMode)
#else /* RF_DEMO > 0 */
	if (rf_prReconSched)
#endif /* RF_DEMO > 0 */
	{
	  rf_PrintReconSchedule(raidPtr->reconControl[row]->reconMap, &(raidPtr->reconControl[row]->starttime));
	}
      }
      reconDesc->state=5;

    case 5:
      rf_stop_cpu_monitor();

      /* Success:  mark the dead disk as reconstructed.  We quiesce the array here to assure no
       * nasty interactions with pending user accesses when we free up the psstatus structure
       * as part of FreeReconControl()
       */



      reconDesc->state=6;

      retcode =  rf_SuspendNewRequestsAndWait(raidPtr);
      rf_StopUserStats(raidPtr);
      rf_PrintUserStats(raidPtr);               /* print out the stats on user accs accumulated during recon */

#ifdef SIMULATE
      if (retcode) return(0);
#endif /* SIMULATE */

      /* fall through to state 6 */
    case 6:
      

      
      RF_LOCK_MUTEX(raidPtr->mutex);
      raidPtr->numFailures--;
      ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE);
      raidPtr->Disks[row][col].status = (ds) ? rf_ds_dist_spared : rf_ds_spared;
      raidPtr->status[row] = (ds) ? rf_rs_reconfigured : rf_rs_optimal;
      RF_UNLOCK_MUTEX(raidPtr->mutex);
      RF_GETTIME(etime);
      RF_TIMEVAL_DIFF(&(raidPtr->reconControl[row]->starttime), &etime, &elpsd);

      /* XXX -- why is state 7 different from state 6 if there is no return() here? -- XXX
       *        Note that I set elpsd above & use it below, so if you put a return
       *        here you'll have to fix this. (also, FreeReconControl is called below)
       */
      
    case 7:

      rf_ResumeNewRequests(raidPtr);

#if RF_DEMO > 0
      if (rf_demoMode) {
        rf_finish_recon_demo(&elpsd);
      }
      else {
#endif /* RF_DEMO > 0 */
	printf("Reconstruction of disk at row %d col %d completed and spare disk reassigned\n", row, col);
	xor_s = raidPtr->accumXorTimeUs/1000000;
	xor_resid_us = raidPtr->accumXorTimeUs%1000000;
	printf("Recon time was %d.%06d seconds, accumulated XOR time was %ld us (%ld.%06ld)\n",
		(int)elpsd.tv_sec,(int)elpsd.tv_usec,raidPtr->accumXorTimeUs,xor_s,xor_resid_us);
	printf("  (start time %d sec %d usec, end time %d sec %d usec)\n",
	       (int)raidPtr->reconControl[row]->starttime.tv_sec,
	       (int)raidPtr->reconControl[row]->starttime.tv_usec,
	       (int)etime.tv_sec, (int)etime.tv_usec);
	rf_print_cpu_util("reconstruction");
d539 6
a544 11
	printf("Total head-sep stall count was %d\n", 
	       (int)reconDesc->hsStallCount);
#endif /* RF_RECON_STATS > 0 */
#if RF_DEMO > 0
      }
#endif /* RF_DEMO > 0 */
      rf_FreeReconControl(raidPtr, row);
      RF_Free(raidPtr->recon_tracerecs, raidPtr->numCol * sizeof(RF_AccTraceEntry_t));
      FreeReconDesc(reconDesc);
      
    }
d546 4
a549 2
  SignalReconDone(raidPtr);
  return (0);
a550 1

d555 108
a662 95
static int ProcessReconEvent(raidPtr, frow, event)
  RF_Raid_t        *raidPtr;
  RF_RowCol_t       frow;
  RF_ReconEvent_t  *event;
{
  int retcode = 0, submitblocked;
  RF_ReconBuffer_t *rbuf;
  RF_SectorCount_t sectorsPerRU;

  Dprintf1("RECON: ProcessReconEvent type %d\n", event->type);  
  switch(event->type) {

  /* a read I/O has completed */
  case RF_REVENT_READDONE:
    rbuf = raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf;
    Dprintf3("RECON: READDONE EVENT: row %d col %d psid %ld\n",
      frow, event->col, rbuf->parityStripeID);
    Dprintf7("RECON: done read  psid %ld buf %lx  %02x %02x %02x %02x %02x\n",
      rbuf->parityStripeID, rbuf->buffer, rbuf->buffer[0]&0xff, rbuf->buffer[1]&0xff,
      rbuf->buffer[2]&0xff, rbuf->buffer[3]&0xff, rbuf->buffer[4]&0xff);
    rf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);
    submitblocked =  rf_SubmitReconBuffer(rbuf, 0, 0);
    Dprintf1("RECON: submitblocked=%d\n", submitblocked);
    if (!submitblocked) retcode = IssueNextReadRequest(raidPtr, frow, event->col);
    break;

  /* a write I/O has completed */
  case RF_REVENT_WRITEDONE:
    if (rf_floatingRbufDebug) {
      rf_CheckFloatingRbufCount(raidPtr, 1);
    }
    sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;
    rbuf = (RF_ReconBuffer_t *) event->arg;
    rf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);
    Dprintf3("RECON: WRITEDONE EVENT: psid %d ru %d (%d %% complete)\n", 
	    rbuf->parityStripeID, rbuf->which_ru, raidPtr->reconControl[frow]->percentComplete);
    rf_ReconMapUpdate(raidPtr, raidPtr->reconControl[frow]->reconMap,
		   rbuf->failedDiskSectorOffset, rbuf->failedDiskSectorOffset + sectorsPerRU -1);
    rf_RemoveFromActiveReconTable(raidPtr, frow, rbuf->parityStripeID, rbuf->which_ru);
    
    if (rbuf->type == RF_RBUF_TYPE_FLOATING) {
      RF_LOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);
      raidPtr->numFullReconBuffers--;
      rf_ReleaseFloatingReconBuffer(raidPtr, frow, rbuf);
      RF_UNLOCK_MUTEX(raidPtr->reconControl[frow]->rb_mutex);
    } else if (rbuf->type == RF_RBUF_TYPE_FORCED) rf_FreeReconBuffer(rbuf);
    else RF_ASSERT(0);
    break;

  case RF_REVENT_BUFCLEAR:                  /* A buffer-stall condition has been cleared */
    Dprintf2("RECON: BUFCLEAR EVENT: row %d col %d\n",frow, event->col);
    submitblocked = rf_SubmitReconBuffer(raidPtr->reconControl[frow]->perDiskInfo[event->col].rbuf, 0, (int) (long)event->arg);
    RF_ASSERT(!submitblocked);              /* we wouldn't have gotten the BUFCLEAR event if we couldn't submit */
    retcode = IssueNextReadRequest(raidPtr, frow, event->col);
    break;

  case RF_REVENT_BLOCKCLEAR:                /* A user-write reconstruction blockage has been cleared */
    DDprintf2("RECON: BLOCKCLEAR EVENT: row %d col %d\n",frow, event->col);
    retcode = TryToRead(raidPtr, frow, event->col);
    break;

  case RF_REVENT_HEADSEPCLEAR:              /* A max-head-separation reconstruction blockage has been cleared */
    Dprintf2("RECON: HEADSEPCLEAR EVENT: row %d col %d\n",frow, event->col);
    retcode = TryToRead(raidPtr, frow, event->col);
    break;

  /* a buffer has become ready to write */
  case RF_REVENT_BUFREADY:
    Dprintf2("RECON: BUFREADY EVENT: row %d col %d\n",frow, event->col);
    retcode = IssueNextWriteRequest(raidPtr, frow);
    if (rf_floatingRbufDebug) {
      rf_CheckFloatingRbufCount(raidPtr, 1);
    }
    break;

  /* we need to skip the current RU entirely because it got recon'd while we were waiting for something else to happen */
  case RF_REVENT_SKIP:
    DDprintf2("RECON: SKIP EVENT: row %d col %d\n",frow, event->col);
    retcode = IssueNextReadRequest(raidPtr, frow, event->col);
    break;

  /* a forced-reconstruction read access has completed.  Just submit the buffer */
  case RF_REVENT_FORCEDREADDONE:
    rbuf = (RF_ReconBuffer_t *) event->arg;
    rf_FreeDiskQueueData((RF_DiskQueueData_t *) rbuf->arg);
    DDprintf2("RECON: FORCEDREADDONE EVENT: row %d col %d\n",frow, event->col);
    submitblocked = rf_SubmitReconBuffer(rbuf, 1, 0);
    RF_ASSERT(!submitblocked);
    break;
    
  default:
    RF_PANIC();
  }
  rf_FreeReconEventDesc(event);
  return(retcode);
d676 1
a676 1
 * from the standard C idiom of having counters point to the next thing to be 
d682 67
a748 60
static int IssueNextReadRequest(raidPtr, row, col)
  RF_Raid_t    *raidPtr;
  RF_RowCol_t   row;
  RF_RowCol_t   col;
{
  RF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];
  RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
  RF_ReconBuffer_t *rbuf = ctrl->rbuf;
  RF_ReconUnitCount_t RUsPerPU = layoutPtr->SUsPerPU / layoutPtr->SUsPerRU;
  RF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;
  int do_new_check = 0, retcode = 0, status;

  /* if we are currently the slowest disk, mark that we have to do a new check */
  if (ctrl->headSepCounter <= raidPtr->reconControl[row]->minHeadSepCounter) do_new_check = 1;

  while (1) {

    ctrl->ru_count++;
    if (ctrl->ru_count < RUsPerPU) {
      ctrl->diskOffset             += sectorsPerRU;
      rbuf->failedDiskSectorOffset += sectorsPerRU;
    } else {
      ctrl->curPSID++;
      ctrl->ru_count = 0;
      /* code left over from when head-sep was based on parity stripe id */
      if (ctrl->curPSID >= raidPtr->reconControl[row]->lastPSID) {
	CheckForNewMinHeadSep(raidPtr, row, ++(ctrl->headSepCounter));
	return(1);                           /* finito! */
      }
      
      /* find the disk offsets of the start of the parity stripe on both the current disk and the failed disk.
       * skip this entire parity stripe if either disk does not appear in the indicated PS
       */
      status = ComputePSDiskOffsets(raidPtr, ctrl->curPSID, row, col, &ctrl->diskOffset, &rbuf->failedDiskSectorOffset,
				    &rbuf->spRow, &rbuf->spCol, &rbuf->spOffset);
      if (status) {
	ctrl->ru_count = RUsPerPU-1; continue;
      }
    }
    rbuf->which_ru = ctrl->ru_count;
    
    /* skip this RU if it's already been reconstructed */
    if (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, rbuf->failedDiskSectorOffset)) {
      Dprintf2("Skipping psid %ld ru %d: already reconstructed\n",ctrl->curPSID,ctrl->ru_count);
      continue;
    }
    break;
  }
  ctrl->headSepCounter++;
  if (do_new_check) CheckForNewMinHeadSep(raidPtr, row, ctrl->headSepCounter);  /* update min if needed */

  
  /* at this point, we have definitely decided what to do, and we have only to see if we can actually do it now */
  rbuf->parityStripeID = ctrl->curPSID;
  rbuf->which_ru       = ctrl->ru_count;
  bzero((char *)&raidPtr->recon_tracerecs[col], sizeof(raidPtr->recon_tracerecs[col]));
  raidPtr->recon_tracerecs[col].reconacc = 1;
  RF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);
  retcode = TryToRead(raidPtr, row, col);
  return(retcode);
a749 1

d755 66
a820 62
static int TryToRead(raidPtr, row, col)
  RF_Raid_t    *raidPtr;
  RF_RowCol_t   row;
  RF_RowCol_t   col;
{
  RF_PerDiskReconCtrl_t *ctrl = &raidPtr->reconControl[row]->perDiskInfo[col];
  RF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;
  RF_StripeNum_t psid = ctrl->curPSID;
  RF_ReconUnitNum_t which_ru = ctrl->ru_count;
  RF_DiskQueueData_t *req;
  int status, created = 0;
  RF_ReconParityStripeStatus_t *pssPtr;
  
  /* if the current disk is too far ahead of the others, issue a head-separation wait and return */
  if (CheckHeadSeparation(raidPtr, ctrl, row, col, ctrl->headSepCounter, which_ru)) return(0);
  RF_LOCK_PSS_MUTEX(raidPtr, row, psid);
  pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE, &created);
  
  /* if recon is blocked on the indicated parity stripe, issue a block-wait request and return.
   * this also must mark the indicated RU in the stripe as under reconstruction if not blocked.
   */
  status = CheckForcedOrBlockedReconstruction(raidPtr, pssPtr, ctrl, row, col, psid, which_ru);
  if (status == RF_PSS_RECON_BLOCKED) {
    Dprintf2("RECON: Stalling psid %ld ru %d: recon blocked\n",psid,which_ru);
    goto out;
  } else if (status == RF_PSS_FORCED_ON_WRITE) {
    rf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);
    goto out;
  }

  /* make one last check to be sure that the indicated RU didn't get reconstructed while
   * we were waiting for something else to happen.  This is unfortunate in that it causes
   * us to make this check twice in the normal case.  Might want to make some attempt to
   * re-work this so that we only do this check if we've definitely blocked on one of the
   * above checks.  When this condition is detected, we may have just created a bogus
   * status entry, which we need to delete.
   */
  if (rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, ctrl->rbuf->failedDiskSectorOffset)) {
    Dprintf2("RECON: Skipping psid %ld ru %d: prior recon after stall\n",psid,which_ru);
    if (created) rf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);
    rf_CauseReconEvent(raidPtr, row, col, NULL, RF_REVENT_SKIP);
    goto out;
  }

  /* found something to read.  issue the I/O */
  Dprintf5("RECON: Read for psid %ld on row %d col %d offset %ld buf %lx\n",
    psid, row, col, ctrl->diskOffset, ctrl->rbuf->buffer);
  RF_ETIMER_STOP(raidPtr->recon_tracerecs[col].recon_timer);
  RF_ETIMER_EVAL(raidPtr->recon_tracerecs[col].recon_timer);
  raidPtr->recon_tracerecs[col].specific.recon.recon_start_to_fetch_us =
    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[col].recon_timer);
  RF_ETIMER_START(raidPtr->recon_tracerecs[col].recon_timer);
  
  /* should be ok to use a NULL proc pointer here, all the bufs we use should be in kernel space */
  req = rf_CreateDiskQueueData(RF_IO_TYPE_READ, ctrl->diskOffset, sectorsPerRU, ctrl->rbuf->buffer, psid, which_ru,
			    ReconReadDoneProc, (void *) ctrl, NULL, &raidPtr->recon_tracerecs[col], (void *)raidPtr, 0, NULL);
  
  RF_ASSERT(req);          /* XXX -- fix this -- XXX */
  
  ctrl->rbuf->arg = (void *) req;
  rf_DiskIOEnqueue(&raidPtr->Queues[row][col], req, RF_IO_RECON_PRIORITY);
  pssPtr->issued[col] = 1;
d823 2
a824 2
  RF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);
  return(0);
d848 106
a953 90
static int ComputePSDiskOffsets(
  RF_Raid_t       *raidPtr,  /* raid descriptor */
  RF_StripeNum_t   psid,     /* parity stripe identifier */
  RF_RowCol_t      row,      /* row and column of disk to find the offsets for */
  RF_RowCol_t      col,
  RF_SectorNum_t  *outDiskOffset,
  RF_SectorNum_t  *outFailedDiskSectorOffset,
  RF_RowCol_t     *spRow,    /* OUT: row,col of spare unit for failed unit */
  RF_RowCol_t     *spCol,
  RF_SectorNum_t  *spOffset) /* OUT: offset into disk containing spare unit */
{
  RF_RaidLayout_t *layoutPtr  = &raidPtr->Layout;
  RF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;
  RF_RaidAddr_t sosRaidAddress;                   /* start-of-stripe */
  RF_RowCol_t *diskids;
  u_int i, j, k, i_offset, j_offset;
  RF_RowCol_t prow, pcol;
  int testcol, testrow;
  RF_RowCol_t stripe;
  RF_SectorNum_t poffset;
  char i_is_parity=0, j_is_parity=0;
  RF_RowCol_t stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;

  /* get a listing of the disks comprising that stripe */
  sosRaidAddress = rf_ParityStripeIDToRaidAddress(layoutPtr, psid);
  (layoutPtr->map->IdentifyStripe)(raidPtr, sosRaidAddress, &diskids, &stripe);
  RF_ASSERT(diskids);

  /* reject this entire parity stripe if it does not contain the indicated disk or it does not contain the failed disk */
  if (row != stripe)
    goto skipit;
  for (i=0; i<stripeWidth; i++) {
    if (col == diskids[i])
      break;
  }
  if (i == stripeWidth)
    goto skipit;
  for (j=0; j<stripeWidth; j++) {
    if (fcol == diskids[j])
      break;
  }
  if (j == stripeWidth) {
    goto skipit;
  }

  /* find out which disk the parity is on */
  (layoutPtr->map->MapParity)(raidPtr, sosRaidAddress, &prow, &pcol, &poffset, RF_DONT_REMAP);

  /* find out if either the current RU or the failed RU is parity */
  /* also, if the parity occurs in this stripe prior to the data and/or failed col, we need to decrement i and/or j */
  for (k=0; k<stripeWidth; k++)
    if (diskids[k] == pcol)
      break;
  RF_ASSERT(k < stripeWidth);
  i_offset = i; j_offset=j;
  if (k < i) i_offset--; else if (k==i) {i_is_parity = 1; i_offset = 0;} /* set offsets to zero to disable multiply below */
  if (k < j) j_offset--; else if (k==j) {j_is_parity = 1; j_offset = 0;}
      
  /* at this point, [ij]_is_parity tells us whether the [current,failed] disk is parity at
   * the start of this RU, and, if data, "[ij]_offset" tells us how far into the stripe
   * the [current,failed] disk is.
   */

  /* call the mapping routine to get the offset into the current disk, repeat for failed disk. */
  if (i_is_parity)
    layoutPtr->map->MapParity(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);
  else
    layoutPtr->map->MapSector(raidPtr, sosRaidAddress + i_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outDiskOffset, RF_DONT_REMAP);

  RF_ASSERT(row == testrow && col == testcol);
  
  if (j_is_parity)
    layoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);
  else
    layoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, &testrow, &testcol, outFailedDiskSectorOffset, RF_DONT_REMAP);
  RF_ASSERT(row == testrow && fcol == testcol);

  /* now locate the spare unit for the failed unit */
  if (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {
    if (j_is_parity)
      layoutPtr->map->MapParity(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);
    else
      layoutPtr->map->MapSector(raidPtr, sosRaidAddress + j_offset * layoutPtr->sectorsPerStripeUnit, spRow, spCol, spOffset, RF_REMAP);
  } else {
    *spRow    = raidPtr->reconControl[row]->spareRow;
    *spCol    = raidPtr->reconControl[row]->spareCol;
    *spOffset = *outFailedDiskSectorOffset;
  }
  
  return(0);
d956 3
a958 3
  Dprintf3("RECON: Skipping psid %ld: nothing needed from r%d c%d\n",
    psid, row, col);
  return(1);
d960 37
d998 2
a999 37
/* this is called when a buffer has become ready to write to the replacement disk */
static int IssueNextWriteRequest(raidPtr, row)
  RF_Raid_t    *raidPtr;
  RF_RowCol_t   row;
{
  RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
  RF_SectorCount_t sectorsPerRU = layoutPtr->sectorsPerStripeUnit * layoutPtr->SUsPerRU;
  RF_RowCol_t fcol = raidPtr->reconControl[row]->fcol;
  RF_ReconBuffer_t *rbuf;
  RF_DiskQueueData_t *req;

  rbuf = rf_GetFullReconBuffer(raidPtr->reconControl[row]);
  RF_ASSERT(rbuf);                  /* there must be one available, or we wouldn't have gotten the event that sent us here */
  RF_ASSERT(rbuf->pssPtr);

  rbuf->pssPtr->writeRbuf = rbuf;
  rbuf->pssPtr = NULL;

  Dprintf7("RECON: New write (r %d c %d offs %d) for psid %ld ru %d (failed disk offset %ld) buf %lx\n",
    rbuf->spRow, rbuf->spCol, rbuf->spOffset, rbuf->parityStripeID,
    rbuf->which_ru, rbuf->failedDiskSectorOffset, rbuf->buffer);
  Dprintf6("RECON: new write psid %ld   %02x %02x %02x %02x %02x\n",
   rbuf->parityStripeID, rbuf->buffer[0]&0xff, rbuf->buffer[1]&0xff,
   rbuf->buffer[2]&0xff, rbuf->buffer[3]&0xff, rbuf->buffer[4]&0xff);

  /* should be ok to use a NULL b_proc here b/c all addrs should be in kernel space */
  req = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, rbuf->spOffset, 
			       sectorsPerRU, rbuf->buffer, 
			       rbuf->parityStripeID, rbuf->which_ru,
			       ReconWriteDoneProc, (void *) rbuf, NULL, 
			       &raidPtr->recon_tracerecs[fcol], 
			       (void *)raidPtr, 0, NULL);

  RF_ASSERT(req);          /* XXX -- fix this -- XXX */
  
  rbuf->arg = (void *) req;
  rf_DiskIOEnqueue(&raidPtr->Queues[rbuf->spRow][rbuf->spCol], req, RF_IO_RECON_PRIORITY);
d1001 1
a1001 1
  return(0);
a1002 1

d1009 23
a1031 23
static int ReconReadDoneProc(arg, status)
  void  *arg;
  int    status;
{
  RF_PerDiskReconCtrl_t *ctrl = (RF_PerDiskReconCtrl_t *) arg;
  RF_Raid_t *raidPtr = ctrl->reconCtrl->reconDesc->raidPtr;

  if (status) {
    /*
     * XXX
     */
    printf("Recon read failed!\n");
    RF_PANIC();
  }

  RF_ETIMER_STOP(raidPtr->recon_tracerecs[ctrl->col].recon_timer);
  RF_ETIMER_EVAL(raidPtr->recon_tracerecs[ctrl->col].recon_timer);
  raidPtr->recon_tracerecs[ctrl->col].specific.recon.recon_fetch_to_return_us =
    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[ctrl->col].recon_timer);
  RF_ETIMER_START(raidPtr->recon_tracerecs[ctrl->col].recon_timer);
  
  rf_CauseReconEvent(raidPtr, ctrl->row, ctrl->col, NULL, RF_REVENT_READDONE);
  return(0);
a1032 1

d1038 15
a1052 10
static int ReconWriteDoneProc(arg, status)
  void  *arg;
  int    status;
{
  RF_ReconBuffer_t *rbuf = (RF_ReconBuffer_t *) arg;

  Dprintf2("Reconstruction completed on psid %ld ru %d\n",rbuf->parityStripeID, rbuf->which_ru);
  if (status) {printf("Recon write failed!\n"); /*fprintf(stderr,"Recon write failed!\n");*/ RF_PANIC();}
  rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col, arg, RF_REVENT_WRITEDONE);
  return(0);
d1057 35
a1091 33
static void CheckForNewMinHeadSep(raidPtr, row, hsCtr)
  RF_Raid_t          *raidPtr;
  RF_RowCol_t         row;
  RF_HeadSepLimit_t   hsCtr;
{
  RF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];
  RF_HeadSepLimit_t new_min;
  RF_RowCol_t i;
  RF_CallbackDesc_t *p;
  RF_ASSERT(hsCtr >= reconCtrlPtr->minHeadSepCounter);           /* from the definition of a minimum */
  

  RF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);
  
  new_min = ~ (1L<< (8*sizeof(long)-1));         /* 0x7FFF....FFF */
  for (i=0; i<raidPtr->numCol; i++) if (i != reconCtrlPtr->fcol) {
    if (reconCtrlPtr->perDiskInfo[i].headSepCounter < new_min) new_min = reconCtrlPtr->perDiskInfo[i].headSepCounter;
  }

  /* set the new minimum and wake up anyone who can now run again */
  if (new_min != reconCtrlPtr->minHeadSepCounter) {
    reconCtrlPtr->minHeadSepCounter = new_min;
    Dprintf1("RECON:  new min head pos counter val is %ld\n",new_min);
    while (reconCtrlPtr->headSepCBList) {
      if (reconCtrlPtr->headSepCBList->callbackArg.v > new_min) break;
      p = reconCtrlPtr->headSepCBList;
      reconCtrlPtr->headSepCBList = p->next;
      p->next = NULL;
      rf_CauseReconEvent(raidPtr, p->row, p->col, NULL, RF_REVENT_HEADSEPCLEAR);
      rf_FreeCallbackDesc(p);
    }
    
  }
d1093 2
a1094 1
  RF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);
a1095 1

d1107 50
a1156 45
static int CheckHeadSeparation(
  RF_Raid_t              *raidPtr,
  RF_PerDiskReconCtrl_t  *ctrl,
  RF_RowCol_t             row,
  RF_RowCol_t             col,
  RF_HeadSepLimit_t       hsCtr,
  RF_ReconUnitNum_t       which_ru)
{
  RF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[row];
  RF_CallbackDesc_t *cb, *p, *pt;
  int retval = 0, tid;
  
  /* if we're too far ahead of the slowest disk, stop working on this disk
   * until the slower ones catch up.  We do this by scheduling a wakeup callback
   * for the time when the slowest disk has caught up.  We define "caught up"
   * with 20% hysteresis, i.e. the head separation must have fallen to at most
   * 80% of the max allowable head separation before we'll wake up.
   * 
   */
  rf_get_threadid(tid);
  RF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);
  if ((raidPtr->headSepLimit >= 0) &&
      ((ctrl->headSepCounter - reconCtrlPtr->minHeadSepCounter) > raidPtr->headSepLimit))
  {
    Dprintf6("[%d] RECON: head sep stall: row %d col %d hsCtr %ld minHSCtr %ld limit %ld\n",
			   tid,row,col,ctrl->headSepCounter, reconCtrlPtr->minHeadSepCounter, raidPtr->headSepLimit);
    cb = rf_AllocCallbackDesc();
    /* the minHeadSepCounter value we have to get to before we'll wake up.  build in 20% hysteresis. */
    cb->callbackArg.v  = (ctrl->headSepCounter - raidPtr->headSepLimit + raidPtr->headSepLimit/5);
    cb->row = row; cb->col = col;
    cb->next = NULL;

    /* insert this callback descriptor into the sorted list of pending head-sep callbacks */
    p = reconCtrlPtr->headSepCBList;
    if (!p) reconCtrlPtr->headSepCBList = cb;
    else if (cb->callbackArg.v < p->callbackArg.v) {
      cb->next = reconCtrlPtr->headSepCBList;
      reconCtrlPtr->headSepCBList = cb;
    }
    else {
      for (pt=p, p=p->next; p && (p->callbackArg.v < cb->callbackArg.v); pt=p,p=p->next);
      cb->next = p;
      pt->next = cb;
    }
    retval = 1;
d1158 4
a1161 4
    ctrl->reconCtrl->reconDesc->hsStallCount++;
#endif /* RF_RECON_STATS > 0 */
  }
  RF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);
d1163 1
a1163 1
  return(retval);
a1164 1

d1172 32
a1203 25
static int CheckForcedOrBlockedReconstruction(
  RF_Raid_t                     *raidPtr,
  RF_ReconParityStripeStatus_t  *pssPtr,
  RF_PerDiskReconCtrl_t         *ctrl,
  RF_RowCol_t                    row,
  RF_RowCol_t                    col,
  RF_StripeNum_t                 psid,
  RF_ReconUnitNum_t              which_ru)
{
  RF_CallbackDesc_t *cb;
  int retcode = 0;

  if ((pssPtr->flags & RF_PSS_FORCED_ON_READ) || (pssPtr->flags & RF_PSS_FORCED_ON_WRITE)) retcode = RF_PSS_FORCED_ON_WRITE;
  else if (pssPtr->flags & RF_PSS_RECON_BLOCKED) {
    Dprintf4("RECON: row %d col %d blocked at psid %ld ru %d\n",row, col, psid, which_ru);
    cb = rf_AllocCallbackDesc();   /* append ourselves to the blockage-wait list */
    cb->row = row; cb->col = col;
    cb->next = pssPtr->blockWaitList;
    pssPtr->blockWaitList = cb;
    retcode = RF_PSS_RECON_BLOCKED;
  }

  if (!retcode) pssPtr->flags |= RF_PSS_UNDER_RECON;    /* mark this RU as under reconstruction */
  
  return(retcode);
a1204 1

d1211 110
a1320 96
int rf_ForceOrBlockRecon(raidPtr, asmap, cbFunc, cbArg)
  RF_Raid_t              *raidPtr;
  RF_AccessStripeMap_t   *asmap;
  void                  (*cbFunc)(RF_Raid_t *,void *);
  void                   *cbArg;
{
  RF_RowCol_t row = asmap->physInfo->row;               /* which row of the array we're working on */
  RF_StripeNum_t stripeID = asmap->stripeID;                    /* the stripe ID we're forcing recon on */
  RF_SectorCount_t sectorsPerRU = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU;   /* num sects in one RU */
  RF_ReconParityStripeStatus_t *pssPtr;                /* a pointer to the parity stripe status structure */
  RF_StripeNum_t psid; /* parity stripe id */
  RF_SectorNum_t offset, fd_offset;                        /* disk offset, failed-disk offset */
  RF_RowCol_t *diskids;
  RF_RowCol_t stripe;
  int tid;
  RF_ReconUnitNum_t which_ru; /* RU within parity stripe */
  RF_RowCol_t fcol, diskno, i;
  RF_ReconBuffer_t *new_rbuf;                               /* ptr to newly allocated rbufs */
  RF_DiskQueueData_t *req;                                  /* disk I/O req to be enqueued */
  RF_CallbackDesc_t *cb;
  int created = 0, nPromoted;

  rf_get_threadid(tid);
  psid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID, &which_ru);

  RF_LOCK_PSS_MUTEX(raidPtr, row, psid);

  pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_CREATE|RF_PSS_RECON_BLOCKED, &created);

  /* if recon is not ongoing on this PS, just return */
  if (!(pssPtr->flags & RF_PSS_UNDER_RECON)) {
    RF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);
    return(0);
  }

  /* otherwise, we have to wait for reconstruction to complete on this RU. */
  /* In order to avoid waiting for a potentially large number of low-priority accesses to
   * complete, we force a normal-priority (i.e. not low-priority) reconstruction
   * on this RU.
   */
  if (!(pssPtr->flags & RF_PSS_FORCED_ON_WRITE) && !(pssPtr->flags & RF_PSS_FORCED_ON_READ)) {
    DDprintf1("Forcing recon on psid %ld\n",psid);
    pssPtr->flags |= RF_PSS_FORCED_ON_WRITE;     /* mark this RU as under forced recon */
    pssPtr->flags &= ~RF_PSS_RECON_BLOCKED;      /* clear the blockage that we just set */
    fcol = raidPtr->reconControl[row]->fcol;
    
    /* get a listing of the disks comprising the indicated stripe */
    (raidPtr->Layout.map->IdentifyStripe)(raidPtr, asmap->raidAddress, &diskids, &stripe);
    RF_ASSERT(row == stripe);
    
    /* For previously issued reads, elevate them to normal priority.  If the I/O has already completed,
     * it won't be found in the queue, and hence this will be a no-op.
     * For unissued reads, allocate buffers and issue new reads.  The fact that we've set the
     * FORCED bit means that the regular recon procs will not re-issue these reqs
     */
    for (i=0; i<raidPtr->Layout.numDataCol+raidPtr->Layout.numParityCol; i++) if ( (diskno = diskids[i]) != fcol) {
      if (pssPtr->issued[diskno]) {
	nPromoted = rf_DiskIOPromote(&raidPtr->Queues[row][diskno], psid, which_ru);
	if (rf_reconDebug && nPromoted) printf("[%d] promoted read from row %d col %d\n",tid,row,diskno);
      } else {
	new_rbuf = rf_MakeReconBuffer(raidPtr, row, diskno, RF_RBUF_TYPE_FORCED);              /* create new buf */
	ComputePSDiskOffsets(raidPtr, psid, row, diskno, &offset, &fd_offset,
			     &new_rbuf->spRow, &new_rbuf->spCol, &new_rbuf->spOffset);   /* find offsets & spare location */
	new_rbuf->parityStripeID = psid;                                                 /* fill in the buffer */
	new_rbuf->which_ru = which_ru;
	new_rbuf->failedDiskSectorOffset = fd_offset;
	new_rbuf->priority = RF_IO_NORMAL_PRIORITY;

	/* use NULL b_proc b/c all addrs should be in kernel space */
	req = rf_CreateDiskQueueData(RF_IO_TYPE_READ, offset + which_ru * sectorsPerRU, sectorsPerRU, new_rbuf->buffer,
				  psid, which_ru, (int (*)(void *, int))ForceReconReadDoneProc, (void *) new_rbuf, NULL,
				  NULL,(void *)raidPtr, 0, NULL);

	RF_ASSERT(req);          /* XXX -- fix this -- XXX */

	new_rbuf->arg = req;
	rf_DiskIOEnqueue(&raidPtr->Queues[row][diskno], req, RF_IO_NORMAL_PRIORITY);     /* enqueue the I/O */
	Dprintf3("[%d] Issued new read req on row %d col %d\n",tid,row,diskno);
      }
    }

    /* if the write is sitting in the disk queue, elevate its priority */
    if (rf_DiskIOPromote(&raidPtr->Queues[row][fcol], psid, which_ru)) printf("[%d] promoted write to row %d col %d\n",tid,row,fcol);
  }
  
  /* install a callback descriptor to be invoked when recon completes on this parity stripe. */
  cb = rf_AllocCallbackDesc();
  /* XXX the following is bogus.. These functions don't really match!!  GO */
  cb->callbackFunc = (void (*)(RF_CBParam_t))cbFunc;
  cb->callbackArg.p = (void *) cbArg;
  cb->next = pssPtr->procWaitList;
  pssPtr->procWaitList = cb;
  DDprintf2("[%d] Waiting for forced recon on psid %ld\n",tid,psid);
  
  RF_UNLOCK_PSS_MUTEX(raidPtr, row, psid);
  return(1);
a1321 1

d1326 14
a1339 8
static void ForceReconReadDoneProc(arg, status)
  void  *arg;
  int    status;
{
  RF_ReconBuffer_t *rbuf = arg;

  if (status) {printf("Forced recon read failed!\n"); /*fprintf(stderr,"Forced recon read failed!\n");*/ RF_PANIC();}
  rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, rbuf->row, rbuf->col, (void *) rbuf, RF_REVENT_FORCEDREADDONE);
a1340 1

d1342 54
a1395 50
int rf_UnblockRecon(raidPtr, asmap)
  RF_Raid_t             *raidPtr;
  RF_AccessStripeMap_t  *asmap;
{
  RF_RowCol_t row = asmap->origRow;
  RF_StripeNum_t stripeID = asmap->stripeID;
  RF_ReconParityStripeStatus_t *pssPtr;
  RF_ReconUnitNum_t which_ru;
  RF_StripeNum_t psid;
  int tid, created = 0;
  RF_CallbackDesc_t *cb;

  rf_get_threadid(tid);
  psid = rf_MapStripeIDToParityStripeID(&raidPtr->Layout, stripeID, &which_ru);
  RF_LOCK_PSS_MUTEX( raidPtr, row, psid);
  pssPtr = rf_LookupRUStatus(raidPtr, raidPtr->reconControl[row]->pssTable, psid, which_ru, RF_PSS_NONE, &created);

  /* When recon is forced, the pss desc can get deleted before we get back to unblock recon.
   * But, this can _only_ happen when recon is forced.
   * It would be good to put some kind of sanity check here, but how to decide if recon
   * was just forced or not?
   */
  if (!pssPtr) {
    /*printf("Warning: no pss descriptor upon unblock on psid %ld RU %d\n",psid,which_ru);*/
    if (rf_reconDebug || rf_pssDebug) printf("Warning: no pss descriptor upon unblock on psid %ld RU %d\n",(long)psid,which_ru);
    goto out;
  }

  pssPtr->blockCount--;
  Dprintf3("[%d] unblocking recon on psid %ld: blockcount is %d\n",tid,psid,pssPtr->blockCount);
  if (pssPtr->blockCount == 0) {     /* if recon blockage has been released */

    /* unblock recon before calling CauseReconEvent in case CauseReconEvent causes us to
     * try to issue a new read before returning here.
     */
    pssPtr->flags &= ~RF_PSS_RECON_BLOCKED;

    
    while (pssPtr->blockWaitList) {  /* spin through the block-wait list and release all the waiters */
      cb = pssPtr->blockWaitList;
      pssPtr->blockWaitList = cb->next;
      cb->next = NULL;
      rf_CauseReconEvent(raidPtr, cb->row, cb->col, NULL, RF_REVENT_BLOCKCLEAR);
      rf_FreeCallbackDesc(cb);
    }
    if (!(pssPtr->flags & RF_PSS_UNDER_RECON)) {     /* if no recon was requested while recon was blocked */
      rf_PSStatusDelete(raidPtr, raidPtr->reconControl[row]->pssTable, pssPtr);
    }
  }
  
d1397 2
a1398 2
  RF_UNLOCK_PSS_MUTEX( raidPtr, row, psid );
  return(0);
@

