head	1.10;
access;
symbols
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.10
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.12
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.8
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.6
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.4
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.18
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.16
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.14
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.12
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.10
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.6.0.8
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.9;

1.9
date	2010.05.23.13.49.35;	author naddy;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.05.00.38.22;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.08.16.07.39;	author peter;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2000.01.11.18.02.20;	author peter;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.01.07.14.50.20;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.27;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.02;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.09;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.6.8.1
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_copyback.c,v 1.9 2010/05/23 13:49:35 naddy Exp $	*/
/*	$NetBSD: rf_copyback.c,v 1.14 2000/03/07 02:59:50 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */


/*****************************************************************************
 *
 * copyback.c -- Code to copy reconstructed data back from spare space to
 *		 the replaced disk.
 *
 * The code operates using callbacks on the I/Os to continue with the next
 * unit to be copied back. We do this because a simple loop containing
 * blocking I/Os will not work in the simulator.
 *
 *****************************************************************************/

#include "rf_types.h"

#include <sys/time.h>
#include <sys/buf.h>
#include "rf_raid.h"
#include "rf_mcpair.h"
#include "rf_acctrace.h"
#include "rf_etimer.h"
#include "rf_general.h"
#include "rf_utils.h"
#include "rf_copyback.h"
#include "rf_decluster.h"
#include "rf_driver.h"
#include "rf_shutdown.h"
#include "rf_kintf.h"

#define	RF_COPYBACK_DATA	0
#define	RF_COPYBACK_PARITY	1

int	rf_copyback_in_progress;

int  rf_CopybackReadDoneProc(RF_CopybackDesc_t *, int);
int  rf_CopybackWriteDoneProc(RF_CopybackDesc_t *, int);
void rf_CopybackOne(RF_CopybackDesc_t *, int, RF_RaidAddr_t,
	RF_RowCol_t, RF_RowCol_t, RF_SectorNum_t);
void rf_CopybackComplete(RF_CopybackDesc_t *, int);

int
rf_ConfigureCopyback(RF_ShutdownList_t **listp)
{
	rf_copyback_in_progress = 0;
	return (0);
}

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/fcntl.h>
#ifdef	__NETBSD__
#include <sys/vnode.h>
#endif


/* Do a complete copyback. */
void
rf_CopybackReconstructedData(RF_Raid_t *raidPtr)
{
	RF_ComponentLabel_t c_label;
	int done, retcode;
	RF_CopybackDesc_t *desc;
	RF_RowCol_t frow, fcol;
	RF_RaidDisk_t *badDisk;
	char *databuf;

	struct partinfo dpart;
	struct vnode *vp;
	struct vattr va;
	struct proc *proc;

	int ac;

	done = 0;
	fcol = 0;
	for (frow = 0; frow < raidPtr->numRow; frow++) {
		for (fcol = 0; fcol < raidPtr->numCol; fcol++) {
			if (raidPtr->Disks[frow][fcol].status ==
			     rf_ds_dist_spared ||
			    raidPtr->Disks[frow][fcol].status ==
			     rf_ds_spared) {
				done = 1;
				break;
			}
		}
		if (done)
			break;
	}

	if (frow == raidPtr->numRow) {
		printf("COPYBACK: No disks need copyback.\n");
		return;
	}
	badDisk = &raidPtr->Disks[frow][fcol];

	proc = raidPtr->engine_thread;

	/*
	 * This device may have been opened successfully the first time.
	 * Close it before trying to open it again.
	 */

	if (raidPtr->raid_cinfo[frow][fcol].ci_vp != NULL) {
		printf("Close the opened device: %s.\n",
		    raidPtr->Disks[frow][fcol].devname);
 		vp = raidPtr->raid_cinfo[frow][fcol].ci_vp;
 		ac = raidPtr->Disks[frow][fcol].auto_configured;
 		rf_close_component(raidPtr, vp, ac);
		raidPtr->raid_cinfo[frow][fcol].ci_vp = NULL;

	}
 	/* Note that this disk was *not* auto_configured (any longer). */
 	raidPtr->Disks[frow][fcol].auto_configured = 0;

	printf("About to (re-)open the device: %s.\n",
	    raidPtr->Disks[frow][fcol].devname);

	retcode = raidlookup(raidPtr->Disks[frow][fcol].devname, proc, &vp);

	if (retcode) {
		printf("COPYBACK: raidlookup on device: %s failed: %d !\n",
		    raidPtr->Disks[frow][fcol].devname, retcode);

		/*
		 * XXX The component isn't responding properly... Must be
		 * still dead :-(
		 */
		return;

	} else {

		/*
		 * Ok, so we can at least do a lookup...
		 * How about actually getting a vp for it ?
		 */

		if ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0)
		{
			return;
		}
		retcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) &dpart, FREAD,
		    proc->p_ucred, proc);
		if (retcode) {
			return;
		}
		raidPtr->Disks[frow][fcol].blockSize = dpart.disklab->d_secsize;

		raidPtr->Disks[frow][fcol].numBlocks = DL_GETPSIZE(dpart.part) -
		    rf_protectedSectors;

		raidPtr->raid_cinfo[frow][fcol].ci_vp = vp;
		raidPtr->raid_cinfo[frow][fcol].ci_dev = va.va_rdev;

		/* XXX Or the above ? */
		raidPtr->Disks[frow][fcol].dev = va.va_rdev;

		/*
		 * We allow the user to specify that only a fraction of the
		 * disks should be used this is just for debug: it speeds up
		 * the parity scan.
		 */
		raidPtr->Disks[frow][fcol].numBlocks =
		    raidPtr->Disks[frow][fcol].numBlocks *
		    rf_sizePercentage / 100;
	}
#if 0
	/* This is the way it was done before the CAM stuff was removed. */

	if (rf_extract_ids(badDisk->devname, &bus, &targ, &lun)) {
		printf("COPYBACK: unable to extract bus, target, lun from"
		    " devname %s.\n", badDisk->devname);
		return;
	}
	/*
	 * TUR the disk that's marked as bad to be sure that it's actually
	 * alive.
	 */
	rf_SCSI_AllocTUR(&tur_op);
	retcode = rf_SCSI_DoTUR(tur_op, bus, targ, lun, badDisk->dev);
	rf_SCSI_FreeDiskOp(tur_op, 0);
#endif

	if (retcode) {
		printf("COPYBACK: target disk failed TUR.\n");
		return;
	}
	/* Get a buffer to hold one SU. */
	RF_Malloc(databuf, rf_RaidAddressToByte(raidPtr,
	    raidPtr->Layout.sectorsPerStripeUnit), (char *));

	/* Create a descriptor. */
	RF_Malloc(desc, sizeof(*desc), (RF_CopybackDesc_t *));
	desc->raidPtr = raidPtr;
	desc->status = 0;
	desc->frow = frow;
	desc->fcol = fcol;
	desc->spRow = badDisk->spareRow;
	desc->spCol = badDisk->spareCol;
	desc->stripeAddr = 0;
	desc->sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	desc->sectPerStripe = raidPtr->Layout.sectorsPerStripeUnit *
	    raidPtr->Layout.numDataCol;
	desc->databuf = databuf;
	desc->mcpair = rf_AllocMCPair();

	printf("COPYBACK: Quiescing the array.\n");
	/*
	 * Quiesce the array, since we don't want to code support for user
	 * accs here.
	 */
	rf_SuspendNewRequestsAndWait(raidPtr);

	/* Adjust state of the array and of the disks. */
	RF_LOCK_MUTEX(raidPtr->mutex);
	raidPtr->Disks[desc->frow][desc->fcol].status = rf_ds_optimal;
	raidPtr->status[desc->frow] = rf_rs_optimal;
	rf_copyback_in_progress = 1;	/* Debug only. */
	RF_UNLOCK_MUTEX(raidPtr->mutex);

	printf("COPYBACK: Beginning\n");
	RF_GETTIME(desc->starttime);
	rf_ContinueCopyback(desc);

	/*
	 * Data has been restored.
	 * Fix up the component label.
	 * Don't actually need the read here.
	 */
	raidread_component_label(raidPtr->raid_cinfo[frow][fcol].ci_dev,
				 raidPtr->raid_cinfo[frow][fcol].ci_vp,
				 &c_label);

	raid_init_component_label(raidPtr, &c_label);

	c_label.row = frow;
	c_label.column = fcol;

	raidwrite_component_label(raidPtr->raid_cinfo[frow][fcol].ci_dev,
				  raidPtr->raid_cinfo[frow][fcol].ci_vp,
				  &c_label);
}


/*
 * Invoked via callback after a copyback I/O has completed to
 * continue on with the next one.
 */
void
rf_ContinueCopyback(RF_CopybackDesc_t *desc)
{
	RF_SectorNum_t testOffs, stripeAddr;
	RF_Raid_t *raidPtr = desc->raidPtr;
	RF_RaidAddr_t addr;
	RF_RowCol_t testRow, testCol;
	int old_pctg, new_pctg, done;
	struct timeval t, diff;

	old_pctg = (-1);
	while (1) {
		stripeAddr = desc->stripeAddr;
		desc->raidPtr->copyback_stripes_done = stripeAddr /
		    desc->sectPerStripe;
		if (rf_prReconSched) {
			old_pctg = 100 * desc->stripeAddr /
			    raidPtr->totalSectors;
		}
		desc->stripeAddr += desc->sectPerStripe;
		if (rf_prReconSched) {
			new_pctg = 100 * desc->stripeAddr /
			    raidPtr->totalSectors;
			if (new_pctg != old_pctg) {
				RF_GETTIME(t);
				RF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);
				printf("%d %d.%06d\n", new_pctg,
				    (int) diff.tv_sec, (int) diff.tv_usec);
			}
		}
		if (stripeAddr >= raidPtr->totalSectors) {
			rf_CopybackComplete(desc, 0);
			return;
		}
		/* Walk through the current stripe, su-by-su. */
		for (done = 0, addr = stripeAddr;
		     addr < stripeAddr + desc->sectPerStripe;
		     addr += desc->sectPerSU) {

			/* Map the SU, disallowing remap to spare space. */
			(raidPtr->Layout.map->MapSector) (raidPtr, addr,
			    &testRow, &testCol, &testOffs, RF_DONT_REMAP);

			if (testRow == desc->frow && testCol == desc->fcol) {
				rf_CopybackOne(desc, RF_COPYBACK_DATA, addr,
				    testRow, testCol, testOffs);
				done = 1;
				break;
			}
		}

		if (!done) {
			/*
			 * We didn't find the failed disk in the data part,
			 * check parity.
			 */

			/*
			 * Map the parity for this stripe, disallowing remap
			 * to spare space.
			 */
			(raidPtr->Layout.map->MapParity) (raidPtr, stripeAddr,
			    &testRow, &testCol, &testOffs, RF_DONT_REMAP);

			if (testRow == desc->frow && testCol == desc->fcol) {
				rf_CopybackOne(desc, RF_COPYBACK_PARITY,
				    stripeAddr, testRow, testCol, testOffs);
			}
		}
		/* Check to see if the last read/write pair failed. */
		if (desc->status) {
			rf_CopybackComplete(desc, 1);
			return;
		}
		/*
		 * We didn't find any units to copy back in this stripe.
		 * Continue with the next one.
		 */
	}
}


/* Copyback one unit. */
void
rf_CopybackOne(RF_CopybackDesc_t *desc, int typ, RF_RaidAddr_t addr,
    RF_RowCol_t testRow, RF_RowCol_t testCol, RF_SectorNum_t testOffs)
{
	RF_SectorCount_t sectPerSU = desc->sectPerSU;
	RF_Raid_t *raidPtr = desc->raidPtr;
	RF_RowCol_t spRow = desc->spRow;
	RF_RowCol_t spCol = desc->spCol;
	RF_SectorNum_t spOffs;

	/* Find the spare location for this SU. */
	if (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {
		if (typ == RF_COPYBACK_DATA)
			raidPtr->Layout.map->MapSector(raidPtr, addr, &spRow,
			    &spCol, &spOffs, RF_REMAP);
		else
			raidPtr->Layout.map->MapParity(raidPtr, addr, &spRow,
			    &spCol, &spOffs, RF_REMAP);
	} else {
		spOffs = testOffs;
	}

	/* Create reqs to read the old location & write the new. */
	desc->readreq = rf_CreateDiskQueueData(RF_IO_TYPE_READ, spOffs,
	    sectPerSU, desc->databuf, 0L, 0, (int (*) (void *, int))
	    rf_CopybackReadDoneProc, desc, NULL, NULL, (void *) raidPtr,
	    RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);
	desc->writereq = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, testOffs,
	    sectPerSU, desc->databuf, 0L, 0, (int (*) (void *, int))
	    rf_CopybackWriteDoneProc, desc, NULL, NULL, (void *) raidPtr,
	    RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);
	desc->frow = testRow;
	desc->fcol = testCol;

	/*
	 * Enqueue the read. The write will go out as part of the callback on
	 * the read. At user-level & in the kernel, wait for the read-write
	 * pair to complete. In the simulator, just return, since everything
	 * will happen as callbacks.
	 */

	RF_LOCK_MUTEX(desc->mcpair->mutex);
	desc->mcpair->flag = 0;

	rf_DiskIOEnqueue(&raidPtr->Queues[spRow][spCol], desc->readreq,
	    RF_IO_NORMAL_PRIORITY);

	while (!desc->mcpair->flag) {
		RF_WAIT_MCPAIR(desc->mcpair);
	}
	RF_UNLOCK_MUTEX(desc->mcpair->mutex);
	rf_FreeDiskQueueData(desc->readreq);
	rf_FreeDiskQueueData(desc->writereq);

}


/*
 * Called at interrupt context when the read has completed.
 * Just send out the write.
 */
int
rf_CopybackReadDoneProc(RF_CopybackDesc_t *desc, int status)
{
	if (status) {		/* Invoke the callback with bad status. */
		printf("COPYBACK: copyback read failed. Aborting.\n");
		(desc->writereq->CompleteFunc) (desc, -100);
	} else {
		rf_DiskIOEnqueue(&(desc->raidPtr
		    ->Queues[desc->frow][desc->fcol]),
		    desc->writereq, RF_IO_NORMAL_PRIORITY);
	}
	return (0);
}


/*
 * Called at interrupt context when the write has completed.
 * At user level & in the kernel, wake up the copyback thread.
 * In the simulator, invoke the next copyback directly.
 * Can't free diskqueuedata structs in the kernel because we're at
 * interrupt context.
 */
int
rf_CopybackWriteDoneProc(RF_CopybackDesc_t *desc, int status)
{
	if (status && status != -100) {
		printf("COPYBACK: copyback write failed. Aborting.\n");
	}
	desc->status = status;
	rf_MCPairWakeupFunc(desc->mcpair);
	return (0);
}


/* Invoked when the copyback has completed. */
void
rf_CopybackComplete(RF_CopybackDesc_t *desc, int status)
{
	RF_Raid_t *raidPtr = desc->raidPtr;
	struct timeval t, diff;

	if (!status) {
		RF_LOCK_MUTEX(raidPtr->mutex);
		if (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {
			RF_ASSERT(raidPtr->Layout.map->parityConfig == 'D');
			rf_FreeSpareTable(raidPtr);
		} else {
			raidPtr->Disks[desc->spRow][desc->spCol].status =
			    rf_ds_spare;
		}
		RF_UNLOCK_MUTEX(raidPtr->mutex);

		RF_GETTIME(t);
		RF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);
		printf("Copyback time was %d.%06d seconds.\n",
		    (int) diff.tv_sec, (int) diff.tv_usec);
	} else
		printf("COPYBACK: Failure.\n");

	RF_Free(desc->databuf, rf_RaidAddressToByte(raidPtr, desc->sectPerSU));
	rf_FreeMCPair(desc->mcpair);
	RF_Free(desc, sizeof(*desc));

	rf_copyback_in_progress = 0;
	rf_ResumeNewRequests(raidPtr);
}
@


1.9
log
@missing dkio.h includes; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_copyback.c,v 1.8 2007/06/05 00:38:22 deraadt Exp $	*/
@


1.8
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_copyback.c,v 1.7 2002/12/16 07:01:03 tdeval Exp $	*/
d82 1
@


1.7
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_copyback.c,v 1.6 2000/08/08 16:07:39 peter Exp $	*/
d180 1
a180 1
		raidPtr->Disks[frow][fcol].numBlocks = dpart.part->p_size -
@


1.6
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_copyback.c,v 1.5 2000/01/11 18:02:20 peter Exp $	*/
d3 1
d31 2
a32 1
/*****************************************************************************************
d34 2
a35 2
 * copyback.c -- code to copy reconstructed data back from spare space to
 *               the replaced disk.
d37 3
a39 3
 * the code operates using callbacks on the I/Os to continue with the next
 * unit to be copied back.  We do this because a simple loop containing blocking I/Os
 * will not work in the simulator.
d41 1
a41 1
 ****************************************************************************************/
d59 2
a60 2
#define RF_COPYBACK_DATA   0
#define RF_COPYBACK_PARITY 1
d62 1
a62 1
int     rf_copyback_in_progress;
d64 8
a71 11
static int rf_CopybackReadDoneProc(RF_CopybackDesc_t * desc, int status);
static int rf_CopybackWriteDoneProc(RF_CopybackDesc_t * desc, int status);
static void rf_CopybackOne(RF_CopybackDesc_t * desc, int typ,
			   RF_RaidAddr_t addr, RF_RowCol_t testRow, 
			   RF_RowCol_t testCol,
    RF_SectorNum_t testOffs);
static void rf_CopybackComplete(RF_CopybackDesc_t * desc, int status);

int 
rf_ConfigureCopyback(listp)
	RF_ShutdownList_t **listp;
d76 1
d83 1
a83 1
#ifdef __NETBSD__
d87 4
a90 4
/* do a complete copyback */
void 
rf_CopybackReconstructedData(raidPtr)
	RF_Raid_t *raidPtr;
d93 1
a93 1
	int     done, retcode;
d97 1
a97 1
	char   *databuf;
d110 4
a113 2
			if (raidPtr->Disks[frow][fcol].status == rf_ds_dist_spared
			    || raidPtr->Disks[frow][fcol].status == rf_ds_spared) {
d123 1
a123 1
		printf("COPYBACK:  no disks need copyback\n");
d130 4
a133 2
	/* This device may have been opened successfully the first time. Close
	 * it before trying to open it again.. */
d136 1
a136 1
		printf("Closed the open device: %s\n",
d144 1
a144 1
 	/* note that this disk was *not* auto_configured (any longer) */
d146 2
a147 2
 
	printf("About to (re-)open the device: %s\n",
d153 1
a153 1
		printf("COPYBACK: raidlookup on device: %s failed: %d!\n",
d156 4
a159 2
		/* XXX the component isn't responding properly... must be
		 * still dead :-( */
d164 4
a167 2
		/* Ok, so we can at least do a lookup... How about actually
		 * getting a vp for it? */
d169 2
a170 1
		if ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {
d173 2
a174 2
		retcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) & dpart,
		    FREAD, proc->p_ucred, proc);
d186 2
a187 1
		raidPtr->Disks[frow][fcol].dev = va.va_rdev;	/* XXX or the above? */
d189 5
a193 3
		/* we allow the user to specify that only a fraction of the
		 * disks should be used this is just for debug:  it speeds up
		 * the parity scan */
d199 1
a199 1
	/* This is the way it was done before the CAM stuff was removed */
d202 2
a203 2
		printf("COPYBACK: unable to extract bus, target, lun from devname %s\n",
		    badDisk->devname);
d206 4
a209 2
	/* TUR the disk that's marked as bad to be sure that it's actually
	 * alive */
d216 1
a216 1
		printf("COPYBACK: target disk failed TUR\n");
d219 3
a221 2
	/* get a buffer to hold one SU  */
	RF_Malloc(databuf, rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit), (char *));
d223 1
a223 1
	/* create a descriptor */
d233 2
a234 1
	desc->sectPerStripe = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.numDataCol;
d238 5
a242 3
	printf("COPYBACK: Quiescing the array\n");
	/* quiesce the array, since we don't want to code support for user
	 * accs here */
d245 1
a245 1
	/* adjust state of the array and of the disks */
d249 1
a249 1
	rf_copyback_in_progress = 1;	/* debug only */
d256 10
a265 7
	/* Data has been restored.  Fix up the component label. */
	/* Don't actually need the read here.. */
	raidread_component_label( raidPtr->raid_cinfo[frow][fcol].ci_dev,
				  raidPtr->raid_cinfo[frow][fcol].ci_vp,
				  &c_label);
	
	raid_init_component_label( raidPtr, &c_label );
d270 3
a272 3
	raidwrite_component_label( raidPtr->raid_cinfo[frow][fcol].ci_dev,
				   raidPtr->raid_cinfo[frow][fcol].ci_vp,
				   &c_label);
d277 2
a278 2
 * invoked via callback after a copyback I/O has completed to
 * continue on with the next one
d280 2
a281 3
void 
rf_ContinueCopyback(desc)
	RF_CopybackDesc_t *desc;
d287 1
a287 1
	int     old_pctg, new_pctg, done;
d293 2
a294 2
		desc->raidPtr->copyback_stripes_done = stripeAddr
			/ desc->sectPerStripe;
d296 2
a297 1
			old_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;
d301 2
a302 1
			new_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;
d306 2
a307 1
				printf("%d %d.%06d\n", new_pctg, (int) diff.tv_sec, (int) diff.tv_usec);
d314 8
a321 5
		/* walk through the current stripe, su-by-su */
		for (done = 0, addr = stripeAddr; addr < stripeAddr + desc->sectPerStripe; addr += desc->sectPerSU) {

			/* map the SU, disallowing remap to spare space */
			(raidPtr->Layout.map->MapSector) (raidPtr, addr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);
d324 2
a325 1
				rf_CopybackOne(desc, RF_COPYBACK_DATA, addr, testRow, testCol, testOffs);
d332 11
a342 6
			/* we didn't find the failed disk in the data part.
			 * check parity. */

			/* map the parity for this stripe, disallowing remap
			 * to spare space */
			(raidPtr->Layout.map->MapParity) (raidPtr, stripeAddr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);
d345 2
a346 1
				rf_CopybackOne(desc, RF_COPYBACK_PARITY, stripeAddr, testRow, testCol, testOffs);
d349 1
a349 1
		/* check to see if the last read/write pair failed */
d354 4
a357 2
		/* we didn't find any units to copy back in this stripe.
		 * Continue with the next one */
d362 4
a365 9
/* copyback one unit */
static void 
rf_CopybackOne(desc, typ, addr, testRow, testCol, testOffs)
	RF_CopybackDesc_t *desc;
	int     typ;
	RF_RaidAddr_t addr;
	RF_RowCol_t testRow;
	RF_RowCol_t testCol;
	RF_SectorNum_t testOffs;
d373 1
a373 1
	/* find the spare spare location for this SU */
d376 2
a377 1
			raidPtr->Layout.map->MapSector(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);
d379 2
a380 1
			raidPtr->Layout.map->MapParity(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);
d385 1
a385 1
	/* create reqs to read the old location & write the new */
d387 3
a389 3
	    sectPerSU, desc->databuf, 0L, 0,
	    (int (*) (void *, int)) rf_CopybackReadDoneProc, desc,
	    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);
d391 3
a393 3
	    sectPerSU, desc->databuf, 0L, 0,
	    (int (*) (void *, int)) rf_CopybackWriteDoneProc, desc,
	    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);
d397 6
a402 4
	/* enqueue the read.  the write will go out as part of the callback on
	 * the read. at user-level & in the kernel, wait for the read-write
	 * pair to complete. in the simulator, just return, since everything
	 * will happen as callbacks */
d407 2
a408 1
	rf_DiskIOEnqueue(&raidPtr->Queues[spRow][spCol], desc->readreq, RF_IO_NORMAL_PRIORITY);
d420 6
a425 5
/* called at interrupt context when the read has completed.  just send out the write */
static int 
rf_CopybackReadDoneProc(desc, status)
	RF_CopybackDesc_t *desc;
	int     status;
d427 2
a428 2
	if (status) {		/* invoke the callback with bad status */
		printf("COPYBACK: copyback read failed.  Aborting.\n");
d431 3
a433 1
		rf_DiskIOEnqueue(&(desc->raidPtr->Queues[desc->frow][desc->fcol]), desc->writereq, RF_IO_NORMAL_PRIORITY);
d437 8
a444 4
/* called at interrupt context when the write has completed.
 * at user level & in the kernel, wake up the copyback thread.
 * in the simulator, invoke the next copyback directly.
 * can't free diskqueuedata structs in the kernel b/c we're at interrupt context.
d446 2
a447 4
static int 
rf_CopybackWriteDoneProc(desc, status)
	RF_CopybackDesc_t *desc;
	int     status;
d450 1
a450 1
		printf("COPYBACK: copyback write failed.  Aborting.\n");
d456 5
a460 5
/* invoked when the copyback has completed */
static void 
rf_CopybackComplete(desc, status)
	RF_CopybackDesc_t *desc;
	int     status;
d471 2
a472 1
			raidPtr->Disks[desc->spRow][desc->spCol].status = rf_ds_spare;
d478 1
a478 1
		printf("Copyback time was %d.%06d seconds\n",
@


1.6.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 2

/*****************************************************************************
d32 2
a33 2
 * copyback.c -- Code to copy reconstructed data back from spare space to
 *		 the replaced disk.
d35 3
a37 3
 * The code operates using callbacks on the I/Os to continue with the next
 * unit to be copied back. We do this because a simple loop containing
 * blocking I/Os will not work in the simulator.
d39 1
a39 1
 *****************************************************************************/
d57 2
a58 2
#define	RF_COPYBACK_DATA	0
#define	RF_COPYBACK_PARITY	1
d60 1
a60 1
int	rf_copyback_in_progress;
d62 11
a72 8
int  rf_CopybackReadDoneProc(RF_CopybackDesc_t *, int);
int  rf_CopybackWriteDoneProc(RF_CopybackDesc_t *, int);
void rf_CopybackOne(RF_CopybackDesc_t *, int, RF_RaidAddr_t,
	RF_RowCol_t, RF_RowCol_t, RF_SectorNum_t);
void rf_CopybackComplete(RF_CopybackDesc_t *, int);

int
rf_ConfigureCopyback(RF_ShutdownList_t **listp)
a76 1

d83 1
a83 1
#ifdef	__NETBSD__
d87 4
a90 4

/* Do a complete copyback. */
void
rf_CopybackReconstructedData(RF_Raid_t *raidPtr)
d93 1
a93 1
	int done, retcode;
d97 1
a97 1
	char *databuf;
d110 2
a111 4
			if (raidPtr->Disks[frow][fcol].status ==
			     rf_ds_dist_spared ||
			    raidPtr->Disks[frow][fcol].status ==
			     rf_ds_spared) {
d121 1
a121 1
		printf("COPYBACK: No disks need copyback.\n");
d128 2
a129 4
	/*
	 * This device may have been opened successfully the first time.
	 * Close it before trying to open it again.
	 */
d132 1
a132 1
		printf("Close the opened device: %s.\n",
d140 1
a140 1
 	/* Note that this disk was *not* auto_configured (any longer). */
d142 2
a143 2

	printf("About to (re-)open the device: %s.\n",
d149 1
a149 1
		printf("COPYBACK: raidlookup on device: %s failed: %d !\n",
d152 2
a153 4
		/*
		 * XXX The component isn't responding properly... Must be
		 * still dead :-(
		 */
d158 2
a159 4
		/*
		 * Ok, so we can at least do a lookup...
		 * How about actually getting a vp for it ?
		 */
d161 1
a161 2
		if ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0)
		{
d164 2
a165 2
		retcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) &dpart, FREAD,
		    proc->p_ucred, proc);
d177 1
a177 2
		/* XXX Or the above ? */
		raidPtr->Disks[frow][fcol].dev = va.va_rdev;
d179 3
a181 5
		/*
		 * We allow the user to specify that only a fraction of the
		 * disks should be used this is just for debug: it speeds up
		 * the parity scan.
		 */
d187 1
a187 1
	/* This is the way it was done before the CAM stuff was removed. */
d190 2
a191 2
		printf("COPYBACK: unable to extract bus, target, lun from"
		    " devname %s.\n", badDisk->devname);
d194 2
a195 4
	/*
	 * TUR the disk that's marked as bad to be sure that it's actually
	 * alive.
	 */
d202 1
a202 1
		printf("COPYBACK: target disk failed TUR.\n");
d205 2
a206 3
	/* Get a buffer to hold one SU. */
	RF_Malloc(databuf, rf_RaidAddressToByte(raidPtr,
	    raidPtr->Layout.sectorsPerStripeUnit), (char *));
d208 1
a208 1
	/* Create a descriptor. */
d218 1
a218 2
	desc->sectPerStripe = raidPtr->Layout.sectorsPerStripeUnit *
	    raidPtr->Layout.numDataCol;
d222 3
a224 5
	printf("COPYBACK: Quiescing the array.\n");
	/*
	 * Quiesce the array, since we don't want to code support for user
	 * accs here.
	 */
d227 1
a227 1
	/* Adjust state of the array and of the disks. */
d231 1
a231 1
	rf_copyback_in_progress = 1;	/* Debug only. */
d238 7
a244 10
	/*
	 * Data has been restored.
	 * Fix up the component label.
	 * Don't actually need the read here.
	 */
	raidread_component_label(raidPtr->raid_cinfo[frow][fcol].ci_dev,
				 raidPtr->raid_cinfo[frow][fcol].ci_vp,
				 &c_label);

	raid_init_component_label(raidPtr, &c_label);
d249 3
a251 3
	raidwrite_component_label(raidPtr->raid_cinfo[frow][fcol].ci_dev,
				  raidPtr->raid_cinfo[frow][fcol].ci_vp,
				  &c_label);
d256 2
a257 2
 * Invoked via callback after a copyback I/O has completed to
 * continue on with the next one.
d259 3
a261 2
void
rf_ContinueCopyback(RF_CopybackDesc_t *desc)
d267 1
a267 1
	int old_pctg, new_pctg, done;
d273 2
a274 2
		desc->raidPtr->copyback_stripes_done = stripeAddr /
		    desc->sectPerStripe;
d276 1
a276 2
			old_pctg = 100 * desc->stripeAddr /
			    raidPtr->totalSectors;
d280 1
a280 2
			new_pctg = 100 * desc->stripeAddr /
			    raidPtr->totalSectors;
d284 1
a284 2
				printf("%d %d.%06d\n", new_pctg,
				    (int) diff.tv_sec, (int) diff.tv_usec);
d291 5
a295 8
		/* Walk through the current stripe, su-by-su. */
		for (done = 0, addr = stripeAddr;
		     addr < stripeAddr + desc->sectPerStripe;
		     addr += desc->sectPerSU) {

			/* Map the SU, disallowing remap to spare space. */
			(raidPtr->Layout.map->MapSector) (raidPtr, addr,
			    &testRow, &testCol, &testOffs, RF_DONT_REMAP);
d298 1
a298 2
				rf_CopybackOne(desc, RF_COPYBACK_DATA, addr,
				    testRow, testCol, testOffs);
d305 6
a310 11
			/*
			 * We didn't find the failed disk in the data part,
			 * check parity.
			 */

			/*
			 * Map the parity for this stripe, disallowing remap
			 * to spare space.
			 */
			(raidPtr->Layout.map->MapParity) (raidPtr, stripeAddr,
			    &testRow, &testCol, &testOffs, RF_DONT_REMAP);
d313 1
a313 2
				rf_CopybackOne(desc, RF_COPYBACK_PARITY,
				    stripeAddr, testRow, testCol, testOffs);
d316 1
a316 1
		/* Check to see if the last read/write pair failed. */
d321 2
a322 4
		/*
		 * We didn't find any units to copy back in this stripe.
		 * Continue with the next one.
		 */
d327 9
a335 4
/* Copyback one unit. */
void
rf_CopybackOne(RF_CopybackDesc_t *desc, int typ, RF_RaidAddr_t addr,
    RF_RowCol_t testRow, RF_RowCol_t testCol, RF_SectorNum_t testOffs)
d343 1
a343 1
	/* Find the spare location for this SU. */
d346 1
a346 2
			raidPtr->Layout.map->MapSector(raidPtr, addr, &spRow,
			    &spCol, &spOffs, RF_REMAP);
d348 1
a348 2
			raidPtr->Layout.map->MapParity(raidPtr, addr, &spRow,
			    &spCol, &spOffs, RF_REMAP);
d353 1
a353 1
	/* Create reqs to read the old location & write the new. */
d355 3
a357 3
	    sectPerSU, desc->databuf, 0L, 0, (int (*) (void *, int))
	    rf_CopybackReadDoneProc, desc, NULL, NULL, (void *) raidPtr,
	    RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);
d359 3
a361 3
	    sectPerSU, desc->databuf, 0L, 0, (int (*) (void *, int))
	    rf_CopybackWriteDoneProc, desc, NULL, NULL, (void *) raidPtr,
	    RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);
d365 4
a368 6
	/*
	 * Enqueue the read. The write will go out as part of the callback on
	 * the read. At user-level & in the kernel, wait for the read-write
	 * pair to complete. In the simulator, just return, since everything
	 * will happen as callbacks.
	 */
d373 1
a373 2
	rf_DiskIOEnqueue(&raidPtr->Queues[spRow][spCol], desc->readreq,
	    RF_IO_NORMAL_PRIORITY);
d385 5
a389 6
/*
 * Called at interrupt context when the read has completed.
 * Just send out the write.
 */
int
rf_CopybackReadDoneProc(RF_CopybackDesc_t *desc, int status)
d391 2
a392 2
	if (status) {		/* Invoke the callback with bad status. */
		printf("COPYBACK: copyback read failed. Aborting.\n");
d395 1
a395 3
		rf_DiskIOEnqueue(&(desc->raidPtr
		    ->Queues[desc->frow][desc->fcol]),
		    desc->writereq, RF_IO_NORMAL_PRIORITY);
d399 4
a402 8


/*
 * Called at interrupt context when the write has completed.
 * At user level & in the kernel, wake up the copyback thread.
 * In the simulator, invoke the next copyback directly.
 * Can't free diskqueuedata structs in the kernel because we're at
 * interrupt context.
d404 4
a407 2
int
rf_CopybackWriteDoneProc(RF_CopybackDesc_t *desc, int status)
d410 1
a410 1
		printf("COPYBACK: copyback write failed. Aborting.\n");
d416 5
a420 5


/* Invoked when the copyback has completed. */
void
rf_CopybackComplete(RF_CopybackDesc_t *desc, int status)
d431 1
a431 2
			raidPtr->Disks[desc->spRow][desc->spCol].status =
			    rf_ds_spare;
d437 1
a437 1
		printf("Copyback time was %d.%06d seconds.\n",
@


1.5
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_copyback.c,v 1.4 2000/01/07 14:50:20 peter Exp $	*/
/*	$NetBSD: rf_copyback.c,v 1.12 2000/01/09 01:29:28 oster Exp $	*/
d104 2
d134 3
a136 3
		VOP_UNLOCK(raidPtr->raid_cinfo[frow][fcol].ci_vp, 0, proc);
		(void) vn_close(raidPtr->raid_cinfo[frow][fcol].ci_vp,
		    FREAD | FWRITE, proc->p_ucred, proc);
d138 1
d140 3
d243 3
a245 4
		
	c_label.version = RF_COMPONENT_LABEL_VERSION; 
	c_label.mod_counter = raidPtr->mod_counter;
	c_label.serial_number = raidPtr->serial_number;
d248 1
a248 5
	c_label.num_rows = raidPtr->numRow;
	c_label.num_columns = raidPtr->numCol;
	c_label.clean = RF_RAID_DIRTY;
	c_label.status = rf_ds_optimal;
	
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_copyback.c,v 1.6 2000/08/08 16:07:39 peter Exp $	*/
/*	$NetBSD: rf_copyback.c,v 1.14 2000/03/07 02:59:50 oster Exp $	*/
a103 2
	int ac;

d132 3
a134 3
 		vp = raidPtr->raid_cinfo[frow][fcol].ci_vp;
 		ac = raidPtr->Disks[frow][fcol].auto_configured;
 		rf_close_component(raidPtr, vp, ac);
a135 1

a136 3
 	/* note that this disk was *not* auto_configured (any longer) */
 	raidPtr->Disks[frow][fcol].auto_configured = 0;
 
d237 4
a240 3
	
	raid_init_component_label( raidPtr, &c_label );

d243 5
a247 1

@


1.5.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 2

/*****************************************************************************
d32 2
a33 2
 * copyback.c -- Code to copy reconstructed data back from spare space to
 *		 the replaced disk.
d35 3
a37 3
 * The code operates using callbacks on the I/Os to continue with the next
 * unit to be copied back. We do this because a simple loop containing
 * blocking I/Os will not work in the simulator.
d39 1
a39 1
 *****************************************************************************/
d57 2
a58 2
#define	RF_COPYBACK_DATA	0
#define	RF_COPYBACK_PARITY	1
d60 1
a60 1
int	rf_copyback_in_progress;
d62 11
a72 8
int  rf_CopybackReadDoneProc(RF_CopybackDesc_t *, int);
int  rf_CopybackWriteDoneProc(RF_CopybackDesc_t *, int);
void rf_CopybackOne(RF_CopybackDesc_t *, int, RF_RaidAddr_t,
	RF_RowCol_t, RF_RowCol_t, RF_SectorNum_t);
void rf_CopybackComplete(RF_CopybackDesc_t *, int);

int
rf_ConfigureCopyback(RF_ShutdownList_t **listp)
a76 1

d83 1
a83 1
#ifdef	__NETBSD__
d87 4
a90 4

/* Do a complete copyback. */
void
rf_CopybackReconstructedData(RF_Raid_t *raidPtr)
d93 1
a93 1
	int done, retcode;
d97 1
a97 1
	char *databuf;
d110 2
a111 4
			if (raidPtr->Disks[frow][fcol].status ==
			     rf_ds_dist_spared ||
			    raidPtr->Disks[frow][fcol].status ==
			     rf_ds_spared) {
d121 1
a121 1
		printf("COPYBACK: No disks need copyback.\n");
d128 2
a129 4
	/*
	 * This device may have been opened successfully the first time.
	 * Close it before trying to open it again.
	 */
d132 1
a132 1
		printf("Close the opened device: %s.\n",
d140 1
a140 1
 	/* Note that this disk was *not* auto_configured (any longer). */
d142 2
a143 2

	printf("About to (re-)open the device: %s.\n",
d149 1
a149 1
		printf("COPYBACK: raidlookup on device: %s failed: %d !\n",
d152 2
a153 4
		/*
		 * XXX The component isn't responding properly... Must be
		 * still dead :-(
		 */
d158 2
a159 4
		/*
		 * Ok, so we can at least do a lookup...
		 * How about actually getting a vp for it ?
		 */
d161 1
a161 2
		if ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0)
		{
d164 2
a165 2
		retcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t) &dpart, FREAD,
		    proc->p_ucred, proc);
d177 1
a177 2
		/* XXX Or the above ? */
		raidPtr->Disks[frow][fcol].dev = va.va_rdev;
d179 3
a181 5
		/*
		 * We allow the user to specify that only a fraction of the
		 * disks should be used this is just for debug: it speeds up
		 * the parity scan.
		 */
d187 1
a187 1
	/* This is the way it was done before the CAM stuff was removed. */
d190 2
a191 2
		printf("COPYBACK: unable to extract bus, target, lun from"
		    " devname %s.\n", badDisk->devname);
d194 2
a195 4
	/*
	 * TUR the disk that's marked as bad to be sure that it's actually
	 * alive.
	 */
d202 1
a202 1
		printf("COPYBACK: target disk failed TUR.\n");
d205 2
a206 3
	/* Get a buffer to hold one SU. */
	RF_Malloc(databuf, rf_RaidAddressToByte(raidPtr,
	    raidPtr->Layout.sectorsPerStripeUnit), (char *));
d208 1
a208 1
	/* Create a descriptor. */
d218 1
a218 2
	desc->sectPerStripe = raidPtr->Layout.sectorsPerStripeUnit *
	    raidPtr->Layout.numDataCol;
d222 3
a224 5
	printf("COPYBACK: Quiescing the array.\n");
	/*
	 * Quiesce the array, since we don't want to code support for user
	 * accs here.
	 */
d227 1
a227 1
	/* Adjust state of the array and of the disks. */
d231 1
a231 1
	rf_copyback_in_progress = 1;	/* Debug only. */
d238 7
a244 10
	/*
	 * Data has been restored.
	 * Fix up the component label.
	 * Don't actually need the read here.
	 */
	raidread_component_label(raidPtr->raid_cinfo[frow][fcol].ci_dev,
				 raidPtr->raid_cinfo[frow][fcol].ci_vp,
				 &c_label);

	raid_init_component_label(raidPtr, &c_label);
d249 3
a251 3
	raidwrite_component_label(raidPtr->raid_cinfo[frow][fcol].ci_dev,
				  raidPtr->raid_cinfo[frow][fcol].ci_vp,
				  &c_label);
d256 2
a257 2
 * Invoked via callback after a copyback I/O has completed to
 * continue on with the next one.
d259 3
a261 2
void
rf_ContinueCopyback(RF_CopybackDesc_t *desc)
d267 1
a267 1
	int old_pctg, new_pctg, done;
d273 2
a274 2
		desc->raidPtr->copyback_stripes_done = stripeAddr /
		    desc->sectPerStripe;
d276 1
a276 2
			old_pctg = 100 * desc->stripeAddr /
			    raidPtr->totalSectors;
d280 1
a280 2
			new_pctg = 100 * desc->stripeAddr /
			    raidPtr->totalSectors;
d284 1
a284 2
				printf("%d %d.%06d\n", new_pctg,
				    (int) diff.tv_sec, (int) diff.tv_usec);
d291 5
a295 8
		/* Walk through the current stripe, su-by-su. */
		for (done = 0, addr = stripeAddr;
		     addr < stripeAddr + desc->sectPerStripe;
		     addr += desc->sectPerSU) {

			/* Map the SU, disallowing remap to spare space. */
			(raidPtr->Layout.map->MapSector) (raidPtr, addr,
			    &testRow, &testCol, &testOffs, RF_DONT_REMAP);
d298 1
a298 2
				rf_CopybackOne(desc, RF_COPYBACK_DATA, addr,
				    testRow, testCol, testOffs);
d305 6
a310 11
			/*
			 * We didn't find the failed disk in the data part,
			 * check parity.
			 */

			/*
			 * Map the parity for this stripe, disallowing remap
			 * to spare space.
			 */
			(raidPtr->Layout.map->MapParity) (raidPtr, stripeAddr,
			    &testRow, &testCol, &testOffs, RF_DONT_REMAP);
d313 1
a313 2
				rf_CopybackOne(desc, RF_COPYBACK_PARITY,
				    stripeAddr, testRow, testCol, testOffs);
d316 1
a316 1
		/* Check to see if the last read/write pair failed. */
d321 2
a322 4
		/*
		 * We didn't find any units to copy back in this stripe.
		 * Continue with the next one.
		 */
d327 9
a335 4
/* Copyback one unit. */
void
rf_CopybackOne(RF_CopybackDesc_t *desc, int typ, RF_RaidAddr_t addr,
    RF_RowCol_t testRow, RF_RowCol_t testCol, RF_SectorNum_t testOffs)
d343 1
a343 1
	/* Find the spare location for this SU. */
d346 1
a346 2
			raidPtr->Layout.map->MapSector(raidPtr, addr, &spRow,
			    &spCol, &spOffs, RF_REMAP);
d348 1
a348 2
			raidPtr->Layout.map->MapParity(raidPtr, addr, &spRow,
			    &spCol, &spOffs, RF_REMAP);
d353 1
a353 1
	/* Create reqs to read the old location & write the new. */
d355 3
a357 3
	    sectPerSU, desc->databuf, 0L, 0, (int (*) (void *, int))
	    rf_CopybackReadDoneProc, desc, NULL, NULL, (void *) raidPtr,
	    RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);
d359 3
a361 3
	    sectPerSU, desc->databuf, 0L, 0, (int (*) (void *, int))
	    rf_CopybackWriteDoneProc, desc, NULL, NULL, (void *) raidPtr,
	    RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);
d365 4
a368 6
	/*
	 * Enqueue the read. The write will go out as part of the callback on
	 * the read. At user-level & in the kernel, wait for the read-write
	 * pair to complete. In the simulator, just return, since everything
	 * will happen as callbacks.
	 */
d373 1
a373 2
	rf_DiskIOEnqueue(&raidPtr->Queues[spRow][spCol], desc->readreq,
	    RF_IO_NORMAL_PRIORITY);
d385 5
a389 6
/*
 * Called at interrupt context when the read has completed.
 * Just send out the write.
 */
int
rf_CopybackReadDoneProc(RF_CopybackDesc_t *desc, int status)
d391 2
a392 2
	if (status) {		/* Invoke the callback with bad status. */
		printf("COPYBACK: copyback read failed. Aborting.\n");
d395 1
a395 3
		rf_DiskIOEnqueue(&(desc->raidPtr
		    ->Queues[desc->frow][desc->fcol]),
		    desc->writereq, RF_IO_NORMAL_PRIORITY);
d399 4
a402 8


/*
 * Called at interrupt context when the write has completed.
 * At user level & in the kernel, wake up the copyback thread.
 * In the simulator, invoke the next copyback directly.
 * Can't free diskqueuedata structs in the kernel because we're at
 * interrupt context.
d404 4
a407 2
int
rf_CopybackWriteDoneProc(RF_CopybackDesc_t *desc, int status)
d410 1
a410 1
		printf("COPYBACK: copyback write failed. Aborting.\n");
d416 5
a420 5


/* Invoked when the copyback has completed. */
void
rf_CopybackComplete(RF_CopybackDesc_t *desc, int status)
d431 1
a431 2
			raidPtr->Disks[desc->spRow][desc->spCol].status =
			    rf_ds_spare;
d437 1
a437 1
		printf("Copyback time was %d.%06d seconds.\n",
@


1.4
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_copyback.c,v 1.3 1999/07/30 14:45:32 peter Exp $	*/
/*	$NetBSD: rf_copyback.c,v 1.10 2000/01/05 02:57:28 oster Exp $	*/
a45 1
#include "rf_threadid.h"
d55 1
d64 3
a66 3
static void 
rf_CopybackOne(RF_CopybackDesc_t * desc, int typ,
    RF_RaidAddr_t addr, RF_RowCol_t testRow, RF_RowCol_t testCol,
a85 5

/* XXX these should be in a .h file somewhere */
int raidlookup __P((char *, struct proc *, struct vnode **));
int raidwrite_component_label __P((dev_t, struct vnode *, RF_ComponentLabel_t *));
int raidread_component_label __P((dev_t, struct vnode *, RF_ComponentLabel_t *));
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_copyback.c,v 1.2 1999/02/16 00:02:27 niklas Exp $	*/
/*	$NetBSD: rf_copyback.c,v 1.7 1999/03/02 03:18:49 oster Exp $	*/
a55 1
#include "rf_sys.h"
d129 1
a129 1
	proc = raidPtr->proc;	/* XXX Yes, this is not nice.. */
d277 2
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_copyback.c,v 1.1 1999/01/11 14:29:02 niklas Exp $	*/
/*	$NetBSD: rf_copyback.c,v 1.3 1999/02/05 00:06:06 oster Exp $	*/
d88 1
d90 2
d98 1
d138 1
d141 1
d237 20
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_copyback.c,v 1.1 1998/11/13 04:20:27 oster Exp $	*/
/*	$NetBSD: rf_copyback.c,v 1.1 1998/11/13 04:20:27 oster Exp $	*/
d35 1
a35 1
 * the code operates using callbacks on the I/Os to continue with the next 
d41 1
a41 105
/*
 * :  
 * Log: rf_copyback.c,v 
 * Revision 1.26  1996/08/06 22:26:00  jimz
 * don't include sys/buf.h on linux
 *
 * Revision 1.25  1996/07/30  03:30:40  jimz
 * include rf_types.h first
 *
 * Revision 1.24  1996/07/27  18:39:52  jimz
 * cleanup sweep
 *
 * Revision 1.23  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.22  1996/07/11  19:08:00  jimz
 * generalize reconstruction mechanism
 * allow raid1 reconstructs via copyback (done with array
 * quiesced, not online, therefore not disk-directed)
 *
 * Revision 1.21  1996/07/11  16:03:47  jimz
 * fixed hanging bug in rf_CopybackWriteDoneProc()
 *
 * Revision 1.20  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.19  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.18  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.17  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.16  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.15  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.14  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.13  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.12  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.11  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.10  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.9  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.8  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.7  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.6  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.5  1995/12/01  15:15:31  root
 * added copyright info
 *
 * Revision 1.4  1995/06/23  13:41:36  robby
 * updeated to prototypes in rf_layout.h
 *
 */
a42 1
#include "rf_types.h"
a43 1
#ifndef LINUX
a44 1
#endif /* !LINUX */
a52 3
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
#include "rf_camlayer.h"
#endif
d61 1
a61 8
int rf_copyback_in_progress;

static int  rf_CopybackReadDoneProc(RF_CopybackDesc_t *desc, int status);
static int  rf_CopybackWriteDoneProc(RF_CopybackDesc_t *desc, int status);
static void rf_CopybackOne(RF_CopybackDesc_t *desc, int typ,
	RF_RaidAddr_t addr, RF_RowCol_t testRow, RF_RowCol_t testCol,
	RF_SectorNum_t testOffs);
static void rf_CopybackComplete(RF_CopybackDesc_t *desc, int status);
d63 11
a73 2
int rf_ConfigureCopyback(listp)
  RF_ShutdownList_t  **listp;
d75 2
a76 2
  rf_copyback_in_progress = 0;
  return(0);
a77 2

#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
a88 1
#endif
d91 3
a93 2
void rf_CopybackReconstructedData(raidPtr)
  RF_Raid_t  *raidPtr;
d95 85
a179 47
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  int done,retcode;
  RF_CopybackDesc_t *desc;
  RF_RowCol_t frow, fcol;
  RF_RaidDisk_t *badDisk;
  char *databuf;

  struct partinfo dpart;
  struct vnode *vp;
  struct vattr va;
  struct proc *proc;

#else
  int bus, targ, lun, done, retcode;
  RF_CopybackDesc_t *desc;
  RF_RowCol_t frow, fcol;
  RF_RaidDisk_t *badDisk;
  RF_DiskOp_t *tur_op;
  char *databuf;
#endif

  done = 0;
  fcol = 0;
  for (frow=0; frow<raidPtr->numRow; frow++) {
    for (fcol=0; fcol<raidPtr->numCol; fcol++) {
      if (raidPtr->Disks[frow][fcol].status == rf_ds_dist_spared
        || raidPtr->Disks[frow][fcol].status == rf_ds_spared)
      {
        done = 1;
        break;
      }
    }
    if (done)
      break;
  }

  if (frow == raidPtr->numRow) {
    printf("COPYBACK:  no disks need copyback\n");
    return;
  }

  badDisk = &raidPtr->Disks[frow][fcol];
#ifndef SIMULATE
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)

  proc = raidPtr->proc;  /* XXX Yes, this is not nice.. */

d181 1
a181 3
  printf("Pretending the disk is happy...\n");
  retcode = 0;  /* XXX this should be set to something more realistic. */
#endif
d183 10
a192 66
  /* This device may have been opened successfully the first time. 
     Close it before trying to open it again.. */

  if (raidPtr->raid_cinfo[frow][fcol].ci_vp != NULL) {
	  printf("Closed the open device: %s\n",
		 raidPtr->Disks[frow][fcol].devname);
	  (void)vn_close(raidPtr->raid_cinfo[frow][fcol].ci_vp, 
			 FREAD|FWRITE,  proc->p_ucred, proc); 
  }

  printf("About to (re-)open the device: %s\n",
		 raidPtr->Disks[frow][fcol].devname);

  retcode = raidlookup(raidPtr->Disks[frow][fcol].devname, proc, &vp);

  if (retcode) {
	  printf("COPYBACK: raidlookup on device: %s failed: %d!\n",
		 raidPtr->Disks[frow][fcol].devname, retcode);

	  /* XXX the component isn't responding properly...
	     must be still dead :-( */
	  return;

  } else {
	  
	  /* Ok, so we can at least do a lookup... How about actually 
	     getting a vp for it? */

	  if ((retcode = VOP_GETATTR(vp, &va, proc->p_ucred, proc)) != 0) {
		  return;
	  } 

	  retcode = VOP_IOCTL(vp, DIOCGPART, (caddr_t)&dpart, 
			    FREAD, proc->p_ucred, proc);
	  if (retcode) {
		  return;
	  }
	  raidPtr->Disks[frow][fcol].blockSize = dpart.disklab->d_secsize;
		  
	  raidPtr->Disks[frow][fcol].numBlocks = dpart.part->p_size - 
			  rf_protectedSectors;
	  
	  raidPtr->raid_cinfo[frow][fcol].ci_vp = vp;
	  raidPtr->raid_cinfo[frow][fcol].ci_dev = va.va_rdev;

	  raidPtr->Disks[frow][fcol].dev = va.va_rdev; /* XXX or the above? */

	  /* we allow the user to specify that only a fraction of the 
	   * disks should be used this is just for debug:  it speeds up 
	   * the parity scan
	   */
	  raidPtr->Disks[frow][fcol].numBlocks = 
		  raidPtr->Disks[frow][fcol].numBlocks * 
		  rf_sizePercentage / 100;
  }
#else
  if (rf_extract_ids(badDisk->devname, &bus, &targ, &lun)) {
    printf("COPYBACK: unable to extract bus, target, lun from devname %s\n",
      badDisk->devname);
    return;
  }

  /* TUR the disk that's marked as bad to be sure that it's actually alive */
  rf_SCSI_AllocTUR(&tur_op);
  retcode = rf_SCSI_DoTUR(tur_op, bus, targ, lun, badDisk->dev);
  rf_SCSI_FreeDiskOp(tur_op, 0);
d195 36
a230 39
  if (retcode) {
    printf("COPYBACK: target disk failed TUR\n");
    return;
  }
#endif /* !SIMULATE */

  /* get a buffer to hold one SU  */
  RF_Malloc(databuf, rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit), (char *));

  /* create a descriptor */
  RF_Malloc(desc, sizeof(*desc), (RF_CopybackDesc_t *));
  desc->raidPtr       = raidPtr;
  desc->status        = 0;
  desc->frow          = frow;
  desc->fcol          = fcol;
  desc->spRow         = badDisk->spareRow;
  desc->spCol         = badDisk->spareCol;
  desc->stripeAddr    = 0;
  desc->sectPerSU     = raidPtr->Layout.sectorsPerStripeUnit;
  desc->sectPerStripe = raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.numDataCol;
  desc->databuf       = databuf;
#ifndef SIMULATE
  desc->mcpair        = rf_AllocMCPair();
#endif /* !SIMULATE */

  printf("COPYBACK: Quiescing the array\n");
  /* quiesce the array, since we don't want to code support for user accs here */
  rf_SuspendNewRequestsAndWait(raidPtr);

  /* adjust state of the array and of the disks */
  RF_LOCK_MUTEX(raidPtr->mutex);
  raidPtr->Disks[desc->frow][desc->fcol].status = rf_ds_optimal;
  raidPtr->status[desc->frow] = rf_rs_optimal;
  rf_copyback_in_progress = 1;                   /* debug only */
  RF_UNLOCK_MUTEX(raidPtr->mutex);
  
  printf("COPYBACK: Beginning\n");
  RF_GETTIME(desc->starttime);
  rf_ContinueCopyback(desc);
d238 3
a240 2
void rf_ContinueCopyback(desc)
  RF_CopybackDesc_t  *desc;
d242 59
a300 67
  RF_SectorNum_t testOffs, stripeAddr;
  RF_Raid_t *raidPtr = desc->raidPtr;
  RF_RaidAddr_t addr;
  RF_RowCol_t testRow, testCol; 
  int old_pctg, new_pctg, done;
  struct timeval t, diff;

  old_pctg = (-1);
  while (1) {
    stripeAddr = desc->stripeAddr;
    if (rf_prReconSched) {
      old_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;
    }
    desc->stripeAddr += desc->sectPerStripe;
    if (rf_prReconSched) {
      new_pctg = 100 * desc->stripeAddr / raidPtr->totalSectors;
      if (new_pctg != old_pctg) {
        RF_GETTIME(t);
        RF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);
        printf("%d %d.%06d\n",new_pctg, (int)diff.tv_sec, (int)diff.tv_usec);
      }
    }
    
    if (stripeAddr >= raidPtr->totalSectors) {
      rf_CopybackComplete(desc, 0);
      return;
    }
    
    /* walk through the current stripe, su-by-su */
    for (done=0, addr = stripeAddr; addr < stripeAddr+desc->sectPerStripe; addr += desc->sectPerSU) {
      
      /* map the SU, disallowing remap to spare space */
      (raidPtr->Layout.map->MapSector)(raidPtr, addr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);
      
      if (testRow == desc->frow && testCol == desc->fcol) {
        rf_CopybackOne(desc, RF_COPYBACK_DATA, addr, testRow, testCol, testOffs);
#ifdef SIMULATE
        return;
#else /* SIMULATE */
        done = 1;
        break;
#endif /* SIMULATE */
      }
    }

    if (!done) {
      /* we didn't find the failed disk in the data part.  check parity. */
    
      /* map the parity for this stripe, disallowing remap to spare space */
      (raidPtr->Layout.map->MapParity)(raidPtr, stripeAddr, &testRow, &testCol, &testOffs, RF_DONT_REMAP);
    
      if (testRow == desc->frow && testCol == desc->fcol) {
        rf_CopybackOne(desc, RF_COPYBACK_PARITY, stripeAddr, testRow, testCol, testOffs);
#ifdef SIMULATE
        return;
#endif /* SIMULATE */
      }
    }

    /* check to see if the last read/write pair failed */
    if (desc->status) {
      rf_CopybackComplete(desc, 1);
      return;
    }
    
    /* we didn't find any units to copy back in this stripe.  Continue with the next one */
  }
d305 8
a312 7
static void rf_CopybackOne(desc, typ, addr, testRow, testCol, testOffs)
  RF_CopybackDesc_t  *desc;
  int                 typ;
  RF_RaidAddr_t       addr;
  RF_RowCol_t         testRow;
  RF_RowCol_t         testCol;
  RF_SectorNum_t      testOffs;
d314 45
a358 47
  RF_SectorCount_t sectPerSU = desc->sectPerSU;
  RF_Raid_t *raidPtr = desc->raidPtr;
  RF_RowCol_t spRow     = desc->spRow;
  RF_RowCol_t spCol     = desc->spCol;
  RF_SectorNum_t spOffs;

  /* find the spare spare location for this SU */
  if (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {
    if (typ == RF_COPYBACK_DATA)
      raidPtr->Layout.map->MapSector(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);
    else
      raidPtr->Layout.map->MapParity(raidPtr, addr, &spRow, &spCol, &spOffs, RF_REMAP);      
  } else {
    spOffs = testOffs;
  }

  /* create reqs to read the old location & write the new */
  desc->readreq  = rf_CreateDiskQueueData(RF_IO_TYPE_READ, spOffs,
    sectPerSU, desc->databuf, 0L, 0, 
    (int (*)(void *,int)) rf_CopybackReadDoneProc, desc,
    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);
  desc->writereq = rf_CreateDiskQueueData(RF_IO_TYPE_WRITE, testOffs,
    sectPerSU, desc->databuf, 0L, 0, 
    (int (*)(void *,int)) rf_CopybackWriteDoneProc, desc,
    NULL, NULL, (void *) raidPtr, RF_DISKQUEUE_DATA_FLAGS_NONE, NULL);
  desc->frow = testRow;
  desc->fcol = testCol;
  
  /* enqueue the read.  the write will go out as part of the callback on the read.
   * at user-level & in the kernel, wait for the read-write pair to complete.
   * in the simulator, just return, since everything will happen as callbacks 
   */
#ifndef SIMULATE
  RF_LOCK_MUTEX(desc->mcpair->mutex);
  desc->mcpair->flag = 0;
#endif /* !SIMULATE */

  rf_DiskIOEnqueue(&raidPtr->Queues[spRow][spCol], desc->readreq, RF_IO_NORMAL_PRIORITY);
  
#ifndef SIMULATE
  while (!desc->mcpair->flag) {
    RF_WAIT_MCPAIR(desc->mcpair);
  }
  RF_UNLOCK_MUTEX(desc->mcpair->mutex);
  rf_FreeDiskQueueData(desc->readreq);
  rf_FreeDiskQueueData(desc->writereq);
#endif /* !SIMULATE */
d363 4
a366 3
static int rf_CopybackReadDoneProc(desc, status)
  RF_CopybackDesc_t  *desc;
  int                 status;
d368 7
a374 8
  if (status) {                                              /* invoke the callback with bad status */
    printf("COPYBACK: copyback read failed.  Aborting.\n");
    (desc->writereq->CompleteFunc)(desc, -100);
  }
  else {
    rf_DiskIOEnqueue(&(desc->raidPtr->Queues[desc->frow][desc->fcol]), desc->writereq, RF_IO_NORMAL_PRIORITY);
  }
  return(0);
d376 1
a376 2

/* called at interrupt context when the write has completed.  
d381 4
a384 3
static int rf_CopybackWriteDoneProc(desc, status)
  RF_CopybackDesc_t  *desc;
  int                 status;
d386 7
a392 18
  if (status && status != -100) {
    printf("COPYBACK: copyback write failed.  Aborting.\n");
  }

#ifdef SIMULATE
  rf_FreeDiskQueueData(desc->readreq);
  rf_FreeDiskQueueData(desc->writereq);
  if (!status)
    rf_ContinueCopyback(desc);
  else
    rf_CopybackComplete(desc, 1);
#else /* SIMULATE */
  desc->status = status;
  rf_MCPairWakeupFunc(desc->mcpair);
#endif /* SIMULATE */
  return(0);
}  

d394 4
a397 3
static void rf_CopybackComplete(desc, status)
  RF_CopybackDesc_t  *desc;
  int                 status;
d399 2
a400 2
  RF_Raid_t *raidPtr = desc->raidPtr;
  struct timeval t, diff;
d402 20
a421 21
  if (!status) {
    RF_LOCK_MUTEX(raidPtr->mutex);
    if (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {
      RF_ASSERT(raidPtr->Layout.map->parityConfig == 'D');
      rf_FreeSpareTable(raidPtr);
    } else {
      raidPtr->Disks[desc->spRow][desc->spCol].status = rf_ds_spare;
    }
    RF_UNLOCK_MUTEX(raidPtr->mutex);

    RF_GETTIME(t);
    RF_TIMEVAL_DIFF(&desc->starttime, &t, &diff);
    printf("Copyback time was %d.%06d seconds\n",
	   (int)diff.tv_sec, (int)diff.tv_usec);
  } else printf("COPYBACK: Failure.\n");

  RF_Free(desc->databuf, rf_RaidAddressToByte(raidPtr, desc->sectPerSU));
#ifndef SIMULATE
  rf_FreeMCPair(desc->mcpair);
#endif /* !SIMULATE */
  RF_Free(desc, sizeof(*desc));
d423 2
a424 2
  rf_copyback_in_progress = 0;
  rf_ResumeNewRequests(raidPtr);
@

