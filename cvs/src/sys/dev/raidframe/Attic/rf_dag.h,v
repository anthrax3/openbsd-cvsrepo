head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.38
	OPENBSD_5_0:1.4.0.36
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.18
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.3
	UBC:1.2.0.16
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.14
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.12
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.4;

1.4
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.28;	author niklas;	state Exp;
branches
	1.2.6.1
	1.2.16.1;
next	1.1;

1.1
date	99.01.11.14.29.06;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.2.16.1
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_dag.h,v 1.4 2002/12/16 07:01:03 tdeval Exp $	*/
/*	$NetBSD: rf_dag.h,v 1.3 1999/02/05 00:06:07 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: William V. Courtright II, Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/****************************************************************************
 *                                                                          *
 * dag.h -- header file for DAG-related data structures                     *
 *                                                                          *
 ****************************************************************************/

#ifndef	_RF__RF_DAG_H_
#define	_RF__RF_DAG_H_

#include "rf_types.h"
#include "rf_threadstuff.h"
#include "rf_alloclist.h"
#include "rf_stripelocks.h"
#include "rf_layout.h"
#include "rf_dagflags.h"
#include "rf_acctrace.h"
#include "rf_memchunk.h"

#define	RF_THREAD_CONTEXT   0	/* We were invoked from thread context. */
#define	RF_INTR_CONTEXT     1	/* We were invoked from interrupt context. */
#define	RF_MAX_ANTECEDENTS 20	/* Max num of antecedents a node may possess. */

#include <sys/buf.h>

struct RF_PropHeader_s {	/* Structure for propagation of results. */
	int		 resultNum;	/* Bind result # resultNum. */
	int		 paramNum;	/* To parameter # paramNum. */
	RF_PropHeader_t	*next;		/* Linked list for multiple
					 * results/params. */
};

typedef enum RF_NodeStatus_e {
	rf_bwd1,	/*
			 * Node is ready for undo logging
			 * (backward error recovery only).
			 */
	rf_bwd2,	/*
			 * Node has completed undo logging
			 * (backward error recovery only).
			 */
	rf_wait,	/* Node is waiting to be executed. */
	rf_fired,	/* Node is currently executing its do function. */
	rf_good,	/*
			 * Node successfully completed execution
			 * of its do function.
			 */
	rf_bad,		/*
			 * Node failed to successfully execute
			 * its do function.
			 */
	rf_skipped,	/*
			 * Not used anymore, used to imply a node
			 * was not executed.
			 */
	rf_recover,	/* Node is currently executing its undo function. */
	rf_panic,	/*
			 * Node failed to successfully execute
			 * its undo function.
			 */
	rf_undone	/* Node successfully executed its undo function. */
} RF_NodeStatus_t;

/*
 * These were used to control skipping a node.
 * Now, these are only used as comments.
 */
typedef enum RF_AntecedentType_e {
	rf_trueData,
	rf_antiData,
	rf_outputData,
	rf_control
} RF_AntecedentType_t;
#define	RF_DAG_PTRCACHESIZE	40
#define	RF_DAG_PARAMCACHESIZE	12

typedef RF_uint8 RF_DagNodeFlags_t;

struct RF_DagNode_s {
	RF_NodeStatus_t	  status;	/* Current status of this node. */
	int		(*doFunc) (RF_DagNode_t *);
					/* Normal function. */
	int		(*undoFunc) (RF_DagNode_t *);
					/* Func to remove effect of doFunc. */
	int		(*wakeFunc) (RF_DagNode_t *, int status);
					/*
					 * Func called when the node completes
					 * an I/O.
					 */
	int		  numParams;	/*
					 * Number of parameters required
					 * by *funcPtr.
					 */
	int		  numResults;	/*
					 * Number of results produced
					 * by *funcPtr.
					 */
	int		  numAntecedents; /* Number of antecedents. */
	int		  numAntDone;	/*
					 * Number of antecedents that
					 * have finished.
					 */
	int		  numSuccedents; /* Number of succedents. */
	int		  numSuccFired;	/*
					 * Incremented when a succedent
					 * is fired during forward execution.
					 */
	int		  numSuccDone;	/*
					 * Incremented when a succedent
					 * finishes during rollBackward.
					 */
	int		  commitNode;	/*
					 * Boolean flag - if true, this is
					 * a commit node.
					 */
	RF_DagNode_t	**succedents;	/*
					 * Succedents, array size
					 * numSuccedents.
					 */
	RF_DagNode_t	**antecedents;	/*
					 * Antecedents, array size
					 * numAntecedents.
					 */
	RF_AntecedentType_t antType[RF_MAX_ANTECEDENTS];
					/* Type of each antecedent. */
	void		**results;	/*
					 * Array of results produced
					 * by *funcPtr.
					 */
	RF_DagParam_t	 *params;	/*
					 * Array of parameters required
					 * by *funcPtr.
					 */
	RF_PropHeader_t	**propList;	/*
					 * Propagation list,
					 * size numSuccedents.
					 */
	RF_DagHeader_t	 *dagHdr;	/*
					 * Ptr to head of dag containing
					 * this node.
					 */
	void		 *dagFuncData;	/*
					 * Dag execution func uses this
					 * for whatever it wants.
					 */
	RF_DagNode_t	 *next;
	int		  nodeNum;	/* Used by PrintDAG for debug only. */
	int		  visited;	/*
					 * Used to avoid re-visiting
					 * nodes on DAG walks.
					 */
	/*
	 * ANY CODE THAT USES THIS FIELD MUST MAINTAIN THE PROPERTY THAT
	 * AFTER IT FINISHES, ALL VISITED FLAGS IN THE DAG ARE IDENTICAL.
	 */

	char		 *name;		/* Debug only. */
	RF_DagNodeFlags_t flags;	/* See below. */
	RF_DagNode_t	 *dag_ptrs[RF_DAG_PTRCACHESIZE];
					/* Cache for performance. */
	RF_DagParam_t	  dag_params[RF_DAG_PARAMCACHESIZE];
					/* Cache for performance. */
};

/*
 * Bit values for flags field of RF_DagNode_t.
 */
#define	RF_DAGNODE_FLAG_NONE	0x00
#define	RF_DAGNODE_FLAG_YIELD	0x01	/*
					 * In the kernel, yield the processor
					 * before firing this node.
					 */

/*
 * rf_enable	   - DAG ready for normal execution, no errors encountered.
 * rf_rollForward  - DAG encountered an error after commit point, rolling
 *		     forward.
 * rf_rollBackward - DAG encountered an error prior to commit point, rolling
 *		     backward.
 */
typedef enum RF_DagStatus_e {
	rf_enable,
	rf_rollForward,
	rf_rollBackward
} RF_DagStatus_t;

#define	RF_MAX_HDR_SUCC		 1

#define	RF_MAXCHUNKS		10

struct RF_DagHeader_s {
	RF_DagStatus_t	  status;		/* Status of this DAG. */
	int		  numSuccedents;	/*
						 * DAG may be a tree,
						 * i.e. may have > 1 root.
						 */
	int		  numCommitNodes;	/*
						 * Number of commit nodes
						 * in graph.
						 */
	int		  numCommits;		/*
						 * Number of commit nodes
						 * that have been fired.
						 */
	RF_DagNode_t	 *succedents[RF_MAX_HDR_SUCC];	/*
							 * Array of succedents,
							 * size numSuccedents.
							 */
	RF_DagHeader_t	 *next;			/*
						 * Ptr to allow a list
						 * of dags.
						 */
	RF_AllocListElem_t *allocList;		/*
						 * Ptr to list of ptrs
						 * to be freed prior to
						 * freeing DAG.
						 */
	RF_AccessStripeMapHeader_t *asmList;	/*
						 * List of access stripe maps
						 * to be freed.
						 */
	int		  nodeNum;		/*
						 * Used by PrintDAG for
						 * debug only.
						 */
	int		  numNodesCompleted;
	RF_AccTraceEntry_t *tracerec;		/* Perf mon only. */

	void		(*cbFunc) (void *);	/*
						 * Function to call when
						 * the dag completes.
						 */
	void		 *cbArg;		/* Argument for cbFunc. */
	char		 *creator;		/*
						 * Name of function used
						 * to create this dag.
						 */

	RF_Raid_t	 *raidPtr;		/*
						 * The descriptor for the
						 * RAID device this DAG
						 * is for.
						 */
	void		 *bp;			/*
						 * The bp for this I/O passed
						 * down from the file system.
						 * ignored outside kernel.
						 */

	RF_ChunkDesc_t	 *memChunk[RF_MAXCHUNKS]; /*
						 * Experimental- Chunks of
						 * memory to be retained upon
						 * DAG free for re-use.
						 */
	int		  chunkIndex;		/*
						 * The idea is to avoid calls
						 * to alloc and free.
						 */

	RF_ChunkDesc_t	**xtraMemChunk;		/*
						 * Escape hatch that allows
						 * SelectAlgorithm to merge
						 * memChunks from several dags.
						 */
	int		  xtraChunkIndex;	/*
						 * Number of ptrs to valid
						 * chunks.
						 */
	int		  xtraChunkCnt;		/*
						 * Number of ptrs to chunks
						 * allocated.
						 */
};

struct RF_DagList_s {
	/* Common info for a list of dags that will be fired sequentially. */
	int		 numDags;	/* Number of dags in the list. */
	int		 numDagsFired;	/*
					 * Number of dags in list that
					 * have initiated execution.
					 */
	int		 numDagsDone;	/*
					 * Number of dags in list that
					 * have completed execution.
					 */
	RF_DagHeader_t	*dags;		/* List of dags. */
	RF_RaidAccessDesc_t *desc;	/* Ptr to descriptor for this access. */
	RF_AccTraceEntry_t tracerec;	/*
					 * Perf mon info for dags (not user
					 * info).
					 */
};

/* Reset a node so that it can be fired again. */
#define	RF_ResetNode(_n_)	do {					\
	(_n_)->status = rf_wait;					\
	(_n_)->numAntDone = 0;						\
	(_n_)->numSuccFired = 0;					\
	(_n_)->numSuccDone = 0;						\
	(_n_)->next = NULL;						\
} while (0)

#define	RF_ResetDagHeader(_h_)	do {					\
	(_h_)->numNodesCompleted = 0;					\
	(_h_)->numCommits = 0;						\
	(_h_)->status = rf_enable;					\
} while (0)

/* Convenience macro for declaring a create dag function. */
#define	RF_CREATE_DAG_FUNC_DECL(_name_)					\
void _name_ (RF_Raid_t *, RF_AccessStripeMap_t *, RF_DagHeader_t *,	\
    void *, RF_RaidAccessFlags_t, RF_AllocListElem_t *);		\
void _name_ (								\
	RF_Raid_t		*raidPtr,				\
	RF_AccessStripeMap_t	*asmap,					\
	RF_DagHeader_t		*dag_h,					\
	void			*bp,					\
	RF_RaidAccessFlags_t	 flags,					\
	RF_AllocListElem_t	*allocList				\
)

#endif	/* !_RF__RF_DAG_H_ */
@


1.4
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dag.h,v 1.3 2002/06/14 21:34:59 todd Exp $	*/
@


1.3
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dag.h,v 1.2 1999/02/16 00:02:28 niklas Exp $	*/
d3 1
d37 2
a38 2
#ifndef _RF__RF_DAG_H_
#define _RF__RF_DAG_H_
d49 3
a51 3
#define RF_THREAD_CONTEXT   0	/* we were invoked from thread context */
#define RF_INTR_CONTEXT     1	/* we were invoked from interrupt context */
#define RF_MAX_ANTECEDENTS 20	/* max num of antecedents a node may posses */
d55 5
a59 4
struct RF_PropHeader_s {	/* structure for propagation of results */
	int     resultNum;	/* bind result # resultNum */
	int     paramNum;	/* to parameter # paramNum */
	RF_PropHeader_t *next;	/* linked list for multiple results/params */
d63 30
a92 19
	rf_bwd1,		/* node is ready for undo logging (backward
				 * error recovery only) */
	rf_bwd2,		/* node has completed undo logging (backward
				 * error recovery only) */
	rf_wait,		/* node is waiting to be executed */
	rf_fired,		/* node is currently executing its do function */
	rf_good,		/* node successfully completed execution of
				 * its do function */
	rf_bad,			/* node failed to successfully execute its do
				 * function */
	rf_skipped,		/* not used anymore, used to imply a node was
				 * not executed */
	rf_recover,		/* node is currently executing its undo
				 * function */
	rf_panic,		/* node failed to successfully execute its
				 * undo function */
	rf_undone		/* node successfully executed its undo
				 * function */
}       RF_NodeStatus_t;
d102 3
a104 3
}       RF_AntecedentType_t;
#define RF_DAG_PTRCACHESIZE   40
#define RF_DAG_PARAMCACHESIZE 12
d109 83
a191 40
	RF_NodeStatus_t status;	/* current status of this node */
	int     (*doFunc) (RF_DagNode_t *);	/* normal function */
	int     (*undoFunc) (RF_DagNode_t *);	/* func to remove effect of
						 * doFunc */
	int     (*wakeFunc) (RF_DagNode_t *, int status);	/* func called when the
								 * node completes an I/O */
	int     numParams;	/* number of parameters required by *funcPtr */
	int     numResults;	/* number of results produced by *funcPtr */
	int     numAntecedents;	/* number of antecedents */
	int     numAntDone;	/* number of antecedents which have finished */
	int     numSuccedents;	/* number of succedents */
	int     numSuccFired;	/* incremented when a succedent is fired
				 * during forward execution */
	int     numSuccDone;	/* incremented when a succedent finishes
				 * during rollBackward */
	int     commitNode;	/* boolean flag - if true, this is a commit
				 * node */
	RF_DagNode_t **succedents;	/* succedents, array size
					 * numSuccedents */
	RF_DagNode_t **antecedents;	/* antecedents, array size
					 * numAntecedents */
	RF_AntecedentType_t antType[RF_MAX_ANTECEDENTS];	/* type of each
								 * antecedent */
	void  **results;	/* array of results produced by *funcPtr */
	RF_DagParam_t *params;	/* array of parameters required by *funcPtr */
	RF_PropHeader_t **propList;	/* propagation list, size
					 * numSuccedents */
	RF_DagHeader_t *dagHdr;	/* ptr to head of dag containing this node */
	void   *dagFuncData;	/* dag execution func uses this for whatever
				 * it wants */
	RF_DagNode_t *next;
	int     nodeNum;	/* used by PrintDAG for debug only */
	int     visited;	/* used to avoid re-visiting nodes on DAG
				 * walks */
	/* ANY CODE THAT USES THIS FIELD MUST MAINTAIN THE PROPERTY THAT AFTER
	 * IT FINISHES, ALL VISITED FLAGS IN THE DAG ARE IDENTICAL */
	char   *name;		/* debug only */
	RF_DagNodeFlags_t flags;/* see below */
	RF_DagNode_t *dag_ptrs[RF_DAG_PTRCACHESIZE];	/* cache for performance */
	RF_DagParam_t dag_params[RF_DAG_PARAMCACHESIZE];	/* cache for performance */
d193 1
d195 1
a195 1
 * Bit values for flags field of RF_DagNode_t
d197 12
a208 7
#define RF_DAGNODE_FLAG_NONE  0x00
#define RF_DAGNODE_FLAG_YIELD 0x01	/* in the kernel, yield the processor
					 * before firing this node */

/* enable - DAG ready for normal execution, no errors encountered
 * rollForward - DAG encountered an error after commit point, rolling forward
 * rollBackward - DAG encountered an error prior to commit point, rolling backward
d214 3
a216 2
}       RF_DagStatus_t;
#define RF_MAX_HDR_SUCC 1
d218 1
a218 1
#define RF_MAXCHUNKS 10
d221 57
a277 25
	RF_DagStatus_t status;	/* status of this DAG */
	int     numSuccedents;	/* DAG may be a tree, i.e. may have > 1 root */
	int     numCommitNodes;	/* number of commit nodes in graph */
	int     numCommits;	/* number of commit nodes which have been
				 * fired  */
	RF_DagNode_t *succedents[RF_MAX_HDR_SUCC];	/* array of succedents,
							 * size numSuccedents */
	RF_DagHeader_t *next;	/* ptr to allow a list of dags */
	RF_AllocListElem_t *allocList;	/* ptr to list of ptrs to be freed
					 * prior to freeing DAG */
	RF_AccessStripeMapHeader_t *asmList;	/* list of access stripe maps
						 * to be freed */
	int     nodeNum;	/* used by PrintDAG for debug only */
	int     numNodesCompleted;
	RF_AccTraceEntry_t *tracerec;	/* perf mon only */

	void    (*cbFunc) (void *);	/* function to call when the dag
					 * completes */
	void   *cbArg;		/* argument for cbFunc */
	char   *creator;	/* name of function used to create this dag */

	RF_Raid_t *raidPtr;	/* the descriptor for the RAID device this DAG
				 * is for */
	void   *bp;		/* the bp for this I/O passed down from the
				 * file system. ignored outside kernel */
d279 2
a280 1
	RF_ChunkDesc_t *memChunk[RF_MAXCHUNKS];	/* experimental- Chunks of
d282 20
a301 10
						 * DAG free for re-use */
	int     chunkIndex;	/* the idea is to avoid calls to alloc and
				 * free */

	RF_ChunkDesc_t **xtraMemChunk;	/* escape hatch which allows
					 * SelectAlgorithm to merge memChunks
					 * from several dags */
	int     xtraChunkIndex;	/* number of ptrs to valid chunks */
	int     xtraChunkCnt;	/* number of ptrs to chunks allocated */

d305 16
a320 10
	/* common info for a list of dags which will be fired sequentially */
	int     numDags;	/* number of dags in the list */
	int     numDagsFired;	/* number of dags in list which have initiated
				 * execution */
	int     numDagsDone;	/* number of dags in list which have completed
				 * execution */
	RF_DagHeader_t *dags;	/* list of dags */
	RF_RaidAccessDesc_t *desc;	/* ptr to descriptor for this access */
	RF_AccTraceEntry_t tracerec;	/* perf mon info for dags (not user
					 * info) */
a321 25
/* resets a node so that it can be fired again */
#define RF_ResetNode(_n_)  { \
  (_n_)->status = rf_wait;   \
  (_n_)->numAntDone = 0;     \
  (_n_)->numSuccFired = 0;   \
  (_n_)->numSuccDone = 0;    \
  (_n_)->next = NULL;        \
}

#define RF_ResetDagHeader(_h_) { \
  (_h_)->numNodesCompleted = 0;  \
  (_h_)->numCommits = 0;         \
  (_h_)->status = rf_enable;     \
}

/* convenience macro for declaring a create dag function */

#define RF_CREATE_DAG_FUNC_DECL(_name_) \
void _name_ ( \
	RF_Raid_t             *raidPtr, \
	RF_AccessStripeMap_t  *asmap, \
	RF_DagHeader_t        *dag_h, \
	void                  *bp, \
	RF_RaidAccessFlags_t   flags, \
	RF_AllocListElem_t    *allocList)
d323 29
a351 1
#endif				/* !_RF__RF_DAG_H_ */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dag.h,v 1.1 1999/01/11 14:29:06 niklas Exp $	*/
d225 1
a225 1
/* convience macro for declaring a create dag function */
@


1.2.6.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d36 2
a37 2
#ifndef	_RF__RF_DAG_H_
#define	_RF__RF_DAG_H_
d48 3
a50 3
#define	RF_THREAD_CONTEXT   0	/* We were invoked from thread context. */
#define	RF_INTR_CONTEXT     1	/* We were invoked from interrupt context. */
#define	RF_MAX_ANTECEDENTS 20	/* Max num of antecedents a node may possess. */
d54 4
a57 5
struct RF_PropHeader_s {	/* Structure for propagation of results. */
	int		 resultNum;	/* Bind result # resultNum. */
	int		 paramNum;	/* To parameter # paramNum. */
	RF_PropHeader_t	*next;		/* Linked list for multiple
					 * results/params. */
d61 19
a79 30
	rf_bwd1,	/*
			 * Node is ready for undo logging
			 * (backward error recovery only).
			 */
	rf_bwd2,	/*
			 * Node has completed undo logging
			 * (backward error recovery only).
			 */
	rf_wait,	/* Node is waiting to be executed. */
	rf_fired,	/* Node is currently executing its do function. */
	rf_good,	/*
			 * Node successfully completed execution
			 * of its do function.
			 */
	rf_bad,		/*
			 * Node failed to successfully execute
			 * its do function.
			 */
	rf_skipped,	/*
			 * Not used anymore, used to imply a node
			 * was not executed.
			 */
	rf_recover,	/* Node is currently executing its undo function. */
	rf_panic,	/*
			 * Node failed to successfully execute
			 * its undo function.
			 */
	rf_undone	/* Node successfully executed its undo function. */
} RF_NodeStatus_t;

d89 3
a91 3
} RF_AntecedentType_t;
#define	RF_DAG_PTRCACHESIZE	40
#define	RF_DAG_PARAMCACHESIZE	12
d96 40
a135 83
	RF_NodeStatus_t	  status;	/* Current status of this node. */
	int		(*doFunc) (RF_DagNode_t *);
					/* Normal function. */
	int		(*undoFunc) (RF_DagNode_t *);
					/* Func to remove effect of doFunc. */
	int		(*wakeFunc) (RF_DagNode_t *, int status);
					/*
					 * Func called when the node completes
					 * an I/O.
					 */
	int		  numParams;	/*
					 * Number of parameters required
					 * by *funcPtr.
					 */
	int		  numResults;	/*
					 * Number of results produced
					 * by *funcPtr.
					 */
	int		  numAntecedents; /* Number of antecedents. */
	int		  numAntDone;	/*
					 * Number of antecedents that
					 * have finished.
					 */
	int		  numSuccedents; /* Number of succedents. */
	int		  numSuccFired;	/*
					 * Incremented when a succedent
					 * is fired during forward execution.
					 */
	int		  numSuccDone;	/*
					 * Incremented when a succedent
					 * finishes during rollBackward.
					 */
	int		  commitNode;	/*
					 * Boolean flag - if true, this is
					 * a commit node.
					 */
	RF_DagNode_t	**succedents;	/*
					 * Succedents, array size
					 * numSuccedents.
					 */
	RF_DagNode_t	**antecedents;	/*
					 * Antecedents, array size
					 * numAntecedents.
					 */
	RF_AntecedentType_t antType[RF_MAX_ANTECEDENTS];
					/* Type of each antecedent. */
	void		**results;	/*
					 * Array of results produced
					 * by *funcPtr.
					 */
	RF_DagParam_t	 *params;	/*
					 * Array of parameters required
					 * by *funcPtr.
					 */
	RF_PropHeader_t	**propList;	/*
					 * Propagation list,
					 * size numSuccedents.
					 */
	RF_DagHeader_t	 *dagHdr;	/*
					 * Ptr to head of dag containing
					 * this node.
					 */
	void		 *dagFuncData;	/*
					 * Dag execution func uses this
					 * for whatever it wants.
					 */
	RF_DagNode_t	 *next;
	int		  nodeNum;	/* Used by PrintDAG for debug only. */
	int		  visited;	/*
					 * Used to avoid re-visiting
					 * nodes on DAG walks.
					 */
	/*
	 * ANY CODE THAT USES THIS FIELD MUST MAINTAIN THE PROPERTY THAT
	 * AFTER IT FINISHES, ALL VISITED FLAGS IN THE DAG ARE IDENTICAL.
	 */

	char		 *name;		/* Debug only. */
	RF_DagNodeFlags_t flags;	/* See below. */
	RF_DagNode_t	 *dag_ptrs[RF_DAG_PTRCACHESIZE];
					/* Cache for performance. */
	RF_DagParam_t	  dag_params[RF_DAG_PARAMCACHESIZE];
					/* Cache for performance. */
a136 1

d138 1
a138 1
 * Bit values for flags field of RF_DagNode_t.
d140 7
a146 12
#define	RF_DAGNODE_FLAG_NONE	0x00
#define	RF_DAGNODE_FLAG_YIELD	0x01	/*
					 * In the kernel, yield the processor
					 * before firing this node.
					 */

/*
 * rf_enable	   - DAG ready for normal execution, no errors encountered.
 * rf_rollForward  - DAG encountered an error after commit point, rolling
 *		     forward.
 * rf_rollBackward - DAG encountered an error prior to commit point, rolling
 *		     backward.
d152 2
a153 3
} RF_DagStatus_t;

#define	RF_MAX_HDR_SUCC		 1
d155 1
a155 1
#define	RF_MAXCHUNKS		10
d158 25
a182 57
	RF_DagStatus_t	  status;		/* Status of this DAG. */
	int		  numSuccedents;	/*
						 * DAG may be a tree,
						 * i.e. may have > 1 root.
						 */
	int		  numCommitNodes;	/*
						 * Number of commit nodes
						 * in graph.
						 */
	int		  numCommits;		/*
						 * Number of commit nodes
						 * that have been fired.
						 */
	RF_DagNode_t	 *succedents[RF_MAX_HDR_SUCC];	/*
							 * Array of succedents,
							 * size numSuccedents.
							 */
	RF_DagHeader_t	 *next;			/*
						 * Ptr to allow a list
						 * of dags.
						 */
	RF_AllocListElem_t *allocList;		/*
						 * Ptr to list of ptrs
						 * to be freed prior to
						 * freeing DAG.
						 */
	RF_AccessStripeMapHeader_t *asmList;	/*
						 * List of access stripe maps
						 * to be freed.
						 */
	int		  nodeNum;		/*
						 * Used by PrintDAG for
						 * debug only.
						 */
	int		  numNodesCompleted;
	RF_AccTraceEntry_t *tracerec;		/* Perf mon only. */

	void		(*cbFunc) (void *);	/*
						 * Function to call when
						 * the dag completes.
						 */
	void		 *cbArg;		/* Argument for cbFunc. */
	char		 *creator;		/*
						 * Name of function used
						 * to create this dag.
						 */

	RF_Raid_t	 *raidPtr;		/*
						 * The descriptor for the
						 * RAID device this DAG
						 * is for.
						 */
	void		 *bp;			/*
						 * The bp for this I/O passed
						 * down from the file system.
						 * ignored outside kernel.
						 */
d184 1
a184 2
	RF_ChunkDesc_t	 *memChunk[RF_MAXCHUNKS]; /*
						 * Experimental- Chunks of
d186 10
a195 20
						 * DAG free for re-use.
						 */
	int		  chunkIndex;		/*
						 * The idea is to avoid calls
						 * to alloc and free.
						 */

	RF_ChunkDesc_t	**xtraMemChunk;		/*
						 * Escape hatch that allows
						 * SelectAlgorithm to merge
						 * memChunks from several dags.
						 */
	int		  xtraChunkIndex;	/*
						 * Number of ptrs to valid
						 * chunks.
						 */
	int		  xtraChunkCnt;		/*
						 * Number of ptrs to chunks
						 * allocated.
						 */
d199 10
a208 16
	/* Common info for a list of dags that will be fired sequentially. */
	int		 numDags;	/* Number of dags in the list. */
	int		 numDagsFired;	/*
					 * Number of dags in list that
					 * have initiated execution.
					 */
	int		 numDagsDone;	/*
					 * Number of dags in list that
					 * have completed execution.
					 */
	RF_DagHeader_t	*dags;		/* List of dags. */
	RF_RaidAccessDesc_t *desc;	/* Ptr to descriptor for this access. */
	RF_AccTraceEntry_t tracerec;	/*
					 * Perf mon info for dags (not user
					 * info).
					 */
d210 25
d236 1
a236 29
/* Reset a node so that it can be fired again. */
#define	RF_ResetNode(_n_)	do {					\
	(_n_)->status = rf_wait;					\
	(_n_)->numAntDone = 0;						\
	(_n_)->numSuccFired = 0;					\
	(_n_)->numSuccDone = 0;						\
	(_n_)->next = NULL;						\
} while (0)

#define	RF_ResetDagHeader(_h_)	do {					\
	(_h_)->numNodesCompleted = 0;					\
	(_h_)->numCommits = 0;						\
	(_h_)->status = rf_enable;					\
} while (0)

/* Convenience macro for declaring a create dag function. */
#define	RF_CREATE_DAG_FUNC_DECL(_name_)					\
void _name_ (RF_Raid_t *, RF_AccessStripeMap_t *, RF_DagHeader_t *,	\
    void *, RF_RaidAccessFlags_t, RF_AllocListElem_t *);		\
void _name_ (								\
	RF_Raid_t		*raidPtr,				\
	RF_AccessStripeMap_t	*asmap,					\
	RF_DagHeader_t		*dag_h,					\
	void			*bp,					\
	RF_RaidAccessFlags_t	 flags,					\
	RF_AllocListElem_t	*allocList				\
)

#endif	/* !_RF__RF_DAG_H_ */
@


1.2.16.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dag.h,v 1.2 1999/02/16 00:02:28 niklas Exp $	*/
d225 1
a225 1
/* convenience macro for declaring a create dag function */
@


1.2.16.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d36 2
a37 2
#ifndef	_RF__RF_DAG_H_
#define	_RF__RF_DAG_H_
d48 3
a50 3
#define	RF_THREAD_CONTEXT   0	/* We were invoked from thread context. */
#define	RF_INTR_CONTEXT     1	/* We were invoked from interrupt context. */
#define	RF_MAX_ANTECEDENTS 20	/* Max num of antecedents a node may possess. */
d54 4
a57 5
struct RF_PropHeader_s {	/* Structure for propagation of results. */
	int		 resultNum;	/* Bind result # resultNum. */
	int		 paramNum;	/* To parameter # paramNum. */
	RF_PropHeader_t	*next;		/* Linked list for multiple
					 * results/params. */
d61 19
a79 30
	rf_bwd1,	/*
			 * Node is ready for undo logging
			 * (backward error recovery only).
			 */
	rf_bwd2,	/*
			 * Node has completed undo logging
			 * (backward error recovery only).
			 */
	rf_wait,	/* Node is waiting to be executed. */
	rf_fired,	/* Node is currently executing its do function. */
	rf_good,	/*
			 * Node successfully completed execution
			 * of its do function.
			 */
	rf_bad,		/*
			 * Node failed to successfully execute
			 * its do function.
			 */
	rf_skipped,	/*
			 * Not used anymore, used to imply a node
			 * was not executed.
			 */
	rf_recover,	/* Node is currently executing its undo function. */
	rf_panic,	/*
			 * Node failed to successfully execute
			 * its undo function.
			 */
	rf_undone	/* Node successfully executed its undo function. */
} RF_NodeStatus_t;

d89 3
a91 3
} RF_AntecedentType_t;
#define	RF_DAG_PTRCACHESIZE	40
#define	RF_DAG_PARAMCACHESIZE	12
d96 40
a135 83
	RF_NodeStatus_t	  status;	/* Current status of this node. */
	int		(*doFunc) (RF_DagNode_t *);
					/* Normal function. */
	int		(*undoFunc) (RF_DagNode_t *);
					/* Func to remove effect of doFunc. */
	int		(*wakeFunc) (RF_DagNode_t *, int status);
					/*
					 * Func called when the node completes
					 * an I/O.
					 */
	int		  numParams;	/*
					 * Number of parameters required
					 * by *funcPtr.
					 */
	int		  numResults;	/*
					 * Number of results produced
					 * by *funcPtr.
					 */
	int		  numAntecedents; /* Number of antecedents. */
	int		  numAntDone;	/*
					 * Number of antecedents that
					 * have finished.
					 */
	int		  numSuccedents; /* Number of succedents. */
	int		  numSuccFired;	/*
					 * Incremented when a succedent
					 * is fired during forward execution.
					 */
	int		  numSuccDone;	/*
					 * Incremented when a succedent
					 * finishes during rollBackward.
					 */
	int		  commitNode;	/*
					 * Boolean flag - if true, this is
					 * a commit node.
					 */
	RF_DagNode_t	**succedents;	/*
					 * Succedents, array size
					 * numSuccedents.
					 */
	RF_DagNode_t	**antecedents;	/*
					 * Antecedents, array size
					 * numAntecedents.
					 */
	RF_AntecedentType_t antType[RF_MAX_ANTECEDENTS];
					/* Type of each antecedent. */
	void		**results;	/*
					 * Array of results produced
					 * by *funcPtr.
					 */
	RF_DagParam_t	 *params;	/*
					 * Array of parameters required
					 * by *funcPtr.
					 */
	RF_PropHeader_t	**propList;	/*
					 * Propagation list,
					 * size numSuccedents.
					 */
	RF_DagHeader_t	 *dagHdr;	/*
					 * Ptr to head of dag containing
					 * this node.
					 */
	void		 *dagFuncData;	/*
					 * Dag execution func uses this
					 * for whatever it wants.
					 */
	RF_DagNode_t	 *next;
	int		  nodeNum;	/* Used by PrintDAG for debug only. */
	int		  visited;	/*
					 * Used to avoid re-visiting
					 * nodes on DAG walks.
					 */
	/*
	 * ANY CODE THAT USES THIS FIELD MUST MAINTAIN THE PROPERTY THAT
	 * AFTER IT FINISHES, ALL VISITED FLAGS IN THE DAG ARE IDENTICAL.
	 */

	char		 *name;		/* Debug only. */
	RF_DagNodeFlags_t flags;	/* See below. */
	RF_DagNode_t	 *dag_ptrs[RF_DAG_PTRCACHESIZE];
					/* Cache for performance. */
	RF_DagParam_t	  dag_params[RF_DAG_PARAMCACHESIZE];
					/* Cache for performance. */
a136 1

d138 1
a138 1
 * Bit values for flags field of RF_DagNode_t.
d140 7
a146 12
#define	RF_DAGNODE_FLAG_NONE	0x00
#define	RF_DAGNODE_FLAG_YIELD	0x01	/*
					 * In the kernel, yield the processor
					 * before firing this node.
					 */

/*
 * rf_enable	   - DAG ready for normal execution, no errors encountered.
 * rf_rollForward  - DAG encountered an error after commit point, rolling
 *		     forward.
 * rf_rollBackward - DAG encountered an error prior to commit point, rolling
 *		     backward.
d152 2
a153 3
} RF_DagStatus_t;

#define	RF_MAX_HDR_SUCC		 1
d155 1
a155 1
#define	RF_MAXCHUNKS		10
d158 25
a182 57
	RF_DagStatus_t	  status;		/* Status of this DAG. */
	int		  numSuccedents;	/*
						 * DAG may be a tree,
						 * i.e. may have > 1 root.
						 */
	int		  numCommitNodes;	/*
						 * Number of commit nodes
						 * in graph.
						 */
	int		  numCommits;		/*
						 * Number of commit nodes
						 * that have been fired.
						 */
	RF_DagNode_t	 *succedents[RF_MAX_HDR_SUCC];	/*
							 * Array of succedents,
							 * size numSuccedents.
							 */
	RF_DagHeader_t	 *next;			/*
						 * Ptr to allow a list
						 * of dags.
						 */
	RF_AllocListElem_t *allocList;		/*
						 * Ptr to list of ptrs
						 * to be freed prior to
						 * freeing DAG.
						 */
	RF_AccessStripeMapHeader_t *asmList;	/*
						 * List of access stripe maps
						 * to be freed.
						 */
	int		  nodeNum;		/*
						 * Used by PrintDAG for
						 * debug only.
						 */
	int		  numNodesCompleted;
	RF_AccTraceEntry_t *tracerec;		/* Perf mon only. */

	void		(*cbFunc) (void *);	/*
						 * Function to call when
						 * the dag completes.
						 */
	void		 *cbArg;		/* Argument for cbFunc. */
	char		 *creator;		/*
						 * Name of function used
						 * to create this dag.
						 */

	RF_Raid_t	 *raidPtr;		/*
						 * The descriptor for the
						 * RAID device this DAG
						 * is for.
						 */
	void		 *bp;			/*
						 * The bp for this I/O passed
						 * down from the file system.
						 * ignored outside kernel.
						 */
d184 1
a184 2
	RF_ChunkDesc_t	 *memChunk[RF_MAXCHUNKS]; /*
						 * Experimental- Chunks of
d186 10
a195 20
						 * DAG free for re-use.
						 */
	int		  chunkIndex;		/*
						 * The idea is to avoid calls
						 * to alloc and free.
						 */

	RF_ChunkDesc_t	**xtraMemChunk;		/*
						 * Escape hatch that allows
						 * SelectAlgorithm to merge
						 * memChunks from several dags.
						 */
	int		  xtraChunkIndex;	/*
						 * Number of ptrs to valid
						 * chunks.
						 */
	int		  xtraChunkCnt;		/*
						 * Number of ptrs to chunks
						 * allocated.
						 */
d199 10
a208 16
	/* Common info for a list of dags that will be fired sequentially. */
	int		 numDags;	/* Number of dags in the list. */
	int		 numDagsFired;	/*
					 * Number of dags in list that
					 * have initiated execution.
					 */
	int		 numDagsDone;	/*
					 * Number of dags in list that
					 * have completed execution.
					 */
	RF_DagHeader_t	*dags;		/* List of dags. */
	RF_RaidAccessDesc_t *desc;	/* Ptr to descriptor for this access. */
	RF_AccTraceEntry_t tracerec;	/*
					 * Perf mon info for dags (not user
					 * info).
					 */
d210 25
d236 1
a236 29
/* Reset a node so that it can be fired again. */
#define	RF_ResetNode(_n_)	do {					\
	(_n_)->status = rf_wait;					\
	(_n_)->numAntDone = 0;						\
	(_n_)->numSuccFired = 0;					\
	(_n_)->numSuccDone = 0;						\
	(_n_)->next = NULL;						\
} while (0)

#define	RF_ResetDagHeader(_h_)	do {					\
	(_h_)->numNodesCompleted = 0;					\
	(_h_)->numCommits = 0;						\
	(_h_)->status = rf_enable;					\
} while (0)

/* Convenience macro for declaring a create dag function. */
#define	RF_CREATE_DAG_FUNC_DECL(_name_)					\
void _name_ (RF_Raid_t *, RF_AccessStripeMap_t *, RF_DagHeader_t *,	\
    void *, RF_RaidAccessFlags_t, RF_AllocListElem_t *);		\
void _name_ (								\
	RF_Raid_t		*raidPtr,				\
	RF_AccessStripeMap_t	*asmap,					\
	RF_DagHeader_t		*dag_h,					\
	void			*bp,					\
	RF_RaidAccessFlags_t	 flags,					\
	RF_AllocListElem_t	*allocList				\
)

#endif	/* !_RF__RF_DAG_H_ */
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dag.h,v 1.1 1998/11/13 04:20:27 oster Exp $	*/
/*	$NetBSD: rf_dag.h,v 1.1 1998/11/13 04:20:27 oster Exp $	*/
a34 100
/*
 *
 * :  
 * Log: rf_dag.h,v 
 * Revision 1.35  1996/11/05 18:38:37  jimz
 * add patch from galvarez@@cs.ucsd.edu (Guillermo Alvarez)
 * to fix dag_params memory-sizing problem (should be an array
 * of the type, not an array of pointers to the type)
 *
 * Revision 1.34  1996/07/28  20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.33  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.32  1996/06/10  22:22:13  wvcii
 * added two node status types for use in backward error
 * recovery experiments.
 *
 * Revision 1.31  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.30  1996/06/07  22:49:18  jimz
 * fix up raidPtr typing
 *
 * Revision 1.29  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.28  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.27  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.26  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.25  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.24  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.23  1996/05/16  23:05:20  jimz
 * Added dag_ptrs field, RF_DAG_PTRCACHESIZE
 *
 * The dag_ptrs field of the node is basically some scribble
 * space to be used here. We could get rid of it, and always
 * allocate the range of pointers, but that's expensive. So,
 * we pick a "common case" size for the pointer cache. Hopefully,
 * we'll find that:
 * (1) Generally, nptrs doesn't exceed RF_DAG_PTRCACHESIZE by
 *     only a little bit (least efficient case)
 * (2) Generally, ntprs isn't a lot less than RF_DAG_PTRCACHESIZE
 *     (wasted memory)
 *
 * Revision 1.22  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.21  1996/05/08  15:23:47  wvcii
 * added new node states:  undone, recover, panic
 *
 * Revision 1.20  1995/12/01  14:59:19  root
 * increased MAX_ANTECEDENTS from 10 to 20
 * should consider getting rid of this (eliminate static array)
 *
 * Revision 1.19  1995/11/30  15:58:59  wvcii
 * added copyright info
 *
 * Revision 1.18  1995/11/19  16:27:03  wvcii
 * created struct dagList
 *
 * Revision 1.17  1995/11/07  15:43:01  wvcii
 * added static array to DAGnode: antType
 * added commitNode type
 * added commit node counts to dag header
 * added ptr (firstDag) to support multi-dag requests
 * added succedent done/fired counts to nodes to support rollback
 * added node status type "skipped"
 * added hdr status types "rollForward, rollBackward"
 * deleted hdr status type "disable"
 * updated ResetNode & ResetDAGHeader to zero new fields
 *
 */
d48 3
a50 3
#define RF_THREAD_CONTEXT   0 /* we were invoked from thread context */
#define RF_INTR_CONTEXT     1 /* we were invoked from interrupt context */
#define RF_MAX_ANTECEDENTS 20 /* max num of antecedents a node may posses */
a51 1
#ifdef KERNEL
a52 1
#endif /* KERNEL */
d54 4
a57 4
struct RF_PropHeader_s { /* structure for propagation of results */
  int               resultNum; /* bind result # resultNum */
  int               paramNum;  /* to parameter # paramNum */
  RF_PropHeader_t  *next;      /* linked list for multiple results/params */
d61 19
a79 12
  rf_bwd1,    /* node is ready for undo logging (backward error recovery only) */
  rf_bwd2,    /* node has completed undo logging (backward error recovery only) */
  rf_wait,    /* node is waiting to be executed */
  rf_fired,   /* node is currently executing its do function */
  rf_good,    /* node successfully completed execution of its do function */
  rf_bad,     /* node failed to successfully execute its do function */
  rf_skipped, /* not used anymore, used to imply a node was not executed */
  rf_recover, /* node is currently executing its undo function */
  rf_panic,   /* node failed to successfully execute its undo function */
  rf_undone   /* node successfully executed its undo function */
} RF_NodeStatus_t;

d85 5
a89 6
  rf_trueData,
  rf_antiData,
  rf_outputData,
  rf_control
} RF_AntecedentType_t;

d96 40
a135 29
  RF_NodeStatus_t status;          /* current status of this node */
  int (*doFunc)(RF_DagNode_t *);   /* normal function */
  int (*undoFunc)(RF_DagNode_t *); /* func to remove effect of doFunc */
  int (*wakeFunc)(RF_DagNode_t *, int status);  /* func called when the node completes an I/O */
  int numParams;                /* number of parameters required by *funcPtr */
  int numResults;               /* number of results produced by *funcPtr */
  int numAntecedents;           /* number of antecedents */
  int numAntDone;               /* number of antecedents which have finished */
  int numSuccedents;            /* number of succedents */
  int numSuccFired;             /* incremented when a succedent is fired during forward execution */
  int numSuccDone;              /* incremented when a succedent finishes during rollBackward */
  int commitNode;               /* boolean flag - if true, this is a commit node */
  RF_DagNode_t **succedents;    /* succedents, array size numSuccedents */
  RF_DagNode_t **antecedents;   /* antecedents, array size numAntecedents */
  RF_AntecedentType_t antType[RF_MAX_ANTECEDENTS]; /* type of each antecedent */
  void **results;               /* array of results produced by *funcPtr */
  RF_DagParam_t *params;        /* array of parameters required by *funcPtr */
  RF_PropHeader_t **propList;   /* propagation list, size numSuccedents */
  RF_DagHeader_t *dagHdr;       /* ptr to head of dag containing this node */
  void *dagFuncData;            /* dag execution func uses this for whatever it wants */
  RF_DagNode_t *next;
  int nodeNum;                  /* used by PrintDAG for debug only */
  int visited;                  /* used to avoid re-visiting nodes on DAG walks */
                                /* ANY CODE THAT USES THIS FIELD MUST MAINTAIN THE PROPERTY
                                 * THAT AFTER IT FINISHES, ALL VISITED FLAGS IN THE DAG ARE IDENTICAL */
  char *name;                   /* debug only */
  RF_DagNodeFlags_t flags;      /* see below */
  RF_DagNode_t  *dag_ptrs[RF_DAG_PTRCACHESIZE];     /* cache for performance */
  RF_DagParam_t  dag_params[RF_DAG_PARAMCACHESIZE]; /* cache for performance */
a136 1

d141 2
a142 1
#define RF_DAGNODE_FLAG_YIELD 0x01 /* in the kernel, yield the processor before firing this node */
d149 4
a152 5
  rf_enable,
  rf_rollForward,
  rf_rollBackward
} RF_DagStatus_t;

d158 38
a195 29
  RF_DagStatus_t status;               /* status of this DAG */
  int numSuccedents;                   /* DAG may be a tree, i.e. may have > 1 root */
  int numCommitNodes;                  /* number of commit nodes in graph */
  int numCommits;                      /* number of commit nodes which have been fired  */
  RF_DagNode_t *succedents[RF_MAX_HDR_SUCC]; /* array of succedents, size numSuccedents */
  RF_DagHeader_t *next;                /* ptr to allow a list of dags */
  RF_AllocListElem_t *allocList;       /* ptr to list of ptrs to be freed prior to freeing DAG */
  RF_AccessStripeMapHeader_t *asmList; /* list of access stripe maps to be freed */
  int nodeNum;                         /* used by PrintDAG for debug only */
  int numNodesCompleted;
  RF_AccTraceEntry_t *tracerec;        /* perf mon only */

  void (*cbFunc)(void *);        /* function to call when the dag completes */
  void *cbArg;                         /* argument for cbFunc */
  char *creator;                       /* name of function used to create this dag */

  RF_Raid_t *raidPtr;                  /* the descriptor for the RAID device this DAG is for */
  void *bp;                            /* the bp for this I/O passed down from the file system. ignored outside kernel */

  RF_ChunkDesc_t *memChunk[RF_MAXCHUNKS]; /* experimental- Chunks of memory to be retained upon DAG free for re-use */
  int chunkIndex;                      /* the idea is to avoid calls to alloc and free */

  RF_ChunkDesc_t **xtraMemChunk;       /* escape hatch which allows SelectAlgorithm to merge memChunks from several dags */
  int xtraChunkIndex;                  /* number of ptrs to valid chunks */
  int xtraChunkCnt;                    /* number of ptrs to chunks allocated */

#ifdef SIMULATE
  int done;                            /* Tag to tell if termination node has been fired */
#endif /* SIMULATE */
d199 10
a208 7
  /* common info for a list of dags which will be fired sequentially */
  int numDags;                 /* number of dags in the list */
  int numDagsFired;            /* number of dags in list which have initiated execution */
  int numDagsDone;             /* number of dags in list which have completed execution */
  RF_DagHeader_t *dags;        /* list of dags */
  RF_RaidAccessDesc_t *desc;   /* ptr to descriptor for this access */
  RF_AccTraceEntry_t tracerec; /* perf mon info for dags (not user info) */
a209 1

a218 8
#ifdef SIMULATE
#define RF_ResetDagHeader(_h_) { \
  (_h_)->done = RF_FALSE;           \
  (_h_)->numNodesCompleted = 0;  \
  (_h_)->numCommits = 0;         \
  (_h_)->status = rf_enable;     \
}
#else /* SIMULATE */
a223 1
#endif /* SIMULATE */
d236 1
a236 1
#endif /* !_RF__RF_DAG_H_ */
@

