head	1.13;
access;
symbols
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2004.02.08.22.33.52;	author grange;	state dead;
branches;
next	1.12;

1.12
date	2003.06.02.23.28.03;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.09.17.20.07;	author fgsch;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2000.08.08.16.07.42;	author peter;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.01.07.14.50.21;	author peter;	state Exp;
branches;
next	1.4;

1.4
date	99.08.02.12.29.31;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.59;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.30;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.12;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.03.28.15.03.52;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.06.07.11.02.31;	author ho;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2004.06.05.23.12.56;	author niklas;	state dead;
branches;
next	;

1.8.4.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove unused files.
ok tdeval@@ millert@@ drahn@@
@
text
@/*	$OpenBSD: rf_netbsdkintf.c,v 1.12 2003/06/02 23:28:03 millert Exp $	*/
/*	$NetBSD: rf_netbsdkintf.c,v 1.93 2000/07/14 15:26:29 oster Exp $	*/
/*-
 * Copyright (c) 1996, 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Greg Oster; Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: cd.c 1.6 90/11/28$
 *
 *      @@(#)cd.c        8.2 (Berkeley) 11/16/93
 */




/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Authors: Mark Holland, Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/***********************************************************
 *
 * rf_kintf.c -- the kernel interface routines for RAIDframe
 *
 ***********************************************************/

#include <sys/errno.h>
#include <sys/param.h>
#include <sys/pool.h>
#include <sys/queue.h>
#include <sys/disk.h>
#include <sys/device.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/param.h>
#include <sys/types.h>
#include <machine/types.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/lock.h>
#include <sys/buf.h>
#include <sys/user.h>
#include <sys/reboot.h>

#include "raid.h"
#include "opt_raid_autoconfig.h"
#include "rf_raid.h"
#include "rf_raidframe.h"
#include "rf_copyback.h"
#include "rf_dag.h"
#include "rf_dagflags.h"
#include "rf_diskqueue.h"
#include "rf_acctrace.h"
#include "rf_etimer.h"
#include "rf_general.h"
#include "rf_debugMem.h"
#include "rf_kintf.h"
#include "rf_options.h"
#include "rf_driver.h"
#include "rf_parityscan.h"
#include "rf_debugprint.h"
#include "rf_threadstuff.h"
#include "rf_configure.h"

int     rf_kdebug_level = 0;

#ifdef DEBUG
#define db1_printf(a) if (rf_kdebug_level > 0) printf a
#else				/* DEBUG */
#define db1_printf(a) { }
#endif				/* DEBUG */

static RF_Raid_t **raidPtrs;	/* global raid device descriptors */

RF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex)

static RF_SparetWait_t *rf_sparet_wait_queue;	/* requests to install a
						 * spare table */
static RF_SparetWait_t *rf_sparet_resp_queue;	/* responses from
						 * installation process */

/* prototypes */
static void KernelWakeupFunc(struct buf * bp);
static void InitBP(struct buf * bp, struct vnode *, unsigned rw_flag, 
		   dev_t dev, RF_SectorNum_t startSect, 
		   RF_SectorCount_t numSect, caddr_t buf,
		   void (*cbFunc) (struct buf *), void *cbArg, 
		   int logBytesPerSector, struct proc * b_proc);
static void raidinit(RF_Raid_t *);

void raidattach(int);
int raidsize(dev_t);
int raidopen(dev_t, int, int, struct proc *);
int raidclose(dev_t, int, int, struct proc *);
int raidioctl(dev_t, u_long, caddr_t, int, struct proc *);
int raidwrite(dev_t, struct uio *, int);
int raidread(dev_t, struct uio *, int);
void raidstrategy(struct buf *);
int raiddump(dev_t, daddr_t, caddr_t, size_t);

/*
 * Pilfered from ccd.c
 */

struct raidbuf {
	struct buf rf_buf;	/* new I/O buf.  MUST BE FIRST!!! */
	struct buf *rf_obp;	/* ptr. to original I/O buf */
	int     rf_flags;	/* misc. flags */
	RF_DiskQueueData_t *req;/* the request that this was part of.. */
};


#define RAIDGETBUF(rs) pool_get(&(rs)->sc_cbufpool, PR_NOWAIT)
#define	RAIDPUTBUF(rs, cbp) pool_put(&(rs)->sc_cbufpool, cbp)

/* XXX Not sure if the following should be replacing the raidPtrs above,
   or if it should be used in conjunction with that... 
*/

struct raid_softc {
	int     sc_flags;	/* flags */
	int     sc_cflags;	/* configuration flags */
	size_t  sc_size;        /* size of the raid device */
	char    sc_xname[20];	/* XXX external name */
	struct disk sc_dkdev;	/* generic disk device info */
	struct pool sc_cbufpool;	/* component buffer pool */
	struct buf_queue buf_queue;	/* used for the device queue */
};
/* sc_flags */
#define RAIDF_INITED	0x01	/* unit has been initialized */
#define RAIDF_WLABEL	0x02	/* label area is writable */
#define RAIDF_LABELLING	0x04	/* unit is currently being labelled */
#define RAIDF_WANTED	0x40	/* someone is waiting to obtain a lock */
#define RAIDF_LOCKED	0x80	/* unit is locked */

#define	raidunit(x)	DISKUNIT(x)
int numraid = 0;

/* 
 * Allow RAIDOUTSTANDING number of simultaneous IO's to this RAID device. 
 * Be aware that large numbers can allow the driver to consume a lot of 
 * kernel memory, especially on writes, and in degraded mode reads.
 * 
 * For example: with a stripe width of 64 blocks (32k) and 5 disks, 
 * a single 64K write will typically require 64K for the old data, 
 * 64K for the old parity, and 64K for the new parity, for a total 
 * of 192K (if the parity buffer is not re-used immediately).
 * Even it if is used immedately, that's still 128K, which when multiplied
 * by say 10 requests, is 1280K, *on top* of the 640K of incoming data.
 * 
 * Now in degraded mode, for example, a 64K read on the above setup may
 * require data reconstruction, which will require *all* of the 4 remaining 
 * disks to participate -- 4 * 32K/disk == 128K again.
 */

#ifndef RAIDOUTSTANDING
#define RAIDOUTSTANDING   6
#endif

#define RAIDLABELDEV(dev)	\
	(MAKEDISKDEV(major((dev)), raidunit((dev)), RAW_PART))

/* declared here, and made public, for the benefit of KVM stuff.. */
struct raid_softc *raid_softc;

static void raidgetdefaultlabel(RF_Raid_t *, struct raid_softc *, 
				     struct disklabel *);
static void raidgetdisklabel(dev_t);
static void raidmakedisklabel(struct raid_softc *);

static int raidlock(struct raid_softc *);
static void raidunlock(struct raid_softc *);

static void rf_markalldirty(RF_Raid_t *);
void rf_mountroot_hook(struct device *);

struct device *raidrootdev;

void rf_ReconThread(struct rf_recon_req *);
/* XXX what I want is: */
/*void rf_ReconThread(RF_Raid_t *raidPtr);  */
void rf_RewriteParityThread(RF_Raid_t *raidPtr);
void rf_CopybackThread(RF_Raid_t *raidPtr);
void rf_ReconstructInPlaceThread(struct rf_recon_req *);
void rf_buildroothack(void *);

RF_AutoConfig_t *rf_find_raid_components(void);
RF_ConfigSet_t *rf_create_auto_sets(RF_AutoConfig_t *);
static int rf_does_it_fit(RF_ConfigSet_t *,RF_AutoConfig_t *);
static int rf_reasonable_label(RF_ComponentLabel_t *);
void rf_create_configuration(RF_AutoConfig_t *,RF_Config_t *,
				  RF_Raid_t *);
int rf_set_autoconfig(RF_Raid_t *, int);
int rf_set_rootpartition(RF_Raid_t *, int);
void rf_release_all_vps(RF_ConfigSet_t *);
void rf_cleanup_config_set(RF_ConfigSet_t *);
int rf_have_enough_components(RF_ConfigSet_t *);
int rf_auto_config_set(RF_ConfigSet_t *, int *);

static int raidautoconfig = 0; /* Debugging, mostly.  Set to 0 to not
				  allow autoconfig to take place.
			          Note that this is overridden by having
			          RAID_AUTOCONFIG as an option in the 
			          kernel config file.  */

void
raidattach(num)
	int     num;
{
	int raidID;
	int i, rc;
	RF_AutoConfig_t *ac_list; /* autoconfig list */
	RF_ConfigSet_t *config_sets;

#ifdef DEBUG
	printf("raidattach: Asked for %d units\n", num);
#endif

	if (num <= 0) {
#ifdef DIAGNOSTIC
		panic("raidattach: count <= 0");
#endif
		return;
	}
	/* This is where all the initialization stuff gets done. */

	numraid = num;

	/* Make some space for requested number of units... */

	RF_Calloc(raidPtrs, num, sizeof(RF_Raid_t *), (RF_Raid_t **));
	if (raidPtrs == NULL) {
		panic("raidPtrs is NULL!!");
	}
	
	rc = rf_mutex_init(&rf_sparet_wait_mutex);
	if (rc) {
		RF_PANIC();
	}

	rf_sparet_wait_queue = rf_sparet_resp_queue = NULL;

	for (i = 0; i < num; i++)
		raidPtrs[i] = NULL;
	rc = rf_BootRaidframe();
	if (rc == 0)
		printf("Kernelized RAIDframe activated\n");
	else
		panic("Serious error booting RAID!!");

	/* put together some datastructures like the CCD device does.. This
	 * lets us lock the device and what-not when it gets opened. */

	raid_softc = (struct raid_softc *)
	    malloc(num * sizeof(struct raid_softc),
		   M_RAIDFRAME, M_NOWAIT);
	if (raid_softc == NULL) {
		printf("WARNING: no memory for RAIDframe driver\n");
		return;
	}

	bzero(raid_softc, num * sizeof(struct raid_softc));
	
	raidrootdev = (struct device *)malloc(num * sizeof(struct device),
					      M_RAIDFRAME, M_NOWAIT);
	if (raidrootdev == NULL) {
		panic("No memory for RAIDframe driver!!?!?!");
	}

	for (raidID = 0; raidID < num; raidID++) {
		BUFQ_INIT(&raid_softc[raidID].buf_queue);

		raidrootdev[raidID].dv_class  = DV_DISK;
		raidrootdev[raidID].dv_cfdata = NULL;
		raidrootdev[raidID].dv_unit   = raidID;
		raidrootdev[raidID].dv_parent = NULL;
		raidrootdev[raidID].dv_flags  = 0;
		sprintf(raidrootdev[raidID].dv_xname,"raid%d",raidID);

		raid_softc[raidID].buf_queue.b_actf = NULL;
		raid_softc[raidID].buf_queue.b_actb = 
			&raid_softc[raidID].buf_queue.b_actf;
		RF_Calloc(raidPtrs[raidID], 1, sizeof(RF_Raid_t),
			  (RF_Raid_t *));
		if (raidPtrs[raidID] == NULL) {
			printf("WARNING: raidPtrs[%d] is NULL\n", raidID);
			numraid = raidID;
			return;
		}
	}

#if RAID_AUTOCONFIG
	raidautoconfig = 1;
#endif

if (raidautoconfig) {
	/* 1. locate all RAID components on the system */

#if DEBUG
	printf("Searching for raid components...\n");
#endif
	ac_list = rf_find_raid_components();

	/* 2. sort them into their respective sets */

	config_sets = rf_create_auto_sets(ac_list);

	/* 3. evaluate each set and configure the valid ones
	   This gets done in rf_buildroothack() */

	/* schedule the creation of the thread to do the 
	   "/ on RAID" stuff */

	kthread_create(rf_buildroothack,config_sets);

#if 0
	mountroothook_establish(rf_mountroot_hook, &raidrootdev[0]);
#endif
}

}

void
rf_buildroothack(arg)
	void *arg;
{
	RF_ConfigSet_t *config_sets = arg;
	RF_ConfigSet_t *cset;
	RF_ConfigSet_t *next_cset;
	int retcode;
	int raidID;
	int rootID;
	int num_root;

	num_root = 0;
	cset = config_sets;
	while(cset != NULL ) {
		next_cset = cset->next;
		if (rf_have_enough_components(cset) && 
		    cset->ac->clabel->autoconfigure==1) {
			retcode = rf_auto_config_set(cset,&raidID);
			if (!retcode) {
				if (cset->rootable) {
					rootID = raidID;
					num_root++;
				}
			} else {
				/* The autoconfig didn't work :( */
#if DEBUG
				printf("Autoconfig failed with code %d for raid%d\n", retcode, raidID);
#endif
				rf_release_all_vps(cset);
			}
		} else {
			/* we're not autoconfiguring this set...  
			   release the associated resources */
			rf_release_all_vps(cset);
		}
		/* cleanup */
		rf_cleanup_config_set(cset);
		cset = next_cset;
	}
	if (boothowto & RB_ASKNAME) {
		/* We don't auto-config... */
	} else {
		/* They didn't ask, and we found something bootable... */

		if (num_root == 1) {
			booted_device = &raidrootdev[rootID]; 
		} else if (num_root > 1) {
			/* we can't guess.. require the user to answer... */
			boothowto |= RB_ASKNAME;
		}
	}
}


int
raidsize(dev)
	dev_t   dev;
{
	struct raid_softc *rs;
	struct disklabel *lp;
	int     part, unit, omask, size;

	unit = raidunit(dev);
	if (unit >= numraid)
		return (-1);
	rs = &raid_softc[unit];

	if ((rs->sc_flags & RAIDF_INITED) == 0)
		return (-1);

	part = DISKPART(dev);
	omask = rs->sc_dkdev.dk_openmask & (1 << part);
	lp = rs->sc_dkdev.dk_label;

	if (omask == 0 && raidopen(dev, 0, S_IFBLK, curproc))
		return (-1);

	if (lp->d_partitions[part].p_fstype != FS_SWAP)
		size = -1;
	else
		size = lp->d_partitions[part].p_size *
		    (lp->d_secsize / DEV_BSIZE);

	if (omask == 0 && raidclose(dev, 0, S_IFBLK, curproc))
		return (-1);

	return (size);

}

int
raiddump(dev, blkno, va, size)
	dev_t   dev;
	daddr_t blkno;
	caddr_t va;
	size_t  size;
{
	/* Not implemented. */
	return ENXIO;
}
/* ARGSUSED */
int
raidopen(dev, flags, fmt, p)
	dev_t   dev;
	int     flags, fmt;
	struct proc *p;
{
	int     unit = raidunit(dev);
	struct raid_softc *rs;
	struct disklabel *lp;
	int     part, pmask;
	int     error = 0;

	if (unit >= numraid)
		return (ENXIO);
	rs = &raid_softc[unit];

	if ((error = raidlock(rs)) != 0)
		return (error);
	lp = rs->sc_dkdev.dk_label;

	part = DISKPART(dev);
	pmask = (1 << part);

	db1_printf(("Opening raid device number: %d partition: %d\n",
		unit, part));


	if ((rs->sc_flags & RAIDF_INITED) &&
	    (rs->sc_dkdev.dk_openmask == 0))
		raidgetdisklabel(dev);

	/* make sure that this partition exists */

	if (part != RAW_PART) {
		db1_printf(("Not a raw partition..\n"));
		if (((rs->sc_flags & RAIDF_INITED) == 0) ||
		    ((part >= lp->d_npartitions) ||
			(lp->d_partitions[part].p_fstype == FS_UNUSED))) {
			error = ENXIO;
			raidunlock(rs);
			db1_printf(("Bailing out...\n"));
			return (error);
		}
	}
	/* Prevent this unit from being unconfigured while open. */
	switch (fmt) {
	case S_IFCHR:
		rs->sc_dkdev.dk_copenmask |= pmask;
		break;

	case S_IFBLK:
		rs->sc_dkdev.dk_bopenmask |= pmask;
		break;
	}

	if ((rs->sc_dkdev.dk_openmask == 0) && 
	    ((rs->sc_flags & RAIDF_INITED) != 0)) {
		/* First one... mark things as dirty... Note that we *MUST*
		 have done a configure before this.  I DO NOT WANT TO BE
		 SCRIBBLING TO RANDOM COMPONENTS UNTIL IT'S BEEN DETERMINED
		 THAT THEY BELONG TOGETHER!!!!! */
		/* XXX should check to see if we're only open for reading
		   here... If so, we needn't do this, but then need some
		   other way of keeping track of what's happened.. */

		rf_markalldirty( raidPtrs[unit] );
	}


	rs->sc_dkdev.dk_openmask =
	    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;

	raidunlock(rs);

	return (error);


}
/* ARGSUSED */
int
raidclose(dev, flags, fmt, p)
	dev_t   dev;
	int     flags, fmt;
	struct proc *p;
{
	int     unit = raidunit(dev);
	struct raid_softc *rs;
	int     error = 0;
	int     part;

	if (unit >= numraid)
		return (ENXIO);
	rs = &raid_softc[unit];

	if ((error = raidlock(rs)) != 0)
		return (error);

	part = DISKPART(dev);

	/* ...that much closer to allowing unconfiguration... */
	switch (fmt) {
	case S_IFCHR:
		rs->sc_dkdev.dk_copenmask &= ~(1 << part);
		break;

	case S_IFBLK:
		rs->sc_dkdev.dk_bopenmask &= ~(1 << part);
		break;
	}
	rs->sc_dkdev.dk_openmask =
	    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;
	
	if ((rs->sc_dkdev.dk_openmask == 0) &&
	    ((rs->sc_flags & RAIDF_INITED) != 0)) {
		/* Last one... device is not unconfigured yet.  
		   Device shutdown has taken care of setting the 
		   clean bits if RAIDF_INITED is not set 
		   mark things as clean... */
#if 0
		printf("Last one on raid%d.  Updating status.\n",unit);
#endif
		rf_update_component_labels(raidPtrs[unit],
						 RF_FINAL_COMPONENT_UPDATE);
	}

	raidunlock(rs);
	return (0);

}

void
raidstrategy(bp)
	struct buf *bp;
{
	int s;

	unsigned int raidID = raidunit(bp->b_dev);
	RF_Raid_t *raidPtr;
	struct raid_softc *rs = &raid_softc[raidID];
	struct disklabel *lp;
	int     wlabel;

	if ((rs->sc_flags & RAIDF_INITED) ==0) {
		bp->b_error = ENXIO;
		bp->b_flags = B_ERROR;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
		return;
	}
	if (raidID >= numraid || !raidPtrs[raidID]) {
		bp->b_error = ENODEV;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
		return;
	}
	raidPtr = raidPtrs[raidID];
	if (!raidPtr->valid) {
		bp->b_error = ENODEV;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
		return;
	}
	if (bp->b_bcount == 0) {
		db1_printf(("b_bcount is zero..\n"));
		biodone(bp);
		return;
	}
	lp = rs->sc_dkdev.dk_label;

	/*
	 * Do bounds checking and adjust transfer.  If there's an
	 * error, the bounds check will flag that for us.
	 */

	wlabel = rs->sc_flags & (RAIDF_WLABEL | RAIDF_LABELLING);
	if (DISKPART(bp->b_dev) != RAW_PART)
		if (bounds_check_with_label(bp, lp, wlabel) <= 0) {
			db1_printf(("Bounds check failed!!:%d %d\n",
				(int) bp->b_blkno, (int) wlabel));
			biodone(bp);
			return;
		}
	s = splbio();

	bp->b_resid = 0;

	/* stuff it onto our queue */
	BUFQ_INSERT_TAIL(&rs->buf_queue, bp);

	raidstart(raidPtrs[raidID]);

	splx(s);
}
/* ARGSUSED */
int
raidread(dev, uio, flags)
	dev_t   dev;
	struct uio *uio;
	int     flags;
{
	int     unit = raidunit(dev);
	struct raid_softc *rs;
	int     part;

	if (unit >= numraid)
		return (ENXIO);
	rs = &raid_softc[unit];

	if ((rs->sc_flags & RAIDF_INITED) == 0)
		return (ENXIO);
	part = DISKPART(dev);

	db1_printf(("raidread: unit: %d partition: %d\n", unit, part));

	return (physio(raidstrategy, NULL, dev, B_READ, minphys, uio));

}
/* ARGSUSED */
int
raidwrite(dev, uio, flags)
	dev_t   dev;
	struct uio *uio;
	int     flags;
{
	int     unit = raidunit(dev);
	struct raid_softc *rs;

	if (unit >= numraid)
		return (ENXIO);
	rs = &raid_softc[unit];

	if ((rs->sc_flags & RAIDF_INITED) == 0)
		return (ENXIO);
	db1_printf(("raidwrite\n"));
	return (physio(raidstrategy, NULL, dev, B_WRITE, minphys, uio));

}

int
raidioctl(dev, cmd, data, flag, p)
	dev_t   dev;
	u_long  cmd;
	caddr_t data;
	int     flag;
	struct proc *p;
{
	int     unit = raidunit(dev);
	int     error = 0;
	int     part, pmask;
	struct raid_softc *rs;
	RF_Config_t *k_cfg, *u_cfg;
	RF_Raid_t *raidPtr;
	RF_RaidDisk_t *diskPtr;
	RF_AccTotals_t *totals;
	RF_DeviceConfig_t *d_cfg, **ucfgp;
	u_char *specific_buf;
	int retcode = 0;
	int row;
	int column;
	struct rf_recon_req *rrcopy, *rr;
	RF_ComponentLabel_t *clabel;
	RF_ComponentLabel_t ci_label;
	RF_ComponentLabel_t **clabel_ptr;
	RF_SingleComponent_t *sparePtr,*componentPtr;
	RF_SingleComponent_t hot_spare;
	RF_SingleComponent_t component;
	RF_ProgressInfo_t progressInfo, **progressInfoPtr;
	int i, j, d;

	if (unit >= numraid)
		return (ENXIO);
	rs = &raid_softc[unit];
	raidPtr = raidPtrs[unit];

	db1_printf(("raidioctl: %d %d %d %d\n", (int) dev,
		(int) DISKPART(dev), (int) unit, (int) cmd));

	/* Must be open for writes for these commands... */
	switch (cmd) {
	case DIOCSDINFO:
	case DIOCWDINFO:
	case DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			return (EBADF);
	}

	/* Must be initialized for these... */
	switch (cmd) {
	case DIOCGDINFO:
	case DIOCSDINFO:
	case DIOCWDINFO:
	case DIOCGPART:
	case DIOCWLABEL:
	case DIOCGDEFLABEL:
	case RAIDFRAME_SHUTDOWN:
	case RAIDFRAME_REWRITEPARITY:
	case RAIDFRAME_GET_INFO:
	case RAIDFRAME_RESET_ACCTOTALS:
	case RAIDFRAME_GET_ACCTOTALS:
	case RAIDFRAME_KEEP_ACCTOTALS:
	case RAIDFRAME_GET_SIZE:
	case RAIDFRAME_FAIL_DISK:
	case RAIDFRAME_COPYBACK:
	case RAIDFRAME_CHECK_RECON_STATUS:
	case RAIDFRAME_CHECK_RECON_STATUS_EXT:
	case RAIDFRAME_GET_COMPONENT_LABEL:
	case RAIDFRAME_SET_COMPONENT_LABEL:
	case RAIDFRAME_ADD_HOT_SPARE:
	case RAIDFRAME_REMOVE_HOT_SPARE:
	case RAIDFRAME_INIT_LABELS:
	case RAIDFRAME_REBUILD_IN_PLACE:
	case RAIDFRAME_CHECK_PARITY:
	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS:
	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT:
	case RAIDFRAME_CHECK_COPYBACK_STATUS:
	case RAIDFRAME_CHECK_COPYBACK_STATUS_EXT:
	case RAIDFRAME_SET_AUTOCONFIG:
	case RAIDFRAME_SET_ROOT:
	case RAIDFRAME_DELETE_COMPONENT:
	case RAIDFRAME_INCORPORATE_HOT_SPARE:
		if ((rs->sc_flags & RAIDF_INITED) == 0)
			return (ENXIO);
	}

	switch (cmd) {

		/* configure the system */
	case RAIDFRAME_CONFIGURE:

		if (raidPtr->valid) {
			/* There is a valid RAID set running on this unit! */
			printf("raid%d: Device already configured!\n",unit);
			return(EINVAL);
		}

		/* copy-in the configuration information */
		/* data points to a pointer to the configuration structure */

		u_cfg = *((RF_Config_t **) data);
		RF_Malloc(k_cfg, sizeof(RF_Config_t), (RF_Config_t *));
		if (k_cfg == NULL) {
			return (ENOMEM);
		}
		retcode = copyin((caddr_t) u_cfg, (caddr_t) k_cfg,
		    sizeof(RF_Config_t));
		if (retcode) {
			RF_Free(k_cfg, sizeof(RF_Config_t));
			db1_printf(("rf_ioctl: retcode=%d copyin.1\n",
				retcode));
			return (retcode);
		}
		/* allocate a buffer for the layout-specific data, and copy it
		 * in */
		if (k_cfg->layoutSpecificSize) {
			if (k_cfg->layoutSpecificSize > 10000) {
				/* sanity check */
				RF_Free(k_cfg, sizeof(RF_Config_t));
				return (EINVAL);
			}
			RF_Malloc(specific_buf, k_cfg->layoutSpecificSize,
			    (u_char *));
			if (specific_buf == NULL) {
				RF_Free(k_cfg, sizeof(RF_Config_t));
				return (ENOMEM);
			}
			retcode = copyin(k_cfg->layoutSpecific,
			    (caddr_t) specific_buf,
			    k_cfg->layoutSpecificSize);
			if (retcode) {
				RF_Free(k_cfg, sizeof(RF_Config_t));
				RF_Free(specific_buf, 
					k_cfg->layoutSpecificSize);
				db1_printf(("rf_ioctl: retcode=%d copyin.2\n",
					retcode));
				return (retcode);
			}
		} else
			specific_buf = NULL;
		k_cfg->layoutSpecific = specific_buf;

		/* should do some kind of sanity check on the configuration.
		 * Store the sum of all the bytes in the last byte? */

		/* configure the system */

		/*
		 * Clear the entire RAID descriptor, just to make sure
		 *  there is no stale data left in the case of a 
		 *  reconfiguration 
		 */
		bzero((char *) raidPtr, sizeof(RF_Raid_t));
		raidPtr->raidid = unit;

		retcode = rf_Configure(raidPtr, k_cfg, NULL);

		if (retcode == 0) {

			/* allow this many simultaneous IO's to 
			   this RAID device */
			raidPtr->openings = RAIDOUTSTANDING;
					
			raidinit(raidPtr);
			rf_markalldirty(raidPtr);
		}
		/* free the buffers.  No return code here. */
		if (k_cfg->layoutSpecificSize) {
			RF_Free(specific_buf, k_cfg->layoutSpecificSize);
		}
		RF_Free(k_cfg, sizeof(RF_Config_t));

		return (retcode);

		/* shutdown the system */
	case RAIDFRAME_SHUTDOWN:

		if ((error = raidlock(rs)) != 0)
			return (error);

		/*
		 * If somebody has a partition mounted, we shouldn't
		 * shutdown.
		 */

		part = DISKPART(dev);
		pmask = (1 << part);
		if ((rs->sc_dkdev.dk_openmask & ~pmask) ||
		    ((rs->sc_dkdev.dk_bopenmask & pmask) &&
			(rs->sc_dkdev.dk_copenmask & pmask))) {
			raidunlock(rs);
			return (EBUSY);
		}

		retcode = rf_Shutdown(raidPtr);

		pool_destroy(&rs->sc_cbufpool);

		/* It's no longer initialized... */
		rs->sc_flags &= ~RAIDF_INITED;

		/* Detach the disk. */
		disk_detach(&rs->sc_dkdev);

		raidunlock(rs);

		return (retcode);
	case RAIDFRAME_GET_COMPONENT_LABEL:
		clabel_ptr = (RF_ComponentLabel_t **) data;
		/* need to read the component label for the disk indicated
		   by row,column in clabel */

		/* For practice, let's get it directly fromdisk, rather 
		   than from the in-core copy */
		RF_Malloc( clabel, sizeof( RF_ComponentLabel_t ),
			   (RF_ComponentLabel_t *));
		if (clabel == NULL)
			return (ENOMEM);

		bzero((char *) clabel, sizeof(RF_ComponentLabel_t));
		
		retcode = copyin( *clabel_ptr, clabel, 
				  sizeof(RF_ComponentLabel_t));

		if (retcode) {
			RF_Free( clabel, sizeof(RF_ComponentLabel_t));
			return(retcode);
		}

		row = clabel->row;
		column = clabel->column;

		if ((row < 0) || (row >= raidPtr->numRow) ||
		    (column < 0) || (column >= raidPtr->numCol +
				     raidPtr->numSpare)) {
			RF_Free( clabel, sizeof(RF_ComponentLabel_t));
			return(EINVAL);
		}

		raidread_component_label(raidPtr->Disks[row][column].dev, 
				raidPtr->raid_cinfo[row][column].ci_vp, 
				clabel );

		retcode = copyout((caddr_t) clabel, 
				  (caddr_t) *clabel_ptr,
				  sizeof(RF_ComponentLabel_t));
		RF_Free( clabel, sizeof(RF_ComponentLabel_t));
		return (retcode);

	case RAIDFRAME_SET_COMPONENT_LABEL:
		clabel = (RF_ComponentLabel_t *) data;

		/* XXX check the label for valid stuff... */
		/* Note that some things *should not* get modified --
		   the user should be re-initing the labels instead of 
		   trying to patch things.
		   */

		printf("Got component label:\n");
		printf("Version: %d\n",clabel->version);
		printf("Serial Number: %d\n",clabel->serial_number);
		printf("Mod counter: %d\n",clabel->mod_counter);
		printf("Row: %d\n", clabel->row);
		printf("Column: %d\n", clabel->column);
		printf("Num Rows: %d\n", clabel->num_rows);
		printf("Num Columns: %d\n", clabel->num_columns);
		printf("Clean: %d\n", clabel->clean);
		printf("Status: %d\n", clabel->status);

		row = clabel->row;
		column = clabel->column;

		if ((row < 0) || (row >= raidPtr->numRow) ||
		    (column < 0) || (column >= raidPtr->numCol)) {
			return(EINVAL);
		}

		/* XXX this isn't allowed to do anything for now :-) */

		/* XXX and before it is, we need to fill in the rest
		   of the fields!?!?!?! */
#if 0
		raidwrite_component_label( 
                            raidPtr->Disks[row][column].dev, 
			    raidPtr->raid_cinfo[row][column].ci_vp, 
			    clabel );
#endif
		return (0);

	case RAIDFRAME_INIT_LABELS:	
		clabel = (RF_ComponentLabel_t *) data;
		/* 
		   we only want the serial number from
		   the above.  We get all the rest of the information
		   from the config that was used to create this RAID
		   set. 
		   */

		raidPtr->serial_number = clabel->serial_number;
		
		raid_init_component_label(raidPtr, &ci_label);
		ci_label.serial_number = clabel->serial_number;

		for(row=0;row<raidPtr->numRow;row++) {
			ci_label.row = row;
			for(column=0;column<raidPtr->numCol;column++) {
				diskPtr = &raidPtr->Disks[row][column];
				ci_label.partitionSize = diskPtr->partitionSize;
				ci_label.column = column;
				raidwrite_component_label( 
				  raidPtr->Disks[row][column].dev, 
				  raidPtr->raid_cinfo[row][column].ci_vp, 
				  &ci_label );
			}
		}

		return (retcode);
	case RAIDFRAME_SET_AUTOCONFIG:
		d = rf_set_autoconfig(raidPtr, *(int *) data);
		printf("New autoconfig value is: %d\n", d);
		*(int *) data = d;
		return (retcode);

	case RAIDFRAME_SET_ROOT:
		d = rf_set_rootpartition(raidPtr, *(int *) data);
		printf("New rootpartition value is: %d\n", d);
		*(int *) data = d;
		return (retcode);

		/* initialize all parity */
	case RAIDFRAME_REWRITEPARITY:

		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* Parity for RAID 0 is trivially correct */
			raidPtr->parity_good = RF_RAID_CLEAN;
			return(0);
		}

		if (raidPtr->parity_rewrite_in_progress == 1) {
			/* Re-write is already in progress! */
			return(EINVAL);
		}

		retcode = RF_CREATE_THREAD(raidPtr->parity_rewrite_thread,
					   rf_RewriteParityThread,
					   raidPtr,"raid_parity");
		return (retcode);


	case RAIDFRAME_ADD_HOT_SPARE:
		sparePtr = (RF_SingleComponent_t *) data;
		memcpy( &hot_spare, sparePtr, sizeof(RF_SingleComponent_t));
		retcode = rf_add_hot_spare(raidPtr, &hot_spare);
		return(retcode);

	case RAIDFRAME_REMOVE_HOT_SPARE:
		return(retcode);

	case RAIDFRAME_DELETE_COMPONENT:
		componentPtr = (RF_SingleComponent_t *)data;
		memcpy( &component, componentPtr, 
			sizeof(RF_SingleComponent_t));
		retcode = rf_delete_component(raidPtr, &component);
		return(retcode);

	case RAIDFRAME_INCORPORATE_HOT_SPARE:
		componentPtr = (RF_SingleComponent_t *)data;
		memcpy( &component, componentPtr, 
			sizeof(RF_SingleComponent_t));
		retcode = rf_incorporate_hot_spare(raidPtr, &component);
		return(retcode);

	case RAIDFRAME_REBUILD_IN_PLACE:

		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* Can't do this on a RAID 0!! */
			return(EINVAL);
		}

		if (raidPtr->recon_in_progress == 1) {
			/* a reconstruct is already in progress! */
			return(EINVAL);
		}

		componentPtr = (RF_SingleComponent_t *) data;
		memcpy( &component, componentPtr, 
			sizeof(RF_SingleComponent_t));
		row = component.row;
		column = component.column;
		printf("Rebuild: %d %d\n",row, column);
		if ((row < 0) || (row >= raidPtr->numRow) ||
		    (column < 0) || (column >= raidPtr->numCol)) {
			return(EINVAL);
		}

		RF_Malloc(rrcopy, sizeof(*rrcopy), (struct rf_recon_req *));
		if (rrcopy == NULL)
			return(ENOMEM);

		rrcopy->raidPtr = (void *) raidPtr;
		rrcopy->row = row;
		rrcopy->col = column;

		retcode = RF_CREATE_THREAD(raidPtr->recon_thread,
					   rf_ReconstructInPlaceThread,
					   rrcopy,"raid_reconip");
		return (retcode);

	case RAIDFRAME_GET_INFO:
		if (!raidPtr->valid)
			return (ENODEV);
		ucfgp = (RF_DeviceConfig_t **) data;
		RF_Malloc(d_cfg, sizeof(RF_DeviceConfig_t),
			  (RF_DeviceConfig_t *));
		if (d_cfg == NULL)
			return (ENOMEM);
		bzero((char *) d_cfg, sizeof(RF_DeviceConfig_t));
		d_cfg->rows = raidPtr->numRow;
		d_cfg->cols = raidPtr->numCol;
		d_cfg->ndevs = raidPtr->numRow * raidPtr->numCol;
		if (d_cfg->ndevs >= RF_MAX_DISKS) {
			RF_Free(d_cfg, sizeof(RF_DeviceConfig_t));
			return (ENOMEM);
		}
		d_cfg->nspares = raidPtr->numSpare;
		if (d_cfg->nspares >= RF_MAX_DISKS) {
			RF_Free(d_cfg, sizeof(RF_DeviceConfig_t));
			return (ENOMEM);
		}
		d_cfg->maxqdepth = raidPtr->maxQueueDepth;
		d = 0;
		for (i = 0; i < d_cfg->rows; i++) {
			for (j = 0; j < d_cfg->cols; j++) {
				d_cfg->devs[d] = raidPtr->Disks[i][j];
				d++;
			}
		}
		for (j = d_cfg->cols, i = 0; i < d_cfg->nspares; i++, j++) {
			d_cfg->spares[i] = raidPtr->Disks[0][j];
		}
		retcode = copyout((caddr_t) d_cfg, (caddr_t) * ucfgp,
				  sizeof(RF_DeviceConfig_t));
		RF_Free(d_cfg, sizeof(RF_DeviceConfig_t));

		return (retcode);

	case RAIDFRAME_CHECK_PARITY:
		*(int *) data = raidPtr->parity_good;
		return (0);

	case RAIDFRAME_RESET_ACCTOTALS:
		bzero(&raidPtr->acc_totals, sizeof(raidPtr->acc_totals));
		return (0);

	case RAIDFRAME_GET_ACCTOTALS:
		totals = (RF_AccTotals_t *) data;
		*totals = raidPtr->acc_totals;
		return (0);

	case RAIDFRAME_KEEP_ACCTOTALS:
		raidPtr->keep_acc_totals = *(int *)data;
		return (0);

	case RAIDFRAME_GET_SIZE:
		*(int *) data = raidPtr->totalSectors;
		return (0);

		/* fail a disk & optionally start reconstruction */
	case RAIDFRAME_FAIL_DISK:

		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* Can't do this on a RAID 0!! */
			return(EINVAL);
		}

		rr = (struct rf_recon_req *) data;

		if (rr->row < 0 || rr->row >= raidPtr->numRow
		    || rr->col < 0 || rr->col >= raidPtr->numCol)
			return (EINVAL);

		printf("raid%d: Failing the disk: row: %d col: %d\n",
		       unit, rr->row, rr->col);

		/* make a copy of the recon request so that we don't rely on
		 * the user's buffer */
		RF_Malloc(rrcopy, sizeof(*rrcopy), (struct rf_recon_req *));
		if (rrcopy == NULL)
			return(ENOMEM);
		bcopy(rr, rrcopy, sizeof(*rr));
		rrcopy->raidPtr = (void *) raidPtr;

		retcode = RF_CREATE_THREAD(raidPtr->recon_thread,
					   rf_ReconThread,
					   rrcopy,"raid_recon");
		return (0);

		/* invoke a copyback operation after recon on whatever disk
		 * needs it, if any */
	case RAIDFRAME_COPYBACK:

		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* This makes no sense on a RAID 0!! */
			return(EINVAL);
		}

		if (raidPtr->copyback_in_progress == 1) {
			/* Copyback is already in progress! */
			return(EINVAL);
		}

		retcode = RF_CREATE_THREAD(raidPtr->copyback_thread,
					   rf_CopybackThread,
					   raidPtr,"raid_copyback");
		return (retcode);

		/* return the percentage completion of reconstruction */
	case RAIDFRAME_CHECK_RECON_STATUS:
		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* This makes no sense on a RAID 0 */
			return (EINVAL);
		}
		row = 0; /* XXX we only consider a single row... */
		if (raidPtr->status[row] != rf_rs_reconstructing)
			*(int *) data = 100;
		else
			*(int *) data = raidPtr->reconControl[row]->percentComplete;
		return (0);

	case RAIDFRAME_CHECK_RECON_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		row = 0; /* XXX we only consider a single row... */
		if (raidPtr->status[row] != rf_rs_reconstructing) {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		} else {
			progressInfo.total = 
				raidPtr->reconControl[row]->numRUsTotal;
			progressInfo.completed = 
				raidPtr->reconControl[row]->numRUsComplete;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS:
		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* This makes no sense on a RAID 0, so tell the
			   user it's done. */
			*(int *) data = 100;
			return(0);
		}
		if (raidPtr->parity_rewrite_in_progress == 1) {
			*(int *) data = 100 * 
				raidPtr->parity_rewrite_stripes_done / 
				raidPtr->Layout.numStripe;
		} else {
			*(int *) data = 100;
		}
		return (0);

	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		if (raidPtr->parity_rewrite_in_progress == 1) {
			progressInfo.total = raidPtr->Layout.numStripe;
			progressInfo.completed = 
				raidPtr->parity_rewrite_stripes_done;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		} else {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

	case RAIDFRAME_CHECK_COPYBACK_STATUS:
		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* This makes no sense on a RAID 0 */
			*(int *) data = 100;
			return(0);
		}
		if (raidPtr->copyback_in_progress == 1) {
			*(int *) data = 100 * raidPtr->copyback_stripes_done / raidPtr->Layout.numStripe;
		} else {
			*(int *) data = 100;
		}
		return (0);

	case RAIDFRAME_CHECK_COPYBACK_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		if (raidPtr->copyback_in_progress == 1) {
			progressInfo.total = raidPtr->Layout.numStripe;
			progressInfo.completed = 
				raidPtr->copyback_stripes_done;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		} else {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

		/* the sparetable daemon calls this to wait for the kernel to
		 * need a spare table. this ioctl does not return until a
		 * spare table is needed. XXX -- calling mpsleep here in the
		 * ioctl code is almost certainly wrong and evil. -- XXX XXX
		 * -- I should either compute the spare table in the kernel,
		 * or have a different -- XXX XXX -- interface (a different
		 * character device) for delivering the table     -- XXX */
#if 0
	case RAIDFRAME_SPARET_WAIT:
		RF_LOCK_MUTEX(rf_sparet_wait_mutex);
		while (!rf_sparet_wait_queue)
			mpsleep(&rf_sparet_wait_queue, (PZERO + 1) | PCATCH, "sparet wait", 0, (void *) simple_lock_addr(rf_sparet_wait_mutex), MS_LOCK_SIMPLE);
		waitreq = rf_sparet_wait_queue;
		rf_sparet_wait_queue = rf_sparet_wait_queue->next;
		RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);

		/* structure assignment */
		*((RF_SparetWait_t *) data) = *waitreq;	

		RF_Free(waitreq, sizeof(*waitreq));
		return (0);

		/* wakes up a process waiting on SPARET_WAIT and puts an error
		 * code in it that will cause the dameon to exit */
	case RAIDFRAME_ABORT_SPARET_WAIT:
		RF_Malloc(waitreq, sizeof(*waitreq), (RF_SparetWait_t *));
		waitreq->fcol = -1;
		RF_LOCK_MUTEX(rf_sparet_wait_mutex);
		waitreq->next = rf_sparet_wait_queue;
		rf_sparet_wait_queue = waitreq;
		RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);
		wakeup(&rf_sparet_wait_queue);
		return (0);

		/* used by the spare table daemon to deliver a spare table
		 * into the kernel */
	case RAIDFRAME_SEND_SPARET:

		/* install the spare table */
		retcode = rf_SetSpareTable(raidPtr, *(void **) data);

		/* respond to the requestor.  the return status of the spare
		 * table installation is passed in the "fcol" field */
		RF_Malloc(waitreq, sizeof(*waitreq), (RF_SparetWait_t *));
		waitreq->fcol = retcode;
		RF_LOCK_MUTEX(rf_sparet_wait_mutex);
		waitreq->next = rf_sparet_resp_queue;
		rf_sparet_resp_queue = waitreq;
		wakeup(&rf_sparet_resp_queue);
		RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);

		return (retcode);
#endif

	default:
		break;		/* fall through to the os-specific code below */

	}

	if (!raidPtr->valid)
		return (EINVAL);

	/*
	 * Add support for "regular" device ioctls here.
	 */

	switch (cmd) {
	case DIOCGDINFO:
		*(struct disklabel *) data = *(rs->sc_dkdev.dk_label);
		break;

	case DIOCGPART:
		((struct partinfo *) data)->disklab = rs->sc_dkdev.dk_label;
		((struct partinfo *) data)->part =
		    &rs->sc_dkdev.dk_label->d_partitions[DISKPART(dev)];
		break;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((error = raidlock(rs)) != 0)
			return (error);

		rs->sc_flags |= RAIDF_LABELLING;

		error = setdisklabel(rs->sc_dkdev.dk_label,
		    (struct disklabel *) data, 0, rs->sc_dkdev.dk_cpulabel);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(RAIDLABELDEV(dev),
				    raidstrategy, rs->sc_dkdev.dk_label,
				    rs->sc_dkdev.dk_cpulabel);
		}
		rs->sc_flags &= ~RAIDF_LABELLING;

		raidunlock(rs);

		if (error)
			return (error);
		break;

	case DIOCWLABEL:
		if (*(int *) data != 0)
			rs->sc_flags |= RAIDF_WLABEL;
		else
			rs->sc_flags &= ~RAIDF_WLABEL;
		break;

	case DIOCGDEFLABEL:
		raidgetdefaultlabel(raidPtr, rs,
		    (struct disklabel *) data);
		break;

	default:
		retcode = ENOTTY;
	}
	return (retcode);

}


/* raidinit -- complete the rest of the initialization for the
   RAIDframe device.  */


static void
raidinit(raidPtr)
	RF_Raid_t *raidPtr;
{
	struct raid_softc *rs;
	int     unit;

	unit = raidPtr->raidid;

	rs = &raid_softc[unit];
	pool_init(&rs->sc_cbufpool, sizeof(struct raidbuf), 0,
		  0, 0, "raidpl", 0, NULL, NULL, M_RAIDFRAME);


	/* XXX should check return code first... */
	rs->sc_flags |= RAIDF_INITED;

	sprintf(rs->sc_xname, "raid%d", unit);	/* XXX doesn't check bounds. */

	rs->sc_dkdev.dk_name = rs->sc_xname;

	/* disk_attach actually creates space for the CPU disklabel, among
	 * other things, so it's critical to call this *BEFORE* we try putzing
	 * with disklabels. */

	disk_attach(&rs->sc_dkdev);

	/* XXX There may be a weird interaction here between this, and
	 * protectedSectors, as used in RAIDframe.  */

	rs->sc_size = raidPtr->totalSectors;

}

/* wake up the daemon & tell it to get us a spare table
 * XXX
 * the entries in the queues should be tagged with the raidPtr
 * so that in the extremely rare case that two recons happen at once, 
 * we know for which device were requesting a spare table
 * XXX
 * 
 * XXX This code is not currently used. GO
 */
int 
rf_GetSpareTableFromDaemon(req)
	RF_SparetWait_t *req;
{
	int     retcode;

	RF_LOCK_MUTEX(rf_sparet_wait_mutex);
	req->next = rf_sparet_wait_queue;
	rf_sparet_wait_queue = req;
	wakeup(&rf_sparet_wait_queue);

	/* mpsleep unlocks the mutex */
	while (!rf_sparet_resp_queue) {
		tsleep(&rf_sparet_resp_queue, PRIBIO,
		    "RAIDframe getsparetable", 0);
	}
	req = rf_sparet_resp_queue;
	rf_sparet_resp_queue = req->next;
	RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);

	retcode = req->fcol;
	RF_Free(req, sizeof(*req));	/* this is not the same req as we
					 * alloc'd */
	return (retcode);
}

/* a wrapper around rf_DoAccess that extracts appropriate info from the 
 * bp & passes it down.
 * any calls originating in the kernel must use non-blocking I/O
 * do some extra sanity checking to return "appropriate" error values for
 * certain conditions (to make some standard utilities work)
 * 
 * Formerly known as: rf_DoAccessKernel
 */
void
raidstart(raidPtr)
	RF_Raid_t *raidPtr;
{
	RF_SectorCount_t num_blocks, pb, sum;
	RF_RaidAddr_t raid_addr;
	int     retcode;
	struct partition *pp;
	daddr_t blocknum;
	int     unit;
	struct raid_softc *rs;
	int     do_async;
	struct buf *bp;

	unit = raidPtr->raidid;
	rs = &raid_softc[unit];

	/* quick check to see if anything has died recently */
	RF_LOCK_MUTEX(raidPtr->mutex);
	if (raidPtr->numNewFailures > 0) {
		rf_update_component_labels(raidPtr, 
					   RF_NORMAL_COMPONENT_UPDATE);
		raidPtr->numNewFailures--;
	}
	RF_UNLOCK_MUTEX(raidPtr->mutex);

	/* Check to see if we're at the limit... */
	RF_LOCK_MUTEX(raidPtr->mutex);
	while (raidPtr->openings > 0) {
		RF_UNLOCK_MUTEX(raidPtr->mutex);

		/* get the next item, if any, from the queue */
		if ((bp = BUFQ_FIRST(&rs->buf_queue)) == NULL) {
			/* nothing more to do */
			return;
		}
		BUFQ_REMOVE(&rs->buf_queue, bp);

	/* Ok, for the bp we have here, bp->b_blkno is relative to the
		 * partition.. Need to make it absolute to the underlying 
		 * device.. */

	blocknum = bp->b_blkno;
	if (DISKPART(bp->b_dev) != RAW_PART) {
		pp = &rs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];
		blocknum += pp->p_offset;
	}

		db1_printf(("Blocks: %d, %d\n", (int) bp->b_blkno, 
			    (int) blocknum));

	db1_printf(("bp->b_bcount = %d\n", (int) bp->b_bcount));
	db1_printf(("bp->b_resid = %d\n", (int) bp->b_resid));

		/* *THIS* is where we adjust what block we're going to... 
		 * but DO NOT TOUCH bp->b_blkno!!! */
	raid_addr = blocknum;

	num_blocks = bp->b_bcount >> raidPtr->logBytesPerSector;
	pb = (bp->b_bcount & raidPtr->sectorMask) ? 1 : 0;
	sum = raid_addr + num_blocks + pb;
	if (1 || rf_debugKernelAccess) {
		db1_printf(("raid_addr=%d sum=%d num_blocks=%d(+%d) (%d)\n",
			(int) raid_addr, (int) sum, (int) num_blocks,
			(int) pb, (int) bp->b_resid));
	}
	if ((sum > raidPtr->totalSectors) || (sum < raid_addr)
	    || (sum < num_blocks) || (sum < pb)) {
		bp->b_error = ENOSPC;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
			RF_LOCK_MUTEX(raidPtr->mutex);
			continue;
	}
	/*
	 * XXX rf_DoAccess() should do this, not just DoAccessKernel()
	 */

	if (bp->b_bcount & raidPtr->sectorMask) {
		bp->b_error = EINVAL;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
			RF_LOCK_MUTEX(raidPtr->mutex);
			continue;
			
	}
	db1_printf(("Calling DoAccess..\n"));


		RF_LOCK_MUTEX(raidPtr->mutex);
	raidPtr->openings--;
	RF_UNLOCK_MUTEX(raidPtr->mutex);

	/*
	 * Everything is async.
	 */
	do_async = 1;
		
		/* don't ever condition on bp->b_flags & B_WRITE.  
		 * always condition on B_READ instead */

		/* XXX we're still at splbio() here... do we *really* 
		   need to be? */

		
  		retcode = rf_DoAccess(raidPtr, (bp->b_flags & B_READ) ?
  				      RF_IO_TYPE_READ : RF_IO_TYPE_WRITE,
  				      do_async, raid_addr, num_blocks,
 				      bp->b_data, bp, NULL, NULL, 
  				      RF_DAG_NONBLOCKING_IO, NULL, NULL, NULL);
  
		RF_LOCK_MUTEX(raidPtr->mutex);
	}
	RF_UNLOCK_MUTEX(raidPtr->mutex);
}




/* invoke an I/O from kernel mode.  Disk queue should be locked upon entry */

int 
rf_DispatchKernelIO(queue, req)
	RF_DiskQueue_t *queue;
	RF_DiskQueueData_t *req;
{
	int     op = (req->type == RF_IO_TYPE_READ) ? B_READ : B_WRITE;
	struct buf *bp;
	struct raidbuf *raidbp = NULL;
	struct raid_softc *rs;
	int     unit;
	int s;

	s=0;
	/* s = splbio();*/ /* want to test this */
	/* XXX along with the vnode, we also need the softc associated with
	 * this device.. */

	req->queue = queue;

	unit = queue->raidPtr->raidid;

	db1_printf(("DispatchKernelIO unit: %d\n", unit));

	if (unit >= numraid) {
		printf("Invalid unit number: %d %d\n", unit, numraid);
		panic("Invalid Unit number in rf_DispatchKernelIO");
	}
	rs = &raid_softc[unit];

	/* XXX is this the right place? */
	disk_busy(&rs->sc_dkdev);

	bp = req->bp;
#if 1
	/* XXX when there is a physical disk failure, someone is passing us a
	 * buffer that contains old stuff!!  Attempt to deal with this problem
	 * without taking a performance hit... (not sure where the real bug
	 * is.  It's buried in RAIDframe somewhere) :-(  GO ) */

	if (bp->b_flags & B_ERROR) {
		bp->b_flags &= ~B_ERROR;
	}
	if (bp->b_error != 0) {
		bp->b_error = 0;
	}
#endif
	raidbp = RAIDGETBUF(rs);

	raidbp->rf_flags = 0;	/* XXX not really used anywhere... */

	/*
	 * context for raidiodone
	 */
	raidbp->rf_obp = bp;
	raidbp->req = req;

	LIST_INIT(&raidbp->rf_buf.b_dep);

	switch (req->type) {
	case RF_IO_TYPE_NOP:	/* used primarily to unlock a locked queue */
		/* XXX need to do something extra here.. */
		/* I'm leaving this in, as I've never actually seen it used,
		 * and I'd like folks to report it... GO */
		printf(("WAKEUP CALLED\n"));
		queue->numOutstanding++;

		/* XXX need to glue the original buffer into this??  */

		KernelWakeupFunc(&raidbp->rf_buf);
		break;

	case RF_IO_TYPE_READ:
	case RF_IO_TYPE_WRITE:

		if (req->tracerec) {
			RF_ETIMER_START(req->tracerec->timer);
		}
		InitBP(&raidbp->rf_buf, queue->rf_cinfo->ci_vp,
		    op | bp->b_flags, queue->rf_cinfo->ci_dev,
		    req->sectorOffset, req->numSector,
		    req->buf, KernelWakeupFunc, (void *) req,
		    queue->raidPtr->logBytesPerSector, req->b_proc);

		if (rf_debugKernelAccess) {
			db1_printf(("dispatch: bp->b_blkno = %ld\n",
				(long) bp->b_blkno));
		}
		queue->numOutstanding++;
		queue->last_deq_sector = req->sectorOffset;
		/* acc wouldn't have been let in if there were any pending
		 * reqs at any other priority */
		queue->curPriority = req->priority;

		db1_printf(("Going for %c to unit %d row %d col %d\n",
			req->type, unit, queue->row, queue->col));
		db1_printf(("sector %d count %d (%d bytes) %d\n",
			(int) req->sectorOffset, (int) req->numSector,
			(int) (req->numSector <<
			    queue->raidPtr->logBytesPerSector),
			(int) queue->raidPtr->logBytesPerSector));
		if ((raidbp->rf_buf.b_flags & B_READ) == 0) {
			raidbp->rf_buf.b_vp->v_numoutput++;
		}
		VOP_STRATEGY(&raidbp->rf_buf);

		break;

	default:
		panic("bad req->type in rf_DispatchKernelIO");
	}
	db1_printf(("Exiting from DispatchKernelIO\n"));
	/* splx(s); */ /* want to test this */
	return (0);
}
/* this is the callback function associated with a I/O invoked from
   kernel code.
 */
static void 
KernelWakeupFunc(vbp)
	struct buf *vbp;
{
	RF_DiskQueueData_t *req = NULL;
	RF_DiskQueue_t *queue;
	struct raidbuf *raidbp = (struct raidbuf *) vbp;
	struct buf *bp;
	struct raid_softc *rs;
	int     unit;
	int s;

	s = splbio();
	db1_printf(("recovering the request queue:\n"));
	req = raidbp->req;

	bp = raidbp->rf_obp;

	queue = (RF_DiskQueue_t *) req->queue;

	if (raidbp->rf_buf.b_flags & B_ERROR) {
		bp->b_flags |= B_ERROR;
		bp->b_error = raidbp->rf_buf.b_error ?
		    raidbp->rf_buf.b_error : EIO;
	}

	/* XXX methinks this could be wrong... */
#if 1
	bp->b_resid = raidbp->rf_buf.b_resid;
#endif

	if (req->tracerec) {
		RF_ETIMER_STOP(req->tracerec->timer);
		RF_ETIMER_EVAL(req->tracerec->timer);
		RF_LOCK_MUTEX(rf_tracing_mutex);
		req->tracerec->diskwait_us += RF_ETIMER_VAL_US(req->tracerec->timer);
		req->tracerec->phys_io_us += RF_ETIMER_VAL_US(req->tracerec->timer);
		req->tracerec->num_phys_ios++;
		RF_UNLOCK_MUTEX(rf_tracing_mutex);
	}
	bp->b_bcount = raidbp->rf_buf.b_bcount;	/* XXXX ?? */

	unit = queue->raidPtr->raidid;	/* *Much* simpler :-> */


	/* XXX Ok, let's get aggressive... If B_ERROR is set, let's go
	 * ballistic, and mark the component as hosed... */

	if (bp->b_flags & B_ERROR) {
		/* Mark the disk as dead */
		/* but only mark it once... */
		if (queue->raidPtr->Disks[queue->row][queue->col].status ==
		    rf_ds_optimal) {
			printf("raid%d: IO Error.  Marking %s as failed.\n",
			    unit, queue->raidPtr->Disks[queue->row][queue->col].devname);
			queue->raidPtr->Disks[queue->row][queue->col].status =
			    rf_ds_failed;
			queue->raidPtr->status[queue->row] = rf_rs_degraded;
			queue->raidPtr->numFailures++;
			queue->raidPtr->numNewFailures++;
		} else {	/* Disk is already dead... */
			/* printf("Disk already marked as dead!\n"); */
		}

	}

	rs = &raid_softc[unit];
	RAIDPUTBUF(rs, raidbp);


	if (bp->b_resid == 0) {
		/* XXX is this the right place for a disk_unbusy()??!??!?!? */
		disk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid));
	}

	rf_DiskIOComplete(queue, req, (bp->b_flags & B_ERROR) ? 1 : 0);
	(req->CompleteFunc) (req->argument, (bp->b_flags & B_ERROR) ? 1 : 0);

	splx(s);
}



/*
 * initialize a buf structure for doing an I/O in the kernel.
 */
static void 
InitBP(bp, b_vp, rw_flag, dev, startSect, numSect, buf, cbFunc, cbArg,
       logBytesPerSector, b_proc)
	struct buf *bp;
	struct vnode *b_vp;
	unsigned rw_flag;
	dev_t dev;
	RF_SectorNum_t startSect;
	RF_SectorCount_t numSect;
	caddr_t buf;
	void (*cbFunc) (struct buf *);
	void *cbArg;
	int logBytesPerSector;
	struct proc *b_proc;
{
	/* bp->b_flags       = B_PHYS | rw_flag; */
	bp->b_flags = B_CALL | rw_flag;	/* XXX need B_PHYS here too??? */
	bp->b_bcount = numSect << logBytesPerSector;
	bp->b_bufsize = bp->b_bcount;
	bp->b_error = 0;
	bp->b_dev = dev;
	bp->b_data = buf;
	bp->b_blkno = startSect;
	bp->b_resid = bp->b_bcount;	/* XXX is this right!??!?!! */
	if (bp->b_bcount == 0) {
		panic("bp->b_bcount is zero in InitBP!!");
	}
	bp->b_proc = b_proc;
	bp->b_iodone = cbFunc;
	bp->b_vp = b_vp;

}

static void
raidgetdefaultlabel(raidPtr, rs, lp)
	RF_Raid_t *raidPtr;
	struct raid_softc *rs;
	struct disklabel *lp;
{
	db1_printf(("Building a default label...\n"));
	bzero(lp, sizeof(*lp));

	/* fabricate a label... */
	lp->d_secperunit = raidPtr->totalSectors;
	lp->d_secsize = raidPtr->bytesPerSector;
	lp->d_nsectors = raidPtr->Layout.dataSectorsPerStripe;
	lp->d_ntracks = 1;
	lp->d_ncylinders = raidPtr->totalSectors / 
		(lp->d_nsectors * lp->d_ntracks);
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;

	strncpy(lp->d_typename, "raid", sizeof(lp->d_typename));
	lp->d_type = DTYPE_RAID;
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
	lp->d_rpm = 3600;
	lp->d_interleave = 1;
	lp->d_flags = 0;

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = raidPtr->totalSectors;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(rs->sc_dkdev.dk_label);

}
/*
 * Read the disklabel from the raid device.  If one is not present, fake one
 * up.
 */
static void
raidgetdisklabel(dev)
	dev_t   dev;
{
	int     unit = raidunit(dev);
	struct raid_softc *rs = &raid_softc[unit];
	char   *errstring;
	struct disklabel *lp = rs->sc_dkdev.dk_label;
	struct cpu_disklabel *clp = rs->sc_dkdev.dk_cpulabel;
	RF_Raid_t *raidPtr;

	db1_printf(("Getting the disklabel...\n"));

	bzero(clp, sizeof(*clp));

	raidPtr = raidPtrs[unit];

	raidgetdefaultlabel(raidPtr, rs, lp);

	/*
	 * Call the generic disklabel extraction routine.
	 */
	errstring = readdisklabel(RAIDLABELDEV(dev), raidstrategy,
	    rs->sc_dkdev.dk_label, rs->sc_dkdev.dk_cpulabel);
	if (errstring)
		raidmakedisklabel(rs);
	else {
		int     i;
		struct partition *pp;

		/*
		 * Sanity check whether the found disklabel is valid.
		 *
		 * This is necessary since total size of the raid device
		 * may vary when an interleave is changed even though exactly
		 * same componets are used, and old disklabel may used
		 * if that is found.
		 */
		if (lp->d_secperunit != rs->sc_size)
			printf("WARNING: %s: "
			    "total sector size in disklabel (%d) != "
			    "the size of raid (%ld)\n", rs->sc_xname,
			    lp->d_secperunit, (long) rs->sc_size);
		for (i = 0; i < lp->d_npartitions; i++) {
			pp = &lp->d_partitions[i];
			if (pp->p_offset + pp->p_size > rs->sc_size)
				printf("WARNING: %s: end of partition `%c' "
				    "exceeds the size of raid (%ld)\n",
				    rs->sc_xname, 'a' + i, (long) rs->sc_size);
		}
	}

}
/*
 * Take care of things one might want to take care of in the event
 * that a disklabel isn't present.
 */
static void
raidmakedisklabel(rs)
	struct raid_softc *rs;
{
	struct disklabel *lp = rs->sc_dkdev.dk_label;
	db1_printf(("Making a label..\n"));

	/*
	 * For historical reasons, if there's no disklabel present
	 * the raw partition must be marked FS_BSDFFS.
	 */

	lp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;

	strncpy(lp->d_packname, "default label", sizeof(lp->d_packname));

	lp->d_checksum = dkcksum(lp);
}
/*
 * Lookup the provided name in the filesystem.  If the file exists,
 * is a valid block device, and isn't being used by anyone else,
 * set *vpp to the file's vnode.
 * You'll find the original of this in ccd.c
 */
int
raidlookup(path, p, vpp)
	char   *path;
	struct proc *p;
	struct vnode **vpp;	/* result */
{
	struct nameidata nd;
	struct vnode *vp;
	struct vattr va;
	int     error;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);
	if ((error = vn_open(&nd, FREAD | FWRITE, 0)) != 0) {
#ifdef DEBUG
		printf("RAIDframe: vn_open returned %d\n", error);
#endif
		return (error);
	}
	vp = nd.ni_vp;
	if (vp->v_usecount > 1) {
		VOP_UNLOCK(vp, 0);
		(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);
		return (EBUSY);
	}
	if ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {
		VOP_UNLOCK(vp, 0);
		(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);
		return (error);
	}
	/* XXX: eventually we should handle VREG, too. */
	if (va.va_type != VBLK) {
		VOP_UNLOCK(vp, 0);
		(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);
		return (ENOTBLK);
	}
	VOP_UNLOCK(vp, 0);
	*vpp = vp;
	return (0);
}
/*
 * Wait interruptibly for an exclusive lock.
 *
 * XXX
 * Several drivers do this; it should be abstracted and made MP-safe.
 * (Hmm... where have we seen this warning before :->  GO )
 */
static int
raidlock(rs)
	struct raid_softc *rs;
{
	int     error;

	while ((rs->sc_flags & RAIDF_LOCKED) != 0) {
		rs->sc_flags |= RAIDF_WANTED;
		if ((error =
			tsleep(rs, PRIBIO | PCATCH, "raidlck", 0)) != 0)
			return (error);
	}
	rs->sc_flags |= RAIDF_LOCKED;
	return (0);
}
/*
 * Unlock and wake up any waiters.
 */
static void
raidunlock(rs)
	struct raid_softc *rs;
{

	rs->sc_flags &= ~RAIDF_LOCKED;
	if ((rs->sc_flags & RAIDF_WANTED) != 0) {
		rs->sc_flags &= ~RAIDF_WANTED;
		wakeup(rs);
	}
}
 

#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */
#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */

int 
raidmarkclean(dev_t dev, struct vnode *b_vp, int mod_counter)
{
	RF_ComponentLabel_t clabel;
	raidread_component_label(dev, b_vp, &clabel);
	clabel.mod_counter = mod_counter;
	clabel.clean = RF_RAID_CLEAN;
	raidwrite_component_label(dev, b_vp, &clabel);
	return(0);
}


int 
raidmarkdirty(dev_t dev, struct vnode *b_vp, int mod_counter)
{
	RF_ComponentLabel_t clabel;
	raidread_component_label(dev, b_vp, &clabel);
	clabel.mod_counter = mod_counter;
	clabel.clean = RF_RAID_DIRTY;
	raidwrite_component_label(dev, b_vp, &clabel);
	return(0);
}

/* ARGSUSED */
int
raidread_component_label(dev, b_vp, clabel)
	dev_t dev;
	struct vnode *b_vp;
	RF_ComponentLabel_t *clabel;
{
	struct buf *bp;
	int error;
	
	/* XXX should probably ensure that we don't try to do this if
	   someone has changed rf_protected_sectors. */ 

	/* get a block of the appropriate size... */
	bp = geteblk((int)RF_COMPONENT_INFO_SIZE);
	bp->b_dev = dev;

	/* get our ducks in a row for the read */
	bp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;
	bp->b_bcount = RF_COMPONENT_INFO_SIZE;
	bp->b_flags = B_BUSY | B_READ;
 	bp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;

	(*bdevsw[major(bp->b_dev)].d_strategy)(bp);

	error = biowait(bp); 

	if (!error) {
		memcpy(clabel, bp->b_data,
		       sizeof(RF_ComponentLabel_t));
#if 0
		rf_print_component_label( clabel );
#endif
        } else {
#if 0
		printf("Failed to read RAID component label!\n");
#endif
	}

        bp->b_flags = B_INVAL | B_AGE;
	brelse(bp); 
	return(error);
}
/* ARGSUSED */
int 
raidwrite_component_label(dev, b_vp, clabel)
	dev_t dev; 
	struct vnode *b_vp;
	RF_ComponentLabel_t *clabel;
{
	struct buf *bp;
	int error;

	/* get a block of the appropriate size... */
	bp = geteblk((int)RF_COMPONENT_INFO_SIZE);
	bp->b_dev = dev;

	/* get our ducks in a row for the write */
	bp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;
	bp->b_bcount = RF_COMPONENT_INFO_SIZE;
	bp->b_flags = B_BUSY | B_WRITE;
 	bp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;

	memset(bp->b_data, 0, RF_COMPONENT_INFO_SIZE );

	memcpy(bp->b_data, clabel, sizeof(RF_ComponentLabel_t));

	(*bdevsw[major(bp->b_dev)].d_strategy)(bp);
	error = biowait(bp); 
        bp->b_flags = B_INVAL | B_AGE;
	brelse(bp);
	if (error) {
#if 1
		printf("Failed to write RAID component info!\n");
#endif
	}

	return(error);
}

void 
rf_markalldirty(raidPtr)
	RF_Raid_t *raidPtr;
{
	RF_ComponentLabel_t clabel;
	int r,c;

	raidPtr->mod_counter++;
	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			if (raidPtr->Disks[r][c].status != rf_ds_failed) {
				raidread_component_label(
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&clabel);
				if (clabel.status == rf_ds_spared) {
					/* XXX do something special... 
					 but whatever you do, don't 
					 try to access it!! */
				} else {
#if 0
				clabel.status = 
					raidPtr->Disks[r][c].status;
				raidwrite_component_label( 
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&clabel);
#endif
				raidmarkdirty( 
				       raidPtr->Disks[r][c].dev, 
				       raidPtr->raid_cinfo[r][c].ci_vp,
				       raidPtr->mod_counter);
				}
			}
		} 
	}
	/* printf("Component labels marked dirty.\n"); */
#if 0
	for( c = 0; c < raidPtr->numSpare ; c++) {
		sparecol = raidPtr->numCol + c;
		if (raidPtr->Disks[r][sparecol].status == rf_ds_used_spare) {
			/* 

			   XXX this is where we get fancy and map this spare
			   into it's correct spot in the array.

			 */
			/* 
			   
			   we claim this disk is "optimal" if it's 
			   rf_ds_used_spare, as that means it should be 
			   directly substitutable for the disk it replaced. 
			   We note that too...

			 */

			for(i=0;i<raidPtr->numRow;i++) {
				for(j=0;j<raidPtr->numCol;j++) {
					if ((raidPtr->Disks[i][j].spareRow == 
					     r) &&
					    (raidPtr->Disks[i][j].spareCol ==
					     sparecol)) {
						srow = r;
						scol = sparecol;
						break;
					}
				}
			}
			
			raidread_component_label( 
				      raidPtr->Disks[r][sparecol].dev,
				      raidPtr->raid_cinfo[r][sparecol].ci_vp,
				      &clabel);
			/* make sure status is noted */
			clabel.version = RF_COMPONENT_LABEL_VERSION; 
			clabel.mod_counter = raidPtr->mod_counter;
			clabel.serial_number = raidPtr->serial_number;
			clabel.row = srow;
			clabel.column = scol;
			clabel.num_rows = raidPtr->numRow;
			clabel.num_columns = raidPtr->numCol;
			clabel.clean = RF_RAID_DIRTY; /* changed in a bit*/
			clabel.status = rf_ds_optimal;
			raidwrite_component_label(
				      raidPtr->Disks[r][sparecol].dev,
				      raidPtr->raid_cinfo[r][sparecol].ci_vp,
				      &clabel);
			raidmarkclean( raidPtr->Disks[r][sparecol].dev, 
			              raidPtr->raid_cinfo[r][sparecol].ci_vp);
		}
	}

#endif
}


void
rf_update_component_labels(raidPtr, final)
	RF_Raid_t *raidPtr;
	int final;
{
	RF_ComponentLabel_t clabel;
	int sparecol;
	int r,c;
	int i,j;
	int srow, scol;

	srow = -1;
	scol = -1;

	/* XXX should do extra checks to make sure things really are clean, 
	   rather than blindly setting the clean bit... */

	raidPtr->mod_counter++;

	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			if (raidPtr->Disks[r][c].status == rf_ds_optimal) {
				raidread_component_label(
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&clabel);
				/* make sure status is noted */
				clabel.status = rf_ds_optimal;
				/* bump the counter */
				clabel.mod_counter = raidPtr->mod_counter;

				raidwrite_component_label( 
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&clabel);
				if (final == RF_FINAL_COMPONENT_UPDATE) {
					if (raidPtr->parity_good == RF_RAID_CLEAN) {
						raidmarkclean( 
							      raidPtr->Disks[r][c].dev, 
							      raidPtr->raid_cinfo[r][c].ci_vp,
							      raidPtr->mod_counter);
					}
				}
			} 
			/* else we don't touch it.. */
		} 
	}

	for( c = 0; c < raidPtr->numSpare ; c++) {
		sparecol = raidPtr->numCol + c;
		if (raidPtr->Disks[0][sparecol].status == rf_ds_used_spare) {
			/* 
			   
			   we claim this disk is "optimal" if it's 
			   rf_ds_used_spare, as that means it should be 
			   directly substitutable for the disk it replaced. 
			   We note that too...

			 */

			for(i=0;i<raidPtr->numRow;i++) {
				for(j=0;j<raidPtr->numCol;j++) {
					if ((raidPtr->Disks[i][j].spareRow == 
					     0) &&
					    (raidPtr->Disks[i][j].spareCol ==
					     sparecol)) {
						srow = i;
						scol = j;
						break;
					}
				}
			}
			
			/* XXX shouldn't *really* need this... */
			raidread_component_label( 
				      raidPtr->Disks[0][sparecol].dev,
				      raidPtr->raid_cinfo[0][sparecol].ci_vp,
				      &clabel);
			/* make sure status is noted */

			raid_init_component_label(raidPtr, &clabel);

			clabel.mod_counter = raidPtr->mod_counter;
			clabel.row = srow;
			clabel.column = scol;
			clabel.status = rf_ds_optimal;

			raidwrite_component_label(
				      raidPtr->Disks[0][sparecol].dev,
				      raidPtr->raid_cinfo[0][sparecol].ci_vp,
				      &clabel);
			if (final == RF_FINAL_COMPONENT_UPDATE) {
				if (raidPtr->parity_good == RF_RAID_CLEAN) {
					raidmarkclean( raidPtr->Disks[0][sparecol].dev,
						       raidPtr->raid_cinfo[0][sparecol].ci_vp,
						       raidPtr->mod_counter);
				}
			}
		}
	}
	/* 	printf("Component labels updated\n"); */
}

void
rf_close_component(raidPtr, vp, auto_configured)
	RF_Raid_t *raidPtr;
	struct vnode *vp;
	int auto_configured;
{
	struct proc *p;

	p = raidPtr->engine_thread;

	if (vp != NULL) {
		if (auto_configured == 1) {
			VOP_CLOSE(vp, FREAD, NOCRED, 0);
			vput(vp);
			
		} else {				
			VOP_UNLOCK(vp, 0);
			(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);
		}
	} else {
		printf("vnode was NULL\n");
	}
}


void
rf_UnconfigureVnodes(raidPtr)
	RF_Raid_t *raidPtr;
{
	int r,c; 
	struct proc *p;
	struct vnode *vp;
	int acd;


	/* We take this opportunity to close the vnodes like we should.. */

	p = raidPtr->engine_thread;

	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			printf("Closing vnode for row: %d col: %d\n", r, c);
			vp = raidPtr->raid_cinfo[r][c].ci_vp;
			acd = raidPtr->Disks[r][c].auto_configured;
			rf_close_component(raidPtr, vp, acd);
			raidPtr->raid_cinfo[r][c].ci_vp = NULL;
			raidPtr->Disks[r][c].auto_configured = 0;
		}
	}
	for (r = 0; r < raidPtr->numSpare; r++) {
		printf("Closing vnode for spare: %d\n", r);
		vp = raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp;
		acd = raidPtr->Disks[0][raidPtr->numCol + r].auto_configured;
		rf_close_component(raidPtr, vp, acd);
		raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;
		raidPtr->Disks[0][raidPtr->numCol + r].auto_configured = 0;
	}
}


void 
rf_ReconThread(req)
	struct rf_recon_req *req;
{
	int     s;
	RF_Raid_t *raidPtr;

	s = splbio();
	raidPtr = (RF_Raid_t *) req->raidPtr;
	raidPtr->recon_in_progress = 1;

	rf_FailDisk((RF_Raid_t *) req->raidPtr, req->row, req->col,
		    ((req->flags & RF_FDFLAGS_RECON) ? 1 : 0));

	/* XXX get rid of this! we don't need it at all.. */
	RF_Free(req, sizeof(*req));

	raidPtr->recon_in_progress = 0;
	splx(s);

	/* That's all... */
	kthread_exit(0);        /* does not return */
}

void
rf_RewriteParityThread(raidPtr)
	RF_Raid_t *raidPtr;
{
	int retcode;
	int s;

	raidPtr->parity_rewrite_in_progress = 1;
	s = splbio();
	retcode = rf_RewriteParity(raidPtr);
	splx(s);
	if (retcode) {
		printf("raid%d: Error re-writing parity!\n",raidPtr->raidid);
	} else {
		/* set the clean bit!  If we shutdown correctly,
		   the clean bit on each component label will get
		   set */
		raidPtr->parity_good = RF_RAID_CLEAN;
	}
	raidPtr->parity_rewrite_in_progress = 0;

	/* Anyone waiting for us to stop?  If so, inform them... */
	if (raidPtr->waitShutdown) {
		wakeup(&raidPtr->parity_rewrite_in_progress);
	}

	/* That's all... */
	kthread_exit(0);        /* does not return */
}


void
rf_CopybackThread(raidPtr)
	RF_Raid_t *raidPtr;
{
	int s;

	raidPtr->copyback_in_progress = 1;
	s = splbio();
	rf_CopybackReconstructedData(raidPtr);
	splx(s);
	raidPtr->copyback_in_progress = 0;

	/* That's all... */
	kthread_exit(0);        /* does not return */
}


void
rf_ReconstructInPlaceThread(req)
	struct rf_recon_req *req;
{
	int retcode;
	int s;
	RF_Raid_t *raidPtr;
	
	s = splbio();
	raidPtr = req->raidPtr;
	raidPtr->recon_in_progress = 1;
	retcode = rf_ReconstructInPlace(raidPtr, req->row, req->col);
	RF_Free(req, sizeof(*req));
	raidPtr->recon_in_progress = 0;
	splx(s);

	/* That's all... */
	kthread_exit(0);        /* does not return */
}

void
rf_mountroot_hook(dev)
	struct device *dev;
{

}


RF_AutoConfig_t *
rf_find_raid_components()
{
	struct devnametobdevmaj *dtobdm;
	struct vnode *vp;
	struct disklabel label;
	struct device *dv;
	char *cd_name;
	dev_t dev;
	int error;
	int i;
	int good_one;
	RF_ComponentLabel_t *clabel;
	RF_AutoConfig_t *ac_list;
	RF_AutoConfig_t *ac;


	/* initialize the AutoConfig list */
	ac_list = NULL;

if (raidautoconfig) {

	/* we begin by trolling through *all* the devices on the system */

	for (dv = alldevs.tqh_first; dv != NULL;
	     dv = dv->dv_list.tqe_next) {

		/* we are only interested in disks... */
		if (dv->dv_class != DV_DISK)
			continue;

		/* we don't care about floppies... */
		if (!strcmp(dv->dv_cfdata->cf_driver->cd_name,"fd")) {
			continue;
		}
		
		/* need to find the device_name_to_block_device_major stuff */
		cd_name = dv->dv_cfdata->cf_driver->cd_name;
		dtobdm = dev_name2blk;
		while (dtobdm->d_name && strcmp(dtobdm->d_name, cd_name)) {
			dtobdm++;
		}

		/* get a vnode for the raw partition of this disk */

		dev = MAKEDISKDEV(dtobdm->d_maj, dv->dv_unit, RAW_PART);
		if (bdevvp(dev, &vp))
			panic("RAID can't alloc vnode");

		error = VOP_OPEN(vp, FREAD, NOCRED, 0);

		if (error) {
			/* "Who cares."  Continue looking 
			   for something that exists*/
			vput(vp);
			continue;
		}

		/* Ok, the disk exists.  Go get the disklabel. */
		error = VOP_IOCTL(vp, DIOCGDINFO, (caddr_t)&label, 
				  FREAD, NOCRED, 0);
		if (error) {
			/*
			 * XXX can't happen - open() would
			 * have errored out (or faked up one)
			 */
			printf("can't get label for dev %s%c (%d)!?!?\n",
			       dv->dv_xname, 'a' + RAW_PART, error);
		}

		/* don't need this any more.  We'll allocate it again
		   a little later if we really do... */
		VOP_CLOSE(vp, FREAD, NOCRED, 0);
		vput(vp);

		for (i=0; i < label.d_npartitions; i++) {
			/* We only support partitions marked as RAID */
			if (label.d_partitions[i].p_fstype != FS_RAID)
				continue;

			dev = MAKEDISKDEV(dtobdm->d_maj, dv->dv_unit, i);
			if (bdevvp(dev, &vp))
				panic("RAID can't alloc vnode");

			error = VOP_OPEN(vp, FREAD, NOCRED, 0);
			if (error) {
				/* Whatever... */
				vput(vp);
				continue;
			}

			good_one = 0;

			clabel = (RF_ComponentLabel_t *) 
				malloc(sizeof(RF_ComponentLabel_t), 
				       M_RAIDFRAME, M_NOWAIT);
			if (clabel == NULL) {
				/* XXX CLEANUP HERE */
				printf("RAID auto config: out of memory!\n");
				return(NULL); /* XXX probably should panic? */
			}

			if (!raidread_component_label(dev, vp, clabel)) {
				/* Got the label.  Does it look reasonable? */
				if (rf_reasonable_label(clabel) &&
				    (clabel->partitionSize <= 
				     label.d_partitions[i].p_size)) {
#if DEBUG
					printf("Component on: %s%c: %d\n", 
					       dv->dv_xname, 'a'+i,
					       label.d_partitions[i].p_size);
					rf_print_component_label(clabel);
#endif
					/* if it's reasonable, add it, 
					   else ignore it. */
					ac = (RF_AutoConfig_t *)
						malloc(sizeof(RF_AutoConfig_t),
						       M_RAIDFRAME,
						       M_NOWAIT);
					if (ac == NULL) {
						/* XXX should panic?? */
						return(NULL);
					}
					
					sprintf(ac->devname, "%s%c",
						dv->dv_xname, 'a'+i);
					ac->dev = dev;
					ac->vp = vp;
					ac->clabel = clabel;
					ac->next = ac_list;
					ac_list = ac;
					good_one = 1;
				} 
			}
			if (!good_one) {
				/* cleanup */
				free(clabel, M_RAIDFRAME);
				VOP_CLOSE(vp, FREAD, NOCRED, 0);
				vput(vp);
			}
		}
	}
}
return(ac_list);
}
			
static int
rf_reasonable_label(clabel)
	RF_ComponentLabel_t *clabel;
{
	
	if (((clabel->version==RF_COMPONENT_LABEL_VERSION_1) ||
	     (clabel->version==RF_COMPONENT_LABEL_VERSION)) &&
	    ((clabel->clean == RF_RAID_CLEAN) ||
	     (clabel->clean == RF_RAID_DIRTY)) &&
	    clabel->row >=0 && 
	    clabel->column >= 0 && 
	    clabel->num_rows > 0 &&
	    clabel->num_columns > 0 &&
	    clabel->row < clabel->num_rows && 
	    clabel->column < clabel->num_columns &&
	    clabel->blockSize > 0 &&
	    clabel->numBlocks > 0) {
		/* label looks reasonable enough... */
		return(1);
	}
	return(0);
}


void
rf_print_component_label(clabel)
	RF_ComponentLabel_t *clabel;
{
	printf("   Row: %d Column: %d Num Rows: %d Num Columns: %d\n",
	       clabel->row, clabel->column, 
	       clabel->num_rows, clabel->num_columns);
	printf("   Version: %d Serial Number: %d Mod Counter: %d\n",
	       clabel->version, clabel->serial_number,
	       clabel->mod_counter);
	printf("   Clean: %s Status: %d\n",
	       clabel->clean ? "Yes" : "No", clabel->status );
	printf("   sectPerSU: %d SUsPerPU: %d SUsPerRU: %d\n",
	       clabel->sectPerSU, clabel->SUsPerPU, clabel->SUsPerRU);
	printf("   RAID Level: %c  blocksize: %d numBlocks: %d\n",
	       (char) clabel->parityConfig, clabel->blockSize, 
	       clabel->numBlocks);
	printf("   Autoconfig: %s\n", clabel->autoconfigure ? "Yes" : "No" );
	printf("   Contains root partition: %s\n",  
	       clabel->root_partition ? "Yes" : "No" );
	printf("   Last configured as: raid%d\n", clabel->last_unit );
#if 0
	   printf("   Config order: %d\n", clabel->config_order);
#endif
	       
}

RF_ConfigSet_t *
rf_create_auto_sets(ac_list)
	RF_AutoConfig_t *ac_list;
{
	RF_AutoConfig_t *ac;
	RF_ConfigSet_t *config_sets;
	RF_ConfigSet_t *cset;
	RF_AutoConfig_t *ac_next;


	config_sets = NULL;

	/* Go through the AutoConfig list, and figure out which components
	   belong to what sets.  */
	ac = ac_list;
	while(ac!=NULL) {
		/* we're going to putz with ac->next, so save it here
		   for use at the end of the loop */
		ac_next = ac->next;

		if (config_sets == NULL) {
			/* will need at least this one... */
			config_sets = (RF_ConfigSet_t *)
				malloc(sizeof(RF_ConfigSet_t), 
				       M_RAIDFRAME, M_NOWAIT);
			if (config_sets == NULL) {
				panic("rf_create_auto_sets: No memory!");
			}
			/* this one is easy :) */
			config_sets->ac = ac;
			config_sets->next = NULL;
			config_sets->rootable = 0;
			ac->next = NULL;
		} else {
			/* which set does this component fit into? */
			cset = config_sets;
			while(cset!=NULL) {
				if (rf_does_it_fit(cset, ac)) {
					/* looks like it matches... */
					ac->next = cset->ac;
					cset->ac = ac;
					break;
				}
				cset = cset->next;
			}
			if (cset==NULL) {
				/* didn't find a match above... new set..*/
				cset = (RF_ConfigSet_t *)
					malloc(sizeof(RF_ConfigSet_t), 
					       M_RAIDFRAME, M_NOWAIT);
				if (cset == NULL) {
					panic("rf_create_auto_sets: No memory!");
				}
				cset->ac = ac;
				ac->next = NULL;
				cset->next = config_sets;
				cset->rootable = 0;
				config_sets = cset;
			}
		}
		ac = ac_next;
	}


	return(config_sets);
}

static int
rf_does_it_fit(cset, ac)	
	RF_ConfigSet_t *cset;
	RF_AutoConfig_t *ac;
{
	RF_ComponentLabel_t *clabel1, *clabel2;

	/* If this one matches the *first* one in the set, that's good
	   enough, since the other members of the set would have been
	   through here too... */
	/* note that we are not checking partitionSize here..

	   Note that we are also not checking the mod_counters here.
	   If everything else matches execpt the mod_counter, that's 
	   good enough for this test.  We will deal with the mod_counters
	   a little later in the autoconfiguration process.  

	    (clabel1->mod_counter == clabel2->mod_counter) &&

	   The reason we don't check for this is that failed disks
	   will have lower modification counts.  If those disks are
	   not added to the set they used to belong to, then they will
	   form their own set, which may result in 2 different sets,
	   for example, competing to be configured at raid0, and
	   perhaps competing to be the root filesystem set.  If the
	   wrong ones get configured, or both attempt to become /,
	   weird behaviour and or serious lossage will occur.  Thus we
	   need to bring them into the fold here, and kick them out at
	   a later point.

	*/

	clabel1 = cset->ac->clabel;
	clabel2 = ac->clabel;
	if ((clabel1->version == clabel2->version) &&
	    (clabel1->serial_number == clabel2->serial_number) &&
	    (clabel1->num_rows == clabel2->num_rows) &&
	    (clabel1->num_columns == clabel2->num_columns) &&
	    (clabel1->sectPerSU == clabel2->sectPerSU) &&
	    (clabel1->SUsPerPU == clabel2->SUsPerPU) &&
	    (clabel1->SUsPerRU == clabel2->SUsPerRU) &&
	    (clabel1->parityConfig == clabel2->parityConfig) &&
	    (clabel1->maxOutstanding == clabel2->maxOutstanding) &&
	    (clabel1->blockSize == clabel2->blockSize) &&
	    (clabel1->numBlocks == clabel2->numBlocks) &&
	    (clabel1->autoconfigure == clabel2->autoconfigure) &&
	    (clabel1->root_partition == clabel2->root_partition) &&
	    (clabel1->last_unit == clabel2->last_unit) &&
	    (clabel1->config_order == clabel2->config_order)) {
		/* if it get's here, it almost *has* to be a match */
	} else {
		/* it's not consistent with somebody in the set.. 
		   punt */
		return(0);
	}
	/* all was fine.. it must fit... */
	return(1);
}

int
rf_have_enough_components(cset)
	RF_ConfigSet_t *cset;
{
	RF_AutoConfig_t *ac;
	RF_AutoConfig_t *auto_config;
	RF_ComponentLabel_t *clabel;
	int r,c;
	int num_rows;
	int num_cols;
	int num_missing;
	int mod_counter;
	int mod_counter_found;
	int even_pair_failed;
	char parity_type;
	

	/* check to see that we have enough 'live' components
	   of this set.  If so, we can configure it if necessary */

	num_rows = cset->ac->clabel->num_rows;
	num_cols = cset->ac->clabel->num_columns;
	parity_type = cset->ac->clabel->parityConfig;

	/* XXX Check for duplicate components!?!?!? */

	/* Determine what the mod_counter is supposed to be for this set. */

	mod_counter_found = 0;
	ac = cset->ac;
	while(ac!=NULL) {
		if (mod_counter_found==0) {
			mod_counter = ac->clabel->mod_counter;
			mod_counter_found = 1;
		} else {
			if (ac->clabel->mod_counter > mod_counter) {
				mod_counter = ac->clabel->mod_counter;
			}
		}
		ac = ac->next;
	}

	num_missing = 0;
	auto_config = cset->ac;

	for(r=0; r<num_rows; r++) {
		even_pair_failed = 0;
		for(c=0; c<num_cols; c++) {
			ac = auto_config;
			while(ac!=NULL) {
				if ((ac->clabel->row == r) &&
				    (ac->clabel->column == c) && 
				    (ac->clabel->mod_counter == mod_counter)) {
					/* it's this one... */
#if DEBUG
					printf("Found: %s at %d,%d\n",
					       ac->devname,r,c);
#endif
					break;
				}
				ac=ac->next;
			}
			if (ac==NULL) {
				/* Didn't find one here! */
				/* special case for RAID 1, especially
				   where there are more than 2
				   components (where RAIDframe treats
				   things a little differently :( ) */
				if (parity_type == '1') {
					if (c%2 == 0) { /* even component */
						even_pair_failed = 1;
					} else { /* odd component.  If
                                                    we're failed, and
                                                    so is the even
                                                    component, it's
                                                    "Good Night, Charlie" */
						if (even_pair_failed == 1) {
							return(0);
						}
					}
				} else {
					/* normal accounting */
					num_missing++;
				}
			}
			if ((parity_type == '1') && (c%2 == 1)) {
				/* Just did an even component, and we didn't
				   bail.. reset the even_pair_failed flag, 
				   and go on to the next component.... */
				even_pair_failed = 0;
			}
		}
	}

	clabel = cset->ac->clabel;

	if (((clabel->parityConfig == '0') && (num_missing > 0)) ||
	    ((clabel->parityConfig == '4') && (num_missing > 1)) ||
	    ((clabel->parityConfig == '5') && (num_missing > 1))) {
		/* XXX this needs to be made *much* more general */
		/* Too many failures */
		return(0);
	}
	/* otherwise, all is well, and we've got enough to take a kick
	   at autoconfiguring this set */
	return(1);
}

void
rf_create_configuration(ac,config,raidPtr)
	RF_AutoConfig_t *ac;
	RF_Config_t *config;
	RF_Raid_t *raidPtr;
{
	RF_ComponentLabel_t *clabel;
	int i;

	clabel = ac->clabel;

	/* 1. Fill in the common stuff */
	config->numRow = clabel->num_rows;
	config->numCol = clabel->num_columns;
	config->numSpare = 0; /* XXX should this be set here? */
	config->sectPerSU = clabel->sectPerSU;
	config->SUsPerPU = clabel->SUsPerPU;
	config->SUsPerRU = clabel->SUsPerRU;
	config->parityConfig = clabel->parityConfig;
	/* XXX... */
	strcpy(config->diskQueueType,"fifo");
	config->maxOutstandingDiskReqs = clabel->maxOutstanding;
	config->layoutSpecificSize = 0; /* XXX ?? */

	while(ac!=NULL) {
		/* row/col values will be in range due to the checks
		   in reasonable_label() */
		strcpy(config->devnames[ac->clabel->row][ac->clabel->column],
		       ac->devname);
		ac = ac->next;
	}

	for(i=0;i<RF_MAXDBGV;i++) {
		config->debugVars[i][0] = NULL;
	}
}

int
rf_set_autoconfig(raidPtr, new_value)
	RF_Raid_t *raidPtr;
	int new_value;
{
	RF_ComponentLabel_t clabel;
	struct vnode *vp;
	dev_t dev;
	int row, column;

	raidPtr->autoconfigure = new_value;
	for(row=0; row<raidPtr->numRow; row++) {
		for(column=0; column<raidPtr->numCol; column++) {
			if (raidPtr->Disks[row][column].status == 
			    rf_ds_optimal) {
				dev = raidPtr->Disks[row][column].dev;
				vp = raidPtr->raid_cinfo[row][column].ci_vp;
				raidread_component_label(dev, vp, &clabel);
				clabel.autoconfigure = new_value;
				raidwrite_component_label(dev, vp, &clabel);
			}
		}
	}
	return(new_value);
}

int
rf_set_rootpartition(raidPtr, new_value)
	RF_Raid_t *raidPtr;
	int new_value;
{
	RF_ComponentLabel_t clabel;
	struct vnode *vp;
	dev_t dev;
	int row, column;

	raidPtr->root_partition = new_value;
	for(row=0; row<raidPtr->numRow; row++) {
		for(column=0; column<raidPtr->numCol; column++) {
			if (raidPtr->Disks[row][column].status == 
			    rf_ds_optimal) {
				dev = raidPtr->Disks[row][column].dev;
				vp = raidPtr->raid_cinfo[row][column].ci_vp;
				raidread_component_label(dev, vp, &clabel);
				clabel.root_partition = new_value;
				raidwrite_component_label(dev, vp, &clabel);
			}
		}
	}
	return(new_value);
}

void
rf_release_all_vps(cset)
	RF_ConfigSet_t *cset;
{
	RF_AutoConfig_t *ac;
	
	ac = cset->ac;
	while(ac!=NULL) {
		/* Close the vp, and give it back */
		if (ac->vp) {
			VOP_CLOSE(ac->vp, FREAD, NOCRED, 0);
			vput(ac->vp);
			ac->vp = NULL;
		}
		ac = ac->next;
	}
}


void
rf_cleanup_config_set(cset)
	RF_ConfigSet_t *cset;
{
	RF_AutoConfig_t *ac;
	RF_AutoConfig_t *next_ac;
	
	ac = cset->ac;
	while(ac!=NULL) {
		next_ac = ac->next;
		/* nuke the label */
		free(ac->clabel, M_RAIDFRAME);
		/* cleanup the config structure */
		free(ac, M_RAIDFRAME);
		/* "next.." */
		ac = next_ac;
	}
	/* and, finally, nuke the config set */
	free(cset, M_RAIDFRAME);
}


void
raid_init_component_label(raidPtr, clabel)
	RF_Raid_t *raidPtr;
	RF_ComponentLabel_t *clabel;
{
	/* current version number */
	clabel->version = RF_COMPONENT_LABEL_VERSION; 
	clabel->serial_number = raidPtr->serial_number;
	clabel->mod_counter = raidPtr->mod_counter;
	clabel->num_rows = raidPtr->numRow;
	clabel->num_columns = raidPtr->numCol;
	clabel->clean = RF_RAID_DIRTY; /* not clean */
	clabel->status = rf_ds_optimal; /* "It's good!" */
	
	clabel->sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	clabel->SUsPerPU = raidPtr->Layout.SUsPerPU;
	clabel->SUsPerRU = raidPtr->Layout.SUsPerRU;

	clabel->blockSize = raidPtr->bytesPerSector;
	clabel->numBlocks = raidPtr->sectorsPerDisk;

	/* XXX not portable */
	clabel->parityConfig = raidPtr->Layout.map->parityConfig;
	clabel->maxOutstanding = raidPtr->maxOutstanding;
	clabel->autoconfigure = raidPtr->autoconfigure;
	clabel->root_partition = raidPtr->root_partition;
	clabel->last_unit = raidPtr->raidid;
	clabel->config_order = raidPtr->config_order;
}

int
rf_auto_config_set(cset,unit)
	RF_ConfigSet_t *cset;
	int *unit;
{
	RF_Raid_t *raidPtr;
	RF_Config_t *config;
	int raidID;
	int retcode;

	printf("RAID autoconfigure\n");

	retcode = 0;
	*unit = -1;

	/* 1. Create a config structure */

	config = (RF_Config_t *)malloc(sizeof(RF_Config_t),
				       M_RAIDFRAME,
				       M_NOWAIT);
	if (config==NULL) {
		printf("Out of mem!?!?\n");
				/* XXX do something more intelligent here. */
		return(1);
	}

	memset(config, 0, sizeof(RF_Config_t));

	/* XXX raidID needs to be set correctly.. */

	/* 
	   2. Figure out what RAID ID this one is supposed to live at 
	   See if we can get the same RAID dev that it was configured
	   on last time.. 
	*/

	raidID = cset->ac->clabel->last_unit;
	if ((raidID < 0) || (raidID >= numraid)) {
		/* let's not wander off into lala land. */
		raidID = numraid - 1;
	}
	if (raidPtrs[raidID]->valid != 0) {

		/* 
		   Nope... Go looking for an alternative...  
		   Start high so we don't immediately use raid0 if that's
		   not taken. 
		*/

		for(raidID = numraid; raidID >= 0; raidID--) {
			if (raidPtrs[raidID]->valid == 0) {
				/* can use this one! */
				break;
			}
		}
	}

	if (raidID < 0) {
		/* punt... */
		printf("Unable to auto configure this set!\n");
		printf("(Out of RAID devs!)\n");
		return(1);
	}
	printf("Configuring raid%d:\n",raidID);
	raidPtr = raidPtrs[raidID];

	/* XXX all this stuff should be done SOMEWHERE ELSE! */
	raidPtr->raidid = raidID;
	raidPtr->openings = RAIDOUTSTANDING;

	/* 3. Build the configuration structure */
	rf_create_configuration(cset->ac, config, raidPtr);

	/* 4. Do the configuration */
	retcode = rf_Configure(raidPtr, config, cset->ac);
	
	if (retcode == 0) {

		raidinit(raidPtrs[raidID]);

		rf_markalldirty(raidPtrs[raidID]);
		raidPtrs[raidID]->autoconfigure = 1; /* XXX do this here? */
		if (cset->ac->clabel->root_partition==1) {
			/* everything configured just fine.  Make a note
			   that this set is eligible to be root. */
			cset->rootable = 1;
			/* XXX do this here? */
			raidPtrs[raidID]->root_partition = 1; 
		}
	}

	/* 5. Cleanup */
	free(config, M_RAIDFRAME);
	
	*unit = raidID;
	return(retcode);
}
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_netbsdkintf.c,v 1.11 2002/12/16 07:01:04 tdeval Exp $	*/
@


1.11
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_netbsdkintf.c,v 1.10 2002/10/12 01:09:44 krw Exp $	*/
d56 1
a56 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.10
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_netbsdkintf.c,v 1.9 2002/03/14 01:27:01 millert Exp $	*/
d1554 1
a1554 1
		    "raidframe getsparetable", 0);
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_netbsdkintf.c,v 1.8 2001/07/09 17:20:07 fgsch Exp $	*/
d327 1
a327 1
		panic("raidPtrs is NULL!!\n");
d343 1
a343 1
		panic("Serious error booting RAID!!\n");
d361 1
a361 1
		panic("No memory for RAIDframe driver!!?!?!\n");
d1722 1
a1722 1
		panic("Invalid Unit number in rf_DispatchKernelIO\n");
d1925 1
a1925 1
		panic("bp->b_bcount is zero in InitBP!!\n");
d2818 1
a2818 1
				panic("rf_create_auto_sets: No memory!\n");
d2843 1
a2843 1
					panic("rf_create_auto_sets: No memory!\n");
@


1.8
log
@More lame OpenBSD tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d183 1
a183 1
static void raidinit __P((RF_Raid_t *));
d185 9
a193 9
void raidattach __P((int));
int raidsize __P((dev_t));
int raidopen __P((dev_t, int, int, struct proc *));
int raidclose __P((dev_t, int, int, struct proc *));
int raidioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int raidwrite __P((dev_t, struct uio *, int));
int raidread __P((dev_t, struct uio *, int));
void raidstrategy __P((struct buf *));
int raiddump __P((dev_t, daddr_t, caddr_t, size_t));
d260 4
a263 4
static void raidgetdefaultlabel __P((RF_Raid_t *, struct raid_softc *, 
				     struct disklabel *));
static void raidgetdisklabel __P((dev_t));
static void raidmakedisklabel __P((struct raid_softc *));
d265 2
a266 2
static int raidlock __P((struct raid_softc *));
static void raidunlock __P((struct raid_softc *));
d268 2
a269 2
static void rf_markalldirty __P((RF_Raid_t *));
void rf_mountroot_hook __P((struct device *));
d273 1
a273 1
void rf_ReconThread __P((struct rf_recon_req *));
d275 18
a292 18
/*void rf_ReconThread __P((RF_Raid_t *raidPtr));  */
void rf_RewriteParityThread __P((RF_Raid_t *raidPtr));
void rf_CopybackThread __P((RF_Raid_t *raidPtr));
void rf_ReconstructInPlaceThread __P((struct rf_recon_req *));
void rf_buildroothack __P((void *));

RF_AutoConfig_t *rf_find_raid_components __P((void));
RF_ConfigSet_t *rf_create_auto_sets __P((RF_AutoConfig_t *));
static int rf_does_it_fit __P((RF_ConfigSet_t *,RF_AutoConfig_t *));
static int rf_reasonable_label __P((RF_ComponentLabel_t *));
void rf_create_configuration __P((RF_AutoConfig_t *,RF_Config_t *,
				  RF_Raid_t *));
int rf_set_autoconfig __P((RF_Raid_t *, int));
int rf_set_rootpartition __P((RF_Raid_t *, int));
void rf_release_all_vps __P((RF_ConfigSet_t *));
void rf_cleanup_config_set __P((RF_ConfigSet_t *));
int rf_have_enough_components __P((RF_ConfigSet_t *));
int rf_auto_config_set __P((RF_ConfigSet_t *, int *));
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_netbsdkintf.c,v 1.8 2001/07/09 17:20:07 fgsch Exp $	*/
d183 1
a183 1
static void raidinit(RF_Raid_t *);
d185 9
a193 9
void raidattach(int);
int raidsize(dev_t);
int raidopen(dev_t, int, int, struct proc *);
int raidclose(dev_t, int, int, struct proc *);
int raidioctl(dev_t, u_long, caddr_t, int, struct proc *);
int raidwrite(dev_t, struct uio *, int);
int raidread(dev_t, struct uio *, int);
void raidstrategy(struct buf *);
int raiddump(dev_t, daddr_t, caddr_t, size_t);
d260 4
a263 4
static void raidgetdefaultlabel(RF_Raid_t *, struct raid_softc *, 
				     struct disklabel *);
static void raidgetdisklabel(dev_t);
static void raidmakedisklabel(struct raid_softc *);
d265 2
a266 2
static int raidlock(struct raid_softc *);
static void raidunlock(struct raid_softc *);
d268 2
a269 2
static void rf_markalldirty(RF_Raid_t *);
void rf_mountroot_hook(struct device *);
d273 1
a273 1
void rf_ReconThread(struct rf_recon_req *);
d275 18
a292 18
/*void rf_ReconThread(RF_Raid_t *raidPtr);  */
void rf_RewriteParityThread(RF_Raid_t *raidPtr);
void rf_CopybackThread(RF_Raid_t *raidPtr);
void rf_ReconstructInPlaceThread(struct rf_recon_req *);
void rf_buildroothack(void *);

RF_AutoConfig_t *rf_find_raid_components(void);
RF_ConfigSet_t *rf_create_auto_sets(RF_AutoConfig_t *);
static int rf_does_it_fit(RF_ConfigSet_t *,RF_AutoConfig_t *);
static int rf_reasonable_label(RF_ComponentLabel_t *);
void rf_create_configuration(RF_AutoConfig_t *,RF_Config_t *,
				  RF_Raid_t *);
int rf_set_autoconfig(RF_Raid_t *, int);
int rf_set_rootpartition(RF_Raid_t *, int);
void rf_release_all_vps(RF_ConfigSet_t *);
void rf_cleanup_config_set(RF_ConfigSet_t *);
int rf_have_enough_components(RF_ConfigSet_t *);
int rf_auto_config_set(RF_ConfigSet_t *, int *);
@


1.8.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_netbsdkintf.c,v 1.8.4.1 2002/06/11 03:42:28 art Exp $	*/
d327 1
a327 1
		panic("raidPtrs is NULL!!");
d343 1
a343 1
		panic("Serious error booting RAID!!");
d361 1
a361 1
		panic("No memory for RAIDframe driver!!?!?!");
d1722 1
a1722 1
		panic("Invalid Unit number in rf_DispatchKernelIO");
d1925 1
a1925 1
		panic("bp->b_bcount is zero in InitBP!!");
d2818 1
a2818 1
				panic("rf_create_auto_sets: No memory!");
d2843 1
a2843 1
					panic("rf_create_auto_sets: No memory!");
@


1.8.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1554 1
a1554 1
		    "RAIDframe getsparetable", 0);
@


1.7
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
@


1.6
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$NetBSD: rf_netbsdkintf.c,v 1.46 2000/01/09 03:39:13 oster Exp $	*/
d136 1
d139 1
d156 1
d182 1
a182 1
static int raidinit __P((dev_t, RF_Raid_t *, int));
d210 2
a211 1
   or if it should be used in conjunction with that... */
a216 1
	dev_t   sc_dev;	        /* our device.. */
d220 1
a220 1
	struct buf buf_queue;   /* used for the device queue */
d230 1
a230 1
static int numraid = 0;
d268 3
d278 20
d305 2
d320 2
d336 1
a336 1
	for (i = 0; i < numraid; i++)
d349 1
a349 1
	    M_RAIDFRAME, M_NOWAIT);
d354 1
a354 1
	numraid = num;
d357 6
d364 9
d384 84
d636 5
a640 1
		rf_update_component_labels( raidPtrs[unit] );
d650 1
a650 1
	register struct buf *bp;
d652 1
a652 1
	register int s;
a657 1
	struct buf *dp;
d707 1
a708 6
	dp = &rs->buf_queue;
	bp->b_actf = NULL;
	bp->b_actb = dp->b_actb;
	*dp->b_actb = bp;
	dp->b_actb = &bp->b_actf;
	
d772 1
d780 1
a780 1
	RF_ComponentLabel_t *component_label;
d782 1
a782 1
	RF_ComponentLabel_t **c_label_ptr;
d786 1
d824 1
d833 1
d835 5
d848 7
d905 6
d913 1
a913 1
		retcode = rf_Configure(raidPtr, k_cfg);
d920 3
a922 9
			
			/* XXX should be moved to rf_Configure() */

			raidPtr->copyback_in_progress = 0;
			raidPtr->parity_rewrite_in_progress = 0;
			raidPtr->recon_in_progress = 0;
		
			retcode = raidinit(dev, raidPtr, unit);
			rf_markalldirty( raidPtr );
d966 1
a966 1
		c_label_ptr = (RF_ComponentLabel_t **) data;
d968 1
a968 1
		   by row,column in component_label */
d972 1
a972 1
		RF_Malloc( component_label, sizeof( RF_ComponentLabel_t ),
d974 1
a974 1
		if (component_label == NULL)
d977 1
a977 1
		bzero((char *) component_label, sizeof(RF_ComponentLabel_t));
d979 1
a979 1
		retcode = copyin( *c_label_ptr, component_label, 
d983 1
a983 1
			RF_Free( component_label, sizeof(RF_ComponentLabel_t));
d987 2
a988 2
		row = component_label->row;
		column = component_label->column;
d991 3
a993 2
		    (column < 0) || (column >= raidPtr->numCol)) {
			RF_Free( component_label, sizeof(RF_ComponentLabel_t));
d997 3
a999 4
		raidread_component_label( 
                              raidPtr->Disks[row][column].dev, 
			      raidPtr->raid_cinfo[row][column].ci_vp, 
			      component_label );
d1001 2
a1002 2
		retcode = copyout((caddr_t) component_label, 
				  (caddr_t) *c_label_ptr,
d1004 1
a1004 1
		RF_Free( component_label, sizeof(RF_ComponentLabel_t));
d1008 1
a1008 1
		component_label = (RF_ComponentLabel_t *) data;
d1017 9
a1025 9
		printf("Version: %d\n",component_label->version);
		printf("Serial Number: %d\n",component_label->serial_number);
		printf("Mod counter: %d\n",component_label->mod_counter);
		printf("Row: %d\n", component_label->row);
		printf("Column: %d\n", component_label->column);
		printf("Num Rows: %d\n", component_label->num_rows);
		printf("Num Columns: %d\n", component_label->num_columns);
		printf("Clean: %d\n", component_label->clean);
		printf("Status: %d\n", component_label->status);
d1027 2
a1028 2
		row = component_label->row;
		column = component_label->column;
d1036 3
d1043 1
a1043 1
			    component_label );
d1048 1
a1048 1
		component_label = (RF_ComponentLabel_t *) data;
d1056 4
a1059 9
		raidPtr->serial_number = component_label->serial_number;
		/* current version number */
		ci_label.version = RF_COMPONENT_LABEL_VERSION; 
		ci_label.serial_number = component_label->serial_number;
		ci_label.mod_counter = raidPtr->mod_counter;
		ci_label.num_rows = raidPtr->numRow;
		ci_label.num_columns = raidPtr->numCol;
		ci_label.clean = RF_RAID_DIRTY; /* not clean */
		ci_label.status = rf_ds_optimal; /* "It's good!" */
d1064 2
d1075 11
a1109 1
		printf("Adding spare\n");
d1116 14
d1287 20
d1309 4
a1312 2
			/* This makes no sense on a RAID 0 */
			return(EINVAL);
d1315 3
a1317 1
			*(int *) data = 100 * raidPtr->parity_rewrite_stripes_done / raidPtr->Layout.numStripe;
d1323 18
d1344 2
a1345 1
			return(EINVAL);
d1354 17
d1496 2
a1497 3
static int
raidinit(dev, raidPtr, unit)
	dev_t   dev;
a1498 1
	int     unit;
a1499 1
	int     retcode;
d1501 1
d1503 1
a1503 1
	retcode = 0;
a1526 1
	rs->sc_dev = dev;
a1527 1
	return (retcode);
a1585 1
	struct buf *dp;
d1590 9
d1605 1
a1605 3
		dp = &rs->buf_queue;
		bp = dp->b_actf;
		if (bp == NULL) {
d1609 1
a1609 9

		/* update structures */
		dp = bp->b_actf;
		if (dp != NULL) {
			dp->b_actb = bp->b_actb;
		} else {
			rs->buf_queue.b_actb = bp->b_actb;
		}
		*bp->b_actb = dp;
d1680 6
a1685 7
	retcode = rf_DoAccess(raidPtr, (bp->b_flags & B_READ) ?
	    RF_IO_TYPE_READ : RF_IO_TYPE_WRITE,
	    do_async, raid_addr, num_blocks,
				      bp->b_un.b_addr, bp, NULL, NULL, 
				      RF_DAG_NONBLOCKING_IO, NULL, NULL, NULL);


d1823 1
a1823 1
	register int s;
d1872 1
a1872 1
			/* XXX here we should bump the version number for each component, and write that data out */
d1900 13
a1912 12
InitBP(
    struct buf * bp,
    struct vnode * b_vp,
    unsigned rw_flag,
    dev_t dev,
    RF_SectorNum_t startSect,
    RF_SectorCount_t numSect,
    caddr_t buf,
    void (*cbFunc) (struct buf *),
    void *cbArg,
    int logBytesPerSector,
    struct proc * b_proc)
d1920 1
a1920 1
	bp->b_un.b_addr = buf;
d2135 5
a2139 5
	RF_ComponentLabel_t component_label;
	raidread_component_label(dev, b_vp, &component_label);
	component_label.mod_counter = mod_counter;
	component_label.clean = RF_RAID_CLEAN;
	raidwrite_component_label(dev, b_vp, &component_label);
d2147 5
a2151 5
	RF_ComponentLabel_t component_label;
	raidread_component_label(dev, b_vp, &component_label);
	component_label.mod_counter = mod_counter;
	component_label.clean = RF_RAID_DIRTY;
	raidwrite_component_label(dev, b_vp, &component_label);
d2157 1
a2157 1
raidread_component_label(dev, b_vp, component_label)
d2160 1
a2160 1
	RF_ComponentLabel_t *component_label;
d2183 1
a2183 1
		memcpy(component_label, bp->b_un.b_addr,
d2186 1
a2186 10
		printf("raidread_component_label: got component label:\n");
		printf("Version: %d\n",component_label->version);
		printf("Serial Number: %d\n",component_label->serial_number);
		printf("Mod counter: %d\n",component_label->mod_counter);
		printf("Row: %d\n", component_label->row);
		printf("Column: %d\n", component_label->column);
		printf("Num Rows: %d\n", component_label->num_rows);
		printf("Num Columns: %d\n", component_label->num_columns);
		printf("Clean: %d\n", component_label->clean);
		printf("Status: %d\n", component_label->status);
d2189 1
d2191 1
d2200 1
a2200 1
raidwrite_component_label(dev, b_vp, component_label)
d2203 1
a2203 1
	RF_ComponentLabel_t *component_label;
d2218 1
a2218 1
	memset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );
d2220 1
a2220 1
	memcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));
d2227 1
d2229 1
d2236 1
a2236 1
rf_markalldirty( raidPtr )
d2239 1
a2239 1
	RF_ComponentLabel_t c_label;
d2249 2
a2250 2
					&c_label);
				if (c_label.status == rf_ds_spared) {
d2256 1
a2256 1
				c_label.status = 
d2261 1
a2261 1
					&c_label);
d2307 1
a2307 1
				      &c_label);
d2309 9
a2317 9
			c_label.version = RF_COMPONENT_LABEL_VERSION; 
			c_label.mod_counter = raidPtr->mod_counter;
			c_label.serial_number = raidPtr->serial_number;
			c_label.row = srow;
			c_label.column = scol;
			c_label.num_rows = raidPtr->numRow;
			c_label.num_columns = raidPtr->numCol;
			c_label.clean = RF_RAID_DIRTY; /* changed in a bit*/
			c_label.status = rf_ds_optimal;
d2321 1
a2321 1
				      &c_label);
d2332 1
a2332 1
rf_update_component_labels( raidPtr )
d2334 1
d2336 1
a2336 1
	RF_ComponentLabel_t c_label;
d2356 1
a2356 1
					&c_label);
d2358 4
a2361 1
				c_label.status = rf_ds_optimal;
d2365 8
a2372 6
					&c_label);
				if (raidPtr->parity_good == RF_RAID_CLEAN) {
					raidmarkclean( 
					      raidPtr->Disks[r][c].dev, 
					      raidPtr->raid_cinfo[r][c].ci_vp,
					      raidPtr->mod_counter);
a2375 22
#if 0
			else if (raidPtr->Disks[r][c].status !=
				   rf_ds_failed) {
				raidread_component_label(
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&c_label);
				/* make sure status is noted */
				c_label.status = 
					raidPtr->Disks[r][c].status;
				raidwrite_component_label( 
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&c_label);
				if (raidPtr->parity_good == RF_RAID_CLEAN) {
					raidmarkclean( 
					      raidPtr->Disks[r][c].dev, 
					      raidPtr->raid_cinfo[r][c].ci_vp,
					      raidPtr->mod_counter);
				}
			}
#endif
d2404 1
d2408 1
a2408 1
				      &c_label);
d2410 8
a2417 9
			c_label.version = RF_COMPONENT_LABEL_VERSION; 
			c_label.mod_counter = raidPtr->mod_counter;
			c_label.serial_number = raidPtr->serial_number;
			c_label.row = srow;
			c_label.column = scol;
			c_label.num_rows = raidPtr->numRow;
			c_label.num_columns = raidPtr->numCol;
			c_label.clean = RF_RAID_DIRTY; /* changed in a bit*/
			c_label.status = rf_ds_optimal;
d2421 7
a2427 5
				      &c_label);
			if (raidPtr->parity_good == RF_RAID_CLEAN) {
				raidmarkclean( raidPtr->Disks[0][sparecol].dev,
			              raidPtr->raid_cinfo[0][sparecol].ci_vp,
					       raidPtr->mod_counter);
d2434 60
d2539 5
d2584 697
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$NetBSD: rf_netbsdkintf.c,v 1.93 2000/07/14 15:26:29 oster Exp $	*/
a135 1
#include <sys/reboot.h>
a137 1
#include "opt_raid_autoconfig.h"
a153 1
#include "rf_configure.h"
d179 1
a179 1
static void raidinit __P((RF_Raid_t *));
d207 1
a207 2
   or if it should be used in conjunction with that... 
*/
d213 1
d217 1
a217 1
	struct buf_queue buf_queue;	/* used for the device queue */
d227 1
a227 1
int numraid = 0;
a264 3
void rf_mountroot_hook __P((struct device *));

struct device *raidrootdev;
a271 20
void rf_buildroothack __P((void *));

RF_AutoConfig_t *rf_find_raid_components __P((void));
RF_ConfigSet_t *rf_create_auto_sets __P((RF_AutoConfig_t *));
static int rf_does_it_fit __P((RF_ConfigSet_t *,RF_AutoConfig_t *));
static int rf_reasonable_label __P((RF_ComponentLabel_t *));
void rf_create_configuration __P((RF_AutoConfig_t *,RF_Config_t *,
				  RF_Raid_t *));
int rf_set_autoconfig __P((RF_Raid_t *, int));
int rf_set_rootpartition __P((RF_Raid_t *, int));
void rf_release_all_vps __P((RF_ConfigSet_t *));
void rf_cleanup_config_set __P((RF_ConfigSet_t *));
int rf_have_enough_components __P((RF_ConfigSet_t *));
int rf_auto_config_set __P((RF_ConfigSet_t *, int *));

static int raidautoconfig = 0; /* Debugging, mostly.  Set to 0 to not
				  allow autoconfig to take place.
			          Note that this is overridden by having
			          RAID_AUTOCONFIG as an option in the 
			          kernel config file.  */
a278 2
	RF_AutoConfig_t *ac_list; /* autoconfig list */
	RF_ConfigSet_t *config_sets;
a291 2
	numraid = num;

d306 1
a306 1
	for (i = 0; i < num; i++)
d319 1
a319 1
		   M_RAIDFRAME, M_NOWAIT);
d324 1
a324 1

a326 6
	raidrootdev = (struct device *)malloc(num * sizeof(struct device),
					      M_RAIDFRAME, M_NOWAIT);
	if (raidrootdev == NULL) {
		panic("No memory for RAIDframe driver!!?!?!\n");
	}

a327 9
		BUFQ_INIT(&raid_softc[raidID].buf_queue);

		raidrootdev[raidID].dv_class  = DV_DISK;
		raidrootdev[raidID].dv_cfdata = NULL;
		raidrootdev[raidID].dv_unit   = raidID;
		raidrootdev[raidID].dv_parent = NULL;
		raidrootdev[raidID].dv_flags  = 0;
		sprintf(raidrootdev[raidID].dv_xname,"raid%d",raidID);

a338 84

#if RAID_AUTOCONFIG
	raidautoconfig = 1;
#endif

if (raidautoconfig) {
	/* 1. locate all RAID components on the system */

#if DEBUG
	printf("Searching for raid components...\n");
#endif
	ac_list = rf_find_raid_components();

	/* 2. sort them into their respective sets */

	config_sets = rf_create_auto_sets(ac_list);

	/* 3. evaluate each set and configure the valid ones
	   This gets done in rf_buildroothack() */

	/* schedule the creation of the thread to do the 
	   "/ on RAID" stuff */

	kthread_create(rf_buildroothack,config_sets);

#if 0
	mountroothook_establish(rf_mountroot_hook, &raidrootdev[0]);
#endif
}

}

void
rf_buildroothack(arg)
	void *arg;
{
	RF_ConfigSet_t *config_sets = arg;
	RF_ConfigSet_t *cset;
	RF_ConfigSet_t *next_cset;
	int retcode;
	int raidID;
	int rootID;
	int num_root;

	num_root = 0;
	cset = config_sets;
	while(cset != NULL ) {
		next_cset = cset->next;
		if (rf_have_enough_components(cset) && 
		    cset->ac->clabel->autoconfigure==1) {
			retcode = rf_auto_config_set(cset,&raidID);
			if (!retcode) {
				if (cset->rootable) {
					rootID = raidID;
					num_root++;
				}
			} else {
				/* The autoconfig didn't work :( */
#if DEBUG
				printf("Autoconfig failed with code %d for raid%d\n", retcode, raidID);
#endif
				rf_release_all_vps(cset);
			}
		} else {
			/* we're not autoconfiguring this set...  
			   release the associated resources */
			rf_release_all_vps(cset);
		}
		/* cleanup */
		rf_cleanup_config_set(cset);
		cset = next_cset;
	}
	if (boothowto & RB_ASKNAME) {
		/* We don't auto-config... */
	} else {
		/* They didn't ask, and we found something bootable... */

		if (num_root == 1) {
			booted_device = &raidrootdev[rootID]; 
		} else if (num_root > 1) {
			/* we can't guess.. require the user to answer... */
			boothowto |= RB_ASKNAME;
		}
	}
d507 1
a507 5
#if 0
		printf("Last one on raid%d.  Updating status.\n",unit);
#endif
		rf_update_component_labels(raidPtrs[unit],
						 RF_FINAL_COMPONENT_UPDATE);
d517 1
a517 1
	struct buf *bp;
d519 1
a519 1
	int s;
d525 1
a574 1
	BUFQ_INSERT_TAIL(&rs->buf_queue, bp);
d576 6
a644 1
	RF_RaidDisk_t *diskPtr;
d652 1
a652 1
	RF_ComponentLabel_t *clabel;
d654 1
a654 1
	RF_ComponentLabel_t **clabel_ptr;
a657 1
	RF_ProgressInfo_t progressInfo, **progressInfoPtr;
a694 1
	case RAIDFRAME_CHECK_RECON_STATUS_EXT:
a702 1
	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT:
a703 5
	case RAIDFRAME_CHECK_COPYBACK_STATUS_EXT:
	case RAIDFRAME_SET_AUTOCONFIG:
	case RAIDFRAME_SET_ROOT:
	case RAIDFRAME_DELETE_COMPONENT:
	case RAIDFRAME_INCORPORATE_HOT_SPARE:
a711 7

		if (raidPtr->valid) {
			/* There is a valid RAID set running on this unit! */
			printf("raid%d: Device already configured!\n",unit);
			return(EINVAL);
		}

a761 6
		/*
		 * Clear the entire RAID descriptor, just to make sure
		 *  there is no stale data left in the case of a 
		 *  reconfiguration 
		 */
		bzero((char *) raidPtr, sizeof(RF_Raid_t));
d764 1
a764 1
		retcode = rf_Configure(raidPtr, k_cfg, NULL);
d771 9
a779 3
					
			raidinit(raidPtr);
			rf_markalldirty(raidPtr);
d823 1
a823 1
		clabel_ptr = (RF_ComponentLabel_t **) data;
d825 1
a825 1
		   by row,column in clabel */
d829 1
a829 1
		RF_Malloc( clabel, sizeof( RF_ComponentLabel_t ),
d831 1
a831 1
		if (clabel == NULL)
d834 1
a834 1
		bzero((char *) clabel, sizeof(RF_ComponentLabel_t));
d836 1
a836 1
		retcode = copyin( *clabel_ptr, clabel, 
d840 1
a840 1
			RF_Free( clabel, sizeof(RF_ComponentLabel_t));
d844 2
a845 2
		row = clabel->row;
		column = clabel->column;
d848 2
a849 3
		    (column < 0) || (column >= raidPtr->numCol +
				     raidPtr->numSpare)) {
			RF_Free( clabel, sizeof(RF_ComponentLabel_t));
d853 4
a856 3
		raidread_component_label(raidPtr->Disks[row][column].dev, 
				raidPtr->raid_cinfo[row][column].ci_vp, 
				clabel );
d858 2
a859 2
		retcode = copyout((caddr_t) clabel, 
				  (caddr_t) *clabel_ptr,
d861 1
a861 1
		RF_Free( clabel, sizeof(RF_ComponentLabel_t));
d865 1
a865 1
		clabel = (RF_ComponentLabel_t *) data;
d874 9
a882 9
		printf("Version: %d\n",clabel->version);
		printf("Serial Number: %d\n",clabel->serial_number);
		printf("Mod counter: %d\n",clabel->mod_counter);
		printf("Row: %d\n", clabel->row);
		printf("Column: %d\n", clabel->column);
		printf("Num Rows: %d\n", clabel->num_rows);
		printf("Num Columns: %d\n", clabel->num_columns);
		printf("Clean: %d\n", clabel->clean);
		printf("Status: %d\n", clabel->status);
d884 2
a885 2
		row = clabel->row;
		column = clabel->column;
a892 3

		/* XXX and before it is, we need to fill in the rest
		   of the fields!?!?!?! */
d897 1
a897 1
			    clabel );
d902 1
a902 1
		clabel = (RF_ComponentLabel_t *) data;
d910 9
a918 4
		raidPtr->serial_number = clabel->serial_number;
		
		raid_init_component_label(raidPtr, &ci_label);
		ci_label.serial_number = clabel->serial_number;
a922 2
				diskPtr = &raidPtr->Disks[row][column];
				ci_label.partitionSize = diskPtr->partitionSize;
a931 11
	case RAIDFRAME_SET_AUTOCONFIG:
		d = rf_set_autoconfig(raidPtr, *(int *) data);
		printf("New autoconfig value is: %d\n", d);
		*(int *) data = d;
		return (retcode);

	case RAIDFRAME_SET_ROOT:
		d = rf_set_rootpartition(raidPtr, *(int *) data);
		printf("New rootpartition value is: %d\n", d);
		*(int *) data = d;
		return (retcode);
d956 1
a962 14
	case RAIDFRAME_DELETE_COMPONENT:
		componentPtr = (RF_SingleComponent_t *)data;
		memcpy( &component, componentPtr, 
			sizeof(RF_SingleComponent_t));
		retcode = rf_delete_component(raidPtr, &component);
		return(retcode);

	case RAIDFRAME_INCORPORATE_HOT_SPARE:
		componentPtr = (RF_SingleComponent_t *)data;
		memcpy( &component, componentPtr, 
			sizeof(RF_SingleComponent_t));
		retcode = rf_incorporate_hot_spare(raidPtr, &component);
		return(retcode);

a1119 20
	case RAIDFRAME_CHECK_RECON_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		row = 0; /* XXX we only consider a single row... */
		if (raidPtr->status[row] != rf_rs_reconstructing) {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		} else {
			progressInfo.total = 
				raidPtr->reconControl[row]->numRUsTotal;
			progressInfo.completed = 
				raidPtr->reconControl[row]->numRUsComplete;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

d1122 2
a1123 4
			/* This makes no sense on a RAID 0, so tell the
			   user it's done. */
			*(int *) data = 100;
			return(0);
d1126 1
a1126 3
			*(int *) data = 100 * 
				raidPtr->parity_rewrite_stripes_done / 
				raidPtr->Layout.numStripe;
a1131 18
	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		if (raidPtr->parity_rewrite_in_progress == 1) {
			progressInfo.total = raidPtr->Layout.numStripe;
			progressInfo.completed = 
				raidPtr->parity_rewrite_stripes_done;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		} else {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

d1135 1
a1135 2
			*(int *) data = 100;
			return(0);
a1143 17
	case RAIDFRAME_CHECK_COPYBACK_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		if (raidPtr->copyback_in_progress == 1) {
			progressInfo.total = raidPtr->Layout.numStripe;
			progressInfo.completed = 
				raidPtr->copyback_stripes_done;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		} else {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);
d1269 3
a1271 2
static void
raidinit(raidPtr)
d1273 1
d1275 1
a1276 1
	int     unit;
d1278 1
a1278 1
	unit = raidPtr->raidid;
d1302 1
d1304 1
d1363 1
a1367 9
	/* quick check to see if anything has died recently */
	RF_LOCK_MUTEX(raidPtr->mutex);
	if (raidPtr->numNewFailures > 0) {
		rf_update_component_labels(raidPtr, 
					   RF_NORMAL_COMPONENT_UPDATE);
		raidPtr->numNewFailures--;
	}
	RF_UNLOCK_MUTEX(raidPtr->mutex);

d1374 3
a1376 1
		if ((bp = BUFQ_FIRST(&rs->buf_queue)) == NULL) {
d1380 9
a1388 1
		BUFQ_REMOVE(&rs->buf_queue, bp);
d1459 7
a1465 6
  		retcode = rf_DoAccess(raidPtr, (bp->b_flags & B_READ) ?
  				      RF_IO_TYPE_READ : RF_IO_TYPE_WRITE,
  				      do_async, raid_addr, num_blocks,
 				      bp->b_data, bp, NULL, NULL, 
  				      RF_DAG_NONBLOCKING_IO, NULL, NULL, NULL);
  
d1603 1
a1603 1
	int s;
d1652 1
a1652 1
			queue->raidPtr->numNewFailures++;
d1680 12
a1691 13
InitBP(bp, b_vp, rw_flag, dev, startSect, numSect, buf, cbFunc, cbArg,
       logBytesPerSector, b_proc)
	struct buf *bp;
	struct vnode *b_vp;
	unsigned rw_flag;
	dev_t dev;
	RF_SectorNum_t startSect;
	RF_SectorCount_t numSect;
	caddr_t buf;
	void (*cbFunc) (struct buf *);
	void *cbArg;
	int logBytesPerSector;
	struct proc *b_proc;
d1699 1
a1699 1
	bp->b_data = buf;
d1914 5
a1918 5
	RF_ComponentLabel_t clabel;
	raidread_component_label(dev, b_vp, &clabel);
	clabel.mod_counter = mod_counter;
	clabel.clean = RF_RAID_CLEAN;
	raidwrite_component_label(dev, b_vp, &clabel);
d1926 5
a1930 5
	RF_ComponentLabel_t clabel;
	raidread_component_label(dev, b_vp, &clabel);
	clabel.mod_counter = mod_counter;
	clabel.clean = RF_RAID_DIRTY;
	raidwrite_component_label(dev, b_vp, &clabel);
d1936 1
a1936 1
raidread_component_label(dev, b_vp, clabel)
d1939 1
a1939 1
	RF_ComponentLabel_t *clabel;
d1962 1
a1962 1
		memcpy(clabel, bp->b_data,
d1965 10
a1974 1
		rf_print_component_label( clabel );
a1976 1
#if 0
a1977 1
#endif
d1986 1
a1986 1
raidwrite_component_label(dev, b_vp, clabel)
d1989 1
a1989 1
	RF_ComponentLabel_t *clabel;
d2004 1
a2004 1
	memset(bp->b_data, 0, RF_COMPONENT_INFO_SIZE );
d2006 1
a2006 1
	memcpy(bp->b_data, clabel, sizeof(RF_ComponentLabel_t));
a2012 1
#if 1
a2013 1
#endif
d2020 1
a2020 1
rf_markalldirty(raidPtr)
d2023 1
a2023 1
	RF_ComponentLabel_t clabel;
d2033 2
a2034 2
					&clabel);
				if (clabel.status == rf_ds_spared) {
d2040 1
a2040 1
				clabel.status = 
d2045 1
a2045 1
					&clabel);
d2091 1
a2091 1
				      &clabel);
d2093 9
a2101 9
			clabel.version = RF_COMPONENT_LABEL_VERSION; 
			clabel.mod_counter = raidPtr->mod_counter;
			clabel.serial_number = raidPtr->serial_number;
			clabel.row = srow;
			clabel.column = scol;
			clabel.num_rows = raidPtr->numRow;
			clabel.num_columns = raidPtr->numCol;
			clabel.clean = RF_RAID_DIRTY; /* changed in a bit*/
			clabel.status = rf_ds_optimal;
d2105 1
a2105 1
				      &clabel);
d2116 1
a2116 1
rf_update_component_labels(raidPtr, final)
a2117 1
	int final;
d2119 1
a2119 1
	RF_ComponentLabel_t clabel;
d2139 1
a2139 1
					&clabel);
d2141 1
a2141 4
				clabel.status = rf_ds_optimal;
				/* bump the counter */
				clabel.mod_counter = raidPtr->mod_counter;

d2145 6
a2150 8
					&clabel);
				if (final == RF_FINAL_COMPONENT_UPDATE) {
					if (raidPtr->parity_good == RF_RAID_CLEAN) {
						raidmarkclean( 
							      raidPtr->Disks[r][c].dev, 
							      raidPtr->raid_cinfo[r][c].ci_vp,
							      raidPtr->mod_counter);
					}
d2154 22
a2203 1
			/* XXX shouldn't *really* need this... */
d2207 1
a2207 1
				      &clabel);
d2209 9
a2217 8

			raid_init_component_label(raidPtr, &clabel);

			clabel.mod_counter = raidPtr->mod_counter;
			clabel.row = srow;
			clabel.column = scol;
			clabel.status = rf_ds_optimal;

d2221 5
a2225 7
				      &clabel);
			if (final == RF_FINAL_COMPONENT_UPDATE) {
				if (raidPtr->parity_good == RF_RAID_CLEAN) {
					raidmarkclean( raidPtr->Disks[0][sparecol].dev,
						       raidPtr->raid_cinfo[0][sparecol].ci_vp,
						       raidPtr->mod_counter);
				}
a2231 60
void
rf_close_component(raidPtr, vp, auto_configured)
	RF_Raid_t *raidPtr;
	struct vnode *vp;
	int auto_configured;
{
	struct proc *p;

	p = raidPtr->engine_thread;

	if (vp != NULL) {
		if (auto_configured == 1) {
			VOP_CLOSE(vp, FREAD, NOCRED, 0);
			vput(vp);
			
		} else {				
			VOP_UNLOCK(vp, 0);
			(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);
		}
	} else {
		printf("vnode was NULL\n");
	}
}


void
rf_UnconfigureVnodes(raidPtr)
	RF_Raid_t *raidPtr;
{
	int r,c; 
	struct proc *p;
	struct vnode *vp;
	int acd;


	/* We take this opportunity to close the vnodes like we should.. */

	p = raidPtr->engine_thread;

	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			printf("Closing vnode for row: %d col: %d\n", r, c);
			vp = raidPtr->raid_cinfo[r][c].ci_vp;
			acd = raidPtr->Disks[r][c].auto_configured;
			rf_close_component(raidPtr, vp, acd);
			raidPtr->raid_cinfo[r][c].ci_vp = NULL;
			raidPtr->Disks[r][c].auto_configured = 0;
		}
	}
	for (r = 0; r < raidPtr->numSpare; r++) {
		printf("Closing vnode for spare: %d\n", r);
		vp = raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp;
		acd = raidPtr->Disks[0][raidPtr->numCol + r].auto_configured;
		rf_close_component(raidPtr, vp, acd);
		raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;
		raidPtr->Disks[0][raidPtr->numCol + r].auto_configured = 0;
	}
}


a2276 5
	/* Anyone waiting for us to stop?  If so, inform them... */
	if (raidPtr->waitShutdown) {
		wakeup(&raidPtr->parity_rewrite_in_progress);
	}

a2316 697
}

void
rf_mountroot_hook(dev)
	struct device *dev;
{

}


RF_AutoConfig_t *
rf_find_raid_components()
{
	struct devnametobdevmaj *dtobdm;
	struct vnode *vp;
	struct disklabel label;
	struct device *dv;
	char *cd_name;
	dev_t dev;
	int error;
	int i;
	int good_one;
	RF_ComponentLabel_t *clabel;
	RF_AutoConfig_t *ac_list;
	RF_AutoConfig_t *ac;


	/* initialize the AutoConfig list */
	ac_list = NULL;

if (raidautoconfig) {

	/* we begin by trolling through *all* the devices on the system */

	for (dv = alldevs.tqh_first; dv != NULL;
	     dv = dv->dv_list.tqe_next) {

		/* we are only interested in disks... */
		if (dv->dv_class != DV_DISK)
			continue;

		/* we don't care about floppies... */
		if (!strcmp(dv->dv_cfdata->cf_driver->cd_name,"fd")) {
			continue;
		}
		
		/* need to find the device_name_to_block_device_major stuff */
		cd_name = dv->dv_cfdata->cf_driver->cd_name;
		dtobdm = dev_name2blk;
		while (dtobdm->d_name && strcmp(dtobdm->d_name, cd_name)) {
			dtobdm++;
		}

		/* get a vnode for the raw partition of this disk */

		dev = MAKEDISKDEV(dtobdm->d_maj, dv->dv_unit, RAW_PART);
		if (bdevvp(dev, &vp))
			panic("RAID can't alloc vnode");

		error = VOP_OPEN(vp, FREAD, NOCRED, 0);

		if (error) {
			/* "Who cares."  Continue looking 
			   for something that exists*/
			vput(vp);
			continue;
		}

		/* Ok, the disk exists.  Go get the disklabel. */
		error = VOP_IOCTL(vp, DIOCGDINFO, (caddr_t)&label, 
				  FREAD, NOCRED, 0);
		if (error) {
			/*
			 * XXX can't happen - open() would
			 * have errored out (or faked up one)
			 */
			printf("can't get label for dev %s%c (%d)!?!?\n",
			       dv->dv_xname, 'a' + RAW_PART, error);
		}

		/* don't need this any more.  We'll allocate it again
		   a little later if we really do... */
		VOP_CLOSE(vp, FREAD, NOCRED, 0);
		vput(vp);

		for (i=0; i < label.d_npartitions; i++) {
			/* We only support partitions marked as RAID */
			if (label.d_partitions[i].p_fstype != FS_RAID)
				continue;

			dev = MAKEDISKDEV(dtobdm->d_maj, dv->dv_unit, i);
			if (bdevvp(dev, &vp))
				panic("RAID can't alloc vnode");

			error = VOP_OPEN(vp, FREAD, NOCRED, 0);
			if (error) {
				/* Whatever... */
				vput(vp);
				continue;
			}

			good_one = 0;

			clabel = (RF_ComponentLabel_t *) 
				malloc(sizeof(RF_ComponentLabel_t), 
				       M_RAIDFRAME, M_NOWAIT);
			if (clabel == NULL) {
				/* XXX CLEANUP HERE */
				printf("RAID auto config: out of memory!\n");
				return(NULL); /* XXX probably should panic? */
			}

			if (!raidread_component_label(dev, vp, clabel)) {
				/* Got the label.  Does it look reasonable? */
				if (rf_reasonable_label(clabel) &&
				    (clabel->partitionSize <= 
				     label.d_partitions[i].p_size)) {
#if DEBUG
					printf("Component on: %s%c: %d\n", 
					       dv->dv_xname, 'a'+i,
					       label.d_partitions[i].p_size);
					rf_print_component_label(clabel);
#endif
					/* if it's reasonable, add it, 
					   else ignore it. */
					ac = (RF_AutoConfig_t *)
						malloc(sizeof(RF_AutoConfig_t),
						       M_RAIDFRAME,
						       M_NOWAIT);
					if (ac == NULL) {
						/* XXX should panic?? */
						return(NULL);
					}
					
					sprintf(ac->devname, "%s%c",
						dv->dv_xname, 'a'+i);
					ac->dev = dev;
					ac->vp = vp;
					ac->clabel = clabel;
					ac->next = ac_list;
					ac_list = ac;
					good_one = 1;
				} 
			}
			if (!good_one) {
				/* cleanup */
				free(clabel, M_RAIDFRAME);
				VOP_CLOSE(vp, FREAD, NOCRED, 0);
				vput(vp);
			}
		}
	}
}
return(ac_list);
}
			
static int
rf_reasonable_label(clabel)
	RF_ComponentLabel_t *clabel;
{
	
	if (((clabel->version==RF_COMPONENT_LABEL_VERSION_1) ||
	     (clabel->version==RF_COMPONENT_LABEL_VERSION)) &&
	    ((clabel->clean == RF_RAID_CLEAN) ||
	     (clabel->clean == RF_RAID_DIRTY)) &&
	    clabel->row >=0 && 
	    clabel->column >= 0 && 
	    clabel->num_rows > 0 &&
	    clabel->num_columns > 0 &&
	    clabel->row < clabel->num_rows && 
	    clabel->column < clabel->num_columns &&
	    clabel->blockSize > 0 &&
	    clabel->numBlocks > 0) {
		/* label looks reasonable enough... */
		return(1);
	}
	return(0);
}


void
rf_print_component_label(clabel)
	RF_ComponentLabel_t *clabel;
{
	printf("   Row: %d Column: %d Num Rows: %d Num Columns: %d\n",
	       clabel->row, clabel->column, 
	       clabel->num_rows, clabel->num_columns);
	printf("   Version: %d Serial Number: %d Mod Counter: %d\n",
	       clabel->version, clabel->serial_number,
	       clabel->mod_counter);
	printf("   Clean: %s Status: %d\n",
	       clabel->clean ? "Yes" : "No", clabel->status );
	printf("   sectPerSU: %d SUsPerPU: %d SUsPerRU: %d\n",
	       clabel->sectPerSU, clabel->SUsPerPU, clabel->SUsPerRU);
	printf("   RAID Level: %c  blocksize: %d numBlocks: %d\n",
	       (char) clabel->parityConfig, clabel->blockSize, 
	       clabel->numBlocks);
	printf("   Autoconfig: %s\n", clabel->autoconfigure ? "Yes" : "No" );
	printf("   Contains root partition: %s\n",  
	       clabel->root_partition ? "Yes" : "No" );
	printf("   Last configured as: raid%d\n", clabel->last_unit );
#if 0
	   printf("   Config order: %d\n", clabel->config_order);
#endif
	       
}

RF_ConfigSet_t *
rf_create_auto_sets(ac_list)
	RF_AutoConfig_t *ac_list;
{
	RF_AutoConfig_t *ac;
	RF_ConfigSet_t *config_sets;
	RF_ConfigSet_t *cset;
	RF_AutoConfig_t *ac_next;


	config_sets = NULL;

	/* Go through the AutoConfig list, and figure out which components
	   belong to what sets.  */
	ac = ac_list;
	while(ac!=NULL) {
		/* we're going to putz with ac->next, so save it here
		   for use at the end of the loop */
		ac_next = ac->next;

		if (config_sets == NULL) {
			/* will need at least this one... */
			config_sets = (RF_ConfigSet_t *)
				malloc(sizeof(RF_ConfigSet_t), 
				       M_RAIDFRAME, M_NOWAIT);
			if (config_sets == NULL) {
				panic("rf_create_auto_sets: No memory!\n");
			}
			/* this one is easy :) */
			config_sets->ac = ac;
			config_sets->next = NULL;
			config_sets->rootable = 0;
			ac->next = NULL;
		} else {
			/* which set does this component fit into? */
			cset = config_sets;
			while(cset!=NULL) {
				if (rf_does_it_fit(cset, ac)) {
					/* looks like it matches... */
					ac->next = cset->ac;
					cset->ac = ac;
					break;
				}
				cset = cset->next;
			}
			if (cset==NULL) {
				/* didn't find a match above... new set..*/
				cset = (RF_ConfigSet_t *)
					malloc(sizeof(RF_ConfigSet_t), 
					       M_RAIDFRAME, M_NOWAIT);
				if (cset == NULL) {
					panic("rf_create_auto_sets: No memory!\n");
				}
				cset->ac = ac;
				ac->next = NULL;
				cset->next = config_sets;
				cset->rootable = 0;
				config_sets = cset;
			}
		}
		ac = ac_next;
	}


	return(config_sets);
}

static int
rf_does_it_fit(cset, ac)	
	RF_ConfigSet_t *cset;
	RF_AutoConfig_t *ac;
{
	RF_ComponentLabel_t *clabel1, *clabel2;

	/* If this one matches the *first* one in the set, that's good
	   enough, since the other members of the set would have been
	   through here too... */
	/* note that we are not checking partitionSize here..

	   Note that we are also not checking the mod_counters here.
	   If everything else matches execpt the mod_counter, that's 
	   good enough for this test.  We will deal with the mod_counters
	   a little later in the autoconfiguration process.  

	    (clabel1->mod_counter == clabel2->mod_counter) &&

	   The reason we don't check for this is that failed disks
	   will have lower modification counts.  If those disks are
	   not added to the set they used to belong to, then they will
	   form their own set, which may result in 2 different sets,
	   for example, competing to be configured at raid0, and
	   perhaps competing to be the root filesystem set.  If the
	   wrong ones get configured, or both attempt to become /,
	   weird behaviour and or serious lossage will occur.  Thus we
	   need to bring them into the fold here, and kick them out at
	   a later point.

	*/

	clabel1 = cset->ac->clabel;
	clabel2 = ac->clabel;
	if ((clabel1->version == clabel2->version) &&
	    (clabel1->serial_number == clabel2->serial_number) &&
	    (clabel1->num_rows == clabel2->num_rows) &&
	    (clabel1->num_columns == clabel2->num_columns) &&
	    (clabel1->sectPerSU == clabel2->sectPerSU) &&
	    (clabel1->SUsPerPU == clabel2->SUsPerPU) &&
	    (clabel1->SUsPerRU == clabel2->SUsPerRU) &&
	    (clabel1->parityConfig == clabel2->parityConfig) &&
	    (clabel1->maxOutstanding == clabel2->maxOutstanding) &&
	    (clabel1->blockSize == clabel2->blockSize) &&
	    (clabel1->numBlocks == clabel2->numBlocks) &&
	    (clabel1->autoconfigure == clabel2->autoconfigure) &&
	    (clabel1->root_partition == clabel2->root_partition) &&
	    (clabel1->last_unit == clabel2->last_unit) &&
	    (clabel1->config_order == clabel2->config_order)) {
		/* if it get's here, it almost *has* to be a match */
	} else {
		/* it's not consistent with somebody in the set.. 
		   punt */
		return(0);
	}
	/* all was fine.. it must fit... */
	return(1);
}

int
rf_have_enough_components(cset)
	RF_ConfigSet_t *cset;
{
	RF_AutoConfig_t *ac;
	RF_AutoConfig_t *auto_config;
	RF_ComponentLabel_t *clabel;
	int r,c;
	int num_rows;
	int num_cols;
	int num_missing;
	int mod_counter;
	int mod_counter_found;
	int even_pair_failed;
	char parity_type;
	

	/* check to see that we have enough 'live' components
	   of this set.  If so, we can configure it if necessary */

	num_rows = cset->ac->clabel->num_rows;
	num_cols = cset->ac->clabel->num_columns;
	parity_type = cset->ac->clabel->parityConfig;

	/* XXX Check for duplicate components!?!?!? */

	/* Determine what the mod_counter is supposed to be for this set. */

	mod_counter_found = 0;
	ac = cset->ac;
	while(ac!=NULL) {
		if (mod_counter_found==0) {
			mod_counter = ac->clabel->mod_counter;
			mod_counter_found = 1;
		} else {
			if (ac->clabel->mod_counter > mod_counter) {
				mod_counter = ac->clabel->mod_counter;
			}
		}
		ac = ac->next;
	}

	num_missing = 0;
	auto_config = cset->ac;

	for(r=0; r<num_rows; r++) {
		even_pair_failed = 0;
		for(c=0; c<num_cols; c++) {
			ac = auto_config;
			while(ac!=NULL) {
				if ((ac->clabel->row == r) &&
				    (ac->clabel->column == c) && 
				    (ac->clabel->mod_counter == mod_counter)) {
					/* it's this one... */
#if DEBUG
					printf("Found: %s at %d,%d\n",
					       ac->devname,r,c);
#endif
					break;
				}
				ac=ac->next;
			}
			if (ac==NULL) {
				/* Didn't find one here! */
				/* special case for RAID 1, especially
				   where there are more than 2
				   components (where RAIDframe treats
				   things a little differently :( ) */
				if (parity_type == '1') {
					if (c%2 == 0) { /* even component */
						even_pair_failed = 1;
					} else { /* odd component.  If
                                                    we're failed, and
                                                    so is the even
                                                    component, it's
                                                    "Good Night, Charlie" */
						if (even_pair_failed == 1) {
							return(0);
						}
					}
				} else {
					/* normal accounting */
					num_missing++;
				}
			}
			if ((parity_type == '1') && (c%2 == 1)) {
				/* Just did an even component, and we didn't
				   bail.. reset the even_pair_failed flag, 
				   and go on to the next component.... */
				even_pair_failed = 0;
			}
		}
	}

	clabel = cset->ac->clabel;

	if (((clabel->parityConfig == '0') && (num_missing > 0)) ||
	    ((clabel->parityConfig == '4') && (num_missing > 1)) ||
	    ((clabel->parityConfig == '5') && (num_missing > 1))) {
		/* XXX this needs to be made *much* more general */
		/* Too many failures */
		return(0);
	}
	/* otherwise, all is well, and we've got enough to take a kick
	   at autoconfiguring this set */
	return(1);
}

void
rf_create_configuration(ac,config,raidPtr)
	RF_AutoConfig_t *ac;
	RF_Config_t *config;
	RF_Raid_t *raidPtr;
{
	RF_ComponentLabel_t *clabel;
	int i;

	clabel = ac->clabel;

	/* 1. Fill in the common stuff */
	config->numRow = clabel->num_rows;
	config->numCol = clabel->num_columns;
	config->numSpare = 0; /* XXX should this be set here? */
	config->sectPerSU = clabel->sectPerSU;
	config->SUsPerPU = clabel->SUsPerPU;
	config->SUsPerRU = clabel->SUsPerRU;
	config->parityConfig = clabel->parityConfig;
	/* XXX... */
	strcpy(config->diskQueueType,"fifo");
	config->maxOutstandingDiskReqs = clabel->maxOutstanding;
	config->layoutSpecificSize = 0; /* XXX ?? */

	while(ac!=NULL) {
		/* row/col values will be in range due to the checks
		   in reasonable_label() */
		strcpy(config->devnames[ac->clabel->row][ac->clabel->column],
		       ac->devname);
		ac = ac->next;
	}

	for(i=0;i<RF_MAXDBGV;i++) {
		config->debugVars[i][0] = NULL;
	}
}

int
rf_set_autoconfig(raidPtr, new_value)
	RF_Raid_t *raidPtr;
	int new_value;
{
	RF_ComponentLabel_t clabel;
	struct vnode *vp;
	dev_t dev;
	int row, column;

	raidPtr->autoconfigure = new_value;
	for(row=0; row<raidPtr->numRow; row++) {
		for(column=0; column<raidPtr->numCol; column++) {
			if (raidPtr->Disks[row][column].status == 
			    rf_ds_optimal) {
				dev = raidPtr->Disks[row][column].dev;
				vp = raidPtr->raid_cinfo[row][column].ci_vp;
				raidread_component_label(dev, vp, &clabel);
				clabel.autoconfigure = new_value;
				raidwrite_component_label(dev, vp, &clabel);
			}
		}
	}
	return(new_value);
}

int
rf_set_rootpartition(raidPtr, new_value)
	RF_Raid_t *raidPtr;
	int new_value;
{
	RF_ComponentLabel_t clabel;
	struct vnode *vp;
	dev_t dev;
	int row, column;

	raidPtr->root_partition = new_value;
	for(row=0; row<raidPtr->numRow; row++) {
		for(column=0; column<raidPtr->numCol; column++) {
			if (raidPtr->Disks[row][column].status == 
			    rf_ds_optimal) {
				dev = raidPtr->Disks[row][column].dev;
				vp = raidPtr->raid_cinfo[row][column].ci_vp;
				raidread_component_label(dev, vp, &clabel);
				clabel.root_partition = new_value;
				raidwrite_component_label(dev, vp, &clabel);
			}
		}
	}
	return(new_value);
}

void
rf_release_all_vps(cset)
	RF_ConfigSet_t *cset;
{
	RF_AutoConfig_t *ac;
	
	ac = cset->ac;
	while(ac!=NULL) {
		/* Close the vp, and give it back */
		if (ac->vp) {
			VOP_CLOSE(ac->vp, FREAD, NOCRED, 0);
			vput(ac->vp);
			ac->vp = NULL;
		}
		ac = ac->next;
	}
}


void
rf_cleanup_config_set(cset)
	RF_ConfigSet_t *cset;
{
	RF_AutoConfig_t *ac;
	RF_AutoConfig_t *next_ac;
	
	ac = cset->ac;
	while(ac!=NULL) {
		next_ac = ac->next;
		/* nuke the label */
		free(ac->clabel, M_RAIDFRAME);
		/* cleanup the config structure */
		free(ac, M_RAIDFRAME);
		/* "next.." */
		ac = next_ac;
	}
	/* and, finally, nuke the config set */
	free(cset, M_RAIDFRAME);
}


void
raid_init_component_label(raidPtr, clabel)
	RF_Raid_t *raidPtr;
	RF_ComponentLabel_t *clabel;
{
	/* current version number */
	clabel->version = RF_COMPONENT_LABEL_VERSION; 
	clabel->serial_number = raidPtr->serial_number;
	clabel->mod_counter = raidPtr->mod_counter;
	clabel->num_rows = raidPtr->numRow;
	clabel->num_columns = raidPtr->numCol;
	clabel->clean = RF_RAID_DIRTY; /* not clean */
	clabel->status = rf_ds_optimal; /* "It's good!" */
	
	clabel->sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	clabel->SUsPerPU = raidPtr->Layout.SUsPerPU;
	clabel->SUsPerRU = raidPtr->Layout.SUsPerRU;

	clabel->blockSize = raidPtr->bytesPerSector;
	clabel->numBlocks = raidPtr->sectorsPerDisk;

	/* XXX not portable */
	clabel->parityConfig = raidPtr->Layout.map->parityConfig;
	clabel->maxOutstanding = raidPtr->maxOutstanding;
	clabel->autoconfigure = raidPtr->autoconfigure;
	clabel->root_partition = raidPtr->root_partition;
	clabel->last_unit = raidPtr->raidid;
	clabel->config_order = raidPtr->config_order;
}

int
rf_auto_config_set(cset,unit)
	RF_ConfigSet_t *cset;
	int *unit;
{
	RF_Raid_t *raidPtr;
	RF_Config_t *config;
	int raidID;
	int retcode;

	printf("RAID autoconfigure\n");

	retcode = 0;
	*unit = -1;

	/* 1. Create a config structure */

	config = (RF_Config_t *)malloc(sizeof(RF_Config_t),
				       M_RAIDFRAME,
				       M_NOWAIT);
	if (config==NULL) {
		printf("Out of mem!?!?\n");
				/* XXX do something more intelligent here. */
		return(1);
	}

	memset(config, 0, sizeof(RF_Config_t));

	/* XXX raidID needs to be set correctly.. */

	/* 
	   2. Figure out what RAID ID this one is supposed to live at 
	   See if we can get the same RAID dev that it was configured
	   on last time.. 
	*/

	raidID = cset->ac->clabel->last_unit;
	if ((raidID < 0) || (raidID >= numraid)) {
		/* let's not wander off into lala land. */
		raidID = numraid - 1;
	}
	if (raidPtrs[raidID]->valid != 0) {

		/* 
		   Nope... Go looking for an alternative...  
		   Start high so we don't immediately use raid0 if that's
		   not taken. 
		*/

		for(raidID = numraid; raidID >= 0; raidID--) {
			if (raidPtrs[raidID]->valid == 0) {
				/* can use this one! */
				break;
			}
		}
	}

	if (raidID < 0) {
		/* punt... */
		printf("Unable to auto configure this set!\n");
		printf("(Out of RAID devs!)\n");
		return(1);
	}
	printf("Configuring raid%d:\n",raidID);
	raidPtr = raidPtrs[raidID];

	/* XXX all this stuff should be done SOMEWHERE ELSE! */
	raidPtr->raidid = raidID;
	raidPtr->openings = RAIDOUTSTANDING;

	/* 3. Build the configuration structure */
	rf_create_configuration(cset->ac, config, raidPtr);

	/* 4. Do the configuration */
	retcode = rf_Configure(raidPtr, config, cset->ac);
	
	if (retcode == 0) {

		raidinit(raidPtrs[raidID]);

		rf_markalldirty(raidPtrs[raidID]);
		raidPtrs[raidID]->autoconfigure = 1; /* XXX do this here? */
		if (cset->ac->clabel->root_partition==1) {
			/* everything configured just fine.  Make a note
			   that this set is eligible to be root. */
			cset->rootable = 1;
			/* XXX do this here? */
			raidPtrs[raidID]->root_partition = 1; 
		}
	}

	/* 5. Cleanup */
	free(config, M_RAIDFRAME);
	
	*unit = raidID;
	return(retcode);
@


1.6.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.6.2.3
log
@Merge in -current from roughly a week ago
@
text
@d183 1
a183 1
static void raidinit(RF_Raid_t *);
d185 9
a193 9
void raidattach(int);
int raidsize(dev_t);
int raidopen(dev_t, int, int, struct proc *);
int raidclose(dev_t, int, int, struct proc *);
int raidioctl(dev_t, u_long, caddr_t, int, struct proc *);
int raidwrite(dev_t, struct uio *, int);
int raidread(dev_t, struct uio *, int);
void raidstrategy(struct buf *);
int raiddump(dev_t, daddr_t, caddr_t, size_t);
d260 4
a263 4
static void raidgetdefaultlabel(RF_Raid_t *, struct raid_softc *, 
				     struct disklabel *);
static void raidgetdisklabel(dev_t);
static void raidmakedisklabel(struct raid_softc *);
d265 2
a266 2
static int raidlock(struct raid_softc *);
static void raidunlock(struct raid_softc *);
d268 2
a269 2
static void rf_markalldirty(RF_Raid_t *);
void rf_mountroot_hook(struct device *);
d273 1
a273 1
void rf_ReconThread(struct rf_recon_req *);
d275 18
a292 18
/*void rf_ReconThread(RF_Raid_t *raidPtr);  */
void rf_RewriteParityThread(RF_Raid_t *raidPtr);
void rf_CopybackThread(RF_Raid_t *raidPtr);
void rf_ReconstructInPlaceThread(struct rf_recon_req *);
void rf_buildroothack(void *);

RF_AutoConfig_t *rf_find_raid_components(void);
RF_ConfigSet_t *rf_create_auto_sets(RF_AutoConfig_t *);
static int rf_does_it_fit(RF_ConfigSet_t *,RF_AutoConfig_t *);
static int rf_reasonable_label(RF_ComponentLabel_t *);
void rf_create_configuration(RF_AutoConfig_t *,RF_Config_t *,
				  RF_Raid_t *);
int rf_set_autoconfig(RF_Raid_t *, int);
int rf_set_rootpartition(RF_Raid_t *, int);
void rf_release_all_vps(RF_ConfigSet_t *);
void rf_cleanup_config_set(RF_ConfigSet_t *);
int rf_have_enough_components(RF_ConfigSet_t *);
int rf_auto_config_set(RF_ConfigSet_t *, int *);
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@d327 1
a327 1
		panic("raidPtrs is NULL!!");
d343 1
a343 1
		panic("Serious error booting RAID!!");
d361 1
a361 1
		panic("No memory for RAIDframe driver!!?!?!");
d1554 1
a1554 1
		    "RAIDframe getsparetable", 0);
d1722 1
a1722 1
		panic("Invalid Unit number in rf_DispatchKernelIO");
d1925 1
a1925 1
		panic("bp->b_bcount is zero in InitBP!!");
d2818 1
a2818 1
				panic("rf_create_auto_sets: No memory!");
d2843 1
a2843 1
					panic("rf_create_auto_sets: No memory!");
@


1.6.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_netbsdkintf.c,v 1.6.2.4 2003/03/28 00:38:28 niklas Exp $	*/
d56 5
a60 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.2.6
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_netbsdkintf.c,v 1.6.2.5 2003/06/07 11:02:31 ho Exp $	*/
@


1.5
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 1
a1 1
/*	$NetBSD: rf_netbsdkintf.c,v 1.39 2000/01/06 02:06:41 oster Exp $	*/
d140 1
a157 2
#define db0_printf(a) printf a
#define db_printf(a) if (rf_kdebug_level > 0) printf a
a158 4
#define db2_printf(a) if (rf_kdebug_level > 1) printf a
#define db3_printf(a) if (rf_kdebug_level > 2) printf a
#define db4_printf(a) if (rf_kdebug_level > 3) printf a
#define db5_printf(a) if (rf_kdebug_level > 4) printf a
a159 1
#define db0_printf(a) printf a
a160 4
#define db2_printf(a) { }
#define db3_printf(a) { }
#define db4_printf(a) { }
#define db5_printf(a) { }
d179 1
a179 3

int raidmarkclean(dev_t dev, struct vnode *b_vp, int);
int raidmarkdirty(dev_t dev, struct vnode *b_vp, int);
a182 5

void    rf_DiskIOComplete(RF_DiskQueue_t *, RF_DiskQueueData_t *, int);
void    rf_CopybackReconstructedData(RF_Raid_t * raidPtr);
static int raidinit __P((dev_t, RF_Raid_t *, int));

a190 3
int raidwrite_component_label(dev_t, struct vnode *, RF_ComponentLabel_t *);
int raidread_component_label(dev_t, struct vnode *, RF_ComponentLabel_t *);
void rf_update_component_labels( RF_Raid_t *);
a262 1
int raidlookup __P((char *, struct proc * p, struct vnode **));
d644 3
d658 1
d663 1
a709 1

a711 2

		db3_printf(("rf_ioctl: RAIDFRAME_CONFIGURE\n"));
d714 1
a717 1
			db3_printf(("rf_ioctl: ENOMEM for config. Code is %d\n", retcode));
d724 1
a724 1
			db3_printf(("rf_ioctl: retcode=%d copyin.1\n",
a733 1
				db3_printf(("rf_ioctl: EINVAL %d\n", retcode));
a739 1
				db3_printf(("rf_ioctl: ENOMEM %d\n", retcode));
d747 3
a749 2
				RF_Free(specific_buf, k_cfg->layoutSpecificSize);
				db3_printf(("rf_ioctl: retcode=%d copyin.2\n",
d762 1
a762 1
		raidPtrs[unit]->raidid = unit;
d764 1
a764 1
		retcode = rf_Configure(raidPtrs[unit], k_cfg);
d766 1
a766 2
		/* allow this many simultaneous IO's to this RAID device */
		raidPtrs[unit]->openings = RAIDOUTSTANDING;
d768 5
a772 1
		/* XXX should be moved to rf_Configure() */
d774 3
a776 3
		raidPtrs[unit]->copyback_in_progress = 0;
		raidPtrs[unit]->parity_rewrite_in_progress = 0;
		raidPtrs[unit]->recon_in_progress = 0;
d778 2
a779 3
		if (retcode == 0) {
			retcode = raidinit(dev, raidPtrs[unit], unit);
			rf_markalldirty( raidPtrs[unit] );
a786 3
		db3_printf(("rf_ioctl: retcode=%d RAIDFRAME_CONFIGURE\n",
			retcode));

d809 1
a809 1
		retcode = rf_Shutdown(raidPtrs[unit]);
d825 1
a825 3
		   by row,column in component_label
		   XXX need to sanity check these values!!! 
		   */
d847 2
a848 2
		if ((row < 0) || (row >= raidPtrs[unit]->numRow) ||
		    (column < 0) || (column >= raidPtrs[unit]->numCol)) {
d854 2
a855 2
                              raidPtrs[unit]->Disks[row][column].dev, 
			      raidPtrs[unit]->raid_cinfo[row][column].ci_vp, 
d887 2
a888 2
		if ((row < 0) || (row >= raidPtrs[unit]->numRow) ||
		    (column < 0) || (column >= raidPtrs[unit]->numCol)) {
d895 2
a896 2
                            raidPtrs[unit]->Disks[row][column].dev, 
			    raidPtrs[unit]->raid_cinfo[row][column].ci_vp, 
d910 1
a910 1
		raidPtrs[unit]->serial_number = component_label->serial_number;
d914 3
a916 3
		ci_label.mod_counter = raidPtrs[unit]->mod_counter;
		ci_label.num_rows = raidPtrs[unit]->numRow;
		ci_label.num_columns = raidPtrs[unit]->numCol;
d920 1
a920 1
		for(row=0;row<raidPtrs[unit]->numRow;row++) {
d922 1
a922 1
			for(column=0;column<raidPtrs[unit]->numCol;column++) {
d925 2
a926 2
				  raidPtrs[unit]->Disks[row][column].dev, 
				  raidPtrs[unit]->raid_cinfo[row][column].ci_vp, 
d936 1
a936 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d938 1
a938 1
			raidPtrs[unit]->parity_good = RF_RAID_CLEAN;
d942 1
a942 1
		if (raidPtrs[unit]->parity_rewrite_in_progress == 1) {
d947 1
a947 3
		/* borrow the thread of the requesting process */

		retcode = RF_CREATE_THREAD(raidPtrs[unit]->parity_rewrite_thread,
d949 1
a949 1
					   raidPtrs[unit],"raid_parity");
d957 1
a957 1
		retcode = rf_add_hot_spare(raidPtrs[unit], &hot_spare);
d965 1
a965 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d970 1
a970 1
		if (raidPtrs[unit]->recon_in_progress == 1) {
d981 2
a982 2
		if ((row < 0) || (row >= raidPtrs[unit]->numRow) ||
		    (column < 0) || (column >= raidPtrs[unit]->numCol)) {
d990 1
a990 1
		rrcopy->raidPtr = (void *) raidPtrs[unit];
d994 1
a994 1
		retcode = RF_CREATE_THREAD(raidPtrs[unit]->recon_thread,
d1000 26
a1025 19
		{
			RF_Raid_t *raid = raidPtrs[unit];
			RF_DeviceConfig_t *cfg, **ucfgp;
			int     i, j, d;

			if (!raid->valid)
				return (ENODEV);
			ucfgp = (RF_DeviceConfig_t **) data;
			RF_Malloc(cfg, sizeof(RF_DeviceConfig_t),
				  (RF_DeviceConfig_t *));
			if (cfg == NULL)
				return (ENOMEM);
			bzero((char *) cfg, sizeof(RF_DeviceConfig_t));
			cfg->rows = raid->numRow;
			cfg->cols = raid->numCol;
			cfg->ndevs = raid->numRow * raid->numCol;
			if (cfg->ndevs >= RF_MAX_DISKS) {
				RF_Free(cfg, sizeof(RF_DeviceConfig_t));
				return (ENOMEM);
d1027 9
a1035 19
			cfg->nspares = raid->numSpare;
			if (cfg->nspares >= RF_MAX_DISKS) {
				RF_Free(cfg, sizeof(RF_DeviceConfig_t));
				return (ENOMEM);
			}
			cfg->maxqdepth = raid->maxQueueDepth;
			d = 0;
			for (i = 0; i < cfg->rows; i++) {
				for (j = 0; j < cfg->cols; j++) {
					cfg->devs[d] = raid->Disks[i][j];
					d++;
				}
			}
			for (j = cfg->cols, i = 0; i < cfg->nspares; i++, j++) {
				cfg->spares[i] = raid->Disks[0][j];
			}
			retcode = copyout((caddr_t) cfg, (caddr_t) * ucfgp,
					  sizeof(RF_DeviceConfig_t));
			RF_Free(cfg, sizeof(RF_DeviceConfig_t));
a1036 3
			return (retcode);
		}
		break;
d1038 1
a1038 1
		*(int *) data = raidPtrs[unit]->parity_good;
d1040 1
d1042 2
a1043 7
		{
			RF_Raid_t *raid = raidPtrs[unit];

			bzero(&raid->acc_totals, sizeof(raid->acc_totals));
			return (0);
		}
		break;
d1046 3
a1048 8
		{
			RF_AccTotals_t *totals = (RF_AccTotals_t *) data;
			RF_Raid_t *raid = raidPtrs[unit];

			*totals = raid->acc_totals;
			return (0);
		}
		break;
d1051 2
a1052 8
		{
			RF_Raid_t *raid = raidPtrs[unit];
			int    *keep = (int *) data;

			raid->keep_acc_totals = *keep;
			return (0);
		}
		break;
d1055 1
a1055 1
		*(int *) data = raidPtrs[unit]->totalSectors;
d1061 1
a1061 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d1068 2
a1069 2
		if (rr->row < 0 || rr->row >= raidPtrs[unit]->numRow
		    || rr->col < 0 || rr->col >= raidPtrs[unit]->numCol)
d1081 1
a1081 1
		rrcopy->raidPtr = (void *) raidPtrs[unit];
d1083 1
a1083 1
		retcode = RF_CREATE_THREAD(raidPtrs[unit]->recon_thread,
d1092 1
a1092 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d1097 1
a1097 1
		if (raidPtrs[unit]->copyback_in_progress == 1) {
d1102 1
a1102 1
		retcode = RF_CREATE_THREAD(raidPtrs[unit]->copyback_thread,
d1104 1
a1104 1
					   raidPtrs[unit],"raid_copyback");
d1109 1
a1109 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d1114 1
a1114 1
		if (raidPtrs[unit]->status[row] != rf_rs_reconstructing)
d1117 1
a1117 1
			*(int *) data = raidPtrs[unit]->reconControl[row]->percentComplete;
d1121 1
a1121 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d1125 2
a1126 2
		if (raidPtrs[unit]->parity_rewrite_in_progress == 1) {
			*(int *) data = 100 * raidPtrs[unit]->parity_rewrite_stripes_done / raidPtrs[unit]->Layout.numStripe;
d1133 1
a1133 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d1137 2
a1138 2
		if (raidPtrs[unit]->copyback_in_progress == 1) {
			*(int *) data = 100 * raidPtrs[unit]->copyback_stripes_done / raidPtrs[unit]->Layout.numStripe;
d1151 1
a1151 1
		 * character device) for delivering the table          -- XXX */
d1161 2
a1162 1
		*((RF_SparetWait_t *) data) = *waitreq;	/* structure assignment */
a1166 1

d1184 1
a1184 1
		retcode = rf_SetSpareTable(raidPtrs[unit], *(void **) data);
d1204 1
a1204 1
	if (!raidPtrs[unit]->valid)
d1253 1
a1253 1
		raidgetdefaultlabel(raidPtrs[unit], rs,
d1723 1
a1723 1
	lp->d_nsectors = 1024 * (1024 / raidPtr->bytesPerSector);
d1725 2
a1726 1
	lp->d_ncylinders = raidPtr->totalSectors / lp->d_nsectors;
@


1.4
log
@restore the NetBSD specific files to their -current state from
NetBSD. There is no reason to mess with these; they are just being
carried around as a reference at the moment.
@
text
@d1 1
a1 1
/*	$NetBSD: rf_netbsdkintf.c,v 1.21 1999/07/21 03:15:26 oster Exp $	*/
a155 5
#define RFK_BOOT_NONE 0
#define RFK_BOOT_GOOD 1
#define RFK_BOOT_BAD  2
static int rf_kbooted = RFK_BOOT_NONE;

a181 9
static struct rf_recon_req *recon_queue = NULL;	/* used to communicate
						 * reconstruction
						 * requests */


decl_simple_lock_data(, recon_queue_mutex)
#define LOCK_RECON_Q_MUTEX() simple_lock(&recon_queue_mutex)
#define UNLOCK_RECON_Q_MUTEX() simple_unlock(&recon_queue_mutex)

a189 9
#define Dprintf0(s)       if (rf_queueDebug) \
     rf_debug_printf(s,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf1(s,a)     if (rf_queueDebug) \
     rf_debug_printf(s,a,NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf2(s,a,b)   if (rf_queueDebug) \
     rf_debug_printf(s,a,b,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf3(s,a,b,c) if (rf_queueDebug) \
     rf_debug_printf(s,a,b,c,NULL,NULL,NULL,NULL,NULL)

d237 1
d252 12
a263 1
 * kernel memory, especially on writes... 
d267 1
a267 1
#define RAIDOUTSTANDING   10
d287 7
a325 1
	recon_queue = NULL;
a334 2
	rf_kbooted = RFK_BOOT_GOOD;

d349 3
d355 3
a357 1
			printf("raidPtrs[%d] is NULL\n", raidID);
d546 1
d549 5
a553 13
#if 0
	db1_printf(("Strategy: 0x%x 0x%x\n", bp, bp->b_data));
	db1_printf(("Strategy(2): bp->b_bufsize%d\n", (int) bp->b_bufsize));
	db1_printf(("bp->b_count=%d\n", (int) bp->b_bcount));
	db1_printf(("bp->b_resid=%d\n", (int) bp->b_resid));
	db1_printf(("bp->b_blkno=%d\n", (int) bp->b_blkno));

	if (bp->b_flags & B_READ)
		db1_printf(("READ\n"));
	else
		db1_printf(("WRITE\n"));
#endif
	if (rf_kbooted != RFK_BOOT_GOOD)
d555 1
d591 1
a591 2
	s = splbio();		/* XXX Needed? */
	db1_printf(("Beginning strategy...\n"));
d594 11
a604 7
	bp->b_error = rf_DoAccessKernel(raidPtrs[raidID], bp,
	    NULL, NULL, NULL);
	if (bp->b_error) {
		bp->b_flags |= B_ERROR;
		db1_printf(("bp->b_flags HAS B_ERROR SET!!!: %d\n",
			bp->b_error));
	}
a605 5
#if 0
	db1_printf(("Strategy exiting: 0x%x 0x%x %d %d\n",
		bp, bp->b_data,
		(int) bp->b_bcount, (int) bp->b_resid));
#endif
a663 7
#if 0
	int     r, c;
#endif
	/* struct raid_ioctl *ccio = (struct ccd_ioctl *)data; */

	/* struct ccdbuf *cbp; */
	/* struct raidbuf *raidbp; */
a668 1
	int s;
d710 1
a710 1
	case RAIDFRAME_CHECKRECON:
d717 3
d742 1
d752 1
d767 2
a779 10
#if 0
		db1_printf(("Considering configuring the system.:%d 0x%x\n",
			unit, p));
#endif

		/* We need the pointer to this a little deeper, so stash it
		 * here... */

		raidPtrs[unit]->proc = p;

d789 6
a829 5
		if (rf_debugKernelAccess) {
			printf("call shutdown\n");
		}
		raidPtrs[unit]->proc = p;	/* XXX  necessary evil */

a831 2
		db1_printf(("Done main shutdown\n"));

a832 1
		db1_printf(("Done freeing component buffer freelist\n"));
d863 1
a867 4
		printf("Row: %d\n",row);
		if (row > raidPtrs[unit]->numRow) {
			row = 0; /* XXX */
		}
d869 5
a873 3
		printf("Column: %d\n",column);
		if (column > raidPtrs[unit]->numCol) {
			column = 0; /* XXX */
d910 2
a911 2
		if ((row < 0) || (row > raidPtrs[unit]->numRow) ||
		    (column < 0) || (column > raidPtrs[unit]->numCol)) {
d965 5
a970 3
		raidPtrs[unit]->proc = p;	/* Blah... :-p GO */
		retcode = rf_RewriteParity(raidPtrs[unit]);
		/* return I/O Error if the parity rewrite fails */
d972 3
a974 8
		if (retcode) {
			retcode = EIO;
		} else {
			/* set the clean bit!  If we shutdown correctly,
			 the clean bit on each component label will get
			 set */
			raidPtrs[unit]->parity_good = RF_RAID_CLEAN;
		}
a981 1
		raidPtrs[unit]->proc = p;	/* Blah... :-p GO */
d989 11
d1006 2
a1007 2
		if ((row < 0) || (row > raidPtrs[unit]->numRow) ||
		    (column < 0) || (column > raidPtrs[unit]->numCol)) {
a1009 6
		printf("Attempting a rebuild in place\n");
		s = splbio();
		raidPtrs[unit]->proc = p;	/* Blah... :-p GO */
		retcode = rf_ReconstructInPlace(raidPtrs[unit], row, column);
		splx(s);
		return(retcode);
d1011 11
a1021 6
		/* issue a test-unit-ready through raidframe to the indicated
		 * device */
#if 0				/* XXX not supported yet (ever?) */
	case RAIDFRAME_TUR:
		/* debug only */
		retcode = rf_SCSI_DoTUR(0, 0, 0, 0, *(dev_t *) data);
d1023 1
a1023 1
#endif
d1042 1
a1042 1
				cfg->ndevs = 0;
d1047 1
a1047 1
				cfg->nspares = 0;
d1068 3
a1070 1

a1103 4
#define RAIDFRAME_RECON 1
		/* XXX The above should probably be set somewhere else!! GO */
#if RAIDFRAME_RECON > 0

d1106 6
d1124 2
d1129 3
a1131 6
		LOCK_RECON_Q_MUTEX();
		rrcopy->next = recon_queue;
		recon_queue = rrcopy;
		wakeup(&recon_queue);
		UNLOCK_RECON_Q_MUTEX();

d1137 15
a1151 6
		/* borrow the current thread to get this done */
		raidPtrs[unit]->proc = p;	/* ICK.. but needed :-p  GO */
		s = splbio();
		rf_CopybackReconstructedData(raidPtrs[unit]);
		splx(s);
		return (0);
d1154 3
a1156 3
	case RAIDFRAME_CHECKRECON:
		row = *(int *) data;
		if (row < 0 || row >= raidPtrs[unit]->numRow)
d1158 2
d1166 25
a1244 3

#endif				/* RAIDFRAME_RECON > 0 */

a1258 1
		db1_printf(("DIOCGDINFO %d %d\n", (int) dev, (int) DISKPART(dev)));
a1262 1
		db1_printf(("DIOCGPART: %d %d\n", (int) dev, (int) DISKPART(dev)));
a1268 1
		db1_printf(("DIOCWDINFO\n"));
a1269 1
		db1_printf(("DIOCSDINFO\n"));
a1291 1
		db1_printf(("DIOCWLABEL\n"));
a1298 1
		db1_printf(("DIOCGDEFLABEL\n"));
d1304 1
a1304 1
		retcode = ENOTTY;	/* XXXX ?? OR EINVAL ? */
a1321 2
	/* int ix; */
	/* struct raidbuf *raidbp; */
a1352 39
/*
 * This kernel thread never exits.  It is created once, and persists
 * until the system reboots.
 */

void 
rf_ReconKernelThread()
{
	struct rf_recon_req *req;
	int     s;

	/* XXX not sure what spl() level we should be at here... probably
	 * splbio() */
	s = splbio();

	while (1) {
		/* grab the next reconstruction request from the queue */
		LOCK_RECON_Q_MUTEX();
		while (!recon_queue) {
			UNLOCK_RECON_Q_MUTEX();
			tsleep(&recon_queue, PRIBIO,
			       "raidframe recon", 0);
			LOCK_RECON_Q_MUTEX();
		}
		req = recon_queue;
		recon_queue = recon_queue->next;
		UNLOCK_RECON_Q_MUTEX();

		/*
	         * If flags specifies that we should start recon, this call
	         * will not return until reconstruction completes, fails, 
		 * or is aborted.
	         */
		rf_FailDisk((RF_Raid_t *) req->raidPtr, req->row, req->col,
		    ((req->flags & RF_FDFLAGS_RECON) ? 1 : 0));

		RF_Free(req, sizeof(*req));
	}
}
d1359 2
a1376 5
#if 0
		mpsleep(&rf_sparet_resp_queue, PZERO, "sparet resp", 0, 
			(void *) simple_lock_addr(rf_sparet_wait_mutex), 
			MS_LOCK_SIMPLE);
#endif
d1387 1
d1393 2
d1396 2
a1397 2
int 
rf_DoAccessKernel(raidPtr, bp, flags, cbFunc, cbArg)
a1398 4
	struct buf *bp;
	RF_RaidAccessFlags_t flags;
	void    (*cbFunc) (struct buf *);
	void   *cbArg;
d1408 2
a1409 2

	/* XXX The dev_t used here should be for /dev/[r]raid* !!! */
d1414 22
d1437 2
a1438 1
	 * partition.. Need to make it absolute to the underlying device.. */
a1443 4
		db1_printf(("updated: %d %d\n", DISKPART(bp->b_dev),
			pp->p_offset));
	} else {
		db1_printf(("Is raw..\n"));
d1445 3
a1447 1
	db1_printf(("Blocks: %d, %d\n", (int) bp->b_blkno, (int) blocknum));
d1452 2
a1453 2
	/* *THIS* is where we adjust what block we're going to... but DO NOT
	 * TOUCH bp->b_blkno!!! */
d1470 2
a1471 1
		return (bp->b_error);
d1482 3
a1484 1
		return (bp->b_error);
a1488 7
	/* Put a throttle on the number of requests we handle simultanously */

	RF_LOCK_MUTEX(raidPtr->mutex);

	while(raidPtr->openings <= 0) {
		RF_UNLOCK_MUTEX(raidPtr->mutex);
		(void)tsleep(&raidPtr->openings, PRIBIO, "rfdwait", 0);
a1489 1
	}
a1490 1

d1497 6
d1504 1
a1504 2
	/* don't ever condition on bp->b_flags & B_WRITE.  always condition on
	 * B_READ instead */
d1508 3
a1510 7
	    bp->b_un.b_addr,
	    bp, NULL, NULL, RF_DAG_NONBLOCKING_IO | flags,
	    NULL, cbFunc, cbArg);
#if 0
	db1_printf(("After call to DoAccess: 0x%x 0x%x %d\n", bp,
		bp->b_data, (int) bp->b_resid));
#endif
d1512 3
a1514 1
	return (retcode);
d1516 4
d1532 1
d1534 2
d1578 2
a1581 2
		/* Dprintf2("rf_DispatchKernelIO: NOP to r %d c %d\n",
		 * queue->row, queue->col); */
a1613 2
		/* Dprintf3("rf_DispatchKernelIO: %c to row %d col %d\n",
		 * req->type, queue->row, queue->col); */
d1633 1
d1651 1
a1651 1
	s = splbio();		/* XXX */
a1655 3
#if 0
	db1_printf(("bp=0x%x\n", bp));
#endif
a1659 3
#if 0
		printf("Setting bp->b_flags!!! %d\n", raidbp->rf_buf.b_error);
#endif
a1663 6
#if 0
	db1_printf(("raidbp->rf_buf.b_bcount=%d\n", (int) raidbp->rf_buf.b_bcount));
	db1_printf(("raidbp->rf_buf.b_bufsize=%d\n", (int) raidbp->rf_buf.b_bufsize));
	db1_printf(("raidbp->rf_buf.b_resid=%d\n", (int) raidbp->rf_buf.b_resid));
	db1_printf(("raidbp->rf_buf.b_data=0x%x\n", raidbp->rf_buf.b_data));
#endif
d1686 1
a1686 1
#if 1
a1703 1
#endif
a1709 2
		db1_printf(("Disk is no longer busy for this buffer... %d %ld %ld\n",
			unit, bp->b_resid, bp->b_bcount));
a1711 2
	} else {
		db1_printf(("b_resid is still %ld\n", bp->b_resid));
a1715 1
	/* printf("Exiting KernelWakeupFunc\n"); */
d1717 1
a1717 1
	splx(s);		/* XXX */
a1744 1
	db1_printf(("bp->b_dev is %d\n", dev));
a1745 4
#if 0
	db1_printf(("bp->b_data=0x%x\n", bp->b_data));
#endif

a1747 1
	db1_printf(("b_bcount is: %d\n", (int) bp->b_bcount));
a1755 22
/* Extras... */

unsigned int 
rpcc()
{
	/* XXX no clue what this is supposed to do.. my guess is that it's
	 * supposed to read the CPU cycle counter... */
	/* db1_printf("this is supposed to do something useful too!??\n"); */
	return (0);
}
#if 0
int 
rf_GetSpareTableFromDaemon(req)
	RF_SparetWait_t *req;
{
	int     retcode = 1;
	printf("This is supposed to do something useful!!\n");	/* XXX */

	return (retcode);

}
#endif
d2275 87
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d255 2
a256 2
	size_t  sc_size;/* size of the raid device */
	dev_t   sc_dev;	/* our device.. */
d302 2
a303 2
	int     raidID;
 	int i, rc;
d354 1
a354 1

d357 1
a357 1
		    (RF_Raid_t *));
d523 9
a531 9
  	
 	if ((rs->sc_dkdev.dk_openmask == 0) &&
 	    ((rs->sc_flags & RAIDF_INITED) != 0)) {
 		/* Last one... device is not unconfigured yet.  
 		   Device shutdown has taken care of setting the 
 		   clean bits if RAIDF_INITED is not set 
 		   mark things as clean... */
 		rf_update_component_labels( raidPtrs[unit] );
 	}
d683 11
a693 11
	int     retcode = 0;
	int     row;
 	int column;
 	int s;
  	struct rf_recon_req *rrcopy, *rr;
 	RF_ComponentLabel_t *component_label;
 	RF_ComponentLabel_t ci_label;
 	RF_ComponentLabel_t **c_label_ptr;
 	RF_SingleComponent_t *sparePtr,*componentPtr;
 	RF_SingleComponent_t hot_spare;
 	RF_SingleComponent_t component;
a865 1

d881 1
a881 1

d888 2
a889 2
 
 		row = component_label->row;
d939 1
a939 1
 		/* XXX this isn't allowed to do anything for now :-) */
a978 1
  
d982 1
a982 1
  
a988 5
  		/* borrow the thread of the requesting process */
  		raidPtrs[unit]->proc = p;	/* Blah... :-p GO */
  		retcode = rf_RewriteParity(raidPtrs[unit]);
  		/* return I/O Error if the parity rewrite fails */

d1032 1
a1032 1
		return (retcode);
d1052 1
a1052 1
			    (RF_DeviceConfig_t *));
d1080 1
a1080 1
			    sizeof(RF_DeviceConfig_t));
d1318 1
a1318 1
	    0, 0, "raidpl", 0, NULL, NULL, M_RAIDFRAME);
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 1
a1 2
/*	$OpenBSD: rf_netbsdkintf.c,v 1.1 1999/01/11 14:29:30 niklas Exp $	*/
/*	$NetBSD: rf_netbsdkintf.c,v 1.10 1999/02/11 01:23:32 oster Exp $	*/
d180 1
a180 1
static int rf_pending_testaccs;
a181 2
RF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex)
RF_DECLARE_STATIC_MUTEX(rf_async_done_q_mutex)
a185 1
static struct rf_test_acc *rf_async_done_qh, *rf_async_done_qt;
d204 8
a211 5
#define Dprintf0(s)       if (rf_queueDebug) rf_debug_printf(s,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf1(s,a)     if (rf_queueDebug) rf_debug_printf(s,a,NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf2(s,a,b)   if (rf_queueDebug) rf_debug_printf(s,a,b,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf3(s,a,b,c) if (rf_queueDebug) rf_debug_printf(s,a,b,c,NULL,NULL,NULL,NULL,NULL)

d213 2
a214 4
/* this is so that we can compile under 2.0 as well as 3.2 */
#ifndef proc_to_task
#define proc_to_task(x) ((x)->task)
#endif				/* !proc_to_task */
d231 3
d242 1
a242 2
	RF_DiskQueueData_t *req;	/* the request that this was
					 * part of.. */
a252 1
	int     sc_unit;/* logical unit number */
d271 10
d296 1
d303 1
d323 15
a337 2
	rf_kbooted = rf_boot();
	if (rf_kbooted) {
d339 1
a339 1
	}
a421 2
	unsigned int raidID;
	int     rc;
a423 13
	/* This whole next chunk of code is somewhat suspect... Not sure it's
	 * needed here at all... XXX */

	if (rf_kbooted == RFK_BOOT_NONE) {
		printf("Doing restart on raidopen.\n");
		rf_kbooted = RFK_BOOT_GOOD;
		rc = rf_boot();
		if (rc) {
			rf_kbooted = RFK_BOOT_BAD;
			printf("Someone is unhappy...\n");
			return (rc);
		}
	}
a431 2
	raidID = raidunit(dev);

d436 1
a436 1
		raidID, part));
d466 15
d523 9
a625 1
	int     result;
a637 1
#if 0
a638 5
#endif
	result = physio(raidstrategy, NULL, dev, B_READ, minphys, uio);
	db1_printf(("raidread done.  Result is %d %d\n",
		result, uio->uio_resid));
	return (result);
a659 1

a683 1

d685 9
a693 8
	struct rf_recon_req *rrcopy, *rr;
#if 0
	int     nbytes, spl, rw, row;
	struct rf_test_acc *ta;
	struct buf *bp;
	RF_SparetWait_t *waitreq;
	struct rf_test_acc *ta_p, *ta_copy;
#endif
d729 6
a801 1
		rf_pending_testaccs = 0;
d803 1
a804 1
		raidPtrs[unit]->raidid = unit;
d807 2
d812 1
d822 1
d844 1
a844 8
		/* the intention here was to disallow shutdowns while
		 * raidframe is mounted, but it doesn't work because the
		 * shutdown ioctl calls rf_open */
		if (rf_pending_testaccs > 0) {
			printf("RAIDFRAME:  Can't shutdown because there are %d pending test accs\n",
			    rf_pending_testaccs);
			return (EINVAL);
		}
d849 1
d867 115
d984 11
a995 2
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0)
			return (EINVAL);
d1001 1
a1001 1
		if (retcode)
d1003 36
d1139 2
a1140 1
		printf("Failing the disk: row: %d col: %d\n", rr->row, rr->col);
d1161 1
d1163 1
d1334 1
d1338 1
d1343 1
d1346 1
a1349 31

/*********************************************************
 *
 * initialization code called at boot time (startup.c)
 *
 ********************************************************/
int 
rf_boot()
{
	int     i, rc;

	rc = rf_mutex_init(&rf_sparet_wait_mutex);
	if (rc) {
		RF_PANIC();
	}
	rc = rf_mutex_init(&rf_async_done_q_mutex);
	if (rc) {
		RF_PANIC();
	}
	rf_sparet_wait_queue = rf_sparet_resp_queue = NULL;
	recon_queue = NULL;
	rf_async_done_qh = rf_async_done_qt = NULL;
	for (i = 0; i < numraid; i++)
		raidPtrs[i] = NULL;
	rc = rf_BootRaidframe();
	if (rc == 0)
		printf("Kernelized RAIDframe activated\n");
	else
		rf_kbooted = RFK_BOOT_BAD;
	return (rc);
}
d1354 1
d1370 2
a1371 1
			tsleep(&recon_queue, PRIBIO | PCATCH, "raidframe recon", 0);
d1380 2
a1381 1
	         * will not return until reconstruction completes, fails, or is aborted.
d1392 2
a1393 2
 * so that in the extremely rare case that two recons happen at once, we know for
 * which device were requesting a spare table
d1409 1
a1409 1
		tsleep(&rf_sparet_resp_queue, PRIBIO | PCATCH,
d1412 3
a1414 1
		mpsleep(&rf_sparet_resp_queue, PZERO, "sparet resp", 0, (void *) simple_lock_addr(rf_sparet_wait_mutex), MS_LOCK_SIMPLE);
d1426 2
a1427 1
/* a wrapper around rf_DoAccess that extracts appropriate info from the bp & passes it down.
d1504 14
d1519 1
a1519 1
	 * XXX For now, all writes are sync
a1521 2
	if ((bp->b_flags & B_READ) == 0)
		do_async = 0;
a1535 6
	/*
	 * If we requested sync I/O, sleep here.
	 */
	if ((retcode == 0) && (do_async == 0))
		tsleep(bp, PRIBIO, "raidsyncio", 0);

d1570 1
a1570 1

d1582 1
d1726 1
d1898 2
a1899 2
			    "the size of raid (%d)\n", rs->sc_xname,
			    lp->d_secperunit, rs->sc_size);
d1904 2
a1905 2
				    "exceeds the size of raid (%d)\n",
				    rs->sc_xname, 'a' + i, rs->sc_size);
d2012 325
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_netbsdkintf.c,v 1.5 1998/12/22 20:03:14 oster Exp $	*/
/*	$NetBSD: rf_netbsdkintf.c,v 1.5 1998/12/22 20:03:14 oster Exp $	*/
a115 178
/*
 * :  
 * Log: rf_kintf.c,v 
 * Revision 1.57  1996/07/19 16:12:20  jimz
 * remove addition of protectedSectors in InitBP- it's already
 * done in the diskqueue code
 *
 * Revision 1.56  1996/07/17  21:00:58  jimz
 * clean up timer interface, tracing
 *
 * Revision 1.55  1996/06/17  03:00:54  jimz
 * Change RAIDFRAME_GET_INFO interface to do its own copyout()
 * (because size of device config structure now exceeds 8k)
 *
 * Revision 1.54  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.53  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.52  1996/06/06  17:28:08  jimz
 * track sector number of last I/O dequeued
 *
 * Revision 1.51  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.50  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.49  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.48  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.47  1996/05/30  12:59:18  jimz
 * make etimer happier, more portable
 *
 * Revision 1.46  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.45  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.44  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.43  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.42  1996/05/23  22:17:54  jimz
 * fix sector size hardcoding problems
 *
 * Revision 1.41  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.40  1996/05/23  13:18:07  jimz
 * tracing_mutex -> rf_tracing_mutex
 *
 * Revision 1.39  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.38  1996/05/20  16:15:32  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.37  1996/05/10  16:23:47  jimz
 * RF_offset -> RF_Offset
 *
 * Revision 1.36  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.35  1996/05/03  19:10:48  jimz
 * change sanity checking for bogus I/Os to return more appropriate
 * values (to make some user-level utilities happer with RAIDframe)
 *
 * Revision 1.34  1996/05/02  22:17:00  jimz
 * When using DKUSAGE, send a bogus IO after configuring to let DKUSAGE know
 * that we exist. This will let user-level programs doing group stats on the
 * RF device function without error before RF gets its first IO
 *
 * Changed rf_device_config devs and spares fields to RF_RaidDisk_t
 *
 * Inc numOutstanding for the disk queue in rf_DispatchKernelIO if
 * type is IO_TYPE_NOP. I'm not sure this is right, but it seems to be,
 * because the disk IO completion routine wants to dec it, and doesn't
 * care if there was no such IO.
 *
 * Revision 1.33  1996/05/02  15:05:44  jimz
 * for now, rf_DoAccessKernel will reject non-sector-sized I/Os
 * eventually, it should do something more clever...
 * (and do it in DoAccess(), not just DoAccessKernel())
 *
 * Revision 1.32  1996/05/01  16:28:39  jimz
 * get rid of uses of ccmn_ functions
 *
 * Revision 1.31  1996/05/01  15:42:17  jimz
 * ccmn_* memory management is on the way out. This is an archival checkpoint-
 * both the old and new code are in place (all the ccmn_ calls are #if 0). After
 * this, the ccmn_ code will no longer appear.
 *
 * Revision 1.30  1996/04/22  15:53:13  jimz
 * MAX_RAIDS -> NRAIDFRAME
 *
 * Revision 1.29  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.28  1995/12/01  19:11:01  root
 * added copyright info
 *
 * Revision 1.27  1995/11/28  18:56:40  wvcii
 * disabled buffer copy in rf_write
 *
 * Revision 1.26  1995/10/06  16:37:08  jimz
 * get struct bufs from ubc, not cam
 * copy all write data, and operate on copy
 * (temporary hack to get around dags in PQ that want
 * to Xor into user write buffers)
 *
 * Revision 1.25  1995/09/30  22:23:08  jimz
 * do not require raid to be active to perform ACCTOTAL ioctl
 *
 * Revision 1.24  1995/09/30  20:39:08  jimz
 * added new ioctls:
 *   RAIDFRAME_RESET_ACCTOTALS
 *   RAIDFRAME_GET_ACCTOTALS
 *   RAIDFRAME_KEEP_ACCTOTALS
 *
 * Revision 1.23  1995/09/20  21:11:59  jimz
 * include dfstrace.h in KERNEL block
 * (even though it's a kernel-only file, this makes the depend process
 * at user-level happy. Why the user-level Makefile wants to depend
 * kintf.c is less clear, but this is a workaround).
 *
 * Revision 1.22  1995/09/19  23:19:03  jimz
 * added DKUSAGE support
 *
 */




#ifdef _KERNEL
#define KERNEL
#endif



#ifdef KERNEL
a117 3

#ifdef __NetBSD__
#include "raid.h"
a128 2
#endif

a130 1

a131 1

a132 1

a133 3


#ifdef __NetBSD__
a134 3
#endif /* __NetBSD__ */


d137 2
d155 1
a155 1
int rf_kdebug_level = 0;
d170 1
a170 1
#else /* DEBUG */
d177 1
a177 1
#endif /* DEBUG */
d179 1
a179 1
static RF_Raid_t **raidPtrs; /* global raid device descriptors */
d185 9
a193 8
static RF_SparetWait_t *rf_sparet_wait_queue;      /* requests to install a spare table */
static RF_SparetWait_t *rf_sparet_resp_queue;      /* responses from installation process */
static struct rf_test_acc    *rf_async_done_qh, *rf_async_done_qt;

static struct rf_recon_req *recon_queue = NULL;          /* used to communicate reconstruction requests */


decl_simple_lock_data(,recon_queue_mutex)
d196 1
d201 6
a206 5
static void KernelWakeupFunc(struct buf  *bp);
static void InitBP(struct buf *bp, struct vnode *, unsigned rw_flag, dev_t dev,
	RF_SectorNum_t startSect, RF_SectorCount_t numSect, caddr_t buf,
	void (*cbFunc)(struct buf *), void *cbArg, int logBytesPerSector,
	struct proc *b_proc);
d217 1
a217 1
#endif /* !proc_to_task */
d219 2
a220 2
void	raidattach __P((int));
int	raidsize __P((dev_t));
d222 11
a232 11
void	rf_DiskIOComplete(RF_DiskQueue_t *, RF_DiskQueueData_t *, int);
void	rf_CopybackReconstructedData(RF_Raid_t *raidPtr);
static	int raidinit __P((dev_t,RF_Raid_t *,int));

int	raidopen __P((dev_t, int, int, struct proc *));
int	raidclose __P((dev_t, int, int, struct proc *));
int	raidioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	raidwrite __P((dev_t, struct uio *, int));
int	raidread __P((dev_t, struct uio *, int));
void	raidstrategy __P((struct buf *));
int	raiddump __P((dev_t, daddr_t, caddr_t, size_t));
d239 5
a243 4
        struct buf	rf_buf;		/* new I/O buf.  MUST BE FIRST!!! */
	struct buf	*rf_obp;	/* ptr. to original I/O buf */
	int		rf_flags;	/* misc. flags */
	RF_DiskQueueData_t  *req;       /* the request that this was part of.. */
d250 2
a251 2
/* XXX Not sure if the following should be replacing the raidPtrs above, 
or if it should be used in conjunction with that... */
d254 8
a261 8
	int		 sc_unit;		/* logical unit number */
	int		 sc_flags;		/* flags */
	int		 sc_cflags;		/* configuration flags */
	size_t		 sc_size;		/* size of the raid device */
	dev_t            sc_dev;                /* our device..*/
	char		 sc_xname[20];		/* XXX external name */
	struct disk	 sc_dkdev;		/* generic disk device info */
	struct pool      sc_cbufpool;           /* component buffer pool */
a262 1

d271 1
a271 1
static int numraid=0;
d279 8
a286 7
static	void raidgetdefaultlabel __P((RF_Raid_t *, struct raid_softc *, struct disklabel *));
static	void raidgetdisklabel __P((dev_t));
static	void raidmakedisklabel __P((struct raid_softc *));

static	int raidlock __P((struct raid_softc *));
static	void raidunlock __P((struct raid_softc *));
int raidlookup __P((char *, struct proc *p, struct vnode **));
d291 1
a291 1
	int num;
d293 1
a293 1
	int raidID;
d296 1
a296 1
	printf("raidattach: Asked for %d units\n",num);
d305 1
a305 3
	/* 
	   This is where all the initialization stuff gets done.
	 */
a312 3



d317 4
a320 2
	
	rf_kbooted = RFK_BOOT_GOOD; 
a321 5
	/* 
	   put together some datastructures like the CCD device does.. 
	   This lets us lock the device and what-not when it gets opened.
        */
	
d323 2
a324 2
		malloc(num * sizeof(struct raid_softc),
		       M_DEVBUF, M_NOWAIT);
d332 5
a336 5
	for(raidID=0;raidID < num;raidID++) {
		RF_Calloc(raidPtrs[raidID], 1, sizeof(RF_Raid_t), 
			  (RF_Raid_t *));
		if (raidPtrs[raidID]==NULL) {
			printf("raidPtrs[%d] is NULL\n",raidID);
d344 1
a344 1
	dev_t dev;
d348 1
a348 1
	int part, unit, omask, size;
d380 1
a380 1
	dev_t dev;
d383 1
a383 1
	size_t size;
a387 1

d391 2
a392 2
	dev_t dev;
	int flags, fmt;
d395 1
a395 1
	int unit = raidunit(dev);
d398 1
a398 1
	int part,pmask;
d400 5
a404 5
	int rc;
	int error = 0;
	
	/* This whole next chunk of code is somewhat suspect... Not sure
	   it's needed here at all... XXX */
d406 1
a406 1
	if (rf_kbooted == RFK_BOOT_NONE) { 
d413 1
a413 1
			return(rc);
a415 1

d421 1
a421 1
		return(error);
d430 1
a430 1
		    raidID,part));
d435 1
a435 1
		raidgetdisklabel(dev); 
d443 1
a443 1
		     (lp->d_partitions[part].p_fstype == FS_UNUSED))) {
d447 1
a447 1
			return(error);
a449 1

d465 1
a465 1
	return(error);
a468 1

d472 2
a473 2
	dev_t dev;
	int flags, fmt;
d476 1
a476 1
	int unit = raidunit(dev);
d478 2
a479 2
	int error = 0;
	int part;
d518 1
a518 1
	int wlabel;
d521 5
a525 5
	db1_printf(("Strategy: 0x%x 0x%x\n",bp,bp->b_data));
	db1_printf(("Strategy(2): bp->b_bufsize%d\n", (int)bp->b_bufsize));
	db1_printf(("bp->b_count=%d\n",(int)bp->b_bcount));
	db1_printf(("bp->b_resid=%d\n",(int)bp->b_resid));
	db1_printf(("bp->b_blkno=%d\n",(int)bp->b_blkno));
d527 1
a527 1
	if (bp->b_flags&B_READ) 
d561 1
a561 1
	wlabel = rs->sc_flags & (RAIDF_WLABEL|RAIDF_LABELLING);
d565 1
a565 1
			       (int)bp->b_blkno,(int)wlabel));
d569 2
a571 3
	s = splbio(); /* XXX Needed? */
	db1_printf(("Beginning strategy...\n"));
	
d573 2
a574 2
	bp->b_error = rf_DoAccessKernel(raidPtrs[raidID], bp, 
					NULL, NULL, NULL);
d578 1
a578 1
			    bp->b_error));
d583 2
a584 2
		    bp,bp->b_data, 
		    (int)bp->b_bcount,(int)bp->b_resid));
a586 1

d590 1
a590 1
	dev_t dev;
d592 1
a592 1
	int flags;
d594 1
a594 1
	int unit = raidunit(dev);
d596 2
a597 2
	int result;
	int part;
d607 1
a607 1
	db1_printf(("raidread: unit: %d partition: %d\n",unit,part));
d612 1
a612 1
	result=physio(raidstrategy, NULL, dev, B_READ, minphys, uio);
d614 2
a615 2
		    result,uio->uio_resid));
	return(result);
a617 1

d621 1
a621 1
	dev_t dev;
d623 1
a623 1
	int flags;
d625 1
a625 1
	int unit = raidunit(dev);
d642 2
a643 2
	dev_t dev;
	u_long cmd;
d645 1
a645 1
	int flag;
d648 3
a650 3
	int unit = raidunit(dev);
	int error = 0;
	int part, pmask; 
d653 1
a653 1
	int r,c;
d655 1
a655 1
	/* 	struct raid_ioctl *ccio = (struct ccd_ioctl *)data; */
d657 2
a658 2
	/* 	struct ccdbuf *cbp; */
	/* 	struct raidbuf *raidbp; */
d661 1
a661 1
	int retcode = 0;
d663 1
a663 1
	int row;
d666 1
a666 1
	int nbytes, spl, rw, row;
d677 2
a678 2
	db1_printf(("raidioctl: %d %d %d %d\n",(int)dev,
		    (int)DISKPART(dev),(int)unit,(int)cmd));
d710 1
a710 1
	
d720 2
a721 2
		u_cfg = *((RF_Config_t **) data);   
		RF_Malloc(k_cfg,sizeof(RF_Config_t),(RF_Config_t *));
d724 1
a724 1
			return(ENOMEM);
d726 2
a727 2
		retcode = copyin((caddr_t) u_cfg, (caddr_t) k_cfg, 
				 sizeof(RF_Config_t));
d729 3
a731 3
			db3_printf(("rf_ioctl: retcode=%d copyin.1\n", 
				    retcode));
			return(retcode);
d733 2
a734 3

		/* allocate a buffer for the layout-specific data, 
		   and copy it in */
d736 1
a736 1
			if (k_cfg->layoutSpecificSize > 10000) { 
d739 1
a739 1
				return(EINVAL);
d741 2
a742 2
			RF_Malloc(specific_buf,k_cfg->layoutSpecificSize,
				  (u_char *));
d744 1
a744 1
				RF_Free(k_cfg,sizeof(RF_Config_t));
d746 1
a746 1
				return(ENOMEM);
d748 3
a750 3
			retcode = copyin(k_cfg->layoutSpecific, 
					 (caddr_t) specific_buf, 
					 k_cfg->layoutSpecificSize);
d753 2
a754 2
					    retcode));
				return(retcode);
d756 2
a757 1
		} else specific_buf = NULL;
d759 3
a761 4
		
		/* should do some kind of sanity check on the configuration. 
		   Store the sum of all the bytes in the last byte?
		   */
d765 1
a765 1
			    unit,p));
d768 2
a769 2
		/* We need the pointer to this a little deeper, so
		   stash it here... */
d780 1
a780 1
		
d782 2
a783 3
			retcode = raidinit(dev, raidPtrs[unit],unit);
		} 

d786 1
a786 1
			RF_Free(specific_buf,k_cfg->layoutSpecificSize);
d788 7
a794 7
		RF_Free(k_cfg,sizeof(RF_Config_t));
		
		db3_printf(("rf_ioctl: retcode=%d RAIDFRAME_CONFIGURE\n", 
			    retcode));
		return(retcode);
		
		/* shutdown the system */    
d796 3
a798 3
		
		if ((error = raidlock(rs)) != 0) 
			return(error);
d807 6
a812 7
                if ((rs->sc_dkdev.dk_openmask & ~pmask) ||
                    ((rs->sc_dkdev.dk_bopenmask & pmask) &&
		     (rs->sc_dkdev.dk_copenmask & pmask))) {
                        raidunlock(rs);
                        return (EBUSY);
                }
		
d814 2
a815 3
		   raidframe is mounted, but it doesn't work because the 
		   shutdown ioctl calls rf_open
		   */
d818 2
a819 2
			       rf_pending_testaccs);
			return(EINVAL);
d824 1
a824 1
		raidPtrs[unit]->proc = p; /* XXX  necessary evil */
d835 2
a836 2
                /* Detach the disk. */
                disk_detach(&rs->sc_dkdev);
d840 2
a841 2
		return(retcode);
		
d845 2
a846 2
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) 
			return(EINVAL);
d848 1
a848 1
		raidPtrs[unit]->proc = p; /* Blah... :-p GO */
d850 1
a850 1
		/* return I/O Error if the parity rewrite fails */ 
d852 7
a858 7
		if (retcode) 
			retcode = EIO;           
		return(retcode);

		/* issue a test-unit-ready through raidframe to the 
		   indicated device */
#if 0 /* XXX not supported yet (ever?) */
d861 2
a862 2
		retcode = rf_SCSI_DoTUR(0, 0, 0, 0, *(dev_t *) data);  
		return(retcode);
d868 2
a869 2
			int i, j, d;
			
d871 4
a874 4
				return(ENODEV);
			ucfgp = (RF_DeviceConfig_t **)data;
			RF_Malloc(cfg,sizeof(RF_DeviceConfig_t),
				  (RF_DeviceConfig_t *));
d876 2
a877 2
				return(ENOMEM);
			bzero((char *)cfg, sizeof(RF_DeviceConfig_t));
d883 1
a883 1
				return(ENOMEM);
d888 1
a888 1
				return(ENOMEM);
d892 2
a893 2
			for(i=0;i<cfg->rows;i++) {
				for(j=0;j<cfg->cols;j++) {
d898 1
a898 1
			for(j=cfg->cols,i=0;i<cfg->nspares;i++,j++) {
d901 5
a905 5
			retcode = copyout((caddr_t)cfg, (caddr_t)*ucfgp, 
					  sizeof(RF_DeviceConfig_t));
			RF_Free(cfg,sizeof(RF_DeviceConfig_t));
			
			return(retcode);
d907 2
a908 2
	break;
	
d912 1
a912 1
			
d914 1
a914 1
			return(0);
d916 2
a917 2
	break;
	
d920 1
a920 1
			RF_AccTotals_t *totals = (RF_AccTotals_t *)data;
d922 1
a922 1
			
d924 1
a924 1
			return(0);
d926 2
a927 2
	break;
	
d931 2
a932 2
			int *keep = (int *)data;
			
d934 1
a934 1
			return(0);
d936 2
a937 2
	break;
	
d940 1
a940 1
		return(0);
d949 2
a950 2
		
		if (rr->row < 0 || rr->row >= raidPtrs[unit]->numRow 
d952 1
a952 1
			return(EINVAL);
d954 4
a957 4
		printf("Failing the disk: row: %d col: %d\n",rr->row,rr->col);
		
		/* make a copy of the recon request so that we don't 
		   rely on the user's buffer */
d967 6
a972 6
		
		return(0);
		
		/* invoke a copyback operation after recon on whatever 
		   disk needs it, if any */
	case RAIDFRAME_COPYBACK:		
d974 1
a974 1
		raidPtrs[unit]->proc = p; /* ICK.. but needed :-p  GO */
d976 2
a977 2
		return(0);
		
d982 2
a983 2
			return(EINVAL);
		if (raidPtrs[unit]->status[row] != rf_rs_reconstructing) 
d985 1
a985 1
		else 
d987 9
a995 12
		return(0);
		
		/* the sparetable daemon calls this to wait for the 
		   kernel to need a spare table.
		   * this ioctl does not return until a spare table is needed.
		   * XXX -- calling mpsleep here in the ioctl code is almost 
		   certainly wrong and evil. -- XXX
		   * XXX -- I should either compute the spare table in the 
		   kernel, or have a different -- XXX
		   * XXX -- interface (a different character device) for
		   delivering the table          -- XXX
		  */
d999 2
a1000 1
		while (!rf_sparet_wait_queue) mpsleep(&rf_sparet_wait_queue, (PZERO+1)|PCATCH, "sparet wait", 0, (void *) simple_lock_addr(rf_sparet_wait_mutex), MS_LOCK_SIMPLE);
d1004 3
a1006 3
		
		*((RF_SparetWait_t *) data) = *waitreq;              /* structure assignment */
		
d1008 5
a1012 5
		return(0);
		
		
		/* wakes up a process waiting on SPARET_WAIT and puts an 
		   error code in it that will cause the dameon to exit */
d1021 1
a1021 1
		return(0);
d1023 2
a1024 2
		/* used by the spare table daemon to deliver a spare table 
		   into the kernel */
d1026 1
a1026 1
		
d1028 4
a1031 4
		retcode = rf_SetSpareTable(raidPtrs[unit],*(void **) data);
		
		/* respond to the requestor.  the return status of the 
		   spare table installation is passed in the "fcol" field */
d1039 2
a1040 2
		
		return(retcode);
d1044 4
a1047 1
#endif   /* RAIDFRAME_RECON > 0 */
a1048 2
	default:  break;               /* fall through to the os-specific code below */
		
d1050 1
a1050 1
	
d1052 2
a1053 2
		return(EINVAL);
	
d1057 1
a1057 1
	
d1060 2
a1061 2
		db1_printf(("DIOCGDINFO %d %d\n",(int)dev,(int)DISKPART(dev)));
		*(struct disklabel *)data = *(rs->sc_dkdev.dk_label);
d1065 3
a1067 3
		db1_printf(("DIOCGPART: %d %d\n",(int)dev,(int)DISKPART(dev)));
		((struct partinfo *)data)->disklab = rs->sc_dkdev.dk_label;
		((struct partinfo *)data)->part =
d1081 1
a1081 1
		    (struct disklabel *)data, 0, rs->sc_dkdev.dk_cpulabel);
a1087 1

d1098 1
a1098 1
		if (*(int *)data != 0)
d1107 1
a1107 1
					 (struct disklabel *)data);
d1111 1
a1111 1
		retcode = ENOTTY; /* XXXX ?? OR EINVAL ? */
d1113 1
a1113 1
	return(retcode);
d1118 1
a1118 1
/* raidinit -- complete the rest of the initialization for the 
d1123 2
a1124 2
raidinit(dev, raidPtr,unit)
	dev_t dev;
d1126 1
a1126 1
	int unit;
d1128 3
a1130 3
	int retcode;
	/* 	int ix; */
	/* 	struct raidbuf *raidbp; */
d1137 2
a1138 1
		  0, 0, "raidpl", 0, NULL, NULL, M_DEVBUF);
a1139 1
	
d1143 1
a1143 1
	sprintf(rs->sc_xname, "raid%d", unit); /* XXX doesn't check bounds.*/
d1145 1
a1145 1
	rs->sc_dkdev.dk_name = rs->sc_xname;	
d1147 2
a1148 2
	   other things, so it's critical to call this *BEFORE* we
	   try putzing with disklabels. */
d1152 2
a1153 2
	   protectedSectors, as used in RAIDframe.  */
	rs->sc_size = raidPtr->totalSectors; 
d1155 1
a1155 1
	return(retcode);
d1164 2
a1165 1
int rf_boot()
d1167 1
a1167 1
  int i, rc;
d1169 19
a1187 19
  rc = rf_mutex_init(&rf_sparet_wait_mutex);
  if (rc) {
    RF_PANIC();
  }
  rc = rf_mutex_init(&rf_async_done_q_mutex);
  if (rc) {
    RF_PANIC();
  }
  rf_sparet_wait_queue = rf_sparet_resp_queue = NULL;
  recon_queue = NULL;
  rf_async_done_qh = rf_async_done_qt = NULL;
  for (i=0; i<numraid; i++)
    raidPtrs[i] = NULL;
  rc = rf_BootRaidframe();
  if (rc == 0)
    printf("Kernelized RAIDframe activated\n");
  else
    rf_kbooted = RFK_BOOT_BAD;
  return(rc);
a1188 1

d1193 2
a1194 1
void rf_ReconKernelThread()
d1196 6
a1201 2
  struct rf_recon_req *req;
  int s;
d1203 11
a1213 2
  /* XXX not sure what spl() level we should be at here... probably splbio() */
  s=splbio();
d1215 6
a1220 18
  while (1) {
    /* grab the next reconstruction request from the queue */
    LOCK_RECON_Q_MUTEX();
    while (!recon_queue) {
	    UNLOCK_RECON_Q_MUTEX();
	    tsleep(&recon_queue, PRIBIO | PCATCH, "raidframe recon", 0);
	    LOCK_RECON_Q_MUTEX();
    }
    req = recon_queue;
    recon_queue = recon_queue->next;
    UNLOCK_RECON_Q_MUTEX();

    /*
     * If flags specifies that we should start recon, this call
     * will not return until reconstruction completes, fails, or is aborted.
     */
    rf_FailDisk((RF_Raid_t *) req->raidPtr, req->row, req->col,
        ((req->flags&RF_FDFLAGS_RECON) ? 1 : 0));
d1222 2
a1223 2
    RF_Free(req, sizeof(*req));
  }
d1227 1
a1227 1
 * the entries in the queues should be tagged with the raidPtr 
d1232 15
a1246 14
int rf_GetSpareTableFromDaemon(req)
  RF_SparetWait_t  *req;
{
  int retcode;

  RF_LOCK_MUTEX(rf_sparet_wait_mutex);
  req->next = rf_sparet_wait_queue;
  rf_sparet_wait_queue = req;
  wakeup(&rf_sparet_wait_queue);

  /* mpsleep unlocks the mutex */
  while (!rf_sparet_resp_queue) {
	  tsleep(&rf_sparet_resp_queue, PRIBIO | PCATCH, 
		 "raidframe getsparetable", 0);
d1248 1
a1248 1
	  mpsleep(&rf_sparet_resp_queue, PZERO, "sparet resp", 0, (void *) simple_lock_addr(rf_sparet_wait_mutex), MS_LOCK_SIMPLE);
d1250 9
a1258 8
  }
  req = rf_sparet_resp_queue;
  rf_sparet_resp_queue = req->next;
  RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);

  retcode = req->fcol;
  RF_Free(req, sizeof(*req));   /* this is not the same req as we alloc'd */
  return(retcode);
a1259 1

d1265 7
a1271 6
int rf_DoAccessKernel(raidPtr, bp, flags, cbFunc, cbArg)
  RF_Raid_t              *raidPtr;
  struct buf             *bp;
  RF_RaidAccessFlags_t    flags;
  void                  (*cbFunc)(struct buf *);
  void                   *cbArg;
d1275 1
a1275 1
	int retcode;
d1277 2
a1278 2
	daddr_t blocknum;	
	int unit;
d1280 1
d1288 1
a1288 2
	   partition.. Need to make it absolute to the underlying
	   device.. */
d1294 2
a1295 2
		db1_printf(("updated: %d %d\n",DISKPART(bp->b_dev),
			    pp->p_offset));
d1301 2
a1302 2
	db1_printf(("bp->b_bcount = %d\n",(int)bp->b_bcount));
	db1_printf(("bp->b_resid = %d\n",(int)bp->b_resid));
d1304 2
a1305 2
	/* *THIS* is where we adjust what block we're going to... but 
	   DO NOT TOUCH bp->b_blkno!!! */
d1307 1
a1307 1
	
d1309 1
a1309 1
	pb = (bp->b_bcount&raidPtr->sectorMask) ? 1 : 0;
d1312 3
a1314 3
		db1_printf(("raid_addr=%d sum=%d num_blocks=%d(+%d) (%d)\n", 
			    (int)raid_addr, (int)sum,(int)num_blocks,
			    (int)pb,(int)bp->b_resid));
a1315 2
	

d1317 1
a1317 2
			|| (sum < num_blocks) || (sum < pb))
	{
d1322 1
a1322 1
		return(bp->b_error);
a1323 1

d1333 1
a1333 1
		return(bp->b_error);
d1337 15
a1351 7
	/* don't ever condition on bp->b_flags & B_WRITE.  
	   always condition on B_READ instead */
	retcode = rf_DoAccess(raidPtr, (bp->b_flags & B_READ) ? 
			      RF_IO_TYPE_READ : RF_IO_TYPE_WRITE,
			      0, raid_addr, num_blocks, bp->b_un.b_addr, 
			      bp, NULL, NULL, RF_DAG_NONBLOCKING_IO|flags, 
			      NULL, cbFunc, cbArg);
d1353 2
a1354 2
	db1_printf(("After call to DoAccess: 0x%x 0x%x %d\n",bp,
	       bp->b_data,(int)bp->b_resid));
d1356 8
a1363 1
	return(retcode);
a1364 1

d1367 4
a1370 3
int rf_DispatchKernelIO(queue, req)
	RF_DiskQueue_t      *queue;
	RF_DiskQueueData_t  *req;
d1372 1
a1372 1
	int op = (req->type == RF_IO_TYPE_READ) ? B_READ : B_WRITE;
d1374 1
a1374 1
	struct raidbuf *raidbp=NULL;
d1376 2
a1377 2
	int unit;
	
d1379 2
a1380 2
	   this device.. */
	
d1382 1
a1382 1
	
d1385 1
a1385 1
 	db1_printf(("DispatchKernelIO unit: %d\n",unit)); 
d1387 2
a1388 2
     	if (unit >= numraid) {
		printf("Invalid unit number: %d %d\n",unit,numraid);
a1390 1

d1394 1
a1394 1
	disk_busy(&rs->sc_dkdev); 
d1398 4
a1401 7
	/* 
	   XXX when there is a physical disk failure, someone is passing 
	   us a buffer that contains old stuff!!  Attempt to deal with
	   this problem without taking a performance hit...
	   (not sure where the real bug is.  It's buried in RAIDframe
	   somewhere) :-(  GO )
	 */
d1406 1
a1406 1
	if (bp->b_error!=0) {
a1408 1

d1411 1
a1411 1
	raidbp->rf_flags = 0; /* XXX not really used anywhere... */
d1420 3
a1422 5
	case RF_IO_TYPE_NOP:   /* used primarily to unlock a locked queue */
		/* 
		Dprintf2("rf_DispatchKernelIO: NOP to r %d c %d\n",
			 queue->row, queue->col);
			 */
d1424 2
a1425 2
		/* I'm leaving this in, as I've never actually seen it 
		   used, and I'd like folks to report it... GO */
d1433 1
a1433 1
		
d1436 1
a1436 1
		
d1440 5
a1444 7


		InitBP(&raidbp->rf_buf, queue->rf_cinfo->ci_vp, 
		       op | bp->b_flags, queue->rf_cinfo->ci_dev, 
		       req->sectorOffset, req->numSector, 
		       req->buf, KernelWakeupFunc, (void *) req,  
		       queue->raidPtr->logBytesPerSector, req->b_proc);
d1447 2
a1448 2
			db1_printf(("dispatch: bp->b_blkno = %ld\n", 
				    (long) bp->b_blkno));
d1452 2
a1453 2
		/* acc wouldn't have been let in if there were any 
		   pending reqs at any other priority */
d1455 2
a1456 4
		/* 
		Dprintf3("rf_DispatchKernelIO: %c to row %d col %d\n", 
			 req->type, queue->row, queue->col);
			 */
d1459 1
a1459 1
		       req->type, unit, queue->row, queue->col));
d1461 4
a1464 4
		       (int) req->sectorOffset, (int) req->numSector,
		       (int) (req->numSector << 
			      queue->raidPtr->logBytesPerSector),
		       (int) queue->raidPtr->logBytesPerSector));
d1468 1
a1469 2
		VOP_STRATEGY(&raidbp->rf_buf);
		
d1471 1
a1471 1
		
d1476 1
a1476 1
	return(0);
d1478 1
a1478 2

/* this is the callback function associated with a I/O invoked from 
d1481 15
a1495 14
static void KernelWakeupFunc(vbp)
  struct buf  *vbp;
{
  RF_DiskQueueData_t *req = NULL;
  RF_DiskQueue_t *queue; 
  struct raidbuf *raidbp = (struct raidbuf *)vbp;
  struct buf *bp;
  struct raid_softc *rs;
  int unit;
  register int s;

  s=splbio(); /* XXX */
  db1_printf(("recovering the request queue:\n"));
  req = raidbp->req;
d1497 1
a1497 1
  bp = raidbp->rf_obp;
d1499 1
a1499 1
  db1_printf(("bp=0x%x\n",bp));
d1502 1
a1502 1
  queue = (RF_DiskQueue_t *) req->queue;
d1504 1
a1504 1
  if (raidbp->rf_buf.b_flags & B_ERROR) {
d1506 1
a1506 1
	  printf("Setting bp->b_flags!!! %d\n",raidbp->rf_buf.b_error);
d1508 4
a1511 5
	  bp->b_flags |= B_ERROR;
	  bp->b_error = raidbp->rf_buf.b_error ? 
		  raidbp->rf_buf.b_error : EIO;
  }

d1513 4
a1516 4
  db1_printf(("raidbp->rf_buf.b_bcount=%d\n",(int)raidbp->rf_buf.b_bcount));
  db1_printf(("raidbp->rf_buf.b_bufsize=%d\n",(int)raidbp->rf_buf.b_bufsize));
  db1_printf(("raidbp->rf_buf.b_resid=%d\n",(int)raidbp->rf_buf.b_resid));
  db1_printf(("raidbp->rf_buf.b_data=0x%x\n",raidbp->rf_buf.b_data));
d1519 1
a1519 1
  /* XXX methinks this could be wrong... */
d1521 1
a1521 1
  bp->b_resid = raidbp->rf_buf.b_resid;
d1524 10
a1533 9
  if (req->tracerec) {
	RF_ETIMER_STOP(req->tracerec->timer);
	RF_ETIMER_EVAL(req->tracerec->timer);
    RF_LOCK_MUTEX(rf_tracing_mutex);
    req->tracerec->diskwait_us += RF_ETIMER_VAL_US(req->tracerec->timer);
    req->tracerec->phys_io_us += RF_ETIMER_VAL_US(req->tracerec->timer);
    req->tracerec->num_phys_ios++;
    RF_UNLOCK_MUTEX(rf_tracing_mutex);
  }
d1535 1
a1535 1
  bp->b_bcount = raidbp->rf_buf.b_bcount;/* XXXX ?? */
a1536 1
  unit = queue->raidPtr->raidid; /* *Much* simpler :-> */
d1538 17
d1556 1
a1556 19
  /* XXX Ok, let's get aggressive... If B_ERROR is set, let's go ballistic, 
     and mark the component as hosed... */
#if 1
  if (bp->b_flags&B_ERROR) {
	  /* Mark the disk as dead */
	  /* but only mark it once... */
	  if (queue->raidPtr->Disks[queue->row][queue->col].status == 
	      rf_ds_optimal) {
		  printf("raid%d: IO Error.  Marking %s as failed.\n", 
			 unit, queue->raidPtr->Disks[queue->row][queue->col].devname );
		  queue->raidPtr->Disks[queue->row][queue->col].status = 
			  rf_ds_failed;
		  queue->raidPtr->status[queue->row] = rf_rs_degraded;
		  queue->raidPtr->numFailures++;
	  } else {  /* Disk is already dead... */
		  /*  printf("Disk already marked as dead!\n"); */
	  }
	  
  }
d1559 3
a1561 2
  rs = &raid_softc[unit];
  RAIDPUTBUF(rs,raidbp);
d1563 8
d1572 3
a1574 12
  if (bp->b_resid==0) {
	  db1_printf(("Disk is no longer busy for this buffer... %d %ld %ld\n",
		 unit, bp->b_resid, bp->b_bcount));
	  /* XXX is this the right place for a disk_unbusy()??!??!?!? */
	  disk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid)); 
  } else {
	  db1_printf(("b_resid is still %ld\n",bp->b_resid));
  }

  rf_DiskIOComplete(queue, req, (bp->b_flags & B_ERROR) ? 1 : 0);
  (req->CompleteFunc)(req->argument, (bp->b_flags & B_ERROR) ? 1 : 0);
  /*   printf("Exiting KernelWakeupFunc\n"); */
d1576 1
a1576 1
  splx(s); /* XXX */
d1584 20
a1603 19
static void InitBP(
  struct buf         *bp,
  struct vnode       *b_vp,
  unsigned            rw_flag,
  dev_t               dev,
  RF_SectorNum_t      startSect,
  RF_SectorCount_t    numSect,
  caddr_t             buf,
  void              (*cbFunc)(struct buf *),
  void               *cbArg,
  int                 logBytesPerSector,
  struct proc        *b_proc)
{
	/*   bp->b_flags       = B_PHYS | rw_flag; */
	bp->b_flags       = B_CALL | rw_flag; /* XXX need B_PHYS here too??? */
	bp->b_bcount      = numSect << logBytesPerSector; 
	bp->b_bufsize     = bp->b_bcount;
	bp->b_error       = 0;
	bp->b_dev         = dev;
d1605 1
a1605 1
	bp->b_un.b_addr   = buf;  
d1607 1
a1607 1
	db1_printf(("bp->b_data=0x%x\n",bp->b_data));
d1610 3
a1612 3
	bp->b_blkno       = startSect;
	bp->b_resid       = bp->b_bcount; /* XXX is this right!??!?!! */
	db1_printf(("b_bcount is: %d\n",(int)bp->b_bcount));
d1616 4
a1619 4
	bp->b_proc        = b_proc;
	bp->b_iodone      = cbFunc;
	bp->b_vp          = b_vp; 
	
a1620 2
#endif /* KERNEL */

d1623 2
a1624 1
unsigned int rpcc()
d1626 4
a1629 4
	/* XXX no clue what this is supposed to do.. my guess is 
	   that it's supposed to read the CPU cycle counter... */
	/* 	db1_printf("this is supposed to do something useful too!??\n"); */
	return(0);
a1630 1

d1632 3
a1634 2
int rf_GetSpareTableFromDaemon(req)
  RF_SparetWait_t  *req;
d1636 4
a1639 4
  int retcode=1;
  printf("This is supposed to do something useful!!\n"); /* XXX */
  
  return(retcode);
d1662 1
a1662 1
	lp->d_type = DTYPE_RAID; 
a1677 1

d1684 1
a1684 1
	dev_t dev;
d1686 1
a1686 1
	int unit = raidunit(dev);
d1688 1
a1688 1
	char *errstring;
d1706 1
a1706 1
	if (errstring) 
d1709 1
a1709 1
		int i;
a1734 1

a1756 1

d1761 1
a1761 1
 * You'll find the original of this in ccd.c 
d1765 1
a1765 1
	char *path;
d1772 1
a1772 1
	int error;
d1775 1
a1775 1
	if ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {
d1777 1
a1777 1
			printf("RAIDframe: vn_open returned %d\n",error);
d1784 1
a1784 1
		(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
d1789 1
a1789 1
		(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
d1795 1
a1795 1
		(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
a1801 1

d1813 1
a1813 1
	int error;
d1817 2
a1818 2
		if ((error = 
		     tsleep(rs, PRIBIO | PCATCH, "raidlck", 0)) != 0)
a1823 1

@

