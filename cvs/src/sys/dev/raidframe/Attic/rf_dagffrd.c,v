head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.38
	OPENBSD_5_0:1.4.0.36
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.16
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.14
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.12
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.4;

1.4
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.11.18.02.21;	author peter;	state Exp;
branches
	1.3.2.1
	1.3.12.1;
next	1.2;

1.2
date	99.02.16.00.02.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.08;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.3.12.1
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_dagffrd.c,v 1.4 2002/12/16 07:01:03 tdeval Exp $	*/
/*	$NetBSD: rf_dagffrd.c,v 1.4 2000/01/07 03:40:58 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland, Daniel Stodolsky, William V. Courtright II
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * rf_dagffrd.c
 *
 * Code for creating fault-free read DAGs.
 *
 */

#include "rf_types.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagutils.h"
#include "rf_dagfuncs.h"
#include "rf_debugMem.h"
#include "rf_memchunk.h"
#include "rf_general.h"
#include "rf_dagffrd.h"

void rf_CreateMirrorReadDAG( RF_Raid_t *, RF_AccessStripeMap_t *,
	RF_DagHeader_t *, void *, RF_RaidAccessFlags_t, RF_AllocListElem_t *,
	int (*) (RF_DagNode_t *));

/*****************************************************************************
 *
 * General comments on DAG creation:
 *
 * All DAGs in this file use roll-away error recovery.  Each DAG has a single
 * commit node, usually called "Cmt."  If an error occurs before the Cmt node
 * is reached, the execution engine will halt forward execution and work
 * backward through the graph, executing the undo functions.  Assuming that
 * each node in the graph prior to the Cmt node are undoable and atomic - or -
 * does not make changes to permanent state, the graph will fail atomically.
 * If an error occurs after the Cmt node executes, the engine will roll-forward
 * through the graph, blindly executing nodes until it reaches the end.
 * If a graph reaches the end, it is assumed to have completed successfully.
 *
 * A graph has only 1 Cmt node.
 *
 *****************************************************************************/


/*****************************************************************************
 *
 * The following wrappers map the standard DAG creation interface to the
 * DAG creation routines.  Additionally, these wrappers enable experimentation
 * with new DAG structures by providing an extra level of indirection, allowing
 * the DAG creation routines to be replaced at this single point.
 *
 *****************************************************************************/

void
rf_CreateFaultFreeReadDAG(
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList
)
{
	rf_CreateNonredundantDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
	    RF_IO_TYPE_READ);
}


/*****************************************************************************
 *
 * DAG creation code begins here.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 * Creates a DAG to perform a nonredundant read or write of data within one
 * stripe.
 * For reads, this DAG is as follows:
 *
 *                   /---- read ----\
 *    Header -- Block ---- read ---- Commit -- Terminate
 *                   \---- read ----/
 *
 * For writes, this DAG is as follows:
 *
 *                    /---- write ----\
 *    Header -- Commit ---- write ---- Block -- Terminate
 *                    \---- write ----/
 *
 * There is one disk node per stripe unit accessed, and all disk nodes are in
 * parallel.
 *
 * Tricky point here:  The first disk node (read or write) is created
 * normally.  Subsequent disk nodes are created by copying the first one,
 * and modifying a few params.  The "succedents" and "antecedents" fields are
 * _not_ re-created in each node, but rather left pointing to the same array
 * that was malloc'd when the first node was created.  Thus, it's essential
 * that when this DAG is freed, the succedents and antecedents fields be freed
 * in ONLY ONE of the read nodes.  This does not apply to the "params" field
 * because it is recreated for each READ node.
 *
 * Note that normal-priority accesses do not need to be tagged with their
 * parity stripe ID, because they will never be promoted.  Hence, I've
 * commented-out the code to do this, and marked it with UNNEEDED.
 *
 *****************************************************************************/

void
rf_CreateNonredundantDAG(
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList,
	RF_IoType_t		 type
)
{
	RF_DagNode_t *nodes, *diskNodes, *blockNode, *commitNode, *termNode;
	RF_PhysDiskAddr_t *pda = asmap->physInfo;
	int (*doFunc) (RF_DagNode_t *), (*undoFunc) (RF_DagNode_t *);
	int i, n, totalNumNodes;
	char *name;

	n = asmap->numStripeUnitsAccessed;
	dag_h->creator = "NonredundantDAG";

	RF_ASSERT(RF_IO_IS_R_OR_W(type));
	switch (type) {
	case RF_IO_TYPE_READ:
		doFunc = rf_DiskReadFunc;
		undoFunc = rf_DiskReadUndoFunc;
		name = "R  ";
		if (rf_dagDebug)
			printf("[Creating non-redundant read DAG]\n");
		break;
	case RF_IO_TYPE_WRITE:
		doFunc = rf_DiskWriteFunc;
		undoFunc = rf_DiskWriteUndoFunc;
		name = "W  ";
		if (rf_dagDebug)
			printf("[Creating non-redundant write DAG]\n");
		break;
	default:
		RF_PANIC();
	}

	/*
	 * For reads, the dag can not commit until the block node is reached.
	 * For writes, the dag commits immediately.
	 */
	dag_h->numCommitNodes = 1;
	dag_h->numCommits = 0;
	dag_h->numSuccedents = 1;

	/*
	 * Node count:
	 * 1 block node
	 * n data reads (or writes)
	 * 1 commit node
	 * 1 terminator node
	 */
	RF_ASSERT(n > 0);
	totalNumNodes = n + 3;
	RF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),
	    (RF_DagNode_t *), allocList);
	i = 0;
	diskNodes = &nodes[i];
	i += n;
	blockNode = &nodes[i];
	i += 1;
	commitNode = &nodes[i];
	i += 1;
	termNode = &nodes[i];
	i += 1;
	RF_ASSERT(i == totalNumNodes);

	/* Initialize nodes. */
	switch (type) {
	case RF_IO_TYPE_READ:
		rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, "Nil",
		    allocList);
		rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, "Cmt",
		    allocList);
		rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
		    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm",
		    allocList);
		break;
	case RF_IO_TYPE_WRITE:
		rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, 1, 0, 0, 0, dag_h, "Nil",
		    allocList);
		rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, n, 1, 0, 0, dag_h, "Cmt",
		    allocList);
		rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
		    rf_TerminateUndoFunc, NULL, 0, n, 0, 0, dag_h, "Trm",
		    allocList);
		break;
	default:
		RF_PANIC();
	}

	for (i = 0; i < n; i++) {
		RF_ASSERT(pda != NULL);
		rf_InitNode(&diskNodes[i], rf_wait, RF_FALSE, doFunc, undoFunc,
		    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, name, allocList);
		diskNodes[i].params[0].p = pda;
		diskNodes[i].params[1].p = pda->bufPtr;
		/* Parity stripe id is not necessary. */
		diskNodes[i].params[2].v = 0;
		diskNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
		pda = pda->next;
	}

	/*
	 * Connect nodes.
	 */

	/* Connect hdr to block node. */
	RF_ASSERT(blockNode->numAntecedents == 0);
	dag_h->succedents[0] = blockNode;

	if (type == RF_IO_TYPE_READ) {
		/* Connecting a nonredundant read DAG. */
		RF_ASSERT(blockNode->numSuccedents == n);
		RF_ASSERT(commitNode->numAntecedents == n);
		for (i = 0; i < n; i++) {
			/* Connect block node to each read node. */
			RF_ASSERT(diskNodes[i].numAntecedents == 1);
			blockNode->succedents[i] = &diskNodes[i];
			diskNodes[i].antecedents[0] = blockNode;
			diskNodes[i].antType[0] = rf_control;

			/* Connect each read node to the commit node. */
			RF_ASSERT(diskNodes[i].numSuccedents == 1);
			diskNodes[i].succedents[0] = commitNode;
			commitNode->antecedents[i] = &diskNodes[i];
			commitNode->antType[i] = rf_control;
		}
		/* Connect the commit node to the term node. */
		RF_ASSERT(commitNode->numSuccedents == 1);
		RF_ASSERT(termNode->numAntecedents == 1);
		RF_ASSERT(termNode->numSuccedents == 0);
		commitNode->succedents[0] = termNode;
		termNode->antecedents[0] = commitNode;
		termNode->antType[0] = rf_control;
	} else {
		/* Connecting a nonredundant write DAG. */
		/* Connect the block node to the commit node. */
		RF_ASSERT(blockNode->numSuccedents == 1);
		RF_ASSERT(commitNode->numAntecedents == 1);
		blockNode->succedents[0] = commitNode;
		commitNode->antecedents[0] = blockNode;
		commitNode->antType[0] = rf_control;

		RF_ASSERT(commitNode->numSuccedents == n);
		RF_ASSERT(termNode->numAntecedents == n);
		RF_ASSERT(termNode->numSuccedents == 0);
		for (i = 0; i < n; i++) {
			/* Connect the commit node to each write node. */
			RF_ASSERT(diskNodes[i].numAntecedents == 1);
			commitNode->succedents[i] = &diskNodes[i];
			diskNodes[i].antecedents[0] = commitNode;
			diskNodes[i].antType[0] = rf_control;

			/* Connect each write node to the term node. */
			RF_ASSERT(diskNodes[i].numSuccedents == 1);
			diskNodes[i].succedents[0] = termNode;
			termNode->antecedents[i] = &diskNodes[i];
			termNode->antType[i] = rf_control;
		}
	}
}
/*****************************************************************************
 * Create a fault-free read DAG for RAID level 1.
 *
 * Hdr -> Nil -> Rmir -> Cmt -> Trm
 *
 * The "Rmir" node schedules a read from the disk in the mirror pair with the
 * shortest disk queue.  The proper queue is selected at Rmir execution.  This
 * deferred mapping is unlike other archs in RAIDframe which generally fix
 * mapping at DAG creation time.
 *
 * Parameters:  raidPtr	  - description of the physical array
 *		asmap	  - logical & physical addresses for this access
 *		bp	  - buffer ptr (for holding read data)
 *		flags	  - general flags (e.g. disk locking)
 *		allocList - list of memory allocated in DAG creation
 *****************************************************************************/

void
rf_CreateMirrorReadDAG(
	RF_Raid_t		 *raidPtr,
	RF_AccessStripeMap_t	 *asmap,
	RF_DagHeader_t		 *dag_h,
	void			 *bp,
	RF_RaidAccessFlags_t	  flags,
	RF_AllocListElem_t	 *allocList,
	int			(*readfunc) (RF_DagNode_t *)
)
{
	RF_DagNode_t *readNodes, *nodes, *blockNode, *commitNode, *termNode;
	RF_PhysDiskAddr_t *data_pda = asmap->physInfo;
	RF_PhysDiskAddr_t *parity_pda = asmap->parityInfo;
	int i, n, totalNumNodes;

	n = asmap->numStripeUnitsAccessed;
	dag_h->creator = "RaidOneReadDAG";
	if (rf_dagDebug) {
		printf("[Creating RAID level 1 read DAG]\n");
	}
	/*
	 * This dag can not commit until the commit node is reached.
	 * Errors prior to the commit point imply the dag has failed.
	 */
	dag_h->numCommitNodes = 1;
	dag_h->numCommits = 0;
	dag_h->numSuccedents = 1;

	/*
	 * Node count:
	 * n data reads
	 * 1 block node
	 * 1 commit node
	 * 1 terminator node
	 */
	RF_ASSERT(n > 0);
	totalNumNodes = n + 3;
	RF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),
	    (RF_DagNode_t *), allocList);
	i = 0;
	readNodes = &nodes[i];
	i += n;
	blockNode = &nodes[i];
	i += 1;
	commitNode = &nodes[i];
	i += 1;
	termNode = &nodes[i];
	i += 1;
	RF_ASSERT(i == totalNumNodes);

	/* Initialize nodes. */
	rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, "Nil", allocList);
	rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
	    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, "Cmt", allocList);
	rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
	    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);

	for (i = 0; i < n; i++) {
		RF_ASSERT(data_pda != NULL);
		RF_ASSERT(parity_pda != NULL);
		rf_InitNode(&readNodes[i], rf_wait, RF_FALSE, readfunc,
		    rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5,
		    0, dag_h, "Rmir", allocList);
		readNodes[i].params[0].p = data_pda;
		readNodes[i].params[1].p = data_pda->bufPtr;
		/* Parity stripe id is not necessary. */
		readNodes[i].params[2].p = 0;
		readNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
		readNodes[i].params[4].p = parity_pda;
		data_pda = data_pda->next;
		parity_pda = parity_pda->next;
	}

	/*
	 * Connect nodes.
	 */

	/* Connect hdr to block node. */
	RF_ASSERT(blockNode->numAntecedents == 0);
	dag_h->succedents[0] = blockNode;

	/* Connect block node to read nodes. */
	RF_ASSERT(blockNode->numSuccedents == n);
	for (i = 0; i < n; i++) {
		RF_ASSERT(readNodes[i].numAntecedents == 1);
		blockNode->succedents[i] = &readNodes[i];
		readNodes[i].antecedents[0] = blockNode;
		readNodes[i].antType[0] = rf_control;
	}

	/* Connect read nodes to commit node. */
	RF_ASSERT(commitNode->numAntecedents == n);
	for (i = 0; i < n; i++) {
		RF_ASSERT(readNodes[i].numSuccedents == 1);
		readNodes[i].succedents[0] = commitNode;
		commitNode->antecedents[i] = &readNodes[i];
		commitNode->antType[i] = rf_control;
	}

	/* Connect commit node to term node. */
	RF_ASSERT(commitNode->numSuccedents == 1);
	RF_ASSERT(termNode->numAntecedents == 1);
	RF_ASSERT(termNode->numSuccedents == 0);
	commitNode->succedents[0] = termNode;
	termNode->antecedents[0] = commitNode;
	termNode->antType[0] = rf_control;
}

void
rf_CreateMirrorIdleReadDAG(
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList
)
{
	rf_CreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
	    rf_DiskReadMirrorIdleFunc);
}

void
rf_CreateMirrorPartitionReadDAG(
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList
)
{
	rf_CreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
	    rf_DiskReadMirrorPartitionFunc);
}
@


1.4
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagffrd.c,v 1.3 2000/01/11 18:02:21 peter Exp $	*/
@


1.3
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagffrd.c,v 1.2 1999/02/16 00:02:30 niklas Exp $	*/
d3 1
d34 1
a34 1
 * code for creating fault-free read DAGs
d48 5
a52 1
/******************************************************************************
d68 1
a68 1
 */
d71 1
a71 1
/******************************************************************************
d77 2
a78 1
 */
d80 1
a80 1
void 
d82 7
a88 6
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList)
d95 3
a97 1
/******************************************************************************
d99 1
a99 2
 * DAG creation code begins here
 */
d101 1
a101 1
/******************************************************************************
d103 1
a103 1
 * creates a DAG to perform a nonredundant read or write of data within one
d135 1
a135 1
void 
d137 8
a144 7
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList,
    RF_IoType_t type)
d148 3
a150 3
	int     (*doFunc) (RF_DagNode_t *), (*undoFunc) (RF_DagNode_t *);
	int     i, n, totalNumNodes;
	char   *name;
d176 3
a178 3
         * For reads, the dag can not commit until the block node is reached.
         * for writes, the dag commits immediately.
         */
d184 6
a189 6
         * Node count:
         * 1 block node
         * n data reads (or writes)
         * 1 commit node
         * 1 terminator node
         */
d205 1
a205 1
	/* initialize nodes */
d208 9
a216 6
		rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
		    NULL, n, 0, 0, 0, dag_h, "Nil", allocList);
		rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
		    NULL, 1, n, 0, 0, dag_h, "Cmt", allocList);
		rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,
		    NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
d219 9
a227 6
		rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
		    NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
		rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
		    NULL, n, 1, 0, 0, dag_h, "Cmt", allocList);
		rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,
		    NULL, 0, n, 0, 0, dag_h, "Trm", allocList);
d235 2
a236 2
		rf_InitNode(&diskNodes[i], rf_wait, RF_FALSE, doFunc, undoFunc, rf_GenericWakeupFunc,
		    1, 1, 4, 0, dag_h, name, allocList);
d239 1
a239 1
		/* parity stripe id is not necessary */
d241 2
a242 1
		diskNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d247 2
a248 2
         * Connect nodes.
         */
d250 1
a250 1
	/* connect hdr to block node */
d255 1
a255 1
		/* connecting a nonredundant read DAG */
d259 1
a259 1
			/* connect block node to each read node */
d265 1
a265 1
			/* connect each read node to the commit node */
d271 1
a271 1
		/* connect the commit node to the term node */
d279 2
a280 2
		/* connecting a nonredundant write DAG */
		/* connect the block node to the commit node */
d291 1
a291 1
			/* connect the commit node to each write node */
d297 1
a297 1
			/* connect each write node to the term node */
d305 2
a306 2
/******************************************************************************
 * Create a fault-free read DAG for RAID level 1
d311 1
a311 1
 * shortest disk queue.  the proper queue is selected at Rmir execution.  this
d315 5
a319 5
 * Parameters:  raidPtr   - description of the physical array
 *              asmap     - logical & physical addresses for this access
 *              bp        - buffer ptr (for holding read data)
 *              flags     - general flags (e.g. disk locking)
 *              allocList - list of memory allocated in DAG creation
d322 10
a331 9
static void 
CreateMirrorReadDAG(
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList,
    int (*readfunc) (RF_DagNode_t * node))
d336 1
a336 1
	int     i, n, totalNumNodes;
d344 3
a346 3
         * This dag can not commit until the commit node is reached
         * errors prior to the commit point imply the dag has failed.
         */
d352 6
a357 6
         * Node count:
         * n data reads
         * 1 block node
         * 1 commit node
         * 1 terminator node
         */
d373 1
a373 1
	/* initialize nodes */
d385 2
a386 2
		    rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5, 0, dag_h,
		    "Rmir", allocList);
d389 1
a389 1
		/* parity stripe id is not necessary */
d391 2
a392 1
		readNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d399 2
a400 2
         * Connect nodes
         */
d402 1
a402 1
	/* connect hdr to block node */
d406 1
a406 1
	/* connect block node to read nodes */
d415 1
a415 1
	/* connect read nodes to commit node */
d424 1
a424 1
	/* connect commit node to term node */
d433 1
a433 1
void 
d435 7
a441 6
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList)
d443 1
a443 1
	CreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
d447 1
a447 1
void 
d449 7
a455 6
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_DagHeader_t * dag_h,
    void *bp,
    RF_RaidAccessFlags_t flags,
    RF_AllocListElem_t * allocList)
d457 1
a457 1
	CreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
@


1.3.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d33 1
a33 1
 * Code for creating fault-free read DAGs.
d47 1
a47 5
void rf_CreateMirrorReadDAG( RF_Raid_t *, RF_AccessStripeMap_t *,
	RF_DagHeader_t *, void *, RF_RaidAccessFlags_t, RF_AllocListElem_t *,
	int (*) (RF_DagNode_t *));

/*****************************************************************************
d63 1
a63 1
 *****************************************************************************/
d66 1
a66 1
/*****************************************************************************
d72 1
a72 2
 *
 *****************************************************************************/
d74 1
a74 1
void
d76 6
a81 7
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList
)
d88 1
a88 1
/*****************************************************************************
d90 2
a91 3
 * DAG creation code begins here.
 *
 *****************************************************************************/
d93 1
a93 1
/*****************************************************************************
d95 1
a95 1
 * Creates a DAG to perform a nonredundant read or write of data within one
d127 1
a127 1
void
d129 7
a135 8
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList,
	RF_IoType_t		 type
)
d139 3
a141 3
	int (*doFunc) (RF_DagNode_t *), (*undoFunc) (RF_DagNode_t *);
	int i, n, totalNumNodes;
	char *name;
d167 3
a169 3
	 * For reads, the dag can not commit until the block node is reached.
	 * For writes, the dag commits immediately.
	 */
d175 6
a180 6
	 * Node count:
	 * 1 block node
	 * n data reads (or writes)
	 * 1 commit node
	 * 1 terminator node
	 */
d196 1
a196 1
	/* Initialize nodes. */
d199 6
a204 9
		rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, "Nil",
		    allocList);
		rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, "Cmt",
		    allocList);
		rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
		    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm",
		    allocList);
d207 6
a212 9
		rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, 1, 0, 0, 0, dag_h, "Nil",
		    allocList);
		rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, n, 1, 0, 0, dag_h, "Cmt",
		    allocList);
		rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
		    rf_TerminateUndoFunc, NULL, 0, n, 0, 0, dag_h, "Trm",
		    allocList);
d220 2
a221 2
		rf_InitNode(&diskNodes[i], rf_wait, RF_FALSE, doFunc, undoFunc,
		    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, name, allocList);
d224 1
a224 1
		/* Parity stripe id is not necessary. */
d226 1
a226 2
		diskNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d231 2
a232 2
	 * Connect nodes.
	 */
d234 1
a234 1
	/* Connect hdr to block node. */
d239 1
a239 1
		/* Connecting a nonredundant read DAG. */
d243 1
a243 1
			/* Connect block node to each read node. */
d249 1
a249 1
			/* Connect each read node to the commit node. */
d255 1
a255 1
		/* Connect the commit node to the term node. */
d263 2
a264 2
		/* Connecting a nonredundant write DAG. */
		/* Connect the block node to the commit node. */
d275 1
a275 1
			/* Connect the commit node to each write node. */
d281 1
a281 1
			/* Connect each write node to the term node. */
d289 2
a290 2
/*****************************************************************************
 * Create a fault-free read DAG for RAID level 1.
d295 1
a295 1
 * shortest disk queue.  The proper queue is selected at Rmir execution.  This
d299 5
a303 5
 * Parameters:  raidPtr	  - description of the physical array
 *		asmap	  - logical & physical addresses for this access
 *		bp	  - buffer ptr (for holding read data)
 *		flags	  - general flags (e.g. disk locking)
 *		allocList - list of memory allocated in DAG creation
d306 9
a314 10
void
rf_CreateMirrorReadDAG(
	RF_Raid_t		 *raidPtr,
	RF_AccessStripeMap_t	 *asmap,
	RF_DagHeader_t		 *dag_h,
	void			 *bp,
	RF_RaidAccessFlags_t	  flags,
	RF_AllocListElem_t	 *allocList,
	int			(*readfunc) (RF_DagNode_t *)
)
d319 1
a319 1
	int i, n, totalNumNodes;
d327 3
a329 3
	 * This dag can not commit until the commit node is reached.
	 * Errors prior to the commit point imply the dag has failed.
	 */
d335 6
a340 6
	 * Node count:
	 * n data reads
	 * 1 block node
	 * 1 commit node
	 * 1 terminator node
	 */
d356 1
a356 1
	/* Initialize nodes. */
d368 2
a369 2
		    rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5,
		    0, dag_h, "Rmir", allocList);
d372 1
a372 1
		/* Parity stripe id is not necessary. */
d374 1
a374 2
		readNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d381 2
a382 2
	 * Connect nodes.
	 */
d384 1
a384 1
	/* Connect hdr to block node. */
d388 1
a388 1
	/* Connect block node to read nodes. */
d397 1
a397 1
	/* Connect read nodes to commit node. */
d406 1
a406 1
	/* Connect commit node to term node. */
d415 1
a415 1
void
d417 6
a422 7
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList
)
d424 1
a424 1
	rf_CreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
d428 1
a428 1
void
d430 6
a435 7
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList
)
d437 1
a437 1
	rf_CreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
@


1.3.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d33 1
a33 1
 * Code for creating fault-free read DAGs.
d47 1
a47 5
void rf_CreateMirrorReadDAG( RF_Raid_t *, RF_AccessStripeMap_t *,
	RF_DagHeader_t *, void *, RF_RaidAccessFlags_t, RF_AllocListElem_t *,
	int (*) (RF_DagNode_t *));

/*****************************************************************************
d63 1
a63 1
 *****************************************************************************/
d66 1
a66 1
/*****************************************************************************
d72 1
a72 2
 *
 *****************************************************************************/
d74 1
a74 1
void
d76 6
a81 7
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList
)
d88 1
a88 1
/*****************************************************************************
d90 2
a91 3
 * DAG creation code begins here.
 *
 *****************************************************************************/
d93 1
a93 1
/*****************************************************************************
d95 1
a95 1
 * Creates a DAG to perform a nonredundant read or write of data within one
d127 1
a127 1
void
d129 7
a135 8
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList,
	RF_IoType_t		 type
)
d139 3
a141 3
	int (*doFunc) (RF_DagNode_t *), (*undoFunc) (RF_DagNode_t *);
	int i, n, totalNumNodes;
	char *name;
d167 3
a169 3
	 * For reads, the dag can not commit until the block node is reached.
	 * For writes, the dag commits immediately.
	 */
d175 6
a180 6
	 * Node count:
	 * 1 block node
	 * n data reads (or writes)
	 * 1 commit node
	 * 1 terminator node
	 */
d196 1
a196 1
	/* Initialize nodes. */
d199 6
a204 9
		rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, "Nil",
		    allocList);
		rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, "Cmt",
		    allocList);
		rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
		    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm",
		    allocList);
d207 6
a212 9
		rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, 1, 0, 0, 0, dag_h, "Nil",
		    allocList);
		rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
		    rf_NullNodeUndoFunc, NULL, n, 1, 0, 0, dag_h, "Cmt",
		    allocList);
		rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
		    rf_TerminateUndoFunc, NULL, 0, n, 0, 0, dag_h, "Trm",
		    allocList);
d220 2
a221 2
		rf_InitNode(&diskNodes[i], rf_wait, RF_FALSE, doFunc, undoFunc,
		    rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, name, allocList);
d224 1
a224 1
		/* Parity stripe id is not necessary. */
d226 1
a226 2
		diskNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d231 2
a232 2
	 * Connect nodes.
	 */
d234 1
a234 1
	/* Connect hdr to block node. */
d239 1
a239 1
		/* Connecting a nonredundant read DAG. */
d243 1
a243 1
			/* Connect block node to each read node. */
d249 1
a249 1
			/* Connect each read node to the commit node. */
d255 1
a255 1
		/* Connect the commit node to the term node. */
d263 2
a264 2
		/* Connecting a nonredundant write DAG. */
		/* Connect the block node to the commit node. */
d275 1
a275 1
			/* Connect the commit node to each write node. */
d281 1
a281 1
			/* Connect each write node to the term node. */
d289 2
a290 2
/*****************************************************************************
 * Create a fault-free read DAG for RAID level 1.
d295 1
a295 1
 * shortest disk queue.  The proper queue is selected at Rmir execution.  This
d299 5
a303 5
 * Parameters:  raidPtr	  - description of the physical array
 *		asmap	  - logical & physical addresses for this access
 *		bp	  - buffer ptr (for holding read data)
 *		flags	  - general flags (e.g. disk locking)
 *		allocList - list of memory allocated in DAG creation
d306 9
a314 10
void
rf_CreateMirrorReadDAG(
	RF_Raid_t		 *raidPtr,
	RF_AccessStripeMap_t	 *asmap,
	RF_DagHeader_t		 *dag_h,
	void			 *bp,
	RF_RaidAccessFlags_t	  flags,
	RF_AllocListElem_t	 *allocList,
	int			(*readfunc) (RF_DagNode_t *)
)
d319 1
a319 1
	int i, n, totalNumNodes;
d327 3
a329 3
	 * This dag can not commit until the commit node is reached.
	 * Errors prior to the commit point imply the dag has failed.
	 */
d335 6
a340 6
	 * Node count:
	 * n data reads
	 * 1 block node
	 * 1 commit node
	 * 1 terminator node
	 */
d356 1
a356 1
	/* Initialize nodes. */
d368 2
a369 2
		    rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5,
		    0, dag_h, "Rmir", allocList);
d372 1
a372 1
		/* Parity stripe id is not necessary. */
d374 1
a374 2
		readNodes[i].params[3].v =
		    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d381 2
a382 2
	 * Connect nodes.
	 */
d384 1
a384 1
	/* Connect hdr to block node. */
d388 1
a388 1
	/* Connect block node to read nodes. */
d397 1
a397 1
	/* Connect read nodes to commit node. */
d406 1
a406 1
	/* Connect commit node to term node. */
d415 1
a415 1
void
d417 6
a422 7
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList
)
d424 1
a424 1
	rf_CreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
d428 1
a428 1
void
d430 6
a435 7
	RF_Raid_t		*raidPtr,
	RF_AccessStripeMap_t	*asmap,
	RF_DagHeader_t		*dag_h,
	void			*bp,
	RF_RaidAccessFlags_t	 flags,
	RF_AllocListElem_t	*allocList
)
d437 1
a437 1
	rf_CreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagffrd.c,v 1.1 1999/01/11 14:29:08 niklas Exp $	*/
/*	$NetBSD: rf_dagffrd.c,v 1.3 1999/02/05 00:06:07 oster Exp $	*/
a41 1
#include "rf_threadid.h"
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagffrd.c,v 1.1 1998/11/13 04:20:27 oster Exp $	*/
/*	$NetBSD: rf_dagffrd.c,v 1.1 1998/11/13 04:20:27 oster Exp $	*/
a34 72
 * :  
 * Log: rf_dagffrd.c,v 
 * Revision 1.14  1996/07/28 20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.13  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.12  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.11  1996/06/06  17:30:44  jimz
 * turn old Raid1 mirror read creation into a more generic function
 * parameterized by an addtional parameter: type of mirrored read
 * this is now used by other dag creation routines so chained declustering
 * and raid1 can share dag creation code, but have different mirroring
 * policies
 *
 * Revision 1.10  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.9  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.8  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.7  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.6  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.5  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.4  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.3  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.2  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.1  1996/05/03  19:19:20  wvcii
 * Initial revision
 *
d51 1
a51 1
 * 
d75 8
a82 7
void rf_CreateFaultFreeReadDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList)
d84 2
a85 2
  rf_CreateNonredundantDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
    RF_IO_TYPE_READ);
d100 1
a100 1
 *                   /---- read ----\ 
d106 1
a106 1
 *                    /---- write ----\ 
d128 9
a136 8
void rf_CreateNonredundantDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList,
  RF_IoType_t            type)
d138 151
a288 146
  RF_DagNode_t *nodes, *diskNodes, *blockNode, *commitNode, *termNode;
  RF_PhysDiskAddr_t *pda = asmap->physInfo;
  int (*doFunc)(RF_DagNode_t *), (*undoFunc)(RF_DagNode_t *);
  int i, n, totalNumNodes;
  char *name;

  n = asmap->numStripeUnitsAccessed;
  dag_h->creator = "NonredundantDAG";

  RF_ASSERT(RF_IO_IS_R_OR_W(type));
  switch (type) {
    case RF_IO_TYPE_READ:
      doFunc = rf_DiskReadFunc;
      undoFunc = rf_DiskReadUndoFunc;
      name = "R  ";
      if (rf_dagDebug) printf("[Creating non-redundant read DAG]\n");
      break;
    case RF_IO_TYPE_WRITE:
      doFunc = rf_DiskWriteFunc;
      undoFunc = rf_DiskWriteUndoFunc;
      name = "W  ";
      if (rf_dagDebug) printf("[Creating non-redundant write DAG]\n");
      break;
    default:
      RF_PANIC();
  }

  /*
   * For reads, the dag can not commit until the block node is reached.
   * for writes, the dag commits immediately.
   */
  dag_h->numCommitNodes = 1;
  dag_h->numCommits = 0;
  dag_h->numSuccedents = 1;

  /*
   * Node count:
   * 1 block node
   * n data reads (or writes)
   * 1 commit node
   * 1 terminator node
   */
  RF_ASSERT(n > 0);
  totalNumNodes = n + 3;
  RF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),
    (RF_DagNode_t *), allocList);
  i = 0;
  diskNodes   = &nodes[i]; i += n;
  blockNode   = &nodes[i]; i += 1;
  commitNode   = &nodes[i]; i += 1;
  termNode    = &nodes[i];  i += 1;
  RF_ASSERT(i == totalNumNodes);

  /* initialize nodes */
  switch (type) {
    case RF_IO_TYPE_READ:
      rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
        NULL, n, 0, 0, 0, dag_h, "Nil", allocList);
      rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
        NULL, 1, n, 0, 0, dag_h, "Cmt", allocList);
      rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,
        NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);
      break;
    case RF_IO_TYPE_WRITE:
      rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
        NULL, 1, 0, 0, 0, dag_h, "Nil", allocList);
      rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,
        NULL, n, 1, 0, 0, dag_h, "Cmt", allocList);
      rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,
        NULL, 0, n, 0, 0, dag_h, "Trm", allocList);
      break;
    default:
      RF_PANIC();
  }

  for (i = 0; i < n; i++) {
    RF_ASSERT(pda != NULL);
    rf_InitNode(&diskNodes[i], rf_wait, RF_FALSE, doFunc, undoFunc, rf_GenericWakeupFunc,
      1, 1, 4, 0, dag_h, name, allocList);
    diskNodes[i].params[0].p  = pda;
    diskNodes[i].params[1].p  = pda->bufPtr;
    /* parity stripe id is not necessary */
    diskNodes[i].params[2].v  = 0;
    diskNodes[i].params[3].v  = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
    pda = pda->next;
  }

  /*
   * Connect nodes.
   */

  /* connect hdr to block node */
  RF_ASSERT(blockNode->numAntecedents == 0);
  dag_h->succedents[0] = blockNode;

  if (type == RF_IO_TYPE_READ) {
    /* connecting a nonredundant read DAG */
    RF_ASSERT(blockNode->numSuccedents == n);
    RF_ASSERT(commitNode->numAntecedents == n);
    for (i=0; i < n; i++) {
      /* connect block node to each read node */
      RF_ASSERT(diskNodes[i].numAntecedents == 1);
      blockNode->succedents[i] = &diskNodes[i];
      diskNodes[i].antecedents[0] = blockNode;
      diskNodes[i].antType[0] = rf_control;

      /* connect each read node to the commit node */
      RF_ASSERT(diskNodes[i].numSuccedents == 1);
      diskNodes[i].succedents[0] = commitNode;
      commitNode->antecedents[i] = &diskNodes[i];
      commitNode->antType[i] = rf_control;
    }
    /* connect the commit node to the term node */
    RF_ASSERT(commitNode->numSuccedents == 1);
    RF_ASSERT(termNode->numAntecedents == 1);
    RF_ASSERT(termNode->numSuccedents == 0);
    commitNode->succedents[0] = termNode;
    termNode->antecedents[0] = commitNode;
    termNode->antType[0] = rf_control;
  }
  else {
    /* connecting a nonredundant write DAG */
    /* connect the block node to the commit node */
    RF_ASSERT(blockNode->numSuccedents == 1);
    RF_ASSERT(commitNode->numAntecedents == 1);
    blockNode->succedents[0] = commitNode;
    commitNode->antecedents[0] = blockNode;
    commitNode->antType[0] = rf_control;

    RF_ASSERT(commitNode->numSuccedents == n);
    RF_ASSERT(termNode->numAntecedents == n);
    RF_ASSERT(termNode->numSuccedents == 0);
    for (i=0; i < n; i++) {
      /* connect the commit node to each write node */
      RF_ASSERT(diskNodes[i].numAntecedents == 1);
      commitNode->succedents[i] = &diskNodes[i];
      diskNodes[i].antecedents[0] = commitNode;
      diskNodes[i].antType[0] = rf_control;

      /* connect each write node to the term node */
      RF_ASSERT(diskNodes[i].numSuccedents == 1);
      diskNodes[i].succedents[0] = termNode;
      termNode->antecedents[i] = &diskNodes[i];
      termNode->antType[i] = rf_control;
    }
  }
a289 1

d303 1
a303 1
 *              flags     - general flags (e.g. disk locking) 
d307 9
a315 8
static void CreateMirrorReadDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList,
  int                   (*readfunc)(RF_DagNode_t *node))
d317 97
a413 94
  RF_DagNode_t *readNodes, *nodes, *blockNode, *commitNode, *termNode;
  RF_PhysDiskAddr_t *data_pda = asmap->physInfo;
  RF_PhysDiskAddr_t *parity_pda = asmap->parityInfo;
  int i, n, totalNumNodes;

  n = asmap->numStripeUnitsAccessed;
  dag_h->creator = "RaidOneReadDAG";
  if (rf_dagDebug) {
    printf("[Creating RAID level 1 read DAG]\n");
  }

  /*
   * This dag can not commit until the commit node is reached
   * errors prior to the commit point imply the dag has failed.
   */
  dag_h->numCommitNodes = 1;
  dag_h->numCommits = 0;
  dag_h->numSuccedents = 1;

  /*
   * Node count:
   * n data reads
   * 1 block node
   * 1 commit node
   * 1 terminator node
   */
  RF_ASSERT(n > 0);
  totalNumNodes = n + 3;
  RF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),
    (RF_DagNode_t *), allocList);
  i = 0;
  readNodes   = &nodes[i]; i += n;
  blockNode   = &nodes[i]; i += 1;
  commitNode = &nodes[i]; i += 1;
  termNode    = &nodes[i]; i += 1;
  RF_ASSERT(i == totalNumNodes);

  /* initialize nodes */
  rf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,
    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, "Nil", allocList);
  rf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,
    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, "Cmt", allocList);
  rf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,
    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, "Trm", allocList);

  for (i = 0; i < n; i++) {
    RF_ASSERT(data_pda != NULL);
    RF_ASSERT(parity_pda != NULL);
    rf_InitNode(&readNodes[i], rf_wait, RF_FALSE, readfunc,
      rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5, 0, dag_h,
      "Rmir", allocList);
    readNodes[i].params[0].p = data_pda;
    readNodes[i].params[1].p = data_pda->bufPtr;
    /* parity stripe id is not necessary */
    readNodes[i].params[2].p = 0;
    readNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
    readNodes[i].params[4].p = parity_pda;
    data_pda = data_pda->next;
    parity_pda = parity_pda->next;
  }

  /*
   * Connect nodes
   */

  /* connect hdr to block node */
  RF_ASSERT(blockNode->numAntecedents == 0);
  dag_h->succedents[0] = blockNode;

  /* connect block node to read nodes */
  RF_ASSERT(blockNode->numSuccedents == n);
  for (i=0; i < n; i++) {
    RF_ASSERT(readNodes[i].numAntecedents == 1);
    blockNode->succedents[i] = &readNodes[i];
    readNodes[i].antecedents[0] = blockNode;
    readNodes[i].antType[0] = rf_control;
  }

  /* connect read nodes to commit node */
  RF_ASSERT(commitNode->numAntecedents == n);
  for (i=0; i < n; i++) {
    RF_ASSERT(readNodes[i].numSuccedents == 1);
    readNodes[i].succedents[0] = commitNode;
    commitNode->antecedents[i] = &readNodes[i];
    commitNode->antType[i] = rf_control;
  }

  /* connect commit node to term node */
  RF_ASSERT(commitNode->numSuccedents == 1);
  RF_ASSERT(termNode->numAntecedents == 1);
  RF_ASSERT(termNode->numSuccedents == 0);
  commitNode->succedents[0] = termNode;
  termNode->antecedents[0] = commitNode;
  termNode->antType[0] = rf_control;
d416 8
a423 7
void rf_CreateMirrorIdleReadDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList)
d425 2
a426 2
  CreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
    rf_DiskReadMirrorIdleFunc);
d429 8
a436 7
void rf_CreateMirrorPartitionReadDAG(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap,
  RF_DagHeader_t        *dag_h,
  void                  *bp,
  RF_RaidAccessFlags_t   flags,
  RF_AllocListElem_t    *allocList)
d438 2
a439 2
  CreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,
    rf_DiskReadMirrorPartitionFunc);
@

