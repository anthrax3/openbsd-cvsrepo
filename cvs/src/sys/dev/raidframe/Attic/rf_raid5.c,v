head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.38
	OPENBSD_5_0:1.4.0.36
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.16
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.14
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.12
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.4;

1.4
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.11.18.02.23;	author peter;	state Exp;
branches
	1.3.2.1
	1.3.12.1;
next	1.2;

1.2
date	99.02.16.00.03.17;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.43;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.3.12.1
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_raid5.c,v 1.4 2002/12/16 07:01:04 tdeval Exp $	*/
/*	$NetBSD: rf_raid5.c,v 1.4 2000/01/08 22:57:30 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 *
 * rf_raid5.c -- Implements RAID Level 5.
 *
 *****************************************************************************/

#include "rf_types.h"
#include "rf_raid.h"
#include "rf_raid5.h"
#include "rf_dag.h"
#include "rf_dagffrd.h"
#include "rf_dagffwr.h"
#include "rf_dagdegrd.h"
#include "rf_dagdegwr.h"
#include "rf_dagutils.h"
#include "rf_general.h"
#include "rf_map.h"
#include "rf_utils.h"

typedef struct RF_Raid5ConfigInfo_s {
	RF_RowCol_t **stripeIdentifier;	/*
					 * Filled in at config time and used
					 * by IdentifyStripe.
					 */
} RF_Raid5ConfigInfo_t;


int
rf_ConfigureRAID5(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
	RF_Raid5ConfigInfo_t *info;
	RF_RowCol_t i, j, startdisk;

	/* Create a RAID level 5 configuration structure. */
	RF_MallocAndAdd(info, sizeof(RF_Raid5ConfigInfo_t),
	    (RF_Raid5ConfigInfo_t *), raidPtr->cleanupList);
	if (info == NULL)
		return (ENOMEM);
	layoutPtr->layoutSpecificInfo = (void *) info;

	RF_ASSERT(raidPtr->numRow == 1);

	/*
	 * The stripe identifier must identify the disks in each stripe, IN
	 * THE ORDER THAT THEY APPEAR IN THE STRIPE.
	 */
	info->stripeIdentifier = rf_make_2d_array(raidPtr->numCol,
	    raidPtr->numCol, raidPtr->cleanupList);
	if (info->stripeIdentifier == NULL)
		return (ENOMEM);
	startdisk = 0;
	for (i = 0; i < raidPtr->numCol; i++) {
		for (j = 0; j < raidPtr->numCol; j++) {
			info->stripeIdentifier[i][j] = (startdisk + j) %
			    raidPtr->numCol;
		}
		if ((--startdisk) < 0)
			startdisk = raidPtr->numCol - 1;
	}

	/* Fill in the remaining layout parameters. */
	layoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
	layoutPtr->numDataCol = raidPtr->numCol - 1;
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
	layoutPtr->numParityCol = 1;
	layoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;

	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;

	return (0);
}

int
rf_GetDefaultNumFloatingReconBuffersRAID5(RF_Raid_t *raidPtr)
{
	return (20);
}

RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitRAID5(RF_Raid_t *raidPtr)
{
	return (10);
}

#if !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(_KERNEL)
/* Not currently used. */
int
rf_ShutdownRAID5(RF_Raid_t *raidPtr)
{
	return (0);
}
#endif

void
rf_MapSectorRAID5(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
{
	RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
	*row = 0;
	*col = (SUID % raidPtr->numCol);
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
	    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
}

void
rf_MapParityRAID5(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
{
	RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;

	*row = 0;
	*col = raidPtr->Layout.numDataCol -
	    (SUID / raidPtr->Layout.numDataCol) % raidPtr->numCol;
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
	    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
}

void
rf_IdentifyStripeRAID5(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
{
	RF_StripeNum_t stripeID =
	    rf_RaidAddressToStripeID(&raidPtr->Layout, addr);
	RF_Raid5ConfigInfo_t *info =
	    (RF_Raid5ConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;

	*outRow = 0;
	*diskids = info->stripeIdentifier[stripeID % raidPtr->numCol];
}

void
rf_MapSIDToPSIDRAID5(RF_RaidLayout_t *layoutPtr, RF_StripeNum_t stripeID,
    RF_StripeNum_t *psID, RF_ReconUnitNum_t *which_ru)
{
	*which_ru = 0;
	*psID = stripeID;
}


/*
 * Select an algorithm for performing an access.  Returns two pointers,
 * one to a function that will return information about the DAG, and
 * another to a function that will create the dag.
 */
void
rf_RaidFiveDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmap, RF_VoidFuncPtr *createFunc)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	RF_PhysDiskAddr_t *failedPDA = NULL;
	RF_RowCol_t frow, fcol;
	RF_RowStatus_t rstat;
	int prior_recon;

	RF_ASSERT(RF_IO_IS_R_OR_W(type));

	if (asmap->numDataFailed + asmap->numParityFailed > 1) {
		RF_ERRORMSG("Multiple disks failed in a single group !"
		            "  Aborting I/O operation.\n");
		 /* *infoFunc = */ *createFunc = NULL;
		return;
	} else
		if (asmap->numDataFailed + asmap->numParityFailed == 1) {

			/*
			 * If under recon & already reconstructed, redirect
			 * the access to the spare drive and eliminate the
			 * failure indication.
			 */
			failedPDA = asmap->failedPDAs[0];
			frow = failedPDA->row;
			fcol = failedPDA->col;
			rstat = raidPtr->status[failedPDA->row];
			prior_recon = (rstat == rf_rs_reconfigured) || (
			    (rstat == rf_rs_reconstructing) ?
			    rf_CheckRUReconstructed(raidPtr
			     ->reconControl[frow]->reconMap,
			     failedPDA->startSector) : 0);
			if (prior_recon) {
				RF_RowCol_t or = failedPDA->row;
				RF_RowCol_t oc = failedPDA->col;
				RF_SectorNum_t oo = failedPDA->startSector;

				if (layoutPtr->map->flags &
				    RF_DISTRIBUTE_SPARE) {
					/* Redirect to dist spare space. */

					if (failedPDA == asmap->parityInfo) {

						/* Parity has failed. */
						(layoutPtr->map->MapParity)
						    (raidPtr,
						     failedPDA->raidAddress,
						     &failedPDA->row,
						     &failedPDA->col,
						     &failedPDA->startSector,
						     RF_REMAP);

						if (asmap->parityInfo->next) {
							/*
							 * Redir 2nd component,
							 * if any.
							 */
							RF_PhysDiskAddr_t *p =
							    asmap
							     ->parityInfo->next;
							RF_SectorNum_t SUoffs =
							    p->startSector %
						layoutPtr->sectorsPerStripeUnit;
							p->row = failedPDA->row;
							p->col = failedPDA->col;
							/*
							 * Cheating:
							 * startSector is not
							 * really a RAID
							 * address.
							 */
							p->startSector =
					rf_RaidAddressOfPrevStripeUnitBoundary(
					    layoutPtr, failedPDA->startSector) +
							    SUoffs;
						}
					} else
						if (asmap->parityInfo->next &&
						    failedPDA ==
						    asmap->parityInfo->next) {
							/*
							 * Should never happen.
							 */
							RF_ASSERT(0);
						} else {
							/* Data has failed. */
							(layoutPtr->map
							 ->MapSector) (raidPtr,
							 failedPDA->raidAddress,
							    &failedPDA->row,
							    &failedPDA->col,
							&failedPDA->startSector,
							    RF_REMAP);
						}

				} else {
					/* Redirect to dedicated spare space. */

					failedPDA->row =
					    raidPtr->Disks[frow][fcol].spareRow;
					failedPDA->col =
					    raidPtr->Disks[frow][fcol].spareCol;

					/*
					 * The parity may have two distinct
					 * components, both of which may need
					 * to be redirected.
					 */
					if (asmap->parityInfo->next) {
						if (failedPDA ==
						    asmap->parityInfo) {
							failedPDA->next->row =
							    failedPDA->row;
							failedPDA->next->col =
							    failedPDA->col;
						} else {
							if (failedPDA ==
							    asmap->parityInfo
							     ->next) {
								/*
								 * Paranoid:
								 * Should never
								 * occur.
								 */
								asmap
								 ->parityInfo
								 ->row =
								 failedPDA->row;
								asmap
								 ->parityInfo
								 ->col =
								 failedPDA->col;
							}
						}
					}
				}

				RF_ASSERT(failedPDA->col != -1);

				if (rf_dagDebug || rf_mapDebug) {
					printf("raid%d: Redirected type '%c'"
					       " r %d c %d o %ld -> r %d c %d"
					       " o %ld\n", raidPtr->raidid,
					       type, or, oc, (long) oo,
					       failedPDA->row, failedPDA->col,
					       (long) failedPDA->startSector);
				}
				asmap->numDataFailed = asmap->numParityFailed
				                     = 0;
			}
		}
	/*
	 * All DAGs begin/end with block/unblock node. Therefore, hdrSucc &
	 * termAnt counts should always be 1. Also, these counts should not be
	 * visible outside DAG creation routines - manipulating the counts
	 * here should be removed.
	 */
	if (type == RF_IO_TYPE_READ) {
		if (asmap->numDataFailed == 0)
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateFaultFreeReadDAG;
		else
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateRaidFiveDegradedReadDAG;
	} else {
		/*
		 * If mirroring, always use large writes. If the access
		 * requires two distinct parity updates, always do a small
		 * write. If the stripe contains a failure but the access
		 * does not, do a small write. The first conditional
		 * (numStripeUnitsAccessed <= numDataCol/2) uses a
		 * less-than-or-equal rather than just a less-than because
		 * when G is 3 or 4, numDataCol/2 is 1, and I want
		 * single-stripe-unit updates to use just one disk.
		 */
		if ((asmap->numDataFailed + asmap->numParityFailed) == 0) {
			if (rf_suppressLocksAndLargeWrites ||
			    (((asmap->numStripeUnitsAccessed <=
			       (layoutPtr->numDataCol / 2)) &&
			      (layoutPtr->numDataCol != 1)) ||
			     (asmap->parityInfo->next != NULL) ||
			     rf_CheckStripeForFailures(raidPtr, asmap))) {
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateSmallWriteDAG;
			} else
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateLargeWriteDAG;
		} else {
			if (asmap->numParityFailed == 1)
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateNonRedundantWriteDAG;
			else
				if (asmap->numStripeUnitsAccessed != 1 &&
				    failedPDA->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
					*createFunc = NULL;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_CreateDegradedWriteDAG;
		}
	}
}
@


1.4
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_raid5.c,v 1.3 2000/01/11 18:02:23 peter Exp $	*/
@


1.3
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_raid5.c,v 1.2 1999/02/16 00:03:17 niklas Exp $	*/
d3 1
d31 1
a31 1
/******************************************************************************
d33 1
a33 1
 * rf_raid5.c -- implements RAID Level 5
d51 10
a60 9
	RF_RowCol_t **stripeIdentifier;	/* filled in at config time and used
					 * by IdentifyStripe */
}       RF_Raid5ConfigInfo_t;

int 
rf_ConfigureRAID5(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d66 3
a68 2
	/* create a RAID level 5 configuration structure */
	RF_MallocAndAdd(info, sizeof(RF_Raid5ConfigInfo_t), (RF_Raid5ConfigInfo_t *), raidPtr->cleanupList);
d75 6
a80 3
	/* the stripe identifier must identify the disks in each stripe, IN
	 * THE ORDER THAT THEY APPEAR IN THE STRIPE. */
	info->stripeIdentifier = rf_make_2d_array(raidPtr->numCol, raidPtr->numCol, raidPtr->cleanupList);
d86 2
a87 1
			info->stripeIdentifier[i][j] = (startdisk + j) % raidPtr->numCol;
d93 1
a93 1
	/* fill in the remaining layout parameters */
d95 2
a96 1
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;
d98 2
a99 1
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d103 2
a104 1
	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d109 2
a110 2
int 
rf_GetDefaultNumFloatingReconBuffersRAID5(RF_Raid_t * raidPtr)
d115 2
a116 2
RF_HeadSepLimit_t 
rf_GetDefaultHeadSepLimitRAID5(RF_Raid_t * raidPtr)
d120 1
d122 3
a124 3
/* not currently used */
int 
rf_ShutdownRAID5(RF_Raid_t * raidPtr)
d130 3
a132 8
void 
rf_MapSectorRAID5(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d137 2
a138 1
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
d142 3
a144 8
void 
rf_MapParityRAID5(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d149 4
a152 2
	*col = raidPtr->Layout.numDataCol - (SUID / raidPtr->Layout.numDataCol) % raidPtr->numCol;
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
d156 3
a158 6
void 
rf_IdentifyStripeRAID5(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t addr,
    RF_RowCol_t ** diskids,
    RF_RowCol_t * outRow)
d160 4
a163 2
	RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, addr);
	RF_Raid5ConfigInfo_t *info = (RF_Raid5ConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d169 3
a171 6
void 
rf_MapSIDToPSIDRAID5(
    RF_RaidLayout_t * layoutPtr,
    RF_StripeNum_t stripeID,
    RF_StripeNum_t * psID,
    RF_ReconUnitNum_t * which_ru)
d176 4
a179 1
/* select an algorithm for performing an access.  Returns two pointers,
d183 3
a185 6
void 
rf_RaidFiveDagSelect(
    RF_Raid_t * raidPtr,
    RF_IoType_t type,
    RF_AccessStripeMap_t * asmap,
    RF_VoidFuncPtr * createFunc)
d191 1
a191 1
	int     prior_recon;
d196 2
a197 1
		RF_ERRORMSG("Multiple disks failed in a single group!  Aborting I/O operation.\n");
d203 2
a204 1
			/* if under recon & already reconstructed, redirect
d206 2
a207 1
			 * failure indication */
d214 3
a216 2
			    rf_CheckRUReconstructed(raidPtr->reconControl[frow]->reconMap, failedPDA->startSector) : 0
			    );
d218 2
a219 1
				RF_RowCol_t or = failedPDA->row, oc = failedPDA->col;
d222 3
a224 2
				if (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {	/* redirect to dist
											 * spare space */
d228 20
a247 8
						/* parity has failed */
						(layoutPtr->map->MapParity) (raidPtr, failedPDA->raidAddress, &failedPDA->row,
						    &failedPDA->col, &failedPDA->startSector, RF_REMAP);

						if (asmap->parityInfo->next) {	/* redir 2nd component,
										 * if any */
							RF_PhysDiskAddr_t *p = asmap->parityInfo->next;
							RF_SectorNum_t SUoffs = p->startSector % layoutPtr->sectorsPerStripeUnit;
d250 10
a259 4
							p->startSector = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->startSector) +
							    SUoffs;	/* cheating:
									 * startSector is not
									 * really a RAID address */
d262 7
a268 3
						if (asmap->parityInfo->next && failedPDA == asmap->parityInfo->next) {
							RF_ASSERT(0);	/* should not ever
									 * happen */
d270 8
a277 5

							/* data has failed */
							(layoutPtr->map->MapSector) (raidPtr, failedPDA->raidAddress, &failedPDA->row,
							    &failedPDA->col, &failedPDA->startSector, RF_REMAP);

d280 2
a281 2
				} else {	/* redirect to dedicated spare
						 * space */
d283 4
a286 2
					failedPDA->row = raidPtr->Disks[frow][fcol].spareRow;
					failedPDA->col = raidPtr->Disks[frow][fcol].spareCol;
d288 2
a289 1
					/* the parity may have two distinct
d291 2
a292 1
					 * to be redirected */
d294 23
a316 8
						if (failedPDA == asmap->parityInfo) {
							failedPDA->next->row = failedPDA->row;
							failedPDA->next->col = failedPDA->col;
						} else
							if (failedPDA == asmap->parityInfo->next) {	/* paranoid:  should
													 * never occur */
								asmap->parityInfo->row = failedPDA->row;
								asmap->parityInfo->col = failedPDA->col;
d318 1
d325 6
a330 5
					printf("raid%d: Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\n",
					       raidPtr->raidid, type, or, oc, 
					       (long) oo, failedPDA->row, 
					       failedPDA->col,
					    (long) failedPDA->startSector);
d332 2
a333 1
				asmap->numDataFailed = asmap->numParityFailed = 0;
d336 6
a341 4
	/* all dags begin/end with block/unblock node therefore, hdrSucc &
	 * termAnt counts should always be 1 also, these counts should not be
	 * visible outside dag creation routines - manipulating the counts
	 * here should be removed */
d344 2
a345 1
			*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;
d347 2
a348 1
			*createFunc = (RF_VoidFuncPtr) rf_CreateRaidFiveDegradedReadDAG;
d350 2
a351 3


		/* if mirroring, always use large writes.  If the access
d353 1
a353 1
		 * write.  If the stripe contains a failure but the access
d358 2
a359 1
		 * single-stripe-unit updates to use just one disk. */
d362 7
a368 3
			    (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||
				(asmap->parityInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {
				*createFunc = (RF_VoidFuncPtr) rf_CreateSmallWriteDAG;
d370 2
a371 1
				*createFunc = (RF_VoidFuncPtr) rf_CreateLargeWriteDAG;
d374 2
a375 1
				*createFunc = (RF_VoidFuncPtr) rf_CreateNonRedundantWriteDAG;
d377 3
a379 1
				if (asmap->numStripeUnitsAccessed != 1 && failedPDA->numSector != layoutPtr->sectorsPerStripeUnit)
d382 2
a383 1
					*createFunc = (RF_VoidFuncPtr) rf_CreateDegradedWriteDAG;
@


1.3.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d32 1
a32 1
 * rf_raid5.c -- Implements RAID Level 5.
d50 9
a58 10
	RF_RowCol_t **stripeIdentifier;	/*
					 * Filled in at config time and used
					 * by IdentifyStripe.
					 */
} RF_Raid5ConfigInfo_t;


int
rf_ConfigureRAID5(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d64 2
a65 3
	/* Create a RAID level 5 configuration structure. */
	RF_MallocAndAdd(info, sizeof(RF_Raid5ConfigInfo_t),
	    (RF_Raid5ConfigInfo_t *), raidPtr->cleanupList);
d72 3
a74 6
	/*
	 * The stripe identifier must identify the disks in each stripe, IN
	 * THE ORDER THAT THEY APPEAR IN THE STRIPE.
	 */
	info->stripeIdentifier = rf_make_2d_array(raidPtr->numCol,
	    raidPtr->numCol, raidPtr->cleanupList);
d80 1
a80 2
			info->stripeIdentifier[i][j] = (startdisk + j) %
			    raidPtr->numCol;
d86 1
a86 1
	/* Fill in the remaining layout parameters. */
d88 1
a88 2
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
d90 1
a90 2
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
d94 1
a94 2
	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d99 2
a100 2
int
rf_GetDefaultNumFloatingReconBuffersRAID5(RF_Raid_t *raidPtr)
d105 2
a106 2
RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitRAID5(RF_Raid_t *raidPtr)
a109 1

d111 3
a113 3
/* Not currently used. */
int
rf_ShutdownRAID5(RF_Raid_t *raidPtr)
d119 8
a126 3
void
rf_MapSectorRAID5(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d131 1
a131 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d135 8
a142 3
void
rf_MapParityRAID5(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d147 2
a148 4
	*col = raidPtr->Layout.numDataCol -
	    (SUID / raidPtr->Layout.numDataCol) % raidPtr->numCol;
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d152 6
a157 3
void
rf_IdentifyStripeRAID5(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
d159 2
a160 4
	RF_StripeNum_t stripeID =
	    rf_RaidAddressToStripeID(&raidPtr->Layout, addr);
	RF_Raid5ConfigInfo_t *info =
	    (RF_Raid5ConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d166 6
a171 3
void
rf_MapSIDToPSIDRAID5(RF_RaidLayout_t *layoutPtr, RF_StripeNum_t stripeID,
    RF_StripeNum_t *psID, RF_ReconUnitNum_t *which_ru)
d176 1
a176 4


/*
 * Select an algorithm for performing an access.  Returns two pointers,
d180 6
a185 3
void
rf_RaidFiveDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmap, RF_VoidFuncPtr *createFunc)
d191 1
a191 1
	int prior_recon;
d196 1
a196 2
		RF_ERRORMSG("Multiple disks failed in a single group !"
		            "  Aborting I/O operation.\n");
d202 1
a202 2
			/*
			 * If under recon & already reconstructed, redirect
d204 1
a204 2
			 * failure indication.
			 */
d211 2
a212 3
			    rf_CheckRUReconstructed(raidPtr
			     ->reconControl[frow]->reconMap,
			     failedPDA->startSector) : 0);
d214 1
a214 2
				RF_RowCol_t or = failedPDA->row;
				RF_RowCol_t oc = failedPDA->col;
d217 2
a218 3
				if (layoutPtr->map->flags &
				    RF_DISTRIBUTE_SPARE) {
					/* Redirect to dist spare space. */
d222 8
a229 20
						/* Parity has failed. */
						(layoutPtr->map->MapParity)
						    (raidPtr,
						     failedPDA->raidAddress,
						     &failedPDA->row,
						     &failedPDA->col,
						     &failedPDA->startSector,
						     RF_REMAP);

						if (asmap->parityInfo->next) {
							/*
							 * Redir 2nd component,
							 * if any.
							 */
							RF_PhysDiskAddr_t *p =
							    asmap
							     ->parityInfo->next;
							RF_SectorNum_t SUoffs =
							    p->startSector %
						layoutPtr->sectorsPerStripeUnit;
d232 4
a235 10
							/*
							 * Cheating:
							 * startSector is not
							 * really a RAID
							 * address.
							 */
							p->startSector =
					rf_RaidAddressOfPrevStripeUnitBoundary(
					    layoutPtr, failedPDA->startSector) +
							    SUoffs;
d238 3
a240 7
						if (asmap->parityInfo->next &&
						    failedPDA ==
						    asmap->parityInfo->next) {
							/*
							 * Should never happen.
							 */
							RF_ASSERT(0);
d242 5
a246 8
							/* Data has failed. */
							(layoutPtr->map
							 ->MapSector) (raidPtr,
							 failedPDA->raidAddress,
							    &failedPDA->row,
							    &failedPDA->col,
							&failedPDA->startSector,
							    RF_REMAP);
d249 2
a250 2
				} else {
					/* Redirect to dedicated spare space. */
d252 2
a253 4
					failedPDA->row =
					    raidPtr->Disks[frow][fcol].spareRow;
					failedPDA->col =
					    raidPtr->Disks[frow][fcol].spareCol;
d255 1
a255 2
					/*
					 * The parity may have two distinct
d257 1
a257 2
					 * to be redirected.
					 */
d259 8
a266 23
						if (failedPDA ==
						    asmap->parityInfo) {
							failedPDA->next->row =
							    failedPDA->row;
							failedPDA->next->col =
							    failedPDA->col;
						} else {
							if (failedPDA ==
							    asmap->parityInfo
							     ->next) {
								/*
								 * Paranoid:
								 * Should never
								 * occur.
								 */
								asmap
								 ->parityInfo
								 ->row =
								 failedPDA->row;
								asmap
								 ->parityInfo
								 ->col =
								 failedPDA->col;
a267 1
						}
d274 5
a278 6
					printf("raid%d: Redirected type '%c'"
					       " r %d c %d o %ld -> r %d c %d"
					       " o %ld\n", raidPtr->raidid,
					       type, or, oc, (long) oo,
					       failedPDA->row, failedPDA->col,
					       (long) failedPDA->startSector);
d280 1
a280 2
				asmap->numDataFailed = asmap->numParityFailed
				                     = 0;
d283 4
a286 6
	/*
	 * All DAGs begin/end with block/unblock node. Therefore, hdrSucc &
	 * termAnt counts should always be 1. Also, these counts should not be
	 * visible outside DAG creation routines - manipulating the counts
	 * here should be removed.
	 */
d289 1
a289 2
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateFaultFreeReadDAG;
d291 1
a291 2
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateRaidFiveDegradedReadDAG;
d293 3
a295 2
		/*
		 * If mirroring, always use large writes. If the access
d297 1
a297 1
		 * write. If the stripe contains a failure but the access
d302 1
a302 2
		 * single-stripe-unit updates to use just one disk.
		 */
d305 3
a307 7
			    (((asmap->numStripeUnitsAccessed <=
			       (layoutPtr->numDataCol / 2)) &&
			      (layoutPtr->numDataCol != 1)) ||
			     (asmap->parityInfo->next != NULL) ||
			     rf_CheckStripeForFailures(raidPtr, asmap))) {
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateSmallWriteDAG;
d309 1
a309 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateLargeWriteDAG;
d312 1
a312 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateNonRedundantWriteDAG;
d314 1
a314 3
				if (asmap->numStripeUnitsAccessed != 1 &&
				    failedPDA->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
d317 1
a317 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_CreateDegradedWriteDAG;
@


1.3.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d32 1
a32 1
 * rf_raid5.c -- Implements RAID Level 5.
d50 9
a58 10
	RF_RowCol_t **stripeIdentifier;	/*
					 * Filled in at config time and used
					 * by IdentifyStripe.
					 */
} RF_Raid5ConfigInfo_t;


int
rf_ConfigureRAID5(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d64 2
a65 3
	/* Create a RAID level 5 configuration structure. */
	RF_MallocAndAdd(info, sizeof(RF_Raid5ConfigInfo_t),
	    (RF_Raid5ConfigInfo_t *), raidPtr->cleanupList);
d72 3
a74 6
	/*
	 * The stripe identifier must identify the disks in each stripe, IN
	 * THE ORDER THAT THEY APPEAR IN THE STRIPE.
	 */
	info->stripeIdentifier = rf_make_2d_array(raidPtr->numCol,
	    raidPtr->numCol, raidPtr->cleanupList);
d80 1
a80 2
			info->stripeIdentifier[i][j] = (startdisk + j) %
			    raidPtr->numCol;
d86 1
a86 1
	/* Fill in the remaining layout parameters. */
d88 1
a88 2
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
d90 1
a90 2
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
d94 1
a94 2
	raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d99 2
a100 2
int
rf_GetDefaultNumFloatingReconBuffersRAID5(RF_Raid_t *raidPtr)
d105 2
a106 2
RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitRAID5(RF_Raid_t *raidPtr)
a109 1

d111 3
a113 3
/* Not currently used. */
int
rf_ShutdownRAID5(RF_Raid_t *raidPtr)
d119 8
a126 3
void
rf_MapSectorRAID5(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d131 1
a131 2
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d135 8
a142 3
void
rf_MapParityRAID5(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d147 2
a148 4
	*col = raidPtr->Layout.numDataCol -
	    (SUID / raidPtr->Layout.numDataCol) % raidPtr->numCol;
	*diskSector = (SUID / (raidPtr->Layout.numDataCol)) *
	    raidPtr->Layout.sectorsPerStripeUnit +
d152 6
a157 3
void
rf_IdentifyStripeRAID5(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
d159 2
a160 4
	RF_StripeNum_t stripeID =
	    rf_RaidAddressToStripeID(&raidPtr->Layout, addr);
	RF_Raid5ConfigInfo_t *info =
	    (RF_Raid5ConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d166 6
a171 3
void
rf_MapSIDToPSIDRAID5(RF_RaidLayout_t *layoutPtr, RF_StripeNum_t stripeID,
    RF_StripeNum_t *psID, RF_ReconUnitNum_t *which_ru)
d176 1
a176 4


/*
 * Select an algorithm for performing an access.  Returns two pointers,
d180 6
a185 3
void
rf_RaidFiveDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmap, RF_VoidFuncPtr *createFunc)
d191 1
a191 1
	int prior_recon;
d196 1
a196 2
		RF_ERRORMSG("Multiple disks failed in a single group !"
		            "  Aborting I/O operation.\n");
d202 1
a202 2
			/*
			 * If under recon & already reconstructed, redirect
d204 1
a204 2
			 * failure indication.
			 */
d211 2
a212 3
			    rf_CheckRUReconstructed(raidPtr
			     ->reconControl[frow]->reconMap,
			     failedPDA->startSector) : 0);
d214 1
a214 2
				RF_RowCol_t or = failedPDA->row;
				RF_RowCol_t oc = failedPDA->col;
d217 2
a218 3
				if (layoutPtr->map->flags &
				    RF_DISTRIBUTE_SPARE) {
					/* Redirect to dist spare space. */
d222 8
a229 20
						/* Parity has failed. */
						(layoutPtr->map->MapParity)
						    (raidPtr,
						     failedPDA->raidAddress,
						     &failedPDA->row,
						     &failedPDA->col,
						     &failedPDA->startSector,
						     RF_REMAP);

						if (asmap->parityInfo->next) {
							/*
							 * Redir 2nd component,
							 * if any.
							 */
							RF_PhysDiskAddr_t *p =
							    asmap
							     ->parityInfo->next;
							RF_SectorNum_t SUoffs =
							    p->startSector %
						layoutPtr->sectorsPerStripeUnit;
d232 4
a235 10
							/*
							 * Cheating:
							 * startSector is not
							 * really a RAID
							 * address.
							 */
							p->startSector =
					rf_RaidAddressOfPrevStripeUnitBoundary(
					    layoutPtr, failedPDA->startSector) +
							    SUoffs;
d238 3
a240 7
						if (asmap->parityInfo->next &&
						    failedPDA ==
						    asmap->parityInfo->next) {
							/*
							 * Should never happen.
							 */
							RF_ASSERT(0);
d242 5
a246 8
							/* Data has failed. */
							(layoutPtr->map
							 ->MapSector) (raidPtr,
							 failedPDA->raidAddress,
							    &failedPDA->row,
							    &failedPDA->col,
							&failedPDA->startSector,
							    RF_REMAP);
d249 2
a250 2
				} else {
					/* Redirect to dedicated spare space. */
d252 2
a253 4
					failedPDA->row =
					    raidPtr->Disks[frow][fcol].spareRow;
					failedPDA->col =
					    raidPtr->Disks[frow][fcol].spareCol;
d255 1
a255 2
					/*
					 * The parity may have two distinct
d257 1
a257 2
					 * to be redirected.
					 */
d259 8
a266 23
						if (failedPDA ==
						    asmap->parityInfo) {
							failedPDA->next->row =
							    failedPDA->row;
							failedPDA->next->col =
							    failedPDA->col;
						} else {
							if (failedPDA ==
							    asmap->parityInfo
							     ->next) {
								/*
								 * Paranoid:
								 * Should never
								 * occur.
								 */
								asmap
								 ->parityInfo
								 ->row =
								 failedPDA->row;
								asmap
								 ->parityInfo
								 ->col =
								 failedPDA->col;
a267 1
						}
d274 5
a278 6
					printf("raid%d: Redirected type '%c'"
					       " r %d c %d o %ld -> r %d c %d"
					       " o %ld\n", raidPtr->raidid,
					       type, or, oc, (long) oo,
					       failedPDA->row, failedPDA->col,
					       (long) failedPDA->startSector);
d280 1
a280 2
				asmap->numDataFailed = asmap->numParityFailed
				                     = 0;
d283 4
a286 6
	/*
	 * All DAGs begin/end with block/unblock node. Therefore, hdrSucc &
	 * termAnt counts should always be 1. Also, these counts should not be
	 * visible outside DAG creation routines - manipulating the counts
	 * here should be removed.
	 */
d289 1
a289 2
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateFaultFreeReadDAG;
d291 1
a291 2
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateRaidFiveDegradedReadDAG;
d293 3
a295 2
		/*
		 * If mirroring, always use large writes. If the access
d297 1
a297 1
		 * write. If the stripe contains a failure but the access
d302 1
a302 2
		 * single-stripe-unit updates to use just one disk.
		 */
d305 3
a307 7
			    (((asmap->numStripeUnitsAccessed <=
			       (layoutPtr->numDataCol / 2)) &&
			      (layoutPtr->numDataCol != 1)) ||
			     (asmap->parityInfo->next != NULL) ||
			     rf_CheckStripeForFailures(raidPtr, asmap))) {
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateSmallWriteDAG;
d309 1
a309 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateLargeWriteDAG;
d312 1
a312 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_CreateNonRedundantWriteDAG;
d314 1
a314 3
				if (asmap->numStripeUnitsAccessed != 1 &&
				    failedPDA->numSector !=
				    layoutPtr->sectorsPerStripeUnit)
d317 1
a317 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_CreateDegradedWriteDAG;
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_raid5.c,v 1.1 1999/01/11 14:29:43 niklas Exp $	*/
/*	$NetBSD: rf_raid5.c,v 1.3 1999/02/05 00:06:16 oster Exp $	*/
a44 1
#include "rf_threadid.h"
a191 1
	int     tid;
d274 4
a277 3
					rf_get_threadid(tid);
					printf("[%d] Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\n",
					    tid, type, or, oc, (long) oo, failedPDA->row, failedPDA->col,
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_raid5.c,v 1.1 1998/11/13 04:20:33 oster Exp $	*/
/*	$NetBSD: rf_raid5.c,v 1.1 1998/11/13 04:20:33 oster Exp $	*/
a35 97
/*
 * :  
 * Log: rf_raid5.c,v 
 * Revision 1.26  1996/11/05 21:10:40  jimz
 * failed pda generalization
 *
 * Revision 1.25  1996/07/31  16:56:18  jimz
 * dataBytesPerStripe, sectorsPerDisk init arch-indep.
 *
 * Revision 1.24  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.23  1996/07/13  00:00:59  jimz
 * sanitized generalized reconstruction architecture
 * cleaned up head sep, rbuf problems
 *
 * Revision 1.22  1996/06/11  08:54:27  jimz
 * improved error-checking at configuration time
 *
 * Revision 1.21  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.20  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.19  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.18  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.17  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.16  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.15  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.14  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.13  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.12  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.11  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.10  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.9  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.8  1996/05/03  19:38:58  wvcii
 * moved dag creation routines to dag library
 *
 * Revision 1.7  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.6  1995/12/06  15:04:28  root
 * added copyright info
 *
 * Revision 1.5  1995/11/17  18:59:41  wvcii
 * added prototyping to MapParity
 *
 * Revision 1.4  1995/06/23  13:38:21  robby
 * updeated to prototypes in rf_layout.h
 *
 */

d51 35
a85 2
  RF_RowCol_t  **stripeIdentifier;    /* filled in at config time and used by IdentifyStripe */
} RF_Raid5ConfigInfo_t;
d87 7
a93 38
int rf_ConfigureRAID5(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
{
  RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
  RF_Raid5ConfigInfo_t *info;
  RF_RowCol_t i, j, startdisk;
  
  /* create a RAID level 5 configuration structure */
  RF_MallocAndAdd(info, sizeof(RF_Raid5ConfigInfo_t), (RF_Raid5ConfigInfo_t *), raidPtr->cleanupList);
  if (info == NULL)
    return(ENOMEM);
  layoutPtr->layoutSpecificInfo = (void *) info;

  RF_ASSERT(raidPtr->numRow == 1);

  /* the stripe identifier must identify the disks in each stripe,
   * IN THE ORDER THAT THEY APPEAR IN THE STRIPE.
   */
  info->stripeIdentifier = rf_make_2d_array(raidPtr->numCol, raidPtr->numCol, raidPtr->cleanupList);
  if (info->stripeIdentifier == NULL)
    return(ENOMEM);
  startdisk = 0;
  for (i=0; i<raidPtr->numCol; i++) {
    for (j=0; j<raidPtr->numCol; j++) {
      info->stripeIdentifier[i][j] = (startdisk + j) % raidPtr->numCol;
    }
    if ((--startdisk) < 0) startdisk = raidPtr->numCol-1;
  }

  /* fill in the remaining layout parameters */
  layoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;
  layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;
  layoutPtr->numDataCol = raidPtr->numCol-1;
  layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
  layoutPtr->numParityCol = 1;
  layoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;
d95 1
a95 1
  raidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d97 1
a97 1
  return(0);
d100 2
a101 1
int rf_GetDefaultNumFloatingReconBuffersRAID5(RF_Raid_t *raidPtr)
d103 1
a103 1
  return(20);
d106 2
a107 1
RF_HeadSepLimit_t rf_GetDefaultHeadSepLimitRAID5(RF_Raid_t *raidPtr)
d109 1
a109 1
  return(10);
a110 1

d113 2
a114 1
int rf_ShutdownRAID5(RF_Raid_t *raidPtr)
d116 1
a116 1
	return(0);
d120 8
a127 7
void rf_MapSectorRAID5(
  RF_Raid_t         *raidPtr,
  RF_RaidAddr_t      raidSector,
  RF_RowCol_t       *row,
  RF_RowCol_t       *col,
  RF_SectorNum_t    *diskSector,
  int                remap)
d129 5
a133 5
  RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
  *row = 0;
  *col = (SUID % raidPtr->numCol);
  *diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d136 8
a143 7
void rf_MapParityRAID5(
  RF_Raid_t       *raidPtr,
  RF_RaidAddr_t    raidSector,
  RF_RowCol_t     *row,
  RF_RowCol_t     *col,
  RF_SectorNum_t  *diskSector,
  int              remap)
d145 6
a150 6
  RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
  
  *row = 0;
  *col = raidPtr->Layout.numDataCol-(SUID/raidPtr->Layout.numDataCol)%raidPtr->numCol;
  *diskSector =(SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +
    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d153 6
a158 5
void rf_IdentifyStripeRAID5(
  RF_Raid_t        *raidPtr,
  RF_RaidAddr_t     addr,
  RF_RowCol_t     **diskids,
  RF_RowCol_t      *outRow)
d160 2
a161 2
  RF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, addr);
  RF_Raid5ConfigInfo_t *info = (RF_Raid5ConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d163 2
a164 2
  *outRow = 0;
  *diskids = info->stripeIdentifier[ stripeID % raidPtr->numCol ];
d167 6
a172 5
void rf_MapSIDToPSIDRAID5(
  RF_RaidLayout_t    *layoutPtr,
  RF_StripeNum_t      stripeID,
  RF_StripeNum_t     *psID,
  RF_ReconUnitNum_t  *which_ru)
d174 2
a175 2
  *which_ru = 0;
  *psID = stripeID;
a176 1

d181 6
a186 5
void rf_RaidFiveDagSelect(
  RF_Raid_t             *raidPtr,
  RF_IoType_t            type,
  RF_AccessStripeMap_t  *asmap,
  RF_VoidFuncPtr        *createFunc)
d188 105
a292 48
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  RF_PhysDiskAddr_t *failedPDA=NULL;
  RF_RowCol_t frow, fcol;
  RF_RowStatus_t rstat;
  int prior_recon;
  int tid;

  RF_ASSERT(RF_IO_IS_R_OR_W(type));

  if (asmap->numDataFailed + asmap->numParityFailed > 1) {
    RF_ERRORMSG("Multiple disks failed in a single group!  Aborting I/O operation.\n");
    /* *infoFunc = */ *createFunc = NULL;
    return;
  } else if (asmap->numDataFailed + asmap->numParityFailed == 1) {
    
    /* if under recon & already reconstructed, redirect the access to the spare drive 
     * and eliminate the failure indication 
     */
    failedPDA = asmap->failedPDAs[0];
    frow = failedPDA->row; fcol = failedPDA->col;
    rstat = raidPtr->status[failedPDA->row];
    prior_recon = (rstat == rf_rs_reconfigured) || (
      (rstat == rf_rs_reconstructing) ?
      rf_CheckRUReconstructed(raidPtr->reconControl[frow]->reconMap, failedPDA->startSector) : 0
      );
    if (prior_recon) {
      RF_RowCol_t or = failedPDA->row,oc=failedPDA->col;
      RF_SectorNum_t oo=failedPDA->startSector;

      if (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {         /* redirect to dist spare space */

	if (failedPDA == asmap->parityInfo) {

	  /* parity has failed */
	  (layoutPtr->map->MapParity)(raidPtr, failedPDA->raidAddress, &failedPDA->row, 
				      &failedPDA->col, &failedPDA->startSector, RF_REMAP);

	  if (asmap->parityInfo->next) {				/* redir 2nd component, if any */
	    RF_PhysDiskAddr_t *p = asmap->parityInfo->next;
	    RF_SectorNum_t SUoffs = p->startSector % layoutPtr->sectorsPerStripeUnit;
	    p->row = failedPDA->row;
	    p->col = failedPDA->col;
	    p->startSector = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->startSector) +
			     SUoffs;  	/* cheating:  startSector is not really a RAID address */
	  }

	} else if (asmap->parityInfo->next && failedPDA == asmap->parityInfo->next) {
	  RF_ASSERT(0);  		/* should not ever happen */
a294 5
	  /* data has failed */
	  (layoutPtr->map->MapSector)(raidPtr, failedPDA->raidAddress, &failedPDA->row, 
				      &failedPDA->col, &failedPDA->startSector, RF_REMAP);

	}
d296 24
a319 14
      } else {                                                 /* redirect to dedicated spare space */
	
	failedPDA->row = raidPtr->Disks[frow][fcol].spareRow;
	failedPDA->col = raidPtr->Disks[frow][fcol].spareCol;
	
	/* the parity may have two distinct components, both of which may need to be redirected */
	if (asmap->parityInfo->next) {
	  if (failedPDA == asmap->parityInfo) {
	    failedPDA->next->row = failedPDA->row;
	    failedPDA->next->col = failedPDA->col;
	  } else if (failedPDA == asmap->parityInfo->next) {    /* paranoid:  should never occur */
	    asmap->parityInfo->row = failedPDA->row;
	    asmap->parityInfo->col = failedPDA->col;
	  }
a320 55
      }

      RF_ASSERT(failedPDA->col != -1);
       
      if (rf_dagDebug || rf_mapDebug) {
	rf_get_threadid(tid);
	printf("[%d] Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\n",
	       tid,type,or,oc,(long)oo,failedPDA->row,failedPDA->col,
	       (long)failedPDA->startSector);
      }
      
      asmap->numDataFailed = asmap->numParityFailed = 0;
    }

  }

  /* all dags begin/end with block/unblock node
   * therefore, hdrSucc & termAnt counts should always be 1
   * also, these counts should not be visible outside dag creation routines - 
   * manipulating the counts here should be removed */
  if (type == RF_IO_TYPE_READ) {
    if (asmap->numDataFailed == 0)
      *createFunc = (RF_VoidFuncPtr)rf_CreateFaultFreeReadDAG;
    else
      *createFunc = (RF_VoidFuncPtr)rf_CreateRaidFiveDegradedReadDAG;
  } else {

    
    /* if mirroring, always use large writes.  If the access requires two
     * distinct parity updates, always do a small write.  If the stripe
     * contains a failure but the access does not, do a small write.
     * The first conditional (numStripeUnitsAccessed <= numDataCol/2) uses a
     * less-than-or-equal rather than just a less-than because when G is 3
     * or 4, numDataCol/2 is 1, and I want single-stripe-unit updates to use
     * just one disk.
     */
    if ( (asmap->numDataFailed + asmap->numParityFailed) == 0) {
      if (rf_suppressLocksAndLargeWrites ||
	  (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol!=1)) ||
	   (asmap->parityInfo->next!=NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {
	*createFunc = (RF_VoidFuncPtr)rf_CreateSmallWriteDAG;
      } 
      else
	*createFunc = (RF_VoidFuncPtr)rf_CreateLargeWriteDAG;
    }
    else {
      if (asmap->numParityFailed == 1)
	*createFunc = (RF_VoidFuncPtr)rf_CreateNonRedundantWriteDAG;
      else
	if (asmap->numStripeUnitsAccessed != 1 && failedPDA->numSector != layoutPtr->sectorsPerStripeUnit)
	  *createFunc = NULL;
	else
	  *createFunc = (RF_VoidFuncPtr)rf_CreateDegradedWriteDAG;
    }
  }
@

