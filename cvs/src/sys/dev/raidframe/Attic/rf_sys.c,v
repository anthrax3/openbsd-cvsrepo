head	1.4;
access;
symbols
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	UBC_SYNC_A:1.4
	UBC_SYNC_B:1.4
	SMP:1.4.0.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.4
date	99.08.04.13.10.55;	author peter;	state dead;
branches;
next	1.3;

1.3
date	99.08.03.13.56.38;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.29;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.53;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.4
log
@* remove redundant rf_ccmn.h

* remove init call to rf_ConfigureEtimer() and rf_sys.c in which it is the
  only function. update conf/files to reflect this.

* update sources to make sure _KERNEL is used not KERNEL

* change rf_etimer.h to protect macros an include of sys/kernel.h with
  a check for _KERNEL - let raidctl compile again.
@
text
@/*	$OpenBSD: rf_sys.c,v 1.3 1999/08/03 13:56:38 peter Exp $	*/
/*	$NetBSD: rf_sys.c,v 1.3 1999/02/05 00:06:18 oster Exp $	*/
/*
 * rf_sys.c
 *
 * Jim Zelenka, CMU/SCS, 14 June 1996
 */
/*
 * Copyright (c) 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include "rf_types.h"
#include "rf_sys.h"
#include <sys/param.h>
#include <sys/time.h>
#include "rf_etimer.h"
#include "rf_general.h"
#include "rf_threadstuff.h"

extern struct rpb *rpb;


int 
rf_ConfigureEtimer(listp)
	RF_ShutdownList_t **listp;
{
	return (0);
}
@


1.3
log
@* rf_reconstruct.c: adopt nilkas' suggestion regard statics and
__inline__ - this is a proof of concept and will cover the raidframe
source as a whole over coming updates. Update namespace of function to
prefix with rf_ - comments again welcome.

* overall: rework the macros in rf_etimer.h and the resultant changes
to their use to count microseconds and not clock ticks. Restore the code
in rf_revent.c to a similar strcuture to before the previous commit,
and use the system timers to govern resource usage.

Tested with local i386/IDE and the reconstruction of a disk in my
array - performance has improved for reconstruction at no noticable
CPU cost.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_sys.c,v 1.2 1999/02/16 00:03:29 niklas Exp $	*/
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_sys.c,v 1.1 1999/01/11 14:29:53 niklas Exp $	*/
a44 5
/* timer stuff */
long    rf_timer_max_val;
long    rf_timer_ticks_per_second;
unsigned long rf_timer_ticks_per_usec;

a49 6
	/* XXX just picking some random values to keep things happy... without
	 * these set, stuff will panic on division by zero errors!! */
	rf_timer_ticks_per_second = 233100233;
	rf_timer_max_val = RF_DEF_TIMER_MAX_VAL;
	rf_timer_ticks_per_usec = rf_timer_ticks_per_second / 1000000;

@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_sys.c,v 1.1 1998/11/13 04:20:35 oster Exp $	*/
/*	$NetBSD: rf_sys.c,v 1.1 1998/11/13 04:20:35 oster Exp $	*/
a34 4
#ifdef _KERNEL
#define KERNEL
#endif

a36 7
#ifndef KERNEL
#include <errno.h>
#include <fcntl.h>
#include <nlist.h>
#include <stdio.h>
#include <unistd.h>
#endif /* !KERNEL */
a37 3
#if !defined(sun) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(LINUX) && (!defined(MACH) || defined(__osf__))
#include <sys/sysinfo.h>
#endif /* !sun && !__NetBSD__ && !__OpenBSD__ && !LINUX && (!MACH || __osf__) */
a38 4
#ifdef __osf__
#include <machine/rpb.h>
#include <machine/hal/hal_sysinfo.h>
#endif /* __osf__ */
a42 1
#ifdef KERNEL
a43 1
#endif /* KERNEL */
d46 2
a47 10
#ifdef __alpha
long rf_timer_max_val;
long rf_timer_ticks_per_second;
unsigned long rf_timer_ticks_per_usec;
#endif /* __alpha */


#if defined(__NetBSD__) || defined(__OpenBSD__)
long rf_timer_max_val;
long rf_timer_ticks_per_second;
a48 12
#endif /* __NetBSD__ || __OpenBSD__ */

#if !defined(KERNEL) && !defined(SIMULATE) && (RF_UTILITY == 0)
pthread_attr_t raidframe_attr_default;

int rf_thread_create(
  RF_Thread_t      *thread,
  pthread_attr_t    attr,
  void            (*func)(),
  RF_ThreadArg_t    arg)
{
  int rc;
a49 16
#ifdef __osf__
  rc = pthread_create(thread, attr, (pthread_startroutine_t)func, arg); 
#endif /* __osf__ */
#ifdef AIX
  rc = pthread_create(thread, &attr, (void *(*)(void *))func, arg); 
#endif /* AIX */
 if (rc)
    return(errno);
  rc = pthread_detach(thread);
  if (rc) {
    /* don't return error, because the thread exists, and must be cleaned up */
    RF_ERRORMSG1("RAIDFRAME WARNING: failed detaching thread %lx\n", thread);
  }
  return(0);
}
#endif /* !KERNEL && !SIMULATE && (RF_UTILITY == 0) */
d51 3
a53 2
#if defined(__osf__) && !defined(KERNEL)
int rf_get_cpu_ticks_per_sec(long *ticksp)
d55 5
a59 147
  char *kmemdevname, buf[sizeof(struct rpb)+8];
  char *memdevname, kernel_name[MAXPATHLEN+1];
  struct nlist nl[2], *np;
  unsigned long rpb_addr;
  int kfd, rc, fd, bad;
  struct rpb rpb;
  off_t off;

  kmemdevname = "/dev/kmem";
  memdevname = "/dev/mem";

  np = &nl[0];
  bzero((char *)np, sizeof(nl));
  nl[0].n_name = "pmap_physhwrpb";
  nl[1].n_name = NULL;

  bad = 0;

  /* get running kernel name */
  bzero(kernel_name, MAXPATHLEN+1);
  kernel_name[0] = '/';
  rc = getsysinfo(GSI_BOOTEDFILE, &kernel_name[1], MAXPATHLEN, 0, 0);
  if (rc != 1) {
    RF_ERRORMSG("RAIDFRAME: cannot get booted kernel name\n");
    if (errno)
      return(errno);
    else
      return(EIO);
  }

  rc = nlist(kernel_name, np);
  if (rc) {
    RF_ERRORMSG1("RAIDFRAME: cannot nlist %s\n", kernel_name);
    return(EIO);
  }

  if (np->n_type == 0) {
    RF_ERRORMSG1("RAIDFRAME: cannot usefully nlist %s\n", kernel_name);
    return(EIO);
  }

  kfd = open(kmemdevname, O_RDONLY);
  if (kfd < 0) {
    perror(kmemdevname);
    return(errno);
  }
  fd = open(memdevname, O_RDONLY);
  if (fd < 0) {
    perror(kmemdevname);
    return(errno);
  }

  /*
   * pmap_physhwrpb is a variable in the kernel containing the physical
   * address of the hardware RPB. We'll just find that variable and
   * read it, then use that as a physical memory address to read the
   * rpb itself.
   */

  off = lseek(kfd, np->n_value, SEEK_SET);
  if (off != np->n_value) {
    RF_ERRORMSG("RAIDFRAME: cannot seek to address of hwrpb addr\n");
    return(EIO);
  }

  rc = read(kfd, &rpb_addr, sizeof(rpb_addr));
  if (rc != sizeof(rpb_addr)) {
    RF_ERRORMSG("RAIDFRAME: cannot read address of hwrpb addr\n");
    if (rc < 0)
      bad = errno;
    bad = EIO;
    goto isbad;
  }

  off = lseek(fd, rpb_addr, SEEK_SET);
  if (off != rpb_addr) {
    RF_ERRORMSG("RAIDFRAME: cannot seek to rpb addr\n");
    bad = EIO;
    goto isbad;
  }

  rc = read(fd, &rpb, sizeof(rpb));
  if (rc != sizeof(rpb)) {
    RF_ERRORMSG1("RAIDFRAME: cannot read rpb (rc=%d)\n", rc);
    if (rc < 0)
      bad = errno;
    bad = EIO;
    goto isbad;
  }

  /*
   * One extra sanity check: the RPB is self-identifying.
   * This field is guaranteed to have the value
   * 0x0000004250525748, always.
   */
  if (rpb.rpb_string != 0x0000004250525748) {
    bad = EIO;
    goto isbad;
  }

isbad:
  if (bad) {
    RF_ERRORMSG("ERROR: rpb failed validation\n");
    RF_ERRORMSG1("RAIDFRAME: perhaps %s has changed since booting?\n",
      kernel_name);
    return(bad);
  }

  *ticksp = rpb.rpb_counter;

  close(kfd);
  close(fd);

  return(0);
}
#endif /* __osf__ && !KERNEL */

int rf_ConfigureEtimer(listp)
  RF_ShutdownList_t  **listp;
{
#ifdef __osf__
  int rc;

#ifdef KERNEL
  rf_timer_ticks_per_second = rpb->rpb_counter;
#else /* KERNEL */
  rc = rf_get_cpu_ticks_per_sec(&rf_timer_ticks_per_second);
  if (rc)
    return(rc);
#endif /* KERNEL */
  rf_timer_max_val = RF_DEF_TIMER_MAX_VAL;
  rf_timer_ticks_per_usec = rf_timer_ticks_per_second/1000000;
#endif /* __osf__ */
#if defined(NETBSD_ALPHA) || defined(OPENBSD_ALPHA)
  /*
   * XXX cgd fix this
   */
  rf_timer_ticks_per_second = 233100233;
  rf_timer_max_val = RF_DEF_TIMER_MAX_VAL;
  rf_timer_ticks_per_usec = rf_timer_ticks_per_second/1000000;
#endif /* NETBSD_ALPHA || OPENBSD_ALPHA */
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
  /* XXX just picking some random values to keep things happy... without these
     set, stuff will panic on division by zero errors!! */
  rf_timer_ticks_per_second = 233100233;
  rf_timer_max_val = RF_DEF_TIMER_MAX_VAL;
  rf_timer_ticks_per_usec = rf_timer_ticks_per_second/1000000;
d61 1
a61 2
#endif
  return(0);
@

