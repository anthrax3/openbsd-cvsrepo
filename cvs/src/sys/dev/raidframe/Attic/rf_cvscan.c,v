head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.34
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.32
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.28
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.16
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.14
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.12
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.10
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.6;

1.6
date	2011.06.21.16.46.00;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.07.14.50.20;	author peter;	state Exp;
branches
	1.4.2.1
	1.4.12.1;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.05;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.4.12.1
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_cvscan.c,v 1.6 2011/06/21 16:46:00 tedu Exp $	*/
/*	$NetBSD: rf_cvscan.c,v 1.5 1999/08/13 03:41:53 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 *
 * cvscan.c --  prioritized cvscan disk queueing code.
 *
 * Nov 9, 1994, adapted from raidSim version (MCH)
 *
 *****************************************************************************/

#include "rf_types.h"
#include "rf_alloclist.h"
#include "rf_stripelocks.h"
#include "rf_layout.h"
#include "rf_diskqueue.h"
#include "rf_cvscan.h"
#include "rf_debugMem.h"
#include "rf_general.h"

void rf_CheckCvscanState(RF_CvscanHeader_t *, char *, int);
void rf_PriorityInsert(RF_DiskQueueData_t **, RF_DiskQueueData_t *);
void rf_ReqInsert(RF_DiskQueueData_t **, RF_DiskQueueData_t *,
	RF_CvscanArmDir_t);
RF_DiskQueueData_t *rf_ReqDequeue(RF_DiskQueueData_t **);
void rf_ReBalance(RF_CvscanHeader_t *);
void rf_Transfer(RF_DiskQueueData_t **, RF_DiskQueueData_t **);
void rf_RealEnqueue(RF_CvscanHeader_t *, RF_DiskQueueData_t *);

#define	DO_CHECK_STATE(_hdr_)	rf_CheckCvscanState((_hdr_), __FILE__, __LINE__)

#define	pri_ok(p)	(((p) == RF_IO_NORMAL_PRIORITY) ||		\
			 ((p) == RF_IO_LOW_PRIORITY))


void
rf_CheckCvscanState(RF_CvscanHeader_t *hdr, char *file, int line)
{
	long i, key;
	RF_DiskQueueData_t *tmp;

	if (hdr->left != (RF_DiskQueueData_t *) NULL)
		RF_ASSERT(hdr->left->sectorOffset < hdr->cur_block);
	for (key = hdr->cur_block, i = 0, tmp = hdr->left;
	     tmp != (RF_DiskQueueData_t *) NULL;
	     key = tmp->sectorOffset, i++, tmp = tmp->next)
		RF_ASSERT(tmp->sectorOffset <= key
		    && tmp->priority == hdr->nxt_priority && 
		    pri_ok(tmp->priority));
	RF_ASSERT(i == hdr->left_cnt);

	for (key = hdr->cur_block, i = 0, tmp = hdr->right;
	     tmp != (RF_DiskQueueData_t *) NULL;
	     key = tmp->sectorOffset, i++, tmp = tmp->next) {
		RF_ASSERT(key <= tmp->sectorOffset);
		RF_ASSERT(tmp->priority == hdr->nxt_priority);
		RF_ASSERT(pri_ok(tmp->priority));
	}
	RF_ASSERT(i == hdr->right_cnt);

	for (key = hdr->nxt_priority - 1, tmp = hdr->burner;
	     tmp != (RF_DiskQueueData_t *) NULL;
	     key = tmp->priority, tmp = tmp->next) {
		RF_ASSERT(tmp);
		RF_ASSERT(hdr);
		RF_ASSERT(pri_ok(tmp->priority));
		RF_ASSERT(key >= tmp->priority);
		RF_ASSERT(tmp->priority < hdr->nxt_priority);
	}
}


void
rf_PriorityInsert(RF_DiskQueueData_t **list_ptr, RF_DiskQueueData_t *req)
{
	/*
	 * Insert block pointed to by req into list whose first entry is
	 * pointed to by the pointer that list_ptr points to.
	 * i.e. list_ptr is a grandparent of the first entry.
	 */

	for (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&
	       (*list_ptr)->priority > req->priority;
	     list_ptr = &((*list_ptr)->next)) {
	}
	req->next = (*list_ptr);
	(*list_ptr) = req;
}


void
rf_ReqInsert(RF_DiskQueueData_t **list_ptr, RF_DiskQueueData_t *req,
    RF_CvscanArmDir_t order)
{
	/*
	 * Insert block pointed to by req into list whose first entry is
	 * pointed to by the pointer that list_ptr points to.
	 * i.e. list_ptr is a grandparent of the first entry.
	 */

	for (; (*list_ptr) != (RF_DiskQueueData_t *) NULL &&
	       ((order == rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <=
	       req->sectorOffset) || (order == rf_cvscan_LEFT &&
	       (*list_ptr)->sectorOffset > req->sectorOffset));
	     list_ptr = &((*list_ptr)->next)) {
	}
	req->next = (*list_ptr);
	(*list_ptr) = req;
}


RF_DiskQueueData_t *
rf_ReqDequeue(RF_DiskQueueData_t **list_ptr)
{
	RF_DiskQueueData_t *ret = (*list_ptr);
	if ((*list_ptr) != (RF_DiskQueueData_t *) NULL) {
		(*list_ptr) = (*list_ptr)->next;
	}
	return (ret);
}


void
rf_ReBalance(RF_CvscanHeader_t *hdr)
{
	/* DO_CHECK_STATE(hdr); */
	while (hdr->right != (RF_DiskQueueData_t *) NULL
	    && hdr->right->sectorOffset < hdr->cur_block) {
		hdr->right_cnt--;
		hdr->left_cnt++;
		rf_ReqInsert(&hdr->left, rf_ReqDequeue(&hdr->right),
		    rf_cvscan_LEFT);
	}
	/* DO_CHECK_STATE(hdr); */
}


void
rf_Transfer(RF_DiskQueueData_t **to_list_ptr, RF_DiskQueueData_t **from_list_ptr)
{
	RF_DiskQueueData_t *gp;
	for (gp = (*from_list_ptr); gp != (RF_DiskQueueData_t *) NULL;) {
		RF_DiskQueueData_t *p = gp->next;
		rf_PriorityInsert(to_list_ptr, gp);
		gp = p;
	}
	(*from_list_ptr) = (RF_DiskQueueData_t *) NULL;
}


void
rf_RealEnqueue(RF_CvscanHeader_t *hdr, RF_DiskQueueData_t *req)
{
	RF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY ||
	    req->priority == RF_IO_LOW_PRIORITY);

	DO_CHECK_STATE(hdr);
	if (hdr->left_cnt == 0 && hdr->right_cnt == 0) {
		hdr->nxt_priority = req->priority;
	}
	if (req->priority > hdr->nxt_priority) {
		/*
		 * Dump all other outstanding requests on the back burner.
		 */
		rf_Transfer(&hdr->burner, &hdr->left);
		rf_Transfer(&hdr->burner, &hdr->right);
		hdr->left_cnt = 0;
		hdr->right_cnt = 0;
		hdr->nxt_priority = req->priority;
	}
	if (req->priority < hdr->nxt_priority) {
		/*
		 * Yet another low priority task !
		 */
		rf_PriorityInsert(&hdr->burner, req);
	} else {
		if (req->sectorOffset < hdr->cur_block) {
			/* This request is to the left of the current arms. */
			rf_ReqInsert(&hdr->left, req, rf_cvscan_LEFT);
			hdr->left_cnt++;
		} else {
			/* This request is to the right of the current arms. */
			rf_ReqInsert(&hdr->right, req, rf_cvscan_RIGHT);
			hdr->right_cnt++;
		}
	}
	DO_CHECK_STATE(hdr);
}


void
rf_CvscanEnqueue(void *q_in, RF_DiskQueueData_t *elem, int priority)
{
	RF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;
	rf_RealEnqueue(hdr, elem /* req */ );
}


RF_DiskQueueData_t *
rf_CvscanDequeue(void *q_in)
{
	RF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;
	long    range, i, sum_dist_left, sum_dist_right;
	RF_DiskQueueData_t *ret;
	RF_DiskQueueData_t *tmp;

	DO_CHECK_STATE(hdr);

	if (hdr->left_cnt == 0 && hdr->right_cnt == 0)
		return ((RF_DiskQueueData_t *) NULL);

	range = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt,
	    hdr->right_cnt));
	for (i = 0, tmp = hdr->left, sum_dist_left =
	     ((hdr->direction == rf_cvscan_RIGHT) ?
	      range * hdr->change_penalty : 0);
	     tmp != (RF_DiskQueueData_t *) NULL && i < range;
	     tmp = tmp->next, i++) {
		sum_dist_left += hdr->cur_block - tmp->sectorOffset;
	}
	for (i = 0, tmp = hdr->right, sum_dist_right =
	     ((hdr->direction == rf_cvscan_LEFT) ?
	      range * hdr->change_penalty : 0);
	     tmp != (RF_DiskQueueData_t *) NULL && i < range;
	     tmp = tmp->next, i++) {
		sum_dist_right += tmp->sectorOffset - hdr->cur_block;
	}

	if (hdr->right_cnt == 0 || sum_dist_left < sum_dist_right) {
		hdr->direction = rf_cvscan_LEFT;
		hdr->cur_block = hdr->left->sectorOffset + hdr->left->numSector;
		hdr->left_cnt = RF_MAX(hdr->left_cnt - 1, 0);
		tmp = hdr->left;
		ret = (rf_ReqDequeue(&hdr->left)) /*->parent*/ ;
	} else {
		hdr->direction = rf_cvscan_RIGHT;
		hdr->cur_block = hdr->right->sectorOffset +
		    hdr->right->numSector;
		hdr->right_cnt = RF_MAX(hdr->right_cnt - 1, 0);
		tmp = hdr->right;
		ret = (rf_ReqDequeue(&hdr->right)) /*->parent*/ ;
	}
	rf_ReBalance(hdr);

	if (hdr->left_cnt == 0 && hdr->right_cnt == 0
	    && hdr->burner != (RF_DiskQueueData_t *) NULL) {
		/*
		 * Restore low priority requests for next dequeue.
		 */
		RF_DiskQueueData_t *burner = hdr->burner;
		hdr->nxt_priority = burner->priority;
		while (burner != (RF_DiskQueueData_t *) NULL &&
		    burner->priority == hdr->nxt_priority) {
			RF_DiskQueueData_t *next = burner->next;
			rf_RealEnqueue(hdr, burner);
			burner = next;
		}
		hdr->burner = burner;
	}
	DO_CHECK_STATE(hdr);
	return (ret);
}


RF_DiskQueueData_t *
rf_CvscanPeek(void *q_in)
{
	RF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;
	long    range, i, sum_dist_left, sum_dist_right;
	RF_DiskQueueData_t *tmp, *headElement;

	DO_CHECK_STATE(hdr);

	if (hdr->left_cnt == 0 && hdr->right_cnt == 0)
		headElement = NULL;
	else {
		range = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt,
		    hdr->right_cnt));
		for (i = 0, tmp = hdr->left, sum_dist_left =
		     ((hdr->direction == rf_cvscan_RIGHT) ?
		      range * hdr->change_penalty : 0);
		     tmp != (RF_DiskQueueData_t *) NULL && i < range;
		     tmp = tmp->next, i++) {
			sum_dist_left += hdr->cur_block - tmp->sectorOffset;
		}
		for (i = 0, tmp = hdr->right, sum_dist_right =
		     ((hdr->direction == rf_cvscan_LEFT) ?
		      range * hdr->change_penalty : 0);
		     tmp != (RF_DiskQueueData_t *) NULL && i < range;
		     tmp = tmp->next, i++) {
			sum_dist_right += tmp->sectorOffset - hdr->cur_block;
		}

		if (hdr->right_cnt == 0 || sum_dist_left < sum_dist_right)
			headElement = hdr->left;
		else
			headElement = hdr->right;
	}
	return (headElement);
}


/*
 * CVSCAN( 1, 0 ) is Shortest Seek Time First (SSTF)
 *				lowest average response time
 * CVSCAN( 1, infinity ) is SCAN
 *				lowest response time standard deviation
 */


int
rf_CvscanConfigure(void)
{
	return (0);
}


void   *
rf_CvscanCreate(RF_SectorCount_t sectPerDisk, RF_AllocListElem_t *clList,
    RF_ShutdownList_t **listp)
{
	RF_CvscanHeader_t *hdr;
	long range = 2;		/* Currently no mechanism to change these. */
	long penalty = sectPerDisk / 5;

	RF_MallocAndAdd(hdr, sizeof(RF_CvscanHeader_t), (RF_CvscanHeader_t *),
	    clList);
	bzero(hdr, sizeof(RF_CvscanHeader_t));
	hdr->range_for_avg = RF_MAX(range, 1);
	hdr->change_penalty = RF_MAX(penalty, 0);
	hdr->direction = rf_cvscan_RIGHT;
	hdr->cur_block = 0;
	hdr->left_cnt = hdr->right_cnt = 0;
	hdr->left = hdr->right = (RF_DiskQueueData_t *) NULL;
	hdr->burner = (RF_DiskQueueData_t *) NULL;
	DO_CHECK_STATE(hdr);

	return ((void *) hdr);
}


#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
/* rf_PrintCvscanQueue is not used, so we ignore it... */
#else
void
rf_PrintCvscanQueue(RF_CvscanHeader_t *hdr)
{
	RF_DiskQueueData_t *tmp;

	printf("CVSCAN(%d,%d) at %d going %s\n",
	    (int) hdr->range_for_avg,
	    (int) hdr->change_penalty,
	    (int) hdr->cur_block,
	    (hdr->direction == rf_cvscan_LEFT) ? "LEFT" : "RIGHT");
	printf("\tLeft(%d): ", hdr->left_cnt);
	for (tmp = hdr->left; tmp != (RF_DiskQueueData_t *) NULL;
	     tmp = tmp->next)
		printf("(%d,%ld,%d) ",
		    (int) tmp->sectorOffset,
		    (long) (tmp->sectorOffset + tmp->numSector),
		    tmp->priority);
	printf("\n");
	printf("\tRight(%d): ", hdr->right_cnt);
	for (tmp = hdr->right; tmp != (RF_DiskQueueData_t *) NULL;
	     tmp = tmp->next)
		printf("(%d,%ld,%d) ",
		    (int) tmp->sectorOffset,
		    (long) (tmp->sectorOffset + tmp->numSector),
		    tmp->priority);
	printf("\n");
	printf("\tBurner: ");
	for (tmp = hdr->burner; tmp != (RF_DiskQueueData_t *) NULL;
	     tmp = tmp->next)
		printf("(%d,%ld,%d) ",
		    (int) tmp->sectorOffset,
		    (long) (tmp->sectorOffset + tmp->numSector),
		    tmp->priority);
	printf("\n");
}
#endif


/*
 * Promote reconstruction accesses for the given stripeID to normal priority.
 * Return 1 if an access was found and zero otherwise.
 * Normally, we should only have one or zero entries in the burner queue,
 * so execution time should be short.
 */
int
rf_CvscanPromote(void *q_in, RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru)
{
	RF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;
	RF_DiskQueueData_t *trailer = NULL, *tmp = hdr->burner, *tlist = NULL;
	int retval = 0;

	DO_CHECK_STATE(hdr);
	while (tmp) {		/* Handle entries at the front of the list. */
		if (tmp->parityStripeID == parityStripeID &&
		    tmp->which_ru == which_ru) {
			hdr->burner = tmp->next;
			tmp->priority = RF_IO_NORMAL_PRIORITY;
			tmp->next = tlist;
			tlist = tmp;
			tmp = hdr->burner;
		} else
			break;
	}
	if (tmp) {
		trailer = tmp;
		tmp = tmp->next;
	}
	while (tmp) {		/* Handle entries on the rest of the list. */
		if (tmp->parityStripeID == parityStripeID &&
		    tmp->which_ru == which_ru) {
			trailer->next = tmp->next;
			tmp->priority = RF_IO_NORMAL_PRIORITY;
			tmp->next = tlist;
			tlist = tmp;	/* Insert on a temp queue. */
			tmp = trailer->next;
		} else {
			trailer = tmp;
			tmp = tmp->next;
		}
	}
	while (tlist) {
		retval++;
		tmp = tlist->next;
		rf_RealEnqueue(hdr, tlist);
		tlist = tmp;
	}
	RF_ASSERT(retval == 0 || retval == 1);
	DO_CHECK_STATE((RF_CvscanHeader_t *) q_in);
	return (retval);
}
@


1.6
log
@remove stupid casts, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_cvscan.c,v 1.5 2002/12/16 07:01:03 tdeval Exp $	*/
@


1.5
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_cvscan.c,v 1.4 2000/01/07 14:50:20 peter Exp $	*/
d355 1
a355 1
	bzero((char *) hdr, sizeof(RF_CvscanHeader_t));
@


1.4
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_cvscan.c,v 1.3 1999/07/30 14:45:32 peter Exp $	*/
d3 1
d31 1
a31 1
/*******************************************************************************
d37 1
a37 1
 ******************************************************************************/
d48 13
a60 1
#define DO_CHECK_STATE(_hdr_) CheckCvscanState((_hdr_), __FILE__, __LINE__)
a61 1
#define pri_ok(p)  ( ((p) == RF_IO_NORMAL_PRIORITY) || ((p) == RF_IO_LOW_PRIORITY))
d63 2
a64 2
static void 
CheckCvscanState(RF_CvscanHeader_t * hdr, char *file, int line)
d66 1
a66 1
	long    i, key;
d72 2
a73 2
	    tmp != (RF_DiskQueueData_t *) NULL;
	    key = tmp->sectorOffset, i++, tmp = tmp->next)
d75 2
a76 1
		    && tmp->priority == hdr->nxt_priority && pri_ok(tmp->priority));
d80 2
a81 2
	    tmp != (RF_DiskQueueData_t *) NULL;
	    key = tmp->sectorOffset, i++, tmp = tmp->next) {
d89 2
a90 2
	    tmp != (RF_DiskQueueData_t *) NULL;
	    key = tmp->priority, tmp = tmp->next) {
d100 2
a101 3

static void 
PriorityInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req)
d103 5
a107 3
	/* * insert block pointed to by req in to list whose first * entry is
	 * pointed to by the pointer that list_ptr points to * ie., list_ptr
	 * is a grandparent of the first entry */
d110 2
a111 2
	    (*list_ptr)->priority > req->priority;
	    list_ptr = &((*list_ptr)->next)) {
d118 9
a126 7

static void 
ReqInsert(RF_DiskQueueData_t ** list_ptr, RF_DiskQueueData_t * req, RF_CvscanArmDir_t order)
{
	/* * insert block pointed to by req in to list whose first * entry is
	 * pointed to by the pointer that list_ptr points to * ie., list_ptr
	 * is a grandparent of the first entry */
d129 4
a132 4

	    ((order == rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <= req->sectorOffset)
		|| (order == rf_cvscan_LEFT && (*list_ptr)->sectorOffset > req->sectorOffset));
	    list_ptr = &((*list_ptr)->next)) {
d139 2
a140 3

static RF_DiskQueueData_t *
ReqDequeue(RF_DiskQueueData_t ** list_ptr)
d150 2
a151 3

static void 
ReBalance(RF_CvscanHeader_t * hdr)
d158 2
a159 1
		ReqInsert(&hdr->left, ReqDequeue(&hdr->right), rf_cvscan_LEFT);
d165 2
a166 3

static void 
Transfer(RF_DiskQueueData_t ** to_list_ptr, RF_DiskQueueData_t ** from_list_ptr)
d171 1
a171 1
		PriorityInsert(to_list_ptr, gp);
d178 2
a179 3

static void 
RealEnqueue(RF_CvscanHeader_t * hdr, RF_DiskQueueData_t * req)
d181 2
a182 1
	RF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY || req->priority == RF_IO_LOW_PRIORITY);
d190 4
a193 4
		** dump all other outstanding requests on the back burner
		*/
		Transfer(&hdr->burner, &hdr->left);
		Transfer(&hdr->burner, &hdr->right);
d200 3
a202 3
		** yet another low priority task!
		*/
		PriorityInsert(&hdr->burner, req);
d205 2
a206 2
			/* this request is to the left of the current arms */
			ReqInsert(&hdr->left, req, rf_cvscan_LEFT);
d209 2
a210 2
			/* this request is to the right of the current arms */
			ReqInsert(&hdr->right, req, rf_cvscan_RIGHT);
d218 2
a219 3

void 
rf_CvscanEnqueue(void *q_in, RF_DiskQueueData_t * elem, int priority)
d222 1
a222 1
	RealEnqueue(hdr, elem /* req */ );
a225 1

d239 2
a240 1
	range = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt, hdr->right_cnt));
d242 4
a245 3
	    ((hdr->direction == rf_cvscan_RIGHT) ? range * hdr->change_penalty : 0);
	    tmp != (RF_DiskQueueData_t *) NULL && i < range;
	    tmp = tmp->next, i++) {
d249 4
a252 3
	    ((hdr->direction == rf_cvscan_LEFT) ? range * hdr->change_penalty : 0);
	    tmp != (RF_DiskQueueData_t *) NULL && i < range;
	    tmp = tmp->next, i++) {
d261 1
a261 1
		ret = (ReqDequeue(&hdr->left)) /*->parent*/ ;
d264 2
a265 1
		hdr->cur_block = hdr->right->sectorOffset + hdr->right->numSector;
d268 1
a268 1
		ret = (ReqDequeue(&hdr->right)) /*->parent*/ ;
d270 1
a270 1
	ReBalance(hdr);
d275 2
a276 2
		** restore low priority requests for next dequeue
		*/
d279 2
a280 2
		while (burner != (RF_DiskQueueData_t *) NULL
		    && burner->priority == hdr->nxt_priority) {
d282 1
a282 1
			RealEnqueue(hdr, burner);
a291 1

d304 2
a305 1
		range = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt, hdr->right_cnt));
d307 4
a310 3
		    ((hdr->direction == rf_cvscan_RIGHT) ? range * hdr->change_penalty : 0);
		    tmp != (RF_DiskQueueData_t *) NULL && i < range;
		    tmp = tmp->next, i++) {
d314 4
a317 3
		    ((hdr->direction == rf_cvscan_LEFT) ? range * hdr->change_penalty : 0);
		    tmp != (RF_DiskQueueData_t *) NULL && i < range;
		    tmp = tmp->next, i++) {
a329 1

d331 5
a335 5
** CVSCAN( 1, 0 ) is Shortest Seek Time First (SSTF)
**				lowest average response time
** CVSCAN( 1, infinity ) is SCAN
**				lowest response time standard deviation
*/
d338 2
a339 2
int 
rf_CvscanConfigure()
a344 1

d346 2
a347 3
rf_CvscanCreate(RF_SectorCount_t sectPerDisk,
    RF_AllocListElem_t * clList,
    RF_ShutdownList_t ** listp)
d350 2
a351 2
	long    range = 2;	/* Currently no mechanism to change these */
	long    penalty = sectPerDisk / 5;
d353 2
a354 1
	RF_MallocAndAdd(hdr, sizeof(RF_CvscanHeader_t), (RF_CvscanHeader_t *), clList);
d370 1
a370 1
/* PrintCvscanQueue is not used, so we ignore it... */
d372 2
a373 2
static void 
PrintCvscanQueue(RF_CvscanHeader_t * hdr)
d383 2
a384 1
	for (tmp = hdr->left; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)
d391 2
a392 1
	for (tmp = hdr->right; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)
d399 2
a400 1
	for (tmp = hdr->burner; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)
d410 5
a414 4
/* promotes reconstruction accesses for the given stripeID to normal priority.
 * returns 1 if an access was found and zero otherwise.  Normally, we should
 * only have one or zero entries in the burner queue, so execution time should
 * be short.
d416 3
a418 2
int 
rf_CvscanPromote(void *q_in, RF_StripeNum_t parityStripeID, RF_ReconUnitNum_t which_ru)
d422 1
a422 1
	int     retval = 0;
d425 3
a427 2
	while (tmp) {		/* handle entries at the front of the list */
		if (tmp->parityStripeID == parityStripeID && tmp->which_ru == which_ru) {
d440 3
a442 2
	while (tmp) {		/* handle entries on the rest of the list */
		if (tmp->parityStripeID == parityStripeID && tmp->which_ru == which_ru) {
d446 1
a446 1
			tlist = tmp;	/* insert on a temp queue */
d456 1
a456 1
		RealEnqueue(hdr, tlist);
@


1.4.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d36 1
a36 1
 *****************************************************************************/
d47 1
a47 13
void rf_CheckCvscanState(RF_CvscanHeader_t *, char *, int);
void rf_PriorityInsert(RF_DiskQueueData_t **, RF_DiskQueueData_t *);
void rf_ReqInsert(RF_DiskQueueData_t **, RF_DiskQueueData_t *,
	RF_CvscanArmDir_t);
RF_DiskQueueData_t *rf_ReqDequeue(RF_DiskQueueData_t **);
void rf_ReBalance(RF_CvscanHeader_t *);
void rf_Transfer(RF_DiskQueueData_t **, RF_DiskQueueData_t **);
void rf_RealEnqueue(RF_CvscanHeader_t *, RF_DiskQueueData_t *);

#define	DO_CHECK_STATE(_hdr_)	rf_CheckCvscanState((_hdr_), __FILE__, __LINE__)

#define	pri_ok(p)	(((p) == RF_IO_NORMAL_PRIORITY) ||		\
			 ((p) == RF_IO_LOW_PRIORITY))
d49 1
d51 2
a52 2
void
rf_CheckCvscanState(RF_CvscanHeader_t *hdr, char *file, int line)
d54 1
a54 1
	long i, key;
d60 2
a61 2
	     tmp != (RF_DiskQueueData_t *) NULL;
	     key = tmp->sectorOffset, i++, tmp = tmp->next)
d63 1
a63 2
		    && tmp->priority == hdr->nxt_priority && 
		    pri_ok(tmp->priority));
d67 2
a68 2
	     tmp != (RF_DiskQueueData_t *) NULL;
	     key = tmp->sectorOffset, i++, tmp = tmp->next) {
d76 2
a77 2
	     tmp != (RF_DiskQueueData_t *) NULL;
	     key = tmp->priority, tmp = tmp->next) {
d87 3
a89 2
void
rf_PriorityInsert(RF_DiskQueueData_t **list_ptr, RF_DiskQueueData_t *req)
d91 3
a93 5
	/*
	 * Insert block pointed to by req into list whose first entry is
	 * pointed to by the pointer that list_ptr points to.
	 * i.e. list_ptr is a grandparent of the first entry.
	 */
d96 2
a97 2
	       (*list_ptr)->priority > req->priority;
	     list_ptr = &((*list_ptr)->next)) {
d104 7
a110 9
void
rf_ReqInsert(RF_DiskQueueData_t **list_ptr, RF_DiskQueueData_t *req,
    RF_CvscanArmDir_t order)
{
	/*
	 * Insert block pointed to by req into list whose first entry is
	 * pointed to by the pointer that list_ptr points to.
	 * i.e. list_ptr is a grandparent of the first entry.
	 */
d113 4
a116 4
	       ((order == rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <=
	       req->sectorOffset) || (order == rf_cvscan_LEFT &&
	       (*list_ptr)->sectorOffset > req->sectorOffset));
	     list_ptr = &((*list_ptr)->next)) {
d123 3
a125 2
RF_DiskQueueData_t *
rf_ReqDequeue(RF_DiskQueueData_t **list_ptr)
d135 3
a137 2
void
rf_ReBalance(RF_CvscanHeader_t *hdr)
d144 1
a144 2
		rf_ReqInsert(&hdr->left, rf_ReqDequeue(&hdr->right),
		    rf_cvscan_LEFT);
d150 3
a152 2
void
rf_Transfer(RF_DiskQueueData_t **to_list_ptr, RF_DiskQueueData_t **from_list_ptr)
d157 1
a157 1
		rf_PriorityInsert(to_list_ptr, gp);
d164 3
a166 2
void
rf_RealEnqueue(RF_CvscanHeader_t *hdr, RF_DiskQueueData_t *req)
d168 1
a168 2
	RF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY ||
	    req->priority == RF_IO_LOW_PRIORITY);
d176 4
a179 4
		 * Dump all other outstanding requests on the back burner.
		 */
		rf_Transfer(&hdr->burner, &hdr->left);
		rf_Transfer(&hdr->burner, &hdr->right);
d186 3
a188 3
		 * Yet another low priority task !
		 */
		rf_PriorityInsert(&hdr->burner, req);
d191 2
a192 2
			/* This request is to the left of the current arms. */
			rf_ReqInsert(&hdr->left, req, rf_cvscan_LEFT);
d195 2
a196 2
			/* This request is to the right of the current arms. */
			rf_ReqInsert(&hdr->right, req, rf_cvscan_RIGHT);
d204 3
a206 2
void
rf_CvscanEnqueue(void *q_in, RF_DiskQueueData_t *elem, int priority)
d209 1
a209 1
	rf_RealEnqueue(hdr, elem /* req */ );
d213 1
d227 1
a227 2
	range = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt,
	    hdr->right_cnt));
d229 3
a231 4
	     ((hdr->direction == rf_cvscan_RIGHT) ?
	      range * hdr->change_penalty : 0);
	     tmp != (RF_DiskQueueData_t *) NULL && i < range;
	     tmp = tmp->next, i++) {
d235 3
a237 4
	     ((hdr->direction == rf_cvscan_LEFT) ?
	      range * hdr->change_penalty : 0);
	     tmp != (RF_DiskQueueData_t *) NULL && i < range;
	     tmp = tmp->next, i++) {
d246 1
a246 1
		ret = (rf_ReqDequeue(&hdr->left)) /*->parent*/ ;
d249 1
a249 2
		hdr->cur_block = hdr->right->sectorOffset +
		    hdr->right->numSector;
d252 1
a252 1
		ret = (rf_ReqDequeue(&hdr->right)) /*->parent*/ ;
d254 1
a254 1
	rf_ReBalance(hdr);
d259 2
a260 2
		 * Restore low priority requests for next dequeue.
		 */
d263 2
a264 2
		while (burner != (RF_DiskQueueData_t *) NULL &&
		    burner->priority == hdr->nxt_priority) {
d266 1
a266 1
			rf_RealEnqueue(hdr, burner);
d276 1
d289 1
a289 2
		range = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt,
		    hdr->right_cnt));
d291 3
a293 4
		     ((hdr->direction == rf_cvscan_RIGHT) ?
		      range * hdr->change_penalty : 0);
		     tmp != (RF_DiskQueueData_t *) NULL && i < range;
		     tmp = tmp->next, i++) {
d297 3
a299 4
		     ((hdr->direction == rf_cvscan_LEFT) ?
		      range * hdr->change_penalty : 0);
		     tmp != (RF_DiskQueueData_t *) NULL && i < range;
		     tmp = tmp->next, i++) {
d312 1
d314 5
a318 5
 * CVSCAN( 1, 0 ) is Shortest Seek Time First (SSTF)
 *				lowest average response time
 * CVSCAN( 1, infinity ) is SCAN
 *				lowest response time standard deviation
 */
d321 2
a322 2
int
rf_CvscanConfigure(void)
d328 1
d330 3
a332 2
rf_CvscanCreate(RF_SectorCount_t sectPerDisk, RF_AllocListElem_t *clList,
    RF_ShutdownList_t **listp)
d335 2
a336 2
	long range = 2;		/* Currently no mechanism to change these. */
	long penalty = sectPerDisk / 5;
d338 1
a338 2
	RF_MallocAndAdd(hdr, sizeof(RF_CvscanHeader_t), (RF_CvscanHeader_t *),
	    clList);
d354 1
a354 1
/* rf_PrintCvscanQueue is not used, so we ignore it... */
d356 2
a357 2
void
rf_PrintCvscanQueue(RF_CvscanHeader_t *hdr)
d367 1
a367 2
	for (tmp = hdr->left; tmp != (RF_DiskQueueData_t *) NULL;
	     tmp = tmp->next)
d374 1
a374 2
	for (tmp = hdr->right; tmp != (RF_DiskQueueData_t *) NULL;
	     tmp = tmp->next)
d381 1
a381 2
	for (tmp = hdr->burner; tmp != (RF_DiskQueueData_t *) NULL;
	     tmp = tmp->next)
d391 4
a394 5
/*
 * Promote reconstruction accesses for the given stripeID to normal priority.
 * Return 1 if an access was found and zero otherwise.
 * Normally, we should only have one or zero entries in the burner queue,
 * so execution time should be short.
d396 2
a397 3
int
rf_CvscanPromote(void *q_in, RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru)
d401 1
a401 1
	int retval = 0;
d404 2
a405 3
	while (tmp) {		/* Handle entries at the front of the list. */
		if (tmp->parityStripeID == parityStripeID &&
		    tmp->which_ru == which_ru) {
d418 2
a419 3
	while (tmp) {		/* Handle entries on the rest of the list. */
		if (tmp->parityStripeID == parityStripeID &&
		    tmp->which_ru == which_ru) {
d423 1
a423 1
			tlist = tmp;	/* Insert on a temp queue. */
d433 1
a433 1
		rf_RealEnqueue(hdr, tlist);
@


1.4.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d36 1
a36 1
 *****************************************************************************/
d47 1
a47 13
void rf_CheckCvscanState(RF_CvscanHeader_t *, char *, int);
void rf_PriorityInsert(RF_DiskQueueData_t **, RF_DiskQueueData_t *);
void rf_ReqInsert(RF_DiskQueueData_t **, RF_DiskQueueData_t *,
	RF_CvscanArmDir_t);
RF_DiskQueueData_t *rf_ReqDequeue(RF_DiskQueueData_t **);
void rf_ReBalance(RF_CvscanHeader_t *);
void rf_Transfer(RF_DiskQueueData_t **, RF_DiskQueueData_t **);
void rf_RealEnqueue(RF_CvscanHeader_t *, RF_DiskQueueData_t *);

#define	DO_CHECK_STATE(_hdr_)	rf_CheckCvscanState((_hdr_), __FILE__, __LINE__)

#define	pri_ok(p)	(((p) == RF_IO_NORMAL_PRIORITY) ||		\
			 ((p) == RF_IO_LOW_PRIORITY))
d49 1
d51 2
a52 2
void
rf_CheckCvscanState(RF_CvscanHeader_t *hdr, char *file, int line)
d54 1
a54 1
	long i, key;
d60 2
a61 2
	     tmp != (RF_DiskQueueData_t *) NULL;
	     key = tmp->sectorOffset, i++, tmp = tmp->next)
d63 1
a63 2
		    && tmp->priority == hdr->nxt_priority && 
		    pri_ok(tmp->priority));
d67 2
a68 2
	     tmp != (RF_DiskQueueData_t *) NULL;
	     key = tmp->sectorOffset, i++, tmp = tmp->next) {
d76 2
a77 2
	     tmp != (RF_DiskQueueData_t *) NULL;
	     key = tmp->priority, tmp = tmp->next) {
d87 3
a89 2
void
rf_PriorityInsert(RF_DiskQueueData_t **list_ptr, RF_DiskQueueData_t *req)
d91 3
a93 5
	/*
	 * Insert block pointed to by req into list whose first entry is
	 * pointed to by the pointer that list_ptr points to.
	 * i.e. list_ptr is a grandparent of the first entry.
	 */
d96 2
a97 2
	       (*list_ptr)->priority > req->priority;
	     list_ptr = &((*list_ptr)->next)) {
d104 7
a110 9
void
rf_ReqInsert(RF_DiskQueueData_t **list_ptr, RF_DiskQueueData_t *req,
    RF_CvscanArmDir_t order)
{
	/*
	 * Insert block pointed to by req into list whose first entry is
	 * pointed to by the pointer that list_ptr points to.
	 * i.e. list_ptr is a grandparent of the first entry.
	 */
d113 4
a116 4
	       ((order == rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <=
	       req->sectorOffset) || (order == rf_cvscan_LEFT &&
	       (*list_ptr)->sectorOffset > req->sectorOffset));
	     list_ptr = &((*list_ptr)->next)) {
d123 3
a125 2
RF_DiskQueueData_t *
rf_ReqDequeue(RF_DiskQueueData_t **list_ptr)
d135 3
a137 2
void
rf_ReBalance(RF_CvscanHeader_t *hdr)
d144 1
a144 2
		rf_ReqInsert(&hdr->left, rf_ReqDequeue(&hdr->right),
		    rf_cvscan_LEFT);
d150 3
a152 2
void
rf_Transfer(RF_DiskQueueData_t **to_list_ptr, RF_DiskQueueData_t **from_list_ptr)
d157 1
a157 1
		rf_PriorityInsert(to_list_ptr, gp);
d164 3
a166 2
void
rf_RealEnqueue(RF_CvscanHeader_t *hdr, RF_DiskQueueData_t *req)
d168 1
a168 2
	RF_ASSERT(req->priority == RF_IO_NORMAL_PRIORITY ||
	    req->priority == RF_IO_LOW_PRIORITY);
d176 4
a179 4
		 * Dump all other outstanding requests on the back burner.
		 */
		rf_Transfer(&hdr->burner, &hdr->left);
		rf_Transfer(&hdr->burner, &hdr->right);
d186 3
a188 3
		 * Yet another low priority task !
		 */
		rf_PriorityInsert(&hdr->burner, req);
d191 2
a192 2
			/* This request is to the left of the current arms. */
			rf_ReqInsert(&hdr->left, req, rf_cvscan_LEFT);
d195 2
a196 2
			/* This request is to the right of the current arms. */
			rf_ReqInsert(&hdr->right, req, rf_cvscan_RIGHT);
d204 3
a206 2
void
rf_CvscanEnqueue(void *q_in, RF_DiskQueueData_t *elem, int priority)
d209 1
a209 1
	rf_RealEnqueue(hdr, elem /* req */ );
d213 1
d227 1
a227 2
	range = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt,
	    hdr->right_cnt));
d229 3
a231 4
	     ((hdr->direction == rf_cvscan_RIGHT) ?
	      range * hdr->change_penalty : 0);
	     tmp != (RF_DiskQueueData_t *) NULL && i < range;
	     tmp = tmp->next, i++) {
d235 3
a237 4
	     ((hdr->direction == rf_cvscan_LEFT) ?
	      range * hdr->change_penalty : 0);
	     tmp != (RF_DiskQueueData_t *) NULL && i < range;
	     tmp = tmp->next, i++) {
d246 1
a246 1
		ret = (rf_ReqDequeue(&hdr->left)) /*->parent*/ ;
d249 1
a249 2
		hdr->cur_block = hdr->right->sectorOffset +
		    hdr->right->numSector;
d252 1
a252 1
		ret = (rf_ReqDequeue(&hdr->right)) /*->parent*/ ;
d254 1
a254 1
	rf_ReBalance(hdr);
d259 2
a260 2
		 * Restore low priority requests for next dequeue.
		 */
d263 2
a264 2
		while (burner != (RF_DiskQueueData_t *) NULL &&
		    burner->priority == hdr->nxt_priority) {
d266 1
a266 1
			rf_RealEnqueue(hdr, burner);
d276 1
d289 1
a289 2
		range = RF_MIN(hdr->range_for_avg, RF_MIN(hdr->left_cnt,
		    hdr->right_cnt));
d291 3
a293 4
		     ((hdr->direction == rf_cvscan_RIGHT) ?
		      range * hdr->change_penalty : 0);
		     tmp != (RF_DiskQueueData_t *) NULL && i < range;
		     tmp = tmp->next, i++) {
d297 3
a299 4
		     ((hdr->direction == rf_cvscan_LEFT) ?
		      range * hdr->change_penalty : 0);
		     tmp != (RF_DiskQueueData_t *) NULL && i < range;
		     tmp = tmp->next, i++) {
d312 1
d314 5
a318 5
 * CVSCAN( 1, 0 ) is Shortest Seek Time First (SSTF)
 *				lowest average response time
 * CVSCAN( 1, infinity ) is SCAN
 *				lowest response time standard deviation
 */
d321 2
a322 2
int
rf_CvscanConfigure(void)
d328 1
d330 3
a332 2
rf_CvscanCreate(RF_SectorCount_t sectPerDisk, RF_AllocListElem_t *clList,
    RF_ShutdownList_t **listp)
d335 2
a336 2
	long range = 2;		/* Currently no mechanism to change these. */
	long penalty = sectPerDisk / 5;
d338 1
a338 2
	RF_MallocAndAdd(hdr, sizeof(RF_CvscanHeader_t), (RF_CvscanHeader_t *),
	    clList);
d354 1
a354 1
/* rf_PrintCvscanQueue is not used, so we ignore it... */
d356 2
a357 2
void
rf_PrintCvscanQueue(RF_CvscanHeader_t *hdr)
d367 1
a367 2
	for (tmp = hdr->left; tmp != (RF_DiskQueueData_t *) NULL;
	     tmp = tmp->next)
d374 1
a374 2
	for (tmp = hdr->right; tmp != (RF_DiskQueueData_t *) NULL;
	     tmp = tmp->next)
d381 1
a381 2
	for (tmp = hdr->burner; tmp != (RF_DiskQueueData_t *) NULL;
	     tmp = tmp->next)
d391 4
a394 5
/*
 * Promote reconstruction accesses for the given stripeID to normal priority.
 * Return 1 if an access was found and zero otherwise.
 * Normally, we should only have one or zero entries in the burner queue,
 * so execution time should be short.
d396 2
a397 3
int
rf_CvscanPromote(void *q_in, RF_StripeNum_t parityStripeID,
    RF_ReconUnitNum_t which_ru)
d401 1
a401 1
	int retval = 0;
d404 2
a405 3
	while (tmp) {		/* Handle entries at the front of the list. */
		if (tmp->parityStripeID == parityStripeID &&
		    tmp->which_ru == which_ru) {
d418 2
a419 3
	while (tmp) {		/* Handle entries on the rest of the list. */
		if (tmp->parityStripeID == parityStripeID &&
		    tmp->which_ru == which_ru) {
d423 1
a423 1
			tlist = tmp;	/* Insert on a temp queue. */
d433 1
a433 1
		rf_RealEnqueue(hdr, tlist);
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_cvscan.c,v 1.2 1999/02/16 00:02:28 niklas Exp $	*/
/*	$NetBSD: rf_cvscan.c,v 1.4 1999/02/05 00:06:07 oster Exp $	*/
a45 1
#include "rf_sys.h"
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_cvscan.c,v 1.1 1999/01/11 14:29:05 niklas Exp $	*/
d357 5
a361 5
+ static void 
+ PrintCvscanQueue(RF_CvscanHeader_t * hdr)
  {
  	RF_DiskQueueData_t *tmp;
  
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_cvscan.c,v 1.2 1998/11/18 15:13:51 oster Exp $	*/
/*	$NetBSD: rf_cvscan.c,v 1.2 1998/11/18 15:13:51 oster Exp $	*/
d32 1
a32 1
 * cvscan.c --  prioritized cvscan disk queueing code.  
a37 27
/*
 * :  
 * Log: rf_cvscan.c,v 
 * Revision 1.6  1996/07/27 23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.5  1996/07/15  17:22:18  jimz
 * nit-pick code cleanup
 * resolve stdlib problems on DEC OSF
 *
 * Revision 1.4  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.3  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.2  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.1  1996/06/05  19:17:40  jimz
 * Initial revision
 *
 */

d52 2
a53 1
static void CheckCvscanState(RF_CvscanHeader_t *hdr, char *file, int line)
d55 1
a55 1
	long i, key;
d58 12
a69 13
	if( hdr->left != (RF_DiskQueueData_t *) NULL )
		RF_ASSERT( hdr->left->sectorOffset < hdr->cur_block );
	for( key=hdr->cur_block, i=0, tmp=hdr->left;
		tmp != (RF_DiskQueueData_t *) NULL;
		key=tmp->sectorOffset, i++, tmp=tmp->next )
		RF_ASSERT( tmp->sectorOffset <= key
		&& tmp->priority == hdr->nxt_priority && pri_ok(tmp->priority) );
	RF_ASSERT( i == hdr->left_cnt );

	for( key=hdr->cur_block, i=0, tmp=hdr->right;
		tmp != (RF_DiskQueueData_t *) NULL;
		key=tmp->sectorOffset, i++, tmp=tmp->next )
	{
d74 1
a74 1
	RF_ASSERT( i == hdr->right_cnt );
d76 3
a78 4
	for( key=hdr->nxt_priority-1, tmp=hdr->burner;
		tmp != (RF_DiskQueueData_t *) NULL;
		key=tmp->priority, tmp=tmp->next )
	{
d89 2
a90 1
static void PriorityInsert(RF_DiskQueueData_t **list_ptr, RF_DiskQueueData_t *req )
d92 8
a99 9
	/* 
	** insert block pointed to by req in to list whose first
	** entry is pointed to by the pointer that list_ptr points to
	** ie., list_ptr is a grandparent of the first entry
	*/

	for( ; (*list_ptr)!=(RF_DiskQueueData_t *)NULL &&
		(*list_ptr)->priority > req->priority;
		list_ptr = &((*list_ptr)->next) ) {}
d106 2
a107 1
static void ReqInsert(RF_DiskQueueData_t **list_ptr, RF_DiskQueueData_t *req, RF_CvscanArmDir_t order)
d109 10
a118 11
	/* 
	** insert block pointed to by req in to list whose first
	** entry is pointed to by the pointer that list_ptr points to
	** ie., list_ptr is a grandparent of the first entry
	*/

	for( ; (*list_ptr)!=(RF_DiskQueueData_t *)NULL &&

		( (order==rf_cvscan_RIGHT && (*list_ptr)->sectorOffset <= req->sectorOffset)
		|| (order==rf_cvscan_LEFT && (*list_ptr)->sectorOffset > req->sectorOffset) );
		list_ptr = &((*list_ptr)->next) ) {}
d125 2
a126 1
static RF_DiskQueueData_t *ReqDequeue(RF_DiskQueueData_t **list_ptr)
d128 2
a129 2
	RF_DiskQueueData_t * ret = (*list_ptr);
	if( (*list_ptr) != (RF_DiskQueueData_t *) NULL ) {
d132 1
a132 1
	return( ret );
d137 2
a138 1
static void ReBalance(RF_CvscanHeader_t *hdr)
d141 2
a142 2
	while( hdr->right != (RF_DiskQueueData_t *) NULL
		&& hdr->right->sectorOffset < hdr->cur_block ) {
d145 1
a145 1
		ReqInsert( &hdr->left, ReqDequeue( &hdr->right ), rf_cvscan_LEFT );
d152 2
a153 1
static void Transfer(RF_DiskQueueData_t **to_list_ptr, RF_DiskQueueData_t **from_list_ptr )
d156 1
a156 1
	for( gp=(*from_list_ptr); gp != (RF_DiskQueueData_t *) NULL; ) {
d158 1
a158 1
		PriorityInsert( to_list_ptr, gp );
d166 2
a167 1
static void RealEnqueue(RF_CvscanHeader_t *hdr, RF_DiskQueueData_t *req)
d170 1
a170 1
	
d172 1
a172 1
	if( hdr->left_cnt == 0 && hdr->right_cnt == 0 ) {
d175 1
a175 1
	if( req->priority > hdr->nxt_priority ) {
d179 2
a180 2
		Transfer( &hdr->burner, &hdr->left );
		Transfer( &hdr->burner, &hdr->right );
d185 1
a185 1
	if( req->priority < hdr->nxt_priority ) {
d189 1
a189 1
		PriorityInsert( &hdr->burner, req );
d191 1
a191 1
		if( req->sectorOffset < hdr->cur_block ) {
d193 1
a193 1
			ReqInsert( &hdr->left, req, rf_cvscan_LEFT );
d197 1
a197 1
			ReqInsert( &hdr->right, req, rf_cvscan_RIGHT );
d206 2
a207 1
void rf_CvscanEnqueue(void *q_in, RF_DiskQueueData_t *elem, int priority)
d209 2
a210 2
        RF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;
	RealEnqueue( hdr, elem /*req*/ );
d215 2
a216 1
RF_DiskQueueData_t *rf_CvscanDequeue(void *q_in)
d218 2
a219 2
        RF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;
	long range, i, sum_dist_left, sum_dist_right;
a223 2
	
	if( hdr->left_cnt == 0 && hdr->right_cnt == 0 ) return( (RF_DiskQueueData_t *) NULL );
d225 8
a232 5
	range = RF_MIN( hdr->range_for_avg, RF_MIN(hdr->left_cnt,hdr->right_cnt));
	for( i=0, tmp=hdr->left, sum_dist_left=
		((hdr->direction==rf_cvscan_RIGHT)?range*hdr->change_penalty:0);
		tmp != (RF_DiskQueueData_t *) NULL && i < range;
		tmp = tmp->next, i++ ) {
d235 4
a238 4
	for( i=0, tmp=hdr->right, sum_dist_right=
		((hdr->direction==rf_cvscan_LEFT)?range*hdr->change_penalty:0);
		tmp != (RF_DiskQueueData_t *) NULL && i < range;
		tmp = tmp->next, i++ ) {
d242 1
a242 1
	if( hdr->right_cnt == 0 || sum_dist_left < sum_dist_right ) {
d245 1
a245 1
		hdr->left_cnt = RF_MAX(hdr->left_cnt-1,0);
d247 1
a247 1
		ret = (ReqDequeue(&hdr->left))/*->parent*/;
d251 1
a251 1
		hdr->right_cnt = RF_MAX(hdr->right_cnt-1,0);
d253 1
a253 1
		ret = (ReqDequeue(&hdr->right))/*->parent*/;
d255 1
a255 1
	ReBalance( hdr );
d257 2
a258 2
	if( hdr->left_cnt == 0 && hdr->right_cnt == 0
		&& hdr->burner != (RF_DiskQueueData_t *) NULL ) {
d264 2
a265 2
		while( burner != (RF_DiskQueueData_t *) NULL
			&& burner->priority == hdr->nxt_priority ) {
d267 1
a267 1
			RealEnqueue( hdr, burner );
d273 1
a273 1
	return( ret );
d278 2
a279 1
RF_DiskQueueData_t *rf_CvscanPeek(void *q_in)
d281 22
a302 3
  RF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;
  long range, i, sum_dist_left, sum_dist_right;
  RF_DiskQueueData_t *tmp, *headElement;
d304 6
a309 25
  DO_CHECK_STATE(hdr);
  
  if( hdr->left_cnt == 0 && hdr->right_cnt == 0 )
    headElement = NULL;
  else {
    range = RF_MIN( hdr->range_for_avg, RF_MIN(hdr->left_cnt,hdr->right_cnt));
    for( i=0, tmp=hdr->left, sum_dist_left=
	((hdr->direction==rf_cvscan_RIGHT)?range*hdr->change_penalty:0);
	tmp != (RF_DiskQueueData_t *) NULL && i < range;
	tmp = tmp->next, i++ ) {
      sum_dist_left += hdr->cur_block - tmp->sectorOffset;
    }
    for( i=0, tmp=hdr->right, sum_dist_right=
	((hdr->direction==rf_cvscan_LEFT)?range*hdr->change_penalty:0);
	tmp != (RF_DiskQueueData_t *) NULL && i < range;
	tmp = tmp->next, i++ ) {
      sum_dist_right += tmp->sectorOffset - hdr->cur_block;
    }
    
    if( hdr->right_cnt == 0 || sum_dist_left < sum_dist_right )
      headElement = hdr->left;
    else
      headElement = hdr->right;
  }
  return(headElement);
d322 2
a323 1
int rf_CvscanConfigure()
d325 1
a325 1
  return(0);
d330 4
a333 3
void *rf_CvscanCreate(RF_SectorCount_t sectPerDisk, 
		      RF_AllocListElem_t *clList,
		      RF_ShutdownList_t **listp)
d336 2
a337 2
	long range = 2;                   /* Currently no mechanism to change these */
	long penalty = sectPerDisk / 5;
d340 3
a342 3
	bzero((char *)hdr, sizeof(RF_CvscanHeader_t));
	hdr->range_for_avg = RF_MAX( range, 1 );
	hdr->change_penalty = RF_MAX( penalty, 0 );
d350 1
a350 1
	return( (void *) hdr );
d357 31
a387 30
static void PrintCvscanQueue(RF_CvscanHeader_t *hdr)
{
	RF_DiskQueueData_t *tmp;

	printf( "CVSCAN(%d,%d) at %d going %s\n", 
		(int)hdr->range_for_avg,
		(int)hdr->change_penalty, 
		(int)hdr->cur_block,
		(hdr->direction==rf_cvscan_LEFT)?"LEFT":"RIGHT" );
	printf( "\tLeft(%d): ", hdr->left_cnt );
	for( tmp = hdr->left; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)
		printf( "(%d,%ld,%d) ", 
			(int) tmp->sectorOffset, 
			(long) (tmp->sectorOffset + tmp->numSector),
			tmp->priority );
	printf( "\n" );
	printf( "\tRight(%d): ", hdr->right_cnt );
	for( tmp = hdr->right; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)
		printf( "(%d,%ld,%d) ",
			(int) tmp->sectorOffset, 
			(long) (tmp->sectorOffset + tmp->numSector),
			tmp->priority );
	printf( "\n" );
	printf( "\tBurner: " );
	for( tmp = hdr->burner; tmp != (RF_DiskQueueData_t *) NULL; tmp = tmp->next)
		printf( "(%d,%ld,%d) ", 
			(int) tmp->sectorOffset, 
			(long) (tmp->sectorOffset + tmp->numSector),
			tmp->priority );
	printf( "\n" );
d397 2
a398 1
int rf_CvscanPromote(void *q_in, RF_StripeNum_t parityStripeID, RF_ReconUnitNum_t which_ru)
d400 3
a402 3
    RF_CvscanHeader_t *hdr = (RF_CvscanHeader_t *) q_in;
    RF_DiskQueueData_t *trailer = NULL, *tmp = hdr->burner, *tlist = NULL;
    int retval=0;
d405 25
a429 17
    while (tmp) {				/* handle entries at the front of the list */
	if (tmp->parityStripeID == parityStripeID && tmp->which_ru == which_ru) {
	    hdr->burner = tmp->next;
	    tmp->priority = RF_IO_NORMAL_PRIORITY;
	    tmp->next = tlist; tlist=tmp;
	    tmp = hdr->burner;
	} else break;
    }
    if (tmp) {trailer=tmp; tmp=tmp->next;}
    while (tmp) {				/* handle entries on the rest of the list */
	if (tmp->parityStripeID == parityStripeID && tmp->which_ru == which_ru) {
	    trailer->next = tmp->next;
	    tmp->priority = RF_IO_NORMAL_PRIORITY;
	    tmp->next = tlist; tlist=tmp;		/* insert on a temp queue */
	    tmp = trailer->next;
	} else {
            trailer=tmp; tmp=tmp->next;
d431 9
a439 10
    }
    while (tlist) {
	retval++;
	tmp = tlist->next;
        RealEnqueue(hdr, tlist);
	tlist = tmp;
    }
    RF_ASSERT(retval==0 || retval==1);
	DO_CHECK_STATE((RF_CvscanHeader_t *)q_in);
    return(retval);
a440 1

@

