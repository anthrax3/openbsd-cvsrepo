head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.38
	OPENBSD_5_0:1.4.0.36
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.18
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.3
	UBC:1.2.0.16
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.14
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.12
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.4;

1.4
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.09.15.10.20;	author tdeval;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.35;	author niklas;	state Exp;
branches
	1.2.6.1
	1.2.16.1;
next	1.1;

1.1
date	99.01.11.14.29.14;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.2.16.1
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_declusterPQ.c,v 1.4 2002/12/16 07:01:03 tdeval Exp $	*/
/*	$NetBSD: rf_declusterPQ.c,v 1.3 1999/02/05 00:06:09 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Authors: Daniel Stodolsky, Mark Holland, Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 * rf_declusterPQ.c
 *
 * Mapping code for declustered P & Q or declustered EvenOdd.
 * Much code borrowed from rf_decluster.c
 *
 *****************************************************************************/


#include "rf_types.h"
#include "rf_raid.h"
#include "rf_configure.h"
#include "rf_decluster.h"
#include "rf_declusterPQ.h"
#include "rf_debugMem.h"
#include "rf_utils.h"
#include "rf_alloclist.h"
#include "rf_general.h"

/* Configuration code. */

int
rf_ConfigureDeclusteredPQ(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	int b, v, k, r, lambda;	/* block design params */
	int i, j, l;
	int *first_avail_slot;
	int complete_FT_count, SUID;
	RF_DeclusteredConfigInfo_t *info;
	int numCompleteFullTablesPerDisk;
	int PUsPerDisk, spareRegionDepthInPUs, extraPUsPerDisk;
	int numCompleteSpareRegionsPerDisk = 0;
	int totSparePUsPerDisk;
	int diskOffsetOfLastFullTableInSUs, SpareSpaceInSUs;
	char *cfgBuf = (char *)(cfgPtr->layoutSpecific);

	cfgBuf += RF_SPAREMAP_NAME_LEN;

	b = *((int *) cfgBuf);
	cfgBuf += sizeof(int);
	v = *((int *) cfgBuf);
	cfgBuf += sizeof(int);
	k = *((int *) cfgBuf);
	cfgBuf += sizeof(int);
	r = *((int *) cfgBuf);
	cfgBuf += sizeof(int);
	lambda = *((int *) cfgBuf);
	cfgBuf += sizeof(int);
	raidPtr->noRotate = *((int *) cfgBuf);
	cfgBuf += sizeof(int);

	if (k <= 2) {
#ifdef	RAIDDEBUG
		printf("RAIDFRAME: k=%d, minimum value 2\n", k);
#endif	/* RAIDDEBUG */
		return (EINVAL);
	}
	/* 1. Create layout specific structure. */
	RF_MallocAndAdd(info, sizeof(RF_DeclusteredConfigInfo_t),
	    (RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList);
	if (info == NULL)
		return (ENOMEM);
	layoutPtr->layoutSpecificInfo = (void *) info;

	/*
	 * 2. The sparemaps are generated assuming that parity is rotated, so
	 * we issue a warning if both distributed sparing and no-rotate are on
	 * at the same time.
	 */
	if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) &&
	    raidPtr->noRotate) {
		RF_ERRORMSG("Warning:  distributed sparing specified without"
		    " parity rotation.\n");
	}
	if (raidPtr->numCol != v) {
		RF_ERRORMSG2("RAID: config error: table element count (%d)"
		    " not equal to no. of cols (%d).\n", v, raidPtr->numCol);
		return (EINVAL);
	}
	/* 3. Set up the values used in devRaidMap. */
	info->BlocksPerTable = b;
	info->NumParityReps = info->groupSize = k;
	info->PUsPerBlock = k - 2;	/* PQ */
	info->SUsPerTable = b * info->PUsPerBlock * layoutPtr->SUsPerPU;
		/* b blks, k-1 SUs each. */
	info->SUsPerFullTable = k * info->SUsPerTable;	/* Rot k times. */
	info->SUsPerBlock = info->PUsPerBlock * layoutPtr->SUsPerPU;
	info->TableDepthInPUs = (b * k) / v;
	info->FullTableDepthInPUs = info->TableDepthInPUs * k;
		/* k repetitions. */

	/* Used only in distributed sparing case. */
	info->FullTablesPerSpareRegion = (v - 1) / rf_gcd(r, v - 1);
		/* (v-1)/gcd fulltables. */
	info->TablesPerSpareRegion = k * info->FullTablesPerSpareRegion;
	info->SpareSpaceDepthPerRegionInSUs = (r * info->TablesPerSpareRegion
	    / (v - 1)) * layoutPtr->SUsPerPU;

	/* Check to make sure the block design is sufficiently small. */
	if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
		if (info->FullTableDepthInPUs * layoutPtr->SUsPerPU +
		    info->SpareSpaceDepthPerRegionInSUs >
		    layoutPtr->stripeUnitsPerDisk) {
			RF_ERRORMSG3("RAID: config error: Full Table depth"
			    " (%d) + Spare Space (%d) larger than disk size"
			    " (%d) (BD too big).\n",
			    (int)info->FullTableDepthInPUs,
			    (int)info->SpareSpaceDepthPerRegionInSUs,
			    (int)layoutPtr->stripeUnitsPerDisk);
			return (EINVAL);
		}
	} else {
		if (info->TableDepthInPUs * layoutPtr->SUsPerPU >
		    layoutPtr->stripeUnitsPerDisk) {
			RF_ERRORMSG2("RAID: config error: Table depth (%d)"
			    " larger than disk size (%d) (BD too big).\n",
			    (int) (info->TableDepthInPUs * layoutPtr->SUsPerPU),
			    (int) layoutPtr->stripeUnitsPerDisk);
			return (EINVAL);
		}
	}

	/*
	 * Compute the size of each disk, and the number of tables in the last
	 * fulltable (which need not be complete).
	 */
	if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {

		PUsPerDisk = layoutPtr->stripeUnitsPerDisk /
		    layoutPtr->SUsPerPU;
		spareRegionDepthInPUs = (info->TablesPerSpareRegion *
		    info->TableDepthInPUs + (info->TablesPerSpareRegion *
		    info->TableDepthInPUs) / (v - 1));
		info->SpareRegionDepthInSUs = spareRegionDepthInPUs *
		    layoutPtr->SUsPerPU;

		numCompleteSpareRegionsPerDisk = PUsPerDisk /
		    spareRegionDepthInPUs;
		info->NumCompleteSRs = numCompleteSpareRegionsPerDisk;
		extraPUsPerDisk = PUsPerDisk % spareRegionDepthInPUs;

		/*
		 * Assume conservatively that we need the full amount of spare
		 * space in one region in order to provide spares for the
		 * partial spare region at the end of the array.  We set "i"
		 * to the number of tables in the partial spare region.  This
		 * may actually include some fulltables.
		 */
		extraPUsPerDisk -= (info->SpareSpaceDepthPerRegionInSUs /
		    layoutPtr->SUsPerPU);
		if (extraPUsPerDisk <= 0)
			i = 0;
		else
			i = extraPUsPerDisk / info->TableDepthInPUs;

		complete_FT_count = raidPtr->numRow *
		    (numCompleteSpareRegionsPerDisk *
		    (info->TablesPerSpareRegion / k) + i / k);
		info->FullTableLimitSUID = complete_FT_count *
		    info->SUsPerFullTable;
		info->ExtraTablesPerDisk = i % k;

		/*
		 * Note that in the last spare region, the spare space is
		 * complete even though data/parity space is not.
		 */
		totSparePUsPerDisk = (numCompleteSpareRegionsPerDisk + 1) *
		    (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);
		info->TotSparePUsPerDisk = totSparePUsPerDisk;

		layoutPtr->stripeUnitsPerDisk =
		    ((complete_FT_count / raidPtr->numRow) *
		    info->FullTableDepthInPUs +	/* data & parity space */
		    info->ExtraTablesPerDisk * info->TableDepthInPUs +
		    totSparePUsPerDisk	/* spare space */
		    ) * layoutPtr->SUsPerPU;
		layoutPtr->dataStripeUnitsPerDisk =
		    (complete_FT_count * info->FullTableDepthInPUs +
		    info->ExtraTablesPerDisk * info->TableDepthInPUs)
		    * layoutPtr->SUsPerPU * (k - 1) / k;

	} else {
		/*
		 * Non-dist spare case:  force each disk to contain an
		 * integral number of tables.
		 */
		layoutPtr->stripeUnitsPerDisk /=
		    (info->TableDepthInPUs * layoutPtr->SUsPerPU);
		layoutPtr->stripeUnitsPerDisk *=
		    (info->TableDepthInPUs * layoutPtr->SUsPerPU);

		/*
		 * Compute the number of tables in the last fulltable, which
		 * need not be complete.
		 */
		complete_FT_count = ((layoutPtr->stripeUnitsPerDisk /
		    layoutPtr->SUsPerPU) / info->FullTableDepthInPUs) *
		    raidPtr->numRow;

		info->FullTableLimitSUID = complete_FT_count *
		    info->SUsPerFullTable;
		info->ExtraTablesPerDisk = ((layoutPtr->stripeUnitsPerDisk /
		    layoutPtr->SUsPerPU) / info->TableDepthInPUs) % k;
	}

	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;

	/*
	 * Find the disk offset of the stripe unit where the last
	 * fulltable starts.
	 */
	numCompleteFullTablesPerDisk = complete_FT_count / raidPtr->numRow;
	diskOffsetOfLastFullTableInSUs = numCompleteFullTablesPerDisk *
	    info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
	if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
		SpareSpaceInSUs = numCompleteSpareRegionsPerDisk *
		    info->SpareSpaceDepthPerRegionInSUs;
		diskOffsetOfLastFullTableInSUs += SpareSpaceInSUs;
		info->DiskOffsetOfLastSpareSpaceChunkInSUs =
		    diskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk *
		    info->TableDepthInPUs * layoutPtr->SUsPerPU;
	}
	info->DiskOffsetOfLastFullTableInSUs = diskOffsetOfLastFullTableInSUs;
	info->numCompleteFullTablesPerDisk = numCompleteFullTablesPerDisk;

	/* 4. Create and initialize the lookup tables. */
	info->LayoutTable = rf_make_2d_array(b, k, raidPtr->cleanupList);
	if (info->LayoutTable == NULL)
		return (ENOMEM);

	info->OffsetTable = rf_make_2d_array(b, k, raidPtr->cleanupList);
	if (info->OffsetTable == NULL)
		return (ENOMEM);

	info->BlockTable = rf_make_2d_array(info->TableDepthInPUs *
	    layoutPtr->SUsPerPU, raidPtr->numCol, raidPtr->cleanupList);
	if (info->BlockTable == NULL)
		return (ENOMEM);

	first_avail_slot = (int *) rf_make_1d_array(v, NULL);
	if (first_avail_slot == NULL)
		return (ENOMEM);

	for (i = 0; i < b; i++)
		for (j = 0; j < k; j++)
			info->LayoutTable[i][j] = *cfgBuf++;

	/* Initialize offset table. */
	for (i = 0; i < b; i++)
		for (j = 0; j < k; j++) {
			info->OffsetTable[i][j] =
			    first_avail_slot[info->LayoutTable[i][j]];
			first_avail_slot[info->LayoutTable[i][j]]++;
		}

	/* Initialize block table. */
	for (SUID = l = 0; l < layoutPtr->SUsPerPU; l++) {
		for (i = 0; i < b; i++) {
			for (j = 0; j < k; j++) {
				info->BlockTable[(info->OffsetTable[i][j] *
				     layoutPtr->SUsPerPU) + l]
				    [info->LayoutTable[i][j]] = SUID;
			}
			SUID++;
		}
	}

	rf_free_1d_array(first_avail_slot, v);

	/* 5. Set up the remaining redundant-but-useful parameters. */

	raidPtr->totalSectors = (k * complete_FT_count + raidPtr->numRow *
	    info->ExtraTablesPerDisk) * info->SUsPerTable *
	    layoutPtr->sectorsPerStripeUnit;
	layoutPtr->numStripe = (raidPtr->totalSectors /
	    layoutPtr->sectorsPerStripeUnit) / (k - 2);

	/*
	 * Strange evaluation order below to try and minimize overflow
	 * problems.
	 */

	layoutPtr->dataSectorsPerStripe = (k - 2) *
	    layoutPtr->sectorsPerStripeUnit;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
	layoutPtr->numDataCol = k - 2;
	layoutPtr->numParityCol = 2;

	return (0);
}

int
rf_GetDefaultNumFloatingReconBuffersPQ(RF_Raid_t *raidPtr)
{
	int def_decl;

	def_decl = rf_GetDefaultNumFloatingReconBuffersDeclustered(raidPtr);
	return (RF_MAX(3 * raidPtr->numCol, def_decl));
}

void
rf_MapSectorDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
	RF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;
	RF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;
	RF_StripeNum_t BlockID, BlockOffset, RepIndex;
	RF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
	RF_StripeNum_t base_suid = 0, outSU, SpareRegion = 0, SpareSpace = 0;

	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);

	/* Fulltable ID within array (across rows). */
	FullTableID = SUID / sus_per_fulltable;
	*row = FullTableID % raidPtr->numRow;

	/* Convert to fulltable ID on this disk. */
	FullTableID /= raidPtr->numRow;

	if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
		SpareRegion = FullTableID / info->FullTablesPerSpareRegion;
		SpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;
	}
	FullTableOffset = SUID % sus_per_fulltable;
	TableID = FullTableOffset / info->SUsPerTable;
	TableOffset = FullTableOffset - TableID * info->SUsPerTable;
	BlockID = TableOffset / info->PUsPerBlock;
	BlockOffset = TableOffset - BlockID * info->PUsPerBlock;
	BlockID %= info->BlocksPerTable;
	RF_ASSERT(BlockOffset < info->groupSize - 2);
	/*
	 * TableIDs go from 0 .. GroupSize-1 inclusive.
	 * PUsPerBlock is k-2.
	 * We want the tableIDs to rotate from the
	 * right, so use GroupSize.
	 */
	RepIndex = info->groupSize - 1 - TableID;
	RF_ASSERT(RepIndex >= 0);
	if (!raidPtr->noRotate) {
		if (TableID == 0)
			/* P on last drive, Q on first. */
			BlockOffset++;
		else
			/* Skip over PQ. */
			BlockOffset += ((BlockOffset >= RepIndex) ? 2 : 0);

		RF_ASSERT(BlockOffset < info->groupSize);
		*col = info->LayoutTable[BlockID][BlockOffset];
	}
	/* Remap to distributed spare space if indicated. */
	if (remap) {
		rf_remap_to_spare_space(layoutPtr, info, *row, FullTableID,
		    TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col,
		    &outSU);
	} else {

		outSU = base_suid;
		outSU += FullTableID * fulltable_depth;
			/* Offset to strt of FT. */
		outSU += SpareSpace;
			/* Skip reserved spare space. */
		outSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;
			/* Offset to start of table. */
		outSU += info->OffsetTable[BlockID][BlockOffset] *
		    layoutPtr->SUsPerPU;
			/* Offset to the PU. */
	}
	outSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);
		/* Offset to the SU within a PU. */

	/*
	 * Convert SUs to sectors, and, if not aligned to SU boundary, add in
	 * offset to sector.
	 */
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit +
	    (raidSector % layoutPtr->sectorsPerStripeUnit);
}


void
rf_MapParityDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
	RF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;
	RF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;
	RF_StripeNum_t BlockID, BlockOffset, RepIndex;
	RF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
	RF_StripeNum_t base_suid = 0, outSU, SpareRegion, SpareSpace = 0;

	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);

	/* Compute row & (possibly) spare space exactly as before. */
	FullTableID = SUID / sus_per_fulltable;
	*row = FullTableID % raidPtr->numRow;
	/* Convert to fulltable ID on this disk. */
	FullTableID /= raidPtr->numRow;
	if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
		SpareRegion = FullTableID / info->FullTablesPerSpareRegion;
		SpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;
	}
	/* Compute BlockID and RepIndex exactly as before. */
	FullTableOffset = SUID % sus_per_fulltable;
	TableID = FullTableOffset / info->SUsPerTable;
	TableOffset = FullTableOffset - TableID * info->SUsPerTable;
	BlockID = TableOffset / info->PUsPerBlock;
	BlockOffset = TableOffset - BlockID * info->PUsPerBlock;
	BlockID %= info->BlocksPerTable;

	/* The parity block is in the position indicated by RepIndex. */
	RepIndex = (raidPtr->noRotate) ?
	    info->PUsPerBlock : info->groupSize - 1 - TableID;
	*col = info->LayoutTable[BlockID][RepIndex];

	if (remap)
		RF_PANIC();

	/*
	 * Compute sector as before, except use RepIndex instead of
	 * BlockOffset.
	 */
	outSU = base_suid;
	outSU += FullTableID * fulltable_depth;
	outSU += SpareSpace;	/* skip rsvd spare space */
	outSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;
	outSU += info->OffsetTable[BlockID][RepIndex] * layoutPtr->SUsPerPU;
	outSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);

	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit +
	    (raidSector % layoutPtr->sectorsPerStripeUnit);
}

void
rf_MapQDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
	RF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;
	RF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;
	RF_StripeNum_t BlockID, BlockOffset, RepIndex, RepIndexQ;
	RF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
	RF_StripeNum_t base_suid = 0, outSU, SpareRegion, SpareSpace = 0;

	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);

	/* Compute row & (possibly) spare space exactly as before. */
	FullTableID = SUID / sus_per_fulltable;
	*row = FullTableID % raidPtr->numRow;
	/* Convert to fulltable ID on this disk. */
	FullTableID /= raidPtr->numRow;
	if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
		SpareRegion = FullTableID / info->FullTablesPerSpareRegion;
		SpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;
	}
	/* Compute BlockID and RepIndex exactly as before. */
	FullTableOffset = SUID % sus_per_fulltable;
	TableID = FullTableOffset / info->SUsPerTable;
	TableOffset = FullTableOffset - TableID * info->SUsPerTable;
	BlockID = TableOffset / info->PUsPerBlock;
	BlockOffset = TableOffset - BlockID * info->PUsPerBlock;
	BlockID %= info->BlocksPerTable;

	/* The q block is in the position indicated by RepIndex. */
	RepIndex = (raidPtr->noRotate) ?
	    info->PUsPerBlock : info->groupSize - 1 - TableID;
	RepIndexQ = ((RepIndex == (info->groupSize - 1)) ? 0 : RepIndex + 1);
	*col = info->LayoutTable[BlockID][RepIndexQ];

	if (remap)
		RF_PANIC();

	/*
	 * Compute sector as before, except use RepIndex instead of
	 * BlockOffset.
	 */
	outSU = base_suid;
	outSU += FullTableID * fulltable_depth;
	outSU += SpareSpace;	/* skip rsvd spare space */
	outSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;
	outSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);

	outSU += info->OffsetTable[BlockID][RepIndexQ] * layoutPtr->SUsPerPU;
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit +
	    (raidSector % layoutPtr->sectorsPerStripeUnit);
}

/*
 * Returns an array of ints identifying the disks that comprise the stripe
 * containing the indicated address.
 * The caller must _never_ attempt to modify this array.
 */
void
rf_IdentifyStripeDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
	RF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
	RF_StripeNum_t base_suid = 0;
	RF_StripeNum_t SUID = rf_RaidAddressToStripeUnitID(layoutPtr, addr);
	RF_StripeNum_t stripeID, FullTableID;
	int tableOffset;

	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);
	/* Fulltable ID within array (across rows). */
	FullTableID = SUID / sus_per_fulltable;
	*outRow = FullTableID % raidPtr->numRow;
	/* Find stripe offset into array. */
	stripeID = rf_StripeUnitIDToStripeID(layoutPtr, SUID);
	/* Find offset into block design table. */
	tableOffset = (stripeID % info->BlocksPerTable);
	*diskids = info->LayoutTable[tableOffset];
}
@


1.4
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_declusterPQ.c,v 1.3 2002/08/09 15:10:20 tdeval Exp $	*/
@


1.3
log
@Remove those noisy informational messages from dmesg.
Use the option RAIDDEBUG to get these.

Theo, thanks for suggesting.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_declusterPQ.c,v 1.2 1999/02/16 00:02:35 niklas Exp $	*/
d3 1
d31 1
a31 1
/*--------------------------------------------------
d34 2
a35 2
 * mapping code for declustered P & Q or declustered EvenOdd
 * much code borrowed from rf_decluster.c
d37 1
a37 1
 *--------------------------------------------------*/
d50 1
a50 1
/* configuration code */
d52 3
a54 5
int 
rf_ConfigureDeclusteredPQ(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d57 4
a60 4
	int     b, v, k, r, lambda;	/* block design params */
	int     i, j, l;
	int    *first_avail_slot;
	int     complete_FT_count, SUID;
d62 6
a67 6
	int     numCompleteFullTablesPerDisk;
	int     PUsPerDisk, spareRegionDepthInPUs, numCompleteSpareRegionsPerDisk = 0,
	        extraPUsPerDisk;
	int     totSparePUsPerDisk;
	int     diskOffsetOfLastFullTableInSUs, SpareSpaceInSUs;
	char   *cfgBuf = (char *) (cfgPtr->layoutSpecific);
d90 3
a92 2
	/* 1. create layout specific structure */
	RF_MallocAndAdd(info, sizeof(RF_DeclusteredConfigInfo_t), (RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList);
d97 9
a105 5
	/* the sparemaps are generated assuming that parity is rotated, so we
	 * issue a warning if both distributed sparing and no-rotate are on at
	 * the same time */
	if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) && raidPtr->noRotate) {
		RF_ERRORMSG("Warning:  distributed sparing specified without parity rotation.\n");
d108 2
a109 1
		RF_ERRORMSG2("RAID: config error: table element count (%d) not equal to no. of cols (%d)\n", v, raidPtr->numCol);
d112 1
a112 1
	/* 3.  set up the values used in devRaidMap */
d116 3
a118 2
	info->SUsPerTable = b * info->PUsPerBlock * layoutPtr->SUsPerPU;	/* b blks, k-1 SUs each */
	info->SUsPerFullTable = k * info->SUsPerTable;	/* rot k times */
d121 2
a122 1
	info->FullTableDepthInPUs = info->TableDepthInPUs * k;	/* k repetitions */
d124 3
a126 2
	/* used only in distributed sparing case */
	info->FullTablesPerSpareRegion = (v - 1) / rf_gcd(r, v - 1);	/* (v-1)/gcd fulltables */
d128 2
a129 1
	info->SpareSpaceDepthPerRegionInSUs = (r * info->TablesPerSpareRegion / (v - 1)) * layoutPtr->SUsPerPU;
d131 1
a131 1
	/* check to make sure the block design is sufficiently small */
d133 9
a141 5
		if (info->FullTableDepthInPUs * layoutPtr->SUsPerPU + info->SpareSpaceDepthPerRegionInSUs > layoutPtr->stripeUnitsPerDisk) {
			RF_ERRORMSG3("RAID: config error: Full Table depth (%d) + Spare Space (%d) larger than disk size (%d) (BD too big)\n",
			    (int) info->FullTableDepthInPUs,
			    (int) info->SpareSpaceDepthPerRegionInSUs,
			    (int) layoutPtr->stripeUnitsPerDisk);
d145 4
a148 2
		if (info->TableDepthInPUs * layoutPtr->SUsPerPU > layoutPtr->stripeUnitsPerDisk) {
			RF_ERRORMSG2("RAID: config error: Table depth (%d) larger than disk size (%d) (BD too big)\n",
d155 4
a158 3

	/* compute the size of each disk, and the number of tables in the last
	 * fulltable (which need not be complete) */
d161 7
a167 4
		PUsPerDisk = layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU;
		spareRegionDepthInPUs = (info->TablesPerSpareRegion * info->TableDepthInPUs +
		    (info->TablesPerSpareRegion * info->TableDepthInPUs) / (v - 1));
		info->SpareRegionDepthInSUs = spareRegionDepthInPUs * layoutPtr->SUsPerPU;
d169 2
a170 1
		numCompleteSpareRegionsPerDisk = PUsPerDisk / spareRegionDepthInPUs;
d174 2
a175 1
		/* assume conservatively that we need the full amount of spare
d179 4
a182 2
		 * may actually include some fulltables. */
		extraPUsPerDisk -= (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);
d188 5
a192 2
		complete_FT_count = raidPtr->numRow * (numCompleteSpareRegionsPerDisk * (info->TablesPerSpareRegion / k) + i / k);
		info->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;
d195 6
a200 3
		/* note that in the last spare region, the spare space is
		 * complete even though data/parity space is not */
		totSparePUsPerDisk = (numCompleteSpareRegionsPerDisk + 1) * (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);
d204 2
a205 1
		    ((complete_FT_count / raidPtr->numRow) * info->FullTableDepthInPUs +	/* data & parity space */
d210 2
a211 1
		    (complete_FT_count * info->FullTableDepthInPUs + info->ExtraTablesPerDisk * info->TableDepthInPUs)
d215 21
a235 13
		/* non-dist spare case:  force each disk to contain an
		 * integral number of tables */
		layoutPtr->stripeUnitsPerDisk /= (info->TableDepthInPUs * layoutPtr->SUsPerPU);
		layoutPtr->stripeUnitsPerDisk *= (info->TableDepthInPUs * layoutPtr->SUsPerPU);

		/* compute the number of tables in the last fulltable, which
		 * need not be complete */
		complete_FT_count =
		    ((layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU) / info->FullTableDepthInPUs) * raidPtr->numRow;

		info->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;
		info->ExtraTablesPerDisk =
		    ((layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU) / info->TableDepthInPUs) % k;
d238 2
a239 1
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;
d241 4
a244 2
	/* find the disk offset of the stripe unit where the last fulltable
	 * starts */
d246 2
a247 1
	diskOffsetOfLastFullTableInSUs = numCompleteFullTablesPerDisk * info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
d249 2
a250 1
		SpareSpaceInSUs = numCompleteSpareRegionsPerDisk * info->SpareSpaceDepthPerRegionInSUs;
d253 2
a254 1
		    diskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;
d259 1
a259 1
	/* 4.  create and initialize the lookup tables */
d263 1
d267 3
a269 1
	info->BlockTable = rf_make_2d_array(info->TableDepthInPUs * layoutPtr->SUsPerPU, raidPtr->numCol, raidPtr->cleanupList);
d281 1
a281 1
	/* initialize offset table */
d284 2
a285 1
			info->OffsetTable[i][j] = first_avail_slot[info->LayoutTable[i][j]];
d289 1
a289 1
	/* initialize block table */
d293 2
a294 1
				info->BlockTable[(info->OffsetTable[i][j] * layoutPtr->SUsPerPU) + l]
d303 1
a303 1
	/* 5.  set up the remaining redundant-but-useful parameters */
d305 5
a309 3
	raidPtr->totalSectors = (k * complete_FT_count + raidPtr->numRow * info->ExtraTablesPerDisk) *
	    info->SUsPerTable * layoutPtr->sectorsPerStripeUnit;
	layoutPtr->numStripe = (raidPtr->totalSectors / layoutPtr->sectorsPerStripeUnit) / (k - 2);
d311 9
a319 5
	/* strange evaluation order below to try and minimize overflow
	 * problems */

	layoutPtr->dataSectorsPerStripe = (k - 2) * layoutPtr->sectorsPerStripeUnit;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;
d326 2
a327 2
int 
rf_GetDefaultNumFloatingReconBuffersPQ(RF_Raid_t * raidPtr)
d329 1
a329 1
	int     def_decl;
d335 3
a337 8
void 
rf_MapSectorDeclusteredPQ(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d340 2
a341 1
	RF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d346 2
a347 1
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
d350 2
a351 1
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);
d353 2
a354 2
	FullTableID = SUID / sus_per_fulltable;	/* fulltable ID within array
						 * (across rows) */
d356 4
a359 2
	FullTableID /= raidPtr->numRow;	/* convert to fulltable ID on this
					 * disk */
d372 5
a376 5
           TableIDs go from 0 .. GroupSize-1 inclusive.
           PUsPerBlock is k-2.
           We want the tableIDs to rotate from the
           right, so use GroupSize
           */
d381 2
a382 1
			BlockOffset++;	/* P on last drive, Q on first */
d384 3
a386 1
			BlockOffset += ((BlockOffset >= RepIndex) ? 2 : 0);	/* skip over PQ */
d390 1
a390 1
	/* remap to distributed spare space if indicated */
d392 3
a394 1
		rf_remap_to_spare_space(layoutPtr, info, *row, FullTableID, TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col, &outSU);
d398 19
a416 11
		outSU += FullTableID * fulltable_depth;	/* offs to strt of FT */
		outSU += SpareSpace;	/* skip rsvd spare space */
		outSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;	/* offs to strt of tble */
		outSU += info->OffsetTable[BlockID][BlockOffset] * layoutPtr->SUsPerPU;	/* offs to the PU */
	}
	outSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);	/* offs to the SU within
										 * a PU */

	/* convert SUs to sectors, and, if not aligned to SU boundary, add in
	 * offset to sector */
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);
d420 3
a422 8
void 
rf_MapParityDeclusteredPQ(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d425 2
a426 1
	RF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d431 2
a432 1
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
d435 2
a436 1
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);
d438 1
a438 1
	/* compute row & (possibly) spare space exactly as before */
d441 2
a442 2
	FullTableID /= raidPtr->numRow;	/* convert to fulltable ID on this
					 * disk */
d447 1
a447 1
	/* compute BlockID and RepIndex exactly as before */
d455 3
a457 2
	/* the parity block is in the position indicated by RepIndex */
	RepIndex = (raidPtr->noRotate) ? info->PUsPerBlock : info->groupSize - 1 - TableID;
d463 4
a466 2
	/* compute sector as before, except use RepIndex instead of
	 * BlockOffset */
d474 2
a475 1
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);
d478 3
a480 8
void 
rf_MapQDeclusteredPQ(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d483 2
a484 1
	RF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d489 2
a490 1
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
d493 2
a494 1
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);
d496 1
a496 1
	/* compute row & (possibly) spare space exactly as before */
d499 2
a500 2
	FullTableID /= raidPtr->numRow;	/* convert to fulltable ID on this
					 * disk */
d505 1
a505 1
	/* compute BlockID and RepIndex exactly as before */
d513 3
a515 2
	/* the q block is in the position indicated by RepIndex */
	RepIndex = (raidPtr->noRotate) ? info->PUsPerBlock : info->groupSize - 1 - TableID;
d522 4
a525 2
	/* compute sector as before, except use RepIndex instead of
	 * BlockOffset */
d533 2
a534 1
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);
d536 5
a540 2
/* returns an array of ints identifying the disks that comprise the stripe containing the indicated address.
 * the caller must _never_ attempt to modify this array.
d542 3
a544 6
void 
rf_IdentifyStripeDeclusteredPQ(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t addr,
    RF_RowCol_t ** diskids,
    RF_RowCol_t * outRow)
d547 2
a548 1
	RF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d550 2
a551 1
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
d555 1
a555 1
	int     tableOffset;
d557 4
a560 3
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);
	FullTableID = SUID / sus_per_fulltable;	/* fulltable ID within array
						 * (across rows) */
d562 4
a565 4
	stripeID = rf_StripeUnitIDToStripeID(layoutPtr, SUID);	/* find stripe offset
								 * into array */
	tableOffset = (stripeID % info->BlocksPerTable);	/* find offset into
								 * block design table */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_declusterPQ.c,v 1.1 1999/01/11 14:29:14 niklas Exp $	*/
d86 1
d88 1
@


1.2.6.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d33 2
a34 2
 * Mapping code for declustered P & Q or declustered EvenOdd.
 * Much code borrowed from rf_decluster.c
d36 1
a36 1
 *****************************************************************************/
d49 1
a49 1
/* Configuration code. */
d51 5
a55 3
int
rf_ConfigureDeclusteredPQ(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d58 4
a61 4
	int b, v, k, r, lambda;	/* block design params */
	int i, j, l;
	int *first_avail_slot;
	int complete_FT_count, SUID;
d63 6
a68 6
	int numCompleteFullTablesPerDisk;
	int PUsPerDisk, spareRegionDepthInPUs, extraPUsPerDisk;
	int numCompleteSpareRegionsPerDisk = 0;
	int totSparePUsPerDisk;
	int diskOffsetOfLastFullTableInSUs, SpareSpaceInSUs;
	char *cfgBuf = (char *)(cfgPtr->layoutSpecific);
a85 1
#ifdef	RAIDDEBUG
a86 1
#endif	/* RAIDDEBUG */
d89 2
a90 3
	/* 1. Create layout specific structure. */
	RF_MallocAndAdd(info, sizeof(RF_DeclusteredConfigInfo_t),
	    (RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList);
d95 5
a99 9
	/*
	 * 2. The sparemaps are generated assuming that parity is rotated, so
	 * we issue a warning if both distributed sparing and no-rotate are on
	 * at the same time.
	 */
	if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) &&
	    raidPtr->noRotate) {
		RF_ERRORMSG("Warning:  distributed sparing specified without"
		    " parity rotation.\n");
d102 1
a102 2
		RF_ERRORMSG2("RAID: config error: table element count (%d)"
		    " not equal to no. of cols (%d).\n", v, raidPtr->numCol);
d105 1
a105 1
	/* 3. Set up the values used in devRaidMap. */
d109 2
a110 3
	info->SUsPerTable = b * info->PUsPerBlock * layoutPtr->SUsPerPU;
		/* b blks, k-1 SUs each. */
	info->SUsPerFullTable = k * info->SUsPerTable;	/* Rot k times. */
d113 1
a113 2
	info->FullTableDepthInPUs = info->TableDepthInPUs * k;
		/* k repetitions. */
d115 2
a116 3
	/* Used only in distributed sparing case. */
	info->FullTablesPerSpareRegion = (v - 1) / rf_gcd(r, v - 1);
		/* (v-1)/gcd fulltables. */
d118 1
a118 2
	info->SpareSpaceDepthPerRegionInSUs = (r * info->TablesPerSpareRegion
	    / (v - 1)) * layoutPtr->SUsPerPU;
d120 1
a120 1
	/* Check to make sure the block design is sufficiently small. */
d122 5
a126 9
		if (info->FullTableDepthInPUs * layoutPtr->SUsPerPU +
		    info->SpareSpaceDepthPerRegionInSUs >
		    layoutPtr->stripeUnitsPerDisk) {
			RF_ERRORMSG3("RAID: config error: Full Table depth"
			    " (%d) + Spare Space (%d) larger than disk size"
			    " (%d) (BD too big).\n",
			    (int)info->FullTableDepthInPUs,
			    (int)info->SpareSpaceDepthPerRegionInSUs,
			    (int)layoutPtr->stripeUnitsPerDisk);
d130 2
a131 4
		if (info->TableDepthInPUs * layoutPtr->SUsPerPU >
		    layoutPtr->stripeUnitsPerDisk) {
			RF_ERRORMSG2("RAID: config error: Table depth (%d)"
			    " larger than disk size (%d) (BD too big).\n",
d138 3
a140 4
	/*
	 * Compute the size of each disk, and the number of tables in the last
	 * fulltable (which need not be complete).
	 */
d143 4
a146 7
		PUsPerDisk = layoutPtr->stripeUnitsPerDisk /
		    layoutPtr->SUsPerPU;
		spareRegionDepthInPUs = (info->TablesPerSpareRegion *
		    info->TableDepthInPUs + (info->TablesPerSpareRegion *
		    info->TableDepthInPUs) / (v - 1));
		info->SpareRegionDepthInSUs = spareRegionDepthInPUs *
		    layoutPtr->SUsPerPU;
d148 1
a148 2
		numCompleteSpareRegionsPerDisk = PUsPerDisk /
		    spareRegionDepthInPUs;
d152 1
a152 2
		/*
		 * Assume conservatively that we need the full amount of spare
d156 2
a157 4
		 * may actually include some fulltables.
		 */
		extraPUsPerDisk -= (info->SpareSpaceDepthPerRegionInSUs /
		    layoutPtr->SUsPerPU);
d163 2
a164 5
		complete_FT_count = raidPtr->numRow *
		    (numCompleteSpareRegionsPerDisk *
		    (info->TablesPerSpareRegion / k) + i / k);
		info->FullTableLimitSUID = complete_FT_count *
		    info->SUsPerFullTable;
d167 3
a169 6
		/*
		 * Note that in the last spare region, the spare space is
		 * complete even though data/parity space is not.
		 */
		totSparePUsPerDisk = (numCompleteSpareRegionsPerDisk + 1) *
		    (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);
d173 1
a173 2
		    ((complete_FT_count / raidPtr->numRow) *
		    info->FullTableDepthInPUs +	/* data & parity space */
d178 1
a178 2
		    (complete_FT_count * info->FullTableDepthInPUs +
		    info->ExtraTablesPerDisk * info->TableDepthInPUs)
d182 13
a194 21
		/*
		 * Non-dist spare case:  force each disk to contain an
		 * integral number of tables.
		 */
		layoutPtr->stripeUnitsPerDisk /=
		    (info->TableDepthInPUs * layoutPtr->SUsPerPU);
		layoutPtr->stripeUnitsPerDisk *=
		    (info->TableDepthInPUs * layoutPtr->SUsPerPU);

		/*
		 * Compute the number of tables in the last fulltable, which
		 * need not be complete.
		 */
		complete_FT_count = ((layoutPtr->stripeUnitsPerDisk /
		    layoutPtr->SUsPerPU) / info->FullTableDepthInPUs) *
		    raidPtr->numRow;

		info->FullTableLimitSUID = complete_FT_count *
		    info->SUsPerFullTable;
		info->ExtraTablesPerDisk = ((layoutPtr->stripeUnitsPerDisk /
		    layoutPtr->SUsPerPU) / info->TableDepthInPUs) % k;
d197 1
a197 2
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;
d199 2
a200 4
	/*
	 * Find the disk offset of the stripe unit where the last
	 * fulltable starts.
	 */
d202 1
a202 2
	diskOffsetOfLastFullTableInSUs = numCompleteFullTablesPerDisk *
	    info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
d204 1
a204 2
		SpareSpaceInSUs = numCompleteSpareRegionsPerDisk *
		    info->SpareSpaceDepthPerRegionInSUs;
d207 1
a207 2
		    diskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk *
		    info->TableDepthInPUs * layoutPtr->SUsPerPU;
d212 1
a212 1
	/* 4. Create and initialize the lookup tables. */
a215 1

d219 1
a219 3

	info->BlockTable = rf_make_2d_array(info->TableDepthInPUs *
	    layoutPtr->SUsPerPU, raidPtr->numCol, raidPtr->cleanupList);
d231 1
a231 1
	/* Initialize offset table. */
d234 1
a234 2
			info->OffsetTable[i][j] =
			    first_avail_slot[info->LayoutTable[i][j]];
d238 1
a238 1
	/* Initialize block table. */
d242 1
a242 2
				info->BlockTable[(info->OffsetTable[i][j] *
				     layoutPtr->SUsPerPU) + l]
d251 1
a251 1
	/* 5. Set up the remaining redundant-but-useful parameters. */
d253 3
a255 5
	raidPtr->totalSectors = (k * complete_FT_count + raidPtr->numRow *
	    info->ExtraTablesPerDisk) * info->SUsPerTable *
	    layoutPtr->sectorsPerStripeUnit;
	layoutPtr->numStripe = (raidPtr->totalSectors /
	    layoutPtr->sectorsPerStripeUnit) / (k - 2);
d257 5
a261 9
	/*
	 * Strange evaluation order below to try and minimize overflow
	 * problems.
	 */

	layoutPtr->dataSectorsPerStripe = (k - 2) *
	    layoutPtr->sectorsPerStripeUnit;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
d268 2
a269 2
int
rf_GetDefaultNumFloatingReconBuffersPQ(RF_Raid_t *raidPtr)
d271 1
a271 1
	int def_decl;
d277 8
a284 3
void
rf_MapSectorDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d287 1
a287 2
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d292 1
a292 2
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
d295 1
a295 2
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);
d297 2
a298 2
	/* Fulltable ID within array (across rows). */
	FullTableID = SUID / sus_per_fulltable;
d300 2
a301 4

	/* Convert to fulltable ID on this disk. */
	FullTableID /= raidPtr->numRow;

d314 5
a318 5
	 * TableIDs go from 0 .. GroupSize-1 inclusive.
	 * PUsPerBlock is k-2.
	 * We want the tableIDs to rotate from the
	 * right, so use GroupSize.
	 */
d323 1
a323 2
			/* P on last drive, Q on first. */
			BlockOffset++;
d325 1
a325 3
			/* Skip over PQ. */
			BlockOffset += ((BlockOffset >= RepIndex) ? 2 : 0);

d329 1
a329 1
	/* Remap to distributed spare space if indicated. */
d331 1
a331 3
		rf_remap_to_spare_space(layoutPtr, info, *row, FullTableID,
		    TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col,
		    &outSU);
d335 11
a345 19
		outSU += FullTableID * fulltable_depth;
			/* Offset to strt of FT. */
		outSU += SpareSpace;
			/* Skip reserved spare space. */
		outSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;
			/* Offset to start of table. */
		outSU += info->OffsetTable[BlockID][BlockOffset] *
		    layoutPtr->SUsPerPU;
			/* Offset to the PU. */
	}
	outSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);
		/* Offset to the SU within a PU. */

	/*
	 * Convert SUs to sectors, and, if not aligned to SU boundary, add in
	 * offset to sector.
	 */
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit +
	    (raidSector % layoutPtr->sectorsPerStripeUnit);
d349 8
a356 3
void
rf_MapParityDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d359 1
a359 2
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d364 1
a364 2
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
d367 1
a367 2
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);
d369 1
a369 1
	/* Compute row & (possibly) spare space exactly as before. */
d372 2
a373 2
	/* Convert to fulltable ID on this disk. */
	FullTableID /= raidPtr->numRow;
d378 1
a378 1
	/* Compute BlockID and RepIndex exactly as before. */
d386 2
a387 3
	/* The parity block is in the position indicated by RepIndex. */
	RepIndex = (raidPtr->noRotate) ?
	    info->PUsPerBlock : info->groupSize - 1 - TableID;
d393 2
a394 4
	/*
	 * Compute sector as before, except use RepIndex instead of
	 * BlockOffset.
	 */
d402 1
a402 2
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit +
	    (raidSector % layoutPtr->sectorsPerStripeUnit);
d405 8
a412 3
void
rf_MapQDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d415 1
a415 2
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d420 1
a420 2
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
d423 1
a423 2
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);
d425 1
a425 1
	/* Compute row & (possibly) spare space exactly as before. */
d428 2
a429 2
	/* Convert to fulltable ID on this disk. */
	FullTableID /= raidPtr->numRow;
d434 1
a434 1
	/* Compute BlockID and RepIndex exactly as before. */
d442 2
a443 3
	/* The q block is in the position indicated by RepIndex. */
	RepIndex = (raidPtr->noRotate) ?
	    info->PUsPerBlock : info->groupSize - 1 - TableID;
d450 2
a451 4
	/*
	 * Compute sector as before, except use RepIndex instead of
	 * BlockOffset.
	 */
d459 1
a459 2
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit +
	    (raidSector % layoutPtr->sectorsPerStripeUnit);
d461 2
a462 5

/*
 * Returns an array of ints identifying the disks that comprise the stripe
 * containing the indicated address.
 * The caller must _never_ attempt to modify this array.
d464 6
a469 3
void
rf_IdentifyStripeDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
d472 1
a472 2
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d474 1
a474 2
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
d478 1
a478 1
	int tableOffset;
d480 3
a482 4
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);
	/* Fulltable ID within array (across rows). */
	FullTableID = SUID / sus_per_fulltable;
d484 4
a487 4
	/* Find stripe offset into array. */
	stripeID = rf_StripeUnitIDToStripeID(layoutPtr, SUID);
	/* Find offset into block design table. */
	tableOffset = (stripeID % info->BlocksPerTable);
@


1.2.16.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_declusterPQ.c,v 1.2 1999/02/16 00:02:35 niklas Exp $	*/
a85 1
#ifdef	RAIDDEBUG
a86 1
#endif	/* RAIDDEBUG */
@


1.2.16.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d33 2
a34 2
 * Mapping code for declustered P & Q or declustered EvenOdd.
 * Much code borrowed from rf_decluster.c
d36 1
a36 1
 *****************************************************************************/
d49 1
a49 1
/* Configuration code. */
d51 5
a55 3
int
rf_ConfigureDeclusteredPQ(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d58 4
a61 4
	int b, v, k, r, lambda;	/* block design params */
	int i, j, l;
	int *first_avail_slot;
	int complete_FT_count, SUID;
d63 6
a68 6
	int numCompleteFullTablesPerDisk;
	int PUsPerDisk, spareRegionDepthInPUs, extraPUsPerDisk;
	int numCompleteSpareRegionsPerDisk = 0;
	int totSparePUsPerDisk;
	int diskOffsetOfLastFullTableInSUs, SpareSpaceInSUs;
	char *cfgBuf = (char *)(cfgPtr->layoutSpecific);
d91 2
a92 3
	/* 1. Create layout specific structure. */
	RF_MallocAndAdd(info, sizeof(RF_DeclusteredConfigInfo_t),
	    (RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList);
d97 5
a101 9
	/*
	 * 2. The sparemaps are generated assuming that parity is rotated, so
	 * we issue a warning if both distributed sparing and no-rotate are on
	 * at the same time.
	 */
	if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) &&
	    raidPtr->noRotate) {
		RF_ERRORMSG("Warning:  distributed sparing specified without"
		    " parity rotation.\n");
d104 1
a104 2
		RF_ERRORMSG2("RAID: config error: table element count (%d)"
		    " not equal to no. of cols (%d).\n", v, raidPtr->numCol);
d107 1
a107 1
	/* 3. Set up the values used in devRaidMap. */
d111 2
a112 3
	info->SUsPerTable = b * info->PUsPerBlock * layoutPtr->SUsPerPU;
		/* b blks, k-1 SUs each. */
	info->SUsPerFullTable = k * info->SUsPerTable;	/* Rot k times. */
d115 1
a115 2
	info->FullTableDepthInPUs = info->TableDepthInPUs * k;
		/* k repetitions. */
d117 2
a118 3
	/* Used only in distributed sparing case. */
	info->FullTablesPerSpareRegion = (v - 1) / rf_gcd(r, v - 1);
		/* (v-1)/gcd fulltables. */
d120 1
a120 2
	info->SpareSpaceDepthPerRegionInSUs = (r * info->TablesPerSpareRegion
	    / (v - 1)) * layoutPtr->SUsPerPU;
d122 1
a122 1
	/* Check to make sure the block design is sufficiently small. */
d124 5
a128 9
		if (info->FullTableDepthInPUs * layoutPtr->SUsPerPU +
		    info->SpareSpaceDepthPerRegionInSUs >
		    layoutPtr->stripeUnitsPerDisk) {
			RF_ERRORMSG3("RAID: config error: Full Table depth"
			    " (%d) + Spare Space (%d) larger than disk size"
			    " (%d) (BD too big).\n",
			    (int)info->FullTableDepthInPUs,
			    (int)info->SpareSpaceDepthPerRegionInSUs,
			    (int)layoutPtr->stripeUnitsPerDisk);
d132 2
a133 4
		if (info->TableDepthInPUs * layoutPtr->SUsPerPU >
		    layoutPtr->stripeUnitsPerDisk) {
			RF_ERRORMSG2("RAID: config error: Table depth (%d)"
			    " larger than disk size (%d) (BD too big).\n",
d140 3
a142 4
	/*
	 * Compute the size of each disk, and the number of tables in the last
	 * fulltable (which need not be complete).
	 */
d145 4
a148 7
		PUsPerDisk = layoutPtr->stripeUnitsPerDisk /
		    layoutPtr->SUsPerPU;
		spareRegionDepthInPUs = (info->TablesPerSpareRegion *
		    info->TableDepthInPUs + (info->TablesPerSpareRegion *
		    info->TableDepthInPUs) / (v - 1));
		info->SpareRegionDepthInSUs = spareRegionDepthInPUs *
		    layoutPtr->SUsPerPU;
d150 1
a150 2
		numCompleteSpareRegionsPerDisk = PUsPerDisk /
		    spareRegionDepthInPUs;
d154 1
a154 2
		/*
		 * Assume conservatively that we need the full amount of spare
d158 2
a159 4
		 * may actually include some fulltables.
		 */
		extraPUsPerDisk -= (info->SpareSpaceDepthPerRegionInSUs /
		    layoutPtr->SUsPerPU);
d165 2
a166 5
		complete_FT_count = raidPtr->numRow *
		    (numCompleteSpareRegionsPerDisk *
		    (info->TablesPerSpareRegion / k) + i / k);
		info->FullTableLimitSUID = complete_FT_count *
		    info->SUsPerFullTable;
d169 3
a171 6
		/*
		 * Note that in the last spare region, the spare space is
		 * complete even though data/parity space is not.
		 */
		totSparePUsPerDisk = (numCompleteSpareRegionsPerDisk + 1) *
		    (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);
d175 1
a175 2
		    ((complete_FT_count / raidPtr->numRow) *
		    info->FullTableDepthInPUs +	/* data & parity space */
d180 1
a180 2
		    (complete_FT_count * info->FullTableDepthInPUs +
		    info->ExtraTablesPerDisk * info->TableDepthInPUs)
d184 13
a196 21
		/*
		 * Non-dist spare case:  force each disk to contain an
		 * integral number of tables.
		 */
		layoutPtr->stripeUnitsPerDisk /=
		    (info->TableDepthInPUs * layoutPtr->SUsPerPU);
		layoutPtr->stripeUnitsPerDisk *=
		    (info->TableDepthInPUs * layoutPtr->SUsPerPU);

		/*
		 * Compute the number of tables in the last fulltable, which
		 * need not be complete.
		 */
		complete_FT_count = ((layoutPtr->stripeUnitsPerDisk /
		    layoutPtr->SUsPerPU) / info->FullTableDepthInPUs) *
		    raidPtr->numRow;

		info->FullTableLimitSUID = complete_FT_count *
		    info->SUsPerFullTable;
		info->ExtraTablesPerDisk = ((layoutPtr->stripeUnitsPerDisk /
		    layoutPtr->SUsPerPU) / info->TableDepthInPUs) % k;
d199 1
a199 2
	raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk *
	    layoutPtr->sectorsPerStripeUnit;
d201 2
a202 4
	/*
	 * Find the disk offset of the stripe unit where the last
	 * fulltable starts.
	 */
d204 1
a204 2
	diskOffsetOfLastFullTableInSUs = numCompleteFullTablesPerDisk *
	    info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
d206 1
a206 2
		SpareSpaceInSUs = numCompleteSpareRegionsPerDisk *
		    info->SpareSpaceDepthPerRegionInSUs;
d209 1
a209 2
		    diskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk *
		    info->TableDepthInPUs * layoutPtr->SUsPerPU;
d214 1
a214 1
	/* 4. Create and initialize the lookup tables. */
a217 1

d221 1
a221 3

	info->BlockTable = rf_make_2d_array(info->TableDepthInPUs *
	    layoutPtr->SUsPerPU, raidPtr->numCol, raidPtr->cleanupList);
d233 1
a233 1
	/* Initialize offset table. */
d236 1
a236 2
			info->OffsetTable[i][j] =
			    first_avail_slot[info->LayoutTable[i][j]];
d240 1
a240 1
	/* Initialize block table. */
d244 1
a244 2
				info->BlockTable[(info->OffsetTable[i][j] *
				     layoutPtr->SUsPerPU) + l]
d253 1
a253 1
	/* 5. Set up the remaining redundant-but-useful parameters. */
d255 3
a257 5
	raidPtr->totalSectors = (k * complete_FT_count + raidPtr->numRow *
	    info->ExtraTablesPerDisk) * info->SUsPerTable *
	    layoutPtr->sectorsPerStripeUnit;
	layoutPtr->numStripe = (raidPtr->totalSectors /
	    layoutPtr->sectorsPerStripeUnit) / (k - 2);
d259 5
a263 9
	/*
	 * Strange evaluation order below to try and minimize overflow
	 * problems.
	 */

	layoutPtr->dataSectorsPerStripe = (k - 2) *
	    layoutPtr->sectorsPerStripeUnit;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
d270 2
a271 2
int
rf_GetDefaultNumFloatingReconBuffersPQ(RF_Raid_t *raidPtr)
d273 1
a273 1
	int def_decl;
d279 8
a286 3
void
rf_MapSectorDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d289 1
a289 2
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d294 1
a294 2
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
d297 1
a297 2
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);
d299 2
a300 2
	/* Fulltable ID within array (across rows). */
	FullTableID = SUID / sus_per_fulltable;
d302 2
a303 4

	/* Convert to fulltable ID on this disk. */
	FullTableID /= raidPtr->numRow;

d316 5
a320 5
	 * TableIDs go from 0 .. GroupSize-1 inclusive.
	 * PUsPerBlock is k-2.
	 * We want the tableIDs to rotate from the
	 * right, so use GroupSize.
	 */
d325 1
a325 2
			/* P on last drive, Q on first. */
			BlockOffset++;
d327 1
a327 3
			/* Skip over PQ. */
			BlockOffset += ((BlockOffset >= RepIndex) ? 2 : 0);

d331 1
a331 1
	/* Remap to distributed spare space if indicated. */
d333 1
a333 3
		rf_remap_to_spare_space(layoutPtr, info, *row, FullTableID,
		    TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col,
		    &outSU);
d337 11
a347 19
		outSU += FullTableID * fulltable_depth;
			/* Offset to strt of FT. */
		outSU += SpareSpace;
			/* Skip reserved spare space. */
		outSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;
			/* Offset to start of table. */
		outSU += info->OffsetTable[BlockID][BlockOffset] *
		    layoutPtr->SUsPerPU;
			/* Offset to the PU. */
	}
	outSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);
		/* Offset to the SU within a PU. */

	/*
	 * Convert SUs to sectors, and, if not aligned to SU boundary, add in
	 * offset to sector.
	 */
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit +
	    (raidSector % layoutPtr->sectorsPerStripeUnit);
d351 8
a358 3
void
rf_MapParityDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d361 1
a361 2
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d366 1
a366 2
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
d369 1
a369 2
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);
d371 1
a371 1
	/* Compute row & (possibly) spare space exactly as before. */
d374 2
a375 2
	/* Convert to fulltable ID on this disk. */
	FullTableID /= raidPtr->numRow;
d380 1
a380 1
	/* Compute BlockID and RepIndex exactly as before. */
d388 2
a389 3
	/* The parity block is in the position indicated by RepIndex. */
	RepIndex = (raidPtr->noRotate) ?
	    info->PUsPerBlock : info->groupSize - 1 - TableID;
d395 2
a396 4
	/*
	 * Compute sector as before, except use RepIndex instead of
	 * BlockOffset.
	 */
d404 1
a404 2
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit +
	    (raidSector % layoutPtr->sectorsPerStripeUnit);
d407 8
a414 3
void
rf_MapQDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d417 1
a417 2
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d422 1
a422 2
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
d425 1
a425 2
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);
d427 1
a427 1
	/* Compute row & (possibly) spare space exactly as before. */
d430 2
a431 2
	/* Convert to fulltable ID on this disk. */
	FullTableID /= raidPtr->numRow;
d436 1
a436 1
	/* Compute BlockID and RepIndex exactly as before. */
d444 2
a445 3
	/* The q block is in the position indicated by RepIndex. */
	RepIndex = (raidPtr->noRotate) ?
	    info->PUsPerBlock : info->groupSize - 1 - TableID;
d452 2
a453 4
	/*
	 * Compute sector as before, except use RepIndex instead of
	 * BlockOffset.
	 */
d461 1
a461 2
	*diskSector = outSU * layoutPtr->sectorsPerStripeUnit +
	    (raidSector % layoutPtr->sectorsPerStripeUnit);
d463 2
a464 5

/*
 * Returns an array of ints identifying the disks that comprise the stripe
 * containing the indicated address.
 * The caller must _never_ attempt to modify this array.
d466 6
a471 3
void
rf_IdentifyStripeDeclusteredPQ(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
d474 1
a474 2
	RF_DeclusteredConfigInfo_t *info =
	    (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
d476 1
a476 2
	RF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs *
	    layoutPtr->SUsPerPU;
d480 1
a480 1
	int tableOffset;
d482 3
a484 4
	rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable,
	    &fulltable_depth, &base_suid);
	/* Fulltable ID within array (across rows). */
	FullTableID = SUID / sus_per_fulltable;
d486 4
a489 4
	/* Find stripe offset into array. */
	stripeID = rf_StripeUnitIDToStripeID(layoutPtr, SUID);
	/* Find offset into block design table. */
	tableOffset = (stripeID % info->BlocksPerTable);
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_declusterPQ.c,v 1.1 1998/11/13 04:20:28 oster Exp $	*/
/*	$NetBSD: rf_declusterPQ.c,v 1.1 1998/11/13 04:20:28 oster Exp $	*/
a37 124
/*
 * $Header: /cvs/netbsd-src/sys/dev/raidframe/rf_declusterPQ.c,v 1.1.1.1 1998/11/13 21:44:07 niklas Exp $
 *
 * Log: rf_declusterPQ.c,v 
 * Revision 1.34  1996/08/21 19:47:14  jimz
 * fix bogus return values from config
 *
 * Revision 1.33  1996/08/21  15:09:16  jimz
 * cleanup debugging spoo
 *
 * Revision 1.32  1996/08/21  04:13:36  jimz
 * debug with EvenOdd
 *
 * Revision 1.31  1996/08/20  22:41:54  jimz
 * 2 parity disks, not 1
 *
 * Revision 1.30  1996/07/31  16:56:18  jimz
 * dataBytesPerStripe, sectorsPerDisk init arch-indep.
 *
 * Revision 1.29  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.28  1996/07/13  00:00:59  jimz
 * sanitized generalized reconstruction architecture
 * cleaned up head sep, rbuf problems
 *
 * Revision 1.27  1996/06/11  08:45:12  jimz
 * improved error-checking on array configuration
 *
 * Revision 1.26  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.25  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.24  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.23  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.22  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.21  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.20  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.19  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.18  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.17  1996/05/17  00:52:56  jimz
 * RepIndex was not being initialized before the computation of
 * RepIndexQ in MapQDeclusteredPQ(). I copied the initialization
 * from MapParityDeclusteredPQ(). Hope that was right.
 *
 * Revision 1.16  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.15  1995/12/01  15:57:46  root
 * added copyright info
 *
 * Revision 1.14  1995/11/17  19:00:13  wvcii
 * added prototyping to MapParity
 * created MapQ
 *
 * Revision 1.13  1995/10/05  22:20:48  jimz
 * free_1d_array() takes two args; provide them both
 *
 * Revision 1.12  1995/09/06  19:26:33  wvcii
 * offset cfgBuf by sparemap length (ConfigureDeclusteredPQ)
 *
 * Revision 1.11  95/06/23  13:41:11  robby
 * updeated to prototypes in rf_layout.h
 * 
 * Revision 1.10  1995/05/02  22:46:53  holland
 * minor code cleanups.
 *
 * Revision 1.9  1995/03/15  20:45:23  holland
 * distr sparing changes.
 *
 * Revision 1.8  1995/03/01  20:25:48  holland
 * kernelization changes
 *
 * Revision 1.7  1995/02/17  19:39:56  holland
 * added size param to all calls to Free().
 * this is ignored at user level, but necessary in the kernel.
 *
 * Revision 1.6  1995/02/10  17:34:10  holland
 * kernelization changes
 *
 * Revision 1.5  1995/02/03  22:31:36  holland
 * many changes related to kernelization
 *
 * Revision 1.4  1995/02/01  15:13:05  holland
 * moved #include of general.h out of raid.h and into each file
 *
 * Revision 1.3  1995/02/01  14:25:19  holland
 * began changes for kernelization:
 *      changed all instances of mutex_t and cond_t to DECLARE macros
 *      converted configuration code to use config structure
 *
 * Revision 1.2  1994/11/28  22:13:56  danner
 * corrected some mapping bugs.
 *
 */
d51 5
a55 4
int rf_ConfigureDeclusteredPQ(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
d57 154
a210 195
    RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
    int b, v, k, r, lambda;				/* block design params */
    int i, j, l;
    int *first_avail_slot;
    int  complete_FT_count, SUID;
    RF_DeclusteredConfigInfo_t *info;
    int numCompleteFullTablesPerDisk;
    int PUsPerDisk, spareRegionDepthInPUs, numCompleteSpareRegionsPerDisk = 0, extraPUsPerDisk;
    int totSparePUsPerDisk;
    int diskOffsetOfLastFullTableInSUs, SpareSpaceInSUs;
    char *cfgBuf = (char *) (cfgPtr->layoutSpecific);

    cfgBuf += RF_SPAREMAP_NAME_LEN;

    b        = *( (int *) cfgBuf);   cfgBuf += sizeof(int);
    v        = *( (int *) cfgBuf);   cfgBuf += sizeof(int);
    k        = *( (int *) cfgBuf);   cfgBuf += sizeof(int);
    r        = *( (int *) cfgBuf);   cfgBuf += sizeof(int);
    lambda   = *( (int *) cfgBuf);   cfgBuf += sizeof(int);
    raidPtr->noRotate = *( (int *) cfgBuf);   cfgBuf += sizeof(int);

    if (k <= 2) {
      printf("RAIDFRAME: k=%d, minimum value 2\n", k);
      return(EINVAL);
    }

    /* 1. create layout specific structure */
    RF_MallocAndAdd(info, sizeof(RF_DeclusteredConfigInfo_t), (RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList);
    if (info == NULL)
      return(ENOMEM);
    layoutPtr->layoutSpecificInfo = (void *) info;

    /* the sparemaps are generated assuming that parity is rotated, so we issue
     * a warning if both distributed sparing and no-rotate are on at the same time
     */
    if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) && raidPtr->noRotate) {
	RF_ERRORMSG("Warning:  distributed sparing specified without parity rotation.\n");
    }

    if (raidPtr->numCol != v) {
        RF_ERRORMSG2("RAID: config error: table element count (%d) not equal to no. of cols (%d)\n", v, raidPtr->numCol);
        return(EINVAL);
    }

    /* 3.  set up the values used in devRaidMap */
    info->BlocksPerTable = b;
    info->NumParityReps = info->groupSize = k;
    info->PUsPerBlock = k-2;  /* PQ */
    info->SUsPerTable = b * info->PUsPerBlock * layoutPtr->SUsPerPU;/* b blks, k-1 SUs each */
    info->SUsPerFullTable = k * info->SUsPerTable;	/* rot k times */
    info->SUsPerBlock = info->PUsPerBlock * layoutPtr->SUsPerPU;
    info->TableDepthInPUs = (b*k) / v;
    info->FullTableDepthInPUs = info->TableDepthInPUs * k;		/* k repetitions */

    /* used only in distributed sparing case */
    info->FullTablesPerSpareRegion = (v-1) / rf_gcd(r, v-1);		/* (v-1)/gcd fulltables */
    info->TablesPerSpareRegion = k * info->FullTablesPerSpareRegion;
    info->SpareSpaceDepthPerRegionInSUs = (r * info->TablesPerSpareRegion / (v-1)) * layoutPtr->SUsPerPU;

    /* check to make sure the block design is sufficiently small */
    if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
        if (info->FullTableDepthInPUs * layoutPtr->SUsPerPU + info->SpareSpaceDepthPerRegionInSUs > layoutPtr->stripeUnitsPerDisk) {
	    RF_ERRORMSG3("RAID: config error: Full Table depth (%d) + Spare Space (%d) larger than disk size (%d) (BD too big)\n",
			 (int)info->FullTableDepthInPUs, 
			 (int)info->SpareSpaceDepthPerRegionInSUs, 
			 (int)layoutPtr->stripeUnitsPerDisk);
	    return(EINVAL);
	}
    } else {
	if (info->TableDepthInPUs * layoutPtr->SUsPerPU > layoutPtr->stripeUnitsPerDisk) {
	    RF_ERRORMSG2("RAID: config error: Table depth (%d) larger than disk size (%d) (BD too big)\n",
			 (int)(info->TableDepthInPUs * layoutPtr->SUsPerPU), 
			 (int)layoutPtr->stripeUnitsPerDisk);
	    return(EINVAL);
	}
    }

	
    /* compute the size of each disk, and the number of tables in the last fulltable (which
     * need not be complete)
     */
    if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
	
	PUsPerDisk = layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU;
	spareRegionDepthInPUs = (info->TablesPerSpareRegion * info->TableDepthInPUs +
				 (info->TablesPerSpareRegion * info->TableDepthInPUs) / (v-1));
	info->SpareRegionDepthInSUs = spareRegionDepthInPUs * layoutPtr->SUsPerPU;
	
	numCompleteSpareRegionsPerDisk = PUsPerDisk / spareRegionDepthInPUs;
	info->NumCompleteSRs = numCompleteSpareRegionsPerDisk;
	extraPUsPerDisk = PUsPerDisk % spareRegionDepthInPUs;

	/* assume conservatively that we need the full amount of spare space in one region in order
	 * to provide spares for the partial spare region at the end of the array.  We set "i" to
	 * the number of tables in the partial spare region.  This may actually include some fulltables.
	 */
	extraPUsPerDisk -= (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);
	if (extraPUsPerDisk <= 0) i = 0;
	else i = extraPUsPerDisk/info->TableDepthInPUs;

	complete_FT_count = raidPtr->numRow * (numCompleteSpareRegionsPerDisk * (info->TablesPerSpareRegion/k) + i/k);
        info->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;
	info->ExtraTablesPerDisk = i % k;

	/* note that in the last spare region, the spare space is complete even though data/parity space is not */
	totSparePUsPerDisk = (numCompleteSpareRegionsPerDisk+1) * (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);
	info->TotSparePUsPerDisk = totSparePUsPerDisk;
	
	layoutPtr->stripeUnitsPerDisk =
	    ((complete_FT_count/raidPtr->numRow) * info->FullTableDepthInPUs +	 	/* data & parity space */
	     info->ExtraTablesPerDisk * info->TableDepthInPUs +
	     totSparePUsPerDisk								/* spare space */
	    ) * layoutPtr->SUsPerPU;
	layoutPtr->dataStripeUnitsPerDisk = 
	    (complete_FT_count * info->FullTableDepthInPUs + info->ExtraTablesPerDisk * info->TableDepthInPUs)
	    * layoutPtr->SUsPerPU * (k-1) / k;

    } else {
        /* non-dist spare case:  force each disk to contain an integral number of tables */
        layoutPtr->stripeUnitsPerDisk /= (info->TableDepthInPUs * layoutPtr->SUsPerPU);
        layoutPtr->stripeUnitsPerDisk *= (info->TableDepthInPUs * layoutPtr->SUsPerPU);

	/* compute the number of tables in the last fulltable, which need not be complete */
        complete_FT_count =
            ((layoutPtr->stripeUnitsPerDisk/layoutPtr->SUsPerPU) / info->FullTableDepthInPUs) * raidPtr->numRow;
	    
        info->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;
        info->ExtraTablesPerDisk =
		((layoutPtr->stripeUnitsPerDisk/layoutPtr->SUsPerPU) / info->TableDepthInPUs) % k;
    }

    raidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;

    /* find the disk offset of the stripe unit where the last fulltable starts */
    numCompleteFullTablesPerDisk = complete_FT_count / raidPtr->numRow;
    diskOffsetOfLastFullTableInSUs = numCompleteFullTablesPerDisk * info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
    if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
        SpareSpaceInSUs  = numCompleteSpareRegionsPerDisk * info->SpareSpaceDepthPerRegionInSUs;
        diskOffsetOfLastFullTableInSUs += SpareSpaceInSUs;
        info->DiskOffsetOfLastSpareSpaceChunkInSUs =
	    diskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;
    }
    info->DiskOffsetOfLastFullTableInSUs = diskOffsetOfLastFullTableInSUs;
    info->numCompleteFullTablesPerDisk = numCompleteFullTablesPerDisk;
	
    /* 4.  create and initialize the lookup tables */
    info->LayoutTable = rf_make_2d_array(b, k, raidPtr->cleanupList);
    if (info->LayoutTable == NULL)
      return(ENOMEM);
    info->OffsetTable = rf_make_2d_array(b, k, raidPtr->cleanupList);
    if (info->OffsetTable == NULL)
      return(ENOMEM);
    info->BlockTable  =	rf_make_2d_array(info->TableDepthInPUs*layoutPtr->SUsPerPU, raidPtr->numCol, raidPtr->cleanupList);
    if (info->BlockTable == NULL)
      return(ENOMEM);

    first_avail_slot  = (int *) rf_make_1d_array(v, NULL);
    if (first_avail_slot == NULL)
      return(ENOMEM);

    for (i=0; i<b; i++)
      for (j=0; j<k; j++)
        info->LayoutTable[i][j] = *cfgBuf++;

    /* initialize offset table */
    for (i=0; i<b; i++) for (j=0; j<k; j++) {
        info->OffsetTable[i][j] = first_avail_slot[ info->LayoutTable[i][j] ];
        first_avail_slot[ info->LayoutTable[i][j] ]++;
    }

    /* initialize block table */
    for (SUID=l=0; l<layoutPtr->SUsPerPU; l++) {
        for (i=0; i<b; i++) {
            for (j=0; j<k; j++) {
                info->BlockTable[ (info->OffsetTable[i][j] * layoutPtr->SUsPerPU) + l ]
		                [ info->LayoutTable[i][j] ] = SUID;
            }
            SUID++;
        }
    }

    rf_free_1d_array(first_avail_slot, v);

    /* 5.  set up the remaining redundant-but-useful parameters */

    raidPtr->totalSectors = (k*complete_FT_count + raidPtr->numRow*info->ExtraTablesPerDisk) *
    			  info->SUsPerTable * layoutPtr->sectorsPerStripeUnit;
    layoutPtr->numStripe = (raidPtr->totalSectors / layoutPtr->sectorsPerStripeUnit) / (k-2);

    /* strange evaluation order below to try and minimize overflow problems */

    layoutPtr->dataSectorsPerStripe = (k-2) * layoutPtr->sectorsPerStripeUnit;
    layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;
    layoutPtr->numDataCol = k-2;
    layoutPtr->numParityCol = 2;
d212 54
a265 1
    return(0);
d268 2
a269 1
int rf_GetDefaultNumFloatingReconBuffersPQ(RF_Raid_t *raidPtr)
d271 1
a271 1
  int def_decl;
d273 2
a274 2
  def_decl = rf_GetDefaultNumFloatingReconBuffersDeclustered(raidPtr);
  return(RF_MAX(3 * raidPtr->numCol, def_decl));
d277 8
a284 7
void rf_MapSectorDeclusteredPQ(
  RF_Raid_t         *raidPtr,
  RF_RaidAddr_t      raidSector,
  RF_RowCol_t       *row,
  RF_RowCol_t       *col,
  RF_SectorNum_t    *diskSector,
  int                remap)
d286 60
a345 58
    RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
    RF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
    RF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;
    RF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset; 
    RF_StripeNum_t BlockID, BlockOffset, RepIndex;
    RF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;
    RF_StripeCount_t fulltable_depth  = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
    RF_StripeNum_t base_suid = 0, outSU, SpareRegion=0, SpareSpace=0;

    rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);
	    
    FullTableID     = SUID / sus_per_fulltable;		/* fulltable ID within array (across rows) */
    *row            = FullTableID % raidPtr->numRow;
    FullTableID    /= raidPtr->numRow;			/* convert to fulltable ID on this disk */
    if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
	SpareRegion = FullTableID / info->FullTablesPerSpareRegion;
        SpareSpace  = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;
    }
    FullTableOffset = SUID % sus_per_fulltable;
    TableID         = FullTableOffset / info->SUsPerTable;
    TableOffset     = FullTableOffset - TableID * info->SUsPerTable;
    BlockID         = TableOffset / info->PUsPerBlock;
    BlockOffset     = TableOffset - BlockID * info->PUsPerBlock;
    BlockID        %= info->BlocksPerTable;
    RF_ASSERT(BlockOffset < info->groupSize-2 );
    /*
       TableIDs go from 0 .. GroupSize-1 inclusive. 
       PUsPerBlock is k-2. 
       We want the tableIDs to rotate from the
       right, so use GroupSize
       */
    RepIndex        = info->groupSize - 1 - TableID;
    RF_ASSERT(RepIndex >= 0);
    if (!raidPtr->noRotate)
      {
	if (TableID==0)
	    BlockOffset++; /* P on last drive, Q on first */
	else
	  BlockOffset    += ((BlockOffset >= RepIndex) ? 2 : 0); /* skip over PQ */
	RF_ASSERT(BlockOffset < info->groupSize);
	*col            = info->LayoutTable[BlockID][BlockOffset];
      }

    /* remap to distributed spare space if indicated */
    if (remap) {
	rf_remap_to_spare_space(layoutPtr, info, *row, FullTableID, TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col, &outSU);
    } else {
    
        outSU	    = base_suid;
        outSU      += FullTableID * fulltable_depth;  				        /* offs to strt of FT */
        outSU	   += SpareSpace;						        /* skip rsvd spare space */
        outSU      += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;   	        /* offs to strt of tble */
        outSU      += info->OffsetTable[BlockID][BlockOffset] * layoutPtr->SUsPerPU;	/* offs to the PU */
    }
    outSU          += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);	        /* offs to the SU within a PU */
    
    /* convert SUs to sectors, and, if not aligned to SU boundary, add in offset to sector */
    *diskSector     = outSU*layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);
d349 8
a356 7
void rf_MapParityDeclusteredPQ(
  RF_Raid_t       *raidPtr,
  RF_RaidAddr_t    raidSector,
  RF_RowCol_t     *row,
  RF_RowCol_t     *col,
  RF_SectorNum_t  *diskSector,
  int              remap)
d358 45
a402 44
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  RF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
  RF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;
  RF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset; 
  RF_StripeNum_t BlockID, BlockOffset, RepIndex;
  RF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;
  RF_StripeCount_t fulltable_depth  = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
  RF_StripeNum_t base_suid = 0, outSU, SpareRegion, SpareSpace=0;
  
  rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);
  
  /* compute row & (possibly) spare space exactly as before */
  FullTableID     = SUID / sus_per_fulltable;
  *row            = FullTableID % raidPtr->numRow;
  FullTableID    /= raidPtr->numRow;			/* convert to fulltable ID on this disk */
  if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
    SpareRegion = FullTableID / info->FullTablesPerSpareRegion;
    SpareSpace  = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;
  }
  
  /* compute BlockID and RepIndex exactly as before */
  FullTableOffset = SUID % sus_per_fulltable;
  TableID         = FullTableOffset / info->SUsPerTable;
    TableOffset     = FullTableOffset - TableID * info->SUsPerTable;
    BlockID         = TableOffset / info->PUsPerBlock;
    BlockOffset     = TableOffset - BlockID * info->PUsPerBlock;
    BlockID        %= info->BlocksPerTable;

  /* the parity block is in the position indicated by RepIndex */
  RepIndex        = (raidPtr->noRotate) ? info->PUsPerBlock : info->groupSize - 1 - TableID;
  *col	    = info->LayoutTable[BlockID][RepIndex];
  
  if (remap)
    RF_PANIC();
  
  /* compute sector as before, except use RepIndex instead of BlockOffset */
  outSU        = base_suid;
  outSU       += FullTableID * fulltable_depth;
  outSU	+= SpareSpace;						/* skip rsvd spare space */
  outSU       += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;
  outSU       += info->OffsetTable[BlockID][RepIndex] * layoutPtr->SUsPerPU;
  outSU       += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);
  
  *diskSector  = outSU*layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);
d405 8
a412 7
void rf_MapQDeclusteredPQ(
  RF_Raid_t       *raidPtr,
  RF_RaidAddr_t    raidSector,
  RF_RowCol_t     *row,
  RF_RowCol_t     *col,
  RF_SectorNum_t  *diskSector,
  int              remap)
d414 43
a456 42
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  RF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
  RF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;
  RF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset; 
  RF_StripeNum_t BlockID, BlockOffset, RepIndex, RepIndexQ;
  RF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;
  RF_StripeCount_t fulltable_depth  = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
  RF_StripeNum_t base_suid = 0, outSU, SpareRegion, SpareSpace=0;
  
  rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);
    
  /* compute row & (possibly) spare space exactly as before */
  FullTableID     = SUID / sus_per_fulltable;
  *row            = FullTableID % raidPtr->numRow;
  FullTableID    /= raidPtr->numRow;			/* convert to fulltable ID on this disk */
  if ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {
    SpareRegion = FullTableID / info->FullTablesPerSpareRegion;
    SpareSpace  = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;
  }

  /* compute BlockID and RepIndex exactly as before */
  FullTableOffset = SUID % sus_per_fulltable;
  TableID         = FullTableOffset / info->SUsPerTable;
    TableOffset     = FullTableOffset - TableID * info->SUsPerTable;
    BlockID         = TableOffset / info->PUsPerBlock;
    BlockOffset     = TableOffset - BlockID * info->PUsPerBlock;
    BlockID        %= info->BlocksPerTable;

  /* the q block is in the position indicated by RepIndex */
  RepIndex        = (raidPtr->noRotate) ? info->PUsPerBlock : info->groupSize - 1 - TableID;
  RepIndexQ = ((RepIndex == (info->groupSize-1)) ? 0 : RepIndex+1);
  *col = info->LayoutTable[BlockID][RepIndexQ];
  
  if (remap)
    RF_PANIC();
  
  /* compute sector as before, except use RepIndex instead of BlockOffset */
  outSU        = base_suid;
  outSU       += FullTableID * fulltable_depth;
  outSU	+= SpareSpace;						/* skip rsvd spare space */
  outSU       += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;
  outSU       += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);
d458 2
a459 2
  outSU       += info->OffsetTable[BlockID][RepIndexQ] * layoutPtr->SUsPerPU;
  *diskSector = outSU*layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);
a460 1

d464 6
a469 5
void rf_IdentifyStripeDeclusteredPQ(
  RF_Raid_t        *raidPtr,
  RF_RaidAddr_t     addr,
  RF_RowCol_t     **diskids,
  RF_RowCol_t      *outRow)
d471 18
a488 15
  RF_RaidLayout_t *layoutPtr           = &(raidPtr->Layout);
  RF_DeclusteredConfigInfo_t *info     = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;
  RF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;
  RF_StripeCount_t fulltable_depth   = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;
  RF_StripeNum_t base_suid         = 0;
  RF_StripeNum_t SUID              = rf_RaidAddressToStripeUnitID(layoutPtr, addr);
  RF_StripeNum_t stripeID, FullTableID;
  int tableOffset;

  rf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);
  FullTableID     = SUID / sus_per_fulltable;		/* fulltable ID within array (across rows) */
  *outRow         = FullTableID % raidPtr->numRow;
  stripeID = rf_StripeUnitIDToStripeID(layoutPtr, SUID);                     /* find stripe offset into array */
  tableOffset = (stripeID % info->BlocksPerTable);                        /* find offset into block design table */
  *diskids = info->LayoutTable[tableOffset];
@

