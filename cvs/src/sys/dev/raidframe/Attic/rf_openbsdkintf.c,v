head	1.66;
access;
symbols
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.4
	OPENBSD_5_0:1.65.0.2
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.57.0.2
	OPENBSD_4_8_BASE:1.57
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.51.0.4
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.50.0.4
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.50.0.2
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.42.0.2
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.27.0.4
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.26.0.4
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.20
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.6
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.66
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.65;

1.65
date	2011.07.06.04.49.36;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	2011.06.21.16.46.00;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	2011.04.14.20.59.35;	author pea;	state Exp;
branches;
next	1.60;

1.60
date	2010.09.23.18.49.39;	author oga;	state Exp;
branches;
next	1.59;

1.59
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.57;

1.57
date	2010.06.26.23.24.45;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.23.13.49.35;	author naddy;	state Exp;
branches;
next	1.55;

1.55
date	2010.04.23.23.59.11;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.52;

1.52
date	2009.08.25.18.46.19;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2009.05.21.23.45.48;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2008.07.23.16.24.43;	author beck;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.48;

1.48
date	2008.06.15.00.36.41;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2008.03.26.00.48.54;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2008.03.24.01.16.58;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.05.16.09.49;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.05.16.01.02;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.09.16.50.23;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.23.03.11.34;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.20.18.18.47;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.12.02.02.17;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.07.00.49.08;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.05.00.38.22;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.28.12.32.13;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.15.00.53.26;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.21.12.20.51;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.08.05.53.45;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.08.05.32.55;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.10.01.00.51;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.18.14.18.18;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.28.02.47.14;	author pedro;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches
	1.26.4.1;
next	1.25;

1.25
date	2004.01.14.20.50.49;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.23.28.03;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.19.14.32.00;	author tdeval;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.12.02.03.46;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.09.15.10.20;	author tdeval;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.05.22.11.27;	author tdeval;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.28.23.38.10;	author tdeval;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.03.16.07;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.06.11.28.27;	author tdeval;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.23.00.39.47;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.29.21.51.18;	author tdeval;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.08.22.10.01;	author tdeval;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.08.08.16.07.43;	author peter;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.01.07.14.50.21;	author peter;	state Exp;
branches;
next	1.7;

1.7
date	99.12.03.22.38.11;	author art;	state Exp;
branches;
next	1.6;

1.6
date	99.08.03.13.56.37;	author peter;	state Exp;
branches;
next	1.5;

1.5
date	99.08.02.20.32.49;	author peter;	state Exp;
branches;
next	1.4;

1.4
date	99.08.02.12.33.43;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.32;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2001.05.14.22.26.12;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.03.28.15.03.52;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2003.05.13.19.35.10;	author ho;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2003.06.07.11.02.32;	author ho;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2004.02.19.10.56.31;	author niklas;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2004.06.05.23.12.56;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.01.31.22.55.38;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;

1.26.4.1
date	2004.11.28.18.35.06;	author brad;	state Exp;
branches;
next	;

1.27.4.1
date	2005.11.21.23.14.08;	author brad;	state Exp;
branches;
next	;


desc
@@


1.66
log
@Put raidframe in the attic.
@
text
@/* $OpenBSD: rf_openbsdkintf.c,v 1.65 2011/07/06 04:49:36 matthew Exp $	*/
/* $NetBSD: rf_netbsdkintf.c,v 1.109 2001/07/27 03:30:07 oster Exp $	*/

/*-
 * Copyright (c) 1996, 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Greg Oster; Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: cd.c 1.6 90/11/28$
 *
 *	@@(#)cd.c	8.2 (Berkeley) 11/16/93
 */

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Authors: Mark Holland, Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 *
 * rf_kintf.c -- The kernel interface routines for RAIDframe.
 *
 *****************************************************************************/

#include <sys/errno.h>

#include <sys/param.h>
#include <sys/pool.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/disk.h>
#include <sys/device.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/fcntl.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/conf.h>
#include <sys/lock.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/reboot.h>

#include "raid.h"
#include "rf_raid.h"
#include "rf_raidframe.h"
#include "rf_copyback.h"
#include "rf_dag.h"
#include "rf_dagflags.h"
#include "rf_desc.h"
#include "rf_diskqueue.h"
#include "rf_engine.h"
#include "rf_acctrace.h"
#include "rf_etimer.h"
#include "rf_general.h"
#include "rf_debugMem.h"
#include "rf_kintf.h"
#include "rf_options.h"
#include "rf_driver.h"
#include "rf_parityscan.h"
#include "rf_debugprint.h"
#include "rf_threadstuff.h"
#include "rf_configure.h"

int	rf_kdebug_level = 0;

#ifdef	RAIDDEBUG
#define	db1_printf(a) do { if (rf_kdebug_level > 0) printf a; } while(0)
#else	/* RAIDDEBUG */
#define	db1_printf(a) (void)0
#endif	/* ! RAIDDEBUG */

static RF_Raid_t **raidPtrs;	/* Global raid device descriptors. */

RF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex);

/* Requests to install a spare table. */
static RF_SparetWait_t *rf_sparet_wait_queue;

/* Responses from installation process. */
static RF_SparetWait_t *rf_sparet_resp_queue;

/* Prototypes. */
void rf_KernelWakeupFunc(struct buf *);
void rf_InitBP(struct buf *, struct vnode *, unsigned, dev_t, RF_SectorNum_t,
    RF_SectorCount_t, caddr_t, void (*)(struct buf *), void *, int,
    struct proc *);
void raidinit(RF_Raid_t *);

void raidattach(int);
daddr64_t raidsize(dev_t);
int  raidopen(dev_t, int, int, struct proc *);
int  raidclose(dev_t, int, int, struct proc *);
int  raidioctl(dev_t, u_long, caddr_t, int, struct proc *);
int  raidwrite(dev_t, struct uio *, int);
int  raidread(dev_t, struct uio *, int);
void raidstrategy(struct buf *);
int  raiddump(dev_t, daddr64_t, caddr_t, size_t);

/*
 * Pilfered from ccd.c
 */
struct raidbuf {
	struct buf	 rf_buf;	/* New I/O buf.	 MUST BE FIRST!!! */
	struct buf	*rf_obp;	/* Ptr. to original I/O buf. */
	int		 rf_flags;	/* Miscellaneous flags. */
	RF_DiskQueueData_t *req;	/* The request that this was part of. */
};

#define	RAIDGETBUF(rs)		pool_get(&(rs)->sc_cbufpool, PR_NOWAIT)
#define	RAIDPUTBUF(rs, cbp)	pool_put(&(rs)->sc_cbufpool, cbp)

/*
 * Some port (like i386) use a swapgeneric that wants to snoop around
 * in this raid_cd structure.  It is preserved (for now) to remain
 * compatible with such practice.
 */
struct cfdriver raid_cd = {
	NULL, "raid", DV_DISK
};

/*
 * XXX Not sure if the following should be replacing the raidPtrs above,
 * or if it should be used in conjunction with that...
 */
struct raid_softc {
	int		sc_flags;		/* Flags. */
	int		sc_cflags;		/* Configuration flags. */
	size_t		sc_size;		/* Size of the raid device. */
	char		sc_xname[20];		/* XXX external name. */
	struct disk	sc_dkdev;		/* Generic disk device info. */
	struct pool	sc_cbufpool;		/* Component buffer pool. */
	struct buf	sc_q;			/* Used for the device queue. */
};

/* sc_flags */
#define	RAIDF_INITED	0x01	/* Unit has been initialized. */
#define	RAIDF_WANTED	0x40	/* Someone is waiting to obtain a lock. */
#define	RAIDF_LOCKED	0x80	/* Unit is locked. */

int numraid = 0;

/*
 * Here we define a cfattach structure for inserting any new raid device
 * into the device tree.  This is needed by some archs that look for
 * bootable devices in there.
 */
int  rf_probe(struct device *, void *, void *);
void rf_attach(struct device *, struct device *, void *);
int  rf_detach(struct device *, int);
int  rf_activate(struct device *, int);

struct cfattach raid_ca = {
	sizeof(struct raid_softc), rf_probe, rf_attach,
	rf_detach, rf_activate
};

/*
 * Allow RAIDOUTSTANDING number of simultaneous IO's to this RAID device.
 * Be aware that large numbers can allow the driver to consume a lot of
 * kernel memory, especially on writes, and in degraded mode reads.
 *
 * For example: with a stripe width of 64 blocks (32k) and 5 disks,
 * a single 64K write will typically require 64K for the old data,
 * 64K for the old parity, and 64K for the new parity, for a total
 * of 192K (if the parity buffer is not re-used immediately).
 * Even it if is used immedately, that's still 128K, which when multiplied
 * by say 10 requests, is 1280K, *on top* of the 640K of incoming data.
 *
 * Now in degraded mode, for example, a 64K read on the above setup may
 * require data reconstruction, which will require *all* of the 4 remaining
 * disks to participate -- 4 * 32K/disk == 128K again.
 */

#ifndef	RAIDOUTSTANDING
#define	RAIDOUTSTANDING		6
#endif

/* Declared here, and made public, for the benefit of KVM stuff... */
struct raid_softc  *raid_softc;
struct raid_softc **raid_scPtrs;

void rf_shutdown_hook(RF_ThreadArg_t);
void raidgetdefaultlabel(RF_Raid_t *, struct raid_softc *, struct disklabel *);
int raidgetdisklabel(dev_t, struct raid_softc *, struct disklabel *, int);

int  raidlock(struct raid_softc *);
void raidunlock(struct raid_softc *);

void rf_markalldirty(RF_Raid_t *);

struct device *raidrootdev;

int  findblkmajor(struct device *dv);
char *findblkname(int);

void rf_ReconThread(struct rf_recon_req *);
/* XXX what I want is: */
/*void rf_ReconThread(RF_Raid_t *raidPtr);*/
void rf_RewriteParityThread(RF_Raid_t *raidPtr);
void rf_CopybackThread(RF_Raid_t *raidPtr);
void rf_ReconstructInPlaceThread(struct rf_recon_req *);
#ifdef	RAID_AUTOCONFIG
void rf_autoconfig_startuphook(void *);
void rf_buildroothack(void *);
int  rf_reasonable_label(RF_ComponentLabel_t *);
#endif	/* RAID_AUTOCONFIG */

RF_AutoConfig_t *rf_find_raid_components(void);
RF_ConfigSet_t *rf_create_auto_sets(RF_AutoConfig_t *);
int  rf_does_it_fit(RF_ConfigSet_t *,RF_AutoConfig_t *);
void rf_create_configuration(RF_AutoConfig_t *,RF_Config_t *,
				  RF_Raid_t *);
int  rf_set_autoconfig(RF_Raid_t *, int);
int  rf_set_rootpartition(RF_Raid_t *, int);
void rf_release_all_vps(RF_ConfigSet_t *);
void rf_cleanup_config_set(RF_ConfigSet_t *);
int  rf_have_enough_components(RF_ConfigSet_t *);
int  rf_auto_config_set(RF_ConfigSet_t *, int *);

int
rf_probe(struct device *parent, void *match_, void *aux)
{
	return 0;
}

void
rf_attach(struct device *parent, struct device *self, void *aux)
{
	/*struct raid_softc *raid = (void *)self;*/
}

int
rf_detach(struct device *self, int flags)
{
	return 0;
}

int
rf_activate(struct device *self, int act)
{
	return 0;
}

void
raidattach(int num)
{
	int raidID;
	int i, rc;

	db1_printf(("raidattach: Asked for %d units\n", num));

	if (num <= 0) {
#ifdef	DIAGNOSTIC
		panic("raidattach: count <= 0");
#endif	/* DIAGNOSTIC */
		return;
	}

	/* This is where all the initialization stuff gets done. */

	numraid = num;

	/* Make some space for requested number of units... */
	RF_Calloc(raidPtrs, num, sizeof(RF_Raid_t *), (RF_Raid_t **));
	if (raidPtrs == NULL) {
		panic("raidPtrs is NULL!!");
	}

	rc = rf_mutex_init(&rf_sparet_wait_mutex);
	if (rc) {
		RF_PANIC();
	}

	rf_sparet_wait_queue = rf_sparet_resp_queue = NULL;

	for (i = 0; i < num; i++)
		raidPtrs[i] = NULL;
	rc = rf_BootRaidframe();
	if (rc == 0)
		printf("Kernelized RAIDframe activated\n");
	else
	        panic("Serious error booting RAID !!!");
	
	/*
	 * Put together some datastructures like the CCD device does...
	 * This lets us lock the device and what-not when it gets opened.
	 */

	raid_softc = malloc(num * sizeof(struct raid_softc), M_RAIDFRAME,
	    M_NOWAIT | M_ZERO);
	if (raid_softc == NULL) {
		printf("WARNING: no memory for RAIDframe driver\n");
		return;
	}

	raid_scPtrs = malloc(num * sizeof(struct raid_softc *), M_RAIDFRAME,
	    M_NOWAIT | M_ZERO);
	if (raid_scPtrs == NULL) {
		printf("WARNING: no memory for RAIDframe driver\n");
		return;
	}

	raidrootdev = (struct device *)malloc(num * sizeof(struct device),
	    M_RAIDFRAME, M_NOWAIT);
	if (raidrootdev == NULL) {
		panic("No memory for RAIDframe driver!!?!?!");
	}

	for (raidID = 0; raidID < num; raidID++) {
#if 0
		SIMPLEQ_INIT(&raid_softc[raidID].sc_q);
#endif

		raidrootdev[raidID].dv_class  = DV_DISK;
		raidrootdev[raidID].dv_cfdata = NULL;
		raidrootdev[raidID].dv_unit   = raidID;
		raidrootdev[raidID].dv_parent = NULL;
		raidrootdev[raidID].dv_flags  = 0;
		snprintf(raidrootdev[raidID].dv_xname,
		    sizeof raidrootdev[raidID].dv_xname,"raid%d",raidID);

		RF_Calloc(raidPtrs[raidID], 1, sizeof (RF_Raid_t),
		    (RF_Raid_t *));
		if (raidPtrs[raidID] == NULL) {
			printf("WARNING: raidPtrs[%d] is NULL\n", raidID);
			numraid = raidID;
			return;
		}
	}

	raid_cd.cd_devs = (void **) raid_scPtrs;
	raid_cd.cd_ndevs = num;

#ifdef	RAID_AUTOCONFIG
	startuphook_establish(rf_autoconfig_startuphook, NULL);
#endif	
}

#ifdef	RAID_AUTOCONFIG
void
rf_autoconfig_startuphook(void *param)
{
	RF_AutoConfig_t *ac_list;	/* Autoconfig list. */
	RF_ConfigSet_t *config_sets;

	/* 1. Locate all RAID components on the system. */

#ifdef	RAIDDEBUG
	printf("Searching for raid components...\n");
#endif	/* RAIDDEBUG */
	ac_list = rf_find_raid_components();

	/* 2. Sort them into their respective sets. */

	config_sets = rf_create_auto_sets(ac_list);

	/*
	 * 3. Evaluate each set and configure the valid ones
	 * This gets done in rf_buildroothack().
	 */

	rf_buildroothack(config_sets);
}

void
rf_buildroothack(void *arg)
{
	RF_ConfigSet_t *config_sets = arg;
	RF_ConfigSet_t *cset;
	RF_ConfigSet_t *next_cset;
	int retcode;
	int raidID;
	int rootID;
	int num_root;
	int majdev;

	rootID = 0;
	num_root = 0;
	cset = config_sets;
	while(cset != NULL ) {
		next_cset = cset->next;
		if (rf_have_enough_components(cset) &&
		    cset->ac->clabel->autoconfigure==1) {
			retcode = rf_auto_config_set(cset,&raidID);
			if (!retcode) {
				if (cset->rootable) {
					rootID = raidID;
#ifdef	RAIDDEBUG
					printf("eligible root device %d:"
					    " raid%d\n", num_root, rootID);
#endif	/* RAIDDEBUG */
					num_root++;
				}
			} else {
				/* The autoconfig didn't work :( */
#ifdef	RAIDDEBUG
				printf("Autoconfig failed with code %d for"
				    " raid%d\n", retcode, raidID);
#endif	/* RAIDDEBUG */
				rf_release_all_vps(cset);
			}
		} else {
			/*
			 * We're not autoconfiguring this set...
			 * Release the associated resources.
			 */
			rf_release_all_vps(cset);
		}
		/* Cleanup. */
		rf_cleanup_config_set(cset);
		cset = next_cset;
	}
	if (boothowto & RB_ASKNAME) {
		/* We don't auto-config... */
	} else {
		/* They didn't ask, and we found something bootable... */

		if (num_root == 1) {
			majdev = findblkmajor(&raidrootdev[rootID]);
			if (majdev < 0)
				boothowto |= RB_ASKNAME;
			else {
				rootdev = MAKEDISKDEV(majdev,rootID,0);
				boothowto |= RB_DFLTROOT;
			}
		} else if (num_root > 1) {
			/* We can't guess... Require the user to answer... */
			boothowto |= RB_ASKNAME;
		}
	}
}
#endif	/* RAID_AUTOCONFIG */

void
rf_shutdown_hook(RF_ThreadArg_t arg)
{
	int unit;
	struct raid_softc *rs;
	RF_Raid_t *raidPtr;

	/* Don't do it if we are not "safe". */
	if (boothowto & RB_NOSYNC)
		return;

	raidPtr = (RF_Raid_t *) arg;
	unit = raidPtr->raidid;
	rs = &raid_softc[unit];

	/* Shutdown the system. */

	if (rf_hook_cookies != NULL && rf_hook_cookies[unit] != NULL)
		rf_hook_cookies[unit] = NULL;

	rf_Shutdown(raidPtr);

	pool_destroy(&rs->sc_cbufpool);

	/* It's no longer initialized... */
	rs->sc_flags &= ~RAIDF_INITED;

	/* config_detach the device. */
	config_detach(device_lookup(&raid_cd, unit), 0);

	/* Detach the disk. */
	disk_detach(&rs->sc_dkdev);
}

daddr64_t
raidsize(dev_t dev)
{
	struct raid_softc *rs;
	struct disklabel *lp;
	int part, unit, omask, size;

	unit = DISKUNIT(dev);
	if (unit >= numraid)
		return (-1);
	rs = &raid_softc[unit];

	if ((rs->sc_flags & RAIDF_INITED) == 0)
		return (-1);

	part = DISKPART(dev);
	omask = rs->sc_dkdev.dk_openmask & (1 << part);
	lp = rs->sc_dkdev.dk_label;

	if (omask == 0 && raidopen(dev, 0, S_IFBLK, curproc))
		return (-1);

	if (lp->d_partitions[part].p_fstype != FS_SWAP)
		size = -1;
	else
		size = DL_GETPSIZE(&lp->d_partitions[part]) *
		    (lp->d_secsize / DEV_BSIZE);

	if (omask == 0 && raidclose(dev, 0, S_IFBLK, curproc))
		return (-1);

	return (size);

}

int
raiddump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
{
	/* Not implemented. */
	return (ENXIO);
}

/* ARGSUSED */
int
raidopen(dev_t dev, int flags, int fmt, struct proc *p)
{
	int unit = DISKUNIT(dev);
	struct raid_softc *rs;
	int part,pmask;
	int error = 0;

	if (unit >= numraid)
		return (ENXIO);
	rs = &raid_softc[unit];

	if ((error = raidlock(rs)) != 0)
		return (error);

	part = DISKPART(dev);
	pmask = (1 << part);

	db1_printf(
	    ("Opening raid device number: %d partition: %d\n", unit, part));


	if ((rs->sc_flags & RAIDF_INITED) && (rs->sc_dkdev.dk_openmask == 0))
		raidgetdisklabel(dev, rs, rs->sc_dkdev.dk_label, 0);

	/* Make sure that this partition exists. */

	if (part != RAW_PART) {
		db1_printf(("Not a raw partition..\n"));
		if (((rs->sc_flags & RAIDF_INITED) == 0) ||
		    ((part >= rs->sc_dkdev.dk_label->d_npartitions) ||
		    (rs->sc_dkdev.dk_label->d_partitions[part].p_fstype ==
		    FS_UNUSED))) {
			error = ENXIO;
			raidunlock(rs);
			db1_printf(("Bailing out...\n"));
			return (error);
		}
	}

	/* Prevent this unit from being unconfigured while opened. */
	switch (fmt) {
	case S_IFCHR:
		rs->sc_dkdev.dk_copenmask |= pmask;
		break;

	case S_IFBLK:
		rs->sc_dkdev.dk_bopenmask |= pmask;
		break;
	}

	if ((rs->sc_dkdev.dk_openmask == 0) &&
	    ((rs->sc_flags & RAIDF_INITED) != 0)) {
		/*
		 * First one...  Mark things as dirty...  Note that we *MUST*
		 * have done a configure before this.  I DO NOT WANT TO BE
		 * SCRIBBLING TO RANDOM COMPONENTS UNTIL IT'S BEEN DETERMINED
		 * THAT THEY BELONG TOGETHER!!!!!
		 */
		/*
		 * XXX should check to see if we're only open for reading
		 * here...  If so, we needn't do this, but then need some
		 * other way of keeping track of what's happened...
		 */

		rf_markalldirty( raidPtrs[unit] );
	}

	rs->sc_dkdev.dk_openmask =
	    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;

	raidunlock(rs);

	return (error);
}

/* ARGSUSED */
int
raidclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	int unit = DISKUNIT(dev);
	struct raid_softc *rs;
	int error = 0;
	int part;

	if (unit >= numraid)
		return (ENXIO);
	rs = &raid_softc[unit];

	if ((error = raidlock(rs)) != 0)
		return (error);

	part = DISKPART(dev);

	/* ...that much closer to allowing unconfiguration... */
	switch (fmt) {
	case S_IFCHR:
		rs->sc_dkdev.dk_copenmask &= ~(1 << part);
		break;

	case S_IFBLK:
		rs->sc_dkdev.dk_bopenmask &= ~(1 << part);
		break;
	}
	rs->sc_dkdev.dk_openmask =
	    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;

	if ((rs->sc_dkdev.dk_openmask == 0) &&
	    ((rs->sc_flags & RAIDF_INITED) != 0)) {
		/*
		 * Last one...  Device is not unconfigured yet.
		 * Device shutdown has taken care of setting the
		 * clean bits if RAIDF_INITED is not set.
		 * Mark things as clean...
		 */
		db1_printf(("Last one on raid%d.  Updating status.\n",unit));
		rf_update_component_labels(raidPtrs[unit],
						 RF_FINAL_COMPONENT_UPDATE);
	}

	raidunlock(rs);
	return (0);
}

void
raidstrategy(struct buf *bp)
{
	int s;

	unsigned int raidID = DISKUNIT(bp->b_dev);
	RF_Raid_t *raidPtr;
	struct raid_softc *rs = &raid_softc[raidID];
	struct disklabel *lp;

	s = splbio();

	if ((rs->sc_flags & RAIDF_INITED) ==0) {
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
  		goto raidstrategy_end;
	}
	if (raidID >= numraid || !raidPtrs[raidID]) {
		bp->b_error = ENODEV;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
		goto raidstrategy_end;
	}
	raidPtr = raidPtrs[raidID];
	if (!raidPtr->valid) {
		bp->b_error = ENODEV;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
		goto raidstrategy_end;
	}
	if (bp->b_bcount == 0) {
		db1_printf(("b_bcount is zero..\n"));
		biodone(bp);
		goto raidstrategy_end;
	}
	lp = rs->sc_dkdev.dk_label;

	/*
	 * Do bounds checking and adjust transfer.  If there's an
	 * error, the bounds check will flag that for us.
	 */
	if (bounds_check_with_label(bp, lp) == -1) {
		db1_printf(("Bounds check failed!!: %d\n",
		    (int)bp->b_blkno));
		biodone(bp);
		goto raidstrategy_end;
	}

	bp->b_resid = 0;

	bp->b_actf = rs->sc_q.b_actf;
	rs->sc_q.b_actf = bp;
	rs->sc_q.b_active++;

	raidstart(raidPtrs[raidID]);

raidstrategy_end:
	splx(s);
}

/* ARGSUSED */
int
raidread(dev_t dev, struct uio *uio, int flags)
{
	int unit = DISKUNIT(dev);
	struct raid_softc *rs;
	int part;

	if (unit >= numraid)
		return (ENXIO);
	rs = &raid_softc[unit];

	if ((rs->sc_flags & RAIDF_INITED) == 0)
		return (ENXIO);
	part = DISKPART(dev);

	db1_printf(("raidread: unit: %d partition: %d\n", unit, part));

	return (physio(raidstrategy, dev, B_READ, minphys, uio));
}

/* ARGSUSED */
int
raidwrite(dev_t dev, struct uio *uio, int flags)
{
	int unit = DISKUNIT(dev);
	struct raid_softc *rs;

	if (unit >= numraid)
		return (ENXIO);
	rs = &raid_softc[unit];

	if ((rs->sc_flags & RAIDF_INITED) == 0)
		return (ENXIO);
	db1_printf(("raidwrite\n"));
	return (physio(raidstrategy, dev, B_WRITE, minphys, uio));
}

int
raidioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int unit = DISKUNIT(dev);
	int error = 0;
	int part, pmask;
	struct raid_softc *rs;
	struct disklabel *lp;
	RF_Config_t *k_cfg, *u_cfg;
	RF_Raid_t *raidPtr;
	RF_RaidDisk_t *diskPtr;
	RF_AccTotals_t *totals;
	RF_DeviceConfig_t *d_cfg, **ucfgp;
	u_char *specific_buf;
	int retcode = 0;
	int row;
	int column;
	struct rf_recon_req *rrcopy, *rr;
	RF_ComponentLabel_t *clabel;
	RF_ComponentLabel_t ci_label;
	RF_ComponentLabel_t **clabel_ptr;
	RF_SingleComponent_t *sparePtr,*componentPtr;
	RF_SingleComponent_t hot_spare;
	RF_SingleComponent_t component;
	RF_ProgressInfo_t progressInfo, **progressInfoPtr;
	int i, j, d;

	if (unit >= numraid)
		return (ENXIO);
	rs = &raid_softc[unit];
	raidPtr = raidPtrs[unit];

	db1_printf(("raidioctl: %d %d %d %d\n", (int)dev, (int)DISKPART(dev),
	    (int)unit, (int)cmd));

	/* Must be open for writes for these commands... */
	switch (cmd) {
	case DIOCSDINFO:
	case DIOCWDINFO:
		if ((flag & FWRITE) == 0)
			return (EBADF);
	}

	/* Must be initialized for these... */
	switch (cmd) {
	case DIOCGDINFO:
	case DIOCSDINFO:
	case DIOCWDINFO:
	case DIOCGPART:
	case DIOCRLDINFO:
	case DIOCGPDINFO:
	case RAIDFRAME_SHUTDOWN:
	case RAIDFRAME_REWRITEPARITY:
	case RAIDFRAME_GET_INFO:
	case RAIDFRAME_RESET_ACCTOTALS:
	case RAIDFRAME_GET_ACCTOTALS:
	case RAIDFRAME_KEEP_ACCTOTALS:
	case RAIDFRAME_GET_SIZE:
	case RAIDFRAME_FAIL_DISK:
	case RAIDFRAME_COPYBACK:
	case RAIDFRAME_CHECK_RECON_STATUS:
	case RAIDFRAME_CHECK_RECON_STATUS_EXT:
	case RAIDFRAME_GET_COMPONENT_LABEL:
	case RAIDFRAME_SET_COMPONENT_LABEL:
	case RAIDFRAME_ADD_HOT_SPARE:
	case RAIDFRAME_REMOVE_HOT_SPARE:
	case RAIDFRAME_INIT_LABELS:
	case RAIDFRAME_REBUILD_IN_PLACE:
	case RAIDFRAME_CHECK_PARITY:
	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS:
	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT:
	case RAIDFRAME_CHECK_COPYBACK_STATUS:
	case RAIDFRAME_CHECK_COPYBACK_STATUS_EXT:
	case RAIDFRAME_SET_AUTOCONFIG:
	case RAIDFRAME_SET_ROOT:
	case RAIDFRAME_DELETE_COMPONENT:
	case RAIDFRAME_INCORPORATE_HOT_SPARE:
		if ((rs->sc_flags & RAIDF_INITED) == 0)
			return (ENXIO);
	}

	switch (cmd) {
		/* Configure the system. */
	case RAIDFRAME_CONFIGURE:

		if (raidPtr->valid) {
			/* There is a valid RAID set running on this unit ! */
			printf("raid%d: Device already configured!\n",unit);
			return(EINVAL);
		}

		/*
		 * Copy-in the configuration information.
		 * data points to a pointer to the configuration structure.
		 */
		u_cfg = *((RF_Config_t **)data);
		RF_Malloc(k_cfg, sizeof (RF_Config_t), (RF_Config_t *));
		if (k_cfg == NULL) {
			return (ENOMEM);
		}
		retcode = copyin((caddr_t)u_cfg, (caddr_t)k_cfg,
		    sizeof (RF_Config_t));
		if (retcode) {
			RF_Free(k_cfg, sizeof(RF_Config_t));
			return (retcode);
		}

		/*
		 * Allocate a buffer for the layout-specific data,
		 * and copy it in.
		 */
		if (k_cfg->layoutSpecificSize) {
			if (k_cfg->layoutSpecificSize > 10000) {
				/* Sanity check. */
				RF_Free(k_cfg, sizeof(RF_Config_t));
				return (EINVAL);
			}
			RF_Malloc(specific_buf, k_cfg->layoutSpecificSize,
			    (u_char *));
			if (specific_buf == NULL) {
				RF_Free(k_cfg, sizeof (RF_Config_t));
				return (ENOMEM);
			}
			retcode = copyin(k_cfg->layoutSpecific,
			    (caddr_t)specific_buf, k_cfg->layoutSpecificSize);
			if (retcode) {
				RF_Free(k_cfg, sizeof(RF_Config_t));
				RF_Free(specific_buf,
					k_cfg->layoutSpecificSize);
				return (retcode);
			}
		} else
			specific_buf = NULL;
		k_cfg->layoutSpecific = specific_buf;

		/*
		 * We should do some kind of sanity check on the
		 * configuration.
		 * Store the sum of all the bytes in the last byte ?
		 */

		/*
		 * Clear the entire RAID descriptor, just to make sure
		 *  there is no stale data left in the case of a
		 *  reconfiguration.
		 */
		bzero(raidPtr, sizeof(RF_Raid_t));

		/* Configure the system. */
		raidPtr->raidid = unit;

		retcode = rf_Configure(raidPtr, k_cfg, NULL);

		if (retcode == 0) {

			/*
			 * Allow this many simultaneous IO's to
			 * this RAID device.
			 */
			raidPtr->openings = RAIDOUTSTANDING;

			raidinit(raidPtr);
			rf_markalldirty(raidPtr);
		}

		/* Free the buffers.  No return code here. */
		if (k_cfg->layoutSpecificSize) {
			RF_Free(specific_buf, k_cfg->layoutSpecificSize);
		}
		RF_Free(k_cfg, sizeof (RF_Config_t));

		return (retcode);

	case RAIDFRAME_SHUTDOWN:
		/* Shutdown the system. */

		if ((error = raidlock(rs)) != 0)
			return (error);

		/*
		 * If somebody has a partition mounted, we shouldn't
		 * shutdown.
		 */

		part = DISKPART(dev);
		pmask = (1 << part);
		if ((rs->sc_dkdev.dk_openmask & ~pmask) ||
		    ((rs->sc_dkdev.dk_bopenmask & pmask) &&
		    (rs->sc_dkdev.dk_copenmask & pmask))) {
			raidunlock(rs);
			return (EBUSY);
		}

		if ((retcode = rf_Shutdown(raidPtr)) == 0) {

			pool_destroy(&rs->sc_cbufpool);

			/* It's no longer initialized... */
			rs->sc_flags &= ~RAIDF_INITED;

			/* config_detach the device. */
			config_detach(device_lookup(&raid_cd, unit), 0);

			/* Detach the disk. */
			disk_detach(&rs->sc_dkdev);
		}

		raidunlock(rs);

		return (retcode);

	case RAIDFRAME_GET_COMPONENT_LABEL:
		clabel_ptr = (RF_ComponentLabel_t **) data;
		/*
		 * We need to read the component label for the disk indicated
		 * by row,column in clabel.
		 */

		/*
		 * For practice, let's get it directly from disk, rather
		 * than from the in-core copy.
		 */
		RF_Malloc( clabel, sizeof( RF_ComponentLabel_t ),
			   (RF_ComponentLabel_t *));
		if (clabel == NULL)
			return (ENOMEM);

		bzero(clabel, sizeof(RF_ComponentLabel_t));

		retcode = copyin( *clabel_ptr, clabel,
				  sizeof(RF_ComponentLabel_t));

		if (retcode) {
			RF_Free( clabel, sizeof(RF_ComponentLabel_t));
			return(retcode);
		}

 		row = clabel->row;
		column = clabel->column;

		if ((row < 0) || (row >= raidPtr->numRow) ||
		    (column < 0) || (column >= raidPtr->numCol)) {
			RF_Free( clabel, sizeof(RF_ComponentLabel_t));
			return(EINVAL);
  		}

		raidread_component_label(raidPtr->Disks[row][column].dev,
		    raidPtr->raid_cinfo[row][column].ci_vp, clabel );

		retcode = copyout((caddr_t) clabel,
				  (caddr_t) *clabel_ptr,
				  sizeof(RF_ComponentLabel_t));
		RF_Free( clabel, sizeof(RF_ComponentLabel_t));
		return (retcode);

	case RAIDFRAME_SET_COMPONENT_LABEL:
		clabel = (RF_ComponentLabel_t *) data;

		/* XXX check the label for valid stuff... */
		/*
		 * Note that some things *should not* get modified --
		 * the user should be re-initing the labels instead of
		 * trying to patch things.
		 */

#ifdef	RAIDDEBUG
		printf("Got component label:\n");
		printf("Version: %d\n",clabel->version);
		printf("Serial Number: %d\n",clabel->serial_number);
		printf("Mod counter: %d\n",clabel->mod_counter);
		printf("Row: %d\n", clabel->row);
		printf("Column: %d\n", clabel->column);
		printf("Num Rows: %d\n", clabel->num_rows);
		printf("Num Columns: %d\n", clabel->num_columns);
		printf("Clean: %d\n", clabel->clean);
		printf("Status: %d\n", clabel->status);
#endif	/* RAIDDEBUG */

		row = clabel->row;
		column = clabel->column;

		if ((row < 0) || (row >= raidPtr->numRow) ||
		    (column < 0) || (column >= raidPtr->numCol)) {
			return(EINVAL);
		}

 		/* XXX this isn't allowed to do anything for now :-) */
#if 0
		raidwrite_component_label(raidPtr->Disks[row][column].dev,
		    raidPtr->raid_cinfo[row][column].ci_vp, clabel );
#endif
		return (0);

	case RAIDFRAME_INIT_LABELS:
		clabel = (RF_ComponentLabel_t *) data;
		/*
		 * We only want the serial number from the above.
		 * We get all the rest of the information from
		 * the config that was used to create this RAID
		 * set.
		 */

		raidPtr->serial_number = clabel->serial_number;

		raid_init_component_label(raidPtr, &ci_label);
		ci_label.serial_number = clabel->serial_number;

		for(row=0;row<raidPtr->numRow;row++) {
			ci_label.row = row;
			for(column=0;column<raidPtr->numCol;column++) {
				diskPtr = &raidPtr->Disks[row][column];
				if (!RF_DEAD_DISK(diskPtr->status)) {
					ci_label.partitionSize =
					    diskPtr->partitionSize;
					ci_label.column = column;
					raidwrite_component_label(
					    raidPtr->Disks[row][column].dev,
					    raidPtr->raid_cinfo[row][column].ci_vp,
					    &ci_label );
				}
			}
		}

		return (retcode);

	case RAIDFRAME_REWRITEPARITY:

		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* Parity for RAID 0 is trivially correct. */
			raidPtr->parity_good = RF_RAID_CLEAN;
			return(0);
		}


		if (raidPtr->parity_rewrite_in_progress == 1) {
			/* Re-write is already in progress ! */
			return(EINVAL);
		}

		retcode = RF_CREATE_THREAD(raidPtr->parity_rewrite_thread,
					   rf_RewriteParityThread,
					   raidPtr,"raid_parity");

		return (retcode);

	case RAIDFRAME_SET_AUTOCONFIG:
		d = rf_set_autoconfig(raidPtr, *(int *) data);
		db1_printf(("New autoconfig value is: %d\n", d));
		*(int *) data = d;
		return (retcode);

	case RAIDFRAME_SET_ROOT:
		d = rf_set_rootpartition(raidPtr, *(int *) data);
		db1_printf(("New rootpartition value is: %d\n", d));
		*(int *) data = d;
		return (retcode);


	case RAIDFRAME_ADD_HOT_SPARE:
		sparePtr = (RF_SingleComponent_t *) data;
		memcpy( &hot_spare, sparePtr, sizeof(RF_SingleComponent_t));
		retcode = rf_add_hot_spare(raidPtr, &hot_spare);
		return(retcode);

	case RAIDFRAME_REMOVE_HOT_SPARE:
		return(retcode);

	case RAIDFRAME_DELETE_COMPONENT:
		componentPtr = (RF_SingleComponent_t *)data;
		memcpy( &component, componentPtr,
			sizeof(RF_SingleComponent_t));
		retcode = rf_delete_component(raidPtr, &component);
		return(retcode);

	case RAIDFRAME_INCORPORATE_HOT_SPARE:
		componentPtr = (RF_SingleComponent_t *)data;
		memcpy( &component, componentPtr,
			sizeof(RF_SingleComponent_t));
		retcode = rf_incorporate_hot_spare(raidPtr, &component);
		return(retcode);

	case RAIDFRAME_REBUILD_IN_PLACE:

		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* Can't do this on a RAID 0 !! */
			return(EINVAL);
		}

		if (raidPtr->recon_in_progress == 1) {
			/* A reconstruct is already in progress ! */
			return(EINVAL);
		}

		componentPtr = (RF_SingleComponent_t *) data;
		memcpy( &component, componentPtr,
			sizeof(RF_SingleComponent_t));
		row = component.row;
		column = component.column;
		db1_printf(("Rebuild: %d %d\n",row, column));
		if ((row < 0) || (row >= raidPtr->numRow) ||
		    (column < 0) || (column >= raidPtr->numCol)) {
			return(EINVAL);
		}

		RF_Malloc(rrcopy, sizeof(*rrcopy), (struct rf_recon_req *));
		if (rrcopy == NULL)
			return(ENOMEM);

		rrcopy->raidPtr = (void *) raidPtr;
		rrcopy->row = row;
		rrcopy->col = column;

		retcode = RF_CREATE_THREAD(raidPtr->recon_thread,
					   rf_ReconstructInPlaceThread,
					   rrcopy,"raid_reconip");

		return (retcode);

	case RAIDFRAME_GET_INFO:
		if (!raidPtr->valid)
			return (ENODEV);
		ucfgp = (RF_DeviceConfig_t **) data;
		RF_Malloc(d_cfg, sizeof(RF_DeviceConfig_t),
			  (RF_DeviceConfig_t *));
		if (d_cfg == NULL)
			return (ENOMEM);
		bzero(d_cfg, sizeof(RF_DeviceConfig_t));
		d_cfg->rows = raidPtr->numRow;
		d_cfg->cols = raidPtr->numCol;
		d_cfg->ndevs = raidPtr->numRow * raidPtr->numCol;
		if (d_cfg->ndevs >= RF_MAX_DISKS) {
			RF_Free(d_cfg, sizeof(RF_DeviceConfig_t));
			return (ENOMEM);
		}
		d_cfg->nspares = raidPtr->numSpare;
		if (d_cfg->nspares >= RF_MAX_DISKS) {
			RF_Free(d_cfg, sizeof(RF_DeviceConfig_t));
			return (ENOMEM);
		}
		d_cfg->maxqdepth = raidPtr->maxQueueDepth;
		d = 0;
		for (i = 0; i < d_cfg->rows; i++) {
			for (j = 0; j < d_cfg->cols; j++) {
				d_cfg->devs[d] = raidPtr->Disks[i][j];
				d++;
			}
		}
		for (j = d_cfg->cols, i = 0; i < d_cfg->nspares; i++, j++) {
			d_cfg->spares[i] = raidPtr->Disks[0][j];
		}
		retcode = copyout((caddr_t) d_cfg, (caddr_t) * ucfgp,
				  sizeof(RF_DeviceConfig_t));
		RF_Free(d_cfg, sizeof(RF_DeviceConfig_t));

		return (retcode);

	case RAIDFRAME_CHECK_PARITY:
		*(int *) data = raidPtr->parity_good;
		return (0);

	case RAIDFRAME_RESET_ACCTOTALS:
		bzero(&raidPtr->acc_totals, sizeof(raidPtr->acc_totals));
		return (0);

  	case RAIDFRAME_GET_ACCTOTALS:
		totals = (RF_AccTotals_t *) data;
		*totals = raidPtr->acc_totals;
		return (0);

	case RAIDFRAME_KEEP_ACCTOTALS:
		raidPtr->keep_acc_totals = *(int *)data;
		return (0);

	case RAIDFRAME_GET_SIZE:
		*(int *) data = raidPtr->totalSectors;
		return (0);

	/* Fail a disk & optionally start reconstruction. */
	case RAIDFRAME_FAIL_DISK:
		rr = (struct rf_recon_req *)data;

		if (rr->row < 0 || rr->row >= raidPtr->numRow ||
		    rr->col < 0 || rr->col >= raidPtr->numCol)
			return (EINVAL);

		db1_printf(("raid%d: Failing the disk: row: %d col: %d\n",
		    unit, rr->row, rr->col));

		/*
		 * Make a copy of the recon request so that we don't
		 * rely on the user's buffer.
		 */
		RF_Malloc(rrcopy, sizeof(*rrcopy), (struct rf_recon_req *));
		if (rrcopy == NULL)
			return(ENOMEM);
		bcopy(rr, rrcopy, sizeof(*rr));
		rrcopy->raidPtr = (void *)raidPtr;

		retcode = RF_CREATE_THREAD(raidPtr->recon_thread,
					   rf_ReconThread,
					   rrcopy,"raid_recon");
		return (0);

	/*
	 * Invoke a copyback operation after recon on whatever
	 * disk needs it, if any.
	 */
	case RAIDFRAME_COPYBACK:
		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* This makes no sense on a RAID 0 !! */
			return(EINVAL);
		}

		if (raidPtr->copyback_in_progress == 1) {
			/* Copyback is already in progress ! */
			return(EINVAL);
		}

		retcode = RF_CREATE_THREAD(raidPtr->copyback_thread,
					   rf_CopybackThread,
					   raidPtr,"raid_copyback");
		return (retcode);

	/* Return the percentage completion of reconstruction. */
	case RAIDFRAME_CHECK_RECON_STATUS:
		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/*
			 * This makes no sense on a RAID 0, so tell the
			 * user it's done.
			 */
			*(int *) data = 100;
			return(0);
		}
		row = 0; /* XXX we only consider a single row... */
		if (raidPtr->status[row] != rf_rs_reconstructing)
			*(int *)data = 100;
		else
			*(int *)data =
			    raidPtr->reconControl[row]->percentComplete;
		return (0);

	case RAIDFRAME_CHECK_RECON_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		row = 0; /* XXX we only consider a single row... */
		if (raidPtr->status[row] != rf_rs_reconstructing) {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		} else {
			progressInfo.total =
				raidPtr->reconControl[row]->numRUsTotal;
			progressInfo.completed =
				raidPtr->reconControl[row]->numRUsComplete;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS:
		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/*
			 * This makes no sense on a RAID 0, so tell the
			 * user it's done.
			 */
			*(int *) data = 100;
			return(0);
		}
		if (raidPtr->parity_rewrite_in_progress == 1) {
			*(int *) data = 100 *
				raidPtr->parity_rewrite_stripes_done /
				raidPtr->Layout.numStripe;
		} else {
			*(int *) data = 100;
		}
		return (0);

	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		if (raidPtr->parity_rewrite_in_progress == 1) {
			progressInfo.total = raidPtr->Layout.numStripe;
			progressInfo.completed =
				raidPtr->parity_rewrite_stripes_done;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		} else {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

	case RAIDFRAME_CHECK_COPYBACK_STATUS:
		if (raidPtr->Layout.map->faultsTolerated == 0) {
			/* This makes no sense on a RAID 0 !! */
			*(int *) data = 100;
			return(0);
		}
		if (raidPtr->copyback_in_progress == 1) {
			*(int *) data = 100 * raidPtr->copyback_stripes_done /
				raidPtr->Layout.numStripe;
		} else {
			*(int *) data = 100;
		}
		return (0);

	case RAIDFRAME_CHECK_COPYBACK_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		if (raidPtr->copyback_in_progress == 1) {
			progressInfo.total = raidPtr->Layout.numStripe;
			progressInfo.completed =
				raidPtr->copyback_stripes_done;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		} else {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

#if 0
	case RAIDFRAME_SPARET_WAIT:
		/*
		 * The sparetable daemon calls this to wait for the
		 * kernel to need a spare table.
		 * This ioctl does not return until a spare table is needed.
		 * XXX -- Calling mpsleep here in the ioctl code is almost
		 * certainly wrong and evil. -- XXX
		 * XXX -- I should either compute the spare table in the
		 * kernel, or have a different. -- XXX
		 * XXX -- Interface (a different character device) for
		 * delivering the table. -- XXX
		 */
		RF_LOCK_MUTEX(rf_sparet_wait_mutex);
		while (!rf_sparet_wait_queue)
			mpsleep(&rf_sparet_wait_queue, (PZERO + 1) | PCATCH,
			    "sparet wait", 0,
			    (void *)simple_lock_addr(rf_sparet_wait_mutex),
			    MS_LOCK_SIMPLE);
		waitreq = rf_sparet_wait_queue;
		rf_sparet_wait_queue = rf_sparet_wait_queue->next;
		RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);

		*((RF_SparetWait_t *)data) = *waitreq;

		RF_Free(waitreq, sizeof *waitreq);
		return (0);

	case RAIDFRAME_ABORT_SPARET_WAIT:
		/*
		 * Wakes up a process waiting on SPARET_WAIT and puts an
		 * error code in it that will cause the dameon to exit.
		 */
		RF_Malloc(waitreq, sizeof (*waitreq), (RF_SparetWait_t *));
		waitreq->fcol = -1;
		RF_LOCK_MUTEX(rf_sparet_wait_mutex);
		waitreq->next = rf_sparet_wait_queue;
		rf_sparet_wait_queue = waitreq;
		RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);
		wakeup(&rf_sparet_wait_queue);
		return (0);

	case RAIDFRAME_SEND_SPARET:
		/*
		 * Used by the spare table daemon to deliver a spare table
		 * into the kernel.
		 */

		/* Install the spare table. */
		retcode = rf_SetSpareTable(raidPtr,*(void **)data);

		/*
		 * Respond to the requestor.  The return status of the
		 * spare table installation is passed in the "fcol" field.
		 */
		RF_Malloc(waitreq, sizeof *waitreq, (RF_SparetWait_t *));
		waitreq->fcol = retcode;
		RF_LOCK_MUTEX(rf_sparet_wait_mutex);
		waitreq->next = rf_sparet_resp_queue;
		rf_sparet_resp_queue = waitreq;
		wakeup(&rf_sparet_resp_queue);
		RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);

		return (retcode);
#endif
	/* Fall through to the os-specific code below. */
	default:
		break;
	}

	if (!raidPtr->valid)
		return (EINVAL);

	/*
	 * Add support for "regular" device ioctls here.
	 */
	switch (cmd) {
	case DIOCRLDINFO:
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		raidgetdisklabel(dev, rs, lp, 0);
		bcopy(lp, rs->sc_dkdev.dk_label, sizeof(*lp));
		free(lp, M_TEMP);
		break;

	case DIOCGDINFO:
		*(struct disklabel *)data = *(rs->sc_dkdev.dk_label);
		break;

	case DIOCGPART:
		((struct partinfo *)data)->disklab = rs->sc_dkdev.dk_label;
		((struct partinfo *)data)->part =
		    &rs->sc_dkdev.dk_label->d_partitions[DISKPART(dev)];
		break;

	case DIOCWDINFO:
	case DIOCSDINFO:
	{
		struct disklabel *lp;
		lp = (struct disklabel *)data;

		if ((error = raidlock(rs)) != 0)
			return (error);

		error = setdisklabel(rs->sc_dkdev.dk_label, lp, 0);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    raidstrategy, rs->sc_dkdev.dk_label);
		}

		raidunlock(rs);

		if (error)
			return (error);
		break;
	}

	case DIOCGPDINFO:
		raidgetdisklabel(dev, rs, (struct disklabel *)data, 1);
		break;

	default:
		retcode = ENOTTY;
	}

	return (retcode);
}

/*
 * raidinit -- Complete the rest of the initialization for the
 * RAIDframe device.
 */
void
raidinit(RF_Raid_t *raidPtr)
{
	struct raid_softc *rs;
	struct cfdata	*cf;
	int unit;

	unit = raidPtr->raidid;

	rs = &raid_softc[unit];
	pool_init(&rs->sc_cbufpool, sizeof(struct raidbuf), 0,
		0, 0, "raidpl", NULL);

	/* XXX should check return code first... */
	rs->sc_flags |= RAIDF_INITED;

	/* XXX doesn't check bounds. */
	snprintf(rs->sc_xname, sizeof rs->sc_xname, "raid%d", unit);

	rs->sc_dkdev.dk_name = rs->sc_xname;

	/*
	 * disk_attach actually creates space for the CPU disklabel, among
	 * other things, so it's critical to call this *BEFORE* we try
	 * putzing with disklabels.
	 */
	disk_attach(NULL, &rs->sc_dkdev);

	/*
	 * XXX There may be a weird interaction here between this, and
	 * protectedSectors, as used in RAIDframe.
	 */
	rs->sc_size = raidPtr->totalSectors;

	/*
	 * config_attach the raid device into the device tree.
	 * For autoconf rootdev selection...
	 */
	cf = malloc(sizeof(struct cfdata), M_RAIDFRAME, M_NOWAIT | M_ZERO);
	if (cf == NULL) {
		printf("WARNING: no memory for cfdata struct\n");
		return;
	}

	cf->cf_attach = &raid_ca;
	cf->cf_driver = &raid_cd;
	cf->cf_unit   = unit;

	config_attach(NULL, cf, NULL, NULL);
}

/*
 * Wake up the daemon & tell it to get us a spare table.
 * XXX
 * The entries in the queues should be tagged with the raidPtr so that
 * in the extremely rare case that two recons happen at once, we know
 * which devices were requesting a spare table.
 * XXX
 *
 * XXX This code is not currently used. GO
 */
int
rf_GetSpareTableFromDaemon(RF_SparetWait_t *req)
{
	int retcode;

	RF_LOCK_MUTEX(rf_sparet_wait_mutex);
	req->next = rf_sparet_wait_queue;
	rf_sparet_wait_queue = req;
	wakeup(&rf_sparet_wait_queue);

	/* mpsleep unlocks the mutex. */
	while (!rf_sparet_resp_queue) {
		tsleep(&rf_sparet_resp_queue, PRIBIO,
		    "RAIDframe getsparetable", 0);
	}
	req = rf_sparet_resp_queue;
	rf_sparet_resp_queue = req->next;
	RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);

	retcode = req->fcol;
	/* This is not the same req as we alloc'd. */
	RF_Free(req, sizeof *req);
	return (retcode);
}

/*
 * A wrapper around rf_DoAccess that extracts appropriate info from the
 * bp and passes it down.
 * Any calls originating in the kernel must use non-blocking I/O.
 * Do some extra sanity checking to return "appropriate" error values for
 * certain conditions (to make some standard utilities work).
 *
 * Formerly known as: rf_DoAccessKernel
 */
void
raidstart(RF_Raid_t *raidPtr)
{
	RF_SectorCount_t num_blocks, pb, sum;
	RF_RaidAddr_t raid_addr;
	int retcode;
	struct partition *pp;
	daddr64_t blocknum;
	int unit;
	struct raid_softc *rs;
	int	do_async;
	struct buf *bp;

	unit = raidPtr->raidid;
	rs = &raid_softc[unit];

	/* Quick check to see if anything has died recently. */
	RF_LOCK_MUTEX(raidPtr->mutex);
	if (raidPtr->numNewFailures > 0) {
		rf_update_component_labels(raidPtr,
					   RF_NORMAL_COMPONENT_UPDATE);
		raidPtr->numNewFailures--;
	}
	RF_UNLOCK_MUTEX(raidPtr->mutex);

	/* Check to see if we're at the limit... */
	RF_LOCK_MUTEX(raidPtr->mutex);
	while (raidPtr->openings > 0) {
		RF_UNLOCK_MUTEX(raidPtr->mutex);

		bp = rs->sc_q.b_actf;
		if (bp == NULL) {
			/* Nothing more to do. */
			return;
		}
		rs->sc_q.b_actf = bp->b_actf;

		/*
		 * Ok, for the bp we have here, bp->b_blkno is relative to the
		 * partition... We need to make it absolute to the underlying
		 * device...
		 */

		blocknum = bp->b_blkno;
		if (DISKPART(bp->b_dev) != RAW_PART) {
			pp = &rs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];
			blocknum += DL_GETPOFFSET(pp);
		}

		db1_printf(("Blocks: %d, %lld\n", (int) bp->b_blkno,
			    blocknum));

		db1_printf(("bp->b_bcount = %d\n", (int) bp->b_bcount));
		db1_printf(("bp->b_resid = %d\n", (int) bp->b_resid));

		/*
		 * *THIS* is where we adjust what block we're going to...
		 * But DO NOT TOUCH bp->b_blkno !!!
		 */
		raid_addr = blocknum;

		num_blocks = bp->b_bcount >> raidPtr->logBytesPerSector;
		pb = (bp->b_bcount & raidPtr->sectorMask) ? 1 : 0;
		sum = raid_addr + num_blocks + pb;
		if (1 || rf_debugKernelAccess) {
			db1_printf(("raid_addr=%d sum=%d num_blocks=%d(+%d)"
			    " (%d)\n", (int)raid_addr, (int)sum,
			    (int)num_blocks, (int)pb, (int)bp->b_resid));
		}
		if ((sum > raidPtr->totalSectors) || (sum < raid_addr)
		    || (sum < num_blocks) || (sum < pb)) {
			bp->b_error = ENOSPC;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
			/* db1_printf(("%s: Calling biodone on 0x%x\n",
			    __func__, bp)); */
			splassert(IPL_BIO);
			biodone(bp);
			RF_LOCK_MUTEX(raidPtr->mutex);
			continue;
		}
		/*
		 * XXX rf_DoAccess() should do this, not just DoAccessKernel().
		 */

		if (bp->b_bcount & raidPtr->sectorMask) {
			bp->b_error = EINVAL;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
			/* db1_printf(("%s: Calling biodone on 0x%x\n",
			    __func__, bp)); */
			splassert(IPL_BIO);
			biodone(bp);
			RF_LOCK_MUTEX(raidPtr->mutex);
			continue;

		}
		db1_printf(("Calling DoAccess..\n"));


		RF_LOCK_MUTEX(raidPtr->mutex);
		raidPtr->openings--;
		RF_UNLOCK_MUTEX(raidPtr->mutex);

		/*
		 * Everything is async.
		 */
		do_async = 1;

		disk_busy(&rs->sc_dkdev);

		/*
		 * XXX we're still at splbio() here...  Do we *really*
		 * need to be ?
		 */

		/*
		 * Don't ever condition on bp->b_flags & B_WRITE.
		 * Always condition on B_READ instead.
		 */

		retcode = rf_DoAccess(raidPtr, (bp->b_flags & B_READ) ?
				      RF_IO_TYPE_READ : RF_IO_TYPE_WRITE,
				      do_async, raid_addr, num_blocks,
				      bp->b_data, bp, NULL, NULL,
				      RF_DAG_NONBLOCKING_IO, NULL, NULL, NULL);

		RF_LOCK_MUTEX(raidPtr->mutex);
	}
	RF_UNLOCK_MUTEX(raidPtr->mutex);
}

/* Invoke an I/O from kernel mode.  Disk queue should be locked upon entry. */

int
rf_DispatchKernelIO(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req)
{
	int op = (req->type == RF_IO_TYPE_READ) ? B_READ : B_WRITE;
	struct buf *bp;
	struct raidbuf *raidbp = NULL;
	struct raid_softc *rs;
	int unit;
	/*int s = splbio();*/	/* Want to test this. */

	/*
	 * XXX along with the vnode, we also need the softc associated with
	 * this device...
	 */
	req->queue = queue;

	unit = queue->raidPtr->raidid;

	db1_printf(("DispatchKernelIO unit: %d\n", unit));

	if (unit >= numraid) {
		printf("Invalid unit number: %d %d\n", unit, numraid);
		panic("Invalid Unit number in rf_DispatchKernelIO");
	}

	rs = &raid_softc[unit];

	bp = req->bp;

#if 1
	/*
	 * XXX When there is a physical disk failure, someone is passing
	 * us a buffer that contains old stuff !!  Attempt to deal with
	 * this problem without taking a performance hit...
	 * (not sure where the real bug is; it's buried in RAIDframe
	 * somewhere) :-( GO )
	 */
	if (bp->b_flags & B_ERROR) {
		bp->b_flags &= ~B_ERROR;
	}
	if (bp->b_error!=0) {
		bp->b_error = 0;
	}
#endif

	raidbp = RAIDGETBUF(rs);

	raidbp->rf_flags = 0;	/* XXX not really used anywhere... */

	/*
	 * Context for raidiodone.
	 */
	raidbp->rf_obp = bp;
	raidbp->req = req;

	LIST_INIT(&raidbp->rf_buf.b_dep);

	switch (req->type) {
	case RF_IO_TYPE_NOP:
		/* Used primarily to unlock a locked queue. */

		db1_printf(("rf_DispatchKernelIO: NOP to r %d c %d\n",
		    queue->row, queue->col));

		/* XXX need to do something extra here... */

		/*
		 * I'm leaving this in, as I've never actually seen it
		 * used, and I'd like folks to report it... GO
		 */
		db1_printf(("WAKEUP CALLED\n"));
		queue->numOutstanding++;

		/* XXX need to glue the original buffer into this ?? */

		rf_KernelWakeupFunc(&raidbp->rf_buf);
		break;

	case RF_IO_TYPE_READ:
	case RF_IO_TYPE_WRITE:
		if (req->tracerec) {
			RF_ETIMER_START(req->tracerec->timer);
		}

		rf_InitBP(&raidbp->rf_buf, queue->rf_cinfo->ci_vp,
		    op | bp->b_flags, queue->rf_cinfo->ci_dev,
		    req->sectorOffset, req->numSector,
		    req->buf, rf_KernelWakeupFunc, (void *)req,
		    queue->raidPtr->logBytesPerSector, req->b_proc);

		if (rf_debugKernelAccess) {
			db1_printf(("dispatch: bp->b_blkno = %ld\n",
			    (long)bp->b_blkno));
		}
		queue->numOutstanding++;
		queue->last_deq_sector = req->sectorOffset;

		/*
		 * Acc wouldn't have been let in if there were any
		 * pending reqs at any other priority.
		 */
		queue->curPriority = req->priority;

		db1_printf(("Going for %c to unit %d row %d col %d\n",
		    req->type, unit, queue->row, queue->col));
		db1_printf(("sector %d count %d (%d bytes) %d\n",
		    (int)req->sectorOffset, (int)req->numSector,
		    (int)(req->numSector << queue->raidPtr->logBytesPerSector),
		    (int)queue->raidPtr->logBytesPerSector));
		if ((raidbp->rf_buf.b_flags & B_READ) == 0) {
			raidbp->rf_buf.b_vp->v_numoutput++;
		}

		VOP_STRATEGY(&raidbp->rf_buf);
		break;

	default:
		panic("bad req->type in rf_DispatchKernelIO");
	}
	db1_printf(("Exiting from DispatchKernelIO\n"));
	/*splx(s);*/	/* want to test this */
	return (0);
}

/*
 * This is the callback function associated with a I/O invoked from
 * kernel code.
 */
void
rf_KernelWakeupFunc(struct buf *vbp)
{
	RF_DiskQueueData_t *req = NULL;
	RF_DiskQueue_t *queue;
	struct raidbuf *raidbp = (struct raidbuf *)vbp;
	struct buf *bp;
	struct raid_softc *rs;
	int unit;
	int s;

	s = splbio();
	db1_printf(("recovering the request queue:\n"));
	req = raidbp->req;

	bp = raidbp->rf_obp;

	queue = (RF_DiskQueue_t *)req->queue;

	if (raidbp->rf_buf.b_flags & B_ERROR) {
		bp->b_flags |= B_ERROR;
		bp->b_error =
		    raidbp->rf_buf.b_error ? raidbp->rf_buf.b_error : EIO;
	}

#if 1
	/* XXX Methinks this could be wrong... */
	bp->b_resid = raidbp->rf_buf.b_resid;
#endif

	if (req->tracerec) {
		RF_ETIMER_STOP(req->tracerec->timer);
		RF_ETIMER_EVAL(req->tracerec->timer);
		RF_LOCK_MUTEX(rf_tracing_mutex);
		req->tracerec->diskwait_us +=
		    RF_ETIMER_VAL_US(req->tracerec->timer);
		req->tracerec->phys_io_us +=
		    RF_ETIMER_VAL_US(req->tracerec->timer);
		req->tracerec->num_phys_ios++;
		RF_UNLOCK_MUTEX(rf_tracing_mutex);
	}

	bp->b_bcount = raidbp->rf_buf.b_bcount;	/* XXXX ?? */

	unit = queue->raidPtr->raidid;	/* *Much* simpler :-> */

	/*
	 * XXX Ok, let's get aggressive...  If B_ERROR is set, let's go
	 * ballistic, and mark the component as hosed...
	 */
	if (bp->b_flags & B_ERROR) {
		/* Mark the disk as dead but only mark it once... */
		if (queue->raidPtr->Disks[queue->row][queue->col].status ==
		    rf_ds_optimal) {
			printf("raid%d: IO Error.  Marking %s as failed.\n",
			    unit,
			    queue->raidPtr->
			    Disks[queue->row][queue->col].devname);
			queue->raidPtr->Disks[queue->row][queue->col].status =
			    rf_ds_failed;
			queue->raidPtr->status[queue->row] = rf_rs_degraded;
			queue->raidPtr->numFailures++;
			queue->raidPtr->numNewFailures++;
		} else {
			/* Disk is already dead... */
			/* printf("Disk already marked as dead!\n"); */
		}
	}

	rs = &raid_softc[unit];
	RAIDPUTBUF(rs, raidbp);

	rf_DiskIOComplete(queue, req, (bp->b_flags & B_ERROR) ? 1 : 0);
	(req->CompleteFunc)(req->argument, (bp->b_flags & B_ERROR) ? 1 : 0);

	splx(s);
}

/*
 * Initialize a buf structure for doing an I/O in the kernel.
 */
void
rf_InitBP(
	struct buf	 *bp,
	struct vnode	 *b_vp,
	unsigned	  rw_flag,
	dev_t		  dev,
	RF_SectorNum_t	  startSect,
	RF_SectorCount_t  numSect,
	caddr_t		  buf,
	void		(*cbFunc)(struct buf *),
	void		 *cbArg,
	int		  logBytesPerSector,
	struct proc	 *b_proc
)
{
	/*bp->b_flags = B_PHYS | rw_flag;*/
	bp->b_flags = B_CALL | rw_flag;	/* XXX need B_PHYS here too ??? */
	bp->b_bcount = numSect << logBytesPerSector;
	bp->b_bufsize = bp->b_bcount;
	bp->b_error = 0;
	bp->b_dev = dev;
	bp->b_data = buf;
	bp->b_blkno = startSect;
	bp->b_resid = bp->b_bcount;	/* XXX is this right !??!?!! */
	if (bp->b_bcount == 0) {
		panic("bp->b_bcount is zero in rf_InitBP!!");
	}
	bp->b_proc = b_proc;
	bp->b_iodone = cbFunc;
	bp->b_vp = b_vp;
	LIST_INIT(&bp->b_dep);
}

void
raidgetdefaultlabel(RF_Raid_t *raidPtr, struct raid_softc *rs,
    struct disklabel *lp)
{
	db1_printf(("Building a default label...\n"));
	bzero(lp, sizeof(*lp));

	/* Fabricate a label... */
	DL_SETDSIZE(lp, raidPtr->totalSectors);
	lp->d_secsize = raidPtr->bytesPerSector;
	lp->d_nsectors = raidPtr->Layout.dataSectorsPerStripe;
	lp->d_ntracks = 4 * raidPtr->numCol;
	lp->d_ncylinders = raidPtr->totalSectors /
	    (lp->d_nsectors * lp->d_ntracks);
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;

	strncpy(lp->d_typename, "raid", sizeof(lp->d_typename));
	lp->d_type = DTYPE_RAID;
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
	lp->d_flags = 0;
	lp->d_version = 1;

	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	DL_SETPSIZE(&lp->d_partitions[RAW_PART], raidPtr->totalSectors);
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = MAXPARTITIONS;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(rs->sc_dkdev.dk_label);
}

/*
 * Read the disklabel from the raid device.
 * If one is not present, fake one up.
 */
int
raidgetdisklabel(dev_t dev, struct raid_softc *rs, struct disklabel *lp,
    int spoofonly)
{
	int unit = DISKUNIT(dev);
	RF_Raid_t *raidPtr;
	int error, i;
	struct partition *pp;

	db1_printf(("Getting the disklabel...\n"));

	bzero(lp, sizeof(*lp));

	raidPtr = raidPtrs[unit];

	raidgetdefaultlabel(raidPtr, rs, lp);

	/*
	 * Call the generic disklabel extraction routine.
	 */
	error = readdisklabel(DISKLABELDEV(dev), raidstrategy, lp,
	    spoofonly);
	if (error)
		return (error);

	/*
	 * Sanity check whether the found disklabel is valid.
	 *
	 * This is necessary since total size of the raid device
	 * may vary when an interleave is changed even though exactly
	 * same componets are used, and old disklabel may used
	 * if that is found.
	 */
#ifdef	RAIDDEBUG
	if (DL_GETDSIZE(lp) != rs->sc_size)
		printf("WARNING: %s: "
		    "total sector size in disklabel (%d) != "
		    "the size of raid (%ld)\n", rs->sc_xname,
		    DL_GETDSIZE(lp), (long) rs->sc_size);
#endif	/* RAIDDEBUG */
	for (i = 0; i < lp->d_npartitions; i++) {
		pp = &lp->d_partitions[i];
		if (DL_GETPOFFSET(pp) + DL_GETPSIZE(pp) > rs->sc_size)
			printf("WARNING: %s: end of partition `%c' "
			    "exceeds the size of raid (%ld)\n",
			    rs->sc_xname, 'a' + i, (long) rs->sc_size);
	}
	return (0);
}

/*
 * Lookup the provided name in the filesystem.	If the file exists,
 * is a valid block device, and isn't being used by anyone else,
 * set *vpp to the file's vnode.
 * You'll find the original of this in ccd.c
 */
int
raidlookup(char *path, struct proc *p, struct vnode **vpp /* result */)
{
	struct nameidata nd;
	struct vnode *vp;
	struct vattr va;
	int error;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);
	if ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {
#ifdef	RAIDDEBUG
		printf("RAIDframe: vn_open returned %d\n", error);
#endif	/* RAIDDEBUG */
		return (error);
	}
	vp = nd.ni_vp;
	if (vp->v_usecount > 1) {
		VOP_UNLOCK(vp, 0, p);
		(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
		return (EBUSY);
	}
	if ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {
		VOP_UNLOCK(vp, 0, p);
		(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
		return (error);
	}
	/* XXX: eventually we should handle VREG, too. */
	if (va.va_type != VBLK) {
		VOP_UNLOCK(vp, 0, p);
		(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
		return (ENOTBLK);
	}
	VOP_UNLOCK(vp, 0, p);
	*vpp = vp;
	return (0);
}

/*
 * Wait interruptibly for an exclusive lock.
 *
 * XXX
 * Several drivers do this; it should be abstracted and made MP-safe.
 * (Hmm... where have we seen this warning before :->  GO )
 */
int
raidlock(struct raid_softc *rs)
{
	int error;

	while ((rs->sc_flags & RAIDF_LOCKED) != 0) {
		rs->sc_flags |= RAIDF_WANTED;
		if ((error = tsleep(rs, PRIBIO | PCATCH, "raidlck", 0)) != 0)
			return (error);
	}
	rs->sc_flags |= RAIDF_LOCKED;
	return (0);
}

/*
 * Unlock and wake up any waiters.
 */
void
raidunlock(struct raid_softc *rs)
{
	rs->sc_flags &= ~RAIDF_LOCKED;
	if ((rs->sc_flags & RAIDF_WANTED) != 0) {
		rs->sc_flags &= ~RAIDF_WANTED;
		wakeup(rs);
	}
}


#define	RF_COMPONENT_INFO_OFFSET	16384	/* bytes */
#define	RF_COMPONENT_INFO_SIZE		 1024	/* bytes */

int
raidmarkclean(dev_t dev, struct vnode *b_vp, int mod_counter)
{
	RF_ComponentLabel_t clabel;
	raidread_component_label(dev, b_vp, &clabel);
	clabel.mod_counter = mod_counter;
	clabel.clean = RF_RAID_CLEAN;
	raidwrite_component_label(dev, b_vp, &clabel);
	return(0);
}


int
raidmarkdirty(dev_t dev, struct vnode *b_vp, int mod_counter)
{
	RF_ComponentLabel_t clabel;
	raidread_component_label(dev, b_vp, &clabel);
	clabel.mod_counter = mod_counter;
	clabel.clean = RF_RAID_DIRTY;
	raidwrite_component_label(dev, b_vp, &clabel);
	return(0);
}

/* ARGSUSED */
int
raidread_component_label(dev_t dev, struct vnode *b_vp,
    RF_ComponentLabel_t *clabel)
{
	struct buf *bp;
	int error;

	/*
	 * XXX should probably ensure that we don't try to do this if
	 * someone has changed rf_protected_sectors.
	 */

	if (b_vp == NULL) {
		/*
		 * For whatever reason, this component is not valid.
		 * Don't try to read a component label from it.
		 */
		return(EINVAL);
	}

	/* Get a block of the appropriate size... */
	bp = geteblk((int)RF_COMPONENT_INFO_SIZE);
	bp->b_dev = dev;

	/* Get our ducks in a row for the read. */
	bp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;
	bp->b_bcount = RF_COMPONENT_INFO_SIZE;
	bp->b_flags |= (B_READ | B_RAW);
 	bp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;

	(*bdevsw[major(bp->b_dev)].d_strategy)(bp);

	error = biowait(bp);

	if (!error) {
		memcpy(clabel, bp->b_data, sizeof(RF_ComponentLabel_t));
#if 0
		rf_print_component_label( clabel );
#endif
	} else {
		db1_printf(("Failed to read RAID component label!\n"));
	}

	brelse(bp);
	return(error);
}

/* ARGSUSED */
int
raidwrite_component_label(dev_t dev, struct vnode *b_vp,
    RF_ComponentLabel_t *clabel)
{
	struct buf *bp;
	int error;

	/* Get a block of the appropriate size... */
	bp = geteblk((int)RF_COMPONENT_INFO_SIZE);
	bp->b_dev = dev;

	/* Get our ducks in a row for the write. */
	bp->b_blkno = RF_COMPONENT_INFO_OFFSET / DEV_BSIZE;
	bp->b_bcount = RF_COMPONENT_INFO_SIZE;
	bp->b_flags |= (B_WRITE | B_RAW);
 	bp->b_resid = RF_COMPONENT_INFO_SIZE / DEV_BSIZE;

	memset(bp->b_data, 0, RF_COMPONENT_INFO_SIZE );

	memcpy(bp->b_data, clabel, sizeof(RF_ComponentLabel_t));

	(*bdevsw[major(bp->b_dev)].d_strategy)(bp);
	error = biowait(bp);
	brelse(bp);
	if (error) {
		printf("Failed to write RAID component info!\n");
	}

	return(error);
}

void
rf_markalldirty(RF_Raid_t *raidPtr)
{
	RF_ComponentLabel_t clabel;
	int r,c;

	raidPtr->mod_counter++;
	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			/*
			 * We don't want to touch (at all) a disk that has
			 * failed.
			 */
			if (!RF_DEAD_DISK(raidPtr->Disks[r][c].status)) {
				raidread_component_label(
				    raidPtr->Disks[r][c].dev,
				    raidPtr->raid_cinfo[r][c].ci_vp, &clabel);
				if (clabel.status == rf_ds_spared) {
					/*
					 * XXX do something special...
					 * But whatever you do, don't
					 * try to access it !!!
					 */
				} else {
#if 0
					clabel.status =
					    raidPtr->Disks[r][c].status;
					raidwrite_component_label(
					    raidPtr->Disks[r][c].dev,
					    raidPtr->raid_cinfo[r][c].ci_vp,
					    &clabel);
#endif
					raidmarkdirty(
					    raidPtr->Disks[r][c].dev,
					    raidPtr->raid_cinfo[r][c].ci_vp,
					    raidPtr->mod_counter);
				}
			}
		}
	}
	/*printf("Component labels marked dirty.\n");*/
#if 0
	for( c = 0; c < raidPtr->numSpare ; c++) {
		sparecol = raidPtr->numCol + c;
		if (raidPtr->Disks[r][sparecol].status == rf_ds_used_spare) {
			/*
			 * XXX This is where we get fancy and map this spare
			 * into it's correct spot in the array.
			 */
			/*
			 * We claim this disk is "optimal" if it's
			 * rf_ds_used_spare, as that means it should be
			 * directly substitutable for the disk it replaced.
			 * We note that too...
			 */

			for(i=0;i<raidPtr->numRow;i++) {
				for(j=0;j<raidPtr->numCol;j++) {
					if ((raidPtr->Disks[i][j].spareRow ==
					     r) &&
					    (raidPtr->Disks[i][j].spareCol ==
					     sparecol)) {
						srow = r;
						scol = sparecol;
						break;
					}
				}
			}

			raidread_component_label(
			    raidPtr->Disks[r][sparecol].dev,
			    raidPtr->raid_cinfo[r][sparecol].ci_vp, &clabel);
			/* Make sure status is noted. */
			clabel.version = RF_COMPONENT_LABEL_VERSION;
			clabel.mod_counter = raidPtr->mod_counter;
			clabel.serial_number = raidPtr->serial_number;
			clabel.row = srow;
			clabel.column = scol;
			clabel.num_rows = raidPtr->numRow;
			clabel.num_columns = raidPtr->numCol;
			clabel.clean = RF_RAID_DIRTY;	/* Changed in a bit. */
			clabel.status = rf_ds_optimal;
			raidwrite_component_label(
			    raidPtr->Disks[r][sparecol].dev,
			    raidPtr->raid_cinfo[r][sparecol].ci_vp, &clabel);
			raidmarkclean( raidPtr->Disks[r][sparecol].dev,
			    raidPtr->raid_cinfo[r][sparecol].ci_vp);
		}
	}

#endif
}


void
rf_update_component_labels(RF_Raid_t *raidPtr, int final)
{
	RF_ComponentLabel_t clabel;
	int sparecol;
	int r,c;
	int i,j;
	int srow, scol;

	srow = -1;
	scol = -1;

	/*
	 * XXX should do extra checks to make sure things really are clean,
	 * rather than blindly setting the clean bit...
	 */

	raidPtr->mod_counter++;

	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			if (raidPtr->Disks[r][c].status == rf_ds_optimal) {
				raidread_component_label(
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&clabel);
				/* Make sure status is noted. */
				clabel.status = rf_ds_optimal;
				/* Bump the counter. */
				clabel.mod_counter = raidPtr->mod_counter;

				raidwrite_component_label(
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&clabel);
				if (final == RF_FINAL_COMPONENT_UPDATE) {
					if (raidPtr->parity_good ==
					    RF_RAID_CLEAN) {
						raidmarkclean(
						    raidPtr->Disks[r][c].dev,
						    raidPtr->
						    raid_cinfo[r][c].ci_vp,
						    raidPtr->mod_counter);
					}
				}
			}
			/* Else we don't touch it... */
		}
	}

	for( c = 0; c < raidPtr->numSpare ; c++) {
		sparecol = raidPtr->numCol + c;
		if (raidPtr->Disks[0][sparecol].status == rf_ds_used_spare) {
			/*
			 * We claim this disk is "optimal" if it's
			 * rf_ds_used_spare, as that means it should be
			 * directly substitutable for the disk it replaced.
			 * We note that too...
			 */

			for(i=0;i<raidPtr->numRow;i++) {
				for(j=0;j<raidPtr->numCol;j++) {
					if ((raidPtr->Disks[i][j].spareRow ==
					     0) &&
					    (raidPtr->Disks[i][j].spareCol ==
					     sparecol)) {
						srow = i;
						scol = j;
						break;
					}
				}
			}

			/* XXX Shouldn't *really* need this... */
			raidread_component_label(
			    raidPtr->Disks[0][sparecol].dev,
			    raidPtr->raid_cinfo[0][sparecol].ci_vp, &clabel);
			/* Make sure status is noted. */

			raid_init_component_label(raidPtr, &clabel);

			clabel.mod_counter = raidPtr->mod_counter;
			clabel.row = srow;
			clabel.column = scol;
			clabel.status = rf_ds_optimal;

			raidwrite_component_label(
			    raidPtr->Disks[0][sparecol].dev,
			    raidPtr->raid_cinfo[0][sparecol].ci_vp, &clabel);
			if (final == RF_FINAL_COMPONENT_UPDATE) {
				if (raidPtr->parity_good == RF_RAID_CLEAN) {
					raidmarkclean(raidPtr->
					    Disks[0][sparecol].dev,
					    raidPtr->
					    raid_cinfo[0][sparecol].ci_vp,
					    raidPtr->mod_counter);
				}
			}
		}
	}
	/*printf("Component labels updated\n");*/
}

void
rf_close_component(RF_Raid_t *raidPtr, struct vnode *vp, int auto_configured)
{
	struct proc *p = curproc;

	if (vp != NULL) {
		if (auto_configured == 1) {
			/* component was opened by rf_find_raid_components() */
			VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, p);
			vrele(vp);
		} else {
			/* component was opened by raidlookup() */
			(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);
		}
	} else {
		printf("vnode was NULL\n");
	}
}

void
rf_UnconfigureVnodes(RF_Raid_t *raidPtr)
{
	int r,c;
	struct vnode *vp;
	int acd;


	/* We take this opportunity to close the vnodes like we should... */

	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			db1_printf(("Closing vnode for row: %d col: %d\n",
			    r, c));
			vp = raidPtr->raid_cinfo[r][c].ci_vp;
			acd = raidPtr->Disks[r][c].auto_configured;
			rf_close_component(raidPtr, vp, acd);
			raidPtr->raid_cinfo[r][c].ci_vp = NULL;
			raidPtr->Disks[r][c].auto_configured = 0;
		}
	}
	for (r = 0; r < raidPtr->numSpare; r++) {
		db1_printf(("Closing vnode for spare: %d\n", r));
		vp = raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp;
		acd = raidPtr->Disks[0][raidPtr->numCol + r].auto_configured;
		rf_close_component(raidPtr, vp, acd);
		raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;
		raidPtr->Disks[0][raidPtr->numCol + r].auto_configured = 0;
	}
}


void
rf_ReconThread(struct rf_recon_req *req)
{
	int s;
	RF_Raid_t *raidPtr;

	s = splbio();
	raidPtr = (RF_Raid_t *) req->raidPtr;
	raidPtr->recon_in_progress = 1;

	rf_FailDisk((RF_Raid_t *) req->raidPtr, req->row, req->col,
		    ((req->flags & RF_FDFLAGS_RECON) ? 1 : 0));

	/* XXX Get rid of this! we don't need it at all... */
	RF_Free(req, sizeof(*req));

	raidPtr->recon_in_progress = 0;
	splx(s);

	/* That's all... */
	kthread_exit(0);	/* Does not return. */
}

void
rf_RewriteParityThread(RF_Raid_t *raidPtr)
{
	int retcode;
	int s;

	s = splbio();
	raidPtr->parity_rewrite_in_progress = 1;
	retcode = rf_RewriteParity(raidPtr);
	if (retcode) {
		printf("raid%d: Error re-writing parity!\n",raidPtr->raidid);
	} else {
		/*
		 * Set the clean bit !  If we shutdown correctly,
		 * the clean bit on each component label will get
		 * set.
		 */
		raidPtr->parity_good = RF_RAID_CLEAN;
	}
	raidPtr->parity_rewrite_in_progress = 0;
	splx(s);

	/* Anyone waiting for us to stop ?  If so, inform them... */
	if (raidPtr->waitShutdown) {
		wakeup(&raidPtr->parity_rewrite_in_progress);
	}

	/* That's all... */
	kthread_exit(0);	/* Does not return. */
}


void
rf_CopybackThread(RF_Raid_t *raidPtr)
{
	int s;

	s = splbio();
	raidPtr->copyback_in_progress = 1;
	rf_CopybackReconstructedData(raidPtr);
	raidPtr->copyback_in_progress = 0;
	splx(s);

	/* That's all... */
	kthread_exit(0);	/* Does not return. */
}


void
rf_ReconstructInPlaceThread(struct rf_recon_req *req)
{
	int retcode;
	int s;
	RF_Raid_t *raidPtr;

	s = splbio();
	raidPtr = req->raidPtr;
	raidPtr->recon_in_progress = 1;
	retcode = rf_ReconstructInPlace(raidPtr, req->row, req->col);
	RF_Free(req, sizeof(*req));
	raidPtr->recon_in_progress = 0;
	splx(s);

	/* That's all... */
	kthread_exit(0);	/* Does not return. */
}


RF_AutoConfig_t *
rf_find_raid_components(void)
{
#ifdef	RAID_AUTOCONFIG
	int major;
	struct vnode *vp;
	struct disklabel label;
	struct device *dv;
	dev_t dev;
	int error;
	int i;
	int good_one;
	RF_ComponentLabel_t *clabel;
	RF_AutoConfig_t *ac;
#endif	/* RAID_AUTOCONFIG */
	RF_AutoConfig_t *ac_list;


	/* Initialize the AutoConfig list. */
	ac_list = NULL;

#ifdef	RAID_AUTOCONFIG
	/* We begin by trolling through *all* the devices on the system. */

	TAILQ_FOREACH(dv, &alldevs, dv_list) {

		/* We are only interested in disks... */
		if (dv->dv_class != DV_DISK)
			continue;

		/* We don't care about floppies... */
		if (!strcmp(dv->dv_cfdata->cf_driver->cd_name,"fd")) {
			continue;
		}

		/*
		 * We need to find the device_name_to_block_device_major
		 * stuff.
		 */
		major = findblkmajor(dv);

		/* Get a vnode for the raw partition of this disk. */

		dev = MAKEDISKDEV(major, dv->dv_unit, RAW_PART);
		if (bdevvp(dev, &vp))
			panic("RAID can't alloc vnode");

		error = VOP_OPEN(vp, FREAD, NOCRED, curproc);

		if (error) {
			/*
			 * "Who cares."  Continue looking
			 * for something that exists.
			 */
			vput(vp);
			continue;
		}

		/* Ok, the disk exists.  Go get the disklabel. */
		error = VOP_IOCTL(vp, DIOCGDINFO, (caddr_t)&label,
				  FREAD, NOCRED, curproc);
		if (error) {
			/*
			 * XXX can't happen - open() would
			 * have errored out (or faked up one).
			 */
			printf("can't get label for dev %s%c (%d)!?!?\n",
			    dv->dv_xname, 'a' + RAW_PART, error);
		}

		/*
		 * We don't need this any more.  We'll allocate it again
		 * a little later if we really do...
		 */
		VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, curproc);
		vrele(vp);

		for (i=0; i < label.d_npartitions; i++) {
			/*
			 * We only support partitions marked as RAID.
			 * Except on sparc/sparc64 where FS_RAID doesn't
			 * fit in the SUN disklabel and we need to look
			 * into each and every partition !!!
			 */
#if !defined(__sparc__) && !defined(__sparc64__) && !defined(__sun3__)
			if (label.d_partitions[i].p_fstype != FS_RAID)
				continue;
#else /* !__sparc__ && !__sparc64__ && !__sun3__ */
			if (label.d_partitions[i].p_fstype == FS_SWAP ||
			    label.d_partitions[i].p_fstype == FS_UNUSED)
				continue;
#endif /* __sparc__ || __sparc64__ || __sun3__ */

			dev = MAKEDISKDEV(major, dv->dv_unit, i);
			if (bdevvp(dev, &vp))
				panic("RAID can't alloc vnode");

			error = VOP_OPEN(vp, FREAD, NOCRED, curproc);
			if (error) {
				/* Whatever... */
				vput(vp);
				continue;
			}

			good_one = 0;

			clabel = (RF_ComponentLabel_t *)
				malloc(sizeof(RF_ComponentLabel_t), M_RAIDFRAME,
				    M_NOWAIT);
			if (clabel == NULL) {
				/* XXX CLEANUP HERE. */
				printf("RAID auto config: out of memory!\n");
				return(NULL); /* XXX probably should panic ? */
			}

			if (!raidread_component_label(dev, vp, clabel)) {
				/* Got the label.  Does it look reasonable ? */
				if (rf_reasonable_label(clabel) &&
				    (clabel->partitionSize <=
				     DL_GETPSIZE(&label.d_partitions[i]))) {
#ifdef	RAIDDEBUG
					printf("Component on: %s%c: %d\n",
					    dv->dv_xname, 'a'+i,
					    DL_GETPSIZE(&label.d_partitions[i]));
					rf_print_component_label(clabel);
#endif	/* RAIDDEBUG */
					/*
					 * If it's reasonable, add it,
					 * else ignore it.
					 */
					ac = (RF_AutoConfig_t *)
						malloc(sizeof(RF_AutoConfig_t),
						    M_RAIDFRAME, M_NOWAIT);
					if (ac == NULL) {
						/* XXX should panic ??? */
						return(NULL);
					}

					snprintf(ac->devname,
						 sizeof ac->devname, "%s%c",
						 dv->dv_xname, 'a'+i);
					ac->dev = dev;
					ac->vp = vp;
					ac->clabel = clabel;
					ac->next = ac_list;
					ac_list = ac;
					good_one = 1;
				}
			}
			if (!good_one) {
				/* Cleanup. */
				free(clabel, M_RAIDFRAME);
				VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, curproc);
				vrele(vp);
			}
		}
	}
#endif	/* RAID_AUTOCONFIG */
	return(ac_list);
}

#ifdef	RAID_AUTOCONFIG
int
rf_reasonable_label(RF_ComponentLabel_t *clabel)
{

	if (((clabel->version==RF_COMPONENT_LABEL_VERSION_1) ||
	     (clabel->version==RF_COMPONENT_LABEL_VERSION)) &&
	    ((clabel->clean == RF_RAID_CLEAN) ||
	     (clabel->clean == RF_RAID_DIRTY)) &&
	    clabel->row >=0 &&
	    clabel->column >= 0 &&
	    clabel->num_rows > 0 &&
	    clabel->num_columns > 0 &&
	    clabel->row < clabel->num_rows &&
	    clabel->column < clabel->num_columns &&
	    clabel->blockSize > 0 &&
	    clabel->numBlocks > 0) {
		/* Label looks reasonable enough... */
		return(1);
	}
	return(0);
}
#endif	/* RAID_AUTOCONFIG */

void
rf_print_component_label(RF_ComponentLabel_t *clabel)
{
	printf("   Row: %d Column: %d Num Rows: %d Num Columns: %d\n",
	    clabel->row, clabel->column, clabel->num_rows, clabel->num_columns);
	printf("   Version: %d Serial Number: %d Mod Counter: %d\n",
	    clabel->version, clabel->serial_number, clabel->mod_counter);
	printf("   Clean: %s Status: %d\n", clabel->clean ? "Yes" : "No",
	    clabel->status );
	printf("   sectPerSU: %d SUsPerPU: %d SUsPerRU: %d\n",
	    clabel->sectPerSU, clabel->SUsPerPU, clabel->SUsPerRU);
	printf("   RAID Level: %c  blocksize: %d numBlocks: %d\n",
	    (char) clabel->parityConfig, clabel->blockSize, clabel->numBlocks);
	printf("   Autoconfig: %s\n", clabel->autoconfigure ? "Yes" : "No" );
	printf("   Contains root partition: %s\n", clabel->root_partition ?
	    "Yes" : "No" );
	printf("   Last configured as: raid%d\n", clabel->last_unit );
#if 0
	printf("   Config order: %d\n", clabel->config_order);
#endif
}

RF_ConfigSet_t *
rf_create_auto_sets(RF_AutoConfig_t *ac_list)
{
	RF_AutoConfig_t *ac;
	RF_ConfigSet_t *config_sets;
	RF_ConfigSet_t *cset;
	RF_AutoConfig_t *ac_next;


	config_sets = NULL;

	/*
	 * Go through the AutoConfig list, and figure out which components
	 * belong to what sets.
	 */
	ac = ac_list;
	while(ac!=NULL) {
		/*
		 * We're going to putz with ac->next, so save it here
		 * for use at the end of the loop.
		 */
		ac_next = ac->next;

		if (config_sets == NULL) {
			/* We will need at least this one... */
			config_sets = (RF_ConfigSet_t *)
				malloc(sizeof(RF_ConfigSet_t), M_RAIDFRAME,
				    M_NOWAIT);
			if (config_sets == NULL) {
				panic("rf_create_auto_sets: No memory!");
			}
			/* This one is easy :) */
			config_sets->ac = ac;
			config_sets->next = NULL;
			config_sets->rootable = 0;
			ac->next = NULL;
		} else {
			/* Which set does this component fit into ? */
			cset = config_sets;
			while(cset!=NULL) {
				if (rf_does_it_fit(cset, ac)) {
					/* Looks like it matches... */
					ac->next = cset->ac;
					cset->ac = ac;
					break;
				}
				cset = cset->next;
			}
			if (cset==NULL) {
				/* Didn't find a match above... new set... */
				cset = (RF_ConfigSet_t *)
					malloc(sizeof(RF_ConfigSet_t),
					    M_RAIDFRAME, M_NOWAIT);
				if (cset == NULL) {
					panic("rf_create_auto_sets: No memory!");
				}
				cset->ac = ac;
				ac->next = NULL;
				cset->next = config_sets;
				cset->rootable = 0;
				config_sets = cset;
			}
		}
		ac = ac_next;
	}


	return(config_sets);
}

int
rf_does_it_fit(RF_ConfigSet_t *cset, RF_AutoConfig_t *ac)
{
	RF_ComponentLabel_t *clabel1, *clabel2;

	/*
	 * If this one matches the *first* one in the set, that's good
	 * enough, since the other members of the set would have been
	 * through here too...
	 */
	/*
	 * Note that we are not checking partitionSize here...
	 *
	 * Note that we are also not checking the mod_counters here.
	 * If everything else matches except the mod_counter, that's
	 * good enough for this test.  We will deal with the mod_counters
	 * a little later in the autoconfiguration process.
	 *
	 *  (clabel1->mod_counter == clabel2->mod_counter) &&
	 *
	 * The reason we don't check for this is that failed disks
	 * will have lower modification counts.  If those disks are
	 * not added to the set they used to belong to, then they will
	 * form their own set, which may result in 2 different sets,
	 * for example, competing to be configured at raid0, and
	 * perhaps competing to be the root filesystem set.  If the
	 * wrong ones get configured, or both attempt to become /,
	 * weird behaviour and or serious lossage will occur.  Thus we
	 * need to bring them into the fold here, and kick them out at
	 * a later point.
	 */

	clabel1 = cset->ac->clabel;
	clabel2 = ac->clabel;
	if ((clabel1->version == clabel2->version) &&
	    (clabel1->serial_number == clabel2->serial_number) &&
	    (clabel1->num_rows == clabel2->num_rows) &&
	    (clabel1->num_columns == clabel2->num_columns) &&
	    (clabel1->sectPerSU == clabel2->sectPerSU) &&
	    (clabel1->SUsPerPU == clabel2->SUsPerPU) &&
	    (clabel1->SUsPerRU == clabel2->SUsPerRU) &&
	    (clabel1->parityConfig == clabel2->parityConfig) &&
	    (clabel1->maxOutstanding == clabel2->maxOutstanding) &&
	    (clabel1->blockSize == clabel2->blockSize) &&
	    (clabel1->numBlocks == clabel2->numBlocks) &&
	    (clabel1->autoconfigure == clabel2->autoconfigure) &&
	    (clabel1->root_partition == clabel2->root_partition) &&
	    (clabel1->last_unit == clabel2->last_unit) &&
	    (clabel1->config_order == clabel2->config_order)) {
		/* If it get's here, it almost *has* to be a match. */
	} else {
		/* It's not consistent with somebody in the set...  Punt. */
		return(0);
	}
	/* All was fine.. It must fit... */
	return(1);
}

int
rf_have_enough_components(RF_ConfigSet_t *cset)
{
	RF_AutoConfig_t *ac;
	RF_AutoConfig_t *auto_config;
	RF_ComponentLabel_t *clabel;
	int r,c;
	int num_rows;
	int num_cols;
	int num_missing;
	int mod_counter;
	int mod_counter_found;
	int even_pair_failed;
	char parity_type;


	/*
	 * Check to see that we have enough 'live' components
	 * of this set.  If so, we can configure it if necessary.
	 */

	num_rows = cset->ac->clabel->num_rows;
	num_cols = cset->ac->clabel->num_columns;
	parity_type = cset->ac->clabel->parityConfig;

	/* XXX Check for duplicate components !?!?!? */

	/* Determine what the mod_counter is supposed to be for this set. */

	mod_counter_found = 0;
	mod_counter = 0;
	ac = cset->ac;
	while(ac!=NULL) {
		if (mod_counter_found==0) {
			mod_counter = ac->clabel->mod_counter;
			mod_counter_found = 1;
		} else {
			if (ac->clabel->mod_counter > mod_counter) {
				mod_counter = ac->clabel->mod_counter;
			}
		}
		ac = ac->next;
	}

	num_missing = 0;
	auto_config = cset->ac;

	for(r=0; r<num_rows; r++) {
		even_pair_failed = 0;
		for(c=0; c<num_cols; c++) {
			ac = auto_config;
			while(ac!=NULL) {
				if ((ac->clabel->row == r) &&
				    (ac->clabel->column == c) &&
				    (ac->clabel->mod_counter == mod_counter)) {
					/* It's this one... */
#ifdef	RAIDDEBUG
					printf("Found: %s at %d,%d\n",
					    ac->devname,r,c);
#endif	/* RAIDDEBUG */
					break;
				}
				ac=ac->next;
			}
			if (ac==NULL) {
				/* Didn't find one here! */
				/*
				 * Special case for RAID 1, especially
				 * where there are more than 2
				 * components (where RAIDframe treats
				 * things a little differently :( )
				 */
				if (parity_type == '1') {
					if (c%2 == 0) {	/* Even component. */
						even_pair_failed = 1;
					} else {	/*
							 * Odd component.
							 * If we're failed,
							 * and so is the even
							 * component, it's
							 * "Good Night, Charlie"
							 */
						if (even_pair_failed == 1) {
							return(0);
						}
					}
				} else {
					/* Normal accounting. */
					num_missing++;
				}
			}
			if ((parity_type == '1') && (c%2 == 1)) {
				/*
				 * Just did an even component, and we didn't
				 * bail... Reset the even_pair_failed flag,
				 * and go on to the next component...
				 */
				even_pair_failed = 0;
			}
		}
	}

	clabel = cset->ac->clabel;

	if (((clabel->parityConfig == '0') && (num_missing > 0)) ||
	    ((clabel->parityConfig == '4') && (num_missing > 1)) ||
	    ((clabel->parityConfig == '5') && (num_missing > 1))) {
		/* XXX This needs to be made *much* more general. */
		/* Too many failures. */
		return(0);
	}
	/*
	 * Otherwise, all is well, and we've got enough to take a kick
	 * at autoconfiguring this set.
	 */
	return(1);
}

void
rf_create_configuration(RF_AutoConfig_t *ac, RF_Config_t *config,
    RF_Raid_t *raidPtr)
{
	RF_ComponentLabel_t *clabel;
	int i;

	clabel = ac->clabel;

	/* 1. Fill in the common stuff. */
	config->numRow = clabel->num_rows;
	config->numCol = clabel->num_columns;
	config->numSpare = 0;	/* XXX Should this be set here ? */
	config->sectPerSU = clabel->sectPerSU;
	config->SUsPerPU = clabel->SUsPerPU;
	config->SUsPerRU = clabel->SUsPerRU;
	config->parityConfig = clabel->parityConfig;
	/* XXX... */
	strlcpy(config->diskQueueType,"fifo", sizeof config->diskQueueType);
	config->maxOutstandingDiskReqs = clabel->maxOutstanding;
	config->layoutSpecificSize = 0;	/* XXX ?? */

	while(ac!=NULL) {
		/*
		 * row/col values will be in range due to the checks
		 * in reasonable_label().
		 */
		strlcpy(config->devnames[ac->clabel->row][ac->clabel->column],
		    ac->devname,
		    sizeof config->devnames[ac->clabel->row][ac->clabel->column]);
		ac = ac->next;
	}

	for(i=0;i<RF_MAXDBGV;i++) {
		config->debugVars[i][0] = '\0';
	}

#ifdef	RAID_DEBUG_ALL

#ifdef	RF_DBG_OPTION
#undef	RF_DBG_OPTION
#endif	/* RF_DBG_OPTION */

#ifdef	__STDC__
#define	RF_DBG_OPTION(_option_,_val_)	do {				\
	snprintf(&(config->debugVars[i++][0]), 50, "%s %ld",		\
	    #_option_, _val_);						\
} while (0)
#else	/* __STDC__ */
#define	RF_DBG_OPTION(_option_,_val_)	do {				\
	snprintf(&(config->debugVars[i++][0]), 50, "%s %ld",		\
	    "/**/_option_/**/", _val_);					\
} while (0)
#endif	/* __STDC__ */

	i = 0;

/*	RF_DBG_OPTION(accessDebug, 0);					*/
/*	RF_DBG_OPTION(accessTraceBufSize, 0);				*/
	RF_DBG_OPTION(cscanDebug, 1);		/* Debug CSCAN sorting.	*/
	RF_DBG_OPTION(dagDebug, 1);
/*	RF_DBG_OPTION(debugPrintUseBuffer, 0);				*/
	RF_DBG_OPTION(degDagDebug, 1);
	RF_DBG_OPTION(disableAsyncAccs, 1);
	RF_DBG_OPTION(diskDebug, 1);
	RF_DBG_OPTION(enableAtomicRMW, 0);
		/*
		 * This debug variable enables locking of the
		 * disk arm during small-write operations.
		 * Setting this variable to anything other than
		 * 0 will result in deadlock.  (wvcii)
		 */
	RF_DBG_OPTION(engineDebug, 1);
	RF_DBG_OPTION(fifoDebug, 1);		/* Debug fifo queueing.	*/
/*	RF_DBG_OPTION(floatingRbufDebug, 1);				*/
/*	RF_DBG_OPTION(forceHeadSepLimit, -1);				*/
/*	RF_DBG_OPTION(forceNumFloatingReconBufs, -1);			*/
		/*
		 * Wire down the number of extra recon buffers
		 * to use.
		 */
/*	RF_DBG_OPTION(keepAccTotals, 1);				*/
		/* Turn on keep_acc_totals. */
	RF_DBG_OPTION(lockTableSize, RF_DEFAULT_LOCK_TABLE_SIZE);
	RF_DBG_OPTION(mapDebug, 1);
	RF_DBG_OPTION(maxNumTraces, -1);

/*	RF_DBG_OPTION(memChunkDebug, 1);				*/
/*	RF_DBG_OPTION(memDebug, 1);					*/
/*	RF_DBG_OPTION(memDebugAddress, 1);				*/
/*	RF_DBG_OPTION(numBufsToAccumulate, 1);				*/
		/*
		 * Number of buffers to accumulate before
		 * doing XOR.
		 */
	RF_DBG_OPTION(prReconSched, 0);
	RF_DBG_OPTION(printDAGsDebug, 1);
	RF_DBG_OPTION(printStatesDebug, 1);
	RF_DBG_OPTION(protectedSectors, 64L);
		/*
		 * Number of sectors at start of disk to exclude
		 * from RAID address space.
		 */
	RF_DBG_OPTION(pssDebug, 1);
	RF_DBG_OPTION(queueDebug, 1);
	RF_DBG_OPTION(quiesceDebug, 1);
	RF_DBG_OPTION(raidSectorOffset, 0);
		/*
		 * Value added to all incoming sectors to debug
		 * alignment problems.
		 */
	RF_DBG_OPTION(reconDebug, 1);
	RF_DBG_OPTION(reconbufferDebug, 1);
	RF_DBG_OPTION(scanDebug, 1);		/* Debug SCAN sorting.	*/
	RF_DBG_OPTION(showXorCallCounts, 0);
		/* Show n-way Xor call counts. */
	RF_DBG_OPTION(shutdownDebug, 1);	/* Show shutdown calls.	*/
	RF_DBG_OPTION(sizePercentage, 100);
	RF_DBG_OPTION(sstfDebug, 1);
		/* Turn on debugging info for sstf queueing. */
	RF_DBG_OPTION(stripeLockDebug, 1);
	RF_DBG_OPTION(suppressLocksAndLargeWrites, 0);
	RF_DBG_OPTION(suppressTraceDelays, 0);
	RF_DBG_OPTION(useMemChunks, 1);
	RF_DBG_OPTION(validateDAGDebug, 1);
	RF_DBG_OPTION(validateVisitedDebug, 1);
		/* XXX turn to zero by default ? */
	RF_DBG_OPTION(verifyParityDebug, 1);
	RF_DBG_OPTION(debugKernelAccess, 1);
		/* DoAccessKernel debugging. */

#if RF_INCLUDE_PARITYLOGGING > 0
	RF_DBG_OPTION(forceParityLogReint, 0);
	RF_DBG_OPTION(numParityRegions, 0);
		/* Number of regions in the array. */
	RF_DBG_OPTION(numReintegrationThreads, 1);
	RF_DBG_OPTION(parityLogDebug, 1);
		/* If nonzero, enables debugging of parity logging. */
	RF_DBG_OPTION(totalInCoreLogCapacity, 1024 * 1024);
		/* Target bytes available for in-core logs. */
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */

#endif	/* RAID_DEBUG_ALL */
}

int
rf_set_autoconfig(RF_Raid_t *raidPtr, int new_value)
{
	RF_ComponentLabel_t clabel;
	struct vnode *vp;
	dev_t dev;
	int row, column;

	raidPtr->autoconfigure = new_value;
	for(row=0; row<raidPtr->numRow; row++) {
		for(column=0; column<raidPtr->numCol; column++) {
			if (raidPtr->Disks[row][column].status ==
			    rf_ds_optimal) {
				dev = raidPtr->Disks[row][column].dev;
				vp = raidPtr->raid_cinfo[row][column].ci_vp;
				raidread_component_label(dev, vp, &clabel);
				clabel.autoconfigure = new_value;
				raidwrite_component_label(dev, vp, &clabel);
			}
		}
	}
	return(new_value);
}

int
rf_set_rootpartition(RF_Raid_t *raidPtr, int new_value)
{
	RF_ComponentLabel_t clabel;
	struct vnode *vp;
	dev_t dev;
	int row, column;

	raidPtr->root_partition = new_value;
	for(row=0; row<raidPtr->numRow; row++) {
		for(column=0; column<raidPtr->numCol; column++) {
			if (raidPtr->Disks[row][column].status ==
			    rf_ds_optimal) {
				dev = raidPtr->Disks[row][column].dev;
				vp = raidPtr->raid_cinfo[row][column].ci_vp;
				raidread_component_label(dev, vp, &clabel);
				clabel.root_partition = new_value;
				raidwrite_component_label(dev, vp, &clabel);
			}
		}
	}
	return(new_value);
}

void
rf_release_all_vps(RF_ConfigSet_t *cset)
{
	RF_AutoConfig_t *ac;

	ac = cset->ac;
	while(ac!=NULL) {
		/* Close the vp, and give it back. */
		if (ac->vp) {
			VOP_CLOSE(ac->vp, FREAD, NOCRED, curproc);
			vrele(ac->vp);
			ac->vp = NULL;
		}
		ac = ac->next;
	}
}


void
rf_cleanup_config_set(RF_ConfigSet_t *cset)
{
	RF_AutoConfig_t *ac;
	RF_AutoConfig_t *next_ac;

	ac = cset->ac;
	while(ac!=NULL) {
		next_ac = ac->next;
		/* Nuke the label. */
		free(ac->clabel, M_RAIDFRAME);
		/* Cleanup the config structure. */
		free(ac, M_RAIDFRAME);
		/* "next..." */
		ac = next_ac;
	}
	/* And, finally, nuke the config set. */
	free(cset, M_RAIDFRAME);
}


void
raid_init_component_label(RF_Raid_t *raidPtr, RF_ComponentLabel_t *clabel)
{
	/* Current version number. */
	clabel->version = RF_COMPONENT_LABEL_VERSION;
	clabel->serial_number = raidPtr->serial_number;
	clabel->mod_counter = raidPtr->mod_counter;
	clabel->num_rows = raidPtr->numRow;
	clabel->num_columns = raidPtr->numCol;
	clabel->clean = RF_RAID_DIRTY;	/* Not clean. */
	clabel->status = rf_ds_optimal;	/* "It's good !" */

	clabel->sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	clabel->SUsPerPU = raidPtr->Layout.SUsPerPU;
	clabel->SUsPerRU = raidPtr->Layout.SUsPerRU;

	clabel->blockSize = raidPtr->bytesPerSector;
	clabel->numBlocks = raidPtr->sectorsPerDisk;

	/* XXX Not portable. */
	clabel->parityConfig = raidPtr->Layout.map->parityConfig;
	clabel->maxOutstanding = raidPtr->maxOutstanding;
	clabel->autoconfigure = raidPtr->autoconfigure;
	clabel->root_partition = raidPtr->root_partition;
	clabel->last_unit = raidPtr->raidid;
	clabel->config_order = raidPtr->config_order;
}

int
rf_auto_config_set(RF_ConfigSet_t *cset, int *unit)
{
	RF_Raid_t *raidPtr;
	RF_Config_t *config;
	int raidID;
	int retcode;

	db1_printf(("RAID autoconfigure\n"));

	retcode = 0;
	*unit = -1;

	/* 1. Create a config structure. */

	config = malloc(sizeof(RF_Config_t), M_RAIDFRAME, M_NOWAIT | M_ZERO);
	if (config==NULL) {
		printf("Out of mem!?!?\n");
				/* XXX Do something more intelligent here. */
		return(1);
	}

	/* XXX raidID needs to be set correctly... */

	/*
	 * 2. Figure out what RAID ID this one is supposed to live at.
	 * See if we can get the same RAID dev that it was configured
	 * on last time...
	 */

	raidID = cset->ac->clabel->last_unit;
	if ((raidID < 0) || (raidID >= numraid)) {
		/* Let's not wander off into lala land. */
		raidID = numraid - 1;
	}
	if (raidPtrs[raidID]->valid != 0) {

		/*
		 * Nope...  Go looking for an alternative...
		 * Start high so we don't immediately use raid0 if that's
		 * not taken.
		 */

		for(raidID = numraid - 1; raidID >= 0; raidID--) {
			if (raidPtrs[raidID]->valid == 0) {
				/* We can use this one ! */
				break;
			}
		}
	}

	if (raidID < 0) {
		/* Punt... */
		printf("Unable to auto configure this set!\n");
		printf("(Out of RAID devs!)\n");
		return(1);
	}
	raidPtr = raidPtrs[raidID];

	/* XXX All this stuff should be done SOMEWHERE ELSE ! */
	raidPtr->raidid = raidID;
	raidPtr->openings = RAIDOUTSTANDING;

	/* 3. Build the configuration structure. */
	rf_create_configuration(cset->ac, config, raidPtr);

	/* 4. Do the configuration. */
	retcode = rf_Configure(raidPtr, config, cset->ac);

	if (retcode == 0) {

		raidinit(raidPtrs[raidID]);

		rf_markalldirty(raidPtrs[raidID]);
		raidPtrs[raidID]->autoconfigure = 1; /* XXX Do this here ? */
		if (cset->ac->clabel->root_partition==1) {
			/*
			 * Everything configured just fine.  Make a note
			 * that this set is eligible to be root.
			 */
			cset->rootable = 1;
			/* XXX Do this here ? */
			raidPtrs[raidID]->root_partition = 1;
		}
	}

	printf(": (%s) total number of sectors is %lu (%lu MB)%s\n",
	    (raidPtrs[raidID]->Layout).map->configName,
	    (unsigned long) raidPtrs[raidID]->totalSectors,
	    (unsigned long) (raidPtrs[raidID]->totalSectors / 1024 *
	    (1 << raidPtrs[raidID]->logBytesPerSector) / 1024),
	    raidPtrs[raidID]->root_partition ? " as root" : "");

	/* 5. Cleanup. */
	free(config, M_RAIDFRAME);

	*unit = raidID;
	return(retcode);
}

void
rf_disk_unbusy(RF_RaidAccessDesc_t *desc)
{
	struct buf *bp;

	bp = (struct buf *)desc->bp;
	disk_unbusy(&raid_softc[desc->raidPtr->raidid].sc_dkdev,
			    (bp->b_bcount - bp->b_resid),
			    (bp->b_flags & B_READ));
}
@


1.65
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.64 2011/06/21 16:46:00 tedu Exp $	*/
@


1.64
log
@remove stupid casts, ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.63 2011/06/05 18:40:33 matthew Exp $	*/
d761 1
a761 1
	if (bounds_check_with_label(bp, lp) <= 0) {
@


1.63
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.62 2011/06/03 21:14:11 matthew Exp $	*/
d964 1
a964 1
		bzero((char *) raidPtr, sizeof(RF_Raid_t));
d1045 1
a1045 1
		bzero((char *) clabel, sizeof(RF_ComponentLabel_t));
d1244 1
a1244 1
		bzero((char *) d_cfg, sizeof(RF_DeviceConfig_t));
@


1.62
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.61 2011/04/14 20:59:35 pea Exp $	*/
a217 2
#define	RAIDF_WLABEL	0x02	/* Label area is writable. */
#define	RAIDF_LABELLING	0x04	/* Unit is currently being labelled. */
a856 1
	case DIOCWLABEL:
a866 1
	case DIOCWLABEL:
a1549 2
		rs->sc_flags |= RAIDF_LABELLING;

a1556 2
		rs->sc_flags &= ~RAIDF_LABELLING;

a1562 7

	case DIOCWLABEL:
		if (*(int *)data != 0)
			rs->sc_flags |= RAIDF_WLABEL;
		else
			rs->sc_flags &= ~RAIDF_WLABEL;
		break;
@


1.61
log
@Make RAIDFRAME compile

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.60 2010/09/23 18:49:39 oga Exp $	*/
a726 1
	int wlabel;
d763 3
a765 4
	wlabel = rs->sc_flags & (RAIDF_WLABEL | RAIDF_LABELLING);
	if (bounds_check_with_label(bp, lp, wlabel) <= 0) {
		db1_printf(("Bounds check failed!!:%d %d\n",
		    (int)bp->b_blkno, (int)wlabel));
@


1.60
log
@The only sensible argument for VOP_* calls that take a struct proc pointer is
curproc. A bunch of callers were passing in 0 (not even NULL, 0) as this
pointer, which was fine until the called vnode function tried to do
something with it. Typically, this code was then copy/pasted to various
parts of the tree.

Accept the facts of life and switch all of these over to passing curproc
for now until the argument can be removed.

Discovered by stsp trying to create a softraid on top of a vnd, which
crashed with a NULL deref in vndioctl.

softraid bits tested by mikeb and jsing. raidframe bits tested by pea,
matthieu and naddy. The rest tested by at least thib, jsing and myself.

ok thib@@, jsing@@.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.59 2010/09/22 01:18:57 matthew Exp $	*/
d3163 1
a3163 1
		config->debugVars[i][0] = NULL;
@


1.59
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.58 2010/09/08 14:47:12 jsing Exp $	*/
d2723 1
a2723 1
		error = VOP_OPEN(vp, FREAD, NOCRED, 0);
d2736 1
a2736 1
				  FREAD, NOCRED, 0);
d2750 1
a2750 1
		VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, 0);
d2773 1
a2773 1
			error = VOP_OPEN(vp, FREAD, NOCRED, 0);
d2828 1
a2828 1
				VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, 0);
d3331 1
a3331 1
			VOP_CLOSE(ac->vp, FREAD, NOCRED, 0);
@


1.58
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.56 2010/05/23 13:49:35 naddy Exp $	*/
d802 1
a802 1
	return (physio(raidstrategy, NULL, dev, B_READ, minphys, uio));
d819 1
a819 1
	return (physio(raidstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.57
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1622 1
a1622 1
	disk_attach(&rs->sc_dkdev);
@


1.56
log
@missing dkio.h includes; ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.55 2010/04/23 23:59:11 krw Exp $	*/
a121 1
#include <sys/user.h>
@


1.55
log
@Make raidframe compile after recent #include rectification. Noted by
oga@@.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.54 2010/04/23 15:25:21 jsing Exp $	*/
d114 1
@


1.54
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.52 2009/08/25 18:46:19 deraadt Exp $	*/
d120 1
@


1.53
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@a2084 1
	lp->d_rpm = 3600;
a2085 1
	lp->d_interleave = 1;
@


1.52
log
@catch up to readdisklabel API change; tested by matthieu
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.51 2009/05/21 23:45:48 krw Exp $	*/
d232 1
a232 1
int  rf_activate(struct device *, enum devact);
d321 1
a321 1
rf_activate(struct device *self, enum devact act)
@


1.51
log
@The only value that d_npartitions should have is MAXPARTITIONS.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.50 2008/07/23 16:24:43 beck Exp $	*/
d266 1
a266 1
void raidgetdisklabel(dev_t, struct raid_softc *, struct disklabel *, int);
d2104 1
a2104 1
void
a2108 1
	char *errstring;
d2110 1
a2110 1
	int i;
d2124 1
a2124 1
	errstring = readdisklabel(DISKLABELDEV(dev), raidstrategy, lp,
d2126 2
a2127 4
	if (errstring) {
		/*printf("%s: %s\n", rs->sc_xname, errstring);*/
		return;
	}
d2151 1
@


1.50
log
@
Correct cases of mishandling of pending reads and writes to prevent
them going negative - this consists of identifying a number of cases of
IO not going through the buffer cache and marking those buffers with
B_RAW - as well as fixing nfs_bio to show pending writes and reads through
the buffer cache via NFS

still has a problem with mishandling the counters I believe in the
async/sync fallback case where counters stay positive which will be
addressed seperately.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.49 2008/06/26 05:42:17 ray Exp $	*/
d2093 1
a2093 1
	lp->d_npartitions = RAW_PART + 1;
@


1.49
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.48 2008/06/15 00:36:41 krw Exp $	*/
d2288 1
a2288 1
	bp->b_flags |= B_READ;
d2323 1
a2323 1
	bp->b_flags |= B_WRITE;
@


1.48
log
@Don't bypass partition bounds check for RAW_PART. We now guarantee that
RAW_PART will always be 0 -> disksize, so the bounds check will always
pass for i/o's to valid addresses. Now the i/o will be properly truncated
if it goes past the end of the device. This prevents various adverse
impacts of issuing i/o's for data past the end of the device.

Repeatedly requested by todd@@.

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.47 2008/03/26 00:48:54 krw Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	  This product includes software developed by the NetBSD
 *	  Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.47
log
@Add DIOCRLDINFO support.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.46 2008/03/24 01:16:58 krw Exp $	*/
d771 6
a776 7
	if (DISKPART(bp->b_dev) != RAW_PART)
		if (bounds_check_with_label(bp, lp, wlabel) <= 0) {
			db1_printf(("Bounds check failed!!:%d %d\n",
			    (int)bp->b_blkno, (int)wlabel));
			biodone(bp);
			goto raidstrategy_end;
		}
@


1.46
log
@Change XXgetdisklabel() to the 'normal' four parameter model to
prepare for adding missing DIOC* ioctl's.

No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.45 2007/11/05 16:09:49 krw Exp $	*/
d836 1
d880 1
d1537 7
@


1.45
log
@Oops. Stray debug printf snuck in.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.44 2007/11/05 16:01:02 krw Exp $	*/
d273 1
a273 1
void raidgetdisklabel(dev_t, struct disklabel *, int);
d623 1
a623 1
		raidgetdisklabel(dev, rs->sc_dkdev.dk_label, 0);
d1580 1
a1580 1
		raidgetdisklabel(dev, (struct disklabel *)data, 1);
d2104 2
a2105 1
raidgetdisklabel(dev_t dev, struct disklabel *lp, int spoofonly)
a2107 1
	struct raid_softc *rs = &raid_softc[unit];
@


1.44
log
@Fix some cpu_switchto fallout. Reading disklabels to find raid
components was causing some systems to hang. The hangs were due to
tsleep() being called before it was prudent to do so.

Create a startup hook to find the raid components when it is safe to
encounter tsleep() but before root is mounted.

Noticed and fix tested by Josh Grosse (who proved the cpu_switchto
link), merdely@@, fkr@@.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.43 2007/09/09 16:50:23 krw Exp $	*/
a434 1
	printf("rf_autoconfig_startuphook\n");
@


1.43
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.42 2007/06/23 03:11:34 krw Exp $	*/
d292 1
a308 10
#ifdef	RAID_AUTOCONFIG
static int raidautoconfig = 0;	/*
				 * Debugging, mostly.  Set to 0 to not
				 * allow autoconfig to take place.
				 * Note that this is overridden by having
				 * RAID_AUTOCONFIG as an option in the
				 * kernel config file.
				 */
#endif	/* RAID_AUTOCONFIG */

a337 4
#ifdef	RAID_AUTOCONFIG
	RF_AutoConfig_t *ac_list;	/* Autoconfig list. */
	RF_ConfigSet_t *config_sets;
#endif	/* RAID_AUTOCONFIG */
d424 10
a433 1
	raidautoconfig = 1;
d435 2
a436 2
	if (raidautoconfig) {
		/* 1. Locate all RAID components on the system. */
d439 1
a439 1
		printf("Searching for raid components...\n");
d441 1
a441 1
		ac_list = rf_find_raid_components();
d443 1
a443 1
		/* 2. Sort them into their respective sets. */
d445 1
a445 1
		config_sets = rf_create_auto_sets(ac_list);
d447 4
a450 14
		/*
		 * 3. Evaluate each set and configure the valid ones
		 * This gets done in rf_buildroothack().
		 */

		/*
		 * Schedule the creation of the thread to do the
		 * "/ on RAID" stuff.
		 */

		rf_buildroothack(config_sets);

	}
#endif	/* RAID_AUTOCONFIG */
d452 1
a454 1
#ifdef	RAID_AUTOCONFIG
@


1.42
log
@Remove raidmakedisklabel(). The only invocation was commented out in
2000, presumably because we spoof a label when one is not found. This
removes the last (?) code that assigned a file type other than
FS_UNUSED to the RAW_PART partition.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.41 2007/06/20 18:18:47 deraadt Exp $	*/
d391 2
a392 2
	raid_softc = (struct raid_softc *)
		malloc(num * sizeof(struct raid_softc), M_RAIDFRAME, M_NOWAIT);
d398 2
a399 5
	bzero(raid_softc, num * sizeof (struct raid_softc));

	raid_scPtrs = (struct raid_softc **)
		malloc(num * sizeof(struct raid_softc *), M_RAIDFRAME,
		    M_NOWAIT);
a404 2
	bzero(raid_scPtrs, num * sizeof (struct raid_softc *));

d1647 1
a1647 1
	cf = malloc(sizeof(struct cfdata), M_RAIDFRAME, M_NOWAIT);
a1651 1
	bzero(cf, sizeof(struct cfdata));
d3421 1
a3421 2
	config = (RF_Config_t *)malloc(sizeof(RF_Config_t), M_RAIDFRAME,
	    M_NOWAIT);
a3426 2

	memset(config, 0, sizeof(RF_Config_t));
@


1.41
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.40 2007/06/12 02:02:17 krw Exp $	*/
a273 1
void raidmakedisklabel(struct raid_softc *);
a2149 1
		/*raidmakedisklabel(rs);*/
a2173 22
}

/*
 * Take care of things one might want to take care of in the event
 * that a disklabel isn't present.
 */
void
raidmakedisklabel(struct raid_softc *rs)
{
	struct disklabel *lp = rs->sc_dkdev.dk_label;
	db1_printf(("Making a label..\n"));

	/*
	 * For historical reasons, if there's no disklabel present
	 * the raw partition must be marked FS_BSDFFS.
	 */

	lp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;

	strncpy(lp->d_packname, "default label", sizeof(lp->d_packname));

	lp->d_checksum = dkcksum(lp);
@


1.40
log
@Bring raidgetdisklabel() into line with all other drivers by passing
the same parameters and honouring the spoofonly flag. DIOCGPDINFO can
thus get the default label using raidgetdisklabel() and spoofonly like
everyone else.

Tested by fkr@@ naddy@@ ho@@.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.39 2007/06/08 05:27:58 deraadt Exp $	*/
d273 1
a273 1
void raidgetdisklabel(dev_t, struct disklabel *, struct cpu_disklabel *, int);
d644 1
a644 2
		raidgetdisklabel(dev, rs->sc_dkdev.dk_label,
		    rs->sc_dkdev.dk_cpulabel, 0);
d793 1
a793 2
		if (bounds_check_with_label(bp, lp, rs->sc_dkdev.dk_cpulabel,
		    wlabel) <= 0) {
d1577 1
a1577 2
		error = setdisklabel(rs->sc_dkdev.dk_label,
		    lp, 0, rs->sc_dkdev.dk_cpulabel);
d1581 1
a1581 2
				    raidstrategy, rs->sc_dkdev.dk_label,
				    rs->sc_dkdev.dk_cpulabel);
d1600 2
a1601 3
	case DIOCGPDINFO: {
		struct cpu_disklabel osdep;
		raidgetdisklabel(dev, (struct disklabel *)data, &osdep, 1);
a1602 1
	}
d2126 1
a2126 2
raidgetdisklabel(dev_t dev, struct disklabel *lp, struct cpu_disklabel *clp,
    int spoofonly)
a2137 1
	bzero(clp, sizeof(*clp));
d2147 1
a2147 1
	    clp, spoofonly);
@


1.39
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.38 2007/06/07 00:49:08 krw Exp $	*/
d273 1
a273 1
void raidgetdisklabel(dev_t);
a625 1
	struct disklabel *lp;
a634 1
	lp = rs->sc_dkdev.dk_label;
d644 2
a645 1
		raidgetdisklabel(dev);
d652 3
a654 2
		    ((part >= lp->d_npartitions) ||
		    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {
d1604 5
a1608 3
	case DIOCGPDINFO:
  		raidgetdefaultlabel(raidPtr, rs, (struct disklabel *) data);
  		break;
d2132 2
a2133 1
raidgetdisklabel(dev_t dev)
a2137 2
	struct disklabel *lp = rs->sc_dkdev.dk_label;
	struct cpu_disklabel *clp = rs->sc_dkdev.dk_cpulabel;
d2144 1
d2155 1
a2155 1
	    rs->sc_dkdev.dk_cpulabel, 0);
@


1.38
log
@Type of raidsize is now daddr64_t, not int. Fixes compile.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.37 2007/06/06 17:15:13 deraadt Exp $	*/
d2111 1
d2113 1
a2113 1
	lp->d_flags = 0;
@


1.37
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.36 2007/06/05 00:38:22 deraadt Exp $	*/
d177 1
a177 1
int  raidsize(dev_t);
d578 1
a578 1
int
@


1.36
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.35 2007/04/28 12:32:13 krw Exp $	*/
d184 1
a184 1
int  raiddump(dev_t, daddr_t, caddr_t, size_t);
d614 1
a614 1
raiddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
d1722 1
a1722 1
	daddr_t blocknum;
d1764 2
a1765 2
		db1_printf(("Blocks: %d, %d\n", (int) bp->b_blkno,
			    (int) blocknum));
@


1.35
log
@CCDLABELDEV/ect and RAIDLABELDEV/etc join other no-op defines in the
trashbin of history, replaced by DISKLABELDEV/etc. No change to .o
files except for __line__.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.34 2007/02/15 00:53:26 krw Exp $	*/
d603 1
a603 1
		size = lp->d_partitions[part].p_size *
d1761 1
a1761 1
			blocknum += pp->p_offset;
d2099 1
a2099 1
	lp->d_secperunit = raidPtr->totalSectors;
d2114 2
a2115 2
	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = raidPtr->totalSectors;
d2168 1
a2168 1
	if (lp->d_secperunit != rs->sc_size)
d2172 1
a2172 1
		    lp->d_secperunit, (long) rs->sc_size);
d2176 1
a2176 1
		if (pp->p_offset + pp->p_size > rs->sc_size)
d2847 1
a2847 1
				     label.d_partitions[i].p_size)) {
d2851 1
a2851 1
					    label.d_partitions[i].p_size);
@


1.34
log
@Don't print the error strings returned by readdisklabel().  If you
need the debug info uncomment the printf's you need. Crude but
effective way to suppress 'no disklabel' errors that pop up at the
most innconvenient times to frighten users. More elegant method,
DPRINTF-like constructs or something, later.

"Yay!" marco@@ ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.33 2006/03/05 21:48:56 miod Exp $	*/
a228 1
#define	raidunit(x)	DISKUNIT(x)
a266 3
#define	RAIDLABELDEV(dev)						\
	(MAKEDISKDEV(major((dev)), raidunit((dev)), RAW_PART))

d585 1
a585 1
	unit = raidunit(dev);
d624 1
a624 1
	int unit = raidunit(dev);
d702 1
a702 1
	int unit = raidunit(dev);
d751 1
a751 1
	unsigned int raidID = raidunit(bp->b_dev);
d818 1
a818 1
	int unit = raidunit(dev);
d839 1
a839 1
	int unit = raidunit(dev);
d855 1
a855 1
	int unit = raidunit(dev);
d1583 1
a1583 1
				error = writedisklabel(RAIDLABELDEV(dev),
d2131 1
a2131 1
	int unit = raidunit(dev);
d2151 1
a2151 1
	errstring = readdisklabel(RAIDLABELDEV(dev), raidstrategy, lp,
@


1.33
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.32 2006/01/21 12:20:51 miod Exp $	*/
d2158 1
a2158 1
		printf("%s: %s\n", rs->sc_xname, errstring);
@


1.32
log
@Remove now unused zeroref member in cfattach structures.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.31 2005/12/08 05:53:45 tedu Exp $	*/
d2756 1
a2756 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
@


1.31
log
@and remove a bogus free spotted after previous commit
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.30 2005/12/08 05:32:55 tedu Exp $	*/
a240 1
void rf_zeroref(struct device *);
d244 1
a244 1
	rf_detach, rf_activate, rf_zeroref
a344 5
}

void
rf_zeroref(struct device *self)
{
@


1.30
log
@missing free, spotted by greg oster
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.29 2005/11/10 01:00:51 pedro Exp $	*/
a1144 1
			RF_Free( clabel, sizeof(RF_ComponentLabel_t));
@


1.29
log
@Fix botch accidentally introduced by me in my last commit here.
Report and testing by kurt@@, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.28 2005/09/18 14:18:18 pedro Exp $	*/
d1104 1
@


1.28
log
@Correctly close RAID components. Fixes PR 4508, okay deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.27 2004/11/28 02:47:14 pedro Exp $	*/
d2604 1
a2604 1
			VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, NULL);
@


1.27
log
@don't hide the process context in rf_close_component(), since we may
need it later on to do locking stuff. fixes the problem with raid
reconstruction, as described in pr 3968. ok mickey@@ tedu@@ tdeval@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.26 2004/02/15 02:45:47 tedu Exp $	*/
d2599 1
a2599 4
	struct proc *p;

	if ((p = raidPtr->engine_thread) == NULL)
		p = curproc;
d2603 2
a2604 1
			VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, p);
d2607 1
a2607 2
			if (VOP_ISLOCKED(vp))
				VOP_UNLOCK(vp, 0, p);
@


1.27.4.1
log
@MFC:
Fix by pedro@@

Correctly close RAID components. Fixes PR 4508.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.27 2004/11/28 02:47:14 pedro Exp $	*/
d2599 4
a2602 1
	struct proc *p = curproc;
a2605 1
			/* component was opened by rf_find_raid_components() */
d2609 2
a2610 1
			/* component was opened by raidlookup() */
@


1.26
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.25 2004/01/14 20:50:49 miod Exp $	*/
d2606 1
a2606 1
			VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, 0);
a2607 1

a2616 1

@


1.26.4.1
log
@MFC:
Fix from pedro@@

don't hide the process context in rf_close_component(), since we may
need it later on to do locking stuff. fixes the problem with raid
reconstruction, as described in pr 3968.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.26 2004/02/15 02:45:47 tedu Exp $	*/
d2606 1
a2606 1
			VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, p);
d2608 1
d2618 1
@


1.25
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.24 2003/06/02 23:28:03 millert Exp $	*/
d3566 2
a3567 1
			    (bp->b_bcount - bp->b_resid));
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.23 2003/04/27 11:22:54 ho Exp $	*/
d205 1
a205 1
	NULL, "raid", DV_DISK, NULL, 0
@


1.23
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.22 2003/01/19 14:32:00 tdeval Exp $	*/
d57 1
a57 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.22
log
@Temporary fix for PR#3069 (thanks for the report, Alex Cichowski), until
I find time to really follow all cases.
At least it works here, and doesn't add new problems, it seems.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.21 2002/12/16 07:01:04 tdeval Exp $	*/
d441 2
a442 1
		sprintf(raidrootdev[raidID].dv_xname,"raid%d",raidID);
d1650 1
a1650 1
	sprintf(rs->sc_xname, "raid%d", unit);
d2885 3
a2887 2
					sprintf(ac->devname, "%s%c",
						dv->dv_xname, 'a'+i);
d3218 1
a3218 1
	strcpy(config->diskQueueType,"fifo");
d3227 3
a3229 2
		strcpy(config->devnames[ac->clabel->row][ac->clabel->column],
		    ac->devname);
@


1.21
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.20 2002/10/12 02:03:46 krw Exp $	*/
d2225 1
a2225 5
raidlookup(
	char		 *path,
	struct proc	 *p,
	struct vnode	**vpp	/* result */
)
d2613 2
a2614 1
			VOP_UNLOCK(vp, 0, p);
@


1.20
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Last bits of diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.19 2002/08/09 15:10:20 tdeval Exp $	*/
d3 1
a81 3



d109 1
a109 1
/***********************************************************
d111 1
a111 1
 * rf_kintf.c -- the kernel interface routines for RAIDframe
d113 1
a113 1
 ***********************************************************/
d157 2
a158 2
#ifdef RAIDDEBUG
#define db1_printf(a) do if (rf_kdebug_level > 0) printf a; while(0)
d160 2
a161 2
#define db1_printf(a) (void)0
#endif	/* RAIDDEBUG */
d163 1
a163 1
static RF_Raid_t **raidPtrs;	/* global raid device descriptors */
d165 1
a165 1
RF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex)
d167 1
a167 1
/* requests to install a spare table */
d170 1
a170 1
/* responses from installation process */
d173 5
a177 5
/* prototypes */
void	rf_KernelWakeupFunc(struct buf *);
void	rf_InitBP(struct buf *, struct vnode *, unsigned, dev_t,
	    RF_SectorNum_t, RF_SectorCount_t, caddr_t, void (*)(struct buf *),
	    void *, int, struct proc *);
d180 9
a188 9
void	raidattach(int);
int	raidsize(dev_t);
int	raidopen(dev_t, int, int, struct proc *);
int	raidclose(dev_t, int, int, struct proc *);
int	raidioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	raidwrite(dev_t, struct uio *, int);
int	raidread(dev_t, struct uio *, int);
void	raidstrategy(struct buf *);
int	raiddump(dev_t, daddr_t, caddr_t, size_t);
d194 4
a197 4
	struct buf rf_buf;	/* new I/O buf.	 MUST BE FIRST!!! */
	struct buf *rf_obp;	/* ptr. to original I/O buf */
	int	rf_flags;	/* misc. flags */
	RF_DiskQueueData_t *req;/* the request that this was part of.. */
d200 2
a201 2
#define RAIDGETBUF(rs)		pool_get(&(rs)->sc_cbufpool, PR_NOWAIT)
#define RAIDPUTBUF(rs, cbp)	pool_put(&(rs)->sc_cbufpool, cbp)
d214 1
a214 1
 * or if it should be used in conjunction with that... 
d217 7
a223 7
	int	 sc_flags;		/* flags */
	int	 sc_cflags;		/* configuration flags */
	size_t	 sc_size;		/* size of the raid device */
	char	 sc_xname[20];		/* XXX external name */
	struct disk sc_dkdev;		/* generic disk device info */
	struct pool sc_cbufpool;	/* component buffer pool */
	struct buf sc_q;		/* used for the device queue */
d227 5
a231 5
#define RAIDF_INITED	0x01	/* unit has been initialized */
#define RAIDF_WLABEL	0x02	/* label area is writable */
#define RAIDF_LABELLING	0x04	/* unit is currently being labelled */
#define RAIDF_WANTED	0x40	/* someone is waiting to obtain a lock */
#define RAIDF_LOCKED	0x80	/* unit is locked */
d241 5
a245 5
int	rf_probe(struct device *, void *, void *);
void	rf_attach(struct device *, struct device *, void *);
int	rf_detach(struct device *, int);
int	rf_activate(struct device *, enum devact);
void	rf_zeroref(struct device *);
d256 4
a259 4
 * 
 * For example: with a stripe width of 64 blocks (32k) and 5 disks, 
 * a single 64K write will typically require 64K for the old data, 
 * 64K for the old parity, and 64K for the new parity, for a total 
d263 1
a263 1
 * 
d265 1
a265 1
 * require data reconstruction, which will require *all* of the 4 remaining 
d269 2
a270 2
#ifndef RAIDOUTSTANDING
#define RAIDOUTSTANDING   6
d273 1
a273 1
#define RAIDLABELDEV(dev)	\
d276 2
a277 2
/* declared here, and made public, for the benefit of KVM stuff.. */
struct raid_softc *raid_softc;
d280 4
a283 4
void	rf_shutdown_hook(RF_ThreadArg_t);
void	raidgetdefaultlabel(RF_Raid_t *, struct raid_softc *, struct disklabel *);
void	raidgetdisklabel(dev_t);
void	raidmakedisklabel(struct raid_softc *);
d285 2
a286 2
int	raidlock(struct raid_softc *);
void	raidunlock(struct raid_softc *);
d288 1
a288 1
void	rf_markalldirty(RF_Raid_t *);
d292 1
a292 1
int findblkmajor(struct device *dv);
d297 1
a297 1
/*void rf_ReconThread(RF_Raid_t *raidPtr);  */
d301 1
a301 1
#ifdef RAID_AUTOCONFIG
d303 2
a304 2
int rf_reasonable_label(RF_ComponentLabel_t *);
#endif
d308 1
a308 1
int rf_does_it_fit(RF_ConfigSet_t *,RF_AutoConfig_t *);
d311 2
a312 2
int rf_set_autoconfig(RF_Raid_t *, int);
int rf_set_rootpartition(RF_Raid_t *, int);
d315 2
a316 2
int rf_have_enough_components(RF_ConfigSet_t *);
int rf_auto_config_set(RF_ConfigSet_t *, int *);
d318 9
a326 7
#ifdef RAID_AUTOCONFIG
static int raidautoconfig = 0; /* Debugging, mostly.  Set to 0 to not
				  allow autoconfig to take place.
			          Note that this is overridden by having
			          RAID_AUTOCONFIG as an option in the 
			          kernel config file.  */
#endif
d329 1
a329 4
rf_probe(parent, match_, aux)
	struct device *parent;
	void *match_;
	void *aux;
d335 1
a335 3
rf_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d337 1
a337 1
	/* struct raid_softc *raid = (void *)self; */
d341 1
a341 3
rf_detach(self, flags)
	struct device *self;
	int flags;
d347 1
a347 3
rf_activate(self, act)
	struct device *self;
	enum devact act;
d353 1
a353 2
rf_zeroref(self)
	struct device *self;
d358 1
a358 2
raidattach(num)
	int num;
d362 2
a363 2
#ifdef RAID_AUTOCONFIG
	RF_AutoConfig_t *ac_list; /* autoconfig list */
d365 1
a365 1
#endif
d370 1
a370 1
#ifdef DIAGNOSTIC
d372 1
a372 1
#endif
d388 2
a389 2
	        RF_PANIC();
        }
d394 1
a394 1
	        raidPtrs[i] = NULL;
d397 1
a397 1
	        printf("Kernelized RAIDframe activated\n");
d399 1
a399 1
	        panic("Serious error booting RAID!!");
d402 1
a402 1
	 * Put together some datastructures like the CCD device does..
d405 1
a405 1
	
d407 1
a407 2
		malloc(num * sizeof(struct raid_softc),
		       M_RAIDFRAME, M_NOWAIT);
d416 2
a417 2
		malloc(num * sizeof(struct raid_softc *),
		       M_RAIDFRAME, M_NOWAIT);
d426 1
a426 1
					      M_RAIDFRAME, M_NOWAIT);
d455 1
a455 1
#ifdef RAID_AUTOCONFIG
d459 1
a459 1
		/* 1. locate all RAID components on the system */
d463 1
a463 1
#endif
d466 1
a466 1
		/* 2. sort them into their respective sets */
d470 4
a473 2
		/* 3. evaluate each set and configure the valid ones
		   This gets done in rf_buildroothack() */
d475 4
a478 2
		/* schedule the creation of the thread to do the 
		   "/ on RAID" stuff */
d483 1
a483 1
#endif
d487 1
a487 1
#ifdef RAID_AUTOCONFIG
d489 1
a489 2
rf_buildroothack(arg)
	void *arg;
d505 1
a505 1
		if (rf_have_enough_components(cset) && 
d512 2
a513 1
					printf("eligible root device %d: raid%d\n", num_root, rootID);
d520 3
a522 2
				printf("Autoconfig failed with code %d for raid%d\n", retcode, raidID);
#endif
d526 4
a529 2
			/* we're not autoconfiguring this set...  
			   release the associated resources */
d532 1
a532 1
		/* cleanup */
d546 1
a546 1
				rootdev = MAKEDISKDEV(majdev,rootID,0); 
d550 1
a550 1
			/* we can't guess.. require the user to answer... */
d555 1
a555 1
#endif
d558 1
a558 2
rf_shutdown_hook(arg)
	RF_ThreadArg_t arg;
d564 1
a564 1
	/* Don't do it if we are not "safe" */
d572 1
a572 1
	/* Shutdown the system */
d592 1
a592 2
raidsize(dev)
	dev_t dev;
d627 1
a627 5
raiddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
d635 1
a635 4
raidopen(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
d642 1
a642 1
	
d661 1
a661 1
	/* make sure that this partition exists */
d675 1
a675 1
	/* Prevent this unit from being unconfigured while open. */
d688 11
a698 7
	        /* First one... mark things as dirty... Note that we *MUST*
	         have done a configure before this.  I DO NOT WANT TO BE
	         SCRIBBLING TO RANDOM COMPONENTS UNTIL IT'S BEEN DETERMINED
	         THAT THEY BELONG TOGETHER!!!!! */
	        /* XXX should check to see if we're only open for reading
	           here... If so, we needn't do this, but then need some
	           other way of keeping track of what's happened.. */
d700 1
a700 1
	        rf_markalldirty( raidPtrs[unit] );
d713 1
a713 4
raidclose(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
d744 6
a749 4
	        /* Last one... device is not unconfigured yet.
	           Device shutdown has taken care of setting the
	           clean bits if RAIDF_INITED is not set
	           mark things as clean... */
d760 1
a760 2
raidstrategy(bp)
	struct buf *bp;
d829 1
a829 4
raidread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d850 1
a850 4
raidwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d866 1
a866 6
raidioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d945 1
a945 1
	
d947 1
a947 1
		/* Configure the system */
d951 1
a951 1
			/* There is a valid RAID set running on this unit! */
d957 1
a957 1
		 * Copy-in the configuration information
d978 1
a978 1
				/* sanity check */
d992 1
a992 1
				RF_Free(specific_buf, 
d999 1
a999 1
		
d1003 1
a1003 1
		 * Store the sum of all the bytes in the last byte?
d1008 2
a1009 2
		 *  there is no stale data left in the case of a 
		 *  reconfiguration 
d1013 1
a1013 1
		/* configure the system */
d1020 4
a1023 2
			/* allow this many simultaneous IO's to
			   this RAID device */
d1025 1
a1025 1
					
d1035 1
a1035 1
		
d1037 1
a1037 1
		
d1039 2
a1040 2
		/* Shutdown the system */
		
d1075 1
a1075 1
		
d1078 4
a1081 2
		/* need to read the component label for the disk indicated
		   by row,column in clabel */
d1083 4
a1086 2
		/* For practice, let's get it directly fromdisk, rather 
		   than from the in-core copy */
d1094 1
a1094 1
		retcode = copyin( *clabel_ptr, clabel, 
d1101 1
a1101 1
 
d1110 2
a1111 4
		raidread_component_label( 
                              raidPtr->Disks[row][column].dev, 
			      raidPtr->raid_cinfo[row][column].ci_vp, 
			      clabel );
d1113 1
a1113 1
		retcode = copyout((caddr_t) clabel, 
d1123 5
a1127 4
		/* Note that some things *should not* get modified --
		   the user should be re-initing the labels instead of 
		   trying to patch things.
		   */
d1140 1
a1140 1
#endif
d1153 2
a1154 4
		raidwrite_component_label( 
                            raidPtr->Disks[row][column].dev, 
			    raidPtr->raid_cinfo[row][column].ci_vp, 
			    clabel );
d1158 1
a1158 1
	case RAIDFRAME_INIT_LABELS:	
d1160 6
a1165 6
		/* 
		   we only want the serial number from
		   the above.  We get all the rest of the information
		   from the config that was used to create this RAID
		   set. 
		   */
d1168 1
a1168 1
		
d1180 3
a1182 3
					raidwrite_component_label( 
					    raidPtr->Disks[row][column].dev, 
					    raidPtr->raid_cinfo[row][column].ci_vp, 
d1189 1
a1189 1
  
d1193 1
a1193 1
			/* Parity for RAID 0 is trivially correct */
d1198 1
a1198 1
		
d1200 1
a1200 1
			/* Re-write is already in progress! */
d1234 1
a1234 1
		memcpy( &component, componentPtr, 
d1241 1
a1241 1
		memcpy( &component, componentPtr, 
d1249 1
a1249 1
			/* Can't do this on a RAID 0!! */
d1254 1
a1254 1
			/* a reconstruct is already in progress! */
d1259 1
a1259 1
		memcpy( &component, componentPtr, 
d1328 1
a1328 1
  
d1337 1
a1337 1
  
d1342 1
a1342 1
	/* fail a disk & optionally start reconstruction */
d1345 1
a1345 1
		
d1351 2
a1352 2
		       unit, rr->row, rr->col));
		
d1355 1
a1355 1
		 * rely on the user's buffer
d1367 1
a1367 1
		
d1372 1
a1372 1
	case RAIDFRAME_COPYBACK:		
d1374 1
a1374 1
			/* This makes no sense on a RAID 0!! */
d1377 1
a1377 1
  
d1379 1
a1379 1
			/* Copyback is already in progress! */
d1382 1
a1382 1
  
d1388 1
a1388 1
	/* Return the percentage completion of reconstruction */
d1391 4
a1394 2
			/* This makes no sense on a RAID 0, so tell the
			   user it's done. */
d1414 1
a1414 1
			progressInfo.total = 
d1416 1
a1416 1
			progressInfo.completed = 
d1428 4
a1431 2
			/* This makes no sense on a RAID 0, so tell the
			   user it's done. */
d1436 2
a1437 2
			*(int *) data = 100 * 
				raidPtr->parity_rewrite_stripes_done / 
d1448 1
a1448 1
			progressInfo.completed = 
d1464 1
a1464 1
			/* This makes no sense on a RAID 0 */
d1480 1
a1480 1
			progressInfo.completed = 
d1516 1
a1516 1
		
d1518 1
a1518 1
		
d1521 1
a1521 1
		
d1539 1
a1539 1
		 * into the kernel
d1541 2
a1542 2
		
		/* Install the spare table */
d1544 1
a1544 1
		
d1546 2
a1547 2
		 * Respond to the requestor.  the return status of the
		 * spare table installation is passed in the "fcol" field
d1556 1
a1556 1
		
d1559 1
a1559 1
	/* fall through to the os-specific code below */
d1563 1
a1563 1
	
d1566 1
a1566 1
	
d1620 1
a1620 1
  
d1629 1
a1629 1
 * raidinit -- complete the rest of the initialization for the
d1633 1
a1633 2
raidinit(raidPtr)
	RF_Raid_t *raidPtr;
d1637 1
a1637 1
	int      unit;
d1644 1
a1644 1
	
d1648 1
a1648 1
	/* XXX doesn't check bounds.*/
d1651 1
a1651 1
	rs->sc_dkdev.dk_name = rs->sc_xname;	
d1655 2
a1656 2
	 * other things, so it's critical to call this *BEFORE* we
	 * try putzing with disklabels.
d1685 1
a1685 1
 * Wake up the daemon & tell it to get us a spare table
d1687 3
a1689 3
 * The entries in the queues should be tagged with the raidPtr so that in the
 * extremely rare case that two recons happen at once, we know for
 * which device were requesting a spare table.
d1691 1
a1691 1
 * 
d1695 1
a1695 2
rf_GetSpareTableFromDaemon(req)
	RF_SparetWait_t	 *req;
d1704 1
a1704 1
	/* mpsleep unlocks the mutex */
d1707 1
a1707 1
		       "raidframe getsparetable", 0);
d1714 1
a1714 1
	/* this is not the same req as we alloc'd */
d1721 5
a1725 5
 * bp & passes it down.
 * Any calls originating in the kernel must use non-blocking I/O
 * do some extra sanity checking to return "appropriate" error values for
 * certain conditions (to make some standard utilities work)
 * 
d1729 1
a1729 2
raidstart(raidPtr)
	RF_Raid_t *raidPtr;
d1735 1
a1735 1
	daddr_t blocknum;	
d1744 1
a1744 1
	/* quick check to see if anything has died recently */
d1747 1
a1747 1
		rf_update_component_labels(raidPtr, 
d1757 1
a1757 1
  
d1760 1
a1760 1
			/* nothing more to do */
d1765 6
a1770 4
		/* Ok, for the bp we have here, bp->b_blkno is relative to the
		 * partition.. Need to make it absolute to the underlying 
		 * device.. */
  
d1776 2
a1777 2
  
		db1_printf(("Blocks: %d, %d\n", (int) bp->b_blkno, 
d1779 1
a1779 1
		
d1782 5
a1786 3
		
		/* *THIS* is where we adjust what block we're going to... 
		 * but DO NOT TOUCH bp->b_blkno!!! */
d1788 1
a1788 1
		
d1793 3
a1795 3
			db1_printf(("raid_addr=%d sum=%d num_blocks=%d(+%d) (%d)\n",
				    (int) raid_addr, (int) sum, (int) num_blocks,
				    (int) pb, (int) bp->b_resid));
d1803 1
a1803 1
				    __func__, bp)); */
d1810 1
a1810 1
		 * XXX rf_DoAccess() should do this, not just DoAccessKernel()
d1812 1
a1812 1
		
d1818 1
a1818 1
				    __func__, bp)); */
d1823 1
a1823 1
			
d1826 2
a1827 2
		
  
d1836 1
a1836 1
		
a1837 3
		
		/* XXX we're still at splbio() here... do we *really* 
		 * need to be? */
d1839 9
a1847 2
		/* don't ever condition on bp->b_flags & B_WRITE.  
		 * always condition on B_READ instead */
d1852 1
a1852 1
				      bp->b_data, bp, NULL, NULL, 
d1860 1
a1860 1
/* Invoke an I/O from kernel mode.  Disk queue should be locked upon entry */
d1863 1
a1863 3
rf_DispatchKernelIO(queue, req)
	RF_DiskQueue_t *queue;
	RF_DiskQueueData_t *req;
d1870 2
a1871 5
	int s;
  
	s=0;
	/* s = splbio();*/ /* want to test this */
	
d1874 1
a1874 1
	 * this device..
d1877 1
a1877 1
	
d1894 1
a1894 1
	 * us a buffer that contains old stuff!!  Attempt to deal with
d1896 2
a1897 2
	 * (not sure where the real bug is.  It's buried in RAIDframe
	 * somewhere) :-(  GO )
d1909 1
a1909 1
	raidbp->rf_flags = 0; /* XXX not really used anywhere... */
d1912 1
a1912 1
	 * context for raidiodone
d1926 1
a1926 1
		/* XXX need to do something extra here.. */
d1935 1
a1935 1
		/* XXX need to glue the original buffer into this??  */
d1939 1
a1939 1
		
d1949 1
a1949 1
		    req->buf, rf_KernelWakeupFunc, (void *)req,	
d1977 1
a1977 1
		
d1982 1
a1982 1
	/* splx(s); */ /* want to test this */
d1991 1
a1991 2
rf_KernelWakeupFunc(vbp)
	struct buf *vbp;
d2032 1
a2032 1
	bp->b_bcount = raidbp->rf_buf.b_bcount;/* XXXX ?? */
d2034 1
a2034 1
	unit = queue->raidPtr->raidid; /* *Much* simpler :-> */
d2037 1
a2037 1
	 * XXX Ok, let's get aggressive... If B_ERROR is set, let's go
d2072 13
a2084 13
rf_InitBP(bp, b_vp, rw_flag, dev, startSect, numSect, buf, cbFunc, cbArg,
    logBytesPerSector, b_proc)
	struct buf *bp;
	struct vnode *b_vp;
	unsigned rw_flag;
	dev_t dev;
	RF_SectorNum_t startSect;
	RF_SectorCount_t numSect;
	caddr_t buf;
	void (*cbFunc)(struct buf *);
	void *cbArg;
	int logBytesPerSector;
	struct proc *b_proc;
d2086 2
a2087 2
	/* bp->b_flags = B_PHYS | rw_flag; */
	bp->b_flags = B_CALL | rw_flag; /* XXX need B_PHYS here too??? */
d2094 1
a2094 1
	bp->b_resid = bp->b_bcount; /* XXX is this right!??!?!! */
d2105 2
a2106 4
raidgetdefaultlabel(raidPtr, rs, lp)
	RF_Raid_t *raidPtr;
	struct raid_softc *rs;
	struct disklabel *lp;
d2111 1
a2111 1
	/* fabricate a label... */
d2116 2
a2117 2
	lp->d_ncylinders = raidPtr->totalSectors / 
		(lp->d_nsectors * lp->d_ntracks);
d2138 2
a2139 2
 * Read the disklabel from the raid device.  If one is not present, fake one
 * up.
d2142 1
a2142 2
raidgetdisklabel(dev)
	dev_t dev;
d2169 1
a2169 1
		/*raidmakedisklabel(rs); */
d2201 1
a2201 2
raidmakedisklabel(rs)
	struct raid_softc *rs;
d2225 5
a2229 4
raidlookup(path, p, vpp)
	char *path;
	struct proc *p;
	struct vnode **vpp;	/* result */
d2273 1
a2273 2
raidlock(rs)
	struct raid_softc *rs;
d2290 1
a2290 2
raidunlock(rs)
	struct raid_softc *rs;
a2297 1
 
a2298 2
#define RF_COMPONENT_INFO_OFFSET  16384 /* bytes */
#define RF_COMPONENT_INFO_SIZE     1024 /* bytes */
d2300 4
a2303 1
int 
d2315 1
a2315 1
int 
d2328 2
a2329 4
raidread_component_label(dev, b_vp, clabel)
	dev_t dev;
	struct vnode *b_vp;
	RF_ComponentLabel_t *clabel;
d2333 5
a2337 3
	
	/* XXX should probably ensure that we don't try to do this if
	   someone has changed rf_protected_sectors. */ 
d2340 4
a2343 2
		/* For whatever reason, this component is not valid.
		   Don't try to read a component label from it. */
d2347 1
a2347 1
	/* get a block of the appropriate size... */
d2351 1
a2351 1
	/* get our ducks in a row for the read */
d2359 1
a2359 1
	error = biowait(bp); 
d2362 1
a2362 2
		memcpy(clabel, bp->b_data,
		       sizeof(RF_ComponentLabel_t));
d2366 1
a2366 1
        } else {
d2370 1
a2370 1
	brelse(bp); 
d2375 3
a2377 5
int 
raidwrite_component_label(dev, b_vp, clabel)
	dev_t dev; 
	struct vnode *b_vp;
	RF_ComponentLabel_t *clabel;
d2382 1
a2382 1
	/* get a block of the appropriate size... */
d2386 1
a2386 1
	/* get our ducks in a row for the write */
d2397 1
a2397 1
	error = biowait(bp); 
d2406 2
a2407 3
void 
rf_markalldirty(raidPtr)
	RF_Raid_t *raidPtr;
d2415 4
a2418 2
			/* we don't want to touch (at all) a disk that has
			   failed */
d2421 2
a2422 3
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&clabel);
d2424 5
a2428 3
					/* XXX do something special... 
					 but whatever you do, don't 
					 try to access it!! */
d2431 11
a2441 11
				clabel.status = 
					raidPtr->Disks[r][c].status;
				raidwrite_component_label( 
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&clabel);
#endif
				raidmarkdirty( 
				       raidPtr->Disks[r][c].dev, 
				       raidPtr->raid_cinfo[r][c].ci_vp,
				       raidPtr->mod_counter);
d2444 1
a2444 1
		} 
d2446 1
a2446 1
	/* printf("Component labels marked dirty.\n"); */
d2451 3
a2453 5
			/* 

			   XXX this is where we get fancy and map this spare
			   into it's correct spot in the array.

d2455 5
a2459 7
			/* 
			   
			   we claim this disk is "optimal" if it's 
			   rf_ds_used_spare, as that means it should be 
			   directly substitutable for the disk it replaced. 
			   We note that too...

d2464 1
a2464 1
					if ((raidPtr->Disks[i][j].spareRow == 
d2474 6
a2479 7
			
			raidread_component_label( 
				      raidPtr->Disks[r][sparecol].dev,
				      raidPtr->raid_cinfo[r][sparecol].ci_vp,
				      &clabel);
			/* make sure status is noted */
			clabel.version = RF_COMPONENT_LABEL_VERSION; 
d2486 1
a2486 1
			clabel.clean = RF_RAID_DIRTY; /* changed in a bit*/
d2489 4
a2492 5
				      raidPtr->Disks[r][sparecol].dev,
				      raidPtr->raid_cinfo[r][sparecol].ci_vp,
				      &clabel);
			raidmarkclean( raidPtr->Disks[r][sparecol].dev, 
			              raidPtr->raid_cinfo[r][sparecol].ci_vp);
d2501 1
a2501 3
rf_update_component_labels(raidPtr, final)
	RF_Raid_t *raidPtr;
	int final;
d2512 4
a2515 2
	/* XXX should do extra checks to make sure things really are clean, 
	   rather than blindly setting the clean bit... */
d2526 1
a2526 1
				/* make sure status is noted */
d2528 1
a2528 1
				/* bump the counter */
d2531 1
a2531 1
				raidwrite_component_label( 
d2536 7
a2542 5
					if (raidPtr->parity_good == RF_RAID_CLEAN) {
						raidmarkclean( 
							      raidPtr->Disks[r][c].dev, 
							      raidPtr->raid_cinfo[r][c].ci_vp,
							      raidPtr->mod_counter);
d2545 3
a2547 3
			} 
			/* else we don't touch it.. */
		} 
d2553 5
a2557 7
			/* 
			   
			   we claim this disk is "optimal" if it's 
			   rf_ds_used_spare, as that means it should be 
			   directly substitutable for the disk it replaced. 
			   We note that too...

d2562 1
a2562 1
					if ((raidPtr->Disks[i][j].spareRow == 
d2572 6
a2577 7
			
			/* XXX shouldn't *really* need this... */
			raidread_component_label( 
				      raidPtr->Disks[0][sparecol].dev,
				      raidPtr->raid_cinfo[0][sparecol].ci_vp,
				      &clabel);
			/* make sure status is noted */
d2587 2
a2588 3
				      raidPtr->Disks[0][sparecol].dev,
				      raidPtr->raid_cinfo[0][sparecol].ci_vp,
				      &clabel);
d2591 5
a2595 3
					raidmarkclean( raidPtr->Disks[0][sparecol].dev,
						       raidPtr->raid_cinfo[0][sparecol].ci_vp,
						       raidPtr->mod_counter);
d2600 1
a2600 1
	/* 	printf("Component labels updated\n"); */
d2604 1
a2604 4
rf_close_component(raidPtr, vp, auto_configured)
	RF_Raid_t *raidPtr;
	struct vnode *vp;
	int auto_configured;
d2615 2
a2616 2
			
		} else {				
d2627 1
a2627 2
rf_UnconfigureVnodes(raidPtr)
	RF_Raid_t *raidPtr;
d2629 1
a2629 1
	int r,c; 
d2634 1
a2634 1
	/* We take this opportunity to close the vnodes like we should.. */
d2658 2
a2659 3
void 
rf_ReconThread(req)
	struct rf_recon_req *req;
d2661 1
a2661 1
	int     s;
d2671 1
a2671 1
	/* XXX get rid of this! we don't need it at all.. */
d2678 1
a2678 1
	kthread_exit(0);        /* does not return */
d2682 1
a2682 2
rf_RewriteParityThread(raidPtr)
	RF_Raid_t *raidPtr;
d2693 5
a2697 3
		/* set the clean bit!  If we shutdown correctly,
		   the clean bit on each component label will get
		   set */
d2703 1
a2703 1
	/* Anyone waiting for us to stop?  If so, inform them... */
d2709 1
a2709 1
	kthread_exit(0);        /* does not return */
d2714 1
a2714 2
rf_CopybackThread(raidPtr)
	RF_Raid_t *raidPtr;
d2725 1
a2725 1
	kthread_exit(0);        /* does not return */
d2730 1
a2730 2
rf_ReconstructInPlaceThread(req)
	struct rf_recon_req *req;
d2735 1
a2735 1
	
d2745 1
a2745 1
	kthread_exit(0);        /* does not return */
d2750 1
a2750 1
rf_find_raid_components()
d2752 1
a2752 1
#ifdef RAID_AUTOCONFIG
d2763 1
a2763 1
#endif
d2767 1
a2767 1
	/* initialize the AutoConfig list */
d2770 2
a2771 2
#ifdef RAID_AUTOCONFIG
	/* we begin by trolling through *all* the devices on the system */
d2773 1
a2773 2
	for (dv = alldevs.tqh_first; dv != NULL;
	     dv = dv->dv_list.tqe_next) {
d2775 1
a2775 1
		/* we are only interested in disks... */
d2779 1
a2779 1
		/* we don't care about floppies... */
d2783 5
a2787 2
		
		/* need to find the device_name_to_block_device_major stuff */
d2790 1
a2790 1
		/* get a vnode for the raw partition of this disk */
d2799 4
a2802 2
			/* "Who cares."  Continue looking 
			   for something that exists*/
d2808 1
a2808 1
		error = VOP_IOCTL(vp, DIOCGDINFO, (caddr_t)&label, 
d2813 1
a2813 1
			 * have errored out (or faked up one)
d2816 1
a2816 1
			       dv->dv_xname, 'a' + RAW_PART, error);
d2819 4
a2822 2
		/* don't need this any more.  We'll allocate it again
		   a little later if we really do... */
d2827 6
a2832 4
			/* We only support partitions marked as RAID.	*/
			/* Aside on sparc/sparc64 where FS_RAID doesn't	*/
			/* fit in the SUN disklabel and we need to look	*/
			/* into each and every partition !!!		*/
d2855 3
a2857 3
			clabel = (RF_ComponentLabel_t *) 
				malloc(sizeof(RF_ComponentLabel_t), 
				       M_RAIDFRAME, M_NOWAIT);
d2859 1
a2859 1
				/* XXX CLEANUP HERE */
d2861 1
a2861 1
				return(NULL); /* XXX probably should panic? */
d2865 1
a2865 1
				/* Got the label.  Does it look reasonable? */
d2867 1
a2867 1
				    (clabel->partitionSize <= 
d2870 3
a2872 3
					printf("Component on: %s%c: %d\n", 
					       dv->dv_xname, 'a'+i,
					       label.d_partitions[i].p_size);
d2874 5
a2878 3
#endif
					/* if it's reasonable, add it, 
					   else ignore it. */
d2881 1
a2881 2
						       M_RAIDFRAME,
						       M_NOWAIT);
d2883 1
a2883 1
						/* XXX should panic?? */
d2886 1
a2886 1
					
d2895 1
a2895 1
				} 
d2898 1
a2898 1
				/* cleanup */
d2905 2
a2906 2
#endif
return(ac_list);
d2908 2
a2909 2
			
#ifdef RAID_AUTOCONFIG
d2911 1
a2911 2
rf_reasonable_label(clabel)
	RF_ComponentLabel_t *clabel;
d2913 1
a2913 1
	
d2918 2
a2919 2
	    clabel->row >=0 && 
	    clabel->column >= 0 && 
d2922 1
a2922 1
	    clabel->row < clabel->num_rows && 
d2926 1
a2926 1
		/* label looks reasonable enough... */
d2931 1
a2931 1
#endif
d2934 1
a2934 2
rf_print_component_label(clabel)
	RF_ComponentLabel_t *clabel;
d2937 1
a2937 2
	       clabel->row, clabel->column, 
	       clabel->num_rows, clabel->num_columns);
d2939 3
a2941 4
	       clabel->version, clabel->serial_number,
	       clabel->mod_counter);
	printf("   Clean: %s Status: %d\n",
	       clabel->clean ? "Yes" : "No", clabel->status );
d2943 1
a2943 1
	       clabel->sectPerSU, clabel->SUsPerPU, clabel->SUsPerRU);
d2945 1
a2945 2
	       (char) clabel->parityConfig, clabel->blockSize, 
	       clabel->numBlocks);
d2947 2
a2948 2
	printf("   Contains root partition: %s\n",  
	       clabel->root_partition ? "Yes" : "No" );
a2952 1
	       
d2956 1
a2956 2
rf_create_auto_sets(ac_list)
	RF_AutoConfig_t *ac_list;
d2966 4
a2969 2
	/* Go through the AutoConfig list, and figure out which components
	   belong to what sets.  */
d2972 4
a2975 2
		/* we're going to putz with ac->next, so save it here
		   for use at the end of the loop */
d2979 1
a2979 1
			/* will need at least this one... */
d2981 2
a2982 2
				malloc(sizeof(RF_ConfigSet_t), 
				       M_RAIDFRAME, M_NOWAIT);
d2986 1
a2986 1
			/* this one is easy :) */
d2992 1
a2992 1
			/* which set does this component fit into? */
d2996 1
a2996 1
					/* looks like it matches... */
d3004 1
a3004 1
				/* didn't find a match above... new set..*/
d3006 2
a3007 2
					malloc(sizeof(RF_ConfigSet_t), 
					       M_RAIDFRAME, M_NOWAIT);
d3026 1
a3026 3
rf_does_it_fit(cset, ac)	
	RF_ConfigSet_t *cset;
	RF_AutoConfig_t *ac;
d3030 26
a3055 24
	/* If this one matches the *first* one in the set, that's good
	   enough, since the other members of the set would have been
	   through here too... */
	/* note that we are not checking partitionSize here..

	   Note that we are also not checking the mod_counters here.
	   If everything else matches execpt the mod_counter, that's 
	   good enough for this test.  We will deal with the mod_counters
	   a little later in the autoconfiguration process.  

	    (clabel1->mod_counter == clabel2->mod_counter) &&

	   The reason we don't check for this is that failed disks
	   will have lower modification counts.  If those disks are
	   not added to the set they used to belong to, then they will
	   form their own set, which may result in 2 different sets,
	   for example, competing to be configured at raid0, and
	   perhaps competing to be the root filesystem set.  If the
	   wrong ones get configured, or both attempt to become /,
	   weird behaviour and or serious lossage will occur.  Thus we
	   need to bring them into the fold here, and kick them out at
	   a later point.

	*/
d3074 1
a3074 1
		/* if it get's here, it almost *has* to be a match */
d3076 1
a3076 2
		/* it's not consistent with somebody in the set.. 
		   punt */
d3079 1
a3079 1
	/* all was fine.. it must fit... */
d3084 1
a3084 2
rf_have_enough_components(cset)
	RF_ConfigSet_t *cset;
a3096 1
	
d3098 5
a3102 2
	/* check to see that we have enough 'live' components
	   of this set.  If so, we can configure it if necessary */
d3108 1
a3108 1
	/* XXX Check for duplicate components!?!?!? */
d3136 1
a3136 1
				    (ac->clabel->column == c) && 
d3138 1
a3138 1
					/* it's this one... */
d3141 2
a3142 2
					       ac->devname,r,c);
#endif
d3149 6
a3154 4
				/* special case for RAID 1, especially
				   where there are more than 2
				   components (where RAIDframe treats
				   things a little differently :( ) */
d3156 1
a3156 1
					if (c%2 == 0) { /* even component */
d3158 7
a3164 5
					} else { /* odd component.  If
                                                    we're failed, and
                                                    so is the even
                                                    component, it's
                                                    "Good Night, Charlie" */
d3170 1
a3170 1
					/* normal accounting */
d3175 5
a3179 3
				/* Just did an even component, and we didn't
				   bail.. reset the even_pair_failed flag, 
				   and go on to the next component.... */
d3190 2
a3191 2
		/* XXX this needs to be made *much* more general */
		/* Too many failures */
d3194 4
a3197 2
	/* otherwise, all is well, and we've got enough to take a kick
	   at autoconfiguring this set */
d3202 2
a3203 4
rf_create_configuration(ac,config,raidPtr)
	RF_AutoConfig_t *ac;
	RF_Config_t *config;
	RF_Raid_t *raidPtr;
d3210 1
a3210 1
	/* 1. Fill in the common stuff */
d3213 1
a3213 1
	config->numSpare = 0; /* XXX should this be set here? */
d3221 1
a3221 1
	config->layoutSpecificSize = 0; /* XXX ?? */
d3224 4
a3227 2
		/* row/col values will be in range due to the checks
		   in reasonable_label() */
d3229 1
a3229 1
		       ac->devname);
d3237 1
a3237 4
#ifdef RAID_DEBUG_ALL
#ifdef RF_DBG_OPTION
#undef RF_DBG_OPTION
#endif
d3239 15
a3253 9
#ifdef __STDC__
#define RF_DBG_OPTION(_option_,_val_) \
	snprintf(&(config->debugVars[i++][0]), 50, \
		 "%s %ld", #_option_, _val_);
#else                           /* __STDC__ */
#define RF_DBG_OPTION(_option_,_val_) \
	snprintf(&(config->debugVars[i++][0]), 50, \
		 "%s %ld", "/**/_option_/**/", _val_);
#endif                          /* __STDC__ */
d3257 84
a3340 75
/*	RF_DBG_OPTION(accessDebug, 0) */
/*	RF_DBG_OPTION(accessTraceBufSize, 0) */
	RF_DBG_OPTION(cscanDebug, 1)	/* debug CSCAN sorting */
	RF_DBG_OPTION(dagDebug, 1)
/*	RF_DBG_OPTION(debugPrintUseBuffer, 0) */
	RF_DBG_OPTION(degDagDebug, 1)
	RF_DBG_OPTION(disableAsyncAccs, 1)
	RF_DBG_OPTION(diskDebug, 1)
	RF_DBG_OPTION(enableAtomicRMW, 0)	/* this debug var enables
					 	 * locking of the disk arm
					 	 * during small-write
					 	 * operations.  Setting this
					 	 * variable to anything other
						 * than 0 will result in
						 * deadlock.  (wvcii) */
	RF_DBG_OPTION(engineDebug, 1)
	RF_DBG_OPTION(fifoDebug, 1)	/* debug fifo queueing */
/*	RF_DBG_OPTION(floatingRbufDebug, 1) */
/*	RF_DBG_OPTION(forceHeadSepLimit, -1) */
/*	RF_DBG_OPTION(forceNumFloatingReconBufs, -1) */	/* wire down number of
						 	 * extra recon buffers
						 	 * to use */
/*	RF_DBG_OPTION(keepAccTotals, 1) */	/* turn on keep_acc_totals */
	RF_DBG_OPTION(lockTableSize, RF_DEFAULT_LOCK_TABLE_SIZE)
	RF_DBG_OPTION(mapDebug, 1)
	RF_DBG_OPTION(maxNumTraces, -1)

/*	RF_DBG_OPTION(memChunkDebug, 1) */
/*	RF_DBG_OPTION(memDebug, 1) */
/*	RF_DBG_OPTION(memDebugAddress, 1) */
/*	RF_DBG_OPTION(numBufsToAccumulate, 1) */	/* number of buffers to
						 	 * accumulate before
							 * doing XOR */
	RF_DBG_OPTION(prReconSched, 0)
	RF_DBG_OPTION(printDAGsDebug, 1)
	RF_DBG_OPTION(printStatesDebug, 1)
	RF_DBG_OPTION(protectedSectors, 64L)		/* # of sectors at start
						 	 * of disk to exclude
						 	 * from RAID address
							 * space */
	RF_DBG_OPTION(pssDebug, 1)
	RF_DBG_OPTION(queueDebug, 1)
	RF_DBG_OPTION(quiesceDebug, 1)
	RF_DBG_OPTION(raidSectorOffset, 0)	/* added to all incoming sectors
					 	 * to debug alignment problems */
	RF_DBG_OPTION(reconDebug, 1)
	RF_DBG_OPTION(reconbufferDebug, 1)
	RF_DBG_OPTION(scanDebug, 1)	/* debug SCAN sorting */
	RF_DBG_OPTION(showXorCallCounts, 0)	/* show n-way Xor call counts */
	RF_DBG_OPTION(shutdownDebug, 1)		/* show shutdown calls */
	RF_DBG_OPTION(sizePercentage, 100)
	RF_DBG_OPTION(sstfDebug, 1)	/* turn on debugging info for sstf
					 * queueing */
	RF_DBG_OPTION(stripeLockDebug, 1)
	RF_DBG_OPTION(suppressLocksAndLargeWrites, 0)
	RF_DBG_OPTION(suppressTraceDelays, 0)
	RF_DBG_OPTION(useMemChunks, 1)
	RF_DBG_OPTION(validateDAGDebug, 1)
	RF_DBG_OPTION(validateVisitedDebug, 1)		/* XXX turn to zero by
						 	 * default? */
	RF_DBG_OPTION(verifyParityDebug, 1)
	RF_DBG_OPTION(debugKernelAccess, 1)	/* DoAccessKernel debugging */

#if 0 /* RF_INCLUDE_PARITYLOGGING > 0 */
	RF_DBG_OPTION(forceParityLogReint, 0)
	RF_DBG_OPTION(numParityRegions, 0)	/* number of regions in the
						 * array */
	RF_DBG_OPTION(numReintegrationThreads, 1)
	RF_DBG_OPTION(parityLogDebug, 1)	/* if nonzero, enables debugging
					 	 * of parity logging */
	RF_DBG_OPTION(totalInCoreLogCapacity, 1024 * 1024)	/* target bytes
							 	 * available for
							 	 * in-core
								 * logs */
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
d3342 1
a3342 1
#endif /* RAID_DEBUG_ALL */
d3346 1
a3346 3
rf_set_autoconfig(raidPtr, new_value)
	RF_Raid_t *raidPtr;
	int new_value;
d3356 1
a3356 1
			if (raidPtr->Disks[row][column].status == 
d3370 1
a3370 3
rf_set_rootpartition(raidPtr, new_value)
	RF_Raid_t *raidPtr;
	int new_value;
d3380 1
a3380 1
			if (raidPtr->Disks[row][column].status == 
d3394 1
a3394 2
rf_release_all_vps(cset)
	RF_ConfigSet_t *cset;
d3397 1
a3397 1
	
d3400 1
a3400 1
		/* Close the vp, and give it back */
d3412 1
a3412 2
rf_cleanup_config_set(cset)
	RF_ConfigSet_t *cset;
d3416 1
a3416 1
	
d3420 1
a3420 1
		/* nuke the label */
d3422 1
a3422 1
		/* cleanup the config structure */
d3424 1
a3424 1
		/* "next.." */
d3427 1
a3427 1
	/* and, finally, nuke the config set */
d3433 1
a3433 3
raid_init_component_label(raidPtr, clabel)
	RF_Raid_t *raidPtr;
	RF_ComponentLabel_t *clabel;
d3435 2
a3436 2
	/* current version number */
	clabel->version = RF_COMPONENT_LABEL_VERSION; 
d3441 3
a3443 3
	clabel->clean = RF_RAID_DIRTY; /* not clean */
	clabel->status = rf_ds_optimal; /* "It's good!" */
	
d3451 1
a3451 1
	/* XXX not portable */
d3461 1
a3461 3
rf_auto_config_set(cset,unit)
	RF_ConfigSet_t *cset;
	int *unit;
d3473 1
a3473 1
	/* 1. Create a config structure */
d3475 2
a3476 3
	config = (RF_Config_t *)malloc(sizeof(RF_Config_t),
				       M_RAIDFRAME,
				       M_NOWAIT);
d3479 1
a3479 1
				/* XXX do something more intelligent here. */
d3485 1
a3485 1
	/* XXX raidID needs to be set correctly.. */
d3487 5
a3491 5
	/* 
	   2. Figure out what RAID ID this one is supposed to live at 
	   See if we can get the same RAID dev that it was configured
	   on last time.. 
	*/
d3495 1
a3495 1
		/* let's not wander off into lala land. */
d3500 5
a3504 5
		/* 
		   Nope... Go looking for an alternative...  
		   Start high so we don't immediately use raid0 if that's
		   not taken. 
		*/
d3508 1
a3508 1
				/* can use this one! */
d3515 1
a3515 1
		/* punt... */
d3522 1
a3522 1
	/* XXX all this stuff should be done SOMEWHERE ELSE! */
d3526 1
a3526 1
	/* 3. Build the configuration structure */
d3529 1
a3529 1
	/* 4. Do the configuration */
d3531 1
a3531 1
	
d3537 1
a3537 1
		raidPtrs[raidID]->autoconfigure = 1; /* XXX do this here? */
d3539 4
a3542 2
			/* everything configured just fine.  Make a note
			   that this set is eligible to be root. */
d3544 2
a3545 2
			/* XXX do this here? */
			raidPtrs[raidID]->root_partition = 1; 
d3556 1
a3556 1
	/* 5. Cleanup */
d3558 1
a3558 1
	
d3564 1
a3564 2
rf_disk_unbusy(desc)
	RF_RaidAccessDesc_t *desc;
d3569 1
a3569 1
	disk_unbusy(&raid_softc[desc->raidPtr->raidid].sc_dkdev, 
@


1.19
log
@Remove those noisy informational messages from dmesg.
Use the option RAIDDEBUG to get these.

Theo, thanks for suggesting.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.18 2002/08/05 22:11:27 tdeval Exp $	*/
d394 1
a394 1
		panic("raidPtrs is NULL!!\n");
d410 1
a410 1
	        panic("Serious error booting RAID!!\n");
d440 1
a440 1
		panic("No memory for RAIDframe driver!!?!?!\n");
d1900 1
a1900 1
		panic("Invalid Unit number in rf_DispatchKernelIO\n");
d2113 1
a2113 1
		panic("bp->b_bcount is zero in rf_InitBP!!\n");
d3011 1
a3011 1
				panic("rf_create_auto_sets: No memory!\n");
d3036 1
a3036 1
					panic("rf_create_auto_sets: No memory!\n");
@


1.18
log
@Clean up hook cookies from shutdown hook.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.17 2002/05/28 23:38:10 tdeval Exp $	*/
d473 1
a473 1
#ifdef DEBUG
d520 1
a520 1
#ifdef DEBUG
d522 1
a522 1
#endif /* DEBUG */
d527 1
a527 1
#ifdef DEBUG
d1147 1
d1158 1
d1232 1
a1232 1
		printf("New autoconfig value is: %d\n", d);
d1238 1
a1238 1
		printf("New rootpartition value is: %d\n", d);
d1283 1
a1283 1
		printf("Rebuild: %d %d\n",row, column);
d1370 2
a1371 2
		printf("raid%d: Failing the disk: row: %d col: %d\n",
		       unit, rr->row, rr->col);
a1698 1
	printf("\n");	/* pretty up config_attach()'s output. */
d1948 1
a1948 1
		printf(("WAKEUP CALLED\n"));
d2200 1
d2206 1
d2258 1
a2258 1
#ifdef DEBUG
d2260 1
a2260 1
#endif
d2388 1
a2388 3
#if 0
		printf("Failed to read RAID component label!\n");
#endif
d2394 1
a2422 1
#if 1
a2423 1
#endif
d2669 2
a2670 1
			printf("Closing vnode for row: %d col: %d\n", r, c);
d2679 1
a2679 1
		printf("Closing vnode for spare: %d\n", r);
d2894 1
a2894 1
#ifdef DEBUG
d2980 1
a2980 1
	   printf("   Config order: %d\n", clabel->config_order);
d3166 1
a3166 1
#ifdef DEBUG
d3485 1
a3485 1
	printf("RAID autoconfigure\n");
a3537 1
	printf("Configuring raid%d:\n",raidID);
d3564 7
@


1.17
log
@splbio protection for biodone()
ok art@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.16 2002/03/14 03:16:07 millert Exp $	*/
d144 1
d579 3
@


1.16
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.15 2002/03/14 01:27:01 millert Exp $	*/
d778 2
d785 1
a785 1
  		return;
d792 1
a792 1
		return;
d800 1
a800 1
		return;
d805 1
a805 1
		return;
d820 1
a820 1
			return;
a822 2
	s = splbio();

d831 1
d1812 3
d1827 3
d2715 1
a2716 1
	s = splbio();
a2717 1
	splx(s);
d2727 1
d2745 1
a2746 1
	s = splbio();
d2748 1
a2749 1
	raidPtr->copyback_in_progress = 0;
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.14 2002/03/06 11:28:27 tdeval Exp $	*/
d176 1
a176 1
void	rf_InitBP __P((struct buf *, struct vnode *, unsigned, dev_t,
d178 1
a178 1
	    void *, int, struct proc *));
@


1.14
log
@Implement a shutdown hook.
We now can safely swap on raid.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.13 2002/01/23 00:39:47 art Exp $	*/
d175 1
a175 1
void	rf_KernelWakeupFunc __P((struct buf *));
d179 1
a179 1
void raidinit __P((RF_Raid_t *));
d181 9
a189 9
void	raidattach __P((int));
int	raidsize __P((dev_t));
int	raidopen __P((dev_t, int, int, struct proc *));
int	raidclose __P((dev_t, int, int, struct proc *));
int	raidioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	raidwrite __P((dev_t, struct uio *, int));
int	raidread __P((dev_t, struct uio *, int));
void	raidstrategy __P((struct buf *));
int	raiddump __P((dev_t, daddr_t, caddr_t, size_t));
d242 5
a246 5
int	rf_probe	__P((struct device *, void *, void *));
void	rf_attach	__P((struct device *, struct device *, void *));
int	rf_detach	__P((struct device *, int));
int	rf_activate	__P((struct device *, enum devact));
void	rf_zeroref	__P((struct device *));
d282 3
a284 4
void	raidgetdefaultlabel
	     __P((RF_Raid_t *, struct raid_softc *, struct disklabel *));
void	raidgetdisklabel __P((dev_t));
void	raidmakedisklabel __P((struct raid_softc *));
d286 2
a287 2
int	raidlock __P((struct raid_softc *));
void	raidunlock __P((struct raid_softc *));
d289 1
a289 1
void	rf_markalldirty __P((RF_Raid_t *));
d293 2
a294 2
int findblkmajor __P((struct device *dv));
char *findblkname __P((int));
d296 1
a296 1
void rf_ReconThread __P((struct rf_recon_req *));
d298 4
a301 4
/*void rf_ReconThread __P((RF_Raid_t *raidPtr));  */
void rf_RewriteParityThread __P((RF_Raid_t *raidPtr));
void rf_CopybackThread __P((RF_Raid_t *raidPtr));
void rf_ReconstructInPlaceThread __P((struct rf_recon_req *));
d303 2
a304 2
void rf_buildroothack __P((void *));
int rf_reasonable_label __P((RF_ComponentLabel_t *));
d307 11
a317 11
RF_AutoConfig_t *rf_find_raid_components __P((void));
RF_ConfigSet_t *rf_create_auto_sets __P((RF_AutoConfig_t *));
int rf_does_it_fit __P((RF_ConfigSet_t *,RF_AutoConfig_t *));
void rf_create_configuration __P((RF_AutoConfig_t *,RF_Config_t *,
				  RF_Raid_t *));
int rf_set_autoconfig __P((RF_Raid_t *, int));
int rf_set_rootpartition __P((RF_Raid_t *, int));
void rf_release_all_vps __P((RF_ConfigSet_t *));
void rf_cleanup_config_set __P((RF_ConfigSet_t *));
int rf_have_enough_components __P((RF_ConfigSet_t *));
int rf_auto_config_set __P((RF_ConfigSet_t *, int *));
@


1.13
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.12 2001/12/29 21:51:18 tdeval Exp $	*/
d281 1
a290 1
void rf_mountroot_hook __P((struct device *));
d470 2
a471 2
if (raidautoconfig) {
	/* 1. locate all RAID components on the system */
d474 1
a474 1
	printf("Searching for raid components...\n");
d476 1
a476 1
	ac_list = rf_find_raid_components();
d478 1
a478 1
	/* 2. sort them into their respective sets */
d480 1
a480 1
	config_sets = rf_create_auto_sets(ac_list);
d482 2
a483 2
	/* 3. evaluate each set and configure the valid ones
	   This gets done in rf_buildroothack() */
d485 2
a486 2
	/* schedule the creation of the thread to do the 
	   "/ on RAID" stuff */
d488 1
a488 1
	rf_buildroothack(config_sets);
d490 1
a490 4
#if 0
	mountroothook_establish(rf_mountroot_hook, &raidrootdev[0]);
#endif
}
d562 32
d758 1
a758 3
#if 0
		printf("Last one on raid%d.  Updating status.\n",unit);
#endif
a760 18
#if 0
		if (doing_shutdown) {
/* #endif */
			/* last one, and we're going down, so
			   lights out for this RAID set too. */
			error = rf_Shutdown(raidPtrs[unit]);
			pool_destroy(&rs->sc_cbufpool);
			
			/* It's no longer initialized... */
			rs->sc_flags &= ~RAIDF_INITED;
			
			/* config_detach the device. */
			config_detach(device_lookup(&raid_cd, unit), 0);

			disk_detach(&rs->sc_dkdev);
/* #if 0 */
		}
#endif
d1075 1
a1075 1
		retcode = rf_Shutdown(raidPtr);
d1077 1
a1077 1
		pool_destroy(&rs->sc_cbufpool);
d1079 2
a1080 2
		/* It's no longer initialized... */
		rs->sc_flags &= ~RAIDF_INITED;
d1082 2
a1083 2
		/* config_detach the device. */
		config_detach(device_lookup(&raid_cd, unit), 0);
d1085 3
a1087 2
		/* Detach the disk. */
		disk_detach(&rs->sc_dkdev);
a2767 7
}

void
rf_mountroot_hook(dev)
	struct device *dev;
{

@


1.12
log
@Enable the RAIDFrame auto-configuration feature.
This permits one to setup a kernel able to automatically retrieve, during
boot, the raid configuration from disks previously used in a RAIDFrame
set.  Moreover, one can define a raid set to contain a bootable partition
that will be mounted on / before the system has started.
A new RAID_AUTOCONFIG kernel option is used, in conjunction with the raid
pseudo-device, to activate the feature.

ok drahn@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.11 2001/12/08 22:10:01 tdeval Exp $	*/
d1644 1
a1644 2
		0, 0, "raidpl", 0, NULL, NULL, M_RAIDFRAME);

@


1.11
log
@Fix compilation error when building a raid enabled kernel.
OK deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_openbsdkintf.c,v 1.10 2000/08/08 16:07:43 peter Exp $	*/
/*	$NetBSD: rf_netbsdkintf.c,v 1.93 2000/07/14 15:26:29 oster Exp $	*/
d120 1
d142 1
d179 1
a179 1
static void raidinit __P((RF_Raid_t *));
d201 2
a202 2
#define RAIDGETBUF() malloc(sizeof (struct raidbuf), M_RAIDFRAME, M_NOWAIT)
#define	RAIDPUTBUF(buf) free(buf, M_RAIDFRAME)
d223 1
d238 16
d279 1
d294 3
d305 1
a305 1
static int rf_reasonable_label __P((RF_ComponentLabel_t *));
d310 1
a310 1
static int rf_does_it_fit __P((RF_ConfigSet_t *,RF_AutoConfig_t *));
d328 39
d427 10
d464 4
a467 1
#if RAID_AUTOCONFIG
d473 1
a473 1
#if DEBUG
d488 1
a488 1
	kthread_create(rf_buildroothack, config_sets, NULL, "raidauto");
d510 1
d512 1
d523 3
d530 1
a530 1
#if DEBUG
d550 7
a556 1
			booted_device = &raidrootdev[rootID]; 
d734 18
d772 1
a772 1
		bp->b_flags = B_ERROR;
d1068 2
d1073 3
d1180 9
a1188 6
				ci_label.partitionSize = diskPtr->partitionSize;
				ci_label.column = column;
				raidwrite_component_label( 
				  raidPtr->Disks[row][column].dev, 
				  raidPtr->raid_cinfo[row][column].ci_vp, 
				  &ci_label );
d1213 1
d1328 1
d1346 1
a1346 1
		/* fail a disk & optionally start reconstruction */
d1372 4
a1375 4
		/*
		 * Invoke a copyback operation after recon on whatever
		 * disk needs it, if any.
		 */
d1391 2
a1392 2
		
		/* Return the percentage completion of reconstruction */
d1469 2
a1470 1
			*(int *) data = 100 * raidPtr->copyback_stripes_done / raidPtr->Layout.numStripe;
d1559 1
a1560 1
		/* fall through to the os-specific code below */
d1583 4
d1593 1
a1593 1
		    (struct disklabel *)data, 0, rs->sc_dkdev.dk_cpulabel);
d1608 1
a1616 3
#if 0
  	case DIOCGDEFLABEL:
#endif
d1618 1
a1618 2
  		raidgetdefaultlabel(raidPtr, rs,
  		    (struct disklabel *) data);
a1620 1

d1624 1
d1632 1
a1632 1
static void
d1637 2
a1638 1
	int     unit;
d1643 3
d1667 18
d1832 5
a1838 3
		
		/* XXX we're still at splbio() here... do we *really* 
		   need to be? */
a1884 3
	/* XXX is this the right place? */
	disk_busy(&rs->sc_dkdev);

d1903 1
a1903 1
	raidbp = RAIDGETBUF();
d2057 1
a2057 6
	RAIDPUTBUF(raidbp);

	if (bp->b_resid==0) {
		/* XXX is this the right place for a disk_unbusy()??!??!?!? */
		disk_unbusy(&rs->sc_dkdev, (bp->b_bcount - bp->b_resid));
	}
d2114 1
a2114 1
	lp->d_ntracks = 1;
d2339 6
d2352 1
a2352 1
	bp->b_flags = B_BUSY | B_READ;
a2370 1
        bp->b_flags = B_INVAL | B_AGE;
d2391 1
a2391 1
	bp->b_flags = B_BUSY | B_WRITE;
a2399 1
        bp->b_flags = B_INVAL | B_AGE;
d2420 3
a2422 1
			if (raidPtr->Disks[r][c].status != rf_ds_failed) {
d2619 2
a2620 1
	p = raidPtr->engine_thread;
d2624 2
a2625 2
			VOP_CLOSE(vp, FREAD, NOCRED, 0);
			vput(vp);
a2641 1
	struct proc *p;
a2647 2
	p = raidPtr->engine_thread;

d2773 1
a2773 1
	struct devnametobdevmaj *dtobdm;
a2776 1
	char *cd_name;
d2790 1
a2790 3
#if RAID_AUTOCONFIG
if (raidautoconfig) {

d2806 1
a2806 5
		cd_name = dv->dv_cfdata->cf_driver->cd_name;
		dtobdm = dev_name2blk;
		while (dtobdm->d_name && strcmp(dtobdm->d_name, cd_name)) {
			dtobdm++;
		}
d2810 1
a2810 1
		dev = MAKEDISKDEV(dtobdm->d_maj, dv->dv_unit, RAW_PART);
d2837 2
a2838 2
		VOP_CLOSE(vp, FREAD, NOCRED, 0);
		vput(vp);
d2841 5
a2845 1
			/* We only support partitions marked as RAID */
d2848 5
d2854 1
a2854 1
			dev = MAKEDISKDEV(dtobdm->d_maj, dv->dv_unit, i);
d2881 1
a2881 1
#if DEBUG
d2911 2
a2912 2
				VOP_CLOSE(vp, FREAD, NOCRED, 0);
				vput(vp);
a2915 1
}
d2921 1
a2921 1
static int
d3039 1
a3039 1
static int
d3127 1
d3153 1
a3153 1
#if DEBUG
d3242 95
d3402 1
a3402 1
			vput(ac->vp);
d3511 1
a3511 1
		for(raidID = numraid; raidID >= 0; raidID--) {
d3558 11
@


1.11.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 2
a2 2
/* $OpenBSD: rf_openbsdkintf.c,v 1.13 2002/01/23 00:39:47 art Exp $	*/
/* $NetBSD: rf_netbsdkintf.c,v 1.109 2001/07/27 03:30:07 oster Exp $	*/
a119 1
#include <sys/pool.h>
a140 1
#include "rf_desc.h"
d177 1
a177 1
void raidinit __P((RF_Raid_t *));
d199 2
a200 2
#define RAIDGETBUF(rs)		pool_get(&(rs)->sc_cbufpool, PR_NOWAIT)
#define RAIDPUTBUF(rs, cbp)	pool_put(&(rs)->sc_cbufpool, cbp)
a220 1
	struct pool sc_cbufpool;	/* component buffer pool */
a234 16
 * Here we define a cfattach structure for inserting any new raid device
 * into the device tree.  This is needed by some archs that look for
 * bootable devices in there.
 */
int	rf_probe	__P((struct device *, void *, void *));
void	rf_attach	__P((struct device *, struct device *, void *));
int	rf_detach	__P((struct device *, int));
int	rf_activate	__P((struct device *, enum devact));
void	rf_zeroref	__P((struct device *));

struct cfattach raid_ca = {
	sizeof(struct raid_softc), rf_probe, rf_attach,
	rf_detach, rf_activate, rf_zeroref
};

/*
a259 1
struct raid_softc **raid_scPtrs;
a273 3
int findblkmajor __P((struct device *dv));
char *findblkname __P((int));

d282 1
a282 1
int rf_reasonable_label __P((RF_ComponentLabel_t *));
d287 1
a287 1
int rf_does_it_fit __P((RF_ConfigSet_t *,RF_AutoConfig_t *));
a304 39
int
rf_probe(parent, match_, aux)
	struct device *parent;
	void *match_;
	void *aux;
{
	return 0;
}

void
rf_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	/* struct raid_softc *raid = (void *)self; */
}

int
rf_detach(self, flags)
	struct device *self;
	int flags;
{
	return 0;
}

int
rf_activate(self, act)
	struct device *self;
	enum devact act;
{
	return 0;
}

void
rf_zeroref(self)
	struct device *self;
{
}

a364 10
	raid_scPtrs = (struct raid_softc **)
		malloc(num * sizeof(struct raid_softc *),
		       M_RAIDFRAME, M_NOWAIT);
	if (raid_scPtrs == NULL) {
		printf("WARNING: no memory for RAIDframe driver\n");
		return;
	}

	bzero(raid_scPtrs, num * sizeof (struct raid_softc *));

d392 1
a392 4
	raid_cd.cd_devs = (void **) raid_scPtrs;
	raid_cd.cd_ndevs = num;

#ifdef RAID_AUTOCONFIG
d398 1
a398 1
#ifdef DEBUG
d413 1
a413 1
	rf_buildroothack(config_sets);
a434 1
	int majdev;
a435 1
	rootID = 0;
a445 3
#ifdef DEBUG
					printf("eligible root device %d: raid%d\n", num_root, rootID);
#endif /* DEBUG */
d450 1
a450 1
#ifdef DEBUG
d470 1
a470 7
			majdev = findblkmajor(&raidrootdev[rootID]);
			if (majdev < 0)
				boothowto |= RB_ASKNAME;
			else {
				rootdev = MAKEDISKDEV(majdev,rootID,0); 
				boothowto |= RB_DFLTROOT;
			}
a647 18
#if 0
		if (doing_shutdown) {
/* #endif */
			/* last one, and we're going down, so
			   lights out for this RAID set too. */
			error = rf_Shutdown(raidPtrs[unit]);
			pool_destroy(&rs->sc_cbufpool);
			
			/* It's no longer initialized... */
			rs->sc_flags &= ~RAIDF_INITED;
			
			/* config_detach the device. */
			config_detach(device_lookup(&raid_cd, unit), 0);

			disk_detach(&rs->sc_dkdev);
/* #if 0 */
		}
#endif
d668 1
a668 1
		bp->b_flags |= B_ERROR;
a963 2
		pool_destroy(&rs->sc_cbufpool);

a966 3
		/* config_detach the device. */
		config_detach(device_lookup(&raid_cd, unit), 0);

d1071 6
a1076 9
				if (!RF_DEAD_DISK(diskPtr->status)) {
					ci_label.partitionSize =
					    diskPtr->partitionSize;
					ci_label.column = column;
					raidwrite_component_label( 
					    raidPtr->Disks[row][column].dev, 
					    raidPtr->raid_cinfo[row][column].ci_vp, 
					    &ci_label );
				}
a1100 1

a1214 1

d1232 1
a1232 1
	/* fail a disk & optionally start reconstruction */
d1258 4
a1261 4
	/*
	 * Invoke a copyback operation after recon on whatever
	 * disk needs it, if any.
	 */
d1277 2
a1278 2

	/* Return the percentage completion of reconstruction */
d1355 1
a1355 2
			*(int *) data = 100 * raidPtr->copyback_stripes_done /
				raidPtr->Layout.numStripe;
a1443 1
	/* fall through to the os-specific code below */
d1445 1
a1467 4
	{
		struct disklabel *lp;
		lp = (struct disklabel *)data;

d1474 1
a1474 1
		    lp, 0, rs->sc_dkdev.dk_cpulabel);
a1488 1
	}
d1497 3
d1501 2
a1502 1
  		raidgetdefaultlabel(raidPtr, rs, (struct disklabel *) data);
d1505 1
a1508 1

d1516 1
a1516 1
void
d1521 1
a1521 2
	struct cfdata	*cf;
	int      unit;
a1525 2
	pool_init(&rs->sc_cbufpool, sizeof(struct raidbuf), 0,
		0, 0, "raidpl", NULL);
a1546 18

	/*
	 * config_attach the raid device into the device tree.
	 * For autoconf rootdev selection...
	 */
	cf = malloc(sizeof(struct cfdata), M_RAIDFRAME, M_NOWAIT);
	if (cf == NULL) {
		printf("WARNING: no memory for cfdata struct\n");
		return;
	}
	bzero(cf, sizeof(struct cfdata));

	cf->cf_attach = &raid_ca;
	cf->cf_driver = &raid_cd;
	cf->cf_unit   = unit;

	config_attach(NULL, cf, NULL, NULL);
	printf("\n");	/* pretty up config_attach()'s output. */
d1694 2
a1695 1
		disk_busy(&rs->sc_dkdev);
d1698 1
a1698 4
		 * need to be? */

		/* don't ever condition on bp->b_flags & B_WRITE.  
		 * always condition on B_READ instead */
d1745 3
d1766 1
a1766 1
	raidbp = RAIDGETBUF(rs);
d1920 6
a1925 1
	RAIDPUTBUF(rs, raidbp);
d1982 1
a1982 1
	lp->d_ntracks = 4 * raidPtr->numCol;
a2206 6
	if (b_vp == NULL) {
		/* For whatever reason, this component is not valid.
		   Don't try to read a component label from it. */
		return(EINVAL);
	}

d2214 1
a2214 1
	bp->b_flags |= B_READ;
d2233 1
d2254 1
a2254 1
	bp->b_flags |= B_WRITE;
d2263 1
d2284 1
a2284 3
			/* we don't want to touch (at all) a disk that has
			   failed */
			if (!RF_DEAD_DISK(raidPtr->Disks[r][c].status)) {
d2481 1
a2481 2
	if ((p = raidPtr->engine_thread) == NULL)
		p = curproc;
d2485 2
a2486 2
			VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, 0);
			vrele(vp);
d2503 1
d2510 2
d2637 1
a2637 1
	int major;
d2641 1
d2655 3
a2657 1
#ifdef RAID_AUTOCONFIG
d2673 5
a2677 1
		major = findblkmajor(dv);
d2681 1
a2681 1
		dev = MAKEDISKDEV(major, dv->dv_unit, RAW_PART);
d2708 2
a2709 2
		VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, 0);
		vrele(vp);
d2712 1
a2712 5
			/* We only support partitions marked as RAID.	*/
			/* Aside on sparc/sparc64 where FS_RAID doesn't	*/
			/* fit in the SUN disklabel and we need to look	*/
			/* into each and every partition !!!		*/
#if !defined(__sparc__) && !defined(__sparc64__) && !defined(__sun3__)
a2714 5
#else /* !__sparc__ && !__sparc64__ && !__sun3__ */
			if (label.d_partitions[i].p_fstype == FS_SWAP ||
			    label.d_partitions[i].p_fstype == FS_UNUSED)
				continue;
#endif /* __sparc__ || __sparc64__ || __sun3__ */
d2716 1
a2716 1
			dev = MAKEDISKDEV(major, dv->dv_unit, i);
d2743 1
a2743 1
#ifdef DEBUG
d2773 2
a2774 2
				VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, 0);
				vrele(vp);
d2778 1
d2784 1
a2784 1
int
d2902 1
a2902 1
int
a2989 1
	mod_counter = 0;
d3015 1
a3015 1
#ifdef DEBUG
a3103 95

#ifdef RAID_DEBUG_ALL
#ifdef RF_DBG_OPTION
#undef RF_DBG_OPTION
#endif

#ifdef __STDC__
#define RF_DBG_OPTION(_option_,_val_) \
	snprintf(&(config->debugVars[i++][0]), 50, \
		 "%s %ld", #_option_, _val_);
#else                           /* __STDC__ */
#define RF_DBG_OPTION(_option_,_val_) \
	snprintf(&(config->debugVars[i++][0]), 50, \
		 "%s %ld", "/**/_option_/**/", _val_);
#endif                          /* __STDC__ */

	i = 0;

/*	RF_DBG_OPTION(accessDebug, 0) */
/*	RF_DBG_OPTION(accessTraceBufSize, 0) */
	RF_DBG_OPTION(cscanDebug, 1)	/* debug CSCAN sorting */
	RF_DBG_OPTION(dagDebug, 1)
/*	RF_DBG_OPTION(debugPrintUseBuffer, 0) */
	RF_DBG_OPTION(degDagDebug, 1)
	RF_DBG_OPTION(disableAsyncAccs, 1)
	RF_DBG_OPTION(diskDebug, 1)
	RF_DBG_OPTION(enableAtomicRMW, 0)	/* this debug var enables
					 	 * locking of the disk arm
					 	 * during small-write
					 	 * operations.  Setting this
					 	 * variable to anything other
						 * than 0 will result in
						 * deadlock.  (wvcii) */
	RF_DBG_OPTION(engineDebug, 1)
	RF_DBG_OPTION(fifoDebug, 1)	/* debug fifo queueing */
/*	RF_DBG_OPTION(floatingRbufDebug, 1) */
/*	RF_DBG_OPTION(forceHeadSepLimit, -1) */
/*	RF_DBG_OPTION(forceNumFloatingReconBufs, -1) */	/* wire down number of
						 	 * extra recon buffers
						 	 * to use */
/*	RF_DBG_OPTION(keepAccTotals, 1) */	/* turn on keep_acc_totals */
	RF_DBG_OPTION(lockTableSize, RF_DEFAULT_LOCK_TABLE_SIZE)
	RF_DBG_OPTION(mapDebug, 1)
	RF_DBG_OPTION(maxNumTraces, -1)

/*	RF_DBG_OPTION(memChunkDebug, 1) */
/*	RF_DBG_OPTION(memDebug, 1) */
/*	RF_DBG_OPTION(memDebugAddress, 1) */
/*	RF_DBG_OPTION(numBufsToAccumulate, 1) */	/* number of buffers to
						 	 * accumulate before
							 * doing XOR */
	RF_DBG_OPTION(prReconSched, 0)
	RF_DBG_OPTION(printDAGsDebug, 1)
	RF_DBG_OPTION(printStatesDebug, 1)
	RF_DBG_OPTION(protectedSectors, 64L)		/* # of sectors at start
						 	 * of disk to exclude
						 	 * from RAID address
							 * space */
	RF_DBG_OPTION(pssDebug, 1)
	RF_DBG_OPTION(queueDebug, 1)
	RF_DBG_OPTION(quiesceDebug, 1)
	RF_DBG_OPTION(raidSectorOffset, 0)	/* added to all incoming sectors
					 	 * to debug alignment problems */
	RF_DBG_OPTION(reconDebug, 1)
	RF_DBG_OPTION(reconbufferDebug, 1)
	RF_DBG_OPTION(scanDebug, 1)	/* debug SCAN sorting */
	RF_DBG_OPTION(showXorCallCounts, 0)	/* show n-way Xor call counts */
	RF_DBG_OPTION(shutdownDebug, 1)		/* show shutdown calls */
	RF_DBG_OPTION(sizePercentage, 100)
	RF_DBG_OPTION(sstfDebug, 1)	/* turn on debugging info for sstf
					 * queueing */
	RF_DBG_OPTION(stripeLockDebug, 1)
	RF_DBG_OPTION(suppressLocksAndLargeWrites, 0)
	RF_DBG_OPTION(suppressTraceDelays, 0)
	RF_DBG_OPTION(useMemChunks, 1)
	RF_DBG_OPTION(validateDAGDebug, 1)
	RF_DBG_OPTION(validateVisitedDebug, 1)		/* XXX turn to zero by
						 	 * default? */
	RF_DBG_OPTION(verifyParityDebug, 1)
	RF_DBG_OPTION(debugKernelAccess, 1)	/* DoAccessKernel debugging */

#if 0 /* RF_INCLUDE_PARITYLOGGING > 0 */
	RF_DBG_OPTION(forceParityLogReint, 0)
	RF_DBG_OPTION(numParityRegions, 0)	/* number of regions in the
						 * array */
	RF_DBG_OPTION(numReintegrationThreads, 1)
	RF_DBG_OPTION(parityLogDebug, 1)	/* if nonzero, enables debugging
					 	 * of parity logging */
	RF_DBG_OPTION(totalInCoreLogCapacity, 1024 * 1024)	/* target bytes
							 	 * available for
							 	 * in-core
								 * logs */
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */

#endif /* RAID_DEBUG_ALL */
d3169 1
a3169 1
			vrele(ac->vp);
d3278 1
a3278 1
		for(raidID = numraid - 1; raidID >= 0; raidID--) {
a3324 11
}

void
rf_disk_unbusy(desc)
	RF_RaidAccessDesc_t *desc;
{
	struct buf *bp;

	bp = (struct buf *)desc->bp;
	disk_unbusy(&raid_softc[desc->raidPtr->raidid].sc_dkdev, 
			    (bp->b_bcount - bp->b_resid));
@


1.11.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.11.2.1 2002/01/31 22:55:38 niklas Exp $	*/
d175 2
a176 2
void	rf_KernelWakeupFunc(struct buf *);
void	rf_InitBP(struct buf *, struct vnode *, unsigned, dev_t,
d178 2
a179 2
	    void *, int, struct proc *);
void raidinit(RF_Raid_t *);
d181 9
a189 9
void	raidattach(int);
int	raidsize(dev_t);
int	raidopen(dev_t, int, int, struct proc *);
int	raidclose(dev_t, int, int, struct proc *);
int	raidioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	raidwrite(dev_t, struct uio *, int);
int	raidread(dev_t, struct uio *, int);
void	raidstrategy(struct buf *);
int	raiddump(dev_t, daddr_t, caddr_t, size_t);
d242 5
a246 5
int	rf_probe(struct device *, void *, void *);
void	rf_attach(struct device *, struct device *, void *);
int	rf_detach(struct device *, int);
int	rf_activate(struct device *, enum devact);
void	rf_zeroref(struct device *);
d281 4
a284 4
void	rf_shutdown_hook(RF_ThreadArg_t);
void	raidgetdefaultlabel(RF_Raid_t *, struct raid_softc *, struct disklabel *);
void	raidgetdisklabel(dev_t);
void	raidmakedisklabel(struct raid_softc *);
d286 2
a287 2
int	raidlock(struct raid_softc *);
void	raidunlock(struct raid_softc *);
d289 2
a290 1
void	rf_markalldirty(RF_Raid_t *);
d294 2
a295 2
int findblkmajor(struct device *dv);
char *findblkname(int);
d297 1
a297 1
void rf_ReconThread(struct rf_recon_req *);
d299 4
a302 4
/*void rf_ReconThread(RF_Raid_t *raidPtr);  */
void rf_RewriteParityThread(RF_Raid_t *raidPtr);
void rf_CopybackThread(RF_Raid_t *raidPtr);
void rf_ReconstructInPlaceThread(struct rf_recon_req *);
d304 2
a305 2
void rf_buildroothack(void *);
int rf_reasonable_label(RF_ComponentLabel_t *);
d308 11
a318 11
RF_AutoConfig_t *rf_find_raid_components(void);
RF_ConfigSet_t *rf_create_auto_sets(RF_AutoConfig_t *);
int rf_does_it_fit(RF_ConfigSet_t *,RF_AutoConfig_t *);
void rf_create_configuration(RF_AutoConfig_t *,RF_Config_t *,
				  RF_Raid_t *);
int rf_set_autoconfig(RF_Raid_t *, int);
int rf_set_rootpartition(RF_Raid_t *, int);
void rf_release_all_vps(RF_ConfigSet_t *);
void rf_cleanup_config_set(RF_ConfigSet_t *);
int rf_have_enough_components(RF_ConfigSet_t *);
int rf_auto_config_set(RF_ConfigSet_t *, int *);
d470 2
a471 2
	if (raidautoconfig) {
		/* 1. locate all RAID components on the system */
d474 1
a474 1
		printf("Searching for raid components...\n");
d476 1
a476 1
		ac_list = rf_find_raid_components();
d478 1
a478 1
		/* 2. sort them into their respective sets */
d480 1
a480 1
		config_sets = rf_create_auto_sets(ac_list);
d482 2
a483 2
		/* 3. evaluate each set and configure the valid ones
		   This gets done in rf_buildroothack() */
d485 2
a486 2
		/* schedule the creation of the thread to do the 
		   "/ on RAID" stuff */
d488 1
a488 1
		rf_buildroothack(config_sets);
d490 4
a493 1
	}
a564 32
void
rf_shutdown_hook(arg)
	RF_ThreadArg_t arg;
{
	int unit;
	struct raid_softc *rs;
	RF_Raid_t *raidPtr;

	/* Don't do it if we are not "safe" */
	if (boothowto & RB_NOSYNC)
		return;

	raidPtr = (RF_Raid_t *) arg;
	unit = raidPtr->raidid;
	rs = &raid_softc[unit];

	/* Shutdown the system */

	rf_Shutdown(raidPtr);

	pool_destroy(&rs->sc_cbufpool);

	/* It's no longer initialized... */
	rs->sc_flags &= ~RAIDF_INITED;

	/* config_detach the device. */
	config_detach(device_lookup(&raid_cd, unit), 0);

	/* Detach the disk. */
	disk_detach(&rs->sc_dkdev);
}

d729 3
a731 1
		db1_printf(("Last one on raid%d.  Updating status.\n",unit));
d734 18
a769 2
	s = splbio();

d775 1
a775 1
  		goto raidstrategy_end;
d782 1
a782 1
		goto raidstrategy_end;
d790 1
a790 1
		goto raidstrategy_end;
d795 1
a795 1
		goto raidstrategy_end;
d810 1
a810 1
			goto raidstrategy_end;
d813 2
a822 1
raidstrategy_end:
d1066 1
a1066 1
		if ((retcode = rf_Shutdown(raidPtr)) == 0) {
d1068 1
a1068 1
			pool_destroy(&rs->sc_cbufpool);
d1070 2
a1071 2
			/* It's no longer initialized... */
			rs->sc_flags &= ~RAIDF_INITED;
d1073 2
a1074 2
			/* config_detach the device. */
			config_detach(device_lookup(&raid_cd, unit), 0);
d1076 2
a1077 3
			/* Detach the disk. */
			disk_detach(&rs->sc_dkdev);
		}
a1801 3
			/* db1_printf(("%s: Calling biodone on 0x%x\n",
				    __func__, bp)); */
			splassert(IPL_BIO);
a1813 3
			/* db1_printf(("%s: Calling biodone on 0x%x\n",
				    __func__, bp)); */
			splassert(IPL_BIO);
d2699 1
a2700 1
	raidPtr->parity_rewrite_in_progress = 1;
d2702 1
a2711 1
	splx(s);
d2729 1
a2730 1
	raidPtr->copyback_in_progress = 1;
d2732 1
a2733 1
	splx(s);
d2758 7
@


1.11.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.11.2.2 2002/06/11 03:42:28 art Exp $	*/
a143 1
#include "rf_engine.h"
d393 1
a393 1
		panic("raidPtrs is NULL!!");
d409 1
a409 1
	        panic("Serious error booting RAID!!");
d439 1
a439 1
		panic("No memory for RAIDframe driver!!?!?!");
d472 1
a472 1
#ifdef	RAIDDEBUG
d519 1
a519 1
#ifdef	RAIDDEBUG
d521 1
a521 1
#endif	/* RAIDDEBUG */
d526 1
a526 1
#ifdef	RAIDDEBUG
a578 3
	if (rf_hook_cookies != NULL && rf_hook_cookies[unit] != NULL)
		rf_hook_cookies[unit] = NULL;

a1142 1
#ifdef	RAIDDEBUG
a1152 1
#endif
d1226 1
a1226 1
		db1_printf(("New autoconfig value is: %d\n", d));
d1232 1
a1232 1
		db1_printf(("New rootpartition value is: %d\n", d));
d1277 1
a1277 1
		db1_printf(("Rebuild: %d %d\n",row, column));
d1364 2
a1365 2
		db1_printf(("raid%d: Failing the disk: row: %d col: %d\n",
		       unit, rr->row, rr->col));
d1693 1
d1895 1
a1895 1
		panic("Invalid Unit number in rf_DispatchKernelIO");
d1943 1
a1943 1
		db1_printf(("WAKEUP CALLED\n"));
d2108 1
a2108 1
		panic("bp->b_bcount is zero in rf_InitBP!!");
a2194 1
#ifdef	RAIDDEBUG
a2199 1
#endif	/* RAIDDEBUG */
d2251 1
a2251 1
#ifdef	RAIDDEBUG
d2253 1
a2253 1
#endif	/* RAIDDEBUG */
d2381 3
a2383 1
		db1_printf(("Failed to read RAID component label!\n"));
a2388 1

d2417 1
d2419 1
d2665 1
a2665 2
			db1_printf(("Closing vnode for row: %d col: %d\n",
			    r, c));
d2674 1
a2674 1
		db1_printf(("Closing vnode for spare: %d\n", r));
d2889 1
a2889 1
#ifdef	RAIDDEBUG
d2975 1
a2975 1
	printf("   Config order: %d\n", clabel->config_order);
d3006 1
a3006 1
				panic("rf_create_auto_sets: No memory!");
d3031 1
a3031 1
					panic("rf_create_auto_sets: No memory!");
d3161 1
a3161 1
#ifdef	RAIDDEBUG
d3480 1
a3480 1
	db1_printf(("RAID autoconfigure\n"));
d3533 1
a3559 7

	printf(": (%s) total number of sectors is %lu (%lu MB)%s\n",
	    (raidPtrs[raidID]->Layout).map->configName,
	    (unsigned long) raidPtrs[raidID]->totalSectors,
	    (unsigned long) (raidPtrs[raidID]->totalSectors / 1024 *
	    (1 << raidPtrs[raidID]->logBytesPerSector) / 1024),
	    raidPtrs[raidID]->root_partition ? " as root" : "");
@


1.11.2.4
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
a2 1

d81 3
d111 1
a111 1
/*****************************************************************************
d113 1
a113 1
 * rf_kintf.c -- The kernel interface routines for RAIDframe.
d115 1
a115 1
 *****************************************************************************/
d159 2
a160 2
#ifdef	RAIDDEBUG
#define	db1_printf(a) do { if (rf_kdebug_level > 0) printf a; } while(0)
d162 2
a163 2
#define	db1_printf(a) (void)0
#endif	/* ! RAIDDEBUG */
d165 1
a165 1
static RF_Raid_t **raidPtrs;	/* Global raid device descriptors. */
d167 1
a167 1
RF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex);
d169 1
a169 1
/* Requests to install a spare table. */
d172 1
a172 1
/* Responses from installation process. */
d175 5
a179 5
/* Prototypes. */
void rf_KernelWakeupFunc(struct buf *);
void rf_InitBP(struct buf *, struct vnode *, unsigned, dev_t, RF_SectorNum_t,
    RF_SectorCount_t, caddr_t, void (*)(struct buf *), void *, int,
    struct proc *);
d182 9
a190 9
void raidattach(int);
int  raidsize(dev_t);
int  raidopen(dev_t, int, int, struct proc *);
int  raidclose(dev_t, int, int, struct proc *);
int  raidioctl(dev_t, u_long, caddr_t, int, struct proc *);
int  raidwrite(dev_t, struct uio *, int);
int  raidread(dev_t, struct uio *, int);
void raidstrategy(struct buf *);
int  raiddump(dev_t, daddr_t, caddr_t, size_t);
d196 4
a199 4
	struct buf	 rf_buf;	/* New I/O buf.	 MUST BE FIRST!!! */
	struct buf	*rf_obp;	/* Ptr. to original I/O buf. */
	int		 rf_flags;	/* Miscellaneous flags. */
	RF_DiskQueueData_t *req;	/* The request that this was part of. */
d202 2
a203 2
#define	RAIDGETBUF(rs)		pool_get(&(rs)->sc_cbufpool, PR_NOWAIT)
#define	RAIDPUTBUF(rs, cbp)	pool_put(&(rs)->sc_cbufpool, cbp)
d216 1
a216 1
 * or if it should be used in conjunction with that...
d219 7
a225 7
	int		sc_flags;		/* Flags. */
	int		sc_cflags;		/* Configuration flags. */
	size_t		sc_size;		/* Size of the raid device. */
	char		sc_xname[20];		/* XXX external name. */
	struct disk	sc_dkdev;		/* Generic disk device info. */
	struct pool	sc_cbufpool;		/* Component buffer pool. */
	struct buf	sc_q;			/* Used for the device queue. */
d229 5
a233 5
#define	RAIDF_INITED	0x01	/* Unit has been initialized. */
#define	RAIDF_WLABEL	0x02	/* Label area is writable. */
#define	RAIDF_LABELLING	0x04	/* Unit is currently being labelled. */
#define	RAIDF_WANTED	0x40	/* Someone is waiting to obtain a lock. */
#define	RAIDF_LOCKED	0x80	/* Unit is locked. */
d243 5
a247 5
int  rf_probe(struct device *, void *, void *);
void rf_attach(struct device *, struct device *, void *);
int  rf_detach(struct device *, int);
int  rf_activate(struct device *, enum devact);
void rf_zeroref(struct device *);
d258 4
a261 4
 *
 * For example: with a stripe width of 64 blocks (32k) and 5 disks,
 * a single 64K write will typically require 64K for the old data,
 * 64K for the old parity, and 64K for the new parity, for a total
d265 1
a265 1
 *
d267 1
a267 1
 * require data reconstruction, which will require *all* of the 4 remaining
d271 2
a272 2
#ifndef	RAIDOUTSTANDING
#define	RAIDOUTSTANDING		6
d275 1
a275 1
#define	RAIDLABELDEV(dev)						\
d278 2
a279 2
/* Declared here, and made public, for the benefit of KVM stuff... */
struct raid_softc  *raid_softc;
d282 4
a285 4
void rf_shutdown_hook(RF_ThreadArg_t);
void raidgetdefaultlabel(RF_Raid_t *, struct raid_softc *, struct disklabel *);
void raidgetdisklabel(dev_t);
void raidmakedisklabel(struct raid_softc *);
d287 2
a288 2
int  raidlock(struct raid_softc *);
void raidunlock(struct raid_softc *);
d290 1
a290 1
void rf_markalldirty(RF_Raid_t *);
d294 1
a294 1
int  findblkmajor(struct device *dv);
d299 1
a299 1
/*void rf_ReconThread(RF_Raid_t *raidPtr);*/
d303 1
a303 1
#ifdef	RAID_AUTOCONFIG
d305 2
a306 2
int  rf_reasonable_label(RF_ComponentLabel_t *);
#endif	/* RAID_AUTOCONFIG */
d310 1
a310 1
int  rf_does_it_fit(RF_ConfigSet_t *,RF_AutoConfig_t *);
d313 2
a314 2
int  rf_set_autoconfig(RF_Raid_t *, int);
int  rf_set_rootpartition(RF_Raid_t *, int);
d317 2
a318 2
int  rf_have_enough_components(RF_ConfigSet_t *);
int  rf_auto_config_set(RF_ConfigSet_t *, int *);
d320 7
a326 9
#ifdef	RAID_AUTOCONFIG
static int raidautoconfig = 0;	/*
				 * Debugging, mostly.  Set to 0 to not
				 * allow autoconfig to take place.
				 * Note that this is overridden by having
				 * RAID_AUTOCONFIG as an option in the
				 * kernel config file.
				 */
#endif	/* RAID_AUTOCONFIG */
d329 4
a332 1
rf_probe(struct device *parent, void *match_, void *aux)
d338 3
a340 1
rf_attach(struct device *parent, struct device *self, void *aux)
d342 1
a342 1
	/*struct raid_softc *raid = (void *)self;*/
d346 3
a348 1
rf_detach(struct device *self, int flags)
d354 3
a356 1
rf_activate(struct device *self, enum devact act)
d362 2
a363 1
rf_zeroref(struct device *self)
d368 2
a369 1
raidattach(int num)
d373 2
a374 2
#ifdef	RAID_AUTOCONFIG
	RF_AutoConfig_t *ac_list;	/* Autoconfig list. */
d376 1
a376 1
#endif	/* RAID_AUTOCONFIG */
d381 1
a381 1
#ifdef	DIAGNOSTIC
d383 1
a383 1
#endif	/* DIAGNOSTIC */
d399 2
a400 2
		RF_PANIC();
	}
d405 1
a405 1
		raidPtrs[i] = NULL;
d408 1
a408 1
		printf("Kernelized RAIDframe activated\n");
d410 1
a410 1
	        panic("Serious error booting RAID !!!");
d413 1
a413 1
	 * Put together some datastructures like the CCD device does...
d416 1
a416 1

d418 2
a419 1
		malloc(num * sizeof(struct raid_softc), M_RAIDFRAME, M_NOWAIT);
d428 2
a429 2
		malloc(num * sizeof(struct raid_softc *), M_RAIDFRAME,
		    M_NOWAIT);
d438 1
a438 1
	    M_RAIDFRAME, M_NOWAIT);
d453 1
a453 2
		snprintf(raidrootdev[raidID].dv_xname,
		    sizeof raidrootdev[raidID].dv_xname,"raid%d",raidID);
d467 1
a467 1
#ifdef	RAID_AUTOCONFIG
d471 1
a471 1
		/* 1. Locate all RAID components on the system. */
d475 1
a475 1
#endif	/* RAIDDEBUG */
d478 1
a478 1
		/* 2. Sort them into their respective sets. */
d482 2
a483 4
		/*
		 * 3. Evaluate each set and configure the valid ones
		 * This gets done in rf_buildroothack().
		 */
d485 2
a486 4
		/*
		 * Schedule the creation of the thread to do the
		 * "/ on RAID" stuff.
		 */
d491 1
a491 1
#endif	/* RAID_AUTOCONFIG */
d495 1
a495 1
#ifdef	RAID_AUTOCONFIG
d497 2
a498 1
rf_buildroothack(void *arg)
d514 1
a514 1
		if (rf_have_enough_components(cset) &&
d521 1
a521 2
					printf("eligible root device %d:"
					    " raid%d\n", num_root, rootID);
d528 2
a529 3
				printf("Autoconfig failed with code %d for"
				    " raid%d\n", retcode, raidID);
#endif	/* RAIDDEBUG */
d533 2
a534 4
			/*
			 * We're not autoconfiguring this set...
			 * Release the associated resources.
			 */
d537 1
a537 1
		/* Cleanup. */
d551 1
a551 1
				rootdev = MAKEDISKDEV(majdev,rootID,0);
d555 1
a555 1
			/* We can't guess... Require the user to answer... */
d560 1
a560 1
#endif	/* RAID_AUTOCONFIG */
d563 2
a564 1
rf_shutdown_hook(RF_ThreadArg_t arg)
d570 1
a570 1
	/* Don't do it if we are not "safe". */
d578 1
a578 1
	/* Shutdown the system. */
d598 2
a599 1
raidsize(dev_t dev)
d634 5
a638 1
raiddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
d646 4
a649 1
raidopen(dev_t dev, int flags, int fmt, struct proc *p)
d656 1
a656 1

d675 1
a675 1
	/* Make sure that this partition exists. */
d689 1
a689 1
	/* Prevent this unit from being unconfigured while opened. */
d702 7
a708 11
		/*
		 * First one...  Mark things as dirty...  Note that we *MUST*
		 * have done a configure before this.  I DO NOT WANT TO BE
		 * SCRIBBLING TO RANDOM COMPONENTS UNTIL IT'S BEEN DETERMINED
		 * THAT THEY BELONG TOGETHER!!!!!
		 */
		/*
		 * XXX should check to see if we're only open for reading
		 * here...  If so, we needn't do this, but then need some
		 * other way of keeping track of what's happened...
		 */
d710 1
a710 1
		rf_markalldirty( raidPtrs[unit] );
d723 4
a726 1
raidclose(dev_t dev, int flags, int fmt, struct proc *p)
d757 4
a760 6
		/*
		 * Last one...  Device is not unconfigured yet.
		 * Device shutdown has taken care of setting the
		 * clean bits if RAIDF_INITED is not set.
		 * Mark things as clean...
		 */
d771 2
a772 1
raidstrategy(struct buf *bp)
d841 4
a844 1
raidread(dev_t dev, struct uio *uio, int flags)
d865 4
a868 1
raidwrite(dev_t dev, struct uio *uio, int flags)
d884 6
a889 1
raidioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d968 1
a968 1

d970 1
a970 1
		/* Configure the system. */
d974 1
a974 1
			/* There is a valid RAID set running on this unit ! */
d980 1
a980 1
		 * Copy-in the configuration information.
d1001 1
a1001 1
				/* Sanity check. */
d1015 1
a1015 1
				RF_Free(specific_buf,
d1022 1
a1022 1

d1026 1
a1026 1
		 * Store the sum of all the bytes in the last byte ?
d1031 2
a1032 2
		 *  there is no stale data left in the case of a
		 *  reconfiguration.
d1036 1
a1036 1
		/* Configure the system. */
d1043 2
a1044 4
			/*
			 * Allow this many simultaneous IO's to
			 * this RAID device.
			 */
d1046 1
a1046 1

d1056 1
a1056 1

d1058 1
a1058 1

d1060 2
a1061 2
		/* Shutdown the system. */

d1096 1
a1096 1

d1099 2
a1100 4
		/*
		 * We need to read the component label for the disk indicated
		 * by row,column in clabel.
		 */
d1102 2
a1103 4
		/*
		 * For practice, let's get it directly from disk, rather
		 * than from the in-core copy.
		 */
d1111 1
a1111 1
		retcode = copyin( *clabel_ptr, clabel,
d1118 1
a1118 1

d1127 4
a1130 2
		raidread_component_label(raidPtr->Disks[row][column].dev,
		    raidPtr->raid_cinfo[row][column].ci_vp, clabel );
d1132 1
a1132 1
		retcode = copyout((caddr_t) clabel,
d1142 4
a1145 5
		/*
		 * Note that some things *should not* get modified --
		 * the user should be re-initing the labels instead of
		 * trying to patch things.
		 */
d1158 1
a1158 1
#endif	/* RAIDDEBUG */
d1171 4
a1174 2
		raidwrite_component_label(raidPtr->Disks[row][column].dev,
		    raidPtr->raid_cinfo[row][column].ci_vp, clabel );
d1178 1
a1178 1
	case RAIDFRAME_INIT_LABELS:
d1180 6
a1185 6
		/*
		 * We only want the serial number from the above.
		 * We get all the rest of the information from
		 * the config that was used to create this RAID
		 * set.
		 */
d1188 1
a1188 1

d1200 3
a1202 3
					raidwrite_component_label(
					    raidPtr->Disks[row][column].dev,
					    raidPtr->raid_cinfo[row][column].ci_vp,
d1209 1
a1209 1

d1213 1
a1213 1
			/* Parity for RAID 0 is trivially correct. */
d1218 1
a1218 1

d1220 1
a1220 1
			/* Re-write is already in progress ! */
d1254 1
a1254 1
		memcpy( &component, componentPtr,
d1261 1
a1261 1
		memcpy( &component, componentPtr,
d1269 1
a1269 1
			/* Can't do this on a RAID 0 !! */
d1274 1
a1274 1
			/* A reconstruct is already in progress ! */
d1279 1
a1279 1
		memcpy( &component, componentPtr,
d1348 1
a1348 1

d1357 1
a1357 1

d1362 1
a1362 1
	/* Fail a disk & optionally start reconstruction. */
d1365 1
a1365 1

d1371 2
a1372 2
		    unit, rr->row, rr->col));

d1375 1
a1375 1
		 * rely on the user's buffer.
d1387 1
a1387 1

d1392 1
a1392 1
	case RAIDFRAME_COPYBACK:
d1394 1
a1394 1
			/* This makes no sense on a RAID 0 !! */
d1397 1
a1397 1

d1399 1
a1399 1
			/* Copyback is already in progress ! */
d1402 1
a1402 1

d1408 1
a1408 1
	/* Return the percentage completion of reconstruction. */
d1411 2
a1412 4
			/*
			 * This makes no sense on a RAID 0, so tell the
			 * user it's done.
			 */
d1432 1
a1432 1
			progressInfo.total =
d1434 1
a1434 1
			progressInfo.completed =
d1446 2
a1447 4
			/*
			 * This makes no sense on a RAID 0, so tell the
			 * user it's done.
			 */
d1452 2
a1453 2
			*(int *) data = 100 *
				raidPtr->parity_rewrite_stripes_done /
d1464 1
a1464 1
			progressInfo.completed =
d1480 1
a1480 1
			/* This makes no sense on a RAID 0 !! */
d1496 1
a1496 1
			progressInfo.completed =
d1532 1
a1532 1

d1534 1
a1534 1

d1537 1
a1537 1

d1555 1
a1555 1
		 * into the kernel.
d1557 2
a1558 2

		/* Install the spare table. */
d1560 1
a1560 1

d1562 2
a1563 2
		 * Respond to the requestor.  The return status of the
		 * spare table installation is passed in the "fcol" field.
d1572 1
a1572 1

d1575 1
a1575 1
	/* Fall through to the os-specific code below. */
d1579 1
a1579 1

d1582 1
a1582 1

d1636 1
a1636 1

d1645 1
a1645 1
 * raidinit -- Complete the rest of the initialization for the
d1649 2
a1650 1
raidinit(RF_Raid_t *raidPtr)
d1654 1
a1654 1
	int unit;
d1661 1
a1661 1

d1665 2
a1666 2
	/* XXX doesn't check bounds. */
	snprintf(rs->sc_xname, sizeof rs->sc_xname, "raid%d", unit);
d1668 1
a1668 1
	rs->sc_dkdev.dk_name = rs->sc_xname;
d1672 2
a1673 2
	 * other things, so it's critical to call this *BEFORE* we try
	 * putzing with disklabels.
d1702 1
a1702 1
 * Wake up the daemon & tell it to get us a spare table.
d1704 3
a1706 3
 * The entries in the queues should be tagged with the raidPtr so that
 * in the extremely rare case that two recons happen at once, we know
 * which devices were requesting a spare table.
d1708 1
a1708 1
 *
d1712 2
a1713 1
rf_GetSpareTableFromDaemon(RF_SparetWait_t *req)
d1722 1
a1722 1
	/* mpsleep unlocks the mutex. */
d1725 1
a1725 1
		    "RAIDframe getsparetable", 0);
d1732 1
a1732 1
	/* This is not the same req as we alloc'd. */
d1739 5
a1743 5
 * bp and passes it down.
 * Any calls originating in the kernel must use non-blocking I/O.
 * Do some extra sanity checking to return "appropriate" error values for
 * certain conditions (to make some standard utilities work).
 *
d1747 2
a1748 1
raidstart(RF_Raid_t *raidPtr)
d1754 1
a1754 1
	daddr_t blocknum;
d1763 1
a1763 1
	/* Quick check to see if anything has died recently. */
d1766 1
a1766 1
		rf_update_component_labels(raidPtr,
d1776 1
a1776 1

d1779 1
a1779 1
			/* Nothing more to do. */
d1784 4
a1787 6
		/*
		 * Ok, for the bp we have here, bp->b_blkno is relative to the
		 * partition... We need to make it absolute to the underlying
		 * device...
		 */

d1793 2
a1794 2

		db1_printf(("Blocks: %d, %d\n", (int) bp->b_blkno,
d1796 1
a1796 1

d1799 3
a1801 5

		/*
		 * *THIS* is where we adjust what block we're going to...
		 * But DO NOT TOUCH bp->b_blkno !!!
		 */
d1803 1
a1803 1

d1808 3
a1810 3
			db1_printf(("raid_addr=%d sum=%d num_blocks=%d(+%d)"
			    " (%d)\n", (int)raid_addr, (int)sum,
			    (int)num_blocks, (int)pb, (int)bp->b_resid));
d1818 1
a1818 1
			    __func__, bp)); */
d1825 1
a1825 1
		 * XXX rf_DoAccess() should do this, not just DoAccessKernel().
d1827 1
a1827 1

d1833 1
a1833 1
			    __func__, bp)); */
d1838 1
a1838 1

d1841 2
a1842 2


d1851 1
a1851 1

d1853 3
d1857 2
a1858 9
		/*
		 * XXX we're still at splbio() here...  Do we *really*
		 * need to be ?
		 */

		/*
		 * Don't ever condition on bp->b_flags & B_WRITE.
		 * Always condition on B_READ instead.
		 */
d1863 1
a1863 1
				      bp->b_data, bp, NULL, NULL,
d1871 1
a1871 1
/* Invoke an I/O from kernel mode.  Disk queue should be locked upon entry. */
d1874 3
a1876 1
rf_DispatchKernelIO(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req)
d1883 5
a1887 2
	/*int s = splbio();*/	/* Want to test this. */

d1890 1
a1890 1
	 * this device...
d1893 1
a1893 1

d1910 1
a1910 1
	 * us a buffer that contains old stuff !!  Attempt to deal with
d1912 2
a1913 2
	 * (not sure where the real bug is; it's buried in RAIDframe
	 * somewhere) :-( GO )
d1925 1
a1925 1
	raidbp->rf_flags = 0;	/* XXX not really used anywhere... */
d1928 1
a1928 1
	 * Context for raidiodone.
d1942 1
a1942 1
		/* XXX need to do something extra here... */
d1951 1
a1951 1
		/* XXX need to glue the original buffer into this ?? */
d1955 1
a1955 1

d1965 1
a1965 1
		    req->buf, rf_KernelWakeupFunc, (void *)req,
d1993 1
a1993 1

d1998 1
a1998 1
	/*splx(s);*/	/* want to test this */
d2007 2
a2008 1
rf_KernelWakeupFunc(struct buf *vbp)
d2049 1
a2049 1
	bp->b_bcount = raidbp->rf_buf.b_bcount;	/* XXXX ?? */
d2051 1
a2051 1
	unit = queue->raidPtr->raidid;	/* *Much* simpler :-> */
d2054 1
a2054 1
	 * XXX Ok, let's get aggressive...  If B_ERROR is set, let's go
d2089 13
a2101 13
rf_InitBP(
	struct buf	 *bp,
	struct vnode	 *b_vp,
	unsigned	  rw_flag,
	dev_t		  dev,
	RF_SectorNum_t	  startSect,
	RF_SectorCount_t  numSect,
	caddr_t		  buf,
	void		(*cbFunc)(struct buf *),
	void		 *cbArg,
	int		  logBytesPerSector,
	struct proc	 *b_proc
)
d2103 2
a2104 2
	/*bp->b_flags = B_PHYS | rw_flag;*/
	bp->b_flags = B_CALL | rw_flag;	/* XXX need B_PHYS here too ??? */
d2111 1
a2111 1
	bp->b_resid = bp->b_bcount;	/* XXX is this right !??!?!! */
d2122 4
a2125 2
raidgetdefaultlabel(RF_Raid_t *raidPtr, struct raid_softc *rs,
    struct disklabel *lp)
d2130 1
a2130 1
	/* Fabricate a label... */
d2135 2
a2136 2
	lp->d_ncylinders = raidPtr->totalSectors /
	    (lp->d_nsectors * lp->d_ntracks);
d2157 2
a2158 2
 * Read the disklabel from the raid device.
 * If one is not present, fake one up.
d2161 2
a2162 1
raidgetdisklabel(dev_t dev)
d2189 1
a2189 1
		/*raidmakedisklabel(rs);*/
d2221 2
a2222 1
raidmakedisklabel(struct raid_softc *rs)
d2246 4
a2249 1
raidlookup(char *path, struct proc *p, struct vnode **vpp /* result */)
d2293 2
a2294 1
raidlock(struct raid_softc *rs)
d2311 2
a2312 1
raidunlock(struct raid_softc *rs)
d2320 1
d2322 2
d2325 1
a2325 4
#define	RF_COMPONENT_INFO_OFFSET	16384	/* bytes */
#define	RF_COMPONENT_INFO_SIZE		 1024	/* bytes */

int
d2337 1
a2337 1
int
d2350 4
a2353 2
raidread_component_label(dev_t dev, struct vnode *b_vp,
    RF_ComponentLabel_t *clabel)
d2357 3
a2359 5

	/*
	 * XXX should probably ensure that we don't try to do this if
	 * someone has changed rf_protected_sectors.
	 */
d2362 2
a2363 4
		/*
		 * For whatever reason, this component is not valid.
		 * Don't try to read a component label from it.
		 */
d2367 1
a2367 1
	/* Get a block of the appropriate size... */
d2371 1
a2371 1
	/* Get our ducks in a row for the read. */
d2379 1
a2379 1
	error = biowait(bp);
d2382 2
a2383 1
		memcpy(clabel, bp->b_data, sizeof(RF_ComponentLabel_t));
d2387 1
a2387 1
	} else {
d2391 1
a2391 1
	brelse(bp);
d2396 5
a2400 3
int
raidwrite_component_label(dev_t dev, struct vnode *b_vp,
    RF_ComponentLabel_t *clabel)
d2405 1
a2405 1
	/* Get a block of the appropriate size... */
d2409 1
a2409 1
	/* Get our ducks in a row for the write. */
d2420 1
a2420 1
	error = biowait(bp);
d2429 3
a2431 2
void
rf_markalldirty(RF_Raid_t *raidPtr)
d2439 2
a2440 4
			/*
			 * We don't want to touch (at all) a disk that has
			 * failed.
			 */
d2443 3
a2445 2
				    raidPtr->Disks[r][c].dev,
				    raidPtr->raid_cinfo[r][c].ci_vp, &clabel);
d2447 3
a2449 5
					/*
					 * XXX do something special...
					 * But whatever you do, don't
					 * try to access it !!!
					 */
d2452 11
a2462 11
					clabel.status =
					    raidPtr->Disks[r][c].status;
					raidwrite_component_label(
					    raidPtr->Disks[r][c].dev,
					    raidPtr->raid_cinfo[r][c].ci_vp,
					    &clabel);
#endif
					raidmarkdirty(
					    raidPtr->Disks[r][c].dev,
					    raidPtr->raid_cinfo[r][c].ci_vp,
					    raidPtr->mod_counter);
d2465 1
a2465 1
		}
d2467 1
a2467 1
	/*printf("Component labels marked dirty.\n");*/
d2472 5
a2476 3
			/*
			 * XXX This is where we get fancy and map this spare
			 * into it's correct spot in the array.
d2478 7
a2484 5
			/*
			 * We claim this disk is "optimal" if it's
			 * rf_ds_used_spare, as that means it should be
			 * directly substitutable for the disk it replaced.
			 * We note that too...
d2489 1
a2489 1
					if ((raidPtr->Disks[i][j].spareRow ==
d2499 7
a2505 6

			raidread_component_label(
			    raidPtr->Disks[r][sparecol].dev,
			    raidPtr->raid_cinfo[r][sparecol].ci_vp, &clabel);
			/* Make sure status is noted. */
			clabel.version = RF_COMPONENT_LABEL_VERSION;
d2512 1
a2512 1
			clabel.clean = RF_RAID_DIRTY;	/* Changed in a bit. */
d2515 5
a2519 4
			    raidPtr->Disks[r][sparecol].dev,
			    raidPtr->raid_cinfo[r][sparecol].ci_vp, &clabel);
			raidmarkclean( raidPtr->Disks[r][sparecol].dev,
			    raidPtr->raid_cinfo[r][sparecol].ci_vp);
d2528 3
a2530 1
rf_update_component_labels(RF_Raid_t *raidPtr, int final)
d2541 2
a2542 4
	/*
	 * XXX should do extra checks to make sure things really are clean,
	 * rather than blindly setting the clean bit...
	 */
d2553 1
a2553 1
				/* Make sure status is noted. */
d2555 1
a2555 1
				/* Bump the counter. */
d2558 1
a2558 1
				raidwrite_component_label(
d2563 5
a2567 7
					if (raidPtr->parity_good ==
					    RF_RAID_CLEAN) {
						raidmarkclean(
						    raidPtr->Disks[r][c].dev,
						    raidPtr->
						    raid_cinfo[r][c].ci_vp,
						    raidPtr->mod_counter);
d2570 3
a2572 3
			}
			/* Else we don't touch it... */
		}
d2578 7
a2584 5
			/*
			 * We claim this disk is "optimal" if it's
			 * rf_ds_used_spare, as that means it should be
			 * directly substitutable for the disk it replaced.
			 * We note that too...
d2589 1
a2589 1
					if ((raidPtr->Disks[i][j].spareRow ==
d2599 7
a2605 6

			/* XXX Shouldn't *really* need this... */
			raidread_component_label(
			    raidPtr->Disks[0][sparecol].dev,
			    raidPtr->raid_cinfo[0][sparecol].ci_vp, &clabel);
			/* Make sure status is noted. */
d2615 3
a2617 2
			    raidPtr->Disks[0][sparecol].dev,
			    raidPtr->raid_cinfo[0][sparecol].ci_vp, &clabel);
d2620 3
a2622 5
					raidmarkclean(raidPtr->
					    Disks[0][sparecol].dev,
					    raidPtr->
					    raid_cinfo[0][sparecol].ci_vp,
					    raidPtr->mod_counter);
d2627 1
a2627 1
	/*printf("Component labels updated\n");*/
d2631 4
a2634 1
rf_close_component(RF_Raid_t *raidPtr, struct vnode *vp, int auto_configured)
d2645 3
a2647 4

		} else {
			if (VOP_ISLOCKED(vp))
				VOP_UNLOCK(vp, 0, p);
d2657 2
a2658 1
rf_UnconfigureVnodes(RF_Raid_t *raidPtr)
d2660 1
a2660 1
	int r,c;
d2665 1
a2665 1
	/* We take this opportunity to close the vnodes like we should... */
d2689 3
a2691 2
void
rf_ReconThread(struct rf_recon_req *req)
d2693 1
a2693 1
	int s;
d2703 1
a2703 1
	/* XXX Get rid of this! we don't need it at all... */
d2710 1
a2710 1
	kthread_exit(0);	/* Does not return. */
d2714 2
a2715 1
rf_RewriteParityThread(RF_Raid_t *raidPtr)
d2726 3
a2728 5
		/*
		 * Set the clean bit !  If we shutdown correctly,
		 * the clean bit on each component label will get
		 * set.
		 */
d2734 1
a2734 1
	/* Anyone waiting for us to stop ?  If so, inform them... */
d2740 1
a2740 1
	kthread_exit(0);	/* Does not return. */
d2745 2
a2746 1
rf_CopybackThread(RF_Raid_t *raidPtr)
d2757 1
a2757 1
	kthread_exit(0);	/* Does not return. */
d2762 2
a2763 1
rf_ReconstructInPlaceThread(struct rf_recon_req *req)
d2768 1
a2768 1

d2778 1
a2778 1
	kthread_exit(0);	/* Does not return. */
d2783 1
a2783 1
rf_find_raid_components(void)
d2785 1
a2785 1
#ifdef	RAID_AUTOCONFIG
d2796 1
a2796 1
#endif	/* RAID_AUTOCONFIG */
d2800 1
a2800 1
	/* Initialize the AutoConfig list. */
d2803 2
a2804 2
#ifdef	RAID_AUTOCONFIG
	/* We begin by trolling through *all* the devices on the system. */
d2806 2
a2807 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
d2809 1
a2809 1
		/* We are only interested in disks... */
d2813 1
a2813 1
		/* We don't care about floppies... */
d2817 2
a2818 5

		/*
		 * We need to find the device_name_to_block_device_major
		 * stuff.
		 */
d2821 1
a2821 1
		/* Get a vnode for the raw partition of this disk. */
d2830 2
a2831 4
			/*
			 * "Who cares."  Continue looking
			 * for something that exists.
			 */
d2837 1
a2837 1
		error = VOP_IOCTL(vp, DIOCGDINFO, (caddr_t)&label,
d2842 1
a2842 1
			 * have errored out (or faked up one).
d2845 1
a2845 1
			    dv->dv_xname, 'a' + RAW_PART, error);
d2848 2
a2849 4
		/*
		 * We don't need this any more.  We'll allocate it again
		 * a little later if we really do...
		 */
d2854 4
a2857 6
			/*
			 * We only support partitions marked as RAID.
			 * Except on sparc/sparc64 where FS_RAID doesn't
			 * fit in the SUN disklabel and we need to look
			 * into each and every partition !!!
			 */
d2880 3
a2882 3
			clabel = (RF_ComponentLabel_t *)
				malloc(sizeof(RF_ComponentLabel_t), M_RAIDFRAME,
				    M_NOWAIT);
d2884 1
a2884 1
				/* XXX CLEANUP HERE. */
d2886 1
a2886 1
				return(NULL); /* XXX probably should panic ? */
d2890 1
a2890 1
				/* Got the label.  Does it look reasonable ? */
d2892 1
a2892 1
				    (clabel->partitionSize <=
d2895 3
a2897 3
					printf("Component on: %s%c: %d\n",
					    dv->dv_xname, 'a'+i,
					    label.d_partitions[i].p_size);
d2899 3
a2901 5
#endif	/* RAIDDEBUG */
					/*
					 * If it's reasonable, add it,
					 * else ignore it.
					 */
d2904 2
a2905 1
						    M_RAIDFRAME, M_NOWAIT);
d2907 1
a2907 1
						/* XXX should panic ??? */
d2910 3
a2912 4

					snprintf(ac->devname,
						 sizeof ac->devname, "%s%c",
						 dv->dv_xname, 'a'+i);
d2919 1
a2919 1
				}
d2922 1
a2922 1
				/* Cleanup. */
d2929 2
a2930 2
#endif	/* RAID_AUTOCONFIG */
	return(ac_list);
d2932 2
a2933 2

#ifdef	RAID_AUTOCONFIG
d2935 2
a2936 1
rf_reasonable_label(RF_ComponentLabel_t *clabel)
d2938 1
a2938 1

d2943 2
a2944 2
	    clabel->row >=0 &&
	    clabel->column >= 0 &&
d2947 1
a2947 1
	    clabel->row < clabel->num_rows &&
d2951 1
a2951 1
		/* Label looks reasonable enough... */
d2956 1
a2956 1
#endif	/* RAID_AUTOCONFIG */
d2959 2
a2960 1
rf_print_component_label(RF_ComponentLabel_t *clabel)
d2963 2
a2964 1
	    clabel->row, clabel->column, clabel->num_rows, clabel->num_columns);
d2966 4
a2969 3
	    clabel->version, clabel->serial_number, clabel->mod_counter);
	printf("   Clean: %s Status: %d\n", clabel->clean ? "Yes" : "No",
	    clabel->status );
d2971 1
a2971 1
	    clabel->sectPerSU, clabel->SUsPerPU, clabel->SUsPerRU);
d2973 2
a2974 1
	    (char) clabel->parityConfig, clabel->blockSize, clabel->numBlocks);
d2976 2
a2977 2
	printf("   Contains root partition: %s\n", clabel->root_partition ?
	    "Yes" : "No" );
d2982 1
d2986 2
a2987 1
rf_create_auto_sets(RF_AutoConfig_t *ac_list)
d2997 2
a2998 4
	/*
	 * Go through the AutoConfig list, and figure out which components
	 * belong to what sets.
	 */
d3001 2
a3002 4
		/*
		 * We're going to putz with ac->next, so save it here
		 * for use at the end of the loop.
		 */
d3006 1
a3006 1
			/* We will need at least this one... */
d3008 2
a3009 2
				malloc(sizeof(RF_ConfigSet_t), M_RAIDFRAME,
				    M_NOWAIT);
d3013 1
a3013 1
			/* This one is easy :) */
d3019 1
a3019 1
			/* Which set does this component fit into ? */
d3023 1
a3023 1
					/* Looks like it matches... */
d3031 1
a3031 1
				/* Didn't find a match above... new set... */
d3033 2
a3034 2
					malloc(sizeof(RF_ConfigSet_t),
					    M_RAIDFRAME, M_NOWAIT);
d3053 3
a3055 1
rf_does_it_fit(RF_ConfigSet_t *cset, RF_AutoConfig_t *ac)
d3059 24
a3082 26
	/*
	 * If this one matches the *first* one in the set, that's good
	 * enough, since the other members of the set would have been
	 * through here too...
	 */
	/*
	 * Note that we are not checking partitionSize here...
	 *
	 * Note that we are also not checking the mod_counters here.
	 * If everything else matches except the mod_counter, that's
	 * good enough for this test.  We will deal with the mod_counters
	 * a little later in the autoconfiguration process.
	 *
	 *  (clabel1->mod_counter == clabel2->mod_counter) &&
	 *
	 * The reason we don't check for this is that failed disks
	 * will have lower modification counts.  If those disks are
	 * not added to the set they used to belong to, then they will
	 * form their own set, which may result in 2 different sets,
	 * for example, competing to be configured at raid0, and
	 * perhaps competing to be the root filesystem set.  If the
	 * wrong ones get configured, or both attempt to become /,
	 * weird behaviour and or serious lossage will occur.  Thus we
	 * need to bring them into the fold here, and kick them out at
	 * a later point.
	 */
d3101 1
a3101 1
		/* If it get's here, it almost *has* to be a match. */
d3103 2
a3104 1
		/* It's not consistent with somebody in the set...  Punt. */
d3107 1
a3107 1
	/* All was fine.. It must fit... */
d3112 2
a3113 1
rf_have_enough_components(RF_ConfigSet_t *cset)
d3126 1
d3128 2
a3129 5

	/*
	 * Check to see that we have enough 'live' components
	 * of this set.  If so, we can configure it if necessary.
	 */
d3135 1
a3135 1
	/* XXX Check for duplicate components !?!?!? */
d3163 1
a3163 1
				    (ac->clabel->column == c) &&
d3165 1
a3165 1
					/* It's this one... */
d3168 2
a3169 2
					    ac->devname,r,c);
#endif	/* RAIDDEBUG */
d3176 4
a3179 6
				/*
				 * Special case for RAID 1, especially
				 * where there are more than 2
				 * components (where RAIDframe treats
				 * things a little differently :( )
				 */
d3181 1
a3181 1
					if (c%2 == 0) {	/* Even component. */
d3183 5
a3187 7
					} else {	/*
							 * Odd component.
							 * If we're failed,
							 * and so is the even
							 * component, it's
							 * "Good Night, Charlie"
							 */
d3193 1
a3193 1
					/* Normal accounting. */
d3198 3
a3200 5
				/*
				 * Just did an even component, and we didn't
				 * bail... Reset the even_pair_failed flag,
				 * and go on to the next component...
				 */
d3211 2
a3212 2
		/* XXX This needs to be made *much* more general. */
		/* Too many failures. */
d3215 2
a3216 4
	/*
	 * Otherwise, all is well, and we've got enough to take a kick
	 * at autoconfiguring this set.
	 */
d3221 4
a3224 2
rf_create_configuration(RF_AutoConfig_t *ac, RF_Config_t *config,
    RF_Raid_t *raidPtr)
d3231 1
a3231 1
	/* 1. Fill in the common stuff. */
d3234 1
a3234 1
	config->numSpare = 0;	/* XXX Should this be set here ? */
d3240 1
a3240 1
	strlcpy(config->diskQueueType,"fifo", sizeof config->diskQueueType);
d3242 1
a3242 1
	config->layoutSpecificSize = 0;	/* XXX ?? */
d3245 4
a3248 7
		/*
		 * row/col values will be in range due to the checks
		 * in reasonable_label().
		 */
		strlcpy(config->devnames[ac->clabel->row][ac->clabel->column],
		    ac->devname,
		    sizeof config->devnames[ac->clabel->row][ac->clabel->column]);
d3256 4
a3259 1
#ifdef	RAID_DEBUG_ALL
d3261 9
a3269 15
#ifdef	RF_DBG_OPTION
#undef	RF_DBG_OPTION
#endif	/* RF_DBG_OPTION */

#ifdef	__STDC__
#define	RF_DBG_OPTION(_option_,_val_)	do {				\
	snprintf(&(config->debugVars[i++][0]), 50, "%s %ld",		\
	    #_option_, _val_);						\
} while (0)
#else	/* __STDC__ */
#define	RF_DBG_OPTION(_option_,_val_)	do {				\
	snprintf(&(config->debugVars[i++][0]), 50, "%s %ld",		\
	    "/**/_option_/**/", _val_);					\
} while (0)
#endif	/* __STDC__ */
d3273 75
a3347 84
/*	RF_DBG_OPTION(accessDebug, 0);					*/
/*	RF_DBG_OPTION(accessTraceBufSize, 0);				*/
	RF_DBG_OPTION(cscanDebug, 1);		/* Debug CSCAN sorting.	*/
	RF_DBG_OPTION(dagDebug, 1);
/*	RF_DBG_OPTION(debugPrintUseBuffer, 0);				*/
	RF_DBG_OPTION(degDagDebug, 1);
	RF_DBG_OPTION(disableAsyncAccs, 1);
	RF_DBG_OPTION(diskDebug, 1);
	RF_DBG_OPTION(enableAtomicRMW, 0);
		/*
		 * This debug variable enables locking of the
		 * disk arm during small-write operations.
		 * Setting this variable to anything other than
		 * 0 will result in deadlock.  (wvcii)
		 */
	RF_DBG_OPTION(engineDebug, 1);
	RF_DBG_OPTION(fifoDebug, 1);		/* Debug fifo queueing.	*/
/*	RF_DBG_OPTION(floatingRbufDebug, 1);				*/
/*	RF_DBG_OPTION(forceHeadSepLimit, -1);				*/
/*	RF_DBG_OPTION(forceNumFloatingReconBufs, -1);			*/
		/*
		 * Wire down the number of extra recon buffers
		 * to use.
		 */
/*	RF_DBG_OPTION(keepAccTotals, 1);				*/
		/* Turn on keep_acc_totals. */
	RF_DBG_OPTION(lockTableSize, RF_DEFAULT_LOCK_TABLE_SIZE);
	RF_DBG_OPTION(mapDebug, 1);
	RF_DBG_OPTION(maxNumTraces, -1);

/*	RF_DBG_OPTION(memChunkDebug, 1);				*/
/*	RF_DBG_OPTION(memDebug, 1);					*/
/*	RF_DBG_OPTION(memDebugAddress, 1);				*/
/*	RF_DBG_OPTION(numBufsToAccumulate, 1);				*/
		/*
		 * Number of buffers to accumulate before
		 * doing XOR.
		 */
	RF_DBG_OPTION(prReconSched, 0);
	RF_DBG_OPTION(printDAGsDebug, 1);
	RF_DBG_OPTION(printStatesDebug, 1);
	RF_DBG_OPTION(protectedSectors, 64L);
		/*
		 * Number of sectors at start of disk to exclude
		 * from RAID address space.
		 */
	RF_DBG_OPTION(pssDebug, 1);
	RF_DBG_OPTION(queueDebug, 1);
	RF_DBG_OPTION(quiesceDebug, 1);
	RF_DBG_OPTION(raidSectorOffset, 0);
		/*
		 * Value added to all incoming sectors to debug
		 * alignment problems.
		 */
	RF_DBG_OPTION(reconDebug, 1);
	RF_DBG_OPTION(reconbufferDebug, 1);
	RF_DBG_OPTION(scanDebug, 1);		/* Debug SCAN sorting.	*/
	RF_DBG_OPTION(showXorCallCounts, 0);
		/* Show n-way Xor call counts. */
	RF_DBG_OPTION(shutdownDebug, 1);	/* Show shutdown calls.	*/
	RF_DBG_OPTION(sizePercentage, 100);
	RF_DBG_OPTION(sstfDebug, 1);
		/* Turn on debugging info for sstf queueing. */
	RF_DBG_OPTION(stripeLockDebug, 1);
	RF_DBG_OPTION(suppressLocksAndLargeWrites, 0);
	RF_DBG_OPTION(suppressTraceDelays, 0);
	RF_DBG_OPTION(useMemChunks, 1);
	RF_DBG_OPTION(validateDAGDebug, 1);
	RF_DBG_OPTION(validateVisitedDebug, 1);
		/* XXX turn to zero by default ? */
	RF_DBG_OPTION(verifyParityDebug, 1);
	RF_DBG_OPTION(debugKernelAccess, 1);
		/* DoAccessKernel debugging. */

#if RF_INCLUDE_PARITYLOGGING > 0
	RF_DBG_OPTION(forceParityLogReint, 0);
	RF_DBG_OPTION(numParityRegions, 0);
		/* Number of regions in the array. */
	RF_DBG_OPTION(numReintegrationThreads, 1);
	RF_DBG_OPTION(parityLogDebug, 1);
		/* If nonzero, enables debugging of parity logging. */
	RF_DBG_OPTION(totalInCoreLogCapacity, 1024 * 1024);
		/* Target bytes available for in-core logs. */
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d3349 1
a3349 1
#endif	/* RAID_DEBUG_ALL */
d3353 3
a3355 1
rf_set_autoconfig(RF_Raid_t *raidPtr, int new_value)
d3365 1
a3365 1
			if (raidPtr->Disks[row][column].status ==
d3379 3
a3381 1
rf_set_rootpartition(RF_Raid_t *raidPtr, int new_value)
d3391 1
a3391 1
			if (raidPtr->Disks[row][column].status ==
d3405 2
a3406 1
rf_release_all_vps(RF_ConfigSet_t *cset)
d3409 1
a3409 1

d3412 1
a3412 1
		/* Close the vp, and give it back. */
d3424 2
a3425 1
rf_cleanup_config_set(RF_ConfigSet_t *cset)
d3429 1
a3429 1

d3433 1
a3433 1
		/* Nuke the label. */
d3435 1
a3435 1
		/* Cleanup the config structure. */
d3437 1
a3437 1
		/* "next..." */
d3440 1
a3440 1
	/* And, finally, nuke the config set. */
d3446 3
a3448 1
raid_init_component_label(RF_Raid_t *raidPtr, RF_ComponentLabel_t *clabel)
d3450 2
a3451 2
	/* Current version number. */
	clabel->version = RF_COMPONENT_LABEL_VERSION;
d3456 3
a3458 3
	clabel->clean = RF_RAID_DIRTY;	/* Not clean. */
	clabel->status = rf_ds_optimal;	/* "It's good !" */

d3466 1
a3466 1
	/* XXX Not portable. */
d3476 3
a3478 1
rf_auto_config_set(RF_ConfigSet_t *cset, int *unit)
d3490 1
a3490 1
	/* 1. Create a config structure. */
d3492 3
a3494 2
	config = (RF_Config_t *)malloc(sizeof(RF_Config_t), M_RAIDFRAME,
	    M_NOWAIT);
d3497 1
a3497 1
				/* XXX Do something more intelligent here. */
d3503 1
a3503 1
	/* XXX raidID needs to be set correctly... */
d3505 5
a3509 5
	/*
	 * 2. Figure out what RAID ID this one is supposed to live at.
	 * See if we can get the same RAID dev that it was configured
	 * on last time...
	 */
d3513 1
a3513 1
		/* Let's not wander off into lala land. */
d3518 5
a3522 5
		/*
		 * Nope...  Go looking for an alternative...
		 * Start high so we don't immediately use raid0 if that's
		 * not taken.
		 */
d3526 1
a3526 1
				/* We can use this one ! */
d3533 1
a3533 1
		/* Punt... */
d3540 1
a3540 1
	/* XXX All this stuff should be done SOMEWHERE ELSE ! */
d3544 1
a3544 1
	/* 3. Build the configuration structure. */
d3547 1
a3547 1
	/* 4. Do the configuration. */
d3549 1
a3549 1

d3555 1
a3555 1
		raidPtrs[raidID]->autoconfigure = 1; /* XXX Do this here ? */
d3557 2
a3558 4
			/*
			 * Everything configured just fine.  Make a note
			 * that this set is eligible to be root.
			 */
d3560 2
a3561 2
			/* XXX Do this here ? */
			raidPtrs[raidID]->root_partition = 1;
d3572 1
a3572 1
	/* 5. Cleanup. */
d3574 1
a3574 1

d3580 2
a3581 1
rf_disk_unbusy(RF_RaidAccessDesc_t *desc)
d3586 1
a3586 1
	disk_unbusy(&raid_softc[desc->raidPtr->raidid].sc_dkdev,
@


1.10
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_openbsdkintf.c,v 1.9 2000/01/11 18:02:22 peter Exp $	*/
d203 9
d213 2
a214 2
   or if it should be used in conjunction with that... 
*/
@


1.9
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_openbsdkintf.c,v 1.8 2000/01/07 14:50:21 peter Exp $	*/
/*	$NetBSD: rf_netbsdkintf.c,v 1.46 2000/01/09 03:39:13 oster Exp $	*/
d133 1
d152 1
d177 1
a177 1
static int raidinit __P((dev_t, RF_Raid_t *, int));
d204 2
a205 2
 * or if it should be used in conjunction with that...
 */
a209 1
	dev_t	 sc_dev;		/* our device..*/
d212 1
a212 1
	struct buf buf_queue;		/* used for the device queue */
d223 1
a223 1
static int numraid = 0;
d261 3
d271 24
d302 4
d318 2
d333 1
a333 1
	for (i = 0; i < numraid; i++)
d347 2
a348 1
	    malloc(num * sizeof (struct raid_softc), M_RAIDFRAME, M_NOWAIT);
d353 1
a353 1
	numraid = num;
d356 6
d363 11
a373 3
		raid_softc[raidID].buf_queue.b_actf = NULL;
		raid_softc[raidID].buf_queue.b_actb = 
			&raid_softc[raidID].buf_queue.b_actf;
d382 85
d468 1
d634 5
a638 1
	        rf_update_component_labels( raidPtrs[unit] );
a654 1
	struct buf *dp;
d704 3
a706 1
	/* stuff it onto our queue */
a707 6
	dp = &rs->buf_queue;
	bp->b_actf = NULL;
	bp->b_actb = dp->b_actb;
	*dp->b_actb = bp;
	dp->b_actb = &bp->b_actf;
	
d771 1
d779 1
a779 1
	RF_ComponentLabel_t *component_label;
d781 1
a781 1
	RF_ComponentLabel_t **c_label_ptr;
d785 1
d812 1
d823 1
d832 1
d834 5
d846 7
d903 7
d913 1
a913 1
		retcode = rf_Configure(raidPtr, k_cfg);
d920 3
a922 9

			/* XXX should be moved to rf_Configure() */

			raidPtr->copyback_in_progress = 0;
			raidPtr->parity_rewrite_in_progress = 0;
			raidPtr->recon_in_progress = 0;
		
			retcode = raidinit(dev, raidPtr, unit);
			rf_markalldirty( raidPtr );
d966 1
a966 1
		c_label_ptr = (RF_ComponentLabel_t **) data;
d968 1
a968 1
		   by row,column in component_label */
d972 1
a972 1
		RF_Malloc( component_label, sizeof( RF_ComponentLabel_t ),
d974 1
a974 1
		if (component_label == NULL)
d977 1
a977 1
		bzero((char *) component_label, sizeof(RF_ComponentLabel_t));
d979 1
a979 1
		retcode = copyin( *c_label_ptr, component_label, 
d983 1
a983 1
			RF_Free( component_label, sizeof(RF_ComponentLabel_t));
d987 2
a988 2
 		row = component_label->row;
		column = component_label->column;
d998 1
a998 1
			      component_label );
d1000 2
a1001 2
		retcode = copyout((caddr_t) component_label, 
				  (caddr_t) *c_label_ptr,
d1003 1
a1003 1
		RF_Free( component_label, sizeof(RF_ComponentLabel_t));
d1007 1
a1007 1
		component_label = (RF_ComponentLabel_t *) data;
d1016 9
a1024 9
		printf("Version: %d\n",component_label->version);
		printf("Serial Number: %d\n",component_label->serial_number);
		printf("Mod counter: %d\n",component_label->mod_counter);
		printf("Row: %d\n", component_label->row);
		printf("Column: %d\n", component_label->column);
		printf("Num Rows: %d\n", component_label->num_rows);
		printf("Num Columns: %d\n", component_label->num_columns);
		printf("Clean: %d\n", component_label->clean);
		printf("Status: %d\n", component_label->status);
d1026 2
a1027 2
		row = component_label->row;
		column = component_label->column;
d1031 1
a1031 1
			RF_Free( component_label, sizeof(RF_ComponentLabel_t));
d1040 1
a1040 1
			    component_label );
d1045 1
a1045 1
		component_label = (RF_ComponentLabel_t *) data;
d1053 4
a1056 9
		raidPtr->serial_number = component_label->serial_number;
		/* current version number */
		ci_label.version = RF_COMPONENT_LABEL_VERSION; 
		ci_label.serial_number = component_label->serial_number;
		ci_label.mod_counter = raidPtr->mod_counter;
		ci_label.num_rows = raidPtr->numRow;
		ci_label.num_columns = raidPtr->numCol;
		ci_label.clean = RF_RAID_DIRTY; /* not clean */
		ci_label.status = rf_ds_optimal; /* "It's good!" */
d1061 2
d1092 11
a1107 1
		printf("Adding spare\n");
d1114 14
d1272 4
a1275 2
			/* This makes no sense on a RAID 0 */
			return(EINVAL);
d1284 21
d1307 4
a1310 2
			/* This makes no sense on a RAID 0 */
			return(EINVAL);
d1313 3
a1315 1
			*(int *) data = 100 * raidPtr->parity_rewrite_stripes_done / raidPtr->Layout.numStripe;
d1321 18
d1342 2
a1343 1
			return(EINVAL);
d1352 18
d1490 2
a1494 1
#endif
d1507 2
a1508 3
int
raidinit(dev, raidPtr, unit)
	dev_t dev;
a1509 1
	int unit;
a1510 1
	int retcode;
d1512 1
d1514 1
a1514 1
	retcode = 0;
a1537 2
	rs->sc_dev = dev;
	return (retcode);
a1597 1
	struct buf *dp;
d1602 9
a1610 1
	
d1616 1
a1616 3
		/* get the next item, if any, from the queue */
		dp = &rs->buf_queue;
		bp = dp->b_actf;
d1621 2
a1622 10
  
		/* update structures */
		dp = bp->b_actf;
		if (dp != NULL) {
			dp->b_actb = bp->b_actb;
		} else {
			rs->buf_queue.b_actb = bp->b_actb;
		}
		*bp->b_actb = dp;
  
a1690 1
		
d1694 1
a1694 1
				      bp->b_un.b_addr, bp, NULL, NULL, 
a1696 1

d1903 1
a1903 1
			/* XXX here we should bump the version number for each component, and write that data out */
d1948 1
a1948 1
	bp->b_un.b_addr = buf;
a1992 1

d2009 2
d2023 7
a2029 7
	errstring = readdisklabel(RAIDLABELDEV(dev), raidstrategy,
	    rs->sc_dkdev.dk_label, rs->sc_dkdev.dk_cpulabel, 0);
	if (errstring)
		raidmakedisklabel(rs);
	else {
		int i;
		struct partition *pp;
d2031 19
a2049 20
		/*
		 * Sanity check whether the found disklabel is valid.
		 *
		 * This is necessary since total size of the raid device
		 * may vary when an interleave is changed even though exactly
		 * same componets are used, and old disklabel may used
		 * if that is found.
		 */
		if (lp->d_secperunit != rs->sc_size)
			printf("WARNING: %s: "
			    "total sector size in disklabel (%d) != "
			    "the size of raid (%ld)\n", rs->sc_xname,
			    lp->d_secperunit, (long) rs->sc_size);
		for (i = 0; i < lp->d_npartitions; i++) {
			pp = &lp->d_partitions[i];
			if (pp->p_offset + pp->p_size > rs->sc_size)
				printf("WARNING: %s: end of partition `%c' "
				    "exceeds the size of raid (%ld)\n",
				    rs->sc_xname, 'a' + i, (long) rs->sc_size);
		}
d2165 5
a2169 5
	RF_ComponentLabel_t component_label;
	raidread_component_label(dev, b_vp, &component_label);
	component_label.mod_counter = mod_counter;
	component_label.clean = RF_RAID_CLEAN;
	raidwrite_component_label(dev, b_vp, &component_label);
d2177 5
a2181 5
	RF_ComponentLabel_t component_label;
	raidread_component_label(dev, b_vp, &component_label);
	component_label.mod_counter = mod_counter;
	component_label.clean = RF_RAID_DIRTY;
	raidwrite_component_label(dev, b_vp, &component_label);
d2187 1
a2187 1
raidread_component_label(dev, b_vp, component_label)
d2190 1
a2190 1
	RF_ComponentLabel_t *component_label;
d2213 1
a2213 1
		memcpy(component_label, bp->b_un.b_addr,
d2216 1
a2216 10
		printf("raidread_component_label: got component label:\n");
		printf("Version: %d\n",component_label->version);
		printf("Serial Number: %d\n",component_label->serial_number);
		printf("Mod counter: %d\n",component_label->mod_counter);
		printf("Row: %d\n", component_label->row);
		printf("Column: %d\n", component_label->column);
		printf("Num Rows: %d\n", component_label->num_rows);
		printf("Num Columns: %d\n", component_label->num_columns);
		printf("Clean: %d\n", component_label->clean);
		printf("Status: %d\n", component_label->status);
d2219 1
d2221 1
d2230 1
a2230 1
raidwrite_component_label(dev, b_vp, component_label)
d2233 1
a2233 1
	RF_ComponentLabel_t *component_label;
d2248 1
a2248 1
	memset( bp->b_un.b_addr, 0, RF_COMPONENT_INFO_SIZE );
d2250 1
a2250 1
	memcpy( bp->b_un.b_addr, component_label, sizeof(RF_ComponentLabel_t));
d2257 1
d2259 1
d2266 1
a2266 1
rf_markalldirty( raidPtr )
d2269 1
a2269 1
	RF_ComponentLabel_t c_label;
d2279 2
a2280 2
					&c_label);
				if (c_label.status == rf_ds_spared) {
d2286 1
a2286 1
				c_label.status = 
d2291 1
a2291 1
					&c_label);
d2337 1
a2337 1
				      &c_label);
d2339 9
a2347 9
			c_label.version = RF_COMPONENT_LABEL_VERSION; 
			c_label.mod_counter = raidPtr->mod_counter;
			c_label.serial_number = raidPtr->serial_number;
			c_label.row = srow;
			c_label.column = scol;
			c_label.num_rows = raidPtr->numRow;
			c_label.num_columns = raidPtr->numCol;
			c_label.clean = RF_RAID_DIRTY; /* changed in a bit*/
			c_label.status = rf_ds_optimal;
d2351 1
a2351 1
				      &c_label);
d2362 1
a2362 1
rf_update_component_labels( raidPtr )
d2364 1
d2366 1
a2366 1
	RF_ComponentLabel_t c_label;
d2386 1
a2386 1
					&c_label);
d2388 4
a2391 1
				c_label.status = rf_ds_optimal;
d2395 8
a2402 6
					&c_label);
				if (raidPtr->parity_good == RF_RAID_CLEAN) {
					raidmarkclean( 
					      raidPtr->Disks[r][c].dev, 
					      raidPtr->raid_cinfo[r][c].ci_vp,
					      raidPtr->mod_counter);
a2405 22
#if 0
			else if (raidPtr->Disks[r][c].status !=
				   rf_ds_failed) {
				raidread_component_label(
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&c_label);
				/* make sure status is noted */
				c_label.status = 
					raidPtr->Disks[r][c].status;
				raidwrite_component_label( 
					raidPtr->Disks[r][c].dev,
					raidPtr->raid_cinfo[r][c].ci_vp,
					&c_label);
				if (raidPtr->parity_good == RF_RAID_CLEAN) {
					raidmarkclean( 
					      raidPtr->Disks[r][c].dev, 
					      raidPtr->raid_cinfo[r][c].ci_vp,
					      raidPtr->mod_counter);
				}
			}
#endif
d2434 1
d2438 1
a2438 1
				      &c_label);
d2440 8
a2447 9
			c_label.version = RF_COMPONENT_LABEL_VERSION; 
			c_label.mod_counter = raidPtr->mod_counter;
			c_label.serial_number = raidPtr->serial_number;
			c_label.row = srow;
			c_label.column = scol;
			c_label.num_rows = raidPtr->numRow;
			c_label.num_columns = raidPtr->numCol;
			c_label.clean = RF_RAID_DIRTY; /* changed in a bit*/
			c_label.status = rf_ds_optimal;
d2451 7
a2457 5
				      &c_label);
			if (raidPtr->parity_good == RF_RAID_CLEAN) {
				raidmarkclean( raidPtr->Disks[0][sparecol].dev,
			              raidPtr->raid_cinfo[0][sparecol].ci_vp,
					       raidPtr->mod_counter);
d2464 60
d2569 5
d2614 702
@


1.9.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_openbsdkintf.c,v 1.10 2000/08/08 16:07:43 peter Exp $	*/
/*	$NetBSD: rf_netbsdkintf.c,v 1.93 2000/07/14 15:26:29 oster Exp $	*/
a132 1
#include <sys/reboot.h>
a150 1
#include "rf_configure.h"
d175 1
a175 1
static void raidinit __P((RF_Raid_t *));
d202 2
a203 2
   or if it should be used in conjunction with that... 
*/
d208 1
d211 1
a211 1
	struct buf sc_q;		/* used for the device queue */
d222 1
a222 1
int numraid = 0;
a259 3
void rf_mountroot_hook __P((struct device *));

struct device *raidrootdev;
a266 24
#ifdef RAID_AUTOCONFIG
void rf_buildroothack __P((void *));
static int rf_reasonable_label __P((RF_ComponentLabel_t *));
#endif

RF_AutoConfig_t *rf_find_raid_components __P((void));
RF_ConfigSet_t *rf_create_auto_sets __P((RF_AutoConfig_t *));
static int rf_does_it_fit __P((RF_ConfigSet_t *,RF_AutoConfig_t *));
void rf_create_configuration __P((RF_AutoConfig_t *,RF_Config_t *,
				  RF_Raid_t *));
int rf_set_autoconfig __P((RF_Raid_t *, int));
int rf_set_rootpartition __P((RF_Raid_t *, int));
void rf_release_all_vps __P((RF_ConfigSet_t *));
void rf_cleanup_config_set __P((RF_ConfigSet_t *));
int rf_have_enough_components __P((RF_ConfigSet_t *));
int rf_auto_config_set __P((RF_ConfigSet_t *, int *));

#ifdef RAID_AUTOCONFIG
static int raidautoconfig = 0; /* Debugging, mostly.  Set to 0 to not
				  allow autoconfig to take place.
			          Note that this is overridden by having
			          RAID_AUTOCONFIG as an option in the 
			          kernel config file.  */
#endif
a273 4
#ifdef RAID_AUTOCONFIG
	RF_AutoConfig_t *ac_list; /* autoconfig list */
	RF_ConfigSet_t *config_sets;
#endif
a285 2
	numraid = num;

d299 1
a299 1
	for (i = 0; i < num; i++)
d313 1
a313 2
		malloc(num * sizeof(struct raid_softc),
		       M_RAIDFRAME, M_NOWAIT);
d318 1
a318 1

a320 6
	raidrootdev = (struct device *)malloc(num * sizeof(struct device),
					      M_RAIDFRAME, M_NOWAIT);
	if (raidrootdev == NULL) {
		panic("No memory for RAIDframe driver!!?!?!\n");
	}

d322 3
a324 11
#if 0
		SIMPLEQ_INIT(&raid_softc[raidID].sc_q);
#endif

		raidrootdev[raidID].dv_class  = DV_DISK;
		raidrootdev[raidID].dv_cfdata = NULL;
		raidrootdev[raidID].dv_unit   = raidID;
		raidrootdev[raidID].dv_parent = NULL;
		raidrootdev[raidID].dv_flags  = 0;
		sprintf(raidrootdev[raidID].dv_xname,"raid%d",raidID);

a332 85

#if RAID_AUTOCONFIG
	raidautoconfig = 1;

if (raidautoconfig) {
	/* 1. locate all RAID components on the system */

#if DEBUG
	printf("Searching for raid components...\n");
#endif
	ac_list = rf_find_raid_components();

	/* 2. sort them into their respective sets */

	config_sets = rf_create_auto_sets(ac_list);

	/* 3. evaluate each set and configure the valid ones
	   This gets done in rf_buildroothack() */

	/* schedule the creation of the thread to do the 
	   "/ on RAID" stuff */

	kthread_create(rf_buildroothack, config_sets, NULL, "raidauto");

#if 0
	mountroothook_establish(rf_mountroot_hook, &raidrootdev[0]);
#endif
}
#endif

}

#ifdef RAID_AUTOCONFIG
void
rf_buildroothack(arg)
	void *arg;
{
	RF_ConfigSet_t *config_sets = arg;
	RF_ConfigSet_t *cset;
	RF_ConfigSet_t *next_cset;
	int retcode;
	int raidID;
	int rootID;
	int num_root;

	num_root = 0;
	cset = config_sets;
	while(cset != NULL ) {
		next_cset = cset->next;
		if (rf_have_enough_components(cset) && 
		    cset->ac->clabel->autoconfigure==1) {
			retcode = rf_auto_config_set(cset,&raidID);
			if (!retcode) {
				if (cset->rootable) {
					rootID = raidID;
					num_root++;
				}
			} else {
				/* The autoconfig didn't work :( */
#if DEBUG
				printf("Autoconfig failed with code %d for raid%d\n", retcode, raidID);
#endif
				rf_release_all_vps(cset);
			}
		} else {
			/* we're not autoconfiguring this set...  
			   release the associated resources */
			rf_release_all_vps(cset);
		}
		/* cleanup */
		rf_cleanup_config_set(cset);
		cset = next_cset;
	}
	if (boothowto & RB_ASKNAME) {
		/* We don't auto-config... */
	} else {
		/* They didn't ask, and we found something bootable... */

		if (num_root == 1) {
			booted_device = &raidrootdev[rootID]; 
		} else if (num_root > 1) {
			/* we can't guess.. require the user to answer... */
			boothowto |= RB_ASKNAME;
		}
	}
a333 1
#endif
d499 1
a499 5
#if 0
		printf("Last one on raid%d.  Updating status.\n",unit);
#endif
		rf_update_component_labels(raidPtrs[unit],
						 RF_FINAL_COMPONENT_UPDATE);
d516 1
d566 1
a566 3
	bp->b_actf = rs->sc_q.b_actf;
	rs->sc_q.b_actf = bp;
	rs->sc_q.b_active++;
d568 6
a636 1
	RF_RaidDisk_t *diskPtr;
d644 1
a644 1
	RF_ComponentLabel_t *clabel;
d646 1
a646 1
	RF_ComponentLabel_t **clabel_ptr;
a649 1
	RF_ProgressInfo_t progressInfo, **progressInfoPtr;
a675 1
	case DIOCGPDINFO:
a685 1
	case RAIDFRAME_CHECK_RECON_STATUS_EXT:
a693 1
	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT:
a694 5
	case RAIDFRAME_CHECK_COPYBACK_STATUS_EXT:
	case RAIDFRAME_SET_AUTOCONFIG:
	case RAIDFRAME_SET_ROOT:
	case RAIDFRAME_DELETE_COMPONENT:
	case RAIDFRAME_INCORPORATE_HOT_SPARE:
a701 7

		if (raidPtr->valid) {
			/* There is a valid RAID set running on this unit! */
			printf("raid%d: Device already configured!\n",unit);
			return(EINVAL);
		}

a751 7
		/*
		 * Clear the entire RAID descriptor, just to make sure
		 *  there is no stale data left in the case of a 
		 *  reconfiguration 
		 */
		bzero((char *) raidPtr, sizeof(RF_Raid_t));

d755 1
a755 1
		retcode = rf_Configure(raidPtr, k_cfg, NULL);
d762 9
a770 3
					
			raidinit(raidPtr);
			rf_markalldirty(raidPtr);
d814 1
a814 1
		clabel_ptr = (RF_ComponentLabel_t **) data;
d816 1
a816 1
		   by row,column in clabel */
d820 1
a820 1
		RF_Malloc( clabel, sizeof( RF_ComponentLabel_t ),
d822 1
a822 1
		if (clabel == NULL)
d825 1
a825 1
		bzero((char *) clabel, sizeof(RF_ComponentLabel_t));
d827 1
a827 1
		retcode = copyin( *clabel_ptr, clabel, 
d831 1
a831 1
			RF_Free( clabel, sizeof(RF_ComponentLabel_t));
d835 2
a836 2
 		row = clabel->row;
		column = clabel->column;
d846 1
a846 1
			      clabel );
d848 2
a849 2
		retcode = copyout((caddr_t) clabel, 
				  (caddr_t) *clabel_ptr,
d851 1
a851 1
		RF_Free( clabel, sizeof(RF_ComponentLabel_t));
d855 1
a855 1
		clabel = (RF_ComponentLabel_t *) data;
d864 9
a872 9
		printf("Version: %d\n",clabel->version);
		printf("Serial Number: %d\n",clabel->serial_number);
		printf("Mod counter: %d\n",clabel->mod_counter);
		printf("Row: %d\n", clabel->row);
		printf("Column: %d\n", clabel->column);
		printf("Num Rows: %d\n", clabel->num_rows);
		printf("Num Columns: %d\n", clabel->num_columns);
		printf("Clean: %d\n", clabel->clean);
		printf("Status: %d\n", clabel->status);
d874 2
a875 2
		row = clabel->row;
		column = clabel->column;
d879 1
a879 1
			RF_Free( clabel, sizeof(RF_ComponentLabel_t));
d888 1
a888 1
			    clabel );
d893 1
a893 1
		clabel = (RF_ComponentLabel_t *) data;
d901 9
a909 4
		raidPtr->serial_number = clabel->serial_number;
		
		raid_init_component_label(raidPtr, &ci_label);
		ci_label.serial_number = clabel->serial_number;
a913 2
				diskPtr = &raidPtr->Disks[row][column];
				ci_label.partitionSize = diskPtr->partitionSize;
a942 11
	case RAIDFRAME_SET_AUTOCONFIG:
		d = rf_set_autoconfig(raidPtr, *(int *) data);
		printf("New autoconfig value is: %d\n", d);
		*(int *) data = d;
		return (retcode);

	case RAIDFRAME_SET_ROOT:
		d = rf_set_rootpartition(raidPtr, *(int *) data);
		printf("New rootpartition value is: %d\n", d);
		*(int *) data = d;
		return (retcode);
d948 1
a954 14
	case RAIDFRAME_DELETE_COMPONENT:
		componentPtr = (RF_SingleComponent_t *)data;
		memcpy( &component, componentPtr, 
			sizeof(RF_SingleComponent_t));
		retcode = rf_delete_component(raidPtr, &component);
		return(retcode);

	case RAIDFRAME_INCORPORATE_HOT_SPARE:
		componentPtr = (RF_SingleComponent_t *)data;
		memcpy( &component, componentPtr, 
			sizeof(RF_SingleComponent_t));
		retcode = rf_incorporate_hot_spare(raidPtr, &component);
		return(retcode);

d1099 2
a1100 4
			/* This makes no sense on a RAID 0, so tell the
			   user it's done. */
			*(int *) data = 100;
			return(0);
a1108 21

	case RAIDFRAME_CHECK_RECON_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		row = 0; /* XXX we only consider a single row... */
		if (raidPtr->status[row] != rf_rs_reconstructing) {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		} else {
			progressInfo.total = 
				raidPtr->reconControl[row]->numRUsTotal;
			progressInfo.completed = 
				raidPtr->reconControl[row]->numRUsComplete;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

d1111 2
a1112 4
			/* This makes no sense on a RAID 0, so tell the
			   user it's done. */
			*(int *) data = 100;
			return(0);
d1115 1
a1115 3
			*(int *) data = 100 * 
				raidPtr->parity_rewrite_stripes_done / 
				raidPtr->Layout.numStripe;
a1120 18
	case RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		if (raidPtr->parity_rewrite_in_progress == 1) {
			progressInfo.total = raidPtr->Layout.numStripe;
			progressInfo.completed = 
				raidPtr->parity_rewrite_stripes_done;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		} else {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

d1124 1
a1124 2
			*(int *) data = 100;
			return(0);
a1132 18
	case RAIDFRAME_CHECK_COPYBACK_STATUS_EXT:
		progressInfoPtr = (RF_ProgressInfo_t **) data;
		if (raidPtr->copyback_in_progress == 1) {
			progressInfo.total = raidPtr->Layout.numStripe;
			progressInfo.completed = 
				raidPtr->copyback_stripes_done;
			progressInfo.remaining = progressInfo.total -
				progressInfo.completed;
		} else {
			progressInfo.remaining = 0;
			progressInfo.completed = 100;
			progressInfo.total = 100;
		}
		retcode = copyout((caddr_t) &progressInfo,
				  (caddr_t) *progressInfoPtr,
				  sizeof(RF_ProgressInfo_t));
		return (retcode);

a1252 2
#endif
	case DIOCGPDINFO:
d1256 1
d1269 3
a1271 2
static void
raidinit(raidPtr)
d1273 1
d1275 1
a1276 1
	int     unit;
d1278 1
a1278 1
	unit = raidPtr->raidid;
d1302 2
d1364 1
d1369 1
a1369 9
	/* quick check to see if anything has died recently */
	RF_LOCK_MUTEX(raidPtr->mutex);
	if (raidPtr->numNewFailures > 0) {
		rf_update_component_labels(raidPtr, 
					   RF_NORMAL_COMPONENT_UPDATE);
		raidPtr->numNewFailures--;
	}
	RF_UNLOCK_MUTEX(raidPtr->mutex);

d1375 3
a1377 1
		bp = rs->sc_q.b_actf;
d1382 10
a1391 2
		rs->sc_q.b_actf = bp->b_actf;

d1460 1
d1464 1
a1464 1
				      bp->b_data, bp, NULL, NULL, 
d1467 1
d1674 1
a1674 1
			queue->raidPtr->numNewFailures++;
d1719 1
a1719 1
	bp->b_data = buf;
d1764 1
a1780 2
	int i;
	struct partition *pp;
d1793 7
a1799 7
	errstring = readdisklabel(RAIDLABELDEV(dev), raidstrategy, lp,
	    rs->sc_dkdev.dk_cpulabel, 0);
	if (errstring) {
		printf("%s: %s\n", rs->sc_xname, errstring);
		return;
		/*raidmakedisklabel(rs); */
	}
d1801 20
a1820 19
	/*
	 * Sanity check whether the found disklabel is valid.
	 *
	 * This is necessary since total size of the raid device
	 * may vary when an interleave is changed even though exactly
	 * same componets are used, and old disklabel may used
	 * if that is found.
	 */
	if (lp->d_secperunit != rs->sc_size)
		printf("WARNING: %s: "
		    "total sector size in disklabel (%d) != "
		    "the size of raid (%ld)\n", rs->sc_xname,
		    lp->d_secperunit, (long) rs->sc_size);
	for (i = 0; i < lp->d_npartitions; i++) {
		pp = &lp->d_partitions[i];
		if (pp->p_offset + pp->p_size > rs->sc_size)
			printf("WARNING: %s: end of partition `%c' "
			    "exceeds the size of raid (%ld)\n",
			    rs->sc_xname, 'a' + i, (long) rs->sc_size);
d1936 5
a1940 5
	RF_ComponentLabel_t clabel;
	raidread_component_label(dev, b_vp, &clabel);
	clabel.mod_counter = mod_counter;
	clabel.clean = RF_RAID_CLEAN;
	raidwrite_component_label(dev, b_vp, &clabel);
d1948 5
a1952 5
	RF_ComponentLabel_t clabel;
	raidread_component_label(dev, b_vp, &clabel);
	clabel.mod_counter = mod_counter;
	clabel.clean = RF_RAID_DIRTY;
	raidwrite_component_label(dev, b_vp, &clabel);
d1958 1
a1958 1
raidread_component_label(dev, b_vp, clabel)
d1961 1
a1961 1
	RF_ComponentLabel_t *clabel;
d1984 1
a1984 1
		memcpy(clabel, bp->b_data,
d1987 10
a1996 1
		rf_print_component_label( clabel );
a1998 1
#if 0
a1999 1
#endif
d2008 1
a2008 1
raidwrite_component_label(dev, b_vp, clabel)
d2011 1
a2011 1
	RF_ComponentLabel_t *clabel;
d2026 1
a2026 1
	memset(bp->b_data, 0, RF_COMPONENT_INFO_SIZE );
d2028 1
a2028 1
	memcpy(bp->b_data, clabel, sizeof(RF_ComponentLabel_t));
a2034 1
#if 1
a2035 1
#endif
d2042 1
a2042 1
rf_markalldirty(raidPtr)
d2045 1
a2045 1
	RF_ComponentLabel_t clabel;
d2055 2
a2056 2
					&clabel);
				if (clabel.status == rf_ds_spared) {
d2062 1
a2062 1
				clabel.status = 
d2067 1
a2067 1
					&clabel);
d2113 1
a2113 1
				      &clabel);
d2115 9
a2123 9
			clabel.version = RF_COMPONENT_LABEL_VERSION; 
			clabel.mod_counter = raidPtr->mod_counter;
			clabel.serial_number = raidPtr->serial_number;
			clabel.row = srow;
			clabel.column = scol;
			clabel.num_rows = raidPtr->numRow;
			clabel.num_columns = raidPtr->numCol;
			clabel.clean = RF_RAID_DIRTY; /* changed in a bit*/
			clabel.status = rf_ds_optimal;
d2127 1
a2127 1
				      &clabel);
d2138 1
a2138 1
rf_update_component_labels(raidPtr, final)
a2139 1
	int final;
d2141 1
a2141 1
	RF_ComponentLabel_t clabel;
d2161 1
a2161 1
					&clabel);
d2163 1
a2163 4
				clabel.status = rf_ds_optimal;
				/* bump the counter */
				clabel.mod_counter = raidPtr->mod_counter;

d2167 6
a2172 8
					&clabel);
				if (final == RF_FINAL_COMPONENT_UPDATE) {
					if (raidPtr->parity_good == RF_RAID_CLEAN) {
						raidmarkclean( 
							      raidPtr->Disks[r][c].dev, 
							      raidPtr->raid_cinfo[r][c].ci_vp,
							      raidPtr->mod_counter);
					}
d2176 22
a2225 1
			/* XXX shouldn't *really* need this... */
d2229 1
a2229 1
				      &clabel);
d2231 9
a2239 8

			raid_init_component_label(raidPtr, &clabel);

			clabel.mod_counter = raidPtr->mod_counter;
			clabel.row = srow;
			clabel.column = scol;
			clabel.status = rf_ds_optimal;

d2243 5
a2247 7
				      &clabel);
			if (final == RF_FINAL_COMPONENT_UPDATE) {
				if (raidPtr->parity_good == RF_RAID_CLEAN) {
					raidmarkclean( raidPtr->Disks[0][sparecol].dev,
						       raidPtr->raid_cinfo[0][sparecol].ci_vp,
						       raidPtr->mod_counter);
				}
a2253 60
void
rf_close_component(raidPtr, vp, auto_configured)
	RF_Raid_t *raidPtr;
	struct vnode *vp;
	int auto_configured;
{
	struct proc *p;

	p = raidPtr->engine_thread;

	if (vp != NULL) {
		if (auto_configured == 1) {
			VOP_CLOSE(vp, FREAD, NOCRED, 0);
			vput(vp);
			
		} else {				
			VOP_UNLOCK(vp, 0, p);
			(void) vn_close(vp, FREAD | FWRITE, p->p_ucred, p);
		}
	} else {
		printf("vnode was NULL\n");
	}
}


void
rf_UnconfigureVnodes(raidPtr)
	RF_Raid_t *raidPtr;
{
	int r,c; 
	struct proc *p;
	struct vnode *vp;
	int acd;


	/* We take this opportunity to close the vnodes like we should.. */

	p = raidPtr->engine_thread;

	for (r = 0; r < raidPtr->numRow; r++) {
		for (c = 0; c < raidPtr->numCol; c++) {
			printf("Closing vnode for row: %d col: %d\n", r, c);
			vp = raidPtr->raid_cinfo[r][c].ci_vp;
			acd = raidPtr->Disks[r][c].auto_configured;
			rf_close_component(raidPtr, vp, acd);
			raidPtr->raid_cinfo[r][c].ci_vp = NULL;
			raidPtr->Disks[r][c].auto_configured = 0;
		}
	}
	for (r = 0; r < raidPtr->numSpare; r++) {
		printf("Closing vnode for spare: %d\n", r);
		vp = raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp;
		acd = raidPtr->Disks[0][raidPtr->numCol + r].auto_configured;
		rf_close_component(raidPtr, vp, acd);
		raidPtr->raid_cinfo[0][raidPtr->numCol + r].ci_vp = NULL;
		raidPtr->Disks[0][raidPtr->numCol + r].auto_configured = 0;
	}
}


a2298 5
	/* Anyone waiting for us to stop?  If so, inform them... */
	if (raidPtr->waitShutdown) {
		wakeup(&raidPtr->parity_rewrite_in_progress);
	}

a2338 702
}

void
rf_mountroot_hook(dev)
	struct device *dev;
{

}


RF_AutoConfig_t *
rf_find_raid_components()
{
#ifdef RAID_AUTOCONFIG
	struct devnametobdevmaj *dtobdm;
	struct vnode *vp;
	struct disklabel label;
	struct device *dv;
	char *cd_name;
	dev_t dev;
	int error;
	int i;
	int good_one;
	RF_ComponentLabel_t *clabel;
	RF_AutoConfig_t *ac;
#endif
	RF_AutoConfig_t *ac_list;


	/* initialize the AutoConfig list */
	ac_list = NULL;

#if RAID_AUTOCONFIG
if (raidautoconfig) {

	/* we begin by trolling through *all* the devices on the system */

	for (dv = alldevs.tqh_first; dv != NULL;
	     dv = dv->dv_list.tqe_next) {

		/* we are only interested in disks... */
		if (dv->dv_class != DV_DISK)
			continue;

		/* we don't care about floppies... */
		if (!strcmp(dv->dv_cfdata->cf_driver->cd_name,"fd")) {
			continue;
		}
		
		/* need to find the device_name_to_block_device_major stuff */
		cd_name = dv->dv_cfdata->cf_driver->cd_name;
		dtobdm = dev_name2blk;
		while (dtobdm->d_name && strcmp(dtobdm->d_name, cd_name)) {
			dtobdm++;
		}

		/* get a vnode for the raw partition of this disk */

		dev = MAKEDISKDEV(dtobdm->d_maj, dv->dv_unit, RAW_PART);
		if (bdevvp(dev, &vp))
			panic("RAID can't alloc vnode");

		error = VOP_OPEN(vp, FREAD, NOCRED, 0);

		if (error) {
			/* "Who cares."  Continue looking 
			   for something that exists*/
			vput(vp);
			continue;
		}

		/* Ok, the disk exists.  Go get the disklabel. */
		error = VOP_IOCTL(vp, DIOCGDINFO, (caddr_t)&label, 
				  FREAD, NOCRED, 0);
		if (error) {
			/*
			 * XXX can't happen - open() would
			 * have errored out (or faked up one)
			 */
			printf("can't get label for dev %s%c (%d)!?!?\n",
			       dv->dv_xname, 'a' + RAW_PART, error);
		}

		/* don't need this any more.  We'll allocate it again
		   a little later if we really do... */
		VOP_CLOSE(vp, FREAD, NOCRED, 0);
		vput(vp);

		for (i=0; i < label.d_npartitions; i++) {
			/* We only support partitions marked as RAID */
			if (label.d_partitions[i].p_fstype != FS_RAID)
				continue;

			dev = MAKEDISKDEV(dtobdm->d_maj, dv->dv_unit, i);
			if (bdevvp(dev, &vp))
				panic("RAID can't alloc vnode");

			error = VOP_OPEN(vp, FREAD, NOCRED, 0);
			if (error) {
				/* Whatever... */
				vput(vp);
				continue;
			}

			good_one = 0;

			clabel = (RF_ComponentLabel_t *) 
				malloc(sizeof(RF_ComponentLabel_t), 
				       M_RAIDFRAME, M_NOWAIT);
			if (clabel == NULL) {
				/* XXX CLEANUP HERE */
				printf("RAID auto config: out of memory!\n");
				return(NULL); /* XXX probably should panic? */
			}

			if (!raidread_component_label(dev, vp, clabel)) {
				/* Got the label.  Does it look reasonable? */
				if (rf_reasonable_label(clabel) &&
				    (clabel->partitionSize <= 
				     label.d_partitions[i].p_size)) {
#if DEBUG
					printf("Component on: %s%c: %d\n", 
					       dv->dv_xname, 'a'+i,
					       label.d_partitions[i].p_size);
					rf_print_component_label(clabel);
#endif
					/* if it's reasonable, add it, 
					   else ignore it. */
					ac = (RF_AutoConfig_t *)
						malloc(sizeof(RF_AutoConfig_t),
						       M_RAIDFRAME,
						       M_NOWAIT);
					if (ac == NULL) {
						/* XXX should panic?? */
						return(NULL);
					}
					
					sprintf(ac->devname, "%s%c",
						dv->dv_xname, 'a'+i);
					ac->dev = dev;
					ac->vp = vp;
					ac->clabel = clabel;
					ac->next = ac_list;
					ac_list = ac;
					good_one = 1;
				} 
			}
			if (!good_one) {
				/* cleanup */
				free(clabel, M_RAIDFRAME);
				VOP_CLOSE(vp, FREAD, NOCRED, 0);
				vput(vp);
			}
		}
	}
}
#endif
return(ac_list);
}
			
#ifdef RAID_AUTOCONFIG
static int
rf_reasonable_label(clabel)
	RF_ComponentLabel_t *clabel;
{
	
	if (((clabel->version==RF_COMPONENT_LABEL_VERSION_1) ||
	     (clabel->version==RF_COMPONENT_LABEL_VERSION)) &&
	    ((clabel->clean == RF_RAID_CLEAN) ||
	     (clabel->clean == RF_RAID_DIRTY)) &&
	    clabel->row >=0 && 
	    clabel->column >= 0 && 
	    clabel->num_rows > 0 &&
	    clabel->num_columns > 0 &&
	    clabel->row < clabel->num_rows && 
	    clabel->column < clabel->num_columns &&
	    clabel->blockSize > 0 &&
	    clabel->numBlocks > 0) {
		/* label looks reasonable enough... */
		return(1);
	}
	return(0);
}
#endif

void
rf_print_component_label(clabel)
	RF_ComponentLabel_t *clabel;
{
	printf("   Row: %d Column: %d Num Rows: %d Num Columns: %d\n",
	       clabel->row, clabel->column, 
	       clabel->num_rows, clabel->num_columns);
	printf("   Version: %d Serial Number: %d Mod Counter: %d\n",
	       clabel->version, clabel->serial_number,
	       clabel->mod_counter);
	printf("   Clean: %s Status: %d\n",
	       clabel->clean ? "Yes" : "No", clabel->status );
	printf("   sectPerSU: %d SUsPerPU: %d SUsPerRU: %d\n",
	       clabel->sectPerSU, clabel->SUsPerPU, clabel->SUsPerRU);
	printf("   RAID Level: %c  blocksize: %d numBlocks: %d\n",
	       (char) clabel->parityConfig, clabel->blockSize, 
	       clabel->numBlocks);
	printf("   Autoconfig: %s\n", clabel->autoconfigure ? "Yes" : "No" );
	printf("   Contains root partition: %s\n",  
	       clabel->root_partition ? "Yes" : "No" );
	printf("   Last configured as: raid%d\n", clabel->last_unit );
#if 0
	   printf("   Config order: %d\n", clabel->config_order);
#endif
	       
}

RF_ConfigSet_t *
rf_create_auto_sets(ac_list)
	RF_AutoConfig_t *ac_list;
{
	RF_AutoConfig_t *ac;
	RF_ConfigSet_t *config_sets;
	RF_ConfigSet_t *cset;
	RF_AutoConfig_t *ac_next;


	config_sets = NULL;

	/* Go through the AutoConfig list, and figure out which components
	   belong to what sets.  */
	ac = ac_list;
	while(ac!=NULL) {
		/* we're going to putz with ac->next, so save it here
		   for use at the end of the loop */
		ac_next = ac->next;

		if (config_sets == NULL) {
			/* will need at least this one... */
			config_sets = (RF_ConfigSet_t *)
				malloc(sizeof(RF_ConfigSet_t), 
				       M_RAIDFRAME, M_NOWAIT);
			if (config_sets == NULL) {
				panic("rf_create_auto_sets: No memory!\n");
			}
			/* this one is easy :) */
			config_sets->ac = ac;
			config_sets->next = NULL;
			config_sets->rootable = 0;
			ac->next = NULL;
		} else {
			/* which set does this component fit into? */
			cset = config_sets;
			while(cset!=NULL) {
				if (rf_does_it_fit(cset, ac)) {
					/* looks like it matches... */
					ac->next = cset->ac;
					cset->ac = ac;
					break;
				}
				cset = cset->next;
			}
			if (cset==NULL) {
				/* didn't find a match above... new set..*/
				cset = (RF_ConfigSet_t *)
					malloc(sizeof(RF_ConfigSet_t), 
					       M_RAIDFRAME, M_NOWAIT);
				if (cset == NULL) {
					panic("rf_create_auto_sets: No memory!\n");
				}
				cset->ac = ac;
				ac->next = NULL;
				cset->next = config_sets;
				cset->rootable = 0;
				config_sets = cset;
			}
		}
		ac = ac_next;
	}


	return(config_sets);
}

static int
rf_does_it_fit(cset, ac)	
	RF_ConfigSet_t *cset;
	RF_AutoConfig_t *ac;
{
	RF_ComponentLabel_t *clabel1, *clabel2;

	/* If this one matches the *first* one in the set, that's good
	   enough, since the other members of the set would have been
	   through here too... */
	/* note that we are not checking partitionSize here..

	   Note that we are also not checking the mod_counters here.
	   If everything else matches execpt the mod_counter, that's 
	   good enough for this test.  We will deal with the mod_counters
	   a little later in the autoconfiguration process.  

	    (clabel1->mod_counter == clabel2->mod_counter) &&

	   The reason we don't check for this is that failed disks
	   will have lower modification counts.  If those disks are
	   not added to the set they used to belong to, then they will
	   form their own set, which may result in 2 different sets,
	   for example, competing to be configured at raid0, and
	   perhaps competing to be the root filesystem set.  If the
	   wrong ones get configured, or both attempt to become /,
	   weird behaviour and or serious lossage will occur.  Thus we
	   need to bring them into the fold here, and kick them out at
	   a later point.

	*/

	clabel1 = cset->ac->clabel;
	clabel2 = ac->clabel;
	if ((clabel1->version == clabel2->version) &&
	    (clabel1->serial_number == clabel2->serial_number) &&
	    (clabel1->num_rows == clabel2->num_rows) &&
	    (clabel1->num_columns == clabel2->num_columns) &&
	    (clabel1->sectPerSU == clabel2->sectPerSU) &&
	    (clabel1->SUsPerPU == clabel2->SUsPerPU) &&
	    (clabel1->SUsPerRU == clabel2->SUsPerRU) &&
	    (clabel1->parityConfig == clabel2->parityConfig) &&
	    (clabel1->maxOutstanding == clabel2->maxOutstanding) &&
	    (clabel1->blockSize == clabel2->blockSize) &&
	    (clabel1->numBlocks == clabel2->numBlocks) &&
	    (clabel1->autoconfigure == clabel2->autoconfigure) &&
	    (clabel1->root_partition == clabel2->root_partition) &&
	    (clabel1->last_unit == clabel2->last_unit) &&
	    (clabel1->config_order == clabel2->config_order)) {
		/* if it get's here, it almost *has* to be a match */
	} else {
		/* it's not consistent with somebody in the set.. 
		   punt */
		return(0);
	}
	/* all was fine.. it must fit... */
	return(1);
}

int
rf_have_enough_components(cset)
	RF_ConfigSet_t *cset;
{
	RF_AutoConfig_t *ac;
	RF_AutoConfig_t *auto_config;
	RF_ComponentLabel_t *clabel;
	int r,c;
	int num_rows;
	int num_cols;
	int num_missing;
	int mod_counter;
	int mod_counter_found;
	int even_pair_failed;
	char parity_type;
	

	/* check to see that we have enough 'live' components
	   of this set.  If so, we can configure it if necessary */

	num_rows = cset->ac->clabel->num_rows;
	num_cols = cset->ac->clabel->num_columns;
	parity_type = cset->ac->clabel->parityConfig;

	/* XXX Check for duplicate components!?!?!? */

	/* Determine what the mod_counter is supposed to be for this set. */

	mod_counter_found = 0;
	ac = cset->ac;
	while(ac!=NULL) {
		if (mod_counter_found==0) {
			mod_counter = ac->clabel->mod_counter;
			mod_counter_found = 1;
		} else {
			if (ac->clabel->mod_counter > mod_counter) {
				mod_counter = ac->clabel->mod_counter;
			}
		}
		ac = ac->next;
	}

	num_missing = 0;
	auto_config = cset->ac;

	for(r=0; r<num_rows; r++) {
		even_pair_failed = 0;
		for(c=0; c<num_cols; c++) {
			ac = auto_config;
			while(ac!=NULL) {
				if ((ac->clabel->row == r) &&
				    (ac->clabel->column == c) && 
				    (ac->clabel->mod_counter == mod_counter)) {
					/* it's this one... */
#if DEBUG
					printf("Found: %s at %d,%d\n",
					       ac->devname,r,c);
#endif
					break;
				}
				ac=ac->next;
			}
			if (ac==NULL) {
				/* Didn't find one here! */
				/* special case for RAID 1, especially
				   where there are more than 2
				   components (where RAIDframe treats
				   things a little differently :( ) */
				if (parity_type == '1') {
					if (c%2 == 0) { /* even component */
						even_pair_failed = 1;
					} else { /* odd component.  If
                                                    we're failed, and
                                                    so is the even
                                                    component, it's
                                                    "Good Night, Charlie" */
						if (even_pair_failed == 1) {
							return(0);
						}
					}
				} else {
					/* normal accounting */
					num_missing++;
				}
			}
			if ((parity_type == '1') && (c%2 == 1)) {
				/* Just did an even component, and we didn't
				   bail.. reset the even_pair_failed flag, 
				   and go on to the next component.... */
				even_pair_failed = 0;
			}
		}
	}

	clabel = cset->ac->clabel;

	if (((clabel->parityConfig == '0') && (num_missing > 0)) ||
	    ((clabel->parityConfig == '4') && (num_missing > 1)) ||
	    ((clabel->parityConfig == '5') && (num_missing > 1))) {
		/* XXX this needs to be made *much* more general */
		/* Too many failures */
		return(0);
	}
	/* otherwise, all is well, and we've got enough to take a kick
	   at autoconfiguring this set */
	return(1);
}

void
rf_create_configuration(ac,config,raidPtr)
	RF_AutoConfig_t *ac;
	RF_Config_t *config;
	RF_Raid_t *raidPtr;
{
	RF_ComponentLabel_t *clabel;
	int i;

	clabel = ac->clabel;

	/* 1. Fill in the common stuff */
	config->numRow = clabel->num_rows;
	config->numCol = clabel->num_columns;
	config->numSpare = 0; /* XXX should this be set here? */
	config->sectPerSU = clabel->sectPerSU;
	config->SUsPerPU = clabel->SUsPerPU;
	config->SUsPerRU = clabel->SUsPerRU;
	config->parityConfig = clabel->parityConfig;
	/* XXX... */
	strcpy(config->diskQueueType,"fifo");
	config->maxOutstandingDiskReqs = clabel->maxOutstanding;
	config->layoutSpecificSize = 0; /* XXX ?? */

	while(ac!=NULL) {
		/* row/col values will be in range due to the checks
		   in reasonable_label() */
		strcpy(config->devnames[ac->clabel->row][ac->clabel->column],
		       ac->devname);
		ac = ac->next;
	}

	for(i=0;i<RF_MAXDBGV;i++) {
		config->debugVars[i][0] = NULL;
	}
}

int
rf_set_autoconfig(raidPtr, new_value)
	RF_Raid_t *raidPtr;
	int new_value;
{
	RF_ComponentLabel_t clabel;
	struct vnode *vp;
	dev_t dev;
	int row, column;

	raidPtr->autoconfigure = new_value;
	for(row=0; row<raidPtr->numRow; row++) {
		for(column=0; column<raidPtr->numCol; column++) {
			if (raidPtr->Disks[row][column].status == 
			    rf_ds_optimal) {
				dev = raidPtr->Disks[row][column].dev;
				vp = raidPtr->raid_cinfo[row][column].ci_vp;
				raidread_component_label(dev, vp, &clabel);
				clabel.autoconfigure = new_value;
				raidwrite_component_label(dev, vp, &clabel);
			}
		}
	}
	return(new_value);
}

int
rf_set_rootpartition(raidPtr, new_value)
	RF_Raid_t *raidPtr;
	int new_value;
{
	RF_ComponentLabel_t clabel;
	struct vnode *vp;
	dev_t dev;
	int row, column;

	raidPtr->root_partition = new_value;
	for(row=0; row<raidPtr->numRow; row++) {
		for(column=0; column<raidPtr->numCol; column++) {
			if (raidPtr->Disks[row][column].status == 
			    rf_ds_optimal) {
				dev = raidPtr->Disks[row][column].dev;
				vp = raidPtr->raid_cinfo[row][column].ci_vp;
				raidread_component_label(dev, vp, &clabel);
				clabel.root_partition = new_value;
				raidwrite_component_label(dev, vp, &clabel);
			}
		}
	}
	return(new_value);
}

void
rf_release_all_vps(cset)
	RF_ConfigSet_t *cset;
{
	RF_AutoConfig_t *ac;
	
	ac = cset->ac;
	while(ac!=NULL) {
		/* Close the vp, and give it back */
		if (ac->vp) {
			VOP_CLOSE(ac->vp, FREAD, NOCRED, 0);
			vput(ac->vp);
			ac->vp = NULL;
		}
		ac = ac->next;
	}
}


void
rf_cleanup_config_set(cset)
	RF_ConfigSet_t *cset;
{
	RF_AutoConfig_t *ac;
	RF_AutoConfig_t *next_ac;
	
	ac = cset->ac;
	while(ac!=NULL) {
		next_ac = ac->next;
		/* nuke the label */
		free(ac->clabel, M_RAIDFRAME);
		/* cleanup the config structure */
		free(ac, M_RAIDFRAME);
		/* "next.." */
		ac = next_ac;
	}
	/* and, finally, nuke the config set */
	free(cset, M_RAIDFRAME);
}


void
raid_init_component_label(raidPtr, clabel)
	RF_Raid_t *raidPtr;
	RF_ComponentLabel_t *clabel;
{
	/* current version number */
	clabel->version = RF_COMPONENT_LABEL_VERSION; 
	clabel->serial_number = raidPtr->serial_number;
	clabel->mod_counter = raidPtr->mod_counter;
	clabel->num_rows = raidPtr->numRow;
	clabel->num_columns = raidPtr->numCol;
	clabel->clean = RF_RAID_DIRTY; /* not clean */
	clabel->status = rf_ds_optimal; /* "It's good!" */
	
	clabel->sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	clabel->SUsPerPU = raidPtr->Layout.SUsPerPU;
	clabel->SUsPerRU = raidPtr->Layout.SUsPerRU;

	clabel->blockSize = raidPtr->bytesPerSector;
	clabel->numBlocks = raidPtr->sectorsPerDisk;

	/* XXX not portable */
	clabel->parityConfig = raidPtr->Layout.map->parityConfig;
	clabel->maxOutstanding = raidPtr->maxOutstanding;
	clabel->autoconfigure = raidPtr->autoconfigure;
	clabel->root_partition = raidPtr->root_partition;
	clabel->last_unit = raidPtr->raidid;
	clabel->config_order = raidPtr->config_order;
}

int
rf_auto_config_set(cset,unit)
	RF_ConfigSet_t *cset;
	int *unit;
{
	RF_Raid_t *raidPtr;
	RF_Config_t *config;
	int raidID;
	int retcode;

	printf("RAID autoconfigure\n");

	retcode = 0;
	*unit = -1;

	/* 1. Create a config structure */

	config = (RF_Config_t *)malloc(sizeof(RF_Config_t),
				       M_RAIDFRAME,
				       M_NOWAIT);
	if (config==NULL) {
		printf("Out of mem!?!?\n");
				/* XXX do something more intelligent here. */
		return(1);
	}

	memset(config, 0, sizeof(RF_Config_t));

	/* XXX raidID needs to be set correctly.. */

	/* 
	   2. Figure out what RAID ID this one is supposed to live at 
	   See if we can get the same RAID dev that it was configured
	   on last time.. 
	*/

	raidID = cset->ac->clabel->last_unit;
	if ((raidID < 0) || (raidID >= numraid)) {
		/* let's not wander off into lala land. */
		raidID = numraid - 1;
	}
	if (raidPtrs[raidID]->valid != 0) {

		/* 
		   Nope... Go looking for an alternative...  
		   Start high so we don't immediately use raid0 if that's
		   not taken. 
		*/

		for(raidID = numraid; raidID >= 0; raidID--) {
			if (raidPtrs[raidID]->valid == 0) {
				/* can use this one! */
				break;
			}
		}
	}

	if (raidID < 0) {
		/* punt... */
		printf("Unable to auto configure this set!\n");
		printf("(Out of RAID devs!)\n");
		return(1);
	}
	printf("Configuring raid%d:\n",raidID);
	raidPtr = raidPtrs[raidID];

	/* XXX all this stuff should be done SOMEWHERE ELSE! */
	raidPtr->raidid = raidID;
	raidPtr->openings = RAIDOUTSTANDING;

	/* 3. Build the configuration structure */
	rf_create_configuration(cset->ac, config, raidPtr);

	/* 4. Do the configuration */
	retcode = rf_Configure(raidPtr, config, cset->ac);
	
	if (retcode == 0) {

		raidinit(raidPtrs[raidID]);

		rf_markalldirty(raidPtrs[raidID]);
		raidPtrs[raidID]->autoconfigure = 1; /* XXX do this here? */
		if (cset->ac->clabel->root_partition==1) {
			/* everything configured just fine.  Make a note
			   that this set is eligible to be root. */
			cset->rootable = 1;
			/* XXX do this here? */
			raidPtrs[raidID]->root_partition = 1; 
		}
	}

	/* 5. Cleanup */
	free(config, M_RAIDFRAME);
	
	*unit = raidID;
	return(retcode);
@


1.9.2.2
log
@Merge in trunk
@
text
@d1 2
a2 2
/* $OpenBSD$	*/
/* $NetBSD: rf_netbsdkintf.c,v 1.109 2001/07/27 03:30:07 oster Exp $	*/
a119 1
#include <sys/pool.h>
a140 1
#include "rf_desc.h"
d177 1
a177 1
void raidinit __P((RF_Raid_t *));
d199 2
a200 11
#define RAIDGETBUF(rs)		pool_get(&(rs)->sc_cbufpool, PR_NOWAIT)
#define RAIDPUTBUF(rs, cbp)	pool_put(&(rs)->sc_cbufpool, cbp)

/*
 * Some port (like i386) use a swapgeneric that wants to snoop around
 * in this raid_cd structure.  It is preserved (for now) to remain
 * compatible with such practice.
 */
struct cfdriver raid_cd = {
	NULL, "raid", DV_DISK, NULL, 0
};
d204 2
a205 2
 * or if it should be used in conjunction with that... 
 */
a211 1
	struct pool sc_cbufpool;	/* component buffer pool */
a225 16
 * Here we define a cfattach structure for inserting any new raid device
 * into the device tree.  This is needed by some archs that look for
 * bootable devices in there.
 */
int	rf_probe	__P((struct device *, void *, void *));
void	rf_attach	__P((struct device *, struct device *, void *));
int	rf_detach	__P((struct device *, int));
int	rf_activate	__P((struct device *, enum devact));
void	rf_zeroref	__P((struct device *));

struct cfattach raid_ca = {
	sizeof(struct raid_softc), rf_probe, rf_attach,
	rf_detach, rf_activate, rf_zeroref
};

/*
a250 1
struct raid_softc **raid_scPtrs;
a264 3
int findblkmajor __P((struct device *dv));
char *findblkname __P((int));

d273 1
a273 1
int rf_reasonable_label __P((RF_ComponentLabel_t *));
d278 1
a278 1
int rf_does_it_fit __P((RF_ConfigSet_t *,RF_AutoConfig_t *));
a295 39
int
rf_probe(parent, match_, aux)
	struct device *parent;
	void *match_;
	void *aux;
{
	return 0;
}

void
rf_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	/* struct raid_softc *raid = (void *)self; */
}

int
rf_detach(self, flags)
	struct device *self;
	int flags;
{
	return 0;
}

int
rf_activate(self, act)
	struct device *self;
	enum devact act;
{
	return 0;
}

void
rf_zeroref(self)
	struct device *self;
{
}

a355 10
	raid_scPtrs = (struct raid_softc **)
		malloc(num * sizeof(struct raid_softc *),
		       M_RAIDFRAME, M_NOWAIT);
	if (raid_scPtrs == NULL) {
		printf("WARNING: no memory for RAIDframe driver\n");
		return;
	}

	bzero(raid_scPtrs, num * sizeof (struct raid_softc *));

d383 1
a383 4
	raid_cd.cd_devs = (void **) raid_scPtrs;
	raid_cd.cd_ndevs = num;

#ifdef RAID_AUTOCONFIG
d389 1
a389 1
#ifdef DEBUG
d404 1
a404 1
	rf_buildroothack(config_sets);
a425 1
	int majdev;
a426 1
	rootID = 0;
a436 3
#ifdef DEBUG
					printf("eligible root device %d: raid%d\n", num_root, rootID);
#endif /* DEBUG */
d441 1
a441 1
#ifdef DEBUG
d461 1
a461 7
			majdev = findblkmajor(&raidrootdev[rootID]);
			if (majdev < 0)
				boothowto |= RB_ASKNAME;
			else {
				rootdev = MAKEDISKDEV(majdev,rootID,0); 
				boothowto |= RB_DFLTROOT;
			}
a638 18
#if 0
		if (doing_shutdown) {
/* #endif */
			/* last one, and we're going down, so
			   lights out for this RAID set too. */
			error = rf_Shutdown(raidPtrs[unit]);
			pool_destroy(&rs->sc_cbufpool);
			
			/* It's no longer initialized... */
			rs->sc_flags &= ~RAIDF_INITED;
			
			/* config_detach the device. */
			config_detach(device_lookup(&raid_cd, unit), 0);

			disk_detach(&rs->sc_dkdev);
/* #if 0 */
		}
#endif
d659 1
a659 1
		bp->b_flags |= B_ERROR;
a954 2
		pool_destroy(&rs->sc_cbufpool);

a957 3
		/* config_detach the device. */
		config_detach(device_lookup(&raid_cd, unit), 0);

d1062 6
a1067 9
				if (!RF_DEAD_DISK(diskPtr->status)) {
					ci_label.partitionSize =
					    diskPtr->partitionSize;
					ci_label.column = column;
					raidwrite_component_label( 
					    raidPtr->Disks[row][column].dev, 
					    raidPtr->raid_cinfo[row][column].ci_vp, 
					    &ci_label );
				}
a1091 1

a1205 1

d1223 1
a1223 1
	/* fail a disk & optionally start reconstruction */
d1249 4
a1252 4
	/*
	 * Invoke a copyback operation after recon on whatever
	 * disk needs it, if any.
	 */
d1268 2
a1269 2

	/* Return the percentage completion of reconstruction */
d1346 1
a1346 2
			*(int *) data = 100 * raidPtr->copyback_stripes_done /
				raidPtr->Layout.numStripe;
a1434 1
	/* fall through to the os-specific code below */
d1436 1
a1458 4
	{
		struct disklabel *lp;
		lp = (struct disklabel *)data;

d1465 1
a1465 1
		    lp, 0, rs->sc_dkdev.dk_cpulabel);
a1479 1
	}
d1488 3
d1492 2
a1493 1
  		raidgetdefaultlabel(raidPtr, rs, (struct disklabel *) data);
d1496 1
a1499 1

d1507 1
a1507 1
void
d1512 1
a1512 2
	struct cfdata	*cf;
	int      unit;
a1516 2
	pool_init(&rs->sc_cbufpool, sizeof(struct raidbuf), 0,
		0, 0, "raidpl", NULL);
a1537 18

	/*
	 * config_attach the raid device into the device tree.
	 * For autoconf rootdev selection...
	 */
	cf = malloc(sizeof(struct cfdata), M_RAIDFRAME, M_NOWAIT);
	if (cf == NULL) {
		printf("WARNING: no memory for cfdata struct\n");
		return;
	}
	bzero(cf, sizeof(struct cfdata));

	cf->cf_attach = &raid_ca;
	cf->cf_driver = &raid_cd;
	cf->cf_unit   = unit;

	config_attach(NULL, cf, NULL, NULL);
	printf("\n");	/* pretty up config_attach()'s output. */
d1685 2
a1686 1
		disk_busy(&rs->sc_dkdev);
d1689 1
a1689 4
		 * need to be? */

		/* don't ever condition on bp->b_flags & B_WRITE.  
		 * always condition on B_READ instead */
d1736 3
d1757 1
a1757 1
	raidbp = RAIDGETBUF(rs);
d1911 6
a1916 1
	RAIDPUTBUF(rs, raidbp);
d1973 1
a1973 1
	lp->d_ntracks = 4 * raidPtr->numCol;
a2197 6
	if (b_vp == NULL) {
		/* For whatever reason, this component is not valid.
		   Don't try to read a component label from it. */
		return(EINVAL);
	}

d2205 1
a2205 1
	bp->b_flags |= B_READ;
d2224 1
d2245 1
a2245 1
	bp->b_flags |= B_WRITE;
d2254 1
d2275 1
a2275 3
			/* we don't want to touch (at all) a disk that has
			   failed */
			if (!RF_DEAD_DISK(raidPtr->Disks[r][c].status)) {
d2472 1
a2472 2
	if ((p = raidPtr->engine_thread) == NULL)
		p = curproc;
d2476 2
a2477 2
			VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, 0);
			vrele(vp);
d2494 1
d2501 2
d2628 1
a2628 1
	int major;
d2632 1
d2646 3
a2648 1
#ifdef RAID_AUTOCONFIG
d2664 5
a2668 1
		major = findblkmajor(dv);
d2672 1
a2672 1
		dev = MAKEDISKDEV(major, dv->dv_unit, RAW_PART);
d2699 2
a2700 2
		VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, 0);
		vrele(vp);
d2703 1
a2703 5
			/* We only support partitions marked as RAID.	*/
			/* Aside on sparc/sparc64 where FS_RAID doesn't	*/
			/* fit in the SUN disklabel and we need to look	*/
			/* into each and every partition !!!		*/
#if !defined(__sparc__) && !defined(__sparc64__) && !defined(__sun3__)
a2705 5
#else /* !__sparc__ && !__sparc64__ && !__sun3__ */
			if (label.d_partitions[i].p_fstype == FS_SWAP ||
			    label.d_partitions[i].p_fstype == FS_UNUSED)
				continue;
#endif /* __sparc__ || __sparc64__ || __sun3__ */
d2707 1
a2707 1
			dev = MAKEDISKDEV(major, dv->dv_unit, i);
d2734 1
a2734 1
#ifdef DEBUG
d2764 2
a2765 2
				VOP_CLOSE(vp, FREAD | FWRITE, NOCRED, 0);
				vrele(vp);
d2769 1
d2775 1
a2775 1
int
d2893 1
a2893 1
int
a2980 1
	mod_counter = 0;
d3006 1
a3006 1
#ifdef DEBUG
a3094 95

#ifdef RAID_DEBUG_ALL
#ifdef RF_DBG_OPTION
#undef RF_DBG_OPTION
#endif

#ifdef __STDC__
#define RF_DBG_OPTION(_option_,_val_) \
	snprintf(&(config->debugVars[i++][0]), 50, \
		 "%s %ld", #_option_, _val_);
#else                           /* __STDC__ */
#define RF_DBG_OPTION(_option_,_val_) \
	snprintf(&(config->debugVars[i++][0]), 50, \
		 "%s %ld", "/**/_option_/**/", _val_);
#endif                          /* __STDC__ */

	i = 0;

/*	RF_DBG_OPTION(accessDebug, 0) */
/*	RF_DBG_OPTION(accessTraceBufSize, 0) */
	RF_DBG_OPTION(cscanDebug, 1)	/* debug CSCAN sorting */
	RF_DBG_OPTION(dagDebug, 1)
/*	RF_DBG_OPTION(debugPrintUseBuffer, 0) */
	RF_DBG_OPTION(degDagDebug, 1)
	RF_DBG_OPTION(disableAsyncAccs, 1)
	RF_DBG_OPTION(diskDebug, 1)
	RF_DBG_OPTION(enableAtomicRMW, 0)	/* this debug var enables
					 	 * locking of the disk arm
					 	 * during small-write
					 	 * operations.  Setting this
					 	 * variable to anything other
						 * than 0 will result in
						 * deadlock.  (wvcii) */
	RF_DBG_OPTION(engineDebug, 1)
	RF_DBG_OPTION(fifoDebug, 1)	/* debug fifo queueing */
/*	RF_DBG_OPTION(floatingRbufDebug, 1) */
/*	RF_DBG_OPTION(forceHeadSepLimit, -1) */
/*	RF_DBG_OPTION(forceNumFloatingReconBufs, -1) */	/* wire down number of
						 	 * extra recon buffers
						 	 * to use */
/*	RF_DBG_OPTION(keepAccTotals, 1) */	/* turn on keep_acc_totals */
	RF_DBG_OPTION(lockTableSize, RF_DEFAULT_LOCK_TABLE_SIZE)
	RF_DBG_OPTION(mapDebug, 1)
	RF_DBG_OPTION(maxNumTraces, -1)

/*	RF_DBG_OPTION(memChunkDebug, 1) */
/*	RF_DBG_OPTION(memDebug, 1) */
/*	RF_DBG_OPTION(memDebugAddress, 1) */
/*	RF_DBG_OPTION(numBufsToAccumulate, 1) */	/* number of buffers to
						 	 * accumulate before
							 * doing XOR */
	RF_DBG_OPTION(prReconSched, 0)
	RF_DBG_OPTION(printDAGsDebug, 1)
	RF_DBG_OPTION(printStatesDebug, 1)
	RF_DBG_OPTION(protectedSectors, 64L)		/* # of sectors at start
						 	 * of disk to exclude
						 	 * from RAID address
							 * space */
	RF_DBG_OPTION(pssDebug, 1)
	RF_DBG_OPTION(queueDebug, 1)
	RF_DBG_OPTION(quiesceDebug, 1)
	RF_DBG_OPTION(raidSectorOffset, 0)	/* added to all incoming sectors
					 	 * to debug alignment problems */
	RF_DBG_OPTION(reconDebug, 1)
	RF_DBG_OPTION(reconbufferDebug, 1)
	RF_DBG_OPTION(scanDebug, 1)	/* debug SCAN sorting */
	RF_DBG_OPTION(showXorCallCounts, 0)	/* show n-way Xor call counts */
	RF_DBG_OPTION(shutdownDebug, 1)		/* show shutdown calls */
	RF_DBG_OPTION(sizePercentage, 100)
	RF_DBG_OPTION(sstfDebug, 1)	/* turn on debugging info for sstf
					 * queueing */
	RF_DBG_OPTION(stripeLockDebug, 1)
	RF_DBG_OPTION(suppressLocksAndLargeWrites, 0)
	RF_DBG_OPTION(suppressTraceDelays, 0)
	RF_DBG_OPTION(useMemChunks, 1)
	RF_DBG_OPTION(validateDAGDebug, 1)
	RF_DBG_OPTION(validateVisitedDebug, 1)		/* XXX turn to zero by
						 	 * default? */
	RF_DBG_OPTION(verifyParityDebug, 1)
	RF_DBG_OPTION(debugKernelAccess, 1)	/* DoAccessKernel debugging */

#if 0 /* RF_INCLUDE_PARITYLOGGING > 0 */
	RF_DBG_OPTION(forceParityLogReint, 0)
	RF_DBG_OPTION(numParityRegions, 0)	/* number of regions in the
						 * array */
	RF_DBG_OPTION(numReintegrationThreads, 1)
	RF_DBG_OPTION(parityLogDebug, 1)	/* if nonzero, enables debugging
					 	 * of parity logging */
	RF_DBG_OPTION(totalInCoreLogCapacity, 1024 * 1024)	/* target bytes
							 	 * available for
							 	 * in-core
								 * logs */
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */

#endif /* RAID_DEBUG_ALL */
d3160 1
a3160 1
			vrele(ac->vp);
d3269 1
a3269 1
		for(raidID = numraid - 1; raidID >= 0; raidID--) {
a3315 11
}

void
rf_disk_unbusy(desc)
	RF_RaidAccessDesc_t *desc;
{
	struct buf *bp;

	bp = (struct buf *)desc->bp;
	disk_unbusy(&raid_softc[desc->raidPtr->raidid].sc_dkdev, 
			    (bp->b_bcount - bp->b_resid));
@


1.9.2.3
log
@Merge in -current from roughly a week ago
@
text
@d175 2
a176 2
void	rf_KernelWakeupFunc(struct buf *);
void	rf_InitBP(struct buf *, struct vnode *, unsigned, dev_t,
d178 2
a179 2
	    void *, int, struct proc *);
void raidinit(RF_Raid_t *);
d181 9
a189 9
void	raidattach(int);
int	raidsize(dev_t);
int	raidopen(dev_t, int, int, struct proc *);
int	raidclose(dev_t, int, int, struct proc *);
int	raidioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	raidwrite(dev_t, struct uio *, int);
int	raidread(dev_t, struct uio *, int);
void	raidstrategy(struct buf *);
int	raiddump(dev_t, daddr_t, caddr_t, size_t);
d242 5
a246 5
int	rf_probe(struct device *, void *, void *);
void	rf_attach(struct device *, struct device *, void *);
int	rf_detach(struct device *, int);
int	rf_activate(struct device *, enum devact);
void	rf_zeroref(struct device *);
d281 4
a284 4
void	rf_shutdown_hook(RF_ThreadArg_t);
void	raidgetdefaultlabel(RF_Raid_t *, struct raid_softc *, struct disklabel *);
void	raidgetdisklabel(dev_t);
void	raidmakedisklabel(struct raid_softc *);
d286 2
a287 2
int	raidlock(struct raid_softc *);
void	raidunlock(struct raid_softc *);
d289 2
a290 1
void	rf_markalldirty(RF_Raid_t *);
d294 2
a295 2
int findblkmajor(struct device *dv);
char *findblkname(int);
d297 1
a297 1
void rf_ReconThread(struct rf_recon_req *);
d299 4
a302 4
/*void rf_ReconThread(RF_Raid_t *raidPtr);  */
void rf_RewriteParityThread(RF_Raid_t *raidPtr);
void rf_CopybackThread(RF_Raid_t *raidPtr);
void rf_ReconstructInPlaceThread(struct rf_recon_req *);
d304 2
a305 2
void rf_buildroothack(void *);
int rf_reasonable_label(RF_ComponentLabel_t *);
d308 11
a318 11
RF_AutoConfig_t *rf_find_raid_components(void);
RF_ConfigSet_t *rf_create_auto_sets(RF_AutoConfig_t *);
int rf_does_it_fit(RF_ConfigSet_t *,RF_AutoConfig_t *);
void rf_create_configuration(RF_AutoConfig_t *,RF_Config_t *,
				  RF_Raid_t *);
int rf_set_autoconfig(RF_Raid_t *, int);
int rf_set_rootpartition(RF_Raid_t *, int);
void rf_release_all_vps(RF_ConfigSet_t *);
void rf_cleanup_config_set(RF_ConfigSet_t *);
int rf_have_enough_components(RF_ConfigSet_t *);
int rf_auto_config_set(RF_ConfigSet_t *, int *);
d470 2
a471 2
	if (raidautoconfig) {
		/* 1. locate all RAID components on the system */
d474 1
a474 1
		printf("Searching for raid components...\n");
d476 1
a476 1
		ac_list = rf_find_raid_components();
d478 1
a478 1
		/* 2. sort them into their respective sets */
d480 1
a480 1
		config_sets = rf_create_auto_sets(ac_list);
d482 2
a483 2
		/* 3. evaluate each set and configure the valid ones
		   This gets done in rf_buildroothack() */
d485 2
a486 2
		/* schedule the creation of the thread to do the 
		   "/ on RAID" stuff */
d488 1
a488 1
		rf_buildroothack(config_sets);
d490 4
a493 1
	}
a564 32
void
rf_shutdown_hook(arg)
	RF_ThreadArg_t arg;
{
	int unit;
	struct raid_softc *rs;
	RF_Raid_t *raidPtr;

	/* Don't do it if we are not "safe" */
	if (boothowto & RB_NOSYNC)
		return;

	raidPtr = (RF_Raid_t *) arg;
	unit = raidPtr->raidid;
	rs = &raid_softc[unit];

	/* Shutdown the system */

	rf_Shutdown(raidPtr);

	pool_destroy(&rs->sc_cbufpool);

	/* It's no longer initialized... */
	rs->sc_flags &= ~RAIDF_INITED;

	/* config_detach the device. */
	config_detach(device_lookup(&raid_cd, unit), 0);

	/* Detach the disk. */
	disk_detach(&rs->sc_dkdev);
}

d729 3
a731 1
		db1_printf(("Last one on raid%d.  Updating status.\n",unit));
d734 18
d1066 1
a1066 1
		if ((retcode = rf_Shutdown(raidPtr)) == 0) {
d1068 1
a1068 1
			pool_destroy(&rs->sc_cbufpool);
d1070 2
a1071 2
			/* It's no longer initialized... */
			rs->sc_flags &= ~RAIDF_INITED;
d1073 2
a1074 2
			/* config_detach the device. */
			config_detach(device_lookup(&raid_cd, unit), 0);
d1076 2
a1077 3
			/* Detach the disk. */
			disk_detach(&rs->sc_dkdev);
		}
d2758 7
@


1.9.2.4
log
@Sync the SMP branch with 3.3
@
text
@a2 1

d81 3
d111 1
a111 1
/*****************************************************************************
d113 1
a113 1
 * rf_kintf.c -- The kernel interface routines for RAIDframe.
d115 1
a115 1
 *****************************************************************************/
a143 1
#include "rf_engine.h"
d158 2
a159 2
#ifdef	RAIDDEBUG
#define	db1_printf(a) do { if (rf_kdebug_level > 0) printf a; } while(0)
d161 2
a162 2
#define	db1_printf(a) (void)0
#endif	/* ! RAIDDEBUG */
d164 1
a164 1
static RF_Raid_t **raidPtrs;	/* Global raid device descriptors. */
d166 1
a166 1
RF_DECLARE_STATIC_MUTEX(rf_sparet_wait_mutex);
d168 1
a168 1
/* Requests to install a spare table. */
d171 1
a171 1
/* Responses from installation process. */
d174 5
a178 5
/* Prototypes. */
void rf_KernelWakeupFunc(struct buf *);
void rf_InitBP(struct buf *, struct vnode *, unsigned, dev_t, RF_SectorNum_t,
    RF_SectorCount_t, caddr_t, void (*)(struct buf *), void *, int,
    struct proc *);
d181 9
a189 9
void raidattach(int);
int  raidsize(dev_t);
int  raidopen(dev_t, int, int, struct proc *);
int  raidclose(dev_t, int, int, struct proc *);
int  raidioctl(dev_t, u_long, caddr_t, int, struct proc *);
int  raidwrite(dev_t, struct uio *, int);
int  raidread(dev_t, struct uio *, int);
void raidstrategy(struct buf *);
int  raiddump(dev_t, daddr_t, caddr_t, size_t);
d195 4
a198 4
	struct buf	 rf_buf;	/* New I/O buf.	 MUST BE FIRST!!! */
	struct buf	*rf_obp;	/* Ptr. to original I/O buf. */
	int		 rf_flags;	/* Miscellaneous flags. */
	RF_DiskQueueData_t *req;	/* The request that this was part of. */
d201 2
a202 2
#define	RAIDGETBUF(rs)		pool_get(&(rs)->sc_cbufpool, PR_NOWAIT)
#define	RAIDPUTBUF(rs, cbp)	pool_put(&(rs)->sc_cbufpool, cbp)
d215 1
a215 1
 * or if it should be used in conjunction with that...
d218 7
a224 7
	int		sc_flags;		/* Flags. */
	int		sc_cflags;		/* Configuration flags. */
	size_t		sc_size;		/* Size of the raid device. */
	char		sc_xname[20];		/* XXX external name. */
	struct disk	sc_dkdev;		/* Generic disk device info. */
	struct pool	sc_cbufpool;		/* Component buffer pool. */
	struct buf	sc_q;			/* Used for the device queue. */
d228 5
a232 5
#define	RAIDF_INITED	0x01	/* Unit has been initialized. */
#define	RAIDF_WLABEL	0x02	/* Label area is writable. */
#define	RAIDF_LABELLING	0x04	/* Unit is currently being labelled. */
#define	RAIDF_WANTED	0x40	/* Someone is waiting to obtain a lock. */
#define	RAIDF_LOCKED	0x80	/* Unit is locked. */
d242 5
a246 5
int  rf_probe(struct device *, void *, void *);
void rf_attach(struct device *, struct device *, void *);
int  rf_detach(struct device *, int);
int  rf_activate(struct device *, enum devact);
void rf_zeroref(struct device *);
d257 4
a260 4
 *
 * For example: with a stripe width of 64 blocks (32k) and 5 disks,
 * a single 64K write will typically require 64K for the old data,
 * 64K for the old parity, and 64K for the new parity, for a total
d264 1
a264 1
 *
d266 1
a266 1
 * require data reconstruction, which will require *all* of the 4 remaining
d270 2
a271 2
#ifndef	RAIDOUTSTANDING
#define	RAIDOUTSTANDING		6
d274 1
a274 1
#define	RAIDLABELDEV(dev)						\
d277 2
a278 2
/* Declared here, and made public, for the benefit of KVM stuff... */
struct raid_softc  *raid_softc;
d281 4
a284 4
void rf_shutdown_hook(RF_ThreadArg_t);
void raidgetdefaultlabel(RF_Raid_t *, struct raid_softc *, struct disklabel *);
void raidgetdisklabel(dev_t);
void raidmakedisklabel(struct raid_softc *);
d286 2
a287 2
int  raidlock(struct raid_softc *);
void raidunlock(struct raid_softc *);
d289 1
a289 1
void rf_markalldirty(RF_Raid_t *);
d293 1
a293 1
int  findblkmajor(struct device *dv);
d298 1
a298 1
/*void rf_ReconThread(RF_Raid_t *raidPtr);*/
d302 1
a302 1
#ifdef	RAID_AUTOCONFIG
d304 2
a305 2
int  rf_reasonable_label(RF_ComponentLabel_t *);
#endif	/* RAID_AUTOCONFIG */
d309 1
a309 1
int  rf_does_it_fit(RF_ConfigSet_t *,RF_AutoConfig_t *);
d312 2
a313 2
int  rf_set_autoconfig(RF_Raid_t *, int);
int  rf_set_rootpartition(RF_Raid_t *, int);
d316 2
a317 2
int  rf_have_enough_components(RF_ConfigSet_t *);
int  rf_auto_config_set(RF_ConfigSet_t *, int *);
d319 7
a325 9
#ifdef	RAID_AUTOCONFIG
static int raidautoconfig = 0;	/*
				 * Debugging, mostly.  Set to 0 to not
				 * allow autoconfig to take place.
				 * Note that this is overridden by having
				 * RAID_AUTOCONFIG as an option in the
				 * kernel config file.
				 */
#endif	/* RAID_AUTOCONFIG */
d328 4
a331 1
rf_probe(struct device *parent, void *match_, void *aux)
d337 3
a339 1
rf_attach(struct device *parent, struct device *self, void *aux)
d341 1
a341 1
	/*struct raid_softc *raid = (void *)self;*/
d345 3
a347 1
rf_detach(struct device *self, int flags)
d353 3
a355 1
rf_activate(struct device *self, enum devact act)
d361 2
a362 1
rf_zeroref(struct device *self)
d367 2
a368 1
raidattach(int num)
d372 2
a373 2
#ifdef	RAID_AUTOCONFIG
	RF_AutoConfig_t *ac_list;	/* Autoconfig list. */
d375 1
a375 1
#endif	/* RAID_AUTOCONFIG */
d380 1
a380 1
#ifdef	DIAGNOSTIC
d382 1
a382 1
#endif	/* DIAGNOSTIC */
d393 1
a393 1
		panic("raidPtrs is NULL!!");
d398 2
a399 2
		RF_PANIC();
	}
d404 1
a404 1
		raidPtrs[i] = NULL;
d407 1
a407 1
		printf("Kernelized RAIDframe activated\n");
d409 1
a409 1
	        panic("Serious error booting RAID !!!");
d412 1
a412 1
	 * Put together some datastructures like the CCD device does...
d415 1
a415 1

d417 2
a418 1
		malloc(num * sizeof(struct raid_softc), M_RAIDFRAME, M_NOWAIT);
d427 2
a428 2
		malloc(num * sizeof(struct raid_softc *), M_RAIDFRAME,
		    M_NOWAIT);
d437 1
a437 1
	    M_RAIDFRAME, M_NOWAIT);
d439 1
a439 1
		panic("No memory for RAIDframe driver!!?!?!");
d466 1
a466 1
#ifdef	RAID_AUTOCONFIG
d470 1
a470 1
		/* 1. Locate all RAID components on the system. */
d472 1
a472 1
#ifdef	RAIDDEBUG
d474 1
a474 1
#endif	/* RAIDDEBUG */
d477 1
a477 1
		/* 2. Sort them into their respective sets. */
d481 2
a482 4
		/*
		 * 3. Evaluate each set and configure the valid ones
		 * This gets done in rf_buildroothack().
		 */
d484 2
a485 4
		/*
		 * Schedule the creation of the thread to do the
		 * "/ on RAID" stuff.
		 */
d490 1
a490 1
#endif	/* RAID_AUTOCONFIG */
d494 1
a494 1
#ifdef	RAID_AUTOCONFIG
d496 2
a497 1
rf_buildroothack(void *arg)
d513 1
a513 1
		if (rf_have_enough_components(cset) &&
d519 3
a521 4
#ifdef	RAIDDEBUG
					printf("eligible root device %d:"
					    " raid%d\n", num_root, rootID);
#endif	/* RAIDDEBUG */
d526 3
a528 4
#ifdef	RAIDDEBUG
				printf("Autoconfig failed with code %d for"
				    " raid%d\n", retcode, raidID);
#endif	/* RAIDDEBUG */
d532 2
a533 4
			/*
			 * We're not autoconfiguring this set...
			 * Release the associated resources.
			 */
d536 1
a536 1
		/* Cleanup. */
d550 1
a550 1
				rootdev = MAKEDISKDEV(majdev,rootID,0);
d554 1
a554 1
			/* We can't guess... Require the user to answer... */
d559 1
a559 1
#endif	/* RAID_AUTOCONFIG */
d562 2
a563 1
rf_shutdown_hook(RF_ThreadArg_t arg)
d569 1
a569 1
	/* Don't do it if we are not "safe". */
d577 1
a577 4
	/* Shutdown the system. */

	if (rf_hook_cookies != NULL && rf_hook_cookies[unit] != NULL)
		rf_hook_cookies[unit] = NULL;
d594 2
a595 1
raidsize(dev_t dev)
d630 5
a634 1
raiddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
d642 4
a645 1
raidopen(dev_t dev, int flags, int fmt, struct proc *p)
d652 1
a652 1

d671 1
a671 1
	/* Make sure that this partition exists. */
d685 1
a685 1
	/* Prevent this unit from being unconfigured while opened. */
d698 7
a704 11
		/*
		 * First one...  Mark things as dirty...  Note that we *MUST*
		 * have done a configure before this.  I DO NOT WANT TO BE
		 * SCRIBBLING TO RANDOM COMPONENTS UNTIL IT'S BEEN DETERMINED
		 * THAT THEY BELONG TOGETHER!!!!!
		 */
		/*
		 * XXX should check to see if we're only open for reading
		 * here...  If so, we needn't do this, but then need some
		 * other way of keeping track of what's happened...
		 */
d706 1
a706 1
		rf_markalldirty( raidPtrs[unit] );
d719 4
a722 1
raidclose(dev_t dev, int flags, int fmt, struct proc *p)
d753 4
a756 6
		/*
		 * Last one...  Device is not unconfigured yet.
		 * Device shutdown has taken care of setting the
		 * clean bits if RAIDF_INITED is not set.
		 * Mark things as clean...
		 */
d767 2
a768 1
raidstrategy(struct buf *bp)
a777 2
	s = splbio();

d783 1
a783 1
  		goto raidstrategy_end;
d790 1
a790 1
		goto raidstrategy_end;
d798 1
a798 1
		goto raidstrategy_end;
d803 1
a803 1
		goto raidstrategy_end;
d818 1
a818 1
			goto raidstrategy_end;
d821 2
a830 1
raidstrategy_end:
d836 4
a839 1
raidread(dev_t dev, struct uio *uio, int flags)
d860 4
a863 1
raidwrite(dev_t dev, struct uio *uio, int flags)
d879 6
a884 1
raidioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d963 1
a963 1

d965 1
a965 1
		/* Configure the system. */
d969 1
a969 1
			/* There is a valid RAID set running on this unit ! */
d975 1
a975 1
		 * Copy-in the configuration information.
d996 1
a996 1
				/* Sanity check. */
d1010 1
a1010 1
				RF_Free(specific_buf,
d1017 1
a1017 1

d1021 1
a1021 1
		 * Store the sum of all the bytes in the last byte ?
d1026 2
a1027 2
		 *  there is no stale data left in the case of a
		 *  reconfiguration.
d1031 1
a1031 1
		/* Configure the system. */
d1038 2
a1039 4
			/*
			 * Allow this many simultaneous IO's to
			 * this RAID device.
			 */
d1041 1
a1041 1

d1051 1
a1051 1

d1053 1
a1053 1

d1055 2
a1056 2
		/* Shutdown the system. */

d1091 1
a1091 1

d1094 2
a1095 4
		/*
		 * We need to read the component label for the disk indicated
		 * by row,column in clabel.
		 */
d1097 2
a1098 4
		/*
		 * For practice, let's get it directly from disk, rather
		 * than from the in-core copy.
		 */
d1106 1
a1106 1
		retcode = copyin( *clabel_ptr, clabel,
d1113 1
a1113 1

d1122 4
a1125 2
		raidread_component_label(raidPtr->Disks[row][column].dev,
		    raidPtr->raid_cinfo[row][column].ci_vp, clabel );
d1127 1
a1127 1
		retcode = copyout((caddr_t) clabel,
d1137 4
a1140 5
		/*
		 * Note that some things *should not* get modified --
		 * the user should be re-initing the labels instead of
		 * trying to patch things.
		 */
a1141 1
#ifdef	RAIDDEBUG
a1151 1
#endif	/* RAIDDEBUG */
d1164 4
a1167 2
		raidwrite_component_label(raidPtr->Disks[row][column].dev,
		    raidPtr->raid_cinfo[row][column].ci_vp, clabel );
d1171 1
a1171 1
	case RAIDFRAME_INIT_LABELS:
d1173 6
a1178 6
		/*
		 * We only want the serial number from the above.
		 * We get all the rest of the information from
		 * the config that was used to create this RAID
		 * set.
		 */
d1181 1
a1181 1

d1193 3
a1195 3
					raidwrite_component_label(
					    raidPtr->Disks[row][column].dev,
					    raidPtr->raid_cinfo[row][column].ci_vp,
d1202 1
a1202 1

d1206 1
a1206 1
			/* Parity for RAID 0 is trivially correct. */
d1211 1
a1211 1

d1213 1
a1213 1
			/* Re-write is already in progress ! */
d1225 1
a1225 1
		db1_printf(("New autoconfig value is: %d\n", d));
d1231 1
a1231 1
		db1_printf(("New rootpartition value is: %d\n", d));
d1247 1
a1247 1
		memcpy( &component, componentPtr,
d1254 1
a1254 1
		memcpy( &component, componentPtr,
d1262 1
a1262 1
			/* Can't do this on a RAID 0 !! */
d1267 1
a1267 1
			/* A reconstruct is already in progress ! */
d1272 1
a1272 1
		memcpy( &component, componentPtr,
d1276 1
a1276 1
		db1_printf(("Rebuild: %d %d\n",row, column));
d1341 1
a1341 1

d1350 1
a1350 1

d1355 1
a1355 1
	/* Fail a disk & optionally start reconstruction. */
d1358 1
a1358 1

d1363 3
a1365 3
		db1_printf(("raid%d: Failing the disk: row: %d col: %d\n",
		    unit, rr->row, rr->col));

d1368 1
a1368 1
		 * rely on the user's buffer.
d1380 1
a1380 1

d1385 1
a1385 1
	case RAIDFRAME_COPYBACK:
d1387 1
a1387 1
			/* This makes no sense on a RAID 0 !! */
d1390 1
a1390 1

d1392 1
a1392 1
			/* Copyback is already in progress ! */
d1395 1
a1395 1

d1401 1
a1401 1
	/* Return the percentage completion of reconstruction. */
d1404 2
a1405 4
			/*
			 * This makes no sense on a RAID 0, so tell the
			 * user it's done.
			 */
d1425 1
a1425 1
			progressInfo.total =
d1427 1
a1427 1
			progressInfo.completed =
d1439 2
a1440 4
			/*
			 * This makes no sense on a RAID 0, so tell the
			 * user it's done.
			 */
d1445 2
a1446 2
			*(int *) data = 100 *
				raidPtr->parity_rewrite_stripes_done /
d1457 1
a1457 1
			progressInfo.completed =
d1473 1
a1473 1
			/* This makes no sense on a RAID 0 !! */
d1489 1
a1489 1
			progressInfo.completed =
d1525 1
a1525 1

d1527 1
a1527 1

d1530 1
a1530 1

d1548 1
a1548 1
		 * into the kernel.
d1550 2
a1551 2

		/* Install the spare table. */
d1553 1
a1553 1

d1555 2
a1556 2
		 * Respond to the requestor.  The return status of the
		 * spare table installation is passed in the "fcol" field.
d1565 1
a1565 1

d1568 1
a1568 1
	/* Fall through to the os-specific code below. */
d1572 1
a1572 1

d1575 1
a1575 1

d1629 1
a1629 1

d1638 1
a1638 1
 * raidinit -- Complete the rest of the initialization for the
d1642 2
a1643 1
raidinit(RF_Raid_t *raidPtr)
d1647 1
a1647 1
	int unit;
d1654 1
a1654 1

d1658 1
a1658 1
	/* XXX doesn't check bounds. */
d1661 1
a1661 1
	rs->sc_dkdev.dk_name = rs->sc_xname;
d1665 2
a1666 2
	 * other things, so it's critical to call this *BEFORE* we try
	 * putzing with disklabels.
d1692 1
d1696 1
a1696 1
 * Wake up the daemon & tell it to get us a spare table.
d1698 3
a1700 3
 * The entries in the queues should be tagged with the raidPtr so that
 * in the extremely rare case that two recons happen at once, we know
 * which devices were requesting a spare table.
d1702 1
a1702 1
 *
d1706 2
a1707 1
rf_GetSpareTableFromDaemon(RF_SparetWait_t *req)
d1716 1
a1716 1
	/* mpsleep unlocks the mutex. */
d1719 1
a1719 1
		    "RAIDframe getsparetable", 0);
d1726 1
a1726 1
	/* This is not the same req as we alloc'd. */
d1733 5
a1737 5
 * bp and passes it down.
 * Any calls originating in the kernel must use non-blocking I/O.
 * Do some extra sanity checking to return "appropriate" error values for
 * certain conditions (to make some standard utilities work).
 *
d1741 2
a1742 1
raidstart(RF_Raid_t *raidPtr)
d1748 1
a1748 1
	daddr_t blocknum;
d1757 1
a1757 1
	/* Quick check to see if anything has died recently. */
d1760 1
a1760 1
		rf_update_component_labels(raidPtr,
d1770 1
a1770 1

d1773 1
a1773 1
			/* Nothing more to do. */
d1778 4
a1781 6
		/*
		 * Ok, for the bp we have here, bp->b_blkno is relative to the
		 * partition... We need to make it absolute to the underlying
		 * device...
		 */

d1787 2
a1788 2

		db1_printf(("Blocks: %d, %d\n", (int) bp->b_blkno,
d1790 1
a1790 1

d1793 3
a1795 5

		/*
		 * *THIS* is where we adjust what block we're going to...
		 * But DO NOT TOUCH bp->b_blkno !!!
		 */
d1797 1
a1797 1

d1802 3
a1804 3
			db1_printf(("raid_addr=%d sum=%d num_blocks=%d(+%d)"
			    " (%d)\n", (int)raid_addr, (int)sum,
			    (int)num_blocks, (int)pb, (int)bp->b_resid));
a1810 3
			/* db1_printf(("%s: Calling biodone on 0x%x\n",
			    __func__, bp)); */
			splassert(IPL_BIO);
d1816 1
a1816 1
		 * XXX rf_DoAccess() should do this, not just DoAccessKernel().
d1818 1
a1818 1

a1822 3
			/* db1_printf(("%s: Calling biodone on 0x%x\n",
			    __func__, bp)); */
			splassert(IPL_BIO);
d1826 1
a1826 1

d1829 2
a1830 2


d1839 1
a1839 1

d1841 3
d1845 2
a1846 9
		/*
		 * XXX we're still at splbio() here...  Do we *really*
		 * need to be ?
		 */

		/*
		 * Don't ever condition on bp->b_flags & B_WRITE.
		 * Always condition on B_READ instead.
		 */
d1851 1
a1851 1
				      bp->b_data, bp, NULL, NULL,
d1859 1
a1859 1
/* Invoke an I/O from kernel mode.  Disk queue should be locked upon entry. */
d1862 3
a1864 1
rf_DispatchKernelIO(RF_DiskQueue_t *queue, RF_DiskQueueData_t *req)
d1871 5
a1875 2
	/*int s = splbio();*/	/* Want to test this. */

d1878 1
a1878 1
	 * this device...
d1881 1
a1881 1

d1888 1
a1888 1
		panic("Invalid Unit number in rf_DispatchKernelIO");
d1898 1
a1898 1
	 * us a buffer that contains old stuff !!  Attempt to deal with
d1900 2
a1901 2
	 * (not sure where the real bug is; it's buried in RAIDframe
	 * somewhere) :-( GO )
d1913 1
a1913 1
	raidbp->rf_flags = 0;	/* XXX not really used anywhere... */
d1916 1
a1916 1
	 * Context for raidiodone.
d1930 1
a1930 1
		/* XXX need to do something extra here... */
d1936 1
a1936 1
		db1_printf(("WAKEUP CALLED\n"));
d1939 1
a1939 1
		/* XXX need to glue the original buffer into this ?? */
d1943 1
a1943 1

d1953 1
a1953 1
		    req->buf, rf_KernelWakeupFunc, (void *)req,
d1981 1
a1981 1

d1986 1
a1986 1
	/*splx(s);*/	/* want to test this */
d1995 2
a1996 1
rf_KernelWakeupFunc(struct buf *vbp)
d2037 1
a2037 1
	bp->b_bcount = raidbp->rf_buf.b_bcount;	/* XXXX ?? */
d2039 1
a2039 1
	unit = queue->raidPtr->raidid;	/* *Much* simpler :-> */
d2042 1
a2042 1
	 * XXX Ok, let's get aggressive...  If B_ERROR is set, let's go
d2077 13
a2089 13
rf_InitBP(
	struct buf	 *bp,
	struct vnode	 *b_vp,
	unsigned	  rw_flag,
	dev_t		  dev,
	RF_SectorNum_t	  startSect,
	RF_SectorCount_t  numSect,
	caddr_t		  buf,
	void		(*cbFunc)(struct buf *),
	void		 *cbArg,
	int		  logBytesPerSector,
	struct proc	 *b_proc
)
d2091 2
a2092 2
	/*bp->b_flags = B_PHYS | rw_flag;*/
	bp->b_flags = B_CALL | rw_flag;	/* XXX need B_PHYS here too ??? */
d2099 1
a2099 1
	bp->b_resid = bp->b_bcount;	/* XXX is this right !??!?!! */
d2101 1
a2101 1
		panic("bp->b_bcount is zero in rf_InitBP!!");
d2110 4
a2113 2
raidgetdefaultlabel(RF_Raid_t *raidPtr, struct raid_softc *rs,
    struct disklabel *lp)
d2118 1
a2118 1
	/* Fabricate a label... */
d2123 2
a2124 2
	lp->d_ncylinders = raidPtr->totalSectors /
	    (lp->d_nsectors * lp->d_ntracks);
d2145 2
a2146 2
 * Read the disklabel from the raid device.
 * If one is not present, fake one up.
d2149 2
a2150 1
raidgetdisklabel(dev_t dev)
d2177 1
a2177 1
		/*raidmakedisklabel(rs);*/
a2187 1
#ifdef	RAIDDEBUG
a2192 1
#endif	/* RAIDDEBUG */
d2207 2
a2208 1
raidmakedisklabel(struct raid_softc *rs)
d2232 4
a2235 1
raidlookup(char *path, struct proc *p, struct vnode **vpp /* result */)
d2244 1
a2244 1
#ifdef	RAIDDEBUG
d2246 1
a2246 1
#endif	/* RAIDDEBUG */
d2279 2
a2280 1
raidlock(struct raid_softc *rs)
d2297 2
a2298 1
raidunlock(struct raid_softc *rs)
d2306 1
d2308 2
d2311 1
a2311 4
#define	RF_COMPONENT_INFO_OFFSET	16384	/* bytes */
#define	RF_COMPONENT_INFO_SIZE		 1024	/* bytes */

int
d2323 1
a2323 1
int
d2336 4
a2339 2
raidread_component_label(dev_t dev, struct vnode *b_vp,
    RF_ComponentLabel_t *clabel)
d2343 3
a2345 5

	/*
	 * XXX should probably ensure that we don't try to do this if
	 * someone has changed rf_protected_sectors.
	 */
d2348 2
a2349 4
		/*
		 * For whatever reason, this component is not valid.
		 * Don't try to read a component label from it.
		 */
d2353 1
a2353 1
	/* Get a block of the appropriate size... */
d2357 1
a2357 1
	/* Get our ducks in a row for the read. */
d2365 1
a2365 1
	error = biowait(bp);
d2368 2
a2369 1
		memcpy(clabel, bp->b_data, sizeof(RF_ComponentLabel_t));
d2373 4
a2376 2
	} else {
		db1_printf(("Failed to read RAID component label!\n"));
d2379 1
a2379 1
	brelse(bp);
a2381 1

d2383 5
a2387 3
int
raidwrite_component_label(dev_t dev, struct vnode *b_vp,
    RF_ComponentLabel_t *clabel)
d2392 1
a2392 1
	/* Get a block of the appropriate size... */
d2396 1
a2396 1
	/* Get our ducks in a row for the write. */
d2407 1
a2407 1
	error = biowait(bp);
d2410 1
d2412 1
d2418 3
a2420 2
void
rf_markalldirty(RF_Raid_t *raidPtr)
d2428 2
a2429 4
			/*
			 * We don't want to touch (at all) a disk that has
			 * failed.
			 */
d2432 3
a2434 2
				    raidPtr->Disks[r][c].dev,
				    raidPtr->raid_cinfo[r][c].ci_vp, &clabel);
d2436 3
a2438 5
					/*
					 * XXX do something special...
					 * But whatever you do, don't
					 * try to access it !!!
					 */
d2441 11
a2451 11
					clabel.status =
					    raidPtr->Disks[r][c].status;
					raidwrite_component_label(
					    raidPtr->Disks[r][c].dev,
					    raidPtr->raid_cinfo[r][c].ci_vp,
					    &clabel);
#endif
					raidmarkdirty(
					    raidPtr->Disks[r][c].dev,
					    raidPtr->raid_cinfo[r][c].ci_vp,
					    raidPtr->mod_counter);
d2454 1
a2454 1
		}
d2456 1
a2456 1
	/*printf("Component labels marked dirty.\n");*/
d2461 5
a2465 3
			/*
			 * XXX This is where we get fancy and map this spare
			 * into it's correct spot in the array.
d2467 7
a2473 5
			/*
			 * We claim this disk is "optimal" if it's
			 * rf_ds_used_spare, as that means it should be
			 * directly substitutable for the disk it replaced.
			 * We note that too...
d2478 1
a2478 1
					if ((raidPtr->Disks[i][j].spareRow ==
d2488 7
a2494 6

			raidread_component_label(
			    raidPtr->Disks[r][sparecol].dev,
			    raidPtr->raid_cinfo[r][sparecol].ci_vp, &clabel);
			/* Make sure status is noted. */
			clabel.version = RF_COMPONENT_LABEL_VERSION;
d2501 1
a2501 1
			clabel.clean = RF_RAID_DIRTY;	/* Changed in a bit. */
d2504 5
a2508 4
			    raidPtr->Disks[r][sparecol].dev,
			    raidPtr->raid_cinfo[r][sparecol].ci_vp, &clabel);
			raidmarkclean( raidPtr->Disks[r][sparecol].dev,
			    raidPtr->raid_cinfo[r][sparecol].ci_vp);
d2517 3
a2519 1
rf_update_component_labels(RF_Raid_t *raidPtr, int final)
d2530 2
a2531 4
	/*
	 * XXX should do extra checks to make sure things really are clean,
	 * rather than blindly setting the clean bit...
	 */
d2542 1
a2542 1
				/* Make sure status is noted. */
d2544 1
a2544 1
				/* Bump the counter. */
d2547 1
a2547 1
				raidwrite_component_label(
d2552 5
a2556 7
					if (raidPtr->parity_good ==
					    RF_RAID_CLEAN) {
						raidmarkclean(
						    raidPtr->Disks[r][c].dev,
						    raidPtr->
						    raid_cinfo[r][c].ci_vp,
						    raidPtr->mod_counter);
d2559 3
a2561 3
			}
			/* Else we don't touch it... */
		}
d2567 7
a2573 5
			/*
			 * We claim this disk is "optimal" if it's
			 * rf_ds_used_spare, as that means it should be
			 * directly substitutable for the disk it replaced.
			 * We note that too...
d2578 1
a2578 1
					if ((raidPtr->Disks[i][j].spareRow ==
d2588 7
a2594 6

			/* XXX Shouldn't *really* need this... */
			raidread_component_label(
			    raidPtr->Disks[0][sparecol].dev,
			    raidPtr->raid_cinfo[0][sparecol].ci_vp, &clabel);
			/* Make sure status is noted. */
d2604 3
a2606 2
			    raidPtr->Disks[0][sparecol].dev,
			    raidPtr->raid_cinfo[0][sparecol].ci_vp, &clabel);
d2609 3
a2611 5
					raidmarkclean(raidPtr->
					    Disks[0][sparecol].dev,
					    raidPtr->
					    raid_cinfo[0][sparecol].ci_vp,
					    raidPtr->mod_counter);
d2616 1
a2616 1
	/*printf("Component labels updated\n");*/
d2620 4
a2623 1
rf_close_component(RF_Raid_t *raidPtr, struct vnode *vp, int auto_configured)
d2634 3
a2636 4

		} else {
			if (VOP_ISLOCKED(vp))
				VOP_UNLOCK(vp, 0, p);
d2646 2
a2647 1
rf_UnconfigureVnodes(RF_Raid_t *raidPtr)
d2649 1
a2649 1
	int r,c;
d2654 1
a2654 1
	/* We take this opportunity to close the vnodes like we should... */
d2658 1
a2658 2
			db1_printf(("Closing vnode for row: %d col: %d\n",
			    r, c));
d2667 1
a2667 1
		db1_printf(("Closing vnode for spare: %d\n", r));
d2677 3
a2679 2
void
rf_ReconThread(struct rf_recon_req *req)
d2681 1
a2681 1
	int s;
d2691 1
a2691 1
	/* XXX Get rid of this! we don't need it at all... */
d2698 1
a2698 1
	kthread_exit(0);	/* Does not return. */
d2702 2
a2703 1
rf_RewriteParityThread(RF_Raid_t *raidPtr)
d2708 1
a2709 1
	raidPtr->parity_rewrite_in_progress = 1;
d2711 1
d2715 3
a2717 5
		/*
		 * Set the clean bit !  If we shutdown correctly,
		 * the clean bit on each component label will get
		 * set.
		 */
a2720 1
	splx(s);
d2722 1
a2722 1
	/* Anyone waiting for us to stop ?  If so, inform them... */
d2728 1
a2728 1
	kthread_exit(0);	/* Does not return. */
d2733 2
a2734 1
rf_CopybackThread(RF_Raid_t *raidPtr)
d2738 1
a2739 1
	raidPtr->copyback_in_progress = 1;
d2741 1
a2742 1
	splx(s);
d2745 1
a2745 1
	kthread_exit(0);	/* Does not return. */
d2750 2
a2751 1
rf_ReconstructInPlaceThread(struct rf_recon_req *req)
d2756 1
a2756 1

d2766 1
a2766 1
	kthread_exit(0);	/* Does not return. */
d2771 1
a2771 1
rf_find_raid_components(void)
d2773 1
a2773 1
#ifdef	RAID_AUTOCONFIG
d2784 1
a2784 1
#endif	/* RAID_AUTOCONFIG */
d2788 1
a2788 1
	/* Initialize the AutoConfig list. */
d2791 2
a2792 2
#ifdef	RAID_AUTOCONFIG
	/* We begin by trolling through *all* the devices on the system. */
d2794 2
a2795 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
d2797 1
a2797 1
		/* We are only interested in disks... */
d2801 1
a2801 1
		/* We don't care about floppies... */
d2805 2
a2806 5

		/*
		 * We need to find the device_name_to_block_device_major
		 * stuff.
		 */
d2809 1
a2809 1
		/* Get a vnode for the raw partition of this disk. */
d2818 2
a2819 4
			/*
			 * "Who cares."  Continue looking
			 * for something that exists.
			 */
d2825 1
a2825 1
		error = VOP_IOCTL(vp, DIOCGDINFO, (caddr_t)&label,
d2830 1
a2830 1
			 * have errored out (or faked up one).
d2833 1
a2833 1
			    dv->dv_xname, 'a' + RAW_PART, error);
d2836 2
a2837 4
		/*
		 * We don't need this any more.  We'll allocate it again
		 * a little later if we really do...
		 */
d2842 4
a2845 6
			/*
			 * We only support partitions marked as RAID.
			 * Except on sparc/sparc64 where FS_RAID doesn't
			 * fit in the SUN disklabel and we need to look
			 * into each and every partition !!!
			 */
d2868 3
a2870 3
			clabel = (RF_ComponentLabel_t *)
				malloc(sizeof(RF_ComponentLabel_t), M_RAIDFRAME,
				    M_NOWAIT);
d2872 1
a2872 1
				/* XXX CLEANUP HERE. */
d2874 1
a2874 1
				return(NULL); /* XXX probably should panic ? */
d2878 1
a2878 1
				/* Got the label.  Does it look reasonable ? */
d2880 1
a2880 1
				    (clabel->partitionSize <=
d2882 4
a2885 4
#ifdef	RAIDDEBUG
					printf("Component on: %s%c: %d\n",
					    dv->dv_xname, 'a'+i,
					    label.d_partitions[i].p_size);
d2887 3
a2889 5
#endif	/* RAIDDEBUG */
					/*
					 * If it's reasonable, add it,
					 * else ignore it.
					 */
d2892 2
a2893 1
						    M_RAIDFRAME, M_NOWAIT);
d2895 1
a2895 1
						/* XXX should panic ??? */
d2898 1
a2898 1

d2907 1
a2907 1
				}
d2910 1
a2910 1
				/* Cleanup. */
d2917 2
a2918 2
#endif	/* RAID_AUTOCONFIG */
	return(ac_list);
d2920 2
a2921 2

#ifdef	RAID_AUTOCONFIG
d2923 2
a2924 1
rf_reasonable_label(RF_ComponentLabel_t *clabel)
d2926 1
a2926 1

d2931 2
a2932 2
	    clabel->row >=0 &&
	    clabel->column >= 0 &&
d2935 1
a2935 1
	    clabel->row < clabel->num_rows &&
d2939 1
a2939 1
		/* Label looks reasonable enough... */
d2944 1
a2944 1
#endif	/* RAID_AUTOCONFIG */
d2947 2
a2948 1
rf_print_component_label(RF_ComponentLabel_t *clabel)
d2951 2
a2952 1
	    clabel->row, clabel->column, clabel->num_rows, clabel->num_columns);
d2954 4
a2957 3
	    clabel->version, clabel->serial_number, clabel->mod_counter);
	printf("   Clean: %s Status: %d\n", clabel->clean ? "Yes" : "No",
	    clabel->status );
d2959 1
a2959 1
	    clabel->sectPerSU, clabel->SUsPerPU, clabel->SUsPerRU);
d2961 2
a2962 1
	    (char) clabel->parityConfig, clabel->blockSize, clabel->numBlocks);
d2964 2
a2965 2
	printf("   Contains root partition: %s\n", clabel->root_partition ?
	    "Yes" : "No" );
d2968 1
a2968 1
	printf("   Config order: %d\n", clabel->config_order);
d2970 1
d2974 2
a2975 1
rf_create_auto_sets(RF_AutoConfig_t *ac_list)
d2985 2
a2986 4
	/*
	 * Go through the AutoConfig list, and figure out which components
	 * belong to what sets.
	 */
d2989 2
a2990 4
		/*
		 * We're going to putz with ac->next, so save it here
		 * for use at the end of the loop.
		 */
d2994 1
a2994 1
			/* We will need at least this one... */
d2996 2
a2997 2
				malloc(sizeof(RF_ConfigSet_t), M_RAIDFRAME,
				    M_NOWAIT);
d2999 1
a2999 1
				panic("rf_create_auto_sets: No memory!");
d3001 1
a3001 1
			/* This one is easy :) */
d3007 1
a3007 1
			/* Which set does this component fit into ? */
d3011 1
a3011 1
					/* Looks like it matches... */
d3019 1
a3019 1
				/* Didn't find a match above... new set... */
d3021 2
a3022 2
					malloc(sizeof(RF_ConfigSet_t),
					    M_RAIDFRAME, M_NOWAIT);
d3024 1
a3024 1
					panic("rf_create_auto_sets: No memory!");
d3041 3
a3043 1
rf_does_it_fit(RF_ConfigSet_t *cset, RF_AutoConfig_t *ac)
d3047 24
a3070 26
	/*
	 * If this one matches the *first* one in the set, that's good
	 * enough, since the other members of the set would have been
	 * through here too...
	 */
	/*
	 * Note that we are not checking partitionSize here...
	 *
	 * Note that we are also not checking the mod_counters here.
	 * If everything else matches except the mod_counter, that's
	 * good enough for this test.  We will deal with the mod_counters
	 * a little later in the autoconfiguration process.
	 *
	 *  (clabel1->mod_counter == clabel2->mod_counter) &&
	 *
	 * The reason we don't check for this is that failed disks
	 * will have lower modification counts.  If those disks are
	 * not added to the set they used to belong to, then they will
	 * form their own set, which may result in 2 different sets,
	 * for example, competing to be configured at raid0, and
	 * perhaps competing to be the root filesystem set.  If the
	 * wrong ones get configured, or both attempt to become /,
	 * weird behaviour and or serious lossage will occur.  Thus we
	 * need to bring them into the fold here, and kick them out at
	 * a later point.
	 */
d3089 1
a3089 1
		/* If it get's here, it almost *has* to be a match. */
d3091 2
a3092 1
		/* It's not consistent with somebody in the set...  Punt. */
d3095 1
a3095 1
	/* All was fine.. It must fit... */
d3100 2
a3101 1
rf_have_enough_components(RF_ConfigSet_t *cset)
d3114 1
d3116 2
a3117 5

	/*
	 * Check to see that we have enough 'live' components
	 * of this set.  If so, we can configure it if necessary.
	 */
d3123 1
a3123 1
	/* XXX Check for duplicate components !?!?!? */
d3151 1
a3151 1
				    (ac->clabel->column == c) &&
d3153 2
a3154 2
					/* It's this one... */
#ifdef	RAIDDEBUG
d3156 2
a3157 2
					    ac->devname,r,c);
#endif	/* RAIDDEBUG */
d3164 4
a3167 6
				/*
				 * Special case for RAID 1, especially
				 * where there are more than 2
				 * components (where RAIDframe treats
				 * things a little differently :( )
				 */
d3169 1
a3169 1
					if (c%2 == 0) {	/* Even component. */
d3171 5
a3175 7
					} else {	/*
							 * Odd component.
							 * If we're failed,
							 * and so is the even
							 * component, it's
							 * "Good Night, Charlie"
							 */
d3181 1
a3181 1
					/* Normal accounting. */
d3186 3
a3188 5
				/*
				 * Just did an even component, and we didn't
				 * bail... Reset the even_pair_failed flag,
				 * and go on to the next component...
				 */
d3199 2
a3200 2
		/* XXX This needs to be made *much* more general. */
		/* Too many failures. */
d3203 2
a3204 4
	/*
	 * Otherwise, all is well, and we've got enough to take a kick
	 * at autoconfiguring this set.
	 */
d3209 4
a3212 2
rf_create_configuration(RF_AutoConfig_t *ac, RF_Config_t *config,
    RF_Raid_t *raidPtr)
d3219 1
a3219 1
	/* 1. Fill in the common stuff. */
d3222 1
a3222 1
	config->numSpare = 0;	/* XXX Should this be set here ? */
d3230 1
a3230 1
	config->layoutSpecificSize = 0;	/* XXX ?? */
d3233 2
a3234 4
		/*
		 * row/col values will be in range due to the checks
		 * in reasonable_label().
		 */
d3236 1
a3236 1
		    ac->devname);
d3244 4
a3247 1
#ifdef	RAID_DEBUG_ALL
d3249 9
a3257 15
#ifdef	RF_DBG_OPTION
#undef	RF_DBG_OPTION
#endif	/* RF_DBG_OPTION */

#ifdef	__STDC__
#define	RF_DBG_OPTION(_option_,_val_)	do {				\
	snprintf(&(config->debugVars[i++][0]), 50, "%s %ld",		\
	    #_option_, _val_);						\
} while (0)
#else	/* __STDC__ */
#define	RF_DBG_OPTION(_option_,_val_)	do {				\
	snprintf(&(config->debugVars[i++][0]), 50, "%s %ld",		\
	    "/**/_option_/**/", _val_);					\
} while (0)
#endif	/* __STDC__ */
d3261 75
a3335 84
/*	RF_DBG_OPTION(accessDebug, 0);					*/
/*	RF_DBG_OPTION(accessTraceBufSize, 0);				*/
	RF_DBG_OPTION(cscanDebug, 1);		/* Debug CSCAN sorting.	*/
	RF_DBG_OPTION(dagDebug, 1);
/*	RF_DBG_OPTION(debugPrintUseBuffer, 0);				*/
	RF_DBG_OPTION(degDagDebug, 1);
	RF_DBG_OPTION(disableAsyncAccs, 1);
	RF_DBG_OPTION(diskDebug, 1);
	RF_DBG_OPTION(enableAtomicRMW, 0);
		/*
		 * This debug variable enables locking of the
		 * disk arm during small-write operations.
		 * Setting this variable to anything other than
		 * 0 will result in deadlock.  (wvcii)
		 */
	RF_DBG_OPTION(engineDebug, 1);
	RF_DBG_OPTION(fifoDebug, 1);		/* Debug fifo queueing.	*/
/*	RF_DBG_OPTION(floatingRbufDebug, 1);				*/
/*	RF_DBG_OPTION(forceHeadSepLimit, -1);				*/
/*	RF_DBG_OPTION(forceNumFloatingReconBufs, -1);			*/
		/*
		 * Wire down the number of extra recon buffers
		 * to use.
		 */
/*	RF_DBG_OPTION(keepAccTotals, 1);				*/
		/* Turn on keep_acc_totals. */
	RF_DBG_OPTION(lockTableSize, RF_DEFAULT_LOCK_TABLE_SIZE);
	RF_DBG_OPTION(mapDebug, 1);
	RF_DBG_OPTION(maxNumTraces, -1);

/*	RF_DBG_OPTION(memChunkDebug, 1);				*/
/*	RF_DBG_OPTION(memDebug, 1);					*/
/*	RF_DBG_OPTION(memDebugAddress, 1);				*/
/*	RF_DBG_OPTION(numBufsToAccumulate, 1);				*/
		/*
		 * Number of buffers to accumulate before
		 * doing XOR.
		 */
	RF_DBG_OPTION(prReconSched, 0);
	RF_DBG_OPTION(printDAGsDebug, 1);
	RF_DBG_OPTION(printStatesDebug, 1);
	RF_DBG_OPTION(protectedSectors, 64L);
		/*
		 * Number of sectors at start of disk to exclude
		 * from RAID address space.
		 */
	RF_DBG_OPTION(pssDebug, 1);
	RF_DBG_OPTION(queueDebug, 1);
	RF_DBG_OPTION(quiesceDebug, 1);
	RF_DBG_OPTION(raidSectorOffset, 0);
		/*
		 * Value added to all incoming sectors to debug
		 * alignment problems.
		 */
	RF_DBG_OPTION(reconDebug, 1);
	RF_DBG_OPTION(reconbufferDebug, 1);
	RF_DBG_OPTION(scanDebug, 1);		/* Debug SCAN sorting.	*/
	RF_DBG_OPTION(showXorCallCounts, 0);
		/* Show n-way Xor call counts. */
	RF_DBG_OPTION(shutdownDebug, 1);	/* Show shutdown calls.	*/
	RF_DBG_OPTION(sizePercentage, 100);
	RF_DBG_OPTION(sstfDebug, 1);
		/* Turn on debugging info for sstf queueing. */
	RF_DBG_OPTION(stripeLockDebug, 1);
	RF_DBG_OPTION(suppressLocksAndLargeWrites, 0);
	RF_DBG_OPTION(suppressTraceDelays, 0);
	RF_DBG_OPTION(useMemChunks, 1);
	RF_DBG_OPTION(validateDAGDebug, 1);
	RF_DBG_OPTION(validateVisitedDebug, 1);
		/* XXX turn to zero by default ? */
	RF_DBG_OPTION(verifyParityDebug, 1);
	RF_DBG_OPTION(debugKernelAccess, 1);
		/* DoAccessKernel debugging. */

#if RF_INCLUDE_PARITYLOGGING > 0
	RF_DBG_OPTION(forceParityLogReint, 0);
	RF_DBG_OPTION(numParityRegions, 0);
		/* Number of regions in the array. */
	RF_DBG_OPTION(numReintegrationThreads, 1);
	RF_DBG_OPTION(parityLogDebug, 1);
		/* If nonzero, enables debugging of parity logging. */
	RF_DBG_OPTION(totalInCoreLogCapacity, 1024 * 1024);
		/* Target bytes available for in-core logs. */
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d3337 1
a3337 1
#endif	/* RAID_DEBUG_ALL */
d3341 3
a3343 1
rf_set_autoconfig(RF_Raid_t *raidPtr, int new_value)
d3353 1
a3353 1
			if (raidPtr->Disks[row][column].status ==
d3367 3
a3369 1
rf_set_rootpartition(RF_Raid_t *raidPtr, int new_value)
d3379 1
a3379 1
			if (raidPtr->Disks[row][column].status ==
d3393 2
a3394 1
rf_release_all_vps(RF_ConfigSet_t *cset)
d3397 1
a3397 1

d3400 1
a3400 1
		/* Close the vp, and give it back. */
d3412 2
a3413 1
rf_cleanup_config_set(RF_ConfigSet_t *cset)
d3417 1
a3417 1

d3421 1
a3421 1
		/* Nuke the label. */
d3423 1
a3423 1
		/* Cleanup the config structure. */
d3425 1
a3425 1
		/* "next..." */
d3428 1
a3428 1
	/* And, finally, nuke the config set. */
d3434 3
a3436 1
raid_init_component_label(RF_Raid_t *raidPtr, RF_ComponentLabel_t *clabel)
d3438 2
a3439 2
	/* Current version number. */
	clabel->version = RF_COMPONENT_LABEL_VERSION;
d3444 3
a3446 3
	clabel->clean = RF_RAID_DIRTY;	/* Not clean. */
	clabel->status = rf_ds_optimal;	/* "It's good !" */

d3454 1
a3454 1
	/* XXX Not portable. */
d3464 3
a3466 1
rf_auto_config_set(RF_ConfigSet_t *cset, int *unit)
d3473 1
a3473 1
	db1_printf(("RAID autoconfigure\n"));
d3478 1
a3478 1
	/* 1. Create a config structure. */
d3480 3
a3482 2
	config = (RF_Config_t *)malloc(sizeof(RF_Config_t), M_RAIDFRAME,
	    M_NOWAIT);
d3485 1
a3485 1
				/* XXX Do something more intelligent here. */
d3491 1
a3491 1
	/* XXX raidID needs to be set correctly... */
d3493 5
a3497 5
	/*
	 * 2. Figure out what RAID ID this one is supposed to live at.
	 * See if we can get the same RAID dev that it was configured
	 * on last time...
	 */
d3501 1
a3501 1
		/* Let's not wander off into lala land. */
d3506 5
a3510 5
		/*
		 * Nope...  Go looking for an alternative...
		 * Start high so we don't immediately use raid0 if that's
		 * not taken.
		 */
d3514 1
a3514 1
				/* We can use this one ! */
d3521 1
a3521 1
		/* Punt... */
d3526 1
d3529 1
a3529 1
	/* XXX All this stuff should be done SOMEWHERE ELSE ! */
d3533 1
a3533 1
	/* 3. Build the configuration structure. */
d3536 1
a3536 1
	/* 4. Do the configuration. */
d3538 1
a3538 1

d3544 1
a3544 1
		raidPtrs[raidID]->autoconfigure = 1; /* XXX Do this here ? */
d3546 2
a3547 4
			/*
			 * Everything configured just fine.  Make a note
			 * that this set is eligible to be root.
			 */
d3549 2
a3550 2
			/* XXX Do this here ? */
			raidPtrs[raidID]->root_partition = 1;
d3554 1
a3554 8
	printf(": (%s) total number of sectors is %lu (%lu MB)%s\n",
	    (raidPtrs[raidID]->Layout).map->configName,
	    (unsigned long) raidPtrs[raidID]->totalSectors,
	    (unsigned long) (raidPtrs[raidID]->totalSectors / 1024 *
	    (1 << raidPtrs[raidID]->logBytesPerSector) / 1024),
	    raidPtrs[raidID]->root_partition ? " as root" : "");

	/* 5. Cleanup. */
d3556 1
a3556 1

d3562 2
a3563 1
rf_disk_unbusy(RF_RaidAccessDesc_t *desc)
d3568 1
a3568 1
	disk_unbusy(&raid_softc[desc->raidPtr->raidid].sc_dkdev,
@


1.9.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.9.2.4 2003/03/28 00:38:28 niklas Exp $	*/
d441 1
a441 2
		snprintf(raidrootdev[raidID].dv_xname,
		    sizeof raidrootdev[raidID].dv_xname,"raid%d",raidID);
d1649 1
a1649 1
	snprintf(rs->sc_xname, sizeof rs->sc_xname, "raid%d", unit);
d2884 2
a2885 3
					snprintf(ac->devname,
						 sizeof ac->devname, "%s%c",
						 dv->dv_xname, 'a'+i);
d3216 1
a3216 1
	strlcpy(config->diskQueueType,"fifo", sizeof config->diskQueueType);
d3225 2
a3226 3
		strlcpy(config->devnames[ac->clabel->row][ac->clabel->column],
		    ac->devname,
		    sizeof config->devnames[ac->clabel->row][ac->clabel->column]);
@


1.9.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: rf_openbsdkintf.c,v 1.9.2.5 2003/05/13 19:35:10 ho Exp $	*/
d57 5
a61 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d205 1
a205 1
	NULL, "raid", DV_DISK
@


1.9.2.8
log
@Merge with the trunk
@
text
@d3566 1
a3566 2
			    (bp->b_bcount - bp->b_resid),
			    (bp->b_flags & B_READ));
@


1.8
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_openbsdkintf.c,v 1.7 1999/12/03 22:38:11 art Exp $	*/
/*	$NetBSD: rf_netbsdkintf.c,v 1.39 2000/01/06 02:06:41 oster Exp $	*/
d137 1
a154 2
#define db0_printf(a) printf a
#define db_printf(a) do if (rf_kdebug_level > 0) printf a; while(0)
a155 4
#define db2_printf(a) do if (rf_kdebug_level > 1) printf a; while(0)
#define db3_printf(a) do if (rf_kdebug_level > 2) printf a; while(0)
#define db4_printf(a) do if (rf_kdebug_level > 3) printf a; while(0)
#define db5_printf(a) do if (rf_kdebug_level > 4) printf a; while(0)
a156 1
#define db0_printf(a) printf a
a157 4
#define db2_printf(a) (void)0
#define db3_printf(a) (void)0
#define db4_printf(a) (void)0
#define db5_printf(a) (void)0
d175 1
a175 3

int raidmarkclean(dev_t dev, struct vnode *b_vp, int);
int raidmarkdirty(dev_t dev, struct vnode *b_vp, int);
a178 5

void	rf_DiskIOComplete(RF_DiskQueue_t *, RF_DiskQueueData_t *, int);
void	rf_CopybackReconstructedData(RF_Raid_t *raidPtr);
int	raidinit __P((dev_t,RF_Raid_t *,int));

a186 4
int raidwrite_component_label(dev_t, struct vnode *, RF_ComponentLabel_t *);
int raidread_component_label(dev_t, struct vnode *, RF_ComponentLabel_t *);
void rf_update_component_labels( RF_Raid_t *);

a257 1
int	raidlookup __P((char *, struct proc *p, struct vnode **));
d636 3
d650 1
d655 1
d700 1
a701 4
		/* Configure the system */

		db3_printf(("rf_ioctl: RAIDFRAME_CONFIGURE\n"));

a708 3
			db3_printf((
			    "rf_ioctl: ENOMEM for config. Code is %d\n",
			    retcode));
a714 2
			db3_printf(("rf_ioctl: retcode=%d copyin.1\n",
			    retcode));
a725 1
				db3_printf(("rf_ioctl: EINVAL %d\n", retcode));
a731 1
				db3_printf(("rf_ioctl: ENOMEM %d\n", retcode));
d738 2
a739 3
				RF_Free(specific_buf, k_cfg->layoutSpecificSize);
				db3_printf(("rf_ioctl: retcode=%d copyin.2\n",
				    retcode));
d753 1
a753 1
		raidPtrs[unit]->raidid = unit;
d755 1
a755 1
		retcode = rf_Configure(raidPtrs[unit], k_cfg);
d757 1
a757 4
		/* allow this many simultaneous IO's to this RAID device */
		raidPtrs[unit]->openings = RAIDOUTSTANDING;

		/* XXX should be moved to rf_Configure() */
d759 9
a767 3
		raidPtrs[unit]->copyback_in_progress = 0;
		raidPtrs[unit]->parity_rewrite_in_progress = 0;
		raidPtrs[unit]->recon_in_progress = 0;
d769 2
a770 3
		if (retcode == 0) {
			retcode = raidinit(dev, raidPtrs[unit],unit);
			rf_markalldirty( raidPtrs[unit] );
a778 3
		db3_printf(("rf_ioctl: retcode=%d RAIDFRAME_CONFIGURE\n",
		    retcode));

d801 1
a801 1
		retcode = rf_Shutdown(raidPtrs[unit]);
d816 1
a816 3
		   by row,column in component_label
		   XXX need to sanity check these values!!! 
		   */
d838 2
a839 2
		if ((row < 0) || (row >= raidPtrs[unit]->numRow) ||
		    (column < 0) || (column >= raidPtrs[unit]->numCol)) {
d844 2
a845 2
                              raidPtrs[unit]->Disks[row][column].dev, 
			      raidPtrs[unit]->raid_cinfo[row][column].ci_vp, 
d877 2
a878 2
		if ((row < 0) || (row >= raidPtrs[unit]->numRow) ||
		    (column < 0) || (column >= raidPtrs[unit]->numCol)) {
d886 2
a887 2
                            raidPtrs[unit]->Disks[row][column].dev, 
			    raidPtrs[unit]->raid_cinfo[row][column].ci_vp, 
d901 1
a901 1
		raidPtrs[unit]->serial_number = component_label->serial_number;
d905 3
a907 3
		ci_label.mod_counter = raidPtrs[unit]->mod_counter;
		ci_label.num_rows = raidPtrs[unit]->numRow;
		ci_label.num_columns = raidPtrs[unit]->numCol;
d911 1
a911 1
		for(row=0;row<raidPtrs[unit]->numRow;row++) {
d913 1
a913 1
			for(column=0;column<raidPtrs[unit]->numCol;column++) {
d916 2
a917 2
				  raidPtrs[unit]->Disks[row][column].dev, 
				  raidPtrs[unit]->raid_cinfo[row][column].ci_vp, 
d926 1
a926 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d928 1
a928 1
			raidPtrs[unit]->parity_good = RF_RAID_CLEAN;
d933 1
a933 1
		if (raidPtrs[unit]->parity_rewrite_in_progress == 1) {
d938 1
a938 3
		/* borrow the thread of the requesting process */

		retcode = RF_CREATE_THREAD(raidPtrs[unit]->parity_rewrite_thread,
d940 1
a940 1
					   raidPtrs[unit],"raid_parity");
d949 1
a949 1
		retcode = rf_add_hot_spare(raidPtrs[unit], &hot_spare);
d957 1
a957 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d962 1
a962 1
		if (raidPtrs[unit]->recon_in_progress == 1) {
d973 2
a974 2
		if ((row < 0) || (row >= raidPtrs[unit]->numRow) ||
		    (column < 0) || (column >= raidPtrs[unit]->numCol)) {
d982 1
a982 1
		rrcopy->raidPtr = (void *) raidPtrs[unit];
d986 1
a986 1
		retcode = RF_CREATE_THREAD(raidPtrs[unit]->recon_thread,
d993 26
a1018 19
		{
			RF_Raid_t *raid = raidPtrs[unit];
			RF_DeviceConfig_t *cfg, **ucfgp;
			int i, j, d;
			
			if (!raid->valid)
				return (ENODEV);
			ucfgp = (RF_DeviceConfig_t **)data;
			RF_Malloc(cfg, sizeof (RF_DeviceConfig_t),
			    (RF_DeviceConfig_t *));
			if (cfg == NULL)
				return (ENOMEM);
			bzero((char *)cfg, sizeof(RF_DeviceConfig_t));
			cfg->rows = raid->numRow;
			cfg->cols = raid->numCol;
			cfg->ndevs = raid->numRow * raid->numCol;
			if (cfg->ndevs >= RF_MAX_DISKS) {
				RF_Free(cfg, sizeof(RF_DeviceConfig_t));
				return (ENOMEM);
a1019 21
			cfg->nspares = raid->numSpare;
			if (cfg->nspares >= RF_MAX_DISKS) {
				RF_Free(cfg, sizeof(RF_DeviceConfig_t));
				return (ENOMEM);
			}
			cfg->maxqdepth = raid->maxQueueDepth;
			d = 0;
			for(i = 0; i < cfg->rows; i++) {
				for(j = 0; j < cfg->cols; j++) {
					cfg->devs[d] = raid->Disks[i][j];
					d++;
				}
			}
			for(j = cfg->cols, i = 0; i < cfg->nspares; i++, j++) {
				cfg->spares[i] = raid->Disks[0][j];
			}
			retcode = copyout((caddr_t)cfg, (caddr_t)*ucfgp,
			    sizeof (RF_DeviceConfig_t));
			RF_Free(cfg, sizeof (RF_DeviceConfig_t));
			
			return (retcode);
d1021 9
a1029 1
		break;
d1031 1
a1031 1
		*(int *) data = raidPtrs[unit]->parity_good;
d1034 8
a1041 18
		{
			RF_Raid_t *raid = raidPtrs[unit];
			
			bzero(&raid->acc_totals, sizeof(raid->acc_totals));
			return (0);
		}
	break;
	
	case RAIDFRAME_GET_ACCTOTALS:
		{
			RF_AccTotals_t *totals = (RF_AccTotals_t *)data;
			RF_Raid_t *raid = raidPtrs[unit];
			
			*totals = raid->acc_totals;
			return (0);
		}
	break;
	
d1043 3
a1045 9
		{
			RF_Raid_t *raid = raidPtrs[unit];
			int *keep = (int *)data;
			
			raid->keep_acc_totals = *keep;
			return (0);
		}
	break;
	
d1047 1
a1047 1
		*(int *) data = raidPtrs[unit]->totalSectors;
d1054 2
a1055 2
		if (rr->row < 0 || rr->row >= raidPtrs[unit]->numRow ||
		    rr->col < 0 || rr->col >= raidPtrs[unit]->numCol)
d1069 1
a1069 1
		rrcopy->raidPtr = (void *)raidPtrs[unit];
d1071 1
a1071 1
		retcode = RF_CREATE_THREAD(raidPtrs[unit]->recon_thread,
d1081 6
a1086 1
		if (raidPtrs[unit]->copyback_in_progress == 1) {
d1091 1
a1091 1
		retcode = RF_CREATE_THREAD(raidPtrs[unit]->copyback_thread,
d1093 1
a1093 1
					   raidPtrs[unit],"raid_copyback");
d1098 4
d1103 1
a1103 1
		if (raidPtrs[unit]->status[row] != rf_rs_reconstructing)
d1107 1
a1107 1
			    raidPtrs[unit]->reconControl[row]->percentComplete;
d1110 1
a1110 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d1114 2
a1115 2
		if (raidPtrs[unit]->parity_rewrite_in_progress == 1) {
			*(int *) data = 100 * raidPtrs[unit]->parity_rewrite_stripes_done / raidPtrs[unit]->Layout.numStripe;
d1122 1
a1122 1
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0) {
d1126 2
a1127 2
		if (raidPtrs[unit]->copyback_in_progress == 1) {
			*(int *) data = 100 * raidPtrs[unit]->copyback_stripes_done / raidPtrs[unit]->Layout.numStripe;
d1182 1
a1182 1
		retcode = rf_SetSpareTable(raidPtrs[unit],*(void **)data);
d1203 1
a1203 1
	if (!raidPtrs[unit]->valid)
d1253 1
a1253 1
  		raidgetdefaultlabel(raidPtrs[unit], rs,
d1743 1
a1743 1
	lp->d_nsectors = 1024 * (1024 / raidPtr->bytesPerSector);
d1745 2
a1746 1
	lp->d_ncylinders = raidPtr->totalSectors / lp->d_nsectors;
@


1.7
log
@Init b_dep so that soft updates work.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_openbsdkintf.c,v 1.6 1999/08/03 13:56:37 peter Exp $	*/

a152 5
#define RFK_BOOT_NONE 0
#define RFK_BOOT_GOOD 1
#define RFK_BOOT_BAD  2
static int rf_kbooted = RFK_BOOT_NONE;

a179 8
/* used to communicate reconstruction requests */
static struct rf_recon_req *recon_queue = NULL;

decl_simple_lock_data(, recon_queue_mutex)

#define LOCK_RECON_Q_MUTEX() simple_lock(&recon_queue_mutex)
#define UNLOCK_RECON_Q_MUTEX() simple_unlock(&recon_queue_mutex)

a185 9
#define Dprintf0(s)       if (rf_queueDebug) \
	rf_debug_printf(s,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf1(s,a)     if (rf_queueDebug) \
	rf_debug_printf(s,a,NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf2(s,a,b)   if (rf_queueDebug) \
	rf_debug_printf(s,a,b,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf3(s,a,b,c) if (rf_queueDebug) \
	rf_debug_printf(s,a,b,c,NULL,NULL,NULL,NULL,NULL)

d232 1
d248 12
a259 1
 * kernel memory, especially on writes...
d263 1
a263 1
#define RAIDOUTSTANDING   10
d283 7
a319 1
	recon_queue = NULL;
a328 2
	rf_kbooted = RFK_BOOT_GOOD;

d344 3
d350 3
a352 1
			printf("raidPtrs[%d] is NULL\n", raidID);
d538 1
d541 7
a547 13
	db1_printf(("Strategy: 0x%x 0x%x\n", bp, bp->b_data));
	db1_printf(("Strategy(2): bp->b_bufsize %d\n", (int)bp->b_bufsize));
	db1_printf(("bp->b_count=%d\n", (int)bp->b_bcount));
	db1_printf(("bp->b_resid=%d\n", (int)bp->b_resid));
	db1_printf(("bp->b_blkno=%d\n", (int)bp->b_blkno));

	if (bp->b_flags & B_READ)
		db1_printf(("READ\n"));
	else
		db1_printf(("WRITE\n"));

	if (rf_kbooted != RFK_BOOT_GOOD)
		return;
a583 1
	/* XXX splbio() needed? */
d585 10
a594 1
	db1_printf(("Beginning strategy...\n"));
d596 2
a597 8
	bp->b_resid = 0;
	bp->b_error =
	    rf_DoAccessKernel(raidPtrs[raidID], bp, NULL, NULL, NULL);
	if (bp->b_error) {
		bp->b_flags |= B_ERROR;
		db1_printf(
		    ("bp->b_flags HAS B_ERROR SET!!!: %d\n", bp->b_error));
	}
a598 2
	db1_printf(("Strategy exiting: 0x%x 0x%x %d %d\n", bp, bp->b_data,
	    (int)bp->b_bcount, (int)bp->b_resid));
a656 7
#if 0
	int r, c;
#endif
	/* struct raid_ioctl *ccio = (struct ccd_ioctl *)data; */

	/* struct ccdbuf *cbp; */
	/* struct raidbuf *raidbp; */
a661 1
	int s;
d702 1
a702 1
	case RAIDFRAME_CHECKRECON:
d709 3
d737 1
d750 1
d764 2
a779 9
		db1_printf(("Considering configuring the system.:%d 0x%x\n",
		    unit, p));

		/*
		 * We need the pointer to this a little deeper,
		 * so stash it here...
		 */
		raidPtrs[unit]->proc = p;

d788 6
a829 5
		if (rf_debugKernelAccess) {
			printf("call shutdown\n");
		}
		raidPtrs[unit]->proc = p; /* XXX Necessary evil */

a831 2
		db1_printf(("Done main shutdown\n"));

d862 1
a866 4
		printf("Row: %d\n",row);
		if (row > raidPtrs[unit]->numRow) {
			row = 0; /* XXX */
		}
d868 5
a872 4
		printf("Column: %d\n",column);
		if (column > raidPtrs[unit]->numCol) {
			column = 0; /* XXX */
		}
d908 3
a910 2
		if ((row < 0) || (row > raidPtrs[unit]->numRow) ||
		    (column < 0) || (column > raidPtrs[unit]->numCol)) {
d963 6
a969 3
		raidPtrs[unit]->proc = p; /* Blah... :-p GO */
		retcode = rf_RewriteParity(raidPtrs[unit]);
		/* return I/O Error if the parity rewrite fails */
d971 4
a974 8
		if (retcode) {
			retcode = EIO;		
		} else {
			/* set the clean bit!  If we shutdown correctly,
			 the clean bit on each component label will get
			 set */
			raidPtrs[unit]->parity_good = RF_RAID_CLEAN;
		}
a981 1
		raidPtrs[unit]->proc = p;	/* Blah... :-p GO */
d989 11
d1006 2
a1007 2
		if ((row < 0) || (row > raidPtrs[unit]->numRow) ||
		    (column < 0) || (column > raidPtrs[unit]->numCol)) {
a1009 5
		printf("Attempting a rebuild in place\n");
		s = splbio();
		raidPtrs[unit]->proc = p;	/* Blah... :-p GO */
		retcode = rf_ReconstructInPlace(raidPtrs[unit], row, column);
		splx(s);
d1011 3
a1013 1
		return (retcode);
d1015 7
a1021 6
#if 0 /* XXX not supported yet (ever?) */
	case RAIDFRAME_TUR:
		/*
		 * Issue a test-unit-ready through raidframe to the
		 * indicated device.
		 */
a1022 2
		/* debug only */
		retcode = rf_SCSI_DoTUR(0, 0, 0, 0, *(dev_t *)data);
a1023 1
#endif
d1043 1
a1043 1
				cfg->ndevs = 0;
d1048 1
a1048 1
				cfg->nspares = 0;
d1068 4
a1071 2
	break;
	
a1104 4
#define RAIDFRAME_RECON 1
		/* XXX The above should probably be set somewhere else!! GO */
#if RAIDFRAME_RECON > 0

d1121 2
d1126 3
a1128 6
		LOCK_RECON_Q_MUTEX();
		rrcopy->next = recon_queue;
		recon_queue = rrcopy;
		wakeup(&recon_queue);
		UNLOCK_RECON_Q_MUTEX();
		
d1136 9
a1144 6
		/* Borrow the current thread to get this done */
		raidPtrs[unit]->proc = p; /* ICK.. but needed :-p  GO */
		s = splbio();
 		rf_CopybackReconstructedData(raidPtrs[unit]);
		splx(s);
		return (0);
d1147 2
a1148 4
	case RAIDFRAME_CHECKRECON:
		row = *(int *)data;
		if (row < 0 || row >= raidPtrs[unit]->numRow)
			return (EINVAL);
d1155 24
a1178 1
		
a1243 2
#endif	 /* RAIDFRAME_RECON > 0 */

a1256 2
		db1_printf(
		    ("DIOCGDINFO %d %d\n", (int)dev, (int)DISKPART(dev)));
a1260 2
		db1_printf(
		    ("DIOCGPART: %d %d\n", (int)dev, (int)DISKPART(dev)));
a1266 1
		db1_printf(("DIOCWDINFO\n"));
a1267 1
		db1_printf(("DIOCSDINFO\n"));
a1290 1
		db1_printf(("DIOCWLABEL\n"));
d1297 8
d1306 1
a1306 1
		retcode = ENOTTY; /* XXXX ?? OR EINVAL ? */
a1321 2
	/*	int ix; */
	/*	struct raidbuf *raidbp; */
a1352 41
 * This kernel thread never exits.  It is created once, and persists
 * until the system reboots.
 */
void
rf_ReconKernelThread()
{
	struct rf_recon_req *req;
	int s;

	/*
	 * XXX not sure what spl() level we should be at here...
	 * probably splbio()
	 */
	s = splbio();

	while (1) {
		/* grab the next reconstruction request from the queue */
		LOCK_RECON_Q_MUTEX();
		while (!recon_queue) {
			UNLOCK_RECON_Q_MUTEX();
			tsleep(&recon_queue, PRIBIO,
			       "raidframe recon", 0);
			LOCK_RECON_Q_MUTEX();
		}
		req = recon_queue;
		recon_queue = recon_queue->next;
		UNLOCK_RECON_Q_MUTEX();

		/*
		 * If flags specifies that we should start recon, this call
		 * will not return until reconstruction completes, fails, or
		 * is aborted.
		 */
		rf_FailDisk((RF_Raid_t *)req->raidPtr, req->row, req->col,
		    ((req->flags&RF_FDFLAGS_RECON) ? 1 : 0));

		RF_Free(req, sizeof *req);
	}
}

/*
d1359 2
a1376 5
#if 0
		mpsleep(&rf_sparet_resp_queue, PZERO, "sparet resp", 0,
		    (void *)simple_lock_addr(rf_sparet_wait_mutex),
		    MS_LOCK_SIMPLE);
#endif
d1394 2
d1397 2
a1398 2
int
rf_DoAccessKernel(raidPtr, bp, flags, cbFunc, cbArg)
a1399 4
	struct buf *bp;
	RF_RaidAccessFlags_t flags;
	void (*cbFunc)(struct buf *);
	void *cbArg;
d1409 2
a1410 2

	/* XXX The dev_t used here should be for /dev/[r]raid* !!! */
a1414 31
	/*
	 * Ok, for the bp we have here, bp->b_blkno is relative to the
	 * partition.. Need to make it absolute to the underlying device..
	 */
	blocknum = bp->b_blkno;
	if (DISKPART(bp->b_dev) != RAW_PART) {
		pp = &rs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];
		blocknum += pp->p_offset;
		db1_printf(
		    ("updated: %d %d\n", DISKPART(bp->b_dev), pp->p_offset));
	} else {
		db1_printf(("Is raw..\n"));
	}
	db1_printf(("Blocks: %d, %d\n", (int)bp->b_blkno, (int)blocknum));
	db1_printf(("bp->b_bcount = %d\n", (int)bp->b_bcount));
	db1_printf(("bp->b_resid = %d\n", (int)bp->b_resid));

	/*
	 * *THIS* is where we adjust what block we're going to... but
	 * DO NOT TOUCH bp->b_blkno!!!
	 */
	raid_addr = blocknum;
	
	num_blocks = bp->b_bcount >> raidPtr->logBytesPerSector;
	pb = (bp->b_bcount&raidPtr->sectorMask) ? 1 : 0;
	sum = raid_addr + num_blocks + pb;
	if (1 || rf_debugKernelAccess) {
		db1_printf(("raid_addr=%d sum=%d num_blocks=%d(+%d) (%d)\n",
		    (int)raid_addr, (int)sum, (int)num_blocks, (int)pb,
		    (int)bp->b_resid));
	}
d1416 78
d1495 10
a1504 8
	if ((sum > raidPtr->totalSectors) || (sum < raid_addr) ||
	    (sum < num_blocks) || (sum < pb)) {
		bp->b_error = ENOSPC;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
		return (bp->b_error);
	}
d1506 6
a1511 13
	/*
	 * XXX rf_DoAccess() should do this, not just DoAccessKernel()
	 */
	if (bp->b_bcount & raidPtr->sectorMask) {
		bp->b_error = EINVAL;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		biodone(bp);
		return (bp->b_error);
	}
	db1_printf(("Calling DoAccess..\n"));

	/* Put a throttle on the number of requests we handle simultanously */
a1512 1
	RF_LOCK_MUTEX(raidPtr->mutex);
a1513 3
	while(raidPtr->openings <= 0) {
		RF_UNLOCK_MUTEX(raidPtr->mutex);
		(void)tsleep(&raidPtr->openings, PRIBIO, "rfdwait", 0);
a1515 2
	raidPtr->openings--;

a1516 17

 	/*
	 * Everything is async.
 	 */
 	do_async = 1;

	/*
	 * Don't ever condition on bp->b_flags & B_WRITE.
	 * always condition on B_READ instead.
	 */
	retcode = rf_DoAccess(raidPtr,
	    (bp->b_flags & B_READ) ? RF_IO_TYPE_READ : RF_IO_TYPE_WRITE,
	    0, raid_addr, num_blocks, bp->b_un.b_addr, bp, NULL, NULL,
	    RF_DAG_NONBLOCKING_IO|flags, NULL, cbFunc, cbArg);
	db1_printf(("After call to DoAccess: 0x%x 0x%x %d\n", bp, bp->b_data,
	    (int)bp->b_resid));
	return (retcode);
d1531 4
d1584 2
d1649 1
d1669 1
a1669 1
	s = splbio(); /* XXX */
a1673 1
	db1_printf(("bp=0x%x\n", bp));
a1677 2
		db1_printf(
		    ("Setting bp->b_flags!!! %d\n", raidbp->rf_buf.b_error));
a1682 8
	db1_printf(("raidbp->rf_buf.b_bcount=%d\n",
	    (int)raidbp->rf_buf.b_bcount));
	db1_printf(("raidbp->rf_buf.b_bufsize=%d\n",
	    (int)raidbp->rf_buf.b_bufsize));
	db1_printf(("raidbp->rf_buf.b_resid=%d\n",
	    (int)raidbp->rf_buf.b_resid));
	db1_printf(("raidbp->rf_buf.b_data=0x%x\n", raidbp->rf_buf.b_data));

a1703 1
#if 1
a1725 1
#endif
a1730 3
		db1_printf((
		    "Disk is no longer busy for this buffer... %d %ld %ld\n",
		    unit, bp->b_resid, bp->b_bcount));
a1732 2
	} else {
		db1_printf(("b_resid is still %ld\n", bp->b_resid));
a1736 1
	/* printf("Exiting rf_KernelWakeupFunc\n"); */
d1738 1
a1738 1
	splx(s); /* XXX */
a1764 1
	db1_printf(("bp->b_dev is %d\n", dev));
a1765 2
	db1_printf(("bp->b_data=0x%x\n", bp->b_data));

a1767 1
	db1_printf(("b_bcount is: %d\n", (int)bp->b_bcount));
a1776 23
/* Extras... */

#if 0
unsigned int
rpcc()
{
	/* XXX no clue what this is supposed to do.. my guess is
	   that it's supposed to read the CPU cycle counter... */
	/*	db1_printf("this is supposed to do something useful too!??\n"); */
	return (0);
}

int
rf_GetSpareTableFromDaemon(req)
	RF_SparetWait_t	 *req;
{
	int retcode=1;
	printf("This is supposed to do something useful!!\n"); /* XXX */

	return (retcode);
}
#endif

d1911 3
a1913 1
		db1_printf(("RAIDframe: vn_open returned %d\n", error));
d2297 87
@


1.6
log
@* rf_reconstruct.c: adopt nilkas' suggestion regard statics and
__inline__ - this is a proof of concept and will cover the raidframe
source as a whole over coming updates. Update namespace of function to
prefix with rf_ - comments again welcome.

* overall: rework the macros in rf_etimer.h and the resultant changes
to their use to count microseconds and not clock ticks. Restore the code
in rf_revent.c to a similar strcuture to before the previous commit,
and use the system timers to govern resource usage.

Tested with local i386/IDE and the reconstruction of a disk in my
array - performance has improved for reconstruction at no noticable
CPU cost.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_openbsdkintf.c,v 1.5 1999/08/02 20:32:49 peter Exp $	*/
d1813 1
@


1.5
log
@revert from using static functions, as per niklas@@openbsd.org advice.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_openbsdkintf.c,v 1.4 1999/08/02 12:33:43 peter Exp $	*/
d1817 1
a1826 1
#if 0
@


1.4
log
@* make some function static, copied from rf_netbsdkintf.c
* move composition og openmask in raidclose to before where it is
tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_openbsdkintf.c,v 1.3 1999/07/30 14:45:32 peter Exp $	*/
d195 1
a195 1
static void	rf_InitBP __P((struct buf *, struct vnode *, unsigned, dev_t,
d216 1
a216 1
static int	raidinit __P((dev_t,RF_Raid_t *,int));
d282 1
a282 1
static void	raidgetdefaultlabel
d284 2
a285 2
static void	raidgetdisklabel __P((dev_t));
static void	raidmakedisklabel __P((struct raid_softc *));
d287 1
a287 1
static int	raidlock __P((struct raid_softc *));
d291 1
a291 1
static void rf_markalldirty __P((RF_Raid_t *));
d1309 1
a1309 1
static int
d1779 1
a1779 1
static void
d1838 1
a1838 1
static void
d1877 1
a1877 1
static void
d1934 1
a1934 1
static void
d2004 1
a2004 1
static int
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_openbsdkintf.c,v 1.2 1999/02/16 00:03:01 niklas Exp $	*/
d195 1
a195 1
void	rf_InitBP __P((struct buf *, struct vnode *, unsigned, dev_t,
d216 1
a216 1
int	raidinit __P((dev_t,RF_Raid_t *,int));
d282 1
a282 1
void	raidgetdefaultlabel
d284 2
a285 2
void	raidgetdisklabel __P((dev_t));
void	raidmakedisklabel __P((struct raid_softc *));
d287 1
a287 1
int	raidlock __P((struct raid_softc *));
d513 3
a524 3
	rs->sc_dkdev.dk_openmask =
	    rs->sc_dkdev.dk_copenmask | rs->sc_dkdev.dk_bopenmask;

d1309 1
a1309 1
int
d1779 1
a1779 1
void
d1838 1
a1838 1
void
d1877 1
a1877 1
void
d1934 1
a1934 1
void
d2004 1
a2004 1
int
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_openbsdkintf.c,v 1.1 1999/01/11 14:29:32 niklas Exp $	*/
a176 2
static int rf_pending_testaccs;

a177 1
RF_DECLARE_STATIC_MUTEX(rf_async_done_q_mutex)
a183 1
static struct rf_test_acc    *rf_async_done_qh, *rf_async_done_qt;
d199 11
a209 4
/* this is so that we can compile under 2.0 as well as 3.2 */
#ifndef proc_to_task
#define proc_to_task(x) ((x)->task)
#endif	/* !proc_to_task */
d226 4
a247 1
	int	 sc_unit;		/* logical unit number */
d266 10
d291 1
d298 1
d317 15
a331 4
	rf_kbooted = rf_boot();
	if (rf_kbooted) {
		panic("Serious error booting RAID!!\n");
	}
a415 2
	unsigned int raidID;
	int rc;
a417 15
	/*
	 * XXX This whole next chunk of code is somewhat suspect... Not sure
	 * it's needed here at all.
	 */
	if (rf_kbooted == RFK_BOOT_NONE) {
		printf("Doing restart on raidopen.\n");
		rf_kbooted = RFK_BOOT_GOOD;
		rc = rf_boot();
		if (rc) {
			rf_kbooted = RFK_BOOT_BAD;
			printf("Someone is unhappy...\n");
			return (rc);
		}
	}

a425 2
	raidID = raidunit(dev);

d430 1
a430 1
	    ("Opening raid device number: %d partition: %d\n", raidID, part));
d460 14
d513 9
a615 1
	int result;
a627 1
#if 0
a628 5
#endif
	result = physio(raidstrategy, NULL, dev, B_READ, minphys, uio);
	db1_printf(("raidread done.  Result is %d %d\n", result,
	    uio->uio_resid));
	return (result);
a672 1

d674 2
d677 6
a682 7
#if 0
	int nbytes, spl, rw, row;
	struct rf_test_acc *ta;
	struct buf *bp;
	RF_SparetWait_t *waitreq;
	struct rf_test_acc *ta_p, *ta_copy;
#endif
d717 6
d797 1
a797 1
		rf_pending_testaccs = 0;
a798 1
		raidPtrs[unit]->raidid = unit;
d801 3
d806 1
d817 1
d839 1
a839 12
		
		/*
		 * The intention here was to disallow shutdowns while
		 * raidframe is mounted, but it doesn't work because the
		 * shutdown ioctl calls rf_open.
		 */
		if (rf_pending_testaccs > 0) {
			printf("RAIDFRAME: Can't shutdown because there are "
			    "%d pending test accs\n",
			    rf_pending_testaccs);
			return (EINVAL);
		}
d844 1
d859 114
a973 1
		/* initialize all parity */
d975 6
a980 2
		if (raidPtrs[unit]->Layout.map->faultsTolerated == 0)
			return (EINVAL);
d986 1
a986 1
		if (retcode)
d988 37
d1129 2
a1130 1
		printf("Failing the disk: row: %d col: %d\n",rr->row,rr->col);
d1155 3
a1157 1
		rf_CopybackReconstructedData(raidPtrs[unit]);
a1347 31
/*********************************************************
 *
 * initialization code called at boot time (startup.c)
 *
 ********************************************************/
int
rf_boot()
{
	int i, rc;

	rc = rf_mutex_init(&rf_sparet_wait_mutex);
	if (rc) {
		RF_PANIC();
	}
	rc = rf_mutex_init(&rf_async_done_q_mutex);
	if (rc) {
		RF_PANIC();
	}
	rf_sparet_wait_queue = rf_sparet_resp_queue = NULL;
	recon_queue = NULL;
	rf_async_done_qh = rf_async_done_qt = NULL;
	for (i = 0; i < numraid; i++)
		raidPtrs[i] = NULL;
	rc = rf_BootRaidframe();
	if (rc == 0)
		printf("Kernelized RAIDframe activated\n");
	else
		rf_kbooted = RFK_BOOT_BAD;
	return (rc);
}

d1369 2
a1370 2
			tsleep(&recon_queue, PRIBIO | PCATCH,
			    "raidframe recon", 0);
d1410 2
a1411 2
		tsleep(&rf_sparet_resp_queue, PRIBIO | PCATCH,
		    "raidframe getsparetable", 0);
d1450 1
d1511 18
d1577 1
d1591 1
d1748 1
d1918 2
a1919 2
			    "the size of raid (%d)\n", rs->sc_xname,
			    lp->d_secperunit, rs->sc_size);
d1924 2
a1925 2
				    "exceeds the size of raid (%d)\n",
				    rs->sc_xname, 'a' + i, rs->sc_size);
d2031 325
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_netbsdkintf.c,v 1.5 1998/12/22 20:03:14 oster Exp $	*/
a115 173
/*
 * :
 * Log: rf_kintf.c,v
 * Revision 1.57  1996/07/19 16:12:20  jimz
 * remove addition of protectedSectors in InitBP- it's already
 * done in the diskqueue code
 *
 * Revision 1.56  1996/07/17  21:00:58	jimz
 * clean up timer interface, tracing
 *
 * Revision 1.55  1996/06/17  03:00:54	jimz
 * Change RAIDFRAME_GET_INFO interface to do its own copyout()
 * (because size of device config structure now exceeds 8k)
 *
 * Revision 1.54  1996/06/09  02:36:46	jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.53  1996/06/07  21:33:04	jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.52  1996/06/06  17:28:08	jimz
 * track sector number of last I/O dequeued
 *
 * Revision 1.51  1996/06/05  18:06:02	jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.50  1996/06/03  23:28:26	jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.49  1996/06/02  17:31:48	jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.48  1996/05/31  22:26:54	jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.47  1996/05/30  12:59:18	jimz
 * make etimer happier, more portable
 *
 * Revision 1.46  1996/05/30  11:29:41	jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.45  1996/05/27  18:56:37	jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.44  1996/05/24  22:17:04	jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.43  1996/05/24  01:59:45	jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.42  1996/05/23  22:17:54	jimz
 * fix sector size hardcoding problems
 *
 * Revision 1.41  1996/05/23  21:46:35	jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.40  1996/05/23  13:18:07	jimz
 * tracing_mutex -> rf_tracing_mutex
 *
 * Revision 1.39  1996/05/23  00:33:23	jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.38  1996/05/20  16:15:32	jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.37  1996/05/10  16:23:47	jimz
 * RF_offset -> RF_Offset
 *
 * Revision 1.36  1996/05/08  21:01:24	jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.35  1996/05/03  19:10:48	jimz
 * change sanity checking for bogus I/Os to return more appropriate
 * values (to make some user-level utilities happer with RAIDframe)
 *
 * Revision 1.34  1996/05/02  22:17:00	jimz
 * When using DKUSAGE, send a bogus IO after configuring to let DKUSAGE know
 * that we exist. This will let user-level programs doing group stats on the
 * RF device function without error before RF gets its first IO
 *
 * Changed rf_device_config devs and spares fields to RF_RaidDisk_t
 *
 * Inc numOutstanding for the disk queue in rf_DispatchKernelIO if
 * type is IO_TYPE_NOP. I'm not sure this is right, but it seems to be,
 * because the disk IO completion routine wants to dec it, and doesn't
 * care if there was no such IO.
 *
 * Revision 1.33  1996/05/02  15:05:44	jimz
 * for now, rf_DoAccessKernel will reject non-sector-sized I/Os
 * eventually, it should do something more clever...
 * (and do it in DoAccess(), not just DoAccessKernel())
 *
 * Revision 1.32  1996/05/01  16:28:39	jimz
 * get rid of uses of ccmn_ functions
 *
 * Revision 1.31  1996/05/01  15:42:17	jimz
 * ccmn_* memory management is on the way out. This is an archival checkpoint-
 * both the old and new code are in place (all the ccmn_ calls are #if 0). After
 * this, the ccmn_ code will no longer appear.
 *
 * Revision 1.30  1996/04/22  15:53:13	jimz
 * MAX_RAIDS -> NRAIDFRAME
 *
 * Revision 1.29  1995/12/12  18:10:06	jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.28  1995/12/01  19:11:01	root
 * added copyright info
 *
 * Revision 1.27  1995/11/28  18:56:40	wvcii
 * disabled buffer copy in rf_write
 *
 * Revision 1.26  1995/10/06  16:37:08	jimz
 * get struct bufs from ubc, not cam
 * copy all write data, and operate on copy
 * (temporary hack to get around dags in PQ that want
 * to Xor into user write buffers)
 *
 * Revision 1.25  1995/09/30  22:23:08	jimz
 * do not require raid to be active to perform ACCTOTAL ioctl
 *
 * Revision 1.24  1995/09/30  20:39:08	jimz
 * added new ioctls:
 *   RAIDFRAME_RESET_ACCTOTALS
 *   RAIDFRAME_GET_ACCTOTALS
 *   RAIDFRAME_KEEP_ACCTOTALS
 *
 * Revision 1.23  1995/09/20  21:11:59	jimz
 * include dfstrace.h in KERNEL block
 * (even though it's a kernel-only file, this makes the depend process
 * at user-level happy. Why the user-level Makefile wants to depend
 * kintf.c is less clear, but this is a workaround).
 *
 * Revision 1.22  1995/09/19  23:19:03	jimz
 * added DKUSAGE support
 *
 */

#ifdef _KERNEL
#define KERNEL
#endif

#ifdef KERNEL
a118 1
#include "raid.h"
d134 1
d151 1
a151 1
int rf_kdebug_level = 0;
d166 1
a166 1
#else /* RAIDDEBUG */
d173 1
a173 1
#endif /* RAIDDEBUG */
d175 1
a175 1
static RF_Raid_t **raidPtrs; /* global raid device descriptors */
d192 1
a192 1
decl_simple_lock_data(,recon_queue_mutex)
d206 1
a206 1
#endif /* !proc_to_task */
d227 4
a230 4
	struct buf	rf_buf;		/* new I/O buf.	 MUST BE FIRST!!! */
	struct buf	*rf_obp;	/* ptr. to original I/O buf */
	int		rf_flags;	/* misc. flags */
	RF_DiskQueueData_t  *req;	/* the request that this was part of.. */
d233 2
a234 2
#define RAIDGETBUF() malloc(sizeof (struct raidbuf), M_DEVBUF, M_NOWAIT)
#define	RAIDPUTBUF(buf) free(buf, M_DEVBUF)
d241 7
a247 7
	int		 sc_unit;		/* logical unit number */
	int		 sc_flags;		/* flags */
	int		 sc_cflags;		/* configuration flags */
	size_t		 sc_size;		/* size of the raid device */
	dev_t		 sc_dev;		/* our device..*/
	char		 sc_xname[20];		/* XXX external name */
	struct disk	 sc_dkdev;		/* generic disk device info */
d258 1
a258 1
static int numraid=0;
d291 1
a291 3
	/*
	 * This is where all the initialization stuff gets done.
	 */
d307 3
a309 3
	   put together some datastructures like the CCD device does..
	   This lets us lock the device and what-not when it gets opened.
	*/
d312 1
a312 2
		malloc(num * sizeof(struct raid_softc),
		       M_DEVBUF, M_NOWAIT);
d318 1
a318 1
	bzero(raid_softc, num * sizeof(struct raid_softc));
d320 5
a324 5
	for(raidID=0;raidID < num;raidID++) {
		RF_Calloc(raidPtrs[raidID], 1, sizeof(RF_Raid_t),
			  (RF_Raid_t *));
		if (raidPtrs[raidID]==NULL) {
			printf("raidPtrs[%d] is NULL\n",raidID);
d547 1
a547 1
	wlabel = rs->sc_flags & (RAIDF_WLABEL|RAIDF_LABELLING);
d552 1
a552 1
			       (int)bp->b_blkno, (int)wlabel));
d599 1
a599 1
	result=physio(raidstrategy, NULL, dev, B_READ, minphys, uio);
d868 2
a869 2
			RF_Malloc(cfg,sizeof(RF_DeviceConfig_t),
				  (RF_DeviceConfig_t *));
d887 2
a888 2
			for(i=0;i<cfg->rows;i++) {
				for(j=0;j<cfg->cols;j++) {
d893 1
a893 1
			for(j=cfg->cols,i=0;i<cfg->nspares;i++,j++) {
d897 2
a898 2
					  sizeof(RF_DeviceConfig_t));
			RF_Free(cfg,sizeof(RF_DeviceConfig_t));
d943 1
a943 1
		rr = (struct rf_recon_req *) data;
d945 2
a946 2
		if (rr->row < 0 || rr->row >= raidPtrs[unit]->numRow
		    || rr->col < 0 || rr->col >= raidPtrs[unit]->numCol)
d957 1
a957 1
		rrcopy->raidPtr = (void *) raidPtrs[unit];
d1004 1
a1004 1
			mpsleep(&rf_sparet_wait_queue, (PZERO+1)|PCATCH,
d1022 1
a1022 1
		RF_Malloc(waitreq, sizeof(*waitreq), (RF_SparetWait_t *));
d1038 1
a1038 1
		retcode = rf_SetSpareTable(raidPtrs[unit],*(void **) data);
d1186 1
a1186 1
	for (i=0; i<numraid; i++)
d1216 4
a1219 3
		  UNLOCK_RECON_Q_MUTEX();
		  tsleep(&recon_queue, PRIBIO | PCATCH, "raidframe recon", 0);
		  LOCK_RECON_Q_MUTEX();
d1230 1
a1230 1
		rf_FailDisk((RF_Raid_t *) req->raidPtr, req->row, req->col,
d1233 1
a1233 1
		RF_Free(req, sizeof(*req));
d1262 1
a1262 1
		    (void *) simple_lock_addr(rf_sparet_wait_mutex),
d1272 1
a1272 1
	RF_Free(req, sizeof(*req));
d1285 5
a1289 5
	RF_Raid_t	       *raidPtr;
	struct buf	       *bp;
	RF_RaidAccessFlags_t	flags;
	void		      (*cbFunc)(struct buf *);
	void		       *cbArg;
d1375 2
a1376 2
	RF_DiskQueue_t	    *queue;
	RF_DiskQueueData_t  *req;
a1639 1
#endif /* KERNEL */
@

