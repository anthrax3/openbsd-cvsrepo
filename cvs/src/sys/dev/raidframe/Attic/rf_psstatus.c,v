head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.38
	OPENBSD_5_0:1.6.0.36
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.34
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.32
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.28
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.30
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.26
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.24
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.22
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.20
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.4.0.16
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.14
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.12
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.10
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.6;

1.6
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.03.11.31.35;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.4.2.1
	1.4.12.1;
next	1.3;

1.3
date	2000.01.07.14.50.22;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.12;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.40;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.4.12.1
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_psstatus.c,v 1.6 2002/12/16 07:01:04 tdeval Exp $	*/
/*	$NetBSD: rf_psstatus.c,v 1.5 2000/01/08 22:57:31 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 *
 * psstatus.c
 *
 * The reconstruction code maintains a bunch of status related to the parity
 * stripes that are currently under reconstruction. This header file defines
 * the status structures.
 *
 *****************************************************************************/

#include "rf_types.h"
#include "rf_raid.h"
#include "rf_general.h"
#include "rf_debugprint.h"
#include "rf_freelist.h"
#include "rf_psstatus.h"
#include "rf_shutdown.h"

#define	Dprintf1(s,a)							\
do {									\
	if (rf_pssDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL);		\
} while(0)
#define	Dprintf2(s,a,b)							\
do {									\
	if (rf_pssDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    NULL, NULL, NULL, NULL, NULL, NULL);		\
} while(0)
#define	Dprintf3(s,a,b,c)						\
do {									\
	if (rf_pssDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    NULL, NULL, NULL, NULL, NULL);			\
} while(0)

void rf_RealPrintPSStatusTable(RF_Raid_t *, RF_PSStatusHeader_t *);

#define	RF_MAX_FREE_PSS		32
#define	RF_PSS_INC		 8
#define	RF_PSS_INITIAL		 4

int  rf_init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);
void rf_clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);
void rf_ShutdownPSStatus(void *);

int
rf_init_pss(RF_ReconParityStripeStatus_t *p, RF_Raid_t *raidPtr)
{
	RF_Calloc(p->issued, raidPtr->numCol, sizeof(char), (char *));
	if (p->issued == NULL)
		return (ENOMEM);
	return (0);
}

void
rf_clean_pss(RF_ReconParityStripeStatus_t *p, RF_Raid_t *raidPtr)
{
	RF_Free(p->issued, raidPtr->numCol * sizeof(char));
}

void
rf_ShutdownPSStatus(void *arg)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) arg;

	RF_FREELIST_DESTROY_CLEAN_ARG(raidPtr->pss_freelist, next,
	    (RF_ReconParityStripeStatus_t *), rf_clean_pss, raidPtr);
}

int
rf_ConfigurePSStatus(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	int rc;

	raidPtr->pssTableSize = RF_PSS_DEFAULT_TABLESIZE;
	RF_FREELIST_CREATE(raidPtr->pss_freelist, RF_MAX_FREE_PSS, RF_PSS_INC,
	    sizeof(RF_ReconParityStripeStatus_t));
	if (raidPtr->pss_freelist == NULL)
		return (ENOMEM);
	rc = rf_ShutdownCreate(listp, rf_ShutdownPSStatus, raidPtr);
	if (rc) {
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		             " rc=%d.\n", __FILE__, __LINE__, rc);
		rf_ShutdownPSStatus(raidPtr);
		return (rc);
	}
	RF_FREELIST_PRIME_INIT_ARG(raidPtr->pss_freelist, RF_PSS_INITIAL, next,
	    (RF_ReconParityStripeStatus_t *), rf_init_pss, raidPtr);
	return (0);
}


/*****************************************************************************
 * Sets up the pss table.
 * We pre-allocate a bunch of entries to avoid as much as possible having to
 * malloc up hash chain entries.
 *****************************************************************************/
RF_PSStatusHeader_t *
rf_MakeParityStripeStatusTable(RF_Raid_t *raidPtr)
{
	RF_PSStatusHeader_t *pssTable;
	int i, j, rc;

	RF_Calloc(pssTable, raidPtr->pssTableSize, sizeof(RF_PSStatusHeader_t),
	    (RF_PSStatusHeader_t *));
	for (i = 0; i < raidPtr->pssTableSize; i++) {
		rc = rf_mutex_init(&pssTable[i].mutex);
		if (rc) {
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			             " rc=%d.\n", __FILE__, __LINE__, rc);
			/* Fail and deallocate. */
			for (j = 0; j < i; j++) {
				rf_mutex_destroy(&pssTable[i].mutex);
			}
			RF_Free(pssTable, raidPtr->pssTableSize *
			    sizeof(RF_PSStatusHeader_t));
			return (NULL);
		}
	}
	return (pssTable);
}

void
rf_FreeParityStripeStatusTable(RF_Raid_t *raidPtr,
    RF_PSStatusHeader_t *pssTable)
{
	int i;

	if (rf_pssDebug)
		rf_RealPrintPSStatusTable(raidPtr, pssTable);
	for (i = 0; i < raidPtr->pssTableSize; i++) {
		if (pssTable[i].chain) {
			printf("ERROR: pss hash chain not null at recon"
			       " shutdown.\n");
		}
		rf_mutex_destroy(&pssTable[i].mutex);
	}
	RF_Free(pssTable, raidPtr->pssTableSize * sizeof(RF_PSStatusHeader_t));
}


/*
 * Looks up the status structure for a parity stripe.
 * If the create_flag is on, returns the status structure, creating it if
 * it doesn't exist. Otherwise returns NULL if the status structure does
 * not exist already.
 *
 * The flags tell whether or not to create it if it doesn't exist + what
 * flags to set initially.
 *
 * ASSUMES THE PSS DESCRIPTOR IS LOCKED UPON ENTRY.
 */
RF_ReconParityStripeStatus_t *
rf_LookupRUStatus(RF_Raid_t *raidPtr, RF_PSStatusHeader_t *pssTable,
    RF_StripeNum_t psID, RF_ReconUnitNum_t which_ru, RF_PSSFlags_t flags,
    int *created)
{
	RF_PSStatusHeader_t *hdr = &pssTable[RF_HASH_PSID(raidPtr, psID)];
	RF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;

	*created = 0;
	for (p = pssPtr; p; p = p->next) {
		if (p->parityStripeID == psID && p->which_ru == which_ru)
			break;
	}

	if (!p && (flags & RF_PSS_CREATE)) {
		Dprintf2("PSS: creating pss for psid %ld ru %d.\n",
		    psID, which_ru);
		p = rf_AllocPSStatus(raidPtr);
		p->next = hdr->chain;
		hdr->chain = p;

		p->parityStripeID = psID;
		p->which_ru = which_ru;
		p->flags = flags;
		p->rbuf = NULL;
		p->writeRbuf = NULL;
		p->xorBufCount = 0;
		p->blockCount = 0;
		p->procWaitList = NULL;
		p->blockWaitList = NULL;
		p->bufWaitList = NULL;
		*created = 1;
	} else
		if (p) {
			/*
			 * We didn't create, but we want to specify
			 * some new status.
			 */
			p->flags |= flags;	/*
						 * Add in whatever flags we're
						 * specifying.
						 */
		}
	if (p && (flags & RF_PSS_RECON_BLOCKED)) {
		/* If we're asking to block recon, bump the count. */
		p->blockCount++;
		Dprintf3("raid%d: Blocked recon on psid %ld. count now %d.\n",
			 raidPtr->raidid, psID, p->blockCount);
	}
	return (p);
}


/*
 * Deletes an entry from the parity stripe status table. Typically used
 * when an entry has been allocated solely to block reconstruction, and
 * no recon was requested while recon was blocked. Assumes the hash
 * chain is ALREADY LOCKED.
 */
void
rf_PSStatusDelete(RF_Raid_t *raidPtr, RF_PSStatusHeader_t *pssTable,
    RF_ReconParityStripeStatus_t *pssPtr)
{
	RF_PSStatusHeader_t *hdr =
	    &(pssTable[RF_HASH_PSID(raidPtr, pssPtr->parityStripeID)]);
	RF_ReconParityStripeStatus_t *p = hdr->chain, *pt = NULL;

	while (p) {
		if (p == pssPtr) {
			if (pt)
				pt->next = p->next;
			else
				hdr->chain = p->next;
			p->next = NULL;
			rf_FreePSStatus(raidPtr, p);
			return;
		}
		pt = p;
		p = p->next;
	}
	RF_ASSERT(0);		/* We must find it here. */
}


/*
 * Deletes an entry from the ps status table after reconstruction has
 * completed.
 */
void
rf_RemoveFromActiveReconTable(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_StripeNum_t psid, RF_ReconUnitNum_t which_ru)
{
	RF_PSStatusHeader_t *hdr =
	    &(raidPtr->reconControl[row]
	     ->pssTable[RF_HASH_PSID(raidPtr, psid)]);
	RF_ReconParityStripeStatus_t *p, *pt;
	RF_CallbackDesc_t *cb, *cb1;

	RF_LOCK_MUTEX(hdr->mutex);
	for (pt = NULL, p = hdr->chain; p; pt = p, p = p->next) {
		if ((p->parityStripeID == psid) && (p->which_ru == which_ru))
			break;
	}
	if (p == NULL) {
		rf_PrintPSStatusTable(raidPtr, row);
	}
	RF_ASSERT(p);		/* It must be there. */

	Dprintf2("PSS: deleting pss for psid %ld ru %d.\n", psid, which_ru);

	/* Delete this entry from the hash chain. */
	if (pt)
		pt->next = p->next;
	else
		hdr->chain = p->next;
	p->next = NULL;

	RF_UNLOCK_MUTEX(hdr->mutex);

	/* Wake-up anyone waiting on the parity stripe ID. */
	cb = p->procWaitList;
	p->procWaitList = NULL;
	while (cb) {
		Dprintf1("Waking up access waiting on parity stripe ID %ld.\n",
		    p->parityStripeID);
		cb1 = cb->next;
		(cb->callbackFunc) (cb->callbackArg);

		/*
		 * THIS IS WHAT THE ORIGINAL CODE HAD... the extra 0 is bogus,
		 * IMHO.
		 */
		/* (cb->callbackFunc)(cb->callbackArg, 0); */
		rf_FreeCallbackDesc(cb);
		cb = cb1;
	}

	rf_FreePSStatus(raidPtr, p);
}

RF_ReconParityStripeStatus_t *
rf_AllocPSStatus(RF_Raid_t *raidPtr)
{
	RF_ReconParityStripeStatus_t *p;

	RF_FREELIST_GET_INIT_ARG(raidPtr->pss_freelist, p, next,
	    (RF_ReconParityStripeStatus_t *), rf_init_pss, raidPtr);
	if (p) {
		bzero(p->issued, raidPtr->numCol);
	}
	p->next = NULL;
	/*
	 * No need to initialize here b/c the only place we're called from is
	 * the above Lookup.
	 */
	return (p);
}

void
rf_FreePSStatus(RF_Raid_t *raidPtr, RF_ReconParityStripeStatus_t *p)
{
	RF_ASSERT(p->procWaitList == NULL);
	RF_ASSERT(p->blockWaitList == NULL);
	RF_ASSERT(p->bufWaitList == NULL);

	RF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist, p, next,
	    rf_clean_pss, raidPtr);
}

void
rf_RealPrintPSStatusTable(RF_Raid_t *raidPtr, RF_PSStatusHeader_t *pssTable)
{
	int i, j, procsWaiting, blocksWaiting, bufsWaiting;
	RF_ReconParityStripeStatus_t *p;
	RF_CallbackDesc_t *cb;

	printf("\nParity Stripe Status Table\n");
	for (i = 0; i < raidPtr->pssTableSize; i++) {
		for (p = pssTable[i].chain; p; p = p->next) {
			procsWaiting = blocksWaiting = bufsWaiting = 0;
			for (cb = p->procWaitList; cb; cb = cb->next)
				procsWaiting++;
			for (cb = p->blockWaitList; cb; cb = cb->next)
				blocksWaiting++;
			for (cb = p->bufWaitList; cb; cb = cb->next)
				bufsWaiting++;
			printf("PSID %ld RU %d : blockCount %d %d/%d/%d"
			    " proc/block/buf waiting, issued ",
			    (long) p->parityStripeID, p->which_ru,
			    p->blockCount, procsWaiting, blocksWaiting,
			    bufsWaiting);
			for (j = 0; j < raidPtr->numCol; j++)
				printf("%c", (p->issued[j]) ? '1' : '0');
			if (!p->flags)
				printf(" flags: (none)");
			else {
				if (p->flags & RF_PSS_UNDER_RECON)
					printf(" under-recon");
				if (p->flags & RF_PSS_FORCED_ON_WRITE)
					printf(" forced-w");
				if (p->flags & RF_PSS_FORCED_ON_READ)
					printf(" forced-r");
				if (p->flags & RF_PSS_RECON_BLOCKED)
					printf(" blocked");
				if (p->flags & RF_PSS_BUFFERWAIT)
					printf(" bufwait");
			}
			printf("\n");
		}
	}
}

void
rf_PrintPSStatusTable(RF_Raid_t *raidPtr, RF_RowCol_t row)
{
	RF_PSStatusHeader_t *pssTable = raidPtr->reconControl[row]->pssTable;
	rf_RealPrintPSStatusTable(raidPtr, pssTable);
}
@


1.6
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_psstatus.c,v 1.5 2002/12/03 11:31:35 tdeval Exp $	*/
@


1.5
log
@Missing initialization.

thanks Greg Oster
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_psstatus.c,v 1.4 2000/01/11 18:02:22 peter Exp $	*/
d3 1
d36 1
a36 1
 * stripes that are currently under reconstruction.  This header file defines
d49 34
a82 15
#define Dprintf1(s,a)         if (rf_pssDebug) rf_debug_printf(s,(void *)((unsigned long)a),NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf2(s,a,b)       if (rf_pssDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf3(s,a,b,c)     if (rf_pssDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),NULL,NULL,NULL,NULL,NULL)

static void 
RealPrintPSStatusTable(RF_Raid_t * raidPtr,
    RF_PSStatusHeader_t * pssTable);

#define RF_MAX_FREE_PSS  32
#define RF_PSS_INC        8
#define RF_PSS_INITIAL    4

static int init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);
static void clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);
static void rf_ShutdownPSStatus(void *);
d84 2
a85 4
static int 
init_pss(p, raidPtr)
	RF_ReconParityStripeStatus_t *p;
	RF_Raid_t *raidPtr;
d93 2
a94 4
static void 
clean_pss(p, raidPtr)
	RF_ReconParityStripeStatus_t *p;
	RF_Raid_t *raidPtr;
d99 2
a100 3
static void 
rf_ShutdownPSStatus(arg)
	void   *arg;
d104 2
a105 1
	RF_FREELIST_DESTROY_CLEAN_ARG(raidPtr->pss_freelist, next, (RF_ReconParityStripeStatus_t *), clean_pss, raidPtr);
d108 3
a110 5
int 
rf_ConfigurePSStatus(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d112 1
a112 1
	int     rc;
d115 2
a116 2
	RF_FREELIST_CREATE(raidPtr->pss_freelist, RF_MAX_FREE_PSS,
	    RF_PSS_INC, sizeof(RF_ReconParityStripeStatus_t));
d121 2
a122 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d127 1
a127 1
	    (RF_ReconParityStripeStatus_t *), init_pss, raidPtr);
d130 4
a133 2
/*****************************************************************************************
 * sets up the pss table
d136 1
a136 1
 ****************************************************************************************/
d138 1
a138 2
rf_MakeParityStripeStatusTable(raidPtr)
	RF_Raid_t *raidPtr;
d141 1
a141 1
	int     i, j, rc;
d143 2
a144 1
	RF_Calloc(pssTable, raidPtr->pssTableSize, sizeof(RF_PSStatusHeader_t), (RF_PSStatusHeader_t *));
d148 3
a150 3
			RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
			    __LINE__, rc);
			/* fail and deallocate */
d154 2
a155 1
			RF_Free(pssTable, raidPtr->pssTableSize * sizeof(RF_PSStatusHeader_t));
d162 3
a164 4
void 
rf_FreeParityStripeStatusTable(raidPtr, pssTable)
	RF_Raid_t *raidPtr;
	RF_PSStatusHeader_t *pssTable;
d166 1
a166 1
	int     i;
d169 1
a169 1
		RealPrintPSStatusTable(raidPtr, pssTable);
d172 2
a173 1
			printf("ERROR: pss hash chain not null at recon shutdown\n");
d181 5
a185 3
/* looks up the status structure for a parity stripe.
 * if the create_flag is on, creates and returns the status structure it it doesn't exist
 * otherwise returns NULL if the status structure does not exist
d187 4
a190 1
 * ASSUMES THE PSS DESCRIPTOR IS LOCKED UPON ENTRY
d193 2
a194 7
rf_LookupRUStatus(
    RF_Raid_t * raidPtr,
    RF_PSStatusHeader_t * pssTable,
    RF_StripeNum_t psID,
    RF_ReconUnitNum_t which_ru,
    RF_PSSFlags_t flags,	/* whether or not to create it if it doesn't
				 * exist + what flags to set initially */
d207 2
a208 1
		Dprintf2("PSS: creating pss for psid %ld ru %d\n", psID, which_ru);
d225 9
a233 4
		if (p) {	/* we didn't create, but we want to specify
				 * some new status */
			p->flags |= flags;	/* add in whatever flags we're
						 * specifying */
d236 3
a238 3
		p->blockCount++;/* if we're asking to block recon, bump the
				 * count */
		Dprintf3("raid%d: Blocked recon on psid %ld.  count now %d\n",
d243 4
a246 1
/* deletes an entry from the parity stripe status table.  typically used
d248 1
a248 1
 * no recon was requested while recon was blocked.  Assumes the hash
d251 3
a253 5
void 
rf_PSStatusDelete(raidPtr, pssTable, pssPtr)
	RF_Raid_t *raidPtr;
	RF_PSStatusHeader_t *pssTable;
	RF_ReconParityStripeStatus_t *pssPtr;
d255 2
a256 1
	RF_PSStatusHeader_t *hdr = &(pssTable[RF_HASH_PSID(raidPtr, pssPtr->parityStripeID)]);
d272 1
a272 1
	RF_ASSERT(0);		/* we must find it here */
d274 13
a286 9
/* deletes an entry from the ps status table after reconstruction has completed */
void 
rf_RemoveFromActiveReconTable(raidPtr, row, psid, which_ru)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
	RF_ReconUnitNum_t which_ru;
	RF_StripeNum_t psid;
{
	RF_PSStatusHeader_t *hdr = &(raidPtr->reconControl[row]->pssTable[RF_HASH_PSID(raidPtr, psid)]);
d298 1
a298 1
	RF_ASSERT(p);		/* it must be there */
d300 1
a300 1
	Dprintf2("PSS: deleting pss for psid %ld ru %d\n", psid, which_ru);
d302 1
a302 1
	/* delete this entry from the hash chain */
d311 1
a311 1
	/* wakup anyone waiting on the parity stripe ID */
d315 2
a316 1
		Dprintf1("Waking up access waiting on parity stripe ID %ld\n", p->parityStripeID);
d320 4
a323 2
		/* THIS IS WHAT THE ORIGINAL CODE HAD... the extra 0 is bogus,
		 * IMHO */
d333 1
a333 2
rf_AllocPSStatus(raidPtr)
	RF_Raid_t *raidPtr;
d337 2
a338 1
	RF_FREELIST_GET_INIT_ARG(raidPtr->pss_freelist, p, next, (RF_ReconParityStripeStatus_t *), init_pss, raidPtr);
d343 4
a346 2
	/* no need to initialize here b/c the only place we're called from is
	 * the above Lookup */
d350 2
a351 4
void 
rf_FreePSStatus(raidPtr, p)
	RF_Raid_t *raidPtr;
	RF_ReconParityStripeStatus_t *p;
d357 2
a358 1
	RF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist, p, next, clean_pss, raidPtr);
d361 2
a362 4
static void 
RealPrintPSStatusTable(raidPtr, pssTable)
	RF_Raid_t *raidPtr;
	RF_PSStatusHeader_t *pssTable;
d364 1
a364 1
	int     i, j, procsWaiting, blocksWaiting, bufsWaiting;
d378 5
a382 2
			printf("PSID %ld RU %d : blockCount %d %d/%d/%d proc/block/buf waiting, issued ",
			    (long) p->parityStripeID, p->which_ru, p->blockCount, procsWaiting, blocksWaiting, bufsWaiting);
d404 2
a405 4
void 
rf_PrintPSStatusTable(raidPtr, row)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
d408 1
a408 1
	RealPrintPSStatusTable(raidPtr, pssTable);
@


1.4
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_psstatus.c,v 1.3 2000/01/07 14:50:22 peter Exp $	*/
d200 1
@


1.4.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d35 1
a35 1
 * stripes that are currently under reconstruction. This header file defines
d48 15
a62 34
#define	Dprintf1(s,a)							\
do {									\
	if (rf_pssDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL);		\
} while(0)
#define	Dprintf2(s,a,b)							\
do {									\
	if (rf_pssDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    NULL, NULL, NULL, NULL, NULL, NULL);		\
} while(0)
#define	Dprintf3(s,a,b,c)						\
do {									\
	if (rf_pssDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    NULL, NULL, NULL, NULL, NULL);			\
} while(0)

void rf_RealPrintPSStatusTable(RF_Raid_t *, RF_PSStatusHeader_t *);

#define	RF_MAX_FREE_PSS		32
#define	RF_PSS_INC		 8
#define	RF_PSS_INITIAL		 4

int  rf_init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);
void rf_clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);
void rf_ShutdownPSStatus(void *);
d64 4
a67 2
int
rf_init_pss(RF_ReconParityStripeStatus_t *p, RF_Raid_t *raidPtr)
d75 4
a78 2
void
rf_clean_pss(RF_ReconParityStripeStatus_t *p, RF_Raid_t *raidPtr)
d83 3
a85 2
void
rf_ShutdownPSStatus(void *arg)
d89 1
a89 2
	RF_FREELIST_DESTROY_CLEAN_ARG(raidPtr->pss_freelist, next,
	    (RF_ReconParityStripeStatus_t *), rf_clean_pss, raidPtr);
d92 5
a96 3
int
rf_ConfigurePSStatus(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d98 1
a98 1
	int rc;
d101 2
a102 2
	RF_FREELIST_CREATE(raidPtr->pss_freelist, RF_MAX_FREE_PSS, RF_PSS_INC,
	    sizeof(RF_ReconParityStripeStatus_t));
d107 2
a108 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		             " rc=%d.\n", __FILE__, __LINE__, rc);
d113 1
a113 1
	    (RF_ReconParityStripeStatus_t *), rf_init_pss, raidPtr);
d116 2
a117 4


/*****************************************************************************
 * Sets up the pss table.
d120 1
a120 1
 *****************************************************************************/
d122 2
a123 1
rf_MakeParityStripeStatusTable(RF_Raid_t *raidPtr)
d126 1
a126 1
	int i, j, rc;
d128 1
a128 2
	RF_Calloc(pssTable, raidPtr->pssTableSize, sizeof(RF_PSStatusHeader_t),
	    (RF_PSStatusHeader_t *));
d132 3
a134 3
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			             " rc=%d.\n", __FILE__, __LINE__, rc);
			/* Fail and deallocate. */
d138 1
a138 2
			RF_Free(pssTable, raidPtr->pssTableSize *
			    sizeof(RF_PSStatusHeader_t));
d145 4
a148 3
void
rf_FreeParityStripeStatusTable(RF_Raid_t *raidPtr,
    RF_PSStatusHeader_t *pssTable)
d150 1
a150 1
	int i;
d153 1
a153 1
		rf_RealPrintPSStatusTable(raidPtr, pssTable);
d156 1
a156 2
			printf("ERROR: pss hash chain not null at recon"
			       " shutdown.\n");
d164 3
a166 5
/*
 * Looks up the status structure for a parity stripe.
 * If the create_flag is on, returns the status structure, creating it if
 * it doesn't exist. Otherwise returns NULL if the status structure does
 * not exist already.
d168 1
a168 4
 * The flags tell whether or not to create it if it doesn't exist + what
 * flags to set initially.
 *
 * ASSUMES THE PSS DESCRIPTOR IS LOCKED UPON ENTRY.
d171 7
a177 2
rf_LookupRUStatus(RF_Raid_t *raidPtr, RF_PSStatusHeader_t *pssTable,
    RF_StripeNum_t psID, RF_ReconUnitNum_t which_ru, RF_PSSFlags_t flags,
d190 1
a190 2
		Dprintf2("PSS: creating pss for psid %ld ru %d.\n",
		    psID, which_ru);
a199 1
		p->xorBufCount = 0;
d206 4
a209 9
		if (p) {
			/*
			 * We didn't create, but we want to specify
			 * some new status.
			 */
			p->flags |= flags;	/*
						 * Add in whatever flags we're
						 * specifying.
						 */
d212 3
a214 3
		/* If we're asking to block recon, bump the count. */
		p->blockCount++;
		Dprintf3("raid%d: Blocked recon on psid %ld. count now %d.\n",
d219 1
a219 4


/*
 * Deletes an entry from the parity stripe status table. Typically used
d221 1
a221 1
 * no recon was requested while recon was blocked. Assumes the hash
d224 5
a228 3
void
rf_PSStatusDelete(RF_Raid_t *raidPtr, RF_PSStatusHeader_t *pssTable,
    RF_ReconParityStripeStatus_t *pssPtr)
d230 1
a230 2
	RF_PSStatusHeader_t *hdr =
	    &(pssTable[RF_HASH_PSID(raidPtr, pssPtr->parityStripeID)]);
d246 1
a246 1
	RF_ASSERT(0);		/* We must find it here. */
d248 9
a256 13


/*
 * Deletes an entry from the ps status table after reconstruction has
 * completed.
 */
void
rf_RemoveFromActiveReconTable(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_StripeNum_t psid, RF_ReconUnitNum_t which_ru)
{
	RF_PSStatusHeader_t *hdr =
	    &(raidPtr->reconControl[row]
	     ->pssTable[RF_HASH_PSID(raidPtr, psid)]);
d268 1
a268 1
	RF_ASSERT(p);		/* It must be there. */
d270 1
a270 1
	Dprintf2("PSS: deleting pss for psid %ld ru %d.\n", psid, which_ru);
d272 1
a272 1
	/* Delete this entry from the hash chain. */
d281 1
a281 1
	/* Wake-up anyone waiting on the parity stripe ID. */
d285 1
a285 2
		Dprintf1("Waking up access waiting on parity stripe ID %ld.\n",
		    p->parityStripeID);
d289 2
a290 4
		/*
		 * THIS IS WHAT THE ORIGINAL CODE HAD... the extra 0 is bogus,
		 * IMHO.
		 */
d300 2
a301 1
rf_AllocPSStatus(RF_Raid_t *raidPtr)
d305 1
a305 2
	RF_FREELIST_GET_INIT_ARG(raidPtr->pss_freelist, p, next,
	    (RF_ReconParityStripeStatus_t *), rf_init_pss, raidPtr);
d310 2
a311 4
	/*
	 * No need to initialize here b/c the only place we're called from is
	 * the above Lookup.
	 */
d315 4
a318 2
void
rf_FreePSStatus(RF_Raid_t *raidPtr, RF_ReconParityStripeStatus_t *p)
d324 1
a324 2
	RF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist, p, next,
	    rf_clean_pss, raidPtr);
d327 4
a330 2
void
rf_RealPrintPSStatusTable(RF_Raid_t *raidPtr, RF_PSStatusHeader_t *pssTable)
d332 1
a332 1
	int i, j, procsWaiting, blocksWaiting, bufsWaiting;
d346 2
a347 5
			printf("PSID %ld RU %d : blockCount %d %d/%d/%d"
			    " proc/block/buf waiting, issued ",
			    (long) p->parityStripeID, p->which_ru,
			    p->blockCount, procsWaiting, blocksWaiting,
			    bufsWaiting);
d369 4
a372 2
void
rf_PrintPSStatusTable(RF_Raid_t *raidPtr, RF_RowCol_t row)
d375 1
a375 1
	rf_RealPrintPSStatusTable(raidPtr, pssTable);
@


1.4.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d35 1
a35 1
 * stripes that are currently under reconstruction. This header file defines
d48 15
a62 34
#define	Dprintf1(s,a)							\
do {									\
	if (rf_pssDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    NULL, NULL, NULL, NULL, NULL, NULL, NULL);		\
} while(0)
#define	Dprintf2(s,a,b)							\
do {									\
	if (rf_pssDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    NULL, NULL, NULL, NULL, NULL, NULL);		\
} while(0)
#define	Dprintf3(s,a,b,c)						\
do {									\
	if (rf_pssDebug)						\
		rf_debug_printf(s,					\
		    (void *)((unsigned long)a),				\
		    (void *)((unsigned long)b),				\
		    (void *)((unsigned long)c),				\
		    NULL, NULL, NULL, NULL, NULL);			\
} while(0)

void rf_RealPrintPSStatusTable(RF_Raid_t *, RF_PSStatusHeader_t *);

#define	RF_MAX_FREE_PSS		32
#define	RF_PSS_INC		 8
#define	RF_PSS_INITIAL		 4

int  rf_init_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);
void rf_clean_pss(RF_ReconParityStripeStatus_t *, RF_Raid_t *);
void rf_ShutdownPSStatus(void *);
d64 4
a67 2
int
rf_init_pss(RF_ReconParityStripeStatus_t *p, RF_Raid_t *raidPtr)
d75 4
a78 2
void
rf_clean_pss(RF_ReconParityStripeStatus_t *p, RF_Raid_t *raidPtr)
d83 3
a85 2
void
rf_ShutdownPSStatus(void *arg)
d89 1
a89 2
	RF_FREELIST_DESTROY_CLEAN_ARG(raidPtr->pss_freelist, next,
	    (RF_ReconParityStripeStatus_t *), rf_clean_pss, raidPtr);
d92 5
a96 3
int
rf_ConfigurePSStatus(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d98 1
a98 1
	int rc;
d101 2
a102 2
	RF_FREELIST_CREATE(raidPtr->pss_freelist, RF_MAX_FREE_PSS, RF_PSS_INC,
	    sizeof(RF_ReconParityStripeStatus_t));
d107 2
a108 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		             " rc=%d.\n", __FILE__, __LINE__, rc);
d113 1
a113 1
	    (RF_ReconParityStripeStatus_t *), rf_init_pss, raidPtr);
d116 2
a117 4


/*****************************************************************************
 * Sets up the pss table.
d120 1
a120 1
 *****************************************************************************/
d122 2
a123 1
rf_MakeParityStripeStatusTable(RF_Raid_t *raidPtr)
d126 1
a126 1
	int i, j, rc;
d128 1
a128 2
	RF_Calloc(pssTable, raidPtr->pssTableSize, sizeof(RF_PSStatusHeader_t),
	    (RF_PSStatusHeader_t *));
d132 3
a134 3
			RF_ERRORMSG3("Unable to init mutex file %s line %d"
			             " rc=%d.\n", __FILE__, __LINE__, rc);
			/* Fail and deallocate. */
d138 1
a138 2
			RF_Free(pssTable, raidPtr->pssTableSize *
			    sizeof(RF_PSStatusHeader_t));
d145 4
a148 3
void
rf_FreeParityStripeStatusTable(RF_Raid_t *raidPtr,
    RF_PSStatusHeader_t *pssTable)
d150 1
a150 1
	int i;
d153 1
a153 1
		rf_RealPrintPSStatusTable(raidPtr, pssTable);
d156 1
a156 2
			printf("ERROR: pss hash chain not null at recon"
			       " shutdown.\n");
d164 3
a166 5
/*
 * Looks up the status structure for a parity stripe.
 * If the create_flag is on, returns the status structure, creating it if
 * it doesn't exist. Otherwise returns NULL if the status structure does
 * not exist already.
d168 1
a168 4
 * The flags tell whether or not to create it if it doesn't exist + what
 * flags to set initially.
 *
 * ASSUMES THE PSS DESCRIPTOR IS LOCKED UPON ENTRY.
d171 7
a177 2
rf_LookupRUStatus(RF_Raid_t *raidPtr, RF_PSStatusHeader_t *pssTable,
    RF_StripeNum_t psID, RF_ReconUnitNum_t which_ru, RF_PSSFlags_t flags,
d190 1
a190 2
		Dprintf2("PSS: creating pss for psid %ld ru %d.\n",
		    psID, which_ru);
a199 1
		p->xorBufCount = 0;
d206 4
a209 9
		if (p) {
			/*
			 * We didn't create, but we want to specify
			 * some new status.
			 */
			p->flags |= flags;	/*
						 * Add in whatever flags we're
						 * specifying.
						 */
d212 3
a214 3
		/* If we're asking to block recon, bump the count. */
		p->blockCount++;
		Dprintf3("raid%d: Blocked recon on psid %ld. count now %d.\n",
d219 1
a219 4


/*
 * Deletes an entry from the parity stripe status table. Typically used
d221 1
a221 1
 * no recon was requested while recon was blocked. Assumes the hash
d224 5
a228 3
void
rf_PSStatusDelete(RF_Raid_t *raidPtr, RF_PSStatusHeader_t *pssTable,
    RF_ReconParityStripeStatus_t *pssPtr)
d230 1
a230 2
	RF_PSStatusHeader_t *hdr =
	    &(pssTable[RF_HASH_PSID(raidPtr, pssPtr->parityStripeID)]);
d246 1
a246 1
	RF_ASSERT(0);		/* We must find it here. */
d248 9
a256 13


/*
 * Deletes an entry from the ps status table after reconstruction has
 * completed.
 */
void
rf_RemoveFromActiveReconTable(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_StripeNum_t psid, RF_ReconUnitNum_t which_ru)
{
	RF_PSStatusHeader_t *hdr =
	    &(raidPtr->reconControl[row]
	     ->pssTable[RF_HASH_PSID(raidPtr, psid)]);
d268 1
a268 1
	RF_ASSERT(p);		/* It must be there. */
d270 1
a270 1
	Dprintf2("PSS: deleting pss for psid %ld ru %d.\n", psid, which_ru);
d272 1
a272 1
	/* Delete this entry from the hash chain. */
d281 1
a281 1
	/* Wake-up anyone waiting on the parity stripe ID. */
d285 1
a285 2
		Dprintf1("Waking up access waiting on parity stripe ID %ld.\n",
		    p->parityStripeID);
d289 2
a290 4
		/*
		 * THIS IS WHAT THE ORIGINAL CODE HAD... the extra 0 is bogus,
		 * IMHO.
		 */
d300 2
a301 1
rf_AllocPSStatus(RF_Raid_t *raidPtr)
d305 1
a305 2
	RF_FREELIST_GET_INIT_ARG(raidPtr->pss_freelist, p, next,
	    (RF_ReconParityStripeStatus_t *), rf_init_pss, raidPtr);
d310 2
a311 4
	/*
	 * No need to initialize here b/c the only place we're called from is
	 * the above Lookup.
	 */
d315 4
a318 2
void
rf_FreePSStatus(RF_Raid_t *raidPtr, RF_ReconParityStripeStatus_t *p)
d324 1
a324 2
	RF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist, p, next,
	    rf_clean_pss, raidPtr);
d327 4
a330 2
void
rf_RealPrintPSStatusTable(RF_Raid_t *raidPtr, RF_PSStatusHeader_t *pssTable)
d332 1
a332 1
	int i, j, procsWaiting, blocksWaiting, bufsWaiting;
d346 2
a347 5
			printf("PSID %ld RU %d : blockCount %d %d/%d/%d"
			    " proc/block/buf waiting, issued ",
			    (long) p->parityStripeID, p->which_ru,
			    p->blockCount, procsWaiting, blocksWaiting,
			    bufsWaiting);
d369 4
a372 2
void
rf_PrintPSStatusTable(RF_Raid_t *raidPtr, RF_RowCol_t row)
d375 1
a375 1
	rf_RealPrintPSStatusTable(raidPtr, pssTable);
@


1.3
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_psstatus.c,v 1.2 1999/02/16 00:03:12 niklas Exp $	*/
/*	$NetBSD: rf_psstatus.c,v 1.4 1999/08/13 03:41:57 oster Exp $	*/
a41 1
#include "rf_threadid.h"
a211 2
		int     tid;
		rf_get_threadid(tid);
d214 2
a215 1
		Dprintf3("[%d] Blocked recon on psid %ld.  count now %d\n", tid, psID, p->blockCount);
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_psstatus.c,v 1.1 1999/01/11 14:29:40 niklas Exp $	*/
/*	$NetBSD: rf_psstatus.c,v 1.3 1999/02/05 00:06:15 oster Exp $	*/
a47 1
#include "rf_sys.h"
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_psstatus.c,v 1.1 1998/11/13 04:20:32 oster Exp $	*/
/*	$NetBSD: rf_psstatus.c,v 1.1 1998/11/13 04:20:32 oster Exp $	*/
a39 73
/* :  
 * Log: rf_psstatus.c,v 
 * Revision 1.29  1996/07/27 23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.28  1996/07/15  17:22:18  jimz
 * nit-pick code cleanup
 * resolve stdlib problems on DEC OSF
 *
 * Revision 1.27  1996/07/13  00:00:59  jimz
 * sanitized generalized reconstruction architecture
 * cleaned up head sep, rbuf problems
 *
 * Revision 1.26  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.25  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.24  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.23  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.22  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.21  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.20  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.19  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.18  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.17  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.16  1996/05/20  16:15:27  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.15  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.14  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.13  1995/11/30  16:17:18  wvcii
 * added copyright info
 *
 */

d54 3
a56 2
static void RealPrintPSStatusTable(RF_Raid_t *raidPtr,
	RF_PSStatusHeader_t *pssTable);
d62 1
a62 1
static int init_pss( RF_ReconParityStripeStatus_t  *, RF_Raid_t *);
d66 51
a116 23
static int init_pss(p, raidPtr)
  RF_ReconParityStripeStatus_t  *p;
  RF_Raid_t                     *raidPtr;
{
  RF_Calloc(p->issued, raidPtr->numCol, sizeof(char), (char *));
  if (p->issued == NULL)
    return(ENOMEM);
  return(0);
}

static void clean_pss(p, raidPtr)
  RF_ReconParityStripeStatus_t  *p;
  RF_Raid_t                     *raidPtr;
{
  RF_Free(p->issued, raidPtr->numCol*sizeof(char));
}

static void rf_ShutdownPSStatus(arg)
  void  *arg;
{
	RF_Raid_t *raidPtr = (RF_Raid_t *)arg;

	RF_FREELIST_DESTROY_CLEAN_ARG(raidPtr->pss_freelist,next,(RF_ReconParityStripeStatus_t *),clean_pss,raidPtr);
a117 25

int rf_ConfigurePSStatus(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
{
  int rc;

  raidPtr->pssTableSize = RF_PSS_DEFAULT_TABLESIZE;
  RF_FREELIST_CREATE(raidPtr->pss_freelist, RF_MAX_FREE_PSS,
    RF_PSS_INC, sizeof(RF_ReconParityStripeStatus_t));
  if (raidPtr->pss_freelist == NULL)
    return(ENOMEM);
  rc = rf_ShutdownCreate(listp, rf_ShutdownPSStatus, raidPtr);
  if (rc) {
    RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
      __FILE__, __LINE__, rc);
    rf_ShutdownPSStatus(raidPtr);
    return(rc);
  }
  RF_FREELIST_PRIME_INIT_ARG(raidPtr->pss_freelist, RF_PSS_INITIAL,next,
    (RF_ReconParityStripeStatus_t *),init_pss,raidPtr);
  return(0);
}

d123 40
a162 38
RF_PSStatusHeader_t *rf_MakeParityStripeStatusTable(raidPtr)
  RF_Raid_t  *raidPtr;
{
  RF_PSStatusHeader_t *pssTable;
  int i, j, rc;

  RF_Calloc(pssTable, raidPtr->pssTableSize, sizeof(RF_PSStatusHeader_t), (RF_PSStatusHeader_t *));
  for (i=0; i<raidPtr->pssTableSize; i++) {
    rc = rf_mutex_init(&pssTable[i].mutex);
    if (rc) {
      RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", __FILE__,
        __LINE__, rc);
      /* fail and deallocate */
      for(j=0;j<i;j++) {
        rf_mutex_destroy(&pssTable[i].mutex);
      }
      RF_Free(pssTable, raidPtr->pssTableSize*sizeof(RF_PSStatusHeader_t));
      return(NULL);
    }
  }
  return(pssTable);
}

void rf_FreeParityStripeStatusTable(raidPtr, pssTable)
  RF_Raid_t            *raidPtr;
  RF_PSStatusHeader_t  *pssTable;
{
  int i;

  if (rf_pssDebug)
    RealPrintPSStatusTable(raidPtr, pssTable);
  for (i=0; i<raidPtr->pssTableSize; i++) {
    if (pssTable[i].chain) {
      printf("ERROR: pss hash chain not null at recon shutdown\n");
    }
    rf_mutex_destroy(&pssTable[i].mutex);
  }
  RF_Free(pssTable, raidPtr->pssTableSize * sizeof(RF_PSStatusHeader_t));
d172 49
a220 42
RF_ReconParityStripeStatus_t *rf_LookupRUStatus(
  RF_Raid_t            *raidPtr,
  RF_PSStatusHeader_t  *pssTable,
  RF_StripeNum_t        psID,
  RF_ReconUnitNum_t     which_ru,
  RF_PSSFlags_t         flags, /* whether or not to create it if it doesn't exist + what flags to set initially */
  int                  *created)
{
  RF_PSStatusHeader_t *hdr = &pssTable[ RF_HASH_PSID(raidPtr,psID) ];
  RF_ReconParityStripeStatus_t *p, *pssPtr = hdr->chain;

  *created = 0;
  for (p = pssPtr; p; p=p->next) {
    if (p->parityStripeID == psID && p->which_ru == which_ru)
      break;
  }

  if (!p && (flags&RF_PSS_CREATE)) {
    Dprintf2("PSS: creating pss for psid %ld ru %d\n",psID,which_ru);
    p = rf_AllocPSStatus(raidPtr);
    p->next = hdr->chain;  hdr->chain = p;
    
    p->parityStripeID = psID;
    p->which_ru = which_ru;
    p->flags = flags;
    p->rbuf = NULL;
    p->writeRbuf = NULL;
    p->blockCount = 0;
    p->procWaitList = NULL;
    p->blockWaitList = NULL;
    p->bufWaitList = NULL;
    *created = 1;
  } else if (p) {                                       /* we didn't create, but we want to specify some new status */
    p->flags |= flags;                                  /* add in whatever flags we're specifying */
  }
  if (p && (flags & RF_PSS_RECON_BLOCKED)) {
    int tid;
    rf_get_threadid(tid);
    p->blockCount++;     /* if we're asking to block recon, bump the count */
    Dprintf3("[%d] Blocked recon on psid %ld.  count now %d\n",tid,psID,p->blockCount);
  }
  return(p);
a221 1

d227 23
a249 18
void rf_PSStatusDelete(raidPtr, pssTable, pssPtr)
  RF_Raid_t                     *raidPtr;
  RF_PSStatusHeader_t           *pssTable;
  RF_ReconParityStripeStatus_t  *pssPtr;
{
  RF_PSStatusHeader_t *hdr = &(pssTable[ RF_HASH_PSID(raidPtr,pssPtr->parityStripeID) ] );
  RF_ReconParityStripeStatus_t *p = hdr->chain, *pt = NULL;

  while (p) {
    if (p == pssPtr) {
      if (pt) pt->next = p->next; else hdr->chain = p->next;
      p->next = NULL;
      rf_FreePSStatus(raidPtr, p);
      return;
    }
    pt = p; p=p->next;
  }
  RF_ASSERT(0);              /* we must find it here */
a250 1

d252 124
a375 105
void rf_RemoveFromActiveReconTable(raidPtr, row, psid, which_ru)
  RF_Raid_t          *raidPtr;
  RF_RowCol_t         row;
  RF_ReconUnitNum_t   which_ru;
  RF_StripeNum_t      psid;
{
  RF_PSStatusHeader_t *hdr = &(raidPtr->reconControl[row]->pssTable[ RF_HASH_PSID(raidPtr,psid) ]);
  RF_ReconParityStripeStatus_t *p, *pt;
  RF_CallbackDesc_t *cb, *cb1;
  
  RF_LOCK_MUTEX( hdr->mutex );
  for (pt=NULL, p = hdr->chain; p; pt=p,p=p->next) {
    if ((p->parityStripeID == psid) && (p->which_ru == which_ru))
      break;
  }
  if (p == NULL) {
    rf_PrintPSStatusTable(raidPtr, row);
  }
  RF_ASSERT(p); /* it must be there */

  Dprintf2("PSS: deleting pss for psid %ld ru %d\n",psid,which_ru);

  /* delete this entry from the hash chain */
  if (pt) pt->next = p->next;
  else hdr->chain = p->next;
  p->next = NULL;

  RF_UNLOCK_MUTEX( hdr->mutex );

  /* wakup anyone waiting on the parity stripe ID */
  cb = p->procWaitList;
  p->procWaitList = NULL;
  while (cb) {
    Dprintf1("Waking up access waiting on parity stripe ID %ld\n",p->parityStripeID);
    cb1 = cb->next;
    (cb->callbackFunc)(cb->callbackArg);

    /* THIS IS WHAT THE ORIGINAL CODE HAD... the extra 0 is bogus, IMHO */
    /*     (cb->callbackFunc)(cb->callbackArg, 0); */
    rf_FreeCallbackDesc(cb);
    cb = cb1;
  }

  rf_FreePSStatus(raidPtr, p);
}

RF_ReconParityStripeStatus_t *rf_AllocPSStatus(raidPtr)
  RF_Raid_t  *raidPtr;
{
  RF_ReconParityStripeStatus_t *p;

  RF_FREELIST_GET_INIT_ARG(raidPtr->pss_freelist,p,next,(RF_ReconParityStripeStatus_t *),init_pss,raidPtr);
  if (p) {
    bzero(p->issued, raidPtr->numCol);
  }
  p->next = NULL;
  /* no need to initialize here b/c the only place we're called from is the above Lookup */
  return(p);
}

void rf_FreePSStatus(raidPtr, p)
  RF_Raid_t                     *raidPtr;
  RF_ReconParityStripeStatus_t  *p;
{
  RF_ASSERT(p->procWaitList == NULL);
  RF_ASSERT(p->blockWaitList == NULL);
  RF_ASSERT(p->bufWaitList == NULL);

  RF_FREELIST_FREE_CLEAN_ARG(raidPtr->pss_freelist,p,next,clean_pss,raidPtr);
}

static void RealPrintPSStatusTable(raidPtr, pssTable)
  RF_Raid_t            *raidPtr;
  RF_PSStatusHeader_t  *pssTable;
{
  int i, j, procsWaiting, blocksWaiting, bufsWaiting;
  RF_ReconParityStripeStatus_t *p;
  RF_CallbackDesc_t *cb;

  printf("\nParity Stripe Status Table\n");
  for (i=0; i< raidPtr->pssTableSize; i++) {
    for (p = pssTable[i].chain; p; p=p->next) {
      procsWaiting = blocksWaiting = bufsWaiting = 0;
      for (cb = p->procWaitList; cb; cb=cb->next) procsWaiting++;
      for (cb = p->blockWaitList; cb; cb=cb->next) blocksWaiting++;
      for (cb = p->bufWaitList; cb; cb=cb->next) bufsWaiting++;
      printf("PSID %ld RU %d : blockCount %d %d/%d/%d proc/block/buf waiting, issued ",
	     (long)p->parityStripeID, p->which_ru, p->blockCount, procsWaiting, blocksWaiting, bufsWaiting);
      for (j=0;j<raidPtr->numCol; j++) printf("%c", (p->issued[j]) ? '1' : '0');
      if (!p->flags) printf(" flags: (none)");
      else {
	if (p->flags & RF_PSS_UNDER_RECON) printf(" under-recon");
	if (p->flags & RF_PSS_FORCED_ON_WRITE) printf(" forced-w");
	if (p->flags & RF_PSS_FORCED_ON_READ) printf(" forced-r");
	if (p->flags & RF_PSS_RECON_BLOCKED) printf(" blocked");
	if (p->flags & RF_PSS_BUFFERWAIT) printf(" bufwait");
      }
      printf("\n");
    }
  }
}

void rf_PrintPSStatusTable(raidPtr, row)
  RF_Raid_t    *raidPtr;
  RF_RowCol_t   row;
d377 2
a378 2
  RF_PSStatusHeader_t *pssTable = raidPtr->reconControl[row]->pssTable;
  RealPrintPSStatusTable(raidPtr, pssTable);
@

