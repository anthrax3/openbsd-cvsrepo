head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.38
	OPENBSD_5_0:1.4.0.36
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.8
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.4;

1.4
date	2002.12.16.07.01.05;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.08.16.07.44;	author peter;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	99.02.16.00.03.20;	author niklas;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	99.01.11.14.29.45;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.22.26.13;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_reconbuffer.c,v 1.4 2002/12/16 07:01:05 tdeval Exp $	*/
/*	$NetBSD: rf_reconbuffer.c,v 1.4 2000/03/13 23:52:36 soren Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************
 *
 * rf_reconbuffer.c -- Reconstruction buffer manager.
 *
 *****************************************************/

#include "rf_raid.h"
#include "rf_reconbuffer.h"
#include "rf_acctrace.h"
#include "rf_etimer.h"
#include "rf_general.h"
#include "rf_debugprint.h"
#include "rf_revent.h"
#include "rf_reconutil.h"
#include "rf_nwayxor.h"

#define	Dprintf1(s,a) if (rf_reconbufferDebug) printf(s, a)
#define	Dprintf2(s,a,b) if (rf_reconbufferDebug) printf(s, a, b)
#define	Dprintf3(s,a,b,c) if (rf_reconbufferDebug) printf(s, a, b, c)
#define	Dprintf4(s,a,b,c,d) if (rf_reconbufferDebug) printf(s, a, b, c, d)
#define	Dprintf5(s,a,b,c,d,e) if (rf_reconbufferDebug) printf(s, a, b, c, d, e)

/*****************************************************************************
 *
 * Submit a reconstruction buffer to the manager for XOR.
 * We can only submit a buffer if (1) we can xor into an existing buffer,
 * which means we don't have to acquire a new one, (2) we can acquire a
 * floating recon buffer, or (3) the caller has indicated that we are allowed
 * to keep the submitted buffer.
 *
 * Returns non-zero if and only if we were not able to submit.
 * In this case, we append the current disk ID to the wait list on the
 * indicated RU, so that it will be re-enabled when we acquire a buffer for
 * this RU.
 *
 *****************************************************************************/

/* Just to make the code below more readable. */
#define	BUFWAIT_APPEND(_cb_,_pssPtr_,_row_,_col_)			\
do {									\
	_cb_ = rf_AllocCallbackDesc();					\
	(_cb_)->row = (_row_);						\
	(_cb_)->col = (_col_);						\
	(_cb_)->next = (_pssPtr_)->bufWaitList;				\
	(_pssPtr_)->bufWaitList = (_cb_);				\
} while (0)

/*
 * rf_nWayXorFuncs[i] is a pointer to a function that will xor "i"
 * bufs into the accumulating sum.
 */
static RF_VoidFuncPtr rf_nWayXorFuncs[] = {
	NULL,
	(RF_VoidFuncPtr) rf_nWayXor1,
	(RF_VoidFuncPtr) rf_nWayXor2,
	(RF_VoidFuncPtr) rf_nWayXor3,
	(RF_VoidFuncPtr) rf_nWayXor4,
	(RF_VoidFuncPtr) rf_nWayXor5,
	(RF_VoidFuncPtr) rf_nWayXor6,
	(RF_VoidFuncPtr) rf_nWayXor7,
	(RF_VoidFuncPtr) rf_nWayXor8,
	(RF_VoidFuncPtr) rf_nWayXor9
};


int
rf_SubmitReconBuffer(
    RF_ReconBuffer_t	*rbuf,		/* The recon buffer to submit. */
    int			 keep_it,	/*
					 * Whether we can keep this buffer or
					 * we have to return it.
					 */
    int			 use_committed	/*
					 * Whether to use a committed or an
					 * available recon buffer.
					 */
)
{
	RF_LayoutSW_t *lp;
	int rc;

	lp = rbuf->raidPtr->Layout.map;
	rc = lp->SubmitReconBuffer(rbuf, keep_it, use_committed);
	return (rc);
}

int
rf_SubmitReconBufferBasic(
    RF_ReconBuffer_t	*rbuf,		/* The recon buffer to submit. */
    int			 keep_it,	/*
					 * Whether we can keep this buffer
					 * or we have to return it.
					 */
    int			 use_committed	/*
					 * Whether to use a committed or
					 * an available recon buffer.
					 */
)
{
	RF_Raid_t *raidPtr = rbuf->raidPtr;
	RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
	RF_ReconCtrl_t *reconCtrlPtr = raidPtr->reconControl[rbuf->row];
	RF_ReconParityStripeStatus_t *pssPtr;
	/* Temporary rbuf pointers. */
	RF_ReconBuffer_t *targetRbuf, *t = NULL;
	/* Temporary data buffer pointer. */
	caddr_t ta;
	RF_CallbackDesc_t *cb, *p;
	int retcode = 0, created = 0;

	RF_Etimer_t timer;

	/* Makes no sense to have a submission from the failed disk. */
	RF_ASSERT(rbuf);
	RF_ASSERT(rbuf->col != reconCtrlPtr->fcol);

	Dprintf5("RECON: submission by row %d col %d for psid %ld ru %d"
	    " (failed offset %ld).\n", rbuf->row, rbuf->col,
	    (long) rbuf->parityStripeID, rbuf->which_ru,
	    (long) rbuf->failedDiskSectorOffset);

	RF_LOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);

	RF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);

	pssPtr = rf_LookupRUStatus(raidPtr, reconCtrlPtr->pssTable,
	    rbuf->parityStripeID, rbuf->which_ru, RF_PSS_NONE, &created);
	RF_ASSERT(pssPtr);	/*
				 * If it didn't exist, we wouldn't have gotten
				 * an rbuf for it.
				 */

	/*
	 * Check to see if enough buffers have accumulated to do an XOR. If
	 * so, there's no need to acquire a floating rbuf. Before we can do
	 * any XORing, we must have acquired a destination buffer. If we
	 * have, then we can go ahead and do the XOR if (1) including this
	 * buffer, enough bufs have accumulated, or (2) this is the last
	 * submission for this stripe. Otherwise, we have to go acquire a
	 * floating rbuf.
	 */

	targetRbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;
	if ((targetRbuf != NULL) &&
	    ((pssPtr->xorBufCount == rf_numBufsToAccumulate - 1) ||
	     (targetRbuf->count + pssPtr->xorBufCount + 1 ==
	      layoutPtr->numDataCol))) {
		/* Install this buffer. */
		pssPtr->rbufsForXor[pssPtr->xorBufCount++] = rbuf;
		Dprintf3("RECON: row %d col %d invoking a %d-way XOR.\n",
		    rbuf->row, rbuf->col, pssPtr->xorBufCount);
		RF_ETIMER_START(timer);
		rf_MultiWayReconXor(raidPtr, pssPtr);
		RF_ETIMER_STOP(timer);
		RF_ETIMER_EVAL(timer);
		raidPtr->accumXorTimeUs += RF_ETIMER_VAL_US(timer);
		if (!keep_it) {
			raidPtr->recon_tracerecs[rbuf->col].xor_us =
			    RF_ETIMER_VAL_US(timer);
			RF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col]
			    .recon_timer);
			RF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col]
			    .recon_timer);
			raidPtr->recon_tracerecs[rbuf->col]
			    .specific.recon.recon_return_to_submit_us +=
			     RF_ETIMER_VAL_US(raidPtr
			      ->recon_tracerecs[rbuf->col].recon_timer);
			RF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col]
			   .recon_timer);

			rf_LogTraceRec(raidPtr,
			    &raidPtr->recon_tracerecs[rbuf->col]);
		}
		rf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr,
		    layoutPtr->numDataCol);

		/*
		 * If use_committed is on, we _must_ consume a buffer off the
		 * committed list.
		 */
		if (use_committed) {
			t = reconCtrlPtr->committedRbufs;
			RF_ASSERT(t);
			reconCtrlPtr->committedRbufs = t->next;
			rf_ReleaseFloatingReconBuffer(raidPtr, rbuf->row, t);
		}
		if (keep_it) {
			RF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row,
			    rbuf->parityStripeID);
			RF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);
			rf_FreeReconBuffer(rbuf);
			return (retcode);
		}
		goto out;
	}
	/* Set the value of "t", which we'll use as the rbuf from here on. */
	if (keep_it) {
		t = rbuf;
	} else {
		if (use_committed) {
			/* If a buffer has been committed to us, use it. */

			t = reconCtrlPtr->committedRbufs;
			RF_ASSERT(t);
			reconCtrlPtr->committedRbufs = t->next;
			t->next = NULL;
		} else
			if (reconCtrlPtr->floatingRbufs) {
				t = reconCtrlPtr->floatingRbufs;
				reconCtrlPtr->floatingRbufs = t->next;
				t->next = NULL;
			}
	}

	/*
	 * If we weren't able to acquire a buffer, append to the end of the
	 * buf list in the recon ctrl struct.
	 */
	if (!t) {
		RF_ASSERT(!keep_it && !use_committed);
		Dprintf2("RECON: row %d col %d failed to acquire floating"
		    " rbuf.\n", rbuf->row, rbuf->col);

		raidPtr->procsInBufWait++;
		if ((raidPtr->procsInBufWait == raidPtr->numCol - 1) &&
		    (raidPtr->numFullReconBuffers == 0)) {
			printf("Buffer wait deadlock detected. Exiting.\n");
			rf_PrintPSStatusTable(raidPtr, rbuf->row);
			RF_PANIC();
		}
		pssPtr->flags |= RF_PSS_BUFFERWAIT;
		/* Append to buf wait list in recon ctrl structure. */
		cb = rf_AllocCallbackDesc();
		cb->row = rbuf->row;
		cb->col = rbuf->col;
		cb->callbackArg.v = rbuf->parityStripeID;
		cb->callbackArg2.v = rbuf->which_ru;
		cb->next = NULL;
		if (!reconCtrlPtr->bufferWaitList)
			reconCtrlPtr->bufferWaitList = cb;
		else {
			/*
			 * Might want to maintain head/tail pointers
			 * here rather than search for end of list.
			 */
			for (p = reconCtrlPtr->bufferWaitList; p->next;
			     p = p->next);
			p->next = cb;
		}
		retcode = 1;
		goto out;
	}
	Dprintf2("RECON: row %d col %d acquired rbuf.\n", rbuf->row, rbuf->col);
	RF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
	RF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
	raidPtr->recon_tracerecs[rbuf->col]
	    .specific.recon.recon_return_to_submit_us +=
	     RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
	RF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col].recon_timer);

	rf_LogTraceRec(raidPtr, &raidPtr->recon_tracerecs[rbuf->col]);

	/* Initialize the buffer. */
	if (t != rbuf) {
		t->row = rbuf->row;
		t->col = reconCtrlPtr->fcol;
		t->parityStripeID = rbuf->parityStripeID;
		t->which_ru = rbuf->which_ru;
		t->failedDiskSectorOffset = rbuf->failedDiskSectorOffset;
		t->spRow = rbuf->spRow;
		t->spCol = rbuf->spCol;
		t->spOffset = rbuf->spOffset;

		ta = t->buffer;
		t->buffer = rbuf->buffer;
		rbuf->buffer = ta;	/* Swap buffers. */
	}
	/*
	 * The first installation always gets installed as the destination
	 * buffer. Subsequent installations get stacked up to allow for
	 * multi-way XOR.
	 */
	if (!pssPtr->rbuf) {
		pssPtr->rbuf = t;
		t->count = 1;
	} else
		/* Install this buffer. */
		pssPtr->rbufsForXor[pssPtr->xorBufCount++] = t;

	/* The buffer is full if G=2. */
	rf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr,
	    layoutPtr->numDataCol);

out:
	RF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);
	RF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);
	return (retcode);
}

int
rf_MultiWayReconXor(
    RF_Raid_t			 *raidPtr,
    RF_ReconParityStripeStatus_t *pssPtr	/*
						 * The pss descriptor for this
						 * parity stripe.
						 */
)
{
	int i, numBufs = pssPtr->xorBufCount;
	int numBytes = rf_RaidAddressToByte(raidPtr,
	    raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU);
	RF_ReconBuffer_t **rbufs = (RF_ReconBuffer_t **) pssPtr->rbufsForXor;
	RF_ReconBuffer_t *targetRbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;

	RF_ASSERT(pssPtr->rbuf != NULL);
	RF_ASSERT(numBufs > 0 && numBufs < RF_PS_MAX_BUFS);
#ifdef	_KERNEL
#if	!defined(__NetBSD__) && !defined(__OpenBSD__)
	/* Yield the processor before doing a big XOR. */
	thread_block();
#endif
#endif	/* _KERNEL */
	/*
	 * XXX
	 *
	 * What if more than 9 bufs ?
	 */
	rf_nWayXorFuncs[numBufs] (pssPtr->rbufsForXor, targetRbuf,
	    numBytes / sizeof(long));

	/*
	 * Release all the reconstruction buffers except the last one, which
	 * belongs to the disk whose submission caused this XOR to take place.
	 */
	for (i = 0; i < numBufs - 1; i++) {
		if (rbufs[i]->type == RF_RBUF_TYPE_FLOATING)
			rf_ReleaseFloatingReconBuffer(raidPtr, rbufs[i]->row,
			    rbufs[i]);
		else
			if (rbufs[i]->type == RF_RBUF_TYPE_FORCED)
				rf_FreeReconBuffer(rbufs[i]);
			else
				RF_ASSERT(0);
	}
	targetRbuf->count += pssPtr->xorBufCount;
	pssPtr->xorBufCount = 0;
	return (0);
}


/*
 * Removes one full buffer from one of the full-buffer lists and returns it.
 *
 * ASSUMES THE RB_MUTEX IS UNLOCKED AT ENTRY.
 */
RF_ReconBuffer_t *
rf_GetFullReconBuffer(RF_ReconCtrl_t *reconCtrlPtr)
{
	RF_ReconBuffer_t *p;

	RF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);

	if ((p = reconCtrlPtr->priorityList) != NULL) {
		reconCtrlPtr->priorityList = p->next;
		p->next = NULL;
		goto out;
	}
	if ((p = reconCtrlPtr->fullBufferList) != NULL) {
		reconCtrlPtr->fullBufferList = p->next;
		p->next = NULL;
		goto out;
	}
out:
	RF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);
	return (p);
}


/*
 * If the reconstruction buffer is full, move it to the full list, which
 * is maintained sorted by failed disk sector offset.
 *
 * ASSUMES THE RB_MUTEX IS LOCKED AT ENTRY.
 */
int
rf_CheckForFullRbuf(RF_Raid_t *raidPtr, RF_ReconCtrl_t *reconCtrl,
    RF_ReconParityStripeStatus_t *pssPtr, int numDataCol)
{
	RF_ReconBuffer_t *p, *pt, *rbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;

	if (rbuf->count == numDataCol) {
		raidPtr->numFullReconBuffers++;
		Dprintf2("RECON: rbuf for psid %ld ru %d has filled.\n",
		    (long) rbuf->parityStripeID, rbuf->which_ru);
		if (!reconCtrl->fullBufferList ||
		    (rbuf->failedDiskSectorOffset <
		     reconCtrl->fullBufferList->failedDiskSectorOffset)) {
			Dprintf2("RECON: rbuf for psid %ld ru %d is head of"
			    " list.\n", (long) rbuf->parityStripeID,
			    rbuf->which_ru);
			rbuf->next = reconCtrl->fullBufferList;
			reconCtrl->fullBufferList = rbuf;
		} else {
			for (pt = reconCtrl->fullBufferList, p = pt->next;
			     p && p->failedDiskSectorOffset <
			      rbuf->failedDiskSectorOffset;
			     pt = p, p = p->next);
			rbuf->next = p;
			pt->next = rbuf;
			Dprintf2("RECON: rbuf for psid %ld ru %d is in list.\n",
			    (long) rbuf->parityStripeID, rbuf->which_ru);
		}
#if 0
		pssPtr->writeRbuf = pssPtr->rbuf;	/*
							 * DEBUG ONLY: We like
							 * to be able to find
							 * this rbuf while it's
							 * awaiting write.
							 */
#else
		rbuf->pssPtr = pssPtr;
#endif
		pssPtr->rbuf = NULL;
		rf_CauseReconEvent(raidPtr, rbuf->row, rbuf->col, NULL,
		    RF_REVENT_BUFREADY);
	}
	return (0);
}


/*
 * Release a floating recon buffer for someone else to use.
 * Assumes the rb_mutex is LOCKED at entry.
 */
void
rf_ReleaseFloatingReconBuffer(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_ReconBuffer_t *rbuf)
{
	RF_ReconCtrl_t *rcPtr = raidPtr->reconControl[row];
	RF_CallbackDesc_t *cb;

	Dprintf2("RECON: releasing rbuf for psid %ld ru %d.\n",
	    (long) rbuf->parityStripeID, rbuf->which_ru);

	/*
	 * If anyone is waiting on buffers, wake one of them up. They will
	 * subsequently wake up anyone else waiting on their RU.
	 */
	if (rcPtr->bufferWaitList) {
		rbuf->next = rcPtr->committedRbufs;
		rcPtr->committedRbufs = rbuf;
		cb = rcPtr->bufferWaitList;
		rcPtr->bufferWaitList = cb->next;
		/* arg==1 => We've committed a buffer. */
		rf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1,
		    RF_REVENT_BUFCLEAR);
		rf_FreeCallbackDesc(cb);
		raidPtr->procsInBufWait--;
	} else {
		rbuf->next = rcPtr->floatingRbufs;
		rcPtr->floatingRbufs = rbuf;
	}
}


/*
 * Release any disk that is waiting on a buffer for the indicated RU.
 * Assumes the rb_mutex is LOCKED at entry.
 */
void
rf_ReleaseBufferWaiters(
    RF_Raid_t			 *raidPtr,
    RF_ReconParityStripeStatus_t *pssPtr
)
{
	RF_CallbackDesc_t *cb1, *cb = pssPtr->bufWaitList;

	Dprintf2("RECON: releasing buf waiters for psid %ld ru %d.\n",
	    (long) pssPtr->parityStripeID, pssPtr->which_ru);
	pssPtr->flags &= ~RF_PSS_BUFFERWAIT;
	while (cb) {
		cb1 = cb->next;
		cb->next = NULL;
		/* arg==0 => We haven't committed a buffer. */
		rf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 0,
		    RF_REVENT_BUFCLEAR);
		rf_FreeCallbackDesc(cb);
		cb = cb1;
	}
	pssPtr->bufWaitList = NULL;
}


/*
 * When reconstruction is forced on an RU, there may be some disks waiting to
 * acquire a buffer for that RU. Since we allocate a new buffer as part of
 * the forced-reconstruction process, we no longer have to wait for any
 * buffers, so we wakeup any waiter that we find in the bufferWaitList.
 *
 * Assumes the rb_mutex is LOCKED at entry.
 */
void
rf_ReleaseBufferWaiter(RF_ReconCtrl_t *rcPtr, RF_ReconBuffer_t *rbuf)
{
	RF_CallbackDesc_t *cb, *cbt;

	for (cbt = NULL, cb = rcPtr->bufferWaitList; cb;
	     cbt = cb, cb = cb->next) {
		if ((cb->callbackArg.v == rbuf->parityStripeID) &&
		    (cb->callbackArg2.v == rbuf->which_ru)) {
			Dprintf2("RECON: Dropping row %d col %d from buffer"
			    " wait list.\n", cb->row, cb->col);
			if (cbt)
				cbt->next = cb->next;
			else
				rcPtr->bufferWaitList = cb->next;

			/* arg==0 => No committed buffer. */
			rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr,
			    cb->row, cb->col, (void *) 0, RF_REVENT_BUFREADY);
			rf_FreeCallbackDesc(cb);
			return;
		}
	}
}
@


1.4
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconbuffer.c,v 1.3 2000/08/08 16:07:44 peter Exp $	*/
@


1.3
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconbuffer.c,v 1.2 1999/02/16 00:03:20 niklas Exp $	*/
d3 1
d31 1
a31 1
/***************************************************
d33 1
a33 1
 * rf_reconbuffer.c -- reconstruction buffer manager
d35 1
a35 1
 ***************************************************/
d47 5
a51 5
#define Dprintf1(s,a) if (rf_reconbufferDebug) printf(s,a)
#define Dprintf2(s,a,b) if (rf_reconbufferDebug) printf(s,a,b)
#define Dprintf3(s,a,b,c) if (rf_reconbufferDebug) printf(s,a,b,c)
#define Dprintf4(s,a,b,c,d) if (rf_reconbufferDebug) printf(s,a,b,c,d)
#define Dprintf5(s,a,b,c,d,e) if (rf_reconbufferDebug) printf(s,a,b,c,d,e)
d53 1
a53 1
/*****************************************************************************************
d56 4
a59 4
 * We can only submit a buffer if (1) we can xor into an existing buffer, which means
 * we don't have to acquire a new one, (2) we can acquire a floating
 * recon buffer, or (3) the caller has indicated that we are allowed to keep the
 * submitted buffer.
d62 15
a76 9
 * In this case, we append the current disk ID to the wait list on the indicated
 * RU, so that it will be re-enabled when we acquire a buffer for this RU.
 *
 ****************************************************************************************/

/* just to make the code below more readable */
#define BUFWAIT_APPEND(_cb_, _pssPtr_, _row_, _col_) \
  _cb_ = rf_AllocCallbackDesc();                    \
  (_cb_)->row = (_row_); (_cb_)->col = (_col_); (_cb_)->next = (_pssPtr_)->bufWaitList; (_pssPtr_)->bufWaitList = (_cb_);
d79 1
a79 1
 * nWayXorFuncs[i] is a pointer to a function that will xor "i"
d82 1
a82 1
static RF_VoidFuncPtr nWayXorFuncs[] = {
d95 13
a107 7
int 
rf_SubmitReconBuffer(rbuf, keep_it, use_committed)
	RF_ReconBuffer_t *rbuf;	/* the recon buffer to submit */
	int     keep_it;	/* whether we can keep this buffer or we have
				 * to return it */
	int     use_committed;	/* whether to use a committed or an available
				 * recon buffer */
d110 1
a110 1
	int     rc;
d117 12
a128 7
int 
rf_SubmitReconBufferBasic(rbuf, keep_it, use_committed)
	RF_ReconBuffer_t *rbuf;	/* the recon buffer to submit */
	int     keep_it;	/* whether we can keep this buffer or we have
				 * to return it */
	int     use_committed;	/* whether to use a committed or an available
				 * recon buffer */
d134 4
a137 3
	RF_ReconBuffer_t *targetRbuf, *t = NULL;	/* temporary rbuf
							 * pointers */
	caddr_t ta;		/* temporary data buffer pointer */
d139 1
a139 1
	int     retcode = 0, created = 0;
d143 1
a143 1
	/* makes no sense to have a submission from the failed disk */
d147 4
a150 2
	Dprintf5("RECON: submission by row %d col %d for psid %ld ru %d (failed offset %ld)\n",
	    rbuf->row, rbuf->col, (long) rbuf->parityStripeID, rbuf->which_ru, (long) rbuf->failedDiskSectorOffset);
d156 11
a166 7
	pssPtr = rf_LookupRUStatus(raidPtr, reconCtrlPtr->pssTable, rbuf->parityStripeID, rbuf->which_ru, RF_PSS_NONE, &created);
	RF_ASSERT(pssPtr);	/* if it didn't exist, we wouldn't have gotten
				 * an rbuf for it */

	/* check to see if enough buffers have accumulated to do an XOR.  If
	 * so, there's no need to acquire a floating rbuf.  Before we can do
	 * any XORing, we must have acquired a destination buffer.  If we
d170 2
a171 1
	 * floating rbuf. */
d175 7
a181 3
	    ((pssPtr->xorBufCount == rf_numBufsToAccumulate - 1) || (targetRbuf->count + pssPtr->xorBufCount + 1 == layoutPtr->numDataCol))) {
		pssPtr->rbufsForXor[pssPtr->xorBufCount++] = rbuf;	/* install this buffer */
		Dprintf3("RECON: row %d col %d invoking a %d-way XOR\n", rbuf->row, rbuf->col, pssPtr->xorBufCount);
d188 12
a199 6
			raidPtr->recon_tracerecs[rbuf->col].xor_us = RF_ETIMER_VAL_US(timer);
			RF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
			RF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
			raidPtr->recon_tracerecs[rbuf->col].specific.recon.recon_return_to_submit_us +=
			    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
			RF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
d201 2
a202 1
			rf_LogTraceRec(raidPtr, &raidPtr->recon_tracerecs[rbuf->col]);
d204 2
a205 1
		rf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr, layoutPtr->numDataCol);
d207 4
a210 2
		/* if use_committed is on, we _must_ consume a buffer off the
		 * committed list. */
d218 2
a219 1
			RF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row, rbuf->parityStripeID);
d226 1
a226 1
	/* set the value of "t", which we'll use as the rbuf from here on */
d230 3
a232 2
		if (use_committed) {	/* if a buffer has been committed to
					 * us, use it */
d245 4
a248 2
	/* If we weren't able to acquire a buffer, append to the end of the
	 * buf list in the recon ctrl struct. */
d251 2
a252 1
		Dprintf2("RECON: row %d col %d failed to acquire floating rbuf\n", rbuf->row, rbuf->col);
d255 3
a257 2
		if ((raidPtr->procsInBufWait == raidPtr->numCol - 1) && (raidPtr->numFullReconBuffers == 0)) {
			printf("Buffer wait deadlock detected.  Exiting.\n");
d262 2
a263 2
		cb = rf_AllocCallbackDesc();	/* append to buf wait list in
						 * recon ctrl structure */
d271 7
a277 3
		else {		/* might want to maintain head/tail pointers
				 * here rather than search for end of list */
			for (p = reconCtrlPtr->bufferWaitList; p->next; p = p->next);
d283 1
a283 1
	Dprintf2("RECON: row %d col %d acquired rbuf\n", rbuf->row, rbuf->col);
d286 3
a288 2
	raidPtr->recon_tracerecs[rbuf->col].specific.recon.recon_return_to_submit_us +=
	    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
d293 1
a293 1
	/* initialize the buffer */
d306 1
a306 1
		rbuf->buffer = ta;	/* swap buffers */
d308 5
a312 3
	/* the first installation always gets installed as the destination
	 * buffer. subsequent installations get stacked up to allow for
	 * multi-way XOR */
d317 2
a318 1
		pssPtr->rbufsForXor[pssPtr->xorBufCount++] = t;	/* install this buffer */
d320 3
a322 2
	rf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr, layoutPtr->numDataCol);	/* the buffer is full if
											 * G=2 */
d330 8
a337 5
int 
rf_MultiWayReconXor(raidPtr, pssPtr)
	RF_Raid_t *raidPtr;
	RF_ReconParityStripeStatus_t *pssPtr;	/* the pss descriptor for this
						 * parity stripe */
d339 3
a341 2
	int     i, numBufs = pssPtr->xorBufCount;
	int     numBytes = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU);
d347 4
a350 3
#ifdef _KERNEL
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
	thread_block();		/* yield the processor before doing a big XOR */
d352 1
a352 1
#endif				/* _KERNEL */
d354 6
a359 5
         * XXX
         *
         * What if more than 9 bufs?
         */
	nWayXorFuncs[numBufs] (pssPtr->rbufsForXor, targetRbuf, numBytes / sizeof(long));
d361 4
a364 2
	/* release all the reconstruction buffers except the last one, which
	 * belongs to the disk whose submission caused this XOR to take place */
d367 2
a368 1
			rf_ReleaseFloatingReconBuffer(raidPtr, rbufs[i]->row, rbufs[i]);
d379 4
a382 1
/* removes one full buffer from one of the full-buffer lists and returns it.
d387 1
a387 2
rf_GetFullReconBuffer(reconCtrlPtr)
	RF_ReconCtrl_t *reconCtrlPtr;
d409 3
a411 2
/* if the reconstruction buffer is full, move it to the full list, which is maintained
 * sorted by failed disk sector offset
d415 3
a417 6
int 
rf_CheckForFullRbuf(raidPtr, reconCtrl, pssPtr, numDataCol)
	RF_Raid_t *raidPtr;
	RF_ReconCtrl_t *reconCtrl;
	RF_ReconParityStripeStatus_t *pssPtr;
	int     numDataCol;
d423 1
a423 1
		Dprintf2("RECON: rbuf for psid %ld ru %d has filled\n",
d425 6
a430 3
		if (!reconCtrl->fullBufferList || (rbuf->failedDiskSectorOffset < reconCtrl->fullBufferList->failedDiskSectorOffset)) {
			Dprintf2("RECON: rbuf for psid %ld ru %d is head of list\n",
			    (long) rbuf->parityStripeID, rbuf->which_ru);
d434 4
a437 1
			for (pt = reconCtrl->fullBufferList, p = pt->next; p && p->failedDiskSectorOffset < rbuf->failedDiskSectorOffset; pt = p, p = p->next);
d440 1
a440 1
			Dprintf2("RECON: rbuf for psid %ld ru %d is in list\n",
d444 2
a445 1
		pssPtr->writeRbuf = pssPtr->rbuf;	/* DEBUG ONLY:  we like
d448 2
a449 1
							 * awaiting write */
d454 2
a455 1
		rf_CauseReconEvent(raidPtr, rbuf->row, rbuf->col, NULL, RF_REVENT_BUFREADY);
d461 3
a463 2
/* release a floating recon buffer for someone else to use.
 * assumes the rb_mutex is LOCKED at entry
d465 3
a467 5
void 
rf_ReleaseFloatingReconBuffer(raidPtr, row, rbuf)
	RF_Raid_t *raidPtr;
	RF_RowCol_t row;
	RF_ReconBuffer_t *rbuf;
d472 1
a472 1
	Dprintf2("RECON: releasing rbuf for psid %ld ru %d\n",
d475 4
a478 2
	/* if anyone is waiting on buffers, wake one of them up.  They will
	 * subsequently wake up anyone else waiting on their RU */
d484 3
a486 2
		rf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1, RF_REVENT_BUFCLEAR);	/* arg==1 => we've
												 * committed a buffer */
d494 5
a498 2
/* release any disk that is waiting on a buffer for the indicated RU.
 * assumes the rb_mutex is LOCKED at entry
d500 5
a504 4
void 
rf_ReleaseBufferWaiters(raidPtr, pssPtr)
	RF_Raid_t *raidPtr;
	RF_ReconParityStripeStatus_t *pssPtr;
d508 1
a508 1
	Dprintf2("RECON: releasing buf waiters for psid %ld ru %d\n",
d514 3
a516 2
		rf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 0, RF_REVENT_BUFCLEAR);	/* arg==0 => we haven't
												 * committed a buffer */
d522 5
a526 2
/* when reconstruction is forced on an RU, there may be some disks waiting to
 * acquire a buffer for that RU.  Since we allocate a new buffer as part of
d528 1
a528 1
 * buffers, so we wakeup any waiter that we find in the bufferWaitList
d530 1
a530 1
 * assumes the rb_mutex is LOCKED at entry
d532 2
a533 4
void 
rf_ReleaseBufferWaiter(rcPtr, rbuf)
	RF_ReconCtrl_t *rcPtr;
	RF_ReconBuffer_t *rbuf;
d537 6
a542 3
	for (cbt = NULL, cb = rcPtr->bufferWaitList; cb; cbt = cb, cb = cb->next) {
		if ((cb->callbackArg.v == rbuf->parityStripeID) && (cb->callbackArg2.v == rbuf->which_ru)) {
			Dprintf2("RECON: Dropping row %d col %d from buffer wait list\n", cb->row, cb->col);
d547 4
a550 2
			rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, cb->row, cb->col, (void *) 0, RF_REVENT_BUFREADY);	/* arg==0 => no
																 * committed buffer */
@


1.3.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************
d32 1
a32 1
 * rf_reconbuffer.c -- Reconstruction buffer manager.
d34 1
a34 1
 *****************************************************/
d46 5
a50 5
#define	Dprintf1(s,a) if (rf_reconbufferDebug) printf(s, a)
#define	Dprintf2(s,a,b) if (rf_reconbufferDebug) printf(s, a, b)
#define	Dprintf3(s,a,b,c) if (rf_reconbufferDebug) printf(s, a, b, c)
#define	Dprintf4(s,a,b,c,d) if (rf_reconbufferDebug) printf(s, a, b, c, d)
#define	Dprintf5(s,a,b,c,d,e) if (rf_reconbufferDebug) printf(s, a, b, c, d, e)
d52 1
a52 1
/*****************************************************************************
d55 4
a58 4
 * We can only submit a buffer if (1) we can xor into an existing buffer,
 * which means we don't have to acquire a new one, (2) we can acquire a
 * floating recon buffer, or (3) the caller has indicated that we are allowed
 * to keep the submitted buffer.
d61 9
a69 15
 * In this case, we append the current disk ID to the wait list on the
 * indicated RU, so that it will be re-enabled when we acquire a buffer for
 * this RU.
 *
 *****************************************************************************/

/* Just to make the code below more readable. */
#define	BUFWAIT_APPEND(_cb_,_pssPtr_,_row_,_col_)			\
do {									\
	_cb_ = rf_AllocCallbackDesc();					\
	(_cb_)->row = (_row_);						\
	(_cb_)->col = (_col_);						\
	(_cb_)->next = (_pssPtr_)->bufWaitList;				\
	(_pssPtr_)->bufWaitList = (_cb_);				\
} while (0)
d72 1
a72 1
 * rf_nWayXorFuncs[i] is a pointer to a function that will xor "i"
d75 1
a75 1
static RF_VoidFuncPtr rf_nWayXorFuncs[] = {
d88 7
a94 13

int
rf_SubmitReconBuffer(
    RF_ReconBuffer_t	*rbuf,		/* The recon buffer to submit. */
    int			 keep_it,	/*
					 * Whether we can keep this buffer or
					 * we have to return it.
					 */
    int			 use_committed	/*
					 * Whether to use a committed or an
					 * available recon buffer.
					 */
)
d97 1
a97 1
	int rc;
d104 7
a110 12
int
rf_SubmitReconBufferBasic(
    RF_ReconBuffer_t	*rbuf,		/* The recon buffer to submit. */
    int			 keep_it,	/*
					 * Whether we can keep this buffer
					 * or we have to return it.
					 */
    int			 use_committed	/*
					 * Whether to use a committed or
					 * an available recon buffer.
					 */
)
d116 3
a118 4
	/* Temporary rbuf pointers. */
	RF_ReconBuffer_t *targetRbuf, *t = NULL;
	/* Temporary data buffer pointer. */
	caddr_t ta;
d120 1
a120 1
	int retcode = 0, created = 0;
d124 1
a124 1
	/* Makes no sense to have a submission from the failed disk. */
d128 2
a129 4
	Dprintf5("RECON: submission by row %d col %d for psid %ld ru %d"
	    " (failed offset %ld).\n", rbuf->row, rbuf->col,
	    (long) rbuf->parityStripeID, rbuf->which_ru,
	    (long) rbuf->failedDiskSectorOffset);
d135 7
a141 11
	pssPtr = rf_LookupRUStatus(raidPtr, reconCtrlPtr->pssTable,
	    rbuf->parityStripeID, rbuf->which_ru, RF_PSS_NONE, &created);
	RF_ASSERT(pssPtr);	/*
				 * If it didn't exist, we wouldn't have gotten
				 * an rbuf for it.
				 */

	/*
	 * Check to see if enough buffers have accumulated to do an XOR. If
	 * so, there's no need to acquire a floating rbuf. Before we can do
	 * any XORing, we must have acquired a destination buffer. If we
d145 1
a145 2
	 * floating rbuf.
	 */
d149 3
a151 7
	    ((pssPtr->xorBufCount == rf_numBufsToAccumulate - 1) ||
	     (targetRbuf->count + pssPtr->xorBufCount + 1 ==
	      layoutPtr->numDataCol))) {
		/* Install this buffer. */
		pssPtr->rbufsForXor[pssPtr->xorBufCount++] = rbuf;
		Dprintf3("RECON: row %d col %d invoking a %d-way XOR.\n",
		    rbuf->row, rbuf->col, pssPtr->xorBufCount);
d158 6
a163 12
			raidPtr->recon_tracerecs[rbuf->col].xor_us =
			    RF_ETIMER_VAL_US(timer);
			RF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col]
			    .recon_timer);
			RF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col]
			    .recon_timer);
			raidPtr->recon_tracerecs[rbuf->col]
			    .specific.recon.recon_return_to_submit_us +=
			     RF_ETIMER_VAL_US(raidPtr
			      ->recon_tracerecs[rbuf->col].recon_timer);
			RF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col]
			   .recon_timer);
d165 1
a165 2
			rf_LogTraceRec(raidPtr,
			    &raidPtr->recon_tracerecs[rbuf->col]);
d167 1
a167 2
		rf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr,
		    layoutPtr->numDataCol);
d169 2
a170 4
		/*
		 * If use_committed is on, we _must_ consume a buffer off the
		 * committed list.
		 */
d178 1
a178 2
			RF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row,
			    rbuf->parityStripeID);
d185 1
a185 1
	/* Set the value of "t", which we'll use as the rbuf from here on. */
d189 2
a190 3
		if (use_committed) {
			/* If a buffer has been committed to us, use it. */

d203 2
a204 4
	/*
	 * If we weren't able to acquire a buffer, append to the end of the
	 * buf list in the recon ctrl struct.
	 */
d207 1
a207 2
		Dprintf2("RECON: row %d col %d failed to acquire floating"
		    " rbuf.\n", rbuf->row, rbuf->col);
d210 2
a211 3
		if ((raidPtr->procsInBufWait == raidPtr->numCol - 1) &&
		    (raidPtr->numFullReconBuffers == 0)) {
			printf("Buffer wait deadlock detected. Exiting.\n");
d216 2
a217 2
		/* Append to buf wait list in recon ctrl structure. */
		cb = rf_AllocCallbackDesc();
d225 3
a227 7
		else {
			/*
			 * Might want to maintain head/tail pointers
			 * here rather than search for end of list.
			 */
			for (p = reconCtrlPtr->bufferWaitList; p->next;
			     p = p->next);
d233 1
a233 1
	Dprintf2("RECON: row %d col %d acquired rbuf.\n", rbuf->row, rbuf->col);
d236 2
a237 3
	raidPtr->recon_tracerecs[rbuf->col]
	    .specific.recon.recon_return_to_submit_us +=
	     RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
d242 1
a242 1
	/* Initialize the buffer. */
d255 1
a255 1
		rbuf->buffer = ta;	/* Swap buffers. */
d257 3
a259 5
	/*
	 * The first installation always gets installed as the destination
	 * buffer. Subsequent installations get stacked up to allow for
	 * multi-way XOR.
	 */
d264 1
a264 2
		/* Install this buffer. */
		pssPtr->rbufsForXor[pssPtr->xorBufCount++] = t;
d266 2
a267 3
	/* The buffer is full if G=2. */
	rf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr,
	    layoutPtr->numDataCol);
d275 5
a279 8
int
rf_MultiWayReconXor(
    RF_Raid_t			 *raidPtr,
    RF_ReconParityStripeStatus_t *pssPtr	/*
						 * The pss descriptor for this
						 * parity stripe.
						 */
)
d281 2
a282 3
	int i, numBufs = pssPtr->xorBufCount;
	int numBytes = rf_RaidAddressToByte(raidPtr,
	    raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU);
d288 3
a290 4
#ifdef	_KERNEL
#if	!defined(__NetBSD__) && !defined(__OpenBSD__)
	/* Yield the processor before doing a big XOR. */
	thread_block();
d292 1
a292 1
#endif	/* _KERNEL */
d294 5
a298 6
	 * XXX
	 *
	 * What if more than 9 bufs ?
	 */
	rf_nWayXorFuncs[numBufs] (pssPtr->rbufsForXor, targetRbuf,
	    numBytes / sizeof(long));
d300 2
a301 4
	/*
	 * Release all the reconstruction buffers except the last one, which
	 * belongs to the disk whose submission caused this XOR to take place.
	 */
d304 1
a304 2
			rf_ReleaseFloatingReconBuffer(raidPtr, rbufs[i]->row,
			    rbufs[i]);
d315 1
a315 4


/*
 * Removes one full buffer from one of the full-buffer lists and returns it.
d320 2
a321 1
rf_GetFullReconBuffer(RF_ReconCtrl_t *reconCtrlPtr)
d343 2
a344 3
/*
 * If the reconstruction buffer is full, move it to the full list, which
 * is maintained sorted by failed disk sector offset.
d348 6
a353 3
int
rf_CheckForFullRbuf(RF_Raid_t *raidPtr, RF_ReconCtrl_t *reconCtrl,
    RF_ReconParityStripeStatus_t *pssPtr, int numDataCol)
d359 1
a359 1
		Dprintf2("RECON: rbuf for psid %ld ru %d has filled.\n",
d361 3
a363 6
		if (!reconCtrl->fullBufferList ||
		    (rbuf->failedDiskSectorOffset <
		     reconCtrl->fullBufferList->failedDiskSectorOffset)) {
			Dprintf2("RECON: rbuf for psid %ld ru %d is head of"
			    " list.\n", (long) rbuf->parityStripeID,
			    rbuf->which_ru);
d367 1
a367 4
			for (pt = reconCtrl->fullBufferList, p = pt->next;
			     p && p->failedDiskSectorOffset <
			      rbuf->failedDiskSectorOffset;
			     pt = p, p = p->next);
d370 1
a370 1
			Dprintf2("RECON: rbuf for psid %ld ru %d is in list.\n",
d374 1
a374 2
		pssPtr->writeRbuf = pssPtr->rbuf;	/*
							 * DEBUG ONLY: We like
d377 1
a377 2
							 * awaiting write.
							 */
d382 1
a382 2
		rf_CauseReconEvent(raidPtr, rbuf->row, rbuf->col, NULL,
		    RF_REVENT_BUFREADY);
d388 2
a389 3
/*
 * Release a floating recon buffer for someone else to use.
 * Assumes the rb_mutex is LOCKED at entry.
d391 5
a395 3
void
rf_ReleaseFloatingReconBuffer(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_ReconBuffer_t *rbuf)
d400 1
a400 1
	Dprintf2("RECON: releasing rbuf for psid %ld ru %d.\n",
d403 2
a404 4
	/*
	 * If anyone is waiting on buffers, wake one of them up. They will
	 * subsequently wake up anyone else waiting on their RU.
	 */
d410 2
a411 3
		/* arg==1 => We've committed a buffer. */
		rf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1,
		    RF_REVENT_BUFCLEAR);
d419 2
a420 5


/*
 * Release any disk that is waiting on a buffer for the indicated RU.
 * Assumes the rb_mutex is LOCKED at entry.
d422 4
a425 5
void
rf_ReleaseBufferWaiters(
    RF_Raid_t			 *raidPtr,
    RF_ReconParityStripeStatus_t *pssPtr
)
d429 1
a429 1
	Dprintf2("RECON: releasing buf waiters for psid %ld ru %d.\n",
d435 2
a436 3
		/* arg==0 => We haven't committed a buffer. */
		rf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 0,
		    RF_REVENT_BUFCLEAR);
d442 2
a443 5


/*
 * When reconstruction is forced on an RU, there may be some disks waiting to
 * acquire a buffer for that RU. Since we allocate a new buffer as part of
d445 1
a445 1
 * buffers, so we wakeup any waiter that we find in the bufferWaitList.
d447 1
a447 1
 * Assumes the rb_mutex is LOCKED at entry.
d449 4
a452 2
void
rf_ReleaseBufferWaiter(RF_ReconCtrl_t *rcPtr, RF_ReconBuffer_t *rbuf)
d456 3
a458 6
	for (cbt = NULL, cb = rcPtr->bufferWaitList; cb;
	     cbt = cb, cb = cb->next) {
		if ((cb->callbackArg.v == rbuf->parityStripeID) &&
		    (cb->callbackArg2.v == rbuf->which_ru)) {
			Dprintf2("RECON: Dropping row %d col %d from buffer"
			    " wait list.\n", cb->row, cb->col);
d463 2
a464 4

			/* arg==0 => No committed buffer. */
			rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr,
			    cb->row, cb->col, (void *) 0, RF_REVENT_BUFREADY);
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconbuffer.c,v 1.1 1999/01/11 14:29:45 niklas Exp $	*/
/*	$NetBSD: rf_reconbuffer.c,v 1.3 1999/02/05 00:06:16 oster Exp $	*/
d301 1
a301 2
	 * belongs to the the disk who's submission caused this XOR to take
	 * place */
@


1.2.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconbuffer.c,v 1.3 2000/08/08 16:07:44 peter Exp $	*/
/*	$NetBSD: rf_reconbuffer.c,v 1.4 2000/03/13 23:52:36 soren Exp $	*/
d301 2
a302 1
	 * belongs to the disk whose submission caused this XOR to take place */
@


1.2.6.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************
d32 1
a32 1
 * rf_reconbuffer.c -- Reconstruction buffer manager.
d34 1
a34 1
 *****************************************************/
d46 5
a50 5
#define	Dprintf1(s,a) if (rf_reconbufferDebug) printf(s, a)
#define	Dprintf2(s,a,b) if (rf_reconbufferDebug) printf(s, a, b)
#define	Dprintf3(s,a,b,c) if (rf_reconbufferDebug) printf(s, a, b, c)
#define	Dprintf4(s,a,b,c,d) if (rf_reconbufferDebug) printf(s, a, b, c, d)
#define	Dprintf5(s,a,b,c,d,e) if (rf_reconbufferDebug) printf(s, a, b, c, d, e)
d52 1
a52 1
/*****************************************************************************
d55 4
a58 4
 * We can only submit a buffer if (1) we can xor into an existing buffer,
 * which means we don't have to acquire a new one, (2) we can acquire a
 * floating recon buffer, or (3) the caller has indicated that we are allowed
 * to keep the submitted buffer.
d61 9
a69 15
 * In this case, we append the current disk ID to the wait list on the
 * indicated RU, so that it will be re-enabled when we acquire a buffer for
 * this RU.
 *
 *****************************************************************************/

/* Just to make the code below more readable. */
#define	BUFWAIT_APPEND(_cb_,_pssPtr_,_row_,_col_)			\
do {									\
	_cb_ = rf_AllocCallbackDesc();					\
	(_cb_)->row = (_row_);						\
	(_cb_)->col = (_col_);						\
	(_cb_)->next = (_pssPtr_)->bufWaitList;				\
	(_pssPtr_)->bufWaitList = (_cb_);				\
} while (0)
d72 1
a72 1
 * rf_nWayXorFuncs[i] is a pointer to a function that will xor "i"
d75 1
a75 1
static RF_VoidFuncPtr rf_nWayXorFuncs[] = {
d88 7
a94 13

int
rf_SubmitReconBuffer(
    RF_ReconBuffer_t	*rbuf,		/* The recon buffer to submit. */
    int			 keep_it,	/*
					 * Whether we can keep this buffer or
					 * we have to return it.
					 */
    int			 use_committed	/*
					 * Whether to use a committed or an
					 * available recon buffer.
					 */
)
d97 1
a97 1
	int rc;
d104 7
a110 12
int
rf_SubmitReconBufferBasic(
    RF_ReconBuffer_t	*rbuf,		/* The recon buffer to submit. */
    int			 keep_it,	/*
					 * Whether we can keep this buffer
					 * or we have to return it.
					 */
    int			 use_committed	/*
					 * Whether to use a committed or
					 * an available recon buffer.
					 */
)
d116 3
a118 4
	/* Temporary rbuf pointers. */
	RF_ReconBuffer_t *targetRbuf, *t = NULL;
	/* Temporary data buffer pointer. */
	caddr_t ta;
d120 1
a120 1
	int retcode = 0, created = 0;
d124 1
a124 1
	/* Makes no sense to have a submission from the failed disk. */
d128 2
a129 4
	Dprintf5("RECON: submission by row %d col %d for psid %ld ru %d"
	    " (failed offset %ld).\n", rbuf->row, rbuf->col,
	    (long) rbuf->parityStripeID, rbuf->which_ru,
	    (long) rbuf->failedDiskSectorOffset);
d135 7
a141 11
	pssPtr = rf_LookupRUStatus(raidPtr, reconCtrlPtr->pssTable,
	    rbuf->parityStripeID, rbuf->which_ru, RF_PSS_NONE, &created);
	RF_ASSERT(pssPtr);	/*
				 * If it didn't exist, we wouldn't have gotten
				 * an rbuf for it.
				 */

	/*
	 * Check to see if enough buffers have accumulated to do an XOR. If
	 * so, there's no need to acquire a floating rbuf. Before we can do
	 * any XORing, we must have acquired a destination buffer. If we
d145 1
a145 2
	 * floating rbuf.
	 */
d149 3
a151 7
	    ((pssPtr->xorBufCount == rf_numBufsToAccumulate - 1) ||
	     (targetRbuf->count + pssPtr->xorBufCount + 1 ==
	      layoutPtr->numDataCol))) {
		/* Install this buffer. */
		pssPtr->rbufsForXor[pssPtr->xorBufCount++] = rbuf;
		Dprintf3("RECON: row %d col %d invoking a %d-way XOR.\n",
		    rbuf->row, rbuf->col, pssPtr->xorBufCount);
d158 6
a163 12
			raidPtr->recon_tracerecs[rbuf->col].xor_us =
			    RF_ETIMER_VAL_US(timer);
			RF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col]
			    .recon_timer);
			RF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col]
			    .recon_timer);
			raidPtr->recon_tracerecs[rbuf->col]
			    .specific.recon.recon_return_to_submit_us +=
			     RF_ETIMER_VAL_US(raidPtr
			      ->recon_tracerecs[rbuf->col].recon_timer);
			RF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col]
			   .recon_timer);
d165 1
a165 2
			rf_LogTraceRec(raidPtr,
			    &raidPtr->recon_tracerecs[rbuf->col]);
d167 1
a167 2
		rf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr,
		    layoutPtr->numDataCol);
d169 2
a170 4
		/*
		 * If use_committed is on, we _must_ consume a buffer off the
		 * committed list.
		 */
d178 1
a178 2
			RF_UNLOCK_PSS_MUTEX(raidPtr, rbuf->row,
			    rbuf->parityStripeID);
d185 1
a185 1
	/* Set the value of "t", which we'll use as the rbuf from here on. */
d189 2
a190 3
		if (use_committed) {
			/* If a buffer has been committed to us, use it. */

d203 2
a204 4
	/*
	 * If we weren't able to acquire a buffer, append to the end of the
	 * buf list in the recon ctrl struct.
	 */
d207 1
a207 2
		Dprintf2("RECON: row %d col %d failed to acquire floating"
		    " rbuf.\n", rbuf->row, rbuf->col);
d210 2
a211 3
		if ((raidPtr->procsInBufWait == raidPtr->numCol - 1) &&
		    (raidPtr->numFullReconBuffers == 0)) {
			printf("Buffer wait deadlock detected. Exiting.\n");
d216 2
a217 2
		/* Append to buf wait list in recon ctrl structure. */
		cb = rf_AllocCallbackDesc();
d225 3
a227 7
		else {
			/*
			 * Might want to maintain head/tail pointers
			 * here rather than search for end of list.
			 */
			for (p = reconCtrlPtr->bufferWaitList; p->next;
			     p = p->next);
d233 1
a233 1
	Dprintf2("RECON: row %d col %d acquired rbuf.\n", rbuf->row, rbuf->col);
d236 2
a237 3
	raidPtr->recon_tracerecs[rbuf->col]
	    .specific.recon.recon_return_to_submit_us +=
	     RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
d242 1
a242 1
	/* Initialize the buffer. */
d255 1
a255 1
		rbuf->buffer = ta;	/* Swap buffers. */
d257 3
a259 5
	/*
	 * The first installation always gets installed as the destination
	 * buffer. Subsequent installations get stacked up to allow for
	 * multi-way XOR.
	 */
d264 1
a264 2
		/* Install this buffer. */
		pssPtr->rbufsForXor[pssPtr->xorBufCount++] = t;
d266 2
a267 3
	/* The buffer is full if G=2. */
	rf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr,
	    layoutPtr->numDataCol);
d275 5
a279 8
int
rf_MultiWayReconXor(
    RF_Raid_t			 *raidPtr,
    RF_ReconParityStripeStatus_t *pssPtr	/*
						 * The pss descriptor for this
						 * parity stripe.
						 */
)
d281 2
a282 3
	int i, numBufs = pssPtr->xorBufCount;
	int numBytes = rf_RaidAddressToByte(raidPtr,
	    raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU);
d288 3
a290 4
#ifdef	_KERNEL
#if	!defined(__NetBSD__) && !defined(__OpenBSD__)
	/* Yield the processor before doing a big XOR. */
	thread_block();
d292 1
a292 1
#endif	/* _KERNEL */
d294 5
a298 6
	 * XXX
	 *
	 * What if more than 9 bufs ?
	 */
	rf_nWayXorFuncs[numBufs] (pssPtr->rbufsForXor, targetRbuf,
	    numBytes / sizeof(long));
d300 2
a301 4
	/*
	 * Release all the reconstruction buffers except the last one, which
	 * belongs to the disk whose submission caused this XOR to take place.
	 */
d304 1
a304 2
			rf_ReleaseFloatingReconBuffer(raidPtr, rbufs[i]->row,
			    rbufs[i]);
d315 1
a315 4


/*
 * Removes one full buffer from one of the full-buffer lists and returns it.
d320 2
a321 1
rf_GetFullReconBuffer(RF_ReconCtrl_t *reconCtrlPtr)
d343 2
a344 3
/*
 * If the reconstruction buffer is full, move it to the full list, which
 * is maintained sorted by failed disk sector offset.
d348 6
a353 3
int
rf_CheckForFullRbuf(RF_Raid_t *raidPtr, RF_ReconCtrl_t *reconCtrl,
    RF_ReconParityStripeStatus_t *pssPtr, int numDataCol)
d359 1
a359 1
		Dprintf2("RECON: rbuf for psid %ld ru %d has filled.\n",
d361 3
a363 6
		if (!reconCtrl->fullBufferList ||
		    (rbuf->failedDiskSectorOffset <
		     reconCtrl->fullBufferList->failedDiskSectorOffset)) {
			Dprintf2("RECON: rbuf for psid %ld ru %d is head of"
			    " list.\n", (long) rbuf->parityStripeID,
			    rbuf->which_ru);
d367 1
a367 4
			for (pt = reconCtrl->fullBufferList, p = pt->next;
			     p && p->failedDiskSectorOffset <
			      rbuf->failedDiskSectorOffset;
			     pt = p, p = p->next);
d370 1
a370 1
			Dprintf2("RECON: rbuf for psid %ld ru %d is in list.\n",
d374 1
a374 2
		pssPtr->writeRbuf = pssPtr->rbuf;	/*
							 * DEBUG ONLY: We like
d377 1
a377 2
							 * awaiting write.
							 */
d382 1
a382 2
		rf_CauseReconEvent(raidPtr, rbuf->row, rbuf->col, NULL,
		    RF_REVENT_BUFREADY);
d388 2
a389 3
/*
 * Release a floating recon buffer for someone else to use.
 * Assumes the rb_mutex is LOCKED at entry.
d391 5
a395 3
void
rf_ReleaseFloatingReconBuffer(RF_Raid_t *raidPtr, RF_RowCol_t row,
    RF_ReconBuffer_t *rbuf)
d400 1
a400 1
	Dprintf2("RECON: releasing rbuf for psid %ld ru %d.\n",
d403 2
a404 4
	/*
	 * If anyone is waiting on buffers, wake one of them up. They will
	 * subsequently wake up anyone else waiting on their RU.
	 */
d410 2
a411 3
		/* arg==1 => We've committed a buffer. */
		rf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1,
		    RF_REVENT_BUFCLEAR);
d419 2
a420 5


/*
 * Release any disk that is waiting on a buffer for the indicated RU.
 * Assumes the rb_mutex is LOCKED at entry.
d422 4
a425 5
void
rf_ReleaseBufferWaiters(
    RF_Raid_t			 *raidPtr,
    RF_ReconParityStripeStatus_t *pssPtr
)
d429 1
a429 1
	Dprintf2("RECON: releasing buf waiters for psid %ld ru %d.\n",
d435 2
a436 3
		/* arg==0 => We haven't committed a buffer. */
		rf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 0,
		    RF_REVENT_BUFCLEAR);
d442 2
a443 5


/*
 * When reconstruction is forced on an RU, there may be some disks waiting to
 * acquire a buffer for that RU. Since we allocate a new buffer as part of
d445 1
a445 1
 * buffers, so we wakeup any waiter that we find in the bufferWaitList.
d447 1
a447 1
 * Assumes the rb_mutex is LOCKED at entry.
d449 4
a452 2
void
rf_ReleaseBufferWaiter(RF_ReconCtrl_t *rcPtr, RF_ReconBuffer_t *rbuf)
d456 3
a458 6
	for (cbt = NULL, cb = rcPtr->bufferWaitList; cb;
	     cbt = cb, cb = cb->next) {
		if ((cb->callbackArg.v == rbuf->parityStripeID) &&
		    (cb->callbackArg2.v == rbuf->which_ru)) {
			Dprintf2("RECON: Dropping row %d col %d from buffer"
			    " wait list.\n", cb->row, cb->col);
d463 2
a464 4

			/* arg==0 => No committed buffer. */
			rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr,
			    cb->row, cb->col, (void *) 0, RF_REVENT_BUFREADY);
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconbuffer.c,v 1.1 1998/11/13 04:20:33 oster Exp $	*/
/*	$NetBSD: rf_reconbuffer.c,v 1.1 1998/11/13 04:20:33 oster Exp $	*/
a35 79
/* :  
 * Log: rf_reconbuffer.c,v 
 * Revision 1.33  1996/07/27 23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.32  1996/07/17  21:00:58  jimz
 * clean up timer interface, tracing
 *
 * Revision 1.31  1996/07/13  00:00:59  jimz
 * sanitized generalized reconstruction architecture
 * cleaned up head sep, rbuf problems
 *
 * Revision 1.30  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.29  1996/06/06  01:23:58  jimz
 * don't free reconCtrlPtr until after all fields have been used out of it
 *
 * Revision 1.28  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.27  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.26  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.25  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.24  1996/05/30  12:59:18  jimz
 * make etimer happier, more portable
 *
 * Revision 1.23  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.22  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.21  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.20  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.19  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.18  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.17  1995/12/06  15:03:24  root
 * added copyright info
 *
 */

#ifdef _KERNEL
#define KERNEL
#endif

a45 1
#ifdef KERNEL
a50 21
#else /* KERNEL */
#define Dprintf1(s,a)         if (rf_reconbufferDebug) rf_debug_printf(s,(void *)((unsigned long)a),NULL,NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf2(s,a,b)       if (rf_reconbufferDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),NULL,NULL,NULL,NULL,NULL,NULL)
#define Dprintf3(s,a,b,c)     if (rf_reconbufferDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),NULL,NULL,NULL,NULL,NULL)
#define Dprintf4(s,a,b,c,d)   if (rf_reconbufferDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),NULL,NULL,NULL,NULL)
#define Dprintf5(s,a,b,c,d,e) if (rf_reconbufferDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),NULL,NULL,NULL)
#endif /* KERNEL */

#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)

/* XXX XXX XXX This is wrong, for a number of reasons:
  a) thread_block doesn't exist with UVM
  b) The prototype begin used here is wrong for the regular VM 
  (regular VM expects a (char *) as an argument.  I don't put 
  that in here as this code uses thread_block with no arguments.. :-/ 

*/
#if 0
void thread_block(void); 
#endif
#endif
d76 10
a85 10
  NULL, 
  (RF_VoidFuncPtr)rf_nWayXor1, 
  (RF_VoidFuncPtr)rf_nWayXor2, 
  (RF_VoidFuncPtr)rf_nWayXor3, 
  (RF_VoidFuncPtr)rf_nWayXor4,
  (RF_VoidFuncPtr)rf_nWayXor5, 
  (RF_VoidFuncPtr)rf_nWayXor6, 
  (RF_VoidFuncPtr)rf_nWayXor7, 
  (RF_VoidFuncPtr)rf_nWayXor8, 
  (RF_VoidFuncPtr)rf_nWayXor9
d87 8
a94 5
    
int rf_SubmitReconBuffer(rbuf, keep_it, use_committed)
  RF_ReconBuffer_t  *rbuf;          /* the recon buffer to submit */
  int                keep_it;       /* whether we can keep this buffer or we have to return it */
  int                use_committed; /* whether to use a committed or an available recon buffer */
d96 2
a97 2
  RF_LayoutSW_t *lp;
  int rc;
d99 3
a101 3
  lp = rbuf->raidPtr->Layout.map;
  rc = lp->SubmitReconBuffer(rbuf, keep_it, use_committed);
  return(rc);
d104 7
a110 4
int rf_SubmitReconBufferBasic(rbuf, keep_it, use_committed)
  RF_ReconBuffer_t  *rbuf;          /* the recon buffer to submit */
  int                keep_it;       /* whether we can keep this buffer or we have to return it */
  int                use_committed; /* whether to use a committed or an available recon buffer */
d112 161
a272 147
  RF_Raid_t *raidPtr                = rbuf->raidPtr;
  RF_RaidLayout_t *layoutPtr        = &raidPtr->Layout;
  RF_ReconCtrl_t *reconCtrlPtr      = raidPtr->reconControl[rbuf->row];
  RF_ReconParityStripeStatus_t *pssPtr;
  RF_ReconBuffer_t *targetRbuf, *t = NULL;        /* temporary rbuf pointers */
  caddr_t ta;                                     /* temporary data buffer pointer */
  RF_CallbackDesc_t *cb, *p;
  int retcode = 0, created = 0;
  
  RF_Etimer_t timer;

  /* makes no sense to have a submission from the failed disk */
  RF_ASSERT(rbuf);
  RF_ASSERT(rbuf->col != reconCtrlPtr->fcol);
  
  Dprintf5("RECON: submission by row %d col %d for psid %ld ru %d (failed offset %ld)\n",
			       rbuf->row, rbuf->col, (long)rbuf->parityStripeID, rbuf->which_ru, (long)rbuf->failedDiskSectorOffset);

  RF_LOCK_PSS_MUTEX(raidPtr,rbuf->row,rbuf->parityStripeID);

  RF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);

  pssPtr = rf_LookupRUStatus(raidPtr, reconCtrlPtr->pssTable, rbuf->parityStripeID, rbuf->which_ru, RF_PSS_NONE, &created);
  RF_ASSERT(pssPtr);  /* if it didn't exist, we wouldn't have gotten an rbuf for it */

  /* check to see if enough buffers have accumulated to do an XOR.  If so, there's no need to
   * acquire a floating rbuf.  Before we can do any XORing, we must have acquired a destination
   * buffer.  If we have, then we can go ahead and do the XOR if (1) including this buffer, enough
   * bufs have accumulated, or (2) this is the last submission for this stripe.
   * Otherwise, we have to go acquire a floating rbuf.
   */

  targetRbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;
  if (  (targetRbuf != NULL) && 
       ((pssPtr->xorBufCount == rf_numBufsToAccumulate-1) || (targetRbuf->count + pssPtr->xorBufCount + 1 == layoutPtr->numDataCol)) ) {
    pssPtr->rbufsForXor[ pssPtr->xorBufCount++ ] = rbuf;          /* install this buffer */
    Dprintf3("RECON: row %d col %d invoking a %d-way XOR\n",rbuf->row, rbuf->col,pssPtr->xorBufCount);
    RF_ETIMER_START(timer);
    rf_MultiWayReconXor(raidPtr, pssPtr);
    RF_ETIMER_STOP(timer); RF_ETIMER_EVAL(timer);
    raidPtr->accumXorTimeUs += RF_ETIMER_VAL_US(timer);
    if (!keep_it) {
      raidPtr->recon_tracerecs[rbuf->col].xor_us = RF_ETIMER_VAL_US(timer);
      RF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
      RF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
      raidPtr->recon_tracerecs[rbuf->col].specific.recon.recon_return_to_submit_us +=
        RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
      RF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
  
      rf_LogTraceRec(raidPtr, &raidPtr->recon_tracerecs[rbuf->col]);
    }
    rf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr, layoutPtr->numDataCol);

    /* if use_committed is on, we _must_ consume a buffer off the committed list. */
    if (use_committed) {
      t = reconCtrlPtr->committedRbufs;
      RF_ASSERT(t);
      reconCtrlPtr->committedRbufs = t->next;
      rf_ReleaseFloatingReconBuffer(raidPtr, rbuf->row, t);
    }
    if (keep_it) {
      RF_UNLOCK_PSS_MUTEX( raidPtr,rbuf->row,rbuf->parityStripeID);
      RF_UNLOCK_MUTEX( reconCtrlPtr->rb_mutex );
      rf_FreeReconBuffer(rbuf);
      return(retcode);
    }
    goto out;
  }

  /* set the value of "t", which we'll use as the rbuf from here on */
  if (keep_it) {
    t = rbuf;
  }
  else {
    if (use_committed) {      /* if a buffer has been committed to us, use it */
      t = reconCtrlPtr->committedRbufs;
      RF_ASSERT(t);
      reconCtrlPtr->committedRbufs = t->next;
      t->next = NULL;
    } else if (reconCtrlPtr->floatingRbufs) {
      t = reconCtrlPtr->floatingRbufs;
      reconCtrlPtr->floatingRbufs = t->next;
      t->next = NULL;
    }
  }

  /* If we weren't able to acquire a buffer, 
   * append to the end of the buf list in the recon ctrl struct.
   */
  if (!t) {
    RF_ASSERT(!keep_it && !use_committed);
    Dprintf2("RECON: row %d col %d failed to acquire floating rbuf\n",rbuf->row, rbuf->col);

    raidPtr->procsInBufWait++;
    if ( (raidPtr->procsInBufWait == raidPtr->numCol -1) && (raidPtr->numFullReconBuffers == 0)) {
      printf("Buffer wait deadlock detected.  Exiting.\n");
      rf_PrintPSStatusTable(raidPtr, rbuf->row);
      RF_PANIC();
    }
    pssPtr->flags |= RF_PSS_BUFFERWAIT;
    cb = rf_AllocCallbackDesc();                      /* append to buf wait list in recon ctrl structure */
    cb->row = rbuf->row; cb->col = rbuf->col;
    cb->callbackArg.v  = rbuf->parityStripeID;
    cb->callbackArg2.v = rbuf->which_ru;
    cb->next = NULL;
    if (!reconCtrlPtr->bufferWaitList) reconCtrlPtr->bufferWaitList = cb;
    else {       /* might want to maintain head/tail pointers here rather than search for end of list */
      for (p = reconCtrlPtr->bufferWaitList; p->next; p=p->next);
      p->next = cb;
    }
    retcode = 1;
    goto out;
  }
  Dprintf2("RECON: row %d col %d acquired rbuf\n",rbuf->row, rbuf->col);
  RF_ETIMER_STOP(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
  RF_ETIMER_EVAL(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
  raidPtr->recon_tracerecs[rbuf->col].specific.recon.recon_return_to_submit_us +=
    RF_ETIMER_VAL_US(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
  RF_ETIMER_START(raidPtr->recon_tracerecs[rbuf->col].recon_timer);
  
  rf_LogTraceRec(raidPtr, &raidPtr->recon_tracerecs[rbuf->col]);

  /* initialize the buffer */
  if (t!=rbuf) {
    t->row = rbuf->row; t->col = reconCtrlPtr->fcol;
    t->parityStripeID = rbuf->parityStripeID;
    t->which_ru = rbuf->which_ru;
    t->failedDiskSectorOffset = rbuf->failedDiskSectorOffset;
    t->spRow=rbuf->spRow;
    t->spCol=rbuf->spCol;
    t->spOffset=rbuf->spOffset;
    
    ta = t->buffer; t->buffer = rbuf->buffer; rbuf->buffer = ta;      /* swap buffers */
  }

  /* the first installation always gets installed as the destination buffer.
   * subsequent installations get stacked up to allow for multi-way XOR
   */
  if (!pssPtr->rbuf) {pssPtr->rbuf = t; t->count = 1;}
  else pssPtr->rbufsForXor[ pssPtr->xorBufCount++ ] = t;          /* install this buffer */

  rf_CheckForFullRbuf(raidPtr, reconCtrlPtr, pssPtr, layoutPtr->numDataCol);      /* the buffer is full if G=2 */

out:  
  RF_UNLOCK_PSS_MUTEX( raidPtr,rbuf->row,rbuf->parityStripeID);
  RF_UNLOCK_MUTEX( reconCtrlPtr->rb_mutex );
  return(retcode);
d275 5
a279 3
int rf_MultiWayReconXor(raidPtr, pssPtr)
  RF_Raid_t                     *raidPtr;
  RF_ReconParityStripeStatus_t  *pssPtr;   /* the pss descriptor for this parity stripe */
d281 8
a288 8
  int i, numBufs = pssPtr->xorBufCount;
  int numBytes = rf_RaidAddressToByte(raidPtr, raidPtr->Layout.sectorsPerStripeUnit * raidPtr->Layout.SUsPerRU);
  RF_ReconBuffer_t **rbufs = (RF_ReconBuffer_t **) pssPtr->rbufsForXor;
  RF_ReconBuffer_t *targetRbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;
  
  RF_ASSERT(pssPtr->rbuf != NULL);
  RF_ASSERT(numBufs > 0 && numBufs < RF_PS_MAX_BUFS);
#ifdef KERNEL
d290 1
a290 1
  thread_block(); /* yield the processor before doing a big XOR */
d292 23
a314 19
#endif /* KERNEL */
  /*
   * XXX
   *
   * What if more than 9 bufs?
   */
  nWayXorFuncs[numBufs](pssPtr->rbufsForXor, targetRbuf, numBytes/sizeof(long));

  /* release all the reconstruction buffers except the last one, which belongs to the
   * the disk who's submission caused this XOR to take place
   */
  for (i=0; i < numBufs-1; i++) {
    if (rbufs[i]->type == RF_RBUF_TYPE_FLOATING) rf_ReleaseFloatingReconBuffer(raidPtr, rbufs[i]->row, rbufs[i]);
    else if (rbufs[i]->type == RF_RBUF_TYPE_FORCED) rf_FreeReconBuffer(rbufs[i]);
    else RF_ASSERT(0);
  }
  targetRbuf->count += pssPtr->xorBufCount;
  pssPtr->xorBufCount = 0;
  return(0);
a315 1

d320 3
a322 2
RF_ReconBuffer_t *rf_GetFullReconBuffer(reconCtrlPtr)
  RF_ReconCtrl_t  *reconCtrlPtr;
d324 1
a324 3
  RF_ReconBuffer_t *p;

  RF_LOCK_MUTEX(reconCtrlPtr->rb_mutex);
d326 1
a326 10
  if ( (p=reconCtrlPtr->priorityList) != NULL) {
    reconCtrlPtr->priorityList = p->next;
    p->next = NULL;
    goto out;
  }
  if ( (p=reconCtrlPtr->fullBufferList) != NULL) {
    reconCtrlPtr->fullBufferList = p->next;
    p->next = NULL;
    goto out;
  }
d328 10
d339 2
a340 2
  RF_UNLOCK_MUTEX(reconCtrlPtr->rb_mutex);
  return(p);
d349 6
a354 5
int rf_CheckForFullRbuf(raidPtr, reconCtrl, pssPtr, numDataCol)
  RF_Raid_t                     *raidPtr;
  RF_ReconCtrl_t                *reconCtrl;
  RF_ReconParityStripeStatus_t  *pssPtr;
  int                            numDataCol;
d356 1
a356 1
  RF_ReconBuffer_t *p, *pt, *rbuf = (RF_ReconBuffer_t *) pssPtr->rbuf;
d358 16
a373 17
  if (rbuf->count == numDataCol) {
    raidPtr->numFullReconBuffers++;
    Dprintf2("RECON: rbuf for psid %ld ru %d has filled\n",
	     (long)rbuf->parityStripeID, rbuf->which_ru);
    if (!reconCtrl->fullBufferList || (rbuf->failedDiskSectorOffset < reconCtrl->fullBufferList->failedDiskSectorOffset)) {
      Dprintf2("RECON: rbuf for psid %ld ru %d is head of list\n", 
	       (long)rbuf->parityStripeID, rbuf->which_ru);
      rbuf->next = reconCtrl->fullBufferList;
      reconCtrl->fullBufferList = rbuf;
    }
    else {
      for (pt = reconCtrl->fullBufferList, p = pt->next; p && p->failedDiskSectorOffset < rbuf->failedDiskSectorOffset; pt=p, p=p->next);
      rbuf->next = p;
      pt->next = rbuf;
      Dprintf2("RECON: rbuf for psid %ld ru %d is in list\n", 
	       (long)rbuf->parityStripeID, rbuf->which_ru);
    }
d375 4
a378 1
    pssPtr->writeRbuf = pssPtr->rbuf;        /* DEBUG ONLY:  we like to be able to find this rbuf while it's awaiting write */
d380 1
a380 1
    rbuf->pssPtr = pssPtr;
d382 4
a385 4
    pssPtr->rbuf = NULL;
    rf_CauseReconEvent(raidPtr, rbuf->row, rbuf->col, NULL, RF_REVENT_BUFREADY);
  }
  return(0);
d392 5
a396 4
void rf_ReleaseFloatingReconBuffer(raidPtr, row, rbuf)
  RF_Raid_t         *raidPtr;
  RF_RowCol_t        row;
  RF_ReconBuffer_t  *rbuf;
d398 5
a402 2
  RF_ReconCtrl_t *rcPtr = raidPtr->reconControl[row];
  RF_CallbackDesc_t *cb;
d404 15
a418 18
  Dprintf2("RECON: releasing rbuf for psid %ld ru %d\n",
	   (long)rbuf->parityStripeID, rbuf->which_ru);
  
  /* if anyone is waiting on buffers, wake one of them up.  They will subsequently wake up anyone
   * else waiting on their RU
   */
  if (rcPtr->bufferWaitList) {
    rbuf->next = rcPtr->committedRbufs;
    rcPtr->committedRbufs = rbuf;
    cb = rcPtr->bufferWaitList;
    rcPtr->bufferWaitList = cb->next;
    rf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 1, RF_REVENT_BUFCLEAR);  /* arg==1 => we've committed a buffer */
    rf_FreeCallbackDesc(cb);
    raidPtr->procsInBufWait--;
  } else {
    rbuf->next = rcPtr->floatingRbufs;
    rcPtr->floatingRbufs = rbuf;
  }
a419 1

d423 4
a426 3
void rf_ReleaseBufferWaiters(raidPtr, pssPtr)
  RF_Raid_t                     *raidPtr;
  RF_ReconParityStripeStatus_t  *pssPtr;
d428 1
a428 1
  RF_CallbackDesc_t *cb1, *cb = pssPtr->bufWaitList;
d430 12
a441 11
  Dprintf2("RECON: releasing buf waiters for psid %ld ru %d\n",
	   (long)pssPtr->parityStripeID, pssPtr->which_ru);
  pssPtr->flags &= ~RF_PSS_BUFFERWAIT;
  while (cb) {
    cb1 = cb->next;
    cb->next = NULL;
    rf_CauseReconEvent(raidPtr, cb->row, cb->col, (void *) 0, RF_REVENT_BUFCLEAR);  /* arg==0 => we haven't committed a buffer */
    rf_FreeCallbackDesc(cb);
    cb = cb1;
  }
  pssPtr->bufWaitList = NULL;
a442 1

d450 4
a453 3
void rf_ReleaseBufferWaiter(rcPtr, rbuf)
  RF_ReconCtrl_t    *rcPtr;
  RF_ReconBuffer_t  *rbuf;
d455 1
a455 1
  RF_CallbackDesc_t *cb, *cbt;
d457 13
a469 10
  for (cbt = NULL, cb = rcPtr->bufferWaitList; cb; cbt = cb, cb=cb->next) {
    if ( (cb->callbackArg.v == rbuf->parityStripeID) && ( cb->callbackArg2.v == rbuf->which_ru)) {
      Dprintf2("RECON: Dropping row %d col %d from buffer wait list\n", cb->row, cb->col);
      if (cbt) cbt->next = cb->next;
      else rcPtr->bufferWaitList = cb->next;
      rf_CauseReconEvent((RF_Raid_t *) rbuf->raidPtr, cb->row, cb->col, (void *) 0, RF_REVENT_BUFREADY);  /* arg==0 => no committed buffer */
      rf_FreeCallbackDesc(cb);
      return;
    }
  }
@

