head	1.8;
access;
symbols
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.30
	OPENBSD_5_0:1.7.0.28
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.26
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.24
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.20
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.22
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.18
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.16
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.14
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.12
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.10
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.8
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.12
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.10
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.8
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.7;

1.7
date	2004.09.20.17.51.07;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.08.16.07.39;	author peter;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2000.01.07.14.50.20;	author peter;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.10;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.14.22.26.10;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.5.8.1
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_dagfuncs.c,v 1.7 2004/09/20 17:51:07 miod Exp $	*/
/*	$NetBSD: rf_dagfuncs.c,v 1.6 2000/03/30 12:45:40 augustss Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland, William V. Courtright II
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * dagfuncs.c -- DAG node execution routines.
 *
 * Rules:
 * 1. Every DAG execution function must eventually cause node->status to
 *    get set to "good" or "bad", and "FinishNode" to be called. In the
 *    case of nodes that complete immediately (xor, NullNodeFunc, etc),
 *    the node execution function can do these two things directly. In
 *    the case of nodes that have to wait for some event (a disk read to
 *    complete, a lock to be released, etc) to occur before they can
 *    complete, this is typically achieved by having whatever module
 *    is doing the operation call GenericWakeupFunc upon completion.
 * 2. DAG execution functions should check the status in the DAG header
 *    and NOP out their operations if the status is not "enable". However,
 *    execution functions that release resources must be sure to release
 *    them even when they NOP out the function that would use them.
 *    Functions that acquire resources should go ahead and acquire them
 *    even when they NOP, so that a downstream release node will not have
 *    to check to find out whether or not the acquire was suppressed.
 */

#include <sys/ioctl.h>
#include <sys/param.h>

#include "rf_archs.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_layout.h"
#include "rf_etimer.h"
#include "rf_acctrace.h"
#include "rf_diskqueue.h"
#include "rf_dagfuncs.h"
#include "rf_general.h"
#include "rf_engine.h"
#include "rf_dagutils.h"

#include "rf_kintf.h"

#if	RF_INCLUDE_PARITYLOGGING > 0
#include "rf_paritylog.h"
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */

int	(*rf_DiskReadFunc) (RF_DagNode_t *);
int	(*rf_DiskWriteFunc) (RF_DagNode_t *);
int	(*rf_DiskReadUndoFunc) (RF_DagNode_t *);
int	(*rf_DiskWriteUndoFunc) (RF_DagNode_t *);
int	(*rf_DiskUnlockFunc) (RF_DagNode_t *);
int	(*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);
int	(*rf_RegularXorUndoFunc) (RF_DagNode_t *);
int	(*rf_SimpleXorUndoFunc) (RF_DagNode_t *);
int	(*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);

/*****************************************************************************
 * Main (only) configuration routine for this module.
 *****************************************************************************/
int
rf_ConfigureDAGFuncs(RF_ShutdownList_t **listp)
{
	RF_ASSERT(((sizeof(long) == 8) && RF_LONGSHIFT == 3) ||
	    ((sizeof(long) == 4) && RF_LONGSHIFT == 2));
	rf_DiskReadFunc = rf_DiskReadFuncForThreads;
	rf_DiskReadUndoFunc = rf_DiskUndoFunc;
	rf_DiskWriteFunc = rf_DiskWriteFuncForThreads;
	rf_DiskWriteUndoFunc = rf_DiskUndoFunc;
	rf_DiskUnlockFunc = rf_DiskUnlockFuncForThreads;
	rf_DiskUnlockUndoFunc = rf_NullNodeUndoFunc;
	rf_RegularXorUndoFunc = rf_NullNodeUndoFunc;
	rf_SimpleXorUndoFunc = rf_NullNodeUndoFunc;
	rf_RecoveryXorUndoFunc = rf_NullNodeUndoFunc;
	return (0);
}


/*****************************************************************************
 * The execution function associated with a terminate node.
 *****************************************************************************/
int
rf_TerminateFunc(RF_DagNode_t *node)
{
	RF_ASSERT(node->dagHdr->numCommits == node->dagHdr->numCommitNodes);
	node->status = rf_good;
	return (rf_FinishNode(node, RF_THREAD_CONTEXT));
}

int
rf_TerminateUndoFunc(RF_DagNode_t *node)
{
	return (0);
}


/*****************************************************************************
 * Execution functions associated with a mirror node.
 *
 * parameters:
 *
 * 0 - Physical disk address of data.
 * 1 - Buffer for holding read data.
 * 2 - Parity stripe ID.
 * 3 - Flags.
 * 4 - Physical disk address of mirror (parity).
 *
 *****************************************************************************/

int
rf_DiskReadMirrorIdleFunc(RF_DagNode_t *node)
{
	/*
	 * Select the mirror copy with the shortest queue and fill in node
	 * parameters with physical disk address.
	 */

	rf_SelectMirrorDiskIdle(node);
	return (rf_DiskReadFunc(node));
}

int
rf_DiskReadMirrorPartitionFunc(RF_DagNode_t *node)
{
	/*
	 * Select the mirror copy with the shortest queue and fill in node
	 * parameters with physical disk address.
	 */

	rf_SelectMirrorDiskPartition(node);
	return (rf_DiskReadFunc(node));
}

int
rf_DiskReadMirrorUndoFunc(RF_DagNode_t *node)
{
	return (0);
}



#if	RF_INCLUDE_PARITYLOGGING > 0
/*****************************************************************************
 * The execution function associated with a parity log update node.
 *****************************************************************************/
int
rf_ParityLogUpdateFunc(RF_DagNode_t *node)
{
	RF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;
	caddr_t buf = (caddr_t) node->params[1].p;
	RF_ParityLogData_t *logData;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;

	if (node->dagHdr->status == rf_enable) {
		RF_ETIMER_START(timer);
		logData = rf_CreateParityLogData(RF_UPDATE, pda, buf,
		    (RF_Raid_t *) (node->dagHdr->raidPtr),
		    node->wakeFunc, (void *) node,
		    node->dagHdr->tracerec, timer);
		if (logData)
			rf_ParityLogAppend(logData, RF_FALSE, NULL, RF_FALSE);
		else {
			RF_ETIMER_STOP(timer);
			RF_ETIMER_EVAL(timer);
			tracerec->plog_us += RF_ETIMER_VAL_US(timer);
			(node->wakeFunc) (node, ENOMEM);
		}
	}
	return (0);
}


/*****************************************************************************
 * The execution function associated with a parity log overwrite node.
 *****************************************************************************/
int
rf_ParityLogOverwriteFunc(RF_DagNode_t *node)
{
	RF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;
	caddr_t buf = (caddr_t) node->params[1].p;
	RF_ParityLogData_t *logData;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;

	if (node->dagHdr->status == rf_enable) {
		RF_ETIMER_START(timer);
		logData = rf_CreateParityLogData(RF_OVERWRITE, pda, buf,
		    (RF_Raid_t *) (node->dagHdr->raidPtr), node->wakeFunc,
		    (void *) node, node->dagHdr->tracerec, timer);
		if (logData)
			rf_ParityLogAppend(logData, RF_FALSE, NULL, RF_FALSE);
		else {
			RF_ETIMER_STOP(timer);
			RF_ETIMER_EVAL(timer);
			tracerec->plog_us += RF_ETIMER_VAL_US(timer);
			(node->wakeFunc) (node, ENOMEM);
		}
	}
	return (0);
}
#else	/* RF_INCLUDE_PARITYLOGGING > 0 */

int
rf_ParityLogUpdateFunc(RF_DagNode_t *node)
{
	return (0);
}

int
rf_ParityLogOverwriteFunc(RF_DagNode_t *node)
{
	return (0);
}
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */

int
rf_ParityLogUpdateUndoFunc(RF_DagNode_t *node)
{
	return (0);
}

int
rf_ParityLogOverwriteUndoFunc(RF_DagNode_t *node)
{
	return (0);
}

/*****************************************************************************
 * The execution function associated with a NOP node.
 *****************************************************************************/
int
rf_NullNodeFunc(RF_DagNode_t *node)
{
	node->status = rf_good;
	return (rf_FinishNode(node, RF_THREAD_CONTEXT));
}

int
rf_NullNodeUndoFunc(RF_DagNode_t *node)
{
	node->status = rf_undone;
	return (rf_FinishNode(node, RF_THREAD_CONTEXT));
}


/*****************************************************************************
 * The execution function associated with a disk-read node.
 *****************************************************************************/
int
rf_DiskReadFuncForThreads(RF_DagNode_t *node)
{
	RF_DiskQueueData_t *req;
	RF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;
	caddr_t buf = (caddr_t) node->params[1].p;
	RF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;
	unsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);
	unsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);
	unsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);
	unsigned which_ru = RF_EXTRACT_RU(node->params[3].v);
	RF_DiskQueueDataFlags_t flags = 0;
	RF_IoType_t iotype = (node->dagHdr->status == rf_enable) ?
	    RF_IO_TYPE_READ : RF_IO_TYPE_NOP;
	RF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;
	void *b_proc = NULL;

	if (node->dagHdr->bp)
		b_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;

	RF_ASSERT(!(lock && unlock));
	flags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;
	flags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;

	req = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,
	    buf, parityStripeID, which_ru,
	    (int (*) (void *, int)) node->wakeFunc,
	    node, NULL, node->dagHdr->tracerec,
	    (void *) (node->dagHdr->raidPtr), flags, b_proc);
	if (!req) {
		(node->wakeFunc) (node, ENOMEM);
	} else {
		node->dagFuncData = (void *) req;
		rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);
	}
	return (0);
}


/*****************************************************************************
 * the execution function associated with a disk-write node
 *****************************************************************************/
int
rf_DiskWriteFuncForThreads(RF_DagNode_t *node)
{
	RF_DiskQueueData_t *req;
	RF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;
	caddr_t buf = (caddr_t) node->params[1].p;
	RF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;
	unsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);
	unsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);
	unsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);
	unsigned which_ru = RF_EXTRACT_RU(node->params[3].v);
	RF_DiskQueueDataFlags_t flags = 0;
	RF_IoType_t iotype = (node->dagHdr->status == rf_enable) ?
	    RF_IO_TYPE_WRITE : RF_IO_TYPE_NOP;
	RF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;
	void *b_proc = NULL;

	if (node->dagHdr->bp)
		b_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;

	/* Normal processing (rollaway or forward recovery) begins here. */
	RF_ASSERT(!(lock && unlock));
	flags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;
	flags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;
	req = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,
	    buf, parityStripeID, which_ru,
	    (int (*) (void *, int)) node->wakeFunc, (void *) node, NULL,
	    node->dagHdr->tracerec, (void *) (node->dagHdr->raidPtr),
	    flags, b_proc);

	if (!req) {
		(node->wakeFunc) (node, ENOMEM);
	} else {
		node->dagFuncData = (void *) req;
		rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);
	}

	return (0);
}
/*****************************************************************************
 * The undo function for disk nodes.
 * Note:  This is not a proper undo of a write node, only locks are released.
 *	  old data is not restored to disk !
 *****************************************************************************/
int
rf_DiskUndoFunc(RF_DagNode_t *node)
{
	RF_DiskQueueData_t *req;
	RF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;
	RF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;

	req = rf_CreateDiskQueueData(RF_IO_TYPE_NOP, 0L, 0, NULL, 0L, 0,
	    (int (*) (void *, int)) node->wakeFunc, (void *) node,
	    NULL, node->dagHdr->tracerec, (void *) (node->dagHdr->raidPtr),
	    RF_UNLOCK_DISK_QUEUE, NULL);
	if (!req)
		(node->wakeFunc) (node, ENOMEM);
	else {
		node->dagFuncData = (void *) req;
		rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req,
		    RF_IO_NORMAL_PRIORITY);
	}

	return (0);
}

/*****************************************************************************
 * The execution function associated with an "unlock disk queue" node.
 *****************************************************************************/
int
rf_DiskUnlockFuncForThreads(RF_DagNode_t *node)
{
	RF_DiskQueueData_t *req;
	RF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;
	RF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;

	req = rf_CreateDiskQueueData(RF_IO_TYPE_NOP, 0L, 0, NULL, 0L, 0,
	    (int (*) (void *, int)) node->wakeFunc, (void *) node,
	    NULL, node->dagHdr->tracerec, (void *) (node->dagHdr->raidPtr),
	    RF_UNLOCK_DISK_QUEUE, NULL);
	if (!req)
		(node->wakeFunc) (node, ENOMEM);
	else {
		node->dagFuncData = (void *) req;
		rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req,
		    RF_IO_NORMAL_PRIORITY);
	}

	return (0);
}

/*****************************************************************************
 * Callback routine for DiskRead and DiskWrite nodes. When the disk op
 * completes, the routine is called to set the node status and inform
 * the execution engine that the node has fired.
 *****************************************************************************/
int
rf_GenericWakeupFunc(RF_DagNode_t *node, int status)
{
	switch (node->status) {
	case rf_bwd1:
		node->status = rf_bwd2;
		if (node->dagFuncData)
			rf_FreeDiskQueueData((RF_DiskQueueData_t *)
			    node->dagFuncData);
		return (rf_DiskWriteFuncForThreads(node));
		break;
	case rf_fired:
		if (status)
			node->status = rf_bad;
		else
			node->status = rf_good;
		break;
	case rf_recover:
		/* Probably should never reach this case. */
		if (status)
			node->status = rf_panic;
		else
			node->status = rf_undone;
		break;
	default:
		printf("rf_GenericWakeupFunc:");
		printf("node->status is %d,", node->status);
		printf("status is %d \n", status);
		RF_PANIC();
		break;
	}
	if (node->dagFuncData)
		rf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);
	return (rf_FinishNode(node, RF_INTR_CONTEXT));
}


/*****************************************************************************
 * There are three distinct types of xor nodes.
 *
 * A "regular xor" is used in the fault-free case where the access spans
 * a complete stripe unit. It assumes that the result buffer is one full
 * stripe unit in size, and uses the stripe-unit-offset values that it
 * computes from the PDAs to determine where within the stripe unit to
 * XOR each argument buffer.
 *
 * A "simple xor" is used in the fault-free case where the access touches
 * only a portion of one (or two, in some cases) stripe unit(s). It assumes
 * that all the argument buffers are of the same size and have the same
 * stripe unit offset.
 *
 * A "recovery xor" is used in the degraded-mode case. It's similar to
 * the regular xor function except that it takes the failed PDA as an
 * additional parameter, and uses it to determine what portions of the
 * argument buffers need to be xor'd into the result buffer, and where
 * in the result buffer they should go.
 *****************************************************************************/

/*
 * Xor the params together and store the result in the result field.
 * Assume the result field points to a buffer that is the size of one SU,
 * and use the pda params to determine where within the buffer to XOR
 * the input buffers.
 */
int
rf_RegularXorFunc(RF_DagNode_t *node)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;
	int i, retcode;

	retcode = 0;
	if (node->dagHdr->status == rf_enable) {
		/* Don't do the XOR if the input is the same as the output. */
		RF_ETIMER_START(timer);
		for (i = 0; i < node->numParams - 1; i += 2)
			if (node->params[i + 1].p != node->results[0]) {
				retcode = rf_XorIntoBuffer(raidPtr,
				    (RF_PhysDiskAddr_t *) node->params[i].p,
				    (char *) node->params[i + 1].p,
				    (char *) node->results[0],
				    node->dagHdr->bp);
			}
		RF_ETIMER_STOP(timer);
		RF_ETIMER_EVAL(timer);
		tracerec->xor_us += RF_ETIMER_VAL_US(timer);
	}
	/* Call wake func explicitly since no I/O in this node. */
	return (rf_GenericWakeupFunc(node, retcode));
}

/* Xor the inputs into the result buffer, ignoring placement issues. */
int
rf_SimpleXorFunc(RF_DagNode_t *node)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;
	int i, retcode = 0;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;

	if (node->dagHdr->status == rf_enable) {
		RF_ETIMER_START(timer);
		/* Don't do the XOR if the input is the same as the output. */
		for (i = 0; i < node->numParams - 1; i += 2)
			if (node->params[i + 1].p != node->results[0]) {
				retcode = rf_bxor((char *)
				    node->params[i + 1].p,
				    (char *) node->results[0],
				    rf_RaidAddressToByte(raidPtr,
				    ((RF_PhysDiskAddr_t *)
				    node->params[i].p)->numSector),
				    (struct buf *) node->dagHdr->bp);
			}
		RF_ETIMER_STOP(timer);
		RF_ETIMER_EVAL(timer);
		tracerec->xor_us += RF_ETIMER_VAL_US(timer);
	}
	/* Call wake func explicitly since no I/O in this node. */
	return (rf_GenericWakeupFunc(node, retcode));
}

/*
 * This xor is used by the degraded-mode dag functions to recover lost data.
 * The second-to-last parameter is the PDA for the failed portion of the access.
 * The code here looks at this PDA and assumes that the xor target buffer is
 * equal in size to the number of sectors in the failed PDA. It then uses
 * the other PDAs in the parameter list to determine where within the target
 * buffer the corresponding data should be xored.
 */
int
rf_RecoveryXorFunc(RF_DagNode_t *node)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;
	RF_PhysDiskAddr_t *failedPDA =
	    (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;
	int i, retcode = 0;
	RF_PhysDiskAddr_t *pda;
	int suoffset, failedSUOffset =
	    rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char *srcbuf, *destbuf;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;

	if (node->dagHdr->status == rf_enable) {
		RF_ETIMER_START(timer);
		for (i = 0; i < node->numParams - 2; i += 2)
			if (node->params[i + 1].p != node->results[0]) {
				pda = (RF_PhysDiskAddr_t *) node->params[i].p;
				srcbuf = (char *) node->params[i + 1].p;
				suoffset = rf_StripeUnitOffset(layoutPtr,
				    pda->startSector);
				destbuf = ((char *) node->results[0]) +
				    rf_RaidAddressToByte(raidPtr,
				    suoffset - failedSUOffset);
				retcode = rf_bxor(srcbuf, destbuf,
				    rf_RaidAddressToByte(raidPtr,
				    pda->numSector), node->dagHdr->bp);
			}
		RF_ETIMER_STOP(timer);
		RF_ETIMER_EVAL(timer);
		tracerec->xor_us += RF_ETIMER_VAL_US(timer);
	}
	return (rf_GenericWakeupFunc(node, retcode));
}


/*****************************************************************************
 * The next three functions are utilities used by the above xor-execution
 * functions.
 *****************************************************************************/

/*
 * This is just a glorified buffer xor. Targbuf points to a buffer that is
 * one full stripe unit in size. srcbuf points to a buffer that may be less
 * than 1 SU, but never more. When the access described by pda is one SU in
 * size (which by implication means it's SU-aligned), all that happens is
 * (targbuf) <- (srcbuf ^ targbuf). When the access is less than one SU in
 * size the XOR occurs on only the portion of targbuf identified in the pda.
 */

int
rf_XorIntoBuffer(RF_Raid_t *raidPtr, RF_PhysDiskAddr_t *pda, char *srcbuf,
    char *targbuf, void *bp)
{
	char *targptr;
	int sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	int SUOffset = pda->startSector % sectPerSU;
	int length, retcode = 0;

	RF_ASSERT(pda->numSector <= sectPerSU);

	targptr = targbuf + rf_RaidAddressToByte(raidPtr, SUOffset);
	length = rf_RaidAddressToByte(raidPtr, pda->numSector);
	retcode = rf_bxor(srcbuf, targptr, length, bp);
	return (retcode);
}

/*
 * It really should be the case that the buffer pointers (returned by malloc)
 * are aligned to the natural word size of the machine, so this is the only
 * case we optimize for. The length should always be a multiple of the sector
 * size, so there should be no problem with leftover bytes at the end.
 */
int
rf_bxor(char *src, char *dest, int len, void *bp)
{
	unsigned mask = sizeof(long) - 1, retcode = 0;

	if (!(((unsigned long) src) & mask) &&
	    !(((unsigned long) dest) & mask) && !(len & mask)) {
		retcode = rf_longword_bxor((unsigned long *) src,
		    (unsigned long *) dest, len >> RF_LONGSHIFT, bp);
	} else {
		RF_ASSERT(0);
	}
	return (retcode);
}

/* Map a user buffer into kernel space, if necessary. */
#define	REMAP_VA(_bp,x,y)	(y) = (x)

/*
 * When XORing in kernel mode, we need to map each user page to kernel
 * space before we can access it.
 * We don't want to assume anything about which input buffers are in
 * kernel/user space, nor about their alignment, so in each loop we
 * compute the maximum number of bytes that we can xor without crossing
 * any page boundaries, and do only this many bytes before the next remap.
 */
int
rf_longword_bxor(unsigned long *src, unsigned long *dest, int len, void *bp)
{
	unsigned long *end = src + len; /* len in longwords. */
	unsigned long d0, d1, d2, d3, s0, s1, s2, s3; /* temps */
	unsigned long *pg_src, *pg_dest; /* Per-page source/dest pointers. */
	int longs_this_time; /* # longwords to xor in the current iteration. */

	REMAP_VA(bp, src, pg_src);
	REMAP_VA(bp, dest, pg_dest);
	if (!pg_src || !pg_dest)
		return (EFAULT);

	while (len >= 4) {
		longs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(pg_src),
		    RF_BLIP(pg_dest)) >> RF_LONGSHIFT);
		src += longs_this_time;
		dest += longs_this_time;
		len -= longs_this_time;
		while (longs_this_time >= 4) {
			d0 = pg_dest[0];
			d1 = pg_dest[1];
			d2 = pg_dest[2];
			d3 = pg_dest[3];
			s0 = pg_src[0];
			s1 = pg_src[1];
			s2 = pg_src[2];
			s3 = pg_src[3];
			pg_dest[0] = d0 ^ s0;
			pg_dest[1] = d1 ^ s1;
			pg_dest[2] = d2 ^ s2;
			pg_dest[3] = d3 ^ s3;
			pg_src += 4;
			pg_dest += 4;
			longs_this_time -= 4;
		}
		while (longs_this_time > 0) {
			/* Cannot cross any page boundaries here. */
			*pg_dest++ ^= *pg_src++;
			longs_this_time--;
		}

		/*
		 * Either we're done, or we've reached a page boundary on one
		 * (or possibly both) of the pointers.
		 */
		if (len) {
			if (RF_PAGE_ALIGNED(src))
				REMAP_VA(bp, src, pg_src);
			if (RF_PAGE_ALIGNED(dest))
				REMAP_VA(bp, dest, pg_dest);
			if (!pg_src || !pg_dest)
				return (EFAULT);
		}
	}
	while (src < end) {
		*pg_dest++ ^= *pg_src++;
		src++;
		dest++;
		len--;
		if (RF_PAGE_ALIGNED(src))
			REMAP_VA(bp, src, pg_src);
		if (RF_PAGE_ALIGNED(dest))
			REMAP_VA(bp, dest, pg_dest);
	}
	RF_ASSERT(len == 0);
	return (0);
}


/*
 * dst = a ^ b ^ c;
 * a may equal dst
 * see comment above longword_bxor
 */
int
rf_longword_bxor3(unsigned long *dst, unsigned long *a, unsigned long *b,
    unsigned long *c, int len, void *bp)
{
	unsigned long a0, a1, a2, a3, b0, b1, b2, b3;
	/* Per-page source/dest pointers. */
	unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;
	int longs_this_time;	/* # longs to xor in the current iteration */
	char dst_is_a = 0;

	/* Note: The length (len) is in longwords. */

	REMAP_VA(bp, a, pg_a);
	REMAP_VA(bp, b, pg_b);
	REMAP_VA(bp, c, pg_c);
	if (a == dst) {
		pg_dst = pg_a;
		dst_is_a = 1;
	} else {
		REMAP_VA(bp, dst, pg_dst);
	}

	/* Align dest to cache line. Can't cross a pg boundary on dst here. */
	while ((((unsigned long) pg_dst) & 0x1f)) {
		*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;
		dst++;
		a++;
		b++;
		c++;
		if (RF_PAGE_ALIGNED(a)) {
			REMAP_VA(bp, a, pg_a);
			if (!pg_a)
				return (EFAULT);
		}
		if (RF_PAGE_ALIGNED(b)) {
			REMAP_VA(bp, a, pg_b);
			if (!pg_b)
				return (EFAULT);
		}
		if (RF_PAGE_ALIGNED(c)) {
			REMAP_VA(bp, a, pg_c);
			if (!pg_c)
				return (EFAULT);
		}
		len--;
	}

	while (len > 4) {
		longs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a),
		    RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >>
		    RF_LONGSHIFT);
		a += longs_this_time;
		b += longs_this_time;
		c += longs_this_time;
		dst += longs_this_time;
		len -= longs_this_time;
		while (longs_this_time >= 4) {
			a0 = pg_a[0];
			longs_this_time -= 4;

			a1 = pg_a[1];
			a2 = pg_a[2];

			a3 = pg_a[3];
			pg_a += 4;

			b0 = pg_b[0];
			b1 = pg_b[1];

			b2 = pg_b[2];
			b3 = pg_b[3];
			/* Start dual issue. */
			a0 ^= b0;
			b0 = pg_c[0];

			pg_b += 4;
			a1 ^= b1;

			a2 ^= b2;
			a3 ^= b3;

			b1 = pg_c[1];
			a0 ^= b0;

			b2 = pg_c[2];
			a1 ^= b1;

			b3 = pg_c[3];
			a2 ^= b2;

			pg_dst[0] = a0;
			a3 ^= b3;
			pg_dst[1] = a1;
			pg_c += 4;
			pg_dst[2] = a2;
			pg_dst[3] = a3;
			pg_dst += 4;
		}
		while (longs_this_time > 0) {
			/* Cannot cross any page boundaries here. */
			*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;
			longs_this_time--;
		}

		if (len) {
			if (RF_PAGE_ALIGNED(a)) {
				REMAP_VA(bp, a, pg_a);
				if (!pg_a)
					return (EFAULT);
				if (dst_is_a)
					pg_dst = pg_a;
			}
			if (RF_PAGE_ALIGNED(b)) {
				REMAP_VA(bp, b, pg_b);
				if (!pg_b)
					return (EFAULT);
			}
			if (RF_PAGE_ALIGNED(c)) {
				REMAP_VA(bp, c, pg_c);
				if (!pg_c)
					return (EFAULT);
			}
			if (!dst_is_a)
				if (RF_PAGE_ALIGNED(dst)) {
					REMAP_VA(bp, dst, pg_dst);
					if (!pg_dst)
						return (EFAULT);
				}
		}
	}
	while (len) {
		*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;
		dst++;
		a++;
		b++;
		c++;
		if (RF_PAGE_ALIGNED(a)) {
			REMAP_VA(bp, a, pg_a);
			if (!pg_a)
				return (EFAULT);
			if (dst_is_a)
				pg_dst = pg_a;
		}
		if (RF_PAGE_ALIGNED(b)) {
			REMAP_VA(bp, b, pg_b);
			if (!pg_b)
				return (EFAULT);
		}
		if (RF_PAGE_ALIGNED(c)) {
			REMAP_VA(bp, c, pg_c);
			if (!pg_c)
				return (EFAULT);
		}
		if (!dst_is_a)
			if (RF_PAGE_ALIGNED(dst)) {
				REMAP_VA(bp, dst, pg_dst);
				if (!pg_dst)
					return (EFAULT);
			}
		len--;
	}
	return (0);
}

int
rf_bxor3(unsigned char *dst, unsigned char *a, unsigned char *b,
    unsigned char *c, unsigned long len, void *bp)
{
	RF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7)
	    == 0);

	return (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,
		(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT,
		 bp));
}
@


1.7
log
@addres -> address
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagfuncs.c,v 1.6 2002/12/16 07:01:03 tdeval Exp $	*/
@


1.6
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagfuncs.c,v 1.5 2000/08/08 16:07:39 peter Exp $	*/
d127 1
a127 1
 * 0 - Physical disk addres of data.
@


1.5
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagfuncs.c,v 1.4 2000/01/07 14:50:20 peter Exp $	*/
d3 1
d32 1
a32 1
 * dagfuncs.c -- DAG node execution routines
d69 1
a69 1
#if RF_INCLUDE_PARITYLOGGING > 0
d71 1
a71 1
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
d73 15
a87 16
int     (*rf_DiskReadFunc) (RF_DagNode_t *);
int     (*rf_DiskWriteFunc) (RF_DagNode_t *);
int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);
int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);
int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);
int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);
int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);
int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);
int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);

/*****************************************************************************************
 * main (only) configuration routine for this module
 ****************************************************************************************/
int 
rf_ConfigureDAGFuncs(listp)
	RF_ShutdownList_t **listp;
d89 2
a90 1
	RF_ASSERT(((sizeof(long) == 8) && RF_LONGSHIFT == 3) || ((sizeof(long) == 4) && RF_LONGSHIFT == 2));
d104 5
a108 7

/*****************************************************************************************
 * the execution function associated with a terminate node
 ****************************************************************************************/
int 
rf_TerminateFunc(node)
	RF_DagNode_t *node;
d115 2
a116 3
int 
rf_TerminateUndoFunc(node)
	RF_DagNode_t *node;
d122 2
a123 2
/*****************************************************************************************
 * execution functions associated with a mirror node
d127 15
a141 14
 * 0 - physical disk addres of data
 * 1 - buffer for holding read data
 * 2 - parity stripe ID
 * 3 - flags
 * 4 - physical disk address of mirror (parity)
 *
 ****************************************************************************************/

int 
rf_DiskReadMirrorIdleFunc(node)
	RF_DagNode_t *node;
{
	/* select the mirror copy with the shortest queue and fill in node
	 * parameters with physical disk address */
d147 2
a148 3
int 
rf_DiskReadMirrorPartitionFunc(node)
	RF_DagNode_t *node;
d150 4
a153 2
	/* select the mirror copy with the shortest queue and fill in node
	 * parameters with physical disk address */
d159 2
a160 3
int 
rf_DiskReadMirrorUndoFunc(node)
	RF_DagNode_t *node;
d167 6
a172 7
#if RF_INCLUDE_PARITYLOGGING > 0
/*****************************************************************************************
 * the execution function associated with a parity log update node
 ****************************************************************************************/
int 
rf_ParityLogUpdateFunc(node)
	RF_DagNode_t *node;
d199 5
a203 6
/*****************************************************************************************
 * the execution function associated with a parity log overwrite node
 ****************************************************************************************/
int 
rf_ParityLogOverwriteFunc(node)
	RF_DagNode_t *node;
d213 3
a215 2
		logData = rf_CreateParityLogData(RF_OVERWRITE, pda, buf, (RF_Raid_t *) (node->dagHdr->raidPtr),
		    node->wakeFunc, (void *) node, node->dagHdr->tracerec, timer);
d227 1
a227 1
#else				/* RF_INCLUDE_PARITYLOGGING > 0 */
d229 2
a230 3
int 
rf_ParityLogUpdateFunc(node)
	RF_DagNode_t *node;
d234 3
a236 3
int 
rf_ParityLogOverwriteFunc(node)
	RF_DagNode_t *node;
d240 1
a240 1
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
d242 2
a243 3
int 
rf_ParityLogUpdateUndoFunc(node)
	RF_DagNode_t *node;
d248 2
a249 3
int 
rf_ParityLogOverwriteUndoFunc(node)
	RF_DagNode_t *node;
d253 6
a258 6
/*****************************************************************************************
 * the execution function associated with a NOP node
 ****************************************************************************************/
int 
rf_NullNodeFunc(node)
	RF_DagNode_t *node;
d264 2
a265 3
int 
rf_NullNodeUndoFunc(node)
	RF_DagNode_t *node;
d272 5
a276 6
/*****************************************************************************************
 * the execution function associated with a disk-read node
 ****************************************************************************************/
int 
rf_DiskReadFuncForThreads(node)
	RF_DagNode_t *node;
d287 2
a288 1
	RF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_READ : RF_IO_TYPE_NOP;
d290 1
a290 1
	void   *b_proc = NULL;
d314 1
a314 1
/*****************************************************************************************
d316 3
a318 4
 ****************************************************************************************/
int 
rf_DiskWriteFuncForThreads(node)
	RF_DagNode_t *node;
d329 2
a330 1
	RF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_WRITE : RF_IO_TYPE_NOP;
d332 1
a332 1
	void   *b_proc = NULL;
d337 1
a337 1
	/* normal processing (rollaway or forward recovery) begins here */
d343 2
a344 4
	    (int (*) (void *, int)) node->wakeFunc,
	    (void *) node, NULL,
	    node->dagHdr->tracerec,
	    (void *) (node->dagHdr->raidPtr),
d356 7
a362 8
/*****************************************************************************************
 * the undo function for disk nodes
 * Note:  this is not a proper undo of a write node, only locks are released.
 *        old data is not restored to disk!
 ****************************************************************************************/
int 
rf_DiskUndoFunc(node)
	RF_DagNode_t *node;
d368 3
a370 6
	req = rf_CreateDiskQueueData(RF_IO_TYPE_NOP,
	    0L, 0, NULL, 0L, 0,
	    (int (*) (void *, int)) node->wakeFunc,
	    (void *) node,
	    NULL, node->dagHdr->tracerec,
	    (void *) (node->dagHdr->raidPtr),
d376 2
a377 1
		rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, RF_IO_NORMAL_PRIORITY);
d382 6
a387 6
/*****************************************************************************************
 * the execution function associated with an "unlock disk queue" node
 ****************************************************************************************/
int 
rf_DiskUnlockFuncForThreads(node)
	RF_DagNode_t *node;
d393 3
a395 6
	req = rf_CreateDiskQueueData(RF_IO_TYPE_NOP,
	    0L, 0, NULL, 0L, 0,
	    (int (*) (void *, int)) node->wakeFunc,
	    (void *) node,
	    NULL, node->dagHdr->tracerec,
	    (void *) (node->dagHdr->raidPtr),
d401 2
a402 1
		rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, RF_IO_NORMAL_PRIORITY);
d407 8
a414 9
/*****************************************************************************************
 * Callback routine for DiskRead and DiskWrite nodes.  When the disk op completes,
 * the routine is called to set the node status and inform the execution engine that
 * the node has fired.
 ****************************************************************************************/
int 
rf_GenericWakeupFunc(node, status)
	RF_DagNode_t *node;
	int     status;
d420 2
a421 1
			rf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);
d431 1
a431 1
		/* probably should never reach this case */
d450 20
a469 16
/*****************************************************************************************
 * there are three distinct types of xor nodes
 * A "regular xor" is used in the fault-free case where the access spans a complete
 * stripe unit.  It assumes that the result buffer is one full stripe unit in size,
 * and uses the stripe-unit-offset values that it computes from the PDAs to determine
 * where within the stripe unit to XOR each argument buffer.
 *
 * A "simple xor" is used in the fault-free case where the access touches only a portion
 * of one (or two, in some cases) stripe unit(s).  It assumes that all the argument
 * buffers are of the same size and have the same stripe unit offset.
 *
 * A "recovery xor" is used in the degraded-mode case.  It's similar to the regular
 * xor function except that it takes the failed PDA as an additional parameter, and
 * uses it to determine what portions of the argument buffers need to be xor'd into
 * the result buffer, and where in the result buffer they should go.
 ****************************************************************************************/
d471 3
a473 2
/* xor the params together and store the result in the result field.
 * assume the result field points to a buffer that is the size of one SU,
d477 2
a478 3
int 
rf_RegularXorFunc(node)
	RF_DagNode_t *node;
d483 1
a483 1
	int     i, retcode;
d487 1
a487 1
		/* don't do the XOR if the input is the same as the output */
d491 5
a495 2
				retcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,
				    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);
d501 7
a507 8
	return (rf_GenericWakeupFunc(node, retcode));	/* call wake func
							 * explicitly since no
							 * I/O in this node */
}
/* xor the inputs into the result buffer, ignoring placement issues */
int 
rf_SimpleXorFunc(node)
	RF_DagNode_t *node;
d510 1
a510 1
	int     i, retcode = 0;
d516 1
a516 1
		/* don't do the XOR if the input is the same as the output */
d519 6
a524 2
				retcode = rf_bxor((char *) node->params[i + 1].p, (char *) node->results[0],
				    rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[i].p)->numSector),
d531 9
a539 8
	return (rf_GenericWakeupFunc(node, retcode));	/* call wake func
							 * explicitly since no
							 * I/O in this node */
}
/* this xor is used by the degraded-mode dag functions to recover lost data.
 * the second-to-last parameter is the PDA for the failed portion of the access.
 * the code here looks at this PDA and assumes that the xor target buffer is
 * equal in size to the number of sectors in the failed PDA.  It then uses
d543 2
a544 3
int 
rf_RecoveryXorFunc(node)
	RF_DagNode_t *node;
d548 3
a550 2
	RF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;
	int     i, retcode = 0;
d552 3
a554 2
	int     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char   *srcbuf, *destbuf;
d564 8
a571 3
				suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
				destbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);
				retcode = rf_bxor(srcbuf, destbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), node->dagHdr->bp);
a578 3
/*****************************************************************************************
 * The next three functions are utilities used by the above xor-execution functions.
 ****************************************************************************************/
d581 5
d587 6
a592 5
 * this is just a glorified buffer xor.  targbuf points to a buffer that is one full stripe unit
 * in size.  srcbuf points to a buffer that may be less than 1 SU, but never more.  When the
 * access described by pda is one SU in size (which by implication means it's SU-aligned),
 * all that happens is (targbuf) <- (srcbuf ^ targbuf).  When the access is less than one
 * SU in size the XOR occurs on only the portion of targbuf identified in the pda.
d595 8
a602 12
int 
rf_XorIntoBuffer(raidPtr, pda, srcbuf, targbuf, bp)
	RF_Raid_t *raidPtr;
	RF_PhysDiskAddr_t *pda;
	char   *srcbuf;
	char   *targbuf;
	void   *bp;
{
	char   *targptr;
	int     sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	int     SUOffset = pda->startSector % sectPerSU;
	int     length, retcode = 0;
d611 3
a613 1
/* it really should be the case that the buffer pointers (returned by malloc)
d615 1
a615 1
 * case we optimize for.  The length should always be a multiple of the sector
d618 2
a619 6
int 
rf_bxor(src, dest, len, bp)
	char   *src;
	char   *dest;
	int     len;
	void   *bp;
d623 4
a626 2
	if (!(((unsigned long) src) & mask) && !(((unsigned long) dest) & mask) && !(len & mask)) {
		retcode = rf_longword_bxor((unsigned long *) src, (unsigned long *) dest, len >> RF_LONGSHIFT, bp);
a631 2
/* map a user buffer into kernel space, if necessary */
#define REMAP_VA(_bp,x,y) (y) = (x)
d633 10
a642 5
/* When XORing in kernel mode, we need to map each user page to kernel space before we can access it.
 * We don't want to assume anything about which input buffers are in kernel/user
 * space, nor about their alignment, so in each loop we compute the maximum number
 * of bytes that we can xor without crossing any page boundaries, and do only this many
 * bytes before the next remap.
d644 7
a650 12
int 
rf_longword_bxor(src, dest, len, bp)
	unsigned long *src;
	unsigned long *dest;
	int     len;		/* longwords */
	void   *bp;
{
	unsigned long *end = src + len;
	unsigned long d0, d1, d2, d3, s0, s1, s2, s3;	/* temps */
	unsigned long *pg_src, *pg_dest;	/* per-page source/dest
							 * pointers */
	int     longs_this_time;/* # longwords to xor in the current iteration */
d658 2
a659 1
		longs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(pg_src), RF_BLIP(pg_dest)) >> RF_LONGSHIFT);	/* note len in longwords */
d680 2
a681 2
		while (longs_this_time > 0) {	/* cannot cross any page
						 * boundaries here */
d686 4
a689 2
		/* either we're done, or we've reached a page boundary on one
		 * (or possibly both) of the pointers */
d715 7
a721 12
   dst = a ^ b ^ c;
   a may equal dst
   see comment above longword_bxor
*/
int 
rf_longword_bxor3(dst, a, b, c, len, bp)
	unsigned long *dst;
	unsigned long *a;
	unsigned long *b;
	unsigned long *c;
	int     len;		/* length in longwords */
	void   *bp;
d724 6
a729 4
	unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;	/* per-page source/dest
								 * pointers */
	int     longs_this_time;/* # longs to xor in the current iteration */
	char    dst_is_a = 0;
d741 1
a741 1
	/* align dest to cache line.  Can't cross a pg boundary on dst here. */
d767 3
a769 1
		longs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a), RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >> RF_LONGSHIFT);
d790 1
a790 1
			/* start dual issue */
d817 2
a818 2
		while (longs_this_time > 0) {	/* cannot cross any page
						 * boundaries here */
d883 3
a885 8
int 
rf_bxor3(dst, a, b, c, len, bp)
	unsigned char *dst;
	unsigned char *a;
	unsigned char *b;
	unsigned char *c;
	unsigned long len;
	void   *bp;
d887 2
a888 1
	RF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);
d891 2
a892 1
		(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));
@


1.5.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d31 1
a31 1
 * dagfuncs.c -- DAG node execution routines.
d68 1
a68 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d70 1
a70 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d72 16
a87 15
int	(*rf_DiskReadFunc) (RF_DagNode_t *);
int	(*rf_DiskWriteFunc) (RF_DagNode_t *);
int	(*rf_DiskReadUndoFunc) (RF_DagNode_t *);
int	(*rf_DiskWriteUndoFunc) (RF_DagNode_t *);
int	(*rf_DiskUnlockFunc) (RF_DagNode_t *);
int	(*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);
int	(*rf_RegularXorUndoFunc) (RF_DagNode_t *);
int	(*rf_SimpleXorUndoFunc) (RF_DagNode_t *);
int	(*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);

/*****************************************************************************
 * Main (only) configuration routine for this module.
 *****************************************************************************/
int
rf_ConfigureDAGFuncs(RF_ShutdownList_t **listp)
d89 1
a89 2
	RF_ASSERT(((sizeof(long) == 8) && RF_LONGSHIFT == 3) ||
	    ((sizeof(long) == 4) && RF_LONGSHIFT == 2));
d103 7
a109 5
/*****************************************************************************
 * The execution function associated with a terminate node.
 *****************************************************************************/
int
rf_TerminateFunc(RF_DagNode_t *node)
d116 3
a118 2
int
rf_TerminateUndoFunc(RF_DagNode_t *node)
d124 2
a125 2
/*****************************************************************************
 * Execution functions associated with a mirror node.
d129 14
a142 15
 * 0 - Physical disk addres of data.
 * 1 - Buffer for holding read data.
 * 2 - Parity stripe ID.
 * 3 - Flags.
 * 4 - Physical disk address of mirror (parity).
 *
 *****************************************************************************/

int
rf_DiskReadMirrorIdleFunc(RF_DagNode_t *node)
{
	/*
	 * Select the mirror copy with the shortest queue and fill in node
	 * parameters with physical disk address.
	 */
d148 3
a150 2
int
rf_DiskReadMirrorPartitionFunc(RF_DagNode_t *node)
d152 2
a153 4
	/*
	 * Select the mirror copy with the shortest queue and fill in node
	 * parameters with physical disk address.
	 */
d159 3
a161 2
int
rf_DiskReadMirrorUndoFunc(RF_DagNode_t *node)
d168 7
a174 6
#if	RF_INCLUDE_PARITYLOGGING > 0
/*****************************************************************************
 * The execution function associated with a parity log update node.
 *****************************************************************************/
int
rf_ParityLogUpdateFunc(RF_DagNode_t *node)
d201 6
a206 5
/*****************************************************************************
 * The execution function associated with a parity log overwrite node.
 *****************************************************************************/
int
rf_ParityLogOverwriteFunc(RF_DagNode_t *node)
d216 2
a217 3
		logData = rf_CreateParityLogData(RF_OVERWRITE, pda, buf,
		    (RF_Raid_t *) (node->dagHdr->raidPtr), node->wakeFunc,
		    (void *) node, node->dagHdr->tracerec, timer);
d229 1
a229 1
#else	/* RF_INCLUDE_PARITYLOGGING > 0 */
d231 3
a233 2
int
rf_ParityLogUpdateFunc(RF_DagNode_t *node)
d237 3
a239 3

int
rf_ParityLogOverwriteFunc(RF_DagNode_t *node)
d243 1
a243 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d245 3
a247 2
int
rf_ParityLogUpdateUndoFunc(RF_DagNode_t *node)
d252 3
a254 2
int
rf_ParityLogOverwriteUndoFunc(RF_DagNode_t *node)
d258 6
a263 6

/*****************************************************************************
 * The execution function associated with a NOP node.
 *****************************************************************************/
int
rf_NullNodeFunc(RF_DagNode_t *node)
d269 3
a271 2
int
rf_NullNodeUndoFunc(RF_DagNode_t *node)
d278 6
a283 5
/*****************************************************************************
 * The execution function associated with a disk-read node.
 *****************************************************************************/
int
rf_DiskReadFuncForThreads(RF_DagNode_t *node)
d294 1
a294 2
	RF_IoType_t iotype = (node->dagHdr->status == rf_enable) ?
	    RF_IO_TYPE_READ : RF_IO_TYPE_NOP;
d296 1
a296 1
	void *b_proc = NULL;
d320 1
a320 1
/*****************************************************************************
d322 4
a325 3
 *****************************************************************************/
int
rf_DiskWriteFuncForThreads(RF_DagNode_t *node)
d336 1
a336 2
	RF_IoType_t iotype = (node->dagHdr->status == rf_enable) ?
	    RF_IO_TYPE_WRITE : RF_IO_TYPE_NOP;
d338 1
a338 1
	void *b_proc = NULL;
d343 1
a343 1
	/* Normal processing (rollaway or forward recovery) begins here. */
d349 4
a352 2
	    (int (*) (void *, int)) node->wakeFunc, (void *) node, NULL,
	    node->dagHdr->tracerec, (void *) (node->dagHdr->raidPtr),
d364 8
a371 7
/*****************************************************************************
 * The undo function for disk nodes.
 * Note:  This is not a proper undo of a write node, only locks are released.
 *	  old data is not restored to disk !
 *****************************************************************************/
int
rf_DiskUndoFunc(RF_DagNode_t *node)
d377 6
a382 3
	req = rf_CreateDiskQueueData(RF_IO_TYPE_NOP, 0L, 0, NULL, 0L, 0,
	    (int (*) (void *, int)) node->wakeFunc, (void *) node,
	    NULL, node->dagHdr->tracerec, (void *) (node->dagHdr->raidPtr),
d388 1
a388 2
		rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req,
		    RF_IO_NORMAL_PRIORITY);
d393 6
a398 6

/*****************************************************************************
 * The execution function associated with an "unlock disk queue" node.
 *****************************************************************************/
int
rf_DiskUnlockFuncForThreads(RF_DagNode_t *node)
d404 6
a409 3
	req = rf_CreateDiskQueueData(RF_IO_TYPE_NOP, 0L, 0, NULL, 0L, 0,
	    (int (*) (void *, int)) node->wakeFunc, (void *) node,
	    NULL, node->dagHdr->tracerec, (void *) (node->dagHdr->raidPtr),
d415 1
a415 2
		rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req,
		    RF_IO_NORMAL_PRIORITY);
d420 9
a428 8

/*****************************************************************************
 * Callback routine for DiskRead and DiskWrite nodes. When the disk op
 * completes, the routine is called to set the node status and inform
 * the execution engine that the node has fired.
 *****************************************************************************/
int
rf_GenericWakeupFunc(RF_DagNode_t *node, int status)
d434 1
a434 2
			rf_FreeDiskQueueData((RF_DiskQueueData_t *)
			    node->dagFuncData);
d444 1
a444 1
		/* Probably should never reach this case. */
d463 16
a478 20
/*****************************************************************************
 * There are three distinct types of xor nodes.
 *
 * A "regular xor" is used in the fault-free case where the access spans
 * a complete stripe unit. It assumes that the result buffer is one full
 * stripe unit in size, and uses the stripe-unit-offset values that it
 * computes from the PDAs to determine where within the stripe unit to
 * XOR each argument buffer.
 *
 * A "simple xor" is used in the fault-free case where the access touches
 * only a portion of one (or two, in some cases) stripe unit(s). It assumes
 * that all the argument buffers are of the same size and have the same
 * stripe unit offset.
 *
 * A "recovery xor" is used in the degraded-mode case. It's similar to
 * the regular xor function except that it takes the failed PDA as an
 * additional parameter, and uses it to determine what portions of the
 * argument buffers need to be xor'd into the result buffer, and where
 * in the result buffer they should go.
 *****************************************************************************/
d480 2
a481 3
/*
 * Xor the params together and store the result in the result field.
 * Assume the result field points to a buffer that is the size of one SU,
d485 3
a487 2
int
rf_RegularXorFunc(RF_DagNode_t *node)
d492 1
a492 1
	int i, retcode;
d496 1
a496 1
		/* Don't do the XOR if the input is the same as the output. */
d500 2
a501 5
				retcode = rf_XorIntoBuffer(raidPtr,
				    (RF_PhysDiskAddr_t *) node->params[i].p,
				    (char *) node->params[i + 1].p,
				    (char *) node->results[0],
				    node->dagHdr->bp);
d507 8
a514 7
	/* Call wake func explicitly since no I/O in this node. */
	return (rf_GenericWakeupFunc(node, retcode));
}

/* Xor the inputs into the result buffer, ignoring placement issues. */
int
rf_SimpleXorFunc(RF_DagNode_t *node)
d517 1
a517 1
	int i, retcode = 0;
d523 1
a523 1
		/* Don't do the XOR if the input is the same as the output. */
d526 2
a527 6
				retcode = rf_bxor((char *)
				    node->params[i + 1].p,
				    (char *) node->results[0],
				    rf_RaidAddressToByte(raidPtr,
				    ((RF_PhysDiskAddr_t *)
				    node->params[i].p)->numSector),
d534 8
a541 9
	/* Call wake func explicitly since no I/O in this node. */
	return (rf_GenericWakeupFunc(node, retcode));
}

/*
 * This xor is used by the degraded-mode dag functions to recover lost data.
 * The second-to-last parameter is the PDA for the failed portion of the access.
 * The code here looks at this PDA and assumes that the xor target buffer is
 * equal in size to the number of sectors in the failed PDA. It then uses
d545 3
a547 2
int
rf_RecoveryXorFunc(RF_DagNode_t *node)
d551 2
a552 3
	RF_PhysDiskAddr_t *failedPDA =
	    (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;
	int i, retcode = 0;
d554 2
a555 3
	int suoffset, failedSUOffset =
	    rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char *srcbuf, *destbuf;
d565 3
a567 8
				suoffset = rf_StripeUnitOffset(layoutPtr,
				    pda->startSector);
				destbuf = ((char *) node->results[0]) +
				    rf_RaidAddressToByte(raidPtr,
				    suoffset - failedSUOffset);
				retcode = rf_bxor(srcbuf, destbuf,
				    rf_RaidAddressToByte(raidPtr,
				    pda->numSector), node->dagHdr->bp);
d575 3
a579 5
/*****************************************************************************
 * The next three functions are utilities used by the above xor-execution
 * functions.
 *****************************************************************************/

d581 5
a585 6
 * This is just a glorified buffer xor. Targbuf points to a buffer that is
 * one full stripe unit in size. srcbuf points to a buffer that may be less
 * than 1 SU, but never more. When the access described by pda is one SU in
 * size (which by implication means it's SU-aligned), all that happens is
 * (targbuf) <- (srcbuf ^ targbuf). When the access is less than one SU in
 * size the XOR occurs on only the portion of targbuf identified in the pda.
d588 12
a599 8
int
rf_XorIntoBuffer(RF_Raid_t *raidPtr, RF_PhysDiskAddr_t *pda, char *srcbuf,
    char *targbuf, void *bp)
{
	char *targptr;
	int sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	int SUOffset = pda->startSector % sectPerSU;
	int length, retcode = 0;
d608 1
a608 3

/*
 * It really should be the case that the buffer pointers (returned by malloc)
d610 1
a610 1
 * case we optimize for. The length should always be a multiple of the sector
d613 6
a618 2
int
rf_bxor(char *src, char *dest, int len, void *bp)
d622 2
a623 4
	if (!(((unsigned long) src) & mask) &&
	    !(((unsigned long) dest) & mask) && !(len & mask)) {
		retcode = rf_longword_bxor((unsigned long *) src,
		    (unsigned long *) dest, len >> RF_LONGSHIFT, bp);
d629 2
d632 5
a636 10
/* Map a user buffer into kernel space, if necessary. */
#define	REMAP_VA(_bp,x,y)	(y) = (x)

/*
 * When XORing in kernel mode, we need to map each user page to kernel
 * space before we can access it.
 * We don't want to assume anything about which input buffers are in
 * kernel/user space, nor about their alignment, so in each loop we
 * compute the maximum number of bytes that we can xor without crossing
 * any page boundaries, and do only this many bytes before the next remap.
d638 12
a649 7
int
rf_longword_bxor(unsigned long *src, unsigned long *dest, int len, void *bp)
{
	unsigned long *end = src + len; /* len in longwords. */
	unsigned long d0, d1, d2, d3, s0, s1, s2, s3; /* temps */
	unsigned long *pg_src, *pg_dest; /* Per-page source/dest pointers. */
	int longs_this_time; /* # longwords to xor in the current iteration. */
d657 1
a657 2
		longs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(pg_src),
		    RF_BLIP(pg_dest)) >> RF_LONGSHIFT);
d678 2
a679 2
		while (longs_this_time > 0) {
			/* Cannot cross any page boundaries here. */
d684 2
a685 4
		/*
		 * Either we're done, or we've reached a page boundary on one
		 * (or possibly both) of the pointers.
		 */
d711 12
a722 7
 * dst = a ^ b ^ c;
 * a may equal dst
 * see comment above longword_bxor
 */
int
rf_longword_bxor3(unsigned long *dst, unsigned long *a, unsigned long *b,
    unsigned long *c, int len, void *bp)
d725 4
a728 6
	/* Per-page source/dest pointers. */
	unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;
	int longs_this_time;	/* # longs to xor in the current iteration */
	char dst_is_a = 0;

	/* Note: The length (len) is in longwords. */
d740 1
a740 1
	/* Align dest to cache line. Can't cross a pg boundary on dst here. */
d766 1
a766 3
		longs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a),
		    RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >>
		    RF_LONGSHIFT);
d787 1
a787 1
			/* Start dual issue. */
d814 2
a815 2
		while (longs_this_time > 0) {
			/* Cannot cross any page boundaries here. */
d880 8
a887 3
int
rf_bxor3(unsigned char *dst, unsigned char *a, unsigned char *b,
    unsigned char *c, unsigned long len, void *bp)
d889 1
a889 2
	RF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7)
	    == 0);
d892 1
a892 2
		(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT,
		 bp));
@


1.4
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagfuncs.c,v 1.3 1999/07/30 14:45:32 peter Exp $	*/
/*	$NetBSD: rf_dagfuncs.c,v 1.5 1999/08/26 02:40:28 oster Exp $	*/
d640 2
a641 2
	register unsigned long *src;
	register unsigned long *dest;
d645 3
a647 3
	register unsigned long *end = src + len;
	register unsigned long d0, d1, d2, d3, s0, s1, s2, s3;	/* temps */
	register unsigned long *pg_src, *pg_dest;	/* per-page source/dest
d717 4
a720 4
	register unsigned long *dst;
	register unsigned long *a;
	register unsigned long *b;
	register unsigned long *c;
d725 1
a725 1
	register unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;	/* per-page source/dest
d882 4
a885 4
	register unsigned char *dst;
	register unsigned char *a;
	register unsigned char *b;
	register unsigned char *c;
@


1.4.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagfuncs.c,v 1.5 2000/08/08 16:07:39 peter Exp $	*/
/*	$NetBSD: rf_dagfuncs.c,v 1.6 2000/03/30 12:45:40 augustss Exp $	*/
d640 2
a641 2
	unsigned long *src;
	unsigned long *dest;
d645 3
a647 3
	unsigned long *end = src + len;
	unsigned long d0, d1, d2, d3, s0, s1, s2, s3;	/* temps */
	unsigned long *pg_src, *pg_dest;	/* per-page source/dest
d717 4
a720 4
	unsigned long *dst;
	unsigned long *a;
	unsigned long *b;
	unsigned long *c;
d725 1
a725 1
	unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;	/* per-page source/dest
d882 4
a885 4
	unsigned char *dst;
	unsigned char *a;
	unsigned char *b;
	unsigned char *c;
@


1.4.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d31 1
a31 1
 * dagfuncs.c -- DAG node execution routines.
d68 1
a68 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d70 1
a70 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d72 16
a87 15
int	(*rf_DiskReadFunc) (RF_DagNode_t *);
int	(*rf_DiskWriteFunc) (RF_DagNode_t *);
int	(*rf_DiskReadUndoFunc) (RF_DagNode_t *);
int	(*rf_DiskWriteUndoFunc) (RF_DagNode_t *);
int	(*rf_DiskUnlockFunc) (RF_DagNode_t *);
int	(*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);
int	(*rf_RegularXorUndoFunc) (RF_DagNode_t *);
int	(*rf_SimpleXorUndoFunc) (RF_DagNode_t *);
int	(*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);

/*****************************************************************************
 * Main (only) configuration routine for this module.
 *****************************************************************************/
int
rf_ConfigureDAGFuncs(RF_ShutdownList_t **listp)
d89 1
a89 2
	RF_ASSERT(((sizeof(long) == 8) && RF_LONGSHIFT == 3) ||
	    ((sizeof(long) == 4) && RF_LONGSHIFT == 2));
d103 7
a109 5
/*****************************************************************************
 * The execution function associated with a terminate node.
 *****************************************************************************/
int
rf_TerminateFunc(RF_DagNode_t *node)
d116 3
a118 2
int
rf_TerminateUndoFunc(RF_DagNode_t *node)
d124 2
a125 2
/*****************************************************************************
 * Execution functions associated with a mirror node.
d129 14
a142 15
 * 0 - Physical disk addres of data.
 * 1 - Buffer for holding read data.
 * 2 - Parity stripe ID.
 * 3 - Flags.
 * 4 - Physical disk address of mirror (parity).
 *
 *****************************************************************************/

int
rf_DiskReadMirrorIdleFunc(RF_DagNode_t *node)
{
	/*
	 * Select the mirror copy with the shortest queue and fill in node
	 * parameters with physical disk address.
	 */
d148 3
a150 2
int
rf_DiskReadMirrorPartitionFunc(RF_DagNode_t *node)
d152 2
a153 4
	/*
	 * Select the mirror copy with the shortest queue and fill in node
	 * parameters with physical disk address.
	 */
d159 3
a161 2
int
rf_DiskReadMirrorUndoFunc(RF_DagNode_t *node)
d168 7
a174 6
#if	RF_INCLUDE_PARITYLOGGING > 0
/*****************************************************************************
 * The execution function associated with a parity log update node.
 *****************************************************************************/
int
rf_ParityLogUpdateFunc(RF_DagNode_t *node)
d201 6
a206 5
/*****************************************************************************
 * The execution function associated with a parity log overwrite node.
 *****************************************************************************/
int
rf_ParityLogOverwriteFunc(RF_DagNode_t *node)
d216 2
a217 3
		logData = rf_CreateParityLogData(RF_OVERWRITE, pda, buf,
		    (RF_Raid_t *) (node->dagHdr->raidPtr), node->wakeFunc,
		    (void *) node, node->dagHdr->tracerec, timer);
d229 1
a229 1
#else	/* RF_INCLUDE_PARITYLOGGING > 0 */
d231 3
a233 2
int
rf_ParityLogUpdateFunc(RF_DagNode_t *node)
d237 3
a239 3

int
rf_ParityLogOverwriteFunc(RF_DagNode_t *node)
d243 1
a243 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d245 3
a247 2
int
rf_ParityLogUpdateUndoFunc(RF_DagNode_t *node)
d252 3
a254 2
int
rf_ParityLogOverwriteUndoFunc(RF_DagNode_t *node)
d258 6
a263 6

/*****************************************************************************
 * The execution function associated with a NOP node.
 *****************************************************************************/
int
rf_NullNodeFunc(RF_DagNode_t *node)
d269 3
a271 2
int
rf_NullNodeUndoFunc(RF_DagNode_t *node)
d278 6
a283 5
/*****************************************************************************
 * The execution function associated with a disk-read node.
 *****************************************************************************/
int
rf_DiskReadFuncForThreads(RF_DagNode_t *node)
d294 1
a294 2
	RF_IoType_t iotype = (node->dagHdr->status == rf_enable) ?
	    RF_IO_TYPE_READ : RF_IO_TYPE_NOP;
d296 1
a296 1
	void *b_proc = NULL;
d320 1
a320 1
/*****************************************************************************
d322 4
a325 3
 *****************************************************************************/
int
rf_DiskWriteFuncForThreads(RF_DagNode_t *node)
d336 1
a336 2
	RF_IoType_t iotype = (node->dagHdr->status == rf_enable) ?
	    RF_IO_TYPE_WRITE : RF_IO_TYPE_NOP;
d338 1
a338 1
	void *b_proc = NULL;
d343 1
a343 1
	/* Normal processing (rollaway or forward recovery) begins here. */
d349 4
a352 2
	    (int (*) (void *, int)) node->wakeFunc, (void *) node, NULL,
	    node->dagHdr->tracerec, (void *) (node->dagHdr->raidPtr),
d364 8
a371 7
/*****************************************************************************
 * The undo function for disk nodes.
 * Note:  This is not a proper undo of a write node, only locks are released.
 *	  old data is not restored to disk !
 *****************************************************************************/
int
rf_DiskUndoFunc(RF_DagNode_t *node)
d377 6
a382 3
	req = rf_CreateDiskQueueData(RF_IO_TYPE_NOP, 0L, 0, NULL, 0L, 0,
	    (int (*) (void *, int)) node->wakeFunc, (void *) node,
	    NULL, node->dagHdr->tracerec, (void *) (node->dagHdr->raidPtr),
d388 1
a388 2
		rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req,
		    RF_IO_NORMAL_PRIORITY);
d393 6
a398 6

/*****************************************************************************
 * The execution function associated with an "unlock disk queue" node.
 *****************************************************************************/
int
rf_DiskUnlockFuncForThreads(RF_DagNode_t *node)
d404 6
a409 3
	req = rf_CreateDiskQueueData(RF_IO_TYPE_NOP, 0L, 0, NULL, 0L, 0,
	    (int (*) (void *, int)) node->wakeFunc, (void *) node,
	    NULL, node->dagHdr->tracerec, (void *) (node->dagHdr->raidPtr),
d415 1
a415 2
		rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req,
		    RF_IO_NORMAL_PRIORITY);
d420 9
a428 8

/*****************************************************************************
 * Callback routine for DiskRead and DiskWrite nodes. When the disk op
 * completes, the routine is called to set the node status and inform
 * the execution engine that the node has fired.
 *****************************************************************************/
int
rf_GenericWakeupFunc(RF_DagNode_t *node, int status)
d434 1
a434 2
			rf_FreeDiskQueueData((RF_DiskQueueData_t *)
			    node->dagFuncData);
d444 1
a444 1
		/* Probably should never reach this case. */
d463 16
a478 20
/*****************************************************************************
 * There are three distinct types of xor nodes.
 *
 * A "regular xor" is used in the fault-free case where the access spans
 * a complete stripe unit. It assumes that the result buffer is one full
 * stripe unit in size, and uses the stripe-unit-offset values that it
 * computes from the PDAs to determine where within the stripe unit to
 * XOR each argument buffer.
 *
 * A "simple xor" is used in the fault-free case where the access touches
 * only a portion of one (or two, in some cases) stripe unit(s). It assumes
 * that all the argument buffers are of the same size and have the same
 * stripe unit offset.
 *
 * A "recovery xor" is used in the degraded-mode case. It's similar to
 * the regular xor function except that it takes the failed PDA as an
 * additional parameter, and uses it to determine what portions of the
 * argument buffers need to be xor'd into the result buffer, and where
 * in the result buffer they should go.
 *****************************************************************************/
d480 2
a481 3
/*
 * Xor the params together and store the result in the result field.
 * Assume the result field points to a buffer that is the size of one SU,
d485 3
a487 2
int
rf_RegularXorFunc(RF_DagNode_t *node)
d492 1
a492 1
	int i, retcode;
d496 1
a496 1
		/* Don't do the XOR if the input is the same as the output. */
d500 2
a501 5
				retcode = rf_XorIntoBuffer(raidPtr,
				    (RF_PhysDiskAddr_t *) node->params[i].p,
				    (char *) node->params[i + 1].p,
				    (char *) node->results[0],
				    node->dagHdr->bp);
d507 8
a514 7
	/* Call wake func explicitly since no I/O in this node. */
	return (rf_GenericWakeupFunc(node, retcode));
}

/* Xor the inputs into the result buffer, ignoring placement issues. */
int
rf_SimpleXorFunc(RF_DagNode_t *node)
d517 1
a517 1
	int i, retcode = 0;
d523 1
a523 1
		/* Don't do the XOR if the input is the same as the output. */
d526 2
a527 6
				retcode = rf_bxor((char *)
				    node->params[i + 1].p,
				    (char *) node->results[0],
				    rf_RaidAddressToByte(raidPtr,
				    ((RF_PhysDiskAddr_t *)
				    node->params[i].p)->numSector),
d534 8
a541 9
	/* Call wake func explicitly since no I/O in this node. */
	return (rf_GenericWakeupFunc(node, retcode));
}

/*
 * This xor is used by the degraded-mode dag functions to recover lost data.
 * The second-to-last parameter is the PDA for the failed portion of the access.
 * The code here looks at this PDA and assumes that the xor target buffer is
 * equal in size to the number of sectors in the failed PDA. It then uses
d545 3
a547 2
int
rf_RecoveryXorFunc(RF_DagNode_t *node)
d551 2
a552 3
	RF_PhysDiskAddr_t *failedPDA =
	    (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;
	int i, retcode = 0;
d554 2
a555 3
	int suoffset, failedSUOffset =
	    rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char *srcbuf, *destbuf;
d565 3
a567 8
				suoffset = rf_StripeUnitOffset(layoutPtr,
				    pda->startSector);
				destbuf = ((char *) node->results[0]) +
				    rf_RaidAddressToByte(raidPtr,
				    suoffset - failedSUOffset);
				retcode = rf_bxor(srcbuf, destbuf,
				    rf_RaidAddressToByte(raidPtr,
				    pda->numSector), node->dagHdr->bp);
d575 3
a579 5
/*****************************************************************************
 * The next three functions are utilities used by the above xor-execution
 * functions.
 *****************************************************************************/

d581 5
a585 6
 * This is just a glorified buffer xor. Targbuf points to a buffer that is
 * one full stripe unit in size. srcbuf points to a buffer that may be less
 * than 1 SU, but never more. When the access described by pda is one SU in
 * size (which by implication means it's SU-aligned), all that happens is
 * (targbuf) <- (srcbuf ^ targbuf). When the access is less than one SU in
 * size the XOR occurs on only the portion of targbuf identified in the pda.
d588 12
a599 8
int
rf_XorIntoBuffer(RF_Raid_t *raidPtr, RF_PhysDiskAddr_t *pda, char *srcbuf,
    char *targbuf, void *bp)
{
	char *targptr;
	int sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	int SUOffset = pda->startSector % sectPerSU;
	int length, retcode = 0;
d608 1
a608 3

/*
 * It really should be the case that the buffer pointers (returned by malloc)
d610 1
a610 1
 * case we optimize for. The length should always be a multiple of the sector
d613 6
a618 2
int
rf_bxor(char *src, char *dest, int len, void *bp)
d622 2
a623 4
	if (!(((unsigned long) src) & mask) &&
	    !(((unsigned long) dest) & mask) && !(len & mask)) {
		retcode = rf_longword_bxor((unsigned long *) src,
		    (unsigned long *) dest, len >> RF_LONGSHIFT, bp);
d629 2
d632 5
a636 10
/* Map a user buffer into kernel space, if necessary. */
#define	REMAP_VA(_bp,x,y)	(y) = (x)

/*
 * When XORing in kernel mode, we need to map each user page to kernel
 * space before we can access it.
 * We don't want to assume anything about which input buffers are in
 * kernel/user space, nor about their alignment, so in each loop we
 * compute the maximum number of bytes that we can xor without crossing
 * any page boundaries, and do only this many bytes before the next remap.
d638 12
a649 7
int
rf_longword_bxor(unsigned long *src, unsigned long *dest, int len, void *bp)
{
	unsigned long *end = src + len; /* len in longwords. */
	unsigned long d0, d1, d2, d3, s0, s1, s2, s3; /* temps */
	unsigned long *pg_src, *pg_dest; /* Per-page source/dest pointers. */
	int longs_this_time; /* # longwords to xor in the current iteration. */
d657 1
a657 2
		longs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(pg_src),
		    RF_BLIP(pg_dest)) >> RF_LONGSHIFT);
d678 2
a679 2
		while (longs_this_time > 0) {
			/* Cannot cross any page boundaries here. */
d684 2
a685 4
		/*
		 * Either we're done, or we've reached a page boundary on one
		 * (or possibly both) of the pointers.
		 */
d711 12
a722 7
 * dst = a ^ b ^ c;
 * a may equal dst
 * see comment above longword_bxor
 */
int
rf_longword_bxor3(unsigned long *dst, unsigned long *a, unsigned long *b,
    unsigned long *c, int len, void *bp)
d725 4
a728 6
	/* Per-page source/dest pointers. */
	unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;
	int longs_this_time;	/* # longs to xor in the current iteration */
	char dst_is_a = 0;

	/* Note: The length (len) is in longwords. */
d740 1
a740 1
	/* Align dest to cache line. Can't cross a pg boundary on dst here. */
d766 1
a766 3
		longs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a),
		    RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >>
		    RF_LONGSHIFT);
d787 1
a787 1
			/* Start dual issue. */
d814 2
a815 2
		while (longs_this_time > 0) {
			/* Cannot cross any page boundaries here. */
d880 8
a887 3
int
rf_bxor3(unsigned char *dst, unsigned char *a, unsigned char *b,
    unsigned char *c, unsigned long len, void *bp)
d889 1
a889 2
	RF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7)
	    == 0);
d892 1
a892 2
		(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT,
		 bp));
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagfuncs.c,v 1.2 1999/02/16 00:02:32 niklas Exp $	*/
/*	$NetBSD: rf_dagfuncs.c,v 1.4 1999/03/14 21:53:31 oster Exp $	*/
a296 3
#if RF_BACKWARD > 0
	caddr_t undoBuf;
#endif
d304 1
a304 8
#if RF_BACKWARD > 0
	/* allocate and zero the undo buffer. this is equivalent to copying
	 * the original buffer's contents to the undo buffer prior to
	 * performing the disk read. XXX hardcoded 512 bytes per sector! */
	if (node->dagHdr->allocList == NULL)
		rf_MakeAllocList(node->dagHdr->allocList);
	RF_CallocAndAdd(undoBuf, 1, 512 * pda->numSector, (caddr_t), node->dagHdr->allocList);
#endif				/* RF_BACKWARD > 0 */
a338 3
#if RF_BACKWARD > 0
	caddr_t undoBuf;
#endif
a342 46
#if RF_BACKWARD > 0
	/* This area is used only for backward error recovery experiments
	 * First, schedule allocate a buffer and schedule a pre-read of the
	 * disk After the pre-read, proceed with the normal disk write */
	if (node->status == rf_bwd2) {
		/* just finished undo logging, now perform real function */
		node->status = rf_fired;
		RF_ASSERT(!(lock && unlock));
		flags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;
		flags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;
		req = rf_CreateDiskQueueData(iotype,
		    pda->startSector, pda->numSector, buf, parityStripeID, which_ru,
		    node->wakeFunc, (void *) node, NULL, node->dagHdr->tracerec,
		    (void *) (node->dagHdr->raidPtr), flags, b_proc);

		if (!req) {
			(node->wakeFunc) (node, ENOMEM);
		} else {
			node->dagFuncData = (void *) req;
			rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);
		}
	} else {
		/* node status should be rf_fired */
		/* schedule a disk pre-read */
		node->status = rf_bwd1;
		RF_ASSERT(!(lock && unlock));
		flags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;
		flags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;
		if (node->dagHdr->allocList == NULL)
			rf_MakeAllocList(node->dagHdr->allocList);
		RF_CallocAndAdd(undoBuf, 1, 512 * pda->numSector, (caddr_t), node->dagHdr->allocList);
		req = rf_CreateDiskQueueData(RF_IO_TYPE_READ,
		    pda->startSector, pda->numSector, undoBuf, parityStripeID, which_ru,
		    node->wakeFunc, (void *) node, NULL, node->dagHdr->tracerec,
		    (void *) (node->dagHdr->raidPtr), flags, b_proc);

		if (!req) {
			(node->wakeFunc) (node, ENOMEM);
		} else {
			node->dagFuncData = (void *) req;
			rf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);
		}
	}
	return (0);
#endif				/* RF_BACKWARD > 0 */

a492 4
#if RF_BACKWARD > 0
	RF_PhysDiskAddr_t *pda;
	caddr_t undoBuf;
#endif
a499 10
#if RF_BACKWARD > 0
				/* This section mimics undo logging for
				 * backward error recovery experiments b
				 * allocating and initializing a buffer XXX
				 * 512 byte sector size is hard coded! */
				pda = node->params[i].p;
				if (node->dagHdr->allocList == NULL)
					rf_MakeAllocList(node->dagHdr->allocList);
				RF_CallocAndAdd(undoBuf, 1, 512 * pda->numSector, (caddr_t), node->dagHdr->allocList);
#endif				/* RF_BACKWARD > 0 */
a519 4
#if RF_BACKWARD > 0
	RF_PhysDiskAddr_t *pda;
	caddr_t undoBuf;
#endif
a525 10
#if RF_BACKWARD > 0
				/* This section mimics undo logging for
				 * backward error recovery experiments b
				 * allocating and initializing a buffer XXX
				 * 512 byte sector size is hard coded! */
				pda = node->params[i].p;
				if (node->dagHdr->allocList == NULL)
					rf_MakeAllocList(node->dagHdr->allocList);
				RF_CallocAndAdd(undoBuf, 1, 512 * pda->numSector, (caddr_t), node->dagHdr->allocList);
#endif				/* RF_BACKWARD > 0 */
a557 3
#if RF_BACKWARD > 0
	caddr_t undoBuf;
#endif
a563 9
#if RF_BACKWARD > 0
				/* This section mimics undo logging for
				 * backward error recovery experiments b
				 * allocating and initializing a buffer XXX
				 * 512 byte sector size is hard coded! */
				if (node->dagHdr->allocList == NULL)
					rf_MakeAllocList(node->dagHdr->allocList);
				RF_CallocAndAdd(undoBuf, 1, 512 * pda->numSector, (caddr_t), node->dagHdr->allocList);
#endif				/* RF_BACKWARD > 0 */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagfuncs.c,v 1.1 1999/01/11 14:29:10 niklas Exp $	*/
/*	$NetBSD: rf_dagfuncs.c,v 1.3 1999/02/05 00:06:08 oster Exp $	*/
d510 3
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagfuncs.c,v 1.1 1998/11/13 04:20:28 oster Exp $	*/
/*	$NetBSD: rf_dagfuncs.c,v 1.1 1998/11/13 04:20:28 oster Exp $	*/
a50 166
/* :  
 * Log: rf_dagfuncs.c,v 
 * Revision 1.64  1996/07/31 16:29:26  jimz
 * LONGSHIFT -> RF_LONGSHIFT, defined in rf_types.h
 *
 * Revision 1.63  1996/07/30  04:00:20  jimz
 * define LONGSHIFT for mips
 *
 * Revision 1.62  1996/07/28  20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.61  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.60  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.59  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.58  1996/07/17  21:00:58  jimz
 * clean up timer interface, tracing
 *
 * Revision 1.57  1996/07/15  17:22:18  jimz
 * nit-pick code cleanup
 * resolve stdlib problems on DEC OSF
 *
 * Revision 1.56  1996/06/11  01:27:50  jimz
 * Fixed bug where diskthread shutdown would crash or hang. This
 * turned out to be two distinct bugs:
 * (1) [crash] The thread shutdown code wasn't properly waiting for
 * all the diskthreads to complete. This caused diskthreads that were
 * exiting+cleaning up to unlock a destroyed mutex.
 * (2) [hang] TerminateDiskQueues wasn't locking, and DiskIODequeue
 * only checked for termination _after_ a wakeup if the queues were
 * empty. This was a race where the termination wakeup could be lost
 * by the dequeueing thread, and the system would hang waiting for the
 * thread to exit, while the thread waited for an I/O or a signal to
 * check the termination flag.
 *
 * Revision 1.55  1996/06/10  22:23:18  wvcii
 * disk and xor funcs now optionally support undo logging
 * for backward error recovery experiments
 *
 * Revision 1.54  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.53  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.52  1996/06/06  17:28:44  jimz
 * add new read mirror partition func, rename old read mirror
 * to rf_DiskReadMirrorIdleFunc
 *
 * Revision 1.51  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.50  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.49  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.48  1996/05/30  12:59:18  jimz
 * make etimer happier, more portable
 *
 * Revision 1.47  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.46  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.45  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.44  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.43  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.42  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.41  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.40  1996/05/08  15:24:14  wvcii
 * modified GenericWakeupFunc to use recover, undone, and panic node states
 *
 * Revision 1.39  1996/05/02  17:18:01  jimz
 * fix up headers for user-land, following ccmn cleanup
 *
 * Revision 1.38  1996/05/01  16:26:51  jimz
 * don't include rf_ccmn.h (get ready to phase out)
 *
 * Revision 1.37  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.36  1995/12/04  19:19:09  wvcii
 * modified DiskReadMirrorFunc
 *  - added fifth parameter, physical disk address of mirror copy
 *  - SelectIdleDisk conditionally swaps parameters 0 & 4
 *
 * Revision 1.35  1995/12/01  15:58:33  root
 * added copyright info
 *
 * Revision 1.34  1995/11/17  18:12:17  amiri
 * Changed DiskReadMirrorFunc to use the generic mapping routines
 * to find the mirror of the data, function was assuming RAID level 1.
 *
 * Revision 1.33  1995/11/17  15:15:59  wvcii
 * changes in DiskReadMirrorFunc
 *   - added ASSERTs
 *   - added call to MapParityRAID1
 *
 * Revision 1.32  1995/11/07  16:25:50  wvcii
 * added DiskUnlockFuncForThreads
 * general debugging of undo functions (first time they were used)
 *
 * Revision 1.31  1995/09/06  19:23:36  wvcii
 * fixed tracing for parity logging nodes
 *
 * Revision 1.30  95/07/07  00:13:01  wvcii
 * added 4th parameter to ParityLogAppend
 * 
 */

#ifdef _KERNEL
#define KERNEL
#endif

#ifndef KERNEL
#include <errno.h>
#endif /* !KERNEL */

a65 1
#ifdef KERNEL
a66 1
#endif /* KERNEL */
d70 1
a70 1
#endif /* RF_INCLUDE_PARITYLOGGING > 0 */
d72 9
a80 9
int (*rf_DiskReadFunc)(RF_DagNode_t *);
int (*rf_DiskWriteFunc)(RF_DagNode_t *);
int (*rf_DiskReadUndoFunc)(RF_DagNode_t *);
int (*rf_DiskWriteUndoFunc)(RF_DagNode_t *);
int (*rf_DiskUnlockFunc)(RF_DagNode_t *);
int (*rf_DiskUnlockUndoFunc)(RF_DagNode_t *);
int (*rf_RegularXorUndoFunc)(RF_DagNode_t *);
int (*rf_SimpleXorUndoFunc)(RF_DagNode_t *);
int (*rf_RecoveryXorUndoFunc)(RF_DagNode_t *);
d85 15
a99 14
int rf_ConfigureDAGFuncs(listp)
  RF_ShutdownList_t  **listp;
{
  RF_ASSERT( ((sizeof(long)==8) && RF_LONGSHIFT==3) || ((sizeof(long)==4)  && RF_LONGSHIFT==2) );
  rf_DiskReadFunc  = rf_DiskReadFuncForThreads;
  rf_DiskReadUndoFunc = rf_DiskUndoFunc;
  rf_DiskWriteFunc = rf_DiskWriteFuncForThreads;
  rf_DiskWriteUndoFunc = rf_DiskUndoFunc;
  rf_DiskUnlockFunc = rf_DiskUnlockFuncForThreads;
  rf_DiskUnlockUndoFunc = rf_NullNodeUndoFunc;
  rf_RegularXorUndoFunc = rf_NullNodeUndoFunc;
  rf_SimpleXorUndoFunc = rf_NullNodeUndoFunc;
  rf_RecoveryXorUndoFunc = rf_NullNodeUndoFunc;
  return(0);
d107 3
a109 2
int rf_TerminateFunc(node)
  RF_DagNode_t  *node;
d111 3
a113 3
  RF_ASSERT(node->dagHdr->numCommits == node->dagHdr->numCommitNodes);
  node->status = rf_good;
  return(rf_FinishNode(node, RF_THREAD_CONTEXT));
d116 3
a118 2
int rf_TerminateUndoFunc(node)
  RF_DagNode_t  *node;
d120 1
a120 1
  return(0);
d137 3
a139 2
int rf_DiskReadMirrorIdleFunc(node)
  RF_DagNode_t  *node;
d141 2
a142 2
  /* select the mirror copy with the shortest queue and fill in node parameters
     with physical disk address */
d144 2
a145 2
  rf_SelectMirrorDiskIdle(node);
  return(rf_DiskReadFunc(node));
d148 3
a150 2
int rf_DiskReadMirrorPartitionFunc(node)
  RF_DagNode_t  *node;
d152 2
a153 2
  /* select the mirror copy with the shortest queue and fill in node parameters
     with physical disk address */
d155 2
a156 2
  rf_SelectMirrorDiskPartition(node);
  return(rf_DiskReadFunc(node));
d159 3
a161 2
int rf_DiskReadMirrorUndoFunc(node)
  RF_DagNode_t  *node;
d163 1
a163 1
  return(0);
d172 24
a195 22
int rf_ParityLogUpdateFunc(node)
  RF_DagNode_t  *node;
{
  RF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;
  caddr_t buf = (caddr_t) node->params[1].p;
  RF_ParityLogData_t *logData;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;

  if (node->dagHdr->status == rf_enable)
    {
      RF_ETIMER_START(timer);
      logData = rf_CreateParityLogData(RF_UPDATE, pda, buf, 
				       (RF_Raid_t *) (node->dagHdr->raidPtr),
				       node->wakeFunc, (void *) node, 
				       node->dagHdr->tracerec, timer);
      if (logData)
	rf_ParityLogAppend(logData, RF_FALSE, NULL, RF_FALSE);
      else
	{
	  RF_ETIMER_STOP(timer); RF_ETIMER_EVAL(timer); tracerec->plog_us += RF_ETIMER_VAL_US(timer);
	  (node->wakeFunc)(node, ENOMEM);
d197 1
a197 2
    }
    return(0);
d204 22
a225 20
int rf_ParityLogOverwriteFunc(node)
  RF_DagNode_t  *node;
{
  RF_PhysDiskAddr_t  *pda = (RF_PhysDiskAddr_t *) node->params[0].p;
  caddr_t buf = (caddr_t) node->params[1].p;
  RF_ParityLogData_t *logData;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;

  if (node->dagHdr->status == rf_enable)
    {
      RF_ETIMER_START(timer);
      logData = rf_CreateParityLogData(RF_OVERWRITE, pda, buf, (RF_Raid_t *) (node->dagHdr->raidPtr),
				    node->wakeFunc, (void *) node, node->dagHdr->tracerec, timer);
      if (logData)
	rf_ParityLogAppend(logData, RF_FALSE, NULL, RF_FALSE);
      else
	{
	  RF_ETIMER_STOP(timer); RF_ETIMER_EVAL(timer); tracerec->plog_us += RF_ETIMER_VAL_US(timer);
	  (node->wakeFunc)(node, ENOMEM);
d227 1
a227 2
    }
    return(0);
d229 1
d231 3
a233 4
#else /* RF_INCLUDE_PARITYLOGGING > 0 */

int rf_ParityLogUpdateFunc(node)
  RF_DagNode_t  *node;
d235 1
a235 1
  return(0);
d237 3
a239 2
int rf_ParityLogOverwriteFunc(node)
  RF_DagNode_t  *node;
d241 1
a241 1
  return(0);
d243 1
d245 3
a247 4
#endif /* RF_INCLUDE_PARITYLOGGING > 0 */

int rf_ParityLogUpdateUndoFunc(node)
  RF_DagNode_t  *node;
d249 1
a249 1
  return(0);
d252 3
a254 2
int rf_ParityLogOverwriteUndoFunc(node)
  RF_DagNode_t  *node;
d256 1
a256 1
  return(0);
a257 1

d261 3
a263 2
int rf_NullNodeFunc(node)
  RF_DagNode_t  *node;
d265 2
a266 2
  node->status = rf_good;
  return(rf_FinishNode(node, RF_THREAD_CONTEXT));
d269 3
a271 2
int rf_NullNodeUndoFunc(node)
  RF_DagNode_t  *node;
d273 2
a274 2
  node->status = rf_undone;
  return(rf_FinishNode(node, RF_THREAD_CONTEXT));
d281 16
a296 15
int rf_DiskReadFuncForThreads(node)
  RF_DagNode_t  *node;
{
  RF_DiskQueueData_t *req;
  RF_PhysDiskAddr_t  *pda       = (RF_PhysDiskAddr_t *)node->params[0].p;
  caddr_t        buf            = (caddr_t)node->params[1].p;
  RF_StripeNum_t parityStripeID = (RF_StripeNum_t)node->params[2].v;
  unsigned       priority       = RF_EXTRACT_PRIORITY(node->params[3].v);
  unsigned       lock           = RF_EXTRACT_LOCK_FLAG(node->params[3].v);
  unsigned       unlock         = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);
  unsigned       which_ru       = RF_EXTRACT_RU(node->params[3].v);
  RF_DiskQueueDataFlags_t flags = 0;
  RF_IoType_t    iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_READ : RF_IO_TYPE_NOP;
  RF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;
  void *b_proc = NULL;
d298 1
a298 1
  caddr_t        undoBuf;
d301 6
a306 7
#ifdef KERNEL
  if (node->dagHdr->bp) b_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;
#endif /* KERNEL */

  RF_ASSERT( !(lock && unlock) );
  flags |= (lock)   ? RF_LOCK_DISK_QUEUE   : 0;
  flags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;
d308 19
a326 21
  /* allocate and zero the undo buffer.
   * this is equivalent to copying the original buffer's contents to the undo buffer
   * prior to performing the disk read.
   * XXX hardcoded 512 bytes per sector!
   */
  if (node->dagHdr->allocList == NULL)
    rf_MakeAllocList(node->dagHdr->allocList);
  RF_CallocAndAdd(undoBuf, 1, 512 * pda->numSector, (caddr_t), node->dagHdr->allocList);
#endif /* RF_BACKWARD > 0 */
  req = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector, 
			       buf, parityStripeID, which_ru, 
			       (int (*)(void *,int)) node->wakeFunc,  
			       node, NULL, node->dagHdr->tracerec,
			    (void *)(node->dagHdr->raidPtr), flags, b_proc);
  if (!req) {
    (node->wakeFunc)(node, ENOMEM);
  } else {
    node->dagFuncData = (void *) req;
    rf_DiskIOEnqueue( &(dqs[pda->row][pda->col]), req, priority );
  }
  return(0);
d333 16
a348 15
int rf_DiskWriteFuncForThreads(node)
  RF_DagNode_t  *node;
{
  RF_DiskQueueData_t *req;
  RF_PhysDiskAddr_t  *pda       = (RF_PhysDiskAddr_t *)node->params[0].p;
  caddr_t        buf            = (caddr_t)node->params[1].p;
  RF_StripeNum_t parityStripeID = (RF_StripeNum_t)node->params[2].v;
  unsigned       priority       = RF_EXTRACT_PRIORITY(node->params[3].v);
  unsigned       lock           = RF_EXTRACT_LOCK_FLAG(node->params[3].v);
  unsigned       unlock         = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);
  unsigned       which_ru       = RF_EXTRACT_RU(node->params[3].v);
  RF_DiskQueueDataFlags_t flags = 0;
  RF_IoType_t    iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_WRITE : RF_IO_TYPE_NOP;
  RF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;
  void *b_proc = NULL;
d350 1
a350 1
  caddr_t undoBuf;
d353 2
a354 3
#ifdef KERNEL
  if (node->dagHdr->bp) b_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;
#endif /* KERNEL */
d357 44
a400 66
  /* This area is used only for backward error recovery experiments
   * First, schedule allocate a buffer and schedule a pre-read of the disk
   * After the pre-read, proceed with the normal disk write
   */
  if (node->status == rf_bwd2) {
    /* just finished undo logging, now perform real function */
    node->status = rf_fired;
    RF_ASSERT( !(lock && unlock) );
    flags |= (lock)   ? RF_LOCK_DISK_QUEUE   : 0;
    flags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;
    req = rf_CreateDiskQueueData(iotype, 
			      pda->startSector, pda->numSector, buf, parityStripeID, which_ru,
			      node->wakeFunc, (void *) node, NULL, node->dagHdr->tracerec,
			      (void *) (node->dagHdr->raidPtr), flags, b_proc);
    
    if (!req) {
      (node->wakeFunc)(node, ENOMEM);
    } else {
      node->dagFuncData = (void *) req;
      rf_DiskIOEnqueue( &(dqs[pda->row][pda->col]), req, priority );
    }
  }

  else {
    /* node status should be rf_fired */
    /* schedule a disk pre-read */
    node->status = rf_bwd1;
    RF_ASSERT( !(lock && unlock) );
    flags |= (lock)   ? RF_LOCK_DISK_QUEUE   : 0;
    flags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;
    if (node->dagHdr->allocList == NULL)
      rf_MakeAllocList(node->dagHdr->allocList);
    RF_CallocAndAdd(undoBuf, 1, 512 * pda->numSector, (caddr_t), node->dagHdr->allocList);
    req = rf_CreateDiskQueueData(RF_IO_TYPE_READ, 
			      pda->startSector, pda->numSector, undoBuf, parityStripeID, which_ru,
			      node->wakeFunc, (void *) node, NULL, node->dagHdr->tracerec,
			      (void *) (node->dagHdr->raidPtr), flags, b_proc);
    
    if (!req) {
      (node->wakeFunc)(node, ENOMEM);
    } else {
      node->dagFuncData = (void *) req;
      rf_DiskIOEnqueue( &(dqs[pda->row][pda->col]), req, priority );
    }
  }
  return(0);
#endif /* RF_BACKWARD > 0 */

  /* normal processing (rollaway or forward recovery) begins here */
  RF_ASSERT( !(lock && unlock) );
  flags |= (lock)   ? RF_LOCK_DISK_QUEUE   : 0;
  flags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;
  req = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector, 
			       buf, parityStripeID, which_ru,
			       (int (*)(void *,int)) node->wakeFunc, 
			       (void *) node, NULL,
			       node->dagHdr->tracerec,
			       (void *) (node->dagHdr->raidPtr), 
			       flags, b_proc);

  if (!req) {
    (node->wakeFunc)(node, ENOMEM);
  } else {
    node->dagFuncData = (void *) req;
    rf_DiskIOEnqueue( &(dqs[pda->row][pda->col]), req, priority );
  }
d402 20
a421 1
  return(0);
a422 1

d428 21
a448 20
int rf_DiskUndoFunc(node)
  RF_DagNode_t  *node;
{
  RF_DiskQueueData_t *req;
  RF_PhysDiskAddr_t  *pda = (RF_PhysDiskAddr_t *)node->params[0].p;
  RF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;

  req = rf_CreateDiskQueueData(RF_IO_TYPE_NOP,
			       0L, 0, NULL, 0L, 0,
			       (int (*)(void *,int)) node->wakeFunc, 
			       (void *) node, 
			       NULL, node->dagHdr->tracerec,
			       (void *) (node->dagHdr->raidPtr), 
			       RF_UNLOCK_DISK_QUEUE, NULL);
  if (!req)
    (node->wakeFunc)(node, ENOMEM);
  else {
    node->dagFuncData = (void *) req;
    rf_DiskIOEnqueue( &(dqs[pda->row][pda->col]), req, RF_IO_NORMAL_PRIORITY );
  }
d450 1
a450 1
  return(0);
a451 1

d455 21
a475 20
int rf_DiskUnlockFuncForThreads(node)
  RF_DagNode_t  *node;
{
  RF_DiskQueueData_t *req;
  RF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *)node->params[0].p;
  RF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;

  req = rf_CreateDiskQueueData(RF_IO_TYPE_NOP,
			       0L, 0, NULL, 0L, 0,
			       (int (*)(void *,int)) node->wakeFunc, 
			       (void *) node, 
			       NULL, node->dagHdr->tracerec,
			       (void *) (node->dagHdr->raidPtr), 
			       RF_UNLOCK_DISK_QUEUE, NULL);
  if (!req)
    (node->wakeFunc)(node, ENOMEM);
  else {
    node->dagFuncData = (void *) req;
    rf_DiskIOEnqueue( &(dqs[pda->row][pda->col]), req, RF_IO_NORMAL_PRIORITY );
  }
d477 1
a477 1
  return(0);
a478 1

d484 32
a515 27
int rf_GenericWakeupFunc(node, status)
  RF_DagNode_t  *node;
  int            status;
{
  switch (node->status) {
  case rf_bwd1 :
    node->status = rf_bwd2;
    if (node->dagFuncData)
      rf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);
    return(rf_DiskWriteFuncForThreads(node));
    break;
  case rf_fired :
    if (status) node->status = rf_bad;
    else node->status = rf_good;
    break;
  case rf_recover :
    /* probably should never reach this case */
    if (status) node->status = rf_panic;
    else node->status = rf_undone;
    break;
  default :
    RF_PANIC();
    break;
  }
  if (node->dagFuncData)
    rf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);
  return(rf_FinishNode(node, RF_INTR_CONTEXT));
d541 8
a548 7
int rf_RegularXorFunc(node)
  RF_DagNode_t  *node;
{
  RF_Raid_t *raidPtr = (RF_Raid_t *)node->params[node->numParams-1].p;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;
  int i, retcode;
d550 2
a551 2
  RF_PhysDiskAddr_t *pda;
  caddr_t undoBuf;
d554 6
a559 5
  retcode = 0;
  if (node->dagHdr->status == rf_enable) {
    /* don't do the XOR if the input is the same as the output */
    RF_ETIMER_START(timer);
    for (i=0; i<node->numParams-1; i+=2) if (node->params[i+1].p != node->results[0]) {
d561 19
a579 15
      /* This section mimics undo logging for backward error recovery experiments b
       * allocating and initializing a buffer
       * XXX 512 byte sector size is hard coded!
       */
      pda = node->params[i].p;
      if (node->dagHdr->allocList == NULL)
	rf_MakeAllocList(node->dagHdr->allocList);
      RF_CallocAndAdd(undoBuf, 1, 512 * pda->numSector, (caddr_t), node->dagHdr->allocList);
#endif /* RF_BACKWARD > 0 */
      retcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,
			      (char *)node->params[i+1].p, (char *) node->results[0], node->dagHdr->bp);
    }
    RF_ETIMER_STOP(timer); RF_ETIMER_EVAL(timer); tracerec->xor_us += RF_ETIMER_VAL_US(timer);
  }
  return(rf_GenericWakeupFunc(node, retcode));     /* call wake func explicitly since no I/O in this node */
a580 1

d582 8
a589 7
int rf_SimpleXorFunc(node)
  RF_DagNode_t  *node;
{
  RF_Raid_t *raidPtr = (RF_Raid_t *)node->params[node->numParams-1].p;
  int i, retcode = 0;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;
d591 2
a592 2
  RF_PhysDiskAddr_t *pda;
  caddr_t undoBuf;
d595 5
a599 4
  if (node->dagHdr->status == rf_enable) {
    RF_ETIMER_START(timer);
    /* don't do the XOR if the input is the same as the output */
    for (i=0; i<node->numParams-1; i+=2) if (node->params[i+1].p != node->results[0]) {
d601 20
a620 17
      /* This section mimics undo logging for backward error recovery experiments b
       * allocating and initializing a buffer
       * XXX 512 byte sector size is hard coded!
       */
      pda = node->params[i].p;
      if (node->dagHdr->allocList == NULL)
	rf_MakeAllocList(node->dagHdr->allocList);
      RF_CallocAndAdd(undoBuf, 1, 512 * pda->numSector, (caddr_t), node->dagHdr->allocList);
#endif /* RF_BACKWARD > 0 */
      retcode = rf_bxor((char *)node->params[i+1].p, (char *) node->results[0], 
		     rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *)node->params[i].p)->numSector),
		     (struct buf *) node->dagHdr->bp);
    }
    RF_ETIMER_STOP(timer); RF_ETIMER_EVAL(timer); tracerec->xor_us += RF_ETIMER_VAL_US(timer);
  }

  return(rf_GenericWakeupFunc(node, retcode));     /* call wake func explicitly since no I/O in this node */
a621 1

d629 13
a641 12
int rf_RecoveryXorFunc(node)
  RF_DagNode_t  *node;
{
  RF_Raid_t *raidPtr = (RF_Raid_t *)node->params[node->numParams-1].p;
  RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &raidPtr->Layout;
  RF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *)node->params[node->numParams-2].p;
  int i, retcode = 0;
  RF_PhysDiskAddr_t *pda;
  int suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr,failedPDA->startSector);
  char *srcbuf, *destbuf;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;
d643 1
a643 1
  caddr_t undoBuf;
d646 5
a650 4
  if (node->dagHdr->status == rf_enable) {
    RF_ETIMER_START(timer);
    for (i=0; i<node->numParams-2; i+=2) if (node->params[i+1].p != node->results[0]) {
      pda = (RF_PhysDiskAddr_t *)node->params[i].p;
d652 18
a669 16
      /* This section mimics undo logging for backward error recovery experiments b
       * allocating and initializing a buffer
       * XXX 512 byte sector size is hard coded!
       */
      if (node->dagHdr->allocList == NULL)
	rf_MakeAllocList(node->dagHdr->allocList);
      RF_CallocAndAdd(undoBuf, 1, 512 * pda->numSector, (caddr_t), node->dagHdr->allocList);
#endif /* RF_BACKWARD > 0 */
      srcbuf = (char *)node->params[i+1].p;
      suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
      destbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr,suoffset-failedSUOffset);
      retcode = rf_bxor(srcbuf, destbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), node->dagHdr->bp);
    }
    RF_ETIMER_STOP(timer); RF_ETIMER_EVAL(timer); tracerec->xor_us += RF_ETIMER_VAL_US(timer);
  }
  return (rf_GenericWakeupFunc(node, retcode));
a670 1

d684 19
a702 18
int rf_XorIntoBuffer(raidPtr, pda, srcbuf, targbuf, bp)
  RF_Raid_t          *raidPtr;
  RF_PhysDiskAddr_t  *pda;
  char               *srcbuf;
  char               *targbuf;
  void               *bp;
{
  char *targptr;
  int sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;
  int SUOffset = pda->startSector % sectPerSU;
  int length, retcode = 0;

  RF_ASSERT(pda->numSector <= sectPerSU);
  
  targptr = targbuf + rf_RaidAddressToByte(raidPtr, SUOffset);
  length  = rf_RaidAddressToByte(raidPtr, pda->numSector);
  retcode = rf_bxor(srcbuf, targptr, length, bp);
  return(retcode);
a703 1

d709 15
a723 14
int rf_bxor(src, dest, len, bp)
  char  *src;
  char  *dest;
  int    len;
  void  *bp;
{
  unsigned mask = sizeof(long) -1, retcode = 0;
  
  if ( !(((unsigned long) src) & mask) && !(((unsigned long) dest) & mask) && !(len&mask) ) {
    retcode = rf_longword_bxor((unsigned long *) src, (unsigned long *) dest, len>>RF_LONGSHIFT, bp);
  } else {
    RF_ASSERT(0);
  }
  return(retcode);
a724 1

a725 8
#ifdef KERNEL
#if defined(__NetBSD__) || defined(__OpenBSD__)
/* XXX Not a clue if this is even close.. */
#define REMAP_VA(_bp,x,y) (y) = (x)
#else
#define REMAP_VA(_bp,x,y) (y) = (unsigned long *) ((IS_SYS_VA(x)) ? (unsigned long *)(x) : (unsigned long *) rf_MapToKernelSpace((struct buf *) (_bp), (caddr_t)(x)))
#endif /* __NetBSD__ || __OpenBSD__ */
#else /* KERNEL */
a726 1
#endif /* KERNEL */
d734 69
a802 55
int rf_longword_bxor(src, dest, len, bp)
  register unsigned long  *src;
  register unsigned long  *dest;
  int                      len; /* longwords */
  void                    *bp;
{
  register unsigned long *end = src+len;
  register unsigned long d0, d1, d2, d3, s0, s1, s2, s3;   /* temps */
  register unsigned long *pg_src, *pg_dest;                /* per-page source/dest pointers */
  int longs_this_time;                                     /* # longwords to xor in the current iteration */

  REMAP_VA(bp, src, pg_src);
  REMAP_VA(bp, dest, pg_dest);
  if (!pg_src || !pg_dest) return(EFAULT);
  
  while (len >= 4 ) {
    longs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(pg_src), RF_BLIP(pg_dest)) >> RF_LONGSHIFT);  /* note len in longwords */
    src += longs_this_time; dest+= longs_this_time; len -= longs_this_time;
    while (longs_this_time >= 4) {
      d0 = pg_dest[0];
      d1 = pg_dest[1];
      d2 = pg_dest[2];
      d3 = pg_dest[3];
      s0 = pg_src[0];
      s1 = pg_src[1];
      s2 = pg_src[2];
      s3 = pg_src[3];
      pg_dest[0] = d0 ^ s0;
      pg_dest[1] = d1 ^ s1;
      pg_dest[2] = d2 ^ s2;
      pg_dest[3] = d3 ^ s3;
      pg_src += 4;
      pg_dest += 4;
      longs_this_time -= 4;
    }
    while (longs_this_time > 0) {   /* cannot cross any page boundaries here */
      *pg_dest++ ^= *pg_src++;
      longs_this_time--;
    }
    
    /* either we're done, or we've reached a page boundary on one (or possibly both) of the pointers */
    if (len) {
      if (RF_PAGE_ALIGNED(src))  REMAP_VA(bp, src, pg_src);
      if (RF_PAGE_ALIGNED(dest)) REMAP_VA(bp, dest, pg_dest);
      if (!pg_src || !pg_dest) return(EFAULT);
    }
  }
  while (src < end) {
    *pg_dest++ ^=  *pg_src++;
    src++; dest++; len--;
    if (RF_PAGE_ALIGNED(src)) REMAP_VA(bp, src, pg_src);
    if (RF_PAGE_ALIGNED(dest)) REMAP_VA(bp, dest, pg_dest);
  }
  RF_ASSERT(len == 0);
  return(0);
d811 173
a983 93
int rf_longword_bxor3(dst,a,b,c,len, bp)
  register unsigned long  *dst;
  register unsigned long  *a;
  register unsigned long  *b;
  register unsigned long  *c;
  int                      len; /* length in longwords */
  void                    *bp;
{
  unsigned long a0,a1,a2,a3, b0,b1,b2,b3;
  register unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;    /* per-page source/dest pointers */
  int longs_this_time;                                     /* # longs to xor in the current iteration */
  char dst_is_a = 0;

  REMAP_VA(bp, a, pg_a);
  REMAP_VA(bp, b, pg_b);
  REMAP_VA(bp, c, pg_c);
  if (a == dst) {pg_dst = pg_a; dst_is_a = 1;} else { REMAP_VA(bp, dst, pg_dst); }
  
  /* align dest to cache line.  Can't cross a pg boundary on dst here. */
  while ((((unsigned long) pg_dst) & 0x1f)) {
    *pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;
    dst++; a++; b++; c++;
    if (RF_PAGE_ALIGNED(a)) {REMAP_VA(bp, a, pg_a); if (!pg_a) return(EFAULT);}
    if (RF_PAGE_ALIGNED(b)) {REMAP_VA(bp, a, pg_b); if (!pg_b) return(EFAULT);}
    if (RF_PAGE_ALIGNED(c)) {REMAP_VA(bp, a, pg_c); if (!pg_c) return(EFAULT);}
    len--;
  }
  
  while (len > 4 ) {
    longs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a), RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >> RF_LONGSHIFT);
    a+= longs_this_time; b+= longs_this_time; c+= longs_this_time; dst+=longs_this_time; len-=longs_this_time;
    while (longs_this_time >= 4) {
      a0 = pg_a[0]; longs_this_time -= 4;
      
      a1 = pg_a[1];
      a2 = pg_a[2];
      
      a3 = pg_a[3];  pg_a += 4;
      
      b0 = pg_b[0];
      b1 = pg_b[1];
      
      b2 = pg_b[2];
      b3 = pg_b[3];
      /* start dual issue */
      a0 ^= b0; b0 =  pg_c[0];
      
      pg_b += 4;  a1 ^= b1;
      
      a2 ^= b2; a3 ^= b3;
      
      b1 =  pg_c[1]; a0 ^= b0;
      
      b2 =  pg_c[2]; a1 ^= b1;
      
      b3 =  pg_c[3]; a2 ^= b2;
      
      pg_dst[0] = a0; a3 ^= b3;
      pg_dst[1] = a1; pg_c += 4;
      pg_dst[2] = a2;
      pg_dst[3] = a3; pg_dst += 4;
    }
    while (longs_this_time > 0) {   /* cannot cross any page boundaries here */
      *pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;
      longs_this_time--;
    }
    
    if (len) {
      if (RF_PAGE_ALIGNED(a)) {REMAP_VA(bp, a, pg_a); if (!pg_a) return(EFAULT); if (dst_is_a) pg_dst = pg_a;}
      if (RF_PAGE_ALIGNED(b)) {REMAP_VA(bp, b, pg_b); if (!pg_b) return(EFAULT);}
      if (RF_PAGE_ALIGNED(c)) {REMAP_VA(bp, c, pg_c); if (!pg_c) return(EFAULT);}
      if (!dst_is_a) if (RF_PAGE_ALIGNED(dst)) {REMAP_VA(bp, dst, pg_dst); if (!pg_dst) return(EFAULT);}
    }
  }
  while (len) {
    *pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;
    dst++; a++; b++; c++;
    if (RF_PAGE_ALIGNED(a)) {REMAP_VA(bp, a, pg_a); if (!pg_a) return(EFAULT); if (dst_is_a) pg_dst = pg_a;}
    if (RF_PAGE_ALIGNED(b)) {REMAP_VA(bp, b, pg_b); if (!pg_b) return(EFAULT);}
    if (RF_PAGE_ALIGNED(c)) {REMAP_VA(bp, c, pg_c); if (!pg_c) return(EFAULT);}
    if (!dst_is_a) if (RF_PAGE_ALIGNED(dst)) {REMAP_VA(bp, dst, pg_dst); if (!pg_dst) return(EFAULT);}
    len--;
  }
  return(0);
}

int rf_bxor3(dst,a,b,c,len, bp)
  register unsigned char  *dst;
  register unsigned char  *a;
  register unsigned char  *b;
  register unsigned char  *c;
  unsigned long            len;
  void                    *bp;
d985 1
a985 1
	RF_ASSERT(((RF_UL(dst)|RF_UL(a)|RF_UL(b)|RF_UL(c)|len) & 0x7) == 0);
d987 2
a988 2
	return(rf_longword_bxor3((unsigned long *)dst, (unsigned long *)a,
		(unsigned long *)b, (unsigned long *)c, len>>RF_LONGSHIFT, bp));
@

