head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.38
	OPENBSD_5_0:1.6.0.36
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.34
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.32
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.28
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.30
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.26
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.24
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.22
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.20
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.16
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.14
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.12
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.10
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.8
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.6;

1.6
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.5.2.1
	1.5.12.1;
next	1.4;

1.4
date	2000.01.07.14.50.22;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.08.04.13.10.55;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.09;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.38;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.5.12.1
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_pq.c,v 1.6 2002/12/16 07:01:04 tdeval Exp $	*/
/*	$NetBSD: rf_pq.c,v 1.7 2000/01/07 03:41:02 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Daniel Stodolsky
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * Code for RAID level 6 (P + Q) disk array architecture.
 */

#include "rf_archs.h"
#include "rf_types.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagffrd.h"
#include "rf_dagffwr.h"
#include "rf_dagdegrd.h"
#include "rf_dagdegwr.h"
#include "rf_dagutils.h"
#include "rf_dagfuncs.h"
#include "rf_etimer.h"
#include "rf_pqdeg.h"
#include "rf_general.h"
#include "rf_map.h"
#include "rf_pq.h"

RF_RedFuncs_t rf_pFuncs = {
	rf_RegularONPFunc, "Regular Old-New P",
	rf_SimpleONPFunc, "Simple Old-New P"
};
RF_RedFuncs_t rf_pRecoveryFuncs = {
	rf_RecoveryPFunc, "Recovery P Func",
	rf_RecoveryPFunc, "Recovery P Func"
};

int
rf_RegularONPFunc(RF_DagNode_t *node)
{
	return (rf_RegularXorFunc(node));
}


/*
 * Same as simpleONQ func, but the coefficient is always 1.
 */

int
rf_SimpleONPFunc(RF_DagNode_t *node)
{
	return (rf_SimpleXorFunc(node));
}

int
rf_RecoveryPFunc(RF_DagNode_t *node)
{
	return (rf_RecoveryXorFunc(node));
}

int
rf_RegularPFunc(RF_DagNode_t *node)
{
	return (rf_RegularXorFunc(node));
}


#if	(RF_INCLUDE_DECL_PQ > 0) || (RF_INCLUDE_RAID6 > 0)

void rf_QDelta(char *dest, char *obuf, char *nbuf, unsigned length,
	unsigned char coeff);
void rf_InvertQ(unsigned long *qbuf, unsigned long *abuf, unsigned length,
	unsigned coeff);

RF_RedFuncs_t rf_qFuncs = {
	rf_RegularONQFunc, "Regular Old-New Q",
	rf_SimpleONQFunc, "Simple Old-New Q"
};
RF_RedFuncs_t rf_qRecoveryFuncs = {
	rf_RecoveryQFunc, "Recovery Q Func",
	rf_RecoveryQFunc, "Recovery Q Func"
};
RF_RedFuncs_t rf_pqRecoveryFuncs = {
	rf_RecoveryPQFunc, "Recovery PQ Func",
	rf_RecoveryPQFunc, "Recovery PQ Func"
};

void
rf_PQDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmap, RF_VoidFuncPtr *createFunc)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
	unsigned ndfail = asmap->numDataFailed;
	unsigned npfail = asmap->numParityFailed;
	unsigned ntfail = npfail + ndfail;

	RF_ASSERT(RF_IO_IS_R_OR_W(type));
	if (ntfail > 2) {
		RF_ERRORMSG("more than two disks failed in a single group !"
		            "  Aborting I/O operation.\n");
		 /* *infoFunc = */ *createFunc = NULL;
		return;
	}
	/* Ok, we can do this I/O. */
	if (type == RF_IO_TYPE_READ) {
		switch (ndfail) {
		case 0:
			/* Fault free read. */
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateFaultFreeReadDAG;	/* Same as raid 5. */
			break;
		case 1:
			/* Lost a single data unit. */
			/*
			 * Two cases:
			 * (1) Parity is not lost. Do a normal raid 5
			 *     reconstruct read.
			 * (2) Parity is lost. Do a reconstruct read using "q".
			 */
			if (ntfail == 2) {	/* Also lost redundancy. */
				if (asmap->failedPDAs[1]->type ==
				    RF_PDA_TYPE_PARITY)
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_110_CreateReadDAG;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_101_CreateReadDAG;
			} else {
				/*
				 * P and Q are ok. But is there a failure in
				 * some unaccessed data unit ?
				 */
				if (rf_NumFailedDataUnitsInStripe(raidPtr,
				    asmap) == 2)
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_200_CreateReadDAG;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_100_CreateReadDAG;
			}
			break;
		case 2:
			/* Lost two data units. */
			/* *infoFunc = rf_PQOneTwo; */
			*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateReadDAG;
			break;
		}
		return;
	}
	/* A write. */
	switch (ntfail) {
	case 0:		/* Fault free. */
		if (rf_suppressLocksAndLargeWrites ||
		    (((asmap->numStripeUnitsAccessed <=
		       (layoutPtr->numDataCol / 2)) &&
		      (layoutPtr->numDataCol != 1)) ||
		     (asmap->parityInfo->next != NULL) ||
		     (asmap->qInfo->next != NULL) ||
		     rf_CheckStripeForFailures(raidPtr, asmap))) {

			*createFunc = (RF_VoidFuncPtr) rf_PQCreateSmallWriteDAG;
		} else {
			*createFunc = (RF_VoidFuncPtr) rf_PQCreateLargeWriteDAG;
		}
		break;

	case 1:		/* Single disk fault. */
		if (npfail == 1) {
			RF_ASSERT((asmap->failedPDAs[0]->type ==
			    RF_PDA_TYPE_PARITY) ||
			    (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));
			if (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {
				/*
				 * Q died, treat like normal mode raid5 write.
				 */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_001_CreateSmallWriteDAG;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_001_CreateLargeWriteDAG;
			} else {/* Parity died, small write only updating Q. */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_010_CreateSmallWriteDAG;
				else
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_010_CreateLargeWriteDAG;
			}
		} else {	/*
				 * Data missing. Do a P reconstruct write if
				 * only a single data unit is lost in the
				 * stripe, otherwise a PQ reconstruct write.
				 */
			if (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_200_CreateWriteDAG;
			else
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_100_CreateWriteDAG;
		}
		break;

	case 2:		/* Two disk faults. */
		switch (npfail) {
		case 2:	/* Both p and q dead. */
			*createFunc = (RF_VoidFuncPtr) rf_PQ_011_CreateWriteDAG;
			break;
		case 1:	/* Either p or q and dead data. */
			RF_ASSERT(asmap->failedPDAs[0]->type ==
			          RF_PDA_TYPE_DATA);
			RF_ASSERT((asmap->failedPDAs[1]->type ==
			           RF_PDA_TYPE_PARITY) ||
			          (asmap->failedPDAs[1]->type ==
			           RF_PDA_TYPE_Q));
			if (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q)
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_101_CreateWriteDAG;
			else
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_110_CreateWriteDAG;
			break;
		case 0:	/* Double data loss. */
			*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateWriteDAG;
			break;
		}
		break;

	default:	/* More than 2 disk faults. */
		*createFunc = NULL;
		RF_PANIC();
	}
	return;
}


/*
 * Used as a stop gap info function.
 */
#if 0
void
rf_PQOne(RF_Raid_t *raidPtr, int *nSucc, int *nAnte,
    RF_AccessStripeMap_t *asmap)
{
	*nSucc = *nAnte = 1;
}

void
rf_PQOneTwo(RF_Raid_t *raidPtr, int *nSucc, int *nAnte,
    RF_AccessStripeMap_t *asmap)
{
	*nSucc = 1;
	*nAnte = 2;
}
#endif

RF_CREATE_DAG_FUNC_DECL(rf_PQCreateLargeWriteDAG)
{
	rf_CommonCreateLargeWriteDAG(raidPtr, asmap, dag_h, bp, flags,
	    allocList, 2, rf_RegularPQFunc, RF_FALSE);
}

int
rf_RegularONQFunc(RF_DagNode_t *node)
{
	int np = node->numParams;
	int d;
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;
	int i;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;
	char *qbuf, *qpbuf;
	char *obuf, *nbuf;
	RF_PhysDiskAddr_t *old, *new;
	unsigned long coeff;
	unsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;

	RF_ETIMER_START(timer);

	d = (np - 3) / 4;
	RF_ASSERT(4 * d + 3 == np);
	qbuf = (char *) node->params[2 * d + 1].p;	/* Q buffer. */
	for (i = 0; i < d; i++) {
		old = (RF_PhysDiskAddr_t *) node->params[2 * i].p;
		obuf = (char *) node->params[2 * i + 1].p;
		new = (RF_PhysDiskAddr_t *) node->params[2 * (d + 1 + i)].p;
		nbuf = (char *) node->params[2 * (d + 1 + i) + 1].p;
		RF_ASSERT(new->numSector == old->numSector);
		RF_ASSERT(new->raidAddress == old->raidAddress);
		/*
		 * The stripe unit within the stripe tells us the coefficient
		 * to use for the multiply.
		 */
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    new->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
		coeff = (coeff % raidPtr->Layout.numDataCol);
		qpbuf = qbuf + rf_RaidAddressToByte(raidPtr,
		    old->startSector % secPerSU);
		rf_QDelta(qpbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr,
		    old->numSector), coeff);
	}

	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->q_us += RF_ETIMER_VAL_US(timer);
	rf_GenericWakeupFunc(node, 0);	/*
					 * Call wake func explicitly since no
					 * I/O in this node.
					 */
	return (0);
}


/*
 * See the SimpleXORFunc for the difference between a simple and regular func.
 * These Q functions should be used for
 *	new q = Q(data, old data, old q)
 * style updates and not for
 *	q = (new data, new data, ...)
 * computations.
 *
 * The simple q takes 2(2d+1)+1 params, where d is the number
 * of stripes written. The order of params is
 *   old data pda_0, old data buffer_0, old data pda_1, old data buffer_1, ...
 *   old data pda_d, old data buffer_d
 *   [2d] old q pda_0, old q buffer
 *   [2d_2] new data pda_0, new data buffer_0, ...
 *   new data pda_d, new data buffer_d
 *   raidPtr
 */

int
rf_SimpleONQFunc(RF_DagNode_t *node)
{
	int np = node->numParams;
	int d;
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;
	int i;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;
	char *qbuf;
	char *obuf, *nbuf;
	RF_PhysDiskAddr_t *old, *new;
	unsigned long coeff;

	RF_ETIMER_START(timer);

	d = (np - 3) / 4;
	RF_ASSERT(4 * d + 3 == np);
	qbuf = (char *) node->params[2 * d + 1].p;	/* Q buffer. */
	for (i = 0; i < d; i++) {
		old = (RF_PhysDiskAddr_t *) node->params[2 * i].p;
		obuf = (char *) node->params[2 * i + 1].p;
		new = (RF_PhysDiskAddr_t *) node->params[2 * (d + 1 + i)].p;
		nbuf = (char *) node->params[2 * (d + 1 + i) + 1].p;
		RF_ASSERT(new->numSector == old->numSector);
		RF_ASSERT(new->raidAddress == old->raidAddress);
		/*
		 * The stripe unit within the stripe tells us the coefficient
		 * to use for the multiply.
		 */
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    new->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
		coeff = (coeff % raidPtr->Layout.numDataCol);
		rf_QDelta(qbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr,
		    old->numSector), coeff);
	}

	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->q_us += RF_ETIMER_VAL_US(timer);
	rf_GenericWakeupFunc(node, 0);	/*
					 * Call wake func explicitly since no
					 * I/O in this node.
					 */
	return (0);
}

RF_CREATE_DAG_FUNC_DECL(rf_PQCreateSmallWriteDAG)
{
	rf_CommonCreateSmallWriteDAG(raidPtr, asmap, dag_h, bp, flags,
	    allocList, &rf_pFuncs, &rf_qFuncs);
}


void rf_RegularQSubr(RF_DagNode_t *, char *);

void
rf_RegularQSubr(RF_DagNode_t *node, char *qbuf)
{
	int np = node->numParams;
	int d;
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;
	unsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	int i;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;
	char *obuf, *qpbuf;
	RF_PhysDiskAddr_t *old;
	unsigned long coeff;

	RF_ETIMER_START(timer);

	d = (np - 1) / 2;
	RF_ASSERT(2 * d + 1 == np);
	for (i = 0; i < d; i++) {
		old = (RF_PhysDiskAddr_t *) node->params[2 * i].p;
		obuf = (char *) node->params[2 * i + 1].p;
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    old->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
		coeff = (coeff % raidPtr->Layout.numDataCol);
		/*
		 * The input buffers may not all be aligned with the start of
		 * the stripe. So shift by their sector offset within the
		 * stripe unit.
		 */
		qpbuf = qbuf + rf_RaidAddressToByte(raidPtr,
		    old->startSector % secPerSU);
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf,
		    rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
	}

	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->q_us += RF_ETIMER_VAL_US(timer);
}


/*
 * Used in degraded writes.
 */

void rf_DegrQSubr(RF_DagNode_t *);

void
rf_DegrQSubr(RF_DagNode_t *node)
{
	int np = node->numParams;
	int d;
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;
	unsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;
	char *qbuf = node->results[1];
	char *obuf, *qpbuf;
	RF_PhysDiskAddr_t *old;
	unsigned long coeff;
	unsigned fail_start;
	int i, j;

	old = (RF_PhysDiskAddr_t *) node->params[np - 2].p;
	fail_start = old->startSector % secPerSU;

	RF_ETIMER_START(timer);

	d = (np - 2) / 2;
	RF_ASSERT(2 * d + 2 == np);
	for (i = 0; i < d; i++) {
		old = (RF_PhysDiskAddr_t *) node->params[2 * i].p;
		obuf = (char *) node->params[2 * i + 1].p;
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    old->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
		coeff = (coeff % raidPtr->Layout.numDataCol);
		/*
		 * The input buffers may not all be aligned with the start of
		 * the stripe. So shift by their sector offset within the
		 * stripe unit.
		 */
		j = old->startSector % secPerSU;
		RF_ASSERT(j >= fail_start);
		qpbuf = qbuf + rf_RaidAddressToByte(raidPtr, j - fail_start);
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf,
		    rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
	}

	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->q_us += RF_ETIMER_VAL_US(timer);
}


/*
 * Called by large write code to compute the new parity and the new q.
 *
 * Structure of the params:
 *
 *   pda_0, buffer_0, pda_1 , buffer_1, ..., pda_d, buffer_d (d = numDataCol)
 *   raidPtr
 *
 * For a total of 2d+1 arguments.
 * The result buffers results[0], results[1] are the buffers for the p and q,
 * respectively.
 *
 * We compute Q first, then compute P. The P calculation may try to reuse
 * one of the input buffers for its output, so if we computed P first, we would
 * corrupt the input for the q calculation.
 */

int
rf_RegularPQFunc(RF_DagNode_t *node)
{
	rf_RegularQSubr(node, node->results[1]);
	return (rf_RegularXorFunc(node));	/* Does the wakeup. */
}

int
rf_RegularQFunc(RF_DagNode_t *node)
{
	/* Almost ... adjust Qsubr args. */
	rf_RegularQSubr(node, node->results[0]);
	rf_GenericWakeupFunc(node, 0);	/*
					 * Call wake func explicitly since no
					 * I/O in this node.
					 */
	return (0);
}


/*
 * Called by singly degraded write code to compute the new parity and
 * the new q.
 *
 * Structure of the params:
 *
 *   pda_0, buffer_0, pda_1 , buffer_1, ..., pda_d, buffer_d
 *   failedPDA raidPtr
 *
 * for a total of 2d+2 arguments.
 * The result buffers results[0], results[1] are the buffers for the parity
 * and q, respectively.
 *
 * We compute Q first, then compute parity. The parity calculation may try
 * to reuse one of the input buffers for its output, so if we computed parity
 * first, we would corrupt the input for the q calculation.
 *
 * We treat this identically to the regularPQ case, ignoring the failedPDA
 * extra argument.
 */

void
rf_Degraded_100_PQFunc(RF_DagNode_t *node)
{
	int     np = node->numParams;

	RF_ASSERT(np >= 2);
	rf_DegrQSubr(node);
	rf_RecoveryXorFunc(node);
}


/*
 * The two below are used when reading a stripe with a single lost data unit.
 * The parameters are
 *
 *  pda_0, buffer_0, ..., pda_n, buffer_n, P pda, P buffer, failedPDA, raidPtr
 *
 * and results[0] contains the data buffer, which is originally zero-filled.
 */

/*
 * This Q func is used by the degraded-mode dag functions to recover lost data.
 * The second-to-last parameter is the PDA for the failed portion of the
 * access. The code here looks at this PDA and assumes that the xor target
 * buffer is equal in size to the number of sectors in the failed PDA. It then
 * uses the other PDAs in the parameter list to determine where within the
 * target buffer the corresponding data should be xored.
 *
 * Recall the basic equation is
 *
 *     Q = (data_1 + 2 * data_2 ... + k * data_k) mod 256
 *
 * so to recover data_j we need
 *
 *    J data_j = (Q - data_1 - 2 data_2 ... - k * data_k) mod 256
 *
 * So the coefficient for each buffer is (255 - data_col), and j should be
 * initialized by copying Q into it. Then we need to do a table lookup to
 * convert to solve
 *   data_j /= J
 *
 */

int
rf_RecoveryQFunc(RF_DagNode_t *node)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;
	RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;
	RF_PhysDiskAddr_t *failedPDA =
	    (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;
	int i;
	RF_PhysDiskAddr_t *pda;
	RF_RaidAddr_t suoffset;
	RF_RaidAddr_t failedSUOffset =
	    rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char *srcbuf, *destbuf;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;
	unsigned long coeff;

	RF_ETIMER_START(timer);
	/* Start by copying Q into the buffer. */
	bcopy(node->params[node->numParams - 3].p, node->results[0],
	    rf_RaidAddressToByte(raidPtr, failedPDA->numSector));
	for (i = 0; i < node->numParams - 4; i += 2) {
		RF_ASSERT(node->params[i + 1].p != node->results[0]);
		pda = (RF_PhysDiskAddr_t *) node->params[i].p;
		srcbuf = (char *) node->params[i + 1].p;
		suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
		destbuf = ((char *) node->results[0]) +
		    rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    pda->raidAddress);
		/* Compute the data unit offset within the column. */
		coeff = (coeff % raidPtr->Layout.numDataCol);
		rf_IncQ((unsigned long *) destbuf, (unsigned long *) srcbuf,
		    rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);
	}
	/* Do the nasty inversion now. */
	coeff = (rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
	    failedPDA->startSector) % raidPtr->Layout.numDataCol);
	rf_InvertQ(node->results[0], node->results[0],
	    rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);
	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->q_us += RF_ETIMER_VAL_US(timer);
	rf_GenericWakeupFunc(node, 0);
	return (0);
}

int
rf_RecoveryPQFunc(RF_DagNode_t *node)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;
	printf("raid%d: Recovery from PQ not implemented.\n", raidPtr->raidid);
	return (1);
}


/*
 * Degraded write Q subroutine.
 * Used when P is dead.
 * Large-write style Q computation.
 * Parameters:
 *
 * (pda, buf), (pda, buf), ..., (failedPDA, bufPtr), failedPDA, raidPtr.
 *
 * We ignore failedPDA.
 *
 * This is a "simple style" recovery func.
 */

void
rf_PQ_DegradedWriteQFunc(RF_DagNode_t *node)
{
	int np = node->numParams;
	int d;
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;
	unsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;
	RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
	RF_Etimer_t timer;
	char *qbuf = node->results[0];
	char *obuf, *qpbuf;
	RF_PhysDiskAddr_t *old;
	unsigned long coeff;
	int fail_start, i, j;

	old = (RF_PhysDiskAddr_t *) node->params[np - 2].p;
	fail_start = old->startSector % secPerSU;

	RF_ETIMER_START(timer);

	d = (np - 2) / 2;
	RF_ASSERT(2 * d + 2 == np);

	for (i = 0; i < d; i++) {
		old = (RF_PhysDiskAddr_t *) node->params[2 * i].p;
		obuf = (char *) node->params[2 * i + 1].p;
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    old->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
		coeff = (coeff % raidPtr->Layout.numDataCol);
		j = old->startSector % secPerSU;
		RF_ASSERT(j >= fail_start);
		qpbuf = qbuf + rf_RaidAddressToByte(raidPtr, j - fail_start);
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf,
		    rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
	}

	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->q_us += RF_ETIMER_VAL_US(timer);
	rf_GenericWakeupFunc(node, 0);
}


/* Q computations. */

/*
 * Coeff - colummn;
 *
 * Compute  dest ^= qfor[28-coeff][rn[coeff+1] a]
 *
 * On 5-bit basis;
 * Length in bytes;
 */

void
rf_IncQ(unsigned long *dest, unsigned long *buf, unsigned length,
    unsigned coeff)
{
	unsigned long a, d, new;
	unsigned long a1, a2;
	unsigned int *q = &(rf_qfor[28 - coeff][0]);
	unsigned r = rf_rn[coeff + 1];

#define	EXTRACT(a,i)	((a >> (5L*i)) & 0x1f)
#define	INSERT(a,i)	(a << (5L*i))

	length /= 8;
	/* 13 5 bit quants in a 64 bit word. */
	while (length) {
		a = *buf++;
		d = *dest;
		a1 = EXTRACT(a, 0) ^ r;
		a2 = EXTRACT(a, 1) ^ r;
		new = INSERT(a2, 1) | a1;
		a1 = EXTRACT(a, 2) ^ r;
		a2 = EXTRACT(a, 3) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 2) | INSERT(a2, 3);
		a1 = EXTRACT(a, 4) ^ r;
		a2 = EXTRACT(a, 5) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 4) | INSERT(a2, 5);
		a1 = EXTRACT(a, 5) ^ r;
		a2 = EXTRACT(a, 6) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 5) | INSERT(a2, 6);
#if	RF_LONGSHIFT > 2
		a1 = EXTRACT(a, 7) ^ r;
		a2 = EXTRACT(a, 8) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 7) | INSERT(a2, 8);
		a1 = EXTRACT(a, 9) ^ r;
		a2 = EXTRACT(a, 10) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 9) | INSERT(a2, 10);
		a1 = EXTRACT(a, 11) ^ r;
		a2 = EXTRACT(a, 12) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 11) | INSERT(a2, 12);
#endif	/* RF_LONGSHIFT > 2 */
		d ^= new;
		*dest++ = d;
		length--;
	}
}


/*
 * Compute.
 *
 * dest ^= rf_qfor[28-coeff][rf_rn[coeff+1] (old^new)]
 *
 * On a five bit basis.
 * Optimization: compute old ^ new on 64 bit basis.
 *
 * Length in bytes.
 */

void
rf_QDelta(char *dest, char *obuf, char *nbuf, unsigned length,
    unsigned char coeff)
{
	unsigned long a, d, new;
	unsigned long a1, a2;
	unsigned int *q = &(rf_qfor[28 - coeff][0]);
	unsigned int r = rf_rn[coeff + 1];

	r = a1 = a2 = new = d = a = 0; /* XXX For now... */
	q = NULL; /* XXX For now */

#ifdef	_KERNEL
	/*
	 * PQ in kernel currently not supported because the encoding/decoding
	 * table is not present.
	 */
	bzero(dest, length);
#else	/* _KERNEL */
	/* This code probably doesn't work and should be rewritten. -wvcii */
	/* 13 5 bit quants in a 64 bit word. */
	length /= 8;
	while (length) {
		a = *obuf++;	/*
				 * XXX Need to reorg to avoid cache conflicts.
				 */
		a ^= *nbuf++;
		d = *dest;
		a1 = EXTRACT(a, 0) ^ r;
		a2 = EXTRACT(a, 1) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = INSERT(a2, 1) | a1;
		a1 = EXTRACT(a, 2) ^ r;
		a2 = EXTRACT(a, 3) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 2) | INSERT(a2, 3);
		a1 = EXTRACT(a, 4) ^ r;
		a2 = EXTRACT(a, 5) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 4) | INSERT(a2, 5);
		a1 = EXTRACT(a, 5) ^ r;
		a2 = EXTRACT(a, 6) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 5) | INSERT(a2, 6);
#if	RF_LONGSHIFT > 2
		a1 = EXTRACT(a, 7) ^ r;
		a2 = EXTRACT(a, 8) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 7) | INSERT(a2, 8);
		a1 = EXTRACT(a, 9) ^ r;
		a2 = EXTRACT(a, 10) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 9) | INSERT(a2, 10);
		a1 = EXTRACT(a, 11) ^ r;
		a2 = EXTRACT(a, 12) ^ r;
		a1 = q[a1];
		a2 = q[a2];
		new = new | INSERT(a1, 11) | INSERT(a2, 12);
#endif	/* RF_LONGSHIFT > 2 */
		d ^= new;
		*dest++ = d;
		length--;
	}
#endif	/* _KERNEL */
}


/*
 * Recover columns a and b from the given p and q into
 * bufs abuf and bbuf. All bufs are word aligned.
 * Length is in bytes.
 */

/*
 * XXX
 *
 * Everything about this seems wrong.
 */

void
rf_PQ_recover(unsigned long *pbuf, unsigned long *qbuf, unsigned long *abuf,
    unsigned long *bbuf, unsigned length, unsigned coeff_a, unsigned coeff_b)
{
	unsigned long p, q, a, a0, a1;
	int col = (29 * coeff_a) + coeff_b;
	unsigned char *q0 = &(rf_qinv[col][0]);

	length /= 8;
	while (length) {
		p = *pbuf++;
		q = *qbuf++;
		a0 = EXTRACT(p, 0);
		a1 = EXTRACT(q, 0);
		a = q0[a0 << 5 | a1];

#define	MF(i)								\
do {									\
	a0 = EXTRACT(p, i);						\
	a1 = EXTRACT(q, i);						\
	a  = a | INSERT(q0[a0<<5 | a1], i);				\
} while (0)

		MF(1);
		MF(2);
		MF(3);
		MF(4);
		MF(5);
		MF(6);
#if 0
		MF(7);
		MF(8);
		MF(9);
		MF(10);
		MF(11);
		MF(12);
#endif	/* 0 */
		*abuf++ = a;
		*bbuf++ = a ^ p;
		length--;
	}
}


/*
 * Lost parity and a data column. Recover that data column.
 * Assume col coeff is lost. Let q the contents of Q after
 * all surviving data columns have been q-xored out of it.
 * Then we have the equation
 *
 *   q[28-coeff][a_i ^ r_i+1] = q
 *
 * but q is cyclic with period 31.
 * So q[3+coeff][q[28-coeff][a_i ^ r_{i+1}]] =
 *    q[31][a_i ^ r_{i+1}] = a_i ^ r_{i+1} .
 *
 * so a_i = r_{coeff+1} ^ q[3+coeff][q]
 *
 * The routine is passed q buffer and the buffer
 * the data is to be recoverd into. They can be the same.
 */

void
rf_InvertQ(unsigned long *qbuf, unsigned long *abuf, unsigned length,
    unsigned coeff)
{
	unsigned long a, new;
	unsigned long a1, a2;
	unsigned int *q = &(rf_qfor[3 + coeff][0]);
	unsigned r = rf_rn[coeff + 1];

	/* 13 5 bit quants in a 64 bit word. */
	length /= 8;
	while (length) {
		a = *qbuf++;
		a1 = EXTRACT(a, 0);
		a2 = EXTRACT(a, 1);
		a1 = r ^ q[a1];
		a2 = r ^ q[a2];
		new = INSERT(a2, 1) | a1;

#define	M(i,j)								\
do {									\
	a1 = EXTRACT(a, i);						\
	a2 = EXTRACT(a, j);						\
	a1 = r ^ q[a1];							\
	a2 = r ^ q[a2];							\
	new = new | INSERT(a1, i) | INSERT(a2, j);			\
} while (0)

		M(2, 3);
		M(4, 5);
		M(5, 6);
#if	RF_LONGSHIFT > 2
		M(7, 8);
		M(9, 10);
		M(11, 12);
#endif	/* RF_LONGSHIFT > 2 */
		*abuf++ = new;
		length--;
	}
}
#endif	/* (RF_INCLUDE_DECL_PQ > 0) || (RF_INCLUDE_RAID6 > 0) */
@


1.6
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_pq.c,v 1.5 2000/01/11 18:02:22 peter Exp $	*/
@


1.5
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_pq.c,v 1.4 2000/01/07 14:50:22 peter Exp $	*/
d3 1
d51 8
a58 2
RF_RedFuncs_t rf_pFuncs = {rf_RegularONPFunc, "Regular Old-New P", rf_SimpleONPFunc, "Simple Old-New P"};
RF_RedFuncs_t rf_pRecoveryFuncs = {rf_RecoveryPFunc, "Recovery P Func", rf_RecoveryPFunc, "Recovery P Func"};
d60 2
a61 3
int 
rf_RegularONPFunc(node)
	RF_DagNode_t *node;
d65 2
d68 2
a69 2
   same as simpleONQ func, but the coefficient is always 1
*/
d71 2
a72 3
int 
rf_SimpleONPFunc(node)
	RF_DagNode_t *node;
d77 2
a78 3
int 
rf_RecoveryPFunc(node)
	RF_DagNode_t *node;
d83 2
a84 3
int 
rf_RegularPFunc(node)
	RF_DagNode_t *node;
a87 1
#if (RF_INCLUDE_DECL_PQ > 0) || (RF_INCLUDE_RAID6 > 0)
d89 24
a112 17
static void 
QDelta(char *dest, char *obuf, char *nbuf, unsigned length,
    unsigned char coeff);
static void 
rf_InvertQ(unsigned long *qbuf, unsigned long *abuf,
    unsigned length, unsigned coeff);

RF_RedFuncs_t rf_qFuncs = {rf_RegularONQFunc, "Regular Old-New Q", rf_SimpleONQFunc, "Simple Old-New Q"};
RF_RedFuncs_t rf_qRecoveryFuncs = {rf_RecoveryQFunc, "Recovery Q Func", rf_RecoveryQFunc, "Recovery Q Func"};
RF_RedFuncs_t rf_pqRecoveryFuncs = {rf_RecoveryPQFunc, "Recovery PQ Func", rf_RecoveryPQFunc, "Recovery PQ Func"};

void 
rf_PQDagSelect(
    RF_Raid_t * raidPtr,
    RF_IoType_t type,
    RF_AccessStripeMap_t * asmap,
    RF_VoidFuncPtr * createFunc)
d121 2
a122 1
		RF_ERRORMSG("more than two disks failed in a single group!  Aborting I/O operation.\n");
d126 1
a126 1
	/* ok, we can do this I/O */
d130 3
a132 2
			/* fault free read */
			*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;	/* same as raid 5 */
d135 12
a146 7
			/* lost a single data unit */
			/* two cases: (1) parity is not lost. do a normal raid
			 * 5 reconstruct read. (2) parity is lost. do a
			 * reconstruct read using "q". */
			if (ntfail == 2) {	/* also lost redundancy */
				if (asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY)
					*createFunc = (RF_VoidFuncPtr) rf_PQ_110_CreateReadDAG;
d148 2
a149 1
					*createFunc = (RF_VoidFuncPtr) rf_PQ_101_CreateReadDAG;
d151 8
a158 4
				/* P and Q are ok. But is there a failure in
				 * some unaccessed data unit? */
				if (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)
					*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateReadDAG;
d160 2
a161 1
					*createFunc = (RF_VoidFuncPtr) rf_PQ_100_CreateReadDAG;
d165 2
a166 2
			/* lost two data units */
			/* *infoFunc = PQOneTwo; */
d172 1
a172 1
	/* a write */
d174 1
a174 1
	case 0:		/* fault free */
d176 6
a181 2
		    (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||
			(asmap->parityInfo->next != NULL) || (asmap->qInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {
d189 1
a189 1
	case 1:		/* single disk fault */
d191 14
a204 7
			RF_ASSERT((asmap->failedPDAs[0]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));
			if (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {	/* q died, treat like
										 * normal mode raid5
										 * write. */
				if (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))
				    || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))
					*createFunc = (RF_VoidFuncPtr) rf_PQ_001_CreateSmallWriteDAG;
d206 10
a215 5
					*createFunc = (RF_VoidFuncPtr) rf_PQ_001_CreateLargeWriteDAG;
			} else {/* parity died, small write only updating Q */
				if (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))
				    || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))
					*createFunc = (RF_VoidFuncPtr) rf_PQ_010_CreateSmallWriteDAG;
d217 2
a218 1
					*createFunc = (RF_VoidFuncPtr) rf_PQ_010_CreateLargeWriteDAG;
d220 2
a221 1
		} else {	/* data missing. Do a P reconstruct write if
d223 2
a224 1
				 * stripe, otherwise a PQ reconstruct write. */
d226 2
a227 1
				*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateWriteDAG;
d229 2
a230 1
				*createFunc = (RF_VoidFuncPtr) rf_PQ_100_CreateWriteDAG;
d234 1
a234 1
	case 2:		/* two disk faults */
d236 1
a236 1
		case 2:	/* both p and q dead */
d239 7
a245 3
		case 1:	/* either p or q and dead data */
			RF_ASSERT(asmap->failedPDAs[0]->type == RF_PDA_TYPE_DATA);
			RF_ASSERT((asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));
d247 2
a248 1
				*createFunc = (RF_VoidFuncPtr) rf_PQ_101_CreateWriteDAG;
d250 2
a251 1
				*createFunc = (RF_VoidFuncPtr) rf_PQ_110_CreateWriteDAG;
d253 1
a253 1
		case 0:	/* double data loss */
d259 1
a259 1
	default:		/* more than 2 disk faults */
d265 2
d268 2
a269 2
   Used as a stop gap info function
*/
d271 3
a273 6
static void 
PQOne(raidPtr, nSucc, nAnte, asmap)
	RF_Raid_t *raidPtr;
	int    *nSucc;
	int    *nAnte;
	RF_AccessStripeMap_t *asmap;
d278 3
a280 6
static void 
PQOneTwo(raidPtr, nSucc, nAnte, asmap)
	RF_Raid_t *raidPtr;
	int    *nSucc;
	int    *nAnte;
	RF_AccessStripeMap_t *asmap;
d289 2
a290 2
	rf_CommonCreateLargeWriteDAG(raidPtr, asmap, dag_h, bp, flags, allocList, 2,
	    rf_RegularPQFunc, RF_FALSE);
d293 2
a294 3
int 
rf_RegularONQFunc(node)
	RF_DagNode_t *node;
d296 2
a297 2
	int     np = node->numParams;
	int     d;
d299 1
a299 1
	int     i;
d302 2
a303 2
	char   *qbuf, *qpbuf;
	char   *obuf, *nbuf;
d312 1
a312 1
	qbuf = (char *) node->params[2 * d + 1].p;	/* q buffer */
d320 10
a329 5
		/* the stripe unit within the stripe tells us the coefficient
		 * to use for the multiply. */
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), new->raidAddress);
		/* compute the data unit offset within the column, then add
		 * one */
d331 4
a334 2
		qpbuf = qbuf + rf_RaidAddressToByte(raidPtr, old->startSector % secPerSU);
		QDelta(qpbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
d340 4
a343 2
	rf_GenericWakeupFunc(node, 0);	/* call wake func explicitly since no
					 * I/O in this node */
a345 3
/*
   See the SimpleXORFunc for the difference between a simple and regular func.
   These Q functions should be used for
a346 1
         new q = Q(data,old data,old q)
d348 17
a364 5
   style updates and not for

         q = ( new data, new data, .... )

   computations.
d366 2
a367 11
   The simple q takes 2(2d+1)+1 params, where d is the number
   of stripes written. The order of params is
   old data pda_0, old data buffer_0, old data pda_1, old data buffer_1, ... old data pda_d, old data buffer_d
   [2d] old q pda_0, old q buffer
   [2d_2] new data pda_0, new data buffer_0, ...                                    new data pda_d, new data buffer_d
   raidPtr
*/

int 
rf_SimpleONQFunc(node)
	RF_DagNode_t *node;
d369 2
a370 2
	int     np = node->numParams;
	int     d;
d372 1
a372 1
	int     i;
d375 2
a376 2
	char   *qbuf;
	char   *obuf, *nbuf;
d384 1
a384 1
	qbuf = (char *) node->params[2 * d + 1].p;	/* q buffer */
d392 10
a401 5
		/* the stripe unit within the stripe tells us the coefficient
		 * to use for the multiply. */
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), new->raidAddress);
		/* compute the data unit offset within the column, then add
		 * one */
d403 2
a404 1
		QDelta(qbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
d410 4
a413 2
	rf_GenericWakeupFunc(node, 0);	/* call wake func explicitly since no
					 * I/O in this node */
d416 1
d419 2
a420 1
	rf_CommonCreateSmallWriteDAG(raidPtr, asmap, dag_h, bp, flags, allocList, &rf_pFuncs, &rf_qFuncs);
a422 1
static void RegularQSubr(RF_DagNode_t *node, char   *qbuf);
d424 4
a427 4
static void 
RegularQSubr(node, qbuf)
	RF_DagNode_t *node;
	char   *qbuf;
d429 2
a430 2
	int     np = node->numParams;
	int     d;
d433 1
a433 1
	int     i;
d436 1
a436 1
	char   *obuf, *qpbuf;
d447 6
a452 3
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);
		/* compute the data unit offset within the column, then add
		 * one */
d454 9
a462 5
		/* the input buffers may not all be aligned with the start of
		 * the stripe. so shift by their sector offset within the
		 * stripe unit */
		qpbuf = qbuf + rf_RaidAddressToByte(raidPtr, old->startSector % secPerSU);
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
d469 2
d472 2
a473 2
   used in degraded writes.
*/
d475 1
a475 1
static void DegrQSubr(RF_DagNode_t *node);
d477 2
a478 3
static void 
DegrQSubr(node)
	RF_DagNode_t *node;
d480 2
a481 2
	int     np = node->numParams;
	int     d;
a483 1
	int     i;
d486 2
a487 2
	char   *qbuf = node->results[1];
	char   *obuf, *qpbuf;
d491 1
a491 1
	int     j;
d503 6
a508 3
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);
		/* compute the data unit offset within the column, then add
		 * one */
d510 5
a514 3
		/* the input buffers may not all be aligned with the start of
		 * the stripe. so shift by their sector offset within the
		 * stripe unit */
d518 2
a519 1
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
a525 2
/*
   Called by large write code to compute the new parity and the new q.
a526 1
   structure of the params:
d528 16
a543 11
   pda_0, buffer_0, pda_1 , buffer_1, ... , pda_d, buffer_d ( d = numDataCol
   raidPtr

   for a total of 2d+1 arguments.
   The result buffers results[0], results[1] are the buffers for the p and q,
   respectively.

   We compute Q first, then compute P. The P calculation may try to reuse
   one of the input buffers for its output, so if we computed P first, we would
   corrupt the input for the q calculation.
*/
d545 2
a546 3
int 
rf_RegularPQFunc(node)
	RF_DagNode_t *node;
d548 2
a549 2
	RegularQSubr(node, node->results[1]);
	return (rf_RegularXorFunc(node));	/* does the wakeup */
d552 9
a560 8
int 
rf_RegularQFunc(node)
	RF_DagNode_t *node;
{
	/* Almost ... adjust Qsubr args */
	RegularQSubr(node, node->results[0]);
	rf_GenericWakeupFunc(node, 0);	/* call wake func explicitly since no
					 * I/O in this node */
a562 2
/*
   Called by singly degraded write code to compute the new parity and the new q.
a563 1
   structure of the params:
d565 20
a584 2
   pda_0, buffer_0, pda_1 , buffer_1, ... , pda_d, buffer_d
   failedPDA raidPtr
d586 2
a587 14
   for a total of 2d+2 arguments.
   The result buffers results[0], results[1] are the buffers for the parity and q,
   respectively.

   We compute Q first, then compute parity. The parity calculation may try to reuse
   one of the input buffers for its output, so if we computed parity first, we would
   corrupt the input for the q calculation.

   We treat this identically to the regularPQ case, ignoring the failedPDA extra argument.
*/

void 
rf_Degraded_100_PQFunc(node)
	RF_DagNode_t *node;
d592 1
a592 1
	DegrQSubr(node);
d598 7
a604 2
   The two below are used when reading a stripe with a single lost data unit.
   The parameters are
d606 7
a612 12
   pda_0, buffer_0, .... pda_n, buffer_n, P pda, P buffer, failedPDA, raidPtr

   and results[0] contains the data buffer. Which is originally zero-filled.

*/

/* this Q func is used by the degraded-mode dag functions to recover lost data.
 * the second-to-last parameter is the PDA for the failed portion of the access.
 * the code here looks at this PDA and assumes that the xor target buffer is
 * equal in size to the number of sectors in the failed PDA.  It then uses
 * the other PDAs in the parameter list to determine where within the target
 * buffer the corresponding data should be xored.
d616 1
a616 1
 *     Q = ( data_1 + 2 * data_2 ... + k * data_k  ) mod 256
d620 1
a620 1
 *    J data_j = (Q - data_1 - 2 data_2 ....- k* data_k) mod 256
d622 3
a624 2
 * So the coefficient for each buffer is (255 - data_col), and j should be initialized by
 * copying Q into it. Then we need to do a table lookup to convert to solve
a626 1
 *
d628 3
a630 3
int 
rf_RecoveryQFunc(node)
	RF_DagNode_t *node;
d634 3
a636 2
	RF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;
	int     i;
d638 4
a641 2
	RF_RaidAddr_t suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char   *srcbuf, *destbuf;
d647 1
a647 1
	/* start by copying Q into the buffer */
d655 5
a659 3
		destbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), pda->raidAddress);
		/* compute the data unit offset within the column */
d661 2
a662 1
		rf_IncQ((unsigned long *) destbuf, (unsigned long *) srcbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);
d664 5
a668 3
	/* Do the nasty inversion now */
	coeff = (rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), failedPDA->startSector) % raidPtr->Layout.numDataCol);
	rf_InvertQ(node->results[0], node->results[0], rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);
d676 2
a677 3
int 
rf_RecoveryPQFunc(node)
	RF_DagNode_t *node;
d680 1
a680 1
	printf("raid%d: Recovery from PQ not implemented.\n",raidPtr->raidid);
a682 5
/*
   Degraded write Q subroutine.
   Used when P is dead.
   Large-write style Q computation.
   Parameters
a683 1
   (pda,buf),(pda,buf),.....,(failedPDA,bufPtr),failedPDA,raidPtr.
d685 12
a696 4
   We ignore failedPDA.

   This is a "simple style" recovery func.
*/
d698 2
a699 3
void 
rf_PQ_DegradedWriteQFunc(node)
	RF_DagNode_t *node;
d701 2
a702 2
	int     np = node->numParams;
	int     d;
a704 1
	int     i;
d707 2
a708 2
	char   *qbuf = node->results[0];
	char   *obuf, *qpbuf;
d711 1
a711 1
	int     fail_start, j;
d724 6
a729 3
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);
		/* compute the data unit offset within the column, then add
		 * one */
d734 2
a735 1
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
d745 1
a745 3


/* Q computations */
d748 7
a754 1
   coeff - colummn;
d756 3
a758 12
   compute  dest ^= qfor[28-coeff][rn[coeff+1] a]

   on 5-bit basis;
   length in bytes;
*/

void 
rf_IncQ(dest, buf, length, coeff)
	unsigned long *dest;
	unsigned long *buf;
	unsigned length;
	unsigned coeff;
d765 2
a766 2
#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)
#define INSERT(a,i) (a << (5L*i))
d769 1
a769 1
	/* 13 5 bit quants in a 64 bit word */
d791 1
a791 1
#if RF_LONGSHIFT > 2
d807 1
a807 1
#endif				/* RF_LONGSHIFT > 2 */
a812 2
/*
   compute
a813 1
   dest ^= rf_qfor[28-coeff][rf_rn[coeff+1] (old^new) ]
d815 10
a824 2
   on a five bit basis.
   optimization: compute old ^ new on 64 bit basis.
d826 2
a827 9
   length in bytes.
*/

static void 
QDelta(
    char *dest,
    char *obuf,
    char *nbuf,
    unsigned length,
d835 2
a836 2
	r = a1 = a2 = new = d = a = 0; /* XXX for now... */
	q = NULL; /* XXX for now */
d838 5
a842 3
#ifdef _KERNEL
	/* PQ in kernel currently not supported because the encoding/decoding
	 * table is not present */
d844 3
a846 3
#else				/* _KERNEL */
	/* this code probably doesn't work and should be rewritten  -wvcii */
	/* 13 5 bit quants in a 64 bit word */
d849 3
a851 1
		a = *obuf++;	/* XXX need to reorg to avoid cache conflicts */
d874 1
a874 1
#if RF_LONGSHIFT > 2
d890 1
a890 1
#endif				/* RF_LONGSHIFT > 2 */
d895 1
a895 1
#endif				/* _KERNEL */
d897 2
d900 4
a903 5
   recover columns a and b from the given p and q into
   bufs abuf and bbuf. All bufs are word aligned.
   Length is in bytes.
*/

d910 4
a913 9
void 
rf_PQ_recover(pbuf, qbuf, abuf, bbuf, length, coeff_a, coeff_b)
	unsigned long *pbuf;
	unsigned long *qbuf;
	unsigned long *abuf;
	unsigned long *bbuf;
	unsigned length;
	unsigned coeff_a;
	unsigned coeff_b;
d916 1
a916 1
	int     col = (29 * coeff_a) + coeff_b;
d926 7
a932 4
#define MF(i) \
      a0 = EXTRACT(p,i); \
      a1 = EXTRACT(q,i); \
      a  = a | INSERT(q0[a0<<5 | a1],i)
d947 1
a947 1
#endif				/* 0 */
a952 5
/*
   Lost parity and a data column. Recover that data column.
   Assume col coeff is lost. Let q the contents of Q after
   all surviving data columns have been q-xored out of it.
   Then we have the equation
a953 1
   q[28-coeff][a_i ^ r_i+1] = q
d955 17
a971 3
   but q is cyclic with period 31.
   So q[3+coeff][q[28-coeff][a_i ^ r_{i+1}]] =
      q[31][a_i ^ r_{i+1}] = a_i ^ r_{i+1} .
d973 2
a974 13
   so a_i = r_{coeff+1} ^ q[3+coeff][q]

   The routine is passed q buffer and the buffer
   the data is to be recoverd into. They can be the same.
*/



static void 
rf_InvertQ(
    unsigned long *qbuf,
    unsigned long *abuf,
    unsigned length,
d982 1
a982 1
	/* 13 5 bit quants in a 64 bit word */
d991 9
a999 6
#define M(i,j) \
      a1 = EXTRACT(a,i); \
      a2 = EXTRACT(a,j); \
      a1 = r ^ q[a1]; \
      a2 = r ^ q[a2]; \
      new = new | INSERT(a1,i) | INSERT(a2,j)
d1004 1
a1004 1
#if RF_LONGSHIFT > 2
d1008 1
a1008 1
#endif				/* RF_LONGSHIFT > 2 */
d1013 1
a1013 2
#endif				/* (RF_INCLUDE_DECL_PQ > 0) ||
				 * (RF_INCLUDE_RAID6 > 0) */
@


1.5.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d50 2
a51 8
RF_RedFuncs_t rf_pFuncs = {
	rf_RegularONPFunc, "Regular Old-New P",
	rf_SimpleONPFunc, "Simple Old-New P"
};
RF_RedFuncs_t rf_pRecoveryFuncs = {
	rf_RecoveryPFunc, "Recovery P Func",
	rf_RecoveryPFunc, "Recovery P Func"
};
d53 3
a55 2
int
rf_RegularONPFunc(RF_DagNode_t *node)
a58 2


d60 2
a61 2
 * Same as simpleONQ func, but the coefficient is always 1.
 */
d63 3
a65 2
int
rf_SimpleONPFunc(RF_DagNode_t *node)
d70 3
a72 2
int
rf_RecoveryPFunc(RF_DagNode_t *node)
d77 3
a79 2
int
rf_RegularPFunc(RF_DagNode_t *node)
d83 1
d85 17
a101 24

#if	(RF_INCLUDE_DECL_PQ > 0) || (RF_INCLUDE_RAID6 > 0)

void rf_QDelta(char *dest, char *obuf, char *nbuf, unsigned length,
	unsigned char coeff);
void rf_InvertQ(unsigned long *qbuf, unsigned long *abuf, unsigned length,
	unsigned coeff);

RF_RedFuncs_t rf_qFuncs = {
	rf_RegularONQFunc, "Regular Old-New Q",
	rf_SimpleONQFunc, "Simple Old-New Q"
};
RF_RedFuncs_t rf_qRecoveryFuncs = {
	rf_RecoveryQFunc, "Recovery Q Func",
	rf_RecoveryQFunc, "Recovery Q Func"
};
RF_RedFuncs_t rf_pqRecoveryFuncs = {
	rf_RecoveryPQFunc, "Recovery PQ Func",
	rf_RecoveryPQFunc, "Recovery PQ Func"
};

void
rf_PQDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmap, RF_VoidFuncPtr *createFunc)
d110 1
a110 2
		RF_ERRORMSG("more than two disks failed in a single group !"
		            "  Aborting I/O operation.\n");
d114 1
a114 1
	/* Ok, we can do this I/O. */
d118 2
a119 3
			/* Fault free read. */
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateFaultFreeReadDAG;	/* Same as raid 5. */
d122 7
a128 12
			/* Lost a single data unit. */
			/*
			 * Two cases:
			 * (1) Parity is not lost. Do a normal raid 5
			 *     reconstruct read.
			 * (2) Parity is lost. Do a reconstruct read using "q".
			 */
			if (ntfail == 2) {	/* Also lost redundancy. */
				if (asmap->failedPDAs[1]->type ==
				    RF_PDA_TYPE_PARITY)
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_110_CreateReadDAG;
d130 1
a130 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_101_CreateReadDAG;
d132 4
a135 8
				/*
				 * P and Q are ok. But is there a failure in
				 * some unaccessed data unit ?
				 */
				if (rf_NumFailedDataUnitsInStripe(raidPtr,
				    asmap) == 2)
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_200_CreateReadDAG;
d137 1
a137 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_100_CreateReadDAG;
d141 2
a142 2
			/* Lost two data units. */
			/* *infoFunc = rf_PQOneTwo; */
d148 1
a148 1
	/* A write. */
d150 1
a150 1
	case 0:		/* Fault free. */
d152 2
a153 6
		    (((asmap->numStripeUnitsAccessed <=
		       (layoutPtr->numDataCol / 2)) &&
		      (layoutPtr->numDataCol != 1)) ||
		     (asmap->parityInfo->next != NULL) ||
		     (asmap->qInfo->next != NULL) ||
		     rf_CheckStripeForFailures(raidPtr, asmap))) {
d161 1
a161 1
	case 1:		/* Single disk fault. */
d163 7
a169 14
			RF_ASSERT((asmap->failedPDAs[0]->type ==
			    RF_PDA_TYPE_PARITY) ||
			    (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));
			if (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {
				/*
				 * Q died, treat like normal mode raid5 write.
				 */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_001_CreateSmallWriteDAG;
d171 5
a175 10
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_001_CreateLargeWriteDAG;
			} else {/* Parity died, small write only updating Q. */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_010_CreateSmallWriteDAG;
d177 1
a177 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_010_CreateLargeWriteDAG;
d179 1
a179 2
		} else {	/*
				 * Data missing. Do a P reconstruct write if
d181 1
a181 2
				 * stripe, otherwise a PQ reconstruct write.
				 */
d183 1
a183 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_200_CreateWriteDAG;
d185 1
a185 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_100_CreateWriteDAG;
d189 1
a189 1
	case 2:		/* Two disk faults. */
d191 1
a191 1
		case 2:	/* Both p and q dead. */
d194 3
a196 7
		case 1:	/* Either p or q and dead data. */
			RF_ASSERT(asmap->failedPDAs[0]->type ==
			          RF_PDA_TYPE_DATA);
			RF_ASSERT((asmap->failedPDAs[1]->type ==
			           RF_PDA_TYPE_PARITY) ||
			          (asmap->failedPDAs[1]->type ==
			           RF_PDA_TYPE_Q));
d198 1
a198 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_101_CreateWriteDAG;
d200 1
a200 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_110_CreateWriteDAG;
d202 1
a202 1
		case 0:	/* Double data loss. */
d208 1
a208 1
	default:	/* More than 2 disk faults. */
a213 2


d215 2
a216 2
 * Used as a stop gap info function.
 */
d218 6
a223 3
void
rf_PQOne(RF_Raid_t *raidPtr, int *nSucc, int *nAnte,
    RF_AccessStripeMap_t *asmap)
d228 6
a233 3
void
rf_PQOneTwo(RF_Raid_t *raidPtr, int *nSucc, int *nAnte,
    RF_AccessStripeMap_t *asmap)
d242 2
a243 2
	rf_CommonCreateLargeWriteDAG(raidPtr, asmap, dag_h, bp, flags,
	    allocList, 2, rf_RegularPQFunc, RF_FALSE);
d246 3
a248 2
int
rf_RegularONQFunc(RF_DagNode_t *node)
d250 2
a251 2
	int np = node->numParams;
	int d;
d253 1
a253 1
	int i;
d256 2
a257 2
	char *qbuf, *qpbuf;
	char *obuf, *nbuf;
d266 1
a266 1
	qbuf = (char *) node->params[2 * d + 1].p;	/* Q buffer. */
d274 5
a278 10
		/*
		 * The stripe unit within the stripe tells us the coefficient
		 * to use for the multiply.
		 */
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    new->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
d280 2
a281 4
		qpbuf = qbuf + rf_RaidAddressToByte(raidPtr,
		    old->startSector % secPerSU);
		rf_QDelta(qpbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr,
		    old->numSector), coeff);
d287 2
a288 4
	rf_GenericWakeupFunc(node, 0);	/*
					 * Call wake func explicitly since no
					 * I/O in this node.
					 */
d291 5
d297 1
d299 11
a309 17
/*
 * See the SimpleXORFunc for the difference between a simple and regular func.
 * These Q functions should be used for
 *	new q = Q(data, old data, old q)
 * style updates and not for
 *	q = (new data, new data, ...)
 * computations.
 *
 * The simple q takes 2(2d+1)+1 params, where d is the number
 * of stripes written. The order of params is
 *   old data pda_0, old data buffer_0, old data pda_1, old data buffer_1, ...
 *   old data pda_d, old data buffer_d
 *   [2d] old q pda_0, old q buffer
 *   [2d_2] new data pda_0, new data buffer_0, ...
 *   new data pda_d, new data buffer_d
 *   raidPtr
 */
d311 3
a313 2
int
rf_SimpleONQFunc(RF_DagNode_t *node)
d315 2
a316 2
	int np = node->numParams;
	int d;
d318 1
a318 1
	int i;
d321 2
a322 2
	char *qbuf;
	char *obuf, *nbuf;
d330 1
a330 1
	qbuf = (char *) node->params[2 * d + 1].p;	/* Q buffer. */
d338 5
a342 10
		/*
		 * The stripe unit within the stripe tells us the coefficient
		 * to use for the multiply.
		 */
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    new->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
d344 1
a344 2
		rf_QDelta(qbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr,
		    old->numSector), coeff);
d350 2
a351 4
	rf_GenericWakeupFunc(node, 0);	/*
					 * Call wake func explicitly since no
					 * I/O in this node.
					 */
a353 1

d356 1
a356 2
	rf_CommonCreateSmallWriteDAG(raidPtr, asmap, dag_h, bp, flags,
	    allocList, &rf_pFuncs, &rf_qFuncs);
d359 1
d361 4
a364 4
void rf_RegularQSubr(RF_DagNode_t *, char *);

void
rf_RegularQSubr(RF_DagNode_t *node, char *qbuf)
d366 2
a367 2
	int np = node->numParams;
	int d;
d370 1
a370 1
	int i;
d373 1
a373 1
	char *obuf, *qpbuf;
d384 3
a386 6
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    old->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
d388 5
a392 9
		/*
		 * The input buffers may not all be aligned with the start of
		 * the stripe. So shift by their sector offset within the
		 * stripe unit.
		 */
		qpbuf = qbuf + rf_RaidAddressToByte(raidPtr,
		    old->startSector % secPerSU);
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf,
		    rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
a398 2


d400 2
a401 2
 * Used in degraded writes.
 */
d403 1
a403 1
void rf_DegrQSubr(RF_DagNode_t *);
d405 3
a407 2
void
rf_DegrQSubr(RF_DagNode_t *node)
d409 2
a410 2
	int np = node->numParams;
	int d;
d413 1
d416 2
a417 2
	char *qbuf = node->results[1];
	char *obuf, *qpbuf;
d421 1
a421 1
	int i, j;
d433 3
a435 6
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    old->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
d437 3
a439 5
		/*
		 * The input buffers may not all be aligned with the start of
		 * the stripe. So shift by their sector offset within the
		 * stripe unit.
		 */
d443 1
a443 2
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf,
		    rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
d450 7
d458 3
d462 4
a465 16
/*
 * Called by large write code to compute the new parity and the new q.
 *
 * Structure of the params:
 *
 *   pda_0, buffer_0, pda_1 , buffer_1, ..., pda_d, buffer_d (d = numDataCol)
 *   raidPtr
 *
 * For a total of 2d+1 arguments.
 * The result buffers results[0], results[1] are the buffers for the p and q,
 * respectively.
 *
 * We compute Q first, then compute P. The P calculation may try to reuse
 * one of the input buffers for its output, so if we computed P first, we would
 * corrupt the input for the q calculation.
 */
d467 3
a469 2
int
rf_RegularPQFunc(RF_DagNode_t *node)
d471 2
a472 2
	rf_RegularQSubr(node, node->results[1]);
	return (rf_RegularXorFunc(node));	/* Does the wakeup. */
d475 8
a482 9
int
rf_RegularQFunc(RF_DagNode_t *node)
{
	/* Almost ... adjust Qsubr args. */
	rf_RegularQSubr(node, node->results[0]);
	rf_GenericWakeupFunc(node, 0);	/*
					 * Call wake func explicitly since no
					 * I/O in this node.
					 */
d485 4
d490 2
d493 10
a502 20
/*
 * Called by singly degraded write code to compute the new parity and
 * the new q.
 *
 * Structure of the params:
 *
 *   pda_0, buffer_0, pda_1 , buffer_1, ..., pda_d, buffer_d
 *   failedPDA raidPtr
 *
 * for a total of 2d+2 arguments.
 * The result buffers results[0], results[1] are the buffers for the parity
 * and q, respectively.
 *
 * We compute Q first, then compute parity. The parity calculation may try
 * to reuse one of the input buffers for its output, so if we computed parity
 * first, we would corrupt the input for the q calculation.
 *
 * We treat this identically to the regularPQ case, ignoring the failedPDA
 * extra argument.
 */
d504 3
a506 2
void
rf_Degraded_100_PQFunc(RF_DagNode_t *node)
d511 1
a511 1
	rf_DegrQSubr(node);
d517 8
a524 7
 * The two below are used when reading a stripe with a single lost data unit.
 * The parameters are
 *
 *  pda_0, buffer_0, ..., pda_n, buffer_n, P pda, P buffer, failedPDA, raidPtr
 *
 * and results[0] contains the data buffer, which is originally zero-filled.
 */
d526 6
a531 7
/*
 * This Q func is used by the degraded-mode dag functions to recover lost data.
 * The second-to-last parameter is the PDA for the failed portion of the
 * access. The code here looks at this PDA and assumes that the xor target
 * buffer is equal in size to the number of sectors in the failed PDA. It then
 * uses the other PDAs in the parameter list to determine where within the
 * target buffer the corresponding data should be xored.
d535 1
a535 1
 *     Q = (data_1 + 2 * data_2 ... + k * data_k) mod 256
d539 1
a539 1
 *    J data_j = (Q - data_1 - 2 data_2 ... - k * data_k) mod 256
d541 2
a542 3
 * So the coefficient for each buffer is (255 - data_col), and j should be
 * initialized by copying Q into it. Then we need to do a table lookup to
 * convert to solve
d545 1
d547 3
a549 3

int
rf_RecoveryQFunc(RF_DagNode_t *node)
d553 2
a554 3
	RF_PhysDiskAddr_t *failedPDA =
	    (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;
	int i;
d556 2
a557 4
	RF_RaidAddr_t suoffset;
	RF_RaidAddr_t failedSUOffset =
	    rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char *srcbuf, *destbuf;
d563 1
a563 1
	/* Start by copying Q into the buffer. */
d571 3
a573 5
		destbuf = ((char *) node->results[0]) +
		    rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    pda->raidAddress);
		/* Compute the data unit offset within the column. */
d575 1
a575 2
		rf_IncQ((unsigned long *) destbuf, (unsigned long *) srcbuf,
		    rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);
d577 3
a579 5
	/* Do the nasty inversion now. */
	coeff = (rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
	    failedPDA->startSector) % raidPtr->Layout.numDataCol);
	rf_InvertQ(node->results[0], node->results[0],
	    rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);
d587 3
a589 2
int
rf_RecoveryPQFunc(RF_DagNode_t *node)
d592 1
a592 1
	printf("raid%d: Recovery from PQ not implemented.\n", raidPtr->raidid);
d595 7
d603 1
d605 2
a606 12
/*
 * Degraded write Q subroutine.
 * Used when P is dead.
 * Large-write style Q computation.
 * Parameters:
 *
 * (pda, buf), (pda, buf), ..., (failedPDA, bufPtr), failedPDA, raidPtr.
 *
 * We ignore failedPDA.
 *
 * This is a "simple style" recovery func.
 */
d608 3
a610 2
void
rf_PQ_DegradedWriteQFunc(RF_DagNode_t *node)
d612 2
a613 2
	int np = node->numParams;
	int d;
d616 1
d619 2
a620 2
	char *qbuf = node->results[0];
	char *obuf, *qpbuf;
d623 1
a623 1
	int fail_start, i, j;
d636 3
a638 6
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    old->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
d643 1
a643 2
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf,
		    rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
d653 3
a655 1
/* Q computations. */
d658 7
a664 7
 * Coeff - colummn;
 *
 * Compute  dest ^= qfor[28-coeff][rn[coeff+1] a]
 *
 * On 5-bit basis;
 * Length in bytes;
 */
d666 6
a671 3
void
rf_IncQ(unsigned long *dest, unsigned long *buf, unsigned length,
    unsigned coeff)
d678 2
a679 2
#define	EXTRACT(a,i)	((a >> (5L*i)) & 0x1f)
#define	INSERT(a,i)	(a << (5L*i))
d682 1
a682 1
	/* 13 5 bit quants in a 64 bit word. */
d704 1
a704 1
#if	RF_LONGSHIFT > 2
d720 1
a720 1
#endif	/* RF_LONGSHIFT > 2 */
d726 2
d729 1
d731 2
a732 10
/*
 * Compute.
 *
 * dest ^= rf_qfor[28-coeff][rf_rn[coeff+1] (old^new)]
 *
 * On a five bit basis.
 * Optimization: compute old ^ new on 64 bit basis.
 *
 * Length in bytes.
 */
d734 9
a742 2
void
rf_QDelta(char *dest, char *obuf, char *nbuf, unsigned length,
d750 2
a751 2
	r = a1 = a2 = new = d = a = 0; /* XXX For now... */
	q = NULL; /* XXX For now */
d753 3
a755 5
#ifdef	_KERNEL
	/*
	 * PQ in kernel currently not supported because the encoding/decoding
	 * table is not present.
	 */
d757 3
a759 3
#else	/* _KERNEL */
	/* This code probably doesn't work and should be rewritten. -wvcii */
	/* 13 5 bit quants in a 64 bit word. */
d762 1
a762 3
		a = *obuf++;	/*
				 * XXX Need to reorg to avoid cache conflicts.
				 */
d785 1
a785 1
#if	RF_LONGSHIFT > 2
d801 1
a801 1
#endif	/* RF_LONGSHIFT > 2 */
d806 1
a806 1
#endif	/* _KERNEL */
d808 5
a815 6
 * Recover columns a and b from the given p and q into
 * bufs abuf and bbuf. All bufs are word aligned.
 * Length is in bytes.
 */

/*
d820 9
a828 4

void
rf_PQ_recover(unsigned long *pbuf, unsigned long *qbuf, unsigned long *abuf,
    unsigned long *bbuf, unsigned length, unsigned coeff_a, unsigned coeff_b)
d831 1
a831 1
	int col = (29 * coeff_a) + coeff_b;
d841 4
a844 7

#define	MF(i)								\
do {									\
	a0 = EXTRACT(p, i);						\
	a1 = EXTRACT(q, i);						\
	a  = a | INSERT(q0[a0<<5 | a1], i);				\
} while (0)
d859 1
a859 1
#endif	/* 0 */
d865 17
a883 17
/*
 * Lost parity and a data column. Recover that data column.
 * Assume col coeff is lost. Let q the contents of Q after
 * all surviving data columns have been q-xored out of it.
 * Then we have the equation
 *
 *   q[28-coeff][a_i ^ r_i+1] = q
 *
 * but q is cyclic with period 31.
 * So q[3+coeff][q[28-coeff][a_i ^ r_{i+1}]] =
 *    q[31][a_i ^ r_{i+1}] = a_i ^ r_{i+1} .
 *
 * so a_i = r_{coeff+1} ^ q[3+coeff][q]
 *
 * The routine is passed q buffer and the buffer
 * the data is to be recoverd into. They can be the same.
 */
d885 5
a889 2
void
rf_InvertQ(unsigned long *qbuf, unsigned long *abuf, unsigned length,
d897 1
a897 1
	/* 13 5 bit quants in a 64 bit word. */
d906 6
a911 9

#define	M(i,j)								\
do {									\
	a1 = EXTRACT(a, i);						\
	a2 = EXTRACT(a, j);						\
	a1 = r ^ q[a1];							\
	a2 = r ^ q[a2];							\
	new = new | INSERT(a1, i) | INSERT(a2, j);			\
} while (0)
d916 1
a916 1
#if	RF_LONGSHIFT > 2
d920 1
a920 1
#endif	/* RF_LONGSHIFT > 2 */
d925 2
a926 1
#endif	/* (RF_INCLUDE_DECL_PQ > 0) || (RF_INCLUDE_RAID6 > 0) */
@


1.5.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d50 2
a51 8
RF_RedFuncs_t rf_pFuncs = {
	rf_RegularONPFunc, "Regular Old-New P",
	rf_SimpleONPFunc, "Simple Old-New P"
};
RF_RedFuncs_t rf_pRecoveryFuncs = {
	rf_RecoveryPFunc, "Recovery P Func",
	rf_RecoveryPFunc, "Recovery P Func"
};
d53 3
a55 2
int
rf_RegularONPFunc(RF_DagNode_t *node)
a58 2


d60 2
a61 2
 * Same as simpleONQ func, but the coefficient is always 1.
 */
d63 3
a65 2
int
rf_SimpleONPFunc(RF_DagNode_t *node)
d70 3
a72 2
int
rf_RecoveryPFunc(RF_DagNode_t *node)
d77 3
a79 2
int
rf_RegularPFunc(RF_DagNode_t *node)
d83 1
d85 17
a101 24

#if	(RF_INCLUDE_DECL_PQ > 0) || (RF_INCLUDE_RAID6 > 0)

void rf_QDelta(char *dest, char *obuf, char *nbuf, unsigned length,
	unsigned char coeff);
void rf_InvertQ(unsigned long *qbuf, unsigned long *abuf, unsigned length,
	unsigned coeff);

RF_RedFuncs_t rf_qFuncs = {
	rf_RegularONQFunc, "Regular Old-New Q",
	rf_SimpleONQFunc, "Simple Old-New Q"
};
RF_RedFuncs_t rf_qRecoveryFuncs = {
	rf_RecoveryQFunc, "Recovery Q Func",
	rf_RecoveryQFunc, "Recovery Q Func"
};
RF_RedFuncs_t rf_pqRecoveryFuncs = {
	rf_RecoveryPQFunc, "Recovery PQ Func",
	rf_RecoveryPQFunc, "Recovery PQ Func"
};

void
rf_PQDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmap, RF_VoidFuncPtr *createFunc)
d110 1
a110 2
		RF_ERRORMSG("more than two disks failed in a single group !"
		            "  Aborting I/O operation.\n");
d114 1
a114 1
	/* Ok, we can do this I/O. */
d118 2
a119 3
			/* Fault free read. */
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateFaultFreeReadDAG;	/* Same as raid 5. */
d122 7
a128 12
			/* Lost a single data unit. */
			/*
			 * Two cases:
			 * (1) Parity is not lost. Do a normal raid 5
			 *     reconstruct read.
			 * (2) Parity is lost. Do a reconstruct read using "q".
			 */
			if (ntfail == 2) {	/* Also lost redundancy. */
				if (asmap->failedPDAs[1]->type ==
				    RF_PDA_TYPE_PARITY)
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_110_CreateReadDAG;
d130 1
a130 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_101_CreateReadDAG;
d132 4
a135 8
				/*
				 * P and Q are ok. But is there a failure in
				 * some unaccessed data unit ?
				 */
				if (rf_NumFailedDataUnitsInStripe(raidPtr,
				    asmap) == 2)
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_200_CreateReadDAG;
d137 1
a137 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_100_CreateReadDAG;
d141 2
a142 2
			/* Lost two data units. */
			/* *infoFunc = rf_PQOneTwo; */
d148 1
a148 1
	/* A write. */
d150 1
a150 1
	case 0:		/* Fault free. */
d152 2
a153 6
		    (((asmap->numStripeUnitsAccessed <=
		       (layoutPtr->numDataCol / 2)) &&
		      (layoutPtr->numDataCol != 1)) ||
		     (asmap->parityInfo->next != NULL) ||
		     (asmap->qInfo->next != NULL) ||
		     rf_CheckStripeForFailures(raidPtr, asmap))) {
d161 1
a161 1
	case 1:		/* Single disk fault. */
d163 7
a169 14
			RF_ASSERT((asmap->failedPDAs[0]->type ==
			    RF_PDA_TYPE_PARITY) ||
			    (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));
			if (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {
				/*
				 * Q died, treat like normal mode raid5 write.
				 */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_001_CreateSmallWriteDAG;
d171 5
a175 10
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_001_CreateLargeWriteDAG;
			} else {/* Parity died, small write only updating Q. */
				if (((asmap->numStripeUnitsAccessed <=
				      (layoutPtr->numDataCol / 2)) ||
				     (asmap->numStripeUnitsAccessed == 1)) ||
				    rf_NumFailedDataUnitsInStripe(raidPtr,
				     asmap))
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_010_CreateSmallWriteDAG;
d177 1
a177 2
					*createFunc = (RF_VoidFuncPtr)
					    rf_PQ_010_CreateLargeWriteDAG;
d179 1
a179 2
		} else {	/*
				 * Data missing. Do a P reconstruct write if
d181 1
a181 2
				 * stripe, otherwise a PQ reconstruct write.
				 */
d183 1
a183 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_200_CreateWriteDAG;
d185 1
a185 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_100_CreateWriteDAG;
d189 1
a189 1
	case 2:		/* Two disk faults. */
d191 1
a191 1
		case 2:	/* Both p and q dead. */
d194 3
a196 7
		case 1:	/* Either p or q and dead data. */
			RF_ASSERT(asmap->failedPDAs[0]->type ==
			          RF_PDA_TYPE_DATA);
			RF_ASSERT((asmap->failedPDAs[1]->type ==
			           RF_PDA_TYPE_PARITY) ||
			          (asmap->failedPDAs[1]->type ==
			           RF_PDA_TYPE_Q));
d198 1
a198 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_101_CreateWriteDAG;
d200 1
a200 2
				*createFunc = (RF_VoidFuncPtr)
				    rf_PQ_110_CreateWriteDAG;
d202 1
a202 1
		case 0:	/* Double data loss. */
d208 1
a208 1
	default:	/* More than 2 disk faults. */
a213 2


d215 2
a216 2
 * Used as a stop gap info function.
 */
d218 6
a223 3
void
rf_PQOne(RF_Raid_t *raidPtr, int *nSucc, int *nAnte,
    RF_AccessStripeMap_t *asmap)
d228 6
a233 3
void
rf_PQOneTwo(RF_Raid_t *raidPtr, int *nSucc, int *nAnte,
    RF_AccessStripeMap_t *asmap)
d242 2
a243 2
	rf_CommonCreateLargeWriteDAG(raidPtr, asmap, dag_h, bp, flags,
	    allocList, 2, rf_RegularPQFunc, RF_FALSE);
d246 3
a248 2
int
rf_RegularONQFunc(RF_DagNode_t *node)
d250 2
a251 2
	int np = node->numParams;
	int d;
d253 1
a253 1
	int i;
d256 2
a257 2
	char *qbuf, *qpbuf;
	char *obuf, *nbuf;
d266 1
a266 1
	qbuf = (char *) node->params[2 * d + 1].p;	/* Q buffer. */
d274 5
a278 10
		/*
		 * The stripe unit within the stripe tells us the coefficient
		 * to use for the multiply.
		 */
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    new->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
d280 2
a281 4
		qpbuf = qbuf + rf_RaidAddressToByte(raidPtr,
		    old->startSector % secPerSU);
		rf_QDelta(qpbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr,
		    old->numSector), coeff);
d287 2
a288 4
	rf_GenericWakeupFunc(node, 0);	/*
					 * Call wake func explicitly since no
					 * I/O in this node.
					 */
d291 5
d297 1
d299 11
a309 17
/*
 * See the SimpleXORFunc for the difference between a simple and regular func.
 * These Q functions should be used for
 *	new q = Q(data, old data, old q)
 * style updates and not for
 *	q = (new data, new data, ...)
 * computations.
 *
 * The simple q takes 2(2d+1)+1 params, where d is the number
 * of stripes written. The order of params is
 *   old data pda_0, old data buffer_0, old data pda_1, old data buffer_1, ...
 *   old data pda_d, old data buffer_d
 *   [2d] old q pda_0, old q buffer
 *   [2d_2] new data pda_0, new data buffer_0, ...
 *   new data pda_d, new data buffer_d
 *   raidPtr
 */
d311 3
a313 2
int
rf_SimpleONQFunc(RF_DagNode_t *node)
d315 2
a316 2
	int np = node->numParams;
	int d;
d318 1
a318 1
	int i;
d321 2
a322 2
	char *qbuf;
	char *obuf, *nbuf;
d330 1
a330 1
	qbuf = (char *) node->params[2 * d + 1].p;	/* Q buffer. */
d338 5
a342 10
		/*
		 * The stripe unit within the stripe tells us the coefficient
		 * to use for the multiply.
		 */
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    new->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
d344 1
a344 2
		rf_QDelta(qbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr,
		    old->numSector), coeff);
d350 2
a351 4
	rf_GenericWakeupFunc(node, 0);	/*
					 * Call wake func explicitly since no
					 * I/O in this node.
					 */
a353 1

d356 1
a356 2
	rf_CommonCreateSmallWriteDAG(raidPtr, asmap, dag_h, bp, flags,
	    allocList, &rf_pFuncs, &rf_qFuncs);
d359 1
d361 4
a364 4
void rf_RegularQSubr(RF_DagNode_t *, char *);

void
rf_RegularQSubr(RF_DagNode_t *node, char *qbuf)
d366 2
a367 2
	int np = node->numParams;
	int d;
d370 1
a370 1
	int i;
d373 1
a373 1
	char *obuf, *qpbuf;
d384 3
a386 6
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    old->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
d388 5
a392 9
		/*
		 * The input buffers may not all be aligned with the start of
		 * the stripe. So shift by their sector offset within the
		 * stripe unit.
		 */
		qpbuf = qbuf + rf_RaidAddressToByte(raidPtr,
		    old->startSector % secPerSU);
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf,
		    rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
a398 2


d400 2
a401 2
 * Used in degraded writes.
 */
d403 1
a403 1
void rf_DegrQSubr(RF_DagNode_t *);
d405 3
a407 2
void
rf_DegrQSubr(RF_DagNode_t *node)
d409 2
a410 2
	int np = node->numParams;
	int d;
d413 1
d416 2
a417 2
	char *qbuf = node->results[1];
	char *obuf, *qpbuf;
d421 1
a421 1
	int i, j;
d433 3
a435 6
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    old->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
d437 3
a439 5
		/*
		 * The input buffers may not all be aligned with the start of
		 * the stripe. So shift by their sector offset within the
		 * stripe unit.
		 */
d443 1
a443 2
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf,
		    rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
d450 7
d458 3
d462 4
a465 16
/*
 * Called by large write code to compute the new parity and the new q.
 *
 * Structure of the params:
 *
 *   pda_0, buffer_0, pda_1 , buffer_1, ..., pda_d, buffer_d (d = numDataCol)
 *   raidPtr
 *
 * For a total of 2d+1 arguments.
 * The result buffers results[0], results[1] are the buffers for the p and q,
 * respectively.
 *
 * We compute Q first, then compute P. The P calculation may try to reuse
 * one of the input buffers for its output, so if we computed P first, we would
 * corrupt the input for the q calculation.
 */
d467 3
a469 2
int
rf_RegularPQFunc(RF_DagNode_t *node)
d471 2
a472 2
	rf_RegularQSubr(node, node->results[1]);
	return (rf_RegularXorFunc(node));	/* Does the wakeup. */
d475 8
a482 9
int
rf_RegularQFunc(RF_DagNode_t *node)
{
	/* Almost ... adjust Qsubr args. */
	rf_RegularQSubr(node, node->results[0]);
	rf_GenericWakeupFunc(node, 0);	/*
					 * Call wake func explicitly since no
					 * I/O in this node.
					 */
d485 4
d490 2
d493 10
a502 20
/*
 * Called by singly degraded write code to compute the new parity and
 * the new q.
 *
 * Structure of the params:
 *
 *   pda_0, buffer_0, pda_1 , buffer_1, ..., pda_d, buffer_d
 *   failedPDA raidPtr
 *
 * for a total of 2d+2 arguments.
 * The result buffers results[0], results[1] are the buffers for the parity
 * and q, respectively.
 *
 * We compute Q first, then compute parity. The parity calculation may try
 * to reuse one of the input buffers for its output, so if we computed parity
 * first, we would corrupt the input for the q calculation.
 *
 * We treat this identically to the regularPQ case, ignoring the failedPDA
 * extra argument.
 */
d504 3
a506 2
void
rf_Degraded_100_PQFunc(RF_DagNode_t *node)
d511 1
a511 1
	rf_DegrQSubr(node);
d517 8
a524 7
 * The two below are used when reading a stripe with a single lost data unit.
 * The parameters are
 *
 *  pda_0, buffer_0, ..., pda_n, buffer_n, P pda, P buffer, failedPDA, raidPtr
 *
 * and results[0] contains the data buffer, which is originally zero-filled.
 */
d526 6
a531 7
/*
 * This Q func is used by the degraded-mode dag functions to recover lost data.
 * The second-to-last parameter is the PDA for the failed portion of the
 * access. The code here looks at this PDA and assumes that the xor target
 * buffer is equal in size to the number of sectors in the failed PDA. It then
 * uses the other PDAs in the parameter list to determine where within the
 * target buffer the corresponding data should be xored.
d535 1
a535 1
 *     Q = (data_1 + 2 * data_2 ... + k * data_k) mod 256
d539 1
a539 1
 *    J data_j = (Q - data_1 - 2 data_2 ... - k * data_k) mod 256
d541 2
a542 3
 * So the coefficient for each buffer is (255 - data_col), and j should be
 * initialized by copying Q into it. Then we need to do a table lookup to
 * convert to solve
d545 1
d547 3
a549 3

int
rf_RecoveryQFunc(RF_DagNode_t *node)
d553 2
a554 3
	RF_PhysDiskAddr_t *failedPDA =
	    (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;
	int i;
d556 2
a557 4
	RF_RaidAddr_t suoffset;
	RF_RaidAddr_t failedSUOffset =
	    rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);
	char *srcbuf, *destbuf;
d563 1
a563 1
	/* Start by copying Q into the buffer. */
d571 3
a573 5
		destbuf = ((char *) node->results[0]) +
		    rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    pda->raidAddress);
		/* Compute the data unit offset within the column. */
d575 1
a575 2
		rf_IncQ((unsigned long *) destbuf, (unsigned long *) srcbuf,
		    rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);
d577 3
a579 5
	/* Do the nasty inversion now. */
	coeff = (rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
	    failedPDA->startSector) % raidPtr->Layout.numDataCol);
	rf_InvertQ(node->results[0], node->results[0],
	    rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);
d587 3
a589 2
int
rf_RecoveryPQFunc(RF_DagNode_t *node)
d592 1
a592 1
	printf("raid%d: Recovery from PQ not implemented.\n", raidPtr->raidid);
d595 7
d603 1
d605 2
a606 12
/*
 * Degraded write Q subroutine.
 * Used when P is dead.
 * Large-write style Q computation.
 * Parameters:
 *
 * (pda, buf), (pda, buf), ..., (failedPDA, bufPtr), failedPDA, raidPtr.
 *
 * We ignore failedPDA.
 *
 * This is a "simple style" recovery func.
 */
d608 3
a610 2
void
rf_PQ_DegradedWriteQFunc(RF_DagNode_t *node)
d612 2
a613 2
	int np = node->numParams;
	int d;
d616 1
d619 2
a620 2
	char *qbuf = node->results[0];
	char *obuf, *qpbuf;
d623 1
a623 1
	int fail_start, i, j;
d636 3
a638 6
		coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),
		    old->raidAddress);
		/*
		 * Compute the data unit offset within the column, then add
		 * one.
		 */
d643 1
a643 2
		rf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf,
		    rf_RaidAddressToByte(raidPtr, old->numSector), coeff);
d653 3
a655 1
/* Q computations. */
d658 7
a664 7
 * Coeff - colummn;
 *
 * Compute  dest ^= qfor[28-coeff][rn[coeff+1] a]
 *
 * On 5-bit basis;
 * Length in bytes;
 */
d666 6
a671 3
void
rf_IncQ(unsigned long *dest, unsigned long *buf, unsigned length,
    unsigned coeff)
d678 2
a679 2
#define	EXTRACT(a,i)	((a >> (5L*i)) & 0x1f)
#define	INSERT(a,i)	(a << (5L*i))
d682 1
a682 1
	/* 13 5 bit quants in a 64 bit word. */
d704 1
a704 1
#if	RF_LONGSHIFT > 2
d720 1
a720 1
#endif	/* RF_LONGSHIFT > 2 */
d726 2
d729 1
d731 2
a732 10
/*
 * Compute.
 *
 * dest ^= rf_qfor[28-coeff][rf_rn[coeff+1] (old^new)]
 *
 * On a five bit basis.
 * Optimization: compute old ^ new on 64 bit basis.
 *
 * Length in bytes.
 */
d734 9
a742 2
void
rf_QDelta(char *dest, char *obuf, char *nbuf, unsigned length,
d750 2
a751 2
	r = a1 = a2 = new = d = a = 0; /* XXX For now... */
	q = NULL; /* XXX For now */
d753 3
a755 5
#ifdef	_KERNEL
	/*
	 * PQ in kernel currently not supported because the encoding/decoding
	 * table is not present.
	 */
d757 3
a759 3
#else	/* _KERNEL */
	/* This code probably doesn't work and should be rewritten. -wvcii */
	/* 13 5 bit quants in a 64 bit word. */
d762 1
a762 3
		a = *obuf++;	/*
				 * XXX Need to reorg to avoid cache conflicts.
				 */
d785 1
a785 1
#if	RF_LONGSHIFT > 2
d801 1
a801 1
#endif	/* RF_LONGSHIFT > 2 */
d806 1
a806 1
#endif	/* _KERNEL */
d808 5
a815 6
 * Recover columns a and b from the given p and q into
 * bufs abuf and bbuf. All bufs are word aligned.
 * Length is in bytes.
 */

/*
d820 9
a828 4

void
rf_PQ_recover(unsigned long *pbuf, unsigned long *qbuf, unsigned long *abuf,
    unsigned long *bbuf, unsigned length, unsigned coeff_a, unsigned coeff_b)
d831 1
a831 1
	int col = (29 * coeff_a) + coeff_b;
d841 4
a844 7

#define	MF(i)								\
do {									\
	a0 = EXTRACT(p, i);						\
	a1 = EXTRACT(q, i);						\
	a  = a | INSERT(q0[a0<<5 | a1], i);				\
} while (0)
d859 1
a859 1
#endif	/* 0 */
d865 17
a883 17
/*
 * Lost parity and a data column. Recover that data column.
 * Assume col coeff is lost. Let q the contents of Q after
 * all surviving data columns have been q-xored out of it.
 * Then we have the equation
 *
 *   q[28-coeff][a_i ^ r_i+1] = q
 *
 * but q is cyclic with period 31.
 * So q[3+coeff][q[28-coeff][a_i ^ r_{i+1}]] =
 *    q[31][a_i ^ r_{i+1}] = a_i ^ r_{i+1} .
 *
 * so a_i = r_{coeff+1} ^ q[3+coeff][q]
 *
 * The routine is passed q buffer and the buffer
 * the data is to be recoverd into. They can be the same.
 */
d885 5
a889 2
void
rf_InvertQ(unsigned long *qbuf, unsigned long *abuf, unsigned length,
d897 1
a897 1
	/* 13 5 bit quants in a 64 bit word. */
d906 6
a911 9

#define	M(i,j)								\
do {									\
	a1 = EXTRACT(a, i);						\
	a2 = EXTRACT(a, j);						\
	a1 = r ^ q[a1];							\
	a2 = r ^ q[a2];							\
	new = new | INSERT(a1, i) | INSERT(a2, j);			\
} while (0)
d916 1
a916 1
#if	RF_LONGSHIFT > 2
d920 1
a920 1
#endif	/* RF_LONGSHIFT > 2 */
d925 2
a926 1
#endif	/* (RF_INCLUDE_DECL_PQ > 0) || (RF_INCLUDE_RAID6 > 0) */
@


1.4
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_pq.c,v 1.3 1999/08/04 13:10:55 peter Exp $	*/
/*	$NetBSD: rf_pq.c,v 1.6 1999/08/15 03:44:46 oster Exp $	*/
a43 1
#include "rf_threadid.h"
@


1.3
log
@* remove redundant rf_ccmn.h

* remove init call to rf_ConfigureEtimer() and rf_sys.c in which it is the
  only function. update conf/files to reflect this.

* update sources to make sure _KERNEL is used not KERNEL

* change rf_etimer.h to protect macros an include of sys/kernel.h with
  a check for _KERNEL - let raidctl compile again.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_pq.c,v 1.2 1999/02/16 00:03:09 niklas Exp $	*/
/*	$NetBSD: rf_pq.c,v 1.3 1999/02/05 00:06:14 oster Exp $	*/
a49 1
#include "rf_sys.h"
d120 1
a120 1
			*createFunc = rf_CreateFaultFreeReadDAG;	/* same as raid 5 */
d129 1
a129 1
					*createFunc = rf_PQ_110_CreateReadDAG;
d131 1
a131 1
					*createFunc = rf_PQ_101_CreateReadDAG;
d136 1
a136 1
					*createFunc = rf_PQ_200_CreateReadDAG;
d138 1
a138 1
					*createFunc = rf_PQ_100_CreateReadDAG;
d144 1
a144 1
			*createFunc = rf_PQ_200_CreateReadDAG;
d156 1
a156 1
			*createFunc = rf_PQCreateSmallWriteDAG;
d158 1
a158 1
			*createFunc = rf_PQCreateLargeWriteDAG;
d170 1
a170 1
					*createFunc = rf_PQ_001_CreateSmallWriteDAG;
d172 1
a172 1
					*createFunc = rf_PQ_001_CreateLargeWriteDAG;
d176 1
a176 1
					*createFunc = rf_PQ_010_CreateSmallWriteDAG;
d178 1
a178 1
					*createFunc = rf_PQ_010_CreateLargeWriteDAG;
d184 1
a184 1
				*createFunc = rf_PQ_200_CreateWriteDAG;
d186 1
a186 1
				*createFunc = rf_PQ_100_CreateWriteDAG;
d193 1
a193 1
			*createFunc = rf_PQ_011_CreateWriteDAG;
d199 1
a199 1
				*createFunc = rf_PQ_101_CreateWriteDAG;
d201 1
a201 1
				*createFunc = rf_PQ_110_CreateWriteDAG;
d204 1
a204 1
			*createFunc = rf_PQ_200_CreateWriteDAG;
d218 1
d239 2
d360 2
d404 2
d592 2
a593 1
	RF_PANIC();
d749 4
a752 1
	unsigned r = rf_rn[coeff + 1];
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_pq.c,v 1.1 1999/01/11 14:29:38 niklas Exp $	*/
d748 1
a748 1
#else				/* KERNEL */
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_pq.c,v 1.1 1998/11/13 04:20:32 oster Exp $	*/
/*	$NetBSD: rf_pq.c,v 1.1 1998/11/13 04:20:32 oster Exp $	*/
a31 100
 *
 * :  
 * Log: rf_pq.c,v 
 * Revision 1.33  1996/11/05 21:10:40  jimz
 * failed pda generalization
 *
 * Revision 1.32  1996/07/31  16:29:50  jimz
 * "fix" math on 32-bit machines using RF_LONGSHIFT
 * (may be incorrect)
 *
 * Revision 1.31  1996/07/31  15:35:01  jimz
 * evenodd changes; bugfixes for double-degraded archs, generalize
 * some formerly PQ-only functions
 *
 * Revision 1.30  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.29  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.28  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.27  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.26  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.25  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.24  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.23  1996/05/30  12:59:18  jimz
 * make etimer happier, more portable
 *
 * Revision 1.22  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.21  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.20  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.19  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.18  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.17  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.16  1996/05/17  14:52:04  wvcii
 * added prototyping to QDelta()
 *   - changed buf params from volatile unsigned long * to char *
 * changed QDelta for kernel
 *   - just bzero the buf since kernel doesn't include pq decode table
 *
 * Revision 1.15  1996/05/03  19:40:20  wvcii
 * added includes for dag library
 *
 * Revision 1.14  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.13  1995/11/30  16:19:55  wvcii
 * added copyright info
 *
 * Revision 1.12  1995/11/07  16:13:47  wvcii
 * changed PQDagSelect prototype
 * function no longer returns numHdrSucc, numTermAnt
 * note:  this file contains node functions which should be
 * moved to rf_dagfuncs.c so that all node funcs are bundled together
 *
 * Revision 1.11  1995/10/04  03:50:33  wvcii
 * removed panics, minor code cleanup in dag selection
 *
 *
d52 2
a53 2
RF_RedFuncs_t rf_pFuncs = { rf_RegularONPFunc, "Regular Old-New P", rf_SimpleONPFunc, "Simple Old-New P" };
RF_RedFuncs_t rf_pRecoveryFuncs = { rf_RecoveryPFunc, "Recovery P Func", rf_RecoveryPFunc, "Recovery P Func" };
d55 3
a57 2
int rf_RegularONPFunc(node)
  RF_DagNode_t  *node;
d59 1
a59 1
  return(rf_RegularXorFunc(node));
a60 1

d62 1
a62 1
   same as simpleONQ func, but the coefficient is always 1 
d65 3
a67 2
int rf_SimpleONPFunc(node)
  RF_DagNode_t  *node;
d69 1
a69 1
  return(rf_SimpleXorFunc(node));
d72 3
a74 2
int rf_RecoveryPFunc(node)
RF_DagNode_t *node;
d76 1
a76 1
  return(rf_RecoveryXorFunc(node));
d79 3
a81 2
int rf_RegularPFunc(node)
  RF_DagNode_t  *node;
d83 1
a83 1
  return(rf_RegularXorFunc(node));
a84 1

d87 28
a114 68
static void QDelta(char *dest, char *obuf, char *nbuf, unsigned length,
	unsigned char coeff);
static void rf_InvertQ(unsigned long *qbuf, unsigned long *abuf,
	unsigned length, unsigned coeff);

RF_RedFuncs_t rf_qFuncs = { rf_RegularONQFunc, "Regular Old-New Q", rf_SimpleONQFunc, "Simple Old-New Q" };
RF_RedFuncs_t rf_qRecoveryFuncs = { rf_RecoveryQFunc, "Recovery Q Func", rf_RecoveryQFunc, "Recovery Q Func" };
RF_RedFuncs_t rf_pqRecoveryFuncs = { rf_RecoveryPQFunc, "Recovery PQ Func", rf_RecoveryPQFunc, "Recovery PQ Func" };

void rf_PQDagSelect(
  RF_Raid_t             *raidPtr,
  RF_IoType_t            type,
  RF_AccessStripeMap_t  *asmap,
  RF_VoidFuncPtr        *createFunc)
{
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);
  unsigned ndfail = asmap->numDataFailed;
  unsigned npfail = asmap->numParityFailed;
  unsigned ntfail = npfail + ndfail;

  RF_ASSERT(RF_IO_IS_R_OR_W(type));
  if (ntfail > 2) 
    {
      RF_ERRORMSG("more than two disks failed in a single group!  Aborting I/O operation.\n");
      /* *infoFunc = */ *createFunc = NULL;
      return;
    }

  /* ok, we can do this I/O */
  if (type == RF_IO_TYPE_READ)
    {
      switch (ndfail)
	{
	case 0:
	  /* fault free read */
	  *createFunc = rf_CreateFaultFreeReadDAG;   /* same as raid 5 */
	  break;
	case 1:
	  /* lost a single data unit */
	  /* two cases:
	        (1) parity is not lost.
		    do a normal raid 5 reconstruct read.
		(2) parity is lost.
		    do a reconstruct read using "q".
          */
	  if (ntfail == 2) /* also lost redundancy */
	    {
	      if (asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) 
		*createFunc = rf_PQ_110_CreateReadDAG; 
	      else
		*createFunc = rf_PQ_101_CreateReadDAG; 
	    }
	  else
	    {
	      /* P and Q are ok. But is there a failure
		 in some unaccessed data unit?
              */
	      if (rf_NumFailedDataUnitsInStripe(raidPtr,asmap)==2)
		*createFunc = rf_PQ_200_CreateReadDAG; 
	      else
		  *createFunc = rf_PQ_100_CreateReadDAG; 
	    }
	  break;
	case 2:
	  /* lost two data units */
	  /* *infoFunc = PQOneTwo; */
	  *createFunc = rf_PQ_200_CreateReadDAG; 
	  break;
d116 33
a148 38
      return;
    }

  /* a write */
  switch (ntfail)
    {
    case 0: /* fault free */
      if (rf_suppressLocksAndLargeWrites ||
	  (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||
	   (asmap->parityInfo->next != NULL) || (asmap->qInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {
	
	*createFunc = rf_PQCreateSmallWriteDAG;
      }
      else {
	*createFunc = rf_PQCreateLargeWriteDAG;
      }
      break;

    case 1: /* single disk fault */
      if (npfail==1) 
	{
	  RF_ASSERT ((asmap->failedPDAs[0]->type == RF_PDA_TYPE_PARITY) ||  (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));
	  if (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q)
	    { /* q died, treat like normal mode raid5 write.*/
	      if (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))
		  || rf_NumFailedDataUnitsInStripe(raidPtr,asmap))
		*createFunc = rf_PQ_001_CreateSmallWriteDAG;
	      else
		*createFunc = rf_PQ_001_CreateLargeWriteDAG;
	    }
	  else
	    { /* parity died, small write only updating Q */
	      if (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))
		  || rf_NumFailedDataUnitsInStripe(raidPtr,asmap))
		*createFunc = rf_PQ_010_CreateSmallWriteDAG;
	      else
		*createFunc = rf_PQ_010_CreateLargeWriteDAG;
	    }
d150 63
a212 9
      else
	{ /* data missing. 
	     Do a P reconstruct write if only a single data unit
	     is lost in the stripe, otherwise a PQ reconstruct
	     write. */
	  if (rf_NumFailedDataUnitsInStripe(raidPtr,asmap)==2)
	    *createFunc = rf_PQ_200_CreateWriteDAG;
	  else
	    *createFunc = rf_PQ_100_CreateWriteDAG;
d214 1
a214 27
      break;

    case 2: /* two disk faults */
      switch (npfail)
	{
	case 2: /* both p and q dead */
	  *createFunc = rf_PQ_011_CreateWriteDAG;
	  break;
	case 1: /* either p or q and dead data */
	  RF_ASSERT(asmap->failedPDAs[0]->type == RF_PDA_TYPE_DATA);
	  RF_ASSERT ((asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) ||  (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));
	  if (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q)
	    *createFunc = rf_PQ_101_CreateWriteDAG;
	  else
	    *createFunc = rf_PQ_110_CreateWriteDAG;
	  break;
	case 0: /* double data loss */
	  *createFunc = rf_PQ_200_CreateWriteDAG;
	  break;
	}
      break;

    default:  /* more than 2 disk faults */
      *createFunc = NULL;
      RF_PANIC();
    }
  return;
a215 1

d217 1
a217 1
   Used as a stop gap info function 
d219 6
a224 14
static void PQOne(raidPtr, nSucc, nAnte, asmap)
  RF_Raid_t             *raidPtr;
  int                   *nSucc;
  int                   *nAnte;
  RF_AccessStripeMap_t  *asmap;
{
  *nSucc = *nAnte = 1;
}

static void PQOneTwo(raidPtr, nSucc, nAnte, asmap)
  RF_Raid_t             *raidPtr;
  int                   *nSucc;
  int                   *nAnte;
  RF_AccessStripeMap_t  *asmap;
d226 1
a226 2
  *nSucc = 1;
  *nAnte = 2;
d229 10
d241 2
a242 2
  rf_CommonCreateLargeWriteDAG(raidPtr, asmap, dag_h, bp, flags, allocList, 2,
    rf_RegularPQFunc, RF_FALSE);
d245 44
a288 42
int rf_RegularONQFunc(node)
  RF_DagNode_t  *node;
{
  int np = node->numParams;
  int d;
  RF_Raid_t *raidPtr = (RF_Raid_t *)node->params[np-1].p;
  int i;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;
  char *qbuf, *qpbuf;
  char *obuf, *nbuf;
  RF_PhysDiskAddr_t *old, *new;
  unsigned long coeff;
  unsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;

  RF_ETIMER_START(timer);

  d = (np-3)/4;
  RF_ASSERT (4*d+3 == np);
  qbuf = (char *) node->params[2*d+1].p; /* q buffer*/
  for (i=0; i < d; i++)
    {
      old  = (RF_PhysDiskAddr_t *) node->params[2*i].p;
      obuf = (char *) node->params[2*i+1].p;
      new  = (RF_PhysDiskAddr_t *) node->params[2*(d+1+i)].p;
      nbuf = (char *) node->params[2*(d+1+i)+1].p;
      RF_ASSERT (new->numSector == old->numSector);
      RF_ASSERT (new->raidAddress == old->raidAddress);
      /* the stripe unit within the stripe tells us the coefficient to use
	 for the multiply. */
      coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),new->raidAddress);
      /* compute the data unit offset within the column, then add one */
      coeff = (coeff % raidPtr->Layout.numDataCol);
      qpbuf = qbuf + rf_RaidAddressToByte(raidPtr,old->startSector % secPerSU);
      QDelta(qpbuf,obuf,nbuf, rf_RaidAddressToByte(raidPtr, old->numSector),coeff);
    }

  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  tracerec->q_us += RF_ETIMER_VAL_US(timer);
  rf_GenericWakeupFunc(node, 0);     /* call wake func explicitly since no I/O in this node */
  return(0);
a289 1

d292 3
a294 1
   These Q functions should be used for 
d296 1
a296 1
         new q = Q(data,old data,old q) 
a297 2
   style updates and not for 
           
d310 42
a351 40
int rf_SimpleONQFunc(node)
  RF_DagNode_t  *node;
{
  int np = node->numParams;
  int d;
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np-1].p;
  int i;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;
  char *qbuf;
  char *obuf, *nbuf;
  RF_PhysDiskAddr_t *old, *new;
  unsigned long coeff;

  RF_ETIMER_START(timer);

  d = (np-3)/4;
  RF_ASSERT (4*d+3 == np);
  qbuf = (char *) node->params[2*d+1].p; /* q buffer*/
  for (i=0; i < d; i++)
    {
      old  = (RF_PhysDiskAddr_t *) node->params[2*i].p;
      obuf = (char *) node->params[2*i+1].p;
      new  = (RF_PhysDiskAddr_t *) node->params[2*(d+1+i)].p;
      nbuf = (char *) node->params[2*(d+1+i)+1].p;
      RF_ASSERT (new->numSector == old->numSector);
      RF_ASSERT (new->raidAddress == old->raidAddress);
      /* the stripe unit within the stripe tells us the coefficient to use
	 for the multiply. */
      coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),new->raidAddress);
      /* compute the data unit offset within the column, then add one */
      coeff = (coeff % raidPtr->Layout.numDataCol);
      QDelta(qbuf,obuf,nbuf, rf_RaidAddressToByte(raidPtr, old->numSector),coeff);
    }

  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  tracerec->q_us += RF_ETIMER_VAL_US(timer);
  rf_GenericWakeupFunc(node, 0);     /* call wake func explicitly since no I/O in this node */
  return(0);
a352 1

d355 1
a355 1
  rf_CommonCreateSmallWriteDAG(raidPtr, asmap, dag_h, bp, flags, allocList, &rf_pFuncs, &rf_qFuncs);
d358 37
a394 35
static void RegularQSubr(node,qbuf)
  RF_DagNode_t  *node;
  char          *qbuf;
{
  int np = node->numParams;
  int d;
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np-1].p;
  unsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;
  int i;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;
  char *obuf, *qpbuf;
  RF_PhysDiskAddr_t *old;
  unsigned long coeff;
  
  RF_ETIMER_START(timer);

  d = (np-1)/2;
  RF_ASSERT (2*d+1 == np);
  for (i=0; i < d; i++)
    {
      old  = (RF_PhysDiskAddr_t *) node->params[2*i].p;
      obuf = (char *) node->params[2*i+1].p;
      coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),old->raidAddress);
      /* compute the data unit offset within the column, then add one */
      coeff = (coeff % raidPtr->Layout.numDataCol);
      /* the input buffers may not all be aligned with the start of the
	 stripe. so shift by their sector offset within the stripe unit */
      qpbuf = qbuf + rf_RaidAddressToByte(raidPtr,old->startSector % secPerSU);
      rf_IncQ((unsigned long *)qpbuf,(unsigned long *)obuf,rf_RaidAddressToByte(raidPtr, old->numSector),coeff);
    }

  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  tracerec->q_us += RF_ETIMER_VAL_US(timer);
a395 1

d400 44
a443 42
static void DegrQSubr(node)
  RF_DagNode_t  *node;
{
  int np = node->numParams;
  int d;
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np-1].p;
  unsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;
  int i;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;
  char *qbuf = node->results[1];
  char *obuf, *qpbuf;
  RF_PhysDiskAddr_t *old;
  unsigned long coeff;
  unsigned fail_start;
  int j;

  old = (RF_PhysDiskAddr_t *)node->params[np-2].p;
  fail_start = old->startSector % secPerSU;
  
  RF_ETIMER_START(timer);

  d = (np-2)/2;
  RF_ASSERT (2*d+2 == np);
  for (i=0; i < d; i++)
    {
      old  = (RF_PhysDiskAddr_t *) node->params[2*i].p;
      obuf = (char *) node->params[2*i+1].p;
      coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),old->raidAddress);
      /* compute the data unit offset within the column, then add one */
      coeff = (coeff % raidPtr->Layout.numDataCol);
      /* the input buffers may not all be aligned with the start of the
	 stripe. so shift by their sector offset within the stripe unit */
      j = old->startSector % secPerSU;
      RF_ASSERT(j >= fail_start);
      qpbuf = qbuf + rf_RaidAddressToByte(raidPtr,j - fail_start);
      rf_IncQ((unsigned long *)qpbuf,(unsigned long *)obuf,rf_RaidAddressToByte(raidPtr, old->numSector),coeff);
    }

  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  tracerec->q_us += RF_ETIMER_VAL_US(timer);
a444 1

d447 1
a447 1
   
d451 1
a451 1
   raidPtr 
d462 17
a478 5
int rf_RegularPQFunc(node)
  RF_DagNode_t  *node;
{
  RegularQSubr(node,node->results[1]);
  return(rf_RegularXorFunc(node)); /* does the wakeup */
a479 10

int rf_RegularQFunc(node)
  RF_DagNode_t  *node;
{
  /* Almost ... adjust Qsubr args */
  RegularQSubr(node, node->results[0]);
  rf_GenericWakeupFunc(node, 0);     /* call wake func explicitly since no I/O in this node */
  return(0);
}

d482 1
a482 1
   
d485 2
a486 2
   pda_0, buffer_0, pda_1 , buffer_1, ... , pda_d, buffer_d 
   failedPDA raidPtr 
d499 9
a507 8
void rf_Degraded_100_PQFunc(node)
  RF_DagNode_t  *node;
{
  int np = node->numParams;

  RF_ASSERT (np >= 2);
  DegrQSubr(node);
  rf_RecoveryXorFunc(node);
d518 1
a518 1
   
d528 2
a529 2
 * Recall the basic equation is 
 *       
d539 2
a540 2
 *  
 * 
d542 38
a579 38
int rf_RecoveryQFunc(node)
  RF_DagNode_t  *node;
{
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams-1].p;
  RF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) &raidPtr->Layout;
  RF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams-2].p;
  int i;
  RF_PhysDiskAddr_t *pda;
  RF_RaidAddr_t suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr,failedPDA->startSector);
  char *srcbuf, *destbuf;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;
  unsigned long coeff;

  RF_ETIMER_START(timer);
  /* start by copying Q into the buffer */
  bcopy(node->params[node->numParams-3].p,node->results[0],
    rf_RaidAddressToByte(raidPtr, failedPDA->numSector));
  for (i=0; i<node->numParams-4; i+=2) 
    {
      RF_ASSERT (node->params[i+1].p != node->results[0]);
      pda = (RF_PhysDiskAddr_t *) node->params[i].p;
      srcbuf = (char *) node->params[i+1].p;
      suoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);
      destbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr,suoffset-failedSUOffset);
      coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),pda->raidAddress);
      /* compute the data unit offset within the column */
      coeff = (coeff % raidPtr->Layout.numDataCol);
      rf_IncQ((unsigned long *)destbuf, (unsigned long *)srcbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);
  }
  /* Do the nasty inversion now */
  coeff =  (rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),failedPDA->startSector) % raidPtr->Layout.numDataCol);
  rf_InvertQ(node->results[0],node->results[0],rf_RaidAddressToByte(raidPtr,pda->numSector),coeff);
  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  tracerec->q_us += RF_ETIMER_VAL_US(timer);
  rf_GenericWakeupFunc(node, 0);
  return(0);
d582 3
a584 2
int rf_RecoveryPQFunc(node)
  RF_DagNode_t  *node;
d586 2
a587 2
  RF_PANIC();
  return(1);
a588 1

d590 1
a590 1
   Degraded write Q subroutine. 
d592 1
a592 1
   Large-write style Q computation. 
d602 42
a643 41
void rf_PQ_DegradedWriteQFunc(node)
  RF_DagNode_t  *node;
{
  int np = node->numParams;
  int d;
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np-1].p;
  unsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;
  int i;
  RF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;
  RF_Etimer_t timer;
  char *qbuf = node->results[0];
  char *obuf, *qpbuf;
  RF_PhysDiskAddr_t *old;
  unsigned long coeff;
  int fail_start,j;

  old = (RF_PhysDiskAddr_t *) node->params[np-2].p;
  fail_start = old->startSector % secPerSU;
  
  RF_ETIMER_START(timer);

  d = (np-2)/2;
  RF_ASSERT (2*d+2 == np);

  for (i=0; i < d; i++)
    {
      old  = (RF_PhysDiskAddr_t *) node->params[2*i].p;
      obuf = (char *) node->params[2*i+1].p;
      coeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout),old->raidAddress);
      /* compute the data unit offset within the column, then add one */
      coeff = (coeff % raidPtr->Layout.numDataCol);
      j = old->startSector % secPerSU;
      RF_ASSERT(j >= fail_start);
      qpbuf = qbuf + rf_RaidAddressToByte(raidPtr,j - fail_start);
      rf_IncQ((unsigned long *)qpbuf,(unsigned long *)obuf,rf_RaidAddressToByte(raidPtr, old->numSector),coeff);
    }

  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  tracerec->q_us += RF_ETIMER_VAL_US(timer);
  rf_GenericWakeupFunc(node, 0);
d660 11
a670 10
void rf_IncQ(dest,buf,length,coeff)
  unsigned long   *dest;
  unsigned long   *buf;
  unsigned         length;
  unsigned         coeff;
{
  unsigned long a, d, new;
  unsigned long a1, a2;
  unsigned int *q = &(rf_qfor[28-coeff][0]);
  unsigned r = rf_rn[coeff+1];
d675 23
a697 24
  length /= 8;
  /* 13 5 bit quants in a 64 bit word */
  while (length)
    {
      a = *buf++;
      d = *dest;
      a1 = EXTRACT(a,0) ^ r;
      a2 = EXTRACT(a,1) ^ r;
      new = INSERT(a2,1) | a1 ;
      a1 = EXTRACT(a,2) ^ r;
      a2 = EXTRACT(a,3) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,2) | INSERT (a2,3);
      a1 = EXTRACT(a,4) ^ r;
      a2 = EXTRACT(a,5) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,4) | INSERT (a2,5);
      a1 = EXTRACT(a,5) ^ r;
      a2 = EXTRACT(a,6) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,5) | INSERT (a2,6);
d699 20
a718 20
      a1 = EXTRACT(a,7) ^ r;
      a2 = EXTRACT(a,8) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,7) | INSERT (a2,8);
      a1 = EXTRACT(a,9) ^ r;
      a2 = EXTRACT(a,10) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,9) | INSERT (a2,10);
      a1 = EXTRACT(a,11) ^ r;
      a2 = EXTRACT(a,12) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,11) | INSERT (a2,12);
#endif /* RF_LONGSHIFT > 2 */
      d ^= new;
      *dest++ = d;
      length--;
    }
d720 2
a722 3
/*
   compute 
   
d731 45
a775 44
static void QDelta(
  char           *dest,
  char           *obuf,
  char           *nbuf,
  unsigned        length,
  unsigned char   coeff)
{
  unsigned long a, d, new;
  unsigned long a1, a2;
  unsigned int *q = &(rf_qfor[28-coeff][0]);
  unsigned r = rf_rn[coeff+1];

#ifdef KERNEL
  /* PQ in kernel currently not supported because the encoding/decoding table is not present */
  bzero(dest, length);
#else  /* KERNEL */
  /* this code probably doesn't work and should be rewritten  -wvcii */
  /* 13 5 bit quants in a 64 bit word */
  length /= 8;
  while (length)
    {
      a = *obuf++; /* XXX need to reorg to avoid cache conflicts */
      a ^= *nbuf++;
      d = *dest;
      a1 = EXTRACT(a,0) ^ r;
      a2 = EXTRACT(a,1) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = INSERT(a2,1) | a1 ;
      a1 = EXTRACT(a,2) ^ r;
      a2 = EXTRACT(a,3) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,2) | INSERT (a2,3);
      a1 = EXTRACT(a,4) ^ r;
      a2 = EXTRACT(a,5) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,4) | INSERT (a2,5);
      a1 = EXTRACT(a,5) ^ r;
      a2 = EXTRACT(a,6) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,5) | INSERT (a2,6);
d777 21
a797 21
      a1 = EXTRACT(a,7) ^ r;
      a2 = EXTRACT(a,8) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,7) | INSERT (a2,8);
      a1 = EXTRACT(a,9) ^ r;
      a2 = EXTRACT(a,10) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,9) | INSERT (a2,10);
      a1 = EXTRACT(a,11) ^ r;
      a2 = EXTRACT(a,12) ^ r;
      a1 = q[a1];
      a2 = q[a2];
      new = new | INSERT(a1,11) | INSERT (a2,12);
#endif /* RF_LONGSHIFT > 2 */
      d ^= new;
      *dest++ = d;
      length--;
    }
#endif  /* KERNEL */
a798 1

d804 1
a804 1
   
d811 21
a831 21
void rf_PQ_recover(pbuf,qbuf,abuf,bbuf,length,coeff_a,coeff_b)
  unsigned long  *pbuf;
  unsigned long  *qbuf;
  unsigned long  *abuf;
  unsigned long  *bbuf;
  unsigned        length; 
  unsigned        coeff_a;
  unsigned        coeff_b;
{
  unsigned long p, q, a, a0, a1;
  int col = (29 * coeff_a) + coeff_b;
  unsigned char *q0 = & (rf_qinv[col][0]);
  
  length /= 8;
  while (length)
    {
      p  = *pbuf++;
      q  = *qbuf++;
      a0 = EXTRACT(p,0);
      a1 = EXTRACT(q,0);
      a  = q0[a0<<5 | a1];
d837 6
a842 6
      MF(1);
      MF(2);
      MF(3);
      MF(4);
      MF(5);
      MF(6);
d844 11
a854 11
      MF(7);
      MF(8);
      MF(9);
      MF(10);
      MF(11);
      MF(12);
#endif /* 0 */
      *abuf++ = a;
      *bbuf++ = a ^ p;
      length--;
    }
d856 1
a856 2

/* 
d864 1
a864 1
   but q is cyclic with period 31. 
d875 22
a896 22
   
static void rf_InvertQ(
  unsigned long  *qbuf,
  unsigned long  *abuf,
  unsigned        length,
  unsigned        coeff)
{
  unsigned long a, new;
  unsigned long a1, a2;
  unsigned int *q = &(rf_qfor[3+coeff][0]);
  unsigned r = rf_rn[coeff+1];

  /* 13 5 bit quants in a 64 bit word */
  length /= 8;
  while (length)
    {
      a = *qbuf++;
      a1 = EXTRACT(a,0);
      a2 = EXTRACT(a,1);
      a1 = r ^ q[a1];
      a2 = r ^ q[a2];
      new = INSERT(a2,1) | a1;
d904 3
a906 3
      M(2,3); 
      M(4,5);
      M(5,6);
d908 7
a914 7
      M(7,8);
      M(9,10);
      M(11,12);
#endif /* RF_LONGSHIFT > 2 */
      *abuf++ = new;
      length--;
    }
d916 2
a917 2

#endif /* (RF_INCLUDE_DECL_PQ > 0) || (RF_INCLUDE_RAID6 > 0) */
@

