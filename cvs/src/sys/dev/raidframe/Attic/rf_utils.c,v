head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.34
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.32
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.28
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.16
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.14
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.12
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.10
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.6;

1.6
date	2011.06.21.16.46.00;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.16.07.01.05;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.11.18.02.23;	author peter;	state Exp;
branches
	1.4.2.1
	1.4.12.1;
next	1.3;

1.3
date	2000.01.07.14.50.23;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.33;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.54;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.4.12.1
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_utils.c,v 1.6 2011/06/21 16:46:00 tedu Exp $	*/
/*	$NetBSD: rf_utils.c,v 1.5 2000/01/07 03:41:03 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/******************************************
 *
 * rf_utils.c -- Various support routines.
 *
 ******************************************/


#include "rf_threadstuff.h"

#include <sys/time.h>

#include "rf_utils.h"
#include "rf_debugMem.h"
#include "rf_alloclist.h"
#include "rf_general.h"

/* Creates & zeros 2-d array with b rows and k columns. (MCH) */
RF_RowCol_t **
rf_make_2d_array(int b, int k, RF_AllocListElem_t *allocList)
{
	RF_RowCol_t **retval, i;

	RF_MallocAndAdd(retval, b * sizeof(RF_RowCol_t *), (RF_RowCol_t **),
	    allocList);
	for (i = 0; i < b; i++) {
		RF_MallocAndAdd(retval[i], k * sizeof(RF_RowCol_t),
		    (RF_RowCol_t *), allocList);
		bzero(retval[i], k * sizeof(RF_RowCol_t));
	}
	return (retval);
}

void
rf_free_2d_array(RF_RowCol_t **a, int b, int k)
{
	RF_RowCol_t i;

	for (i = 0; i < b; i++)
		RF_Free(a[i], k * sizeof(RF_RowCol_t));
	RF_Free(a, b * sizeof(RF_RowCol_t));
}

/* Creates & zeroes a 1-d array with c columns. */
RF_RowCol_t *
rf_make_1d_array(int c, RF_AllocListElem_t *allocList)
{
	RF_RowCol_t *retval;

	RF_MallocAndAdd(retval, c * sizeof(RF_RowCol_t), (RF_RowCol_t *),
	    allocList);
	bzero(retval, c * sizeof(RF_RowCol_t));
	return (retval);
}

void
rf_free_1d_array(RF_RowCol_t *a, int n)
{
	RF_Free(a, n * sizeof(RF_RowCol_t));
}

/*
 * Euclid's algorithm: Finds and returns the greatest common divisor
 * between a and b. (MCH)
 */
int
rf_gcd(int m, int n)
{
	int t;

	while (m > 0) {
		t = n % m;
		n = m;
		m = t;
	}
	return (n);
}

/*
 * These convert between text and integer. Apparently the regular C macros
 * for doing this are not available in the kernel.
 */

#define	ISDIGIT(x)	((x) >= '0' && (x) <= '9')
#define	ISHEXCHAR(x)	(((x) >= 'a' && (x) <= 'f') ||			\
			 ((x) >= 'A' && (x) <= 'F'))
#define	ISHEX(x)	(ISDIGIT(x) || ISHEXCHAR(x))
#define	HC2INT(x)	(((x) >= 'a' && (x) <= 'f') ?			\
			 (x) - 'a' + 10 :				\
			 (((x) >= 'A' && (x) <= 'F') ?			\
			   (x) - 'A' + 10 : (x - '0')))

int
rf_atoi(char *p)
{
	int val = 0, negate = 0;

	if (*p == '-') {
		negate = 1;
		p++;
	}
	for (; ISDIGIT(*p); p++)
		val = 10 * val + (*p - '0');
	return ((negate) ? -val : val);
}

int
rf_htoi(char *p)
{
	int val = 0;
	for (; ISHEXCHAR(*p); p++)
		val = 16 * val + HC2INT(*p);
	return (val);
}
@


1.6
log
@remove stupid casts, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_utils.c,v 1.5 2002/12/16 07:01:05 tdeval Exp $	*/
@


1.5
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_utils.c,v 1.4 2000/01/11 18:02:23 peter Exp $	*/
d58 1
a58 1
		bzero((char *) retval[i], k * sizeof(RF_RowCol_t));
d81 1
a81 1
	bzero((char *) retval, c * sizeof(RF_RowCol_t));
@


1.4
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_utils.c,v 1.3 2000/01/07 14:50:23 peter Exp $	*/
d3 1
d31 1
a31 1
/****************************************
d33 1
a33 1
 * rf_utils.c -- various support routines
d35 1
a35 1
 ****************************************/
d47 1
a47 1
/* creates & zeros 2-d array with b rows and k columns (MCH) */
d49 1
a49 4
rf_make_2d_array(b, k, allocList)
	int     b;
	int     k;
	RF_AllocListElem_t *allocList;
d53 2
a54 1
	RF_MallocAndAdd(retval, b * sizeof(RF_RowCol_t *), (RF_RowCol_t **), allocList);
d56 3
a58 2
		RF_MallocAndAdd(retval[i], k * sizeof(RF_RowCol_t), (RF_RowCol_t *), allocList);
		(void) bzero((char *) retval[i], k * sizeof(RF_RowCol_t));
d63 2
a64 5
void 
rf_free_2d_array(a, b, k)
	RF_RowCol_t **a;
	int     b;
	int     k;
d73 1
a73 2

/* creates & zeros a 1-d array with c columns */
d75 1
a75 3
rf_make_1d_array(c, allocList)
	int     c;
	RF_AllocListElem_t *allocList;
d79 3
a81 2
	RF_MallocAndAdd(retval, c * sizeof(RF_RowCol_t), (RF_RowCol_t *), allocList);
	(void) bzero((char *) retval, c * sizeof(RF_RowCol_t));
d85 2
a86 4
void 
rf_free_1d_array(a, n)
	RF_RowCol_t *a;
	int     n;
d90 4
a93 2
/* Euclid's algorithm:  finds and returns the greatest common divisor
 * between a and b.     (MCH)
d95 2
a96 4
int 
rf_gcd(m, n)
	int     m;
	int     n;
d98 1
a98 1
	int     t;
d107 4
a110 2
/* these convert between text and integer.  Apparently the regular C macros
 * for doing this are not available in the kernel
d113 11
a123 9
#define ISDIGIT(x)   ( (x) >= '0' && (x) <= '9' )
#define ISHEXCHAR(x) ( ((x) >= 'a' && (x) <= 'f') || ((x) >= 'A' && (x) <= 'F') )
#define ISHEX(x)     ( ISDIGIT(x) || ISHEXCHAR(x) )
#define HC2INT(x)    ( ((x) >= 'a' && (x) <= 'f') ? (x) - 'a' + 10 :                    \
		       ( ((x) >= 'A' && (x) <= 'F') ? (x) - 'A' + 10 : (x - '0') ) )

int 
rf_atoi(p)
	char   *p;
d125 1
a125 1
	int     val = 0, negate = 0;
d136 2
a137 3
int 
rf_htoi(p)
	char   *p;
d139 1
a139 1
	int     val = 0;
@


1.4.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/******************************************
d32 1
a32 1
 * rf_utils.c -- Various support routines.
d34 1
a34 1
 ******************************************/
d46 1
a46 1
/* Creates & zeros 2-d array with b rows and k columns. (MCH) */
d48 4
a51 1
rf_make_2d_array(int b, int k, RF_AllocListElem_t *allocList)
d55 1
a55 2
	RF_MallocAndAdd(retval, b * sizeof(RF_RowCol_t *), (RF_RowCol_t **),
	    allocList);
d57 2
a58 3
		RF_MallocAndAdd(retval[i], k * sizeof(RF_RowCol_t),
		    (RF_RowCol_t *), allocList);
		bzero((char *) retval[i], k * sizeof(RF_RowCol_t));
d63 5
a67 2
void
rf_free_2d_array(RF_RowCol_t **a, int b, int k)
d76 2
a77 1
/* Creates & zeroes a 1-d array with c columns. */
d79 3
a81 1
rf_make_1d_array(int c, RF_AllocListElem_t *allocList)
d85 2
a86 3
	RF_MallocAndAdd(retval, c * sizeof(RF_RowCol_t), (RF_RowCol_t *),
	    allocList);
	bzero((char *) retval, c * sizeof(RF_RowCol_t));
d90 4
a93 2
void
rf_free_1d_array(RF_RowCol_t *a, int n)
d97 2
a98 4

/*
 * Euclid's algorithm: Finds and returns the greatest common divisor
 * between a and b. (MCH)
d100 4
a103 2
int
rf_gcd(int m, int n)
d105 1
a105 1
	int t;
d114 2
a115 4

/*
 * These convert between text and integer. Apparently the regular C macros
 * for doing this are not available in the kernel.
d118 9
a126 11
#define	ISDIGIT(x)	((x) >= '0' && (x) <= '9')
#define	ISHEXCHAR(x)	(((x) >= 'a' && (x) <= 'f') ||			\
			 ((x) >= 'A' && (x) <= 'F'))
#define	ISHEX(x)	(ISDIGIT(x) || ISHEXCHAR(x))
#define	HC2INT(x)	(((x) >= 'a' && (x) <= 'f') ?			\
			 (x) - 'a' + 10 :				\
			 (((x) >= 'A' && (x) <= 'F') ?			\
			   (x) - 'A' + 10 : (x - '0')))

int
rf_atoi(char *p)
d128 1
a128 1
	int val = 0, negate = 0;
d139 3
a141 2
int
rf_htoi(char *p)
d143 1
a143 1
	int val = 0;
@


1.4.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/******************************************
d32 1
a32 1
 * rf_utils.c -- Various support routines.
d34 1
a34 1
 ******************************************/
d46 1
a46 1
/* Creates & zeros 2-d array with b rows and k columns. (MCH) */
d48 4
a51 1
rf_make_2d_array(int b, int k, RF_AllocListElem_t *allocList)
d55 1
a55 2
	RF_MallocAndAdd(retval, b * sizeof(RF_RowCol_t *), (RF_RowCol_t **),
	    allocList);
d57 2
a58 3
		RF_MallocAndAdd(retval[i], k * sizeof(RF_RowCol_t),
		    (RF_RowCol_t *), allocList);
		bzero((char *) retval[i], k * sizeof(RF_RowCol_t));
d63 5
a67 2
void
rf_free_2d_array(RF_RowCol_t **a, int b, int k)
d76 2
a77 1
/* Creates & zeroes a 1-d array with c columns. */
d79 3
a81 1
rf_make_1d_array(int c, RF_AllocListElem_t *allocList)
d85 2
a86 3
	RF_MallocAndAdd(retval, c * sizeof(RF_RowCol_t), (RF_RowCol_t *),
	    allocList);
	bzero((char *) retval, c * sizeof(RF_RowCol_t));
d90 4
a93 2
void
rf_free_1d_array(RF_RowCol_t *a, int n)
d97 2
a98 4

/*
 * Euclid's algorithm: Finds and returns the greatest common divisor
 * between a and b. (MCH)
d100 4
a103 2
int
rf_gcd(int m, int n)
d105 1
a105 1
	int t;
d114 2
a115 4

/*
 * These convert between text and integer. Apparently the regular C macros
 * for doing this are not available in the kernel.
d118 9
a126 11
#define	ISDIGIT(x)	((x) >= '0' && (x) <= '9')
#define	ISHEXCHAR(x)	(((x) >= 'a' && (x) <= 'f') ||			\
			 ((x) >= 'A' && (x) <= 'F'))
#define	ISHEX(x)	(ISDIGIT(x) || ISHEXCHAR(x))
#define	HC2INT(x)	(((x) >= 'a' && (x) <= 'f') ?			\
			 (x) - 'a' + 10 :				\
			 (((x) >= 'A' && (x) <= 'F') ?			\
			   (x) - 'A' + 10 : (x - '0')))

int
rf_atoi(char *p)
d128 1
a128 1
	int val = 0, negate = 0;
d139 3
a141 2
int
rf_htoi(char *p)
d143 1
a143 1
	int val = 0;
@


1.3
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_utils.c,v 1.2 1999/02/16 00:03:33 niklas Exp $	*/
/*	$NetBSD: rf_utils.c,v 1.4 1999/08/13 03:41:58 oster Exp $	*/
a40 1
#include "rf_threadid.h"
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_utils.c,v 1.1 1999/01/11 14:29:54 niklas Exp $	*/
/*	$NetBSD: rf_utils.c,v 1.3 1999/02/05 00:06:18 oster Exp $	*/
a45 1
#include "rf_sys.h"
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_utils.c,v 1.1 1998/11/13 04:20:35 oster Exp $	*/
/*	$NetBSD: rf_utils.c,v 1.1 1998/11/13 04:20:35 oster Exp $	*/
a35 54
/* :  
 * Log: rf_utils.c,v 
 * Revision 1.20  1996/07/27 23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.19  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.18  1996/07/15  17:22:18  jimz
 * nit-pick code cleanup
 * resolve stdlib problems on DEC OSF
 *
 * Revision 1.17  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.16  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.15  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.14  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.13  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.12  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.11  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.10  1995/12/06  15:17:44  root
 * added copyright info
 *
 */
a38 7
#ifdef _KERNEL
#define KERNEL
#endif

#ifndef KERNEL
#include <stdio.h>
#endif /* !KERNEL */
a47 4
#ifndef KERNEL
#include "rf_randmacros.h"
#endif /* !KERNEL */

d49 27
a75 25
RF_RowCol_t **rf_make_2d_array(b, k, allocList)
  int                  b;
  int                  k;
  RF_AllocListElem_t  *allocList;
{
    RF_RowCol_t **retval, i;

    RF_MallocAndAdd(retval, b * sizeof(RF_RowCol_t *), (RF_RowCol_t **), allocList);
    for (i=0; i<b; i++) {
      RF_MallocAndAdd(retval[i], k * sizeof(RF_RowCol_t), (RF_RowCol_t *), allocList);
      (void) bzero((char *) retval[i], k*sizeof(RF_RowCol_t));
    }
    return(retval);
}

void rf_free_2d_array(a, b, k)
  RF_RowCol_t  **a;
  int            b;
  int            k;
{
  RF_RowCol_t i;

  for (i=0; i<b; i++)
    RF_Free(a[i], k*sizeof(RF_RowCol_t));
  RF_Free(a, b*sizeof(RF_RowCol_t));
d80 4
a83 3
RF_RowCol_t *rf_make_1d_array(c, allocList)
  int                  c;
  RF_AllocListElem_t  *allocList;
d85 1
a85 1
  RF_RowCol_t *retval;
d87 3
a89 3
  RF_MallocAndAdd(retval, c * sizeof(RF_RowCol_t), (RF_RowCol_t *), allocList);
  (void) bzero((char *) retval, c*sizeof(RF_RowCol_t));
  return(retval);
d92 4
a95 3
void rf_free_1d_array(a, n)
  RF_RowCol_t  *a;
  int           n;
d97 1
a97 1
  RF_Free(a, n * sizeof(RF_RowCol_t));
a98 1

d102 13
a114 38
int rf_gcd(m, n)
  int  m;
  int  n;
{
    int t;

    while (m>0) {
        t = n % m;
        n = m;
        m = t;
    }
    return(n);
}

#if !defined(KERNEL) && !defined(SIMULATE) && defined(__osf__)
/* this is used to generate a random number when _FASTRANDOM is off
 * in randmacros.h
 */
long rf_do_random(rval, rdata)
  long                *rval;
  struct random_data  *rdata;
{
  int a, b;
  long c;
  /*
   * random_r() generates random 32-bit values. OR them together.
   */
  if (random_r(&a, rdata)!=0) {
    fprintf(stderr,"Yikes!  call to random_r failed\n");
    exit(1);
  }
  if (random_r(&b, rdata)!=0) {
    fprintf(stderr,"Yikes!  call to random_r failed\n");
    exit(1);
  }
  c = ((long)a)<<32;
  *rval = c|b;
  return(*rval);
a115 2
#endif /* !KERNEL && !SIMULATE && __osf__ */

d126 23
a148 16
int rf_atoi(p)
 char  *p;
{
  int val = 0, negate = 0;
  
  if (*p == '-') {negate=1; p++;}
  for ( ; ISDIGIT(*p); p++) val = 10 * val + (*p - '0');
  return((negate) ? -val : val);
}

int rf_htoi(p)
  char  *p;
{
  int val = 0;
  for ( ; ISHEXCHAR(*p); p++) val = 16 * val + HC2INT(*p);
  return(val);
@

