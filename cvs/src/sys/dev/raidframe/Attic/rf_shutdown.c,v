head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.16
	OPENBSD_5_0:1.6.0.14
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.12
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.10
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.6
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.6;

1.6
date	2008.05.19.18.42.13;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.16.07.01.05;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.08.16.07.45;	author peter;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	2000.01.11.18.02.23;	author peter;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.02.16.00.03.26;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.49;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.26.14;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_shutdown.c,v 1.6 2008/05/19 18:42:13 miod Exp $	*/
/*	$NetBSD: rf_shutdown.c,v 1.6 2000/01/13 23:41:18 oster Exp $	*/

/*
 * rf_shutdown.c
 */
/*
 * Copyright (c) 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
/*
 * Maintain lists of cleanup functions. Also, mechanisms for coordinating
 * thread startup and shutdown.
 */

#include "rf_types.h"
#include "rf_threadstuff.h"
#include "rf_shutdown.h"
#include "rf_debugMem.h"
#include "rf_freelist.h"

void rf_FreeShutdownEnt(RF_ShutdownList_t *);
void
rf_FreeShutdownEnt(RF_ShutdownList_t *ent)
{
	free(ent, M_RAIDFRAME);
}

int
_rf_ShutdownCreate(RF_ShutdownList_t **listp, void (*cleanup) (void *arg),
    void *arg, char *file, int line)
{
	RF_ShutdownList_t *ent;

	/*
         * Have to directly allocate memory here, since we start up before
         * and shutdown after RAIDframe internal allocation system.
         */
	/* ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t),
	 *     M_RAIDFRAME, M_WAITOK); */
	ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t),
	    M_RAIDFRAME, M_NOWAIT);
	if (ent == NULL)
		return (ENOMEM);
	ent->cleanup = cleanup;
	ent->arg = arg;
	ent->file = file;
	ent->line = line;
	ent->next = *listp;
	*listp = ent;
	return (0);
}

int
rf_ShutdownList(RF_ShutdownList_t **list)
{
	RF_ShutdownList_t *r, *next;
	char *file;
	int line;

	for (r = *list; r; r = next) {
		next = r->next;
		file = r->file;
		line = r->line;

		if (rf_shutdownDebug) {
			printf("call shutdown, created %s:%d\n", file, line);
		}
		r->cleanup(r->arg);

		if (rf_shutdownDebug) {
			printf("completed shutdown, created %s:%d\n", file,
			    line);
		}
		rf_FreeShutdownEnt(r);
	}
	*list = NULL;
	return (0);
}
@


1.6
log
@Change all remaining MD uses of MALLOC and FREE into proper malloc() and
free() calls; prodded by chl@@, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_shutdown.c,v 1.5 2002/12/16 07:01:05 tdeval Exp $	*/
@


1.5
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_shutdown.c,v 1.4 2000/08/08 16:07:45 peter Exp $	*/
d48 1
a48 1
	FREE(ent, M_RAIDFRAME);
@


1.4
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_shutdown.c,v 1.3 2000/01/11 18:02:23 peter Exp $	*/
d3 1
d44 3
a46 2
static void 
rf_FreeShutdownEnt(RF_ShutdownList_t * ent)
d51 3
a53 7
int 
_rf_ShutdownCreate(
    RF_ShutdownList_t ** listp,
    void (*cleanup) (void *arg),
    void *arg,
    char *file,
    int line)
d61 4
a64 4
	/* 	ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t), 
		M_RAIDFRAME, M_WAITOK); */
	ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t), 
					   M_RAIDFRAME, M_NOWAIT);
d76 2
a77 2
int 
rf_ShutdownList(RF_ShutdownList_t ** list)
d80 2
a81 2
	char   *file;
	int     line;
d94 2
a95 1
			printf("completed shutdown, created %s:%d\n", file, line);
@


1.4.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d43 2
a44 3
void rf_FreeShutdownEnt(RF_ShutdownList_t *);
void
rf_FreeShutdownEnt(RF_ShutdownList_t *ent)
d49 7
a55 3
int
_rf_ShutdownCreate(RF_ShutdownList_t **listp, void (*cleanup) (void *arg),
    void *arg, char *file, int line)
d63 4
a66 4
	/* ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t),
	 *     M_RAIDFRAME, M_WAITOK); */
	ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t),
	    M_RAIDFRAME, M_NOWAIT);
d78 2
a79 2
int
rf_ShutdownList(RF_ShutdownList_t **list)
d82 2
a83 2
	char *file;
	int line;
d96 1
a96 2
			printf("completed shutdown, created %s:%d\n", file,
			    line);
@


1.3
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_shutdown.c,v 1.2 1999/02/16 00:03:26 niklas Exp $	*/
/*	$NetBSD: rf_shutdown.c,v 1.5 2000/01/08 22:57:31 oster Exp $	*/
d63 4
a66 1
	ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t), M_RAIDFRAME, M_WAITOK);
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_shutdown.c,v 1.4 2000/08/08 16:07:45 peter Exp $	*/
/*	$NetBSD: rf_shutdown.c,v 1.6 2000/01/13 23:41:18 oster Exp $	*/
d63 1
a63 4
	/* 	ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t), 
		M_RAIDFRAME, M_WAITOK); */
	ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t), 
					   M_RAIDFRAME, M_NOWAIT);
@


1.3.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d43 2
a44 3
void rf_FreeShutdownEnt(RF_ShutdownList_t *);
void
rf_FreeShutdownEnt(RF_ShutdownList_t *ent)
d49 7
a55 3
int
_rf_ShutdownCreate(RF_ShutdownList_t **listp, void (*cleanup) (void *arg),
    void *arg, char *file, int line)
d63 4
a66 4
	/* ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t),
	 *     M_RAIDFRAME, M_WAITOK); */
	ent = (RF_ShutdownList_t *) malloc(sizeof(RF_ShutdownList_t),
	    M_RAIDFRAME, M_NOWAIT);
d78 2
a79 2
int
rf_ShutdownList(RF_ShutdownList_t **list)
d82 2
a83 2
	char *file;
	int line;
d96 1
a96 2
			printf("completed shutdown, created %s:%d\n", file,
			    line);
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_shutdown.c,v 1.1 1999/01/11 14:29:49 niklas Exp $	*/
/*	$NetBSD: rf_shutdown.c,v 1.4 1999/02/05 00:06:17 oster Exp $	*/
a41 1
#include "rf_threadid.h"
d88 1
a88 3
			int     tid;
			rf_get_threadid(tid);
			printf("[%d] call shutdown, created %s:%d\n", tid, file, line);
d93 1
a93 3
			int     tid;
			rf_get_threadid(tid);
			printf("[%d] completed shutdown, created %s:%d\n", tid, file, line);
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_shutdown.c,v 1.1 1998/11/13 04:20:34 oster Exp $	*/
/*	$NetBSD: rf_shutdown.c,v 1.1 1998/11/13 04:20:34 oster Exp $	*/
d44 2
a45 1
static void rf_FreeShutdownEnt(RF_ShutdownList_t *ent)
d47 1
a47 5
#ifdef KERNEL
  FREE(ent, M_DEVBUF);
#else /* KERNEL */
  free(ent);
#endif /* KERNEL */
d50 7
a56 6
int _rf_ShutdownCreate(
  RF_ShutdownList_t  **listp,
  void               (*cleanup)(void *arg),
  void                *arg,
  char                *file,
  int                  line)
d58 1
a58 1
  RF_ShutdownList_t *ent;
d60 14
a73 21
  /*
   * Have to directly allocate memory here, since we start up before
   * and shutdown after RAIDframe internal allocation system.
   */
#ifdef KERNEL
  ent = (RF_ShutdownList_t *)malloc( sizeof(RF_ShutdownList_t), M_DEVBUF, M_WAITOK);
#if 0
  MALLOC(ent, RF_ShutdownList_t *, sizeof(RF_ShutdownList_t), M_DEVBUF, M_WAITOK);
#endif
#else /* KERNEL */
  ent = (RF_ShutdownList_t *)malloc(sizeof(RF_ShutdownList_t));
#endif /* KERNEL */
  if (ent == NULL)
    return(ENOMEM);
  ent->cleanup = cleanup;
  ent->arg = arg;
  ent->file = file;
  ent->line = line;
  ent->next = *listp;
  *listp = ent;
  return(0);
d76 2
a77 1
int rf_ShutdownList(RF_ShutdownList_t **list)
d79 25
a103 27
  RF_ShutdownList_t *r, *next;
  char *file;
  int line;

  for(r=*list;r;r=next) {
    next = r->next;
    file = r->file;
    line = r->line;

    if (rf_shutdownDebug) {
      int tid;
      rf_get_threadid(tid);
      printf("[%d] call shutdown, created %s:%d\n", tid, file, line);
    }

    r->cleanup(r->arg);

    if (rf_shutdownDebug) {
      int tid;
      rf_get_threadid(tid);
      printf("[%d] completed shutdown, created %s:%d\n", tid, file, line);
    }

    rf_FreeShutdownEnt(r);
  }
  *list = NULL;
  return(0);
@

