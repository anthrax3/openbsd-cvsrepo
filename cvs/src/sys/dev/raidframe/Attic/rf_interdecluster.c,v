head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.38
	OPENBSD_5_0:1.4.0.36
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.16
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.14
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.12
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.4;

1.4
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.3.2.1
	1.3.12.1;
next	1.2;

1.2
date	99.02.16.00.02.52;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.26;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.3.12.1
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_interdecluster.c,v 1.4 2002/12/16 07:01:04 tdeval Exp $	*/
/*	$NetBSD: rf_interdecluster.c,v 1.4 2000/01/07 03:41:00 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Khalil Amiri
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*************************************************************
 *
 * rf_interdecluster.c -- Implements interleaved declustering.
 *
 *************************************************************/


#include "rf_types.h"
#include "rf_raid.h"
#include "rf_interdecluster.h"
#include "rf_dag.h"
#include "rf_dagutils.h"
#include "rf_dagfuncs.h"
#include "rf_general.h"
#include "rf_utils.h"
#include "rf_dagffrd.h"
#include "rf_dagdegrd.h"
#include "rf_dagffwr.h"
#include "rf_dagdegwr.h"

typedef struct RF_InterdeclusterConfigInfo_s {
	/* Filled in at config time and used by IdentifyStripe. */
	RF_RowCol_t	**stripeIdentifier;
	RF_StripeCount_t  numSparingRegions;
	RF_StripeCount_t  stripeUnitsPerSparingRegion;
	RF_SectorNum_t	  mirrorStripeOffset;
}	RF_InterdeclusterConfigInfo_t;

int
rf_ConfigureInterDecluster(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
	RF_StripeCount_t num_used_stripeUnitsPerDisk;
	RF_InterdeclusterConfigInfo_t *info;
	RF_RowCol_t i, tmp, SUs_per_region;

	/* Create an Interleaved Declustering configuration structure. */
	RF_MallocAndAdd(info, sizeof(RF_InterdeclusterConfigInfo_t),
	    (RF_InterdeclusterConfigInfo_t *), raidPtr->cleanupList);
	if (info == NULL)
		return (ENOMEM);
	layoutPtr->layoutSpecificInfo = (void *) info;

	/* Fill in the config structure. */
	SUs_per_region = raidPtr->numCol * (raidPtr->numCol - 1);
	info->stripeIdentifier = rf_make_2d_array(SUs_per_region, 2,
	    raidPtr->cleanupList);
	if (info->stripeIdentifier == NULL)
		return (ENOMEM);
	for (i = 0; i < SUs_per_region; i++) {
		info->stripeIdentifier[i][0] = i / (raidPtr->numCol - 1);
		tmp = i / raidPtr->numCol;
		info->stripeIdentifier[i][1] = (i + 1 + tmp) % raidPtr->numCol;
	}

	/* No spare tables. */
	RF_ASSERT(raidPtr->numRow == 1);

	/* Fill in the remaining layout parameters. */

	/*
	 * Total number of stripes should a multiple of 2*numCol: Each sparing
	 * region consists of 2*numCol stripes: n-1 primary copy, n-1
	 * secondary copy and 2 for spare...
	 */
	num_used_stripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk -
	    (layoutPtr->stripeUnitsPerDisk % (2 * raidPtr->numCol));
	info->numSparingRegions = num_used_stripeUnitsPerDisk /
	    (2 * raidPtr->numCol);
	/*
	 * This is in fact the number of stripe units (that are primary data
	 * copies) in the sparing region.
	 */
	info->stripeUnitsPerSparingRegion = raidPtr->numCol *
	    (raidPtr->numCol - 1);
	info->mirrorStripeOffset = info->numSparingRegions *
	    (raidPtr->numCol + 1);
	layoutPtr->numStripe = info->numSparingRegions *
	    info->stripeUnitsPerSparingRegion;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
	layoutPtr->numDataCol = 1;
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
	layoutPtr->numParityCol = 1;

	layoutPtr->dataStripeUnitsPerDisk = num_used_stripeUnitsPerDisk;

	raidPtr->sectorsPerDisk =
	    num_used_stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;

	raidPtr->totalSectors =
	    (layoutPtr->numStripe) * layoutPtr->sectorsPerStripeUnit;

	layoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk /
	    layoutPtr->sectorsPerStripeUnit;

	return (0);
}

int
rf_GetDefaultNumFloatingReconBuffersInterDecluster(RF_Raid_t *raidPtr)
{
	return (30);
}

RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitInterDecluster(RF_Raid_t *raidPtr)
{
	return (raidPtr->sectorsPerDisk);
}

RF_ReconUnitCount_t
rf_GetNumSpareRUsInterDecluster(RF_Raid_t *raidPtr)
{
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;

	return (2 * ((RF_ReconUnitCount_t) info->numSparingRegions));
	/*
	 * The layout uses two stripe units per disk as spare within each
	 * sparing region.
	 */
}

/* Maps to the primary copy of the data, i.e. the first mirror pair. */
void
rf_MapSectorInterDecluster(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t* diskSector, int remap)
{
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
	RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
	RF_StripeNum_t su_offset_into_disk, mirror_su_offset_into_disk;
	RF_StripeNum_t sparing_region_id, index_within_region;
	int col_before_remap;

	*row = 0;
	sparing_region_id = SUID / info->stripeUnitsPerSparingRegion;
	index_within_region = SUID % info->stripeUnitsPerSparingRegion;
	su_offset_into_disk = index_within_region % (raidPtr->numCol - 1);
	mirror_su_offset_into_disk = index_within_region / raidPtr->numCol;
	col_before_remap = index_within_region / (raidPtr->numCol - 1);

	if (!remap) {
		*col = col_before_remap;
		*diskSector = (su_offset_into_disk + ((raidPtr->numCol - 1) *
		    sparing_region_id)) * raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector +=
		    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
	} else {
		/* Remap sector to spare space... */
		*diskSector = sparing_region_id * (raidPtr->numCol + 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidPtr->numCol - 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector +=
		    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
		*col = (index_within_region + 1 + mirror_su_offset_into_disk) %
		    raidPtr->numCol;
		*col = (*col + 1) % raidPtr->numCol;
		if (*col == col_before_remap)
			*col = (*col + 1) % raidPtr->numCol;
	}
}

/* Maps to the second copy of the mirror pair. */
void
rf_MapParityInterDecluster(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
{
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
	RF_StripeNum_t sparing_region_id, index_within_region;
	RF_StripeNum_t mirror_su_offset_into_disk;
	RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
	int col_before_remap;

	sparing_region_id = SUID / info->stripeUnitsPerSparingRegion;
	index_within_region = SUID % info->stripeUnitsPerSparingRegion;
	mirror_su_offset_into_disk = index_within_region / raidPtr->numCol;
	col_before_remap = (index_within_region + 1 +
	    mirror_su_offset_into_disk) % raidPtr->numCol;

	*row = 0;
	if (!remap) {
		*col = col_before_remap;
		*diskSector = info->mirrorStripeOffset *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += sparing_region_id * (raidPtr->numCol - 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += mirror_su_offset_into_disk *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector +=
		    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
	} else {
		/* Remap parity to spare space... */
		*diskSector = sparing_region_id * (raidPtr->numCol + 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidPtr->numCol) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidSector %
		    raidPtr->Layout.sectorsPerStripeUnit);
		*col = index_within_region / (raidPtr->numCol - 1);
		*col = (*col + 1) % raidPtr->numCol;
		if (*col == col_before_remap)
			*col = (*col + 1) % raidPtr->numCol;
	}
}

void
rf_IdentifyStripeInterDecluster(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
{
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
	RF_StripeNum_t SUID;

	SUID = addr / raidPtr->Layout.sectorsPerStripeUnit;
	SUID = SUID % info->stripeUnitsPerSparingRegion;

	*outRow = 0;
	*diskids = info->stripeIdentifier[SUID];
}

void
rf_MapSIDToPSIDInterDecluster( RF_RaidLayout_t *layoutPtr,
    RF_StripeNum_t stripeID, RF_StripeNum_t *psID, RF_ReconUnitNum_t *which_ru)
{
	*which_ru = 0;
	*psID = stripeID;
}


/*****************************************************************************
 * Select a graph to perform a single-stripe access.
 *
 * Parameters:	raidPtr	   - Description of the physical array.
 *		type	   - Type of operation (read or write) requested.
 *		asmap	   - Logical & physical addresses for this access.
 *		createFunc - Name of function to use to create the graph.
 *****************************************************************************/

void
rf_RAIDIDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmap, RF_VoidFuncPtr *createFunc)
{
	RF_ASSERT(RF_IO_IS_R_OR_W(type));

	if (asmap->numDataFailed + asmap->numParityFailed > 1) {
		RF_ERRORMSG("Multiple disks failed in a single group !"
		    "  Aborting I/O operation.\n");
		*createFunc = NULL;
		return;
	}
	*createFunc = (type == RF_IO_TYPE_READ)
	    ? (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG
	    : (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;
	if (type == RF_IO_TYPE_READ) {
		if (asmap->numDataFailed == 0)
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateMirrorPartitionReadDAG;
		else
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateRaidOneDegradedReadDAG;
	} else
		*createFunc = (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;
}
@


1.4
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_interdecluster.c,v 1.3 2000/01/11 18:02:22 peter Exp $	*/
@


1.3
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_interdecluster.c,v 1.2 1999/02/16 00:02:52 niklas Exp $	*/
d3 1
d31 1
a31 1
/************************************************************
d33 1
a33 1
 * rf_interdecluster.c -- implements interleaved declustering
d35 1
a35 1
 ************************************************************/
d52 10
a61 12
	RF_RowCol_t **stripeIdentifier;	/* filled in at config time and used
					 * by IdentifyStripe */
	RF_StripeCount_t numSparingRegions;
	RF_StripeCount_t stripeUnitsPerSparingRegion;
	RF_SectorNum_t mirrorStripeOffset;
}       RF_InterdeclusterConfigInfo_t;

int 
rf_ConfigureInterDecluster(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d68 3
a70 3
	/* create an Interleaved Declustering configuration structure */
	RF_MallocAndAdd(info, sizeof(RF_InterdeclusterConfigInfo_t), (RF_InterdeclusterConfigInfo_t *),
	    raidPtr->cleanupList);
d75 1
a75 1
	/* fill in the config structure.  */
d77 2
a78 1
	info->stripeIdentifier = rf_make_2d_array(SUs_per_region, 2, raidPtr->cleanupList);
d87 1
a87 1
	/* no spare tables */
d90 1
a90 1
	/* fill in the remaining layout parameters */
d92 2
a93 1
	/* total number of stripes should a multiple of 2*numCol: Each sparing
d95 18
a112 10
	 * secondary copy and 2 for spare .. */
	num_used_stripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk - (layoutPtr->stripeUnitsPerDisk %
	    (2 * raidPtr->numCol));
	info->numSparingRegions = num_used_stripeUnitsPerDisk / (2 * raidPtr->numCol);
	/* this is in fact the number of stripe units (that are primary data
	 * copies) in the sparing region */
	info->stripeUnitsPerSparingRegion = raidPtr->numCol * (raidPtr->numCol - 1);
	info->mirrorStripeOffset = info->numSparingRegions * (raidPtr->numCol + 1);
	layoutPtr->numStripe = info->numSparingRegions * info->stripeUnitsPerSparingRegion;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;
d114 2
a115 1
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
d126 2
a127 1
	layoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk / layoutPtr->sectorsPerStripeUnit;
d132 2
a133 2
int 
rf_GetDefaultNumFloatingReconBuffersInterDecluster(RF_Raid_t * raidPtr)
d138 2
a139 2
RF_HeadSepLimit_t 
rf_GetDefaultHeadSepLimitInterDecluster(RF_Raid_t * raidPtr)
d144 2
a145 3
RF_ReconUnitCount_t 
rf_GetNumSpareRUsInterDecluster(
    RF_Raid_t * raidPtr)
d147 2
a148 1
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d151 4
a154 2
	/* the layout uses two stripe units per disk as spare within each
	 * sparing region */
d156 5
a160 9
/* Maps to the primary copy of the data, i.e. the first mirror pair */
void 
rf_MapSectorInterDecluster(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d162 2
a163 1
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d167 1
a167 1
	int     col_before_remap;
d177 10
a186 2
		*col = col_before_remap;;
		*diskSector = (su_offset_into_disk + ((raidPtr->numCol - 1) * sparing_region_id)) *
d188 4
a191 7
		*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
	} else {
		/* remap sector to spare space... */
		*diskSector = sparing_region_id * (raidPtr->numCol + 1) * raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidPtr->numCol - 1) * raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
		*col = (index_within_region + 1 + mirror_su_offset_into_disk) % raidPtr->numCol;
d197 1
d199 3
a201 8
void 
rf_MapParityInterDecluster(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t raidSector,
    RF_RowCol_t * row,
    RF_RowCol_t * col,
    RF_SectorNum_t * diskSector,
    int remap)
d203 4
a206 2
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
	RF_StripeNum_t sparing_region_id, index_within_region, mirror_su_offset_into_disk;
d208 1
a208 1
	int     col_before_remap;
d213 2
a214 1
	col_before_remap = (index_within_region + 1 + mirror_su_offset_into_disk) % raidPtr->numCol;
d219 8
a226 4
		*diskSector = info->mirrorStripeOffset * raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += sparing_region_id * (raidPtr->numCol - 1) * raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += mirror_su_offset_into_disk * raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d228 7
a234 4
		/* remap parity to spare space ... */
		*diskSector = sparing_region_id * (raidPtr->numCol + 1) * raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidPtr->numCol) * raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d242 3
a244 6
void 
rf_IdentifyStripeInterDecluster(
    RF_Raid_t * raidPtr,
    RF_RaidAddr_t addr,
    RF_RowCol_t ** diskids,
    RF_RowCol_t * outRow)
d246 2
a247 1
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d257 3
a259 6
void 
rf_MapSIDToPSIDInterDecluster(
    RF_RaidLayout_t * layoutPtr,
    RF_StripeNum_t stripeID,
    RF_StripeNum_t * psID,
    RF_ReconUnitNum_t * which_ru)
d264 4
a267 2
/******************************************************************************
 * select a graph to perform a single-stripe access
d269 4
a272 4
 * Parameters:  raidPtr    - description of the physical array
 *              type       - type of operation (read or write) requested
 *              asmap      - logical & physical addresses for this access
 *              createFunc - name of function to use to create the graph
d275 3
a277 6
void 
rf_RAIDIDagSelect(
    RF_Raid_t * raidPtr,
    RF_IoType_t type,
    RF_AccessStripeMap_t * asmap,
    RF_VoidFuncPtr * createFunc)
d282 2
a283 1
		RF_ERRORMSG("Multiple disks failed in a single group!  Aborting I/O operation.\n");
d287 3
a289 1
	*createFunc = (type == RF_IO_TYPE_READ) ? (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG : (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;
d292 2
a293 1
			*createFunc = (RF_VoidFuncPtr) rf_CreateMirrorPartitionReadDAG;
d295 2
a296 1
			*createFunc = (RF_VoidFuncPtr) rf_CreateRaidOneDegradedReadDAG;
@


1.3.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*************************************************************
d32 1
a32 1
 * rf_interdecluster.c -- Implements interleaved declustering.
d34 1
a34 1
 *************************************************************/
d51 12
a62 10
	/* Filled in at config time and used by IdentifyStripe. */
	RF_RowCol_t	**stripeIdentifier;
	RF_StripeCount_t  numSparingRegions;
	RF_StripeCount_t  stripeUnitsPerSparingRegion;
	RF_SectorNum_t	  mirrorStripeOffset;
}	RF_InterdeclusterConfigInfo_t;

int
rf_ConfigureInterDecluster(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d69 3
a71 3
	/* Create an Interleaved Declustering configuration structure. */
	RF_MallocAndAdd(info, sizeof(RF_InterdeclusterConfigInfo_t),
	    (RF_InterdeclusterConfigInfo_t *), raidPtr->cleanupList);
d76 1
a76 1
	/* Fill in the config structure. */
d78 1
a78 2
	info->stripeIdentifier = rf_make_2d_array(SUs_per_region, 2,
	    raidPtr->cleanupList);
d87 1
a87 1
	/* No spare tables. */
d90 1
a90 1
	/* Fill in the remaining layout parameters. */
d92 1
a92 2
	/*
	 * Total number of stripes should a multiple of 2*numCol: Each sparing
d94 10
a103 18
	 * secondary copy and 2 for spare...
	 */
	num_used_stripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk -
	    (layoutPtr->stripeUnitsPerDisk % (2 * raidPtr->numCol));
	info->numSparingRegions = num_used_stripeUnitsPerDisk /
	    (2 * raidPtr->numCol);
	/*
	 * This is in fact the number of stripe units (that are primary data
	 * copies) in the sparing region.
	 */
	info->stripeUnitsPerSparingRegion = raidPtr->numCol *
	    (raidPtr->numCol - 1);
	info->mirrorStripeOffset = info->numSparingRegions *
	    (raidPtr->numCol + 1);
	layoutPtr->numStripe = info->numSparingRegions *
	    info->stripeUnitsPerSparingRegion;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
d105 1
a105 2
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
d116 1
a116 2
	layoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk /
	    layoutPtr->sectorsPerStripeUnit;
d121 2
a122 2
int
rf_GetDefaultNumFloatingReconBuffersInterDecluster(RF_Raid_t *raidPtr)
d127 2
a128 2
RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitInterDecluster(RF_Raid_t *raidPtr)
d133 3
a135 2
RF_ReconUnitCount_t
rf_GetNumSpareRUsInterDecluster(RF_Raid_t *raidPtr)
d137 1
a137 2
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
d140 2
a141 4
	/*
	 * The layout uses two stripe units per disk as spare within each
	 * sparing region.
	 */
d143 9
a151 5

/* Maps to the primary copy of the data, i.e. the first mirror pair. */
void
rf_MapSectorInterDecluster(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t* diskSector, int remap)
d153 1
a153 2
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
d157 1
a157 1
	int col_before_remap;
d167 4
a170 5
		*col = col_before_remap;
		*diskSector = (su_offset_into_disk + ((raidPtr->numCol - 1) *
		    sparing_region_id)) * raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector +=
		    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d172 5
a176 9
		/* Remap sector to spare space... */
		*diskSector = sparing_region_id * (raidPtr->numCol + 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidPtr->numCol - 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector +=
		    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
		*col = (index_within_region + 1 + mirror_su_offset_into_disk) %
		    raidPtr->numCol;
a181 1

d183 8
a190 3
void
rf_MapParityInterDecluster(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d192 2
a193 4
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
	RF_StripeNum_t sparing_region_id, index_within_region;
	RF_StripeNum_t mirror_su_offset_into_disk;
d195 1
a195 1
	int col_before_remap;
d200 1
a200 2
	col_before_remap = (index_within_region + 1 +
	    mirror_su_offset_into_disk) % raidPtr->numCol;
d205 4
a208 8
		*diskSector = info->mirrorStripeOffset *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += sparing_region_id * (raidPtr->numCol - 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += mirror_su_offset_into_disk *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector +=
		    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d210 4
a213 7
		/* Remap parity to spare space... */
		*diskSector = sparing_region_id * (raidPtr->numCol + 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidPtr->numCol) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidSector %
		    raidPtr->Layout.sectorsPerStripeUnit);
d221 6
a226 3
void
rf_IdentifyStripeInterDecluster(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
d228 1
a228 2
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
d238 6
a243 3
void
rf_MapSIDToPSIDInterDecluster( RF_RaidLayout_t *layoutPtr,
    RF_StripeNum_t stripeID, RF_StripeNum_t *psID, RF_ReconUnitNum_t *which_ru)
d248 2
a249 4


/*****************************************************************************
 * Select a graph to perform a single-stripe access.
d251 4
a254 4
 * Parameters:	raidPtr	   - Description of the physical array.
 *		type	   - Type of operation (read or write) requested.
 *		asmap	   - Logical & physical addresses for this access.
 *		createFunc - Name of function to use to create the graph.
d257 6
a262 3
void
rf_RAIDIDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmap, RF_VoidFuncPtr *createFunc)
d267 1
a267 2
		RF_ERRORMSG("Multiple disks failed in a single group !"
		    "  Aborting I/O operation.\n");
d271 1
a271 3
	*createFunc = (type == RF_IO_TYPE_READ)
	    ? (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG
	    : (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;
d274 1
a274 2
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateMirrorPartitionReadDAG;
d276 1
a276 2
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateRaidOneDegradedReadDAG;
@


1.3.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*************************************************************
d32 1
a32 1
 * rf_interdecluster.c -- Implements interleaved declustering.
d34 1
a34 1
 *************************************************************/
d51 12
a62 10
	/* Filled in at config time and used by IdentifyStripe. */
	RF_RowCol_t	**stripeIdentifier;
	RF_StripeCount_t  numSparingRegions;
	RF_StripeCount_t  stripeUnitsPerSparingRegion;
	RF_SectorNum_t	  mirrorStripeOffset;
}	RF_InterdeclusterConfigInfo_t;

int
rf_ConfigureInterDecluster(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d69 3
a71 3
	/* Create an Interleaved Declustering configuration structure. */
	RF_MallocAndAdd(info, sizeof(RF_InterdeclusterConfigInfo_t),
	    (RF_InterdeclusterConfigInfo_t *), raidPtr->cleanupList);
d76 1
a76 1
	/* Fill in the config structure. */
d78 1
a78 2
	info->stripeIdentifier = rf_make_2d_array(SUs_per_region, 2,
	    raidPtr->cleanupList);
d87 1
a87 1
	/* No spare tables. */
d90 1
a90 1
	/* Fill in the remaining layout parameters. */
d92 1
a92 2
	/*
	 * Total number of stripes should a multiple of 2*numCol: Each sparing
d94 10
a103 18
	 * secondary copy and 2 for spare...
	 */
	num_used_stripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk -
	    (layoutPtr->stripeUnitsPerDisk % (2 * raidPtr->numCol));
	info->numSparingRegions = num_used_stripeUnitsPerDisk /
	    (2 * raidPtr->numCol);
	/*
	 * This is in fact the number of stripe units (that are primary data
	 * copies) in the sparing region.
	 */
	info->stripeUnitsPerSparingRegion = raidPtr->numCol *
	    (raidPtr->numCol - 1);
	info->mirrorStripeOffset = info->numSparingRegions *
	    (raidPtr->numCol + 1);
	layoutPtr->numStripe = info->numSparingRegions *
	    info->stripeUnitsPerSparingRegion;
	layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit <<
	    raidPtr->logBytesPerSector;
d105 1
a105 2
	layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol *
	    layoutPtr->sectorsPerStripeUnit;
d116 1
a116 2
	layoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk /
	    layoutPtr->sectorsPerStripeUnit;
d121 2
a122 2
int
rf_GetDefaultNumFloatingReconBuffersInterDecluster(RF_Raid_t *raidPtr)
d127 2
a128 2
RF_HeadSepLimit_t
rf_GetDefaultHeadSepLimitInterDecluster(RF_Raid_t *raidPtr)
d133 3
a135 2
RF_ReconUnitCount_t
rf_GetNumSpareRUsInterDecluster(RF_Raid_t *raidPtr)
d137 1
a137 2
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
d140 2
a141 4
	/*
	 * The layout uses two stripe units per disk as spare within each
	 * sparing region.
	 */
d143 9
a151 5

/* Maps to the primary copy of the data, i.e. the first mirror pair. */
void
rf_MapSectorInterDecluster(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t* diskSector, int remap)
d153 1
a153 2
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
d157 1
a157 1
	int col_before_remap;
d167 4
a170 5
		*col = col_before_remap;
		*diskSector = (su_offset_into_disk + ((raidPtr->numCol - 1) *
		    sparing_region_id)) * raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector +=
		    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d172 5
a176 9
		/* Remap sector to spare space... */
		*diskSector = sparing_region_id * (raidPtr->numCol + 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidPtr->numCol - 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector +=
		    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
		*col = (index_within_region + 1 + mirror_su_offset_into_disk) %
		    raidPtr->numCol;
a181 1

d183 8
a190 3
void
rf_MapParityInterDecluster(RF_Raid_t *raidPtr, RF_RaidAddr_t raidSector,
    RF_RowCol_t *row, RF_RowCol_t *col, RF_SectorNum_t *diskSector, int remap)
d192 2
a193 4
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
	RF_StripeNum_t sparing_region_id, index_within_region;
	RF_StripeNum_t mirror_su_offset_into_disk;
d195 1
a195 1
	int col_before_remap;
d200 1
a200 2
	col_before_remap = (index_within_region + 1 +
	    mirror_su_offset_into_disk) % raidPtr->numCol;
d205 4
a208 8
		*diskSector = info->mirrorStripeOffset *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += sparing_region_id * (raidPtr->numCol - 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += mirror_su_offset_into_disk *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector +=
		    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
d210 4
a213 7
		/* Remap parity to spare space... */
		*diskSector = sparing_region_id * (raidPtr->numCol + 1) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidPtr->numCol) *
		    raidPtr->Layout.sectorsPerStripeUnit;
		*diskSector += (raidSector %
		    raidPtr->Layout.sectorsPerStripeUnit);
d221 6
a226 3
void
rf_IdentifyStripeInterDecluster(RF_Raid_t *raidPtr, RF_RaidAddr_t addr,
    RF_RowCol_t **diskids, RF_RowCol_t *outRow)
d228 1
a228 2
	RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *)
	    raidPtr->Layout.layoutSpecificInfo;
d238 6
a243 3
void
rf_MapSIDToPSIDInterDecluster( RF_RaidLayout_t *layoutPtr,
    RF_StripeNum_t stripeID, RF_StripeNum_t *psID, RF_ReconUnitNum_t *which_ru)
d248 2
a249 4


/*****************************************************************************
 * Select a graph to perform a single-stripe access.
d251 4
a254 4
 * Parameters:	raidPtr	   - Description of the physical array.
 *		type	   - Type of operation (read or write) requested.
 *		asmap	   - Logical & physical addresses for this access.
 *		createFunc - Name of function to use to create the graph.
d257 6
a262 3
void
rf_RAIDIDagSelect(RF_Raid_t *raidPtr, RF_IoType_t type,
    RF_AccessStripeMap_t *asmap, RF_VoidFuncPtr *createFunc)
d267 1
a267 2
		RF_ERRORMSG("Multiple disks failed in a single group !"
		    "  Aborting I/O operation.\n");
d271 1
a271 3
	*createFunc = (type == RF_IO_TYPE_READ)
	    ? (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG
	    : (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;
d274 1
a274 2
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateMirrorPartitionReadDAG;
d276 1
a276 2
			*createFunc = (RF_VoidFuncPtr)
			    rf_CreateRaidOneDegradedReadDAG;
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_interdecluster.c,v 1.1 1999/01/11 14:29:26 niklas Exp $	*/
/*	$NetBSD: rf_interdecluster.c,v 1.3 1999/02/05 00:06:12 oster Exp $	*/
a42 1
#include "rf_threadid.h"
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_interdecluster.c,v 1.1 1998/11/13 04:20:30 oster Exp $	*/
/*	$NetBSD: rf_interdecluster.c,v 1.1 1998/11/13 04:20:30 oster Exp $	*/
d32 1
a32 1
 * rf_interdecluster.c -- implements interleaved declustering 
a35 88
/* :  
 * Log: rf_interdecluster.c,v 
 * Revision 1.24  1996/08/02 13:20:38  jimz
 * get rid of bogus (long) casts
 *
 * Revision 1.23  1996/07/31  16:56:18  jimz
 * dataBytesPerStripe, sectorsPerDisk init arch-indep.
 *
 * Revision 1.22  1996/07/29  14:05:12  jimz
 * fix numPUs/numRUs confusion (everything is now numRUs)
 * clean up some commenting, return values
 *
 * Revision 1.21  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.20  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.19  1996/07/13  00:00:59  jimz
 * sanitized generalized reconstruction architecture
 * cleaned up head sep, rbuf problems
 *
 * Revision 1.18  1996/06/19  17:53:48  jimz
 * move GetNumSparePUs, InstallSpareTable ops into layout switch
 *
 * Revision 1.17  1996/06/11  15:17:55  wvcii
 * added include of rf_interdecluster.h
 * fixed parameter list of rf_ConfigureInterDecluster
 * fixed return type of rf_GetNumSparePUsInterDecluster
 * removed include of rf_raid1.h
 *
 * Revision 1.16  1996/06/11  08:55:15  jimz
 * improved error-checking at configuration time
 *
 * Revision 1.15  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.14  1996/06/07  22:26:27  jimz
 * type-ify which_ru (RF_ReconUnitNum_t)
 *
 * Revision 1.13  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.12  1996/06/06  18:41:48  jimz
 * add interleaved declustering dag selection
 *
 * Revision 1.11  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.10  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.9  1996/05/31  05:03:01  amiri
 * fixed a bug related to sparing layout.
 *
 * Revision 1.8  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.7  1996/05/24  01:59:45  jimz
 * another checkpoint in code cleanup for release
 * time to sync kernel tree
 *
 * Revision 1.6  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.5  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.4  1996/05/03  19:50:38  wvcii
 * removed include of rf_redstripe.h
 * fixed change log parameters in header
 *
 */
d52 12
a63 11
  RF_RowCol_t       **stripeIdentifier;   /* filled in at config time
                                           * and used by IdentifyStripe */
  RF_StripeCount_t    numSparingRegions;
  RF_StripeCount_t    stripeUnitsPerSparingRegion;
  RF_SectorNum_t      mirrorStripeOffset;  
} RF_InterdeclusterConfigInfo_t;

int rf_ConfigureInterDecluster(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
d65 48
a112 46
  RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
  RF_StripeCount_t num_used_stripeUnitsPerDisk;
  RF_InterdeclusterConfigInfo_t *info;
  RF_RowCol_t i, tmp, SUs_per_region;
  
  /* create an Interleaved Declustering configuration structure */
  RF_MallocAndAdd(info, sizeof(RF_InterdeclusterConfigInfo_t), (RF_InterdeclusterConfigInfo_t *), 
			raidPtr->cleanupList);
  if (info == NULL)
    return(ENOMEM);
  layoutPtr->layoutSpecificInfo = (void *) info;

  /*  fill in the config structure.  */
  SUs_per_region = raidPtr->numCol * (raidPtr->numCol - 1);
  info->stripeIdentifier = rf_make_2d_array(SUs_per_region, 2 , raidPtr->cleanupList);
  if (info->stripeIdentifier == NULL)
    return(ENOMEM);
  for (i=0; i< SUs_per_region; i++) {
      info->stripeIdentifier[i][0] = i / (raidPtr->numCol-1);
      tmp = i / raidPtr->numCol;
      info->stripeIdentifier[i][1] = (i+1+tmp) % raidPtr->numCol;
    }

  /* no spare tables */
  RF_ASSERT(raidPtr->numRow == 1);

  /* fill in the remaining layout parameters */

  /* total number of stripes should a multiple of 2*numCol: Each sparing region consists of
   2*numCol stripes: n-1 primary copy, n-1 secondary copy and 2 for spare .. */ 
    num_used_stripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk - (layoutPtr->stripeUnitsPerDisk %
	(2*raidPtr->numCol) );
  info->numSparingRegions = num_used_stripeUnitsPerDisk / (2*raidPtr->numCol);
  /* this is in fact the number of stripe units (that are primary data copies) in the sparing region */
  info->stripeUnitsPerSparingRegion = raidPtr->numCol * (raidPtr->numCol - 1);
  info->mirrorStripeOffset = info->numSparingRegions * (raidPtr->numCol+1);
  layoutPtr->numStripe = info->numSparingRegions * info->stripeUnitsPerSparingRegion;
  layoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;
  layoutPtr->numDataCol = 1;
  layoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;
  layoutPtr->numParityCol = 1;
 
  layoutPtr->dataStripeUnitsPerDisk = num_used_stripeUnitsPerDisk;

  raidPtr->sectorsPerDisk = 
    num_used_stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;
d114 2
a115 2
  raidPtr->totalSectors = 
    (layoutPtr->numStripe) * layoutPtr->sectorsPerStripeUnit;
d117 1
a117 1
  layoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk / layoutPtr->sectorsPerStripeUnit;
d119 1
a119 1
  return(0);
d122 2
a123 1
int rf_GetDefaultNumFloatingReconBuffersInterDecluster(RF_Raid_t *raidPtr)
d125 1
a125 1
  return(30);
d128 2
a129 1
RF_HeadSepLimit_t rf_GetDefaultHeadSepLimitInterDecluster(RF_Raid_t *raidPtr)
d131 1
a131 1
  return(raidPtr->sectorsPerDisk);
d134 3
a136 2
RF_ReconUnitCount_t rf_GetNumSpareRUsInterDecluster(
  RF_Raid_t  *raidPtr)
d138 1
a138 1
  RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
d140 3
a142 2
  return ( 2 * ((RF_ReconUnitCount_t) info->numSparingRegions) ); 
	/* the layout uses two stripe units per disk as spare within each sparing region */
a143 1

d145 8
a152 7
void rf_MapSectorInterDecluster(
  RF_Raid_t         *raidPtr,
  RF_RaidAddr_t      raidSector,
  RF_RowCol_t       *row,
  RF_RowCol_t       *col,
  RF_SectorNum_t    *diskSector,
  int                remap)
d154 28
a181 28
 RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
 RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
 RF_StripeNum_t su_offset_into_disk, mirror_su_offset_into_disk;
 RF_StripeNum_t sparing_region_id, index_within_region;
 int col_before_remap;

 *row = 0;
 sparing_region_id = SUID / info->stripeUnitsPerSparingRegion;
 index_within_region = SUID % info->stripeUnitsPerSparingRegion;
 su_offset_into_disk = index_within_region % (raidPtr->numCol-1);
 mirror_su_offset_into_disk = index_within_region / raidPtr->numCol;
 col_before_remap = index_within_region / (raidPtr->numCol-1);

 if (!remap) {
        *col = col_before_remap;;
        *diskSector = ( su_offset_into_disk + ( (raidPtr->numCol-1) * sparing_region_id) ) *
                        raidPtr->Layout.sectorsPerStripeUnit;
        *diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
      }
 else {
      /* remap sector to spare space...*/
      *diskSector = sparing_region_id * (raidPtr->numCol+1) * raidPtr->Layout.sectorsPerStripeUnit;
      *diskSector += (raidPtr->numCol-1) * raidPtr->Layout.sectorsPerStripeUnit;
      *diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
      *col = (index_within_region + 1 + mirror_su_offset_into_disk) % raidPtr->numCol;
      *col = (*col + 1) % raidPtr->numCol;
      if (*col == col_before_remap) *col = (*col + 1) % raidPtr->numCol;
   }
a182 1

d184 8
a191 7
void rf_MapParityInterDecluster(
  RF_Raid_t       *raidPtr,
  RF_RaidAddr_t    raidSector,
  RF_RowCol_t     *row,
  RF_RowCol_t     *col,
  RF_SectorNum_t  *diskSector,
  int              remap)
d193 27
a219 27
  RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
  RF_StripeNum_t sparing_region_id, index_within_region, mirror_su_offset_into_disk;
  RF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;
  int col_before_remap;
  
  sparing_region_id = SUID / info->stripeUnitsPerSparingRegion;
  index_within_region = SUID % info->stripeUnitsPerSparingRegion;
  mirror_su_offset_into_disk = index_within_region / raidPtr->numCol;
  col_before_remap = (index_within_region + 1 + mirror_su_offset_into_disk) % raidPtr->numCol;

  *row = 0;
  if (!remap) {
        *col = col_before_remap;
        *diskSector =  info->mirrorStripeOffset * raidPtr->Layout.sectorsPerStripeUnit;
        *diskSector += sparing_region_id * (raidPtr->numCol-1)  * raidPtr->Layout.sectorsPerStripeUnit;
        *diskSector += mirror_su_offset_into_disk * raidPtr->Layout.sectorsPerStripeUnit;
        *diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
       }
  else {
        /* remap parity to spare space ... */
        *diskSector =  sparing_region_id * (raidPtr->numCol+1) * raidPtr->Layout.sectorsPerStripeUnit;
        *diskSector += (raidPtr->numCol) * raidPtr->Layout.sectorsPerStripeUnit;
        *diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);
        *col = index_within_region / (raidPtr->numCol-1);
        *col = (*col + 1) % raidPtr->numCol;
        if (*col == col_before_remap) *col = (*col + 1) % raidPtr->numCol;
  }
d222 6
a227 5
void rf_IdentifyStripeInterDecluster(
  RF_Raid_t        *raidPtr,
  RF_RaidAddr_t     addr,
  RF_RowCol_t     **diskids,
  RF_RowCol_t      *outRow)
d229 2
a230 2
  RF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;
  RF_StripeNum_t SUID;
d232 2
a233 2
  SUID = addr / raidPtr->Layout.sectorsPerStripeUnit;
  SUID = SUID % info->stripeUnitsPerSparingRegion;
d235 2
a236 2
  *outRow = 0;
  *diskids = info->stripeIdentifier[ SUID ];
d239 6
a244 5
void rf_MapSIDToPSIDInterDecluster(
  RF_RaidLayout_t    *layoutPtr,
  RF_StripeNum_t      stripeID,
  RF_StripeNum_t     *psID,
  RF_ReconUnitNum_t  *which_ru)
d246 2
a247 2
  *which_ru = 0;
  *psID = stripeID;
a248 1

d258 6
a263 5
void rf_RAIDIDagSelect(
  RF_Raid_t             *raidPtr,
  RF_IoType_t            type,
  RF_AccessStripeMap_t  *asmap,
  RF_VoidFuncPtr *createFunc)
d265 1
a265 1
  RF_ASSERT(RF_IO_IS_R_OR_W(type));
d267 13
a279 15
  if (asmap->numDataFailed + asmap->numParityFailed > 1) {
    RF_ERRORMSG("Multiple disks failed in a single group!  Aborting I/O operation.\n");
    *createFunc = NULL;
    return;
  }
  
  *createFunc = (type == RF_IO_TYPE_READ) ? (RF_VoidFuncPtr)rf_CreateFaultFreeReadDAG : (RF_VoidFuncPtr)rf_CreateRaidOneWriteDAG;
  if (type == RF_IO_TYPE_READ) {
    if (asmap->numDataFailed == 0)
      *createFunc = (RF_VoidFuncPtr)rf_CreateMirrorPartitionReadDAG;
    else
      *createFunc = (RF_VoidFuncPtr)rf_CreateRaidOneDegradedReadDAG;
  }
  else
    *createFunc = (RF_VoidFuncPtr)rf_CreateRaidOneWriteDAG;
@

