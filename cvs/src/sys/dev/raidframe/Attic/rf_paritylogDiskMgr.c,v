head	1.8;
access;
symbols
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.34
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.32
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.28
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.30
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.26
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.24
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.22
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.20
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.12
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.10
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.8
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.7;

1.7
date	2011.06.21.16.46.00;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.08.16.07.43;	author peter;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2000.01.11.18.02.22;	author peter;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.01.07.14.50.22;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.05;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.34;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.14.22.26.13;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.5.8.1
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_paritylogDiskMgr.c,v 1.7 2011/06/21 16:46:00 tedu Exp $	*/
/*	$NetBSD: rf_paritylogDiskMgr.c,v 1.10 2000/01/15 01:57:57 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: William V. Courtright II
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */
/*
 * Code for flushing and reintegrating operations related to parity logging.
 */

#include "rf_archs.h"

#if	RF_INCLUDE_PARITYLOGGING > 0

#include "rf_types.h"
#include "rf_threadstuff.h"
#include "rf_mcpair.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagfuncs.h"
#include "rf_desc.h"
#include "rf_layout.h"
#include "rf_diskqueue.h"
#include "rf_paritylog.h"
#include "rf_general.h"
#include "rf_etimer.h"
#include "rf_paritylogging.h"
#include "rf_engine.h"
#include "rf_dagutils.h"
#include "rf_map.h"
#include "rf_parityscan.h"

#include "rf_paritylogDiskMgr.h"

caddr_t rf_AcquireReintBuffer(RF_RegionBufferQueue_t *);
void rf_ReleaseReintBuffer(RF_RegionBufferQueue_t *, caddr_t);
void rf_ReadRegionLog(RF_RegionId_t, RF_MCPair_t *, caddr_t, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_WriteCoreLog(RF_ParityLog_t *, RF_MCPair_t *, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_ReadRegionParity(RF_RegionId_t, RF_MCPair_t *, caddr_t, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_WriteRegionParity(RF_RegionId_t, RF_MCPair_t *, caddr_t, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_FlushLogsToDisk(RF_Raid_t *, RF_ParityLog_t *);
void rf_ReintegrateRegion(RF_Raid_t *, RF_RegionId_t, RF_ParityLog_t *);
void rf_ReintegrateLogs(RF_Raid_t *, RF_ParityLog_t *);


caddr_t
rf_AcquireReintBuffer(RF_RegionBufferQueue_t *pool)
{
	caddr_t bufPtr = NULL;

	/*
	 * Return a region buffer from the free list (pool). If the free list
	 * is empty, WAIT. BLOCKING
	 */

	RF_LOCK_MUTEX(pool->mutex);
	if (pool->availableBuffers > 0) {
		bufPtr = pool->buffers[pool->availBuffersIndex];
		pool->availableBuffers--;
		pool->availBuffersIndex++;
		if (pool->availBuffersIndex == pool->totalBuffers)
			pool->availBuffersIndex = 0;
		RF_UNLOCK_MUTEX(pool->mutex);
	} else {
		RF_PANIC();	/*
				 * Should never happen in correct config,
				 * single reint.
				 */
		RF_WAIT_COND(pool->cond, pool->mutex);
	}
	return (bufPtr);
}


void
rf_ReleaseReintBuffer(RF_RegionBufferQueue_t *pool, caddr_t bufPtr)
{
	/*
	 * Insert a region buffer (bufPtr) into the free list (pool).
	 * NON-BLOCKING
	 */

	RF_LOCK_MUTEX(pool->mutex);
	pool->availableBuffers++;
	pool->buffers[pool->emptyBuffersIndex] = bufPtr;
	pool->emptyBuffersIndex++;
	if (pool->emptyBuffersIndex == pool->totalBuffers)
		pool->emptyBuffersIndex = 0;
	RF_ASSERT(pool->availableBuffers <= pool->totalBuffers);
	RF_UNLOCK_MUTEX(pool->mutex);
	RF_SIGNAL_COND(pool->cond);
}


void
rf_ReadRegionLog(RF_RegionId_t regionID, RF_MCPair_t *rrd_mcpair,
    caddr_t regionBuffer, RF_Raid_t *raidPtr, RF_DagHeader_t **rrd_dag_h,
    RF_AllocListElem_t **rrd_alloclist, RF_PhysDiskAddr_t **rrd_pda)
{
	/*
	 * Initiate the read a region log from disk. Once initiated, return
	 * to the calling routine.
	 *
	 * NON-BLOCKING
	 */

	RF_AccTraceEntry_t *tracerec;
	RF_DagNode_t *rrd_rdNode;

	/* Create DAG to read region log from disk. */
	rf_MakeAllocList(*rrd_alloclist);
	*rrd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, regionBuffer,
	    rf_DiskReadFunc, rf_DiskReadUndoFunc, "Rrl", *rrd_alloclist,
	    RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for the core log. */
	/* RF_Malloc(*rrd_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
	*rrd_pda = rf_AllocPDAList(1);
	rf_MapLogParityLogging(raidPtr, regionID, 0, &((*rrd_pda)->row),
	    &((*rrd_pda)->col), &((*rrd_pda)->startSector));
	(*rrd_pda)->numSector = raidPtr->regionInfo[regionID].capacity;

	if ((*rrd_pda)->next) {
		(*rrd_pda)->next = NULL;
		printf("set rrd_pda->next to NULL\n");
	}
	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
	bzero(tracerec, sizeof(RF_AccTraceEntry_t));
	(*rrd_dag_h)->tracerec = tracerec;
	rrd_rdNode = (*rrd_dag_h)->succedents[0]->succedents[0];
	rrd_rdNode->params[0].p = *rrd_pda;
	/* rrd_rdNode->params[1] = regionBuffer; */
	rrd_rdNode->params[2].v = 0;
	rrd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
						   0, 0, 0);

	/* Launch region log read dag. */
	rf_DispatchDAG(*rrd_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,
	    (void *) rrd_mcpair);
}


void
rf_WriteCoreLog(RF_ParityLog_t *log, RF_MCPair_t *fwr_mcpair,
    RF_Raid_t *raidPtr, RF_DagHeader_t **fwr_dag_h,
    RF_AllocListElem_t **fwr_alloclist, RF_PhysDiskAddr_t **fwr_pda)
{
	RF_RegionId_t regionID = log->regionID;
	RF_AccTraceEntry_t *tracerec;
	RF_SectorNum_t regionOffset;
	RF_DagNode_t *fwr_wrNode;

	/*
	 * Initiate the write of a core log to a region log disk. Once
	 * initiated, return to the calling routine.
	 *
	 * NON-BLOCKING
	 */

	/* Create DAG to write a core log to a region log disk. */
	rf_MakeAllocList(*fwr_alloclist);
	*fwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, log->bufPtr,
	    rf_DiskWriteFunc, rf_DiskWriteUndoFunc, "Wcl", *fwr_alloclist,
	    RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for the region log. */
	/* RF_Malloc(*fwr_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
	*fwr_pda = rf_AllocPDAList(1);
	regionOffset = log->diskOffset;
	rf_MapLogParityLogging(raidPtr, regionID, regionOffset,
	    &((*fwr_pda)->row), &((*fwr_pda)->col), &((*fwr_pda)->startSector));
	(*fwr_pda)->numSector = raidPtr->numSectorsPerLog;

	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
	bzero(tracerec, sizeof(RF_AccTraceEntry_t));
	(*fwr_dag_h)->tracerec = tracerec;
	fwr_wrNode = (*fwr_dag_h)->succedents[0]->succedents[0];
	fwr_wrNode->params[0].p = *fwr_pda;
	/* fwr_wrNode->params[1] = log->bufPtr; */
	fwr_wrNode->params[2].v = 0;
	fwr_wrNode->params[3].v =
	    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);

	/* Launch the dag to write the core log to disk. */
	rf_DispatchDAG(*fwr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,
	    (void *) fwr_mcpair);
}


void
rf_ReadRegionParity(RF_RegionId_t regionID, RF_MCPair_t *prd_mcpair,
    caddr_t parityBuffer, RF_Raid_t *raidPtr, RF_DagHeader_t **prd_dag_h,
    RF_AllocListElem_t **prd_alloclist, RF_PhysDiskAddr_t **prd_pda)
{
	/*
	 * Initiate the read region parity from disk. Once initiated, return
	 * to the calling routine.
	 *
	 * NON-BLOCKING
	 */

	RF_AccTraceEntry_t *tracerec;
	RF_DagNode_t *prd_rdNode;

	/* Create DAG to read region parity from disk. */
	rf_MakeAllocList(*prd_alloclist);
	*prd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, NULL, rf_DiskReadFunc,
	    rf_DiskReadUndoFunc, "Rrp", *prd_alloclist, RF_DAG_FLAGS_NONE,
	    RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for region parity. */
	/* RF_Malloc(*prd_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
	*prd_pda = rf_AllocPDAList(1);
	rf_MapRegionParity(raidPtr, regionID, &((*prd_pda)->row),
	    &((*prd_pda)->col), &((*prd_pda)->startSector),
	    &((*prd_pda)->numSector));
	if (rf_parityLogDebug)
		printf("[reading %d sectors of parity from region %d]\n",
		    (int) (*prd_pda)->numSector, regionID);
	if ((*prd_pda)->next) {
		(*prd_pda)->next = NULL;
		printf("set prd_pda->next to NULL\n");
	}
	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
	bzero(tracerec, sizeof(RF_AccTraceEntry_t));
	(*prd_dag_h)->tracerec = tracerec;
	prd_rdNode = (*prd_dag_h)->succedents[0]->succedents[0];
	prd_rdNode->params[0].p = *prd_pda;
	prd_rdNode->params[1].p = parityBuffer;
	prd_rdNode->params[2].v = 0;
	prd_rdNode->params[3].v =
	    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
	if (rf_validateDAGDebug)
		rf_ValidateDAG(*prd_dag_h);
	/* Launch region parity read dag. */
	rf_DispatchDAG(*prd_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,
	    (void *) prd_mcpair);
}

void
rf_WriteRegionParity(RF_RegionId_t regionID, RF_MCPair_t *pwr_mcpair,
    caddr_t parityBuffer, RF_Raid_t *raidPtr, RF_DagHeader_t **pwr_dag_h,
    RF_AllocListElem_t **pwr_alloclist, RF_PhysDiskAddr_t **pwr_pda)
{
	/*
	 * Initiate the write of region parity to disk. Once initiated, return
	 * to the calling routine.
	 *
	 * NON-BLOCKING
	 */

	RF_AccTraceEntry_t *tracerec;
	RF_DagNode_t *pwr_wrNode;

	/* Create DAG to write region log from disk. */
	rf_MakeAllocList(*pwr_alloclist);
	*pwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, parityBuffer,
	    rf_DiskWriteFunc, rf_DiskWriteUndoFunc, "Wrp", *pwr_alloclist,
	    RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for region parity. */
	/* RF_Malloc(*pwr_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
	*pwr_pda = rf_AllocPDAList(1);
	rf_MapRegionParity(raidPtr, regionID, &((*pwr_pda)->row),
	    &((*pwr_pda)->col), &((*pwr_pda)->startSector),
	    &((*pwr_pda)->numSector));

	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
	bzero(tracerec, sizeof(RF_AccTraceEntry_t));
	(*pwr_dag_h)->tracerec = tracerec;
	pwr_wrNode = (*pwr_dag_h)->succedents[0]->succedents[0];
	pwr_wrNode->params[0].p = *pwr_pda;
	/* pwr_wrNode->params[1] = parityBuffer; */
	pwr_wrNode->params[2].v = 0;
	pwr_wrNode->params[3].v =
	    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);

	/* Launch the dag to write region parity to disk. */
	rf_DispatchDAG(*pwr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,
	    (void *) pwr_mcpair);
}

void
rf_FlushLogsToDisk(RF_Raid_t *raidPtr, RF_ParityLog_t *logList)
{
	/*
	 * Flush a linked list of core logs to the log disk. Logs contain the
	 * disk location where they should be written. Logs were written in
	 * FIFO order and that order must be preserved.
	 *
	 * Recommended optimizations:
	 * 1) Allow multiple flushes to occur simultaneously.
	 * 2) Coalesce contiguous flush operations.
	 *
	 * BLOCKING
	 */

	RF_ParityLog_t *log;
	RF_RegionId_t regionID;
	RF_MCPair_t *fwr_mcpair;
	RF_DagHeader_t *fwr_dag_h;
	RF_AllocListElem_t *fwr_alloclist;
	RF_PhysDiskAddr_t *fwr_pda;

	fwr_mcpair = rf_AllocMCPair();
	RF_LOCK_MUTEX(fwr_mcpair->mutex);

	RF_ASSERT(logList);
	log = logList;
	while (log) {
		regionID = log->regionID;

		/* Create and launch a DAG to write the core log. */
		if (rf_parityLogDebug)
			printf("[initiating write of core log for region"
			    " %d]\n", regionID);
		fwr_mcpair->flag = RF_FALSE;
		rf_WriteCoreLog(log, fwr_mcpair, raidPtr, &fwr_dag_h,
		    &fwr_alloclist, &fwr_pda);

		/* Wait for the DAG to complete. */
		while (!fwr_mcpair->flag)
			RF_WAIT_COND(fwr_mcpair->cond, fwr_mcpair->mutex);
		if (fwr_dag_h->status != rf_enable) {
			RF_ERRORMSG1("Unable to write core log to disk"
			    " (region %d)\n", regionID);
			RF_ASSERT(0);
		}
		/* RF_Free(fwr_pda, sizeof(RF_PhysDiskAddr_t)); */
		rf_FreePhysDiskAddr(fwr_pda);
		rf_FreeDAG(fwr_dag_h);
		rf_FreeAllocList(fwr_alloclist);

		log = log->next;
	}
	RF_UNLOCK_MUTEX(fwr_mcpair->mutex);
	rf_FreeMCPair(fwr_mcpair);
	rf_ReleaseParityLogs(raidPtr, logList);
}

void
rf_ReintegrateRegion(RF_Raid_t *raidPtr, RF_RegionId_t regionID,
    RF_ParityLog_t *coreLog)
{
	RF_MCPair_t *rrd_mcpair = NULL, *prd_mcpair, *pwr_mcpair;
	RF_DagHeader_t *rrd_dag_h, *prd_dag_h, *pwr_dag_h;
	RF_AllocListElem_t *rrd_alloclist, *prd_alloclist, *pwr_alloclist;
	RF_PhysDiskAddr_t *rrd_pda, *prd_pda, *pwr_pda;
	caddr_t parityBuffer, regionBuffer = NULL;

	/*
	 * Reintegrate a region (regionID).
	 *
	 * 1. Acquire region and parity buffers.
	 * 2. Read log from disk.
	 * 3. Read parity from disk.
	 * 4. Apply log to parity.
	 * 5. Apply core log to parity.
	 * 6. Write new parity to disk.
	 *
	 * BLOCKING
	 */

	if (rf_parityLogDebug)
		printf("[reintegrating region %d]\n", regionID);

	/* Initiate read of region parity. */
	if (rf_parityLogDebug)
		printf("[initiating read of parity for region %d]\n", regionID);
	parityBuffer = rf_AcquireReintBuffer(&raidPtr->parityBufferPool);
	prd_mcpair = rf_AllocMCPair();
	RF_LOCK_MUTEX(prd_mcpair->mutex);
	prd_mcpair->flag = RF_FALSE;
	rf_ReadRegionParity(regionID, prd_mcpair, parityBuffer, raidPtr,
			 &prd_dag_h, &prd_alloclist, &prd_pda);

	/* If region log nonempty, initiate read. */
	if (raidPtr->regionInfo[regionID].diskCount > 0) {
		if (rf_parityLogDebug)
			printf("[initiating read of disk log for region %d]\n",
			    regionID);
		regionBuffer =
		    rf_AcquireReintBuffer(&raidPtr->regionBufferPool);
		rrd_mcpair = rf_AllocMCPair();
		RF_LOCK_MUTEX(rrd_mcpair->mutex);
		rrd_mcpair->flag = RF_FALSE;
		rf_ReadRegionLog(regionID, rrd_mcpair, regionBuffer, raidPtr,
		    &rrd_dag_h, &rrd_alloclist, &rrd_pda);
	}
	/* Wait on read of region parity to complete. */
	while (!prd_mcpair->flag) {
		RF_WAIT_COND(prd_mcpair->cond, prd_mcpair->mutex);
	}
	RF_UNLOCK_MUTEX(prd_mcpair->mutex);
	if (prd_dag_h->status != rf_enable) {
		RF_ERRORMSG("Unable to read parity from disk\n");
		/* Add code to fail the parity disk. */
		RF_ASSERT(0);
	}
	/* Apply core log to parity. */
	/* if (coreLog) ApplyLogsToParity(coreLog, parityBuffer); */

	if (raidPtr->regionInfo[regionID].diskCount > 0) {
		/* Wait on read of region log to complete. */
		while (!rrd_mcpair->flag)
			RF_WAIT_COND(rrd_mcpair->cond, rrd_mcpair->mutex);
		RF_UNLOCK_MUTEX(rrd_mcpair->mutex);
		if (rrd_dag_h->status != rf_enable) {
			RF_ERRORMSG("Unable to read region log from disk\n");
			/* Add code to fail the log disk. */
			RF_ASSERT(0);
		}
		/* Apply region log to parity. */
		/* ApplyRegionToParity(regionID, regionBuffer, parityBuffer); */
		/* Release resources associated with region log. */
		/* RF_Free(rrd_pda, sizeof(RF_PhysDiskAddr_t)); */
		rf_FreePhysDiskAddr(rrd_pda);
		rf_FreeDAG(rrd_dag_h);
		rf_FreeAllocList(rrd_alloclist);
		rf_FreeMCPair(rrd_mcpair);
		rf_ReleaseReintBuffer(&raidPtr->regionBufferPool, regionBuffer);
	}
	/* Write reintegrated parity to disk. */
	if (rf_parityLogDebug)
		printf("[initiating write of parity for region %d]\n",
		    regionID);
	pwr_mcpair = rf_AllocMCPair();
	RF_LOCK_MUTEX(pwr_mcpair->mutex);
	pwr_mcpair->flag = RF_FALSE;
	rf_WriteRegionParity(regionID, pwr_mcpair, parityBuffer, raidPtr,
	    &pwr_dag_h, &pwr_alloclist, &pwr_pda);
	while (!pwr_mcpair->flag)
		RF_WAIT_COND(pwr_mcpair->cond, pwr_mcpair->mutex);
	RF_UNLOCK_MUTEX(pwr_mcpair->mutex);
	if (pwr_dag_h->status != rf_enable) {
		RF_ERRORMSG("Unable to write parity to disk\n");
		/* Add code to fail the parity disk. */
		RF_ASSERT(0);
	}
	/* Release resources associated with read of old parity. */
	/* RF_Free(prd_pda, sizeof(RF_PhysDiskAddr_t)); */
	rf_FreePhysDiskAddr(prd_pda);
	rf_FreeDAG(prd_dag_h);
	rf_FreeAllocList(prd_alloclist);
	rf_FreeMCPair(prd_mcpair);

	/* Release resources associated with write of new parity. */
	rf_ReleaseReintBuffer(&raidPtr->parityBufferPool, parityBuffer);
	/* RF_Free(pwr_pda, sizeof(RF_PhysDiskAddr_t)); */
	rf_FreePhysDiskAddr(pwr_pda);
	rf_FreeDAG(pwr_dag_h);
	rf_FreeAllocList(pwr_alloclist);
	rf_FreeMCPair(pwr_mcpair);

	if (rf_parityLogDebug)
		printf("[finished reintegrating region %d]\n", regionID);
}


void
rf_ReintegrateLogs(RF_Raid_t *raidPtr, RF_ParityLog_t *logList)
{
	RF_ParityLog_t *log, *freeLogList = NULL;
	RF_ParityLogData_t *logData, *logDataList;
	RF_RegionId_t regionID;

	RF_ASSERT(logList);
	while (logList) {
		log = logList;
		logList = logList->next;
		log->next = NULL;
		regionID = log->regionID;
		rf_ReintegrateRegion(raidPtr, regionID, log);
		log->numRecords = 0;

		/*
		 * Remove all items which are blocked on reintegration of this
		 * region.
		 */
		RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
		logData = rf_SearchAndDequeueParityLogData(raidPtr, regionID,
		    &raidPtr->parityLogDiskQueue.reintBlockHead,
		    &raidPtr->parityLogDiskQueue.reintBlockTail, RF_TRUE);
		logDataList = logData;
		while (logData) {
			logData->next =
			    rf_SearchAndDequeueParityLogData(raidPtr, regionID,
			     &raidPtr->parityLogDiskQueue.reintBlockHead,
			     &raidPtr->parityLogDiskQueue.reintBlockTail,
			     RF_TRUE);
			logData = logData->next;
		}
		RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);

		/*
		 * Process blocked log data and clear reintInProgress flag for
		 * this region.
		 */
		if (logDataList)
			rf_ParityLogAppend(logDataList, RF_TRUE, &log, RF_TRUE);
		else {
			/*
			 * Enable flushing for this region. Holding both
			 * locks provides a synchronization barrier with
			 * DumpParityLogToDisk.
			 */
			RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
			RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
			RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
			raidPtr->regionInfo[regionID].diskCount = 0;
			raidPtr->regionInfo[regionID].reintInProgress =
			    RF_FALSE;
			RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
			RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID]
			    .reintMutex);	/* Flushing is now enabled. */
			RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
		}
		/*
		 * If log wasn't used, attach it to the list of logs to be
		 * returned.
		 */
		if (log) {
			log->next = freeLogList;
			freeLogList = log;
		}
	}
	if (freeLogList)
		rf_ReleaseParityLogs(raidPtr, freeLogList);
}

int
rf_ShutdownLogging(RF_Raid_t *raidPtr)
{
	/*
	 * Shutdown parity logging:
	 * 1) Disable parity logging in all regions.
	 * 2) Reintegrate all regions.
	 */

	RF_SectorCount_t diskCount;
	RF_RegionId_t regionID;
	RF_ParityLog_t *log;

	if (rf_parityLogDebug)
		printf("[shutting down parity logging]\n");
	/*
	 * Since parity log maps are volatile, we must reintegrate all
	 * regions.
	 */
	if (rf_forceParityLogReint) {
		for (regionID = 0; regionID < rf_numParityRegions; regionID++) {
			RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
			raidPtr->regionInfo[regionID].loggingEnabled = RF_FALSE;
			log = raidPtr->regionInfo[regionID].coreLog;
			raidPtr->regionInfo[regionID].coreLog = NULL;
			diskCount = raidPtr->regionInfo[regionID].diskCount;
			RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
			if (diskCount > 0 || log != NULL)
				rf_ReintegrateRegion(raidPtr, regionID, log);
			if (log != NULL)
				rf_ReleaseParityLogs(raidPtr, log);
		}
	}
	if (rf_parityLogDebug) {
		printf("[parity logging disabled]\n");
		printf("[should be done !]\n");
	}
	return (0);
}

int
rf_ParityLoggingDiskManager(RF_Raid_t *raidPtr)
{
	RF_ParityLog_t *reintQueue, *flushQueue;
	int workNeeded, done = RF_FALSE;
	int s;

	/*
	 * Main program for parity logging disk thread. This routine waits
	 * for work to appear in either the flush or reintegration queues and
	 * is responsible for flushing core logs to the log disk as well as
	 * reintegrating parity regions.
	 *
	 * BLOCKING
	 */

	s = splbio();

	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);

	/*
	 * Inform our creator that we're running. Don't bother doing the
	 * mutex lock/unlock dance: we locked above, and we'll unlock
	 * below with nothing to do, yet.
	 */
	raidPtr->parityLogDiskQueue.threadState |= RF_PLOG_RUNNING;
	RF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);

	/* Empty the work queues. */
	flushQueue = raidPtr->parityLogDiskQueue.flushQueue;
	raidPtr->parityLogDiskQueue.flushQueue = NULL;
	reintQueue = raidPtr->parityLogDiskQueue.reintQueue;
	raidPtr->parityLogDiskQueue.reintQueue = NULL;
	workNeeded = (flushQueue || reintQueue);

	while (!done) {
		while (workNeeded) {
			/*
			 * First, flush all logs in the flush queue, freeing
			 * buffers. Second, reintegrate all regions that are
			 * reported as full. Third, append queued log data
			 * until blocked.
			 *
			 * Note: Incoming appends (ParityLogAppend) can block
			 * on either 1. empty buffer pool 2. region under
			 * reintegration. To preserve a global FIFO ordering of
			 * appends, buffers are not released to the world
			 * until those appends blocked on buffers are removed
			 * from the append queue. Similarly, regions that are
			 * reintegrated are not opened for general use until
			 * the append queue has been emptied.
			 */

			RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);

			/*
			 * Empty flushQueue, using free'd log buffers to
			 * process bufTail.
			 */
			if (flushQueue)
				rf_FlushLogsToDisk(raidPtr, flushQueue);

			/*
			 * Empty reintQueue, flushing from reintTail as we go.
			 */
			if (reintQueue)
				rf_ReintegrateLogs(raidPtr, reintQueue);

			RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
			flushQueue = raidPtr->parityLogDiskQueue.flushQueue;
			raidPtr->parityLogDiskQueue.flushQueue = NULL;
			reintQueue = raidPtr->parityLogDiskQueue.reintQueue;
			raidPtr->parityLogDiskQueue.reintQueue = NULL;
			workNeeded = (flushQueue || reintQueue);
		}
		/* No work is needed at this point. */
		if (raidPtr->parityLogDiskQueue.threadState & RF_PLOG_TERMINATE) {
			/*
			 * Shutdown parity logging:
			 * 1. Disable parity logging in all regions.
			 * 2. Reintegrate all regions.
			 */
			done = RF_TRUE;	/* Thread disabled, no work needed. */
			RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
			rf_ShutdownLogging(raidPtr);
		}
		if (!done) {
			/* Thread enabled, no work needed, so sleep. */
			if (rf_parityLogDebug)
				printf("[parity logging disk manager"
				    " sleeping]\n");
			RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond,
			    raidPtr->parityLogDiskQueue.mutex);
			if (rf_parityLogDebug)
				printf("[parity logging disk manager just"
				    " woke up]\n");
			flushQueue = raidPtr->parityLogDiskQueue.flushQueue;
			raidPtr->parityLogDiskQueue.flushQueue = NULL;
			reintQueue = raidPtr->parityLogDiskQueue.reintQueue;
			raidPtr->parityLogDiskQueue.reintQueue = NULL;
			workNeeded = (flushQueue || reintQueue);
		}
	}
	/*
	 * Announce that we're done.
	 */
	RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	raidPtr->parityLogDiskQueue.threadState |= RF_PLOG_SHUTDOWN;
	RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	RF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);

	splx(s);

	/*
	 * In the Net- & OpenBSD kernel, the thread must exit; returning would
	 * cause the proc trampoline to attempt to return to userspace.
	 */
	kthread_exit(0);	/* does not return */
}
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.7
log
@remove stupid casts, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_paritylogDiskMgr.c,v 1.6 2002/12/16 07:01:04 tdeval Exp $	*/
@


1.6
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_paritylogDiskMgr.c,v 1.5 2000/08/08 16:07:43 peter Exp $	*/
d157 1
a157 1
	bzero((char *) tracerec, sizeof(RF_AccTraceEntry_t));
d206 1
a206 1
	bzero((char *) tracerec, sizeof(RF_AccTraceEntry_t));
d258 1
a258 1
	bzero((char *) tracerec, sizeof(RF_AccTraceEntry_t));
d304 1
a304 1
	bzero((char *) tracerec, sizeof(RF_AccTraceEntry_t));
@


1.5
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_paritylogDiskMgr.c,v 1.4 2000/01/11 18:02:22 peter Exp $	*/
d3 1
d30 2
a31 2
/* Code for flushing and reintegration operations related to parity logging.
 *
d36 1
a36 1
#if RF_INCLUDE_PARITYLOGGING > 0
d58 14
a71 1
static caddr_t AcquireReintBuffer(RF_RegionBufferQueue_t *);
d73 2
a74 3
static caddr_t 
AcquireReintBuffer(pool)
	RF_RegionBufferQueue_t *pool;
d78 4
a81 2
	/* Return a region buffer from the free list (pool). If the free list
	 * is empty, WAIT. BLOCKING */
d92 4
a95 2
		RF_PANIC();	/* should never happen in correct config,
				 * single reint */
d101 3
a103 4
static void 
ReleaseReintBuffer(
    RF_RegionBufferQueue_t * pool,
    caddr_t bufPtr)
d105 4
a108 2
	/* Insert a region buffer (bufPtr) into the free list (pool).
	 * NON-BLOCKING */
d122 4
a125 10

static void 
ReadRegionLog(
    RF_RegionId_t regionID,
    RF_MCPair_t * rrd_mcpair,
    caddr_t regionBuffer,
    RF_Raid_t * raidPtr,
    RF_DagHeader_t ** rrd_dag_h,
    RF_AllocListElem_t ** rrd_alloclist,
    RF_PhysDiskAddr_t ** rrd_pda)
d127 2
a128 1
	/* Initiate the read a region log from disk.  Once initiated, return
d130 3
a132 2
	 * 
	 * NON-BLOCKING */
d137 1
a137 1
	/* create DAG to read region log from disk */
d139 7
a145 9
	*rrd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, regionBuffer, 
				      rf_DiskReadFunc, rf_DiskReadUndoFunc,
				      "Rrl", *rrd_alloclist, 
				      RF_DAG_FLAGS_NONE, 
				      RF_IO_NORMAL_PRIORITY);

	/* create and initialize PDA for the core log */
	/* RF_Malloc(*rrd_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t
	 * *)); */
d147 2
a148 2
	rf_MapLogParityLogging(raidPtr, regionID, 0, &((*rrd_pda)->row), 
			       &((*rrd_pda)->col), &((*rrd_pda)->startSector));
d155 2
a156 2
	/* initialize DAG parameters */
	RF_Malloc(tracerec,sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d161 1
a161 1
/*  rrd_rdNode->params[1] = regionBuffer; */
d163 1
a163 1
	rrd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 
d166 1
a166 1
	/* launch region log read dag */
d172 4
a175 9

static void 
WriteCoreLog(
    RF_ParityLog_t * log,
    RF_MCPair_t * fwr_mcpair,
    RF_Raid_t * raidPtr,
    RF_DagHeader_t ** fwr_dag_h,
    RF_AllocListElem_t ** fwr_alloclist,
    RF_PhysDiskAddr_t ** fwr_pda)
d182 2
a183 1
	/* Initiate the write of a core log to a region log disk. Once
d185 3
a187 2
	 * 
	 * NON-BLOCKING */
d189 1
a189 1
	/* create DAG to write a core log to a region log disk */
d191 7
a197 7
	*fwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, log->bufPtr, 
				      rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
	    "Wcl", *fwr_alloclist, RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

	/* create and initialize PDA for the region log */
	/* RF_Malloc(*fwr_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t
	 * *)); */
d200 2
a201 3
	rf_MapLogParityLogging(raidPtr, regionID, regionOffset, 
			       &((*fwr_pda)->row), &((*fwr_pda)->col), 
			       &((*fwr_pda)->startSector));
d204 2
a205 2
	/* initialize DAG parameters */
	RF_Malloc(tracerec,sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d210 1
a210 1
/*  fwr_wrNode->params[1] = log->bufPtr; */
d212 2
a213 2
	fwr_wrNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 
						   0, 0, 0);
d215 1
a215 1
	/* launch the dag to write the core log to disk */
d221 4
a224 9
static void 
ReadRegionParity(
    RF_RegionId_t regionID,
    RF_MCPair_t * prd_mcpair,
    caddr_t parityBuffer,
    RF_Raid_t * raidPtr,
    RF_DagHeader_t ** prd_dag_h,
    RF_AllocListElem_t ** prd_alloclist,
    RF_PhysDiskAddr_t ** prd_pda)
d226 2
a227 1
	/* Initiate the read region parity from disk. Once initiated, return
d229 3
a231 2
	 * 
	 * NON-BLOCKING */
d236 1
a236 1
	/* create DAG to read region parity from disk */
d238 7
a244 8
	*prd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, NULL, rf_DiskReadFunc, 
				      rf_DiskReadUndoFunc, "Rrp", 
				      *prd_alloclist, RF_DAG_FLAGS_NONE, 
				      RF_IO_NORMAL_PRIORITY);

	/* create and initialize PDA for region parity */
	/* RF_Malloc(*prd_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t
	 * *)); */
d246 3
a248 3
	rf_MapRegionParity(raidPtr, regionID, &((*prd_pda)->row), 
			   &((*prd_pda)->col), &((*prd_pda)->startSector), 
			   &((*prd_pda)->numSector));
d256 2
a257 2
	/* initialize DAG parameters */
	RF_Malloc(tracerec,sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d264 2
a265 2
	prd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 
						   0, 0, 0);
d268 1
a268 1
	/* launch region parity read dag */
d273 4
a276 9
static void 
WriteRegionParity(
    RF_RegionId_t regionID,
    RF_MCPair_t * pwr_mcpair,
    caddr_t parityBuffer,
    RF_Raid_t * raidPtr,
    RF_DagHeader_t ** pwr_dag_h,
    RF_AllocListElem_t ** pwr_alloclist,
    RF_PhysDiskAddr_t ** pwr_pda)
d278 2
a279 1
	/* Initiate the write of region parity to disk. Once initiated, return
d281 3
a283 2
	 * 
	 * NON-BLOCKING */
d288 1
a288 1
	/* create DAG to write region log from disk */
d290 7
a296 9
	*pwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, parityBuffer, 
				      rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
				      "Wrp", *pwr_alloclist, 
				      RF_DAG_FLAGS_NONE, 
				      RF_IO_NORMAL_PRIORITY);

	/* create and initialize PDA for region parity */
	/* RF_Malloc(*pwr_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t
	 * *)); */
d298 3
a300 3
	rf_MapRegionParity(raidPtr, regionID, &((*pwr_pda)->row), 
			   &((*pwr_pda)->col), &((*pwr_pda)->startSector), 
			   &((*pwr_pda)->numSector));
d302 2
a303 2
	/* initialize DAG parameters */
	RF_Malloc(tracerec,sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d308 1
a308 1
/*  pwr_wrNode->params[1] = parityBuffer; */
d310 2
a311 2
	pwr_wrNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 
						   0, 0, 0);
d313 1
a313 1
	/* launch the dag to write region parity to disk */
d318 2
a319 4
static void 
FlushLogsToDisk(
    RF_Raid_t * raidPtr,
    RF_ParityLog_t * logList)
d321 3
a323 2
	/* Flush a linked list of core logs to the log disk. Logs contain the
	 * disk location where they should be written.  Logs were written in
d325 7
a331 5
	 * 
	 * Recommended optimizations: 1) allow multiple flushes to occur
	 * simultaneously 2) coalesce contiguous flush operations
	 * 
	 * BLOCKING */
d348 1
a348 1
		/* create and launch a DAG to write the core log */
d350 2
a351 1
			printf("[initiating write of core log for region %d]\n", regionID);
d353 2
a354 2
		WriteCoreLog(log, fwr_mcpair, raidPtr, &fwr_dag_h, 
			     &fwr_alloclist, &fwr_pda);
d356 1
a356 1
		/* wait for the DAG to complete */
d360 2
a361 1
			RF_ERRORMSG1("Unable to write core log to disk (region %d)\n", regionID);
d376 3
a378 5
static void 
ReintegrateRegion(
    RF_Raid_t * raidPtr,
    RF_RegionId_t regionID,
    RF_ParityLog_t * coreLog)
d386 9
a394 1
	/* Reintegrate a region (regionID). 
d396 2
a397 8
	 * 1. acquire region and parity buffers 
	 * 2. read log from disk 
	 * 3. read parity from disk 
	 * 4. apply log to parity 
	 * 5. apply core log to parity 
	 * 6. write new parity to disk
	 * 
	 * BLOCKING */
d402 1
a402 1
	/* initiate read of region parity */
d404 2
a405 2
		printf("[initiating read of parity for region %d]\n",regionID);
	parityBuffer = AcquireReintBuffer(&raidPtr->parityBufferPool);
d409 1
a409 1
	ReadRegionParity(regionID, prd_mcpair, parityBuffer, raidPtr, 
d412 1
a412 1
	/* if region log nonempty, initiate read */
d416 3
a418 2
			       regionID);
		regionBuffer = AcquireReintBuffer(&raidPtr->regionBufferPool);
d422 2
a423 2
		ReadRegionLog(regionID, rrd_mcpair, regionBuffer, raidPtr, 
			      &rrd_dag_h, &rrd_alloclist, &rrd_pda);
d425 1
a425 1
	/* wait on read of region parity to complete */
d432 1
a432 1
		/* add code to fail the parity disk */
d435 1
a435 1
	/* apply core log to parity */
d439 1
a439 1
		/* wait on read of region log to complete */
d445 1
a445 1
			/* add code to fail the log disk */
d448 1
a448 1
		/* apply region log to parity */
d450 1
a450 1
		/* release resources associated with region log */
d456 1
a456 1
		ReleaseReintBuffer(&raidPtr->regionBufferPool, regionBuffer);
d458 1
a458 1
	/* write reintegrated parity to disk */
d461 1
a461 1
		       regionID);
d465 2
a466 2
	WriteRegionParity(regionID, pwr_mcpair, parityBuffer, raidPtr, 
			  &pwr_dag_h, &pwr_alloclist, &pwr_pda);
d472 1
a472 1
		/* add code to fail the parity disk */
d475 1
a475 1
	/* release resources associated with read of old parity */
d482 2
a483 2
	/* release resources associated with write of new parity */
	ReleaseReintBuffer(&raidPtr->parityBufferPool, parityBuffer);
d495 2
a496 5

static void 
ReintegrateLogs(
    RF_Raid_t * raidPtr,
    RF_ParityLog_t * logList)
d508 1
a508 1
		ReintegrateRegion(raidPtr, regionID, log);
d511 4
a514 2
		/* remove all items which are blocked on reintegration of this
		 * region */
d516 3
a518 4
		logData = rf_SearchAndDequeueParityLogData(raidPtr, regionID, 
			   &raidPtr->parityLogDiskQueue.reintBlockHead, 
			   &raidPtr->parityLogDiskQueue.reintBlockTail, 
							   RF_TRUE);
d521 5
a525 5
			logData->next = rf_SearchAndDequeueParityLogData(
					 raidPtr, regionID, 
					 &raidPtr->parityLogDiskQueue.reintBlockHead, 
					 &raidPtr->parityLogDiskQueue.reintBlockTail, 
					 RF_TRUE);
d530 4
a533 2
		/* process blocked log data and clear reintInProgress flag for
		 * this region */
d537 2
a538 1
			/* Enable flushing for this region.  Holding both
d540 2
a541 1
			 * DumpParityLogToDisk */
d546 2
a547 1
			raidPtr->regionInfo[regionID].reintInProgress = RF_FALSE;
d549 2
a550 2
			RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);	/* flushing is now
											 * enabled */
d553 4
a556 2
		/* if log wasn't used, attach it to the list of logs to be
		 * returned */
d566 2
a567 2
int 
rf_ShutdownLogging(RF_Raid_t * raidPtr)
d569 5
a573 2
	/* shutdown parity logging 1) disable parity logging in all regions 2)
	 * reintegrate all regions */
d581 4
a584 2
	/* Since parity log maps are volatile, we must reintegrate all
	 * regions. */
d588 1
a588 2
			raidPtr->regionInfo[regionID].loggingEnabled = 
				RF_FALSE;
d594 1
a594 1
				ReintegrateRegion(raidPtr, regionID, log);
d601 1
a601 1
		printf("[should be done!]\n");
d606 2
a607 2
int 
rf_ParityLoggingDiskManager(RF_Raid_t * raidPtr)
d610 1
a610 1
	int     workNeeded, done = RF_FALSE;
d613 2
a614 1
	/* Main program for parity logging disk thread.  This routine waits
d618 3
a620 2
	 * 
	 * BLOCKING */
d627 4
a630 4
         * Inform our creator that we're running. Don't bother doing the
         * mutex lock/unlock dance- we locked above, and we'll unlock
         * below with nothing to do, yet.
         */
d634 1
a634 1
	/* empty the work queues */
d643 3
a645 2
			/* First, flush all logs in the flush queue, freeing
			 * buffers Second, reintegrate all regions which are
d648 4
a651 4
			 * 
			 * Note: Incoming appends (ParityLogAppend) can block on
			 * either 1. empty buffer pool 2. region under
			 * reintegration To preserve a global FIFO ordering of
d654 4
a657 3
			 * from the append queue.  Similarly, regions which
			 * are reintegrated are not opened for general use
			 * until the append queue has been emptied. */
d661 4
a664 2
			/* empty flushQueue, using free'd log buffers to
			 * process bufTail */
d666 1
a666 1
			       FlushLogsToDisk(raidPtr, flushQueue);
d668 3
a670 1
			/* empty reintQueue, flushing from reintTail as we go */
d672 1
a672 1
				ReintegrateLogs(raidPtr, reintQueue);
d681 1
a681 1
		/* no work is needed at this point */
d683 6
a688 3
			/* shutdown parity logging 1. disable parity logging
			 * in all regions 2. reintegrate all regions */
			done = RF_TRUE;	/* thread disabled, no work needed */
d693 1
a693 1
			/* thread enabled, no work needed, so sleep */
d695 4
a698 3
				printf("[parity logging disk manager sleeping]\n");
			RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, 
				     raidPtr->parityLogDiskQueue.mutex);
d700 2
a701 1
				printf("[parity logging disk manager just woke up]\n");
d710 2
a711 2
         * Announce that we're done.
         */
d720 3
a722 3
         * In the Net- & OpenBSD kernel, the thread must exit; returning would
         * cause the proc trampoline to attempt to return to userspace.
         */
d725 1
a725 1
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.5.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d29 2
a30 2
/*
 * Code for flushing and reintegrating operations related to parity logging.
d35 1
a35 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d57 1
a57 14
caddr_t rf_AcquireReintBuffer(RF_RegionBufferQueue_t *);
void rf_ReleaseReintBuffer(RF_RegionBufferQueue_t *, caddr_t);
void rf_ReadRegionLog(RF_RegionId_t, RF_MCPair_t *, caddr_t, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_WriteCoreLog(RF_ParityLog_t *, RF_MCPair_t *, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_ReadRegionParity(RF_RegionId_t, RF_MCPair_t *, caddr_t, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_WriteRegionParity(RF_RegionId_t, RF_MCPair_t *, caddr_t, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_FlushLogsToDisk(RF_Raid_t *, RF_ParityLog_t *);
void rf_ReintegrateRegion(RF_Raid_t *, RF_RegionId_t, RF_ParityLog_t *);
void rf_ReintegrateLogs(RF_Raid_t *, RF_ParityLog_t *);

d59 3
a61 2
caddr_t
rf_AcquireReintBuffer(RF_RegionBufferQueue_t *pool)
d65 2
a66 4
	/*
	 * Return a region buffer from the free list (pool). If the free list
	 * is empty, WAIT. BLOCKING
	 */
d77 2
a78 4
		RF_PANIC();	/*
				 * Should never happen in correct config,
				 * single reint.
				 */
d84 4
a87 3

void
rf_ReleaseReintBuffer(RF_RegionBufferQueue_t *pool, caddr_t bufPtr)
d89 2
a90 4
	/*
	 * Insert a region buffer (bufPtr) into the free list (pool).
	 * NON-BLOCKING
	 */
d104 10
a113 4
void
rf_ReadRegionLog(RF_RegionId_t regionID, RF_MCPair_t *rrd_mcpair,
    caddr_t regionBuffer, RF_Raid_t *raidPtr, RF_DagHeader_t **rrd_dag_h,
    RF_AllocListElem_t **rrd_alloclist, RF_PhysDiskAddr_t **rrd_pda)
d115 1
a115 2
	/*
	 * Initiate the read a region log from disk. Once initiated, return
d117 2
a118 3
	 *
	 * NON-BLOCKING
	 */
d123 1
a123 1
	/* Create DAG to read region log from disk. */
d125 9
a133 7
	*rrd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, regionBuffer,
	    rf_DiskReadFunc, rf_DiskReadUndoFunc, "Rrl", *rrd_alloclist,
	    RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for the core log. */
	/* RF_Malloc(*rrd_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
d135 2
a136 2
	rf_MapLogParityLogging(raidPtr, regionID, 0, &((*rrd_pda)->row),
	    &((*rrd_pda)->col), &((*rrd_pda)->startSector));
d143 2
a144 2
	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d149 1
a149 1
	/* rrd_rdNode->params[1] = regionBuffer; */
d151 1
a151 1
	rrd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
d154 1
a154 1
	/* Launch region log read dag. */
d160 9
a168 4
void
rf_WriteCoreLog(RF_ParityLog_t *log, RF_MCPair_t *fwr_mcpair,
    RF_Raid_t *raidPtr, RF_DagHeader_t **fwr_dag_h,
    RF_AllocListElem_t **fwr_alloclist, RF_PhysDiskAddr_t **fwr_pda)
d175 1
a175 2
	/*
	 * Initiate the write of a core log to a region log disk. Once
d177 2
a178 3
	 *
	 * NON-BLOCKING
	 */
d180 1
a180 1
	/* Create DAG to write a core log to a region log disk. */
d182 7
a188 7
	*fwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, log->bufPtr,
	    rf_DiskWriteFunc, rf_DiskWriteUndoFunc, "Wcl", *fwr_alloclist,
	    RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for the region log. */
	/* RF_Malloc(*fwr_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
d191 3
a193 2
	rf_MapLogParityLogging(raidPtr, regionID, regionOffset,
	    &((*fwr_pda)->row), &((*fwr_pda)->col), &((*fwr_pda)->startSector));
d196 2
a197 2
	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d202 1
a202 1
	/* fwr_wrNode->params[1] = log->bufPtr; */
d204 2
a205 2
	fwr_wrNode->params[3].v =
	    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d207 1
a207 1
	/* Launch the dag to write the core log to disk. */
d213 9
a221 4
void
rf_ReadRegionParity(RF_RegionId_t regionID, RF_MCPair_t *prd_mcpair,
    caddr_t parityBuffer, RF_Raid_t *raidPtr, RF_DagHeader_t **prd_dag_h,
    RF_AllocListElem_t **prd_alloclist, RF_PhysDiskAddr_t **prd_pda)
d223 1
a223 2
	/*
	 * Initiate the read region parity from disk. Once initiated, return
d225 2
a226 3
	 *
	 * NON-BLOCKING
	 */
d231 1
a231 1
	/* Create DAG to read region parity from disk. */
d233 8
a240 7
	*prd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, NULL, rf_DiskReadFunc,
	    rf_DiskReadUndoFunc, "Rrp", *prd_alloclist, RF_DAG_FLAGS_NONE,
	    RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for region parity. */
	/* RF_Malloc(*prd_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
d242 3
a244 3
	rf_MapRegionParity(raidPtr, regionID, &((*prd_pda)->row),
	    &((*prd_pda)->col), &((*prd_pda)->startSector),
	    &((*prd_pda)->numSector));
d252 2
a253 2
	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d260 2
a261 2
	prd_rdNode->params[3].v =
	    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d264 1
a264 1
	/* Launch region parity read dag. */
d269 9
a277 4
void
rf_WriteRegionParity(RF_RegionId_t regionID, RF_MCPair_t *pwr_mcpair,
    caddr_t parityBuffer, RF_Raid_t *raidPtr, RF_DagHeader_t **pwr_dag_h,
    RF_AllocListElem_t **pwr_alloclist, RF_PhysDiskAddr_t **pwr_pda)
d279 1
a279 2
	/*
	 * Initiate the write of region parity to disk. Once initiated, return
d281 2
a282 3
	 *
	 * NON-BLOCKING
	 */
d287 1
a287 1
	/* Create DAG to write region log from disk. */
d289 9
a297 7
	*pwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, parityBuffer,
	    rf_DiskWriteFunc, rf_DiskWriteUndoFunc, "Wrp", *pwr_alloclist,
	    RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for region parity. */
	/* RF_Malloc(*pwr_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
d299 3
a301 3
	rf_MapRegionParity(raidPtr, regionID, &((*pwr_pda)->row),
	    &((*pwr_pda)->col), &((*pwr_pda)->startSector),
	    &((*pwr_pda)->numSector));
d303 2
a304 2
	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d309 1
a309 1
	/* pwr_wrNode->params[1] = parityBuffer; */
d311 2
a312 2
	pwr_wrNode->params[3].v =
	    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d314 1
a314 1
	/* Launch the dag to write region parity to disk. */
d319 4
a322 2
void
rf_FlushLogsToDisk(RF_Raid_t *raidPtr, RF_ParityLog_t *logList)
d324 2
a325 3
	/*
	 * Flush a linked list of core logs to the log disk. Logs contain the
	 * disk location where they should be written. Logs were written in
d327 5
a331 7
	 *
	 * Recommended optimizations:
	 * 1) Allow multiple flushes to occur simultaneously.
	 * 2) Coalesce contiguous flush operations.
	 *
	 * BLOCKING
	 */
d348 1
a348 1
		/* Create and launch a DAG to write the core log. */
d350 1
a350 2
			printf("[initiating write of core log for region"
			    " %d]\n", regionID);
d352 2
a353 2
		rf_WriteCoreLog(log, fwr_mcpair, raidPtr, &fwr_dag_h,
		    &fwr_alloclist, &fwr_pda);
d355 1
a355 1
		/* Wait for the DAG to complete. */
d359 1
a359 2
			RF_ERRORMSG1("Unable to write core log to disk"
			    " (region %d)\n", regionID);
d374 5
a378 3
void
rf_ReintegrateRegion(RF_Raid_t *raidPtr, RF_RegionId_t regionID,
    RF_ParityLog_t *coreLog)
d386 1
a386 9
	/*
	 * Reintegrate a region (regionID).
	 *
	 * 1. Acquire region and parity buffers.
	 * 2. Read log from disk.
	 * 3. Read parity from disk.
	 * 4. Apply log to parity.
	 * 5. Apply core log to parity.
	 * 6. Write new parity to disk.
d388 8
a395 2
	 * BLOCKING
	 */
d400 1
a400 1
	/* Initiate read of region parity. */
d402 2
a403 2
		printf("[initiating read of parity for region %d]\n", regionID);
	parityBuffer = rf_AcquireReintBuffer(&raidPtr->parityBufferPool);
d407 1
a407 1
	rf_ReadRegionParity(regionID, prd_mcpair, parityBuffer, raidPtr,
d410 1
a410 1
	/* If region log nonempty, initiate read. */
d414 2
a415 3
			    regionID);
		regionBuffer =
		    rf_AcquireReintBuffer(&raidPtr->regionBufferPool);
d419 2
a420 2
		rf_ReadRegionLog(regionID, rrd_mcpair, regionBuffer, raidPtr,
		    &rrd_dag_h, &rrd_alloclist, &rrd_pda);
d422 1
a422 1
	/* Wait on read of region parity to complete. */
d429 1
a429 1
		/* Add code to fail the parity disk. */
d432 1
a432 1
	/* Apply core log to parity. */
d436 1
a436 1
		/* Wait on read of region log to complete. */
d442 1
a442 1
			/* Add code to fail the log disk. */
d445 1
a445 1
		/* Apply region log to parity. */
d447 1
a447 1
		/* Release resources associated with region log. */
d453 1
a453 1
		rf_ReleaseReintBuffer(&raidPtr->regionBufferPool, regionBuffer);
d455 1
a455 1
	/* Write reintegrated parity to disk. */
d458 1
a458 1
		    regionID);
d462 2
a463 2
	rf_WriteRegionParity(regionID, pwr_mcpair, parityBuffer, raidPtr,
	    &pwr_dag_h, &pwr_alloclist, &pwr_pda);
d469 1
a469 1
		/* Add code to fail the parity disk. */
d472 1
a472 1
	/* Release resources associated with read of old parity. */
d479 2
a480 2
	/* Release resources associated with write of new parity. */
	rf_ReleaseReintBuffer(&raidPtr->parityBufferPool, parityBuffer);
d492 5
a496 2
void
rf_ReintegrateLogs(RF_Raid_t *raidPtr, RF_ParityLog_t *logList)
d508 1
a508 1
		rf_ReintegrateRegion(raidPtr, regionID, log);
d511 2
a512 4
		/*
		 * Remove all items which are blocked on reintegration of this
		 * region.
		 */
d514 4
a517 3
		logData = rf_SearchAndDequeueParityLogData(raidPtr, regionID,
		    &raidPtr->parityLogDiskQueue.reintBlockHead,
		    &raidPtr->parityLogDiskQueue.reintBlockTail, RF_TRUE);
d520 5
a524 5
			logData->next =
			    rf_SearchAndDequeueParityLogData(raidPtr, regionID,
			     &raidPtr->parityLogDiskQueue.reintBlockHead,
			     &raidPtr->parityLogDiskQueue.reintBlockTail,
			     RF_TRUE);
d529 2
a530 4
		/*
		 * Process blocked log data and clear reintInProgress flag for
		 * this region.
		 */
d534 1
a534 2
			/*
			 * Enable flushing for this region. Holding both
d536 1
a536 2
			 * DumpParityLogToDisk.
			 */
d541 1
a541 2
			raidPtr->regionInfo[regionID].reintInProgress =
			    RF_FALSE;
d543 2
a544 2
			RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID]
			    .reintMutex);	/* Flushing is now enabled. */
d547 2
a548 4
		/*
		 * If log wasn't used, attach it to the list of logs to be
		 * returned.
		 */
d558 2
a559 2
int
rf_ShutdownLogging(RF_Raid_t *raidPtr)
d561 2
a562 5
	/*
	 * Shutdown parity logging:
	 * 1) Disable parity logging in all regions.
	 * 2) Reintegrate all regions.
	 */
d570 2
a571 4
	/*
	 * Since parity log maps are volatile, we must reintegrate all
	 * regions.
	 */
d575 2
a576 1
			raidPtr->regionInfo[regionID].loggingEnabled = RF_FALSE;
d582 1
a582 1
				rf_ReintegrateRegion(raidPtr, regionID, log);
d589 1
a589 1
		printf("[should be done !]\n");
d594 2
a595 2
int
rf_ParityLoggingDiskManager(RF_Raid_t *raidPtr)
d598 1
a598 1
	int workNeeded, done = RF_FALSE;
d601 1
a601 2
	/*
	 * Main program for parity logging disk thread. This routine waits
d605 2
a606 3
	 *
	 * BLOCKING
	 */
d613 4
a616 4
	 * Inform our creator that we're running. Don't bother doing the
	 * mutex lock/unlock dance: we locked above, and we'll unlock
	 * below with nothing to do, yet.
	 */
d620 1
a620 1
	/* Empty the work queues. */
d629 2
a630 3
			/*
			 * First, flush all logs in the flush queue, freeing
			 * buffers. Second, reintegrate all regions that are
d633 4
a636 4
			 *
			 * Note: Incoming appends (ParityLogAppend) can block
			 * on either 1. empty buffer pool 2. region under
			 * reintegration. To preserve a global FIFO ordering of
d639 3
a641 4
			 * from the append queue. Similarly, regions that are
			 * reintegrated are not opened for general use until
			 * the append queue has been emptied.
			 */
d645 2
a646 4
			/*
			 * Empty flushQueue, using free'd log buffers to
			 * process bufTail.
			 */
d648 1
a648 1
				rf_FlushLogsToDisk(raidPtr, flushQueue);
d650 1
a650 3
			/*
			 * Empty reintQueue, flushing from reintTail as we go.
			 */
d652 1
a652 1
				rf_ReintegrateLogs(raidPtr, reintQueue);
d661 1
a661 1
		/* No work is needed at this point. */
d663 3
a665 6
			/*
			 * Shutdown parity logging:
			 * 1. Disable parity logging in all regions.
			 * 2. Reintegrate all regions.
			 */
			done = RF_TRUE;	/* Thread disabled, no work needed. */
d670 1
a670 1
			/* Thread enabled, no work needed, so sleep. */
d672 3
a674 4
				printf("[parity logging disk manager"
				    " sleeping]\n");
			RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond,
			    raidPtr->parityLogDiskQueue.mutex);
d676 1
a676 2
				printf("[parity logging disk manager just"
				    " woke up]\n");
d685 2
a686 2
	 * Announce that we're done.
	 */
d695 3
a697 3
	 * In the Net- & OpenBSD kernel, the thread must exit; returning would
	 * cause the proc trampoline to attempt to return to userspace.
	 */
d700 1
a700 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.4
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylogDiskMgr.c,v 1.3 2000/01/07 14:50:22 peter Exp $	*/
/*	$NetBSD: rf_paritylogDiskMgr.c,v 1.7 2000/01/08 01:18:36 oster Exp $	*/
d77 1
a77 1
		RF_PANIC();	/* should never happen in currect config,
d120 1
a120 1
	RF_AccTraceEntry_t tracerec;
d125 5
a129 2
	*rrd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, regionBuffer, rf_DiskReadFunc, rf_DiskReadUndoFunc,
	    "Rrl", *rrd_alloclist, RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);
d135 2
a136 1
	rf_MapLogParityLogging(raidPtr, regionID, 0, &((*rrd_pda)->row), &((*rrd_pda)->col), &((*rrd_pda)->startSector));
d144 3
a146 2
	bzero((char *) &tracerec, sizeof(tracerec));
	(*rrd_dag_h)->tracerec = &tracerec;
d151 2
a152 1
	rrd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d171 1
a171 1
	RF_AccTraceEntry_t tracerec;
d182 2
a183 1
	*fwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, log->bufPtr, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
d191 3
a193 1
	rf_MapLogParityLogging(raidPtr, regionID, regionOffset, &((*fwr_pda)->row), &((*fwr_pda)->col), &((*fwr_pda)->startSector));
d197 3
a199 2
	bzero((char *) &tracerec, sizeof(tracerec));
	(*fwr_dag_h)->tracerec = &tracerec;
d204 2
a205 1
	fwr_wrNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d228 1
a228 1
	RF_AccTraceEntry_t tracerec;
d233 4
a236 2
	*prd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, NULL, rf_DiskReadFunc, rf_DiskReadUndoFunc,
	    "Rrp", *prd_alloclist, RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);
d242 3
a244 1
	rf_MapRegionParity(raidPtr, regionID, &((*prd_pda)->row), &((*prd_pda)->col), &((*prd_pda)->startSector), &((*prd_pda)->numSector));
d253 3
a255 2
	bzero((char *) &tracerec, sizeof(tracerec));
	(*prd_dag_h)->tracerec = &tracerec;
d260 2
a261 1
	prd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d284 1
a284 1
	RF_AccTraceEntry_t tracerec;
d289 5
a293 2
	*pwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, parityBuffer, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
	    "Wrp", *pwr_alloclist, RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);
d299 3
a301 1
	rf_MapRegionParity(raidPtr, regionID, &((*pwr_pda)->row), &((*pwr_pda)->col), &((*pwr_pda)->startSector), &((*pwr_pda)->numSector));
d304 3
a306 2
	bzero((char *) &tracerec, sizeof(tracerec));
	(*pwr_dag_h)->tracerec = &tracerec;
d311 2
a312 1
	pwr_wrNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d352 2
a353 1
		WriteCoreLog(log, fwr_mcpair, raidPtr, &fwr_dag_h, &fwr_alloclist, &fwr_pda);
d386 8
a393 3
	/* Reintegrate a region (regionID). 1. acquire region and parity
	 * buffers 2. read log from disk 3. read parity from disk 4. apply log
	 * to parity 5. apply core log to parity 6. write new parity to disk
d402 1
a402 1
		printf("[initiating read of parity for region %d]\n", regionID);
d407 2
a408 1
	ReadRegionParity(regionID, prd_mcpair, parityBuffer, raidPtr, &prd_dag_h, &prd_alloclist, &prd_pda);
d413 2
a414 1
			printf("[initiating read of disk log for region %d]\n", regionID);
d419 2
a420 1
		ReadRegionLog(regionID, rrd_mcpair, regionBuffer, raidPtr, &rrd_dag_h, &rrd_alloclist, &rrd_pda);
d457 2
a458 1
		printf("[initiating write of parity for region %d]\n", regionID);
d462 2
a463 1
	WriteRegionParity(regionID, pwr_mcpair, parityBuffer, raidPtr, &pwr_dag_h, &pwr_alloclist, &pwr_pda);
d514 4
a517 1
		logData = rf_SearchAndDequeueParityLogData(raidPtr, regionID, &raidPtr->parityLogDiskQueue.reintBlockHead, &raidPtr->parityLogDiskQueue.reintBlockTail, RF_TRUE);
d520 5
a524 1
			logData->next = rf_SearchAndDequeueParityLogData(raidPtr, regionID, &raidPtr->parityLogDiskQueue.reintBlockHead, &raidPtr->parityLogDiskQueue.reintBlockTail, RF_TRUE);
d575 2
a576 1
			raidPtr->regionInfo[regionID].loggingEnabled = RF_FALSE;
d599 1
d608 2
d648 1
a648 1
				FlushLogsToDisk(raidPtr, flushQueue);
d673 2
a674 1
			RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, raidPtr->parityLogDiskQueue.mutex);
d691 2
@


1.4.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylogDiskMgr.c,v 1.5 2000/08/08 16:07:43 peter Exp $	*/
/*	$NetBSD: rf_paritylogDiskMgr.c,v 1.10 2000/01/15 01:57:57 oster Exp $	*/
d77 1
a77 1
		RF_PANIC();	/* should never happen in correct config,
d120 1
a120 1
	RF_AccTraceEntry_t *tracerec;
d125 2
a126 5
	*rrd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, regionBuffer, 
				      rf_DiskReadFunc, rf_DiskReadUndoFunc,
				      "Rrl", *rrd_alloclist, 
				      RF_DAG_FLAGS_NONE, 
				      RF_IO_NORMAL_PRIORITY);
d132 1
a132 2
	rf_MapLogParityLogging(raidPtr, regionID, 0, &((*rrd_pda)->row), 
			       &((*rrd_pda)->col), &((*rrd_pda)->startSector));
d140 2
a141 3
	RF_Malloc(tracerec,sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
	bzero((char *) tracerec, sizeof(RF_AccTraceEntry_t));
	(*rrd_dag_h)->tracerec = tracerec;
d146 1
a146 2
	rrd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 
						   0, 0, 0);
d165 1
a165 1
	RF_AccTraceEntry_t *tracerec;
d176 1
a176 2
	*fwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, log->bufPtr, 
				      rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
d184 1
a184 3
	rf_MapLogParityLogging(raidPtr, regionID, regionOffset, 
			       &((*fwr_pda)->row), &((*fwr_pda)->col), 
			       &((*fwr_pda)->startSector));
d188 2
a189 3
	RF_Malloc(tracerec,sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
	bzero((char *) tracerec, sizeof(RF_AccTraceEntry_t));
	(*fwr_dag_h)->tracerec = tracerec;
d194 1
a194 2
	fwr_wrNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 
						   0, 0, 0);
d217 1
a217 1
	RF_AccTraceEntry_t *tracerec;
d222 2
a223 4
	*prd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, NULL, rf_DiskReadFunc, 
				      rf_DiskReadUndoFunc, "Rrp", 
				      *prd_alloclist, RF_DAG_FLAGS_NONE, 
				      RF_IO_NORMAL_PRIORITY);
d229 1
a229 3
	rf_MapRegionParity(raidPtr, regionID, &((*prd_pda)->row), 
			   &((*prd_pda)->col), &((*prd_pda)->startSector), 
			   &((*prd_pda)->numSector));
d238 2
a239 3
	RF_Malloc(tracerec,sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
	bzero((char *) tracerec, sizeof(RF_AccTraceEntry_t));
	(*prd_dag_h)->tracerec = tracerec;
d244 1
a244 2
	prd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 
						   0, 0, 0);
d267 1
a267 1
	RF_AccTraceEntry_t *tracerec;
d272 2
a273 5
	*pwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, parityBuffer, 
				      rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
				      "Wrp", *pwr_alloclist, 
				      RF_DAG_FLAGS_NONE, 
				      RF_IO_NORMAL_PRIORITY);
d279 1
a279 3
	rf_MapRegionParity(raidPtr, regionID, &((*pwr_pda)->row), 
			   &((*pwr_pda)->col), &((*pwr_pda)->startSector), 
			   &((*pwr_pda)->numSector));
d282 2
a283 3
	RF_Malloc(tracerec,sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
	bzero((char *) tracerec, sizeof(RF_AccTraceEntry_t));
	(*pwr_dag_h)->tracerec = tracerec;
d288 1
a288 2
	pwr_wrNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 
						   0, 0, 0);
d328 1
a328 2
		WriteCoreLog(log, fwr_mcpair, raidPtr, &fwr_dag_h, 
			     &fwr_alloclist, &fwr_pda);
d361 3
a363 8
	/* Reintegrate a region (regionID). 
	 *
	 * 1. acquire region and parity buffers 
	 * 2. read log from disk 
	 * 3. read parity from disk 
	 * 4. apply log to parity 
	 * 5. apply core log to parity 
	 * 6. write new parity to disk
d372 1
a372 1
		printf("[initiating read of parity for region %d]\n",regionID);
d377 1
a377 2
	ReadRegionParity(regionID, prd_mcpair, parityBuffer, raidPtr, 
			 &prd_dag_h, &prd_alloclist, &prd_pda);
d382 1
a382 2
			printf("[initiating read of disk log for region %d]\n",
			       regionID);
d387 1
a387 2
		ReadRegionLog(regionID, rrd_mcpair, regionBuffer, raidPtr, 
			      &rrd_dag_h, &rrd_alloclist, &rrd_pda);
d424 1
a424 2
		printf("[initiating write of parity for region %d]\n",
		       regionID);
d428 1
a428 2
	WriteRegionParity(regionID, pwr_mcpair, parityBuffer, raidPtr, 
			  &pwr_dag_h, &pwr_alloclist, &pwr_pda);
d479 1
a479 4
		logData = rf_SearchAndDequeueParityLogData(raidPtr, regionID, 
			   &raidPtr->parityLogDiskQueue.reintBlockHead, 
			   &raidPtr->parityLogDiskQueue.reintBlockTail, 
							   RF_TRUE);
d482 1
a482 5
			logData->next = rf_SearchAndDequeueParityLogData(
					 raidPtr, regionID, 
					 &raidPtr->parityLogDiskQueue.reintBlockHead, 
					 &raidPtr->parityLogDiskQueue.reintBlockTail, 
					 RF_TRUE);
d533 1
a533 2
			raidPtr->regionInfo[regionID].loggingEnabled = 
				RF_FALSE;
a555 1
	int s;
a563 2
	s = splbio();

d602 1
a602 1
			       FlushLogsToDisk(raidPtr, flushQueue);
d627 1
a627 2
			RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, 
				     raidPtr->parityLogDiskQueue.mutex);
a643 2

	splx(s);
@


1.4.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d29 2
a30 2
/*
 * Code for flushing and reintegrating operations related to parity logging.
d35 1
a35 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d57 1
a57 14
caddr_t rf_AcquireReintBuffer(RF_RegionBufferQueue_t *);
void rf_ReleaseReintBuffer(RF_RegionBufferQueue_t *, caddr_t);
void rf_ReadRegionLog(RF_RegionId_t, RF_MCPair_t *, caddr_t, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_WriteCoreLog(RF_ParityLog_t *, RF_MCPair_t *, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_ReadRegionParity(RF_RegionId_t, RF_MCPair_t *, caddr_t, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_WriteRegionParity(RF_RegionId_t, RF_MCPair_t *, caddr_t, RF_Raid_t *,
	RF_DagHeader_t **, RF_AllocListElem_t **, RF_PhysDiskAddr_t **);
void rf_FlushLogsToDisk(RF_Raid_t *, RF_ParityLog_t *);
void rf_ReintegrateRegion(RF_Raid_t *, RF_RegionId_t, RF_ParityLog_t *);
void rf_ReintegrateLogs(RF_Raid_t *, RF_ParityLog_t *);

d59 3
a61 2
caddr_t
rf_AcquireReintBuffer(RF_RegionBufferQueue_t *pool)
d65 2
a66 4
	/*
	 * Return a region buffer from the free list (pool). If the free list
	 * is empty, WAIT. BLOCKING
	 */
d77 2
a78 4
		RF_PANIC();	/*
				 * Should never happen in correct config,
				 * single reint.
				 */
d84 4
a87 3

void
rf_ReleaseReintBuffer(RF_RegionBufferQueue_t *pool, caddr_t bufPtr)
d89 2
a90 4
	/*
	 * Insert a region buffer (bufPtr) into the free list (pool).
	 * NON-BLOCKING
	 */
d104 10
a113 4
void
rf_ReadRegionLog(RF_RegionId_t regionID, RF_MCPair_t *rrd_mcpair,
    caddr_t regionBuffer, RF_Raid_t *raidPtr, RF_DagHeader_t **rrd_dag_h,
    RF_AllocListElem_t **rrd_alloclist, RF_PhysDiskAddr_t **rrd_pda)
d115 1
a115 2
	/*
	 * Initiate the read a region log from disk. Once initiated, return
d117 2
a118 3
	 *
	 * NON-BLOCKING
	 */
d123 1
a123 1
	/* Create DAG to read region log from disk. */
d125 9
a133 7
	*rrd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, regionBuffer,
	    rf_DiskReadFunc, rf_DiskReadUndoFunc, "Rrl", *rrd_alloclist,
	    RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for the core log. */
	/* RF_Malloc(*rrd_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
d135 2
a136 2
	rf_MapLogParityLogging(raidPtr, regionID, 0, &((*rrd_pda)->row),
	    &((*rrd_pda)->col), &((*rrd_pda)->startSector));
d143 2
a144 2
	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d149 1
a149 1
	/* rrd_rdNode->params[1] = regionBuffer; */
d151 1
a151 1
	rrd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY,
d154 1
a154 1
	/* Launch region log read dag. */
d160 9
a168 4
void
rf_WriteCoreLog(RF_ParityLog_t *log, RF_MCPair_t *fwr_mcpair,
    RF_Raid_t *raidPtr, RF_DagHeader_t **fwr_dag_h,
    RF_AllocListElem_t **fwr_alloclist, RF_PhysDiskAddr_t **fwr_pda)
d175 1
a175 2
	/*
	 * Initiate the write of a core log to a region log disk. Once
d177 2
a178 3
	 *
	 * NON-BLOCKING
	 */
d180 1
a180 1
	/* Create DAG to write a core log to a region log disk. */
d182 7
a188 7
	*fwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, log->bufPtr,
	    rf_DiskWriteFunc, rf_DiskWriteUndoFunc, "Wcl", *fwr_alloclist,
	    RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for the region log. */
	/* RF_Malloc(*fwr_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
d191 3
a193 2
	rf_MapLogParityLogging(raidPtr, regionID, regionOffset,
	    &((*fwr_pda)->row), &((*fwr_pda)->col), &((*fwr_pda)->startSector));
d196 2
a197 2
	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d202 1
a202 1
	/* fwr_wrNode->params[1] = log->bufPtr; */
d204 2
a205 2
	fwr_wrNode->params[3].v =
	    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d207 1
a207 1
	/* Launch the dag to write the core log to disk. */
d213 9
a221 4
void
rf_ReadRegionParity(RF_RegionId_t regionID, RF_MCPair_t *prd_mcpair,
    caddr_t parityBuffer, RF_Raid_t *raidPtr, RF_DagHeader_t **prd_dag_h,
    RF_AllocListElem_t **prd_alloclist, RF_PhysDiskAddr_t **prd_pda)
d223 1
a223 2
	/*
	 * Initiate the read region parity from disk. Once initiated, return
d225 2
a226 3
	 *
	 * NON-BLOCKING
	 */
d231 1
a231 1
	/* Create DAG to read region parity from disk. */
d233 8
a240 7
	*prd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, NULL, rf_DiskReadFunc,
	    rf_DiskReadUndoFunc, "Rrp", *prd_alloclist, RF_DAG_FLAGS_NONE,
	    RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for region parity. */
	/* RF_Malloc(*prd_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
d242 3
a244 3
	rf_MapRegionParity(raidPtr, regionID, &((*prd_pda)->row),
	    &((*prd_pda)->col), &((*prd_pda)->startSector),
	    &((*prd_pda)->numSector));
d252 2
a253 2
	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d260 2
a261 2
	prd_rdNode->params[3].v =
	    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d264 1
a264 1
	/* Launch region parity read dag. */
d269 9
a277 4
void
rf_WriteRegionParity(RF_RegionId_t regionID, RF_MCPair_t *pwr_mcpair,
    caddr_t parityBuffer, RF_Raid_t *raidPtr, RF_DagHeader_t **pwr_dag_h,
    RF_AllocListElem_t **pwr_alloclist, RF_PhysDiskAddr_t **pwr_pda)
d279 1
a279 2
	/*
	 * Initiate the write of region parity to disk. Once initiated, return
d281 2
a282 3
	 *
	 * NON-BLOCKING
	 */
d287 1
a287 1
	/* Create DAG to write region log from disk. */
d289 9
a297 7
	*pwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, parityBuffer,
	    rf_DiskWriteFunc, rf_DiskWriteUndoFunc, "Wrp", *pwr_alloclist,
	    RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

	/* Create and initialize PDA for region parity. */
	/* RF_Malloc(*pwr_pda, sizeof(RF_PhysDiskAddr_t),
	 * (RF_PhysDiskAddr_t *)); */
d299 3
a301 3
	rf_MapRegionParity(raidPtr, regionID, &((*pwr_pda)->row),
	    &((*pwr_pda)->col), &((*pwr_pda)->startSector),
	    &((*pwr_pda)->numSector));
d303 2
a304 2
	/* Initialize DAG parameters. */
	RF_Malloc(tracerec, sizeof(RF_AccTraceEntry_t), (RF_AccTraceEntry_t *));
d309 1
a309 1
	/* pwr_wrNode->params[1] = parityBuffer; */
d311 2
a312 2
	pwr_wrNode->params[3].v =
	    RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d314 1
a314 1
	/* Launch the dag to write region parity to disk. */
d319 4
a322 2
void
rf_FlushLogsToDisk(RF_Raid_t *raidPtr, RF_ParityLog_t *logList)
d324 2
a325 3
	/*
	 * Flush a linked list of core logs to the log disk. Logs contain the
	 * disk location where they should be written. Logs were written in
d327 5
a331 7
	 *
	 * Recommended optimizations:
	 * 1) Allow multiple flushes to occur simultaneously.
	 * 2) Coalesce contiguous flush operations.
	 *
	 * BLOCKING
	 */
d348 1
a348 1
		/* Create and launch a DAG to write the core log. */
d350 1
a350 2
			printf("[initiating write of core log for region"
			    " %d]\n", regionID);
d352 2
a353 2
		rf_WriteCoreLog(log, fwr_mcpair, raidPtr, &fwr_dag_h,
		    &fwr_alloclist, &fwr_pda);
d355 1
a355 1
		/* Wait for the DAG to complete. */
d359 1
a359 2
			RF_ERRORMSG1("Unable to write core log to disk"
			    " (region %d)\n", regionID);
d374 5
a378 3
void
rf_ReintegrateRegion(RF_Raid_t *raidPtr, RF_RegionId_t regionID,
    RF_ParityLog_t *coreLog)
d386 1
a386 9
	/*
	 * Reintegrate a region (regionID).
	 *
	 * 1. Acquire region and parity buffers.
	 * 2. Read log from disk.
	 * 3. Read parity from disk.
	 * 4. Apply log to parity.
	 * 5. Apply core log to parity.
	 * 6. Write new parity to disk.
d388 8
a395 2
	 * BLOCKING
	 */
d400 1
a400 1
	/* Initiate read of region parity. */
d402 2
a403 2
		printf("[initiating read of parity for region %d]\n", regionID);
	parityBuffer = rf_AcquireReintBuffer(&raidPtr->parityBufferPool);
d407 1
a407 1
	rf_ReadRegionParity(regionID, prd_mcpair, parityBuffer, raidPtr,
d410 1
a410 1
	/* If region log nonempty, initiate read. */
d414 2
a415 3
			    regionID);
		regionBuffer =
		    rf_AcquireReintBuffer(&raidPtr->regionBufferPool);
d419 2
a420 2
		rf_ReadRegionLog(regionID, rrd_mcpair, regionBuffer, raidPtr,
		    &rrd_dag_h, &rrd_alloclist, &rrd_pda);
d422 1
a422 1
	/* Wait on read of region parity to complete. */
d429 1
a429 1
		/* Add code to fail the parity disk. */
d432 1
a432 1
	/* Apply core log to parity. */
d436 1
a436 1
		/* Wait on read of region log to complete. */
d442 1
a442 1
			/* Add code to fail the log disk. */
d445 1
a445 1
		/* Apply region log to parity. */
d447 1
a447 1
		/* Release resources associated with region log. */
d453 1
a453 1
		rf_ReleaseReintBuffer(&raidPtr->regionBufferPool, regionBuffer);
d455 1
a455 1
	/* Write reintegrated parity to disk. */
d458 1
a458 1
		    regionID);
d462 2
a463 2
	rf_WriteRegionParity(regionID, pwr_mcpair, parityBuffer, raidPtr,
	    &pwr_dag_h, &pwr_alloclist, &pwr_pda);
d469 1
a469 1
		/* Add code to fail the parity disk. */
d472 1
a472 1
	/* Release resources associated with read of old parity. */
d479 2
a480 2
	/* Release resources associated with write of new parity. */
	rf_ReleaseReintBuffer(&raidPtr->parityBufferPool, parityBuffer);
d492 5
a496 2
void
rf_ReintegrateLogs(RF_Raid_t *raidPtr, RF_ParityLog_t *logList)
d508 1
a508 1
		rf_ReintegrateRegion(raidPtr, regionID, log);
d511 2
a512 4
		/*
		 * Remove all items which are blocked on reintegration of this
		 * region.
		 */
d514 4
a517 3
		logData = rf_SearchAndDequeueParityLogData(raidPtr, regionID,
		    &raidPtr->parityLogDiskQueue.reintBlockHead,
		    &raidPtr->parityLogDiskQueue.reintBlockTail, RF_TRUE);
d520 5
a524 5
			logData->next =
			    rf_SearchAndDequeueParityLogData(raidPtr, regionID,
			     &raidPtr->parityLogDiskQueue.reintBlockHead,
			     &raidPtr->parityLogDiskQueue.reintBlockTail,
			     RF_TRUE);
d529 2
a530 4
		/*
		 * Process blocked log data and clear reintInProgress flag for
		 * this region.
		 */
d534 1
a534 2
			/*
			 * Enable flushing for this region. Holding both
d536 1
a536 2
			 * DumpParityLogToDisk.
			 */
d541 1
a541 2
			raidPtr->regionInfo[regionID].reintInProgress =
			    RF_FALSE;
d543 2
a544 2
			RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID]
			    .reintMutex);	/* Flushing is now enabled. */
d547 2
a548 4
		/*
		 * If log wasn't used, attach it to the list of logs to be
		 * returned.
		 */
d558 2
a559 2
int
rf_ShutdownLogging(RF_Raid_t *raidPtr)
d561 2
a562 5
	/*
	 * Shutdown parity logging:
	 * 1) Disable parity logging in all regions.
	 * 2) Reintegrate all regions.
	 */
d570 2
a571 4
	/*
	 * Since parity log maps are volatile, we must reintegrate all
	 * regions.
	 */
d575 2
a576 1
			raidPtr->regionInfo[regionID].loggingEnabled = RF_FALSE;
d582 1
a582 1
				rf_ReintegrateRegion(raidPtr, regionID, log);
d589 1
a589 1
		printf("[should be done !]\n");
d594 2
a595 2
int
rf_ParityLoggingDiskManager(RF_Raid_t *raidPtr)
d598 1
a598 1
	int workNeeded, done = RF_FALSE;
d601 1
a601 2
	/*
	 * Main program for parity logging disk thread. This routine waits
d605 2
a606 3
	 *
	 * BLOCKING
	 */
d613 4
a616 4
	 * Inform our creator that we're running. Don't bother doing the
	 * mutex lock/unlock dance: we locked above, and we'll unlock
	 * below with nothing to do, yet.
	 */
d620 1
a620 1
	/* Empty the work queues. */
d629 2
a630 3
			/*
			 * First, flush all logs in the flush queue, freeing
			 * buffers. Second, reintegrate all regions that are
d633 4
a636 4
			 *
			 * Note: Incoming appends (ParityLogAppend) can block
			 * on either 1. empty buffer pool 2. region under
			 * reintegration. To preserve a global FIFO ordering of
d639 3
a641 4
			 * from the append queue. Similarly, regions that are
			 * reintegrated are not opened for general use until
			 * the append queue has been emptied.
			 */
d645 2
a646 4
			/*
			 * Empty flushQueue, using free'd log buffers to
			 * process bufTail.
			 */
d648 1
a648 1
				rf_FlushLogsToDisk(raidPtr, flushQueue);
d650 1
a650 3
			/*
			 * Empty reintQueue, flushing from reintTail as we go.
			 */
d652 1
a652 1
				rf_ReintegrateLogs(raidPtr, reintQueue);
d661 1
a661 1
		/* No work is needed at this point. */
d663 3
a665 6
			/*
			 * Shutdown parity logging:
			 * 1. Disable parity logging in all regions.
			 * 2. Reintegrate all regions.
			 */
			done = RF_TRUE;	/* Thread disabled, no work needed. */
d670 1
a670 1
			/* Thread enabled, no work needed, so sleep. */
d672 3
a674 4
				printf("[parity logging disk manager"
				    " sleeping]\n");
			RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond,
			    raidPtr->parityLogDiskQueue.mutex);
d676 1
a676 2
				printf("[parity logging disk manager just"
				    " woke up]\n");
d685 2
a686 2
	 * Announce that we're done.
	 */
d695 3
a697 3
	 * In the Net- & OpenBSD kernel, the thread must exit; returning would
	 * cause the proc trampoline to attempt to return to userspace.
	 */
d700 1
a700 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
@


1.3
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylogDiskMgr.c,v 1.2 1999/02/16 00:03:05 niklas Exp $	*/
/*	$NetBSD: rf_paritylogDiskMgr.c,v 1.4 1999/08/13 03:41:57 oster Exp $	*/
a47 1
#include "rf_threadid.h"
a556 2
	rf_assign_threadid();	/* don't remove this line */

d644 1
a644 1
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
a649 3
#else
	return (0);
#endif
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylogDiskMgr.c,v 1.1 1999/01/11 14:29:34 niklas Exp $	*/
/*	$NetBSD: rf_paritylogDiskMgr.c,v 1.3 1999/02/05 00:06:14 oster Exp $	*/
a54 1
#include "rf_sys.h"
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_paritylogDiskMgr.c,v 1.1 1998/11/13 04:20:31 oster Exp $	*/
/*	$NetBSD: rf_paritylogDiskMgr.c,v 1.1 1998/11/13 04:20:31 oster Exp $	*/
a30 107
 * :  
 * Log: rf_paritylogDiskMgr.c,v 
 * Revision 1.25  1996/07/28 20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.24  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.23  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.22  1996/06/11  10:17:33  jimz
 * Put in thread startup/shutdown mechanism for proper synchronization
 * with start and end of day routines.
 *
 * Revision 1.21  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.20  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.19  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.18  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.17  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.16  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.15  1996/05/30  12:59:18  jimz
 * make etimer happier, more portable
 *
 * Revision 1.14  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.13  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.12  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.11  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.10  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.9  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.8  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.7  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.6  1995/12/06  20:58:27  wvcii
 * added prototypes
 *
 * Revision 1.5  1995/11/30  16:06:05  wvcii
 * added copyright info
 *
 * Revision 1.4  1995/10/09  22:41:10  wvcii
 * minor bug fix
 *
 * Revision 1.3  1995/10/08  20:43:47  wvcii
 * lots of random debugging - debugging still incomplete
 *
 * Revision 1.2  1995/09/07  15:52:19  jimz
 * noop compile when INCLUDE_PARITYLOGGING not defined
 *
 * Revision 1.1  1995/09/06  19:24:44  wvcii
 * Initial revision
 *
d61 45
a105 4
static caddr_t AcquireReintBuffer(pool)
  RF_RegionBufferQueue_t  *pool;
{
  caddr_t bufPtr = NULL;
d107 39
a145 79
  /* Return a region buffer from the free list (pool).
     If the free list is empty, WAIT.
     BLOCKING */

  RF_LOCK_MUTEX(pool->mutex);
  if (pool->availableBuffers > 0) {
    bufPtr = pool->buffers[pool->availBuffersIndex];
    pool->availableBuffers--;
    pool->availBuffersIndex++;
    if (pool->availBuffersIndex == pool->totalBuffers)
      pool->availBuffersIndex = 0;
    RF_UNLOCK_MUTEX(pool->mutex);
  }
  else {
    RF_PANIC(); /* should never happen in currect config, single reint */
    RF_WAIT_COND(pool->cond, pool->mutex);
  }
  return(bufPtr);
}

static void ReleaseReintBuffer(
  RF_RegionBufferQueue_t  *pool,
  caddr_t                  bufPtr)
{
  /* Insert a region buffer (bufPtr) into the free list (pool).
     NON-BLOCKING */

  RF_LOCK_MUTEX(pool->mutex);
  pool->availableBuffers++;
  pool->buffers[pool->emptyBuffersIndex] = bufPtr;
  pool->emptyBuffersIndex++;
  if (pool->emptyBuffersIndex == pool->totalBuffers)
    pool->emptyBuffersIndex = 0;
  RF_ASSERT(pool->availableBuffers <= pool->totalBuffers);
  RF_UNLOCK_MUTEX(pool->mutex);
  RF_SIGNAL_COND(pool->cond);
}



static void ReadRegionLog(
  RF_RegionId_t         regionID,
  RF_MCPair_t          *rrd_mcpair,
  caddr_t               regionBuffer,
  RF_Raid_t            *raidPtr,
  RF_DagHeader_t      **rrd_dag_h,
  RF_AllocListElem_t  **rrd_alloclist,
  RF_PhysDiskAddr_t   **rrd_pda)
{
  /* Initiate the read a region log from disk.  Once initiated, return
     to the calling routine.

     NON-BLOCKING
   */

  RF_AccTraceEntry_t tracerec;
  RF_DagNode_t *rrd_rdNode;

  /* create DAG to read region log from disk */
  rf_MakeAllocList(*rrd_alloclist);
  *rrd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, regionBuffer, rf_DiskReadFunc, rf_DiskReadUndoFunc,
			     "Rrl", *rrd_alloclist, RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

  /* create and initialize PDA for the core log */
  /* RF_Malloc(*rrd_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *)); */
  *rrd_pda = rf_AllocPDAList(1);
  rf_MapLogParityLogging(raidPtr, regionID, 0, &((*rrd_pda)->row), &((*rrd_pda)->col), &((*rrd_pda)->startSector));
  (*rrd_pda)->numSector = raidPtr->regionInfo[regionID].capacity;

  if ((*rrd_pda)->next) {
    (*rrd_pda)->next = NULL;
    printf("set rrd_pda->next to NULL\n");
  }

  /* initialize DAG parameters */
  bzero((char *)&tracerec,sizeof(tracerec));
  (*rrd_dag_h)->tracerec = &tracerec;
  rrd_rdNode = (*rrd_dag_h)->succedents[0]->succedents[0];
  rrd_rdNode->params[0].p = *rrd_pda;
d147 2
a148 2
  rrd_rdNode->params[2].v = 0;
  rrd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d150 3
a152 3
  /* launch region log read dag */
  rf_DispatchDAG(*rrd_dag_h, (void (*)(void *))rf_MCPairWakeupFunc, 
		 (void *) rrd_mcpair);
d157 37
a193 36
static void WriteCoreLog(
  RF_ParityLog_t       *log,
  RF_MCPair_t          *fwr_mcpair,
  RF_Raid_t            *raidPtr,
  RF_DagHeader_t      **fwr_dag_h,
  RF_AllocListElem_t  **fwr_alloclist,
  RF_PhysDiskAddr_t   **fwr_pda)
{
  RF_RegionId_t regionID = log->regionID;
  RF_AccTraceEntry_t tracerec;
  RF_SectorNum_t regionOffset;
  RF_DagNode_t *fwr_wrNode;

  /* Initiate the write of a core log to a region log disk.
     Once initiated, return to the calling routine.

     NON-BLOCKING
   */

  /* create DAG to write a core log to a region log disk */
  rf_MakeAllocList(*fwr_alloclist);
  *fwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, log->bufPtr, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
			     "Wcl", *fwr_alloclist, RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

  /* create and initialize PDA for the region log */
  /* RF_Malloc(*fwr_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *)); */
  *fwr_pda = rf_AllocPDAList(1);
  regionOffset = log->diskOffset;
  rf_MapLogParityLogging(raidPtr, regionID, regionOffset, &((*fwr_pda)->row), &((*fwr_pda)->col), &((*fwr_pda)->startSector));
  (*fwr_pda)->numSector = raidPtr->numSectorsPerLog;

  /* initialize DAG parameters */
  bzero((char *)&tracerec,sizeof(tracerec));
  (*fwr_dag_h)->tracerec = &tracerec;
  fwr_wrNode = (*fwr_dag_h)->succedents[0]->succedents[0];
  fwr_wrNode->params[0].p = *fwr_pda;
d195 93
a287 92
  fwr_wrNode->params[2].v = 0;
  fwr_wrNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
  
  /* launch the dag to write the core log to disk */
  rf_DispatchDAG(*fwr_dag_h, (void (*)(void *)) rf_MCPairWakeupFunc,
		 (void *) fwr_mcpair);
}


static void ReadRegionParity(
  RF_RegionId_t         regionID,
  RF_MCPair_t          *prd_mcpair,
  caddr_t               parityBuffer,
  RF_Raid_t            *raidPtr,
  RF_DagHeader_t      **prd_dag_h,
  RF_AllocListElem_t  **prd_alloclist,
  RF_PhysDiskAddr_t   **prd_pda)
{
  /* Initiate the read region parity from disk.
     Once initiated, return to the calling routine.

     NON-BLOCKING
   */

  RF_AccTraceEntry_t tracerec;
  RF_DagNode_t *prd_rdNode;

  /* create DAG to read region parity from disk */
  rf_MakeAllocList(*prd_alloclist);
  *prd_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, NULL, rf_DiskReadFunc, rf_DiskReadUndoFunc,
			     "Rrp", *prd_alloclist, RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

  /* create and initialize PDA for region parity */
  /* RF_Malloc(*prd_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *)); */
  *prd_pda = rf_AllocPDAList(1);
  rf_MapRegionParity(raidPtr, regionID, &((*prd_pda)->row), &((*prd_pda)->col), &((*prd_pda)->startSector), &((*prd_pda)->numSector));
  if (rf_parityLogDebug)
    printf("[reading %d sectors of parity from region %d]\n", 
	   (int)(*prd_pda)->numSector, regionID);
  if ((*prd_pda)->next) {
    (*prd_pda)->next = NULL;
    printf("set prd_pda->next to NULL\n");
  }

  /* initialize DAG parameters */
  bzero((char *)&tracerec,sizeof(tracerec));
  (*prd_dag_h)->tracerec = &tracerec;
  prd_rdNode = (*prd_dag_h)->succedents[0]->succedents[0];
  prd_rdNode->params[0].p = *prd_pda;
  prd_rdNode->params[1].p = parityBuffer;
  prd_rdNode->params[2].v = 0;
  prd_rdNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
  if (rf_validateDAGDebug)
    rf_ValidateDAG(*prd_dag_h);
  /* launch region parity read dag */
  rf_DispatchDAG(*prd_dag_h, (void (*)(void *)) rf_MCPairWakeupFunc, 
		 (void *) prd_mcpair);
}

static void WriteRegionParity(
  RF_RegionId_t         regionID,
  RF_MCPair_t          *pwr_mcpair,
  caddr_t               parityBuffer,
  RF_Raid_t            *raidPtr,
  RF_DagHeader_t      **pwr_dag_h,
  RF_AllocListElem_t  **pwr_alloclist,
  RF_PhysDiskAddr_t   **pwr_pda)
{
  /* Initiate the write of region parity to disk.
     Once initiated, return to the calling routine.

     NON-BLOCKING
   */

  RF_AccTraceEntry_t tracerec;
  RF_DagNode_t *pwr_wrNode;

  /* create DAG to write region log from disk */
  rf_MakeAllocList(*pwr_alloclist);
  *pwr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, 0, parityBuffer, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,
			     "Wrp", *pwr_alloclist, RF_DAG_FLAGS_NONE, RF_IO_NORMAL_PRIORITY);

  /* create and initialize PDA for region parity */
  /* RF_Malloc(*pwr_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t *)); */
  *pwr_pda = rf_AllocPDAList(1);
  rf_MapRegionParity(raidPtr, regionID, &((*pwr_pda)->row), &((*pwr_pda)->col), &((*pwr_pda)->startSector), &((*pwr_pda)->numSector));

  /* initialize DAG parameters */
  bzero((char *)&tracerec,sizeof(tracerec));
  (*pwr_dag_h)->tracerec = &tracerec;
  pwr_wrNode = (*pwr_dag_h)->succedents[0]->succedents[0];
  pwr_wrNode->params[0].p = *pwr_pda;
d289 114
a402 2
  pwr_wrNode->params[2].v = 0;
  pwr_wrNode->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);
d404 244
a647 383
  /* launch the dag to write region parity to disk */
  rf_DispatchDAG(*pwr_dag_h, (void (*)(void *))rf_MCPairWakeupFunc,
			      (void *) pwr_mcpair);
}

static void FlushLogsToDisk(
  RF_Raid_t       *raidPtr,
  RF_ParityLog_t  *logList)
{
  /* Flush a linked list of core logs to the log disk.
     Logs contain the disk location where they should be
     written.  Logs were written in FIFO order and that
     order must be preserved.

     Recommended optimizations:
       1) allow multiple flushes to occur simultaneously
       2) coalesce contiguous flush operations

     BLOCKING
     */

  RF_ParityLog_t *log;
  RF_RegionId_t regionID;
  RF_MCPair_t *fwr_mcpair;
  RF_DagHeader_t *fwr_dag_h;
  RF_AllocListElem_t *fwr_alloclist;
  RF_PhysDiskAddr_t *fwr_pda;

  fwr_mcpair = rf_AllocMCPair();
  RF_LOCK_MUTEX(fwr_mcpair->mutex);
  
  RF_ASSERT(logList);
  log = logList;
  while (log)
    {
      regionID = log->regionID;
      
      /* create and launch a DAG to write the core log */
      if (rf_parityLogDebug)
	printf("[initiating write of core log for region %d]\n", regionID);
      fwr_mcpair->flag = RF_FALSE;
      WriteCoreLog(log, fwr_mcpair, raidPtr, &fwr_dag_h, &fwr_alloclist, &fwr_pda);

      /* wait for the DAG to complete */
#ifndef SIMULATE
      while (!fwr_mcpair->flag)
	RF_WAIT_COND(fwr_mcpair->cond, fwr_mcpair->mutex);
#endif /* !SIMULATE */
      if (fwr_dag_h->status != rf_enable)
	{
	  RF_ERRORMSG1("Unable to write core log to disk (region %d)\n", regionID);
	  RF_ASSERT(0);
	}

      /* RF_Free(fwr_pda, sizeof(RF_PhysDiskAddr_t)); */
      rf_FreePhysDiskAddr(fwr_pda);
      rf_FreeDAG(fwr_dag_h);
      rf_FreeAllocList(fwr_alloclist);

      log = log->next;
    }
  RF_UNLOCK_MUTEX(fwr_mcpair->mutex);
  rf_FreeMCPair(fwr_mcpair);
  rf_ReleaseParityLogs(raidPtr, logList);
}

static void ReintegrateRegion(
  RF_Raid_t       *raidPtr,
  RF_RegionId_t    regionID,
  RF_ParityLog_t  *coreLog)
{
  RF_MCPair_t *rrd_mcpair=NULL, *prd_mcpair, *pwr_mcpair;
  RF_DagHeader_t *rrd_dag_h, *prd_dag_h, *pwr_dag_h;
  RF_AllocListElem_t *rrd_alloclist, *prd_alloclist, *pwr_alloclist;
  RF_PhysDiskAddr_t *rrd_pda, *prd_pda, *pwr_pda;
  caddr_t parityBuffer, regionBuffer=NULL;

  /* Reintegrate a region (regionID).
     1. acquire region and parity buffers
     2. read log from disk
     3. read parity from disk
     4. apply log to parity
     5. apply core log to parity
     6. write new parity to disk

     BLOCKING
    */

  if (rf_parityLogDebug)
    printf("[reintegrating region %d]\n", regionID);

  /* initiate read of region parity */
  if (rf_parityLogDebug)
    printf("[initiating read of parity for region %d]\n", regionID);
  parityBuffer = AcquireReintBuffer(&raidPtr->parityBufferPool);
  prd_mcpair = rf_AllocMCPair();
  RF_LOCK_MUTEX(prd_mcpair->mutex);
  prd_mcpair->flag = RF_FALSE;
  ReadRegionParity(regionID, prd_mcpair, parityBuffer, raidPtr, &prd_dag_h, &prd_alloclist, &prd_pda);

  /* if region log nonempty, initiate read */
  if (raidPtr->regionInfo[regionID].diskCount > 0)
    {
      if (rf_parityLogDebug)
	printf("[initiating read of disk log for region %d]\n", regionID);
      regionBuffer = AcquireReintBuffer(&raidPtr->regionBufferPool);
      rrd_mcpair = rf_AllocMCPair();
      RF_LOCK_MUTEX(rrd_mcpair->mutex);
      rrd_mcpair->flag = RF_FALSE;
      ReadRegionLog(regionID, rrd_mcpair, regionBuffer, raidPtr, &rrd_dag_h, &rrd_alloclist, &rrd_pda);
    }

  /* wait on read of region parity to complete */
#ifndef SIMULATE
  while (!prd_mcpair->flag) {
    RF_WAIT_COND(prd_mcpair->cond, prd_mcpair->mutex);
  }
#endif /* !SIMULATE */
  RF_UNLOCK_MUTEX(prd_mcpair->mutex);
  if (prd_dag_h->status != rf_enable)
    {
      RF_ERRORMSG("Unable to read parity from disk\n");
      /* add code to fail the parity disk */
      RF_ASSERT(0);
    }
  
  /* apply core log to parity */
  /*  if (coreLog)
      ApplyLogsToParity(coreLog, parityBuffer); */
  
  if (raidPtr->regionInfo[regionID].diskCount > 0)
    {
      /* wait on read of region log to complete */
#ifndef SIMULATE
      while (!rrd_mcpair->flag)
	RF_WAIT_COND(rrd_mcpair->cond, rrd_mcpair->mutex);
#endif /* !SIMULATE */
      RF_UNLOCK_MUTEX(rrd_mcpair->mutex);
      if (rrd_dag_h->status != rf_enable)
	{
	  RF_ERRORMSG("Unable to read region log from disk\n");
	  /* add code to fail the log disk */
	  RF_ASSERT(0);
	}
      /* apply region log to parity */
      /*      ApplyRegionToParity(regionID, regionBuffer, parityBuffer); */
      /* release resources associated with region log */
      /* RF_Free(rrd_pda, sizeof(RF_PhysDiskAddr_t)); */
      rf_FreePhysDiskAddr(rrd_pda);
      rf_FreeDAG(rrd_dag_h);
      rf_FreeAllocList(rrd_alloclist);
      rf_FreeMCPair(rrd_mcpair);
      ReleaseReintBuffer(&raidPtr->regionBufferPool, regionBuffer);
    }

  /* write reintegrated parity to disk */
  if (rf_parityLogDebug)
    printf("[initiating write of parity for region %d]\n", regionID);
  pwr_mcpair = rf_AllocMCPair();
  RF_LOCK_MUTEX(pwr_mcpair->mutex);
  pwr_mcpair->flag = RF_FALSE;
  WriteRegionParity(regionID, pwr_mcpair, parityBuffer, raidPtr, &pwr_dag_h, &pwr_alloclist, &pwr_pda);
#ifndef SIMULATE
  while (!pwr_mcpair->flag)
    RF_WAIT_COND(pwr_mcpair->cond, pwr_mcpair->mutex);
#endif /* !SIMULATE */
  RF_UNLOCK_MUTEX(pwr_mcpair->mutex);
  if (pwr_dag_h->status != rf_enable)
    {
      RF_ERRORMSG("Unable to write parity to disk\n");
      /* add code to fail the parity disk */
      RF_ASSERT(0);
    }

  /* release resources associated with read of old parity */
  /* RF_Free(prd_pda, sizeof(RF_PhysDiskAddr_t)); */
  rf_FreePhysDiskAddr(prd_pda);
  rf_FreeDAG(prd_dag_h);
  rf_FreeAllocList(prd_alloclist);
  rf_FreeMCPair(prd_mcpair);

  /* release resources associated with write of new parity */
  ReleaseReintBuffer(&raidPtr->parityBufferPool, parityBuffer);
  /* RF_Free(pwr_pda, sizeof(RF_PhysDiskAddr_t)); */
  rf_FreePhysDiskAddr(pwr_pda);
  rf_FreeDAG(pwr_dag_h);
  rf_FreeAllocList(pwr_alloclist);
  rf_FreeMCPair(pwr_mcpair);

  if (rf_parityLogDebug)
    printf("[finished reintegrating region %d]\n", regionID);
}



static void ReintegrateLogs(
  RF_Raid_t       *raidPtr,
  RF_ParityLog_t  *logList)
{
  RF_ParityLog_t *log, *freeLogList = NULL;
  RF_ParityLogData_t *logData, *logDataList;
  RF_RegionId_t regionID;

  RF_ASSERT(logList);
  while (logList)
    {
      log = logList;
      logList = logList->next;
      log->next = NULL;
      regionID = log->regionID;
      ReintegrateRegion(raidPtr, regionID, log);
      log->numRecords = 0;

      /* remove all items which are blocked on reintegration of this region */
      RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
      logData = rf_SearchAndDequeueParityLogData(raidPtr, regionID, &raidPtr->parityLogDiskQueue.reintBlockHead, &raidPtr->parityLogDiskQueue.reintBlockTail, RF_TRUE);
      logDataList = logData;
      while (logData)
	{
	  logData->next = rf_SearchAndDequeueParityLogData(raidPtr, regionID, &raidPtr->parityLogDiskQueue.reintBlockHead, &raidPtr->parityLogDiskQueue.reintBlockTail, RF_TRUE);
	  logData = logData->next;
	}
      RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);

      /* process blocked log data and clear reintInProgress flag for this region */
      if (logDataList)
	rf_ParityLogAppend(logDataList, RF_TRUE, &log, RF_TRUE);
      else
	{
	  /* Enable flushing for this region.  Holding both locks provides
	     a synchronization barrier with DumpParityLogToDisk
	     */
	  RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	  RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);
	  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	  raidPtr->regionInfo[regionID].diskCount = 0;
	  raidPtr->regionInfo[regionID].reintInProgress = RF_FALSE;
	  RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	  RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex); /* flushing is now enabled */
	  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	}
      /* if log wasn't used, attach it to the list of logs to be returned */
      if (log)
	{
	  log->next = freeLogList;
	  freeLogList = log;
	}
    }
  if (freeLogList)
    rf_ReleaseParityLogs(raidPtr, freeLogList);
}

int rf_ShutdownLogging(RF_Raid_t *raidPtr)
{
  /* shutdown parity logging
     1) disable parity logging in all regions
     2) reintegrate all regions
     */

  RF_SectorCount_t diskCount;
  RF_RegionId_t regionID;
  RF_ParityLog_t *log;

  if (rf_parityLogDebug)
    printf("[shutting down parity logging]\n");
  /* Since parity log maps are volatile, we must reintegrate all regions. */
  if (rf_forceParityLogReint) {
    for (regionID = 0; regionID < rf_numParityRegions; regionID++)
      {
	RF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	raidPtr->regionInfo[regionID].loggingEnabled = RF_FALSE;
	log = raidPtr->regionInfo[regionID].coreLog;
	raidPtr->regionInfo[regionID].coreLog = NULL;
	diskCount = raidPtr->regionInfo[regionID].diskCount;
	RF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);
	if (diskCount > 0 || log != NULL)
	  ReintegrateRegion(raidPtr, regionID, log);
	if (log != NULL)
	  rf_ReleaseParityLogs(raidPtr, log);
      }
  }
  if (rf_parityLogDebug)
    {
      printf("[parity logging disabled]\n");
      printf("[should be done!]\n");
    }
  return(0);
}

int rf_ParityLoggingDiskManager(RF_Raid_t *raidPtr)
{
  RF_ParityLog_t *reintQueue, *flushQueue;
  int workNeeded, done = RF_FALSE;

  rf_assign_threadid(); /* don't remove this line */

  /* Main program for parity logging disk thread.  This routine waits
     for work to appear in either the flush or reintegration queues
     and is responsible for flushing core logs to the log disk as
     well as reintegrating parity regions.

     BLOCKING
     */

  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);

  /*
   * Inform our creator that we're running. Don't bother doing the
   * mutex lock/unlock dance- we locked above, and we'll unlock
   * below with nothing to do, yet.
   */
  raidPtr->parityLogDiskQueue.threadState |= RF_PLOG_RUNNING;
  RF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);

  /* empty the work queues */
  flushQueue = raidPtr->parityLogDiskQueue.flushQueue;  raidPtr->parityLogDiskQueue.flushQueue = NULL;
  reintQueue = raidPtr->parityLogDiskQueue.reintQueue;  raidPtr->parityLogDiskQueue.reintQueue = NULL;
  workNeeded = (flushQueue || reintQueue);

  while (!done)
    {
      while (workNeeded)
	{
	  /* First, flush all logs in the flush queue, freeing buffers
	     Second, reintegrate all regions which are reported as full.
	     Third, append queued log data until blocked.

	     Note: Incoming appends (ParityLogAppend) can block on either
	       1. empty buffer pool
	       2. region under reintegration
	     To preserve a global FIFO ordering of appends, buffers are not
	     released to the world until those appends blocked on buffers are
	     removed from the append queue.  Similarly, regions which are
	     reintegrated are not opened for general use until the append
	     queue has been emptied.
	     */

	  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);

	  /* empty flushQueue, using free'd log buffers to process bufTail */
	  if (flushQueue)
	    FlushLogsToDisk(raidPtr, flushQueue);

	  /* empty reintQueue, flushing from reintTail as we go */
	  if (reintQueue)
	    ReintegrateLogs(raidPtr, reintQueue);

	  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	  flushQueue = raidPtr->parityLogDiskQueue.flushQueue;  raidPtr->parityLogDiskQueue.flushQueue = NULL;
	  reintQueue = raidPtr->parityLogDiskQueue.reintQueue;  raidPtr->parityLogDiskQueue.reintQueue = NULL;
	  workNeeded = (flushQueue || reintQueue);
	}
      /* no work is needed at this point */
      if (raidPtr->parityLogDiskQueue.threadState&RF_PLOG_TERMINATE)
	{
	  /* shutdown parity logging
	     1. disable parity logging in all regions
	     2. reintegrate all regions
	     */
	  done = RF_TRUE;  /* thread disabled, no work needed */
	  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
	  rf_ShutdownLogging(raidPtr);
	}
      if (!done)
	{
	  /* thread enabled, no work needed, so sleep */
	  if (rf_parityLogDebug)
	    printf("[parity logging disk manager sleeping]\n");
	  RF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, raidPtr->parityLogDiskQueue.mutex);
	  if (rf_parityLogDebug)
	    printf("[parity logging disk manager just woke up]\n");
	  flushQueue = raidPtr->parityLogDiskQueue.flushQueue;  raidPtr->parityLogDiskQueue.flushQueue = NULL;
	  reintQueue = raidPtr->parityLogDiskQueue.reintQueue;  raidPtr->parityLogDiskQueue.reintQueue = NULL;
	  workNeeded = (flushQueue || reintQueue);
	}
    }
  /*
   * Announce that we're done.
   */
  RF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  raidPtr->parityLogDiskQueue.threadState |= RF_PLOG_SHUTDOWN;
  RF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);
  RF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);
d649 5
a653 5
  /*
   * In the Net- and OpenBSD kernels, the thread must exit; returning would
   * cause the proc trampoline to attempt to return to userspace.
   */
  kthread_exit(0);	/* does not return */
d655 1
a655 1
  return(0);
d658 1
a658 2

#endif /* RF_INCLUDE_PARITYLOGGING > 0 */
@

