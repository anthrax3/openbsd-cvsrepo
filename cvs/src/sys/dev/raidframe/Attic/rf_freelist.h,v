head	1.4;
access;
symbols
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.38
	OPENBSD_5_0:1.3.0.36
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.34
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.32
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.28
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.30
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.26
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.24
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.22
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.20
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.18
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.16
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.14
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.12
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.10
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.8
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.6
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.20
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.18
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.2.0.16
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.14
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.12
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.4
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.3;

1.3
date	2002.12.16.07.01.04;	author tdeval;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.47;	author niklas;	state Exp;
branches
	1.2.6.1
	1.2.16.1;
next	1.1;

1.1
date	99.01.11.14.29.23;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	;

1.2.16.1
date	2003.05.19.22.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_freelist.h,v 1.3 2002/12/16 07:01:04 tdeval Exp $	*/
/*	$NetBSD: rf_freelist.h,v 1.3 1999/02/05 00:06:11 oster Exp $	*/

/*
 * rf_freelist.h
 */
/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * rf_freelist.h -- Code to manage counted freelists.
 *
 * Keep an arena of fixed-size objects. When a new object is needed,
 * allocate it as necessary. When an object is freed, either put it
 * in the arena, or really free it, depending on the maximum arena
 * size.
 */

#ifndef	_RF__RF_FREELIST_H_
#define	_RF__RF_FREELIST_H_

#include "rf_types.h"
#include "rf_debugMem.h"
#include "rf_general.h"
#include "rf_threadstuff.h"

#define	RF_FREELIST_STATS	0

#if	RF_FREELIST_STATS > 0
typedef struct RF_FreeListStats_s {
	char	*file;
	int	 line;
	int	 allocations;
	int	 frees;
	int	 max_free;
	int	 grows;
	int	 outstanding;
	int	 max_outstanding;
} RF_FreeListStats_t;

#define	RF_FREELIST_STAT_INIT(_fl_)					\
do {									\
	bzero((char *)&((_fl_)->stats), sizeof(RF_FreeListStats_t));	\
	(_fl_)->stats.file = __FILE__;					\
	(_fl_)->stats.line = __LINE__;					\
} while (0)

#define	RF_FREELIST_STAT_ALLOC(_fl_)					\
do {									\
	(_fl_)->stats.allocations++;					\
	(_fl_)->stats.outstanding++;					\
	if ((_fl_)->stats.outstanding > (_fl_)->stats.max_outstanding)	\
		(_fl_)->stats.max_outstanding =				\
		    (_fl_)->stats.outstanding;				\
} while (0)

#define	RF_FREELIST_STAT_FREE_UPDATE(_fl_)				\
do {									\
	if ((_fl_)->free_cnt > (_fl_)->stats.max_free)			\
		(_fl_)->stats.max_free = (_fl_)->free_cnt;		\
} while (0)

#define	RF_FREELIST_STAT_FREE(_fl_)					\
do {									\
	(_fl_)->stats.frees++;						\
	(_fl_)->stats.outstanding--;					\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
} while (0)

#define	RF_FREELIST_STAT_GROW(_fl_)					\
do {									\
	(_fl_)->stats.grows++;						\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
} while (0)

#define	RF_FREELIST_STAT_REPORT(_fl_)					\
do {									\
	printf("Freelist at %s %d (%s)\n", (_fl_)->stats.file,		\
	    (_fl_)->stats.line, RF_STRING(_fl_));			\
	printf("  %d allocations, %d frees\n",				\
	    (_fl_)->stats.allocations, (_fl_)->stats.frees);		\
	printf("  %d grows\n", (_fl_)->stats.grows);			\
	printf("  %d outstanding\n", (_fl_)->stats.outstanding);	\
	printf("  %d free (max)\n", (_fl_)->stats.max_free);		\
	printf("  %d outstanding (max)\n",				\
	    (_fl_)->stats.max_outstanding);				\
} while (0)

#else	/* RF_FREELIST_STATS > 0 */

#define	RF_FREELIST_STAT_INIT(_fl_)
#define	RF_FREELIST_STAT_ALLOC(_fl_)
#define	RF_FREELIST_STAT_FREE_UPDATE(_fl_)
#define	RF_FREELIST_STAT_FREE(_fl_)
#define	RF_FREELIST_STAT_GROW(_fl_)
#define	RF_FREELIST_STAT_REPORT(_fl_)

#endif	/* RF_FREELIST_STATS > 0 */

struct RF_FreeList_s {
	void	*objlist;	/* List of free obj. */
	int	 free_cnt;	/* How many free obj. */
	int	 max_free_cnt;	/* Max free arena size. */
	int	 obj_inc;	/* How many to allocate at a time. */
	int	 obj_size;	/* Size of objects. */
	RF_DECLARE_MUTEX(lock);
#if	RF_FREELIST_STATS > 0
	RF_FreeListStats_t stats;	/* Statistics. */
#endif	/* RF_FREELIST_STATS > 0 */
};

/*
 * fl	  = FreeList.
 * maxcnt = Max number of items in arena.
 * inc	  = How many to allocate at a time.
 * size	  = Size of object.
 */
#define	RF_FREELIST_CREATE(_fl_,_maxcnt_,_inc_,_size_)			\
do {									\
	int rc;								\
	RF_ASSERT((_inc_) > 0);						\
	RF_Malloc(_fl_, sizeof(RF_FreeList_t), (RF_FreeList_t *));	\
	(_fl_)->objlist = NULL;						\
	(_fl_)->free_cnt = 0;						\
	(_fl_)->max_free_cnt = _maxcnt_;				\
	(_fl_)->obj_inc = _inc_;					\
	(_fl_)->obj_size = _size_;					\
	rc = rf_mutex_init(&(_fl_)->lock);				\
	if (rc) {							\
		RF_Free(_fl_, sizeof(RF_FreeList_t));			\
		_fl_ = NULL;						\
	}								\
	RF_FREELIST_STAT_INIT(_fl_);					\
} while (0)

/*
 * fl	 = FreeList.
 * cnt	 = Number to prime with.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Object cast.
 */
#define	RF_FREELIST_PRIME(_fl_,_cnt_,_nextp_,_cast_)			\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	for (_i = 0; _i < (_cnt_); _i++) {				\
		RF_Calloc(_p, 1, (_fl_)->obj_size, (void *));		\
		if (_p) {						\
			(_cast_(_p))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _p;				\
			(_fl_)->free_cnt++;				\
		}							\
		else {							\
			break;						\
		}							\
	}								\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

#define	RF_FREELIST_MUTEX_OF(_fl_)	((_fl_)->lock)

#define	RF_FREELIST_DO_UNLOCK(_fl_)	RF_UNLOCK_MUTEX((_fl_)->lock)

#define	RF_FREELIST_DO_LOCK(_fl_)	RF_LOCK_MUTEX((_fl_)->lock)

/*
 * fl	 = FreeList.
 * cnt	 = Number to prime with.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Object cast.
 * init	 = Func to call to init obj.
 */
#define	RF_FREELIST_PRIME_INIT(_fl_,_cnt_,_nextp_,_cast_,_init_)	\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	for (_i = 0; _i < (_cnt_); _i++) {				\
		RF_Calloc(_p, 1, (_fl_)->obj_size, (void *));		\
		if (_init_(_cast_ _p)) {				\
			RF_Free(_p, (_fl_)->obj_size);			\
			_p = NULL;					\
		}							\
		if (_p) {						\
			(_cast_(_p))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _p;				\
			(_fl_)->free_cnt++;				\
		}							\
		else {							\
			break;						\
		}							\
	}								\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * cnt	 = Number to prime with.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Object cast.
 * init	 = Func to call to init obj.
 * arg	 = Arg to init obj func.
 */
#define	RF_FREELIST_PRIME_INIT_ARG(_fl_,_cnt_,_nextp_,_cast_,_init_,_arg_) \
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	for (_i = 0; _i < (_cnt_); _i++) {				\
		RF_Calloc(_p, 1, (_fl_)->obj_size, (void *));		\
		if (_init_(_cast_ _p, _arg_)) {				\
			RF_Free(_p, (_fl_)->obj_size);			\
			_p = NULL;					\
		}							\
		if (_p) {						\
			(_cast_(_p))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _p;				\
			(_fl_)->free_cnt++;				\
		}							\
		else {							\
			break;						\
		}							\
	}								\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * init	 = Init obj func.
 */
#define	RF_FREELIST_GET_INIT(_fl_,_obj_,_nextp_,_cast_,_init_)		\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			if (_init_(_obj_)) {				\
				RF_Free(_obj_, (_fl_)->obj_size);	\
				_obj_ = NULL;				\
			}						\
			else {						\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					    (_fl_)->obj_size,		\
					    (void *));			\
					if (_p) {			\
						if (_init_(_p)) {	\
							RF_Free(_p,	\
						  (_fl_)->obj_size);	\
							_p = NULL;	\
							break;		\
						}			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
		} 							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * init	 = Init obj func.
 * arg	 = Arg to init obj func.
 */
#define	RF_FREELIST_GET_INIT_ARG(_fl_,_obj_,_nextp_,_cast_,_init_,_arg_) \
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			if (_init_(_obj_, _arg_)) {			\
				RF_Free(_obj_, (_fl_)->obj_size);	\
				_obj_ = NULL;				\
			}						\
			else {						\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					   (_fl_)->obj_size, (void *));	\
					if (_p) {			\
						if (_init_(_p, _arg_))	\
						{			\
							RF_Free(_p,	\
						    (_fl_)->obj_size);	\
							_p = NULL;	\
							break;		\
						}			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
		}							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * init	 = Init obj func.
 */
#define	RF_FREELIST_GET_INIT_NOUNLOCK(_fl_,_obj_,_nextp_,_cast_,_init_)	\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			if (_init_(_obj_)) {				\
				RF_Free(_obj_, (_fl_)->obj_size);	\
				_obj_ = NULL;				\
			}						\
			else {						\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					    (_fl_)->obj_size,		\
					    (void *));			\
					if (_p) {			\
						if (_init_(_p)) {	\
							RF_Free(_p,	\
						    (_fl_)->obj_size);	\
							_p = NULL;	\
							break;		\
						}			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
		}							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 */
#define	RF_FREELIST_GET(_fl_,_obj_,_nextp_,_cast_)			\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			for (_i = 1; _i < (_fl_)->obj_inc; _i++) {	\
				RF_Calloc(_p, 1, (_fl_)->obj_size,	\
				    (void *));				\
				if (_p) {				\
					(_cast_(_p))->_nextp_ =		\
					    (_fl_)->objlist;		\
					(_fl_)->objlist = _p;		\
				}					\
				else {					\
					break;				\
				}					\
			}						\
		}							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * num	 = Num objs to return.
 */
#define	RF_FREELIST_GET_N(_fl_,_obj_,_nextp_,_cast_,_num_)		\
do {									\
	void *_p, *_l, *_f;						\
	int _i, _n;							\
	_l = _f = NULL;							\
	_n = 0;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	for (_n = 0; _n < _num_; _n++) {				\
		if (_fl_->objlist) {					\
			_obj_ = _cast_((_fl_)->objlist);		\
			(_fl_)->objlist = (void *)((_obj_)->_nextp_);	\
			(_fl_)->free_cnt--;				\
		}							\
		else {							\
			/*						\
			 * Allocate one at a time so we can free	\
			 * one at a time without cleverness when arena	\
			 * is full.					\
			 */						\
			RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);	\
			if (_obj_) {					\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					    (_fl_)->obj_size,		\
					    (void *));			\
					if (_p) {			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
			RF_FREELIST_STAT_GROW(_fl_);			\
		}							\
		if (_f == NULL)						\
			_f = _obj_;					\
		if (_obj_) {						\
			(_cast_(_obj_))->_nextp_ = _l;			\
			_l = _obj_;					\
			RF_FREELIST_STAT_ALLOC(_fl_);			\
		}							\
		else {							\
			(_cast_(_f))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _l;				\
			_n = _num_;					\
		}							\
	}								\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 */
#define	RF_FREELIST_FREE(_fl_,_obj_,_nextp_)				\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * num	 = Num to free (debugging).
 */
#define	RF_FREELIST_FREE_N(_fl_,_obj_,_nextp_,_cast_,_num_)		\
do {									\
	void *_no;							\
	int _n;								\
	_n = 0;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	while(_obj_) {							\
		_no = (_cast_(_obj_))->_nextp_;				\
		if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {		\
			RF_Free(_obj_, (_fl_)->obj_size);		\
		}							\
		else {							\
			RF_ASSERT((_fl_)->free_cnt <			\
			    (_fl_)->max_free_cnt);			\
			(_obj_)->_nextp_ = (_fl_)->objlist;		\
			(_fl_)->objlist = (void *)(_obj_);		\
			(_fl_)->free_cnt++;				\
		}							\
		_n++;							\
		_obj_ = _no;						\
		RF_FREELIST_STAT_FREE(_fl_);				\
	}								\
	RF_ASSERT(_n==(_num_));						\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * clean = Undo for init.
 */
#define	RF_FREELIST_FREE_CLEAN(_fl_,_obj_,_nextp_,_clean_)		\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		_clean_(_obj_);					\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * clean = Undo for init.
 * arg	 = Arg for undo func.
 */
#define	RF_FREELIST_FREE_CLEAN_ARG(_fl_,_obj_,_nextp_,_clean_,_arg_)	\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		_clean_(_obj_, _arg_);					\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * clean = Undo for init.
 */
#define	RF_FREELIST_FREE_CLEAN_NOUNLOCK(_fl_,_obj_,_nextp_,_clean_)	\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		_clean_(_obj_);					\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
} while (0)

/*
 * fl	 = FreeList.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast to object type.
 */
#define	RF_FREELIST_DESTROY(_fl_,_nextp_,_cast_)			\
do {									\
	void *_cur, *_next;						\
	RF_FREELIST_STAT_REPORT(_fl_);					\
	rf_mutex_destroy(&((_fl_)->lock));				\
	for (_cur = (_fl_)->objlist; _cur; _cur = _next) {		\
		_next = (_cast_ _cur)->_nextp_;				\
		RF_Free(_cur, (_fl_)->obj_size);			\
	}								\
	RF_Free(_fl_, sizeof(RF_FreeList_t));				\
} while (0)

/*
 * fl	 = FreeList.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast to object type.
 * clean = Func to undo obj init.
 */
#define	RF_FREELIST_DESTROY_CLEAN(_fl_,_nextp_,_cast_,_clean_)		\
do {									\
	void *_cur, *_next;						\
	RF_FREELIST_STAT_REPORT(_fl_);					\
	rf_mutex_destroy(&((_fl_)->lock));				\
	for (_cur = (_fl_)->objlist; _cur; _cur = _next) {		\
		_next = (_cast_ _cur)->_nextp_;				\
		_clean_(_cur);						\
		RF_Free(_cur, (_fl_)->obj_size);			\
	}								\
	RF_Free(_fl_, sizeof(RF_FreeList_t));				\
} while (0)

/*
 * fl	 = FreeList.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast to object type.
 * clean = Func to undo obj init.
 * arg	 = Arg for undo func.
 */
#define	RF_FREELIST_DESTROY_CLEAN_ARG(_fl_,_nextp_,_cast_,_clean_,_arg_) \
do {									\
	void *_cur, *_next;						\
	RF_FREELIST_STAT_REPORT(_fl_);					\
	rf_mutex_destroy(&((_fl_)->lock));				\
	for (_cur = (_fl_)->objlist; _cur; _cur = _next) {		\
		_next = (_cast_ _cur)->_nextp_;				\
		_clean_(_cur, _arg_);					\
		RF_Free(_cur, (_fl_)->obj_size);			\
	}								\
	RF_Free(_fl_, sizeof(RF_FreeList_t));				\
} while (0)

#endif	/* !_RF__RF_FREELIST_H_ */
@


1.3
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_freelist.h,v 1.2 1999/02/16 00:02:47 niklas Exp $	*/
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_freelist.h,v 1.1 1999/01/11 14:29:23 niklas Exp $	*/
d3 1
d35 1
a35 1
 * rf_freelist.h -- code to manage counted freelists
d43 2
a44 2
#ifndef _RF__RF_FREELIST_H_
#define _RF__RF_FREELIST_H_
d51 1
a51 1
#define RF_FREELIST_STATS 0
d53 1
a53 1
#if RF_FREELIST_STATS > 0
d55 66
a120 55
	char   *file;
	int     line;
	int     allocations;
	int     frees;
	int     max_free;
	int     grows;
	int     outstanding;
	int     max_outstanding;
}       RF_FreeListStats_t;
#define RF_FREELIST_STAT_INIT(_fl_) { \
	bzero((char *)&((_fl_)->stats), sizeof(RF_FreeListStats_t)); \
	(_fl_)->stats.file = __FILE__; \
	(_fl_)->stats.line = __LINE__; \
}

#define RF_FREELIST_STAT_ALLOC(_fl_) { \
	(_fl_)->stats.allocations++; \
	(_fl_)->stats.outstanding++; \
	if ((_fl_)->stats.outstanding > (_fl_)->stats.max_outstanding) \
		(_fl_)->stats.max_outstanding = (_fl_)->stats.outstanding; \
}

#define RF_FREELIST_STAT_FREE_UPDATE(_fl_) { \
	if ((_fl_)->free_cnt > (_fl_)->stats.max_free) \
		(_fl_)->stats.max_free = (_fl_)->free_cnt; \
}

#define RF_FREELIST_STAT_FREE(_fl_) { \
	(_fl_)->stats.frees++; \
	(_fl_)->stats.outstanding--; \
	RF_FREELIST_STAT_FREE_UPDATE(_fl_); \
}

#define RF_FREELIST_STAT_GROW(_fl_) { \
	(_fl_)->stats.grows++; \
	RF_FREELIST_STAT_FREE_UPDATE(_fl_); \
}

#define RF_FREELIST_STAT_REPORT(_fl_) { \
	printf("Freelist at %s %d (%s)\n", (_fl_)->stats.file, (_fl_)->stats.line, RF_STRING(_fl_)); \
	printf("  %d allocations, %d frees\n", (_fl_)->stats.allocations, (_fl_)->stats.frees); \
	printf("  %d grows\n", (_fl_)->stats.grows); \
	printf("  %d outstanding\n", (_fl_)->stats.outstanding); \
	printf("  %d free (max)\n", (_fl_)->stats.max_free); \
	printf("  %d outstanding (max)\n", (_fl_)->stats.max_outstanding); \
}

#else				/* RF_FREELIST_STATS > 0 */

#define RF_FREELIST_STAT_INIT(_fl_)
#define RF_FREELIST_STAT_ALLOC(_fl_)
#define RF_FREELIST_STAT_FREE_UPDATE(_fl_)
#define RF_FREELIST_STAT_FREE(_fl_)
#define RF_FREELIST_STAT_GROW(_fl_)
#define RF_FREELIST_STAT_REPORT(_fl_)
d122 1
a122 1
#endif				/* RF_FREELIST_STATS > 0 */
d125 9
a133 9
	void   *objlist;	/* list of free obj */
	int     free_cnt;	/* how many free obj */
	int     max_free_cnt;	/* max free arena size */
	int     obj_inc;	/* how many to allocate at a time */
	int     obj_size;	/* size of objects */
	        RF_DECLARE_MUTEX(lock)
#if RF_FREELIST_STATS > 0
	RF_FreeListStats_t stats;	/* statistics */
#endif				/* RF_FREELIST_STATS > 0 */
d135 1
d137 578
a714 543
 * fl     = freelist
 * maxcnt = max number of items in arena
 * inc    = how many to allocate at a time
 * size   = size of object
 */
#define RF_FREELIST_CREATE(_fl_,_maxcnt_,_inc_,_size_) { \
	int rc; \
	RF_ASSERT((_inc_) > 0); \
	RF_Malloc(_fl_, sizeof(RF_FreeList_t), (RF_FreeList_t *)); \
	(_fl_)->objlist = NULL; \
	(_fl_)->free_cnt = 0; \
	(_fl_)->max_free_cnt = _maxcnt_; \
	(_fl_)->obj_inc = _inc_; \
	(_fl_)->obj_size = _size_; \
	rc = rf_mutex_init(&(_fl_)->lock); \
	if (rc) { \
		RF_Free(_fl_, sizeof(RF_FreeList_t)); \
		_fl_ = NULL; \
	} \
	RF_FREELIST_STAT_INIT(_fl_); \
}

/*
 * fl    = freelist
 * cnt   = number to prime with
 * nextp = name of "next" pointer in obj
 * cast  = object cast
 */
#define RF_FREELIST_PRIME(_fl_,_cnt_,_nextp_,_cast_) { \
	void *_p; \
	int _i; \
	RF_LOCK_MUTEX((_fl_)->lock); \
	for(_i=0;_i<(_cnt_);_i++) { \
		RF_Calloc(_p,1,(_fl_)->obj_size,(void *)); \
		if (_p) { \
			(_cast_(_p))->_nextp_ = (_fl_)->objlist; \
			(_fl_)->objlist = _p; \
			(_fl_)->free_cnt++; \
		} \
		else { \
			break; \
		} \
	} \
	RF_FREELIST_STAT_FREE_UPDATE(_fl_); \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

#define RF_FREELIST_MUTEX_OF(_fl_) ((_fl_)->lock)

#define RF_FREELIST_DO_UNLOCK(_fl_) { \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

#define RF_FREELIST_DO_LOCK(_fl_) { \
	RF_LOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl    = freelist
 * cnt   = number to prime with
 * nextp = name of "next" pointer in obj
 * cast  = object cast
 * init  = func to call to init obj
 */
#define RF_FREELIST_PRIME_INIT(_fl_,_cnt_,_nextp_,_cast_,_init_) { \
	void *_p; \
	int _i; \
	RF_LOCK_MUTEX((_fl_)->lock); \
	for(_i=0;_i<(_cnt_);_i++) { \
		RF_Calloc(_p,1,(_fl_)->obj_size,(void *)); \
		if (_init_ (_cast_ _p)) { \
			RF_Free(_p,(_fl_)->obj_size); \
			_p = NULL; \
		} \
		if (_p) { \
			(_cast_(_p))->_nextp_ = (_fl_)->objlist; \
			(_fl_)->objlist = _p; \
			(_fl_)->free_cnt++; \
		} \
		else { \
			break; \
		} \
	} \
	RF_FREELIST_STAT_FREE_UPDATE(_fl_); \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl    = freelist
 * cnt   = number to prime with
 * nextp = name of "next" pointer in obj
 * cast  = object cast
 * init  = func to call to init obj
 * arg   = arg to init obj func
 */
#define RF_FREELIST_PRIME_INIT_ARG(_fl_,_cnt_,_nextp_,_cast_,_init_,_arg_) { \
	void *_p; \
	int _i; \
	RF_LOCK_MUTEX((_fl_)->lock); \
	for(_i=0;_i<(_cnt_);_i++) { \
		RF_Calloc(_p,1,(_fl_)->obj_size,(void *)); \
		if (_init_ (_cast_ _p,_arg_)) { \
			RF_Free(_p,(_fl_)->obj_size); \
			_p = NULL; \
		} \
		if (_p) { \
			(_cast_(_p))->_nextp_ = (_fl_)->objlist; \
			(_fl_)->objlist = _p; \
			(_fl_)->free_cnt++; \
		} \
		else { \
			break; \
		} \
	} \
	RF_FREELIST_STAT_FREE_UPDATE(_fl_); \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl    = freelist
 * obj   = object to allocate
 * nextp = name of "next" pointer in obj
 * cast  = cast of obj assignment
 * init  = init obj func
 */
#define RF_FREELIST_GET_INIT(_fl_,_obj_,_nextp_,_cast_,_init_) { \
	void *_p; \
	int _i; \
	RF_LOCK_MUTEX((_fl_)->lock); \
	RF_ASSERT(sizeof(*(_obj_))==((_fl_)->obj_size)); \
	if (_fl_->objlist) { \
		_obj_ = _cast_((_fl_)->objlist); \
		(_fl_)->objlist = (void *)((_obj_)->_nextp_); \
		(_fl_)->free_cnt--; \
	} \
	else { \
		/* \
		 * Allocate one at a time so we can free \
		 * one at a time without cleverness when arena \
		 * is full. \
		 */ \
		RF_Calloc(_obj_,1,(_fl_)->obj_size,_cast_); \
		if (_obj_) { \
			if (_init_ (_obj_)) { \
				RF_Free(_obj_,(_fl_)->obj_size); \
				_obj_ = NULL; \
			} \
			else { \
				for(_i=1;_i<(_fl_)->obj_inc;_i++) { \
					RF_Calloc(_p,1,(_fl_)->obj_size,(void *)); \
					if (_p) { \
						if (_init_ (_p)) { \
							RF_Free(_p,(_fl_)->obj_size); \
							_p = NULL; \
							break; \
						} \
						(_cast_(_p))->_nextp_ = (_fl_)->objlist; \
						(_fl_)->objlist = _p; \
					} \
					else { \
						break; \
					} \
				} \
			} \
		} \
		RF_FREELIST_STAT_GROW(_fl_); \
	} \
	RF_FREELIST_STAT_ALLOC(_fl_); \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl    = freelist
 * obj   = object to allocate
 * nextp = name of "next" pointer in obj
 * cast  = cast of obj assignment
 * init  = init obj func
 * arg   = arg to init obj func
 */
#define RF_FREELIST_GET_INIT_ARG(_fl_,_obj_,_nextp_,_cast_,_init_,_arg_) { \
	void *_p; \
	int _i; \
	RF_LOCK_MUTEX((_fl_)->lock); \
	RF_ASSERT(sizeof(*(_obj_))==((_fl_)->obj_size)); \
	if (_fl_->objlist) { \
		_obj_ = _cast_((_fl_)->objlist); \
		(_fl_)->objlist = (void *)((_obj_)->_nextp_); \
		(_fl_)->free_cnt--; \
	} \
	else { \
		/* \
		 * Allocate one at a time so we can free \
		 * one at a time without cleverness when arena \
		 * is full. \
		 */ \
		RF_Calloc(_obj_,1,(_fl_)->obj_size,_cast_); \
		if (_obj_) { \
			if (_init_ (_obj_,_arg_)) { \
				RF_Free(_obj_,(_fl_)->obj_size); \
				_obj_ = NULL; \
			} \
			else { \
				for(_i=1;_i<(_fl_)->obj_inc;_i++) { \
					RF_Calloc(_p,1,(_fl_)->obj_size,(void *)); \
					if (_p) { \
						if (_init_ (_p,_arg_)) { \
							RF_Free(_p,(_fl_)->obj_size); \
							_p = NULL; \
							break; \
						} \
						(_cast_(_p))->_nextp_ = (_fl_)->objlist; \
						(_fl_)->objlist = _p; \
					} \
					else { \
						break; \
					} \
				} \
			} \
		} \
		RF_FREELIST_STAT_GROW(_fl_); \
	} \
	RF_FREELIST_STAT_ALLOC(_fl_); \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl    = freelist
 * obj   = object to allocate
 * nextp = name of "next" pointer in obj
 * cast  = cast of obj assignment
 * init  = init obj func
 */
#define RF_FREELIST_GET_INIT_NOUNLOCK(_fl_,_obj_,_nextp_,_cast_,_init_) { \
	void *_p; \
	int _i; \
	RF_LOCK_MUTEX((_fl_)->lock); \
	RF_ASSERT(sizeof(*(_obj_))==((_fl_)->obj_size)); \
	if (_fl_->objlist) { \
		_obj_ = _cast_((_fl_)->objlist); \
		(_fl_)->objlist = (void *)((_obj_)->_nextp_); \
		(_fl_)->free_cnt--; \
	} \
	else { \
		/* \
		 * Allocate one at a time so we can free \
		 * one at a time without cleverness when arena \
		 * is full. \
		 */ \
		RF_Calloc(_obj_,1,(_fl_)->obj_size,_cast_); \
		if (_obj_) { \
			if (_init_ (_obj_)) { \
				RF_Free(_obj_,(_fl_)->obj_size); \
				_obj_ = NULL; \
			} \
			else { \
				for(_i=1;_i<(_fl_)->obj_inc;_i++) { \
					RF_Calloc(_p,1,(_fl_)->obj_size,(void *)); \
					if (_p) { \
						if (_init_ (_p)) { \
							RF_Free(_p,(_fl_)->obj_size); \
							_p = NULL; \
							break; \
						} \
						(_cast_(_p))->_nextp_ = (_fl_)->objlist; \
						(_fl_)->objlist = _p; \
					} \
					else { \
						break; \
					} \
				} \
			} \
		} \
		RF_FREELIST_STAT_GROW(_fl_); \
	} \
	RF_FREELIST_STAT_ALLOC(_fl_); \
}

/*
 * fl    = freelist
 * obj   = object to allocate
 * nextp = name of "next" pointer in obj
 * cast  = cast of obj assignment
 */
#define RF_FREELIST_GET(_fl_,_obj_,_nextp_,_cast_) { \
	void *_p; \
	int _i; \
	RF_LOCK_MUTEX((_fl_)->lock); \
	RF_ASSERT(sizeof(*(_obj_))==((_fl_)->obj_size)); \
	if (_fl_->objlist) { \
		_obj_ = _cast_((_fl_)->objlist); \
		(_fl_)->objlist = (void *)((_obj_)->_nextp_); \
		(_fl_)->free_cnt--; \
	} \
	else { \
		/* \
		 * Allocate one at a time so we can free \
		 * one at a time without cleverness when arena \
		 * is full. \
		 */ \
		RF_Calloc(_obj_,1,(_fl_)->obj_size,_cast_); \
		if (_obj_) { \
			for(_i=1;_i<(_fl_)->obj_inc;_i++) { \
				RF_Calloc(_p,1,(_fl_)->obj_size,(void *)); \
				if (_p) { \
					(_cast_(_p))->_nextp_ = (_fl_)->objlist; \
					(_fl_)->objlist = _p; \
				} \
				else { \
					break; \
				} \
			} \
		} \
		RF_FREELIST_STAT_GROW(_fl_); \
	} \
	RF_FREELIST_STAT_ALLOC(_fl_); \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl    = freelist
 * obj   = object to allocate
 * nextp = name of "next" pointer in obj
 * cast  = cast of obj assignment
 * num   = num objs to return
 */
#define RF_FREELIST_GET_N(_fl_,_obj_,_nextp_,_cast_,_num_) { \
	void *_p, *_l, *_f; \
	int _i, _n; \
	_l = _f = NULL; \
	_n = 0; \
	RF_LOCK_MUTEX((_fl_)->lock); \
	RF_ASSERT(sizeof(*(_obj_))==((_fl_)->obj_size)); \
	for(_n=0;_n<_num_;_n++) { \
		if (_fl_->objlist) { \
			_obj_ = _cast_((_fl_)->objlist); \
			(_fl_)->objlist = (void *)((_obj_)->_nextp_); \
			(_fl_)->free_cnt--; \
		} \
		else { \
			/* \
			 * Allocate one at a time so we can free \
			 * one at a time without cleverness when arena \
			 * is full. \
			 */ \
			RF_Calloc(_obj_,1,(_fl_)->obj_size,_cast_); \
			if (_obj_) { \
				for(_i=1;_i<(_fl_)->obj_inc;_i++) { \
					RF_Calloc(_p,1,(_fl_)->obj_size,(void *)); \
					if (_p) { \
						(_cast_(_p))->_nextp_ = (_fl_)->objlist; \
						(_fl_)->objlist = _p; \
					} \
					else { \
						break; \
					} \
				} \
			} \
			RF_FREELIST_STAT_GROW(_fl_); \
		} \
		if (_f == NULL) \
			_f = _obj_; \
		if (_obj_) { \
			(_cast_(_obj_))->_nextp_ = _l; \
			_l = _obj_; \
			RF_FREELIST_STAT_ALLOC(_fl_); \
		} \
		else { \
			(_cast_(_f))->_nextp_ = (_fl_)->objlist; \
			(_fl_)->objlist = _l; \
			_n = _num_; \
		} \
	} \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl = freelist
 * obj   = object to free
 * nextp = name of "next" pointer in obj
 */
#define RF_FREELIST_FREE(_fl_,_obj_,_nextp_) { \
	RF_LOCK_MUTEX((_fl_)->lock); \
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) { \
		RF_Free(_obj_,(_fl_)->obj_size); \
	} \
	else { \
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt); \
		(_obj_)->_nextp_ = (_fl_)->objlist; \
		(_fl_)->objlist = (void *)(_obj_); \
		(_fl_)->free_cnt++; \
	} \
	RF_FREELIST_STAT_FREE(_fl_); \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl    = freelist
 * obj   = object to free
 * nextp = name of "next" pointer in obj
 * num   = num to free (debugging)
 */
#define RF_FREELIST_FREE_N(_fl_,_obj_,_nextp_,_cast_,_num_) { \
	void *_no; \
	int _n; \
	_n = 0; \
	RF_LOCK_MUTEX((_fl_)->lock); \
	while(_obj_) { \
		_no = (_cast_(_obj_))->_nextp_; \
		if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) { \
			RF_Free(_obj_,(_fl_)->obj_size); \
		} \
		else { \
			RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt); \
			(_obj_)->_nextp_ = (_fl_)->objlist; \
			(_fl_)->objlist = (void *)(_obj_); \
			(_fl_)->free_cnt++; \
		} \
		_n++; \
		_obj_ = _no; \
		RF_FREELIST_STAT_FREE(_fl_); \
	} \
	RF_ASSERT(_n==(_num_)); \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl    = freelist
 * obj   = object to free
 * nextp = name of "next" pointer in obj
 * clean = undo for init
 */
#define RF_FREELIST_FREE_CLEAN(_fl_,_obj_,_nextp_,_clean_) { \
	RF_LOCK_MUTEX((_fl_)->lock); \
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) { \
		_clean_ (_obj_); \
		RF_Free(_obj_,(_fl_)->obj_size); \
	} \
	else { \
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt); \
		(_obj_)->_nextp_ = (_fl_)->objlist; \
		(_fl_)->objlist = (void *)(_obj_); \
		(_fl_)->free_cnt++; \
	} \
	RF_FREELIST_STAT_FREE(_fl_); \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl    = freelist
 * obj   = object to free
 * nextp = name of "next" pointer in obj
 * clean = undo for init
 * arg   = arg for undo func
 */
#define RF_FREELIST_FREE_CLEAN_ARG(_fl_,_obj_,_nextp_,_clean_,_arg_) { \
	RF_LOCK_MUTEX((_fl_)->lock); \
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) { \
		_clean_ (_obj_,_arg_); \
		RF_Free(_obj_,(_fl_)->obj_size); \
	} \
	else { \
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt); \
		(_obj_)->_nextp_ = (_fl_)->objlist; \
		(_fl_)->objlist = (void *)(_obj_); \
		(_fl_)->free_cnt++; \
	} \
	RF_FREELIST_STAT_FREE(_fl_); \
	RF_UNLOCK_MUTEX((_fl_)->lock); \
}

/*
 * fl    = freelist
 * obj   = object to free
 * nextp = name of "next" pointer in obj
 * clean = undo for init
 */
#define RF_FREELIST_FREE_CLEAN_NOUNLOCK(_fl_,_obj_,_nextp_,_clean_) { \
	RF_LOCK_MUTEX((_fl_)->lock); \
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) { \
		_clean_ (_obj_); \
		RF_Free(_obj_,(_fl_)->obj_size); \
	} \
	else { \
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt); \
		(_obj_)->_nextp_ = (_fl_)->objlist; \
		(_fl_)->objlist = (void *)(_obj_); \
		(_fl_)->free_cnt++; \
	} \
	RF_FREELIST_STAT_FREE(_fl_); \
}

/*
 * fl     = freelist
 * nextp = name of "next" pointer in obj
 * cast  = cast to object type
 */
#define RF_FREELIST_DESTROY(_fl_,_nextp_,_cast_) { \
	void *_cur, *_next; \
	RF_FREELIST_STAT_REPORT(_fl_); \
	rf_mutex_destroy(&((_fl_)->lock)); \
	for(_cur=(_fl_)->objlist;_cur;_cur=_next) { \
		_next = (_cast_ _cur)->_nextp_; \
		RF_Free(_cur,(_fl_)->obj_size); \
	} \
	RF_Free(_fl_,sizeof(RF_FreeList_t)); \
}

/*
 * fl    = freelist
 * nextp = name of "next" pointer in obj
 * cast  = cast to object type
 * clean = func to undo obj init
 */
#define RF_FREELIST_DESTROY_CLEAN(_fl_,_nextp_,_cast_,_clean_) { \
	void *_cur, *_next; \
	RF_FREELIST_STAT_REPORT(_fl_); \
	rf_mutex_destroy(&((_fl_)->lock)); \
	for(_cur=(_fl_)->objlist;_cur;_cur=_next) { \
		_next = (_cast_ _cur)->_nextp_; \
		_clean_ (_cur); \
		RF_Free(_cur,(_fl_)->obj_size); \
	} \
	RF_Free(_fl_,sizeof(RF_FreeList_t)); \
}

/*
 * fl    = freelist
 * nextp = name of "next" pointer in obj
 * cast  = cast to object type
 * clean = func to undo obj init
 * arg   = arg for undo func
 */
#define RF_FREELIST_DESTROY_CLEAN_ARG(_fl_,_nextp_,_cast_,_clean_,_arg_) { \
	void *_cur, *_next; \
	RF_FREELIST_STAT_REPORT(_fl_); \
	rf_mutex_destroy(&((_fl_)->lock)); \
	for(_cur=(_fl_)->objlist;_cur;_cur=_next) { \
		_next = (_cast_ _cur)->_nextp_; \
		_clean_ (_cur,_arg_); \
		RF_Free(_cur,(_fl_)->obj_size); \
	} \
	RF_Free(_fl_,sizeof(RF_FreeList_t)); \
}
d716 1
a716 1
#endif				/* !_RF__RF_FREELIST_H_ */
@


1.2.16.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d34 1
a34 1
 * rf_freelist.h -- Code to manage counted freelists.
d42 2
a43 2
#ifndef	_RF__RF_FREELIST_H_
#define	_RF__RF_FREELIST_H_
d50 1
a50 1
#define	RF_FREELIST_STATS	0
d52 1
a52 1
#if	RF_FREELIST_STATS > 0
d54 55
a108 66
	char	*file;
	int	 line;
	int	 allocations;
	int	 frees;
	int	 max_free;
	int	 grows;
	int	 outstanding;
	int	 max_outstanding;
} RF_FreeListStats_t;

#define	RF_FREELIST_STAT_INIT(_fl_)					\
do {									\
	bzero((char *)&((_fl_)->stats), sizeof(RF_FreeListStats_t));	\
	(_fl_)->stats.file = __FILE__;					\
	(_fl_)->stats.line = __LINE__;					\
} while (0)

#define	RF_FREELIST_STAT_ALLOC(_fl_)					\
do {									\
	(_fl_)->stats.allocations++;					\
	(_fl_)->stats.outstanding++;					\
	if ((_fl_)->stats.outstanding > (_fl_)->stats.max_outstanding)	\
		(_fl_)->stats.max_outstanding =				\
		    (_fl_)->stats.outstanding;				\
} while (0)

#define	RF_FREELIST_STAT_FREE_UPDATE(_fl_)				\
do {									\
	if ((_fl_)->free_cnt > (_fl_)->stats.max_free)			\
		(_fl_)->stats.max_free = (_fl_)->free_cnt;		\
} while (0)

#define	RF_FREELIST_STAT_FREE(_fl_)					\
do {									\
	(_fl_)->stats.frees++;						\
	(_fl_)->stats.outstanding--;					\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
} while (0)

#define	RF_FREELIST_STAT_GROW(_fl_)					\
do {									\
	(_fl_)->stats.grows++;						\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
} while (0)

#define	RF_FREELIST_STAT_REPORT(_fl_)					\
do {									\
	printf("Freelist at %s %d (%s)\n", (_fl_)->stats.file,		\
	    (_fl_)->stats.line, RF_STRING(_fl_));			\
	printf("  %d allocations, %d frees\n",				\
	    (_fl_)->stats.allocations, (_fl_)->stats.frees);		\
	printf("  %d grows\n", (_fl_)->stats.grows);			\
	printf("  %d outstanding\n", (_fl_)->stats.outstanding);	\
	printf("  %d free (max)\n", (_fl_)->stats.max_free);		\
	printf("  %d outstanding (max)\n",				\
	    (_fl_)->stats.max_outstanding);				\
} while (0)

#else	/* RF_FREELIST_STATS > 0 */

#define	RF_FREELIST_STAT_INIT(_fl_)
#define	RF_FREELIST_STAT_ALLOC(_fl_)
#define	RF_FREELIST_STAT_FREE_UPDATE(_fl_)
#define	RF_FREELIST_STAT_FREE(_fl_)
#define	RF_FREELIST_STAT_GROW(_fl_)
#define	RF_FREELIST_STAT_REPORT(_fl_)
d110 1
a110 1
#endif	/* RF_FREELIST_STATS > 0 */
d113 9
a121 9
	void	*objlist;	/* List of free obj. */
	int	 free_cnt;	/* How many free obj. */
	int	 max_free_cnt;	/* Max free arena size. */
	int	 obj_inc;	/* How many to allocate at a time. */
	int	 obj_size;	/* Size of objects. */
	RF_DECLARE_MUTEX(lock);
#if	RF_FREELIST_STATS > 0
	RF_FreeListStats_t stats;	/* Statistics. */
#endif	/* RF_FREELIST_STATS > 0 */
a122 1

d124 543
a666 578
 * fl	  = FreeList.
 * maxcnt = Max number of items in arena.
 * inc	  = How many to allocate at a time.
 * size	  = Size of object.
 */
#define	RF_FREELIST_CREATE(_fl_,_maxcnt_,_inc_,_size_)			\
do {									\
	int rc;								\
	RF_ASSERT((_inc_) > 0);						\
	RF_Malloc(_fl_, sizeof(RF_FreeList_t), (RF_FreeList_t *));	\
	(_fl_)->objlist = NULL;						\
	(_fl_)->free_cnt = 0;						\
	(_fl_)->max_free_cnt = _maxcnt_;				\
	(_fl_)->obj_inc = _inc_;					\
	(_fl_)->obj_size = _size_;					\
	rc = rf_mutex_init(&(_fl_)->lock);				\
	if (rc) {							\
		RF_Free(_fl_, sizeof(RF_FreeList_t));			\
		_fl_ = NULL;						\
	}								\
	RF_FREELIST_STAT_INIT(_fl_);					\
} while (0)

/*
 * fl	 = FreeList.
 * cnt	 = Number to prime with.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Object cast.
 */
#define	RF_FREELIST_PRIME(_fl_,_cnt_,_nextp_,_cast_)			\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	for (_i = 0; _i < (_cnt_); _i++) {				\
		RF_Calloc(_p, 1, (_fl_)->obj_size, (void *));		\
		if (_p) {						\
			(_cast_(_p))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _p;				\
			(_fl_)->free_cnt++;				\
		}							\
		else {							\
			break;						\
		}							\
	}								\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

#define	RF_FREELIST_MUTEX_OF(_fl_)	((_fl_)->lock)

#define	RF_FREELIST_DO_UNLOCK(_fl_)	RF_UNLOCK_MUTEX((_fl_)->lock)

#define	RF_FREELIST_DO_LOCK(_fl_)	RF_LOCK_MUTEX((_fl_)->lock)

/*
 * fl	 = FreeList.
 * cnt	 = Number to prime with.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Object cast.
 * init	 = Func to call to init obj.
 */
#define	RF_FREELIST_PRIME_INIT(_fl_,_cnt_,_nextp_,_cast_,_init_)	\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	for (_i = 0; _i < (_cnt_); _i++) {				\
		RF_Calloc(_p, 1, (_fl_)->obj_size, (void *));		\
		if (_init_(_cast_ _p)) {				\
			RF_Free(_p, (_fl_)->obj_size);			\
			_p = NULL;					\
		}							\
		if (_p) {						\
			(_cast_(_p))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _p;				\
			(_fl_)->free_cnt++;				\
		}							\
		else {							\
			break;						\
		}							\
	}								\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * cnt	 = Number to prime with.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Object cast.
 * init	 = Func to call to init obj.
 * arg	 = Arg to init obj func.
 */
#define	RF_FREELIST_PRIME_INIT_ARG(_fl_,_cnt_,_nextp_,_cast_,_init_,_arg_) \
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	for (_i = 0; _i < (_cnt_); _i++) {				\
		RF_Calloc(_p, 1, (_fl_)->obj_size, (void *));		\
		if (_init_(_cast_ _p, _arg_)) {				\
			RF_Free(_p, (_fl_)->obj_size);			\
			_p = NULL;					\
		}							\
		if (_p) {						\
			(_cast_(_p))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _p;				\
			(_fl_)->free_cnt++;				\
		}							\
		else {							\
			break;						\
		}							\
	}								\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * init	 = Init obj func.
 */
#define	RF_FREELIST_GET_INIT(_fl_,_obj_,_nextp_,_cast_,_init_)		\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			if (_init_(_obj_)) {				\
				RF_Free(_obj_, (_fl_)->obj_size);	\
				_obj_ = NULL;				\
			}						\
			else {						\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					    (_fl_)->obj_size,		\
					    (void *));			\
					if (_p) {			\
						if (_init_(_p)) {	\
							RF_Free(_p,	\
						  (_fl_)->obj_size);	\
							_p = NULL;	\
							break;		\
						}			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
		} 							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * init	 = Init obj func.
 * arg	 = Arg to init obj func.
 */
#define	RF_FREELIST_GET_INIT_ARG(_fl_,_obj_,_nextp_,_cast_,_init_,_arg_) \
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			if (_init_(_obj_, _arg_)) {			\
				RF_Free(_obj_, (_fl_)->obj_size);	\
				_obj_ = NULL;				\
			}						\
			else {						\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					   (_fl_)->obj_size, (void *));	\
					if (_p) {			\
						if (_init_(_p, _arg_))	\
						{			\
							RF_Free(_p,	\
						    (_fl_)->obj_size);	\
							_p = NULL;	\
							break;		\
						}			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
		}							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * init	 = Init obj func.
 */
#define	RF_FREELIST_GET_INIT_NOUNLOCK(_fl_,_obj_,_nextp_,_cast_,_init_)	\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			if (_init_(_obj_)) {				\
				RF_Free(_obj_, (_fl_)->obj_size);	\
				_obj_ = NULL;				\
			}						\
			else {						\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					    (_fl_)->obj_size,		\
					    (void *));			\
					if (_p) {			\
						if (_init_(_p)) {	\
							RF_Free(_p,	\
						    (_fl_)->obj_size);	\
							_p = NULL;	\
							break;		\
						}			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
		}							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 */
#define	RF_FREELIST_GET(_fl_,_obj_,_nextp_,_cast_)			\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			for (_i = 1; _i < (_fl_)->obj_inc; _i++) {	\
				RF_Calloc(_p, 1, (_fl_)->obj_size,	\
				    (void *));				\
				if (_p) {				\
					(_cast_(_p))->_nextp_ =		\
					    (_fl_)->objlist;		\
					(_fl_)->objlist = _p;		\
				}					\
				else {					\
					break;				\
				}					\
			}						\
		}							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * num	 = Num objs to return.
 */
#define	RF_FREELIST_GET_N(_fl_,_obj_,_nextp_,_cast_,_num_)		\
do {									\
	void *_p, *_l, *_f;						\
	int _i, _n;							\
	_l = _f = NULL;							\
	_n = 0;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	for (_n = 0; _n < _num_; _n++) {				\
		if (_fl_->objlist) {					\
			_obj_ = _cast_((_fl_)->objlist);		\
			(_fl_)->objlist = (void *)((_obj_)->_nextp_);	\
			(_fl_)->free_cnt--;				\
		}							\
		else {							\
			/*						\
			 * Allocate one at a time so we can free	\
			 * one at a time without cleverness when arena	\
			 * is full.					\
			 */						\
			RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);	\
			if (_obj_) {					\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					    (_fl_)->obj_size,		\
					    (void *));			\
					if (_p) {			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
			RF_FREELIST_STAT_GROW(_fl_);			\
		}							\
		if (_f == NULL)						\
			_f = _obj_;					\
		if (_obj_) {						\
			(_cast_(_obj_))->_nextp_ = _l;			\
			_l = _obj_;					\
			RF_FREELIST_STAT_ALLOC(_fl_);			\
		}							\
		else {							\
			(_cast_(_f))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _l;				\
			_n = _num_;					\
		}							\
	}								\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 */
#define	RF_FREELIST_FREE(_fl_,_obj_,_nextp_)				\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * num	 = Num to free (debugging).
 */
#define	RF_FREELIST_FREE_N(_fl_,_obj_,_nextp_,_cast_,_num_)		\
do {									\
	void *_no;							\
	int _n;								\
	_n = 0;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	while(_obj_) {							\
		_no = (_cast_(_obj_))->_nextp_;				\
		if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {		\
			RF_Free(_obj_, (_fl_)->obj_size);		\
		}							\
		else {							\
			RF_ASSERT((_fl_)->free_cnt <			\
			    (_fl_)->max_free_cnt);			\
			(_obj_)->_nextp_ = (_fl_)->objlist;		\
			(_fl_)->objlist = (void *)(_obj_);		\
			(_fl_)->free_cnt++;				\
		}							\
		_n++;							\
		_obj_ = _no;						\
		RF_FREELIST_STAT_FREE(_fl_);				\
	}								\
	RF_ASSERT(_n==(_num_));						\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * clean = Undo for init.
 */
#define	RF_FREELIST_FREE_CLEAN(_fl_,_obj_,_nextp_,_clean_)		\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		_clean_(_obj_);					\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * clean = Undo for init.
 * arg	 = Arg for undo func.
 */
#define	RF_FREELIST_FREE_CLEAN_ARG(_fl_,_obj_,_nextp_,_clean_,_arg_)	\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		_clean_(_obj_, _arg_);					\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * clean = Undo for init.
 */
#define	RF_FREELIST_FREE_CLEAN_NOUNLOCK(_fl_,_obj_,_nextp_,_clean_)	\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		_clean_(_obj_);					\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
} while (0)

/*
 * fl	 = FreeList.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast to object type.
 */
#define	RF_FREELIST_DESTROY(_fl_,_nextp_,_cast_)			\
do {									\
	void *_cur, *_next;						\
	RF_FREELIST_STAT_REPORT(_fl_);					\
	rf_mutex_destroy(&((_fl_)->lock));				\
	for (_cur = (_fl_)->objlist; _cur; _cur = _next) {		\
		_next = (_cast_ _cur)->_nextp_;				\
		RF_Free(_cur, (_fl_)->obj_size);			\
	}								\
	RF_Free(_fl_, sizeof(RF_FreeList_t));				\
} while (0)

/*
 * fl	 = FreeList.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast to object type.
 * clean = Func to undo obj init.
 */
#define	RF_FREELIST_DESTROY_CLEAN(_fl_,_nextp_,_cast_,_clean_)		\
do {									\
	void *_cur, *_next;						\
	RF_FREELIST_STAT_REPORT(_fl_);					\
	rf_mutex_destroy(&((_fl_)->lock));				\
	for (_cur = (_fl_)->objlist; _cur; _cur = _next) {		\
		_next = (_cast_ _cur)->_nextp_;				\
		_clean_(_cur);						\
		RF_Free(_cur, (_fl_)->obj_size);			\
	}								\
	RF_Free(_fl_, sizeof(RF_FreeList_t));				\
} while (0)

/*
 * fl	 = FreeList.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast to object type.
 * clean = Func to undo obj init.
 * arg	 = Arg for undo func.
 */
#define	RF_FREELIST_DESTROY_CLEAN_ARG(_fl_,_nextp_,_cast_,_clean_,_arg_) \
do {									\
	void *_cur, *_next;						\
	RF_FREELIST_STAT_REPORT(_fl_);					\
	rf_mutex_destroy(&((_fl_)->lock));				\
	for (_cur = (_fl_)->objlist; _cur; _cur = _next) {		\
		_next = (_cast_ _cur)->_nextp_;				\
		_clean_(_cur, _arg_);					\
		RF_Free(_cur, (_fl_)->obj_size);			\
	}								\
	RF_Free(_fl_, sizeof(RF_FreeList_t));				\
} while (0)
d668 1
a668 1
#endif	/* !_RF__RF_FREELIST_H_ */
@


1.2.6.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d34 1
a34 1
 * rf_freelist.h -- Code to manage counted freelists.
d42 2
a43 2
#ifndef	_RF__RF_FREELIST_H_
#define	_RF__RF_FREELIST_H_
d50 1
a50 1
#define	RF_FREELIST_STATS	0
d52 1
a52 1
#if	RF_FREELIST_STATS > 0
d54 55
a108 66
	char	*file;
	int	 line;
	int	 allocations;
	int	 frees;
	int	 max_free;
	int	 grows;
	int	 outstanding;
	int	 max_outstanding;
} RF_FreeListStats_t;

#define	RF_FREELIST_STAT_INIT(_fl_)					\
do {									\
	bzero((char *)&((_fl_)->stats), sizeof(RF_FreeListStats_t));	\
	(_fl_)->stats.file = __FILE__;					\
	(_fl_)->stats.line = __LINE__;					\
} while (0)

#define	RF_FREELIST_STAT_ALLOC(_fl_)					\
do {									\
	(_fl_)->stats.allocations++;					\
	(_fl_)->stats.outstanding++;					\
	if ((_fl_)->stats.outstanding > (_fl_)->stats.max_outstanding)	\
		(_fl_)->stats.max_outstanding =				\
		    (_fl_)->stats.outstanding;				\
} while (0)

#define	RF_FREELIST_STAT_FREE_UPDATE(_fl_)				\
do {									\
	if ((_fl_)->free_cnt > (_fl_)->stats.max_free)			\
		(_fl_)->stats.max_free = (_fl_)->free_cnt;		\
} while (0)

#define	RF_FREELIST_STAT_FREE(_fl_)					\
do {									\
	(_fl_)->stats.frees++;						\
	(_fl_)->stats.outstanding--;					\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
} while (0)

#define	RF_FREELIST_STAT_GROW(_fl_)					\
do {									\
	(_fl_)->stats.grows++;						\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
} while (0)

#define	RF_FREELIST_STAT_REPORT(_fl_)					\
do {									\
	printf("Freelist at %s %d (%s)\n", (_fl_)->stats.file,		\
	    (_fl_)->stats.line, RF_STRING(_fl_));			\
	printf("  %d allocations, %d frees\n",				\
	    (_fl_)->stats.allocations, (_fl_)->stats.frees);		\
	printf("  %d grows\n", (_fl_)->stats.grows);			\
	printf("  %d outstanding\n", (_fl_)->stats.outstanding);	\
	printf("  %d free (max)\n", (_fl_)->stats.max_free);		\
	printf("  %d outstanding (max)\n",				\
	    (_fl_)->stats.max_outstanding);				\
} while (0)

#else	/* RF_FREELIST_STATS > 0 */

#define	RF_FREELIST_STAT_INIT(_fl_)
#define	RF_FREELIST_STAT_ALLOC(_fl_)
#define	RF_FREELIST_STAT_FREE_UPDATE(_fl_)
#define	RF_FREELIST_STAT_FREE(_fl_)
#define	RF_FREELIST_STAT_GROW(_fl_)
#define	RF_FREELIST_STAT_REPORT(_fl_)
d110 1
a110 1
#endif	/* RF_FREELIST_STATS > 0 */
d113 9
a121 9
	void	*objlist;	/* List of free obj. */
	int	 free_cnt;	/* How many free obj. */
	int	 max_free_cnt;	/* Max free arena size. */
	int	 obj_inc;	/* How many to allocate at a time. */
	int	 obj_size;	/* Size of objects. */
	RF_DECLARE_MUTEX(lock);
#if	RF_FREELIST_STATS > 0
	RF_FreeListStats_t stats;	/* Statistics. */
#endif	/* RF_FREELIST_STATS > 0 */
a122 1

d124 543
a666 578
 * fl	  = FreeList.
 * maxcnt = Max number of items in arena.
 * inc	  = How many to allocate at a time.
 * size	  = Size of object.
 */
#define	RF_FREELIST_CREATE(_fl_,_maxcnt_,_inc_,_size_)			\
do {									\
	int rc;								\
	RF_ASSERT((_inc_) > 0);						\
	RF_Malloc(_fl_, sizeof(RF_FreeList_t), (RF_FreeList_t *));	\
	(_fl_)->objlist = NULL;						\
	(_fl_)->free_cnt = 0;						\
	(_fl_)->max_free_cnt = _maxcnt_;				\
	(_fl_)->obj_inc = _inc_;					\
	(_fl_)->obj_size = _size_;					\
	rc = rf_mutex_init(&(_fl_)->lock);				\
	if (rc) {							\
		RF_Free(_fl_, sizeof(RF_FreeList_t));			\
		_fl_ = NULL;						\
	}								\
	RF_FREELIST_STAT_INIT(_fl_);					\
} while (0)

/*
 * fl	 = FreeList.
 * cnt	 = Number to prime with.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Object cast.
 */
#define	RF_FREELIST_PRIME(_fl_,_cnt_,_nextp_,_cast_)			\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	for (_i = 0; _i < (_cnt_); _i++) {				\
		RF_Calloc(_p, 1, (_fl_)->obj_size, (void *));		\
		if (_p) {						\
			(_cast_(_p))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _p;				\
			(_fl_)->free_cnt++;				\
		}							\
		else {							\
			break;						\
		}							\
	}								\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

#define	RF_FREELIST_MUTEX_OF(_fl_)	((_fl_)->lock)

#define	RF_FREELIST_DO_UNLOCK(_fl_)	RF_UNLOCK_MUTEX((_fl_)->lock)

#define	RF_FREELIST_DO_LOCK(_fl_)	RF_LOCK_MUTEX((_fl_)->lock)

/*
 * fl	 = FreeList.
 * cnt	 = Number to prime with.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Object cast.
 * init	 = Func to call to init obj.
 */
#define	RF_FREELIST_PRIME_INIT(_fl_,_cnt_,_nextp_,_cast_,_init_)	\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	for (_i = 0; _i < (_cnt_); _i++) {				\
		RF_Calloc(_p, 1, (_fl_)->obj_size, (void *));		\
		if (_init_(_cast_ _p)) {				\
			RF_Free(_p, (_fl_)->obj_size);			\
			_p = NULL;					\
		}							\
		if (_p) {						\
			(_cast_(_p))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _p;				\
			(_fl_)->free_cnt++;				\
		}							\
		else {							\
			break;						\
		}							\
	}								\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * cnt	 = Number to prime with.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Object cast.
 * init	 = Func to call to init obj.
 * arg	 = Arg to init obj func.
 */
#define	RF_FREELIST_PRIME_INIT_ARG(_fl_,_cnt_,_nextp_,_cast_,_init_,_arg_) \
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	for (_i = 0; _i < (_cnt_); _i++) {				\
		RF_Calloc(_p, 1, (_fl_)->obj_size, (void *));		\
		if (_init_(_cast_ _p, _arg_)) {				\
			RF_Free(_p, (_fl_)->obj_size);			\
			_p = NULL;					\
		}							\
		if (_p) {						\
			(_cast_(_p))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _p;				\
			(_fl_)->free_cnt++;				\
		}							\
		else {							\
			break;						\
		}							\
	}								\
	RF_FREELIST_STAT_FREE_UPDATE(_fl_);				\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * init	 = Init obj func.
 */
#define	RF_FREELIST_GET_INIT(_fl_,_obj_,_nextp_,_cast_,_init_)		\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			if (_init_(_obj_)) {				\
				RF_Free(_obj_, (_fl_)->obj_size);	\
				_obj_ = NULL;				\
			}						\
			else {						\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					    (_fl_)->obj_size,		\
					    (void *));			\
					if (_p) {			\
						if (_init_(_p)) {	\
							RF_Free(_p,	\
						  (_fl_)->obj_size);	\
							_p = NULL;	\
							break;		\
						}			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
		} 							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * init	 = Init obj func.
 * arg	 = Arg to init obj func.
 */
#define	RF_FREELIST_GET_INIT_ARG(_fl_,_obj_,_nextp_,_cast_,_init_,_arg_) \
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			if (_init_(_obj_, _arg_)) {			\
				RF_Free(_obj_, (_fl_)->obj_size);	\
				_obj_ = NULL;				\
			}						\
			else {						\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					   (_fl_)->obj_size, (void *));	\
					if (_p) {			\
						if (_init_(_p, _arg_))	\
						{			\
							RF_Free(_p,	\
						    (_fl_)->obj_size);	\
							_p = NULL;	\
							break;		\
						}			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
		}							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * init	 = Init obj func.
 */
#define	RF_FREELIST_GET_INIT_NOUNLOCK(_fl_,_obj_,_nextp_,_cast_,_init_)	\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			if (_init_(_obj_)) {				\
				RF_Free(_obj_, (_fl_)->obj_size);	\
				_obj_ = NULL;				\
			}						\
			else {						\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					    (_fl_)->obj_size,		\
					    (void *));			\
					if (_p) {			\
						if (_init_(_p)) {	\
							RF_Free(_p,	\
						    (_fl_)->obj_size);	\
							_p = NULL;	\
							break;		\
						}			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
		}							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 */
#define	RF_FREELIST_GET(_fl_,_obj_,_nextp_,_cast_)			\
do {									\
	void *_p;							\
	int _i;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	if (_fl_->objlist) {						\
		_obj_ = _cast_((_fl_)->objlist);			\
		(_fl_)->objlist = (void *)((_obj_)->_nextp_);		\
		(_fl_)->free_cnt--;					\
	}								\
	else {								\
		/*							\
		 * Allocate one at a time so we can free		\
		 * one at a time without cleverness when arena		\
		 * is full.						\
		 */							\
		RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);		\
		if (_obj_) {						\
			for (_i = 1; _i < (_fl_)->obj_inc; _i++) {	\
				RF_Calloc(_p, 1, (_fl_)->obj_size,	\
				    (void *));				\
				if (_p) {				\
					(_cast_(_p))->_nextp_ =		\
					    (_fl_)->objlist;		\
					(_fl_)->objlist = _p;		\
				}					\
				else {					\
					break;				\
				}					\
			}						\
		}							\
		RF_FREELIST_STAT_GROW(_fl_);				\
	}								\
	RF_FREELIST_STAT_ALLOC(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to allocate.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast of obj assignment.
 * num	 = Num objs to return.
 */
#define	RF_FREELIST_GET_N(_fl_,_obj_,_nextp_,_cast_,_num_)		\
do {									\
	void *_p, *_l, *_f;						\
	int _i, _n;							\
	_l = _f = NULL;							\
	_n = 0;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	RF_ASSERT(sizeof(*(_obj_)) == ((_fl_)->obj_size));		\
	for (_n = 0; _n < _num_; _n++) {				\
		if (_fl_->objlist) {					\
			_obj_ = _cast_((_fl_)->objlist);		\
			(_fl_)->objlist = (void *)((_obj_)->_nextp_);	\
			(_fl_)->free_cnt--;				\
		}							\
		else {							\
			/*						\
			 * Allocate one at a time so we can free	\
			 * one at a time without cleverness when arena	\
			 * is full.					\
			 */						\
			RF_Calloc(_obj_, 1, (_fl_)->obj_size, _cast_);	\
			if (_obj_) {					\
				for (_i = 1; _i < (_fl_)->obj_inc;	\
				     _i++) {				\
					RF_Calloc(_p, 1,		\
					    (_fl_)->obj_size,		\
					    (void *));			\
					if (_p) {			\
						(_cast_(_p))->_nextp_ =	\
						    (_fl_)->objlist;	\
						(_fl_)->objlist = _p;	\
					}				\
					else {				\
						break;			\
					}				\
				}					\
			}						\
			RF_FREELIST_STAT_GROW(_fl_);			\
		}							\
		if (_f == NULL)						\
			_f = _obj_;					\
		if (_obj_) {						\
			(_cast_(_obj_))->_nextp_ = _l;			\
			_l = _obj_;					\
			RF_FREELIST_STAT_ALLOC(_fl_);			\
		}							\
		else {							\
			(_cast_(_f))->_nextp_ = (_fl_)->objlist;	\
			(_fl_)->objlist = _l;				\
			_n = _num_;					\
		}							\
	}								\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 */
#define	RF_FREELIST_FREE(_fl_,_obj_,_nextp_)				\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * num	 = Num to free (debugging).
 */
#define	RF_FREELIST_FREE_N(_fl_,_obj_,_nextp_,_cast_,_num_)		\
do {									\
	void *_no;							\
	int _n;								\
	_n = 0;								\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	while(_obj_) {							\
		_no = (_cast_(_obj_))->_nextp_;				\
		if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {		\
			RF_Free(_obj_, (_fl_)->obj_size);		\
		}							\
		else {							\
			RF_ASSERT((_fl_)->free_cnt <			\
			    (_fl_)->max_free_cnt);			\
			(_obj_)->_nextp_ = (_fl_)->objlist;		\
			(_fl_)->objlist = (void *)(_obj_);		\
			(_fl_)->free_cnt++;				\
		}							\
		_n++;							\
		_obj_ = _no;						\
		RF_FREELIST_STAT_FREE(_fl_);				\
	}								\
	RF_ASSERT(_n==(_num_));						\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * clean = Undo for init.
 */
#define	RF_FREELIST_FREE_CLEAN(_fl_,_obj_,_nextp_,_clean_)		\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		_clean_(_obj_);					\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * clean = Undo for init.
 * arg	 = Arg for undo func.
 */
#define	RF_FREELIST_FREE_CLEAN_ARG(_fl_,_obj_,_nextp_,_clean_,_arg_)	\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		_clean_(_obj_, _arg_);					\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
	RF_UNLOCK_MUTEX((_fl_)->lock);					\
} while (0)

/*
 * fl	 = FreeList.
 * obj	 = Object to free.
 * nextp = Name of "next" pointer in obj.
 * clean = Undo for init.
 */
#define	RF_FREELIST_FREE_CLEAN_NOUNLOCK(_fl_,_obj_,_nextp_,_clean_)	\
do {									\
	RF_LOCK_MUTEX((_fl_)->lock);					\
	if ((_fl_)->free_cnt == (_fl_)->max_free_cnt) {			\
		_clean_(_obj_);					\
		RF_Free(_obj_, (_fl_)->obj_size);			\
	}								\
	else {								\
		RF_ASSERT((_fl_)->free_cnt < (_fl_)->max_free_cnt);	\
		(_obj_)->_nextp_ = (_fl_)->objlist;			\
		(_fl_)->objlist = (void *)(_obj_);			\
		(_fl_)->free_cnt++;					\
	}								\
	RF_FREELIST_STAT_FREE(_fl_);					\
} while (0)

/*
 * fl	 = FreeList.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast to object type.
 */
#define	RF_FREELIST_DESTROY(_fl_,_nextp_,_cast_)			\
do {									\
	void *_cur, *_next;						\
	RF_FREELIST_STAT_REPORT(_fl_);					\
	rf_mutex_destroy(&((_fl_)->lock));				\
	for (_cur = (_fl_)->objlist; _cur; _cur = _next) {		\
		_next = (_cast_ _cur)->_nextp_;				\
		RF_Free(_cur, (_fl_)->obj_size);			\
	}								\
	RF_Free(_fl_, sizeof(RF_FreeList_t));				\
} while (0)

/*
 * fl	 = FreeList.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast to object type.
 * clean = Func to undo obj init.
 */
#define	RF_FREELIST_DESTROY_CLEAN(_fl_,_nextp_,_cast_,_clean_)		\
do {									\
	void *_cur, *_next;						\
	RF_FREELIST_STAT_REPORT(_fl_);					\
	rf_mutex_destroy(&((_fl_)->lock));				\
	for (_cur = (_fl_)->objlist; _cur; _cur = _next) {		\
		_next = (_cast_ _cur)->_nextp_;				\
		_clean_(_cur);						\
		RF_Free(_cur, (_fl_)->obj_size);			\
	}								\
	RF_Free(_fl_, sizeof(RF_FreeList_t));				\
} while (0)

/*
 * fl	 = FreeList.
 * nextp = Name of "next" pointer in obj.
 * cast	 = Cast to object type.
 * clean = Func to undo obj init.
 * arg	 = Arg for undo func.
 */
#define	RF_FREELIST_DESTROY_CLEAN_ARG(_fl_,_nextp_,_cast_,_clean_,_arg_) \
do {									\
	void *_cur, *_next;						\
	RF_FREELIST_STAT_REPORT(_fl_);					\
	rf_mutex_destroy(&((_fl_)->lock));				\
	for (_cur = (_fl_)->objlist; _cur; _cur = _next) {		\
		_next = (_cast_ _cur)->_nextp_;				\
		_clean_(_cur, _arg_);					\
		RF_Free(_cur, (_fl_)->obj_size);			\
	}								\
	RF_Free(_fl_, sizeof(RF_FreeList_t));				\
} while (0)
d668 1
a668 1
#endif	/* !_RF__RF_FREELIST_H_ */
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_freelist.h,v 1.1 1998/11/13 04:20:30 oster Exp $	*/
/*	$NetBSD: rf_freelist.h,v 1.1 1998/11/13 04:20:30 oster Exp $	*/
d32 1
a32 65
/*
 * :  
 * Log: rf_freelist.h,v 
 * Revision 1.13  1996/06/10 12:50:57  jimz
 * Add counters to freelists to track number of allocations, frees,
 * grows, max size, etc. Adjust a couple sets of PRIME params based
 * on the results.
 *
 * Revision 1.12  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.11  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.10  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.9  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.8  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.7  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.6  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.5  1996/05/20  16:16:12  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.4  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.3  1996/05/16  16:04:52  jimz
 * allow init func to fail for FREELIST ops
 *
 * Revision 1.2  1996/05/16  14:54:08  jimz
 * added _INIT and _CLEAN versions of ops for objects with
 * internal allocations
 *
 * Revision 1.1  1996/05/15  23:37:53  jimz
 * Initial revision
 *
 */
d54 9
a62 10
  char  *file;
  int    line;
  int    allocations;
  int    frees;
  int    max_free;
  int    grows;
  int    outstanding;
  int    max_outstanding;
} RF_FreeListStats_t;

d101 1
a101 1
#else /* RF_FREELIST_STATS > 0 */
d110 1
a110 1
#endif /* RF_FREELIST_STATS > 0 */
d113 6
a118 6
	void  *objlist;      /* list of free obj */
	int    free_cnt;     /* how many free obj */
	int    max_free_cnt; /* max free arena size */
	int    obj_inc;      /* how many to allocate at a time */
	int    obj_size;     /* size of objects */
	RF_DECLARE_MUTEX(lock)
d120 2
a121 2
	RF_FreeListStats_t  stats;  /* statistics */
#endif /* RF_FREELIST_STATS > 0 */
a122 1

d668 1
a668 1
#endif /* !_RF__RF_FREELIST_H_ */
@

