head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.38
	OPENBSD_5_0:1.5.0.36
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.34
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.32
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.28
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.8
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.5;

1.5
date	2002.12.16.07.01.05;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.08.16.07.45;	author peter;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	99.07.30.14.45.33;	author peter;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.16.00.03.23;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.47;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.26.14;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_reconstruct.h,v 1.5 2002/12/16 07:01:05 tdeval Exp $	*/
/*	$NetBSD: rf_reconstruct.h,v 1.5 2000/05/28 00:48:30 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/***********************************************************
 * rf_reconstruct.h -- Header file for reconstruction code.
 ***********************************************************/

#ifndef _RF__RF_RECONSTRUCT_H_
#define _RF__RF_RECONSTRUCT_H_

#include "rf_types.h"
#include <sys/time.h>
#include "rf_reconmap.h"
#include "rf_psstatus.h"

/* Reconstruction configuration information. */
struct RF_ReconConfig_s {
	unsigned		numFloatingReconBufs;
						/*
						 * Number of floating recon
						 * bufs to use.
						 */
	RF_HeadSepLimit_t	headSepLimit;	/*
						 * How far apart the heads are
						 * allowed to become, in parity
						 * stripes.
						 */
};

/* A reconstruction buffer. */
struct RF_ReconBuffer_s {
	RF_Raid_t		*raidPtr;	/*
						 * (void *) to avoid recursive
						 * includes.
						 */
	caddr_t			 buffer;	/* Points to the data. */
	RF_StripeNum_t		 parityStripeID;/*
						 * The parity stripe that this
						 * data relates to.
						 */
	int			 which_ru;	/*
						 * Which reconstruction unit
						 * within the PSS.
						 */
	RF_SectorNum_t		 failedDiskSectorOffset;
						/*
						 * The offset into the failed
						 * disk.
						 */
	RF_RowCol_t		 row, col;	/*
						 * Which disk this buffer
						 * belongs to or is targeted at.
						 */
	RF_StripeCount_t	 count;		/*
						 * Counts the # of SUs
						 * installed so far.
						 */
	int			 priority;	/*
						 * Used to force high priority
						 * recon.
						 */
	RF_RbufType_t		 type;		/* FORCED or FLOATING. */
	char			*arrived;	/*
						 * [x] = 1/0 if SU from disk x
						 * has/hasn't arrived.
						 */
	RF_ReconBuffer_t	*next;		/*
						 * Used for buffer management.
						 */
	void			*arg;		/*
						 * Generic field for general
						 * use.
						 */
	RF_RowCol_t		 spRow, spCol;	/*
						 * Spare disk to which this buf
						 * should be written.
						 */
	/* If dist sparing off, always identifies the replacement disk */
	RF_SectorNum_t		 spOffset;	/*
						 * Offset into the spare disk.
						 */
	/* If dist sparing off, identical to failedDiskSectorOffset */
	RF_ReconParityStripeStatus_t *pssPtr;	/*
						 * Debug pss associated with
						 * issue-pending write.
						 */
};

/*
 * A reconstruction event descriptor. The event types currently are:
 *    RF_REVENT_READDONE	-- A read operation has completed.
 *    RF_REVENT_WRITEDONE	-- A write operation has completed.
 *    RF_REVENT_BUFREADY	-- The buffer manager has produced a
 *				   full buffer.
 *    RF_REVENT_BLOCKCLEAR	-- A reconstruction blockage has been cleared.
 *    RF_REVENT_BUFCLEAR	-- The buffer manager has released a process
 *				   blocked on submission.
 *    RF_REVENT_SKIP		-- We need to skip the current RU and go on
 *				   to the next one, typ. b/c we found recon
 *				   forced.
 *    RF_REVENT_FORCEDREADONE	-- A forced-reconstructoin read operation has
 *				   completed.
 */
typedef enum RF_Revent_e {
	RF_REVENT_READDONE,
	RF_REVENT_WRITEDONE,
	RF_REVENT_BUFREADY,
	RF_REVENT_BLOCKCLEAR,
	RF_REVENT_BUFCLEAR,
	RF_REVENT_HEADSEPCLEAR,
	RF_REVENT_SKIP,
	RF_REVENT_FORCEDREADDONE
} RF_Revent_t;

struct RF_ReconEvent_s {
	RF_Revent_t		 type;	/* What kind of event has occurred. */
	RF_RowCol_t		 col;	/*
					 * Row ID is implicit in the queue in
					 * which the event is placed.
					 */
	void			*arg;	/* A generic argument. */
	RF_ReconEvent_t		*next;
};

/*
 * Reconstruction control information maintained per-disk.
 * (for surviving disks)
 */
struct RF_PerDiskReconCtrl_s {
	RF_ReconCtrl_t		*reconCtrl;
	RF_RowCol_t		 row, col;	/*
						 * To make this structure
						 * self-identifying.
						 */
	RF_StripeNum_t		 curPSID;	/*
						 * The next parity stripe ID
						 * to check on this disk.
						 */
	RF_HeadSepLimit_t	 headSepCounter;/*
						 * Counter used to control
						 * maximum head separation.
						 */
	RF_SectorNum_t		 diskOffset;	/*
						 * The offset into the
						 * indicated disk
						 * of the current PU.
						 */
	RF_ReconUnitNum_t	 ru_count;	/*
						 * This counts off the recon
						 * units within each parity
						 * unit.
						 */
	RF_ReconBuffer_t	*rbuf;		/*
						 * The recon buffer assigned
						 * to this disk.
						 */
};

/* Main reconstruction control structure. */
struct RF_ReconCtrl_s {
	RF_RaidReconDesc_t	*reconDesc;
	RF_RowCol_t		 fcol;		/* Which column has failed. */
	RF_PerDiskReconCtrl_t	*perDiskInfo;	/*
						 * Information maintained
						 * per-disk.
						 */
	RF_ReconMap_t		*reconMap;	/*
						 * Map of what has/has not
						 * been reconstructed.
						 */
	RF_RowCol_t		 spareRow;	/*
						 * Which of the spare disks
						 * we're using.
						 */
	RF_RowCol_t		 spareCol;
	RF_StripeNum_t		 lastPSID;	/*
						 * The ID of the last
						 * parity stripe we want
						 * reconstructed.
						 */
	int			 percentComplete;
						/*
						 * Percentage completion of
						 * reconstruction.
						 */
	int			 numRUsComplete;/*
						 * Number of Reconstruction
						 * Units done.
						 */
	int			 numRUsTotal;	/*
						 * Total number of
						 * Reconstruction Units.
						 */

	/* Reconstruction event queue. */
	RF_ReconEvent_t		*eventQueue;	/*
						 * Queue of pending
						 * reconstruction events.
						 */
	RF_DECLARE_MUTEX	(eq_mutex);	/*
						 * Mutex for locking event
						 * queue.
						 */
	RF_DECLARE_COND		(eq_cond);	/*
						 * Condition variable for
						 * signalling recon events.
						 */
	int			 eq_count;	/* Debug only. */

	/* Reconstruction buffer management. */
	RF_DECLARE_MUTEX	(rb_mutex);	/*
						 * Mutex for messing around
						 * with recon buffers.
						 */
	RF_ReconBuffer_t	*floatingRbufs;	/*
						 * Available floating
						 * reconstruction buffers.
						 */
	RF_ReconBuffer_t	*committedRbufs;/*
						 * Recon buffers that have
						 * been committed to some
						 * waiting disk.
						 */
	RF_ReconBuffer_t	*fullBufferList;/*
						 * Full buffers waiting to be
						 * written out.
						 */
	RF_ReconBuffer_t	*priorityList;	/*
						 * Full buffers that have been
						 * elevated to higher priority.
						 */
	RF_CallbackDesc_t	*bufferWaitList;/*
						 * Disks that are currently
						 * blocked waiting for buffers.
						 */

	/* Parity stripe status table. */
	RF_PSStatusHeader_t	*pssTable;	/*
						 * Stores the reconstruction
						 * status of active parity
						 * stripes.
						 */

	/* Maximum-head separation control. */
	RF_HeadSepLimit_t	 minHeadSepCounter;
						/*
						 * The minimum hs counter over
						 * all disks.
						 */
	RF_CallbackDesc_t	*headSepCBList;	/*
						 * List of callbacks to be
						 * done as minPSID advances.
						 */

	/* Performance monitoring. */
	struct timeval		 starttime;	/* Recon start time. */

	void		       (*continueFunc) (void *);
						/*
						 * Function to call when io
						 * returns.
						 */
	void			*continueArg;	/* Argument for Func. */
};

/* The default priority for reconstruction accesses. */
#define RF_IO_RECON_PRIORITY RF_IO_LOW_PRIORITY

int  rf_ConfigureReconstruction(RF_ShutdownList_t **);
int  rf_ReconstructFailedDisk(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ReconstructFailedDiskBasic(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ReconstructInPlace(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ContinueReconstructFailedDisk(RF_RaidReconDesc_t *);
int  rf_ForceOrBlockRecon(RF_Raid_t *, RF_AccessStripeMap_t *,
	void (*) (RF_Raid_t *, void *), void *);
int  rf_UnblockRecon(RF_Raid_t *, RF_AccessStripeMap_t *);
int  rf_RegisterReconDoneProc(RF_Raid_t *, void (*) (RF_Raid_t *, void *),
	void *, RF_ReconDoneProc_t **);

#endif	/* !_RF__RF_RECONSTRUCT_H_ */
@


1.5
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.h,v 1.4 2000/08/08 16:07:45 peter Exp $	*/
@


1.4
log
@sync RAIDframe with Gre Oster's work for NetBSD.

This update incorporates changes since January 2000.

RAID1 and RAID5 tested for functionality matching the 2.7 code. A
number of bug fixes (including stopping a parity rebuild when
unconfiguring) have been included. See Greg's RAIDframe info page:

	http://www.cs.usask.ca/staff/oster/raid.html

The RAID_AUTOCONFIG feature set does *NOT* yet work. These features
require more work throughout the boot system and as such are a big
task.

IMPORTANT: As with anything that is this near live data on your
systems, please test carefully with existing configurations before
deploying in a live system.  Feedback via sendbug or mail direct
to peter@@wonderland.org is appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_reconstruct.h,v 1.3 1999/07/30 14:45:33 peter Exp $	*/
d3 1
d31 3
a33 3
/*********************************************************
 * rf_reconstruct.h -- header file for reconstruction code
 *********************************************************/
d43 1
a43 1
/* reconstruction configuration information */
d45 10
a54 4
	unsigned numFloatingReconBufs;	/* number of floating recon bufs to
					 * use */
	RF_HeadSepLimit_t headSepLimit;	/* how far apart the heads are allow
					 * to become, in parity stripes */
d56 2
a57 1
/* a reconstruction buffer */
d59 55
a113 23
	RF_Raid_t *raidPtr;	/* void * to avoid recursive includes */
	caddr_t buffer;		/* points to the data */
	RF_StripeNum_t parityStripeID;	/* the parity stripe that this data
					 * relates to */
	int     which_ru;	/* which reconstruction unit within the PSS */
	RF_SectorNum_t failedDiskSectorOffset;	/* the offset into the failed
						 * disk */
	RF_RowCol_t row, col;	/* which disk this buffer belongs to or is
				 * targeted at */
	RF_StripeCount_t count;	/* counts the # of SUs installed so far */
	int     priority;	/* used to force hi priority recon */
	RF_RbufType_t type;	/* FORCED or FLOATING */
	char   *arrived;	/* [x] = 1/0 if SU from disk x has/hasn't
				 * arrived */
	RF_ReconBuffer_t *next;	/* used for buffer management */
	void   *arg;		/* generic field for general use */
	RF_RowCol_t spRow, spCol;	/* spare disk to which this buf should
					 * be written */
	/* if dist sparing off, always identifies the replacement disk */
	RF_SectorNum_t spOffset;/* offset into the spare disk */
	/* if dist sparing off, identical to failedDiskSectorOffset */
	RF_ReconParityStripeStatus_t *pssPtr;	/* debug- pss associated with
						 * issue-pending write */
d115 15
a129 8
/* a reconstruction event descriptor.  The event types currently are:
 *    RF_REVENT_READDONE    -- a read operation has completed
 *    RF_REVENT_WRITEDONE   -- a write operation has completed
 *    RF_REVENT_BUFREADY    -- the buffer manager has produced a full buffer
 *    RF_REVENT_BLOCKCLEAR  -- a reconstruction blockage has been cleared
 *    RF_REVENT_BUFCLEAR    -- the buffer manager has released a process blocked on submission
 *    RF_REVENT_SKIP        -- we need to skip the current RU and go on to the next one, typ. b/c we found recon forced
 *    RF_REVENT_FORCEDREADONE- a forced-reconstructoin read operation has completed
d140 1
a140 1
}       RF_Revent_t;
d143 7
a149 5
	RF_Revent_t type;	/* what kind of event has occurred */
	RF_RowCol_t col;	/* row ID is implicit in the queue in which
				 * the event is placed */
	void   *arg;		/* a generic argument */
	RF_ReconEvent_t *next;
d151 1
d153 1
a153 1
 * Reconstruction control information maintained per-disk
d157 27
a183 11
	RF_ReconCtrl_t *reconCtrl;
	RF_RowCol_t row, col;	/* to make this structure self-identifying */
	RF_StripeNum_t curPSID;	/* the next parity stripe ID to check on this
				 * disk */
	RF_HeadSepLimit_t headSepCounter;	/* counter used to control
						 * maximum head separation */
	RF_SectorNum_t diskOffset;	/* the offset into the indicated disk
					 * of the current PU */
	RF_ReconUnitNum_t ru_count;	/* this counts off the recon units
					 * within each parity unit */
	RF_ReconBuffer_t *rbuf;	/* the recon buffer assigned to this disk */
d185 2
a186 1
/* main reconstruction control structure */
d188 60
a247 28
	RF_RaidReconDesc_t *reconDesc;
	RF_RowCol_t fcol;	/* which column has failed */
	RF_PerDiskReconCtrl_t *perDiskInfo;	/* information maintained
						 * per-disk */
	RF_ReconMap_t *reconMap;/* map of what has/has not been reconstructed */
	RF_RowCol_t spareRow;	/* which of the spare disks we're using */
	RF_RowCol_t spareCol;
	RF_StripeNum_t lastPSID;/* the ID of the last parity stripe we want
				 * reconstructed */
	int     percentComplete;/* percentage completion of reconstruction */
	int     numRUsComplete; /* number of Reconstruction Units done */
	int     numRUsTotal;    /* total number of Reconstruction Units */

	/* reconstruction event queue */
	RF_ReconEvent_t *eventQueue;	/* queue of pending reconstruction
					 * events */
	        RF_DECLARE_MUTEX(eq_mutex)	/* mutex for locking event
						 * queue */
	        RF_DECLARE_COND(eq_cond)	/* condition variable for
						 * signalling recon events */
	int     eq_count;	/* debug only */

	/* reconstruction buffer management */
	        RF_DECLARE_MUTEX(rb_mutex)	/* mutex for messing around
						 * with recon buffers */
	RF_ReconBuffer_t *floatingRbufs;	/* available floating
						 * reconstruction buffers */
	RF_ReconBuffer_t *committedRbufs;	/* recon buffers that have
d249 42
a290 24
						 * waiting disk */
	RF_ReconBuffer_t *fullBufferList;	/* full buffers waiting to be
						 * written out */
	RF_ReconBuffer_t *priorityList;	/* full buffers that have been
					 * elevated to higher priority */
	RF_CallbackDesc_t *bufferWaitList;	/* disks that are currently
						 * blocked waiting for buffers */

	/* parity stripe status table */
	RF_PSStatusHeader_t *pssTable;	/* stores the reconstruction status of
					 * active parity stripes */

	/* maximum-head separation control */
	RF_HeadSepLimit_t minHeadSepCounter;	/* the minimum hs counter over
						 * all disks */
	RF_CallbackDesc_t *headSepCBList;	/* list of callbacks to be
						 * done as minPSID advances */

	/* performance monitoring */
	struct timeval starttime;	/* recon start time */

	void    (*continueFunc) (void *);	/* function to call when io
						 * returns */
	void   *continueArg;	/* argument for Func */
d292 2
a293 1
/* the default priority for reconstruction accesses */
d296 10
a305 23
int     rf_ConfigureReconstruction(RF_ShutdownList_t ** listp);

int 
rf_ReconstructFailedDisk(RF_Raid_t * raidPtr, RF_RowCol_t row,
    RF_RowCol_t col);

int 
rf_ReconstructFailedDiskBasic(RF_Raid_t * raidPtr, RF_RowCol_t row,
    RF_RowCol_t col);

int 
rf_ReconstructInPlace(RF_Raid_t * raidPtr, RF_RowCol_t row, RF_RowCol_t col);

int     rf_ContinueReconstructFailedDisk(RF_RaidReconDesc_t * reconDesc);

int 
rf_ForceOrBlockRecon(RF_Raid_t * raidPtr, RF_AccessStripeMap_t * asmap,
    void (*cbFunc) (RF_Raid_t *, void *), void *cbArg);

	int     rf_UnblockRecon(RF_Raid_t * raidPtr, RF_AccessStripeMap_t * asmap);

	int     rf_RegisterReconDoneProc(RF_Raid_t * raidPtr, void (*proc) (RF_Raid_t *, void *), void *arg,
            RF_ReconDoneProc_t ** handlep);
d307 1
a307 1
#endif				/* !_RF__RF_RECONSTRUCT_H_ */
@


1.4.8.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 3
a32 3
/***********************************************************
 * rf_reconstruct.h -- Header file for reconstruction code.
 ***********************************************************/
d42 1
a42 1
/* Reconstruction configuration information. */
d44 4
a47 10
	unsigned		numFloatingReconBufs;
						/*
						 * Number of floating recon
						 * bufs to use.
						 */
	RF_HeadSepLimit_t	headSepLimit;	/*
						 * How far apart the heads are
						 * allowed to become, in parity
						 * stripes.
						 */
d49 1
a49 2

/* A reconstruction buffer. */
d51 23
a73 55
	RF_Raid_t		*raidPtr;	/*
						 * (void *) to avoid recursive
						 * includes.
						 */
	caddr_t			 buffer;	/* Points to the data. */
	RF_StripeNum_t		 parityStripeID;/*
						 * The parity stripe that this
						 * data relates to.
						 */
	int			 which_ru;	/*
						 * Which reconstruction unit
						 * within the PSS.
						 */
	RF_SectorNum_t		 failedDiskSectorOffset;
						/*
						 * The offset into the failed
						 * disk.
						 */
	RF_RowCol_t		 row, col;	/*
						 * Which disk this buffer
						 * belongs to or is targeted at.
						 */
	RF_StripeCount_t	 count;		/*
						 * Counts the # of SUs
						 * installed so far.
						 */
	int			 priority;	/*
						 * Used to force high priority
						 * recon.
						 */
	RF_RbufType_t		 type;		/* FORCED or FLOATING. */
	char			*arrived;	/*
						 * [x] = 1/0 if SU from disk x
						 * has/hasn't arrived.
						 */
	RF_ReconBuffer_t	*next;		/*
						 * Used for buffer management.
						 */
	void			*arg;		/*
						 * Generic field for general
						 * use.
						 */
	RF_RowCol_t		 spRow, spCol;	/*
						 * Spare disk to which this buf
						 * should be written.
						 */
	/* If dist sparing off, always identifies the replacement disk */
	RF_SectorNum_t		 spOffset;	/*
						 * Offset into the spare disk.
						 */
	/* If dist sparing off, identical to failedDiskSectorOffset */
	RF_ReconParityStripeStatus_t *pssPtr;	/*
						 * Debug pss associated with
						 * issue-pending write.
						 */
d75 8
a82 15

/*
 * A reconstruction event descriptor. The event types currently are:
 *    RF_REVENT_READDONE	-- A read operation has completed.
 *    RF_REVENT_WRITEDONE	-- A write operation has completed.
 *    RF_REVENT_BUFREADY	-- The buffer manager has produced a
 *				   full buffer.
 *    RF_REVENT_BLOCKCLEAR	-- A reconstruction blockage has been cleared.
 *    RF_REVENT_BUFCLEAR	-- The buffer manager has released a process
 *				   blocked on submission.
 *    RF_REVENT_SKIP		-- We need to skip the current RU and go on
 *				   to the next one, typ. b/c we found recon
 *				   forced.
 *    RF_REVENT_FORCEDREADONE	-- A forced-reconstructoin read operation has
 *				   completed.
d93 1
a93 1
} RF_Revent_t;
d96 5
a100 7
	RF_Revent_t		 type;	/* What kind of event has occurred. */
	RF_RowCol_t		 col;	/*
					 * Row ID is implicit in the queue in
					 * which the event is placed.
					 */
	void			*arg;	/* A generic argument. */
	RF_ReconEvent_t		*next;
a101 1

d103 1
a103 1
 * Reconstruction control information maintained per-disk.
d107 11
a117 27
	RF_ReconCtrl_t		*reconCtrl;
	RF_RowCol_t		 row, col;	/*
						 * To make this structure
						 * self-identifying.
						 */
	RF_StripeNum_t		 curPSID;	/*
						 * The next parity stripe ID
						 * to check on this disk.
						 */
	RF_HeadSepLimit_t	 headSepCounter;/*
						 * Counter used to control
						 * maximum head separation.
						 */
	RF_SectorNum_t		 diskOffset;	/*
						 * The offset into the
						 * indicated disk
						 * of the current PU.
						 */
	RF_ReconUnitNum_t	 ru_count;	/*
						 * This counts off the recon
						 * units within each parity
						 * unit.
						 */
	RF_ReconBuffer_t	*rbuf;		/*
						 * The recon buffer assigned
						 * to this disk.
						 */
d119 1
a119 2

/* Main reconstruction control structure. */
d121 28
a148 60
	RF_RaidReconDesc_t	*reconDesc;
	RF_RowCol_t		 fcol;		/* Which column has failed. */
	RF_PerDiskReconCtrl_t	*perDiskInfo;	/*
						 * Information maintained
						 * per-disk.
						 */
	RF_ReconMap_t		*reconMap;	/*
						 * Map of what has/has not
						 * been reconstructed.
						 */
	RF_RowCol_t		 spareRow;	/*
						 * Which of the spare disks
						 * we're using.
						 */
	RF_RowCol_t		 spareCol;
	RF_StripeNum_t		 lastPSID;	/*
						 * The ID of the last
						 * parity stripe we want
						 * reconstructed.
						 */
	int			 percentComplete;
						/*
						 * Percentage completion of
						 * reconstruction.
						 */
	int			 numRUsComplete;/*
						 * Number of Reconstruction
						 * Units done.
						 */
	int			 numRUsTotal;	/*
						 * Total number of
						 * Reconstruction Units.
						 */

	/* Reconstruction event queue. */
	RF_ReconEvent_t		*eventQueue;	/*
						 * Queue of pending
						 * reconstruction events.
						 */
	RF_DECLARE_MUTEX	(eq_mutex);	/*
						 * Mutex for locking event
						 * queue.
						 */
	RF_DECLARE_COND		(eq_cond);	/*
						 * Condition variable for
						 * signalling recon events.
						 */
	int			 eq_count;	/* Debug only. */

	/* Reconstruction buffer management. */
	RF_DECLARE_MUTEX	(rb_mutex);	/*
						 * Mutex for messing around
						 * with recon buffers.
						 */
	RF_ReconBuffer_t	*floatingRbufs;	/*
						 * Available floating
						 * reconstruction buffers.
						 */
	RF_ReconBuffer_t	*committedRbufs;/*
						 * Recon buffers that have
d150 24
a173 42
						 * waiting disk.
						 */
	RF_ReconBuffer_t	*fullBufferList;/*
						 * Full buffers waiting to be
						 * written out.
						 */
	RF_ReconBuffer_t	*priorityList;	/*
						 * Full buffers that have been
						 * elevated to higher priority.
						 */
	RF_CallbackDesc_t	*bufferWaitList;/*
						 * Disks that are currently
						 * blocked waiting for buffers.
						 */

	/* Parity stripe status table. */
	RF_PSStatusHeader_t	*pssTable;	/*
						 * Stores the reconstruction
						 * status of active parity
						 * stripes.
						 */

	/* Maximum-head separation control. */
	RF_HeadSepLimit_t	 minHeadSepCounter;
						/*
						 * The minimum hs counter over
						 * all disks.
						 */
	RF_CallbackDesc_t	*headSepCBList;	/*
						 * List of callbacks to be
						 * done as minPSID advances.
						 */

	/* Performance monitoring. */
	struct timeval		 starttime;	/* Recon start time. */

	void		       (*continueFunc) (void *);
						/*
						 * Function to call when io
						 * returns.
						 */
	void			*continueArg;	/* Argument for Func. */
d175 2
d178 20
a197 2
/* The default priority for reconstruction accesses. */
#define RF_IO_RECON_PRIORITY RF_IO_LOW_PRIORITY
d199 2
a200 10
int  rf_ConfigureReconstruction(RF_ShutdownList_t **);
int  rf_ReconstructFailedDisk(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ReconstructFailedDiskBasic(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ReconstructInPlace(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ContinueReconstructFailedDisk(RF_RaidReconDesc_t *);
int  rf_ForceOrBlockRecon(RF_Raid_t *, RF_AccessStripeMap_t *,
	void (*) (RF_Raid_t *, void *), void *);
int  rf_UnblockRecon(RF_Raid_t *, RF_AccessStripeMap_t *);
int  rf_RegisterReconDoneProc(RF_Raid_t *, void (*) (RF_Raid_t *, void *),
	void *, RF_ReconDoneProc_t **);
d202 1
a202 1
#endif	/* !_RF__RF_RECONSTRUCT_H_ */
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconstruct.h,v 1.2 1999/02/16 00:03:23 niklas Exp $	*/
/*	$NetBSD: rf_reconstruct.h,v 1.4 1999/03/02 03:18:48 oster Exp $	*/
d131 2
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconstruct.h,v 1.4 2000/08/08 16:07:45 peter Exp $	*/
/*	$NetBSD: rf_reconstruct.h,v 1.5 2000/05/28 00:48:30 oster Exp $	*/
a130 2
	int     numRUsComplete; /* number of Reconstruction Units done */
	int     numRUsTotal;    /* total number of Reconstruction Units */
@


1.3.4.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 3
a32 3
/***********************************************************
 * rf_reconstruct.h -- Header file for reconstruction code.
 ***********************************************************/
d42 1
a42 1
/* Reconstruction configuration information. */
d44 4
a47 10
	unsigned		numFloatingReconBufs;
						/*
						 * Number of floating recon
						 * bufs to use.
						 */
	RF_HeadSepLimit_t	headSepLimit;	/*
						 * How far apart the heads are
						 * allowed to become, in parity
						 * stripes.
						 */
d49 1
a49 2

/* A reconstruction buffer. */
d51 23
a73 55
	RF_Raid_t		*raidPtr;	/*
						 * (void *) to avoid recursive
						 * includes.
						 */
	caddr_t			 buffer;	/* Points to the data. */
	RF_StripeNum_t		 parityStripeID;/*
						 * The parity stripe that this
						 * data relates to.
						 */
	int			 which_ru;	/*
						 * Which reconstruction unit
						 * within the PSS.
						 */
	RF_SectorNum_t		 failedDiskSectorOffset;
						/*
						 * The offset into the failed
						 * disk.
						 */
	RF_RowCol_t		 row, col;	/*
						 * Which disk this buffer
						 * belongs to or is targeted at.
						 */
	RF_StripeCount_t	 count;		/*
						 * Counts the # of SUs
						 * installed so far.
						 */
	int			 priority;	/*
						 * Used to force high priority
						 * recon.
						 */
	RF_RbufType_t		 type;		/* FORCED or FLOATING. */
	char			*arrived;	/*
						 * [x] = 1/0 if SU from disk x
						 * has/hasn't arrived.
						 */
	RF_ReconBuffer_t	*next;		/*
						 * Used for buffer management.
						 */
	void			*arg;		/*
						 * Generic field for general
						 * use.
						 */
	RF_RowCol_t		 spRow, spCol;	/*
						 * Spare disk to which this buf
						 * should be written.
						 */
	/* If dist sparing off, always identifies the replacement disk */
	RF_SectorNum_t		 spOffset;	/*
						 * Offset into the spare disk.
						 */
	/* If dist sparing off, identical to failedDiskSectorOffset */
	RF_ReconParityStripeStatus_t *pssPtr;	/*
						 * Debug pss associated with
						 * issue-pending write.
						 */
d75 8
a82 15

/*
 * A reconstruction event descriptor. The event types currently are:
 *    RF_REVENT_READDONE	-- A read operation has completed.
 *    RF_REVENT_WRITEDONE	-- A write operation has completed.
 *    RF_REVENT_BUFREADY	-- The buffer manager has produced a
 *				   full buffer.
 *    RF_REVENT_BLOCKCLEAR	-- A reconstruction blockage has been cleared.
 *    RF_REVENT_BUFCLEAR	-- The buffer manager has released a process
 *				   blocked on submission.
 *    RF_REVENT_SKIP		-- We need to skip the current RU and go on
 *				   to the next one, typ. b/c we found recon
 *				   forced.
 *    RF_REVENT_FORCEDREADONE	-- A forced-reconstructoin read operation has
 *				   completed.
d93 1
a93 1
} RF_Revent_t;
d96 5
a100 7
	RF_Revent_t		 type;	/* What kind of event has occurred. */
	RF_RowCol_t		 col;	/*
					 * Row ID is implicit in the queue in
					 * which the event is placed.
					 */
	void			*arg;	/* A generic argument. */
	RF_ReconEvent_t		*next;
a101 1

d103 1
a103 1
 * Reconstruction control information maintained per-disk.
d107 11
a117 27
	RF_ReconCtrl_t		*reconCtrl;
	RF_RowCol_t		 row, col;	/*
						 * To make this structure
						 * self-identifying.
						 */
	RF_StripeNum_t		 curPSID;	/*
						 * The next parity stripe ID
						 * to check on this disk.
						 */
	RF_HeadSepLimit_t	 headSepCounter;/*
						 * Counter used to control
						 * maximum head separation.
						 */
	RF_SectorNum_t		 diskOffset;	/*
						 * The offset into the
						 * indicated disk
						 * of the current PU.
						 */
	RF_ReconUnitNum_t	 ru_count;	/*
						 * This counts off the recon
						 * units within each parity
						 * unit.
						 */
	RF_ReconBuffer_t	*rbuf;		/*
						 * The recon buffer assigned
						 * to this disk.
						 */
d119 1
a119 2

/* Main reconstruction control structure. */
d121 28
a148 60
	RF_RaidReconDesc_t	*reconDesc;
	RF_RowCol_t		 fcol;		/* Which column has failed. */
	RF_PerDiskReconCtrl_t	*perDiskInfo;	/*
						 * Information maintained
						 * per-disk.
						 */
	RF_ReconMap_t		*reconMap;	/*
						 * Map of what has/has not
						 * been reconstructed.
						 */
	RF_RowCol_t		 spareRow;	/*
						 * Which of the spare disks
						 * we're using.
						 */
	RF_RowCol_t		 spareCol;
	RF_StripeNum_t		 lastPSID;	/*
						 * The ID of the last
						 * parity stripe we want
						 * reconstructed.
						 */
	int			 percentComplete;
						/*
						 * Percentage completion of
						 * reconstruction.
						 */
	int			 numRUsComplete;/*
						 * Number of Reconstruction
						 * Units done.
						 */
	int			 numRUsTotal;	/*
						 * Total number of
						 * Reconstruction Units.
						 */

	/* Reconstruction event queue. */
	RF_ReconEvent_t		*eventQueue;	/*
						 * Queue of pending
						 * reconstruction events.
						 */
	RF_DECLARE_MUTEX	(eq_mutex);	/*
						 * Mutex for locking event
						 * queue.
						 */
	RF_DECLARE_COND		(eq_cond);	/*
						 * Condition variable for
						 * signalling recon events.
						 */
	int			 eq_count;	/* Debug only. */

	/* Reconstruction buffer management. */
	RF_DECLARE_MUTEX	(rb_mutex);	/*
						 * Mutex for messing around
						 * with recon buffers.
						 */
	RF_ReconBuffer_t	*floatingRbufs;	/*
						 * Available floating
						 * reconstruction buffers.
						 */
	RF_ReconBuffer_t	*committedRbufs;/*
						 * Recon buffers that have
d150 24
a173 42
						 * waiting disk.
						 */
	RF_ReconBuffer_t	*fullBufferList;/*
						 * Full buffers waiting to be
						 * written out.
						 */
	RF_ReconBuffer_t	*priorityList;	/*
						 * Full buffers that have been
						 * elevated to higher priority.
						 */
	RF_CallbackDesc_t	*bufferWaitList;/*
						 * Disks that are currently
						 * blocked waiting for buffers.
						 */

	/* Parity stripe status table. */
	RF_PSStatusHeader_t	*pssTable;	/*
						 * Stores the reconstruction
						 * status of active parity
						 * stripes.
						 */

	/* Maximum-head separation control. */
	RF_HeadSepLimit_t	 minHeadSepCounter;
						/*
						 * The minimum hs counter over
						 * all disks.
						 */
	RF_CallbackDesc_t	*headSepCBList;	/*
						 * List of callbacks to be
						 * done as minPSID advances.
						 */

	/* Performance monitoring. */
	struct timeval		 starttime;	/* Recon start time. */

	void		       (*continueFunc) (void *);
						/*
						 * Function to call when io
						 * returns.
						 */
	void			*continueArg;	/* Argument for Func. */
d175 2
d178 20
a197 2
/* The default priority for reconstruction accesses. */
#define RF_IO_RECON_PRIORITY RF_IO_LOW_PRIORITY
d199 2
a200 10
int  rf_ConfigureReconstruction(RF_ShutdownList_t **);
int  rf_ReconstructFailedDisk(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ReconstructFailedDiskBasic(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ReconstructInPlace(RF_Raid_t *, RF_RowCol_t, RF_RowCol_t);
int  rf_ContinueReconstructFailedDisk(RF_RaidReconDesc_t *);
int  rf_ForceOrBlockRecon(RF_Raid_t *, RF_AccessStripeMap_t *,
	void (*) (RF_Raid_t *, void *), void *);
int  rf_UnblockRecon(RF_Raid_t *, RF_AccessStripeMap_t *);
int  rf_RegisterReconDoneProc(RF_Raid_t *, void (*) (RF_Raid_t *, void *),
	void *, RF_ReconDoneProc_t **);
d202 1
a202 1
#endif	/* !_RF__RF_RECONSTRUCT_H_ */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconstruct.h,v 1.1 1999/01/11 14:29:47 niklas Exp $	*/
/*	$NetBSD: rf_reconstruct.h,v 1.3 1999/02/05 00:06:16 oster Exp $	*/
d185 3
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_reconstruct.h,v 1.1 1998/11/13 04:20:34 oster Exp $	*/
/*	$NetBSD: rf_reconstruct.h,v 1.1 1998/11/13 04:20:34 oster Exp $	*/
a33 88
/* :  
 * Log: rf_reconstruct.h,v 
 * Revision 1.25  1996/08/01 15:57:24  jimz
 * minor cleanup
 *
 * Revision 1.24  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.23  1996/07/15  05:40:41  jimz
 * some recon datastructure cleanup
 * better handling of multiple failures
 * added undocumented double-recon test
 *
 * Revision 1.22  1996/07/13  00:00:59  jimz
 * sanitized generalized reconstruction architecture
 * cleaned up head sep, rbuf problems
 *
 * Revision 1.21  1996/07/11  19:08:00  jimz
 * generalize reconstruction mechanism
 * allow raid1 reconstructs via copyback (done with array
 * quiesced, not online, therefore not disk-directed)
 *
 * Revision 1.20  1996/06/11  10:57:30  jimz
 * add rf_RegisterReconDoneProc
 *
 * Revision 1.19  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.18  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.17  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.16  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.15  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.14  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.13  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.12  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.11  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.10  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.9  1995/12/06  15:04:55  root
 * added copyright info
 *
 */

d44 4
a47 2
  unsigned           numFloatingReconBufs; /* number of floating recon bufs to use */
  RF_HeadSepLimit_t  headSepLimit;         /* how far apart the heads are allow to become, in parity stripes */ 
a48 1

d51 23
a73 17
  RF_Raid_t        *raidPtr;          /* void * to avoid recursive includes */
  caddr_t           buffer;           /* points to the data */
  RF_StripeNum_t    parityStripeID;   /* the parity stripe that this data relates to */
  int               which_ru;         /* which reconstruction unit within the PSS */
  RF_SectorNum_t failedDiskSectorOffset;/* the offset into the failed disk */
  RF_RowCol_t       row, col;         /* which disk this buffer belongs to or is targeted at */
  RF_StripeCount_t  count;            /* counts the # of SUs installed so far */
  int               priority;         /* used to force hi priority recon */
  RF_RbufType_t     type;             /* FORCED or FLOATING */
  char             *arrived;          /* [x] = 1/0 if SU from disk x has/hasn't arrived */
  RF_ReconBuffer_t *next;             /* used for buffer management */
  void             *arg;              /* generic field for general use */
  RF_RowCol_t       spRow, spCol;     /* spare disk to which this buf should be written */
                                      /* if dist sparing off, always identifies the replacement disk */
  RF_SectorNum_t    spOffset;         /* offset into the spare disk */
                                      /* if dist sparing off, identical to failedDiskSectorOffset */
  RF_ReconParityStripeStatus_t *pssPtr; /* debug- pss associated with issue-pending write */
a74 1

d93 1
a93 1
} RF_Revent_t;
d96 5
a100 4
  RF_Revent_t       type;  /* what kind of event has occurred */
  RF_RowCol_t       col;   /* row ID is implicit in the queue in which the event is placed */
  void             *arg;   /* a generic argument */
  RF_ReconEvent_t  *next;
a101 1

d107 11
a117 7
  RF_ReconCtrl_t     *reconCtrl;
  RF_RowCol_t         row, col;              /* to make this structure self-identifying */
  RF_StripeNum_t      curPSID;               /* the next parity stripe ID to check on this disk */
  RF_HeadSepLimit_t   headSepCounter;        /* counter used to control maximum head separation */
  RF_SectorNum_t      diskOffset;            /* the offset into the indicated disk of the current PU */
  RF_ReconUnitNum_t   ru_count;              /* this counts off the recon units within each parity unit */
  RF_ReconBuffer_t   *rbuf;                  /* the recon buffer assigned to this disk */
a118 1

d121 51
a171 35
  RF_RaidReconDesc_t    *reconDesc;
  RF_RowCol_t            fcol;          /* which column has failed */
  RF_PerDiskReconCtrl_t *perDiskInfo;   /* information maintained per-disk */
  RF_ReconMap_t         *reconMap;      /* map of what has/has not been reconstructed */
  RF_RowCol_t            spareRow;      /* which of the spare disks we're using */
  RF_RowCol_t            spareCol;
  RF_StripeNum_t         lastPSID;      /* the ID of the last parity stripe we want reconstructed */
  int                    percentComplete; /* percentage completion of reconstruction */

  /* reconstruction event queue */
  RF_ReconEvent_t  *eventQueue;    /* queue of pending reconstruction events */
  RF_DECLARE_MUTEX(eq_mutex)       /* mutex for locking event queue */
  RF_DECLARE_COND(eq_cond)         /* condition variable for signalling recon events */
  int               eq_count;      /* debug only */

  /* reconstruction buffer management */
  RF_DECLARE_MUTEX(rb_mutex)             /* mutex for messing around with recon buffers */
  RF_ReconBuffer_t      *floatingRbufs;  /* available floating reconstruction buffers */
  RF_ReconBuffer_t      *committedRbufs; /* recon buffers that have been committed to some waiting disk */
  RF_ReconBuffer_t      *fullBufferList; /* full buffers waiting to be written out */
  RF_ReconBuffer_t      *priorityList;   /* full buffers that have been elevated to higher priority */
  RF_CallbackDesc_t     *bufferWaitList; /* disks that are currently blocked waiting for buffers */

  /* parity stripe status table */
  RF_PSStatusHeader_t  *pssTable;  /* stores the reconstruction status of active parity stripes */

  /* maximum-head separation control */
  RF_HeadSepLimit_t  minHeadSepCounter;  /* the minimum hs counter over all disks */
  RF_CallbackDesc_t *headSepCBList;  /* list of callbacks to be done as minPSID advances */

  /* performance monitoring */
  struct timeval    starttime;      /* recon start time */

  void (*continueFunc)(void *);     /* function to call when io returns*/
  void *continueArg;                     /* argument for Func */
a172 1

d176 1
a176 1
int rf_ConfigureReconstruction(RF_ShutdownList_t **listp);
d178 3
a180 2
int rf_ReconstructFailedDisk(RF_Raid_t *raidPtr, RF_RowCol_t row,
	RF_RowCol_t col);
d182 3
a184 2
int rf_ReconstructFailedDiskBasic(RF_Raid_t *raidPtr, RF_RowCol_t row,
	RF_RowCol_t col);
d186 1
a186 1
int rf_ContinueReconstructFailedDisk(RF_RaidReconDesc_t *reconDesc);
d188 3
a190 2
int rf_ForceOrBlockRecon(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap,
	void (*cbFunc)(RF_Raid_t *,void *), void *cbArg);
d192 1
a192 1
int rf_UnblockRecon(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap);
d194 2
a195 2
int rf_RegisterReconDoneProc(RF_Raid_t *raidPtr, void (*proc)(RF_Raid_t *, void *), void *arg,
	RF_ReconDoneProc_t **handlep);
d197 1
a197 1
#endif /* !_RF__RF_RECONSTRUCT_H_ */
@

