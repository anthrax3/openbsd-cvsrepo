head	1.17;
access;
symbols
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.18
	OPENBSD_5_0:1.16.0.16
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.14
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.12
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.8
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.18
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.16
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.14
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.12
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.8
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.16;

1.16
date	2007.09.09.16.50.23;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.19.14.32.00;	author tdeval;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.15.18.42.06;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.03.16.07;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.08.09.25.57;	author tdeval;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.06.11.28.27;	author tdeval;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.00.56.23;	author tdeval;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.29.21.51.18;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2000.01.11.18.02.21;	author peter;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.01.07.14.50.21;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.32;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.41;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.19;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.03.28.15.03.52;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.03.28.00.38.28;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2003.05.13.19.35.10;	author ho;	state Exp;
branches;
next	;

1.6.4.1
date	2002.01.31.22.55.38;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_engine.c,v 1.16 2007/09/09 16:50:23 krw Exp $	*/
/*	$NetBSD: rf_engine.c,v 1.10 2000/08/20 16:51:03 thorpej Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: William V. Courtright II, Mark Holland, Rachad Youssef
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/****************************************************************************
 *                                                                          *
 * engine.c -- Code for DAG execution engine.                               *
 *                                                                          *
 * Modified to work as follows (holland):                                   *
 *   A user-thread calls into DispatchDAG, which fires off the nodes that   *
 *   are direct successors to the header node. DispatchDAG then returns,    *
 *   and the rest of the I/O continues asynchronously. As each node         *
 *   completes, the node execution function calls FinishNode(). FinishNode  *
 *   scans the list of successors to the node and increments the antecedent *
 *   counts. Each node that becomes enabled is placed on a central node     *
 *   queue. A dedicated dag-execution thread grabs nodes off of this        *
 *   queue and fires them.                                                  *
 *                                                                          *
 *   NULL nodes are never fired.                                            *
 *                                                                          *
 *   Terminator nodes are never fired, but rather cause the callback        *
 *   associated with the DAG to be invoked.                                 *
 *                                                                          *
 *   If a node fails, the dag either rolls forward to the completion or     *
 *   rolls back, undoing previously-completed nodes and fails atomically.   *
 *   The direction of recovery is determined by the location of the failed  *
 *   node in the graph. If the failure occurred before the commit node in   *
 *   the graph, backward recovery is used. Otherwise, forward recovery is   *
 *   used.                                                                  *
 *                                                                          *
 ****************************************************************************/

#include "rf_threadstuff.h"

#include <sys/errno.h>

#include "rf_dag.h"
#include "rf_engine.h"
#include "rf_etimer.h"
#include "rf_general.h"
#include "rf_dagutils.h"
#include "rf_shutdown.h"
#include "rf_raid.h"

int  rf_BranchDone(RF_DagNode_t *);
int  rf_NodeReady(RF_DagNode_t *);
void rf_FireNode(RF_DagNode_t *);
void rf_FireNodeArray(int, RF_DagNode_t **);
void rf_FireNodeList(RF_DagNode_t *);
void rf_PropagateResults(RF_DagNode_t *, int);
void rf_ProcessNode(RF_DagNode_t *, int);

void rf_DAGExecutionThread(RF_ThreadArg_t);
#ifdef	RAID_AUTOCONFIG
#define	RF_ENGINE_PID	10
void rf_DAGExecutionThread_pre(RF_ThreadArg_t);
extern pid_t	  lastpid;
#endif	/* RAID_AUTOCONFIG */
void		**rf_hook_cookies;
extern int	  numraid;

#define	DO_INIT(_l_,_r_)						\
do {									\
	int _rc;							\
	_rc = rf_create_managed_mutex(_l_, &(_r_)->node_queue_mutex);	\
	if (_rc) {							\
		return(_rc);						\
	}								\
	_rc = rf_create_managed_cond(_l_, &(_r_)->node_queue_cond);	\
	if (_rc) {							\
		return(_rc);						\
	}								\
} while (0)

/*
 * Synchronization primitives for this file. DO_WAIT should be enclosed
 * in a while loop.
 */

/*
 * XXX Is this spl-ing really necessary ?
 */
#define	DO_LOCK(_r_)							\
do {									\
	ks = splbio();							\
	RF_LOCK_MUTEX((_r_)->node_queue_mutex);				\
} while (0)

#define	DO_UNLOCK(_r_)							\
do {									\
	RF_UNLOCK_MUTEX((_r_)->node_queue_mutex);			\
	splx(ks);							\
} while (0)

#define	DO_WAIT(_r_)							\
	RF_WAIT_COND((_r_)->node_queue, (_r_)->node_queue_mutex)

/* XXX RF_SIGNAL_COND? */
#define	DO_SIGNAL(_r_)							\
	RF_BROADCAST_COND((_r_)->node_queue)

void rf_ShutdownEngine(void *);

void
rf_ShutdownEngine(void *arg)
{
	RF_Raid_t *raidPtr;

	raidPtr = (RF_Raid_t *) arg;
	raidPtr->shutdown_engine = 1;
	DO_SIGNAL(raidPtr);
}

int
rf_ConfigureEngine(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
{
	int rc;
	char raidname[16];

	DO_INIT(listp, raidPtr);

	raidPtr->node_queue = NULL;
	raidPtr->dags_in_flight = 0;

	rc = rf_init_managed_threadgroup(listp, &raidPtr->engine_tg);
	if (rc)
		return (rc);

	/*
	 * We create the execution thread only once per system boot. No need
	 * to check return code b/c the kernel panics if it can't create the
	 * thread.
	 */
	if (rf_engineDebug) {
		printf("raid%d: %s engine thread\n", raidPtr->raidid,
		    (initproc)?"Starting":"Creating");
	}
	if (rf_hook_cookies == NULL) {
		rf_hook_cookies = malloc(numraid * sizeof(void *), M_RAIDFRAME,
		    M_NOWAIT | M_ZERO);
		if (rf_hook_cookies == NULL)
			return (ENOMEM);
	}
#ifdef	RAID_AUTOCONFIG
	if (initproc == NULL) {
		rf_hook_cookies[raidPtr->raidid] =
			startuphook_establish(rf_DAGExecutionThread_pre,
			    raidPtr);
	} else {
#endif	/* RAID_AUTOCONFIG */
		snprintf(&raidname[0], 16, "raid%d", raidPtr->raidid);
		if (RF_CREATE_THREAD(raidPtr->engine_thread,
		    rf_DAGExecutionThread, raidPtr, &raidname[0])) {
			RF_ERRORMSG("RAIDFRAME: Unable to start engine"
			    " thread\n");
			return (ENOMEM);
		}
		if (rf_engineDebug) {
			printf("raid%d: Engine thread started\n",
			    raidPtr->raidid);
		}
		RF_THREADGROUP_STARTED(&raidPtr->engine_tg);
#ifdef	RAID_AUTOCONFIG
	}
#endif
	/* XXX Something is missing here... */
#ifdef	debug
	printf("Skipping the WAIT_START !!!\n");
#endif
	/* Engine thread is now running and waiting for work. */
	if (rf_engineDebug) {
		printf("raid%d: Engine thread running and waiting for events\n",
		    raidPtr->raidid);
	}
	rc = rf_ShutdownCreate(listp, rf_ShutdownEngine, raidPtr);
	if (rc) {
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d\n", __FILE__, __LINE__, rc);
		rf_ShutdownEngine(NULL);
	}
	return (rc);
}

int
rf_BranchDone(RF_DagNode_t *node)
{
	int i;

	/*
	 * Return true if forward execution is completed for a node and it's
	 * succedents.
	 */
	switch (node->status) {
	case rf_wait:
		/* Should never be called in this state. */
		RF_PANIC();
		break;
	case rf_fired:
		/* Node is currently executing, so we're not done. */
		return (RF_FALSE);
	case rf_good:
		/* For each succedent. */
		for (i = 0; i < node->numSuccedents; i++)
			/* Recursively check branch. */
			if (!rf_BranchDone(node->succedents[i]))
				return RF_FALSE;

		return RF_TRUE;	/*
				 * Node and all succedent branches aren't in
				 * fired state.
				 */
		break;
	case rf_bad:
		/* Succedents can't fire. */
		return (RF_TRUE);
	case rf_recover:
		/* Should never be called in this state. */
		RF_PANIC();
		break;
	case rf_undone:
	case rf_panic:
		/* XXX Need to fix this case. */
		/* For now, assume that we're done. */
		return (RF_TRUE);
		break;
	default:
		/* Illegal node status. */
		RF_PANIC();
		break;
	}
}

int
rf_NodeReady(RF_DagNode_t *node)
{
	int ready;

	switch (node->dagHdr->status) {
	case rf_enable:
	case rf_rollForward:
		if ((node->status == rf_wait) &&
		    (node->numAntecedents == node->numAntDone))
			ready = RF_TRUE;
		else
			ready = RF_FALSE;
		break;
	case rf_rollBackward:
		RF_ASSERT(node->numSuccDone <= node->numSuccedents);
		RF_ASSERT(node->numSuccFired <= node->numSuccedents);
		RF_ASSERT(node->numSuccFired <= node->numSuccDone);
		if ((node->status == rf_good) &&
		    (node->numSuccDone == node->numSuccedents))
			ready = RF_TRUE;
		else
			ready = RF_FALSE;
		break;
	default:
		printf("Execution engine found illegal DAG status"
		    " in rf_NodeReady\n");
		RF_PANIC();
		break;
	}

	return (ready);
}


/*
 * User context and dag-exec-thread context:
 * Fire a node. The node's status field determines which function, do or undo,
 * to be fired.
 * This routine assumes that the node's status field has alread been set to
 * "fired" or "recover" to indicate the direction of execution.
 */
void
rf_FireNode(RF_DagNode_t *node)
{
	switch (node->status) {
	case rf_fired:
		/* Fire the do function of a node. */
		if (rf_engineDebug>1) {
			printf("raid%d: Firing node 0x%lx (%s)\n",
			    node->dagHdr->raidPtr->raidid,
			    (unsigned long) node, node->name);
		}
		if (node->flags & RF_DAGNODE_FLAG_YIELD) {
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
			/* thread_block(); */
			/* printf("Need to block the thread here...\n");  */
			/*
			 * XXX thread_block is actually mentioned in
			 * /usr/include/vm/vm_extern.h
			 */
#else
			thread_block();
#endif
		}
		(*(node->doFunc)) (node);
		break;
	case rf_recover:
		/* Fire the undo function of a node. */
		if (rf_engineDebug>1) {
			printf("raid%d: Firing (undo) node 0x%lx (%s)\n",
			    node->dagHdr->raidPtr->raidid,
			    (unsigned long) node, node->name);
		}
		if (node->flags & RF_DAGNODE_FLAG_YIELD) {
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
			/* thread_block(); */
			/* printf("Need to block the thread here...\n"); */
			/*
			 * XXX thread_block is actually mentioned in
			 * /usr/include/vm/vm_extern.h
			 */
#else
			thread_block();
#endif
		}
		(*(node->undoFunc)) (node);
		break;
	default:
		RF_PANIC();
		break;
	}
}


/*
 * User context:
 * Attempt to fire each node in a linear array.
 * The entire list is fired atomically.
 */
void
rf_FireNodeArray(int numNodes, RF_DagNode_t **nodeList)
{
	RF_DagStatus_t dstat;
	RF_DagNode_t *node;
	int i, j;

	/* First, mark all nodes which are ready to be fired. */
	for (i = 0; i < numNodes; i++) {
		node = nodeList[i];
		dstat = node->dagHdr->status;
		RF_ASSERT((node->status == rf_wait) ||
		    (node->status == rf_good));
		if (rf_NodeReady(node)) {
			if ((dstat == rf_enable) || (dstat == rf_rollForward)) {
				RF_ASSERT(node->status == rf_wait);
				if (node->commitNode)
					node->dagHdr->numCommits++;
				node->status = rf_fired;
				for (j = 0; j < node->numAntecedents; j++)
					node->antecedents[j]->numSuccFired++;
			} else {
				RF_ASSERT(dstat == rf_rollBackward);
				RF_ASSERT(node->status == rf_good);
				/* Only one commit node per graph. */
				RF_ASSERT(node->commitNode == RF_FALSE);
				node->status = rf_recover;
			}
		}
	}
	/* Now, fire the nodes. */
	for (i = 0; i < numNodes; i++) {
		if ((nodeList[i]->status == rf_fired) ||
		    (nodeList[i]->status == rf_recover))
			rf_FireNode(nodeList[i]);
	}
}


/*
 * User context:
 * Attempt to fire each node in a linked list.
 * The entire list is fired atomically.
 */
void
rf_FireNodeList(RF_DagNode_t *nodeList)
{
	RF_DagNode_t *node, *next;
	RF_DagStatus_t dstat;
	int j;

	if (nodeList) {
		/* First, mark all nodes which are ready to be fired. */
		for (node = nodeList; node; node = next) {
			next = node->next;
			dstat = node->dagHdr->status;
			RF_ASSERT((node->status == rf_wait) ||
			    (node->status == rf_good));
			if (rf_NodeReady(node)) {
				if ((dstat == rf_enable) ||
				    (dstat == rf_rollForward)) {
					RF_ASSERT(node->status == rf_wait);
					if (node->commitNode)
						node->dagHdr->numCommits++;
					node->status = rf_fired;
					for (j = 0; j < node->numAntecedents;
					     j++)
						node->antecedents[j]
						    ->numSuccFired++;
				} else {
					RF_ASSERT(dstat == rf_rollBackward);
					RF_ASSERT(node->status == rf_good);
					/* Only one commit node per graph. */
					RF_ASSERT(node->commitNode == RF_FALSE);
					node->status = rf_recover;
				}
			}
		}
		/* Now, fire the nodes. */
		for (node = nodeList; node; node = next) {
			next = node->next;
			if ((node->status == rf_fired) ||
			    (node->status == rf_recover))
				rf_FireNode(node);
		}
	}
}


/*
 * Interrupt context:
 * For each succedent,
 *    propagate required results from node to succedent.
 *    increment succedent's numAntDone.
 *    place newly-enable nodes on node queue for firing.
 *
 * To save context switches, we don't place NIL nodes on the node queue,
 * but rather just process them as if they had fired. Note that NIL nodes
 * that are the direct successors of the header will actually get fired by
 * DispatchDAG, which is fine because no context switches are involved.
 *
 * Important:  when running at user level, this can be called by any
 * disk thread, and so the increment and check of the antecedent count
 * must be locked. I used the node queue mutex and locked down the
 * entire function, but this is certainly overkill.
 */
void
rf_PropagateResults(RF_DagNode_t *node, int context)
{
	RF_DagNode_t *s, *a;
	RF_Raid_t *raidPtr;
	int i, ks;
	/* A list of NIL nodes to be finished. */
	RF_DagNode_t *finishlist = NULL;
	/* List of nodes with failed truedata antecedents. */
	RF_DagNode_t *skiplist = NULL;
	RF_DagNode_t *firelist = NULL;	/* A list of nodes to be fired. */
	RF_DagNode_t *q = NULL, *qh = NULL, *next;
	int j, skipNode;

	raidPtr = node->dagHdr->raidPtr;

	DO_LOCK(raidPtr);

	/* Debug - validate fire counts. */
	for (i = 0; i < node->numAntecedents; i++) {
		a = *(node->antecedents + i);
		RF_ASSERT(a->numSuccFired >= a->numSuccDone);
		RF_ASSERT(a->numSuccFired <= a->numSuccedents);
		a->numSuccDone++;
	}

	switch (node->dagHdr->status) {
	case rf_enable:
	case rf_rollForward:
		for (i = 0; i < node->numSuccedents; i++) {
			s = *(node->succedents + i);
			RF_ASSERT(s->status == rf_wait);
			(s->numAntDone)++;
			if (s->numAntDone == s->numAntecedents) {
				/* Look for NIL nodes. */
				if (s->doFunc == rf_NullNodeFunc) {
					/*
					 * Don't fire NIL nodes, just process
					 * them.
					 */
					s->next = finishlist;
					finishlist = s;
				} else {
					/*
					 * Look to see if the node is to be
					 * skipped.
					 */
					skipNode = RF_FALSE;
					for (j = 0; j < s->numAntecedents; j++)
						if ((s->antType[j] ==
						     rf_trueData) &&
						    (s->antecedents[j]->status
						     == rf_bad))
							skipNode = RF_TRUE;
					if (skipNode) {
						/*
						 * This node has one or more
						 * failed true data
						 * dependencies, so skip it.
						 */
						s->next = skiplist;
						skiplist = s;
					} else {
						/*
						 * Add s to list of nodes (q)
						 * to execute.
						 */
						if (context != RF_INTR_CONTEXT)
						{
							/*
							 * We only have to
							 * enqueue if we're at
							 * intr context.
							 */
							/*
							 * Put node on a list to
							 * be fired after we
							 * unlock.
							 */
							s->next = firelist;
							firelist = s;
						} else {
							/*
							 * Enqueue the node for
							 * the dag exec thread
							 * to fire.
							 */
						     RF_ASSERT(rf_NodeReady(s));
							if (q) {
								q->next = s;
								q = s;
							} else {
								qh = q = s;
								qh->next = NULL;
							}
						}
					}
				}
			}
		}

		if (q) {
			/*
			 * Transfer our local list of nodes to the node
			 * queue.
			 */
			q->next = raidPtr->node_queue;
			raidPtr->node_queue = qh;
			DO_SIGNAL(raidPtr);
		}
		DO_UNLOCK(raidPtr);

		for (; skiplist; skiplist = next) {
			next = skiplist->next;
			skiplist->status = rf_skipped;
			for (i = 0; i < skiplist->numAntecedents; i++) {
				skiplist->antecedents[i]->numSuccFired++;
			}
			if (skiplist->commitNode) {
				skiplist->dagHdr->numCommits++;
			}
			rf_FinishNode(skiplist, context);
		}
		for (; finishlist; finishlist = next) {
			/* NIL nodes: no need to fire them. */
			next = finishlist->next;
			finishlist->status = rf_good;
			for (i = 0; i < finishlist->numAntecedents; i++) {
				finishlist->antecedents[i]->numSuccFired++;
			}
			if (finishlist->commitNode)
				finishlist->dagHdr->numCommits++;
			/*
			 * Okay, here we're calling rf_FinishNode() on nodes
			 * that have the null function as their work proc.
			 * Such a node could be the terminal node in a DAG.
			 * If so, it will cause the DAG to complete, which will
			 * in turn free memory used by the DAG, which includes
			 * the node in question.
			 * Thus, we must avoid referencing the node at all
			 * after calling rf_FinishNode() on it.
			 */
			/* Recursive call. */
			rf_FinishNode(finishlist, context);
		}
		/* Fire all nodes in firelist. */
		rf_FireNodeList(firelist);
		break;

	case rf_rollBackward:
		for (i = 0; i < node->numAntecedents; i++) {
			a = *(node->antecedents + i);
			RF_ASSERT(a->status == rf_good);
			RF_ASSERT(a->numSuccDone <= a->numSuccedents);
			RF_ASSERT(a->numSuccDone <= a->numSuccFired);

			if (a->numSuccDone == a->numSuccFired) {
				if (a->undoFunc == rf_NullNodeFunc) {
					/*
					 * Don't fire NIL nodes, just process
					 * them.
					 */
					a->next = finishlist;
					finishlist = a;
				} else {
					if (context != RF_INTR_CONTEXT) {
						/*
						 * We only have to enqueue if
						 * we're at intr context.
						 */
						/*
						 * Put node on a list to
						 * be fired after we
						 * unlock.
						 */
						a->next = firelist;
						firelist = a;
					} else {
						/*
						 * Enqueue the node for
						 * the dag exec thread
						 * to fire.
						 */
						RF_ASSERT(rf_NodeReady(a));
						if (q) {
							q->next = a;
							q = a;
						} else {
							qh = q = a;
							qh->next = NULL;
						}
					}
				}
			}
		}
		if (q) {
			/*
			 * Transfer our local list of nodes to the node
			 * queue.
			 */
			q->next = raidPtr->node_queue;
			raidPtr->node_queue = qh;
			DO_SIGNAL(raidPtr);
		}
		DO_UNLOCK(raidPtr);
		for (; finishlist; finishlist = next) {
			/* NIL nodes: no need to fire them. */
			next = finishlist->next;
			finishlist->status = rf_good;
			/*
			 * Okay, here we're calling rf_FinishNode() on nodes
			 * that have the null function as their work proc.
			 * Such a node could be the first node in a DAG.
			 * If so, it will cause the DAG to complete, which will
			 * in turn free memory used by the DAG, which includes
			 * the node in question.
			 * Thus, we must avoid referencing the node at all
			 * after calling rf_FinishNode() on it.
			 */
			rf_FinishNode(finishlist, context);
			/* Recursive call. */
		}
		/* Fire all nodes in firelist. */
		rf_FireNodeList(firelist);

		break;
	default:
		printf("Engine found illegal DAG status in"
		    " rf_PropagateResults()\n");
		RF_PANIC();
		break;
	}
}


/*
 * Process a fired node which has completed.
 */
void
rf_ProcessNode(RF_DagNode_t *node, int context)
{
	RF_Raid_t *raidPtr;

	raidPtr = node->dagHdr->raidPtr;

	switch (node->status) {
	case rf_good:
		/* Normal case, don't need to do anything. */
		break;
	case rf_bad:
		if ((node->dagHdr->numCommits > 0) ||
		    (node->dagHdr->numCommitNodes == 0)) {
			/* Crossed commit barrier. */
			node->dagHdr->status = rf_rollForward;
			if (rf_engineDebug || 1) {
				printf("raid%d: node (%s) returned fail,"
				    " rolling forward\n", raidPtr->raidid,
				    node->name);
			}
		} else {
			/* Never reached commit barrier. */
			node->dagHdr->status = rf_rollBackward;
			if (rf_engineDebug || 1) {
				printf("raid%d: node (%s) returned fail,"
				    " rolling backward\n", raidPtr->raidid,
				    node->name);
			}
		}
		break;
	case rf_undone:
		/* Normal rollBackward case, don't need to do anything. */
		break;
	case rf_panic:
		/* An undo node failed !!! */
		printf("UNDO of a node failed !!!/n");
		break;
	default:
		printf("node finished execution with an illegal status !!!\n");
		RF_PANIC();
		break;
	}

	/*
	 * Enqueue node's succedents (antecedents if rollBackward) for
	 * execution.
	 */
	rf_PropagateResults(node, context);
}


/*
 * User context or dag-exec-thread context:
 * This is the first step in post-processing a newly-completed node.
 * This routine is called by each node execution function to mark the node
 * as complete and fire off any successors that have been enabled.
 */
int
rf_FinishNode(RF_DagNode_t *node, int context)
{
	/* As far as I can tell, retcode is not used -wvcii. */
	int retcode = RF_FALSE;
	node->dagHdr->numNodesCompleted++;
	rf_ProcessNode(node, context);

	return (retcode);
}


/*
 * User context:
 * Submit dag for execution, return non-zero if we have to wait for completion.
 * If and only if we return non-zero, we'll cause cbFunc to get invoked with
 * cbArg when the DAG has completed.
 *
 * For now we always return 1. If the DAG does not cause any I/O, then the
 * callback may get invoked before DispatchDAG returns. There's code in state
 * 5 of ContinueRaidAccess to handle this.
 *
 * All we do here is fire the direct successors of the header node. The DAG
 * execution thread does the rest of the dag processing.
 */
int
rf_DispatchDAG(RF_DagHeader_t *dag, void (*cbFunc) (void *), void *cbArg)
{
	RF_Raid_t *raidPtr;

	raidPtr = dag->raidPtr;
	if (dag->tracerec) {
		RF_ETIMER_START(dag->tracerec->timer);
	}
	if (rf_engineDebug || rf_validateDAGDebug) {
		if (rf_ValidateDAG(dag))
			RF_PANIC();
	}
	if (rf_engineDebug>1) {
		printf("raid%d: Entering DispatchDAG\n", raidPtr->raidid);
	}
	raidPtr->dags_in_flight++;	/*
					 * Debug only:  blow off proper
					 * locking.
					 */
	dag->cbFunc = cbFunc;
	dag->cbArg = cbArg;
	dag->numNodesCompleted = 0;
	dag->status = rf_enable;
	rf_FireNodeArray(dag->numSuccedents, dag->succedents);
	return (1);
}


/*
 * Dedicated kernel thread:
 * The thread that handles all DAG node firing.
 * To minimize locking and unlocking, we grab a copy of the entire node queue
 * and then set the node queue to NULL before doing any firing of nodes.
 * This way we only have to release the lock once. Of course, it's probably
 * rare that there's more than one node in the queue at any one time, but it
 * sometimes happens.
 *
 * In the kernel, this thread runs at spl0 and is not swappable. I copied these
 * characteristics from the aio_completion_thread.
 */

#ifdef	RAID_AUTOCONFIG
void
rf_DAGExecutionThread_pre(RF_ThreadArg_t arg)
{
	RF_Raid_t *raidPtr;
	char raidname[16];
	pid_t oldpid = lastpid;

	raidPtr = (RF_Raid_t *) arg;

	if (rf_engineDebug) {
		printf("raid%d: Starting engine thread\n", raidPtr->raidid);
	}

	lastpid = RF_ENGINE_PID + raidPtr->raidid - 1;
	snprintf(raidname, sizeof raidname, "raid%d", raidPtr->raidid);

	if (RF_CREATE_THREAD(raidPtr->engine_thread, rf_DAGExecutionThread,
	    raidPtr, &raidname[0])) {
		RF_ERRORMSG("RAIDFRAME: Unable to start engine thread\n");
		return;
	}

	lastpid = oldpid;
	if (rf_engineDebug) {
		printf("raid%d: Engine thread started\n", raidPtr->raidid);
	}
	RF_THREADGROUP_STARTED(&raidPtr->engine_tg);
}
#endif	/* RAID_AUTOCONFIG */

void
rf_DAGExecutionThread(RF_ThreadArg_t arg)
{
	RF_DagNode_t *nd, *local_nq, *term_nq, *fire_nq;
	RF_Raid_t *raidPtr;
	int ks;
	int s;

	raidPtr = (RF_Raid_t *) arg;

	while (!(&raidPtr->engine_tg)->created)
		(void) tsleep((void *)&(&raidPtr->engine_tg)->created, PWAIT,
				"raidinit", 0);

	if (rf_engineDebug) {
		printf("raid%d: Engine thread is running\n", raidPtr->raidid);
	}
	/* XXX What to put here ? XXX */

	s = splbio();

	RF_THREADGROUP_RUNNING(&raidPtr->engine_tg);

	rf_hook_cookies[raidPtr->raidid] =
		shutdownhook_establish(rf_shutdown_hook, (void *)raidPtr);

	DO_LOCK(raidPtr);
	while (!raidPtr->shutdown_engine) {

		while (raidPtr->node_queue != NULL) {
			local_nq = raidPtr->node_queue;
			fire_nq = NULL;
			term_nq = NULL;
			raidPtr->node_queue = NULL;
			DO_UNLOCK(raidPtr);

			/* First, strip out the terminal nodes. */
			while (local_nq) {
				nd = local_nq;
				local_nq = local_nq->next;
				switch (nd->dagHdr->status) {
				case rf_enable:
				case rf_rollForward:
					if (nd->numSuccedents == 0) {
						/*
						 * End of the dag, add to
						 * callback list.
						 */
						nd->next = term_nq;
						term_nq = nd;
					} else {
						/*
						 * Not the end, add to the
						 * fire queue.
						 */
						nd->next = fire_nq;
						fire_nq = nd;
					}
					break;
				case rf_rollBackward:
					if (nd->numAntecedents == 0) {
						/*
						 * End of the dag, add to the
						 * callback list.
						 */
						nd->next = term_nq;
						term_nq = nd;
					} else {
						/*
						 * Not the end, add to the
						 * fire queue.
						 */
						nd->next = fire_nq;
						fire_nq = nd;
					}
					break;
				default:
					RF_PANIC();
					break;
				}
			}

			/*
			 * Execute callback of dags which have reached the
			 * terminal node.
			 */
			while (term_nq) {
				nd = term_nq;
				term_nq = term_nq->next;
				nd->next = NULL;
				(nd->dagHdr->cbFunc) (nd->dagHdr->cbArg);
				raidPtr->dags_in_flight--; /* Debug only. */
			}

			/* Fire remaining nodes. */
			rf_FireNodeList(fire_nq);

			DO_LOCK(raidPtr);
		}
		while (!raidPtr->shutdown_engine && raidPtr->node_queue == NULL)
			DO_WAIT(raidPtr);
	}
	DO_UNLOCK(raidPtr);

	if (rf_hook_cookies && rf_hook_cookies[raidPtr->raidid] != NULL) {
		shutdownhook_disestablish(rf_hook_cookies[raidPtr->raidid]);
		rf_hook_cookies[raidPtr->raidid] = NULL;
	}

	RF_THREADGROUP_DONE(&raidPtr->engine_tg);

	splx(s);
	kthread_exit(0);
}
@


1.16
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.15 2003/04/27 11:22:54 ho Exp $	*/
@


1.15
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.14 2003/01/19 14:32:00 tdeval Exp $	*/
d166 2
a167 3
		rf_hook_cookies =
		    malloc(numraid * sizeof(void *),
			   M_RAIDFRAME, M_NOWAIT);
a169 1
		bzero(rf_hook_cookies, numraid * sizeof(void *));
@


1.14
log
@Temporary fix for PR#3069 (thanks for the report, Alex Cichowski), until
I find time to really follow all cases.
At least it works here, and doesn't add new problems, it seems.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.13 2002/12/16 07:01:03 tdeval Exp $	*/
a836 1
	int len;
d846 1
a846 5
	len = sprintf(&raidname[0], "raid%d", raidPtr->raidid);
#ifdef	DIAGNOSTIC
	if (len >= sizeof(raidname))
		panic("raidname expansion too long.");
#endif	/* DIAGNOSTIC */
@


1.13
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.12 2002/07/15 18:42:06 art Exp $	*/
d162 2
a163 1
		printf("raid%d: Creating engine thread\n", raidPtr->raidid);
d183 1
a183 1
			RF_ERRORMSG("RAIDFRAME: Unable to create engine"
d188 1
a188 1
			printf("raid%d: Created engine thread\n",
d310 1
a310 1
		if (rf_engineDebug) {
d331 1
a331 1
		if (rf_engineDebug) {
d802 1
a802 1
	if (rf_engineDebug) {
d843 1
a843 1
		printf("raid%d: Creating engine thread\n", raidPtr->raidid);
d855 1
a855 1
		RF_ERRORMSG("RAIDFRAME: Unable to create engine thread\n");
d861 1
a861 1
		printf("raid%d: Created engine thread\n", raidPtr->raidid);
@


1.12
log
@No need to disestablish the startuphook.
It's done automatically now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.11 2002/03/14 03:16:07 millert Exp $	*/
d3 1
d33 1
a33 1
 * engine.c -- code for DAG execution engine                                *
d37 3
a39 3
 *   are direct successors to the header node.  DispatchDAG then returns,   *
 *   and the rest of the I/O continues asynchronously.  As each node        *
 *   completes, the node execution function calls FinishNode().  FinishNode *
d41 2
a42 2
 *   counts.  Each node that becomes enabled is placed on a central node    *
 *   queue.  A dedicated dag-execution thread grabs nodes off of this       *
d53 2
a54 2
 *   node in the graph.  If the failure occurred before the commit node in   *
 *   the graph, backward recovery is used.  Otherwise, forward recovery is  *
d71 10
a80 3
void	DAGExecutionThread(RF_ThreadArg_t arg);
#ifdef RAID_AUTOCONFIG
void	DAGExecutionThread_pre(RF_ThreadArg_t arg);
d82 1
d88 11
a98 21
#define DO_INIT(_l_,_r_) { \
  int _rc; \
  _rc = rf_create_managed_mutex(_l_,&(_r_)->node_queue_mutex); \
  if (_rc) { \
    return(_rc); \
  } \
  _rc = rf_create_managed_cond(_l_,&(_r_)->node_queue_cond); \
  if (_rc) { \
    return(_rc); \
  } \
}

/* synchronization primitives for this file.  DO_WAIT should be enclosed in a while loop. */

/*
 * XXX Is this spl-ing really necessary?
 */
#define DO_LOCK(_r_) \
do { \
	ks = splbio(); \
	RF_LOCK_MUTEX((_r_)->node_queue_mutex); \
d101 18
a118 4
#define DO_UNLOCK(_r_) \
do { \
	RF_UNLOCK_MUTEX((_r_)->node_queue_mutex); \
	splx(ks); \
d121 1
a121 1
#define DO_WAIT(_r_) \
d125 1
a125 1
#define DO_SIGNAL(_r_) \
d130 2
a131 3
void 
rf_ShutdownEngine(arg)
	void   *arg;
d140 3
a142 5
int 
rf_ConfigureEngine(
    RF_ShutdownList_t ** listp,
    RF_Raid_t * raidPtr,
    RF_Config_t * cfgPtr)
d144 2
a145 2
	int     rc;
	char	raidname[16];
d156 2
a157 1
	/* we create the execution thread only once per system boot. no need
d159 2
a160 1
	 * thread. */
d172 1
a172 1
#ifdef RAID_AUTOCONFIG
d175 2
a176 1
			startuphook_establish(DAGExecutionThread_pre, raidPtr);
d181 3
a183 2
		    DAGExecutionThread, raidPtr, &raidname[0])) {
			RF_ERRORMSG("RAIDFRAME: Unable to create engine thread\n");
d187 2
a188 1
			printf("raid%d: Created engine thread\n", raidPtr->raidid);
d191 1
a191 1
#ifdef RAID_AUTOCONFIG
d194 3
a196 3
	/* XXX something is missing here... */
#ifdef debug
	printf("Skipping the WAIT_START!!\n");
d198 1
a198 1
	/* engine thread is now running and waiting for work */
d200 2
a201 1
		printf("raid%d: Engine thread running and waiting for events\n", raidPtr->raidid);
d205 2
a206 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n", __FILE__,
		    __LINE__, rc);
d212 2
a213 2
static int 
BranchDone(RF_DagNode_t * node)
d215 1
a215 1
	int     i;
d217 4
a220 2
	/* return true if forward execution is completed for a node and it's
	 * succedents */
d223 1
a223 1
		/* should never be called in this state */
d227 1
a227 1
		/* node is currently executing, so we're not done */
d230 4
a233 3
		for (i = 0; i < node->numSuccedents; i++)	/* for each succedent */
			if (!BranchDone(node->succedents[i]))	/* recursively check
								 * branch */
d235 5
a239 2
		return RF_TRUE;	/* node and all succedent branches aren't in
				 * fired state */
d242 1
a242 1
		/* succedents can't fire */
d245 1
a245 1
		/* should never be called in this state */
d250 2
a251 2
		/* XXX need to fix this case */
		/* for now, assume that we're done */
d255 1
a255 1
		/* illegal node status */
d261 2
a262 2
static int 
NodeReady(RF_DagNode_t * node)
d264 1
a264 1
	int     ready;
d269 2
a270 1
		if ((node->status == rf_wait) && (node->numAntecedents == node->numAntDone))
d279 2
a280 1
		if ((node->status == rf_good) && (node->numSuccDone == node->numSuccedents))
d286 2
a287 1
		printf("Execution engine found illegal DAG status in NodeReady\n");
d296 3
a298 3

/* user context and dag-exec-thread context:
 * Fire a node.  The node's status field determines which function, do or undo,
d303 2
a304 2
static void 
FireNode(RF_DagNode_t * node)
d308 1
a308 1
		/* fire the do function of a node */
d310 3
a312 3
			printf("raid%d: Firing node 0x%lx (%s)\n", 
			       node->dagHdr->raidPtr->raidid, 
			       (unsigned long) node, node->name);
d318 4
a321 2
			/* XXX thread_block is actually mentioned in
			 * /usr/include/vm/vm_extern.h */
d329 1
a329 1
		/* fire the undo function of a node */
d331 3
a333 3
			printf("raid%d: Firing (undo) node 0x%lx (%s)\n", 
			       node->dagHdr->raidPtr->raidid,
			       (unsigned long) node, node->name);
d339 4
a342 2
			/* XXX thread_block is actually mentioned in
			 * /usr/include/vm/vm_extern.h */
d346 1
a346 1
                }
d356 2
a357 2

/* user context:
d361 2
a362 4
static void 
FireNodeArray(
    int numNodes,
    RF_DagNode_t ** nodeList)
d366 1
a366 1
	int     i, j;
d368 1
a368 1
	/* first, mark all nodes which are ready to be fired */
d372 3
a374 2
		RF_ASSERT((node->status == rf_wait) || (node->status == rf_good));
		if (NodeReady(node)) {
d385 2
a386 2
				RF_ASSERT(node->commitNode == RF_FALSE);	/* only one commit node
										 * per graph */
d391 1
a391 1
	/* now, fire the nodes */
d393 3
a395 2
		if ((nodeList[i]->status == rf_fired) || (nodeList[i]->status == rf_recover))
			FireNode(nodeList[i]);
d400 2
a401 1
/* user context:
d405 2
a406 2
static void 
FireNodeList(RF_DagNode_t * nodeList)
d410 1
a410 1
	int     j;
d413 1
a413 1
		/* first, mark all nodes which are ready to be fired */
d417 5
a421 3
			RF_ASSERT((node->status == rf_wait) || (node->status == rf_good));
			if (NodeReady(node)) {
				if ((dstat == rf_enable) || (dstat == rf_rollForward)) {
d426 4
a429 2
					for (j = 0; j < node->numAntecedents; j++)
						node->antecedents[j]->numSuccFired++;
d433 2
a434 2
					RF_ASSERT(node->commitNode == RF_FALSE);	/* only one commit node
											 * per graph */
d439 1
a439 1
		/* now, fire the nodes */
d442 3
a444 2
			if ((node->status == rf_fired) || (node->status == rf_recover))
				FireNode(node);
d448 8
a455 5
/* interrupt context:
 * for each succedent
 *    propagate required results from node to succedent
 *    increment succedent's numAntDone
 *    place newly-enable nodes on node queue for firing
d458 1
a458 1
 * but rather just process them as if they had fired.  Note that NIL nodes
d464 1
a464 1
 * must be locked.  I used the node queue mutex and locked down the
d467 2
a468 4
static void 
PropagateResults(
    RF_DagNode_t * node,
    int context)
d472 6
a477 6
	int     i, ks;
	RF_DagNode_t *finishlist = NULL;	/* a list of NIL nodes to be
						 * finished */
	RF_DagNode_t *skiplist = NULL;	/* list of nodes with failed truedata
					 * antecedents */
	RF_DagNode_t *firelist = NULL;	/* a list of nodes to be fired */
d479 1
a479 1
	int     j, skipNode;
d485 1
a485 1
	/* debug - validate fire counts */
d501 1
a501 1
				/* look for NIL nodes */
d503 4
a506 2
					/* don't fire NIL nodes, just process
					 * them */
d510 4
a513 2
					/* look to see if the node is to be
					 * skipped */
d516 4
a519 1
						if ((s->antType[j] == rf_trueData) && (s->antecedents[j]->status == rf_bad))
d522 2
a523 1
						/* this node has one or more
d525 2
a526 1
						 * dependencies, so skip it */
d529 9
a537 5
					} else
						/* add s to list of nodes (q)
						 * to execute */
						if (context != RF_INTR_CONTEXT) {
							/* we only have to
d539 8
a546 4
							 * intr context */
							s->next = firelist;	/* put node on a list to
										 * be fired after we
										 * unlock */
d548 7
a554 4
						} else {	/* enqueue the node for
								 * the dag exec thread
								 * to fire */
							RF_ASSERT(NodeReady(s));
d563 1
d569 4
a572 1
			/* xfer our local list of nodes to the node queue */
d591 1
a591 1
			/* NIL nodes: no need to fire them */
d600 11
a610 9
		         * Okay, here we're calling rf_FinishNode() on nodes that
		         * have the null function as their work proc. Such a node
		         * could be the terminal node in a DAG. If so, it will
		         * cause the DAG to complete, which will in turn free
		         * memory used by the DAG, which includes the node in
		         * question. Thus, we must avoid referencing the node
		         * at all after calling rf_FinishNode() on it.
		         */
			rf_FinishNode(finishlist, context);	/* recursive call */
d612 2
a613 2
		/* fire all nodes in firelist */
		FireNodeList(firelist);
d625 4
a628 2
					/* don't fire NIL nodes, just process
					 * them */
d633 10
a642 5
						/* we only have to enqueue if
						 * we're at intr context */
						a->next = firelist;	/* put node on a list to
									 * be fired after we
									 * unlock */
d644 7
a650 4
					} else {	/* enqueue the node for
							 * the dag exec thread
							 * to fire */
						RF_ASSERT(NodeReady(a));
d663 4
a666 1
			/* xfer our local list of nodes to the node queue */
d672 2
a673 2
		for (; finishlist; finishlist = next) {	/* NIL nodes: no need to
							 * fire them */
d677 11
a687 9
		         * Okay, here we're calling rf_FinishNode() on nodes that
		         * have the null function as their work proc. Such a node
		         * could be the first node in a DAG. If so, it will
		         * cause the DAG to complete, which will in turn free
		         * memory used by the DAG, which includes the node in
		         * question. Thus, we must avoid referencing the node
		         * at all after calling rf_FinishNode() on it.
		         */
			rf_FinishNode(finishlist, context);	/* recursive call */
d689 2
a690 2
		/* fire all nodes in firelist */
		FireNodeList(firelist);
d694 2
a695 1
		printf("Engine found illegal DAG status in PropagateResults()\n");
a701 1

d703 1
a703 1
 * Process a fired node which has completed
d705 2
a706 4
static void 
ProcessNode(
    RF_DagNode_t * node,
    int context)
d714 1
a714 1
		/* normal case, don't need to do anything */
d717 4
a720 3
		if ((node->dagHdr->numCommits > 0) || (node->dagHdr->numCommitNodes == 0)) {
			node->dagHdr->status = rf_rollForward;	/* crossed commit
								 * barrier */
d722 3
a724 1
				printf("raid%d: node (%s) returned fail, rolling forward\n", raidPtr->raidid, node->name);
d727 2
a728 2
			node->dagHdr->status = rf_rollBackward;	/* never reached commit
								 * barrier */
d730 3
a732 1
				printf("raid%d: node (%s) returned fail, rolling backward\n", raidPtr->raidid, node->name);
d737 1
a737 1
		/* normal rollBackward case, don't need to do anything */
d740 2
a741 2
		/* an undo node failed!!! */
		printf("UNDO of a node failed!!!/n");
d744 1
a744 1
		printf("node finished execution with an illegal status!!!\n");
d749 5
a753 3
	/* enqueue node's succedents (antecedents if rollBackward) for
	 * execution */
	PropagateResults(node, context);
d757 2
a758 2

/* user context or dag-exec-thread context:
d763 2
a764 4
int 
rf_FinishNode(
    RF_DagNode_t * node,
    int context)
d766 2
a767 2
	/* as far as I can tell, retcode is not used -wvcii */
	int     retcode = RF_FALSE;
d769 1
a769 1
	ProcessNode(node, context);
d775 4
a778 3
/* user context:
 * submit dag for execution, return non-zero if we have to wait for completion.
 * if and only if we return non-zero, we'll cause cbFunc to get invoked with
d781 9
a789 12
 * for now we always return 1.  If the DAG does not cause any I/O, then the callback
 * may get invoked before DispatchDAG returns.  There's code in state 5 of ContinueRaidAccess
 * to handle this.
 *
 * All we do here is fire the direct successors of the header node.  The
 * DAG execution thread does the rest of the dag processing.
 */
int 
rf_DispatchDAG(
    RF_DagHeader_t * dag,
    void (*cbFunc) (void *),
    void *cbArg)
d804 4
a807 2
	raidPtr->dags_in_flight++;	/* debug only:  blow off proper
					 * locking */
d812 1
a812 1
	FireNodeArray(dag->numSuccedents, dag->succedents);
d815 10
a824 6
/* dedicated kernel thread:
 * the thread that handles all DAG node firing.
 * To minimize locking and unlocking, we grab a copy of the entire node queue and then set the
 * node queue to NULL before doing any firing of nodes.  This way we only have to release the
 * lock once.  Of course, it's probably rare that there's more than one node in the queue at
 * any one time, but it sometimes happens.
d826 1
a826 1
 * In the kernel, this thread runs at spl0 and is not swappable.  I copied these
d830 3
a832 3
#ifdef RAID_AUTOCONFIG
void 
DAGExecutionThread_pre(RF_ThreadArg_t arg)
d847 1
a847 1
#ifdef DIAGNOSTIC
d850 1
a850 1
#endif /* DIAGNOSTIC */
d852 1
a852 1
	if (RF_CREATE_THREAD(raidPtr->engine_thread, DAGExecutionThread,
d866 2
a867 2
void 
DAGExecutionThread(RF_ThreadArg_t arg)
d871 2
a872 2
	int     ks;
	int     s;
d883 1
a883 1
	/* XXX what to put here XXX */
d902 1
a902 1
			/* first, strip out the terminal nodes */
d910 4
a913 2
						/* end of the dag, add to
						 * callback list */
d917 4
a920 2
						/* not the end, add to the
						 * fire queue */
d927 4
a930 2
						/* end of the dag, add to the
						 * callback list */
d934 4
a937 2
						/* not the end, add to the
						 * fire queue */
d948 4
a951 2
			/* execute callback of dags which have reached the
			 * terminal node */
d957 1
a957 1
				raidPtr->dags_in_flight--;	/* debug only */
d960 2
a961 2
			/* fire remaining nodes */
			FireNodeList(fire_nq);
@


1.11
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.10 2002/03/08 09:25:57 tdeval Exp $	*/
a755 5

	if (rf_hook_cookies && rf_hook_cookies[raidPtr->raidid] != NULL) {
		startuphook_disestablish(rf_hook_cookies[raidPtr->raidid]);
		rf_hook_cookies[raidPtr->raidid] = NULL;
	}
@


1.10
log
@numraid is needed, always.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.9 2002/03/06 11:28:27 tdeval Exp $	*/
d154 1
a154 1
		    malloc(numraid * sizeof(void*),
d158 1
a158 1
		bzero(rf_hook_cookies, numraid * sizeof(void*));
d798 1
a798 1
		(void) tsleep((void*)&(&raidPtr->engine_tg)->created, PWAIT,
d811 1
a811 1
		shutdownhook_establish(rf_shutdown_hook, (void*)raidPtr);
@


1.9
log
@Implement a shutdown hook.
We now can safely swap on raid.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.8 2002/02/16 00:56:23 tdeval Exp $	*/
d70 1
d72 1
a73 1
extern int	  numraid;
a74 1
void	DAGExecutionThread_pre(RF_ThreadArg_t arg);
d76 2
a77 2
void	DAGExecutionThread(RF_ThreadArg_t arg);
void	**rf_hook_cookies;
@


1.8
log
@Cope with the new pid allocation semantic from nordin@@
ok nordin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.7 2001/12/29 21:51:18 tdeval Exp $	*/
d74 1
a74 2
static void	**rf_startuphook_cookie;
void DAGExecutionThread_pre(RF_ThreadArg_t arg);
d76 2
a77 1
void DAGExecutionThread(RF_ThreadArg_t arg);
d152 8
d162 1
a162 9
		if (rf_startuphook_cookie == NULL) {
			rf_startuphook_cookie =
			    malloc(numraid * sizeof(void*),
				   M_RAIDFRAME, M_NOWAIT);
			if (rf_startuphook_cookie == NULL)
				return (ENOMEM);
			bzero(rf_startuphook_cookie, numraid * sizeof(void*));
		}
		rf_startuphook_cookie[raidPtr->raidid] =
d757 4
a760 2
	if (rf_startuphook_cookie && rf_startuphook_cookie[raidPtr->raidid])
		startuphook_disestablish(rf_startuphook_cookie[raidPtr->raidid]);
d810 3
d880 5
@


1.7
log
@Enable the RAIDFrame auto-configuration feature.
This permits one to setup a kernel able to automatically retrieve, during
boot, the raid configuration from disks previously used in a RAIDFrame
set.  Moreover, one can define a raid set to contain a bootable partition
that will be mounted on / before the system has started.
A new RAID_AUTOCONFIG kernel option is used, in conjunction with the raid
pseudo-device, to activate the feature.

ok drahn@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.6 2001/09/20 17:02:31 mpech Exp $	*/
a762 1
	lastpid = -2;
d764 1
d776 1
a776 4
	LIST_REMOVE(raidPtr->engine_thread, p_hash);
	raidPtr->engine_thread->p_pid = RF_ENGINE_PID + raidPtr->raidid;
	LIST_INSERT_HEAD(PIDHASH(RF_ENGINE_PID + raidPtr->raidid),
	    raidPtr->engine_thread, p_hash);
@


1.6
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_engine.c,v 1.5 2000/01/11 18:02:21 peter Exp $	*/
/*	$NetBSD: rf_engine.c,v 1.9 2000/01/08 22:57:31 oster Exp $	*/
d70 8
a77 1
static void DAGExecutionThread(RF_ThreadArg_t arg);
d96 18
a113 4
#define DO_LOCK(_r_)      { ks = splbio(); RF_LOCK_MUTEX((_r_)->node_queue_mutex); }
#define DO_UNLOCK(_r_)    { RF_UNLOCK_MUTEX((_r_)->node_queue_mutex); splx(ks); }
#define DO_WAIT(_r_)   tsleep(&(_r_)->node_queue, PRIBIO, "raidframe nq",0)
#define DO_SIGNAL(_r_)    wakeup(&(_r_)->node_queue)
d115 1
a115 1
static void rf_ShutdownEngine(void *);
d117 1
a117 1
static void 
d135 1
d152 25
a176 3
	if (RF_CREATE_THREAD(raidPtr->engine_thread, DAGExecutionThread, raidPtr,"raid")) {
		RF_ERRORMSG("RAIDFRAME: Unable to create engine thread\n");
		return (ENOMEM);
d178 1
a178 4
	if (rf_engineDebug) {
		printf("raid%d: Created engine thread\n", raidPtr->raidid);
	}
	RF_THREADGROUP_STARTED(&raidPtr->engine_tg);
a182 3
#if 0
	RF_THREADGROUP_WAIT_START(&raidPtr->engine_tg);
#endif
d308 1
a308 1
		if (node->flags & RF_DAGNODE_FLAG_YIELD)
d317 1
d746 43
a788 1
static void 
d797 4
@


1.6.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_engine.c,v 1.7 2001/12/29 21:51:18 tdeval Exp $	*/
/*	$NetBSD: rf_engine.c,v 1.10 2000/08/20 16:51:03 thorpej Exp $	*/
d70 1
a70 8
#ifdef RAID_AUTOCONFIG
#define	RF_ENGINE_PID	10
extern int	  numraid;
extern pid_t	  lastpid;
static void	**rf_startuphook_cookie;
void DAGExecutionThread_pre(RF_ThreadArg_t arg);
#endif	/* RAID_AUTOCONFIG */
void DAGExecutionThread(RF_ThreadArg_t arg);
d89 4
a92 18
#define DO_LOCK(_r_) \
do { \
	ks = splbio(); \
	RF_LOCK_MUTEX((_r_)->node_queue_mutex); \
} while (0)

#define DO_UNLOCK(_r_) \
do { \
	RF_UNLOCK_MUTEX((_r_)->node_queue_mutex); \
	splx(ks); \
} while (0)

#define DO_WAIT(_r_) \
	RF_WAIT_COND((_r_)->node_queue, (_r_)->node_queue_mutex)

/* XXX RF_SIGNAL_COND? */
#define DO_SIGNAL(_r_) \
	RF_BROADCAST_COND((_r_)->node_queue)
d94 1
a94 1
void rf_ShutdownEngine(void *);
d96 1
a96 1
void 
a113 1
	char	raidname[16];
d130 6
a135 25
#ifdef RAID_AUTOCONFIG
	if (initproc == NULL) {
		if (rf_startuphook_cookie == NULL) {
			rf_startuphook_cookie =
			    malloc(numraid * sizeof(void*),
				   M_RAIDFRAME, M_NOWAIT);
			if (rf_startuphook_cookie == NULL)
				return (ENOMEM);
			bzero(rf_startuphook_cookie, numraid * sizeof(void*));
		}
		rf_startuphook_cookie[raidPtr->raidid] =
			startuphook_establish(DAGExecutionThread_pre, raidPtr);
	} else {
#endif	/* RAID_AUTOCONFIG */
		snprintf(&raidname[0], 16, "raid%d", raidPtr->raidid);
		if (RF_CREATE_THREAD(raidPtr->engine_thread,
		    DAGExecutionThread, raidPtr, &raidname[0])) {
			RF_ERRORMSG("RAIDFRAME: Unable to create engine thread\n");
			return (ENOMEM);
		}
		if (rf_engineDebug) {
			printf("raid%d: Created engine thread\n", raidPtr->raidid);
		}
		RF_THREADGROUP_STARTED(&raidPtr->engine_tg);
#ifdef RAID_AUTOCONFIG
d137 1
a137 1
#endif
d142 3
d270 1
a270 1
		if (node->flags & RF_DAGNODE_FLAG_YIELD) {
a278 1
                }
d707 1
a707 43
#ifdef RAID_AUTOCONFIG
void 
DAGExecutionThread_pre(RF_ThreadArg_t arg)
{
	RF_Raid_t *raidPtr;
	char raidname[16];
	int len;
	pid_t oldpid = lastpid;

	raidPtr = (RF_Raid_t *) arg;

	if (rf_startuphook_cookie && rf_startuphook_cookie[raidPtr->raidid])
		startuphook_disestablish(rf_startuphook_cookie[raidPtr->raidid]);

	if (rf_engineDebug) {
		printf("raid%d: Creating engine thread\n", raidPtr->raidid);
	}
	lastpid = -2;

	len = sprintf(&raidname[0], "raid%d", raidPtr->raidid);
#ifdef DIAGNOSTIC
	if (len >= sizeof(raidname))
		panic("raidname expansion too long.");
#endif /* DIAGNOSTIC */

	if (RF_CREATE_THREAD(raidPtr->engine_thread, DAGExecutionThread,
	    raidPtr, &raidname[0])) {
		RF_ERRORMSG("RAIDFRAME: Unable to create engine thread\n");
		return;
	}
	LIST_REMOVE(raidPtr->engine_thread, p_hash);
	raidPtr->engine_thread->p_pid = RF_ENGINE_PID + raidPtr->raidid;
	LIST_INSERT_HEAD(PIDHASH(RF_ENGINE_PID + raidPtr->raidid),
	    raidPtr->engine_thread, p_hash);
	lastpid = oldpid;
	if (rf_engineDebug) {
		printf("raid%d: Created engine thread\n", raidPtr->raidid);
	}
	RF_THREADGROUP_STARTED(&raidPtr->engine_tg);
}
#endif	/* RAID_AUTOCONFIG */

void 
a715 4

	while (!(&raidPtr->engine_tg)->created)
		(void) tsleep((void*)&(&raidPtr->engine_tg)->created, PWAIT,
				"raidinit", 0);
@


1.6.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.6.4.1 2002/01/31 22:55:38 niklas Exp $	*/
a69 1
void	DAGExecutionThread(RF_ThreadArg_t arg);
a70 1
void	DAGExecutionThread_pre(RF_ThreadArg_t arg);
d72 1
d74 2
d77 1
a77 2
void		**rf_hook_cookies;
extern int	  numraid;
a151 8
	if (rf_hook_cookies == NULL) {
		rf_hook_cookies =
		    malloc(numraid * sizeof(void *),
			   M_RAIDFRAME, M_NOWAIT);
		if (rf_hook_cookies == NULL)
			return (ENOMEM);
		bzero(rf_hook_cookies, numraid * sizeof(void *));
	}
d154 9
a162 1
		rf_hook_cookies[raidPtr->raidid] =
d757 2
a758 4
	if (rf_hook_cookies && rf_hook_cookies[raidPtr->raidid] != NULL) {
		startuphook_disestablish(rf_hook_cookies[raidPtr->raidid]);
		rf_hook_cookies[raidPtr->raidid] = NULL;
	}
d763 1
a764 1
	lastpid = RF_ENGINE_PID + raidPtr->raidid - 1;
d776 4
a779 1

d799 1
a799 1
		(void) tsleep((void *)&(&raidPtr->engine_tg)->created, PWAIT,
a810 3
	rf_hook_cookies[raidPtr->raidid] =
		shutdownhook_establish(rf_shutdown_hook, (void *)raidPtr);

a877 5

	if (rf_hook_cookies && rf_hook_cookies[raidPtr->raidid] != NULL) {
		shutdownhook_disestablish(rf_hook_cookies[raidPtr->raidid]);
		rf_hook_cookies[raidPtr->raidid] = NULL;
	}
@


1.6.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.6.4.2 2002/06/11 03:42:28 art Exp $	*/
d756 5
@


1.6.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d32 1
a32 1
 * engine.c -- Code for DAG execution engine.                               *
d36 3
a38 3
 *   are direct successors to the header node. DispatchDAG then returns,    *
 *   and the rest of the I/O continues asynchronously. As each node         *
 *   completes, the node execution function calls FinishNode(). FinishNode  *
d40 2
a41 2
 *   counts. Each node that becomes enabled is placed on a central node     *
 *   queue. A dedicated dag-execution thread grabs nodes off of this        *
d52 2
a53 2
 *   node in the graph. If the failure occurred before the commit node in   *
 *   the graph, backward recovery is used. Otherwise, forward recovery is   *
d70 3
a72 10
int  rf_BranchDone(RF_DagNode_t *);
int  rf_NodeReady(RF_DagNode_t *);
void rf_FireNode(RF_DagNode_t *);
void rf_FireNodeArray(int, RF_DagNode_t **);
void rf_FireNodeList(RF_DagNode_t *);
void rf_PropagateResults(RF_DagNode_t *, int);
void rf_ProcessNode(RF_DagNode_t *, int);

void rf_DAGExecutionThread(RF_ThreadArg_t);
#ifdef	RAID_AUTOCONFIG
a73 1
void rf_DAGExecutionThread_pre(RF_ThreadArg_t);
d79 21
a99 11
#define	DO_INIT(_l_,_r_)						\
do {									\
	int _rc;							\
	_rc = rf_create_managed_mutex(_l_, &(_r_)->node_queue_mutex);	\
	if (_rc) {							\
		return(_rc);						\
	}								\
	_rc = rf_create_managed_cond(_l_, &(_r_)->node_queue_cond);	\
	if (_rc) {							\
		return(_rc);						\
	}								\
d102 4
a105 18
/*
 * Synchronization primitives for this file. DO_WAIT should be enclosed
 * in a while loop.
 */

/*
 * XXX Is this spl-ing really necessary ?
 */
#define	DO_LOCK(_r_)							\
do {									\
	ks = splbio();							\
	RF_LOCK_MUTEX((_r_)->node_queue_mutex);				\
} while (0)

#define	DO_UNLOCK(_r_)							\
do {									\
	RF_UNLOCK_MUTEX((_r_)->node_queue_mutex);			\
	splx(ks);							\
d108 1
a108 1
#define	DO_WAIT(_r_)							\
d112 1
a112 1
#define	DO_SIGNAL(_r_)							\
d117 3
a119 2
void
rf_ShutdownEngine(void *arg)
d128 5
a132 3
int
rf_ConfigureEngine(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d134 2
a135 2
	int rc;
	char raidname[16];
d146 1
a146 2
	/*
	 * We create the execution thread only once per system boot. No need
d148 1
a148 2
	 * thread.
	 */
d150 1
a150 2
		printf("raid%d: %s engine thread\n", raidPtr->raidid,
		    (initproc)?"Starting":"Creating");
d160 1
a160 1
#ifdef	RAID_AUTOCONFIG
d163 1
a163 2
			startuphook_establish(rf_DAGExecutionThread_pre,
			    raidPtr);
d168 2
a169 3
		    rf_DAGExecutionThread, raidPtr, &raidname[0])) {
			RF_ERRORMSG("RAIDFRAME: Unable to start engine"
			    " thread\n");
d173 1
a173 2
			printf("raid%d: Engine thread started\n",
			    raidPtr->raidid);
d176 1
a176 1
#ifdef	RAID_AUTOCONFIG
d179 3
a181 3
	/* XXX Something is missing here... */
#ifdef	debug
	printf("Skipping the WAIT_START !!!\n");
d183 1
a183 1
	/* Engine thread is now running and waiting for work. */
d185 1
a185 2
		printf("raid%d: Engine thread running and waiting for events\n",
		    raidPtr->raidid);
d189 2
a190 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d\n", __FILE__, __LINE__, rc);
d196 2
a197 2
int
rf_BranchDone(RF_DagNode_t *node)
d199 1
a199 1
	int i;
d201 2
a202 4
	/*
	 * Return true if forward execution is completed for a node and it's
	 * succedents.
	 */
d205 1
a205 1
		/* Should never be called in this state. */
d209 1
a209 1
		/* Node is currently executing, so we're not done. */
d212 3
a214 4
		/* For each succedent. */
		for (i = 0; i < node->numSuccedents; i++)
			/* Recursively check branch. */
			if (!rf_BranchDone(node->succedents[i]))
d216 2
a217 5

		return RF_TRUE;	/*
				 * Node and all succedent branches aren't in
				 * fired state.
				 */
d220 1
a220 1
		/* Succedents can't fire. */
d223 1
a223 1
		/* Should never be called in this state. */
d228 2
a229 2
		/* XXX Need to fix this case. */
		/* For now, assume that we're done. */
d233 1
a233 1
		/* Illegal node status. */
d239 2
a240 2
int
rf_NodeReady(RF_DagNode_t *node)
d242 1
a242 1
	int ready;
d247 1
a247 2
		if ((node->status == rf_wait) &&
		    (node->numAntecedents == node->numAntDone))
d256 1
a256 2
		if ((node->status == rf_good) &&
		    (node->numSuccDone == node->numSuccedents))
d262 1
a262 2
		printf("Execution engine found illegal DAG status"
		    " in rf_NodeReady\n");
d271 3
a273 3
/*
 * User context and dag-exec-thread context:
 * Fire a node. The node's status field determines which function, do or undo,
d278 2
a279 2
void
rf_FireNode(RF_DagNode_t *node)
d283 5
a287 5
		/* Fire the do function of a node. */
		if (rf_engineDebug>1) {
			printf("raid%d: Firing node 0x%lx (%s)\n",
			    node->dagHdr->raidPtr->raidid,
			    (unsigned long) node, node->name);
d293 2
a294 4
			/*
			 * XXX thread_block is actually mentioned in
			 * /usr/include/vm/vm_extern.h
			 */
d302 5
a306 5
		/* Fire the undo function of a node. */
		if (rf_engineDebug>1) {
			printf("raid%d: Firing (undo) node 0x%lx (%s)\n",
			    node->dagHdr->raidPtr->raidid,
			    (unsigned long) node, node->name);
d312 2
a313 4
			/*
			 * XXX thread_block is actually mentioned in
			 * /usr/include/vm/vm_extern.h
			 */
d317 1
a317 1
		}
d327 2
a328 2
/*
 * User context:
d332 4
a335 2
void
rf_FireNodeArray(int numNodes, RF_DagNode_t **nodeList)
d339 1
a339 1
	int i, j;
d341 1
a341 1
	/* First, mark all nodes which are ready to be fired. */
d345 2
a346 3
		RF_ASSERT((node->status == rf_wait) ||
		    (node->status == rf_good));
		if (rf_NodeReady(node)) {
d357 2
a358 2
				/* Only one commit node per graph. */
				RF_ASSERT(node->commitNode == RF_FALSE);
d363 1
a363 1
	/* Now, fire the nodes. */
d365 2
a366 3
		if ((nodeList[i]->status == rf_fired) ||
		    (nodeList[i]->status == rf_recover))
			rf_FireNode(nodeList[i]);
d371 1
a371 2
/*
 * User context:
d375 2
a376 2
void
rf_FireNodeList(RF_DagNode_t *nodeList)
d380 1
a380 1
	int j;
d383 1
a383 1
		/* First, mark all nodes which are ready to be fired. */
d387 3
a389 5
			RF_ASSERT((node->status == rf_wait) ||
			    (node->status == rf_good));
			if (rf_NodeReady(node)) {
				if ((dstat == rf_enable) ||
				    (dstat == rf_rollForward)) {
d394 2
a395 4
					for (j = 0; j < node->numAntecedents;
					     j++)
						node->antecedents[j]
						    ->numSuccFired++;
d399 2
a400 2
					/* Only one commit node per graph. */
					RF_ASSERT(node->commitNode == RF_FALSE);
d405 1
a405 1
		/* Now, fire the nodes. */
d408 2
a409 3
			if ((node->status == rf_fired) ||
			    (node->status == rf_recover))
				rf_FireNode(node);
d413 5
a417 8


/*
 * Interrupt context:
 * For each succedent,
 *    propagate required results from node to succedent.
 *    increment succedent's numAntDone.
 *    place newly-enable nodes on node queue for firing.
d420 1
a420 1
 * but rather just process them as if they had fired. Note that NIL nodes
d426 1
a426 1
 * must be locked. I used the node queue mutex and locked down the
d429 4
a432 2
void
rf_PropagateResults(RF_DagNode_t *node, int context)
d436 6
a441 6
	int i, ks;
	/* A list of NIL nodes to be finished. */
	RF_DagNode_t *finishlist = NULL;
	/* List of nodes with failed truedata antecedents. */
	RF_DagNode_t *skiplist = NULL;
	RF_DagNode_t *firelist = NULL;	/* A list of nodes to be fired. */
d443 1
a443 1
	int j, skipNode;
d449 1
a449 1
	/* Debug - validate fire counts. */
d465 1
a465 1
				/* Look for NIL nodes. */
d467 2
a468 4
					/*
					 * Don't fire NIL nodes, just process
					 * them.
					 */
d472 2
a473 4
					/*
					 * Look to see if the node is to be
					 * skipped.
					 */
d476 1
a476 4
						if ((s->antType[j] ==
						     rf_trueData) &&
						    (s->antecedents[j]->status
						     == rf_bad))
d479 1
a479 2
						/*
						 * This node has one or more
d481 1
a481 2
						 * dependencies, so skip it.
						 */
d484 5
a488 9
					} else {
						/*
						 * Add s to list of nodes (q)
						 * to execute.
						 */
						if (context != RF_INTR_CONTEXT)
						{
							/*
							 * We only have to
d490 4
a493 8
							 * intr context.
							 */
							/*
							 * Put node on a list to
							 * be fired after we
							 * unlock.
							 */
							s->next = firelist;
d495 4
a498 7
						} else {
							/*
							 * Enqueue the node for
							 * the dag exec thread
							 * to fire.
							 */
						     RF_ASSERT(rf_NodeReady(s));
a506 1
					}
d512 1
a512 4
			/*
			 * Transfer our local list of nodes to the node
			 * queue.
			 */
d531 1
a531 1
			/* NIL nodes: no need to fire them. */
d540 9
a548 11
			 * Okay, here we're calling rf_FinishNode() on nodes
			 * that have the null function as their work proc.
			 * Such a node could be the terminal node in a DAG.
			 * If so, it will cause the DAG to complete, which will
			 * in turn free memory used by the DAG, which includes
			 * the node in question.
			 * Thus, we must avoid referencing the node at all
			 * after calling rf_FinishNode() on it.
			 */
			/* Recursive call. */
			rf_FinishNode(finishlist, context);
d550 2
a551 2
		/* Fire all nodes in firelist. */
		rf_FireNodeList(firelist);
d563 2
a564 4
					/*
					 * Don't fire NIL nodes, just process
					 * them.
					 */
d569 5
a573 10
						/*
						 * We only have to enqueue if
						 * we're at intr context.
						 */
						/*
						 * Put node on a list to
						 * be fired after we
						 * unlock.
						 */
						a->next = firelist;
d575 4
a578 7
					} else {
						/*
						 * Enqueue the node for
						 * the dag exec thread
						 * to fire.
						 */
						RF_ASSERT(rf_NodeReady(a));
d591 1
a591 4
			/*
			 * Transfer our local list of nodes to the node
			 * queue.
			 */
d597 2
a598 2
		for (; finishlist; finishlist = next) {
			/* NIL nodes: no need to fire them. */
d602 9
a610 11
			 * Okay, here we're calling rf_FinishNode() on nodes
			 * that have the null function as their work proc.
			 * Such a node could be the first node in a DAG.
			 * If so, it will cause the DAG to complete, which will
			 * in turn free memory used by the DAG, which includes
			 * the node in question.
			 * Thus, we must avoid referencing the node at all
			 * after calling rf_FinishNode() on it.
			 */
			rf_FinishNode(finishlist, context);
			/* Recursive call. */
d612 2
a613 2
		/* Fire all nodes in firelist. */
		rf_FireNodeList(firelist);
d617 1
a617 2
		printf("Engine found illegal DAG status in"
		    " rf_PropagateResults()\n");
d624 1
d626 1
a626 1
 * Process a fired node which has completed.
d628 4
a631 2
void
rf_ProcessNode(RF_DagNode_t *node, int context)
d639 1
a639 1
		/* Normal case, don't need to do anything. */
d642 3
a644 4
		if ((node->dagHdr->numCommits > 0) ||
		    (node->dagHdr->numCommitNodes == 0)) {
			/* Crossed commit barrier. */
			node->dagHdr->status = rf_rollForward;
d646 1
a646 3
				printf("raid%d: node (%s) returned fail,"
				    " rolling forward\n", raidPtr->raidid,
				    node->name);
d649 2
a650 2
			/* Never reached commit barrier. */
			node->dagHdr->status = rf_rollBackward;
d652 1
a652 3
				printf("raid%d: node (%s) returned fail,"
				    " rolling backward\n", raidPtr->raidid,
				    node->name);
d657 1
a657 1
		/* Normal rollBackward case, don't need to do anything. */
d660 2
a661 2
		/* An undo node failed !!! */
		printf("UNDO of a node failed !!!/n");
d664 1
a664 1
		printf("node finished execution with an illegal status !!!\n");
d669 3
a671 5
	/*
	 * Enqueue node's succedents (antecedents if rollBackward) for
	 * execution.
	 */
	rf_PropagateResults(node, context);
d675 2
a676 2
/*
 * User context or dag-exec-thread context:
d681 4
a684 2
int
rf_FinishNode(RF_DagNode_t *node, int context)
d686 2
a687 2
	/* As far as I can tell, retcode is not used -wvcii. */
	int retcode = RF_FALSE;
d689 1
a689 1
	rf_ProcessNode(node, context);
d695 3
a697 4
/*
 * User context:
 * Submit dag for execution, return non-zero if we have to wait for completion.
 * If and only if we return non-zero, we'll cause cbFunc to get invoked with
d700 12
a711 9
 * For now we always return 1. If the DAG does not cause any I/O, then the
 * callback may get invoked before DispatchDAG returns. There's code in state
 * 5 of ContinueRaidAccess to handle this.
 *
 * All we do here is fire the direct successors of the header node. The DAG
 * execution thread does the rest of the dag processing.
 */
int
rf_DispatchDAG(RF_DagHeader_t *dag, void (*cbFunc) (void *), void *cbArg)
d723 1
a723 1
	if (rf_engineDebug>1) {
d726 2
a727 4
	raidPtr->dags_in_flight++;	/*
					 * Debug only:  blow off proper
					 * locking.
					 */
d732 1
a732 1
	rf_FireNodeArray(dag->numSuccedents, dag->succedents);
d735 6
a740 10


/*
 * Dedicated kernel thread:
 * The thread that handles all DAG node firing.
 * To minimize locking and unlocking, we grab a copy of the entire node queue
 * and then set the node queue to NULL before doing any firing of nodes.
 * This way we only have to release the lock once. Of course, it's probably
 * rare that there's more than one node in the queue at any one time, but it
 * sometimes happens.
d742 1
a742 1
 * In the kernel, this thread runs at spl0 and is not swappable. I copied these
d746 3
a748 3
#ifdef	RAID_AUTOCONFIG
void
rf_DAGExecutionThread_pre(RF_ThreadArg_t arg)
d752 1
d758 1
a758 1
		printf("raid%d: Starting engine thread\n", raidPtr->raidid);
d762 5
a766 1
	snprintf(raidname, sizeof raidname, "raid%d", raidPtr->raidid);
d768 1
a768 1
	if (RF_CREATE_THREAD(raidPtr->engine_thread, rf_DAGExecutionThread,
d770 1
a770 1
		RF_ERRORMSG("RAIDFRAME: Unable to start engine thread\n");
d776 1
a776 1
		printf("raid%d: Engine thread started\n", raidPtr->raidid);
d782 2
a783 2
void
rf_DAGExecutionThread(RF_ThreadArg_t arg)
d787 2
a788 2
	int ks;
	int s;
d799 1
a799 1
	/* XXX What to put here ? XXX */
d818 1
a818 1
			/* First, strip out the terminal nodes. */
d826 2
a827 4
						/*
						 * End of the dag, add to
						 * callback list.
						 */
d831 2
a832 4
						/*
						 * Not the end, add to the
						 * fire queue.
						 */
d839 2
a840 4
						/*
						 * End of the dag, add to the
						 * callback list.
						 */
d844 2
a845 4
						/*
						 * Not the end, add to the
						 * fire queue.
						 */
d856 2
a857 4
			/*
			 * Execute callback of dags which have reached the
			 * terminal node.
			 */
d863 1
a863 1
				raidPtr->dags_in_flight--; /* Debug only. */
d866 2
a867 2
			/* Fire remaining nodes. */
			rf_FireNodeList(fire_nq);
@


1.5
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.4 2000/01/07 14:50:21 peter Exp $	*/
d52 1
a52 1
 *   node in the graph.  If the failure occured before the commit node in   *
@


1.5.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.5 2000/01/11 18:02:21 peter Exp $	*/
d52 1
a52 1
 *   node in the graph.  If the failure occurred before the commit node in   *
@


1.5.2.2
log
@Merge in trunk
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: rf_engine.c,v 1.10 2000/08/20 16:51:03 thorpej Exp $	*/
d70 1
a70 8
#ifdef RAID_AUTOCONFIG
#define	RF_ENGINE_PID	10
extern int	  numraid;
extern pid_t	  lastpid;
static void	**rf_startuphook_cookie;
void DAGExecutionThread_pre(RF_ThreadArg_t arg);
#endif	/* RAID_AUTOCONFIG */
void DAGExecutionThread(RF_ThreadArg_t arg);
d89 4
a92 18
#define DO_LOCK(_r_) \
do { \
	ks = splbio(); \
	RF_LOCK_MUTEX((_r_)->node_queue_mutex); \
} while (0)

#define DO_UNLOCK(_r_) \
do { \
	RF_UNLOCK_MUTEX((_r_)->node_queue_mutex); \
	splx(ks); \
} while (0)

#define DO_WAIT(_r_) \
	RF_WAIT_COND((_r_)->node_queue, (_r_)->node_queue_mutex)

/* XXX RF_SIGNAL_COND? */
#define DO_SIGNAL(_r_) \
	RF_BROADCAST_COND((_r_)->node_queue)
d94 1
a94 1
void rf_ShutdownEngine(void *);
d96 1
a96 1
void 
a113 1
	char	raidname[16];
d130 6
a135 25
#ifdef RAID_AUTOCONFIG
	if (initproc == NULL) {
		if (rf_startuphook_cookie == NULL) {
			rf_startuphook_cookie =
			    malloc(numraid * sizeof(void*),
				   M_RAIDFRAME, M_NOWAIT);
			if (rf_startuphook_cookie == NULL)
				return (ENOMEM);
			bzero(rf_startuphook_cookie, numraid * sizeof(void*));
		}
		rf_startuphook_cookie[raidPtr->raidid] =
			startuphook_establish(DAGExecutionThread_pre, raidPtr);
	} else {
#endif	/* RAID_AUTOCONFIG */
		snprintf(&raidname[0], 16, "raid%d", raidPtr->raidid);
		if (RF_CREATE_THREAD(raidPtr->engine_thread,
		    DAGExecutionThread, raidPtr, &raidname[0])) {
			RF_ERRORMSG("RAIDFRAME: Unable to create engine thread\n");
			return (ENOMEM);
		}
		if (rf_engineDebug) {
			printf("raid%d: Created engine thread\n", raidPtr->raidid);
		}
		RF_THREADGROUP_STARTED(&raidPtr->engine_tg);
#ifdef RAID_AUTOCONFIG
d137 1
a137 1
#endif
d142 3
d270 1
a270 1
		if (node->flags & RF_DAGNODE_FLAG_YIELD) {
a278 1
                }
d707 1
a707 40
#ifdef RAID_AUTOCONFIG
void 
DAGExecutionThread_pre(RF_ThreadArg_t arg)
{
	RF_Raid_t *raidPtr;
	char raidname[16];
	int len;
	pid_t oldpid = lastpid;

	raidPtr = (RF_Raid_t *) arg;

	if (rf_startuphook_cookie && rf_startuphook_cookie[raidPtr->raidid])
		startuphook_disestablish(rf_startuphook_cookie[raidPtr->raidid]);

	if (rf_engineDebug) {
		printf("raid%d: Creating engine thread\n", raidPtr->raidid);
	}

	lastpid = RF_ENGINE_PID + raidPtr->raidid - 1;
	len = sprintf(&raidname[0], "raid%d", raidPtr->raidid);
#ifdef DIAGNOSTIC
	if (len >= sizeof(raidname))
		panic("raidname expansion too long.");
#endif /* DIAGNOSTIC */

	if (RF_CREATE_THREAD(raidPtr->engine_thread, DAGExecutionThread,
	    raidPtr, &raidname[0])) {
		RF_ERRORMSG("RAIDFRAME: Unable to create engine thread\n");
		return;
	}

	lastpid = oldpid;
	if (rf_engineDebug) {
		printf("raid%d: Created engine thread\n", raidPtr->raidid);
	}
	RF_THREADGROUP_STARTED(&raidPtr->engine_tg);
}
#endif	/* RAID_AUTOCONFIG */

void 
a715 4

	while (!(&raidPtr->engine_tg)->created)
		(void) tsleep((void*)&(&raidPtr->engine_tg)->created, PWAIT,
				"raidinit", 0);
@


1.5.2.3
log
@Merge in -current from roughly a week ago
@
text
@a69 1
void	DAGExecutionThread(RF_ThreadArg_t arg);
a70 1
void	DAGExecutionThread_pre(RF_ThreadArg_t arg);
d72 1
d74 2
d77 1
a77 2
void		**rf_hook_cookies;
extern int	  numraid;
a151 8
	if (rf_hook_cookies == NULL) {
		rf_hook_cookies =
		    malloc(numraid * sizeof(void *),
			   M_RAIDFRAME, M_NOWAIT);
		if (rf_hook_cookies == NULL)
			return (ENOMEM);
		bzero(rf_hook_cookies, numraid * sizeof(void *));
	}
d154 9
a162 1
		rf_hook_cookies[raidPtr->raidid] =
d757 2
a758 4
	if (rf_hook_cookies && rf_hook_cookies[raidPtr->raidid] != NULL) {
		startuphook_disestablish(rf_hook_cookies[raidPtr->raidid]);
		rf_hook_cookies[raidPtr->raidid] = NULL;
	}
d796 1
a796 1
		(void) tsleep((void *)&(&raidPtr->engine_tg)->created, PWAIT,
a807 3
	rf_hook_cookies[raidPtr->raidid] =
		shutdownhook_establish(rf_shutdown_hook, (void *)raidPtr);

a874 5

	if (rf_hook_cookies && rf_hook_cookies[raidPtr->raidid] != NULL) {
		shutdownhook_disestablish(rf_hook_cookies[raidPtr->raidid]);
		rf_hook_cookies[raidPtr->raidid] = NULL;
	}
@


1.5.2.4
log
@Sync the SMP branch with 3.3
@
text
@a2 1

d32 1
a32 1
 * engine.c -- Code for DAG execution engine.                               *
d36 3
a38 3
 *   are direct successors to the header node. DispatchDAG then returns,    *
 *   and the rest of the I/O continues asynchronously. As each node         *
 *   completes, the node execution function calls FinishNode(). FinishNode  *
d40 2
a41 2
 *   counts. Each node that becomes enabled is placed on a central node     *
 *   queue. A dedicated dag-execution thread grabs nodes off of this        *
d52 2
a53 2
 *   node in the graph. If the failure occurred before the commit node in   *
 *   the graph, backward recovery is used. Otherwise, forward recovery is   *
d70 3
a72 10
int  rf_BranchDone(RF_DagNode_t *);
int  rf_NodeReady(RF_DagNode_t *);
void rf_FireNode(RF_DagNode_t *);
void rf_FireNodeArray(int, RF_DagNode_t **);
void rf_FireNodeList(RF_DagNode_t *);
void rf_PropagateResults(RF_DagNode_t *, int);
void rf_ProcessNode(RF_DagNode_t *, int);

void rf_DAGExecutionThread(RF_ThreadArg_t);
#ifdef	RAID_AUTOCONFIG
a73 1
void rf_DAGExecutionThread_pre(RF_ThreadArg_t);
d79 21
a99 25
#define	DO_INIT(_l_,_r_)						\
do {									\
	int _rc;							\
	_rc = rf_create_managed_mutex(_l_, &(_r_)->node_queue_mutex);	\
	if (_rc) {							\
		return(_rc);						\
	}								\
	_rc = rf_create_managed_cond(_l_, &(_r_)->node_queue_cond);	\
	if (_rc) {							\
		return(_rc);						\
	}								\
} while (0)

/*
 * Synchronization primitives for this file. DO_WAIT should be enclosed
 * in a while loop.
 */

/*
 * XXX Is this spl-ing really necessary ?
 */
#define	DO_LOCK(_r_)							\
do {									\
	ks = splbio();							\
	RF_LOCK_MUTEX((_r_)->node_queue_mutex);				\
d102 4
a105 4
#define	DO_UNLOCK(_r_)							\
do {									\
	RF_UNLOCK_MUTEX((_r_)->node_queue_mutex);			\
	splx(ks);							\
d108 1
a108 1
#define	DO_WAIT(_r_)							\
d112 1
a112 1
#define	DO_SIGNAL(_r_)							\
d117 3
a119 2
void
rf_ShutdownEngine(void *arg)
d128 5
a132 3
int
rf_ConfigureEngine(RF_ShutdownList_t **listp, RF_Raid_t *raidPtr,
    RF_Config_t *cfgPtr)
d134 2
a135 2
	int rc;
	char raidname[16];
d146 1
a146 2
	/*
	 * We create the execution thread only once per system boot. No need
d148 1
a148 2
	 * thread.
	 */
d150 1
a150 2
		printf("raid%d: %s engine thread\n", raidPtr->raidid,
		    (initproc)?"Starting":"Creating");
d160 1
a160 1
#ifdef	RAID_AUTOCONFIG
d163 1
a163 2
			startuphook_establish(rf_DAGExecutionThread_pre,
			    raidPtr);
d168 2
a169 3
		    rf_DAGExecutionThread, raidPtr, &raidname[0])) {
			RF_ERRORMSG("RAIDFRAME: Unable to start engine"
			    " thread\n");
d173 1
a173 2
			printf("raid%d: Engine thread started\n",
			    raidPtr->raidid);
d176 1
a176 1
#ifdef	RAID_AUTOCONFIG
d179 3
a181 3
	/* XXX Something is missing here... */
#ifdef	debug
	printf("Skipping the WAIT_START !!!\n");
d183 1
a183 1
	/* Engine thread is now running and waiting for work. */
d185 1
a185 2
		printf("raid%d: Engine thread running and waiting for events\n",
		    raidPtr->raidid);
d189 2
a190 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d"
		    " rc=%d\n", __FILE__, __LINE__, rc);
d196 2
a197 2
int
rf_BranchDone(RF_DagNode_t *node)
d199 1
a199 1
	int i;
d201 2
a202 4
	/*
	 * Return true if forward execution is completed for a node and it's
	 * succedents.
	 */
d205 1
a205 1
		/* Should never be called in this state. */
d209 1
a209 1
		/* Node is currently executing, so we're not done. */
d212 3
a214 4
		/* For each succedent. */
		for (i = 0; i < node->numSuccedents; i++)
			/* Recursively check branch. */
			if (!rf_BranchDone(node->succedents[i]))
d216 2
a217 5

		return RF_TRUE;	/*
				 * Node and all succedent branches aren't in
				 * fired state.
				 */
d220 1
a220 1
		/* Succedents can't fire. */
d223 1
a223 1
		/* Should never be called in this state. */
d228 2
a229 2
		/* XXX Need to fix this case. */
		/* For now, assume that we're done. */
d233 1
a233 1
		/* Illegal node status. */
d239 2
a240 2
int
rf_NodeReady(RF_DagNode_t *node)
d242 1
a242 1
	int ready;
d247 1
a247 2
		if ((node->status == rf_wait) &&
		    (node->numAntecedents == node->numAntDone))
d256 1
a256 2
		if ((node->status == rf_good) &&
		    (node->numSuccDone == node->numSuccedents))
d262 1
a262 2
		printf("Execution engine found illegal DAG status"
		    " in rf_NodeReady\n");
d271 3
a273 3
/*
 * User context and dag-exec-thread context:
 * Fire a node. The node's status field determines which function, do or undo,
d278 2
a279 2
void
rf_FireNode(RF_DagNode_t *node)
d283 5
a287 5
		/* Fire the do function of a node. */
		if (rf_engineDebug>1) {
			printf("raid%d: Firing node 0x%lx (%s)\n",
			    node->dagHdr->raidPtr->raidid,
			    (unsigned long) node, node->name);
d293 2
a294 4
			/*
			 * XXX thread_block is actually mentioned in
			 * /usr/include/vm/vm_extern.h
			 */
d302 5
a306 5
		/* Fire the undo function of a node. */
		if (rf_engineDebug>1) {
			printf("raid%d: Firing (undo) node 0x%lx (%s)\n",
			    node->dagHdr->raidPtr->raidid,
			    (unsigned long) node, node->name);
d312 2
a313 4
			/*
			 * XXX thread_block is actually mentioned in
			 * /usr/include/vm/vm_extern.h
			 */
d317 1
a317 1
		}
d327 2
a328 2
/*
 * User context:
d332 4
a335 2
void
rf_FireNodeArray(int numNodes, RF_DagNode_t **nodeList)
d339 1
a339 1
	int i, j;
d341 1
a341 1
	/* First, mark all nodes which are ready to be fired. */
d345 2
a346 3
		RF_ASSERT((node->status == rf_wait) ||
		    (node->status == rf_good));
		if (rf_NodeReady(node)) {
d357 2
a358 2
				/* Only one commit node per graph. */
				RF_ASSERT(node->commitNode == RF_FALSE);
d363 1
a363 1
	/* Now, fire the nodes. */
d365 2
a366 3
		if ((nodeList[i]->status == rf_fired) ||
		    (nodeList[i]->status == rf_recover))
			rf_FireNode(nodeList[i]);
d371 1
a371 2
/*
 * User context:
d375 2
a376 2
void
rf_FireNodeList(RF_DagNode_t *nodeList)
d380 1
a380 1
	int j;
d383 1
a383 1
		/* First, mark all nodes which are ready to be fired. */
d387 3
a389 5
			RF_ASSERT((node->status == rf_wait) ||
			    (node->status == rf_good));
			if (rf_NodeReady(node)) {
				if ((dstat == rf_enable) ||
				    (dstat == rf_rollForward)) {
d394 2
a395 4
					for (j = 0; j < node->numAntecedents;
					     j++)
						node->antecedents[j]
						    ->numSuccFired++;
d399 2
a400 2
					/* Only one commit node per graph. */
					RF_ASSERT(node->commitNode == RF_FALSE);
d405 1
a405 1
		/* Now, fire the nodes. */
d408 2
a409 3
			if ((node->status == rf_fired) ||
			    (node->status == rf_recover))
				rf_FireNode(node);
d413 5
a417 8


/*
 * Interrupt context:
 * For each succedent,
 *    propagate required results from node to succedent.
 *    increment succedent's numAntDone.
 *    place newly-enable nodes on node queue for firing.
d420 1
a420 1
 * but rather just process them as if they had fired. Note that NIL nodes
d426 1
a426 1
 * must be locked. I used the node queue mutex and locked down the
d429 4
a432 2
void
rf_PropagateResults(RF_DagNode_t *node, int context)
d436 6
a441 6
	int i, ks;
	/* A list of NIL nodes to be finished. */
	RF_DagNode_t *finishlist = NULL;
	/* List of nodes with failed truedata antecedents. */
	RF_DagNode_t *skiplist = NULL;
	RF_DagNode_t *firelist = NULL;	/* A list of nodes to be fired. */
d443 1
a443 1
	int j, skipNode;
d449 1
a449 1
	/* Debug - validate fire counts. */
d465 1
a465 1
				/* Look for NIL nodes. */
d467 2
a468 4
					/*
					 * Don't fire NIL nodes, just process
					 * them.
					 */
d472 2
a473 4
					/*
					 * Look to see if the node is to be
					 * skipped.
					 */
d476 1
a476 4
						if ((s->antType[j] ==
						     rf_trueData) &&
						    (s->antecedents[j]->status
						     == rf_bad))
d479 1
a479 2
						/*
						 * This node has one or more
d481 1
a481 2
						 * dependencies, so skip it.
						 */
d484 5
a488 9
					} else {
						/*
						 * Add s to list of nodes (q)
						 * to execute.
						 */
						if (context != RF_INTR_CONTEXT)
						{
							/*
							 * We only have to
d490 4
a493 8
							 * intr context.
							 */
							/*
							 * Put node on a list to
							 * be fired after we
							 * unlock.
							 */
							s->next = firelist;
d495 4
a498 7
						} else {
							/*
							 * Enqueue the node for
							 * the dag exec thread
							 * to fire.
							 */
						     RF_ASSERT(rf_NodeReady(s));
a506 1
					}
d512 1
a512 4
			/*
			 * Transfer our local list of nodes to the node
			 * queue.
			 */
d531 1
a531 1
			/* NIL nodes: no need to fire them. */
d540 9
a548 11
			 * Okay, here we're calling rf_FinishNode() on nodes
			 * that have the null function as their work proc.
			 * Such a node could be the terminal node in a DAG.
			 * If so, it will cause the DAG to complete, which will
			 * in turn free memory used by the DAG, which includes
			 * the node in question.
			 * Thus, we must avoid referencing the node at all
			 * after calling rf_FinishNode() on it.
			 */
			/* Recursive call. */
			rf_FinishNode(finishlist, context);
d550 2
a551 2
		/* Fire all nodes in firelist. */
		rf_FireNodeList(firelist);
d563 2
a564 4
					/*
					 * Don't fire NIL nodes, just process
					 * them.
					 */
d569 5
a573 10
						/*
						 * We only have to enqueue if
						 * we're at intr context.
						 */
						/*
						 * Put node on a list to
						 * be fired after we
						 * unlock.
						 */
						a->next = firelist;
d575 4
a578 7
					} else {
						/*
						 * Enqueue the node for
						 * the dag exec thread
						 * to fire.
						 */
						RF_ASSERT(rf_NodeReady(a));
d591 1
a591 4
			/*
			 * Transfer our local list of nodes to the node
			 * queue.
			 */
d597 2
a598 2
		for (; finishlist; finishlist = next) {
			/* NIL nodes: no need to fire them. */
d602 9
a610 11
			 * Okay, here we're calling rf_FinishNode() on nodes
			 * that have the null function as their work proc.
			 * Such a node could be the first node in a DAG.
			 * If so, it will cause the DAG to complete, which will
			 * in turn free memory used by the DAG, which includes
			 * the node in question.
			 * Thus, we must avoid referencing the node at all
			 * after calling rf_FinishNode() on it.
			 */
			rf_FinishNode(finishlist, context);
			/* Recursive call. */
d612 2
a613 2
		/* Fire all nodes in firelist. */
		rf_FireNodeList(firelist);
d617 1
a617 2
		printf("Engine found illegal DAG status in"
		    " rf_PropagateResults()\n");
d624 1
d626 1
a626 1
 * Process a fired node which has completed.
d628 4
a631 2
void
rf_ProcessNode(RF_DagNode_t *node, int context)
d639 1
a639 1
		/* Normal case, don't need to do anything. */
d642 3
a644 4
		if ((node->dagHdr->numCommits > 0) ||
		    (node->dagHdr->numCommitNodes == 0)) {
			/* Crossed commit barrier. */
			node->dagHdr->status = rf_rollForward;
d646 1
a646 3
				printf("raid%d: node (%s) returned fail,"
				    " rolling forward\n", raidPtr->raidid,
				    node->name);
d649 2
a650 2
			/* Never reached commit barrier. */
			node->dagHdr->status = rf_rollBackward;
d652 1
a652 3
				printf("raid%d: node (%s) returned fail,"
				    " rolling backward\n", raidPtr->raidid,
				    node->name);
d657 1
a657 1
		/* Normal rollBackward case, don't need to do anything. */
d660 2
a661 2
		/* An undo node failed !!! */
		printf("UNDO of a node failed !!!/n");
d664 1
a664 1
		printf("node finished execution with an illegal status !!!\n");
d669 3
a671 5
	/*
	 * Enqueue node's succedents (antecedents if rollBackward) for
	 * execution.
	 */
	rf_PropagateResults(node, context);
d675 2
a676 2
/*
 * User context or dag-exec-thread context:
d681 4
a684 2
int
rf_FinishNode(RF_DagNode_t *node, int context)
d686 2
a687 2
	/* As far as I can tell, retcode is not used -wvcii. */
	int retcode = RF_FALSE;
d689 1
a689 1
	rf_ProcessNode(node, context);
d695 3
a697 4
/*
 * User context:
 * Submit dag for execution, return non-zero if we have to wait for completion.
 * If and only if we return non-zero, we'll cause cbFunc to get invoked with
d700 12
a711 9
 * For now we always return 1. If the DAG does not cause any I/O, then the
 * callback may get invoked before DispatchDAG returns. There's code in state
 * 5 of ContinueRaidAccess to handle this.
 *
 * All we do here is fire the direct successors of the header node. The DAG
 * execution thread does the rest of the dag processing.
 */
int
rf_DispatchDAG(RF_DagHeader_t *dag, void (*cbFunc) (void *), void *cbArg)
d723 1
a723 1
	if (rf_engineDebug>1) {
d726 2
a727 4
	raidPtr->dags_in_flight++;	/*
					 * Debug only:  blow off proper
					 * locking.
					 */
d732 1
a732 1
	rf_FireNodeArray(dag->numSuccedents, dag->succedents);
d735 6
a740 10


/*
 * Dedicated kernel thread:
 * The thread that handles all DAG node firing.
 * To minimize locking and unlocking, we grab a copy of the entire node queue
 * and then set the node queue to NULL before doing any firing of nodes.
 * This way we only have to release the lock once. Of course, it's probably
 * rare that there's more than one node in the queue at any one time, but it
 * sometimes happens.
d742 1
a742 1
 * In the kernel, this thread runs at spl0 and is not swappable. I copied these
d746 3
a748 3
#ifdef	RAID_AUTOCONFIG
void
rf_DAGExecutionThread_pre(RF_ThreadArg_t arg)
d757 5
d763 1
a763 1
		printf("raid%d: Starting engine thread\n", raidPtr->raidid);
d768 1
a768 1
#ifdef	DIAGNOSTIC
d771 1
a771 1
#endif	/* DIAGNOSTIC */
d773 1
a773 1
	if (RF_CREATE_THREAD(raidPtr->engine_thread, rf_DAGExecutionThread,
d775 1
a775 1
		RF_ERRORMSG("RAIDFRAME: Unable to start engine thread\n");
d781 1
a781 1
		printf("raid%d: Engine thread started\n", raidPtr->raidid);
d787 2
a788 2
void
rf_DAGExecutionThread(RF_ThreadArg_t arg)
d792 2
a793 2
	int ks;
	int s;
d804 1
a804 1
	/* XXX What to put here ? XXX */
d823 1
a823 1
			/* First, strip out the terminal nodes. */
d831 2
a832 4
						/*
						 * End of the dag, add to
						 * callback list.
						 */
d836 2
a837 4
						/*
						 * Not the end, add to the
						 * fire queue.
						 */
d844 2
a845 4
						/*
						 * End of the dag, add to the
						 * callback list.
						 */
d849 2
a850 4
						/*
						 * Not the end, add to the
						 * fire queue.
						 */
d861 2
a862 4
			/*
			 * Execute callback of dags which have reached the
			 * terminal node.
			 */
d868 1
a868 1
				raidPtr->dags_in_flight--; /* Debug only. */
d871 2
a872 2
			/* Fire remaining nodes. */
			rf_FireNodeList(fire_nq);
@


1.5.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_engine.c,v 1.5.2.4 2003/03/28 00:38:28 niklas Exp $	*/
d837 1
d847 5
a851 1
	snprintf(raidname, sizeof raidname, "raid%d", raidPtr->raidid);
@


1.4
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_engine.c,v 1.3 1999/07/30 14:45:32 peter Exp $	*/
/*	$NetBSD: rf_engine.c,v 1.6 2000/01/05 02:57:29 oster Exp $	*/
a63 1
#include "rf_threadid.h"
d113 1
a113 1
	int     rc, tid = 0;
a114 3
	if (rf_engineDebug) {
		rf_get_threadid(tid);
	}
d128 1
a128 1
		printf("[%d] Creating engine thread\n", tid);
d135 1
a135 1
		printf("[%d] Created engine thread\n", tid);
d147 1
a147 1
		printf("[%d] Engine thread running and waiting for events\n", tid);
a242 2
	int     tid;

d247 3
a249 2
			rf_get_threadid(tid);
			printf("[%d] Firing node 0x%lx (%s)\n", tid, (unsigned long) node, node->name);
d265 4
a268 3
		if (rf_engineDebug || 1) {
			rf_get_threadid(tid);
			printf("[%d] Firing (undo) node 0x%lx (%s)\n", tid, (unsigned long) node, node->name);
d397 1
a397 1
	int     tid, i, ks;
a405 2
	rf_get_threadid(tid);

a594 1
	int     tid;
d607 1
a607 2
				rf_get_threadid(tid);
				printf("[%d] node (%s) returned fail, rolling forward\n", tid, node->name);
d613 1
a613 2
				rf_get_threadid(tid);
				printf("[%d] node (%s) returned fail, rolling backward\n", tid, node->name);
a674 1
	int     tid;
d685 1
a685 2
		rf_get_threadid(tid);
		printf("[%d] Entering DispatchDAG\n", tid);
d712 1
a712 1
	int     ks, tid;
a716 1
	rf_assign_threadid();
d718 1
a718 2
		rf_get_threadid(tid);
		printf("[%d] Engine thread is running\n", tid);
a719 6
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
	thread = current_thread();
	thread_swappable(thread, RF_FALSE);
	thread->priority = thread->sched_pri = BASEPRI_SYSTEM;
	s = spl0();
#endif
d795 1
a795 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a797 5
#else
	splx(s);
	thread_terminate(thread);
	thread_halt_self();
#endif
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_engine.c,v 1.2 1999/02/16 00:02:41 niklas Exp $	*/
/*	$NetBSD: rf_engine.c,v 1.5 1999/03/14 21:53:31 oster Exp $	*/
a105 4
	/* XXX something is missing here... */
#ifdef DEBUG
	printf("IGNORING WAIT_STOP\n");
#endif
d134 1
a134 1
	if (RF_CREATE_THREAD(raidPtr->engine_thread, DAGExecutionThread, raidPtr)) {
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_engine.c,v 1.1 1999/01/11 14:29:19 niklas Exp $	*/
/*	$NetBSD: rf_engine.c,v 1.4 1999/02/05 00:06:11 oster Exp $	*/
d92 1
a92 1
#define DO_WAIT(_r_)   tsleep(&(_r_)->node_queue, PRIBIO | PCATCH, "raidframe nq",0)
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_engine.c,v 1.2 1998/11/13 11:48:26 simonb Exp $	*/
/*	$NetBSD: rf_engine.c,v 1.2 1998/11/13 11:48:26 simonb Exp $	*/
a57 150
/* 
 * :  
 *
 * Log: rf_engine.c,v 
 * Revision 1.56  1996/07/28 20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.55  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.54  1996/07/17  21:00:58  jimz
 * clean up timer interface, tracing
 *
 * Revision 1.53  1996/07/15  17:22:18  jimz
 * nit-pick code cleanup
 * resolve stdlib problems on DEC OSF
 *
 * Revision 1.52  1996/06/17  03:17:08  jimz
 * correctly shut down engine thread in kernel
 *
 * Revision 1.51  1996/06/14  15:02:10  jimz
 * make new engine code happy in simulator
 *
 * Revision 1.50  1996/06/14  14:19:48  jimz
 * use diskgroup to control engine thread, make all engine-thread-related
 * stuff per-array
 *
 * Revision 1.49  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.48  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.47  1996/06/06  01:23:23  jimz
 * fix bug in node traversal when firing multiple nodes simultaneously
 *
 * Revision 1.46  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.45  1996/05/30  12:59:18  jimz
 * make etimer happier, more portable
 *
 * Revision 1.44  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.43  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.42  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.41  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.40  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.39  1996/05/20  16:15:17  jimz
 * switch to rf_{mutex,cond}_{init,destroy}
 *
 * Revision 1.38  1996/05/18  20:09:54  jimz
 * bit of cleanup to compile cleanly in kernel, once again
 *
 * Revision 1.37  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.36  1996/05/15  20:24:19  wvcii
 * fixed syntax bug in SIMULATE clause above ProcessNode
 *
 * Revision 1.35  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.34  1996/05/08  15:25:28  wvcii
 * eliminated dead code
 * merged common cases (sim/user/kernel)
 * entire node lists (arrays) now fired atomically
 * reordered source code for readability
 * beefed-up & corrected comments
 *
 * Revision 1.33  1996/05/07  19:39:40  jimz
 * 1. fixed problems in PropogateResults() with nodes being referenced
 * after they were no longer valid
 * 2. fixed problems in PropogateResults() with the node list being
 * incorrectly threaded
 *
 * Revision 1.32  1996/05/07  19:03:56  wvcii
 * in PropagateResults, fixed a bug in the  rollBackward case:
 *   node data is copied before the call to FinishNode which
 *   frees the node and destroys its data.
 *
 * Revision 1.31  1996/05/07  17:45:17  jimz
 * remove old #if 0 code from PropogateResults() (was kept in
 * previous version for archival purposes (rcsdiff))
 *
 * Revision 1.30  1996/05/07  17:44:19  jimz
 * fix threading of nodes to be fired in PropagateResults()
 * fix iteration through skiplist in PropagateResults()
 * fix incorrect accesses to freed memory (dereferencing a
 *   node that was freed by the action of calling FinishNode()
 *   on it, which in turn completed its DAG) in PropagateResults()
 *
 * Revision 1.29  1996/05/02  15:04:15  wvcii
 * fixed bad array index in PropagateResults
 *
 * Revision 1.28  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.27  1995/12/08  15:07:03  arw
 * cache code cleanup
 *
 * Revision 1.26  1995/11/07  16:18:01  wvcii
 * numerous changes associated with roll-away error recovery
 * when a node fails, dag enters rollForward or rollBackward state
 *
 * Revision 1.25  1995/09/06  19:27:17  wvcii
 * added debug vars enableRollAway and debugRecovery
 *
 */

#ifdef _KERNEL
#define KERNEL
#endif

a59 5
#ifndef KERNEL
#include <stdio.h>
#include <stdlib.h>
#endif /* !KERNEL */

a70 1
#ifndef SIMULATE
a71 1
#endif /* !SIMULATE */
a85 8
#ifndef KERNEL

#define DO_LOCK(_r_)      RF_LOCK_MUTEX((_r_)->node_queue_mutex)
#define DO_UNLOCK(_r_)    RF_UNLOCK_MUTEX((_r_)->node_queue_mutex)
#define DO_WAIT(_r_)      RF_WAIT_COND((_r_)->node_queue_cond, (_r_)->node_queue_mutex)
#define DO_SIGNAL(_r_)    RF_SIGNAL_COND((_r_)->node_queue_cond)

#else /* !KERNEL */
a91 3
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
#define DO_WAIT(_r_)      mpsleep(&(_r_)->node_queue, PZERO, "raidframe nq", 0, (void *) simple_lock_addr((_r_)->node_queue_mutex), MS_LOCK_SIMPLE)
#else
a92 1
#endif
a94 2
#endif /* !KERNEL */

d97 10
a106 10
static void rf_ShutdownEngine(arg)
  void  *arg;
{
  RF_Raid_t *raidPtr;

  raidPtr = (RF_Raid_t *)arg;
#ifndef SIMULATE
  raidPtr->shutdown_engine = 1;
  DO_SIGNAL(raidPtr);
  /* XXX something is missing here... */
d108 1
a108 1
  printf("IGNORING WAIT_STOP\n"); 
a109 4
#if 0
  RF_THREADGROUP_WAIT_STOP(&raidPtr->engine_tg);
#endif
#endif /* !SIMULATE */
d112 5
a116 4
int rf_ConfigureEngine(
  RF_ShutdownList_t  **listp,
  RF_Raid_t           *raidPtr,
  RF_Config_t         *cfgPtr)
d118 6
a123 1
  int rc, tid=0;
d125 22
a146 30
  if (rf_engineDebug) {
    rf_get_threadid(tid);
  }

  DO_INIT(listp,raidPtr);

  raidPtr->node_queue = NULL;
  raidPtr->dags_in_flight = 0;

#ifndef SIMULATE
  rc = rf_init_managed_threadgroup(listp, &raidPtr->engine_tg);
  if (rc)
    return(rc);
  
  /* we create the execution thread only once per system boot.
   * no need to check return code b/c the kernel panics if it can't create the thread.
   */
  if (rf_engineDebug) {
    printf("[%d] Creating engine thread\n", tid);
  }

  if (RF_CREATE_THREAD(raidPtr->engine_thread, DAGExecutionThread, raidPtr)) {
    RF_ERRORMSG("RAIDFRAME: Unable to create engine thread\n");
    return(ENOMEM);
  }
  if (rf_engineDebug) {
    printf("[%d] Created engine thread\n", tid);
  }
  RF_THREADGROUP_STARTED(&raidPtr->engine_tg);
  /* XXX something is missing here... */
d148 1
a148 1
  printf("Skipping the WAIT_START!!\n");
d151 1
a151 1
  RF_THREADGROUP_WAIT_START(&raidPtr->engine_tg);
d153 11
a163 14
  /* engine thread is now running and waiting for work */
  if (rf_engineDebug) {
    printf("[%d] Engine thread running and waiting for events\n", tid);
  }
#endif /* !SIMULATE */

  rc = rf_ShutdownCreate(listp, rf_ShutdownEngine, raidPtr);
  if (rc) {
    RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n", __FILE__,
      __LINE__, rc);
    rf_ShutdownEngine(NULL);
  }

  return(rc);
d166 2
a167 1
static int BranchDone(RF_DagNode_t *node)
d169 1
a169 1
  int i;
d171 36
a206 33
  /* return true if forward execution is completed for a node and it's succedents */
  switch (node->status) {
  case rf_wait :
    /* should never be called in this state */
    RF_PANIC();
    break;
  case rf_fired :
    /* node is currently executing, so we're not done */
    return(RF_FALSE);
  case rf_good :
    for (i = 0; i < node->numSuccedents; i++) /* for each succedent */
      if (!BranchDone(node->succedents[i]))   /* recursively check branch */
	return RF_FALSE;
    return RF_TRUE;  /* node and all succedent branches aren't in fired state */
    break;
  case rf_bad :
    /* succedents can't fire */
    return(RF_TRUE);
  case rf_recover :
    /* should never be called in this state */
    RF_PANIC();
    break;
  case rf_undone :
  case rf_panic :
    /* XXX need to fix this case */
    /* for now, assume that we're done */
    return(RF_TRUE);
    break;
  default :
    /* illegal node status */
    RF_PANIC();
    break;
  }
d209 2
a210 4
#ifdef SIMULATE
/* this is only ifdef SIMULATE because nothing else needs it */
/* recursively determine if a DAG has completed execution */
static int DAGDone(RF_DagHeader_t *dag)
d212 1
a212 1
  int i;
d214 22
a235 6
  for (i = 0; i < dag->numSuccedents; i++)
    if (!BranchDone(dag->succedents[i]))
      return RF_FALSE;
  return RF_TRUE;
}
#endif /* SIMULATE */
d237 1
a237 28
static int NodeReady(RF_DagNode_t *node)
{
  int ready;

  switch (node->dagHdr->status) {
  case rf_enable :
  case rf_rollForward :
    if ((node->status == rf_wait) && (node->numAntecedents == node->numAntDone))
      ready = RF_TRUE;
    else
      ready = RF_FALSE;
    break;
  case rf_rollBackward :
    RF_ASSERT(node->numSuccDone <= node->numSuccedents);
    RF_ASSERT(node->numSuccFired <= node->numSuccedents);
    RF_ASSERT(node->numSuccFired <= node->numSuccDone);
    if ((node->status == rf_good) && (node->numSuccDone == node->numSuccedents))
      ready = RF_TRUE;
    else
      ready = RF_FALSE;
    break;
  default :
    printf("Execution engine found illegal DAG status in NodeReady\n");
    RF_PANIC();
    break;
  }  

  return(ready);
d248 2
a249 1
static void FireNode(RF_DagNode_t *node)
d251 1
a251 1
  int tid;
d253 8
a260 9
  switch (node->status) {
  case rf_fired :
    /* fire the do function of a node */
    if (rf_engineDebug) {
      rf_get_threadid(tid);
      printf("[%d] Firing node 0x%lx (%s)\n",tid,(unsigned long) node, node->name);
    }
#ifdef KERNEL
    if (node->flags & RF_DAGNODE_FLAG_YIELD) {
d262 4
a265 4
	    /* 	    thread_block(); */
	    /*  	    printf("Need to block the thread here...\n");  */
	    /* XXX thread_block is actually mentioned in 
	       /usr/include/vm/vm_extern.h */
d267 1
a267 1
	    thread_block();
d269 10
a278 12
    }
#endif /* KERNEL */
    (*(node->doFunc)) (node);
    break;
  case rf_recover :
    /* fire the undo function of a node */
      if (rf_engineDebug || 1) {
        rf_get_threadid(tid);
        printf("[%d] Firing (undo) node 0x%lx (%s)\n",tid,(unsigned long) node, node->name);
      }
#ifdef KERNEL
      if (node->flags & RF_DAGNODE_FLAG_YIELD)
d280 4
a283 4
	      /* 	      thread_block(); */
	      /* 	    printf("Need to block the thread here...\n"); */
	    /* XXX thread_block is actually mentioned in 
	       /usr/include/vm/vm_extern.h */
d285 1
a285 1
        thread_block();
d287 6
a292 7
#endif /* KERNEL */
      (*(node->undoFunc)) (node);
    break;
  default :
    RF_PANIC();
    break;
  }
d301 36
a336 35
static void FireNodeArray(
  int             numNodes,
  RF_DagNode_t  **nodeList)
{
  RF_DagStatus_t dstat;
  RF_DagNode_t *node;
  int i, j;

  /* first, mark all nodes which are ready to be fired */
  for (i = 0; i < numNodes; i++) {
    node = nodeList[i];
    dstat = node->dagHdr->status;
    RF_ASSERT((node->status == rf_wait) || (node->status == rf_good));
    if (NodeReady(node)) {
      if ((dstat == rf_enable) || (dstat == rf_rollForward)) {
	RF_ASSERT(node->status == rf_wait);
	if (node->commitNode)
	  node->dagHdr->numCommits++;
	node->status = rf_fired;
	for (j = 0; j < node->numAntecedents; j++)
	  node->antecedents[j]->numSuccFired++;
      }
      else {
	RF_ASSERT(dstat == rf_rollBackward);
	RF_ASSERT(node->status == rf_good);
	RF_ASSERT(node->commitNode == RF_FALSE); /* only one commit node per graph */
	node->status = rf_recover;
      }
    }
  }
  /* now, fire the nodes */
  for (i = 0; i < numNodes; i++) {
    if ((nodeList[i]->status == rf_fired) || (nodeList[i]->status == rf_recover))
      FireNode(nodeList[i]);
  }
a339 1
#ifndef SIMULATE
d344 2
a345 1
static void FireNodeList(RF_DagNode_t *nodeList)
d347 34
a380 34
  RF_DagNode_t *node, *next;
  RF_DagStatus_t dstat;
  int j;

  if (nodeList) {
    /* first, mark all nodes which are ready to be fired */
    for (node = nodeList; node; node = next) {
      next = node->next;
      dstat = node->dagHdr->status;
      RF_ASSERT((node->status == rf_wait) || (node->status == rf_good));
      if (NodeReady(node)) {
        if ((dstat == rf_enable) || (dstat == rf_rollForward)) {
          RF_ASSERT(node->status == rf_wait);
          if (node->commitNode)
            node->dagHdr->numCommits++;
          node->status = rf_fired;
          for (j = 0; j < node->numAntecedents; j++)
            node->antecedents[j]->numSuccFired++;
        }
        else {
          RF_ASSERT(dstat == rf_rollBackward);
          RF_ASSERT(node->status == rf_good);
          RF_ASSERT(node->commitNode == RF_FALSE); /* only one commit node per graph */
          node->status = rf_recover;
        }
      }
    }
    /* now, fire the nodes */
    for (node = nodeList; node; node = next) {
      next = node->next;
      if ((node->status == rf_fired) || (node->status == rf_recover))
        FireNode(node);
    }
  }
a381 4
#endif /* !SIMULATE */



d398 28
a425 67
static void PropagateResults(
  RF_DagNode_t  *node,
  int            context)
{
  RF_DagNode_t *s, *a;
  RF_Raid_t *raidPtr;
  int tid, i, ks;
#ifdef SIMULATE
  RF_PropHeader_t *p;         /* prop list for succedent i */
#else /* SIMULATE */
  RF_DagNode_t *finishlist = NULL; /* a list of NIL nodes to be finished */
  RF_DagNode_t *skiplist = NULL;   /* list of nodes with failed truedata antecedents */
  RF_DagNode_t *firelist = NULL;   /* a list of nodes to be fired */
  RF_DagNode_t *q = NULL, *qh = NULL, *next;
  int j, skipNode;
#endif /* SIMULATE */

  rf_get_threadid(tid);

  raidPtr = node->dagHdr->raidPtr;

  DO_LOCK(raidPtr);

  /* debug - validate fire counts */
  for (i = 0; i < node->numAntecedents; i++) {
    a = *(node->antecedents + i);
    RF_ASSERT(a->numSuccFired >= a->numSuccDone);
    RF_ASSERT(a->numSuccFired <= a->numSuccedents);
    a->numSuccDone++;
  }

  switch (node->dagHdr->status) {
  case rf_enable :
  case rf_rollForward :
#ifdef SIMULATE
      /* currently we never propagate results unless in simulation */
    for (i = 0; i < node->numSuccedents; i++) {
      s = *(node->succedents + i);      
      RF_ASSERT(s->status == rf_wait);
      (s->numAntDone)++;
      if (node->propList == NULL)
	/* null propList implies no results to be propagated */
	p = NULL;
      else
	/* p=head of prop list for succedent i */
	p = *(node->propList + i);
      while (p != NULL) {
	/* bind node results to succedent's parameters */
#if 0
	*(s->params + p->paramNum) = *(node->results + p->resultNum);
#else
	s->params[p->paramNum].p = node->results[p->resultNum];
#endif
	p = p->next;
      }
    }
#else  /* SIMULATE */
    for (i = 0; i < node->numSuccedents; i++) {
      s = *(node->succedents + i);      
      RF_ASSERT(s->status == rf_wait);
      (s->numAntDone)++;
      if (s->numAntDone == s->numAntecedents) {
	/* look for NIL nodes */
	if (s->doFunc == rf_NullNodeFunc) {
	  /* don't fire NIL nodes, just process them */
	  s->next = finishlist;
	  finishlist = s;
a426 31
	else {
	  /* look to see if the node is to be skipped */
	  skipNode = RF_FALSE;
	  for (j = 0; j < s->numAntecedents; j++)
	    if ((s->antType[j] == rf_trueData) && (s->antecedents[j]->status == rf_bad))
	      skipNode = RF_TRUE;
	  if (skipNode) {
	    /* this node has one or more failed true data dependencies, so skip it */
	    s->next = skiplist;
	    skiplist = s;
	  }
	  else
	    /* add s to list of nodes (q) to execute */
	    if (context != RF_INTR_CONTEXT) {
	      /* we only have to enqueue if we're at intr context */
	      s->next = firelist;  /* put node on a list to be fired after we unlock */
	      firelist = s;
	    } else {               /* enqueue the node for the dag exec thread to fire */
	      RF_ASSERT(NodeReady(s));
	      if (q) {
	        q->next = s;
	        q = s;
	      }
	      else {
	        qh = q = s;
	        qh->next = NULL;
	      }
	    }
	}
      }
    }
d428 163
a590 73
    if (q) {
      /* xfer our local list of nodes to the node queue */
      q->next = raidPtr->node_queue; raidPtr->node_queue = qh;
      DO_SIGNAL(raidPtr);
    }
    DO_UNLOCK(raidPtr);

    for (; skiplist; skiplist = next) {
      next = skiplist->next;
      skiplist->status = rf_skipped;
      for (i = 0; i < skiplist->numAntecedents; i++) {
	skiplist->antecedents[i]->numSuccFired++;
      }
      if (skiplist->commitNode) {
	skiplist->dagHdr->numCommits++;
      }
      rf_FinishNode(skiplist, context);
    }
    for (; finishlist; finishlist = next) {
      /* NIL nodes: no need to fire them */
      next = finishlist->next;
      finishlist->status = rf_good;
      for (i = 0; i < finishlist->numAntecedents; i++) {
	finishlist->antecedents[i]->numSuccFired++;
      }
      if (finishlist->commitNode)
	finishlist->dagHdr->numCommits++;
      /*
       * Okay, here we're calling rf_FinishNode() on nodes that
       * have the null function as their work proc. Such a node
       * could be the terminal node in a DAG. If so, it will
       * cause the DAG to complete, which will in turn free
       * memory used by the DAG, which includes the node in
       * question. Thus, we must avoid referencing the node
       * at all after calling rf_FinishNode() on it.
       */
      rf_FinishNode(finishlist, context);   /* recursive call */
    }
    /* fire all nodes in firelist */
    FireNodeList(firelist);
#endif   /* SIMULATE */
    break;

  case rf_rollBackward :
#ifdef SIMULATE
#else /* SIMULATE */
    for (i = 0; i < node->numAntecedents; i++) {
      a = *(node->antecedents + i);
      RF_ASSERT(a->status == rf_good);
      RF_ASSERT(a->numSuccDone <= a->numSuccedents);
      RF_ASSERT(a->numSuccDone <= a->numSuccFired);

      if (a->numSuccDone == a->numSuccFired) {
	if (a->undoFunc == rf_NullNodeFunc) {
	  /* don't fire NIL nodes, just process them */
	  a->next = finishlist;
	  finishlist = a;
	} else {
	  if (context != RF_INTR_CONTEXT) {
	    /* we only have to enqueue if we're at intr context */
	    a->next = firelist;  /* put node on a list to be fired after we unlock */
	    firelist = a;
	  } else {               /* enqueue the node for the dag exec thread to fire */
	    RF_ASSERT(NodeReady(a));
	    if (q) {
	      q->next = a;
	      q = a;
	    }
	    else {
	      qh = q = a;
	      qh->next = NULL;
	    }
	  }
a591 33
      }
      
    }
    if (q) {
      /* xfer our local list of nodes to the node queue */
      q->next = raidPtr->node_queue; raidPtr->node_queue = qh;
      DO_SIGNAL(raidPtr);
    }
    DO_UNLOCK(raidPtr);
    for (; finishlist; finishlist = next) {       /* NIL nodes: no need to fire them */
      next = finishlist->next;
      finishlist->status = rf_good;
      /*
       * Okay, here we're calling rf_FinishNode() on nodes that
       * have the null function as their work proc. Such a node
       * could be the first node in a DAG. If so, it will
       * cause the DAG to complete, which will in turn free
       * memory used by the DAG, which includes the node in
       * question. Thus, we must avoid referencing the node
       * at all after calling rf_FinishNode() on it.
       */
      rf_FinishNode(finishlist, context);   /* recursive call */
    }
    /* fire all nodes in firelist */
    FireNodeList(firelist);
#endif /* SIMULATE */

    break;
  default :
    printf("Engine found illegal DAG status in PropagateResults()\n");
    RF_PANIC();
    break;
  }
d599 43
a641 8
static void ProcessNode(
  RF_DagNode_t  *node,
  int            context)
{
  RF_Raid_t *raidPtr;
  int tid;

  raidPtr = node->dagHdr->raidPtr;
d643 3
a645 87
  switch (node->status) {
  case rf_good :
    /* normal case, don't need to do anything */
    break;
  case rf_bad :
    if ((node->dagHdr->numCommits > 0) || (node->dagHdr->numCommitNodes == 0)) {
      node->dagHdr->status = rf_rollForward;  /* crossed commit barrier */
      if (rf_engineDebug || 1) {
        rf_get_threadid(tid);
        printf("[%d] node (%s) returned fail, rolling forward\n", tid, node->name);
      }
    }
    else {
      node->dagHdr->status = rf_rollBackward; /* never reached commit barrier */
      if (rf_engineDebug || 1) {
        rf_get_threadid(tid);
        printf("[%d] node (%s) returned fail, rolling backward\n", tid, node->name);
      }
    }
    break;
  case rf_undone :
    /* normal rollBackward case, don't need to do anything */
    break;
  case rf_panic :
    /* an undo node failed!!! */
    printf("UNDO of a node failed!!!/n");
    break;
  default :
    printf("node finished execution with an illegal status!!!\n");
    RF_PANIC();
    break;
  }

#ifdef SIMULATE
  /* simulator fires nodes here.
   * user/kernel rely upon PropagateResults to do this.
   * XXX seems like this code should be merged so that the same thing happens for
   * both sim, user, and kernel.  -wvcii
   */
  switch (node->dagHdr->status) {
  case rf_enable :
  case rf_rollForward :
    if (node->numSuccedents == 0) {
      /* process terminal node */
      if (rf_engineDebug) if (!DAGDone(node->dagHdr)) {
	rf_get_threadid(tid);
	printf("[%d] ProcessNode:  !!!done but dag still in flight\n",tid);
	RF_PANIC();
      }
      if (rf_engineDebug) printf("[%d] ProcessNode:  !!!done will return true\n",tid);    
      /* Mark dag as done */
      (node->dagHdr)->done=RF_TRUE;
      raidPtr->dags_in_flight--;
    }
    else {
      PropagateResults(node, context);
      FireNodeArray(node->numSuccedents, node->succedents);
    }
    break;
  case rf_rollBackward :
    if (node->numAntecedents == 0) {
      /* reached head of dag, we're done */
      if (rf_engineDebug) if (!DAGDone(node->dagHdr)) {
	rf_get_threadid(tid);
	printf("[%d] ProcessNode:  !!!done but dag still in flight\n",tid);
	RF_PANIC();
      }
      if (rf_engineDebug) printf("[%d] ProcessNode:  !!!done will return true\n",tid);    
      /* Mark dag as done */
      (node->dagHdr)->done=RF_TRUE;
      raidPtr->dags_in_flight--;
    }
    else {
      PropagateResults(node, context);
      FireNodeArray(node->numAntecedents, node->antecedents);
    }
    break;
  default :
    RF_PANIC();
    break;
  }


#else /* SIMULATE */
  /* enqueue node's succedents (antecedents if rollBackward) for execution */
  PropagateResults(node, context);
#endif /* SIMULATE */
d655 9
a663 13
int rf_FinishNode(
  RF_DagNode_t  *node,
  int            context)
{
  /* as far as I can tell, retcode is not used -wvcii */
  int retcode = RF_FALSE;
  node->dagHdr->numNodesCompleted++;
  ProcessNode(node, context);

#ifdef SIMULATE
 if ((node->dagHdr)->done == RF_TRUE)
   retcode = RF_TRUE;
#endif /* SIMULATE */
d665 1
a665 1
 return(retcode); 
d681 29
a709 29
int rf_DispatchDAG(
  RF_DagHeader_t   *dag,
  void            (*cbFunc)(void *),
  void             *cbArg)
{
  RF_Raid_t *raidPtr;
  int tid;

  raidPtr = dag->raidPtr;
  if (dag->tracerec) {
    RF_ETIMER_START(dag->tracerec->timer);
  }

  if (rf_engineDebug || rf_validateDAGDebug) {
    if (rf_ValidateDAG(dag))
      RF_PANIC();
  }
  if (rf_engineDebug) {
    rf_get_threadid(tid);
    printf("[%d] Entering DispatchDAG\n",tid);
  }

  raidPtr->dags_in_flight++;  /* debug only:  blow off proper locking */
  dag->cbFunc = cbFunc;
  dag->cbArg  = cbArg;
  dag->numNodesCompleted = 0;
  dag->status = rf_enable;
  FireNodeArray(dag->numSuccedents, dag->succedents);
  return(1);
a710 1

d722 2
a723 2
#ifndef SIMULATE
static void DAGExecutionThread(RF_ThreadArg_t arg)
d725 12
a736 4
  RF_DagNode_t *nd, *local_nq, *term_nq, *fire_nq;
  RF_Raid_t *raidPtr;
  int ks, tid;
  int s;
d738 76
a813 69
  RF_Thread_t thread;
#endif

  raidPtr = (RF_Raid_t *)arg;

  rf_assign_threadid();
  if (rf_engineDebug) {
    rf_get_threadid(tid);
    printf("[%d] Engine thread is running\n", tid);
  }

#ifdef KERNEL
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
  thread = current_thread();
  thread_swappable(thread, RF_FALSE);
  thread->priority = thread->sched_pri = BASEPRI_SYSTEM;
  s = spl0();
#endif
  /* XXX what to put here XXX */

  s=splbio();

#endif /* KERNEL */

  RF_THREADGROUP_RUNNING(&raidPtr->engine_tg);

  DO_LOCK(raidPtr);
  while (!raidPtr->shutdown_engine) {

    while (raidPtr->node_queue != NULL) {
      local_nq = raidPtr->node_queue;
      fire_nq = NULL;
      term_nq = NULL;
      raidPtr->node_queue = NULL;
      DO_UNLOCK(raidPtr);

      /* first, strip out the terminal nodes */
      while (local_nq) {
	nd = local_nq;
	local_nq = local_nq->next;
	switch(nd->dagHdr->status) {
	case rf_enable :
	case rf_rollForward :
	  if (nd->numSuccedents == 0) {
	    /* end of the dag, add to callback list */
	    nd->next = term_nq;
	    term_nq = nd;
	  }
	  else {
	    /* not the end, add to the fire queue */
	    nd->next = fire_nq;
	    fire_nq = nd;
	  }
	  break;
	case rf_rollBackward :
	  if (nd->numAntecedents == 0) {
	    /* end of the dag, add to the callback list */
	    nd->next = term_nq;
	    term_nq = nd;
	  }
	  else {
	    /* not the end, add to the fire queue */
	    nd->next = fire_nq;
	    fire_nq = nd;
	  }
	  break;
	default :
	  RF_PANIC();
	  break;
d815 1
a815 20
      }

      /* execute callback of dags which have reached the terminal node */
      while (term_nq) {
	nd = term_nq;
	term_nq = term_nq->next;
	nd->next = NULL;
	(nd->dagHdr->cbFunc)(nd->dagHdr->cbArg);
	raidPtr->dags_in_flight--;  /* debug only */
      }

      /* fire remaining nodes */
      FireNodeList(fire_nq);

      DO_LOCK(raidPtr);
    }
    while (!raidPtr->shutdown_engine && raidPtr->node_queue == NULL)
      DO_WAIT(raidPtr);
  }
  DO_UNLOCK(raidPtr);
d817 1
a817 2
  RF_THREADGROUP_DONE(&raidPtr->engine_tg);
#ifdef KERNEL
d819 2
a820 2
  splx(s);
  kthread_exit(0);
d822 3
a824 3
  splx(s);
  thread_terminate(thread);
  thread_halt_self();
a825 1
#endif /* KERNEL */
a826 2

#endif /* !SIMULATE */
@

