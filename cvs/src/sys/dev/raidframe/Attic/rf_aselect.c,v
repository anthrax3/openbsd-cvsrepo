head	1.4;
access;
symbols
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.38
	OPENBSD_5_0:1.3.0.36
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.34
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.32
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.28
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.30
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.26
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.24
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.22
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.20
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.18
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.16
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.14
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.12
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.10
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.8
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.6
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.20
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.18
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.2.0.16
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.14
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.12
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.4
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.3;

1.3
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.02.23;	author niklas;	state Exp;
branches
	1.2.6.1
	1.2.16.1;
next	1.1;

1.1
date	99.01.11.14.28.59;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	;

1.2.16.1
date	2003.05.19.22.21.50;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_aselect.c,v 1.3 2002/12/16 07:01:03 tdeval Exp $	*/
/*	$NetBSD: rf_aselect.c,v 1.3 1999/02/05 00:06:06 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland, William V. Courtright II
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/****************************************************************************
 *
 * aselect.c -- algorithm selection code
 *
 *****************************************************************************/


#include "rf_archs.h"
#include "rf_types.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagutils.h"
#include "rf_dagfuncs.h"
#include "rf_general.h"
#include "rf_desc.h"
#include "rf_map.h"

#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
/* The function below is not used... so don't define it! */
#else
void rf_TransferDagMemory(RF_DagHeader_t *, RF_DagHeader_t *);
#endif

int  rf_InitHdrNode(RF_DagHeader_t **, RF_Raid_t *, int);
void rf_UpdateNodeHdrPtr(RF_DagHeader_t *, RF_DagNode_t *);
int  rf_SelectAlgorithm(RF_RaidAccessDesc_t *, RF_RaidAccessFlags_t);


/*****************************************************************************
 *
 * Create and Initialize a dag header and termination node.
 *
 *****************************************************************************/
int
rf_InitHdrNode(RF_DagHeader_t **hdr, RF_Raid_t *raidPtr, int memChunkEnable)
{
	/* Create and initialize dag hdr. */
	*hdr = rf_AllocDAGHeader();
	rf_MakeAllocList((*hdr)->allocList);
	if ((*hdr)->allocList == NULL) {
		rf_FreeDAGHeader(*hdr);
		return (ENOMEM);
	}
	(*hdr)->status = rf_enable;
	(*hdr)->numSuccedents = 0;
	(*hdr)->raidPtr = raidPtr;
	(*hdr)->next = NULL;
	return (0);
}


/*****************************************************************************
 *
 * Transfer allocation list and mem chunks from one dag to another.
 *
 *****************************************************************************/
#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(_KERNEL)
/* The function below is not used... so don't define it! */
#else
void
rf_TransferDagMemory(RF_DagHeader_t *daga, RF_DagHeader_t *dagb)
{
	RF_AccessStripeMapHeader_t *end;
	RF_AllocListElem_t *p;
	int i, memChunksXfrd = 0, xtraChunksXfrd = 0;

	/* Transfer allocList from dagb to daga. */
	for (p = dagb->allocList; p; p = p->next) {
		for (i = 0; i < p->numPointers; i++) {
			rf_AddToAllocList(daga->allocList, p->pointers[i],
			    p->sizes[i]);
			p->pointers[i] = NULL;
			p->sizes[i] = 0;
		}
		p->numPointers = 0;
	}

	/* Transfer chunks from dagb to daga. */
	while ((memChunksXfrd + xtraChunksXfrd <
	    dagb->chunkIndex + dagb->xtraChunkIndex) &&
	    (daga->chunkIndex < RF_MAXCHUNKS)) {
		/* Stuff chunks into daga's memChunk array. */
		if (memChunksXfrd < dagb->chunkIndex) {
			daga->memChunk[daga->chunkIndex++] =
			    dagb->memChunk[memChunksXfrd];
			dagb->memChunk[memChunksXfrd++] = NULL;
		} else {
			daga->memChunk[daga->xtraChunkIndex++] =
			    dagb->xtraMemChunk[xtraChunksXfrd];
			dagb->xtraMemChunk[xtraChunksXfrd++] = NULL;
		}
	}
	/* Use escape hatch to hold excess chunks. */
	while (memChunksXfrd + xtraChunksXfrd <
	    dagb->chunkIndex + dagb->xtraChunkIndex) {
		if (memChunksXfrd < dagb->chunkIndex) {
			daga->xtraMemChunk[daga->xtraChunkIndex++] =
			    dagb->memChunk[memChunksXfrd];
			dagb->memChunk[memChunksXfrd++] = NULL;
		} else {
			daga->xtraMemChunk[daga->xtraChunkIndex++] =
			    dagb->xtraMemChunk[xtraChunksXfrd];
			dagb->xtraMemChunk[xtraChunksXfrd++] = NULL;
		}
	}
	RF_ASSERT((memChunksXfrd == dagb->chunkIndex) &&
	    (xtraChunksXfrd == dagb->xtraChunkIndex));
	RF_ASSERT(daga->chunkIndex <= RF_MAXCHUNKS);
	RF_ASSERT(daga->xtraChunkIndex <= daga->xtraChunkCnt);
	dagb->chunkIndex = 0;
	dagb->xtraChunkIndex = 0;

	/* Transfer asmList from dagb to daga. */
	if (dagb->asmList) {
		if (daga->asmList) {
			end = daga->asmList;
			while (end->next)
				end = end->next;
			end->next = dagb->asmList;
		} else
			daga->asmList = dagb->asmList;
		dagb->asmList = NULL;
	}
}
#endif	/* __NetBSD__ || __OpenBSD__ */


/*****************************************************************************
 *
 * Ensure that all node->dagHdr fields in a dag are consistent.
 *
 * IMPORTANT: This routine recursively searches all succedents of the node.
 * If a succedent is encountered whose dagHdr ptr does not require adjusting,
 * that node's succedents WILL NOT BE EXAMINED.
 *
 *****************************************************************************/
void
rf_UpdateNodeHdrPtr(RF_DagHeader_t *hdr, RF_DagNode_t *node)
{
	int i;
	RF_ASSERT(hdr != NULL && node != NULL);
	for (i = 0; i < node->numSuccedents; i++)
		if (node->succedents[i]->dagHdr != hdr)
			rf_UpdateNodeHdrPtr(hdr, node->succedents[i]);
	node->dagHdr = hdr;
}


/*****************************************************************************
 *
 * Create a DAG to do a read or write operation.
 *
 * Create an array of dagLists, one list per parity stripe.
 * Return the lists in the array desc->dagArray.
 *
 * Normally, each list contains one dag for the entire stripe.  In some
 * tricky cases, we break this into multiple dags, either one per stripe
 * unit or one per block (sector).  When this occurs, these dags are returned
 * as a linked list (dagList) which is executed sequentially (to preserve
 * atomic parity updates in the stripe).
 *
 * Dags that operate on independent parity goups (stripes) are returned in
 * independent dagLists (distinct elements in desc->dagArray) and may be
 * executed concurrently.
 *
 * Finally, if the SelectionFunc fails to create a dag for a block, we punt
 * and return 1.
 *
 * The above process is performed in two phases:
 *   1) create an array(s) of creation functions (eg stripeFuncs)
 *   2) create dags and concatenate/merge to form the final dag.
 *
 * Because dag's are basic blocks (single entry, single exit, unconditional
 * control flow), we can add the following optimizations (future work):
 *   first-pass optimizer to allow max concurrency (need all data dependencies)
 *   second-pass optimizer to eliminate common subexpressions (need true
 *       data dependencies)
 *   third-pass optimizer to eliminate dead code (need true data dependencies)
 *****************************************************************************/

#define	MAXNSTRIPES	50

int
rf_SelectAlgorithm(RF_RaidAccessDesc_t *desc, RF_RaidAccessFlags_t flags)
{
	RF_AccessStripeMapHeader_t *asm_h = desc->asmap;
	RF_IoType_t type = desc->type;
	RF_Raid_t *raidPtr = desc->raidPtr;
	void *bp = desc->bp;

	RF_AccessStripeMap_t *asmap = asm_h->stripeMap;
	RF_AccessStripeMap_t *asm_p;
	RF_DagHeader_t *dag_h = NULL, *tempdag_h, *lastdag_h;
	int i, j, k;
	RF_VoidFuncPtr *stripeFuncs, normalStripeFuncs[MAXNSTRIPES];
	RF_AccessStripeMap_t *asm_up, *asm_bp;
	RF_AccessStripeMapHeader_t ***asmh_u, *endASMList;
	RF_AccessStripeMapHeader_t ***asmh_b;
	RF_VoidFuncPtr **stripeUnitFuncs, uFunc;
	RF_VoidFuncPtr **blockFuncs, bFunc;
	int numStripesBailed = 0, cantCreateDAGs = RF_FALSE;
	int numStripeUnitsBailed = 0;
	int stripeNum, numUnitDags = 0, stripeUnitNum, numBlockDags = 0;
	RF_StripeNum_t numStripeUnits;
	RF_SectorNum_t numBlocks;
	RF_RaidAddr_t address;
	int length;
	RF_PhysDiskAddr_t *physPtr;
	caddr_t buffer;

	lastdag_h = NULL;
	asmh_u = asmh_b = NULL;
	stripeUnitFuncs = NULL;
	blockFuncs = NULL;

	/*
	 * Get an array of dag-function creation pointers.
	 * Try to avoid calling malloc.
	 */
	if (asm_h->numStripes <= MAXNSTRIPES)
		stripeFuncs = normalStripeFuncs;
	else
		RF_Calloc(stripeFuncs, asm_h->numStripes,
		    sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));

	/*
	 * Walk through the asm list once collecting information.
	 * Attempt to find a single creation function for each stripe.
	 */
	desc->numStripes = 0;
	for (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++) {
		desc->numStripes++;
		(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_p,
		    &stripeFuncs[i]);
		/* Check to see if we found a creation func for this stripe. */
		if (stripeFuncs[i] == (RF_VoidFuncPtr) NULL) {
			/*
			 * Could not find creation function for entire stripe.
			 * So, let's see if we can find one for each stripe
			 * unit in the stripe.
			 */

			if (numStripesBailed == 0) {
				/*
				 * One stripe map header for each stripe we
				 * bail on.
				 */
				RF_Malloc(asmh_u,
				    sizeof(RF_AccessStripeMapHeader_t **) *
				    asm_h->numStripes,
				    (RF_AccessStripeMapHeader_t ***));
				/*
				 * Create an array of ptrs to arrays of
				 * stripeFuncs.
				 */
				RF_Calloc(stripeUnitFuncs, asm_h->numStripes,
				    sizeof(RF_VoidFuncPtr),
				    (RF_VoidFuncPtr **));
			}
			/*
			 * Create an array of creation funcs (called
			 * stripeFuncs) for this stripe.
			 */
			numStripeUnits = asm_p->numStripeUnitsAccessed;
			RF_Calloc(stripeUnitFuncs[numStripesBailed],
			    numStripeUnits, sizeof(RF_VoidFuncPtr),
			    (RF_VoidFuncPtr *));
			RF_Malloc(asmh_u[numStripesBailed], numStripeUnits *
			    sizeof(RF_AccessStripeMapHeader_t *),
			    (RF_AccessStripeMapHeader_t **));

			/* Lookup array of stripeUnitFuncs for this stripe. */
			for (j = 0, physPtr = asm_p->physInfo; physPtr;
			    physPtr = physPtr->next, j++) {
				/*
				 * Remap for series of single stripe-unit
				 * accesses.
				 */
				address = physPtr->raidAddress;
				length = physPtr->numSector;
				buffer = physPtr->bufPtr;

				asmh_u[numStripesBailed][j] =
				    rf_MapAccess(raidPtr, address, length,
				        buffer, RF_DONT_REMAP);
				asm_up = asmh_u[numStripesBailed][j]->stripeMap;

				/*
				 * Get the creation func for this
				 * stripe unit.
				 */
				(raidPtr->Layout.map->SelectionFunc) (raidPtr,
				    type, asm_up,
				    &(stripeUnitFuncs[numStripesBailed][j]));

				/*
				 * Check to see if we found a creation func
				 * for this stripe unit.
				 */
				if (stripeUnitFuncs[numStripesBailed][j] ==
				    (RF_VoidFuncPtr) NULL) {
					/*
					 * Could not find creation function
					 * for stripe unit.  So, let's see if
					 * we can find one for each block in
					 * the stripe unit.
					 */
					if (numStripeUnitsBailed == 0) {
						/*
						 * one stripe map header for
						 * each stripe unit we bail on.
						 */
						RF_Malloc(asmh_b,
				    sizeof(RF_AccessStripeMapHeader_t **) *
				    asm_h->numStripes *
				    raidPtr->Layout.numDataCol,
				    (RF_AccessStripeMapHeader_t ***));
						/*
						 * Create an array of ptrs to
						 * arrays of blockFuncs.
						 */
						RF_Calloc(blockFuncs,
						    asm_h->numStripes *
						    raidPtr->Layout.numDataCol,
						    sizeof(RF_VoidFuncPtr),
						    (RF_VoidFuncPtr **));
					}
					/*
					 * Create an array of creation funcs
					 * (called blockFuncs) for this stripe
					 * unit.
					 */
					numBlocks = physPtr->numSector;
					numBlockDags += numBlocks;
					RF_Calloc(
					    blockFuncs[numStripeUnitsBailed], 
					    numBlocks, sizeof(RF_VoidFuncPtr), 
					    (RF_VoidFuncPtr *));
					RF_Malloc(asmh_b[numStripeUnitsBailed], 
				    numBlocks * 
				    sizeof(RF_AccessStripeMapHeader_t *), 
				    (RF_AccessStripeMapHeader_t **));

					/*
					 * Lookup array of blockFuncs for this
					 * stripe unit.
					 */
					for (k = 0; k < numBlocks; k++) {
						/*
						 * Remap for series of single
						 * stripe-unit accesses.
						 */
						address = physPtr->raidAddress
						    + k;
						length = 1;
						buffer = physPtr->bufPtr +
					    (k * (1 <<
					    raidPtr->logBytesPerSector));

						asmh_b[numStripeUnitsBailed][k]
						    = rf_MapAccess(raidPtr,
						    address, length, buffer,
						    RF_DONT_REMAP);
						asm_bp =
				    asmh_b[numStripeUnitsBailed][k]->stripeMap;

						/*
						 * Get the creation func for
						 * this stripe unit.
						 */
						(raidPtr->Layout.map->
				    SelectionFunc) (raidPtr,
				        type, asm_bp,
				        &(blockFuncs[numStripeUnitsBailed][k]));

						/*
						 * Check to see if we found a
						 * creation func for this
						 * stripe unit.
						 */
						if (blockFuncs
						    [numStripeUnitsBailed][k]
						    == NULL)
							cantCreateDAGs =
							    RF_TRUE;
					}
					numStripeUnitsBailed++;
				} else {
					numUnitDags++;
				}
			}
			RF_ASSERT(j == numStripeUnits);
			numStripesBailed++;
		}
	}

	if (cantCreateDAGs) {
		/* Free memory and punt. */
		if (asm_h->numStripes > MAXNSTRIPES)
			RF_Free(stripeFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
		if (numStripesBailed > 0) {
			stripeNum = 0;
			for (i = 0, asm_p = asmap; asm_p;
			    asm_p = asm_p->next, i++)
				if (stripeFuncs[i] == NULL) {
					numStripeUnits =
					    asm_p->numStripeUnitsAccessed;
					for (j = 0; j < numStripeUnits; j++)
						rf_FreeAccessStripeMap(
						    asmh_u[stripeNum][j]);
					RF_Free(asmh_u[stripeNum],
				    numStripeUnits *
				    sizeof(RF_AccessStripeMapHeader_t *));
					RF_Free(stripeUnitFuncs[stripeNum],
					    numStripeUnits *
					    sizeof(RF_VoidFuncPtr));
					stripeNum++;
				}
			RF_ASSERT(stripeNum == numStripesBailed);
			RF_Free(stripeUnitFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
			RF_Free(asmh_u, asm_h->numStripes *
			    sizeof(RF_AccessStripeMapHeader_t **));
		}
		return (1);
	} else {
		/* Begin dag creation. */
		stripeNum = 0;
		stripeUnitNum = 0;

		/* Create an array of dagLists and fill them in. */
		RF_CallocAndAdd(desc->dagArray, desc->numStripes,
		    sizeof(RF_DagList_t), (RF_DagList_t *), desc->cleanupList);

		for (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++) {
			/* Grab dag header for this stripe. */
			dag_h = NULL;
			desc->dagArray[i].desc = desc;

			if (stripeFuncs[i] == (RF_VoidFuncPtr) NULL) {
				/* Use bailout functions for this stripe. */
				for (j = 0, physPtr = asm_p->physInfo; physPtr;
				    physPtr = physPtr->next, j++) {
					uFunc = stripeUnitFuncs[stripeNum][j];
					if (uFunc == (RF_VoidFuncPtr) NULL) {
						/*
						 * Use bailout functions for
						 * this stripe unit.
						 */
						for (k = 0; k <
						    physPtr->numSector; k++) {
							/*
							 * Create a dag for
							 * this block.
							 */
							rf_InitHdrNode(
							    &tempdag_h,
							    raidPtr,
							    rf_useMemChunks);
							desc->dagArray[i].
							    numDags++;
							if (dag_h == NULL) {
								dag_h =
								    tempdag_h;
							} else {
								lastdag_h->next
								    = tempdag_h;
							}
							lastdag_h = tempdag_h;

							bFunc = blockFuncs
							    [stripeUnitNum][k];
							RF_ASSERT(bFunc);
							asm_bp = asmh_b
							    [stripeUnitNum][k]
							    ->stripeMap;
							(*bFunc) (raidPtr,
							    asm_bp, tempdag_h,
							    bp, flags,
							    tempdag_h
							    ->allocList);
						}
						stripeUnitNum++;
					} else {
						/*
						 * Create a dag for this unit.
						 */
						rf_InitHdrNode(&tempdag_h,
						    raidPtr, rf_useMemChunks);
						desc->dagArray[i].numDags++;
						if (dag_h == NULL) {
							dag_h = tempdag_h;
						} else {
							lastdag_h->next =
							    tempdag_h;
						}
						lastdag_h = tempdag_h;

						asm_up = asmh_u[stripeNum][j]
						    ->stripeMap;
						(*uFunc) (raidPtr, asm_up,
						    tempdag_h, bp, flags,
						    tempdag_h->allocList);
					}
				}
				RF_ASSERT(j == asm_p->numStripeUnitsAccessed);
				/*
				 * Merge linked bailout dag to existing dag
				 * collection.
				 */
				stripeNum++;
			} else {
				/* Create a dag for this parity stripe. */
				rf_InitHdrNode(&tempdag_h, raidPtr,
				    rf_useMemChunks);
				desc->dagArray[i].numDags++;
				if (dag_h == NULL) {
					dag_h = tempdag_h;
				} else {
					lastdag_h->next = tempdag_h;
				}
				lastdag_h = tempdag_h;

				(stripeFuncs[i]) (raidPtr, asm_p, tempdag_h,
				    bp, flags, tempdag_h->allocList);
			}
			desc->dagArray[i].dags = dag_h;
		}
		RF_ASSERT(i == desc->numStripes);

		/* Free memory. */
		if (asm_h->numStripes > MAXNSTRIPES)
			RF_Free(stripeFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
		if ((numStripesBailed > 0) || (numStripeUnitsBailed > 0)) {
			stripeNum = 0;
			stripeUnitNum = 0;
			if (dag_h->asmList) {
				endASMList = dag_h->asmList;
				while (endASMList->next)
					endASMList = endASMList->next;
			} else
				endASMList = NULL;
			/* Walk through io, stripe by stripe. */
			for (i = 0, asm_p = asmap; asm_p;
			    asm_p = asm_p->next, i++)
				if (stripeFuncs[i] == NULL) {
					numStripeUnits =
					    asm_p->numStripeUnitsAccessed;
					/*
					 * Walk through stripe, stripe unit by
					 * stripe unit.
					 */
					for (j = 0, physPtr = asm_p->physInfo;
					    physPtr;
					    physPtr = physPtr->next, j++) {
						if (stripeUnitFuncs[stripeNum]
						    [j] == NULL) {
							numBlocks =
							    physPtr->numSector;
							/*
							 * Walk through stripe
							 * unit, block by
							 * block.
							 */
							for (k = 0; k <
							    numBlocks; k++)
								if (dag_h
								    ->asmList 
								    == NULL) {
						dag_h->asmList = 
						    asmh_b[stripeUnitNum][k];
						endASMList = dag_h->asmList;
								} else {
						endASMList->next =
						    asmh_b[stripeUnitNum][k];
						endASMList = endASMList->next;
								}
							RF_Free(asmh_b
				    [stripeUnitNum], numBlocks *
				    sizeof(RF_AccessStripeMapHeader_t *));
							RF_Free(blockFuncs
						    [stripeUnitNum], numBlocks *
						    sizeof(RF_VoidFuncPtr));
							stripeUnitNum++;
						}
						if (dag_h->asmList == NULL) {
							dag_h->asmList = asmh_u
							    [stripeNum][j];
							endASMList = dag_h
							    ->asmList;
						} else {
							endASMList->next =
							    asmh_u[stripeNum]
							    [j];
							endASMList = endASMList
							    ->next;
						}
					}
					RF_Free(asmh_u[stripeNum],
					    numStripeUnits *
					    sizeof(
					        RF_AccessStripeMapHeader_t *));
					RF_Free(stripeUnitFuncs[stripeNum],
					    numStripeUnits *
					    sizeof(RF_VoidFuncPtr));
					stripeNum++;
				}
			RF_ASSERT(stripeNum == numStripesBailed);
			RF_Free(stripeUnitFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
			RF_Free(asmh_u, asm_h->numStripes *
			    sizeof(RF_AccessStripeMapHeader_t **));
			if (numStripeUnitsBailed > 0) {
				RF_ASSERT(stripeUnitNum ==
				    numStripeUnitsBailed);
				RF_Free(blockFuncs, raidPtr->Layout.numDataCol
				    * asm_h->numStripes *
				    sizeof(RF_VoidFuncPtr));
				RF_Free(asmh_b, raidPtr->Layout.numDataCol *
				    asm_h->numStripes *
				    sizeof(RF_AccessStripeMapHeader_t **));
			}
		}
		return (0);
	}
}
@


1.3
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_aselect.c,v 1.2 1999/02/16 00:02:23 niklas Exp $	*/
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_aselect.c,v 1.1 1999/01/11 14:28:59 niklas Exp $	*/
d3 1
d31 1
a31 1
/*****************************************************************************
d49 1
a49 1
/* the function below is not used... so don't define it! */
d51 1
a51 1
static void TransferDagMemory(RF_DagHeader_t *, RF_DagHeader_t *);
d54 3
a56 3
static int InitHdrNode(RF_DagHeader_t **, RF_Raid_t *, int);
static void UpdateNodeHdrPtr(RF_DagHeader_t *, RF_DagNode_t *);
int     rf_SelectAlgorithm(RF_RaidAccessDesc_t *, RF_RaidAccessFlags_t);
d59 1
a59 1
/******************************************************************************
d61 1
a61 1
 * Create and Initialiaze a dag header and termination node
d64 2
a65 5
static int 
InitHdrNode(hdr, raidPtr, memChunkEnable)
	RF_DagHeader_t **hdr;
	RF_Raid_t *raidPtr;
	int     memChunkEnable;
d67 1
a67 1
	/* create and initialize dag hdr */
d80 3
a82 1
/******************************************************************************
d84 1
a84 1
 * Transfer allocation list and mem chunks from one dag to another
d88 1
a88 1
/* the function below is not used... so don't define it! */
d90 2
a91 4
static void 
TransferDagMemory(daga, dagb)
	RF_DagHeader_t *daga;
	RF_DagHeader_t *dagb;
d95 1
a95 1
	int     i, memChunksXfrd = 0, xtraChunksXfrd = 0;
d97 1
a97 1
	/* transfer allocList from dagb to daga */
d100 2
a101 1
			rf_AddToAllocList(daga->allocList, p->pointers[i], p->sizes[i]);
d108 5
a112 3
	/* transfer chunks from dagb to daga */
	while ((memChunksXfrd + xtraChunksXfrd < dagb->chunkIndex + dagb->xtraChunkIndex) && (daga->chunkIndex < RF_MAXCHUNKS)) {
		/* stuff chunks into daga's memChunk array */
d114 2
a115 1
			daga->memChunk[daga->chunkIndex++] = dagb->memChunk[memChunksXfrd];
d118 2
a119 1
			daga->memChunk[daga->xtraChunkIndex++] = dagb->xtraMemChunk[xtraChunksXfrd];
d123 3
a125 2
	/* use escape hatch to hold excess chunks */
	while (memChunksXfrd + xtraChunksXfrd < dagb->chunkIndex + dagb->xtraChunkIndex) {
d127 2
a128 1
			daga->xtraMemChunk[daga->xtraChunkIndex++] = dagb->memChunk[memChunksXfrd];
d131 2
a132 1
			daga->xtraMemChunk[daga->xtraChunkIndex++] = dagb->xtraMemChunk[xtraChunksXfrd];
d136 2
a137 1
	RF_ASSERT((memChunksXfrd == dagb->chunkIndex) && (xtraChunksXfrd == dagb->xtraChunkIndex));
d143 1
a143 1
	/* transfer asmList from dagb to daga */
d155 2
a156 1
#endif				/* __NetBSD__ || __OpenBSD__ */
d158 1
a158 1
/*****************************************************************************************
d160 1
a160 1
 * Ensure that all node->dagHdr fields in a dag are consistent
d162 3
a164 3
 * IMPORTANT: This routine recursively searches all succedents of the node.  If a
 * succedent is encountered whose dagHdr ptr does not require adjusting, that node's
 * succedents WILL NOT BE EXAMINED.
d166 3
a168 5
 ****************************************************************************************/
static void 
UpdateNodeHdrPtr(hdr, node)
	RF_DagHeader_t *hdr;
	RF_DagNode_t *node;
d170 1
a170 1
	int     i;
d174 1
a174 1
			UpdateNodeHdrPtr(hdr, node->succedents[i]);
d177 3
a179 1
/******************************************************************************
d183 2
a184 2
 * create an array of dagLists, one list per parity stripe.
 * return the lists in the array desc->dagArray.
d192 1
a192 1
 * dags which operate on independent parity goups (stripes) are returned in
d204 1
a204 1
 * control flow, we can add the following optimizations (future work):
d207 1
a207 1
 *                         data dependencies)
d211 1
a211 1
#define MAXNSTRIPES 50
d213 2
a214 4
int 
rf_SelectAlgorithm(desc, flags)
	RF_RaidAccessDesc_t *desc;
	RF_RaidAccessFlags_t flags;
d219 1
a219 1
	void   *bp = desc->bp;
d224 1
a224 1
	int     i, j, k;
d231 3
a233 3
	int     numStripesBailed = 0, cantCreateDAGs = RF_FALSE;
	int     numStripeUnitsBailed = 0;
	int     stripeNum, numUnitDags = 0, stripeUnitNum, numBlockDags = 0;
d237 1
a237 1
	int     length;
d246 4
a249 2
	/* get an array of dag-function creation pointers, try to avoid
	 * calling malloc */
d253 2
a254 1
		RF_Calloc(stripeFuncs, asm_h->numStripes, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));
d256 4
a259 2
	/* walk through the asm list once collecting information */
	/* attempt to find a single creation function for each stripe */
d263 3
a265 2
		(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_p, &stripeFuncs[i]);
		/* check to see if we found a creation func for this stripe */
d267 5
a271 3
			/* could not find creation function for entire stripe
			 * so, let's see if we can find one for each stripe
			 * unit in the stripe */
d274 15
a288 6
				/* one stripe map header for each stripe we
				 * bail on */
				RF_Malloc(asmh_u, sizeof(RF_AccessStripeMapHeader_t **) * asm_h->numStripes, (RF_AccessStripeMapHeader_t ***));
				/* create an array of ptrs to arrays of
				 * stripeFuncs */
				RF_Calloc(stripeUnitFuncs, asm_h->numStripes, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr **));
d290 4
a293 2
			/* create an array of creation funcs (called
			 * stripeFuncs) for this stripe */
d295 14
a308 7
			RF_Calloc(stripeUnitFuncs[numStripesBailed], numStripeUnits, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));
			RF_Malloc(asmh_u[numStripesBailed], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *), (RF_AccessStripeMapHeader_t **));

			/* lookup array of stripeUnitFuncs for this stripe */
			for (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++) {
				/* remap for series of single stripe-unit
				 * accesses */
d313 3
a315 1
				asmh_u[numStripesBailed][j] = rf_MapAccess(raidPtr, address, length, buffer, RF_DONT_REMAP);
d318 20
a337 10
				/* get the creation func for this stripe unit */
				(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_up, &(stripeUnitFuncs[numStripesBailed][j]));

				/* check to see if we found a creation func
				 * for this stripe unit */
				if (stripeUnitFuncs[numStripesBailed][j] == (RF_VoidFuncPtr) NULL) {
					/* could not find creation function
					 * for stripe unit so, let's see if we
					 * can find one for each block in the
					 * stripe unit */
d339 18
a356 6
						/* one stripe map header for
						 * each stripe unit we bail on */
						RF_Malloc(asmh_b, sizeof(RF_AccessStripeMapHeader_t **) * asm_h->numStripes * raidPtr->Layout.numDataCol, (RF_AccessStripeMapHeader_t ***));
						/* create an array of ptrs to
						 * arrays of blockFuncs */
						RF_Calloc(blockFuncs, asm_h->numStripes * raidPtr->Layout.numDataCol, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr **));
d358 2
a359 1
					/* create an array of creation funcs
d361 2
a362 1
					 * unit */
d365 13
a377 5
					RF_Calloc(blockFuncs[numStripeUnitsBailed], numBlocks, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));
					RF_Malloc(asmh_b[numStripeUnitsBailed], numBlocks * sizeof(RF_AccessStripeMapHeader_t *), (RF_AccessStripeMapHeader_t **));

					/* lookup array of blockFuncs for this
					 * stripe unit */
d379 6
a384 3
						/* remap for series of single
						 * stripe-unit accesses */
						address = physPtr->raidAddress + k;
d386 19
a404 8
						buffer = physPtr->bufPtr + (k * (1 << raidPtr->logBytesPerSector));

						asmh_b[numStripeUnitsBailed][k] = rf_MapAccess(raidPtr, address, length, buffer, RF_DONT_REMAP);
						asm_bp = asmh_b[numStripeUnitsBailed][k]->stripeMap;

						/* get the creation func for
						 * this stripe unit */
						(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_bp, &(blockFuncs[numStripeUnitsBailed][k]));
d406 2
a407 1
						/* check to see if we found a
d409 7
a415 3
						 * stripe unit */
						if (blockFuncs[numStripeUnitsBailed][k] == NULL)
							cantCreateDAGs = RF_TRUE;
d428 1
a428 1
		/* free memory and punt */
d430 2
a431 1
			RF_Free(stripeFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));
d434 2
a435 1
			for (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++)
d437 2
a438 1
					numStripeUnits = asm_p->numStripeUnitsAccessed;
d440 8
a447 3
						rf_FreeAccessStripeMap(asmh_u[stripeNum][j]);
					RF_Free(asmh_u[stripeNum], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *));
					RF_Free(stripeUnitFuncs[stripeNum], numStripeUnits * sizeof(RF_VoidFuncPtr));
d451 4
a454 2
			RF_Free(stripeUnitFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));
			RF_Free(asmh_u, asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));
d458 1
a458 1
		/* begin dag creation */
d462 3
a464 2
		/* create an array of dagLists and fill them in */
		RF_CallocAndAdd(desc->dagArray, desc->numStripes, sizeof(RF_DagList_t), (RF_DagList_t *), desc->cleanupList);
d467 1
a467 1
			/* grab dag header for this stripe */
d472 3
a474 2
				/* use bailout functions for this stripe */
				for (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++) {
d477 16
a492 7
						/* use bailout functions for
						 * this stripe unit */
						for (k = 0; k < physPtr->numSector; k++) {
							/* create a dag for
							 * this block */
							InitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);
							desc->dagArray[i].numDags++;
d494 2
a495 1
								dag_h = tempdag_h;
d497 2
a498 1
								lastdag_h->next = tempdag_h;
d502 2
a503 1
							bFunc = blockFuncs[stripeUnitNum][k];
d505 8
a512 2
							asm_bp = asmh_b[stripeUnitNum][k]->stripeMap;
							(*bFunc) (raidPtr, asm_bp, tempdag_h, bp, flags, tempdag_h->allocList);
d516 5
a520 2
						/* create a dag for this unit */
						InitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);
d525 2
a526 1
							lastdag_h->next = tempdag_h;
d530 5
a534 2
						asm_up = asmh_u[stripeNum][j]->stripeMap;
						(*uFunc) (raidPtr, asm_up, tempdag_h, bp, flags, tempdag_h->allocList);
d538 4
a541 2
				/* merge linked bailout dag to existing dag
				 * collection */
d544 3
a546 2
				/* Create a dag for this parity stripe */
				InitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);
d555 2
a556 1
				(stripeFuncs[i]) (raidPtr, asm_p, tempdag_h, bp, flags, tempdag_h->allocList);
d562 1
a562 1
		/* free memory */
d564 2
a565 1
			RF_Free(stripeFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));
d575 3
a577 2
			/* walk through io, stripe by stripe */
			for (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++)
d579 15
a593 7
					numStripeUnits = asm_p->numStripeUnitsAccessed;
					/* walk through stripe, stripe unit by
					 * stripe unit */
					for (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++) {
						if (stripeUnitFuncs[stripeNum][j] == NULL) {
							numBlocks = physPtr->numSector;
							/* walk through stripe
d595 10
a604 5
							 * block */
							for (k = 0; k < numBlocks; k++)
								if (dag_h->asmList == NULL) {
									dag_h->asmList = asmh_b[stripeUnitNum][k];
									endASMList = dag_h->asmList;
d606 3
a608 2
									endASMList->next = asmh_b[stripeUnitNum][k];
									endASMList = endASMList->next;
d610 6
a615 2
							RF_Free(asmh_b[stripeUnitNum], numBlocks * sizeof(RF_AccessStripeMapHeader_t *));
							RF_Free(blockFuncs[stripeUnitNum], numBlocks * sizeof(RF_VoidFuncPtr));
d619 4
a622 2
							dag_h->asmList = asmh_u[stripeNum][j];
							endASMList = dag_h->asmList;
d624 5
a628 2
							endASMList->next = asmh_u[stripeNum][j];
							endASMList = endASMList->next;
d631 7
a637 2
					RF_Free(asmh_u[stripeNum], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *));
					RF_Free(stripeUnitFuncs[stripeNum], numStripeUnits * sizeof(RF_VoidFuncPtr));
d641 4
a644 2
			RF_Free(stripeUnitFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));
			RF_Free(asmh_u, asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));
d646 8
a653 3
				RF_ASSERT(stripeUnitNum == numStripeUnitsBailed);
				RF_Free(blockFuncs, raidPtr->Layout.numDataCol * asm_h->numStripes * sizeof(RF_VoidFuncPtr));
				RF_Free(asmh_b, raidPtr->Layout.numDataCol * asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));
@


1.2.16.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/****************************************************************************
d48 1
a48 1
/* The function below is not used... so don't define it! */
d50 1
a50 1
void rf_TransferDagMemory(RF_DagHeader_t *, RF_DagHeader_t *);
d53 3
a55 3
int  rf_InitHdrNode(RF_DagHeader_t **, RF_Raid_t *, int);
void rf_UpdateNodeHdrPtr(RF_DagHeader_t *, RF_DagNode_t *);
int  rf_SelectAlgorithm(RF_RaidAccessDesc_t *, RF_RaidAccessFlags_t);
d58 1
a58 1
/*****************************************************************************
d60 1
a60 1
 * Create and Initialize a dag header and termination node.
d63 5
a67 2
int
rf_InitHdrNode(RF_DagHeader_t **hdr, RF_Raid_t *raidPtr, int memChunkEnable)
d69 1
a69 1
	/* Create and initialize dag hdr. */
d82 1
a82 3


/*****************************************************************************
d84 1
a84 1
 * Transfer allocation list and mem chunks from one dag to another.
d88 1
a88 1
/* The function below is not used... so don't define it! */
d90 4
a93 2
void
rf_TransferDagMemory(RF_DagHeader_t *daga, RF_DagHeader_t *dagb)
d97 1
a97 1
	int i, memChunksXfrd = 0, xtraChunksXfrd = 0;
d99 1
a99 1
	/* Transfer allocList from dagb to daga. */
d102 1
a102 2
			rf_AddToAllocList(daga->allocList, p->pointers[i],
			    p->sizes[i]);
d109 3
a111 5
	/* Transfer chunks from dagb to daga. */
	while ((memChunksXfrd + xtraChunksXfrd <
	    dagb->chunkIndex + dagb->xtraChunkIndex) &&
	    (daga->chunkIndex < RF_MAXCHUNKS)) {
		/* Stuff chunks into daga's memChunk array. */
d113 1
a113 2
			daga->memChunk[daga->chunkIndex++] =
			    dagb->memChunk[memChunksXfrd];
d116 1
a116 2
			daga->memChunk[daga->xtraChunkIndex++] =
			    dagb->xtraMemChunk[xtraChunksXfrd];
d120 2
a121 3
	/* Use escape hatch to hold excess chunks. */
	while (memChunksXfrd + xtraChunksXfrd <
	    dagb->chunkIndex + dagb->xtraChunkIndex) {
d123 1
a123 2
			daga->xtraMemChunk[daga->xtraChunkIndex++] =
			    dagb->memChunk[memChunksXfrd];
d126 1
a126 2
			daga->xtraMemChunk[daga->xtraChunkIndex++] =
			    dagb->xtraMemChunk[xtraChunksXfrd];
d130 1
a130 2
	RF_ASSERT((memChunksXfrd == dagb->chunkIndex) &&
	    (xtraChunksXfrd == dagb->xtraChunkIndex));
d136 1
a136 1
	/* Transfer asmList from dagb to daga. */
d148 1
a148 2
#endif	/* __NetBSD__ || __OpenBSD__ */

d150 1
a150 1
/*****************************************************************************
d152 1
a152 1
 * Ensure that all node->dagHdr fields in a dag are consistent.
d154 3
a156 3
 * IMPORTANT: This routine recursively searches all succedents of the node.
 * If a succedent is encountered whose dagHdr ptr does not require adjusting,
 * that node's succedents WILL NOT BE EXAMINED.
d158 5
a162 3
 *****************************************************************************/
void
rf_UpdateNodeHdrPtr(RF_DagHeader_t *hdr, RF_DagNode_t *node)
d164 1
a164 1
	int i;
d168 1
a168 1
			rf_UpdateNodeHdrPtr(hdr, node->succedents[i]);
d171 1
a171 3


/*****************************************************************************
d175 2
a176 2
 * Create an array of dagLists, one list per parity stripe.
 * Return the lists in the array desc->dagArray.
d184 1
a184 1
 * Dags that operate on independent parity goups (stripes) are returned in
d196 1
a196 1
 * control flow), we can add the following optimizations (future work):
d199 1
a199 1
 *       data dependencies)
d203 1
a203 1
#define	MAXNSTRIPES	50
d205 4
a208 2
int
rf_SelectAlgorithm(RF_RaidAccessDesc_t *desc, RF_RaidAccessFlags_t flags)
d213 1
a213 1
	void *bp = desc->bp;
d218 1
a218 1
	int i, j, k;
d225 3
a227 3
	int numStripesBailed = 0, cantCreateDAGs = RF_FALSE;
	int numStripeUnitsBailed = 0;
	int stripeNum, numUnitDags = 0, stripeUnitNum, numBlockDags = 0;
d231 1
a231 1
	int length;
d240 2
a241 4
	/*
	 * Get an array of dag-function creation pointers.
	 * Try to avoid calling malloc.
	 */
d245 1
a245 2
		RF_Calloc(stripeFuncs, asm_h->numStripes,
		    sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));
d247 2
a248 4
	/*
	 * Walk through the asm list once collecting information.
	 * Attempt to find a single creation function for each stripe.
	 */
d252 2
a253 3
		(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_p,
		    &stripeFuncs[i]);
		/* Check to see if we found a creation func for this stripe. */
d255 3
a257 5
			/*
			 * Could not find creation function for entire stripe.
			 * So, let's see if we can find one for each stripe
			 * unit in the stripe.
			 */
d260 6
a265 15
				/*
				 * One stripe map header for each stripe we
				 * bail on.
				 */
				RF_Malloc(asmh_u,
				    sizeof(RF_AccessStripeMapHeader_t **) *
				    asm_h->numStripes,
				    (RF_AccessStripeMapHeader_t ***));
				/*
				 * Create an array of ptrs to arrays of
				 * stripeFuncs.
				 */
				RF_Calloc(stripeUnitFuncs, asm_h->numStripes,
				    sizeof(RF_VoidFuncPtr),
				    (RF_VoidFuncPtr **));
d267 2
a268 4
			/*
			 * Create an array of creation funcs (called
			 * stripeFuncs) for this stripe.
			 */
d270 7
a276 14
			RF_Calloc(stripeUnitFuncs[numStripesBailed],
			    numStripeUnits, sizeof(RF_VoidFuncPtr),
			    (RF_VoidFuncPtr *));
			RF_Malloc(asmh_u[numStripesBailed], numStripeUnits *
			    sizeof(RF_AccessStripeMapHeader_t *),
			    (RF_AccessStripeMapHeader_t **));

			/* Lookup array of stripeUnitFuncs for this stripe. */
			for (j = 0, physPtr = asm_p->physInfo; physPtr;
			    physPtr = physPtr->next, j++) {
				/*
				 * Remap for series of single stripe-unit
				 * accesses.
				 */
d281 1
a281 3
				asmh_u[numStripesBailed][j] =
				    rf_MapAccess(raidPtr, address, length,
				        buffer, RF_DONT_REMAP);
d284 10
a293 20
				/*
				 * Get the creation func for this
				 * stripe unit.
				 */
				(raidPtr->Layout.map->SelectionFunc) (raidPtr,
				    type, asm_up,
				    &(stripeUnitFuncs[numStripesBailed][j]));

				/*
				 * Check to see if we found a creation func
				 * for this stripe unit.
				 */
				if (stripeUnitFuncs[numStripesBailed][j] ==
				    (RF_VoidFuncPtr) NULL) {
					/*
					 * Could not find creation function
					 * for stripe unit.  So, let's see if
					 * we can find one for each block in
					 * the stripe unit.
					 */
d295 6
a300 18
						/*
						 * one stripe map header for
						 * each stripe unit we bail on.
						 */
						RF_Malloc(asmh_b,
				    sizeof(RF_AccessStripeMapHeader_t **) *
				    asm_h->numStripes *
				    raidPtr->Layout.numDataCol,
				    (RF_AccessStripeMapHeader_t ***));
						/*
						 * Create an array of ptrs to
						 * arrays of blockFuncs.
						 */
						RF_Calloc(blockFuncs,
						    asm_h->numStripes *
						    raidPtr->Layout.numDataCol,
						    sizeof(RF_VoidFuncPtr),
						    (RF_VoidFuncPtr **));
d302 1
a302 2
					/*
					 * Create an array of creation funcs
d304 1
a304 2
					 * unit.
					 */
d307 5
a311 13
					RF_Calloc(
					    blockFuncs[numStripeUnitsBailed], 
					    numBlocks, sizeof(RF_VoidFuncPtr), 
					    (RF_VoidFuncPtr *));
					RF_Malloc(asmh_b[numStripeUnitsBailed], 
				    numBlocks * 
				    sizeof(RF_AccessStripeMapHeader_t *), 
				    (RF_AccessStripeMapHeader_t **));

					/*
					 * Lookup array of blockFuncs for this
					 * stripe unit.
					 */
d313 3
a315 6
						/*
						 * Remap for series of single
						 * stripe-unit accesses.
						 */
						address = physPtr->raidAddress
						    + k;
d317 8
a324 19
						buffer = physPtr->bufPtr +
					    (k * (1 <<
					    raidPtr->logBytesPerSector));

						asmh_b[numStripeUnitsBailed][k]
						    = rf_MapAccess(raidPtr,
						    address, length, buffer,
						    RF_DONT_REMAP);
						asm_bp =
				    asmh_b[numStripeUnitsBailed][k]->stripeMap;

						/*
						 * Get the creation func for
						 * this stripe unit.
						 */
						(raidPtr->Layout.map->
				    SelectionFunc) (raidPtr,
				        type, asm_bp,
				        &(blockFuncs[numStripeUnitsBailed][k]));
d326 1
a326 2
						/*
						 * Check to see if we found a
d328 3
a330 7
						 * stripe unit.
						 */
						if (blockFuncs
						    [numStripeUnitsBailed][k]
						    == NULL)
							cantCreateDAGs =
							    RF_TRUE;
d343 1
a343 1
		/* Free memory and punt. */
d345 1
a345 2
			RF_Free(stripeFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
d348 1
a348 2
			for (i = 0, asm_p = asmap; asm_p;
			    asm_p = asm_p->next, i++)
d350 1
a350 2
					numStripeUnits =
					    asm_p->numStripeUnitsAccessed;
d352 3
a354 8
						rf_FreeAccessStripeMap(
						    asmh_u[stripeNum][j]);
					RF_Free(asmh_u[stripeNum],
				    numStripeUnits *
				    sizeof(RF_AccessStripeMapHeader_t *));
					RF_Free(stripeUnitFuncs[stripeNum],
					    numStripeUnits *
					    sizeof(RF_VoidFuncPtr));
d358 2
a359 4
			RF_Free(stripeUnitFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
			RF_Free(asmh_u, asm_h->numStripes *
			    sizeof(RF_AccessStripeMapHeader_t **));
d363 1
a363 1
		/* Begin dag creation. */
d367 2
a368 3
		/* Create an array of dagLists and fill them in. */
		RF_CallocAndAdd(desc->dagArray, desc->numStripes,
		    sizeof(RF_DagList_t), (RF_DagList_t *), desc->cleanupList);
d371 1
a371 1
			/* Grab dag header for this stripe. */
d376 2
a377 3
				/* Use bailout functions for this stripe. */
				for (j = 0, physPtr = asm_p->physInfo; physPtr;
				    physPtr = physPtr->next, j++) {
d380 7
a386 16
						/*
						 * Use bailout functions for
						 * this stripe unit.
						 */
						for (k = 0; k <
						    physPtr->numSector; k++) {
							/*
							 * Create a dag for
							 * this block.
							 */
							rf_InitHdrNode(
							    &tempdag_h,
							    raidPtr,
							    rf_useMemChunks);
							desc->dagArray[i].
							    numDags++;
d388 1
a388 2
								dag_h =
								    tempdag_h;
d390 1
a390 2
								lastdag_h->next
								    = tempdag_h;
d394 1
a394 2
							bFunc = blockFuncs
							    [stripeUnitNum][k];
d396 2
a397 8
							asm_bp = asmh_b
							    [stripeUnitNum][k]
							    ->stripeMap;
							(*bFunc) (raidPtr,
							    asm_bp, tempdag_h,
							    bp, flags,
							    tempdag_h
							    ->allocList);
d401 2
a402 5
						/*
						 * Create a dag for this unit.
						 */
						rf_InitHdrNode(&tempdag_h,
						    raidPtr, rf_useMemChunks);
d407 1
a407 2
							lastdag_h->next =
							    tempdag_h;
d411 2
a412 5
						asm_up = asmh_u[stripeNum][j]
						    ->stripeMap;
						(*uFunc) (raidPtr, asm_up,
						    tempdag_h, bp, flags,
						    tempdag_h->allocList);
d416 2
a417 4
				/*
				 * Merge linked bailout dag to existing dag
				 * collection.
				 */
d420 2
a421 3
				/* Create a dag for this parity stripe. */
				rf_InitHdrNode(&tempdag_h, raidPtr,
				    rf_useMemChunks);
d430 1
a430 2
				(stripeFuncs[i]) (raidPtr, asm_p, tempdag_h,
				    bp, flags, tempdag_h->allocList);
d436 1
a436 1
		/* Free memory. */
d438 1
a438 2
			RF_Free(stripeFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
d448 2
a449 3
			/* Walk through io, stripe by stripe. */
			for (i = 0, asm_p = asmap; asm_p;
			    asm_p = asm_p->next, i++)
d451 7
a457 15
					numStripeUnits =
					    asm_p->numStripeUnitsAccessed;
					/*
					 * Walk through stripe, stripe unit by
					 * stripe unit.
					 */
					for (j = 0, physPtr = asm_p->physInfo;
					    physPtr;
					    physPtr = physPtr->next, j++) {
						if (stripeUnitFuncs[stripeNum]
						    [j] == NULL) {
							numBlocks =
							    physPtr->numSector;
							/*
							 * Walk through stripe
d459 5
a463 10
							 * block.
							 */
							for (k = 0; k <
							    numBlocks; k++)
								if (dag_h
								    ->asmList 
								    == NULL) {
						dag_h->asmList = 
						    asmh_b[stripeUnitNum][k];
						endASMList = dag_h->asmList;
d465 2
a466 3
						endASMList->next =
						    asmh_b[stripeUnitNum][k];
						endASMList = endASMList->next;
d468 2
a469 6
							RF_Free(asmh_b
				    [stripeUnitNum], numBlocks *
				    sizeof(RF_AccessStripeMapHeader_t *));
							RF_Free(blockFuncs
						    [stripeUnitNum], numBlocks *
						    sizeof(RF_VoidFuncPtr));
d473 2
a474 4
							dag_h->asmList = asmh_u
							    [stripeNum][j];
							endASMList = dag_h
							    ->asmList;
d476 2
a477 5
							endASMList->next =
							    asmh_u[stripeNum]
							    [j];
							endASMList = endASMList
							    ->next;
d480 2
a481 7
					RF_Free(asmh_u[stripeNum],
					    numStripeUnits *
					    sizeof(
					        RF_AccessStripeMapHeader_t *));
					RF_Free(stripeUnitFuncs[stripeNum],
					    numStripeUnits *
					    sizeof(RF_VoidFuncPtr));
d485 2
a486 4
			RF_Free(stripeUnitFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
			RF_Free(asmh_u, asm_h->numStripes *
			    sizeof(RF_AccessStripeMapHeader_t **));
d488 3
a490 8
				RF_ASSERT(stripeUnitNum ==
				    numStripeUnitsBailed);
				RF_Free(blockFuncs, raidPtr->Layout.numDataCol
				    * asm_h->numStripes *
				    sizeof(RF_VoidFuncPtr));
				RF_Free(asmh_b, raidPtr->Layout.numDataCol *
				    asm_h->numStripes *
				    sizeof(RF_AccessStripeMapHeader_t **));
@


1.2.6.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/****************************************************************************
d48 1
a48 1
/* The function below is not used... so don't define it! */
d50 1
a50 1
void rf_TransferDagMemory(RF_DagHeader_t *, RF_DagHeader_t *);
d53 3
a55 3
int  rf_InitHdrNode(RF_DagHeader_t **, RF_Raid_t *, int);
void rf_UpdateNodeHdrPtr(RF_DagHeader_t *, RF_DagNode_t *);
int  rf_SelectAlgorithm(RF_RaidAccessDesc_t *, RF_RaidAccessFlags_t);
d58 1
a58 1
/*****************************************************************************
d60 1
a60 1
 * Create and Initialize a dag header and termination node.
d63 5
a67 2
int
rf_InitHdrNode(RF_DagHeader_t **hdr, RF_Raid_t *raidPtr, int memChunkEnable)
d69 1
a69 1
	/* Create and initialize dag hdr. */
d82 1
a82 3


/*****************************************************************************
d84 1
a84 1
 * Transfer allocation list and mem chunks from one dag to another.
d88 1
a88 1
/* The function below is not used... so don't define it! */
d90 4
a93 2
void
rf_TransferDagMemory(RF_DagHeader_t *daga, RF_DagHeader_t *dagb)
d97 1
a97 1
	int i, memChunksXfrd = 0, xtraChunksXfrd = 0;
d99 1
a99 1
	/* Transfer allocList from dagb to daga. */
d102 1
a102 2
			rf_AddToAllocList(daga->allocList, p->pointers[i],
			    p->sizes[i]);
d109 3
a111 5
	/* Transfer chunks from dagb to daga. */
	while ((memChunksXfrd + xtraChunksXfrd <
	    dagb->chunkIndex + dagb->xtraChunkIndex) &&
	    (daga->chunkIndex < RF_MAXCHUNKS)) {
		/* Stuff chunks into daga's memChunk array. */
d113 1
a113 2
			daga->memChunk[daga->chunkIndex++] =
			    dagb->memChunk[memChunksXfrd];
d116 1
a116 2
			daga->memChunk[daga->xtraChunkIndex++] =
			    dagb->xtraMemChunk[xtraChunksXfrd];
d120 2
a121 3
	/* Use escape hatch to hold excess chunks. */
	while (memChunksXfrd + xtraChunksXfrd <
	    dagb->chunkIndex + dagb->xtraChunkIndex) {
d123 1
a123 2
			daga->xtraMemChunk[daga->xtraChunkIndex++] =
			    dagb->memChunk[memChunksXfrd];
d126 1
a126 2
			daga->xtraMemChunk[daga->xtraChunkIndex++] =
			    dagb->xtraMemChunk[xtraChunksXfrd];
d130 1
a130 2
	RF_ASSERT((memChunksXfrd == dagb->chunkIndex) &&
	    (xtraChunksXfrd == dagb->xtraChunkIndex));
d136 1
a136 1
	/* Transfer asmList from dagb to daga. */
d148 1
a148 2
#endif	/* __NetBSD__ || __OpenBSD__ */

d150 1
a150 1
/*****************************************************************************
d152 1
a152 1
 * Ensure that all node->dagHdr fields in a dag are consistent.
d154 3
a156 3
 * IMPORTANT: This routine recursively searches all succedents of the node.
 * If a succedent is encountered whose dagHdr ptr does not require adjusting,
 * that node's succedents WILL NOT BE EXAMINED.
d158 5
a162 3
 *****************************************************************************/
void
rf_UpdateNodeHdrPtr(RF_DagHeader_t *hdr, RF_DagNode_t *node)
d164 1
a164 1
	int i;
d168 1
a168 1
			rf_UpdateNodeHdrPtr(hdr, node->succedents[i]);
d171 1
a171 3


/*****************************************************************************
d175 2
a176 2
 * Create an array of dagLists, one list per parity stripe.
 * Return the lists in the array desc->dagArray.
d184 1
a184 1
 * Dags that operate on independent parity goups (stripes) are returned in
d196 1
a196 1
 * control flow), we can add the following optimizations (future work):
d199 1
a199 1
 *       data dependencies)
d203 1
a203 1
#define	MAXNSTRIPES	50
d205 4
a208 2
int
rf_SelectAlgorithm(RF_RaidAccessDesc_t *desc, RF_RaidAccessFlags_t flags)
d213 1
a213 1
	void *bp = desc->bp;
d218 1
a218 1
	int i, j, k;
d225 3
a227 3
	int numStripesBailed = 0, cantCreateDAGs = RF_FALSE;
	int numStripeUnitsBailed = 0;
	int stripeNum, numUnitDags = 0, stripeUnitNum, numBlockDags = 0;
d231 1
a231 1
	int length;
d240 2
a241 4
	/*
	 * Get an array of dag-function creation pointers.
	 * Try to avoid calling malloc.
	 */
d245 1
a245 2
		RF_Calloc(stripeFuncs, asm_h->numStripes,
		    sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));
d247 2
a248 4
	/*
	 * Walk through the asm list once collecting information.
	 * Attempt to find a single creation function for each stripe.
	 */
d252 2
a253 3
		(raidPtr->Layout.map->SelectionFunc) (raidPtr, type, asm_p,
		    &stripeFuncs[i]);
		/* Check to see if we found a creation func for this stripe. */
d255 3
a257 5
			/*
			 * Could not find creation function for entire stripe.
			 * So, let's see if we can find one for each stripe
			 * unit in the stripe.
			 */
d260 6
a265 15
				/*
				 * One stripe map header for each stripe we
				 * bail on.
				 */
				RF_Malloc(asmh_u,
				    sizeof(RF_AccessStripeMapHeader_t **) *
				    asm_h->numStripes,
				    (RF_AccessStripeMapHeader_t ***));
				/*
				 * Create an array of ptrs to arrays of
				 * stripeFuncs.
				 */
				RF_Calloc(stripeUnitFuncs, asm_h->numStripes,
				    sizeof(RF_VoidFuncPtr),
				    (RF_VoidFuncPtr **));
d267 2
a268 4
			/*
			 * Create an array of creation funcs (called
			 * stripeFuncs) for this stripe.
			 */
d270 7
a276 14
			RF_Calloc(stripeUnitFuncs[numStripesBailed],
			    numStripeUnits, sizeof(RF_VoidFuncPtr),
			    (RF_VoidFuncPtr *));
			RF_Malloc(asmh_u[numStripesBailed], numStripeUnits *
			    sizeof(RF_AccessStripeMapHeader_t *),
			    (RF_AccessStripeMapHeader_t **));

			/* Lookup array of stripeUnitFuncs for this stripe. */
			for (j = 0, physPtr = asm_p->physInfo; physPtr;
			    physPtr = physPtr->next, j++) {
				/*
				 * Remap for series of single stripe-unit
				 * accesses.
				 */
d281 1
a281 3
				asmh_u[numStripesBailed][j] =
				    rf_MapAccess(raidPtr, address, length,
				        buffer, RF_DONT_REMAP);
d284 10
a293 20
				/*
				 * Get the creation func for this
				 * stripe unit.
				 */
				(raidPtr->Layout.map->SelectionFunc) (raidPtr,
				    type, asm_up,
				    &(stripeUnitFuncs[numStripesBailed][j]));

				/*
				 * Check to see if we found a creation func
				 * for this stripe unit.
				 */
				if (stripeUnitFuncs[numStripesBailed][j] ==
				    (RF_VoidFuncPtr) NULL) {
					/*
					 * Could not find creation function
					 * for stripe unit.  So, let's see if
					 * we can find one for each block in
					 * the stripe unit.
					 */
d295 6
a300 18
						/*
						 * one stripe map header for
						 * each stripe unit we bail on.
						 */
						RF_Malloc(asmh_b,
				    sizeof(RF_AccessStripeMapHeader_t **) *
				    asm_h->numStripes *
				    raidPtr->Layout.numDataCol,
				    (RF_AccessStripeMapHeader_t ***));
						/*
						 * Create an array of ptrs to
						 * arrays of blockFuncs.
						 */
						RF_Calloc(blockFuncs,
						    asm_h->numStripes *
						    raidPtr->Layout.numDataCol,
						    sizeof(RF_VoidFuncPtr),
						    (RF_VoidFuncPtr **));
d302 1
a302 2
					/*
					 * Create an array of creation funcs
d304 1
a304 2
					 * unit.
					 */
d307 5
a311 13
					RF_Calloc(
					    blockFuncs[numStripeUnitsBailed], 
					    numBlocks, sizeof(RF_VoidFuncPtr), 
					    (RF_VoidFuncPtr *));
					RF_Malloc(asmh_b[numStripeUnitsBailed], 
				    numBlocks * 
				    sizeof(RF_AccessStripeMapHeader_t *), 
				    (RF_AccessStripeMapHeader_t **));

					/*
					 * Lookup array of blockFuncs for this
					 * stripe unit.
					 */
d313 3
a315 6
						/*
						 * Remap for series of single
						 * stripe-unit accesses.
						 */
						address = physPtr->raidAddress
						    + k;
d317 8
a324 19
						buffer = physPtr->bufPtr +
					    (k * (1 <<
					    raidPtr->logBytesPerSector));

						asmh_b[numStripeUnitsBailed][k]
						    = rf_MapAccess(raidPtr,
						    address, length, buffer,
						    RF_DONT_REMAP);
						asm_bp =
				    asmh_b[numStripeUnitsBailed][k]->stripeMap;

						/*
						 * Get the creation func for
						 * this stripe unit.
						 */
						(raidPtr->Layout.map->
				    SelectionFunc) (raidPtr,
				        type, asm_bp,
				        &(blockFuncs[numStripeUnitsBailed][k]));
d326 1
a326 2
						/*
						 * Check to see if we found a
d328 3
a330 7
						 * stripe unit.
						 */
						if (blockFuncs
						    [numStripeUnitsBailed][k]
						    == NULL)
							cantCreateDAGs =
							    RF_TRUE;
d343 1
a343 1
		/* Free memory and punt. */
d345 1
a345 2
			RF_Free(stripeFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
d348 1
a348 2
			for (i = 0, asm_p = asmap; asm_p;
			    asm_p = asm_p->next, i++)
d350 1
a350 2
					numStripeUnits =
					    asm_p->numStripeUnitsAccessed;
d352 3
a354 8
						rf_FreeAccessStripeMap(
						    asmh_u[stripeNum][j]);
					RF_Free(asmh_u[stripeNum],
				    numStripeUnits *
				    sizeof(RF_AccessStripeMapHeader_t *));
					RF_Free(stripeUnitFuncs[stripeNum],
					    numStripeUnits *
					    sizeof(RF_VoidFuncPtr));
d358 2
a359 4
			RF_Free(stripeUnitFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
			RF_Free(asmh_u, asm_h->numStripes *
			    sizeof(RF_AccessStripeMapHeader_t **));
d363 1
a363 1
		/* Begin dag creation. */
d367 2
a368 3
		/* Create an array of dagLists and fill them in. */
		RF_CallocAndAdd(desc->dagArray, desc->numStripes,
		    sizeof(RF_DagList_t), (RF_DagList_t *), desc->cleanupList);
d371 1
a371 1
			/* Grab dag header for this stripe. */
d376 2
a377 3
				/* Use bailout functions for this stripe. */
				for (j = 0, physPtr = asm_p->physInfo; physPtr;
				    physPtr = physPtr->next, j++) {
d380 7
a386 16
						/*
						 * Use bailout functions for
						 * this stripe unit.
						 */
						for (k = 0; k <
						    physPtr->numSector; k++) {
							/*
							 * Create a dag for
							 * this block.
							 */
							rf_InitHdrNode(
							    &tempdag_h,
							    raidPtr,
							    rf_useMemChunks);
							desc->dagArray[i].
							    numDags++;
d388 1
a388 2
								dag_h =
								    tempdag_h;
d390 1
a390 2
								lastdag_h->next
								    = tempdag_h;
d394 1
a394 2
							bFunc = blockFuncs
							    [stripeUnitNum][k];
d396 2
a397 8
							asm_bp = asmh_b
							    [stripeUnitNum][k]
							    ->stripeMap;
							(*bFunc) (raidPtr,
							    asm_bp, tempdag_h,
							    bp, flags,
							    tempdag_h
							    ->allocList);
d401 2
a402 5
						/*
						 * Create a dag for this unit.
						 */
						rf_InitHdrNode(&tempdag_h,
						    raidPtr, rf_useMemChunks);
d407 1
a407 2
							lastdag_h->next =
							    tempdag_h;
d411 2
a412 5
						asm_up = asmh_u[stripeNum][j]
						    ->stripeMap;
						(*uFunc) (raidPtr, asm_up,
						    tempdag_h, bp, flags,
						    tempdag_h->allocList);
d416 2
a417 4
				/*
				 * Merge linked bailout dag to existing dag
				 * collection.
				 */
d420 2
a421 3
				/* Create a dag for this parity stripe. */
				rf_InitHdrNode(&tempdag_h, raidPtr,
				    rf_useMemChunks);
d430 1
a430 2
				(stripeFuncs[i]) (raidPtr, asm_p, tempdag_h,
				    bp, flags, tempdag_h->allocList);
d436 1
a436 1
		/* Free memory. */
d438 1
a438 2
			RF_Free(stripeFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
d448 2
a449 3
			/* Walk through io, stripe by stripe. */
			for (i = 0, asm_p = asmap; asm_p;
			    asm_p = asm_p->next, i++)
d451 7
a457 15
					numStripeUnits =
					    asm_p->numStripeUnitsAccessed;
					/*
					 * Walk through stripe, stripe unit by
					 * stripe unit.
					 */
					for (j = 0, physPtr = asm_p->physInfo;
					    physPtr;
					    physPtr = physPtr->next, j++) {
						if (stripeUnitFuncs[stripeNum]
						    [j] == NULL) {
							numBlocks =
							    physPtr->numSector;
							/*
							 * Walk through stripe
d459 5
a463 10
							 * block.
							 */
							for (k = 0; k <
							    numBlocks; k++)
								if (dag_h
								    ->asmList 
								    == NULL) {
						dag_h->asmList = 
						    asmh_b[stripeUnitNum][k];
						endASMList = dag_h->asmList;
d465 2
a466 3
						endASMList->next =
						    asmh_b[stripeUnitNum][k];
						endASMList = endASMList->next;
d468 2
a469 6
							RF_Free(asmh_b
				    [stripeUnitNum], numBlocks *
				    sizeof(RF_AccessStripeMapHeader_t *));
							RF_Free(blockFuncs
						    [stripeUnitNum], numBlocks *
						    sizeof(RF_VoidFuncPtr));
d473 2
a474 4
							dag_h->asmList = asmh_u
							    [stripeNum][j];
							endASMList = dag_h
							    ->asmList;
d476 2
a477 5
							endASMList->next =
							    asmh_u[stripeNum]
							    [j];
							endASMList = endASMList
							    ->next;
d480 2
a481 7
					RF_Free(asmh_u[stripeNum],
					    numStripeUnits *
					    sizeof(
					        RF_AccessStripeMapHeader_t *));
					RF_Free(stripeUnitFuncs[stripeNum],
					    numStripeUnits *
					    sizeof(RF_VoidFuncPtr));
d485 2
a486 4
			RF_Free(stripeUnitFuncs, asm_h->numStripes *
			    sizeof(RF_VoidFuncPtr));
			RF_Free(asmh_u, asm_h->numStripes *
			    sizeof(RF_AccessStripeMapHeader_t **));
d488 3
a490 8
				RF_ASSERT(stripeUnitNum ==
				    numStripeUnitsBailed);
				RF_Free(blockFuncs, raidPtr->Layout.numDataCol
				    * asm_h->numStripes *
				    sizeof(RF_VoidFuncPtr));
				RF_Free(asmh_b, raidPtr->Layout.numDataCol *
				    asm_h->numStripes *
				    sizeof(RF_AccessStripeMapHeader_t **));
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_aselect.c,v 1.1 1998/11/13 04:20:26 oster Exp $	*/
/*	$NetBSD: rf_aselect.c,v 1.1 1998/11/13 04:20:26 oster Exp $	*/
d33 1
a33 1
 * 
d35 1
a35 102
/*
 * :  
 * Log: rf_aselect.c,v 
 * Revision 1.35  1996/07/28 20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.34  1996/07/27  18:39:39  jimz
 * cleanup sweep
 *
 * Revision 1.33  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.32  1996/06/12  03:29:40  jimz
 * Note: things that call InitHdrNode should check
 * for successful return.
 *
 * Revision 1.31  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.30  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.29  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.28  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.27  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.26  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.25  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.24  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.23  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.22  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.21  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.20  1996/05/03  19:45:35  wvcii
 * removed includes of old deg creation files
 * updated SelectAlgorithm comments
 *
 * Revision 1.19  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.18  1995/11/30  16:27:48  wvcii
 * added copyright info
 *
 * Revision 1.17  1995/11/19  16:25:55  wvcii
 * SelectAlgorithm now creates an array, returned in desc->dagArray
 * return value is now int (1 = FAIL)
 *
 * Revision 1.16  1995/11/17  15:09:58  wvcii
 * fixed bug in SelectAlgorithm in which multiple graphs per stripe are required
 *
 * Revision 1.15  1995/11/07  17:12:42  wvcii
 * changed SelectAlgorithm as follows:
 *
 * dag creation funcs now create term nodes
 * dag selection funcs no longer return numHdrSucc, numTermAnt
 * there is now one dag hdr for each dag in a request, implying
 * that SelectAlgorithm now returns a linked list of dag hdrs
 *
 */
d55 1
a55 1
int rf_SelectAlgorithm(RF_RaidAccessDesc_t *, RF_RaidAccessFlags_t );
d63 5
a67 4
static int InitHdrNode(hdr, raidPtr, memChunkEnable)
  RF_DagHeader_t  **hdr;
  RF_Raid_t        *raidPtr;
  int               memChunkEnable;
d69 12
a80 12
  /* create and initialize dag hdr */
  *hdr = rf_AllocDAGHeader();
  rf_MakeAllocList((*hdr)->allocList);
  if ((*hdr)->allocList == NULL) {
    rf_FreeDAGHeader(*hdr);
    return(ENOMEM);
  }
  (*hdr)->status = rf_enable;
  (*hdr)->numSuccedents = 0;
  (*hdr)->raidPtr = raidPtr;
  (*hdr)->next = NULL;
  return(0);
a81 1

d90 4
a93 3
static void TransferDagMemory(daga, dagb)
  RF_DagHeader_t  *daga;
  RF_DagHeader_t  *dagb;
d95 12
a106 12
  RF_AccessStripeMapHeader_t *end;
  RF_AllocListElem_t *p;
  int i, memChunksXfrd = 0, xtraChunksXfrd = 0;

  /* transfer allocList from dagb to daga */
  for (p = dagb->allocList; p ; p = p->next)
    {
      for (i = 0; i < p->numPointers; i++)
	{
	  rf_AddToAllocList(daga->allocList, p->pointers[i], p->sizes[i]);
	  p->pointers[i] = NULL;
	  p->sizes[i] = 0;
a107 2
      p->numPointers = 0;
    }
d109 10
a118 8
  /* transfer chunks from dagb to daga */
  while ((memChunksXfrd + xtraChunksXfrd < dagb->chunkIndex + dagb->xtraChunkIndex) && (daga->chunkIndex < RF_MAXCHUNKS))
    {
      /* stuff chunks into daga's memChunk array */
      if (memChunksXfrd < dagb->chunkIndex)
	{
	  daga->memChunk[daga->chunkIndex++] = dagb->memChunk[memChunksXfrd];
	  dagb->memChunk[memChunksXfrd++] = NULL;
d120 9
a128 4
      else
	{
	  daga->memChunk[daga->xtraChunkIndex++] = dagb->xtraMemChunk[xtraChunksXfrd];
	  dagb->xtraMemChunk[xtraChunksXfrd++] = NULL;
d130 16
a145 29
    }
  /* use escape hatch to hold excess chunks */
  while (memChunksXfrd + xtraChunksXfrd < dagb->chunkIndex + dagb->xtraChunkIndex) {
    if (memChunksXfrd < dagb->chunkIndex)
      {
	daga->xtraMemChunk[daga->xtraChunkIndex++] = dagb->memChunk[memChunksXfrd];
	dagb->memChunk[memChunksXfrd++] = NULL;
      }
    else
      {
	daga->xtraMemChunk[daga->xtraChunkIndex++] = dagb->xtraMemChunk[xtraChunksXfrd];
	dagb->xtraMemChunk[xtraChunksXfrd++] = NULL;
      }
  }
  RF_ASSERT((memChunksXfrd == dagb->chunkIndex) && (xtraChunksXfrd == dagb->xtraChunkIndex));
  RF_ASSERT(daga->chunkIndex <= RF_MAXCHUNKS);
  RF_ASSERT(daga->xtraChunkIndex <= daga->xtraChunkCnt);
  dagb->chunkIndex = 0;
  dagb->xtraChunkIndex = 0;

  /* transfer asmList from dagb to daga */
  if (dagb->asmList)
    {
      if (daga->asmList)
	{
	  end = daga->asmList;
	  while (end->next)
	    end = end->next;
	  end->next = dagb->asmList;
a146 4
      else
	daga->asmList = dagb->asmList;
      dagb->asmList = NULL;
    }
d148 1
a148 1
#endif /* __NetBSD__ || __OpenBSD__ */
d159 4
a162 3
static void UpdateNodeHdrPtr(hdr, node)
  RF_DagHeader_t  *hdr;
  RF_DagNode_t    *node;
d164 6
a169 6
  int i;
  RF_ASSERT(hdr != NULL && node != NULL);
  for (i = 0; i < node->numSuccedents; i++)
    if (node->succedents[i]->dagHdr != hdr)
      UpdateNodeHdrPtr(hdr, node->succedents[i]);
  node->dagHdr = hdr;
a170 1

d183 1
a183 1
 * 
d205 4
a208 3
int rf_SelectAlgorithm(desc, flags)
  RF_RaidAccessDesc_t   *desc;
  RF_RaidAccessFlags_t   flags;
d210 130
a339 143
  RF_AccessStripeMapHeader_t *asm_h = desc->asmap;
  RF_IoType_t type     = desc->type;
  RF_Raid_t *raidPtr = desc->raidPtr;
  void *bp      = desc->bp;

  RF_AccessStripeMap_t *asmap = asm_h->stripeMap;
  RF_AccessStripeMap_t *asm_p;
  RF_DagHeader_t *dag_h = NULL, *tempdag_h, *lastdag_h;
  int i, j, k;
  RF_VoidFuncPtr *stripeFuncs, normalStripeFuncs[MAXNSTRIPES];
  RF_AccessStripeMap_t *asm_up, *asm_bp;
  RF_AccessStripeMapHeader_t ***asmh_u, *endASMList;
  RF_AccessStripeMapHeader_t ***asmh_b;
  RF_VoidFuncPtr **stripeUnitFuncs, uFunc;
  RF_VoidFuncPtr **blockFuncs, bFunc;
  int numStripesBailed = 0, cantCreateDAGs = RF_FALSE;
  int numStripeUnitsBailed = 0;
  int stripeNum, numUnitDags = 0, stripeUnitNum, numBlockDags = 0;
  RF_StripeNum_t numStripeUnits;
  RF_SectorNum_t numBlocks;
  RF_RaidAddr_t address;
  int length;
  RF_PhysDiskAddr_t *physPtr;
  caddr_t buffer;

  lastdag_h = NULL;
  asmh_u = asmh_b = NULL;
  stripeUnitFuncs = NULL;
  blockFuncs = NULL;

  /* get an array of dag-function creation pointers, try to avoid calling malloc */
  if (asm_h->numStripes <= MAXNSTRIPES) stripeFuncs = normalStripeFuncs;
  else RF_Calloc(stripeFuncs, asm_h->numStripes, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));

  /* walk through the asm list once collecting information */
  /* attempt to find a single creation function for each stripe */
  desc->numStripes = 0;
  for (i=0,asm_p = asmap; asm_p; asm_p=asm_p->next,i++) {
    desc->numStripes++;
    (raidPtr->Layout.map->SelectionFunc)(raidPtr, type, asm_p, &stripeFuncs[i]);
    /* check to see if we found a creation func for this stripe */
    if (stripeFuncs[i] == (RF_VoidFuncPtr) NULL)
      {
	/* could not find creation function for entire stripe
	   so, let's see if we can find one for each stripe unit in the stripe */
	
	if (numStripesBailed == 0)
	  {
	    /* one stripe map header for each stripe we bail on */
	    RF_Malloc(asmh_u, sizeof(RF_AccessStripeMapHeader_t **) * asm_h->numStripes, (RF_AccessStripeMapHeader_t ***));
	    /* create an array of ptrs to arrays of stripeFuncs */
	    RF_Calloc(stripeUnitFuncs, asm_h->numStripes, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr **));
	  }
	
	/* create an array of creation funcs (called stripeFuncs) for this stripe */
	numStripeUnits = asm_p->numStripeUnitsAccessed;
	RF_Calloc(stripeUnitFuncs[numStripesBailed], numStripeUnits, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));
	RF_Malloc(asmh_u[numStripesBailed], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *), (RF_AccessStripeMapHeader_t **));
	
	/* lookup array of stripeUnitFuncs for this stripe */
	for (j=0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++)
	  {
	    /* remap for series of single stripe-unit accesses */
	    address = physPtr->raidAddress;
	    length  = physPtr->numSector;
	    buffer  = physPtr->bufPtr;

	    asmh_u[numStripesBailed][j] = rf_MapAccess(raidPtr, address, length, buffer, RF_DONT_REMAP);
	    asm_up = asmh_u[numStripesBailed][j]->stripeMap;
	    
	    /* get the creation func for this stripe unit */
	    (raidPtr->Layout.map-> SelectionFunc)(raidPtr, type, asm_up, &(stripeUnitFuncs[numStripesBailed][j]));
	    
	    /* check to see if we found a creation func for this stripe unit */
	    if (stripeUnitFuncs[numStripesBailed][j] == (RF_VoidFuncPtr) NULL)
	      {
		/* could not find creation function for stripe unit so,
		   let's see if we can find one for each block in the stripe unit */
		if (numStripeUnitsBailed == 0)
		  {
		    /* one stripe map header for each stripe unit we bail on */
		    RF_Malloc(asmh_b, sizeof(RF_AccessStripeMapHeader_t **) * asm_h->numStripes * raidPtr->Layout.numDataCol, (RF_AccessStripeMapHeader_t ***));
		    /* create an array of ptrs to arrays of blockFuncs */
		    RF_Calloc(blockFuncs, asm_h->numStripes * raidPtr->Layout.numDataCol, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr **));
		  }

		/* create an array of creation funcs (called blockFuncs) for this stripe unit */
		numBlocks = physPtr->numSector;
		numBlockDags += numBlocks;
		RF_Calloc(blockFuncs[numStripeUnitsBailed], numBlocks, sizeof(RF_VoidFuncPtr), (RF_VoidFuncPtr *));
		RF_Malloc(asmh_b[numStripeUnitsBailed], numBlocks * sizeof(RF_AccessStripeMapHeader_t *), (RF_AccessStripeMapHeader_t **));
	
		/* lookup array of blockFuncs for this stripe unit */
		for (k=0; k < numBlocks; k++)
		  {
		    /* remap for series of single stripe-unit accesses */
		    address = physPtr->raidAddress + k;
		    length  = 1;
		    buffer  = physPtr->bufPtr + (k * (1<<raidPtr->logBytesPerSector));
		    
		    asmh_b[numStripeUnitsBailed][k] = rf_MapAccess(raidPtr, address, length, buffer, RF_DONT_REMAP);
		    asm_bp = asmh_b[numStripeUnitsBailed][k]->stripeMap;
		    
		    /* get the creation func for this stripe unit */
		    (raidPtr->Layout.map-> SelectionFunc)(raidPtr, type, asm_bp, &(blockFuncs[numStripeUnitsBailed][k]));
		    
		    /* check to see if we found a creation func for this stripe unit */
		    if (blockFuncs[numStripeUnitsBailed][k] == NULL)
		      cantCreateDAGs = RF_TRUE;
		  }
		numStripeUnitsBailed++;
	      }
	    else
	      {
		numUnitDags++;
	      }
	  }
	RF_ASSERT(j == numStripeUnits);
	numStripesBailed++;
      }
  }

  if (cantCreateDAGs)
    {
      /* free memory and punt */
      if (asm_h->numStripes > MAXNSTRIPES)
	RF_Free(stripeFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));
      if (numStripesBailed > 0)
	{
	  stripeNum = 0;
	  for (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++)
	    if (stripeFuncs[i] == NULL)
	      {
		numStripeUnits = asm_p->numStripeUnitsAccessed;
		for (j = 0; j < numStripeUnits; j++)
		    rf_FreeAccessStripeMap(asmh_u[stripeNum][j]);
		RF_Free(asmh_u[stripeNum], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *));
		RF_Free(stripeUnitFuncs[stripeNum], numStripeUnits * sizeof(RF_VoidFuncPtr));
		stripeNum++;
	      }
	  RF_ASSERT(stripeNum == numStripesBailed);
	  RF_Free(stripeUnitFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));
	  RF_Free(asmh_u, asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));
d341 90
a430 32
      return(1);
    }
  else
    {
      /* begin dag creation */
      stripeNum = 0;
      stripeUnitNum = 0;

      /* create an array of dagLists and fill them in */
      RF_CallocAndAdd(desc->dagArray, desc->numStripes, sizeof(RF_DagList_t), (RF_DagList_t *), desc->cleanupList);

      for (i=0, asm_p = asmap; asm_p; asm_p=asm_p->next,i++) {
	/* grab dag header for this stripe */
	dag_h = NULL;
	desc->dagArray[i].desc = desc;

	if (stripeFuncs[i] == (RF_VoidFuncPtr) NULL)
	  {
	    /* use bailout functions for this stripe */
	    for (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr=physPtr->next, j++)
	      {
		uFunc = stripeUnitFuncs[stripeNum][j];
		if (uFunc == (RF_VoidFuncPtr) NULL)
		  {
		    /* use bailout functions for this stripe unit */
		    for (k = 0; k < physPtr->numSector; k++)
		      {
			/* create a dag for this block */
			InitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);
			desc->dagArray[i].numDags++;
			if (dag_h == NULL) {
			  dag_h = tempdag_h;
d432 59
a490 2
			else {
			  lastdag_h->next = tempdag_h;
d492 2
a493 114
			lastdag_h = tempdag_h;
			
			bFunc = blockFuncs[stripeUnitNum][k];
			RF_ASSERT(bFunc);
			asm_bp = asmh_b[stripeUnitNum][k]->stripeMap;
			(*bFunc)(raidPtr, asm_bp, tempdag_h, bp, flags, tempdag_h->allocList);
		      }
		    stripeUnitNum++;
		  }
		else
		  {
		    /* create a dag for this unit */
		    InitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);
		    desc->dagArray[i].numDags++;
		    if (dag_h == NULL) {
		      dag_h = tempdag_h;
		    }
		    else {
		      lastdag_h->next = tempdag_h;
		    }
		    lastdag_h = tempdag_h;
	  
		    asm_up = asmh_u[stripeNum][j]->stripeMap;
		    (*uFunc)(raidPtr, asm_up, tempdag_h, bp, flags, tempdag_h->allocList);
		  }
	      }
	    RF_ASSERT(j == asm_p->numStripeUnitsAccessed);
	    /* merge linked bailout dag to existing dag collection */
	    stripeNum++;
	  }
	else {
	  /* Create a dag for this parity stripe */
	  InitHdrNode(&tempdag_h, raidPtr, rf_useMemChunks);
	  desc->dagArray[i].numDags++;
	  if (dag_h == NULL) {
	    dag_h = tempdag_h;
	  }
	  else {
	    lastdag_h->next = tempdag_h;
	  }
	  lastdag_h = tempdag_h;
	  
	  (stripeFuncs[i])(raidPtr, asm_p, tempdag_h, bp, flags, tempdag_h->allocList);
	}
	desc->dagArray[i].dags = dag_h;
      }
      RF_ASSERT(i == desc->numStripes);

      /* free memory */
      if (asm_h->numStripes > MAXNSTRIPES)
	RF_Free(stripeFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));
      if ((numStripesBailed > 0) || (numStripeUnitsBailed > 0))
	{
	  stripeNum = 0;
	  stripeUnitNum = 0;
	  if (dag_h->asmList)
	    {
	      endASMList = dag_h->asmList;
	      while (endASMList->next)
		endASMList = endASMList->next;
	    }
	  else
	    endASMList = NULL;
	  /* walk through io, stripe by stripe */
	  for (i = 0, asm_p = asmap; asm_p; asm_p = asm_p->next, i++)
	    if (stripeFuncs[i] == NULL)
	      {
		numStripeUnits = asm_p->numStripeUnitsAccessed;
		/* walk through stripe, stripe unit by stripe unit */
		for (j = 0, physPtr = asm_p->physInfo; physPtr; physPtr = physPtr->next, j++)
		  {
		    if (stripeUnitFuncs[stripeNum][j] == NULL)
		      {
			numBlocks = physPtr->numSector;
			/* walk through stripe unit, block by block */
			for (k = 0; k < numBlocks; k++)
			  if (dag_h->asmList == NULL)
			    {
			      dag_h->asmList = asmh_b[stripeUnitNum][k];
			      endASMList = dag_h->asmList;
			    }
			  else
			    {
			      endASMList->next = asmh_b[stripeUnitNum][k];
			      endASMList = endASMList->next;
			    }
			RF_Free(asmh_b[stripeUnitNum], numBlocks * sizeof(RF_AccessStripeMapHeader_t *));
			RF_Free(blockFuncs[stripeUnitNum], numBlocks * sizeof(RF_VoidFuncPtr));
			stripeUnitNum++;
		      }
		    if (dag_h->asmList == NULL)
		      {
			dag_h->asmList = asmh_u[stripeNum][j];
			endASMList = dag_h->asmList;
		      }
		    else
		      {
			endASMList->next = asmh_u[stripeNum][j];
			endASMList = endASMList->next;
		      }
		  }
		RF_Free(asmh_u[stripeNum], numStripeUnits * sizeof(RF_AccessStripeMapHeader_t *));
		RF_Free(stripeUnitFuncs[stripeNum], numStripeUnits * sizeof(RF_VoidFuncPtr));
		stripeNum++;
	      }
	  RF_ASSERT(stripeNum == numStripesBailed);
	  RF_Free(stripeUnitFuncs, asm_h->numStripes * sizeof(RF_VoidFuncPtr));
	  RF_Free(asmh_u, asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));
	  if (numStripeUnitsBailed > 0)
	    {
	      RF_ASSERT(stripeUnitNum == numStripeUnitsBailed);
	      RF_Free(blockFuncs, raidPtr->Layout.numDataCol * asm_h->numStripes * sizeof(RF_VoidFuncPtr));
	      RF_Free(asmh_b, raidPtr->Layout.numDataCol * asm_h->numStripes * sizeof(RF_AccessStripeMapHeader_t **));
	    }
a494 2
      return(0);
    }
@

