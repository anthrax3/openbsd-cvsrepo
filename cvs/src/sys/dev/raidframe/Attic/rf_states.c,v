head	1.10;
access;
symbols
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.38
	OPENBSD_5_0:1.9.0.36
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.34
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.32
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.28
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.30
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.26
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.24
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.22
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.20
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.18
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.16
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.14
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.12
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.10
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.8
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.6.0.12
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.10
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.8
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2012.04.06.15.53.59;	author jsing;	state dead;
branches;
next	1.9;

1.9
date	2002.12.16.07.01.05;	author tdeval;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.28.23.38.10;	author tdeval;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.29.21.51.18;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.11.18.02.23;	author peter;	state Exp;
branches
	1.6.2.1
	1.6.12.1;
next	1.5;

1.5
date	2000.01.07.14.50.23;	author peter;	state Exp;
branches;
next	1.4;

1.4
date	99.08.04.13.10.55;	author peter;	state Exp;
branches;
next	1.3;

1.3
date	99.07.30.14.45.33;	author peter;	state Exp;
branches;
next	1.2;

1.2
date	99.02.16.00.03.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.50;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2003.03.28.00.38.29;	author niklas;	state Exp;
branches;
next	;

1.6.12.1
date	2002.01.31.22.55.38;	author niklas;	state Exp;
branches;
next	1.6.12.2;

1.6.12.2
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.6.12.3;

1.6.12.3
date	2003.05.19.22.21.53;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_states.c,v 1.9 2002/12/16 07:01:05 tdeval Exp $	*/
/*	$NetBSD: rf_states.c,v 1.15 2000/10/20 02:24:45 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Mark Holland, William V. Courtright II, Robby Findler
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/errno.h>

#include "rf_archs.h"
#include "rf_threadstuff.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_desc.h"
#include "rf_aselect.h"
#include "rf_general.h"
#include "rf_states.h"
#include "rf_dagutils.h"
#include "rf_driver.h"
#include "rf_engine.h"
#include "rf_map.h"
#include "rf_etimer.h"
#include "rf_kintf.h"

/*
 * Prototypes for some of the available states.
 *
 * States must:
 *
 *   - not block.
 *
 *   - either schedule rf_ContinueRaidAccess as a callback and return
 *     RF_TRUE, or complete all of their work and return RF_FALSE.
 *
 *   - increment desc->state when they have finished their work.
 */

char *StateName(RF_AccessState_t);

char *
StateName(RF_AccessState_t state)
{
	switch (state) {
		case rf_QuiesceState:return "QuiesceState";
	case rf_MapState:
		return "MapState";
	case rf_LockState:
		return "LockState";
	case rf_CreateDAGState:
		return "CreateDAGState";
	case rf_ExecuteDAGState:
		return "ExecuteDAGState";
	case rf_ProcessDAGState:
		return "ProcessDAGState";
	case rf_CleanupState:
		return "CleanupState";
	case rf_LastState:
		return "LastState";
	case rf_IncrAccessesCountState:
		return "IncrAccessesCountState";
	case rf_DecrAccessesCountState:
		return "DecrAccessesCountState";
	default:
		return "!!! UnnamedState !!!";
	}
}

void
rf_ContinueRaidAccess(RF_RaidAccessDesc_t *desc)
{
	int suspended = RF_FALSE;
	int current_state_index = desc->state;
	RF_AccessState_t current_state = desc->states[current_state_index];
	int unit = desc->raidPtr->raidid;

	do {
		current_state_index = desc->state;
		current_state = desc->states[current_state_index];

		switch (current_state) {

		case rf_QuiesceState:
			suspended = rf_State_Quiesce(desc);
			break;
		case rf_IncrAccessesCountState:
			suspended = rf_State_IncrAccessCount(desc);
			break;
		case rf_MapState:
			suspended = rf_State_Map(desc);
			break;
		case rf_LockState:
			suspended = rf_State_Lock(desc);
			break;
		case rf_CreateDAGState:
			suspended = rf_State_CreateDAG(desc);
			break;
		case rf_ExecuteDAGState:
			suspended = rf_State_ExecuteDAG(desc);
			break;
		case rf_ProcessDAGState:
			suspended = rf_State_ProcessDAG(desc);
			break;
		case rf_CleanupState:
			suspended = rf_State_Cleanup(desc);
			break;
		case rf_DecrAccessesCountState:
			suspended = rf_State_DecrAccessCount(desc);
			break;
		case rf_LastState:
			suspended = rf_State_LastState(desc);
			break;
		}

		/*
		 * After this point, we cannot dereference desc since desc may
		 * have been freed. desc is only freed in LastState, so if we
		 * reenter this function or loop back up, desc should be valid.
		 */

		if (rf_printStatesDebug) {
			printf("raid%d: State: %-24s StateIndex: %3i desc:"
			       " 0x%ld %s.\n", unit, StateName(current_state),
			       current_state_index, (long) desc, suspended ?
			       "callback scheduled" : "looping");
		}
	} while (!suspended && current_state != rf_LastState);

	return;
}


void
rf_ContinueDagAccess(RF_DagList_t *dagList)
{
	RF_AccTraceEntry_t *tracerec = &(dagList->desc->tracerec);
	RF_RaidAccessDesc_t *desc;
	RF_DagHeader_t *dag_h;
	RF_Etimer_t timer;
	int i;

	desc = dagList->desc;

	timer = tracerec->timer;
	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->specific.user.exec_us = RF_ETIMER_VAL_US(timer);
	RF_ETIMER_START(tracerec->timer);

	/* Skip to dag which just finished. */
	dag_h = dagList->dags;
	for (i = 0; i < dagList->numDagsDone; i++) {
		dag_h = dag_h->next;
	}

	/* Check to see if retry is required. */
	if (dag_h->status == rf_rollBackward) {
		/*
		 * When a dag fails, mark desc status as bad and allow all
		 * other dags in the desc to execute to completion. Then,
		 * free all dags and start over.
		 */
		desc->status = 1;	/* Bad status. */
		{
			printf("raid%d: DAG failure: %c addr 0x%lx (%ld)"
			       " nblk 0x%x (%d) buf 0x%lx.\n",
			       desc->raidPtr->raidid, desc->type,
			       (long) desc->raidAddress,
			       (long) desc->raidAddress,
			       (int) desc->numBlocks, (int) desc->numBlocks,
			       (unsigned long) (desc->bufPtr));
		}
	}
	dagList->numDagsDone++;
	rf_ContinueRaidAccess(desc);
}

int
rf_State_LastState(RF_RaidAccessDesc_t *desc)
{
	void (*callbackFunc) (RF_CBParam_t) = desc->callbackFunc;
	RF_CBParam_t callbackArg;

	callbackArg.p = desc->callbackArg;

	/*
	 * If this is not an async request, wake up the caller.
	 */
	if (desc->async_flag == 0)
		wakeup(desc->bp);

	/*
	 * That's all the IO for this one... Unbusy the 'disk'.
	 */

	rf_disk_unbusy(desc);

	/*
	 * Wakeup any requests waiting to go.
	 */

	RF_LOCK_MUTEX(((RF_Raid_t *) desc->raidPtr)->mutex);
	((RF_Raid_t *) desc->raidPtr)->openings++;
	RF_UNLOCK_MUTEX(((RF_Raid_t *) desc->raidPtr)->mutex);

	/* Wake up any pending I/O. */
	raidstart(((RF_Raid_t *) desc->raidPtr));

	/* printf("%s: Calling biodone on 0x%x.\n", __func__, desc->bp); */
	splassert(IPL_BIO);
	biodone(desc->bp);	/* Access came through ioctl. */

	if (callbackFunc)
		callbackFunc(callbackArg);
	rf_FreeRaidAccDesc(desc);

	return RF_FALSE;
}

int
rf_State_IncrAccessCount(RF_RaidAccessDesc_t *desc)
{
	RF_Raid_t *raidPtr;

	raidPtr = desc->raidPtr;
	/*
	 * Bummer. We have to do this to be 100% safe w.r.t. the increment
	 * below.
	 */
	RF_LOCK_MUTEX(raidPtr->access_suspend_mutex);
	raidPtr->accs_in_flight++;	/* Used to detect quiescence. */
	RF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);

	desc->state++;
	return RF_FALSE;
}

int
rf_State_DecrAccessCount(RF_RaidAccessDesc_t *desc)
{
	RF_Raid_t *raidPtr;

	raidPtr = desc->raidPtr;

	RF_LOCK_MUTEX(raidPtr->access_suspend_mutex);
	raidPtr->accs_in_flight--;
	if (raidPtr->accesses_suspended && raidPtr->accs_in_flight == 0) {
		rf_SignalQuiescenceLock(raidPtr, raidPtr->reconDesc);
	}
	rf_UpdateUserStats(raidPtr, RF_ETIMER_VAL_US(desc->timer),
	    desc->numBlocks);
	RF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);

	desc->state++;
	return RF_FALSE;
}

int
rf_State_Quiesce(RF_RaidAccessDesc_t *desc)
{
	RF_AccTraceEntry_t *tracerec = &desc->tracerec;
	RF_Etimer_t timer;
	int suspended = RF_FALSE;
	RF_Raid_t *raidPtr;

	raidPtr = desc->raidPtr;

	RF_ETIMER_START(timer);
	RF_ETIMER_START(desc->timer);

	RF_LOCK_MUTEX(raidPtr->access_suspend_mutex);
	if (raidPtr->accesses_suspended) {
		RF_CallbackDesc_t *cb;
		cb = rf_AllocCallbackDesc();
		/*
		 * XXX The following cast is quite bogus...
		 * rf_ContinueRaidAccess takes a (RF_RaidAccessDesc_t *)
		 * as an argument... GO
		 */
		cb->callbackFunc = (void (*) (RF_CBParam_t))
		    rf_ContinueRaidAccess;
		cb->callbackArg.p = (void *) desc;
		cb->next = raidPtr->quiesce_wait_list;
		raidPtr->quiesce_wait_list = cb;
		suspended = RF_TRUE;
	}
	RF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);

	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->specific.user.suspend_ovhd_us += RF_ETIMER_VAL_US(timer);

	if (suspended && rf_quiesceDebug)
		printf("Stalling access due to quiescence lock.\n");

	desc->state++;
	return suspended;
}

int
rf_State_Map(RF_RaidAccessDesc_t *desc)
{
	RF_Raid_t *raidPtr = desc->raidPtr;
	RF_AccTraceEntry_t *tracerec = &desc->tracerec;
	RF_Etimer_t timer;

	RF_ETIMER_START(timer);

	if (!(desc->asmap = rf_MapAccess(raidPtr, desc->raidAddress,
	     desc->numBlocks, desc->bufPtr, RF_DONT_REMAP)))
		RF_PANIC();

	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->specific.user.map_us = RF_ETIMER_VAL_US(timer);

	desc->state++;
	return RF_FALSE;
}

int
rf_State_Lock(RF_RaidAccessDesc_t *desc)
{
	RF_AccTraceEntry_t *tracerec = &desc->tracerec;
	RF_Raid_t *raidPtr = desc->raidPtr;
	RF_AccessStripeMapHeader_t *asmh = desc->asmap;
	RF_AccessStripeMap_t *asm_p;
	RF_Etimer_t timer;
	int suspended = RF_FALSE;

	RF_ETIMER_START(timer);
	if (!(raidPtr->Layout.map->flags & RF_NO_STRIPE_LOCKS)) {
		RF_StripeNum_t lastStripeID = -1;

		/* Acquire each lock that we don't already hold. */
		for (asm_p = asmh->stripeMap; asm_p; asm_p = asm_p->next) {
			RF_ASSERT(RF_IO_IS_R_OR_W(desc->type));
			if (!rf_suppressLocksAndLargeWrites &&
			    asm_p->parityInfo &&
			    !(desc->flags & RF_DAG_SUPPRESS_LOCKS) &&
			    !(asm_p->flags & RF_ASM_FLAGS_LOCK_TRIED)) {
				asm_p->flags |= RF_ASM_FLAGS_LOCK_TRIED;
				/* Locks must be acquired hierarchically. */
				RF_ASSERT(asm_p->stripeID > lastStripeID);
				lastStripeID = asm_p->stripeID;
				/*
				 * XXX The cast to (void (*)(RF_CBParam_t))
				 * below is bogus !  GO
				 */
				RF_INIT_LOCK_REQ_DESC(asm_p->lockReqDesc,
				    desc->type, (void (*) (struct buf *))
				     rf_ContinueRaidAccess, desc, asm_p,
				    raidPtr->Layout.dataSectorsPerStripe);
				if (rf_AcquireStripeLock(raidPtr->lockTable,
				     asm_p->stripeID, &asm_p->lockReqDesc)) {
					suspended = RF_TRUE;
					break;
				}
			}
			if (desc->type == RF_IO_TYPE_WRITE &&
			    raidPtr->status[asm_p->physInfo->row] ==
			    rf_rs_reconstructing) {
				if (!(asm_p->flags & RF_ASM_FLAGS_FORCE_TRIED))
				{
					int val;

					asm_p->flags |=
					    RF_ASM_FLAGS_FORCE_TRIED;
					/*
					 * XXX The cast below is quite
					 * bogus !!! XXX  GO
					 */
					val = rf_ForceOrBlockRecon(raidPtr,
					    asm_p,
					    (void (*) (RF_Raid_t *, void *))
					     rf_ContinueRaidAccess, desc);
					if (val == 0) {
						asm_p->flags |=
						    RF_ASM_FLAGS_RECON_BLOCKED;
					} else {
						suspended = RF_TRUE;
						break;
					}
				} else {
					if (rf_pssDebug) {
						printf("raid%d: skipping"
						       " force/block because"
						       " already done, psid"
						       " %ld.\n",
						       desc->raidPtr->raidid,
						       (long) asm_p->stripeID);
					}
				}
			} else {
				if (rf_pssDebug) {
					printf("raid%d: skipping force/block"
					       " because not write or not"
					       " under recon, psid %ld.\n",
					       desc->raidPtr->raidid,
					       (long) asm_p->stripeID);
				}
			}
		}

		RF_ETIMER_STOP(timer);
		RF_ETIMER_EVAL(timer);
		tracerec->specific.user.lock_us += RF_ETIMER_VAL_US(timer);

		if (suspended)
			return (RF_TRUE);
	}
	desc->state++;
	return (RF_FALSE);
}

/*
 * The following three states create, execute, and post-process DAGs.
 * The error recovery unit is a single DAG.
 * By default, SelectAlgorithm creates an array of DAGs, one per parity stripe.
 * In some tricky cases, multiple dags per stripe are created.
 *   - DAGs within a parity stripe are executed sequentially (arbitrary order).
 *   - DAGs for distinct parity stripes are executed concurrently.
 *
 * Repeat until all DAGs complete successfully -or- DAG selection fails.
 *
 * while !done
 *   create dag(s) (SelectAlgorithm)
 *   if dag
 *     execute dag (DispatchDAG)
 *     if dag successful
 *       done (SUCCESS)
 *     else
 *       !done (RETRY - start over with new dags)
 *   else
 *     done (FAIL)
 */
int
rf_State_CreateDAG(RF_RaidAccessDesc_t *desc)
{
	RF_AccTraceEntry_t *tracerec = &desc->tracerec;
	RF_Etimer_t timer;
	RF_DagHeader_t *dag_h;
	int i, selectStatus;

	/*
	 * Generate a dag for the access, and fire it off. When the dag
	 * completes, we'll get re-invoked in the next state.
	 */
	RF_ETIMER_START(timer);
	/* SelectAlgorithm returns one or more dags. */
	selectStatus = rf_SelectAlgorithm(desc,
	    desc->flags | RF_DAG_SUPPRESS_LOCKS);
	if (rf_printDAGsDebug)
		for (i = 0; i < desc->numStripes; i++)
			rf_PrintDAGList(desc->dagArray[i].dags);
	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	/* Update time to create all dags. */
	tracerec->specific.user.dag_create_us = RF_ETIMER_VAL_US(timer);

	desc->status = 0;	/* Good status. */

	if (selectStatus) {
		/* Failed to create a dag. */
		/*
		 * This happens when there are too many faults or incomplete
		 * dag libraries.
		 */
		printf("[Failed to create a DAG]\n");
		RF_PANIC();
	} else {
		/* Bind dags to desc. */
		for (i = 0; i < desc->numStripes; i++) {
			dag_h = desc->dagArray[i].dags;
			while (dag_h) {
				dag_h->bp = (struct buf *) desc->bp;
				dag_h->tracerec = tracerec;
				dag_h = dag_h->next;
			}
		}
		desc->flags |= RF_DAG_DISPATCH_RETURNED;
		desc->state++;	/* Next state should be rf_State_ExecuteDAG. */
	}
	return RF_FALSE;
}


/*
 * The access has an array of dagLists, one dagList per parity stripe.
 * Fire the first DAG in each parity stripe (dagList).
 * DAGs within a stripe (dagList) must be executed sequentially.
 *  - This preserves atomic parity update.
 * DAGs for independents parity groups (stripes) are fired concurrently.
 */
int
rf_State_ExecuteDAG(RF_RaidAccessDesc_t *desc)
{
	int i;
	RF_DagHeader_t *dag_h;
	RF_DagList_t *dagArray = desc->dagArray;

	/*
	 * Next state is always rf_State_ProcessDAG. Important to do this
	 * before firing the first dag (it may finish before we leave this
	 * routine).
	 */
	desc->state++;

	/*
	 * Sweep dag array, a stripe at a time, firing the first dag in each
	 * stripe.
	 */
	for (i = 0; i < desc->numStripes; i++) {
		RF_ASSERT(dagArray[i].numDags > 0);
		RF_ASSERT(dagArray[i].numDagsDone == 0);
		RF_ASSERT(dagArray[i].numDagsFired == 0);
		RF_ETIMER_START(dagArray[i].tracerec.timer);
		/* Fire first dag in this stripe. */
		dag_h = dagArray[i].dags;
		RF_ASSERT(dag_h);
		dagArray[i].numDagsFired++;
		/*
		 * XXX Yet another case where we pass in a conflicting
		 * function pointer :-(  XXX  GO
		 */
		rf_DispatchDAG(dag_h, (void (*) (void *)) rf_ContinueDagAccess,
		    &dagArray[i]);
	}

	/*
	 * The DAG will always call the callback, even if there was no
	 * blocking, so we are always suspended in this state.
	 */
	return RF_TRUE;
}


/*
 * rf_State_ProcessDAG is entered when a dag completes.
 * First, check that all DAGs in the access have completed.
 * If not, fire as many DAGs as possible.
 */
int
rf_State_ProcessDAG(RF_RaidAccessDesc_t *desc)
{
	RF_AccessStripeMapHeader_t *asmh = desc->asmap;
	RF_Raid_t *raidPtr = desc->raidPtr;
	RF_DagHeader_t *dag_h;
	int i, j, done = RF_TRUE;
	RF_DagList_t *dagArray = desc->dagArray;
	RF_Etimer_t timer;

	/* Check to see if this is the last dag. */
	for (i = 0; i < desc->numStripes; i++)
		if (dagArray[i].numDags != dagArray[i].numDagsDone)
			done = RF_FALSE;

	if (done) {
		if (desc->status) {
			/* A dag failed, retry. */
			RF_ETIMER_START(timer);
			/* Free all dags. */
			for (i = 0; i < desc->numStripes; i++) {
				rf_FreeDAG(desc->dagArray[i].dags);
			}
			rf_MarkFailuresInASMList(raidPtr, asmh);
			/* Back up to rf_State_CreateDAG. */
			desc->state = desc->state - 2;
			return RF_FALSE;
		} else {
			/* Move on to rf_State_Cleanup. */
			desc->state++;
		}
		return RF_FALSE;
	} else {
		/* More dags to execute. */
		/* See if any are ready to be fired. If so, fire them. */
		/*
		 * Don't fire the initial dag in a list, it's fired in
		 * rf_State_ExecuteDAG.
		 */
		for (i = 0; i < desc->numStripes; i++) {
			if ((dagArray[i].numDagsDone < dagArray[i].numDags) &&
			    (dagArray[i].numDagsDone ==
			     dagArray[i].numDagsFired) &&
			    (dagArray[i].numDagsFired > 0)) {
				RF_ETIMER_START(dagArray[i].tracerec.timer);
				/* Fire next dag in this stripe. */
				/*
				 * First, skip to next dag awaiting execution.
				 */
				dag_h = dagArray[i].dags;
				for (j = 0; j < dagArray[i].numDagsDone; j++)
					dag_h = dag_h->next;
				dagArray[i].numDagsFired++;
				/*
				 * XXX And again we pass a different function
				 * pointer... GO
				 */
				rf_DispatchDAG(dag_h, (void (*) (void *))
				    rf_ContinueDagAccess, &dagArray[i]);
			}
		}
		return RF_TRUE;
	}
}

/* Only make it this far if all dags complete successfully. */
int
rf_State_Cleanup(RF_RaidAccessDesc_t *desc)
{
	RF_AccTraceEntry_t *tracerec = &desc->tracerec;
	RF_AccessStripeMapHeader_t *asmh = desc->asmap;
	RF_Raid_t *raidPtr = desc->raidPtr;
	RF_AccessStripeMap_t *asm_p;
	RF_DagHeader_t *dag_h;
	RF_Etimer_t timer;
	int i;

	desc->state++;

	timer = tracerec->timer;
	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->specific.user.dag_retry_us = RF_ETIMER_VAL_US(timer);

	/* The RAID I/O is complete. Clean up. */
	tracerec->specific.user.dag_retry_us = 0;

	RF_ETIMER_START(timer);
	if (desc->flags & RF_DAG_RETURN_DAG) {
		/* Copy dags into paramDAG. */
		*(desc->paramDAG) = desc->dagArray[0].dags;
		dag_h = *(desc->paramDAG);
		for (i = 1; i < desc->numStripes; i++) {
			/* Concatenate dags from remaining stripes. */
			RF_ASSERT(dag_h);
			while (dag_h->next)
				dag_h = dag_h->next;
			dag_h->next = desc->dagArray[i].dags;
		}
	} else {
		/* Free all dags. */
		for (i = 0; i < desc->numStripes; i++) {
			rf_FreeDAG(desc->dagArray[i].dags);
		}
	}

	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->specific.user.cleanup_us = RF_ETIMER_VAL_US(timer);

	RF_ETIMER_START(timer);
	if (!(raidPtr->Layout.map->flags & RF_NO_STRIPE_LOCKS)) {
		for (asm_p = asmh->stripeMap; asm_p; asm_p = asm_p->next) {
			if (!rf_suppressLocksAndLargeWrites &&
			    asm_p->parityInfo &&
			    !(desc->flags & RF_DAG_SUPPRESS_LOCKS)) {
				RF_ASSERT_VALID_LOCKREQ(&asm_p->lockReqDesc);
				rf_ReleaseStripeLock(raidPtr->lockTable,
				    asm_p->stripeID, &asm_p->lockReqDesc);
			}
			if (asm_p->flags & RF_ASM_FLAGS_RECON_BLOCKED) {
				rf_UnblockRecon(raidPtr, asm_p);
			}
		}
	}
	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->specific.user.lock_us += RF_ETIMER_VAL_US(timer);

	RF_ETIMER_START(timer);
	if (desc->flags & RF_DAG_RETURN_ASM)
		*(desc->paramASM) = asmh;
	else
		rf_FreeAccessStripeMap(asmh);
	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	tracerec->specific.user.cleanup_us += RF_ETIMER_VAL_US(timer);

	RF_ETIMER_STOP(desc->timer);
	RF_ETIMER_EVAL(desc->timer);

	timer = desc->tracerec.tot_timer;
	RF_ETIMER_STOP(timer);
	RF_ETIMER_EVAL(timer);
	desc->tracerec.total_us = RF_ETIMER_VAL_US(timer);

	rf_LogTraceRec(raidPtr, tracerec);

	desc->flags |= RF_DAG_ACCESS_COMPLETE;

	return RF_FALSE;
}
@


1.9
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_states.c,v 1.8 2002/05/28 23:38:10 tdeval Exp $	*/
@


1.8
log
@splbio protection for biodone()
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_states.c,v 1.7 2001/12/29 21:51:18 tdeval Exp $	*/
d3 1
d48 12
a59 8
/* prototypes for some of the available states.

   States must:

     - not block.

     - either schedule rf_ContinueRaidAccess as a callback and return
       RF_TRUE, or complete all of their work and return RF_FALSE.
d61 1
a61 2
     - increment desc->state when they have finished their work.
*/
d63 1
a63 1
static char *
d91 2
a92 2
void 
rf_ContinueRaidAccess(RF_RaidAccessDesc_t * desc)
d94 2
a95 2
	int     suspended = RF_FALSE;
	int     current_state_index = desc->state;
d97 1
a97 1
	int     unit = desc->raidPtr->raidid;
a99 1

d137 2
a138 1
		/* after this point, we cannot dereference desc since desc may
d140 2
a141 1
		 * renter this function or loop back up, desc should be valid. */
d144 4
a147 4
			printf("raid%d: State: %-24s StateIndex: %3i desc: 0x%ld %s\n",
			       unit, StateName(current_state), 
			       current_state_index, (long) desc,
			    suspended ? "callback scheduled" : "looping");
d155 2
a156 2
void 
rf_ContinueDagAccess(RF_DagList_t * dagList)
d162 1
a162 1
	int     i;
d172 1
a172 1
	/* skip to dag which just finished */
d178 1
a178 1
	/* check to see if retry is required */
d180 6
a185 4
		/* when a dag fails, mark desc status as bad and allow all
		 * other dags in the desc to execute to completion.  then,
		 * free all dags and start over */
		desc->status = 1;	/* bad status */
d187 4
a190 2
			printf("raid%d: DAG failure: %c addr 0x%lx (%ld) nblk 0x%x (%d) buf 0x%lx\n",
			       desc->raidPtr->raidid, desc->type, 
d192 1
a192 2
			    (long) desc->raidAddress, (int) desc->numBlocks,
			       (int) desc->numBlocks, 
d200 2
a201 2
int 
rf_State_LastState(RF_RaidAccessDesc_t * desc)
d203 1
a203 1
	void    (*callbackFunc) (RF_CBParam_t) = desc->callbackFunc;
d209 2
a210 2
         * If this is not an async request, wake up the caller
         */
d214 2
a215 2
	/* 
	 * That's all the IO for this one... unbusy the 'disk'.
d220 1
a220 1
	/* 
d228 1
a228 1
	/* wake up any pending IO */
d231 1
a231 1
	/* printf("%s: Calling biodone on 0x%x\n", __func__, desc->bp); */
d233 1
a233 1
	biodone(desc->bp);	/* access came through ioctl */
d242 2
a243 2
int 
rf_State_IncrAccessCount(RF_RaidAccessDesc_t * desc)
d248 4
a251 2
	/* Bummer. We have to do this to be 100% safe w.r.t. the increment
	 * below */
d253 1
a253 1
	raidPtr->accs_in_flight++;	/* used to detect quiescence */
d260 2
a261 2
int 
rf_State_DecrAccessCount(RF_RaidAccessDesc_t * desc)
d272 2
a273 1
	rf_UpdateUserStats(raidPtr, RF_ETIMER_VAL_US(desc->timer), desc->numBlocks);
d280 2
a281 2
int 
rf_State_Quiesce(RF_RaidAccessDesc_t * desc)
d285 1
a285 1
	int     suspended = RF_FALSE;
d297 7
a303 4
		/* XXX the following cast is quite bogus...
		 * rf_ContinueRaidAccess takes a (RF_RaidAccessDesc_t *) as an
		 * argument..  GO */
		cb->callbackFunc = (void (*) (RF_CBParam_t)) rf_ContinueRaidAccess;
d316 1
a316 1
		printf("Stalling access due to quiescence lock\n");
d322 2
a323 2
int 
rf_State_Map(RF_RaidAccessDesc_t * desc)
d331 2
a332 2
	if (!(desc->asmap = rf_MapAccess(raidPtr, desc->raidAddress, desc->numBlocks,
		    desc->bufPtr, RF_DONT_REMAP)))
d343 2
a344 2
int 
rf_State_Lock(RF_RaidAccessDesc_t * desc)
d351 1
a351 1
	int     suspended = RF_FALSE;
d357 1
a357 1
		/* acquire each lock that we don't already hold */
d365 2
a366 3
				RF_ASSERT(asm_p->stripeID > lastStripeID);	/* locks must be
										 * acquired
										 * hierarchically */
d368 7
a374 4
				/* XXX the cast to (void (*)(RF_CBParam_t))
				 * below is bogus!  GO */
				RF_INIT_LOCK_REQ_DESC(asm_p->lockReqDesc, desc->type,
				    (void (*) (struct buf *)) rf_ContinueRaidAccess, desc, asm_p,
d376 2
a377 2
				if (rf_AcquireStripeLock(raidPtr->lockTable, asm_p->stripeID,
					&asm_p->lockReqDesc)) {
d383 16
a398 9
			    raidPtr->status[asm_p->physInfo->row] == rf_rs_reconstructing) {
				if (!(asm_p->flags & RF_ASM_FLAGS_FORCE_TRIED)) {
					int     val;

					asm_p->flags |= RF_ASM_FLAGS_FORCE_TRIED;
					/* XXX the cast below is quite
					 * bogus!!! XXX  GO */
					val = rf_ForceOrBlockRecon(raidPtr, asm_p,
					    (void (*) (RF_Raid_t *, void *)) rf_ContinueRaidAccess, desc);
d400 2
a401 1
						asm_p->flags |= RF_ASM_FLAGS_RECON_BLOCKED;
d408 5
a412 2
						printf("raid%d: skipping force/block because already done, psid %ld\n",
						       desc->raidPtr->raidid, 
d418 4
a421 2
					printf("raid%d: skipping force/block because not write or not under recon, psid %ld\n",
					       desc->raidPtr->raidid, 
d437 1
d439 6
a444 6
 * the following three states create, execute, and post-process dags
 * the error recovery unit is a single dag.
 * by default, SelectAlgorithm creates an array of dags, one per parity stripe
 * in some tricky cases, multiple dags per stripe are created
 *   - dags within a parity stripe are executed sequentially (arbitrary order)
 *   - dags for distinct parity stripes are executed concurrently
d446 1
a446 1
 * repeat until all dags complete successfully -or- dag selection fails
d459 2
a460 2
int 
rf_State_CreateDAG(RF_RaidAccessDesc_t * desc)
d465 1
a465 1
	int     i, selectStatus;
d467 4
a470 2
	/* generate a dag for the access, and fire it off.  When the dag
	 * completes, we'll get re-invoked in the next state. */
d472 3
a474 2
	/* SelectAlgorithm returns one or more dags */
	selectStatus = rf_SelectAlgorithm(desc, desc->flags | RF_DAG_SUPPRESS_LOCKS);
d480 1
a480 1
	/* update time to create all dags */
d483 1
a483 1
	desc->status = 0;	/* good status */
d486 5
a490 3
		/* failed to create a dag */
		/* this happens when there are too many faults or incomplete
		 * dag libraries */
d494 1
a494 1
		/* bind dags to desc */
d504 1
a504 1
		desc->state++;	/* next state should be rf_State_ExecuteDAG */
d510 9
a518 9

/* the access has an array of dagLists, one dagList per parity stripe.
 * fire the first dag in each parity stripe (dagList).
 * dags within a stripe (dagList) must be executed sequentially
 *  - this preserves atomic parity update
 * dags for independents parity groups (stripes) are fired concurrently */

int 
rf_State_ExecuteDAG(RF_RaidAccessDesc_t * desc)
d520 1
a520 1
	int     i;
d524 2
a525 1
	/* next state is always rf_State_ProcessDAG important to do this
d527 2
a528 1
	 * routine) */
d531 4
a534 2
	/* sweep dag array, a stripe at a time, firing the first dag in each
	 * stripe */
d540 1
a540 1
		/* fire first dag in this stripe */
d544 6
a549 3
		/* XXX Yet another case where we pass in a conflicting
		 * function pointer :-(  XXX  GO */
		rf_DispatchDAG(dag_h, (void (*) (void *)) rf_ContinueDagAccess, &dagArray[i]);
d552 4
a555 2
	/* the DAG will always call the callback, even if there was no
	 * blocking, so we are always suspended in this state */
d560 7
a566 7

/* rf_State_ProcessDAG is entered when a dag completes.
 * first, check to all dags in the access have completed
 * if not, fire as many dags as possible */

int 
rf_State_ProcessDAG(RF_RaidAccessDesc_t * desc)
d571 1
a571 1
	int     i, j, done = RF_TRUE;
d575 1
a575 1
	/* check to see if this is the last dag */
d582 1
a582 1
			/* a dag failed, retry */
d584 1
a584 1
			/* free all dags */
d589 1
a589 1
			/* back up to rf_State_CreateDAG */
d593 1
a593 1
			/* move on to rf_State_Cleanup */
d598 6
a603 4
		/* more dags to execute */
		/* see if any are ready to be fired.  if so, fire them */
		/* don't fire the initial dag in a list, it's fired in
		 * rf_State_ExecuteDAG */
d605 4
a608 3
			if ((dagArray[i].numDagsDone < dagArray[i].numDags)
			    && (dagArray[i].numDagsDone == dagArray[i].numDagsFired)
			    && (dagArray[i].numDagsFired > 0)) {
d610 4
a613 2
				/* fire next dag in this stripe */
				/* first, skip to next dag awaiting execution */
d618 6
a623 4
				/* XXX and again we pass a different function
				 * pointer.. GO */
				rf_DispatchDAG(dag_h, (void (*) (void *)) rf_ContinueDagAccess,
				    &dagArray[i]);
d629 4
a632 3
/* only make it this far if all dags complete successfully */
int 
rf_State_Cleanup(RF_RaidAccessDesc_t * desc)
d649 1
a649 1
	/* the RAID I/O is complete.  Clean up. */
d654 1
a654 1
		/* copy dags into paramDAG */
d658 1
a658 1
			/* concatenate dags from remaining stripes */
d665 1
a665 1
		/* free all dags */
d682 2
a683 3
				rf_ReleaseStripeLock(raidPtr->lockTable, 
						     asm_p->stripeID,
				    &asm_p->lockReqDesc);
@


1.7
log
@Enable the RAIDFrame auto-configuration feature.
This permits one to setup a kernel able to automatically retrieve, during
boot, the raid configuration from disks previously used in a RAIDFrame
set.  Moreover, one can define a raid set to contain a bootable partition
that will be mounted on / before the system has started.
A new RAID_AUTOCONFIG kernel option is used, in conjunction with the raid
pseudo-device, to activate the feature.

ok drahn@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_states.c,v 1.6 2000/01/11 18:02:23 peter Exp $	*/
d223 2
a224 1
	/* printf("Calling biodone on 0x%x\n",desc->bp); */
@


1.6
log
@sync with NetBSD

- removed threadid stuff
- removed unused files
- general tidyup
- you can no longer configure the same unit twice (without
de-configuring first of course).

Again, this has only been tested locally on IDE disks. Further testing
and feedback would be appreciated.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_states.c,v 1.5 2000/01/07 14:50:23 peter Exp $	*/
/*	$NetBSD: rf_states.c,v 1.13 2000/01/09 00:00:18 oster Exp $	*/
d207 6
d225 1
d455 1
a455 1
		printf("[Failed to create a DAG\n]");
@


1.6.2.1
log
@Merge in trunk
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: rf_states.c,v 1.15 2000/10/20 02:24:45 oster Exp $	*/
a206 6
	 * That's all the IO for this one... unbusy the 'disk'.
	 */

	rf_disk_unbusy(desc);

	/* 
a218 1

d448 1
a448 1
		printf("[Failed to create a DAG]\n");
@


1.6.2.2
log
@Sync the SMP branch with 3.3
@
text
@a2 1

d47 8
a54 12
/*
 * Prototypes for some of the available states.
 *
 * States must:
 *
 *   - not block.
 *
 *   - either schedule rf_ContinueRaidAccess as a callback and return
 *     RF_TRUE, or complete all of their work and return RF_FALSE.
 *
 *   - increment desc->state when they have finished their work.
 */
d56 2
a57 1
char *StateName(RF_AccessState_t);
d59 1
a59 1
char *
d87 2
a88 2
void
rf_ContinueRaidAccess(RF_RaidAccessDesc_t *desc)
d90 2
a91 2
	int suspended = RF_FALSE;
	int current_state_index = desc->state;
d93 1
a93 1
	int unit = desc->raidPtr->raidid;
d96 1
d134 1
a134 2
		/*
		 * After this point, we cannot dereference desc since desc may
d136 1
a136 2
		 * reenter this function or loop back up, desc should be valid.
		 */
d139 4
a142 4
			printf("raid%d: State: %-24s StateIndex: %3i desc:"
			       " 0x%ld %s.\n", unit, StateName(current_state),
			       current_state_index, (long) desc, suspended ?
			       "callback scheduled" : "looping");
d150 2
a151 2
void
rf_ContinueDagAccess(RF_DagList_t *dagList)
d157 1
a157 1
	int i;
d167 1
a167 1
	/* Skip to dag which just finished. */
d173 1
a173 1
	/* Check to see if retry is required. */
d175 4
a178 6
		/*
		 * When a dag fails, mark desc status as bad and allow all
		 * other dags in the desc to execute to completion. Then,
		 * free all dags and start over.
		 */
		desc->status = 1;	/* Bad status. */
d180 2
a181 4
			printf("raid%d: DAG failure: %c addr 0x%lx (%ld)"
			       " nblk 0x%x (%d) buf 0x%lx.\n",
			       desc->raidPtr->raidid, desc->type,
			       (long) desc->raidAddress,
d183 2
a184 1
			       (int) desc->numBlocks, (int) desc->numBlocks,
d192 2
a193 2
int
rf_State_LastState(RF_RaidAccessDesc_t *desc)
d195 1
a195 1
	void (*callbackFunc) (RF_CBParam_t) = desc->callbackFunc;
d201 2
a202 2
	 * If this is not an async request, wake up the caller.
	 */
d206 2
a207 2
	/*
	 * That's all the IO for this one... Unbusy the 'disk'.
d212 1
a212 1
	/*
d220 1
a220 1
	/* Wake up any pending I/O. */
d223 2
a224 3
	/* printf("%s: Calling biodone on 0x%x.\n", __func__, desc->bp); */
	splassert(IPL_BIO);
	biodone(desc->bp);	/* Access came through ioctl. */
d233 2
a234 2
int
rf_State_IncrAccessCount(RF_RaidAccessDesc_t *desc)
d239 2
a240 4
	/*
	 * Bummer. We have to do this to be 100% safe w.r.t. the increment
	 * below.
	 */
d242 1
a242 1
	raidPtr->accs_in_flight++;	/* Used to detect quiescence. */
d249 2
a250 2
int
rf_State_DecrAccessCount(RF_RaidAccessDesc_t *desc)
d261 1
a261 2
	rf_UpdateUserStats(raidPtr, RF_ETIMER_VAL_US(desc->timer),
	    desc->numBlocks);
d268 2
a269 2
int
rf_State_Quiesce(RF_RaidAccessDesc_t *desc)
d273 1
a273 1
	int suspended = RF_FALSE;
d285 4
a288 7
		/*
		 * XXX The following cast is quite bogus...
		 * rf_ContinueRaidAccess takes a (RF_RaidAccessDesc_t *)
		 * as an argument... GO
		 */
		cb->callbackFunc = (void (*) (RF_CBParam_t))
		    rf_ContinueRaidAccess;
d301 1
a301 1
		printf("Stalling access due to quiescence lock.\n");
d307 2
a308 2
int
rf_State_Map(RF_RaidAccessDesc_t *desc)
d316 2
a317 2
	if (!(desc->asmap = rf_MapAccess(raidPtr, desc->raidAddress,
	     desc->numBlocks, desc->bufPtr, RF_DONT_REMAP)))
d328 2
a329 2
int
rf_State_Lock(RF_RaidAccessDesc_t *desc)
d336 1
a336 1
	int suspended = RF_FALSE;
d342 1
a342 1
		/* Acquire each lock that we don't already hold. */
d350 3
a352 2
				/* Locks must be acquired hierarchically. */
				RF_ASSERT(asm_p->stripeID > lastStripeID);
d354 4
a357 7
				/*
				 * XXX The cast to (void (*)(RF_CBParam_t))
				 * below is bogus !  GO
				 */
				RF_INIT_LOCK_REQ_DESC(asm_p->lockReqDesc,
				    desc->type, (void (*) (struct buf *))
				     rf_ContinueRaidAccess, desc, asm_p,
d359 2
a360 2
				if (rf_AcquireStripeLock(raidPtr->lockTable,
				     asm_p->stripeID, &asm_p->lockReqDesc)) {
d366 9
a374 16
			    raidPtr->status[asm_p->physInfo->row] ==
			    rf_rs_reconstructing) {
				if (!(asm_p->flags & RF_ASM_FLAGS_FORCE_TRIED))
				{
					int val;

					asm_p->flags |=
					    RF_ASM_FLAGS_FORCE_TRIED;
					/*
					 * XXX The cast below is quite
					 * bogus !!! XXX  GO
					 */
					val = rf_ForceOrBlockRecon(raidPtr,
					    asm_p,
					    (void (*) (RF_Raid_t *, void *))
					     rf_ContinueRaidAccess, desc);
d376 1
a376 2
						asm_p->flags |=
						    RF_ASM_FLAGS_RECON_BLOCKED;
d383 2
a384 5
						printf("raid%d: skipping"
						       " force/block because"
						       " already done, psid"
						       " %ld.\n",
						       desc->raidPtr->raidid,
d390 2
a391 4
					printf("raid%d: skipping force/block"
					       " because not write or not"
					       " under recon, psid %ld.\n",
					       desc->raidPtr->raidid,
a406 1

d408 6
a413 6
 * The following three states create, execute, and post-process DAGs.
 * The error recovery unit is a single DAG.
 * By default, SelectAlgorithm creates an array of DAGs, one per parity stripe.
 * In some tricky cases, multiple dags per stripe are created.
 *   - DAGs within a parity stripe are executed sequentially (arbitrary order).
 *   - DAGs for distinct parity stripes are executed concurrently.
d415 1
a415 1
 * Repeat until all DAGs complete successfully -or- DAG selection fails.
d428 2
a429 2
int
rf_State_CreateDAG(RF_RaidAccessDesc_t *desc)
d434 1
a434 1
	int i, selectStatus;
d436 2
a437 4
	/*
	 * Generate a dag for the access, and fire it off. When the dag
	 * completes, we'll get re-invoked in the next state.
	 */
d439 2
a440 3
	/* SelectAlgorithm returns one or more dags. */
	selectStatus = rf_SelectAlgorithm(desc,
	    desc->flags | RF_DAG_SUPPRESS_LOCKS);
d446 1
a446 1
	/* Update time to create all dags. */
d449 1
a449 1
	desc->status = 0;	/* Good status. */
d452 3
a454 5
		/* Failed to create a dag. */
		/*
		 * This happens when there are too many faults or incomplete
		 * dag libraries.
		 */
d458 1
a458 1
		/* Bind dags to desc. */
d468 1
a468 1
		desc->state++;	/* Next state should be rf_State_ExecuteDAG. */
d474 9
a482 9
/*
 * The access has an array of dagLists, one dagList per parity stripe.
 * Fire the first DAG in each parity stripe (dagList).
 * DAGs within a stripe (dagList) must be executed sequentially.
 *  - This preserves atomic parity update.
 * DAGs for independents parity groups (stripes) are fired concurrently.
 */
int
rf_State_ExecuteDAG(RF_RaidAccessDesc_t *desc)
d484 1
a484 1
	int i;
d488 1
a488 2
	/*
	 * Next state is always rf_State_ProcessDAG. Important to do this
d490 1
a490 2
	 * routine).
	 */
d493 2
a494 4
	/*
	 * Sweep dag array, a stripe at a time, firing the first dag in each
	 * stripe.
	 */
d500 1
a500 1
		/* Fire first dag in this stripe. */
d504 3
a506 6
		/*
		 * XXX Yet another case where we pass in a conflicting
		 * function pointer :-(  XXX  GO
		 */
		rf_DispatchDAG(dag_h, (void (*) (void *)) rf_ContinueDagAccess,
		    &dagArray[i]);
d509 2
a510 4
	/*
	 * The DAG will always call the callback, even if there was no
	 * blocking, so we are always suspended in this state.
	 */
d515 7
a521 7
/*
 * rf_State_ProcessDAG is entered when a dag completes.
 * First, check that all DAGs in the access have completed.
 * If not, fire as many DAGs as possible.
 */
int
rf_State_ProcessDAG(RF_RaidAccessDesc_t *desc)
d526 1
a526 1
	int i, j, done = RF_TRUE;
d530 1
a530 1
	/* Check to see if this is the last dag. */
d537 1
a537 1
			/* A dag failed, retry. */
d539 1
a539 1
			/* Free all dags. */
d544 1
a544 1
			/* Back up to rf_State_CreateDAG. */
d548 1
a548 1
			/* Move on to rf_State_Cleanup. */
d553 4
a556 6
		/* More dags to execute. */
		/* See if any are ready to be fired. If so, fire them. */
		/*
		 * Don't fire the initial dag in a list, it's fired in
		 * rf_State_ExecuteDAG.
		 */
d558 3
a560 4
			if ((dagArray[i].numDagsDone < dagArray[i].numDags) &&
			    (dagArray[i].numDagsDone ==
			     dagArray[i].numDagsFired) &&
			    (dagArray[i].numDagsFired > 0)) {
d562 2
a563 4
				/* Fire next dag in this stripe. */
				/*
				 * First, skip to next dag awaiting execution.
				 */
d568 4
a571 6
				/*
				 * XXX And again we pass a different function
				 * pointer... GO
				 */
				rf_DispatchDAG(dag_h, (void (*) (void *))
				    rf_ContinueDagAccess, &dagArray[i]);
d577 3
a579 4

/* Only make it this far if all dags complete successfully. */
int
rf_State_Cleanup(RF_RaidAccessDesc_t *desc)
d596 1
a596 1
	/* The RAID I/O is complete. Clean up. */
d601 1
a601 1
		/* Copy dags into paramDAG. */
d605 1
a605 1
			/* Concatenate dags from remaining stripes. */
d612 1
a612 1
		/* Free all dags. */
d629 3
a631 2
				rf_ReleaseStripeLock(raidPtr->lockTable,
				    asm_p->stripeID, &asm_p->lockReqDesc);
@


1.6.12.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_states.c,v 1.7 2001/12/29 21:51:18 tdeval Exp $	*/
/*	$NetBSD: rf_states.c,v 1.15 2000/10/20 02:24:45 oster Exp $	*/
a206 6
	 * That's all the IO for this one... unbusy the 'disk'.
	 */

	rf_disk_unbusy(desc);

	/* 
a218 1

d448 1
a448 1
		printf("[Failed to create a DAG]\n");
@


1.6.12.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_states.c,v 1.6.12.1 2002/01/31 22:55:38 niklas Exp $	*/
d223 1
a223 2
	/* printf("%s: Calling biodone on 0x%x\n", __func__, desc->bp); */
	splassert(IPL_BIO);
@


1.6.12.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d47 8
a54 12
/*
 * Prototypes for some of the available states.
 *
 * States must:
 *
 *   - not block.
 *
 *   - either schedule rf_ContinueRaidAccess as a callback and return
 *     RF_TRUE, or complete all of their work and return RF_FALSE.
 *
 *   - increment desc->state when they have finished their work.
 */
d56 2
a57 1
char *StateName(RF_AccessState_t);
d59 1
a59 1
char *
d87 2
a88 2
void
rf_ContinueRaidAccess(RF_RaidAccessDesc_t *desc)
d90 2
a91 2
	int suspended = RF_FALSE;
	int current_state_index = desc->state;
d93 1
a93 1
	int unit = desc->raidPtr->raidid;
d96 1
d134 1
a134 2
		/*
		 * After this point, we cannot dereference desc since desc may
d136 1
a136 2
		 * reenter this function or loop back up, desc should be valid.
		 */
d139 4
a142 4
			printf("raid%d: State: %-24s StateIndex: %3i desc:"
			       " 0x%ld %s.\n", unit, StateName(current_state),
			       current_state_index, (long) desc, suspended ?
			       "callback scheduled" : "looping");
d150 2
a151 2
void
rf_ContinueDagAccess(RF_DagList_t *dagList)
d157 1
a157 1
	int i;
d167 1
a167 1
	/* Skip to dag which just finished. */
d173 1
a173 1
	/* Check to see if retry is required. */
d175 4
a178 6
		/*
		 * When a dag fails, mark desc status as bad and allow all
		 * other dags in the desc to execute to completion. Then,
		 * free all dags and start over.
		 */
		desc->status = 1;	/* Bad status. */
d180 2
a181 4
			printf("raid%d: DAG failure: %c addr 0x%lx (%ld)"
			       " nblk 0x%x (%d) buf 0x%lx.\n",
			       desc->raidPtr->raidid, desc->type,
			       (long) desc->raidAddress,
d183 2
a184 1
			       (int) desc->numBlocks, (int) desc->numBlocks,
d192 2
a193 2
int
rf_State_LastState(RF_RaidAccessDesc_t *desc)
d195 1
a195 1
	void (*callbackFunc) (RF_CBParam_t) = desc->callbackFunc;
d201 2
a202 2
	 * If this is not an async request, wake up the caller.
	 */
d206 2
a207 2
	/*
	 * That's all the IO for this one... Unbusy the 'disk'.
d212 1
a212 1
	/*
d220 1
a220 1
	/* Wake up any pending I/O. */
d223 1
a223 1
	/* printf("%s: Calling biodone on 0x%x.\n", __func__, desc->bp); */
d225 1
a225 1
	biodone(desc->bp);	/* Access came through ioctl. */
d234 2
a235 2
int
rf_State_IncrAccessCount(RF_RaidAccessDesc_t *desc)
d240 2
a241 4
	/*
	 * Bummer. We have to do this to be 100% safe w.r.t. the increment
	 * below.
	 */
d243 1
a243 1
	raidPtr->accs_in_flight++;	/* Used to detect quiescence. */
d250 2
a251 2
int
rf_State_DecrAccessCount(RF_RaidAccessDesc_t *desc)
d262 1
a262 2
	rf_UpdateUserStats(raidPtr, RF_ETIMER_VAL_US(desc->timer),
	    desc->numBlocks);
d269 2
a270 2
int
rf_State_Quiesce(RF_RaidAccessDesc_t *desc)
d274 1
a274 1
	int suspended = RF_FALSE;
d286 4
a289 7
		/*
		 * XXX The following cast is quite bogus...
		 * rf_ContinueRaidAccess takes a (RF_RaidAccessDesc_t *)
		 * as an argument... GO
		 */
		cb->callbackFunc = (void (*) (RF_CBParam_t))
		    rf_ContinueRaidAccess;
d302 1
a302 1
		printf("Stalling access due to quiescence lock.\n");
d308 2
a309 2
int
rf_State_Map(RF_RaidAccessDesc_t *desc)
d317 2
a318 2
	if (!(desc->asmap = rf_MapAccess(raidPtr, desc->raidAddress,
	     desc->numBlocks, desc->bufPtr, RF_DONT_REMAP)))
d329 2
a330 2
int
rf_State_Lock(RF_RaidAccessDesc_t *desc)
d337 1
a337 1
	int suspended = RF_FALSE;
d343 1
a343 1
		/* Acquire each lock that we don't already hold. */
d351 3
a353 2
				/* Locks must be acquired hierarchically. */
				RF_ASSERT(asm_p->stripeID > lastStripeID);
d355 4
a358 7
				/*
				 * XXX The cast to (void (*)(RF_CBParam_t))
				 * below is bogus !  GO
				 */
				RF_INIT_LOCK_REQ_DESC(asm_p->lockReqDesc,
				    desc->type, (void (*) (struct buf *))
				     rf_ContinueRaidAccess, desc, asm_p,
d360 2
a361 2
				if (rf_AcquireStripeLock(raidPtr->lockTable,
				     asm_p->stripeID, &asm_p->lockReqDesc)) {
d367 9
a375 16
			    raidPtr->status[asm_p->physInfo->row] ==
			    rf_rs_reconstructing) {
				if (!(asm_p->flags & RF_ASM_FLAGS_FORCE_TRIED))
				{
					int val;

					asm_p->flags |=
					    RF_ASM_FLAGS_FORCE_TRIED;
					/*
					 * XXX The cast below is quite
					 * bogus !!! XXX  GO
					 */
					val = rf_ForceOrBlockRecon(raidPtr,
					    asm_p,
					    (void (*) (RF_Raid_t *, void *))
					     rf_ContinueRaidAccess, desc);
d377 1
a377 2
						asm_p->flags |=
						    RF_ASM_FLAGS_RECON_BLOCKED;
d384 2
a385 5
						printf("raid%d: skipping"
						       " force/block because"
						       " already done, psid"
						       " %ld.\n",
						       desc->raidPtr->raidid,
d391 2
a392 4
					printf("raid%d: skipping force/block"
					       " because not write or not"
					       " under recon, psid %ld.\n",
					       desc->raidPtr->raidid,
a407 1

d409 6
a414 6
 * The following three states create, execute, and post-process DAGs.
 * The error recovery unit is a single DAG.
 * By default, SelectAlgorithm creates an array of DAGs, one per parity stripe.
 * In some tricky cases, multiple dags per stripe are created.
 *   - DAGs within a parity stripe are executed sequentially (arbitrary order).
 *   - DAGs for distinct parity stripes are executed concurrently.
d416 1
a416 1
 * Repeat until all DAGs complete successfully -or- DAG selection fails.
d429 2
a430 2
int
rf_State_CreateDAG(RF_RaidAccessDesc_t *desc)
d435 1
a435 1
	int i, selectStatus;
d437 2
a438 4
	/*
	 * Generate a dag for the access, and fire it off. When the dag
	 * completes, we'll get re-invoked in the next state.
	 */
d440 2
a441 3
	/* SelectAlgorithm returns one or more dags. */
	selectStatus = rf_SelectAlgorithm(desc,
	    desc->flags | RF_DAG_SUPPRESS_LOCKS);
d447 1
a447 1
	/* Update time to create all dags. */
d450 1
a450 1
	desc->status = 0;	/* Good status. */
d453 3
a455 5
		/* Failed to create a dag. */
		/*
		 * This happens when there are too many faults or incomplete
		 * dag libraries.
		 */
d459 1
a459 1
		/* Bind dags to desc. */
d469 1
a469 1
		desc->state++;	/* Next state should be rf_State_ExecuteDAG. */
d475 9
a483 9
/*
 * The access has an array of dagLists, one dagList per parity stripe.
 * Fire the first DAG in each parity stripe (dagList).
 * DAGs within a stripe (dagList) must be executed sequentially.
 *  - This preserves atomic parity update.
 * DAGs for independents parity groups (stripes) are fired concurrently.
 */
int
rf_State_ExecuteDAG(RF_RaidAccessDesc_t *desc)
d485 1
a485 1
	int i;
d489 1
a489 2
	/*
	 * Next state is always rf_State_ProcessDAG. Important to do this
d491 1
a491 2
	 * routine).
	 */
d494 2
a495 4
	/*
	 * Sweep dag array, a stripe at a time, firing the first dag in each
	 * stripe.
	 */
d501 1
a501 1
		/* Fire first dag in this stripe. */
d505 3
a507 6
		/*
		 * XXX Yet another case where we pass in a conflicting
		 * function pointer :-(  XXX  GO
		 */
		rf_DispatchDAG(dag_h, (void (*) (void *)) rf_ContinueDagAccess,
		    &dagArray[i]);
d510 2
a511 4
	/*
	 * The DAG will always call the callback, even if there was no
	 * blocking, so we are always suspended in this state.
	 */
d516 7
a522 7
/*
 * rf_State_ProcessDAG is entered when a dag completes.
 * First, check that all DAGs in the access have completed.
 * If not, fire as many DAGs as possible.
 */
int
rf_State_ProcessDAG(RF_RaidAccessDesc_t *desc)
d527 1
a527 1
	int i, j, done = RF_TRUE;
d531 1
a531 1
	/* Check to see if this is the last dag. */
d538 1
a538 1
			/* A dag failed, retry. */
d540 1
a540 1
			/* Free all dags. */
d545 1
a545 1
			/* Back up to rf_State_CreateDAG. */
d549 1
a549 1
			/* Move on to rf_State_Cleanup. */
d554 4
a557 6
		/* More dags to execute. */
		/* See if any are ready to be fired. If so, fire them. */
		/*
		 * Don't fire the initial dag in a list, it's fired in
		 * rf_State_ExecuteDAG.
		 */
d559 3
a561 4
			if ((dagArray[i].numDagsDone < dagArray[i].numDags) &&
			    (dagArray[i].numDagsDone ==
			     dagArray[i].numDagsFired) &&
			    (dagArray[i].numDagsFired > 0)) {
d563 2
a564 4
				/* Fire next dag in this stripe. */
				/*
				 * First, skip to next dag awaiting execution.
				 */
d569 4
a572 6
				/*
				 * XXX And again we pass a different function
				 * pointer... GO
				 */
				rf_DispatchDAG(dag_h, (void (*) (void *))
				    rf_ContinueDagAccess, &dagArray[i]);
d578 3
a580 4

/* Only make it this far if all dags complete successfully. */
int
rf_State_Cleanup(RF_RaidAccessDesc_t *desc)
d597 1
a597 1
	/* The RAID I/O is complete. Clean up. */
d602 1
a602 1
		/* Copy dags into paramDAG. */
d606 1
a606 1
			/* Concatenate dags from remaining stripes. */
d613 1
a613 1
		/* Free all dags. */
d630 3
a632 2
				rf_ReleaseStripeLock(raidPtr->lockTable,
				    asm_p->stripeID, &asm_p->lockReqDesc);
@


1.5
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_states.c,v 1.4 1999/08/04 13:10:55 peter Exp $	*/
/*	$NetBSD: rf_states.c,v 1.10 1999/12/12 20:52:37 oster Exp $	*/
a37 1
#include "rf_threadid.h"
d93 1
d139 3
a141 5
			int     tid;
			rf_get_threadid(tid);

			printf("[%d] State: %-24s StateIndex: %3i desc: 0x%ld %s\n",
			    tid, StateName(current_state), current_state_index, (long) desc,
d180 3
a182 2
			printf("[%d] DAG failure: %c addr 0x%lx (%ld) nblk 0x%x (%d) buf 0x%lx\n",
			    desc->tid, desc->type, (long) desc->raidAddress,
d184 2
a185 1
			    (int) desc->numBlocks, (unsigned long) (desc->bufPtr));
d376 3
a378 2
						printf("[%d] skipping force/block because already done, psid %ld\n",
						    desc->tid, (long) asm_p->stripeID);
d383 3
a385 2
					printf("[%d] skipping force/block because not write or not under recon, psid %ld\n",
					    desc->tid, (long) asm_p->stripeID);
d580 1
a580 1
	int     tid, i;
a583 2
	rf_get_threadid(tid);

d622 2
a623 1
				rf_ReleaseStripeLock(raidPtr->lockTable, asm_p->stripeID,
@


1.4
log
@* remove redundant rf_ccmn.h

* remove init call to rf_ConfigureEtimer() and rf_sys.c in which it is the
  only function. update conf/files to reflect this.

* update sources to make sure _KERNEL is used not KERNEL

* change rf_etimer.h to protect macros an include of sys/kernel.h with
  a check for _KERNEL - let raidctl compile again.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_states.c,v 1.3 1999/07/30 14:45:33 peter Exp $	*/
/*	$NetBSD: rf_states.c,v 1.7 1999/07/08 00:45:24 oster Exp $	*/
d46 1
a46 8

#if defined(_KERNEL) && (DKUSAGE > 0)
#include <sys/dkusage.h>
#include <io/common/iotypes.h>
#include <io/cam/dec_cam.h>
#include <io/cam/cam.h>
#include <io/cam/pdrv.h>
#endif				/* _KERNEL && DKUSAGE > 0 */
a191 1

d200 13
a212 21
	if (!(desc->flags & RF_DAG_TEST_ACCESS)) {	/* don't biodone if this */
#if DKUSAGE > 0
		RF_DKU_END_IO(((RF_Raid_t *) desc->raidPtr)->raidid, (struct buf *) desc->bp);
#else
		RF_DKU_END_IO(((RF_Raid_t *) desc->raidPtr)->raidid);
#endif				/* DKUSAGE > 0 */

		/*
	         * If this is not an async request, wake up the caller
	         */
		if (desc->async_flag == 0)
			wakeup(desc->bp);

		/* 
		 * Wakeup any requests waiting to go.
		 */

		RF_LOCK_MUTEX(((RF_Raid_t *) desc->raidPtr)->mutex);
		((RF_Raid_t *) desc->raidPtr)->openings++;
		wakeup(&(((RF_Raid_t *) desc->raidPtr)->openings));
		RF_UNLOCK_MUTEX(((RF_Raid_t *) desc->raidPtr)->mutex);
d214 5
a218 3
		/* printf("Calling biodone on 0x%x\n",desc->bp); */
		biodone(desc->bp);	/* access came through ioctl */
	}
@


1.3
log
@Update RAIDframe from NetBSD-current as of 1999/07/26.

Please note that you *must* follow the upgrade instructions at

	http://www.cs.usask.ca/staff/oster/clabel_upgrade.html

before installing the new raidctl and new kernel using this code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_states.c,v 1.2 1999/02/16 00:03:28 niklas Exp $	*/
d47 1
a47 1
#if defined(KERNEL) && (DKUSAGE > 0)
d53 1
a53 1
#endif				/* KERNEL && DKUSAGE > 0 */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_states.c,v 1.1 1999/01/11 14:29:50 niklas Exp $	*/
/*	$NetBSD: rf_states.c,v 1.6 1999/02/05 00:06:17 oster Exp $	*/
d220 9
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_states.c,v 1.2 1998/11/13 13:47:56 drochner Exp $	*/
/*	$NetBSD: rf_states.c,v 1.2 1998/11/13 13:47:56 drochner Exp $	*/
a29 191
/*
 * :  
 * Log: rf_states.c,v 
 * Revision 1.45  1996/07/28 20:31:39  jimz
 * i386netbsd port
 * true/false fixup
 *
 * Revision 1.44  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.43  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.42  1996/07/17  21:00:58  jimz
 * clean up timer interface, tracing
 *
 * Revision 1.41  1996/07/11  19:08:00  jimz
 * generalize reconstruction mechanism
 * allow raid1 reconstructs via copyback (done with array
 * quiesced, not online, therefore not disk-directed)
 *
 * Revision 1.40  1996/06/17  14:38:33  jimz
 * properly #if out RF_DEMO code
 * fix bug in MakeConfig that was causing weird behavior
 * in configuration routines (config was not zeroed at start)
 * clean up genplot handling of stacks
 *
 * Revision 1.39  1996/06/11  18:12:17  jimz
 * got rid of evil race condition in LastState
 *
 * Revision 1.38  1996/06/10  14:18:58  jimz
 * move user, throughput stats into per-array structure
 *
 * Revision 1.37  1996/06/09  02:36:46  jimz
 * lots of little crufty cleanup- fixup whitespace
 * issues, comment #ifdefs, improve typing in some
 * places (esp size-related)
 *
 * Revision 1.36  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.35  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.34  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.33  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.32  1996/05/30  12:59:18  jimz
 * make etimer happier, more portable
 *
 * Revision 1.31  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.30  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.29  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.28  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.27  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.26  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.25  1996/05/20  19:31:46  jimz
 * straighten out syntax problems
 *
 * Revision 1.24  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.23  1996/05/16  23:37:33  jimz
 * fix misspelled "else"
 *
 * Revision 1.22  1996/05/15  22:33:32  jimz
 * appropriately #ifdef cache stuff
 *
 * Revision 1.21  1996/05/06  22:09:20  wvcii
 * rf_State_ExecuteDAG now only executes the first dag
 * of each parity stripe in a multi-stripe access
 *
 * rf_State_ProcessDAG now executes all dags in a
 * multi-stripe access except the first dag of each stripe.
 *
 * Revision 1.20  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.19  1995/11/19  16:29:50  wvcii
 * replaced LaunchDAGState with CreateDAGState, ExecuteDAGState
 * created rf_ContinueDagAccess
 *
 * Revision 1.18  1995/11/07  15:37:23  wvcii
 * deleted states SendDAGState, RetryDAGState
 * added staes: LaunchDAGState, ProcessDAGState
 * code no longer has a hard-coded retry count of 1 but will support
 * retries until a dag can not be found (selected) to perform the user request
 *
 * Revision 1.17  1995/10/09  23:36:08  amiri
 * *** empty log message ***
 *
 * Revision 1.16  1995/10/09  18:36:58  jimz
 * moved call to StopThroughput for user-level driver to rf_driver.c
 *
 * Revision 1.15  1995/10/09  18:07:23  wvcii
 * lastState now call rf_StopThroughputStats
 *
 * Revision 1.14  1995/10/05  18:56:31  jimz
 * no-op file if !INCLUDE_VS
 *
 * Revision 1.13  1995/09/30  20:38:24  jimz
 * LogTraceRec now takes a Raid * as its first argument
 *
 * Revision 1.12  1995/09/19  22:58:54  jimz
 * integrate DKUSAGE into raidframe
 *
 * Revision 1.11  1995/09/07  01:26:55  jimz
 * Achive basic compilation in kernel. Kernel functionality
 * is not guaranteed at all, but it'll compile. Mostly. I hope.
 *
 * Revision 1.10  1995/07/26  03:28:31  robby
 * intermediary checkin
 *
 * Revision 1.9  1995/07/23  02:50:33  robby
 * oops. fixed boo boo
 *
 * Revision 1.8  1995/07/22  22:54:54  robby
 * removed incorrect comment
 *
 * Revision 1.7  1995/07/21  19:30:26  robby
 * added idle state for rf_when-idle.c
 *
 * Revision 1.6  1995/07/10  19:06:28  rachad
 * *** empty log message ***
 *
 * Revision 1.5  1995/07/10  17:30:38  robby
 * added virtual striping lock states
 *
 * Revision 1.4  1995/07/08  18:05:39  rachad
 * Linked up Claudsons code with the real cache
 *
 * Revision 1.3  1995/07/06  14:38:50  robby
 * changed get_thread_id to get_threadid
 *
 * Revision 1.2  1995/07/06  14:24:15  robby
 * added log
 *
 */

#ifdef _KERNEL
#define KERNEL
#endif

#ifdef KERNEL
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
#include <dkusage.h>
#endif /* !__NetBSD__ && !__OpenBSD__ */
#endif /* KERNEL */

d53 1
a53 1
#endif /* KERNEL && DKUSAGE > 0 */
d67 138
d206 1
a206 157
#ifdef SIMULATE
extern int global_async_flag;
#endif /* SIMULATE */

static char *StateName(RF_AccessState_t state)
{
  switch (state) {
    case rf_QuiesceState:            return "QuiesceState";
    case rf_MapState:                return "MapState";
    case rf_LockState:               return "LockState";
    case rf_CreateDAGState:          return "CreateDAGState";
    case rf_ExecuteDAGState:         return "ExecuteDAGState";
    case rf_ProcessDAGState:         return "ProcessDAGState";
    case rf_CleanupState:            return "CleanupState";
    case rf_LastState:               return "LastState";
    case rf_IncrAccessesCountState:  return "IncrAccessesCountState";
    case rf_DecrAccessesCountState:  return "DecrAccessesCountState";
    default:                         return "!!! UnnamedState !!!";
  }
}

void rf_ContinueRaidAccess(RF_RaidAccessDesc_t *desc)
{
  int suspended = RF_FALSE;
  int current_state_index = desc->state;
  RF_AccessState_t current_state = desc->states[current_state_index];

#ifdef SIMULATE
  rf_SetCurrentOwner(desc->owner);
#endif /* SIMULATE */
  
  do {

    current_state_index = desc->state;
    current_state = desc->states [current_state_index];

    switch (current_state) {

    case rf_QuiesceState: 		 suspended = rf_State_Quiesce(desc); 
				 break;
    case rf_IncrAccessesCountState: suspended = rf_State_IncrAccessCount(desc); 
				 break;
    case rf_MapState:		 suspended = rf_State_Map(desc); 
				 break;
    case rf_LockState:		 suspended = rf_State_Lock(desc);
				 break;
    case rf_CreateDAGState:	 suspended = rf_State_CreateDAG(desc); 
				 break;
    case rf_ExecuteDAGState:	 suspended = rf_State_ExecuteDAG(desc); 
				 break;
    case rf_ProcessDAGState:	 suspended = rf_State_ProcessDAG(desc);
				 break;
    case rf_CleanupState: 	 suspended = rf_State_Cleanup(desc);
				 break;
    case rf_DecrAccessesCountState: suspended = rf_State_DecrAccessCount(desc);
				 break;
    case rf_LastState:		 suspended = rf_State_LastState(desc);
				 break;
    }

    /* after this point, we cannot dereference desc since desc may
       have been freed. desc is only freed in LastState, so if we
       renter this function or loop back up, desc should be valid. */

    if (rf_printStatesDebug) {
      int tid;
      rf_get_threadid (tid);

      printf ("[%d] State: %-24s StateIndex: %3i desc: 0x%ld %s\n",
	      tid, StateName(current_state), current_state_index, (long)desc, 
	      suspended ? "callback scheduled" : "looping");
    }
  } while (!suspended && current_state != rf_LastState);

  return;
}


void rf_ContinueDagAccess (RF_DagList_t *dagList)
{
  RF_AccTraceEntry_t *tracerec = &(dagList->desc->tracerec);
  RF_RaidAccessDesc_t *desc;
  RF_DagHeader_t *dag_h;
  RF_Etimer_t timer;
  int i;

  desc = dagList->desc;

  timer = tracerec->timer;
  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  tracerec->specific.user.exec_us = RF_ETIMER_VAL_US(timer);
  RF_ETIMER_START(tracerec->timer);

  /* skip to dag which just finished */
  dag_h = dagList->dags;
  for (i = 0; i < dagList->numDagsDone; i++) {
    dag_h = dag_h->next;
  }

  /* check to see if retry is required */
  if (dag_h->status == rf_rollBackward) {
    /* when a dag fails, mark desc status as bad and allow all other dags
     * in the desc to execute to completion.  then, free all dags and start over */
    desc->status = 1;  /* bad status */
#if RF_DEMO > 0
    if (!rf_demoMode)
#endif /* RF_DEMO > 0 */
    {
      printf("[%d] DAG failure: %c addr 0x%lx (%ld) nblk 0x%x (%d) buf 0x%lx\n",
	     desc->tid, desc->type, (long)desc->raidAddress, 
	     (long)desc->raidAddress,(int)desc->numBlocks,
	     (int)desc->numBlocks, (unsigned long) (desc->bufPtr));
    }
  }

  dagList->numDagsDone++;
  rf_ContinueRaidAccess(desc);
}


int rf_State_LastState(RF_RaidAccessDesc_t *desc)
{
  void (*callbackFunc)(RF_CBParam_t) = desc->callbackFunc;
  RF_CBParam_t callbackArg;

  callbackArg.p = desc->callbackArg;

#ifdef SIMULATE
  int tid;
  rf_get_threadid(tid);

  if (rf_accessDebug)
    printf("async_flag set to  %d\n",global_async_flag);
  global_async_flag=desc->async_flag;
  if (rf_accessDebug)
    printf("Will now do clean up for %d\n",rf_GetCurrentOwner());
  rf_FreeRaidAccDesc(desc);
  
  if (callbackFunc)
    callbackFunc(callbackArg);
#else /* SIMULATE */

#ifndef KERNEL
      
  if (!(desc->flags & RF_DAG_NONBLOCKING_IO)) {
    /* bummer that we have to take another lock here */
    RF_LOCK_MUTEX(desc->mutex);
    RF_ASSERT(desc->flags&RF_DAG_ACCESS_COMPLETE);
    RF_SIGNAL_COND(desc->cond);  /* DoAccess frees the desc in the blocking-I/O case */
    RF_UNLOCK_MUTEX(desc->mutex);
  }
  else 
    rf_FreeRaidAccDesc(desc);
      
  if (callbackFunc)
    callbackFunc(callbackArg);
d208 1
a208 2
#else  /* KERNEL */
  if (!(desc->flags & RF_DAG_TEST_ACCESS)) {/* don't biodone if this */
d210 1
a210 1
    RF_DKU_END_IO(((RF_Raid_t *)desc->raidPtr)->raidid,(struct buf *)desc->bp);
d212 2
a213 182
    RF_DKU_END_IO(((RF_Raid_t *)desc->raidPtr)->raidid);
#endif /* DKUSAGE > 0 */
    /*     printf("Calling biodone on 0x%x\n",desc->bp); */
    biodone(desc->bp); 			/* access came through ioctl */
  }

  if (callbackFunc) callbackFunc(callbackArg);
  rf_FreeRaidAccDesc(desc);

#endif /* ! KERNEL */
#endif /* SIMULATE */

  return RF_FALSE;
}

int rf_State_IncrAccessCount(RF_RaidAccessDesc_t *desc)
{
  RF_Raid_t *raidPtr;

  raidPtr = desc->raidPtr;
  /* Bummer. We have to do this to be 100% safe w.r.t. the increment below */
  RF_LOCK_MUTEX(raidPtr->access_suspend_mutex);
  raidPtr->accs_in_flight++; /* used to detect quiescence */
  RF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);

  desc->state++;
  return RF_FALSE;
}

int rf_State_DecrAccessCount(RF_RaidAccessDesc_t *desc)
{
  RF_Raid_t *raidPtr;

  raidPtr = desc->raidPtr;

  RF_LOCK_MUTEX(raidPtr->access_suspend_mutex);
  raidPtr->accs_in_flight--;
  if (raidPtr->accesses_suspended && raidPtr->accs_in_flight == 0)  {
    rf_SignalQuiescenceLock(raidPtr, raidPtr->reconDesc);
  }
  rf_UpdateUserStats(raidPtr, RF_ETIMER_VAL_US(desc->timer), desc->numBlocks);
  RF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);

  desc->state++;
  return RF_FALSE;
}

int rf_State_Quiesce(RF_RaidAccessDesc_t *desc)
{
  RF_AccTraceEntry_t *tracerec     = &desc->tracerec;
  RF_Etimer_t timer;
  int suspended = RF_FALSE;
  RF_Raid_t *raidPtr;

  raidPtr = desc->raidPtr;

  RF_ETIMER_START(timer);
  RF_ETIMER_START(desc->timer);

  RF_LOCK_MUTEX(raidPtr->access_suspend_mutex);
  if (raidPtr->accesses_suspended) {
    RF_CallbackDesc_t *cb;
    cb = rf_AllocCallbackDesc();
    /* XXX the following cast is quite bogus...  rf_ContinueRaidAccess
       takes a (RF_RaidAccessDesc_t *) as an argument..  GO */
    cb->callbackFunc = (void (*)(RF_CBParam_t))rf_ContinueRaidAccess;
    cb->callbackArg.p  = (void *) desc;
    cb->next = raidPtr->quiesce_wait_list;
    raidPtr->quiesce_wait_list = cb;
    suspended = RF_TRUE;
  } 

  RF_UNLOCK_MUTEX(raidPtr->access_suspend_mutex);
  
  RF_ETIMER_STOP(timer); 
  RF_ETIMER_EVAL(timer);
  tracerec->specific.user.suspend_ovhd_us += RF_ETIMER_VAL_US(timer);
  
  if (suspended && rf_quiesceDebug) 
    printf("Stalling access due to quiescence lock\n");

  desc->state++;
  return suspended;
}

int rf_State_Map(RF_RaidAccessDesc_t *desc)
{
  RF_Raid_t *raidPtr               = desc->raidPtr;
  RF_AccTraceEntry_t *tracerec     = &desc->tracerec;
  RF_Etimer_t timer;

  RF_ETIMER_START(timer);

  if (!(desc->asmap = rf_MapAccess(raidPtr, desc->raidAddress, desc->numBlocks, 
			      desc->bufPtr, RF_DONT_REMAP)))
    RF_PANIC();
  
  RF_ETIMER_STOP(timer); 
  RF_ETIMER_EVAL(timer); 
  tracerec->specific.user.map_us = RF_ETIMER_VAL_US(timer);

  desc->state ++;
  return RF_FALSE;
}

int rf_State_Lock(RF_RaidAccessDesc_t *desc)
{
  RF_AccTraceEntry_t *tracerec     = &desc->tracerec;
  RF_Raid_t *raidPtr               = desc->raidPtr;
  RF_AccessStripeMapHeader_t *asmh = desc->asmap;
  RF_AccessStripeMap_t *asm_p;
  RF_Etimer_t timer;
  int suspended = RF_FALSE;

  RF_ETIMER_START(timer);
  if (!(raidPtr->Layout.map->flags & RF_NO_STRIPE_LOCKS)) {
    RF_StripeNum_t lastStripeID = -1;

    /* acquire each lock that we don't already hold */
    for (asm_p = asmh->stripeMap; asm_p; asm_p = asm_p->next) {
      RF_ASSERT(RF_IO_IS_R_OR_W(desc->type));
      if (!rf_suppressLocksAndLargeWrites && 
          asm_p->parityInfo && 
          !(desc->flags& RF_DAG_SUPPRESS_LOCKS) && 
          !(asm_p->flags & RF_ASM_FLAGS_LOCK_TRIED))
      {
        asm_p->flags |= RF_ASM_FLAGS_LOCK_TRIED;
        RF_ASSERT(asm_p->stripeID > lastStripeID); /* locks must be acquired
						   hierarchically */
        lastStripeID = asm_p->stripeID;
	/* XXX the cast to (void (*)(RF_CBParam_t)) below is bogus!  GO */
        RF_INIT_LOCK_REQ_DESC(asm_p->lockReqDesc, desc->type, 
            (void (*)(struct buf *))rf_ContinueRaidAccess, desc, asm_p, 
            raidPtr->Layout.dataSectorsPerStripe);
        if (rf_AcquireStripeLock(raidPtr->lockTable, asm_p->stripeID,
            &asm_p->lockReqDesc))
        {
          suspended = RF_TRUE;
          break;
        }
      }

      if (desc->type == RF_IO_TYPE_WRITE && 
          raidPtr->status[asm_p->physInfo->row] == rf_rs_reconstructing)
      {
        if (! (asm_p->flags & RF_ASM_FLAGS_FORCE_TRIED) ) {
          int val;

          asm_p->flags |= RF_ASM_FLAGS_FORCE_TRIED;
	  /* XXX the cast below is quite bogus!!! XXX  GO */
          val = rf_ForceOrBlockRecon(raidPtr, asm_p, 
		 (void (*)(RF_Raid_t *,void *))rf_ContinueRaidAccess, desc);
          if (val == 0) {
            asm_p->flags |= RF_ASM_FLAGS_RECON_BLOCKED;
          }
          else {
            suspended = RF_TRUE;
            break;
          }
        }
        else {
          if (rf_pssDebug) {
            printf("[%d] skipping force/block because already done, psid %ld\n",
                desc->tid,(long)asm_p->stripeID);
          }
        }
      }
      else {
        if (rf_pssDebug) {
          printf("[%d] skipping force/block because not write or not under recon, psid %ld\n",
              desc->tid,(long)asm_p->stripeID);
        }
      }
    }

    RF_ETIMER_STOP(timer); 
    RF_ETIMER_EVAL(timer); 
    tracerec->specific.user.lock_us += RF_ETIMER_VAL_US(timer);

    if (suspended)
      return(RF_TRUE);
  }
d215 187
a401 2
  desc->state++;
  return(RF_FALSE);
a402 1

d424 2
a425 1
int rf_State_CreateDAG (RF_RaidAccessDesc_t *desc)
d427 40
a466 42
  RF_AccTraceEntry_t *tracerec     = &desc->tracerec;
  RF_Etimer_t timer;
  RF_DagHeader_t *dag_h;
  int i, selectStatus;

  /* generate a dag for the access, and fire it off.  When the dag
     completes, we'll get re-invoked in the next state. */
  RF_ETIMER_START(timer);
  /* SelectAlgorithm returns one or more dags */
  selectStatus = rf_SelectAlgorithm(desc, desc->flags|RF_DAG_SUPPRESS_LOCKS);
  if (rf_printDAGsDebug)
    for (i = 0; i < desc->numStripes; i++)
      rf_PrintDAGList(desc->dagArray[i].dags);
  RF_ETIMER_STOP(timer); 
  RF_ETIMER_EVAL(timer); 
  /* update time to create all dags */
  tracerec->specific.user.dag_create_us = RF_ETIMER_VAL_US(timer);

  desc->status = 0; /* good status */

  if (selectStatus) {
    /* failed to create a dag */
    /* this happens when there are too many faults or incomplete dag libraries */
    printf("[Failed to create a DAG\n]");
    RF_PANIC();
  }
  else {
    /* bind dags to desc */
    for (i = 0; i < desc->numStripes; i++) {
      dag_h = desc->dagArray[i].dags;
      while (dag_h) {
#ifdef KERNEL
	dag_h->bp = (struct buf *) desc->bp;
#endif /* KERNEL */
	dag_h->tracerec = tracerec;
	dag_h = dag_h->next;
      }
    }
    desc->flags |= RF_DAG_DISPATCH_RETURNED;
    desc->state++;  /* next state should be rf_State_ExecuteDAG */
  }
  return RF_FALSE;
d477 2
a478 1
int rf_State_ExecuteDAG(RF_RaidAccessDesc_t *desc)
d480 28
a507 27
  int i;
  RF_DagHeader_t *dag_h;
  RF_DagList_t *dagArray = desc->dagArray;

  /* next state is always rf_State_ProcessDAG
   * important to do this before firing the first dag
   * (it may finish before we leave this routine) */
  desc->state++;

  /* sweep dag array, a stripe at a time, firing the first dag in each stripe */
  for (i = 0; i < desc->numStripes; i++) {
    RF_ASSERT(dagArray[i].numDags > 0);
    RF_ASSERT(dagArray[i].numDagsDone == 0);
    RF_ASSERT(dagArray[i].numDagsFired == 0);
    RF_ETIMER_START(dagArray[i].tracerec.timer);
    /* fire first dag in this stripe */
    dag_h = dagArray[i].dags;
    RF_ASSERT(dag_h);
    dagArray[i].numDagsFired++;
    /* XXX Yet another case where we pass in a conflicting function pointer
       :-(  XXX  GO */
    rf_DispatchDAG(dag_h, (void (*)(void *))rf_ContinueDagAccess, &dagArray[i]);
  }

  /* the DAG will always call the callback, even if there was no
   * blocking, so we are always suspended in this state */
  return RF_TRUE;
d516 2
a517 1
int rf_State_ProcessDAG(RF_RaidAccessDesc_t *desc)
d519 53
a571 53
  RF_AccessStripeMapHeader_t *asmh = desc->asmap;
  RF_Raid_t *raidPtr               = desc->raidPtr;
  RF_DagHeader_t *dag_h;
  int i, j, done = RF_TRUE;
  RF_DagList_t *dagArray = desc->dagArray;
  RF_Etimer_t timer;

  /* check to see if this is the last dag */
  for (i = 0; i < desc->numStripes; i++)
    if (dagArray[i].numDags != dagArray[i].numDagsDone)
      done = RF_FALSE;

  if (done) {
    if (desc->status) {
      /* a dag failed, retry */
      RF_ETIMER_START(timer);
      /* free all dags */
      for (i = 0; i < desc->numStripes; i++) {
	rf_FreeDAG(desc->dagArray[i].dags);
      }
      rf_MarkFailuresInASMList(raidPtr, asmh);
      /* back up to rf_State_CreateDAG */
      desc->state = desc->state - 2;
      return RF_FALSE;
    }
    else {
      /* move on to rf_State_Cleanup */
      desc->state++;
    }
    return RF_FALSE;
  }
  else {
    /* more dags to execute */
    /* see if any are ready to be fired.  if so, fire them */
    /* don't fire the initial dag in a list, it's fired in rf_State_ExecuteDAG */
    for (i = 0; i < desc->numStripes; i++) {
      if ((dagArray[i].numDagsDone < dagArray[i].numDags)
	  && (dagArray[i].numDagsDone == dagArray[i].numDagsFired)
	  && (dagArray[i].numDagsFired > 0)) {
	RF_ETIMER_START(dagArray[i].tracerec.timer);
	/* fire next dag in this stripe */
	/* first, skip to next dag awaiting execution */
	dag_h = dagArray[i].dags;
	for (j = 0; j < dagArray[i].numDagsDone; j++)
	  dag_h = dag_h->next;
	dagArray[i].numDagsFired++;
	/* XXX and again we pass a different function pointer.. GO */
	rf_DispatchDAG(dag_h, (void (*)(void *))rf_ContinueDagAccess, 
		       &dagArray[i]);
      }
    }
    return RF_TRUE;
  }
a572 1

d574 2
a575 1
int rf_State_Cleanup(RF_RaidAccessDesc_t *desc)
d577 78
a654 86
  RF_AccTraceEntry_t *tracerec     = &desc->tracerec;
  RF_AccessStripeMapHeader_t *asmh = desc->asmap;  
  RF_Raid_t *raidPtr               = desc->raidPtr;
  RF_AccessStripeMap_t *asm_p;
  RF_DagHeader_t *dag_h;
  RF_Etimer_t timer;
  int tid, i;

  desc->state ++;

  rf_get_threadid(tid);

  timer = tracerec->timer;
  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer); 
  tracerec->specific.user.dag_retry_us = RF_ETIMER_VAL_US(timer);
    
  /* the RAID I/O is complete.  Clean up. */
  tracerec->specific.user.dag_retry_us = 0;
  
  RF_ETIMER_START(timer);
  if (desc->flags & RF_DAG_RETURN_DAG) {
    /* copy dags into paramDAG */
    *(desc->paramDAG) = desc->dagArray[0].dags;
    dag_h = *(desc->paramDAG);
    for (i = 1; i < desc->numStripes; i++) {
      /* concatenate dags from remaining stripes */
      RF_ASSERT(dag_h);
      while (dag_h->next)
	dag_h = dag_h->next;
      dag_h->next = desc->dagArray[i].dags;
    }
  }
  else {
    /* free all dags */
    for (i = 0; i < desc->numStripes; i++) {
      rf_FreeDAG(desc->dagArray[i].dags);
    }
  }
  
  RF_ETIMER_STOP(timer); 
  RF_ETIMER_EVAL(timer); 
  tracerec->specific.user.cleanup_us = RF_ETIMER_VAL_US(timer);

  RF_ETIMER_START(timer);
  if (!(raidPtr->Layout.map->flags & RF_NO_STRIPE_LOCKS)) {
    for (asm_p = asmh->stripeMap; asm_p; asm_p = asm_p->next) {
      if (!rf_suppressLocksAndLargeWrites &&
          asm_p->parityInfo && 
          !(desc->flags&RF_DAG_SUPPRESS_LOCKS))
      {
        RF_ASSERT_VALID_LOCKREQ(&asm_p->lockReqDesc);
        rf_ReleaseStripeLock(raidPtr->lockTable, asm_p->stripeID, 
            &asm_p->lockReqDesc);
      }
      if (asm_p->flags & RF_ASM_FLAGS_RECON_BLOCKED) {
        rf_UnblockRecon(raidPtr, asm_p);
      }
    }
  }
  
#ifdef SIMULATE
  /* refresh current owner in case blocked ios where allowed to run */
  rf_SetCurrentOwner(desc->owner);
#endif /* SIMULATE */

  RF_ETIMER_STOP(timer); 
  RF_ETIMER_EVAL(timer); 
  tracerec->specific.user.lock_us += RF_ETIMER_VAL_US(timer);
  
  RF_ETIMER_START(timer);
  if (desc->flags & RF_DAG_RETURN_ASM) 
    *(desc->paramASM) = asmh;     
  else
    rf_FreeAccessStripeMap(asmh);
  RF_ETIMER_STOP(timer); 
  RF_ETIMER_EVAL(timer); 
  tracerec->specific.user.cleanup_us += RF_ETIMER_VAL_US(timer);
  
  RF_ETIMER_STOP(desc->timer); 
  RF_ETIMER_EVAL(desc->timer);

  timer = desc->tracerec.tot_timer;
  RF_ETIMER_STOP(timer);
  RF_ETIMER_EVAL(timer);
  desc->tracerec.total_us = RF_ETIMER_VAL_US(timer);
d656 1
a656 1
  rf_LogTraceRec(raidPtr, tracerec);
d658 1
a658 1
  desc->flags |= RF_DAG_ACCESS_COMPLETE;
d660 1
a660 1
  return RF_FALSE;
@

