head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.16
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.14
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.12
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2012.04.06.15.53.58;	author jsing;	state dead;
branches;
next	1.5;

1.5
date	2011.06.21.16.46.00;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.16.07.01.03;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.07.14.50.20;	author peter;	state Exp;
branches
	1.3.2.1
	1.3.12.1;
next	1.2;

1.2
date	99.02.16.00.02.33;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.11.14.29.11;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2003.03.28.00.38.27;	author niklas;	state Exp;
branches;
next	;

1.3.12.1
date	2003.05.19.22.21.51;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Put raidframe in the attic.
@
text
@/*	$OpenBSD: rf_dagutils.c,v 1.5 2011/06/21 16:46:00 tedu Exp $	*/
/*	$NetBSD: rf_dagutils.c,v 1.6 1999/12/09 02:26:09 oster Exp $	*/

/*
 * Copyright (c) 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Authors: Mark Holland, William V. Courtright II, Jim Zelenka
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*****************************************************************************
 *
 * rf_dagutils.c -- Utility routines for manipulating dags.
 *
 *****************************************************************************/

#include "rf_archs.h"
#include "rf_types.h"
#include "rf_threadstuff.h"
#include "rf_raid.h"
#include "rf_dag.h"
#include "rf_dagutils.h"
#include "rf_dagfuncs.h"
#include "rf_general.h"
#include "rf_freelist.h"
#include "rf_map.h"
#include "rf_shutdown.h"

#define	SNUM_DIFF(_a_,_b_)	(((_a_)>(_b_))?((_a_)-(_b_)):((_b_)-(_a_)))

RF_RedFuncs_t rf_xorFuncs = {
	rf_RegularXorFunc, "Reg Xr", rf_SimpleXorFunc, "Simple Xr"
};

RF_RedFuncs_t rf_xorRecoveryFuncs = {
	rf_RecoveryXorFunc, "Recovery Xr", rf_RecoveryXorFunc, "Recovery Xr"
};

void rf_RecurPrintDAG(RF_DagNode_t *, int, int);
void rf_PrintDAG(RF_DagHeader_t *);
int  rf_ValidateBranch(RF_DagNode_t *, int *, int *, RF_DagNode_t **, int);
void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);
void rf_ValidateVisitedBits(RF_DagHeader_t *);

/*****************************************************************************
 *
 * InitNode - Initialize a dag node.
 *
 * The size of the propList array is always the same as that of the
 * successors array.
 *
 *****************************************************************************/
void
rf_InitNode(
	RF_DagNode_t	 *node,
	RF_NodeStatus_t	  initstatus,
	int		  commit,
	int		(*doFunc) (RF_DagNode_t *),
	int		(*undoFunc) (RF_DagNode_t *node),
	int		(*wakeFunc) (RF_DagNode_t *node, int),
	int		  nSucc,
	int		  nAnte,
	int		  nParam,
	int		  nResult,
	RF_DagHeader_t	 *hdr,
	char		 *name,
	RF_AllocListElem_t *alist
)
{
	void **ptrs;
	int nptrs;

	if (nAnte > RF_MAX_ANTECEDENTS)
		RF_PANIC();
	node->status = initstatus;
	node->commitNode = commit;
	node->doFunc = doFunc;
	node->undoFunc = undoFunc;
	node->wakeFunc = wakeFunc;
	node->numParams = nParam;
	node->numResults = nResult;
	node->numAntecedents = nAnte;
	node->numAntDone = 0;
	node->next = NULL;
	node->numSuccedents = nSucc;
	node->name = name;
	node->dagHdr = hdr;
	node->visited = 0;

	/* Allocate all the pointers with one call to malloc. */
	nptrs = nSucc + nAnte + nResult + nSucc;

	if (nptrs <= RF_DAG_PTRCACHESIZE) {
		/*
	         * The dag_ptrs field of the node is basically some scribble
	         * space to be used here. We could get rid of it, and always
	         * allocate the range of pointers, but that's expensive. So,
	         * we pick a "common case" size for the pointer cache.
		 * Hopefully, we'll find that:
	         * (1) Generally, nptrs doesn't exceed RF_DAG_PTRCACHESIZE by
	         *     only a little bit (least efficient case).
	         * (2) Generally, ntprs isn't a lot less than
		 *     RF_DAG_PTRCACHESIZE (wasted memory).
	         */
		ptrs = (void **) node->dag_ptrs;
	} else {
		RF_CallocAndAdd(ptrs, nptrs, sizeof(void *), (void **), alist);
	}
	node->succedents = (nSucc) ? (RF_DagNode_t **) ptrs : NULL;
	node->antecedents = (nAnte) ? (RF_DagNode_t **) (ptrs + nSucc) : NULL;
	node->results = (nResult) ? (void **) (ptrs + nSucc + nAnte) : NULL;
	node->propList = (nSucc) ? (RF_PropHeader_t **)
	    (ptrs + nSucc + nAnte + nResult) : NULL;

	if (nParam) {
		if (nParam <= RF_DAG_PARAMCACHESIZE) {
			node->params = (RF_DagParam_t *) node->dag_params;
		} else {
			RF_CallocAndAdd(node->params, nParam,
			    sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);
		}
	} else {
		node->params = NULL;
	}
}



/*****************************************************************************
 *
 * Allocation and deallocation routines.
 *
 *****************************************************************************/

void
rf_FreeDAG(RF_DagHeader_t *dag_h)
{
	RF_AccessStripeMapHeader_t *asmap, *t_asmap;
	RF_DagHeader_t *nextDag;
	int i;

	while (dag_h) {
		nextDag = dag_h->next;
		for (i = 0; dag_h->memChunk[i] && i < RF_MAXCHUNKS; i++) {
			/* Release mem chunks. */
			rf_ReleaseMemChunk(dag_h->memChunk[i]);
			dag_h->memChunk[i] = NULL;
		}

		RF_ASSERT(i == dag_h->chunkIndex);
		if (dag_h->xtraChunkCnt > 0) {
			/* Free xtraMemChunks. */
			for (i = 0; dag_h->xtraMemChunk[i] &&
			     i < dag_h->xtraChunkIndex; i++) {
				rf_ReleaseMemChunk(dag_h->xtraMemChunk[i]);
				dag_h->xtraMemChunk[i] = NULL;
			}
			RF_ASSERT(i == dag_h->xtraChunkIndex);
			/* Free ptrs to xtraMemChunks. */
			RF_Free(dag_h->xtraMemChunk, dag_h->xtraChunkCnt *
			    sizeof(RF_ChunkDesc_t *));
		}
		rf_FreeAllocList(dag_h->allocList);
		for (asmap = dag_h->asmList; asmap;) {
			t_asmap = asmap;
			asmap = asmap->next;
			rf_FreeAccessStripeMap(t_asmap);
		}
		rf_FreeDAGHeader(dag_h);
		dag_h = nextDag;
	}
}

RF_PropHeader_t *
rf_MakePropListEntry(RF_DagHeader_t *dag_h, int resultNum, int paramNum,
    RF_PropHeader_t *next, RF_AllocListElem_t *allocList)
{
	RF_PropHeader_t *p;

	RF_CallocAndAdd(p, 1, sizeof(RF_PropHeader_t), (RF_PropHeader_t *),
	    allocList);
	p->resultNum = resultNum;
	p->paramNum = paramNum;
	p->next = next;
	return (p);
}

static RF_FreeList_t *rf_dagh_freelist;

#define	RF_MAX_FREE_DAGH	128
#define	RF_DAGH_INC		 16
#define	RF_DAGH_INITIAL		 32

void rf_ShutdownDAGs(void *);
void
rf_ShutdownDAGs(void *ignored)
{
	RF_FREELIST_DESTROY(rf_dagh_freelist, next, (RF_DagHeader_t *));
}

int
rf_ConfigureDAGs(RF_ShutdownList_t **listp)
{
	int rc;

	RF_FREELIST_CREATE(rf_dagh_freelist, RF_MAX_FREE_DAGH, RF_DAGH_INC,
	    sizeof(RF_DagHeader_t));
	if (rf_dagh_freelist == NULL)
		return (ENOMEM);
	rc = rf_ShutdownCreate(listp, rf_ShutdownDAGs, NULL);
	if (rc) {
		RF_ERRORMSG3("Unable to add to shutdown list file %s line"
		    " %d rc=%d\n", __FILE__, __LINE__, rc);
		rf_ShutdownDAGs(NULL);
		return (rc);
	}
	RF_FREELIST_PRIME(rf_dagh_freelist, RF_DAGH_INITIAL, next,
	    (RF_DagHeader_t *));
	return (0);
}

RF_DagHeader_t *
rf_AllocDAGHeader(void)
{
	RF_DagHeader_t *dh;

	RF_FREELIST_GET(rf_dagh_freelist, dh, next, (RF_DagHeader_t *));
	if (dh) {
		bzero(dh, sizeof(RF_DagHeader_t));
	}
	return (dh);
}

void
rf_FreeDAGHeader(RF_DagHeader_t *dh)
{
	RF_FREELIST_FREE(rf_dagh_freelist, dh, next);
}

/* Allocate a buffer big enough to hold the data described by pda. */
void *
rf_AllocBuffer(RF_Raid_t *raidPtr, RF_DagHeader_t *dag_h,
    RF_PhysDiskAddr_t *pda, RF_AllocListElem_t *allocList)
{
	char *p;

	RF_MallocAndAdd(p, pda->numSector << raidPtr->logBytesPerSector,
	    (char *), allocList);
	return ((void *) p);
}


/*****************************************************************************
 *
 * Debug routines.
 *
 *****************************************************************************/

char *
rf_NodeStatusString(RF_DagNode_t *node)
{
	switch (node->status) {
	case rf_wait:
		return ("wait");
	case rf_fired:
		return ("fired");
	case rf_good:
		return ("good");
	case rf_bad:
		return ("bad");
	default:
		return ("?");
	}
}

void
rf_PrintNodeInfoString(RF_DagNode_t *node)
{
	RF_PhysDiskAddr_t *pda;
	int (*df) (RF_DagNode_t *) = node->doFunc;
	int i, lk, unlk;
	void *bufPtr;

	if ((df == rf_DiskReadFunc) || (df == rf_DiskWriteFunc) ||
	    (df == rf_DiskReadMirrorIdleFunc) ||
	    (df == rf_DiskReadMirrorPartitionFunc)) {
		pda = (RF_PhysDiskAddr_t *) node->params[0].p;
		bufPtr = (void *) node->params[1].p;
		lk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);
		unlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);
		RF_ASSERT(!(lk && unlk));
		printf("r %d c %d offs %ld nsect %d buf 0x%lx %s\n", pda->row,
		    pda->col, (long) pda->startSector, (int) pda->numSector,
		    (long) bufPtr, (lk) ? "LOCK" : ((unlk) ? "UNLK" : " "));
		return;
	}
	if (df == rf_DiskUnlockFunc) {
		pda = (RF_PhysDiskAddr_t *) node->params[0].p;
		lk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);
		unlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);
		RF_ASSERT(!(lk && unlk));
		printf("r %d c %d %s\n", pda->row, pda->col,
		    (lk) ? "LOCK" : ((unlk) ? "UNLK" : "nop"));
		return;
	}
	if ((df == rf_SimpleXorFunc) || (df == rf_RegularXorFunc)
	    || (df == rf_RecoveryXorFunc)) {
		printf("result buf 0x%lx\n", (long) node->results[0]);
		for (i = 0; i < node->numParams - 1; i += 2) {
			pda = (RF_PhysDiskAddr_t *) node->params[i].p;
			bufPtr = (RF_PhysDiskAddr_t *) node->params[i + 1].p;
			printf("    buf 0x%lx r%d c%d offs %ld nsect %d\n",
			    (long) bufPtr, pda->row, pda->col,
			    (long) pda->startSector, (int) pda->numSector);
		}
		return;
	}
#if	RF_INCLUDE_PARITYLOGGING > 0
	if (df == rf_ParityLogOverwriteFunc || df == rf_ParityLogUpdateFunc) {
		for (i = 0; i < node->numParams - 1; i += 2) {
			pda = (RF_PhysDiskAddr_t *) node->params[i].p;
			bufPtr = (RF_PhysDiskAddr_t *) node->params[i + 1].p;
			printf(" r%d c%d offs %ld nsect %d buf 0x%lx\n",
			    pda->row, pda->col, (long) pda->startSector,
			    (int) pda->numSector, (long) bufPtr);
		}
		return;
	}
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */

	if ((df == rf_TerminateFunc) || (df == rf_NullNodeFunc)) {
		printf("\n");
		return;
	}
	printf("?\n");
}

void
rf_RecurPrintDAG(RF_DagNode_t *node, int depth, int unvisited)
{
	char *anttype;
	int i;

	node->visited = (unvisited) ? 0 : 1;
	printf("(%d) %d C%d %s: %s,s%d %d/%d,a%d/%d,p%d,r%d S{", depth,
	    node->nodeNum, node->commitNode, node->name,
	    rf_NodeStatusString(node), node->numSuccedents,
	    node->numSuccFired, node->numSuccDone,
	    node->numAntecedents, node->numAntDone,
	    node->numParams, node->numResults);
	for (i = 0; i < node->numSuccedents; i++) {
		printf("%d%s", node->succedents[i]->nodeNum,
		    ((i == node->numSuccedents - 1) ? "\0" : " "));
	}
	printf("} A{");
	for (i = 0; i < node->numAntecedents; i++) {
		switch (node->antType[i]) {
		case rf_trueData:
			anttype = "T";
			break;
		case rf_antiData:
			anttype = "A";
			break;
		case rf_outputData:
			anttype = "O";
			break;
		case rf_control:
			anttype = "C";
			break;
		default:
			anttype = "?";
			break;
		}
		printf("%d(%s)%s", node->antecedents[i]->nodeNum, anttype,
		    (i == node->numAntecedents - 1) ? "\0" : " ");
	}
	printf("}; ");
	rf_PrintNodeInfoString(node);
	for (i = 0; i < node->numSuccedents; i++) {
		if (node->succedents[i]->visited == unvisited)
			rf_RecurPrintDAG(node->succedents[i], depth + 1,
			    unvisited);
	}
}

void
rf_PrintDAG(RF_DagHeader_t *dag_h)
{
	int unvisited, i;
	char *status;

	/* Set dag status. */
	switch (dag_h->status) {
	case rf_enable:
		status = "enable";
		break;
	case rf_rollForward:
		status = "rollForward";
		break;
	case rf_rollBackward:
		status = "rollBackward";
		break;
	default:
		status = "illegal !";
		break;
	}
	/* Find out if visited bits are currently set or cleared. */
	unvisited = dag_h->succedents[0]->visited;

	printf("DAG type:  %s\n", dag_h->creator);
	printf("format is (depth) num commit type: status,nSucc nSuccFired/n"
	    "SuccDone,nAnte/nAnteDone,nParam,nResult S{x} A{x(type)};  info\n");
	printf("(0) %d Hdr: %s, s%d, (commit %d/%d) S{", dag_h->nodeNum,
	    status, dag_h->numSuccedents, dag_h->numCommitNodes,
	    dag_h->numCommits);
	for (i = 0; i < dag_h->numSuccedents; i++) {
		printf("%d%s", dag_h->succedents[i]->nodeNum,
		    ((i == dag_h->numSuccedents - 1) ? "\0" : " "));
	}
	printf("};\n");
	for (i = 0; i < dag_h->numSuccedents; i++) {
		if (dag_h->succedents[i]->visited == unvisited)
			rf_RecurPrintDAG(dag_h->succedents[i], 1, unvisited);
	}
}

/* Assign node numbers. */
int
rf_AssignNodeNums(RF_DagHeader_t *dag_h)
{
	int unvisited, i, nnum;
	RF_DagNode_t *node;

	nnum = 0;
	unvisited = dag_h->succedents[0]->visited;

	dag_h->nodeNum = nnum++;
	for (i = 0; i < dag_h->numSuccedents; i++) {
		node = dag_h->succedents[i];
		if (node->visited == unvisited) {
			nnum = rf_RecurAssignNodeNums(dag_h->succedents[i],
			    nnum, unvisited);
		}
	}
	return (nnum);
}

int
rf_RecurAssignNodeNums(RF_DagNode_t *node, int num, int unvisited)
{
	int i;

	node->visited = (unvisited) ? 0 : 1;

	node->nodeNum = num++;
	for (i = 0; i < node->numSuccedents; i++) {
		if (node->succedents[i]->visited == unvisited) {
			num = rf_RecurAssignNodeNums(node->succedents[i],
			    num, unvisited);
		}
	}
	return (num);
}

/* Set the header pointers in each node to "newptr". */
void
rf_ResetDAGHeaderPointers(RF_DagHeader_t *dag_h, RF_DagHeader_t *newptr)
{
	int i;

	for (i = 0; i < dag_h->numSuccedents; i++)
		if (dag_h->succedents[i]->dagHdr != newptr)
			rf_RecurResetDAGHeaderPointers(dag_h->succedents[i],
			    newptr);
}

void
rf_RecurResetDAGHeaderPointers(RF_DagNode_t *node, RF_DagHeader_t *newptr)
{
	int i;

	node->dagHdr = newptr;
	for (i = 0; i < node->numSuccedents; i++)
		if (node->succedents[i]->dagHdr != newptr)
			rf_RecurResetDAGHeaderPointers(node->succedents[i],
			    newptr);
}

void
rf_PrintDAGList(RF_DagHeader_t *dag_h)
{
	int i = 0;

	for (; dag_h; dag_h = dag_h->next) {
		rf_AssignNodeNums(dag_h);
		printf("\n\nDAG %d IN LIST:\n", i++);
		rf_PrintDAG(dag_h);
	}
}

int
rf_ValidateBranch(RF_DagNode_t *node, int *scount, int *acount,
    RF_DagNode_t **nodes, int unvisited)
{
	int i, retcode = 0;

	/* Construct an array of node pointers indexed by node num. */
	node->visited = (unvisited) ? 0 : 1;
	nodes[node->nodeNum] = node;

	if (node->next != NULL) {
		printf("INVALID DAG: next pointer in node is not NULL.\n");
		retcode = 1;
	}
	if (node->status != rf_wait) {
		printf("INVALID DAG: Node status is not wait.\n");
		retcode = 1;
	}
	if (node->numAntDone != 0) {
		printf("INVALID DAG: numAntDone is not zero.\n");
		retcode = 1;
	}
	if (node->doFunc == rf_TerminateFunc) {
		if (node->numSuccedents != 0) {
			printf("INVALID DAG: Terminator node has"
			    " succedents.\n");
			retcode = 1;
		}
	} else {
		if (node->numSuccedents == 0) {
			printf("INVALID DAG: Non-terminator node has no"
			    " succedents\n");
			retcode = 1;
		}
	}
	for (i = 0; i < node->numSuccedents; i++) {
		if (!node->succedents[i]) {
			printf("INVALID DAG: succedent %d of node %s"
			    " is NULL.\n", i, node->name);
			retcode = 1;
		}
		scount[node->succedents[i]->nodeNum]++;
	}
	for (i = 0; i < node->numAntecedents; i++) {
		if (!node->antecedents[i]) {
			printf("INVALID DAG: antecedent %d of node %s is"
			    " NULL.\n", i, node->name);
			retcode = 1;
		}
		acount[node->antecedents[i]->nodeNum]++;
	}
	for (i = 0; i < node->numSuccedents; i++) {
		if (node->succedents[i]->visited == unvisited) {
			if (rf_ValidateBranch(node->succedents[i], scount,
				acount, nodes, unvisited)) {
				retcode = 1;
			}
		}
	}
	return (retcode);
}

void
rf_ValidateBranchVisitedBits(RF_DagNode_t *node, int unvisited, int rl)
{
	int i;

	RF_ASSERT(node->visited == unvisited);
	for (i = 0; i < node->numSuccedents; i++) {
		if (node->succedents[i] == NULL) {
			printf("node=%lx node->succedents[%d] is NULL.\n",
			    (long) node, i);
			RF_ASSERT(0);
		}
		rf_ValidateBranchVisitedBits(node->succedents[i],
		    unvisited, rl + 1);
	}
}

/*
 * NOTE:  Never call this on a big dag, because it is exponential
 * in execution time.
 */
void
rf_ValidateVisitedBits(RF_DagHeader_t *dag)
{
	int i, unvisited;

	unvisited = dag->succedents[0]->visited;

	for (i = 0; i < dag->numSuccedents; i++) {
		if (dag->succedents[i] == NULL) {
			printf("dag=%lx dag->succedents[%d] is NULL.\n",
			    (long) dag, i);
			RF_ASSERT(0);
		}
		rf_ValidateBranchVisitedBits(dag->succedents[i], unvisited, 0);
	}
}

/*
 * Validate a DAG. _at entry_ verify that:
 *   -- numNodesCompleted is zero
 *   -- node queue is null
 *   -- dag status is rf_enable
 *   -- next pointer is null on every node
 *   -- all nodes have status wait
 *   -- numAntDone is zero in all nodes
 *   -- terminator node has zero successors
 *   -- no other node besides terminator has zero successors
 *   -- no successor or antecedent pointer in a node is NULL
 *   -- number of times that each node appears as a successor of another node
 *      is equal to the antecedent count on that node
 *   -- number of times that each node appears as an antecedent of another node
 *      is equal to the succedent count on that node
 *   -- what else ?
 */
int
rf_ValidateDAG(RF_DagHeader_t *dag_h)
{
	int i, nodecount;
	int *scount, *acount;	/* Per-node successor and antecedent counts. */
	RF_DagNode_t **nodes;	/* Array of ptrs to nodes in dag. */
	int retcode = 0;
	int unvisited;
	int commitNodeCount = 0;

	if (rf_validateVisitedDebug)
		rf_ValidateVisitedBits(dag_h);

	if (dag_h->numNodesCompleted != 0) {
		printf("INVALID DAG: num nodes completed is %d, should be 0.\n",
		    dag_h->numNodesCompleted);
		retcode = 1;
		goto validate_dag_bad;
	}
	if (dag_h->status != rf_enable) {
		printf("INVALID DAG: not enabled.\n");
		retcode = 1;
		goto validate_dag_bad;
	}
	if (dag_h->numCommits != 0) {
		printf("INVALID DAG: numCommits != 0 (%d)\n",
		    dag_h->numCommits);
		retcode = 1;
		goto validate_dag_bad;
	}
	if (dag_h->numSuccedents != 1) {
		/* Currently, all dags must have only one succedent. */
		printf("INVALID DAG: numSuccedents != 1 (%d).\n",
		    dag_h->numSuccedents);
		retcode = 1;
		goto validate_dag_bad;
	}
	nodecount = rf_AssignNodeNums(dag_h);

	unvisited = dag_h->succedents[0]->visited;

	RF_Calloc(scount, nodecount, sizeof(int), (int *));
	RF_Calloc(acount, nodecount, sizeof(int), (int *));
	RF_Calloc(nodes, nodecount, sizeof(RF_DagNode_t *), (RF_DagNode_t **));
	for (i = 0; i < dag_h->numSuccedents; i++) {
		if ((dag_h->succedents[i]->visited == unvisited)
		    && rf_ValidateBranch(dag_h->succedents[i], scount,
			acount, nodes, unvisited)) {
			retcode = 1;
		}
	}
	/* Start at 1 to skip the header node. */
	for (i = 1; i < nodecount; i++) {
		if (nodes[i]->commitNode)
			commitNodeCount++;
		if (nodes[i]->doFunc == NULL) {
			printf("INVALID DAG: node %s has an undefined"
			    " doFunc.\n", nodes[i]->name);
			retcode = 1;
			goto validate_dag_out;
		}
		if (nodes[i]->undoFunc == NULL) {
			printf("INVALID DAG: node %s has an undefined"
			    " doFunc.\n", nodes[i]->name);
			retcode = 1;
			goto validate_dag_out;
		}
		if (nodes[i]->numAntecedents != scount[nodes[i]->nodeNum]) {
			printf("INVALID DAG: node %s has %d antecedents but"
			    " appears as a succedent %d times.\n",
			    nodes[i]->name, nodes[i]->numAntecedents,
			    scount[nodes[i]->nodeNum]);
			retcode = 1;
			goto validate_dag_out;
		}
		if (nodes[i]->numSuccedents != acount[nodes[i]->nodeNum]) {
			printf("INVALID DAG: node %s has %d succedents but"
			    " appears as an antecedent %d times.\n",
			    nodes[i]->name, nodes[i]->numSuccedents,
			    acount[nodes[i]->nodeNum]);
			retcode = 1;
			goto validate_dag_out;
		}
	}

	if (dag_h->numCommitNodes != commitNodeCount) {
		printf("INVALID DAG: incorrect commit node count. "
		    "hdr->numCommitNodes (%d) found (%d) commit nodes"
		    " in graph.\n",
		    dag_h->numCommitNodes, commitNodeCount);
		retcode = 1;
		goto validate_dag_out;
	}

validate_dag_out:
	RF_Free(scount, nodecount * sizeof(int));
	RF_Free(acount, nodecount * sizeof(int));
	RF_Free(nodes, nodecount * sizeof(RF_DagNode_t *));
	if (retcode)
		rf_PrintDAGList(dag_h);

	if (rf_validateVisitedDebug)
		rf_ValidateVisitedBits(dag_h);

	return (retcode);

validate_dag_bad:
	rf_PrintDAGList(dag_h);
	return (retcode);
}


/*****************************************************************************
 *
 * Misc construction routines.
 *
 *****************************************************************************/

void
rf_redirect_asm(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap)
{
	int ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) ? 1 : 0;
	int row = asmap->physInfo->row;
	int fcol = raidPtr->reconControl[row]->fcol;
	int srow = raidPtr->reconControl[row]->spareRow;
	int scol = raidPtr->reconControl[row]->spareCol;
	RF_PhysDiskAddr_t *pda;

	RF_ASSERT(raidPtr->status[row] == rf_rs_reconstructing);
	for (pda = asmap->physInfo; pda; pda = pda->next) {
		if (pda->col == fcol) {
			if (rf_dagDebug) {
				if (!rf_CheckRUReconstructed(
				    raidPtr->reconControl[row]->reconMap,
				    pda->startSector)) {
					RF_PANIC();
				}
			}
			/*printf("Remapped data for large write\n");*/
			if (ds) {
				raidPtr->Layout.map->MapSector(raidPtr,
				    pda->raidAddress, &pda->row, &pda->col,
				    &pda->startSector, RF_REMAP);
			} else {
				pda->row = srow;
				pda->col = scol;
			}
		}
	}
	for (pda = asmap->parityInfo; pda; pda = pda->next) {
		if (pda->col == fcol) {
			if (rf_dagDebug) {
				if (!rf_CheckRUReconstructed(
				    raidPtr->reconControl[row]->reconMap,
				    pda->startSector)) {
					RF_PANIC();
				}
			}
		}
		if (ds) {
			(raidPtr->Layout.map->MapParity) (raidPtr,
			    pda->raidAddress, &pda->row, &pda->col,
			    &pda->startSector, RF_REMAP);
		} else {
			pda->row = srow;
			pda->col = scol;
		}
	}
}


/*
 * This routine allocates read buffers and generates stripe maps for the
 * regions of the array from the start of the stripe to the start of the
 * access, and from the end of the access to the end of the stripe. It also
 * computes and returns the number of DAG nodes needed to read all this data.
 * Note that this routine does the wrong thing if the access is fully
 * contained within one stripe unit, so we RF_ASSERT against this case at the
 * start.
 */
void
rf_MapUnaccessedPortionOfStripe(
	RF_Raid_t		 *raidPtr,
	RF_RaidLayout_t		 *layoutPtr,	/* in: layout information */
	RF_AccessStripeMap_t	 *asmap,	/* in: access stripe map */
	RF_DagHeader_t		 *dag_h,	/* in: header of the dag */
						/*     to create */
	RF_AccessStripeMapHeader_t **new_asm_h,	/* in: ptr to array of 2 */
						/*     headers, to be */
						/*     filled in */
	int			 *nRodNodes,	/* out: num nodes to be */
						/*      generated to read */
						/*      unaccessed data */
	char			**sosBuffer,	/* out: pointers to newly */
						/*      allocated buffer */
	char			**eosBuffer,
	RF_AllocListElem_t	 *allocList
)
{
	RF_RaidAddr_t sosRaidAddress, eosRaidAddress;
	RF_SectorNum_t sosNumSector, eosNumSector;

	RF_ASSERT(asmap->numStripeUnitsAccessed > (layoutPtr->numDataCol / 2));
	/*
	 * Generate an access map for the region of the array from start of
	 * stripe to start of access.
	 */
	new_asm_h[0] = new_asm_h[1] = NULL;
	*nRodNodes = 0;
	if (!rf_RaidAddressStripeAligned(layoutPtr, asmap->raidAddress)) {
		sosRaidAddress = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
		    asmap->raidAddress);
		sosNumSector = asmap->raidAddress - sosRaidAddress;
		RF_MallocAndAdd(*sosBuffer, rf_RaidAddressToByte(raidPtr,
		    sosNumSector), (char *), allocList);
		new_asm_h[0] = rf_MapAccess(raidPtr, sosRaidAddress,
		    sosNumSector, *sosBuffer, RF_DONT_REMAP);
		new_asm_h[0]->next = dag_h->asmList;
		dag_h->asmList = new_asm_h[0];
		*nRodNodes += new_asm_h[0]->stripeMap->numStripeUnitsAccessed;

		RF_ASSERT(new_asm_h[0]->stripeMap->next == NULL);
		/* We're totally within one stripe here. */
		if (asmap->flags & RF_ASM_REDIR_LARGE_WRITE)
			rf_redirect_asm(raidPtr, new_asm_h[0]->stripeMap);
	}
	/*
	 * Generate an access map for the region of the array from end of
	 * access to end of stripe.
	 */
	if (!rf_RaidAddressStripeAligned(layoutPtr, asmap->endRaidAddress)) {
		eosRaidAddress = asmap->endRaidAddress;
		eosNumSector = rf_RaidAddressOfNextStripeBoundary(layoutPtr,
		    eosRaidAddress) - eosRaidAddress;
		RF_MallocAndAdd(*eosBuffer, rf_RaidAddressToByte(raidPtr,
		    eosNumSector), (char *), allocList);
		new_asm_h[1] = rf_MapAccess(raidPtr, eosRaidAddress,
		    eosNumSector, *eosBuffer, RF_DONT_REMAP);
		new_asm_h[1]->next = dag_h->asmList;
		dag_h->asmList = new_asm_h[1];
		*nRodNodes += new_asm_h[1]->stripeMap->numStripeUnitsAccessed;

		RF_ASSERT(new_asm_h[1]->stripeMap->next == NULL);
		/* We're totally within one stripe here. */
		if (asmap->flags & RF_ASM_REDIR_LARGE_WRITE)
			rf_redirect_asm(raidPtr, new_asm_h[1]->stripeMap);
	}
}


/* Returns non-zero if the indicated ranges of stripe unit offsets overlap. */
int
rf_PDAOverlap(RF_RaidLayout_t *layoutPtr, RF_PhysDiskAddr_t *src,
    RF_PhysDiskAddr_t *dest)
{
	RF_SectorNum_t soffs =
	    rf_StripeUnitOffset(layoutPtr, src->startSector);
	RF_SectorNum_t doffs =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector);
	/* Use -1 to be sure we stay within SU. */
	RF_SectorNum_t send =
	    rf_StripeUnitOffset(layoutPtr, src->startSector +
	    src->numSector - 1);
	RF_SectorNum_t dend =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector +
	    dest->numSector - 1);

	return ((RF_MAX(soffs, doffs) <= RF_MIN(send, dend)) ? 1 : 0);
}


/*
 * GenerateFailedAccessASMs
 *
 * This routine figures out what portion of the stripe needs to be read
 * to effect the degraded read or write operation. It's primary function
 * is to identify everything required to recover the data, and then
 * eliminate anything that is already being accessed by the user.
 *
 * The main result is two new ASMs, one for the region from the start of the
 * stripe to the start of the access, and one for the region from the end of
 * the access to the end of the stripe. These ASMs describe everything that
 * needs to be read to effect the degraded access. Other results are:
 *    nXorBufs -- The total number of buffers that need to be XORed together
 *		  to recover the lost data,
 *    rpBufPtr -- Ptr to a newly-allocated buffer to hold the parity. If NULL
 *                at entry, not allocated.
 *    overlappingPDAs --
 *                Describes which of the non-failed PDAs, in the user access,
 *                overlap data that needs to be read to effect recovery.
 *                overlappingPDAs[i]==1 if and only if, neglecting the failed
 *                PDA, the i'th pda in the input asm overlaps data that needs
 *                to be read for recovery.
 */
 /* in: asmap - ASM for the actual access, one stripe only. */
 /* in: faildPDA - Which component of the access has failed. */
 /* in: dag_h - Header of the DAG we're going to create. */
 /* out: new_asm_h - The two new ASMs. */
 /* out: nXorBufs - The total number of xor bufs required. */
 /* out: rpBufPtr - A buffer for the parity read. */
void
rf_GenerateFailedAccessASMs(
	RF_Raid_t		 *raidPtr,
	RF_AccessStripeMap_t	 *asmap,
	RF_PhysDiskAddr_t	 *failedPDA,
	RF_DagHeader_t		 *dag_h,
	RF_AccessStripeMapHeader_t **new_asm_h,
	int			 *nXorBufs,
	char			**rpBufPtr,
	char			 *overlappingPDAs,
	RF_AllocListElem_t	 *allocList
)
{
	RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);

	/* s=start, e=end, s=stripe, a=access, f=failed, su=stripe unit */
	RF_RaidAddr_t sosAddr, sosEndAddr, eosStartAddr, eosAddr;

	RF_SectorCount_t numSect[2], numParitySect;
	RF_PhysDiskAddr_t *pda;
	char *rdBuf, *bufP;
	int foundit, i;

	bufP = NULL;
	foundit = 0;
	/*
	 * First compute the following raid addresses:
	 * - Start of stripe
	 * - (sosAddr) MIN(start of access, start of failed SU)
	 * - (sosEndAddr) MAX(end of access, end of failed SU)
	 * - (eosStartAddr) end of stripe (i.e. start of next stripe)
	 *   (eosAddr)
	 */
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
	    asmap->raidAddress);
	sosEndAddr = RF_MIN(asmap->raidAddress,
	    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
	    failedPDA->raidAddress));
	eosStartAddr = RF_MAX(asmap->endRaidAddress,
	    rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr,
	    failedPDA->raidAddress));
	eosAddr = rf_RaidAddressOfNextStripeBoundary(layoutPtr,
	    asmap->raidAddress);

	/*
	 * Now generate access stripe maps for each of the above regions of
	 * the stripe. Use a dummy (NULL) buf ptr for now.
	 */

	new_asm_h[0] = (sosAddr != sosEndAddr) ?
	    rf_MapAccess(raidPtr, sosAddr, sosEndAddr - sosAddr, NULL,
	    RF_DONT_REMAP) : NULL;
	new_asm_h[1] = (eosStartAddr != eosAddr) ?
	    rf_MapAccess(raidPtr, eosStartAddr, eosAddr - eosStartAddr, NULL,
	    RF_DONT_REMAP) : NULL;

	/*
	 * Walk through the PDAs and range-restrict each SU to the region of
	 * the SU touched on the failed PDA. Also compute total data buffer
	 * space requirements in this step. Ignore the parity for now.
	 */

	numSect[0] = numSect[1] = 0;
	if (new_asm_h[0]) {
		new_asm_h[0]->next = dag_h->asmList;
		dag_h->asmList = new_asm_h[0];
		for (pda = new_asm_h[0]->stripeMap->physInfo; pda;
		     pda = pda->next) {
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda,
			    RF_RESTRICT_NOBUFFER, 0);
			numSect[0] += pda->numSector;
		}
	}
	if (new_asm_h[1]) {
		new_asm_h[1]->next = dag_h->asmList;
		dag_h->asmList = new_asm_h[1];
		for (pda = new_asm_h[1]->stripeMap->physInfo;
		     pda; pda = pda->next) {
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda,
			    RF_RESTRICT_NOBUFFER, 0);
			numSect[1] += pda->numSector;
		}
	}
	numParitySect = failedPDA->numSector;

	/*
	 * Allocate buffer space for the data & parity we have to read to
	 * recover from the failure.
	 */

	if (numSect[0] + numSect[1] + ((rpBufPtr) ? numParitySect : 0)) {
		/* Don't allocate parity buf if not needed. */
		RF_MallocAndAdd(rdBuf, rf_RaidAddressToByte(raidPtr,
		    numSect[0] + numSect[1] + numParitySect), (char *),
		    allocList);
		bufP = rdBuf;
		if (rf_degDagDebug)
			printf("Newly allocated buffer (%d bytes) is 0x%lx\n",
			    (int) rf_RaidAddressToByte(raidPtr,
			    numSect[0] + numSect[1] + numParitySect),
			    (unsigned long) bufP);
	}
	/*
	 * Now walk through the pdas one last time and assign buffer pointers
	 * (ugh!). Again, ignore the parity. Also, count nodes to find out
	 * how many bufs need to be xored together.
	 */
	(*nXorBufs) = 1;	/* In read case, 1 is for parity. */
				/* In write case, 1 is for failed data. */
	if (new_asm_h[0]) {
		for (pda = new_asm_h[0]->stripeMap->physInfo; pda;
		     pda = pda->next) {
			pda->bufPtr = bufP;
			bufP += rf_RaidAddressToByte(raidPtr, pda->numSector);
		}
		*nXorBufs += new_asm_h[0]->stripeMap->numStripeUnitsAccessed;
	}
	if (new_asm_h[1]) {
		for (pda = new_asm_h[1]->stripeMap->physInfo; pda;
		     pda = pda->next) {
			pda->bufPtr = bufP;
			bufP += rf_RaidAddressToByte(raidPtr, pda->numSector);
		}
		(*nXorBufs) += new_asm_h[1]->stripeMap->numStripeUnitsAccessed;
	}
	if (rpBufPtr)
		/* The rest of the buffer is for parity. */
		*rpBufPtr = bufP;

	/*
	 * The last step is to figure out how many more distinct buffers need
	 * to get xor'd to produce the missing unit. there's one for each
	 * user-data read node that overlaps the portion of the failed unit
	 * being accessed.
	 */

	for (foundit = i = 0, pda = asmap->physInfo;
	     pda; i++, pda = pda->next) {
		if (pda == failedPDA) {
			i--;
			foundit = 1;
			continue;
		}
		if (rf_PDAOverlap(layoutPtr, pda, failedPDA)) {
			overlappingPDAs[i] = 1;
			(*nXorBufs)++;
		}
	}
	if (!foundit) {
		RF_ERRORMSG("GenerateFailedAccessASMs: did not find failedPDA"
		    " in asm list.\n");
		RF_ASSERT(0);
	}
	if (rf_degDagDebug) {
		if (new_asm_h[0]) {
			printf("First asm:\n");
			rf_PrintFullAccessStripeMap(new_asm_h[0], 1);
		}
		if (new_asm_h[1]) {
			printf("Second asm:\n");
			rf_PrintFullAccessStripeMap(new_asm_h[1], 1);
		}
	}
}


/*
 * Adjust the offset and number of sectors in the destination pda so that
 * it covers at most the region of the SU covered by the source PDA. This
 * is exclusively a restriction:  the number of sectors indicated by the
 * target PDA can only shrink.
 *
 * For example:  s = sectors within SU indicated by source PDA
 *               d = sectors within SU indicated by dest PDA
 *               r = results, stored in dest PDA
 *
 * |--------------- one stripe unit ---------------------|
 * |           sssssssssssssssssssssssssssssssss         |
 * |    ddddddddddddddddddddddddddddddddddddddddddddd    |
 * |           rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr         |
 *
 * Another example:
 *
 * |--------------- one stripe unit ---------------------|
 * |           sssssssssssssssssssssssssssssssss         |
 * |    ddddddddddddddddddddddd                          |
 * |           rrrrrrrrrrrrrrrr                          |
 *
 */
void
rf_RangeRestrictPDA(RF_Raid_t *raidPtr, RF_PhysDiskAddr_t *src,
    RF_PhysDiskAddr_t *dest, int dobuffer, int doraidaddr)
{
	RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
	RF_SectorNum_t soffs =
	    rf_StripeUnitOffset(layoutPtr, src->startSector);
	RF_SectorNum_t doffs =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector);
	RF_SectorNum_t send =
	    rf_StripeUnitOffset(layoutPtr, src->startSector +
	    src->numSector - 1); /* Use -1 to be sure we stay within SU. */
	RF_SectorNum_t dend =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector +
	    dest->numSector - 1);
	RF_SectorNum_t subAddr =
	    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
	    dest->startSector); /* Stripe unit boundary. */

	dest->startSector = subAddr + RF_MAX(soffs, doffs);
	dest->numSector = subAddr + RF_MIN(send, dend) + 1 - dest->startSector;

	if (dobuffer)
		dest->bufPtr += (soffs > doffs) ?
		    rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;
	if (doraidaddr) {
		dest->raidAddress =
		    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
		    dest->raidAddress) +
		    rf_StripeUnitOffset(layoutPtr, dest->startSector);
	}
}

/*
 * Want the highest of these primes to be the largest one
 * less than the max expected number of columns (won't hurt
 * to be too small or too large, but won't be optimal, either)
 * --jimz
 */
#define	NLOWPRIMES	8
static int lowprimes[NLOWPRIMES] = {2, 3, 5, 7, 11, 13, 17, 19};

/*****************************************************************************
 * Compute the workload shift factor. (chained declustering)
 *
 * Return nonzero if access should shift to secondary, otherwise,
 * access is to primary.
 *****************************************************************************/
int
rf_compute_workload_shift(RF_Raid_t *raidPtr, RF_PhysDiskAddr_t *pda)
{
	/*
         * Variables:
         *  d   = Column of disk containing primary.
         *  f   = Column of failed disk.
         *  n   = Number of disks in array.
         *  sd  = "shift distance"
	 *	  (number of columns that d is to the right of f).
         *  row = Row of array the access is in.
         *  v   = Numerator of redirection ratio.
         *  k   = Denominator of redirection ratio.
         */
	RF_RowCol_t d, f, sd, row, n;
	int k, v, ret, i;

	row = pda->row;
	n = raidPtr->numCol;

	/* Assign column of primary copy to d. */
	d = pda->col;

	/* Assign column of dead disk to f. */
	for (f = 0; ((!RF_DEAD_DISK(raidPtr->Disks[row][f].status)) &&
	     (f < n)); f++);

	RF_ASSERT(f < n);
	RF_ASSERT(f != d);

	sd = (f > d) ? (n + d - f) : (d - f);
	RF_ASSERT(sd < n);

	/*
         * v of every k accesses should be redirected.
         *
         * v/k := (n-1-sd)/(n-1)
         */
	v = (n - 1 - sd);
	k = (n - 1);

#if 1
	/*
         * XXX
         * Is this worth it ?
         *
         * Now reduce the fraction, by repeatedly factoring
         * out primes (just like they teach in elementary school !).
         */
	for (i = 0; i < NLOWPRIMES; i++) {
		if (lowprimes[i] > v)
			break;
		while (((v % lowprimes[i]) == 0) && ((k % lowprimes[i]) == 0)) {
			v /= lowprimes[i];
			k /= lowprimes[i];
		}
	}
#endif

	raidPtr->hist_diskreq[row][d]++;
	if (raidPtr->hist_diskreq[row][d] > v) {
		ret = 0;	/* Do not redirect. */
	} else {
		ret = 1;	/* Redirect. */
	}

#if 0
	printf("d=%d f=%d sd=%d v=%d k=%d ret=%d h=%d\n", d, f, sd, v, k, ret,
	    raidPtr->hist_diskreq[row][d]);
#endif

	if (raidPtr->hist_diskreq[row][d] >= k) {
		/* Reset counter. */
		raidPtr->hist_diskreq[row][d] = 0;
	}
	return (ret);
}

/*
 * Disk selection routines.
 */

/*
 * Select the disk with the shortest queue from a mirror pair.
 * Both the disk I/Os queued in RAIDframe as well as those at the physical
 * disk are counted as members of the "queue".
 */
void
rf_SelectMirrorDiskIdle(RF_DagNode_t *node)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;
	RF_RowCol_t rowData, colData, rowMirror, colMirror;
	int dataQueueLength, mirrorQueueLength, usemirror;
	RF_PhysDiskAddr_t *data_pda = (RF_PhysDiskAddr_t *) node->params[0].p;
	RF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *) node->params[4].p;
	RF_PhysDiskAddr_t *tmp_pda;
	RF_RaidDisk_t **disks = raidPtr->Disks;
	RF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;

	/* Return the [row col] of the disk with the shortest queue. */
	rowData = data_pda->row;
	colData = data_pda->col;
	rowMirror = mirror_pda->row;
	colMirror = mirror_pda->col;
	dataQueue = &(dqs[rowData][colData]);
	mirrorQueue = &(dqs[rowMirror][colMirror]);

#ifdef	RF_LOCK_QUEUES_TO_READ_LEN
	RF_LOCK_QUEUE_MUTEX(dataQueue, "SelectMirrorDiskIdle");
#endif	/* RF_LOCK_QUEUES_TO_READ_LEN */
	dataQueueLength = dataQueue->queueLength + dataQueue->numOutstanding;
#ifdef	RF_LOCK_QUEUES_TO_READ_LEN
	RF_UNLOCK_QUEUE_MUTEX(dataQueue, "SelectMirrorDiskIdle");
	RF_LOCK_QUEUE_MUTEX(mirrorQueue, "SelectMirrorDiskIdle");
#endif	/* RF_LOCK_QUEUES_TO_READ_LEN */
	mirrorQueueLength = mirrorQueue->queueLength +
	    mirrorQueue->numOutstanding;
#ifdef	RF_LOCK_QUEUES_TO_READ_LEN
	RF_UNLOCK_QUEUE_MUTEX(mirrorQueue, "SelectMirrorDiskIdle");
#endif	/* RF_LOCK_QUEUES_TO_READ_LEN */

	usemirror = 0;
	if (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {
		usemirror = 0;
	} else
		if (RF_DEAD_DISK(disks[rowData][colData].status)) {
			usemirror = 1;
		} else
			if (raidPtr->parity_good == RF_RAID_DIRTY) {
				/* Trust only the main disk. */
				usemirror = 0;
			} else
			if (dataQueueLength < mirrorQueueLength) {
				usemirror = 0;
			} else
				if (mirrorQueueLength < dataQueueLength) {
					usemirror = 1;
				} else {
					/* Queues are equal length. */
					/* Attempt cleverness. */
					if (SNUM_DIFF(dataQueue
					    ->last_deq_sector, data_pda
					    ->startSector) <=
					    SNUM_DIFF(mirrorQueue
					    ->last_deq_sector, mirror_pda
					    ->startSector)) {
						usemirror = 0;
					} else {
						usemirror = 1;
					}
				}

	if (usemirror) {
		/* Use mirror (parity) disk, swap params 0 & 4. */
		tmp_pda = data_pda;
		node->params[0].p = mirror_pda;
		node->params[4].p = tmp_pda;
	} else {
		/* Use data disk, leave param 0 unchanged. */
	}
	/*printf("dataQueueLength %d, mirrorQueueLength %d\n", dataQueueLength,
	    mirrorQueueLength);*/
}

/*
 * Do simple partitioning. This assumes that
 * the data and parity disks are laid out identically.
 */
void
rf_SelectMirrorDiskPartition(RF_DagNode_t *node)
{
	RF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;
	RF_RowCol_t rowData, colData, rowMirror, colMirror;
	RF_PhysDiskAddr_t *data_pda = (RF_PhysDiskAddr_t *) node->params[0].p;
	RF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *) node->params[4].p;
	RF_PhysDiskAddr_t *tmp_pda;
	RF_RaidDisk_t **disks = raidPtr->Disks;
	RF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;
	int usemirror;

	/* Return the [row col] of the disk with the shortest queue. */
	rowData = data_pda->row;
	colData = data_pda->col;
	rowMirror = mirror_pda->row;
	colMirror = mirror_pda->col;
	dataQueue = &(dqs[rowData][colData]);
	mirrorQueue = &(dqs[rowMirror][colMirror]);

	usemirror = 0;
	if (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {
		usemirror = 0;
	} else
		if (RF_DEAD_DISK(disks[rowData][colData].status)) {
			usemirror = 1;
		} else
			if (raidPtr->parity_good == RF_RAID_DIRTY) {
				/* Trust only the main disk. */
				usemirror = 0;
		} else
				if (data_pda->startSector <
				    (disks[rowData][colData].numBlocks / 2)) {
				usemirror = 0;
			} else {
				usemirror = 1;
			}

	if (usemirror) {
		/* Use mirror (parity) disk, swap params 0 & 4. */
		tmp_pda = data_pda;
		node->params[0].p = mirror_pda;
		node->params[4].p = tmp_pda;
	} else {
		/* Use data disk, leave param 0 unchanged. */
	}
}
@


1.5
log
@remove stupid casts, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagutils.c,v 1.4 2002/12/16 07:01:03 tdeval Exp $	*/
@


1.4
log
@Major KNF.  Incentive from Tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagutils.c,v 1.3 2000/01/07 14:50:20 peter Exp $	*/
d249 1
a249 1
		bzero((char *) dh, sizeof(RF_DagHeader_t));
@


1.3
log
@sync with work by Greg Oster on NetBSD

Please note: This update has *only* been tested on i386 with IDE
disks. Could someone with a spare box please make sure all is OK with
SCSI and maybe other arches ? sparc testing will follow locally.

* remove rf_sys.h
* many changes to make it more stable
* some performance increases
* All raid threads now get their own kernel process and the calling
  raidctl(8) program will show status progress through a meter.
* In theory FFS_SOFTUPDATES and RAIDframe will now work together - NOT
  TESTED YET

See http://www.cs.usask.ca/staff/oster/raid.html

This updates include Greg's changes to Jan 4th 2000.

TODO:
* some odd behaviour when running raictl -c on an already config'ed
  raid set - problem founf, fix being done
* progress meter is in raidctl(8) - seperate commit, but could do with
  sync'ing with OpenBSD ftp version
@
text
@d1 1
a1 1
/*	$OpenBSD: rf_dagutils.c,v 1.2 1999/02/16 00:02:33 niklas Exp $	*/
d3 1
d31 1
a31 1
/******************************************************************************
d33 1
a33 1
 * rf_dagutils.c -- utility routines for manipulating dags
d49 1
a49 1
#define SNUM_DIFF(_a_,_b_) (((_a_)>(_b_))?((_a_)-(_b_)):((_b_)-(_a_)))
d52 2
a53 2
	rf_RegularXorFunc, "Reg Xr",
rf_SimpleXorFunc, "Simple Xr"};
d56 2
a57 2
	rf_RecoveryXorFunc, "Recovery Xr",
rf_RecoveryXorFunc, "Recovery Xr"};
d59 5
a63 7
static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);
static void rf_PrintDAG(RF_DagHeader_t *);
static int 
rf_ValidateBranch(RF_DagNode_t *, int *, int *,
    RF_DagNode_t **, int);
static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);
static void rf_ValidateVisitedBits(RF_DagHeader_t *);
d65 1
a65 1
/******************************************************************************
d67 1
a67 1
 * InitNode - initialize a dag node
d69 1
a69 1
 * the size of the propList array is always the same as that of the
d73 1
a73 1
void 
d75 14
a88 13
    RF_DagNode_t * node,
    RF_NodeStatus_t initstatus,
    int commit,
    int (*doFunc) (RF_DagNode_t * node),
    int (*undoFunc) (RF_DagNode_t * node),
    int (*wakeFunc) (RF_DagNode_t * node, int status),
    int nSucc,
    int nAnte,
    int nParam,
    int nResult,
    RF_DagHeader_t * hdr,
    char *name,
    RF_AllocListElem_t * alist)
d90 2
a91 2
	void  **ptrs;
	int     nptrs;
d110 1
a110 1
	/* allocate all the pointers with one call to malloc */
d118 2
a119 2
	         * we pick a "common case" size for the pointer cache. Hopefully,
	         * we'll find that:
d121 3
a123 3
	         *     only a little bit (least efficient case)
	         * (2) Generally, ntprs isn't a lot less than RF_DAG_PTRCACHESIZE
	         *     (wasted memory)
d132 2
a133 1
	node->propList = (nSucc) ? (RF_PropHeader_t **) (ptrs + nSucc + nAnte + nResult) : NULL;
d139 2
a140 1
			RF_CallocAndAdd(node->params, nParam, sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);
d149 1
a149 1
/******************************************************************************
d151 1
a151 1
 * allocation and deallocation routines
d155 2
a156 3
void 
rf_FreeDAG(dag_h)
	RF_DagHeader_t *dag_h;
d160 1
a160 1
	int     i;
d165 1
a165 1
			/* release mem chunks */
d172 3
a174 2
			/* free xtraMemChunks */
			for (i = 0; dag_h->xtraMemChunk[i] && i < dag_h->xtraChunkIndex; i++) {
d179 3
a181 2
			/* free ptrs to xtraMemChunks */
			RF_Free(dag_h->xtraMemChunk, dag_h->xtraChunkCnt * sizeof(RF_ChunkDesc_t *));
d195 2
a196 6
rf_MakePropListEntry(
    RF_DagHeader_t * dag_h,
    int resultNum,
    int paramNum,
    RF_PropHeader_t * next,
    RF_AllocListElem_t * allocList)
d200 2
a201 2
	RF_CallocAndAdd(p, 1, sizeof(RF_PropHeader_t),
	    (RF_PropHeader_t *), allocList);
d210 7
a216 8
#define RF_MAX_FREE_DAGH 128
#define RF_DAGH_INC       16
#define RF_DAGH_INITIAL   32

static void rf_ShutdownDAGs(void *);
static void 
rf_ShutdownDAGs(ignored)
	void   *ignored;
d221 2
a222 3
int 
rf_ConfigureDAGs(listp)
	RF_ShutdownList_t **listp;
d224 1
a224 1
	int     rc;
d226 2
a227 2
	RF_FREELIST_CREATE(rf_dagh_freelist, RF_MAX_FREE_DAGH,
	    RF_DAGH_INC, sizeof(RF_DagHeader_t));
d232 2
a233 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line %d rc=%d\n",
		    __FILE__, __LINE__, rc);
d243 1
a243 1
rf_AllocDAGHeader()
d254 2
a255 2
void 
rf_FreeDAGHeader(RF_DagHeader_t * dh)
d259 5
a263 7
/* allocates a buffer big enough to hold the data described by pda */
void   *
rf_AllocBuffer(
    RF_Raid_t * raidPtr,
    RF_DagHeader_t * dag_h,
    RF_PhysDiskAddr_t * pda,
    RF_AllocListElem_t * allocList)
d265 1
a265 1
	char   *p;
d271 3
a273 1
/******************************************************************************
d275 1
a275 1
 * debug routines
d279 2
a280 2
char   *
rf_NodeStatusString(RF_DagNode_t * node)
d283 2
a284 1
		case rf_wait:return ("wait");
d296 2
a297 2
void 
rf_PrintNodeInfoString(RF_DagNode_t * node)
d300 7
a306 7
	int     (*df) (RF_DagNode_t *) = node->doFunc;
	int     i, lk, unlk;
	void   *bufPtr;

	if ((df == rf_DiskReadFunc) || (df == rf_DiskWriteFunc)
	    || (df == rf_DiskReadMirrorIdleFunc)
	    || (df == rf_DiskReadMirrorPartitionFunc)) {
d312 3
a314 3
		printf("r %d c %d offs %ld nsect %d buf 0x%lx %s\n", pda->row, pda->col,
		    (long) pda->startSector, (int) pda->numSector, (long) bufPtr,
		    (lk) ? "LOCK" : ((unlk) ? "UNLK" : " "));
d338 1
a338 1
#if RF_INCLUDE_PARITYLOGGING > 0
d349 1
a349 1
#endif				/* RF_INCLUDE_PARITYLOGGING > 0 */
d358 2
a359 5
static void 
rf_RecurPrintDAG(node, depth, unvisited)
	RF_DagNode_t *node;
	int     depth;
	int     unvisited;
d361 2
a362 2
	char   *anttype;
	int     i;
d366 5
a370 3
	    node->nodeNum, node->commitNode, node->name, rf_NodeStatusString(node),
	    node->numSuccedents, node->numSuccFired, node->numSuccDone,
	    node->numAntecedents, node->numAntDone, node->numParams, node->numResults);
d394 2
a395 1
		printf("%d(%s)%s", node->antecedents[i]->nodeNum, anttype, (i == node->numAntecedents - 1) ? "\0" : " ");
d401 2
a402 1
			rf_RecurPrintDAG(node->succedents[i], depth + 1, unvisited);
d406 2
a407 3
static void 
rf_PrintDAG(dag_h)
	RF_DagHeader_t *dag_h;
d409 2
a410 2
	int     unvisited, i;
	char   *status;
d412 1
a412 1
	/* set dag status */
d424 1
a424 1
		status = "illegal!";
d427 1
a427 1
	/* find out if visited bits are currently set or clear */
d431 2
a432 1
	printf("format is (depth) num commit type: status,nSucc nSuccFired/nSuccDone,nAnte/nAnteDone,nParam,nResult S{x} A{x(type)};  info\n");
d434 2
a435 1
	    status, dag_h->numSuccedents, dag_h->numCommitNodes, dag_h->numCommits);
d446 4
a449 3
/* assigns node numbers */
int 
rf_AssignNodeNums(RF_DagHeader_t * dag_h)
d451 1
a451 1
	int     unvisited, i, nnum;
d461 2
a462 1
			nnum = rf_RecurAssignNodeNums(dag_h->succedents[i], nnum, unvisited);
d468 2
a469 5
int 
rf_RecurAssignNodeNums(node, num, unvisited)
	RF_DagNode_t *node;
	int     num;
	int     unvisited;
d471 1
a471 1
	int     i;
d478 2
a479 1
			num = rf_RecurAssignNodeNums(node->succedents[i], num, unvisited);
d484 4
a487 5
/* set the header pointers in each node to "newptr" */
void 
rf_ResetDAGHeaderPointers(dag_h, newptr)
	RF_DagHeader_t *dag_h;
	RF_DagHeader_t *newptr;
d489 2
a490 1
	int     i;
d493 2
a494 1
			rf_RecurResetDAGHeaderPointers(dag_h->succedents[i], newptr);
d497 2
a498 4
void 
rf_RecurResetDAGHeaderPointers(node, newptr)
	RF_DagNode_t *node;
	RF_DagHeader_t *newptr;
d500 2
a501 1
	int     i;
d505 2
a506 1
			rf_RecurResetDAGHeaderPointers(node->succedents[i], newptr);
d509 2
a510 3

void 
rf_PrintDAGList(RF_DagHeader_t * dag_h)
d512 1
a512 1
	int     i = 0;
d521 3
a523 7
static int 
rf_ValidateBranch(node, scount, acount, nodes, unvisited)
	RF_DagNode_t *node;
	int    *scount;
	int    *acount;
	RF_DagNode_t **nodes;
	int     unvisited;
d525 1
a525 1
	int     i, retcode = 0;
d527 1
a527 1
	/* construct an array of node pointers indexed by node num */
d532 1
a532 1
		printf("INVALID DAG: next pointer in node is not NULL\n");
d536 1
a536 1
		printf("INVALID DAG: Node status is not wait\n");
d540 1
a540 1
		printf("INVALID DAG: numAntDone is not zero\n");
d545 2
a546 1
			printf("INVALID DAG: Terminator node has succedents\n");
d551 2
a552 1
			printf("INVALID DAG: Non-terminator node has no succedents\n");
d558 2
a559 1
			printf("INVALID DAG: succedent %d of node %s is NULL\n", i, node->name);
d566 2
a567 1
			printf("INVALID DAG: antecedent %d of node %s is NULL\n", i, node->name);
d583 2
a584 5
static void 
rf_ValidateBranchVisitedBits(node, unvisited, rl)
	RF_DagNode_t *node;
	int     unvisited;
	int     rl;
d586 1
a586 1
	int     i;
d591 2
a592 1
			printf("node=%lx node->succedents[%d] is NULL\n", (long) node, i);
d595 2
a596 1
		rf_ValidateBranchVisitedBits(node->succedents[i], unvisited, rl + 1);
d599 4
a602 2
/* NOTE:  never call this on a big dag, because it is exponential
 * in execution time
d604 2
a605 3
static void 
rf_ValidateVisitedBits(dag)
	RF_DagHeader_t *dag;
d607 1
a607 1
	int     i, unvisited;
d613 2
a614 1
			printf("dag=%lx dag->succedents[%d] is NULL\n", (long) dag, i);
d620 3
a622 1
/* validate a DAG.  _at entry_ verify that:
d636 1
a636 1
 *   -- what else?
d638 9
a646 10
int 
rf_ValidateDAG(dag_h)
	RF_DagHeader_t *dag_h;
{
	int     i, nodecount;
	int    *scount, *acount;/* per-node successor and antecedent counts */
	RF_DagNode_t **nodes;	/* array of ptrs to nodes in dag */
	int     retcode = 0;
	int     unvisited;
	int     commitNodeCount = 0;
d652 2
a653 1
		printf("INVALID DAG: num nodes completed is %d, should be 0\n", dag_h->numNodesCompleted);
d658 1
a658 1
		printf("INVALID DAG: not enabled\n");
d663 2
a664 1
		printf("INVALID DAG: numCommits != 0 (%d)\n", dag_h->numCommits);
d669 3
a671 2
		/* currently, all dags must have only one succedent */
		printf("INVALID DAG: numSuccedents !1 (%d)\n", dag_h->numSuccedents);
d689 1
a689 1
	/* start at 1 to skip the header node */
d694 2
a695 1
			printf("INVALID DAG: node %s has an undefined doFunc\n", nodes[i]->name);
d700 2
a701 1
			printf("INVALID DAG: node %s has an undefined doFunc\n", nodes[i]->name);
d706 4
a709 2
			printf("INVALID DAG: node %s has %d antecedents but appears as a succedent %d times\n",
			    nodes[i]->name, nodes[i]->numAntecedents, scount[nodes[i]->nodeNum]);
d714 4
a717 2
			printf("INVALID DAG: node %s has %d succedents but appears as an antecedent %d times\n",
			    nodes[i]->name, nodes[i]->numSuccedents, acount[nodes[i]->nodeNum]);
d724 3
a726 1
		printf("INVALID DAG: incorrect commit node count.  hdr->numCommitNodes (%d) found (%d) commit nodes in graph\n",
d731 1
d750 1
a750 1
/******************************************************************************
d752 1
a752 1
 * misc construction routines
d756 8
a763 10
void 
rf_redirect_asm(
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap)
{
	int     ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) ? 1 : 0;
	int     row = asmap->physInfo->row;
	int     fcol = raidPtr->reconControl[row]->fcol;
	int     srow = raidPtr->reconControl[row]->spareRow;
	int     scol = raidPtr->reconControl[row]->spareCol;
d770 3
a772 2
				if (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap,
					pda->startSector)) {
d776 1
a776 1
			/* printf("Remapped data for large write\n"); */
d778 3
a780 2
				raidPtr->Layout.map->MapSector(raidPtr, pda->raidAddress,
				    &pda->row, &pda->col, &pda->startSector, RF_REMAP);
d790 3
a792 1
				if (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, pda->startSector)) {
d798 3
a800 1
			(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);
d809 2
a810 1
/* this routine allocates read buffers and generates stripe maps for the
d812 1
a812 1
 * access, and from the end of the access to the end of the stripe.  It also
d818 1
a818 1
void 
d820 16
a835 11
    RF_Raid_t * raidPtr,
    RF_RaidLayout_t * layoutPtr,/* in: layout information */
    RF_AccessStripeMap_t * asmap,	/* in: access stripe map */
    RF_DagHeader_t * dag_h,	/* in: header of the dag to create */
    RF_AccessStripeMapHeader_t ** new_asm_h,	/* in: ptr to array of 2
						 * headers, to be filled in */
    int *nRodNodes,		/* out: num nodes to be generated to read
				 * unaccessed data */
    char **sosBuffer,		/* out: pointers to newly allocated buffer */
    char **eosBuffer,
    RF_AllocListElem_t * allocList)
d841 4
a844 2
	/* generate an access map for the region of the array from start of
	 * stripe to start of access */
d848 2
a849 1
		sosRaidAddress = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);
d851 4
a854 2
		RF_MallocAndAdd(*sosBuffer, rf_RaidAddressToByte(raidPtr, sosNumSector), (char *), allocList);
		new_asm_h[0] = rf_MapAccess(raidPtr, sosRaidAddress, sosNumSector, *sosBuffer, RF_DONT_REMAP);
d860 1
a860 1
		/* we're totally within one stripe here */
d864 4
a867 2
	/* generate an access map for the region of the array from end of
	 * access to end of stripe */
d870 6
a875 3
		eosNumSector = rf_RaidAddressOfNextStripeBoundary(layoutPtr, eosRaidAddress) - eosRaidAddress;
		RF_MallocAndAdd(*eosBuffer, rf_RaidAddressToByte(raidPtr, eosNumSector), (char *), allocList);
		new_asm_h[1] = rf_MapAccess(raidPtr, eosRaidAddress, eosNumSector, *eosBuffer, RF_DONT_REMAP);
d881 1
a881 1
		/* we're totally within one stripe here */
d888 16
a904 12
/* returns non-zero if the indicated ranges of stripe unit offsets overlap */
int 
rf_PDAOverlap(
    RF_RaidLayout_t * layoutPtr,
    RF_PhysDiskAddr_t * src,
    RF_PhysDiskAddr_t * dest)
{
	RF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);
	RF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);
	/* use -1 to be sure we stay within SU */
	RF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);
	RF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);
d909 2
a910 1
/* GenerateFailedAccessASMs
d912 2
a913 2
 * this routine figures out what portion of the stripe needs to be read
 * to effect the degraded read or write operation.  It's primary function
d919 5
a923 5
 * the access to the end of the stripe.  These ASMs describe everything that
 * needs to be read to effect the degraded access.  Other results are:
 *    nXorBufs -- the total number of buffers that need to be XORed together to
 *                recover the lost data,
 *    rpBufPtr -- ptr to a newly-allocated buffer to hold the parity.  If NULL
d926 1
a926 1
 *                describes which of the non-failed PDAs in the user access
d929 1
a929 1
 *                PDA, the ith pda in the input asm overlaps data that needs
d932 7
a938 7
 /* in: asm - ASM for the actual access, one stripe only */
 /* in: faildPDA - which component of the access has failed */
 /* in: dag_h - header of the DAG we're going to create */
 /* out: new_asm_h - the two new ASMs */
 /* out: nXorBufs - the total number of xor bufs required */
 /* out: rpBufPtr - a buffer for the parity read */
void 
d940 10
a949 9
    RF_Raid_t * raidPtr,
    RF_AccessStripeMap_t * asmap,
    RF_PhysDiskAddr_t * failedPDA,
    RF_DagHeader_t * dag_h,
    RF_AccessStripeMapHeader_t ** new_asm_h,
    int *nXorBufs,
    char **rpBufPtr,
    char *overlappingPDAs,
    RF_AllocListElem_t * allocList)
d958 2
a959 2
	char   *rdBuf, *bufP;
	int     foundit, i;
d963 36
a998 18
	/* first compute the following raid addresses: start of stripe,
	 * (sosAddr) MIN(start of access, start of failed SU),   (sosEndAddr)
	 * MAX(end of access, end of failed SU),       (eosStartAddr) end of
	 * stripe (i.e. start of next stripe)   (eosAddr) */
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);
	sosEndAddr = RF_MIN(asmap->raidAddress, rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->raidAddress));
	eosStartAddr = RF_MAX(asmap->endRaidAddress, rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr, failedPDA->raidAddress));
	eosAddr = rf_RaidAddressOfNextStripeBoundary(layoutPtr, asmap->raidAddress);

	/* now generate access stripe maps for each of the above regions of
	 * the stripe.  Use a dummy (NULL) buf ptr for now */

	new_asm_h[0] = (sosAddr != sosEndAddr) ? rf_MapAccess(raidPtr, sosAddr, sosEndAddr - sosAddr, NULL, RF_DONT_REMAP) : NULL;
	new_asm_h[1] = (eosStartAddr != eosAddr) ? rf_MapAccess(raidPtr, eosStartAddr, eosAddr - eosStartAddr, NULL, RF_DONT_REMAP) : NULL;

	/* walk through the PDAs and range-restrict each SU to the region of
	 * the SU touched on the failed PDA.  also compute total data buffer
	 * space requirements in this step.  Ignore the parity for now. */
d1004 4
a1007 2
		for (pda = new_asm_h[0]->stripeMap->physInfo; pda; pda = pda->next) {
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda, RF_RESTRICT_NOBUFFER, 0);
d1014 4
a1017 2
		for (pda = new_asm_h[1]->stripeMap->physInfo; pda; pda = pda->next) {
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda, RF_RESTRICT_NOBUFFER, 0);
d1023 10
a1032 6
	/* allocate buffer space for the data & parity we have to read to
	 * recover from the failure */

	if (numSect[0] + numSect[1] + ((rpBufPtr) ? numParitySect : 0)) {	/* don't allocate parity
										 * buf if not needed */
		RF_MallocAndAdd(rdBuf, rf_RaidAddressToByte(raidPtr, numSect[0] + numSect[1] + numParitySect), (char *), allocList);
d1036 3
a1038 1
			    (int) rf_RaidAddressToByte(raidPtr, numSect[0] + numSect[1] + numParitySect), (unsigned long) bufP);
d1040 7
a1046 5
	/* now walk through the pdas one last time and assign buffer pointers
	 * (ugh!).  Again, ignore the parity.  also, count nodes to find out
	 * how many bufs need to be xored together */
	(*nXorBufs) = 1;	/* in read case, 1 is for parity.  In write
				 * case, 1 is for failed data */
d1048 2
a1049 1
		for (pda = new_asm_h[0]->stripeMap->physInfo; pda; pda = pda->next) {
d1056 2
a1057 1
		for (pda = new_asm_h[1]->stripeMap->physInfo; pda; pda = pda->next) {
d1064 2
a1065 2
		*rpBufPtr = bufP;	/* the rest of the buffer is for
					 * parity */
d1067 3
a1069 2
	/* the last step is to figure out how many more distinct buffers need
	 * to get xor'd to produce the missing unit.  there's one for each
d1071 2
a1072 1
	 * being accessed */
d1074 2
a1075 1
	for (foundit = i = 0, pda = asmap->physInfo; pda; i++, pda = pda->next) {
d1087 2
a1088 1
		RF_ERRORMSG("GenerateFailedAccessASMs: did not find failedPDA in asm list\n");
d1104 3
a1106 2
/* adjusts the offset and number of sectors in the destination pda so that
 * it covers at most the region of the SU covered by the source PDA.  This
d1127 3
a1129 7
void 
rf_RangeRestrictPDA(
    RF_Raid_t * raidPtr,
    RF_PhysDiskAddr_t * src,
    RF_PhysDiskAddr_t * dest,
    int dobuffer,
    int doraidaddr)
d1132 13
a1144 6
	RF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);
	RF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);
	RF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);	/* use -1 to be sure we
													 * stay within SU */
	RF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);
	RF_SectorNum_t subAddr = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->startSector);	/* stripe unit boundary */
d1150 2
a1151 1
		dest->bufPtr += (soffs > doffs) ? rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;
d1153 3
a1155 1
		dest->raidAddress = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->raidAddress) +
d1159 1
d1166 1
a1166 1
#define NLOWPRIMES 8
d1168 1
d1170 1
a1170 1
 * compute the workload shift factor.  (chained declustering)
d1172 2
a1173 2
 * return nonzero if access should shift to secondary, otherwise,
 * access is to primary
d1175 2
a1176 4
int 
rf_compute_workload_shift(
    RF_Raid_t * raidPtr,
    RF_PhysDiskAddr_t * pda)
d1179 9
a1187 8
         * variables:
         *  d   = column of disk containing primary
         *  f   = column of failed disk
         *  n   = number of disks in array
         *  sd  = "shift distance" (number of columns that d is to the right of f)
         *  row = row of array the access is in
         *  v   = numerator of redirection ratio
         *  k   = denominator of redirection ratio
d1190 1
a1190 1
	int     k, v, ret, i;
d1195 1
a1195 1
	/* assign column of primary copy to d */
d1198 3
a1200 2
	/* assign column of dead disk to f */
	for (f = 0; ((!RF_DEAD_DISK(raidPtr->Disks[row][f].status)) && (f < n)); f++);
d1209 1
a1209 1
         * v of every k accesses should be redirected
d1219 1
a1219 1
         * Is this worth it?
d1222 1
a1222 1
         * out primes (just like they teach in elementary school!)
d1236 1
a1236 1
		ret = 0;	/* do not redirect */
d1238 1
a1238 1
		ret = 1;	/* redirect */
d1247 1
a1247 1
		/* reset counter */
d1252 1
d1254 1
a1254 1
 * Disk selection routines
d1258 1
a1258 1
 * Selects the disk with the shortest queue from a mirror pair.
d1260 1
a1260 1
 * disk are counted as members of the "queue"
d1262 2
a1263 2
void 
rf_SelectMirrorDiskIdle(RF_DagNode_t * node)
d1267 1
a1267 1
	int     dataQueueLength, mirrorQueueLength, usemirror;
d1274 1
a1274 1
	/* return the [row col] of the disk with the shortest queue */
d1282 1
a1282 1
#ifdef RF_LOCK_QUEUES_TO_READ_LEN
d1284 1
a1284 1
#endif				/* RF_LOCK_QUEUES_TO_READ_LEN */
d1286 1
a1286 1
#ifdef RF_LOCK_QUEUES_TO_READ_LEN
d1289 4
a1292 3
#endif				/* RF_LOCK_QUEUES_TO_READ_LEN */
	mirrorQueueLength = mirrorQueue->queueLength + mirrorQueue->numOutstanding;
#ifdef RF_LOCK_QUEUES_TO_READ_LEN
d1294 1
a1294 1
#endif				/* RF_LOCK_QUEUES_TO_READ_LEN */
d1304 1
a1304 1
				/* Trust only the main disk */
d1313 8
a1320 4
					/* queues are equal length. attempt
					 * cleverness. */
					if (SNUM_DIFF(dataQueue->last_deq_sector, data_pda->startSector)
					    <= SNUM_DIFF(mirrorQueue->last_deq_sector, mirror_pda->startSector)) {
d1328 1
a1328 1
		/* use mirror (parity) disk, swap params 0 & 4 */
d1333 1
a1333 1
		/* use data disk, leave param 0 unchanged */
d1335 2
a1336 2
	/* printf("dataQueueLength %d, mirrorQueueLength
	 * %d\n",dataQueueLength, mirrorQueueLength); */
d1338 1
d1343 2
a1344 2
void 
rf_SelectMirrorDiskPartition(RF_DagNode_t * node)
d1353 1
a1353 1
	int     usemirror;
d1355 1
a1355 1
	/* return the [row col] of the disk with the shortest queue */
d1369 1
a1369 1
		} else 
d1371 1
a1371 1
				/* Trust only the main disk */
d1374 1
a1374 1
				if (data_pda->startSector < 
d1382 1
a1382 1
		/* use mirror (parity) disk, swap params 0 & 4 */
d1387 1
a1387 1
		/* use data disk, leave param 0 unchanged */
@


1.3.12.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d32 1
a32 1
 * rf_dagutils.c -- Utility routines for manipulating dags.
d48 1
a48 1
#define	SNUM_DIFF(_a_,_b_)	(((_a_)>(_b_))?((_a_)-(_b_)):((_b_)-(_a_)))
d51 2
a52 2
	rf_RegularXorFunc, "Reg Xr", rf_SimpleXorFunc, "Simple Xr"
};
d55 2
a56 2
	rf_RecoveryXorFunc, "Recovery Xr", rf_RecoveryXorFunc, "Recovery Xr"
};
d58 7
a64 5
void rf_RecurPrintDAG(RF_DagNode_t *, int, int);
void rf_PrintDAG(RF_DagHeader_t *);
int  rf_ValidateBranch(RF_DagNode_t *, int *, int *, RF_DagNode_t **, int);
void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);
void rf_ValidateVisitedBits(RF_DagHeader_t *);
d66 1
a66 1
/*****************************************************************************
d68 1
a68 1
 * InitNode - Initialize a dag node.
d70 1
a70 1
 * The size of the propList array is always the same as that of the
d74 1
a74 1
void
d76 13
a88 14
	RF_DagNode_t	 *node,
	RF_NodeStatus_t	  initstatus,
	int		  commit,
	int		(*doFunc) (RF_DagNode_t *),
	int		(*undoFunc) (RF_DagNode_t *node),
	int		(*wakeFunc) (RF_DagNode_t *node, int),
	int		  nSucc,
	int		  nAnte,
	int		  nParam,
	int		  nResult,
	RF_DagHeader_t	 *hdr,
	char		 *name,
	RF_AllocListElem_t *alist
)
d90 2
a91 2
	void **ptrs;
	int nptrs;
d110 1
a110 1
	/* Allocate all the pointers with one call to malloc. */
d118 2
a119 2
	         * we pick a "common case" size for the pointer cache.
		 * Hopefully, we'll find that:
d121 3
a123 3
	         *     only a little bit (least efficient case).
	         * (2) Generally, ntprs isn't a lot less than
		 *     RF_DAG_PTRCACHESIZE (wasted memory).
d132 1
a132 2
	node->propList = (nSucc) ? (RF_PropHeader_t **)
	    (ptrs + nSucc + nAnte + nResult) : NULL;
d138 1
a138 2
			RF_CallocAndAdd(node->params, nParam,
			    sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);
d147 1
a147 1
/*****************************************************************************
d149 1
a149 1
 * Allocation and deallocation routines.
d153 3
a155 2
void
rf_FreeDAG(RF_DagHeader_t *dag_h)
d159 1
a159 1
	int i;
d164 1
a164 1
			/* Release mem chunks. */
d171 2
a172 3
			/* Free xtraMemChunks. */
			for (i = 0; dag_h->xtraMemChunk[i] &&
			     i < dag_h->xtraChunkIndex; i++) {
d177 2
a178 3
			/* Free ptrs to xtraMemChunks. */
			RF_Free(dag_h->xtraMemChunk, dag_h->xtraChunkCnt *
			    sizeof(RF_ChunkDesc_t *));
d192 6
a197 2
rf_MakePropListEntry(RF_DagHeader_t *dag_h, int resultNum, int paramNum,
    RF_PropHeader_t *next, RF_AllocListElem_t *allocList)
d201 2
a202 2
	RF_CallocAndAdd(p, 1, sizeof(RF_PropHeader_t), (RF_PropHeader_t *),
	    allocList);
d211 8
a218 7
#define	RF_MAX_FREE_DAGH	128
#define	RF_DAGH_INC		 16
#define	RF_DAGH_INITIAL		 32

void rf_ShutdownDAGs(void *);
void
rf_ShutdownDAGs(void *ignored)
d223 3
a225 2
int
rf_ConfigureDAGs(RF_ShutdownList_t **listp)
d227 1
a227 1
	int rc;
d229 2
a230 2
	RF_FREELIST_CREATE(rf_dagh_freelist, RF_MAX_FREE_DAGH, RF_DAGH_INC,
	    sizeof(RF_DagHeader_t));
d235 2
a236 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line"
		    " %d rc=%d\n", __FILE__, __LINE__, rc);
d246 1
a246 1
rf_AllocDAGHeader(void)
d257 2
a258 2
void
rf_FreeDAGHeader(RF_DagHeader_t *dh)
d262 7
a268 5

/* Allocate a buffer big enough to hold the data described by pda. */
void *
rf_AllocBuffer(RF_Raid_t *raidPtr, RF_DagHeader_t *dag_h,
    RF_PhysDiskAddr_t *pda, RF_AllocListElem_t *allocList)
d270 1
a270 1
	char *p;
d276 1
a276 3


/*****************************************************************************
d278 1
a278 1
 * Debug routines.
d282 2
a283 2
char *
rf_NodeStatusString(RF_DagNode_t *node)
d286 1
a286 2
	case rf_wait:
		return ("wait");
d298 2
a299 2
void
rf_PrintNodeInfoString(RF_DagNode_t *node)
d302 7
a308 7
	int (*df) (RF_DagNode_t *) = node->doFunc;
	int i, lk, unlk;
	void *bufPtr;

	if ((df == rf_DiskReadFunc) || (df == rf_DiskWriteFunc) ||
	    (df == rf_DiskReadMirrorIdleFunc) ||
	    (df == rf_DiskReadMirrorPartitionFunc)) {
d314 3
a316 3
		printf("r %d c %d offs %ld nsect %d buf 0x%lx %s\n", pda->row,
		    pda->col, (long) pda->startSector, (int) pda->numSector,
		    (long) bufPtr, (lk) ? "LOCK" : ((unlk) ? "UNLK" : " "));
d340 1
a340 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d351 1
a351 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d360 5
a364 2
void
rf_RecurPrintDAG(RF_DagNode_t *node, int depth, int unvisited)
d366 2
a367 2
	char *anttype;
	int i;
d371 3
a373 5
	    node->nodeNum, node->commitNode, node->name,
	    rf_NodeStatusString(node), node->numSuccedents,
	    node->numSuccFired, node->numSuccDone,
	    node->numAntecedents, node->numAntDone,
	    node->numParams, node->numResults);
d397 1
a397 2
		printf("%d(%s)%s", node->antecedents[i]->nodeNum, anttype,
		    (i == node->numAntecedents - 1) ? "\0" : " ");
d403 1
a403 2
			rf_RecurPrintDAG(node->succedents[i], depth + 1,
			    unvisited);
d407 3
a409 2
void
rf_PrintDAG(RF_DagHeader_t *dag_h)
d411 2
a412 2
	int unvisited, i;
	char *status;
d414 1
a414 1
	/* Set dag status. */
d426 1
a426 1
		status = "illegal !";
d429 1
a429 1
	/* Find out if visited bits are currently set or cleared. */
d433 1
a433 2
	printf("format is (depth) num commit type: status,nSucc nSuccFired/n"
	    "SuccDone,nAnte/nAnteDone,nParam,nResult S{x} A{x(type)};  info\n");
d435 1
a435 2
	    status, dag_h->numSuccedents, dag_h->numCommitNodes,
	    dag_h->numCommits);
d446 3
a448 4

/* Assign node numbers. */
int
rf_AssignNodeNums(RF_DagHeader_t *dag_h)
d450 1
a450 1
	int unvisited, i, nnum;
d460 1
a460 2
			nnum = rf_RecurAssignNodeNums(dag_h->succedents[i],
			    nnum, unvisited);
d466 5
a470 2
int
rf_RecurAssignNodeNums(RF_DagNode_t *node, int num, int unvisited)
d472 1
a472 1
	int i;
d479 1
a479 2
			num = rf_RecurAssignNodeNums(node->succedents[i],
			    num, unvisited);
d484 5
a488 4

/* Set the header pointers in each node to "newptr". */
void
rf_ResetDAGHeaderPointers(RF_DagHeader_t *dag_h, RF_DagHeader_t *newptr)
d490 1
a490 2
	int i;

d493 1
a493 2
			rf_RecurResetDAGHeaderPointers(dag_h->succedents[i],
			    newptr);
d496 4
a499 2
void
rf_RecurResetDAGHeaderPointers(RF_DagNode_t *node, RF_DagHeader_t *newptr)
d501 1
a501 2
	int i;

d505 1
a505 2
			rf_RecurResetDAGHeaderPointers(node->succedents[i],
			    newptr);
d508 3
a510 2
void
rf_PrintDAGList(RF_DagHeader_t *dag_h)
d512 1
a512 1
	int i = 0;
d521 7
a527 3
int
rf_ValidateBranch(RF_DagNode_t *node, int *scount, int *acount,
    RF_DagNode_t **nodes, int unvisited)
d529 1
a529 1
	int i, retcode = 0;
d531 1
a531 1
	/* Construct an array of node pointers indexed by node num. */
d536 1
a536 1
		printf("INVALID DAG: next pointer in node is not NULL.\n");
d540 1
a540 1
		printf("INVALID DAG: Node status is not wait.\n");
d544 1
a544 1
		printf("INVALID DAG: numAntDone is not zero.\n");
d549 1
a549 2
			printf("INVALID DAG: Terminator node has"
			    " succedents.\n");
d554 1
a554 2
			printf("INVALID DAG: Non-terminator node has no"
			    " succedents\n");
d560 1
a560 2
			printf("INVALID DAG: succedent %d of node %s"
			    " is NULL.\n", i, node->name);
d567 1
a567 2
			printf("INVALID DAG: antecedent %d of node %s is"
			    " NULL.\n", i, node->name);
d583 5
a587 2
void
rf_ValidateBranchVisitedBits(RF_DagNode_t *node, int unvisited, int rl)
d589 1
a589 1
	int i;
d594 1
a594 2
			printf("node=%lx node->succedents[%d] is NULL.\n",
			    (long) node, i);
d597 1
a597 2
		rf_ValidateBranchVisitedBits(node->succedents[i],
		    unvisited, rl + 1);
d600 2
a601 4

/*
 * NOTE:  Never call this on a big dag, because it is exponential
 * in execution time.
d603 3
a605 2
void
rf_ValidateVisitedBits(RF_DagHeader_t *dag)
d607 1
a607 1
	int i, unvisited;
d613 1
a613 2
			printf("dag=%lx dag->succedents[%d] is NULL.\n",
			    (long) dag, i);
d619 1
a619 3

/*
 * Validate a DAG. _at entry_ verify that:
d633 1
a633 1
 *   -- what else ?
d635 10
a644 9
int
rf_ValidateDAG(RF_DagHeader_t *dag_h)
{
	int i, nodecount;
	int *scount, *acount;	/* Per-node successor and antecedent counts. */
	RF_DagNode_t **nodes;	/* Array of ptrs to nodes in dag. */
	int retcode = 0;
	int unvisited;
	int commitNodeCount = 0;
d650 1
a650 2
		printf("INVALID DAG: num nodes completed is %d, should be 0.\n",
		    dag_h->numNodesCompleted);
d655 1
a655 1
		printf("INVALID DAG: not enabled.\n");
d660 1
a660 2
		printf("INVALID DAG: numCommits != 0 (%d)\n",
		    dag_h->numCommits);
d665 2
a666 3
		/* Currently, all dags must have only one succedent. */
		printf("INVALID DAG: numSuccedents != 1 (%d).\n",
		    dag_h->numSuccedents);
d684 1
a684 1
	/* Start at 1 to skip the header node. */
d689 1
a689 2
			printf("INVALID DAG: node %s has an undefined"
			    " doFunc.\n", nodes[i]->name);
d694 1
a694 2
			printf("INVALID DAG: node %s has an undefined"
			    " doFunc.\n", nodes[i]->name);
d699 2
a700 4
			printf("INVALID DAG: node %s has %d antecedents but"
			    " appears as a succedent %d times.\n",
			    nodes[i]->name, nodes[i]->numAntecedents,
			    scount[nodes[i]->nodeNum]);
d705 2
a706 4
			printf("INVALID DAG: node %s has %d succedents but"
			    " appears as an antecedent %d times.\n",
			    nodes[i]->name, nodes[i]->numSuccedents,
			    acount[nodes[i]->nodeNum]);
d713 1
a713 3
		printf("INVALID DAG: incorrect commit node count. "
		    "hdr->numCommitNodes (%d) found (%d) commit nodes"
		    " in graph.\n",
a717 1

d736 1
a736 1
/*****************************************************************************
d738 1
a738 1
 * Misc construction routines.
d742 10
a751 8
void
rf_redirect_asm(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap)
{
	int ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) ? 1 : 0;
	int row = asmap->physInfo->row;
	int fcol = raidPtr->reconControl[row]->fcol;
	int srow = raidPtr->reconControl[row]->spareRow;
	int scol = raidPtr->reconControl[row]->spareCol;
d758 2
a759 3
				if (!rf_CheckRUReconstructed(
				    raidPtr->reconControl[row]->reconMap,
				    pda->startSector)) {
d763 1
a763 1
			/*printf("Remapped data for large write\n");*/
d765 2
a766 3
				raidPtr->Layout.map->MapSector(raidPtr,
				    pda->raidAddress, &pda->row, &pda->col,
				    &pda->startSector, RF_REMAP);
d776 1
a776 3
				if (!rf_CheckRUReconstructed(
				    raidPtr->reconControl[row]->reconMap,
				    pda->startSector)) {
d782 1
a782 3
			(raidPtr->Layout.map->MapParity) (raidPtr,
			    pda->raidAddress, &pda->row, &pda->col,
			    &pda->startSector, RF_REMAP);
d791 1
a791 2
/*
 * This routine allocates read buffers and generates stripe maps for the
d793 1
a793 1
 * access, and from the end of the access to the end of the stripe. It also
d799 1
a799 1
void
d801 11
a811 16
	RF_Raid_t		 *raidPtr,
	RF_RaidLayout_t		 *layoutPtr,	/* in: layout information */
	RF_AccessStripeMap_t	 *asmap,	/* in: access stripe map */
	RF_DagHeader_t		 *dag_h,	/* in: header of the dag */
						/*     to create */
	RF_AccessStripeMapHeader_t **new_asm_h,	/* in: ptr to array of 2 */
						/*     headers, to be */
						/*     filled in */
	int			 *nRodNodes,	/* out: num nodes to be */
						/*      generated to read */
						/*      unaccessed data */
	char			**sosBuffer,	/* out: pointers to newly */
						/*      allocated buffer */
	char			**eosBuffer,
	RF_AllocListElem_t	 *allocList
)
d817 2
a818 4
	/*
	 * Generate an access map for the region of the array from start of
	 * stripe to start of access.
	 */
d822 1
a822 2
		sosRaidAddress = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
		    asmap->raidAddress);
d824 2
a825 4
		RF_MallocAndAdd(*sosBuffer, rf_RaidAddressToByte(raidPtr,
		    sosNumSector), (char *), allocList);
		new_asm_h[0] = rf_MapAccess(raidPtr, sosRaidAddress,
		    sosNumSector, *sosBuffer, RF_DONT_REMAP);
d831 1
a831 1
		/* We're totally within one stripe here. */
d835 2
a836 4
	/*
	 * Generate an access map for the region of the array from end of
	 * access to end of stripe.
	 */
d839 3
a841 6
		eosNumSector = rf_RaidAddressOfNextStripeBoundary(layoutPtr,
		    eosRaidAddress) - eosRaidAddress;
		RF_MallocAndAdd(*eosBuffer, rf_RaidAddressToByte(raidPtr,
		    eosNumSector), (char *), allocList);
		new_asm_h[1] = rf_MapAccess(raidPtr, eosRaidAddress,
		    eosNumSector, *eosBuffer, RF_DONT_REMAP);
d847 1
a847 1
		/* We're totally within one stripe here. */
a853 16
/* Returns non-zero if the indicated ranges of stripe unit offsets overlap. */
int
rf_PDAOverlap(RF_RaidLayout_t *layoutPtr, RF_PhysDiskAddr_t *src,
    RF_PhysDiskAddr_t *dest)
{
	RF_SectorNum_t soffs =
	    rf_StripeUnitOffset(layoutPtr, src->startSector);
	RF_SectorNum_t doffs =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector);
	/* Use -1 to be sure we stay within SU. */
	RF_SectorNum_t send =
	    rf_StripeUnitOffset(layoutPtr, src->startSector +
	    src->numSector - 1);
	RF_SectorNum_t dend =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector +
	    dest->numSector - 1);
d855 12
d871 1
a871 2
/*
 * GenerateFailedAccessASMs
d873 2
a874 2
 * This routine figures out what portion of the stripe needs to be read
 * to effect the degraded read or write operation. It's primary function
d880 5
a884 5
 * the access to the end of the stripe. These ASMs describe everything that
 * needs to be read to effect the degraded access. Other results are:
 *    nXorBufs -- The total number of buffers that need to be XORed together
 *		  to recover the lost data,
 *    rpBufPtr -- Ptr to a newly-allocated buffer to hold the parity. If NULL
d887 1
a887 1
 *                Describes which of the non-failed PDAs, in the user access,
d890 1
a890 1
 *                PDA, the i'th pda in the input asm overlaps data that needs
d893 7
a899 7
 /* in: asmap - ASM for the actual access, one stripe only. */
 /* in: faildPDA - Which component of the access has failed. */
 /* in: dag_h - Header of the DAG we're going to create. */
 /* out: new_asm_h - The two new ASMs. */
 /* out: nXorBufs - The total number of xor bufs required. */
 /* out: rpBufPtr - A buffer for the parity read. */
void
d901 9
a909 10
	RF_Raid_t		 *raidPtr,
	RF_AccessStripeMap_t	 *asmap,
	RF_PhysDiskAddr_t	 *failedPDA,
	RF_DagHeader_t		 *dag_h,
	RF_AccessStripeMapHeader_t **new_asm_h,
	int			 *nXorBufs,
	char			**rpBufPtr,
	char			 *overlappingPDAs,
	RF_AllocListElem_t	 *allocList
)
d918 2
a919 2
	char *rdBuf, *bufP;
	int foundit, i;
d923 18
a940 36
	/*
	 * First compute the following raid addresses:
	 * - Start of stripe
	 * - (sosAddr) MIN(start of access, start of failed SU)
	 * - (sosEndAddr) MAX(end of access, end of failed SU)
	 * - (eosStartAddr) end of stripe (i.e. start of next stripe)
	 *   (eosAddr)
	 */
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
	    asmap->raidAddress);
	sosEndAddr = RF_MIN(asmap->raidAddress,
	    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
	    failedPDA->raidAddress));
	eosStartAddr = RF_MAX(asmap->endRaidAddress,
	    rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr,
	    failedPDA->raidAddress));
	eosAddr = rf_RaidAddressOfNextStripeBoundary(layoutPtr,
	    asmap->raidAddress);

	/*
	 * Now generate access stripe maps for each of the above regions of
	 * the stripe. Use a dummy (NULL) buf ptr for now.
	 */

	new_asm_h[0] = (sosAddr != sosEndAddr) ?
	    rf_MapAccess(raidPtr, sosAddr, sosEndAddr - sosAddr, NULL,
	    RF_DONT_REMAP) : NULL;
	new_asm_h[1] = (eosStartAddr != eosAddr) ?
	    rf_MapAccess(raidPtr, eosStartAddr, eosAddr - eosStartAddr, NULL,
	    RF_DONT_REMAP) : NULL;

	/*
	 * Walk through the PDAs and range-restrict each SU to the region of
	 * the SU touched on the failed PDA. Also compute total data buffer
	 * space requirements in this step. Ignore the parity for now.
	 */
d946 2
a947 4
		for (pda = new_asm_h[0]->stripeMap->physInfo; pda;
		     pda = pda->next) {
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda,
			    RF_RESTRICT_NOBUFFER, 0);
d954 2
a955 4
		for (pda = new_asm_h[1]->stripeMap->physInfo;
		     pda; pda = pda->next) {
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda,
			    RF_RESTRICT_NOBUFFER, 0);
d961 6
a966 10
	/*
	 * Allocate buffer space for the data & parity we have to read to
	 * recover from the failure.
	 */

	if (numSect[0] + numSect[1] + ((rpBufPtr) ? numParitySect : 0)) {
		/* Don't allocate parity buf if not needed. */
		RF_MallocAndAdd(rdBuf, rf_RaidAddressToByte(raidPtr,
		    numSect[0] + numSect[1] + numParitySect), (char *),
		    allocList);
d970 1
a970 3
			    (int) rf_RaidAddressToByte(raidPtr,
			    numSect[0] + numSect[1] + numParitySect),
			    (unsigned long) bufP);
d972 5
a976 7
	/*
	 * Now walk through the pdas one last time and assign buffer pointers
	 * (ugh!). Again, ignore the parity. Also, count nodes to find out
	 * how many bufs need to be xored together.
	 */
	(*nXorBufs) = 1;	/* In read case, 1 is for parity. */
				/* In write case, 1 is for failed data. */
d978 1
a978 2
		for (pda = new_asm_h[0]->stripeMap->physInfo; pda;
		     pda = pda->next) {
d985 1
a985 2
		for (pda = new_asm_h[1]->stripeMap->physInfo; pda;
		     pda = pda->next) {
d992 2
a993 2
		/* The rest of the buffer is for parity. */
		*rpBufPtr = bufP;
d995 2
a996 3
	/*
	 * The last step is to figure out how many more distinct buffers need
	 * to get xor'd to produce the missing unit. there's one for each
d998 1
a998 2
	 * being accessed.
	 */
d1000 1
a1000 2
	for (foundit = i = 0, pda = asmap->physInfo;
	     pda; i++, pda = pda->next) {
d1012 1
a1012 2
		RF_ERRORMSG("GenerateFailedAccessASMs: did not find failedPDA"
		    " in asm list.\n");
d1028 2
a1029 3
/*
 * Adjust the offset and number of sectors in the destination pda so that
 * it covers at most the region of the SU covered by the source PDA. This
d1050 7
a1056 3
void
rf_RangeRestrictPDA(RF_Raid_t *raidPtr, RF_PhysDiskAddr_t *src,
    RF_PhysDiskAddr_t *dest, int dobuffer, int doraidaddr)
d1059 6
a1064 13
	RF_SectorNum_t soffs =
	    rf_StripeUnitOffset(layoutPtr, src->startSector);
	RF_SectorNum_t doffs =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector);
	RF_SectorNum_t send =
	    rf_StripeUnitOffset(layoutPtr, src->startSector +
	    src->numSector - 1); /* Use -1 to be sure we stay within SU. */
	RF_SectorNum_t dend =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector +
	    dest->numSector - 1);
	RF_SectorNum_t subAddr =
	    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
	    dest->startSector); /* Stripe unit boundary. */
d1070 1
a1070 2
		dest->bufPtr += (soffs > doffs) ?
		    rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;
d1072 1
a1072 3
		dest->raidAddress =
		    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
		    dest->raidAddress) +
a1075 1

d1082 1
a1082 1
#define	NLOWPRIMES	8
a1083 1

d1085 1
a1085 1
 * Compute the workload shift factor. (chained declustering)
d1087 2
a1088 2
 * Return nonzero if access should shift to secondary, otherwise,
 * access is to primary.
d1090 4
a1093 2
int
rf_compute_workload_shift(RF_Raid_t *raidPtr, RF_PhysDiskAddr_t *pda)
d1096 8
a1103 9
         * Variables:
         *  d   = Column of disk containing primary.
         *  f   = Column of failed disk.
         *  n   = Number of disks in array.
         *  sd  = "shift distance"
	 *	  (number of columns that d is to the right of f).
         *  row = Row of array the access is in.
         *  v   = Numerator of redirection ratio.
         *  k   = Denominator of redirection ratio.
d1106 1
a1106 1
	int k, v, ret, i;
d1111 1
a1111 1
	/* Assign column of primary copy to d. */
d1114 2
a1115 3
	/* Assign column of dead disk to f. */
	for (f = 0; ((!RF_DEAD_DISK(raidPtr->Disks[row][f].status)) &&
	     (f < n)); f++);
d1124 1
a1124 1
         * v of every k accesses should be redirected.
d1134 1
a1134 1
         * Is this worth it ?
d1137 1
a1137 1
         * out primes (just like they teach in elementary school !).
d1151 1
a1151 1
		ret = 0;	/* Do not redirect. */
d1153 1
a1153 1
		ret = 1;	/* Redirect. */
d1162 1
a1162 1
		/* Reset counter. */
a1166 1

d1168 1
a1168 1
 * Disk selection routines.
d1172 1
a1172 1
 * Select the disk with the shortest queue from a mirror pair.
d1174 1
a1174 1
 * disk are counted as members of the "queue".
d1176 2
a1177 2
void
rf_SelectMirrorDiskIdle(RF_DagNode_t *node)
d1181 1
a1181 1
	int dataQueueLength, mirrorQueueLength, usemirror;
d1188 1
a1188 1
	/* Return the [row col] of the disk with the shortest queue. */
d1196 1
a1196 1
#ifdef	RF_LOCK_QUEUES_TO_READ_LEN
d1198 1
a1198 1
#endif	/* RF_LOCK_QUEUES_TO_READ_LEN */
d1200 1
a1200 1
#ifdef	RF_LOCK_QUEUES_TO_READ_LEN
d1203 3
a1205 4
#endif	/* RF_LOCK_QUEUES_TO_READ_LEN */
	mirrorQueueLength = mirrorQueue->queueLength +
	    mirrorQueue->numOutstanding;
#ifdef	RF_LOCK_QUEUES_TO_READ_LEN
d1207 1
a1207 1
#endif	/* RF_LOCK_QUEUES_TO_READ_LEN */
d1217 1
a1217 1
				/* Trust only the main disk. */
d1226 4
a1229 8
					/* Queues are equal length. */
					/* Attempt cleverness. */
					if (SNUM_DIFF(dataQueue
					    ->last_deq_sector, data_pda
					    ->startSector) <=
					    SNUM_DIFF(mirrorQueue
					    ->last_deq_sector, mirror_pda
					    ->startSector)) {
d1237 1
a1237 1
		/* Use mirror (parity) disk, swap params 0 & 4. */
d1242 1
a1242 1
		/* Use data disk, leave param 0 unchanged. */
d1244 2
a1245 2
	/*printf("dataQueueLength %d, mirrorQueueLength %d\n", dataQueueLength,
	    mirrorQueueLength);*/
a1246 1

d1251 2
a1252 2
void
rf_SelectMirrorDiskPartition(RF_DagNode_t *node)
d1261 1
a1261 1
	int usemirror;
d1263 1
a1263 1
	/* Return the [row col] of the disk with the shortest queue. */
d1277 1
a1277 1
		} else
d1279 1
a1279 1
				/* Trust only the main disk. */
d1282 1
a1282 1
				if (data_pda->startSector <
d1290 1
a1290 1
		/* Use mirror (parity) disk, swap params 0 & 4. */
d1295 1
a1295 1
		/* Use data disk, leave param 0 unchanged. */
@


1.3.2.1
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

d30 1
a30 1
/*****************************************************************************
d32 1
a32 1
 * rf_dagutils.c -- Utility routines for manipulating dags.
d48 1
a48 1
#define	SNUM_DIFF(_a_,_b_)	(((_a_)>(_b_))?((_a_)-(_b_)):((_b_)-(_a_)))
d51 2
a52 2
	rf_RegularXorFunc, "Reg Xr", rf_SimpleXorFunc, "Simple Xr"
};
d55 2
a56 2
	rf_RecoveryXorFunc, "Recovery Xr", rf_RecoveryXorFunc, "Recovery Xr"
};
d58 7
a64 5
void rf_RecurPrintDAG(RF_DagNode_t *, int, int);
void rf_PrintDAG(RF_DagHeader_t *);
int  rf_ValidateBranch(RF_DagNode_t *, int *, int *, RF_DagNode_t **, int);
void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);
void rf_ValidateVisitedBits(RF_DagHeader_t *);
d66 1
a66 1
/*****************************************************************************
d68 1
a68 1
 * InitNode - Initialize a dag node.
d70 1
a70 1
 * The size of the propList array is always the same as that of the
d74 1
a74 1
void
d76 13
a88 14
	RF_DagNode_t	 *node,
	RF_NodeStatus_t	  initstatus,
	int		  commit,
	int		(*doFunc) (RF_DagNode_t *),
	int		(*undoFunc) (RF_DagNode_t *node),
	int		(*wakeFunc) (RF_DagNode_t *node, int),
	int		  nSucc,
	int		  nAnte,
	int		  nParam,
	int		  nResult,
	RF_DagHeader_t	 *hdr,
	char		 *name,
	RF_AllocListElem_t *alist
)
d90 2
a91 2
	void **ptrs;
	int nptrs;
d110 1
a110 1
	/* Allocate all the pointers with one call to malloc. */
d118 2
a119 2
	         * we pick a "common case" size for the pointer cache.
		 * Hopefully, we'll find that:
d121 3
a123 3
	         *     only a little bit (least efficient case).
	         * (2) Generally, ntprs isn't a lot less than
		 *     RF_DAG_PTRCACHESIZE (wasted memory).
d132 1
a132 2
	node->propList = (nSucc) ? (RF_PropHeader_t **)
	    (ptrs + nSucc + nAnte + nResult) : NULL;
d138 1
a138 2
			RF_CallocAndAdd(node->params, nParam,
			    sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);
d147 1
a147 1
/*****************************************************************************
d149 1
a149 1
 * Allocation and deallocation routines.
d153 3
a155 2
void
rf_FreeDAG(RF_DagHeader_t *dag_h)
d159 1
a159 1
	int i;
d164 1
a164 1
			/* Release mem chunks. */
d171 2
a172 3
			/* Free xtraMemChunks. */
			for (i = 0; dag_h->xtraMemChunk[i] &&
			     i < dag_h->xtraChunkIndex; i++) {
d177 2
a178 3
			/* Free ptrs to xtraMemChunks. */
			RF_Free(dag_h->xtraMemChunk, dag_h->xtraChunkCnt *
			    sizeof(RF_ChunkDesc_t *));
d192 6
a197 2
rf_MakePropListEntry(RF_DagHeader_t *dag_h, int resultNum, int paramNum,
    RF_PropHeader_t *next, RF_AllocListElem_t *allocList)
d201 2
a202 2
	RF_CallocAndAdd(p, 1, sizeof(RF_PropHeader_t), (RF_PropHeader_t *),
	    allocList);
d211 8
a218 7
#define	RF_MAX_FREE_DAGH	128
#define	RF_DAGH_INC		 16
#define	RF_DAGH_INITIAL		 32

void rf_ShutdownDAGs(void *);
void
rf_ShutdownDAGs(void *ignored)
d223 3
a225 2
int
rf_ConfigureDAGs(RF_ShutdownList_t **listp)
d227 1
a227 1
	int rc;
d229 2
a230 2
	RF_FREELIST_CREATE(rf_dagh_freelist, RF_MAX_FREE_DAGH, RF_DAGH_INC,
	    sizeof(RF_DagHeader_t));
d235 2
a236 2
		RF_ERRORMSG3("Unable to add to shutdown list file %s line"
		    " %d rc=%d\n", __FILE__, __LINE__, rc);
d246 1
a246 1
rf_AllocDAGHeader(void)
d257 2
a258 2
void
rf_FreeDAGHeader(RF_DagHeader_t *dh)
d262 7
a268 5

/* Allocate a buffer big enough to hold the data described by pda. */
void *
rf_AllocBuffer(RF_Raid_t *raidPtr, RF_DagHeader_t *dag_h,
    RF_PhysDiskAddr_t *pda, RF_AllocListElem_t *allocList)
d270 1
a270 1
	char *p;
d276 1
a276 3


/*****************************************************************************
d278 1
a278 1
 * Debug routines.
d282 2
a283 2
char *
rf_NodeStatusString(RF_DagNode_t *node)
d286 1
a286 2
	case rf_wait:
		return ("wait");
d298 2
a299 2
void
rf_PrintNodeInfoString(RF_DagNode_t *node)
d302 7
a308 7
	int (*df) (RF_DagNode_t *) = node->doFunc;
	int i, lk, unlk;
	void *bufPtr;

	if ((df == rf_DiskReadFunc) || (df == rf_DiskWriteFunc) ||
	    (df == rf_DiskReadMirrorIdleFunc) ||
	    (df == rf_DiskReadMirrorPartitionFunc)) {
d314 3
a316 3
		printf("r %d c %d offs %ld nsect %d buf 0x%lx %s\n", pda->row,
		    pda->col, (long) pda->startSector, (int) pda->numSector,
		    (long) bufPtr, (lk) ? "LOCK" : ((unlk) ? "UNLK" : " "));
d340 1
a340 1
#if	RF_INCLUDE_PARITYLOGGING > 0
d351 1
a351 1
#endif	/* RF_INCLUDE_PARITYLOGGING > 0 */
d360 5
a364 2
void
rf_RecurPrintDAG(RF_DagNode_t *node, int depth, int unvisited)
d366 2
a367 2
	char *anttype;
	int i;
d371 3
a373 5
	    node->nodeNum, node->commitNode, node->name,
	    rf_NodeStatusString(node), node->numSuccedents,
	    node->numSuccFired, node->numSuccDone,
	    node->numAntecedents, node->numAntDone,
	    node->numParams, node->numResults);
d397 1
a397 2
		printf("%d(%s)%s", node->antecedents[i]->nodeNum, anttype,
		    (i == node->numAntecedents - 1) ? "\0" : " ");
d403 1
a403 2
			rf_RecurPrintDAG(node->succedents[i], depth + 1,
			    unvisited);
d407 3
a409 2
void
rf_PrintDAG(RF_DagHeader_t *dag_h)
d411 2
a412 2
	int unvisited, i;
	char *status;
d414 1
a414 1
	/* Set dag status. */
d426 1
a426 1
		status = "illegal !";
d429 1
a429 1
	/* Find out if visited bits are currently set or cleared. */
d433 1
a433 2
	printf("format is (depth) num commit type: status,nSucc nSuccFired/n"
	    "SuccDone,nAnte/nAnteDone,nParam,nResult S{x} A{x(type)};  info\n");
d435 1
a435 2
	    status, dag_h->numSuccedents, dag_h->numCommitNodes,
	    dag_h->numCommits);
d446 3
a448 4

/* Assign node numbers. */
int
rf_AssignNodeNums(RF_DagHeader_t *dag_h)
d450 1
a450 1
	int unvisited, i, nnum;
d460 1
a460 2
			nnum = rf_RecurAssignNodeNums(dag_h->succedents[i],
			    nnum, unvisited);
d466 5
a470 2
int
rf_RecurAssignNodeNums(RF_DagNode_t *node, int num, int unvisited)
d472 1
a472 1
	int i;
d479 1
a479 2
			num = rf_RecurAssignNodeNums(node->succedents[i],
			    num, unvisited);
d484 5
a488 4

/* Set the header pointers in each node to "newptr". */
void
rf_ResetDAGHeaderPointers(RF_DagHeader_t *dag_h, RF_DagHeader_t *newptr)
d490 1
a490 2
	int i;

d493 1
a493 2
			rf_RecurResetDAGHeaderPointers(dag_h->succedents[i],
			    newptr);
d496 4
a499 2
void
rf_RecurResetDAGHeaderPointers(RF_DagNode_t *node, RF_DagHeader_t *newptr)
d501 1
a501 2
	int i;

d505 1
a505 2
			rf_RecurResetDAGHeaderPointers(node->succedents[i],
			    newptr);
d508 3
a510 2
void
rf_PrintDAGList(RF_DagHeader_t *dag_h)
d512 1
a512 1
	int i = 0;
d521 7
a527 3
int
rf_ValidateBranch(RF_DagNode_t *node, int *scount, int *acount,
    RF_DagNode_t **nodes, int unvisited)
d529 1
a529 1
	int i, retcode = 0;
d531 1
a531 1
	/* Construct an array of node pointers indexed by node num. */
d536 1
a536 1
		printf("INVALID DAG: next pointer in node is not NULL.\n");
d540 1
a540 1
		printf("INVALID DAG: Node status is not wait.\n");
d544 1
a544 1
		printf("INVALID DAG: numAntDone is not zero.\n");
d549 1
a549 2
			printf("INVALID DAG: Terminator node has"
			    " succedents.\n");
d554 1
a554 2
			printf("INVALID DAG: Non-terminator node has no"
			    " succedents\n");
d560 1
a560 2
			printf("INVALID DAG: succedent %d of node %s"
			    " is NULL.\n", i, node->name);
d567 1
a567 2
			printf("INVALID DAG: antecedent %d of node %s is"
			    " NULL.\n", i, node->name);
d583 5
a587 2
void
rf_ValidateBranchVisitedBits(RF_DagNode_t *node, int unvisited, int rl)
d589 1
a589 1
	int i;
d594 1
a594 2
			printf("node=%lx node->succedents[%d] is NULL.\n",
			    (long) node, i);
d597 1
a597 2
		rf_ValidateBranchVisitedBits(node->succedents[i],
		    unvisited, rl + 1);
d600 2
a601 4

/*
 * NOTE:  Never call this on a big dag, because it is exponential
 * in execution time.
d603 3
a605 2
void
rf_ValidateVisitedBits(RF_DagHeader_t *dag)
d607 1
a607 1
	int i, unvisited;
d613 1
a613 2
			printf("dag=%lx dag->succedents[%d] is NULL.\n",
			    (long) dag, i);
d619 1
a619 3

/*
 * Validate a DAG. _at entry_ verify that:
d633 1
a633 1
 *   -- what else ?
d635 10
a644 9
int
rf_ValidateDAG(RF_DagHeader_t *dag_h)
{
	int i, nodecount;
	int *scount, *acount;	/* Per-node successor and antecedent counts. */
	RF_DagNode_t **nodes;	/* Array of ptrs to nodes in dag. */
	int retcode = 0;
	int unvisited;
	int commitNodeCount = 0;
d650 1
a650 2
		printf("INVALID DAG: num nodes completed is %d, should be 0.\n",
		    dag_h->numNodesCompleted);
d655 1
a655 1
		printf("INVALID DAG: not enabled.\n");
d660 1
a660 2
		printf("INVALID DAG: numCommits != 0 (%d)\n",
		    dag_h->numCommits);
d665 2
a666 3
		/* Currently, all dags must have only one succedent. */
		printf("INVALID DAG: numSuccedents != 1 (%d).\n",
		    dag_h->numSuccedents);
d684 1
a684 1
	/* Start at 1 to skip the header node. */
d689 1
a689 2
			printf("INVALID DAG: node %s has an undefined"
			    " doFunc.\n", nodes[i]->name);
d694 1
a694 2
			printf("INVALID DAG: node %s has an undefined"
			    " doFunc.\n", nodes[i]->name);
d699 2
a700 4
			printf("INVALID DAG: node %s has %d antecedents but"
			    " appears as a succedent %d times.\n",
			    nodes[i]->name, nodes[i]->numAntecedents,
			    scount[nodes[i]->nodeNum]);
d705 2
a706 4
			printf("INVALID DAG: node %s has %d succedents but"
			    " appears as an antecedent %d times.\n",
			    nodes[i]->name, nodes[i]->numSuccedents,
			    acount[nodes[i]->nodeNum]);
d713 1
a713 3
		printf("INVALID DAG: incorrect commit node count. "
		    "hdr->numCommitNodes (%d) found (%d) commit nodes"
		    " in graph.\n",
a717 1

d736 1
a736 1
/*****************************************************************************
d738 1
a738 1
 * Misc construction routines.
d742 10
a751 8
void
rf_redirect_asm(RF_Raid_t *raidPtr, RF_AccessStripeMap_t *asmap)
{
	int ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) ? 1 : 0;
	int row = asmap->physInfo->row;
	int fcol = raidPtr->reconControl[row]->fcol;
	int srow = raidPtr->reconControl[row]->spareRow;
	int scol = raidPtr->reconControl[row]->spareCol;
d758 2
a759 3
				if (!rf_CheckRUReconstructed(
				    raidPtr->reconControl[row]->reconMap,
				    pda->startSector)) {
d763 1
a763 1
			/*printf("Remapped data for large write\n");*/
d765 2
a766 3
				raidPtr->Layout.map->MapSector(raidPtr,
				    pda->raidAddress, &pda->row, &pda->col,
				    &pda->startSector, RF_REMAP);
d776 1
a776 3
				if (!rf_CheckRUReconstructed(
				    raidPtr->reconControl[row]->reconMap,
				    pda->startSector)) {
d782 1
a782 3
			(raidPtr->Layout.map->MapParity) (raidPtr,
			    pda->raidAddress, &pda->row, &pda->col,
			    &pda->startSector, RF_REMAP);
d791 1
a791 2
/*
 * This routine allocates read buffers and generates stripe maps for the
d793 1
a793 1
 * access, and from the end of the access to the end of the stripe. It also
d799 1
a799 1
void
d801 11
a811 16
	RF_Raid_t		 *raidPtr,
	RF_RaidLayout_t		 *layoutPtr,	/* in: layout information */
	RF_AccessStripeMap_t	 *asmap,	/* in: access stripe map */
	RF_DagHeader_t		 *dag_h,	/* in: header of the dag */
						/*     to create */
	RF_AccessStripeMapHeader_t **new_asm_h,	/* in: ptr to array of 2 */
						/*     headers, to be */
						/*     filled in */
	int			 *nRodNodes,	/* out: num nodes to be */
						/*      generated to read */
						/*      unaccessed data */
	char			**sosBuffer,	/* out: pointers to newly */
						/*      allocated buffer */
	char			**eosBuffer,
	RF_AllocListElem_t	 *allocList
)
d817 2
a818 4
	/*
	 * Generate an access map for the region of the array from start of
	 * stripe to start of access.
	 */
d822 1
a822 2
		sosRaidAddress = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
		    asmap->raidAddress);
d824 2
a825 4
		RF_MallocAndAdd(*sosBuffer, rf_RaidAddressToByte(raidPtr,
		    sosNumSector), (char *), allocList);
		new_asm_h[0] = rf_MapAccess(raidPtr, sosRaidAddress,
		    sosNumSector, *sosBuffer, RF_DONT_REMAP);
d831 1
a831 1
		/* We're totally within one stripe here. */
d835 2
a836 4
	/*
	 * Generate an access map for the region of the array from end of
	 * access to end of stripe.
	 */
d839 3
a841 6
		eosNumSector = rf_RaidAddressOfNextStripeBoundary(layoutPtr,
		    eosRaidAddress) - eosRaidAddress;
		RF_MallocAndAdd(*eosBuffer, rf_RaidAddressToByte(raidPtr,
		    eosNumSector), (char *), allocList);
		new_asm_h[1] = rf_MapAccess(raidPtr, eosRaidAddress,
		    eosNumSector, *eosBuffer, RF_DONT_REMAP);
d847 1
a847 1
		/* We're totally within one stripe here. */
a853 16
/* Returns non-zero if the indicated ranges of stripe unit offsets overlap. */
int
rf_PDAOverlap(RF_RaidLayout_t *layoutPtr, RF_PhysDiskAddr_t *src,
    RF_PhysDiskAddr_t *dest)
{
	RF_SectorNum_t soffs =
	    rf_StripeUnitOffset(layoutPtr, src->startSector);
	RF_SectorNum_t doffs =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector);
	/* Use -1 to be sure we stay within SU. */
	RF_SectorNum_t send =
	    rf_StripeUnitOffset(layoutPtr, src->startSector +
	    src->numSector - 1);
	RF_SectorNum_t dend =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector +
	    dest->numSector - 1);
d855 12
d871 1
a871 2
/*
 * GenerateFailedAccessASMs
d873 2
a874 2
 * This routine figures out what portion of the stripe needs to be read
 * to effect the degraded read or write operation. It's primary function
d880 5
a884 5
 * the access to the end of the stripe. These ASMs describe everything that
 * needs to be read to effect the degraded access. Other results are:
 *    nXorBufs -- The total number of buffers that need to be XORed together
 *		  to recover the lost data,
 *    rpBufPtr -- Ptr to a newly-allocated buffer to hold the parity. If NULL
d887 1
a887 1
 *                Describes which of the non-failed PDAs, in the user access,
d890 1
a890 1
 *                PDA, the i'th pda in the input asm overlaps data that needs
d893 7
a899 7
 /* in: asmap - ASM for the actual access, one stripe only. */
 /* in: faildPDA - Which component of the access has failed. */
 /* in: dag_h - Header of the DAG we're going to create. */
 /* out: new_asm_h - The two new ASMs. */
 /* out: nXorBufs - The total number of xor bufs required. */
 /* out: rpBufPtr - A buffer for the parity read. */
void
d901 9
a909 10
	RF_Raid_t		 *raidPtr,
	RF_AccessStripeMap_t	 *asmap,
	RF_PhysDiskAddr_t	 *failedPDA,
	RF_DagHeader_t		 *dag_h,
	RF_AccessStripeMapHeader_t **new_asm_h,
	int			 *nXorBufs,
	char			**rpBufPtr,
	char			 *overlappingPDAs,
	RF_AllocListElem_t	 *allocList
)
d918 2
a919 2
	char *rdBuf, *bufP;
	int foundit, i;
d923 18
a940 36
	/*
	 * First compute the following raid addresses:
	 * - Start of stripe
	 * - (sosAddr) MIN(start of access, start of failed SU)
	 * - (sosEndAddr) MAX(end of access, end of failed SU)
	 * - (eosStartAddr) end of stripe (i.e. start of next stripe)
	 *   (eosAddr)
	 */
	sosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr,
	    asmap->raidAddress);
	sosEndAddr = RF_MIN(asmap->raidAddress,
	    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
	    failedPDA->raidAddress));
	eosStartAddr = RF_MAX(asmap->endRaidAddress,
	    rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr,
	    failedPDA->raidAddress));
	eosAddr = rf_RaidAddressOfNextStripeBoundary(layoutPtr,
	    asmap->raidAddress);

	/*
	 * Now generate access stripe maps for each of the above regions of
	 * the stripe. Use a dummy (NULL) buf ptr for now.
	 */

	new_asm_h[0] = (sosAddr != sosEndAddr) ?
	    rf_MapAccess(raidPtr, sosAddr, sosEndAddr - sosAddr, NULL,
	    RF_DONT_REMAP) : NULL;
	new_asm_h[1] = (eosStartAddr != eosAddr) ?
	    rf_MapAccess(raidPtr, eosStartAddr, eosAddr - eosStartAddr, NULL,
	    RF_DONT_REMAP) : NULL;

	/*
	 * Walk through the PDAs and range-restrict each SU to the region of
	 * the SU touched on the failed PDA. Also compute total data buffer
	 * space requirements in this step. Ignore the parity for now.
	 */
d946 2
a947 4
		for (pda = new_asm_h[0]->stripeMap->physInfo; pda;
		     pda = pda->next) {
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda,
			    RF_RESTRICT_NOBUFFER, 0);
d954 2
a955 4
		for (pda = new_asm_h[1]->stripeMap->physInfo;
		     pda; pda = pda->next) {
			rf_RangeRestrictPDA(raidPtr, failedPDA, pda,
			    RF_RESTRICT_NOBUFFER, 0);
d961 6
a966 10
	/*
	 * Allocate buffer space for the data & parity we have to read to
	 * recover from the failure.
	 */

	if (numSect[0] + numSect[1] + ((rpBufPtr) ? numParitySect : 0)) {
		/* Don't allocate parity buf if not needed. */
		RF_MallocAndAdd(rdBuf, rf_RaidAddressToByte(raidPtr,
		    numSect[0] + numSect[1] + numParitySect), (char *),
		    allocList);
d970 1
a970 3
			    (int) rf_RaidAddressToByte(raidPtr,
			    numSect[0] + numSect[1] + numParitySect),
			    (unsigned long) bufP);
d972 5
a976 7
	/*
	 * Now walk through the pdas one last time and assign buffer pointers
	 * (ugh!). Again, ignore the parity. Also, count nodes to find out
	 * how many bufs need to be xored together.
	 */
	(*nXorBufs) = 1;	/* In read case, 1 is for parity. */
				/* In write case, 1 is for failed data. */
d978 1
a978 2
		for (pda = new_asm_h[0]->stripeMap->physInfo; pda;
		     pda = pda->next) {
d985 1
a985 2
		for (pda = new_asm_h[1]->stripeMap->physInfo; pda;
		     pda = pda->next) {
d992 2
a993 2
		/* The rest of the buffer is for parity. */
		*rpBufPtr = bufP;
d995 2
a996 3
	/*
	 * The last step is to figure out how many more distinct buffers need
	 * to get xor'd to produce the missing unit. there's one for each
d998 1
a998 2
	 * being accessed.
	 */
d1000 1
a1000 2
	for (foundit = i = 0, pda = asmap->physInfo;
	     pda; i++, pda = pda->next) {
d1012 1
a1012 2
		RF_ERRORMSG("GenerateFailedAccessASMs: did not find failedPDA"
		    " in asm list.\n");
d1028 2
a1029 3
/*
 * Adjust the offset and number of sectors in the destination pda so that
 * it covers at most the region of the SU covered by the source PDA. This
d1050 7
a1056 3
void
rf_RangeRestrictPDA(RF_Raid_t *raidPtr, RF_PhysDiskAddr_t *src,
    RF_PhysDiskAddr_t *dest, int dobuffer, int doraidaddr)
d1059 6
a1064 13
	RF_SectorNum_t soffs =
	    rf_StripeUnitOffset(layoutPtr, src->startSector);
	RF_SectorNum_t doffs =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector);
	RF_SectorNum_t send =
	    rf_StripeUnitOffset(layoutPtr, src->startSector +
	    src->numSector - 1); /* Use -1 to be sure we stay within SU. */
	RF_SectorNum_t dend =
	    rf_StripeUnitOffset(layoutPtr, dest->startSector +
	    dest->numSector - 1);
	RF_SectorNum_t subAddr =
	    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
	    dest->startSector); /* Stripe unit boundary. */
d1070 1
a1070 2
		dest->bufPtr += (soffs > doffs) ?
		    rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;
d1072 1
a1072 3
		dest->raidAddress =
		    rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,
		    dest->raidAddress) +
a1075 1

d1082 1
a1082 1
#define	NLOWPRIMES	8
a1083 1

d1085 1
a1085 1
 * Compute the workload shift factor. (chained declustering)
d1087 2
a1088 2
 * Return nonzero if access should shift to secondary, otherwise,
 * access is to primary.
d1090 4
a1093 2
int
rf_compute_workload_shift(RF_Raid_t *raidPtr, RF_PhysDiskAddr_t *pda)
d1096 8
a1103 9
         * Variables:
         *  d   = Column of disk containing primary.
         *  f   = Column of failed disk.
         *  n   = Number of disks in array.
         *  sd  = "shift distance"
	 *	  (number of columns that d is to the right of f).
         *  row = Row of array the access is in.
         *  v   = Numerator of redirection ratio.
         *  k   = Denominator of redirection ratio.
d1106 1
a1106 1
	int k, v, ret, i;
d1111 1
a1111 1
	/* Assign column of primary copy to d. */
d1114 2
a1115 3
	/* Assign column of dead disk to f. */
	for (f = 0; ((!RF_DEAD_DISK(raidPtr->Disks[row][f].status)) &&
	     (f < n)); f++);
d1124 1
a1124 1
         * v of every k accesses should be redirected.
d1134 1
a1134 1
         * Is this worth it ?
d1137 1
a1137 1
         * out primes (just like they teach in elementary school !).
d1151 1
a1151 1
		ret = 0;	/* Do not redirect. */
d1153 1
a1153 1
		ret = 1;	/* Redirect. */
d1162 1
a1162 1
		/* Reset counter. */
a1166 1

d1168 1
a1168 1
 * Disk selection routines.
d1172 1
a1172 1
 * Select the disk with the shortest queue from a mirror pair.
d1174 1
a1174 1
 * disk are counted as members of the "queue".
d1176 2
a1177 2
void
rf_SelectMirrorDiskIdle(RF_DagNode_t *node)
d1181 1
a1181 1
	int dataQueueLength, mirrorQueueLength, usemirror;
d1188 1
a1188 1
	/* Return the [row col] of the disk with the shortest queue. */
d1196 1
a1196 1
#ifdef	RF_LOCK_QUEUES_TO_READ_LEN
d1198 1
a1198 1
#endif	/* RF_LOCK_QUEUES_TO_READ_LEN */
d1200 1
a1200 1
#ifdef	RF_LOCK_QUEUES_TO_READ_LEN
d1203 3
a1205 4
#endif	/* RF_LOCK_QUEUES_TO_READ_LEN */
	mirrorQueueLength = mirrorQueue->queueLength +
	    mirrorQueue->numOutstanding;
#ifdef	RF_LOCK_QUEUES_TO_READ_LEN
d1207 1
a1207 1
#endif	/* RF_LOCK_QUEUES_TO_READ_LEN */
d1217 1
a1217 1
				/* Trust only the main disk. */
d1226 4
a1229 8
					/* Queues are equal length. */
					/* Attempt cleverness. */
					if (SNUM_DIFF(dataQueue
					    ->last_deq_sector, data_pda
					    ->startSector) <=
					    SNUM_DIFF(mirrorQueue
					    ->last_deq_sector, mirror_pda
					    ->startSector)) {
d1237 1
a1237 1
		/* Use mirror (parity) disk, swap params 0 & 4. */
d1242 1
a1242 1
		/* Use data disk, leave param 0 unchanged. */
d1244 2
a1245 2
	/*printf("dataQueueLength %d, mirrorQueueLength %d\n", dataQueueLength,
	    mirrorQueueLength);*/
a1246 1

d1251 2
a1252 2
void
rf_SelectMirrorDiskPartition(RF_DagNode_t *node)
d1261 1
a1261 1
	int usemirror;
d1263 1
a1263 1
	/* Return the [row col] of the disk with the shortest queue. */
d1277 1
a1277 1
		} else
d1279 1
a1279 1
				/* Trust only the main disk. */
d1282 1
a1282 1
				if (data_pda->startSector <
d1290 1
a1290 1
		/* Use mirror (parity) disk, swap params 0 & 4. */
d1295 1
a1295 1
		/* Use data disk, leave param 0 unchanged. */
@


1.2
log
@Merge from NetBSD, mostly indentation
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagutils.c,v 1.1 1999/01/11 14:29:11 niklas Exp $	*/
/*	$NetBSD: rf_dagutils.c,v 1.3 1999/02/05 00:06:08 oster Exp $	*/
a46 1
#include "rf_sys.h"
d1216 4
d1277 4
d1282 2
a1283 1
			if (data_pda->startSector < (disks[rowData][colData].numBlocks / 2)) {
@


1.1
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: rf_dagutils.c,v 1.1 1998/11/13 04:20:28 oster Exp $	*/
/*	$NetBSD: rf_dagutils.c,v 1.1 1998/11/13 04:20:28 oster Exp $	*/
a35 151
/*
 * :  
 * Log: rf_dagutils.c,v 
 * Revision 1.55  1996/08/22 14:39:47  jimz
 * reduce v/k fraction (better load balancing)
 *
 * Revision 1.54  1996/08/21  04:14:12  jimz
 * minor workload shift tweaking
 *
 * Revision 1.53  1996/08/20  23:41:16  jimz
 * fix up workload shift computation
 *
 * Revision 1.52  1996/08/20  22:34:16  jimz
 * first cut at fixing workload shift
 * needs work
 *
 * Revision 1.51  1996/08/20  16:51:16  jimz
 * comment more verbosely compute_workload_shift()
 *
 * Revision 1.50  1996/08/11  00:40:50  jimz
 * fix up broken comment
 *
 * Revision 1.49  1996/07/27  23:36:08  jimz
 * Solaris port of simulator
 *
 * Revision 1.48  1996/07/27  18:40:01  jimz
 * cleanup sweep
 *
 * Revision 1.47  1996/07/22  19:52:16  jimz
 * switched node params to RF_DagParam_t, a union of
 * a 64-bit int and a void *, for better portability
 * attempted hpux port, but failed partway through for
 * lack of a single C compiler capable of compiling all
 * source files
 *
 * Revision 1.46  1996/07/18  22:57:14  jimz
 * port simulator to AIX
 *
 * Revision 1.45  1996/06/17  03:24:59  jimz
 * include shutdown.h for define of now-macroized ShutdownCreate
 *
 * Revision 1.44  1996/06/10  12:50:57  jimz
 * Add counters to freelists to track number of allocations, frees,
 * grows, max size, etc. Adjust a couple sets of PRIME params based
 * on the results.
 *
 * Revision 1.43  1996/06/10  11:55:47  jimz
 * Straightened out some per-array/not-per-array distinctions, fixed
 * a couple bugs related to confusion. Added shutdown lists. Removed
 * layout shutdown function (now subsumed by shutdown lists).
 *
 * Revision 1.42  1996/06/07  21:33:04  jimz
 * begin using consistent types for sector numbers,
 * stripe numbers, row+col numbers, recon unit numbers
 *
 * Revision 1.41  1996/06/06  17:28:58  jimz
 * make PrintNodeInfoString aware of new mirroring funcs
 *
 * Revision 1.40  1996/06/05  18:06:02  jimz
 * Major code cleanup. The Great Renaming is now done.
 * Better modularity. Better typing. Fixed a bunch of
 * synchronization bugs. Made a lot of global stuff
 * per-desc or per-array. Removed dead code.
 *
 * Revision 1.39  1996/06/03  23:28:26  jimz
 * more bugfixes
 * check in tree to sync for IPDS runs with current bugfixes
 * there still may be a problem with threads in the script test
 * getting I/Os stuck- not trivially reproducible (runs ~50 times
 * in a row without getting stuck)
 *
 * Revision 1.38  1996/06/02  17:31:48  jimz
 * Moved a lot of global stuff into array structure, where it belongs.
 * Fixed up paritylogging, pss modules in this manner. Some general
 * code cleanup. Removed lots of dead code, some dead files.
 *
 * Revision 1.37  1996/05/31  22:26:54  jimz
 * fix a lot of mapping problems, memory allocation problems
 * found some weird lock issues, fixed 'em
 * more code cleanup
 *
 * Revision 1.36  1996/05/30  23:22:16  jimz
 * bugfixes of serialization, timing problems
 * more cleanup
 *
 * Revision 1.35  1996/05/30  11:29:41  jimz
 * Numerous bug fixes. Stripe lock release code disagreed with the taking code
 * about when stripes should be locked (I made it consistent: no parity, no lock)
 * There was a lot of extra serialization of I/Os which I've removed- a lot of
 * it was to calculate values for the cache code, which is no longer with us.
 * More types, function, macro cleanup. Added code to properly quiesce the array
 * on shutdown. Made a lot of stuff array-specific which was (bogusly) general
 * before. Fixed memory allocation, freeing bugs.
 *
 * Revision 1.34  1996/05/27  18:56:37  jimz
 * more code cleanup
 * better typing
 * compiles in all 3 environments
 *
 * Revision 1.33  1996/05/24  22:17:04  jimz
 * continue code + namespace cleanup
 * typed a bunch of flags
 *
 * Revision 1.32  1996/05/24  04:28:55  jimz
 * release cleanup ckpt
 *
 * Revision 1.31  1996/05/23  21:46:35  jimz
 * checkpoint in code cleanup (release prep)
 * lots of types, function names have been fixed
 *
 * Revision 1.30  1996/05/23  00:33:23  jimz
 * code cleanup: move all debug decls to rf_options.c, all extern
 * debug decls to rf_options.h, all debug vars preceded by rf_
 *
 * Revision 1.29  1996/05/18  19:51:34  jimz
 * major code cleanup- fix syntax, make some types consistent,
 * add prototypes, clean out dead code, et cetera
 *
 * Revision 1.28  1996/05/16  23:05:52  jimz
 * changed InitNode() to use dag_ptrs field of node when appropriate
 * (see rf_dag.h or comments within InitNode() for details)
 *
 * Revision 1.27  1996/05/16  15:37:19  jimz
 * convert to RF_FREELIST stuff for dag headers
 *
 * Revision 1.26  1996/05/08  21:01:24  jimz
 * fixed up enum type names that were conflicting with other
 * enums and function names (ie, "panic")
 * future naming trends will be towards RF_ and rf_ for
 * everything raidframe-related
 *
 * Revision 1.25  1996/05/03  19:56:15  wvcii
 * added misc routines from old dag creation files
 *
 * Revision 1.24  1995/12/12  18:10:06  jimz
 * MIN -> RF_MIN, MAX -> RF_MAX, ASSERT -> RF_ASSERT
 * fix 80-column brain damage in comments
 *
 * Revision 1.23  1995/12/01  15:59:50  root
 * added copyright info
 *
 * Revision 1.22  1995/11/17  15:14:12  wvcii
 * PrintDAG now processes DiskReadMirrorFunc nodes
 *
 * Revision 1.21  1995/11/07  16:22:38  wvcii
 * InitNode and InitNodeFromBuf now initialize commit fields
 * beefed up ValidateDag
 * prettied up PrintDAGList
 *
 */

d53 1
a53 1
	rf_SimpleXorFunc, "Simple Xr"};
d57 1
a57 1
	rf_RecoveryXorFunc, "Recovery Xr"};
d61 3
a63 2
static int rf_ValidateBranch(RF_DagNode_t *, int *, int *, 
			     RF_DagNode_t **, int );
d75 69
a143 71
void rf_InitNode(
  RF_DagNode_t         *node,
  RF_NodeStatus_t       initstatus,
  int                   commit,
  int                 (*doFunc)(RF_DagNode_t *node),
  int                 (*undoFunc)(RF_DagNode_t *node),
  int                 (*wakeFunc)(RF_DagNode_t *node,int status),
  int                   nSucc,
  int                   nAnte,
  int                   nParam,
  int                   nResult,
  RF_DagHeader_t       *hdr,
  char                 *name,
  RF_AllocListElem_t   *alist)
{
  void **ptrs;
  int nptrs;

  if (nAnte > RF_MAX_ANTECEDENTS)
    RF_PANIC();
  node->status         = initstatus;
  node->commitNode     = commit;
  node->doFunc         = doFunc;
  node->undoFunc       = undoFunc;
  node->wakeFunc       = wakeFunc;
  node->numParams      = nParam;
  node->numResults     = nResult;
  node->numAntecedents = nAnte;
  node->numAntDone     = 0;
  node->next           = NULL;
  node->numSuccedents  = nSucc;
  node->name           = name;
  node->dagHdr         = hdr;
  node->visited        = 0;

  /* allocate all the pointers with one call to malloc */
  nptrs = nSucc+nAnte+nResult+nSucc;
  
  if (nptrs <= RF_DAG_PTRCACHESIZE) {
    /*
     * The dag_ptrs field of the node is basically some scribble
     * space to be used here. We could get rid of it, and always
     * allocate the range of pointers, but that's expensive. So,
     * we pick a "common case" size for the pointer cache. Hopefully,
     * we'll find that:
     * (1) Generally, nptrs doesn't exceed RF_DAG_PTRCACHESIZE by
     *     only a little bit (least efficient case)
     * (2) Generally, ntprs isn't a lot less than RF_DAG_PTRCACHESIZE
     *     (wasted memory)
     */
    ptrs = (void **)node->dag_ptrs;
  }
  else {
    RF_CallocAndAdd(ptrs, nptrs, sizeof(void *), (void **), alist);
  }
  node->succedents  = (nSucc)   ? (RF_DagNode_t         **) ptrs                  : NULL;
  node->antecedents = (nAnte)   ? (RF_DagNode_t         **) (ptrs+nSucc)          : NULL;
  node->results     = (nResult) ? (void            **) (ptrs+nSucc+nAnte)         : NULL;
  node->propList    = (nSucc)   ? (RF_PropHeader_t **) (ptrs+nSucc+nAnte+nResult) : NULL;

  if (nParam) {
    if (nParam <= RF_DAG_PARAMCACHESIZE) {
      node->params = (RF_DagParam_t *)node->dag_params;
    }
    else {
      RF_CallocAndAdd(node->params, nParam, sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);
    }
  }
  else {
    node->params = NULL;
  }
d154 54
a207 52
void rf_FreeDAG(dag_h)
  RF_DagHeader_t  *dag_h;
{
  RF_AccessStripeMapHeader_t *asmap, *t_asmap;
  RF_DagHeader_t *nextDag;
  int i;

  while (dag_h) {
    nextDag = dag_h->next;
    for (i=0; dag_h->memChunk[i] && i < RF_MAXCHUNKS; i++) {
      /* release mem chunks */
      rf_ReleaseMemChunk(dag_h->memChunk[i]);
      dag_h->memChunk[i] = NULL;
    }
    
    RF_ASSERT(i == dag_h->chunkIndex);
    if (dag_h->xtraChunkCnt > 0) {
      /* free xtraMemChunks */
      for (i=0; dag_h->xtraMemChunk[i] && i < dag_h->xtraChunkIndex; i++) {
        rf_ReleaseMemChunk(dag_h->xtraMemChunk[i]);
        dag_h->xtraMemChunk[i] = NULL;
      }
      RF_ASSERT(i == dag_h->xtraChunkIndex);
      /* free ptrs to xtraMemChunks */
      RF_Free(dag_h->xtraMemChunk, dag_h->xtraChunkCnt * sizeof(RF_ChunkDesc_t *));
    }
    rf_FreeAllocList(dag_h->allocList);
    for (asmap = dag_h->asmList; asmap;) {
      t_asmap = asmap;
      asmap = asmap->next;
      rf_FreeAccessStripeMap(t_asmap);
    }
    rf_FreeDAGHeader(dag_h);
    dag_h = nextDag;
  }
}

RF_PropHeader_t *rf_MakePropListEntry(
  RF_DagHeader_t      *dag_h,
  int                  resultNum,
  int                  paramNum,
  RF_PropHeader_t     *next,
  RF_AllocListElem_t  *allocList)
{
  RF_PropHeader_t *p;

  RF_CallocAndAdd(p, 1, sizeof(RF_PropHeader_t),
    (RF_PropHeader_t *), allocList);
  p->resultNum = resultNum;
  p->paramNum = paramNum;
  p->next = next;
  return(p);
d217 3
a219 2
static void rf_ShutdownDAGs(ignored)
  void  *ignored;
d221 1
a221 1
	RF_FREELIST_DESTROY(rf_dagh_freelist,next,(RF_DagHeader_t *));
d224 3
a226 2
int rf_ConfigureDAGs(listp)
  RF_ShutdownList_t  **listp;
d228 1
a228 1
	int rc;
d231 1
a231 1
		RF_DAGH_INC, sizeof(RF_DagHeader_t));
d233 1
a233 1
		return(ENOMEM);
d237 1
a237 1
			__FILE__, __LINE__, rc);
d239 1
a239 1
		return(rc);
d241 3
a243 3
	RF_FREELIST_PRIME(rf_dagh_freelist, RF_DAGH_INITIAL,next,
		(RF_DagHeader_t *));
	return(0);
d246 2
a247 1
RF_DagHeader_t *rf_AllocDAGHeader()
d251 1
a251 1
	RF_FREELIST_GET(rf_dagh_freelist,dh,next,(RF_DagHeader_t *));
d253 1
a253 1
		bzero((char *)dh, sizeof(RF_DagHeader_t));
d255 1
a255 1
	return(dh);
d258 2
a259 1
void rf_FreeDAGHeader(RF_DagHeader_t *dh)
d261 1
a261 1
	RF_FREELIST_FREE(rf_dagh_freelist,dh,next);
a262 1

d264 12
a275 11
void *rf_AllocBuffer(
  RF_Raid_t           *raidPtr,
  RF_DagHeader_t      *dag_h,
  RF_PhysDiskAddr_t   *pda,
  RF_AllocListElem_t  *allocList)
{
  char *p;

  RF_MallocAndAdd(p, pda->numSector << raidPtr->logBytesPerSector,
    (char *), allocList);
  return((void *)p);
a276 1

d283 2
a284 1
char *rf_NodeStatusString(RF_DagNode_t *node)
d286 12
a297 54
  switch (node->status) {
    case rf_wait: return("wait");
    case rf_fired: return("fired");
    case rf_good: return("good");
    case rf_bad: return("bad");
    default: return("?");
  }
}

void rf_PrintNodeInfoString(RF_DagNode_t *node)
{
  RF_PhysDiskAddr_t *pda;
  int (*df)(RF_DagNode_t *) = node->doFunc;
  int i, lk, unlk;
  void *bufPtr;
  
  if ((df==rf_DiskReadFunc) || (df==rf_DiskWriteFunc)
      || (df==rf_DiskReadMirrorIdleFunc)
      || (df == rf_DiskReadMirrorPartitionFunc))
  {
    pda = (RF_PhysDiskAddr_t *)node->params[0].p;
    bufPtr = (void *)node->params[1].p;
    lk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);
    unlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);
    RF_ASSERT( !(lk && unlk) );
    printf("r %d c %d offs %ld nsect %d buf 0x%lx %s\n", pda->row, pda->col,
       (long)pda->startSector, (int) pda->numSector, (long)bufPtr,
       (lk) ? "LOCK" : ((unlk) ? "UNLK" : " "));
    return;
  }

  if (df == rf_DiskUnlockFunc) {
    pda = (RF_PhysDiskAddr_t *)node->params[0].p;
    lk = RF_EXTRACT_LOCK_FLAG(node->params[3].v);
    unlk = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);
    RF_ASSERT( !(lk && unlk) );
    printf("r %d c %d %s\n", pda->row, pda->col,
      (lk) ? "LOCK" : ((unlk) ? "UNLK" : "nop"));
    return;
  }

  if ((df==rf_SimpleXorFunc) || (df==rf_RegularXorFunc)
      || (df==rf_RecoveryXorFunc))
  {
    printf("result buf 0x%lx\n",(long) node->results[0]);
    for (i=0; i<node->numParams-1; i+=2) {
      pda = (RF_PhysDiskAddr_t *)node->params[i].p;
      bufPtr = (RF_PhysDiskAddr_t *)node->params[i+1].p;
      printf("    buf 0x%lx r%d c%d offs %ld nsect %d\n",
	     (long)bufPtr, pda->row, pda->col, 
	     (long)pda->startSector, (int)pda->numSector);
    }
    return;
  }
d299 42
d342 64
a405 103
  if (df==rf_ParityLogOverwriteFunc || df==rf_ParityLogUpdateFunc) {
    for (i=0; i<node->numParams-1; i+=2) {
      pda = (RF_PhysDiskAddr_t *)node->params[i].p;
      bufPtr = (RF_PhysDiskAddr_t *)node->params[i+1].p;
      printf(" r%d c%d offs %ld nsect %d buf 0x%lx\n", 
	     pda->row, pda->col, (long) pda->startSector, 
	     (int) pda->numSector, (long) bufPtr);
    }
    return;
  }
#endif /* RF_INCLUDE_PARITYLOGGING > 0 */

  if ((df==rf_TerminateFunc) || (df==rf_NullNodeFunc)) {
    printf("\n");
    return;
  }

  printf("?\n");
}

static void rf_RecurPrintDAG(node, depth, unvisited)
  RF_DagNode_t  *node;
  int            depth;
  int            unvisited;
{
  char *anttype;
  int i;

  node->visited = (unvisited) ? 0 : 1;
  printf("(%d) %d C%d %s: %s,s%d %d/%d,a%d/%d,p%d,r%d S{", depth,
    node->nodeNum, node->commitNode, node->name, rf_NodeStatusString(node),
    node->numSuccedents, node->numSuccFired, node->numSuccDone, 
	node->numAntecedents, node->numAntDone, node->numParams,node->numResults);
  for (i=0; i<node->numSuccedents; i++) {
    printf("%d%s", node->succedents[i]->nodeNum,
      ((i==node->numSuccedents-1) ? "\0" : " "));
  }
  printf("} A{");
  for (i=0; i<node->numAntecedents; i++) {
    switch (node->antType[i]) {
    case rf_trueData :
      anttype = "T";
      break;
    case rf_antiData :
      anttype = "A";
      break;
    case rf_outputData :
      anttype = "O";
      break;
    case rf_control :
      anttype = "C";
      break;
    default :
      anttype = "?";
      break;
    }
    printf("%d(%s)%s", node->antecedents[i]->nodeNum, anttype, (i==node->numAntecedents-1) ? "\0" : " ");
  }
  printf("}; ");
  rf_PrintNodeInfoString(node);
  for (i=0; i<node->numSuccedents; i++) {
    if (node->succedents[i]->visited == unvisited)
      rf_RecurPrintDAG(node->succedents[i], depth+1, unvisited);
  }
}

static void rf_PrintDAG(dag_h)
  RF_DagHeader_t  *dag_h;
{
  int unvisited, i;
  char *status;

  /* set dag status */
  switch (dag_h->status) {
  case rf_enable :
    status = "enable";
    break;
  case rf_rollForward :
    status = "rollForward";
    break;
  case rf_rollBackward :
    status = "rollBackward";
    break;
  default :
    status = "illegal!";
    break;
  }
  /* find out if visited bits are currently set or clear */
  unvisited = dag_h->succedents[0]->visited;
  
  printf("DAG type:  %s\n", dag_h->creator);
  printf("format is (depth) num commit type: status,nSucc nSuccFired/nSuccDone,nAnte/nAnteDone,nParam,nResult S{x} A{x(type)};  info\n");
  printf("(0) %d Hdr: %s, s%d, (commit %d/%d) S{", dag_h->nodeNum,
    status, dag_h->numSuccedents, dag_h->numCommitNodes, dag_h->numCommits);
  for (i=0; i<dag_h->numSuccedents; i++) {
    printf("%d%s", dag_h->succedents[i]->nodeNum,
      ((i==dag_h->numSuccedents-1) ? "\0" : " "));
  }
  printf("};\n");
  for (i=0; i<dag_h->numSuccedents; i++) {
    if (dag_h->succedents[i]->visited == unvisited)
      rf_RecurPrintDAG(dag_h->succedents[i], 1, unvisited);
  }
d408 39
d448 2
a449 1
int rf_AssignNodeNums(RF_DagHeader_t *dag_h)
d451 5
a455 2
  int unvisited, i, nnum;
  RF_DagNode_t *node;
d457 8
a464 29
  nnum = 0;
  unvisited = dag_h->succedents[0]->visited;
  
  dag_h->nodeNum = nnum++;
  for (i=0; i<dag_h->numSuccedents; i++) {
    node = dag_h->succedents[i];
    if (node->visited == unvisited) {
      nnum = rf_RecurAssignNodeNums(dag_h->succedents[i], nnum, unvisited);
    }
  }
  return(nnum);
}

int rf_RecurAssignNodeNums(node, num, unvisited)
  RF_DagNode_t  *node;
  int            num;
  int            unvisited;
{
  int i;

  node->visited = (unvisited) ? 0 : 1;

  node->nodeNum = num++;
  for (i=0; i<node->numSuccedents; i++) {
    if (node->succedents[i]->visited == unvisited) {
      num = rf_RecurAssignNodeNums(node->succedents[i], num, unvisited);
    }
  }
  return(num);
d467 18
d486 9
a494 110
void rf_ResetDAGHeaderPointers(dag_h, newptr)
  RF_DagHeader_t  *dag_h;
  RF_DagHeader_t  *newptr;
{
  int i;
  for (i=0; i<dag_h->numSuccedents; i++)
    if (dag_h->succedents[i]->dagHdr != newptr)
      rf_RecurResetDAGHeaderPointers(dag_h->succedents[i], newptr);
}

void rf_RecurResetDAGHeaderPointers(node, newptr)
  RF_DagNode_t    *node;
  RF_DagHeader_t  *newptr;
{
  int i;
  node->dagHdr = newptr;
  for (i=0; i<node->numSuccedents; i++)
    if (node->succedents[i]->dagHdr != newptr)
      rf_RecurResetDAGHeaderPointers(node->succedents[i], newptr);
}


void rf_PrintDAGList(RF_DagHeader_t *dag_h)
{
  int i=0;

  for (; dag_h; dag_h=dag_h->next) {
    rf_AssignNodeNums(dag_h);
    printf("\n\nDAG %d IN LIST:\n",i++);
    rf_PrintDAG(dag_h);
  }
}

static int rf_ValidateBranch(node, scount, acount, nodes, unvisited)
  RF_DagNode_t   *node;
  int            *scount;
  int            *acount;
  RF_DagNode_t  **nodes;
  int             unvisited;
{
  int i, retcode = 0;

  /* construct an array of node pointers indexed by node num */
  node->visited = (unvisited) ? 0 : 1;
  nodes[ node->nodeNum ] = node;

  if (node->next != NULL) {
    printf("INVALID DAG: next pointer in node is not NULL\n");
    retcode = 1;
  }
  if (node->status != rf_wait) {
    printf("INVALID DAG: Node status is not wait\n");
    retcode = 1;
  }
  if (node->numAntDone != 0) {
    printf("INVALID DAG: numAntDone is not zero\n");
    retcode = 1;
  }
  if (node->doFunc == rf_TerminateFunc) {
    if (node->numSuccedents != 0) {
      printf("INVALID DAG: Terminator node has succedents\n");
      retcode = 1;
    }
  } else {
    if (node->numSuccedents == 0) {
      printf("INVALID DAG: Non-terminator node has no succedents\n");
      retcode = 1;
    }
  }
  for (i=0; i<node->numSuccedents; i++)  {
    if (!node->succedents[i]) {
      printf("INVALID DAG: succedent %d of node %s is NULL\n",i,node->name);
      retcode = 1;
    }
    scount[ node->succedents[i]->nodeNum ]++;
  }
  for (i=0; i<node->numAntecedents; i++) {
    if (!node->antecedents[i]) {
      printf("INVALID DAG: antecedent %d of node %s is NULL\n",i,node->name);
      retcode = 1;
    }
    acount[ node->antecedents[i]->nodeNum ]++;
  }
  for (i=0; i<node->numSuccedents; i++) {
    if (node->succedents[i]->visited == unvisited) {
      if (rf_ValidateBranch(node->succedents[i], scount,
          acount, nodes, unvisited))
      {
        retcode = 1;
      }
    }
  }
  return(retcode);
}

static void rf_ValidateBranchVisitedBits(node, unvisited, rl)
  RF_DagNode_t  *node;
  int            unvisited;
  int            rl;
{
  int i;

  RF_ASSERT(node->visited == unvisited);
  for (i=0; i<node->numSuccedents; i++) {
    if (node->succedents[i] == NULL) {
      printf("node=%lx node->succedents[%d] is NULL\n", (long)node, i);
      RF_ASSERT(0);
    }
    rf_ValidateBranchVisitedBits(node->succedents[i],unvisited, rl+1);
  }
d497 4
a500 5
/* NOTE:  never call this on a big dag, because it is exponential
 * in execution time
 */
static void rf_ValidateVisitedBits(dag)
  RF_DagHeader_t  *dag;
d502 7
a508 1
  int i, unvisited;
d510 4
a513 1
  unvisited = dag->succedents[0]->visited;
d515 5
a519 7
  for (i=0; i<dag->numSuccedents; i++) {
    if (dag->succedents[i] == NULL) {
      printf("dag=%lx dag->succedents[%d] is NULL\n", (long) dag, i);
      RF_ASSERT(0);
    }
    rf_ValidateBranchVisitedBits(dag->succedents[i],unvisited,0);
  }
d522 98
d636 76
a711 79
int rf_ValidateDAG(dag_h)
  RF_DagHeader_t  *dag_h;
{
  int i, nodecount;
  int *scount, *acount;        /* per-node successor and antecedent counts */
  RF_DagNode_t **nodes;        /* array of ptrs to nodes in dag */
  int retcode = 0;
  int unvisited;
  int commitNodeCount = 0;

  if (rf_validateVisitedDebug)
    rf_ValidateVisitedBits(dag_h);
  
  if (dag_h->numNodesCompleted != 0) {
    printf("INVALID DAG: num nodes completed is %d, should be 0\n",dag_h->numNodesCompleted);
    retcode = 1; goto validate_dag_bad;
  }
  if (dag_h->status != rf_enable) {
    printf("INVALID DAG: not enabled\n");
    retcode = 1; goto validate_dag_bad;
  }
  if (dag_h->numCommits != 0) {
    printf("INVALID DAG: numCommits != 0 (%d)\n",dag_h->numCommits);
    retcode = 1; goto validate_dag_bad;
  }
  if (dag_h->numSuccedents != 1) {
    /* currently, all dags must have only one succedent */
    printf("INVALID DAG: numSuccedents !1 (%d)\n",dag_h->numSuccedents);
    retcode = 1; goto validate_dag_bad;
  }
  nodecount = rf_AssignNodeNums(dag_h);

  unvisited = dag_h->succedents[0]->visited;
    
  RF_Calloc(scount, nodecount, sizeof(int), (int *));
  RF_Calloc(acount, nodecount, sizeof(int), (int *));
  RF_Calloc(nodes,  nodecount, sizeof(RF_DagNode_t *), (RF_DagNode_t **));
  for (i=0; i<dag_h->numSuccedents; i++) {
    if ((dag_h->succedents[i]->visited == unvisited)
        && rf_ValidateBranch(dag_h->succedents[i], scount,
        acount, nodes, unvisited))
    {
      retcode = 1;
    }
  }
  /* start at 1 to skip the header node */
  for (i=1; i<nodecount; i++) {
    if ( nodes[i]->commitNode )
      commitNodeCount++;
    if ( nodes[i]->doFunc == NULL ) {
      printf("INVALID DAG: node %s has an undefined doFunc\n", nodes[i]->name);
      retcode = 1;
      goto validate_dag_out;
    }
    if ( nodes[i]->undoFunc == NULL ) {
      printf("INVALID DAG: node %s has an undefined doFunc\n", nodes[i]->name);
      retcode = 1;
      goto validate_dag_out;
    }
    if ( nodes[i]->numAntecedents != scount[ nodes[i]->nodeNum ] ) {
      printf("INVALID DAG: node %s has %d antecedents but appears as a succedent %d times\n",
	     nodes[i]->name, nodes[i]->numAntecedents, scount[nodes[i]->nodeNum]);
      retcode = 1;
      goto validate_dag_out;
    }
    if ( nodes[i]->numSuccedents != acount[ nodes[i]->nodeNum ] ) {
      printf("INVALID DAG: node %s has %d succedents but appears as an antecedent %d times\n",
	     nodes[i]->name, nodes[i]->numSuccedents, acount[nodes[i]->nodeNum]);
      retcode = 1;
      goto validate_dag_out;
    }
  }

  if ( dag_h->numCommitNodes != commitNodeCount ) {
    printf("INVALID DAG: incorrect commit node count.  hdr->numCommitNodes (%d) found (%d) commit nodes in graph\n",
      dag_h->numCommitNodes, commitNodeCount);
    retcode = 1;
    goto validate_dag_out;
  }
d713 6
d720 10
a729 10
  RF_Free(scount, nodecount*sizeof(int));
  RF_Free(acount, nodecount*sizeof(int));
  RF_Free(nodes,  nodecount*sizeof(RF_DagNode_t *));
  if (retcode)
    rf_PrintDAGList(dag_h);
  
  if (rf_validateVisitedDebug)
    rf_ValidateVisitedBits(dag_h);
  
  return(retcode);
d732 2
a733 2
  rf_PrintDAGList(dag_h);
  return(retcode);
d743 46
a788 46
void rf_redirect_asm(
  RF_Raid_t             *raidPtr,
  RF_AccessStripeMap_t  *asmap)
{
  int ds = (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) ? 1 : 0;
  int row = asmap->physInfo->row;
  int fcol = raidPtr->reconControl[row]->fcol;
  int srow = raidPtr->reconControl[row]->spareRow;
  int scol = raidPtr->reconControl[row]->spareCol;
  RF_PhysDiskAddr_t *pda;

  RF_ASSERT( raidPtr->status[row] == rf_rs_reconstructing );
  for (pda = asmap->physInfo; pda; pda=pda->next) {
    if (pda->col == fcol) {
      if (rf_dagDebug) {
        if (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap,
          pda->startSector))
        {
          RF_PANIC();
        }
      }
      /*printf("Remapped data for large write\n");*/
      if (ds) {
        raidPtr->Layout.map->MapSector(raidPtr, pda->raidAddress,
          &pda->row, &pda->col, &pda->startSector, RF_REMAP);
      }
      else {
        pda->row = srow; pda->col = scol;
      }
    }
  }
  for (pda = asmap->parityInfo; pda; pda=pda->next) {
    if (pda->col == fcol) {
      if (rf_dagDebug) {
        if (!rf_CheckRUReconstructed(raidPtr->reconControl[row]->reconMap, pda->startSector)) {
          RF_PANIC();
        }
      }
    }
    if (ds) {
      (raidPtr->Layout.map->MapParity)(raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);
    }
    else {
      pda->row = srow; pda->col = scol;
    }
  }
d800 52
a851 48
void rf_MapUnaccessedPortionOfStripe(
  RF_Raid_t                    *raidPtr,
  RF_RaidLayout_t              *layoutPtr, /* in: layout information */
  RF_AccessStripeMap_t         *asmap,     /* in: access stripe map */
  RF_DagHeader_t               *dag_h,     /* in: header of the dag to create */
  RF_AccessStripeMapHeader_t  **new_asm_h, /* in: ptr to array of 2 headers, to be filled in */
  int                          *nRodNodes, /* out: num nodes to be generated to read unaccessed data */
  char                        **sosBuffer, /* out: pointers to newly allocated buffer */
  char                        **eosBuffer,
  RF_AllocListElem_t           *allocList)
{
  RF_RaidAddr_t sosRaidAddress, eosRaidAddress;
  RF_SectorNum_t sosNumSector, eosNumSector;

  RF_ASSERT( asmap->numStripeUnitsAccessed > (layoutPtr->numDataCol/2) );
  /* generate an access map for the region of the array from start of stripe
   * to start of access */
  new_asm_h[0] = new_asm_h[1] = NULL; *nRodNodes = 0;
  if (!rf_RaidAddressStripeAligned(layoutPtr, asmap->raidAddress)) {
    sosRaidAddress = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);
    sosNumSector   = asmap->raidAddress - sosRaidAddress;
    RF_MallocAndAdd(*sosBuffer, rf_RaidAddressToByte(raidPtr, sosNumSector), (char *), allocList);
    new_asm_h[0]   = rf_MapAccess(raidPtr, sosRaidAddress, sosNumSector, *sosBuffer, RF_DONT_REMAP);
    new_asm_h[0]->next = dag_h->asmList;
    dag_h->asmList = new_asm_h[0];
    *nRodNodes    += new_asm_h[0]->stripeMap->numStripeUnitsAccessed;
    
    RF_ASSERT(new_asm_h[0]->stripeMap->next == NULL);
    /* we're totally within one stripe here */
    if (asmap->flags & RF_ASM_REDIR_LARGE_WRITE)
      rf_redirect_asm(raidPtr, new_asm_h[0]->stripeMap);
  }
  /* generate an access map for the region of the array from end of access
   * to end of stripe */
  if (!rf_RaidAddressStripeAligned(layoutPtr, asmap->endRaidAddress)) {
    eosRaidAddress = asmap->endRaidAddress;
    eosNumSector   = rf_RaidAddressOfNextStripeBoundary(layoutPtr, eosRaidAddress) - eosRaidAddress;
    RF_MallocAndAdd(*eosBuffer, rf_RaidAddressToByte(raidPtr, eosNumSector), (char *), allocList);
    new_asm_h[1]   = rf_MapAccess(raidPtr, eosRaidAddress, eosNumSector, *eosBuffer, RF_DONT_REMAP);
    new_asm_h[1]->next = dag_h->asmList;
    dag_h->asmList = new_asm_h[1];
    *nRodNodes    += new_asm_h[1]->stripeMap->numStripeUnitsAccessed;
    
    RF_ASSERT(new_asm_h[1]->stripeMap->next == NULL);
    /* we're totally within one stripe here */
    if (asmap->flags & RF_ASM_REDIR_LARGE_WRITE)
      rf_redirect_asm(raidPtr, new_asm_h[1]->stripeMap);
  }
d857 12
a868 11
int rf_PDAOverlap(
  RF_RaidLayout_t    *layoutPtr,
  RF_PhysDiskAddr_t  *src,
  RF_PhysDiskAddr_t  *dest)
{
  RF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);
  RF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);
  /* use -1 to be sure we stay within SU */
  RF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector-1);
  RF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector-1);
  return( (RF_MAX(soffs,doffs) <= RF_MIN(send,dend)) ? 1 : 0 );
d900 126
a1025 104
void rf_GenerateFailedAccessASMs(
  RF_Raid_t                    *raidPtr,
  RF_AccessStripeMap_t         *asmap,
  RF_PhysDiskAddr_t            *failedPDA,
  RF_DagHeader_t               *dag_h,
  RF_AccessStripeMapHeader_t  **new_asm_h,
  int                          *nXorBufs,
  char                        **rpBufPtr,
  char                         *overlappingPDAs,
  RF_AllocListElem_t           *allocList)
{
  RF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);

  /* s=start, e=end, s=stripe, a=access, f=failed, su=stripe unit */
  RF_RaidAddr_t sosAddr, sosEndAddr, eosStartAddr, eosAddr;

  RF_SectorCount_t numSect[2], numParitySect;
  RF_PhysDiskAddr_t *pda;
  char *rdBuf, *bufP;
  int foundit, i;

  bufP = NULL;
  foundit = 0;
  /* first compute the following raid addresses:
       start of stripe,                            (sosAddr)
       MIN(start of access, start of failed SU),   (sosEndAddr)
       MAX(end of access, end of failed SU),       (eosStartAddr)
       end of stripe (i.e. start of next stripe)   (eosAddr)
  */
  sosAddr      = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);
  sosEndAddr   = RF_MIN(asmap->raidAddress, rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr,failedPDA->raidAddress));
  eosStartAddr = RF_MAX(asmap->endRaidAddress, rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr, failedPDA->raidAddress));
  eosAddr      = rf_RaidAddressOfNextStripeBoundary(layoutPtr, asmap->raidAddress);

  /* now generate access stripe maps for each of the above regions of the
   * stripe.  Use a dummy (NULL) buf ptr for now */

  new_asm_h[0] = (sosAddr != sosEndAddr)   ? rf_MapAccess(raidPtr, sosAddr,      sosEndAddr-sosAddr,   NULL, RF_DONT_REMAP) : NULL;
  new_asm_h[1] = (eosStartAddr != eosAddr) ? rf_MapAccess(raidPtr, eosStartAddr, eosAddr-eosStartAddr, NULL, RF_DONT_REMAP) : NULL;

  /* walk through the PDAs and range-restrict each SU to the region of the
   * SU touched on the failed PDA.  also compute total data buffer space
   * requirements in this step.  Ignore the parity for now. */

  numSect[0] = numSect[1] = 0;
  if (new_asm_h[0]) {
    new_asm_h[0]->next = dag_h->asmList; dag_h->asmList = new_asm_h[0];
    for (pda = new_asm_h[0]->stripeMap->physInfo; pda; pda = pda->next) {
      rf_RangeRestrictPDA(raidPtr,failedPDA, pda, RF_RESTRICT_NOBUFFER, 0); numSect[0] += pda->numSector;
    }
  }
  if (new_asm_h[1]) {
    new_asm_h[1]->next = dag_h->asmList; dag_h->asmList = new_asm_h[1];
    for (pda = new_asm_h[1]->stripeMap->physInfo; pda; pda = pda->next) {
      rf_RangeRestrictPDA(raidPtr,failedPDA, pda, RF_RESTRICT_NOBUFFER, 0); numSect[1] += pda->numSector;
    }
  }
  numParitySect = failedPDA->numSector;

  /* allocate buffer space for the data & parity we have to read to recover
   * from the failure */

  if (numSect[0]+numSect[1]+ ((rpBufPtr) ? numParitySect : 0)) {      /* don't allocate parity buf if not needed */
    RF_MallocAndAdd(rdBuf, rf_RaidAddressToByte(raidPtr,numSect[0]+numSect[1]+numParitySect), (char *), allocList);
    bufP = rdBuf;
    if (rf_degDagDebug) printf("Newly allocated buffer (%d bytes) is 0x%lx\n",
			    (int)rf_RaidAddressToByte(raidPtr,numSect[0]+numSect[1]+numParitySect), (unsigned long) bufP);
  }

  /* now walk through the pdas one last time and assign buffer pointers
   * (ugh!).  Again, ignore the parity.  also, count nodes to find out how
   * many bufs need to be xored together */
  (*nXorBufs) = 1;   /* in read case, 1 is for parity.  In write case, 1 is for failed data */
  if (new_asm_h[0]) {
    for (pda=new_asm_h[0]->stripeMap->physInfo; pda; pda=pda->next) {pda->bufPtr = bufP; bufP += rf_RaidAddressToByte(raidPtr,pda->numSector);}
    *nXorBufs += new_asm_h[0]->stripeMap->numStripeUnitsAccessed;
  }
  if (new_asm_h[1]) {
    for (pda=new_asm_h[1]->stripeMap->physInfo; pda; pda=pda->next) {pda->bufPtr = bufP; bufP += rf_RaidAddressToByte(raidPtr,pda->numSector);}
    (*nXorBufs) += new_asm_h[1]->stripeMap->numStripeUnitsAccessed;
  }
  if (rpBufPtr) *rpBufPtr = bufP;     /* the rest of the buffer is for parity */

  /* the last step is to figure out how many more distinct buffers need to
   * get xor'd to produce the missing unit.  there's one for each user-data
   * read node that overlaps the portion of the failed unit being accessed */

  for (foundit=i=0,pda=asmap->physInfo; pda; i++,pda=pda->next) {
    if (pda == failedPDA) {i--; foundit=1; continue;}
    if (rf_PDAOverlap(layoutPtr, pda, failedPDA)) {
      overlappingPDAs[i] = 1;
      (*nXorBufs)++;
    }
  }
  if (!foundit) {RF_ERRORMSG("GenerateFailedAccessASMs: did not find failedPDA in asm list\n"); RF_ASSERT(0);}

  if (rf_degDagDebug) {
    if (new_asm_h[0]) {
      printf("First asm:\n"); rf_PrintFullAccessStripeMap(new_asm_h[0], 1);
    }
    if (new_asm_h[1]) {
      printf("Second asm:\n"); rf_PrintFullAccessStripeMap(new_asm_h[1], 1);
    }
  }
d1051 25
a1075 23
void rf_RangeRestrictPDA(
  RF_Raid_t          *raidPtr,
  RF_PhysDiskAddr_t  *src,
  RF_PhysDiskAddr_t  *dest,
  int                 dobuffer,
  int                 doraidaddr)
{
  RF_RaidLayout_t *layoutPtr = &raidPtr->Layout;
  RF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);
  RF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);
  RF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector-1);     /* use -1 to be sure we stay within SU */
  RF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector-1);
  RF_SectorNum_t subAddr = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->startSector); /* stripe unit boundary */

  dest->startSector = subAddr + RF_MAX(soffs,doffs);
  dest->numSector = subAddr + RF_MIN(send,dend) + 1 - dest->startSector;

  if (dobuffer)
    dest->bufPtr += (soffs > doffs) ? rf_RaidAddressToByte(raidPtr,soffs-doffs) : 0;
  if (doraidaddr) {
    dest->raidAddress = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->raidAddress) +
                        rf_StripeUnitOffset(layoutPtr, dest->startSector);
  }
a1076 1

d1084 1
a1084 2
static int lowprimes[NLOWPRIMES] = {2,3,5,7,11,13,17,19};

d1091 40
a1130 39
int rf_compute_workload_shift(
  RF_Raid_t          *raidPtr,
  RF_PhysDiskAddr_t  *pda)
{
  /*
   * variables:
   *  d   = column of disk containing primary
   *  f   = column of failed disk
   *  n   = number of disks in array
   *  sd  = "shift distance" (number of columns that d is to the right of f)
   *  row = row of array the access is in
   *  v   = numerator of redirection ratio
   *  k   = denominator of redirection ratio
   */
  RF_RowCol_t d, f, sd, row, n;
  int k, v, ret, i;

  row = pda->row;
  n = raidPtr->numCol;

  /* assign column of primary copy to d */
  d = pda->col;

  /* assign column of dead disk to f */
  for(f=0;((!RF_DEAD_DISK(raidPtr->Disks[row][f].status))&&(f<n));f++);

  RF_ASSERT(f < n);
  RF_ASSERT(f != d);

  sd = (f > d) ? (n + d - f) : (d - f);
  RF_ASSERT(sd < n);

  /*
   * v of every k accesses should be redirected
   *
   * v/k := (n-1-sd)/(n-1)
   */
  v = (n-1-sd);
  k = (n-1);
d1133 15
a1147 15
  /*
   * XXX
   * Is this worth it?
   *
   * Now reduce the fraction, by repeatedly factoring
   * out primes (just like they teach in elementary school!)
   */
  for(i=0;i<NLOWPRIMES;i++) {
    if (lowprimes[i] > v)
      break;
    while (((v%lowprimes[i])==0) && ((k%lowprimes[i])==0)) {
      v /= lowprimes[i];
      k /= lowprimes[i];
    }
  }
d1150 6
a1155 7
  raidPtr->hist_diskreq[row][d]++;
  if (raidPtr->hist_diskreq[row][d] > v) {
    ret = 0; /* do not redirect */
  }
  else {
    ret = 1; /* redirect */
  }
d1158 2
a1159 2
  printf("d=%d f=%d sd=%d v=%d k=%d ret=%d h=%d\n", d, f, sd, v, k, ret,
    raidPtr->hist_diskreq[row][d]);
d1162 5
a1166 6
  if (raidPtr->hist_diskreq[row][d] >= k) {
    /* reset counter */
    raidPtr->hist_diskreq[row][d] = 0;
  }

  return(ret);
a1167 1

d1177 2
a1178 1
void rf_SelectMirrorDiskIdle(RF_DagNode_t *node)
d1180 16
a1195 16
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;
  RF_RowCol_t rowData, colData, rowMirror, colMirror;
  int dataQueueLength, mirrorQueueLength, usemirror;
  RF_PhysDiskAddr_t *data_pda   = (RF_PhysDiskAddr_t *)node->params[0].p;
  RF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *)node->params[4].p;
  RF_PhysDiskAddr_t *tmp_pda;
  RF_RaidDisk_t **disks = raidPtr->Disks;
  RF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;

  /* return the [row col] of the disk with the shortest queue */
  rowData = data_pda->row;
  colData = data_pda->col;
  rowMirror = mirror_pda->row;
  colMirror = mirror_pda->col;
  dataQueue   = &(dqs[rowData][colData]);
  mirrorQueue = &(dqs[rowMirror][colMirror]);
d1198 3
a1200 3
  RF_LOCK_QUEUE_MUTEX(dataQueue, "SelectMirrorDiskIdle");
#endif /* RF_LOCK_QUEUES_TO_READ_LEN */
  dataQueueLength = dataQueue->queueLength + dataQueue->numOutstanding;
d1202 4
a1205 4
  RF_UNLOCK_QUEUE_MUTEX(dataQueue, "SelectMirrorDiskIdle");
  RF_LOCK_QUEUE_MUTEX(mirrorQueue, "SelectMirrorDiskIdle");
#endif /* RF_LOCK_QUEUES_TO_READ_LEN */
  mirrorQueueLength = mirrorQueue->queueLength + mirrorQueue->numOutstanding;
d1207 2
a1208 2
  RF_UNLOCK_QUEUE_MUTEX(mirrorQueue, "SelectMirrorDiskIdle");
#endif /* RF_LOCK_QUEUES_TO_READ_LEN */
d1210 33
a1242 35
  usemirror = 0;
  if (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {
    usemirror = 0;
  }
  else if (RF_DEAD_DISK(disks[rowData][colData].status)) {
    usemirror = 1;
  }
  else if (dataQueueLength < mirrorQueueLength) {
    usemirror = 0;
  }
  else if (mirrorQueueLength < dataQueueLength) {
    usemirror = 1;
  }
  else {
    /* queues are equal length. attempt cleverness. */
    if (SNUM_DIFF(dataQueue->last_deq_sector,data_pda->startSector)
        <= SNUM_DIFF(mirrorQueue->last_deq_sector,mirror_pda->startSector))
    {
      usemirror = 0;
    }
    else {
      usemirror = 1;
    }
  }

  if (usemirror) {
    /* use mirror (parity) disk, swap params 0 & 4 */
    tmp_pda = data_pda;
    node->params[0].p = mirror_pda;
    node->params[4].p = tmp_pda;
  }
  else {
    /* use data disk, leave param 0 unchanged */
  }
  /* printf("dataQueueLength %d, mirrorQueueLength %d\n",dataQueueLength, mirrorQueueLength); */
a1243 1

d1248 2
a1249 1
void rf_SelectMirrorDiskPartition(RF_DagNode_t *node)
d1251 38
a1288 40
  RF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;
  RF_RowCol_t rowData, colData, rowMirror, colMirror;
  RF_PhysDiskAddr_t *data_pda   = (RF_PhysDiskAddr_t *)node->params[0].p;
  RF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *)node->params[4].p;
  RF_PhysDiskAddr_t *tmp_pda;
  RF_RaidDisk_t **disks = raidPtr->Disks;
  RF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;
  int usemirror;

  /* return the [row col] of the disk with the shortest queue */
  rowData = data_pda->row;
  colData = data_pda->col;
  rowMirror = mirror_pda->row;
  colMirror = mirror_pda->col;
  dataQueue   = &(dqs[rowData][colData]);
  mirrorQueue = &(dqs[rowMirror][colMirror]);

  usemirror = 0;
  if (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {
    usemirror = 0;
  }
  else if (RF_DEAD_DISK(disks[rowData][colData].status)) {
    usemirror = 1;
  }
  else if (data_pda->startSector < (disks[rowData][colData].numBlocks / 2)) {
    usemirror = 0;
  }
  else {
    usemirror = 1;
  }

  if (usemirror) {
    /* use mirror (parity) disk, swap params 0 & 4 */
    tmp_pda = data_pda;
    node->params[0].p = mirror_pda;
    node->params[4].p = tmp_pda;
  }
  else {
    /* use data disk, leave param 0 unchanged */
  }
@

