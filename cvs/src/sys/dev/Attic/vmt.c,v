head	1.31;
access;
symbols
	OPENBSD_5_7:1.28.0.4
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.31
date	2015.07.21.09.13.11;	author reyk;	state dead;
branches;
next	1.30;
commitid	d27V1FOGj1cGBUt8;

1.30
date	2015.07.21.03.38.22;	author reyk;	state Exp;
branches;
next	1.29;
commitid	t8p39jbat5DBrbFu;

1.29
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.28;
commitid	p4LJxGKbi0BU2cG6;

1.28
date	2015.02.07.01.19.40;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	J7ySI1ZREP62T8hM;

1.27
date	2014.12.20.11.27.18;	author reyk;	state Exp;
branches;
next	1.26;
commitid	oH6jkmv1tdpIDzr3;

1.26
date	2014.12.19.15.14.48;	author reyk;	state Exp;
branches;
next	1.25;
commitid	UewfXf5dREXDnNWa;

1.25
date	2014.12.19.15.07.33;	author reyk;	state Exp;
branches;
next	1.24;
commitid	7r8D5Z0tQksAxKzl;

1.24
date	2014.12.18.19.31.37;	author reyk;	state Exp;
branches;
next	1.23;
commitid	FOYk5islTeHLMaCZ;

1.23
date	2014.12.18.19.22.21;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	cqEVlLRyxOurPwyf;

1.22
date	2014.12.18.19.18.22;	author reyk;	state Exp;
branches;
next	1.21;
commitid	sf36GwXfX3BiP5hJ;

1.21
date	2014.12.18.16.30.29;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	E8yKfW0tUk9Qmedl;

1.20
date	2014.12.05.15.50.03;	author mpi;	state Exp;
branches;
next	1.19;
commitid	t9FBKDfc4VDxpEy2;

1.19
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.18;
commitid	OBNa5kfxQ2UXoiIw;

1.18
date	2014.07.11.08.18.31;	author guenther;	state Exp;
branches;
next	1.17;
commitid	zJyOCNTjgsYVGLiw;

1.17
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2013.11.11.09.15.34;	author mpi;	state Exp;
branches;
next	1.15;

1.15
date	2013.10.26.21.05.09;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.14.00.20.49;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2013.07.03.15.26.02;	author sf;	state Exp;
branches;
next	1.12;

1.12
date	2012.09.11.04.40.14;	author dtucker;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.27.21.29.25;	author dtucker;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.03.10.15.23;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.26.01.16.11;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.26.00.57.21;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2009.12.28.14.25.34;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.28.14.22.09;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.26.02.20.58;	author cnst;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.23.22.22.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.2;

1.2
date	2008.07.12.23.17.33;	author ckuethe;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.08.05.22.00;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Move vmt.c to sys/dev/pv/vmt.c.  The history is lost but can be found
in the Attic of sys/dev/vmt.c.

OK to do it deraadt@@
@
text
@/*	$OpenBSD: vmt.c,v 1.30 2015/07/21 03:38:22 reyk Exp $ */

/*
 * Copyright (c) 2007 David Crawshaw <david@@zentus.com>
 * Copyright (c) 2008 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#if !defined(__i386__) && !defined(__amd64__)
#error vmt(4) is only supported on i386 and amd64
#endif

/*
 * Protocol reverse engineered by Ken Kato:
 * http://chitchat.at.infoseek.co.jp/vmware/backdoor.html
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/signalvar.h>
#include <sys/syslog.h>
#include <sys/proc.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_var.h>
#include <netinet/in.h>

#include <dev/rndvar.h>

/* "The" magic number, always occupies the EAX register. */
#define VM_MAGIC			0x564D5868

/* Port numbers, passed on EDX.LOW . */
#define VM_PORT_CMD			0x5658
#define VM_PORT_RPC			0x5659

/* Commands, passed on ECX.LOW. */
#define VM_CMD_GET_SPEED		0x01
#define VM_CMD_APM			0x02
#define VM_CMD_GET_MOUSEPOS		0x04
#define VM_CMD_SET_MOUSEPOS		0x05
#define VM_CMD_GET_CLIPBOARD_LEN	0x06
#define VM_CMD_GET_CLIPBOARD		0x07
#define VM_CMD_SET_CLIPBOARD_LEN	0x08
#define VM_CMD_SET_CLIPBOARD		0x09
#define VM_CMD_GET_VERSION		0x0a
#define  VM_VERSION_UNMANAGED			0x7fffffff
#define VM_CMD_GET_DEVINFO		0x0b
#define VM_CMD_DEV_ADDREMOVE		0x0c
#define VM_CMD_GET_GUI_OPTIONS		0x0d
#define VM_CMD_SET_GUI_OPTIONS		0x0e
#define VM_CMD_GET_SCREEN_SIZE		0x0f
#define VM_CMD_GET_HWVER		0x11
#define VM_CMD_POPUP_OSNOTFOUND		0x12
#define VM_CMD_GET_BIOS_UUID		0x13
#define VM_CMD_GET_MEM_SIZE		0x14
/*#define VM_CMD_GET_TIME		0x17 */	/* deprecated */
#define VM_CMD_RPC			0x1e
#define VM_CMD_GET_TIME_FULL		0x2e

/* RPC sub-commands, passed on ECX.HIGH. */
#define VM_RPC_OPEN			0x00
#define VM_RPC_SET_LENGTH		0x01
#define VM_RPC_SET_DATA			0x02
#define VM_RPC_GET_LENGTH		0x03
#define VM_RPC_GET_DATA			0x04
#define VM_RPC_GET_END			0x05
#define VM_RPC_CLOSE			0x06

/* RPC magic numbers, passed on EBX. */
#define VM_RPC_OPEN_RPCI	0x49435052UL /* with VM_RPC_OPEN. */
#define VM_RPC_OPEN_TCLO	0x4F4C4354UL /* with VP_RPC_OPEN. */
#define VM_RPC_ENH_DATA		0x00010000UL /* with enhanced RPC data calls. */

#define VM_RPC_FLAG_COOKIE	0x80000000UL

/* RPC reply flags */
#define VM_RPC_REPLY_SUCCESS	0x0001
#define VM_RPC_REPLY_DORECV	0x0002		/* incoming message available */
#define VM_RPC_REPLY_CLOSED	0x0004		/* RPC channel is closed */
#define VM_RPC_REPLY_UNSENT	0x0008		/* incoming message was removed? */
#define VM_RPC_REPLY_CHECKPOINT	0x0010		/* checkpoint occurred -> retry */
#define VM_RPC_REPLY_POWEROFF	0x0020		/* underlying device is powering off */
#define VM_RPC_REPLY_TIMEOUT	0x0040
#define VM_RPC_REPLY_HB		0x0080		/* high-bandwidth tx/rx available */

/* VM state change IDs */
#define VM_STATE_CHANGE_HALT	1
#define VM_STATE_CHANGE_REBOOT	2
#define VM_STATE_CHANGE_POWERON 3
#define VM_STATE_CHANGE_RESUME  4
#define VM_STATE_CHANGE_SUSPEND 5

/* VM guest info keys */
#define VM_GUEST_INFO_DNS_NAME		1
#define VM_GUEST_INFO_IP_ADDRESS	2
#define VM_GUEST_INFO_DISK_FREE_SPACE	3
#define VM_GUEST_INFO_BUILD_NUMBER	4
#define VM_GUEST_INFO_OS_NAME_FULL	5
#define VM_GUEST_INFO_OS_NAME		6
#define VM_GUEST_INFO_UPTIME		7
#define VM_GUEST_INFO_MEMORY		8
#define VM_GUEST_INFO_IP_ADDRESS_V2	9

/* RPC responses */
#define VM_RPC_REPLY_OK			"OK "
#define VM_RPC_RESET_REPLY		"OK ATR toolbox"
#define VM_RPC_REPLY_ERROR		"ERROR Unknown command"
#define VM_RPC_REPLY_ERROR_IP_ADDR	"ERROR Unable to find guest IP address"

/* A register. */
union vm_reg {
	struct {
		uint16_t low;
		uint16_t high;
	} part;
	uint32_t word;
#ifdef __amd64__
	struct {
		uint32_t low;
		uint32_t high;
	} words;
	uint64_t quad;
#endif
} __packed;

/* A register frame. */
struct vm_backdoor {
	union vm_reg eax;
	union vm_reg ebx;
	union vm_reg ecx;
	union vm_reg edx;
	union vm_reg esi;
	union vm_reg edi;
	union vm_reg ebp;
} __packed;

/* RPC context. */
struct vm_rpc {
	uint16_t channel;
	uint32_t cookie1;
	uint32_t cookie2;
};

struct vmt_softc {
	struct device		sc_dev;

	struct vm_rpc		sc_tclo_rpc;
	char			*sc_rpc_buf;
	int			sc_rpc_error;
	int			sc_tclo_ping;
	int			sc_set_guest_os;
#define VMT_RPC_BUFLEN			256

	struct timeout		sc_tick;
	struct timeout		sc_tclo_tick;
	struct ksensordev	sc_sensordev;
	struct ksensor		sc_sensor;

	char			sc_hostname[MAXHOSTNAMELEN];
};

#ifdef VMT_DEBUG
#define DPRINTF(_arg...)	printf(_arg)
#else
#define DPRINTF(_arg...)	do {} while(0)
#endif
#define DEVNAME(_s)		((_s)->sc_dev.dv_xname)

void	 vm_cmd(struct vm_backdoor *);
void	 vm_ins(struct vm_backdoor *);
void	 vm_outs(struct vm_backdoor *);

/* Functions for communicating with the VM Host. */
int	 vm_rpc_open(struct vm_rpc *, uint32_t);
int	 vm_rpc_close(struct vm_rpc *);
int	 vm_rpc_send(const struct vm_rpc *, const uint8_t *, uint32_t);
int	 vm_rpc_send_str(const struct vm_rpc *, const uint8_t *);
int	 vm_rpc_get_length(const struct vm_rpc *, uint32_t *, uint16_t *);
int	 vm_rpc_get_data(const struct vm_rpc *, char *, uint32_t, uint16_t);
int	 vm_rpc_send_rpci_tx_buf(struct vmt_softc *, const uint8_t *, uint32_t);
int	 vm_rpc_send_rpci_tx(struct vmt_softc *, const char *, ...)
	    __attribute__((__format__(__kprintf__,2,3)));
int	 vm_rpci_response_successful(struct vmt_softc *);

void	 vmt_probe_cmd(struct vm_backdoor *, uint16_t);
void	 vmt_tclo_state_change_success(struct vmt_softc *, int, char);
void	 vmt_do_reboot(struct vmt_softc *);
void	 vmt_do_shutdown(struct vmt_softc *);
void	 vmt_shutdown(void *);

void	 vmt_update_guest_info(struct vmt_softc *);
void	 vmt_update_guest_uptime(struct vmt_softc *);

void	 vmt_tick(void *);
void	 vmt_resume(void);

int	 vmt_match(struct device *, void *, void *);
void	 vmt_attach(struct device *, struct device *, void *);
int	 vmt_activate(struct device *, int);

void	 vmt_tclo_tick(void *);
int	 vmt_tclo_process(struct vmt_softc *, const char *);
void	 vmt_tclo_reset(struct vmt_softc *);
void	 vmt_tclo_ping(struct vmt_softc *);
void	 vmt_tclo_halt(struct vmt_softc *);
void	 vmt_tclo_reboot(struct vmt_softc *);
void	 vmt_tclo_poweron(struct vmt_softc *);
void	 vmt_tclo_suspend(struct vmt_softc *);
void	 vmt_tclo_resume(struct vmt_softc *);
void	 vmt_tclo_capreg(struct vmt_softc *);
void	 vmt_tclo_broadcastip(struct vmt_softc *);

int	 vmt_probe(void);

struct vmt_tclo_rpc {
	const char	*name;
	void		(*cb)(struct vmt_softc *);
} vmt_tclo_rpc[] = {
	/* Keep sorted by name (case-sensitive) */
        { "Capabilities_Register",      vmt_tclo_capreg },
        { "OS_Halt",                    vmt_tclo_halt },
        { "OS_PowerOn",                 vmt_tclo_poweron },
        { "OS_Reboot",                  vmt_tclo_reboot },
        { "OS_Resume",                  vmt_tclo_resume },
        { "OS_Suspend",                 vmt_tclo_suspend },
        { "Set_Option broadcastIP 1",   vmt_tclo_broadcastip },
        { "ping",                       vmt_tclo_ping },
        { "reset",                      vmt_tclo_reset },
	{ NULL },
#if 0
	/* Various unsupported commands */
	{ "Set_Option autohide 0" },
	{ "Set_Option copypaste 1" },
	{ "Set_Option enableDnD 1" },
	{ "Set_Option enableMessageBusTunnel 0" },
	{ "Set_Option linkRootHgfsShare 0" },
	{ "Set_Option mapRootHgfsShare 0" },
	{ "Set_Option synctime 1" },
	{ "Set_Option synctime.period 0" },
	{ "Set_Option time.synchronize.tools.enable 1" },
	{ "Set_Option time.synchronize.tools.percentCorrection 0" },
	{ "Set_Option time.synchronize.tools.slewCorrection 1" },
	{ "Set_Option time.synchronize.tools.startup 1" },
	{ "Set_Option toolScripts.afterPowerOn 1" },
	{ "Set_Option toolScripts.afterResume 1" },
	{ "Set_Option toolScripts.beforePowerOff 1" },
	{ "Set_Option toolScripts.beforeSuspend 1" },
	{ "Time_Synchronize 0" },
	{ "Vix_1_Relayed_Command \"38cdcae40e075d66\"" },
#endif
};

struct cfattach vmt_ca = {
	sizeof(struct vmt_softc),
	vmt_match,
	vmt_attach,
	NULL,
	vmt_activate
};

struct cfdriver vmt_cd = {
	NULL,
	"vmt",
	DV_DULL
};

extern char hostname[MAXHOSTNAMELEN];

void
vmt_probe_cmd(struct vm_backdoor *frame, uint16_t cmd)
{
	bzero(frame, sizeof(*frame));

	(frame->eax).word = VM_MAGIC;
	(frame->ebx).word = ~VM_MAGIC;
	(frame->ecx).part.low = cmd;
	(frame->ecx).part.high = 0xffff;
	(frame->edx).part.low  = VM_PORT_CMD;
	(frame->edx).part.high = 0;

	vm_cmd(frame);
}

int
vmt_probe(void)
{
	struct vm_backdoor frame;

	vmt_probe_cmd(&frame, VM_CMD_GET_VERSION);
	if (frame.eax.word == 0xffffffff ||
	    frame.ebx.word != VM_MAGIC)
		return (0);

	vmt_probe_cmd(&frame, VM_CMD_GET_SPEED);
	if (frame.eax.word == VM_MAGIC)
		return (0);

	return (1);
}

int
vmt_match(struct device *parent, void *match, void *aux)
{
	const char **busname = (const char **)aux;

	if (!vmt_probe())
		return (0);

	return (strcmp(*busname, vmt_cd.cd_name) == 0);
}

void
vmt_attach(struct device *parent, struct device *self, void *aux)
{
	struct vmt_softc *sc = (struct vmt_softc *)self;

	printf("\n");
	sc->sc_rpc_buf = malloc(VMT_RPC_BUFLEN, M_DEVBUF, M_NOWAIT);
	if (sc->sc_rpc_buf == NULL) {
		printf("%s: unable to allocate buffer for RPC\n",
		    DEVNAME(sc));
		return;
	}

	if (vm_rpc_open(&sc->sc_tclo_rpc, VM_RPC_OPEN_TCLO) != 0) {
		printf("%s: failed to open backdoor RPC channel "
		    "(TCLO protocol)\n", DEVNAME(sc));
		goto free;
	}

	/* don't know if this is important at all yet */
	if (vm_rpc_send_rpci_tx(sc,
	    "tools.capability.hgfs_server toolbox 1") != 0) {
		printf(": failed to set HGFS server capability\n");
		goto free;
	}

	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_sensor.type = SENSOR_TIMEDELTA;
	sc->sc_sensor.status = SENSOR_S_UNKNOWN;

	sensor_attach(&sc->sc_sensordev, &sc->sc_sensor);
	sensordev_install(&sc->sc_sensordev);

	timeout_set(&sc->sc_tick, vmt_tick, sc);
	if (mountroothook_establish(vmt_tick, sc) == NULL)
		DPRINTF("%s: unable to establish tick\n", DEVNAME(sc));

	timeout_set(&sc->sc_tclo_tick, vmt_tclo_tick, sc);
	timeout_add_sec(&sc->sc_tclo_tick, 1);
	sc->sc_tclo_ping = 1;

	return;

free:
	free(sc->sc_rpc_buf, M_DEVBUF, 0);
}

void
vmt_resume(void)
{
	struct vm_backdoor frame;
	extern void rdrand(void *);

	bzero(&frame, sizeof(frame));
	frame.eax.word = VM_MAGIC;
	frame.ecx.part.low = VM_CMD_GET_TIME_FULL;
	frame.edx.part.low  = VM_PORT_CMD;
	vm_cmd(&frame);

	rdrand(NULL);
	add_true_randomness(frame.eax.word);
	add_true_randomness(frame.esi.word);
	add_true_randomness(frame.edx.word);
	add_true_randomness(frame.ebx.word);
	resume_randomness(NULL, 0);
}

int
vmt_activate(struct device *self, int act)
{
	int rv = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		vmt_shutdown(self);
		break;
	case DVACT_RESUME:
		vmt_resume();
		break;
	}
	return (rv);
}


void
vmt_update_guest_uptime(struct vmt_softc *sc)
{
	/* host wants uptime in hundredths of a second */
	if (vm_rpc_send_rpci_tx(sc, "SetGuestInfo  %d %lld00",
	    VM_GUEST_INFO_UPTIME, (long long)time_uptime) != 0) {
		DPRINTF("%s: unable to set guest uptime", DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}
}

void
vmt_update_guest_info(struct vmt_softc *sc)
{
	if (strncmp(sc->sc_hostname, hostname, sizeof(sc->sc_hostname)) != 0) {
		strlcpy(sc->sc_hostname, hostname, sizeof(sc->sc_hostname));

		if (vm_rpc_send_rpci_tx(sc, "SetGuestInfo  %d %s",
		    VM_GUEST_INFO_DNS_NAME, sc->sc_hostname) != 0) {
			DPRINTF("%s: unable to set hostname", DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}
	}

	/*
	 * We're supposed to pass the full network address information back
	 * here, but that involves xdr (sunrpc) data encoding, which seems a
	 * bit unreasonable.
	 */

	if (sc->sc_set_guest_os == 0) {
		if (vm_rpc_send_rpci_tx(sc, "SetGuestInfo  %d %s %s %s",
		    VM_GUEST_INFO_OS_NAME_FULL,
		    ostype, osrelease, osversion) != 0) {
			DPRINTF("%s: unable to set full guest OS", DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}

		/*
		 * Host doesn't like it if we send an OS name it doesn't
		 * recognise, so use the closest match, which happens
		 * to be FreeBSD.
		 */

		if (vm_rpc_send_rpci_tx(sc, "SetGuestInfo  %d %s",
		    VM_GUEST_INFO_OS_NAME, "FreeBSD") != 0) {
			DPRINTF("%s: unable to set guest OS", DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}

		sc->sc_set_guest_os = 1;
	}
}

void
vmt_tick(void *xarg)
{
	struct vmt_softc *sc = xarg;
	struct vm_backdoor frame;
	struct timeval *guest = &sc->sc_sensor.tv;
	struct timeval host, diff;

	microtime(guest);

	bzero(&frame, sizeof(frame));
	frame.eax.word = VM_MAGIC;
	frame.ecx.part.low = VM_CMD_GET_TIME_FULL;
	frame.edx.part.low  = VM_PORT_CMD;
	vm_cmd(&frame);

	if (frame.eax.word != 0xffffffff) {
		host.tv_sec = ((uint64_t)frame.esi.word << 32) | frame.edx.word;
		host.tv_usec = frame.ebx.word;

		timersub(guest, &host, &diff);

		sc->sc_sensor.value = (u_int64_t)diff.tv_sec * 1000000000LL +
		    (u_int64_t)diff.tv_usec * 1000LL;
		sc->sc_sensor.status = SENSOR_S_OK;
	} else {
		sc->sc_sensor.status = SENSOR_S_UNKNOWN;
	}

	vmt_update_guest_info(sc);
	vmt_update_guest_uptime(sc);

	timeout_add_sec(&sc->sc_tick, 15);
}

void
vmt_tclo_state_change_success(struct vmt_softc *sc, int success, char state)
{
	if (vm_rpc_send_rpci_tx(sc, "tools.os.statechange.status %d %d",
	    success, state) != 0) {
		DPRINTF("%s: unable to send state change result\n",
		    DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}
}

void
vmt_do_shutdown(struct vmt_softc *sc)
{
	vmt_tclo_state_change_success(sc, 1, VM_STATE_CHANGE_HALT);
	vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK);

	suspend_randomness();

	log(LOG_KERN | LOG_NOTICE,
	    "Shutting down in response to request from VMware host\n");
	prsignal(initprocess, SIGUSR2);
}

void
vmt_do_reboot(struct vmt_softc *sc)
{
	vmt_tclo_state_change_success(sc, 1, VM_STATE_CHANGE_REBOOT);
	vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK);

	suspend_randomness();

	log(LOG_KERN | LOG_NOTICE,
	    "Rebooting in response to request from VMware host\n");
	prsignal(initprocess, SIGINT);
}

void
vmt_shutdown(void *arg)
{
	struct vmt_softc *sc = arg;

	if (vm_rpc_send_rpci_tx(sc,
	    "tools.capability.hgfs_server toolbox 0") != 0) {
		DPRINTF("%s: failed to disable hgfs server capability\n",
		    DEVNAME(sc));
	}

	if (vm_rpc_send(&sc->sc_tclo_rpc, NULL, 0) != 0) {
		DPRINTF("%s: failed to send shutdown ping\n", DEVNAME(sc));
	}

	vm_rpc_close(&sc->sc_tclo_rpc);
}

void
vmt_tclo_reset(struct vmt_softc *sc)
{
	if (sc->sc_rpc_error != 0) {
		DPRINTF("%s: resetting rpc\n", DEVNAME(sc));
		vm_rpc_close(&sc->sc_tclo_rpc);

		/* reopen and send the reset reply next time around */
		sc->sc_rpc_error = 1;
		return;
	}

	if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_RESET_REPLY) != 0) {
		DPRINTF("%s: failed to send reset reply\n", DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}
}

void
vmt_tclo_ping(struct vmt_softc *sc)
{
	vmt_update_guest_info(sc);

	if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
		DPRINTF("%s: error sending ping response\n", DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}
}

void
vmt_tclo_halt(struct vmt_softc *sc)
{
	vmt_do_shutdown(sc);
}

void
vmt_tclo_reboot(struct vmt_softc *sc)
{
	vmt_do_reboot(sc);
}

void
vmt_tclo_poweron(struct vmt_softc *sc)
{
	vmt_tclo_state_change_success(sc, 1, VM_STATE_CHANGE_POWERON);

	if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
		DPRINTF("%s: error sending poweron response\n", DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}
}

void
vmt_tclo_suspend(struct vmt_softc *sc)
{
	log(LOG_KERN | LOG_NOTICE,
	    "VMware guest entering suspended state\n");

	suspend_randomness();

	vmt_tclo_state_change_success(sc, 1, VM_STATE_CHANGE_SUSPEND);
	if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
		DPRINTF("%s: error sending suspend response\n", DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}
}

void
vmt_tclo_resume(struct vmt_softc *sc)
{
	log(LOG_KERN | LOG_NOTICE,
	    "VMware guest resuming from suspended state\n");

	/* force guest info update */
	sc->sc_hostname[0] = '\0';
	sc->sc_set_guest_os = 0;
	vmt_update_guest_info(sc);
	vmt_resume();

	vmt_tclo_state_change_success(sc, 1, VM_STATE_CHANGE_RESUME);
	if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
		DPRINTF("%s: error sending resume response\n", DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}
}

void
vmt_tclo_capreg(struct vmt_softc *sc)
{
	/* don't know if this is important at all */
	if (vm_rpc_send_rpci_tx(sc,
	    "vmx.capability.unified_loop toolbox") != 0) {
		DPRINTF("%s: unable to set unified loop\n", DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}

	if (vm_rpci_response_successful(sc) == 0) {
		DPRINTF("%s: host rejected unified loop setting\n",
		    DEVNAME(sc));
	}

	/* the trailing space is apparently important here */
	if (vm_rpc_send_rpci_tx(sc,
	    "tools.capability.statechange ") != 0) {
		DPRINTF("%s: unable to send statechange capability\n",
		    DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}

	if (vm_rpci_response_successful(sc) == 0) {
		DPRINTF("%s: host rejected statechange capability\n",
		    DEVNAME(sc));
	}

	if (vm_rpc_send_rpci_tx(sc, "tools.set.version %u",
	    VM_VERSION_UNMANAGED) != 0) {
		DPRINTF("%s: unable to set tools version\n",
		    DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}

	vmt_update_guest_uptime(sc);

	if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
		DPRINTF("%s: error sending capabilities_register"
		    " response\n", DEVNAME(sc));
		sc->sc_rpc_error = 1;
	}
}

void
vmt_tclo_broadcastip(struct vmt_softc *sc)
{
	struct ifnet *iface;
	struct sockaddr_in *guest_ip;

	/* find first available ipv4 address */
	guest_ip = NULL;
	TAILQ_FOREACH(iface, &ifnet, if_list) {
		struct ifaddr *iface_addr;

		/* skip loopback */
		if (strncmp(iface->if_xname, "lo", 2) == 0 &&
		    iface->if_xname[2] >= '0' &&
		    iface->if_xname[2] <= '9') {
			continue;
		}

		TAILQ_FOREACH(iface_addr, &iface->if_addrlist,
		    ifa_list) {
			if (iface_addr->ifa_addr->sa_family != AF_INET)
				continue;

			guest_ip = satosin(iface_addr->ifa_addr);
			break;
		}
	}

	if (guest_ip != NULL) {
		char ip[INET_ADDRSTRLEN];

		inet_ntop(AF_INET, &guest_ip->sin_addr, ip, sizeof(ip));
		if (vm_rpc_send_rpci_tx(sc, "info-set guestinfo.ip %s",
		    ip) != 0) {
			DPRINTF("%s: unable to send guest IP address\n",
			    DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}

		if (vm_rpc_send_str(&sc->sc_tclo_rpc,
		    VM_RPC_REPLY_OK) != 0) {
			DPRINTF("%s: error sending broadcastIP"
			    " response\n", DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}
	} else {
		if (vm_rpc_send_str(&sc->sc_tclo_rpc,
		    VM_RPC_REPLY_ERROR_IP_ADDR) != 0) {
			DPRINTF("%s: error sending broadcastIP"
			    " error response\n", DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}
	}
}

int
vmt_tclo_process(struct vmt_softc *sc, const char *name)
{
	int i;

	/* Search for rpc command and call handler */
	for (i = 0; vmt_tclo_rpc[i].name != NULL; i++) {
		if (strcmp(vmt_tclo_rpc[i].name, sc->sc_rpc_buf) == 0) {
			vmt_tclo_rpc[i].cb(sc);
			return (0);
		}
	}

	DPRINTF("%s: unknown command: \"%s\"\n", DEVNAME(sc), name);

	return (-1);
}

void
vmt_tclo_tick(void *xarg)
{
	struct vmt_softc *sc = xarg;
	u_int32_t rlen;
	u_int16_t ack;
	int delay;

	/* By default, poll every second for new messages */
	delay = 1;

	/* reopen tclo channel if it's currently closed */
	if (sc->sc_tclo_rpc.channel == 0 &&
	    sc->sc_tclo_rpc.cookie1 == 0 &&
	    sc->sc_tclo_rpc.cookie2 == 0) {
		if (vm_rpc_open(&sc->sc_tclo_rpc, VM_RPC_OPEN_TCLO) != 0) {
			DPRINTF("%s: unable to reopen TCLO channel\n",
			    DEVNAME(sc));
			timeout_add_sec(&sc->sc_tclo_tick, 15);
			return;
		}

		if (vm_rpc_send_str(&sc->sc_tclo_rpc,
		    VM_RPC_RESET_REPLY) != 0) {
			DPRINTF("%s: failed to send reset reply\n",
			    DEVNAME(sc));
			sc->sc_rpc_error = 1;
			goto out;
		} else {
			sc->sc_rpc_error = 0;
		}
	}

	if (sc->sc_tclo_ping) {
		if (vm_rpc_send(&sc->sc_tclo_rpc, NULL, 0) != 0) {
			DPRINTF("%s: failed to send TCLO outgoing ping\n",
			    DEVNAME(sc));
			sc->sc_rpc_error = 1;
			goto out;
		}
	}

	if (vm_rpc_get_length(&sc->sc_tclo_rpc, &rlen, &ack) != 0) {
		DPRINTF("%s: failed to get length of incoming TCLO data\n",
		    DEVNAME(sc));
		sc->sc_rpc_error = 1;
		goto out;
	}

	if (rlen == 0) {
		sc->sc_tclo_ping = 1;
		goto out;
	}

	if (rlen >= VMT_RPC_BUFLEN) {
		rlen = VMT_RPC_BUFLEN - 1;
	}
	if (vm_rpc_get_data(&sc->sc_tclo_rpc, sc->sc_rpc_buf, rlen, ack) != 0) {
		DPRINTF("%s: failed to get incoming TCLO data\n", DEVNAME(sc));
		sc->sc_rpc_error = 1;
		goto out;
	}
	sc->sc_tclo_ping = 0;

	/* The VM host can queue multiple messages; continue without delay */
	delay = 0;

	if (vmt_tclo_process(sc, sc->sc_rpc_buf) != 0) {
		if (vm_rpc_send_str(&sc->sc_tclo_rpc,
		    VM_RPC_REPLY_ERROR) != 0) {
			DPRINTF("%s: error sending unknown command reply\n",
			    DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}
	}

	if (sc->sc_rpc_error == 1) {
		/* On error, give time to recover and wait a second */
		delay = 1;
	}

out:
	timeout_add_sec(&sc->sc_tclo_tick, delay);
}

#define BACKDOOR_OP_I386(op, frame)		\
	__asm__ volatile (			\
		"pushal;"			\
		"pushl %%eax;"			\
		"movl 0x18(%%eax), %%ebp;"	\
		"movl 0x14(%%eax), %%edi;"	\
		"movl 0x10(%%eax), %%esi;"	\
		"movl 0x0c(%%eax), %%edx;"	\
		"movl 0x08(%%eax), %%ecx;"	\
		"movl 0x04(%%eax), %%ebx;"	\
		"movl 0x00(%%eax), %%eax;"	\
		op				\
		"xchgl %%eax, 0x00(%%esp);"	\
		"movl %%ebp, 0x18(%%eax);"	\
		"movl %%edi, 0x14(%%eax);"	\
		"movl %%esi, 0x10(%%eax);"	\
		"movl %%edx, 0x0c(%%eax);"	\
		"movl %%ecx, 0x08(%%eax);"	\
		"movl %%ebx, 0x04(%%eax);"	\
		"popl 0x00(%%eax);"		\
		"popal;"			\
		::"a"(frame)			\
	)

#define BACKDOOR_OP_AMD64(op, frame)		\
	__asm__ volatile (			\
		"pushq %%rbp;			\n\t" \
		"pushq %%rax;			\n\t" \
		"movq 0x30(%%rax), %%rbp;	\n\t" \
		"movq 0x28(%%rax), %%rdi;	\n\t" \
		"movq 0x20(%%rax), %%rsi;	\n\t" \
		"movq 0x18(%%rax), %%rdx;	\n\t" \
		"movq 0x10(%%rax), %%rcx;	\n\t" \
		"movq 0x08(%%rax), %%rbx;	\n\t" \
		"movq 0x00(%%rax), %%rax;	\n\t" \
		op				"\n\t" \
		"xchgq %%rax, 0x00(%%rsp);	\n\t" \
		"movq %%rbp, 0x30(%%rax);	\n\t" \
		"movq %%rdi, 0x28(%%rax);	\n\t" \
		"movq %%rsi, 0x20(%%rax);	\n\t" \
		"movq %%rdx, 0x18(%%rax);	\n\t" \
		"movq %%rcx, 0x10(%%rax);	\n\t" \
		"movq %%rbx, 0x08(%%rax);	\n\t" \
		"popq 0x00(%%rax);		\n\t" \
		"popq %%rbp;			\n\t" \
		: /* No outputs. */ : "a" (frame) \
		  /* No pushal on amd64 so warn gcc about the clobbered registers. */ \
		: "rbx", "rcx", "rdx", "rdi", "rsi", "cc", "memory" \
	)


#ifdef __i386__
#define BACKDOOR_OP(op, frame) BACKDOOR_OP_I386(op, frame)
#else
#define BACKDOOR_OP(op, frame) BACKDOOR_OP_AMD64(op, frame)
#endif

void
vm_cmd(struct vm_backdoor *frame)
{
	BACKDOOR_OP("inl %%dx, %%eax;", frame);
}

void
vm_ins(struct vm_backdoor *frame)
{
	BACKDOOR_OP("cld;\n\trep insb;", frame);
}

void
vm_outs(struct vm_backdoor *frame)
{
	BACKDOOR_OP("cld;\n\trep outsb;", frame);
}

int
vm_rpc_open(struct vm_rpc *rpc, uint32_t proto)
{
	struct vm_backdoor frame;

	bzero(&frame, sizeof(frame));
	frame.eax.word      = VM_MAGIC;
	frame.ebx.word      = proto | VM_RPC_FLAG_COOKIE;
	frame.ecx.part.low  = VM_CMD_RPC;
	frame.ecx.part.high = VM_RPC_OPEN;
	frame.edx.part.low  = VM_PORT_CMD;
	frame.edx.part.high = 0;

	vm_cmd(&frame);

	if (frame.ecx.part.high != 1 || frame.edx.part.low != 0) {
		/* open-vm-tools retries without VM_RPC_FLAG_COOKIE here.. */
		DPRINTF("vmware: open failed, eax=%08x, ecx=%08x, edx=%08x\n",
		    frame.eax.word, frame.ecx.word, frame.edx.word);
		return EIO;
	}

	rpc->channel = frame.edx.part.high;
	rpc->cookie1 = frame.esi.word;
	rpc->cookie2 = frame.edi.word;

	return 0;
}

int
vm_rpc_close(struct vm_rpc *rpc)
{
	struct vm_backdoor frame;

	bzero(&frame, sizeof(frame));
	frame.eax.word      = VM_MAGIC;
	frame.ebx.word      = 0;
	frame.ecx.part.low  = VM_CMD_RPC;
	frame.ecx.part.high = VM_RPC_CLOSE;
	frame.edx.part.low  = VM_PORT_CMD;
	frame.edx.part.high = rpc->channel;
	frame.edi.word      = rpc->cookie2;
	frame.esi.word      = rpc->cookie1;

	vm_cmd(&frame);

	if (frame.ecx.part.high == 0 || frame.ecx.part.low != 0) {
		DPRINTF("vmware: close failed, eax=%08x, ecx=%08x\n",
		    frame.eax.word, frame.ecx.word);
		return EIO;
	}

	rpc->channel = 0;
	rpc->cookie1 = 0;
	rpc->cookie2 = 0;

	return 0;
}

int
vm_rpc_send(const struct vm_rpc *rpc, const uint8_t *buf, uint32_t length)
{
	struct vm_backdoor frame;

	/* Send the length of the command. */
	bzero(&frame, sizeof(frame));
	frame.eax.word = VM_MAGIC;
	frame.ebx.word = length;
	frame.ecx.part.low  = VM_CMD_RPC;
	frame.ecx.part.high = VM_RPC_SET_LENGTH;
	frame.edx.part.low  = VM_PORT_CMD;
	frame.edx.part.high = rpc->channel;
	frame.esi.word = rpc->cookie1;
	frame.edi.word = rpc->cookie2;

	vm_cmd(&frame);

	if ((frame.ecx.part.high & VM_RPC_REPLY_SUCCESS) == 0) {
		DPRINTF("vmware: sending length failed, eax=%08x, ecx=%08x\n",
		    frame.eax.word, frame.ecx.word);
		return EIO;
	}

	if (length == 0)
		return 0; /* Only need to poke once if command is null. */

	/* Send the command using enhanced RPC. */
	bzero(&frame, sizeof(frame));
	frame.eax.word = VM_MAGIC;
	frame.ebx.word = VM_RPC_ENH_DATA;
	frame.ecx.word = length;
	frame.edx.part.low  = VM_PORT_RPC;
	frame.edx.part.high = rpc->channel;
	frame.ebp.word = rpc->cookie1;
	frame.edi.word = rpc->cookie2;
#ifdef __amd64__
	frame.esi.quad = (uint64_t)buf;
#else
	frame.esi.word = (uint32_t)buf;
#endif

	vm_outs(&frame);

	if (frame.ebx.word != VM_RPC_ENH_DATA) {
		/* open-vm-tools retries on VM_RPC_REPLY_CHECKPOINT */
		DPRINTF("vmware: send failed, ebx=%08x\n", frame.ebx.word);
		return EIO;
	}

	return 0;
}

int
vm_rpc_send_str(const struct vm_rpc *rpc, const uint8_t *str)
{
	return vm_rpc_send(rpc, str, strlen(str));
}

int
vm_rpc_get_data(const struct vm_rpc *rpc, char *data, uint32_t length,
    uint16_t dataid)
{
	struct vm_backdoor frame;

	/* Get data using enhanced RPC. */
	bzero(&frame, sizeof(frame));
	frame.eax.word      = VM_MAGIC;
	frame.ebx.word      = VM_RPC_ENH_DATA;
	frame.ecx.word      = length;
	frame.edx.part.low  = VM_PORT_RPC;
	frame.edx.part.high = rpc->channel;
	frame.esi.word      = rpc->cookie1;
#ifdef __amd64__
	frame.edi.quad      = (uint64_t)data;
#else
	frame.edi.word      = (uint32_t)data;
#endif
	frame.ebp.word      = rpc->cookie2;

	vm_ins(&frame);

	/* NUL-terminate the data */
	data[length] = '\0';

	if (frame.ebx.word != VM_RPC_ENH_DATA) {
		DPRINTF("vmware: get data failed, ebx=%08x\n",
		    frame.ebx.word);
		return EIO;
	}

	/* Acknowledge data received. */
	bzero(&frame, sizeof(frame));
	frame.eax.word      = VM_MAGIC;
	frame.ebx.word      = dataid;
	frame.ecx.part.low  = VM_CMD_RPC;
	frame.ecx.part.high = VM_RPC_GET_END;
	frame.edx.part.low  = VM_PORT_CMD;
	frame.edx.part.high = rpc->channel;
	frame.esi.word      = rpc->cookie1;
	frame.edi.word      = rpc->cookie2;

	vm_cmd(&frame);

	if (frame.ecx.part.high == 0) {
		DPRINTF("vmware: ack data failed, eax=%08x, ecx=%08x\n",
		    frame.eax.word, frame.ecx.word);
		return EIO;
	}

	return 0;
}

int
vm_rpc_get_length(const struct vm_rpc *rpc, uint32_t *length, uint16_t *dataid)
{
	struct vm_backdoor frame;

	bzero(&frame, sizeof(frame));
	frame.eax.word      = VM_MAGIC;
	frame.ebx.word      = 0;
	frame.ecx.part.low  = VM_CMD_RPC;
	frame.ecx.part.high = VM_RPC_GET_LENGTH;
	frame.edx.part.low  = VM_PORT_CMD;
	frame.edx.part.high = rpc->channel;
	frame.esi.word      = rpc->cookie1;
	frame.edi.word      = rpc->cookie2;

	vm_cmd(&frame);

	if ((frame.ecx.part.high & VM_RPC_REPLY_SUCCESS) == 0) {
		DPRINTF("vmware: get length failed, eax=%08x, ecx=%08x\n",
		    frame.eax.word, frame.ecx.word);
		return EIO;
	}
	if ((frame.ecx.part.high & VM_RPC_REPLY_DORECV) == 0) {
		*length = 0;
		*dataid = 0;
	} else {
		*length = frame.ebx.word;
		*dataid = frame.edx.part.high;
	}

	return 0;
}

int
vm_rpci_response_successful(struct vmt_softc *sc)
{
	return (sc->sc_rpc_buf[0] == '1' && sc->sc_rpc_buf[1] == ' ');
}

int
vm_rpc_send_rpci_tx_buf(struct vmt_softc *sc, const uint8_t *buf,
    uint32_t length)
{
	struct vm_rpc rpci;
	u_int32_t rlen;
	u_int16_t ack;
	int result = 0;

	if (vm_rpc_open(&rpci, VM_RPC_OPEN_RPCI) != 0) {
		DPRINTF("%s: rpci channel open failed\n", DEVNAME(sc));
		return EIO;
	}

	if (vm_rpc_send(&rpci, sc->sc_rpc_buf, length) != 0) {
		DPRINTF("%s: unable to send rpci command\n", DEVNAME(sc));
		result = EIO;
		goto out;
	}

	if (vm_rpc_get_length(&rpci, &rlen, &ack) != 0) {
		DPRINTF("%s: failed to get length of rpci response data\n",
		    DEVNAME(sc));
		result = EIO;
		goto out;
	}

	if (rlen > 0) {
		if (rlen >= VMT_RPC_BUFLEN) {
			rlen = VMT_RPC_BUFLEN - 1;
		}

		if (vm_rpc_get_data(&rpci, sc->sc_rpc_buf, rlen, ack) != 0) {
			DPRINTF("%s: failed to get rpci response data\n",
			    DEVNAME(sc));
			result = EIO;
			goto out;
		}
	}

out:
	if (vm_rpc_close(&rpci) != 0) {
		DPRINTF("%s: unable to close rpci channel\n", DEVNAME(sc));
	}

	return result;
}

int
vm_rpc_send_rpci_tx(struct vmt_softc *sc, const char *fmt, ...)
{
	va_list args;
	int len;

	va_start(args, fmt);
	len = vsnprintf(sc->sc_rpc_buf, VMT_RPC_BUFLEN, fmt, args);
	va_end(args);

	if (len >= VMT_RPC_BUFLEN) {
		DPRINTF("%s: rpci command didn't fit in buffer\n", DEVNAME(sc));
		return EIO;
	}

	return vm_rpc_send_rpci_tx_buf(sc, sc->sc_rpc_buf, len);
}

#if 0
	struct vm_backdoor frame;

	bzero(&frame, sizeof(frame));

	frame.eax.word = VM_MAGIC;
	frame.ecx.part.low = VM_CMD_GET_VERSION;
	frame.edx.part.low  = VM_PORT_CMD;

	printf("\n");
	printf("eax 0x%08x\n", frame.eax.word);
	printf("ebx 0x%08x\n", frame.ebx.word);
	printf("ecx 0x%08x\n", frame.ecx.word);
	printf("edx 0x%08x\n", frame.edx.word);
	printf("ebp 0x%08x\n", frame.ebp.word);
	printf("edi 0x%08x\n", frame.edi.word);
	printf("esi 0x%08x\n", frame.esi.word);

	vm_cmd(&frame);

	printf("-\n");
	printf("eax 0x%08x\n", frame.eax.word);
	printf("ebx 0x%08x\n", frame.ebx.word);
	printf("ecx 0x%08x\n", frame.ecx.word);
	printf("edx 0x%08x\n", frame.edx.word);
	printf("ebp 0x%08x\n", frame.ebp.word);
	printf("edi 0x%08x\n", frame.edi.word);
	printf("esi 0x%08x\n", frame.esi.word);
#endif

/*
 * Notes on tracing backdoor activity in vmware-guestd:
 *
 * - Find the addresses of the inl / rep insb / rep outsb
 *   instructions used to perform backdoor operations.
 *   One way to do this is to disassemble vmware-guestd:
 *
 *   $ objdump -S /emul/freebsd/sbin/vmware-guestd > vmware-guestd.S
 *
 *   and search for '<tab>in ' in the resulting file.  The rep insb and
 *   rep outsb code is directly below that.
 *
 * - Run vmware-guestd under gdb, setting up breakpoints as follows:
 *   (the addresses shown here are the ones from VMware-server-1.0.10-203137,
 *   the last version that actually works in FreeBSD emulation on OpenBSD)
 *
 * break *0x805497b   (address of 'in' instruction)
 * commands 1
 * silent
 * echo INOUT\n
 * print/x $ecx
 * print/x $ebx
 * print/x $edx
 * continue
 * end
 * break *0x805497c   (address of instruction after 'in')
 * commands 2
 * silent
 * echo ===\n
 * print/x $ecx
 * print/x $ebx
 * print/x $edx
 * echo \n
 * continue
 * end
 * break *0x80549b7   (address of instruction before 'rep insb')
 * commands 3
 * silent
 * set variable $inaddr = $edi
 * set variable $incount = $ecx
 * continue
 * end
 * break *0x80549ba   (address of instruction after 'rep insb')
 * commands 4
 * silent
 * echo IN\n
 * print $incount
 * x/s $inaddr
 * echo \n
 * continue
 * end
 * break *0x80549fb    (address of instruction before 'rep outsb')
 * commands 5
 * silent
 * echo OUT\n
 * print $ecx
 * x/s $esi
 * echo \n
 * continue
 * end
 *
 * This will produce a log of the backdoor operations, including the
 * data sent and received and the relevant register values.  You can then
 * match the register values to the various constants in this file.
 */
@


1.30
log
@Add pvbus(4), a pseudo-bus to attach non-PCI paravirtual devices and buses.
vmt(4) is moved from mainbus0 to pvbus0, more devices will follow.

OK sf@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.29 2015/03/14 03:38:46 jsg Exp $ */
@


1.29
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.28 2015/02/07 01:19:40 deraadt Exp $ */
d229 2
d321 3
@


1.28
log
@New framework that allows hibernate to pass in entropy from it's fresh
boot.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.27 2014/12/20 11:27:18 reyk Exp $ */
a43 1
#include <dev/vmtvar.h>
@


1.27
log
@Cleanup vmt(4) by changing an ugly if statement for received commands
into a table of callbacks.  Additionally, turn printfs into DPRINTFs
to make the driver less chatty by default.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.26 2014/12/19 15:14:48 reyk Exp $ */
d390 1
a390 1
	resume_randomness();
@


1.26
log
@shuffle function declarations a bit;  stylistic changes only.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.25 2014/12/19 15:07:33 reyk Exp $ */
d178 7
a184 1
#define DEVNAME(_s)	((_s)->sc_dev.dv_xname)
a211 1
void	 vmt_tclo_tick(void *);
d218 50
d361 1
a361 1
		printf("%s: unable to establish tick\n", DEVNAME(sc));
d416 1
a416 1
		printf("%s: unable to set guest uptime", DEVNAME(sc));
d429 1
a429 1
			printf("%s: unable to set hostname", DEVNAME(sc));
d444 1
a444 1
			printf("%s: unable to set full guest OS", DEVNAME(sc));
d456 1
a456 1
			printf("%s: unable to set guest OS", DEVNAME(sc));
d504 2
a505 1
		printf("%s: unable to send state change result\n", DEVNAME(sc));
d543 1
a543 1
		printf("%s: failed to disable hgfs server capability\n",
d548 1
a548 1
		printf("%s: failed to send shutdown ping\n", DEVNAME(sc));
d555 203
d773 1
a773 1
			printf("%s: unable to reopen TCLO channel\n",
d781 2
a782 1
			printf("%s: failed to send reset reply\n", DEVNAME(sc));
d792 1
a792 1
			printf("%s: failed to send TCLO outgoing ping\n",
d800 1
a800 1
		printf("%s: failed to get length of incoming TCLO data\n",
d815 1
a815 1
		printf("%s: failed to get incoming TCLO data\n", DEVNAME(sc));
d824 1
a824 154
	if (strcmp(sc->sc_rpc_buf, "reset") == 0) {

		if (sc->sc_rpc_error != 0) {
			printf("%s: resetting rpc\n", DEVNAME(sc));
			vm_rpc_close(&sc->sc_tclo_rpc);
			/* reopen and send the reset reply next time around */
			goto out;
		}

		if (vm_rpc_send_str(&sc->sc_tclo_rpc,
		    VM_RPC_RESET_REPLY) != 0) {
			printf("%s: failed to send reset reply\n", DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}

	} else if (strcmp(sc->sc_rpc_buf, "ping") == 0) {

		vmt_update_guest_info(sc);
		if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
			printf("%s: error sending ping response\n",
			    DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}

	} else if (strcmp(sc->sc_rpc_buf, "OS_Halt") == 0) {
		vmt_do_shutdown(sc);
	} else if (strcmp(sc->sc_rpc_buf, "OS_Reboot") == 0) {
		vmt_do_reboot(sc);
	} else if (strcmp(sc->sc_rpc_buf, "OS_PowerOn") == 0) {
		vmt_tclo_state_change_success(sc, 1, VM_STATE_CHANGE_POWERON);
		if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
			printf("%s: error sending poweron response\n",
			    DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}
	} else if (strcmp(sc->sc_rpc_buf, "OS_Suspend") == 0) {
		log(LOG_KERN | LOG_NOTICE,
		    "VMware guest entering suspended state\n");

		suspend_randomness();

		vmt_tclo_state_change_success(sc, 1, VM_STATE_CHANGE_SUSPEND);
		if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
			printf("%s: error sending suspend response\n",
			    DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}
	} else if (strcmp(sc->sc_rpc_buf, "OS_Resume") == 0) {
		log(LOG_KERN | LOG_NOTICE,
		    "VMware guest resuming from suspended state\n");

		/* force guest info update */
		sc->sc_hostname[0] = '\0';
		sc->sc_set_guest_os = 0;
		vmt_update_guest_info(sc);
		vmt_resume();

		vmt_tclo_state_change_success(sc, 1, VM_STATE_CHANGE_RESUME);
		if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
			printf("%s: error sending resume response\n",
			    DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}
	} else if (strcmp(sc->sc_rpc_buf, "Capabilities_Register") == 0) {

		/* don't know if this is important at all */
		if (vm_rpc_send_rpci_tx(sc,
		    "vmx.capability.unified_loop toolbox") != 0) {
			printf("%s: unable to set unified loop\n", DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}
		if (vm_rpci_response_successful(sc) == 0) {
			printf("%s: host rejected unified loop setting\n",
			    DEVNAME(sc));
		}

		/* the trailing space is apparently important here */
		if (vm_rpc_send_rpci_tx(sc,
		    "tools.capability.statechange ") != 0) {
			printf("%s: unable to send statechange capability\n",
			    DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}
		if (vm_rpci_response_successful(sc) == 0) {
			printf("%s: host rejected statechange capability\n",
			    DEVNAME(sc));
		}

		if (vm_rpc_send_rpci_tx(sc, "tools.set.version %u",
		    VM_VERSION_UNMANAGED) != 0) {
			printf("%s: unable to set tools version\n",
			    DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}

		vmt_update_guest_uptime(sc);

		if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
			printf("%s: error sending capabilities_register"
			    " response\n", DEVNAME(sc));
			sc->sc_rpc_error = 1;
		}
	} else if (strcmp(sc->sc_rpc_buf, "Set_Option broadcastIP 1") == 0) {
		struct ifnet *iface;
		struct sockaddr_in *guest_ip;

		/* find first available ipv4 address */
		guest_ip = NULL;
		TAILQ_FOREACH(iface, &ifnet, if_list) {
			struct ifaddr *iface_addr;

			/* skip loopback */
			if (strncmp(iface->if_xname, "lo", 2) == 0 &&
			    iface->if_xname[2] >= '0' &&
			    iface->if_xname[2] <= '9') {
				continue;
			}

			TAILQ_FOREACH(iface_addr, &iface->if_addrlist,
			    ifa_list) {
				if (iface_addr->ifa_addr->sa_family != AF_INET)
					continue;

				guest_ip = satosin(iface_addr->ifa_addr);
				break;
			}
		}

		if (guest_ip != NULL) {
			char ip[INET_ADDRSTRLEN];

			inet_ntop(AF_INET, &guest_ip->sin_addr, ip, sizeof(ip));
			if (vm_rpc_send_rpci_tx(sc, "info-set guestinfo.ip %s",
			    ip) != 0) {
				printf("%s: unable to send guest IP address\n",
				    DEVNAME(sc));
				sc->sc_rpc_error = 1;
			}

			if (vm_rpc_send_str(&sc->sc_tclo_rpc,
			    VM_RPC_REPLY_OK) != 0) {
				printf("%s: error sending broadcastIP"
				    " response\n", DEVNAME(sc));
				sc->sc_rpc_error = 1;
			}
		} else {
			if (vm_rpc_send_str(&sc->sc_tclo_rpc,
			    VM_RPC_REPLY_ERROR_IP_ADDR) != 0) {
				printf("%s: error sending broadcastIP"
				    " error response\n", DEVNAME(sc));
				sc->sc_rpc_error = 1;
			}
		}
	} else {
d827 1
a827 1
			printf("%s: error sending unknown command reply\n",
d934 1
a934 1
		printf("vmware: open failed, eax=%08x, ecx=%08x, edx=%08x\n",
d964 1
a964 1
		printf("vmware: close failed, eax=%08x, ecx=%08x\n",
d995 1
a995 1
		printf("vmware: sending length failed, eax=%08x, ecx=%08x\n",
d1022 1
a1022 1
		printf("vmware: send failed, ebx=%08x\n", frame.ebx.word);
d1062 1
a1062 1
		printf("vmware: get data failed, ebx=%08x\n",
d1081 1
a1081 1
		printf("vmware: ack data failed, eax=%08x, ecx=%08x\n",
d1107 1
a1107 1
		printf("vmware: get length failed, eax=%08x, ecx=%08x\n",
d1138 1
a1138 1
		printf("%s: rpci channel open failed\n", DEVNAME(sc));
d1143 1
a1143 1
		printf("%s: unable to send rpci command\n", DEVNAME(sc));
d1149 1
a1149 1
		printf("%s: failed to get length of rpci response data\n",
d1161 1
a1161 1
			printf("%s: failed to get rpci response data\n",
d1170 1
a1170 1
		printf("%s: unable to close rpci channel\n", DEVNAME(sc));
d1187 1
a1187 1
		printf("%s: rpci command didn't fit in buffer\n", DEVNAME(sc));
@


1.25
log
@No need to include sys/types.h when sys/param.h is already included.
While here, sort includes a bit. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.24 2014/12/18 19:31:37 reyk Exp $ */
a160 4
int	vmt_match(struct device *, void *, void *);
void	vmt_attach(struct device *, struct device *, void *);
int	vmt_activate(struct device *, int);

d180 33
a225 29

void vm_cmd(struct vm_backdoor *);
void vm_ins(struct vm_backdoor *);
void vm_outs(struct vm_backdoor *);

/* Functions for communicating with the VM Host. */
int vm_rpc_open(struct vm_rpc *, uint32_t);
int vm_rpc_close(struct vm_rpc *);
int vm_rpc_send(const struct vm_rpc *, const uint8_t *, uint32_t);
int vm_rpc_send_str(const struct vm_rpc *, const uint8_t *);
int vm_rpc_get_length(const struct vm_rpc *, uint32_t *, uint16_t *);
int vm_rpc_get_data(const struct vm_rpc *, char *, uint32_t, uint16_t);
int vm_rpc_send_rpci_tx_buf(struct vmt_softc *, const uint8_t *, uint32_t);
int vm_rpc_send_rpci_tx(struct vmt_softc *, const char *, ...)
	__attribute__((__format__(__kprintf__,2,3)));
int vm_rpci_response_successful(struct vmt_softc *);

void vmt_probe_cmd(struct vm_backdoor *, uint16_t);
void vmt_tclo_state_change_success(struct vmt_softc *, int, char);
void vmt_do_reboot(struct vmt_softc *);
void vmt_do_shutdown(struct vmt_softc *);
void vmt_shutdown(void *);

void vmt_update_guest_info(struct vmt_softc *);
void vmt_update_guest_uptime(struct vmt_softc *);

void vmt_tick(void *);
void vmt_tclo_tick(void *);
void vmt_resume(void);
@


1.24
log
@Wrap more of these long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.23 2014/12/18 19:22:21 deraadt Exp $ */
a23 2
#include <dev/vmtvar.h>

a31 1
#include <sys/types.h>
d38 1
d42 1
d44 1
@


1.23
log
@wrap unreasonably long lines
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.22 2014/12/18 19:18:22 reyk Exp $ */
d289 2
a290 1
	if (vm_rpc_send_rpci_tx(sc, "tools.capability.hgfs_server toolbox 1") != 0) {
d380 3
a382 2
	 * we're supposed to pass the full network address information back here,
	 * but that involves xdr (sunrpc) data encoding, which seems a bit unreasonable.
d387 2
a388 1
		    VM_GUEST_INFO_OS_NAME_FULL, ostype, osrelease, osversion) != 0) {
d394 3
a396 2
		 * host doesn't like it if we send an OS name it doesn't recognise,
		 * so use the closest match, which happens to be FreeBSD.
d398 1
d485 2
a486 1
	if (vm_rpc_send_rpci_tx(sc, "tools.capability.hgfs_server toolbox 0") != 0) {
d514 2
a515 1
			printf("%s: unable to reopen TCLO channel\n", DEVNAME(sc));
d520 2
a521 1
		if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_RESET_REPLY) != 0) {
d573 2
a574 1
		if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_RESET_REPLY) != 0) {
d583 2
a584 1
			printf("%s: error sending ping response\n", DEVNAME(sc));
d595 2
a596 1
			printf("%s: error sending poweron response\n", DEVNAME(sc));
d607 2
a608 1
			printf("%s: error sending suspend response\n", DEVNAME(sc));
d641 2
a642 1
		if (vm_rpc_send_rpci_tx(sc, "tools.capability.statechange ") != 0) {
d654 2
a655 1
			printf("%s: unable to set tools version\n", DEVNAME(sc));
d662 2
a663 2
			printf("%s: error sending capabilities_register response\n",
			    DEVNAME(sc));
d677 2
a678 1
			    iface->if_xname[2] >= '0' && iface->if_xname[2] <= '9') {
d682 3
a684 2
			TAILQ_FOREACH(iface_addr, &iface->if_addrlist, ifa_list) {
				if (iface_addr->ifa_addr->sa_family != AF_INET) {
a685 1
				}
d703 4
a706 3
			if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_OK) != 0) {
				printf("%s: error sending broadcastIP response\n",
				    DEVNAME(sc));
d712 2
a713 2
				printf("%s: error sending broadcastIP error response\n",
				    DEVNAME(sc));
d718 2
a719 1
		if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_ERROR) != 0) {
d1022 2
a1023 1
vm_rpc_send_rpci_tx_buf(struct vmt_softc *sc, const uint8_t *buf, uint32_t length)
@


1.22
log
@The VM host might send multiple messages at once but vmt(4) only
processed one of time per second.  Change the code to process all
queued messages without delay immediately.  This fixes two things: a)
the vmt time sensor is available on boot when ntpd -s is loaded and b)
the random seeding on resume (OS_Resume message) is executed almost
immediately and not delayed by about 20 seconds.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.21 2014/12/18 16:30:29 deraadt Exp $ */
d457 2
a458 1
	log(LOG_KERN | LOG_NOTICE, "Shutting down in response to request from VMware host\n");
d470 2
a471 1
	log(LOG_KERN | LOG_NOTICE, "Rebooting in response to request from VMware host\n");
d481 2
a482 1
		printf("%s: failed to disable hgfs server capability\n", DEVNAME(sc));
d524 2
a525 1
			printf("%s: failed to send TCLO outgoing ping\n", DEVNAME(sc));
d532 2
a533 1
		printf("%s: failed to get length of incoming TCLO data\n", DEVNAME(sc));
d589 2
a590 1
		log(LOG_KERN | LOG_NOTICE, "VMware guest entering suspended state\n");
d600 2
a601 1
		log(LOG_KERN | LOG_NOTICE, "VMware guest resuming from suspended state\n");
d611 2
a612 1
			printf("%s: error sending resume response\n", DEVNAME(sc));
d618 2
a619 1
		if (vm_rpc_send_rpci_tx(sc, "vmx.capability.unified_loop toolbox") != 0) {
d624 2
a625 1
			printf("%s: host rejected unified loop setting\n", DEVNAME(sc));
d630 2
a631 1
			printf("%s: unable to send statechange capability\n", DEVNAME(sc));
d635 2
a636 1
			printf("%s: host rejected statechange capability\n", DEVNAME(sc));
d639 2
a640 1
		if (vm_rpc_send_rpci_tx(sc, "tools.set.version %u", VM_VERSION_UNMANAGED) != 0) {
d648 2
a649 1
			printf("%s: error sending capabilities_register response\n", DEVNAME(sc));
d683 2
a684 1
				printf("%s: unable to send guest IP address\n", DEVNAME(sc));
d689 2
a690 1
				printf("%s: error sending broadcastIP response\n", DEVNAME(sc));
d694 2
a695 1
			if (vm_rpc_send_str(&sc->sc_tclo_rpc, VM_RPC_REPLY_ERROR_IP_ADDR) != 0) {
d703 2
a704 1
			printf("%s: error sending unknown command reply\n", DEVNAME(sc));
d811 1
a811 1
			frame.eax.word, frame.ecx.word, frame.edx.word);
d841 1
a841 1
				frame.eax.word, frame.ecx.word);
d872 1
a872 1
				frame.eax.word, frame.ecx.word);
d939 1
a939 1
				frame.ebx.word);
d958 1
a958 1
				frame.eax.word, frame.ecx.word);
d984 1
a984 1
				frame.eax.word, frame.ecx.word);
d1024 2
a1025 1
		printf("%s: failed to get length of rpci response data\n", DEVNAME(sc));
d1036 2
a1037 1
			printf("%s: failed to get rpci response data\n", DEVNAME(sc));
@


1.21
log
@When a VM resume occurs, request information from the VM and enqueue as
entropy - then do a RNG resume.
If the VM signals a boot/reboot/suspend action, push the RNG into suspend.
ok reyk djm
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.20 2014/12/05 15:50:03 mpi Exp $ */
d495 4
d548 3
d691 5
d697 1
a697 1
	timeout_add_sec(&sc->sc_tclo_tick, 1);
@


1.20
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.19 2014/07/12 18:48:51 tedu Exp $ */
d44 1
d225 1
d317 20
d346 3
d455 2
d467 2
d579 2
d593 1
@


1.19
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.18 2014/07/11 08:18:31 guenther Exp $ */
d42 1
@


1.18
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.17 2014/03/29 18:09:30 guenther Exp $ */
d311 1
a311 1
	free(sc->sc_rpc_buf, M_DEVBUF);
@


1.17
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.16 2013/11/11 09:15:34 mpi Exp $ */
d430 1
a430 1
	psignal(initproc, SIGUSR2);
d440 1
a440 1
	psignal(initproc, SIGINT);
@


1.16
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.15 2013/10/26 21:05:09 deraadt Exp $ */
d656 1
a656 1
	__asm__ __volatile__ (			\
d680 1
a680 1
	__asm__ __volatile__ (			\
@


1.15
log
@Use the "activate" framework rather a shutdown hook
ok jmatthew dlg pelikan
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.14 2013/10/14 00:20:49 dlg Exp $ */
d624 3
d628 1
a628 1
			    inet_ntoa(guest_ip->sin_addr)) != 0) {
@


1.14
log
@defer the first update of the sensor as late in the boot process we can
but running it from the mountroot hooks. this means the clock will be
attached and therefore better to compare the hypervisors clock against.
before we used to get ridiculous timedeltas, which if ntpd used to set the
time with on startup (ie, ntpd -s) would make us think we were in 2057 or
2104.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.13 2013/07/03 15:26:02 sf Exp $ */
d161 1
d185 3
a187 1
	vmt_attach
d216 1
a222 1
void vmt_shutdown_hook(void *);
a290 2
	shutdownhook_establish(vmt_shutdown_hook, sc);

d314 14
d444 1
a444 1
vmt_shutdown_hook(void *arg)
@


1.13
log
@cast time_t to long long, time_t is signed, tv_nsec is long

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.12 2012/09/11 04:40:14 dtucker Exp $ */
d300 2
a301 1
	timeout_add_sec(&sc->sc_tick, 1);
@


1.12
log
@Check that the host supports GET_SPEED as well as GET_VERSION before deciding
vmt_probe has succeeded.

qemu supports GET_VERSION but not the RPC protocol so the probe succeeds
but the attach fails, resulting in "vmt0: failed to open backdoor RPC
channel (TCLO protocol)".  All known versions of vmware support GET_SPEED
and no known qemu versions do, so this prevents it from attempting to
attach (and failing) on qemu while still working on vmware.

with & ok jmatthew@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.11 2011/01/27 21:29:25 dtucker Exp $ */
d316 2
a317 2
	if (vm_rpc_send_rpci_tx(sc, "SetGuestInfo  %d %lu00",
	    VM_GUEST_INFO_UPTIME, time_uptime) != 0) {
@


1.11
log
@Fix newlines for error on attach case.  with & ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.10 2010/11/03 10:15:23 dlg Exp $ */
d209 1
d223 15
d243 1
a243 11
	bzero(&frame, sizeof(frame));

	frame.eax.word = VM_MAGIC;
	frame.ebx.word = ~VM_MAGIC;
	frame.ecx.part.low = VM_CMD_GET_VERSION;
	frame.ecx.part.high = 0xffff;
	frame.edx.part.low  = VM_PORT_CMD;
	frame.edx.part.high = 0;

	vm_cmd(&frame);

d246 4
@


1.10
log
@only let vmt match and therefore attach if mainbus is specifically asking
for vmt to attach after vmt_probe succeeds. this prevents vmt from
appearing at other attach points hanging off mainbus.

found by phessler@@ and debugged gently by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.9 2010/10/26 01:16:11 dlg Exp $ */
d258 1
d261 2
a262 1
		printf(": unable to allocate buffer for RPC\n");
d267 2
a268 1
		printf(": failed to open backdoor RPC channel (TCLO protocol)\n");
a295 1
	printf("\n");
@


1.9
log
@log suspends and resumes. resend hostname and address info from the guest
to the host on resume.

from jonathan matthew
reviewed and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.8 2010/10/26 00:57:21 dlg Exp $ */
d248 3
a250 2
	/* we cant get here unless vmt_probe previously succeeded */
	return (1);
@


1.8
log
@big update to vmware tools functionality from jonathan matthew.

vmt(4) will now:
- initiate shutdown by signalling init with SIGUSR2 when requested by
the host.
- initiate a reboot by signalling init with SIGINT when requested by
the host.
- report the guests hostname to the host
- report the guests first non-loopback IP address to the host
- report the guests uptime to the host
- update the guests timedelta sensor using the 64bit rpc

vmt(4) now does the majority of what people actually need.

this has been tested on vmware server 2.0.2 with linux as the host,
vmware esx 4.0, and vmware esx 4.1
testing by jonathan matthew and myself. previous versions of the changes
were also tested by johan allard and srebrenko sehic.
code reviewed by and ok matthew@@
thanks moch and johan :)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.7 2009/12/28 14:25:34 dlg Exp $ */
d105 2
d515 21
@


1.7
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.6 2009/12/28 14:22:09 dlg Exp $ */
d37 6
d64 1
a64 1
#define VM_CMD_GET_GUI_OPTIONS  	0x0d
d71 1
a71 1
#define VM_CMD_GET_TIME			0x17
d73 1
d85 37
a121 3
#define VM_RPC_OPEN_RPCI  	0x49435052UL /* with VM_RPC_OPEN. */
#define VM_RPC_OPEN_RPCI_ENH  	0xC9435052UL /* with VM_RPC_OPEN, enhanced. */
#define VM_RPC_ENH_DATA  	0x00010000UL /* with enhanced RPC data calls. */
d163 1
a163 1
	struct vm_rpc		sc_rpc;
d165 3
d171 1
d184 1
a184 1
 
d196 1
a196 1
int vm_rpc_open(struct vm_rpc *);
d199 1
d202 11
d215 2
a253 3
	size_t len;
	u_int32_t rlen;
	u_int16_t ack;
d261 2
a262 2
	if (vm_rpc_open(&sc->sc_rpc) != 0) {
		printf(": failed to open backdoor RPC channel\n");
d266 4
a269 16
	len = snprintf(sc->sc_rpc_buf, VMT_RPC_BUFLEN, "tools.set.version %u ",
	    VM_VERSION_UNMANAGED);
#ifdef DIAGNOSTIC
	if (len > VMT_RPC_BUFLEN)
		panic("vmt rpc buffer is too small");
#endif

	if (vm_rpc_send(&sc->sc_rpc, sc->sc_rpc_buf, len) != 0) {
		printf("%s: failed to send version\n", DEVNAME(sc));
		return;
	}

	if (vm_rpc_get_length(&sc->sc_rpc, &rlen, &ack) != 0) {
		printf("%s: failed to get length of version reply\n",
		    DEVNAME(sc));
		return;
d272 1
a272 16
	if (rlen > VMT_RPC_BUFLEN) {
		printf("%s: reply is too large for version buffer\n",
		    DEVNAME(sc));
		return;
	}

	bzero(sc->sc_rpc_buf, VMT_RPC_BUFLEN);
	if (vm_rpc_get_data(&sc->sc_rpc, sc->sc_rpc_buf, rlen, ack) != 0) {
		printf("%s: failed to get version reply\n", DEVNAME(sc));
		return;
	}

	if (sc->sc_rpc_buf[0] != '1' && sc->sc_rpc_buf[1] != ' ') {
		printf("%s: setting version failed\n", DEVNAME(sc));
		return;
	}
d286 4
d298 50
a354 4
	size_t len;
	u_int32_t rlen;
	u_int16_t ack;

d359 1
a359 1
	frame.ecx.part.low = VM_CMD_GET_TIME;
d363 10
a372 1
	if (frame.eax.word == 0xffffffff) {
a373 1
		goto out;
d376 25
a400 2
	host.tv_sec = frame.eax.word;
	host.tv_usec = frame.ebx.word;
d402 5
a406 1
	timersub(guest, &host, &diff);
d408 3
a410 3
	sc->sc_sensor.value = (u_int64_t)diff.tv_sec * 1000000000LL +
	    (u_int64_t)diff.tv_usec * 1000LL;
	sc->sc_sensor.status = SENSOR_S_OK;
d412 8
a419 2
	if (strncmp(sc->sc_hostname, hostname, sizeof(sc->sc_hostname)) != 0) {
		strlcpy(sc->sc_hostname, hostname, sizeof(sc->sc_hostname));
d421 3
a423 6
		len = snprintf(sc->sc_rpc_buf, VMT_RPC_BUFLEN,
		    "info-set guestinfo.ip %s ", "192.168.1.1");
#ifdef DIAGNOSTIC
		if (len > VMT_RPC_BUFLEN)
			panic("vmt rpc buffer is too small");
#endif
d425 2
a426 3
		if (vm_rpc_send(&sc->sc_rpc, sc->sc_rpc_buf, len) != 0) {
			goto out;
		}
d428 6
a433 3
		if (vm_rpc_get_length(&sc->sc_rpc, &rlen, &ack) != 0) {
			goto out;
		}
d435 7
a441 3
		bzero(sc->sc_rpc_buf, VMT_RPC_BUFLEN);
		if (vm_rpc_get_data(&sc->sc_rpc, sc->sc_rpc_buf,
		    rlen, ack) != 0) {
d445 6
a450 3
		if (sc->sc_rpc_buf[0] != '1' && sc->sc_rpc_buf[1] != ' ') {
			printf("%s: setting hostname failed\n", DEVNAME(sc));
			return;
d452 1
d454 6
a459 2
		printf("%s: hostname set to %s\n", DEVNAME(sc),
		    sc->sc_hostname);
d462 4
a465 4
	if (vm_rpc_get_length(&sc->sc_rpc, &rlen, &ack) != 0) {
		printf("%s: failed to get length of version reply\n",
		    DEVNAME(sc));
		return;
d468 2
a469 1
	if (rlen == 0)
d471 1
d473 7
a479 3
	if (vm_rpc_get_data(&sc->sc_rpc, sc->sc_rpc_buf, rlen, ack) != 0) {
		printf("%s: failed to get version reply\n", DEVNAME(sc));
		return;
d481 58
d540 55
a594 1
	printf("%s: \"%s\"\n", DEVNAME(sc), sc->sc_rpc_buf);
d597 1
a597 1
	timeout_add_sec(&sc->sc_tick, 15);
d676 1
a676 1
vm_rpc_open(struct vm_rpc *rpc)
d682 1
a682 1
	frame.ebx.word      = VM_RPC_OPEN_RPCI_ENH;
d691 1
d752 1
a752 1
	if (frame.ecx.part.high == 0) {
d766 1
a766 1
	frame.edx.part.low  = VM_PORT_RPC;  // XXX we are here
d779 1
d788 6
d816 3
d864 1
a864 1
	if (frame.ecx.part.high == 0) {
d869 29
d899 23
a921 2
	*length = frame.ebx.word;
	*dataid = frame.edx.part.high;
d923 6
a928 1
	return 0;
d931 17
d978 66
@


1.6
log
@tweak vmt to work on amd64 as well as i386. like i386, it is still
commented out in GENERIC. it needs more love.

diff by david cranshaw a long time ago. sorry it has taken so long
for me to look at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.5 2009/04/26 02:20:58 cnst Exp $ */
d141 1
a141 1
        NULL,
d351 4
a354 4
#define BACKDOOR_OP_I386(op, frame) \
	__asm__ __volatile__ (        \
		"pushal;"                   \
		"pushl %%eax;"              \
d370 3
a372 3
		"popl 0x00(%%eax);"         \
		"popal;"                    \
		::"a"(frame)                \
d375 21
a395 21
#define BACKDOOR_OP_AMD64(op, frame) \
	__asm__ __volatile__ (        \
		"pushq %%rbp;               \n\t" \
		"pushq %%rax;               \n\t" \
		"movq 0x30(%%rax), %%rbp;   \n\t"  \
		"movq 0x28(%%rax), %%rdi;   \n\t"  \
		"movq 0x20(%%rax), %%rsi;   \n\t"  \
		"movq 0x18(%%rax), %%rdx;   \n\t"  \
		"movq 0x10(%%rax), %%rcx;   \n\t"  \
		"movq 0x08(%%rax), %%rbx;   \n\t"  \
		"movq 0x00(%%rax), %%rax;   \n\t"  \
		op                         "\n\t"  \
		"xchgq %%rax, 0x00(%%rsp);  \n\t" \
		"movq %%rbp, 0x30(%%rax);   \n\t"  \
		"movq %%rdi, 0x28(%%rax);   \n\t"  \
		"movq %%rsi, 0x20(%%rax);   \n\t"  \
		"movq %%rdx, 0x18(%%rax);   \n\t"  \
		"movq %%rcx, 0x10(%%rax);   \n\t"  \
		"movq %%rbx, 0x08(%%rax);   \n\t"  \
		"popq 0x00(%%rax);          \n\t"  \
		"popq %%rbp;                \n\t"  \
d431 1
a431 1
  bzero(&frame, sizeof(frame));
d459 1
a459 1
  bzero(&frame, sizeof(frame));
d490 1
a490 1
  bzero(&frame, sizeof(frame));
d512 1
a512 1
  bzero(&frame, sizeof(frame));
d543 1
a543 1
  bzero(&frame, sizeof(frame));
d566 1
a566 1
  bzero(&frame, sizeof(frame));
d592 1
a592 1
  bzero(&frame, sizeof(frame));
@


1.5
log
@in ca_attach() there is no need to set .value and .flags of sensors to 0,
since autoconf(9) allocates softc with M_ZERO;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.4 2008/10/23 22:22:43 deraadt Exp $ */
d20 2
a21 2
#if !defined(__i386__)
#error vmt(4) is only supported on i386
d39 1
a39 1
#define VM_MAGIC			0x564D5868UL
d89 7
d104 2
a106 2
	union vm_reg edi;
	union vm_reg esi;
d351 5
a355 5
#define BACKDOOR_OP(op, frame)			\
	__asm__ __volatile__ (			\
		"pushal;"                       \
		"pushl %%eax;"			\
		"movl 0x18(%%eax), %%esi;"	\
d357 1
a357 1
		"movl 0x10(%%eax), %%ebp;"	\
d364 1
a364 1
		"movl %%esi, 0x18(%%eax);"	\
d366 1
a366 1
		"movl %%ebp, 0x10(%%eax);"	\
d370 29
a398 3
		"popl 0x00(%%eax);"		\
		"popal;"                        \
		::"a"(frame)			\
d401 7
d411 1
a411 1
	BACKDOOR_OP("inl (%%dx);", frame);
d417 1
a417 1
	BACKDOOR_OP("pushf; cld; rep insb; popf;", frame);
d423 1
a423 1
	BACKDOOR_OP("pushf; cld; rep outsb; popf;", frame);
d431 1
d441 1
a441 2
	if (frame.eax.word != 0 || frame.ecx.part.high != 1
				|| frame.edx.part.low != 0) {
d459 1
d466 1
a467 2
	frame.edi.word      = rpc->cookie2;
	frame.ebp.word      = 0;
d471 1
a471 2
	if (frame.eax.word != 0 || frame.ecx.part.high == 0
				|| frame.ecx.part.low != 0) {
d490 1
d502 1
a502 1
	if (frame.eax.word != 0 || frame.ecx.part.high == 0) {
d512 1
d516 1
a516 1
	frame.edx.part.low  = VM_PORT_RPC;
d518 5
d524 1
a524 2
	frame.edi.word = rpc->cookie2;
	frame.ebp.word = rpc->cookie1;
d543 1
d550 3
d554 1
d566 1
d578 1
a578 1
	if (frame.eax.word != 0 || frame.ecx.part.high == 0) {
d592 1
d604 1
a604 1
	if (frame.eax.word != 0 || frame.ecx.part.high == 0) {
@


1.4
log
@use the correct idiom for NFOO things which come from "foo.h" files
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.3 2008/09/10 14:01:23 blambert Exp $ */
a242 2
	sc->sc_sensor.value = 0LL;
	sc->sc_sensor.flags = 0;
@


1.3
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.2 2008/07/12 23:17:33 ckuethe Exp $ */
d205 1
a205 1
#if DIAGNOSTIC
d298 1
a298 1
#if DIAGNOSTIC
@


1.2
log
@reference vmt (openbsd) rather than vmware (xorg)
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: vmt.c,v 1.1 2008/07/08 05:22:00 dlg Exp $ */
d250 1
a250 1
	timeout_add(&sc->sc_tick, hz);
d343 1
a343 1
	timeout_add(&sc->sc_tick, hz * 15);
@


1.1
log
@vmt(4) is a kernel level implementation of the vmware tools.

it only provides the hosts machines clock as a timedelta sensor so far.

getting it into the tree so people can work on it as suggested by fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d21 1
a21 1
#error vmware(4) is only supported on i386
@

