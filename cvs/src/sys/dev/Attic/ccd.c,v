head	1.98;
access;
symbols
	OPENBSD_5_0:1.97.0.2
	OPENBSD_5_0_BASE:1.97
	OPENBSD_4_9:1.92.0.2
	OPENBSD_4_9_BASE:1.92
	OPENBSD_4_8:1.90.0.2
	OPENBSD_4_8_BASE:1.90
	OPENBSD_4_7:1.88.0.2
	OPENBSD_4_7_BASE:1.88
	OPENBSD_4_6:1.86.0.4
	OPENBSD_4_6_BASE:1.86
	OPENBSD_4_5:1.85.0.4
	OPENBSD_4_5_BASE:1.85
	OPENBSD_4_4:1.85.0.2
	OPENBSD_4_4_BASE:1.85
	OPENBSD_4_3:1.82.0.2
	OPENBSD_4_3_BASE:1.82
	OPENBSD_4_2:1.78.0.2
	OPENBSD_4_2_BASE:1.78
	OPENBSD_4_1:1.68.0.2
	OPENBSD_4_1_BASE:1.68
	OPENBSD_4_0:1.67.0.2
	OPENBSD_4_0_BASE:1.67
	OPENBSD_3_9:1.64.0.2
	OPENBSD_3_9_BASE:1.64
	OPENBSD_3_8:1.62.0.2
	OPENBSD_3_8_BASE:1.62
	OPENBSD_3_7:1.57.0.2
	OPENBSD_3_7_BASE:1.57
	OPENBSD_3_6:1.55.0.4
	OPENBSD_3_6_BASE:1.55
	SMP_SYNC_A:1.55
	SMP_SYNC_B:1.55
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.53.0.2
	OPENBSD_3_4_BASE:1.53
	UBC_SYNC_A:1.52
	OPENBSD_3_3:1.50.0.2
	OPENBSD_3_3_BASE:1.50
	OPENBSD_3_2:1.49.0.2
	OPENBSD_3_2_BASE:1.49
	OPENBSD_3_1:1.47.0.2
	OPENBSD_3_1_BASE:1.47
	UBC_SYNC_B:1.49
	UBC:1.46.0.2
	UBC_BASE:1.46
	OPENBSD_3_0:1.44.0.2
	OPENBSD_3_0_BASE:1.44
	OPENBSD_2_9_BASE:1.41
	OPENBSD_2_9:1.41.0.8
	OPENBSD_2_8:1.41.0.6
	OPENBSD_2_8_BASE:1.41
	OPENBSD_2_7:1.41.0.4
	OPENBSD_2_7_BASE:1.41
	SMP:1.41.0.2
	SMP_BASE:1.41
	kame_19991208:1.41
	OPENBSD_2_6:1.40.0.2
	OPENBSD_2_6_BASE:1.40
	OPENBSD_2_5:1.38.0.2
	OPENBSD_2_5_BASE:1.38
	OPENBSD_2_4:1.37.0.2
	OPENBSD_2_4_BASE:1.37
	OPENBSD_2_3:1.35.0.2
	OPENBSD_2_3_BASE:1.35
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.98
date	2011.10.06.20.49.28;	author deraadt;	state dead;
branches;
next	1.97;

1.97
date	2011.07.06.04.49.36;	author matthew;	state Exp;
branches;
next	1.96;

1.96
date	2011.06.30.16.28.05;	author matthew;	state Exp;
branches;
next	1.95;

1.95
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.94;

1.94
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.93;

1.93
date	2011.04.12.20.18.13;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.90;

1.90
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.88;

1.88
date	2009.08.24.08.51.18;	author jasper;	state Exp;
branches;
next	1.87;

1.87
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2009.06.04.05.57.27;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2008.07.01.04.15.59;	author ray;	state Exp;
branches;
next	1.84;

1.84
date	2008.06.15.00.36.40;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.14.10.55.20;	author mk;	state Exp;
branches;
next	1.82;

1.82
date	2007.09.12.18.45.14;	author mk;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.11.13.39.33;	author gilles;	state Exp;
branches;
next	1.80;

1.80
date	2007.09.08.17.59.23;	author gilles;	state Exp;
branches;
next	1.79;

1.79
date	2007.09.01.15.28.39;	author thib;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.07.05.29.43;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.05.00.38.20;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.28.12.32.13;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.18.19.06.56;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.06.06.41.42;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2007.03.30.15.19.05;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.29.15.03.42;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2006.08.12.18.08.11;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2006.07.20.18.06.44;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2006.07.20.15.42.09;	author mickey;	state Exp;
branches;
next	1.64;

1.64
date	2006.01.09.12.43.16;	author pedro;	state Exp;
branches;
next	1.63;

1.63
date	2005.09.13.17.26.16;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2005.05.22.19.40.51;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2005.05.12.17.16.06;	author niallo;	state Exp;
branches;
next	1.60;

1.60
date	2005.05.12.14.16.38;	author niallo;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.30.22.28.00;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.25.17.51.16;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2005.03.12.16.33.53;	author mickey;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2005.02.24.19.36.39;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.15.02.45.46;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.02.23.28.01;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2003.04.04.02.21.26;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2003.03.28.02.39.07;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2002.11.10.21.23.09;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2002.05.24.13.10.52;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.23.14.28.36;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2001.11.28.16.13.29;	author art;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.27.04.45.56;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.05.20.56.58;	author art;	state Exp;
branches;
next	1.41;

1.41
date	99.11.26.16.46.17;	author art;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	99.09.11.00.13.45;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	99.09.10.23.31.54;	author art;	state Exp;
branches;
next	1.38;

1.38
date	99.02.26.01.38.23;	author art;	state Exp;
branches;
next	1.37;

1.37
date	98.10.03.21.19.00;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	98.08.04.21.26.35;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	98.03.10.20.43.17;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	98.02.06.22.17.16;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	98.01.25.09.42.31;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	98.01.25.09.39.19;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	98.01.25.09.22.28;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	98.01.24.22.53.49;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	98.01.24.21.38.56;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	98.01.24.21.33.32;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	98.01.24.21.12.36;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	98.01.21.12.16.04;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	98.01.09.14.36.11;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	98.01.07.00.48.10;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	97.12.15.03.52.24;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.12.12.20.22.35;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	97.11.26.22.30.20;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	97.11.06.05.58.08;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	97.10.06.20.19.39;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.10.06.15.07.46;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	97.08.08.21.47.01;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.02.13.23.33.26;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	97.01.31.10.32.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.01.31.10.31.43;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.12.19.18.26.58;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.05.10.12.32.11;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.05.02.13.34.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.04.21.22.19.44;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.19.07.43.47;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.04.18.23.47.00;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.03.02.00.29.21;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.02.27.09.43.17;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.01.12.20.21.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.14.06.19.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.08.03.03.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.06.21.36.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches;
next	;

1.41.2.1
date	2001.07.04.10.40.09;	author niklas;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2001.11.13.21.09.59;	author niklas;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2002.03.28.12.29.44;	author niklas;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2003.03.28.00.38.09;	author niklas;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	2003.05.13.19.34.56;	author ho;	state Exp;
branches;
next	1.41.2.8;

1.41.2.8
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.41.2.9;

1.41.2.9
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	1.41.2.10;

1.41.2.10
date	2004.06.05.23.12.36;	author niklas;	state Exp;
branches;
next	;

1.46.2.1
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;

1.57.2.1
date	2005.05.22.21.36.27;	author brad;	state Exp;
branches;
next	;


desc
@@


1.98
log
@ccd goes to the attic
discussed with jsing and millert
@
text
@/*	$OpenBSD: ccd.c,v 1.97 2011/07/06 04:49:36 matthew Exp $	*/
/*	$NetBSD: ccd.c,v 1.33 1996/05/05 04:21:14 thorpej Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * Copyright (c) 1997 Niklas Hallqvist.
 * Copyright (c) 2005 Michael Shalayeff.
 * All rights reserved.
 * 
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: cd.c 1.6 90/11/28$
 *
 *	@@(#)cd.c	8.2 (Berkeley) 11/16/93
 */

/*
 * "Concatenated" disk driver.
 *
 * Dynamic configuration and disklabel support by:
 *	Jason R. Thorpe <thorpej@@nas.nasa.gov>
 *	Numerical Aerodynamic Simulation Facility
 *	Mail Stop 258-6
 *	NASA Ames Research Center
 *	Moffett Field, CA 94035
 *
 * Mirroring support based on code written by Satoshi Asami
 * and Nisha Talagala.
 */
/* #define	CCDDEBUG */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/errno.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/namei.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/disklabel.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/syslog.h>
#include <sys/fcntl.h>
#include <sys/vnode.h>
#include <sys/conf.h>
#include <sys/rwlock.h>
#include <sys/dkio.h>

#include <dev/ccdvar.h>

#ifdef __GNUC__
#define INLINE static __inline
#else
#define INLINE
#endif

/*
 * A concatenated disk is described after initialization by this structure.
 */
struct ccd_softc {
	struct disk	sc_dkdev;		/* generic disk device info */
	struct ccdgeom	sc_geom;		/* pseudo geometry info */
	struct ccdcinfo	*sc_cinfo;		/* component info */
	struct ccdiinfo	*sc_itable;		/* interleave table */
	char		sc_xname[8];		/* XXX external name */
	size_t		sc_size;		/* size of ccd */
	int		sc_flags;		/* flags */
	int		sc_cflags;		/* copy of ccd_flags */
	int		sc_ileave;		/* interleave */
	u_int		sc_nccdisks;		/* # of components */
	u_int		sc_nccunits;		/* # of components for data */
	struct rwlock	sc_rwlock;		/* lock */

};

/* sc_flags */
#define CCDF_INITED	0x01	/* unit has been initialized */

#ifdef CCDDEBUG
#define CCD_DCALL(m,c)		if (ccddebug & (m)) c
#define CCD_DPRINTF(m,a)	CCD_DCALL(m, printf a)
#define CCDB_FOLLOW	0x01
#define CCDB_INIT	0x02
#define CCDB_IO		0x04
#define CCDB_LABEL	0x08
#define CCDB_VNODE	0x10
int ccddebug = 0x00;
#else
#define CCD_DCALL(m,c)		/* m, c */
#define CCD_DPRINTF(m,a)	/* m, a */
#endif

struct ccdbuf {
	struct buf	cb_buf;		/* new I/O buf */
	struct buf	*cb_obp;	/* ptr. to original I/O buf */
	struct ccd_softc*cb_sc;		/* point back to the device */
	struct ccdbuf	*cb_dep;	/* mutual ptrs for mirror part */
	int		cb_comp;	/* target component */
	int		cb_flags;	/* misc. flags */
#define CBF_MIRROR	0x01		/* we're for a mirror component */
#define CBF_DONE	0x02		/* this buffer is done */
};

/* called by main() at boot time */
void	ccdattach(int);

/* called by biodone() at interrupt time */
void	ccdiodone(struct buf *);
daddr64_t	ccdsize(dev_t);

void	ccdstart(struct ccd_softc *, struct buf *);
void	ccdinterleave(struct ccd_softc *);
void	ccdintr(struct ccd_softc *, struct buf *);
int	ccdinit(struct ccddevice *, char **, struct proc *);
int	ccdlookup(char *, struct proc *p, struct vnode **);
long	ccdbuffer(struct ccd_softc *, struct buf *, daddr64_t, caddr_t,
    long, struct ccdbuf **);
int	ccdgetdisklabel(dev_t, struct ccd_softc *, struct disklabel *, int);
INLINE struct ccdbuf *getccdbuf(void);
INLINE void putccdbuf(struct ccdbuf *);

#define ccdlock(sc) rw_enter(&sc->sc_rwlock, RW_WRITE|RW_INTR)
#define ccdunlock(sc) rw_exit_write(&sc->sc_rwlock)

#ifdef CCDDEBUG
void	printiinfo(struct ccdiinfo *);
#endif

/* Non-private for the benefit of libkvm. */
struct	ccd_softc *ccd_softc;
struct	ccddevice *ccddevs;
int	numccd = 0;

/*
 * struct ccdbuf allocator
 */
struct pool	ccdbufpl;

/*
 * Manage the ccd buffer structures.
 */
INLINE struct ccdbuf *
getccdbuf(void)
{
	struct ccdbuf *cbp;

	cbp = pool_get(&ccdbufpl, PR_WAITOK | PR_ZERO);

	return (cbp);
}

INLINE void
putccdbuf(struct ccdbuf *cbp)
{
	pool_put(&ccdbufpl, cbp);
}

/*
 * Called by main() during pseudo-device attachment.  All we need
 * to do is allocate enough space for devices to be configured later.
 */
void
ccdattach(int num)
{
	int i;

	if (num <= 0) {
#ifdef DIAGNOSTIC
		panic("ccdattach: count <= 0");
#endif
		return;
	}

	ccd_softc = (struct ccd_softc *)malloc(num * sizeof(struct ccd_softc),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	ccddevs = (struct ccddevice *)malloc(num * sizeof(struct ccddevice),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if ((ccd_softc == NULL) || (ccddevs == NULL)) {
		printf("WARNING: no memory for concatenated disks\n");
		if (ccd_softc != NULL)
			free(ccd_softc, M_DEVBUF);
		if (ccddevs != NULL)
			free(ccddevs, M_DEVBUF);
		return;
	}
	for (i = 0; i < num; i++) {
		rw_init(&ccd_softc[i].sc_rwlock, "ccdlock");
	}
	numccd = num;

	pool_init(&ccdbufpl, sizeof(struct ccdbuf), 0, 0, 0, "ccdbufpl", NULL);
	pool_setlowat(&ccdbufpl, 16);
	pool_sethiwat(&ccdbufpl, 1024);
}

int
ccdinit(struct ccddevice *ccd, char **cpaths, struct proc *p)
{
	struct ccd_softc *cs = &ccd_softc[ccd->ccd_unit];
	struct ccdcinfo *ci = NULL;
	daddr64_t size;
	int ix;
	struct vnode *vp;
	struct vattr va;
	size_t minsize;
	int maxsecsize;
	struct partinfo dpart;
	struct ccdgeom *ccg = &cs->sc_geom;
	char tmppath[MAXPATHLEN];
	int error;

	CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT, ("ccdinit: unit %d cflags %b\n",
	    ccd->ccd_unit, ccd->ccd_flags, CCDF_BITS));

	cs->sc_size = 0;
	cs->sc_ileave = ccd->ccd_interleave;
	cs->sc_nccdisks = ccd->ccd_ndev;
	if (snprintf(cs->sc_xname, sizeof(cs->sc_xname), "ccd%d",
	    ccd->ccd_unit) >= sizeof(cs->sc_xname)) {
		printf("ccdinit: device name too long.\n");
		return(ENXIO);
	}

	/* Allocate space for the component info. */
	cs->sc_cinfo = malloc(cs->sc_nccdisks * sizeof(struct ccdcinfo),
	    M_DEVBUF, M_WAITOK | M_ZERO);

	/*
	 * Verify that each component piece exists and record
	 * relevant information about it.
	 */
	maxsecsize = 0;
	minsize = 0;
	for (ix = 0; ix < cs->sc_nccdisks; ix++) {
		vp = ccd->ccd_vpp[ix];
		ci = &cs->sc_cinfo[ix];
		ci->ci_vp = vp;

		/*
		 * Copy in the pathname of the component.
		 */
		bzero(tmppath, sizeof(tmppath));	/* sanity */
		error = copyinstr(cpaths[ix], tmppath,
		    MAXPATHLEN, &ci->ci_pathlen);
		if (error) {
			CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT,
			    ("%s: can't copy path, error = %d\n",
			    cs->sc_xname, error));
			free(cs->sc_cinfo, M_DEVBUF);
			return (error);
		}
		ci->ci_path = malloc(ci->ci_pathlen, M_DEVBUF, M_WAITOK);
		bcopy(tmppath, ci->ci_path, ci->ci_pathlen);

		/*
		 * XXX: Cache the component's dev_t.
		 */
		if ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {
			CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT,
			    ("%s: %s: getattr failed error = %d\n",
			    cs->sc_xname, ci->ci_path, error));
			free(ci->ci_path, M_DEVBUF);
			free(cs->sc_cinfo, M_DEVBUF);
			return (error);
		}
		ci->ci_dev = va.va_rdev;

		/*
		 * Get partition information for the component.
		 */
		error = VOP_IOCTL(vp, DIOCGPART, (caddr_t)&dpart,
		    FREAD, p->p_ucred, p);
		if (error) {
			CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT,
			    ("%s: %s: ioctl failed, error = %d\n",
			    cs->sc_xname, ci->ci_path, error));
			free(ci->ci_path, M_DEVBUF);
			free(cs->sc_cinfo, M_DEVBUF);
			return (error);
		}
		if (dpart.part->p_fstype == FS_CCD ||
		    dpart.part->p_fstype == FS_BSDFFS) {
			maxsecsize =
			    ((dpart.disklab->d_secsize > maxsecsize) ?
			    dpart.disklab->d_secsize : maxsecsize);
			size = DL_GETPSIZE(dpart.part);
		} else {
			CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT,
			    ("%s: %s: incorrect partition type\n",
			    cs->sc_xname, ci->ci_path));
			free(ci->ci_path, M_DEVBUF);
			free(cs->sc_cinfo, M_DEVBUF);
			return (EFTYPE);
		}

		/*
		 * Calculate the size, truncating to an interleave
		 * boundary if necessary.
		 */
		if (cs->sc_ileave > 1)
			size -= size % cs->sc_ileave;

		if (size == 0) {
			CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT,
			    ("%s: %s: size == 0\n", cs->sc_xname, ci->ci_path));
			free(ci->ci_path, M_DEVBUF);
			free(cs->sc_cinfo, M_DEVBUF);
			return (ENODEV);
		}

		if (minsize == 0 || size < minsize)
			minsize = size;
		ci->ci_size = size;
		cs->sc_size += size;
	}
	ccg->ccg_rpm = 0;

	/*
	 * Don't allow the interleave to be smaller than
	 * the biggest component sector.
	 */
	if ((cs->sc_ileave > 0) &&
	    (cs->sc_ileave < (maxsecsize / DEV_BSIZE))) {
		CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT,
		    ("%s: interleave must be at least %d\n",
		    cs->sc_xname, (maxsecsize / DEV_BSIZE)));
		free(ci->ci_path, M_DEVBUF);
		free(cs->sc_cinfo, M_DEVBUF);
		return (EINVAL);
	}

	/*
	 * Mirroring support requires uniform interleave and
	 * and even number of components.
	 */
	if (ccd->ccd_flags & CCDF_MIRROR) {
		ccd->ccd_flags |= CCDF_UNIFORM;
		if (cs->sc_ileave == 0) {
			CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT,
			    ("%s: mirroring requires interleave\n",
			    cs->sc_xname));
			free(ci->ci_path, M_DEVBUF);
			free(cs->sc_cinfo, M_DEVBUF);
			return (EINVAL);
		}
		if (cs->sc_nccdisks % 2) {
			CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT,
			    ("%s: mirroring requires even # of components\n",
			    cs->sc_xname));
			free(ci->ci_path, M_DEVBUF);
			free(cs->sc_cinfo, M_DEVBUF);
			return (EINVAL);
		}
	}

	/*
	 * If uniform interleave is desired set all sizes to that of
	 * the smallest component.
	 */
	ccg->ccg_ntracks = cs->sc_nccunits = cs->sc_nccdisks;
	if (ccd->ccd_flags & CCDF_UNIFORM) {
		for (ci = cs->sc_cinfo;
		     ci < &cs->sc_cinfo[cs->sc_nccdisks]; ci++)
			ci->ci_size = minsize;

		if (ccd->ccd_flags & CCDF_MIRROR)
			cs->sc_nccunits = ccg->ccg_ntracks /= 2;
		cs->sc_size = ccg->ccg_ntracks * minsize;
	}

	cs->sc_cflags = ccd->ccd_flags;	/* So we can find out later... */

	/*
	 * Construct the interleave table.
	 */
	ccdinterleave(cs);

	/*
	 * Create pseudo-geometry based on 1MB cylinders.  It's
	 * pretty close.
	 */
	ccg->ccg_secsize = DEV_BSIZE;
	ccg->ccg_nsectors = cs->sc_ileave? cs->sc_ileave :
	    1024 * (1024 / ccg->ccg_secsize);
	ccg->ccg_ncylinders = cs->sc_size / ccg->ccg_ntracks /
	    ccg->ccg_nsectors;

	cs->sc_flags |= CCDF_INITED;

	return (0);
}

void
ccdinterleave(struct ccd_softc *cs)
{
	struct ccdcinfo *ci, *smallci;
	struct ccdiinfo *ii;
	daddr64_t bn, lbn;
	int ix;
	u_long size;

	CCD_DPRINTF(CCDB_INIT,
	    ("ccdinterleave(%p): ileave %d\n", cs, cs->sc_ileave));

	/*
	 * Allocate an interleave table.
	 * Chances are this is too big, but we don't care.
	 */
	size = (cs->sc_nccdisks + 1) * sizeof(struct ccdiinfo);
	cs->sc_itable = (struct ccdiinfo *)malloc(size, M_DEVBUF,
	    M_WAITOK | M_ZERO);

	/*
	 * Trivial case: no interleave (actually interleave of disk size).
	 * Each table entry represents a single component in its entirety.
	 */
	if (cs->sc_ileave == 0) {
		bn = 0;
		ii = cs->sc_itable;

		for (ix = 0; ix < cs->sc_nccdisks; ix++) {
			/* Allocate space for ii_index. */
			ii->ii_index = malloc(sizeof(int), M_DEVBUF, M_WAITOK);
			ii->ii_ndisk = 1;
			ii->ii_startblk = bn;
			ii->ii_startoff = 0;
			ii->ii_index[0] = ix;
			bn += cs->sc_cinfo[ix].ci_size;
			ii++;
		}
		ii->ii_ndisk = 0;

		CCD_DCALL(CCDB_INIT, printiinfo(cs->sc_itable));
		return;
	}

	/*
	 * The following isn't fast or pretty; it doesn't have to be.
	 */
	size = 0;
	bn = lbn = 0;
	for (ii = cs->sc_itable; ; ii++) {
		/* Allocate space for ii_index. */
		ii->ii_index = malloc((sizeof(int) * cs->sc_nccdisks),
		    M_DEVBUF, M_WAITOK);

		/*
		 * Locate the smallest of the remaining components
		 */
		smallci = NULL;
		for (ci = cs->sc_cinfo;
		    ci < &cs->sc_cinfo[cs->sc_nccdisks]; ci++)
			if (ci->ci_size > size &&
			    (smallci == NULL ||
			    ci->ci_size < smallci->ci_size))
				smallci = ci;

		/*
		 * Nobody left, all done
		 */
		if (smallci == NULL) {
			ii->ii_ndisk = 0;
			break;
		}

		/*
		 * Record starting logical block and component offset
		 */
		ii->ii_startblk = bn / cs->sc_ileave;
		ii->ii_startoff = lbn;

		/*
		 * Determine how many disks take part in this interleave
		 * and record their indices.
		 */
		ix = 0;
		for (ci = cs->sc_cinfo;
		    ci < &cs->sc_cinfo[cs->sc_nccunits]; ci++)
			if (ci->ci_size >= smallci->ci_size)
				ii->ii_index[ix++] = ci - cs->sc_cinfo;
		ii->ii_ndisk = ix;
		bn += ix * (smallci->ci_size - size);
		lbn = smallci->ci_size / cs->sc_ileave;
		size = smallci->ci_size;
	}

	CCD_DCALL(CCDB_INIT, printiinfo(cs->sc_itable));
}

/* ARGSUSED */
int
ccdopen(dev_t dev, int flags, int fmt, struct proc *p)
{
	int unit = DISKUNIT(dev);
	struct ccd_softc *cs;
	struct disklabel *lp;
	int error = 0, part;

	CCD_DPRINTF(CCDB_FOLLOW, ("ccdopen(%x, %x)\n", dev, flags));

	if (unit >= numccd)
		return (ENXIO);
	cs = &ccd_softc[unit];

	if ((error = ccdlock(cs)) != 0)
		return (error);

	lp = cs->sc_dkdev.dk_label;

	part = DISKPART(dev);

	/*
	 * If we're initialized, check to see if there are any other
	 * open partitions.  If not, then it's safe to update
	 * the in-core disklabel.
	 */
	if ((cs->sc_flags & CCDF_INITED) && (cs->sc_dkdev.dk_openmask == 0))
		ccdgetdisklabel(dev, cs, lp, 0);

	error = disk_openpart(&cs->sc_dkdev, part, fmt,
	    (cs->sc_flags & CCDF_INITED) != 0);

	ccdunlock(cs);
	return (error);
}

/* ARGSUSED */
int
ccdclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	int unit = DISKUNIT(dev);
	struct ccd_softc *cs;
	int error = 0, part;

	CCD_DPRINTF(CCDB_FOLLOW, ("ccdclose(%x, %x)\n", dev, flags));

	if (unit >= numccd)
		return (ENXIO);
	cs = &ccd_softc[unit];

	if ((error = ccdlock(cs)) != 0)
		return (error);

	part = DISKPART(dev);

	disk_closepart(&cs->sc_dkdev, part, fmt);

	ccdunlock(cs);
	return (0);
}

void
ccdstrategy(struct buf *bp)
{
	int unit = DISKUNIT(bp->b_dev);
	struct ccd_softc *cs = &ccd_softc[unit];
	int s;

	CCD_DPRINTF(CCDB_FOLLOW, ("ccdstrategy(%p): unit %d\n", bp, unit));

	if ((cs->sc_flags & CCDF_INITED) == 0) {
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		goto done;
	}

	/* Validate the request. */
	if (bounds_check_with_label(bp, cs->sc_dkdev.dk_label) == -1)
		goto done;

	bp->b_resid = bp->b_bcount;

	/*
	 * "Start" the unit.
	 */
	s = splbio();
	ccdstart(cs, bp);
	splx(s);
	return;

 done:
	s = splbio();
	biodone(bp);
	splx(s);
}

void
ccdstart(struct ccd_softc *cs, struct buf *bp)
{
	long bcount, rcount;
	struct ccdbuf **cbpp;
	caddr_t addr;
	daddr64_t bn;
	struct partition *pp;

	CCD_DPRINTF(CCDB_FOLLOW, ("ccdstart(%p, %p, %s)\n", cs, bp,
	    bp->b_flags & B_READ? "read" : "write"));

	/* Instrumentation. */
	disk_busy(&cs->sc_dkdev);

	/*
	 * Translate the partition-relative block number to an absolute.
	 */
	bn = bp->b_blkno;
	pp = &cs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];
	bn += DL_GETPOFFSET(pp);

	/*
	 * Allocate component buffers
	 */
	cbpp = malloc(2 * cs->sc_nccdisks * sizeof(struct ccdbuf *), M_DEVBUF,
	    M_WAITOK | M_ZERO);
	addr = bp->b_data;
	for (bcount = bp->b_bcount; bcount > 0; bcount -= rcount) {
		rcount = ccdbuffer(cs, bp, bn, addr, bcount, cbpp);
		
		/*
		 * This is the old, slower, but less restrictive, mode of
		 * operation.  It allows interleaves which are not multiples
		 * of PAGE_SIZE and mirroring.
		 */
		if ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)
			cbpp[0]->cb_buf.b_vp->v_numoutput++;
		VOP_STRATEGY(&cbpp[0]->cb_buf);

		if ((cs->sc_cflags & CCDF_MIRROR) &&
		    ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)) {
			cbpp[1]->cb_buf.b_vp->v_numoutput++;
			VOP_STRATEGY(&cbpp[1]->cb_buf);
		}

		bn += btodb(rcount);
		addr += rcount;
	}

	free(cbpp, M_DEVBUF);
}

/*
 * Build a component buffer header.
 */
long
ccdbuffer(struct ccd_softc *cs, struct buf *bp, daddr64_t bn, caddr_t addr,
    long bcount, struct ccdbuf **cbpp)
{
	struct ccdcinfo *ci, *ci2 = NULL;
	struct ccdbuf *cbp;
	daddr64_t cbn, cboff, sblk;
	int ccdisk, ccdisk2, off;
	long cnt;
	struct ccdiinfo *ii;
	struct buf *nbp;

	CCD_DPRINTF(CCDB_IO, ("ccdbuffer(%p, %p, %d, %p, %ld, %p)\n",
	    cs, bp, bn, addr, bcount, cbpp));

	/*
	 * Determine which component bn falls in.
	 */
	cbn = bn;
	cboff = 0;

	if (cs->sc_ileave == 0) {
		/*
		 * Serially concatenated
		 */
		sblk = 0;
		for (ccdisk = 0, ci = &cs->sc_cinfo[ccdisk];
		    cbn >= sblk + ci->ci_size;
		    ccdisk++, ci = &cs->sc_cinfo[ccdisk])
			sblk += ci->ci_size;
		cbn -= sblk;
	} else {
		/*
		 * Interleaved
		 */
		cboff = cbn % cs->sc_ileave;
		cbn /= cs->sc_ileave;
		for (ii = cs->sc_itable; ii->ii_ndisk; ii++)
			if (ii->ii_startblk > cbn)
				break;
		ii--;
		off = cbn - ii->ii_startblk;
		if (ii->ii_ndisk == 1) {
			ccdisk = ii->ii_index[0];
			cbn = ii->ii_startoff + off;
		} else {
			ccdisk = ii->ii_index[off % ii->ii_ndisk];
			cbn = ii->ii_startoff + off / ii->ii_ndisk;
		}
		ci = &cs->sc_cinfo[ccdisk];
		if (cs->sc_cflags & CCDF_MIRROR) {
			/* Mirrored data */
			ccdisk2 = ccdisk + ii->ii_ndisk;
			ci2 = &cs->sc_cinfo[ccdisk2];
			/* spread the read over both parts */
			if (bp->b_flags & B_READ &&
			    bcount > bp->b_bcount / 2 &&
			    (!(ci2->ci_flags & CCIF_FAILED) ||
			      ci->ci_flags & CCIF_FAILED)) {
				ccdisk = ccdisk2;
				ci = ci2;
			}
		}
		cbn *= cs->sc_ileave;
		CCD_DPRINTF(CCDB_IO, ("ccdisk %d cbn %lld ci %p ci2 %p\n",
		    ccdisk, cbn, ci, ci2));
	}

	/* Limit the operation at next component border */
	if (cs->sc_ileave == 0)
		cnt = dbtob(ci->ci_size - cbn);
	else
		cnt = dbtob(cs->sc_ileave - cboff);
	if (cnt < bcount)
		bcount = cnt;

	/*
	 * Setup new component buffer.
	 */
	cbp = cbpp[0] = getccdbuf();
	cbp->cb_flags = 0;
	nbp = &cbp->cb_buf;
	nbp->b_flags = bp->b_flags | B_CALL;
	nbp->b_iodone = ccdiodone;
	nbp->b_proc = bp->b_proc;
	nbp->b_dev = ci->ci_dev;		/* XXX */
	nbp->b_blkno = cbn + cboff;
	nbp->b_vp = ci->ci_vp;
	nbp->b_bcount = bcount;
	LIST_INIT(&nbp->b_dep);
	nbp->b_data = addr;

	/*
	 * context for ccdiodone
	 */
	cbp->cb_obp = bp;
	cbp->cb_sc = cs;
	cbp->cb_comp = ccdisk;

	/*
	 * Mirrors have an additional write operation that is nearly
	 * identical to the first.
	 */
	if ((cs->sc_cflags & CCDF_MIRROR) &&
	    !(ci2->ci_flags & CCIF_FAILED) &&
	    ((cbp->cb_buf.b_flags & B_READ) == 0)) {
		struct ccdbuf *cbp2;
		cbpp[1] = cbp2 = getccdbuf();
		*cbp2 = *cbp;
		cbp2->cb_flags = CBF_MIRROR;
		cbp2->cb_buf.b_dev = ci2->ci_dev;	/* XXX */
		cbp2->cb_buf.b_vp = ci2->ci_vp;
		LIST_INIT(&cbp2->cb_buf.b_dep);
		cbp2->cb_comp = ccdisk2;
		cbp2->cb_dep = cbp;
		cbp->cb_dep = cbp2;
	}

	CCD_DPRINTF(CCDB_IO, (" dev %x(u%d): cbp %p bn %lld addr %p bcnt %ld\n",
	    ci->ci_dev, ci-cs->sc_cinfo, cbp, bp->b_blkno,
	    bp->b_data, bp->b_bcount));

	return (bcount);
}

void
ccdintr(struct ccd_softc *cs, struct buf *bp)
{

	splassert(IPL_BIO);

	CCD_DPRINTF(CCDB_FOLLOW, ("ccdintr(%p, %p)\n", cs, bp));

	/*
	 * Request is done for better or worse, wakeup the top half.
	 */
	if (bp->b_flags & B_ERROR)
		bp->b_resid = bp->b_bcount;
	disk_unbusy(&cs->sc_dkdev, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));
	biodone(bp);
}

/*
 * Called at interrupt time.
 * Mark the component as done and if all components are done,
 * take a ccd interrupt.
 */
void
ccdiodone(struct buf *vbp)
{
	struct ccdbuf *cbp = (struct ccdbuf *)vbp;
	struct buf *bp = cbp->cb_obp;
	struct ccd_softc *cs = cbp->cb_sc;
	long count = bp->b_bcount;
	char *comptype;

	splassert(IPL_BIO);

	CCD_DPRINTF(CCDB_FOLLOW, ("ccdiodone(%p)\n", cbp));
	CCD_DPRINTF(CCDB_IO, (cbp->cb_flags & CBF_MIRROR?
	    "ccdiodone: mirror component\n" : 
	    "ccdiodone: bp %p bcount %ld resid %ld\n",
	    bp, bp->b_bcount, bp->b_resid));
	CCD_DPRINTF(CCDB_IO, (" dev %x(u%d), cbp %p bn %lld addr %p bcnt %ld\n",
	    vbp->b_dev, cbp->cb_comp, cbp, vbp->b_blkno,
	    vbp->b_data, vbp->b_bcount));

	if (vbp->b_flags & B_ERROR) {
		cs->sc_cinfo[cbp->cb_comp].ci_flags |= CCIF_FAILED;
		if (cbp->cb_flags & CBF_MIRROR)
			comptype = " (mirror)";
		else {
			bp->b_flags |= B_ERROR;
			bp->b_error = vbp->b_error ?
			    vbp->b_error : EIO;
			comptype = "";
		}

		printf("%s: error %d on component %d%s\n",
		    cs->sc_xname, bp->b_error, cbp->cb_comp, comptype);
	}
	cbp->cb_flags |= CBF_DONE;

	if (cbp->cb_dep &&
	    (cbp->cb_dep->cb_flags & CBF_DONE) != (cbp->cb_flags & CBF_DONE))
		return;

	if (cbp->cb_flags & CBF_MIRROR &&
	    !(cbp->cb_dep->cb_flags & CBF_MIRROR)) {
		cbp = cbp->cb_dep;
		vbp = (struct buf *)cbp;
	}

	count = vbp->b_bcount;

	if (cbp->cb_dep)
		putccdbuf(cbp->cb_dep);
	putccdbuf(cbp);

	/*
	 * If all done, "interrupt".
	 *
	 * Note that mirror component buffers aren't counted against
	 * the original I/O buffer.
	 */
	if (count > bp->b_resid)
		panic("ccdiodone: count");
	bp->b_resid -= count;
	if (bp->b_resid == 0)
		ccdintr(cs, bp);
}

/* ARGSUSED */
int
ccdread(dev_t dev, struct uio *uio, int flags)
{
	int unit = DISKUNIT(dev);
	struct ccd_softc *cs;

	CCD_DPRINTF(CCDB_FOLLOW, ("ccdread(%x, %p)\n", dev, uio));

	if (unit >= numccd)
		return (ENXIO);
	cs = &ccd_softc[unit];

	if ((cs->sc_flags & CCDF_INITED) == 0)
		return (ENXIO);

	/*
	 * XXX: It's not clear that using minphys() is completely safe,
	 * in particular, for raw I/O.  Underlying devices might have some
	 * non-obvious limits, because of the copy to user-space.
	 */
	return (physio(ccdstrategy, dev, B_READ, minphys, uio));
}

/* ARGSUSED */
int
ccdwrite(dev_t dev, struct uio *uio, int flags)
{
	int unit = DISKUNIT(dev);
	struct ccd_softc *cs;

	CCD_DPRINTF(CCDB_FOLLOW, ("ccdwrite(%x, %p)\n", dev, uio));

	if (unit >= numccd)
		return (ENXIO);
	cs = &ccd_softc[unit];

	if ((cs->sc_flags & CCDF_INITED) == 0)
		return (ENXIO);

	/*
	 * XXX: It's not clear that using minphys() is completely safe,
	 * in particular, for raw I/O.  Underlying devices might have some
	 * non-obvious limits, because of the copy to user-space.
	 */
	return (physio(ccdstrategy, dev, B_WRITE, minphys, uio));
}

int
ccdioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int unit = DISKUNIT(dev);
	int i, j, lookedup = 0, error = 0;
	int part, pmask, s;
	struct disklabel *lp;
	struct ccd_softc *cs;
	struct ccd_ioctl *ccio = (struct ccd_ioctl *)data;
	struct ccddevice ccd;
	char **cpp;
	struct vnode **vpp;

	if (unit >= numccd)
		return (ENXIO);

	cs = &ccd_softc[unit];
	if (cmd != CCDIOCSET && !(cs->sc_flags & CCDF_INITED))
		return (ENXIO);

	/* access control */
	switch (cmd) {
	case CCDIOCSET:
	case CCDIOCCLR:
	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0)
			return (EBADF);
	}

	bzero(&ccd, sizeof(ccd));
	switch (cmd) {
	case CCDIOCSET:
		if (cs->sc_flags & CCDF_INITED)
			return (EBUSY);

		if (ccio->ccio_ndisks == 0 || ccio->ccio_ndisks > INT_MAX ||
		    ccio->ccio_ileave < 0)
			return (EINVAL);

		if ((error = ccdlock(cs)) != 0)
			return (error);

		/* Fill in some important bits. */
		ccd.ccd_unit = unit;
		ccd.ccd_interleave = ccio->ccio_ileave;
		ccd.ccd_flags = ccio->ccio_flags & CCDF_USERMASK;

		/*
		 * Allocate space for and copy in the array of
		 * componet pathnames and device numbers.
		 */
		cpp = malloc(ccio->ccio_ndisks * sizeof(char *),
		    M_DEVBUF, M_WAITOK);
		vpp = malloc(ccio->ccio_ndisks * sizeof(struct vnode *),
		    M_DEVBUF, M_WAITOK);

		error = copyin((caddr_t)ccio->ccio_disks, (caddr_t)cpp,
		    ccio->ccio_ndisks * sizeof(char **));
		if (error) {
			free(vpp, M_DEVBUF);
			free(cpp, M_DEVBUF);
			ccdunlock(cs);
			return (error);
		}

		for (i = 0; i < ccio->ccio_ndisks; ++i) {
			CCD_DPRINTF(CCDB_INIT,
			    ("ccdioctl: component %d: %p, lookedup = %d\n",
				i, cpp[i], lookedup));
			if ((error = ccdlookup(cpp[i], p, &vpp[i])) != 0) {
				for (j = 0; j < lookedup; ++j)
					(void)vn_close(vpp[j], FREAD|FWRITE,
					    p->p_ucred, p);
				free(vpp, M_DEVBUF);
				free(cpp, M_DEVBUF);
				ccdunlock(cs);
				return (error);
			}
			++lookedup;
		}
		ccd.ccd_cpp = cpp;
		ccd.ccd_vpp = vpp;
		ccd.ccd_ndev = ccio->ccio_ndisks;

		/*
		 * Initialize the ccd.  Fills in the softc for us.
		 */
		if ((error = ccdinit(&ccd, cpp, p)) != 0) {
			for (j = 0; j < lookedup; ++j)
				(void)vn_close(vpp[j], FREAD|FWRITE,
				    p->p_ucred, p);
			bzero(&ccd_softc[unit], sizeof(struct ccd_softc));
			free(vpp, M_DEVBUF);
			free(cpp, M_DEVBUF);
			ccdunlock(cs);
			return (error);
		}

		/*
		 * The ccd has been successfully initialized, so
		 * we can place it into the array.  Don't try to
		 * read the disklabel until the disk has been attached,
		 * because space for the disklabel is allocated
		 * in disk_attach();
		 */
		bcopy(&ccd, &ccddevs[unit], sizeof(ccd));
		ccio->ccio_unit = unit;
		ccio->ccio_size = cs->sc_size;

		/* Attach the disk. */
		cs->sc_dkdev.dk_name = cs->sc_xname;
		disk_attach(NULL, &cs->sc_dkdev);

		/* Try and read the disklabel. */
		ccdgetdisklabel(dev, cs, cs->sc_dkdev.dk_label, 0);

		ccdunlock(cs);
		break;

	case CCDIOCCLR:
		if ((error = ccdlock(cs)) != 0)
			return (error);

		/*
		 * Don't unconfigure if any other partitions are open
		 * or if both the character and block flavors of this
		 * partition are open.
		 */
		part = DISKPART(dev);
		pmask = (1 << part);
		if ((cs->sc_dkdev.dk_openmask & ~pmask) ||
		    ((cs->sc_dkdev.dk_bopenmask & pmask) &&
		    (cs->sc_dkdev.dk_copenmask & pmask))) {
			ccdunlock(cs);
			return (EBUSY);
		}

		/*
		 * Free ccd_softc information and clear entry.
		 */

		/* Close the components and free their pathnames. */
		for (i = 0; i < cs->sc_nccdisks; ++i) {
			/*
			 * XXX: this close could potentially fail and
			 * cause Bad Things.  Maybe we need to force
			 * the close to happen?
			 */
#ifdef DIAGNOSTIC
			CCD_DCALL(CCDB_VNODE, vprint("CCDIOCCLR: vnode info",
			    cs->sc_cinfo[i].ci_vp));
#endif

			(void)vn_close(cs->sc_cinfo[i].ci_vp, FREAD|FWRITE,
			    p->p_ucred, p);
			free(cs->sc_cinfo[i].ci_path, M_DEVBUF);
		}

		/* Free interleave index. */
		for (i = 0; cs->sc_itable[i].ii_ndisk; ++i)
			free(cs->sc_itable[i].ii_index, M_DEVBUF);

		/* Free component info and interleave table. */
		free(cs->sc_cinfo, M_DEVBUF);
		free(cs->sc_itable, M_DEVBUF);
		cs->sc_flags &= ~CCDF_INITED;

		/*
		 * Free ccddevice information and clear entry.
		 */
		free(ccddevs[unit].ccd_cpp, M_DEVBUF);
		free(ccddevs[unit].ccd_vpp, M_DEVBUF);
		bcopy(&ccd, &ccddevs[unit], sizeof(ccd));

		/* Detach the disk. */
		disk_detach(&cs->sc_dkdev);

		/* This must be atomic. */
		s = splhigh();
		ccdunlock(cs);
		bzero(cs, sizeof(struct ccd_softc));
		splx(s);
		break;

	case DIOCRLDINFO:
		if ((error = ccdlock(cs)) != 0)
			return (error);

		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		ccdgetdisklabel(dev, cs, lp, 0);
		*(cs->sc_dkdev.dk_label) = *lp;
		free(lp, M_TEMP);

		ccdunlock(cs);
		break;

	case DIOCGPDINFO:
		if ((error = ccdlock(cs)) != 0)
			return (error);

		ccdgetdisklabel(dev, cs, (struct disklabel *)data, 1);

		ccdunlock(cs);
		break;

	case DIOCGDINFO:
		*(struct disklabel *)data = *(cs->sc_dkdev.dk_label);
		break;

	case DIOCGPART:
		((struct partinfo *)data)->disklab = cs->sc_dkdev.dk_label;
		((struct partinfo *)data)->part =
		    &cs->sc_dkdev.dk_label->d_partitions[DISKPART(dev)];
		break;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((error = ccdlock(cs)) != 0)
			return (error);

		error = setdisklabel(cs->sc_dkdev.dk_label,
		    (struct disklabel *)data, 0);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    ccdstrategy, cs->sc_dkdev.dk_label);
		}

		ccdunlock(cs);

		if (error)
			return (error);
		break;

	default:
		return (ENOTTY);
	}

	return (0);
}

daddr64_t
ccdsize(dev_t dev)
{
	struct ccd_softc *cs;
	int part, unit;
	daddr64_t size;

	unit = DISKUNIT(dev);
	if (unit >= numccd)
		return (-1);

	cs = &ccd_softc[unit];
	if ((cs->sc_flags & CCDF_INITED) == 0)
		return (-1);

	if (ccdopen(dev, 0, S_IFBLK, curproc))
		return (-1);

	part = DISKPART(dev);
	if (cs->sc_dkdev.dk_label->d_partitions[part].p_fstype != FS_SWAP)
		size = -1;
	else
		size = DL_GETPSIZE(&cs->sc_dkdev.dk_label->d_partitions[part]);

	if (ccdclose(dev, 0, S_IFBLK, curproc))
		return (-1);

	return (size);
}

int
ccddump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
{

	/* Not implemented. */
	return ENXIO;
}

/*
 * Lookup the provided name in the filesystem.  If the file exists,
 * is a valid block device, and isn't being used by anyone else,
 * set *vpp to the file's vnode.
 */
int
ccdlookup(char *path, struct proc *p, struct vnode **vpp)
{
	struct nameidata nd;
	struct vnode *vp;
	struct vattr va;
	int error;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, path, p);
	if ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {
		CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT,
		    ("ccdlookup: vn_open error = %d\n", error));
		return (error);
	}
	vp = nd.ni_vp;

	if (vp->v_usecount > 1) {
		VOP_UNLOCK(vp, 0, p);
		(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
		return (EBUSY);
	}

	if ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {
		CCD_DPRINTF(CCDB_FOLLOW | CCDB_INIT,
		    ("ccdlookup: getattr error = %d\n", error));
		VOP_UNLOCK(vp, 0, p);
		(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
		return (error);
	}

	/* XXX: eventually we should handle VREG, too. */
	if (va.va_type != VBLK) {
		VOP_UNLOCK(vp, 0, p);
		(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
		return (ENOTBLK);
	}

#ifdef DIAGNOSTIC
	CCD_DCALL(CCDB_VNODE, vprint("ccdlookup: vnode info", vp));
#endif

	VOP_UNLOCK(vp, 0, p);
	*vpp = vp;
	return (0);
}

/*
 * Read the disklabel from the ccd.  If one is not present, fake one
 * up.
 */
int
ccdgetdisklabel(dev_t dev, struct ccd_softc *cs, struct disklabel *lp,
    int spoofonly)
{
	struct ccdgeom *ccg = &cs->sc_geom;

	bzero(lp, sizeof(*lp));

	DL_SETDSIZE(lp, cs->sc_size);
	lp->d_secsize = ccg->ccg_secsize;
	lp->d_nsectors = ccg->ccg_nsectors;
	lp->d_ntracks = ccg->ccg_ntracks;
	lp->d_ncylinders = ccg->ccg_ncylinders;
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;

	strncpy(lp->d_typename, "ccd", sizeof(lp->d_typename));
	lp->d_type = DTYPE_CCD;
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
	lp->d_flags = 0;
	lp->d_version = 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(cs->sc_dkdev.dk_label);

	/*
	 * Call the generic disklabel extraction routine.
	 */
	return readdisklabel(DISKLABELDEV(dev), ccdstrategy,
	    cs->sc_dkdev.dk_label, spoofonly);
}

#ifdef CCDDEBUG
void
printiinfo(struct ccdiinfo *ii)
{
	int ix, i;

	for (ix = 0; ii->ii_ndisk; ix++, ii++) {
		printf(" itab[%d]: #dk %d sblk %d soff %d",
		       ix, ii->ii_ndisk, ii->ii_startblk, ii->ii_startoff);
		for (i = 0; i < ii->ii_ndisk; i++)
			printf(" %d", ii->ii_index[i]);
		printf("\n");
	}
}
#endif
@


1.97
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.96 2011/06/30 16:28:05 matthew Exp $	*/
@


1.96
log
@Refactor some common open/close/detach disk driver code into
subr_disk.c.  For now just the MI disk drivers.

ok deraadt@@, krw@@; jsing@@ liked the approach too
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.95 2011/06/05 18:40:33 matthew Exp $	*/
a616 1
	struct disklabel *lp;
d622 1
a623 1
		bp->b_flags |= B_ERROR;
d627 2
a628 11
	/* If it's a nil transfer, wake up the top half now. */
	if (bp->b_bcount == 0)
		goto done;

	lp = cs->sc_dkdev.dk_label;

	/*
	 * Do bounds checking and adjust transfer.  If there's an
	 * error, the bounds check will flag that for us.
	 */
	if (bounds_check_with_label(bp, lp) <= 0)
d640 2
a641 1
done:
@


1.95
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.94 2011/06/03 21:14:11 matthew Exp $	*/
d556 1
a556 1
	int error = 0, part, pmask;
a569 1
	pmask = (1 << part);
d579 2
a580 22
	/* Check that the partition exists. */
	if (part != RAW_PART) {
		if (((cs->sc_flags & CCDF_INITED) == 0) ||
		    ((part >= lp->d_npartitions) ||
		    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {
			error = ENXIO;
			goto done;
		}
	}

	/* Prevent our unit from being unconfigured while open. */
	switch (fmt) {
	case S_IFCHR:
		cs->sc_dkdev.dk_copenmask |= pmask;
		break;

	case S_IFBLK:
		cs->sc_dkdev.dk_bopenmask |= pmask;
		break;
	}
	cs->sc_dkdev.dk_openmask =
	    cs->sc_dkdev.dk_copenmask | cs->sc_dkdev.dk_bopenmask;
a581 1
 done:
d605 1
a605 12
	/* ...that much closer to allowing unconfiguration... */
	switch (fmt) {
	case S_IFCHR:
		cs->sc_dkdev.dk_copenmask &= ~(1 << part);
		break;

	case S_IFBLK:
		cs->sc_dkdev.dk_bopenmask &= ~(1 << part);
		break;
	}
	cs->sc_dkdev.dk_openmask =
	    cs->sc_dkdev.dk_copenmask | cs->sc_dkdev.dk_bopenmask;
@


1.94
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.93 2011/04/12 20:18:13 miod Exp $	*/
a136 2
#define CCDF_WLABEL	0x02	/* label area is writable */
#define CCDF_LABELLING	0x04	/* unit is currently being labelled */
a1031 1
	case DIOCWLABEL:
a1226 2
		cs->sc_flags |= CCDF_LABELLING;

a1234 2
		cs->sc_flags &= ~CCDF_LABELLING;

a1238 7
		break;

	case DIOCWLABEL:
		if (*(int *)data != 0)
			cs->sc_flags |= CCDF_WLABEL;
		else
			cs->sc_flags &= ~CCDF_WLABEL;
@


1.93
log
@Fix uninitialized variable access introduced in 1.58, causing read access
to possibly favor the mirror instead of the main ccd by incorrectly
considering the main ccd is in the failure state, for interleaved+mirrored
ccds.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.92 2010/09/22 01:18:57 matthew Exp $	*/
a651 1
	int wlabel;
d673 1
a673 2
	wlabel = cs->sc_flags & (CCDF_WLABEL|CCDF_LABELLING);
	if (bounds_check_with_label(bp, lp, wlabel) <= 0)
@


1.92
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.91 2010/09/08 14:47:12 jsing Exp $	*/
d798 1
d807 1
a807 1
			      ci->ci_flags & CCIF_FAILED))
d809 2
a812 1
		ci = &cs->sc_cinfo[ccdisk];
@


1.91
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.89 2010/04/23 15:25:21 jsing Exp $	*/
d981 1
a981 1
	return (physio(ccdstrategy, NULL, dev, B_READ, minphys, uio));
d1005 1
a1005 1
	return (physio(ccdstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.90
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1121 1
a1121 1
		disk_attach(&cs->sc_dkdev);
@


1.89
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.87 2009/08/13 15:23:11 deraadt Exp $	*/
d106 1
@


1.88
log
@- fix format strings for values that are daddr64_t

ok otto@@, agreed by deraadt@@
@
text
@d262 1
a262 1
	int ix, rpm;
a293 1
	rpm = 0;
a374 1
		rpm += dpart.disklab->d_rpm;
d376 1
a376 1
	ccg->ccg_rpm = rpm / cs->sc_nccdisks;
a1367 1
	lp->d_rpm = ccg->ccg_rpm;
a1371 1
	lp->d_interleave = 1;
@


1.87
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.86 2009/06/04 05:57:27 krw Exp $	*/
d812 1
a812 1
		CCD_DPRINTF(CCDB_IO, ("ccdisk %d cbn %d ci %p ci2 %p\n",
d866 1
a866 1
	CCD_DPRINTF(CCDB_IO, (" dev %x(u%d): cbp %p bn %d addr %p bcnt %ld\n",
d912 1
a912 1
	CCD_DPRINTF(CCDB_IO, (" dev %x(u%d), cbp %p bn %d addr %p bcnt %ld\n",
@


1.86
log
@Add DIOCRLDINFO to those drivers previously deprived.

Noticed by & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.85 2008/07/01 04:15:59 ray Exp $	*/
d178 1
a178 1
void	ccdgetdisklabel(dev_t, struct ccd_softc *, struct disklabel *, int);
d1356 1
a1356 1
void
a1360 1
	char *errstring;
d1386 1
a1386 1
	errstring = readdisklabel(DISKLABELDEV(dev), ccdstrategy,
a1387 3
	/* It's actually extremely common to have unlabeled ccds. */
	if (errstring != NULL)
		CCD_DPRINTF(CCDB_LABEL, ("%s: %s\n", cs->sc_xname, errstring));
@


1.85
log
@Remove clauses 3 and 4 from BSD license owned by mickey, niklas, and NetBSD.

OK niklas, mickey, deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.84 2008/06/15 00:36:40 krw Exp $	*/
d1015 1
d1193 12
@


1.84
log
@Don't bypass partition bounds check for RAW_PART. We now guarantee that
RAW_PART will always be 0 -> disksize, so the bounds check will always
pass for i/o's to valid addresses. Now the i/o will be properly truncated
if it goes past the end of the device. This prevents various adverse
impacts of issuing i/o's for data past the end of the device.

Repeatedly requested by todd@@.

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.83 2008/06/14 10:55:20 mk Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.83
log
@A bunch of pool_get() + bzero() -> pool_get(..., .. | PR_ZERO)
conversions that should shave a few bytes off the kernel.

ok henning, krw, jsing, oga, miod, and thib (``even though i usually prefer
FOO|BAR''; thanks for looking.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.82 2007/09/12 18:45:14 mk Exp $	*/
d683 1
a683 2
	if (DISKPART(bp->b_dev) != RAW_PART &&
	    bounds_check_with_label(bp, lp, wlabel) <= 0)
@


1.82
log
@There is no such word as `detatch'.

ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.81 2007/09/11 13:39:33 gilles Exp $	*/
d214 2
a215 2
	if ((cbp = pool_get(&ccdbufpl, PR_WAITOK)))
		bzero(cbp, sizeof(struct ccdbuf));
@


1.81
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.80 2007/09/08 17:59:23 gilles Exp $	*/
d1192 1
a1192 1
		/* Detatch the disk. */
@


1.80
log
@more M_ZERO changes

ok pyr@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.79 2007/09/01 15:28:39 thib Exp $	*/
d242 1
a242 1
	    M_DEVBUF, M_NOWAIT|M_ZERO);
d244 1
a244 1
	    M_DEVBUF, M_NOWAIT|M_ZERO);
d293 1
a293 1
	    M_DEVBUF, M_WAITOK|M_ZERO);
d479 2
a480 1
	cs->sc_itable = (struct ccdiinfo *)malloc(size, M_DEVBUF, M_WAITOK|M_ZERO);
d728 1
a728 1
	    M_WAITOK|M_ZERO);
@


1.79
log
@fix a use after free case.
From Bret Lambert via deraadt@@;

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.78 2007/06/20 18:15:46 deraadt Exp $	*/
d242 1
a242 1
	    M_DEVBUF, M_NOWAIT);
d244 1
a244 1
	    M_DEVBUF, M_NOWAIT);
a256 2
	bzero(ccd_softc, num * sizeof(struct ccd_softc));
	bzero(ccddevs, num * sizeof(struct ccddevice));
d293 1
a293 2
	    M_DEVBUF, M_WAITOK);
	bzero(cs->sc_cinfo, cs->sc_nccdisks * sizeof(struct ccdcinfo));
d479 1
a479 2
	cs->sc_itable = (struct ccdiinfo *)malloc(size, M_DEVBUF, M_WAITOK);
	bzero((caddr_t)cs->sc_itable, size);
d727 1
a727 2
	    M_WAITOK);
	bzero(cbpp, 2 * cs->sc_nccdisks * sizeof(struct ccdbuf *));
@


1.78
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.77 2007/06/08 05:27:58 deraadt Exp $	*/
a955 1
	putccdbuf(cbp);
d958 1
@


1.77
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.76 2007/06/07 05:29:43 deraadt Exp $	*/
d185 1
a185 2
void	ccdgetdisklabel(dev_t, struct ccd_softc *, struct disklabel *,
    struct cpu_disklabel *, int);
d591 1
a591 1
		ccdgetdisklabel(dev, cs, lp, cs->sc_dkdev.dk_cpulabel, 0);
d687 1
a687 2
	    bounds_check_with_label(bp, lp, cs->sc_dkdev.dk_cpulabel,
	    wlabel) <= 0)
d1136 1
a1136 2
		ccdgetdisklabel(dev, cs, cs->sc_dkdev.dk_label,
		    cs->sc_dkdev.dk_cpulabel, 0);
d1206 1
a1206 3
	case DIOCGPDINFO: {
		struct cpu_disklabel osdep;

d1210 1
a1210 2
		ccdgetdisklabel(dev, cs, (struct disklabel *)data,
		    &osdep, 1);
a1213 1
	}
d1233 1
a1233 1
		    (struct disklabel *)data, 0, cs->sc_dkdev.dk_cpulabel);
d1237 1
a1237 2
				    ccdstrategy, cs->sc_dkdev.dk_label,
				    cs->sc_dkdev.dk_cpulabel);
d1357 1
a1357 1
    struct cpu_disklabel *clp, int spoofonly)
a1362 1
	bzero(clp, sizeof(*clp));
d1387 1
a1387 1
	    cs->sc_dkdev.dk_label, cs->sc_dkdev.dk_cpulabel, spoofonly);
@


1.76
log
@in OpenBSD as all old BSD unix, RAW_PART always starts at 0, so no
need for special case code; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.75 2007/06/06 17:15:13 deraadt Exp $	*/
d1386 1
@


1.75
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.74 2007/06/05 00:38:20 deraadt Exp $	*/
d726 2
a727 4
	if (DISKPART(bp->b_dev) != RAW_PART) {
		pp = &cs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];
		bn += DL_GETPOFFSET(pp);
	}
@


1.74
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.73 2007/06/01 00:07:48 krw Exp $	*/
d176 1
a176 1
int	ccdsize(dev_t);
d183 1
a183 1
long	ccdbuffer(struct ccd_softc *, struct buf *, daddr_t, caddr_t,
d271 1
a271 1
	size_t size;
d471 1
a471 1
	daddr_t bn, lbn;
d713 1
a713 1
	daddr_t bn;
d767 1
a767 1
ccdbuffer(struct ccd_softc *cs, struct buf *bp, daddr_t bn, caddr_t addr,
d772 1
a772 1
	daddr_t cbn, cboff, sblk;
d1272 1
a1272 1
int
d1276 2
a1277 1
	int part, size, unit;
d1303 1
a1303 1
ccddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
@


1.73
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.72 2007/04/28 12:32:13 krw Exp $	*/
d358 1
a358 1
			size = dpart.part->p_size;
d728 1
a728 1
		bn += pp->p_offset;
d1293 1
a1293 1
		size = cs->sc_dkdev.dk_label->d_partitions[part].p_size;
d1374 1
a1374 1
	lp->d_secperunit = cs->sc_size;
@


1.72
log
@CCDLABELDEV/ect and RAIDLABELDEV/etc join other no-op defines in the
trashbin of history, replaced by DISKLABELDEV/etc. No change to .o
files except for __line__.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.71 2007/04/18 19:06:56 miod Exp $	*/
a1386 5

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;
@


1.71
log
@Remove the ``new i/o'' code. It has never worked well, noone has stepped up
to fix it, and it goes in the way of good changes pedro is brewing.
No functional change, tested todd@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.70 2007/04/06 06:41:42 tedu Exp $	*/
a159 4
#define	ccdunit(x)	DISKUNIT(x)
#define CCDLABELDEV(dev)	\
	(MAKEDISKDEV(major((dev)), ccdunit((dev)), RAW_PART))

d567 1
a567 1
	int unit = ccdunit(dev);
d626 1
a626 1
	int unit = ccdunit(dev);
d661 1
a661 1
	int unit = ccdunit(bp->b_dev);
d981 1
a981 1
	int unit = ccdunit(dev);
d1005 1
a1005 1
	int unit = ccdunit(dev);
d1028 1
a1028 1
	int unit = ccdunit(dev);
d1245 1
a1245 1
				error = writedisklabel(CCDLABELDEV(dev),
d1278 1
a1278 1
	unit = ccdunit(dev);
d1400 1
a1400 1
	errstring = readdisklabel(CCDLABELDEV(dev), ccdstrategy,
@


1.70
log
@use rwlocks instead of hand-rolled.  make the softc private parts private.
this means making ccdconfig "SMALL" to turn off the kvm groveling nonsense
ok deraadt millert pedro todd
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.69 2007/03/30 15:19:05 deraadt Exp $	*/
a11 1
 * Niklas Hallqvist redid the buffer policy for better performance.
a91 2
 *
 * Buffer scatter/gather policy by Niklas Hallqvist.
a145 9

/*
 * Overridable value telling how many kvm spaces of MAXBSIZE we need for
 * component I/O operations.
 */
#ifndef CCD_CLUSTERS
#define CCD_CLUSTERS 16
#endif

d172 1
a172 9
#define CBF_OLD		0x02		/* use old I/O protocol */
#define CBF_DONE	0x04		/* this buffer is done */

	int		cb_sgcnt;	/* scatter/gather segment count */
#define	CCD_SGMAX	(MAXBSIZE >> PAGE_SHIFT)
	struct ccdseg {
		caddr_t	cs_sgaddr;	/* scatter/gather segment addresses */
		long	cs_sglen;	/* scatter/gather segment lengths */
	} cb_sg[1];
d188 1
a188 1
    long, struct ccdbuf **, int);
a204 13
int	ccdbufsizeof;

/*
 * A separate map so that locking on kernel_map won't happen in interrupts
 * (XXX due to fragmentation this might fail easy and panic the kernel)
 */
struct vm_map *ccdmap;

/*
 * Set when a process need some kvm.
 * XXX should we fallback to old I/O policy instead when out of ccd kvm?
 */
int ccd_need_kvm = 0;
d220 1
a220 1
		bzero(cbp, ccdbufsizeof);
d265 1
a265 3
	ccdbufsizeof = sizeof(struct ccdbuf) +
	    (CCD_SGMAX - 1) * sizeof(struct ccdseg);
	pool_init(&ccdbufpl, ccdbufsizeof, 0, 0, 0, "ccdbufpl", NULL);
d715 1
a715 1
	struct ccdbuf **cbpp, *cbp;
a718 1
	int i, old_io = cs->sc_cflags & CCDF_OLD;
a741 1
	old_io = old_io || ((vaddr_t)addr & PAGE_MASK);
d743 1
a743 1
		rcount = ccdbuffer(cs, bp, bn, addr, bcount, cbpp, old_io);
d750 8
a757 10
		if (old_io) {
			if ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)
				cbpp[0]->cb_buf.b_vp->v_numoutput++;
			VOP_STRATEGY(&cbpp[0]->cb_buf);

			if ((cs->sc_cflags & CCDF_MIRROR) &&
			    ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)) {
				cbpp[1]->cb_buf.b_vp->v_numoutput++;
				VOP_STRATEGY(&cbpp[1]->cb_buf);
			}
a763 13
	/* The new leaner mode of operation */
	if (!old_io)
		/*
		 * Fire off the requests
		 */
		for (i = 0; i < 2*cs->sc_nccdisks; i++) {
			cbp = cbpp[i];
			if (cbp) {
				if ((cbp->cb_buf.b_flags & B_READ) == 0)
					cbp->cb_buf.b_vp->v_numoutput++;
				VOP_STRATEGY(&cbp->cb_buf);
			}
		}
d772 1
a772 1
    long bcount, struct ccdbuf **cbpp, int old_io)
d778 1
a778 1
	long old_bcount, cnt;
d844 15
a858 15
	if (old_io || cbpp[ccdisk] == NULL) {
		/*
		 * Setup new component buffer.
		 */
		cbp = cbpp[old_io ? 0 : ccdisk] = getccdbuf();
		cbp->cb_flags = old_io ? CBF_OLD : 0;
		nbp = &cbp->cb_buf;
		nbp->b_flags = bp->b_flags | B_CALL;
		nbp->b_iodone = ccdiodone;
		nbp->b_proc = bp->b_proc;
		nbp->b_dev = ci->ci_dev;		/* XXX */
		nbp->b_blkno = cbn + cboff;
		nbp->b_vp = ci->ci_vp;
		nbp->b_bcount = bcount;
		LIST_INIT(&nbp->b_dep);
d860 6
a865 27
		/*
		 * context for ccdiodone
		 */
		cbp->cb_obp = bp;
		cbp->cb_sc = cs;
		cbp->cb_comp = ccdisk;

		/* Deal with the different algorithms */
		if (old_io)
			nbp->b_data = addr;
		else {
			do {
				nbp->b_data = (caddr_t) uvm_km_valloc(ccdmap,
				    bp->b_bcount);

				/*
				 * XXX Instead of sleeping, we might revert
				 * XXX to old I/O policy for this buffer set.
				 */
				if (nbp->b_data == NULL) {
					ccd_need_kvm++;
					tsleep(ccdmap, PRIBIO, "ccdbuffer", 0);
				}
			} while (nbp->b_data == NULL);
			cbp->cb_sgcnt = 0;
			old_bcount = 0;
		}
d867 17
a883 41
		/*
		 * Mirrors have an additional write operation that is nearly
		 * identical to the first.
		 */
		if ((cs->sc_cflags & CCDF_MIRROR) &&
		    !(ci2->ci_flags & CCIF_FAILED) &&
		    ((cbp->cb_buf.b_flags & B_READ) == 0)) {
			struct ccdbuf *cbp2;
			cbpp[old_io? 1 : ccdisk2] = cbp2 = getccdbuf();
			*cbp2 = *cbp;
			cbp2->cb_flags = CBF_MIRROR | (old_io ? CBF_OLD : 0);
			cbp2->cb_buf.b_dev = ci2->ci_dev;	/* XXX */
			cbp2->cb_buf.b_vp = ci2->ci_vp;
			LIST_INIT(&cbp2->cb_buf.b_dep);
			cbp2->cb_comp = ccdisk2;
			cbp2->cb_dep = cbp;
			cbp->cb_dep = cbp2;
		}
	} else {
		/*
		 * Continue on an already started component buffer
		 */
		cbp = cbpp[ccdisk];
		nbp = &cbp->cb_buf;

		/*
		 * Map the new pages at the end of the buffer.
		 */
		old_bcount = nbp->b_bcount;
		nbp->b_bcount += bcount;
	}

	if (!old_io) {
		CCD_DPRINTF(CCDB_IO, ("ccdbuffer: sg %d (%p/%x) off %x\n",
		    cbp->cb_sgcnt, addr, bcount, old_bcount));

		pagemove(addr, nbp->b_data + old_bcount, round_page(bcount));
		nbp->b_bufsize += round_page(bcount);
		cbp->cb_sg[cbp->cb_sgcnt].cs_sgaddr = addr;
		cbp->cb_sg[cbp->cb_sgcnt].cs_sglen = bcount;
		cbp->cb_sgcnt++;
d922 1
a922 3
	int old_io = cbp->cb_flags & CBF_OLD;
	int i;
	long count = bp->b_bcount, off;
a961 20
	if (!old_io) {
		/*
		 * Gather all the pieces and put them where they should be.
		 */
		for (i = 0, off = 0; i < cbp->cb_sgcnt; i++) {
			CCD_DPRINTF(CCDB_IO,
			    ("ccdiodone: sg %d (%p/%x) off %x\n", i,
			    cbp->cb_sg[i].cs_sgaddr,
			    cbp->cb_sg[i].cs_sglen, off));
			pagemove(vbp->b_data + off, cbp->cb_sg[i].cs_sgaddr,
			    round_page(cbp->cb_sg[i].cs_sglen));
			off += cbp->cb_sg[i].cs_sglen;
		}

		uvm_km_free(ccdmap, (vaddr_t)vbp->b_data, count);
		if (ccd_need_kvm) {
			ccd_need_kvm = 0;
			wakeup(ccdmap);
		}
	}
a1039 1
	vaddr_t min, max;
a1076 10
		/* XXX the new code is unstable still */
		ccd.ccd_flags |= CCDF_OLD;

		/*
		 * Interleaving which is not a multiple of the click size
		 * must use the old I/O code (by design)
		 */
		if (ccio->ccio_ileave % (PAGE_SIZE / DEV_BSIZE) != 0)
			ccd.ccd_flags |= CCDF_OLD;

a1137 16

		/*
		 * If we use the optimized protocol we need some kvm space
		 * for the component buffers.  Allocate it here.
		 *
		 * XXX I'd like to have a more dynamic way of acquiring kvm
		 * XXX space, but that is problematic as we are not allowed
		 * XXX to lock the kernel_map in interrupt context.  It is
		 * XXX doable via a freelist implementation though.
		 */
		if (!ccdmap && !(ccd.ccd_flags & CCDF_OLD)) {
			min = vm_map_min(kernel_map);
			ccdmap = uvm_km_suballoc(kernel_map, &min, &max,
			    CCD_CLUSTERS * MAXBSIZE, VM_MAP_INTRSAFE,
			    FALSE, NULL);
		}
@


1.69
log
@accept interleave of 0; pr 5431, my patch matches the author's
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.68 2006/11/29 15:03:42 krw Exp $	*/
d115 1
d126 25
a210 2
int	ccdlock(struct ccd_softc *);
void	ccdunlock(struct ccd_softc *);
d214 3
d270 2
d291 3
a1554 34
}

/*
 * Wait interruptibly for an exclusive lock.
 *
 * XXX
 * Several drivers do this; it should be abstracted and made MP-safe.
 */
int
ccdlock(struct ccd_softc *cs)
{
	int error;

	while ((cs->sc_flags & CCDF_LOCKED) != 0) {
		cs->sc_flags |= CCDF_WANTED;
		if ((error = tsleep(cs, PRIBIO | PCATCH, "ccdlck", 0)) != 0)
			return (error);
	}
	cs->sc_flags |= CCDF_LOCKED;
	return (0);
}

/*
 * Unlock and wake up any waiters.
 */
void
ccdunlock(struct ccd_softc *cs)
{

	cs->sc_flags &= ~CCDF_LOCKED;
	if ((cs->sc_flags & CCDF_WANTED) != 0) {
		cs->sc_flags &= ~CCDF_WANTED;
		wakeup(cs);
	}
@


1.68
log
@The historical reasons to spoof the 'c' partition of ccdN as being FFS
are no longer operative. Spoof the label created for ccdN with an
UNUSED 'c' partition like every other device's spoofed label.

Problem pointed out by millert@@ in relation to pending disklabel(8)
changes.

ok mickey@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.67 2006/08/12 18:08:11 krw Exp $	*/
d1154 1
a1154 1
		    ccio->ccio_ileave <= 0)
@


1.67
log
@Rather than using cs->sc_size to set d_secperunit and then RAW_PART's
p_size, use d_secperunit to set RAW_PART's p_size. This is more
consistant with other usage and makes the intent clearer.

This should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.66 2006/07/20 18:06:44 mickey Exp $	*/
a184 1
void	ccdmakedisklabel(struct ccd_softc *);
a1519 3
	if (errstring)
		ccdmakedisklabel(cs);

a1522 18
}

/*
 * Take care of things one might want to take care of in the event
 * that a disklabel isn't present.
 */
void
ccdmakedisklabel(struct ccd_softc *cs)
{
	struct disklabel *lp = cs->sc_dkdev.dk_label;

	/*
	 * For historical reasons, if there's no disklabel present
	 * the raw partition must be marked FS_BSDFFS.
	 */
	lp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;

	strncpy(lp->d_packname, "default label", sizeof(lp->d_packname));
@


1.66
log
@otto sez there is no need to check for upper bound for the ileave. indeed
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.65 2006/07/20 15:42:09 mickey Exp $	*/
d1508 1
a1508 1
	lp->d_partitions[RAW_PART].p_size = cs->sc_size;
@


1.65
log
@do some range checking on ccio passed from user; pt out by ramrunner@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.64 2006/01/09 12:43:16 pedro Exp $	*/
d1155 1
a1155 1
		    ccio->ccio_ileave <= 0 || ccio->ccio_ileave > INT_MAX)
@


1.64
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.63 2005/09/13 17:26:16 mickey Exp $	*/
d1153 4
@


1.63
log
@make a macro instead of #ifdef DEBUG if() printf() #endif; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.62 2005/05/22 19:40:51 art Exp $	*/
d1290 1
d1293 1
d1466 1
d1468 1
@


1.62
log
@remove "0x" in front of %p in printfs.

eyeballed by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.61 2005/05/12 17:16:06 niallo Exp $	*/
d132 3
a134 5
#if defined(CCDDEBUG) && !defined(DEBUG)
#define DEBUG
#endif

#ifdef DEBUG
d141 3
d191 1
a191 1
#ifdef DEBUG
d290 2
a291 5
#ifdef DEBUG
	if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
		printf("ccdinit: unit %d cflags %b\n",
		    ccd->ccd_unit, ccd->ccd_flags, CCDF_BITS);
#endif
d326 3
a328 5
#ifdef DEBUG
			if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
				printf("%s: can't copy path, error = %d\n",
				    cs->sc_xname, error);
#endif
d339 3
a341 6
#ifdef DEBUG
			if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
				printf("%s: %s: getattr failed %s = %d\n",
				    cs->sc_xname, ci->ci_path,
				    "error", error);
#endif
d354 3
a356 5
#ifdef DEBUG
			if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
				printf("%s: %s: ioctl failed, error = %d\n",
				    cs->sc_xname, ci->ci_path, error);
#endif
d368 3
a370 5
#ifdef DEBUG
			if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
				printf("%s: %s: incorrect partition type\n",
				    cs->sc_xname, ci->ci_path);
#endif
d384 2
a385 5
#ifdef DEBUG
			if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
				printf("%s: %s: size == 0\n",
				    cs->sc_xname, ci->ci_path);
#endif
d405 3
a407 5
#ifdef DEBUG
		if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
			printf("%s: interleave must be at least %d\n",
			    cs->sc_xname, (maxsecsize / DEV_BSIZE));
#endif
d420 3
a422 5
#ifdef DEBUG
			if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
			printf("%s: mirroring requires interleave\n",
			    cs->sc_xname);
#endif
d428 3
a430 5
#ifdef DEBUG
			if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
			printf("%s: mirroring requires even # of components\n",
			    cs->sc_xname);
#endif
d483 3
a485 4
#ifdef DEBUG
	if (ccddebug & CCDB_INIT)
		printf("ccdinterleave(%p): ileave %d\n", cs, cs->sc_ileave);
#endif
d513 2
a514 4
#ifdef DEBUG
		if (ccddebug & CCDB_INIT)
			printiinfo(cs->sc_itable);
#endif
d567 2
a568 4
#ifdef DEBUG
	if (ccddebug & CCDB_INIT)
		printiinfo(cs->sc_itable);
#endif
d580 2
a581 4
#ifdef DEBUG
	if (ccddebug & CCDB_FOLLOW)
		printf("ccdopen(%x, %x)\n", dev, flags);
#endif
d638 1
a638 4
#ifdef DEBUG
	if (ccddebug & CCDB_FOLLOW)
		printf("ccdclose(%x, %x)\n", dev, flags);
#endif
d675 2
a676 4
#ifdef DEBUG
	if (ccddebug & CCDB_FOLLOW)
		printf("ccdstrategy(%p): unit %d\n", bp, unit);
#endif
d725 2
a726 5
#ifdef DEBUG
	if (ccddebug & CCDB_FOLLOW)
		printf("ccdstart(%p, %p, %s)\n", cs, bp,
		    bp->b_flags & B_READ? "read" : "write");
#endif
d803 2
a804 5
#ifdef DEBUG
	if (ccddebug & CCDB_IO)
		printf("ccdbuffer(%p, %p, %d, %p, %ld, %p)\n",
		    cs, bp, bn, addr, bcount, cbpp);
#endif
d853 2
a854 5
#ifdef DEBUG
		if (ccddebug & CCDB_IO)
			printf("ccdisk %d cbn %d ci %p ci2 %p\n",
			    ccdisk, cbn, ci, ci2);
#endif
d942 3
a944 5
#ifdef DEBUG
		if (ccddebug & CCDB_IO)
			printf("ccdbuffer: sg %d (%p/%x) off %x\n",
			    cbp->cb_sgcnt, addr, bcount, old_bcount);
#endif
d952 3
a954 6
#ifdef DEBUG
	if (ccddebug & CCDB_IO)
		printf(" dev %x(u%d): cbp %p bn %d addr %p bcnt %ld\n",
		    ci->ci_dev, ci-cs->sc_cinfo, cbp, bp->b_blkno,
		    bp->b_data, bp->b_bcount);
#endif
d965 2
a966 4
#ifdef DEBUG
	if (ccddebug & CCDB_FOLLOW)
		printf("ccdintr(%p, %p)\n", cs, bp);
#endif
d995 8
a1002 14
#ifdef DEBUG
	if (ccddebug & CCDB_FOLLOW)
		printf("ccdiodone(%p)\n", cbp);
	if (ccddebug & CCDB_IO) {
		if (cbp->cb_flags & CBF_MIRROR)
			printf("ccdiodone: mirror component\n");
		else
			printf("ccdiodone: bp %p bcount %ld resid %ld\n",
			    bp, bp->b_bcount, bp->b_resid);
		printf(" dev %x(u%d), cbp %p bn %d addr %p bcnt %ld\n",
		    vbp->b_dev, cbp->cb_comp, cbp, vbp->b_blkno,
		    vbp->b_data, vbp->b_bcount);
	}
#endif
d1035 4
a1038 6
#ifdef DEBUG
			if (ccddebug & CCDB_IO)
				printf("ccdiodone: sg %d (%p/%x) off %x\n", i,
				    cbp->cb_sg[i].cs_sgaddr,
				    cbp->cb_sg[i].cs_sglen, off);
#endif
d1076 2
a1077 4
#ifdef DEBUG
	if (ccddebug & CCDB_FOLLOW)
		printf("ccdread(%x, %p)\n", dev, uio);
#endif
d1100 2
a1101 4
#ifdef DEBUG
	if (ccddebug & CCDB_FOLLOW)
		printf("ccdwrite(%x, %p)\n", dev, uio);
#endif
a1189 7
#ifdef DEBUG
		if (ccddebug & CCDB_INIT)
			for (i = 0; i < ccio->ccio_ndisks; ++i)
				printf("ccdioctl: component %d: %p\n",
				    i, cpp[i]);
#endif

d1191 3
a1193 4
#ifdef DEBUG
			if (ccddebug & CCDB_INIT)
				printf("ccdioctl: lookedup = %d\n", lookedup);
#endif
d1290 3
a1292 5
#ifdef DEBUG
			if (ccddebug & CCDB_VNODE)
				vprint("CCDIOCCLR: vnode info",
				    cs->sc_cinfo[i].ci_vp);
#endif
d1437 2
a1438 4
#ifdef DEBUG
		if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
			printf("ccdlookup: vn_open error = %d\n", error);
#endif
d1450 2
a1451 4
#ifdef DEBUG
		if (ccddebug & (CCDB_FOLLOW|CCDB_INIT))
			printf("ccdlookup: getattr error = %d\n", error);
#endif
d1464 1
a1464 4
#ifdef DEBUG
	if (ccddebug & CCDB_VNODE)
		vprint("ccdlookup: vnode info", vp);
#endif
a1515 1
#ifdef DEBUG
d1517 2
a1518 4
	if (ccddebug & CCDB_LABEL)
		if (errstring != NULL)
			printf("%s: %s\n", cs->sc_xname, errstring);
#endif
d1573 1
a1573 1
#ifdef DEBUG
@


1.61
log
@ANSIfy, some KNF and zap a little bit of whitespace.

No binary changes.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.59 2005/03/30 22:28:00 mickey Exp $	*/
d1253 1
a1253 1
				printf("ccdioctl: component %d: 0x%p\n",
@


1.60
log
@Add a bzero() after malloc() when allocating component info in ccdinit().

This fixes a panic in ccd(4) mirroring where the second component could be
wrongly treated as failed, which leads to uvm_fault in write operation.

ok mickey@@
@
text
@d231 1
a231 2
putccdbuf(cbp)
	struct ccdbuf *cbp;
d241 1
a241 2
ccdattach(num)
	int num;
d274 1
a274 4
ccdinit(ccd, cpaths, p)
	struct ccddevice *ccd;
	char **cpaths;
	struct proc *p;
d363 2
a364 2
				 printf("%s: %s: ioctl failed, error = %d\n",
				     cs->sc_xname, ci->ci_path, error);
d445 1
a445 1
		if (cs->sc_nccdisks % 2) { 
d449 1
a449 1
			    cs->sc_xname); 
d495 1
a495 2
ccdinterleave(cs)
	struct ccd_softc *cs;
d598 1
a598 4
ccdopen(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
d659 1
a659 4
ccdclose(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
d697 1
a697 2
ccdstrategy(bp)
	struct buf *bp;
d748 1
a748 3
ccdstart(cs, bp)
	struct ccd_softc *cs;
	struct buf *bp;
d827 2
a828 8
ccdbuffer(cs, bp, bn, addr, bcount, cbpp, old_io)
	struct ccd_softc *cs;
	struct buf *bp;
	daddr_t bn;
	caddr_t addr;
	long bcount;
	struct ccdbuf **cbpp;
	int old_io;
d935 1
a935 1
							    bp->b_bcount);
d1006 1
a1006 3
ccdintr(cs, bp)
	struct ccd_softc *cs;
	struct buf *bp;
d1031 1
a1031 2
ccdiodone(vbp)
	struct buf *vbp;
d1127 1
a1127 4
ccdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d1153 1
a1153 4
ccdwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d1178 1
a1178 6
ccdioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d1456 1
a1456 2
ccdsize(dev)
	dev_t dev;
d1485 1
a1485 5
ccddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
d1498 1
a1498 4
ccdlookup(path, p, vpp)
	char *path;
	struct proc *p;
	struct vnode **vpp;	/* result */
d1606 1
a1606 2
ccdmakedisklabel(cs)
	struct ccd_softc *cs;
d1626 1
a1626 2
ccdlock(cs)
	struct ccd_softc *cs;
d1643 1
a1643 2
ccdunlock(cs)
	struct ccd_softc *cs;
d1655 1
a1655 2
printiinfo(ii)
	struct ccdiinfo *ii;
@


1.59
log
@init pool after we allocate softc array in case malloc fails
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.58 2005/03/25 17:51:16 mickey Exp $	*/
d312 1
@


1.58
log
@calculate the rpm for a disklabel; implement new io discipline for mirror; this also changes the mirror striping strategy a bit to achieve the scatter-gathering; of course it has been proven that new discipline still makes troubles thus not enabling it yet );
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.57 2005/03/12 16:33:53 mickey Exp $	*/
a251 6
	ccdbufsizeof = sizeof(struct ccdbuf) +
	    (CCD_SGMAX - 1) * sizeof(struct ccdseg);
	pool_init(&ccdbufpl, ccdbufsizeof, 0, 0, 0, "ccdbufpl", NULL);
	pool_setlowat(&ccdbufpl, 16);
	pool_sethiwat(&ccdbufpl, 1024);

d267 6
@


1.57
log
@initialise min arg to uvm_km_suballoc; not currently enabled code path
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.56 2005/02/24 19:36:39 mickey Exp $	*/
d96 1
a96 1
/*#define	CCDDEBUG */
d284 1
a284 1
	int ix;
d319 1
d413 1
d415 1
d826 1
a826 1
		for (i = 0; i < cs->sc_nccdisks; i++) {
d853 1
a853 1
	int ccdisk, off;
d900 2
a901 1
			ci2 = &cs->sc_cinfo[ccdisk + ii->ii_ndisk];
d903 5
a907 2
			if (bp->b_flags & B_READ && cbn & 1)
				ccdisk += ii->ii_ndisk;
d975 1
d977 10
a986 9
			cbp = getccdbuf();
			*cbp = *cbpp[0];
			cbp->cb_flags = CBF_MIRROR | (old_io ? CBF_OLD : 0);
			cbp->cb_buf.b_dev = ci2->ci_dev;	/* XXX */
			cbp->cb_buf.b_vp = ci2->ci_vp;
			LIST_INIT(&cbp->cb_buf.b_dep);
			cbp->cb_comp = ci2 - cs->sc_cinfo;
			cbp->cb_dep = cbpp[0];
			cbpp[0]->cb_dep = cbpp[1] = cbp;
d1060 1
a1060 1
	int cbflags, i;
d1095 11
a1105 1
	cbflags = cbp->cb_flags |= CBF_DONE;
a1130 4
	if (cbp->cb_dep &&
	    (cbp->cb_dep->cb_flags & CBF_DONE) != (cbflags & CBF_DONE))
		return;

d1256 1
a1256 1
		/* new code seems to work now but enable it after a release */
d1261 1
a1261 2
		 * must use the old I/O code (by design), as must mirror
		 * setups (until implemented in the new code).
d1263 1
a1263 2
		if (ccio->ccio_ileave % (PAGE_SIZE / DEV_BSIZE) != 0 ||
		    (ccd.ccd_flags & CCDF_MIRROR))
d1610 1
a1614 1
	lp->d_rpm = 3600;
@


1.57.2.1
log
@MFC:
Fix by niallo@@

Add a bzero() after malloc() when allocating component info in ccdinit().

This fixes a panic in ccd(4) mirroring where the second component could be
wrongly treated as failed, which leads to uvm_fault in write operation.

ok niallo@@ mickey@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.57 2005/03/12 16:33:53 mickey Exp $	*/
a311 1
	bzero(cs->sc_cinfo, cs->sc_nccdisks * sizeof(struct ccdcinfo));
@


1.56
log
@fix a buffer-done race that makes mirroring work now;
use pool instead of malloc/free and this fixes new buffer mode;
implement DIOCGPDINFO for disklabel -d;
tested by henning@@ millert@@ fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.55 2004/02/15 02:45:46 tedu Exp $	*/
d1332 2
a1333 1
		if (!ccdmap && !(ccd.ccd_flags & CCDF_OLD))
d1337 1
@


1.55
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.54 2004/01/09 21:32:23 brad Exp $	*/
d7 1
d96 1
d104 1
d146 2
a147 5

struct ccdseg {
	caddr_t		cs_sgaddr;	/* scatter/gather segment addresses */
	long		cs_sglen;	/* scatter/gather segment lengths */
};
d152 2
a153 1
	int		cb_unit;	/* target unit */
d158 1
d161 5
a165 1
	struct ccdseg	*cb_sg;		/* scatter/gather segments */
a167 3
#define CCDLABELDEV(dev)	\
	(MAKEDISKDEV(major((dev)), ccdunit((dev)), RAW_PART))

d176 1
a176 1
void	ccdinterleave(struct ccd_softc *, int);
d182 2
a183 1
void	ccdgetdisklabel(dev_t);
d198 1
d200 5
a204 2
/* A separate map so that locking on kernel_map won't happen in interrupts */
static struct vm_map *ccdmap;
d210 6
a215 1
static int ccd_need_kvm = 0;
d221 1
a221 1
getccdbuf()
d225 2
a226 4
	cbp = malloc(sizeof (struct ccdbuf), M_DEVBUF, M_WAITOK);
	bzero(cbp, sizeof (struct ccdbuf));
	cbp->cb_sg = malloc(sizeof (struct ccdseg) * MAXBSIZE >> PAGE_SHIFT,
	    M_DEVBUF, M_WAITOK);
d234 1
a234 2
	free((caddr_t)cbp->cb_sg, M_DEVBUF);
	free((caddr_t)cbp, M_DEVBUF);
d252 6
d296 2
a297 1
		printf("ccdinit: unit %d\n", ccd->ccd_unit);
d462 1
d469 2
a470 3
			cs->sc_size = (cs->sc_nccdisks / 2) * minsize;
		else
			cs->sc_size = cs->sc_nccdisks * minsize;
d473 2
d478 1
a478 1
	ccdinterleave(cs, ccd->ccd_unit);
d485 4
a488 3
	ccg->ccg_ntracks = 1;
	ccg->ccg_nsectors = 1024 * (1024 / ccg->ccg_secsize);
	ccg->ccg_ncylinders = cs->sc_size / ccg->ccg_nsectors;
a490 2
	cs->sc_cflags = ccd->ccd_flags;	/* So we can find out later... */
	cs->sc_unit = ccd->ccd_unit;
d496 1
a496 1
ccdinterleave(cs, unit)
a497 1
	int unit;
d584 1
a584 1
		    ci < &cs->sc_cinfo[cs->sc_nccdisks]; ci++)
d632 1
a632 1
		ccdgetdisklabel(dev);
d766 1
a766 1
	int i, old_io = ccddevs[cs->sc_unit].ccd_flags & CCDF_OLD;
d770 2
a771 1
		printf("ccdstart(%p, %p)\n", cs, bp);
a806 3
			/*
			 * Mirror requires additional write.
			 */
d857 2
a858 2
		printf("ccdbuffer(%p, %p, %d, %p, %ld)\n", cs, bp, bn, addr,
		    bcount);
d892 9
a900 13
			if (cs->sc_cflags & CCDF_MIRROR) {
				ccdisk =
				    ii->ii_index[off % (ii->ii_ndisk / 2)];
				cbn = ii->ii_startoff +
				    (off / (ii->ii_ndisk / 2));
				/* Mirrored data */
				ci2 =
				    &cs->sc_cinfo[ccdisk + (ii->ii_ndisk / 2)];
			} else {
				/* Normal case. */
				ccdisk = ii->ii_index[off % ii->ii_ndisk];
				cbn = ii->ii_startoff + off / ii->ii_ndisk;
			}
d904 5
d939 1
a939 1
		cbp->cb_unit = cs->sc_unit;
d976 2
a977 1
			cbpp[1] = cbp;
d1049 1
a1049 2
	int unit = cbp->cb_unit;
	struct ccd_softc *cs = &ccd_softc[unit];
d1073 1
d1086 1
a1086 1
	cbflags = cbp->cb_flags;
d1111 5
d1117 2
d1120 11
a1130 13
	if ((cbflags & CBF_MIRROR) == 0) {
		/*
		 * If all done, "interrupt".
		 *
		 * Note that mirror component buffers aren't counted against
		 * the original I/O buffer.
		 */
		if (count > bp->b_resid)
			panic("ccdiodone: count");
		bp->b_resid -= count;
		if (bp->b_resid == 0)
			ccdintr(&ccd_softc[unit], bp);
	}
d1211 1
d1213 13
a1227 1

a1232 3
		if ((flag & FWRITE) == 0)
			return (EBADF);

d1241 1
a1241 1
		/* XXX the new code is unstable still */
d1342 2
a1343 1
		ccdgetdisklabel(dev);
a1345 1

a1348 6
		if ((cs->sc_flags & CCDF_INITED) == 0)
			return (ENXIO);

		if ((flag & FWRITE) == 0)
			return (EBADF);

d1411 1
d1413 10
d1424 1
a1426 3
		if ((cs->sc_flags & CCDF_INITED) == 0)
			return (ENXIO);

a1430 3
		if ((cs->sc_flags & CCDF_INITED) == 0)
			return (ENXIO);

a1437 6
		if ((cs->sc_flags & CCDF_INITED) == 0)
			return (ENXIO);

		if ((flag & FWRITE) == 0)
			return (EBADF);

a1460 5
		if ((cs->sc_flags & CCDF_INITED) == 0)
			return (ENXIO);

		if ((flag & FWRITE) == 0)
			return (EBADF);
d1580 2
a1581 2
ccdgetdisklabel(dev)
	dev_t dev;
d1583 1
a1583 2
	int unit = ccdunit(dev);
	struct ccd_softc *cs = &ccd_softc[unit];
a1584 3
	struct disklabel *lp = cs->sc_dkdev.dk_label;
	struct cpu_disklabel *clp = cs->sc_dkdev.dk_cpulabel;
	struct ccdgeom *ccg = &cs->sc_geom;
d1616 1
a1616 1
	    cs->sc_dkdev.dk_label, cs->sc_dkdev.dk_cpulabel, 0);
@


1.54
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.53 2003/06/02 23:28:01 millert Exp $	*/
d1016 2
a1017 1
	disk_unbusy(&cs->sc_dkdev, (bp->b_bcount - bp->b_resid));
@


1.53
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.52 2003/04/04 02:21:26 krw Exp $	*/
a113 2

#include <uvm/uvm_extern.h>
@


1.52
log
@sprintf -> snprintf, plus check for overflow in device name.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.51 2003/03/28 02:39:07 millert Exp $	*/
d59 1
a59 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.51
log
@In ccdsize(), check for CCDF_INITED before doing the ccdopen().
Adapted from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.50 2002/11/10 21:23:09 miod Exp $	*/
d292 5
a296 1
	sprintf(cs->sc_xname, "ccd%d", ccd->ccd_unit);	/* XXX */
@


1.50
log
@Use appropriate VM_MAP constants rather than hardcoded values in
uvm_map_create() and uvm_km_suballoc().
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.49 2002/05/24 13:10:52 art Exp $	*/
d1459 1
a1459 1
	int part, size;
d1461 2
a1462 1
	if (ccdopen(dev, 0, S_IFBLK, curproc))
d1465 3
a1467 2
	cs = &ccd_softc[ccdunit(dev)];
	part = DISKPART(dev);
d1469 1
a1469 1
	if ((cs->sc_flags & CCDF_INITED) == 0)
d1472 1
@


1.49
log
@Make sure that b_iodone handlers are called at splbio (and splassert(IPL_BIO) in all known callers, just to make sure).
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.48 2002/05/23 14:28:36 art Exp $	*/
d1303 2
a1304 1
			    CCD_CLUSTERS * MAXBSIZE, FALSE, FALSE, NULL);
@


1.48
log
@protect biodone with splbio.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.47 2002/03/14 01:26:52 millert Exp $	*/
d1036 1
a1036 1
	int cbflags, s, i;
d1040 2
a1041 1
	s = splbio();
a1109 1
	splx(s);
@


1.47
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.46 2001/11/28 16:13:29 art Exp $	*/
d736 1
d738 1
d1006 2
@


1.46
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.45 2001/11/06 19:53:18 miod Exp $	*/
d172 1
a172 1
void	ccdattach __P((int));
d175 2
a176 2
void	ccdiodone __P((struct buf *));
int	ccdsize __P((dev_t));
d178 13
a190 13
void	ccdstart __P((struct ccd_softc *, struct buf *));
void	ccdinterleave __P((struct ccd_softc *, int));
void	ccdintr __P((struct ccd_softc *, struct buf *));
int	ccdinit __P((struct ccddevice *, char **, struct proc *));
int	ccdlookup __P((char *, struct proc *p, struct vnode **));
long	ccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,
    long, struct ccdbuf **, int));
void	ccdgetdisklabel __P((dev_t));
void	ccdmakedisklabel __P((struct ccd_softc *));
int	ccdlock __P((struct ccd_softc *));
void	ccdunlock __P((struct ccd_softc *));
INLINE struct ccdbuf *getccdbuf __P((void));
INLINE void putccdbuf __P((struct ccdbuf *));
d193 1
a193 1
void	printiinfo __P((struct ccdiinfo *));
@


1.46.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.46 2001/11/28 16:13:29 art Exp $	*/
d172 1
a172 1
void	ccdattach(int);
d175 2
a176 2
void	ccdiodone(struct buf *);
int	ccdsize(dev_t);
d178 13
a190 13
void	ccdstart(struct ccd_softc *, struct buf *);
void	ccdinterleave(struct ccd_softc *, int);
void	ccdintr(struct ccd_softc *, struct buf *);
int	ccdinit(struct ccddevice *, char **, struct proc *);
int	ccdlookup(char *, struct proc *p, struct vnode **);
long	ccdbuffer(struct ccd_softc *, struct buf *, daddr_t, caddr_t,
    long, struct ccdbuf **, int);
void	ccdgetdisklabel(dev_t);
void	ccdmakedisklabel(struct ccd_softc *);
int	ccdlock(struct ccd_softc *);
void	ccdunlock(struct ccd_softc *);
INLINE struct ccdbuf *getccdbuf(void);
INLINE void putccdbuf(struct ccdbuf *);
d193 1
a193 1
void	printiinfo(struct ccdiinfo *);
a735 1
	s = splbio();
a736 1
	splx(s);
a1004 2
	splassert(IPL_BIO);

d1032 1
a1032 1
	int cbflags, i;
d1036 1
a1036 2
	splassert(IPL_BIO);

d1105 1
@


1.46.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d292 1
a292 5
	if (snprintf(cs->sc_xname, sizeof(cs->sc_xname), "ccd%d",
	    ccd->ccd_unit) >= sizeof(cs->sc_xname)) {
		printf("ccdinit: device name too long.\n");
		return(ENXIO);
	}
d1303 1
a1303 2
			    CCD_CLUSTERS * MAXBSIZE, VM_MAP_INTRSAFE,
			    FALSE, NULL);
d1458 1
a1458 1
	int part, size, unit;
d1460 1
a1460 2
	unit = ccdunit(dev);
	if (unit >= numccd)
d1463 3
a1465 1
	cs = &ccd_softc[unit];
a1468 4
	if (ccdopen(dev, 0, S_IFBLK, curproc))
		return (-1);

	part = DISKPART(dev);
@


1.45
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.44 2001/09/19 20:50:58 mickey Exp $	*/
d202 1
a202 1
static vm_map_t ccdmap;
@


1.44
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.43 2001/06/27 04:45:56 art Exp $	*/
a118 1
#include <vm/vm.h>
@


1.43
log
@zap old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.42 2001/05/05 20:56:58 art Exp $	*/
a119 2
#include <vm/vm_kern.h>

@


1.42
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.41 1999/11/26 16:46:17 art Exp $	*/
a121 1
#if defined(UVM)
a122 1
#endif
a933 1
#if defined(UVM)
a935 4
#else
				nbp->b_data = (caddr_t) kmem_alloc_pageable(
							 ccdmap, bp->b_bcount);
#endif
a1085 1
#if defined(UVM)
a1086 3
#else
		kmem_free(ccdmap, (vaddr_t)vbp->b_data, count);
#endif
a1300 1
#if defined(UVM)
a1302 4
#else
			ccdmap = kmem_suballoc(kernel_map, &min, &max,
			    CCD_CLUSTERS * MAXBSIZE, FALSE);
#endif
@


1.41
log
@vm_offset_t -> vaddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.40 1999/09/11 00:13:45 mickey Exp $	*/
d225 1
a225 1
	cbp->cb_sg = malloc(sizeof (struct ccdseg) * MAXBSIZE / CLBYTES,
d780 1
a780 1
	old_io = old_io || ((vaddr_t)addr & CLOFSET); /* XXX !claligned */
d787 1
a787 1
		 * of CLBYTES and mirroring.
d992 2
a993 3
		pagemove(addr, nbp->b_data + old_bcount,
		    clrnd(round_page(bcount)));
		nbp->b_bufsize += clrnd(round_page(bcount));
d1089 1
a1089 1
			    clrnd(round_page(cbp->cb_sg[i].cs_sglen)));
d1228 1
a1228 1
		if (ccio->ccio_ileave % (CLBYTES / DEV_BSIZE) != 0 ||
@


1.41.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.41 1999/11/26 16:46:17 art Exp $	*/
d122 1
d124 1
d225 1
a225 1
	cbp->cb_sg = malloc(sizeof (struct ccdseg) * MAXBSIZE >> PAGE_SHIFT,
d780 1
a780 1
	old_io = old_io || ((vaddr_t)addr & PAGE_MASK);
d787 1
a787 1
		 * of PAGE_SIZE and mirroring.
d936 1
d939 4
d992 3
a994 2
		pagemove(addr, nbp->b_data + old_bcount, round_page(bcount));
		nbp->b_bufsize += round_page(bcount);
d1090 1
a1090 1
			    round_page(cbp->cb_sg[i].cs_sglen));
d1094 1
d1096 3
d1229 1
a1229 1
		if (ccio->ccio_ileave % (PAGE_SIZE / DEV_BSIZE) != 0 ||
d1313 1
d1316 4
@


1.41.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.41.2.1 2001/07/04 10:40:09 niklas Exp $	*/
d120 2
@


1.41.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d119 1
@


1.41.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.41.2.3 2001/11/13 21:09:59 niklas Exp $	*/
d202 1
a202 1
static struct vm_map *ccdmap;
@


1.41.2.5
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d172 1
a172 1
void	ccdattach(int);
d175 2
a176 2
void	ccdiodone(struct buf *);
int	ccdsize(dev_t);
d178 13
a190 13
void	ccdstart(struct ccd_softc *, struct buf *);
void	ccdinterleave(struct ccd_softc *, int);
void	ccdintr(struct ccd_softc *, struct buf *);
int	ccdinit(struct ccddevice *, char **, struct proc *);
int	ccdlookup(char *, struct proc *p, struct vnode **);
long	ccdbuffer(struct ccd_softc *, struct buf *, daddr_t, caddr_t,
    long, struct ccdbuf **, int);
void	ccdgetdisklabel(dev_t);
void	ccdmakedisklabel(struct ccd_softc *);
int	ccdlock(struct ccd_softc *);
void	ccdunlock(struct ccd_softc *);
INLINE struct ccdbuf *getccdbuf(void);
INLINE void putccdbuf(struct ccdbuf *);
d193 1
a193 1
void	printiinfo(struct ccdiinfo *);
@


1.41.2.6
log
@Sync the SMP branch with 3.3
@
text
@a735 1
	s = splbio();
a736 1
	splx(s);
a1004 2
	splassert(IPL_BIO);

d1032 1
a1032 1
	int cbflags, i;
d1036 1
a1036 2
	splassert(IPL_BIO);

d1105 1
d1299 1
a1299 2
			    CCD_CLUSTERS * MAXBSIZE, VM_MAP_INTRSAFE,
			    FALSE, NULL);
@


1.41.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.41.2.6 2003/03/28 00:38:09 niklas Exp $	*/
d292 1
a292 5
	if (snprintf(cs->sc_xname, sizeof(cs->sc_xname), "ccd%d",
	    ccd->ccd_unit) >= sizeof(cs->sc_xname)) {
		printf("ccdinit: device name too long.\n");
		return(ENXIO);
	}
d1459 1
a1459 1
	int part, size, unit;
d1461 1
a1461 2
	unit = ccdunit(dev);
	if (unit >= numccd)
d1464 3
a1466 1
	cs = &ccd_softc[unit];
a1469 4
	if (ccdopen(dev, 0, S_IFBLK, curproc))
		return (-1);

	part = DISKPART(dev);
@


1.41.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.41.2.7 2003/05/13 19:34:56 ho Exp $	*/
d59 5
a63 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.41.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d114 2
@


1.41.2.10
log
@Merge with the trunk
@
text
@d1016 1
a1016 2
	disk_unbusy(&cs->sc_dkdev, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));
@


1.40
log
@s/vm_offset_t/vaddr_t/g
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.39 1999/09/10 23:31:54 art Exp $	*/
d1097 1
a1097 1
		kmem_free(ccdmap, (vm_offset_t)vbp->b_data, count);
@


1.39
log
@roundup(foo, CLBYTES) -> clrnd(round_page(foo))
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.38 1999/02/26 01:38:23 art Exp $	*/
d780 1
a780 1
	old_io = old_io || ((vm_offset_t)addr & CLOFSET); /* XXX !claligned */
d1197 1
a1197 1
	vm_offset_t min, max;
@


1.38
log
@uvm compat
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.37 1998/10/03 21:19:00 millert Exp $	*/
d993 2
a994 2
		    roundup(bcount, CLBYTES));
		nbp->b_bufsize += roundup(bcount, CLBYTES);
d1090 1
a1090 1
			    roundup(cbp->cb_sg[i].cs_sglen, CLBYTES));
@


1.37
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.36 1998/08/04 21:26:35 millert Exp $	*/
d122 4
d936 7
a942 2
				nbp->b_data = (caddr_t)kmem_alloc_pageable(
				    ccdmap, bp->b_bcount);
d1094 3
d1098 1
d1313 4
d1319 1
@


1.36
log
@don't rely on b_resid being signed
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.35 1998/03/10 20:43:17 millert Exp $	*/
d1594 1
a1594 1
	    cs->sc_dkdev.dk_label, cs->sc_dkdev.dk_cpulabel);
@


1.35
log
@Play nicely with soft updates.  Based on a patch from Kirk via FreeBSD--untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.34 1998/02/06 22:17:16 deraadt Exp $	*/
d1101 2
a1103 2
		if (bp->b_resid < 0)
			panic("ccdiodone: count");
@


1.34
log
@add FS_CCD, make ccd prefer such partitions. It still accespts FS_BSDFFS, and something will change about that soon
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.33 1998/01/25 09:42:31 niklas Exp $	*/
d918 1
d959 1
@


1.33
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.31 1998/01/25 09:22:28 niklas Exp $	*/
d359 2
a360 1
		if (dpart.part->p_fstype == FS_BSDFFS) {
@


1.32
log
@Disable the new buffer policy for now
@
text
@d1205 1
a1205 1
		/* XXX the new code is unstable yet */
@


1.31
log
@Remove redundant splbio I added yesterday
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.30 1998/01/24 22:53:49 niklas Exp $	*/
d1204 3
@


1.30
log
@On the other hand... no need for recursive locks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.27 1998/01/24 21:12:36 niklas Exp $	*/
d835 1
a835 1
	int ccdisk, off, s;
a929 1
				s = splbio();
a931 1
				splx(s);
@


1.29
log
@Well when MP comes.. we need locks
@
text
@a930 1
				vm_map_lock(ccdmap);
a932 1
				vm_map_unlock(ccdmap);
@


1.28
log
@Protect allocation of ccd physmem of ccd interrupts
@
text
@d931 1
d934 1
@


1.27
log
@Eek, missing splbio, although splx was there. marging two "if"s
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.26 1998/01/21 12:16:04 niklas Exp $	*/
d835 1
a835 1
	int ccdisk, off;
d930 1
d933 2
@


1.26
log
@remove obsolete comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.25 1998/01/09 14:36:11 niklas Exp $	*/
d1034 1
d1065 1
a1065 1
	if (!old_io)
a1080 1
	if (!old_io) {
@


1.25
log
@Clear buffers on allocation, suggested by csapuntz
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.24 1998/01/07 00:48:10 niklas Exp $	*/
a164 5
	/*
	 * XXX These statically sized scatter/gather parameter vectors
	 * should maybe be dynamic instead... but that costs malloc time
	 * in ccdstart.
	 */
@


1.24
log
@DOH!  I managed to alloc 0 bytes always for the segment descriptors.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.23 1997/12/15 03:52:24 mickey Exp $	*/
d225 1
@


1.23
log
@compile w/ DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.22 1997/12/12 20:22:35 niklas Exp $	*/
d224 3
a226 2
	cbp = malloc(sizeof(struct ccdbuf), M_DEVBUF, M_WAITOK);
	cbp->cb_sg = malloc(DEV_BSIZE / CLBYTES, M_DEVBUF, M_WAITOK);
@


1.22
log
@Make compile on systems where NBPG is not a constant
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.21 1997/11/26 22:30:20 niklas Exp $	*/
d980 1
a980 1
			    cbp->cb_sg->cs_sgcnt, addr, bcount, old_bcount);
@


1.21
log
@Optimized to perform well on small interleaves which makes the ccd driver
really useful as a performance booster.  The interleave needs to be a
multiple of the software page size (CLBYTES) and not have mirror components
if the new optimized policy should be used, otherwise the old policy will
be used still.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.20 1997/11/06 05:58:08 csapuntz Exp $	*/
d122 6
d151 5
d171 1
a171 4
	caddr_t		cb_sgaddr[MAXBSIZE / CLBYTES];
					/* scatter/gather segment addresses */
	long		cb_sglen[MAXBSIZE / CLBYTES];
					/* scatter/gather segment lengths */
a173 5
#define	getccdbuf()		\
	((struct ccdbuf *)malloc(sizeof(struct ccdbuf), M_DEVBUF, M_WAITOK))
#define putccdbuf(cbp)		\
	free((caddr_t)(cbp), M_DEVBUF)

d195 2
d217 21
d980 1
a980 1
			    cbp->cb_sgcnt, addr, bcount, old_bcount);
d985 2
a986 2
		cbp->cb_sgaddr[cbp->cb_sgcnt] = addr;
		cbp->cb_sglen[cbp->cb_sgcnt] = bcount;
d1075 2
a1076 1
				    cbp->cb_sgaddr[i], cbp->cb_sglen[i], off);
d1078 3
a1080 3
			pagemove(vbp->b_data + off, cbp->cb_sgaddr[i],
			    roundup(cbp->cb_sglen[i], CLBYTES));
			off += cbp->cb_sglen[i];
@


1.20
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.19 1997/10/06 20:19:39 deraadt Exp $	*/
d6 1
d8 1
a8 1
 *
d11 1
d96 2
d119 11
d151 2
d154 10
a163 1
#define CBF_MIRROR	0x01		/* we're for a mirror component */
d186 2
a187 2
void	ccdbuffer __P((struct ccd_softc *, struct buf *,
		daddr_t, caddr_t, long, struct ccdbuf **));
d202 9
d249 4
a252 4
	register struct ccd_softc *cs = &ccd_softc[ccd->ccd_unit];
	register struct ccdcinfo *ci = NULL;
	register size_t size;
	register int ix;
d458 1
a458 1
	register struct ccd_softc *cs;
d461 4
a464 4
	register struct ccdcinfo *ci, *smallci;
	register struct ccdiinfo *ii;
	register daddr_t bn, lbn;
	register int ix;
d520 1
a520 1
		     ci < &cs->sc_cinfo[cs->sc_nccdisks]; ci++)
d523 1
a523 1
			     ci->ci_size < smallci->ci_size))
d546 1
a546 1
		     ci < &cs->sc_cinfo[cs->sc_nccdisks]; ci++)
d600 1
a600 1
		     (lp->d_partitions[part].p_fstype == FS_UNUSED))) {
d668 1
a668 1
	register struct buf *bp;
d670 3
a672 3
	register int unit = ccdunit(bp->b_dev);
	register struct ccd_softc *cs = &ccd_softc[unit];
	register int s;
d701 1
a701 1
			goto done;
d718 2
a719 2
	register struct ccd_softc *cs;
	register struct buf *bp;
d721 2
a722 2
	register long bcount, rcount;
	struct ccdbuf *cbp[4];
d726 1
d746 1
a746 1
	 * Allocate component buffers and fire off the requests
d748 3
d752 1
d754 2
a755 6
		ccdbuffer(cs, bp, bn, addr, bcount, cbp);
		rcount = cbp[0]->cb_buf.b_bcount;
		if ((cbp[0]->cb_buf.b_flags & B_READ) == 0)
			cbp[0]->cb_buf.b_vp->v_numoutput++;
		VOP_STRATEGY(&cbp[0]->cb_buf);

d757 3
a759 1
		 * Mirror requires additional write.
d761 13
a773 4
		if ((cs->sc_cflags & CCDF_MIRROR) &&
		    ((cbp[0]->cb_buf.b_flags & B_READ) == 0)) {
			cbp[1]->cb_buf.b_vp->v_numoutput++;
			VOP_STRATEGY(&cbp[1]->cb_buf);
d779 15
d799 3
a801 3
void
ccdbuffer(cs, bp, bn, addr, bcount, cbpp)
	register struct ccd_softc *cs;
d807 1
d809 7
a815 4
	register struct ccdcinfo *ci, *ci2 = NULL;
	register struct ccdbuf *cbp;
	register daddr_t cbn, cboff;
	int ccdisk;
d819 2
a820 2
		printf("ccdbuffer(%p, %p, %d, %p, %ld)\n",
		       cs, bp, bn, addr, bcount);
d822 1
a828 3
	/*
	 * Serially concatenated
	 */
d830 3
a832 2
		register daddr_t sblk;

d839 4
a842 8
	}
	/*
	 * Interleaved
	 */
	else {
		register struct ccdiinfo *ii;
		int off;

d872 1
a872 12
	/*
	 * Fill in the component buf structure.
	 */
	cbp = getccdbuf();
	cbp->cb_flags = 0;
	cbp->cb_buf.b_flags = bp->b_flags | B_CALL;
	cbp->cb_buf.b_iodone = ccdiodone;
	cbp->cb_buf.b_proc = bp->b_proc;
	cbp->cb_buf.b_dev = ci->ci_dev;		/* XXX */
	cbp->cb_buf.b_blkno = cbn + cboff;
	cbp->cb_buf.b_data = addr;
	cbp->cb_buf.b_vp = ci->ci_vp;
d874 1
a874 1
		cbp->cb_buf.b_bcount = dbtob(ci->ci_size - cbn);
d876 3
a878 3
		cbp->cb_buf.b_bcount = dbtob(cs->sc_ileave - cboff);
	if (cbp->cb_buf.b_bcount > bcount)
		cbp->cb_buf.b_bcount = bcount;
d880 69
a948 6
	/*
	 * context for ccdiodone
	 */
	cbp->cb_obp = bp;
	cbp->cb_unit = cs->sc_unit;
	cbp->cb_comp = ccdisk;
d950 13
a962 2
	/* First buffer is dealt with. */
	cbpp[0] = cbp;
d967 2
a968 2
		       ci->ci_dev, ci-cs->sc_cinfo, cbp, cbp->cb_buf.b_blkno,
		       cbp->cb_buf.b_data, cbp->cb_buf.b_bcount);
d971 1
a971 14
	/*
	 * Mirrors have an additional write operation that is nearly
	 * identical to the first.
	 */
	if ((cs->sc_cflags & CCDF_MIRROR) &&
	    ((cbp->cb_buf.b_flags & B_READ) == 0)) {
		cbp = getccdbuf();
		*cbp = *cbpp[0];
		cbp->cb_flags = CBF_MIRROR;
		cbp->cb_buf.b_dev = ci2->ci_dev;	/* XXX */
		cbp->cb_buf.b_vp = ci2->ci_vp;
		cbp->cb_comp = ci2 - cs->sc_cinfo;
		cbpp[1] = cbp;
	}
d976 2
a977 2
	register struct ccd_softc *cs;
	register struct buf *bp;
d1002 3
a1004 3
	struct ccdbuf *cbp = (struct ccdbuf *) vbp;
	register struct buf *bp = cbp->cb_obp;
	register int unit = cbp->cb_unit;
d1006 3
a1008 1
	int count, cbflags, s;
a1010 1
	s = splbio();
d1019 1
a1019 1
			       bp, bp->b_bcount, bp->b_resid);
d1021 2
a1022 3
		       cbp->cb_buf.b_dev, cbp->cb_comp, cbp,
		       cbp->cb_buf.b_blkno, cbp->cb_buf.b_data,
		       cbp->cb_buf.b_bcount);
d1026 1
a1026 1
	if (cbp->cb_buf.b_flags & B_ERROR) {
d1031 2
a1032 2
			bp->b_error = cbp->cb_buf.b_error ?
			    cbp->cb_buf.b_error : EIO;
d1037 1
a1037 1
		       cs->sc_xname, bp->b_error, cbp->cb_comp, comptype);
a1038 1
	count = cbp->cb_buf.b_bcount;
d1040 24
a1065 6
	/*
	 * If all done, "interrupt".
	 *
	 * Note that mirror component buffers aren't counted against
	 * the original I/O buffer.
	 */
d1067 6
d1156 1
d1181 9
d1259 13
d1635 1
a1635 1
	register int ix, i;
@


1.19
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.17 1997/08/08 21:47:01 niklas Exp $	*/
d1329 1
a1329 1
		VOP_UNLOCK(vp);
d1339 1
a1339 1
		VOP_UNLOCK(vp);
d1346 1
a1346 1
		VOP_UNLOCK(vp);
d1356 1
a1356 1
	VOP_UNLOCK(vp);
@


1.18
log
@VFS Lite2 Changes
@
text
@d1329 1
a1329 1
		VOP_UNLOCK(vp, 0, p);
d1339 1
a1339 1
		VOP_UNLOCK(vp, 0, p);
d1346 1
a1346 1
		VOP_UNLOCK(vp, 0, p);
d1356 1
a1356 1
	VOP_UNLOCK(vp, 0, p);
@


1.17
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.16 1997/02/13 23:33:26 niklas Exp $	*/
d1329 1
a1329 1
		VOP_UNLOCK(vp);
d1339 1
a1339 1
		VOP_UNLOCK(vp);
d1346 1
a1346 1
		VOP_UNLOCK(vp);
d1356 1
a1356 1
	VOP_UNLOCK(vp);
@


1.16
log
@Remove statics to ease DDB debugging
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.15 1997/01/31 10:32:21 deraadt Exp $	*/
d663 3
a665 2
	if (DISKPART(bp->b_dev) != RAW_PART)
		if (bounds_check_with_label(bp, lp, wlabel) <= 0)
@


1.15
log
@off-by-one in partition indexing, netbsd pr#3161, kleink@@layla.inka.de
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.14 1997/01/31 10:31:43 deraadt Exp $	*/
d155 6
a160 6
static	void ccdstart __P((struct ccd_softc *, struct buf *));
static	void ccdinterleave __P((struct ccd_softc *, int));
static	void ccdintr __P((struct ccd_softc *, struct buf *));
static	int ccdinit __P((struct ccddevice *, char **, struct proc *));
static	int ccdlookup __P((char *, struct proc *p, struct vnode **));
static	void ccdbuffer __P((struct ccd_softc *, struct buf *,
d162 4
a165 4
static	void ccdgetdisklabel __P((dev_t));
static	void ccdmakedisklabel __P((struct ccd_softc *));
static	int ccdlock __P((struct ccd_softc *));
static	void ccdunlock __P((struct ccd_softc *));
d168 1
a168 1
static	void printiinfo __P((struct ccdiinfo *));
d208 1
a208 1
static int
d421 1
a421 1
static void
d680 1
a680 1
static void
d736 1
a736 1
static void
d862 1
a862 1
static void
d1306 1
a1306 1
static int
d1364 1
a1364 1
static void
d1421 1
a1421 1
static void
d1442 1
a1442 1
static int
d1460 1
a1460 1
static void
d1473 1
a1473 1
static void
@


1.14
log
@if error, b_resid = b_bcount
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.13 1996/12/19 18:26:58 deraadt Exp $	*/
d564 1
a564 1
		    ((part > lp->d_npartitions) ||
@


1.13
log
@netbsd fix to problem found by m4@@nts.umn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.12 1996/05/10 12:32:11 deraadt Exp $	*/
d647 1
@


1.12
log
@return an error
@
text
@d1 1
a1 1
/*	$OpenBSD: ccd.c,v 1.10 1996/04/21 22:19:44 deraadt Exp $	*/
d747 1
d767 3
a769 1
		for (ci = cs->sc_cinfo; cbn >= sblk + ci->ci_size; ci++)
d778 1
a778 1
		int ccdisk, off;
d832 2
a833 2
	cbp->cb_unit = cs - ccd_softc;
	cbp->cb_comp = ci - cs->sc_cinfo;
@


1.11
log
@no sys/cpu.h
@
text
@d2 1
a2 1
/*	$NetBSD: ccd.c,v 1.32 1996/04/22 01:26:39 christos Exp $	*/
d586 1
a586 1
	return (0);
@


1.10
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: ccd.c,v 1.9 1996/04/19 07:43:47 mickey Exp $	*/
/*	$NetBSD: ccd.c,v 1.31 1996/03/30 23:05:54 christos Exp $	*/
a110 1
#include <sys/cpu.h>
@


1.9
log
@Fix according to the last changes.
dev_conf.h deleted, longjmp proto changed.
@
text
@d1 2
a2 2
/*	$OpenBSD: ccd.c,v 1.7 1996/03/02 00:29:21 niklas Exp $	*/
/*	$NetBSD: ccd.c,v 1.29 1996/03/07 15:00:11 christos Exp $	*/
d112 1
d751 1
a751 1
		printf("ccdbuffer(%p, %p, %d, %p, %d)\n",
d838 1
a838 1
		printf(" dev %x(u%d): cbp %p bn %d addr %p bcnt %d\n",
d902 1
a902 1
			printf("ccdiodone: bp %p bcount %d resid %d\n",
d904 1
a904 1
		printf(" dev %x(u%d), cbp %p bn %d addr %p bcnt %d\n",
@


1.8
log
@NetBSD 960317 merge
@
text
@a112 1
#include <dev/dev_conf.h>
@


1.7
log
@From NetBSD: sync with 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ccd.c,v 1.28 1996/02/28 01:08:28 thorpej Exp $	*/
a102 1
#include <sys/conf.h>
d111 1
d113 1
a148 8
/* {b,c}devsw[] function prototypes */
dev_type_open(ccdopen);
dev_type_close(ccdclose);
dev_type_strategy(ccdstrategy);
dev_type_ioctl(ccdioctl);
dev_type_read(ccdread);
dev_type_write(ccdwrite);

d153 2
a154 1
void	ccdiodone __P((struct ccdbuf *cbp));
a184 2
	int i;

d216 1
a216 1
	register struct ccdcinfo *ci;
d257 3
a259 2
		if (error = copyinstr(cpaths[ix], tmppath,
		    MAXPATHLEN, &ci->ci_pathlen)) {
d274 1
a274 1
		if (error = VOP_GETATTR(vp, &va, p->p_ucred, p)) {
d290 3
a292 2
		if (error = VOP_IOCTL(vp, DIOCGPART, (caddr_t)&dpart,
		    FREAD, p->p_ucred, p)) {
a321 3
		if (size < 0)
			size = 0;

d435 1
a435 1
		printf("ccdinterleave(%x): ileave %d\n", cs, cs->sc_ileave);
d546 1
a546 1
	if (error = ccdlock(cs))
d610 1
a610 1
	if (error = ccdlock(cs))
d638 1
a638 2
	register daddr_t bn;
	register int sz, s;
d644 1
a644 1
		printf("ccdstrategy(%x): unit %d\n", bp, unit);
d693 1
a693 1
		printf("ccdstart(%x, %x)\n", cs, bp);
d745 1
a745 1
	register struct ccdcinfo *ci, *ci2;
d751 1
a751 1
		printf("ccdbuffer(%x, %x, %d, %x, %d)\n",
d813 1
a813 1
	cbp->cb_buf.b_iodone = (void (*)())ccdiodone;
d838 1
a838 1
		printf(" dev %x(u%d): cbp %x bn %d addr %x bcnt %d\n",
d867 1
a867 1
		printf("ccdintr(%x, %x)\n", cs, bp);
d884 2
a885 2
ccdiodone(cbp)
	struct ccdbuf *cbp;
d887 1
d897 1
a897 1
		printf("ccdiodone(%x)\n", cbp);
d902 1
a902 1
			printf("ccdiodone: bp %x bcount %d resid %d\n",
d904 1
a904 1
		printf(" dev %x(u%d), cbp %x bn %d addr %x bcnt %d\n",
d956 1
a956 1
		printf("ccdread(%x, %x)\n", dev, uio);
d985 1
a985 1
		printf("ccdwrite(%x, %x)\n", dev, uio);
d1033 1
a1033 1
		if (error = ccdlock(cs))
d1062 1
a1062 1
				printf("ccdioctl: component %d: 0x%x\n",
d1071 1
a1071 1
			if (error = ccdlookup(cpp[i], p, &vpp[i])) {
d1089 1
a1089 1
		if (error = ccdinit(&ccd, cpp, p)) {
d1129 1
a1129 1
		if (error = ccdlock(cs))
d1218 1
a1218 1
		if (error = ccdlock(cs))
d1315 1
a1315 1
	if (error = vn_open(&nd, FREAD|FWRITE, 0)) {
d1317 1
a1317 1
		if (ccddebug & CCDB_FOLLOW|CCDB_INIT)
d1330 1
a1330 1
	if (error = VOP_GETATTR(vp, &va, p->p_ucred, p)) {
d1332 1
a1332 1
		if (ccddebug & CCDB_FOLLOW|CCDB_INIT)
d1401 3
a1403 2
	if (errstring = readdisklabel(CCDLABELDEV(dev), ccdstrategy,
	    cs->sc_dkdev.dk_label, cs->sc_dkdev.dk_cpulabel))
@


1.6
log
@From NetBSD: update to 960217 sources
@
text
@d2 1
a2 1
/*	$NetBSD: ccd.c,v 1.27 1996/02/11 18:04:01 thorpej Exp $	*/
d4 2
a5 2
/*
 * Copyright (c) 1995, 1996 Jason R. Thorpe.
d8 3
d21 5
a25 4
 *	This product includes software developed for the NetBSD Project
 *	by Jason R. Thorpe.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d27 11
a37 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.5
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 2
a2 1
/*	$NetBSD: ccd.c,v 1.23 1996/01/07 22:03:28 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995 Jason R. Thorpe.
d87 3
a115 1
int ccddebug = 0x00;
d121 1
d131 3
d163 2
a164 2
static	struct ccdbuf *ccdbuffer __P((struct ccd_softc *, struct buf *,
		daddr_t, caddr_t, long));
d364 28
d399 5
a403 1
		cs->sc_size = cs->sc_nccdisks * minsize;
d568 7
a574 4
	if (part != RAW_PART && ((part > lp->d_npartitions) ||
	    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {
		error = ENXIO;
		goto done;
d692 1
a692 1
	struct ccdbuf *cbp;
d719 15
a733 5
		cbp = ccdbuffer(cs, bp, bn, addr, bcount);
		rcount = cbp->cb_buf.b_bcount;
		if ((cbp->cb_buf.b_flags & B_READ) == 0)
			cbp->cb_buf.b_vp->v_numoutput++;
		VOP_STRATEGY(&cbp->cb_buf);
d742 2
a743 2
static struct ccdbuf *
ccdbuffer(cs, bp, bn, addr, bcount)
d749 1
d751 1
a751 1
	register struct ccdcinfo *ci;
d795 13
a807 2
			ccdisk = ii->ii_index[off % ii->ii_ndisk];
			cbn = ii->ii_startoff + off / ii->ii_ndisk;
d817 1
d839 3
d848 15
a862 1
	return (cbp);
d896 2
a897 1
	int count, s;
d904 5
a908 2
		printf("ccdiodone: bp %x bcount %d resid %d\n",
		       bp, bp->b_bcount, bp->b_resid);
d917 11
a927 6
		bp->b_flags |= B_ERROR;
		bp->b_error = cbp->cb_buf.b_error ? cbp->cb_buf.b_error : EIO;
#ifdef DEBUG
		printf("%s: error %d on component %d\n",
		       cs->sc_xname, bp->b_error, cbp->cb_comp);
#endif
d930 1
d935 11
a945 6
	 */
	bp->b_resid -= count;
	if (bp->b_resid < 0)
		panic("ccdiodone: count");
	if (bp->b_resid == 0)
		ccdintr(&ccd_softc[unit], bp);
d1189 1
a1189 1
		disk_detatch(&cs->sc_dkdev);
@


1.4
log
@from netbsd:
Fix a race condition where if a process is asleep waiting on an
exclusive lock of a ccd device while another process is unconfiguring
that same device, the first process would never awaken (unless interrupted).
@
text
@d1 1
a1 1
/*	$NetBSD: ccd.c,v 1.22 1995/12/08 19:13:26 thorpej Exp $	*/
a91 1
#include <sys/dkstat.h>
a203 4

	/* XXX: is this necessary? */
	for (i = 0; i < numccd; ++i)
		ccddevs[i].ccd_dk = -1;
a229 3
#ifdef WORKING_DISK_STATISTICS		/* XXX !! */
	cs->sc_dk = ccd->ccd_dk;
#endif
d233 1
d258 2
a259 2
				printf("ccd%d: can't copy path, error = %d\n",
				    ccd->ccd_unit, error);
d273 2
a274 2
				printf("ccd%d: %s: getattr failed %s = %d\n",
				    ccd->ccd_unit, ci->ci_path,
d290 2
a291 2
				 printf("ccd%d: %s: ioctl failed, error = %d\n",
				     ccd->ccd_unit, ci->ci_path, error);
d305 2
a306 2
				printf("ccd%d: %s: incorrect partition type\n",
				    ccd->ccd_unit, ci->ci_path);
d326 2
a327 2
				printf("ccd%d: %s: size == 0\n",
				    ccd->ccd_unit, ci->ci_path);
d348 2
a349 2
			printf("ccd%d: interleave must be at least %d\n",
			    ccd->ccd_unit, (maxsecsize / DEV_BSIZE));
a380 5
#ifdef WORKING_DISK_STATISTICS		/* XXX !! */
	if (ccd->ccd_dk >= 0)
		dk_wpms[ccd->ccd_dk] = 32 * (60 * DEV_BSIZE / 2);     /* XXX */
#endif

d384 1
d515 1
a515 1
	lp = &cs->sc_dkdev.dk_label;
d620 1
a620 1
	lp = &cs->sc_dkdev.dk_label;
d660 2
a661 11
#ifdef WORKING_DISK_STATISTICS		/* XXX !! */
	/*
	 * Instrumentation (not very meaningful)
	 */
	cs->sc_nactive++;
	if (cs->sc_dk >= 0) {
		dk_busy |= 1 << cs->sc_dk;
		dk_xfer[cs->sc_dk]++;
		dk_wds[cs->sc_dk] += bp->b_bcount >> 6;
	}
#endif
d668 1
a668 1
		pp = &cs->sc_dkdev.dk_label.d_partitions[DISKPART(bp->b_dev)];
a795 10
#ifdef WORKING_DISK_STATISTICS		/* XXX !! */
	--cs->sc_nactive;
#ifdef DIAGNOSTIC
	if (cs->sc_nactive < 0)
		panic("ccdintr: ccd%d: sc_nactive < 0", cs->sc_unit);
#endif

	if (cs->sc_nactive == 0 && cs->sc_dk >= 0)
		dk_busy &= ~(1 << cs->sc_dk);
#endif
d798 1
d813 1
d834 2
a835 2
		printf("ccd%d: error %d on component %d\n",
		       unit, bp->b_error, cbp->cb_comp);
a925 3
#ifdef WORKING_DISK_STATISTICS		/* XXX !! */
	extern int dkn;
#endif
a993 13
#ifdef WORKING_DISK_STATISTICS		/* XXX !! */
		/*
		 * Assign disk index first so that init routine
		 * can use it (saves having the driver drag around
		 * the ccddevice pointer just to set up the dk_*
		 * info in the open routine).
		 */
		if (dkn < DK_NDRIVE)
			ccd.ccd_dk = dkn++;
		else
			ccd.ccd_dk = -1;
#endif

a997 4
#ifdef WORKING_DISK_STATISTICS		/* XXX !! */
			if (ccd.ccd_dk >= 0)
				--dkn;
#endif
d1010 4
a1013 1
		 * we can place it into the array and read the disklabel.
d1018 6
a1088 1
		ccd.ccd_dk = -1;
d1091 3
d1106 1
a1106 1
		*(struct disklabel *)data = cs->sc_dkdev.dk_label;
d1113 1
a1113 1
		((struct partinfo *)data)->disklab = &cs->sc_dkdev.dk_label;
d1115 1
a1115 1
		    &cs->sc_dkdev.dk_label.d_partitions[DISKPART(dev)];
d1131 2
a1132 2
		error = setdisklabel(&cs->sc_dkdev.dk_label,
		    (struct disklabel *)data, 0, &cs->sc_dkdev.dk_cpulabel);
d1136 2
a1137 2
				    ccdstrategy, &cs->sc_dkdev.dk_label,
				    &cs->sc_dkdev.dk_cpulabel);
d1183 1
a1183 1
	if (cs->sc_dkdev.dk_label.d_partitions[part].p_fstype != FS_SWAP)
d1186 1
a1186 1
		size = cs->sc_dkdev.dk_label.d_partitions[part].p_size;
d1276 2
a1277 2
	struct disklabel *lp = &cs->sc_dkdev.dk_label;
	struct cpu_disklabel *clp = &cs->sc_dkdev.dk_cpulabel;
d1304 1
a1304 1
	lp->d_checksum = dkcksum(&cs->sc_dkdev.dk_label);
d1310 1
a1310 1
	    &cs->sc_dkdev.dk_label, &cs->sc_dkdev.dk_cpulabel))
d1317 1
a1317 1
			printf("ccd%d: %s\n", unit, errstring);
d1329 1
a1329 1
	struct disklabel *lp = &cs->sc_dkdev.dk_label;
@


1.3
log
@unconfiguring of ccd causes system panic; fix from gdonl@@gv.ssi1.com; netbsd pr#1820
@
text
@d1 1
a1 1
/*	$NetBSD: ccd.c,v 1.18.2.2 1995/11/03 02:40:33 thorpej Exp $	*/
d948 1
a948 1
	int part, pmask;
d1096 2
d1113 2
d1117 2
d1121 1
a1121 1
		bzero(cs, sizeof(struct ccd_softc));
d1131 2
d1134 2
@


1.2
log
@In ccdstart(), only translate the block number from partition-relative
to absolute if part != RAW_PART.
@
text
@d1110 2
a1112 1
		}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ccd.c,v 1.18.2.1 1995/10/12 21:30:16 thorpej Exp $	*/
d664 1
d686 5
a690 2
	bn = (bp->b_blkno +
	    cs->sc_dkdev.dk_label.d_partitions[DISKPART(bp->b_dev)].p_offset);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

