head	1.11;
access;
symbols
	OPENBSD_5_7:1.9.0.28
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.26
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.24
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.20
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.18
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.16
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.14
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.14
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.12
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.10
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.8
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.05.11.06.46.21;	author ratchov;	state dead;
branches;
next	1.10;
commitid	RaOGL5SyOGOZylwx;

1.10
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.9;
commitid	p4LJxGKbi0BU2cG6;

1.9
date	2008.10.17.18.30.20;	author okan;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.23.19.54.36;	author jakemsr;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.17.08.35.33;	author jakemsr;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.27.00.23.43;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.06.02.34.57;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.31.04.14.00;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.01.01.49.48;	author aaron;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2000.07.20.21.44.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	97.10.07.14.07.45;	author niklas;	state Exp;
branches
	1.1.12.1;
next	;

1.1.12.1
date	2001.05.14.22.22.59;	author niklas;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2001.07.04.10.40.08;	author niklas;	state Exp;
branches;
next	1.1.12.3;

1.1.12.3
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.1.12.4;

1.1.12.4
date	2003.03.28.00.38.09;	author niklas;	state Exp;
branches;
next	1.1.12.5;

1.1.12.5
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.01.31.22.55.29;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@/*	$OpenBSD: auconv.c,v 1.10 2015/03/14 03:38:46 jsg Exp $ */
/*	$NetBSD: auconv.c,v 1.3 1999/11/01 18:12:19 augustss Exp $	*/

/*
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <dev/auconv.h>

void
change_sign8(void *v, u_char *p, int cc)
{
	while (--cc >= 0) {
		*p ^= 0x80;
		++p;
	}
}

void
change_sign16_le(void *v, u_char *p, int cc)
{
	while ((cc -= 2) >= 0) {
		p[1] ^= 0x80;
		p += 2;
	}
}

void
change_sign16_be(void *v, u_char *p, int cc)
{
	while ((cc -= 2) >= 0) {
		p[0] ^= 0x80;
		p += 2;
	}
}

void
swap_bytes(void *v, u_char *p, int cc)
{
	u_char t;

	while ((cc -= 2) >= 0) {
		t = p[0];
		p[0] = p[1];
		p[1] = t;
		p += 2;
	}
}

void
swap_bytes_change_sign16_le(void *v, u_char *p, int cc)
{
	u_char t;

	while ((cc -= 2) >= 0) {
		t = p[1];
		p[1] = p[0] ^ 0x80;
		p[0] = t;
		p += 2;
	}
}

void
swap_bytes_change_sign16_be(void *v, u_char *p, int cc)
{
	u_char t;

	while ((cc -= 2) >= 0) {
		t = p[0];
		p[0] = p[1] ^ 0x80;
		p[1] = t;
		p += 2;
	}
}

void
change_sign16_swap_bytes_le(void *v, u_char *p, int cc)
{
	swap_bytes_change_sign16_be(v, p, cc);
}

void
change_sign16_swap_bytes_be(void *v, u_char *p, int cc)
{
	swap_bytes_change_sign16_le(v, p, cc);
}

void
linear8_to_linear16_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[1] = *--p;
		q[0] = 0;
	}
}

void
linear8_to_linear16_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[0] = *--p;
		q[1] = 0;
	}
}

void
linear16_to_linear8_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 2) >= 0) {
		*q++ = p[1];
		p += 2;
	}
}

void
linear16_to_linear8_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 2) >= 0) {
		*q++ = p[0];
		p += 2;
	}
}

void
ulinear8_to_linear16_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[1] = (*--p) ^ 0x80;
		q[0] = 0;
	}
}

void
ulinear8_to_linear16_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[0] = (*--p) ^ 0x80;
		q[1] = 0;
	}
}

void
linear16_to_ulinear8_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 2) >= 0) {
		*q++ = p[1] ^ 0x80;
		p += 2;
	}
}

void
linear16_to_ulinear8_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 2) >= 0) {
		*q++ = p[0] ^ 0x80;
		p += 2;
	}
}

/*
 * just expand mono to stereo, no other conversions
 */
void
noswap_bytes_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[1] = q[3] = *--p;
		q[0] = q[2] = *--p;
	}
}

/*
 * same as swap_bytes(), plus expand mono to stereo
 */
void
swap_bytes_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[0] = q[2] = *--p;
		q[1] = q[3] = *--p;
	}
}

/*
 * same as linear8_to_linear16_le(), plus expand mono to stereo
 */
void
linear8_to_linear16_le_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[1] = q[3] = *--p;
		q[0] = q[2] = 0;
	}
}

/*
 * same as linear8_to_linear16_be(), plus expand mono to stereo
 */
void
linear8_to_linear16_be_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[0] = q[2] = *--p;
		q[1] = q[3] = 0;
	}
}

/*
 * same as ulinear8_to_linear16_le(), plus expand mono to stereo
 */
void
ulinear8_to_linear16_le_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[1] = q[3] = (*--p) ^ 0x80;
		q[0] = q[2] = 0;
	}
}

/*
 * same as ulinear8_to_linear16_be(), plus expand mono to stereo
 */
void
ulinear8_to_linear16_be_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[0] = q[2] = (*--p) ^ 0x80;
		q[1] = q[3] = 0;
	}
}

/*
 * same as change_sign16_le(), plus expand mono to stereo
 */
void
change_sign16_le_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[1] = q[3] = (*--p) ^ 0x80;
		q[0] = q[2] = *--p;
	}
}

/*
 * same as change_sign16_be(), plus expand mono to stereo
 */
void
change_sign16_be_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[0] = q[2] = (*--p) ^ 0x80;
		q[1] = q[3] = *--p;
	}
}

/*
 * same as swap_bytes_change_sign16_le(), plus expand mono to stereo
 */
void
swap_bytes_change_sign16_le_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[0] = q[2] = *--p;
		q[1] = q[3] = (*--p) ^ 0x80;
	}
}

/*
 * same as swap_bytes_change_sign16_be(), plus expand mono to stereo
 */
void
swap_bytes_change_sign16_be_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[0] = q[2] = (*--p) ^ 0x80;
		q[1] = q[3] = *--p;
	}
}

/*
 *  same as change_sign16_swap_bytes_le(), plus expand mono to stereo
 */
void
change_sign16_swap_bytes_le_mts(void *v, u_char *p, int cc)
{
	change_sign16_be_mts(v, p, cc);
}

/*
 * same as change_sign16_swap_bytes_be(), plus expand mono to stereo
 */
void
change_sign16_swap_bytes_be_mts(void *v, u_char *p, int cc)
{
	change_sign16_le_mts(v, p, cc);
}


void
linear16_decimator(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[0];
		*q++ = p[1];
		p += 4;
	}
}

void
linear16_to_linear8_le_stm(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[1];
		p += 4;
	}
}

void
linear16_to_linear8_be_stm(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[0];
		p += 4;
	}
}

void
linear16_to_ulinear8_le_stm(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[1] ^ 0x80;
		p += 4;
	}
}

void
linear16_to_ulinear8_be_stm(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[0] ^ 0x80;
		p += 4;
	}
}

void
change_sign16_le_stm(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[0];
		*q++ = p[1] ^ 0x80;
		p += 4;
	}
}

void
change_sign16_be_stm(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[0] ^ 0x80;
		*q++ = p[1];
		p += 4;
	}
}

void
swap_bytes_stm(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[1];
		*q++ = p[0];
		p += 4;
	}
}

void
swap_bytes_change_sign16_be_stm(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[1] ^ 0x80;
		*q++ = p[0];
		p += 4;
	}
}

void
change_sign16_swap_bytes_le_stm(void *v, u_char *p, int cc)
{
	swap_bytes_change_sign16_be_stm(v, p, cc);
}
@


1.10
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auconv.c,v 1.9 2008/10/17 18:30:20 okan Exp $ */
@


1.9
log
@Remove clauses 3 and 4 from NetBSD license.

from ray; ok ray, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: auconv.c,v 1.8 2007/10/23 19:54:36 jakemsr Exp $ */
a31 1
#include <sys/audioio.h>
@


1.8
log
@- add a couple more mono-to-stereo conversions
- add stereo-to-mono conversions for mono recording
  on stereo only devices
@
text
@d1 1
a1 1
/*	$OpenBSD: auconv.c,v 1.7 2007/07/17 08:35:33 jakemsr Exp $ */
a15 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
@


1.7
log
@when looping through an array and advancing your pointer to the array
2x on each loop, only loop .5x times

fixes hard hangs on i386 and "hiccups" on sgi when these functions are
used through e.g. dd if=/dev/audio of=foo, since mulaw is the default
encoding.

the commit history wrt this code is interesting.  I am responsible for
introducing this braindamage to OpenBSD ... and note that
linear16_to_linear8_[lb]e had it right ...
@
text
@d1 1
a1 1
/*	$OpenBSD: auconv.c,v 1.6 2003/06/27 00:23:43 jason Exp $ */
d238 1
a238 1
 * same as swap_bytes(), just expand mono to stereo
d357 34
d406 111
@


1.6
log
@ansify and add an alaw <-> mulaw conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: auconv.c,v 1.5 2002/05/06 02:34:57 nate Exp $ */
d203 1
a203 1
	while (--cc >= 0) {
d214 1
a214 1
	while (--cc >= 0) {
@


1.5
log
@new conversion functions from NetBSD for uaudio
@
text
@d1 1
a1 1
/*	$OpenBSD: auconv.c,v 1.4 2001/12/31 04:14:00 mickey Exp $ */
d43 1
a43 4
change_sign8(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d52 1
a52 4
change_sign16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d61 1
a61 4
change_sign16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d70 1
a70 4
swap_bytes(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d83 1
a83 4
swap_bytes_change_sign16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d96 1
a96 4
swap_bytes_change_sign16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d109 1
a109 4
change_sign16_swap_bytes_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d115 1
a115 4
change_sign16_swap_bytes_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d121 1
a121 4
linear8_to_linear16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d135 1
a135 4
linear8_to_linear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d149 1
a149 4
linear16_to_linear8_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d160 1
a160 4
linear16_to_linear8_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d171 1
a171 4
ulinear8_to_linear16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d185 1
a185 4
ulinear8_to_linear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d224 1
a224 4
noswap_bytes_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d241 1
a241 4
swap_bytes_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d258 1
a258 4
linear8_to_linear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d275 1
a275 4
linear8_to_linear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d292 1
a292 4
ulinear8_to_linear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d309 1
a309 4
ulinear8_to_linear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d326 1
a326 4
change_sign16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d343 1
a343 4
change_sign16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d360 1
a360 4
change_sign16_swap_bytes_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d369 1
a369 4
change_sign16_swap_bytes_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
@


1.4
log
@add a mono-to-stereo versions; from Kazuhiko Fukuhara <zaa83571@@oak.zero.ad.jp>
@
text
@d1 1
a1 1
/*	$OpenBSD: auconv.c,v 1.3 2001/05/01 01:49:48 aaron Exp $ */
d223 39
a338 17
	}
}

void
ulinear8_to_linear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[0] = (*--p) ^ 0x80;
		q[1] = 0;
@


1.3
log
@Add $OpenBSD$ tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d204 218
@


1.3.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: auconv.c,v 1.4 2001/12/31 04:14:00 mickey Exp $ */
a203 218
}

void
ulinear8_to_linear16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[1] = (*--p) ^ 0x80;
		q[0] = 0;
	}
}

/*
 * just expand mono to stereo, no other conversions
 */
void
noswap_bytes_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[1] = q[3] = *--p;
		q[0] = q[2] = *--p;
	}
}

/*
 * same as swap_bytes(), just expand mono to stereo
 */
void
swap_bytes_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[0] = q[2] = *--p;
		q[1] = q[3] = *--p;
	}
}

/*
 * same as linear8_to_linear16_le(), plus expand mono to stereo
 */
void
linear8_to_linear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[1] = q[3] = *--p;
		q[0] = q[2] = 0;
	}
}

/*
 * same as linear8_to_linear16_be(), plus expand mono to stereo
 */
void
linear8_to_linear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[0] = q[2] = *--p;
		q[1] = q[3] = 0;
	}
}

void
ulinear8_to_linear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[0] = (*--p) ^ 0x80;
		q[1] = 0;
	}
}

/*
 * same as ulinear8_to_linear16_le(), plus expand mono to stereo
 */
void
ulinear8_to_linear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[1] = q[3] = (*--p) ^ 0x80;
		q[0] = q[2] = 0;
	}
}

/*
 * same as ulinear8_to_linear16_be(), plus expand mono to stereo
 */
void
ulinear8_to_linear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[0] = q[2] = (*--p) ^ 0x80;
		q[1] = q[3] = 0;
	}
}

/*
 * same as change_sign16_le(), plus expand mono to stereo
 */
void
change_sign16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[1] = q[3] = (*--p) ^ 0x80;
		q[0] = q[2] = *--p;
	}
}

/*
 * same as change_sign16_be(), plus expand mono to stereo
 */
void
change_sign16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[0] = q[2] = (*--p) ^ 0x80;
		q[1] = q[3] = *--p;
	}
}

/*
 *  same as change_sign16_swap_bytes_le(), plus expand mono to stereo
 */
void
change_sign16_swap_bytes_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	change_sign16_be_mts(v, p, cc);
}

/*
 * same as change_sign16_swap_bytes_be(), plus expand mono to stereo
 */
void
change_sign16_swap_bytes_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	change_sign16_le_mts(v, p, cc);
@


1.3.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: auconv.c,v 1.3.4.1 2002/01/31 22:55:29 niklas Exp $ */
a222 39
void
ulinear8_to_linear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[0] = (*--p) ^ 0x80;
		q[1] = 0;
	}
}

void
linear16_to_ulinear8_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while (--cc >= 0) {
		*q++ = p[1] ^ 0x80;
		p += 2;
	}
}

void
linear16_to_ulinear8_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while (--cc >= 0) {
		*q++ = p[0] ^ 0x80;
		p += 2;
	}
}

d300 17
@


1.2
log
@extend with new netbsd api, and add backwards compat hacks for drivers
@
text
@d1 1
@


1.1
log
@From NetBSD: Simple conversions of audio streams, for use with the newer
MI audio subsystem (actually one of two :-) ) coming after 2.2
@
text
@d1 1
a1 2
/*	$OpenBSD: auconv.c,v 1.2 1997/08/24 22:20:24 augustss Exp $	*/
/*	$NetBSD: auconv.c,v 1.2 1997/08/24 22:20:24 augustss Exp $	*/
a38 1
#include <machine/endian.h>
a40 8
#if BYTE_ORDER == LITTLE_ENDIAN
#define LO 0
#define HI 1
#else
#define LO 1
#define HI 0
#endif

d54 13
a66 1
change_sign16(v, p, cc)
d72 1
a72 1
		p[HI] ^= 0x80;
d94 1
a94 1
swap_bytes_change_sign16(v, p, cc)
d102 3
a104 3
		t = p[HI];
		p[HI] = p[LO] ^ 0x80;
		p[LO] = t;
d110 1
a110 1
change_sign16_swap_bytes(v, p, cc)
d118 3
a120 3
		t = p[LO];
		p[LO] = p[HI] ^ 0x80;
		p[HI] = t;
d126 19
a144 1
linear8_to_linear16(v, p, cc)
d155 33
a187 2
		q[HI] = *--p;
		q[LO] = 0;
d192 1
a192 1
linear16_to_linear8(v, p, cc)
d200 1
a200 1
		*q++ = p[HI];
@


1.1.12.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 1
/*	$NetBSD: auconv.c,v 1.3 1999/11/01 18:12:19 augustss Exp $	*/
d40 1
d43 8
d64 1
a64 13
change_sign16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	while ((cc -= 2) >= 0) {
		p[1] ^= 0x80;
		p += 2;
	}
}

void
change_sign16_be(v, p, cc)
d70 1
a70 1
		p[0] ^= 0x80;
d92 1
a92 1
swap_bytes_change_sign16_le(v, p, cc)
d100 3
a102 3
		t = p[1];
		p[1] = p[0] ^ 0x80;
		p[0] = t;
d108 1
a108 1
swap_bytes_change_sign16_be(v, p, cc)
d116 3
a118 3
		t = p[0];
		p[0] = p[1] ^ 0x80;
		p[1] = t;
d124 1
a124 19
change_sign16_swap_bytes_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	swap_bytes_change_sign16_be(v, p, cc);
}

void
change_sign16_swap_bytes_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	swap_bytes_change_sign16_le(v, p, cc);
}

void
linear8_to_linear16_le(v, p, cc)
d135 2
a136 33
		q[1] = *--p;
		q[0] = 0;
	}
}

void
linear8_to_linear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[0] = *--p;
		q[1] = 0;
	}
}

void
linear16_to_linear8_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	while ((cc -= 2) >= 0) {
		*q++ = p[1];
		p += 2;
d141 1
a141 1
linear16_to_linear8_be(v, p, cc)
d149 1
a149 1
		*q++ = p[0];
@


1.1.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@a0 1
/*	$OpenBSD$ */
@


1.1.12.3
log
@Merge in trunk
@
text
@a204 218

void
ulinear8_to_linear16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[1] = (*--p) ^ 0x80;
		q[0] = 0;
	}
}

/*
 * just expand mono to stereo, no other conversions
 */
void
noswap_bytes_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[1] = q[3] = *--p;
		q[0] = q[2] = *--p;
	}
}

/*
 * same as swap_bytes(), just expand mono to stereo
 */
void
swap_bytes_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[0] = q[2] = *--p;
		q[1] = q[3] = *--p;
	}
}

/*
 * same as linear8_to_linear16_le(), plus expand mono to stereo
 */
void
linear8_to_linear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[1] = q[3] = *--p;
		q[0] = q[2] = 0;
	}
}

/*
 * same as linear8_to_linear16_be(), plus expand mono to stereo
 */
void
linear8_to_linear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[0] = q[2] = *--p;
		q[1] = q[3] = 0;
	}
}

void
ulinear8_to_linear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[0] = (*--p) ^ 0x80;
		q[1] = 0;
	}
}

/*
 * same as ulinear8_to_linear16_le(), plus expand mono to stereo
 */
void
ulinear8_to_linear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[1] = q[3] = (*--p) ^ 0x80;
		q[0] = q[2] = 0;
	}
}

/*
 * same as ulinear8_to_linear16_be(), plus expand mono to stereo
 */
void
ulinear8_to_linear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[0] = q[2] = (*--p) ^ 0x80;
		q[1] = q[3] = 0;
	}
}

/*
 * same as change_sign16_le(), plus expand mono to stereo
 */
void
change_sign16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[1] = q[3] = (*--p) ^ 0x80;
		q[0] = q[2] = *--p;
	}
}

/*
 * same as change_sign16_be(), plus expand mono to stereo
 */
void
change_sign16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[0] = q[2] = (*--p) ^ 0x80;
		q[1] = q[3] = *--p;
	}
}

/*
 *  same as change_sign16_swap_bytes_le(), plus expand mono to stereo
 */
void
change_sign16_swap_bytes_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	change_sign16_be_mts(v, p, cc);
}

/*
 * same as change_sign16_swap_bytes_be(), plus expand mono to stereo
 */
void
change_sign16_swap_bytes_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	change_sign16_le_mts(v, p, cc);
}
@


1.1.12.4
log
@Sync the SMP branch with 3.3
@
text
@a222 39
void
ulinear8_to_linear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while (--cc >= 0) {
		q -= 2;
		q[0] = (*--p) ^ 0x80;
		q[1] = 0;
	}
}

void
linear16_to_ulinear8_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while (--cc >= 0) {
		*q++ = p[1] ^ 0x80;
		p += 2;
	}
}

void
linear16_to_ulinear8_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while (--cc >= 0) {
		*q++ = p[0] ^ 0x80;
		p += 2;
	}
}

d300 17
@


1.1.12.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d43 4
a46 1
change_sign8(void *v, u_char *p, int cc)
d55 4
a58 1
change_sign16_le(void *v, u_char *p, int cc)
d67 4
a70 1
change_sign16_be(void *v, u_char *p, int cc)
d79 4
a82 1
swap_bytes(void *v, u_char *p, int cc)
d95 4
a98 1
swap_bytes_change_sign16_le(void *v, u_char *p, int cc)
d111 4
a114 1
swap_bytes_change_sign16_be(void *v, u_char *p, int cc)
d127 4
a130 1
change_sign16_swap_bytes_le(void *v, u_char *p, int cc)
d136 4
a139 1
change_sign16_swap_bytes_be(void *v, u_char *p, int cc)
d145 4
a148 1
linear8_to_linear16_le(void *v, u_char *p, int cc)
d162 4
a165 1
linear8_to_linear16_be(void *v, u_char *p, int cc)
d179 4
a182 1
linear16_to_linear8_le(void *v, u_char *p, int cc)
d193 4
a196 1
linear16_to_linear8_be(void *v, u_char *p, int cc)
d207 4
a210 1
ulinear8_to_linear16_le(void *v, u_char *p, int cc)
d224 4
a227 1
ulinear8_to_linear16_be(void *v, u_char *p, int cc)
d266 4
a269 1
noswap_bytes_mts(void *v, u_char *p, int cc)
d286 4
a289 1
swap_bytes_mts(void *v, u_char *p, int cc)
d306 4
a309 1
linear8_to_linear16_le_mts(void *v, u_char *p, int cc)
d326 4
a329 1
linear8_to_linear16_be_mts(void *v, u_char *p, int cc)
d346 4
a349 1
ulinear8_to_linear16_le_mts(void *v, u_char *p, int cc)
d366 4
a369 1
ulinear8_to_linear16_be_mts(void *v, u_char *p, int cc)
d386 4
a389 1
change_sign16_le_mts(void *v, u_char *p, int cc)
d406 4
a409 1
change_sign16_be_mts(void *v, u_char *p, int cc)
d426 4
a429 1
change_sign16_swap_bytes_le_mts(void *v, u_char *p, int cc)
d438 4
a441 1
change_sign16_swap_bytes_be_mts(void *v, u_char *p, int cc)
@


