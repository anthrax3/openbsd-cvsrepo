head	1.16;
access;
symbols
	OPENBSD_5_4:1.13.0.12
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.11.0.6
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.24
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.22
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.20
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.18
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.16
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.14
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.12
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.10
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.10
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.8.0.8
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.6
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2013.11.28.00.38.50;	author dlg;	state dead;
branches;
next	1.15;

1.15
date	2013.11.04.11.57.26;	author mpi;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.30.02.13.53;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.21.20.08.11;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.12.02.01.17;	author jakemsr;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.16.19.45.09;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.03.22.11.05.31;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.26.16.20.04;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.24.13.44.18;	author ho;	state Exp;
branches
	1.8.8.1;
next	1.7;

1.7
date	2000.04.13.00.00.08;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	98.11.03.21.00.11;	author downsj;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	98.04.26.21.03.09;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.07.10.23.06.30;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	96.03.02.00.29.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.09.43.17;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches;
next	;

1.6.6.1
date	2001.05.14.22.23.00;	author niklas;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2003.03.28.00.38.09;	author niklas;	state Exp;
branches;
next	;

1.8.8.1
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@the stuff in audiovar.h is only used in audio.c, so move it in there to
take the temptation of using it elsewhere and fumbling with audio internals
away from the rest of the kernel.

ok mpi@@ ratchov@@
"if it is worth doing, just do it." deraadt@@
@
text
@/*	$OpenBSD: audiovar.h,v 1.15 2013/11/04 11:57:26 mpi Exp $	*/
/*	$NetBSD: audiovar.h,v 1.18 1998/03/03 09:16:16 augustss Exp $	*/

/*
 * Copyright (c) 1991-1993 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	From: Header: audiovar.h,v 1.3 93/07/18 14:07:25 mccanne Exp  (LBL)
 */

/*
 * Initial/default block duration is both configurable and patchable.
 */
#ifndef AUDIO_BLK_MS
#define AUDIO_BLK_MS	50	/* 50 ms */
#endif

#ifndef AU_RING_SIZE
#define AU_RING_SIZE		65536
#endif

#define AUMINBUF 512
#define AUMINBLK 32
#define AUMINNOBLK 2
struct audio_ringbuffer {
	int	bufsize;	/* allocated memory */
	int	blksize;	/* I/O block size */
	int	maxblks;	/* no of blocks in ring */
	u_char	*start;		/* start of buffer area */
	u_char	*end;		/* end of buffer area */
	u_char	*inp;		/* input pointer (to buffer) */
	u_char	*outp;		/* output pointer (from buffer) */
	int	used;		/* no of used bytes */
	int	usedlow;	/* start writer when used falls below this */
	int	usedhigh;	/* stop writer when used goes above this */
	u_long	stamp;		/* bytes transferred */
	u_long	stamp_last;	/* old value of bytes transferred */
	u_long	drops;		/* missed samples from over/underrun */
	u_long	pdrops;		/* paused samples */
	char	pause;		/* transfer is paused */
	char	mmapped;	/* device is mmap()-ed */
	u_char	blkset;		/* blksize has been set, for stickiness */
};

#define AUDIO_N_PORTS 4

struct au_mixer_ports {
	int	index;
	int	master;
	int	nports;
	u_char	isenum;
	u_int	allports;
	u_int	aumask[AUDIO_N_PORTS];
	u_int	misel [AUDIO_N_PORTS];
	u_int	miport[AUDIO_N_PORTS];
};

/*
 * Software state, per audio device.
 */
struct audio_softc {
	struct	device dev;
	void	*hw_hdl;	/* Hardware driver handle */
	struct	audio_hw_if *hw_if; /* Hardware interface */
	struct	device *sc_dev;	/* Hardware device struct */
	u_char	sc_open;	/* single use device */
#define AUOPEN_READ	0x01
#define AUOPEN_WRITE	0x02
	u_char	sc_mode;	/* bitmask for RECORD/PLAY */

	struct	selinfo sc_wsel; /* write selector */
	struct	selinfo sc_rsel; /* read selector */
	struct	proc *sc_async_audio;	/* process who wants audio SIGIO */
	struct	mixer_asyncs {
		struct mixer_asyncs *next;
		struct proc *proc;
	} *sc_async_mixer;  /* processes who want mixer SIGIO */

	/* Sleep channels for reading and writing. */
	int	sc_rchan;
	int	sc_wchan;

	/* Ring buffers, separate for record and play. */
	struct	audio_ringbuffer sc_rr; /* Record ring */
	struct	audio_ringbuffer sc_pr; /* Play ring */

	u_char	*sc_sil_start;	/* start of silence in buffer */
	int	sc_sil_count;	/* # of silence bytes */

	u_char	sc_rbus;	/* input dma in progress */
	u_char	sc_pbus;	/* output dma in progress */

	u_char	sc_rqui;	/* input dma quiesced */
	u_char	sc_pqui;	/* output dma quiesced */

	struct	audio_params sc_pparams;	/* play encoding parameters */
	struct	audio_params sc_rparams;	/* record encoding parameters */

	int	sc_eof;		/* EOF, i.e. zero sized write, counter */
	u_long	sc_wstamp;
	u_long	sc_playdrop;

	int	sc_full_duplex;	/* device in full duplex mode */

	struct	au_mixer_ports sc_inports, sc_outports;
	int	sc_monitor_port;

	int     sc_refcnt;
	int     sc_dying;

	int	sc_quiesce;
#define	AUDIO_QUIESCE_START	1
#define	AUDIO_QUIESCE_SILENT	2
	struct timeout sc_resume_to;
	struct task sc_resume_task;
	struct task sc_mixer_task;
	u_char	sc_mute;

#ifdef AUDIO_INTR_TIME
	u_long	sc_pfirstintr;	/* first time we saw a play interrupt */
	int	sc_pnintr;	/* number of interrupts */
	u_long	sc_plastintr;	/* last time we saw a play interrupt */
	long	sc_pblktime;	/* nominal time between interrupts */
	u_long	sc_rfirstintr;	/* first time we saw a rec interrupt */
	int	sc_rnintr;	/* number of interrupts */
	u_long	sc_rlastintr;	/* last time we saw a rec interrupt */
	long	sc_rblktime;	/* nominal time between interrupts */
#endif
};
@


1.15
log
@Convert wskbd_set_mixervolume() to use a task internally instead of
being called in a workq.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.14 2013/10/30 02:13:53 dlg Exp $	*/
@


1.14
log
@replace workqs with tasks.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.13 2010/09/21 20:08:11 jakemsr Exp $	*/
d144 1
@


1.13
log
@change quiescing to not call the audio_hw_if halt method in interrupt
context, because drivers (like eso(4) and envy(4)) might want to sleep
in their halt method.
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.12 2010/09/12 02:01:17 jakemsr Exp $	*/
d143 1
a143 1
	struct workq_task sc_resume_task;
@


1.12
log
@DVACT_{QUIESCE,RESUME} for audio(4)
DVACT_QUIESCE:
1) waits until ringbuffer current position wraps back to the start of
the buffer
2) stops playback and/or recording by way of the hardware drivers' "halt"
audio_hw_if method
3) blocks userland access to audio device
4) saves the current state of the master mute, then mutes it
DVACT_RESUME:
1) reprogram hardware stream parameters for playback or recording
if they were active at DVACT_QUIESCE by way of hardware drivers'
"set_params" audio_hw_if method
2) start playback or recording if they were active at DVACT_QUIESCE
by way of hardware drivers' "trigger" or "start" audio_hw_if method
3) restores master mute state as it was at DVACT_QUIESCE
4) wakes up blocked userland processes accessing the hardware
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.11 2009/03/16 19:45:09 ratchov Exp $	*/
d120 3
@


1.11
log
@first stage of removing ``copying & needfeel'' flags that
make the audio driver missing blocks and, thus, breaking
full-duplex apps.
help and ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.10 2008/03/22 11:05:31 ratchov Exp $	*/
d135 7
@


1.10
log
@add audio(4) driver the ability to use different block sizes for play and
record modes. This makes possible to have blocks of the same duration if the
play and record formats are different. The API change is backward
compatible, so it shouldn't be noticed by current audio ports.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.9 2002/08/26 16:20:04 mickey Exp $	*/
a68 2
	char	copying;	/* data is being copied */
	char	needfill;	/* buffer needs filling when copying is done */
@


1.9
log
@space cleanup; some from grendel@@zeitbombe.org
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.8 2000/05/24 13:44:18 ho Exp $	*/
d72 1
a115 2

	u_char	sc_blkset;	/* Blocksize has been set */
@


1.8
log
@Permit detach of audio devices, such as uaudio. Selected code
from NetBSD/Lennart Augustsson. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.7 2000/04/13 00:00:08 csapuntz Exp $	*/
d136 2
a137 2
        int     sc_refcnt;
        int     sc_dying;
@


1.8.8.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.8 2000/05/24 13:44:18 ho Exp $	*/
d136 2
a137 2
	int     sc_refcnt;
	int     sc_dying;
@


1.7
log
@

Move min # of blocks to two to accomodate hackis neomagic driver
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.6 1998/11/03 21:00:11 downsj Exp $	*/
d135 3
@


1.6
log
@Partial sync with NetBSD, adds new trigger methods.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
#define AUMINNOBLK 3
@


1.6.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: audiovar.h,v 1.8 2000/05/24 13:44:18 ho Exp $	*/
d52 1
a52 1
#define AUMINNOBLK 2
a134 3

        int     sc_refcnt;
        int     sc_dying;
@


1.6.6.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d136 2
a137 2
	int     sc_refcnt;
	int     sc_dying;
@


1.5
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 2
a2 2
/*	$OpenBSD: audiovar.h,v 1.16 1997/08/19 23:49:58 augustss Exp $	*/
/*	$NetBSD: audiovar.h,v 1.17 1997/10/19 07:42:01 augustss Exp $	*/
d127 1
a127 1
	int	sc_eof;		/* EOF, i.e. zero sixed write, counter */
d137 1
a137 1
	u_long	sc_pfirstintr;	/* first time we saw a xmit interrupt */
d139 1
a139 1
	u_long	sc_plastintr;	/* last time we saw a xmit interrupt */
d143 1
a143 1
	u_long	sc_rlastintr;	/* last time we saw a xrec interrupt */
@


1.4
log
@sync with NETBSD 30/3/97 + adapating aria.c
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: audiovar.h,v 1.7 1996/02/20 10:00:33 mycroft Exp $	*/
d43 1
a43 1
#define AUDIO_BLK_MS	20	/* 20 ms */
d46 2
a47 2
#ifndef AUDIO_BACKLOG
#define AUDIO_BACKLOG	3	/* 60 ms */
d50 23
a72 9
/*
 * Use a single page as the size of the audio ring buffers, so that
 * the data won't cross a page boundary.  This way the dma carried out
 * in the hardware module will be efficient (i.e., at_dma() won't have
 * to make a copy).
 */
#ifndef AU_RING_SIZE
#define AU_RING_SIZE		NBPG
#endif
d74 1
a74 22
#define AU_RING_MOD(k)		((k) & (AU_RING_SIZE - 1))
#define AU_RING_EMPTY(rp) 	((rp)->hp == (rp)->tp)
#define AU_RING_FULL(rp)	(AU_RING_MOD((rp)->tp + 1) == (rp)->hp)
#define AU_RING_LEN(rp)		(AU_RING_MOD((rp)->tp - (rp)->hp))
#define AU_RING_INIT(rp)	{					  \
					 (rp)->nblk = (rp)->au_stamp = 0; \
					 (rp)->hp = (rp)->tp = (rp)->bp;  \
				}

struct audio_buffer {
	u_char	*hp;		/* head */
	u_char	*tp;		/* tail */
	u_char	*bp;		/* start of buffer */
	u_char	*ep;		/* end of buffer */
	
	int	nblk;		/* number of active blocks in buffer */
	int	maxblk;		/* max # of active blocks in buffer */
	u_long	au_stamp;	/* number of audio samples read/written */

	u_short	cb_pause;	/* io paused */
	u_long	cb_drops;	/* missed samples from over/underrun */
	u_long	cb_pdrops;	/* paused samples */
d76 9
a84 2
	int	fill;		/* number of silence pad bytes */
	u_char	*otp;		/* point where silence padding started */
d91 2
a92 1
	void	*hw_hdl;		/* Hardware driver handle */
d94 1
d102 5
a106 1
	struct	proc *sc_async;	/* process who wants SIGIO */
d113 7
a119 2
	struct	audio_buffer rr; /* Record ring */
	struct	audio_buffer pr; /* Play ring */
a120 2
	u_char	*auzero_block;	/* a block of silence */
	
d124 2
a125 2
	u_long	sc_wseek;	/* timestamp of last frame written */
	u_long	sc_rseek;	/* timestamp of last frame read */
d127 19
a145 11
	int	sc_blksize;	/* recv block (chunk) size in bytes */
	int	sc_smpl_in_blk;	/* # samples in a block  */
	int	sc_50ms;	/* # of samples for 50ms? */
	int	sc_backlog;	/* # blks of xmit backlog to generate */
	int	sc_lowat;	/* xmit low water mark (for wakeup) */
	int	sc_hiwat;	/* xmit high water mark (for wakeup) */

	int	sc_rblks;	/* number of phantom record blocks */
	int	sc_wblks;	/* number of output silence blocks */
	int	sc_pencoding;	/* current encoding; play */
	int	sc_rencoding;	/* current encoding; record */
@


1.3
log
@From NetBSD: sync with 960217 sources
@
text
@d82 3
d109 2
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d2 1
a2 1
/*	$NetBSD: audiovar.h,v 1.5 1996/02/16 02:25:44 mycroft Exp $	*/
d97 1
d121 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: audiovar.h,v 1.3 1995/05/08 22:01:44 brezak Exp $	*/
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
