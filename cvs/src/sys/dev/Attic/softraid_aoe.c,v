head	1.38;
access;
symbols
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.25.0.4
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.38
date	2014.10.07.20.23.32;	author tedu;	state dead;
branches;
next	1.37;
commitid	1hbxZJRSxjvGk5Dm;

1.37
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.36;
commitid	OBNa5kfxQ2UXoiIw;

1.36
date	2014.01.21.04.23.14;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2013.11.21.16.34.50;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2013.09.20.08.08.45;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2013.03.31.15.44.52;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.31.11.37.40;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.02.12.50.01;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.16.06.42.22;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.15.09.28.29;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.15.04.03.01;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2012.10.08.14.22.41;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.26.14.54.52;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.25.15.28.17;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.07.00.18.06;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.04.04.49.05;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.04.03.53.22;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.04.03.24.51;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.04.03.22.07;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.05.19.52.02;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.02.15.49.25;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.01.19.31.04;	author thib;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.29.18.43.54;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.06.17.26.44;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.15.13.19.37;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.07.14.27.12;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.26.23.06.49;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.09.14.12.25;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.24.14.13.28;	author blambert;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.03.17.39.26;	author ckuethe;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.02.21.23.11;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.11.14.06.21;	author jsing;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.04.20.36.23;	author thib;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.24.19.32.02;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.25.23.05.17;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.23.23.44.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.38
log
@remove preliminary AOE (ata over ethernet) support. not finished after
many years and wide spread demand for support never materialized.
time to pack it in.
@
text
@/* $OpenBSD: softraid_aoe.c,v 1.37 2014/07/12 18:48:51 tedu Exp $ */
/*
 * Copyright (c) 2008 Ted Unangst <tedu@@openbsd.org>
 * Copyright (c) 2008 Marco Peereboom <marco@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/disk.h>
#include <sys/rwlock.h>
#include <sys/queue.h>
#include <sys/fcntl.h>
#include <sys/disklabel.h>
#include <sys/mount.h>
#include <sys/sensors.h>
#include <sys/stat.h>
#include <sys/conf.h>
#include <sys/uio.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_disk.h>

#include <dev/softraidvar.h>
#include <dev/rndvar.h>

#include <sys/socket.h>
#include <sys/mbuf.h>
#include <sys/socketvar.h>
#include <net/if.h>
#include <netinet/in.h>
#include <net/ethertypes.h>
#include <netinet/if_ether.h>
#include <net/if_aoe.h>

/* AOE initiator functions. */
int	sr_aoe_create(struct sr_discipline *, struct bioc_createraid *,
	    int, int64_t);
int	sr_aoe_assemble(struct sr_discipline *, struct bioc_createraid *,
	    int, void *);
int	sr_aoe_alloc_resources(struct sr_discipline *);
void	sr_aoe_free_resources(struct sr_discipline *);
int	sr_aoe_rw(struct sr_workunit *);

/* AOE target functions. */
int	sr_aoe_server_create(struct sr_discipline *, struct bioc_createraid *,
	    int, int64_t);
int	sr_aoe_server_assemble(struct sr_discipline *, struct bioc_createraid *,
	    int, void *);
int	sr_aoe_server_alloc_resources(struct sr_discipline *);
void	sr_aoe_server_free_resources(struct sr_discipline *);
int	sr_aoe_server_start(struct sr_discipline *);

void	sr_aoe_request_done(struct aoe_req *, struct aoe_packet *);
void	sr_aoe_input(struct aoe_handler *, struct mbuf *);
void	sr_aoe_setup(struct aoe_handler *, struct mbuf *);
void	sr_aoe_timeout(void *);

/* Discipline initialisation. */
void
sr_aoe_discipline_init(struct sr_discipline *sd)
{

	/* Fill out discipline members. */
	sd->sd_type = SR_MD_AOE_INIT;
	strlcpy(sd->sd_name, "AOE INIT", sizeof(sd->sd_name));
	sd->sd_capabilities = SR_CAP_SYSTEM_DISK;
	sd->sd_max_wu = SR_RAIDAOE_NOWU;

	/* Setup discipline specific function pointers. */
	sd->sd_alloc_resources = sr_aoe_alloc_resources;
	sd->sd_assemble = sr_aoe_assemble;
	sd->sd_create = sr_aoe_create;
	sd->sd_free_resources = sr_aoe_free_resources;
	sd->sd_scsi_rw = sr_aoe_rw;
	sd->sd_scsi_intr = NULL;
}

void
sr_aoe_server_discipline_init(struct sr_discipline *sd)
{

	/* Fill out discipline members. */
	sd->sd_type = SR_MD_AOE_TARG;
	strlcpy(sd->sd_name, "AOE TARG", sizeof(sd->sd_name));
	sd->sd_capabilities = 0;
	sd->sd_max_wu = SR_RAIDAOE_NOWU;

	/* Setup discipline specific function pointers. */
	sd->sd_alloc_resources = sr_aoe_server_alloc_resources;
	sd->sd_assemble = sr_aoe_server_assemble;
	sd->sd_create = sr_aoe_server_create;
	sd->sd_free_resources = sr_aoe_server_free_resources;
	sd->sd_scsi_inquiry = NULL;
	sd->sd_scsi_read_cap = NULL;
	sd->sd_scsi_tur = NULL;
	sd->sd_scsi_req_sense = NULL;
	sd->sd_scsi_start_stop = NULL;
	sd->sd_scsi_sync = NULL;
	sd->sd_scsi_rw = NULL;
	sd->sd_scsi_intr = NULL;
	sd->sd_set_chunk_state = NULL;
	sd->sd_set_vol_state = NULL;
	sd->sd_start_discipline = sr_aoe_server_start;
}

/* AOE initiator */
int
sr_aoe_create(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, int64_t coerced_size)
{
	if (no_chunk != 1) {
		sr_error(sd->sd_sc, "%s requires exactly one chunk",
		    sd->sd_name);
		return EINVAL;
	}

	sd->sd_max_ccb_per_wu = no_chunk;

	return 0;
}

int
sr_aoe_assemble(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, void *data)
{
	struct ifnet		*ifp;
	struct aoe_handler	*ah;
	struct sr_aoe_config	sri;
	int			rv, s;
#if 0
	struct mbuf *m;
	struct ether_header *eh;
	struct aoe_packet *ap;
	int rv;
#endif

	if (!(bc->bc_opaque_flags & BIOC_SOIN))
		return (EINVAL);
	if (bc->bc_opaque_size != sizeof(sri))
		return (EINVAL);
	if ((rv = copyin(bc->bc_opaque, &sri, sizeof(sri))))
	    return (rv);
	sri.nic[sizeof(sri.nic) - 1] = 0;

	sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;

	ifp = ifunit(sri.nic);
	if (!ifp)
		return (EINVAL);

	ah = malloc(sizeof(*ah), M_DEVBUF, M_WAITOK | M_ZERO);
	ah->ifp = ifp;
	ah->major = sri.shelf;
	ah->minor = sri.slot;
	ah->fn = (workq_fn)sr_aoe_input;
	TAILQ_INIT(&ah->reqs);

	s = splnet();
	TAILQ_INSERT_TAIL(&aoe_handlers, ah, next);
	splx(s);

	sd->mds.mdd_aoe.sra_ah = ah;
	sd->mds.mdd_aoe.sra_eaddr = sri.dsteaddr;

#if 0
	MGETHDR(m, M_WAIT, MT_HEADER);
	eh = mtod(m, struct ether_header *);
	memcpy(eh->ether_dhost, sd->mds.mdd_aoe.sra_eaddr, 6);
	memcpy(eh->ether_shost, ((struct arpcom *)ifp)->ac_enaddr, 6);
	eh->ether_type = htons(ETHERTYPE_AOE);
	ap = (struct aoe_packet *)&eh[1];
	ap->vers = 1;
	ap->flags = 0;
	ap->error = 0;
	ap->major = sri.shelf;
	ap->minor = sri.slot;
	ap->command = 1;
	ap->tag = 0;
	ap->buffercnt = 0;
	ap->firmwarevers = 0;
	ap->configsectorcnt = 0;
	ap->serververs = 0;
	ap->ccmd = 0;
	ap->configstringlen = 0;
	m->m_pkthdr.len = m->m_len = AOE_CFGHDRLEN;
	s = splnet();
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, rv);
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
	rv = tsleep(ah, PRIBIO|PCATCH, "aoesetup", 30 * hz);
	splx(s);
	if (rv) {
		s = splnet();
		TAILQ_REMOVE(&aoe_handlers, ah, next);
		splx(s);
		free(ah, M_DEVBUF, 0);
		return rv;
	}
#endif
	return 0;
}

void
sr_aoe_setup(struct aoe_handler *ah, struct mbuf *m)
{
	struct aoe_packet	*ap;
	int			s;

	ap = mtod(m, struct aoe_packet *);
	if (ap->command != 1)
		goto out;
	if (ap->tag != 0)
		goto out;
	s = splnet();
	ah->fn = (workq_fn)sr_aoe_input;
	wakeup(ah);
	splx(s);

out:
	m_freem(m);
}

int
sr_aoe_alloc_resources(struct sr_discipline *sd)
{
	DNPRINTF(SR_D_DIS, "%s: sr_aoe_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	sr_wu_alloc(sd, sizeof(struct sr_workunit));
	sr_ccb_alloc(sd);

	return 0;
}

void
sr_aoe_free_resources(struct sr_discipline *sd)
{
	struct aoe_handler	*ah;
	int			s;

	DNPRINTF(SR_D_DIS, "%s: sr_aoe_free_resources\n",
	    DEVNAME(sd->sd_sc));

	ah = sd->mds.mdd_aoe.sra_ah;
	if (ah) {
		s = splnet();
		TAILQ_REMOVE(&aoe_handlers, ah, next);
		splx(s);
		free(ah, M_DEVBUF, 0);
	}

	if (sd->sd_meta)
		free(sd->sd_meta, M_DEVBUF, 0);

	sr_wu_free(sd);
	sr_ccb_free(sd);
}

int sr_send_aoe_chunk(struct sr_workunit *wu, daddr_t blk, int i);
int
sr_send_aoe_chunk(struct sr_workunit *wu, daddr_t blk, int i)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	int			s;
	daddr_t			fragblk;
	struct mbuf		*m;
	struct ether_header	*eh;
	struct aoe_packet	*ap;
	struct ifnet		*ifp;
	struct aoe_handler	*ah;
	struct aoe_req		*ar;
	int			tag, rv;
	int			fragsize;
	const int		aoe_frags = 2;

	fragblk = blk + aoe_frags * i;
	fragsize = aoe_frags * 512;
	if (fragblk + aoe_frags - 1 > wu->swu_blk_end) {
		fragsize = (wu->swu_blk_end - fragblk + 1) * 512;
	}
	tag = ++sd->mds.mdd_aoe.sra_tag;
	ah = sd->mds.mdd_aoe.sra_ah;
	ar = malloc(sizeof(*ar), M_DEVBUF, M_NOWAIT);
	if (!ar) {
		splx(s);
		return ENOMEM;
	}
	ar->v = wu;
	ar->tag = tag;
	ar->len = fragsize;
	timeout_set(&ar->to, sr_aoe_timeout, ar);
	TAILQ_INSERT_TAIL(&ah->reqs, ar, next);
	splx(s);

	ifp = ah->ifp;
	MGETHDR(m, M_DONTWAIT, MT_HEADER);
	if (xs->flags & SCSI_DATA_OUT && m) {
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m);
			m = NULL;
		}
	}
	if (!m) {
		s = splbio();
		TAILQ_REMOVE(&ah->reqs, ar, next);
		splx(s);
		free(ar, M_DEVBUF, 0);
		return ENOMEM;
	}

	eh = mtod(m, struct ether_header *);
	memcpy(eh->ether_dhost, &sd->mds.mdd_aoe.sra_eaddr, ETHER_ADDR_LEN);
	memcpy(eh->ether_shost, ((struct arpcom *)ifp)->ac_enaddr,
	    ETHER_ADDR_LEN);
	eh->ether_type = htons(ETHERTYPE_AOE);
	ap = (struct aoe_packet *)&eh[1];
	ap->vers = 1;
	ap->flags = 0;
	ap->error = 0;
	ap->major = ah->major;
	ap->minor = ah->minor;
	ap->command = 0;
	ap->tag = tag;
	ap->aflags = 0; /* AOE_EXTENDED; */
	if (xs->flags & SCSI_DATA_OUT) {
		ap->aflags |= AOE_WRITE;
		ap->cmd = AOE_WRITE;
		memcpy(ap->data, xs->data + (aoe_frags * i * 512), fragsize);
	} else {
		ap->cmd = AOE_READ;
	}
	ap->feature = 0;
	ap->sectorcnt = fragsize / 512;
	AOE_BLK2HDR(fragblk, ap);

	m->m_pkthdr.len = m->m_len = AOE_CMDHDRLEN + fragsize;
	s = splnet();
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, rv);
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
	if (rv == 0)
		timeout_add_sec(&ar->to, 10);
	splx(s);

	if (rv) {
		s = splbio();
		TAILQ_REMOVE(&ah->reqs, ar, next);
		splx(s);
		free(ar, M_DEVBUF, 0);
	}

	return rv;
}

int
sr_aoe_rw(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_chunk		*scp;
	daddr_t			blk;
	int			s, ios, rt;
	int			rv, i;
	const int		aoe_frags = 2;


	DNPRINTF(SR_D_DIS, "%s: sr_aoe_rw 0x%02x\n", DEVNAME(sd->sd_sc),
	    xs->cmd->opcode);

	/* blk and scsi error will be handled by sr_validate_io */
	if (sr_validate_io(wu, &blk, "sr_aoe_rw"))
		goto bad;

	/* add 1 to get the inclusive amount, then some more for rounding */
	ios = (wu->swu_blk_end - wu->swu_blk_start + 1 + (aoe_frags - 1)) /
	    aoe_frags;
	wu->swu_io_count = ios;

	if (xs->flags & SCSI_POLL)
		panic("can't AOE poll");

	s = splbio();
	for (i = 0; i < ios; i++) {
		if (xs->flags & SCSI_DATA_IN) {
			rt = 0;
ragain:
			scp = sd->sd_vol.sv_chunks[0];
			switch (scp->src_meta.scm_status) {
			case BIOC_SDONLINE:
			case BIOC_SDSCRUB:
				break;

			case BIOC_SDOFFLINE:
			case BIOC_SDREBUILD:
			case BIOC_SDHOTSPARE:
				if (rt++ < sd->sd_meta->ssdi.ssd_chunk_no)
					goto ragain;

				/* FALLTHROUGH */
			default:
				/* volume offline */
				printf("%s: is offline, can't read\n",
				DEVNAME(sd->sd_sc));
				goto bad;
			}
		} else {
			scp = sd->sd_vol.sv_chunks[0];
			switch (scp->src_meta.scm_status) {
			case BIOC_SDONLINE:
			case BIOC_SDSCRUB:
			case BIOC_SDREBUILD:
				break;

			case BIOC_SDHOTSPARE: /* should never happen */
			case BIOC_SDOFFLINE:
				wu->swu_io_count--;
				goto bad;

			default:
				goto bad;
			}
		}

		rv = sr_send_aoe_chunk(wu, blk, i);

		if (rv) {
			return rv;
		}
	}

	return (0);
bad:
	/* wu is unwound by sr_wu_put */
	return (1);
}

void
sr_aoe_request_done(struct aoe_req *ar, struct aoe_packet *ap)
{
	struct sr_discipline	*sd;
	struct scsi_xfer	*xs;
	struct sr_workunit	*wu;
	daddr_t			blk;
	int64_t			offset;
	int			len, s;

	wu = ar->v;
	sd = wu->swu_dis;
	xs = wu->swu_xs;

	if (!ap || ap->flags & AOE_F_ERROR) {
		wu->swu_ios_failed++;
	} else {
		wu->swu_ios_succeeded++;
		len = ar->len; /* XXX check against sector count */
		if (xs->flags & SCSI_DATA_IN) {
			AOE_HDR2BLK(ap, blk);
			/* XXX bounds checking */
			offset = (wu->swu_blk_start - blk) * 512;
			memcpy(xs->data + offset, ap->data, len);
		}
	}

	wu->swu_ios_complete++;

	s = splbio();
	if (wu->swu_ios_complete == wu->swu_io_count) {
		if (wu->swu_ios_failed == wu->swu_ios_complete)
			xs->error = XS_DRIVER_STUFFUP;
		else
			xs->error = XS_NOERROR;

		sr_scsi_done(sd, xs);
	}
	splx(s);

	free(ar, M_DEVBUF, 0);
}

void
sr_aoe_input(struct aoe_handler *ah, struct mbuf *m)
{
	struct aoe_packet	*ap;
	struct aoe_req		*ar;
	int			tag;
	int			s;

	ap = mtod(m, struct aoe_packet *);
	tag = ap->tag;

	s = splnet();
	TAILQ_FOREACH(ar, &ah->reqs, next) {
		if (ar->tag == tag) {
			timeout_del(&ar->to);
			TAILQ_REMOVE(&ah->reqs, ar, next);
			break;
		}
	}
	splx(s);
	if (!ar)
		goto out;

	ap = mtod(m, struct aoe_packet *);
	sr_aoe_request_done(ar, ap);
out:
	m_freem(m);
}

void
sr_aoe_timeout(void *v)
{
	struct aoe_req		*ar = v;
	struct sr_discipline	*sd;
	struct scsi_xfer	*xs;
	struct aoe_handler	*ah;
	struct sr_workunit	*wu;
	int			s;

	wu = ar->v;
	sd = wu->swu_dis;
	xs = wu->swu_xs;
	ah = sd->mds.mdd_aoe.sra_ah;

	s = splnet();
	TAILQ_REMOVE(&ah->reqs, ar, next);
	splx(s);

	sr_aoe_request_done(ar, NULL);
}

/* AOE target */
void		sr_aoe_server(struct aoe_handler *, struct mbuf *);
void		sr_aoe_server_create_thread(void *);
void		sr_aoe_server_thread(void *);

int
sr_aoe_server_create(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, int64_t coerced_size)
{
	if (no_chunk != 1) {
		sr_error(sd->sd_sc, "%s requires exactly one chunk",
		    sd->sd_name);
		return EINVAL;
	}

	sd->sd_meta->ssdi.ssd_size = coerced_size;

	strlcpy(sd->sd_name, "AOE TARG", sizeof(sd->sd_name));

	sd->sd_max_ccb_per_wu = no_chunk;

	return 0;
}

int
sr_aoe_server_assemble(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, void *data)
{

	sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;

	return 0;
}

int
sr_aoe_server_alloc_resources(struct sr_discipline *sd)
{
	int			s, rv = EINVAL;
	unsigned char		slot;
	unsigned short		shelf;
	const char		*nic;
	struct aoe_handler	*ah;
	struct ifnet		*ifp;

	DNPRINTF(SR_D_DIS, "%s: sr_aoe_server_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	/* setup runtime values */
	/* XXX where do these come from */
	slot = 3;
	shelf = 4;
	nic = "re0";

	ifp = ifunit(nic);
	if (!ifp) {
		printf("%s: sr_aoe_server_alloc_resources: illegal interface "
		    "%s\n", DEVNAME(sd->sd_sc), nic);
		return (EINVAL);
	}
	shelf = htons(shelf);

	ah = malloc(sizeof(*ah), M_DEVBUF, M_WAITOK | M_ZERO);
	ah->ifp = ifp;
	ah->major = shelf;
	ah->minor = slot;
	ah->fn = (workq_fn)sr_aoe_server;
	TAILQ_INIT(&ah->reqs);

	s = splnet();
	TAILQ_INSERT_TAIL(&aoe_handlers, ah, next);
	splx(s);

	sd->mds.mdd_aoe.sra_ah = ah;
	memset(&sd->mds.mdd_aoe.sra_eaddr, 0xff,
	    sizeof(sd->mds.mdd_aoe.sra_eaddr));
	sd->mds.mdd_aoe.sra_ifp = ifp;

	if (sr_wu_alloc(sd))
		goto bad;
	if (sr_ccb_alloc(sd))
		goto bad;

	rv = 0;
bad:
	return (rv);
}

void
sr_aoe_server_free_resources(struct sr_discipline *sd)
{
	int			s;

	DNPRINTF(SR_D_DIS, "%s: sr_aoe_server_free_resources\n",
	    DEVNAME(sd->sd_sc));

	s = splnet();
	if (sd->mds.mdd_aoe.sra_ah) {
		TAILQ_REMOVE(&aoe_handlers, sd->mds.mdd_aoe.sra_ah, next);
		free(sd->mds.mdd_aoe.sra_ah, M_DEVBUF, 0);
	}
	splx(s);

	sr_wu_free(sd);
	sr_ccb_free(sd);
}

int
sr_aoe_server_start(struct sr_discipline *sd)
{
	kthread_create_deferred(sr_aoe_server_create_thread, sd);

	return (0);
}

void
sr_aoe_server_create_thread(void *arg)
{
	struct sr_discipline	*sd = arg;

	if (kthread_create(sr_aoe_server_thread, arg, NULL, DEVNAME(sd->sd_sc))
	    != 0) {
		printf("%s: unable to create AOE thread\n",
		    DEVNAME(sd->sd_sc));
		/* XXX unwind */
		return;
	}
}

void
sr_aoe_server_thread(void *arg)
{
	struct sr_discipline	*sd = arg;
	struct ifnet		*ifp;
	struct aoe_handler	*ah;
	struct aoe_req		*ar;
	struct aoe_packet	*rp, *ap;
	struct mbuf		*m, *m2;
	struct ether_header	*eh;
	struct buf		buf;
	daddr_t			blk;
	int			len;
	int			rv, s;

	/* sanity */
	if (!sd)
		return;
	ah = sd->mds.mdd_aoe.sra_ah;
	if (ah == NULL)
		return;
	ifp = sd->mds.mdd_aoe.sra_ifp;
	if (ifp == NULL)
		return;

	printf("%s: AOE target: %s exported via: %s\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, ifp->if_xname);

	while (1) {
		s = splnet();
resleep:
		rv = tsleep(ah, PCATCH | PRIBIO, "aoe targ", 0);
		if (rv) {
			splx(s);
			break;
		}
		ar = TAILQ_FIRST(&ah->reqs);
		if (!ar) {
			goto resleep;
		}
		TAILQ_REMOVE(&ah->reqs, ar, next);
		splx(s);
		m2 = ar->v;
		rp = mtod(m2, struct aoe_packet *);
		if (rp->command) {
			continue;
		}
		if (rp->aflags & AOE_AF_WRITE) {
			MGETHDR(m, M_DONTWAIT, MT_HEADER);
			if (!m)
				continue;
			len = rp->sectorcnt * 512;

			eh = mtod(m, struct ether_header *);
			memcpy(eh->ether_dhost, &sd->mds.mdd_aoe.sra_eaddr,
			    ETHER_ADDR_LEN);
			memcpy(eh->ether_shost,
			    ((struct arpcom *)ifp)->ac_enaddr, ETHER_ADDR_LEN);
			eh->ether_type = htons(ETHERTYPE_AOE);
			ap = (struct aoe_packet *)&eh[1];
			AOE_HDR2BLK(ap, blk);
			bzero(&buf, sizeof(buf));
			buf.b_blkno = blk;
			buf.b_flags = B_WRITE | B_PHYS;
			buf.b_bcount = len;
			buf.b_bufsize = len;
			buf.b_resid = len;
			buf.b_data = rp->data;
			buf.b_error = 0;
			buf.b_proc = curproc;
			buf.b_dev = sd->sd_vol.sv_chunks[0]->src_dev_mm;
			buf.b_vp = sd->sd_vol.sv_chunks[0]->src_vn;
			if ((buf.b_flags & B_READ) == 0)
				buf.b_vp->v_numoutput++;
			LIST_INIT(&buf.b_dep);

			s = splbio();
			VOP_STRATEGY(&buf);
			biowait(&buf);
			splx(s);

			ap->vers = 1;
			ap->flags = AOE_F_RESP;
			ap->error = 0;
			ap->major = rp->major;
			ap->minor = rp->minor;
			ap->command = 1;
			ap->tag = rp->tag;
			ap->aflags = rp->aflags;
			ap->feature = 0;
			ap->sectorcnt = len / 512;
			ap->cmd = AOE_WRITE;
			ap->lba0 = 0;
			ap->lba1 = 0;
			ap->lba2 = 0;
			ap->lba3 = 0;
			ap->lba4 = 0;
			ap->lba5 = 0;
			ap->reserved = 0;

			m->m_pkthdr.len = m->m_len = AOE_CMDHDRLEN;

			s = splnet();
			IFQ_ENQUEUE(&ifp->if_snd, m, NULL, rv);
			if ((ifp->if_flags & IFF_OACTIVE) == 0)
				(*ifp->if_start)(ifp);
			splx(s);
		} else {
			MGETHDR(m, M_DONTWAIT, MT_HEADER);
			if (m) {
				MCLGET(m, M_DONTWAIT);
				if (!(m->m_flags & M_EXT)) {
					m_freem(m);
					m = NULL;
				}
			}
			if (!m)
				continue;
			len = rp->sectorcnt * 512;

			eh = mtod(m, struct ether_header *);
			memcpy(eh->ether_dhost, &sd->mds.mdd_aoe.sra_eaddr,
			    ETHER_ADDR_LEN);
			memcpy(eh->ether_shost,
			    ((struct arpcom *)ifp)->ac_enaddr, ETHER_ADDR_LEN);
			eh->ether_type = htons(ETHERTYPE_AOE);
			ap = (struct aoe_packet *)&eh[1];
			AOE_HDR2BLK(ap, blk);
			memset(&buf, 0, sizeof buf);
			buf.b_blkno = blk;
			buf.b_flags = B_WRITE | B_PHYS;
			buf.b_bcount = len;
			buf.b_bufsize = len;
			buf.b_resid = len;
			buf.b_data = ap->data;
			buf.b_error = 0;
			buf.b_proc = curproc;
			buf.b_dev = sd->sd_vol.sv_chunks[0]->src_dev_mm;
			buf.b_vp = sd->sd_vol.sv_chunks[0]->src_vn;
			if ((buf.b_flags & B_READ) == 0)
				buf.b_vp->v_numoutput++;
			LIST_INIT(&buf.b_dep);

			s = splbio();
			VOP_STRATEGY(&buf);
			biowait(&buf);
			splx(s);

			ap->vers = 1;
			ap->flags = AOE_F_RESP;
			ap->error = 0;
			ap->major = rp->major;
			ap->minor = rp->minor;
			ap->command = 1;
			ap->tag = rp->tag;
			ap->aflags = rp->aflags;
			ap->feature = 0;
			ap->sectorcnt = len / 512;
			ap->cmd = AOE_READ;
			ap->lba0 = 0;
			ap->lba1 = 0;
			ap->lba2 = 0;
			ap->lba3 = 0;
			ap->lba4 = 0;
			ap->lba5 = 0;
			ap->reserved = 0;
			m->m_pkthdr.len = m->m_len = AOE_CMDHDRLEN;

			s = splnet();
			IFQ_ENQUEUE(&ifp->if_snd, m, NULL, rv);
			if ((ifp->if_flags & IFF_OACTIVE) == 0)
				(*ifp->if_start)(ifp);
			splx(s);
		}
	}
}

void
sr_aoe_server(struct aoe_handler *ah, struct mbuf *m)
{
	struct aoe_req		*ar;
	int			s;

	ar = malloc(sizeof *ar, M_DEVBUF, M_NOWAIT);
	if (!ar) {
		/* XXX warning? */
		m_freem(m);
		return;
	}
	ar->v = m;
	s = splnet();
	TAILQ_INSERT_TAIL(&ah->reqs, ar, next);
	wakeup(ah);
	splx(s);
}
@


1.37
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.36 2014/01/21 04:23:14 jsing Exp $ */
@


1.36
log
@Allow for variable sized work units.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.35 2013/11/21 16:34:50 krw Exp $ */
d218 1
a218 1
		free(ah, M_DEVBUF);
d271 1
a271 1
		free(ah, M_DEVBUF);
d275 1
a275 1
		free(sd->sd_meta, M_DEVBUF);
d331 1
a331 1
		free(ar, M_DEVBUF);
d373 1
a373 1
		free(ar, M_DEVBUF);
d501 1
a501 1
	free(ar, M_DEVBUF);
d653 1
a653 1
		free(sd->mds.mdd_aoe.sra_ah, M_DEVBUF);
@


1.35
log
@Change a bunch of daddr_t variables that don't (obviously) contain
512-byte-block information to int64_t, the underlying type of
daddr_t at the moment. No change to .o files. Removal of now
unneeded (long long) casts is next.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.34 2013/09/20 08:08:45 tedu Exp $ */
d251 1
a251 1
	sr_wu_alloc(sd);
@


1.34
log
@remove debug code. not sure how this lasted so long.
noticed by maxime villard
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.33 2013/06/11 16:42:13 deraadt Exp $ */
d467 2
a468 1
	daddr_t			blk, offset;
@


1.33
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.32 2013/03/31 15:44:52 jsing Exp $ */
a389 4

	printf("%s: sr_aoe_rw 0x%02x\n", DEVNAME(sd->sd_sc),
	    xs->cmd->opcode);
	return (1);
@


1.32
log
@Use consistent error handling when validating the number of chunks
provided.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.31 2013/03/31 11:37:40 jsing Exp $ */
d281 1
a281 1
int sr_send_aoe_chunk(struct sr_workunit *wu, daddr64_t blk, int i);
d283 1
a283 1
sr_send_aoe_chunk(struct sr_workunit *wu, daddr64_t blk, int i)
d288 1
a288 1
	daddr64_t		fragblk;
d385 1
a385 1
	daddr64_t		blk;
d471 1
a471 1
	daddr64_t		blk, offset;
d697 1
a697 1
	daddr64_t		blk;
@


1.31
log
@The return value of sd_free_resources() is never checked and all of the
implementations only ever returned zero. Change the return value from
int to void instead of pretending it might mean something.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.30 2013/03/02 12:50:01 jsing Exp $ */
d133 3
a135 2

	if (no_chunk != 1)
d137 1
d567 3
a569 2

	if (no_chunk != 1)
d571 1
@


1.30
log
@sr_alloc_resources() and sr_free_resources() can never be called without
a valid struct sr_discipline. Remove redundant NULL pointer checks.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.29 2013/01/16 06:42:22 jsing Exp $ */
d63 1
a63 1
int	sr_aoe_free_resources(struct sr_discipline *);
d72 1
a72 1
int	sr_aoe_server_free_resources(struct sr_discipline *);
d255 1
a255 1
int
a257 1
	int			s, rv = EINVAL;
d259 1
a263 3
	sr_wu_free(sd);
	sr_ccb_free(sd);

d275 2
a276 2
	rv = 0;
	return (rv);
d641 1
a641 1
int
a648 3
	sr_wu_free(sd);
	sr_ccb_free(sd);

d656 2
a657 1
	return (0);
@


1.29
log
@Set resid to zero if the scsi transfer completed without error.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.28 2013/01/15 09:28:29 jsing Exp $ */
a245 3
	if (!sd)
		return (EINVAL);

a260 3
	if (!sd)
		return (rv);

a600 3
	if (!sd)
		return (rv);

a647 3

	if (!sd)
		return (EINVAL);
@


1.28
log
@Always initialise the discipline name, not just when we are doing a create.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.27 2013/01/15 04:03:01 jsing Exp $ */
a505 2

		xs->resid = 0;
@


1.27
log
@Keep a function pointer to the per-discipline I/O interrupt handler in the
discipline data structure. To be used with an upcoming diff.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.26 2012/10/08 14:22:41 jsing Exp $ */
d87 1
d106 1
a135 2

	strlcpy(sd->sd_name, "AOE INIT", sizeof(sd->sd_name));
@


1.26
log
@Provide a mechanism for the kernel to pass data through to the discipline
during volume assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.24 2011/12/25 15:28:17 jsing Exp $ */
d96 1
d120 1
@


1.25
log
@Provide default set chunk state and set volume state functions which
cover the no redundancy/no rebuild case. Use these for the AOE, crypto and
RAID 0 disciplines.
@
text
@d61 1
a61 1
	    int);
d70 1
a70 1
	    int);
d142 1
a142 1
    int no_chunk)
d589 1
a589 1
    int no_chunk)
@


1.24
log
@Initialise discipline function pointers with defaults and only override
those that are needed by a specific discipline.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.22 2011/07/04 04:49:05 tedu Exp $ */
a95 3
	/* XXX reuse raid 1 functions for now FIXME */
	sd->sd_set_chunk_state = sr_raid1_set_chunk_state;
	sd->sd_set_vol_state = sr_raid1_set_vol_state;
d107 3
a109 1
	/* Setup discipline pointers. */
a110 2
	sd->sd_assemble = sr_aoe_server_assemble;
	sd->sd_alloc_resources = sr_aoe_server_alloc_resources;
a111 1
	sd->sd_start_discipline = sr_aoe_server_start;
d121 1
@


1.23
log
@allow AOE config to be specified by userland.  ok marco.
use consistent network types as requested and ok deraadt.
@
text
@d90 3
a92 1
	/* Setup discipline pointers. */
a93 2
	sd->sd_assemble = sr_aoe_assemble;
	sd->sd_alloc_resources = sr_aoe_alloc_resources;
a94 7
	sd->sd_start_discipline = NULL;
	sd->sd_scsi_inquiry = sr_raid_inquiry;
	sd->sd_scsi_read_cap = sr_raid_read_cap;
	sd->sd_scsi_tur = sr_raid_tur;
	sd->sd_scsi_req_sense = sr_raid_request_sense;
	sd->sd_scsi_start_stop = sr_raid_start_stop;
	sd->sd_scsi_sync = sr_raid_sync;
@


1.22
log
@assemble is a more appropriate place for the setup code than allocate.
not that it works any better.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.21 2011/07/04 03:53:22 tedu Exp $ */
d156 2
a157 5
	unsigned char		slot;
	unsigned short		shelf;
	const char		*nic;
	const char	 	*dsteaddr;
	int			s;
d165 7
d175 1
a175 7
	/* where do these come from */
	slot = 3;
	shelf = 4;
	nic = "ne0";
	dsteaddr = dsteaddr;

	ifp = ifunit(nic);
a177 1
	shelf = htons(shelf);
d181 2
a182 2
	ah->major = shelf;
	ah->minor = slot;
d191 1
a191 1
	memcpy(sd->mds.mdd_aoe.sra_eaddr, dsteaddr, 6);
d203 2
a204 2
	ap->major = shelf;
	ap->minor = slot;
d351 3
a353 2
	memcpy(eh->ether_dhost, sd->mds.mdd_aoe.sra_eaddr, 6);
	memcpy(eh->ether_shost, ((struct arpcom *)ifp)->ac_enaddr, 6);
d649 2
a650 6
	sd->mds.mdd_aoe.sra_eaddr[0] = 0xff;
	sd->mds.mdd_aoe.sra_eaddr[1] = 0xff;
	sd->mds.mdd_aoe.sra_eaddr[2] = 0xff;
	sd->mds.mdd_aoe.sra_eaddr[3] = 0xff;
	sd->mds.mdd_aoe.sra_eaddr[4] = 0xff;
	sd->mds.mdd_aoe.sra_eaddr[5] = 0xff;
d763 2
a764 1
			memcpy(eh->ether_dhost, sd->mds.mdd_aoe.sra_eaddr, 6);
d766 1
a766 1
			    ((struct arpcom *)ifp)->ac_enaddr, 6);
d830 2
a831 1
			memcpy(eh->ether_dhost, sd->mds.mdd_aoe.sra_eaddr, 6);
d833 1
a833 1
			    ((struct arpcom *)ifp)->ac_enaddr, 6);
@


1.21
log
@redo the timeout and input handling.  unify them and fix some bugs.
we no longer retry commands, somebody else can worry about that.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.20 2011/07/04 03:24:51 tedu Exp $ */
a153 29

	sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;

	return 0;
}

void
sr_aoe_setup(struct aoe_handler *ah, struct mbuf *m)
{
	struct aoe_packet	*ap;
	int			s;

	ap = mtod(m, struct aoe_packet *);
	if (ap->command != 1)
		goto out;
	if (ap->tag != 0)
		goto out;
	s = splnet();
	ah->fn = (workq_fn)sr_aoe_input;
	wakeup(ah);
	splx(s);

out:
	m_freem(m);
}

int
sr_aoe_alloc_resources(struct sr_discipline *sd)
{
d159 2
a166 1
	int s;
a167 2
	if (!sd)
		return (EINVAL);
d169 1
a169 5
	DNPRINTF(SR_D_DIS, "%s: sr_aoe_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	sr_wu_alloc(sd);
	sr_ccb_alloc(sd);
d175 1
d178 1
a178 1
	if (!ifp) {
a179 1
	}
d194 1
a194 6
	sd->mds.mdd_aoe.sra_eaddr[0] = 0xff;
	sd->mds.mdd_aoe.sra_eaddr[1] = 0xff;
	sd->mds.mdd_aoe.sra_eaddr[2] = 0xff;
	sd->mds.mdd_aoe.sra_eaddr[3] = 0xff;
	sd->mds.mdd_aoe.sra_eaddr[4] = 0xff;
	sd->mds.mdd_aoe.sra_eaddr[5] = 0xff;
d231 35
@


1.20
log
@make it look like other softraid code
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.19 2011/07/04 03:22:07 tedu Exp $ */
d75 1
d487 1
a487 1
sr_aoe_input(struct aoe_handler *ah, struct mbuf *m)
a490 2
	struct aoe_req		*ar;
	struct aoe_packet	*ap;
a493 4
	int			tag;

	ap = mtod(m, struct aoe_packet *);
	tag = ap->tag;
a494 12
	s = splnet();
	TAILQ_FOREACH(ar, &ah->reqs, next) {
		if (ar->tag == tag) {
			TAILQ_REMOVE(&ah->reqs, ar, next);
			break;
		}
	}
	splx(s);
	if (!ar) {
		goto out;
	}
	timeout_del(&ar->to);
d499 1
a499 2

	if (ap->flags & AOE_F_ERROR) {
a500 1
		goto out;
a514 1

d525 4
d530 25
a565 1
	struct aoe_req		*ar2;
d575 1
a575 6
	TAILQ_FOREACH(ar2, &ah->reqs, next) {
		if (ar2->tag == ar->tag) {
			TAILQ_REMOVE(&ah->reqs, ar, next);
			break;
		}
	}
d577 2
a578 6
	if (!ar2)
		return;
	free(ar, M_DEVBUF);
	/* give it another go */
	/* XXX this is going to repeat the whole workunit */
	sr_aoe_rw(wu);
@


1.19
log
@whack the collider stuff for now
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.18 2011/04/05 19:52:02 krw Exp $ */
d162 2
a163 2
	struct aoe_packet *ap;
	int s;
d182 5
a186 5
	struct ifnet *ifp;
	struct aoe_handler *ah;
	unsigned char slot;
	unsigned short shelf;
	const char *nic;
d490 6
a495 6
	struct aoe_req *ar;
	struct aoe_packet *ap;
	struct sr_workunit *wu;
	daddr64_t blk, offset;
	int len, s;
	int tag;
d553 1
a553 1
	struct aoe_req *ar = v;
d556 4
a559 4
	struct aoe_handler *ah;
	struct aoe_req *ar2;
	struct sr_workunit *wu;
	int s;
d723 1
a723 8
	struct mbuf *m, *m2;
	struct ether_header *eh;
	struct aoe_packet *rp, *ap;
	struct aoe_req *ar;
	int len;
	struct buf buf;
	daddr64_t blk;

d726 7
a733 1
	struct sr_discipline	*sd = arg;
@


1.18
log
@Iopoolification. Testing by marco@@.

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.17 2010/07/02 15:49:25 krw Exp $ */
a403 1
	struct sr_workunit	*wup;
a429 1
	/* walk queue backwards and fill in collider if we have one */
a430 18
	if (0) /* XXX */ TAILQ_FOREACH_REVERSE(wup, &sd->sd_wu_pendq, sr_wu_list, swu_link) {
		if (wu->swu_blk_end < wup->swu_blk_start ||
		    wup->swu_blk_end < wu->swu_blk_start)
			continue;

		/* we have an LBA collision, defer wu */
		wu->swu_state = SR_WU_DEFERRED;
		if (wup->swu_collider)
			/* wu is on deferred queue, append to last wu */
			while (wup->swu_collider)
				wup = wup->swu_collider;

		wup->swu_collider = wu;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu, swu_link);
		sd->sd_wu_collisions++;
		splx(s);
		return (0);
	}
d492 1
a492 1
	struct sr_workunit *wu, *wup;
a542 16
		if (0) /* XXX */ TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link) {
			if (wu == wup) {
				/* wu on pendq, remove */
				TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);

				if (wu->swu_collider) {
					/* restart deferred wu */
					wu->swu_collider->swu_state =
					    SR_WU_INPROGRESS;
					TAILQ_REMOVE(&sd->sd_wu_defq,
					    wu->swu_collider, swu_link);
					/* sr_raid_startwu(wu->swu_collider); */
				}
				break;
			}
		}
@


1.17
log
@Don't timeout_add() when the referenced struct is about to be
discarded. It will eventually fire. Fortunately this file not
yet being used.

ok tedu@@.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.16 2010/07/01 19:31:04 thib Exp $ */
a578 3

		/* do not change the order of these 2 functions */
		sr_wu_put(wu);
@


1.16
log
@make sure that buf's on the stack set the b_bq to NULL.
one memset -> bzero.

ok marco@@, jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.15 2010/06/29 18:43:54 tedu Exp $ */
d385 2
a386 1
	timeout_add_sec(&ar->to, 10);
@


1.15
log
@move a little code around, eventually it will be better
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.14 2010/03/06 17:26:44 jsing Exp $ */
d819 1
a819 1
			memset(&buf, 0, sizeof buf);
@


1.14
log
@Allow code to compile.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.12 2009/12/15 13:19:37 jsing Exp $ */
d302 1
d304 1
a304 1
sr_aoe_rw(struct sr_workunit *wu)
d308 2
a309 4
	struct sr_workunit	*wup;
	struct sr_chunk		*scp;
	int			s, ios, rt;
	daddr64_t		fragblk, blk;
d316 1
a316 1
	int			tag, rv, i;
d320 90
a450 5
		fragblk = blk + aoe_frags * i;
		fragsize = aoe_frags * 512;
		if (fragblk + aoe_frags - 1 > wu->swu_blk_end) {
			fragsize = (wu->swu_blk_end - fragblk + 1) * 512;
		}
d491 1
a491 62
		tag = ++sd->mds.mdd_aoe.sra_tag;
		ah = sd->mds.mdd_aoe.sra_ah;
		ar = malloc(sizeof(*ar), M_DEVBUF, M_NOWAIT);
		if (!ar) {
			splx(s);
			return ENOMEM;
		}
		ar->v = wu;
		ar->tag = tag;
		ar->len = fragsize;
		timeout_set(&ar->to, sr_aoe_timeout, ar);
		TAILQ_INSERT_TAIL(&ah->reqs, ar, next);
		splx(s);

		ifp = ah->ifp;
		MGETHDR(m, M_DONTWAIT, MT_HEADER);
		if (xs->flags & SCSI_DATA_OUT && m) {
			MCLGET(m, M_DONTWAIT);
			if (!(m->m_flags & M_EXT)) {
				m_freem(m);
				m = NULL;
			}
		}
		if (!m) {
			s = splbio();
			TAILQ_REMOVE(&ah->reqs, ar, next);
			splx(s);
			free(ar, M_DEVBUF);
			return ENOMEM;
		}

		eh = mtod(m, struct ether_header *);
		memcpy(eh->ether_dhost, sd->mds.mdd_aoe.sra_eaddr, 6);
		memcpy(eh->ether_shost, ((struct arpcom *)ifp)->ac_enaddr, 6);
		eh->ether_type = htons(ETHERTYPE_AOE);
		ap = (struct aoe_packet *)&eh[1];
		ap->vers = 1;
		ap->flags = 0;
		ap->error = 0;
		ap->major = ah->major;
		ap->minor = ah->minor;
		ap->command = 0;
		ap->tag = tag;
		ap->aflags = 0; /* AOE_EXTENDED; */
		if (xs->flags & SCSI_DATA_OUT) {
			ap->aflags |= AOE_WRITE;
			ap->cmd = AOE_WRITE;
			memcpy(ap->data, xs->data + (aoe_frags * i * 512), fragsize);
		} else {
			ap->cmd = AOE_READ;
		}
		ap->feature = 0;
		ap->sectorcnt = fragsize / 512;
		AOE_BLK2HDR(fragblk, ap);

		m->m_pkthdr.len = m->m_len = AOE_CMDHDRLEN + fragsize;
		s = splnet();
		IFQ_ENQUEUE(&ifp->if_snd, m, NULL, rv);
		if ((ifp->if_flags & IFF_OACTIVE) == 0)
			(*ifp->if_start)(ifp);
		timeout_add_sec(&ar->to, 10);
		splx(s);
a493 4
			s = splbio();
			TAILQ_REMOVE(&ah->reqs, ar, next);
			splx(s);
			free(ar, M_DEVBUF);
@


1.13
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d59 1
a59 1
	    int, int64t);
d68 1
a68 1
	    int, int64t);
d136 1
a136 1
    int no_chunk, int64t coerced_size)
d151 1
a151 1
    int no_chunk);
d608 1
a608 1
    int no_chunk, int64t coerced_size)
d625 1
a625 1
    int no_chunk);
@


1.12
log
@Factor out discipline specific create/assemble code.

"in, in, in!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.9 2009/08/09 14:12:25 marco Exp $ */
a541 1
		xs->flags |= ITSDONE;
@


1.11
log
@Define discipline capabilities using a set of flags.

"shiny!!" marco@@
@
text
@d58 4
d67 4
a86 1
	sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;
d90 2
a113 1
	sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;
d117 2
d134 25
d606 27
@


1.10
log
@- let this compile again.

ok jsing@@
@
text
@d78 1
d104 1
a120 3
#if 0
	disk = 0; /* we are not a disk */
#endif
@


1.9
log
@Switch softraid to vnodes to prevent bad things from happening when using
d_open/d_close.

tested by many, ok jsing, thib, krw
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.8 2009/07/24 14:13:28 blambert Exp $ */
d98 1
a98 1
sr_aoe_server_discipline_init(struct sr_dscipline *sd)
d119 1
d121 1
@


1.8
log
@timeout_add -> timeout_add_sec

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.7 2009/06/03 17:39:26 ckuethe Exp $ */
d748 3
d754 1
a754 1
			bdevsw_lookup(buf.b_dev)->d_strategy(&buf);
d814 3
d820 1
a820 1
			bdevsw_lookup(buf.b_dev)->d_strategy(&buf);
@


1.7
log
@whitespace. "Sure" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.6 2009/06/02 21:23:11 marco Exp $ */
d431 1
a431 1
		timeout_add(&ar->to, hz * 10);
@


1.6
log
@Abuse bio layer a little less by marking fake buffers with B_PHYS.
From beck with lots of squealing and ear bleeds.
Issue originally reported by todd.

ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.5 2009/05/11 14:06:21 jsing Exp $ */
d285 1
a285 1
	
a368 1
	
d370 1
a370 1
	
d384 1
a384 1
	
d401 1
a401 1
	
d425 1
a425 1
	
d433 1
a433 1
	
d496 1
a496 1
	
@


1.5
log
@Move the discipline initialisation code into discipline specific functions,
rather than initialising everything in softraid.c. This makes a discipline
more self-contained and reduces the number of function declarations needed
in softraidvar.h.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.3 2008/12/24 19:32:02 marco Exp $ */
d741 1
a741 1
			buf.b_flags = B_WRITE;
d804 1
a804 1
			buf.b_flags = B_WRITE;
@


1.4
log
@malloc + memset(ah, 0, ...) to malloc with M_ZERO.

ok marco@@ some time ago.
@
text
@d57 64
a120 3
void			sr_aoe_input(struct aoe_handler *, struct mbuf *);
void			sr_aoe_setup(struct aoe_handler *, struct mbuf *);
void			sr_aoe_timeout(void *);
@


1.3
log
@This creates the notion of a non-disk softraid device.  The aoe target
is such a beast because it doesn't physically add a device to the OS but
exports a RAID partition.  It creates a kernel thread for each
exported aoe target.  Since it reuses all the goodies in softraid upon
reboot the metadata is discovered and therefore the partition is exported
at boot time.

ok tedu dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.2 2008/11/25 23:05:17 marco Exp $ */
d118 1
a118 2
	ah = malloc(sizeof(*ah), M_DEVBUF, M_WAITOK);
	memset(ah, 0, sizeof(*ah));
@


1.2
log
@Add generic sr_scsi_done function that does the spl dance
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_aoe.c,v 1.1 2008/11/23 23:44:01 tedu Exp $ */
d29 1
d61 1
a61 1
/* AOE disk functions */
d114 1
a114 1
		return EINVAL;
d226 4
a236 3
	wu->swu_blk_start = blk;
	wu->swu_blk_end = blk + (xs->datalen >> 9) - 1;

a383 1

a384 1

d507 4
a510 3
#if 0
int			sr_aoe_start_server(struct sr_discipline *);
void			sr_aoe_server(struct aoe_handler *, struct mbuf *);
d513 1
a513 1
sr_aoe_start_server(struct sr_discipline *sd)
d515 6
a520 13
	struct ifnet *ifp;
	struct aoe_handler *ah;
	unsigned char slot;
	unsigned short shelf;
	const char *nic;
	struct mbuf *m, *m2;
	struct ether_header *eh;
	struct aoe_packet *rp, *ap;
	struct aoe_req *ar;
	int rv, s;
	int len;
	struct buf buf;
	daddr64_t blk;
d523 1
a523 1
		return (EINVAL);
d525 1
a525 1
	DNPRINTF(SR_D_DIS, "%s: sr_aoe_alloc_resources\n",
d528 2
a529 4
	sr_alloc_wu(sd);
	sr_alloc_ccb(sd);

	/* where do these come from */
d532 1
a532 1
	nic = "ne0";
d536 3
a538 1
		return EINVAL;
d542 1
a542 2
	ah = malloc(sizeof(*ah), M_DEVBUF, M_WAITOK);
	memset(ah, 0, sizeof(*ah));
d560 86
d650 1
a650 1
		rv = tsleep(ah, PCATCH|PRIBIO, "wait", 0);
d674 2
a675 1
			memcpy(eh->ether_shost, ((struct arpcom *)ifp)->ac_enaddr, 6);
d737 2
a738 1
			memcpy(eh->ether_shost, ((struct arpcom *)ifp)->ac_enaddr, 6);
a784 1

a785 7

	s = splnet();
	TAILQ_REMOVE(&aoe_handlers, ah, next);
	splx(s);
	free(ah, M_DEVBUF);

	return rv;
d791 2
a792 2
	struct aoe_req *ar;
	int s;
d796 1
a805 1
#endif /* server */
@


1.1
log
@softraid support for ata over ethernet (aoe).  this includes a client and
part of a server.  there's no configuration yet, and several other drawbacks,
but it can be hammered into shape.  i haven't moved the code forward in a year,
and marco wants it in the tree to hack on.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d468 1
a468 1
		scsi_done(xs);
@

