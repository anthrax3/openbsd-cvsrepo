head	1.57;
access;
symbols
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.23.0.4
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.2
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.57
date	2014.01.18.09.23.26;	author jsing;	state dead;
branches;
next	1.56;

1.56
date	2014.01.18.09.01.01;	author jsing;	state Exp;
branches;
next	1.55;

1.55
date	2013.11.21.17.06.45;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2013.11.21.16.34.51;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2013.11.05.08.55.58;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2013.11.04.21.02.57;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.21.15.01.53;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2013.05.21.14.30.01;	author jsing;	state Exp;
branches;
next	1.47;

1.47
date	2013.05.21.14.25.23;	author jsing;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.26.16.06.05;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2013.04.26.15.45.35;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2013.04.23.13.35.08;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2013.04.23.13.13.11;	author jsing;	state Exp;
branches;
next	1.42;

1.42
date	2013.04.23.12.49.52;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2013.03.31.15.44.52;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.31.11.12.06;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.31.10.41.16;	author jsing;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.30.14.41.37;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.29.15.26.45;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.29.13.05.47;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.29.12.00.59;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.29.11.46.45;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2013.03.27.14.30.11;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2013.03.25.16.01.49;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.02.12.50.01;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2013.01.16.09.21.50;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.16.07.06.29;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.16.06.42.22;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.16.06.29.14;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.15.09.28.29;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.15.04.03.01;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.08.14.22.41;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.25.15.28.17;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.08.00.12.54;	author jordan;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.06.02.45.55;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.05.19.52.02;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.02.09.20.26;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.01.19.31.04;	author thib;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.26.11.20.34;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.20.19.55.15;	author jordan;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.15.13.19.37;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.07.14.33.38;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.07.14.27.12;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.09.14.12.25;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.04.20.17.14;	author jordan;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.31.15.30.35;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.31.15.23.02;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.20.13.00.44;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.17.22.45.41;	author jordan;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.13.00.14.56;	author jordan;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.12.17.22.52;	author jsing;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.12.00.04.50;	author jordan;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.10.03.24.02;	author marco;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Rename softraid RAIDP to softraid RAID5.

Discussed with krw@@
@
text
@/* $OpenBSD: softraid_raidp.c,v 1.56 2014/01/18 09:01:01 jsing Exp $ */
/*
 * Copyright (c) 2009 Marco Peereboom <marco@@peereboom.us>
 * Copyright (c) 2009 Jordan Hargrave <jordan@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/disk.h>
#include <sys/rwlock.h>
#include <sys/queue.h>
#include <sys/fcntl.h>
#include <sys/disklabel.h>
#include <sys/mount.h>
#include <sys/sensors.h>
#include <sys/stat.h>
#include <sys/pool.h>
#include <sys/conf.h>
#include <sys/uio.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_disk.h>

#include <dev/softraidvar.h>
#include <dev/rndvar.h>

/* RAID P functions. */
int	sr_raidp_create(struct sr_discipline *, struct bioc_createraid *,
	    int, int64_t);
int	sr_raidp_assemble(struct sr_discipline *, struct bioc_createraid *,
	    int, void *);
int	sr_raidp_init(struct sr_discipline *);
int	sr_raidp_rw(struct sr_workunit *);
int	sr_raidp_openings(struct sr_discipline *);
void	sr_raidp_intr(struct buf *);
int	sr_raidp_wu_done(struct sr_workunit *);
void	sr_raidp_set_chunk_state(struct sr_discipline *, int, int);
void	sr_raidp_set_vol_state(struct sr_discipline *);

void	sr_raidp_xor(void *, void *, int);
int	sr_raidp_addio(struct sr_workunit *wu, int, daddr_t, daddr_t,
	    void *, int, int, void *);
void	sr_dump(void *, int);
void	sr_raidp_scrub(struct sr_discipline *);

void	*sr_get_block(struct sr_discipline *, int);
void	sr_put_block(struct sr_discipline *, void *, int);

/* discipline initialisation. */
void
sr_raidp_discipline_init(struct sr_discipline *sd, u_int8_t type)
{
	/* Fill out discipline members. */
	sd->sd_type = type;
	strlcpy(sd->sd_name, "RAID 5", sizeof(sd->sd_name));
	sd->sd_capabilities = SR_CAP_SYSTEM_DISK | SR_CAP_AUTO_ASSEMBLE |
	    SR_CAP_REDUNDANT;
	sd->sd_max_ccb_per_wu = 4; /* only if stripsize <= MAXPHYS */
	sd->sd_max_wu = SR_RAIDP_NOWU;

	/* Setup discipline specific function pointers. */
	sd->sd_assemble = sr_raidp_assemble;
	sd->sd_create = sr_raidp_create;
	sd->sd_openings = sr_raidp_openings;
	sd->sd_scsi_rw = sr_raidp_rw;
	sd->sd_scsi_intr = sr_raidp_intr;
	sd->sd_scsi_wu_done = sr_raidp_wu_done;
	sd->sd_set_chunk_state = sr_raidp_set_chunk_state;
	sd->sd_set_vol_state = sr_raidp_set_vol_state;
}

int
sr_raidp_create(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, int64_t coerced_size)
{
	if (no_chunk < 3) {
		sr_error(sd->sd_sc, "%s requires three or more chunks",
		    sd->sd_name);
		return EINVAL;
	}

	/*
	 * XXX add variable strip size later even though MAXPHYS is really
	 * the clever value, users like to tinker with that type of stuff.
	 */
	sd->sd_meta->ssdi.ssd_strip_size = MAXPHYS;
	sd->sd_meta->ssdi.ssd_size = (coerced_size &
	    ~(((u_int64_t)sd->sd_meta->ssdi.ssd_strip_size >>
	    DEV_BSHIFT) - 1)) * (no_chunk - 1);

	return sr_raidp_init(sd);
}

int
sr_raidp_assemble(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, void *data)
{
	return sr_raidp_init(sd);
}

int
sr_raidp_init(struct sr_discipline *sd)
{
	/* Initialise runtime values. */
	sd->mds.mdd_raidp.srp_strip_bits =
	    sr_validate_stripsize(sd->sd_meta->ssdi.ssd_strip_size);
	if (sd->mds.mdd_raidp.srp_strip_bits == -1) {
		sr_error(sd->sd_sc, "invalid strip size");
		return EINVAL;
	}

	return 0;
}

int
sr_raidp_openings(struct sr_discipline *sd)
{
	return (sd->sd_max_wu >> 1); /* 2 wu's per IO */
}

void
sr_raidp_set_chunk_state(struct sr_discipline *sd, int c, int new_state)
{
	int			old_state, s;

	DNPRINTF(SR_D_STATE, "%s: %s: %s: sr_raid_set_chunk_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    sd->sd_vol.sv_chunks[c]->src_meta.scmi.scm_devname, c, new_state);

	/* ok to go to splbio since this only happens in error path */
	s = splbio();
	old_state = sd->sd_vol.sv_chunks[c]->src_meta.scm_status;

	/* multiple IOs to the same chunk that fail will come through here */
	if (old_state == new_state)
		goto done;

	switch (old_state) {
	case BIOC_SDONLINE:
		switch (new_state) {
		case BIOC_SDOFFLINE:
		case BIOC_SDSCRUB:
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SDOFFLINE:
		if (new_state == BIOC_SDREBUILD) {
			;
		} else
			goto die;
		break;

	case BIOC_SDSCRUB:
		switch (new_state) {
		case BIOC_SDONLINE:
		case BIOC_SDOFFLINE:
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SDREBUILD:
		switch (new_state) {
		case BIOC_SDONLINE:
		case BIOC_SDOFFLINE:
			break;
		default:
			goto die;
		}
		break;

	default:
die:
		splx(s); /* XXX */
		panic("%s: %s: %s: invalid chunk state transition "
		    "%d -> %d", DEVNAME(sd->sd_sc),
		    sd->sd_meta->ssd_devname,
		    sd->sd_vol.sv_chunks[c]->src_meta.scmi.scm_devname,
		    old_state, new_state);
		/* NOTREACHED */
	}

	sd->sd_vol.sv_chunks[c]->src_meta.scm_status = new_state;
	sd->sd_set_vol_state(sd);

	sd->sd_must_flush = 1;
	workq_add_task(NULL, 0, sr_meta_save_callback, sd, NULL);
done:
	splx(s);
}

void
sr_raidp_set_vol_state(struct sr_discipline *sd)
{
	int			states[SR_MAX_STATES];
	int			new_state, i, s, nd;
	int			old_state = sd->sd_vol_status;

	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid_set_vol_state\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname);

	nd = sd->sd_meta->ssdi.ssd_chunk_no;

	for (i = 0; i < SR_MAX_STATES; i++)
		states[i] = 0;

	for (i = 0; i < nd; i++) {
		s = sd->sd_vol.sv_chunks[i]->src_meta.scm_status;
		if (s >= SR_MAX_STATES)
			panic("%s: %s: %s: invalid chunk state",
			    DEVNAME(sd->sd_sc),
			    sd->sd_meta->ssd_devname,
			    sd->sd_vol.sv_chunks[i]->src_meta.scmi.scm_devname);
		states[s]++;
	}

	if (states[BIOC_SDONLINE] == nd)
		new_state = BIOC_SVONLINE;
	else if (states[BIOC_SDONLINE] < nd - 1)
		new_state = BIOC_SVOFFLINE;
	else if (states[BIOC_SDSCRUB] != 0)
		new_state = BIOC_SVSCRUB;
	else if (states[BIOC_SDREBUILD] != 0)
		new_state = BIOC_SVREBUILD;
	else if (states[BIOC_SDONLINE] == nd - 1)
		new_state = BIOC_SVDEGRADED;
	else {
#ifdef SR_DEBUG
		DNPRINTF(SR_D_STATE, "%s: invalid volume state, old state "
		    "was %d\n", DEVNAME(sd->sd_sc), old_state);
		for (i = 0; i < nd; i++)
			DNPRINTF(SR_D_STATE, "%s: chunk %d status = %d\n",
			    DEVNAME(sd->sd_sc), i,
			    sd->sd_vol.sv_chunks[i]->src_meta.scm_status);
#endif
		panic("invalid volume state");
	}

	DNPRINTF(SR_D_STATE, "%s: %s: sr_raidp_set_vol_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    old_state, new_state);

	switch (old_state) {
	case BIOC_SVONLINE:
		switch (new_state) {
		case BIOC_SVONLINE: /* can go to same state */
		case BIOC_SVDEGRADED:
		case BIOC_SVREBUILD: /* happens on boot */
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVOFFLINE:
		/* XXX this might be a little too much */
		goto die;

	case BIOC_SVSCRUB:
		switch (new_state) {
		case BIOC_SVONLINE:
		case BIOC_SVOFFLINE:
		case BIOC_SVDEGRADED:
		case BIOC_SVSCRUB: /* can go to same state */
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVREBUILD:
		switch (new_state) {
		case BIOC_SVONLINE:
		case BIOC_SVOFFLINE:
		case BIOC_SVDEGRADED:
		case BIOC_SVREBUILD: /* can go to the same state */
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVDEGRADED:
		switch (new_state) {
		case BIOC_SVOFFLINE:
		case BIOC_SVREBUILD:
		case BIOC_SVDEGRADED: /* can go to the same state */
			break;
		default:
			goto die;
		}
		break;

	default:
die:
		panic("%s: %s: invalid volume state transition %d -> %d",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
		    old_state, new_state);
		/* NOTREACHED */
	}

	sd->sd_vol_status = new_state;
}

int
sr_raidp_rw(struct sr_workunit *wu)
{
	struct sr_workunit	*wu_r = NULL;
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_chunk		*scp;
	int			s, i;
	daddr_t			blk, lba;
	int64_t			chunk_offs, lbaoffs, phys_offs, strip_offs;
	int64_t			strip_bits, strip_no, strip_size;
	int64_t			chunk, no_chunk;
	int64_t			length, parity, datalen, row_size;
	void			*xorbuf, *data;

	/* blk and scsi error will be handled by sr_validate_io */
	if (sr_validate_io(wu, &blk, "sr_raidp_rw"))
		goto bad;

	strip_size = sd->sd_meta->ssdi.ssd_strip_size;
	strip_bits = sd->mds.mdd_raidp.srp_strip_bits;
	no_chunk = sd->sd_meta->ssdi.ssd_chunk_no - 1;
	row_size = (no_chunk << strip_bits) >> DEV_BSHIFT;

	data = xs->data;
	datalen = xs->datalen;
	lbaoffs	= blk << DEV_BSHIFT;

	if (xs->flags & SCSI_DATA_OUT) {
		if ((wu_r = sr_scsi_wu_get(sd, SCSI_NOSLEEP)) == NULL){
			printf("%s: can't get wu_r", DEVNAME(sd->sd_sc));
			goto bad;
		}
		wu_r->swu_state = SR_WU_INPROGRESS;
		wu_r->swu_flags |= SR_WUF_DISCIPLINE;
	}

	wu->swu_blk_start = 0;
	while (datalen != 0) {
		strip_no = lbaoffs >> strip_bits;
		strip_offs = lbaoffs & (strip_size - 1);
		chunk_offs = (strip_no / no_chunk) << strip_bits;
		phys_offs = chunk_offs + strip_offs +
		    (sd->sd_meta->ssd_data_offset << DEV_BSHIFT);

		/* get size remaining in this stripe */
		length = MIN(strip_size - strip_offs, datalen);

		/* map disk offset to parity/data drive */
		chunk = strip_no % no_chunk;

		/* RAID5 - left asymmetric algorithm */
		parity = no_chunk - ((strip_no / no_chunk) % (no_chunk + 1));
		if (chunk >= parity)
			chunk++;

		lba = phys_offs >> DEV_BSHIFT;

		/* XXX big hammer.. exclude I/O from entire stripe */
		if (wu->swu_blk_start == 0)
			wu->swu_blk_start = (strip_no / no_chunk) * row_size;
		wu->swu_blk_end = (strip_no / no_chunk) * row_size + (row_size - 1);

		scp = sd->sd_vol.sv_chunks[chunk];
		if (xs->flags & SCSI_DATA_IN) {
			switch (scp->src_meta.scm_status) {
			case BIOC_SDONLINE:
			case BIOC_SDSCRUB:
				/* drive is good. issue single read request */
				if (sr_raidp_addio(wu, chunk, lba, length,
				    data, xs->flags, 0, NULL))
					goto bad;
				break;
			case BIOC_SDOFFLINE:
			case BIOC_SDREBUILD:
			case BIOC_SDHOTSPARE:
				/*
				 * XXX only works if this LBA has already
				 * been scrubbed
				 */
				printf("Disk %llx offline, "
				    "regenerating buffer\n", chunk);
				memset(data, 0, length);
				for (i = 0; i <= no_chunk; i++) {
					/*
					 * read all other drives: xor result
					 * into databuffer.
					 */
					if (i != chunk) {
						if (sr_raidp_addio(wu, i, lba,
						    length, NULL, SCSI_DATA_IN,
						    0, data))
							goto bad;
					}
				}
				break;
			default:
				printf("%s: is offline, can't read\n",
				    DEVNAME(sd->sd_sc));
				goto bad;
			}
		} else {
			/* XXX handle writes to failed/offline disk? */
			if (scp->src_meta.scm_status == BIOC_SDOFFLINE)
				goto bad;

			/*
			 * initialize XORBUF with contents of new data to be
			 * written. This will be XORed with old data and old
			 * parity in the intr routine. The result in xorbuf
			 * is the new parity data.
			 */
			xorbuf = sr_get_block(sd, length);
			if (xorbuf == NULL)
				goto bad;
			memcpy(xorbuf, data, length);

			/* xor old data */
			if (sr_raidp_addio(wu_r, chunk, lba, length, NULL,
			    SCSI_DATA_IN, 0, xorbuf))
				goto bad;

			/* xor old parity */
			if (sr_raidp_addio(wu_r, parity, lba, length, NULL,
			    SCSI_DATA_IN, 0, xorbuf))
				goto bad;

			/* write new data */
			if (sr_raidp_addio(wu, chunk, lba, length, data,
			    xs->flags, 0, NULL))
				goto bad;

			/* write new parity */
			if (sr_raidp_addio(wu, parity, lba, length, xorbuf,
			    xs->flags, SR_CCBF_FREEBUF, NULL))
				goto bad;
		}

		/* advance to next block */
		lbaoffs += length;
		datalen -= length;
		data += length;
	}

	s = splbio();
	if (wu_r) {
		/* collide write request with reads */
		wu_r->swu_blk_start = wu->swu_blk_start;
		wu_r->swu_blk_end = wu->swu_blk_end;

		wu->swu_state = SR_WU_DEFERRED;
		wu_r->swu_collider = wu;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu, swu_link);

		wu = wu_r;
	}
	splx(s);

	sr_schedule_wu(wu);

	return (0);

bad:
	/* XXX - can leak xorbuf on error. */
	/* wu is unwound by sr_wu_put */
	if (wu_r)
		sr_scsi_wu_put(sd, wu_r);
	return (1);
}

void
sr_raidp_intr(struct buf *bp)
{
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu;
	struct sr_discipline	*sd = wu->swu_dis;
	int			s;

	DNPRINTF(SR_D_INTR, "%s: sr_raidp_intr bp %p xs %p\n",
	    DEVNAME(sd->sd_sc), bp, wu->swu_xs);

	s = splbio();
	sr_ccb_done(ccb);

	/* XXX - Should this be done via the workq? */

	/* XOR data to result. */
	if (ccb->ccb_state == SR_CCB_OK && ccb->ccb_opaque)
		sr_raidp_xor(ccb->ccb_opaque, ccb->ccb_buf.b_data,
		    ccb->ccb_buf.b_bcount);

	/* Free allocated data buffer. */
	if (ccb->ccb_flags & SR_CCBF_FREEBUF) {
		sr_put_block(sd, ccb->ccb_buf.b_data, ccb->ccb_buf.b_bcount);
		ccb->ccb_buf.b_data = NULL;
	}

	sr_wu_done(wu);
	splx(s);
}

int
sr_raidp_wu_done(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;

	/* XXX - we have no way of propagating errors... */
	if (wu->swu_flags & SR_WUF_DISCIPLINE)
		return SR_WU_OK;

	/* XXX - This is insufficient for RAID 4/5. */
	if (wu->swu_ios_succeeded > 0) {
		xs->error = XS_NOERROR;
		return SR_WU_OK;
	}

	if (xs->flags & SCSI_DATA_IN) {
		printf("%s: retrying read on block %lld\n",
		    sd->sd_meta->ssd_devname, (long long)wu->swu_blk_start);
		sr_wu_release_ccbs(wu);
		wu->swu_state = SR_WU_RESTART;
		if (sd->sd_scsi_rw(wu) == 0)
			return SR_WU_RESTART;
	} else {
		printf("%s: permanently fail write on block %lld\n",
		    sd->sd_meta->ssd_devname, (long long)wu->swu_blk_start);
	}

	wu->swu_state = SR_WU_FAILED;
	xs->error = XS_DRIVER_STUFFUP;

	return SR_WU_FAILED;
}

int
sr_raidp_addio(struct sr_workunit *wu, int chunk, daddr_t blkno,
    daddr_t len, void *data, int xsflags, int ccbflags, void *xorbuf)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_ccb		*ccb;

	DNPRINTF(SR_D_DIS, "sr_raidp_addio: %s %d.%llx %llx %s\n",
	    (xsflags & SCSI_DATA_IN) ? "read" : "write", chunk, 
	    (long long)blkno, (long long)len, xorbuf ? "X0R" : "-");

	/* Allocate temporary buffer. */
	if (data == NULL) {
		data = sr_get_block(sd, len);
		if (data == NULL)
			return (-1);
		ccbflags |= SR_CCBF_FREEBUF;
	}

	ccb = sr_ccb_rw(sd, chunk, blkno, len, data, xsflags, ccbflags);
	if (ccb == NULL) {
		if (ccbflags & SR_CCBF_FREEBUF)
			sr_put_block(sd, data, len);
		return (-1);
	}
	ccb->ccb_opaque = xorbuf;
	sr_wu_enqueue_ccb(wu, ccb);

	return (0);
}

void
sr_dump(void *blk, int len)
{
	uint8_t			*b = blk;
	int			i, j, c;

	for (i = 0; i < len; i += 16) {
		for (j = 0; j < 16; j++)
			printf("%.2x ", b[i + j]);
		printf("  ");
		for (j = 0; j < 16; j++) {
			c = b[i + j];
			if (c < ' ' || c > 'z' || i + j > len)
				c = '.';
			printf("%c", c);
		}
		printf("\n");
	}
}

void
sr_raidp_xor(void *a, void *b, int len)
{
	uint32_t		*xa = a, *xb = b;

	len >>= 2;
	while (len--)
		*xa++ ^= *xb++;
}

#if 0
void
sr_raidp_scrub(struct sr_discipline *sd)
{
	int64_t strip_no, strip_size, no_chunk, parity, max_strip, strip_bits;
	int64_t i;
	struct sr_workunit *wu_r, *wu_w;
	int s, slept;
	void *xorbuf;

	wu_w = sr_scsi_wu_get(sd, 0);
	wu_r = sr_scsi_wu_get(sd, 0);

	no_chunk = sd->sd_meta->ssdi.ssd_chunk_no - 1;
	strip_size = sd->sd_meta->ssdi.ssd_strip_size;
	strip_bits = sd->mds.mdd_raidp.srp_strip_bits;
	max_strip = sd->sd_meta->ssdi.ssd_size >> strip_bits;

	for (strip_no = 0; strip_no < max_strip; strip_no++) {
		parity = no_chunk - ((strip_no / no_chunk) % (no_chunk + 1));

		xorbuf = sr_get_block(sd, strip_size);
		for (i = 0; i <= no_chunk; i++) {
			if (i != parity)
				sr_raidp_addio(wu_r, i, 0xBADCAFE, strip_size,
				    NULL, SCSI_DATA_IN, 0, xorbuf);
		}
		sr_raidp_addio(wu_w, parity, 0xBADCAFE, strip_size, xorbuf,
		    SCSI_DATA_OUT, SR_CCBF_FREEBUF, NULL);

		wu_r->swu_flags |= SR_WUF_REBUILD;

		/* Collide wu_w with wu_r */
		wu_w->swu_state = SR_WU_DEFERRED;
		wu_w->swu_flags |= SR_WUF_REBUILD | SR_WUF_WAKEUP;
		wu_r->swu_collider = wu_w;

		s = splbio();
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu_w, swu_link);
		splx(s);

		wu_r->swu_state = SR_WU_INPROGRESS;
		sr_schedule_wu(wu_r);

		slept = 0;
		while ((wu_w->swu_flags & SR_WUF_REBUILDIOCOMP) == 0) {
			tsleep(wu_w, PRIBIO, "sr_scrub", 0);
			slept = 1;
		}
		if (!slept)
			tsleep(sd->sd_sc, PWAIT, "sr_yield", 1);
	}
done:
	return;
}
#endif

void *
sr_get_block(struct sr_discipline *sd, int length)
{
	return dma_alloc(length, PR_NOWAIT | PR_ZERO);
}

void
sr_put_block(struct sr_discipline *sd, void *ptr, int length)
{
	dma_free(ptr, length);
}

@


1.56
log
@Remove the RAID 4 discipline from softraid. Anyone sensible would use RAID
5 instead of RAID 4, assuming both were functional.

Discussed with krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.55 2013/11/21 17:06:45 krw Exp $ */
@


1.55
log
@Cast daddr_t variable to (long long) even for %llx!
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.54 2013/11/21 16:34:51 krw Exp $ */
d76 1
a76 4
	if (sd->sd_type == SR_MD_RAID4)
		strlcpy(sd->sd_name, "RAID 4", sizeof(sd->sd_name));
	else
		strlcpy(sd->sd_name, "RAID 5", sizeof(sd->sd_name));
d380 5
a384 9
		if (sd->sd_type == SR_MD_RAID4)
			parity = no_chunk; /* RAID4: Parity is always drive N */
		else {
			/* RAID5: left asymmetric algorithm */
			parity = no_chunk - ((strip_no / no_chunk) %
			    (no_chunk + 1));
			if (chunk >= parity)
				chunk++;
		}
d645 1
a645 5
		if (sd->sd_type == SR_MD_RAID4)
			parity = no_chunk;
		else
			parity = no_chunk - ((strip_no / no_chunk) %
			    (no_chunk + 1));
@


1.54
log
@Change a bunch of daddr_t variables that don't (obviously) contain
512-byte-block information to int64_t, the underlying type of
daddr_t at the moment. No change to .o files. Removal of now
unneeded (long long) casts is next.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.53 2013/11/05 08:55:58 reyk Exp $ */
d580 2
a581 2
	    (xsflags & SCSI_DATA_IN) ? "read" : "write", chunk, blkno, len,
	    xorbuf ? "X0R" : "-");
@


1.53
log
@Fix RAID levels 0, 4, 5, and 6 with partitions larger than 2TB.

A 64bit bit operation with the 32bit strip size could overflow and
result in ridiculously small volumes when using large partitions (eg.
4x 3TB in RAID 5 resulted in a ~2TB volume).  It is fixed by casting
the strip size to an unsigned 64bit value.

ok tedu@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.52 2013/11/04 21:02:57 deraadt Exp $ */
d341 5
a345 3
	daddr_t			blk, lbaoffs, strip_no, chunk, row_size;
	daddr_t			strip_size, no_chunk, lba, chunk_offs, phys_offs;
	daddr_t			strip_bits, length, parity, strip_offs, datalen;
d637 2
a638 2
	daddr_t strip_no, strip_size, no_chunk, parity, max_strip, strip_bits;
	daddr_t i;
@


1.52
log
@substantial namespace cleanup.  Might go a little bit too far, but we
can expose some of the kernel structures with split .h files if need be.
Discussed with various, including jsing.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.51 2013/11/01 17:36:19 krw Exp $ */
d112 2
a113 2
	    ~((sd->sd_meta->ssdi.ssd_strip_size >> DEV_BSHIFT) - 1)) *
	    (no_chunk - 1);
@


1.51
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.50 2013/06/11 16:42:13 deraadt Exp $ */
d37 1
@


1.50
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.49 2013/05/21 15:01:53 jsing Exp $ */
d553 1
a553 1
		    sd->sd_meta->ssd_devname, wu->swu_blk_start);
d560 1
a560 1
		    sd->sd_meta->ssd_devname, wu->swu_blk_start);
@


1.49
log
@Provide a function that handles the scheduling of work units. This
simplifies the discipline code, avoids code duplication and moves the
scheduling logic into a single location.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.46 2013/04/26 16:06:05 jsing Exp $ */
d61 1
a61 1
int	sr_raidp_addio(struct sr_workunit *wu, int, daddr64_t, daddr64_t,
d340 3
a342 3
	daddr64_t		blk, lbaoffs, strip_no, chunk, row_size;
	daddr64_t		strip_size, no_chunk, lba, chunk_offs, phys_offs;
	daddr64_t		strip_bits, length, parity, strip_offs, datalen;
d570 2
a571 2
sr_raidp_addio(struct sr_workunit *wu, int chunk, daddr64_t blkno,
    daddr64_t len, void *data, int xsflags, int ccbflags, void *xorbuf)
d634 2
a635 2
	daddr64_t strip_no, strip_size, no_chunk, parity, max_strip, strip_bits;
	daddr64_t i;
@


1.48
log
@Fix missing work unit state initialisations.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.47 2013/05/21 14:25:23 jsing Exp $ */
d490 3
a493 19
	/* Construct the work unit, do not schedule it. */
	if (wu->swu_state == SR_WU_CONSTRUCT)
		goto queued;

	/* current io failed, restart */
	if (wu->swu_state == SR_WU_RESTART)
		goto start;

	/* deferred io failed, don't restart */
	if (wu->swu_state == SR_WU_REQUEUE)
		goto queued;

	if (sr_check_io_collision(wu))
		goto queued;

start:
	sr_raid_startwu(wu);
queued:
	splx(s);
d495 1
d673 1
d675 2
a676 5
		if (sr_check_io_collision(wu_r))
			goto queued;
		sr_raid_startwu(wu_r);
	queued:
		splx(s);
@


1.47
log
@Use a state to indicate that a work unit should only be constructed and not
scheduled, rather than trying to imply this from the rebuild flag.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.46 2013/04/26 16:06:05 jsing Exp $ */
d363 1
@


1.46
log
@Convert RAID4/5 to new work unit completion routines.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.45 2013/04/26 15:45:35 jsing Exp $ */
d490 2
a491 2
	/* rebuild io, let rebuild routine deal with it */
	if (wu->swu_flags & SR_WUF_REBUILD)
@


1.45
log
@Add a SR_WUF_DISCIPLINE flag that identifies work units that have resulted
from discipline specific I/O. Such work units are not associated with a
SCSI xfer and are returned via sr_wu_put() on completion.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.44 2013/04/23 13:35:08 jsing Exp $ */
d56 1
d90 1
d522 1
a522 1
	struct sr_workunit	*wu = ccb->ccb_wu, *wup;
a523 2
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_softc		*sc = sd->sd_sc;
d527 1
a527 1
	    DEVNAME(sc), bp, xs);
d530 1
d532 1
a532 1
	sr_ccb_done(ccb);
d545 3
a547 3
	DNPRINTF(SR_D_INTR, "%s: sr_intr: comp: %d count: %d failed: %d\n",
	    DEVNAME(sc), wu->swu_ios_complete, wu->swu_io_count,
	    wu->swu_ios_failed);
d549 9
a557 2
	if (wu->swu_ios_complete < wu->swu_io_count)
		goto done;
d559 2
a560 1
	if (xs != NULL)
d562 1
a562 17

	/* if all ios failed, retry reads and give up on writes */
	if (wu->swu_ios_failed == wu->swu_ios_complete) {
		/* XXX xs could be NULL here. */
		if (xs->flags & SCSI_DATA_IN) {
			printf("%s: retrying read on block %lld\n",
			    DEVNAME(sc), ccb->ccb_buf.b_blkno);
			sr_wu_release_ccbs(wu);
			wu->swu_state = SR_WU_RESTART;
			if (sd->sd_scsi_rw(wu) == 0)
				goto done;
			xs->error = XS_DRIVER_STUFFUP;
		} else {
			printf("%s: permanently fail write on block %lld\n",
			    DEVNAME(sc), ccb->ccb_buf.b_blkno);
			xs->error = XS_DRIVER_STUFFUP;
		}
d565 10
a574 19
	TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link)
		if (wu == wup)
			break;

	if (wup == NULL)
		panic("%s: wu %p not on pending queue",
		    DEVNAME(sd->sd_sc), wu);

	TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);

	if (wu->swu_collider) {
		if (wu->swu_ios_failed)
			sr_raid_recreate_wu(wu->swu_collider);

		/* XXX Should the collider be failed if this xs failed? */
		/* restart deferred wu */
		wu->swu_collider->swu_state = SR_WU_INPROGRESS;
		TAILQ_REMOVE(&sd->sd_wu_defq, wu->swu_collider, swu_link);
		sr_raid_startwu(wu->swu_collider);
d577 2
a578 8
	if (wu->swu_flags & SR_WUF_REBUILD)
		wu->swu_flags |= SR_WUF_REBUILDIOCOMP;
	if (wu->swu_flags & SR_WUF_WAKEUP)
		wakeup(wu);
	if (wu->swu_flags & SR_WUF_DISCIPLINE)
		sr_scsi_wu_put(sd, wu);
	else if (!(wu->swu_flags & SR_WUF_REBUILD))
		sr_scsi_done(sd, xs);
d580 1
a580 2
done:
	splx(s);
@


1.44
log
@Convert RAID4/5 to new ccb handling.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.43 2013/04/23 13:13:11 jsing Exp $ */
d356 1
a356 2
	if (xs->flags & SCSI_DATA_OUT)
		/* create write workunit */
d361 2
d597 4
a600 7
	if (!(wu->swu_flags & SR_WUF_REBUILD)) {
		if (xs == NULL) {
			sr_scsi_wu_put(sd, wu);
		} else {
			sr_scsi_done(sd, xs);
		}
	}
@


1.43
log
@Do not pass SR_CCBF_FREEBUF unless we are passing an already allocated
buffer that we want freed; set SR_CCBF_FREEBUF when a buffer is allocated
by the addio function.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.42 2013/04/23 12:49:52 jsing Exp $ */
d609 2
a610 2
sr_raidp_addio(struct sr_workunit *wu, int dsk, daddr64_t blk, daddr64_t len,
    void *data, int flag, int ccbflags, void *xorbuf)
d615 3
a617 3
	ccb = sr_ccb_get(sd);
	if (!ccb)
		return (-1);
d619 1
a619 1
	/* allocate temporary buffer */
d627 5
a631 12
	DNPRINTF(0, "%sio: %d.%llx %llx %s\n",
	    flag & SCSI_DATA_IN ? "read" : "write",
	    dsk, blk, len,
	    xorbuf ? "X0R" : "-");

	ccb->ccb_flags = ccbflags;
	if (flag & SCSI_POLL) {
		ccb->ccb_buf.b_flags = 0;
		ccb->ccb_buf.b_iodone = NULL;
	} else {
		ccb->ccb_buf.b_flags = B_CALL;
		ccb->ccb_buf.b_iodone = sr_raidp_intr;
a632 22
	if (flag & SCSI_DATA_IN)
		ccb->ccb_buf.b_flags |= B_READ;
	else
		ccb->ccb_buf.b_flags |= B_WRITE;

	/* add offset for metadata */
	ccb->ccb_buf.b_flags |= B_PHYS;
	ccb->ccb_buf.b_blkno = blk;
	ccb->ccb_buf.b_bcount = len;
	ccb->ccb_buf.b_bufsize = len;
	ccb->ccb_buf.b_resid = len;
	ccb->ccb_buf.b_data = data;
	ccb->ccb_buf.b_error = 0;
	ccb->ccb_buf.b_proc = curproc;
	ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[dsk]->src_dev_mm;
	ccb->ccb_buf.b_vp = sd->sd_vol.sv_chunks[dsk]->src_vn;
	ccb->ccb_buf.b_bq = NULL;
	if ((ccb->ccb_buf.b_flags & B_READ) == 0)
		ccb->ccb_buf.b_vp->v_numoutput++;

	ccb->ccb_wu = wu;
	ccb->ccb_target = dsk;
d634 1
a634 11

	LIST_INIT(&ccb->ccb_buf.b_dep);
	TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);

	DNPRINTF(SR_D_DIS, "%s: %s: sr_raidp: b_bcount: %d "
	    "b_blkno: %x b_flags 0x%0x b_data %p\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
	    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);

	wu->swu_io_count++;
@


1.42
log
@Rename ccb_flag to ccb_flags.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.41 2013/03/31 15:44:52 jsing Exp $ */
d341 1
a341 1
	void		       *xorbuf, *data;
d421 1
a421 1
						    SR_CCBF_FREEBUF, data))
d449 1
a449 1
			    SCSI_DATA_IN, SR_CCBF_FREEBUF, xorbuf))
d454 1
a454 1
			    SCSI_DATA_IN, SR_CCBF_FREEBUF, xorbuf))
d508 1
d624 1
d737 1
a737 2
				    NULL, SCSI_DATA_IN, SR_CCBF_FREEBUF,
				    xorbuf);
@


1.41
log
@Use consistent error handling when validating the number of chunks
provided.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.40 2013/03/31 11:12:06 jsing Exp $ */
d537 1
a537 1
	if (ccb->ccb_flag & SR_CCBF_FREEBUF) {
d609 1
a609 1
    void *data, int flag, int ccbflag, void *xorbuf)
d630 1
a630 1
	ccb->ccb_flag = ccbflag;
@


1.40
log
@Provide default resource allocation and free functions. Convert all
disciplines except for AOE and CRYPTO, which require custom handlers.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.39 2013/03/31 10:41:16 jsing Exp $ */
d97 3
a99 2

	if (no_chunk < 3)
d101 1
@


1.39
log
@Pull the initialisation of runtime values out into a separate init
function, rather than having it spread across create/assemble/alloc.
Also handle strip size errors appropriately, rather than failing silently.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.38 2013/03/30 14:41:37 jsing Exp $ */
a52 2
int	sr_raidp_alloc_resources(struct sr_discipline *);
int	sr_raidp_free_resources(struct sr_discipline *);
a83 1
	sd->sd_alloc_resources = sr_raidp_alloc_resources;
a85 1
	sd->sd_free_resources = sr_raidp_free_resources;
a137 33
}

int
sr_raidp_alloc_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	DNPRINTF(SR_D_DIS, "%s: sr_raidp_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	if (sr_wu_alloc(sd))
		goto bad;
	if (sr_ccb_alloc(sd))
		goto bad;

	rv = 0;
bad:
	return (rv);
}

int
sr_raidp_free_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	DNPRINTF(SR_D_DIS, "%s: sr_raidp_free_resources\n",
	    DEVNAME(sd->sd_sc));

	sr_wu_free(sd);
	sr_ccb_free(sd);

	rv = 0;
	return (rv);
@


1.38
log
@Provide wrappers for scsi_io_get() and scsi_io_put(), that also include
the sd_sync check/wakeup. Remove some unnecessary NULL checks whilst here.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.37 2013/03/29 15:26:45 jsing Exp $ */
d52 1
d114 1
a114 1
	return 0;
d121 13
a154 6
		goto bad;

	/* setup runtime values */
	sd->mds.mdd_raidp.srp_strip_bits =
	    sr_validate_stripsize(sd->sd_meta->ssdi.ssd_strip_size);
	if (sd->mds.mdd_raidp.srp_strip_bits == -1)
@


1.37
log
@Properly release ccbs when restarting a work unit.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.36 2013/03/29 13:05:47 jsing Exp $ */
d385 1
a385 1
		if ((wu_r = scsi_io_get(&sd->sd_iopool, SCSI_NOSLEEP)) == NULL){
d537 1
a537 1
		scsi_io_put(&sd->sd_iopool, wu_r);
d624 1
a624 3
			scsi_io_put(&sd->sd_iopool, wu);
			if (sd->sd_sync && sd->sd_wu_pending == 0)
				wakeup(sd);
d743 2
a744 4
	if ((wu_w = scsi_io_get(&sd->sd_iopool, 0)) == NULL)
		goto done;
	if ((wu_r = scsi_io_get(&sd->sd_iopool, 0)) == NULL)
		goto done;
@


1.36
log
@Convert RAID 4/5/6 to new ccb completion code.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.35 2013/03/29 12:00:59 jsing Exp $ */
d585 1
a585 2
			sr_ccb_put(ccb);
			TAILQ_INIT(&wu->swu_ccb);
@


1.35
log
@Decouple wakeups on work unit completion from the type of I/O being
performed.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.34 2013/03/29 11:46:45 jsing Exp $ */
d551 1
a551 1
	DNPRINTF(SR_D_INTR, "%s: sr_intr bp %p xs %p\n",
d554 1
a554 4
	DNPRINTF(SR_D_INTR, "%s: sr_intr: b_bcount: %d b_resid: %d"
	    " b_flags: 0x%0x block: %lld target: %d\n", DEVNAME(sc),
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags,
	    ccb->ccb_buf.b_blkno, ccb->ccb_target);
d556 1
a556 1
	s = splbio();
d558 4
a561 19
	if (ccb->ccb_buf.b_flags & B_ERROR) {
		DNPRINTF(SR_D_INTR, "%s: i/o error on block %lld target: %d\n",
		    DEVNAME(sc), ccb->ccb_buf.b_blkno, ccb->ccb_target);
		printf("io error: disk %x\n", ccb->ccb_target);
		wu->swu_ios_failed++;
		ccb->ccb_state = SR_CCB_FAILED;
		if (ccb->ccb_target != -1)
			sd->sd_set_chunk_state(sd, ccb->ccb_target,
			    BIOC_SDOFFLINE);
		else
			panic("%s: invalid target on wu: %p", DEVNAME(sc), wu);
	} else {
		ccb->ccb_state = SR_CCB_OK;
		wu->swu_ios_succeeded++;
		/* XOR data to result */
		if (ccb->ccb_opaque)
			sr_raidp_xor(ccb->ccb_opaque, ccb->ccb_buf.b_data,
			    ccb->ccb_buf.b_bcount);
	}
d563 1
a563 1
	/* free allocated data buffer */
a567 1
	wu->swu_ios_complete++;
@


1.34
log
@sd_wu_pending is only decremented when scsi_done() or scsi_io_put() are
called. As a result, factor out the the sd_sync check/wakeup code and move
it to after the scsi_done() call in sr_scsi_done(). Perform the same
sd_sync check/wakeup after scsi_io_put() calls (including the addition of
some that were previously missed).

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.33 2013/03/27 14:30:11 jsing Exp $ */
d638 5
a642 7
	if (wu->swu_flags & SR_WUF_REBUILD) {
		/* XXX - decouple from SCSI_DATA_OUT. */
		if (wu->swu_xs->flags & SCSI_DATA_OUT) {
			wu->swu_flags |= SR_WUF_REBUILDIOCOMP;
			wakeup(wu);
		}
	} else {
d796 1
@


1.33
log
@Rewrite the work unit handling code in the RAID 1/4/5/6 interrupt handlers.
This simplifies the code and will allow for easier conversion to the workq
based work unit completion routines. It also ensures that work units are
always removed from the pending queue and that colliders are started, even
in the event of an I/O failure.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.32 2013/03/25 16:01:49 jsing Exp $ */
d645 5
a649 1
		if (xs != NULL)
d651 1
a651 2
		else
			scsi_io_put(&sd->sd_iopool, wu);
a652 3

	if (sd->sd_sync && sd->sd_wu_pending == 0)
		wakeup(sd);
@


1.32
log
@Factor out the code that is used to recreate work units - one copy of the
code is sufficient.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.31 2013/03/02 12:50:01 jsing Exp $ */
d549 1
a549 1
	int			s, pend;
d592 2
a593 1
	if (wu->swu_ios_complete >= wu->swu_io_count) {
d595 2
a596 20
		/* if all ios failed, retry reads and give up on writes */
		if (wu->swu_ios_failed == wu->swu_ios_complete) {
			if (xs->flags & SCSI_DATA_IN) {
				printf("%s: retrying read on block %lld\n",
				    DEVNAME(sc), ccb->ccb_buf.b_blkno);
				sr_ccb_put(ccb);
				TAILQ_INIT(&wu->swu_ccb);
				wu->swu_state = SR_WU_RESTART;
				if (sd->sd_scsi_rw(wu))
					goto bad;
				else
					goto retry;
			} else {
				printf("%s: permanently fail write on block "
				    "%lld\n", DEVNAME(sc),
				    ccb->ccb_buf.b_blkno);
				xs->error = XS_DRIVER_STUFFUP;
				goto bad;
			}
		}
d598 16
a613 24
		if (xs != NULL)
			xs->error = XS_NOERROR;

		pend = 0;
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link) {
			if (wu == wup) {
				/* wu on pendq, remove */
				TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);
				pend = 1;

				if (wu->swu_collider) {
					if (wu->swu_ios_failed)
						/* toss all ccbs and recreate */
						sr_raid_recreate_wu(wu->swu_collider);

					/* restart deferred wu */
					wu->swu_collider->swu_state =
					    SR_WU_INPROGRESS;
					TAILQ_REMOVE(&sd->sd_wu_defq,
					    wu->swu_collider, swu_link);
					sr_raid_startwu(wu->swu_collider);
				}
				break;
			}
d615 1
d617 3
a619 15
		if (!pend)
			printf("%s: wu: %p not on pending queue\n",
			    DEVNAME(sc), wu);

		if (wu->swu_flags & SR_WUF_REBUILD) {
			if (wu->swu_xs->flags & SCSI_DATA_OUT) {
				wu->swu_flags |= SR_WUF_REBUILDIOCOMP;
				wakeup(wu);
			}
		} else {
			if (xs != NULL)
				sr_scsi_done(sd, xs);
			else
				scsi_io_put(&sd->sd_iopool, wu);
		}
d621 15
a635 2
		if (sd->sd_sync && sd->sd_wu_pending == 0)
			wakeup(sd);
a637 5
retry:
	splx(s);
	return;
bad:
	xs->error = XS_DRIVER_STUFFUP;
d639 5
a643 2
		wu->swu_flags |= SR_WUF_REBUILDIOCOMP;
		wakeup(wu);
d645 4
a648 1
		sr_scsi_done(sd, xs);
d651 4
@


1.31
log
@sr_alloc_resources() and sr_free_resources() can never be called without
a valid struct sr_discipline. Remove redundant NULL pointer checks.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.30 2013/01/16 09:21:50 jsing Exp $ */
a56 1
void	sr_raidp_recreate_wu(struct sr_workunit *);
d628 1
a628 1
						sr_raidp_recreate_wu(wu->swu_collider);
a673 21
}

void
sr_raidp_recreate_wu(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_workunit	*wup = wu;

	do {
		DNPRINTF(SR_D_INTR, "%s: sr_raidp_recreate_wu: %p\n", wup);

		/* toss all ccbs */
		sr_wu_release_ccbs(wup);

		/* recreate ccbs */
		wup->swu_state = SR_WU_REQUEUE;
		if (sd->sd_scsi_rw(wup))
			panic("could not requeue io");

		wup = wup->swu_collider;
	} while (wup);
@


1.30
log
@Consistently call sr_scsi_done instead of scsi_done.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.29 2013/01/16 07:06:29 jsing Exp $ */
a135 3
	if (!sd)
		return (rv);

a158 3

	if (!sd)
		return (rv);
@


1.29
log
@Add a new capability flag to identify disciplines where read failures are
not necessarily terminal (i.e. we have redundancy).

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.28 2013/01/16 06:42:22 jsing Exp $ */
d659 1
a659 1
				scsi_done(xs);
d677 1
a677 1
		scsi_done(xs);
@


1.28
log
@Set resid to zero if the scsi transfer completed without error.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.27 2013/01/16 06:29:14 jsing Exp $ */
d80 2
a81 1
	sd->sd_capabilities = SR_CAP_SYSTEM_DISK | SR_CAP_AUTO_ASSEMBLE;
@


1.27
log
@Factor out code used to release ccbs from a workunit.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.26 2013/01/15 09:28:29 jsing Exp $ */
d621 1
a621 1
		if (xs != NULL) {
a622 2
			xs->resid = 0;
		}
@


1.26
log
@Always initialise the discipline name, not just when we are doing a create.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.25 2013/01/15 04:03:01 jsing Exp $ */
a688 1
	struct sr_ccb		*ccb;
d694 1
a694 5
		while ((ccb = TAILQ_FIRST(&wup->swu_ccb)) != NULL) {
			TAILQ_REMOVE(&wup->swu_ccb, ccb, ccb_link);
			sr_ccb_put(ccb);
		}
		TAILQ_INIT(&wup->swu_ccb);
@


1.25
log
@Keep a function pointer to the per-discipline I/O interrupt handler in the
discipline data structure. To be used with an upcoming diff.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.24 2012/10/08 14:22:41 jsing Exp $ */
a73 1

d76 4
a102 5

	if (sd->sd_type == SR_MD_RAID4)
		strlcpy(sd->sd_name, "RAID 4", sizeof(sd->sd_name));
	else
		strlcpy(sd->sd_name, "RAID 5", sizeof(sd->sd_name));
@


1.24
log
@Provide a mechanism for the kernel to pass data through to the discipline
during volume assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.21 2011/04/06 02:45:55 marco Exp $ */
d88 1
@


1.23
log
@Initialise discipline function pointers with defaults and only override
those that are needed by a specific discipline.
@
text
@d51 1
a51 1
	    int);
d119 1
a119 1
    int no_chunk)
@


1.22
log
@Fix raidp/raid6 to work with new iopool code, needed to swap wu's
Update to use dma_malloc for I/O blocks
ok marco@@
@
text
@d75 1
a75 1
	/* fill out discipline members. */
d81 3
a83 1
	/* setup discipline pointers. */
a84 2
	sd->sd_assemble = sr_raidp_assemble;
	sd->sd_alloc_resources = sr_raidp_alloc_resources;
d86 1
a86 7
	sd->sd_start_discipline = NULL;
	sd->sd_scsi_inquiry = sr_raid_inquiry;
	sd->sd_scsi_read_cap = sr_raid_read_cap;
	sd->sd_scsi_tur = sr_raid_tur;
	sd->sd_scsi_req_sense = sr_raid_request_sense;
	sd->sd_scsi_start_stop = sr_raid_start_stop;
	sd->sd_scsi_sync = sr_raid_sync;
a89 1
	sd->sd_openings = sr_raidp_openings;
@


1.21
log
@fix some spaces while looking for bigmem shiz
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.20 2011/04/05 19:52:02 krw Exp $ */
d68 1
a68 1
void	sr_put_block(struct sr_discipline *, void *);
d374 1
a374 1
	struct sr_workunit	*wu_w = NULL;
d399 2
a400 2
		if ((wu_w = scsi_io_get(&sd->sd_iopool, SCSI_NOSLEEP)) == NULL){
			printf("%s: can't get wu_w", DEVNAME(sd->sd_sc));
d489 1
a489 1
			if (sr_raidp_addio(wu, chunk, lba, length, NULL,
d494 1
a494 1
			if (sr_raidp_addio(wu, parity, lba, length, NULL,
d499 1
a499 1
			if (sr_raidp_addio(wu_w, chunk, lba, length, data,
d504 1
a504 1
			if (sr_raidp_addio(wu_w, parity, lba, length, xorbuf,
d516 1
a516 1
	if (wu_w) {
d518 2
a519 2
		wu_w->swu_blk_start = wu->swu_blk_start;
		wu_w->swu_blk_end = wu->swu_blk_end;
d521 3
a523 6
		/*
		 * put xs block in write request (scsi_done not called till
		 * write completes)
		 */
		wu_w->swu_xs = wu->swu_xs;
		wu->swu_xs = NULL;
d525 1
a525 3
		wu_w->swu_state = SR_WU_DEFERRED;
		wu->swu_collider = wu_w;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu_w, swu_link);
d550 2
a551 2
	if (wu_w)
		scsi_io_put(&sd->sd_iopool, wu_w);
d597 1
a597 1
		sr_put_block(sd, ccb->ccb_buf.b_data);
d885 1
a885 1
	return malloc(length, M_DEVBUF, M_ZERO | M_NOWAIT | M_CANFAIL);
d889 1
a889 1
sr_put_block(struct sr_discipline *sd, void *ptr)
d891 1
a891 1
	free(ptr, M_DEVBUF);
@


1.20
log
@Iopoolification. Testing by marco@@.

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.19 2010/08/07 03:50:01 krw Exp $ */
d64 1
a64 1
void 	sr_dump(void *, int);
d415 1
a415 1
		/* map disk offset to parity/data drive */	
d426 1
a426 1
	
d428 1
a428 1
	
d727 1
a727 1
	struct sr_discipline 	*sd = wu->swu_dis;
d799 1
a799 1
		for (j = 0; j < 16; j++) 
d853 1
a853 1
				    NULL, SCSI_DATA_IN, SR_CCBF_FREEBUF, 
d860 1
a860 1
		
@


1.19
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.18 2010/07/02 09:20:26 jsing Exp $ */
d399 1
a399 1
		if ((wu_w = sr_wu_get(sd, 0)) == NULL) {
d556 1
a556 1
		sr_wu_put(wu_w);
a671 2
			/* do not change the order of these 2 functions */
			sr_wu_put(wu);
d674 2
a690 2
		/* do not change the order of these 2 functions */
		sr_wu_put(wu);
d832 1
a832 1
	if ((wu_r = sr_wu_get(sd, 1)) == NULL)
d834 1
a834 1
	if ((wu_w = sr_wu_get(sd, 1)) == NULL)
@


1.18
log
@Determine the data offset using a variable specified within the softraid
metadata. This allows us to implement seamless transitions from the
previous metadata version to the current version, avoiding the need to
recreate the softraid volume.

Joint work with marco@@ during c2k10.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.16 2010/03/26 11:20:34 jsing Exp $ */
d242 1
a242 1
		    "%d -> %d\n", DEVNAME(sd->sd_sc),
d362 1
a362 1
		panic("%s: %s: invalid volume state transition %d -> %d\n",
@


1.17
log
@make sure that buf's on the stack set the b_bq to NULL.
one memset -> bzero.

ok marco@@, jsing@@
@
text
@d410 1
a410 1
		    (SR_DATA_OFFSET << DEV_BSHIFT);
@


1.16
log
@Add storage for the boot block and boot loader to the softraid metadata.
Also add a new optional metadata type for boot data. This is the first
step (of many) towards being able to boot from softraid volumes.

WARNING: This version of the softraid metadata is not compatible with
previous versions. As a result, any softraid volumes created with older
kernels will not assemble. Data on existing softraid volumes should be
backed up before upgrading. The volume should then be recreated and the
data restored.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.14 2010/01/09 23:15:06 krw Exp $ */
d772 1
@


1.15
log
@Fix collider offsets to correct LBA.
Thanks to Niklas
ok @@marco
@
text
@d409 2
a410 2
		phys_offs = chunk_offs + strip_offs + 
		    ((SR_META_OFFSET + SR_META_SIZE) << DEV_BSHIFT);
@


1.14
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.13 2009/12/15 13:19:37 jsing Exp $ */
d379 1
a379 1
	daddr64_t		blk, lbaoffs, strip_no, chunk;
d391 1
d431 2
a432 2
			wu->swu_blk_start = chunk_offs >> DEV_BSHIFT;
		wu->swu_blk_end = ((chunk_offs + (no_chunk << strip_bits)) >> DEV_BSHIFT) - 1;
@


1.13
log
@Factor out discipline specific create/assemble code.

"in, in, in!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.11 2009/12/07 14:27:12 jsing Exp $ */
a635 1
			xs->flags |= ITSDONE;
a685 1
	xs->flags |= ITSDONE;
@


1.12
log
@Cleanup discipline initialisation.

ok marco@@
@
text
@d48 4
d82 2
d97 33
@


1.11
log
@Define discipline capabilities using a set of flags.

"shiny!!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.9 2009/08/04 20:17:14 jordan Exp $ */
d68 1
a68 1
sr_raidp_discipline_init(struct sr_discipline *sd)
d72 1
@


1.10
log
@Switch softraid to vnodes to prevent bad things from happening when using
d_open/d_close.

tested by many, ok jsing, thib, krw
@
text
@d72 1
a74 1
	sd->sd_rebuild = 0;
@


1.9
log
@Fix volume state transitions for RAID4/5/6
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.8 2009/07/31 15:30:35 jsing Exp $ */
d732 3
a734 1
	ccb->ccb_buf.b_vp = NULL;
@


1.8
log
@Clean up debug droppings.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.7 2009/07/31 15:23:02 jsing Exp $ */
a244 2
	else if (states[BIOC_SDONLINE] == nd - 1)
		new_state = BIOC_SVDEGRADED;
d251 2
@


1.7
log
@raidp is degraded when n - 1 disks are online, not offline.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.5 2009/06/17 22:45:41 jordan Exp $ */
d254 3
a256 1
		printf("old_state = %d, ", old_state);
d258 2
a259 1
			printf("%d = %d, ", i,
d261 2
a262 1
		panic("invalid new_state");
d265 1
a265 1
	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid_set_vol_state %d -> %d\n",
@


1.6
log
@First stab at state transitions.
ok jsing
@
text
@d245 2
a248 2
	else if (states[BIOC_SDOFFLINE] == nd - 1)
		new_state = BIOC_SVDEGRADED;
@


1.5
log
@Added openings callback; cleanup & KNF
I/O now works reliably
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.4 2009/06/13 00:14:56 jordan Exp $ */
a147 1
	/* XXX this is for RAID 0 */
a163 1
			break;
d179 5
a183 3
		if (new_state == BIOC_SDONLINE) {
			;
		} else
d185 1
d189 5
a193 10
		if (new_state == BIOC_SDONLINE) {
			;
		} else
			goto die;
		break;

	case BIOC_SDHOTSPARE:
		if (new_state == BIOC_SDREBUILD) {
			;
		} else
d195 1
a224 2
	/* XXX this is for RAID 0 */

d245 1
a245 1
	else if (states[BIOC_SDONLINE] == 0)
d247 2
a252 2
	else if (states[BIOC_SDOFFLINE] != 0)
		new_state = BIOC_SVDEGRADED;
a268 1
		case BIOC_SVOFFLINE:
a286 11
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVBUILDING:
		switch (new_state) {
		case BIOC_SVONLINE:
		case BIOC_SVOFFLINE:
		case BIOC_SVBUILDING: /* can go to the same state */
@


1.4
log
@Fixed writes for RAID4/5, was not properly freeing Xor buffer
Cleaned up LBA calculation code
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.3 2009/06/12 17:22:52 jsing Exp $ */
d51 1
d63 4
a66 1
/* Discipline initialisation. */
d71 2
a72 2
	/* Fill out discipline members. */
	sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;
d74 1
a74 1
	sd->sd_rebuild = 1;
d76 1
a76 1
	/* Setup discipline pointers. */
d89 7
d148 1
d228 2
a368 4
#if 0
	printf("0000: sr_raidp_%s: blk=%llx len=%llx\n",	 
	     xs->flags & SCSI_DATA_IN ? "rd" : "wr", blk, datalen);
#endif
d370 2
a371 2
		/* Create Write workunit */
		if ((wu_w = sr_wu_get(sd, 1)) == NULL) {
d384 1
a384 1
		/* Get size remaining in this stripe */
d387 1
a387 1
		/* Map disk offset to parity/data drive */	
d390 1
a390 2
			/* RAID4: Parity is always drive N */
			parity = no_chunk;
d392 1
a392 1
			/* RAID5: Left Asymmetric algorithm */
d401 1
a401 1
		/* XXX: Big Hammer.. exclude I/O from entire stripe */
d405 1
a405 5
#if 0
		printf("    : strip=%llx offs=%llx lba=%llx len=%llx n=%lld, "
		    "p=%lld\n", strip_no, strip_offs, lba, length, chunk,
		    parity);
#endif
d411 1
a411 1
				/* Drive is good.. issue single read request */
d420 1
a420 1
				 * XXX: only works if this LBA has already
d428 1
a428 1
					 * Read all other drives: xor result
d445 1
a445 1
			/* XXX: handle writes to failed/offline disk?? */
d450 1
a450 1
			 * Initialize XORBUF with contents of new data to be
d455 3
a457 1
			xorbuf = malloc(length, M_DEVBUF, M_ZERO);
d460 1
d462 16
a477 7
			    SCSI_DATA_IN, SR_CCBF_FREEBUF, xorbuf) ||	/* xor old data */
			    sr_raidp_addio(wu, parity, lba, length, NULL,
			    SCSI_DATA_IN, SR_CCBF_FREEBUF, xorbuf) ||	/* xor old parity */
			    sr_raidp_addio(wu_w, chunk, lba, length, data,
			    xs->flags, 0, NULL) ||		/* write new data */
			    sr_raidp_addio(wu_w, parity, lba, length, xorbuf,
			    xs->flags, SR_CCBF_FREEBUF, NULL))		/* write new parity */
d481 1
a481 1
		/* Advance to next block */
d486 1
d489 1
a489 1
		/* Collide write request with reads */
d493 7
d517 1
a517 2
	if (sr_check_io_collision(wu)) {
		printf("input collided\n");
a518 1
	}
d542 1
a542 1
	DNPRINTF(SR_D_INTR, "%s: sr_intr bp %x xs %x\n",
a549 9
#if 0
	printf("sr_intr: %s %d.%llx %lx %s\n",
	    (ccb->ccb_buf.b_flags & B_READ) ? "read" : "write",
	    ccb->ccb_target,
	    ccb->ccb_buf.b_blkno,
	    ccb->ccb_buf.b_bcount,
	    ccb->ccb_opaque ? "<xor>" : "");
#endif

d566 2
a567 2
		if (ccb->ccb_opaque) {
			/* XOR data to result */
a569 1
		}
d572 5
a576 4
	/* Free allocated data buffer */
	if (ccb->ccb_flag & SR_CCBF_FREEBUF)
			free(ccb->ccb_buf.b_data, M_DEVBUF);

d584 1
d710 6
a715 3
	/* Allocate temporary buffer */
	if (data == NULL)
		data = malloc(len, M_DEVBUF, M_ZERO);
d735 1
a735 1
	/* Add offset for metadata */
d765 2
a766 1
void sr_dump(void *blk, int len)
d768 2
a769 2
	uint8_t *b = blk;
	int i, j, c;
a784 1
/* Fast block X0R */
d788 1
a788 1
	u_int32_t *xa = a, *xb = b;
d795 1
d822 1
a822 1
		xorbuf = malloc(strip_size, M_DEVBUF, M_ZERO);
d858 14
@


1.3
log
@KNF and wrap at 80 columns.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raidp.c,v 1.1 2009/06/10 03:24:02 marco Exp $ */
d58 1
a58 1
	    void *, int, void *);
d339 1
a339 1
	daddr64_t		strip_size, no_chunk, lba, strip_row;
d359 1
a359 1
	if (!(xs->flags & SCSI_DATA_IN))
a368 1
		strip_row = strip_no / no_chunk;
d370 3
d390 1
a390 1
		lba = (strip_row * strip_size + strip_offs) >> DEV_BSHIFT;
d394 2
a395 4
			wu->swu_blk_start = (strip_row * strip_size) >>
			    DEV_BSHIFT;
		wu->swu_blk_end = wu->swu_blk_start +
		    ((no_chunk * strip_size) >> DEV_BSHIFT) - 1;
d408 1
a408 1
				    data, xs->flags, NULL))
d429 1
a429 1
						    data))
d454 1
a454 1
			    SCSI_DATA_IN, xorbuf) ||	/* xor old data */
d456 1
a456 1
			    SCSI_DATA_IN, xorbuf) ||	/* xor old parity */
d458 1
a458 1
			    xs->flags, NULL) ||		/* write new data */
d460 1
a460 1
			    xs->flags, NULL))		/* write new parity */
d472 3
a516 1
	caddr_t			bs, xbs, xbe;
d560 2
a561 4
	if (xs) {
		bs = ccb->ccb_buf.b_data;
		xbs = (caddr_t)xs->data;
		xbe = xbs + xs->datalen;
a562 8
		if (!(xbs <= bs && bs < xbe)) {
			/*
			 * Check if buffer is within XS data.. if not it is
			 * allocated bufa/bufb/xordata.
			 */
			free(ccb->ccb_buf.b_data, M_DEVBUF);
		}
	}
d686 1
a686 1
    void *data, int flag, void *xorbuf)
d704 1
d719 1
a719 1
	ccb->ccb_buf.b_blkno = (SR_META_OFFSET + SR_META_SIZE) + blk;
d807 2
a808 1
				    NULL, SCSI_DATA_IN, xorbuf);
d811 1
a811 1
		    SCSI_DATA_OUT, NULL);
@


1.2
log
@Added working support for raid4/raid5 softraid
Newfs is working but still debugging code exists
softraid_raidp is still disabled
ok marco@@
@
text
@d57 2
a58 1
int	sr_raidp_addio(struct sr_workunit *wu, int, daddr64_t, daddr64_t, void *, int, void *);
d321 2
a322 3
		panic("%s: %s: invalid volume state transition "
		    "%d -> %d\n", DEVNAME(sd->sd_sc),
		    sd->sd_meta->ssd_devname,
d382 2
a383 1
			parity = no_chunk - ((strip_no / no_chunk) % (no_chunk + 1));
d392 4
a395 2
			wu->swu_blk_start = (strip_row * strip_size) >> DEV_BSHIFT;
		wu->swu_blk_end = wu->swu_blk_start + ((no_chunk * strip_size) >> DEV_BSHIFT) - 1;
d397 3
a399 1
		printf("    : strip=%llx offs=%llx lba=%llx len=%llx n=%lld, p=%lld\n", strip_no, strip_offs, lba, length, chunk, parity);
d407 2
a408 1
				if (sr_raidp_addio(wu, chunk, lba, length, data, xs->flags, NULL))
d414 6
a419 2
				/* XXX: only works if this LBA has already been scrubbed */
				printf("Disk %llx offline, regenerating buffer\n", chunk);
d421 5
a425 2
				for (i=0; i<= no_chunk; i++) {
					/* Read all other drives: xor result into databuffer */
d427 3
a429 1
						if (sr_raidp_addio(wu, i, lba, length, NULL, SCSI_DATA_IN, data))
d435 2
a436 1
				printf("%s: is offline, can't read\n", DEVNAME(sd->sd_sc));
d439 1
a439 2
		}
		else {
d444 6
a449 3
			/* Initialize XORBUF with contents of new data to be written
			 *   This will be XORed with old data and old parity in the intr routine
			 *   The result in xorbuf is the new parity data */
d453 8
a460 4
			if (sr_raidp_addio(wu, chunk,  lba, length, NULL, SCSI_DATA_IN, xorbuf) ||  /* xor old data */
			    sr_raidp_addio(wu, parity, lba, length, NULL, SCSI_DATA_IN, xorbuf) ||  /* xor old parity */
			    sr_raidp_addio(wu_w, chunk,  lba, length, data,   xs->flags, NULL) || /* write new data */
			    sr_raidp_addio(wu_w, parity, lba, length, xorbuf, xs->flags, NULL))   /* write new parity */
d552 2
a553 1
			sr_raidp_xor(ccb->ccb_opaque, ccb->ccb_buf.b_data, ccb->ccb_buf.b_bcount);
d564 4
a567 1
			/* Check if buffer is within XS data.. if not it is allocated bufa/bufb/xordata */
d693 2
a694 1
sr_raidp_addio(struct sr_workunit *wu, int dsk, daddr64_t blk, daddr64_t len, void *data, int flag, void *xorbuf)
d715 1
a715 2
	}
	else {
d759 3
a761 3
	for (i=0; i<len; i+=16) {
		for (j=0; j<16; j++) 
			printf("%.2x ", b[i+j]);
d763 3
a765 3
		for (j=0; j<16; j++) {
			c = b[i+j];
			if (c < ' ' || c > 'z' || i+j > len)
d787 2
a788 1
	daddr64_t strip_no, strip_size, no_chunk, parity, max_strip, strip_bits, i;
d803 1
a803 1
	for (strip_no=0; strip_no<max_strip; strip_no++) {
d807 2
a808 1
			parity = no_chunk - ((strip_no / no_chunk) % (no_chunk + 1));
d811 1
a811 1
		for (i=0; i<=no_chunk; i++) {
d813 2
a814 1
				sr_raidp_addio(wu_r, i, 0xBADCAFE, strip_size, NULL, SCSI_DATA_IN, xorbuf);
d816 2
a817 1
		sr_raidp_addio(wu_w, parity, 0xBADCAFE, strip_size, xorbuf, SCSI_DATA_OUT, NULL);
@


1.1
log
@Add framework for raid 4 & 5 so that we can work in tree.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d56 5
d102 6
d333 1
a333 1
#if 0
a335 5
#endif
	int			s;
	daddr64_t		blk;
#if 0
	struct sr_ccb		*ccb;
d337 6
a342 2
	int			ios, x, i, s, rt;
#endif
d347 7
a353 2
	/* calculate physical block */
	blk += SR_META_SIZE + SR_META_OFFSET;
a354 2
	/* XXX replace this with raid 4 & 5! */
	goto bad;
d356 7
a362 13
	if (xs->flags & SCSI_DATA_IN)
		ios = 1;
	else
		ios = sd->sd_meta->ssdi.ssd_chunk_no;
	wu->swu_io_count = ios;

	for (i = 0; i < ios; i++) {
		ccb = sr_ccb_get(sd);
		if (!ccb) {
			/* should never happen but handle more gracefully */
			printf("%s: %s: too many ccbs queued\n",
			    DEVNAME(sd->sd_sc),
			    sd->sd_meta->ssd_devname);
d366 31
a396 18
		if (xs->flags & SCSI_POLL) {
			ccb->ccb_buf.b_flags = 0;
			ccb->ccb_buf.b_iodone = NULL;
		} else {
			ccb->ccb_buf.b_flags = B_CALL;
			ccb->ccb_buf.b_iodone = sr_raidp_intr;
		}

		ccb->ccb_buf.b_flags |= B_PHYS;
		ccb->ccb_buf.b_blkno = blk;
		ccb->ccb_buf.b_bcount = xs->datalen;
		ccb->ccb_buf.b_bufsize = xs->datalen;
		ccb->ccb_buf.b_resid = xs->datalen;
		ccb->ccb_buf.b_data = xs->data;
		ccb->ccb_buf.b_error = 0;
		ccb->ccb_buf.b_proc = curproc;
		ccb->ccb_wu = wu;

a397 6
			rt = 0;
ragain:
			/* interleave reads */
			x = sd->mds.mdd_raidp.sr1_counter++ %
			    sd->sd_meta->ssdi.ssd_chunk_no;
			scp = sd->sd_vol.sv_chunks[x];
d401 3
a403 1
				ccb->ccb_buf.b_flags |= B_READ;
a404 1

d408 11
a418 4
				if (rt++ < sd->sd_meta->ssdi.ssd_chunk_no)
					goto ragain;

				/* FALLTHROUGH */
d420 1
a420 4
				/* volume offline */
				printf("%s: is offline, can't read\n",
				    DEVNAME(sd->sd_sc));
				sr_ccb_put(ccb);
d423 5
a427 16
		} else {
			/* writes go on all working disks */
			x = i;
			scp = sd->sd_vol.sv_chunks[x];
			switch (scp->src_meta.scm_status) {
			case BIOC_SDONLINE:
			case BIOC_SDSCRUB:
			case BIOC_SDREBUILD:
				ccb->ccb_buf.b_flags |= B_WRITE;
				break;

			case BIOC_SDHOTSPARE: /* should never happen */
			case BIOC_SDOFFLINE:
				wu->swu_io_count--;
				sr_ccb_put(ccb);
				continue;
d429 10
a438 1
			default:
d440 1
a440 1
			}
d442 4
a445 14
		}
		ccb->ccb_target = x;
		ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[x]->src_dev_mm;
		ccb->ccb_buf.b_vp = NULL;

		LIST_INIT(&ccb->ccb_buf.b_dep);

		TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);

		DNPRINTF(SR_D_DIS, "%s: %s: sr_raidp: b_bcount: %d "
		    "b_blkno: %x b_flags 0x%0x b_data %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
		    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
		    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);
a446 1
#endif
d448 6
d467 2
a468 1
	if (sr_check_io_collision(wu))
d470 1
d479 2
d492 1
d503 9
d517 1
d528 16
d573 5
a577 3
		xs->error = XS_NOERROR;
		xs->resid = 0;
		xs->flags |= ITSDONE;
d614 2
a615 1
			scsi_done(xs);
d664 150
@

