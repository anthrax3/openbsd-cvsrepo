head	1.79;
access;
symbols
	OPENBSD_5_9:1.77.0.2
	OPENBSD_5_9_BASE:1.77
	OPENBSD_5_8:1.75.0.4
	OPENBSD_5_8_BASE:1.75
	OPENBSD_5_7:1.74.0.4
	OPENBSD_5_7_BASE:1.74
	OPENBSD_5_6:1.71.0.4
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.63.0.10
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.63.0.6
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.63.0.4
	OPENBSD_5_3_BASE:1.63
	OPENBSD_5_2:1.63.0.2
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.2
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.53.0.4
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.49.0.6
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.2
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.47.0.4
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.44.0.2
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.43.0.2
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.29
	SMP:1.28.0.4
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	UBC_SYNC_B:1.24
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	UBC:1.5.0.2;
locks; strict;
comment	@ * @;


1.79
date	2016.04.25.20.00.33;	author tedu;	state dead;
branches;
next	1.78;
commitid	MLNYUlvoOtU8VX0s;

1.78
date	2016.03.01.16.43.08;	author naddy;	state Exp;
branches;
next	1.77;
commitid	EkPO5hcDLACEBw66;

1.77
date	2015.09.08.11.58.58;	author deraadt;	state Exp;
branches;
next	1.76;
commitid	0sUWn2kvvIbRxEXQ;

1.76
date	2015.08.27.06.16.41;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	4y6KXwep91G3uIQC;

1.75
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.74;
commitid	p4LJxGKbi0BU2cG6;

1.74
date	2015.02.10.22.03.11;	author miod;	state Exp;
branches;
next	1.73;
commitid	mPS0lsN3kaFpVud4;

1.73
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.72;
commitid	C5iGb36LQxjM60Q3;

1.72
date	2015.01.19.18.37.19;	author deraadt;	state Exp;
branches;
next	1.71;
commitid	P40vqA9nKc2St0w6;

1.71
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	JtO5uXxVcnZfhUkR;

1.70
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.69;
commitid	OBNa5kfxQ2UXoiIw;

1.69
date	2014.06.17.03.49.03;	author guenther;	state Exp;
branches;
next	1.68;
commitid	AikEp0WofcvLqv0P;

1.68
date	2014.06.15.20.22.12;	author matthew;	state Exp;
branches;
next	1.67;
commitid	oIdPvEwwyHzbpjaN;

1.67
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.66;

1.66
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.65;

1.65
date	2014.03.27.04.38.40;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.62;

1.62
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2012.02.15.04.26.27;	author guenther;	state Exp;
branches;
next	1.60;

1.60
date	2011.09.18.23.24.14;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2011.06.24.22.48.36;	author djm;	state Exp;
branches;
next	1.56;

1.56
date	2011.06.23.16.02.33;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2011.06.22.01.32.16;	author djm;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.02.17.04.35;	author guenther;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.21.18.44.01;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2009.07.09.22.29.55;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2008.11.09.05.13.53;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.12.12.27.27;	author blambert;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.05.07.33.37;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.11.13.39.33;	author gilles;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.10.19.49.31;	author gilles;	state Exp;
branches;
next	1.44;

1.44
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2006.10.06.05.47.27;	author djm;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.28.17.06.38;	author pedro;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2006.05.23.22.28.22;	author alek;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.11.21.30.30;	author miod;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2005.11.19.02.18.00;	author pedro;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.17.22.11.34;	author millert;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2004.11.07.20.39.31;	author marius;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.07.07.31.40;	author marius;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.23.05.16.35;	author marius;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.21.05.24.40;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.08.16.30.01;	author sturm;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.15.20.32.16;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.16.06.36.40;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.28.12.40.01;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.20.22.03.31;	author art;	state Exp;
branches
	1.28.4.1;
next	1.27;

1.27
date	2002.12.12.08.36.05;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2002.12.04.17.37.39;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.10.04.34.56;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.25.23.22.58;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.16.15.01.08;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.09.03.51.49;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.28.03.38.35;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.07.21.22.55;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.30.15.53.36;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.30.04.28.05;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.24.21.45.55;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.23.18.01.39;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.22.04.02.39;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.21.00.23.00;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.21.00.18.57;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.20.00.03.37;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.19.07.50.42;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.19.07.43.22;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.19.07.39.49;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.13.08.13.54;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.12.12.20.35;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.21.15.07.04;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.10.21.26.34;	author espie;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.06.10.19.15.06;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.19.21.44.02;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.18.00.16.00;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.16.16.16.52;	author provos;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;

1.28.4.1
date	2003.05.13.19.34.56;	author ho;	state Exp;
branches;
next	1.28.4.2;

1.28.4.2
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	;

1.38.2.1
date	2006.10.06.05.53.37;	author brad;	state Exp;
branches;
next	;

1.40.2.1
date	2006.10.06.05.51.12;	author brad;	state Exp;
branches;
next	;

1.42.2.1
date	2006.11.01.20.03.35;	author brad;	state Exp;
branches;
next	;


desc
@@


1.79
log
@boom goes the dynamite
@
text
@/*	$OpenBSD: systrace.c,v 1.78 2016/03/01 16:43:08 naddy Exp $	*/
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/tree.h>
#include <sys/malloc.h>
#include <sys/syscall.h>
#include <sys/vnode.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/filio.h>
#include <sys/signalvar.h>
#include <sys/rwlock.h>
#include <sys/pool.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/poll.h>
#include <sys/ptrace.h>

#include <sys/exec.h>
#include <uvm/uvm_extern.h>

#include <dev/systrace.h>

void	systraceattach(int);

int	systraceopen(dev_t, int, int, struct proc *);
int	systraceclose(dev_t, int, int, struct proc *);
int	systraceioctl(dev_t, u_long, caddr_t, int, struct proc *);

int	systracef_read(struct file *, off_t *, struct uio *, struct ucred *);
int	systracef_write(struct file *, off_t *, struct uio *, struct ucred *);
int	systracef_ioctl(struct file *, u_long, caddr_t, struct proc *p);
int	systracef_poll(struct file *, int, struct proc *);
int	systracef_kqfilter(struct file *, struct knote *);
int	systracef_stat(struct file *, struct stat *, struct proc *);
int	systracef_close(struct file *, struct proc *);

struct str_policy {
	TAILQ_ENTRY(str_policy) next;

	int nr;

	struct emul *emul;	/* Is only valid for this emulation */

	int refcount;

	int nsysent;
	u_char *sysent;
};

struct str_inject {
	caddr_t kaddr;
	caddr_t uaddr;
	size_t  len;
};

#define STR_PROC_ONQUEUE	0x01
#define STR_PROC_WAITANSWER	0x02
#define STR_PROC_SYSCALLRES	0x04
#define STR_PROC_REPORT		0x08	/* Report emulation */
#define STR_PROC_NEEDSEQNR	0x10	/* Answer must quote seqnr */
#define STR_PROC_SETEUID	0x20	/* Elevate privileges */
#define STR_PROC_SETEGID	0x40

struct str_process {
	TAILQ_ENTRY(str_process) next;
	TAILQ_ENTRY(str_process) msg_next;
	struct str_process *firstmsg;

	struct proc *proc;
	pid_t pid;

	struct fsystrace *parent;
	struct str_policy *policy;

	struct systrace_replace *replace;
	char *fname[SYSTR_MAXFNAME];
	size_t nfname;

	int flags;
	short answer;
	short error;
	u_int16_t seqnr;	/* expected reply sequence number */

	uid_t seteuid;
	gid_t setegid;

	int isscript;
	char scriptname[MAXPATHLEN];

	struct str_message msg;

	caddr_t sg;
	struct str_inject injects[SYSTR_MAXINJECTS];
	int  injectind;
};

struct rwlock systrace_lck;

static __inline void
systrace_lock(void)
{
	rw_enter_write(&systrace_lck);
}

static __inline void
systrace_unlock(void)
{
	rw_exit_write(&systrace_lck);
}

/* Needs to be called with fst locked */

int	systrace_attach(struct fsystrace *, pid_t);
int	systrace_detach(struct str_process *);
int	systrace_answer(struct str_process *, struct systrace_answer *);
int     systrace_setscriptname(struct str_process *,
	    struct systrace_scriptname *);
int     systrace_prepinject(struct str_process *, struct systrace_inject *);
int     systrace_inject(struct str_process *, int);
int	systrace_io(struct str_process *, struct systrace_io *);
int	systrace_policy(struct fsystrace *, struct systrace_policy *);
int	systrace_preprepl(struct str_process *, struct systrace_replace *);
int	systrace_replace(struct str_process *, size_t, register_t []);
int	systrace_getcwd(struct fsystrace *, struct str_process *, int);
int	systrace_restorecwd(struct fsystrace *, struct proc *);
int	systrace_fname(struct str_process *, caddr_t, size_t);
void	systrace_replacefree(struct str_process *);

int	systrace_processready(struct str_process *);
struct proc *systrace_find(struct str_process *);
struct str_process *systrace_findpid(struct fsystrace *fst, pid_t pid);
void	systrace_wakeup(struct fsystrace *);
void	systrace_closepolicy(struct fsystrace *, struct str_policy *);
void	systrace_insert_process(struct fsystrace *, struct proc *,
	    struct str_process *);
struct str_policy *systrace_newpolicy(struct fsystrace *, int);
int	systrace_msg_child(struct fsystrace *, struct str_process *, pid_t);
int	systrace_msg_policyfree(struct fsystrace *, struct str_policy *);
int	systrace_msg_ask(struct fsystrace *, struct str_process *,
	    int, size_t, register_t []);
int	systrace_msg_result(struct fsystrace *, struct str_process *,
	    int, int, size_t, register_t [], register_t []);
int	systrace_msg_emul(struct fsystrace *, struct str_process *);
int	systrace_msg_ugid(struct fsystrace *, struct str_process *);
int	systrace_make_msg(struct str_process *, int);

static struct fileops systracefops = {
	systracef_read,
	systracef_write,
	systracef_ioctl,
	systracef_poll,
	systracef_kqfilter,
	systracef_stat,
	systracef_close
};

struct pool systr_proc_pl;
struct pool systr_policy_pl;

int systrace_debug = 0;

#define DPRINTF(y)	if (systrace_debug) printf y;

/* ARGSUSED */
int
systracef_read(struct file *fp, off_t *poff, struct uio *uio,
    struct ucred *cred)
{
	struct fsystrace *fst = (struct fsystrace *)fp->f_data;
	struct str_process *process;
	int error = 0;

	if (uio->uio_resid != sizeof(struct str_message))
		return (EINVAL);

 again:
	systrace_lock();
	rw_enter_write(&fst->lock);
	systrace_unlock();
	if ((process = TAILQ_FIRST(&fst->messages)) != NULL) {
		error = uiomove((caddr_t)&process->msg,
		    sizeof(struct str_message), uio);
		if (!error) {
			TAILQ_REMOVE(&fst->messages, process, msg_next);
			CLR(process->flags, STR_PROC_ONQUEUE);

			if (SYSTR_MSG_NOPROCESS(process))
				pool_put(&systr_proc_pl, process);

		}
	} else if (TAILQ_FIRST(&fst->processes) == NULL) {
		/* EOF situation */
		;
	} else {
		if (fp->f_flag & FNONBLOCK)
			error = EAGAIN;
		else {
			rw_exit_write(&fst->lock);
			error = tsleep(fst, PWAIT|PCATCH, "systrrd", 0);
			if (error)
				goto out;
			goto again;
		}

	}

	rw_exit_write(&fst->lock);
 out:
	return (error);
}

/* ARGSUSED */
int
systracef_write(struct file *fp, off_t *poff, struct uio *uio,
    struct ucred *cred)
{
	return (EIO);
}

#define POLICY_VALID(x)	((x) == SYSTR_POLICY_PERMIT || \
			 (x) == SYSTR_POLICY_ASK || \
			 (x) == SYSTR_POLICY_NEVER || \
			 (x) == SYSTR_POLICY_KILL)

/* ARGSUSED */
int
systracef_ioctl(struct file *fp, u_long cmd, caddr_t data, struct proc *p)
{
	int ret = 0;
	struct fsystrace *fst = (struct fsystrace *)fp->f_data;
	struct str_process *strp;
	pid_t pid = 0;
	int atfd = -1;

	switch (cmd) {
	case FIONBIO:
	case FIOASYNC:
		return (0);

	case STRIOCDETACH:
	case STRIOCREPORT:
		pid = *(pid_t *)data;
		if (!pid)
			ret = EINVAL;
		break;
	case STRIOCANSWER:
		pid = ((struct systrace_answer *)data)->stra_pid;
		if (!pid)
			ret = EINVAL;
		break;
	case STRIOCIO:
		pid = ((struct systrace_io *)data)->strio_pid;
		if (!pid)
			ret = EINVAL;
		break;
	case STRIOCSCRIPTNAME:
		pid = ((struct systrace_scriptname *)data)->sn_pid;
		if (!pid)
			ret = EINVAL;
		break;
	case STRIOCINJECT:
		pid = ((struct systrace_inject *)data)->stri_pid;
		if (!pid)
			ret = EINVAL;
		break;
	case STRIOCGETCWD: {
		struct systrace_getcwd *gd = (struct systrace_getcwd *)data;
		pid = gd->strgd_pid;
		if (!pid)
			ret = EINVAL;
		atfd = gd->strgd_atfd;
		break;
	}
	case STRIOCATTACH:
	case STRIOCRESCWD:
	case STRIOCPOLICY:
		break;
	case STRIOCREPLACE:
		pid = ((struct systrace_replace *)data)->strr_pid;
		if (!pid)
			ret = EINVAL;
		break;
	default:
		ret = ENOTTY;
		break;
	}

	if (ret)
		return (ret);

	systrace_lock();
	rw_enter_write(&fst->lock);
	systrace_unlock();
	if (pid) {
		strp = systrace_findpid(fst, pid);
		if (strp == NULL) {
			ret = ESRCH;
			goto unlock;
		}
	}

	switch (cmd) {
	case STRIOCATTACH:
		pid = *(pid_t *)data;
		if (!pid)
			ret = EINVAL;
		else
			ret = systrace_attach(fst, pid);
		DPRINTF(("%s: attach to %u: %d\n", __func__, pid, ret));
		break;
	case STRIOCDETACH:
		ret = systrace_detach(strp);
		break;
	case STRIOCREPORT:
		SET(strp->flags, STR_PROC_REPORT);
		break;
	case STRIOCANSWER:
		ret = systrace_answer(strp, (struct systrace_answer *)data);
		break;
	case STRIOCIO:
		ret = systrace_io(strp, (struct systrace_io *)data);
		break;
	case STRIOCSCRIPTNAME:
		ret = systrace_setscriptname(strp,
		    (struct systrace_scriptname *)data);
		break;
	case STRIOCINJECT:
		ret = systrace_prepinject(strp, (struct systrace_inject *)data);
		break;
	case STRIOCPOLICY:
		ret = systrace_policy(fst, (struct systrace_policy *)data);
		break;
	case STRIOCREPLACE:
		ret = systrace_preprepl(strp, (struct systrace_replace *)data);
		break;
	case STRIOCRESCWD:
		ret = systrace_restorecwd(fst, p);
		break;
	case STRIOCGETCWD:
		ret = systrace_getcwd(fst, strp, atfd);
		break;
	default:
		ret = ENOTTY;
		break;
	}

 unlock:
	rw_exit_write(&fst->lock);
	return (ret);
}

/* ARGSUSED */
int
systracef_poll(struct file *fp, int events, struct proc *p)
{
	struct fsystrace *fst = (struct fsystrace *)fp->f_data;
	int revents = 0;

	if ((events & (POLLIN | POLLRDNORM)) == 0)
		return (0);

	systrace_lock();
	rw_enter_write(&fst->lock);
	systrace_unlock();
	if (!TAILQ_EMPTY(&fst->messages))
		revents = events & (POLLIN | POLLRDNORM);
	else
		selrecord(p, &fst->si);
	rw_exit_write(&fst->lock);

	return (revents);
}

/* ARGSUSED */
int
systracef_kqfilter(struct file *fp, struct knote *kn)
{
	return (1);
}

/* ARGSUSED */
int
systracef_stat(struct file *fp, struct stat *sb, struct proc *p)
{
	return (EOPNOTSUPP);
}

/* ARGSUSED */
int
systracef_close(struct file *fp, struct proc *p)
{
	struct fsystrace *fst = (struct fsystrace *)fp->f_data;
	struct str_process *strp;
	struct str_policy *strpol;

	systrace_lock();
	rw_enter_write(&fst->lock);
	systrace_unlock();

	/* Untrace all processes */
	for (strp = TAILQ_FIRST(&fst->processes); strp;
	    strp = TAILQ_FIRST(&fst->processes)) {
		struct proc *q = strp->proc;

		systrace_detach(strp);
		psignal(q, SIGKILL);
	}

	/* Clean up fork and exit messages */
	for (strp = TAILQ_FIRST(&fst->messages); strp;
	    strp = TAILQ_FIRST(&fst->messages)) {
		TAILQ_REMOVE(&fst->messages, strp, msg_next);
		pool_put(&systr_proc_pl, strp);
	}

	/* Clean up all policies */
	for (strpol = TAILQ_FIRST(&fst->policies); strpol;
	    strpol = TAILQ_FIRST(&fst->policies))
		systrace_closepolicy(fst, strpol);

	/* Release vnodes */
	if (fst->fd_cdir)
		vrele(fst->fd_cdir);
	if (fst->fd_rdir)
		vrele(fst->fd_rdir);
	rw_exit_write(&fst->lock);

	free(fp->f_data, M_XDATA, sizeof(struct fsystrace));
	fp->f_data = NULL;

	return (0);
}

void
systraceattach(int n)
{
	pool_init(&systr_proc_pl, sizeof(struct str_process), 0, 0, 0,
	    "strprocpl", NULL);
	pool_init(&systr_policy_pl, sizeof(struct str_policy), 0, 0, 0,
	    "strpolpl", NULL);
	rw_init(&systrace_lck, "systrace");
}

int
systraceopen(dev_t dev, int flag, int mode, struct proc *p)
{
	return (0);
}

int
systraceclose(dev_t dev, int flag, int mode, struct proc *p)
{
	return (0);
}

int
systraceioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct file *f;
	struct fsystrace *fst = NULL;
	int fd, error;

	switch (cmd) {
	case STRIOCCLONE:
		fst = (struct fsystrace *)malloc(sizeof(*fst),
		    M_XDATA, M_WAITOK | M_ZERO);
		rw_init(&fst->lock, "systrace");
		TAILQ_INIT(&fst->processes);
		TAILQ_INIT(&fst->messages);
		TAILQ_INIT(&fst->policies);

		if (suser(p, 0) == 0)
			fst->issuser = 1;
		fst->p_ruid = p->p_ucred->cr_ruid;
		fst->p_rgid = p->p_ucred->cr_rgid;

		fdplock(p->p_fd);
		error = falloc(p, &f, &fd);
		fdpunlock(p->p_fd);
		if (error) {
			free(fst, M_XDATA, sizeof(*fst));
			return (error);
		}
		f->f_flag = FREAD | FWRITE;
		f->f_type = DTYPE_SYSTRACE;
		f->f_ops = &systracefops;
		f->f_data = (caddr_t) fst;
		*(int *)data = fd;
		FILE_SET_MATURE(f, p);
		break;
	default:
		error = EINVAL;
		break;
	}
	return (error);
}

void
systrace_wakeup(struct fsystrace *fst)
{
	wakeup((caddr_t)fst);
	selwakeup(&fst->si);
}

struct proc *
systrace_find(struct str_process *strp)
{
	struct proc *proc;

	if ((proc = pfind(strp->pid)) == NULL)
		return (NULL);

	if (proc != strp->proc)
		return (NULL);

	if (!ISSET(proc->p_flag, P_SYSTRACE))
		return (NULL);

	return (proc);
}

void
systrace_exit(struct proc *proc)
{
	struct str_process *strp;
	struct fsystrace *fst;

	systrace_lock();
	strp = proc->p_systrace;
	if (strp != NULL) {
		fst = strp->parent;
		rw_enter_write(&fst->lock);
		systrace_unlock();

		/* Insert Exit message */
		systrace_msg_child(fst, strp, -1);

		systrace_detach(strp);
		proc->p_systrace = NULL;
		rw_exit_write(&fst->lock);
	} else
		systrace_unlock();
	atomic_clearbits_int(&proc->p_flag, P_SYSTRACE);
}

struct str_process *
systrace_getproc(void)
{
	struct str_process *newstrp;

	newstrp = pool_get(&systr_proc_pl, PR_WAITOK|PR_ZERO);
	newstrp->firstmsg = pool_get(&systr_proc_pl, PR_WAITOK|PR_ZERO);
	return (newstrp);
}

void
systrace_freeproc(struct str_process *strp)
{
	if (strp->firstmsg)
		pool_put(&systr_proc_pl, strp->firstmsg);
	pool_put(&systr_proc_pl, strp);
}

void
systrace_fork(struct proc *oldproc, struct proc *p, struct str_process *newstrp)
{
	struct str_process *oldstrp, *strp;
	struct fsystrace *fst;

	systrace_lock();
	oldstrp = oldproc->p_systrace;
	if (oldstrp == NULL) {
		systrace_unlock();
		systrace_freeproc(newstrp);
		return;
	}

	fst = oldstrp->parent;
	rw_enter_write(&fst->lock);
	systrace_unlock();

	systrace_insert_process(fst, p, newstrp);
	if ((strp = systrace_findpid(fst, p->p_pid)) == NULL)
		panic("systrace_fork");

	/* Reference policy */
	if ((strp->policy = oldstrp->policy) != NULL)
		strp->policy->refcount++;

	/* Insert fork message */
	systrace_msg_child(fst, oldstrp, p->p_pid);
	rw_exit_write(&fst->lock);
}

#define REACQUIRE_LOCK	do { \
	systrace_lock(); \
	strp = p->p_systrace; \
	if (strp == NULL) { \
		systrace_unlock(); \
		return (error); \
	} \
	fst = strp->parent; \
	rw_enter_write(&fst->lock); \
	systrace_unlock(); \
} while (0)

int
systrace_redirect(int code, struct proc *p, void *v, register_t *retval)
{
	struct process *pr = p->p_p;
	struct sysent *callp;
	struct str_process *strp;
	struct str_policy *strpolicy;
	struct fsystrace *fst = NULL;
	struct emul *oldemul;
	int policy, error = 0, report = 0, maycontrol = 0, issuser = 0;
	uid_t old_ruid = p->p_ucred->cr_ruid;
	gid_t old_rgid = p->p_ucred->cr_rgid;

	systrace_lock();
	strp = p->p_systrace;
	if (strp == NULL) {
		systrace_unlock();
		return (EINVAL);
	}

	if (code < 0 || code >= pr->ps_emul->e_nsysent) {
		systrace_unlock();
		return (EINVAL);
	}

	KASSERT(strp->proc == p);

	fst = strp->parent;

	rw_enter_write(&fst->lock);
	systrace_unlock();

	/*
	 * We can not monitor a SUID process unless we are root,
	 * but we wait until it executes something unprivileged.
	 * A non-root user may only monitor if the real uid and
	 * real gid match the monitored process.  Changing the
	 * uid or gid causes PS_SUGID to be set.
	 */
	if (fst->issuser) {
		maycontrol = 1;
		issuser = 1;
	} else if (!ISSET(pr->ps_flags, PS_SUGID | PS_SUGIDEXEC)) {
		maycontrol = fst->p_ruid == old_ruid &&
		    fst->p_rgid == old_rgid;
	}

	if (!maycontrol) {
		policy = SYSTR_POLICY_PERMIT;
	} else {
		/* Find out current policy */
		if ((strpolicy = strp->policy) == NULL)
			policy = SYSTR_POLICY_ASK;
		else {
			if (code >= strpolicy->nsysent)
				policy = SYSTR_POLICY_NEVER;
			else
				policy = strpolicy->sysent[code];
		}
	}

	callp = pr->ps_emul->e_sysent + code;

	/* Fast-path */
	if (policy != SYSTR_POLICY_ASK) {
		if (policy != SYSTR_POLICY_PERMIT &&
		    policy != SYSTR_POLICY_KILL) {
			if (policy > 0)
				error = policy;
			else
				error = EPERM;
		}
		systrace_replacefree(strp);
		rw_exit_write(&fst->lock);
		if (policy == SYSTR_POLICY_KILL) {
			error = EPERM;
			DPRINTF(("systrace: pid %u killed on syscall %d\n",
			    pr->ps_pid, code));
			psignal(p, SIGKILL);
		} else if (policy == SYSTR_POLICY_PERMIT)
			error = (*callp->sy_call)(p, v, retval);
		return (error);
	}

	/*
	 * Reset our stackgap allocation.  Note that when resetting
	 * the stackgap allocation, we expect to get the same address
	 * base; i.e. that stackgap_init() is idempotent.
	 */
	systrace_inject(strp, 0 /* Just reset internal state */);
	strp->sg = stackgap_init(p);

	/* Puts the current process to sleep, return unlocked */
	error = systrace_msg_ask(fst, strp, code, callp->sy_argsize, v);
	/* lock has been released in systrace_msg_ask() */

	if (error)
		return (error);

	/* We might have detached by now for some reason */
	systrace_lock();
	if ((strp = p->p_systrace) == NULL) {
		systrace_unlock();
		return (error);
	}

	fst = strp->parent;
	rw_enter_write(&fst->lock);
	systrace_unlock();

	if (strp->answer == SYSTR_POLICY_NEVER) {
		error = strp->error;
		systrace_replacefree(strp);
		goto out_unlock;
	}

	if (ISSET(strp->flags, STR_PROC_SYSCALLRES)) {
		CLR(strp->flags, STR_PROC_SYSCALLRES);
		report = 1;
	}

	error = systrace_inject(strp, 1/* Perform copies */);
	/* Replace the arguments if necessary */
	if (!error && strp->replace != NULL)
		error = systrace_replace(strp, callp->sy_argsize, v);
	if (error)
		goto out_unlock;

	oldemul = pr->ps_emul;
		
	/* Elevate privileges as desired */
	if (issuser && ISSET(strp->flags, STR_PROC_SETEUID|STR_PROC_SETEGID)) {
		struct ucred *uc, *newcred;

		uc = p->p_ucred;
		newcred = NULL;
		if (ISSET(strp->flags, STR_PROC_SETEUID) &&
		    uc->cr_uid != strp->seteuid) {
			newcred = crdup(uc);
			newcred->cr_uid = strp->seteuid;
		}
		if (ISSET(strp->flags, STR_PROC_SETEGID) &&
		    uc->cr_gid != strp->setegid) {
			if (newcred == NULL)
				newcred = crdup(uc);
			newcred->cr_gid = strp->setegid;
		}
		if (newcred != NULL) {
			p->p_ucred = newcred;
			crfree(uc);
			atomic_setbits_int(&pr->ps_flags, PS_SUGID);
		}
	}

	rw_exit_write(&fst->lock);
				
	error = (*callp->sy_call)(p, v, retval);

	/* reset the credentials on the thread */
	refreshcreds(p);

	/* Return to old privileges */
	systrace_lock();
	if ((strp = p->p_systrace) == NULL) {
		systrace_unlock();
		return (error);
	}

	systrace_replacefree(strp);

	if (ISSET(pr->ps_flags, PS_SUGID | PS_SUGIDEXEC)) {
		if ((fst = strp->parent) == NULL || !fst->issuser) {
			systrace_unlock();
			return (error);
		}
	}

	/* Report change in emulation */

	/* See if we should force a report */
	if (ISSET(strp->flags, STR_PROC_REPORT)) {
		CLR(strp->flags, STR_PROC_REPORT);
		oldemul = NULL;
	}

	/* Acquire lock */
	fst = strp->parent;
	rw_enter_write(&fst->lock);
	systrace_unlock();

	if (pr->ps_emul != oldemul) {
		/* Old policy is without meaning now */
		if (strp->policy) {
			systrace_closepolicy(fst, strp->policy);
			strp->policy = NULL;
		}
		systrace_msg_emul(fst, strp);

		REACQUIRE_LOCK;
	}

	/* Report if effective uid or gid changed */
	if (old_ruid != pr->ps_ucred->cr_ruid ||
	    old_rgid != pr->ps_ucred->cr_rgid) {
		systrace_msg_ugid(fst, strp);

		REACQUIRE_LOCK;
	}

	/* Report result from system call */
	if (report) {
		systrace_msg_result(fst, strp, error, code,
		    callp->sy_argsize, v, retval);

		/* not locked */
		goto out;
	}

out_unlock:
	rw_exit_write(&fst->lock);
out:
	return (error);
}

/* Called with fst locked */

int
systrace_answer(struct str_process *strp, struct systrace_answer *ans)
{
	int error = 0;

	DPRINTF(("%s: %u: policy %d\n", __func__,
	    ans->stra_pid, ans->stra_policy));

	if (!POLICY_VALID(ans->stra_policy)) {
		error = EINVAL;
		goto out;
	}

	/* Check if answer is in sync with us */
	if (ans->stra_seqnr != strp->seqnr) {
		error = ESRCH;
		goto out;
	}

	if ((error = systrace_processready(strp)) != 0)
		goto out;

	strp->answer = ans->stra_policy;
	strp->error = ans->stra_error;
	if (!strp->error)
		strp->error = EPERM;
	if (ISSET(ans->stra_flags, SYSTR_FLAGS_RESULT))
		SET(strp->flags, STR_PROC_SYSCALLRES);

	/* See if we should elevate privileges for this system call */
	if (ISSET(ans->stra_flags, SYSTR_FLAGS_SETEUID)) {
		SET(strp->flags, STR_PROC_SETEUID);
		strp->seteuid = ans->stra_seteuid;
	}
	if (ISSET(ans->stra_flags, SYSTR_FLAGS_SETEGID)) {
		SET(strp->flags, STR_PROC_SETEGID);
		strp->setegid = ans->stra_setegid;
	}

	/* Clearing the flag indicates to the process that it woke up */
	CLR(strp->flags, STR_PROC_WAITANSWER);
	wakeup(strp);
 out:

	return (error);
}

int
systrace_setscriptname(struct str_process *strp, struct systrace_scriptname *ans)
{
	strlcpy(strp->scriptname,
	    ans->sn_scriptname, sizeof(strp->scriptname));

	return (0);
}

int
systrace_inject(struct str_process *strp, int docopy)
{
	int ind, ret = 0;

	for (ind = 0; ind < strp->injectind; ind++) {
		struct str_inject *inject = &strp->injects[ind];
		if (!ret && docopy &&
		    copyout(inject->kaddr, inject->uaddr, inject->len))
			ret = EINVAL;
		free(inject->kaddr, M_XDATA, 0);
	}

	strp->injectind = 0;
	return (ret);
}

int
systrace_prepinject(struct str_process *strp, struct systrace_inject *inj)
{
	caddr_t udata, kaddr = NULL;
	int ret = 0;
	struct str_inject *inject;

	if (strp->injectind >= SYSTR_MAXINJECTS)
		return (ENOBUFS);

	udata = stackgap_alloc(&strp->sg, inj->stri_len);
	if (udata == NULL)
		return (ENOMEM);

	/*
	 * We have infact forced a maximum length on stri_len because
	 * of the stackgap.
	 */

	kaddr = malloc(inj->stri_len, M_XDATA, M_WAITOK);
	ret = copyin(inj->stri_addr, kaddr, inj->stri_len);
	if (ret) {
		free(kaddr, M_XDATA, inj->stri_len);
		return (ret);
	}

	inject = &strp->injects[strp->injectind++];
	inject->kaddr = kaddr;
	inject->uaddr = inj->stri_addr = udata;
	inject->len = inj->stri_len;

	return (0);
}

int
systrace_policy(struct fsystrace *fst, struct systrace_policy *pol)
{
	struct str_policy *strpol;
	struct str_process *strp;

	switch(pol->strp_op) {
	case SYSTR_POLICY_NEW:
		DPRINTF(("%s: new, ents %d\n", __func__,
			    pol->strp_maxents));
		if (pol->strp_maxents <= 0 || pol->strp_maxents > 1024)
			return (EINVAL);
		strpol = systrace_newpolicy(fst, pol->strp_maxents);
		if (strpol == NULL)
			return (ENOBUFS);
		pol->strp_num = strpol->nr;
		break;
	case SYSTR_POLICY_ASSIGN:
		DPRINTF(("%s: %d -> pid %d\n", __func__,
			    pol->strp_num, pol->strp_pid));

		/* Find right policy by number */
		TAILQ_FOREACH(strpol, &fst->policies, next)
		    if (strpol->nr == pol->strp_num)
			    break;
		if (strpol == NULL)
			return (EINVAL);

		strp = systrace_findpid(fst, pol->strp_pid);
		if (strp == NULL)
			return (EINVAL);

		/* Check that emulation matches */
		if (strpol->emul && strpol->emul != strp->proc->p_p->ps_emul)
			return (EINVAL);

		if (strp->policy)
			systrace_closepolicy(fst, strp->policy);
		strp->policy = strpol;

		/* LRU for policy use */
		TAILQ_REMOVE(&fst->policies, strpol, next);
		TAILQ_INSERT_TAIL(&fst->policies, strpol, next);
		strpol->refcount++;

		/* Record emulation for this policy */
		if (strpol->emul == NULL)
			strpol->emul = strp->proc->p_p->ps_emul;

		break;
	case SYSTR_POLICY_MODIFY:
		DPRINTF(("%s: %d: code %d -> policy %d\n", __func__,
		    pol->strp_num, pol->strp_code, pol->strp_policy));
		if (!POLICY_VALID(pol->strp_policy))
			return (EINVAL);
		TAILQ_FOREACH(strpol, &fst->policies, next)
		    if (strpol->nr == pol->strp_num)
			    break;
		if (strpol == NULL)
			return (EINVAL);
		if (pol->strp_code < 0 || pol->strp_code >= strpol->nsysent)
			return (EINVAL);
		strpol->sysent[pol->strp_code] = pol->strp_policy;
		break;
	default:
		return (EINVAL);
	}

	return (0);
}

int
systrace_processready(struct str_process *strp)
{
	if (ISSET(strp->flags, STR_PROC_ONQUEUE))
		return (EBUSY);

	if (!ISSET(strp->flags, STR_PROC_WAITANSWER))
		return (EBUSY);

	if (strp->proc->p_stat != SSLEEP)
		return (EBUSY);

	return (0);
}

int
systrace_getcwd(struct fsystrace *fst, struct str_process *strp, int atfd)
{
	struct filedesc *myfdp, *fdp;
	struct vnode *dvp, *odvp;
	int error;

	DPRINTF(("%s: %d\n", __func__, strp->pid));

	error = systrace_processready(strp);
	if (error)
		return (error);

	myfdp = curproc->p_fd;
	fdp = strp->proc->p_fd;
	if (myfdp == NULL || fdp == NULL)
		return (EINVAL);

	if (atfd == AT_FDCWD)
		dvp = fdp->fd_cdir;
	else {
		struct file *fp = fd_getfile(fdp, atfd);
		if (fp == NULL || fp->f_type != DTYPE_VNODE)
			return (EINVAL);
		dvp = (struct vnode *)fp->f_data;
		if (dvp->v_type != VDIR)
			return (EINVAL);
	}

	/* Is there a STRIOCGETCWD currently in effect? */
	if (fst->fd_pid == 0) {
		/* nope: just save the current values */
		fst->fd_cdir = myfdp->fd_cdir;
		fst->fd_rdir = myfdp->fd_rdir;
	} else {
		/* yep: carefully release the current values */
		odvp = myfdp->fd_rdir;
		myfdp->fd_rdir = fst->fd_rdir;
		if (odvp != NULL)
			vrele(odvp);
		odvp = myfdp->fd_cdir;
		myfdp->fd_cdir = fst->fd_cdir;
		if (odvp != NULL)
			vrele(odvp);
	}
	fst->fd_pid = strp->pid;

	if ((myfdp->fd_cdir = dvp) != NULL)
		vref(myfdp->fd_cdir);
	if ((myfdp->fd_rdir = fdp->fd_rdir) != NULL)
		vref(myfdp->fd_rdir);

	return (0);
}

int
systrace_restorecwd(struct fsystrace *fst, struct proc *p)
{
	struct filedesc *fdp;
	struct vnode *rvp, *cvp;

	if (!fst->fd_pid)
		return (EINVAL);

	fdp = p->p_fd;

	/*
	 * Restore original root and current directories and release the
	 * ones from the other process.
	 */
	rvp = fdp->fd_rdir;
	cvp = fdp->fd_cdir;
	fdp->fd_rdir = fst->fd_rdir;
	fdp->fd_cdir = fst->fd_cdir;
	fst->fd_cdir = fst->fd_rdir = NULL;
	if (rvp != NULL)
		vrele(rvp);
	if (cvp != NULL)
		vrele(cvp);

	/* Note that we are normal again */
	fst->fd_pid = 0;

	return (0);
}

int
systrace_io(struct str_process *strp, struct systrace_io *io)
{
	struct proc *p = curproc, *t = strp->proc;
	struct uio uio;
	struct iovec iov;
	int error = 0;

	DPRINTF(("%s: %u: %p(%lu)\n", __func__,
	    io->strio_pid, io->strio_offs, (u_long)io->strio_len));

	switch (io->strio_op) {
	case SYSTR_READ:
		uio.uio_rw = UIO_READ;
		break;
	case SYSTR_WRITE:
		uio.uio_rw = UIO_WRITE;
		break;
	default:
		return (EINVAL);
	}

	error = systrace_processready(strp);
	if (error)
		goto out;

	iov.iov_base = io->strio_addr;
	iov.iov_len = io->strio_len;
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)(u_long)io->strio_offs;
	uio.uio_resid = io->strio_len;
	uio.uio_segflg = UIO_USERSPACE;
	uio.uio_procp = p;

	error = process_domem(p, t, &uio, PT_WRITE_I);
	io->strio_len -= uio.uio_resid;
 out:

	return (error);
}

int
systrace_attach(struct fsystrace *fst, pid_t pid)
{
	int error = 0;
	struct proc *p = curproc;
	struct proc *t;				/* target thread */
	struct process *tr;			/* target process */
	struct str_process *newstrp;

	if ((t = pfind(pid)) == NULL || (t->p_flag & P_THREAD)) {
		error = ESRCH;
		goto out;
	}
	tr = t->p_p;

	if (ISSET(tr->ps_flags, PS_INEXEC)) {
		error = EAGAIN;
		goto out;
	}

	/*
	 * You can't attach to a process if:
	 *	(1) it's the process that's doing the attaching,
	 */
	if (tr == p->p_p) {
		error = EINVAL;
		goto out;
	}

	/*
	 *	(2) it's a system process
	 */
	if (ISSET(t->p_flag, P_SYSTEM)) {
		error = EPERM;
		goto out;
	}

	/*
	 *	(3) it's being traced already
	 */
	if (ISSET(t->p_flag, P_SYSTRACE)) {
		error = EBUSY;
		goto out;
	}

	/*
	 *	(4) it's not owned by you, or the last exec
	 *	    gave us setuid/setgid privs (unless
	 *	    you're root), or...
	 *
	 *      [Note: once PS_SUGID or PS_SUGIDEXEC gets set in execve(),
	 *      it stays set until the process does another execve(). Hence
	 *	this prevents a setuid process which revokes its
	 *	special privileges using setuid() from being
	 *	traced. This is good security.]
	 */
	if ((tr->ps_ucred->cr_ruid != p->p_ucred->cr_ruid ||
		ISSET(tr->ps_flags, PS_SUGID | PS_SUGIDEXEC)) &&
	    (error = suser(p, 0)) != 0)
		goto out;

	/*
	 *	(5) ...it's init, which controls the security level
	 *	    of the entire system, and the system was not
	 *          compiled with permanently insecure mode turned
	 *	    on.
	 */
	if ((tr->ps_pid == 1) && (securelevel > -1)) {
		error = EPERM;
		goto out;
	}

	newstrp = systrace_getproc();
	systrace_insert_process(fst, t, newstrp);

 out:
	return (error);
}

void
systrace_execve0(struct proc *p)
{  
	struct str_process *strp;

	systrace_lock();
	strp = p->p_systrace;
	strp->isscript = 0;
	systrace_unlock();
}

void
systrace_execve1(char *path, struct proc *p)
{
	struct str_process *strp;
	struct fsystrace *fst;
	struct str_msg_execve *msg_execve;

	do { 
		systrace_lock();
		strp = p->p_systrace;
		if (strp == NULL) {
			systrace_unlock();
			return;
		}

		msg_execve = &strp->msg.msg_data.msg_execve;
		fst = strp->parent;
		rw_enter_write(&fst->lock);
		systrace_unlock();

		/*
		 * susers will get the execve call anyway.  Also, if
		 * we're not allowed to control the process, escape.
		 */

		if (fst->issuser ||
		    fst->p_ruid != p->p_ucred->cr_ruid ||
		    fst->p_rgid != p->p_ucred->cr_rgid) {
			rw_exit_write(&fst->lock);
			return;
		}
		strlcpy(msg_execve->path, path, MAXPATHLEN);
	} while (systrace_make_msg(strp, SYSTR_MSG_EXECVE) != 0);
}

/* Prepare to replace arguments */

int
systrace_preprepl(struct str_process *strp, struct systrace_replace *repl)
{
	size_t len;
	int i, ret = 0;

	ret = systrace_processready(strp);
	if (ret)
		return (ret);

	if (strp->replace != NULL) {
		free(strp->replace, M_XDATA, 0);
		strp->replace = NULL;
	}

	if (repl->strr_nrepl < 0 || repl->strr_nrepl > SYSTR_MAXARGS)
		return (EINVAL);

	for (i = 0, len = 0; i < repl->strr_nrepl; i++) {
		if (repl->strr_argind[i] < 0 ||
		    repl->strr_argind[i] >= SYSTR_MAXARGS)
			return (EINVAL);
		if (repl->strr_offlen[i] == 0)
			continue;
		len += repl->strr_offlen[i];
		if (repl->strr_offlen[i] > SYSTR_MAXREPLEN ||
		    repl->strr_off[i] > SYSTR_MAXREPLEN ||
		    len > SYSTR_MAXREPLEN)
			return (EINVAL);
		if (repl->strr_offlen[i] + repl->strr_off[i] > len)
			return (EINVAL);
	}

	/* Make sure that the length adds up */
	if (repl->strr_len != len)
		return (EINVAL);

	/* Check against a maximum length */
	if (repl->strr_len > SYSTR_MAXREPLEN)
		return (EINVAL);

	strp->replace = (struct systrace_replace *)
	    malloc(sizeof(struct systrace_replace) + len, M_XDATA, M_WAITOK);

	memcpy(strp->replace, repl, sizeof(struct systrace_replace));
	ret = copyin(repl->strr_base, strp->replace + 1, len);
	if (ret) {
		free(strp->replace, M_XDATA,
		    sizeof(struct systrace_replace) + len);
		strp->replace = NULL;
		return (ret);
	}

	/* Adjust the offset */
	repl = strp->replace;
	repl->strr_base = (caddr_t)(repl + 1);

	return (0);
}

/*
 * Replace the arguments with arguments from the monitoring process.
 */

int
systrace_replace(struct str_process *strp, size_t argsize, register_t args[])
{
	struct systrace_replace *repl = strp->replace;
	caddr_t kdata, kbase;
	caddr_t udata, ubase;
	int i, maxarg, ind, ret = 0;

	maxarg = argsize/sizeof(register_t);
	ubase = stackgap_alloc(&strp->sg, repl->strr_len);
	if (ubase == NULL) {
		ret = EINVAL;
		goto out;
	}

	kbase = repl->strr_base;
	for (i = 0; i < maxarg && i < repl->strr_nrepl; i++) {
		ind = repl->strr_argind[i];
		if (ind < 0 || ind >= maxarg) {
			ret = EINVAL;
			goto out;
		}
		if (repl->strr_offlen[i] == 0) {
			args[ind] = repl->strr_off[i];
			continue;
		}
		kdata = kbase + repl->strr_off[i];
		if (repl->strr_flags[i] & SYSTR_NOLINKS) {
			ret = systrace_fname(strp, kdata, repl->strr_offlen[i]);
			if (ret != 0)
				goto out;
		}
		udata = ubase + repl->strr_off[i];
		if (copyout(kdata, udata, repl->strr_offlen[i])) {
			ret = EINVAL;
			goto out;
		}

		/* Replace the argument with the new address */
		args[ind] = (register_t)udata;
	}

 out:
	return (ret);
}

int
systrace_fname(struct str_process *strp, caddr_t kdata, size_t len)
{
	if (strp->nfname >= SYSTR_MAXFNAME || len < 1)
		return EINVAL;

	strp->fname[strp->nfname] = kdata;
	strp->fname[strp->nfname][len - 1] = '\0';
	strp->nfname++;

	return 0;
}

void
systrace_replacefree(struct str_process *strp)
{
	if (strp->replace != NULL) {
		free(strp->replace, M_XDATA, 0);
		strp->replace = NULL;
	}
	while (strp->nfname > 0) {
		strp->nfname--;
		strp->fname[strp->nfname] = NULL;
	}
}
int
systrace_scriptname(struct proc *p, char *dst)
{
	struct str_process *strp;
	struct fsystrace *fst;
	int error = 0;

	systrace_lock();  
	strp = p->p_systrace;
	fst = strp->parent;

	rw_enter_write(&fst->lock);
	systrace_unlock();

	if (!fst->issuser &&
		(ISSET(p->p_p->ps_flags, PS_SUGID | PS_SUGIDEXEC) ||
		fst->p_ruid != p->p_ucred->cr_ruid ||
		fst->p_rgid != p->p_ucred->cr_rgid)) {
		error = EPERM;
		goto out;
	}

	if (strp != NULL) {
		if (strp->scriptname[0] == '\0') {
			error = ENOENT;
			goto out;
		}

		strlcpy(dst, strp->scriptname, MAXPATHLEN);
		strp->isscript = 1;
	}

 out:
	strp->scriptname[0] = '\0';
	rw_exit_write(&fst->lock);

	return (error);
}

void
systrace_namei(struct nameidata *ndp)
{
	struct str_process *strp;
	struct fsystrace *fst;
	struct componentname *cnp = &ndp->ni_cnd;
	size_t i;
	int hamper = 0;

	systrace_lock();
	strp = cnp->cn_proc->p_systrace;
	if (strp != NULL) {
		fst = strp->parent;
		rw_enter_write(&fst->lock);
		systrace_unlock();

		for (i = 0; i < strp->nfname; i++)
			if (strcmp(cnp->cn_pnbuf, strp->fname[i]) == 0) {
				hamper = 1;
				break;
			}

		if (!hamper && strp->isscript &&
		    strcmp(cnp->cn_pnbuf, strp->scriptname) == 0)
			hamper = 1;

		rw_exit_write(&fst->lock);
	} else
		systrace_unlock();

	if (hamper) {
		/* ELOOP if namei() tries to readlink */
		ndp->ni_loopcnt = SYMLOOP_MAX;
		cnp->cn_flags &= ~FOLLOW;
		cnp->cn_flags |= NOFOLLOW;
	}
}

struct str_process *
systrace_findpid(struct fsystrace *fst, pid_t pid)
{
	struct str_process *strp;
	struct proc *proc = NULL;

	TAILQ_FOREACH(strp, &fst->processes, next)
	    if (strp->pid == pid)
		    break;

	if (strp == NULL)
		return (NULL);

	proc = systrace_find(strp);

	return (proc ? strp : NULL);
}

int
systrace_detach(struct str_process *strp)
{
	struct proc *proc;
	struct fsystrace *fst = NULL;
	int error = 0;

	DPRINTF(("%s: Trying to detach from %d\n", __func__, strp->pid));

	if ((proc = systrace_find(strp)) != NULL) {
		atomic_clearbits_int(&proc->p_flag, P_SYSTRACE);
		proc->p_systrace = NULL;
	} else
		error = ESRCH;

	if (ISSET(strp->flags, STR_PROC_WAITANSWER)) {
		CLR(strp->flags, STR_PROC_WAITANSWER);
		wakeup(strp);
	}

	fst = strp->parent;
	systrace_wakeup(fst);

	if (ISSET(strp->flags, STR_PROC_ONQUEUE))
		TAILQ_REMOVE(&fst->messages, strp, msg_next);

	TAILQ_REMOVE(&fst->processes, strp, next);
	fst->nprocesses--;

	if (strp->policy)
		systrace_closepolicy(fst, strp->policy);
	systrace_replacefree(strp);
	systrace_freeproc(strp);
	return (error);
}

void
systrace_closepolicy(struct fsystrace *fst, struct str_policy *policy)
{
	if (--policy->refcount)
		return;

	fst->npolicies--;

	if (policy->nsysent)
		free(policy->sysent, M_XDATA, policy->nsysent);

	TAILQ_REMOVE(&fst->policies, policy, next);

	pool_put(&systr_policy_pl, policy);
}


void
systrace_insert_process(struct fsystrace *fst, struct proc *proc,
	struct str_process *strp)
{
	strp->pid = proc->p_pid;
	strp->proc = proc;
	strp->parent = fst;

	TAILQ_INSERT_TAIL(&fst->processes, strp, next);
	fst->nprocesses++;

	proc->p_systrace = strp;
	atomic_setbits_int(&proc->p_flag, P_SYSTRACE);
}

struct str_policy *
systrace_newpolicy(struct fsystrace *fst, int maxents)
{
	struct str_policy *pol;
	int i;

	if (fst->npolicies > SYSTR_MAX_POLICIES && !fst->issuser) {
		struct str_policy *tmp;

		/* Try to find a policy for freeing */
		TAILQ_FOREACH(tmp, &fst->policies, next) {
			if (tmp->refcount == 1)
				break;
		}

		if (tmp == NULL)
			return (NULL);

		/* Notify userland about freed policy */
		systrace_msg_policyfree(fst, tmp);
		/* Free this policy */
		systrace_closepolicy(fst, tmp);
	}

	pol = pool_get(&systr_policy_pl, PR_NOWAIT|PR_ZERO);
	if (pol == NULL)
		return (NULL);

	DPRINTF(("%s: allocating %d -> %lu\n", __func__,
		     maxents, (u_long)maxents * sizeof(int)));

	pol->sysent = malloc(maxents, M_XDATA, M_WAITOK);
	pol->nsysent = maxents;
	for (i = 0; i < maxents; i++)
		pol->sysent[i] = SYSTR_POLICY_ASK;

	fst->npolicies++;
	pol->nr = fst->npolicynr++;
	pol->refcount = 1;

	TAILQ_INSERT_TAIL(&fst->policies, pol, next);

	return (pol);
}

int
systrace_msg_ask(struct fsystrace *fst, struct str_process *strp,
    int code, size_t argsize, register_t args[])
{
	struct str_msg_ask *msg_ask = &strp->msg.msg_data.msg_ask;
	int i;

	msg_ask->code = code;
	msg_ask->argsize = argsize;
	for (i = 0; i < (argsize/sizeof(register_t)) && i < SYSTR_MAXARGS; i++)
		msg_ask->args[i] = args[i];

	return (systrace_make_msg(strp, SYSTR_MSG_ASK));
}

int
systrace_msg_result(struct fsystrace *fst, struct str_process *strp,
    int error, int code, size_t argsize, register_t args[], register_t rval[])
{
	struct str_msg_ask *msg_ask = &strp->msg.msg_data.msg_ask;
	int i;

	msg_ask->code = code;
	msg_ask->argsize = argsize;
	msg_ask->result = error;
	for (i = 0; i < (argsize/sizeof(register_t)) && i < SYSTR_MAXARGS; i++)
		msg_ask->args[i] = args[i];

	msg_ask->rval[0] = rval[0];
	msg_ask->rval[1] = rval[1];

	return (systrace_make_msg(strp, SYSTR_MSG_RES));
}

int
systrace_msg_emul(struct fsystrace *fst, struct str_process *strp)
{
	struct str_msg_emul *msg_emul = &strp->msg.msg_data.msg_emul;
	struct proc *p = strp->proc;

	memcpy(msg_emul->emul, p->p_p->ps_emul->e_name, SYSTR_EMULEN);

	return (systrace_make_msg(strp, SYSTR_MSG_EMUL));
}

int
systrace_msg_ugid(struct fsystrace *fst, struct str_process *strp)
{
	struct str_msg_ugid *msg_ugid = &strp->msg.msg_data.msg_ugid;
	struct ucred *uc = strp->proc->p_p->ps_ucred;

	msg_ugid->uid = uc->cr_ruid;
	msg_ugid->gid = uc->cr_rgid;

	return (systrace_make_msg(strp, SYSTR_MSG_UGID));
}

int
systrace_make_msg(struct str_process *strp, int type)
{
	struct str_message *msg = &strp->msg;
	struct fsystrace *fst = strp->parent;
	int st, pri;

	pri = PWAIT|PCATCH;
	if (type == SYSTR_MSG_EXECVE)
		pri &= ~PCATCH;

	msg->msg_seqnr = ++strp->seqnr;
	msg->msg_type = type;
	msg->msg_pid = strp->pid;
	if (strp->policy)
		msg->msg_policy = strp->policy->nr;
	else
		msg->msg_policy = -1;

	SET(strp->flags, STR_PROC_WAITANSWER);
	if (ISSET(strp->flags, STR_PROC_ONQUEUE))
		goto out;

	TAILQ_INSERT_TAIL(&fst->messages, strp, msg_next);
	SET(strp->flags, STR_PROC_ONQUEUE);

 out:
	systrace_wakeup(fst);

	/* Release the lock - XXX */
	rw_exit_write(&fst->lock);

	while (1) {
		st = tsleep(strp, pri, "systrmsg", 0);
		if (st != 0)
			return (ERESTART);
		/* If we detach, then everything is permitted */
		if ((strp = curproc->p_systrace) == NULL)
			return (0);
		if (!ISSET(strp->flags, STR_PROC_WAITANSWER))
			break;
	}

	return (0);
}

int
systrace_msg_child(struct fsystrace *fst, struct str_process *strp, pid_t npid)
{
	struct str_process *nstrp;
	struct str_message *msg;
	struct str_msg_child *msg_child;

	if (strp->firstmsg) {
		nstrp = strp->firstmsg;
		strp->firstmsg = NULL;
	} else
		nstrp = pool_get(&systr_proc_pl, PR_WAITOK|PR_ZERO);

	DPRINTF(("%s: %p: pid %d -> pid %d\n", __func__,
		    nstrp, strp->pid, npid));

	msg = &nstrp->msg;
	msg_child = &msg->msg_data.msg_child;

	msg->msg_type = SYSTR_MSG_CHILD;
	msg->msg_pid = strp->pid;
	if (strp->policy)
		msg->msg_policy = strp->policy->nr;
	else
		msg->msg_policy = -1;
	msg_child->new_pid = npid;

	TAILQ_INSERT_TAIL(&fst->messages, nstrp, msg_next);

	systrace_wakeup(fst);

	return (0);
}

int
systrace_msg_policyfree(struct fsystrace *fst, struct str_policy *strpol)
{
	struct str_process *nstrp;
	struct str_message *msg;

	nstrp = pool_get(&systr_proc_pl, PR_WAITOK|PR_ZERO);

	DPRINTF(("%s: free %d\n", __func__, strpol->nr));

	msg = &nstrp->msg;

	msg->msg_type = SYSTR_MSG_POLICYFREE;
	msg->msg_policy = strpol->nr;

	TAILQ_INSERT_TAIL(&fst->messages, nstrp, msg_next);

	systrace_wakeup(fst);

	return (0);
}

caddr_t  
stackgap_init(struct proc *p)
{
	struct process *pr = p->p_p;

	if (pr->ps_stackgap == 0) {
		if (uvm_map(&pr->ps_vmspace->vm_map, &pr->ps_stackgap,
		    round_page(STACKGAPLEN), NULL, 0, 0,
		    UVM_MAPFLAG(PROT_READ | PROT_WRITE, PROT_READ | PROT_WRITE,
		    MAP_INHERIT_COPY, MADV_RANDOM, UVM_FLAG_COPYONW)))
			sigexit(p, SIGILL);
	}

        return (caddr_t)pr->ps_stackgap;
}

void *          
stackgap_alloc(caddr_t *sgp, size_t sz)
{
	void *n = (void *) *sgp;
	caddr_t nsgp;

	sz = ALIGN(sz);
	nsgp = *sgp + sz;
	if (nsgp > (caddr_t)trunc_page((vaddr_t)n) + STACKGAPLEN)
		return NULL;
	*sgp = nsgp;
	return n;
}
@


1.78
log
@Copy the stackgap_init() and stackgap_alloc() functions from
compat/common/compat_util.c to dev/systrace.c, the one place they
are used, and remove the remaining kernel references to compat/*.
ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.77 2015/09/08 11:58:58 deraadt Exp $	*/
@


1.77
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.76 2015/08/27 06:16:41 deraadt Exp $	*/
d51 2
a52 1
#include <compat/common/compat_util.h>
d1814 30
@


1.76
log
@simple sizes for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.75 2015/03/14 03:38:46 jsg Exp $	*/
d460 1
a460 1
	free(fp->f_data, M_XDATA, 0);
d1588 1
a1588 1
		free(policy->sysent, M_XDATA, 0);
@


1.75
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.74 2015/02/10 22:03:11 miod Exp $	*/
d497 1
a497 1
		fst = (struct fsystrace *)malloc(sizeof(struct fsystrace),
d513 1
a513 1
			free(fst, M_XDATA, 0);
d960 1
a960 1
		free(kaddr, M_XDATA, 0);
d1360 2
a1361 1
		free(strp->replace, M_XDATA, 0);
@


1.74
log
@Another uiomovei(,sizeof,) -> uiomove
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.73 2015/02/10 21:56:09 miod Exp $	*/
a37 1
#include <sys/conf.h>
@


1.73
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.72 2015/01/19 18:37:19 deraadt Exp $	*/
d214 1
a214 1
		error = uiomovei((caddr_t)&process->msg,
@


1.72
log
@use SYMLOOP_MAX rather than MAXSYMLINKS
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.71 2014/07/13 23:10:23 deraadt Exp $	*/
d214 1
a214 1
		error = uiomove((caddr_t)&process->msg,
@


1.71
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.70 2014/07/12 18:48:51 tedu Exp $	*/
d1519 1
a1519 1
		ndp->ni_loopcnt = MAXSYMLINKS;
@


1.70
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.69 2014/06/17 03:49:03 guenther Exp $	*/
d1642 1
a1642 2
	pol->sysent = (u_char *)malloc(maxents * sizeof(u_char),
	    M_XDATA, M_WAITOK);
@


1.69
log
@Revise previous: if a user calls STRIOCGETCWD two or more times in a row
without an intervening STRIOCRESCWD, release the current values instead
of the saved values, so as to effectively emulate a STRIOCRESCWD.

While here, make sure the fdc->fd_[cr]dir members are updated before
vrele()ing their old values, so that they can't be caught as dangling refs.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.68 2014/06/15 20:22:12 matthew Exp $	*/
d461 1
a461 1
	free(fp->f_data, M_XDATA);
d514 1
a514 1
			free(fst, M_XDATA);
d932 1
a932 1
		free(inject->kaddr, M_XDATA);
d961 1
a961 1
		free(kaddr, M_XDATA);
d1325 1
a1325 1
		free(strp->replace, M_XDATA);
d1361 1
a1361 1
		free(strp->replace, M_XDATA);
d1440 1
a1440 1
		free(strp->replace, M_XDATA);
d1588 1
a1588 1
		free(policy->sysent, M_XDATA);
@


1.68
log
@Fix vnode leak in systrace(4).

If a user calls STRIOCGETCWD two or more times in a row without an
intervening STRIOCRESCWD, then the references held on fst->fd_{c,r}dir
would leak.

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.67 2014/04/18 11:51:17 guenther Exp $	*/
d158 1
a263 1
	struct filedesc *fdp;
d370 1
a370 17
		if (!fst->fd_pid) {
			ret = EINVAL;
			break;
		}
		fdp = p->p_fd;

		/* Release cwd from other process */
		if (fdp->fd_cdir)
			vrele(fdp->fd_cdir);
		if (fdp->fd_rdir)
			vrele(fdp->fd_rdir);
		/* This restores the cwd we had before */
		fdp->fd_cdir = fst->fd_cdir;
		fdp->fd_rdir = fst->fd_rdir;
		/* Note that we are normal again */
		fst->fd_pid = 0;
		fst->fd_cdir = fst->fd_rdir = NULL;
d1063 1
a1063 1
	struct vnode *dvp;
d1088 16
a1103 7
	/* Release any saved vnodes. */
	if (fst->fd_cdir != NULL)
		vrele(fst->fd_cdir);
	if (fst->fd_rdir != NULL)
		vrele(fst->fd_rdir);

	/* Store our current values */
a1104 2
	fst->fd_cdir = myfdp->fd_cdir;
	fst->fd_rdir = myfdp->fd_rdir;
d1110 31
@


1.67
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.66 2014/03/30 21:54:48 guenther Exp $	*/
d1103 6
@


1.66
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.65 2014/03/27 04:38:40 guenther Exp $	*/
a61 2
uid_t	systrace_seteuid(struct proc *,  uid_t);
gid_t	systrace_setegid(struct proc *,  gid_t);
a117 1
	uid_t saveuid;
a118 1
	gid_t savegid;
a664 3
	struct ucred *uc;
	uid_t olduid;
	gid_t oldgid;
d666 2
d699 2
a700 2
		maycontrol = fst->p_ruid == p->p_ucred->cr_ruid &&
		    fst->p_rgid == p->p_ucred->cr_rgid;
a784 3
	uc = p->p_ucred;
	olduid = uc->cr_ruid;
	oldgid = uc->cr_rgid;
d787 22
a808 7
	if (issuser) {
		if (ISSET(strp->flags, STR_PROC_SETEUID))
			strp->saveuid = systrace_seteuid(p, strp->seteuid);
		if (ISSET(strp->flags, STR_PROC_SETEGID))
			strp->savegid = systrace_setegid(p, strp->setegid);
	} else
		CLR(strp->flags, STR_PROC_SETEUID|STR_PROC_SETEGID);
d814 3
a823 13
	if (issuser) {
		if (ISSET(strp->flags, STR_PROC_SETEUID)) {
			if (uc->cr_uid == strp->seteuid)
				systrace_seteuid(p, strp->saveuid);
			CLR(strp->flags, STR_PROC_SETEUID);
		}
		if (ISSET(strp->flags, STR_PROC_SETEGID)) {
			if (uc->cr_gid == strp->setegid)
				systrace_setegid(p, strp->savegid);
			CLR(strp->flags, STR_PROC_SETEGID);
		}
	}

d858 2
a859 2
	if (olduid != p->p_ucred->cr_ruid ||
	    oldgid != p->p_ucred->cr_rgid) {
a879 38
uid_t
systrace_seteuid(struct proc *p,  uid_t euid)
{
	struct ucred *uc = p->p_ucred;
	uid_t oeuid = uc->cr_uid;

	if (oeuid == euid)
		return (oeuid);

	/*
	 * Copy credentials so other references do not see our changes.
	 */
	p->p_ucred = uc = crcopy(uc);
	uc->cr_uid = euid;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);

	return (oeuid);
}

gid_t
systrace_setegid(struct proc *p,  gid_t egid)
{
	struct ucred *uc = p->p_ucred;
	gid_t oegid = uc->cr_gid;

	if (oegid == egid)
		return (oegid);

	/*
	 * Copy credentials so other references do not see our changes.
	 */
	p->p_ucred = uc = crcopy(uc);
	uc->cr_gid = egid;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);

	return (oegid);
}

d1163 3
a1165 1
	struct proc *proc, *p = curproc;
d1168 1
a1168 1
	if ((proc = pfind(pid)) == NULL || (proc->p_flag & P_THREAD)) {
d1172 1
d1174 1
a1174 1
	if (ISSET(proc->p_p->ps_flags, PS_INEXEC)) {
d1183 1
a1183 1
	if (proc->p_p == p->p_p) {
d1191 1
a1191 1
	if (ISSET(proc->p_flag, P_SYSTEM)) {
d1199 1
a1199 1
	if (ISSET(proc->p_flag, P_SYSTRACE)) {
d1215 2
a1216 2
	if ((proc->p_ucred->cr_ruid != p->p_ucred->cr_ruid ||
		ISSET(proc->p_p->ps_flags, PS_SUGID | PS_SUGIDEXEC)) &&
d1226 1
a1226 1
	if ((proc->p_p->ps_pid == 1) && (securelevel > -1)) {
d1232 1
a1232 1
	systrace_insert_process(fst, proc, newstrp);
d1678 1
a1678 1
	struct proc *p = strp->proc;
d1680 2
a1681 2
	msg_ugid->uid = p->p_ucred->cr_ruid;
	msg_ugid->gid = p->p_ucred->cr_rgid;
@


1.65
log
@Check for PS_SUGID/PS_SUGIDEXEC against the correct set of flags

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.64 2014/03/26 05:23:42 guenther Exp $	*/
d527 2
a528 2
		fst->p_ruid = p->p_cred->p_ruid;
		fst->p_rgid = p->p_cred->p_rgid;
d669 1
a669 1
	struct pcred *pc;
d704 2
a705 2
		maycontrol = fst->p_ruid == p->p_cred->p_ruid &&
		    fst->p_rgid == p->p_cred->p_rgid;
d790 3
a792 3
	pc = p->p_cred;
	olduid = pc->p_ruid;
	oldgid = pc->p_rgid;
d816 1
a816 1
			if (pc->pc_ucred->cr_uid == strp->seteuid)
d821 1
a821 1
			if (pc->pc_ucred->cr_gid == strp->setegid)
d861 2
a862 2
	if (olduid != p->p_cred->p_ruid ||
	    oldgid != p->p_cred->p_rgid) {
d886 2
a887 2
	struct pcred *pc = p->p_cred;
	uid_t oeuid = pc->pc_ucred->cr_uid;
d889 1
a889 1
	if (pc->pc_ucred->cr_uid == euid)
d895 2
a896 2
	pc->pc_ucred = crcopy(pc->pc_ucred);
	pc->pc_ucred->cr_uid = euid;
d905 2
a906 2
	struct pcred *pc = p->p_cred;
	gid_t oegid = pc->pc_ucred->cr_gid;
d908 1
a908 1
	if (pc->pc_ucred->cr_gid == egid)
d914 2
a915 2
	pc->pc_ucred = crcopy(pc->pc_ucred);
	pc->pc_ucred->cr_gid = egid;
d1253 1
a1253 1
	if ((proc->p_cred->p_ruid != p->p_cred->p_ruid ||
d1264 1
a1264 1
	if ((proc->p_pid == 1) && (securelevel > -1)) {
d1313 2
a1314 2
		    fst->p_ruid != p->p_cred->p_ruid ||
		    fst->p_rgid != p->p_cred->p_rgid) {
d1474 2
a1475 2
		fst->p_ruid != p->p_cred->p_ruid ||
		fst->p_rgid != p->p_cred->p_rgid)) {
d1718 2
a1719 2
	msg_ugid->uid = p->p_cred->p_ruid;
	msg_ugid->gid = p->p_cred->p_rgid;
@


1.64
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.63 2012/04/22 05:43:14 guenther Exp $	*/
d1254 1
a1254 1
		ISSET(proc->p_flag, PS_SUGID | PS_SUGIDEXEC)) &&
@


1.63
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.62 2012/02/20 22:23:39 guenther Exp $	*/
d663 1
d681 1
a681 1
	if (code < 0 || code >= p->p_emul->e_nsysent) {
d703 1
a703 1
	} else if (!ISSET(p->p_p->ps_flags, PS_SUGID | PS_SUGIDEXEC)) {
d722 1
a722 1
	callp = p->p_emul->e_sysent + code;
d738 1
a738 1
			    p->p_pid, code));
d751 1
a751 1
	strp->sg = stackgap_init(p->p_emul);
d789 1
a789 1
	oldemul = p->p_emul;
d829 1
a829 1
	if (ISSET(p->p_p->ps_flags, PS_SUGID | PS_SUGIDEXEC)) {
d849 1
a849 1
	if (p->p_emul != oldemul) {
d1063 1
a1063 1
		if (strpol->emul && strpol->emul != strp->proc->p_emul)
d1077 1
a1077 1
			strpol->emul = strp->proc->p_emul;
d1707 1
a1707 1
	memcpy(msg_emul->emul, p->p_emul->e_name, SYSTR_EMULEN);
@


1.62
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.61 2012/02/15 04:26:27 guenther Exp $	*/
d542 1
a542 1
		FILE_SET_MATURE(f);
@


1.61
log
@Hold struct filedesc's fd_lock when writing to the fd_ofiles, fd_ofileflags,
or fd_{lo,hi}maps members, or when doing a read for a write.  Fixes hangs
when an rthreaded processes sleeps while copying the fd table for fork()
and catches another thread with the lock.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.60 2011/09/18 23:24:14 matthew Exp $	*/
d1206 1
a1206 1
	if ((proc = pfind(pid)) == NULL) {
d1211 1
a1211 1
	if (ISSET(proc->p_flag, P_INEXEC)) {
d1220 1
a1220 1
	if (proc->p_pid == p->p_pid) {
@


1.60
log
@Add support for *at(2) system calls to systrace(1).

ok deraadt@@, sthen@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.59 2011/07/11 15:40:47 guenther Exp $	*/
d530 1
d532 1
@


1.59
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.57 2011/06/24 22:48:36 djm Exp $	*/
d161 1
a161 1
int	systrace_getcwd(struct fsystrace *, struct str_process *);
d270 1
d303 3
a305 2
	case STRIOCGETCWD:
		pid = *(pid_t *)data;
d308 1
d310 1
d393 1
a393 1
		ret = systrace_getcwd(fst, strp);
d1114 1
a1114 1
systrace_getcwd(struct fsystrace *fst, struct str_process *strp)
d1117 1
d1131 11
d1147 1
a1147 1
	if ((myfdp->fd_cdir = fdp->fd_cdir) != NULL)
@


1.58
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@a666 1
	KERNEL_LOCK();
a670 1
		KERNEL_UNLOCK();
a675 1
		KERNEL_UNLOCK();
a734 1
		KERNEL_UNLOCK();
d750 1
a750 2
	if (error) {
		KERNEL_UNLOCK();
a751 1
	}
a756 1
		KERNEL_UNLOCK();
a803 1
		KERNEL_UNLOCK();
a824 1
			KERNEL_UNLOCK();
a872 1
	KERNEL_UNLOCK();
@


1.57
log
@printf -> DPRINTF in the SIGKILL path
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.56 2011/06/23 16:02:33 tedu Exp $	*/
d667 1
d672 1
d678 1
d738 1
d754 2
a755 1
	if (error)
d757 1
d763 1
d811 1
d833 1
d882 1
@


1.56
log
@ansify a few files.  ok deraadt dlg krw matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.55 2011/06/22 01:32:16 djm Exp $	*/
d730 2
a731 1
			printf("systrace: killed on syscall %d\n", code);
@


1.55
log
@Add a SYSTR_POLICY_KILL per-syscall policy option that sends SIGKILL to
the traced process when the syscall is attempted. This is more useful and
safer for unsupervised sandboxing than returning EPERM (which is the
behaviour of SYSTR_POLICY_NEVER), as this could cause dangerous misbehaviour
in applications that don't expect it.

"I like it" deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.54 2011/04/02 17:04:35 guenther Exp $	*/
d202 2
a203 5
systracef_read(fp, poff, uio, cred)
	struct file *fp;
	off_t *poff;
	struct uio *uio;
	struct ucred *cred;
d250 2
a251 5
systracef_write(fp, poff, uio, cred)
	struct file *fp;
	off_t *poff;
	struct uio *uio;
	struct ucred *cred;
d263 1
a263 5
systracef_ioctl(fp, cmd, data, p)
	struct file *fp;
	u_long cmd;
	caddr_t data;
	struct proc *p;
d403 1
a403 4
systracef_poll(fp, events, p)
	struct file *fp;
	int events;
	struct proc *p;
d425 1
a425 3
systracef_kqfilter(fp, kn)
	struct file *fp;
	struct knote *kn;
d432 1
a432 4
systracef_stat(fp, sb, p)
	struct file *fp;
	struct stat *sb;
	struct proc *p;
d439 1
a439 3
systracef_close(fp, p)
	struct file *fp;
	struct proc *p;
d494 1
a494 5
systraceopen(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d500 1
a500 5
systraceclose(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d506 1
a506 6
systraceioctl(dev, cmd, data, flag, p)
	dev_t	dev;
	u_long	cmd;
	caddr_t	data;
	int	flag;
	struct proc *p;
@


1.54
log
@Move P_SUGID and P_SUGIDEXEC from struct proc to struct process, so
that you can't evade the checks by doing the dirty work in an rthread

ok blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.53 2010/07/21 18:44:01 deraadt Exp $	*/
d264 2
a265 1
			 (x) == SYSTR_POLICY_NEVER)
d752 2
a753 1
		if (policy != SYSTR_POLICY_PERMIT) {
d761 5
a765 1
		if (policy == SYSTR_POLICY_PERMIT)
@


1.53
log
@No need for read/write functions, just use enodev like all the other
things things do
ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.52 2009/11/09 17:53:39 nicm Exp $	*/
d723 1
a723 1
	 * uid or gid causes P_SUGID to be set.
d728 1
a728 2
	} else if (!ISSET(p->p_flag, P_SUGID) &&
	    !ISSET(p->p_flag, P_SUGIDEXEC)) {
d848 1
a848 1
	if (ISSET(p->p_flag, P_SUGID) || ISSET(p->p_flag, P_SUGIDEXEC)) {
d916 1
a916 1
	atomic_setbits_int(&p->p_flag, P_SUGID);
d935 1
a935 1
	atomic_setbits_int(&p->p_flag, P_SUGID);
d1254 1
a1254 1
	 *      [Note: once P_SUGID or P_SUGIDEXEC gets set in execve(),
d1261 1
a1261 2
		ISSET(proc->p_flag, P_SUGID) ||
		ISSET(proc->p_flag, P_SUGIDEXEC)) &&
d1479 2
a1480 2
	if (!fst->issuser && (ISSET(p->p_flag, P_SUGID) ||
		ISSET(p->p_flag, P_SUGIDEXEC) ||
@


1.52
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.51 2009/10/31 06:40:16 deraadt Exp $	*/
a59 2
int	systraceread(dev_t, struct uio *, int);
int	systracewrite(dev_t, struct uio *, int);
a60 1
int	systracepoll(dev_t, int, struct proc *);
a532 18
systraceread(dev, uio, ioflag)
	dev_t	dev;
	struct uio *uio;
	int	ioflag;
{
	return (EIO);
}

int
systracewrite(dev, uio, ioflag)
	dev_t	dev;
	struct uio *uio;
	int	ioflag;
{
	return (EIO);
}

int
a574 9
}

int
systracepoll(dev, events, p)
	dev_t	dev;
	int	events;
	struct proc *p;
{
	return (seltrue(dev, events, p));
@


1.51
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.50 2009/07/09 22:29:55 thib Exp $	*/
a611 1
	KNOTE(&fst->si.si_note, 0);
@


1.50
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.48 2008/09/12 12:27:27 blambert Exp $	*/
d612 1
@


1.49
log
@systrace activation happens in the middle of a rather sensitive piece of
fork(), i worry about it a lot but cannot prove yet that sleeping there
is bad.  Anyways, this change makes us never sleep in that area -- the
memory needed is allocated ealier like the ptrace state.  tested by many
developers.
@
text
@d1189 1
a1189 1
		VREF(myfdp->fd_cdir);
d1191 1
a1191 1
		VREF(myfdp->fd_rdir);
@


1.48
log
@Remove bzero/memset calls after pool_gets by passing the PR_ZERO
flag to the pool_get call.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.47 2008/01/05 07:33:37 brad Exp $	*/
d105 1
d173 2
a174 1
int	systrace_insert_process(struct fsystrace *, struct proc *);
d648 1
d655 10
d666 9
a674 1
systrace_fork(struct proc *oldproc, struct proc *p)
d683 1
d691 1
a691 2
	if (systrace_insert_process(fst, p))
		goto out;
a700 1
 out:
d1243 1
d1308 2
a1309 1
	error = systrace_insert_process(fst, proc);
d1624 1
a1624 2
	pool_put(&systr_proc_pl, strp);

d1645 3
a1647 2
int
systrace_insert_process(struct fsystrace *fst, struct proc *proc)
a1648 7
	struct str_process *strp;

	strp = pool_get(&systr_proc_pl, PR_NOWAIT);
	if (strp == NULL)
		return (ENOBUFS);

	memset((caddr_t)strp, 0, sizeof(struct str_process));
a1657 2

	return (0);
d1684 1
a1684 1
	pol = pool_get(&systr_policy_pl, PR_NOWAIT);
a1690 2
	memset((caddr_t)pol, 0, sizeof(struct str_policy));

d1816 5
a1820 1
	nstrp = pool_get(&systr_proc_pl, PR_WAITOK|PR_ZERO);
@


1.47
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok krw@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.46 2007/09/11 13:39:33 gilles Exp $	*/
d1805 1
a1805 2
	nstrp = pool_get(&systr_proc_pl, PR_WAITOK);
	memset(nstrp, 0, sizeof(struct str_process));
d1834 1
a1834 2
	nstrp = pool_get(&systr_proc_pl, PR_WAITOK);
	memset(nstrp, 0, sizeof(struct str_process));
@


1.46
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.45 2007/09/10 19:49:31 gilles Exp $	*/
d327 1
a327 1
		ret = EINVAL;
d402 1
a402 1
		ret = EINVAL;
@


1.45
log
@more MALLOC/FREE -> malloc/free and M_ZERO changes

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.44 2007/03/15 10:22:30 art Exp $	*/
d566 1
a566 1
		    M_XDATA, M_WAITOK|M_ZERO);
@


1.44
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.43 2006/10/06 05:47:27 djm Exp $	*/
d497 1
a497 1
	FREE(fp->f_data, M_XDATA);
d565 2
a566 4
		MALLOC(fst, struct fsystrace *, sizeof(struct fsystrace),
		    M_XDATA, M_WAITOK);

		memset(fst, 0, sizeof(struct fsystrace));
d579 1
a579 1
			FREE(fst, M_XDATA);
@


1.43
log
@fix an exploitable integer overflow found by Chris Evans of Google
Security; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.42 2006/05/28 17:06:38 pedro Exp $	*/
d651 1
a651 1
	CLR(proc->p_flag, P_SYSTRACE);
d929 1
a929 1
	p->p_flag |= P_SUGID;
d948 1
a948 1
	p->p_flag |= P_SUGID;
d1582 1
a1582 1
		CLR(proc->p_flag, P_SYSTRACE);
d1644 1
a1644 1
	SET(proc->p_flag, P_SYSTRACE);
@


1.42
log
@Allow len == 1 in systrace_fname(), so systraced processes can proceed
their *stat() calls, for example, and get ENOENT, which is expected for
"", instead of a forced EINVAL.

Fixes the spurious 'rm: : Invalid argument' warnings when building with
option USE_SYSTRACE, reported on ports@@.

Okay provos@@ sturm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.41 2006/05/23 22:28:22 alek Exp $	*/
d1362 3
a1364 1
		len += repl->strr_offlen[i];
d1367 5
d1381 1
a1381 1
	if (repl->strr_len > 2048)
d1416 4
@


1.42.2.1
log
@MFC:
Fix by djm@@

fix an exploitable integer overflow found by Chris Evans of Google
Security; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.42 2006/05/28 17:06:38 pedro Exp $	*/
d1362 1
a1362 3
		if (repl->strr_argind[i] < 0 ||
		    repl->strr_argind[i] >= SYSTR_MAXARGS)
			return (EINVAL);
a1364 5
		len += repl->strr_offlen[i];
		if (repl->strr_offlen[i] > SYSTR_MAXREPLEN ||
		    repl->strr_off[i] > SYSTR_MAXREPLEN ||
		    len > SYSTR_MAXREPLEN)
			return (EINVAL);
d1374 1
a1374 1
	if (repl->strr_len > SYSTR_MAXREPLEN)
a1408 4
	if (ubase == NULL) {
		ret = EINVAL;
		goto out;
	}
@


1.41
log
@Replace lockmgr with rwlock; 'i think so' tedu@@, ok sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.40 2005/12/11 21:30:30 miod Exp $	*/
d1444 1
a1444 1
	if (strp->nfname >= SYSTR_MAXFNAME || len < 2)
@


1.40
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.39 2005/11/19 02:18:00 pedro Exp $	*/
d45 1
a45 1
#include <sys/lock.h>
d136 1
a136 1
struct lock systrace_lck;
d141 1
a141 1
	lockmgr(&systrace_lck, LK_EXCLUSIVE, NULL);
d147 1
a147 1
	lockmgr(&systrace_lck, LK_RELEASE, NULL);
d218 1
a218 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d238 1
a238 1
			lockmgr(&fst->lock, LK_RELEASE, NULL);
d247 1
a247 1
	lockmgr(&fst->lock, LK_RELEASE, NULL);
d335 1
a335 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d407 1
a407 1
	lockmgr(&fst->lock, LK_RELEASE, NULL);
d425 1
a425 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d431 1
a431 1
	lockmgr(&fst->lock, LK_RELEASE, NULL);
d466 1
a466 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d495 1
a495 1
	lockmgr(&fst->lock, LK_RELEASE, NULL);
d510 1
a510 1
	lockinit(&systrace_lck, PLOCK, "systrace", 0, 0);
d569 1
a569 1
		lockinit(&fst->lock, PLOCK, "systrace", 0, 0);
d641 1
a641 1
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d648 1
a648 1
		lockmgr(&fst->lock, LK_RELEASE, NULL);
d668 1
a668 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d683 1
a683 1
	lockmgr(&fst->lock, LK_RELEASE, NULL);
d694 1
a694 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL); \
d727 1
a727 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d771 1
a771 1
		lockmgr(&fst->lock, LK_RELEASE, NULL);
d800 1
a800 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d835 1
a835 1
	lockmgr(&fst->lock, LK_RELEASE, NULL);
d878 1
a878 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d910 1
a910 1
	lockmgr(&fst->lock, LK_RELEASE, NULL);
d1323 1
a1323 1
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d1334 1
a1334 1
			lockmgr(&fst->lock, LK_RELEASE, NULL);
d1477 1
a1477 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d1500 1
a1500 1
	lockmgr(&fst->lock, LK_RELEASE, NULL);
d1518 1
a1518 1
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL);
d1531 1
a1531 1
		lockmgr(&fst->lock, LK_RELEASE, NULL);
d1773 1
a1773 1
	lockmgr(&fst->lock, LK_RELEASE, NULL);
@


1.40.2.1
log
@MFC:
Fix by djm@@

fix an exploitable integer overflow found by Chris Evans of Google
Security; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.40 2005/12/11 21:30:30 miod Exp $	*/
d1362 1
a1362 3
		if (repl->strr_argind[i] < 0 ||
		    repl->strr_argind[i] >= SYSTR_MAXARGS)
			return (EINVAL);
a1364 5
		len += repl->strr_offlen[i];
		if (repl->strr_offlen[i] > SYSTR_MAXREPLEN ||
		    repl->strr_off[i] > SYSTR_MAXREPLEN ||
		    len > SYSTR_MAXREPLEN)
			return (EINVAL);
d1374 1
a1374 1
	if (repl->strr_len > SYSTR_MAXREPLEN)
a1408 4
	if (ubase == NULL) {
		ret = EINVAL;
		goto out;
	}
@


1.39
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.38 2005/04/17 22:11:34 millert Exp $	*/
d50 1
a53 2
#include <miscfs/procfs/procfs.h>

d1213 1
a1213 1
	error = procfs_domem(p, t, NULL, &uio);
@


1.38
log
@Intermediate cast of strio_offs -> uio_offset should be u_long not long
since otherwise a very high kernel address would be stored as a negative
offset.  From NetBSD (christos).
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.37 2004/11/07 20:39:31 marius Exp $	*/
d142 1
a142 1
	lockmgr(&systrace_lck, LK_EXCLUSIVE, NULL, curproc);
d148 1
a148 1
	lockmgr(&systrace_lck, LK_RELEASE, NULL, curproc);
d219 1
a219 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, curproc);
d239 1
a239 1
			lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
d248 1
a248 1
	lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
d336 1
a336 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, curproc);
d408 1
a408 1
	lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
d426 1
a426 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
d432 1
a432 1
	lockmgr(&fst->lock, LK_RELEASE, NULL, p);
d467 1
a467 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, curproc);
d496 1
a496 1
	lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
d642 1
a642 1
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, curproc);
d649 1
a649 1
		lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
d669 1
a669 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, curproc);
d684 1
a684 1
	lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
d695 1
a695 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p); \
d728 1
a728 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
d772 1
a772 1
		lockmgr(&fst->lock, LK_RELEASE, NULL, p);
d801 1
a801 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
d836 1
a836 1
	lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
d879 1
a879 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
d911 1
a911 1
	lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
d1324 1
a1324 1
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
d1335 1
a1335 1
			lockmgr(&fst->lock, LK_RELEASE, NULL, p);
d1478 1
a1478 1
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
d1501 1
a1501 1
	lockmgr(&fst->lock, LK_RELEASE, NULL, p);
d1519 1
a1519 1
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, curproc);
d1532 1
a1532 1
		lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
a1748 1
	struct proc *p = strp->proc;
d1774 1
a1774 1
	lockmgr(&fst->lock, LK_RELEASE, NULL, p);
@


1.38.2.1
log
@MFC:
Fix by djm@@

fix an exploitable integer overflow found by Chris Evans of Google
Security; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.38 2005/04/17 22:11:34 millert Exp $	*/
d1363 1
a1363 3
		if (repl->strr_argind[i] < 0 ||
		    repl->strr_argind[i] >= SYSTR_MAXARGS)
			return (EINVAL);
a1365 5
		len += repl->strr_offlen[i];
		if (repl->strr_offlen[i] > SYSTR_MAXREPLEN ||
		    repl->strr_off[i] > SYSTR_MAXREPLEN ||
		    len > SYSTR_MAXREPLEN)
			return (EINVAL);
d1375 1
a1375 1
	if (repl->strr_len > SYSTR_MAXREPLEN)
a1409 4
	if (ubase == NULL) {
		ret = EINVAL;
		goto out;
	}
@


1.37
log
@add a new message: inject.  this allows the tracer to to inject buffers into
the stackgap.  this in turn allows for argument replacement with indirection.
for example replacing an entire envp or struct pollfd.

ok provos@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.36 2004/07/07 07:31:40 marius Exp $	*/
d1209 1
a1209 1
	uio.uio_offset = (off_t)(long)io->strio_offs;
@


1.36
log
@fix an issue when scripts are exec'd under systrace where
the argv[0] would be normalized, and hence break scripts
that depend on how they were called.

this fixes an issue in the ports builds.

ok provos@@ deraadt@@; lots of testing during hackathon sturm@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.35 2004/06/23 05:16:35 marius Exp $	*/
d89 6
d126 1
a126 1
	
d131 4
d158 2
d308 5
d371 3
d778 8
d815 1
d817 1
a817 1
	if (strp->replace != NULL) {
d819 2
a820 3
		if (error)
			goto out_unlock;
	}
d910 1
a910 1
 out_unlock:
d912 1
a912 1
 out:
d1013 51
d1405 1
a1405 2
	struct proc *p = strp->proc;
	caddr_t sg, udata, ubase;
d1409 1
a1409 2
	sg = stackgap_init(p->p_emul);
	ubase = stackgap_alloc(&sg, repl->strr_len);
@


1.35
log
@a few fixes to systrace

- add an exec message so that whenever a set-uid/gid process
  exec's a new image which we may control, the exec does not
  go by unnoticed.

- take special care to check for P_SUGIDEXEC as well as
  P_SUGID, corresponding to the same changes that were made in
  the ptrace code a while ago

ok niels@@, sturm@@; thanks to naddy for testing
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.34 2003/10/21 05:24:40 jmc Exp $	*/
d121 3
d146 2
d291 5
d350 4
d976 9
d1218 12
a1229 1
systrace_execve(char *path, struct proc *p)
d1231 30
a1260 29
       struct str_process *strp;
       struct fsystrace *fst;
       struct str_msg_execve *msg_execve;

       do { 
               systrace_lock();
               strp = p->p_systrace;
               if (strp == NULL) {
                       systrace_unlock();
                       return;
               }

               msg_execve = &strp->msg.msg_data.msg_execve;
               fst = strp->parent;
               lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
               systrace_unlock();

               /*
                * susers will get the execve call anyway.  Also, if
                * we're not allowed to control the process, escape.
                */
               if (fst->issuser ||
                   fst->p_ruid != p->p_cred->p_ruid ||
                   fst->p_rgid != p->p_cred->p_rgid) {
                       lockmgr(&fst->lock, LK_RELEASE, NULL, p);
                       return;
               }
	       strlcpy(msg_execve->path, path, MAXPATHLEN);
       } while (systrace_make_msg(strp, SYSTR_MSG_EXECVE) != 0);
d1390 38
d1450 4
@


1.34
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.33 2003/10/08 16:30:01 sturm Exp $	*/
d120 1
a120 1

d706 3
a708 2
		issuser =1 ;
	} else if (!(p->p_flag & P_SUGID)) {
d820 1
a820 1
	if (p->p_flag & P_SUGID) {
a951 1
	
d1165 2
a1166 2
	 *      [Note: once P_SUGID gets set in execve(), it stays
	 *	set until the process does another execve(). Hence
d1172 2
a1173 1
		ISSET(proc->p_flag, P_SUGID)) &&
d1194 34
a1332 1

d1363 1
d1372 1
a1372 1
		for (i = 0; i < strp->nfname; i++) {
d1374 1
a1374 4
				/* ELOOP if namei() tries to readlink */
				ndp->ni_loopcnt = MAXSYMLINKS;
				cnp->cn_flags &= ~FOLLOW;
				cnp->cn_flags |= NOFOLLOW;
d1377 1
a1377 1
		}
d1381 7
d1596 5
a1600 1
	int st;
d1624 1
a1624 1
		st = tsleep(strp, PWAIT | PCATCH, "systrmsg", 0);
@


1.33
log
@originally from cb@@netbsd.org, adapted by provos

itojun@@ ok

fix a race condition between path resolution in userland
and the subsequent namei(): inform the kernel portion of
valid filenames and then disallow symlink lookups for
those filenames by means of a hook in namei().
with suggestions from provos@@

also, add (currently unused) seqnr field to struct
systrace_replace, from provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.32 2003/09/23 16:51:12 millert Exp $	*/
d1167 2
a1168 2
	 *	this prevents a setuid process which revokes it's
	 *	special privilidges using setuid() from being
@


1.32
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.31 2003/08/15 20:32:16 tedu Exp $	*/
d48 1
d108 2
d124 13
a136 2
void systrace_lock(void);
void systrace_unlock(void);
d148 2
a181 1
struct lock systrace_lck;
a470 12
systrace_lock(void)
{
	lockmgr(&systrace_lck, LK_EXCLUSIVE, NULL, curproc);
}

void
systrace_unlock(void)
{
	lockmgr(&systrace_lck, LK_RELEASE, NULL, curproc);
}

void
d727 8
a734 28
	switch (policy) {
	case SYSTR_POLICY_PERMIT:
		break;
	case SYSTR_POLICY_ASK:
		/* Puts the current process to sleep, return unlocked */
		error = systrace_msg_ask(fst, strp, code, callp->sy_argsize, v);

		/* lock has been released in systrace_msg_ask() */
		fst = NULL;
		/* We might have detached by now for some reason */
		if (!error && (strp = p->p_systrace) != NULL) {
			/* XXX - do I need to lock here? */
			if (strp->answer == SYSTR_POLICY_NEVER) {
				error = strp->error;
				if (strp->replace != NULL) {
					free(strp->replace, M_XDATA);
					strp->replace = NULL;
				}
			} else {
				if (ISSET(strp->flags, STR_PROC_SYSCALLRES)) {
					CLR(strp->flags, STR_PROC_SYSCALLRES);
					report = 1;
				}
				/* Replace the arguments if necessary */
				if (strp->replace != NULL) {
					error = systrace_replace(strp, callp->sy_argsize, v);
				}
			}
d736 1
a736 10
		break;
	default:
		if (policy > 0)
			error = policy;
		else
			error = EPERM;
		break;
	}

	if (fst) {
d738 3
a740 1
		fst = NULL;
d743 3
d750 29
d785 9
a793 11
	systrace_lock();
	if ((strp = p->p_systrace) != NULL) {
		if (issuser) {
			if (ISSET(strp->flags, STR_PROC_SETEUID))
				strp->saveuid = systrace_seteuid(p, strp->seteuid);
			if (ISSET(strp->flags, STR_PROC_SETEGID))
				strp->savegid = systrace_setegid(p, strp->setegid);
		} else
			CLR(strp->flags, STR_PROC_SETEUID|STR_PROC_SETEGID);
	}
	systrace_unlock();
d817 2
d867 1
d1000 4
d1254 2
d1257 1
a1257 2
	struct systrace_replace *repl = strp->replace;
	caddr_t sg, kdata, udata, kbase, ubase;
d1276 5
a1291 2
	free(repl, M_XDATA);
	strp->replace = NULL;
d1295 56
d1400 1
a1400 2
	if (strp->replace)
		free(strp->replace, M_XDATA);
@


1.31
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.30 2003/06/16 06:36:40 itojun Exp $	*/
d48 1
d63 1
a63 1
int	systraceselect(dev_t, int, struct proc *);
d70 1
a70 1
int	systracef_select(struct file *, int, struct proc *);
d156 1
a156 1
	systracef_select,
d365 1
a365 1
systracef_select(fp, which, p)
d367 1
a367 1
	int which;
d371 1
a371 1
	int ready = 0;
d373 1
a373 1
	if (which != FREAD)
d379 3
a381 2
	ready = TAILQ_FIRST(&fst->messages) != NULL;
	if (!ready)
d385 1
a385 1
	return (ready);
d563 1
a563 1
systraceselect(dev, rw, p)
d565 1
a565 1
	int	rw;
d568 1
a568 1
	return (0);
@


1.30
log
@- limited number of processes per systrace
- escape fixes for special characters
markus, sturm ok.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.29 2003/03/28 12:40:01 henning Exp $	*/
d536 1
a536 1
		if (suser(p->p_ucred, &p->p_acflag) == 0)
d1158 1
a1158 1
	    (error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.29
log
@unbreak
STRIOCCLONE and SYSTR_CLONE have the same value now

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.28 2003/02/20 22:03:31 art Exp $	*/
d142 1
d1378 17
a1394 2
	if (fst->npolicies > SYSTR_MAX_POLICIES && !fst->issuser)
		return (NULL);
d1509 1
a1509 1
			return (EINTR);
d1543 23
@


1.28
log
@Fix a crash in the systrace found by form@@
One is a kernel fix that changes the lockin and one is a userland fix that
prevents dereferencing a freed pointer.
From provos
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.27 2002/12/12 08:36:05 art Exp $	*/
a525 1
	case SYSTR_CLONE:
@


1.28.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.28 2003/02/20 22:03:31 art Exp $	*/
d526 1
@


1.28.4.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a47 2
#include <sys/namei.h>
#include <sys/poll.h>
d62 1
a62 1
int	systracepoll(dev_t, int, struct proc *);
d69 1
a69 1
int	systracef_poll(struct file *, int, struct proc *);
a105 2
	char *fname[SYSTR_MAXFNAME];
	size_t nfname;
d120 2
a121 13
struct lock systrace_lck;

static __inline void
systrace_lock(void)
{
	lockmgr(&systrace_lck, LK_EXCLUSIVE, NULL, curproc);
}

static __inline void
systrace_unlock(void)
{
	lockmgr(&systrace_lck, LK_RELEASE, NULL, curproc);
}
a132 2
int	systrace_fname(struct str_process *, caddr_t, size_t);
void	systrace_replacefree(struct str_process *);
a141 1
int	systrace_msg_policyfree(struct fsystrace *, struct str_policy *);
d154 1
a154 1
	systracef_poll,
d164 1
d363 1
a363 1
systracef_poll(fp, events, p)
d365 1
a365 1
	int events;
d369 1
a369 1
	int revents = 0;
d371 1
a371 1
	if ((events & (POLLIN | POLLRDNORM)) == 0)
d377 2
a378 3
	if (!TAILQ_EMPTY(&fst->messages))
		revents = events & (POLLIN | POLLRDNORM);
	else
d382 1
a382 1
	return (revents);
d453 12
d535 1
a535 1
		if (suser(p, 0) == 0)
d560 1
a560 1
systracepoll(dev, events, p)
d562 1
a562 1
	int	events;
d565 1
a565 1
	return (seltrue(dev, events, p));
d721 37
d759 1
a759 9
	/* Fast-path */
	if (policy != SYSTR_POLICY_ASK) {
		if (policy != SYSTR_POLICY_PERMIT) {
			if (policy > 0)
				error = policy;
			else
				error = EPERM;
		}
		systrace_replacefree(strp);
d761 1
a761 3
		if (policy == SYSTR_POLICY_PERMIT)
			error = (*callp->sy_call)(p, v, retval);
		return (error);
a763 3
	/* Puts the current process to sleep, return unlocked */
	error = systrace_msg_ask(fst, strp, code, callp->sy_argsize, v);
	/* lock has been released in systrace_msg_ask() */
a767 29
	/* We might have detached by now for some reason */
	systrace_lock();
	if ((strp = p->p_systrace) == NULL) {
		systrace_unlock();
		return (error);
	}

	fst = strp->parent;
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
	systrace_unlock();

	if (strp->answer == SYSTR_POLICY_NEVER) {
		error = strp->error;
		systrace_replacefree(strp);
		goto out_unlock;
	}

	if (ISSET(strp->flags, STR_PROC_SYSCALLRES)) {
		CLR(strp->flags, STR_PROC_SYSCALLRES);
		report = 1;
	}

	/* Replace the arguments if necessary */
	if (strp->replace != NULL) {
		error = systrace_replace(strp, callp->sy_argsize, v);
		if (error)
			goto out_unlock;
	}

d774 11
a784 9
	if (issuser) {
		if (ISSET(strp->flags, STR_PROC_SETEUID))
			strp->saveuid = systrace_seteuid(p, strp->seteuid);
		if (ISSET(strp->flags, STR_PROC_SETEGID))
			strp->savegid = systrace_setegid(p, strp->setegid);
	} else
		CLR(strp->flags, STR_PROC_SETEUID|STR_PROC_SETEGID);

	lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
a807 2
	systrace_replacefree(strp);

a855 1
 out_unlock:
a987 4

		/* LRU for policy use */
		TAILQ_REMOVE(&fst->policies, strpol, next);
		TAILQ_INSERT_TAIL(&fst->policies, strpol, next);
d1151 2
a1152 2
	 *	this prevents a setuid process which revokes its
	 *	special privileges using setuid() from being
d1157 1
a1157 1
	    (error = suser(p, 0)) != 0)
d1238 1
d1240 1
a1240 3
	caddr_t kdata, kbase;
	struct proc *p = strp->proc;
	caddr_t sg, udata, ubase;
a1258 5
		if (repl->strr_flags[i] & SYSTR_NOLINKS) {
			ret = systrace_fname(strp, kdata, repl->strr_offlen[i]);
			if (ret != 0)
				goto out;
		}
d1270 2
a1274 56
int
systrace_fname(struct str_process *strp, caddr_t kdata, size_t len)
{

	if (strp->nfname >= SYSTR_MAXFNAME || len < 2)
		return EINVAL;

	strp->fname[strp->nfname] = kdata;
	strp->fname[strp->nfname][len - 1] = '\0';
	strp->nfname++;

	return 0;
}

void
systrace_replacefree(struct str_process *strp)
{
	if (strp->replace != NULL) {
		free(strp->replace, M_XDATA);
		strp->replace = NULL;
	}
	while (strp->nfname > 0) {
		strp->nfname--;
		strp->fname[strp->nfname] = NULL;
	}
}

void
systrace_namei(struct nameidata *ndp)
{
	struct str_process *strp;
	struct fsystrace *fst;
	struct componentname *cnp = &ndp->ni_cnd;
	size_t i;

	systrace_lock();
	strp = cnp->cn_proc->p_systrace;
	if (strp != NULL) {
		fst = strp->parent;
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, curproc);
		systrace_unlock();

		for (i = 0; i < strp->nfname; i++) {
			if (strcmp(cnp->cn_pnbuf, strp->fname[i]) == 0) {
				/* ELOOP if namei() tries to readlink */
				ndp->ni_loopcnt = MAXSYMLINKS;
				cnp->cn_flags &= ~FOLLOW;
				cnp->cn_flags |= NOFOLLOW;
				break;
			}
		}
		lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
	} else
		systrace_unlock();
}

d1324 2
a1325 1
	systrace_replacefree(strp);
d1377 2
a1378 17
	if (fst->npolicies > SYSTR_MAX_POLICIES && !fst->issuser) {
		struct str_policy *tmp;

		/* Try to find a policy for freeing */
		TAILQ_FOREACH(tmp, &fst->policies, next) {
			if (tmp->refcount == 1)
				break;
		}

		if (tmp == NULL)
			return (NULL);

		/* Notify userland about freed policy */
		systrace_msg_policyfree(fst, tmp);
		/* Free this policy */
		systrace_closepolicy(fst, tmp);
	}
d1493 1
a1493 1
			return (ERESTART);
a1526 23

	TAILQ_INSERT_TAIL(&fst->messages, nstrp, msg_next);

	systrace_wakeup(fst);

	return (0);
}

int
systrace_msg_policyfree(struct fsystrace *fst, struct str_policy *strpol)
{
	struct str_process *nstrp;
	struct str_message *msg;

	nstrp = pool_get(&systr_proc_pl, PR_WAITOK);
	memset(nstrp, 0, sizeof(struct str_process));

	DPRINTF(("%s: free %d\n", __func__, strpol->nr));

	msg = &nstrp->msg;

	msg->msg_type = SYSTR_MSG_POLICYFREE;
	msg->msg_policy = strpol->nr;
@


1.27
log
@statement after label.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.26 2002/12/04 17:37:39 mickey Exp $	*/
d648 12
d765 1
d775 3
a777 3
	if (issuser) {
		systrace_lock();
		if ((strp = p->p_systrace) != NULL) {
d782 4
a785 4
		}
		systrace_unlock();
	} else
		CLR(strp->flags, STR_PROC_SETEUID|STR_PROC_SETEGID);
d790 6
d797 9
a805 12
		systrace_lock();
		if ((strp = p->p_systrace) != NULL) {
			if (ISSET(strp->flags, STR_PROC_SETEUID)) {
				if (pc->pc_ucred->cr_uid == strp->seteuid)
					systrace_seteuid(p, strp->saveuid);
				CLR(strp->flags, STR_PROC_SETEUID);
			}
			if (ISSET(strp->flags, STR_PROC_SETEGID)) {
				if (pc->pc_ucred->cr_gid == strp->setegid)
					systrace_setegid(p, strp->savegid);
				CLR(strp->flags, STR_PROC_SETEGID);
			}
a806 1
		systrace_unlock();
d810 2
a811 5
		/* Stupid Locking not necessary */
		if ((strp = p->p_systrace) == NULL ||
		    (fst = strp->parent) == NULL)
			return (error);
		if (!fst->issuser)
d813 1
a816 2
	systrace_lock();
	strp = p->p_systrace;
d819 1
a819 1
	if (strp != NULL && ISSET(strp->flags, STR_PROC_REPORT)) {
d824 4
a827 4
	if (p->p_emul != oldemul && strp != NULL) {
		fst = strp->parent;
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
		systrace_unlock();
d829 1
d836 3
a838 2
	} else
		systrace_unlock();
d843 1
a843 9
		systrace_lock();
		if ((strp = p->p_systrace) == NULL) {
			systrace_unlock();
			goto nougid;
		}

		fst = strp->parent;
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
		systrace_unlock();
d845 1
a845 3
		systrace_msg_ugid(fst, strp);
	nougid:
		;
d849 1
a849 6
	systrace_lock();
	if (report && (strp = p->p_systrace) != NULL) {
		fst = strp->parent;
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
		systrace_unlock();

a851 2
	} else
		systrace_unlock();
d853 6
@


1.26
log
@rename the clone ioctl to avoid clashing w/ the sockio; provos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.25 2002/11/10 04:34:56 art Exp $	*/
d842 1
@


1.25
log
@Be more careful with illegal syscall numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.c,v 1.24 2002/10/25 23:22:58 fgsch Exp $	*/
d525 1
@


1.24
log
@add id tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d663 5
@


1.23
log
@support for privilege elevation.

with privilege elevation no suid or sgid binaries are necessary any
longer.  Applications can be executed completely
unprivileged. Systrace raises the privileges for a single system call
depending on the configured policy.

Idea from discussions with Perry Metzger, Dug Song and Marcus Watts.

from provos
@
text
@d1 1
@


1.22
log
@new message to track uid/gid changes
from provos
@
text
@d63 2
d91 2
d111 5
d653 5
a657 1
	int policy, error = 0, report = 0, maycontrol = 0;
d680 1
a680 1
	if (fst->issuser)
d682 2
a683 1
	else if (!(p->p_flag & P_SUGID)) {
d746 16
a761 14
	if (!error) {
		struct emul *oldemul = p->p_emul;
		uid_t olduid = p->p_cred->p_ruid;
		gid_t oldgid = p->p_cred->p_rgid;

		error = (*callp->sy_call)(p, v, retval);

		if (p->p_flag & P_SUGID) {
			/* Stupid Locking not necessary */
			if ((strp = p->p_systrace) == NULL ||
			    (fst = strp->parent) == NULL)
				return (error);
			if (!fst->issuser)
				return (error);
d763 5
d769 2
a770 1
		/* Report change in emulation */
d772 11
a782 6
		strp = p->p_systrace;

		/* See if we should force a report */
		if (strp != NULL && ISSET(strp->flags, STR_PROC_REPORT)) {
			CLR(strp->flags, STR_PROC_REPORT);
			oldemul = NULL;
d784 2
d787 8
a794 4
		if (p->p_emul != oldemul && strp != NULL) {
			fst = strp->parent;
			lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
			systrace_unlock();
d796 3
a798 8
			/* Old policy is without meaning now */
			if (strp->policy) {
				systrace_closepolicy(fst, strp->policy);
				strp->policy = NULL;
			}
			systrace_msg_emul(fst, strp);
		} else
			systrace_unlock();
d800 5
a804 8
		/* Report if effective uid or gid changed */
		if (olduid != p->p_cred->p_ruid ||
		    oldgid != p->p_cred->p_rgid) {
			systrace_lock();
			if ((strp = p->p_systrace) == NULL) {
				systrace_unlock();
				goto nougid;
			}
d806 4
a809 3
			fst = strp->parent;
			lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
			systrace_unlock();
d811 4
a814 2
			systrace_msg_ugid(fst, strp);
		nougid:
d816 3
d820 3
a822 1
		/* Report result from system call */
d824 1
a824 3
		if (report && (strp = p->p_systrace) != NULL) {
			fst = strp->parent;
			lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
d826 2
d829 6
a834 4
			systrace_msg_result(fst, strp, error, code,
			    callp->sy_argsize, v, retval);
		} else
			systrace_unlock();
d837 12
d852 38
d920 11
@


1.21
log
@cast size_t to u_long on printing.  from netbsd
@
text
@d137 1
d734 2
d772 17
d1342 12
@


1.20
log
@return EBUSY in processready
@
text
@d944 2
a945 2
	DPRINTF(("%s: %u: %p(%d)\n", __func__,
	    io->strio_pid, io->strio_offs, io->strio_len));
d1259 2
a1260 2
	DPRINTF(("%s: allocating %d -> %d\n", __func__,
		     maxents, maxents * sizeof(int)));
@


1.19
log
@minor KNF.  pid_t is unsigned.
@
text
@d895 1
a895 1
		return (EINVAL);
d898 1
a898 1
		return (EINVAL);
@


1.18
log
@whitespace at EOL
@
text
@d298 1
a298 1
		DPRINTF(("%s: attach to %d: %d\n", __func__, pid, ret));
d792 2
a793 2
	DPRINTF(("%s: %d: policy %d\n", __func__,
		    ans->stra_pid, ans->stra_policy));
d872 1
a872 1
			    pol->strp_num, pol->strp_code, pol->strp_policy));
d944 2
a945 2
	DPRINTF(("%s: %d: %p(%d)\n", __func__,
		    io->strio_pid, io->strio_offs, io->strio_len));
@


1.17
log
@better uid/gid tracking; okay deraadt@@
@
text
@d236 1
a236 1
	
d279 1
a279 1
	
d791 1
a791 1
	
d864 1
a864 1
		
d943 1
a943 1
	
d1023 1
a1023 1
	 * 
d1159 1
a1159 1
	
d1174 1
a1174 1
	
d1187 1
a1187 1
	
d1379 1
a1379 1
	
@


1.16
log
@prevent double free in some error conditions; from xs@@kittenz.org
@
text
@d526 2
d643 1
a643 1
	int policy, error = 0, report = 0;
d659 15
a673 4
	if ((p->p_flag & P_SUGID) && !fst->issuser) {
		/* We can not monitor a SUID process unless we are root,
		 * but we wait until it executes something unprivileged.
		 */
@


1.15
log
@add seqnr to message from kernel, userland needs to quote correct seqnr.
avoids problems where tsleep has been interrupted by a signal.
@
text
@d1051 1
a1051 1
	if (strp->replace != NULL)
d1053 2
@


1.14
log
@two more missing systrace_lock
@
text
@d88 1
d105 1
d787 6
d1317 1
@


1.13
log
@need systrace_lock/unlock around lockmgr lock operation.  provos ok
@
text
@d278 1
d280 1
d401 1
d403 1
@


1.12
log
@comment clarification.  niels ok
@
text
@d359 1
d361 1
@


1.11
log
@minor KNF
@
text
@d674 2
a676 1
		fst = NULL;
@


1.10
log
@whitespace
@
text
@d672 1
a672 1
		error = systrace_msg_ask(fst,strp, code, callp->sy_argsize, v);
@


1.9
log
@tabify
@
text
@d237 2
a238 2
        case FIOASYNC:
                return (0);
d246 1
a246 1
 	case STRIOCANSWER:
d251 1
a251 1
 	case STRIOCIO:
d256 1
a256 1
 	case STRIOCGETCWD:
d265 1
a265 1
 	case STRIOCREPLACE:
d518 1
a518 1
    
@


1.8
log
@do not call unlock when the lock is not locked; found by millert@@
@
text
@d138 7
a144 7
    systracef_read,
    systracef_write,
    systracef_ioctl,
    systracef_select,
    systracef_kqfilter,
    systracef_stat,
    systracef_close
@


1.7
log
@in the error case, just remove an installed argument replacement, it is not
needed
@
text
@a239 8
	case STRIOCATTACH:
		pid = *(pid_t *)data;
		if (!pid)
			ret = EINVAL;
		else
			ret = systrace_attach(fst, pid);
		DPRINTF(("%s: attach to %d: %d\n", __func__, pid, ret));
		goto unlock;
a245 19
	case STRIOCRESCWD:
		if (!fst->fd_pid) {
			ret = EINVAL;
			goto unlock;
		}
		fdp = p->p_fd;

		/* Release cwd from other process */
		if (fdp->fd_cdir)
			vrele(fdp->fd_cdir);
		if (fdp->fd_rdir)
			vrele(fdp->fd_rdir);
		/* This restores the cwd we had before */
		fdp->fd_cdir = fst->fd_cdir;
		fdp->fd_rdir = fst->fd_rdir;
		/* Note that we are normal again */
		fst->fd_pid = 0;
		fst->fd_cdir = fst->fd_rdir = NULL;
		goto unlock;
d261 2
d288 8
d313 19
@


1.6
log
@system call argument rewriting framework via stackgap; okay art@@
@
text
@d676 1
a676 1
			if (strp->answer == SYSTR_POLICY_NEVER)
d678 5
a682 1
			else {
@


1.5
log
@more __FUNCTION__ slaughter
@
text
@d48 2
d99 2
d118 2
d290 5
d328 3
d678 9
a686 3
			else if (ISSET(strp->flags, STR_PROC_SYSCALLRES)) {
				CLR(strp->flags, STR_PROC_SYSCALLRES);
				report = 1;
d772 1
a772 6
	if (ISSET(strp->flags, STR_PROC_ONQUEUE)) {
		error = EINVAL;
		goto out;
	}
	if (!ISSET(strp->flags, STR_PROC_WAITANSWER)) {
		error = EINVAL;
a773 1
	}
d1018 96
d1163 2
d1179 1
a1179 1
		FREE(policy->sysent, M_XDATA);
d1228 1
a1228 1
	MALLOC(pol->sysent, u_char *, maxents * sizeof(u_char),
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d85 1
d240 1
a240 1
		DPRINTF(("%s: attach to %d: %d\n", __FUNCTION__, pid, ret));
d243 1
d305 3
d699 9
a707 1
		if (p->p_emul != oldemul && (strp = p->p_systrace) != NULL) {
d744 1
a744 1
	DPRINTF(("%s: %d: policy %d\n", __FUNCTION__,
d784 1
a784 1
		DPRINTF(("%s: new, ents %d\n", __FUNCTION__,
d794 1
a794 1
		DPRINTF(("%s: %d -> pid %d\n", __FUNCTION__,
d823 1
a823 1
		DPRINTF(("%s: %d: code %d -> policy %d\n", __FUNCTION__,
d864 1
a864 1
	DPRINTF(("%s: %d\n", __FUNCTION__, strp->pid));
d896 1
a896 1
	DPRINTF(("%s: %d: %p(%d)\n", __FUNCTION__,
d999 1
d1029 1
a1029 1
	DPRINTF(("%s: Trying to detach from %d\n", __FUNCTION__, strp->pid));
d1111 1
a1111 1
	DPRINTF(("%s: allocating %d -> %d\n", __FUNCTION__,
d1228 1
a1228 1
	DPRINTF(("%s: %p: pid %d -> pid %d\n", __FUNCTION__,
@


1.5.2.2
log
@sync to -current
@
text
@a0 1
/*	$OpenBSD$	*/
a47 2
#include <compat/common/compat_util.h>

a60 2
uid_t	systrace_seteuid(struct proc *,  uid_t);
gid_t	systrace_setegid(struct proc *,  gid_t);
a84 4
#define STR_PROC_REPORT		0x08	/* Report emulation */
#define STR_PROC_NEEDSEQNR	0x10	/* Answer must quote seqnr */
#define STR_PROC_SETEUID	0x20	/* Elevate privileges */
#define STR_PROC_SETEGID	0x40
a95 2
	struct systrace_replace *replace;

a98 6
	u_int16_t seqnr;	/* expected reply sequence number */

	uid_t seteuid;
	uid_t saveuid;
	gid_t setegid;
	gid_t savegid;
a112 2
int	systrace_preprepl(struct str_process *, struct systrace_replace *);
int	systrace_replace(struct str_process *, size_t, register_t []);
a127 1
int	systrace_msg_ugid(struct fsystrace *, struct str_process *);
d131 7
a137 7
	systracef_read,
	systracef_write,
	systracef_ioctl,
	systracef_select,
	systracef_kqfilter,
	systracef_stat,
	systracef_close
d227 1
a227 1

d230 2
a231 2
	case FIOASYNC:
		return (0);
d233 8
a241 1
	case STRIOCREPORT:
d246 20
a265 1
	case STRIOCANSWER:
d270 1
a270 1
	case STRIOCIO:
d275 1
a275 1
	case STRIOCGETCWD:
a279 2
	case STRIOCATTACH:
	case STRIOCRESCWD:
a281 5
	case STRIOCREPLACE:
		pid = ((struct systrace_replace *)data)->strr_pid;
		if (!pid)
			ret = EINVAL;
		break;
d289 1
a289 2

	systrace_lock();
a290 1
	systrace_unlock();
a299 8
	case STRIOCATTACH:
		pid = *(pid_t *)data;
		if (!pid)
			ret = EINVAL;
		else
			ret = systrace_attach(fst, pid);
		DPRINTF(("%s: attach to %u: %d\n", __func__, pid, ret));
		break;
a302 3
	case STRIOCREPORT:
		SET(strp->flags, STR_PROC_REPORT);
		break;
a311 22
	case STRIOCREPLACE:
		ret = systrace_preprepl(strp, (struct systrace_replace *)data);
		break;
	case STRIOCRESCWD:
		if (!fst->fd_pid) {
			ret = EINVAL;
			break;
		}
		fdp = p->p_fd;

		/* Release cwd from other process */
		if (fdp->fd_cdir)
			vrele(fdp->fd_cdir);
		if (fdp->fd_rdir)
			vrele(fdp->fd_rdir);
		/* This restores the cwd we had before */
		fdp->fd_cdir = fst->fd_cdir;
		fdp->fd_rdir = fst->fd_rdir;
		/* Note that we are normal again */
		fst->fd_pid = 0;
		fst->fd_cdir = fst->fd_rdir = NULL;
		break;
a337 1
	systrace_lock();
a338 1
	systrace_unlock();
a375 1
	systrace_lock();
a376 1
	systrace_unlock();
d497 1
a497 3
		fst->p_ruid = p->p_cred->p_ruid;
		fst->p_rgid = p->p_cred->p_rgid;

d612 1
a612 5
	struct emul *oldemul;
	struct pcred *pc;
	uid_t olduid;
	gid_t oldgid;
	int policy, error = 0, report = 0, maycontrol = 0, issuser = 0;
d628 4
a631 16
	/*
	 * We can not monitor a SUID process unless we are root,
	 * but we wait until it executes something unprivileged.
	 * A non-root user may only monitor if the real uid and
	 * real gid match the monitored process.  Changing the
	 * uid or gid causes P_SUGID to be set.
	 */
	if (fst->issuser) {
		maycontrol = 1;
		issuser =1 ;
	} else if (!(p->p_flag & P_SUGID)) {
		maycontrol = fst->p_ruid == p->p_cred->p_ruid &&
		    fst->p_rgid == p->p_cred->p_rgid;
	}

	if (!maycontrol) {
d651 1
a651 1
		error = systrace_msg_ask(fst, strp, code, callp->sy_argsize, v);
d653 1
a653 1
		/* lock has been released in systrace_msg_ask() */
a654 1
		/* We might have detached by now for some reason */
d657 1
a657 1
			if (strp->answer == SYSTR_POLICY_NEVER) {
d659 3
a661 13
				if (strp->replace != NULL) {
					free(strp->replace, M_XDATA);
					strp->replace = NULL;
				}
			} else {
				if (ISSET(strp->flags, STR_PROC_SYSCALLRES)) {
					CLR(strp->flags, STR_PROC_SYSCALLRES);
					report = 1;
				}
				/* Replace the arguments if necessary */
				if (strp->replace != NULL) {
					error = systrace_replace(strp, callp->sy_argsize, v);
				}
d678 4
a681 2
	if (error)
		return (error);
d683 7
a689 13
	oldemul = p->p_emul;
	pc = p->p_cred;
	olduid = pc->p_ruid;
	oldgid = pc->p_rgid;
		
	/* Elevate privileges as desired */
	if (issuser) {
		systrace_lock();
		if ((strp = p->p_systrace) != NULL) {
			if (ISSET(strp->flags, STR_PROC_SETEUID))
				strp->saveuid = systrace_seteuid(p, strp->seteuid);
			if (ISSET(strp->flags, STR_PROC_SETEGID))
				strp->savegid = systrace_setegid(p, strp->setegid);
a690 5
		systrace_unlock();
	} else
		CLR(strp->flags, STR_PROC_SETEUID|STR_PROC_SETEGID);
				
	error = (*callp->sy_call)(p, v, retval);
d692 1
a692 2
	/* Return to old privileges */
	if (issuser) {
d694 9
a702 5
		if ((strp = p->p_systrace) != NULL) {
			if (ISSET(strp->flags, STR_PROC_SETEUID)) {
				if (pc->pc_ucred->cr_uid == strp->seteuid)
					systrace_seteuid(p, strp->saveuid);
				CLR(strp->flags, STR_PROC_SETEUID);
d704 3
a706 41
			if (ISSET(strp->flags, STR_PROC_SETEGID)) {
				if (pc->pc_ucred->cr_gid == strp->setegid)
					systrace_setegid(p, strp->savegid);
				CLR(strp->flags, STR_PROC_SETEGID);
			}
		}
		systrace_unlock();
	}

	if (p->p_flag & P_SUGID) {
		/* Stupid Locking not necessary */
		if ((strp = p->p_systrace) == NULL ||
		    (fst = strp->parent) == NULL)
			return (error);
		if (!fst->issuser)
			return (error);
	}

	/* Report change in emulation */
	systrace_lock();
	strp = p->p_systrace;

	/* See if we should force a report */
	if (strp != NULL && ISSET(strp->flags, STR_PROC_REPORT)) {
		CLR(strp->flags, STR_PROC_REPORT);
		oldemul = NULL;
	}

	if (p->p_emul != oldemul && strp != NULL) {
		fst = strp->parent;
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
		systrace_unlock();

		/* Old policy is without meaning now */
		if (strp->policy) {
			systrace_closepolicy(fst, strp->policy);
			strp->policy = NULL;
		}
		systrace_msg_emul(fst, strp);
	} else
		systrace_unlock();
d708 1
a708 3
	/* Report if effective uid or gid changed */
	if (olduid != p->p_cred->p_ruid ||
	    oldgid != p->p_cred->p_rgid) {
d710 3
a712 1
		if ((strp = p->p_systrace) == NULL) {
a713 2
			goto nougid;
		}
d715 4
a718 6
		fst = strp->parent;
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
		systrace_unlock();

		systrace_msg_ugid(fst, strp);
	nougid:
a720 12
	/* Report result from system call */
	systrace_lock();
	if (report && (strp = p->p_systrace) != NULL) {
		fst = strp->parent;
		lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
		systrace_unlock();

		systrace_msg_result(fst, strp, error, code,
		    callp->sy_argsize, v, retval);
	} else
		systrace_unlock();

a723 38
uid_t
systrace_seteuid(struct proc *p,  uid_t euid)
{
	struct pcred *pc = p->p_cred;
	uid_t oeuid = pc->pc_ucred->cr_uid;

	if (pc->pc_ucred->cr_uid == euid)
		return (oeuid);

	/*
	 * Copy credentials so other references do not see our changes.
	 */
	pc->pc_ucred = crcopy(pc->pc_ucred);
	pc->pc_ucred->cr_uid = euid;
	p->p_flag |= P_SUGID;

	return (oeuid);
}

gid_t
systrace_setegid(struct proc *p,  gid_t egid)
{
	struct pcred *pc = p->p_cred;
	gid_t oegid = pc->pc_ucred->cr_gid;

	if (pc->pc_ucred->cr_gid == egid)
		return (oegid);

	/*
	 * Copy credentials so other references do not see our changes.
	 */
	pc->pc_ucred = crcopy(pc->pc_ucred);
	pc->pc_ucred->cr_gid = egid;
	p->p_flag |= P_SUGID;

	return (oegid);
}

d730 3
a732 3

	DPRINTF(("%s: %u: policy %d\n", __func__,
	    ans->stra_pid, ans->stra_policy));
d739 2
a740 3
	/* Check if answer is in sync with us */
	if (ans->stra_seqnr != strp->seqnr) {
		error = ESRCH;
d743 2
a744 2

	if ((error = systrace_processready(strp)) != 0)
d746 1
a754 11
	/* See if we should elevate privileges for this system call */
	if (ISSET(ans->stra_flags, SYSTR_FLAGS_SETEUID)) {
		SET(strp->flags, STR_PROC_SETEUID);
		strp->seteuid = ans->stra_seteuid;
	}
	if (ISSET(ans->stra_flags, SYSTR_FLAGS_SETEGID)) {
		SET(strp->flags, STR_PROC_SETEGID);
		strp->setegid = ans->stra_setegid;
	}
	

d771 1
a771 1
		DPRINTF(("%s: new, ents %d\n", __func__,
d781 1
a781 1
		DPRINTF(("%s: %d -> pid %d\n", __func__,
d803 1
a803 1

d810 2
a811 2
		DPRINTF(("%s: %d: code %d -> policy %d\n", __func__,
		    pol->strp_num, pol->strp_code, pol->strp_policy));
d834 1
a834 1
		return (EBUSY);
d837 1
a837 1
		return (EBUSY);
d851 1
a851 1
	DPRINTF(("%s: %d\n", __func__, strp->pid));
d882 3
a884 3

	DPRINTF(("%s: %u: %p(%lu)\n", __func__,
	    io->strio_pid, io->strio_offs, (u_long)io->strio_len));
d962 1
a962 1
	 *
a985 1

a989 98
/* Prepare to replace arguments */

int
systrace_preprepl(struct str_process *strp, struct systrace_replace *repl)
{
	size_t len;
	int i, ret = 0;

	ret = systrace_processready(strp);
	if (ret)
		return (ret);

	if (strp->replace != NULL) {
		free(strp->replace, M_XDATA);
		strp->replace = NULL;
	}

	if (repl->strr_nrepl < 0 || repl->strr_nrepl > SYSTR_MAXARGS)
		return (EINVAL);

	for (i = 0, len = 0; i < repl->strr_nrepl; i++) {
		len += repl->strr_offlen[i];
		if (repl->strr_offlen[i] == 0)
			continue;
		if (repl->strr_offlen[i] + repl->strr_off[i] > len)
			return (EINVAL);
	}

	/* Make sure that the length adds up */
	if (repl->strr_len != len)
		return (EINVAL);

	/* Check against a maximum length */
	if (repl->strr_len > 2048)
		return (EINVAL);

	strp->replace = (struct systrace_replace *)
	    malloc(sizeof(struct systrace_replace) + len, M_XDATA, M_WAITOK);

	memcpy(strp->replace, repl, sizeof(struct systrace_replace));
	ret = copyin(repl->strr_base, strp->replace + 1, len);
	if (ret) {
		free(strp->replace, M_XDATA);
		strp->replace = NULL;
		return (ret);
	}

	/* Adjust the offset */
	repl = strp->replace;
	repl->strr_base = (caddr_t)(repl + 1);

	return (0);
}

/*
 * Replace the arguments with arguments from the monitoring process.
 */

int
systrace_replace(struct str_process *strp, size_t argsize, register_t args[])
{
	struct proc *p = strp->proc;
	struct systrace_replace *repl = strp->replace;
	caddr_t sg, kdata, udata, kbase, ubase;
	int i, maxarg, ind, ret = 0;

	maxarg = argsize/sizeof(register_t);
	sg = stackgap_init(p->p_emul);
	ubase = stackgap_alloc(&sg, repl->strr_len);

	kbase = repl->strr_base;
	for (i = 0; i < maxarg && i < repl->strr_nrepl; i++) {
		ind = repl->strr_argind[i];
		if (ind < 0 || ind >= maxarg) {
			ret = EINVAL;
			goto out;
		}
		if (repl->strr_offlen[i] == 0) {
			args[ind] = repl->strr_off[i];
			continue;
		}
		kdata = kbase + repl->strr_off[i];
		udata = ubase + repl->strr_off[i];
		if (copyout(kdata, udata, repl->strr_offlen[i])) {
			ret = EINVAL;
			goto out;
		}

		/* Replace the argument with the new address */
		args[ind] = (register_t)udata;
	}

 out:
	free(repl, M_XDATA);
	strp->replace = NULL;
	return (ret);
}

d999 1
a999 1

d1014 2
a1015 2

	DPRINTF(("%s: Trying to detach from %d\n", __func__, strp->pid));
d1027 1
a1027 1

a1038 2
	if (strp->replace)
		free(strp->replace, M_XDATA);
d1053 1
a1053 1
		free(policy->sysent, M_XDATA);
d1097 2
a1098 2
	DPRINTF(("%s: allocating %d -> %lu\n", __func__,
		     maxents, (u_long)maxents * sizeof(int)));
d1102 1
a1102 1
	pol->sysent = (u_char *)malloc(maxents * sizeof(u_char),
a1162 12
systrace_msg_ugid(struct fsystrace *fst, struct str_process *strp)
{
	struct str_msg_ugid *msg_ugid = &strp->msg.msg_data.msg_ugid;
	struct proc *p = strp->proc;

	msg_ugid->uid = p->p_cred->p_ruid;
	msg_ugid->gid = p->p_cred->p_rgid;

	return (systrace_make_msg(strp, SYSTR_MSG_UGID));
}

int
a1169 1
	msg->msg_seqnr = ++strp->seqnr;
d1214 1
a1214 1
	DPRINTF(("%s: %p: pid %d -> pid %d\n", __func__,
d1216 1
a1216 1

@


1.5.2.3
log
@sync
@
text
@d525 1
a525 1
	case STRIOCCLONE:
a646 12
#define REACQUIRE_LOCK	do { \
	systrace_lock(); \
	strp = p->p_systrace; \
	if (strp == NULL) { \
		systrace_unlock(); \
		return (error); \
	} \
	fst = strp->parent; \
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p); \
	systrace_unlock(); \
} while (0)

a666 5
	if (code < 0 || code >= p->p_emul->e_nsysent) {
		systrace_unlock();
		return (EINVAL);
	}

a746 1

d756 3
a758 3
	systrace_lock();
	if ((strp = p->p_systrace) != NULL) {
		if (issuser) {
d763 4
a766 4
		} else
			CLR(strp->flags, STR_PROC_SETEUID|STR_PROC_SETEGID);
	}
	systrace_unlock();
a770 6
	systrace_lock();
	if ((strp = p->p_systrace) == NULL) {
		systrace_unlock();
		return (error);
	}

d772 12
a783 9
		if (ISSET(strp->flags, STR_PROC_SETEUID)) {
			if (pc->pc_ucred->cr_uid == strp->seteuid)
				systrace_seteuid(p, strp->saveuid);
			CLR(strp->flags, STR_PROC_SETEUID);
		}
		if (ISSET(strp->flags, STR_PROC_SETEGID)) {
			if (pc->pc_ucred->cr_gid == strp->setegid)
				systrace_setegid(p, strp->savegid);
			CLR(strp->flags, STR_PROC_SETEGID);
d785 1
d789 5
a793 2
		if ((fst = strp->parent) == NULL || !fst->issuser) {
			systrace_unlock();
a794 1
		}
d798 2
d802 1
a802 1
	if (ISSET(strp->flags, STR_PROC_REPORT)) {
d807 4
a810 4
	/* Acquire lock */
	fst = strp->parent;
	lockmgr(&fst->lock, LK_EXCLUSIVE, NULL, p);
	systrace_unlock();
a811 1
	if (p->p_emul != oldemul) {
d818 2
a819 3

		REACQUIRE_LOCK;
	}
d824 10
d835 1
a835 2

		REACQUIRE_LOCK;
d839 6
a844 1
	if (report) {
d847 2
a849 6
		/* not locked */
		goto out;
	}

	lockmgr(&fst->lock, LK_RELEASE, NULL, curproc);
 out:
@


1.4
log
@new ioctl that reports the current emulation a process uses; needed for
attaching to a running process
@
text
@d240 1
a240 1
		DPRINTF(("%s: attach to %d: %d\n", __FUNCTION__, pid, ret));
d744 1
a744 1
	DPRINTF(("%s: %d: policy %d\n", __FUNCTION__,
d784 1
a784 1
		DPRINTF(("%s: new, ents %d\n", __FUNCTION__,
d794 1
a794 1
		DPRINTF(("%s: %d -> pid %d\n", __FUNCTION__,
d823 1
a823 1
		DPRINTF(("%s: %d: code %d -> policy %d\n", __FUNCTION__,
d864 1
a864 1
	DPRINTF(("%s: %d\n", __FUNCTION__, strp->pid));
d896 1
a896 1
	DPRINTF(("%s: %d: %p(%d)\n", __FUNCTION__,
d1029 1
a1029 1
	DPRINTF(("%s: Trying to detach from %d\n", __FUNCTION__, strp->pid));
d1111 1
a1111 1
	DPRINTF(("%s: allocating %d -> %d\n", __FUNCTION__,
d1228 1
a1228 1
	DPRINTF(("%s: %p: pid %d -> pid %d\n", __FUNCTION__,
@


1.3
log
@make fsystrace available in systrace.h; keep some more stats.
@
text
@d85 1
d243 1
d305 3
d699 9
a707 1
		if (p->p_emul != oldemul && (strp = p->p_systrace) != NULL) {
d999 1
@


1.2
log
@when detaching form a process don't forget to remove posted messages.
@
text
@a102 20
struct fsystrace {
	struct lock lock;
	struct selinfo si;

	TAILQ_HEAD(strprocessq, str_process) processes;
	TAILQ_HEAD(strpolicyq, str_policy) policies;

	struct strprocessq messages;

	int npolicynr;
	int npolicies;

	int issuser;

	/* cwd magic */
	pid_t fd_pid;
	struct vnode *fd_cdir;
	struct vnode *fd_rdir;
};

a382 3
		if (ISSET(strp->flags, STR_PROC_ONQUEUE))
			TAILQ_REMOVE(&fst->messages, strp, msg_next);

d1035 2
d1076 1
@


1.1
log
@systrace facility, used to enforce and generate policies for system calls
okay deraadt@@
@
text
@a407 1
		
d1040 4
a1043 1
	if ((proc = systrace_find(strp)) == NULL) {
a1044 2
		goto out;
	}
a1050 4
	CLR(proc->p_flag, P_SYSTRACE);
	proc->p_systrace = NULL;

 out:
d1053 4
d1232 1
d1234 3
@

