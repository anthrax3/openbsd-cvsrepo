head	1.54;
access;
symbols
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.44.0.6
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.19
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.8
	OPENBSD_2_8:1.11.0.6
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.54
date	2011.06.23.17.09.01;	author matthew;	state dead;
branches;
next	1.53;

1.53
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	2011.05.31.17.35.35;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.07.18.45.56;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.22.03.12.37;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.12.19.58.48;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.15.00.36.41;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2008.05.23.00.51.33;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2008.01.05.07.33.37;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.11.13.39.33;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.08.17.59.23;	author gilles;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.18.20.55.52;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.18.20.49.19;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.05.00.38.20;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.24.23.14.00;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2006.09.24.20.29.52;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.14.01.04.58;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.12.13.53.44;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.30.23.49.08;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.03.15.43.53;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.01.20.57.09;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.14.20.50.49;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.21.05.24.40;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.19.12.59.13;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.03.12.08.28;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.23.22.47.16;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.10.24.19.11.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.08.05.43.16;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.27.04.45.57;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.16.12.51.48;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	99.11.16.09.24.59;	author art;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	99.09.14.14.19.56;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.02.26.01.44.33;	author art;	state Exp;
branches;
next	1.8;

1.8
date	98.10.03.21.19.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.10.18.10.37.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.06.04.30.35;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.19.53;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.23.47.04;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.21.14;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.19.13.49.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2001.07.04.10.40.12;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.11.13.21.09.59;	author niklas;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.03.28.15.03.51;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2003.05.13.19.34.56;	author ho;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	1.11.2.8;

1.11.2.8
date	2004.06.05.23.12.36;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Eliminate ramdisk.c and ramdisk.h now that they're unused.
@
text
@/*	$OpenBSD: ramdisk.c,v 1.53 2011/06/05 18:40:33 matthew Exp $	*/
/*	$NetBSD: ramdisk.c,v 1.8 1996/04/12 08:30:09 leo Exp $	*/

/*
 * Copyright (c) 1995 Gordon W. Ross, Leo Weppelman.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by
 *			Gordon W. Ross and Leo Weppelman.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This implements a general-purpose RAM-disk.
 * See ramdisk.h for notes on the config types.
 *
 * Note that this driver provides the same functionality
 * as the MFS filesystem hack, but this is better because
 * you can use this for any filesystem type you'd like!
 *
 * Credit for most of the kmem ramdisk code goes to:
 *   Leo Weppelman (atari) and Phil Nelson (pc532)
 * Credit for the ideas behind the "user space RAM" code goes
 * to the authors of the MFS implementation.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/disk.h>
#include <sys/proc.h>
#include <sys/conf.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>

#include <uvm/uvm_extern.h>

#include <dev/ramdisk.h>

/*
 * By default, include the user-space functionality.
 * Use:  option RAMDISK_SERVER=0 to turn it off.
 */
#if !defined(RAMDISK_SERVER) && !defined(SMALL_KERNEL)
#define	RAMDISK_SERVER 1
#endif

/*
 * XXX: the "control" unit is (base unit + 16).
 * We should just use the cdev as the "control", but
 * that interferes with the security stuff preventing
 * simultaneous use of raw and block devices.
 *
 * XXX Assumption: 16 RAM-disks are enough!
 */
#define RD_MAX_UNITS	0x10
#define RD_IS_CTRL(dev) (DISKPART(dev) == RAW_PART)

/* autoconfig stuff... */

struct rd_softc {
	struct device sc_dev;	/* REQUIRED first entry */
	struct disk sc_dk;	/* hook for generic disk handling */
	struct rd_conf sc_rd;
#if RAMDISK_SERVER
	struct buf *sc_buflist;
#endif
};
/* shorthand for fields in sc_rd: */
#define sc_addr sc_rd.rd_addr
#define sc_size sc_rd.rd_size
#define sc_type sc_rd.rd_type

void rdattach(int);
void rd_attach(struct device *, struct device *, void *);
void rdgetdisklabel(dev_t, struct rd_softc *, struct disklabel *, int);

/*
 * Some ports (like i386) use a swapgeneric that wants to
 * snoop around in this rd_cd structure.  It is preserved
 * (for now) to remain compatible with such practice.
 * XXX - that practice is questionable...
 */
struct cfdriver rd_cd = {
	NULL, "rd", DV_DISK
};

/*
 * Here we define a cfattach structure for inserting any new rd device into the
 * device tree. This is needed by some archs that look for bootable devices in
 * there.
 */
int  rd_probe(struct device *, void *, void *);
int  rd_detach(struct device *, int);

struct cfattach rd_ca = {
	sizeof(struct rd_softc), rd_probe, rd_attach,
	rd_detach
};

void rdstrategy(struct buf *bp);

int   ramdisk_ndevs;
void *ramdisk_devs[RD_MAX_UNITS];

/*
 * This is called if we are configured as a pseudo-device
 */
void
rdattach(int n)
{
	struct rd_softc *sc;
	struct cfdata *cf;
	int i;

#ifdef	DIAGNOSTIC
	if (ramdisk_ndevs) {
		printf("ramdisk: multiple attach calls?\n");
		return;
	}
#endif

	/* XXX:  Are we supposed to provide a default? */
	if (n < 1)
		n = 1;
	if (n > RD_MAX_UNITS)
		n = RD_MAX_UNITS;
	ramdisk_ndevs = n;

	/* XXX: Fake-up rd_cd (see above) */
	rd_cd.cd_ndevs = ramdisk_ndevs;
	rd_cd.cd_devs  = ramdisk_devs;

	/* Attach as if by autoconfig. */
	cf = malloc(sizeof(struct cfdata), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (cf == NULL) {
		printf("WARNING: no memory for cfdata struct\n");
		return;
	}
	cf->cf_attach = &rd_ca;
	cf->cf_driver = &rd_cd;

	for (i = 0; i < n; i++) {
		sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK | M_ZERO);
		if (snprintf(sc->sc_dev.dv_xname, sizeof(sc->sc_dev.dv_xname),
		    "rd%d", i) >= sizeof(sc->sc_dev.dv_xname)) {
			printf("rdattach: device name too long\n");
			free(sc, M_DEVBUF);
			return;
		}
		ramdisk_devs[i] = sc;
		sc->sc_dev.dv_unit = i;
		sc->sc_dev.dv_class = DV_DISK;
		sc->sc_dev.dv_parent = NULL;
		sc->sc_dev.dv_cfdata = cf;
		TAILQ_INSERT_TAIL(&alldevs, &sc->sc_dev, dv_list);
		device_ref(&sc->sc_dev);
		rd_attach(NULL, &sc->sc_dev, NULL);
	}
}

void
rd_attach(struct device *parent, struct device *self, void *aux)
{
	struct rd_softc *sc = (struct rd_softc *)self;

	/* XXX - Could accept aux info here to set the config. */
#ifdef	RAMDISK_HOOKS
	/*
	 * This external function might setup a pre-loaded disk.
	 * All it would need to do is setup the rd_conf struct.
	 * See sys/arch/sun3/dev/rd_root.c for an example.
	 */
	rd_attach_hook(sc->sc_dev.dv_unit, &sc->sc_rd);
#endif

	/*
	 * Initialize and attach the disk structure.
	 */
	sc->sc_dk.dk_name = sc->sc_dev.dv_xname;
	disk_attach(&sc->sc_dev, &sc->sc_dk);
}

/*
 * operational routines:
 * open, close, read, write, strategy,
 * ioctl, dump, size
 */

#if RAMDISK_SERVER
int rd_server_loop(struct rd_softc *sc);
int rd_ioctl_server(struct rd_softc *sc,
		struct rd_conf *urd, struct proc *proc);
#endif
int rd_ioctl_kalloc(struct rd_softc *sc,
		struct rd_conf *urd, struct proc *proc);

dev_type_open(rdopen);
dev_type_close(rdclose);
dev_type_read(rdread);
dev_type_write(rdwrite);
dev_type_ioctl(rdioctl);
dev_type_size(rdsize);
dev_type_dump(rddump);

int
rddump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
{
	return (ENODEV);
}

daddr64_t
rdsize(dev_t dev)
{
	int part, unit;
	struct rd_softc *sc;

	/* Disallow control units. */
	unit = DISKUNIT(dev);
	if (unit >= ramdisk_ndevs)
		return (0);
	sc = ramdisk_devs[unit];
	if (sc == NULL)
		return (0);

	if (sc->sc_type == RD_UNCONFIGURED)
		return (0);

	rdgetdisklabel(dev, sc, sc->sc_dk.dk_label, 0);
	part = DISKPART(dev);
	if (part >= sc->sc_dk.dk_label->d_npartitions)
		return (0);
	return (DL_GETPSIZE(&sc->sc_dk.dk_label->d_partitions[part]) *
	    (sc->sc_dk.dk_label->d_secsize / DEV_BSIZE));
}

int
rdopen(dev_t dev, int flag, int fmt, struct proc *proc)
{
	int unit;
	struct rd_softc *sc;

	unit = DISKUNIT(dev);
	if (unit >= ramdisk_ndevs)
		return (ENXIO);
	sc = ramdisk_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	/*
	 * The control device is not exclusive, and can
	 * open uninitialized units (so you can setconf).
	 */
	if (RD_IS_CTRL(dev))
		return (0);

#ifdef	RAMDISK_HOOKS
	/* Call the open hook to allow loading the device. */
	rd_open_hook(unit, &sc->sc_rd);
#endif

	/*
	 * This is a normal, "slave" device, so
	 * enforce initialized, exclusive open.
	 */
	if (sc->sc_type == RD_UNCONFIGURED)
		return (ENXIO);

	/*
	 * Make sure we have read the disklabel.
	 */
	rdgetdisklabel(dev, sc, sc->sc_dk.dk_label, 0);
	return (0);
}

int
rdclose(dev_t dev, int flag, int fmt, struct proc *proc)
{
	return (0);
}

int
rdread(dev_t dev, struct uio *uio, int flags)
{
	return (physio(rdstrategy, dev, B_READ, minphys, uio));
}

int
rdwrite(dev_t dev, struct uio *uio, int flags)
{
	return (physio(rdstrategy, dev, B_WRITE, minphys, uio));
}

/*
 * Handle I/O requests, either directly, or
 * by passing them to the server process.
 */
void
rdstrategy(struct buf *bp)
{
	int unit, s;
	struct rd_softc *sc;
	caddr_t addr;
	size_t off, xfer;

	unit = DISKUNIT(bp->b_dev);
	sc = ramdisk_devs[unit];

	/* Sort rogue requests out */
	if (sc == NULL || bp->b_blkno < 0 ||
	    (bp->b_bcount % sc->sc_dk.dk_label->d_secsize) != 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* Do not write on "no trespassing" areas... */
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) <= 0)
		goto bad;

	switch (sc->sc_type) {
#if RAMDISK_SERVER
	case RD_UMEM_SERVER:
		/* Just add this job to the server's queue. */
		bp->b_actf = sc->sc_buflist;
		sc->sc_buflist = bp;
		if (bp->b_actf == NULL) {
			/* server queue was empty. */
			wakeup((caddr_t)sc);
			/* see rd_server_loop() */
		}
		/* no biodone in this case */
		return;
#endif	/* RAMDISK_SERVER */

	case RD_KMEM_FIXED:
	case RD_KMEM_ALLOCATED:
		/* These are in kernel space.  Access directly. */
		bp->b_resid = bp->b_bcount;
		off = (bp->b_blkno << DEV_BSHIFT);
		xfer = bp->b_bcount;
		if (xfer > (sc->sc_size - off))
			xfer = (sc->sc_size - off);
		addr = sc->sc_addr + off;
		if (bp->b_flags & B_READ)
			bcopy(addr, bp->b_data, xfer);
		else
			bcopy(bp->b_data, addr, xfer);
		bp->b_resid -= xfer;
		break;

	default:
		bp->b_error = EIO;
bad:
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		break;
	}

	s = splbio();
	biodone(bp);
	splx(s);
}

int
rdioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *proc)
{
	struct disklabel *lp;
	struct rd_softc *sc;
	struct rd_conf *urd;
	int unit = DISKUNIT(dev), error;

	sc = ramdisk_devs[unit];

	urd = (struct rd_conf *)data;
	switch (cmd) {
	case DIOCRLDINFO:
		if (sc->sc_type == RD_UNCONFIGURED)
			break;
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		rdgetdisklabel(dev, sc, lp, 0);
		bcopy(lp, sc->sc_dk.dk_label, sizeof(*lp));
		free(lp, M_TEMP);
		return (0);

	case DIOCGPDINFO:
		if (sc->sc_type == RD_UNCONFIGURED)
			break;
		rdgetdisklabel(dev, sc, (struct disklabel *)data, 1);
		return (0);

	case DIOCGDINFO:
		if (sc->sc_type == RD_UNCONFIGURED)
			break;
		*(struct disklabel *)data = *(sc->sc_dk.dk_label);
		return (0);

	case DIOCGPART:
		((struct partinfo *)data)->disklab = sc->sc_dk.dk_label;
		((struct partinfo *)data)->part =
		    &sc->sc_dk.dk_label->d_partitions[DISKPART(dev)];
		return (0);

	case DIOCWDINFO:
	case DIOCSDINFO:
		if (sc->sc_type == RD_UNCONFIGURED)
			break;
		if ((flag & FWRITE) == 0)
			return (EBADF);

		error = setdisklabel(sc->sc_dk.dk_label,
		    (struct disklabel *)data, sc->sc_dk.dk_openmask);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    rdstrategy, sc->sc_dk.dk_label);
		}
		return (error);

	case RD_GETCONF:
		/* If this is not the control device, punt! */
		if (RD_IS_CTRL(dev) == 0)
			break;
		*urd = sc->sc_rd;
		return (0);

	case RD_SETCONF:
		/* If this is not the control device, punt! */
		if (RD_IS_CTRL(dev) == 0)
			break;
		/* Can only set it once. */
		if (sc->sc_type != RD_UNCONFIGURED)
			break;
		switch (urd->rd_type) {
		case RD_KMEM_ALLOCATED:
			return (rd_ioctl_kalloc(sc, urd, proc));
#if RAMDISK_SERVER
		case RD_UMEM_SERVER:
			return (rd_ioctl_server(sc, urd, proc));
#endif
		default:
			break;
		}
		break;

	default:
		return (ENOTTY);
	}
	return (EINVAL);
}

void
rdgetdisklabel(dev_t dev, struct rd_softc *sc, struct disklabel *lp,
    int spoofonly)
{
	bzero(lp, sizeof(struct disklabel));

	lp->d_secsize = DEV_BSIZE;
	lp->d_ntracks = 1;
	lp->d_nsectors = sc->sc_size >> DEV_BSHIFT;
	lp->d_ncylinders = 1;
	lp->d_secpercyl = lp->d_nsectors;
	if (lp->d_secpercyl == 0) {
		lp->d_secpercyl = 100;
		/* as long as it's not 0 - readdisklabel divides by it (?) */
	}

	strncpy(lp->d_typename, "RAM disk", sizeof(lp->d_typename));
	lp->d_type = DTYPE_SCSI;
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
	DL_SETDSIZE(lp, lp->d_nsectors);
	lp->d_version = 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	/*
	 * Call the generic disklabel extraction routine
	 */
	readdisklabel(DISKLABELDEV(dev), rdstrategy, lp, spoofonly);
}

/*
 * Handle ioctl RD_SETCONF for (sc_type == RD_KMEM_ALLOCATED)
 * Just allocate some kernel memory and return.
 */
int
rd_ioctl_kalloc(struct rd_softc *sc, struct rd_conf *urd, struct proc *proc)
{
	vaddr_t addr;
	vsize_t size;

	/* Sanity check the size. */
	size = urd->rd_size;
	addr = uvm_km_zalloc(kernel_map, size);
	if (!addr)
		return (ENOMEM);

	/* This unit is now configured. */
	sc->sc_addr = (caddr_t)addr; 	/* kernel space */
	sc->sc_size = (size_t)size;
	sc->sc_type = RD_KMEM_ALLOCATED;
	return (0);
}

int
rd_probe(struct device *parent, void *match_, void *aux)
{
	return (0);
}

int
rd_detach(struct device *self, int flags)
{
	return (0);
}

#if RAMDISK_SERVER

/*
 * Handle ioctl RD_SETCONF for (sc_type == RD_UMEM_SERVER)
 * Set config, then become the I/O server for this unit.
 */
int
rd_ioctl_server(struct rd_softc *sc, struct rd_conf *urd, struct proc *proc)
{
	vaddr_t end;
	int error;

	/* Sanity check addr, size. */
	end = (vaddr_t) (urd->rd_addr + urd->rd_size);

	if ((end >= VM_MAXUSER_ADDRESS) || (end < ((vaddr_t) urd->rd_addr)) )
		return (EINVAL);

	/* This unit is now configured. */
	sc->sc_addr = urd->rd_addr; 	/* user space */
	sc->sc_size = urd->rd_size;
	sc->sc_type = RD_UMEM_SERVER;

	/* Become the server daemon */
	error = rd_server_loop(sc);

	/* This server is now going away! */
	sc->sc_type = RD_UNCONFIGURED;
	sc->sc_addr = 0;
	sc->sc_size = 0;
	return (error);
}	

int	rd_sleep_pri = PWAIT | PCATCH;

int
rd_server_loop(struct rd_softc *sc)
{
	struct buf *bp;
	caddr_t addr;	/* user space address */
	size_t  off;	/* offset into "device" */
	size_t  xfer;	/* amount to transfer */
	int error, s;

	for (;;) {
		/* Wait for some work to arrive. */
		while (sc->sc_buflist == NULL) {
			error = tsleep((caddr_t)sc, rd_sleep_pri, "rd_idle", 0);
			if (error)
				return (error);
		}

		/* Unlink buf from head of list. */
		bp = sc->sc_buflist;
		sc->sc_buflist = bp->b_actf;
		bp->b_actf = NULL;

		/* Do the transfer to/from user space. */
		error = 0;
		bp->b_resid = bp->b_bcount;
		off = (bp->b_blkno << DEV_BSHIFT);
		if (off >= sc->sc_size) {
			if (bp->b_flags & B_READ)
				goto done;	/* EOF (not an error) */
			error = EIO;
			goto done;
		}
		xfer = bp->b_resid;
		if (xfer > (sc->sc_size - off))
			xfer = (sc->sc_size - off);
		addr = sc->sc_addr + off;
		if (bp->b_flags & B_READ)
			error = copyin(addr, bp->b_data, xfer);
		else
			error = copyout(bp->b_data, addr, xfer);
		if (!error)
			bp->b_resid -= xfer;

	done:
		if (error) {
			bp->b_error = error;
			bp->b_flags |= B_ERROR;
		}
		s = splbio();
		biodone(bp);
		splx(s);
	}
}

#endif	/* RAMDISK_SERVER */
@


1.53
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.52 2011/06/03 21:14:11 matthew Exp $	*/
@


1.52
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.51 2011/05/31 17:35:35 matthew Exp $	*/
a443 7

	case DIOCWLABEL:
		if (sc->sc_type == RD_UNCONFIGURED)
			break;
		if ((flag & FWRITE) == 0)
			return (EBADF);
		return (0);
@


1.51
log
@Change a few of the more common disk drivers (sd, cd, wd, rd, and vnd)
to return EBUSY if the user tries to modify an open partition's offset
or size.  Only sadness can result if a user tries this, and rejecting
it prevents a race between sdstart() and sdstrategy().

Curiously, there was already code in the kernel and in disklabel(8) to
detect/handle this, but it was effectively disabled because the disk
drivers always used something like "/* sc->sc_dk.dk_openmask */ 0",
and this commented out code has existed since even r1.1 in NetBSD.

I had no problems building a release and messing around with
disklabel(8) for a bit with this diff.  Canarying the more common MI
disk drivers until we gain confidence that there aren't any
regressions, then we can switch the remaining drivers.

"I am surprised you got me convinced that this stuff is safe" deraadt@@
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.50 2010/09/22 01:18:57 matthew Exp $	*/
d343 1
a343 1
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label, 1) <= 0)
@


1.50
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.49 2010/09/08 14:47:12 jsing Exp $	*/
d437 1
a437 1
		    (struct disklabel *)data, /*sd->sc_dk.dk_openmask : */0);
@


1.49
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.47 2010/08/28 20:23:22 matthew Exp $	*/
d311 1
a311 1
	return (physio(rdstrategy, NULL, dev, B_READ, minphys, uio));
d317 1
a317 1
	return (physio(rdstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.48
log
@no need for an activate function if it just returns 0
@
text
@d207 1
a207 1
	disk_attach(&sc->sc_dk);
@


1.47
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.46 2010/04/23 15:25:21 jsing Exp $	*/
a120 1
int  rd_activate(struct device *, int);
d124 1
a124 1
	rd_detach, rd_activate
a546 6
{
	return (0);
}

int
rd_activate(struct device *self, int act)
@


1.46
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.44 2008/08/22 03:12:37 deraadt Exp $	*/
a128 1
struct dkdriver rddkdriver = { rdstrategy };
a206 1
	sc->sc_dk.dk_driver = &rddkdriver;
@


1.45
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@a506 2
	lp->d_rpm = 3600;
	lp->d_interleave = 1;
@


1.44
log
@ANSI and other cleanups; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.43 2008/07/12 19:58:48 miod Exp $	*/
d121 1
a121 1
int  rd_activate(struct device *, enum devact);
d557 1
a557 1
rd_activate(struct device *self, enum devact act)
@


1.43
log
@Make sure the label is read in rdopen(), this isn't the case if you
boot bsd.rd -a and want to mount the ramdisk later on.

ok otto@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.42 2008/06/15 00:36:41 krw Exp $	*/
d89 1
a89 1
	struct disk sc_dkdev;	/* hook for generic disk handling */
d138 1
a138 2
rdattach(n)
	int n;
d152 1
a152 1
	if (n <= 1)
d191 1
a191 3
rd_attach(parent, self, aux)
	struct device	*parent, *self;
	void		*aux;
d208 3
a210 3
	sc->sc_dkdev.dk_driver = &rddkdriver;
	sc->sc_dkdev.dk_name = sc->sc_dev.dv_xname;
	disk_attach(&sc->sc_dkdev);
d236 1
a236 5
rddump(dev, blkno, va, size)
	dev_t dev;
	daddr64_t blkno;
	caddr_t va;
	size_t size;
d238 1
a238 1
	return ENODEV;
d250 1
a250 1
		return 0;
d253 1
a253 1
		return 0;
d256 1
a256 1
		return 0;
d258 1
a258 1
	rdgetdisklabel(dev, sc, sc->sc_dkdev.dk_label, 0);
d260 4
a263 5
	if (part >= sc->sc_dkdev.dk_label->d_npartitions)
		return 0;
	else
		return DL_GETPSIZE(&sc->sc_dkdev.dk_label->d_partitions[part]) *
		    (sc->sc_dkdev.dk_label->d_secsize / DEV_BSIZE);
d267 1
a267 4
rdopen(dev, flag, fmt, proc)
	dev_t   dev;
	int     flag, fmt;
	struct proc *proc;
d274 1
a274 1
		return ENXIO;
d277 1
a277 1
		return ENXIO;
d284 1
a284 1
		return 0;
d296 1
a296 1
		return ENXIO;
d301 2
a302 3
	rdgetdisklabel(dev, sc, sc->sc_dkdev.dk_label, 0);

	return 0;
d306 1
a306 4
rdclose(dev, flag, fmt, proc)
	dev_t   dev;
	int     flag, fmt;
	struct proc *proc;
d308 1
a308 2

	return 0;
d312 1
a312 4
rdread(dev, uio, flags)
	dev_t		dev;
	struct uio	*uio;
	int		flags;
d318 1
a318 4
rdwrite(dev, uio, flags)
	dev_t		dev;
	struct uio	*uio;
	int		flags;
d328 1
a328 2
rdstrategy(bp)
	struct buf *bp;
d330 1
a330 1
	int unit;
a333 1
	int s;
d340 1
a340 1
	    (bp->b_bcount % sc->sc_dkdev.dk_label->d_secsize) != 0) {
d346 1
a346 1
	if (bounds_check_with_label(bp, sc->sc_dkdev.dk_label, 1) <= 0)
d394 1
a394 6
rdioctl(dev, cmd, data, flag, proc)
	dev_t	dev;
	u_long	cmd;
	int		flag;
	caddr_t	data;
	struct proc	*proc;
a395 1
	int unit;
d399 1
a399 1
	int error;
a400 1
	unit = DISKUNIT(dev);
d410 1
a410 1
		bcopy(lp, sc->sc_dkdev.dk_label, sizeof(*lp));
d412 1
a412 1
		return 0;
d418 1
a418 1
		return 0;
d421 1
a421 1
		if (sc->sc_type == RD_UNCONFIGURED) {
d423 2
a424 3
		}
		*(struct disklabel *)data = *(sc->sc_dkdev.dk_label);
		return 0;
d427 1
a427 1
		((struct partinfo *)data)->disklab = sc->sc_dkdev.dk_label;
d429 2
a430 2
		    &sc->sc_dkdev.dk_label->d_partitions[DISKPART(dev)];
		return 0;
d434 1
a434 1
		if (sc->sc_type == RD_UNCONFIGURED) {
a435 1
		}
d437 1
a437 1
			return EBADF;
d439 1
a439 1
		error = setdisklabel(sc->sc_dkdev.dk_label,
d444 1
a444 1
				    rdstrategy, sc->sc_dkdev.dk_label);
d446 1
a446 2

		return error;
d449 1
a449 1
		if (sc->sc_type == RD_UNCONFIGURED) {
a450 1
		}
d452 2
a453 2
			return EBADF;
		return 0;
d457 1
a457 1
		if (RD_IS_CTRL(dev) == 0) {
a458 1
		}
d460 1
a460 1
		return 0;
d464 1
a464 1
		if (RD_IS_CTRL(dev) == 0) {
a465 1
		}
d467 1
a467 1
		if (sc->sc_type != RD_UNCONFIGURED) {
a468 1
		}
d471 1
a471 1
			return rd_ioctl_kalloc(sc, urd, proc);
d474 1
a474 1
			return rd_ioctl_server(sc, urd, proc);
d482 1
a482 1
		return ENOTTY;
d484 1
a484 1
	return EINVAL;
d526 1
a526 4
rd_ioctl_kalloc(sc, urd, proc)
	struct rd_softc *sc;
	struct rd_conf *urd;
	struct proc	*proc;
d535 1
a535 1
		return ENOMEM;
d541 1
a541 1
	return 0;
d547 1
a547 1
	return 0;
d553 1
a553 1
	return 0;
d559 1
a559 1
	return 0;
d569 1
a569 4
rd_ioctl_server(sc, urd, proc)
	struct rd_softc *sc;
	struct rd_conf *urd;
	struct proc	*proc;
d578 1
a578 1
		return EINVAL;
a591 1

d598 1
a598 2
rd_server_loop(sc)
	struct rd_softc *sc;
d604 1
a604 2
	int error;
	int s;
d611 1
a611 1
				return error;
@


1.42
log
@Don't bypass partition bounds check for RAW_PART. We now guarantee that
RAW_PART will always be 0 -> disksize, so the bounds check will always
pass for i/o's to valid addresses. Now the i/o will be properly truncated
if it goes past the end of the device. This prevents various adverse
impacts of issuing i/o's for data past the end of the device.

Repeatedly requested by todd@@.

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.41 2008/05/23 00:51:33 krw Exp $	*/
d308 5
@


1.41
log
@Make rd act more like a 'normal' disk device, allowing the elimination of
'fakerootdev' hackery. This allows us to bring back miod@@'s r1.70 subr_disk.c
change to avoid the GENERIC dance when rootdev has been initialized. This
in turn re-enables raidframe root devices.

Add a nice panic if rootdev can't be initialized, displaying the name of the
device that didn't work rather than just blowing up by de-referencing NULL.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.40 2008/01/05 07:33:37 brad Exp $	*/
d348 1
a348 1
	int unit, part;
d365 1
a365 3
	part = DISKPART(bp->b_dev);
	if (part != RAW_PART &&
	    bounds_check_with_label(bp, sc->sc_dkdev.dk_label, 1) <= 0)
@


1.40
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok krw@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.39 2007/09/11 13:39:33 gilles Exp $	*/
d111 15
a125 1
	NULL, "rd", DV_DULL
d142 1
d164 8
d182 5
d580 19
a598 1
}	
@


1.39
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.38 2007/09/08 17:59:23 gilles Exp $	*/
d487 3
@


1.38
log
@more M_ZERO changes

ok pyr@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.37 2007/06/20 18:15:46 deraadt Exp $	*/
d150 1
a150 1
		sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK|M_ZERO);
@


1.37
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.36 2007/06/18 20:55:52 deraadt Exp $	*/
d150 1
a150 2
		sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK);
		bzero((caddr_t)sc, sizeof(*sc));
@


1.36
log
@avoid modification race in DIOCRLDINFO; ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.35 2007/06/18 20:49:19 krw Exp $	*/
d102 1
a102 2
void rdgetdisklabel(dev_t, struct rd_softc *, struct disklabel *,
    struct cpu_disklabel *, int);
d238 1
a238 2
	rdgetdisklabel(dev, sc, sc->sc_dkdev.dk_label, sc->sc_dkdev.dk_cpulabel,
	    0);
d340 1
a340 2
	    bounds_check_with_label(bp, sc->sc_dkdev.dk_label,
	      sc->sc_dkdev.dk_cpulabel, 1) <= 0)
d410 1
a410 1
		rdgetdisklabel(dev, sc, lp, sc->sc_dkdev.dk_cpulabel, 0);
d415 5
a419 10
	case DIOCGPDINFO: {
			struct cpu_disklabel osdep;

			if (sc->sc_type == RD_UNCONFIGURED) {
				break;
			}
			rdgetdisklabel(dev, sc, (struct disklabel *)data,
			    &osdep, 1);
			return 0;
		}
d443 1
a443 2
		    (struct disklabel *)data, /*sd->sc_dk.dk_openmask : */0,
		    sc->sc_dkdev.dk_cpulabel);
d447 1
a447 2
				    rdstrategy, sc->sc_dkdev.dk_label,
				    sc->sc_dkdev.dk_cpulabel);
d494 1
a494 1
    struct cpu_disklabel *clp, int spoofonly)
a496 1
	bzero(clp, sizeof(struct cpu_disklabel));
d523 1
a523 1
	readdisklabel(DISKLABELDEV(dev), rdstrategy, lp, clp, spoofonly);
@


1.35
log
@Implement DIOCRLDINFO, DIOCGPDINFO and DIOCGPART. Tweak DIOCGDINFO to
avoid unnecessary rdgetdisklabel() call.

requested by & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.34 2007/06/08 05:27:58 deraadt Exp $	*/
d399 1
d410 1
a410 1
		if (sc->sc_type == RD_UNCONFIGURED) {
d412 4
a415 3
		}
		rdgetdisklabel(dev, sc, sc->sc_dkdev.dk_label,
		    sc->sc_dkdev.dk_cpulabel, 0);
@


1.34
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.33 2007/06/06 17:15:13 deraadt Exp $	*/
d102 2
a103 1
void rdgetdisklabel(dev_t, struct rd_softc *);
d239 2
a240 1
	rdgetdisklabel(dev, sc);
d408 19
d431 7
a437 2
		rdgetdisklabel(dev, sc);
		bcopy(sc->sc_dkdev.dk_label, data, sizeof(struct disklabel));
d501 2
a502 1
rdgetdisklabel(dev_t dev, struct rd_softc *sc)
d504 2
a505 4
	struct disklabel *lp = sc->sc_dkdev.dk_label;

	bzero(sc->sc_dkdev.dk_label, sizeof(struct disklabel));
	bzero(sc->sc_dkdev.dk_cpulabel, sizeof(struct cpu_disklabel));
d532 1
a532 2
	readdisklabel(DISKLABELDEV(dev), rdstrategy, sc->sc_dkdev.dk_label,
	    sc->sc_dkdev.dk_cpulabel, 0);
@


1.33
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.32 2007/06/05 00:38:20 deraadt Exp $	*/
d498 1
@


1.32
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.31 2007/06/01 00:07:48 krw Exp $	*/
d214 1
a214 1
	daddr_t blkno;
d221 1
a221 1
int
@


1.31
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.30 2007/04/24 23:14:00 krw Exp $	*/
d243 1
a243 1
		return sc->sc_dkdev.dk_label->d_partitions[part].p_size *
d495 1
a495 1
	lp->d_secperunit = lp->d_nsectors;
@


1.30
log
@Pass a real dev_t to readdisklabel(), not a unit number with lipstick.

Suggestions from miod@@, KNF nit from mk@@

ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.29 2006/09/24 20:29:52 krw Exp $	*/
a497 5

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;
@


1.29
log
@Eliminate D_CHAIN, D_ECC and D_RAMDISK flags from disklabel. They were
not being used in the tree for anything obviously useful. Get it done
early so we can find if there are non-obvious uses out there.

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.28 2006/08/14 01:04:58 krw Exp $	*/
d102 1
a102 1
void rdgetdisklabel(struct rd_softc *sc);
d238 1
a238 1
	rdgetdisklabel(sc);
d410 1
a410 1
		rdgetdisklabel(sc);
d475 1
a475 1
rdgetdisklabel(struct rd_softc *sc)
d511 2
a512 2
	readdisklabel(DISKLABELDEV(sc->sc_dev.dv_unit), rdstrategy,
	    sc->sc_dkdev.dk_label, sc->sc_dkdev.dk_cpulabel, 0);
@


1.28
log
@Now that DEV_BSIZE is universally defined as 1 << DEV_BSHIFT, use it to
set d_secsize instead of 1 << DEV_BSHIFT. Just for textual consistency in
setting d_secsize.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.27 2006/08/12 13:53:44 krw Exp $	*/
a497 1
	lp->d_flags = D_RAMDISK;
@


1.27
log
@Setting d_secsize to DEV_BSIZE (or 1 << DEV_BSHIFT, or 512) and then
setting RAW_PART's p_size to d_secperunit * (d_secsize / DEV_BSIZE) is
a waste of a few ops. And p_size should be in sectors anyway.

Just set RAW_PART's p_size to d_secperunit to make usage consistant
across the tree.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.26 2005/06/30 23:49:08 miod Exp $	*/
d482 1
a482 1
	lp->d_secsize = 1 << DEV_BSHIFT;
@


1.26
log
@Do not compile RAMDISK_SERVER functionnality by default if option SMALL_KERNEL;
saves roughly 512 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.25 2004/04/03 15:43:53 krw Exp $	*/
d501 1
a501 2
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
@


1.25
log
@Complete 'lp.d_' to 'lp->d_' changes started with r1.24 so that ramdisk_cd and
friends compile again.

ok tdeval@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.24 2004/04/01 20:57:09 miod Exp $	*/
d70 1
a70 1
#ifndef RAMDISK_SERVER
@


1.24
log
@Better bounds checking in strategy(), and kill the (unused) rd flags
while there.

ok tdeval@@ (long ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.23 2004/01/14 20:50:49 miod Exp $	*/
d492 17
a508 17
	strncpy(lp.d_typename, "RAM disk", sizeof(lp.d_typename));
	lp.d_type = DTYPE_SCSI;
	strncpy(lp.d_packname, "fictitious", sizeof(lp.d_packname));
	lp.d_secperunit = lp.d_nsectors;
	lp.d_rpm = 3600;
	lp.d_interleave = 1;
	lp.d_flags = D_RAMDISK;

	lp.d_partitions[RAW_PART].p_offset = 0;
	lp.d_partitions[RAW_PART].p_size =
	    lp.d_secperunit * (lp.d_secsize / DEV_BSIZE);
	lp.d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp.d_npartitions = RAW_PART + 1;

	lp.d_magic = DISKMAGIC;
	lp.d_magic2 = DISKMAGIC;
	lp.d_checksum = dkcksum(&lp);
@


1.23
log
@Do not fill more than the first three fields of cfdriver structures unless
necessary. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.22 2003/10/21 05:24:40 jmc Exp $	*/
d91 1
d93 1
a93 1
	int sc_flags;
a98 3
/* flags */
#define RD_ISOPEN	0x01
#define RD_SERVED	0x02
d102 1
a102 1
struct disklabel *rdgetdisklabel(dev_t dev, struct rd_softc *sc);
a225 1
	struct disklabel *lp;
d238 1
a238 1
	lp = rdgetdisklabel(dev, sc);
d240 1
a240 1
	if (part > lp->d_npartitions)
d243 2
a244 2
		return lp->d_partitions[part].p_size *
		    (lp->d_secsize / DEV_BSIZE);
a280 2
	if (sc->sc_flags & RD_ISOPEN)
		return EBUSY;
a290 11
	int unit;
	struct rd_softc *sc;

	unit = DISKUNIT(dev);
	sc = ramdisk_devs[unit];

	if (RD_IS_CTRL(dev))
		return 0;

	/* Normal device. */
	sc->sc_flags = 0;
d321 1
a321 1
	int unit;
d324 1
a324 1
	size_t  off, xfer;
d330 14
d364 1
a364 6
		if (off >= sc->sc_size) {
			if (bp->b_flags & B_READ)
				break;	/* EOF */
			goto set_eio;
		}
		xfer = bp->b_resid;
a375 2
		bp->b_resid = bp->b_bcount;
	set_eio:
d377 1
d379 1
d382 1
a398 2
	struct cpu_disklabel clp;
	struct disklabel lp, *lpp;
d410 2
a411 3
		lpp = rdgetdisklabel(dev, sc);
		if (lpp)
			*(struct disklabel *)data = *lpp;
d422 3
a424 2
		error = setdisklabel(&lp, (struct disklabel *)data,
		    /*sd->sc_dk.dk_openmask : */0, &clp);
d428 2
a429 1
				    rdstrategy, &lp, &clp);
d474 2
a475 4
struct disklabel *
rdgetdisklabel(dev, sc)
	dev_t dev;
	struct rd_softc *sc;
d477 12
a488 14
	static struct disklabel lp;
	struct cpu_disklabel clp;
	char *errstring;

	bzero(&lp, sizeof(struct disklabel));
	bzero(&clp, sizeof(struct cpu_disklabel));

	lp.d_secsize = 1 << DEV_BSHIFT;
	lp.d_ntracks = 1;
	lp.d_nsectors = sc->sc_size >> DEV_BSHIFT;
	lp.d_ncylinders = 1;
	lp.d_secpercyl = lp.d_nsectors;
	if (lp.d_secpercyl == 0) {
		lp.d_secpercyl = 100;
d498 1
a498 1
	lp.d_flags = 0;
d513 2
a514 6
	errstring = readdisklabel(DISKLABELDEV(dev), rdstrategy, &lp, &clp, 0);
	if (errstring) {
		/*printf("%s: %s\n", sc->sc_dev.dv_xname, errstring);*/
		return NULL;
	}
	return &lp;
@


1.22
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.21 2003/04/19 12:59:13 krw Exp $	*/
d113 1
a113 1
	NULL, "rd", DV_DULL, NULL, 0
@


1.21
log
@Some string cleanup: sprintf -> snprintf and magic numbers to sizeof
(remember: d_[type|pack]name do not need terminating null).

Take the opportunity to introduce some paranoia and check the device
name lengths to make sure they fit, with appropriate errors if not.

ok tedu@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.20 2003/03/03 12:08:28 miod Exp $	*/
d36 1
a36 1
 * This implements a general-puspose RAM-disk.
d78 1
a78 1
 * simulatneous use of raw and block devices.
@


1.20
log
@Provide a functional d_psize() function for ramdisk block devices.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.19 2002/05/23 22:47:16 art Exp $	*/
a151 1

d154 6
a161 1
		sprintf(sc->sc_dev.dv_xname, "rd%d", i);
d503 1
a503 1
	strncpy(lp.d_typename, "RAM disk", 16);
d505 1
a505 1
	strncpy(lp.d_packname, "fictitious", 16);
@


1.19
log
@Protect biodone calls with splbio.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.18 2002/03/14 01:26:52 millert Exp $	*/
d103 1
a103 1
static void rd_attach(struct device *, struct device *, void *);
d119 2
a120 2
static int   ramdisk_ndevs;
static void *ramdisk_devs[RD_MAX_UNITS];
d162 1
a162 1
static void
d194 2
a195 2
static int rd_server_loop(struct rd_softc *sc);
static int rd_ioctl_server(struct rd_softc *sc,
d198 1
a198 1
static int rd_ioctl_kalloc(struct rd_softc *sc,
d209 2
a210 1
int rddump(dev, blkno, va, size)
d219 2
a220 1
int rdsize(dev_t dev)
d222 1
a222 1
	int unit;
d224 1
d227 1
a227 1
	unit = minor(dev);
d237 7
a243 1
	return (sc->sc_size >> DEV_BSHIFT);
d532 1
a532 1
static int
d560 1
a560 1
static int
d593 1
a593 1
static int
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.17 2001/11/06 19:53:18 miod Exp $	*/
d328 1
d376 1
d378 1
d593 1
d634 1
d636 1
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.16 2001/10/24 19:11:08 millert Exp $	*/
d102 3
a104 3
void rdattach __P((int));
static void rd_attach __P((struct device *, struct device *, void *));
struct disklabel *rdgetdisklabel __P((dev_t dev, struct rd_softc *sc));
d116 1
a116 1
void rdstrategy __P((struct buf *bp));
d194 3
a196 3
static int rd_server_loop __P((struct rd_softc *sc));
static int rd_ioctl_server __P((struct rd_softc *sc,
		struct rd_conf *urd, struct proc *proc));
d198 2
a199 2
static int rd_ioctl_kalloc __P((struct rd_softc *sc,
		struct rd_conf *urd, struct proc *proc));
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.17 2001/11/06 19:53:18 miod Exp $	*/
d102 3
a104 3
void rdattach(int);
static void rd_attach(struct device *, struct device *, void *);
struct disklabel *rdgetdisklabel(dev_t dev, struct rd_softc *sc);
d116 1
a116 1
void rdstrategy(struct buf *bp);
d194 3
a196 3
static int rd_server_loop(struct rd_softc *sc);
static int rd_ioctl_server(struct rd_softc *sc,
		struct rd_conf *urd, struct proc *proc);
d198 2
a199 2
static int rd_ioctl_kalloc(struct rd_softc *sc,
		struct rd_conf *urd, struct proc *proc);
a327 1
	int s;
a374 1
	s = splbio();
a375 1
	splx(s);
a589 1
	int s;
a629 1
		s = splbio();
a630 1
		splx(s);
@


1.17.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 1
a103 1
void rd_attach(struct device *, struct device *, void *);
d119 2
a120 2
int   ramdisk_ndevs;
void *ramdisk_devs[RD_MAX_UNITS];
d152 1
a154 6
		if (snprintf(sc->sc_dev.dv_xname, sizeof(sc->sc_dev.dv_xname),
		    "rd%d", i) >= sizeof(sc->sc_dev.dv_xname)) {
			printf("rdattach: device name too long\n");
			free(sc, M_DEVBUF);
			return;
		}
d157 1
d162 1
a162 1
void
d194 2
a195 2
int rd_server_loop(struct rd_softc *sc);
int rd_ioctl_server(struct rd_softc *sc,
d198 1
a198 1
int rd_ioctl_kalloc(struct rd_softc *sc,
d209 1
a209 2
int
rddump(dev, blkno, va, size)
d218 1
a218 2
int
rdsize(dev_t dev)
d220 1
a220 1
	int part, unit;
a221 1
	struct disklabel *lp;
d224 1
a224 1
	unit = DISKUNIT(dev);
d234 1
a234 7
	lp = rdgetdisklabel(dev, sc);
	part = DISKPART(dev);
	if (part > lp->d_npartitions)
		return 0;
	else
		return lp->d_partitions[part].p_size *
		    (lp->d_secsize / DEV_BSIZE);
d490 1
a490 1
	strncpy(lp.d_typename, "RAM disk", sizeof(lp.d_typename));
d492 1
a492 1
	strncpy(lp.d_packname, "fictitious", sizeof(lp.d_packname));
d523 1
a523 1
int
d551 1
a551 1
int
d584 1
a584 1
int
@


1.16
log
@Use macros from sys/disklabel.h instead of custom ones with slightly
different (and thus confusing) semantics.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.15 2001/09/19 20:50:58 mickey Exp $	*/
a61 1
#include <vm/vm.h>
@


1.15
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.14 2001/07/08 05:43:16 millert Exp $	*/
d84 1
a84 6
#define RD_UNIT(unit)    (unit / MAXPARTITIONS)
#define RD_PART(unit)    (unit % MAXPARTITIONS)
#define RD_IS_CTRL(unit) (RD_PART(unit) == RAW_PART)
#define	MAKERDDEV(maj, unit, part)	MAKEDISKDEV(maj, unit, part)

#define	RDLABELDEV(dev)	(MAKERDDEV(major(dev), RD_UNIT(minor(dev)), RAW_PART))
d244 1
a244 1
	int md, unit;
d247 1
a247 2
	md = minor(dev);
	unit = RD_UNIT(md);
d258 1
a258 1
	if (RD_IS_CTRL(md))
d284 1
a284 1
	int md, unit;
d287 1
a287 2
	md = minor(dev);
	unit = RD_UNIT(md);
d290 1
a290 1
	if (RD_IS_CTRL(md))
d325 1
a325 1
	int md, unit;
d330 1
a330 2
	md = minor(bp->b_dev);
	unit = RD_UNIT(md);
d387 1
a387 1
	int md, unit;
d394 1
a394 2
	md = minor(dev);
	unit = RD_UNIT(md);
d420 1
a420 1
				error = writedisklabel(RDLABELDEV(dev),
d436 1
a436 1
		if (RD_IS_CTRL(md) == 0) {
d444 1
a444 1
		if (RD_IS_CTRL(md) == 0) {
d509 1
a509 1
	errstring = readdisklabel(RDLABELDEV(dev), rdstrategy, &lp, &clp, 0);
@


1.14
log
@Add missing call to minor() in RDLABELDEV macro.
This only worked before by luck.  Fixes floppy panic in -current.
Thanks to krw@@ for the DDB traceback, it helped ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.13 2001/06/27 04:45:57 art Exp $	*/
a62 2
#include <vm/vm_kern.h>

@


1.13
log
@zap old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.12 2001/05/16 12:51:48 ho Exp $	*/
d91 1
a91 1
#define	RDLABELDEV(dev)	(MAKERDDEV(major(dev), RD_UNIT(dev), RAW_PART))
@


1.12
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.11 1999/11/16 09:24:59 art Exp $	*/
a64 1
#if defined(UVM)
a65 1
#endif
a542 1
#if defined(UVM)
a543 3
#else
	addr = kmem_alloc(kernel_map, size);
#endif
@


1.11
log
@We don't need a prototype for kmem_alloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.10 1999/09/14 14:19:56 mickey Exp $	*/
a163 4
		if (!sc) {
			printf("ramdisk: malloc for attach failed!\n");
			return;
		}
@


1.11.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.11 1999/11/16 09:24:59 art Exp $	*/
d65 1
d67 1
d164 4
d549 1
d551 3
@


1.11.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.11.2.1 2001/07/04 10:40:12 niklas Exp $	*/
d63 2
d86 6
a91 1
#define RD_IS_CTRL(dev) (DISKPART(dev) == RAW_PART)
d251 1
a251 1
	int unit;
d254 2
a255 1
	unit = DISKUNIT(dev);
d266 1
a266 1
	if (RD_IS_CTRL(dev))
d292 1
a292 1
	int unit;
d295 2
a296 1
	unit = DISKUNIT(dev);
d299 1
a299 1
	if (RD_IS_CTRL(dev))
d334 1
a334 1
	int unit;
d339 2
a340 1
	unit = DISKUNIT(bp->b_dev);
d397 1
a397 1
	int unit;
d404 2
a405 1
	unit = DISKUNIT(dev);
d431 1
a431 1
				error = writedisklabel(DISKLABELDEV(dev),
d447 1
a447 1
		if (RD_IS_CTRL(dev) == 0) {
d455 1
a455 1
		if (RD_IS_CTRL(dev) == 0) {
d520 1
a520 1
	errstring = readdisklabel(DISKLABELDEV(dev), rdstrategy, &lp, &clp, 0);
@


1.11.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
@


1.11.2.4
log
@Merge in -current from roughly a week ago
@
text
@d102 3
a104 3
void rdattach(int);
static void rd_attach(struct device *, struct device *, void *);
struct disklabel *rdgetdisklabel(dev_t dev, struct rd_softc *sc);
d116 1
a116 1
void rdstrategy(struct buf *bp);
d194 3
a196 3
static int rd_server_loop(struct rd_softc *sc);
static int rd_ioctl_server(struct rd_softc *sc,
		struct rd_conf *urd, struct proc *proc);
d198 2
a199 2
static int rd_ioctl_kalloc(struct rd_softc *sc,
		struct rd_conf *urd, struct proc *proc);
@


1.11.2.5
log
@Sync the SMP branch with 3.3
@
text
@d103 1
a103 1
void rd_attach(struct device *, struct device *, void *);
d119 2
a120 2
int   ramdisk_ndevs;
void *ramdisk_devs[RD_MAX_UNITS];
d162 1
a162 1
void
d194 2
a195 2
int rd_server_loop(struct rd_softc *sc);
int rd_ioctl_server(struct rd_softc *sc,
d198 1
a198 1
int rd_ioctl_kalloc(struct rd_softc *sc,
d209 1
a209 2
int
rddump(dev, blkno, va, size)
d218 1
a218 2
int
rdsize(dev_t dev)
d220 1
a220 1
	int part, unit;
a221 1
	struct disklabel *lp;
d224 1
a224 1
	unit = DISKUNIT(dev);
d234 1
a234 7
	lp = rdgetdisklabel(dev, sc);
	part = DISKPART(dev);
	if (part > lp->d_npartitions)
		return 0;
	else
		return lp->d_partitions[part].p_size *
		    (lp->d_secsize / DEV_BSIZE);
a327 1
	int s;
a374 1
	s = splbio();
a375 1
	splx(s);
d520 1
a520 1
int
d548 1
a548 1
int
d581 1
a581 1
int
a589 1
	int s;
a629 1
		s = splbio();
a630 1
		splx(s);
@


1.11.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.11.2.5 2003/03/28 00:38:10 niklas Exp $	*/
d152 1
a154 6
		if (snprintf(sc->sc_dev.dv_xname, sizeof(sc->sc_dev.dv_xname),
		    "rd%d", i) >= sizeof(sc->sc_dev.dv_xname)) {
			printf("rdattach: device name too long\n");
			free(sc, M_DEVBUF);
			return;
		}
d157 1
d499 1
a499 1
	strncpy(lp.d_typename, "RAM disk", sizeof(lp.d_typename));
d501 1
a501 1
	strncpy(lp.d_packname, "fictitious", sizeof(lp.d_packname));
@


1.11.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 1
 * This implements a general-purpose RAM-disk.
d78 1
a78 1
 * simultaneous use of raw and block devices.
d113 1
a113 1
	NULL, "rd", DV_DULL
@


1.11.2.8
log
@Merge with the trunk
@
text
@a90 1
#if RAMDISK_SERVER
d92 1
a92 1
#endif
d98 3
d104 1
a104 1
void rdgetdisklabel(struct rd_softc *sc);
d228 1
d241 1
a241 1
	rdgetdisklabel(sc);
d243 1
a243 1
	if (part >= sc->sc_dkdev.dk_label->d_npartitions)
d246 2
a247 2
		return sc->sc_dkdev.dk_label->d_partitions[part].p_size *
		    (sc->sc_dkdev.dk_label->d_secsize / DEV_BSIZE);
d284 2
d296 11
d337 1
a337 1
	int unit, part;
d340 1
a340 1
	size_t off, xfer;
a345 14
	/* Sort rogue requests out */
	if (sc == NULL || bp->b_blkno < 0 ||
	    (bp->b_bcount % sc->sc_dkdev.dk_label->d_secsize) != 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* Do not write on "no trespassing" areas... */
	part = DISKPART(bp->b_dev);
	if (part != RAW_PART &&
	    bounds_check_with_label(bp, sc->sc_dkdev.dk_label,
	      sc->sc_dkdev.dk_cpulabel, 1) <= 0)
		goto bad;

d366 6
a371 1
		xfer = bp->b_bcount;
d383 2
a385 1
bad:
a386 1
		bp->b_resid = bp->b_bcount;
a388 1

d405 2
d418 3
a420 2
		rdgetdisklabel(sc);
		bcopy(sc->sc_dkdev.dk_label, data, sizeof(struct disklabel));
d431 2
a432 3
		error = setdisklabel(sc->sc_dkdev.dk_label,
		    (struct disklabel *)data, /*sd->sc_dk.dk_openmask : */0,
		    sc->sc_dkdev.dk_cpulabel);
d436 1
a436 2
				    rdstrategy, sc->sc_dkdev.dk_label,
				    sc->sc_dkdev.dk_cpulabel);
d481 4
a484 2
void
rdgetdisklabel(struct rd_softc *sc)
d486 14
a499 12
	struct disklabel *lp = sc->sc_dkdev.dk_label;

	bzero(sc->sc_dkdev.dk_label, sizeof(struct disklabel));
	bzero(sc->sc_dkdev.dk_cpulabel, sizeof(struct cpu_disklabel));

	lp->d_secsize = 1 << DEV_BSHIFT;
	lp->d_ntracks = 1;
	lp->d_nsectors = sc->sc_size >> DEV_BSHIFT;
	lp->d_ncylinders = 1;
	lp->d_secpercyl = lp->d_nsectors;
	if (lp->d_secpercyl == 0) {
		lp->d_secpercyl = 100;
d503 17
a519 17
	strncpy(lp->d_typename, "RAM disk", sizeof(lp->d_typename));
	lp->d_type = DTYPE_SCSI;
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
	lp->d_secperunit = lp->d_nsectors;
	lp->d_rpm = 3600;
	lp->d_interleave = 1;
	lp->d_flags = D_RAMDISK;

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);
d524 6
a529 2
	readdisklabel(DISKLABELDEV(sc->sc_dev.dv_unit), rdstrategy,
	    sc->sc_dkdev.dk_label, sc->sc_dkdev.dk_cpulabel, 0);
@


1.10
log
@vaddr_t/vsize_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.9 1999/02/26 01:44:33 art Exp $	*/
a66 3
#else
/* Don't want all those other VM headers... */
extern vm_offset_t	 kmem_alloc __P((vm_map_t, vm_size_t));
@


1.9
log
@compatibility with uvm kmem allocators
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.8 1998/10/03 21:19:00 millert Exp $	*/
d547 2
a548 2
	vm_offset_t addr;
	vm_size_t  size;
d579 1
a579 1
	vm_offset_t end;
d583 1
a583 1
	end = (vm_offset_t) (urd->rd_addr + urd->rd_size);
d585 1
a585 2
	if ((end >= VM_MAXUSER_ADDRESS) ||
		(end < ((vm_offset_t) urd->rd_addr)) )
@


1.8
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.7 1997/10/18 10:37:03 deraadt Exp $	*/
d64 4
d70 1
d552 3
d556 1
@


1.7
log
@avoid "no disklabel" error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.6 1997/02/06 04:30:35 rahnds Exp $	*/
d524 1
a524 1
	errstring = readdisklabel(RDLABELDEV(dev), rdstrategy, &lp, &clp);
@


1.6
log
@Changes to ramdisk driver to support disklabels. Work done by Theo.
This will require changes for each machine type.
changes to MAKEDEV, suggest treating rd like sd
---
sd*|vnd*|ccd*|rd*)
...
	rd*)  name=rd;  blk=17; chr=17;;
---
Make certain that majors and minors are correct
conf.c
	add a entry in cdevsw for rd (previously was only in bdev)
---
cdev_decl(rd);
...
struct cdevsw cdevsw[] = {
	...
	cdev_disk_init(NRD,rd),         /* 17 ram disk driver*/
---

other changes to how rdconfig is called may be appropriate,
it must now be configured using the "raw" parition typically 'c'.
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.5 1996/04/21 22:19:53 deraadt Exp $	*/
d526 1
a526 1
		printf("%s: %s\n", sc->sc_dev.dv_xname, errstring);
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: ramdisk.c,v 1.4 1996/04/18 23:47:04 niklas Exp $	*/
d55 1
d59 2
d86 6
a91 2
#define RD_IS_CTRL(unit) (unit & 0x10)
#define RD_UNIT(unit)    (unit &  0xF)
d112 1
d404 3
a411 4
	/* If this is not the control device, punt! */
	if (RD_IS_CTRL(md) == 0)
		return ENOTTY;

d414 35
d450 4
d458 4
d463 1
a463 1
		if (sc->sc_type != RD_UNCONFIGURED)
d465 1
d479 51
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ramdisk.c,v 1.5 1996/03/07 10:26:29 leo Exp $	*/
d50 2
d56 2
d82 1
a85 6
/*
 * XXX -  This is just for a sanity check.  Only
 * applies to kernel-space RAM disk allocations.
 */
#define RD_KMEM_MAX_SIZE	0x100000	/* 1MB */

d103 2
a104 2
static int  rd_match (struct device *, void *self, void *);
static void rd_attach(struct device *, struct device *self, void *);
d106 9
a114 3
struct cfdriver rdcd = {
	NULL, "rd", rd_match, rd_attach,
	DV_DULL, sizeof(struct rd_softc), NULL, 0 };
d117 1
d119 2
a120 1
struct dkdriver rddkdriver = { rdstrategy };
d122 6
a127 5
static int
rd_match(parent, self, aux)
	struct device	*parent;
	void	*self;
	void	*aux;
d129 8
a136 8
#ifdef	RAMDISK_HOOKS
	/*
	 * This external function allows for a machine dependent
	 * match function.
	 */
	return (rd_match_hook(parent, self, aux));
#else
	return(1);
d138 26
a181 1
	printf("\n");
a185 1
	bzero(&sc->sc_dkdev, sizeof(sc->sc_dkdev));
d202 10
d229 1
a229 1
	if (unit >= rdcd.cd_ndevs)
d231 1
a231 1
	sc = rdcd.cd_devs[unit];
d241 2
a242 1
int rdopen(dev, flag, fmt, proc)
d252 1
a252 1
	if (unit >= rdcd.cd_ndevs)
d254 1
a254 1
	sc = rdcd.cd_devs[unit];
d282 2
a283 1
int rdclose(dev, flag, fmt, proc)
d293 1
a293 1
	sc = rdcd.cd_devs[unit];
d305 1
a305 1
rdread(dev, uio)
d308 1
d314 1
a314 1
rdwrite(dev, uio)
d317 1
d337 1
a337 1
	sc = rdcd.cd_devs[unit];
d399 1
a399 1
	sc = rdcd.cd_devs[unit];
d434 1
a434 1
int
a444 2
	if (size > RD_KMEM_MAX_SIZE)
		return EINVAL;
d462 1
a462 1
int
@


1.3
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 2
a2 1
/*	$NetBSD: ramdisk.c,v 1.4 1996/01/07 22:03:31 thorpej Exp $	*/
d121 7
d129 1
@


1.2
log
@from netbsd; get size of softc right
@
text
@d1 1
a1 1
/*	$NetBSD: ramdisk.c,v 1.1.2.1 1995/11/17 23:34:25 gwr Exp $	*/
d52 1
d90 1
d110 4
d140 8
a154 2

void rdstrategy __P((struct buf *bp));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ramdisk.c,v 1.1 1995/10/08 23:30:57 gwr Exp $	*/
d106 1
a106 1
	DV_DISK, sizeof(struct device), NULL, 0 };
d394 1
a394 1
 * Handle ioctl RD_SETCONF for (sc_type == RD_KMEM_ALLOCATED)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
