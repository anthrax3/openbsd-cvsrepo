head	1.27;
access;
symbols
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.4
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.14
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.12
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.8
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.6
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.4
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.2
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.10
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.8
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.4
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.8
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.13
	SMP:1.12.0.4
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	UBC_SYNC_B:1.11
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	UBC:1.4.0.2;
locks; strict;
comment	@ * @;


1.27
date	2016.04.25.20.00.33;	author tedu;	state dead;
branches;
next	1.26;
commitid	MLNYUlvoOtU8VX0s;

1.26
date	2016.03.01.16.43.08;	author naddy;	state Exp;
branches;
next	1.25;
commitid	EkPO5hcDLACEBw66;

1.25
date	2015.01.20.01.48.13;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	ezo1LvadshG8WzF2;

1.24
date	2015.01.16.00.18.06;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	gobI4Gg1WMhvXm3K;

1.23
date	2011.09.18.23.24.14;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.22.01.32.16;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.09.05.13.53;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.06.05.47.27;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.23.22.28.22;	author alek;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2004.11.07.20.39.31;	author marius;	state Exp;
branches
	1.18.4.1
	1.18.6.1;
next	1.17;

1.17
date	2004.07.07.07.31.40;	author marius;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.23.05.16.35;	author marius;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.08.16.30.01;	author sturm;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.16.06.36.40;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.28.11.52.05;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.04.17.37.39;	author mickey;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2002.10.25.23.22.58;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.16.15.01.08;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.09.03.51.49;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.24.21.45.55;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.22.04.02.39;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.21.15.07.04;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.16.01.24.38;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.19.15.06;	author provos;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.06.02.15.41.26;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.19.21.44.02;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.16.16.16.52;	author provos;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;

1.12.4.1
date	2003.05.13.19.34.56;	author ho;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	;

1.18.4.1
date	2006.10.06.05.53.38;	author brad;	state Exp;
branches;
next	;

1.18.6.1
date	2006.10.06.05.51.12;	author brad;	state Exp;
branches;
next	;

1.19.2.1
date	2006.11.01.20.03.35;	author brad;	state Exp;
branches;
next	;


desc
@@


1.27
log
@boom goes the dynamite
@
text
@/*	$OpenBSD: systrace.h,v 1.26 2016/03/01 16:43:08 naddy Exp $	*/
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _SYSTRACE_H_
#define _SYSTRACE_H_

#include <sys/syslimits.h>
#include <sys/ioccom.h>
#include <sys/rwlock.h>

#define SYSTR_EMULEN	8	/* sync with sys proc */

struct str_msg_emul {
	char emul[SYSTR_EMULEN];
};

struct str_msg_ugid {
	uid_t uid;
	gid_t gid;
};

struct str_msg_execve {
	char path[PATH_MAX];
};

#define SYSTR_MAX_POLICIES	64
#define SYSTR_MAXARGS		64
#define SYSTR_MAXFNAME		8
#define SYSTR_MAXINJECTS        8
#define SYSTR_MAXREPLEN		2048

struct str_msg_ask {
	int code;
	int argsize;
	register_t args[SYSTR_MAXARGS];
	register_t rval[2];
	int result;
};

/* Queued on fork or exit of a process */

struct str_msg_child {
	pid_t new_pid;
};

#define SYSTR_MSG_ASK		1
#define SYSTR_MSG_RES		2
#define SYSTR_MSG_EMUL		3
#define SYSTR_MSG_CHILD		4
#define SYSTR_MSG_UGID		5
#define SYSTR_MSG_POLICYFREE	6
#define SYSTR_MSG_EXECVE	7

#define SYSTR_MSG_NOPROCESS(x) \
	((x)->msg.msg_type == SYSTR_MSG_CHILD || \
	 (x)->msg.msg_type == SYSTR_MSG_POLICYFREE)

struct str_message {
	int msg_type;
	pid_t msg_pid;
	u_int16_t msg_seqnr;	/* answer has to match seqnr */
	short msg_policy;
	union {
		struct str_msg_emul msg_emul;
		struct str_msg_ugid msg_ugid;
		struct str_msg_ask msg_ask;
		struct str_msg_child msg_child;
		struct str_msg_execve msg_execve;
	} msg_data;
};

struct systrace_answer {
	pid_t stra_pid;
	u_int16_t stra_seqnr;
	short reserved;
	uid_t stra_seteuid;	/* elevated privileges for system call */
	uid_t stra_setegid;
	int stra_policy;
	int stra_error;
	int stra_flags;
};

struct systrace_scriptname {
	pid_t sn_pid;
	char  sn_scriptname[PATH_MAX];
};

#define SYSTR_READ		1
#define SYSTR_WRITE		2

struct systrace_io {
	pid_t strio_pid;
	int strio_op;
	void *strio_offs;
	void *strio_addr;
	size_t strio_len;
};

#define SYSTR_POLICY_NEW	1
#define SYSTR_POLICY_ASSIGN	2
#define SYSTR_POLICY_MODIFY	3

struct systrace_policy {
	int strp_op;
	int strp_num;
	union {
		struct {
			short code;
			short policy;
		} assign;
		pid_t pid;
		int maxents;
	} strp_data;
};

#define strp_pid	strp_data.pid
#define strp_maxents	strp_data.maxents
#define strp_code	strp_data.assign.code
#define strp_policy	strp_data.assign.policy

#define	SYSTR_NOLINKS	1

struct systrace_replace {
	pid_t strr_pid;
	u_int16_t strr_seqnr;
	int16_t reserved;
	int strr_nrepl;
	caddr_t	strr_base;	/* Base memory */
	size_t strr_len;	/* Length of memory */
	int strr_argind[SYSTR_MAXARGS];
	size_t strr_off[SYSTR_MAXARGS];
	size_t strr_offlen[SYSTR_MAXARGS];
	int32_t strr_flags[SYSTR_MAXARGS];
};

struct systrace_inject {
	/* On return, this contains the stackgap address. */
	caddr_t stri_addr;
	size_t  stri_len;
	pid_t   stri_pid;
};

struct systrace_getcwd {
	pid_t	strgd_pid;
	int	strgd_atfd;
};

#define STRIOCCLONE		_IOR('s', 100, int)
#define SYSTR_CLONE		STRIOCCLONE
#define STRIOCATTACH		_IOW('s', 101, pid_t)
#define STRIOCDETACH		_IOW('s', 102, pid_t)
#define STRIOCANSWER		_IOW('s', 103, struct systrace_answer)
#define STRIOCIO		_IOWR('s', 104, struct systrace_io)
#define STRIOCPOLICY		_IOWR('s', 105, struct systrace_policy)
#define STRIOCGETCWD		_IOW('s', 106, struct systrace_getcwd)
#define STRIOCRESCWD		_IO('s', 107)
#define STRIOCREPORT		_IOW('s', 108, pid_t)
#define STRIOCREPLACE		_IOW('s', 109, struct systrace_replace)
#define STRIOCSCRIPTNAME	_IOW('s', 110, struct systrace_scriptname)
#define STRIOCINJECT		_IOWR('s', 111, struct systrace_inject)

#define SYSTR_POLICY_ASK	0
#define SYSTR_POLICY_PERMIT	1
#define SYSTR_POLICY_NEVER	2
#define SYSTR_POLICY_KILL	3

#define SYSTR_FLAGS_RESULT	0x001
#define SYSTR_FLAGS_SETEUID	0x002
#define SYSTR_FLAGS_SETEGID	0x004

#ifdef _KERNEL
#include <sys/namei.h>

struct str_process;
struct fsystrace {
	struct rwlock lock;
	struct selinfo si;

	TAILQ_HEAD(strprocessq, str_process) processes;
	int nprocesses;

	TAILQ_HEAD(strpolicyq, str_policy) policies;

	struct strprocessq messages;

	int npolicynr;
	int npolicies;

	int issuser;
	uid_t p_ruid;
	gid_t p_rgid;

	/* cwd magic */
	pid_t fd_pid;
	struct vnode *fd_cdir;
	struct vnode *fd_rdir;
};

/* Internal prototypes */

void systrace_namei(struct nameidata *);
int  systrace_redirect(int, struct proc *, void *, register_t *);
void systrace_exit(struct proc *);
struct str_process *systrace_getproc(void);
void systrace_freeproc(struct str_process *);
void systrace_fork(struct proc *, struct proc *, struct str_process *newstrp);
void systrace_execve0(struct proc *);
void systrace_execve1(char *, struct proc *);
int systrace_scriptname(struct proc *, char *);

caddr_t stackgap_init(struct proc *);
void *stackgap_alloc(caddr_t *, size_t);

#endif /* _KERNEL */
#endif /* _SYSTRACE_H_ */
@


1.26
log
@Copy the stackgap_init() and stackgap_alloc() functions from
compat/common/compat_util.c to dev/systrace.c, the one place they
are used, and remove the remaining kernel references to compat/*.
ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.25 2015/01/20 01:48:13 deraadt Exp $	*/
@


1.25
log
@#include <sys/syslimits.h> to allow operation without requiring the noise
of <sys/param.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.24 2015/01/16 00:18:06 deraadt Exp $	*/
d238 3
@


1.24
log
@Move to using PATH_MAX
ok millert guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.23 2011/09/18 23:24:14 matthew Exp $	*/
d35 1
@


1.23
log
@Add support for *at(2) system calls to systrace(1).

ok deraadt@@, sthen@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.22 2011/06/22 01:32:16 djm Exp $	*/
d50 1
a50 1
	char path[MAXPATHLEN];
d112 1
a112 1
	char  sn_scriptname[MAXPATHLEN];
@


1.22
log
@Add a SYSTR_POLICY_KILL per-syscall policy option that sends SIGKILL to
the traced process when the syscall is attempted. This is more useful and
safer for unsupervised sandboxing than returning EPERM (which is the
behaviour of SYSTR_POLICY_NEVER), as this could cause dangerous misbehaviour
in applications that don't expect it.

"I like it" deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.21 2008/11/09 05:13:53 deraadt Exp $	*/
d170 5
d182 1
a182 1
#define STRIOCGETCWD		_IOW('s', 106, pid_t)
@


1.21
log
@systrace activation happens in the middle of a rather sensitive piece of
fork(), i worry about it a lot but cannot prove yet that sleeping there
is bad.  Anyways, this change makes us never sleep in that area -- the
memory needed is allocated ealier like the ptrace state.  tested by many
developers.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.20 2006/10/06 05:47:27 djm Exp $	*/
d187 1
@


1.20
log
@fix an exploitable integer overflow found by Chris Evans of Google
Security; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.19 2006/05/23 22:28:22 alek Exp $	*/
d225 3
a227 1
void systrace_fork(struct proc *, struct proc *);
@


1.19
log
@Replace lockmgr with rwlock; 'i think so' tedu@@, ok sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.18 2004/11/07 20:39:31 marius Exp $	*/
d57 1
@


1.19.2.1
log
@MFC:
Fix by djm@@

fix an exploitable integer overflow found by Chris Evans of Google
Security; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.19 2006/05/23 22:28:22 alek Exp $	*/
a56 1
#define SYSTR_MAXREPLEN		2048
@


1.18
log
@add a new message: inject.  this allows the tracer to to inject buffers into
the stackgap.  this in turn allows for argument replacement with indirection.
for example replacing an entire envp or struct pollfd.

ok provos@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.17 2004/07/07 07:31:40 marius Exp $	*/
d36 1
d196 1
a196 1
	struct lock lock;
@


1.18.4.1
log
@MFC:
Fix by djm@@

fix an exploitable integer overflow found by Chris Evans of Google
Security; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.18 2004/11/07 20:39:31 marius Exp $	*/
a55 1
#define SYSTR_MAXREPLEN		2048
@


1.18.6.1
log
@MFC:
Fix by djm@@

fix an exploitable integer overflow found by Chris Evans of Google
Security; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.18 2004/11/07 20:39:31 marius Exp $	*/
a55 1
#define SYSTR_MAXREPLEN		2048
@


1.17
log
@fix an issue when scripts are exec'd under systrace where
the argv[0] would be normalized, and hence break scripts
that depend on how they were called.

this fixes an issue in the ports builds.

ok provos@@ deraadt@@; lots of testing during hackathon sturm@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.16 2004/06/23 05:16:35 marius Exp $	*/
d55 1
a77 1
#define SYSTR_MSG_SCRIPTNAME	8
d161 7
d180 1
@


1.16
log
@a few fixes to systrace

- add an exec message so that whenever a set-uid/gid process
  exec's a new image which we may control, the exec does not
  go by unnoticed.

- take special care to check for P_SUGIDEXEC as well as
  P_SUGID, corresponding to the same changes that were made in
  the ptrace code a while ago

ok niels@@, sturm@@; thanks to naddy for testing
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.15 2003/10/08 16:30:01 sturm Exp $	*/
d77 1
d108 5
d172 1
d216 3
a218 1
void systrace_execve(char *, struct proc *);
@


1.15
log
@originally from cb@@netbsd.org, adapted by provos

itojun@@ ok

fix a race condition between path resolution in userland
and the subsequent namei(): inform the kernel portion of
valid filenames and then disallow symlink lookups for
those filenames by means of a hook in namei().
with suggestions from provos@@

also, add (currently unused) seqnr field to struct
systrace_replace, from provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.14 2003/06/16 06:36:40 itojun Exp $	*/
d48 4
d76 1
d92 1
d155 11
a165 11
#define STRIOCCLONE	_IOR('s', 100, int)
#define SYSTR_CLONE	STRIOCCLONE
#define STRIOCATTACH	_IOW('s', 101, pid_t)
#define STRIOCDETACH	_IOW('s', 102, pid_t)
#define STRIOCANSWER	_IOW('s', 103, struct systrace_answer)
#define STRIOCIO	_IOWR('s', 104, struct systrace_io)
#define STRIOCPOLICY	_IOWR('s', 105, struct systrace_policy)
#define STRIOCGETCWD	_IOW('s', 106, pid_t)
#define STRIOCRESCWD	_IO('s', 107)
#define STRIOCREPORT	_IOW('s', 108, pid_t)
#define STRIOCREPLACE	_IOW('s', 109, struct systrace_replace)
d206 1
a206 1
int systrace_redirect(int, struct proc *, void *, register_t *);
d209 1
@


1.14
log
@- limited number of processes per systrace
- escape fixes for special characters
markus, sturm ok.  from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.13 2003/03/28 11:52:05 mickey Exp $	*/
d50 1
d134 2
d138 2
d146 1
d170 2
d199 1
@


1.13
log
@fake off the SYSTR_CLONE through a normally numbered other ioctl; as of previous rename; after discussion w/ niels
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.12 2002/12/04 17:37:39 mickey Exp $	*/
d65 6
a70 5
#define SYSTR_MSG_ASK	1
#define SYSTR_MSG_RES	2
#define SYSTR_MSG_EMUL	3
#define SYSTR_MSG_CHILD	4
#define SYSTR_MSG_UGID	5
d73 2
a74 1
	((x)->msg.msg_type == SYSTR_MSG_CHILD)
@


1.12
log
@rename the clone ioctl to avoid clashing w/ the sockio; provos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.11 2002/10/25 23:22:58 fgsch Exp $	*/
a36 3
	/* XXX kill this after a major release */
#define	SYSTR_CLONE	_IOR('s', 1, int)

d142 1
@


1.12.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: systrace.h,v 1.12 2002/12/04 17:37:39 mickey Exp $	*/
d37 3
a144 1
#define SYSTR_CLONE	STRIOCCLONE
@


1.12.4.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 1
#define SYSTR_MAXFNAME		8
d65 5
a69 6
#define SYSTR_MSG_ASK		1
#define SYSTR_MSG_RES		2
#define SYSTR_MSG_EMUL		3
#define SYSTR_MSG_CHILD		4
#define SYSTR_MSG_UGID		5
#define SYSTR_MSG_POLICYFREE	6
d72 1
a72 2
	((x)->msg.msg_type == SYSTR_MSG_CHILD || \
	 (x)->msg.msg_type == SYSTR_MSG_POLICYFREE)
a130 2
#define	SYSTR_NOLINKS	1

a132 2
	u_int16_t strr_seqnr;
	int16_t reserved;
a138 1
	int32_t strr_flags[SYSTR_MAXARGS];
a161 2
#include <sys/namei.h>

a188 1
void systrace_namei(struct nameidata *);
@


1.11
log
@add id tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
d144 1
@


1.10
log
@support for privilege elevation.

with privilege elevation no suid or sgid binaries are necessary any
longer.  Applications can be executed completely
unprivileged. Systrace raises the privileges for a single system call
depending on the configured policy.

Idea from discussions with Perry Metzger, Dug Song and Marcus Watts.

from provos
@
text
@d1 1
@


1.9
log
@new message to track uid/gid changes
from provos
@
text
@d92 2
d157 2
@


1.8
log
@better uid/gid tracking; okay deraadt@@
@
text
@d44 5
d70 1
d82 1
@


1.7
log
@add seqnr to message from kernel, userland needs to quote correct seqnr.
avoids problems where tsleep has been interrupted by a signal.
@
text
@d166 2
@


1.6
log
@system call argument rewriting framework via stackgap; okay art@@
@
text
@d72 1
a73 1
	short reserved;
d83 2
@


1.5
log
@forgot copyright, pointed out by christos@@netbsd
@
text
@d121 10
d139 1
@


1.4
log
@new ioctl that reports the current emulation a process uses; needed for
attaching to a running process
@
text
@d1 30
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d98 1
@


1.4.2.2
log
@sync to -current
@
text
@a0 31
/*	$OpenBSD$	*/
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

a13 5
struct str_msg_ugid {
	uid_t uid;
	gid_t gid;
};

a34 1
#define SYSTR_MSG_UGID	5
a41 1
	u_int16_t msg_seqnr;	/* answer has to match seqnr */
d43 1
a45 1
		struct str_msg_ugid msg_ugid;
a52 4
	u_int16_t stra_seqnr;
	short reserved;
	uid_t stra_seteuid;	/* elevated privileges for system call */
	uid_t stra_setegid;
a90 10
struct systrace_replace {
	pid_t strr_pid;
	int strr_nrepl;
	caddr_t	strr_base;	/* Base memory */
	size_t strr_len;	/* Length of memory */
	int strr_argind[SYSTR_MAXARGS];
	size_t strr_off[SYSTR_MAXARGS];
	size_t strr_offlen[SYSTR_MAXARGS];
};

a97 2
#define STRIOCREPORT	_IOW('s', 108, pid_t)
#define STRIOCREPLACE	_IOW('s', 109, struct systrace_replace)
a103 2
#define SYSTR_FLAGS_SETEUID	0x002
#define SYSTR_FLAGS_SETEGID	0x004
a121 2
	uid_t p_ruid;
	gid_t p_rgid;
@


1.4.2.3
log
@sync
@
text
@d37 2
a142 2
#define STRIOCCLONE	_IOR('s', 100, int)
#define SYSTR_CLONE	STRIOCCLONE
@


1.3
log
@explicit padding; okay deraadt@@
@
text
@d98 1
@


1.2
log
@make fsystrace available in systrace.h; keep some more stats.
@
text
@d43 1
@


1.1
log
@systrace facility, used to enforce and generate policies for system calls
okay deraadt@@
@
text
@d105 23
@

