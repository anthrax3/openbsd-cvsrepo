head	1.72;
access;
symbols
	OPENBSD_6_0:1.71.0.4
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.70.0.2
	OPENBSD_5_9_BASE:1.70
	OPENBSD_5_8:1.65.0.4
	OPENBSD_5_8_BASE:1.65
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.61.0.4
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.59.0.4
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.59.0.2
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.58.0.6
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.8
	OPENBSD_5_0:1.58.0.4
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.58.0.2
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.57.0.4
	OPENBSD_4_8_BASE:1.57
	OPENBSD_4_7:1.57.0.2
	OPENBSD_4_7_BASE:1.57
	OPENBSD_4_6:1.56.0.6
	OPENBSD_4_6_BASE:1.56
	OPENBSD_4_5:1.56.0.2
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.55.0.2
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.54.0.2
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.53.0.4
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.53.0.2
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.47.0.2
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.25
	UBC:1.20.0.4
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	SMP:1.15.0.4
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.72
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.71;
commitid	VyLWTsbepAOk7VQM;

1.71
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.70;
commitid	QHiEhS9DHyE6oiIr;

1.70
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.69;
commitid	B0kwmVGiD5DVx4kv;

1.69
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.68;
commitid	5gdEnqVoJuTuwdTu;

1.68
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.67;
commitid	5DvsamK0GblTp8ww;

1.67
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.66;
commitid	eYnPulzvLjDImPCa;

1.66
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.65;
commitid	p0v5tuE1Ch6fY0Nj;

1.65
date	2015.06.21.21.22.27;	author krw;	state Exp;
branches;
next	1.64;
commitid	IkPG2hQtii3T4sXA;

1.64
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.63;
commitid	Hly9lJn6CNMylcFu;

1.63
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.62;
commitid	yM2VFFhpDTeFQlve;

1.62
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.61;
commitid	uzzBR7hz9ncd4O6G;

1.61
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.60;
commitid	TGHgrLxu6sxZoiFt;

1.60
date	2013.08.07.01.06.27;	author bluhm;	state Exp;
branches;
next	1.59;

1.59
date	2012.12.05.23.20.16;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.57;

1.57
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.30.11.33.14;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.03.18.16.43;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.25.18.50.51;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.05.14.28.20;	author kurt;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.25.22.41.42;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.04.04.43.28;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2006.02.20.11.13.57;	author jsg;	state Exp;
branches;
next	1.46;

1.46
date	2006.01.30.11.41.00;	author jsg;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.09.21.19.47;	author jsg;	state Exp;
branches;
next	1.44;

1.44
date	2005.11.09.05.50.25;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.25.15.49.37;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2005.06.20.22.42.29;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.24.00.25.05;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.02.04.01.07.39;	author kurt;	state Exp;
branches;
next	1.39;

1.39
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.05.20.06.58;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.05.12.43.26;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.05.07.58.55;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.24.21.26.05;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.21.18.58.48;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.05.01.26.11;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.26.01.29.55;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.25.22.32.27;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.23.11.13.20;	author avsm;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.19.00.27.02;	author avsm;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.15.20.32.16;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.25.22.28.14;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.23.18.02.47;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.10.20.21.15;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.02.18.34.11;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.29.21.54.00;	author mickey;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2001.07.08.23.38.05;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.25.21.11.16;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.23.23.36.02;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.10.19.26.16;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.17.04.34.08;	author aaron;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.04.16.00.40.40;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.27.06.48.28;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.26.06.19.33;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.20.19.39.38;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.10.17.50.15;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.20.20.35.14;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.20.19.39.36;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.20.03.24.21;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.19.00.12.41;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.18.18.42.08;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.18.03.56.07;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.18.03.26.51;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.04.01.49;	author mickey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.04.03.01.01.58;	author mickey;	state Exp;
branches;
next	;

1.2.2.1
date	2000.06.18.04.29.34;	author jason;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.06.18.18.56.13;	author jason;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2000.06.19.03.21.52;	author jason;	state Exp;
branches;
next	;

1.15.4.1
date	2001.05.14.22.23.30;	author niklas;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2001.07.04.10.40.37;	author niklas;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.15.4.4;

1.15.4.4
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.15.4.5;

1.15.4.5
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.15.4.6;

1.15.4.6
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.15.4.7;

1.15.4.7
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	;

1.20.4.1
date	2002.01.31.22.55.30;	author niklas;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	;


desc
@@


1.72
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: an.c,v 1.71 2016/04/13 10:49:26 mpi Exp $	*/
/*	$NetBSD: an.c,v 1.34 2005/06/20 02:49:18 atatat Exp $	*/
/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/an/if_an.c,v 1.12 2000/11/13 23:04:12 wpaul Exp $
 */
/*
 * Copyright (c) 2004, 2005 David Young.  All rights reserved.
 * Copyright (c) 2004, 2005 OJC Technologies.  All rights reserved.
 * Copyright (c) 2004, 2005 Dayton Data Center Services, LLC.  All
 *     rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY David Young AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL David Young AND CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Aironet 4500/4800 802.11 PCMCIA/ISA/PCI driver for FreeBSD.
 *
 * Written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * Ported to NetBSD from FreeBSD by Atsushi Onoe at the San Diego
 * IETF meeting.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/ucred.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/device.h>
#include <sys/endian.h>
#include <sys/tree.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_llc.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_radiotap.h>
#include <net80211/ieee80211_var.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/ic/anreg.h>
#include <dev/ic/anvar.h>

struct cfdriver an_cd = {
	NULL, "an", DV_IFNET
};

int	an_reset(struct an_softc *);
void	an_wait(struct an_softc *);
int	an_init(struct ifnet *);
void	an_stop(struct ifnet *, int);
void	an_start(struct ifnet *);
void	an_watchdog(struct ifnet *);
int	an_ioctl(struct ifnet *, u_long, caddr_t);
int	an_media_change(struct ifnet *);
void	an_media_status(struct ifnet *, struct ifmediareq *);

int	an_set_nwkey(struct an_softc *, struct ieee80211_nwkey *);
int	an_set_nwkey_wep(struct an_softc *, struct ieee80211_nwkey *);
int	an_get_nwkey(struct an_softc *, struct ieee80211_nwkey *);
int	an_write_wepkey(struct an_softc *, int, struct an_wepkey *,
				int);

void	an_rxeof(struct an_softc *);
void	an_txeof(struct an_softc *, u_int16_t);
void	an_linkstat_intr(struct an_softc *);

int	an_cmd(struct an_softc *, int, int);
int	an_seek_bap(struct an_softc *, int, int);
int	an_read_bap(struct an_softc *, int, int, void *, int, int);
int	an_write_bap(struct an_softc *, int, int, void *, int);
int	an_mwrite_bap(struct an_softc *, int, int, struct mbuf *, int);
int	an_read_rid(struct an_softc *, int, void *, int *);
int	an_write_rid(struct an_softc *, int, void *, int);

int	an_alloc_nicmem(struct an_softc *, int, int *);

int	an_newstate(struct ieee80211com *, enum ieee80211_state, int);

#ifdef AN_DEBUG
int an_debug = 0;

#define	DPRINTF(X)	if (an_debug) printf X
#define	DPRINTF2(X)	if (an_debug > 1) printf X
#else
#define	DPRINTF(X)
#define	DPRINTF2(X)
#endif

#if BYTE_ORDER == BIG_ENDIAN
static __inline void
an_swap16(u_int16_t *p, int cnt)
{
        for (; cnt--; p++)
                *p = swap16(*p);
}
#define an_switch32(val)	(val >> 16 | (val & 0xFFFF) << 16)
#else
#define an_swap16(p, cnt)
#define an_switch32(val)	val
#endif

int
an_attach(struct an_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int i;
	struct an_rid_wepkey *akey;
	int buflen, kid, rid;
	int chan, chan_min, chan_max;

	sc->sc_invalid = 0;

	/* disable interrupts */
	CSR_WRITE_2(sc, AN_INT_EN, 0);
	CSR_WRITE_2(sc, AN_EVENT_ACK, 0xffff);

//	an_wait(sc);
	if (an_reset(sc) != 0) {
		sc->sc_invalid = 1;
		return 1;
	}

	/* Load factory config */
	if (an_cmd(sc, AN_CMD_READCFG, 0) != 0) {
		printf("%s: failed to load config data\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}

	/* Read the current configuration */
	buflen = sizeof(sc->sc_config);
	if (an_read_rid(sc, AN_RID_GENCONFIG, &sc->sc_config, &buflen) != 0) {
		printf("%s: read config failed\n", sc->sc_dev.dv_xname);
		return(EIO);
	}

	an_swap16((u_int16_t *)&sc->sc_config.an_macaddr, 3); 

	/* Read the card capabilities */
	buflen = sizeof(sc->sc_caps);
	if (an_read_rid(sc, AN_RID_CAPABILITIES, &sc->sc_caps, &buflen) != 0) {
		printf("%s: read caps failed\n", sc->sc_dev.dv_xname);
		return(EIO);
	}

	an_swap16((u_int16_t *)&sc->sc_caps.an_oemaddr, 3); 
	an_swap16((u_int16_t *)&sc->sc_caps.an_rates, 4);

	/* Read WEP settings from persistent memory */
	akey = &sc->sc_buf.sc_wepkey;
	buflen = sizeof(struct an_rid_wepkey);
	rid = AN_RID_WEP_VOLATILE;	/* first persistent key */
	while (an_read_rid(sc, rid, akey, &buflen) == 0) {
		an_swap16((u_int16_t *)&akey->an_mac_addr, 3); 
		an_swap16((u_int16_t *)&akey->an_key, 8); 
		kid = akey->an_key_index;
		DPRINTF(("an_attach: wep rid=0x%x len=%d(%d) index=0x%04x "
		    "mac[0]=%02x keylen=%d\n",
		    rid, buflen, sizeof(*akey), kid,
		    akey->an_mac_addr[0], akey->an_key_len));
		if (kid == 0xffff) {
			sc->sc_tx_perskey = akey->an_mac_addr[0];
			sc->sc_tx_key = -1;
			break;
		}
		if (kid >= IEEE80211_WEP_NKID)
			break;
		sc->sc_perskeylen[kid] = akey->an_key_len;
		sc->sc_wepkeys[kid].an_wep_keylen = -1;
		rid = AN_RID_WEP_PERSISTENT;	/* for next key */
		buflen = sizeof(struct an_rid_wepkey);
	}

	IEEE80211_ADDR_COPY(ic->ic_myaddr, sc->sc_caps.an_oemaddr);
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	printf("%s: Firmware %x.%02x.%02x, Radio: ", ifp->if_xname,
	    sc->sc_caps.an_fwrev >> 8,
	    sc->sc_caps.an_fwrev & 0xff,
	    sc->sc_caps.an_fwsubrev);

	if (sc->sc_config.an_radiotype & AN_RADIOTYPE_80211_FH)
		printf("802.11 FH");
	else if (sc->sc_config.an_radiotype & AN_RADIOTYPE_80211_DS)
		printf("802.11 DS");
	else if (sc->sc_config.an_radiotype & AN_RADIOTYPE_LM2000_DS)
		printf("LM2000 DS");
	else
		printf("unknown (%x)", sc->sc_config.an_radiotype);

	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));
	
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = an_ioctl;
	ifp->if_start = an_start;
	ifp->if_watchdog = an_watchdog;

	ic->ic_phytype = IEEE80211_T_DS;
	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_caps = IEEE80211_C_WEP | IEEE80211_C_PMGT | IEEE80211_C_MONITOR;
#ifndef IEEE80211_STA_ONLY
	ic->ic_caps |= IEEE80211_C_IBSS;
#endif
	ic->ic_state = IEEE80211_S_INIT;
	IEEE80211_ADDR_COPY(ic->ic_myaddr, sc->sc_caps.an_oemaddr);

	switch (sc->sc_caps.an_regdomain) {
	default:
	case AN_REGDOMAIN_USA:
	case AN_REGDOMAIN_CANADA:
		chan_min = 1; chan_max = 11; break;
	case AN_REGDOMAIN_EUROPE:
	case AN_REGDOMAIN_AUSTRALIA:
		chan_min = 1; chan_max = 13; break;
	case AN_REGDOMAIN_JAPAN:
		chan_min = 14; chan_max = 14; break;
	case AN_REGDOMAIN_SPAIN:
		chan_min = 10; chan_max = 11; break;
	case AN_REGDOMAIN_FRANCE:
		chan_min = 10; chan_max = 13; break;
	case AN_REGDOMAIN_JAPANWIDE:
		chan_min = 1; chan_max = 14; break;
	}

	for (chan = chan_min; chan <= chan_max; chan++) {
		ic->ic_channels[chan].ic_freq =
		    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[chan].ic_flags = IEEE80211_CHAN_B;
	}
	ic->ic_ibss_chan = &ic->ic_channels[chan_min];

	/* Find supported rate */
	for (i = 0; i < sizeof(sc->sc_caps.an_rates); i++) {
		if (sc->sc_caps.an_rates[i] == 0)
			continue;
		ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[
		    ic->ic_sup_rates[IEEE80211_MODE_11B].rs_nrates++] =
		    sc->sc_caps.an_rates[i];
	}

	/*
	 * Call MI attach routine.
	 */
	if_attach(ifp);
	ieee80211_ifattach(ifp);

	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = an_newstate;

	ieee80211_media_init(ifp, an_media_change, an_media_status);

#if NBPFILTER > 0
	bzero(&sc->sc_rxtapu, sizeof(sc->sc_rxtapu));
	sc->sc_rxtap.ar_ihdr.it_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.ar_ihdr.it_present = AN_RX_RADIOTAP_PRESENT;

	bzero(&sc->sc_txtapu, sizeof(sc->sc_txtapu));
	sc->sc_txtap.at_ihdr.it_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.at_ihdr.it_present = AN_TX_RADIOTAP_PRESENT;

	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + 64);
#endif

	sc->sc_attached = 1;

	return(0);
}

void
an_rxeof(struct an_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct an_rxframe frmhdr;
	struct mbuf *m;
	u_int16_t status;
	int fid, gaplen, len, off;
	uint8_t *gap;

	fid = CSR_READ_2(sc, AN_RX_FID);

	/* First read in the frame header */
	if (an_read_bap(sc, fid, 0, &frmhdr, sizeof(frmhdr), sizeof(frmhdr)) != 0) {
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_RX);
		ifp->if_ierrors++;
		DPRINTF(("an_rxeof: read fid %x failed\n", fid));
		return;
	}
	an_swap16((u_int16_t *)&frmhdr.an_whdr, sizeof(struct ieee80211_frame)/2);

	status = frmhdr.an_rx_status;
	if ((status & AN_STAT_ERRSTAT) != 0 &&
	    ic->ic_opmode != IEEE80211_M_MONITOR) {
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_RX);
		ifp->if_ierrors++;
		DPRINTF(("an_rxeof: fid %x status %x\n", fid, status));
		return;
	}

	/* the payload length field includes a 16-bit "mystery field" */
	len = frmhdr.an_rx_payload_len - sizeof(uint16_t);
	off = ALIGN(sizeof(struct ieee80211_frame));

	if (off + len > MCLBYTES) {
		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_RX);
			ifp->if_ierrors++;
			DPRINTF(("an_rxeof: oversized packet %d\n", len));
			return;
		}
		len = 0;
	}

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_RX);
		ifp->if_ierrors++;
		DPRINTF(("an_rxeof: MGET failed\n"));
		return;
	}
	if (off + len + AN_GAPLEN_MAX > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_RX);
			m_freem(m);
			ifp->if_ierrors++;
			DPRINTF(("an_rxeof: MCLGET failed\n"));
			return;
		}
	}
	m->m_data += off - sizeof(struct ieee80211_frame);

	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
		gaplen = frmhdr.an_gaplen;
		if (gaplen > AN_GAPLEN_MAX) {
			CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_RX);
			m_freem(m);
			ifp->if_ierrors++;
			DPRINTF(("%s: gap too long\n", __func__));
			return;
		}
		/*
		 * We don't need the 16-bit mystery field (payload length?),
		 * so read it into the region reserved for the 802.11 header.
		 *
		 * When Cisco Aironet 350 cards w/ firmware version 5 or
		 * greater operate with certain Cisco 350 APs,
		 * the "gap" is filled with the SNAP header.  Read
		 * it in after the 802.11 header.
		 */
		gap = m->m_data + sizeof(struct ieee80211_frame) -
		    sizeof(uint16_t);
		an_read_bap(sc, fid, -1, gap, gaplen + sizeof(u_int16_t),
		    gaplen + sizeof(u_int16_t));
	} else
		gaplen = 0;

	an_read_bap(sc, fid, -1,
	    m->m_data + sizeof(struct ieee80211_frame) + gaplen, len, len);
	an_swap16((u_int16_t *)(m->m_data + sizeof(struct ieee80211_frame) + gaplen), (len+1)/2);
	m->m_pkthdr.len = m->m_len = sizeof(struct ieee80211_frame) + gaplen +
	    len;

	memcpy(m->m_data, &frmhdr.an_whdr, sizeof(struct ieee80211_frame));
	CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_RX);

#if NBPFILTER > 0
	if (sc->sc_drvbpf) {
		struct mbuf mb;
		struct an_rx_radiotap_header *tap = &sc->sc_rxtap;

		tap->ar_rate = frmhdr.an_rx_rate;
		tap->ar_antsignal = frmhdr.an_rx_signal_strength;
		tap->ar_chan_freq = ic->ic_bss->ni_chan->ic_freq;
		tap->ar_chan_flags = ic->ic_bss->ni_chan->ic_flags;


		mb.m_data = (caddr_t)tap;
		mb.m_len = sizeof(sc->sc_rxtapu);
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif /* NBPFILTER > 0 */

	wh = mtod(m, struct ieee80211_frame *);
	rxi.rxi_flags = 0;
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		/*
		 * WEP is decrypted by hardware. Clear WEP bit
		 * header for ieee80211_input().
		 */
		wh->i_fc[1] &= ~IEEE80211_FC1_WEP;

		rxi.rxi_flags |= IEEE80211_RXI_HWDEC;
	}

	ni = ieee80211_find_rxnode(ic, wh);
	rxi.rxi_rssi = frmhdr.an_rx_signal_strength;
	rxi.rxi_tstamp = an_switch32(frmhdr.an_rx_time);
	ieee80211_input(ifp, m, ni, &rxi);
	ieee80211_release_node(ic, ni);
}

void
an_txeof(struct an_softc *sc, u_int16_t status)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int cur, id;

	sc->sc_tx_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	id = CSR_READ_2(sc, AN_TX_CMP_FID);
	CSR_WRITE_2(sc, AN_EVENT_ACK, status & (AN_EV_TX | AN_EV_TX_EXC));

	if (status & AN_EV_TX_EXC)
		ifp->if_oerrors++;

	cur = sc->sc_txcur;
	if (sc->sc_txd[cur].d_fid == id) {
		sc->sc_txd[cur].d_inuse = 0;
		DPRINTF2(("an_txeof: sent %x/%d\n", id, cur));
		AN_INC(cur, AN_TX_RING_CNT);
		sc->sc_txcur = cur;
	} else {
		for (cur = 0; cur < AN_TX_RING_CNT; cur++) {
			if (id == sc->sc_txd[cur].d_fid) {
				sc->sc_txd[cur].d_inuse = 0;
				break;
			}
		}
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: tx mismatch: "
			    "expected %x(%d), actual %x(%d)\n",
			    sc->sc_dev.dv_xname,
			    sc->sc_txd[sc->sc_txcur].d_fid, sc->sc_txcur,
			    id, cur);
	}
}

int
an_intr(void *arg)
{
	struct an_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int i;
	u_int16_t status;

	if (!sc->sc_enabled || sc->sc_invalid ||
	    (sc->sc_dev.dv_flags & DVF_ACTIVE) == 0 ||
	    (ifp->if_flags & IFF_RUNNING) == 0)
		return 0;

	if ((ifp->if_flags & IFF_UP) == 0) {
		CSR_WRITE_2(sc, AN_INT_EN, 0);
		CSR_WRITE_2(sc, AN_EVENT_ACK, ~0);
		return 1;
	}

	/* maximum 10 loops per interrupt */
	for (i = 0; i < 10; i++) {
		if (!sc->sc_enabled || sc->sc_invalid)
			return 1;
		if (CSR_READ_2(sc, AN_SW0) != AN_MAGIC) {
			DPRINTF(("an_intr: magic number changed: %x\n",
			    CSR_READ_2(sc, AN_SW0)));
			sc->sc_invalid = 1;
			return 1;
		}
		status = CSR_READ_2(sc, AN_EVENT_STAT);
		CSR_WRITE_2(sc, AN_EVENT_ACK, status & ~(AN_INTRS));
		if ((status & AN_INTRS) == 0)
			break;

		if (status & AN_EV_RX)
			an_rxeof(sc);

		if (status & (AN_EV_TX | AN_EV_TX_EXC))
			an_txeof(sc, status);

		if (status & AN_EV_LINKSTAT)
			an_linkstat_intr(sc);

		if (ifq_is_oactive(&ifp->if_snd) == 0 &&
		    sc->sc_ic.ic_state == IEEE80211_S_RUN &&
		    !IFQ_IS_EMPTY(&ifp->if_snd))
			an_start(ifp);
	}

	return 1;
}

/* Must be called at proper protection level! */
int
an_cmd(struct an_softc *sc, int cmd, int val)
{
	int i, stat;

	/* make sure previous command completed */
	if (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("%s: command 0x%x busy\n", sc->sc_dev.dv_xname,
			    CSR_READ_2(sc, AN_COMMAND));
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);
	}

	CSR_WRITE_2(sc, AN_PARAM0, val);
	CSR_WRITE_2(sc, AN_PARAM1, 0);
	CSR_WRITE_2(sc, AN_PARAM2, 0);
	CSR_WRITE_2(sc, AN_COMMAND, cmd);

	if (cmd == AN_CMD_FW_RESTART) {
		/* XXX: should sleep here */
		DELAY(100*1000);
	}

	for (i = 0; i < AN_TIMEOUT; i++) {
		if (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)
			break;
		DELAY(10);
	}

	stat = CSR_READ_2(sc, AN_STATUS);

	/* clear stuck command busy if necessary */
	if (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY)
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CLR_STUCK_BUSY);

	/* Ack the command */
	CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);

	if (i == AN_TIMEOUT) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("%s: command 0x%x param 0x%x timeout\n",
			    sc->sc_dev.dv_xname, cmd, val);
		return ETIMEDOUT;
	}
	if (stat & AN_STAT_CMD_RESULT) {
		if (sc->sc_ic.ic_if.if_flags & IFF_DEBUG)
			printf("%s: command 0x%x param 0x%x status 0x%x "
			    "resp 0x%x 0x%x 0x%x\n",
			    sc->sc_dev.dv_xname, cmd, val, stat,
			    CSR_READ_2(sc, AN_RESP0), CSR_READ_2(sc, AN_RESP1),
			    CSR_READ_2(sc, AN_RESP2));
		return EIO;
	}

	return 0;
}

int
an_reset(struct an_softc *sc)
{

	DPRINTF(("an_reset\n"));

	if (!sc->sc_enabled)
		return ENXIO;

	an_cmd(sc, AN_CMD_ENABLE, 0);
	an_cmd(sc, AN_CMD_FW_RESTART, 0);
	an_cmd(sc, AN_CMD_NOOP2, 0);

	if (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT) {
		printf("%s: reset failed\n", sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

	an_cmd(sc, AN_CMD_DISABLE, 0);
	return 0;
}

void
an_linkstat_intr(struct an_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	u_int16_t status;

	status = CSR_READ_2(sc, AN_LINKSTAT);
	CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_LINKSTAT);
	DPRINTF(("an_linkstat_intr: status 0x%x\n", status));

	if (status == AN_LINKSTAT_ASSOCIATED) {
		if (ic->ic_state != IEEE80211_S_RUN
#ifndef IEEE80211_STA_ONLY
		    || ic->ic_opmode == IEEE80211_M_IBSS
#endif
		    )
			ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	} else {
		if (ic->ic_opmode == IEEE80211_M_STA)
			ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
	}
}

/*
 * Wait for firmware come up after power enabled.
 */
void
an_wait(struct an_softc *sc)
{
	int i;

	CSR_WRITE_2(sc, AN_COMMAND, AN_CMD_NOOP2);
	for (i = 0; i < 3*hz; i++) {
		if (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_CMD)
			break;
		(void)tsleep(sc, PWAIT, "anatch", 1);
	}
	CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);
}

int
an_read_bap(struct an_softc *sc, int id, int off, void *buf, int len, int blen)
{
	int error, cnt, cnt2;

	if (len == 0 || blen == 0)
		return 0;
	if (off == -1)
		off = sc->sc_bap_off;
	if (id != sc->sc_bap_id || off != sc->sc_bap_off) {
		if ((error = an_seek_bap(sc, id, off)) != 0)
			return EIO;
	}

	cnt = (blen + 1) / 2;
	CSR_READ_MULTI_STREAM_2(sc, AN_DATA0, (u_int16_t *)buf, cnt);
	for (cnt2 = (len + 1) / 2; cnt < cnt2; cnt++)
		(void) CSR_READ_2(sc, AN_DATA0);
	sc->sc_bap_off += cnt * 2;

	return 0;
}

int
an_write_bap(struct an_softc *sc, int id, int off, void *buf, int buflen)
{
	int error, cnt;

	if (buflen == 0)
		return 0;
	if (off == -1)
		off = sc->sc_bap_off;
	if (id != sc->sc_bap_id || off != sc->sc_bap_off) {
		if ((error = an_seek_bap(sc, id, off)) != 0)
			return EIO;
	}

	cnt = (buflen + 1) / 2;
	CSR_WRITE_MULTI_STREAM_2(sc, AN_DATA0, (u_int16_t *)buf, cnt);
	sc->sc_bap_off += cnt * 2;
	return 0;
}

int
an_seek_bap(struct an_softc *sc, int id, int off)
{
	int i, status;

	CSR_WRITE_2(sc, AN_SEL0, id);
	CSR_WRITE_2(sc, AN_OFF0, off);

	for (i = 0; ; i++) {
		status = CSR_READ_2(sc, AN_OFF0);
		if ((status & AN_OFF_BUSY) == 0)
			break;
		if (i == AN_TIMEOUT) {
			printf("%s: timeout in an_seek_bap to 0x%x/0x%x\n",
			    sc->sc_dev.dv_xname, id, off);
			sc->sc_bap_off = AN_OFF_ERR;	/* invalidate */
			return ETIMEDOUT;
		}
		DELAY(10);
	}
	if (status & AN_OFF_ERR) {
		printf("%s: failed in an_seek_bap to 0x%x/0x%x\n",
		    sc->sc_dev.dv_xname, id, off);
		sc->sc_bap_off = AN_OFF_ERR;	/* invalidate */
		return EIO;
	}
	sc->sc_bap_id = id;
	sc->sc_bap_off = off;
	return 0;
}

int
an_mwrite_bap(struct an_softc *sc, int id, int off, struct mbuf *m, int totlen)
{
	int error, len, cnt;

	if (off == -1)
		off = sc->sc_bap_off;
	if (id != sc->sc_bap_id || off != sc->sc_bap_off) {
		if ((error = an_seek_bap(sc, id, off)) != 0)
			return EIO;
	}

	for (len = 0; m != NULL; m = m->m_next) {
		if (m->m_len == 0)
			continue;
		len = min(m->m_len, totlen);

		if ((mtod(m, u_long) & 0x1) || (len & 0x1)) {
			m_copydata(m, 0, totlen, (caddr_t)&sc->sc_buf.sc_txbuf);
			cnt = (totlen + 1) / 2;
			an_swap16((u_int16_t *)&sc->sc_buf.sc_txbuf, cnt); 
			CSR_WRITE_MULTI_STREAM_2(sc, AN_DATA0,
			    sc->sc_buf.sc_val, cnt);
			off += cnt * 2;
			break;
		}
		cnt = len / 2;
		an_swap16((u_int16_t *)mtod(m, u_int16_t *), cnt); 
		CSR_WRITE_MULTI_STREAM_2(sc, AN_DATA0, mtod(m, u_int16_t *),
		    cnt);
		off += len;
		totlen -= len;
	}
	sc->sc_bap_off = off;
	return 0;
}

int
an_alloc_nicmem(struct an_softc *sc, int len, int *idp)
{
	int i;

	if (an_cmd(sc, AN_CMD_ALLOC_MEM, len)) {
		printf("%s: failed to allocate %d bytes on NIC\n",
		    sc->sc_dev.dv_xname, len);
		return(ENOMEM);
	}

	for (i = 0; i < AN_TIMEOUT; i++) {
		if (CSR_READ_2(sc, AN_EVENT_STAT) & AN_EV_ALLOC)
			break;
		if (i == AN_TIMEOUT) {
			printf("%s: timeout in alloc\n", sc->sc_dev.dv_xname);
			return ETIMEDOUT;
		}
		DELAY(10);
	}

	*idp = CSR_READ_2(sc, AN_ALLOC_FID);
	CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_ALLOC);
	return 0;
}

int
an_read_rid(struct an_softc *sc, int rid, void *buf, int *buflenp)
{
	int error;
	u_int16_t len;

	/* Tell the NIC to enter record read mode. */
	error = an_cmd(sc, AN_CMD_ACCESS | AN_ACCESS_READ, rid);
	if (error)
		return error;

	/* length in byte, including length itself */
	error = an_read_bap(sc, rid, 0, &len, sizeof(len), sizeof(len));
	if (error)
		return error;

	len -= 2;
	return an_read_bap(sc, rid, sizeof(len), buf, len, *buflenp);
}

int
an_write_rid(struct an_softc *sc, int rid, void *buf, int buflen)
{
	int error;
	u_int16_t len;

	/* length in byte, including length itself */
	len = buflen + 2;

	error = an_write_bap(sc, rid, 0, &len, sizeof(len));
	if (error)
		return error;
	error = an_write_bap(sc, rid, sizeof(len), buf, buflen);
	if (error)
		return error;

	return an_cmd(sc, AN_CMD_ACCESS | AN_ACCESS_WRITE, rid);
}

int
an_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct an_softc *sc = ifp->if_softc;
	int s, error = 0;

	if ((sc->sc_dev.dv_flags & DVF_ACTIVE) == 0)
		return ENXIO;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		error = an_init(ifp);
		break;
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (sc->sc_enabled) {
				/*
				 * To avoid rescanning another access point,
				 * do not call an_init() here.  Instead, only
				 * reflect promisc mode settings.
				 */
				error = an_cmd(sc, AN_CMD_SET_MODE,
				    (ifp->if_flags & IFF_PROMISC) ? 0xffff : 0);
			} else
				error = an_init(ifp);
		} else if (sc->sc_enabled)
			an_stop(ifp, 1);
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		/* The Aironet has no multicast filter. */
		error = 0;
		break;
	case SIOCS80211NWKEY:
		error = an_set_nwkey(sc, (struct ieee80211_nwkey *)data);
			break;
	case SIOCG80211NWKEY:
		error = an_get_nwkey(sc, (struct ieee80211_nwkey *)data);
		break;
	default:
		error = ieee80211_ioctl(ifp, command, data);
		break;
	}
	if (error == ENETRESET) {
		if (sc->sc_enabled)
			error = an_init(ifp);
		else
			error = 0;
	}
	splx(s);
	return(error);
}

int
an_init(struct ifnet *ifp)
{
	struct an_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int i, error, fid;

	DPRINTF(("an_init: enabled %d\n", sc->sc_enabled));
	if (!sc->sc_enabled) {
		if (sc->sc_enable)
			(*sc->sc_enable)(sc);
		an_wait(sc);
		sc->sc_enabled = 1;
	} else {
		an_stop(ifp, 0);
		if ((error = an_reset(sc)) != 0) {
			printf("%s: failed to reset\n", ifp->if_xname);
			an_stop(ifp, 1);
			return error;
		}
	}
	CSR_WRITE_2(sc, AN_SW0, AN_MAGIC);

	/* Allocate the TX buffers */
	for (i = 0; i < AN_TX_RING_CNT; i++) {
		if ((error = an_alloc_nicmem(sc, AN_TX_MAX_LEN, &fid)) != 0) {
			printf("%s: failed to allocate nic memory\n",
			    ifp->if_xname);
			an_stop(ifp, 1);
			return error;
		}
		DPRINTF2(("an_init: txbuf %d allocated %x\n", i, fid));
		sc->sc_txd[i].d_fid = fid;
		sc->sc_txd[i].d_inuse = 0;
	}
	sc->sc_txcur = sc->sc_txnext = 0;

	IEEE80211_ADDR_COPY(sc->sc_config.an_macaddr, ic->ic_myaddr);
	an_swap16((u_int16_t *)&sc->sc_config.an_macaddr, 3); 
	sc->sc_config.an_scanmode = AN_SCANMODE_ACTIVE;
	sc->sc_config.an_authtype = AN_AUTHTYPE_OPEN;	/*XXX*/
	if (ic->ic_flags & IEEE80211_F_WEPON) {
		sc->sc_config.an_authtype |=
		    AN_AUTHTYPE_PRIVACY_IN_USE;
	}
	sc->sc_config.an_listen_interval = ic->ic_lintval;
	sc->sc_config.an_beacon_period = ic->ic_lintval;
	if (ic->ic_flags & IEEE80211_F_PMGTON)
		sc->sc_config.an_psave_mode = AN_PSAVE_PSP;
	else
		sc->sc_config.an_psave_mode = AN_PSAVE_CAM;
	sc->sc_config.an_ds_channel =
	    ieee80211_chan2ieee(ic, ic->ic_ibss_chan);

	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		sc->sc_config.an_opmode =
		    AN_OPMODE_INFRASTRUCTURE_STATION;
		sc->sc_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		sc->sc_config.an_opmode = AN_OPMODE_IBSS_ADHOC;
		sc->sc_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;
		break;
#endif
	case IEEE80211_M_MONITOR:
		sc->sc_config.an_opmode =
		    AN_OPMODE_INFRASTRUCTURE_STATION;
		sc->sc_config.an_rxmode =
		    AN_RXMODE_80211_MONITOR_ANYBSS;
		sc->sc_config.an_authtype = AN_AUTHTYPE_NONE;
		if (ic->ic_flags & IEEE80211_F_WEPON)
			sc->sc_config.an_authtype |=
			    AN_AUTHTYPE_PRIVACY_IN_USE |
		            AN_AUTHTYPE_ALLOW_UNENCRYPTED;
		break;
	default:
		printf("%s: bad opmode %d\n", ifp->if_xname, ic->ic_opmode);
		an_stop(ifp, 1);
		return EIO;
	}
	sc->sc_config.an_rxmode |= AN_RXMODE_NO_8023_HEADER;

	/* Set the ssid list */
	memset(&sc->sc_buf, 0, sizeof(sc->sc_buf.sc_ssidlist));
	sc->sc_buf.sc_ssidlist.an_entry[0].an_ssid_len =
	    ic->ic_des_esslen;
	if (ic->ic_des_esslen)
		memcpy(sc->sc_buf.sc_ssidlist.an_entry[0].an_ssid,
		    ic->ic_des_essid, ic->ic_des_esslen);
	an_swap16((u_int16_t *)&sc->sc_buf.sc_ssidlist.an_entry[0].an_ssid, 16); 
	if ((error = an_write_rid(sc, AN_RID_SSIDLIST, &sc->sc_buf,
	    sizeof(sc->sc_buf.sc_ssidlist)))) {
		printf("%s: failed to write ssid list\n", ifp->if_xname);
		an_stop(ifp, 1);
		return error;
	}

	/* Set the AP list */
	memset(&sc->sc_buf, 0, sizeof(sc->sc_buf.sc_aplist));
	(void)an_write_rid(sc, AN_RID_APLIST, &sc->sc_buf,
	    sizeof(sc->sc_buf.sc_aplist));

	/* Set the encapsulation */
	for (i = 0; i < AN_ENCAP_NENTS; i++) {
		sc->sc_buf.sc_encap.an_entry[i].an_ethertype = 0;
		sc->sc_buf.sc_encap.an_entry[i].an_action =
		    AN_RXENCAP_RFC1024 | AN_TXENCAP_RFC1024;
	}
	(void)an_write_rid(sc, AN_RID_ENCAP, &sc->sc_buf,
	    sizeof(sc->sc_buf.sc_encap));

	/* Set the WEP Keys */
	if (ic->ic_flags & IEEE80211_F_WEPON)
		an_write_wepkey(sc, AN_RID_WEP_VOLATILE, sc->sc_wepkeys,
		    sc->sc_tx_key);

	/* Set the configuration */
	if ((error = an_write_rid(sc, AN_RID_GENCONFIG, &sc->sc_config,
	    sizeof(sc->sc_config)))) {
		printf("%s: failed to write config\n", ifp->if_xname);
		an_stop(ifp, 1);
		return error;
	}

	/* Enable the MAC */
	if (an_cmd(sc, AN_CMD_ENABLE, 0)) {
		printf("%s: failed to enable MAC\n", sc->sc_dev.dv_xname);
		an_stop(ifp, 1);
		return ENXIO;
	}
	if (ifp->if_flags & IFF_PROMISC)
		an_cmd(sc, AN_CMD_SET_MODE, 0xffff);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ic->ic_state = IEEE80211_S_INIT;
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

	/* enable interrupts */
	CSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);
	return 0;
}

void
an_start(struct ifnet *ifp)
{
	struct an_softc *sc = (struct an_softc *)ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct ieee80211_frame *wh;
	struct an_txframe frmhdr;
	struct mbuf *m;
	u_int16_t len;
	int cur, fid;

	if (!sc->sc_enabled || sc->sc_invalid) {
		DPRINTF(("an_start: noop: enabled %d invalid %d\n",
		    sc->sc_enabled, sc->sc_invalid));
		return;
	}

	memset(&frmhdr, 0, sizeof(frmhdr));
	cur = sc->sc_txnext;
	for (;;) {
		if (ic->ic_state != IEEE80211_S_RUN) {
			DPRINTF(("an_start: not running %d\n", ic->ic_state));
			break;
		}
		m = ifq_deq_begin(&ifp->if_snd);
		if (m == NULL) {
			DPRINTF2(("an_start: no pending mbuf\n"));
			break;
		}
		if (sc->sc_txd[cur].d_inuse) {
			ifq_deq_rollback(&ifp->if_snd, m);
			DPRINTF2(("an_start: %x/%d busy\n",
			    sc->sc_txd[cur].d_fid, cur));
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
		ifq_deq_commit(&ifp->if_snd, m);
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		if ((m = ieee80211_encap(ifp, m, &ni)) == NULL) {
			ifp->if_oerrors++;
			continue;
		}
		if (ni != NULL)
			ieee80211_release_node(ic, ni);
#if NBPFILTER > 0
		if (ic->ic_rawbpf)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif

		wh = mtod(m, struct ieee80211_frame *);
		if (ic->ic_flags & IEEE80211_F_WEPON)
			wh->i_fc[1] |= IEEE80211_FC1_WEP;
		m_copydata(m, 0, sizeof(struct ieee80211_frame),
		    (caddr_t)&frmhdr.an_whdr);
		an_swap16((u_int16_t *)&frmhdr.an_whdr, sizeof(struct ieee80211_frame)/2);

		/* insert payload length in front of llc/snap */
		len = htons(m->m_pkthdr.len - sizeof(struct ieee80211_frame));
		m_adj(m, sizeof(struct ieee80211_frame) - sizeof(len));
		if (mtod(m, u_long) & 0x01)
			memcpy(mtod(m, caddr_t), &len, sizeof(len));
		else
			*mtod(m, u_int16_t *) = len;

		/*
		 * XXX Aironet firmware apparently convert the packet
		 * with longer than 1500 bytes in length into LLC/SNAP.
		 * If we have 1500 bytes in ethernet payload, it is
		 * 1508 bytes including LLC/SNAP and will be inserted
		 * additional LLC/SNAP header with 1501-1508 in its
		 * ethertype !!
		 * So we skip LLC/SNAP header and force firmware to
		 * convert it to LLC/SNAP again.
		 */
		m_adj(m, sizeof(struct llc));

		frmhdr.an_tx_ctl = AN_TXCTL_80211;
		frmhdr.an_tx_payload_len = m->m_pkthdr.len;
		frmhdr.an_gaplen = AN_TXGAP_802_11;

		if (ic->ic_fixed_rate != -1)
			frmhdr.an_tx_rate =
			    ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[
			    ic->ic_fixed_rate] & IEEE80211_RATE_VAL;
		else
			frmhdr.an_tx_rate = 0;

		if (sizeof(frmhdr) + AN_TXGAP_802_11 + sizeof(len) +
		    m->m_pkthdr.len > AN_TX_MAX_LEN) {
			ifp->if_oerrors++;
			m_freem(m);
			continue;
		}

#if NBPFILTER > 0
		if (sc->sc_drvbpf) {
			struct mbuf mb;
			struct an_tx_radiotap_header *tap = &sc->sc_txtap;

			tap->at_rate = 
			    ic->ic_bss->ni_rates.rs_rates[ic->ic_bss->ni_txrate];
			tap->at_chan_freq =
			    ic->ic_bss->ni_chan->ic_freq;
			tap->at_chan_flags =
			    ic->ic_bss->ni_chan->ic_flags;

			mb.m_data = (caddr_t)tap;
			mb.m_len = sizeof(sc->sc_txtapu);
			mb.m_next = m;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_drvbpf, m, BPF_DIRECTION_OUT);
		}
#endif

		fid = sc->sc_txd[cur].d_fid;
		if (an_write_bap(sc, fid, 0, &frmhdr, sizeof(frmhdr)) != 0) {
			ifp->if_oerrors++;
			m_freem(m);
			continue;
		}
		/* dummy write to avoid seek. */
		an_write_bap(sc, fid, -1, &frmhdr, AN_TXGAP_802_11);
		an_mwrite_bap(sc, fid, -1, m, m->m_pkthdr.len);
		m_freem(m);

		DPRINTF2(("an_start: send %d byte via %x/%d\n",
		    ntohs(len) + sizeof(struct ieee80211_frame),
		    fid, cur));
		sc->sc_txd[cur].d_inuse = 1;
		if (an_cmd(sc, AN_CMD_TX, fid)) {
			printf("%s: xmit failed\n", ifp->if_xname);
			sc->sc_txd[cur].d_inuse = 0;
			continue;
		}
		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
		AN_INC(cur, AN_TX_RING_CNT);
		sc->sc_txnext = cur;
	}
}

void
an_stop(struct ifnet *ifp, int disable)
{
	struct an_softc *sc = ifp->if_softc;
	int i, s;

	if (!sc->sc_enabled)
		return;

	DPRINTF(("an_stop: disable %d\n", disable));

	s = splnet();
	ieee80211_new_state(&sc->sc_ic, IEEE80211_S_INIT, -1);
	if (!sc->sc_invalid) {
		an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);
		CSR_WRITE_2(sc, AN_INT_EN, 0);
		an_cmd(sc, AN_CMD_DISABLE, 0);

		for (i = 0; i < AN_TX_RING_CNT; i++)
			an_cmd(sc, AN_CMD_DEALLOC_MEM, sc->sc_txd[i].d_fid);
	}

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (disable) {
		if (sc->sc_disable)
			(*sc->sc_disable)(sc);
		sc->sc_enabled = 0;
	}
	splx(s);
}

void
an_watchdog(struct ifnet *ifp)
{
	struct an_softc *sc = ifp->if_softc;

	if (!sc->sc_enabled)
		return;

	if (sc->sc_tx_timer) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", ifp->if_xname);
			ifp->if_oerrors++;
			an_init(ifp);
			return;
		}
		ifp->if_timer = 1;
	}
	ieee80211_watchdog(ifp);
}

/* TBD factor with ieee80211_media_change */
int
an_media_change(struct ifnet *ifp)
{
	struct an_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifmedia_entry *ime;
	enum ieee80211_opmode newmode;
	int i, rate, error = 0;

	ime = ic->ic_media.ifm_cur;
	if (IFM_SUBTYPE(ime->ifm_media) == IFM_AUTO) {
		i = -1;
	} else {
		struct ieee80211_rateset *rs =
		    &ic->ic_sup_rates[IEEE80211_MODE_11B];
		rate = ieee80211_media2rate(ime->ifm_media);
		if (rate == 0)
			return EINVAL;
		for (i = 0; i < rs->rs_nrates; i++) {
			if ((rs->rs_rates[i] & IEEE80211_RATE_VAL) == rate)
				break;
		}
		if (i == rs->rs_nrates)
			return EINVAL;
	}
	if (ic->ic_fixed_rate != i) {
		ic->ic_fixed_rate = i;
		error = ENETRESET;
	}

#ifndef IEEE80211_STA_ONLY
	if (ime->ifm_media & IFM_IEEE80211_ADHOC)
		newmode = IEEE80211_M_IBSS;
	else if (ime->ifm_media & IFM_IEEE80211_HOSTAP)
		newmode = IEEE80211_M_HOSTAP;
	else
#endif
	if (ime->ifm_media & IFM_IEEE80211_MONITOR)
		newmode = IEEE80211_M_MONITOR;
	else
		newmode = IEEE80211_M_STA;
	if (ic->ic_opmode != newmode) {
		ic->ic_opmode = newmode;
		error = ENETRESET;
	}
	if (error == ENETRESET) {
		if (sc->sc_enabled)
			error = an_init(ifp);
		else
			error = 0;
	}
	ifp->if_baudrate = ifmedia_baudrate(ic->ic_media.ifm_cur->ifm_media);

	return error;
}

void
an_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct an_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int rate, buflen;

	if (sc->sc_enabled == 0) {
		imr->ifm_active = IFM_IEEE80211 | IFM_NONE;
		imr->ifm_status = 0;
		return;
	}

	imr->ifm_status = IFM_AVALID;
	imr->ifm_active = IFM_IEEE80211;
	if (ic->ic_state == IEEE80211_S_RUN)
		imr->ifm_status |= IFM_ACTIVE;
	buflen = sizeof(sc->sc_buf);
	if (ic->ic_fixed_rate != -1)
		rate = ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[
		    ic->ic_fixed_rate] & IEEE80211_RATE_VAL;
	else if (an_read_rid(sc, AN_RID_STATUS, &sc->sc_buf, &buflen) != 0)
		rate = 0;
	else
		rate = sc->sc_buf.sc_status.an_current_tx_rate;
	imr->ifm_active |= ieee80211_rate2media(ic, rate, IEEE80211_MODE_11B);
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		imr->ifm_active |= IFM_IEEE80211_ADHOC;
		break;
	case IEEE80211_M_HOSTAP:
		imr->ifm_active |= IFM_IEEE80211_HOSTAP;
		break;
#endif
	case IEEE80211_M_MONITOR:
		imr->ifm_active |= IFM_IEEE80211_MONITOR;
		break;
	default:
		break;
	}
}

int
an_set_nwkey(struct an_softc *sc, struct ieee80211_nwkey *nwkey)
{
	int error;
	struct ieee80211com *ic = &sc->sc_ic;
	u_int16_t prevauth;

	error = 0;
	prevauth = sc->sc_config.an_authtype;

	switch (nwkey->i_wepon) {
	case IEEE80211_NWKEY_OPEN:
		sc->sc_config.an_authtype = AN_AUTHTYPE_OPEN;
		ic->ic_flags &= ~IEEE80211_F_WEPON;
		break;

	case IEEE80211_NWKEY_WEP:
	case IEEE80211_NWKEY_WEP | IEEE80211_NWKEY_PERSIST:
		error = an_set_nwkey_wep(sc, nwkey);
		if (error == 0 || error == ENETRESET) {
			sc->sc_config.an_authtype =
			    AN_AUTHTYPE_OPEN | AN_AUTHTYPE_PRIVACY_IN_USE;
			ic->ic_flags |= IEEE80211_F_WEPON;
		}
		break;

	default:
		error = EINVAL;
		break;
	}
	if (error == 0 && prevauth != sc->sc_config.an_authtype)
		error = ENETRESET;
	return error;
}

int
an_set_nwkey_wep(struct an_softc *sc, struct ieee80211_nwkey *nwkey)
{
	int i, txkey, anysetkey, needreset, error;
	struct an_wepkey keys[IEEE80211_WEP_NKID];

	error = 0;
	memset(keys, 0, sizeof(keys));
	anysetkey = needreset = 0;

	/* load argument and sanity check */
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		keys[i].an_wep_keylen = nwkey->i_key[i].i_keylen;
		if (keys[i].an_wep_keylen < 0)
			continue;
		if (keys[i].an_wep_keylen != 0 &&
		    keys[i].an_wep_keylen < IEEE80211_WEP_KEYLEN)
			return EINVAL;
		if (keys[i].an_wep_keylen > sizeof(keys[i].an_wep_key))
			return EINVAL;
		if ((error = copyin(nwkey->i_key[i].i_keydat,
		    keys[i].an_wep_key, keys[i].an_wep_keylen)) != 0)
			return error;
		anysetkey++;
	}
	txkey = nwkey->i_defkid - 1;
	if (txkey >= 0) {
		if (txkey >= IEEE80211_WEP_NKID)
			return EINVAL;
		/* default key must have a valid value */
		if (keys[txkey].an_wep_keylen == 0 ||
		    (keys[txkey].an_wep_keylen < 0 &&
		    sc->sc_perskeylen[txkey] == 0))
			return EINVAL;
		anysetkey++;
	}
	DPRINTF(("an_set_nwkey_wep: %s: %sold(%d:%d,%d,%d,%d) "
	    "pers(%d:%d,%d,%d,%d) new(%d:%d,%d,%d,%d)\n",
	    sc->sc_dev.dv_xname,
	    ((nwkey->i_wepon & IEEE80211_NWKEY_PERSIST) ? "persist: " : ""),
	    sc->sc_tx_key,
	    sc->sc_wepkeys[0].an_wep_keylen, sc->sc_wepkeys[1].an_wep_keylen,
	    sc->sc_wepkeys[2].an_wep_keylen, sc->sc_wepkeys[3].an_wep_keylen,
	    sc->sc_tx_perskey,
	    sc->sc_perskeylen[0], sc->sc_perskeylen[1],
	    sc->sc_perskeylen[2], sc->sc_perskeylen[3],
	    txkey,
	    keys[0].an_wep_keylen, keys[1].an_wep_keylen,
	    keys[2].an_wep_keylen, keys[3].an_wep_keylen));
	if (!(nwkey->i_wepon & IEEE80211_NWKEY_PERSIST)) {
		/* set temporary keys */
		sc->sc_tx_key = txkey;
		for (i = 0; i < IEEE80211_WEP_NKID; i++) {
			if (keys[i].an_wep_keylen < 0)
				continue;
			memcpy(&sc->sc_wepkeys[i], &keys[i], sizeof(keys[i]));
		}
	} else {
		/* set persist keys */
		if (anysetkey) {
			/* prepare to write nvram */
			if (!sc->sc_enabled) {
				if (sc->sc_enable)
					(*sc->sc_enable)(sc);
				an_wait(sc);
				sc->sc_enabled = 1;
				error = an_write_wepkey(sc,
				    AN_RID_WEP_PERSISTENT, keys, txkey);
				if (sc->sc_disable)
					(*sc->sc_disable)(sc);
				sc->sc_enabled = 0;
			} else {
				an_cmd(sc, AN_CMD_DISABLE, 0);
				error = an_write_wepkey(sc,
				    AN_RID_WEP_PERSISTENT, keys, txkey);
				an_cmd(sc, AN_CMD_ENABLE, 0);
			}
			if (error)
				return error;
		}
		if (txkey >= 0)
			sc->sc_tx_perskey = txkey;
		if (sc->sc_tx_key >= 0) {
			sc->sc_tx_key = -1;
			needreset++;
		}
		for (i = 0; i < IEEE80211_WEP_NKID; i++) {
			if (sc->sc_wepkeys[i].an_wep_keylen >= 0) {
				memset(&sc->sc_wepkeys[i].an_wep_key, 0,
				    sizeof(sc->sc_wepkeys[i].an_wep_key));
				sc->sc_wepkeys[i].an_wep_keylen = -1;
				needreset++;
			}
			if (keys[i].an_wep_keylen >= 0)
				sc->sc_perskeylen[i] = keys[i].an_wep_keylen;
		}
	}
	if (needreset) {
		/* firmware restart to reload persistent key */
		an_reset(sc);
	}
	if (anysetkey || needreset)
		error = ENETRESET;
	return error;
}

int
an_get_nwkey(struct an_softc *sc, struct ieee80211_nwkey *nwkey)
{
	int i, error;

	error = 0;
	if (sc->sc_config.an_authtype & AN_AUTHTYPE_LEAP)
		nwkey->i_wepon = IEEE80211_NWKEY_EAP;
	else if (sc->sc_config.an_authtype & AN_AUTHTYPE_PRIVACY_IN_USE)
		nwkey->i_wepon = IEEE80211_NWKEY_WEP;
	else
		nwkey->i_wepon = IEEE80211_NWKEY_OPEN;
	if (sc->sc_tx_key == -1)
		nwkey->i_defkid = sc->sc_tx_perskey + 1;
	else
		nwkey->i_defkid = sc->sc_tx_key + 1;
	if (nwkey->i_key[0].i_keydat == NULL)
		return 0;
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (nwkey->i_key[i].i_keydat == NULL)
			continue;
		/* do not show any keys to non-root user */
		if ((error = suser(curproc, 0)) != 0)
			break;
		nwkey->i_key[i].i_keylen = sc->sc_wepkeys[i].an_wep_keylen;
		if (nwkey->i_key[i].i_keylen < 0) {
			if (sc->sc_perskeylen[i] == 0)
				nwkey->i_key[i].i_keylen = 0;
			continue;
		}
		if ((error = copyout(sc->sc_wepkeys[i].an_wep_key,
		    nwkey->i_key[i].i_keydat,
		    sc->sc_wepkeys[i].an_wep_keylen)) != 0)
			break;
	}
	return error;
}

int
an_write_wepkey(struct an_softc *sc, int type, struct an_wepkey *keys, int kid)
{
	int i, error;
	struct an_rid_wepkey *akey;

	error = 0;
	akey = &sc->sc_buf.sc_wepkey;
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		memset(akey, 0, sizeof(struct an_rid_wepkey));
		if (keys[i].an_wep_keylen < 0 ||
		    keys[i].an_wep_keylen > sizeof(akey->an_key))
			continue;
		akey->an_key_len = keys[i].an_wep_keylen;
		akey->an_key_index = i;
		akey->an_mac_addr[0] = 1;	/* default mac */
		an_swap16((u_int16_t *)&akey->an_mac_addr, 3); 
		memcpy(akey->an_key, keys[i].an_wep_key, keys[i].an_wep_keylen);
		an_swap16((u_int16_t *)&akey->an_key, 8); 
		if ((error = an_write_rid(sc, type, akey, sizeof(*akey))) != 0)
			return error;
	}
	if (kid >= 0) {
		memset(akey, 0, sizeof(struct an_rid_wepkey));
		akey->an_key_index = 0xffff;
		akey->an_mac_addr[0] = kid;
		an_swap16((u_int16_t *)&akey->an_mac_addr, 3); 
		akey->an_key_len = 0;
		memset(akey->an_key, 0, sizeof(akey->an_key));
		error = an_write_rid(sc, type, akey, sizeof(*akey));
	}
	return error;
}

int
an_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct an_softc *sc = ic->ic_softc;
	struct ieee80211_node *ni = ic->ic_bss;
	enum ieee80211_state ostate;
	int buflen;

	ostate = ic->ic_state;
	DPRINTF(("an_newstate: %s -> %s\n", ieee80211_state_name[ostate],
	    ieee80211_state_name[nstate]));

	switch (nstate) {
	case IEEE80211_S_INIT:
		ic->ic_flags &= ~IEEE80211_F_IBSSON;
		return (*sc->sc_newstate)(ic, nstate, arg);

	case IEEE80211_S_RUN:
		buflen = sizeof(sc->sc_buf);
		an_read_rid(sc, AN_RID_STATUS, &sc->sc_buf, &buflen);
		an_swap16((u_int16_t *)&sc->sc_buf.sc_status.an_cur_bssid, 3); 
		an_swap16((u_int16_t *)&sc->sc_buf.sc_status.an_ssid, 16); 
		IEEE80211_ADDR_COPY(ni->ni_bssid,
		    sc->sc_buf.sc_status.an_cur_bssid);
		IEEE80211_ADDR_COPY(ni->ni_macaddr, ni->ni_bssid);
		ni->ni_chan = &ic->ic_channels[
		    sc->sc_buf.sc_status.an_cur_channel];
		ni->ni_esslen = sc->sc_buf.sc_status.an_ssidlen;
		if (ni->ni_esslen > IEEE80211_NWID_LEN)
			ni->ni_esslen = IEEE80211_NWID_LEN;	/*XXX*/
		memcpy(ni->ni_essid, sc->sc_buf.sc_status.an_ssid,
		    ni->ni_esslen);
		ni->ni_rates = ic->ic_sup_rates[IEEE80211_MODE_11B];	/*XXX*/
		if (ic->ic_if.if_flags & IFF_DEBUG) {
			printf("%s: ", sc->sc_dev.dv_xname);
			if (ic->ic_opmode == IEEE80211_M_STA)
				printf("associated ");
			else
				printf("synchronized ");
			printf("with %s ssid ", ether_sprintf(ni->ni_bssid));
			ieee80211_print_essid(ni->ni_essid, ni->ni_esslen);
			printf(" channel %u start %uMb\n",
			    sc->sc_buf.sc_status.an_cur_channel,
			    sc->sc_buf.sc_status.an_current_tx_rate/2);
		}
		break;

	default:
		break;
	}
	ic->ic_state = nstate;
	/* skip standard ieee80211 handling */
	return 0;
}

int
an_detach(struct an_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	if (!sc->sc_attached)
		return 0;

	s = splnet();
	sc->sc_invalid = 1;
	an_stop(ifp, 1);
	ifmedia_delete_instance(&sc->sc_ic.ic_media, IFM_INST_ANY);
	ieee80211_ifdetach(ifp);
	if_detach(ifp);
	splx(s);
	return 0;
}

@


1.71
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.70 2015/11/25 03:09:58 dlg Exp $	*/
a496 2
	else
		ifp->if_opackets++;
a1107 1
		ifp->if_opackets++;
@


1.70
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.69 2015/11/24 17:11:39 mpi Exp $	*/
a268 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.69
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.68 2015/11/24 13:33:17 mpi Exp $	*/
d491 1
a491 1
	ifp->if_flags &= ~IFF_OACTIVE;
d566 1
a566 1
		if ((ifp->if_flags & IFF_OACTIVE) == 0 &&
d1063 1
a1063 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1107 1
a1107 1
			ifp->if_flags |= IFF_OACTIVE;
d1245 2
a1246 1
	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);
@


1.68
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.67 2015/11/20 03:35:22 dlg Exp $	*/
a96 1
#include <net/if_dl.h>
@


1.67
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.66 2015/10/25 12:48:46 mpi Exp $	*/
a99 1
#include <net/if_types.h>
@


1.66
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.65 2015/06/21 21:22:27 krw Exp $	*/
d1100 1
a1100 1
		IFQ_POLL(&ifp->if_snd, m);
d1106 1
d1112 1
a1112 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.65
log
@Don't use uninitialized data as a return value.

From Brainy via Maxime Villard via tech@@.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.64 2015/02/10 23:25:46 mpi Exp $	*/
a876 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d887 1
a887 9
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			error = an_init(ifp);
			arp_ifinit(&sc->sc_ic.ic_ac, ifa);
			break;
		default:
			error = an_init(ifp);
			break;
		}
@


1.64
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.63 2014/12/22 02:28:51 tedu Exp $	*/
d1030 2
a1031 2
	if (an_write_rid(sc, AN_RID_SSIDLIST, &sc->sc_buf,
	    sizeof(sc->sc_buf.sc_ssidlist)) != 0) {
d1057 2
a1058 2
	if (an_write_rid(sc, AN_RID_GENCONFIG, &sc->sc_config,
	    sizeof(sc->sc_config)) != 0) {
@


1.63
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.62 2014/09/14 14:17:24 jsg Exp $	*/
a443 1
	m->m_pkthdr.rcvif = ifp;
@


1.62
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.61 2014/07/22 13:12:11 mpi Exp $	*/
a101 1
#ifdef INET
a103 1
#endif
a889 1
#ifdef INET
a893 1
#endif
@


1.61
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.60 2013/08/07 01:06:27 bluhm Exp $	*/
a90 1
#include <sys/proc.h>
@


1.60
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.59 2012/12/05 23:20:16 deraadt Exp $	*/
a104 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.59
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.58 2010/08/27 17:08:00 jsg Exp $	*/
a105 1
#include <netinet/in_var.h>
@


1.58
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.57 2009/08/10 20:29:54 deraadt Exp $	*/
a78 2

#include <sys/cdefs.h>
@


1.57
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.56 2008/08/27 09:05:03 damien Exp $	*/
a277 1
	ifp->if_init = an_init;
@


1.56
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.55 2008/07/21 18:43:19 damien Exp $	*/
a348 2
	sc->sc_sdhook = shutdownhook_establish(an_shutdown, sc);

a1296 9
void
an_shutdown(void *self)
{
	struct an_softc *sc = (struct an_softc *)self;

	if (sc->sc_attached)
		an_stop(&sc->sc_ic.ic_if, 1);
}

a1681 2
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
@


1.55
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.54 2007/09/30 11:33:14 kettenis Exp $	*/
d284 4
a287 2
	ic->ic_caps = IEEE80211_C_WEP | IEEE80211_C_PMGT | IEEE80211_C_IBSS |
	    IEEE80211_C_MONITOR;
d680 5
a684 2
		if (ic->ic_state != IEEE80211_S_RUN ||
		    ic->ic_opmode == IEEE80211_M_IBSS)
d1012 1
d1017 1
d1339 1
d1344 3
a1346 1
	else if (ime->ifm_media & IFM_IEEE80211_MONITOR)
d1394 1
d1401 1
@


1.54
log
@s/NPBFILTER/NBPFILTER/ in #endif comment. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.53 2007/01/03 18:16:43 claudio Exp $	*/
d360 1
d478 1
d485 2
d490 3
a492 2
	ieee80211_input(ifp, m, ni, frmhdr.an_rx_signal_strength,
	    an_switch32(frmhdr.an_rx_time));
@


1.53
log
@M_DUP_PKTHDR() cleanup. On static buffers M_DUP_PKTHDR() will leak mbuf tags.
See similar rum(4) commit for more info. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.52 2006/06/25 18:50:51 mickey Exp $	*/
d474 1
a474 1
#endif /* NPBFILTER > 0 */
@


1.52
log
@put the 1.32 change back; tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.51 2006/05/22 20:35:12 krw Exp $	*/
a465 1
		M_DUP_PKTHDR(&mb, m);
d469 3
a471 1
		mb.m_pkthdr.len += mb.m_len;
a1195 1
			M_DUP_PKTHDR(&mb, m);
d1199 3
a1201 1
			mb.m_pkthdr.len += mb.m_len;
@


1.51
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.50 2006/04/05 14:28:20 kurt Exp $	*/
d149 1
a149 1
int	an_read_bap(struct an_softc *, int, int, void *, int);
d370 1
a370 1
	if (an_read_bap(sc, fid, 0, &frmhdr, sizeof(frmhdr)) != 0) {
d440 2
a441 1
		an_read_bap(sc, fid, -1, gap, gaplen + sizeof(u_int16_t));
d446 1
a446 1
	    m->m_data + sizeof(struct ieee80211_frame) + gaplen, len);
d699 1
a699 1
an_read_bap(struct an_softc *sc, int id, int off, void *buf, int buflen)
d701 1
a701 1
	int error, cnt;
d703 1
a703 1
	if (buflen == 0)
d712 1
a712 1
	cnt = (buflen + 1) / 2;
d714 2
d847 1
a847 1
	error = an_read_bap(sc, rid, 0, &len, sizeof(len));
d852 1
a852 8
	if (*buflenp < len) {
		printf("%s: record buffer is too small, "
		    "rid=%x, size=%d, len=%d\n",
		    sc->sc_dev.dv_xname, rid, *buflenp, len);
		return ENOSPC;
	}
	*buflenp = len;
	return an_read_bap(sc, rid, sizeof(len), buf, len);
@


1.50
log
@Add support for big endian archs. tested by jaredy@@ and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.49 2006/03/25 22:41:42 djm Exp $	*/
d1678 2
a1679 1
	shutdownhook_disestablish(sc->sc_sdhook);
@


1.49
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.48 2006/03/04 04:43:28 brad Exp $	*/
d144 1
a144 1
void	an_txeof(struct an_softc *, int);
d169 1
d176 5
d218 2
d227 3
d235 3
a237 1
		kid = letoh16(akey->an_key_index);
d241 1
a241 1
		    akey->an_mac_addr[0], letoh16(akey->an_key_len)));
d249 1
a249 1
		sc->sc_perskeylen[kid] = letoh16(akey->an_key_len);
d259 2
a260 2
	    htole16(sc->sc_caps.an_fwrev) >> 8,
	    htole16(sc->sc_caps.an_fwrev) & 0xff,
d289 1
a289 1
	switch (letoh16(sc->sc_caps.an_regdomain)) {
d376 1
d378 1
a378 1
	status = letoh16(frmhdr.an_rx_status);
d388 1
a388 1
	len = letoh16(frmhdr.an_rx_payload_len) - sizeof(uint16_t);
d421 1
a421 1
		gaplen = letoh16(frmhdr.an_gaplen);
d446 1
d461 2
a462 2
		tap->ar_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->ar_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
d485 1
a485 1
	    letoh32(frmhdr.an_rx_time));
d490 1
a490 1
an_txeof(struct an_softc *sc, int status)
a714 24
#if BYTE_ORDER == BIG_ENDIAN
	switch(id) {
	case AN_RID_GENCONFIG:
	case AN_RID_ACTUALCFG:
		break;
	case AN_RID_SSIDLIST:
		break;
	case AN_RID_APLIST:
		break;
	case AN_RID_DRVNAME:
		break;
	case AN_RID_CAPABILITIES:
		break;
	case AN_RID_STATUS:
		break;
	case AN_RID_WEP_VOLATILE:
	case AN_RID_WEP_PERMANENT:
		break;
	case AN_RID_32BITS_CUM:
		break;
	
	}
#endif

d789 1
d796 1
d848 1
a848 1
	len = letoh16(len) - 2;
d866 1
a866 1
	len = htole16(buflen + 2);
d983 3
a985 2
	sc->sc_config.an_scanmode = htole16(AN_SCANMODE_ACTIVE);
	sc->sc_config.an_authtype = htole16(AN_AUTHTYPE_OPEN);	/*XXX*/
d988 1
a988 1
		    htole16(AN_AUTHTYPE_PRIVACY_IN_USE);
d990 2
a991 2
	sc->sc_config.an_listen_interval = htole16(ic->ic_lintval);
	sc->sc_config.an_beacon_period = htole16(ic->ic_lintval);
d993 1
a993 1
		sc->sc_config.an_psave_mode = htole16(AN_PSAVE_PSP);
d995 1
a995 1
		sc->sc_config.an_psave_mode = htole16(AN_PSAVE_CAM);
d997 1
a997 1
	    htole16(ieee80211_chan2ieee(ic, ic->ic_ibss_chan));
d1002 2
a1003 2
		    htole16(AN_OPMODE_INFRASTRUCTURE_STATION);
		sc->sc_config.an_rxmode = htole16(AN_RXMODE_BC_MC_ADDR);
d1006 2
a1007 2
		sc->sc_config.an_opmode = htole16(AN_OPMODE_IBSS_ADHOC);
		sc->sc_config.an_rxmode = htole16(AN_RXMODE_BC_MC_ADDR);
d1011 1
a1011 1
		    htole16(AN_OPMODE_INFRASTRUCTURE_STATION);
d1013 2
a1014 2
		    htole16(AN_RXMODE_80211_MONITOR_ANYBSS);
		sc->sc_config.an_authtype = htole16(AN_AUTHTYPE_NONE);
d1017 2
a1018 2
			    htole16(AN_AUTHTYPE_PRIVACY_IN_USE |
		            AN_AUTHTYPE_ALLOW_UNENCRYPTED);
d1025 1
a1025 1
	sc->sc_config.an_rxmode |= htole16(AN_RXMODE_NO_8023_HEADER);
d1030 1
a1030 1
	    htole16(ic->ic_des_esslen);
d1034 1
d1049 1
a1049 1
		sc->sc_buf.sc_encap.an_entry[i].an_ethertype = htole16(0);
d1051 1
a1051 1
		    htole16(AN_RXENCAP_RFC1024 | AN_TXENCAP_RFC1024);
d1147 1
d1169 3
a1171 3
		frmhdr.an_tx_ctl = htole16(AN_TXCTL_80211);
		frmhdr.an_tx_payload_len = htole16(m->m_pkthdr.len);
		frmhdr.an_gaplen = htole16(AN_TXGAP_802_11);
d1195 1
a1195 1
			    htole16(ic->ic_bss->ni_chan->ic_freq);
d1197 1
a1197 1
			    htole16(ic->ic_bss->ni_chan->ic_flags);
d1376 1
a1376 1
		rate = letoh16(sc->sc_buf.sc_status.an_current_tx_rate);
a1581 1
	memset(akey, 0, sizeof(struct an_rid_wepkey));
d1583 1
d1587 2
a1588 2
		akey->an_key_len = htole16(keys[i].an_wep_keylen);
		akey->an_key_index = htole16(i);
d1590 1
d1592 1
d1597 2
a1598 1
		akey->an_key_index = htole16(0xffff);
d1600 2
a1601 1
		akey->an_key_len = htole16(0);
d1628 2
d1634 2
a1635 2
		    letoh16(sc->sc_buf.sc_status.an_cur_channel)];
		ni->ni_esslen = letoh16(sc->sc_buf.sc_status.an_ssidlen);
d1650 2
a1651 2
			    letoh16(sc->sc_buf.sc_status.an_cur_channel),
			    letoh16(sc->sc_buf.sc_status.an_current_tx_rate)/2);
@


1.48
log
@remove the colon between "address" and the MAC address.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.47 2006/02/20 11:13:57 jsg Exp $	*/
d455 1
a455 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d1134 1
a1134 1
			bpf_mtap(ifp->if_bpf, m);
d1144 1
a1144 1
			bpf_mtap(ic->ic_rawbpf, m);
d1208 1
a1208 1
			bpf_mtap(sc->sc_drvbpf, m);
@


1.47
log
@Be sure to call shutdownhook_disestablish() as this is a removeable device.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.46 2006/01/30 11:41:00 jsg Exp $	*/
d259 1
a259 1
	printf(", address: %s\n", ether_sprintf(ic->ic_myaddr));
@


1.46
log
@Add basic radiotap support.  Modelled somewhat after
ral and NetBSD wi radiotap.
"looks ok" damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.45 2006/01/09 21:19:47 jsg Exp $	*/
d334 1
a334 1
	shutdownhook_establish(an_shutdown, sc);
d1676 1
@


1.45
log
@Move an(4) to a driver based on the NetBSD one.
This brings net80211 support and support for newer hardware.
In addition ancontrol is no longer needed.

This driver does not yet work on big endian archs like the previous
one did.

"do it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
d321 13
d439 20
d1190 21
@


1.44
log
@splimp -> splnet
@
text
@d1 2
a2 2
/*	$OpenBSD: an.c,v 1.43 2005/10/25 15:49:37 jmc Exp $	*/

d34 31
a64 1
 * $FreeBSD: src/sys/dev/an/if_an.c,v 1.21 2001/09/10 02:05:09 brooks Exp $
d76 2
a77 38
 * The Aironet 4500/4800 series cards come in PCMCIA, ISA and PCI form.
 * This driver supports all three device types (PCI devices are supported
 * through an extra PCI shim: /sys/pci/if_an_p.c). ISA devices can be
 * supported either using hard-coded IO port/IRQ settings or via Plug
 * and Play. The 4500 series devices support 1Mbps and 2Mbps data rates.
 * The 4800 devices support 1, 2, 5.5 and 11Mbps rates.
 *
 * Like the WaveLAN/IEEE cards, the Aironet NICs are all essentially
 * PCMCIA devices. The ISA and PCI cards are a combination of a PCMCIA
 * device and a PCMCIA to ISA or PCMCIA to PCI adapter card. There are
 * a couple of important differences though:
 *
 * - Lucent ISA card looks to the host like a PCMCIA controller with
 *   a PCMCIA WaveLAN card inserted. This means that even desktop
 *   machines need to be configured with PCMCIA support in order to
 *   use WaveLAN/IEEE ISA cards. The Aironet cards on the other hand
 *   actually look like normal ISA and PCI devices to the host, so
 *   no PCMCIA controller support is needed
 *
 * The latter point results in a small gotcha. The Aironet PCMCIA
 * cards can be configured for one of two operating modes depending
 * on how the Vpp1 and Vpp2 programming voltages are set when the
 * card is activated. In order to put the card in proper PCMCIA
 * operation (where the CIS table is visible and the interface is
 * programmed for PCMCIA operation), both Vpp1 and Vpp2 have to be
 * set to 5 volts. FreeBSD by default doesn't set the Vpp voltages,
 * which leaves the card in ISA/PCI mode, which prevents it from
 * being activated as an PCMCIA device.
 *
 * Note that some PCMCIA controller software packages for Windows NT
 * fail to set the voltages as well.
 *
 * The Aironet devices can operate in both station mode and access point
 * mode. Typically, when programmed for station mode, the card can be set
 * to automatically perform encapsulation/decapsulation of Ethernet II
 * and 802.3 frames within 802.11 frames so that the host doesn't have
 * to do it itself. This driver doesn't program the card that way: the
 * driver handles all of the encapsulation/decapsulation itself.
d80 3
a82 3
#ifdef INET
#define ANCACHE			/* enable signal strength cache */
#endif
a85 1
#include <sys/device.h>
a87 1
#include <sys/malloc.h>
d89 1
a89 1
#include <sys/proc.h>
d92 6
a97 4
#ifdef ANCACHE
#include <sys/syslog.h>
#include <sys/sysctl.h>
#endif
d101 1
a114 1
#include "bpfilter.h"
d119 1
a119 2
#include <machine/bus.h>

a120 6
#include <dev/ic/anreg.h>

#define TIMEOUT(handle,func,sc,time) timeout_add(&(handle), (time))
#define UNTIMEOUT(func,sc,handle) timeout_del(&(handle))
#define BPF_MTAP(if,mbuf) bpf_mtap((if)->if_bpf, (mbuf))
#define BPFATTACH(if_bpf,if,dlt,sz)
d126 40
a165 23
void an_reset(struct an_softc *);
int an_ioctl(struct ifnet *, u_long, caddr_t);
int an_init_tx_ring(struct an_softc *);
void an_start(struct ifnet *);
void an_watchdog(struct ifnet *);
void an_rxeof(struct an_softc *);
void an_txeof(struct an_softc *, int);

void an_promisc(struct an_softc *, int);
int an_cmd(struct an_softc *, int, int);
int an_read_record(struct an_softc *, struct an_ltv_gen *);
int an_write_record(struct an_softc *, struct an_ltv_gen *);
int an_read_data(struct an_softc *, int,
					int, caddr_t, int);
int an_write_data(struct an_softc *, int,
					int, caddr_t, int);
int an_seek(struct an_softc *, int, int, int);
int an_alloc_nicmem(struct an_softc *, int, int *);
void an_stats_update(void *);
void an_setdef(struct an_softc *, struct an_req *);
#ifdef ANCACHE
void an_cache_store(struct an_softc *, struct ether_header *,
					struct mbuf *, unsigned short);
a166 2
int an_media_change(struct ifnet *);
void an_media_status(struct ifnet *, struct ifmediareq *);
d171 2
a172 2
	for (; cnt--; p++)
		*p = swap16(*p);
d176 1
a176 2
an_attach(sc)
	struct an_softc *sc;
d180 4
d185 1
a185 2
	sc->an_gone = 0;
	sc->an_associated = 0;
d191 5
a195 2
	/* Reset the NIC. */
	an_reset(sc);
d198 4
a201 3
	if (an_cmd(sc, AN_CMD_READCFG, 0)) {
		printf("%s: failed to load config data\n", ifp->if_xname);
		return(EIO);
d205 3
a207 4
	sc->an_config.an_type = AN_RID_GENCONFIG;
	sc->an_config.an_len = sizeof(struct an_ltv_genconfig);
	if (an_read_record(sc, (struct an_ltv_gen *)&sc->an_config)) {
		printf("%s: read record failed\n", ifp->if_xname);
d212 3
a214 4
	sc->an_caps.an_type = AN_RID_CAPABILITIES;
	sc->an_caps.an_len = sizeof(struct an_ltv_caps);
	if (an_read_record(sc, (struct an_ltv_gen *)&sc->an_caps)) {
		printf("%s: read record failed\n", ifp->if_xname);
d218 21
a238 6
	/* Read ssid list */
	sc->an_ssidlist.an_type = AN_RID_SSIDLIST;
	sc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);
	if (an_read_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {
		printf("%s: read record failed\n", ifp->if_xname);
		return(EIO);
d241 2
a242 7
	/* Read AP list */
	sc->an_aplist.an_type = AN_RID_APLIST;
	sc->an_aplist.an_len = sizeof(struct an_ltv_aplist);
	if (an_read_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {
		printf("%s: read record failed\n", ifp->if_xname);
		return(EIO);
	}
d244 13
a256 2
	bcopy((char *)&sc->an_caps.an_oemaddr,
	   (char *)&sc->sc_ic.ic_ac.ac_enaddr, ETHER_ADDR_LEN);
d258 2
a259 3
	printf(": address %6s\n", ether_sprintf(sc->sc_ic.ic_ac.ac_enaddr));

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
d264 1
a265 1
	ifp->if_baudrate = 10000000;
d268 6
a273 16
	bzero(sc->an_config.an_nodename, sizeof(sc->an_config.an_nodename));
	strlcpy(sc->an_config.an_nodename, AN_DEFAULT_NODENAME,
	    sizeof(sc->an_config.an_nodename));

	bzero(sc->an_ssidlist.an_ssid1, sizeof(sc->an_ssidlist.an_ssid1));
	strlcpy(sc->an_ssidlist.an_ssid1, AN_DEFAULT_NETNAME,
	    sizeof(sc->an_ssidlist.an_ssid1));
	sc->an_ssidlist.an_ssid1_len = strlen(sc->an_ssidlist.an_ssid1);

	sc->an_config.an_opmode = AN_OPMODE_INFRASTRUCTURE_STATION;

	sc->an_tx_rate = 0;
	bzero((char *)&sc->an_stats, sizeof(sc->an_stats));
#ifdef ANCACHE
	sc->an_sigitems = sc->an_nextitem = 0;
#endif
d275 33
a307 24
	ifmedia_init(&sc->an_ifmedia, 0, an_media_change, an_media_status);
#define	ADD(m, c)	ifmedia_add(&sc->an_ifmedia, (m), (c), NULL)
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2, 0, 0), 0);
	if (sc->an_caps.an_rates[2] == AN_RATE_5_5MBPS) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
		    IFM_IEEE80211_ADHOC, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5, 0, 0), 0);
	}
	if (sc->an_caps.an_rates[3] == AN_RATE_11MBPS) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
		    IFM_IEEE80211_ADHOC, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11, 0, 0), 0);
	}
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, 0, 0), 0);
#undef ADD
	ifmedia_set(&sc->an_ifmedia, IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
	    0, 0));
d310 1
a310 1
	 * Call MI attach routines.
d313 6
a318 6
	ether_ifattach(ifp);
	timeout_set(&sc->an_stat_ch, an_stats_update, sc);
#if NBPFILTER > 0
	BPFATTACH(&sc->sc_ic.ic_ac.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif
d322 1
a322 2
	an_reset(sc);
	an_init(sc);
d328 1
a328 2
an_rxeof(sc)
	struct an_softc	 *sc;
d330 15
a344 15
	struct ieee80211com	*ic = &sc->sc_ic;
	struct ifnet		*ifp = &ic->ic_if;
	struct ether_header	*eh;
#ifdef ANCACHE
	struct an_rxframe	rx_frame;
#endif
	struct an_rxframe_802_3	rx_frame_802_3;
	struct mbuf		*m;
	int			id, len, error = 0;

	id = CSR_READ_2(sc, AN_RX_FID);

#ifdef ANCACHE
	/* Read NIC frame header */
	if (an_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {
d346 1
d349 5
a353 4
#endif
	/* Read in the 802_3 frame header */
	if (an_read_data(sc, id, 0x34, (caddr_t)&rx_frame_802_3,
			 sizeof(rx_frame_802_3))) {
d355 1
d359 3
a361 4
	if (rx_frame_802_3.an_rx_802_3_status != 0) {
		ifp->if_ierrors++;
		return;
	}
d363 8
a370 5
	/* Check for insane frame length */
	len = letoh16(rx_frame_802_3.an_rx_802_3_payload_len);
	if (len + ETHER_HDR_LEN + 2 > MCLBYTES) {
		ifp->if_ierrors++;
		return;
d375 1
d377 1
d380 9
a388 5
	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		ifp->if_ierrors++;
		return;
d390 1
d392 30
d423 9
a431 15
	m->m_pkthdr.len = m->m_len = len + 12;
	m->m_data += ETHER_ALIGN;
	eh = mtod(m, struct ether_header *);

	bcopy((char *)&rx_frame_802_3.an_rx_dst_addr,
	    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);
	bcopy((char *)&rx_frame_802_3.an_rx_src_addr,
	    (char *)&eh->ether_shost, ETHER_ADDR_LEN);

	/* in mbuf header type is just before payload */
	error = an_read_data(sc, id, 0x44, (caddr_t)&(eh->ether_type), len);
	if (error) {
		m_freem(m);
		ifp->if_ierrors++;
		return;
d434 4
a437 13
	ifp->if_ipackets++;

#if NBPFILTER > 0
	/* Handle BPF listeners. */
	if (ifp->if_bpf)
		BPF_MTAP(ifp, m);
#endif

	/* Receive packet. */
#ifdef ANCACHE
	an_cache_store(sc, eh, m, rx_frame.an_rx_signal_strength);
#endif
	ether_input_mbuf(ifp, m);
d441 1
a441 3
an_txeof(sc, status)
	struct an_softc	*sc;
	int		status;
d443 2
a444 3
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int		id;
d446 1
a446 1
	ifp->if_timer = 0;
d450 1
d457 19
a475 39
	if (id != sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons])
		printf("%s: id mismatch: expected %x, got %x\n", ifp->if_xname,
		    sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons], id);

	sc->an_rdata.an_tx_ring[sc->an_rdata.an_tx_cons] = 0;
	AN_INC(sc->an_rdata.an_tx_cons, AN_TX_RING_CNT);
}

/*
 * We abuse the stats updater to check the current NIC status. This
 * is important because we don't want to allow transmissions until
 * the NIC has synchronized to the current cell (either as the master
 * in an ad-hoc group, or as a station connected to an access point).
 */
void
an_stats_update(xsc)
	void			*xsc;
{
	struct an_softc         *sc = xsc;
	struct ieee80211com	*ic = &sc->sc_ic;
	struct ifnet		*ifp = &ic->ic_if;
	int			s;

	s = splnet();

	sc->an_status.an_type = AN_RID_STATUS;
	sc->an_status.an_len = sizeof(struct an_ltv_status);
	an_read_record(sc, (struct an_ltv_gen *)&sc->an_status);

	if (sc->an_status.an_opmode & AN_STATUS_OPMODE_IN_SYNC)
		sc->an_associated = 1;
	else
		sc->an_associated = 0;

	/* Don't do this while we're transmitting */
	if (!(ifp->if_flags & IFF_OACTIVE)) {
		sc->an_stats.an_len = sizeof(struct an_ltv_stats);
		sc->an_stats.an_type = AN_RID_32BITS_CUM;
		an_read_record(sc, (struct an_ltv_gen *)&sc->an_stats.an_len);
a476 3

	splx(s);
	TIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);
d480 1
a480 2
an_intr(xsc)
	void	*xsc;
d482 8
a489 6
	struct an_softc		*sc = (struct an_softc*)xsc;
	struct ieee80211com	*ic = &sc->sc_ic;
	struct ifnet		*ifp = &ic->ic_if;
	u_int16_t		status;

	if (sc->an_gone)
d492 1
a492 2
	if (!(ifp->if_flags & IFF_UP)) {
		CSR_WRITE_2(sc, AN_EVENT_ACK, 0xFFFF);
d494 2
a495 1
		return 0;
d498 14
a511 9
	/* Disable interrupts. */
	CSR_WRITE_2(sc, AN_INT_EN, 0);

	status = CSR_READ_2(sc, AN_EVENT_STAT);
	CSR_WRITE_2(sc, AN_EVENT_ACK, ~AN_INTRS);

	if (status & AN_EV_AWAKE) {
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_AWAKE);
	}
d513 2
a514 7
	if (status & AN_EV_LINKSTAT) {
		if (CSR_READ_2(sc, AN_LINKSTAT) == AN_LINKSTAT_ASSOCIATED)
			sc->an_associated = 1;
		else
			sc->an_associated = 0;
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_LINKSTAT);
	}
d516 2
a517 4
	if (status & AN_EV_RX) {
		an_rxeof(sc);
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_RX);
	}
d519 2
a520 4
	if (status & AN_EV_TX) {
		an_txeof(sc, status);
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_TX);
	}
d522 4
a525 3
	if (status & AN_EV_TX_EXC) {
		an_txeof(sc, status);
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_TX_EXC);
a527 9
	if (status & AN_EV_ALLOC)
		CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_ALLOC);

	/* Re-enable interrupts. */
	CSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		an_start(ifp);

d531 1
d533 1
a533 4
an_cmd(sc, cmd, val)
	struct an_softc *sc;
	int cmd;
	int val;
d539 3
a541 1
		printf("%s: command busy\n", sc->sc_dev.dv_xname);
a547 1
	DELAY(10);
a548 1
	DELAY(10);
d550 6
a555 1
	for (i = AN_TIMEOUT; i--; DELAY(10)) {
d558 1
a558 6
		else {
			if (CSR_READ_2(sc, AN_COMMAND) == cmd) {
				DELAY(10);
				CSR_WRITE_2(sc, AN_COMMAND, cmd);
			}
		}
d563 2
a564 2
	/* clear stuck command busy if needed */
	if (CSR_READ_2(sc, AN_COMMAND) & AN_CMD_BUSY) {
a565 1
	}
d570 15
a584 5
	if (i <= 0)
		return(ETIMEDOUT);

	if (stat & AN_STAT_CMD_RESULT)
		return(EIO);
d586 1
a586 1
	return(0);
d589 2
a590 8
/*
 * This reset sequence may look a little strange, but this is the
 * most reliable method I've found to really kick the NIC in the
 * head and force it to reboot correctly.
 */
void
an_reset(sc)
	struct an_softc		*sc;
d592 6
a597 3
	if (sc->an_gone)
		return;
/*printf("ena ");*/
a598 1
/* printf("rst ");*/
a599 1
/*printf("nop ");*/
d602 1
a602 1
	if (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT)
d604 2
d608 1
d611 5
a615 11
/*
 * Read an LTV record from the NIC.
 */
int
an_read_record(sc, ltv)
	struct an_softc		*sc;
	struct an_ltv_gen	*ltv;
{
	u_int16_t	*ptr, len, rlen, ltv_data_length;
	volatile u_int16_t v;
	int		i;
d617 11
a627 8
	if (ltv->an_len < 4 || ltv->an_type == 0)
		return(EINVAL);

	/* Tell the NIC to enter record read mode. */
	if (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type)) {
		printf("%s: RID 0x%04x access failed\n",
		    sc->sc_dev.dv_xname, ltv->an_type);
		return(EIO);
d629 1
d631 7
a637 6
	/* Seek to the record. */
	if (an_seek(sc, ltv->an_type, 0, AN_BAP1)) {
		printf("%s: RID 0x%04x seek to record failed\n",
		    sc->sc_dev.dv_xname, ltv->an_type);
		return(EIO);
	}
d639 5
a643 66
	/*
	 * Read the length to make sure it
	 * matches what we expect (this verifies that we have enough
	 * room to hold all of the returned data).
	 */
	rlen = len = CSR_READ_2(sc, AN_DATA1);

	/*
	 * Work out record's data length, which is struct length - type word
	 * as we have just read the length.
	 */
	ltv_data_length = ltv->an_len - sizeof(u_int16_t);

	if (rlen > ltv_data_length)
		rlen = ltv_data_length;

	/* Now read the data. */
	len -= 2; rlen -= 2;	/* skip the type */
	ptr = ltv->an_val;
	for (i = 0; (rlen - i) > 1; i += 2)
		*ptr++ = CSR_READ_2(sc, AN_DATA1);
	if (rlen - i == 1)
		*(u_int8_t *)ptr = CSR_READ_1(sc, AN_DATA1);
	for (; i < len; i++)
		v = CSR_READ_1(sc, AN_DATA1);

#if BYTE_ORDER == BIG_ENDIAN
	switch (ltv->an_type) {
	case AN_RID_GENCONFIG:
	case AN_RID_ACTUALCFG:
		an_swap16(&ltv->an_val[4], 7); /* an_macaddr, an_rates */
		an_swap16(&ltv->an_val[63], 8);  /* an_nodename */
		break;
	case AN_RID_SSIDLIST:
		an_swap16(&ltv->an_val[1], 16); /* an_ssid1 */
		an_swap16(&ltv->an_val[18], 16); /* an_ssid2 */
		an_swap16(&ltv->an_val[35], 16); /* an_ssid3 */
		break;
	case AN_RID_APLIST:
		an_swap16(ltv->an_val, 12);
		break;
	case AN_RID_DRVNAME:
		an_swap16(ltv->an_val, 8);
		break;
	case AN_RID_CAPABILITIES:
		an_swap16(ltv->an_val, 2);	/* an_oui */
		an_swap16(&ltv->an_val[3], 34); /* an_manufname .. an_aironetaddr */
		an_swap16(&ltv->an_val[39], 8); /* an_callid .. an_tx_diversity */
		break;
	case AN_RID_STATUS:
		an_swap16(&ltv->an_val[0], 3);	/* an_macaddr */
		an_swap16(&ltv->an_val[7], 36);	/* an_ssid .. an_prev_bssid3 */
		an_swap16(&ltv->an_val[0x74/2], 2);	/* an_ap_ip_addr */
		break;
	case AN_RID_WEP_VOLATILE:
	case AN_RID_WEP_PERMANENT:
		an_swap16(&ltv->an_val[1], 3);	/* an_mac_addr */
		an_swap16(&ltv->an_val[5], 7);
		break;
	case AN_RID_32BITS_CUM:
		for (i = 0x60; i--;) {
			u_int16_t t = ltv->an_val[i * 2] ^ ltv->an_val[i * 2 + 1];
			ltv->an_val[i * 2] ^= t;
			ltv->an_val[i * 2 + 1] ^= t;
		}
		break;
d645 1
a645 2
#endif
	return(0);
a647 3
/*
 * Same as read, except we inject data instead of reading it.
 */
d649 1
a649 3
an_write_record(sc, ltv)
	struct an_softc		*sc;
	struct an_ltv_gen	*ltv;
d651 1
a651 2
	u_int16_t	*ptr;
	int		i;
d653 8
a660 2
	if (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv->an_type))
		return(EIO);
d662 3
a664 2
	if (an_seek(sc, ltv->an_type, 0, AN_BAP1))
		return(EIO);
d667 1
a667 1
	switch (ltv->an_type) {
a669 2
		an_swap16(&ltv->an_val[4], 7); /* an_macaddr, an_rates */
		an_swap16(&ltv->an_val[63], 8);  /* an_nodename */
a671 3
		an_swap16(&ltv->an_val[1], 16); /* an_ssid1 */
		an_swap16(&ltv->an_val[18], 16); /* an_ssid2 */
		an_swap16(&ltv->an_val[35], 16); /* an_ssid3 */
a673 1
		an_swap16(ltv->an_val, 12);
a675 1
		an_swap16(ltv->an_val, 8);
a677 3
		an_swap16(ltv->an_val, 2);	/* an_oui */
		an_swap16(&ltv->an_val[3], 34); /* an_manufname .. an_aironetaddr */
		an_swap16(&ltv->an_val[39], 8); /* an_callid .. an_tx_diversity */
a679 3
		an_swap16(&ltv->an_val[0], 3);	/* an_macaddr */
		an_swap16(&ltv->an_val[7], 36);	/* an_ssid .. an_prev_bssid3 */
		an_swap16(&ltv->an_val[0x74/2], 2);	/* an_ap_ip_addr */
a682 2
		an_swap16(&ltv->an_val[1], 3);	/* an_mac_addr */
		an_swap16(&ltv->an_val[5], 7);
d684 3
d690 1
a690 10
	CSR_WRITE_2(sc, AN_DATA1, ltv->an_len);

	ptr = ltv->an_val;
	for (i = 0; i < (ltv->an_len - 1) >> 1; i++)
		CSR_WRITE_2(sc, AN_DATA1, ptr[i]);

	if (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_WRITE, ltv->an_type))
		return(EIO);

	return(0);
d694 3
a696 21
an_seek(sc, id, off, chan)
	struct an_softc		*sc;
	int			id, off, chan;
{
	int			i;
	int			selreg, offreg;

	switch (chan) {
	case AN_BAP0:
		selreg = AN_SEL0;
		offreg = AN_OFF0;
		break;
	case AN_BAP1:
		selreg = AN_SEL1;
		offreg = AN_OFF1;
		break;
	default:
		printf("%s: invalid data path: %x\n",
		    sc->sc_dev.dv_xname, chan);
		return (EIO);
	}
d698 7
a704 6
	CSR_WRITE_2(sc, selreg, id);
	CSR_WRITE_2(sc, offreg, off);

	for (i = AN_TIMEOUT; i--; DELAY(10)) {
		if (!(CSR_READ_2(sc, offreg) & (AN_OFF_BUSY|AN_OFF_ERR)))
			break;
d707 4
a710 4
	if (i <= 0)
		return(ETIMEDOUT);

	return (0);
d714 1
a714 5
an_read_data(sc, id, off, buf, len)
	struct an_softc		*sc;
	int			id, off;
	caddr_t			buf;
	int			len;
d716 1
a716 2
	if (off != -1 && an_seek(sc, id, off, AN_BAP1))
		return(EIO);
d718 2
a719 4
	bus_space_read_raw_multi_2(sc->an_btag, sc->an_bhandle,
	    AN_DATA1, buf, len & ~1);
	if (len & 1)
	        ((u_int8_t *)buf)[len - 1] = CSR_READ_1(sc, AN_DATA1);
d721 21
a741 1
	return (0);
d745 1
a745 5
an_write_data(sc, id, off, buf, len)
	struct an_softc		*sc;
	int			id, off;
	caddr_t			buf;
	int			len;
d747 1
a747 2
	if (off != -1 && an_seek(sc, id, off, AN_BAP0))
		return(EIO);
d749 28
a776 6
	bus_space_write_raw_multi_2(sc->an_btag, sc->an_bhandle,
	    AN_DATA0, buf, len & ~1);
	if (len & 1)
	        CSR_WRITE_1(sc, AN_DATA0, ((u_int8_t *)buf)[len - 1]);

	return (0);
a778 4
/*
 * Allocate a region of memory inside the NIC and zero
 * it out.
 */
d780 1
a780 4
an_alloc_nicmem(sc, len, id)
	struct an_softc		*sc;
	int			len;
	int			*id;
d782 1
a782 1
	int			i;
d790 1
a790 1
	for (i = AN_TIMEOUT; i--; DELAY(10)) {
d793 5
d800 4
a803 2
	if (i <= 0)
		return(ETIMEDOUT);
d805 5
a809 2
	CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_ALLOC);
	*id = CSR_READ_2(sc, AN_ALLOC_FID);
d811 4
a814 2
	if (an_seek(sc, *id, 0, AN_BAP0))
		return(EIO);
d816 4
a819 3
	bus_space_set_multi_2(sc->an_btag, sc->an_bhandle,
	    AN_DATA0, 0, len / 2);
	CSR_WRITE_1(sc, AN_DATA0, 0);
d821 9
a829 1
	return(0);
d832 5
a836 11
void
an_setdef(sc, areq)
	struct an_softc		*sc;
	struct an_req		*areq;
{
	struct ieee80211com	*ic = &sc->sc_ic;
	struct ifnet		*ifp = &ic->ic_if;
	struct an_ltv_genconfig	*cfg;
	struct an_ltv_ssidlist	*ssid;
	struct an_ltv_aplist	*ap;
	struct an_ltv_gen	*sp;
d838 2
a839 7
	switch (areq->an_type) {
	case AN_RID_GENCONFIG:
		cfg = (struct an_ltv_genconfig *)areq;
		bcopy((char *)&cfg->an_macaddr,
		    (char *)&sc->sc_ic.ic_ac.ac_enaddr, ETHER_ADDR_LEN);
		bcopy((char *)&cfg->an_macaddr, LLADDR(ifp->if_sadl),
		    ETHER_ADDR_LEN);
d841 6
a846 31
		bcopy((char *)cfg, (char *)&sc->an_config,
			sizeof(struct an_ltv_genconfig));
		break;
	case AN_RID_SSIDLIST:
		ssid = (struct an_ltv_ssidlist *)areq;
		bcopy((char *)ssid, (char *)&sc->an_ssidlist,
			sizeof(struct an_ltv_ssidlist));
		break;
	case AN_RID_APLIST:
		ap = (struct an_ltv_aplist *)areq;
		bcopy((char *)ap, (char *)&sc->an_aplist,
			sizeof(struct an_ltv_aplist));
		break;
	case AN_RID_TX_SPEED:
		sp = (struct an_ltv_gen *)areq;
		sc->an_tx_rate = sp->an_val[0];
		break;
	case AN_RID_WEP_VOLATILE:
		/* Disable the MAC */
		an_cmd(sc, AN_CMD_DISABLE, 0);

		/* Just write the key, we don't want to save it */
		an_write_record(sc, (struct an_ltv_gen *)areq);

		/* Turn the MAC back on */
		an_cmd(sc, AN_CMD_ENABLE, 0);

		break;
	case AN_RID_WEP_PERMANENT:
		/* Disable the MAC */
		an_cmd(sc, AN_CMD_DISABLE, 0);
d848 1
a848 16
		/* Just write the key, the card will save it in this mode */
		an_write_record(sc, (struct an_ltv_gen *)areq);

		/* Turn the MAC back on */
		an_cmd(sc, AN_CMD_ENABLE, 0);

		break;
	default:
		printf("%s: unknown RID: %x\n",
		    sc->sc_dev.dv_xname, areq->an_type);
		return;
	}

	/* Reinitialize the card. */
	if (ifp->if_flags & IFF_UP)
		an_init(sc);
d851 2
a852 9
/*
 * We can't change the NIC configuration while the MAC is enabled,
 * so in order to turn on RX monitor mode, we have to turn the MAC
 * off first.
 */
void
an_promisc(sc, promisc)
	struct an_softc		*sc;
	int			promisc;
d854 3
a856 1
	struct an_ltv_genconfig genconf;
d858 2
a859 38
	/* Disable the MAC. */
	an_cmd(sc, AN_CMD_DISABLE, 0);

	/* Set RX mode. */
	if (promisc &&
	    !(sc->an_config.an_rxmode & AN_RXMODE_LAN_MONITOR_CURBSS)) {
		sc->an_rxmode = sc->an_config.an_rxmode;
		sc->an_config.an_rxmode |=
		    AN_RXMODE_LAN_MONITOR_CURBSS;
	} else {
		sc->an_config.an_rxmode = sc->an_rxmode;
	}

	/* Transfer the configuration to the NIC */
	genconf = sc->an_config;
	genconf.an_len = sizeof(struct an_ltv_genconfig);
	genconf.an_type = AN_RID_GENCONFIG;
	if (an_write_record(sc, (struct an_ltv_gen *)&genconf)) {
		printf("%s: failed to set configuration\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	/* Turn the MAC back on. */
	an_cmd(sc, AN_CMD_ENABLE, 0);
}

int
an_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
{
	int			s, error = 0;
	struct an_softc		*sc;
	struct an_req		areq;
	struct ifreq		*ifr;
	struct proc		*p = curproc;
	struct ifaddr		*ifa = (struct ifaddr *)data;
a862 13
	sc = ifp->if_softc;
	ifr = (struct ifreq *)data;

	if (sc->an_gone) {
		splx(s);
		return(ENODEV);
	}

	if ((error = ether_ioctl(ifp, &sc->sc_ic.ic_ac, command, data)) > 0) {
		splx(s);
		return error;
	}

d869 1
a869 1
			an_init(sc);
d874 1
a874 1
			an_init(sc);
d880 12
a891 21
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->an_if_flags & IFF_PROMISC)) {
				an_promisc(sc, 1);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->an_if_flags & IFF_PROMISC) {
				an_promisc(sc, 0);
				an_reset(sc);
			}
			an_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				an_stop(sc);
		}
		sc->an_if_flags = ifp->if_flags;
		error = 0;
		break;
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->an_ifmedia, command);
d898 2
a899 35
	case SIOCGAIRONET:
		error = copyin(ifr->ifr_data, &areq, sizeof(areq));
		if (error)
			break;
#ifdef ANCACHE
		if (areq.an_type == AN_RID_ZERO_CACHE) {
			error = suser(p, 0);
			if (error)
				break;
			sc->an_sigitems = sc->an_nextitem = 0;
			break;
		} else if (areq.an_type == AN_RID_READ_CACHE) {
			char *pt = (char *)&areq.an_val;
			bcopy((char *)&sc->an_sigitems, (char *)pt,
			    sizeof(int));
			pt += sizeof(int);
			areq.an_len = sizeof(int) / 2;
			bcopy((char *)&sc->an_sigcache, (char *)pt,
			    sizeof(struct an_sigcache) * sc->an_sigitems);
			areq.an_len += ((sizeof(struct an_sigcache) *
			    sc->an_sigitems) / 2) + 1;
		} else
#endif
		if (an_read_record(sc, (struct an_ltv_gen *)&areq)) {
			error = EINVAL;
			break;
		}
		error = copyout(&areq, ifr->ifr_data, sizeof(areq));
		break;
	case SIOCSAIRONET:
		error = suser(p, 0);
		if (error)
			break;
		error = copyin(ifr->ifr_data, &areq, sizeof(areq));
		if (error)
d901 2
a902 1
		an_setdef(sc, &areq);
d905 1
a905 1
		error = EINVAL;
d908 6
a913 1

a914 1

d919 1
a919 2
an_init_tx_ring(sc)
	struct an_softc		*sc;
d921 3
a923 2
	int			i;
	int			id;
d925 13
a937 8
	if (sc->an_gone)
		return (0);

	for (i = 0; i < AN_TX_RING_CNT; i++) {
		if (an_alloc_nicmem(sc, ETHER_MAX_LEN + 0x44, &id))
			return(ENOMEM);
		sc->an_rdata.an_tx_fids[i] = id;
		sc->an_rdata.an_tx_ring[i] = 0;
d939 1
a939 27

	sc->an_rdata.an_tx_prod = 0;
	sc->an_rdata.an_tx_cons = 0;

	return(0);
}

void
an_init(sc)
	struct an_softc *sc;
{
	struct ieee80211com	*ic = &sc->sc_ic;
	struct ifnet		*ifp = &ic->ic_if;
	struct an_ltv_ssidlist	ssid;
	struct an_ltv_aplist	aplist;
	struct an_ltv_genconfig	genconf;
	int	s;

	if (sc->an_gone)
		return;

	s = splnet();

	if (ifp->if_flags & IFF_RUNNING)
		an_stop(sc);

	sc->an_associated = 0;
d942 54
a995 5
	if (an_init_tx_ring(sc)) {
		printf("%s: tx buffer allocation failed\n",
		    sc->sc_dev.dv_xname);
		splx(s);
		return;
d997 1
a997 18

	/* Set our MAC address. */
	bcopy((char *)&sc->sc_ic.ic_ac.ac_enaddr,
	    (char *)&sc->an_config.an_macaddr, ETHER_ADDR_LEN);

	if (ifp->if_flags & IFF_BROADCAST)
		sc->an_config.an_rxmode = AN_RXMODE_BC_ADDR;
	else
		sc->an_config.an_rxmode = AN_RXMODE_ADDR;

	if (ifp->if_flags & IFF_MULTICAST)
		sc->an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;

	/* Initialize promisc mode. */
	if (ifp->if_flags & IFF_PROMISC)
		sc->an_config.an_rxmode |= AN_RXMODE_LAN_MONITOR_CURBSS;

	sc->an_rxmode = sc->an_config.an_rxmode;
d1000 11
a1010 7
	ssid = sc->an_ssidlist;
	ssid.an_type = AN_RID_SSIDLIST;
	ssid.an_len = sizeof(struct an_ltv_ssidlist);
	if (an_write_record(sc, (struct an_ltv_gen *)&ssid)) {
		printf("%s: failed to set ssid list\n", sc->sc_dev.dv_xname);
		splx(s);
		return;
d1014 24
a1037 18
	aplist = sc->an_aplist;
	aplist.an_type = AN_RID_APLIST;
	aplist.an_len = sizeof(struct an_ltv_aplist);
	if (an_write_record(sc, (struct an_ltv_gen *)&aplist)) {
		printf("%s: failed to set AP list\n", sc->sc_dev.dv_xname);
		splx(s);
		return;
	}

	/* Set the configuration in the NIC */
	genconf = sc->an_config;
	genconf.an_len = sizeof(struct an_ltv_genconfig);
	genconf.an_type = AN_RID_GENCONFIG;
	if (an_write_record(sc, (struct an_ltv_gen *)&genconf)) {
		printf("%s: failed to set configuration\n",
		    sc->sc_dev.dv_xname);
		splx(s);
		return;
d1043 2
a1044 2
		splx(s);
		return;
d1046 2
a1047 5

	/* enable interrupts */
	CSR_WRITE_2(sc, AN_INT_EN, AN_INTRS);

	splx(s);
d1051 3
d1055 3
a1057 1
	TIMEOUT(sc->an_stat_ch, an_stats_update, sc, hz);
d1061 1
a1061 2
an_start(ifp)
	struct ifnet		*ifp;
d1063 8
a1070 11
	struct an_softc		*sc;
	struct mbuf		*m0 = NULL;
	struct an_txframe_802_3	tx_frame_802_3;
	struct ether_header	*eh;
	u_int16_t		len;
	int			id;
	int			idx;
	unsigned char           txcontrol;
	int			pkts = 0;

	sc = ifp->if_softc;
d1072 3
a1074 1
	if (sc->an_gone)
d1076 1
d1078 16
a1093 12
	if (ifp->if_flags & IFF_OACTIVE)
		return;

	if (!sc->an_associated)
		return;

	idx = sc->an_rdata.an_tx_prod;
	bzero((char *)&tx_frame_802_3, sizeof(tx_frame_802_3));

	while(sc->an_rdata.an_tx_ring[idx] == 0) {
		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m0 == NULL)
d1095 3
a1097 32

		pkts++;
		id = sc->an_rdata.an_tx_fids[idx];
		eh = mtod(m0, struct ether_header *);

		bcopy((char *)&eh->ether_dhost,
		    (char *)&tx_frame_802_3.an_tx_dst_addr, ETHER_ADDR_LEN);
		bcopy((char *)&eh->ether_shost,
		    (char *)&tx_frame_802_3.an_tx_src_addr, ETHER_ADDR_LEN);

		len = m0->m_pkthdr.len - 12;  /* minus src/dest mac & type */
		tx_frame_802_3.an_tx_802_3_payload_len = htole16(len);

		m_copydata(m0, sizeof(struct ether_header) - 2, len,
		    (caddr_t)&sc->an_txbuf);

		txcontrol=AN_TXCTL_8023;
		/* write the txcontrol only */
		an_write_data(sc, id, 0x08, (caddr_t)&txcontrol,
			      sizeof(txcontrol));

		/* 802_3 header */
		an_write_data(sc, id, 0x34, (caddr_t)&tx_frame_802_3,
			      sizeof(struct an_txframe_802_3));

		/* in mbuf header type is just before payload */
		an_write_data(sc, id, 0x44, (caddr_t)&sc->an_txbuf, len);

		/*
		 * If there's a BPF listener, bounce a copy of
		 * this frame to him.
		 */
d1100 11
a1110 1
			BPF_MTAP(ifp, m0);
d1113 13
a1125 2
		m_freem(m0);
		m0 = NULL;
d1127 11
a1137 3
		sc->an_rdata.an_tx_ring[idx] = id;
		if (an_cmd(sc, AN_CMD_TX, id))
			printf("%s: xmit failed\n", sc->sc_dev.dv_xname);
d1139 10
a1148 4
		AN_INC(idx, AN_TX_RING_CNT);
	}
	if (pkts == 0)
		return;
d1150 6
a1155 2
	if (m0 != NULL)
		ifp->if_flags |= IFF_OACTIVE;
d1157 10
a1166 1
	sc->an_rdata.an_tx_prod = idx;
d1168 14
a1181 4
	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
d1185 1
a1185 2
an_stop(sc)
	struct an_softc		*sc;
d1187 2
a1188 3
	struct ieee80211com	*ic = &sc->sc_ic;
	struct ifnet		*ifp = &ic->ic_if;
	int			i;
d1190 1
a1190 1
	if (sc->an_gone)
d1193 1
a1193 3
	an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);
	CSR_WRITE_2(sc, AN_INT_EN, 0);
	an_cmd(sc, AN_CMD_DISABLE, 0);
d1195 6
a1200 2
	for (i = 0; i < AN_TX_RING_CNT; i++)
		an_cmd(sc, AN_CMD_DEALLOC_MEM, sc->an_rdata.an_tx_fids[i]);
d1202 3
a1204 1
	UNTIMEOUT(an_stats_update, sc, sc->an_stat_ch);
d1206 2
d1209 7
d1219 1
a1219 2
an_watchdog(ifp)
	struct ifnet		*ifp;
d1221 1
a1221 3
	struct an_softc		*sc;

	sc = ifp->if_softc;
d1223 1
a1223 1
	if (sc->an_gone)
d1226 10
a1235 6
	printf("%s: device timeout\n", sc->sc_dev.dv_xname);

	an_reset(sc);
	an_init(sc);

	ifp->if_oerrors++;
d1239 1
a1239 2
an_shutdown(self)
	void *self;
d1241 4
a1244 1
	an_stop(self);
d1247 30
a1276 25
#ifdef ANCACHE
/* Aironet signal strength cache code.
 * store signal/noise/quality on per MAC src basis in
 * a small fixed cache.  The cache wraps if > MAX slots
 * used.  The cache may be zeroed out to start over.
 * Two simple filters exist to reduce computation:
 * 1. ip only (literally 0x800, ETHERTYPE_IP) which may be used
 * to ignore some packets.  It defaults to ip only.
 * it could be used to focus on broadcast, non-IP 802.11 beacons.
 * 2. multicast/broadcast only.  This may be used to
 * ignore unicast packets and only cache signal strength
 * for multicast/broadcast packets (beacons); e.g., Mobile-IP
 * beacons and not unicast traffic.
 *
 * The cache stores (MAC src(index), IP src (major clue), signal,
 *	quality, noise)
 *
 * No apologies for storing IP src here.  It's easy and saves much
 * trouble elsewhere.  The cache is assumed to be INET dependent,
 * although it need not be.
 *
 * Note: the Aironet only has a single byte of signal strength value
 * in the rx frame header, and it's not scaled to anything sensible.
 * This is kind of lame, but it's all we've got.
 */
d1278 19
a1296 1
#ifdef documentation
d1298 2
a1299 3
int an_sigitems;                                /* number of cached entries */
struct an_sigcache an_sigcache[MAXANCACHE];  /*  array of cache entries */
int an_nextitem;                                /*  index/# of entries */
d1301 6
d1308 5
a1312 1
#endif
d1314 29
a1342 22
/* control variables for cache filtering.  Basic idea is
 * to reduce cost (e.g., to only Mobile-IP agent beacons
 * which are broadcast or multicast).  Still you might
 * want to measure signal strength anth unicast ping packets
 * on a pt. to pt. ant. setup.
 */
/* set true if you want to limit cache items to broadcast/mcast
 * only packets (not unicast).  Useful for mobile-ip beacons which
 * are broadcast/multicast at network layer.  Default is all packets
 * so ping/unicast anll work say anth pt. to pt. antennae setup.
 */
#if 0
static int an_cache_mcastonly = 0;
SYSCTL_INT(_machdep, OID_AUTO, an_cache_mcastonly, CTLFLAG_RW,
	&an_cache_mcastonly, 0, "");

/* set true if you want to limit cache items to IP packets only
*/
static int an_cache_iponly = 1;
SYSCTL_INT(_machdep, OID_AUTO, an_cache_iponly, CTLFLAG_RW,
	&an_cache_iponly, 0, "");
#endif
d1344 2
a1345 10
/*
 * an_cache_store, per rx packet store signal
 * strength in MAC (src) indexed cache.
 */
void
an_cache_store(sc, eh, m, rx_quality)
	struct an_softc *sc;
	struct ether_header *eh;
	struct mbuf *m;
	unsigned short rx_quality;
d1347 3
a1349 9
	static int cache_slot = 0;	/* use this cache entry */
	static int wrapindex = 0;       /* next "free" cache entry */
	int i, type_ipv4 = 0;

	/* filters:
	 * 1. ip only
	 * 2. configurable filter to throw out unicast packets,
	 * keep multicast only.
	 */
d1351 2
a1352 2
	if ((ntohs(eh->ether_type) == ETHERTYPE_IP))
		type_ipv4 = 1;
d1354 15
a1368 3
	/* filter for ip packets only */
	if (sc->an_cache_iponly && !type_ipv4)
		return;
d1370 8
a1377 3
	/* filter for broadcast/multicast only */
	if (sc->an_cache_mcastonly && ((eh->ether_dhost[0] & 1) == 0))
		return;
d1379 5
a1383 15
#ifdef SIGDEBUG
	printf("an: q value %x (MSB=0x%x, LSB=0x%x) \n",
	    rx_quality & 0xffff, rx_quality >> 8, rx_quality & 0xff);
#endif
	/* do a linear search for a matching MAC address
	 * in the cache table
	 * . MAC address is 6 bytes,
	 * . var w_nextitem holds total number of entries already cached
	 */
	for(i = 0; i < sc->an_nextitem; i++)
		if (!bcmp(eh->ether_shost, sc->an_sigcache[i].macsrc, 6))
			/* Match!,
			 * so we already have this entry, update the data
			 */
			break;
d1385 79
a1463 20
	/* did we find a matching mac address?
	 * if yes, then overwrite a previously existing cache entry
	 */
	if (i < sc->an_nextitem)
		cache_slot = i;

	/* else, have a new address entry,so
	 * add this new entry,
	 * if table full, then we need to replace LRU entry
	 */
	else {

		/* check for space in cache table
		 * note: an_nextitem also holds number of entries
		 * added in the cache table
		 */
		if (sc->an_nextitem < MAXANCACHE) {
			cache_slot = sc->an_nextitem;
			sc->an_nextitem++;
			sc->an_sigitems = sc->an_nextitem;
d1465 9
a1473 7
		/* no space found, so simply wrap anth wrap index
		 * and "zap" the next entry
		 */
		else {
			if (wrapindex == MAXANCACHE)
				wrapindex = 0;
			cache_slot = wrapindex++;
d1476 8
d1485 4
a1488 9
	/* invariant: cache_slot now points at some slot
	 * in cache.
	 */
	if (cache_slot < 0 || cache_slot >= MAXANCACHE) {
		log(LOG_ERR, "an_cache_store, bad index: %d of "
		    "[0..%d], gross cache error\n",
		    cache_slot, MAXANCACHE);
		return;
	}
d1490 29
a1518 8
	/*  store items in cache
	 *  .ip source address
	 *  .mac src
	 *  .signal, etc.
	 */
	if (type_ipv4) {
		struct ip *ip = (struct ip *)(mtod(m, char *) + ETHER_HDR_LEN);
		sc->an_sigcache[cache_slot].ipsrc = ntohl(ip->ip_src.s_addr);
d1520 1
a1520 3
	bcopy(eh->ether_shost, sc->an_sigcache[cache_slot].macsrc, 6);

	sc->an_sigcache[cache_slot].signal = rx_quality;
a1521 1
#endif
d1524 1
a1524 2
an_media_change(ifp)
	struct ifnet		*ifp;
d1526 2
a1527 3
	struct an_softc *sc = ifp->if_softc;
	int otype = sc->an_config.an_opmode;
	int orate = sc->an_tx_rate;
d1529 23
a1551 4
	if ((sc->an_ifmedia.ifm_cur->ifm_media & IFM_IEEE80211_ADHOC) != 0)
		sc->an_config.an_opmode = AN_OPMODE_IBSS_ADHOC;
	else
		sc->an_config.an_opmode = AN_OPMODE_INFRASTRUCTURE_STATION;
d1553 43
a1595 3
	switch (IFM_SUBTYPE(sc->an_ifmedia.ifm_cur->ifm_media)) {
	case IFM_IEEE80211_DS1:
		sc->an_tx_rate = AN_RATE_1MBPS;
d1597 2
a1598 11
	case IFM_IEEE80211_DS2:
		sc->an_tx_rate = AN_RATE_2MBPS;
		break;
	case IFM_IEEE80211_DS5:
		sc->an_tx_rate = AN_RATE_5_5MBPS;
		break;
	case IFM_IEEE80211_DS11:
		sc->an_tx_rate = AN_RATE_11MBPS;
		break;
	case IFM_AUTO:
		sc->an_tx_rate = 0;
d1601 10
d1612 2
a1613 3
	if (otype != sc->an_config.an_opmode ||
	    orate != sc->an_tx_rate)
		an_init(sc);
d1615 8
a1622 1
	return(0);
a1624 44
void
an_media_status(ifp, imr)
	struct ifnet		*ifp;
	struct ifmediareq	*imr;
{
	struct an_ltv_status	status;
	struct an_softc		*sc = ifp->if_softc;

	status.an_len = sizeof(status);
	status.an_type = AN_RID_STATUS;
	if (an_read_record(sc, (struct an_ltv_gen *)&status)) {
		/* If the status read fails, just lie. */
		imr->ifm_active = sc->an_ifmedia.ifm_cur->ifm_media;
		imr->ifm_status = IFM_AVALID|IFM_ACTIVE;
	}

	if (sc->an_tx_rate == 0) {
		imr->ifm_active = IFM_IEEE80211|IFM_AUTO;
		if (sc->an_config.an_opmode == AN_OPMODE_IBSS_ADHOC)
			imr->ifm_active |= IFM_IEEE80211_ADHOC;
		switch (status.an_current_tx_rate) {
		case AN_RATE_1MBPS:
			imr->ifm_active |= IFM_IEEE80211_DS1;
			break;
		case AN_RATE_2MBPS:
			imr->ifm_active |= IFM_IEEE80211_DS2;
			break;
		case AN_RATE_5_5MBPS:
			imr->ifm_active |= IFM_IEEE80211_DS5;
			break;
		case AN_RATE_11MBPS:
			imr->ifm_active |= IFM_IEEE80211_DS11;
			break;
		}
	} else {
		imr->ifm_active = sc->an_ifmedia.ifm_cur->ifm_media;
	}

	imr->ifm_status = IFM_AVALID;
	if (sc->an_config.an_opmode == AN_OPMODE_IBSS_ADHOC)
		imr->ifm_status |= IFM_ACTIVE;
	else if (status.an_opmode & AN_STATUS_OPMODE_ASSOCIATED)
		imr->ifm_status |= IFM_ACTIVE;
}
@


1.43
log
@dont' -> don't in comments;
from ray lai;
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.42 2005/06/20 22:42:29 jsg Exp $	*/
d432 1
a432 1
	s = splimp();
d990 1
a990 1
	s = splimp();
d1134 1
a1134 1
	s = splimp();
@


1.42
log
@Replace arpcom in the softc with ieee80211com in preparation for
further net80211 changes. ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.41 2005/04/24 00:25:05 brad Exp $	*/
d910 1
a910 1
		/* Just write the key, we dont' want to save it */
@


1.41
log
@- fix and update comments
- use ETHERTYPE_IP instead of magic value
- saanp -> type_ipv4

From FreeBSD

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.40 2005/02/04 01:07:39 kurt Exp $	*/
d118 2
d177 2
a178 1
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;
d229 1
a229 1
	   (char *)&sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
d231 1
a231 1
	printf(": address %6s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d291 1
a291 1
	BPFATTACH(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
d307 2
a308 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d395 2
a396 1
	struct ifnet	*ifp;
a398 2
	ifp = &sc->sc_arpcom.ac_if;

d427 3
a429 2
	struct an_softc		*sc;
	struct ifnet		*ifp;
a433 3
	sc = xsc;
	ifp = &sc->sc_arpcom.ac_if;

d458 3
a460 2
	struct an_softc		*sc;
	struct ifnet		*ifp;
a462 2
	sc = (struct an_softc*)xsc;

a465 2
	ifp = &sc->sc_arpcom.ac_if;

d874 2
a875 1
	struct ifnet		*ifp;
a880 2
	ifp = &sc->sc_arpcom.ac_if;

d885 1
a885 1
		    (char *)&sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
d1000 1
a1000 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
d1012 1
a1012 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d1124 2
a1125 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d1150 1
a1150 1
	bcopy((char *)&sc->sc_arpcom.ac_enaddr,
d1312 2
a1313 1
	struct ifnet		*ifp;
a1317 2

	ifp = &sc->sc_arpcom.ac_if;
@


1.40
log
@fix setting 128bit WEP keys on BIG_ENDIAN arches.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.39 2004/09/23 17:45:16 brad Exp $	*/
d46 1
a46 1
 * The Aironet 4500/4800 series cards some in PCMCIA, ISA and PCI form.
a57 1
 * - Lucent doesn't currently offer a PCI card, however Aironet does
d73 1
a73 3
 * being activated as an PCMCIA device. Consequently, /sys/pccard/pccard.c
 * has to be patched slightly in order to enable the Vpp voltages in
 * order to make the Aironet PCMCIA cards work.
d1366 1
a1366 1
 * 1. ip only (literally 0x800) which may be used
d1431 1
a1431 1
	int i, saanp = 0;
d1439 2
a1440 2
	if ((ntohs(eh->ether_type) == 0x800))
		saanp = 1;
d1443 1
a1443 1
	if (sc->an_cache_iponly && !saanp)
d1512 1
a1512 1
	if (saanp) {
@


1.39
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.38 2004/08/05 20:06:58 brad Exp $	*/
d683 1
a683 1
		an_swap16(&ltv->an_val[5], 6);
d745 1
a745 1
		an_swap16(&ltv->an_val[5], 6);
@


1.38
log
@use ETHER_MAX_LEN.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.37 2004/08/05 12:43:26 miod Exp $	*/
a234 1
	ifp->if_mtu = ETHERMTU;
@


1.37
log
@Remove forgotten debug code which does not compile on alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.36 2004/08/05 07:58:55 mickey Exp $	*/
d1115 1
a1115 1
		if (an_alloc_nicmem(sc, 1518 + 0x44, &id))
@


1.36
log
@allocate a cluster on rx after all possible failures had been checked for; repair sigcache misalignment
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.35 2004/07/24 21:26:05 mickey Exp $	*/
a358 1
if ((int)m->m_data & 3) printf("m_data %p\n", m->m_data);
@


1.35
log
@provide proper ip header alignment (and repair big endian archs again from after ether_input_mbuf conversion); also kill some stupid spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.34 2003/10/21 18:58:48 jmc Exp $	*/
d308 1
a308 1
	struct ifnet		*ifp;
d315 1
a315 3
	int			id, error = 0;

	ifp = &sc->sc_arpcom.ac_if;
a318 17
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}
	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		ifp->if_ierrors++;
		return;
	}

	m->m_pkthdr.rcvif = ifp;
	m->m_data += ETHER_ALIGN;

	eh = mtod(m, struct ether_header *);

d339 2
a340 1
	if (letoh16(rx_frame_802_3.an_rx_802_3_payload_len) > MCLBYTES) {
d345 17
a361 2
	m->m_pkthdr.len = m->m_len =
	    letoh16(rx_frame_802_3.an_rx_802_3_payload_len) + 12;
d369 1
a369 2
	error = an_read_data(sc, id, 0x44, (caddr_t)&(eh->ether_type),
			     letoh16(rx_frame_802_3.an_rx_802_3_payload_len));
a1435 1
	struct ip *ip = 0;
a1458 5

	/* find the ip header.  we want to store the ip_src address */
	if (saanp)
		ip = (struct ip *)(mtod(m, char *) + sizeof(struct ether_header));

d1517 4
a1520 2
	if (saanp)
		sc->an_sigcache[cache_slot].ipsrc = ip->ip_src.s_addr;
@


1.34
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.33 2003/10/05 01:26:11 mickey Exp $	*/
d334 1
d692 1
a692 1
		for (i = 0x60; i--; ) {
d968 1
a968 1
	    !(sc->an_config.an_rxmode & AN_RXMODE_LAN_MONITOR_CURBSS) ) {
d1432 1
a1432 1
an_cache_store (sc, eh, m, rx_quality)
a1437 2
	struct ip *ip = 0;
	int i;
d1440 2
a1441 1
	int saanp=0;
d1452 1
a1452 2
	/* filter for ip packets only
	*/
d1475 1
a1475 1
		if (!bcmp(eh->ether_shost , sc->an_sigcache[i].macsrc, 6))
d1484 1
a1484 1
	if (i < sc->an_nextitem )
d1497 1
a1497 1
		if ( sc->an_nextitem < MAXANCACHE ) {
d1529 1
a1529 1
	bcopy( eh->ether_shost, sc->an_sigcache[cache_slot].macsrc,  6);
@


1.33
log
@from freebsd: read one word less (for type) and take care of odd sized records
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.32 2003/09/26 01:29:55 mickey Exp $	*/
d1287 1
a1287 1
		 * If there's a BPF listner, bounce a copy of
@


1.32
log
@reading the record skip the remainder of data we do not need. we are still screwed on writes though
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.31 2003/09/25 22:32:27 mickey Exp $	*/
d648 1
d650 1
a650 1
	for (i = 0; i < rlen; i += 2)
d652 4
a655 2
	for (; i < len; i += 2)
		v = CSR_READ_2(sc, AN_DATA1);
@


1.31
log
@make sure to not overflow when initializing {node,net}name (truncation does not matter)
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.30 2003/09/23 11:13:20 avsm Exp $	*/
d610 2
a611 1
	u_int16_t	*ptr, len;
a612 1
	u_int16_t	ltv_data_length;
d636 1
a636 1
	len = CSR_READ_2(sc, AN_DATA1);
d644 2
a645 6
	if (len > ltv_data_length) {
		printf("%s: RID 0x%04x record length mismatch -- expected %d, "
		    "got %d\n", sc->sc_dev.dv_xname, ltv->an_type,
		    ltv_data_length, len);
		return(ENOSPC);
	}
d649 4
a652 2
	for (i = 0; i < (len - 1) >> 1; i++)
		ptr[i] = CSR_READ_2(sc, AN_DATA1);
@


1.30
log
@revert safety checks; requested by mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.29 2003/09/19 00:27:02 avsm Exp $	*/
d244 2
a245 2
	bcopy(AN_DEFAULT_NODENAME, sc->an_config.an_nodename,
	    sizeof(AN_DEFAULT_NODENAME) - 1);
d248 3
a250 3
	bcopy(AN_DEFAULT_NETNAME, sc->an_ssidlist.an_ssid1,
	    sizeof(AN_DEFAULT_NETNAME) - 1);
	sc->an_ssidlist.an_ssid1_len = strlen(AN_DEFAULT_NETNAME);
@


1.29
log
@Put in a couple of sanity checks to ensure that the AN_DEFAULT_*
variables arent defined too large.
itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.28 2003/08/15 20:32:16 tedu Exp $	*/
a242 3
	if (sizeof(sc->an_config.an_nodename) < sizeof(AN_DEFAULT_NODENAME))
		panic("AN_DEFAULT_NODENAME too long");

a245 3

	if (sizeof(sc->an_ssidlist.an_ssid1) < sizeof(AN_DEFAULT_NETNAME))
		panic("AN_DEFAULT_NETNAME too long");
@


1.28
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.27 2003/06/25 22:28:14 mickey Exp $	*/
d243 3
d249 3
@


1.27
log
@AN_RID_ACTUALCFG gets the same endianesslessness as AN_RID_GENCONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.26 2003/06/23 18:02:47 mickey Exp $	*/
d1065 1
a1065 1
			error = suser(p->p_ucred, &p->p_acflag);
d1089 1
a1089 1
		error = suser(p->p_ucred, &p->p_acflag);
@


1.26
log
@no need for an explicit <machine/intr.h> inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.25 2002/07/10 20:21:15 fgsch Exp $	*/
d659 1
d721 1
@


1.25
log
@use ifp->if_sadl whether possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.24 2002/06/09 03:14:18 todd Exp $	*/
a126 1
#include <machine/intr.h>
@


1.24
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.23 2002/03/14 01:26:54 millert Exp $	*/
a881 2
	struct sockaddr_dl	*sdl;
	struct ifaddr		*ifa;
a886 1
	extern struct ifaddr	**ifnet_addrs;
d893 3
a895 4

		ifa = ifnet_addrs[ifp->if_index];
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		bcopy((char *)&cfg->an_macaddr, (char *)&sc->sc_arpcom.ac_enaddr,
a896 1
		bcopy((char *)&cfg->an_macaddr, LLADDR(sdl), ETHER_ADDR_LEN);
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.22 2002/03/12 09:51:20 kjc Exp $	*/
d179 1
a179 1
	struct ifnet	*ifp = &sc->arpcom.ac_if;
d230 1
a230 1
	   (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);
d232 1
a232 1
	printf(": address %6s\n", ether_sprintf(sc->arpcom.ac_enaddr));
d293 1
a293 1
	BPFATTACH(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
d318 1
a318 1
	ifp = &sc->arpcom.ac_if;
d403 1
a403 1
	ifp = &sc->arpcom.ac_if;
d440 1
a440 1
	ifp = &sc->arpcom.ac_if;
d475 1
a475 1
	ifp = &sc->arpcom.ac_if;
d891 1
a891 1
	ifp = &sc->arpcom.ac_if;
d899 1
a899 1
		bcopy((char *)&cfg->an_macaddr, (char *)&sc->arpcom.ac_enaddr,
d1014 1
a1014 1
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
d1026 1
a1026 1
			arp_ifinit(&sc->arpcom, ifa);
d1138 1
a1138 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d1163 1
a1163 1
	bcopy((char *)&sc->arpcom.ac_enaddr,
d1331 1
a1331 1
	ifp = &sc->arpcom.ac_if;
@


1.22
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.21 2002/01/02 18:34:11 mickey Exp $	*/
d141 20
a160 20
void an_reset		__P((struct an_softc *));
int an_ioctl		__P((struct ifnet *, u_long, caddr_t));
int an_init_tx_ring	__P((struct an_softc *));
void an_start		__P((struct ifnet *));
void an_watchdog		__P((struct ifnet *));
void an_rxeof		__P((struct an_softc *));
void an_txeof		__P((struct an_softc *, int));

void an_promisc		__P((struct an_softc *, int));
int an_cmd		__P((struct an_softc *, int, int));
int an_read_record	__P((struct an_softc *, struct an_ltv_gen *));
int an_write_record	__P((struct an_softc *, struct an_ltv_gen *));
int an_read_data		__P((struct an_softc *, int,
					int, caddr_t, int));
int an_write_data	__P((struct an_softc *, int,
					int, caddr_t, int));
int an_seek		__P((struct an_softc *, int, int, int));
int an_alloc_nicmem	__P((struct an_softc *, int, int *));
void an_stats_update	__P((void *));
void an_setdef		__P((struct an_softc *, struct an_req *));
d162 2
a163 2
void an_cache_store	__P((struct an_softc *, struct ether_header *,
					struct mbuf *, unsigned short));
d165 2
a166 2
int an_media_change	__P((struct ifnet *));
void an_media_status	__P((struct ifnet *, struct ifmediareq *));
@


1.21
log
@proper data length handling on read; from toby@@svector.co.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.20 2001/09/29 21:54:00 mickey Exp $	*/
d242 1
d522 1
a522 1
	if (ifp->if_snd.ifq_head != NULL)
d1241 1
d1258 1
a1258 1
		IF_DEQUEUE(&ifp->if_snd, m0);
d1262 1
d1307 2
@


1.20
log
@if_media support, from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.19 2001/07/08 23:38:05 fgsch Exp $	*/
d612 1
d632 2
a633 2
	 * Read the length and record type and make sure they
	 * match what we expect (this verifies that we have enough
d637 8
a644 1
	if (len > ltv->an_len) {
d647 1
a647 1
		    ltv->an_len, len);
a650 2
	ltv->an_len = len;

d653 1
a653 1
	for (i = 0; i < (ltv->an_len - 1) >> 1; i++)
@


1.20.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.21 2002/01/02 18:34:11 mickey Exp $	*/
a611 1
	u_int16_t	ltv_data_length;
d631 2
a632 2
	 * Read the length to make sure it
	 * matches what we expect (this verifies that we have enough
d636 1
a636 8

	/*
	 * Work out record's data length, which is struct length - type word
	 * as we have just read the length.
	 */
	ltv_data_length = ltv->an_len - sizeof(u_int16_t);

	if (len > ltv_data_length) {
d639 1
a639 1
		    ltv_data_length, len);
d643 2
d647 1
a647 1
	for (i = 0; i < (len - 1) >> 1; i++)
@


1.20.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.20.4.1 2002/01/31 22:55:30 niklas Exp $	*/
d141 20
a160 20
void an_reset(struct an_softc *);
int an_ioctl(struct ifnet *, u_long, caddr_t);
int an_init_tx_ring(struct an_softc *);
void an_start(struct ifnet *);
void an_watchdog(struct ifnet *);
void an_rxeof(struct an_softc *);
void an_txeof(struct an_softc *, int);

void an_promisc(struct an_softc *, int);
int an_cmd(struct an_softc *, int, int);
int an_read_record(struct an_softc *, struct an_ltv_gen *);
int an_write_record(struct an_softc *, struct an_ltv_gen *);
int an_read_data(struct an_softc *, int,
					int, caddr_t, int);
int an_write_data(struct an_softc *, int,
					int, caddr_t, int);
int an_seek(struct an_softc *, int, int, int);
int an_alloc_nicmem(struct an_softc *, int, int *);
void an_stats_update(void *);
void an_setdef(struct an_softc *, struct an_req *);
d162 2
a163 2
void an_cache_store(struct an_softc *, struct ether_header *,
					struct mbuf *, unsigned short);
d165 2
a166 2
int an_media_change(struct ifnet *);
void an_media_status(struct ifnet *, struct ifmediareq *);
d179 1
a179 1
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;
d230 1
a230 1
	   (char *)&sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
d232 1
a232 1
	printf(": address %6s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
a241 1
	IFQ_SET_READY(&ifp->if_snd);
d292 1
a292 1
	BPFATTACH(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
d317 1
a317 1
	ifp = &sc->sc_arpcom.ac_if;
d402 1
a402 1
	ifp = &sc->sc_arpcom.ac_if;
d439 1
a439 1
	ifp = &sc->sc_arpcom.ac_if;
d474 1
a474 1
	ifp = &sc->sc_arpcom.ac_if;
d521 1
a521 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
d890 1
a890 1
	ifp = &sc->sc_arpcom.ac_if;
d898 1
a898 1
		bcopy((char *)&cfg->an_macaddr, (char *)&sc->sc_arpcom.ac_enaddr,
d1013 1
a1013 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
d1025 1
a1025 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d1137 1
a1137 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d1162 1
a1162 1
	bcopy((char *)&sc->sc_arpcom.ac_enaddr,
a1239 1
	int			pkts = 0;
d1256 1
a1256 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
a1259 1
		pkts++;
a1303 2
	if (pkts == 0)
		return;
d1326 1
a1326 1
	ifp = &sc->sc_arpcom.ac_if;
@


1.20.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.20.4.2 2002/06/11 03:42:17 art Exp $	*/
d882 2
d889 1
d896 4
a899 3
		bcopy((char *)&cfg->an_macaddr,
		    (char *)&sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
		bcopy((char *)&cfg->an_macaddr, LLADDR(ifp->if_sadl),
d901 1
@


1.19
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.18 2001/06/25 21:11:16 mickey Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/an/if_an.c,v 1.2 2000/01/16 06:41:49 wpaul Exp $
d165 2
d260 25
d613 1
a613 1
	if (ltv->an_len == 0 || ltv->an_type == 0)
d1047 4
d1527 83
@


1.18
log
@remove struct and contsts duplicated in between the files.
make it work on powerpc.
improve performance by using the bus_*_multi_* finctions instead of loops.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.17 2001/06/23 23:36:02 mickey Exp $	*/
a239 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
@


1.17
log
@use ether_input_mbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.16 2001/06/10 19:26:16 mickey Exp $	*/
d166 7
d331 1
a331 1
	if (rx_frame_802_3.an_rx_802_3_payload_len > MCLBYTES) {
d337 1
a337 2
	    rx_frame_802_3.an_rx_802_3_payload_len + 12;

d346 1
a346 2
			     rx_frame_802_3.an_rx_802_3_payload_len);

d370 2
a371 2
	struct an_softc		*sc;
	int			status;
d373 2
a374 2
	struct ifnet		*ifp;
	int			id;
d383 1
a383 1
	if (status & AN_EV_TX_EXC) {
d385 1
a385 1
	} else
d584 2
a585 2
	u_int16_t		*ptr;
	int			i, len;
d620 1
a620 1
	ptr = &ltv->an_val;
d624 41
d676 2
a677 2
	u_int16_t		*ptr;
	int			i;
d685 35
d722 1
a722 1
	ptr = &ltv->an_val;
d752 1
a752 1
		return(EIO);
d766 1
a766 1
	return(0);
d776 2
a777 8
	int			i;
	u_int16_t		*ptr;
	u_int8_t		*ptr2;

	if (off != -1) {
		if (an_seek(sc, id, off, AN_BAP1))
			return(EIO);
	}
d779 4
a782 8
	ptr = (u_int16_t *)buf;
	for (i = 0; i < len / 2; i++)
		ptr[i] = CSR_READ_2(sc, AN_DATA1);
	i*=2;
	if (i<len){
	        ptr2 = (u_int8_t *)buf;
	        ptr2[i] = CSR_READ_1(sc, AN_DATA1);
	}
d784 1
a784 1
	return(0);
d794 2
a795 8
	int			i;
	u_int16_t		*ptr;
	u_int8_t		*ptr2;

	if (off != -1) {
		if (an_seek(sc, id, off, AN_BAP0))
			return(EIO);
	}
d797 4
a800 8
	ptr = (u_int16_t *)buf;
	for (i = 0; i < (len / 2); i++)
		CSR_WRITE_2(sc, AN_DATA0, ptr[i]);
	i*=2;
	if (i<len){
	        ptr2 = (u_int8_t *)buf;
	        CSR_WRITE_1(sc, AN_DATA0, ptr2[i]);
	}
d802 1
a802 1
	return(0);
d837 3
a839 2
	for (i = 0; i < len / 2; i++)
		CSR_WRITE_2(sc, AN_DATA0, 0);
d885 1
a885 1
		sc->an_tx_rate = sp->an_val;
d930 2
d937 1
a937 2
	    !(sc->an_config.an_rxmode & AN_RXMODE_LAN_MONITOR_CURBSS)
	    ) {
d946 4
a949 3
	sc->an_config.an_len = sizeof(struct an_ltv_genconfig);
	sc->an_config.an_type = AN_RID_GENCONFIG;
	if (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {
d1102 4
a1105 1
	int			s;
d1144 4
a1147 3
	sc->an_ssidlist.an_type = AN_RID_SSIDLIST;
	sc->an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist);
	if (an_write_record(sc, (struct an_ltv_gen *)&sc->an_ssidlist)) {
d1154 4
a1157 3
	sc->an_aplist.an_type = AN_RID_APLIST;
	sc->an_aplist.an_len = sizeof(struct an_ltv_aplist);
	if (an_write_record(sc, (struct an_ltv_gen *)&sc->an_aplist)) {
d1164 4
a1167 3
	sc->an_config.an_len = sizeof(struct an_ltv_genconfig);
	sc->an_config.an_type = AN_RID_GENCONFIG;
	if (an_write_record(sc, (struct an_ltv_gen *)&sc->an_config)) {
d1200 1
d1232 2
a1233 2
		tx_frame_802_3.an_tx_802_3_payload_len =
		  m0->m_pkthdr.len - 12;  /* minus src/dest mac & type */
d1235 1
a1235 2
		m_copydata(m0, sizeof(struct ether_header) - 2 ,
		    tx_frame_802_3.an_tx_802_3_payload_len,
d1248 1
a1248 2
		an_write_data(sc, id, 0x44, (caddr_t)&sc->an_txbuf,
			    tx_frame_802_3.an_tx_802_3_payload_len);
d1411 1
a1411 1
	if ((ntohs(eh->ether_type) == 0x800)) {
a1412 1
	}
d1416 1
a1416 1
	if (sc->an_cache_iponly && !saanp) {
a1417 1
	}
d1419 2
a1420 3
	/* filter for broadcast/multicast only
	 */
	if (sc->an_cache_mcastonly && ((eh->ether_dhost[0] & 1) == 0)) {
a1421 1
	}
d1428 2
a1429 4
	/* find the ip header.  we want to store the ip_src
	 * address.
	 */
	if (saanp) {
a1430 1
	}
d1437 2
a1438 2
	for(i = 0; i < sc->an_nextitem; i++) {
		if (!bcmp(eh->ether_shost , sc->an_sigcache[i].macsrc, 6)) {
a1442 2
		}
	}
d1447 1
a1447 1
	if (i < sc->an_nextitem )   {
d1449 1
a1449 1
	}
d1454 1
a1454 1
	else    {
d1469 1
a1469 1
			if (wrapindex == MAXANCACHE) {
a1470 1
			}
d1490 1
a1490 1
	if (saanp) {
a1491 1
	}
@


1.16
log
@inconsistantly redundant returns
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.15 2001/04/17 04:34:08 aaron Exp $	*/
a356 1
	m_adj(m, sizeof(struct ether_header));
d360 1
a360 1
	ether_input(ifp, eh, m);
d1367 1
a1367 1
		ip = mtod(m, struct ip *);
d1376 1
a1376 1
		if (! bcmp(eh->ether_shost , sc->an_sigcache[i].macsrc,  6 )) {
d1378 1
a1378 2
			 * so we already have this entry,
			 * update the data
@


1.15
log
@No colon after "address" when printing out Ethernet address.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.14 2001/04/16 00:40:40 tholo Exp $	*/
a361 2

	return;
a389 2

	return;
a569 2

	return;
a856 2

	return;
a892 2

	return;
a1120 2

	return;
a1209 2

	return;
a1233 2

	return;
a1252 2

	return;
a1438 2

	return;
@


1.15.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.15 2001/04/17 04:34:08 aaron Exp $	*/
@


1.15.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.15.4.1 2001/05/14 22:23:30 niklas Exp $	*/
a165 7
static __inline void
an_swap16(u_int16_t *p, int cnt)
{
	for (; cnt--; p++)
		*p = swap16(*p);
}

d324 1
a324 1
	if (letoh16(rx_frame_802_3.an_rx_802_3_payload_len) > MCLBYTES) {
d330 2
a331 1
	    letoh16(rx_frame_802_3.an_rx_802_3_payload_len) + 12;
d340 2
a341 1
			     letoh16(rx_frame_802_3.an_rx_802_3_payload_len));
d357 1
d361 3
a363 1
	ether_input_mbuf(ifp, m);
d368 2
a369 2
	struct an_softc	*sc;
	int		status;
d371 2
a372 2
	struct ifnet	*ifp;
	int		id;
d381 1
a381 1
	if (status & AN_EV_TX_EXC)
d383 1
a383 1
	else
d392 2
d574 2
d586 2
a587 2
	u_int16_t	*ptr, len;
	int		i;
d622 1
a622 1
	ptr = ltv->an_val;
a625 41
#if BYTE_ORDER == BIG_ENDIAN
	switch (ltv->an_type) {
	case AN_RID_GENCONFIG:
		an_swap16(&ltv->an_val[4], 7); /* an_macaddr, an_rates */
		an_swap16(&ltv->an_val[63], 8);  /* an_nodename */
		break;
	case AN_RID_SSIDLIST:
		an_swap16(&ltv->an_val[1], 16); /* an_ssid1 */
		an_swap16(&ltv->an_val[18], 16); /* an_ssid2 */
		an_swap16(&ltv->an_val[35], 16); /* an_ssid3 */
		break;
	case AN_RID_APLIST:
		an_swap16(ltv->an_val, 12);
		break;
	case AN_RID_DRVNAME:
		an_swap16(ltv->an_val, 8);
		break;
	case AN_RID_CAPABILITIES:
		an_swap16(ltv->an_val, 2);	/* an_oui */
		an_swap16(&ltv->an_val[3], 34); /* an_manufname .. an_aironetaddr */
		an_swap16(&ltv->an_val[39], 8); /* an_callid .. an_tx_diversity */
		break;
	case AN_RID_STATUS:
		an_swap16(&ltv->an_val[0], 3);	/* an_macaddr */
		an_swap16(&ltv->an_val[7], 36);	/* an_ssid .. an_prev_bssid3 */
		an_swap16(&ltv->an_val[0x74/2], 2);	/* an_ap_ip_addr */
		break;
	case AN_RID_WEP_VOLATILE:
	case AN_RID_WEP_PERMANENT:
		an_swap16(&ltv->an_val[1], 3);	/* an_mac_addr */
		an_swap16(&ltv->an_val[5], 6);
		break;
	case AN_RID_32BITS_CUM:
		for (i = 0x60; i--; ) {
			u_int16_t t = ltv->an_val[i * 2] ^ ltv->an_val[i * 2 + 1];
			ltv->an_val[i * 2] ^= t;
			ltv->an_val[i * 2 + 1] ^= t;
		}
		break;
	}
#endif
d637 2
a638 2
	u_int16_t	*ptr;
	int		i;
a645 35
#if BYTE_ORDER == BIG_ENDIAN
	switch (ltv->an_type) {
	case AN_RID_GENCONFIG:
		an_swap16(&ltv->an_val[4], 7); /* an_macaddr, an_rates */
		an_swap16(&ltv->an_val[63], 8);  /* an_nodename */
		break;
	case AN_RID_SSIDLIST:
		an_swap16(&ltv->an_val[1], 16); /* an_ssid1 */
		an_swap16(&ltv->an_val[18], 16); /* an_ssid2 */
		an_swap16(&ltv->an_val[35], 16); /* an_ssid3 */
		break;
	case AN_RID_APLIST:
		an_swap16(ltv->an_val, 12);
		break;
	case AN_RID_DRVNAME:
		an_swap16(ltv->an_val, 8);
		break;
	case AN_RID_CAPABILITIES:
		an_swap16(ltv->an_val, 2);	/* an_oui */
		an_swap16(&ltv->an_val[3], 34); /* an_manufname .. an_aironetaddr */
		an_swap16(&ltv->an_val[39], 8); /* an_callid .. an_tx_diversity */
		break;
	case AN_RID_STATUS:
		an_swap16(&ltv->an_val[0], 3);	/* an_macaddr */
		an_swap16(&ltv->an_val[7], 36);	/* an_ssid .. an_prev_bssid3 */
		an_swap16(&ltv->an_val[0x74/2], 2);	/* an_ap_ip_addr */
		break;
	case AN_RID_WEP_VOLATILE:
	case AN_RID_WEP_PERMANENT:
		an_swap16(&ltv->an_val[1], 3);	/* an_mac_addr */
		an_swap16(&ltv->an_val[5], 6);
		break;
	}
#endif

d648 1
a648 1
	ptr = ltv->an_val;
d678 1
a678 1
		return (EIO);
d692 1
a692 1
	return (0);
d702 3
a704 2
	if (off != -1 && an_seek(sc, id, off, AN_BAP1))
		return(EIO);
d706 4
a709 4
	bus_space_read_raw_multi_2(sc->an_btag, sc->an_bhandle,
	    AN_DATA1, buf, len & ~1);
	if (len & 1)
	        ((u_int8_t *)buf)[len - 1] = CSR_READ_1(sc, AN_DATA1);
d711 10
a720 1
	return (0);
d730 8
a737 2
	if (off != -1 && an_seek(sc, id, off, AN_BAP0))
		return(EIO);
d739 8
a746 4
	bus_space_write_raw_multi_2(sc->an_btag, sc->an_bhandle,
	    AN_DATA0, buf, len & ~1);
	if (len & 1)
	        CSR_WRITE_1(sc, AN_DATA0, ((u_int8_t *)buf)[len - 1]);
d748 1
a748 1
	return (0);
d783 2
a784 3
	bus_space_set_multi_2(sc->an_btag, sc->an_bhandle,
	    AN_DATA0, 0, len / 2);
	CSR_WRITE_1(sc, AN_DATA0, 0);
d830 1
a830 1
		sc->an_tx_rate = sp->an_val[0];
d863 2
a876 2
	struct an_ltv_genconfig genconf;

d882 2
a883 1
	    !(sc->an_config.an_rxmode & AN_RXMODE_LAN_MONITOR_CURBSS) ) {
d892 3
a894 4
	genconf = sc->an_config;
	genconf.an_len = sizeof(struct an_ltv_genconfig);
	genconf.an_type = AN_RID_GENCONFIG;
	if (an_write_record(sc, (struct an_ltv_gen *)&genconf)) {
d901 2
d1049 1
a1049 4
	struct an_ltv_ssidlist	ssid;
	struct an_ltv_aplist	aplist;
	struct an_ltv_genconfig	genconf;
	int	s;
d1088 3
a1090 4
	ssid = sc->an_ssidlist;
	ssid.an_type = AN_RID_SSIDLIST;
	ssid.an_len = sizeof(struct an_ltv_ssidlist);
	if (an_write_record(sc, (struct an_ltv_gen *)&ssid)) {
d1097 3
a1099 4
	aplist = sc->an_aplist;
	aplist.an_type = AN_RID_APLIST;
	aplist.an_len = sizeof(struct an_ltv_aplist);
	if (an_write_record(sc, (struct an_ltv_gen *)&aplist)) {
d1106 3
a1108 4
	genconf = sc->an_config;
	genconf.an_len = sizeof(struct an_ltv_genconfig);
	genconf.an_type = AN_RID_GENCONFIG;
	if (an_write_record(sc, (struct an_ltv_gen *)&genconf)) {
d1131 2
a1142 1
	u_int16_t		len;
d1174 2
a1175 2
		len = m0->m_pkthdr.len - 12;  /* minus src/dest mac & type */
		tx_frame_802_3.an_tx_802_3_payload_len = htole16(len);
d1177 2
a1178 1
		m_copydata(m0, sizeof(struct ether_header) - 2, len,
d1191 2
a1192 1
		an_write_data(sc, id, 0x44, (caddr_t)&sc->an_txbuf, len);
d1222 2
d1248 2
d1269 2
d1361 1
a1361 1
	if ((ntohs(eh->ether_type) == 0x800))
d1363 1
d1367 1
a1367 1
	if (sc->an_cache_iponly && !saanp)
d1369 1
d1371 3
a1373 2
	/* filter for broadcast/multicast only */
	if (sc->an_cache_mcastonly && ((eh->ether_dhost[0] & 1) == 0))
d1375 1
d1382 6
a1387 3
	/* find the ip header.  we want to store the ip_src address */
	if (saanp)
		ip = (struct ip *)(mtod(m, char *) + sizeof(struct ether_header));
d1394 2
a1395 2
	for(i = 0; i < sc->an_nextitem; i++)
		if (!bcmp(eh->ether_shost , sc->an_sigcache[i].macsrc, 6))
d1397 2
a1398 1
			 * so we already have this entry, update the data
d1401 2
d1407 1
a1407 1
	if (i < sc->an_nextitem )
d1409 1
a1409 1

d1414 1
a1414 1
	else {
d1429 1
a1429 1
			if (wrapindex == MAXANCACHE)
d1431 1
d1451 1
a1451 1
	if (saanp)
d1453 1
d1457 2
@


1.15.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.15.4.2 2001/07/04 10:40:37 niklas Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/an/if_an.c,v 1.21 2001/09/10 02:05:09 brooks Exp $
a164 2
int an_media_change	__P((struct ifnet *));
void an_media_status	__P((struct ifnet *, struct ifmediareq *));
d240 1
a258 25
	ifmedia_init(&sc->an_ifmedia, 0, an_media_change, an_media_status);
#define	ADD(m, c)	ifmedia_add(&sc->an_ifmedia, (m), (c), NULL)
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS1, 0, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS2, 0, 0), 0);
	if (sc->an_caps.an_rates[2] == AN_RATE_5_5MBPS) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5,
		    IFM_IEEE80211_ADHOC, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS5, 0, 0), 0);
	}
	if (sc->an_caps.an_rates[3] == AN_RATE_11MBPS) {
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11,
		    IFM_IEEE80211_ADHOC, 0), 0);
		ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_IEEE80211_DS11, 0, 0), 0);
	}
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
	    IFM_IEEE80211_ADHOC, 0), 0);
	ADD(IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, 0, 0), 0);
#undef ADD
	ifmedia_set(&sc->an_ifmedia, IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO,
	    0, 0));

d587 1
a587 1
	if (ltv->an_len < 4 || ltv->an_type == 0)
a1020 4
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->an_ifmedia, command);
		break;
a1496 83

int
an_media_change(ifp)
	struct ifnet		*ifp;
{
	struct an_softc *sc = ifp->if_softc;
	int otype = sc->an_config.an_opmode;
	int orate = sc->an_tx_rate;

	if ((sc->an_ifmedia.ifm_cur->ifm_media & IFM_IEEE80211_ADHOC) != 0)
		sc->an_config.an_opmode = AN_OPMODE_IBSS_ADHOC;
	else
		sc->an_config.an_opmode = AN_OPMODE_INFRASTRUCTURE_STATION;

	switch (IFM_SUBTYPE(sc->an_ifmedia.ifm_cur->ifm_media)) {
	case IFM_IEEE80211_DS1:
		sc->an_tx_rate = AN_RATE_1MBPS;
		break;
	case IFM_IEEE80211_DS2:
		sc->an_tx_rate = AN_RATE_2MBPS;
		break;
	case IFM_IEEE80211_DS5:
		sc->an_tx_rate = AN_RATE_5_5MBPS;
		break;
	case IFM_IEEE80211_DS11:
		sc->an_tx_rate = AN_RATE_11MBPS;
		break;
	case IFM_AUTO:
		sc->an_tx_rate = 0;
		break;
	}

	if (otype != sc->an_config.an_opmode ||
	    orate != sc->an_tx_rate)
		an_init(sc);

	return(0);
}

void
an_media_status(ifp, imr)
	struct ifnet		*ifp;
	struct ifmediareq	*imr;
{
	struct an_ltv_status	status;
	struct an_softc		*sc = ifp->if_softc;

	status.an_len = sizeof(status);
	status.an_type = AN_RID_STATUS;
	if (an_read_record(sc, (struct an_ltv_gen *)&status)) {
		/* If the status read fails, just lie. */
		imr->ifm_active = sc->an_ifmedia.ifm_cur->ifm_media;
		imr->ifm_status = IFM_AVALID|IFM_ACTIVE;
	}

	if (sc->an_tx_rate == 0) {
		imr->ifm_active = IFM_IEEE80211|IFM_AUTO;
		if (sc->an_config.an_opmode == AN_OPMODE_IBSS_ADHOC)
			imr->ifm_active |= IFM_IEEE80211_ADHOC;
		switch (status.an_current_tx_rate) {
		case AN_RATE_1MBPS:
			imr->ifm_active |= IFM_IEEE80211_DS1;
			break;
		case AN_RATE_2MBPS:
			imr->ifm_active |= IFM_IEEE80211_DS2;
			break;
		case AN_RATE_5_5MBPS:
			imr->ifm_active |= IFM_IEEE80211_DS5;
			break;
		case AN_RATE_11MBPS:
			imr->ifm_active |= IFM_IEEE80211_DS11;
			break;
		}
	} else {
		imr->ifm_active = sc->an_ifmedia.ifm_cur->ifm_media;
	}

	imr->ifm_status = IFM_AVALID;
	if (sc->an_config.an_opmode == AN_OPMODE_IBSS_ADHOC)
		imr->ifm_status |= IFM_ACTIVE;
	else if (status.an_opmode & AN_STATUS_OPMODE_ASSOCIATED)
		imr->ifm_status |= IFM_ACTIVE;
}
@


1.15.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a611 1
	u_int16_t	ltv_data_length;
d631 2
a632 2
	 * Read the length to make sure it
	 * matches what we expect (this verifies that we have enough
d636 1
a636 8

	/*
	 * Work out record's data length, which is struct length - type word
	 * as we have just read the length.
	 */
	ltv_data_length = ltv->an_len - sizeof(u_int16_t);

	if (len > ltv_data_length) {
d639 1
a639 1
		    ltv_data_length, len);
d643 2
d647 1
a647 1
	for (i = 0; i < (len - 1) >> 1; i++)
@


1.15.4.5
log
@Merge in -current from about a week ago
@
text
@d141 20
a160 20
void an_reset(struct an_softc *);
int an_ioctl(struct ifnet *, u_long, caddr_t);
int an_init_tx_ring(struct an_softc *);
void an_start(struct ifnet *);
void an_watchdog(struct ifnet *);
void an_rxeof(struct an_softc *);
void an_txeof(struct an_softc *, int);

void an_promisc(struct an_softc *, int);
int an_cmd(struct an_softc *, int, int);
int an_read_record(struct an_softc *, struct an_ltv_gen *);
int an_write_record(struct an_softc *, struct an_ltv_gen *);
int an_read_data(struct an_softc *, int,
					int, caddr_t, int);
int an_write_data(struct an_softc *, int,
					int, caddr_t, int);
int an_seek(struct an_softc *, int, int, int);
int an_alloc_nicmem(struct an_softc *, int, int *);
void an_stats_update(void *);
void an_setdef(struct an_softc *, struct an_req *);
d162 2
a163 2
void an_cache_store(struct an_softc *, struct ether_header *,
					struct mbuf *, unsigned short);
d165 2
a166 2
int an_media_change(struct ifnet *);
void an_media_status(struct ifnet *, struct ifmediareq *);
a241 1
	IFQ_SET_READY(&ifp->if_snd);
d521 1
a521 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
a1239 1
	int			pkts = 0;
d1256 1
a1256 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
a1259 1
		pkts++;
a1303 2
	if (pkts == 0)
		return;
@


1.15.4.6
log
@Sync the SMP branch with 3.3
@
text
@d179 1
a179 1
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;
d230 1
a230 1
	   (char *)&sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
d232 1
a232 1
	printf(": address %6s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d293 1
a293 1
	BPFATTACH(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
d318 1
a318 1
	ifp = &sc->sc_arpcom.ac_if;
d403 1
a403 1
	ifp = &sc->sc_arpcom.ac_if;
d440 1
a440 1
	ifp = &sc->sc_arpcom.ac_if;
d475 1
a475 1
	ifp = &sc->sc_arpcom.ac_if;
d882 2
d889 1
d891 1
a891 1
	ifp = &sc->sc_arpcom.ac_if;
d896 4
a899 3
		bcopy((char *)&cfg->an_macaddr,
		    (char *)&sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
		bcopy((char *)&cfg->an_macaddr, LLADDR(ifp->if_sadl),
d901 1
d1014 1
a1014 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
d1026 1
a1026 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d1138 1
a1138 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d1163 1
a1163 1
	bcopy((char *)&sc->sc_arpcom.ac_enaddr,
d1331 1
a1331 1
	ifp = &sc->sc_arpcom.ac_if;
@


1.15.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d127 1
d245 2
a246 2
	strlcpy(sc->an_config.an_nodename, AN_DEFAULT_NODENAME,
	    sizeof(sc->an_config.an_nodename));
d249 3
a251 3
	strlcpy(sc->an_ssidlist.an_ssid1, AN_DEFAULT_NETNAME,
	    sizeof(sc->an_ssidlist.an_ssid1));
	sc->an_ssidlist.an_ssid1_len = strlen(sc->an_ssidlist.an_ssid1);
d611 1
a611 2
	u_int16_t	*ptr, len, rlen, ltv_data_length;
	volatile u_int16_t v;
d613 1
d637 1
a637 1
	rlen = len = CSR_READ_2(sc, AN_DATA1);
d645 6
a650 2
	if (rlen > ltv_data_length)
		rlen = ltv_data_length;
a652 1
	len -= 2; rlen -= 2;	/* skip the type */
d654 2
a655 6
	for (i = 0; (rlen - i) > 1; i += 2)
		*ptr++ = CSR_READ_2(sc, AN_DATA1);
	if (rlen - i == 1)
		*(u_int8_t *)ptr = CSR_READ_1(sc, AN_DATA1);
	for (; i < len; i++)
		v = CSR_READ_1(sc, AN_DATA1);
a659 1
	case AN_RID_ACTUALCFG:
a720 1
	case AN_RID_ACTUALCFG:
d1064 1
a1064 1
			error = suser(p, 0);
d1088 1
a1088 1
		error = suser(p, 0);
d1285 1
a1285 1
		 * If there's a BPF listener, bounce a copy of
@


1.14
log
@Avoid resetting the interface when not needed; allows temporary WEP keys
to work.  ALso optimize some interactions with the card.

Fixes rest of PR 1754; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.13 2001/02/27 06:48:28 tholo Exp $	*/
d223 1
a223 1
	printf(": address: %6s\n", ether_sprintf(sc->arpcom.ac_enaddr));
@


1.13
log
@Always fully reset the card on an_init()
Call an_init() when setting and clearing promisc; makes transmitter work
after turning off promiscuous mode
Identify RID in an_read_record() on failure
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.12 2001/02/26 06:19:33 tholo Exp $	*/
d265 1
d507 7
a513 1
	int i;
a531 15
/* printf("<<cmd %x,%d>>", cmd, i); */
#if 0
	DELAY(100);
	for (i = AN_TIMEOUT; i--; DELAY(100)) {
		int s = CSR_READ_2(sc, AN_STATUS);
		CSR_READ_2(sc, AN_RESP0);
		CSR_READ_2(sc, AN_RESP1);
		CSR_READ_2(sc, AN_RESP2);
		if ((s & AN_STAT_CMD_CODE) == (cmd & AN_STAT_CMD_CODE))
			break;
	}
/*printf("<<resp %d, %x>>", i, s);*/
#endif
	/* Ack the command */
	CSR_WRITE_2(sc, AN_EVENT_ACK, AN_EV_CMD);
d533 3
a536 1
/*printf("busy");*/
d540 3
d546 3
d958 1
a1057 2

	an_reset(sc);
@


1.12
log
@Allow configuration of WEP.  From FreeBSD; ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.11 2001/02/20 19:39:38 mickey Exp $	*/
d594 2
a595 1
		printf("%s: RID access failed\n", sc->sc_dev.dv_xname);
d601 2
a602 1
		printf("%s: seek to record failed\n", sc->sc_dev.dv_xname);
d613 3
a615 2
		printf("%s: record length mismatch -- expected %d, got %d\n",
		    sc->sc_dev.dv_xname, ltv->an_len, len);
d959 1
a959 3
			else {
				an_init(sc);
			}
d1058 2
d1064 4
a1067 7
		an_reset(sc);
		if (an_init_tx_ring(sc)) {
			printf("%s: tx buffer allocation failed\n",
			    sc->sc_dev.dv_xname);
			splx(s);
			return;
		}
@


1.11
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.10 2001/01/10 17:50:15 angelos Exp $	*/
d829 22
d956 3
a958 1
			an_init(sc);
@


1.10
log
@BSS mode by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.9 2000/06/20 20:35:14 todd Exp $	*/
d135 1
a135 1
#define BPFATTACH(if_bpf,if,dlt,sz) bpfattach((if_bpf), (if), (dlt), (sz))
@


1.9
log
@allow rx to work after tcpdump; ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.8 2000/06/20 19:39:36 todd Exp $	*/
d244 1
a244 1
	sc->an_config.an_opmode = AN_OPMODE_IBSS_ADHOC;
@


1.8
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.7 2000/06/20 03:24:21 aaron Exp $	*/
d933 2
a934 2
			} else
				an_init(sc);
@


1.7
log
@After bpf_mtap(), in promisc mode, don't drop packets that aren't for us here;
that is done in ether_input(); jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.6 2000/06/19 00:12:41 aaron Exp $	*/
d557 2
a558 1
void an_reset(sc)
d581 2
a582 1
int an_read_record(sc, ltv)
d629 2
a630 1
int an_write_record(sc, ltv)
d655 2
a656 1
int an_seek(sc, id, off, chan)
d692 2
a693 1
int an_read_data(sc, id, off, buf, len)
d720 2
a721 1
int an_write_data(sc, id, off, buf, len)
d752 2
a753 1
int an_alloc_nicmem(sc, len, id)
d847 2
a848 1
void an_promisc(sc, promisc)
d880 2
a881 1
int an_ioctl(ifp, command, data)
d1112 2
a1113 1
void an_start(ifp)
d1203 2
a1204 1
void an_stop(sc)
d1229 2
a1230 1
void an_watchdog(ifp)
@


1.6
log
@Insert missing splx(); me and roberto@@ns2.freenix.org.

Hacking at USENIX 2000 :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.5 2000/06/18 18:42:08 tholo Exp $	*/
d349 1
d351 1
a351 1
	if (ifp->if_bpf) {
d353 1
a353 7
		if (ifp->if_flags & IFF_PROMISC &&
		    (bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,
		    ETHER_ADDR_LEN) && (eh->ether_dhost[0] & 1) == 0)) {
			m_freem(m);
			return;
		}
	}
d1165 1
d1168 1
@


1.5
log
@Initialize the signal quality cache iff ANCACHE
Only allow superuser to clear the signal quality cache
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.4 2000/06/18 03:56:07 aaron Exp $	*/
d894 2
a895 1
	if (sc->an_gone)
d897 1
@


1.4
log
@Thou shalt not bequeath to mere mortals the ability to change the configuration
of an Aironet device.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.3 2000/06/18 03:26:51 aaron Exp $	*/
d248 3
d947 3
@


1.3
log
@Fix an off-by-one error that caused uvm_fault() whenever changing any an(4)
configuration options with ancontrol(8). Now USENIX attendees can use the
wireless setup :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.2 2000/04/06 04:01:49 mickey Exp $	*/
d100 1
d883 1
d965 3
@


1.2
log
@hide debugging printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.1 2000/04/03 01:01:58 mickey Exp $	*/
d800 1
a800 1
		ifa = ifnet_addrs[ifp->if_index - 1];
@


1.2.2.1
log
@Pull in patch from current:
Fix (aaron):
- Fix an off-by-one error that caused uvm_fault() whenever changing any an(4)
configuration options with ancontrol(8). Now USENIX attendees can use the
wireless setup :-)
- Thou shalt not bequeath to mere mortals the ability to change the
configuration of an Aironet device.
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.4 2000/06/18 03:56:07 aaron Exp $	*/
a99 1
#include <sys/proc.h>
d800 1
a800 1
		ifa = ifnet_addrs[ifp->if_index];
a881 1
	struct proc		*p = curproc;
a962 3
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			break;
@


1.2.2.2
log
@Pull in patch from current:
Fix (tholo):
Initialize the signal quality cache iff ANCACHE
Only allow superuser to clear the signal quality cache
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.5 2000/06/18 18:42:08 tholo Exp $	*/
a247 3
#ifdef ANCACHE
	sc->an_sigitems = sc->an_nextitem = 0;
#endif
a943 3
			error = suser(p->p_ucred, &p->p_acflag);
			if (error)
				break;
@


1.2.2.3
log
@Pull in patch from current:
Fix (aaron):
Insert missing splx(); me and roberto@@ns2.freenix.org.

Hacking at USENIX 2000 :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: an.c,v 1.2.2.2 2000/06/18 18:56:13 jason Exp $	*/
d894 1
a894 2
	if (sc->an_gone) {
		splx(s);
a895 1
	}
@


1.1
log
@aironet 802.11 ds driver from freebsd, isa and pci are missing
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d537 1
a537 1
printf("<<resp %d, %x>>", i, s);
d543 1
a543 1
printf("busy");
d563 1
a563 1
printf("ena ");
d565 1
a565 1
printf("rst ");
d567 1
a567 1
printf("nop ");
@

