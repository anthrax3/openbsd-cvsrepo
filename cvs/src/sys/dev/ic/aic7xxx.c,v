head	1.92;
access;
symbols
	OPENBSD_6_1_BASE:1.92
	OPENBSD_6_0:1.91.0.8
	OPENBSD_6_0_BASE:1.91
	OPENBSD_5_9:1.91.0.2
	OPENBSD_5_9_BASE:1.91
	OPENBSD_5_8:1.91.0.4
	OPENBSD_5_8_BASE:1.91
	OPENBSD_5_7:1.89.0.2
	OPENBSD_5_7_BASE:1.89
	OPENBSD_5_6:1.88.0.4
	OPENBSD_5_6_BASE:1.88
	OPENBSD_5_5:1.86.0.6
	OPENBSD_5_5_BASE:1.86
	OPENBSD_5_4:1.86.0.2
	OPENBSD_5_4_BASE:1.86
	OPENBSD_5_3:1.85.0.2
	OPENBSD_5_3_BASE:1.85
	OPENBSD_5_2:1.84.0.10
	OPENBSD_5_2_BASE:1.84
	OPENBSD_5_1_BASE:1.84
	OPENBSD_5_1:1.84.0.12
	OPENBSD_5_0:1.84.0.8
	OPENBSD_5_0_BASE:1.84
	OPENBSD_4_9:1.84.0.6
	OPENBSD_4_9_BASE:1.84
	OPENBSD_4_8:1.84.0.4
	OPENBSD_4_8_BASE:1.84
	OPENBSD_4_7:1.84.0.2
	OPENBSD_4_7_BASE:1.84
	OPENBSD_4_6:1.82.0.8
	OPENBSD_4_6_BASE:1.82
	OPENBSD_4_5:1.82.0.4
	OPENBSD_4_5_BASE:1.82
	OPENBSD_4_4:1.82.0.2
	OPENBSD_4_4_BASE:1.82
	OPENBSD_4_3:1.80.0.2
	OPENBSD_4_3_BASE:1.80
	OPENBSD_4_2:1.76.0.2
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.73.0.4
	OPENBSD_4_1_BASE:1.73
	OPENBSD_4_0:1.73.0.2
	OPENBSD_4_0_BASE:1.73
	OPENBSD_3_9:1.72.0.2
	OPENBSD_3_9_BASE:1.72
	OPENBSD_3_8:1.67.0.2
	OPENBSD_3_8_BASE:1.67
	OPENBSD_3_7:1.63.0.2
	OPENBSD_3_7_BASE:1.63
	OPENBSD_3_6:1.59.0.2
	OPENBSD_3_6_BASE:1.59
	SMP_SYNC_A:1.57
	SMP_SYNC_B:1.57
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.49.0.2
	OPENBSD_3_4_BASE:1.49
	UBC_SYNC_A:1.47
	OPENBSD_3_3:1.45.0.2
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.41.0.2
	OPENBSD_3_2_BASE:1.41
	OPENBSD_3_1:1.38.0.2
	OPENBSD_3_1_BASE:1.38
	UBC_SYNC_B:1.42
	UBC:1.34.0.2
	UBC_BASE:1.34
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	SMP:1.18.0.6
	SMP_BASE:1.18
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.4
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.17.0.6
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.17.0.4
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.92
date	2016.08.17.01.17.54;	author krw;	state Exp;
branches;
next	1.91;
commitid	ABXin5xH6wOo5rmV;

1.91
date	2015.07.17.21.42.49;	author krw;	state Exp;
branches;
next	1.90;
commitid	bEhopXwWgYXDvWRJ;

1.90
date	2015.05.07.01.19.00;	author jsg;	state Exp;
branches;
next	1.89;
commitid	lmqPJs50QQTPj7Jl;

1.89
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.88;
commitid	20ZyHa9gTJxHxhwD;

1.88
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.87;
commitid	JtO5uXxVcnZfhUkR;

1.87
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.86;
commitid	I19imNlAX05zJOED;

1.86
date	2013.04.20.20.23.09;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2012.12.05.23.20.16;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2010.03.14.14.37.01;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.18.19.57.09;	author halex;	state Exp;
branches;
next	1.82;

1.82
date	2008.07.29.21.18.53;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2008.06.25.18.21.48;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.79;

1.79
date	2007.11.25.16.40.04;	author jmc;	state Exp;
branches;
next	1.78;

1.78
date	2007.10.20.22.44.00;	author fgsch;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.07.17.58.39;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.26.21.53.16;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.14.01.37.49;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.02.02.20.36;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2006.07.30.14.21.14;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2006.02.06.17.29.10;	author jmc;	state Exp;
branches;
next	1.71;

1.71
date	2005.12.28.03.00.07;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2005.12.04.03.56.17;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2005.12.01.02.21.13;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2005.10.04.23.52.04;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2005.08.07.17.14.57;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2005.07.18.02.43.26;	author fgsch;	state Exp;
branches;
next	1.65;

1.65
date	2005.06.01.21.49.53;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2005.04.17.18.54.41;	author tom;	state Exp;
branches;
next	1.63;

1.63
date	2005.02.20.15.35.35;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2005.01.12.00.35.32;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2004.12.30.17.20.09;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2004.10.24.04.28.33;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2004.08.13.23.38.54;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2004.08.01.01.36.23;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.05.04.32.50;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.05.04.14.46;	author krw;	state dead;
branches;
next	1.55;

1.55
date	2004.02.22.16.06.26;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.08.00.38.08;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.17.14.40.55;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.24.22.45.45;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2003.10.21.18.58.48;	author jmc;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.29.19.28.15;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.12.22.47.02;	author fgsch;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.12.20.27.03;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.30.21.04.18;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.21.14.58.06;	author drahn;	state Exp;
branches;
next	1.44;

1.44
date	2003.01.05.22.41.35;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2002.12.09.00.45.37;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.10.09.23.43.10;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.05.05.41.03;	author smurph;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.28.00.34.54;	author smurph;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.26.00.56.10;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.19.21.07.25;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.16.04.36.33;	author smurph;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.15.10.57.01;	author ho;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.31.02.52.19;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.12.20.12.11;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.24.18.22.31;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.06.04.42.06;	author csapuntz;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.25.06.15.37;	author csapuntz;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.06.15.46.51;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.02.18.50.17;	author aaron;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.03.22.18.36;	author smurph;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.05.04.29.58;	author smurph;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.04.03.48.47;	author smurph;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.22.02.48.47;	author smurph;	state Exp;
branches;
next	1.18;

1.18
date	99.01.11.05.12.15;	author millert;	state Exp;
branches
	1.18.6.1;
next	1.17;

1.17
date	97.07.03.17.46.53;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.04.10.22.52.18;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.01.15.05.50.38;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.11.28.23.27.43;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	96.11.23.21.46.33;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	96.11.12.20.30.15;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.10.31.01.01.24;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.10.16.10.25.07;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.08.21.22.27.32;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.07.02.20.18.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.27.21.15.47;	author shawn;	state Exp;
branches;
next	1.6;

1.6
date	96.05.26.00.26.56;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.05.12.42.29;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.21.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.18.23.47.15;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.15.01.39.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.30;	author deraadt;	state Exp;
branches;
next	;

1.18.6.1
date	2000.03.24.09.09.08;	author niklas;	state Exp;
branches;
next	1.18.6.2;

1.18.6.2
date	2001.05.14.22.23.24;	author niklas;	state Exp;
branches;
next	1.18.6.3;

1.18.6.3
date	2001.07.04.10.40.27;	author niklas;	state Exp;
branches;
next	1.18.6.4;

1.18.6.4
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.18.6.5;

1.18.6.5
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.18.6.6;

1.18.6.6
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.18.6.7;

1.18.6.7
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.18.6.8;

1.18.6.8
date	2002.03.28.11.50.59;	author niklas;	state Exp;
branches;
next	1.18.6.9;

1.18.6.9
date	2003.03.28.00.38.11;	author niklas;	state Exp;
branches;
next	1.18.6.10;

1.18.6.10
date	2003.05.13.19.34.57;	author ho;	state Exp;
branches;
next	1.18.6.11;

1.18.6.11
date	2004.02.19.10.56.15;	author niklas;	state Exp;
branches;
next	1.18.6.12;

1.18.6.12
date	2004.06.05.23.12.39;	author niklas;	state Exp;
branches;
next	;

1.34.2.1
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2003.05.19.21.54.23;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.92
log
@Move to iopool. No voluntary testers after several years of requests so now
everybody gets to test!
@
text
@/*	$OpenBSD: aic7xxx.c,v 1.91 2015/07/17 21:42:49 krw Exp $	*/
/*	$NetBSD: aic7xxx.c,v 1.108 2003/11/02 11:07:44 wiz Exp $	*/

/*
 * Core routines and tables shareable across OS platforms.
 *
 * Copyright (c) 1994-2002 Justin T. Gibbs.
 * Copyright (c) 2000-2002 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $Id: aic7xxx.c,v 1.91 2015/07/17 21:42:49 krw Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
 */

#include <dev/ic/aic7xxx_openbsd.h>
#ifdef SMALL_KERNEL
#define	IO_EXPAND
#endif
#include <dev/ic/aic7xxx_inline.h>
#include <dev/microcode/aic7xxx/aicasm_insformat.h>

/****************************** Softc Data ************************************/
struct ahc_softc_tailq ahc_tailq = TAILQ_HEAD_INITIALIZER(ahc_tailq);

/***************************** Lookup Tables **********************************/
char *ahc_chip_names[] =
{
	"NONE",
	"aic7770",
	"aic7850",
	"aic7855",
	"aic7859",
	"aic7860",
	"aic7870",
	"aic7880",
	"aic7895",
	"aic7895C",
	"aic7890/91",
	"aic7896/97",
	"aic7892",
	"aic7899"
};

/*
 * Hardware error codes.
 */
struct ahc_hard_error_entry {
        uint8_t errno;
	char *errmesg;
};

#if !defined(SMALL_KERNEL)
static struct ahc_hard_error_entry ahc_hard_errors[] = {
	{ ILLHADDR,	"Illegal Host Access" },
	{ ILLSADDR,	"Illegal Sequencer Address referrenced" },
	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
	{ SQPARERR,	"Sequencer Parity Error" },
	{ DPARERR,	"Data-path Parity Error" },
	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
	{ PCIERRSTAT,	"PCI Error detected" },
	{ CIOPARERR,	"CIOBUS Parity Error" },
};
static const u_int num_errors = NUM_ELEMENTS(ahc_hard_errors);
#endif /* !defined(SMALL_KERNEL) */

static struct ahc_phase_table_entry ahc_phase_table[] =
{
	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
	{ P_DATAOUT_DT,	MSG_NOOP,		"in DT Data-out phase"	},
	{ P_DATAIN_DT,	MSG_INITIATOR_DET_ERR,	"in DT Data-in phase"	},
	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
	{ 0,		MSG_NOOP,		"in unknown phase"	}
};

/*
 * In most cases we only wish to itterate over real phases, so
 * exclude the last element from the count.
 */
static const u_int num_phases = NUM_ELEMENTS(ahc_phase_table) - 1;

/*
 * Valid SCSIRATE values.  (p. 3-17)
 * Provides a mapping of transfer periods in ns to the proper value to
 * stick in the scsixfer reg.
 */
static struct ahc_syncrate ahc_syncrates[] =
{
      /* ultra2    fast/ultra  period     rate */
	{ 0x42,      0x000,      9,      "80.0" },
	{ 0x03,      0x000,     10,      "40.0" },
	{ 0x04,      0x000,     11,      "33.0" },
	{ 0x05,      0x100,     12,      "20.0" },
	{ 0x06,      0x110,     15,      "16.0" },
	{ 0x07,      0x120,     18,      "13.4" },
	{ 0x08,      0x000,     25,      "10.0" },
	{ 0x19,      0x010,     31,      "8.0"  },
	{ 0x1a,      0x020,     37,      "6.67" },
	{ 0x1b,      0x030,     43,      "5.7"  },
	{ 0x1c,      0x040,     50,      "5.0"  },
	{ 0x00,      0x050,     56,      "4.4"  },
	{ 0x00,      0x060,     62,      "4.0"  },
	{ 0x00,      0x070,     68,      "3.6"  },
	{ 0x00,      0x000,      0,      NULL   }
};

/* Our Sequencer Program */
#include <dev/microcode/aic7xxx/aic7xxx_seq.h>

/**************************** Function Declarations ***************************/
static void		ahc_force_renegotiation(struct ahc_softc *ahc,
						struct ahc_devinfo *devinfo);
static struct ahc_tmode_tstate*
			ahc_alloc_tstate(struct ahc_softc *ahc,
					 u_int scsi_id, char channel);
#ifdef AHC_TARGET_MODE
static void		ahc_free_tstate(struct ahc_softc *ahc,
					u_int scsi_id, char channel, int force);
#endif
static struct ahc_syncrate*
			ahc_devlimited_syncrate(struct ahc_softc *ahc,
					        struct ahc_initiator_tinfo *,
						u_int *period,
						u_int *ppr_options,
						role_t role);
static void		ahc_update_pending_scbs(struct ahc_softc *ahc);
static void		ahc_fetch_devinfo(struct ahc_softc *ahc,
					  struct ahc_devinfo *devinfo);
static void		ahc_assert_atn(struct ahc_softc *ahc);
static void		ahc_setup_initiator_msgout(struct ahc_softc *ahc,
						   struct ahc_devinfo *devinfo,
						   struct scb *scb);
static void		ahc_build_transfer_msg(struct ahc_softc *ahc,
					       struct ahc_devinfo *devinfo);
static void		ahc_construct_sdtr(struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo,
					   u_int period, u_int offset);
static void		ahc_construct_wdtr(struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo,
					   u_int bus_width);
static void		ahc_construct_ppr(struct ahc_softc *ahc,
					  struct ahc_devinfo *devinfo,
					  u_int period, u_int offset,
					  u_int bus_width, u_int ppr_options);
static void		ahc_clear_msg_state(struct ahc_softc *ahc);
static void		ahc_handle_proto_violation(struct ahc_softc *ahc);
static void		ahc_handle_message_phase(struct ahc_softc *ahc);
typedef enum {
	AHCMSG_1B,
	AHCMSG_2B,
	AHCMSG_EXT
} ahc_msgtype;
static int		ahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type,
				     u_int msgval, int full);
static int		ahc_parse_msg(struct ahc_softc *ahc,
				      struct ahc_devinfo *devinfo);
static int		ahc_handle_msg_reject(struct ahc_softc *ahc,
					      struct ahc_devinfo *devinfo);
static void		ahc_handle_ign_wide_residue(struct ahc_softc *ahc,
						struct ahc_devinfo *devinfo);
static void		ahc_reinitialize_dataptrs(struct ahc_softc *ahc);
static void		ahc_handle_devreset(struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo,
					    cam_status status, char *message,
					    int verbose_level);
#ifdef AHC_TARGET_MODE
static void		ahc_setup_target_msgin(struct ahc_softc *ahc,
					       struct ahc_devinfo *devinfo,
					       struct scb *scb);
#endif

//static bus_dmamap_callback_t	ahc_dmamap_cb;
static void			ahc_build_free_scb_list(struct ahc_softc *ahc);
static int			ahc_init_scbdata(struct ahc_softc *ahc);
static void			ahc_fini_scbdata(struct ahc_softc *ahc);
static void		ahc_qinfifo_requeue(struct ahc_softc *ahc,
					    struct scb *prev_scb,
					    struct scb *scb);
static int		ahc_qinfifo_count(struct ahc_softc *ahc);
static u_int		ahc_rem_scb_from_disc_list(struct ahc_softc *ahc,
						   u_int prev, u_int scbptr);
static void		ahc_add_curscb_to_free_list(struct ahc_softc *ahc);
static u_int		ahc_rem_wscb(struct ahc_softc *ahc,
				     u_int scbpos, u_int prev);
static void		ahc_reset_current_bus(struct ahc_softc *ahc);
#ifdef AHC_DUMP_SEQ
static void		ahc_dumpseq(struct ahc_softc *ahc);
#endif
static int		ahc_loadseq(struct ahc_softc *ahc);
static int		ahc_check_patch(struct ahc_softc *ahc,
					const struct patch **start_patch,
					u_int start_instr, u_int *skip_addr);
static void		ahc_download_instr(struct ahc_softc *ahc,
					   u_int instrptr, uint8_t *dconsts);
#ifdef AHC_TARGET_MODE
static void		ahc_queue_lstate_event(struct ahc_softc *ahc,
					       struct ahc_tmode_lstate *lstate,
					       u_int initiator_id,
					       u_int event_type,
					       u_int event_arg);
static void		ahc_update_scsiid(struct ahc_softc *ahc,
					  u_int targid_mask);
static int		ahc_handle_target_cmd(struct ahc_softc *ahc,
					      struct target_cmd *cmd);
#endif

/************************** Added for porting to NetBSD ***********************/
static int ahc_createdmamem(bus_dma_tag_t tag,
			    int size,
			    int flags,
			    bus_dmamap_t *mapp,
			    caddr_t *vaddr,
			    bus_addr_t *baddr,
			    bus_dma_segment_t *seg,
			    int *nseg,
			    const char *myname, const char *what);
static void ahc_freedmamem(bus_dma_tag_t tag,
			   int size,
			   bus_dmamap_t map,
			   caddr_t vaddr,
			   bus_dma_segment_t *seg,
			   int nseg);

/************************* Sequencer Execution Control ************************/
/*
 * Restart the sequencer program from address zero
 */
void
ahc_restart(struct ahc_softc *ahc)
{

	ahc_pause(ahc);

	/* No more pending messages. */
	ahc_clear_msg_state(ahc);

	ahc_outb(ahc, SCSISIGO, 0);		/* De-assert BSY */
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);	/* No message to send */
	ahc_outb(ahc, SXFRCTL1, ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);
	ahc_outb(ahc, LASTPHASE, P_BUSFREE);
	ahc_outb(ahc, SAVED_SCSIID, 0xFF);
	ahc_outb(ahc, SAVED_LUN, 0xFF);

	/*
	 * Ensure that the sequencer's idea of TQINPOS
	 * matches our own.  The sequencer increments TQINPOS
	 * only after it sees a DMA complete and a reset could
	 * occur before the increment leaving the kernel to believe
	 * the command arrived but the sequencer to not.
	 */
	ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);

	/* Always allow reselection */
	ahc_outb(ahc, SCSISEQ,
		 ahc_inb(ahc, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Ensure that no DMA operations are in progress */
		ahc_outb(ahc, CCSCBCNT, 0);
		ahc_outb(ahc, CCSGCTL, 0);
		ahc_outb(ahc, CCSCBCTL, 0);
	}
	/*
	 * If we were in the process of DMA'ing SCB data into
	 * an SCB, replace that SCB on the free list.  This prevents
	 * an SCB leak.
	 */
	if ((ahc_inb(ahc, SEQ_FLAGS2) & SCB_DMA) != 0) {
		ahc_add_curscb_to_free_list(ahc);
		ahc_outb(ahc, SEQ_FLAGS2,
			 ahc_inb(ahc, SEQ_FLAGS2) & ~SCB_DMA);
	}

	/*
	 * Clear any pending sequencer interrupt.  It is no
	 * longer relevant since we're resetting the Program
	 * Counter.
	 */
	ahc_outb(ahc, CLRINT, CLRSEQINT);

	ahc_outb(ahc, MWI_RESIDUAL, 0);
	ahc_outb(ahc, SEQCTL, ahc->seqctl);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);

	ahc_unpause(ahc);
}

/************************* Input/Output Queues ********************************/
void
ahc_run_qoutfifo(struct ahc_softc *ahc)
{
	struct scb *scb;
	u_int  scb_index;

	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);
	while (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {

		scb_index = ahc->qoutfifo[ahc->qoutfifonext];
#ifdef __sgi__
		if ((ahc->qoutfifonext & 0x1f) == 0x1f) {
			u_int modnext;
			u_int32_t *nextp;

			/*
			 * Clear 32 bytes of QOUTFIFO at a time
			 * so that we don't clobber an incoming
			 * byte DMA to the array on architectures
			 * non coherent caches.
			 */
			modnext = ahc->qoutfifonext & ~0x1f;
			nextp = (uint32_t *)(&ahc->qoutfifo[modnext]);
			*nextp++ = 0xFFFFFFFFUL;
			*nextp++ = 0xFFFFFFFFUL;
			*nextp++ = 0xFFFFFFFFUL;
			*nextp++ = 0xFFFFFFFFUL;
			*nextp++ = 0xFFFFFFFFUL;
			*nextp++ = 0xFFFFFFFFUL;
			*nextp++ = 0xFFFFFFFFUL;
			*nextp++ = 0xFFFFFFFFUL;
			ahc_dmamap_sync(ahc, ahc->parent_dmat /*shared_data_dmat*/,
					ahc->shared_data_dmamap,
					/*offset*/modnext, /*len*/32,
					BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
		}
#else
		if ((ahc->qoutfifonext & 0x03) == 0x03) {
			u_int modnext;

			/*
			 * Clear 32bits of QOUTFIFO at a time
			 * so that we don't clobber an incoming
			 * byte DMA to the array on architectures
			 * that only support 32bit load and store
			 * operations.
			 */
			modnext = ahc->qoutfifonext & ~0x3;
			*((uint32_t *)(&ahc->qoutfifo[modnext])) = 0xFFFFFFFFUL;
			ahc_dmamap_sync(ahc, ahc->parent_dmat /*shared_data_dmat*/,
					ahc->shared_data_dmamap,
					/*offset*/modnext, /*len*/4,
					BUS_DMASYNC_PREREAD);
		}
#endif
		ahc->qoutfifonext++;

		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("%s: WARNING no command for scb %d "
			       "(cmdcmplt)\nQOUTPOS = %d\n",
			       ahc_name(ahc), scb_index,
			       (ahc->qoutfifonext - 1) & 0xFF);
			continue;
		}

		/*
		 * Save off the residual
		 * if there is one.
		 */
		ahc_update_residual(ahc, scb);
		ahc_done(ahc, scb);
	}
}

void
ahc_run_untagged_queues(struct ahc_softc *ahc)
{
	int i;

	for (i = 0; i < 16; i++)
		ahc_run_untagged_queue(ahc, &ahc->untagged_queues[i]);
}

void
ahc_run_untagged_queue(struct ahc_softc *ahc, struct scb_tailq *queue)
{
	struct scb *scb;

	if (ahc->untagged_queue_lock != 0)
		return;

	if ((scb = TAILQ_FIRST(queue)) != NULL
	    && (scb->flags & SCB_ACTIVE) == 0) {
		scb->flags |= SCB_ACTIVE;
		ahc_queue_scb(ahc, scb);
	}
}

/************************* Interrupt Handling *********************************/
void
ahc_handle_brkadrint(struct ahc_softc *ahc)
{
	/*
	 * We upset the sequencer :-(
	 * Lookup the error message
	 */
#ifndef SMALL_KERNEL
	int i;
	int error;

	error = ahc_inb(ahc, ERROR);
	for (i = 0; error != 1 && i < num_errors; i++)
		error >>= 1;
	if (i >= num_errors)
		panic("invalid error code");
	printf("%s: brkadrint, %s at seqaddr = 0x%x\n",
	       ahc_name(ahc), ahc_hard_errors[i].errmesg,
	       ahc_inb(ahc, SEQADDR0) |
	       (ahc_inb(ahc, SEQADDR1) << 8));

	ahc_dump_card_state(ahc);
#endif

	/* Tell everyone that this HBA is no longer available */
	ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,
		       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,
		       CAM_NO_HBA);

	/* Disable all interrupt sources by resetting the controller */
	ahc_shutdown(ahc);
}

void
ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat)
{
	struct scb *scb;
	struct ahc_devinfo devinfo;
	u_int scb_index;

	ahc_fetch_devinfo(ahc, &devinfo);

	/*
	 * Clear the upper byte that holds SEQINT status
	 * codes and clear the SEQINT bit. We will unpause
	 * the sequencer, if appropriate, after servicing
	 * the request.
	 */
	ahc_outb(ahc, CLRINT, CLRSEQINT);
	switch (intstat & SEQINT_MASK) {
	case BAD_STATUS:
	{
		struct hardware_scb *hscb;

		/*
		 * Set the default return value to 0 (don't
		 * send sense).  The sense code will change
		 * this if needed.
		 */
		ahc_outb(ahc, RETURN_1, 0);

		/*
		 * The sequencer will notify us when a command
		 * has an error that would be of interest to
		 * the kernel.  This allows us to leave the sequencer
		 * running in the common case of command completes
		 * without error.  The sequencer will already have
		 * DMA'd the SCB back up to us, so we can reference
		 * the in kernel copy directly.
		 */
		scb_index = ahc_inb(ahc, SCB_TAG);
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			ahc_print_devinfo(ahc, &devinfo);
			printf("ahc_intr - referenced scb "
			       "not valid during seqint 0x%x scb(%d)\n",
			       intstat, scb_index);
			ahc_dump_card_state(ahc);
			panic("for safety");
			goto unpause;
		}

		hscb = scb->hscb;

		/* Don't want to clobber the original sense code */
		if ((scb->flags & SCB_SENSE) != 0) {
			/*
			 * Clear the SCB_SENSE Flag and have
			 * the sequencer do a normal command
			 * complete.
			 */
			scb->flags &= ~SCB_SENSE;
			ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
			break;
		}
		ahc_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
		/* Freeze the queue until the client sees the error. */
		ahc_freeze_devq(ahc, scb);
		ahc_freeze_scb(scb);
		ahc_set_scsi_status(scb, hscb->shared_data.status.scsi_status);
		switch (hscb->shared_data.status.scsi_status) {
		case SCSI_STATUS_OK:
			printf("%s: Interrupted for status of 0 (?)\n",
			       ahc_name(ahc));
			break;
		case SCSI_STATUS_CMD_TERMINATED:
		case SCSI_STATUS_CHECK_COND:
		{
			struct ahc_dma_seg *sg;
			struct scsi_sense *sc;
			struct ahc_initiator_tinfo *targ_info;
			struct ahc_tmode_tstate *tstate;
			struct ahc_transinfo *tinfo;
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOW_SENSE) {
				ahc_print_path(ahc, scb);
				printf("SCB %d: requests Check Status\n",
				       scb->hscb->tag);
			}
#endif

			if (ahc_perform_autosense(scb) == 0)
				break;

			targ_info = ahc_fetch_transinfo(ahc,
							devinfo.channel,
							devinfo.our_scsiid,
							devinfo.target,
							&tstate);
			tinfo = &targ_info->curr;
			sg = scb->sg_list;
			sc = (struct scsi_sense *)(&hscb->shared_data.cdb);
			/*
			 * Save off the residual if there is one.
			 */
			ahc_update_residual(ahc, scb);
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOW_SENSE) {
				ahc_print_path(ahc, scb);
				printf("Sending Sense\n");
			}
#endif
			sg->addr = ahc_get_sense_bufaddr(ahc, scb);
			sg->len = ahc_get_sense_bufsize(ahc, scb);
			sg->len |= AHC_DMA_LAST_SEG;

			/* Fixup byte order */
			sg->addr = aic_htole32(sg->addr);
			sg->len = aic_htole32(sg->len);

			sc->opcode = REQUEST_SENSE;
			sc->byte2 = 0;
			if (tinfo->protocol_version <= SCSI_REV_2
			    && SCB_GET_LUN(scb) < 8)
				sc->byte2 = SCB_GET_LUN(scb) << 5;
			sc->unused[0] = 0;
			sc->unused[1] = 0;
			sc->length = sg->len;
			sc->control = 0;

			/*
			 * We can't allow the target to disconnect.
			 * This will be an untagged transaction and
			 * having the target disconnect will make this
			 * transaction indistinguishable from outstanding
			 * tagged transactions.
			 */
			hscb->control = 0;

			/*
			 * This request sense could be because the
			 * the device lost power or in some other
			 * way has lost our transfer negotiations.
			 * Renegotiate if appropriate.  Unit attention
			 * errors will be reported before any data
			 * phases occur.
			 */
			if (ahc_get_residual(scb)
			    == ahc_get_transfer_length(scb)) {
				ahc_update_neg_request(ahc, &devinfo,
						       tstate, targ_info,
						       AHC_NEG_IF_NON_ASYNC);
			}
			if (tstate->auto_negotiate & devinfo.target_mask) {
				hscb->control |= MK_MESSAGE;
				scb->flags &= ~SCB_NEGOTIATE;
				scb->flags |= SCB_AUTO_NEGOTIATE;
			}
			hscb->cdb_len = sizeof(*sc);
			hscb->dataptr = sg->addr;
			hscb->datacnt = sg->len;
			hscb->sgptr = scb->sg_list_phys | SG_FULL_RESID;
			hscb->sgptr = aic_htole32(hscb->sgptr);
#ifdef __OpenBSD__
			bus_dmamap_sync(ahc->parent_dmat,
			    ahc->scb_data->sense_dmamap,
			    (scb - ahc->scb_data->scbarray) *
			    sizeof(struct scsi_sense_data),
			    sizeof(struct scsi_sense_data),
			    BUS_DMASYNC_PREREAD);
			bus_dmamap_sync(ahc->parent_dmat,
			    scb->sg_map->sg_dmamap,
			    0, scb->sg_map->sg_dmamap->dm_mapsize,
			    BUS_DMASYNC_PREWRITE);
			bus_dmamap_sync(ahc->parent_dmat,
			    ahc->scb_data->hscb_dmamap,
			    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
#endif
			scb->sg_count = 1;
			scb->flags |= SCB_SENSE;
			ahc_qinfifo_requeue_tail(ahc, scb);
			ahc_outb(ahc, RETURN_1, SEND_SENSE);
			/*
			 * Ensure we have enough time to actually
			 * retrieve the sense.
			 */
			ahc_scb_timer_reset(scb, 5 * 1000000);
			break;
		}
		default:
			break;
		}
		break;
	}
	case NO_MATCH:
	{
		/* Ensure we don't leave the selection hardware on */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));

		printf("%s:%c:%d: no active SCB for reconnecting "
		       "target - issuing BUS DEVICE RESET\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target);
		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
		       "ARG_1 == 0x%x ACCUM = 0x%x\n",
		       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),
		       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));
		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
		       "SINDEX == 0x%x\n",
		       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),
		       ahc_index_busy_tcl(ahc,
			    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),
				      ahc_inb(ahc, SAVED_LUN))),
		       ahc_inb(ahc, SINDEX));
		printf("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
		       "SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",
		       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),
		       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),
		       ahc_inb(ahc, SCB_CONTROL));
		printf("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",
		       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));
		printf("SXFRCTL0 == 0x%x\n", ahc_inb(ahc, SXFRCTL0));
		printf("SEQCTL == 0x%x\n", ahc_inb(ahc, SEQCTL));
		ahc_dump_card_state(ahc);
		ahc->msgout_buf[0] = MSG_BUS_DEV_RESET;
		ahc->msgout_len = 1;
		ahc->msgout_index = 0;
		ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		ahc_assert_atn(ahc);
		break;
	}
	case SEND_REJECT:
	{
		u_int rejbyte = ahc_inb(ahc, ACCUM);
		printf("%s:%c:%d: Warning - unknown message received from "
		       "target (0x%x).  Rejecting\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);
		break;
	}
	case PROTO_VIOLATION:
	{
		ahc_handle_proto_violation(ahc);
		break;
	}
	case IGN_WIDE_RES:
		ahc_handle_ign_wide_residue(ahc, &devinfo);
		break;
	case PDATA_REINIT:
		ahc_reinitialize_dataptrs(ahc);
		break;
	case BAD_PHASE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		printf("%s:%c:%d: unknown scsi bus phase %x, "
		       "lastphase = 0x%x.  Attempting to continue\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       lastphase, ahc_inb(ahc, SCSISIGI));
		break;
	}
	case MISSED_BUSFREE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		printf("%s:%c:%d: Missed busfree. "
		       "Lastphase = 0x%x, Curphase = 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       lastphase, ahc_inb(ahc, SCSISIGI));
		ahc_restart(ahc);
		return;
	}
	case HOST_MSG_LOOP:
	{
		/*
		 * The sequencer has encountered a message phase
		 * that requires host assistance for completion.
		 * While handling the message phase(s), we will be
		 * notified by the sequencer after each byte is
		 * transferred so we can track bus phase changes.
		 *
		 * If this is the first time we've seen a HOST_MSG_LOOP
		 * interrupt, initialize the state of the host message
		 * loop.
		 */
		if (ahc->msg_type == MSG_TYPE_NONE) {
			u_int bus_phase;

			bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			if (bus_phase != P_MESGIN
			 && bus_phase != P_MESGOUT) {
				printf("ahc_intr: HOST_MSG_LOOP bad "
				       "phase 0x%x\n",
				      bus_phase);
				/*
				 * Probably transitioned to bus free before
				 * we got here.  Just punt the message.
				 */
				ahc_clear_intstat(ahc);
				ahc_restart(ahc);
				return;
			}

			scb_index = ahc_inb(ahc, SCB_TAG);
			scb = ahc_lookup_scb(ahc, scb_index);
			if (devinfo.role == ROLE_INITIATOR) {
				if (scb == NULL)
					panic("HOST_MSG_LOOP with "
					      "invalid SCB %x\n", scb_index);

				if (bus_phase == P_MESGOUT)
					ahc_setup_initiator_msgout(ahc,
								   &devinfo,
								   scb);
				else {
					ahc->msg_type =
					    MSG_TYPE_INITIATOR_MSGIN;
					ahc->msgin_index = 0;
				}
			}
#ifdef AHC_TARGET_MODE
			else {
				if (bus_phase == P_MESGOUT) {
					ahc->msg_type =
					    MSG_TYPE_TARGET_MSGOUT;
					ahc->msgin_index = 0;
				}
				else
					ahc_setup_target_msgin(ahc,
							       &devinfo,
							       scb);
			}
#endif
		}

		ahc_handle_message_phase(ahc);
		break;
	}
	case PERR_DETECTED:
	{
		/*
		 * If we've cleared the parity error interrupt
		 * but the sequencer still believes that SCSIPERR
		 * is true, it must be that the parity error is
		 * for the currently presented byte on the bus,
		 * and we are not in a phase (data-in) where we will
		 * eventually ack this byte.  Ack the byte and
		 * throw it away in the hope that the target will
		 * take us to message out to deliver the appropriate
		 * error message.
		 */
		if ((intstat & SCSIINT) == 0
		 && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {

			if ((ahc->features & AHC_DT) == 0) {
				u_int curphase;

				/*
				 * The hardware will only let you ack bytes
				 * if the expected phase in SCSISIGO matches
				 * the current phase.  Make sure this is
				 * currently the case.
				 */
				curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
				ahc_outb(ahc, LASTPHASE, curphase);
				ahc_outb(ahc, SCSISIGO, curphase);
			}
			if ((ahc_inb(ahc, SCSISIGI) & (CDI|MSGI)) == 0) {
				int wait;

				/*
				 * In a data phase.  Faster to bitbucket
				 * the data than to individually ack each
				 * byte.  This is also the only strategy
				 * that will work with AUTOACK enabled.
				 */
				ahc_outb(ahc, SXFRCTL1,
					 ahc_inb(ahc, SXFRCTL1) | BITBUCKET);
				wait = 5000;
				while (--wait != 0) {
					if ((ahc_inb(ahc, SCSISIGI)
					  & (CDI|MSGI)) != 0)
						break;
					aic_delay(100);
				}
				ahc_outb(ahc, SXFRCTL1,
					 ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);
				if (wait == 0) {
					ahc_print_devinfo(ahc, &devinfo);
					printf("Unable to clear parity error.  "
					       "Resetting bus.\n");
					scb_index = ahc_inb(ahc, SCB_TAG);
					scb = ahc_lookup_scb(ahc, scb_index);
					if (scb != NULL)
						ahc_set_transaction_status(scb,
						    CAM_UNCOR_PARITY);
					ahc_reset_channel(ahc, devinfo.channel, 
							  /*init reset*/TRUE);
				}
			} else {
				ahc_inb(ahc, SCSIDATL);
			}
		}
		break;
	}
	case DATA_OVERRUN:
	{
		/*
		 * When the sequencer detects an overrun, it
		 * places the controller in "BITBUCKET" mode
		 * and allows the target to complete its transfer.
		 * Unfortunately, none of the counters get updated
		 * when the controller is in this mode, so we have
		 * no way of knowing how large the overrun was.
		 */
		u_int scbindex = ahc_inb(ahc, SCB_TAG);
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		u_int i;

		scb = ahc_lookup_scb(ahc, scbindex);
		for (i = 0; i < num_phases; i++) {
			if (lastphase == ahc_phase_table[i].phase)
				break;
		}
#ifdef AHC_DEBUG
		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
			ahc_print_path(ahc, scb);
			printf("data overrun detected %s."
			       "  Tag == 0x%x.\n",
			       ahc_phase_table[i].phasemsg,
			       scb->hscb->tag);
			ahc_print_path(ahc, scb);
			printf("%s seen Data Phase.  Length = %ld.  NumSGs = %d.\n",
			       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
			       ahc_get_transfer_length(scb), scb->sg_count);
			if (scb->sg_count > 0) {
				for (i = 0; i < scb->sg_count; i++) {

					printf("sg[%d] - Addr 0x%x%x : Length %d\n",
					       i,
					       (aic_le32toh(scb->sg_list[i].len) >> 24
						& SG_HIGH_ADDR_BITS),
					       aic_le32toh(scb->sg_list[i].addr),
					       aic_le32toh(scb->sg_list[i].len)
					       & AHC_SG_LEN_MASK);
				}
			}
		}
#endif
		/*
		 * Set this and it will take effect when the
		 * target does a command complete.
		 */
		ahc_freeze_devq(ahc, scb);
		if ((scb->flags & SCB_SENSE) == 0) {
			ahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);
		} else {
			scb->flags &= ~SCB_SENSE;
			ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
		}
		ahc_freeze_scb(scb);

		if ((ahc->features & AHC_ULTRA2) != 0) {
			/*
			 * Clear the channel in case we return
			 * to data phase later.
			 */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);
		}
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			u_int dscommand1;

			/* Ensure HHADDR is 0 for future DMA operations. */
			dscommand1 = ahc_inb(ahc, DSCOMMAND1);
			ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
			ahc_outb(ahc, HADDR, 0);
			ahc_outb(ahc, DSCOMMAND1, dscommand1);
		}
		break;
	}
	case MKMSG_FAILED:
	{
		u_int scbindex;

		printf("%s:%c:%d:%d: Attempt to issue message failed\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       devinfo.lun);
		scbindex = ahc_inb(ahc, SCB_TAG);
		scb = ahc_lookup_scb(ahc, scbindex);
		if (scb != NULL)
			/*
			 * Ensure that we didn't put a second instance of this
			 * SCB into the QINFIFO.
			 */
			ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
					   SCB_GET_CHANNEL(ahc, scb),
					   SCB_GET_LUN(scb), scb->hscb->tag,
					   ROLE_INITIATOR, /*status*/0,
					   SEARCH_REMOVE);
		break;
	}
	case NO_FREE_SCB:
	{
		printf("%s: No free or disconnected SCBs\n", ahc_name(ahc));
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	case SCB_MISMATCH:
	{
		u_int scbptr;

		scbptr = ahc_inb(ahc, SCBPTR);
		printf("Bogus TAG after DMA.  SCBPTR %d, tag %d, our tag %d\n",
		       scbptr, ahc_inb(ahc, ARG_1),
		       ahc->scb_data->hscbs[scbptr].tag);
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	case OUT_OF_RANGE:
	{
#ifndef SMALL_KERNEL
		printf("%s: BTT calculation out of range\n", ahc_name(ahc));
		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
		       "ARG_1 == 0x%x ACCUM = 0x%x\n",
		       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),
		       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));
		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
		       "SINDEX == 0x%x\n, A == 0x%x\n",
		       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),
		       ahc_index_busy_tcl(ahc,
			    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),
				      ahc_inb(ahc, SAVED_LUN))),
		       ahc_inb(ahc, SINDEX),
		       ahc_inb(ahc, ACCUM));
		printf("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
		       "SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",
		       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),
		       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),
		       ahc_inb(ahc, SCB_CONTROL));
		printf("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",
		       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));
#endif
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	default:
		printf("ahc_intr: seqint, "
		       "intstat == 0x%x, scsisigi = 0x%x\n",
		       intstat, ahc_inb(ahc, SCSISIGI));
		break;
	}
unpause:
	/*
	 *  The sequencer is paused immediately on
	 *  a SEQINT, so we should restart it when
	 *  we're done.
	 */
	ahc_unpause(ahc);
}

void
ahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat)
{
	u_int	scb_index;
	u_int	status0;
	u_int	status;
	struct	scb *scb;
	char	cur_channel;
	char	intr_channel;

	if ((ahc->features & AHC_TWIN) != 0
	    && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
		cur_channel = 'B';
	else
		cur_channel = 'A';
	intr_channel = cur_channel;

	if ((ahc->features & AHC_ULTRA2) != 0)
		status0 = ahc_inb(ahc, SSTAT0) & IOERR;
	else
		status0 = 0;
	status = ahc_inb(ahc, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
	if (status == 0 && status0 == 0) {
		if ((ahc->features & AHC_TWIN) != 0) {
			/* Try the other channel */
			ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			status = ahc_inb(ahc, SSTAT1)
			       & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
			intr_channel = (cur_channel == 'A') ? 'B' : 'A';
		}
		if (status == 0) {
			printf("%s: Spurious SCSI interrupt\n", ahc_name(ahc));
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
			ahc_unpause(ahc);
			return;
		}
	}

	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	if (scb != NULL
	 && (ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)
		scb = NULL;

	if ((ahc->features & AHC_ULTRA2) != 0
	 && (status0 & IOERR) != 0) {
		int now_lvd;

		now_lvd = ahc_inb(ahc, SBLKCTL) & ENAB40;
		printf("%s: Transceiver State Has Changed to %s mode\n",
		       ahc_name(ahc), now_lvd ? "LVD" : "SE");
		ahc_outb(ahc, CLRSINT0, CLRIOERR);
		/*
		 * When transitioning to SE mode, the reset line
		 * glitches, triggering an arbitration bug in some
		 * Ultra2 controllers.  This bug is cleared when we
		 * assert the reset line.  Since a reset glitch has
		 * already occurred with this transition and a
		 * transceiver state change is handled just like
		 * a bus reset anyway, asserting the reset line
		 * ourselves is safe.
		 */
		ahc_reset_channel(ahc, intr_channel,
				 /*Initiate Reset*/now_lvd == 0);
	} else if ((status & SCSIRSTI) != 0) {
		printf("%s: Someone reset channel %c\n",
			ahc_name(ahc), intr_channel);
		if (intr_channel != cur_channel)
			ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
		ahc_reset_channel(ahc, intr_channel, /*Initiate Reset*/FALSE);
	} else if ((status & SCSIPERR) != 0) {
		/*
		 * Determine the bus phase and queue an appropriate message.
		 * SCSIPERR is latched true as soon as a parity error
		 * occurs.  If the sequencer acked the transfer that
		 * caused the parity error and the currently presented
		 * transfer on the bus has correct parity, SCSIPERR will
		 * be cleared by CLRSCSIPERR.  Use this to determine if
		 * we should look at the last phase the sequencer recorded,
		 * or the current phase presented on the bus.
		 */
		struct	ahc_devinfo devinfo;
		u_int	mesg_out;
		u_int	curphase;
		u_int	errorphase;
		u_int	lastphase;
		u_int	scsirate;
		u_int	i;
		u_int	sstat2;
		int	silent;

		lastphase = ahc_inb(ahc, LASTPHASE);
		curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
		sstat2 = ahc_inb(ahc, SSTAT2);
		ahc_outb(ahc, CLRSINT1, CLRSCSIPERR);
		/*
		 * For all phases save DATA, the sequencer won't
		 * automatically ack a byte that has a parity error
		 * in it.  So the only way that the current phase
		 * could be 'data-in' is if the parity error is for
		 * an already acked byte in the data phase.  During
		 * synchronous data-in transfers, we may actually
		 * ack bytes before latching the current phase in
		 * LASTPHASE, leading to the discrepancy between
		 * curphase and lastphase.
		 */
		if ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0
		 || curphase == P_DATAIN || curphase == P_DATAIN_DT)
			errorphase = curphase;
		else
			errorphase = lastphase;

		for (i = 0; i < num_phases; i++) {
			if (errorphase == ahc_phase_table[i].phase)
				break;
		}
		mesg_out = ahc_phase_table[i].mesg_out;
		silent = FALSE;
		if (scb != NULL) {
			if (SCB_IS_SILENT(scb))
				silent = TRUE;
			else
				ahc_print_path(ahc, scb);
			scb->flags |= SCB_TRANSMISSION_ERROR;
		} else
			printf("%s:%c:%d: ", ahc_name(ahc), intr_channel,
			       SCSIID_TARGET(ahc, ahc_inb(ahc, SAVED_SCSIID)));
		scsirate = ahc_inb(ahc, SCSIRATE);
		if (silent == FALSE) {
			printf("parity error detected %s. "
			       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
			       ahc_phase_table[i].phasemsg,
			       ahc_inw(ahc, SEQADDR0),
			       scsirate);
			if ((ahc->features & AHC_DT) != 0) {
				if ((sstat2 & CRCVALERR) != 0)
					printf("\tCRC Value Mismatch\n");
				if ((sstat2 & CRCENDERR) != 0)
					printf("\tNo terminal CRC packet "
					       "received\n");
				if ((sstat2 & CRCREQERR) != 0)
					printf("\tIllegal CRC packet "
					       "request\n");
				if ((sstat2 & DUAL_EDGE_ERR) != 0)
					printf("\tUnexpected %sDT Data Phase\n",
					       (scsirate & SINGLE_EDGE)
					     ? "" : "non-");
			}
		}

		if ((ahc->features & AHC_DT) != 0
		 && (sstat2 & DUAL_EDGE_ERR) != 0) {
			/*
			 * This error applies regardless of
			 * data direction, so ignore the value
			 * in the phase table.
			 */
			mesg_out = MSG_INITIATOR_DET_ERR;
		}

		/*
		 * We've set the hardware to assert ATN if we
		 * get a parity error on "in" phases, so all we
		 * need to do is stuff the message buffer with
		 * the appropriate message.  "In" phases have set
		 * mesg_out to something other than MSG_NOP.
		 */
		if (mesg_out != MSG_NOOP) {
			if (ahc->msg_type != MSG_TYPE_NONE)
				ahc->send_msg_perror = TRUE;
			else
				ahc_outb(ahc, MSG_OUT, mesg_out);
		}
		/*
		 * Force a renegotiation with this target just in
		 * case we are out of sync for some external reason
		 * unknown (or unreported) by the target.
		 */
		ahc_fetch_devinfo(ahc, &devinfo);
		ahc_force_renegotiation(ahc, &devinfo);

		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_unpause(ahc);
	} else if ((status & SELTO) != 0) {
		u_int	scbptr;

		/* Stop the selection */
		ahc_outb(ahc, SCSISEQ, 0);

		/* No more pending messages */
		ahc_clear_msg_state(ahc);

		/* Clear interrupt state */
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);

		/*
		 * Although the driver does not care about the
		 * 'Selection in Progress' status bit, the busy
		 * LED does.  SELINGO is only cleared by a successful
		 * selection, so we must manually clear it to insure
		 * the LED turns off just incase no future successful
		 * selections occur (e.g. no devices on the bus).
		 */
		ahc_outb(ahc, CLRSINT0, CLRSELINGO);

		scbptr = ahc_inb(ahc, WAITING_SCBH);
		ahc_outb(ahc, SCBPTR, scbptr);
		scb_index = ahc_inb(ahc, SCB_TAG);

		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("%s: ahc_intr - referenced scb not "
			       "valid during SELTO scb(%d, %d)\n",
			       ahc_name(ahc), scbptr, scb_index);
			ahc_dump_card_state(ahc);
		} else {
			struct ahc_devinfo devinfo;
#ifdef AHC_DEBUG
			if ((ahc_debug & AHC_SHOW_SELTO) != 0) {
				ahc_print_path(ahc, scb);
				printf("Saw Selection Timeout for SCB 0x%x\n",
				       scb_index);
			}
#endif
			ahc_scb_devinfo(ahc, &devinfo, scb);
			ahc_set_transaction_status(scb, CAM_SEL_TIMEOUT);
			ahc_freeze_devq(ahc, scb);

			/*
			 * Cancel any pending transactions on the device
			 * now that it seems to be missing.  This will
			 * also revert us to async/narrow transfers until
			 * we can renegotiate with the device.
			 */
			ahc_handle_devreset(ahc, &devinfo,
					    CAM_SEL_TIMEOUT,
					    "Selection Timeout",
					    /*verbose_level*/1);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_restart(ahc);
	} else if ((status & BUSFREE) != 0
		&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {
		struct	ahc_devinfo devinfo;
		u_int	lastphase;
		u_int	saved_scsiid;
		u_int	saved_lun;
		u_int	target;
		u_int	initiator_role_id;
		char	channel;
		int	printerror;

		/*
		 * Clear our selection hardware as soon as possible.
		 * We may have an entry in the waiting Q for this target,
		 * that is affected by this busfree and we don't want to
		 * go about selecting the target while we handle the event.
		 */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));

		/*
		 * Disable busfree interrupts and clear the busfree
		 * interrupt status.  We do this here so that several
		 * bus transactions occur prior to clearing the SCSIINT
		 * latch.  It can take a bit for the clearing to take effect.
		 */
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);

		/*
		 * Look at what phase we were last in.
		 * If its message out, chances are pretty good
		 * that the busfree was in response to one of
		 * our abort requests.
		 */
		lastphase = ahc_inb(ahc, LASTPHASE);
		saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
		saved_lun = ahc_inb(ahc, SAVED_LUN);
		target = SCSIID_TARGET(ahc, saved_scsiid);
		initiator_role_id = SCSIID_OUR_ID(saved_scsiid);
		channel = SCSIID_CHANNEL(ahc, saved_scsiid);
		ahc_compile_devinfo(&devinfo, initiator_role_id,
				    target, saved_lun, channel, ROLE_INITIATOR);
		printerror = 1;

		if (lastphase == P_MESGOUT) {
			u_int tag;

			tag = SCB_LIST_NULL;
			if (ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT_TAG, TRUE)
			    || ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT, TRUE)) {
				if (ahc->msgout_buf[ahc->msgout_index - 1]
				    == MSG_ABORT_TAG)
					tag = scb->hscb->tag;
				ahc_print_path(ahc, scb);
				printf("SCB %d - Abort%s Completed.\n",
				       scb->hscb->tag, tag == SCB_LIST_NULL ?
				       "" : " Tag");
				ahc_abort_scbs(ahc, target, channel,
					       saved_lun, tag,
					       ROLE_INITIATOR,
					       CAM_REQ_ABORTED);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_1B,
						MSG_BUS_DEV_RESET, TRUE)) {
#ifdef __FreeBSD__
				/*
				 * Don't mark the user's request for this BDR
				 * as completing with CAM_BDR_SENT.  CAM3
				 * specifies CAM_REQ_CMP.
				 */
				if (scb != NULL
				 && scb->io_ctx->ccb_h.func_code== XPT_RESET_DEV
				 && ahc_match_scb(ahc, scb, target, channel,
						  CAM_LUN_WILDCARD,
						  SCB_LIST_NULL,
						  ROLE_INITIATOR)) {
					ahc_set_transaction_status(scb, CAM_REQ_CMP);
				}
#endif
				ahc_compile_devinfo(&devinfo,
						    initiator_role_id,
						    target,
						    CAM_LUN_WILDCARD,
						    channel,
						    ROLE_INITIATOR);
				ahc_handle_devreset(ahc, &devinfo,
						    CAM_BDR_SENT,
						    "Bus Device Reset",
						    /*verbose_level*/0);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_PPR, FALSE)) {
				struct ahc_initiator_tinfo *tinfo;
				struct ahc_tmode_tstate *tstate;

				/*
				 * PPR Rejected.  Try non-ppr negotiation
				 * and retry command.
				 */
				tinfo = ahc_fetch_transinfo(ahc,
							    devinfo.channel,
							    devinfo.our_scsiid,
							    devinfo.target,
							    &tstate);
				tinfo->curr.transport_version = 2;
				tinfo->goal.transport_version = 2;
				tinfo->goal.ppr_options = 0;
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_WDTR, FALSE)) {
				/*
				 * Negotiation Rejected.  Go-narrow and
				 * retry command.
				 */
				ahc_set_width(ahc, &devinfo,
					      MSG_EXT_WDTR_BUS_8_BIT,
					      AHC_TRANS_CUR|AHC_TRANS_GOAL,
					      /*paused*/TRUE);
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_SDTR, FALSE)) {
				/*
				 * Negotiation Rejected.  Go-async and
				 * retry command.
				 */
				ahc_set_syncrate(ahc, &devinfo,
						/*syncrate*/NULL,
						/*period*/0, /*offset*/0,
						/*ppr_options*/0,
						AHC_TRANS_CUR|AHC_TRANS_GOAL,
						/*paused*/TRUE);
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			}
		}
		if (printerror != 0) {
			u_int i;

			if (scb != NULL) {
				u_int tag;

				if ((scb->hscb->control & TAG_ENB) != 0)
					tag = scb->hscb->tag;
				else
					tag = SCB_LIST_NULL;
				ahc_print_path(ahc, scb);
				ahc_abort_scbs(ahc, target, channel,
					       SCB_GET_LUN(scb), tag,
					       ROLE_INITIATOR,
					       CAM_UNEXP_BUSFREE);
			} else {
				/*
				 * We had not fully identified this connection,
				 * so we cannot abort anything.
				 */
				printf("%s: ", ahc_name(ahc));
			}
			for (i = 0; i < num_phases; i++) {
				if (lastphase == ahc_phase_table[i].phase)
					break;
			}
			if (lastphase != P_BUSFREE) {
				/*
				 * Renegotiate with this device at the
				 * next oportunity just in case this busfree
				 * is due to a negotiation mismatch with the
				 * device.
				 */
				ahc_force_renegotiation(ahc, &devinfo);
			}
			printf("Unexpected busfree %s\n"
			       "SEQADDR == 0x%x\n",
			       ahc_phase_table[i].phasemsg,
			       ahc_inb(ahc, SEQADDR0)
				| (ahc_inb(ahc, SEQADDR1) << 8));
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_restart(ahc);
	} else {
		printf("%s: Missing case in ahc_handle_scsiint. status = %x\n",
		       ahc_name(ahc), status);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
	}
}

/*
 * Force renegotiation to occur the next time we initiate
 * a command to the current device.
 */
void
ahc_force_renegotiation(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	struct	ahc_initiator_tinfo *targ_info;
	struct	ahc_tmode_tstate *tstate;

	targ_info = ahc_fetch_transinfo(ahc,
					devinfo->channel,
					devinfo->our_scsiid,
					devinfo->target,
					&tstate);
	ahc_update_neg_request(ahc, devinfo, tstate,
			       targ_info, AHC_NEG_IF_NON_ASYNC);
}

#define AHC_MAX_STEPS 2000
void
ahc_clear_critical_section(struct ahc_softc *ahc)
{
	int	stepping;
	int	steps;
	u_int	simode0;
	u_int	simode1;

	if (ahc->num_critical_sections == 0)
		return;

	stepping = FALSE;
	steps = 0;
	simode0 = 0;
	simode1 = 0;
	for (;;) {
		struct	cs *cs;
		u_int	seqaddr;
		u_int	i;

		seqaddr = ahc_inb(ahc, SEQADDR0)
			| (ahc_inb(ahc, SEQADDR1) << 8);

		/*
		 * Seqaddr represents the next instruction to execute,
		 * so we are really executing the instruction just
		 * before it.
		 */
		cs = ahc->critical_sections;
		for (i = 0; i < ahc->num_critical_sections; i++, cs++) {

			if (cs->begin < seqaddr && cs->end >= seqaddr)
				break;
		}

		if (i == ahc->num_critical_sections)
			break;

		if (steps > AHC_MAX_STEPS) {
			printf("%s: Infinite loop in critical section\n",
			       ahc_name(ahc));
			ahc_dump_card_state(ahc);
			panic("critical section loop");
		}

		steps++;
		if (stepping == FALSE) {

			/*
			 * Disable all interrupt sources so that the
			 * sequencer will not be stuck by a pausing
			 * interrupt condition while we attempt to
			 * leave a critical section.
			 */
			simode0 = ahc_inb(ahc, SIMODE0);
			ahc_outb(ahc, SIMODE0, 0);
			simode1 = ahc_inb(ahc, SIMODE1);
			if ((ahc->features & AHC_DT) != 0)
				/*
				 * On DT class controllers, we
				 * use the enhanced busfree logic.
				 * Unfortunately we cannot re-enable
				 * busfree detection within the
				 * current connection, so we must
				 * leave it on while single stepping.
				 */
				ahc_outb(ahc, SIMODE1, simode1 & ENBUSFREE);
			else
				ahc_outb(ahc, SIMODE1, 0);
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
			ahc_outb(ahc, SEQCTL, ahc->seqctl | STEP);
			stepping = TRUE;
		}
		if ((ahc->features & AHC_DT) != 0) {
			ahc_outb(ahc, CLRSINT1, CLRBUSFREE);
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
		}
		ahc_outb(ahc, HCNTRL, ahc->unpause);
		while (!ahc_is_paused(ahc))
			aic_delay(200);
	}
	if (stepping) {
		ahc_outb(ahc, SIMODE0, simode0);
		ahc_outb(ahc, SIMODE1, simode1);
		ahc_outb(ahc, SEQCTL, ahc->seqctl);
	}
}

/*
 * Clear any pending interrupt status.
 */
void
ahc_clear_intstat(struct ahc_softc *ahc)
{
	/* Clear any interrupt conditions this may have caused */
	ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
				|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|
				CLRREQINIT);
	ahc_flush_device_writes(ahc);
	ahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);
	ahc_flush_device_writes(ahc);
	ahc_outb(ahc, CLRINT, CLRSCSIINT);
	ahc_flush_device_writes(ahc);
}

/**************************** Debugging Routines ******************************/
#ifdef AHC_DEBUG
uint32_t ahc_debug = 0; /* AHC_SHOW_MISC|AHC_SHOW_SENSE|AHC_DEBUG_OPTS;*/

void
ahc_print_scb(struct scb *scb)
{
	int i;

	struct hardware_scb *hscb = scb->hscb;

	printf("scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n",
	       (void *)scb,
	       hscb->control,
	       hscb->scsiid,
	       hscb->lun,
	       hscb->cdb_len);
	printf("Shared Data: ");
	for (i = 0; i < sizeof(hscb->shared_data.cdb); i++)
		printf("%#02x", hscb->shared_data.cdb[i]);
	printf("        dataptr:%#x datacnt:%#x sgptr:%#x tag:%#x\n",
		aic_le32toh(hscb->dataptr),
		aic_le32toh(hscb->datacnt),
		aic_le32toh(hscb->sgptr),
		hscb->tag);
	if (scb->sg_count > 0) {
		for (i = 0; i < scb->sg_count; i++) {
			printf("sg[%d] - Addr 0x%x%x : Length %d\n",
			       i,
			       (aic_le32toh(scb->sg_list[i].len) >> 24
			        & SG_HIGH_ADDR_BITS),
			       aic_le32toh(scb->sg_list[i].addr),
			       aic_le32toh(scb->sg_list[i].len));
		}
	}
}
#endif

/************************* Transfer Negotiation *******************************/
/*
 * Allocate per target mode instance (ID we respond to as a target)
 * transfer negotiation data structures.
 */
static struct ahc_tmode_tstate *
ahc_alloc_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel)
{
	struct ahc_tmode_tstate *master_tstate;
	struct ahc_tmode_tstate *tstate;
	int i;

	master_tstate = ahc->enabled_targets[ahc->our_id];
	if (channel == 'B') {
		scsi_id += 8;
		master_tstate = ahc->enabled_targets[ahc->our_id_b + 8];
	}
	if (ahc->enabled_targets[scsi_id] != NULL
	    && ahc->enabled_targets[scsi_id] != master_tstate)
		panic("%s: ahc_alloc_tstate - Target already allocated",
		      ahc_name(ahc));
	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (tstate == NULL)
		return (NULL);

	/*
	 * If we have allocated a master tstate, copy user settings from
	 * the master tstate (taken from SRAM or the EEPROM) for this
	 * channel, but reset our current and goal settings to async/narrow
	 * until an initiator talks to us.
	 */
	if (master_tstate != NULL) {
		memcpy(tstate, master_tstate, sizeof(*tstate));
		memset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));
		tstate->ultraenb = 0;
		for (i = 0; i < AHC_NUM_TARGETS; i++) {
			memset(&tstate->transinfo[i].curr, 0,
			      sizeof(tstate->transinfo[i].curr));
			memset(&tstate->transinfo[i].goal, 0,
			      sizeof(tstate->transinfo[i].goal));
		}
	}
	ahc->enabled_targets[scsi_id] = tstate;
	return (tstate);
}

#ifdef AHC_TARGET_MODE
/*
 * Free per target mode instance (ID we respond to as a target)
 * transfer negotiation data structures.
 */
static void
ahc_free_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel, int force)
{
	struct ahc_tmode_tstate *tstate;

	/*
	 * Don't clean up our "master" tstate.
	 * It has our default user settings.
	 */
	if (((channel == 'B' && scsi_id == ahc->our_id_b)
	  || (channel == 'A' && scsi_id == ahc->our_id))
	 && force == FALSE)
		return;

	if (channel == 'B')
		scsi_id += 8;
	tstate = ahc->enabled_targets[scsi_id];
	if (tstate != NULL)
		free(tstate, M_DEVBUF, 0);
	ahc->enabled_targets[scsi_id] = NULL;
}
#endif

/*
 * Called when we have an active connection to a target on the bus,
 * this function finds the nearest syncrate to the input period limited
 * by the capabilities of the bus connectivity of and sync settings for
 * the target.
 */
struct ahc_syncrate *
ahc_devlimited_syncrate(struct ahc_softc *ahc,
			struct ahc_initiator_tinfo *tinfo,
			u_int *period, u_int *ppr_options, role_t role)
{
	struct	ahc_transinfo *transinfo;
	u_int	maxsync;

	if ((ahc->features & AHC_ULTRA2) != 0) {
		if ((ahc_inb(ahc, SBLKCTL) & ENAB40) != 0
		 && (ahc_inb(ahc, SSTAT2) & EXP_ACTIVE) == 0) {
			maxsync = AHC_SYNCRATE_DT;
		} else {
			maxsync = AHC_SYNCRATE_ULTRA;
			/* Can't do DT on an SE bus */
			*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
		}
	} else if ((ahc->features & AHC_ULTRA) != 0) {
		maxsync = AHC_SYNCRATE_ULTRA;
	} else {
		maxsync = AHC_SYNCRATE_FAST;
	}
	/*
	 * Never allow a value higher than our current goal
	 * period otherwise we may allow a target initiated
	 * negotiation to go above the limit as set by the
	 * user.  In the case of an initiator initiated
	 * sync negotiation, we limit based on the user
	 * setting.  This allows the system to still accept
	 * incoming negotiations even if target initiated
	 * negotiation is not performed.
	 */
	if (role == ROLE_TARGET)
		transinfo = &tinfo->user;
	else
		transinfo = &tinfo->goal;
	*ppr_options &= transinfo->ppr_options;
	if (transinfo->width == MSG_EXT_WDTR_BUS_8_BIT) {
		maxsync = MAX(maxsync, AHC_SYNCRATE_ULTRA2);
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
	}
	if (transinfo->period == 0) {
		*period = 0;
		*ppr_options = 0;
		return (NULL);
	}
	*period = MAX(*period, transinfo->period);
	return (ahc_find_syncrate(ahc, period, ppr_options, maxsync));
}

/*
 * Look up the valid period to SCSIRATE conversion in our table.
 * Return the period and offset that should be sent to the target
 * if this was the beginning of an SDTR.
 */
struct ahc_syncrate *
ahc_find_syncrate(struct ahc_softc *ahc, u_int *period,
		  u_int *ppr_options, u_int maxsync)
{
	struct ahc_syncrate *syncrate;

	if ((ahc->features & AHC_DT) == 0)
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;

	/* Skip all DT only entries if DT is not available */
	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0
	 && maxsync < AHC_SYNCRATE_ULTRA2)
		maxsync = AHC_SYNCRATE_ULTRA2;

	for (syncrate = &ahc_syncrates[maxsync];
	     syncrate->rate != NULL;
	     syncrate++) {

		/*
		 * The Ultra2 table doesn't go as low
		 * as for the Fast/Ultra cards.
		 */
		if ((ahc->features & AHC_ULTRA2) != 0
		 && (syncrate->sxfr_u2 == 0))
			break;

		if (*period <= syncrate->period) {
			/*
			 * When responding to a target that requests
			 * sync, the requested rate may fall between
			 * two rates that we can output, but still be
			 * a rate that we can receive.  Because of this,
			 * we want to respond to the target with
			 * the same rate that it sent to us even
			 * if the period we use to send data to it
			 * is lower.  Only lower the response period
			 * if we must.
			 */
			if (syncrate == &ahc_syncrates[maxsync])
				*period = syncrate->period;

			/*
			 * At some speeds, we only support
			 * ST transfers.
			 */
			if ((syncrate->sxfr_u2 & ST_SXFR) != 0)
				*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
			break;
		}
	}

	if ((*period == 0)
	 || (syncrate->rate == NULL)
	 || ((ahc->features & AHC_ULTRA2) != 0
	  && (syncrate->sxfr_u2 == 0))) {
		/* Use asynchronous transfers. */
		*period = 0;
		syncrate = NULL;
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
	}
	return (syncrate);
}

/*
 * Convert from an entry in our syncrate table to the SCSI equivalent
 * sync "period" factor.
 */
u_int
ahc_find_period(struct ahc_softc *ahc, u_int scsirate, u_int maxsync)
{
	struct ahc_syncrate *syncrate;

	if ((ahc->features & AHC_ULTRA2) != 0)
		scsirate &= SXFR_ULTRA2;
	else
		scsirate &= SXFR;

	syncrate = &ahc_syncrates[maxsync];
	while (syncrate->rate != NULL) {

		if ((ahc->features & AHC_ULTRA2) != 0) {
			if (syncrate->sxfr_u2 == 0)
				break;
			else if (scsirate == (syncrate->sxfr_u2 & SXFR_ULTRA2))
				return (syncrate->period);
		} else if (scsirate == (syncrate->sxfr & SXFR)) {
				return (syncrate->period);
		}
		syncrate++;
	}
	return (0); /* async */
}

/*
 * Truncate the given synchronous offset to a value the
 * current adapter type and syncrate are capable of.
 */
void
ahc_validate_offset(struct ahc_softc *ahc,
		    struct ahc_initiator_tinfo *tinfo,
		    struct ahc_syncrate *syncrate,
		    u_int *offset, int wide, role_t role)
{
	u_int maxoffset;

	/* Limit offset to what we can do */
	if (syncrate == NULL) {
		maxoffset = 0;
	} else if ((ahc->features & AHC_ULTRA2) != 0) {
		maxoffset = MAX_OFFSET_ULTRA2;
	} else {
		if (wide)
			maxoffset = MAX_OFFSET_16BIT;
		else
			maxoffset = MAX_OFFSET_8BIT;
	}
	*offset = MIN(*offset, maxoffset);
	if (tinfo != NULL) {
		if (role == ROLE_TARGET)
			*offset = MIN(*offset, tinfo->user.offset);
		else
			*offset = MIN(*offset, tinfo->goal.offset);
	}
}

/*
 * Truncate the given transfer width parameter to a value the
 * current adapter type is capable of.
 */
void
ahc_validate_width(struct ahc_softc *ahc, struct ahc_initiator_tinfo *tinfo,
		   u_int *bus_width, role_t role)
{
	switch (*bus_width) {
	default:
		if (ahc->features & AHC_WIDE) {
			/* Respond Wide */
			*bus_width = MSG_EXT_WDTR_BUS_16_BIT;
			break;
		}
		/* FALLTHROUGH */
	case MSG_EXT_WDTR_BUS_8_BIT:
		*bus_width = MSG_EXT_WDTR_BUS_8_BIT;
		break;
	}
	if (tinfo != NULL) {
		if (role == ROLE_TARGET)
			*bus_width = MIN(tinfo->user.width, *bus_width);
		else
			*bus_width = MIN(tinfo->goal.width, *bus_width);
	}
}

/*
 * Update the bitmask of targets for which the controller should
 * negotiate with at the next convenient opportunity.  This currently
 * means the next time we send the initial identify messages for
 * a new transaction.
 */
int
ahc_update_neg_request(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		       struct ahc_tmode_tstate *tstate,
		       struct ahc_initiator_tinfo *tinfo, ahc_neg_type neg_type)
{
	u_int auto_negotiate_orig;

	auto_negotiate_orig = tstate->auto_negotiate;
	if (neg_type == AHC_NEG_ALWAYS) {
		/*
		 * Force our "current" settings to be
		 * unknown so that unless a bus reset
		 * occurs the need to renegotiate is
		 * recorded persistently.
		 */
		if ((ahc->features & AHC_WIDE) != 0)
			tinfo->curr.width = AHC_WIDTH_UNKNOWN;
		tinfo->curr.period = AHC_PERIOD_UNKNOWN;
		tinfo->curr.offset = AHC_OFFSET_UNKNOWN;
	}
	if (tinfo->curr.period != tinfo->goal.period
	 || tinfo->curr.width != tinfo->goal.width
	 || tinfo->curr.offset != tinfo->goal.offset
	 || tinfo->curr.ppr_options != tinfo->goal.ppr_options
	 || (neg_type == AHC_NEG_IF_NON_ASYNC
	  && (tinfo->goal.offset != 0
	   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT
	   || tinfo->goal.ppr_options != 0)))
		tstate->auto_negotiate |= devinfo->target_mask;
	else
		tstate->auto_negotiate &= ~devinfo->target_mask;

	return (auto_negotiate_orig != tstate->auto_negotiate);
}

/*
 * Update the user/goal/curr tables of synchronous negotiation
 * parameters as well as, in the case of a current or active update,
 * any data structures on the host controller.  In the case of an
 * active update, the specified target is currently talking to us on
 * the bus, so the transfer parameter update must take effect
 * immediately.
 */
void
ahc_set_syncrate(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		 struct ahc_syncrate *syncrate, u_int period,
		 u_int offset, u_int ppr_options, u_int type, int paused)
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	u_int	old_period;
	u_int	old_offset;
	u_int	old_ppr;
	int	active;
	int	update_needed;

	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
	update_needed = 0;

	if (syncrate == NULL) {
		period = 0;
		offset = 0;
	}

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);

	if ((type & AHC_TRANS_USER) != 0) {
		tinfo->user.period = period;
		tinfo->user.offset = offset;
		tinfo->user.ppr_options = ppr_options;
	}

	if ((type & AHC_TRANS_GOAL) != 0) {
		tinfo->goal.period = period;
		tinfo->goal.offset = offset;
		tinfo->goal.ppr_options = ppr_options;
	}

	old_period = tinfo->curr.period;
	old_offset = tinfo->curr.offset;
	old_ppr	   = tinfo->curr.ppr_options;

	if ((type & AHC_TRANS_CUR) != 0
	 && (old_period != period
	  || old_offset != offset
	  || old_ppr != ppr_options)) {
		u_int	scsirate;

		update_needed++;
		scsirate = tinfo->scsirate;
		if ((ahc->features & AHC_ULTRA2) != 0) {

			scsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);
			if (syncrate != NULL) {
				scsirate |= syncrate->sxfr_u2;
				if ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0)
					scsirate |= ENABLE_CRC;
				else
					scsirate |= SINGLE_EDGE;
			}
		} else {

			scsirate &= ~(SXFR|SOFS);
			/*
			 * Ensure Ultra mode is set properly for
			 * this target.
			 */
			tstate->ultraenb &= ~devinfo->target_mask;
			if (syncrate != NULL) {
				if (syncrate->sxfr & ULTRA_SXFR) {
					tstate->ultraenb |=
						devinfo->target_mask;
				}
				scsirate |= syncrate->sxfr & SXFR;
				scsirate |= offset & SOFS;
			}
			if (active) {
				u_int sxfrctl0;

				sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
				sxfrctl0 &= ~FAST20;
				if (tstate->ultraenb & devinfo->target_mask)
					sxfrctl0 |= FAST20;
				ahc_outb(ahc, SXFRCTL0, sxfrctl0);
			}
		}
		if (active) {
			ahc_outb(ahc, SCSIRATE, scsirate);
			if ((ahc->features & AHC_ULTRA2) != 0)
				ahc_outb(ahc, SCSIOFFSET, offset);
		}

		tinfo->scsirate = scsirate;
		tinfo->curr.period = period;
		tinfo->curr.offset = offset;
		tinfo->curr.ppr_options = ppr_options;

		ahc_send_async(ahc, devinfo->channel, devinfo->target,
		  CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (1 /*bootverbose*/) {
			if (offset != 0) {
				printf("%s: target %d synchronous at %sMHz%s, "
				       "offset = 0x%x\n", ahc_name(ahc),
				       devinfo->target, syncrate->rate,
				       (ppr_options & MSG_EXT_PPR_DT_REQ)
				       ? " DT" : "", offset);
			} else {
				printf("%s: target %d using "
				       "asynchronous transfers\n",
				       ahc_name(ahc), devinfo->target);
			}
		}
	}

	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
						tinfo, AHC_NEG_TO_GOAL);

	if (update_needed)
		ahc_update_pending_scbs(ahc);
}

/*
 * Update the user/goal/curr tables of wide negotiation
 * parameters as well as, in the case of a current or active update,
 * any data structures on the host controller.  In the case of an
 * active update, the specified target is currently talking to us on
 * the bus, so the transfer parameter update must take effect
 * immediately.
 */
void
ahc_set_width(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
	      u_int width, u_int type, int paused)
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	u_int	oldwidth;
	int	active;
	int	update_needed;

	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
	update_needed = 0;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);

	if ((type & AHC_TRANS_USER) != 0)
		tinfo->user.width = width;

	if ((type & AHC_TRANS_GOAL) != 0)
		tinfo->goal.width = width;

	oldwidth = tinfo->curr.width;
	if ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {
		u_int	scsirate;

		update_needed++;
		scsirate =  tinfo->scsirate;
		scsirate &= ~WIDEXFER;
		if (width == MSG_EXT_WDTR_BUS_16_BIT)
			scsirate |= WIDEXFER;

		tinfo->scsirate = scsirate;

		if (active)
			ahc_outb(ahc, SCSIRATE, scsirate);

		tinfo->curr.width = width;

		ahc_send_async(ahc, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (1 /*bootverbose*/) {
			printf("%s: target %d using %dbit transfers\n",
			       ahc_name(ahc), devinfo->target,
			       8 * (0x01 << width));
		}
	}

	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
						tinfo, AHC_NEG_TO_GOAL);
	if (update_needed)
		ahc_update_pending_scbs(ahc);
}

/*
 * Update the current state of tagged queuing for a given target.
 */
void
ahc_set_tags(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
	     ahc_queue_alg alg)
{
	ahc_platform_set_tags(ahc, devinfo, alg);
	ahc_send_async(ahc, devinfo->channel, devinfo->target,
		       devinfo->lun, AC_TRANSFER_NEG, &alg);
}

/*
 * When the transfer settings for a connection change, update any
 * in-transit SCBs to contain the new data so the hardware will
 * be set correctly during future (re)selections.
 */
static void
ahc_update_pending_scbs(struct ahc_softc *ahc)
{
	struct	scb *pending_scb;
	int	pending_scb_count;
	int	i;
	int	paused;
	u_int	saved_scbptr;

	/*
	 * Traverse the pending SCB list and ensure that all of the
	 * SCBs there have the proper settings.
	 */
	pending_scb_count = 0;
	LIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {
		struct ahc_devinfo devinfo;
		struct hardware_scb *pending_hscb;
		struct ahc_initiator_tinfo *tinfo;
		struct ahc_tmode_tstate *tstate;

		ahc_scb_devinfo(ahc, &devinfo, pending_scb);
		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
					    devinfo.our_scsiid,
					    devinfo.target, &tstate);
		pending_hscb = pending_scb->hscb;
		pending_hscb->control &= ~ULTRAENB;
		if ((tstate->ultraenb & devinfo.target_mask) != 0)
			pending_hscb->control |= ULTRAENB;
		pending_hscb->scsirate = tinfo->scsirate;
		pending_hscb->scsioffset = tinfo->curr.offset;
		if ((tstate->auto_negotiate & devinfo.target_mask) == 0
		 && (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {
			pending_scb->flags &= ~SCB_AUTO_NEGOTIATE;
			pending_hscb->control &= ~MK_MESSAGE;
		}
		ahc_sync_scb(ahc, pending_scb,
			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
		pending_scb_count++;
	}

	if (pending_scb_count == 0)
		return;

	if (ahc_is_paused(ahc)) {
		paused = 1;
	} else {
		paused = 0;
		ahc_pause(ahc);
	}

	saved_scbptr = ahc_inb(ahc, SCBPTR);
	/* Ensure that the hscbs down on the card match the new information */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		struct	hardware_scb *pending_hscb;
		u_int	control;
		u_int	scb_tag;

		ahc_outb(ahc, SCBPTR, i);
		scb_tag = ahc_inb(ahc, SCB_TAG);
		pending_scb = ahc_lookup_scb(ahc, scb_tag);
		if (pending_scb == NULL)
			continue;

		pending_hscb = pending_scb->hscb;
		control = ahc_inb(ahc, SCB_CONTROL);
		control &= ~(ULTRAENB|MK_MESSAGE);
		control |= pending_hscb->control & (ULTRAENB|MK_MESSAGE);
		ahc_outb(ahc, SCB_CONTROL, control);
		ahc_outb(ahc, SCB_SCSIRATE, pending_hscb->scsirate);
		ahc_outb(ahc, SCB_SCSIOFFSET, pending_hscb->scsioffset);
	}
	ahc_outb(ahc, SCBPTR, saved_scbptr);

	if (paused == 0)
		ahc_unpause(ahc);
}

/**************************** Pathing Information *****************************/
static void
ahc_fetch_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	u_int	saved_scsiid;
	role_t	role;
	int	our_id;

	if (ahc_inb(ahc, SSTAT0) & TARGET)
		role = ROLE_TARGET;
	else
		role = ROLE_INITIATOR;

	if (role == ROLE_TARGET
	 && (ahc->features & AHC_MULTI_TID) != 0
	 && (ahc_inb(ahc, SEQ_FLAGS)
	   & (CMDPHASE_PENDING|TARG_CMD_PENDING|NO_DISCONNECT)) != 0) {
		/* We were selected, so pull our id from TARGIDIN */
		our_id = ahc_inb(ahc, TARGIDIN) & OID;
	} else if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;

	saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
	ahc_compile_devinfo(devinfo,
			    our_id,
			    SCSIID_TARGET(ahc, saved_scsiid),
			    ahc_inb(ahc, SAVED_LUN),
			    SCSIID_CHANNEL(ahc, saved_scsiid),
			    role);
}

struct ahc_phase_table_entry*
ahc_lookup_phase_entry(int phase)
{
	struct ahc_phase_table_entry *entry;
	struct ahc_phase_table_entry *last_entry;

	/*
	 * num_phases doesn't include the default entry which
	 * will be returned if the phase doesn't match.
	 */
	last_entry = &ahc_phase_table[num_phases];
	for (entry = ahc_phase_table; entry < last_entry; entry++) {
		if (phase == entry->phase)
			break;
	}
	return (entry);
}

void
ahc_compile_devinfo(struct ahc_devinfo *devinfo, u_int our_id, u_int target,
		    u_int lun, char channel, role_t role)
{
	devinfo->our_scsiid = our_id;
	devinfo->target = target;
	devinfo->lun = lun;
	devinfo->target_offset = target;
	devinfo->channel = channel;
	devinfo->role = role;
	if (channel == 'B')
		devinfo->target_offset += 8;
	devinfo->target_mask = (0x01 << devinfo->target_offset);
}

void
ahc_print_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	printf("%s:%c:%d:%d: ", ahc_name(ahc), devinfo->channel,
	       devinfo->target, devinfo->lun);
}

void
ahc_scb_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		struct scb *scb)
{
	role_t	role;
	int	our_id;

	our_id = SCSIID_OUR_ID(scb->hscb->scsiid);
	role = ROLE_INITIATOR;
	if ((scb->flags & SCB_TARGET_SCB) != 0)
		role = ROLE_TARGET;
	ahc_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahc, scb),
			    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahc, scb), role);
}


/************************ Message Phase Processing ****************************/
static void
ahc_assert_atn(struct ahc_softc *ahc)
{
	u_int scsisigo;

	scsisigo = ATNO;
	if ((ahc->features & AHC_DT) == 0)
		scsisigo |= ahc_inb(ahc, SCSISIGI);
	ahc_outb(ahc, SCSISIGO, scsisigo);
}

/*
 * When an initiator transaction with the MK_MESSAGE flag either reconnects
 * or enters the initial message out phase, we are interrupted.  Fill our
 * outgoing message buffer with the appropriate message and begin handing
 * the message phase(s) manually.
 */
static void
ahc_setup_initiator_msgout(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
			   struct scb *scb)
{
	/*
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if ((scb->flags & SCB_DEVICE_RESET) == 0
	 && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {
		u_int identify_msg;

		identify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);
		if ((scb->hscb->control & DISCENB) != 0)
			identify_msg |= MSG_IDENTIFY_DISCFLAG;
		ahc->msgout_buf[ahc->msgout_index++] = identify_msg;
		ahc->msgout_len++;

		if ((scb->hscb->control & TAG_ENB) != 0) {
			ahc->msgout_buf[ahc->msgout_index++] =
			    scb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);
			ahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;
			ahc->msgout_len += 2;
		}
	}

	if (scb->flags & SCB_DEVICE_RESET) {
		ahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;
		ahc->msgout_len++;
		ahc_print_path(ahc, scb);
		printf("Bus Device Reset Message Sent\n");
		/*
		 * Clear our selection hardware in advance of
		 * the busfree.  We may have an entry in the waiting
		 * Q for this target, and we don't want to go about
		 * selecting while we handle the busfree and blow it
		 * away.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else if ((scb->flags & SCB_ABORT) != 0) {
		if ((scb->hscb->control & TAG_ENB) != 0)
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;
		else
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;
		ahc->msgout_len++;
		ahc_print_path(ahc, scb);
		printf("Abort%s Message Sent\n",
		       (scb->hscb->control & TAG_ENB) != 0 ? " Tag" : "");
		/*
		 * Clear our selection hardware in advance of
		 * the busfree.  We may have an entry in the waiting
		 * Q for this target, and we don't want to go about
		 * selecting while we handle the busfree and blow it
		 * away.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {
		ahc_build_transfer_msg(ahc, devinfo);
	} else {
		printf("ahc_intr: AWAITING_MSG for an SCB that "
		       "does not have a waiting message\n");
		printf("SCSIID = %x, target_mask = %x\n", scb->hscb->scsiid,
		       devinfo->target_mask);
		panic("SCB = %d, SCB Control = %x, MSG_OUT = %x "
		      "SCB flags = %x", scb->hscb->tag, scb->hscb->control,
		      ahc_inb(ahc, MSG_OUT), scb->flags);
	}

	/*
	 * Clear the MK_MESSAGE flag from the SCB so we aren't
	 * asked to send this message again.
	 */
	ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);
	scb->hscb->control &= ~MK_MESSAGE;
	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
}

/*
 * Build an appropriate transfer negotiation message for the
 * currently active target.
 */
static void
ahc_build_transfer_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	/*
	 * We need to initiate transfer negotiations.
	 * If our current and goal settings are identical,
	 * we want to renegotiate due to a check condition.
	 */
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	struct	ahc_syncrate *rate;
	int	dowide;
	int	dosync;
	int	doppr;
	u_int	period;
	u_int	ppr_options;
	u_int	offset;

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	/*
	 * Filter our period based on the current connection.
	 * If we can't perform DT transfers on this segment (not in LVD
	 * mode for instance), then our decision to issue a PPR message
	 * may change.
	 */
	period = tinfo->goal.period;
	offset = tinfo->goal.offset;
	ppr_options = tinfo->goal.ppr_options;
	/* Target initiated PPR is not allowed in the SCSI spec */
	if (devinfo->role == ROLE_TARGET)
		ppr_options = 0;
	rate = ahc_devlimited_syncrate(ahc, tinfo, &period,
				       &ppr_options, devinfo->role);
	dowide = tinfo->curr.width != tinfo->goal.width;
	dosync = tinfo->curr.offset != offset || tinfo->curr.period != period;
	/*
	 * Only use PPR if we have options that need it, even if the device
	 * claims to support it.  There might be an expander in the way
	 * that doesn't.
	 */
	doppr = ppr_options != 0;

	if (!dowide && !dosync && !doppr) {
		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
		dosync = tinfo->goal.offset != 0;
	}

	if (!dowide && !dosync && !doppr) {
		/*
		 * Force async with a WDTR message if we have a wide bus,
		 * or just issue an SDTR with a 0 offset.
		 */
		if ((ahc->features & AHC_WIDE) != 0)
			dowide = 1;
		else
			dosync = 1;

		if (bootverbose) {
			ahc_print_devinfo(ahc, devinfo);
			printf("Ensuring async\n");
		}
	}

	/* Target initiated PPR is not allowed in the SCSI spec */
	if (devinfo->role == ROLE_TARGET)
		doppr = 0;

	/*
	 * Both the PPR message and SDTR message require the
	 * goal syncrate to be limited to what the target device
	 * is capable of handling (based on whether an LVD->SE
	 * expander is on the bus), so combine these two cases.
	 * Regardless, guarantee that if we are using WDTR and SDTR
	 * messages that WDTR comes first.
	 */
	if (doppr || (dosync && !dowide)) {

		offset = tinfo->goal.offset;
		ahc_validate_offset(ahc, tinfo, rate, &offset,
				    doppr ? tinfo->goal.width
					  : tinfo->curr.width,
				    devinfo->role);
		if (doppr) {
			ahc_construct_ppr(ahc, devinfo, period, offset,
					  tinfo->goal.width, ppr_options);
		} else {
			ahc_construct_sdtr(ahc, devinfo, period, offset);
		}
	} else {
		ahc_construct_wdtr(ahc, devinfo, tinfo->goal.width);
	}
}

/*
 * Build a synchronous negotiation message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_sdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		   u_int period, u_int offset)
{
	if (offset == 0)
		period = AHC_ASYNC_XFER_PERIOD;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_len += 5;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       devinfo->lun, period, offset);
	}
}

/*
 * Build a wide negotiation message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_wdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		   u_int bus_width)
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_len += 4;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending WDTR %x\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       devinfo->lun, bus_width);
	}
}

/*
 * Build a parallel protocol request message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_ppr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		  u_int period, u_int offset, u_int bus_width,
		  u_int ppr_options)
{
	if (offset == 0)
		period = AHC_ASYNC_XFER_PERIOD;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = 0;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_buf[ahc->msgout_index++] = ppr_options;
	ahc->msgout_len += 8;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "
		       "offset %x, ppr_options %x\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target, devinfo->lun,
		       bus_width, period, offset, ppr_options);
	}
}

/*
 * Clear any active message state.
 */
static void
ahc_clear_msg_state(struct ahc_softc *ahc)
{
	ahc->msgout_len = 0;
	ahc->msgin_index = 0;
	ahc->msg_type = MSG_TYPE_NONE;
	if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0) {
		/*
		 * The target didn't care to respond to our
		 * message request, so clear ATN.
		 */
		ahc_outb(ahc, CLRSINT1, CLRATNO);
	}
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
	ahc_outb(ahc, SEQ_FLAGS2,
		 ahc_inb(ahc, SEQ_FLAGS2) & ~TARGET_MSG_PENDING);
}

static void
ahc_handle_proto_violation(struct ahc_softc *ahc)
{
	struct	ahc_devinfo devinfo;
	struct	scb *scb;
	u_int	scbid;
	u_int	seq_flags;
	u_int	curphase;
	u_int	lastphase;
	int	found;

	ahc_fetch_devinfo(ahc, &devinfo);
	scbid = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scbid);
	seq_flags = ahc_inb(ahc, SEQ_FLAGS);
	curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
	lastphase = ahc_inb(ahc, LASTPHASE);
	if ((seq_flags & NOT_IDENTIFIED) != 0) {

		/*
		 * The reconnecting target either did not send an
		 * identify message, or did, but we didn't find an SCB
		 * to match.
		 */
		ahc_print_devinfo(ahc, &devinfo);
		printf("Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x.\n", lastphase);
		scb = NULL;
	} else if (scb == NULL) {
		/*
		 * We don't seem to have an SCB active for this
		 * transaction.  Print an error and reset the bus.
		 */
		ahc_print_devinfo(ahc, &devinfo);
		printf("No SCB found during protocol violation\n");
		goto proto_violation_reset;
	} else {
		ahc_set_transaction_status(scb, CAM_SEQUENCE_FAIL);
		if ((seq_flags & NO_CDB_SENT) != 0) {
			ahc_print_path(ahc, scb);
			printf("No or incomplete CDB sent to device.\n");
		} else if ((ahc_inb(ahc, SCB_CONTROL) & STATUS_RCVD) == 0) {
			/*
			 * The target never bothered to provide status to
			 * us prior to completing the command.  Since we don't
			 * know the disposition of this command, we must attempt
			 * to abort it.  Assert ATN and prepare to send an abort
			 * message.
			 */
			ahc_print_path(ahc, scb);
			printf("Completed command without status.\n");
		} else {
			ahc_print_path(ahc, scb);
			printf("Unknown protocol violation.\n");
			ahc_dump_card_state(ahc);
		}
	}
	if ((lastphase & ~P_DATAIN_DT) == 0
	 || lastphase == P_COMMAND) {
proto_violation_reset:
		/*
		 * Target either went directly to data/command
		 * phase or didn't respond to our ATN.
		 * The only safe thing to do is to blow
		 * it away with a bus reset.
		 */
		found = ahc_reset_channel(ahc, 'A', TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), 'A', found);
	} else {
		/*
		 * Leave the selection hardware off in case
		 * this abort attempt will affect yet to
		 * be sent commands.
		 */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & ~ENSELO);
		ahc_assert_atn(ahc);
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		if (scb == NULL) {
			ahc_print_devinfo(ahc, &devinfo);
			ahc->msgout_buf[0] = MSG_ABORT_TASK;
			ahc->msgout_len = 1;
			ahc->msgout_index = 0;
			ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		} else {
			ahc_print_path(ahc, scb);
			scb->flags |= SCB_ABORT;
		}
		printf("Protocol violation %s.  Attempting to abort.\n",
		       ahc_lookup_phase_entry(curphase)->phasemsg);
	}
}

/*
 * Manual message loop handler.
 */
static void
ahc_handle_message_phase(struct ahc_softc *ahc)
{
	struct	ahc_devinfo devinfo;
	u_int	bus_phase;
	int	end_session;

	ahc_fetch_devinfo(ahc, &devinfo);
	end_session = FALSE;
	bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;

reswitch:
	switch (ahc->msg_type) {
	case MSG_TYPE_INITIATOR_MSGOUT:
	{
		int lastbyte;
		int phasemis;
		int msgdone;

		if (ahc->msgout_len == 0)
			panic("HOST_MSG_LOOP interrupt with no active message");

#ifdef AHC_DEBUG
		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
			ahc_print_devinfo(ahc, &devinfo);
			printf("INITIATOR_MSG_OUT");
		}
#endif
		phasemis = bus_phase != P_MESGOUT;
		if (phasemis) {
#ifdef AHC_DEBUG
			if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
				printf(" PHASEMIS %s\n",
				       ahc_lookup_phase_entry(bus_phase)
							     ->phasemsg);
			}
#endif
			if (bus_phase == P_MESGIN) {
				/*
				 * Change gears and see if
				 * this messages is of interest to
				 * us or should be passed back to
				 * the sequencer.
				 */
				ahc_outb(ahc, CLRSINT1, CLRATNO);
				ahc->send_msg_perror = FALSE;
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;
				ahc->msgin_index = 0;
				goto reswitch;
			}
			end_session = TRUE;
			break;
		}

		if (ahc->send_msg_perror) {
			ahc_outb(ahc, CLRSINT1, CLRATNO);
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
#ifdef AHC_DEBUG
			if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
				printf(" byte 0x%x\n", ahc->send_msg_perror);
#endif
			ahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);
			break;
		}

		msgdone	= ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			/*
			 * The target has requested a retry.
			 * Re-assert ATN, reset our message index to
			 * 0, and try again.
			 */
			ahc->msgout_index = 0;
			ahc_assert_atn(ahc);
		}

		lastbyte = ahc->msgout_index == (ahc->msgout_len - 1);
		if (lastbyte) {
			/* Last byte is signified by dropping ATN */
			ahc_outb(ahc, CLRSINT1, CLRATNO);
		}

		/*
		 * Clear our interrupt status and present
		 * the next byte on the bus.
		 */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
#ifdef AHC_DEBUG
		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
			printf(" byte 0x%x\n",
			       ahc->msgout_buf[ahc->msgout_index]);
#endif
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
		break;
	}
	case MSG_TYPE_INITIATOR_MSGIN:
	{
		int phasemis;
		int message_done;

#ifdef AHC_DEBUG
		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
			ahc_print_devinfo(ahc, &devinfo);
			printf("INITIATOR_MSG_IN");
		}
#endif
		phasemis = bus_phase != P_MESGIN;
		if (phasemis) {
#ifdef AHC_DEBUG
			if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
				printf(" PHASEMIS %s\n",
				       ahc_lookup_phase_entry(bus_phase)
							     ->phasemsg);
			}
#endif
			ahc->msgin_index = 0;
			if (bus_phase == P_MESGOUT
			 && (ahc->send_msg_perror == TRUE
			  || (ahc->msgout_len != 0
			   && ahc->msgout_index == 0))) {
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
				goto reswitch;
			}
			end_session = TRUE;
			break;
		}

		/* Pull the byte in without acking it */
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);
#ifdef AHC_DEBUG
		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
			printf(" byte 0x%x\n",
			       ahc->msgin_buf[ahc->msgin_index]);
#endif

		message_done = ahc_parse_msg(ahc, &devinfo);

		if (message_done) {
			/*
			 * Clear our incoming message buffer in case there
			 * is another message following this one.
			 */
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response,
			 * assert ATN so the target takes us to the
			 * message out phase.
			 */
			if (ahc->msgout_len != 0) {
#ifdef AHC_DEBUG
				if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
					ahc_print_devinfo(ahc, &devinfo);
					printf("Asserting ATN for response\n");
				}
#endif
				ahc_assert_atn(ahc);
			}
		} else
			ahc->msgin_index++;

		if (message_done == MSGLOOP_TERMINATED) {
			end_session = TRUE;
		} else {
			/* Ack the byte */
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
			ahc_inb(ahc, SCSIDATL);
		}
		break;
	}
	case MSG_TYPE_TARGET_MSGIN:
	{
		int msgdone;
		int msgout_request;

		if (ahc->msgout_len == 0)
			panic("Target MSGIN with no active message");

		/*
		 * If we interrupted a mesgout session, the initiator
		 * will not know this until our first REQ.  So, we
		 * only honor mesgout requests after we've sent our
		 * first byte.
		 */
		if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0
		 && ahc->msgout_index > 0)
			msgout_request = TRUE;
		else
			msgout_request = FALSE;

		if (msgout_request) {

			/*
			 * Change gears and see if
			 * this messages is of interest to
			 * us or should be passed back to
			 * the sequencer.
			 */
			ahc->msg_type = MSG_TYPE_TARGET_MSGOUT;
			ahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);
			ahc->msgin_index = 0;
			/* Dummy read to REQ for first byte */
			ahc_inb(ahc, SCSIDATL);
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
			break;
		}

		msgdone = ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
			end_session = TRUE;
			break;
		}

		/*
		 * Present the next byte on the bus.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
		break;
	}
	case MSG_TYPE_TARGET_MSGOUT:
	{
		int lastbyte;
		int msgdone;

		/*
		 * The initiator signals that this is
		 * the last byte by dropping ATN.
		 */
		lastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;

		/*
		 * Read the latched byte, but turn off SPIOEN first
		 * so that we don't inadvertently cause a REQ for the
		 * next byte.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);
		msgdone = ahc_parse_msg(ahc, &devinfo);
		if (msgdone == MSGLOOP_TERMINATED) {
			/*
			 * The message is *really* done in that it caused
			 * us to go to bus free.  The sequencer has already
			 * been reset at this point, so pull the ejection
			 * handle.
			 */
			return;
		}

		ahc->msgin_index++;

		/*
		 * XXX Read spec about initiator dropping ATN too soon
		 *     and use msgdone to detect it.
		 */
		if (msgdone == MSGLOOP_MSGCOMPLETE) {
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response, transition
			 * to the Message in phase and send it.
			 */
			if (ahc->msgout_len != 0) {
				ahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);
				ahc_outb(ahc, SXFRCTL0,
					 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
				ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
				ahc->msgin_index = 0;
				break;
			}
		}

		if (lastbyte)
			end_session = TRUE;
		else {
			/* Ask for the next byte. */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		}

		break;
	}
	default:
		panic("Unknown REQINIT message type");
	}

	if (end_session) {
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);
	} else
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
}

/*
 * See if we sent a particular extended message to the target.
 * If "full" is true, return true only if the target saw the full
 * message.  If "full" is false, return true if the target saw at
 * least the first byte of the message.
 */
static int
ahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type, u_int msgval, int full)
{
	int found;
	u_int index;

	found = FALSE;
	index = 0;

	while (index < ahc->msgout_len) {
		if (ahc->msgout_buf[index] == MSG_EXTENDED) {
			u_int end_index;

			end_index = index + 1 + ahc->msgout_buf[index + 1];
			if (ahc->msgout_buf[index+2] == msgval
			 && type == AHCMSG_EXT) {

				if (full) {
					if (ahc->msgout_index > end_index)
						found = TRUE;
				} else if (ahc->msgout_index > index)
					found = TRUE;
			}
			index = end_index;
		} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_TASK
			&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {

			/* Skip tag type and tag id or residue param*/
			index += 2;
		} else {
			/* Single byte message */
			if (type == AHCMSG_1B
			 && ahc->msgout_buf[index] == msgval
			 && ahc->msgout_index > index)
				found = TRUE;
			index++;
		}

		if (found)
			break;
	}
	return (found);
}

/*
 * Wait for a complete incoming message, parse it, and respond accordingly.
 */
static int
ahc_parse_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	int	reject;
	int	done;
	int	response;
	u_int	targ_scsirate;

	done = MSGLOOP_IN_PROG;
	response = FALSE;
	reject = FALSE;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	targ_scsirate = tinfo->scsirate;

	/*
	 * Parse as much of the message as is available,
	 * rejecting it if we don't support it.  When
	 * the entire message is available and has been
	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
	 * that we have parsed an entire message.
	 *
	 * In the case of extended messages, we accept the length
	 * byte outright and perform more checking once we know the
	 * extended message type.
	 */
	switch (ahc->msgin_buf[0]) {
	case MSG_DISCONNECT:
	case MSG_SAVEDATAPOINTER:
	case MSG_CMDCOMPLETE:
	case MSG_RESTOREPOINTERS:
	case MSG_IGN_WIDE_RESIDUE:
		/*
		 * End our message loop as these are messages
		 * the sequencer handles on its own.
		 */
		done = MSGLOOP_TERMINATED;
		break;
	case MSG_MESSAGE_REJECT:
		response = ahc_handle_msg_reject(ahc, devinfo);
		/* FALLTHROUGH */
	case MSG_NOOP:
		done = MSGLOOP_MSGCOMPLETE;
		break;
	case MSG_EXTENDED:
	{
		/* Wait for enough of the message to begin validation */
		if (ahc->msgin_index < 2)
			break;
		switch (ahc->msgin_buf[2]) {
		case MSG_EXT_SDTR:
		{
			struct	 ahc_syncrate *syncrate;
			u_int	 period;
			u_int	 ppr_options;
			u_int	 offset;
			u_int	 saved_offset;

			if (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
				reject = TRUE;
				break;
			}

			/*
			 * Wait until we have both args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_SDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))
				break;

			period = ahc->msgin_buf[3];
			ppr_options = 0;
			saved_offset = offset = ahc->msgin_buf[4];
			syncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,
							   &ppr_options,
							   devinfo->role);
			ahc_validate_offset(ahc, tinfo, syncrate, &offset,
					    targ_scsirate & WIDEXFER,
					    devinfo->role);
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received "
				       "SDTR period %x, offset %x\n\t"
				       "Filtered to period %x, offset %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       ahc->msgin_buf[3], saved_offset,
				       period, offset);
			}
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period,
					 offset, ppr_options,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE);

			/*
			 * See if we initiated Sync Negotiation
			 * and didn't have to fall down to async
			 * transfers.
			 */
			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, TRUE)) {
				/* We started it */
				if (saved_offset != offset) {
					/* Went too low - force async */
					reject = TRUE;
				}
			} else {
				/*
				 * Send our own SDTR in reply
				 */
				if (bootverbose
				 && devinfo->role == ROLE_INITIATOR) {
					printf("(%s:%c:%d:%d): Target "
					       "Initiated SDTR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_sdtr(ahc, devinfo,
						   period, offset);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		case MSG_EXT_WDTR:
		{
			u_int bus_width;
			u_int saved_width;
			u_int sending_reply;

			sending_reply = FALSE;
			if (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
				reject = TRUE;
				break;
			}

			/*
			 * Wait until we have our arg before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_WDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))
				break;

			bus_width = ahc->msgin_buf[3];
			saved_width = bus_width;
			ahc_validate_width(ahc, tinfo, &bus_width,
					   devinfo->role);
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received WDTR "
				       "%x filtered to %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       saved_width, bus_width);
			}

			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, TRUE)) {
				/*
				 * Don't send a WDTR back to the
				 * target, since we asked first.
				 * If the width went higher than our
				 * request, reject it.
				 */
				if (saved_width > bus_width) {
					reject = TRUE;
					printf("(%s:%c:%d:%d): requested %dBit "
					       "transfers.  Rejecting...\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun,
					       8 * (0x01 << bus_width));
					bus_width = 0;
				}
			} else {
				/*
				 * Send our own WDTR in reply
				 */
				if (bootverbose
				 && devinfo->role == ROLE_INITIATOR) {
					printf("(%s:%c:%d:%d): Target "
					       "Initiated WDTR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_wdtr(ahc, devinfo, bus_width);
				ahc->msgout_index = 0;
				response = TRUE;
				sending_reply = TRUE;
			}
			/*
			 * After a wide message, we are async, but
			 * some devices don't seem to honor this portion
			 * of the spec.  Force a renegotiation of the
			 * sync component of our transfer agreement even
			 * if our goal is async.  By updating our width
			 * after forcing the negotiation, we avoid
			 * renegotiating for width.
			 */
			ahc_update_neg_request(ahc, devinfo, tstate,
					       tinfo, AHC_NEG_ALWAYS);
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE);
			if (sending_reply == FALSE && reject == FALSE) {

				/*
				 * We will always have an SDTR to send.
				 */
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_build_transfer_msg(ahc, devinfo);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		case MSG_EXT_PPR:
		{
			struct	ahc_syncrate *syncrate;
			u_int	period;
			u_int	offset;
			u_int	bus_width;
			u_int	ppr_options;
			u_int	saved_width;
			u_int	saved_offset;
			u_int	saved_ppr_options;

			if (ahc->msgin_buf[1] != MSG_EXT_PPR_LEN) {
				reject = TRUE;
				break;
			}

			/*
			 * Wait until we have all args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_PPR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_PPR_LEN + 1))
				break;

			period = ahc->msgin_buf[3];
			offset = ahc->msgin_buf[5];
			bus_width = ahc->msgin_buf[6];
			saved_width = bus_width;
			ppr_options = ahc->msgin_buf[7];
			/*
			 * According to the spec, a DT only
			 * period factor with no DT option
			 * set implies async.
			 */
			if ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0
			 && period == 9)
				offset = 0;
			saved_ppr_options = ppr_options;
			saved_offset = offset;

			/*
			 * Mask out any options we don't support
			 * on any controller.  Transfer options are
			 * only available if we are negotiating wide.
			 */
			ppr_options &= MSG_EXT_PPR_DT_REQ;
			if (bus_width == 0)
				ppr_options = 0;

			ahc_validate_width(ahc, tinfo, &bus_width,
					   devinfo->role);
			syncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,
							   &ppr_options,
							   devinfo->role);
			ahc_validate_offset(ahc, tinfo, syncrate,
					    &offset, bus_width,
					    devinfo->role);

			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, TRUE)) {
				/*
				 * If we are unable to do any of the
				 * requested options (we went too low),
				 * then we'll have to reject the message.
				 */
				if (saved_width > bus_width
				 || saved_offset != offset
				 || saved_ppr_options != ppr_options) {
					reject = TRUE;
					period = 0;
					offset = 0;
					bus_width = 0;
					ppr_options = 0;
					syncrate = NULL;
				}
			} else {
				if (devinfo->role != ROLE_TARGET)
					printf("(%s:%c:%d:%d): Target "
					       "Initiated PPR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				else
					printf("(%s:%c:%d:%d): Initiator "
					       "Initiated PPR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_ppr(ahc, devinfo, period, offset,
						  bus_width, ppr_options);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received PPR width %x, "
				       "period %x, offset %x,options %x\n"
				       "\tFiltered to width %x, period %x, "
				       "offset %x, options %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       saved_width, ahc->msgin_buf[3],
				       saved_offset, saved_ppr_options,
				       bus_width, period, offset, ppr_options);
			}
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE);
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period,
					 offset, ppr_options,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE);
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		default:
			/* Unknown extended message.  Reject it. */
			reject = TRUE;
			break;
		}
		break;
	}
#ifdef AHC_TARGET_MODE
	case MSG_BUS_DEV_RESET:
		ahc_handle_devreset(ahc, devinfo,
				    CAM_BDR_SENT,
				    "Bus Device Reset Received",
				    /*verbose_level*/0);
		ahc_restart(ahc);
		done = MSGLOOP_TERMINATED;
		break;
	case MSG_ABORT_TAG:
	case MSG_ABORT:
	case MSG_CLEAR_QUEUE:
	{
		int tag;

		/* Target mode messages */
		if (devinfo->role != ROLE_TARGET) {
			reject = TRUE;
			break;
		}
		tag = SCB_LIST_NULL;
		if (ahc->msgin_buf[0] == MSG_ABORT_TAG)
			tag = ahc_inb(ahc, INITIATOR_TAG);
		ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       devinfo->lun, tag, ROLE_TARGET,
			       CAM_REQ_ABORTED);

		tstate = ahc->enabled_targets[devinfo->our_scsiid];
		if (tstate != NULL) {
			struct ahc_tmode_lstate* lstate;

			lstate = tstate->enabled_luns[devinfo->lun];
			if (lstate != NULL) {
				ahc_queue_lstate_event(ahc, lstate,
						       devinfo->our_scsiid,
						       ahc->msgin_buf[0],
						       /*arg*/tag);
				ahc_send_lstate_events(ahc, lstate);
			}
		}
		ahc_restart(ahc);
		done = MSGLOOP_TERMINATED;
		break;
	}
#endif
	case MSG_TERM_IO_PROC:
	default:
		reject = TRUE;
		break;
	}

	if (reject) {
		/*
		 * Setup to reject the message.
		 */
		ahc->msgout_index = 0;
		ahc->msgout_len = 1;
		ahc->msgout_buf[0] = MSG_MESSAGE_REJECT;
		done = MSGLOOP_MSGCOMPLETE;
		response = TRUE;
	}

	if (done != MSGLOOP_IN_PROG && !response)
		/* Clear the outgoing message buffer */
		ahc->msgout_len = 0;

	return (done);
}

/*
 * Process a message reject message.
 */
static int
ahc_handle_msg_reject(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	/*
	 * What we care about here is if we had an
	 * outstanding SDTR or WDTR message for this
	 * target.  If we did, this is a signal that
	 * the target is refusing negotiation.
	 */
	struct scb *scb;
	struct ahc_initiator_tinfo *tinfo;
	struct ahc_tmode_tstate *tstate;
	u_int scb_index;
	u_int last_msg;
	int   response = 0;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
	/* Might be necessary */
	last_msg = ahc_inb(ahc, LAST_MSG);

	if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, /*full*/FALSE)) {
		/*
		 * Target does not support the PPR message.
		 * Attempt to negotiate SPI-2 style.
		 */
		if (bootverbose) {
			printf("(%s:%c:%d:%d): PPR Rejected. "
			       "Trying WDTR/SDTR\n",
			       ahc_name(ahc), devinfo->channel,
			       devinfo->target, devinfo->lun);
		}
		tinfo->goal.ppr_options = 0;
		tinfo->curr.transport_version = 2;
		tinfo->goal.transport_version = 2;
		ahc->msgout_index = 0;
		ahc->msgout_len = 0;
		ahc_build_transfer_msg(ahc, devinfo);
		ahc->msgout_index = 0;
		response = 1;
	} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, /*full*/FALSE)) {

		/* note 8bit xfers */
		printf("(%s:%c:%d:%d): refuses WIDE negotiation.  Using "
		       "8bit transfers\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target, devinfo->lun);
		ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
			      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
			      /*paused*/TRUE);
		/*
		 * No need to clear the sync rate.  If the target
		 * did not accept the command, our syncrate is
		 * unaffected.  If the target started the negotiation,
		 * but rejected our response, we already cleared the
		 * sync rate before sending our WDTR.
		 */
		if (tinfo->goal.offset != tinfo->curr.offset) {

			/* Start the sync negotiation */
			ahc->msgout_index = 0;
			ahc->msgout_len = 0;
			ahc_build_transfer_msg(ahc, devinfo);
			ahc->msgout_index = 0;
			response = 1;
		}
	} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, /*full*/FALSE)) {
		/* note asynch xfers and clear flag */
		ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL, /*period*/0,
				 /*offset*/0, /*ppr_options*/0,
				 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				 /*paused*/TRUE);
		printf("(%s:%c:%d:%d): refuses synchronous negotiation. "
		       "Using asynchronous transfers\n",
		       ahc_name(ahc), devinfo->channel,
		       devinfo->target, devinfo->lun);
	} else if ((scb->hscb->control & MSG_SIMPLE_TASK) != 0) {
		int tag_type;
		int mask;

		tag_type = (scb->hscb->control & MSG_SIMPLE_TASK);

		if (tag_type == MSG_SIMPLE_TASK) {
			printf("(%s:%c:%d:%d): refuses tagged commands.  "
			       "Performing non-tagged I/O\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target, devinfo->lun);
			ahc_set_tags(ahc, devinfo, AHC_QUEUE_NONE);
			mask = ~0x23;
		} else {
			printf("(%s:%c:%d:%d): refuses %s tagged commands.  "
			       "Performing simple queue tagged I/O only\n",
			       ahc_name(ahc), devinfo->channel, devinfo->target,
			       devinfo->lun, tag_type == MSG_ORDERED_TASK
			       ? "ordered" : "head of queue");
			ahc_set_tags(ahc, devinfo, AHC_QUEUE_BASIC);
			mask = ~0x03;
		}

		/*
		 * Resend the identify for this CCB as the target
		 * may believe that the selection is invalid otherwise.
		 */
		ahc_outb(ahc, SCB_CONTROL,
			 ahc_inb(ahc, SCB_CONTROL) & mask);
		scb->hscb->control &= mask;
		ahc_set_transaction_tag(scb, /*enabled*/FALSE,
					/*type*/MSG_SIMPLE_TASK);
		ahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);
		ahc_assert_atn(ahc);

		/*
		 * This transaction is now at the head of
		 * the untagged queue for this target.
		 */
		if ((ahc->flags & AHC_SCB_BTT) == 0) {
			struct scb_tailq *untagged_q;

			untagged_q =
			    &(ahc->untagged_queues[devinfo->target_offset]);
			TAILQ_INSERT_HEAD(untagged_q, scb, links.tqe);
			scb->flags |= SCB_UNTAGGEDQ;
		}
		ahc_busy_tcl(ahc, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),
			     scb->hscb->tag);

		/*
		 * Requeue all tagged commands for this target
		 * currently in our possession so they can be
		 * converted to untagged commands.
		 */
		ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
				   SCB_GET_CHANNEL(ahc, scb),
				   SCB_GET_LUN(scb), /*tag*/SCB_LIST_NULL,
				   ROLE_INITIATOR, CAM_REQUEUE_REQ,
				   SEARCH_COMPLETE);
	} else {
		/*
		 * Otherwise, we ignore it.
		 */
		printf("%s:%c:%d: Message reject for %x -- ignored\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       last_msg);
	}
	return (response);
}

/*
 * Process an ingnore wide residue message.
 */
static void
ahc_handle_ign_wide_residue(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	u_int scb_index;
	struct scb *scb;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	/*
	 * XXX Actually check data direction in the sequencer?
	 * Perhaps add datadir to some spare bits in the hscb?
	 */
	if ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0
	 || ahc_get_transfer_dir(scb) != CAM_DIR_IN) {
		/*
		 * Ignore the message if we haven't
		 * seen an appropriate data phase yet.
		 */
	} else {
		/*
		 * If the residual occurred on the last
		 * transfer and the transfer request was
		 * expected to end on an odd count, do
		 * nothing.  Otherwise, subtract a byte
		 * and update the residual count accordingly.
		 */
		uint32_t sgptr;

		sgptr = ahc_inb(ahc, SCB_RESIDUAL_SGPTR);
		if ((sgptr & SG_LIST_NULL) != 0
		 && (ahc_inb(ahc, SCB_LUN) & SCB_XFERLEN_ODD) != 0) {
			/*
			 * If the residual occurred on the last
			 * transfer and the transfer request was
			 * expected to end on an odd count, do
			 * nothing.
			 */
		} else {
			struct ahc_dma_seg *sg;
			uint32_t data_cnt;
			uint32_t data_addr;
			uint32_t sglen;

			/* Pull in all of the sgptr */
			sgptr = ahc_inl(ahc, SCB_RESIDUAL_SGPTR);
			data_cnt = ahc_inl(ahc, SCB_RESIDUAL_DATACNT);

			if ((sgptr & SG_LIST_NULL) != 0) {
				/*
				 * The residual data count is not updated
				 * for the command run to completion case.
				 * Explicitly zero the count.
				 */
				data_cnt &= ~AHC_SG_LEN_MASK;
			}

			data_addr = ahc_inl(ahc, SHADDR);

			data_cnt += 1;
			data_addr -= 1;
			sgptr &= SG_PTR_MASK;

			sg = ahc_sg_bus_to_virt(scb, sgptr);

			/*
			 * The residual sg ptr points to the next S/G
			 * to load so we must go back one.
			 */
			sg--;
			sglen = aic_le32toh(sg->len) & AHC_SG_LEN_MASK;
			if (sg != scb->sg_list
			 && sglen < (data_cnt & AHC_SG_LEN_MASK)) {

				sg--;
				sglen = aic_le32toh(sg->len);
				/*
				 * Preserve High Address and SG_LIST bits
				 * while setting the count to 1.
				 */
				data_cnt = 1 | (sglen & (~AHC_SG_LEN_MASK));
				data_addr = aic_le32toh(sg->addr)
					  + (sglen & AHC_SG_LEN_MASK) - 1;

				/*
				 * Increment sg so it points to the
				 * "next" sg.
				 */
				sg++;
				sgptr = ahc_sg_virt_to_bus(scb, sg);
			}
			ahc_outl(ahc, SCB_RESIDUAL_SGPTR, sgptr);
			ahc_outl(ahc, SCB_RESIDUAL_DATACNT, data_cnt);
			/*
			 * Toggle the "oddness" of the transfer length
			 * to handle this mid-transfer ignore wide
			 * residue.  This ensures that the oddness is
			 * correct for subsequent data transfers.
			 */
			ahc_outb(ahc, SCB_LUN,
				 ahc_inb(ahc, SCB_LUN) ^ SCB_XFERLEN_ODD);
		}
	}
}


/*
 * Reinitialize the data pointers for the active transfer
 * based on its current residual.
 */
static void
ahc_reinitialize_dataptrs(struct ahc_softc *ahc)
{
	struct	 scb *scb;
	struct	 ahc_dma_seg *sg;
	u_int	 scb_index;
	uint32_t sgptr;
	uint32_t resid;
	uint32_t dataptr;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	sgptr = (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
	      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
	      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8)
	      |	ahc_inb(ahc, SCB_RESIDUAL_SGPTR);

	sgptr &= SG_PTR_MASK;
	sg = ahc_sg_bus_to_virt(scb, sgptr);

	/* The residual sg_ptr always points to the next sg */
	sg--;

	resid = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 2) << 16)
	      | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 1) << 8)
	      | ahc_inb(ahc, SCB_RESIDUAL_DATACNT);

	dataptr = aic_le32toh(sg->addr)
		+ (aic_le32toh(sg->len) & AHC_SG_LEN_MASK)
		- resid;
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		u_int dscommand1;

		dscommand1 = ahc_inb(ahc, DSCOMMAND1);
		ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
		ahc_outb(ahc, HADDR,
			 (aic_le32toh(sg->len) >> 24) & SG_HIGH_ADDR_BITS);
		ahc_outb(ahc, DSCOMMAND1, dscommand1);
	}
	ahc_outb(ahc, HADDR + 3, dataptr >> 24);
	ahc_outb(ahc, HADDR + 2, dataptr >> 16);
	ahc_outb(ahc, HADDR + 1, dataptr >> 8);
	ahc_outb(ahc, HADDR, dataptr);
	ahc_outb(ahc, HCNT + 2, resid >> 16);
	ahc_outb(ahc, HCNT + 1, resid >> 8);
	ahc_outb(ahc, HCNT, resid);
	if ((ahc->features & AHC_ULTRA2) == 0) {
		ahc_outb(ahc, STCNT + 2, resid >> 16);
		ahc_outb(ahc, STCNT + 1, resid >> 8);
		ahc_outb(ahc, STCNT, resid);
	}
}

/*
 * Handle the effects of issuing a bus device reset message.
 */
static void
ahc_handle_devreset(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		    cam_status status, char *message, int verbose_level)
{
#ifdef AHC_TARGET_MODE
	struct ahc_tmode_tstate* tstate;
	u_int lun;
#endif
	int found;

	found = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       CAM_LUN_WILDCARD, SCB_LIST_NULL, devinfo->role,
			       status);

#ifdef AHC_TARGET_MODE
	/*
	 * Send an immediate notify ccb to all target mord peripheral
	 * drivers affected by this action.
	 */
	tstate = ahc->enabled_targets[devinfo->our_scsiid];
	if (tstate != NULL) {
		for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
			struct ahc_tmode_lstate* lstate;

			lstate = tstate->enabled_luns[lun];
			if (lstate == NULL)
				continue;

			ahc_queue_lstate_event(ahc, lstate, devinfo->our_scsiid,
					       MSG_BUS_DEV_RESET, /*arg*/0);
			ahc_send_lstate_events(ahc, lstate);
		}
	}
#endif

	/*
	 * Go back to async/narrow transfers and renegotiate.
	 */
	ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
		      AHC_TRANS_CUR, /*paused*/TRUE);
	ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,
			 /*period*/0, /*offset*/0, /*ppr_options*/0,
			 AHC_TRANS_CUR, /*paused*/TRUE);

	if (status != CAM_SEL_TIMEOUT)
		ahc_send_async(ahc, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_SENT_BDR, NULL);

	if (message != NULL
	 && (verbose_level <= bootverbose))
		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahc_name(ahc),
		       message, devinfo->channel, devinfo->target, found);
}

#ifdef AHC_TARGET_MODE
static void
ahc_setup_target_msgin(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		       struct scb *scb)
{

	/*
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)
		ahc_build_transfer_msg(ahc, devinfo);
	else
		panic("ahc_intr: AWAITING target message with no message");

	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
}
#endif

int
ahc_softc_init(struct ahc_softc *ahc)
{

	/* The IRQMS bit is only valid on VL and EISA chips */
	if ((ahc->chip & AHC_PCI) == 0)
		ahc->unpause = ahc_inb(ahc, HCNTRL) & IRQMS;
	else
		ahc->unpause = 0;
	ahc->pause = ahc->unpause | PAUSE;
	/* XXX The shared scb data stuff should be deprecated */
	if (ahc->scb_data == NULL) {
		ahc->scb_data = malloc(sizeof(*ahc->scb_data), M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (ahc->scb_data == NULL)
			return (ENOMEM);
	}

	return (0);
}

void
ahc_softc_insert(struct ahc_softc *ahc)
{
	struct ahc_softc *list_ahc;

#if AHC_PCI_CONFIG > 0
	/*
	 * Second Function PCI devices need to inherit some
	 * settings from function 0.
	 */
	if ((ahc->chip & AHC_BUS_MASK) == AHC_PCI
	 && (ahc->features & AHC_MULTI_FUNC) != 0) {
		TAILQ_FOREACH(list_ahc, &ahc_tailq, links) {
			ahc_dev_softc_t list_pci;
			ahc_dev_softc_t pci;

			list_pci = list_ahc->dev_softc;
			pci = ahc->dev_softc;
			if (ahc_get_pci_slot(list_pci) == ahc_get_pci_slot(pci)
			 && ahc_get_pci_bus(list_pci) == ahc_get_pci_bus(pci)) {
				struct ahc_softc *master;
				struct ahc_softc *slave;

				if (ahc_get_pci_function(list_pci) == 0) {
					master = list_ahc;
					slave = ahc;
				} else {
					master = ahc;
					slave = list_ahc;
				}
				slave->flags &= ~AHC_BIOS_ENABLED;
				slave->flags |=
				    master->flags & AHC_BIOS_ENABLED;
				slave->flags &= ~AHC_PRIMARY_CHANNEL;
				slave->flags |=
				    master->flags & AHC_PRIMARY_CHANNEL;
				break;
			}
		}
	}
#endif

	/*
	 * Insertion sort into our list of softcs.
	 */
	list_ahc = TAILQ_FIRST(&ahc_tailq);
	while (list_ahc != NULL
	    && ahc_softc_comp(ahc, list_ahc) <= 0)
		list_ahc = TAILQ_NEXT(list_ahc, links);
	if (list_ahc != NULL)
		TAILQ_INSERT_BEFORE(list_ahc, ahc, links);
	else
		TAILQ_INSERT_TAIL(&ahc_tailq, ahc, links);
	ahc->init_level++;
}

void
ahc_set_unit(struct ahc_softc *ahc, int unit)
{
	ahc->unit = unit;
}

void
ahc_set_name(struct ahc_softc *ahc, char *name)
{
	if (ahc->name != NULL)
		free(ahc->name, M_DEVBUF, 0);
	ahc->name = name;
}

void
ahc_free(struct ahc_softc *ahc)
{
	int i;

	switch (ahc->init_level) {
	default:
	case 2:
		ahc_shutdown(ahc);
		/* FALLTHROUGH */
	case 1:
		bus_dmamap_unload(ahc->parent_dmat, ahc->shared_data_dmamap);
		bus_dmamap_destroy(ahc->parent_dmat, ahc->shared_data_dmamap);
		bus_dmamem_unmap(ahc->parent_dmat, (caddr_t)ahc->qoutfifo, ahc->shared_data_size);
		bus_dmamem_free(ahc->parent_dmat, &ahc->shared_data_seg, ahc->shared_data_nseg);
		break;
	case 0:
		break;
	}

	ahc_platform_free(ahc);
	ahc_fini_scbdata(ahc);
	for (i = 0; i < AHC_NUM_TARGETS; i++) {
		struct ahc_tmode_tstate *tstate;

		tstate = ahc->enabled_targets[i];
		if (tstate != NULL) {
#ifdef AHC_TARGET_MODE
			int j;

			for (j = 0; j < AHC_NUM_LUNS; j++) {
				struct ahc_tmode_lstate *lstate;

				lstate = tstate->enabled_luns[j];
				if (lstate != NULL) {
					  /*xpt_free_path(lstate->path);*/
					free(lstate, M_DEVBUF, 0);
				}
			}
#endif
			free(tstate, M_DEVBUF, 0);
		}
	}
#ifdef AHC_TARGET_MODE
	if (ahc->black_hole != NULL) {
	  /*xpt_free_path(ahc->black_hole->path);*/
		free(ahc->black_hole, M_DEVBUF, 0);
	}
#endif
	if (ahc->seep_config != NULL)
		free(ahc->seep_config, M_DEVBUF, 0);
	return;
}

void
ahc_shutdown(void *arg)
{
	struct	ahc_softc *ahc;
	int	i;

	ahc = (struct ahc_softc *)arg;

	/* This will reset most registers to 0, but not all */
	ahc_reset(ahc, /*reinit*/FALSE);
	ahc_outb(ahc, SCSISEQ, 0);
	ahc_outb(ahc, SXFRCTL0, 0);
	ahc_outb(ahc, DSPCISTATUS, 0);

	for (i = TARG_SCSIRATE; i < SCSICONF; i++)
		ahc_outb(ahc, i, 0);
}

/*
 * Reset the controller and record some information about it
 * that is only available just after a reset.  If "reinit" is
 * non-zero, this reset occured after initial configuration
 * and the caller requests that the chip be fully reinitialized
 * to a runable state.  Chip interrupts are *not* enabled after
 * a reinitialization.  The caller must enable interrupts via
 * ahc_intr_enable().
 */
int
ahc_reset(struct ahc_softc *ahc, int reinit)
{
	u_int	sblkctl;
	u_int	sxfrctl1_a, sxfrctl1_b;
	int	error;
	int	wait;

	/*
	 * Preserve the value of the SXFRCTL1 register for all channels.
	 * It contains settings that affect termination and we don't want
	 * to disturb the integrity of the bus.
	 */
	ahc_pause(ahc);
	sxfrctl1_b = 0;
	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7770) {
		/*
		 * Save channel B's settings in case this chip
		 * is setup for TWIN channel operation.
		 */
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		sxfrctl1_b = ahc_inb(ahc, SXFRCTL1);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	sxfrctl1_a = ahc_inb(ahc, SXFRCTL1);

	ahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);

	/*
	 * Ensure that the reset has finished.  We delay 1000us
	 * prior to reading the register to make sure the chip
	 * has sufficiently completed its reset to handle register
	 * accesses.
	 */
	wait = 1000;
	do {
		aic_delay(1000);
	} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));

	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", ahc_name(ahc));
	}
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/* Determine channel configuration */
	sblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);
	/* No Twin Channel PCI cards */
	if ((ahc->chip & AHC_PCI) != 0)
		sblkctl &= ~SELBUSB;
	switch (sblkctl) {
	case 0:
		/* Single Narrow Channel */
		break;
	case SELWIDE:
		/* Wide Channel */
		ahc->features |= AHC_WIDE;
		break;
	case SELBUSB:
		/* Twin Channel */
		ahc->features |= AHC_TWIN;
		break;
	default:
		printf(" Unsupported adapter type (0x%x).  Ignoring\n", sblkctl);
		return(-1);
	}

	/*
	 * Reload sxfrctl1.
	 *
	 * We must always initialize STPWEN to 1 before we
	 * restore the saved values.  STPWEN is initialized
	 * to a tri-state condition which can only be cleared
	 * by turning it on.
	 */
	if ((ahc->features & AHC_TWIN) != 0) {
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		ahc_outb(ahc, SXFRCTL1, sxfrctl1_b);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	ahc_outb(ahc, SXFRCTL1, sxfrctl1_a);

	error = 0;
	if (reinit != 0)
		/*
		 * If a recovery action has forced a chip reset,
		 * re-initialize the chip to our liking.
		 */
		error = ahc->bus_chip_init(ahc);
#ifdef AHC_DUMP_SEQ
	else
		ahc_dumpseq(ahc);
#endif

	return (error);
}

/*
 * Determine the number of SCBs available on the controller
 */
int
ahc_probe_scbs(struct ahc_softc *ahc) {
	int i;

	for (i = 0; i < AHC_SCB_MAX; i++) {

		ahc_outb(ahc, SCBPTR, i);
		ahc_outb(ahc, SCB_BASE, i);
		if (ahc_inb(ahc, SCB_BASE) != i)
			break;
		ahc_outb(ahc, SCBPTR, 0);
		if (ahc_inb(ahc, SCB_BASE) != 0)
			break;
	}
	return (i);
}

#if 0
static void
ahc_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error)
{
	bus_addr_t *baddr;

	baddr = (bus_addr_t *)arg;
	*baddr = segs->ds_addr;
}
#endif

static void
ahc_build_free_scb_list(struct ahc_softc *ahc)
{
	int scbsize;
	int i;

	scbsize = 32;
	if ((ahc->flags & AHC_LSCBS_ENABLED) != 0)
		scbsize = 64;

	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		int j;

		ahc_outb(ahc, SCBPTR, i);

		/*
		 * Touch all SCB bytes to avoid parity errors
		 * should one of our debugging routines read
		 * an otherwise uninitiatlized byte.
		 */
		for (j = 0; j < scbsize; j++)
			ahc_outb(ahc, SCB_BASE+j, 0xFF);

		/* Clear the control byte. */
		ahc_outb(ahc, SCB_CONTROL, 0);

		/* Set the next pointer */
		if ((ahc->flags & AHC_PAGESCBS) != 0)
			ahc_outb(ahc, SCB_NEXT, i+1);
		else
			ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);

		/* Make the tag number, SCSIID, and lun invalid */
		ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
		ahc_outb(ahc, SCB_SCSIID, 0xFF);
		ahc_outb(ahc, SCB_LUN, 0xFF);
	}

	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		/* SCB 0 heads the free list. */
		ahc_outb(ahc, FREE_SCBH, 0);
	} else {
		/* No free list. */
		ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	}

	/* Make sure that the last SCB terminates the free list */
	ahc_outb(ahc, SCBPTR, i-1);
	ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);
}

static int
ahc_init_scbdata(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;
	int i;

	scb_data = ahc->scb_data;
	SLIST_INIT(&scb_data->free_scbs);
	SLIST_INIT(&scb_data->sg_maps);

	mtx_init(&ahc->sc_scb_mtx, IPL_BIO);
	scsi_iopool_init(&ahc->sc_iopool, ahc, ahc_scb_alloc, ahc_scb_free);

	/* Allocate SCB resources */
	scb_data->scbarray = mallocarray(AHC_SCB_MAX_ALLOC, sizeof(struct scb),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (scb_data->scbarray == NULL)
		return (ENOMEM);

	/* Determine the number of hardware SCBs and initialize them */

	scb_data->maxhscbs = ahc_probe_scbs(ahc);
	if (ahc->scb_data->maxhscbs == 0) {
		printf("%s: No SCB space found\n", ahc_name(ahc));
		return (ENXIO);
	}

	/*
	 * Create our DMA tags.  These tags define the kinds of device
	 * accessible memory allocations and memory mappings we will
	 * need to perform during normal operation.
	 *
	 * Unless we need to further restrict the allocation, we rely
	 * on the restrictions of the parent dmat, hence the common
	 * use of MAXADDR and MAXSIZE.
	 */

	if (ahc_createdmamem(ahc->parent_dmat,
	     AHC_SCB_MAX * sizeof(struct hardware_scb), ahc->sc_dmaflags,
	     &scb_data->hscb_dmamap,
	     (caddr_t *)&scb_data->hscbs, &scb_data->hscb_busaddr,
	     &scb_data->hscb_seg, &scb_data->hscb_nseg, ahc_name(ahc),
	     "hardware SCB structures") < 0)
		goto error_exit;

	scb_data->init_level++;

	if (ahc_createdmamem(ahc->parent_dmat,
	     AHC_SCB_MAX * sizeof(struct scsi_sense_data), ahc->sc_dmaflags,
	     &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,
	     &scb_data->sense_busaddr, &scb_data->sense_seg,
	     &scb_data->sense_nseg, ahc_name(ahc), "sense buffers") < 0)
		goto error_exit;

	scb_data->init_level++;

	/* Perform initial CCB allocation */
	memset(scb_data->hscbs, 0,
	       AHC_SCB_MAX_ALLOC * sizeof(struct hardware_scb));
	do {
		i = scb_data->numscbs;
		ahc_alloc_scbs(ahc);
	} while ((i != scb_data->numscbs) &&
	    (scb_data->numscbs < AHC_SCB_MAX_ALLOC));

	if (scb_data->numscbs != AHC_SCB_MAX_ALLOC) {
		printf("%s: ahc_init_scbdata - "
		       "Unable to allocate initial scbs\n",
		       ahc_name(ahc));
		goto error_exit;
	}

	/*
	 * Reserve the next queued SCB.
	 */
	ahc->next_queued_scb = scsi_io_get(&ahc->sc_iopool,
	    SCSI_POLL | SCSI_NOSLEEP);
	if (ahc->next_queued_scb != NULL)
		/* Note that we were successful */
		return (0);

error_exit:

	return (ENOMEM);
}

static void
ahc_fini_scbdata(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;

	scb_data = ahc->scb_data;
	if (scb_data == NULL)
		return;

	switch (scb_data->init_level) {
	default:
	case 5:
	{
		struct sg_map_node *sg_map;

		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
			ahc_freedmamem(ahc->parent_dmat, PAGE_SIZE,
			    sg_map->sg_dmamap, (caddr_t)sg_map->sg_vaddr,
			    &sg_map->sg_dmasegs, sg_map->sg_nseg);
			free(sg_map, M_DEVBUF, 0);
		}
	}
	/*FALLTHROUGH*/
	case 4:
		ahc_freedmamem(ahc->parent_dmat,
		    AHC_SCB_MAX * sizeof(struct scsipi_sense_data),
		    scb_data->sense_dmamap, (caddr_t)scb_data->sense,
		    &scb_data->sense_seg, scb_data->sense_nseg);
	/*FALLTHROUGH*/
	case 3:
		ahc_freedmamem(ahc->parent_dmat,
		    AHC_SCB_MAX * sizeof(struct hardware_scb),
		    scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,
		    &scb_data->hscb_seg, scb_data->hscb_nseg);
	/*FALLTHROUGH*/
	case 2:
	case 1:
	case 0:
		break;
	}
	if (scb_data->scbarray != NULL)
		free(scb_data->scbarray, M_DEVBUF, 0);
}

void
ahc_alloc_scbs(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;
	struct scb *next_scb;
	struct sg_map_node *sg_map;
	bus_addr_t physaddr;
	struct ahc_dma_seg *segs;
	int newcount;
	int i;

	scb_data = ahc->scb_data;
	if (scb_data->numscbs >= AHC_SCB_MAX_ALLOC)
		/* Can't allocate any more */
		return;

	next_scb = &scb_data->scbarray[scb_data->numscbs];

	sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);

	if (sg_map == NULL)
		return;

	/* Allocate S/G space for the next batch of SCBS */
	if (ahc_createdmamem(ahc->parent_dmat, PAGE_SIZE, ahc->sc_dmaflags,
			     &sg_map->sg_dmamap,
			     (caddr_t *)&sg_map->sg_vaddr, &sg_map->sg_physaddr,
			     &sg_map->sg_dmasegs, &sg_map->sg_nseg, ahc_name(ahc),
			     "SG space") < 0) {
		free(sg_map, M_DEVBUF, 0);
		return;
	}

	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);

	segs = sg_map->sg_vaddr;
	physaddr = sg_map->sg_physaddr;

	newcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));
	newcount = MIN(newcount, (AHC_SCB_MAX_ALLOC - scb_data->numscbs));
	for (i = 0; i < newcount; i++) {
		struct scb_platform_data *pdata = NULL;
		int error;

		if (sizeof(*pdata) > 0) {
			pdata = malloc(sizeof(*pdata), M_DEVBUF,
			    M_NOWAIT | M_ZERO);
			if (pdata == NULL)
				break;
		}

		next_scb->platform_data = pdata;
		next_scb->sg_map = sg_map;
		next_scb->sg_list = segs;
		/*
		 * The sequencer always starts with the second entry.
		 * The first entry is embedded in the scb.
		 */
		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
		next_scb->ahc_softc = ahc;
		next_scb->flags = SCB_FLAG_NONE;

		error = bus_dmamap_create(ahc->parent_dmat,
			  AHC_MAXTRANSFER_SIZE, AHC_NSEG, MAXPHYS, 0,
			  BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW|ahc->sc_dmaflags,
			  &next_scb->dmamap);
		if (error != 0)
			break;

		next_scb->hscb = &scb_data->hscbs[scb_data->numscbs];
		next_scb->hscb->tag = ahc->scb_data->numscbs;
		mtx_enter(&ahc->sc_scb_mtx);
		SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs,
				  next_scb, links.sle);
		mtx_leave(&ahc->sc_scb_mtx);
		segs += AHC_NSEG;
		physaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));
		next_scb++;
		ahc->scb_data->numscbs++;
	}
}

#ifndef DEBUG
void
ahc_controller_info(struct ahc_softc *ahc, char *buf, size_t buf_len)
{
	int len = 0;

	snprintf(buf + len, buf_len - len, "%s: ",
		 ahc_chip_names[ahc->chip & AHC_CHIPID_MASK]);
	len = strlen(buf);
	if ((ahc->features & AHC_TWIN) != 0)
		snprintf(buf + len, buf_len - len,
			 "Twin Channel, primary %c, ",
			 (ahc->flags & AHC_PRIMARY_CHANNEL) + 'A');
	else {
		const char *speed;
		const char *type;

		speed = "";
		if ((ahc->features & AHC_ULTRA) != 0) {
			speed = "Ultra ";
		} else if ((ahc->features & AHC_DT) != 0) {
			speed = "Ultra160 ";
		} else if ((ahc->features & AHC_ULTRA2) != 0) {
			speed = "Ultra2 ";
		}
		if ((ahc->features & AHC_WIDE) != 0) {
			type = "Wide";
		} else {
			type = "Single";
		}
		snprintf(buf + len, buf_len - len,
			 "%s%s Channel %c, ",
			 speed, type, ahc->channel);
	}
	len = strlen(buf);

	if ((ahc->flags & AHC_PAGESCBS) != 0)
		snprintf(buf + len, buf_len - len, "%d/%d SCBs",
			 ahc->scb_data->maxhscbs, AHC_MAX_QUEUE);
	else
		snprintf(buf + len, buf_len - len, "%d SCBs",
			 ahc->scb_data->maxhscbs);
}
#endif /* !DEBUG */

int
ahc_chip_init(struct ahc_softc *ahc)
{
	int	 term;
	int	 error;
	u_int	 i;
	u_int	 scsi_conf;
	u_int	 scsiseq_template;
	uint32_t physaddr;

	ahc_outb(ahc, SEQ_FLAGS, 0);
	ahc_outb(ahc, SEQ_FLAGS2, 0);

	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
	if (ahc->features & AHC_TWIN) {

		/*
		 * Setup Channel B first.
		 */
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		term = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;
		ahc_outb(ahc, SCSIID, ahc->our_id_b);
		scsi_conf = ahc_inb(ahc, SCSICONF + 1);
		ahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))
					|term|ahc->seltime_b|ENSTIMER|ACTNEGEN);
		if ((ahc->features & AHC_ULTRA2) != 0)
			ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
		ahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
		ahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);

		/* Select Channel A */
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
	}
	term = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);
	else
		ahc_outb(ahc, SCSIID, ahc->our_id);
	scsi_conf = ahc_inb(ahc, SCSICONF);
	ahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))
				|term|ahc->seltime
				|ENSTIMER|ACTNEGEN);
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
	ahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
	ahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);

	/* There are no untagged SCBs active yet. */
	for (i = 0; i < 16; i++) {
		ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, 0));
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			int lun;

			/*
			 * The SCB based BTT allows an entry per
			 * target and lun pair.
			 */
			for (lun = 1; lun < AHC_NUM_LUNS; lun++)
				ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, lun));
		}
	}

	/* All of our queues are empty */
	for (i = 0; i < 256; i++)
		ahc->qoutfifo[i] = SCB_LIST_NULL;
#ifdef __sgi__
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
#else
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREREAD);
#endif
	for (i = 0; i < 256; i++)
		ahc->qinfifo[i] = SCB_LIST_NULL;

	if ((ahc->features & AHC_MULTI_TID) != 0) {
		ahc_outb(ahc, TARGID, 0);
		ahc_outb(ahc, TARGID + 1, 0);
	}

	/*
	 * Tell the sequencer where it can find our arrays in memory.
	 */
	physaddr = ahc->scb_data->hscb_busaddr;
	ahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);

	physaddr = ahc->shared_data_busaddr;
	ahc_outb(ahc, SHARED_DATA_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 3, (physaddr >> 24) & 0xFF);

	/*
	 * Initialize the group code to command length table.
	 * This overrides the values in TARG_SCSIRATE, so only
	 * setup the table after we have processed that information.
	 */
	ahc_outb(ahc, CMDSIZE_TABLE, 5);
	ahc_outb(ahc, CMDSIZE_TABLE + 1, 9);
	ahc_outb(ahc, CMDSIZE_TABLE + 2, 9);
	ahc_outb(ahc, CMDSIZE_TABLE + 3, 0);
	ahc_outb(ahc, CMDSIZE_TABLE + 4, 15);
	ahc_outb(ahc, CMDSIZE_TABLE + 5, 11);
	ahc_outb(ahc, CMDSIZE_TABLE + 6, 0);
	ahc_outb(ahc, CMDSIZE_TABLE + 7, 0);

	if ((ahc->features & AHC_HS_MAILBOX) != 0)
		ahc_outb(ahc, HS_MAILBOX, 0);

	/* Tell the sequencer of our initial queue positions */
	if ((ahc->features & AHC_TARGETMODE) != 0) {
		ahc->tqinfifonext = 1;
		ahc_outb(ahc, KERNEL_TQINPOS, ahc->tqinfifonext - 1);
		ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
	}
	ahc->qinfifonext = 0;
	ahc->qoutfifonext = 0;
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
		ahc_outb(ahc, SNSCB_QOFF, ahc->qinfifonext);
		ahc_outb(ahc, SDSCB_QOFF, 0);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
		ahc_outb(ahc, QINPOS, ahc->qinfifonext);
		ahc_outb(ahc, QOUTPOS, ahc->qoutfifonext);
	}

	/* We don't have any waiting selections */
	ahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);

	/* Our disconnection list is empty too */
	ahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);

	/* Message out buffer starts empty */
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);

	/*
	 * Setup the allowed SCSI Sequences based on operational mode.
	 * If we are a target, we'll enable select in operations once
	 * we've had a lun enabled.
	 */
	scsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;
	if ((ahc->flags & AHC_INITIATORROLE) != 0)
		scsiseq_template |= ENRSELI;
	ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);

	/* Initialize our list of free SCBs. */
	ahc_build_free_scb_list(ahc);

	/*
	 * Tell the sequencer which SCB will be the next one it receives.
	 */
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);

	/*
	 * Load the Sequencer program and Enable the adapter
	 * in "fast" mode.
	 */
	if (bootverbose)
		printf("%s: Downloading Sequencer Program...",
		       ahc_name(ahc));

	error = ahc_loadseq(ahc);
	if (error != 0)
		return (error);

	if ((ahc->features & AHC_ULTRA2) != 0) {
		int wait;

		/*
		 * Wait for up to 500ms for our transceivers
		 * to settle.  If the adapter does not have
		 * a cable attached, the transceivers may
		 * never settle, so don't complain if we
		 * fail here.
		 */
		for (wait = 5000;
		     (ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
		     wait--)
			aic_delay(100);
	}
	ahc_restart(ahc);
	return (0);
}

/*
 * Start the board, ready for normal operation
 */
int
ahc_init(struct ahc_softc *ahc)
{
	int	 max_targ;
	u_int	 i;
	u_int	 scsi_conf;
	u_int	 ultraenb;
	u_int	 discenable;
	u_int	 tagenable;
	size_t	 driver_data_size;

#ifdef AHC_DEBUG
	if ((ahc_debug & AHC_DEBUG_SEQUENCER) != 0)
		ahc->flags |= AHC_SEQUENCER_DEBUG;
#endif

#ifdef AHC_PRINT_SRAM
	printf("Scratch Ram:");
	for (i = 0x20; i < 0x5f; i++) {
		if (((i % 8) == 0) && (i != 0)) {
			printf ("\n              ");
		}
		printf (" 0x%x", ahc_inb(ahc, i));
	}
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0x70; i < 0x7f; i++) {
			if (((i % 8) == 0) && (i != 0)) {
				printf ("\n              ");
			}
			printf (" 0x%x", ahc_inb(ahc, i));
		}
	}
	printf ("\n");
	/*
	 * Reading uninitialized scratch ram may
	 * generate parity errors.
	 */
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
#endif
	max_targ = 15;

	/*
	 * Assume we have a board at this stage and it has been reset.
	 */
	if ((ahc->flags & AHC_USEDEFAULTS) != 0)
		ahc->our_id = ahc->our_id_b = 7;

	/*
	 * Default to allowing initiator operations.
	 */
	ahc->flags |= AHC_INITIATORROLE;

	/*
	 * Only allow target mode features if this unit has them enabled.
	 */
	//if ((AHC_TMODE_ENABLE & (0x1 << ahc->unit)) == 0)
		ahc->features &= ~AHC_TARGETMODE;

	/*
	 * DMA tag for our command fifos and other data in system memory
	 * the card's sequencer must be able to access.  For initiator
	 * roles, we need to allocate space for the qinfifo and qoutfifo.
	 * The qinfifo and qoutfifo are composed of 256 1 byte elements.
	 * When providing for the target mode role, we must additionally
	 * provide space for the incoming target command fifo and an extra
	 * byte to deal with a DMA bug in some chip versions.
	 */
	driver_data_size = 2 * 256 * sizeof(uint8_t);
	if ((ahc->features & AHC_TARGETMODE) != 0)
		driver_data_size += AHC_TMODE_CMDS * sizeof(struct target_cmd)
				 + /*DMA WideOdd Bug Buffer*/1;

	ahc->init_level++;

	if (ahc_createdmamem(ahc->parent_dmat, driver_data_size,
			     ahc->sc_dmaflags,
			     &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,
			     &ahc->shared_data_busaddr, &ahc->shared_data_seg,
			     &ahc->shared_data_nseg, ahc_name(ahc), "shared data") < 0)
		return (ENOMEM);

	ahc->init_level++;

	if ((ahc->features & AHC_TARGETMODE) != 0) {
		ahc->targetcmds = (struct target_cmd *)ahc->qoutfifo;
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[AHC_TMODE_CMDS];
		ahc->dma_bug_buf = ahc->shared_data_busaddr
				 + driver_data_size - 1;
		/* All target command blocks start out invalid. */
		for (i = 0; i < AHC_TMODE_CMDS; i++)
			ahc->targetcmds[i].cmd_valid = 0;
#ifdef __sgi__
		ahc_sync_tqinfifo(ahc, BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
#else
		ahc_sync_tqinfifo(ahc, BUS_DMASYNC_PREREAD);
#endif
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[256];
	}
	ahc->qinfifo = &ahc->qoutfifo[256];

	ahc->init_level++;

	/* Allocate SCB data now that buffer_dmat is initialized */
	if (ahc->scb_data->maxhscbs == 0)
		if (ahc_init_scbdata(ahc) != 0)
			return (ENOMEM);

	/*
	 * Allocate a tstate to house information for our
	 * initiator presence on the bus as well as the user
	 * data for any target mode initiator.
	 */
	if (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {
		printf("%s: unable to allocate ahc_tmode_tstate.  "
		       "Failing attach\n", ahc_name(ahc));
		return (ENOMEM);
	}

	if ((ahc->features & AHC_TWIN) != 0) {
		if (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {
			printf("%s: unable to allocate ahc_tmode_tstate.  "
			       "Failing attach\n", ahc_name(ahc));
			return (ENOMEM);
		}
	}

	ahc_outb(ahc, SEQ_FLAGS, 0);
	ahc_outb(ahc, SEQ_FLAGS2, 0);

	if (ahc->scb_data->maxhscbs < AHC_SCB_MAX_ALLOC) {
		ahc->flags |= AHC_PAGESCBS;
	} else {
		ahc->flags &= ~AHC_PAGESCBS;
	}

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOW_MISC) {
		printf("%s: hardware scb %u bytes; kernel scb %u bytes; "
		       "ahc_dma %u bytes\n",
			ahc_name(ahc),
			(u_int)sizeof(struct hardware_scb),
			(u_int)sizeof(struct scb),
			(u_int)sizeof(struct ahc_dma_seg));
	}
#endif /* AHC_DEBUG */

	/*
	 * Look at the information that board initialization or
	 * the board bios has left us.
	 */
	if (ahc->features & AHC_TWIN) {
		scsi_conf = ahc_inb(ahc, SCSICONF + 1);
		if ((scsi_conf & RESET_SCSI) != 0
		 && (ahc->flags & AHC_INITIATORROLE) != 0)
			ahc->flags |= AHC_RESET_BUS_B;
	}

	scsi_conf = ahc_inb(ahc, SCSICONF);
	if ((scsi_conf & RESET_SCSI) != 0
	 && (ahc->flags & AHC_INITIATORROLE) != 0)
		ahc->flags |= AHC_RESET_BUS_A;

	ultraenb = 0;
	tagenable = ALL_TARGETS_MASK;

	/* Grab the disconnection disable table and invert it for our needs */
	if ((ahc->flags & AHC_USEDEFAULTS) != 0) {
		printf("%s: Host Adapter Bios disabled.  Using default SCSI "
			"device parameters\n", ahc_name(ahc));
		ahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B|
			      AHC_TERM_ENB_A|AHC_TERM_ENB_B;
		discenable = ALL_TARGETS_MASK;
		if ((ahc->features & AHC_ULTRA) != 0)
			ultraenb = ALL_TARGETS_MASK;
	} else {
		discenable = ~((ahc_inb(ahc, DISC_DSB + 1) << 8)
			   | ahc_inb(ahc, DISC_DSB));
		if ((ahc->features & (AHC_ULTRA|AHC_ULTRA2)) != 0)
			ultraenb = (ahc_inb(ahc, ULTRA_ENB + 1) << 8)
				      | ahc_inb(ahc, ULTRA_ENB);
	}

	if ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)
		max_targ = 7;

	for (i = 0; i <= max_targ; i++) {
		struct ahc_initiator_tinfo *tinfo;
		struct ahc_tmode_tstate *tstate;
		u_int our_id;
		u_int target_id;
		char channel;

		channel = 'A';
		our_id = ahc->our_id;
		target_id = i;
		if (i > 7 && (ahc->features & AHC_TWIN) != 0) {
			channel = 'B';
			our_id = ahc->our_id_b;
			target_id = i % 8;
		}
		tinfo = ahc_fetch_transinfo(ahc, channel, our_id,
					    target_id, &tstate);
		/* Default to async narrow across the board */
		memset(tinfo, 0, sizeof(*tinfo));
		if (ahc->flags & AHC_USEDEFAULTS) {
			if ((ahc->features & AHC_WIDE) != 0)
				tinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;

			/*
			 * These will be truncated when we determine the
			 * connection type we have with the target.
			 */
			tinfo->user.period = ahc_syncrates->period;
			tinfo->user.offset = MAX_OFFSET;
		} else {
			u_int scsirate;
			uint16_t mask;

			/* Take the settings leftover in scratch RAM. */
			scsirate = ahc_inb(ahc, TARG_SCSIRATE + i);
			mask = (0x01 << i);
			if ((ahc->features & AHC_ULTRA2) != 0) {
				u_int offset;
				u_int maxsync;

				if ((scsirate & SOFS) == 0x0F) {
					/*
					 * Haven't negotiated yet,
					 * so the format is different.
					 */
					scsirate = (scsirate & SXFR) >> 4
						 | (ultraenb & mask)
						  ? 0x08 : 0x0
						 | (scsirate & WIDEXFER);
					offset = MAX_OFFSET_ULTRA2;
				} else
					offset = ahc_inb(ahc, TARG_OFFSET + i);
				if ((scsirate & ~WIDEXFER) == 0 && offset != 0)
					/* Set to the lowest sync rate, 5MHz */
					scsirate |= 0x1c;
				maxsync = AHC_SYNCRATE_ULTRA2;
				if ((ahc->features & AHC_DT) != 0)
					maxsync = AHC_SYNCRATE_DT;
				tinfo->user.period =
				    ahc_find_period(ahc, scsirate, maxsync);
				if (offset == 0)
					tinfo->user.period = 0;
				else
					tinfo->user.offset = MAX_OFFSET;
				if ((scsirate & SXFR_ULTRA2) <= 8/*10MHz*/
				 && (ahc->features & AHC_DT) != 0)
					tinfo->user.ppr_options =
					    MSG_EXT_PPR_DT_REQ;
			} else if ((scsirate & SOFS) != 0) {
				if ((scsirate & SXFR) == 0x40
				 && (ultraenb & mask) != 0) {
					/* Treat 10MHz as a non-ultra speed */
					scsirate &= ~SXFR;
					ultraenb &= ~mask;
				}
				tinfo->user.period =
				    ahc_find_period(ahc, scsirate,
						    (ultraenb & mask)
						   ? AHC_SYNCRATE_ULTRA
						   : AHC_SYNCRATE_FAST);
				if (tinfo->user.period != 0)
					tinfo->user.offset = MAX_OFFSET;
			}
			if (tinfo->user.period == 0)
				tinfo->user.offset = 0;
			if ((scsirate & WIDEXFER) != 0
			 && (ahc->features & AHC_WIDE) != 0)
				tinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;
			tinfo->user.protocol_version = 4;
			if ((ahc->features & AHC_DT) != 0)
				tinfo->user.transport_version = 3;
			else
				tinfo->user.transport_version = 2;
			tinfo->goal.protocol_version = 2;
			tinfo->goal.transport_version = 2;
			tinfo->curr.protocol_version = 2;
			tinfo->curr.transport_version = 2;
		}
		tstate->ultraenb = 0;
		tstate->discenable = discenable;
	}
	ahc->user_discenable = discenable;
	ahc->user_tagenable = tagenable;

	return (ahc->bus_chip_init(ahc));
}

void
ahc_intr_enable(struct ahc_softc *ahc, int enable)
{
	u_int hcntrl;

	hcntrl = ahc_inb(ahc, HCNTRL);
	hcntrl &= ~INTEN;
	ahc->pause &= ~INTEN;
	ahc->unpause &= ~INTEN;
	if (enable) {
		hcntrl |= INTEN;
		ahc->pause |= INTEN;
		ahc->unpause |= INTEN;
	}
	ahc_outb(ahc, HCNTRL, hcntrl);
}

/************************** Busy Target Table *********************************/
/*
 * Return the untagged transaction id for a given target/channel lun.
 * Optionally, clear the entry.
 */
u_int
ahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl)
{
	u_int scbid;
	u_int target_offset;

	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;

		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		scbid = ahc_inb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl));
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		scbid = ahc_inb(ahc, BUSY_TARGETS + target_offset);
	}

	return (scbid);
}

void
ahc_unbusy_tcl(struct ahc_softc *ahc, u_int tcl)
{
	u_int target_offset;

	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;

		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		ahc_outb(ahc, SCB_64_BTT+TCL_TARGET_OFFSET(tcl), SCB_LIST_NULL);
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		ahc_outb(ahc, BUSY_TARGETS + target_offset, SCB_LIST_NULL);
	}
}

void
ahc_busy_tcl(struct ahc_softc *ahc, u_int tcl, u_int scbid)
{
	u_int target_offset;

	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;

		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		ahc_outb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl), scbid);
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		ahc_outb(ahc, BUSY_TARGETS + target_offset, scbid);
	}
}

/************************** SCB and SCB queue management **********************/
int
ahc_match_scb(struct ahc_softc *ahc, struct scb *scb, int target,
	      char channel, int lun, u_int tag, role_t role)
{
	char chan;
	int targ, slun, match;

	if (scb == NULL)
		return 0;

	targ = SCB_GET_TARGET(ahc, scb);
	chan = SCB_GET_CHANNEL(ahc, scb);
	slun = SCB_GET_LUN(scb);

	match = ((chan == channel) || (channel == ALL_CHANNELS));
	if (match != 0)
		match = ((targ == target) || (target == CAM_TARGET_WILDCARD));
	if (match != 0)
		match = ((lun == slun) || (lun == CAM_LUN_WILDCARD));
	if (match != 0) {
#ifdef AHC_TARGET_MODE
		int group;

		group = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);
		if (role == ROLE_INITIATOR) {
			match = (group != XPT_FC_GROUP_TMODE)
			      && ((tag == scb->hscb->tag)
			       || (tag == SCB_LIST_NULL));
		} else if (role == ROLE_TARGET) {
			match = (group == XPT_FC_GROUP_TMODE)
			      && ((tag == scb->io_ctx->csio.tag_id)
			       || (tag == SCB_LIST_NULL));
		}
#else /* !AHC_TARGET_MODE */
		match = ((tag == scb->hscb->tag) || (tag == SCB_LIST_NULL));
#endif /* AHC_TARGET_MODE */
	}

	return match;
}

void
ahc_freeze_devq(struct ahc_softc *ahc, struct scb *scb)
{
	int	target;
	char	channel;
	int	lun;

	target = SCB_GET_TARGET(ahc, scb);
	lun = SCB_GET_LUN(scb);
	channel = SCB_GET_CHANNEL(ahc, scb);

	ahc_search_qinfifo(ahc, target, channel, lun,
			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
			   CAM_REQUEUE_REQ, SEARCH_COMPLETE);

	ahc_platform_freeze_devq(ahc, scb);
}

void
ahc_qinfifo_requeue_tail(struct ahc_softc *ahc, struct scb *scb)
{
	struct scb *prev_scb;

	prev_scb = NULL;
	if (ahc_qinfifo_count(ahc) != 0) {
		u_int prev_tag;
		uint8_t prev_pos;

		prev_pos = ahc->qinfifonext - 1;
		prev_tag = ahc->qinfifo[prev_pos];
		prev_scb = ahc_lookup_scb(ahc, prev_tag);
	}
	ahc_qinfifo_requeue(ahc, prev_scb, scb);
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}
}

static void
ahc_qinfifo_requeue(struct ahc_softc *ahc, struct scb *prev_scb,
		    struct scb *scb)
{
	if (prev_scb == NULL) {
		ahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);
	} else {
		prev_scb->hscb->next = scb->hscb->tag;
		ahc_sync_scb(ahc, prev_scb,
			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	}
	ahc->qinfifo[ahc->qinfifonext] = scb->hscb->tag;
	ahc_dmamap_sync(ahc, ahc->parent_dmat, ahc->shared_data_dmamap,
			/*offset*/ahc->qinfifonext+256, /*len*/1,
			BUS_DMASYNC_PREWRITE);
	ahc->qinfifonext++;
	scb->hscb->next = ahc->next_queued_scb->hscb->tag;
	ahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
}

static int
ahc_qinfifo_count(struct ahc_softc *ahc)
{
	uint8_t qinpos;
	uint8_t diff;

	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		qinpos = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinpos);
	} else
		qinpos = ahc_inb(ahc, QINPOS);
	diff = ahc->qinfifonext - qinpos;
	return (diff);
}

int
ahc_search_qinfifo(struct ahc_softc *ahc, int target, char channel,
		   int lun, u_int tag, role_t role, uint32_t status,
		   ahc_search_action action)
{
	struct	scb *scb;
	struct	scb *prev_scb;
	uint8_t qinstart;
	uint8_t qinpos;
	uint8_t qintail;
	uint8_t next;
	uint8_t prev;
	uint8_t curscbptr;
	int	found;
	int	have_qregs;

	qintail = ahc->qinfifonext;
	have_qregs = (ahc->features & AHC_QUEUE_REGS) != 0;
	if (have_qregs) {
		qinstart = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinstart);
	} else
		qinstart = ahc_inb(ahc, QINPOS);
	qinpos = qinstart;
	found = 0;
	prev_scb = NULL;

	if (action == SEARCH_COMPLETE) {
		/*
		 * Don't attempt to run any queued untagged transactions
		 * until we are done with the abort process.
		 */
		ahc_freeze_untagged_queues(ahc);
	}

	/*
	 * Start with an empty queue.  Entries that are not chosen
	 * for removal will be re-added to the queue as we go.
	 */
	ahc->qinfifonext = qinpos;
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);

	while (qinpos != qintail) {
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinpos]);
		if (scb == NULL) {
			printf("qinpos = %d, SCB index = %d\n",
				qinpos, ahc->qinfifo[qinpos]);
			panic("Loop 1");
		}

		if (ahc_match_scb(ahc, scb, target, channel, lun, tag, role)) {
			/*
			 * We found an scb that needs to be acted on.
			 */
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;

				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb, status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in qinfifo\n");
				ahc_done(ahc, scb);

				/* FALLTHROUGH */
			}
			case SEARCH_REMOVE:
				break;
			case SEARCH_COUNT:
				ahc_qinfifo_requeue(ahc, prev_scb, scb);
				prev_scb = scb;
				break;
			}
		} else {
			ahc_qinfifo_requeue(ahc, prev_scb, scb);
			prev_scb = scb;
		}
		qinpos++;
	}

	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}

	if (action != SEARCH_COUNT
	 && (found != 0)
	 && (qinstart != ahc->qinfifonext)) {
		/*
		 * The sequencer may be in the process of DMA'ing
		 * down the SCB at the beginning of the queue.
		 * This could be problematic if either the first,
		 * or the second SCB is removed from the queue
		 * (the first SCB includes a pointer to the "next"
		 * SCB to DMA). If we have removed any entries, swap
		 * the first element in the queue with the next HSCB
		 * so the sequencer will notice that NEXT_QUEUED_SCB
		 * has changed during its DMA attempt and will retry
		 * the DMA.
		 */
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinstart]);

		if (scb == NULL) {
			printf("found = %d, qinstart = %d, qinfifionext = %d\n",
				found, qinstart, ahc->qinfifonext);
			panic("First/Second Qinfifo fixup");
		}
		/*
		 * ahc_swap_with_next_hscb forces our next pointer to
		 * point to the reserved SCB for future commands.  Save
		 * and restore our original next pointer to maintain
		 * queue integrity.
		 */
		next = scb->hscb->next;
		ahc->scb_data->scbindex[scb->hscb->tag] = NULL;
		ahc_swap_with_next_hscb(ahc, scb);
		scb->hscb->next = next;
		ahc->qinfifo[qinstart] = scb->hscb->tag;

		/* Tell the card about the new head of the qinfifo. */
		ahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);

		/* Fixup the tail "next" pointer. */
		qintail = ahc->qinfifonext - 1;
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qintail]);
		scb->hscb->next = ahc->next_queued_scb->hscb->tag;
	}

	/*
	 * Search waiting for selection list.
	 */
	curscbptr = ahc_inb(ahc, SCBPTR);
	next = ahc_inb(ahc, WAITING_SCBH);  /* Start at head of list. */
	prev = SCB_LIST_NULL;

	while (next != SCB_LIST_NULL) {
		uint8_t scb_index;

		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			printf("Waiting List inconsistency. "
			       "SCB index == %d, yet numscbs == %d.",
			       scb_index, ahc->scb_data->numscbs);
			ahc_dump_card_state(ahc);
			panic("for safety");
		}
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("scb_index = %d, next = %d\n",
				scb_index, next);
			panic("Waiting List traversal");
		}
		if (ahc_match_scb(ahc, scb, target, channel,
				  lun, SCB_LIST_NULL, role)) {
			/*
			 * We found an scb that needs to be acted on.
			 */
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;

				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb, status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in Wait List\n");
				ahc_done(ahc, scb);
				/* FALLTHROUGH */
			}
			case SEARCH_REMOVE:
				next = ahc_rem_wscb(ahc, next, prev);
				break;
			case SEARCH_COUNT:
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
				break;
			}
		} else {

			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
		}
	}
	ahc_outb(ahc, SCBPTR, curscbptr);

	found += ahc_search_untagged_queues(ahc, /*scsi_xfer*/NULL, target,
					    channel, lun, status, action);

	if (action == SEARCH_COMPLETE)
		ahc_release_untagged_queues(ahc);
	return (found);
}

int
ahc_search_untagged_queues(struct ahc_softc *ahc, struct scsi_xfer *xs,
			   int target, char channel, int lun, uint32_t status,
			   ahc_search_action action)
{
	struct	scb *scb;
	int	maxtarget;
	int	found;
	int	i;

	if (action == SEARCH_COMPLETE) {
		/*
		 * Don't attempt to run any queued untagged transactions
		 * until we are done with the abort process.
		 */
		ahc_freeze_untagged_queues(ahc);
	}

	found = 0;
	i = 0;
	if ((ahc->flags & AHC_SCB_BTT) == 0) {

		maxtarget = 16;
		if (target != CAM_TARGET_WILDCARD) {

			i = target;
			if (channel == 'B')
				i += 8;
			maxtarget = i + 1;
		}
	} else {
		maxtarget = 0;
	}

	for (; i < maxtarget; i++) {
		struct scb_tailq *untagged_q;
		struct scb *next_scb;

		untagged_q = &(ahc->untagged_queues[i]);
		next_scb = TAILQ_FIRST(untagged_q);
		while (next_scb != NULL) {

			scb = next_scb;
			next_scb = TAILQ_NEXT(scb, links.tqe);

			/*
			 * The head of the list may be the currently
			 * active untagged command for a device.
			 * We're only searching for commands that
			 * have not been started.  A transaction
			 * marked active but still in the qinfifo
			 * is removed by the qinfifo scanning code
			 * above.
			 */
			if ((scb->flags & SCB_ACTIVE) != 0)
				continue;

			if (ahc_match_scb(ahc, scb, target, channel, lun,
					  SCB_LIST_NULL, ROLE_INITIATOR) == 0
			    || (xs != NULL && xs != scb->xs))
				continue;

			/*
			 * We found an scb that needs to be acted on.
			 */
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;

				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb, status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				ahc_done(ahc, scb);
				break;
			}
			case SEARCH_REMOVE:
				scb->flags &= ~SCB_UNTAGGEDQ;
				TAILQ_REMOVE(untagged_q, scb, links.tqe);
				break;
			case SEARCH_COUNT:
				break;
			}
		}
	}

	if (action == SEARCH_COMPLETE)
		ahc_release_untagged_queues(ahc);
	return (found);
}

int
ahc_search_disc_list(struct ahc_softc *ahc, int target, char channel,
		     int lun, u_int tag, int stop_on_first, int remove,
		     int save_state)
{
	struct	scb *scbp;
	u_int	next;
	u_int	prev;
	u_int	count;
	u_int	active_scb;

	count = 0;
	next = ahc_inb(ahc, DISCONNECTED_SCBH);
	prev = SCB_LIST_NULL;

	if (save_state) {
		/* restore this when we're done */
		active_scb = ahc_inb(ahc, SCBPTR);
	} else
		/* Silence compiler */
		active_scb = SCB_LIST_NULL;

	while (next != SCB_LIST_NULL) {
		u_int scb_index;

		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			printf("Disconnected List inconsistency. "
			       "SCB index == %d, yet numscbs == %d.",
			       scb_index, ahc->scb_data->numscbs);
			ahc_dump_card_state(ahc);
			panic("for safety");
		}

		if (next == prev) {
			panic("Disconnected List Loop. "
			      "cur SCBPTR == %x, prev SCBPTR == %x.",
			      next, prev);
		}
		scbp = ahc_lookup_scb(ahc, scb_index);
		if (ahc_match_scb(ahc, scbp, target, channel, lun,
				  tag, ROLE_INITIATOR)) {
			count++;
			if (remove) {
				next =
				    ahc_rem_scb_from_disc_list(ahc, prev, next);
			} else {
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
			}
			if (stop_on_first)
				break;
		} else {
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
		}
	}
	if (save_state)
		ahc_outb(ahc, SCBPTR, active_scb);
	return (count);
}

/*
 * Remove an SCB from the on chip list of disconnected transactions.
 * This is empty/unused if we are not performing SCB paging.
 */
static u_int
ahc_rem_scb_from_disc_list(struct ahc_softc *ahc, u_int prev, u_int scbptr)
{
	u_int next;

	ahc_outb(ahc, SCBPTR, scbptr);
	next = ahc_inb(ahc, SCB_NEXT);

	ahc_outb(ahc, SCB_CONTROL, 0);

	ahc_add_curscb_to_free_list(ahc);

	if (prev != SCB_LIST_NULL) {
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	} else
		ahc_outb(ahc, DISCONNECTED_SCBH, next);

	return (next);
}

/*
 * Add the SCB as selected by SCBPTR onto the on chip list of
 * free hardware SCBs.  This list is empty/unused if we are not
 * performing SCB paging.
 */
static void
ahc_add_curscb_to_free_list(struct ahc_softc *ahc)
{
	/*
	 * Invalidate the tag so that our abort
	 * routines don't think it's active.
	 */
	ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);

	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		ahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));
		ahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));
	}
}

/*
 * Manipulate the waiting for selection list and return the
 * scb that follows the one that we remove.
 */
static u_int
ahc_rem_wscb(struct ahc_softc *ahc, u_int scbpos, u_int prev)
{
	u_int curscb, next;

	/*
	 * Select the SCB we want to abort and
	 * pull the next pointer out of it.
	 */
	curscb = ahc_inb(ahc, SCBPTR);
	ahc_outb(ahc, SCBPTR, scbpos);
	next = ahc_inb(ahc, SCB_NEXT);

	/* Clear the necessary fields */
	ahc_outb(ahc, SCB_CONTROL, 0);

	ahc_add_curscb_to_free_list(ahc);

	/* update the waiting list */
	if (prev == SCB_LIST_NULL) {
		/* First in the list */
		ahc_outb(ahc, WAITING_SCBH, next);

		/*
		 * Ensure we aren't attempting to perform
		 * selection for this entry.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else {
		/*
		 * Select the scb that pointed to us
		 * and update its next pointer.
		 */
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	}

	/*
	 * Point us back at the original scb position.
	 */
	ahc_outb(ahc, SCBPTR, curscb);
	return next;
}

/******************************** Error Handling ******************************/
/*
 * Abort all SCBs that match the given description (target/channel/lun/tag),
 * setting their status to the passed in status if the status has not already
 * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
 * is paused before it is called.
 */
int
ahc_abort_scbs(struct ahc_softc *ahc, int target, char channel,
	       int lun, u_int tag, role_t role, uint32_t status)
{
	struct	scb *scbp;
	struct	scb *scbp_next;
	u_int	active_scb;
	int	i, j;
	int	maxtarget;
	int	minlun;
	int	maxlun;

	int	found;

	/*
	 * Don't attempt to run any queued untagged transactions
	 * until we are done with the abort process.
	 */
	ahc_freeze_untagged_queues(ahc);

	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);

	found = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,
				   role, CAM_REQUEUE_REQ, SEARCH_COMPLETE);

	/*
	 * Clean out the busy target table for any untagged commands.
	 */
	i = 0;
	maxtarget = 16;
	if (target != CAM_TARGET_WILDCARD) {
		i = target;
		if (channel == 'B')
			i += 8;
		maxtarget = i + 1;
	}

	if (lun == CAM_LUN_WILDCARD) {

		/*
		 * Unless we are using an SCB based
		 * busy targets table, there is only
		 * one table entry for all luns of
		 * a target.
		 */
		minlun = 0;
		maxlun = 1;
		if ((ahc->flags & AHC_SCB_BTT) != 0)
			maxlun = AHC_NUM_LUNS;
	} else {
		minlun = lun;
		maxlun = lun + 1;
	}

	if (role != ROLE_TARGET) {
		for (;i < maxtarget; i++) {
			for (j = minlun;j < maxlun; j++) {
				u_int scbid;
				u_int tcl;

				tcl = BUILD_TCL(i << 4, j);
				scbid = ahc_index_busy_tcl(ahc, tcl);
				scbp = ahc_lookup_scb(ahc, scbid);
				if (scbp == NULL
				 || ahc_match_scb(ahc, scbp, target, channel,
						  lun, tag, role) == 0)
					continue;
				ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, j));
			}
		}

		/*
		 * Go through the disconnected list and remove any entries we
		 * have queued for completion, 0'ing their control byte too.
		 * We save the active SCB and restore it ourselves, so there
		 * is no reason for this search to restore it too.
		 */
		ahc_search_disc_list(ahc, target, channel, lun, tag,
				     /*stop_on_first*/FALSE, /*remove*/TRUE,
				     /*save_state*/FALSE);
	}

	/*
	 * Go through the hardware SCB array looking for commands that
	 * were active but not on any list.  In some cases, these remnants
	 * might not still have mappings in the scbindex array (e.g. unexpected
	 * bus free with the same scb queued for an abort).  Don't hold this
	 * against them.
	 */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scbid;

		ahc_outb(ahc, SCBPTR, i);
		scbid = ahc_inb(ahc, SCB_TAG);
		scbp = ahc_lookup_scb(ahc, scbid);
		if ((scbp == NULL && scbid != SCB_LIST_NULL)
		 || (scbp != NULL
		  && ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)))
			ahc_add_curscb_to_free_list(ahc);
	}

	/*
	 * Go through the pending CCB list and look for
	 * commands for this target that are still active.
	 * These are other tagged commands that were
	 * disconnected when the reset occurred.
	 */
	scbp_next = LIST_FIRST(&ahc->pending_scbs);
	while (scbp_next != NULL) {
		scbp = scbp_next;
		scbp_next = LIST_NEXT(scbp, pending_links);
		if (ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)) {
			cam_status ostat;

			ostat = ahc_get_transaction_status(scbp);
			if (ostat == CAM_REQ_INPROG)
				ahc_set_transaction_status(scbp, status);
			if (ahc_get_transaction_status(scbp) != CAM_REQ_CMP)
				ahc_freeze_scb(scbp);
			if ((scbp->flags & SCB_ACTIVE) == 0)
				printf("Inactive SCB on pending list\n");
			ahc_done(ahc, scbp);
			found++;
		}
	}
	ahc_outb(ahc, SCBPTR, active_scb);
	ahc_platform_abort_scbs(ahc, target, channel, lun, tag, role, status);
	ahc_release_untagged_queues(ahc);
	return found;
}

static void
ahc_reset_current_bus(struct ahc_softc *ahc)
{
	uint8_t scsiseq;

	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);
	scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);
	ahc_flush_device_writes(ahc);
	aic_delay(AHC_BUSRESET_DELAY);
	/* Turn off the bus reset */
	ahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);

	ahc_clear_intstat(ahc);

	/* Re-enable reset interrupts */
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);
}

int
ahc_reset_channel(struct ahc_softc *ahc, char channel, int initiate_reset)
{
	struct	ahc_devinfo devinfo;
	u_int	initiator, target, max_scsiid;
	u_int	sblkctl;
	u_int	scsiseq;
	u_int	simode1;
	int	found;
	int	restart_needed;
	char	cur_channel;

	ahc->pending_device = NULL;

	ahc_compile_devinfo(&devinfo,
			    CAM_TARGET_WILDCARD,
			    CAM_TARGET_WILDCARD,
			    CAM_LUN_WILDCARD,
			    channel, ROLE_UNKNOWN);
	ahc_pause(ahc);

	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);

	/*
	 * Run our command complete fifos to ensure that we perform
	 * completion processing on any commands that 'completed'
	 * before the reset occurred.
	 */
	ahc_run_qoutfifo(ahc);
#ifdef AHC_TARGET_MODE
	/*
	 * XXX - In Twin mode, the tqinfifo may have commands
	 *	 for an unaffected channel in it.  However, if
	 *	 we have run out of ATIO resources to drain that
	 *	 queue, we may not get them all out here.  Further,
	 *	 the blocked transactions for the reset channel
	 *	 should just be killed off, irrespecitve of whether
	 *	 we are blocked on ATIO resources.  Write a routine
	 *	 to compact the tqinfifo appropriately.
	 */
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		ahc_run_tqinfifo(ahc, /*paused*/TRUE);
	}
#endif

	/*
	 * Reset the bus if we are initiating this reset
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	cur_channel = 'A';
	if ((ahc->features & AHC_TWIN) != 0
	 && ((sblkctl & SELBUSB) != 0))
	    cur_channel = 'B';
	scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
	if (cur_channel != channel) {
		/* Case 1: Command for another bus is active
		 * Stealthily reset the other bus without
		 * upsetting the current bus.
		 */
		ahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);
		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
#ifdef AHC_TARGET_MODE
		/*
		 * Bus resets clear ENSELI, so we cannot
		 * defer re-enabling bus reset interrupts
		 * if we are in target mode.
		 */
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			simode1 |= ENSCSIRST;
#endif
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
		ahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));
		ahc_outb(ahc, SBLKCTL, sblkctl);
		restart_needed = FALSE;
	} else {
		/* Case 2: A command from this bus is active or we're idle */
		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
#ifdef AHC_TARGET_MODE
		/*
		 * Bus resets clear ENSELI, so we cannot
		 * defer re-enabling bus reset interrupts
		 * if we are in target mode.
		 */
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			simode1 |= ENSCSIRST;
#endif
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
		ahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));
		restart_needed = TRUE;
	}

	/*
	 * Clean up all the state information for the
	 * pending transactions on this bus.
	 */
	found = ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, channel,
			       CAM_LUN_WILDCARD, SCB_LIST_NULL,
			       ROLE_UNKNOWN, CAM_SCSI_BUS_RESET);

	max_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;

#ifdef AHC_TARGET_MODE
	/*
	 * Send an immediate notify ccb to all target more peripheral
	 * drivers affected by this action.
	 */
	for (target = 0; target <= max_scsiid; target++) {
		struct ahc_tmode_tstate* tstate;
		u_int lun;

		tstate = ahc->enabled_targets[target];
		if (tstate == NULL)
			continue;
		for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
			struct ahc_tmode_lstate* lstate;

			lstate = tstate->enabled_luns[lun];
			if (lstate == NULL)
				continue;

			ahc_queue_lstate_event(ahc, lstate, CAM_TARGET_WILDCARD,
					       EVENT_TYPE_BUS_RESET, /*arg*/0);
			ahc_send_lstate_events(ahc, lstate);
		}
	}
#endif
	/* Notify the XPT that a bus reset occurred */
	ahc_send_async(ahc, devinfo.channel, CAM_TARGET_WILDCARD,
		       CAM_LUN_WILDCARD, AC_BUS_RESET, NULL);

	/*
	 * Revert to async/narrow transfers until we renegotiate.
	 */
	for (target = 0; target <= max_scsiid; target++) {

		if (ahc->enabled_targets[target] == NULL)
			continue;
		for (initiator = 0; initiator <= max_scsiid; initiator++) {
			ahc_compile_devinfo(&devinfo, target, initiator,
					    CAM_LUN_WILDCARD,
					    channel, ROLE_UNKNOWN);
			ahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
				      AHC_TRANS_CUR, /*paused*/TRUE);
			ahc_set_syncrate(ahc, &devinfo, /*syncrate*/NULL,
					 /*period*/0, /*offset*/0,
					 /*ppr_options*/0, AHC_TRANS_CUR,
					 /*paused*/TRUE);
		}
	}

	if (restart_needed)
		ahc_restart(ahc);
	else
		ahc_unpause(ahc);
	return found;
}


/***************************** Residual Processing ****************************/
/*
 * Calculate the residual for a just completed SCB.
 */
void
ahc_calc_residual(struct ahc_softc *ahc, struct scb *scb)
{
	struct hardware_scb *hscb;
	struct status_pkt *spkt;
	uint32_t sgptr;
	uint32_t resid_sgptr;
	uint32_t resid;

	/*
	 * 5 cases.
	 * 1) No residual.
	 *    SG_RESID_VALID clear in sgptr.
	 * 2) Transferless command
	 * 3) Never performed any transfers.
	 *    sgptr has SG_FULL_RESID set.
	 * 4) No residual but target did not
	 *    save data pointers after the
	 *    last transfer, so sgptr was
	 *    never updated.
	 * 5) We have a partial residual.
	 *    Use residual_sgptr to determine
	 *    where we are.
	 */

	hscb = scb->hscb;
	sgptr = aic_le32toh(hscb->sgptr);
	if ((sgptr & SG_RESID_VALID) == 0)
		/* Case 1 */
		return;
	sgptr &= ~SG_RESID_VALID;

	if ((sgptr & SG_LIST_NULL) != 0)
		/* Case 2 */
		return;

	spkt = &hscb->shared_data.status;
	resid_sgptr = aic_le32toh(spkt->residual_sg_ptr);
	if ((sgptr & SG_FULL_RESID) != 0) {
		/* Case 3 */
		resid = ahc_get_transfer_length(scb);
	} else if ((resid_sgptr & SG_LIST_NULL) != 0) {
		/* Case 4 */
		return;
	} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {
		panic("Bogus resid sgptr value 0x%x", resid_sgptr);
	} else {
		struct ahc_dma_seg *sg;

		/*
		 * Remainder of the SG where the transfer
		 * stopped.
		 */
		resid = aic_le32toh(spkt->residual_datacnt) & AHC_SG_LEN_MASK;
		sg = ahc_sg_bus_to_virt(scb, resid_sgptr & SG_PTR_MASK);

		/* The residual sg_ptr always points to the next sg */
		sg--;

		/*
		 * Add up the contents of all residual
		 * SG segments that are after the SG where
		 * the transfer stopped.
		 */
		while ((aic_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {
			sg++;
			resid += aic_le32toh(sg->len) & AHC_SG_LEN_MASK;
		}
	}
	if ((scb->flags & SCB_SENSE) == 0)
		ahc_set_residual(scb, resid);
	else
		ahc_set_sense_residual(scb, resid);

#ifdef AHC_DEBUG
	if ((ahc_debug & AHC_SHOW_MISC) != 0) {
		ahc_print_path(ahc, scb);
		printf("Handled %sResidual of %d bytes\n",
		       (scb->flags & SCB_SENSE) ? "Sense " : "", resid);
	}
#endif
}

/******************************* Target Mode **********************************/
#ifdef AHC_TARGET_MODE
/*
 * Add a target mode event to this lun's queue
 */
static void
ahc_queue_lstate_event(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate,
		       u_int initiator_id, u_int event_type, u_int event_arg)
{
	struct ahc_tmode_event *event;
	int pending;

	xpt_freeze_devq(lstate->path, /*count*/1);
	if (lstate->event_w_idx >= lstate->event_r_idx)
		pending = lstate->event_w_idx - lstate->event_r_idx;
	else
		pending = AHC_TMODE_EVENT_BUFFER_SIZE + 1
			- (lstate->event_r_idx - lstate->event_w_idx);

	if (event_type == EVENT_TYPE_BUS_RESET
	 || event_type == MSG_BUS_DEV_RESET) {
		/*
		 * Any earlier events are irrelevant, so reset our buffer.
		 * This has the effect of allowing us to deal with reset
		 * floods (an external device holding down the reset line)
		 * without losing the event that is really interesting.
		 */
		lstate->event_r_idx = 0;
		lstate->event_w_idx = 0;
		xpt_release_devq(lstate->path, pending, /*runqueue*/FALSE);
	}

	if (pending == AHC_TMODE_EVENT_BUFFER_SIZE) {
		xpt_print_path(lstate->path);
		printf("immediate event %x:%x lost\n",
		       lstate->event_buffer[lstate->event_r_idx].event_type,
		       lstate->event_buffer[lstate->event_r_idx].event_arg);
		lstate->event_r_idx++;
		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
			lstate->event_r_idx = 0;
		xpt_release_devq(lstate->path, /*count*/1, /*runqueue*/FALSE);
	}

	event = &lstate->event_buffer[lstate->event_w_idx];
	event->initiator_id = initiator_id;
	event->event_type = event_type;
	event->event_arg = event_arg;
	lstate->event_w_idx++;
	if (lstate->event_w_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
		lstate->event_w_idx = 0;
}

/*
 * Send any target mode events queued up waiting
 * for immediate notify resources.
 */
void
ahc_send_lstate_events(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate)
{
	struct ccb_hdr *ccbh;
	struct ccb_immed_notify *inot;

	while (lstate->event_r_idx != lstate->event_w_idx
	    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {
		struct ahc_tmode_event *event;

		event = &lstate->event_buffer[lstate->event_r_idx];
		SLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);
		inot = (struct ccb_immed_notify *)ccbh;
		switch (event->event_type) {
		case EVENT_TYPE_BUS_RESET:
			ccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;
			break;
		default:
			ccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;
			inot->message_args[0] = event->event_type;
			inot->message_args[1] = event->event_arg;
			break;
		}
		inot->initiator_id = event->initiator_id;
		inot->sense_len = 0;
		xpt_done((union ccb *)inot);
		lstate->event_r_idx++;
		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
			lstate->event_r_idx = 0;
	}
}
#endif

/******************** Sequencer Program Patching/Download *********************/

#ifdef AHC_DUMP_SEQ
void
ahc_dumpseq(struct ahc_softc* ahc)
{
	int i;

	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	for (i = 0; i < ahc->instruction_ram_size; i++) {
		uint8_t ins_bytes[4];

		ahc_insb(ahc, SEQRAM, ins_bytes, 4);
		printf("0x%08x\n", ins_bytes[0] << 24
				 | ins_bytes[1] << 16
				 | ins_bytes[2] << 8
				 | ins_bytes[3]);
	}
}
#endif

static int
ahc_loadseq(struct ahc_softc *ahc)
{
	struct	cs cs_table[NUM_CRITICAL_SECTIONS];
	u_int	begin_set[NUM_CRITICAL_SECTIONS];
	u_int	end_set[NUM_CRITICAL_SECTIONS];
	const struct	patch *cur_patch;
	u_int	cs_count;
	u_int	cur_cs;
	u_int	i;
	u_int	skip_addr;
	u_int	sg_prefetch_cnt;
	int	downloaded;
	uint8_t	download_consts[7];

	/*
	 * Start out with 0 critical sections
	 * that apply to this firmware load.
	 */
	cs_count = 0;
	cur_cs = 0;
	memset(begin_set, 0, sizeof(begin_set));
	memset(end_set, 0, sizeof(end_set));

	/* Setup downloadable constant table */
	download_consts[QOUTFIFO_OFFSET] = 0;
	if (ahc->targetcmds != NULL)
		download_consts[QOUTFIFO_OFFSET] += 32;
	download_consts[QINFIFO_OFFSET] = download_consts[QOUTFIFO_OFFSET] + 1;
	download_consts[CACHESIZE_MASK] = ahc->pci_cachesize - 1;
	download_consts[INVERTED_CACHESIZE_MASK] = ~(ahc->pci_cachesize - 1);
	sg_prefetch_cnt = ahc->pci_cachesize;
	if (sg_prefetch_cnt < (2 * sizeof(struct ahc_dma_seg)))
		sg_prefetch_cnt = 2 * sizeof(struct ahc_dma_seg);
	download_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;
	download_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_cnt - 1);
	download_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_cnt - 1);

	cur_patch = patches;
	downloaded = 0;
	skip_addr = 0;
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);

	for (i = 0; i < sizeof(seqprog)/4; i++) {
		if (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {
			/*
			 * Don't download this instruction as it
			 * is in a patch that was removed.
			 */
			continue;
		}

		if (downloaded == ahc->instruction_ram_size) {
			/*
			 * We're about to exceed the instruction
			 * storage capacity for this chip.  Fail
			 * the load.
			 */
			printf("\n%s: Program too large for instruction memory "
			       "size of %d!\n", ahc_name(ahc),
			       ahc->instruction_ram_size);
			return (ENOMEM);
		}

		/*
		 * Move through the CS table until we find a CS
		 * that might apply to this instruction.
		 */
		for (; cur_cs < NUM_CRITICAL_SECTIONS; cur_cs++) {
			if (critical_sections[cur_cs].end <= i) {
				if (begin_set[cs_count] == TRUE
				 && end_set[cs_count] == FALSE) {
					cs_table[cs_count].end = downloaded;
					end_set[cs_count] = TRUE;
					cs_count++;
				}
				continue;
			}
			if (critical_sections[cur_cs].begin <= i
			 && begin_set[cs_count] == FALSE) {
				cs_table[cs_count].begin = downloaded;
				begin_set[cs_count] = TRUE;
			}
			break;
		}
		ahc_download_instr(ahc, i, download_consts);
		downloaded++;
	}

	ahc->num_critical_sections = cs_count;
	if (cs_count != 0) {
		ahc->critical_sections = mallocarray(cs_count,
		    sizeof(struct cs), M_DEVBUF, M_NOWAIT);
		if (ahc->critical_sections == NULL)
			panic("ahc_loadseq: Could not malloc");
		cs_count *= sizeof(struct cs);

		memcpy(ahc->critical_sections, cs_table, cs_count);
	}
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);

	if (bootverbose) {
		printf(" %d instructions downloaded\n", downloaded);
		printf("%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\n",
		       ahc_name(ahc), ahc->features, ahc->bugs, ahc->flags);
	}
	return (0);
}

static int
ahc_check_patch(struct ahc_softc *ahc, const struct patch **start_patch,
		u_int start_instr, u_int *skip_addr)
{
	const struct	patch *cur_patch;
	const struct	patch *last_patch;
	u_int	num_patches;

	num_patches = sizeof(patches)/sizeof(struct patch);
	last_patch = &patches[num_patches];
	cur_patch = *start_patch;

	while (cur_patch < last_patch && start_instr == cur_patch->begin) {

		if (cur_patch->patch_func(ahc) == 0) {

			/* Start rejecting code */
			*skip_addr = start_instr + cur_patch->skip_instr;
			cur_patch += cur_patch->skip_patch;
		} else {
			/* Accepted this patch.  Advance to the next
			 * one and wait for our intruction pointer to
			 * hit this point.
			 */
			cur_patch++;
		}
	}

	*start_patch = cur_patch;
	if (start_instr < *skip_addr)
		/* Still skipping */
		return (0);

	return (1);
}

static void
ahc_download_instr(struct ahc_softc *ahc, u_int instrptr, uint8_t *dconsts)
{
	union	ins_formats instr;
	struct	ins_format1 *fmt1_ins;
	struct	ins_format3 *fmt3_ins;
	u_int	opcode;

	/*
	 * The firmware is always compiled into a little endian format.
	 */
	instr.integer = aic_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);

	fmt1_ins = &instr.format1;
	fmt3_ins = NULL;

	/* Pull the opcode */
	opcode = instr.format1.opcode;
	switch (opcode) {
	case AIC_OP_JMP:
	case AIC_OP_JC:
	case AIC_OP_JNC:
	case AIC_OP_CALL:
	case AIC_OP_JNE:
	case AIC_OP_JNZ:
	case AIC_OP_JE:
	case AIC_OP_JZ:
	{
		const struct patch *cur_patch;
		int address_offset;
		u_int address;
		u_int skip_addr;
		u_int i;

		fmt3_ins = &instr.format3;
		address_offset = 0;
		address = fmt3_ins->address;
		cur_patch = patches;
		skip_addr = 0;

		for (i = 0; i < address;) {

			ahc_check_patch(ahc, &cur_patch, i, &skip_addr);

			if (skip_addr > i) {
				int end_addr;

				end_addr = MIN(address, skip_addr);
				address_offset += end_addr - i;
				i = skip_addr;
			} else {
				i++;
			}
		}
		address -= address_offset;
		fmt3_ins->address = address;
		/* FALLTHROUGH */
	}
	case AIC_OP_OR:
	case AIC_OP_AND:
	case AIC_OP_XOR:
	case AIC_OP_ADD:
	case AIC_OP_ADC:
	case AIC_OP_BMOV:
		if (fmt1_ins->parity != 0) {
			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
		}
		fmt1_ins->parity = 0;
		if ((ahc->features & AHC_CMD_CHAN) == 0
		 && opcode == AIC_OP_BMOV) {
			/*
			 * Block move was added at the same time
			 * as the command channel.  Verify that
			 * this is only a move of a single element
			 * and convert the BMOV to a MOV
			 * (AND with an immediate of FF).
			 */
			if (fmt1_ins->immediate != 1)
				panic("%s: BMOV not supported",
				      ahc_name(ahc));
			fmt1_ins->opcode = AIC_OP_AND;
			fmt1_ins->immediate = 0xff;
		}
		/* FALLTHROUGH */
	case AIC_OP_ROL:
		if ((ahc->features & AHC_ULTRA2) != 0) {
			int i, count;

			/* Calculate odd parity for the instruction */
			for (i = 0, count = 0; i < 31; i++) {
				uint32_t mask;

				mask = 0x01 << i;
				if ((instr.integer & mask) != 0)
					count++;
			}
			if ((count & 0x01) == 0)
				instr.format1.parity = 1;
		} else {
			/* Compress the instruction for older sequencers */
			if (fmt3_ins != NULL) {
				instr.integer =
					fmt3_ins->immediate
				      | (fmt3_ins->source << 8)
				      | (fmt3_ins->address << 16)
				      |	(fmt3_ins->opcode << 25);
			} else {
				instr.integer =
					fmt1_ins->immediate
				      | (fmt1_ins->source << 8)
				      | (fmt1_ins->destination << 16)
				      |	(fmt1_ins->ret << 24)
				      |	(fmt1_ins->opcode << 25);
			}
		}
		/* The sequencer is a little endian cpu */
		instr.integer = aic_htole32(instr.integer);
		ahc_outsb(ahc, SEQRAM, instr.bytes, 4);
		break;
	default:
		panic("Unknown opcode encountered in seq program");
		break;
	}
}

#ifndef SMALL_KERNEL
int
ahc_print_register(ahc_reg_parse_entry_t *table, u_int num_entries,
		   const char *name, u_int address, u_int value,
		   u_int *cur_column, u_int wrap_point)
{
	u_int printed_mask;
	int entry, printed;

	if (cur_column != NULL && *cur_column >= wrap_point) {
		printf("\n");
		*cur_column = 0;
	}
	printed = printf("%s[0x%x]", name, value);
	if (table == NULL) {
		printed += printf(" ");
		if (cur_column != NULL)
			*cur_column += printed;
		return (printed);
	}

	printed_mask = 0;
	while (printed_mask != 0xFF) {
		for (entry = 0; entry < num_entries; entry++) {
			if (((value & table[entry].mask) != table[entry].value)
			    || ((printed_mask & table[entry].mask) ==
			    table[entry].mask))
				continue;

			printed += printf("%s%s",
					  printed_mask == 0 ? ":(" : "|",
					  table[entry].name);
			printed_mask |= table[entry].mask;

			break;
		}
		if (entry >= num_entries)
			break;
	}

	printed += printf("%s", printed_mask == 0 ? " " : ") ");
	if (cur_column != NULL)
		*cur_column += printed;

	return (printed);
}
#endif

void
ahc_dump_card_state(struct ahc_softc *ahc)
{
#ifndef SMALL_KERNEL
	struct	scb *scb;
	struct	scb_tailq *untagged_q;
	u_int	cur_col;
	int	paused;
	int	target;
	int	maxtarget;
	int	i;
	uint8_t last_phase;
	uint8_t qinpos;
	uint8_t qintail;
	uint8_t qoutpos;
	uint8_t scb_index;
	uint8_t saved_scbptr;

	if (ahc_is_paused(ahc)) {
		paused = 1;
	} else {
		paused = 0;
		ahc_pause(ahc);
	}

	saved_scbptr = ahc_inb(ahc, SCBPTR);
	last_phase = ahc_inb(ahc, LASTPHASE);
	printf("================== Dump Card State Begins =================\n"
	       "%s: Dumping Card State %s, at SEQADDR 0x%x\n",
	       ahc_name(ahc), ahc_lookup_phase_entry(last_phase)->phasemsg,
	       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
	if (paused)
		printf("Card was paused\n");
	printf("ACCUM = 0x%x, SINDEX = 0x%x, DINDEX = 0x%x, ARG_2 = 0x%x\n",
	       ahc_inb(ahc, ACCUM), ahc_inb(ahc, SINDEX), ahc_inb(ahc, DINDEX),
	       ahc_inb(ahc, ARG_2));
	printf("HCNT = 0x%x SCBPTR = 0x%x\n", ahc_inb(ahc, HCNT),
	       ahc_inb(ahc, SCBPTR));
	cur_col = 0;
	if ((ahc->features & AHC_DT) != 0)
		ahc_scsiphase_print(ahc_inb(ahc, SCSIPHASE), &cur_col, 50);
	ahc_scsisigi_print(ahc_inb(ahc, SCSISIGI), &cur_col, 50);
	ahc_error_print(ahc_inb(ahc, ERROR), &cur_col, 50);
	ahc_scsibusl_print(ahc_inb(ahc, SCSIBUSL), &cur_col, 50);
	ahc_lastphase_print(ahc_inb(ahc, LASTPHASE), &cur_col, 50);
	ahc_scsiseq_print(ahc_inb(ahc, SCSISEQ), &cur_col, 50);
	ahc_sblkctl_print(ahc_inb(ahc, SBLKCTL), &cur_col, 50);
	ahc_scsirate_print(ahc_inb(ahc, SCSIRATE), &cur_col, 50);
	ahc_seqctl_print(ahc_inb(ahc, SEQCTL), &cur_col, 50);
	ahc_seq_flags_print(ahc_inb(ahc, SEQ_FLAGS), &cur_col, 50);
	ahc_sstat0_print(ahc_inb(ahc, SSTAT0), &cur_col, 50);
	ahc_sstat1_print(ahc_inb(ahc, SSTAT1), &cur_col, 50);
	ahc_sstat2_print(ahc_inb(ahc, SSTAT2), &cur_col, 50);
	ahc_sstat3_print(ahc_inb(ahc, SSTAT3), &cur_col, 50);
	ahc_simode0_print(ahc_inb(ahc, SIMODE0), &cur_col, 50);
	ahc_simode1_print(ahc_inb(ahc, SIMODE1), &cur_col, 50);
	ahc_sxfrctl0_print(ahc_inb(ahc, SXFRCTL0), &cur_col, 50);
	ahc_dfcntrl_print(ahc_inb(ahc, DFCNTRL), &cur_col, 50);
	ahc_dfstatus_print(ahc_inb(ahc, DFSTATUS), &cur_col, 50);
	if (cur_col != 0)
		printf("\n");
	printf("STACK:");
	for (i = 0; i < STACK_SIZE; i++)
	       printf(" 0x%x", ahc_inb(ahc, STACK)|(ahc_inb(ahc, STACK) << 8));
	printf("\nSCB count = %d\n", ahc->scb_data->numscbs);
	printf("Kernel NEXTQSCB = %d\n", ahc->next_queued_scb->hscb->tag);
	printf("Card NEXTQSCB = %d\n", ahc_inb(ahc, NEXT_QUEUED_SCB));
	/* QINFIFO */
	printf("QINFIFO entries: ");
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		qinpos = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinpos);
	} else
		qinpos = ahc_inb(ahc, QINPOS);
	qintail = ahc->qinfifonext;
	while (qinpos != qintail) {
		printf("%d ", ahc->qinfifo[qinpos]);
		qinpos++;
	}
	printf("\n");

	printf("Waiting Queue entries: ");
	scb_index = ahc_inb(ahc, WAITING_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	printf("Disconnected Queue entries: ");
	scb_index = ahc_inb(ahc, DISCONNECTED_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);
	printf("QOUTFIFO entries: ");
	qoutpos = ahc->qoutfifonext;
	i = 0;
	while (ahc->qoutfifo[qoutpos] != SCB_LIST_NULL && i++ < 256) {
		printf("%d ", ahc->qoutfifo[qoutpos]);
		qoutpos++;
	}
	printf("\n");

	printf("Sequencer Free SCB List: ");
	scb_index = ahc_inb(ahc, FREE_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d ", scb_index);
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	printf("Sequencer SCB Info: ");
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		ahc_outb(ahc, SCBPTR, i);
		/*cur_col =*/ printf("\n%3d ", i);

		ahc_scb_control_print(ahc_inb(ahc, SCB_CONTROL), &cur_col, 60);
		ahc_scb_scsiid_print(ahc_inb(ahc, SCB_SCSIID), &cur_col, 60);
		ahc_scb_lun_print(ahc_inb(ahc, SCB_LUN), &cur_col, 60);
		ahc_scb_tag_print(ahc_inb(ahc, SCB_TAG), &cur_col, 60);
	}
	printf("\n");

	printf("Pending list: ");
	i = 0;
	LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
		if (i++ > 256)
			break;
		/*cur_col =*/ printf("\n%3d ", scb->hscb->tag);
		ahc_scb_control_print(scb->hscb->control, &cur_col, 60);
		ahc_scb_scsiid_print(scb->hscb->scsiid, &cur_col, 60);
		ahc_scb_lun_print(scb->hscb->lun, &cur_col, 60);
		if ((ahc->flags & AHC_PAGESCBS) == 0) {
			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
			printf("(");
			ahc_scb_control_print(ahc_inb(ahc, SCB_CONTROL),
					      &cur_col, 60);
			ahc_scb_tag_print(ahc_inb(ahc, SCB_TAG), &cur_col, 60);
			printf(")");
		}
	}
	printf("\n");

	printf("Kernel Free SCB list: ");
	i = 0;
	mtx_enter(&ahc->sc_scb_mtx);
	SLIST_FOREACH(scb, &ahc->scb_data->free_scbs, links.sle) {
		if (i++ > 256)
			break;
		printf("%d ", scb->hscb->tag);
	}
	printf("\n");
	mtx_leave(&ahc->sc_scb_mtx);

	maxtarget = (ahc->features & (AHC_WIDE|AHC_TWIN)) ? 15 : 7;
	for (target = 0; target <= maxtarget; target++) {
		untagged_q = &ahc->untagged_queues[target];
		if (TAILQ_FIRST(untagged_q) == NULL)
			continue;
		printf("Untagged Q(%d): ", target);
		i = 0;
		TAILQ_FOREACH(scb, untagged_q, links.tqe) {
			if (i++ > 256)
				break;
			printf("%d ", scb->hscb->tag);
		}
		printf("\n");
	}

	ahc_platform_dump_card_state(ahc);
	printf("\n================= Dump Card State Ends ==================\n");
	ahc_outb(ahc, SCBPTR, saved_scbptr);
	if (paused == 0)
		ahc_unpause(ahc);
#endif
}

/************************* Target Mode ****************************************/
#ifdef AHC_TARGET_MODE
cam_status
ahc_find_tmode_devs(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb,
		    struct ahc_tmode_tstate **tstate,
		    struct ahc_tmode_lstate **lstate,
		    int notfound_failure)
{

	if ((ahc->features & AHC_TARGETMODE) == 0)
		return (CAM_REQ_INVALID);

	/*
	 * Handle the 'black hole' device that sucks up
	 * requests to unattached luns on enabled targets.
	 */
	if (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD
	 && ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {
		*tstate = NULL;
		*lstate = ahc->black_hole;
	} else {
		u_int max_id;

		max_id = (ahc->features & AHC_WIDE) ? 15 : 7;
		if (ccb->ccb_h.target_id > max_id)
			return (CAM_TID_INVALID);

		if (ccb->ccb_h.target_lun >= AHC_NUM_LUNS)
			return (CAM_LUN_INVALID);

		*tstate = ahc->enabled_targets[ccb->ccb_h.target_id];
		*lstate = NULL;
		if (*tstate != NULL)
			*lstate =
			    (*tstate)->enabled_luns[ccb->ccb_h.target_lun];
	}

	if (notfound_failure != 0 && *lstate == NULL)
		return (CAM_PATH_INVALID);

	return (CAM_REQ_CMP);
}

void
ahc_handle_en_lun(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb)
{
	struct	   ahc_tmode_tstate *tstate;
	struct	   ahc_tmode_lstate *lstate;
	struct	   ccb_en_lun *cel;
	cam_status status;
	u_long	   s;
	u_int	   target;
	u_int	   lun;
	u_int	   target_mask;
	u_int	   our_id;
	int	   error;
	char	   channel;

	status = ahc_find_tmode_devs(ahc, sim, ccb, &tstate, &lstate,
				     /*notfound_failure*/FALSE);

	if (status != CAM_REQ_CMP) {
		ccb->ccb_h.status = status;
		return;
	}

	if (cam_sim_bus(sim) == 0)
		our_id = ahc->our_id;
	else
		our_id = ahc->our_id_b;

	if (ccb->ccb_h.target_id != our_id) {
		/*
		 * our_id represents our initiator ID, or
		 * the ID of the first target to have an
		 * enabled lun in target mode.  There are
		 * two cases that may preclude enabling a
		 * target id other than our_id.
		 *
		 *   o our_id is for an active initiator role.
		 *     Since the hardware does not support
		 *     reselections to the initiator role at
		 *     anything other than our_id, and our_id
		 *     is used by the hardware to indicate the
		 *     ID to use for both select-out and
		 *     reselect-out operations, the only target
		 *     ID we can support in this mode is our_id.
		 *
		 *   o The MULTARGID feature is not available and
		 *     a previous target mode ID has been enabled.
		 */
		if ((ahc->features & AHC_MULTIROLE) != 0) {

			if ((ahc->features & AHC_MULTI_TID) != 0
			 && (ahc->flags & AHC_INITIATORROLE) != 0) {
				/*
				 * Only allow additional targets if
				 * the initiator role is disabled.
				 * The hardware cannot handle a re-select-in
				 * on the initiator id during a re-select-out
				 * on a different target id.
				 */
				status = CAM_TID_INVALID;
			} else if ((ahc->flags & AHC_INITIATORROLE) != 0
				|| ahc->enabled_luns > 0) {
				/*
				 * Only allow our target id to change
				 * if the initiator role is not configured
				 * and there are no enabled luns which
				 * are attached to the currently registered
				 * scsi id.
				 */
				status = CAM_TID_INVALID;
			}
		} else if ((ahc->features & AHC_MULTI_TID) == 0
			&& ahc->enabled_luns > 0) {

			status = CAM_TID_INVALID;
		}
	}

	if (status != CAM_REQ_CMP) {
		ccb->ccb_h.status = status;
		return;
	}

	/*
	 * We now have an id that is valid.
	 * If we aren't in target mode, switch modes.
	 */
	if ((ahc->flags & AHC_TARGETROLE) == 0
	 && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
		u_long	 s;
		ahc_flag saved_flags;

		printf("Configuring Target Mode\n");
		s = splbio();
		if (LIST_FIRST(&ahc->pending_scbs) != NULL) {
			ccb->ccb_h.status = CAM_BUSY;
			splx(s);
			return;
		}
		saved_flags = ahc->flags;
		ahc->flags |= AHC_TARGETROLE;
		if ((ahc->features & AHC_MULTIROLE) == 0)
			ahc->flags &= ~AHC_INITIATORROLE;
		ahc_pause(ahc);
		error = ahc_loadseq(ahc);
		if (error != 0) {
			/*
			 * Restore original configuration and notify
			 * the caller that we cannot support target mode.
			 * Since the adapter started out in this
			 * configuration, the firmware load will succeed,
			 * so there is no point in checking ahc_loadseq's
			 * return value.
			 */
			ahc->flags = saved_flags;
			(void)ahc_loadseq(ahc);
			ahc_restart(ahc);
			splx(s);
			ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;
			return;
		}
		ahc_restart(ahc);
		splx(s);
	}
	cel = &ccb->cel;
	target = ccb->ccb_h.target_id;
	lun = ccb->ccb_h.target_lun;
	channel = SIM_CHANNEL(ahc, sim);
	target_mask = 0x01 << target;
	if (channel == 'B')
		target_mask <<= 8;

	if (cel->enable != 0) {
		u_int scsiseq;

		/* Are we already enabled?? */
		if (lstate != NULL) {
			xpt_print_path(ccb->ccb_h.path);
			printf("Lun already enabled\n");
			ccb->ccb_h.status = CAM_LUN_ALRDY_ENA;
			return;
		}

		if (cel->grp6_len != 0
		 || cel->grp7_len != 0) {
			/*
			 * Don't (yet?) support vendor
			 * specific commands.
			 */
			ccb->ccb_h.status = CAM_REQ_INVALID;
			printf("Non-zero Group Codes\n");
			return;
		}

		/*
		 * Seems to be okay.
		 * Setup our data structures.
		 */
		if (target != CAM_TARGET_WILDCARD && tstate == NULL) {
			tstate = ahc_alloc_tstate(ahc, target, channel);
			if (tstate == NULL) {
				xpt_print_path(ccb->ccb_h.path);
				printf("Couldn't allocate tstate\n");
				ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
				return;
			}
		}
		lstate = malloc(sizeof(*lstate), M_DEVBUF, M_NOWAIT | M_ZERO);
		if (lstate == NULL) {
			xpt_print_path(ccb->ccb_h.path);
			printf("Couldn't allocate lstate\n");
			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
			return;
		}
		status = xpt_create_path(&lstate->path, /*periph*/NULL,
					 xpt_path_path_id(ccb->ccb_h.path),
					 xpt_path_target_id(ccb->ccb_h.path),
					 xpt_path_lun_id(ccb->ccb_h.path));
		if (status != CAM_REQ_CMP) {
			free(lstate, M_DEVBUF, 0);
			xpt_print_path(ccb->ccb_h.path);
			printf("Couldn't allocate path\n");
			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
			return;
		}
		SLIST_INIT(&lstate->accept_tios);
		SLIST_INIT(&lstate->immed_notifies);
		s = splbio();
		ahc_pause(ahc);
		if (target != CAM_TARGET_WILDCARD) {
			tstate->enabled_luns[lun] = lstate;
			ahc->enabled_luns++;

			if ((ahc->features & AHC_MULTI_TID) != 0) {
				u_int targid_mask;

				targid_mask = ahc_inb(ahc, TARGID)
					    | (ahc_inb(ahc, TARGID + 1) << 8);

				targid_mask |= target_mask;
				ahc_outb(ahc, TARGID, targid_mask);
				ahc_outb(ahc, TARGID+1, (targid_mask >> 8));

				ahc_update_scsiid(ahc, targid_mask);
			} else {
				u_int our_id;
				char  channel;

				channel = SIM_CHANNEL(ahc, sim);
				our_id = SIM_SCSI_ID(ahc, sim);

				/*
				 * This can only happen if selections
				 * are not enabled
				 */
				if (target != our_id) {
					u_int sblkctl;
					char  cur_channel;
					int   swap;

					sblkctl = ahc_inb(ahc, SBLKCTL);
					cur_channel = (sblkctl & SELBUSB)
						    ? 'B' : 'A';
					if ((ahc->features & AHC_TWIN) == 0)
						cur_channel = 'A';
					swap = cur_channel != channel;
					if (channel == 'A')
						ahc->our_id = target;
					else
						ahc->our_id_b = target;

					if (swap)
						ahc_outb(ahc, SBLKCTL,
							 sblkctl ^ SELBUSB);

					ahc_outb(ahc, SCSIID, target);

					if (swap)
						ahc_outb(ahc, SBLKCTL, sblkctl);
				}
			}
		} else
			ahc->black_hole = lstate;
		/* Allow select-in operations */
		if (ahc->black_hole != NULL && ahc->enabled_luns > 0) {
			scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
			scsiseq |= ENSELI;
			ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);
			scsiseq = ahc_inb(ahc, SCSISEQ);
			scsiseq |= ENSELI;
			ahc_outb(ahc, SCSISEQ, scsiseq);
		}
		ahc_unpause(ahc);
		splx(s);
		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_print_path(ccb->ccb_h.path);
		printf("Lun now enabled for target mode\n");
	} else {
		struct scb *scb;
		int i, empty;

		if (lstate == NULL) {
			ccb->ccb_h.status = CAM_LUN_INVALID;
			return;
		}

		s = splbio();

		ccb->ccb_h.status = CAM_REQ_CMP;
		LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
			struct ccb_hdr *ccbh;

			ccbh = &scb->io_ctx->ccb_h;
			if (ccbh->func_code == XPT_CONT_TARGET_IO
			 && !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){
				printf("CTIO pending\n");
				ccb->ccb_h.status = CAM_REQ_INVALID;
				splx(s);
				return;
			}
		}

		if (SLIST_FIRST(&lstate->accept_tios) != NULL) {
			printf("ATIOs pending\n");
			ccb->ccb_h.status = CAM_REQ_INVALID;
		}

		if (SLIST_FIRST(&lstate->immed_notifies) != NULL) {
			printf("INOTs pending\n");
			ccb->ccb_h.status = CAM_REQ_INVALID;
		}

		if (ccb->ccb_h.status != CAM_REQ_CMP) {
			splx(s);
			return;
		}

		xpt_print_path(ccb->ccb_h.path);
		printf("Target mode disabled\n");
		xpt_free_path(lstate->path);
		free(lstate, M_DEVBUF, 0);

		ahc_pause(ahc);
		/* Can we clean up the target too? */
		if (target != CAM_TARGET_WILDCARD) {
			tstate->enabled_luns[lun] = NULL;
			ahc->enabled_luns--;
			for (empty = 1, i = 0; i < 8; i++)
				if (tstate->enabled_luns[i] != NULL) {
					empty = 0;
					break;
				}

			if (empty) {
				ahc_free_tstate(ahc, target, channel,
						/*force*/FALSE);
				if (ahc->features & AHC_MULTI_TID) {
					u_int targid_mask;

					targid_mask = ahc_inb(ahc, TARGID)
						    | (ahc_inb(ahc, TARGID + 1)
						       << 8);

					targid_mask &= ~target_mask;
					ahc_outb(ahc, TARGID, targid_mask);
					ahc_outb(ahc, TARGID+1,
						 (targid_mask >> 8));
					ahc_update_scsiid(ahc, targid_mask);
				}
			}
		} else {

			ahc->black_hole = NULL;

			/*
			 * We can't allow selections without
			 * our black hole device.
			 */
			empty = TRUE;
		}
		if (ahc->enabled_luns == 0) {
			/* Disallow select-in */
			u_int scsiseq;

			scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
			scsiseq &= ~ENSELI;
			ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);
			scsiseq = ahc_inb(ahc, SCSISEQ);
			scsiseq &= ~ENSELI;
			ahc_outb(ahc, SCSISEQ, scsiseq);

			if ((ahc->features & AHC_MULTIROLE) == 0) {
				printf("Configuring Initiator Mode\n");
				ahc->flags &= ~AHC_TARGETROLE;
				ahc->flags |= AHC_INITIATORROLE;
				/*
				 * Returning to a configuration that
				 * fit previously will always succeed.
				 */
				(void)ahc_loadseq(ahc);
				ahc_restart(ahc);
				/*
				 * Unpaused.  The extra unpause
				 * that follows is harmless.
				 */
			}
		}
		ahc_unpause(ahc);
		splx(s);
	}
}

static void
ahc_update_scsiid(struct ahc_softc *ahc, u_int targid_mask)
{
	u_int scsiid_mask;
	u_int scsiid;

	if ((ahc->features & AHC_MULTI_TID) == 0)
		panic("ahc_update_scsiid called on non-multitid unit");

	/*
	 * Since we will rely on the TARGID mask
	 * for selection enables, ensure that OID
	 * in SCSIID is not set to some other ID
	 * that we don't want to allow selections on.
	 */
	if ((ahc->features & AHC_ULTRA2) != 0)
		scsiid = ahc_inb(ahc, SCSIID_ULTRA2);
	else
		scsiid = ahc_inb(ahc, SCSIID);
	scsiid_mask = 0x1 << (scsiid & OID);
	if ((targid_mask & scsiid_mask) == 0) {
		u_int our_id;

		/* ffs counts from 1 */
		our_id = ffs(targid_mask);
		if (our_id == 0)
			our_id = ahc->our_id;
		else
			our_id--;
		scsiid &= TID;
		scsiid |= our_id;
	}
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, scsiid);
	else
		ahc_outb(ahc, SCSIID, scsiid);
}

#ifdef AHC_TARGET_MODE
void
ahc_run_tqinfifo(struct ahc_softc *ahc, int paused)
{
	struct target_cmd *cmd;

	/*
	 * If the card supports auto-access pause,
	 * we can access the card directly regardless
	 * of whether it is paused or not.
	 */
	if ((ahc->features & AHC_AUTOPAUSE) != 0)
		paused = TRUE;

	ahc_sync_tqinfifo(ahc, BUS_DMASYNC_POSTREAD);
	while ((cmd = &ahc->targetcmds[ahc->tqinfifonext])->cmd_valid != 0) {

		/*
		 * Only advance through the queue if we
		 * have the resources to process the command.
		 */
		if (ahc_handle_target_cmd(ahc, cmd) != 0)
			break;

		cmd->cmd_valid = 0;
		ahc_dmamap_sync(ahc, ahc->parent_dmat/*shared_data_dmat*/,
				ahc->shared_data_dmamap,
				ahc_targetcmd_offset(ahc, ahc->tqinfifonext),
				sizeof(struct target_cmd),
#ifdef __sgi__
				BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
#else
				BUS_DMASYNC_PREREAD);
#endif
		ahc->tqinfifonext++;

		/*
		 * Lazily update our position in the target mode incoming
		 * command queue as seen by the sequencer.
		 */
		if ((ahc->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {
			if ((ahc->features & AHC_HS_MAILBOX) != 0) {
				u_int hs_mailbox;

				hs_mailbox = ahc_inb(ahc, HS_MAILBOX);
				hs_mailbox &= ~HOST_TQINPOS;
				hs_mailbox |= ahc->tqinfifonext & HOST_TQINPOS;
				ahc_outb(ahc, HS_MAILBOX, hs_mailbox);
			} else {
				if (!paused)
					ahc_pause(ahc);
				ahc_outb(ahc, KERNEL_TQINPOS,
					 ahc->tqinfifonext & HOST_TQINPOS);
				if (!paused)
					ahc_unpause(ahc);
			}
		}
	}
}
#endif

static int
ahc_handle_target_cmd(struct ahc_softc *ahc, struct target_cmd *cmd)
{
	struct	  ahc_tmode_tstate *tstate;
	struct	  ahc_tmode_lstate *lstate;
	struct	  ccb_accept_tio *atio;
	uint8_t *byte;
	int	  initiator;
	int	  target;
	int	  lun;

	initiator = SCSIID_TARGET(ahc, cmd->scsiid);
	target = SCSIID_OUR_ID(cmd->scsiid);
	lun    = (cmd->identify & MSG_IDENTIFY_LUNMASK);

	byte = cmd->bytes;
	tstate = ahc->enabled_targets[target];
	lstate = NULL;
	if (tstate != NULL)
		lstate = tstate->enabled_luns[lun];

	/*
	 * Commands for disabled luns go to the black hole driver.
	 */
	if (lstate == NULL)
		lstate = ahc->black_hole;

	atio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);
	if (atio == NULL) {
		ahc->flags |= AHC_TQINFIFO_BLOCKED;
		/*
		 * Wait for more ATIOs from the peripheral driver for this lun.
		 */
		if (bootverbose)
			printf("%s: ATIOs exhausted\n", ahc_name(ahc));
		return (1);
	} else
		ahc->flags &= ~AHC_TQINFIFO_BLOCKED;
#if 0
	printf("Incoming command from %d for %d:%d%s\n",
	       initiator, target, lun,
	       lstate == ahc->black_hole ? "(Black Holed)" : "");
#endif
	SLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);

	if (lstate == ahc->black_hole) {
		/* Fill in the wildcards */
		atio->ccb_h.target_id = target;
		atio->ccb_h.target_lun = lun;
	}

	/*
	 * Package it up and send it off to
	 * whomever has this lun enabled.
	 */
	atio->sense_len = 0;
	atio->init_id = initiator;
	if (byte[0] != 0xFF) {
		/* Tag was included */
		atio->tag_action = *byte++;
		atio->tag_id = *byte++;
		atio->ccb_h.flags = CAM_TAG_ACTION_VALID;
	} else {
		atio->ccb_h.flags = 0;
	}
	byte++;

	/* Okay.  Now determine the cdb size based on the command code */
	switch (*byte >> CMD_GROUP_CODE_SHIFT) {
	case 0:
		atio->cdb_len = 6;
		break;
	case 1:
	case 2:
		atio->cdb_len = 10;
		break;
	case 4:
		atio->cdb_len = 16;
		break;
	case 5:
		atio->cdb_len = 12;
		break;
	case 3:
	default:
		/* Only copy the opcode. */
		atio->cdb_len = 1;
		printf("Reserved or VU command code type encountered\n");
		break;
	}

	memcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);

	atio->ccb_h.status |= CAM_CDB_RECVD;

	if ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {
		/*
		 * We weren't allowed to disconnect.
		 * We're hanging on the bus until a
		 * continue target I/O comes in response
		 * to this accept tio.
		 */
#if 0
		printf("Received Immediate Command %d:%d:%d - %p\n",
		       initiator, target, lun, ahc->pending_device);
#endif
		ahc->pending_device = lstate;
		ahc_freeze_ccb((union ccb *)atio);
		atio->ccb_h.flags |= CAM_DIS_DISCONNECT;
	}
	xpt_done((union ccb*)atio);
	return (0);
}
#endif

static int
ahc_createdmamem(bus_dma_tag_t tag, int size, int flags, bus_dmamap_t *mapp,
    caddr_t *vaddr, bus_addr_t *baddr, bus_dma_segment_t *seg, int *nseg,
    const char *myname, const char *what)
{
	int error;

	if ((error = bus_dmamap_create(tag, size, 1, size, 0,
				       BUS_DMA_NOWAIT | flags, mapp)) != 0) {
                printf("%s: failed to create DMA map for %s, error = %d\n",
			myname, what, error);
		return (error);
        }

	if ((error = bus_dmamem_alloc(tag, size, PAGE_SIZE, 0,
				      seg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to allocate DMA mem for %s, error = %d\n",
			myname, what, error);
		goto destroy;
	}

	if ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,
				    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: failed to map DMA mem for %s, error = %d\n",
			myname, what, error);
		goto free;
	}

	if ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,
				     BUS_DMA_NOWAIT)) != 0) {
                printf("%s: failed to load DMA map for %s, error = %d\n",
			myname, what, error);
		goto unmap;
        }

	*baddr = (*mapp)->dm_segs[0].ds_addr;
	return (0);

unmap:
	bus_dmamem_unmap(tag, *vaddr, size);
free:
	bus_dmamem_free(tag, seg, *nseg);
destroy:
	bus_dmamap_destroy(tag, *mapp);

	*vaddr = 0;
	bzero(seg, sizeof(*seg));
	return (error);
}

static void
ahc_freedmamem(bus_dma_tag_t tag, int size, bus_dmamap_t map, caddr_t vaddr,
    bus_dma_segment_t *seg, int nseg)
{

	bus_dmamap_unload(tag, map);
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
	bus_dmamap_destroy(tag, map);
}
@


1.91
log
@Nuke a bunch of leading and trailing whitespace so I don't go blind
reading this code. No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.90 2015/05/07 01:19:00 jsg Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.90 2015/05/07 01:19:00 jsg Exp $
d4237 3
d4302 5
a4306 6
	ahc->next_queued_scb = ahc_get_scb(ahc);

	/*
	 * Note that we were successful
	 */
	return (0);
d4429 1
d4432 1
d6621 1
d6628 1
@


1.90
log
@fix indentation of a line
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.89 2014/12/13 21:05:33 doug Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.89 2014/12/13 21:05:33 doug Exp $
d210 1
a210 1
//static bus_dmamap_callback_t	ahc_dmamap_cb; 
d466 1
a466 1
	
d509 1
a509 1
		hscb = scb->hscb; 
d558 1
a558 1
			sc = (struct scsi_sense *)(&hscb->shared_data.cdb); 
d604 1
a604 1
			if (ahc_get_residual(scb) 
d616 1
a616 1
			hscb->dataptr = sg->addr; 
d690 1
a690 1
	case SEND_REJECT: 
d694 1
a694 1
		       "target (0x%x).  Rejecting\n", 
d696 1
a696 1
		break; 
d787 1
a787 1
				else 
d1051 1
a1051 1
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
d1097 1
a1097 1
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
d1190 2
a1191 2
		 * We've set the hardware to assert ATN if we   
		 * get a parity error on "in" phases, so all we  
d1503 1
a1503 1
		 * Seqaddr represents the next instruction to execute, 
d1509 1
a1509 1
			
d1579 1
a1579 1
 	ahc_flush_device_writes(ahc);
d1736 1
a1736 1
	else 
d1770 1
a1770 1
	
d1802 1
a1802 1
		 	if ((syncrate->sxfr_u2 & ST_SXFR) != 0)
d2146 3
a2148 3
 	ahc_platform_set_tags(ahc, devinfo, alg);
 	ahc_send_async(ahc, devinfo->channel, devinfo->target,
 		       devinfo->lun, AC_TRANSFER_NEG, &alg);
d2249 1
a2249 1
 	   & (CMDPHASE_PENDING|TARG_CMD_PENDING|NO_DISCONNECT)) != 0) {
d2711 1
a2711 1
{ 
d2867 1
a2867 1
		} else 
d2960 1
a2960 1
		
d3117 1
a3117 1
			
d3151 1
a3151 1
			ahc_set_syncrate(ahc, devinfo, 
d3586 1
a3586 1
	 	scb->hscb->control &= mask;
d3839 1
a3839 1
	
d3856 1
a3856 1
	/*              
d3860 1
a3860 1
	 */             
d3883 1
a3883 1
	ahc->pause = ahc->unpause | PAUSE; 
d3925 1
a3925 1
				slave->flags &= ~AHC_BIOS_ENABLED; 
d3928 1
a3928 1
				slave->flags &= ~AHC_PRIMARY_CHANNEL; 
d4053 1
a4053 1
	
d4138 1
a4138 1
	else 
d4167 1
a4167 1
ahc_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) 
d4205 1
a4205 1
		else 
d4286 1
a4286 1
	} while ((i != scb_data->numscbs) && 
d4304 1
a4304 1
	return (0); 
d4400 1
a4400 1
		if (sizeof(*pdata) > 0) { 
d4418 1
a4418 1
		error = bus_dmamap_create(ahc->parent_dmat, 
d4587 1
a4587 1
		
d4718 1
a4718 1
	
d4734 1
a4734 1
	 * The qinfifo and qoutfifo are composed of 256 1 byte elements. 
d4834 1
a4834 1
	ultraenb = 0;	
d4930 1
a4930 1
				 	ultraenb &= ~mask;
d4932 1
a4932 1
				tinfo->user.period = 
d4994 1
a4994 1
		
d5014 1
a5014 1
		
d5032 1
a5032 1
		
d5095 1
a5095 1
	
d5133 1
a5133 1
		ahc_sync_scb(ahc, prev_scb, 
d5353 1
a5353 1
			
d5578 1
a5578 1
{       
d5597 1
a5597 1
		ahc_outb(ahc, WAITING_SCBH, next); 
d5606 1
a5606 1
		 * Select the scb that pointed to us 
d5998 1
a5998 1
		 * stopped.  
d6217 1
a6217 1
				 	end_set[cs_count] = TRUE;
d6562 1
a6562 1
		
d6741 1
a6741 1
		   	 && (ahc->flags & AHC_INITIATORROLE) != 0) {
d6892 1
a6892 1
				
d7016 1
a7016 1
					 	 (targid_mask >> 8));
d7150 1
a7150 1
					ahc_pause(ahc);	
d7250 1
a7250 1
	
@


1.89
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.88 2014/07/13 23:10:23 deraadt Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.88 2014/07/13 23:10:23 deraadt Exp $
d1324 1
a1324 1
				tag = scb->hscb->tag;
@


1.88
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.87 2014/07/12 18:48:17 tedu Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.87 2014/07/12 18:48:17 tedu Exp $
d6235 2
a6236 3

		cs_count *= sizeof(struct cs);
		ahc->critical_sections = malloc(cs_count, M_DEVBUF, M_NOWAIT);
d6239 2
@


1.87
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.86 2013/04/20 20:23:09 miod Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.86 2013/04/20 20:23:09 miod Exp $
d4238 1
a4238 1
	scb_data->scbarray = malloc(sizeof(struct scb) * AHC_SCB_MAX_ALLOC,
@


1.86
log
@In ahc_reset(), use SELxxx constants instead of magic values. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.85 2012/12/05 23:20:16 deraadt Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.85 2012/12/05 23:20:16 deraadt Exp $
d1691 1
a1691 1
		free(tstate, M_DEVBUF);
d3961 1
a3961 1
		free(ahc->name, M_DEVBUF);
d4001 1
a4001 1
					free(lstate, M_DEVBUF);
d4005 1
a4005 1
			free(tstate, M_DEVBUF);
d4011 1
a4011 1
		free(ahc->black_hole, M_DEVBUF);
d4015 1
a4015 1
		free(ahc->seep_config, M_DEVBUF);
d4331 1
a4331 1
			free(sg_map, M_DEVBUF);
d4353 1
a4353 1
		free(scb_data->scbarray, M_DEVBUF);
d4385 1
a4385 1
		free(sg_map, M_DEVBUF);
d6868 1
a6868 1
			free(lstate, M_DEVBUF);
d6989 1
a6989 1
		free(lstate, M_DEVBUF);
@


1.85
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.84 2010/03/14 14:37:01 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.84 2010/03/14 14:37:01 krw Exp $
d4101 1
a4101 1
	case 2:
d4105 1
a4105 1
	case 8:
@


1.84
log
@Quieten ahc a bit, same as ahd is. Put some messages emitted during
an i/o restart inside AHC_DEBUG. Spotted by jsing@@ during sgi probe.
Should be cosmetic only.

Tested by jsing@@.

ok beck@@
ok deraadt@@ for 4.7.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.83 2009/11/18 19:57:09 halex Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.83 2009/11/18 19:57:09 halex Exp $
a47 3

#include <sys/cdefs.h>
/* __FBSDID("$FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.100 2004/05/11 20:39:46 gibbs Exp $"); */
@


1.83
log
@panic on impossible error code
potential off-by-one found by parfait

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.82 2008/07/29 21:18:53 miod Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.82 2008/07/29 21:18:53 miod Exp $
d887 22
a908 20
		ahc_print_path(ahc, scb);
		printf("data overrun detected %s."
		       "  Tag == 0x%x.\n",
		       ahc_phase_table[i].phasemsg,
  		       scb->hscb->tag);
#ifndef SMALL_KERNEL
		ahc_print_path(ahc, scb);
		printf("%s seen Data Phase.  Length = %ld.  NumSGs = %d.\n",
		       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
		       ahc_get_transfer_length(scb), scb->sg_count);
		if (scb->sg_count > 0) {
			for (i = 0; i < scb->sg_count; i++) {

				printf("sg[%d] - Addr 0x%x%x : Length %d\n",
				       i,
				       (aic_le32toh(scb->sg_list[i].len) >> 24
				        & SG_HIGH_ADDR_BITS),
				       aic_le32toh(scb->sg_list[i].addr),
				       aic_le32toh(scb->sg_list[i].len)
				       & AHC_SG_LEN_MASK);
@


1.82
log
@In ahc_free(), which is invoked if attachment fails, do not free()
pointers we don't own, but the autoconf machinery does.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.81 2008/06/25 18:21:48 deraadt Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.81 2008/06/25 18:21:48 deraadt Exp $
d444 2
@


1.81
log
@do not print scsi id, since scsibus does that now; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.80 2007/11/27 16:22:13 martynas Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.80 2007/11/27 16:22:13 martynas Exp $
a4012 4
#ifndef __NetBSD__
	if (ahc->name != NULL)
		free(ahc->name, M_DEVBUF);
#endif
a4014 3
#ifndef __FreeBSD__
	free(ahc, M_DEVBUF);
#endif
@


1.80
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.79 2007/11/25 16:40:04 jmc Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.79 2007/11/25 16:40:04 jmc Exp $
d4453 1
a4453 2
			 "Twin Channel, A SCSI Id=%d, B SCSI Id=%d, "
			 "primary %c, ", ahc->our_id, ahc->our_id_b,
d4473 2
a4474 2
			 "%s%s Channel %c, SCSI Id=%d, ",
			 speed, type, ahc->channel, ahc->our_id);
@


1.79
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.78 2007/10/20 22:44:00 fgsch Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.78 2007/10/20 22:44:00 fgsch Exp $
d1227 1
a1227 1
		 * LED does.  SELINGO is only cleared by a successfull
d4308 1
a4308 1
	 * Note that we were successfull
@


1.78
log
@Remove unneeded scope declarations that shadows existing ones. krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.77 2007/09/07 17:58:39 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.77 2007/09/07 17:58:39 krw Exp $
d1227 1
a1227 1
		 * LED does.  SELINGO is only cleared by a sucessfull
@


1.77
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.76 2007/05/26 21:53:16 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.76 2007/05/26 21:53:16 krw Exp $
d466 1
a479 1
		u_int  scb_index;
a746 2
			struct scb *scb;
			u_int scb_index;
a848 3
					struct	scb *scb;
					u_int	scb_index;

a4067 2
		u_int sblkctl;

a4128 2
		u_int sblkctl;

a5929 2
			struct ahc_devinfo devinfo;

@


1.76
log
@'recevied' -> 'received' in a displayed message. From Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.75 2007/05/14 01:37:49 deraadt Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.75 2007/05/14 01:37:49 deraadt Exp $
d1647 1
a1647 2
	tstate = (struct ahc_tmode_tstate*)malloc(sizeof(*tstate),
						   M_DEVBUF, M_NOWAIT);
d1667 1
a1667 2
	} else
		memset(tstate, 0, sizeof(*tstate));
d3890 2
a3891 2
		ahc->scb_data = malloc(sizeof(*ahc->scb_data),
				       M_DEVBUF, M_NOWAIT);
a3893 1
		memset(ahc->scb_data, 0, sizeof(*ahc->scb_data));
d4253 2
a4254 3
	scb_data->scbarray =
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX_ALLOC,
				 M_DEVBUF, M_NOWAIT);
a4256 1
	memset(scb_data->scbarray, 0, sizeof(struct scb) * AHC_SCB_MAX_ALLOC);
d4416 2
a4417 2
			pdata = (struct scb_platform_data *)
			    malloc(sizeof(*pdata), M_DEVBUF, M_NOWAIT);
a4419 1
			bzero(pdata, sizeof(*pdata));
d6874 1
a6874 1
		lstate = malloc(sizeof(*lstate), M_DEVBUF, M_NOWAIT);
a6880 1
		memset(lstate, 0, sizeof(*lstate));
@


1.75
log
@delete unused code; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.74 2007/05/02 02:20:36 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.74 2007/05/02 02:20:36 krw Exp $
d1172 1
a1172 1
					       "recevied\n");
@


1.74
log
@Eliminate unused inline functions and replace ahc_lock() which
resolves to s = splbio() and ahc_unlock() which resolves to splx(s)
with splbio/splx calls.

ok marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.73 2006/07/30 14:21:14 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.73 2006/07/30 14:21:14 krw Exp $
a3957 16
/*
 * Verify that the passed in softc pointer is for a
 * controller that is still configured.
 */
struct ahc_softc *
ahc_find_softc(struct ahc_softc *ahc)
{
	struct ahc_softc *list_ahc;

	TAILQ_FOREACH(list_ahc, &ahc_tailq, links) {
		if (list_ahc == ahc)
			return (ahc);
	}
	return (NULL);
}

d4457 1
d4501 1
a5002 83
/*
 * Ensure that the card is paused in a location
 * outside of all critical sections and that all
 * pending work is completed prior to returning.
 * This routine should only be called from outside
 * an interrupt context.
 */
void
ahc_pause_and_flushwork(struct ahc_softc *ahc)
{
	int intstat;
	int maxloops;
	int paused;

	maxloops = 1000;
	ahc->flags |= AHC_ALL_INTERRUPTS;
	paused = FALSE;
	do {
		if (paused) {
			ahc_unpause(ahc);
			/*
			 * Give the sequencer some time to service
			 * any active selections.
			 */
			aic_delay(500);
		}
		ahc_intr(ahc);
		ahc_pause(ahc);
		paused = TRUE;
		ahc_outb(ahc, SCSISEQ, ahc_inb(ahc, SCSISEQ) & ~ENSELO);
		intstat = ahc_inb(ahc, INTSTAT);
		if ((intstat & INT_PEND) == 0) {
			ahc_clear_critical_section(ahc);
			intstat = ahc_inb(ahc, INTSTAT);
		}
	} while (--maxloops
	      && (intstat != 0xFF || (ahc->features & AHC_REMOVABLE) == 0)
	      && ((intstat & INT_PEND) != 0
	       || (ahc_inb(ahc, SSTAT0) & (SELDO|SELINGO)) != 0));
	if (maxloops == 0) {
		printf("Infinite interrupt loop, INTSTAT = %x",
		       ahc_inb(ahc, INTSTAT));
	}
	ahc_platform_flushwork(ahc);
	ahc->flags &= ~AHC_ALL_INTERRUPTS;
}

int
ahc_suspend(struct ahc_softc *ahc)
{

	ahc_pause_and_flushwork(ahc);

	if (LIST_FIRST(&ahc->pending_scbs) != NULL) {
		ahc_unpause(ahc);
		return (EBUSY);
	}

#ifdef AHC_TARGET_MODE
	/*
	 * XXX What about ATIOs that have not yet been serviced?
	 * Perhaps we should just refuse to be suspended if we
	 * are acting in a target role.
	 */
	if (ahc->pending_device != NULL) {
		ahc_unpause(ahc);
		return (EBUSY);
	}
#endif
	ahc_shutdown(ahc);
	return (0);
}

int
ahc_resume(struct ahc_softc *ahc)
{

	ahc_reset(ahc, /*reinit*/TRUE);
	ahc_intr_enable(ahc, TRUE); 
	ahc_restart(ahc);
	return (0);
}

d6437 1
d6483 1
d7124 1
d7183 1
@


1.73
log
@Make [ahc|ahd]_print_register() consistant, since they are both called
by the same aicasm-generated code. ahc_print_register() now just
tracks the return values of printf() as ahd_print_register() was
doing.

Eliminates a 1024 character buffer on the stack that
ahc_print_register() was using to keep track of the number of
characters printed.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.72 2006/02/06 17:29:10 jmc Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.72 2006/02/06 17:29:10 jmc Exp $
d6901 1
a6901 1
		ahc_lock(ahc, &s);
d6904 1
a6904 1
			ahc_unlock(ahc, &s);
d6925 1
a6925 1
			ahc_unlock(ahc, &s);
d6930 1
a6930 1
		ahc_unlock(ahc, &s);
d6996 1
a6996 1
		ahc_lock(ahc, &s);
d7062 1
a7062 1
		ahc_unlock(ahc, &s);
d7075 2
a7076 2
		ahc_lock(ahc, &s);
		
d7086 1
a7086 1
				ahc_unlock(ahc, &s);
d7102 1
a7102 1
			ahc_unlock(ahc, &s);
d7177 1
a7177 1
		ahc_unlock(ahc, &s);
@


1.72
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.71 2005/12/28 03:00:07 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.71 2005/12/28 03:00:07 krw Exp $
a6539 1
	char line[1024];
a6541 3
	line[0] = 0;
	printed_mask = 0;

d6546 7
a6552 3
	snprintf(line, sizeof(line), "%s[0x%x]", name, value);
	if (table == NULL)
		goto done;
d6554 1
d6561 4
a6564 5
			if (printed_mask == 0)
				strlcat(line, ":(", sizeof line);
			else
				strlcat(line, "|", sizeof line);
			strlcat(line, table[entry].name, sizeof line);
d6566 1
a6571 6
	if (printed_mask != 0)
		strlcat(line, ")", sizeof line);

done:
	printf("%s ", line);
	printed = strlen(line) + 1;
d6573 1
@


1.71
log
@Strip out fancy timeout code that attempts to mimic FreeBSD's thread
based timeout handling. Use the simple timeout == bus reset model
instead. Also move verbose debug output inside #ifdef/#endif.

Fixes pulling out a raidctl disk causing a crash noted by kurt@@.
Rebuilding the raid still problematic.

Reduces but does not eliminate crashes with 'smartctl -d scsi -a
/dev/rcd0c' seen by Sigfried H?versen.

Should only impact timeout handling. No change to normal processing.

Thanks to kurt@@ and Sigfied for testing.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.70 2005/12/04 03:56:17 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.70 2005/12/04 03:56:17 krw Exp $
d4657 1
a4657 1
	 * If we are a target, we'll enalbe select in operations once
@


1.70
log
@Allocate all scbs during initialization to avoid using
bus_dmamem_alloc() in interrupt context.

Use same logic as ahd.

"Looks good to me" pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.69 2005/12/01 02:21:13 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.69 2005/12/01 02:21:13 krw Exp $
d956 1
a956 2
		if (scb != NULL
		 && (scb->flags & SCB_RECOVERY_SCB) != 0)
@


1.69
log
@bus_dma code clean up. No functional change. Polished form of diff
from marco@@.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.68 2005/10/04 23:52:04 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.68 2005/10/04 23:52:04 krw Exp $
d4266 1
d4320 5
a4324 1
	ahc_alloc_scbs(ahc);
d4326 1
a4326 1
	if (scb_data->numscbs == 0) {
@


1.68
log
@Sync with new aicasm.c. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.67 2005/08/07 17:14:57 deraadt Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.67 2005/08/07 17:14:57 deraadt Exp $
d7397 8
a7404 1
	int error, level = 0;
d7410 1
a7410 1
		goto out;
a7411 1
	level++;
d7417 1
a7417 1
		goto out;
a7418 10
	level++;

	if ((error = bus_dmamap_create(tag, size, 1, size, 0,
				       BUS_DMA_NOWAIT | flags, mapp)) != 0) {
                printf("%s: failed to create DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }
	level++;

d7424 1
a7424 1
		goto out;
d7428 1
d7430 6
a7435 16
	return 0;
out:
	printf("ahc_createdmamem error (%d)\n", level);
	switch (level) {
	case 3:
		bus_dmamap_destroy(tag, *mapp);
		/* FALLTHROUGH */
	case 2:
		bus_dmamem_unmap(tag, *vaddr, size);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(tag, seg, *nseg);
		break;
	default:
		break;
	}
d7437 3
a7439 1
	return error;
a7447 1
	bus_dmamap_destroy(tag, map);
d7450 1
@


1.67
log
@remove some scsi bus warnings and gunk if on a ramdisk; semi-ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.66 2005/07/18 02:43:26 fgsch Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.66 2005/07/18 02:43:26 fgsch Exp $
d6262 3
a6264 3
	struct	cs cs_table[num_critical_sections];
	u_int	begin_set[num_critical_sections];
	u_int	end_set[num_critical_sections];
d6329 1
a6329 1
		for (; cur_cs < num_critical_sections; cur_cs++) {
@


1.66
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.65 2005/06/01 21:49:53 miod Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.65 2005/06/01 21:49:53 miod Exp $
d89 1
d101 1
d437 1
d450 1
d895 1
d912 1
d990 1
d1011 1
d6583 1
d6762 1
@


1.65
log
@De-inline a few functions if option SMALL_KERNEL, and do not compile
ahc_print_scb() unless option AHC_DEBUG.

Saves about 3KB on alpha RAMDISK{,B}.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.64 2005/04/17 18:54:41 tom Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.64 2005/04/17 18:54:41 tom Exp $
d6101 1
a6101 1
		panic("Bogus resid sgptr value 0x%x\n", resid_sgptr);
@


1.64
log
@Typo in panic string

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.62 2005/01/12 00:35:32 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.63 2005/02/20 15:35:35 miod Exp $
d53 3
a1583 1
#endif
d1617 1
@


1.63
log
@Do not confuse syslog by printing messages starting with '<'.

ok krw@@
@
text
@d43 1
a43 1
 * $Id: aic7xxx.c,v 1.62 2005/01/12 00:35:32 krw Exp $
d976 1
a976 1
		panic("for saftey");
@


1.62
log
@Fix an off by one in the critical section clearing code. The code was
adjusting twice for the instruction pointer indicating the *next*
instruction to execute.

From FreeBSD r1.101.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.61 2004/12/30 17:20:09 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.61 2004/12/30 17:20:09 krw Exp $
d6595 1
a6595 1
	printf(">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\n"
d6746 1
a6746 1
	printf("\n<<<<<<<<<<<<<<<<< Dump Card State Ends >>>>>>>>>>>>>>>>>>\n");
@


1.61
log
@Clean up some code to eliminate snprintf() return value abuse noted by
Theo.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.60 2004/10/24 04:28:33 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.60 2004/10/24 04:28:33 krw Exp $
a1500 2
		if (seqaddr != 0)
			seqaddr -= 1;
@


1.60
log
@Shuffle defines around so that ahc and ahd use the aic_ names that
come with the freebsd sources, rather than duplicating those names in
the ahd_ and ahc_ namespaces. Big reduction in delta to freebsd
sources, which reduces noise when updating the code.

No .o differences found on i386.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.59 2004/08/13 23:38:54 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.59 2004/08/13 23:38:54 krw Exp $
d6526 3
a6528 3
	int	printed;
	u_int	printed_mask;
	char    line[1024];
d6531 1
d6537 4
a6540 10
	printed = snprintf(line, sizeof(line), "%s[0x%x]", name, value);
	if (table == NULL) {
		printed += snprintf(&line[printed], (sizeof line) - printed,
		    " ");
		printf("%s", line);
		if (cur_column != NULL)
			*cur_column += printed;
		return (printed);
	}
	printed_mask = 0;
a6541 2
		int entry;

d6543 3
a6545 4
			if (((value & table[entry].mask)
			  != table[entry].value)
			 || ((printed_mask & table[entry].mask)
			  == table[entry].mask))
d6547 5
a6551 4
			printed += snprintf(&line[printed],
			    (sizeof line) - printed, "%s%s", 
				printed_mask == 0 ? ":(" : "|",
				table[entry].name);
a6552 1
			
d6559 6
a6564 5
		printed += snprintf(&line[printed],
		    (sizeof line) - printed, ") ");
	else
		printed += snprintf(&line[printed],
		    (sizeof line) - printed, " ");
a6566 1
	printf("%s", line);
@


1.59
log
@Fix issue with auto request sense handling for both ahc and ahd.

Restore hppa functionality, add sgi functionality for ahc.

ok deraadt@@, plus marco@@, mickey@@, pefo@@ for various bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.58 2004/08/01 01:36:23 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.58 2004/08/01 01:36:23 krw Exp $
d568 2
a569 2
			sg->addr = ahc_htole32(sg->addr);
			sg->len = ahc_htole32(sg->len);
d613 1
a613 1
			hscb->sgptr = ahc_htole32(hscb->sgptr);
d839 1
a839 1
					ahc_delay(100);
d897 1
a897 1
				       (ahc_le32toh(scb->sg_list[i].len) >> 24
d899 2
a900 2
				       ahc_le32toh(scb->sg_list[i].addr),
				       ahc_le32toh(scb->sg_list[i].len)
d1554 1
a1554 1
			ahc_delay(200);
d1602 3
a1604 3
		ahc_le32toh(hscb->dataptr),
		ahc_le32toh(hscb->datacnt),
		ahc_le32toh(hscb->sgptr),
d1610 1
a1610 1
			       (ahc_le32toh(scb->sg_list[i].len) >> 24
d1612 2
a1613 2
			       ahc_le32toh(scb->sg_list[i].addr),
			       ahc_le32toh(scb->sg_list[i].len));
d3698 1
a3698 1
			sglen = ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
d3703 1
a3703 1
				sglen = ahc_le32toh(sg->len);
d3709 1
a3709 1
				data_addr = ahc_le32toh(sg->addr)
d3765 2
a3766 2
	dataptr = ahc_le32toh(sg->addr)
		+ (ahc_le32toh(sg->len) & AHC_SG_LEN_MASK)
d3774 1
a3774 1
			 (ahc_le32toh(sg->len) >> 24) & SG_HIGH_ADDR_BITS);
d4107 1
a4107 1
		ahc_delay(1000);
d4685 1
a4685 1
			ahc_delay(100);
d5028 1
a5028 1
			ahc_delay(500);
d5874 1
a5874 1
	ahc_delay(AHC_BUSRESET_DELAY);
d6081 1
a6081 1
	sgptr = ahc_le32toh(hscb->sgptr);
d6092 1
a6092 1
	resid_sgptr = ahc_le32toh(spkt->residual_sg_ptr);
d6108 1
a6108 1
		resid = ahc_le32toh(spkt->residual_datacnt) & AHC_SG_LEN_MASK;
d6119 1
a6119 1
		while ((ahc_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {
d6121 1
a6121 1
			resid += ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
d6407 1
a6407 1
	instr.integer = ahc_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
d6512 1
a6512 1
		instr.integer = ahc_htole32(instr.integer);
@


1.58
log
@Fold in relevant bits of the most recent two updates from
gibbs@@freebsd.

Large commit messages detailing all changes can be read at revisions
1.97 and 1.100 of aic7xxx.c:

www.freebsd.org/cgi/cvsweb.cgi/src/sys/dev/aic7xxx/aic7xxx.c

Tested by marco, nate and pefo. Fixed broken system for nate.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.57 2004/06/05 04:32:50 deraadt Exp $	*/
d43 1
a43 1
 * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.c#155 $
d335 27
d379 1
d4569 3
d4573 1
a4573 1

d4786 3
d4790 1
d7244 3
d7248 1
@


1.57
log
@another try to re-add it
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.55 2004/02/22 16:06:26 krw Exp $	*/
d43 1
a43 5
 * $Id: aic7xxx.c,v 1.55 2004/02/22 16:06:26 krw Exp $
 *
 * //depot/aic7xxx/aic7xxx/aic7xxx.c#112 $
 *
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx.c,v 1.88 2003/01/20 20:44:55 gibbs Exp $
d50 1
a50 1
/* __KERNEL_RCSID(0, "$NetBSD: aic7xxx.c,v 1.108 2003/11/02 11:07:44 wiz Exp $"); */
d147 2
a148 1
static void		ahc_force_renegotiation(struct ahc_softc *);
d202 1
a202 1
#if AHC_TARGET_MODE
d225 1
a225 1
static void		ahc_loadseq(struct ahc_softc *ahc);
d308 8
d317 1
a317 1
	ahc_outb(ahc, SEQCTL, FASTMODE);
d320 1
d485 1
d488 1
d748 1
a748 1
#if AHC_TARGET_MODE
d1076 9
a1084 8
		u_int mesg_out;
		u_int curphase;
		u_int errorphase;
		u_int lastphase;
		u_int scsirate;
		u_int i;
		u_int sstat2;
		int   silent;
d1173 3
a1175 1
		ahc_force_renegotiation(ahc);
d1212 1
d1220 1
a1220 10
			/*
			 * Force a renegotiation with this target just in
			 * case the cable was pulled and will later be
			 * re-attached.  The target may forget its negotiation
			 * settings with us should it attempt to reselect
			 * during the interruption.  The target will not issue
			 * a unit attention in this case, so we must always
			 * renegotiate.
			 */
			ahc_force_renegotiation(ahc);
d1223 11
d1239 8
a1246 7
		u_int lastphase;
		u_int saved_scsiid;
		u_int saved_lun;
		u_int target;
		u_int initiator_role_id;
		char channel;
		int printerror;
d1278 2
a1282 1
			struct ahc_devinfo devinfo;
a1284 1
			ahc_fetch_devinfo(ahc, &devinfo);
d1348 1
a1348 3
						MSG_EXT_WDTR, FALSE)
				|| ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_SDTR, FALSE)) {
d1350 1
a1350 1
				 * Negotiation Rejected.  Go-async and
d1357 8
d1401 9
a1409 7
			/*
			 * Renegotiate with this device at the
			 * next opportunity just in case this busfree
			 * is due to a negotiation mismatch with the
			 * device.
			 */
			ahc_force_renegotiation(ahc);
d1430 1
a1430 1
ahc_force_renegotiation(struct ahc_softc *ahc)
a1431 1
	struct	ahc_devinfo devinfo;
a1434 1
	ahc_fetch_devinfo(ahc, &devinfo);
d1436 3
a1438 3
					devinfo.channel,
					devinfo.our_scsiid,
					devinfo.target,
d1440 1
a1440 1
	ahc_update_neg_request(ahc, &devinfo, tstate,
d1513 1
a1513 1
				ahc_outb(ahc, SIMODE1, ENBUSFREE);
d1517 1
a1517 1
			ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) | STEP);
d1531 1
a1531 1
		ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) & ~STEP);
a1541 1
	ahc_flush_device_writes(ahc);
d2117 2
d2423 1
d2431 1
a2431 1
	dosync = tinfo->curr.period != period;
d3227 11
a3240 5
			/* After a wide message, we are async */
			ahc_set_syncrate(ahc, devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, /*ppr_options*/0,
					 AHC_TRANS_ACTIVE, /*paused*/TRUE);
d3243 8
a3250 7
				if (tinfo->goal.offset) {
					ahc->msgout_index = 0;
					ahc->msgout_len = 0;
					ahc_build_transfer_msg(ahc, devinfo);
					ahc->msgout_index = 0;
					response = TRUE;
				}
d3631 1
a3631 1
		 && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {
d3644 14
a3657 14
			/* Pull in the rest of the sgptr */
			sgptr |= (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8);
			sgptr &= SG_PTR_MASK;
			data_cnt = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+3) << 24)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+2) << 16)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+1) << 8)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT));

			data_addr = (ahc_inb(ahc, SHADDR + 3) << 24)
				  | (ahc_inb(ahc, SHADDR + 2) << 16)
				  | (ahc_inb(ahc, SHADDR + 1) << 8)
				  | (ahc_inb(ahc, SHADDR));
d3661 1
d3664 1
a3689 7
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 3,
					 sgptr >> 24);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 2,
					 sgptr >> 16);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 1,
					 sgptr >> 8);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR, sgptr);
d3691 10
a3700 5

			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 3, data_cnt >> 24);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 2, data_cnt >> 16);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 1, data_cnt >> 8);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT, data_cnt);
d3810 3
a3812 2
	ahc_send_async(ahc, devinfo->channel, devinfo->target,
	  CAM_LUN_WILDCARD, AC_SENT_BDR, NULL);
d3913 1
a3913 1
	    && ahc_softc_comp(list_ahc, ahc) <= 0)
a3956 1
	ahc_fini_scbdata(ahc);
a3960 1
		/* TAILQ_REMOVE(&ahc_tailq, ahc, links); XXX */
d3973 1
d3979 1
a3979 1
#if AHC_TARGET_MODE
d3995 1
a3995 1
#if AHC_TARGET_MODE
d4022 1
a4022 1
	ahc_reset(ahc);
d4033 6
a4038 1
 * that is only available just after a reset.
d4041 1
a4041 1
ahc_reset(struct ahc_softc *ahc)
d4045 1
a4053 8
	if ((ahc_inb(ahc, HCNTRL) & CHIPRST) != 0) {
		/*
		 * The chip has not been initialized since
		 * PCI/EISA/VLB bus reset.  Don't trust
		 * "left over BIOS data".
		 */
		ahc->flags |= AHC_NO_BIOS_INIT;
	}
d4128 7
d4136 1
a4136 1
	if (ahc->init_level == 0)
d4140 1
a4140 1
	return (0);
d4212 8
a4244 7
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		/* SCB 0 heads the free list */
		ahc_outb(ahc, FREE_SCBH, 0);
	} else {
		ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	}

a4249 2
	ahc_build_free_scb_list(ahc);

a4282 1
	scb_data->init_level++;
d4292 1
a4292 1
	 * Tell the sequencer which SCB will be the next one it receives.
a4294 1
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);
d4412 1
a4412 1
		next_scb->flags = SCB_FREE;
d4470 1
a4470 1
			 ahc->scb_data->maxhscbs, AHC_SCB_MAX);
a4475 3
/*
 * Start the board, ready for normal operation
 */
d4477 1
a4477 1
ahc_init(struct ahc_softc *ahc)
a4478 2
	int	 max_targ;
	int	 i;
d4480 2
a4483 4
	u_int	 ultraenb;
	u_int	 discenable;
	u_int	 tagenable;
	size_t	 driver_data_size;
a4485 117
#ifdef AHC_DEBUG
	if ((ahc_debug & AHC_DEBUG_SEQUENCER) != 0)
		ahc->flags |= AHC_SEQUENCER_DEBUG;
#endif

#ifdef AHC_PRINT_SRAM
	printf("Scratch Ram:");
	for (i = 0x20; i < 0x5f; i++) {
		if (((i % 8) == 0) && (i != 0)) {
			printf ("\n              ");
		}
		printf (" 0x%x", ahc_inb(ahc, i));
	}
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0x70; i < 0x7f; i++) {
			if (((i % 8) == 0) && (i != 0)) {
				printf ("\n              ");
			}
			printf (" 0x%x", ahc_inb(ahc, i));
		}
	}
	printf ("\n");
	/*
	 * Reading uninitialized scratch ram may
	 * generate parity errors.
	 */
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
#endif
	max_targ = 15;

	/*
	 * Assume we have a board at this stage and it has been reset.
	 */
	if ((ahc->flags & AHC_USEDEFAULTS) != 0)
		ahc->our_id = ahc->our_id_b = 7;
	
	/*
	 * Default to allowing initiator operations.
	 */
	ahc->flags |= AHC_INITIATORROLE;

	/*
	 * Only allow target mode features if this unit has them enabled.
	 */
	//if ((AHC_TMODE_ENABLE & (0x1 << ahc->unit)) == 0)
		ahc->features &= ~AHC_TARGETMODE;

	/*
	 * DMA tag for our command fifos and other data in system memory
	 * the card's sequencer must be able to access.  For initiator
	 * roles, we need to allocate space for the qinfifo and qoutfifo.
	 * The qinfifo and qoutfifo are composed of 256 1 byte elements. 
	 * When providing for the target mode role, we must additionally
	 * provide space for the incoming target command fifo and an extra
	 * byte to deal with a DMA bug in some chip versions.
	 */
	driver_data_size = 2 * 256 * sizeof(uint8_t);
	if ((ahc->features & AHC_TARGETMODE) != 0)
		driver_data_size += AHC_TMODE_CMDS * sizeof(struct target_cmd)
				 + /*DMA WideOdd Bug Buffer*/1;

	if (ahc_createdmamem(ahc->parent_dmat, driver_data_size,
			     ahc->sc_dmaflags,
			     &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,
			     &ahc->shared_data_busaddr, &ahc->shared_data_seg,
			     &ahc->shared_data_nseg, ahc_name(ahc), "shared data") < 0)
		return (ENOMEM);

	ahc->init_level++;

	if ((ahc->features & AHC_TARGETMODE) != 0) {
		ahc->targetcmds = (struct target_cmd *)ahc->qoutfifo;
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[AHC_TMODE_CMDS];
		ahc->dma_bug_buf = ahc->shared_data_busaddr
				 + driver_data_size - 1;
		/* All target command blocks start out invalid. */
		for (i = 0; i < AHC_TMODE_CMDS; i++)
			ahc->targetcmds[i].cmd_valid = 0;
		ahc_sync_tqinfifo(ahc, BUS_DMASYNC_PREREAD);
		ahc->tqinfifonext = 1;
		ahc_outb(ahc, KERNEL_TQINPOS, ahc->tqinfifonext - 1);
		ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[256];
	}
	ahc->qinfifo = &ahc->qoutfifo[256];

	ahc->init_level++;

	/* Allocate SCB data now that buffer_dmat is initialized */
	if (ahc->scb_data->maxhscbs == 0)
		if (ahc_init_scbdata(ahc) != 0)
		  return (ENOMEM);

	if (bootverbose)
		printf("%s: found %d SCBs\n", ahc_name(ahc),
		    ahc->scb_data->maxhscbs);

	/*
	 * Allocate a tstate to house information for our
	 * initiator presence on the bus as well as the user
	 * data for any target mode initiator.
	 */
	if (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {
		printf("%s: unable to allocate ahc_tmode_tstate.  "
		       "Failing attach\n", ahc_name(ahc));
		return (ENOMEM);
	}

	if ((ahc->features & AHC_TWIN) != 0) {
		if (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {
			printf("%s: unable to allocate ahc_tmode_tstate.  "
			       "Failing attach\n", ahc_name(ahc));
			return (ENOMEM);
		}
	}

a4488 17
	if (ahc->scb_data->maxhscbs < AHC_SCB_MAX_ALLOC) {
		ahc->flags |= AHC_PAGESCBS;
	} else {
		ahc->flags &= ~AHC_PAGESCBS;
	}

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOW_MISC) {
		printf("%s: hardware scb %lu bytes; kernel scb %lu bytes; "
		       "ahc_dma %lu bytes\n",
			ahc_name(ahc),
			(u_long)sizeof(struct hardware_scb),
			(u_long)sizeof(struct scb),
			(u_long)sizeof(struct ahc_dma_seg));
	}
#endif /* AHC_DEBUG */

d4493 1
a4493 2
		 * The device is gated to channel B after a chip reset,
		 * so set those values first
a4505 4
		if ((scsi_conf & RESET_SCSI) != 0
		 && (ahc->flags & AHC_INITIATORROLE) != 0)
			ahc->flags |= AHC_RESET_BUS_B;

a4508 1

d4523 5
a4527 3
	if ((scsi_conf & RESET_SCSI) != 0
	 && (ahc->flags & AHC_INITIATORROLE) != 0)
		ahc->flags |= AHC_RESET_BUS_A;
d4529 295
a4823 6
	/*
	 * Look at the information that board initialization or
	 * the board bios has left us.
	 */
	ultraenb = 0;	
	tagenable = ALL_TARGETS_MASK;
d4873 1
a4873 1
			tinfo->user.offset = ~0;
d4908 1
a4908 1
					tinfo->user.offset = ~0;
d4926 1
a4926 1
					tinfo->user.offset = ~0;
d4949 1
a4949 124
	/* There are no untagged SCBs active yet. */
	for (i = 0; i < 16; i++) {
		ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, 0));
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			int lun;

			/*
			 * The SCB based BTT allows an entry per
			 * target and lun pair.
			 */
			for (lun = 1; lun < AHC_NUM_LUNS; lun++)
				ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, lun));
		}
	}

	/* All of our queues are empty */
	for (i = 0; i < 256; i++)
		ahc->qoutfifo[i] = SCB_LIST_NULL;

	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREREAD);

	for (i = 0; i < 256; i++)
		ahc->qinfifo[i] = SCB_LIST_NULL;

	ahc_sync_qinfifo(ahc, BUS_DMASYNC_PREWRITE);

	if ((ahc->features & AHC_MULTI_TID) != 0) {
		ahc_outb(ahc, TARGID, 0);
		ahc_outb(ahc, TARGID + 1, 0);
	}

	/*
	 * Tell the sequencer where it can find our arrays in memory.
	 */
	physaddr = ahc->scb_data->hscb_busaddr;
	ahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);

	physaddr = ahc->shared_data_busaddr;
	ahc_outb(ahc, SHARED_DATA_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 3, (physaddr >> 24) & 0xFF);

	/*
	 * Initialize the group code to command length table.
	 * This overrides the values in TARG_SCSIRATE, so only
	 * setup the table after we have processed that information.
	 */
	ahc_outb(ahc, CMDSIZE_TABLE, 5);
	ahc_outb(ahc, CMDSIZE_TABLE + 1, 9);
	ahc_outb(ahc, CMDSIZE_TABLE + 2, 9);
	ahc_outb(ahc, CMDSIZE_TABLE + 3, 0);
	ahc_outb(ahc, CMDSIZE_TABLE + 4, 15);
	ahc_outb(ahc, CMDSIZE_TABLE + 5, 11);
	ahc_outb(ahc, CMDSIZE_TABLE + 6, 0);
	ahc_outb(ahc, CMDSIZE_TABLE + 7, 0);
		
	/* Tell the sequencer of our initial queue positions */
	ahc_outb(ahc, KERNEL_QINPOS, 0);
	ahc_outb(ahc, QINPOS, 0);
	ahc_outb(ahc, QOUTPOS, 0);

	/*
	 * Use the built in queue management registers
	 * if they are available.
	 */
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);
		ahc_outb(ahc, SDSCB_QOFF, 0);
		ahc_outb(ahc, SNSCB_QOFF, 0);
		ahc_outb(ahc, HNSCB_QOFF, 0);
	}


	/* We don't have any waiting selections */
	ahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);

	/* Our disconnection list is empty too */
	ahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);

	/* Message out buffer starts empty */
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);

	/*
	 * Setup the allowed SCSI Sequences based on operational mode.
	 * If we are a target, we'll enalbe select in operations once
	 * we've had a lun enabled.
	 */
	scsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;
	if ((ahc->flags & AHC_INITIATORROLE) != 0)
		scsiseq_template |= ENRSELI;
	ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);

	/*
	 * Load the Sequencer program and Enable the adapter
	 * in "fast" mode.
	 */
	if (bootverbose)
		printf("%s: Downloading Sequencer Program...",
		       ahc_name(ahc));

	ahc_loadseq(ahc);

	if ((ahc->features & AHC_ULTRA2) != 0) {
		int wait;

		/*
		 * Wait for up to 500ms for our transceivers
		 * to settle.  If the adapter does not have
		 * a cable attached, the transceivers may
		 * never settle, so don't complain if we
		 * fail here.
		 */
		ahc_pause(ahc);
		for (wait = 5000;
		     (ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
		     wait--)
			ahc_delay(100);
		ahc_unpause(ahc);
	}
	return (0);
a4984 1
	intstat = 0;
d4993 1
a4993 1
			ahc_delay(200);
d4999 5
a5003 3
		ahc_clear_critical_section(ahc);
		if (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0)
			break;
d5005 3
a5007 2
	      && (((intstat = ahc_inb(ahc, INTSTAT)) & INT_PEND) != 0
	       || (ahc_inb(ahc, SSTAT0) & (SELDO|SELINGO))));
a5018 2
	uint8_t *ptr;
	int	 i;
d5022 2
a5023 1
	if (LIST_FIRST(&ahc->pending_scbs) != NULL)
d5025 1
d5027 1
a5027 1
#if AHC_TARGET_MODE
d5033 2
a5034 1
	if (ahc->pending_device != NULL)
d5036 1
a5037 64

	/* Save volatile registers */
	if ((ahc->features & AHC_TWIN) != 0) {
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		ahc->suspend_state.channel[1].scsiseq = ahc_inb(ahc, SCSISEQ);
		ahc->suspend_state.channel[1].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
		ahc->suspend_state.channel[1].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
		ahc->suspend_state.channel[1].simode0 = ahc_inb(ahc, SIMODE0);
		ahc->suspend_state.channel[1].simode1 = ahc_inb(ahc, SIMODE1);
		ahc->suspend_state.channel[1].seltimer = ahc_inb(ahc, SELTIMER);
		ahc->suspend_state.channel[1].seqctl = ahc_inb(ahc, SEQCTL);
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
	}
	ahc->suspend_state.channel[0].scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc->suspend_state.channel[0].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
	ahc->suspend_state.channel[0].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
	ahc->suspend_state.channel[0].simode0 = ahc_inb(ahc, SIMODE0);
	ahc->suspend_state.channel[0].simode1 = ahc_inb(ahc, SIMODE1);
	ahc->suspend_state.channel[0].seltimer = ahc_inb(ahc, SELTIMER);
	ahc->suspend_state.channel[0].seqctl = ahc_inb(ahc, SEQCTL);

	if ((ahc->chip & AHC_PCI) != 0) {
		ahc->suspend_state.dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		ahc->suspend_state.dspcistatus = ahc_inb(ahc, DSPCISTATUS);
	}

	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;

		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc->suspend_state.optionmode = ahc_inb(ahc, OPTIONMODE);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc->suspend_state.crccontrol1 = ahc_inb(ahc, CRCCONTROL1);
	}

	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc->suspend_state.scbbaddr = ahc_inb(ahc, SCBBADDR);

	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc->suspend_state.dff_thrsh = ahc_inb(ahc, DFF_THRSH);

	ptr = ahc->suspend_state.scratch_ram;
	for (i = 0; i < 64; i++)
		*ptr++ = ahc_inb(ahc, SRAM_BASE + i);

	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0; i < 16; i++)
			*ptr++ = ahc_inb(ahc, TARG_OFFSET + i);
	}

	ptr = ahc->suspend_state.btt;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		for (i = 0;i < AHC_NUM_TARGETS; i++) {
			int j;

			for (j = 0;j < AHC_NUM_LUNS; j++) {
				u_int tcl;

				tcl = BUILD_TCL(i << 4, j);
				*ptr = ahc_index_busy_tcl(ahc, tcl);
			}
		}
	}
a5044 2
	uint8_t *ptr;
	int	 i;
d5046 3
a5048 72
	ahc_reset(ahc);

	ahc_build_free_scb_list(ahc);

	/* Restore volatile registers */
	if ((ahc->features & AHC_TWIN) != 0) {
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		ahc_outb(ahc, SCSIID, ahc->our_id);
		ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[1].scsiseq);
		ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[1].sxfrctl0);
		ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[1].sxfrctl1);
		ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[1].simode0);
		ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[1].simode1);
		ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[1].seltimer);
		ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[1].seqctl);
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
	}
	ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[0].scsiseq);
	ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[0].sxfrctl0);
	ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[0].sxfrctl1);
	ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[0].simode0);
	ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[0].simode1);
	ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[0].seltimer);
	ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[0].seqctl);
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);
	else
		ahc_outb(ahc, SCSIID, ahc->our_id);

	if ((ahc->chip & AHC_PCI) != 0) {
		ahc_outb(ahc, DSCOMMAND0, ahc->suspend_state.dscommand0);
		ahc_outb(ahc, DSPCISTATUS, ahc->suspend_state.dspcistatus);
	}

	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;

		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc_outb(ahc, OPTIONMODE, ahc->suspend_state.optionmode);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc_outb(ahc, CRCCONTROL1, ahc->suspend_state.crccontrol1);
	}

	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc_outb(ahc, SCBBADDR, ahc->suspend_state.scbbaddr);

	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, DFF_THRSH, ahc->suspend_state.dff_thrsh);

	ptr = ahc->suspend_state.scratch_ram;
	for (i = 0; i < 64; i++)
		ahc_outb(ahc, SRAM_BASE + i, *ptr++);

	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0; i < 16; i++)
			ahc_outb(ahc, TARG_OFFSET + i, *ptr++);
	}

	ptr = ahc->suspend_state.btt;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		for (i = 0;i < AHC_NUM_TARGETS; i++) {
			int j;

			for (j = 0;j < AHC_NUM_LUNS; j++) {
				u_int tcl;

				tcl = BUILD_TCL(i << 4, j);
				ahc_busy_tcl(ahc, tcl, *ptr);
			}
		}
	}
d5135 1
a5135 1
#if AHC_TARGET_MODE
d5431 1
a5431 1
	found += ahc_search_untagged_queues(ahc, /*ahc_io_ctx_t*/NULL, target,
d5498 1
a5498 1
			    /*|| (ctx != NULL && ctx != scb->io_ctx)*/)
d5879 1
a5879 1
#if AHC_TARGET_MODE
d5911 1
a5911 1
#if AHC_TARGET_MODE
d5930 1
a5930 1
#if AHC_TARGET_MODE
d5982 4
a6198 8
	int max_prog;

	if ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)
		max_prog = 448;
	else if ((ahc->features & AHC_ULTRA2) != 0)
		max_prog = 768;
	else
		max_prog = 512;
d6203 1
a6203 1
	for (i = 0; i < max_prog; i++) {
d6215 1
a6215 1
static void
a6224 1
	int	downloaded;
d6227 1
d6268 13
a6315 1
	ahc_restart(ahc);
d6322 1
d6400 1
d6402 1
d6777 1
d6782 1
a6782 1
	u_long	   s;
d6859 2
a6860 1
		u_long	s;
d6869 1
d6874 18
a6891 1
		ahc_loadseq(ahc);
d7126 10
a7135 2
				ahc_pause(ahc);
				ahc_loadseq(ahc);
@


1.56
log
@Remove unused file. We use aic7xxxvar.h.

ok marco@@ millert@@
@
text
@@


1.55
log
@Minor tweak from gibbs @@ FreeBSD. Shorten one printf, eliminate
another that was inappropriate.

ok tdeval@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.54 2004/02/08 00:38:08 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.54 2004/02/08 00:38:08 krw Exp $
@


1.54
log
@Pull in a few recent changes from FreeBSD, plus a couple of local
tweaks.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.53 2004/01/17 14:40:55 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.53 2004/01/17 14:40:55 krw Exp $
d5489 1
a5489 1
					printf("Inactive SCB in Waiting List\n");
a5594 2
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in untaggedQ\n");
@


1.53
log
@Major stability improvement. Fix a variety of systems and problems
by dealing with various error conditions.

Testing by Marco Peereboom, Olivier Cherrier, Alex Holst, Daniel Lucq,
deraadt@@, beck@@ and others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.52 2003/12/24 22:45:45 krw Exp $	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.52 2003/12/24 22:45:45 krw Exp $
d4935 1
a4935 1
		if (paused)
d4937 6
d5197 9
a5205 4
	int targ = SCB_GET_TARGET(ahc, scb);
	char chan = SCB_GET_CHANNEL(ahc, scb);
	int slun = SCB_GET_LUN(scb);
	int match;
a5212 1
#if 0
a5228 1
#endif
@


1.52
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
 * $Id: aic7xxx.c,v 1.108 2003/11/02 11:07:44 wiz Exp $
d562 1
a562 2
			if (ahc_get_transfer_length(scb) > 0 &&
			    ahc_get_residual(scb) 
d2006 1
a2006 1
		if (1 /*bootverbose*/ ) {
d2076 1
a2076 1
		if (bootverbose) {
@


1.51
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 3
d7 2
a8 1
 * Copyright (c) 1994-2001 Justin T. Gibbs.
d17 8
a24 2
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d27 2
a28 1
 * GNU Public License ("GPL").
d30 6
a35 5
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d38 6
a43 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d45 1
a45 1
 * $Id: aic7xxx.c,v 1.50 2003/09/29 19:28:15 mickey Exp $
d47 4
a50 2
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.80 2001/12/16 17:38:30 gibbs Exp $
 * $OpenBSD: aic7xxx.c,v 1.50 2003/09/29 19:28:15 mickey Exp $
d53 3
a55 1
#ifdef __OpenBSD__
d58 2
a59 7
#include <dev/microcode/aic7xxx/sequencer.h>
#endif
#ifdef __FreeBSD__
#include <dev/aic7xxx/aic7xxx_freebsd.h>
#include <dev/aic7xxx/aic7xxx_inline.h>
#include <dev/aic7xxx/aicasm/aicasm_insformat.h>
#endif
a80 1
static const u_int num_chip_names = NUM_ELEMENTS(ahc_chip_names);
a147 1
#ifdef __OpenBSD__
a148 3
#else
#include "aic7xxx_seq.h"
#endif 
d151 1
a167 3
static void		ahc_scb_devinfo(struct ahc_softc *ahc,
					struct ahc_devinfo *devinfo,
					struct scb *scb);
d185 1
d211 4
a214 11
#ifdef __OpenBSD__
int			ahc_init_scbdata(struct ahc_softc *ahc);
void			ahc_fini_scbdata(struct ahc_softc *ahc);
void			ahc_build_free_scb_list(struct ahc_softc *ahc);
#else
static bus_dmamap_callback_t	ahc_dmamap_cb;
static int		ahc_init_scbdata(struct ahc_softc *ahc);
static void		ahc_fini_scbdata(struct ahc_softc *ahc);
static void		ahc_build_free_scb_list(struct ahc_softc *ahc);
#endif 

a223 3
static int		ahc_abort_scbs(struct ahc_softc *ahc, int target,
				       char channel, int lun, u_int tag,
				       role_t role, uint32_t status);
d245 18
d273 3
d279 3
d341 1
a341 1
			ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
d353 1
a353 1
			       ahc->qoutfifonext - 1);
d361 1
a361 1
		ahc_update_residual(scb);
d384 1
a384 1
	 && (scb->flags & SCB_ACTIVE) == 0) {
d454 1
a454 1
		 * dma'd the SCB back up to us, so we can reference
d460 2
a461 1
			printf("%s:%c:%d: ahc_intr - referenced scb "
d463 1
a463 2
			       ahc_name(ahc), devinfo.channel,
			       devinfo.target, intstat, scb_index);
a478 1
			ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
a480 1
		ahc_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
d487 1
a487 1
			printf("%s: Interrupted for staus of 0???\n",
d499 1
a499 1
			if (ahc_debug & AHC_SHOWSENSE) {
d505 1
a505 1
				
d519 2
a520 2
 			 */
			ahc_update_residual(scb);
d522 1
a522 1
			if (ahc_debug & AHC_SHOWSENSE) {
d530 1
a530 1
			
d538 1
a538 1
			 && SCB_GET_LUN(scb) < 8)
a561 1
#ifdef __OpenBSD__
d563 2
a564 6
			    ahc_get_residual(scb) == 
			    ahc_get_transfer_length(scb)) {
#else 
			if (ahc_get_residual(scb) 
			 == ahc_get_transfer_length(scb)) {
#endif
d567 1
a567 1
						       /*force*/TRUE);
d580 1
a580 1
			bus_dmamap_sync(ahc->scb_data->sense_dmat,
d586 1
a586 1
			bus_dmamap_sync(ahc->scb_data->sg_dmat,
d590 1
a590 1
			bus_dmamap_sync(ahc->scb_data->hscb_dmat,
a598 5
#ifdef __OpenBSD__
			if (!(scb->io_ctx->flags & SCSI_POLL))
				timeout_add(&scb->io_ctx->stimeout, 5 * hz);
#endif 
#ifdef __FreeBSD__
d603 1
a603 5
			untimeout(ahc_timeout, (caddr_t)scb,
				  scb->io_ctx->ccb_h.timeout_ch);
			scb->io_ctx->ccb_h.timeout_ch =
			    timeout(ahc_timeout, (caddr_t)scb, 5 * hz);
#endif
d620 1
a620 1
		printf("SAVED_SCSIID == 0x%02x, SAVED_LUN == 0x%x, "
d657 1
a657 1
	case NO_IDENT: 
d659 2
a660 19
		/*
		 * The reconnecting target either did not send an identify
		 * message, or did, but we didn't find an SCB to match and
		 * before it could respond to our ATN/abort, it hit a dataphase.
		 * The only safe thing to do is to blow it away with a bus
		 * reset.
		 */
		int found;

		printf("%s:%c:%d: Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x, SAVED_SCSIID == 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_SCSIID));
		found = ahc_reset_channel(ahc, devinfo.channel, 
					  /*initiate reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), devinfo.channel,
		       found);
		return;
d729 1
a729 1
					      "invalid SCB %x", scb_index);
d740 3
a742 1
			} else {
a747 1
#if AHC_TARGET_MODE
d752 1
a753 1
			}
d788 38
a825 1
			ahc_inb(ahc, SCSIDATL);
d874 6
a879 1
		ahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);
a994 3
	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);

d996 1
a996 1
	 && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
d1023 3
d1029 1
a1029 1
	 && (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)
d1076 1
d1104 8
a1111 3
		if (scb != NULL)
			ahc_print_path(ahc, scb);
		else
d1115 21
a1135 5
		printf("parity error detected %s. "
		       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
		       ahc_phase_table[i].phasemsg,
		       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),
		       scsirate);
d1137 8
a1144 11
		if ((ahc->features & AHC_DT) != 0) {

			if ((sstat2 & CRCVALERR) != 0)
				printf("\tCRC Value Mismatch\n");
			if ((sstat2 & CRCENDERR) != 0)
				printf("\tNo terminal CRC packet recevied\n");
			if ((sstat2 & CRCREQERR) != 0)
				printf("\tIllegal CRC packet request\n");
			if ((sstat2 & DUAL_EDGE_ERR) != 0)
				printf("\tUnexpected %sDT Data Phase\n",
				       (scsirate & SINGLE_EDGE) ? "" : "non-");
d1160 6
d1169 1
a1169 1
		u_int scbptr;
d1184 1
a1184 1
		 * LED does.  SELINGO is only cleared by a successful
d1200 1
d1202 17
d1273 1
a1273 1
			 || ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT, TRUE)) {
d1275 2
a1276 2
				 == MSG_ABORT_TAG)
					tag = scb->hscb->tag;
a1287 1
				struct ahc_devinfo devinfo;
d1381 7
a1393 1
		ahc_clear_msg_state(ahc);
d1403 21
d1484 12
a1495 1
			ahc_outb(ahc, SIMODE1, 0);
d1500 4
d1505 1
a1505 1
		do {
a1506 1
		} while (!ahc_is_paused(ahc));
d1528 1
a1528 1
	ahc_flush_device_writes(ahc);
d1534 4
d1589 1
a1589 1
	 && ahc->enabled_targets[scsi_id] != master_tstate)
d1592 2
a1593 1
	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
d1607 1
a1607 1
		for (i = 0; i < 16; i++) {
d1656 2
a1657 1
			u_int *period, u_int *ppr_options, role_t role) {
d1690 4
d1870 1
a1870 1
		       struct ahc_initiator_tinfo *tinfo, int force)
d1875 12
d1891 2
a1892 2
	 || (force
	  && (tinfo->goal.period != 0
d2006 2
a2007 2
			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (1 /*bootverbose*/) {
d2023 1
a2023 1
						tinfo, /*force*/FALSE);
d2085 1
a2085 1
						tinfo, /*force*/FALSE);
a2097 2
 	ahc_send_async(ahc, devinfo->channel, devinfo->target,
 		       devinfo->lun, AC_TRANSFER_NEG, &alg);
d2197 2
a2198 1
	 && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
d2248 8
a2255 1
static void
d2264 1
a2264 1
	if ((scb->hscb->control & TARGET_SCB) != 0)
d2286 1
a2286 1
 * outgoing message buffer with the appropriate message and begin handling
d2293 1
a2293 1
	/*              
d2297 1
a2297 1
	 */             
d2378 1
a2378 1
	/*              
d2382 1
a2382 1
	 */             
a2388 1
	int	use_ppr;
d2410 6
a2415 1
	doppr = tinfo->curr.ppr_options != ppr_options;
d2419 1
a2419 2
		dosync = tinfo->goal.period != 0;
		doppr = tinfo->goal.ppr_options != 0;
d2423 13
a2435 2
		panic("ahc_intr: AWAITING_MSG for negotiation, "
		      "but no negotiation needed");	
a2437 1
	use_ppr = (tinfo->curr.transport_version >= 3) || doppr;
d2440 1
a2440 1
		use_ppr = 0;
d2450 1
a2450 1
	if (use_ppr || (dosync && !dowide)) {
d2454 2
a2455 2
				    use_ppr ? tinfo->goal.width
					    : tinfo->curr.width,
d2457 1
a2457 1
		if (use_ppr) {
d2476 2
d2520 2
d2556 96
d2679 6
d2687 7
d2714 4
d2744 5
d2757 6
a2763 1

d2765 7
d2786 5
d2806 7
a2812 1
			if (ahc->msgout_len != 0)
d2814 1
d2818 7
a2824 3
		/* Ack the byte */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_inb(ahc, SCSIDATL);
d3026 1
a3026 1
	 * the entire message is availible and has been
d3035 11
d3099 1
a3099 1
			ahc_set_syncrate(ahc, devinfo,
d3215 1
a3215 1
				if (tinfo->goal.period) {
d3349 1
d3361 3
a3363 1
#ifdef AHC_TARGET_MODE
d3369 3
d3373 2
a3374 5
			       devinfo->lun,
			       ahc->msgin_buf[0] == MSG_ABORT_TAG
						  ? SCB_LIST_NULL
						  : ahc_inb(ahc, INITIATOR_TAG),
			       ROLE_TARGET, CAM_REQ_ABORTED);
d3385 1
a3385 1
						       /*arg*/0);
d3389 2
a3390 1
		done = MSGLOOP_MSGCOMPLETE;
d3392 1
d3480 1
a3480 1
		if (tinfo->goal.period) {
d3750 1
a3750 1
	
d3782 1
a3782 1
		       CAM_LUN_WILDCARD, AC_SENT_BDR, NULL);
a3812 46
/**************************** Initialization **********************************/
/*
 * Allocate a controller structure for a new device
 * and perform initial initialization.
 */
struct ahc_softc *
ahc_alloc(void *platform_arg, char *name)
{
	struct  ahc_softc *ahc;
	int	i;

#ifdef __OpenBSD__	/* OpenBSD provides softc! */
	ahc = (struct ahc_softc *)platform_arg;
#else 
#ifndef	__FreeBSD__
	ahc = malloc(sizeof(*ahc), M_DEVBUF, M_NOWAIT);
	if (!ahc) {
		printf("aic7xxx: cannot malloc softc!\n");
		free(name, M_DEVBUF);
		return NULL;
	}
#else
	ahc = device_get_softc((device_t)platform_arg);
#endif
	memset(ahc, 0, sizeof(*ahc));
#endif 
	LIST_INIT(&ahc->pending_scbs);
	/* We don't know our unit number until the OSM sets it */
	ahc->name = name;
	ahc->unit = -1;
	ahc->description = NULL;
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	ahc->chip = AHC_NONE;
	ahc->features = AHC_FENONE;
	ahc->bugs = AHC_BUGNONE;
	ahc->flags = AHC_FNONE;

	for (i = 0; i < 16; i++)
		TAILQ_INIT(&ahc->untagged_queues[i]);
	if (ahc_platform_alloc(ahc, platform_arg) != 0) {
		ahc_free(ahc);
		ahc = NULL;
	}
	return (ahc);
}
d3892 16
a3921 1
#ifndef __OpenBSD__
d3930 1
a3930 1
	case 5:
d3932 1
a3932 11
		TAILQ_REMOVE(&ahc_tailq, ahc, links);
		/* FALLTHROUGH */
	case 4:
		ahc_dmamap_unload(ahc, ahc->shared_data_dmat,
				  ahc->shared_data_dmamap);
		/* FALLTHROUGH */
	case 3:
		ahc_dmamem_free(ahc, ahc->shared_data_dmat, ahc->qoutfifo,
				ahc->shared_data_dmamap);
		ahc_dmamap_destroy(ahc, ahc->shared_data_dmat,
				   ahc->shared_data_dmamap);
a3933 2
	case 2:
		ahc_dma_tag_destroy(ahc, ahc->shared_data_dmat);
d3935 4
a3938 3
#ifndef __linux__
		ahc_dma_tag_destroy(ahc, ahc->buffer_dmat);
#endif
a3943 3
#ifndef __linux__
	ahc_dma_tag_destroy(ahc, ahc->parent_dmat);
#endif
d3958 1
a3958 1
					xpt_free_path(lstate->path);
d3968 1
a3968 1
		xpt_free_path(ahc->black_hole->path);
d3972 1
d3975 3
a3982 1
#endif /* __OpenBSD__ */
d3998 1
a3998 1
	for (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)
d4019 8
d4045 4
a4048 1
	 * Ensure that the reset has finished
d4079 1
a4079 1
		printf(" Unsupported adapter type.  Ignoring\n");
d4129 1
a4129 1
#ifndef __OpenBSD__
d4138 1
a4138 1
#endif 
a4139 1
#ifndef __OpenBSD__
a4140 3
#else
void
#endif 
d4143 1
d4146 4
d4151 2
d4155 8
d4172 1
a4172 1
		/* Make the tag number invalid */
d4174 2
a4180 4

	/* Ensure we clear the 0 SCB's control byte. */
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outb(ahc, SCB_CONTROL, 0);
a4182 1
#ifndef __OpenBSD__
d4194 1
a4194 1
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,
d4198 1
a4198 1
	memset(scb_data->scbarray, 0, sizeof(struct scb) * AHC_SCB_MAX);
d4227 6
a4232 51
	/* DMA tag for our hardware scb structures */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       AHC_SCB_MAX * sizeof(struct hardware_scb),
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->hscb_dmat) != 0) {
		goto error_exit;
	}

	scb_data->init_level++;

	/* Allocation for our hscbs */
	if (ahc_dmamem_alloc(ahc, scb_data->hscb_dmat,
			     (void **)&scb_data->hscbs,
			     BUS_DMA_NOWAIT, &scb_data->hscb_dmamap) != 0) {
		goto error_exit;
	}

	scb_data->init_level++;

	/* And permanently map them */
	ahc_dmamap_load(ahc, scb_data->hscb_dmat, scb_data->hscb_dmamap,
			scb_data->hscbs,
			AHC_SCB_MAX * sizeof(struct hardware_scb),
			ahc_dmamap_cb, &scb_data->hscb_busaddr, /*flags*/0);

	scb_data->init_level++;

	/* DMA tag for our sense buffers */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->sense_dmat) != 0) {
		goto error_exit;
	}

	scb_data->init_level++;

	/* Allocate them */
	if (ahc_dmamem_alloc(ahc, scb_data->sense_dmat,
			     (void **)&scb_data->sense,
			     BUS_DMA_NOWAIT, &scb_data->sense_dmamap) != 0) {
a4233 9
	}

	scb_data->init_level++;

	/* And permanently map them */
	ahc_dmamap_load(ahc, scb_data->sense_dmat, scb_data->sense_dmamap,
			scb_data->sense,
			AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			ahc_dmamap_cb, &scb_data->sense_busaddr, /*flags*/0);
d4237 5
a4241 9
	/* DMA tag for our S/G structures.  We allocate in page sized chunks */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       PAGE_SIZE, /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->sg_dmat) != 0) {
a4242 1
	}
d4247 2
a4248 1
	memset(scb_data->hscbs, 0, AHC_SCB_MAX * sizeof(struct hardware_scb));
d4250 1
d4266 1
a4266 1
	 * Note that we were successful
d4286 1
a4286 1
	case 7:
d4292 3
a4294 5
			ahc_dmamap_unload(ahc, scb_data->sg_dmat,
					  sg_map->sg_dmamap);
			ahc_dmamem_free(ahc, scb_data->sg_dmat,
					sg_map->sg_vaddr,
					sg_map->sg_dmamap);
a4296 1
		ahc_dma_tag_destroy(ahc, scb_data->sg_dmat);
d4298 1
a4298 8
	case 6:
		ahc_dmamap_unload(ahc, scb_data->sense_dmat,
				  scb_data->sense_dmamap);
	case 5:
		ahc_dmamem_free(ahc, scb_data->sense_dmat, scb_data->sense,
				scb_data->sense_dmamap);
		ahc_dmamap_destroy(ahc, scb_data->sense_dmat,
				   scb_data->sense_dmamap);
d4300 5
a4304 1
		ahc_dma_tag_destroy(ahc, scb_data->sense_dmat);
d4306 5
a4310 2
		ahc_dmamap_unload(ahc, scb_data->hscb_dmat,
				  scb_data->hscb_dmamap);
a4311 4
		ahc_dmamem_free(ahc, scb_data->hscb_dmat, scb_data->hscbs,
				scb_data->hscb_dmamap);
		ahc_dmamap_destroy(ahc, scb_data->hscb_dmat,
				   scb_data->hscb_dmamap);
a4312 2
		ahc_dma_tag_destroy(ahc, scb_data->hscb_dmat);
		break;
d4332 1
a4332 1
	if (scb_data->numscbs >= AHC_SCB_MAX)
d4344 5
a4348 3
	if (ahc_dmamem_alloc(ahc, scb_data->sg_dmat,
			     (void **)&sg_map->sg_vaddr,
			     BUS_DMA_NOWAIT, &sg_map->sg_dmamap) != 0) {
a4354 4
	ahc_dmamap_load(ahc, scb_data->sg_dmat, sg_map->sg_dmamap,
			sg_map->sg_vaddr, PAGE_SIZE, ahc_dmamap_cb,
			&sg_map->sg_physaddr, /*flags*/0);

d4359 3
a4361 3
	for (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {
		struct scb_platform_data *pdata;
#ifndef __linux__
d4363 9
a4371 5
#endif
		pdata = (struct scb_platform_data *)malloc(sizeof(*pdata),
							   M_DEVBUF, M_NOWAIT);
		if (pdata == NULL)
			break;
d4382 5
a4386 3
#ifndef __linux__
		error = ahc_dmamap_create(ahc, ahc->buffer_dmat, /*flags*/0,
					  &next_scb->dmamap);
d4389 1
a4389 1
#endif
a4399 1
#endif /* __OpenBSD__ */
d4462 3
a4464 3
#define AHC_DEBUG_SEQUENCER
#ifdef AHC_DEBUG_SEQUENCER
	ahc->flags |= AHC_SEQUENCER_DEBUG;
d4484 6
d4492 1
d4507 1
a4507 1
	if ((AHC_TMODE_ENABLE & (0x1 << ahc->unit)) == 0)
a4509 17
#if !defined(__linux__) && !defined(__OpenBSD__)
	/* DMA tag for mapping buffers into device visible space. */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       /*maxsize*/MAXBSIZE, /*nsegments*/AHC_NSEG,
			       /*maxsegsz*/AHC_MAXTRANSFER_SIZE,
			       /*flags*/BUS_DMA_ALLOCNOW,
			       &ahc->buffer_dmat) != 0) {
		return (ENOMEM);
	}
#endif

	ahc->init_level++;

d4513 1
a4513 1
	 * roles, we need to allocate space for the the qinfifo and qoutfifo.
d4517 1
a4517 1
	 * byte to deal with a dma bug in some chip versions.
a4519 10
#ifdef __OpenBSD__
	if (ahc_createdmamem(ahc, ahc->shared_data_dmat, driver_data_size, 
	    &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,
	    &ahc->shared_data_busaddr, &ahc->shared_data_seg,
	    &ahc->shared_data_nseg, "shared data") < 0)
		return (ENOMEM);

	ahc->init_level++;
#else

a4522 13
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       driver_data_size,
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &ahc->shared_data_dmat) != 0) {
		return (ENOMEM);
	}

	ahc->init_level++;
d4524 5
a4528 4
	/* Allocation of driver data */
	if (ahc_dmamem_alloc(ahc, ahc->shared_data_dmat,
			     (void **)&ahc->qoutfifo,
			     BUS_DMA_NOWAIT, &ahc->shared_data_dmamap) != 0) {
a4529 1
	}
a4532 4
	/* And permanently map it in */
	ahc_dmamap_load(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
			ahc->qoutfifo, driver_data_size, ahc_dmamap_cb,
			&ahc->shared_data_busaddr, /*flags*/0);
a4546 1
#endif 
d4554 5
a4558 1
			return (ENOMEM);
d4582 1
a4582 1
	if (ahc->scb_data->maxhscbs < AHC_SCB_MAX) {
d4589 3
a4591 3
	if (ahc_debug & AHC_SHOWMISC) {
		printf("%s: hardware scb %d bytes; kernel scb %d bytes; "
		       "ahc_dma %d bytes\n",
d4593 3
a4595 3
		        sizeof(struct hardware_scb),
			sizeof(struct scb),
			sizeof(struct ahc_dma_seg));
d4624 1
a4624 1
	
d4651 1
a4651 1
	if (ahc->flags & AHC_USEDEFAULTS) {
d4768 2
a4769 1
		tstate->ultraenb = ultraenb;
d4792 1
a4792 1
	
d4804 1
a4804 1
	
d4850 1
d4873 1
a4873 1
         */
d4929 1
d4934 1
d4936 2
d4940 2
d4945 3
a4947 2
		maxloops--;
	} while (((intstat = ahc_inb(ahc, INTSTAT)) & INT_PEND) && --maxloops);
d4950 1
a4950 1
		      ahc_inb(ahc, INTSTAT));
d4976 1
a4976 1
	
d5203 1
d5220 1
d5278 1
a5278 1
	ahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
d5289 2
a5290 2
	u_int8_t qinpos;
	u_int8_t diff;
d5311 2
a5312 1
	uint8_t next, prev;
a5314 2
	int	maxtarget;
	int	i;
a5316 2
	ahc_sync_qinfifo(ahc, BUS_DMASYNC_POSTWRITE);

a5324 1
	next = ahc_inb(ahc, NEXT_QUEUED_SCB);
d5327 1
a5327 1
	
d5364 1
a5364 2
					ahc_set_transaction_status(scb,
								   status);
d5371 1
d5398 1
a5398 1
		 * The sequencer may be in the process of dmaing
d5403 1
a5403 1
		 * SCB to dma). If we have removed any entries, swap
d5406 1
a5406 1
		 * has changed during its dma attempt and will retry
d5476 1
a5476 2
					ahc_set_transaction_status(scb,
								   status);
d5501 27
a5527 3
	/*
	 * And lastly, the untagged holding queues.
	 */
d5566 14
a5579 11
			if (ahc_match_scb(ahc, scb, target, channel,
					  lun, SCB_LIST_NULL, role)) {
				/*
				 * We found an scb that needs to be acted on.
				 */
				found++;
				switch (action) {
				case SEARCH_COMPLETE:
				{
					cam_status ostat;
					cam_status cstat;
d5581 17
a5597 19
					ostat = ahc_get_transaction_status(scb);
					if (ostat == CAM_REQ_INPROG)
						ahc_set_transaction_status(scb,
								   status);
					cstat = ahc_get_transaction_status(scb);
					if (cstat != CAM_REQ_CMP)
						ahc_freeze_scb(scb);
					if ((scb->flags & SCB_ACTIVE) == 0)
						printf("Inactive SCB in untaggedQ\n");
					ahc_done(ahc, scb);
					break;
				}
				case SEARCH_REMOVE:
					TAILQ_REMOVE(untagged_q, scb,
						     links.tqe);
					break;
				case SEARCH_COUNT:
					break;
				}
d5825 26
a5850 3
	for (;i < maxtarget; i++) {
		for (j = minlun;j < maxlun; j++)
			ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, j));
a5853 10
	 * Go through the disconnected list and remove any entries we
	 * have queued for completion, 0'ing their control byte too.
	 * We save the active SCB and restore it ourselves, so there
	 * is no reason for this search to restore it too.
	 */
	ahc_search_disc_list(ahc, target, channel, lun, tag,
			     /*stop_on_first*/FALSE, /*remove*/TRUE,
			     /*save_state*/FALSE);

	/*
d5855 4
a5858 1
	 * were active but not on any list.
d5866 3
a5868 2
		if (scbp != NULL
		 && ahc_match_scb(ahc, scbp, target, channel, lun, tag, role))
d5952 10
a5982 4
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
d5990 1
a5990 1
			ahc_outb(ahc, SIMODE1, simode1 | ENSCSIRST);
d5992 4
a6000 1
		ahc_clear_msg_state(ahc);
a6001 4
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
d6009 1
a6009 1
			ahc_outb(ahc, SIMODE1, simode1 | ENSCSIRST);
d6011 4
d6028 1
a6028 1
	
a6053 4
	/* Notify the XPT that a bus reset occurred */
	ahc_send_async(ahc, devinfo.channel, CAM_TARGET_WILDCARD,
		       CAM_LUN_WILDCARD, AC_BUS_RESET, NULL);

d6089 1
a6089 1
ahc_calc_residual(struct scb *scb)
d6133 1
a6133 1
		panic("Bogus resid sgptr value 0x%x", resid_sgptr);
d6139 1
a6139 1
		 * stopped.
d6163 4
a6166 3
	if (ahc_debug & AHC_SHOWMISC) {
		ahc_print_path(scb->ahc_softc, scb);
		printf("Handled Residual of %d bytes\n", resid);
d6381 1
a6381 1
	if (bootverbose)
d6383 3
a6462 1

a6463 1

d6547 58
d6608 7
a6614 5
	struct scb *scb;
	struct scb_tailq *untagged_q;
	int target;
	int maxtarget;
	int i;
d6622 7
a6629 1

d6631 2
a6632 1
	printf("%s: Dumping Card State %s, at SEQADDR 0x%x\n",
d6635 2
d6640 3
a6642 9
	printf("HCNT = 0x%x\n", ahc_inb(ahc, HCNT));
	printf("SCSISEQ = 0x%x, SBLKCTL = 0x%x\n",
	       ahc_inb(ahc, SCSISEQ), ahc_inb(ahc, SBLKCTL));
	printf(" DFCNTRL = 0x%x, DFSTATUS = 0x%x\n",
	       ahc_inb(ahc, DFCNTRL), ahc_inb(ahc, DFSTATUS));
	printf("LASTPHASE = 0x%x, SCSISIGI = 0x%x, SXFRCTL0 = 0x%x\n",
	       last_phase, ahc_inb(ahc, SCSISIGI), ahc_inb(ahc, SXFRCTL0));
	printf("SSTAT0 = 0x%x, SSTAT1 = 0x%x\n",
	       ahc_inb(ahc, SSTAT0), ahc_inb(ahc, SSTAT1));
d6644 25
a6668 7
		printf("SCSIPHASE = 0x%x\n", ahc_inb(ahc, SCSIPHASE));
	printf("STACK == 0x%x, 0x%x, 0x%x, 0x%x\n",
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8));
	printf("SCB count = %d\n", ahc->scb_data->numscbs);
d6725 12
d6742 4
a6745 3
		if (scb != LIST_FIRST(&ahc->pending_scbs))
			printf(", ");
		printf("%d", scb->hscb->tag);
d6748 5
a6752 2
			printf("(0x%x, 0x%x)", ahc_inb(ahc, SCB_CONTROL),
			       ahc_inb(ahc, SCB_TAG));
d6782 1
d6784 2
d6841 1
d6853 4
a6856 2
	if ((ahc->features & AHC_MULTIROLE) != 0) {
		u_int	   our_id;
d6858 21
a6878 4
		if (cam_sim_bus(sim) == 0)
			our_id = ahc->our_id;
		else
			our_id = ahc->our_id_b;
a6879 1
		if (ccb->ccb_h.target_id != our_id) {
d6901 4
d6910 1
a6910 1
 		return;
d6965 1
a6965 1
		/*	
d7186 1
a7186 1
	 * Since we will rely on the the TARGID mask
d7238 1
a7238 1
		ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
d7302 2
d7381 1
d7383 71
a7453 1
#endif
@


1.50
log
@more dmamp_sync()s; krw@@ ok
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.48 2003/08/12 20:27:03 mickey Exp $
d34 1
a34 1
 * $OpenBSD: aic7xxx.c,v 1.48 2003/08/12 20:27:03 mickey Exp $
d112 1
a112 1
 * Provides a mapping of tranfer periods in ns to the proper value to
d390 1
a390 1
	/* Tell everyone that this HBA is no longer availible */
d530 1
a530 1
			 * transaction indestinguishable from outstanding
d710 1
a710 1
		 * transfered so we can track bus phase changes.
d1739 1
a1739 1
 * negotiate with at the next convenient oportunity.  This currently
d2144 1
a2144 1
 * outgoing message buffer with the appropriate message and beging handing
d2335 1
a2335 1
 * Build a wide negotiateion message in our message
d2588 1
a2588 1
		 * so that we don't inadvertantly cause a REQ for the
d2719 1
a2719 1
	 * Parse as much of the message as is availible,
d3229 1
a3229 1
		 * currently in our posession so they can be
d3495 1
a3495 1
 * and perform initial initializion.
d3725 1
a3725 1
 * that is only availabel just after a reset.
d4683 1
a4683 1
		 * a cable attached, the tranceivers may
@


1.49
log
@fix after mickey breakage; reported by grange@@.
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.47 2003/04/27 11:22:52 ho Exp $
d34 1
a34 1
 * $OpenBSD: aic7xxx.c,v 1.47 2003/04/27 11:22:52 ho Exp $
d565 16
d4596 2
d5065 5
a5069 1
	ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;
d5105 2
@


1.48
log
@constify sequencer script; krw@@ ok
@
text
@a564 16
#ifdef __OpenBSD__
			bus_dmamap_sync(ahc->scb_data->sense_dmat,
			    ahc->scb_data->sense_dmamap,
			    (scb - ahc->scb_data->scbarray) *
			    sizeof(struct scsi_sense_data),
			    sizeof(struct scsi_sense_data),
			    BUS_DMASYNC_PREREAD);
			bus_dmamap_sync(ahc->scb_data->sg_dmat,
			    scb->sg_map->sg_dmamap,
			    0, scb->sg_map->sg_dmamap->dm_mapsize,
			    BUS_DMASYNC_PREWRITE);
			bus_dmamap_sync(ahc->scb_data->hscb_dmat,
			    ahc->scb_data->hscb_dmamap,
			    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
#endif
a4579 2
	ahc_sync_qinfifo(ahc, BUS_DMASYNC_PREWRITE);

d5047 1
a5047 5
	ahc->qinfifo[ahc->qinfifonext] = scb->hscb->tag;
	ahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
			/*offset*/ahc->qinfifonext+256, /*len*/1,
			BUS_DMASYNC_PREWRITE);
	ahc->qinfifonext++;
a5082 2

	ahc_sync_qinfifo(ahc, BUS_DMASYNC_POSTWRITE);
@


1.47
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.46 2003/03/30 21:04:18 krw Exp $
d34 1
a34 1
 * $OpenBSD: aic7xxx.c,v 1.46 2003/03/30 21:04:18 krw Exp $
d233 1
a233 1
					struct patch **start_patch,
d565 16
d4596 2
d5065 5
a5069 1
	ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;
d5106 2
d6042 1
a6042 1
	struct	patch *cur_patch;
d6131 1
a6131 1
ahc_check_patch(struct ahc_softc *ahc, struct patch **start_patch,
d6134 2
a6135 2
	struct	patch *cur_patch;
	struct	patch *last_patch;
d6194 1
a6194 1
		struct patch *cur_patch;
@


1.46
log
@Fix probing of dual channel 7899 with some fixes from current FreeBSD
code, plus an extra ahc_flush_device_writes().

ok deraadt@@ tdeval@@
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.45 2003/03/21 14:58:06 drahn Exp $
d34 1
a34 1
 * $OpenBSD: aic7xxx.c,v 1.45 2003/03/21 14:58:06 drahn Exp $
d4151 1
a4151 1
ahc_controller_info(struct ahc_softc *ahc, char *buf)
d4153 1
a4153 1
	int len;
d4155 3
a4157 2
	len = sprintf(buf, "%s: ", ahc_chip_names[ahc->chip & AHC_CHIPID_MASK]);
	buf += len;
d4159 4
a4162 4
 		len = sprintf(buf, "Twin Channel, A SCSI Id=%d, "
			      "B SCSI Id=%d, primary %c, ",
			      ahc->our_id, ahc->our_id_b,
			      (ahc->flags & AHC_PRIMARY_CHANNEL) + 'A');
d4180 3
a4182 2
		len = sprintf(buf, "%s%s Channel %c, SCSI Id=%d, ",
			      speed, type, ahc->channel, ahc->our_id);
d4184 1
a4184 1
	buf += len;
d4187 2
a4188 2
		sprintf(buf, "%d/%d SCBs",
			ahc->scb_data->maxhscbs, AHC_SCB_MAX);
d4190 2
a4191 1
		sprintf(buf, "%d SCBs", ahc->scb_data->maxhscbs);
@


1.45
log
@Endian fixes for ahc driver. These are a no-op for i386.  Now works on macppc.
ok millert@@ miod@@ krw@@
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.44 2003/01/05 22:41:35 deraadt Exp $
d34 1
a34 1
 * $OpenBSD: aic7xxx.c,v 1.44 2003/01/05 22:41:35 deraadt Exp $
d1392 1
d1396 1
d1398 1
d1400 1
d5634 1
@


1.44
log
@spelling
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.43 2002/12/09 00:45:37 millert Exp $
d34 1
a34 1
 * $OpenBSD: aic7xxx.c,v 1.43 2002/12/09 00:45:37 millert Exp $
d561 2
a562 2
			hscb->dataptr = ahc_htole32(sg->addr); 
			hscb->datacnt = ahc_htole32(sg->len);
@


1.43
log
@From Andrushock, s/sucess/success/g
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.42 2002/10/09 23:43:10 krw Exp $
d34 1
a34 1
 * $OpenBSD: aic7xxx.c,v 1.42 2002/10/09 23:43:10 krw Exp $
d1112 1
a1112 1
		 * LED does.  SELINGO is only cleared by a successfull
d4005 1
a4005 1
	 * Note that we were successfull
@


1.42
log
@Remove trailing '\n's from panic messages.

Started by a commit to siop from provos@@netbsd.org.

ok miod@@ millert@@
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.41 2002/07/05 05:41:03 smurph Exp $
d34 1
a34 1
 * $OpenBSD: aic7xxx.c,v 1.41 2002/07/05 05:41:03 smurph Exp $
d1112 1
a1112 1
		 * LED does.  SELINGO is only cleared by a sucessfull
@


1.41
log
@attempt to make ahc smaller.  change PCI interrupt handler.
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.40 2002/06/28 00:34:54 smurph Exp $
d34 1
a34 1
 * $OpenBSD: aic7xxx.c,v 1.40 2002/06/28 00:34:54 smurph Exp $
d725 1
a725 1
					      "invalid SCB %x\n", scb_index);
d2259 1
a2259 1
		      "but no negotiation needed\n");	
d5109 1
a5109 1
			panic("Loop 1\n");
d5175 1
a5175 1
			panic("First/Second Qinfifo fixup\n");
d5221 1
a5221 1
			panic("Waiting List traversal\n");
d5847 1
a5847 1
		panic("Bogus resid sgptr value 0x%x\n", resid_sgptr);
d6212 1
a6212 1
				panic("%s: BMOV not supported\n",
d6772 1
a6772 1
		panic("ahc_update_scsiid called on non-multitid unit\n");
@


1.40
log
@Return of new ahc
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.39 2002/02/16 04:36:33 smurph Exp $
d34 1
a34 1
 * $OpenBSD: src/sys/dev/ic/aic7xxx.c,v 1.39 2002/12/16 17:38:30 smurph Exp $
d599 1
a599 1
		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
@


1.39
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d2 1
a2 5
 * Generic driver for the aic7xxx based adaptec SCSI controllers
 * Product specific probe and attach routines can be found in:
 * i386/eisa/ahc_eisa.c	27/284X and aic7770 motherboard controllers
 * pci/ahc_pci.c	3985, 3980, 3940, 2940, aic7895, aic7890,
 *			aic7880, aic7870, aic7860, and aic7850 controllers
d4 1
a4 1
 * Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999, 2000 Justin T. Gibbs.
d17 1
a17 1
 * the GNU Public License ("GPL").
d31 1
a31 50
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.40 2000/01/07 23:08:17 gibbs Exp $
 * $OpenBSD: aic7xxx.c,v 1.38 2002/03/26 00:56:10 krw Exp $
 */
/*
 * A few notes on features of the driver.
 *
 * SCB paging takes advantage of the fact that devices stay disconnected
 * from the bus a relatively long time and that while they're disconnected,
 * having the SCBs for these transactions down on the host adapter is of
 * little use.  Instead of leaving this idle SCB down on the card we copy
 * it back up into kernel memory and reuse the SCB slot on the card to
 * schedule another transaction.  This can be a real payoff when doing random
 * I/O to tagged queueing devices since there are more transactions active at
 * once for the device to sort for optimal seek reduction. The algorithm goes
 * like this...
 *
 * The sequencer maintains two lists of its hardware SCBs.  The first is the
 * singly linked free list which tracks all SCBs that are not currently in
 * use.  The second is the doubly linked disconnected list which holds the
 * SCBs of transactions that are in the disconnected state sorted most
 * recently disconnected first.  When the kernel queues a transaction to
 * the card, a hardware SCB to "house" this transaction is retrieved from
 * either of these two lists.  If the SCB came from the disconnected list,
 * a check is made to see if any data transfer or SCB linking (more on linking
 * in a bit) information has been changed since it was copied from the host
 * and if so, DMAs the SCB back up before it can be used.  Once a hardware
 * SCB has been obtained, the SCB is DMAed from the host.  Before any work
 * can begin on this SCB, the sequencer must ensure that either the SCB is
 * for a tagged transaction or the target is not already working on another
 * non-tagged transaction.  If a conflict arises in the non-tagged case, the
 * sequencer finds the SCB for the active transactions and sets the SCB_LINKED
 * field in that SCB to this next SCB to execute.  To facilitate finding
 * active non-tagged SCBs, the last four bytes of up to the first four hardware
 * SCBs serve as a storage area for the currently active SCB ID for each
 * target.
 *
 * When a device reconnects, a search is made of the hardware SCBs to find
 * the SCB for this transaction.  If the search fails, a hardware SCB is
 * pulled from either the free or disconnected SCB list and the proper
 * SCB is DMAed from the host.  If the MK_MESSAGE control bit is set
 * in the control byte of the SCB while it was disconnected, the sequencer
 * will assert ATN and attempt to issue a message to the host.
 *
 * When a command completes, a check for non-zero status and residuals is
 * made.  If either of these conditions exists, the SCB is DMAed back up to
 * the host so that it can interpret this information.  Additionally, in the
 * case of bad status, the sequencer generates a special interrupt and pauses
 * itself.  This allows the host to setup a request sense command if it 
 * chooses for this target synchronously with the error so that sense
 * information isn't lost.
d33 2
d37 3
a39 20
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/proc.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_message.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>

#include <uvm/uvm_extern.h>

#include <dev/ic/aic7xxxreg.h>
#include <dev/ic/aic7xxxvar.h>
#include <dev/microcode/aic7xxx/aic7xxx_seq.h>
a40 12
#include "pci.h"

/*
 * Some ISA devices (e.g. on a VLB) can perform 32-bit DMA.  This
 * flag is passed to bus_dmamap_create() to indicate that fact.
 */
#ifndef ISABUS_DMA_32BIT
#define ISABUS_DMA_32BIT	BUS_DMA_BUS1
#endif 

#ifndef AHC_TMODE_ENABLE
#define AHC_TMODE_ENABLE 0
d42 4
a45 4
#include <sys/kernel.h>

#ifndef le32toh
#define le32toh	letoh32  /* to match Free/Net macros */
d47 2
d50 17
a66 67
#define	IS_SCSIBUS_B(ahc, sc_link)	\
	((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
#define ALL_CHANNELS '\0'
#define ALL_TARGETS_MASK 0xFFFF
#define INITIATOR_WILDCARD	(~0)

#define	SIM_IS_SCSIBUS_B(ahc, sc_link)	\
	((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
#define	SIM_CHANNEL(ahc, sc_link)	\
	(SIM_IS_SCSIBUS_B(ahc, sc_link) ? 'B' : 'A')
#define	SIM_SCSI_ID(ahc, sc_link)	\
	(SIM_IS_SCSIBUS_B(ahc, sc_link) ? ahc->our_id_b : ahc->our_id)
#define	SCB_IS_SCSIBUS_B(scb)	\
	(((scb)->hscb->tcl & SELBUSB) != 0)
#define	SCB_TARGET(scb)	\
	(((scb)->hscb->tcl & TID) >> 4)
#define	SCB_CHANNEL(scb) \
	(SCB_IS_SCSIBUS_B(scb) ? 'B' : 'A')
#define	SCB_LUN(scb)	\
	((scb)->hscb->tcl & LID)
#define SCB_TARGET_OFFSET(scb)		\
	(SCB_TARGET(scb) + (SCB_IS_SCSIBUS_B(scb) ? 8 : 0))
#define SCB_TARGET_MASK(scb)		\
	(0x01 << (SCB_TARGET_OFFSET(scb)))
#define TCL_CHANNEL(ahc, tcl)		\
	((((ahc)->features & AHC_TWIN) && ((tcl) & SELBUSB)) ? 'B' : 'A')
#define TCL_SCSI_ID(ahc, tcl)		\
	(TCL_CHANNEL((ahc), (tcl)) == 'B' ? (ahc)->our_id_b : (ahc)->our_id)
#define TCL_TARGET(tcl) (((tcl) & TID) >> TCL_TARGET_SHIFT)
#define TCL_LUN(tcl) ((tcl) & LID)

#define XS_TCL(ahc, xs) \
	((((xs)->sc_link->target << 4) & 0xF0) \
	| (SIM_IS_SCSIBUS_B((ahc), (xs)->sc_link) ? SELBUSB : 0) \
	| ((xs)->sc_link->lun & 0x07))

/*
 * Under normal circumstances, these messages are unnecessary
 * and not terribly cosmetic.
 */
#ifdef DEBUG
#define bootverbose	1
#define STATIC
#define INLINE
#else
#define bootverbose	0
#define STATIC	static
#define INLINE __inline
#endif

typedef enum {
	ROLE_UNKNOWN,
	ROLE_INITIATOR,
	ROLE_TARGET
} role_t;

struct ahc_devinfo {
	int	  our_scsiid;
	int	  target_offset;
	u_int16_t target_mask;
	u_int8_t  target;
	u_int8_t  lun;
	char	  channel;
	role_t	  role;		/*
				 * Only guaranteed to be correct if not
				 * in the busfree state.
				 */
d68 1
d70 6
a75 170
typedef enum {
	SEARCH_COMPLETE,
	SEARCH_COUNT,
	SEARCH_REMOVE
} ahc_search_action;

#ifdef AHC_DEBUG
static int     ahc_debug = AHC_DEBUG;
#endif

#if NPCI > 0
void ahc_pci_intr(struct ahc_softc *ahc);
#endif

STATIC int	ahcinitscbdata(struct ahc_softc *ahc);
STATIC void	ahcfiniscbdata(struct ahc_softc *ahc);

STATIC int	ahc_poll(struct ahc_softc *ahc, int wait);
STATIC void	ahc_shutdown(void *arg);
STATIC int	ahc_execute_scb(void *arg, bus_dma_segment_t *dm_segs,
		    int nsegments);
STATIC int	ahc_setup_data(struct ahc_softc *ahc, struct scsi_xfer *xs,
		    struct scb *scb);
STATIC void	ahc_freeze_devq(struct ahc_softc *ahc,
		    struct scsi_link *sc_link);
STATIC void	ahcallocscbs(struct ahc_softc *ahc);
STATIC void	ahc_fetch_devinfo(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_compile_devinfo(struct ahc_devinfo *devinfo, u_int our_id,
		    u_int target, u_int lun, char channel, role_t role);
STATIC u_int	ahc_abort_wscb(struct ahc_softc *ahc, u_int scbpos, u_int prev);
STATIC void	ahc_done(struct ahc_softc *ahc, struct scb *scbp);
STATIC struct tmode_tstate *
		ahc_alloc_tstate(struct ahc_softc *ahc, u_int scsi_id,
		    char channel);
STATIC void	ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat);
STATIC void	ahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat);
STATIC void	ahc_build_transfer_msg(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_setup_initiator_msgout(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, struct scb *scb);
STATIC void	ahc_setup_target_msgin(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC int	ahc_handle_msg_reject(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_clear_msg_state(struct ahc_softc *ahc);
STATIC void	ahc_handle_message_phase(struct ahc_softc *ahc,
		    struct scsi_link *sc_link);
STATIC int	ahc_sent_msg(struct ahc_softc *ahc, u_int msgtype, int full);

typedef enum {
	MSGLOOP_IN_PROG,
	MSGLOOP_MSGCOMPLETE,
	MSGLOOP_TERMINATED
} msg_loop_stat;

STATIC int	ahc_parse_msg(struct ahc_softc *ahc, struct scsi_link *sc_link,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_handle_ign_wide_residue(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_handle_devreset(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, int status, char *message,
		    int verbose_level);
#ifdef AHC_DUMP_SEQ
STATIC void	ahc_dumpseq(struct ahc_softc *ahc);
#endif
STATIC void	ahc_loadseq(struct ahc_softc *ahc);
STATIC int	ahc_check_patch(struct ahc_softc *ahc,
		    struct patch **start_patch, int start_instr,
		    int *skip_addr);
STATIC void	ahc_download_instr(struct ahc_softc *ahc, int instrptr,
		    u_int8_t *dconsts);
STATIC int	ahc_match_scb(struct scb *scb, int target, char channel,
		    int lun, u_int tag, role_t role);
#ifdef AHC_DEBUG
STATIC void	ahc_print_scb(struct scb *scb);
#endif
STATIC int	ahc_search_qinfifo(struct ahc_softc *ahc, int target,
		    char channel, int lun, u_int tag, role_t role,
		    u_int32_t status, ahc_search_action action);
STATIC int	ahc_reset_channel(struct ahc_softc *ahc, char channel,
		    int initiate_reset);
STATIC int	ahc_abort_scbs(struct ahc_softc *ahc, int target, char channel,
		    int lun, u_int tag, role_t role, u_int32_t status);
STATIC int	ahc_search_disc_list(struct ahc_softc *ahc, int target,
		    char channel, int lun, u_int tag, int stop_on_first,
		    int remove, int save_state);
STATIC u_int	ahc_rem_scb_from_disc_list(struct ahc_softc *ahc, u_int prev,
		    u_int scbptr);
STATIC void	ahc_add_curscb_to_free_list(struct ahc_softc *ahc);
STATIC void	ahc_clear_intstat(struct ahc_softc *ahc);
STATIC void	ahc_reset_current_bus(struct ahc_softc *ahc);
STATIC struct ahc_syncrate *
		ahc_devlimited_syncrate(struct ahc_softc *ahc, u_int *period);
STATIC struct ahc_syncrate *
		ahc_find_syncrate(struct ahc_softc *ahc, u_int *period,
		    u_int maxsync);
STATIC u_int ahc_find_period(struct ahc_softc *ahc, u_int scsirate,
		u_int maxsync);
STATIC void	ahc_validate_offset(struct ahc_softc *ahc,
					 struct ahc_syncrate *syncrate,
					 u_int *offset, int wide); 
STATIC void	ahc_update_target_msg_request(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo,
		    struct ahc_initiator_tinfo *tinfo, int force, int paused);
STATIC void	ahc_set_syncrate(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, struct ahc_syncrate *syncrate,
		    u_int period, u_int offset, u_int type, int paused,
		    int done);
STATIC void	ahc_set_width(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, u_int width, u_int type,
		    int paused, int done);
STATIC void	ahc_set_tags(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo,int enable);
STATIC int      ahc_istagged_device(struct ahc_softc *ahc,
		    struct scsi_xfer *xs, int nocmdcheck);
STATIC void     ahc_check_tags(struct ahc_softc *ahc, struct scsi_xfer *xs);
STATIC void	ahc_construct_sdtr(struct ahc_softc *ahc, u_int period,
		    u_int offset);
STATIC void	ahc_construct_wdtr(struct ahc_softc *ahc, u_int bus_width);

STATIC void	ahc_calc_residual(struct scb *scb);

STATIC void	ahc_update_pending_syncrates(struct ahc_softc *ahc);

STATIC void	ahc_set_recoveryscb(struct ahc_softc *ahc, struct scb *scb);
STATIC void ahc_timeout(void *);

static __inline int  sequencer_paused(struct ahc_softc *ahc);
static __inline void pause_sequencer(struct ahc_softc *ahc);
static __inline void unpause_sequencer(struct ahc_softc *ahc);
STATIC void restart_sequencer(struct ahc_softc *ahc);
static __inline u_int ahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl,
		    int unbusy);
 
static __inline void	ahc_busy_tcl(struct ahc_softc *ahc, struct scb *scb);
static __inline int	ahc_isbusy_tcl(struct ahc_softc *ahc, struct scb *scb);
static __inline void ahc_freeze_ccb(struct scb* scb);
static __inline void ahcsetccbstatus(struct scsi_xfer *xs, int status);
STATIC void ahc_run_qoutfifo(struct ahc_softc *ahc);

static __inline struct ahc_initiator_tinfo *
	ahc_fetch_transinfo(struct ahc_softc *ahc, char channel, u_int our_id,
	    u_int target, struct tmode_tstate **tstate);
STATIC void ahcfreescb(struct ahc_softc *ahc, struct scb *scb);
static __inline struct scb *ahcgetscb(struct ahc_softc *ahc);
int    ahc_createdmamem(struct ahc_softc *ahc, int size, bus_dmamap_t *mapp,
	    caddr_t *vaddr, bus_addr_t *baddr, bus_dma_segment_t *segs,
	    int *nseg, const char *what);
STATIC void ahc_freedmamem(bus_dma_tag_t tag, int size, bus_dmamap_t map,
	    caddr_t vaddr, bus_dma_segment_t *seg, int nseg);
STATIC void ahcminphys(struct buf *bp);

STATIC INLINE	struct scsi_xfer *ahc_first_xs(struct ahc_softc *);
STATIC INLINE	void   ahc_list_insert_before(struct ahc_softc *ahc,
			    struct scsi_xfer *xs, struct scsi_xfer *next_xs);
STATIC INLINE	void   ahc_list_insert_head(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC INLINE	void   ahc_list_insert_tail(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC INLINE	void   ahc_list_remove(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC INLINE	struct scsi_xfer *ahc_list_next(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC int32_t ahc_scsi_cmd(struct scsi_xfer *xs);
static __inline void ahc_swap_hscb(struct hardware_scb *);
static __inline void ahc_swap_sg(struct ahc_dma_seg *);

struct cfdriver ahc_cd = {
	NULL, "ahc", DV_DULL
d78 9
a86 6
static struct scsi_adapter ahc_switch =
{
	ahc_scsi_cmd,
	ahcminphys,
	0,
	0,
d88 1
d90 1
a90 2
/* the below structure is so we have a default dev struct for our link struct */
static struct scsi_device ahc_dev =
d92 10
a101 4
	NULL, /* Use default error handler */
	NULL, /* have a queue, served by this */
	NULL, /* have no async handler */
	NULL, /* Use default 'done' routine */
d104 5
a108 18
static __inline void
ahc_swap_hscb(struct hardware_scb *hscb)
{
	hscb->SG_pointer = htole32(hscb->SG_pointer);
	hscb->data = htole32(hscb->data);
	hscb->datalen = htole32(hscb->datalen);
	/*
	 * No need to swap cmdpointer; it's either 0 or set to
	 * cmdstore_busaddr, which is already swapped.
	 */
}

static __inline void
ahc_swap_sg(struct ahc_dma_seg *sg)
{
	sg->addr = htole32(sg->addr);
	sg->len = htole32(sg->len);
}
a109 4
STATIC void
ahcminphys(bp)
	struct buf *bp;
{
d111 3
a113 5
 * Even though the card can transfer up to 16megs per command
 * we are limited by the number of segments in the dma segment
 * list that we can hold.  The worst case is that all pages are
 * discontinuous physically, hense the "page per segment" limit
 * enforced here.
d115 1
a115 9
	if (bp->b_bcount > ((AHC_NSEG - 1) * PAGE_SIZE)) {
		bp->b_bcount = ((AHC_NSEG - 1) * PAGE_SIZE);
	}
	minphys(bp);
}


static __inline u_int32_t
ahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)
d117 17
a133 3
	return (ahc->scb_data->hscb_busaddr
		+ (sizeof(struct hardware_scb) * index));
}
d135 6
a140 1
#define AHC_BUSRESET_DELAY	25	/* Reset delay in us */
d142 61
a202 6
static __inline int
sequencer_paused(ahc)
	struct ahc_softc *ahc;
{
	return ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);
}
d204 10
a213 21
static __inline void
pause_sequencer(ahc)
	struct ahc_softc *ahc;
{
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/*
	 * Since the sequencer can disable pausing in a critical section, we
	 * must loop until it actually stops.
	 */
	while (sequencer_paused(ahc) == 0)
		;
}

static __inline void
unpause_sequencer(ahc)
	struct ahc_softc *ahc;
{
	if ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)
		ahc_outb(ahc, HCNTRL, ahc->unpause);
}
d215 34
d252 2
a253 35
STATIC void
restart_sequencer(ahc)
	struct ahc_softc *ahc;
{
	u_int i;

	pause_sequencer(ahc);

	/*
	 * Everytime we restart the sequencer, there
	 * is the possiblitity that we have restarted
	 * within a three instruction window where an
	 * SCB has been marked free but has not made it
	 * onto the free list.  Since SCSI events(bus reset,
	 * unexpected bus free) will always freeze the
	 * sequencer, we cannot close this window.  To
	 * avoid losing an SCB, we reconsitute the free
	 * list every time we restart the sequencer.
	 */
	ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		
		ahc_outb(ahc, SCBPTR, i);
		if (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)
			ahc_add_curscb_to_free_list(ahc);
	}
	ahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);
	unpause_sequencer(ahc);
}

static __inline u_int
ahc_index_busy_tcl(ahc, tcl, unbusy)
	struct ahc_softc *ahc;
	u_int tcl;
	int unbusy;
a254 1
	u_int scbid;
d256 1
a256 6
	scbid = ahc->untagged_scbs[tcl];
	if (unbusy) {
		ahc->untagged_scbs[tcl] = SCB_LIST_NULL;
		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
		    UNTAGGEDSCB_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
	}
d258 3
a260 2
	return (scbid);
}
d262 8
a269 25
static __inline void
ahc_busy_tcl(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
	ahc->untagged_scbs[scb->hscb->tcl] = scb->hscb->tag;
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    UNTAGGEDSCB_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
}

static __inline int
ahc_isbusy_tcl(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
	return ahc->untagged_scbs[scb->hscb->tcl] != SCB_LIST_NULL;
}

static __inline void
ahc_freeze_ccb(scb)
	struct scb *scb;
{
	struct scsi_xfer *xs = scb->xs;
	struct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
	int target;
d271 8
a278 4
	target = xs->sc_link->target;
	if (!(scb->flags & SCB_FREEZE_QUEUE)) {
		ahc->devqueue_blocked[target]++;
		scb->flags |= SCB_FREEZE_QUEUE;
a279 18
}

static __inline void
ahcsetccbstatus(xs, status)
	struct scsi_xfer *xs;
	int status;
{
	xs->error = status;
}

static __inline struct ahc_initiator_tinfo *
ahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)
	struct ahc_softc *ahc;
	char channel;
	u_int our_id;
	u_int remote_id;
	struct tmode_tstate **tstate;
{
d281 3
a283 4
	 * Transfer data structures are stored from the perspective
	 * of the target role.  Since the parameters for a connection
	 * in the initiator role to a given target are the same as
	 * when the roles are reversed, we pretend we are the target.
d285 10
a294 4
	if (channel == 'B')
		our_id += 8;
	*tstate = ahc->enabled_targets[our_id];
	return (&(*tstate)->transinfo[remote_id]);
d297 3
a299 3
STATIC void
ahc_run_qoutfifo(ahc)
	struct ahc_softc *ahc;
d304 2
a305 2
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    0, 256, BUS_DMASYNC_POSTREAD);
a306 1
	while (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {
d308 2
a309 1
		ahc->qoutfifo[ahc->qoutfifonext++] = SCB_LIST_NULL;
d311 18
a328 3
		scb = &ahc->scb_data->scbarray[scb_index];
		if (scb_index >= ahc->scb_data->numscbs
		  || (scb->flags & SCB_ACTIVE) == 0) {
d340 1
a340 4
		if (scb->hscb->residual_SG_count != 0)
			ahc_calc_residual(scb);
		else
			scb->xs->resid = 0;
d345 8
d354 3
a356 7
/*
 * An scb (and hence an scb entry on the board) is put onto the
 * free list.
 */
STATIC void
ahcfreescb(ahc, scb)
	struct ahc_softc *ahc;
a357 3
{       
	struct hardware_scb *hscb;
	int opri;
d359 2
a360 6
	hscb = scb->hscb;

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWSCBS)
		printf("%s: free SCB tag %x\n", ahc_name(ahc), hscb->tag);
#endif
d362 4
a365 6
	opri = splbio();

	if ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||
	    (scb->flags & SCB_RECOVERY_SCB) != 0) {
		ahc->flags &= ~AHC_RESOURCE_SHORTAGE;
		ahc->queue_blocked = 0;
a366 10

	/* Clean up for the next user */
	scb->flags = SCB_FREE;
	hscb->control = 0;
	hscb->status = 0;
	timeout_del(&scb->xs->stimeout);

	SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links);

	splx(opri);
d369 3
a371 9
/*
 * Get a free scb, either one already assigned to a hardware slot
 * on the adapter or one that will require an SCB to be paged out before
 * use. If there are none, see if we can allocate a new SCB.  Otherwise
 * either return an error or sleep.
 */
static __inline struct scb *
ahcgetscb(ahc)
	struct ahc_softc *ahc;
d373 6
a378 2
	struct scb *scbp;
	int opri;
d380 14
a393 9
	opri = splbio();
	if ((scbp = SLIST_FIRST(&ahc->scb_data->free_scbs))) {
		SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links);
	} else {
		ahcallocscbs(ahc);
		scbp = SLIST_FIRST(&ahc->scb_data->free_scbs);
		if (scbp != NULL)
			SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links);
	}
d395 2
a396 3
	splx(opri);

	return (scbp);
d399 5
a403 17
int
ahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)
	struct ahc_softc *ahc;
	int size;
	bus_dmamap_t *mapp;
	caddr_t *vaddr;
	bus_addr_t *baddr;
	bus_dma_segment_t *seg;
	int *nseg;
	const char *what;
{
	int error, level = 0;
	int dma_flags = BUS_DMA_NOWAIT;
	bus_dma_tag_t tag = ahc->sc_dmat;
	const char *myname = ahc_name(ahc);
	if ((ahc->chip & AHC_VL) !=0)
		dma_flags |= ISABUS_DMA_32BIT;
d405 1
a405 47
	if ((error = bus_dmamem_alloc(tag, size, NBPG, 0,
			seg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to allocate DMA mem for %s, error = %d\n",
			myname, what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,
			BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: failed to map DMA mem for %s, error = %d\n",
			myname, what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamap_create(tag, size, 1, size, 0,
			dma_flags, mapp)) != 0) {
		printf("%s: failed to create DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }
	level++;

	if ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,
			BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to load DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }

	*baddr = (*mapp)->dm_segs[0].ds_addr;
	return 0;
out:
	switch (level) {
	case 3:
		bus_dmamap_destroy(tag, *mapp);
		/* FALLTHROUGH */
	case 2:
		bus_dmamem_unmap(tag, *vaddr, size);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(tag, seg, *nseg);
		break;
	default:
		break;
	}
d407 12
a418 2
	return error;
}
d420 6
a425 9
STATIC void
ahc_freedmamem(tag, size, map, vaddr, seg, nseg)
	bus_dma_tag_t tag;
	int size;
	bus_dmamap_t map;
	caddr_t vaddr;
	bus_dma_segment_t *seg;
	int nseg;
{
d427 20
a446 5
	bus_dmamap_unload(tag, map);
	bus_dmamap_destroy(tag, map);
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
}
d448 1
a448 6
#ifdef  AHC_DEBUG
STATIC void
ahc_print_scb(scb)
	struct scb *scb;
{
	struct hardware_scb *hscb = scb->hscb;
d450 297
a746 21
	printf("scb:%p tag %x control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n",
		scb,
		hscb->tag,
		hscb->control,
		hscb->tcl,
		hscb->cmdlen,
		(unsigned long)le32toh(hscb->cmdpointer));
	printf("        datlen:%u data:0x%lx segs:0x%x segp:0x%lx\n",
		le32toh(hscb->datalen),
		(unsigned long)(le32toh(hscb->data)),
		hscb->SG_count,
		(unsigned long)(le32toh(hscb->SG_pointer)));
	printf("	sg_addr:%lx sg_len:%lu\n",
		(unsigned long)(le32toh(scb->sg_list[0].addr)),
		(unsigned long)(le32toh(scb->sg_list[0].len)));
	printf("	cdb:%x %x %x %x %x %x %x %x %x %x %x %x\n",
		hscb->cmdstore[0], hscb->cmdstore[1], hscb->cmdstore[2],
		hscb->cmdstore[3], hscb->cmdstore[4], hscb->cmdstore[5],
		hscb->cmdstore[6], hscb->cmdstore[7], hscb->cmdstore[8],
		hscb->cmdstore[9], hscb->cmdstore[10], hscb->cmdstore[11]);
}
d748 69
d818 29
a846 14
static struct {
        u_int8_t errno;
	char *errmesg;
} hard_error[] = {
	{ ILLHADDR,	"Illegal Host Access" },
	{ ILLSADDR,	"Illegal Sequencer Address referrenced" },
	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
	{ SQPARERR,	"Sequencer Parity Error" },
	{ DPARERR,	"Data-path Parity Error" },
	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
	{ PCIERRSTAT,	"PCI Error detected" },
	{ CIOPARERR,	"CIOBUS Parity Error" },
};
static const int num_errors = sizeof(hard_error)/sizeof(hard_error[0]);
d848 11
a858 15
static struct {
        u_int8_t phase;
        u_int8_t mesg_out; /* Message response to parity errors */
	char *phasemsg;
} phase_table[] = {
	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
	{ 0,		MSG_NOOP,		"in unknown phase"	}
};
static const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;
d860 28
a887 27
/*
 * Valid SCSIRATE values.  (p. 3-17)
 * Provides a mapping of tranfer periods in ns to the proper value to
 * stick in the scsiscfr reg to use that transfer rate.
 */
#define AHC_SYNCRATE_DT		0
#define AHC_SYNCRATE_ULTRA2	1
#define AHC_SYNCRATE_ULTRA	3
#define AHC_SYNCRATE_FAST	6
static struct ahc_syncrate ahc_syncrates[] = {
      /* ultra2    fast/ultra  period     rate */
	{ 0x42,      0x000,      9,      "80.0" },
	{ 0x03,      0x000,     10,      "40.0" },
	{ 0x04,      0x000,     11,      "33.0" },
	{ 0x05,      0x100,     12,      "20.0" },
	{ 0x06,      0x110,     15,      "16.0" },
	{ 0x07,      0x120,     18,      "13.4" },
	{ 0x08,      0x000,     25,      "10.0" },
	{ 0x19,      0x010,     31,      "8.0"  },
	{ 0x1a,      0x020,     37,      "6.67" },
	{ 0x1b,      0x030,     43,      "5.7"  },
	{ 0x1c,      0x040,     50,      "5.0"  },
	{ 0x00,      0x050,     56,      "4.4"  },
	{ 0x00,      0x060,     62,      "4.0"  },
	{ 0x00,      0x070,     68,      "3.6"  },
	{ 0x00,      0x000,      0,      NULL   }
};
d889 41
a929 15
/*
 * Allocate a controller structure for a new device and initialize it.
 * ahc_reset should be called before now since we assume that the card
 * is paused.
 */
void
ahc_construct(ahc, iot, ioh, chip, flags, features, channel)
	struct  ahc_softc *ahc;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ahc_chip chip;
	ahc_flag flags;
	ahc_feature features;
	u_char channel;
{
d931 3
a933 1
	 * find unit and check we have that many defined
d935 1
a935 15
	LIST_INIT(&ahc->pending_scbs);
	ahc->sc_iot = iot;
	ahc->sc_ioh = ioh;
	ahc->chip = chip;
	ahc->flags = flags;
	ahc->features = features;
	ahc->channel = channel;
	ahc->scb_data = NULL;
	ahc->pci_intr_func = NULL;

	ahc->unpause = (ahc_inb(ahc, HCNTRL) & IRQMS) | INTEN;
	/* The IRQMS bit is only valid on VL and EISA chips */
	if ((ahc->chip & AHC_PCI) != 0)
		ahc->unpause &= ~IRQMS;
	ahc->pause = ahc->unpause | PAUSE;
d939 1
a939 2
ahc_free(ahc)
	struct ahc_softc *ahc;
d941 234
a1174 12
	ahcfiniscbdata(ahc);
	if (ahc->init_level != 0)
		ahc_freedmamem(ahc->sc_dmat, ahc->shared_data_size,
		    ahc->shared_data_dmamap, ahc->qoutfifo,
		    &ahc->shared_data_seg, ahc->shared_data_nseg);

	if (ahc->scb_data != NULL)
		free(ahc->scb_data, M_DEVBUF);
	if (ahc->pci_data != NULL)
		free(ahc->pci_data, M_DEVBUF);
	return;
}
d1176 3
a1178 10
STATIC int
ahcinitscbdata(ahc)
	struct ahc_softc *ahc;
{
	struct scb_data *scb_data;
	int i;
	
	scb_data = ahc->scb_data;
	SLIST_INIT(&scb_data->free_scbs);
	SLIST_INIT(&scb_data->sg_maps);
d1180 49
a1228 7
	/* Allocate SCB resources */
	scb_data->scbarray =
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,
				 M_DEVBUF, M_NOWAIT);
	if (scb_data->scbarray == NULL)
		return (ENOMEM);
	bzero(scb_data->scbarray, sizeof(struct scb) * AHC_SCB_MAX);
d1230 38
a1267 1
	/* Determine the number of hardware SCBs and initialize them */
d1269 2
a1270 5
	scb_data->maxhscbs = ahc_probe_scbs(ahc);
	/* SCB 0 heads the free list */
	ahc_outb(ahc, FREE_SCBH, 0);
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		ahc_outb(ahc, SCBPTR, i);
d1272 33
a1304 8
		/* Clear the control byte. */
		ahc_outb(ahc, SCB_CONTROL, 0);

		/* Set the next pointer */
		ahc_outb(ahc, SCB_NEXT, i+1);

		/* Make the tag number invalid */
		ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
d1306 1
d1308 8
a1315 3
	/* Make sure that the last SCB terminates the free list */
	ahc_outb(ahc, SCBPTR, i-1);
	ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);
d1317 2
a1318 3
	/* Ensure we clear the 0 SCB's control byte. */
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outb(ahc, SCB_CONTROL, 0);
d1320 25
a1344 1
	scb_data->maxhscbs = i;
d1346 2
a1347 2
	if (ahc->scb_data->maxhscbs == 0)
		panic("%s: No SCB space found", ahc_name(ahc));
d1349 6
a1354 9
	/*
	 * Create our DMA tags.  These tags define the kinds of device
	 * accessable memory allocations and memory mappings we will
	 * need to perform during normal operation.
	 *
	 * Unless we need to further restrict the allocation, we rely
	 * on the restrictions of the parent dmat, hence the common
	 * use of MAXADDR and MAXSIZE.
	 */
d1356 2
a1357 6
	if (ahc_createdmamem(ahc,
	    AHC_SCB_MAX * sizeof(struct hardware_scb), 
	    &scb_data->hscb_dmamap, (caddr_t *)&scb_data->hscbs, 
	    &scb_data->hscb_busaddr, &scb_data->hscb_seg,
	    &scb_data->hscb_nseg, "hardware SCB structures") < 0)
		goto error_exit;
d1359 23
a1381 20
	scb_data->init_level++;

	if (ahc_createdmamem(ahc,
	    AHC_SCB_MAX * sizeof(struct scsi_sense_data),
	    &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,
	    &scb_data->sense_busaddr, &scb_data->sense_seg,
	    &scb_data->sense_nseg, "sense buffers") < 0)
		goto error_exit;

	scb_data->init_level++;

	/* Perform initial CCB allocation */
	bzero(scb_data->hscbs, AHC_SCB_MAX * sizeof(struct hardware_scb));
	ahcallocscbs(ahc);

	if (scb_data->numscbs == 0) {
		printf("%s: ahc_init_scb_data - "
		       "Unable to allocate initial scbs\n",
		       ahc_name(ahc));
		goto error_exit;
d1383 1
d1385 12
a1396 10
	scb_data->init_level++;

	/*
	 * Note that we were successfull
	 */
	return 0; 

error_exit:

	return ENOMEM;
d1399 3
a1401 3
STATIC void
ahcfiniscbdata(ahc)
	struct ahc_softc *ahc;
d1403 1
a1403 1
	struct scb_data *scb_data;
d1405 1
a1405 1
	scb_data = ahc->scb_data;
d1407 22
a1428 12
	switch (scb_data->init_level) {
	default:
	case 3:
	{
		struct sg_map_node *sg_map;

		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
			ahc_freedmamem(ahc->sc_dmat, PAGE_SIZE,
			    sg_map->sg_dmamap, (caddr_t)sg_map->sg_vaddr,
			    &sg_map->sg_dmasegs, sg_map->sg_nseg);
			free(sg_map, M_DEVBUF);
a1430 16
	/*FALLTHROUGH*/
	case 2:
		ahc_freedmamem(ahc->sc_dmat,
		    AHC_SCB_MAX * sizeof(struct scsi_sense_data),
		    scb_data->sense_dmamap, (caddr_t)scb_data->sense,
		    &scb_data->sense_seg, scb_data->sense_nseg);
	/*FALLTHROUGH*/
	case 1:
		ahc_freedmamem(ahc->sc_dmat,
		    AHC_SCB_MAX * sizeof(struct hardware_scb), 
		    scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,
		    &scb_data->hscb_seg, scb_data->hscb_nseg);
	/*FALLTHROUGH*/
	}
	if (scb_data->scbarray != NULL)
		free(scb_data->scbarray, M_DEVBUF);
d1433 7
a1439 5
void
ahc_xxx_reset(devname, iot, ioh)
	char *devname;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d1441 3
a1443 2
	u_char hcntrl;
	int wait;
d1445 12
a1456 5
#ifdef AHC_DUMP_SEQ
	ahc_dumpseq(ahc);
#endif
	/* Retain the IRQ type across the chip reset */
	hcntrl = (bus_space_read_1(iot, ioh, HCNTRL) & IRQMS) | INTEN;
a1457 1
	bus_space_write_1(iot, ioh, HCNTRL, CHIPRST | PAUSE);
d1459 4
a1462 1
	 * Ensure that the reset has finished
d1464 14
a1477 8
	wait = 1000;
	while (--wait && !(bus_space_read_1(iot, ioh, HCNTRL) & CHIPRSTACK))
		DELAY(1000);
	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
				 "Trying to initialize anyway.\n", devname);
	}
	bus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);
d1480 7
a1486 3
int
ahc_reset(ahc)
	struct ahc_softc *ahc;
d1488 2
a1489 8
	u_int	sblkctl;
	int	wait;
	
#ifdef AHC_DUMP_SEQ
	if (ahc->init_level == 0)
		ahc_dumpseq(ahc);
#endif
	ahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);
d1491 2
a1492 1
	 * Ensure that the reset has finished
d1494 4
a1497 4
	wait = 1000;
	do {
		DELAY(1000);
	} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));
d1499 6
a1504 28
	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", ahc_name(ahc));
	}
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/* Determine channel configuration */
	sblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);
	/* No Twin Channel PCI cards */
	if ((ahc->chip & AHC_PCI) != 0)
		sblkctl &= ~SELBUSB;
	switch (sblkctl) {
	case 0:
		/* Single Narrow Channel */
		break;
	case 2:
		/* Wide Channel */
		ahc->features |= AHC_WIDE;
		break;
	case 8:
		/* Twin Channel */
		ahc->features |= AHC_TWIN;
		break;
	default:
		printf(" Unsupported adapter type.  Ignoring\n");
		return(-1);
	}
	return (0);
d1506 1
d1511 2
a1512 1
 * by the capabilities of the bus connectivity of the target.
d1514 5
a1518 5
STATIC struct ahc_syncrate *
ahc_devlimited_syncrate(ahc, period)
	struct ahc_softc *ahc;
	u_int *period;
{
d1524 1
a1524 1
			maxsync = AHC_SYNCRATE_ULTRA2;
d1527 2
d1535 22
a1556 1
	return (ahc_find_syncrate(ahc, period, maxsync));
d1564 3
a1566 5
STATIC struct ahc_syncrate *
ahc_find_syncrate(ahc, period, maxsync)
	struct ahc_softc *ahc;
	u_int *period;
	u_int maxsync;
d1570 19
a1588 4
	syncrate = &ahc_syncrates[maxsync];
	while ((syncrate->rate != NULL)
	    && ((ahc->features & AHC_ULTRA2) == 0
	     || (syncrate->sxfr_u2 != 0))) {
d1604 7
a1612 1
		syncrate++;
d1622 1
d1627 6
a1632 5
STATIC u_int
ahc_find_period(ahc, scsirate, maxsync)
	struct ahc_softc *ahc;
	u_int scsirate;
	u_int maxsync;
d1657 9
a1665 6
STATIC void
ahc_validate_offset(ahc, syncrate, offset, wide)
	struct ahc_softc *ahc;
	struct ahc_syncrate *syncrate;
	u_int *offset;
	int wide;
d1681 6
d1689 27
a1715 9
STATIC void
ahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct ahc_initiator_tinfo *tinfo;
	int force;
	int paused;
{
	u_int targ_msg_req_orig;
d1717 23
a1739 7
	targ_msg_req_orig = ahc->targ_msg_req;
	if (tinfo->current.period != tinfo->goal.period
	    || tinfo->current.width != tinfo->goal.width
	    || tinfo->current.offset != tinfo->goal.offset
	    || (force && (tinfo->goal.period != 0
	    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))
		ahc->targ_msg_req |= devinfo->target_mask;
d1741 1
a1741 22
		ahc->targ_msg_req &= ~devinfo->target_mask;

	if (ahc->targ_msg_req != targ_msg_req_orig) {
		/* Update the message request bit for this target */
		if ((ahc->features & AHC_HS_MAILBOX) != 0) {
			if (paused) {
				ahc_outb(ahc, TARGET_MSG_REQUEST,
					 ahc->targ_msg_req & 0xFF);
				ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
					 (ahc->targ_msg_req >> 8) & 0xFF);
			} else {
				ahc_outb(ahc, HS_MAILBOX,
					 0x01 << HOST_MAILBOX_SHIFT);
			}
		} else {
			if (!paused)
				pause_sequencer(ahc);

			ahc_outb(ahc, TARGET_MSG_REQUEST,
				 ahc->targ_msg_req & 0xFF);
			ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
				 (ahc->targ_msg_req >> 8) & 0xFF);
d1743 1
a1743 4
			if (!paused)
				unpause_sequencer(ahc);
		}
	}
d1746 12
a1757 10
STATIC void
ahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct ahc_syncrate *syncrate;
	u_int period;
	u_int offset;
	u_int type;
	int paused;
	int done;
d1760 1
a1760 1
	struct	tmode_tstate *tstate;
d1763 6
a1768 1
	int	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
d1775 1
a1775 2
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
d1777 16
a1792 2
	old_period = tinfo->current.period;
	old_offset = tinfo->current.offset;
d1795 3
a1797 1
	 && (old_period != period || old_offset != offset)) {
d1800 1
a1803 2
			/* XXX */
			/* Force single edge until DT is fully implemented */
d1805 7
a1811 5
			if (syncrate != NULL)
				scsirate |= syncrate->sxfr_u2|SINGLE_EDGE;

			if (active)
				ahc_outb(ahc, SCSIOFFSET, offset);
d1838 1
a1838 1
		if (active)
d1840 3
d1845 18
a1862 20
		tinfo->current.period = period;
		tinfo->current.offset = offset;

		/* Update the syncrates in any pending scbs */
		ahc_update_pending_syncrates(ahc);
	}

	/*
	 * Print messages if we're verbose and at the end of a negotiation
	 * cycle.
	 */
	if (done) {
		if (offset != 0) {
			printf("%s: target %d synchronous at %sMHz, "
			       "offset = 0x%x\n", ahc_name(ahc),
			       devinfo->target, syncrate->rate, offset);
		} else {
			printf("%s: target %d using "
			       "asynchronous transfers\n",
			       ahc_name(ahc), devinfo->target);
d1866 2
a1867 9
	if ((type & AHC_TRANS_GOAL) != 0) {
		tinfo->goal.period = period;
		tinfo->goal.offset = offset;
	}

	if ((type & AHC_TRANS_USER) != 0) {
		tinfo->user.period = period;
		tinfo->user.offset = offset;
	}
d1869 2
a1870 3
	ahc_update_target_msg_request(ahc, devinfo, tinfo,
				      /*force*/FALSE,
				      paused);
d1873 11
a1883 8
STATIC void
ahc_set_width(ahc, devinfo, width, type, paused, done)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	u_int width;
	u_int type;
	int paused;
	int done;
d1885 13
a1897 4
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
	u_int  oldwidth;
	int    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
d1899 2
a1900 5
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target,
				    &tstate);
	oldwidth = tinfo->current.width;
d1902 1
d1906 1
d1917 157
a2073 1
		tinfo->current.width = width;
d2075 73
d2149 6
a2154 4
	if (done) {
		printf("%s: target %d using %dbit transfers\n",
		       ahc_name(ahc), devinfo->target,
		       8 * (0x01 << width));
d2157 41
a2197 4
	if ((type & AHC_TRANS_GOAL) != 0)
		tinfo->goal.width = width;
	if ((type & AHC_TRANS_USER) != 0)
		tinfo->user.width = width;
d2199 8
a2206 2
	ahc_update_target_msg_request(ahc, devinfo, tinfo,
				      /*force*/FALSE, paused);
d2209 6
a2214 5
STATIC void
ahc_set_tags(ahc, devinfo, enable)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	int enable;
d2216 34
a2249 2
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
d2251 4
a2254 8
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target,
				    &tstate);
	if (enable)
		tstate->tagenable |= devinfo->target_mask;
	else {
		tstate->tagenable &= ~devinfo->target_mask;
a2255 1
}
d2257 4
a2260 11
/*
 * Attach all the sub-devices we can find
 */
int
ahc_attach(ahc)
	struct ahc_softc *ahc;
{
	/*
	 * Initialize the software queue.
	 */
	LIST_INIT(&ahc->sc_xxxq);
d2262 4
a2265 23
#ifdef AHC_BROKEN_CACHE
	if (cpu_class == CPUCLASS_386)	/* doesn't have "wbinvd" instruction */
		ahc_broken_cache = 0;
#endif
	/*
	 * fill in the prototype scsi_links.
	 */
	ahc->sc_link.adapter_target = ahc->our_id;
	if (ahc->features & AHC_WIDE)
		ahc->sc_link.adapter_buswidth = 16;
	ahc->sc_link.adapter_softc = ahc;
	ahc->sc_link.adapter = &ahc_switch;
	ahc->sc_link.openings = 2;
	ahc->sc_link.device = &ahc_dev;
	ahc->sc_link.flags = SCSIDEBUG_LEVEL;
	
	if (ahc->features & AHC_TWIN) {
		/* Configure the second scsi bus */
		ahc->sc_link_b = ahc->sc_link;
		ahc->sc_link_b.adapter_target = ahc->our_id_b;
		if (ahc->features & AHC_WIDE)
			ahc->sc_link.adapter_buswidth = 16;
	}
d2268 6
a2273 1
	 * ask the adapter what subunits are present
d2275 1
a2275 3
	if ((ahc->flags & AHC_CHANNEL_B_PRIMARY) == 0) {
		/* make IS_SCSIBUS_B() == false, while probing channel A */
		ahc->sc_link_b.scsibus = 0xff;
d2277 11
a2287 3
		config_found((void *)ahc, &ahc->sc_link, scsiprint);
		if (ahc->features & AHC_TWIN)
			config_found((void *)ahc, &ahc->sc_link_b, scsiprint);
d2289 3
a2291 5
		/*
		 * if implementation of IS_SCSIBUS_B() is changed to use
		 * ahc->sc_link.scsibus, then "ahc->sc_link.scsibus = 0xff;"
		 * is needed, here.
		 */
d2293 18
a2310 3
		/* assert(ahc->features & AHC_TWIN); */
		config_found((void *)ahc, &ahc->sc_link_b, scsiprint);
		config_found((void *)ahc, &ahc->sc_link, scsiprint);
a2311 1
	return 1;
d2314 7
a2320 4
STATIC void
ahc_fetch_devinfo(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
d2322 10
a2331 23
	u_int	saved_tcl;
	role_t	role;
	int	our_id;

	if (ahc_inb(ahc, SSTAT0) & TARGET)
		role = ROLE_TARGET;
	else
		role = ROLE_INITIATOR;

	if (role == ROLE_TARGET
	 && (ahc->features & AHC_MULTI_TID) != 0
	 && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
		/* We were selected, so pull our id from TARGIDIN */
		our_id = ahc_inb(ahc, TARGIDIN) & OID;
	} else if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;

	saved_tcl = ahc_inb(ahc, SAVED_TCL);
	ahc_compile_devinfo(devinfo, our_id, TCL_TARGET(saved_tcl),
			    TCL_LUN(saved_tcl), TCL_CHANNEL(ahc, saved_tcl),
			    role);
d2334 8
a2341 8
STATIC void
ahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)
	struct ahc_devinfo *devinfo;
	u_int our_id;
	u_int target;
	u_int lun;
	char channel;
	role_t role;
d2343 15
a2357 9
	devinfo->our_scsiid = our_id;
	devinfo->target = target;
	devinfo->lun = lun;
	devinfo->target_offset = target;
	devinfo->channel = channel;
	devinfo->role = role;
	if (channel == 'B')
		devinfo->target_offset += 8;
	devinfo->target_mask = (0x01 << devinfo->target_offset);
d2361 1
a2361 1
 * Catch an interrupt from the adapter
d2363 2
a2364 2
int
ahc_intr(void *arg)
d2366 12
a2377 2
	struct	ahc_softc *ahc;
	u_int	intstat;
d2379 9
a2387 1
	ahc = (struct ahc_softc *)arg; 
d2389 3
a2391 1
	intstat = ahc_inb(ahc, INTSTAT);
d2393 7
a2399 65
	/*
	 * Any interrupts to process?
	 */
	if ((intstat & INT_PEND) == 0) {
		if (ahc->pci_intr_func && ahc->pci_intr_func(ahc)) {
#ifdef AHC_DEBUG
			printf("%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\n",
			    ahc_name(ahc),
			    ahc_inb(ahc, CCHADDR) |
			    (ahc_inb(ahc, CCHADDR+1) << 8)
			    | (ahc_inb(ahc, CCHADDR+2) << 16)
			    | (ahc_inb(ahc, CCHADDR+3) << 24),
			    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)
			    | (ahc_inb(ahc, HADDR+2) << 16)
			    | (ahc_inb(ahc, HADDR+3) << 24),
			    ahc_inb(ahc, SEQADDR0) |
			    (ahc_inb(ahc, SEQADDR1) << 8));
#endif
			return 1;
		}
		return 0;
	}

	if (intstat & CMDCMPLT) {
		ahc_outb(ahc, CLRINT, CLRCMDINT);
		ahc_run_qoutfifo(ahc);
	}
	if (intstat & BRKADRINT) {
		/*
		 * We upset the sequencer :-(
		 * Lookup the error message
		 */
		int i, error, num_errors;

		error = ahc_inb(ahc, ERROR);
		num_errors =  sizeof(hard_error)/sizeof(hard_error[0]);
		for (i = 0; error != 1 && i < num_errors; i++)
			error >>= 1;
		panic("%s: brkadrint, %s at seqaddr = 0x%x\n",
		      ahc_name(ahc), hard_error[i].errmesg,
		      ahc_inb(ahc, SEQADDR0) |
		      (ahc_inb(ahc, SEQADDR1) << 8));

		/* Tell everyone that this HBA is no longer availible */
		ahc_abort_scbs(ahc, ALL_TARGETS, ALL_CHANNELS,
			       ALL_LUNS, SCB_LIST_NULL, ROLE_UNKNOWN,
			       XS_DRIVER_STUFFUP);
	}
	if (intstat & SEQINT)
		ahc_handle_seqint(ahc, intstat);

	if (intstat & SCSIINT)
		ahc_handle_scsiint(ahc, intstat);
	return(1);
}

STATIC struct tmode_tstate *
ahc_alloc_tstate(ahc, scsi_id, channel)
	struct ahc_softc *ahc;
	u_int scsi_id;
	char channel;
{
	struct tmode_tstate *master_tstate;
	struct tmode_tstate *tstate;
	int i, s;
d2401 2
a2402 12
	master_tstate = ahc->enabled_targets[ahc->our_id];
	if (channel == 'B') {
		scsi_id += 8;
		master_tstate = ahc->enabled_targets[ahc->our_id_b + 8];
	}
	if (ahc->enabled_targets[scsi_id] != NULL
	 && ahc->enabled_targets[scsi_id] != master_tstate)
		panic("%s: ahc_alloc_tstate - Target already allocated",
		      ahc_name(ahc));
	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
	if (tstate == NULL)
		return (NULL);
d2404 17
a2420 14
	/*
	 * If we have allocated a master tstate, copy user settings from
	 * the master tstate (taken from SRAM or the EEPROM) for this
	 * channel, but reset our current and goal settings to async/narrow
	 * until an initiator talks to us.
	 */
	if (master_tstate != NULL) {
		bcopy(master_tstate, tstate, sizeof(*tstate));
		tstate->ultraenb = 0;
		for (i = 0; i < 16; i++) {
			bzero(&tstate->transinfo[i].current,
			      sizeof(tstate->transinfo[i].current));
			bzero(&tstate->transinfo[i].goal,
			      sizeof(tstate->transinfo[i].goal));
a2421 7
	} else
		bzero(tstate, sizeof(*tstate));
	s = splbio();
	ahc->enabled_targets[scsi_id] = tstate;
	splx(s);
	return (tstate);
}
d2423 6
a2428 9
STATIC void
ahc_handle_seqint(ahc, intstat)
	struct ahc_softc *ahc;
	u_int intstat;
{
	struct scb *scb;
	struct ahc_devinfo devinfo;
	
	ahc_fetch_devinfo(ahc, &devinfo);
d2430 10
a2439 13
	/*
	 * Clear the upper byte that holds SEQINT status
	 * codes and clear the SEQINT bit. We will unpause
	 * the sequencer, if appropriate, after servicing
	 * the request.
	 */
	ahc_outb(ahc, CLRINT, CLRSEQINT);
	switch (intstat & SEQINT_MASK) {
	case NO_MATCH:
	{
		/* Ensure we don't leave the selection hardware on */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
d2441 4
a2444 66
		printf("%s:%c:%d: no active SCB for reconnecting "
		       "target - issuing BUS DEVICE RESET\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target);
		printf("SAVED_TCL == 0x%x, ARG_1 == 0x%x, SEQ_FLAGS == 0x%x\n",
		       ahc_inb(ahc, SAVED_TCL), ahc_inb(ahc, ARG_1),
		       ahc_inb(ahc, SEQ_FLAGS));
		ahc->msgout_buf[0] = MSG_BUS_DEV_RESET;
		ahc->msgout_len = 1;
		ahc->msgout_index = 0;
		ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, LASTPHASE) | ATNO);
		break;
	}
	case UPDATE_TMSG_REQ:
		ahc_outb(ahc, TARGET_MSG_REQUEST, ahc->targ_msg_req & 0xFF);
		ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
			 (ahc->targ_msg_req >> 8) & 0xFF);
		ahc_outb(ahc, HS_MAILBOX, 0);
		break;
	case SEND_REJECT: 
	{
		u_int rejbyte = ahc_inb(ahc, ACCUM);
		printf("%s:%c:%d: Warning - unknown message received from "
		       "target (0x%x).  Rejecting\n", 
		       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);
		break; 
	}
	case NO_IDENT: 
	{
		/*
		 * The reconnecting target either did not send an identify
		 * message, or did, but we didn't find and SCB to match and
		 * before it could respond to our ATN/abort, it hit a dataphase.
		 * The only safe thing to do is to blow it away with a bus
		 * reset.
		 */
		int found;

		printf("%s:%c:%d: Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x, SAVED_TCL == 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_TCL));
		found = ahc_reset_channel(ahc, devinfo.channel, 
					  /*initiate reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), devinfo.channel,
		       found);
		return;
	}
	case BAD_PHASE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		if (lastphase == P_BUSFREE) {
			printf("%s:%c:%d: Missed busfree.  Curphase = 0x%x\n",
			       ahc_name(ahc), devinfo.channel, devinfo.target,
			       ahc_inb(ahc, SCSISIGI));
			restart_sequencer(ahc);
			return;
		} else {
			printf("%s:%c:%d: unknown scsi bus phase %x.  "
			       "Attempting to continue\n",
			       ahc_name(ahc), devinfo.channel, devinfo.target,
			       ahc_inb(ahc, SCSISIGI));
a2445 18
		break; 
	}
	case BAD_STATUS:
	{
		u_int  scb_index;
		struct hardware_scb *hscb;
		struct scsi_xfer *xs;
		/*
		 * The sequencer will notify us when a command
		 * has an error that would be of interest to
		 * the kernel.  This allows us to leave the sequencer
		 * running in the common case of command completes
		 * without error.  The sequencer will already have
		 * dma'd the SCB back up to us, so we can reference
		 * the in kernel copy directly.
		 */
		scb_index = ahc_inb(ahc, SCB_TAG);
		scb = &ahc->scb_data->scbarray[scb_index];
d2448 2
a2449 3
		 * Set the default return value to 0 (don't
		 * send sense).  The sense code will change
		 * this if needed.
d2451 8
a2458 9
		ahc_outb(ahc, RETURN_1, 0);
		if (!(scb_index < ahc->scb_data->numscbs
		   && (scb->flags & SCB_ACTIVE) != 0)) {
			printf("%s:%c:%d: ahc_intr - referenced scb "
			       "not valid during seqint 0x%x scb(%d)\n",
			       ahc_name(ahc), devinfo.channel,
			       devinfo.target, intstat, scb_index);
			goto unpause;
		}
d2460 1
a2460 2
		hscb = scb->hscb; 
		xs = scb->xs;
d2462 10
a2471 9
		/* Don't want to clobber the original sense code */
		if ((scb->flags & SCB_SENSE) != 0) {
			/*
			 * Clear the SCB_SENSE Flag and have
			 * the sequencer do a normal command
			 * complete.
			 */
			scb->flags &= ~SCB_SENSE;
			ahcsetccbstatus(xs, XS_DRIVER_STUFFUP);
a2473 24
		/* Freeze the queue unit the client sees the error. */
		ahc_freeze_devq(ahc, xs->sc_link);
		ahc_freeze_ccb(scb);
		xs->status = hscb->status;
		switch (hscb->status) {
		case SCSI_OK:
			printf("%s: Interrupted for staus of 0???\n",
			       ahc_name(ahc));
			break;
		case SCSI_CHECK:
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d: requests Check Status\n",
				       scb->hscb->tag);
			}
#endif
				
			if (xs->error == XS_NOERROR &&
			    !(scb->flags & SCB_SENSE)) {
				struct ahc_dma_seg *sg;
				struct scsi_sense *sc;
				struct ahc_initiator_tinfo *tinfo;
				struct tmode_tstate *tstate;
d2475 2
a2476 9
				sg = scb->sg_list;
				sc = (struct scsi_sense *)(&hscb->cmdstore); 
				/*
				 * Save off the residual if there is one.
				 */
				if (hscb->residual_SG_count != 0)
					ahc_calc_residual(scb);
				else
					xs->resid = 0;
d2478 1
a2478 10
#ifdef AHC_DEBUG
				if (ahc_debug & AHC_SHOWSENSE) {
					sc_print_addr(scb->xs->sc_link);
					printf("Sending Sense\n");
				}
#endif
				sg->addr = ahc->scb_data->sense_busaddr +
					(hscb->tag*sizeof(struct scsi_sense_data));
				
				sg->len = sizeof(struct scsi_sense_data);
d2480 6
a2485 12
				sc->opcode = REQUEST_SENSE;
				sc->byte2 =  SCB_LUN(scb) << 5;
				sc->unused[0] = 0;
				sc->unused[1] = 0;
				sc->length = sg->len;
				sc->control = 0;

				/*
				 * Would be nice to preserve DISCENB here,
				 * but due to the way we page SCBs, we can't.
				 */
				hscb->control = 0;
a2486 58
				/*
				 * This request sense could be because the
				 * the device lost power or in some other
				 * way has lost our transfer negotiations.
				 * Renegotiate if appropriate.
				 */
				ahc_calc_residual(scb);
#ifdef AHC_DEBUG
				if (ahc_debug & AHC_SHOWSENSE) {
					sc_print_addr(xs->sc_link);
					printf("Sense: datalen %d resid %d"
					       "chan %d id %d targ %d\n",
					       xs->datalen, xs->resid,
					       devinfo.channel,
					       devinfo.our_scsiid,
					       devinfo.target);
				}
#endif
				if (xs->datalen > 0 &&
				    xs->resid == xs->datalen) {
				tinfo = ahc_fetch_transinfo(ahc,
							    devinfo.channel,
							    devinfo.our_scsiid,
							    devinfo.target,
							    &tstate);
					ahc_update_target_msg_request(ahc,
							      &devinfo,
							      tinfo,
							      /*force*/TRUE,
							      /*paused*/TRUE);
				}
				hscb->status = 0;
				hscb->SG_count = 1;
				hscb->SG_pointer = scb->sg_list_phys;
				hscb->data = sg->addr; 
				hscb->datalen = sg->len;
				hscb->cmdpointer = hscb->cmdstore_busaddr;
				hscb->cmdlen = sizeof(*sc);
				scb->sg_count = hscb->SG_count;
				ahc_swap_hscb(hscb);
				ahc_swap_sg(scb->sg_list);
				scb->flags |= SCB_SENSE;
				/*
				 * Ensure the target is busy since this
				 * will be an untagged request.
				 */
				ahc_busy_tcl(ahc, scb);
				ahc_outb(ahc, RETURN_1, SEND_SENSE);

				/*
				 * Ensure we have enough time to actually
				 * retrieve the sense.
				 */
				if (!(scb->xs->flags & SCSI_POLL))
					timeout_add(&scb->xs->stimeout, 5 * hz);
			}
			break;
		case SCSI_BUSY:
d2488 3
a2490 2
			 * Requeue any transactions that haven't been
			 * sent yet.
d2492 8
a2499 4
			ahc_freeze_devq(ahc, xs->sc_link);
			ahc_freeze_ccb(scb);
			break;
		}
d2502 1
a2502 12
	case TRACE_POINT:
	{
		printf("SSTAT2 = 0x%x DFCNTRL = 0x%x\n", ahc_inb(ahc, SSTAT2),
		       ahc_inb(ahc, DFCNTRL));
		printf("SSTAT3 = 0x%x DSTATUS = 0x%x\n", ahc_inb(ahc, SSTAT3),
		       ahc_inb(ahc, DFSTATUS));
		printf("SSTAT0 = 0x%x, SCB_DATACNT = 0x%x\n",
		       ahc_inb(ahc, SSTAT0),
		       ahc_inb(ahc, SCB_DATACNT));
		break;
	}
	case HOST_MSG_LOOP:
d2504 6
d2511 4
a2514 8
		 * The sequencer has encountered a message phase
		 * that requires host assistance for completion.
		 * While handling the message phase(s), we will be
		 * notified by the sequencer after each byte is
		 * transfered so we can track bus phases.
		 *
		 * If this is the first time we've seen a HOST_MSG_LOOP,
		 * initialize the state of the host message loop.
d2516 5
a2520 2
		if (ahc->msg_type == MSG_TYPE_NONE) {
			u_int bus_phase;
d2522 1
a2522 13
			bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			if (bus_phase != P_MESGIN
			 && bus_phase != P_MESGOUT) {
				printf("ahc_intr: HOST_MSG_LOOP bad "
				       "phase 0x%x\n",
				      bus_phase);
				/*
				 * Probably transitioned to bus free before
				 * we got here.  Just punt the message.
				 */
				ahc_clear_intstat(ahc);
				restart_sequencer(ahc);
			}
d2524 15
a2538 3
			if (devinfo.role == ROLE_INITIATOR) {
				struct scb *scb;
				u_int scb_index;
d2540 6
a2545 21
				scb_index = ahc_inb(ahc, SCB_TAG);
				scb = &ahc->scb_data->scbarray[scb_index];

				if (bus_phase == P_MESGOUT)
					ahc_setup_initiator_msgout(ahc,
								   &devinfo,
								   scb);
				else {
					ahc->msg_type =
					    MSG_TYPE_INITIATOR_MSGIN;
					ahc->msgin_index = 0;
				}
			} else {
				if (bus_phase == P_MESGOUT) {
					ahc->msg_type =
					    MSG_TYPE_TARGET_MSGOUT;
					ahc->msgin_index = 0;
				} else 
					/* XXX Ever executed??? */
					ahc_setup_target_msgin(ahc, &devinfo);
			}
d2548 5
a2552 2
		/* Pass a NULL path so that handlers generate their own */
		ahc_handle_message_phase(ahc, /*path*/NULL);
d2555 1
a2555 1
	case PERR_DETECTED:
d2557 3
d2561 2
a2562 9
		 * If we've cleared the parity error interrupt
		 * but the sequencer still believes that SCSIPERR
		 * is true, it must be that the parity error is
		 * for the currently presented byte on the bus,
		 * and we are not in a phase (data-in) where we will
		 * eventually ack this byte.  Ack the byte and
		 * throw it away in the hope that the target will
		 * take us to message out to deliver the appropriate
		 * error message.
d2564 1
a2564 3
		if ((intstat & SCSIINT) == 0
		 && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {
			u_int curphase;
d2566 9
d2576 4
a2579 4
			 * The hardware will only let you ack bytes
			 * if the expected phase in SCSISIGO matches
			 * the current phase.  Make sure this is
			 * currently the case.
d2581 1
a2581 4
			curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			ahc_outb(ahc, LASTPHASE, curphase);
			ahc_outb(ahc, SCSISIGO, curphase);
			ahc_inb(ahc, SCSIDATL);
d2583 3
a2585 4
		break;
	}
	case DATA_OVERRUN:
	{
d2587 2
a2588 6
		 * When the sequencer detects an overrun, it
		 * places the controller in "BITBUCKET" mode
		 * and allows the target to complete its transfer.
		 * Unfortunately, none of the counters get updated
		 * when the controller is in this mode, so we have
		 * no way of knowing how large the overrun was.
d2590 2
a2591 3
		u_int scbindex = ahc_inb(ahc, SCB_TAG);
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		int i;
d2593 10
a2602 3
		scb = &ahc->scb_data->scbarray[scbindex];
		for (i = 0; i < num_phases; i++) {
			if (lastphase == phase_table[i].phase)
d2604 1
d2606 7
a2612 16
		sc_print_addr(scb->xs->sc_link);
		printf("data overrun detected %s."
		       "  Tag == 0x%x.\n",
		       phase_table[i].phasemsg,
  		       scb->hscb->tag);
		sc_print_addr(scb->xs->sc_link);
		printf("%s seen Data Phase.  Length = %d.  NumSGs = %d.\n",
		       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
		       scb->xs->datalen, scb->sg_count);
		if (scb->sg_count > 0) {
			for (i = 0; i < scb->sg_count; i++) {
				printf("sg[%d] - Addr 0x%x : Length %d\n",
				       i,
				       (unsigned int)le32toh(scb->sg_list[i].addr),
				       (unsigned int)le32toh(scb->sg_list[i].len));
			}
d2614 1
a2614 32
		/*
		 * Set this and it will take affect when the
		 * target does a command complete.
		 */
		ahc_freeze_devq(ahc, scb->xs->sc_link);
		ahcsetccbstatus(scb->xs, XS_DRIVER_STUFFUP);
		ahc_freeze_ccb(scb);
		break;
	}
	case TRACEPOINT:
	{
		printf("TRACEPOINT: RETURN_2 = %d\n", ahc_inb(ahc, RETURN_2));
#if 0
		printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1));
		printf("SSTAT0 == 0x%x\n", ahc_inb(ahc, SSTAT0));
		printf(", SCSISIGI == 0x%x\n", ahc_inb(ahc, SCSISIGI));
		printf("TRACEPOINT: CCHCNT = %d, SG_COUNT = %d\n",
		       ahc_inb(ahc, CCHCNT), ahc_inb(ahc, SG_COUNT));
		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG));
		printf("TRACEPOINT1: CCHADDR = %d, CCHCNT = %d, SCBPTR = %d\n",
		       ahc_inb(ahc, CCHADDR)
		    | (ahc_inb(ahc, CCHADDR+1) << 8)
		    | (ahc_inb(ahc, CCHADDR+2) << 16)
		    | (ahc_inb(ahc, CCHADDR+3) << 24),
		       ahc_inb(ahc, CCHCNT)
		    | (ahc_inb(ahc, CCHCNT+1) << 8)
		    | (ahc_inb(ahc, CCHCNT+2) << 16),
		       ahc_inb(ahc, SCBPTR));
		printf("TRACEPOINT: WAITING_SCBH = %d\n", 
		       ahc_inb(ahc, WAITING_SCBH));
		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG));
#endif
a2616 7
#if NOT_YET
	/* XXX Fill these in later */
	case MESG_BUFFER_BUSY:
		break;
	case MSGIN_PHASEMIS:
		break;
#endif
d2618 1
a2618 4
		printf("ahc_intr: seqint, "
		       "intstat == 0x%x, scsisigi = 0x%x\n",
		       intstat, ahc_inb(ahc, SCSISIGI));
		break;
d2620 6
a2625 8
	
unpause:
	/*
	 *  The sequencer is paused immediately on
	 *  a SEQINT, so we should restart it when
	 *  we're done.
	 */
	unpause_sequencer(ahc);
d2628 8
a2635 4
STATIC void
ahc_handle_scsiint(ahc, intstat)
	struct ahc_softc *ahc;
	u_int intstat;
d2637 13
a2649 5
	u_int	scb_index;
	u_int	status;
	struct	scb *scb;
	char	cur_channel;
	char	intr_channel;
d2651 9
a2659 6
	if ((ahc->features & AHC_TWIN) != 0
	 && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
		cur_channel = 'B';
	else
		cur_channel = 'A';
	intr_channel = cur_channel;
d2661 9
a2669 12
	status = ahc_inb(ahc, SSTAT1);
	if (status == 0) {
		if ((ahc->features & AHC_TWIN) != 0) {
			/* Try the other channel */
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			status = ahc_inb(ahc, SSTAT1);
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			intr_channel = (cur_channel == 'A') ? 'B' : 'A';
		}
		if (status == 0) {
			printf("%s: Spurious SCSI interrupt\n", ahc_name(ahc));
			return;
d2671 3
d2675 2
d2678 12
a2689 8
	scb_index = ahc_inb(ahc, SCB_TAG);
	if (scb_index < ahc->scb_data->numscbs) {
		scb = &ahc->scb_data->scbarray[scb_index];
		if ((scb->flags & SCB_ACTIVE) == 0
		 || (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)
			scb = NULL;
	} else
		scb = NULL;
d2691 6
a2696 20
	if ((status & SCSIRSTI) != 0) {
		printf("%s: Someone reset channel %c\n",
			ahc_name(ahc), intr_channel);
		ahc_reset_channel(ahc, intr_channel, /* Initiate Reset */FALSE);
	} else if ((status & SCSIPERR) != 0) {
		/*
		 * Determine the bus phase and queue an appropriate message.
		 * SCSIPERR is latched true as soon as a parity error
		 * occurs.  If the sequencer acked the transfer that
		 * caused the parity error and the currently presented
		 * transfer on the bus has correct parity, SCSIPERR will
		 * be cleared by CLRSCSIPERR.  Use this to determine if
		 * we should look at the last phase the sequencer recorded,
		 * or the current phase presented on the bus.
		 */
		u_int mesg_out;
		u_int curphase;
		u_int errorphase;
		u_int lastphase;
		int   i;
d2698 36
a2733 19
		lastphase = ahc_inb(ahc, LASTPHASE);
		curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
		ahc_outb(ahc, CLRSINT1, CLRSCSIPERR);
		/*
		 * For all phases save DATA, the sequencer won't
		 * automatically ack a byte that has a parity error
		 * in it.  So the only way that the current phase
		 * could be 'data-in' is if the parity error is for
		 * an already acked byte in the data phase.  During
		 * synchronous data-in transfers, we may actually
		 * ack bytes before latching the current phase in
		 * LASTPHASE, leading to the discrepancy between
		 * curphase and lastphase.
		 */
		if ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0
		 || curphase == P_DATAIN)
			errorphase = curphase;
		else
			errorphase = lastphase;
d2735 8
a2742 2
		for (i = 0; i < num_phases; i++) {
			if (errorphase == phase_table[i].phase)
a2743 14
		}
		mesg_out = phase_table[i].mesg_out;
		if (scb != NULL)
			sc_print_addr(scb->xs->sc_link);
		else
			printf("%s:%c:%d: ", ahc_name(ahc),
			       intr_channel,
			       TCL_TARGET(ahc_inb(ahc, SAVED_TCL)));
		
		printf("parity error detected %s. "
		       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
		       phase_table[i].phasemsg,
		       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),
		       ahc_inb(ahc, SCSIRATE));
d2745 55
a2799 12
		/*
		 * We've set the hardware to assert ATN if we   
		 * get a parity error on "in" phases, so all we  
		 * need to do is stuff the message buffer with
		 * the appropriate message.  "In" phases have set
		 * mesg_out to something other than MSG_NOP.
		 */
		if (mesg_out != MSG_NOOP) {
			if (ahc->msg_type != MSG_TYPE_NONE)
				ahc->send_msg_perror = TRUE;
			else
				ahc_outb(ahc, MSG_OUT, mesg_out);
d2801 5
a2805 16
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		unpause_sequencer(ahc);
	} else if ((status & BUSFREE) != 0
		&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {
		/*
		 * First look at what phase we were last in.
		 * If its message out, chances are pretty good
		 * that the busfree was in response to one of
		 * our abort requests.
		 */
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		u_int saved_tcl = ahc_inb(ahc, SAVED_TCL);
		u_int target = TCL_TARGET(saved_tcl);
		u_int initiator_role_id = TCL_SCSI_ID(ahc, saved_tcl);
		char channel = TCL_CHANNEL(ahc, saved_tcl);
		int printerror = 1;
d2807 3
a2809 46
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (lastphase == P_MESGOUT) {
			u_int message;
			u_int tag;

			message = ahc->msgout_buf[ahc->msgout_index - 1];
			tag = SCB_LIST_NULL;
			switch (message) {
			case MSG_ABORT_TAG:
				tag = scb->hscb->tag;
				/* FALLTRHOUGH */
			case MSG_ABORT:
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d - Abort %s Completed.\n",
				       scb->hscb->tag, tag == SCB_LIST_NULL ?
				       "" : "Tag");
				ahc_abort_scbs(ahc, target, channel,
					       TCL_LUN(saved_tcl), tag,
					       ROLE_INITIATOR,
					       XS_DRIVER_STUFFUP);
				printerror = 0;
				break;
			case MSG_BUS_DEV_RESET:
			{
				struct ahc_devinfo devinfo;

				if (scb != NULL &&
				    (scb->xs->flags & SCSI_RESET)
				 && ahc_match_scb(scb, target, channel,
						  TCL_LUN(saved_tcl),
						  SCB_LIST_NULL,
						  ROLE_INITIATOR)) {
					ahcsetccbstatus(scb->xs, XS_NOERROR);
				}
				ahc_compile_devinfo(&devinfo,
						    initiator_role_id,
						    target,
						    TCL_LUN(saved_tcl),
						    channel,
						    ROLE_INITIATOR);
				ahc_handle_devreset(ahc, &devinfo,
						    XS_RESET,
						    "Bus Device Reset",
						    /*verbose_level*/0);
				printerror = 0;
d2812 9
a2820 1
			default:
d2822 11
a2833 3
		}
		if (printerror != 0) {
			int i;
d2835 16
a2850 12
			if (scb != NULL) {
				u_int tag;

				if ((scb->hscb->control & TAG_ENB) != 0)
					tag = scb->hscb->tag;
				else
					tag = SCB_LIST_NULL;
				ahc_abort_scbs(ahc, target, channel,
					       SCB_LUN(scb), tag,
					       ROLE_INITIATOR,
					       XS_DRIVER_STUFFUP);
				sc_print_addr(scb->xs->sc_link);
d2853 1
a2853 2
				 * We had not fully identified this connection,
				 * so we cannot abort anything.
d2855 13
a2867 1
				printf("%s: ", ahc_name(ahc));
d2869 17
a2885 3
			for (i = 0; i < num_phases; i++) {
				if (lastphase == phase_table[i].phase)
					break;
d2887 2
a2888 4
			printf("Unexpected busfree %s\n"
			       "SEQADDR == 0x%x\n",
			       phase_table[i].phasemsg, ahc_inb(ahc, SEQADDR0)
				| (ahc_inb(ahc, SEQADDR1) << 8));
d2890 10
a2899 7
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		restart_sequencer(ahc);
	} else if ((status & SELTO) != 0) {
		u_int scbptr;
d2901 4
a2904 3
		scbptr = ahc_inb(ahc, WAITING_SCBH);
		ahc_outb(ahc, SCBPTR, scbptr);
		scb_index = ahc_inb(ahc, SCB_TAG);
d2906 9
a2914 6
		if (scb_index < ahc->scb_data->numscbs) {
			scb = &ahc->scb_data->scbarray[scb_index];
			if ((scb->flags & SCB_ACTIVE) == 0)
				scb = NULL;
		} else
			scb = NULL;
d2916 15
a2930 6
		if (scb == NULL) {
			printf("%s: ahc_intr - referenced scb not "
			       "valid during SELTO scb(%d, %d)\n",
			       ahc_name(ahc), scbptr, scb_index);
		} else {
			u_int tag;
d2932 17
a2948 3
			tag = SCB_LIST_NULL;
			if ((scb->hscb->control & TAG_ENB) != 0)
				tag = scb->hscb->tag;
d2950 60
a3009 3
			ahc_abort_scbs(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				       SCB_LUN(scb), tag,
				       ROLE_INITIATOR, XS_SELTIMEOUT);
d3011 1
a3011 26
		/* Stop the selection */
		ahc_outb(ahc, SCSISEQ, 0);

		/* No more pending messages */
		ahc_clear_msg_state(ahc);

		/*
		 * Although the driver does not care about the
		 * 'Selection in Progress' status bit, the busy
		 * LED does.  SELINGO is only cleared by a sucessful
		 * selection, so we must manually clear it to ensure
		 * the LED turns off just incase no future successful
		 * selections occur (e.g. no devices on the bus).
		 */
		ahc_outb(ahc, CLRSINT0, CLRSELINGO);

		/* Clear interrupt state */
		ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		restart_sequencer(ahc);
	} else {
		sc_print_addr(scb->xs->sc_link);
		printf("Unknown SCSIINT. Status = 0x%x\n", status);
		ahc_outb(ahc, CLRSINT1, status);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		unpause_sequencer(ahc);
d3013 23
a3035 1
}
d3037 3
a3039 14
STATIC void
ahc_build_transfer_msg(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	/*
	 * We need to initiate transfer negotiations.
	 * If our current and goal settings are identical,
	 * we want to renegotiate due to a check condition.
	 */
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	int	dowide;
	int	dosync;
d3041 8
a3048 59
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
	dowide = tinfo->current.width != tinfo->goal.width;
	dosync = tinfo->current.period != tinfo->goal.period;

	if (!dowide && !dosync) {
		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
		dosync = tinfo->goal.period != 0;
	}

	if (dowide) {
		ahc_construct_wdtr(ahc, tinfo->goal.width);
	} else if (dosync) {
		struct	ahc_syncrate *rate;
		u_int	period;
		u_int	offset;

		period = tinfo->goal.period;
		rate = ahc_devlimited_syncrate(ahc, &period);
		offset = tinfo->goal.offset;
		ahc_validate_offset(ahc, rate, &offset,
				    tinfo->current.width);
		ahc_construct_sdtr(ahc, period, offset);
	} else {
		panic("ahc_intr: AWAITING_MSG for negotiation, "
		      "but no negotiation needed\n");	
	}
}

STATIC void
ahc_setup_initiator_msgout(ahc, devinfo, scb)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct scb *scb;
{
	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if ((scb->flags & SCB_DEVICE_RESET) == 0
	 && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {
		u_int identify_msg;

		identify_msg = MSG_IDENTIFYFLAG | SCB_LUN(scb);
		if ((scb->hscb->control & DISCENB) != 0)
			identify_msg |= MSG_IDENTIFY_DISCFLAG;
		ahc->msgout_buf[ahc->msgout_index++] = identify_msg;
		ahc->msgout_len++;

		if ((scb->hscb->control & TAG_ENB) != 0) {
			/* XXX fvdl FreeBSD has tag action passed down */
			ahc->msgout_buf[ahc->msgout_index++] = MSG_SIMPLE_Q_TAG;
			ahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;
			ahc->msgout_len += 2;
d3050 7
d3059 9
a3067 22
	if (scb->flags & SCB_DEVICE_RESET) {
		ahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;
		ahc->msgout_len++;
		
		sc_print_addr(scb->xs->sc_link);
		printf("Bus Device Reset Message Sent\n");
	} else if (scb->flags & SCB_ABORT) {
		if ((scb->hscb->control & TAG_ENB) != 0)
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;
		else
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;
		ahc->msgout_len++;
		sc_print_addr(scb->xs->sc_link);
		printf("Abort Message Sent\n");
	} else if ((ahc->targ_msg_req & devinfo->target_mask) != 0) {
		ahc_build_transfer_msg(ahc, devinfo);
	} else {
		printf("ahc_intr: AWAITING_MSG for an SCB that "
		       "does not have a waiting message");
		panic("SCB = %d, SCB Control = %x, MSG_OUT = %x "
		      "SCB flags = %x", scb->hscb->tag, scb->hscb->control,
		      ahc_inb(ahc, MSG_OUT), scb->flags);
d3070 3
a3072 26
	/*
	 * Clear the MK_MESSAGE flag from the SCB so we aren't
	 * asked to send this message again.
	 */
	ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);
	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
}

STATIC void
ahc_setup_target_msgin(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if ((ahc->targ_msg_req & devinfo->target_mask) != 0)
		ahc_build_transfer_msg(ahc, devinfo);
	else
		panic("ahc_intr: AWAITING target message with no message");
d3074 1
a3074 2
	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
d3077 5
a3081 4
STATIC int
ahc_handle_msg_reject(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
d3090 2
d3097 4
a3100 2
	scb = &ahc->scb_data->scbarray[scb_index];

d3104 20
a3123 3
	if (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/FALSE)) {
		struct ahc_initiator_tinfo *tinfo;
		struct tmode_tstate *tstate;
d3126 4
a3129 6
		if (bootverbose)
			printf("%s:%c:%d: refuses WIDE negotiation.  Using "
			       "8bit transfers\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target);
		ahc_set_width(ahc, devinfo,
			      MSG_EXT_WDTR_BUS_8_BIT,
d3131 1
a3131 1
			      /*paused*/TRUE, /*done*/TRUE);
a3138 3
		tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
					    devinfo->our_scsiid,
					    devinfo->target, &tstate);
a3139 1
			u_int period;
a3141 2
			period = tinfo->goal.period;
			ahc_devlimited_syncrate(ahc, &period);
d3144 1
a3144 1
			ahc_construct_sdtr(ahc, period, tinfo->goal.offset);
d3148 1
a3148 1
	} else if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/FALSE)) {
d3151 1
a3151 1
				 /*offset*/0,
d3153 26
a3178 14
				 /*paused*/TRUE,
				 /*done*/TRUE);
		if (bootverbose)
			printf("%s:%c:%d: refuses synchronous negotiation. "
			       "Using asynchronous transfers\n",
			       ahc_name(ahc),
			       devinfo->channel, devinfo->target);
	} else if ((scb->hscb->control & TAG_ENB) != 0) {
		if (bootverbose)
			printf("%s:%c:%d: refuses tagged commands.  Performing "
			       "non-tagged I/O\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target);
			
		ahc_set_tags(ahc, devinfo, FALSE);
d3184 5
a3188 3
		ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL)
					  & ~MSG_SIMPLE_Q_TAG);
	 	scb->hscb->control &= ~TAG_ENB;
d3190 16
a3205 1
		ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);
d3212 4
a3215 3
		ahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				   SCB_LUN(scb), /*tag*/SCB_LIST_NULL,
				   ROLE_INITIATOR, SCB_REQUEUE,
d3228 5
a3232 3
STATIC void
ahc_clear_msg_state(ahc)
	struct ahc_softc *ahc;
d3234 49
a3282 5
	ahc->msgout_len = 0;
	ahc->msgin_index = 0;
	ahc->msg_type = MSG_TYPE_NONE;
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
}
d3284 4
a3287 8
STATIC void
ahc_handle_message_phase(ahc, sc_link)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
{ 
	struct	ahc_devinfo devinfo;
	u_int	bus_phase;
	int	end_session;
d3289 2
a3290 3
	ahc_fetch_devinfo(ahc, &devinfo);
	end_session = FALSE;
	bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
d3292 9
a3300 7
reswitch:
	switch (ahc->msg_type) {
	case MSG_TYPE_INITIATOR_MSGOUT:
	{
		int lastbyte;
		int phasemis;
		int msgdone;
d3302 9
a3310 2
		if (ahc->msgout_len == 0)
			panic("REQINIT interrupt with no active message");
a3311 3
		phasemis = bus_phase != P_MESGOUT;
		if (phasemis) {
			if (bus_phase == P_MESGIN) {
d3313 2
a3314 4
				 * Change gears and see if
				 * this messages is of interest to
				 * us or should be passed back to
				 * the sequencer.
d3316 9
a3324 5
				ahc_outb(ahc, CLRSINT1, CLRATNO);
				ahc->send_msg_perror = FALSE;
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;
				ahc->msgin_index = 0;
				goto reswitch;
d3326 5
a3330 2
			end_session = TRUE;
			break;
d3332 91
d3424 3
a3426 5
		if (ahc->send_msg_perror) {
			ahc_outb(ahc, CLRSINT1, CLRATNO);
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
			ahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);
			break;
d3428 90
d3519 60
a3578 9
		msgdone	= ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			/*
			 * The target has requested a retry.
			 * Re-assert ATN, reset our message index to
			 * 0, and try again.
			 */
			ahc->msgout_index = 0;
			ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);
d3580 36
d3617 25
a3641 12
		lastbyte = ahc->msgout_index == (ahc->msgout_len - 1);
		if (lastbyte) {
			/* Last byte is signified by dropping ATN */
			ahc_outb(ahc, CLRSINT1, CLRATNO);
		}

		/*
		 * Clear our interrupt status and present
		 * the next byte on the bus.
		 */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
a3643 4
	case MSG_TYPE_INITIATOR_MSGIN:
	{
		int phasemis;
		int message_done;
d3645 14
a3658 1
		phasemis = bus_phase != P_MESGIN;
d3660 5
a3664 8
		if (phasemis) {
			ahc->msgin_index = 0;
			if (bus_phase == P_MESGOUT
			 && (ahc->send_msg_perror == TRUE
			  || (ahc->msgout_len != 0
			   && ahc->msgout_index == 0))) {
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
				goto reswitch;
d3666 2
a3667 2
			end_session = TRUE;
			break;
d3669 15
d3685 5
a3689 2
		/* Pull the byte in without acking it */
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);
d3691 1
a3691 1
		message_done = ahc_parse_msg(ahc, sc_link, &devinfo);
d3693 5
a3697 6
		if (message_done) {
			/*
			 * Clear our incoming message buffer in case there
			 * is another message following this one.
			 */
			ahc->msgin_index = 0;
d3699 3
a3701 10
			/*
			 * If this message illicited a response,
			 * assert ATN so the target takes us to the
			 * message out phase.
			 */
			if (ahc->msgout_len != 0)
				ahc_outb(ahc, SCSISIGO,
					 ahc_inb(ahc, SCSISIGO) | ATNO);
		} else 
			ahc->msgin_index++;
d3703 20
a3722 12
		/* Ack the byte */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_inb(ahc, SCSIDATL);
		break;
	}
	case MSG_TYPE_TARGET_MSGIN:
	{
		int msgdone;
		int msgout_request;

		if (ahc->msgout_len == 0)
			panic("Target MSGIN with no active message");
d3725 2
a3726 4
		 * If we interrupted a mesgout session, the initiator
		 * will not know this until our first REQ.  So, we
		 * only honor mesgout requests after we've sent our
		 * first byte.
d3728 6
a3733 5
		if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0
		 && ahc->msgout_index > 0)
			msgout_request = TRUE;
		else
			msgout_request = FALSE;
d3735 1
a3735 1
		if (msgout_request) {
d3737 7
a3743 15
			/*
			 * Change gears and see if
			 * this messages is of interest to
			 * us or should be passed back to
			 * the sequencer.
			 */
			ahc->msg_type = MSG_TYPE_TARGET_MSGOUT;
			ahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);
			ahc->msgin_index = 0;
			/* Dummy read to REQ for first byte */
			ahc_inb(ahc, SCSIDATL);
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
			break;
		}
d3745 5
a3749 7
		msgdone = ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
			end_session = TRUE;
			break;
		}
d3751 16
a3766 5
		/*
		 * Present the next byte on the bus.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
d3768 3
a3771 4
	case MSG_TYPE_TARGET_MSGOUT:
	{
		int lastbyte;
		int msgdone;
d3773 17
a3789 5
		/*
		 * The initiator signals that this is
		 * the last byte by dropping ATN.
		 */
		lastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;
d3791 4
a3794 19
		/*
		 * Read the latched byte, but turn off SPIOEN first
		 * so that we don't inadvertantly cause a REQ for the
		 * next byte.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);
		msgdone = ahc_parse_msg(ahc, sc_link, &devinfo);
		if (msgdone == MSGLOOP_TERMINATED) {
			/*
			 * The message is *really* done in that it caused
			 * us to go to bus free.  The sequencer has already
			 * been reset at this point, so pull the ejection
			 * handle.
			 */
			return;
		}
		
		ahc->msgin_index++;
d3796 2
a3797 6
		/*
		 * XXX Read spec about initiator dropping ATN too soon
		 *     and use msgdone to detect it.
		 */
		if (msgdone == MSGLOOP_MSGCOMPLETE) {
			ahc->msgin_index = 0;
d3799 6
a3804 13
			/*
			 * If this message illicited a response, transition
			 * to the Message in phase and send it.
			 */
			if (ahc->msgout_len != 0) {
				ahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);
				ahc_outb(ahc, SXFRCTL0,
					 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
				ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
				ahc->msgin_index = 0;
				break;
			}
		}
d3806 1
a3806 7
		if (lastbyte)
			end_session = TRUE;
		else {
			/* Ask for the next byte. */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		}
d3808 7
a3814 1
		break;
d3816 1
a3816 9
	default:
		panic("Unknown REQINIT message type");
	}

	if (end_session) {
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);
	} else
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
d3819 3
a3821 11
/*
 * See if we sent a particular extended message to the target.
 * If "full" is true, the target saw the full message.
 * If "full" is false, the target saw at least the first
 * byte of the message.
 */
STATIC int
ahc_sent_msg(ahc, msgtype, full)
	struct ahc_softc *ahc;
	u_int msgtype;
	int full;
d3823 1
a3823 2
	int found;
	int index;
d3825 4
a3828 2
	found = FALSE;
	index = 0;
d3830 8
a3837 2
	while (index < ahc->msgout_len) {
		if (ahc->msgout_buf[index] == MSG_EXTENDED) {
d3839 2
a3840 3
			/* Found a candidate */
			if (ahc->msgout_buf[index+2] == msgtype) {
				u_int end_index;
d3842 2
a3843 11
				end_index = index + 1
					  + ahc->msgout_buf[index + 1];
				if (full) {
					if (ahc->msgout_index > end_index)
						found = TRUE;
				} else if (ahc->msgout_index > index)
					found = TRUE;
			}
			break;
		} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_Q_TAG
			&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
d3845 5
a3849 9
			/* Skip tag type and tag id or residue param*/
			index += 2;
		} else {
			/* Single byte message */
			index++;
		}
	}
	return (found);
}
d3851 2
a3852 50
STATIC int
ahc_parse_msg(ahc, sc_link, devinfo)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
	struct ahc_devinfo *devinfo;
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	int	reject;
	int	done;
	int	response;
	u_int	targ_scsirate;

	done = MSGLOOP_IN_PROG;
	response = FALSE;
	reject = FALSE;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	targ_scsirate = tinfo->scsirate;

	/*
	 * Parse as much of the message as is availible,
	 * rejecting it if we don't support it.  When
	 * the entire message is availible and has been
	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
	 * that we have parsed an entire message.
	 *
	 * In the case of extended messages, we accept the length
	 * byte outright and perform more checking once we know the
	 * extended message type.
	 */
	switch (ahc->msgin_buf[0]) {
	case MSG_MESSAGE_REJECT:
		response = ahc_handle_msg_reject(ahc, devinfo);
		/* FALLTHROUGH */
	case MSG_NOOP:
		done = MSGLOOP_MSGCOMPLETE;
		break;
	case MSG_IGN_WIDE_RESIDUE:
	{
		/* Wait for the whole message */
		if (ahc->msgin_index >= 1) {
			if (ahc->msgin_buf[1] != 1
			 || tinfo->current.width == MSG_EXT_WDTR_BUS_8_BIT) {
				reject = TRUE;
				done = MSGLOOP_MSGCOMPLETE;
			} else
				ahc_handle_ign_wide_residue(ahc, devinfo);
		}
		break;
a3853 17
	case MSG_EXTENDED:
	{
		/* Wait for enough of the message to begin validation */
		if (ahc->msgin_index < 2)
			break;
		switch (ahc->msgin_buf[2]) {
		case MSG_EXT_SDTR:
		{
			struct	 ahc_syncrate *syncrate;
			u_int	 period;
			u_int	 offset;
			u_int	 saved_offset;
			
			if (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
				reject = TRUE;
				break;
			}
d3855 3
a3857 9
			/*
			 * Wait until we have both args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_SDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))
				break;
d3859 4
a3862 9
			period = ahc->msgin_buf[3];
			saved_offset = offset = ahc->msgin_buf[4];
			syncrate = ahc_devlimited_syncrate(ahc, &period);
			ahc_validate_offset(ahc, syncrate, &offset,
					    targ_scsirate & WIDEXFER);
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period, offset,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE, /*done*/TRUE);
d3864 5
a3868 30
			/*
			 * See if we initiated Sync Negotiation
			 * and didn't have to fall down to async
			 * transfers.
			 */
			if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/TRUE)) {
				/* We started it */
				if (saved_offset != offset) {
					/* Went too low - force async */
					reject = TRUE;
				}
			} else {
				/*
				 * Send our own SDTR in reply
				 */
				if (bootverbose)
					printf("Sending SDTR!\n");
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_sdtr(ahc, period, offset);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		case MSG_EXT_WDTR:
		{
			u_int	bus_width;
			u_int	sending_reply;
d3870 3
a3872 5
			sending_reply = FALSE;
			if (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
				reject = TRUE;
				break;
			}
d3874 7
a3880 9
			/*
			 * Wait until we have our arg before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_WDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))
				break;
d3882 1
a3882 54
			bus_width = ahc->msgin_buf[3];
			if (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/TRUE)) {
				/*
				 * Don't send a WDTR back to the
				 * target, since we asked first.
				 */
				switch (bus_width){
				default:
					/*
					 * How can we do anything greater
					 * than 16bit transfers on a 16bit
					 * bus?
					 */
					reject = TRUE;
					printf("%s: target %d requested %dBit "
					       "transfers.  Rejecting...\n",
					       ahc_name(ahc), devinfo->target,
					       8 * (0x01 << bus_width));
					/* FALLTHROUGH */
				case MSG_EXT_WDTR_BUS_8_BIT:
					bus_width = MSG_EXT_WDTR_BUS_8_BIT;
					break;
				case MSG_EXT_WDTR_BUS_16_BIT:
					break;
				}
			} else {
				/*
				 * Send our own WDTR in reply
				 */
				if (bootverbose)
					printf("Sending WDTR!\n");
				switch (bus_width) {
				default:
					if (ahc->features & AHC_WIDE) {
						/* Respond Wide */
						bus_width =
						    MSG_EXT_WDTR_BUS_16_BIT;
						break;
					}
					/* FALLTHROUGH */
				case MSG_EXT_WDTR_BUS_8_BIT:
					bus_width = MSG_EXT_WDTR_BUS_8_BIT;
					break;
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_wdtr(ahc, bus_width);
				ahc->msgout_index = 0;
				response = TRUE;
				sending_reply = TRUE;
			}
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE, /*done*/TRUE);
d3884 7
a3890 6
			/* After a wide message, we are async */
			ahc_set_syncrate(ahc, devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, AHC_TRANS_ACTIVE,
					 /*paused*/TRUE, /*done*/FALSE);
			if (sending_reply == FALSE && reject == FALSE) {
d3892 3
a3894 28
				if (tinfo->goal.period) {
					struct	ahc_syncrate *rate;
					u_int	period;
					u_int	offset;

					/* Start the sync negotiation */
					period = tinfo->goal.period;
					rate = ahc_devlimited_syncrate(ahc,
								       &period);
					offset = tinfo->goal.offset;
					ahc_validate_offset(ahc, rate, &offset,
							  tinfo->current.width);
					ahc->msgout_index = 0;
					ahc->msgout_len = 0;
					ahc_construct_sdtr(ahc, period, offset);
					ahc->msgout_index = 0;
					response = TRUE;
				}
			}
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		default:
			/* Unknown extended message.  Reject it. */
			reject = TRUE;
			break;
		}
		break;
a3895 21
	case MSG_BUS_DEV_RESET:
		ahc_handle_devreset(ahc, devinfo,
				    XS_RESET, "Bus Device Reset Received",
				    /*verbose_level*/0);
		restart_sequencer(ahc);
		done = MSGLOOP_TERMINATED;
		break;
	case MSG_ABORT_TAG:
	case MSG_ABORT:
	case MSG_CLEAR_QUEUE:
		/* Target mode messages */
		if (devinfo->role != ROLE_TARGET) {
			reject = TRUE;
			break;
		}
#if AHC_TARGET_MODE
		ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       devinfo->lun,
			       ahc->msgin_buf[0] == MSG_ABORT_TAG ? SCB_LIST_NULL
			       : ahc_inb(ahc, INITIATOR_TAG),
				ROLE_TARGET, XS_DRIVER_STUFFUP);
d3897 11
a3907 3
		tstate = ahc->enabled_targets[devinfo->our_scsiid];
		if (tstate != NULL) {
			struct tmode_lstate* lstate;
d3909 11
a3919 18
			lstate = tstate->enabled_luns[devinfo->lun];
			if (lstate != NULL) {
				ahc_queue_lstate_event(ahc, lstate,
						       devinfo->our_scsiid,
						       ahc->msgin_buf[0],
						       /*arg*/0);
				ahc_send_lstate_events(ahc, lstate);
			}
		}
		done = MSGLOOP_MSGCOMPLETE;
#else
		panic("ahc: got target mode message");
#endif
		break;
	case MSG_TERM_IO_PROC:
	default:
		reject = TRUE;
		break;
d3922 7
a3928 9
	if (reject) {
		/*
		 * Setup to reject the message.
		 */
		ahc->msgout_index = 0;
		ahc->msgout_len = 1;
		ahc->msgout_buf[0] = MSG_MESSAGE_REJECT;
		done = MSGLOOP_MSGCOMPLETE;
		response = TRUE;
d3931 9
a3939 3
	if (done != MSGLOOP_IN_PROG && !response)
		/* Clear the outgoing message buffer */
		ahc->msgout_len = 0;
d3941 12
a3952 2
	return (done);
}
d3954 1
a3954 7
STATIC void
ahc_handle_ign_wide_residue(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	u_int scb_index;
	struct scb *scb;
d3956 6
a3961 17
	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = &ahc->scb_data->scbarray[scb_index];
	if ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0
	 || !(scb->xs->flags & SCSI_DATA_IN)) {
		/*
		 * Ignore the message if we haven't
		 * seen an appropriate data phase yet.
		 */
	} else {
		/*
		 * If the residual occurred on the last
		 * transfer and the transfer request was
		 * expected to end on an odd count, do
		 * nothing.  Otherwise, subtract a byte
		 * and update the residual count accordingly.
		 */
		u_int resid_sgcnt;
d3963 1
a3963 17
		resid_sgcnt = ahc_inb(ahc, SCB_RESID_SGCNT);
		if (resid_sgcnt == 0
		 && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {
			/*
			 * If the residual occurred on the last
			 * transfer and the transfer request was
			 * expected to end on an odd count, do
			 * nothing.
			 */
		} else {
			u_int data_cnt;
			u_int data_addr;
			u_int sg_index;

			data_cnt = (ahc_inb(ahc, SCB_RESID_DCNT + 2) << 16)
				 | (ahc_inb(ahc, SCB_RESID_DCNT + 1) << 8)
				 | (ahc_inb(ahc, SCB_RESID_DCNT));
d3965 5
a3969 4
			data_addr = (ahc_inb(ahc, SHADDR + 3) << 24)
				  | (ahc_inb(ahc, SHADDR + 2) << 16)
				  | (ahc_inb(ahc, SHADDR + 1) << 8)
				  | (ahc_inb(ahc, SHADDR));
d3971 1
a3971 2
			data_cnt += 1;
			data_addr -= 1;
d3973 11
a3983 1
			sg_index = scb->sg_count - resid_sgcnt;
d3985 1
a3985 22
			if (sg_index != 0
			 && (le32toh(scb->sg_list[sg_index].len) < data_cnt)) {
				u_int32_t sg_addr;

				sg_index--;
				data_cnt = 1;
				data_addr = le32toh(scb->sg_list[sg_index].addr)
					  + le32toh(scb->sg_list[sg_index].len)
					  - 1;
				
				/*
				 * The physical address base points to the
				 * second entry as it is always used for
				 * calculating the "next S/G pointer".
				 */
				sg_addr = scb->sg_list_phys
					+ (sg_index* sizeof(*scb->sg_list));
				ahc_outb(ahc, SG_NEXT + 3, sg_addr >> 24);
				ahc_outb(ahc, SG_NEXT + 2, sg_addr >> 16);
				ahc_outb(ahc, SG_NEXT + 1, sg_addr >> 8);
				ahc_outb(ahc, SG_NEXT, sg_addr);
			}
d3987 3
a3989 3
			ahc_outb(ahc, SCB_RESID_DCNT + 2, data_cnt >> 16);
			ahc_outb(ahc, SCB_RESID_DCNT + 1, data_cnt >> 8);
			ahc_outb(ahc, SCB_RESID_DCNT, data_cnt);
d3991 5
a3995 5
			ahc_outb(ahc, SHADDR + 3, data_addr >> 24);
			ahc_outb(ahc, SHADDR + 2, data_addr >> 16);
			ahc_outb(ahc, SHADDR + 1, data_addr >> 8);
			ahc_outb(ahc, SHADDR, data_addr);
		}
a3996 1
}
d3998 5
a4002 9
STATIC void
ahc_handle_devreset(ahc, devinfo, status, message, verbose_level)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	int status;
	char *message;
	int verbose_level;
{
	int found;
a4003 4
	found = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       ALL_LUNS, SCB_LIST_NULL, devinfo->role,
			       status);
	
d4005 1
a4005 3
	 * Go back to async/narrow transfers and renegotiate.
	 * ahc_set_width and ahc_set_syncrate can cope with NULL
	 * paths.
d4007 5
a4011 10
	ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
		      AHC_TRANS_CUR, /*paused*/TRUE, /*done*/FALSE);
	ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,
			 /*period*/0, /*offset*/0, AHC_TRANS_CUR,
			 /*paused*/TRUE, /*done*/FALSE);
	
	if (message != NULL
	 && (verbose_level <= bootverbose))
		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahc_name(ahc),
		       message, devinfo->channel, devinfo->target, found);
d4014 2
a4015 9
/*
 * We have an scb which has been processed by the
 * adaptor, now we look to see how the operation
 * went.
 */
STATIC void
ahc_done(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
d4017 1
a4017 4
	struct scsi_xfer *xs = scb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	int requeue = 0;
	int target;
d4019 3
a4021 3
	SC_DEBUG(xs->sc_link, SDEV_DB2, ("ahc_done\n"));
	
	LIST_REMOVE(scb, pend_links);
d4023 5
a4027 1
	timeout_del(&scb->xs->stimeout);
d4029 10
a4038 5
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWCMDS) {
		sc_print_addr(sc_link);
		printf("ahc_done opcode %d tag %x\n", xs->cmdstore.opcode,
		    scb->hscb->tag);
d4040 23
a4062 14
#endif
	
	target = sc_link->target;
	
	if (xs->datalen) {
		int op;
	
		if ((xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_POSTREAD;
		else
			op = BUS_DMASYNC_POSTWRITE;
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
		    0, scb->dmamap->dm_mapsize, op);
		bus_dmamap_unload(ahc->sc_dmat, scb->dmamap);
d4064 3
d4068 10
a4077 7
	/*
	 * Unbusy this target/channel/lun.
	 * XXX if we are holding two commands per lun, 
	 *     send the next command.
	 */
	if (!(scb->hscb->control & TAG_ENB))
		ahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);
d4079 4
a4082 5
	/*
	 * If the recovery SCB completes, we have to be
	 * out of our timeout.
	 */
	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
d4084 1
a4084 1
		struct	scb *scbp;
d4086 1
a4086 8
		/*
		 * We were able to complete the command successfully,
		 * so reinstate the timeouts for all other pending
		 * commands.
		 */
		scbp = ahc->pending_scbs.lh_first;
		while (scbp != NULL) {
			struct scsi_xfer *txs = scbp->xs;
d4088 2
a4089 5
			if (!(txs->flags & SCSI_POLL))
				timeout_add(&scbp->xs->stimeout,
				    (scbp->xs->timeout * hz)/1000);
			scbp = LIST_NEXT(scbp, pend_links);
		}
d4091 6
a4096 12
		/*
		 * Ensure that we didn't put a second instance of this
		 * SCB into the QINFIFO.
		 */
		ahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				   SCB_LUN(scb), scb->hscb->tag,
				   ROLE_INITIATOR, /*status*/0,
				   SEARCH_REMOVE);
		if (xs->error != XS_NOERROR)
			ahcsetccbstatus(xs, XS_TIMEOUT);
		sc_print_addr(xs->sc_link);
		printf("no longer in timeout, status = %x\n", xs->status);
d4099 8
a4106 26
	if (xs->error != XS_NOERROR) {
		/* Don't clobber any existing error state */
	} else if ((scb->flags & SCB_SENSE) != 0) {
		/*
		 * We performed autosense retrieval.
		 *
		 * bzero the sense data before having
		 * the drive fill it.  The SCSI spec mandates
		 * that any untransfered data should be
		 * assumed to be zero.  Complete the 'bounce'
		 * of sense information through buffers accessible
		 * via bus-space by copying it into the clients
		 * csio.
		 */
		bzero(&xs->sense, sizeof(struct scsi_sense));
		bcopy(&ahc->scb_data->sense[scb->hscb->tag],
		      &xs->sense, le32toh(scb->sg_list->len));
		xs->error = XS_SENSE;
	}
	if (scb->flags & SCB_FREEZE_QUEUE) {
		ahc->devqueue_blocked[target]--;
		scb->flags &= ~SCB_FREEZE_QUEUE;
	}
	
	requeue = scb->flags & SCB_REQUEUE;
	ahcfreescb(ahc, scb);
d4108 13
a4120 1
	if (requeue) {
d4122 2
a4123 2
		 * Re-insert at the front of the private queue to
		 * preserve order.
d4125 17
a4141 12
		int s;

		s = splbio();
		/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */
		ahc_list_insert_head(ahc, xs);
		splx(s);
	} else {
		if (((xs->flags & SCSI_POLL) != 0) &&
		    (xs->error == XS_NOERROR))
			ahc_check_tags(ahc, xs);
		xs->flags |= ITSDONE;
		scsi_done(xs);
a4142 11

	/*
	 * If there are entries in the software queue, try to
	 * run the first one.  We should be more or less guaranteed
	 * to succeed, since we just freed an SCB.
	 *
	 * NOTE: ahc_scsi_cmd() relies on our calling it with
	 * the first entry in the queue.
	 */
	if ((xs = ahc->sc_xxxq.lh_first) != NULL)
		(void) ahc_scsi_cmd(xs);
d4144 1
d4146 2
a4147 6
/*
 * Determine the number of SCBs available on the controller
 */
int
ahc_probe_scbs(ahc)
	struct ahc_softc *ahc;
d4149 12
a4160 1
	int i;
d4162 15
a4176 8
	for (i = 0; i < AHC_SCB_MAX; i++) {
		ahc_outb(ahc, SCBPTR, i);
		ahc_outb(ahc, SCB_CONTROL, i);
		if (ahc_inb(ahc, SCB_CONTROL) != i)
			break;
		ahc_outb(ahc, SCBPTR, 0);
		if (ahc_inb(ahc, SCB_CONTROL) != 0)
			break;
d4178 7
a4184 2
	
	return (i);
d4191 1
a4191 2
ahc_init(ahc)
	struct ahc_softc *ahc;
d4193 15
a4207 11
	int	  max_targ = 15;
	int	  i;
	int	  term;
	u_int	  scsi_conf;
	u_int	  scsiseq_template;
	u_int	  ultraenb;
	u_int	  discenable;
	u_int	  tagenable;
	size_t	  driver_data_size;
	u_int32_t physaddr;
	struct scb_data *scb_data = NULL;
d4227 1
a4227 10

	if (ahc->scb_data == NULL) {
		scb_data = malloc(sizeof (struct scb_data), M_DEVBUF, M_NOWAIT);
		if (scb_data == NULL) {
			printf("%s: cannot malloc scb_data!\n", ahc_name(ahc));
			return (ENOMEM);
		}
		bzero(scb_data, sizeof(struct scb_data));
		ahc->scb_data = scb_data;
	}
d4237 25
a4261 2
	ahc->flags |= AHC_INITIATORMODE;
	
d4265 9
a4273 9
	 * roles, we need to allocate space for the qinfifo, qoutfifo,
	 * and untagged_scb arrays each of which are composed of 256
	 * 1 byte elements.  When providing for the target mode role,
	 * we additionally must provide space for the incoming target
	 * command fifo.
	 */
	driver_data_size = 3 * 256 * sizeof(u_int8_t);

	if (ahc_createdmamem(ahc, driver_data_size, 
d4280 25
d4306 1
a4306 4
	/* Allocate SCB data now that sc_dmat is initialized */
	if (ahc->scb_data->maxhscbs == 0)
		if (ahcinitscbdata(ahc) != 0)
			return (ENOMEM);
d4308 19
a4327 4
	ahc->untagged_scbs = &ahc->qinfifo[256];
	/* There are no untagged SCBs active yet. */
	for (i = 0; i < 256; i++)
		ahc->untagged_scbs[i] = SCB_LIST_NULL;
d4329 6
a4334 3
	/* All of our queues are empty */
	for (i = 0; i < 256; i++)
		ahc->qoutfifo[i] = SCB_LIST_NULL;
a4335 3
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
		 0, driver_data_size, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	
d4342 1
a4342 1
		printf("%s: unable to allocate tmode_tstate.  "
d4344 1
a4344 1
		return (-1);
d4349 1
a4349 1
			printf("%s: unable to allocate tmode_tstate.  "
d4351 1
a4351 10
			return (-1);
		}
 		printf("Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, ",
		       ahc->our_id, ahc->our_id_b,
		       ahc->flags & AHC_CHANNEL_B_PRIMARY? 'B': 'A');
	} else {
		if ((ahc->features & AHC_WIDE) != 0) {
			printf("Wide ");
		} else {
			printf("Single ");
a4352 1
		printf("Channel %c, SCSI Id=%d, ", ahc->channel, ahc->our_id);
d4356 1
a4359 1
		printf("%d/%d SCBs\n", ahc->scb_data->maxhscbs, AHC_SCB_MAX);
a4361 1
		printf("%d SCBs\n", ahc->scb_data->maxhscbs);
d4375 1
a4375 1
	/* Set the SCSI Id,SXFRCTL0,SXFRCTL1, and SIMODE1, for both channels*/
d4382 1
d4384 1
a4384 4
		if ((ahc->features & AHC_ULTRA2) != 0)
			ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id_b);
		else
			ahc_outb(ahc, SCSIID, ahc->our_id_b);
d4387 3
a4389 1
					|term|ENSTIMER|ACTNEGEN);
d4394 1
a4394 1
		 && (ahc->flags & AHC_INITIATORMODE) != 0)
d4400 1
d4408 1
a4408 1
				|term
d4410 2
d4416 1
a4416 1
	 && (ahc->flags & AHC_INITIATORMODE) != 0)
d4448 1
a4448 1
		struct tmode_tstate *tstate;
d4464 1
a4464 1
		bzero(tinfo, sizeof(*tinfo));
d4477 1
a4477 1
			u_int16_t mask;
d4498 3
d4510 4
d4515 6
d4529 2
d4534 9
a4543 1
		tinfo->goal = tinfo->user; /* force negotiation */
a4544 2
		tstate->discenable = discenable;
		tstate->tagenable = 0; /* Wait until the XPT says its okay */
d4549 29
d4588 4
a4591 11
	ahc_outb(ahc, SCBID_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 3, (physaddr >> 24) & 0xFF);

	/* Target mode incomding command fifo */
	physaddr += 3 * 256 * sizeof(u_int8_t);
	ahc_outb(ahc, TMODE_CMDADDR, physaddr & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 3, (physaddr >> 24) & 0xFF);
a4611 10
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC)
		printf("DISCENABLE == 0x%x\nULTRAENB == 0x%x\n",
		    discenable, ultraenb);
#endif

	/* Don't have any special messages to send to targets */
	ahc_outb(ahc, TARGET_MSG_REQUEST, 0);
	ahc_outb(ahc, TARGET_MSG_REQUEST + 1, 0);

a4622 1

d4634 1
a4634 1
	 * If we are a target, we'll enable select in operations once
d4638 1
a4638 1
	if ((ahc->flags & AHC_INITIATORMODE) != 0)
d4652 17
a4668 2
	/* We have to wait until after any system dumps... */
	shutdownhook_establish(ahc_shutdown, ahc);
d4672 17
d4690 5
a4694 4
 * Routines to manage a scsi_xfer into the software queue.  
 * We overload xs->free_list to to ensure we don't run into a queue 
 * resource shortage, and keep a pointer to the last entry around 
 * to make insertion O(C).
d4696 2
a4697 5
STATIC INLINE void
ahc_list_insert_before(ahc, xs, next_xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	struct scsi_xfer *next_xs;
d4699 2
a4700 1
	LIST_INSERT_BEFORE(xs, next_xs, free_list); 
d4702 17
d4721 2
a4722 4
STATIC INLINE void
ahc_list_insert_head(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
d4724 62
a4785 5
	if (ahc->sc_xxxq.lh_first == NULL)
		ahc->sc_xxxqlast = xs;
	LIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);
	return;
}
d4787 3
a4789 9
STATIC INLINE void
ahc_list_insert_tail(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	if (ahc->sc_xxxq.lh_first == NULL){
		ahc->sc_xxxqlast = xs;
		LIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);
		return;
a4790 3
	LIST_INSERT_AFTER(ahc->sc_xxxqlast, xs, free_list);
	ahc->sc_xxxqlast = xs;
}
d4792 10
a4801 12
STATIC INLINE void
ahc_list_remove(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	struct scsi_xfer *lxs;
	if (xs == ahc->sc_xxxqlast) {
		lxs = ahc->sc_xxxq.lh_first;
		while (lxs != NULL) {
			if (LIST_NEXT(lxs, free_list) == ahc->sc_xxxqlast) {
                                ahc->sc_xxxqlast = lxs;
				break;
a4802 1
			lxs = LIST_NEXT(xs, free_list);
d4805 2
a4806 4
	
	LIST_REMOVE(xs, free_list);
	if (ahc->sc_xxxq.lh_first == NULL)
		ahc->sc_xxxqlast = NULL;
d4809 2
a4810 4
STATIC INLINE struct scsi_xfer *
ahc_list_next(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
d4812 2
a4813 2
	return(LIST_NEXT(xs, free_list));
}
d4815 1
a4815 8
/*
 * Pick the first xs for a non-blocked target.
 */
STATIC INLINE struct scsi_xfer *
ahc_first_xs(struct ahc_softc *ahc)
{
	int target;
	struct scsi_xfer *xs = ahc->sc_xxxq.lh_first;
d4817 1
a4817 2
	if (ahc->queue_blocked)
        	return NULL;
d4819 12
a4830 7
	while (xs != NULL) {
		target = xs->sc_link->target;
		if (ahc->devqueue_blocked[target] == 0 &&
		    ahc_index_busy_tcl(ahc, XS_TCL(ahc, xs), FALSE) ==
			SCB_LIST_NULL)
			break;
		xs = LIST_NEXT(xs, free_list);
d4832 11
d4844 4
a4847 2
	return xs;
}
d4849 2
a4850 16
STATIC int32_t
ahc_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_xfer *first_xs, *next_xs = NULL;
	struct ahc_softc *ahc;
	struct scb *scb;
	struct hardware_scb *hscb;	
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
	u_int target_id;
	u_int our_id;
	char channel;
	int s, tcl;
	u_int16_t mask;
	int dontqueue = 0, fromqueue = 0;
d4852 6
a4857 2
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("ahc_scsi_cmd\n"));
	ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
d4859 2
a4860 2
	/* must protect the queue */
	s = splbio();
d4862 2
a4863 12
	if (xs == ahc->sc_xxxq.lh_first) {
		/*
		 * Called from ahc_done. Calling with the first entry in
		 * the queue is really just a way of seeing where we're
		 * called from. Now, find the first eligible SCB to send,
		 * e.g. one which will be accepted immediately.
		 */

		if (ahc->queue_blocked) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}
d4865 3
a4867 5
		xs = ahc_first_xs(ahc);
		if (xs == NULL) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}
d4869 3
a4871 4
		next_xs = ahc_list_next(ahc, xs);
		ahc_list_remove(ahc, xs);
		fromqueue = 1;
		goto get_scb;
d4874 7
a4880 8
	/* determine safety of software queueing */
	dontqueue = xs->flags & SCSI_POLL;
	
	/*
	 * If no new requests are accepted, just insert into the
	 * private queue to wait for our turn.
	 */
	tcl = XS_TCL(ahc, xs);
d4882 3
a4884 8
	if (ahc->queue_blocked ||
	    ahc->devqueue_blocked[xs->sc_link->target] ||
	    (!ahc_istagged_device(ahc, xs, 0) &&
	     ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)) {
		if (dontqueue) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return TRY_AGAIN_LATER;
a4885 3
		ahc_list_insert_tail(ahc, xs);
		splx(s);
		return SUCCESSFULLY_QUEUED;
d4887 2
d4890 10
a4899 1
	first_xs = ahc_first_xs(ahc);
d4901 11
a4911 2
	/* determine safety of software queueing */
	dontqueue = xs->flags & SCSI_POLL;
d4913 2
a4914 14
	/*
	 * Handle situations where there's already entries in the
	 * queue.
	 */
	if (first_xs != NULL) {
		/*
		 * If we can't queue, we have to abort, since
		 * we have to preserve order.
		 */
		if (dontqueue) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
d4916 4
a4919 8
		/*
		 * Swap with the first queue entry.
		 */
		ahc_list_insert_tail(ahc, xs);
		xs = first_xs;
		next_xs = ahc_list_next(ahc, xs);
		ahc_list_remove(ahc, xs);
		fromqueue = 1;
d4921 10
d4932 1
d4934 4
a4937 1
get_scb:
d4939 12
a4950 2
	target_id = xs->sc_link->target;
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
d4952 9
a4960 4
	/*
	 * get an scb to use.
	 */
	if ((scb = ahcgetscb(ahc)) == NULL) {
d4962 8
a4969 5
		if (dontqueue) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
d4971 14
a4984 9
		/*
		 * If we were pulled off the queue, put ourselves
		 * back to where we came from, otherwise tack ourselves
		 * onto the end.
		 */
		if (fromqueue && next_xs != NULL)
			ahc_list_insert_before(ahc, xs, next_xs);
		else
			ahc_list_insert_tail(ahc, xs);
d4986 2
a4987 3
		splx(s);
		return (SUCCESSFULLY_QUEUED);
	}
d4989 6
a4994 1
	tcl = XS_TCL(ahc, xs);
d4996 3
a4998 5
#ifdef DIAGNOSTIC
	if (!ahc_istagged_device(ahc, xs, 0) &&
	    ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)
		panic("ahc: queuing for busy target");
#endif
d5000 3
a5002 4
	scb->xs = xs;
	hscb = scb->hscb;
	hscb->tcl = tcl;
	timeout_set(&xs->stimeout, ahc_timeout, scb);
d5004 2
a5005 4
	if (ahc_istagged_device(ahc, xs, 0))
		scb->hscb->control |= TAG_ENB;
	else
		ahc_busy_tcl(ahc, scb);
d5007 4
a5010 12
	splx(s);
 
	channel = SIM_CHANNEL(ahc, xs->sc_link);
	if (ahc->inited_channels[channel - 'A'] == 0) {
		if ((channel == 'A' && (ahc->flags & AHC_RESET_BUS_A)) ||
		    (channel == 'B' && (ahc->flags & AHC_RESET_BUS_B))) {
			s = splbio();
			ahc_reset_channel(ahc, channel, TRUE);
			splx(s);
		}
		ahc->inited_channels[channel - 'A'] = 1;
	}
d5012 4
a5015 3
	/*
	 * Put all the arguments for the xfer in the scb
	 */
d5017 11
a5027 5
	mask = SCB_TARGET_MASK(scb);
	tinfo = ahc_fetch_transinfo(ahc, SIM_CHANNEL(ahc, xs->sc_link), our_id,
				    target_id, &tstate);
	if (ahc->inited_targets[target_id] == 0) {
		struct ahc_devinfo devinfo;
d5029 10
a5038 8
		s = splbio();
		ahc_compile_devinfo(&devinfo, our_id, target_id,
		    xs->sc_link->lun, SIM_CHANNEL(ahc, xs->sc_link),
		    ROLE_INITIATOR);
		ahc_update_target_msg_request(ahc, &devinfo, tinfo, TRUE,
		    FALSE);
		ahc->inited_targets[target_id] = 1;
		splx(s);
d5040 4
d5045 5
a5049 7
	hscb->scsirate = tinfo->scsirate;
	hscb->scsioffset = tinfo->current.offset;
	if ((tstate->ultraenb & mask) != 0)
		hscb->control |= ULTRAENB;
		
	if ((tstate->discenable & mask) != 0)
		hscb->control |= DISCENB;
d5051 7
a5057 8
	if (xs->flags & SCSI_RESET) {
		hscb->cmdpointer = NULL;
		scb->flags |= SCB_DEVICE_RESET;
		hscb->control |= MK_MESSAGE;
		return ahc_execute_scb(scb, NULL, 0);
	}

	return ahc_setup_data(ahc, xs, scb);
d5060 4
a5063 5
STATIC int
ahc_execute_scb(arg, dm_segs, nsegments)
	void *arg;
	bus_dma_segment_t *dm_segs;
	int nsegments;
d5065 11
a5075 4
	struct	 scb *scb;
	struct scsi_xfer *xs;
	struct	 ahc_softc *ahc;
	int	 s;
d5077 19
a5095 3
	scb = (struct scb *)arg;
	xs = scb->xs;
	ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
d5097 6
d5104 7
a5110 4
	if (nsegments != 0) {
		struct ahc_dma_seg *sg;
		bus_dma_segment_t *end_seg;
		int op;
d5112 10
a5121 1
		end_seg = dm_segs + nsegments;
d5123 22
a5144 12
		/* Copy the first SG into the data pointer area */
		scb->hscb->data = dm_segs->ds_addr;
		scb->hscb->datalen = dm_segs->ds_len;

		/* Copy the segments into our SG list */
		sg = scb->sg_list;
		while (dm_segs < end_seg) {
			sg->addr = dm_segs->ds_addr;
			sg->len = dm_segs->ds_len;
			ahc_swap_sg(sg);
			sg++;
			dm_segs++;
d5146 2
d5149 2
a5150 8
		/* Note where to find the SG entries in bus space */
		scb->hscb->SG_pointer = scb->sg_list_phys;
		if ((scb->xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_PREREAD;
		else
			op = BUS_DMASYNC_PREWRITE;
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
		    0, scb->dmamap->dm_mapsize, op);
d5152 1
a5152 3
		scb->hscb->SG_pointer = 0;
		scb->hscb->data = 0;
		scb->hscb->datalen = 0;
a5153 2
	
	scb->sg_count = scb->hscb->SG_count = nsegments;
d5155 42
a5196 1
	s = splbio();
d5199 1
a5199 2
	 * Last time we need to check if this SCB needs to
	 * be aborted.
d5201 3
a5203 9
	if (xs->flags & ITSDONE) {
		if (!ahc_istagged_device(ahc, xs, 0))
			ahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);
		if (nsegments != 0)
			bus_dmamap_unload(ahc->sc_dmat, scb->dmamap);
		ahcfreescb(ahc, scb);
		splx(s);
		return (COMPLETE);
	}
d5205 2
a5206 4
#ifdef DIAGNOSTIC
	if (scb->sg_count > 255)
		panic("ahc bad sg_count");
#endif
d5208 26
a5233 22
	ahc_swap_hscb(scb->hscb);
		
	LIST_INSERT_HEAD(&ahc->pending_scbs, scb, pend_links);

	scb->flags |= SCB_ACTIVE;

	if (!(xs->flags & SCSI_POLL))
		timeout_add(&xs->stimeout, (xs->timeout * hz) / 1000);

	if ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {
#if 0
		printf("Continueing Immediate Command %d:%d\n",
		       xs->sc_link->target,
		       xs->sc_link->lun);
#endif
		pause_sequencer(ahc);
		if ((ahc->flags & AHC_PAGESCBS) == 0)
			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
		ahc_outb(ahc, SCB_TAG, scb->hscb->tag);
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
		unpause_sequencer(ahc);
	} else {
d5235 20
a5254 7
		ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;

		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
		    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
		
		if ((ahc->features & AHC_QUEUE_REGS) != 0) {
			ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
d5256 3
a5258 3
			pause_sequencer(ahc);
			ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
			unpause_sequencer(ahc);
d5261 1
a5262 15
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWCMDS) {
		sc_print_addr(xs->sc_link);
		printf("opcode %d tag %x len %d flags %x control %x fpos %u"
		    " rate %x\n",
		    xs->cmdstore.opcode, scb->hscb->tag, scb->hscb->datalen,
		    scb->flags, scb->hscb->control, ahc->qinfifonext,
		    scb->hscb->scsirate);
	}
#endif

	if (!(xs->flags & SCSI_POLL)) {
		splx(s);
		return (SUCCESSFULLY_QUEUED);
	}
d5264 1
a5264 1
	 * If we can't use interrupts, poll for completion
d5266 10
a5275 7
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("cmd_poll\n"));
	do {
		if (ahc_poll(ahc, xs->timeout)) {
			if (!(xs->flags & SCSI_SILENT))
				printf("cmd fail\n");
			ahc_timeout(scb);
			break;
d5277 3
a5279 4
	} while (!(xs->flags & ITSDONE));
	splx(s);
	return (COMPLETE);
}
d5281 3
a5283 10
STATIC int
ahc_poll(ahc, wait)
	struct   ahc_softc *ahc;
	int   wait;	/* in msec */
{
	while (--wait) {
		DELAY(1000);
		if (ahc_inb(ahc, INTSTAT) & INT_PEND)
			break;
	}
d5285 3
a5287 8
	if (wait == 0) {
		printf("%s: board is not responding\n", ahc_name(ahc));
		return (EIO);
	}
		
	ahc_intr((void *)ahc);
	return (0);
}
d5289 2
a5290 14
STATIC int
ahc_setup_data(ahc, xs, scb)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	struct scb *scb;
{
	struct hardware_scb *hscb;
	
	hscb = scb->hscb;
	xs->resid = xs->status = 0;
	
	hscb->cmdlen = xs->cmdlen;
	bcopy(xs->cmd, hscb->cmdstore, xs->cmdlen);
	hscb->cmdpointer = hscb->cmdstore_busaddr;
d5292 11
a5302 3
	/* Only use S/G if there is a transfer */
	if (xs->datalen) {
		int error;
d5304 33
a5336 16
		error = bus_dmamap_load(ahc->sc_dmat,
			    scb->dmamap, xs->data,
			    xs->datalen, NULL,
			    (xs->flags & SCSI_NOSLEEP) ?
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			if (!ahc_istagged_device(ahc, xs, 0))
				ahc_index_busy_tcl(ahc, hscb->tcl, TRUE);
			return (TRY_AGAIN_LATER);	/* XXX fvdl */
		}
		error = ahc_execute_scb(scb,
		    scb->dmamap->dm_segs,
		    scb->dmamap->dm_nsegs);
		return error;
	} else {
		return ahc_execute_scb(scb, NULL, 0);
a5337 1
}
d5339 3
a5341 16
STATIC void
ahc_freeze_devq(ahc, sc_link)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
{
	int	target;
	char	channel;
	int	lun;

	target = sc_link->target;
	lun = sc_link->lun;
	channel = SIM_CHANNEL(ahc, sc_link);
	
	ahc_search_qinfifo(ahc, target, channel, lun,
			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
			   SCB_REQUEUE, SEARCH_COMPLETE);
d5344 4
a5347 3
STATIC void
ahcallocscbs(ahc)
	struct ahc_softc *ahc;
d5349 5
a5353 8
	struct scb_data *scb_data;
	struct scb *next_scb;
	struct sg_map_node *sg_map;
	bus_addr_t physaddr;
	struct ahc_dma_seg *segs;
	int newcount;
	int i;
	int dma_flags = 0;
d5355 3
a5357 4
	scb_data = ahc->scb_data;
	if (scb_data->numscbs >= AHC_SCB_MAX)
		/* Can't allocate any more */
		return;
d5359 6
a5364 1
	next_scb = &scb_data->scbarray[scb_data->numscbs];
d5366 2
a5367 1
	sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);
d5369 9
a5377 12
	if (sg_map == NULL)
		return;
	bzero(sg_map, sizeof(struct sg_map_node));
	
	if (ahc_createdmamem(ahc, PAGE_SIZE, &sg_map->sg_dmamap,
	    (caddr_t *)&sg_map->sg_vaddr, &sg_map->sg_physaddr,
	    &sg_map->sg_dmasegs, &sg_map->sg_nseg, "SG space") < 0) {
		free(sg_map, M_DEVBUF);
		return;
	}
	
	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);
d5379 22
a5400 39
	segs = sg_map->sg_vaddr;
	physaddr = sg_map->sg_physaddr;

	newcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));

	for (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {
		int error;

		next_scb->sg_list = segs;
		/*
		 * The sequencer always starts with the second entry.
		 * The first entry is embedded in the scb.
		 */
		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
		next_scb->flags = SCB_FREE;
		
		/* set up AHA-284x right. */
		dma_flags = ((ahc->chip & AHC_VL) !=0) ? 
			BUS_DMA_NOWAIT|ISABUS_DMA_32BIT :
			BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW;
		
		error = bus_dmamap_create(ahc->sc_dmat,
				 AHC_MAXTRANSFER_SIZE, AHC_NSEG, MAXBSIZE, 0,
				 dma_flags, &next_scb->dmamap);
		if (error !=0) 
			break;

		next_scb->hscb = &scb_data->hscbs[scb_data->numscbs];
		next_scb->hscb->tag = ahc->scb_data->numscbs;
		next_scb->hscb->cmdstore_busaddr = 
		    ahc_hscb_busaddr(ahc, next_scb->hscb->tag)
		  + offsetof(struct hardware_scb, cmdstore);
		next_scb->hscb->cmdstore_busaddr =
		    htole32(next_scb->hscb->cmdstore_busaddr);
		SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, next_scb, links);
		segs += AHC_NSEG;
		physaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));
		next_scb++;
		ahc->scb_data->numscbs++;
d5402 3
d5407 6
a5412 4
#ifdef AHC_DUMP_SEQ
STATIC void
ahc_dumpseq(ahc)
	struct ahc_softc* ahc;
d5414 6
a5419 2
	int i;
	int max_prog;
d5421 1
a5421 6
	if ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)
		max_prog = 448;
	else if ((ahc->features & AHC_ULTRA2) != 0)
		max_prog = 768;
	else
		max_prog = 512;
d5423 5
a5427 5
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	for (i = 0; i < max_prog; i++) {
		u_int8_t ins_bytes[4];
d5429 1
a5429 6
		ahc_insb(ahc, SEQRAM, ins_bytes, 4);
		printf("0x%08x\n", ins_bytes[0] << 24
				 | ins_bytes[1] << 16
				 | ins_bytes[2] << 8
				 | ins_bytes[3]);
	}
a5430 1
#endif
d5432 7
a5438 3
STATIC void
ahc_loadseq(ahc)
	struct ahc_softc* ahc;
d5440 5
a5444 18
	struct patch *cur_patch;
	int i;
	int downloaded;
	int skip_addr;
	u_int8_t download_consts[4];

	/* Setup downloadable constant table */
#if 0
	/* No downloaded constants are currently defined. */
	download_consts[TMODE_NUMCMDS] = ahc->num_targetcmds;
#endif

	cur_patch = patches;
	downloaded = 0;
	skip_addr = 0;
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
d5446 3
a5448 10
	for (i = 0; i < sizeof(seqprog)/4; i++) {
		if (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {
			/*
			 * Don't download this instruction as it
			 * is in a patch that was removed.
			 */
                        continue;
		}
		ahc_download_instr(ahc, i, download_consts);
		downloaded++;
d5450 1
a5450 2
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);
	restart_sequencer(ahc);
d5452 8
a5459 3
	if (bootverbose)
		printf(" %d instructions downloaded\n", downloaded);
}
d5461 7
a5467 10
STATIC int
ahc_check_patch(ahc, start_patch, start_instr,skip_addr)
	struct ahc_softc *ahc;
	struct patch **start_patch;
	int start_instr;
	int *skip_addr;
{
	struct	patch *cur_patch;
	struct	patch *last_patch;
	int	num_patches;
d5469 2
a5470 3
	num_patches = sizeof(patches)/sizeof(struct patch);
	last_patch = &patches[num_patches];
	cur_patch = *start_patch;
d5472 1
a5472 1
	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
d5474 4
a5477 1
		if (cur_patch->patch_func(ahc) == 0) {
d5479 12
a5490 10
			/* Start rejecting code */
			*skip_addr = start_instr + cur_patch->skip_instr;
			cur_patch += cur_patch->skip_patch;
		} else {
			/* Accepted this patch.  Advance to the next
			 * one and wait for our intruction pointer to
			 * hit this point.
			 */
			cur_patch++;
		}
d5493 5
a5497 6
	*start_patch = cur_patch;
	if (start_instr < *skip_addr)
		/* Still skipping */
		return (0);

	return (1);
d5500 10
a5509 5
STATIC void
ahc_download_instr(ahc, instrptr, dconsts)
	struct ahc_softc *ahc;
	int instrptr;
	u_int8_t *dconsts;
d5511 15
a5525 4
	union	ins_formats instr;
	struct	ins_format1 *fmt1_ins;
	struct	ins_format3 *fmt3_ins;
	u_int	opcode;
d5527 2
a5528 2
	/* Structure copy */
	instr = *(union ins_formats*)&seqprog[instrptr * 4];
d5530 2
a5531 1
	instr.integer = le32toh(instr.integer);
d5533 11
a5543 2
	fmt1_ins = &instr.format1;
	fmt3_ins = NULL;
d5545 1
a5545 17
	/* Pull the opcode */
	opcode = instr.format1.opcode;
	switch (opcode) {
	case AIC_OP_JMP:
	case AIC_OP_JC:
	case AIC_OP_JNC:
	case AIC_OP_CALL:
	case AIC_OP_JNE:
	case AIC_OP_JNZ:
	case AIC_OP_JE:
	case AIC_OP_JZ:
	{
		struct patch *cur_patch;
		int address_offset;
		u_int address;
		int skip_addr;
		int i;
d5547 14
a5560 5
		fmt3_ins = &instr.format3;
		address_offset = 0;
		address = fmt3_ins->address;
		cur_patch = patches;
		skip_addr = 0;
d5562 4
a5565 1
		for (i = 0; i < address;) {
d5567 9
a5575 1
			ahc_check_patch(ahc, &cur_patch, i, &skip_addr);
d5577 6
a5582 2
			if (skip_addr > i) {
				int end_addr;
d5584 6
a5589 10
				end_addr = MIN(address, skip_addr);
				address_offset += end_addr - i;
				i = skip_addr;
			} else {
				i++;
			}
		}
		address -= address_offset;
		fmt3_ins->address = address;
		/* FALLTHROUGH */
a5590 14
	case AIC_OP_OR:
	case AIC_OP_AND:
	case AIC_OP_XOR:
	case AIC_OP_ADD:
	case AIC_OP_ADC:
	case AIC_OP_BMOV:
		if (fmt1_ins->parity != 0) {
			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
		}
		fmt1_ins->parity = 0;
		/* FALLTHROUGH */
	case AIC_OP_ROL:
		if ((ahc->features & AHC_ULTRA2) != 0) {
			int i, count;
d5592 22
a5613 26
			/* Calculate odd parity for the instruction */
			for (i = 0, count = 0; i < 31; i++) {
				u_int32_t mask;

				mask = 0x01 << i;
				if ((instr.integer & mask) != 0)
					count++;
			}
			if ((count & 0x01) == 0)
				instr.format1.parity = 1;
		} else {
			/* Compress the instruction for older sequencers */
			if (fmt3_ins != NULL) {
				instr.integer =
					fmt3_ins->immediate
				      | (fmt3_ins->source << 8)
				      | (fmt3_ins->address << 16)
				      |	(fmt3_ins->opcode << 25);
			} else {
				instr.integer =
					fmt1_ins->immediate
				      | (fmt1_ins->source << 8)
				      | (fmt1_ins->destination << 16)
				      |	(fmt1_ins->ret << 24)
				      |	(fmt1_ins->opcode << 25);
			}
a5614 6
		instr.integer = htole32(instr.integer);
		ahc_outsb(ahc, SEQRAM, instr.bytes, 4);
		break;
	default:
		panic("Unknown opcode encountered in seq program");
		break;
d5616 4
d5622 2
a5623 4
STATIC void
ahc_set_recoveryscb(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
d5625 1
d5627 6
a5632 2
	if ((scb->flags & SCB_RECOVERY_SCB) == 0) {
		struct scb *scbp;
d5634 1
a5634 1
		scb->flags |= SCB_RECOVERY_SCB;
d5636 2
a5637 18
		/*
		 * Take all queued, but not sent SCBs out of the equation.
		 * Also ensure that no new CCBs are queued to us while we
		 * try to fix this problem.
		 */
		ahc->queue_blocked = 1;

		/*
		 * Go through all of our pending SCBs and remove
		 * any scheduled timeouts for them.  We will reschedule
		 * them after we've successfully fixed this problem.
		 */
		scbp = ahc->pending_scbs.lh_first;
		while (scbp != NULL) {
			timeout_del(&scbp->xs->stimeout);
			scbp = scbp->pend_links.le_next;
		}
	}
d5640 2
a5641 2
STATIC void
ahc_timeout(void *arg)
d5643 10
a5652 8
	struct	scb *scb;
	struct	ahc_softc *ahc;
	int	s, found;
	u_int	last_phase;
	int	target;
	int	lun;
	int	i;
	char	channel;
d5654 6
a5659 2
	scb = (struct scb *)arg; 
	ahc = (struct ahc_softc *)scb->xs->sc_link->adapter_softc;
d5661 2
a5662 1
	s = splbio();
d5665 3
a5667 4
	 * Ensure that the card doesn't do anything
	 * behind our back.  Also make sure that we
	 * didn't "just" miss an interrupt that would
	 * affect this timeout.
d5669 4
a5672 11
	do {
		ahc_intr(ahc);
		pause_sequencer(ahc);
	} while (ahc_inb(ahc, INTSTAT) & INT_PEND);

	if ((scb->flags & SCB_ACTIVE) == 0) {
		/* Previous timeout took care of me already */
		printf("Timedout SCB handled by another timeout\n");
		unpause_sequencer(ahc);
		splx(s);
		return;
d5674 1
a5675 6
	target = SCB_TARGET(scb);
	channel = SCB_CHANNEL(scb);
	lun = SCB_LUN(scb);

	sc_print_addr(scb->xs->sc_link);
	printf("SCB 0x%x - timed out ", scb->hscb->tag);
d5677 1
a5677 2
	 * Take a snapshot of the bus state and print out
	 * some information so we can track down driver bugs.
d5679 18
a5696 40
	last_phase = ahc_inb(ahc, LASTPHASE);

	for (i = 0; i < num_phases; i++) {
		if (last_phase == phase_table[i].phase)
			break;
	}
	printf("%s", phase_table[i].phasemsg);
  
	printf(", SEQADDR == 0x%x\n",
	       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
#if 0
	printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1));
	printf("SSTAT3 == 0x%x\n", ahc_inb(ahc, SSTAT3));
	printf("SCSIPHASE == 0x%x\n", ahc_inb(ahc, SCSIPHASE));
	printf("SCSIRATE == 0x%x\n", ahc_inb(ahc, SCSIRATE));
	printf("SCSIOFFSET == 0x%x\n", ahc_inb(ahc, SCSIOFFSET));
	printf("SEQ_FLAGS == 0x%x\n", ahc_inb(ahc, SEQ_FLAGS));
	printf("SCB_DATAPTR == 0x%x\n", ahc_inb(ahc, SCB_DATAPTR)
				      | ahc_inb(ahc, SCB_DATAPTR + 1) << 8
				      | ahc_inb(ahc, SCB_DATAPTR + 2) << 16
				      | ahc_inb(ahc, SCB_DATAPTR + 3) << 24);
	printf("SCB_DATACNT == 0x%x\n", ahc_inb(ahc, SCB_DATACNT)
				      | ahc_inb(ahc, SCB_DATACNT + 1) << 8
				      | ahc_inb(ahc, SCB_DATACNT + 2) << 16);
	printf("SCB_SGCOUNT == 0x%x\n", ahc_inb(ahc, SCB_SGCOUNT));
	printf("CCSCBCTL == 0x%x\n", ahc_inb(ahc, CCSCBCTL));
	printf("CCSCBCNT == 0x%x\n", ahc_inb(ahc, CCSCBCNT));
	printf("DFCNTRL == 0x%x\n", ahc_inb(ahc, DFCNTRL));
	printf("DFSTATUS == 0x%x\n", ahc_inb(ahc, DFSTATUS));
	printf("CCHCNT == 0x%x\n", ahc_inb(ahc, CCHCNT));
	if (scb->sg_count > 0) {
		for (i = 0; i < scb->sg_count; i++) {
			printf("sg[%d] - Addr 0x%x : Length %d\n",
			       i,
			       le32toh(scb->sg_list[i].addr),
			       le32toh(scb->sg_list[i].len));
		}
	}
#endif
	if (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {
d5698 3
a5700 2
		 * Been down this road before.
		 * Do a full bus reset.
d5702 6
a5707 5
bus_reset:
		ahcsetccbstatus(scb->xs, XS_TIMEOUT);
		found = ahc_reset_channel(ahc, channel, /*Initiate Reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), channel, found);
d5709 8
d5718 3
a5720 20
		 * If we are a target, transition to bus free and report
		 * the timeout.
		 * 
		 * The target/initiator that is holding up the bus may not
		 * be the same as the one that triggered this timeout
		 * (different commands have different timeout lengths).
		 * If the bus is idle and we are actiing as the initiator
		 * for this request, queue a BDR message to the timed out
		 * target.  Otherwise, if the timed out transaction is
		 * active:
		 *   Initiator transaction:
		 *	Stuff the message buffer with a BDR message and assert
		 *	ATN in the hopes that the target will let go of the bus
		 *	and go to the mesgout phase.  If this fails, we'll
		 *	get another timeout 2 seconds later which will attempt
		 *	a bus reset.
		 *
		 *   Target transaction:
		 *	Transition to BUS FREE and report the error.
		 *	It's good to be the target!
d5722 6
a5727 59
		u_int active_scb_index;

		active_scb_index = ahc_inb(ahc, SCB_TAG);

		if (last_phase != P_BUSFREE 
		  && (active_scb_index < ahc->scb_data->numscbs)) {
			struct scb *active_scb;

			/*
			 * If the active SCB is not from our device,
			 * assume that another device is hogging the bus
			 * and wait for it's timeout to expire before
			 * taking additional action.
			 */ 
			active_scb = &ahc->scb_data->scbarray[active_scb_index];
			if (active_scb->hscb->tcl != scb->hscb->tcl) {
				u_int	newtimeout;

				sc_print_addr(scb->xs->sc_link);
				printf("Other SCB Timeout%s",
			 	       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
				       ? " again\n" : "\n");
				scb->flags |= SCB_OTHERTCL_TIMEOUT;
				newtimeout = MAX(active_scb->xs->timeout,
						 scb->xs->timeout);
				timeout_add(&scb->xs->stimeout,
				    (newtimeout * hz) / 1000);
				splx(s);
				return;
			} 

			/* It's us */
			if ((scb->hscb->control & TARGET_SCB) != 0) {

				/*
				 * Send back any queued up transactions
				 * and properly record the error condition.
				 */
				ahc_freeze_devq(ahc, scb->xs->sc_link);
				ahcsetccbstatus(scb->xs, XS_TIMEOUT);
				ahc_freeze_ccb(scb);
				ahc_done(ahc, scb);

				/* Will clear us from the bus */
				restart_sequencer(ahc);
				splx(s);
				return;
			} 

			ahc_set_recoveryscb(ahc, active_scb);
			ahc_outb(ahc, MSG_OUT, MSG_BUS_DEV_RESET);
			ahc_outb(ahc, SCSISIGO, last_phase|ATNO);
			sc_print_addr(active_scb->xs->sc_link);
			printf("BDR message in message buffer\n");
			active_scb->flags |=  SCB_DEVICE_RESET;
			timeout_add(&active_scb->xs->stimeout, 2 * hz);
			unpause_sequencer(ahc);
		} else {
			int	 disconnected;
d5729 7
a5735 14
			/* XXX Shouldn't panic.  Just punt instead */
			if ((scb->hscb->control & TARGET_SCB) != 0)
				panic("Timed-out target SCB but bus idle");

			if (last_phase != P_BUSFREE
			 && (ahc_inb(ahc, SSTAT0) & TARGET) != 0) {
				/* XXX What happened to the SCB? */
				/* Hung target selection.  Goto busfree */
				printf("%s: Hung target selection\n",
				       ahc_name(ahc));
				restart_sequencer(ahc);
				splx(s);
				return;
			}
d5737 10
a5746 7
			if (ahc_search_qinfifo(ahc, target, channel, lun,
					       scb->hscb->tag, ROLE_INITIATOR,
					       /*status*/0, SEARCH_COUNT) > 0) {
				disconnected = FALSE;
			} else {
				disconnected = TRUE;
			}
d5748 5
a5752 2
			if (disconnected) {
				u_int active_scb;
d5754 3
a5756 29
				ahc_set_recoveryscb(ahc, scb);
				/*
				 * Simply set the MK_MESSAGE control bit.
				 */
				scb->hscb->control |= MK_MESSAGE;
				scb->flags |= SCB_QUEUED_MSG
					   |  SCB_DEVICE_RESET;

				/*
				 * Mark the cached copy of this SCB in the
				 * disconnected list too, so that a reconnect
				 * at this point causes a BDR or abort.
				 */
				active_scb = ahc_inb(ahc, SCBPTR);
				if (ahc_search_disc_list(ahc, target,
							 channel, lun,
							 scb->hscb->tag,
							 /*stop_on_first*/TRUE,
							 /*remove*/FALSE,
							 /*save_state*/FALSE)) {
					u_int scb_control;

					scb_control = ahc_inb(ahc, SCB_CONTROL);
					scb_control |= MK_MESSAGE;
					ahc_outb(ahc, SCB_CONTROL, scb_control);
				}
				ahc_outb(ahc, SCBPTR, active_scb);
				ahc_index_busy_tcl(ahc, scb->hscb->tcl,
						   /*unbusy*/TRUE);
d5758 3
a5760 42
				/*
				 * Actually re-queue this SCB in case we can
				 * select the device before it reconnects.
				 * Clear out any entries in the QINFIFO first
				 * so we are the next SCB for this target
				 * to run.
				 */
				ahc_search_qinfifo(ahc, SCB_TARGET(scb),
						   channel, SCB_LUN(scb),
						   SCB_LIST_NULL,
						   ROLE_INITIATOR,
						   SCB_REQUEUE,
						   SEARCH_COMPLETE);
				sc_print_addr(scb->xs->sc_link);
				printf("Queuing a BDR SCB\n");
				ahc->qinfifo[ahc->qinfifonext++] =
				    scb->hscb->tag;

				bus_dmamap_sync(ahc->sc_dmat,
				    ahc->shared_data_dmamap,
				    QINFIFO_OFFSET * 256, 256,
				    BUS_DMASYNC_PREWRITE);

				if ((ahc->features & AHC_QUEUE_REGS) != 0) {
					ahc_outb(ahc, HNSCB_QOFF,
						 ahc->qinfifonext);
				} else {
					ahc_outb(ahc, KERNEL_QINPOS,
						 ahc->qinfifonext);
				}
				timeout_add(&scb->xs->stimeout, 2 * hz);
				unpause_sequencer(ahc);
			} else {
				/* Go "immediatly" to the bus reset */
				/* This shouldn't happen */
				ahc_set_recoveryscb(ahc, scb);
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d: Immediate reset.  "
					"Flags = 0x%x\n", scb->hscb->tag,
					scb->flags);
				goto bus_reset;
			}
d5763 4
a5766 22
	splx(s);
}

STATIC int
ahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	role_t role;
	u_int32_t status;
	ahc_search_action action;
{
	struct	 scb *scbp;
	u_int8_t qinpos;
	u_int8_t qintail;
	int	 found;

	qinpos = ahc_inb(ahc, QINPOS);
	qintail = ahc->qinfifonext;
	found = 0;
d5769 1
a5769 2
	 * Start with an empty queue.  Entries that are not chosen
	 * for removal will be re-added to the queue as we go.
d5771 6
a5776 3
	ahc->qinfifonext = qinpos;
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_POSTREAD);
d5778 9
a5786 25
	while (qinpos != qintail) {
		scbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];
		if (ahc_match_scb(scbp, target, channel, lun, tag, role)) {
			/*
			 * We found an scb that needs to be removed.
			 */
			switch (action) {
			case SEARCH_COMPLETE:
				if (!(scbp->xs->flags & ITSDONE)) {
					scbp->flags |= status;
					scbp->xs->error = XS_NOERROR;
				}
				ahc_freeze_ccb(scbp);
				ahc_done(ahc, scbp);
				break;
			case SEARCH_COUNT:
				ahc->qinfifo[ahc->qinfifonext++] =
				    scbp->hscb->tag;
				break;
			case SEARCH_REMOVE:
				break;
			}
			found++;
		} else {
			ahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;
a5787 9
		qinpos++;
	}
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
	
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
d5790 5
a5794 1
	return (found);
d5797 2
d5800 1
a5800 4
 * Abort all SCBs that match the given description (target/channel/lun/tag),
 * setting their status to the passed in status if the status has not already
 * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
 * is paused before it is called.
d5802 2
a5803 9
STATIC int
ahc_abort_scbs(ahc, target, channel, lun, tag, role, status)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	role_t role;
	u_int32_t status;
d5805 21
a5825 4
	struct	scb *scbp;
	u_int	active_scb;
	int	i;
	int	found;
d5827 6
a5832 2
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
d5834 3
a5836 2
	found = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,
				   role, SCB_REQUEUE, SEARCH_COMPLETE);
d5838 12
a5849 8
	/*
	 * Search waiting for selection list.
	 */
	{
		u_int8_t next, prev;
                /* Start at head of list. */
		next = ahc_inb(ahc, WAITING_SCBH);
		prev = SCB_LIST_NULL;
d5851 6
a5856 2
		while (next != SCB_LIST_NULL) {
			u_int8_t scb_index;
d5858 2
a5859 10
			ahc_outb(ahc, SCBPTR, next);
			scb_index = ahc_inb(ahc, SCB_TAG);
			if (scb_index >= ahc->scb_data->numscbs) {
				panic("Waiting List inconsistency. "
				      "SCB index == %d, yet numscbs == %d.",
				      scb_index, ahc->scb_data->numscbs);
			}
			scbp = &ahc->scb_data->scbarray[scb_index];
			if (ahc_match_scb(scbp, target, channel,
					  lun, SCB_LIST_NULL, role)) {
d5861 8
a5868 6
				next = ahc_abort_wscb(ahc, next, prev);
			} else {
				
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
			}
d5871 12
a5882 9
	/*
	 * Go through the disconnected list and remove any entries we
	 * have queued for completion, 0'ing their control byte too.
	 * We save the active SCB and restore it ourselves, so there
	 * is no reason for this search to restore it too.
	 */
	ahc_search_disc_list(ahc, target, channel, lun, tag,
			     /*stop_on_first*/FALSE, /*remove*/TRUE,
			     /*save_state*/FALSE);
d5884 18
a5901 6
	/*
	 * Go through the hardware SCB array looking for commands that
	 * were active but not on any list.
	 */
	for(i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scbid;
d5903 32
a5934 7
		ahc_outb(ahc, SCBPTR, i);
		scbid = ahc_inb(ahc, SCB_TAG);
		scbp = &ahc->scb_data->scbarray[scbid];
		if (scbid < ahc->scb_data->numscbs && 
			 ahc_match_scb(scbp, target, channel, lun, tag, role))
				ahc_add_curscb_to_free_list(ahc);
	}
d5936 9
a5944 8
	/*
	 * Go through the pending CCB list and look for
	 * commands for this target that are still active.
	 * These are other tagged commands that were
	 * disconnected when the reset occurred.
	 */
	{
		struct scb *scb;
d5946 16
a5961 12
		scb = ahc->pending_scbs.lh_first;
		while (scb != NULL) {
			scbp = scb;
			scb = scb->pend_links.le_next;
			if (ahc_match_scb(scbp, target, channel,
					  lun, tag, role)) {
				if (!(scbp->xs->flags & ITSDONE))
					ahcsetccbstatus(scbp->xs, status);
				ahc_freeze_ccb(scbp);
				ahc_done(ahc, scbp);
				found++;
			}
d5963 6
a5969 2
	ahc_outb(ahc, SCBPTR, active_scb);
	return found;
d5971 1
d5973 5
a5977 11
STATIC int
ahc_search_disc_list(ahc, target, channel, lun, tag, stop_on_first, 
		     remove, save_state)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	int stop_on_first;
	int remove;
	int save_state;
d5979 24
a6002 5
	struct	scb *scbp;
	u_int	next;
	u_int	prev;
	u_int	count;
	u_int	active_scb;
d6004 23
a6026 3
	count = 0;
	next = ahc_inb(ahc, DISCONNECTED_SCBH);
	prev = SCB_LIST_NULL;
d6028 13
a6040 6
	if (save_state) {
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
	} else
		/* Silence compiler */
		active_scb = SCB_LIST_NULL;
d6042 6
a6047 2
	while (next != SCB_LIST_NULL) {
		u_int scb_index;
d6049 7
a6055 6
		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			panic("Disconnected List inconsistency. "
			      "SCB index == %d, yet numscbs == %d.",
			      scb_index, ahc->scb_data->numscbs);
d6057 18
a6074 10
		scbp = &ahc->scb_data->scbarray[scb_index];
		if (ahc_match_scb(scbp, target, channel, lun,
				  tag, ROLE_INITIATOR)) {
			count++;
			if (remove) {
				next =
				    ahc_rem_scb_from_disc_list(ahc, prev, next);
			} else {
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
d6076 1
a6076 5
			if (stop_on_first)
				break;
		} else {
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
d6078 12
d6091 5
a6095 3
	if (save_state)
	ahc_outb(ahc, SCBPTR, active_scb);
	return (count);
d6098 3
a6100 5
STATIC u_int
ahc_rem_scb_from_disc_list(ahc, prev, scbptr)
	struct ahc_softc *ahc;
	u_int prev;
	u_int scbptr;
d6102 7
a6108 1
	u_int next;
d6110 1
a6110 2
	ahc_outb(ahc, SCBPTR, scbptr);
	next = ahc_inb(ahc, SCB_NEXT);
d6112 1
a6112 1
	ahc_outb(ahc, SCB_CONTROL, 0);
d6114 11
a6124 1
	ahc_add_curscb_to_free_list(ahc);
d6126 4
a6129 5
	if (prev != SCB_LIST_NULL) {
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	} else
		ahc_outb(ahc, DISCONNECTED_SCBH, next);
d6131 1
a6131 1
	return (next);
d6134 2
a6135 3
STATIC void
ahc_add_curscb_to_free_list(ahc)
	struct ahc_softc *ahc;
d6137 4
a6140 18
	/* Invalidate the tag so that ahc_find_scb doesn't think it's active */
	ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);

	ahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));
	ahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));
}

/*
 * Manipulate the waiting for selection list and return the
 * scb that follows the one that we remove.
 */
STATIC u_int
ahc_abort_wscb(ahc, scbpos, prev)
	struct ahc_softc *ahc;
	u_int scbpos;
        u_int prev;
{       
	u_int curscb, next;
d6143 1
a6143 2
	 * Select the SCB we want to abort and
	 * pull the next pointer out of it.
d6145 1
a6145 3
	curscb = ahc_inb(ahc, SCBPTR);
	ahc_outb(ahc, SCBPTR, scbpos);
	next = ahc_inb(ahc, SCB_NEXT);
d6147 2
a6148 2
	/* Clear the necessary fields */
	ahc_outb(ahc, SCB_CONTROL, 0);
d6150 17
a6166 1
	ahc_add_curscb_to_free_list(ahc);
d6168 5
a6172 4
	/* update the waiting list */
	if (prev == SCB_LIST_NULL) {
		/* First in the list */
		ahc_outb(ahc, WAITING_SCBH, next); 
d6174 1
a6174 13
		/*
		 * Ensure we aren't attempting to perform
		 * selection for this entry.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else {
		/*
		 * Select the scb that pointed to us 
		 * and update its next pointer.
		 */
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	}
d6176 1
a6176 6
	/*
	 * Point us back at the original scb position.
	 */
	ahc_outb(ahc, SCBPTR, curscb);
	return next;
}
d6178 2
a6179 11
STATIC void
ahc_clear_intstat(ahc)
	struct ahc_softc *ahc;
{
	/* Clear any interrupt conditions this may have caused */
	ahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);
	ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
				|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|
				CLRREQINIT);
	ahc_outb(ahc, CLRINT, CLRSCSIINT);
}
d6181 40
a6220 5
STATIC void
ahc_reset_current_bus(ahc)
	struct ahc_softc *ahc;
{
	u_int8_t scsiseq;
d6222 3
a6224 6
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);
	scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);
	DELAY(AHC_BUSRESET_DELAY);
	/* Turn off the bus reset */
	ahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);
d6226 31
a6256 4
	ahc_clear_intstat(ahc);

	/* Re-enable reset interrupts */
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);
d6259 2
a6260 5
STATIC int
ahc_reset_channel(ahc, channel, initiate_reset)
	struct ahc_softc *ahc;
	char channel;
	int initiate_reset;
d6262 11
a6272 6
	u_int	initiator, target, max_scsiid;
	u_int	sblkctl;
	u_int	our_id;
	int	found;
	int	restart_needed;
	char	cur_channel;
d6274 1
a6274 1
	ahc->pending_device = NULL;
d6276 39
a6314 40
	pause_sequencer(ahc);

	/*
	 * Run our command complete fifos to ensure that we perform
	 * completion processing on any commands that 'completed'
	 * before the reset occurred.
	 */
	ahc_run_qoutfifo(ahc);

	/*
	 * Reset the bus if we are initiating this reset
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	cur_channel = 'A';
	if ((ahc->features & AHC_TWIN) != 0
	 && ((sblkctl & SELBUSB) != 0))
	    cur_channel = 'B';
	if (cur_channel != channel) {
		/* Case 1: Command for another bus is active
		 * Stealthily reset the other bus without
		 * upsetting the current bus.
		 */
		ahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
		ahc_outb(ahc, SBLKCTL, sblkctl);
		restart_needed = FALSE;
	} else {
		/* Case 2: A command from this bus is active or we're idle */
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
d6316 17
a6332 11
		/*
		 * Since we are going to restart the sequencer, avoid
		 * a race in the sequencer that could cause corruption
		 * of our Q pointers by starting over from index 0.
		 */
		ahc->qoutfifonext = 0;
		if ((ahc->features & AHC_QUEUE_REGS) != 0)
			ahc_outb(ahc, SDSCB_QOFF, 0);
		else
			ahc_outb(ahc, QOUTPOS, 0);
		restart_needed = TRUE;
d6334 35
a6368 12

	/*
	 * Clean up all the state information for the
	 * pending transactions on this bus.
	 */
	found = ahc_abort_scbs(ahc, ALL_TARGETS, channel,
			       ALL_LUNS, SCB_LIST_NULL,
			       ROLE_UNKNOWN, XS_RESET);
	if (channel == 'B') {
		our_id = ahc->our_id_b;
	} else {
		our_id = ahc->our_id;
d6370 1
d6372 8
a6379 6
	max_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;
	
	/*
	 * Revert to async/narrow transfers until we renegotiate.
	 */
	for (target = 0; target <= max_scsiid; target++) {
d6381 4
a6384 1
		if (ahc->enabled_targets[target] == NULL)
d6386 6
a6391 16
		for (initiator = 0; initiator <= max_scsiid; initiator++) {
			struct ahc_devinfo devinfo;

			ahc_compile_devinfo(&devinfo, target, initiator,
					    ALL_LUNS,
					    channel, ROLE_UNKNOWN);
			ahc_set_width(ahc, &devinfo,
				      MSG_EXT_WDTR_BUS_8_BIT,
				      AHC_TRANS_CUR,
				      /*paused*/TRUE,
				      /*done*/FALSE);
			ahc_set_syncrate(ahc, &devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, AHC_TRANS_CUR,
					 /*paused*/TRUE,
					 /*done*/FALSE);
d6393 1
d6396 2
a6397 5
	if (restart_needed)
		restart_sequencer(ahc);
	else
		unpause_sequencer(ahc);
	return found;
d6400 36
a6435 13
STATIC int
ahc_match_scb(scb, target, channel, lun, role, tag)
	struct scb *scb;
	int target;
	char channel;
	int lun;
	role_t role;
	u_int tag;
{
	int targ = SCB_TARGET(scb);
	char chan = SCB_CHANNEL(scb);
	int slun = SCB_LUN(scb);
	int match;
d6437 2
a6438 7
	match = ((chan == channel) || (channel == ALL_CHANNELS));
	if (match != 0)
		match = ((targ == target) || (target == ALL_TARGETS));
	if (match != 0)
		match = ((lun == slun) || (lun == ALL_LUNS));
	return match;
}
d6440 1
a6440 12
STATIC void
ahc_construct_sdtr(ahc, period, offset)
	struct ahc_softc *ahc;
	u_int period;
	u_int offset;
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_len += 5;
d6443 2
a6444 4
STATIC void
ahc_construct_wdtr(ahc, bus_width)
	struct ahc_softc *ahc;
	u_int bus_width;
d6446 9
a6454 6
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_len += 4;
}
d6456 2
a6457 5
STATIC void
ahc_calc_residual(scb)
	struct scb *scb;
{
	struct	hardware_scb *hscb;
d6459 4
a6462 1
	hscb = scb->hscb;
d6464 2
a6465 17
	/*
	 * If the disconnected flag is still set, this is bogus
	 * residual information left over from a sequencer
	 * pagin/pageout, so ignore this case.
	 */
	if ((scb->hscb->control & DISCONNECTED) == 0) {
		u_int32_t resid;
		int	  resid_sgs;
		int	  sg;
		
		/*
		 * Remainder of the SG where the transfer
		 * stopped.
		 */
		resid = (hscb->residual_data_count[2] << 16)
		      |	(hscb->residual_data_count[1] <<8)
		      |	(hscb->residual_data_count[0]);
d6467 4
a6470 8
		/*
		 * Add up the contents of all residual
		 * SG segments that are after the SG where
		 * the transfer stopped.
		 */
		resid_sgs = scb->hscb->residual_SG_count - 1/*current*/;
		sg = scb->sg_count - resid_sgs;
		while (resid_sgs > 0) {
d6472 22
a6493 3
			resid += le32toh(scb->sg_list[sg].len);
			sg++;
			resid_sgs--;
d6495 5
a6499 1
		scb->xs->resid = resid;
d6503 2
a6504 2
	 * Clean out the residual information in this SCB for its
	 * next consumer.
d6506 131
a6636 1
	hscb->residual_SG_count = 0;
d6638 23
a6660 7
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC) {
		sc_print_addr(scb->xs->sc_link);
		printf("Handled Residual of %ld bytes\n" ,scb->xs->resid);
	}
#endif
}
d6662 4
a6665 8
STATIC void
ahc_update_pending_syncrates(ahc)
	struct ahc_softc *ahc;
{
	struct	scb *scb;
	int	pending_scb_count;
	int	i;
	u_int	saved_scbptr;
d6667 1
a6667 14
	/*
	 * Traverse the pending SCB list and ensure that all of the
	 * SCBs there have the proper settings.
	 */
	scb = LIST_FIRST(&ahc->pending_scbs);
	pending_scb_count = 0;
	while (scb != NULL) {
		struct ahc_devinfo devinfo;
		struct scsi_xfer *xs;
		struct scb *pending_scb;
		struct hardware_scb *pending_hscb;
		struct ahc_initiator_tinfo *tinfo;
		struct tmode_tstate *tstate;
		u_int  our_id, remote_id;
d6669 28
a6696 20
		xs = scb->xs;
		pending_scb = scb;
		pending_hscb = pending_scb->hscb;
		our_id = SCB_IS_SCSIBUS_B(pending_scb)
		       ? ahc->our_id_b : ahc->our_id;
		remote_id = xs->sc_link->target;
		ahc_compile_devinfo(&devinfo, our_id, remote_id,
				    SCB_LUN(pending_scb),
				    SCB_CHANNEL(pending_scb),
				    ROLE_UNKNOWN);
		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
					    our_id, remote_id, &tstate);
		pending_hscb->control &= ~ULTRAENB;
		if ((tstate->ultraenb & devinfo.target_mask) != 0)
			pending_hscb->control |= ULTRAENB;
		pending_hscb->scsirate = tinfo->scsirate;
		pending_hscb->scsioffset = tinfo->current.offset;
		pending_scb_count++;
		scb = LIST_NEXT(scb, pend_links);
	}
d6698 15
a6712 2
	if (pending_scb_count == 0)
		return;
d6714 18
a6731 4
	saved_scbptr = ahc_inb(ahc, SCBPTR);
	/* Ensure that the hscbs down on the card match the new information */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scb_tag;
d6733 1
a6733 11
		ahc_outb(ahc, SCBPTR, i);
		scb_tag = ahc_inb(ahc, SCB_TAG);
		if (scb_tag != SCB_LIST_NULL) {
			struct	ahc_devinfo devinfo;
			struct	scb *pending_scb;
			struct scsi_xfer *xs;
			struct	hardware_scb *pending_hscb;
			struct	ahc_initiator_tinfo *tinfo;
			struct	tmode_tstate *tstate;
			u_int	our_id, remote_id;
			u_int	control;
d6735 24
a6758 21
			pending_scb = &ahc->scb_data->scbarray[scb_tag];
			if (pending_scb->flags == SCB_FREE)
				continue;
			pending_hscb = pending_scb->hscb;
			xs = pending_scb->xs;
			our_id = SCB_IS_SCSIBUS_B(pending_scb)
			       ? ahc->our_id_b : ahc->our_id;
			remote_id = xs->sc_link->target;
			ahc_compile_devinfo(&devinfo, our_id, remote_id,
					    SCB_LUN(pending_scb),
					    SCB_CHANNEL(pending_scb),
					    ROLE_UNKNOWN);
			tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
						    our_id, remote_id, &tstate);
			control = ahc_inb(ahc, SCB_CONTROL);
			control &= ~ULTRAENB;
			if ((tstate->ultraenb & devinfo.target_mask) != 0)
				control |= ULTRAENB;
			ahc_outb(ahc, SCB_CONTROL, control);
			ahc_outb(ahc, SCB_SCSIRATE, tinfo->scsirate);
			ahc_outb(ahc, SCB_SCSIOFFSET, tinfo->current.offset);
d6760 2
a6762 1
	ahc_outb(ahc, SCBPTR, saved_scbptr);
d6765 2
a6766 2
STATIC void
ahc_shutdown(void *arg)
d6768 2
a6769 5
	struct	ahc_softc *ahc;
	int	i;
	u_int	sxfrctl1_a, sxfrctl1_b;

	ahc = (struct ahc_softc *)arg;
d6771 2
a6772 1
	pause_sequencer(ahc);
d6775 4
a6778 4
	 * Preserve the value of the SXFRCTL1 register for all channels.
	 * It contains settings that affect termination and we don't want
	 * to disturb the integrity of the bus during shutdown in case
	 * we are in a multi-initiator setup.
d6780 7
a6786 3
	sxfrctl1_b = 0;
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;
d6788 8
a6795 4
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		sxfrctl1_b = ahc_inb(ahc, SXFRCTL1);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
d6797 10
d6808 7
a6814 1
	sxfrctl1_a = ahc_inb(ahc, SXFRCTL1);
d6816 2
a6817 2
	/* This will reset most registers to 0, but not all */
	ahc_reset(ahc);
d6819 6
a6824 2
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;
d6826 29
a6854 4
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		ahc_outb(ahc, SXFRCTL1, sxfrctl1_b);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
a6855 8
	ahc_outb(ahc, SXFRCTL1, sxfrctl1_a);

	ahc_outb(ahc, SCSISEQ, 0);
	ahc_outb(ahc, SXFRCTL0, 0);
	ahc_outb(ahc, DSPCISTATUS, 0);

	for (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)
		ahc_outb(ahc, i, 0);
d6858 2
a6859 4
STATIC void
ahc_check_tags(ahc, xs)
struct ahc_softc *ahc;
struct scsi_xfer *xs;
d6861 7
a6867 1
	struct ahc_devinfo devinfo;
d6869 3
a6871 2
	if (xs->sc_link->quirks & SDEV_NOTAGS)
		return;
d6873 5
a6877 2
	if (ahc_istagged_device(ahc, xs, 1))
 		return;
d6879 5
a6883 28
	ahc_compile_devinfo(&devinfo,
	    SIM_SCSI_ID(ahc, xs->sc_link),
	    xs->sc_link->target,
	    xs->sc_link->lun,
	    SIM_CHANNEL(ahc, xs->sc_link),
	    ROLE_INITIATOR);

	ahc_set_tags(ahc, &devinfo, TRUE);

	printf("%s: target %d using tagged queuing\n",
	    ahc_name(ahc), xs->sc_link->target);

	if (ahc->scb_data->maxhscbs >= 16 ||
	    (ahc->flags & AHC_PAGESCBS)) {
		/* Default to 16 tags */
		xs->sc_link->openings += 14;
	} else {
		/*	
		 * Default to 4 tags on whimpy
		 * cards that don't have much SCB
		 * space and can't page.  This prevents
		 * a single device from hogging all
		 * slots.  We should really have a better
		 * way of providing fairness.
		 */
		xs->sc_link->openings += 2;
	}
}
d6885 15
a6899 10
STATIC int
ahc_istagged_device(ahc, xs, nocmdcheck)
struct ahc_softc *ahc;
struct scsi_xfer *xs;
int nocmdcheck;
{
	char channel;
	u_int our_id, target;
	struct tmode_tstate *tstate;
	struct ahc_devinfo devinfo;
d6901 5
a6905 2
	if (xs->sc_link->quirks & SDEV_NOTAGS)
		return 0;
d6908 2
a6909 2
	 * XXX never do these commands with tags. Should really be
	 * in a higher layer.
d6911 11
a6921 4
	if (!nocmdcheck && (xs->cmd->opcode == INQUIRY ||
	     xs->cmd->opcode == TEST_UNIT_READY ||
	     xs->cmd->opcode == REQUEST_SENSE))
		return 0;
d6923 24
a6946 4
	channel = SIM_CHANNEL(ahc, xs->sc_link);
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
	target = xs->sc_link->target;
	(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);
d6948 1
a6948 2
	ahc_compile_devinfo(&devinfo, our_id, target,
	    xs->sc_link->lun, channel, ROLE_INITIATOR);
d6950 17
a6966 1
	return (tstate->tagenable & devinfo.target_mask);
d6968 2
@


1.38
log
@Fix problems the ahc driver was having with the recent changes to
scsiconf.c. The fact that both this ('original') ahc driver and the
new ahc driver (since reverted) crashed if devices capable of tagged
queuing were not correctly flagged as such must be a clue to some
interesting problem.

a) Restore marking of appropriate devices as tagged.
b) Use TAG_ENB define instead of MSG_SIMPLE_Q_TAG when
   manipulating hscb->control. Both were defined to the
   same value, but TAG_ENB is the define used to extract
   the bit later on.
c) Delete unused field 'tagdisable'.

ok millert@@, also tested by naddy@@
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.37 2002/03/19 21:07:25 millert Exp $
d1055 1
a1055 1
	/* Retain the IRQ type accross the chip reset */
@


1.37
log
@remove __P
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.36 2002/03/19 02:49:20 millert Exp $
a1474 1
		tstate->tagdisable |= devinfo->target_mask;
d2404 1
a2404 1
			if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0)
d2641 1
a2641 1
	} else if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0) {
d2655 1
a2655 1
	 	scb->hscb->control &= ~MSG_SIMPLE_Q_TAG;
d3523 3
a3526 1
		ahc_check_tags(ahc, xs);
a3854 1
		tstate->tagdisable = 0;
d4197 1
a4197 1
		scb->hscb->control |= MSG_SIMPLE_Q_TAG;
a5804 1
	struct scsi_inquiry_data *inq;
a5805 6
	struct tmode_tstate *tstate;
	int target_id, our_id;
	char channel;

	if (xs->cmd->opcode != INQUIRY || xs->error != XS_NOERROR)
		return;
d5810 2
a5811 7
	target_id = xs->sc_link->target;
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
	channel = SIM_CHANNEL(ahc, xs->sc_link);

	(void)ahc_fetch_transinfo(ahc, channel, our_id, target_id, &tstate);
	ahc_compile_devinfo(&devinfo, our_id, target_id,
	    xs->sc_link->lun, channel, ROLE_INITIATOR);
d5813 26
a5838 31
	if (tstate->tagdisable & devinfo.target_mask)
		return;

	/*
	 * Sneak a look at the results of the SCSI Inquiry
	 * command and see if we can do Tagged queing.  This
	 * should really be done by the higher level drivers.
	 */
	inq = (struct scsi_inquiry_data *)xs->data;
	if ((inq->flags & SID_CmdQue) && !(ahc_istagged_device(ahc, xs, 1))) {
#ifdef AHC_DEBUG 
		printf("%s: target %d using tagged queuing\n",
			ahc_name(ahc), xs->sc_link->target);
#endif 
		ahc_set_tags(ahc, &devinfo, TRUE);

		if (ahc->scb_data->maxhscbs >= 16 ||
		    (ahc->flags & AHC_PAGESCBS)) {
			/* Default to 16 tags */
			xs->sc_link->openings += 14;
		} else {
			/*
			 * Default to 4 tags on whimpy
			 * cards that don't have much SCB
			 * space and can't page.  This prevents
			 * a single device from hogging all
			 * slots.  We should really have a better
			 * way of providing fairness.
			 */
			xs->sc_link->openings += 2;
		}
@


1.36
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.34 2001/11/15 10:57:01 ho Exp $
d214 15
a228 18
STATIC int	ahc_poll __P((struct ahc_softc *ahc, int wait));
STATIC void	ahc_shutdown __P((void *arg));
STATIC int	ahc_execute_scb __P((void *arg, bus_dma_segment_t *dm_segs,
				     int nsegments));
STATIC int	ahc_setup_data __P((struct ahc_softc *ahc,
				    struct scsi_xfer *xs, struct scb *scb));
STATIC void	ahc_freeze_devq __P((struct ahc_softc *ahc,
				     struct scsi_link *sc_link));
STATIC void	ahcallocscbs __P((struct ahc_softc *ahc));
STATIC void	ahc_fetch_devinfo __P((struct ahc_softc *ahc,
				       struct ahc_devinfo *devinfo));
STATIC void	ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,
					 u_int our_id, u_int target,
					 u_int lun, char channel,
					 role_t role));
STATIC u_int	ahc_abort_wscb __P((struct ahc_softc *ahc,
				    u_int scbpos, u_int prev));
STATIC void	ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));
d230 16
a245 18
		ahc_alloc_tstate __P((struct ahc_softc *ahc, u_int scsi_id,
				      char channel));
STATIC void	ahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));
STATIC void	ahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));
STATIC void	ahc_build_transfer_msg __P((struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo));
STATIC void	ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,
						struct ahc_devinfo *devinfo,
						struct scb *scb));
STATIC void	ahc_setup_target_msgin __P((struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo));
STATIC int	ahc_handle_msg_reject __P((struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo));
STATIC void	ahc_clear_msg_state __P((struct ahc_softc *ahc));
STATIC void	ahc_handle_message_phase __P((struct ahc_softc *ahc,
					      struct scsi_link *sc_link));
STATIC int	ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,
				  int full));
d253 7
a259 9
STATIC int	ahc_parse_msg __P((struct ahc_softc *ahc,
				   struct scsi_link *sc_link,
				   struct ahc_devinfo *devinfo));
STATIC void	ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,
						 struct ahc_devinfo *devinfo));
STATIC void	ahc_handle_devreset __P((struct ahc_softc *ahc,
					 struct ahc_devinfo *devinfo,
					 int status, char *message,
					 int verbose_level));
d261 1
a261 1
STATIC void	ahc_dumpseq __P((struct ahc_softc *ahc));
d263 8
a270 8
STATIC void	ahc_loadseq __P((struct ahc_softc *ahc));
STATIC int	ahc_check_patch __P((struct ahc_softc *ahc,
				     struct patch **start_patch,
				     int start_instr, int *skip_addr));
STATIC void	ahc_download_instr __P((struct ahc_softc *ahc,
					int instrptr, u_int8_t *dconsts));
STATIC int	ahc_match_scb __P((struct scb *scb, int target, char channel,
				   int lun, u_int tag, role_t role));
d272 1
a272 1
STATIC void	ahc_print_scb __P((struct scb *scb));
d274 15
a288 18
STATIC int	ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,
					char channel, int lun, u_int tag,
					role_t role, u_int32_t status,
					ahc_search_action action));
STATIC int	ahc_reset_channel __P((struct ahc_softc *ahc, char channel,
				       int initiate_reset));
STATIC int	ahc_abort_scbs __P((struct ahc_softc *ahc, int target,
				    char channel, int lun, u_int tag,
				    role_t role, u_int32_t status));
STATIC int	ahc_search_disc_list __P((struct ahc_softc *ahc, int target,
					  char channel, int lun, u_int tag,
					  int stop_on_first, int remove,
					  int save_state));
STATIC u_int	ahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,
						u_int prev, u_int scbptr));
STATIC void	ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));
STATIC void	ahc_clear_intstat __P((struct ahc_softc *ahc));
STATIC void	ahc_reset_current_bus __P((struct ahc_softc *ahc));
d290 1
a290 1
		ahc_devlimited_syncrate __P((struct ahc_softc *ahc, u_int *period));
d292 5
a296 5
		ahc_find_syncrate __P((struct ahc_softc *ahc, u_int *period,
				       u_int maxsync));
STATIC u_int ahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,
				  u_int maxsync));
STATIC void	ahc_validate_offset __P((struct ahc_softc *ahc,
d298 33
a330 38
					 u_int *offset, int wide)); 
STATIC void	ahc_update_target_msg_request __P((struct ahc_softc *ahc,
					      struct ahc_devinfo *devinfo,
					      struct ahc_initiator_tinfo *tinfo,
					      int force, int paused));
STATIC void	ahc_set_syncrate __P((struct ahc_softc *ahc,
				      struct ahc_devinfo *devinfo,
				      struct ahc_syncrate *syncrate,
				      u_int period, u_int offset,
				      u_int type, int paused, int done));
STATIC void	ahc_set_width __P((struct ahc_softc *ahc,
			      struct ahc_devinfo *devinfo,
			      u_int width, u_int type, int paused, int done));
STATIC void	ahc_set_tags __P((struct ahc_softc *ahc,
				  struct ahc_devinfo *devinfo,int enable));
STATIC int      ahc_istagged_device __P((struct ahc_softc *ahc,
					 struct scsi_xfer *xs,
					 int nocmdcheck));
STATIC void     ahc_check_tags __P((struct ahc_softc *ahc,
				    struct scsi_xfer *xs));
STATIC void	ahc_construct_sdtr __P((struct ahc_softc *ahc,
				   u_int period, u_int offset));
STATIC void	ahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));

STATIC void	ahc_calc_residual __P((struct scb *scb));

STATIC void	ahc_update_pending_syncrates __P((struct ahc_softc *ahc));

STATIC void	ahc_set_recoveryscb __P((struct ahc_softc *ahc,
					 struct scb *scb));
STATIC void ahc_timeout __P((void *));

static __inline int  sequencer_paused __P((struct ahc_softc *ahc));
static __inline void pause_sequencer __P((struct ahc_softc *ahc));
static __inline void unpause_sequencer __P((struct ahc_softc *ahc));
STATIC void restart_sequencer __P((struct ahc_softc *ahc));
static __inline u_int ahc_index_busy_tcl __P((struct ahc_softc *ahc,
					      u_int tcl, int unbusy));
d332 5
a336 7
static __inline void	ahc_busy_tcl __P((struct ahc_softc *ahc,
					  struct scb *scb));
static __inline int	ahc_isbusy_tcl __P((struct ahc_softc *ahc,
					    struct scb *scb));
static __inline void ahc_freeze_ccb __P((struct scb* scb));
static __inline void ahcsetccbstatus __P((struct scsi_xfer *xs, int status));
STATIC void ahc_run_qoutfifo __P((struct ahc_softc *ahc));
d339 25
a363 29
	ahc_fetch_transinfo __P((struct ahc_softc *ahc, char channel,
				 u_int our_id, u_int target,
				 struct tmode_tstate **tstate));
STATIC void ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));
static __inline struct scb *ahcgetscb __P((struct ahc_softc *ahc));
int    ahc_createdmamem __P((struct ahc_softc *ahc, int size,
			     bus_dmamap_t *mapp, caddr_t *vaddr,
			     bus_addr_t *baddr, bus_dma_segment_t *segs,
			     int *nseg, const char *what));
STATIC void ahc_freedmamem __P((bus_dma_tag_t tag, int size,
				bus_dmamap_t map, caddr_t vaddr,
				bus_dma_segment_t *seg, int nseg));
STATIC void ahcminphys __P((struct buf *bp));

STATIC INLINE	struct scsi_xfer *ahc_first_xs __P((struct ahc_softc *));
STATIC INLINE	void   ahc_list_insert_before __P((struct ahc_softc *ahc,
						   struct scsi_xfer *xs,
						   struct scsi_xfer *next_xs));
STATIC INLINE	void   ahc_list_insert_head __P((struct ahc_softc *ahc,
						 struct scsi_xfer *xs));
STATIC INLINE	void   ahc_list_insert_tail __P((struct ahc_softc *ahc,
						 struct scsi_xfer *xs));
STATIC INLINE	void   ahc_list_remove __P((struct ahc_softc *ahc,
					    struct scsi_xfer *xs));
STATIC INLINE	struct scsi_xfer *ahc_list_next __P((struct ahc_softc *ahc,
						     struct scsi_xfer *xs));
STATIC int32_t ahc_scsi_cmd __P((struct scsi_xfer *xs));
static __inline void ahc_swap_hscb __P((struct hardware_scb *));
static __inline void ahc_swap_sg __P((struct ahc_dma_seg *));
@


1.35
log
@New port of FreeBSD's ahc driver
@
text
@d2 5
a6 1
 * Core routines and tables shareable across OS platforms.
d8 1
a8 1
 * Copyright (c) 1994-2001 Justin T. Gibbs.
d21 1
a21 1
 * GNU Public License ("GPL").
d35 50
a84 1
 * $Id: //depot/src/aic7xxx/aic7xxx.c#43 $
a85 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.80 2001/12/16 17:38:30 gibbs Exp $
d88 29
a116 4
#ifdef __OpenBSD__
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
#include <dev/microcode/aic7xxx/aicasm_insformat.h>
a117 7
#ifdef __FreeBSD__
#include <dev/aic7xxx/aic7xxx_freebsd.h>
#include <dev/aic7xxx/aic7xxx_inline.h>
#include <dev/aic7xxx/aicasm/aicasm_insformat.h>
#endif 
/****************************** Softc Data ************************************/
struct ahc_softc_tailq ahc_tailq = TAILQ_HEAD_INITIALIZER(ahc_tailq);
d119 76
a194 17
/***************************** Lookup Tables **********************************/
char *ahc_chip_names[] =
{
	"NONE",
	"aic7770",
	"aic7850",
	"aic7855",
	"aic7859",
	"aic7860",
	"aic7870",
	"aic7880",
	"aic7895",
	"aic7895C",
	"aic7890/91",
	"aic7896/97",
	"aic7892",
	"aic7899"
a195 1
static const u_int num_chip_names = NUM_ELEMENTS(ahc_chip_names);
d197 191
a387 6
/*
 * Hardware error codes.
 */
struct ahc_hard_error_entry {
        uint8_t errno;
	char *errmesg;
d390 6
a395 9
static struct ahc_hard_error_entry ahc_hard_errors[] = {
	{ ILLHADDR,	"Illegal Host Access" },
	{ ILLSADDR,	"Illegal Sequencer Address referrenced" },
	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
	{ SQPARERR,	"Sequencer Parity Error" },
	{ DPARERR,	"Data-path Parity Error" },
	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
	{ PCIERRSTAT,	"PCI Error detected" },
	{ CIOPARERR,	"CIOBUS Parity Error" },
a396 1
static const u_int num_errors = NUM_ELEMENTS(ahc_hard_errors);
d398 2
a399 1
static struct ahc_phase_table_entry ahc_phase_table[] =
d401 4
a404 10
	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
	{ P_DATAOUT_DT,	MSG_NOOP,		"in DT Data-out phase"	},
	{ P_DATAIN_DT,	MSG_INITIATOR_DET_ERR,	"in DT Data-in phase"	},
	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
	{ 0,		MSG_NOOP,		"in unknown phase"	}
d407 23
d431 5
a435 2
 * In most cases we only wish to itterate over real phases, so
 * exclude the last element from the count.
d437 15
a451 1
static const u_int num_phases = NUM_ELEMENTS(ahc_phase_table) - 1;
d453 3
a455 6
/*
 * Valid SCSIRATE values.  (p. 3-17)
 * Provides a mapping of tranfer periods in ns to the proper value to
 * stick in the scsixfer reg.
 */
static struct ahc_syncrate ahc_syncrates[] =
d457 2
a458 17
      /* ultra2    fast/ultra  period     rate */
	{ 0x42,      0x000,      9,      "80.0" },
	{ 0x03,      0x000,     10,      "40.0" },
	{ 0x04,      0x000,     11,      "33.0" },
	{ 0x05,      0x100,     12,      "20.0" },
	{ 0x06,      0x110,     15,      "16.0" },
	{ 0x07,      0x120,     18,      "13.4" },
	{ 0x08,      0x000,     25,      "10.0" },
	{ 0x19,      0x010,     31,      "8.0"  },
	{ 0x1a,      0x020,     37,      "6.67" },
	{ 0x1b,      0x030,     43,      "5.7"  },
	{ 0x1c,      0x040,     50,      "5.0"  },
	{ 0x00,      0x050,     56,      "4.4"  },
	{ 0x00,      0x060,     62,      "4.0"  },
	{ 0x00,      0x070,     68,      "3.6"  },
	{ 0x00,      0x000,      0,      NULL   }
};
d460 5
a464 6
/* Our Sequencer Program */
#ifdef __OpenBSD__
#include <dev/microcode/aic7xxx/aic7xxx_seq.h>
#else
#include "aic7xxx_seq.h"
#endif 
d466 7
a472 61
/**************************** Function Declarations ***************************/
static struct ahc_tmode_tstate*
			ahc_alloc_tstate(struct ahc_softc *ahc,
					 u_int scsi_id, char channel);
#ifdef AHC_TARGET_MODE
static void		ahc_free_tstate(struct ahc_softc *ahc,
					u_int scsi_id, char channel, int force);
#endif
static struct ahc_syncrate*
			ahc_devlimited_syncrate(struct ahc_softc *ahc,
					        struct ahc_initiator_tinfo *,
						u_int *period,
						u_int *ppr_options,
						role_t role);
static void		ahc_update_pending_scbs(struct ahc_softc *ahc);
static void		ahc_fetch_devinfo(struct ahc_softc *ahc,
					  struct ahc_devinfo *devinfo);
static void		ahc_scb_devinfo(struct ahc_softc *ahc,
					struct ahc_devinfo *devinfo,
					struct scb *scb);
static void		ahc_assert_atn(struct ahc_softc *ahc);
static void		ahc_setup_initiator_msgout(struct ahc_softc *ahc,
						   struct ahc_devinfo *devinfo,
						   struct scb *scb);
static void		ahc_build_transfer_msg(struct ahc_softc *ahc,
					       struct ahc_devinfo *devinfo);
static void		ahc_construct_sdtr(struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo,
					   u_int period, u_int offset);
static void		ahc_construct_wdtr(struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo,
					   u_int bus_width);
static void		ahc_construct_ppr(struct ahc_softc *ahc,
					  struct ahc_devinfo *devinfo,
					  u_int period, u_int offset,
					  u_int bus_width, u_int ppr_options);
static void		ahc_clear_msg_state(struct ahc_softc *ahc);
static void		ahc_handle_message_phase(struct ahc_softc *ahc);
typedef enum {
	AHCMSG_1B,
	AHCMSG_2B,
	AHCMSG_EXT
} ahc_msgtype;
static int		ahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type,
				     u_int msgval, int full);
static int		ahc_parse_msg(struct ahc_softc *ahc,
				      struct ahc_devinfo *devinfo);
static int		ahc_handle_msg_reject(struct ahc_softc *ahc,
					      struct ahc_devinfo *devinfo);
static void		ahc_handle_ign_wide_residue(struct ahc_softc *ahc,
						struct ahc_devinfo *devinfo);
static void		ahc_reinitialize_dataptrs(struct ahc_softc *ahc);
static void		ahc_handle_devreset(struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo,
					    cam_status status, char *message,
					    int verbose_level);
#if AHC_TARGET_MODE
static void		ahc_setup_target_msgin(struct ahc_softc *ahc,
					       struct ahc_devinfo *devinfo,
					       struct scb *scb);
#endif
d474 7
a480 10
#ifdef __OpenBSD__
int			ahc_init_scbdata(struct ahc_softc *ahc);
void			ahc_fini_scbdata(struct ahc_softc *ahc);
void			ahc_build_free_scb_list(struct ahc_softc *ahc);
#else
static bus_dmamap_callback_t	ahc_dmamap_cb;
static int		ahc_init_scbdata(struct ahc_softc *ahc);
static void		ahc_fini_scbdata(struct ahc_softc *ahc);
static void		ahc_build_free_scb_list(struct ahc_softc *ahc);
#endif 
a481 34
static void		ahc_qinfifo_requeue(struct ahc_softc *ahc,
					    struct scb *prev_scb,
					    struct scb *scb);
static int		ahc_qinfifo_count(struct ahc_softc *ahc);
static u_int		ahc_rem_scb_from_disc_list(struct ahc_softc *ahc,
						   u_int prev, u_int scbptr);
static void		ahc_add_curscb_to_free_list(struct ahc_softc *ahc);
static u_int		ahc_rem_wscb(struct ahc_softc *ahc,
				     u_int scbpos, u_int prev);
static int		ahc_abort_scbs(struct ahc_softc *ahc, int target,
				       char channel, int lun, u_int tag,
				       role_t role, uint32_t status);
static void		ahc_reset_current_bus(struct ahc_softc *ahc);
#ifdef AHC_DUMP_SEQ
static void		ahc_dumpseq(struct ahc_softc *ahc);
#endif
static void		ahc_loadseq(struct ahc_softc *ahc);
static int		ahc_check_patch(struct ahc_softc *ahc,
					struct patch **start_patch,
					u_int start_instr, u_int *skip_addr);
static void		ahc_download_instr(struct ahc_softc *ahc,
					   u_int instrptr, uint8_t *dconsts);
#ifdef AHC_TARGET_MODE
static void		ahc_queue_lstate_event(struct ahc_softc *ahc,
					       struct ahc_tmode_lstate *lstate,
					       u_int initiator_id,
					       u_int event_type,
					       u_int event_arg);
static void		ahc_update_scsiid(struct ahc_softc *ahc,
					  u_int targid_mask);
static int		ahc_handle_target_cmd(struct ahc_softc *ahc,
					      struct target_cmd *cmd);
#endif
/************************* Sequencer Execution Control ************************/
d485 35
a519 2
void
ahc_restart(struct ahc_softc *ahc)
d521 8
d530 12
a541 1
	ahc_pause(ahc);
d543 7
a549 3
	ahc_outb(ahc, SCSISIGO, 0);		/* De-assert BSY */
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);	/* No message to send */
	ahc_outb(ahc, SXFRCTL1, ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);
d551 7
a557 8
	/*
	 * Ensure that the sequencer's idea of TQINPOS
	 * matches our own.  The sequencer increments TQINPOS
	 * only after it sees a DMA complete and a reset could
	 * occur before the increment leaving the kernel to believe
	 * the command arrived but the sequencer to not.
	 */
	ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
d559 4
a562 8
	/* Always allow reselection */
	ahc_outb(ahc, SCSISEQ,
		 ahc_inb(ahc, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Ensure that no DMA operations are in progress */
		ahc_outb(ahc, CCSCBCNT, 0);
		ahc_outb(ahc, CCSGCTL, 0);
		ahc_outb(ahc, CCSCBCTL, 0);
d564 18
d583 4
a586 3
	 * If we were in the process of DMA'ing SCB data into
	 * an SCB, replace that SCB on the free list.  This prevents
	 * an SCB leak.
d588 4
a591 10
	if ((ahc_inb(ahc, SEQ_FLAGS2) & SCB_DMA) != 0) {
		ahc_add_curscb_to_free_list(ahc);
		ahc_outb(ahc, SEQ_FLAGS2,
			 ahc_inb(ahc, SEQ_FLAGS2) & ~SCB_DMA);
	}
	ahc_outb(ahc, MWI_RESIDUAL, 0);
	ahc_outb(ahc, SEQCTL, FASTMODE);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	ahc_unpause(ahc);
d594 3
a596 3
/************************* Input/Output Queues ********************************/
void
ahc_run_qoutfifo(struct ahc_softc *ahc)
d601 3
a603 1
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);
a604 1

d606 1
a606 18
		if ((ahc->qoutfifonext & 0x03) == 0x03) {
			u_int modnext;

			/*
			 * Clear 32bits of QOUTFIFO at a time
			 * so that we don't clobber an incoming
			 * byte DMA to the array on architectures
			 * that only support 32bit load and store
			 * operations.
			 */
			modnext = ahc->qoutfifonext & ~0x3;
			*((uint32_t *)(&ahc->qoutfifo[modnext])) = 0xFFFFFFFFUL;
			ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
					ahc->shared_data_dmamap,
					/*offset*/modnext, /*len*/4,
					BUS_DMASYNC_PREREAD);
		}
		ahc->qoutfifonext++;
d608 3
a610 2
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
d622 4
a625 1
		ahc_update_residual(scb);
a629 4
void
ahc_run_untagged_queues(struct ahc_softc *ahc)
{
	int i;
d631 13
a643 3
	for (i = 0; i < 16; i++)
		ahc_run_untagged_queue(ahc, &ahc->untagged_queues[i]);
}
d645 4
a648 4
void
ahc_run_untagged_queue(struct ahc_softc *ahc, struct scb_tailq *queue)
{
	struct scb *scb;
d650 1
a650 2
	if (ahc->untagged_queue_lock != 0)
		return;
d652 4
a655 4
	if ((scb = TAILQ_FIRST(queue)) != NULL
	 && (scb->flags & SCB_ACTIVE) == 0) {
		scb->flags |= SCB_ACTIVE;
		ahc_queue_scb(ahc, scb);
d657 10
d669 9
a677 3
/************************* Interrupt Handling *********************************/
void
ahc_handle_brkadrint(struct ahc_softc *ahc)
d679 12
a690 6
	/*
	 * We upset the sequencer :-(
	 * Lookup the error message
	 */
	int i;
	int error;
d692 1
a692 14
	error = ahc_inb(ahc, ERROR);
	for (i = 0; error != 1 && i < num_errors; i++)
		error >>= 1;
	printf("%s: brkadrint, %s at seqaddr = 0x%x\n",
	       ahc_name(ahc), ahc_hard_errors[i].errmesg,
	       ahc_inb(ahc, SEQADDR0) |
	       (ahc_inb(ahc, SEQADDR1) << 8));

	ahc_dump_card_state(ahc);

	/* Tell everyone that this HBA is no longer availible */
	ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,
		       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,
		       CAM_NO_HBA);
d694 1
a694 2
	/* Disable all interrupt sources by resetting the controller */
	ahc_shutdown(ahc);
d697 17
a713 5
void
ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat)
{
	struct scb *scb;
	struct ahc_devinfo devinfo;
d715 50
a764 1
	ahc_fetch_devinfo(ahc, &devinfo);
d766 9
a774 12
	/*
	 * Clear the upper byte that holds SEQINT status
	 * codes and clear the SEQINT bit. We will unpause
	 * the sequencer, if appropriate, after servicing
	 * the request.
	 */
	ahc_outb(ahc, CLRINT, CLRSEQINT);
	switch (intstat & SEQINT_MASK) {
	case BAD_STATUS:
	{
		u_int  scb_index;
		struct hardware_scb *hscb;
d776 5
a780 6
		/*
		 * Set the default return value to 0 (don't
		 * send sense).  The sense code will change
		 * this if needed.
		 */
		ahc_outb(ahc, RETURN_1, 0);
d782 6
a787 20
		/*
		 * The sequencer will notify us when a command
		 * has an error that would be of interest to
		 * the kernel.  This allows us to leave the sequencer
		 * running in the common case of command completes
		 * without error.  The sequencer will already have
		 * dma'd the SCB back up to us, so we can reference
		 * the in kernel copy directly.
		 */
		scb_index = ahc_inb(ahc, SCB_TAG);
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("%s:%c:%d: ahc_intr - referenced scb "
			       "not valid during seqint 0x%x scb(%d)\n",
			       ahc_name(ahc), devinfo.channel,
			       devinfo.target, intstat, scb_index);
			ahc_dump_card_state(ahc);
			panic("for safety");
			goto unpause;
		}
d789 22
a810 1
		hscb = scb->hscb; 
d812 14
a825 37
		/* Don't want to clobber the original sense code */
		if ((scb->flags & SCB_SENSE) != 0) {
			/*
			 * Clear the SCB_SENSE Flag and have
			 * the sequencer do a normal command
			 * complete.
			 */
			scb->flags &= ~SCB_SENSE;
			printf("ahc_handle_seqint: sense fail\n");
			ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
			break;
		}
		ahc_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
		/* Freeze the queue until the client sees the error. */
		ahc_freeze_devq(ahc, scb);
		ahc_freeze_scb(scb);
		ahc_set_scsi_status(scb, hscb->shared_data.status.scsi_status);
		switch (hscb->shared_data.status.scsi_status) {
		case SCSI_STATUS_OK:
			printf("%s: Interrupted for staus of 0???\n",
			       ahc_name(ahc));
			break;
		case SCSI_STATUS_CMD_TERMINATED:
		case SCSI_STATUS_CHECK_COND:
		{
			struct ahc_dma_seg *sg;
			struct scsi_sense *sc;
			struct ahc_initiator_tinfo *targ_info;
			struct ahc_tmode_tstate *tstate;
			struct ahc_transinfo *tinfo;
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				ahc_print_path(ahc, scb);
				printf("SCB %d: requests Check Status\n",
				       scb->hscb->tag);
			}
#endif
d827 15
a841 2
			if (ahc_perform_autosense(scb) == 0)
				break;
d843 27
a869 35
			targ_info = ahc_fetch_transinfo(ahc,
							devinfo.channel,
							devinfo.our_scsiid,
							devinfo.target,
							&tstate);
			tinfo = &targ_info->curr;
			sg = scb->sg_list;
			sc = (struct scsi_sense *)(&hscb->shared_data.cdb); 
			/*
			 * Save off the residual if there is one.
 			 */
			ahc_update_residual(scb);
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				ahc_print_path(ahc, scb);
				printf("Sending Sense\n");
			}
#endif
			sg->addr = ahc_get_sense_bufaddr(ahc, scb);
			sg->len = ahc_get_sense_bufsize(ahc, scb);
			sg->len |= AHC_DMA_LAST_SEG;
			
			/* Fixup byte order */
			sg->addr = ahc_htole32(sg->addr);
			sg->len = ahc_htole32(sg->len);

			sc->opcode = REQUEST_SENSE;
			sc->byte2 = 0;
			if (tinfo->protocol_version <= SCSI_REV_2
			 && SCB_GET_LUN(scb) < 8)
				sc->byte2 = SCB_GET_LUN(scb) << 5;
			sc->unused[0] = 0;
			sc->unused[1] = 0;
			sc->length = sg->len;
			sc->control = 0;
d871 15
a885 404
			/*
			 * We can't allow the target to disconnect.
			 * This will be an untagged transaction and
			 * having the target disconnect will make this
			 * transaction indestinguishable from outstanding
			 * tagged transactions.
			 */
			hscb->control = 0;

			/*
			 * This request sense could be because the
			 * the device lost power or in some other
			 * way has lost our transfer negotiations.
			 * Renegotiate if appropriate.  Unit attention
			 * errors will be reported before any data
			 * phases occur.
			 */
#ifdef __OpenBSD__
			if (ahc_get_transfer_length(scb) > 0 &&
			    ahc_get_residual(scb) == 
			    ahc_get_transfer_length(scb)) {
#else 
			if (ahc_get_residual(scb) 
			 == ahc_get_transfer_length(scb)) {
#endif
				ahc_update_neg_request(ahc, &devinfo,
						       tstate, targ_info,
						       /*force*/TRUE);
			}
			if (tstate->auto_negotiate & devinfo.target_mask) {
				hscb->control |= MK_MESSAGE;
				scb->flags &= ~SCB_NEGOTIATE;
				scb->flags |= SCB_AUTO_NEGOTIATE;
			}
			hscb->cdb_len = sizeof(*sc);
			hscb->dataptr = ahc_htole32(sg->addr); 
			hscb->datacnt = ahc_htole32(sg->len);
			hscb->sgptr = scb->sg_list_phys | SG_FULL_RESID;
			hscb->sgptr = ahc_htole32(hscb->sgptr);
			scb->sg_count = 1;
			scb->flags |= SCB_SENSE;
			ahc_qinfifo_requeue_tail(ahc, scb);
			ahc_outb(ahc, RETURN_1, SEND_SENSE);
#ifdef __OpenBSD__
			if (!(scb->io_ctx->flags & SCSI_POLL))
				timeout_add(&scb->io_ctx->stimeout, 5 * hz);
#endif 
#ifdef __FreeBSD__
			/*
			 * Ensure we have enough time to actually
			 * retrieve the sense.
			 */
			untimeout(ahc_timeout, (caddr_t)scb,
				  scb->io_ctx->ccb_h.timeout_ch);
			scb->io_ctx->ccb_h.timeout_ch =
			    timeout(ahc_timeout, (caddr_t)scb, 5 * hz);
#endif
			break;
		}
		default:
			break;
		}
		break;
	}
	case NO_MATCH:
	{
		/* Ensure we don't leave the selection hardware on */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));

		printf("%s:%c:%d: no active SCB for reconnecting "
		       "target - issuing BUS DEVICE RESET\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target);
		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
		       "ARG_1 == 0x%x ACCUM = 0x%x\n",
		       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),
		       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));
		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
		       "SINDEX == 0x%x\n",
		       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),
		       ahc_index_busy_tcl(ahc,
			    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),
				      ahc_inb(ahc, SAVED_LUN))),
		       ahc_inb(ahc, SINDEX));
		printf("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
		       "SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",
		       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),
		       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),
		       ahc_inb(ahc, SCB_CONTROL));
		printf("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",
		       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));
		printf("SXFRCTL0 == 0x%x\n", ahc_inb(ahc, SXFRCTL0));
		printf("SEQCTL == 0x%x\n", ahc_inb(ahc, SEQCTL));
		ahc_dump_card_state(ahc);
		ahc->msgout_buf[0] = MSG_BUS_DEV_RESET;
		ahc->msgout_len = 1;
		ahc->msgout_index = 0;
		ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		ahc_assert_atn(ahc);
		break;
	}
	case SEND_REJECT: 
	{
		u_int rejbyte = ahc_inb(ahc, ACCUM);
		printf("%s:%c:%d: Warning - unknown message received from "
		       "target (0x%x).  Rejecting\n", 
		       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);
		break; 
	}
	case NO_IDENT: 
	{
		/*
		 * The reconnecting target either did not send an identify
		 * message, or did, but we didn't find an SCB to match and
		 * before it could respond to our ATN/abort, it hit a dataphase.
		 * The only safe thing to do is to blow it away with a bus
		 * reset.
		 */
		int found;

		printf("%s:%c:%d: Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x, SAVED_SCSIID == 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_SCSIID));
		found = ahc_reset_channel(ahc, devinfo.channel, 
					  /*initiate reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), devinfo.channel,
		       found);
		return;
	}
	case IGN_WIDE_RES:
		ahc_handle_ign_wide_residue(ahc, &devinfo);
		break;
	case PDATA_REINIT:
		ahc_reinitialize_dataptrs(ahc);
		break;
	case BAD_PHASE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		printf("%s:%c:%d: unknown scsi bus phase %x, "
		       "lastphase = 0x%x.  Attempting to continue\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       lastphase, ahc_inb(ahc, SCSISIGI));
		break;
	}
	case MISSED_BUSFREE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		printf("%s:%c:%d: Missed busfree. "
		       "Lastphase = 0x%x, Curphase = 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       lastphase, ahc_inb(ahc, SCSISIGI));
		ahc_restart(ahc);
		return;
	}
	case HOST_MSG_LOOP:
	{
		/*
		 * The sequencer has encountered a message phase
		 * that requires host assistance for completion.
		 * While handling the message phase(s), we will be
		 * notified by the sequencer after each byte is
		 * transfered so we can track bus phase changes.
		 *
		 * If this is the first time we've seen a HOST_MSG_LOOP
		 * interrupt, initialize the state of the host message
		 * loop.
		 */
		if (ahc->msg_type == MSG_TYPE_NONE) {
			struct scb *scb;
			u_int scb_index;
			u_int bus_phase;

			bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			if (bus_phase != P_MESGIN
			 && bus_phase != P_MESGOUT) {
				printf("ahc_intr: HOST_MSG_LOOP bad "
				       "phase 0x%x\n",
				      bus_phase);
				/*
				 * Probably transitioned to bus free before
				 * we got here.  Just punt the message.
				 */
				ahc_clear_intstat(ahc);
				ahc_restart(ahc);
				return;
			}

			scb_index = ahc_inb(ahc, SCB_TAG);
			scb = ahc_lookup_scb(ahc, scb_index);
			if (devinfo.role == ROLE_INITIATOR) {
				if (scb == NULL)
					panic("HOST_MSG_LOOP with "
					      "invalid SCB %x\n", scb_index);

				if (bus_phase == P_MESGOUT)
					ahc_setup_initiator_msgout(ahc,
								   &devinfo,
								   scb);
				else {
					ahc->msg_type =
					    MSG_TYPE_INITIATOR_MSGIN;
					ahc->msgin_index = 0;
				}
			} else {
				if (bus_phase == P_MESGOUT) {
					ahc->msg_type =
					    MSG_TYPE_TARGET_MSGOUT;
					ahc->msgin_index = 0;
				}
#if AHC_TARGET_MODE
				else 
					ahc_setup_target_msgin(ahc,
							       &devinfo,
							       scb);
#endif
			}
		}

		ahc_handle_message_phase(ahc);
		break;
	}
	case PERR_DETECTED:
	{
		/*
		 * If we've cleared the parity error interrupt
		 * but the sequencer still believes that SCSIPERR
		 * is true, it must be that the parity error is
		 * for the currently presented byte on the bus,
		 * and we are not in a phase (data-in) where we will
		 * eventually ack this byte.  Ack the byte and
		 * throw it away in the hope that the target will
		 * take us to message out to deliver the appropriate
		 * error message.
		 */
		if ((intstat & SCSIINT) == 0
		 && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {

			if ((ahc->features & AHC_DT) == 0) {
				u_int curphase;

				/*
				 * The hardware will only let you ack bytes
				 * if the expected phase in SCSISIGO matches
				 * the current phase.  Make sure this is
				 * currently the case.
				 */
				curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
				ahc_outb(ahc, LASTPHASE, curphase);
				ahc_outb(ahc, SCSISIGO, curphase);
			}
			ahc_inb(ahc, SCSIDATL);
		}
		break;
	}
	case DATA_OVERRUN:
	{
		/*
		 * When the sequencer detects an overrun, it
		 * places the controller in "BITBUCKET" mode
		 * and allows the target to complete its transfer.
		 * Unfortunately, none of the counters get updated
		 * when the controller is in this mode, so we have
		 * no way of knowing how large the overrun was.
		 */
		u_int scbindex = ahc_inb(ahc, SCB_TAG);
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		u_int i;

		scb = ahc_lookup_scb(ahc, scbindex);
		for (i = 0; i < num_phases; i++) {
			if (lastphase == ahc_phase_table[i].phase)
				break;
		}
		ahc_print_path(ahc, scb);
		printf("data overrun detected %s."
		       "  Tag == 0x%x.\n",
		       ahc_phase_table[i].phasemsg,
  		       scb->hscb->tag);
		ahc_print_path(ahc, scb);
		printf("%s seen Data Phase.  Length = %ld.  NumSGs = %d.\n",
		       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
		       ahc_get_transfer_length(scb), scb->sg_count);
		if (scb->sg_count > 0) {
			for (i = 0; i < scb->sg_count; i++) {

				printf("sg[%d] - Addr 0x%x%x : Length %d\n",
				       i,
				       (ahc_le32toh(scb->sg_list[i].len) >> 24
				        & SG_HIGH_ADDR_BITS),
				       ahc_le32toh(scb->sg_list[i].addr),
				       ahc_le32toh(scb->sg_list[i].len)
				       & AHC_SG_LEN_MASK);
			}
		}
		/*
		 * Set this and it will take effect when the
		 * target does a command complete.
		 */
		ahc_freeze_devq(ahc, scb);
		ahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);
		ahc_freeze_scb(scb);

		if ((ahc->features & AHC_ULTRA2) != 0) {
			/*
			 * Clear the channel in case we return
			 * to data phase later.
			 */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);
		}
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			u_int dscommand1;

			/* Ensure HHADDR is 0 for future DMA operations. */
			dscommand1 = ahc_inb(ahc, DSCOMMAND1);
			ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
			ahc_outb(ahc, HADDR, 0);
			ahc_outb(ahc, DSCOMMAND1, dscommand1);
		}
		break;
	}
	case MKMSG_FAILED:
	{
		u_int scbindex;

		printf("%s:%c:%d:%d: Attempt to issue message failed\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       devinfo.lun);
		scbindex = ahc_inb(ahc, SCB_TAG);
		scb = ahc_lookup_scb(ahc, scbindex);
		if (scb != NULL
		 && (scb->flags & SCB_RECOVERY_SCB) != 0)
			/*
			 * Ensure that we didn't put a second instance of this
			 * SCB into the QINFIFO.
			 */
			ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
					   SCB_GET_CHANNEL(ahc, scb),
					   SCB_GET_LUN(scb), scb->hscb->tag,
					   ROLE_INITIATOR, /*status*/0,
					   SEARCH_REMOVE);
		break;
	}
	case NO_FREE_SCB:
	{
		printf("%s: No free or disconnected SCBs\n", ahc_name(ahc));
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	case SCB_MISMATCH:
	{
		u_int scbptr;

		scbptr = ahc_inb(ahc, SCBPTR);
		printf("Bogus TAG after DMA.  SCBPTR %d, tag %d, our tag %d\n",
		       scbptr, ahc_inb(ahc, ARG_1),
		       ahc->scb_data->hscbs[scbptr].tag);
		ahc_dump_card_state(ahc);
		panic("for saftey");
		break;
	}
	case OUT_OF_RANGE:
	{
		printf("%s: BTT calculation out of range\n", ahc_name(ahc));
		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
		       "ARG_1 == 0x%x ACCUM = 0x%x\n",
		       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),
		       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));
		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
		       "SINDEX == 0x%x\n, A == 0x%x\n",
		       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),
		       ahc_index_busy_tcl(ahc,
			    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),
				      ahc_inb(ahc, SAVED_LUN))),
		       ahc_inb(ahc, SINDEX),
		       ahc_inb(ahc, ACCUM));
		printf("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
		       "SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",
		       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),
		       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),
		       ahc_inb(ahc, SCB_CONTROL));
		printf("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",
		       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	default:
		printf("ahc_intr: seqint, "
		       "intstat == 0x%x, scsisigi = 0x%x\n",
		       intstat, ahc_inb(ahc, SCSISIGI));
		break;
	}
unpause:
d887 1
a887 3
	 *  The sequencer is paused immediately on
	 *  a SEQINT, so we should restart it when
	 *  we're done.
d889 9
a897 132
	ahc_unpause(ahc);
}

void
ahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat)
{
	u_int	scb_index;
	u_int	status0;
	u_int	status;
	struct	scb *scb;
	char	cur_channel;
	char	intr_channel;

	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);

	if ((ahc->features & AHC_TWIN) != 0
	 && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
		cur_channel = 'B';
	else
		cur_channel = 'A';
	intr_channel = cur_channel;

	if ((ahc->features & AHC_ULTRA2) != 0)
		status0 = ahc_inb(ahc, SSTAT0) & IOERR;
	else
		status0 = 0;
	status = ahc_inb(ahc, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
	if (status == 0 && status0 == 0) {
		if ((ahc->features & AHC_TWIN) != 0) {
			/* Try the other channel */
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			status = ahc_inb(ahc, SSTAT1)
			       & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
			intr_channel = (cur_channel == 'A') ? 'B' : 'A';
		}
		if (status == 0) {
			printf("%s: Spurious SCSI interrupt\n", ahc_name(ahc));
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
			ahc_unpause(ahc);
			return;
		}
	}

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	if (scb != NULL
	 && (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)
		scb = NULL;

	if ((ahc->features & AHC_ULTRA2) != 0
	 && (status0 & IOERR) != 0) {
		int now_lvd;

		now_lvd = ahc_inb(ahc, SBLKCTL) & ENAB40;
		printf("%s: Transceiver State Has Changed to %s mode\n",
		       ahc_name(ahc), now_lvd ? "LVD" : "SE");
		ahc_outb(ahc, CLRSINT0, CLRIOERR);
		/*
		 * When transitioning to SE mode, the reset line
		 * glitches, triggering an arbitration bug in some
		 * Ultra2 controllers.  This bug is cleared when we
		 * assert the reset line.  Since a reset glitch has
		 * already occurred with this transition and a
		 * transceiver state change is handled just like
		 * a bus reset anyway, asserting the reset line
		 * ourselves is safe.
		 */
		ahc_reset_channel(ahc, intr_channel,
				 /*Initiate Reset*/now_lvd == 0);
	} else if ((status & SCSIRSTI) != 0) {
		printf("%s: Someone reset channel %c\n",
			ahc_name(ahc), intr_channel);
		if (intr_channel != cur_channel)
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
		ahc_reset_channel(ahc, intr_channel, /*Initiate Reset*/FALSE);
	} else if ((status & SCSIPERR) != 0) {
		/*
		 * Determine the bus phase and queue an appropriate message.
		 * SCSIPERR is latched true as soon as a parity error
		 * occurs.  If the sequencer acked the transfer that
		 * caused the parity error and the currently presented
		 * transfer on the bus has correct parity, SCSIPERR will
		 * be cleared by CLRSCSIPERR.  Use this to determine if
		 * we should look at the last phase the sequencer recorded,
		 * or the current phase presented on the bus.
		 */
		u_int mesg_out;
		u_int curphase;
		u_int errorphase;
		u_int lastphase;
		u_int scsirate;
		u_int i;
		u_int sstat2;

		lastphase = ahc_inb(ahc, LASTPHASE);
		curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
		sstat2 = ahc_inb(ahc, SSTAT2);
		ahc_outb(ahc, CLRSINT1, CLRSCSIPERR);
		/*
		 * For all phases save DATA, the sequencer won't
		 * automatically ack a byte that has a parity error
		 * in it.  So the only way that the current phase
		 * could be 'data-in' is if the parity error is for
		 * an already acked byte in the data phase.  During
		 * synchronous data-in transfers, we may actually
		 * ack bytes before latching the current phase in
		 * LASTPHASE, leading to the discrepancy between
		 * curphase and lastphase.
		 */
		if ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0
		 || curphase == P_DATAIN || curphase == P_DATAIN_DT)
			errorphase = curphase;
		else
			errorphase = lastphase;

		for (i = 0; i < num_phases; i++) {
			if (errorphase == ahc_phase_table[i].phase)
				break;
		}
		mesg_out = ahc_phase_table[i].mesg_out;
		if (scb != NULL)
			ahc_print_path(ahc, scb);
		else
			printf("%s:%c:%d: ", ahc_name(ahc), intr_channel,
			       SCSIID_TARGET(ahc, ahc_inb(ahc, SAVED_SCSIID)));
		scsirate = ahc_inb(ahc, SCSIRATE);
		printf("parity error detected %s. "
		       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
		       ahc_phase_table[i].phasemsg,
		       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),
		       scsirate);
d899 6
a904 1
		if ((ahc->features & AHC_DT) != 0) {
d906 16
a921 10
			if ((sstat2 & CRCVALERR) != 0)
				printf("\tCRC Value Mismatch\n");
			if ((sstat2 & CRCENDERR) != 0)
				printf("\tNo terminal CRC packet recevied\n");
			if ((sstat2 & CRCREQERR) != 0)
				printf("\tIllegal CRC packet request\n");
			if ((sstat2 & DUAL_EDGE_ERR) != 0)
				printf("\tUnexpected %sDT Data Phase\n",
				       (scsirate & SINGLE_EDGE) ? "" : "non-");
		}
d923 10
a932 17
		/*
		 * We've set the hardware to assert ATN if we   
		 * get a parity error on "in" phases, so all we  
		 * need to do is stuff the message buffer with
		 * the appropriate message.  "In" phases have set
		 * mesg_out to something other than MSG_NOP.
		 */
		if (mesg_out != MSG_NOOP) {
			if (ahc->msg_type != MSG_TYPE_NONE)
				ahc->send_msg_perror = TRUE;
			else
				ahc_outb(ahc, MSG_OUT, mesg_out);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_unpause(ahc);
	} else if ((status & SELTO) != 0) {
		u_int scbptr;
d934 7
a940 2
		/* Stop the selection */
		ahc_outb(ahc, SCSISEQ, 0);
d942 1
a942 2
		/* No more pending messages */
		ahc_clear_msg_state(ahc);
d944 5
a948 3
		/* Clear interrupt state */
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);
d950 2
a951 9
		/*
		 * Although the driver does not care about the
		 * 'Selection in Progress' status bit, the busy
		 * LED does.  SELINGO is only cleared by a sucessfull
		 * selection, so we must manually clear it to insure
		 * the LED turns off just incase no future successful
		 * selections occur (e.g. no devices on the bus).
		 */
		ahc_outb(ahc, CLRSINT0, CLRSELINGO);
d953 2
a954 3
		scbptr = ahc_inb(ahc, WAITING_SCBH);
		ahc_outb(ahc, SCBPTR, scbptr);
		scb_index = ahc_inb(ahc, SCB_TAG);
d956 3
a958 20
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("%s: ahc_intr - referenced scb not "
			       "valid during SELTO scb(%d, %d)\n",
			       ahc_name(ahc), scbptr, scb_index);
		} else {
			ahc_set_transaction_status(scb, CAM_SEL_TIMEOUT);
			ahc_freeze_devq(ahc, scb);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_restart(ahc);
	} else if ((status & BUSFREE) != 0
		&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {
		u_int lastphase;
		u_int saved_scsiid;
		u_int saved_lun;
		u_int target;
		u_int initiator_role_id;
		char channel;
		int printerror;
d960 3
a962 8
		/*
		 * Clear our selection hardware as soon as possible.
		 * We may have an entry in the waiting Q for this target,
		 * that is affected by this busfree and we don't want to
		 * go about selecting the target while we handle the event.
		 */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
d964 3
a966 8
		/*
		 * Disable busfree interrupts and clear the busfree
		 * interrupt status.  We do this here so that several
		 * bus transactions occur prior to clearing the SCSIINT
		 * latch.  It can take a bit for the clearing to take effect.
		 */
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);
d968 1
a968 13
		/*
		 * Look at what phase we were last in.
		 * If its message out, chances are pretty good
		 * that the busfree was in response to one of
		 * our abort requests.
		 */
		lastphase = ahc_inb(ahc, LASTPHASE);
		saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
		saved_lun = ahc_inb(ahc, SAVED_LUN);
		target = SCSIID_TARGET(ahc, saved_scsiid);
		initiator_role_id = SCSIID_OUR_ID(saved_scsiid);
		channel = SCSIID_CHANNEL(ahc, saved_scsiid);
		printerror = 1;
d970 2
a971 3
		if (lastphase == P_MESGOUT) {
			struct ahc_devinfo devinfo;
			u_int tag;
d973 9
a981 49
			ahc_fetch_devinfo(ahc, &devinfo);
			tag = SCB_LIST_NULL;
			if (ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT_TAG, TRUE)
			 || ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT, TRUE)) {
				if (ahc->msgout_buf[ahc->msgout_index - 1]
				 == MSG_ABORT_TAG)
					tag = scb->hscb->tag;
				ahc_print_path(ahc, scb);
				printf("SCB %d - Abort%s Completed.\n",
				       scb->hscb->tag, tag == SCB_LIST_NULL ?
				       "" : " Tag");
				ahc_abort_scbs(ahc, target, channel,
					       saved_lun, tag,
					       ROLE_INITIATOR,
					       CAM_REQ_ABORTED);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_1B,
						MSG_BUS_DEV_RESET, TRUE)) {
				struct ahc_devinfo devinfo;
#ifdef __FreeBSD__
				/*
				 * Don't mark the user's request for this BDR
				 * as completing with CAM_BDR_SENT.  CAM3
				 * specifies CAM_REQ_CMP.
				 */
				if (scb != NULL
				 && scb->io_ctx->ccb_h.func_code== XPT_RESET_DEV
				 && ahc_match_scb(ahc, scb, target, channel,
						  CAM_LUN_WILDCARD,
						  SCB_LIST_NULL,
						  ROLE_INITIATOR)) {
					ahc_set_transaction_status(scb, CAM_REQ_CMP);
				}
#endif
				ahc_compile_devinfo(&devinfo,
						    initiator_role_id,
						    target,
						    CAM_LUN_WILDCARD,
						    channel,
						    ROLE_INITIATOR);
				ahc_handle_devreset(ahc, &devinfo,
						    CAM_BDR_SENT,
						    "Bus Device Reset",
						    /*verbose_level*/0);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_PPR, FALSE)) {
				struct ahc_initiator_tinfo *tinfo;
				struct ahc_tmode_tstate *tstate;
d983 6
a988 38
				/*
				 * PPR Rejected.  Try non-ppr negotiation
				 * and retry command.
				 */
				tinfo = ahc_fetch_transinfo(ahc,
							    devinfo.channel,
							    devinfo.our_scsiid,
							    devinfo.target,
							    &tstate);
				tinfo->curr.transport_version = 2;
				tinfo->goal.transport_version = 2;
				tinfo->goal.ppr_options = 0;
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_WDTR, FALSE)
				|| ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_SDTR, FALSE)) {
				/*
				 * Negotiation Rejected.  Go-async and
				 * retry command.
				 */
				ahc_set_width(ahc, &devinfo,
					      MSG_EXT_WDTR_BUS_8_BIT,
					      AHC_TRANS_CUR|AHC_TRANS_GOAL,
					      /*paused*/TRUE);
				ahc_set_syncrate(ahc, &devinfo,
						/*syncrate*/NULL,
						/*period*/0, /*offset*/0,
						/*ppr_options*/0,
						AHC_TRANS_CUR|AHC_TRANS_GOAL,
						/*paused*/TRUE);
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			}
		}
		if (printerror != 0) {
			u_int i;
d990 1
a990 2
			if (scb != NULL) {
				u_int tag;
d992 6
a997 35
				if ((scb->hscb->control & TAG_ENB) != 0)
					tag = scb->hscb->tag;
				else
					tag = SCB_LIST_NULL;
				ahc_print_path(ahc, scb);
				ahc_abort_scbs(ahc, target, channel,
					       SCB_GET_LUN(scb), tag,
					       ROLE_INITIATOR,
					       CAM_UNEXP_BUSFREE);
			} else {
				/*
				 * We had not fully identified this connection,
				 * so we cannot abort anything.
				 */
				printf("%s: ", ahc_name(ahc));
			}
			for (i = 0; i < num_phases; i++) {
				if (lastphase == ahc_phase_table[i].phase)
					break;
			}
			printf("Unexpected busfree %s\n"
			       "SEQADDR == 0x%x\n",
			       ahc_phase_table[i].phasemsg,
			       ahc_inb(ahc, SEQADDR0)
				| (ahc_inb(ahc, SEQADDR1) << 8));
		}
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_restart(ahc);
	} else {
		printf("%s: Missing case in ahc_handle_scsiint. status = %x\n",
		       ahc_name(ahc), status);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
	}
}
d999 1
a999 8
#define AHC_MAX_STEPS 2000
void
ahc_clear_critical_section(struct ahc_softc *ahc)
{
	int	stepping;
	int	steps;
	u_int	simode0;
	u_int	simode1;
d1001 3
a1003 2
	if (ahc->num_critical_sections == 0)
		return;
d1005 6
a1010 25
	stepping = FALSE;
	steps = 0;
	simode0 = 0;
	simode1 = 0;
	for (;;) {
		struct	cs *cs;
		u_int	seqaddr;
		u_int	i;

		seqaddr = ahc_inb(ahc, SEQADDR0)
			| (ahc_inb(ahc, SEQADDR1) << 8);

		/*
		 * Seqaddr represents the next instruction to execute, 
		 * so we are really executing the instruction just
		 * before it.
		 */
		if (seqaddr != 0)
			seqaddr -= 1;
		cs = ahc->critical_sections;
		for (i = 0; i < ahc->num_critical_sections; i++, cs++) {
			
			if (cs->begin < seqaddr && cs->end >= seqaddr)
				break;
		}
d1012 1
a1012 2
		if (i == ahc->num_critical_sections)
			break;
d1014 4
a1017 6
		if (steps > AHC_MAX_STEPS) {
			printf("%s: Infinite loop in critical section\n",
			       ahc_name(ahc));
			ahc_dump_card_state(ahc);
			panic("critical section loop");
		}
d1019 1
a1019 2
		steps++;
		if (stepping == FALSE) {
d1021 1
a1021 24
			/*
			 * Disable all interrupt sources so that the
			 * sequencer will not be stuck by a pausing
			 * interrupt condition while we attempt to
			 * leave a critical section.
			 */
			simode0 = ahc_inb(ahc, SIMODE0);
			ahc_outb(ahc, SIMODE0, 0);
			simode1 = ahc_inb(ahc, SIMODE1);
			ahc_outb(ahc, SIMODE1, 0);
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
			ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) | STEP);
			stepping = TRUE;
		}
		ahc_outb(ahc, HCNTRL, ahc->unpause);
		do {
			ahc_delay(200);
		} while (!ahc_is_paused(ahc));
	}
	if (stepping) {
		ahc_outb(ahc, SIMODE0, simode0);
		ahc_outb(ahc, SIMODE1, simode1);
		ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) & ~STEP);
	}
d1024 3
a1026 5
/*
 * Clear any pending interrupt status.
 */
void
ahc_clear_intstat(struct ahc_softc *ahc)
d1028 1
a1028 7
	/* Clear any interrupt conditions this may have caused */
	ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
				|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|
				CLRREQINIT);
	ahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);
	ahc_outb(ahc, CLRINT, CLRSCSIINT);
}
d1030 1
a1030 5
/**************************** Debugging Routines ******************************/
void
ahc_print_scb(struct scb *scb)
{
	int i;
d1032 5
a1036 1
	struct hardware_scb *hscb = scb->hscb;
d1038 6
a1043 22
	printf("scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n",
	       (void *)scb,
	       hscb->control,
	       hscb->scsiid,
	       hscb->lun,
	       hscb->cdb_len);
	printf("Shared Data: ");
	for (i = 0; i < sizeof(hscb->shared_data.cdb); i++)
		printf("%#02x", hscb->shared_data.cdb[i]);
	printf("        dataptr:%#x datacnt:%#x sgptr:%#x tag:%#x\n",
		ahc_le32toh(hscb->dataptr),
		ahc_le32toh(hscb->datacnt),
		ahc_le32toh(hscb->sgptr),
		hscb->tag);
	if (scb->sg_count > 0) {
		for (i = 0; i < scb->sg_count; i++) {
			printf("sg[%d] - Addr 0x%x%x : Length %d\n",
			       i,
			       (ahc_le32toh(scb->sg_list[i].len) >> 24
			        & SG_HIGH_ADDR_BITS),
			       ahc_le32toh(scb->sg_list[i].addr),
			       ahc_le32toh(scb->sg_list[i].len));
d1046 16
d1064 5
a1068 7
/************************* Transfer Negotiation *******************************/
/*
 * Allocate per target mode instance (ID we respond to as a target)
 * transfer negotiation data structures.
 */
static struct ahc_tmode_tstate *
ahc_alloc_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel)
d1070 2
a1071 3
	struct ahc_tmode_tstate *master_tstate;
	struct ahc_tmode_tstate *tstate;
	int i;
d1073 5
a1077 12
	master_tstate = ahc->enabled_targets[ahc->our_id];
	if (channel == 'B') {
		scsi_id += 8;
		master_tstate = ahc->enabled_targets[ahc->our_id_b + 8];
	}
	if (ahc->enabled_targets[scsi_id] != NULL
	 && ahc->enabled_targets[scsi_id] != master_tstate)
		panic("%s: ahc_alloc_tstate - Target already allocated",
		      ahc_name(ahc));
	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
	if (tstate == NULL)
		return (NULL);
d1079 1
d1081 1
a1081 4
	 * If we have allocated a master tstate, copy user settings from
	 * the master tstate (taken from SRAM or the EEPROM) for this
	 * channel, but reset our current and goal settings to async/narrow
	 * until an initiator talks to us.
d1083 8
a1090 14
	if (master_tstate != NULL) {
		memcpy(tstate, master_tstate, sizeof(*tstate));
		memset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));
		tstate->ultraenb = 0;
		for (i = 0; i < 16; i++) {
			memset(&tstate->transinfo[i].curr, 0,
			      sizeof(tstate->transinfo[i].curr));
			memset(&tstate->transinfo[i].goal, 0,
			      sizeof(tstate->transinfo[i].goal));
		}
	} else
		memset(tstate, 0, sizeof(*tstate));
	ahc->enabled_targets[scsi_id] = tstate;
	return (tstate);
d1093 3
a1095 7
#ifdef AHC_TARGET_MODE
/*
 * Free per target mode instance (ID we respond to as a target)
 * transfer negotiation data structures.
 */
static void
ahc_free_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel, int force)
d1097 8
a1104 2
	struct ahc_tmode_tstate *tstate;

d1106 1
a1106 2
	 * Don't clean up our "master" tstate.
	 * It has our default user settings.
d1108 10
a1117 4
	if (((channel == 'B' && scsi_id == ahc->our_id_b)
	  || (channel == 'A' && scsi_id == ahc->our_id))
	 && force == FALSE)
		return;
d1119 22
a1140 6
	if (channel == 'B')
		scsi_id += 8;
	tstate = ahc->enabled_targets[scsi_id];
	if (tstate != NULL)
		free(tstate, M_DEVBUF);
	ahc->enabled_targets[scsi_id] = NULL;
a1141 1
#endif
d1146 1
a1146 2
 * by the capabilities of the bus connectivity of and sync settings for
 * the target.
d1148 5
a1152 5
struct ahc_syncrate *
ahc_devlimited_syncrate(struct ahc_softc *ahc,
			struct ahc_initiator_tinfo *tinfo,
			u_int *period, u_int *ppr_options, role_t role) {
	struct	ahc_transinfo *transinfo;
d1158 1
a1158 1
			maxsync = AHC_SYNCRATE_DT;
a1160 2
			/* Can't do DT on an SE bus */
			*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1167 1
a1167 22
	/*
	 * Never allow a value higher than our current goal
	 * period otherwise we may allow a target initiated
	 * negotiation to go above the limit as set by the
	 * user.  In the case of an initiator initiated
	 * sync negotiation, we limit based on the user
	 * setting.  This allows the system to still accept
	 * incoming negotiations even if target initiated
	 * negotiation is not performed.
	 */
	if (role == ROLE_TARGET)
		transinfo = &tinfo->user;
	else 
		transinfo = &tinfo->goal;
	*ppr_options &= transinfo->ppr_options;
	if (transinfo->period == 0) {
		*period = 0;
		*ppr_options = 0;
		return (NULL);
	}
	*period = MAX(*period, transinfo->period);
	return (ahc_find_syncrate(ahc, period, ppr_options, maxsync));
d1175 5
a1179 3
struct ahc_syncrate *
ahc_find_syncrate(struct ahc_softc *ahc, u_int *period,
		  u_int *ppr_options, u_int maxsync)
d1183 4
a1186 19
	if ((ahc->features & AHC_DT) == 0)
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;

	/* Skip all DT only entries if DT is not available */
	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0
	 && maxsync < AHC_SYNCRATE_ULTRA2)
		maxsync = AHC_SYNCRATE_ULTRA2;
	
	for (syncrate = &ahc_syncrates[maxsync];
	     syncrate->rate != NULL;
	     syncrate++) {

		/*
		 * The Ultra2 table doesn't go as low
		 * as for the Fast/Ultra cards.
		 */
		if ((ahc->features & AHC_ULTRA2) != 0
		 && (syncrate->sxfr_u2 == 0))
			break;
a1201 7

			/*
			 * At some speeds, we only support
			 * ST transfers.
			 */
		 	if ((syncrate->sxfr_u2 & ST_SXFR) != 0)
				*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1204 1
a1213 1
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1218 5
a1222 6
/*
 * Convert from an entry in our syncrate table to the SCSI equivalent
 * sync "period" factor.
 */
u_int
ahc_find_period(struct ahc_softc *ahc, u_int scsirate, u_int maxsync)
d1247 6
a1252 9
/*
 * Truncate the given synchronous offset to a value the
 * current adapter type and syncrate are capable of.
 */
void
ahc_validate_offset(struct ahc_softc *ahc,
		    struct ahc_initiator_tinfo *tinfo,
		    struct ahc_syncrate *syncrate,
		    u_int *offset, int wide, role_t role)
a1267 6
	if (tinfo != NULL) {
		if (role == ROLE_TARGET)
			*offset = MIN(*offset, tinfo->user.offset);
		else
			*offset = MIN(*offset, tinfo->goal.offset);
	}
d1270 7
a1276 7
/*
 * Truncate the given transfer width parameter to a value the
 * current adapter type is capable of.
 */
void
ahc_validate_width(struct ahc_softc *ahc, struct ahc_initiator_tinfo *tinfo,
		   u_int *bus_width, role_t role)
d1278 1
a1278 19
	switch (*bus_width) {
	default:
		if (ahc->features & AHC_WIDE) {
			/* Respond Wide */
			*bus_width = MSG_EXT_WDTR_BUS_16_BIT;
			break;
		}
		/* FALLTHROUGH */
	case MSG_EXT_WDTR_BUS_8_BIT:
		*bus_width = MSG_EXT_WDTR_BUS_8_BIT;
		break;
	}
	if (tinfo != NULL) {
		if (role == ROLE_TARGET)
			*bus_width = MIN(tinfo->user.width, *bus_width);
		else
			*bus_width = MIN(tinfo->goal.width, *bus_width);
	}
}
d1280 7
a1286 23
/*
 * Update the bitmask of targets for which the controller should
 * negotiate with at the next convenient oportunity.  This currently
 * means the next time we send the initial identify messages for
 * a new transaction.
 */
int
ahc_update_neg_request(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		       struct ahc_tmode_tstate *tstate,
		       struct ahc_initiator_tinfo *tinfo, int force)
{
	u_int auto_negotiate_orig;

	auto_negotiate_orig = tstate->auto_negotiate;
	if (tinfo->curr.period != tinfo->goal.period
	 || tinfo->curr.width != tinfo->goal.width
	 || tinfo->curr.offset != tinfo->goal.offset
	 || tinfo->curr.ppr_options != tinfo->goal.ppr_options
	 || (force
	  && (tinfo->goal.period != 0
	   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT
	   || tinfo->goal.ppr_options != 0)))
		tstate->auto_negotiate |= devinfo->target_mask;
d1288 22
a1309 1
		tstate->auto_negotiate &= ~devinfo->target_mask;
d1311 4
a1314 1
	return (auto_negotiate_orig != tstate->auto_negotiate);
d1317 10
a1326 12
/*
 * Update the user/goal/curr tables of synchronous negotiation
 * parameters as well as, in the case of a current or active update,
 * any data structures on the host controller.  In the case of an
 * active update, the specified target is currently talking to us on
 * the bus, so the transfer parameter update must take effect
 * immediately.
 */
void
ahc_set_syncrate(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		 struct ahc_syncrate *syncrate, u_int period,
		 u_int offset, u_int ppr_options, u_int type, int paused)
d1329 1
a1329 1
	struct	ahc_tmode_tstate *tstate;
d1332 1
a1332 6
	u_int	old_ppr;
	int	active;
	int	update_needed;

	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
	update_needed = 0;
d1339 2
a1340 1
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
d1342 2
a1343 16

	if ((type & AHC_TRANS_USER) != 0) {
		tinfo->user.period = period;
		tinfo->user.offset = offset;
		tinfo->user.ppr_options = ppr_options;
	}

	if ((type & AHC_TRANS_GOAL) != 0) {
		tinfo->goal.period = period;
		tinfo->goal.offset = offset;
		tinfo->goal.ppr_options = ppr_options;
	}

	old_period = tinfo->curr.period;
	old_offset = tinfo->curr.offset;
	old_ppr	   = tinfo->curr.ppr_options;
d1346 1
a1346 3
	 && (old_period != period
	  || old_offset != offset
	  || old_ppr != ppr_options)) {
a1348 1
		update_needed++;
d1352 2
d1355 5
a1359 7
			if (syncrate != NULL) {
				scsirate |= syncrate->sxfr_u2;
				if ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0)
					scsirate |= ENABLE_CRC;
				else
					scsirate |= SINGLE_EDGE;
			}
d1386 1
a1386 1
		if (active) {
a1387 3
			if ((ahc->features & AHC_ULTRA2) != 0)
				ahc_outb(ahc, SCSIOFFSET, offset);
		}
d1390 20
a1409 18
		tinfo->curr.period = period;
		tinfo->curr.offset = offset;
		tinfo->curr.ppr_options = ppr_options;

		ahc_send_async(ahc, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (1 /*bootverbose*/) {
			if (offset != 0) {
				printf("%s: target %d synchronous at %sMHz%s, "
				       "offset = 0x%x\n", ahc_name(ahc),
				       devinfo->target, syncrate->rate,
				       (ppr_options & MSG_EXT_PPR_DT_REQ)
				       ? " DT" : "", offset);
			} else {
				printf("%s: target %d using "
				       "asynchronous transfers\n",
				       ahc_name(ahc), devinfo->target);
			}
d1413 9
a1421 2
	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
						tinfo, /*force*/FALSE);
d1423 3
a1425 2
	if (update_needed)
		ahc_update_pending_scbs(ahc);
d1428 8
a1435 11
/*
 * Update the user/goal/curr tables of wide negotiation
 * parameters as well as, in the case of a current or active update,
 * any data structures on the host controller.  In the case of an
 * active update, the specified target is currently talking to us on
 * the bus, so the transfer parameter update must take effect
 * immediately.
 */
void
ahc_set_width(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
	      u_int width, u_int type, int paused)
d1437 4
a1440 5
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	u_int	oldwidth;
	int	active;
	int	update_needed;
d1442 5
a1446 10
	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
	update_needed = 0;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);

	if ((type & AHC_TRANS_USER) != 0)
		tinfo->user.width = width;

	if ((type & AHC_TRANS_GOAL) != 0)
		tinfo->goal.width = width;
a1447 1
	oldwidth = tinfo->curr.width;
a1450 1
		update_needed++;
d1461 2
a1462 1
		tinfo->curr.width = width;
d1464 4
a1467 7
		ahc_send_async(ahc, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (bootverbose) {
			printf("%s: target %d using %dbit transfers\n",
			       ahc_name(ahc), devinfo->target,
			       8 * (0x01 << width));
		}
d1470 7
a1476 4
	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
						tinfo, /*force*/FALSE);
	if (update_needed)
		ahc_update_pending_scbs(ahc);
d1479 5
a1483 6
/*
 * Update the current state of tagged queuing for a given target.
 */
void
ahc_set_tags(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
	     ahc_queue_alg alg)
d1485 13
a1497 3
 	ahc_platform_set_tags(ahc, devinfo, alg);
 	ahc_send_async(ahc, devinfo->channel, devinfo->target,
 		       devinfo->lun, AC_TRANSFER_NEG, &alg);
d1501 1
a1501 3
 * When the transfer settings for a connection change, update any
 * in-transit SCBs to contain the new data so the hardware will
 * be set correctly during future (re)selections.
d1503 3
a1505 2
static void
ahc_update_pending_scbs(struct ahc_softc *ahc)
d1507 4
a1510 5
	struct	scb *pending_scb;
	int	pending_scb_count;
	int	i;
	int	paused;
	u_int	saved_scbptr;
d1512 4
d1517 1
a1517 2
	 * Traverse the pending SCB list and ensure that all of the
	 * SCBs there have the proper settings.
d1519 15
a1533 25
	pending_scb_count = 0;
	LIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {
		struct ahc_devinfo devinfo;
		struct hardware_scb *pending_hscb;
		struct ahc_initiator_tinfo *tinfo;
		struct ahc_tmode_tstate *tstate;

		ahc_scb_devinfo(ahc, &devinfo, pending_scb);
		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
					    devinfo.our_scsiid,
					    devinfo.target, &tstate);
		pending_hscb = pending_scb->hscb;
		pending_hscb->control &= ~ULTRAENB;
		if ((tstate->ultraenb & devinfo.target_mask) != 0)
			pending_hscb->control |= ULTRAENB;
		pending_hscb->scsirate = tinfo->scsirate;
		pending_hscb->scsioffset = tinfo->curr.offset;
		if ((tstate->auto_negotiate & devinfo.target_mask) == 0
		 && (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {
			pending_scb->flags &= ~SCB_AUTO_NEGOTIATE;
			pending_hscb->control &= ~MK_MESSAGE;
		}
		ahc_sync_scb(ahc, pending_scb,
			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
		pending_scb_count++;
d1536 6
a1541 2
	if (pending_scb_count == 0)
		return;
d1543 3
a1545 2
	if (ahc_is_paused(ahc)) {
		paused = 1;
d1547 5
a1551 16
		paused = 0;
		ahc_pause(ahc);
	}

	saved_scbptr = ahc_inb(ahc, SCBPTR);
	/* Ensure that the hscbs down on the card match the new information */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		struct	hardware_scb *pending_hscb;
		u_int	control;
		u_int	scb_tag;

		ahc_outb(ahc, SCBPTR, i);
		scb_tag = ahc_inb(ahc, SCB_TAG);
		pending_scb = ahc_lookup_scb(ahc, scb_tag);
		if (pending_scb == NULL)
			continue;
d1553 3
a1555 7
		pending_hscb = pending_scb->hscb;
		control = ahc_inb(ahc, SCB_CONTROL);
		control &= ~(ULTRAENB|MK_MESSAGE);
		control |= pending_hscb->control & (ULTRAENB|MK_MESSAGE);
		ahc_outb(ahc, SCB_CONTROL, control);
		ahc_outb(ahc, SCB_SCSIRATE, pending_hscb->scsirate);
		ahc_outb(ahc, SCB_SCSIOFFSET, pending_hscb->scsioffset);
d1557 1
a1557 4
	ahc_outb(ahc, SCBPTR, saved_scbptr);

	if (paused == 0)
		ahc_unpause(ahc);
d1560 4
a1563 3
/**************************** Pathing Information *****************************/
static void
ahc_fetch_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
d1565 1
a1565 1
	u_int	saved_scsiid;
d1584 3
a1586 6
	saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
	ahc_compile_devinfo(devinfo,
			    our_id,
			    SCSIID_TARGET(ahc, saved_scsiid),
			    ahc_inb(ahc, SAVED_LUN),
			    SCSIID_CHANNEL(ahc, saved_scsiid),
d1590 8
a1597 21
struct ahc_phase_table_entry*
ahc_lookup_phase_entry(int phase)
{
	struct ahc_phase_table_entry *entry;
	struct ahc_phase_table_entry *last_entry;

	/*
	 * num_phases doesn't include the default entry which
	 * will be returned if the phase doesn't match.
	 */
	last_entry = &ahc_phase_table[num_phases];
	for (entry = ahc_phase_table; entry < last_entry; entry++) {
		if (phase == entry->phase)
			break;
	}
	return (entry);
}

void
ahc_compile_devinfo(struct ahc_devinfo *devinfo, u_int our_id, u_int target,
		    u_int lun, char channel, role_t role)
a1609 28
static void
ahc_scb_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		struct scb *scb)
{
	role_t	role;
	int	our_id;

	our_id = SCSIID_OUR_ID(scb->hscb->scsiid);
	role = ROLE_INITIATOR;
	if ((scb->hscb->control & TARGET_SCB) != 0)
		role = ROLE_TARGET;
	ahc_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahc, scb),
			    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahc, scb), role);
}


/************************ Message Phase Processing ****************************/
static void
ahc_assert_atn(struct ahc_softc *ahc)
{
	u_int scsisigo;

	scsisigo = ATNO;
	if ((ahc->features & AHC_DT) == 0)
		scsisigo |= ahc_inb(ahc, SCSISIGI);
	ahc_outb(ahc, SCSISIGO, scsisigo);
}

d1611 1
a1611 4
 * When an initiator transaction with the MK_MESSAGE flag either reconnects
 * or enters the initial message out phase, we are interrupted.  Fill our
 * outgoing message buffer with the appropriate message and beging handing
 * the message phase(s) manually.
d1613 2
a1614 3
static void
ahc_setup_initiator_msgout(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
			   struct scb *scb)
d1616 2
a1617 7
	/*
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;
d1619 1
a1619 3
	if ((scb->flags & SCB_DEVICE_RESET) == 0
	 && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {
		u_int identify_msg;
d1621 1
a1621 5
		identify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);
		if ((scb->hscb->control & DISCENB) != 0)
			identify_msg |= MSG_IDENTIFY_DISCFLAG;
		ahc->msgout_buf[ahc->msgout_index++] = identify_msg;
		ahc->msgout_len++;
d1623 19
a1641 5
		if ((scb->hscb->control & TAG_ENB) != 0) {
			ahc->msgout_buf[ahc->msgout_index++] =
			    scb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);
			ahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;
			ahc->msgout_len += 2;
d1643 1
d1646 5
a1650 5
	if (scb->flags & SCB_DEVICE_RESET) {
		ahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;
		ahc->msgout_len++;
		ahc_print_path(ahc, scb);
		printf("Bus Device Reset Message Sent\n");
d1652 2
a1653 5
		 * Clear our selection hardware in advance of
		 * the busfree.  We may have an entry in the waiting
		 * Q for this target, and we don't want to go about
		 * selecting while we handle the busfree and blow it
		 * away.
d1655 15
a1669 28
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else if ((scb->flags & SCB_ABORT) != 0) {
		if ((scb->hscb->control & TAG_ENB) != 0)
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;
		else
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;
		ahc->msgout_len++;
		ahc_print_path(ahc, scb);
		printf("Abort%s Message Sent\n",
		       (scb->hscb->control & TAG_ENB) != 0 ? " Tag" : "");
		/*
		 * Clear our selection hardware in advance of
		 * the busfree.  We may have an entry in the waiting
		 * Q for this target, and we don't want to go about
		 * selecting while we handle the busfree and blow it
		 * away.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {
		ahc_build_transfer_msg(ahc, devinfo);
	} else {
		printf("ahc_intr: AWAITING_MSG for an SCB that "
		       "does not have a waiting message\n");
		printf("SCSIID = %x, target_mask = %x\n", scb->hscb->scsiid,
		       devinfo->target_mask);
		panic("SCB = %d, SCB Control = %x, MSG_OUT = %x "
		      "SCB flags = %x", scb->hscb->tag, scb->hscb->control,
		      ahc_inb(ahc, MSG_OUT), scb->flags);
d1671 2
d1674 3
a1676 8
	/*
	 * Clear the MK_MESSAGE flag from the SCB so we aren't
	 * asked to send this message again.
	 */
	ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);
	scb->hscb->control &= ~MK_MESSAGE;
	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
d1679 5
a1683 6
/*
 * Build an appropriate transfer negotiation message for the
 * currently active target.
 */
static void
ahc_build_transfer_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
d1685 3
a1687 15
	/*
	 * We need to initiate transfer negotiations.
	 * If our current and goal settings are identical,
	 * we want to renegotiate due to a check condition.
	 */
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	struct	ahc_syncrate *rate;
	int	dowide;
	int	dosync;
	int	doppr;
	int	use_ppr;
	u_int	period;
	u_int	ppr_options;
	u_int	offset;
d1689 4
a1692 23
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	/*
	 * Filter our period based on the current connection.
	 * If we can't perform DT transfers on this segment (not in LVD
	 * mode for instance), then our decision to issue a PPR message
	 * may change.
	 */
	period = tinfo->goal.period;
	ppr_options = tinfo->goal.ppr_options;
	/* Target initiated PPR is not allowed in the SCSI spec */
	if (devinfo->role == ROLE_TARGET)
		ppr_options = 0;
	rate = ahc_devlimited_syncrate(ahc, tinfo, &period,
				       &ppr_options, devinfo->role);
	dowide = tinfo->curr.width != tinfo->goal.width;
	dosync = tinfo->curr.period != period;
	doppr = tinfo->curr.ppr_options != ppr_options;

	if (!dowide && !dosync && !doppr) {
		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
		dosync = tinfo->goal.period != 0;
		doppr = tinfo->goal.ppr_options != 0;
d1694 7
d1702 22
a1723 4
	if (!dowide && !dosync && !doppr) {
		panic("ahc_intr: AWAITING_MSG for negotiation, "
		      "but no negotiation needed\n");	
	}
d1725 9
a1733 4
	use_ppr = (tinfo->curr.transport_version >= 3) || doppr;
	/* Target initiated PPR is not allowed in the SCSI spec */
	if (devinfo->role == ROLE_TARGET)
		use_ppr = 0;
d1736 4
a1739 6
	 * Both the PPR message and SDTR message require the
	 * goal syncrate to be limited to what the target device
	 * is capable of handling (based on whether an LVD->SE
	 * expander is on the bus), so combine these two cases.
	 * Regardless, guarantee that if we are using WDTR and SDTR
	 * messages that WDTR comes first.
d1741 7
a1747 1
	if (use_ppr || (dosync && !dowide)) {
d1749 13
a1761 13
		offset = tinfo->goal.offset;
		ahc_validate_offset(ahc, tinfo, rate, &offset,
				    use_ppr ? tinfo->goal.width
					    : tinfo->curr.width,
				    devinfo->role);
		if (use_ppr) {
			ahc_construct_ppr(ahc, devinfo, period, offset,
					  tinfo->goal.width, ppr_options);
		} else {
			ahc_construct_sdtr(ahc, devinfo, period, offset);
		}
	} else {
		ahc_construct_wdtr(ahc, devinfo, tinfo->goal.width);
d1763 13
a1775 20
}

/*
 * Build a synchronous negotiation message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_sdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		   u_int period, u_int offset)
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_len += 5;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       devinfo->lun, period, offset);
d1777 10
a1786 1
}
d1788 10
a1797 17
/*
 * Build a wide negotiateion message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_wdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		   u_int bus_width)
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_len += 4;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending WDTR %x\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       devinfo->lun, bus_width);
d1799 3
a1801 1
}
d1803 14
a1816 23
/*
 * Build a parallel protocol request message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_ppr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		  u_int period, u_int offset, u_int bus_width,
		  u_int ppr_options)
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = 0;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_buf[ahc->msgout_index++] = ppr_options;
	ahc->msgout_len += 8;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "
		       "offset %x, ppr_options %x\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target, devinfo->lun,
		       bus_width, period, offset, ppr_options);
d1818 16
a1833 1
}
a1834 10
/*
 * Clear any active message state.
 */
static void
ahc_clear_msg_state(struct ahc_softc *ahc)
{
	ahc->msgout_len = 0;
	ahc->msgin_index = 0;
	ahc->msg_type = MSG_TYPE_NONE;
	if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0) {
d1836 3
a1838 2
		 * The target didn't care to respond to our
		 * message request, so clear ATN.
d1840 58
a1897 4
		ahc_outb(ahc, CLRSINT1, CLRATNO);
	}
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
}
d1899 10
a1908 9
/*
 * Manual message loop handler.
 */
static void
ahc_handle_message_phase(struct ahc_softc *ahc)
{ 
	struct	ahc_devinfo devinfo;
	u_int	bus_phase;
	int	end_session;
d1910 6
a1915 3
	ahc_fetch_devinfo(ahc, &devinfo);
	end_session = FALSE;
	bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
d1917 5
a1921 7
reswitch:
	switch (ahc->msg_type) {
	case MSG_TYPE_INITIATOR_MSGOUT:
	{
		int lastbyte;
		int phasemis;
		int msgdone;
d1923 48
a1970 2
		if (ahc->msgout_len == 0)
			panic("HOST_MSG_LOOP interrupt with no active message");
a1971 3
		phasemis = bus_phase != P_MESGOUT;
		if (phasemis) {
			if (bus_phase == P_MESGIN) {
d1973 2
a1974 4
				 * Change gears and see if
				 * this messages is of interest to
				 * us or should be passed back to
				 * the sequencer.
d1976 2
a1977 5
				ahc_outb(ahc, CLRSINT1, CLRATNO);
				ahc->send_msg_perror = FALSE;
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;
				ahc->msgin_index = 0;
				goto reswitch;
a1978 8
			end_session = TRUE;
			break;
		}

		if (ahc->send_msg_perror) {
			ahc_outb(ahc, CLRSINT1, CLRATNO);
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
			ahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);
d1980 1
a1980 4
		}

		msgdone	= ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
d1982 2
a1983 3
			 * The target has requested a retry.
			 * Re-assert ATN, reset our message index to
			 * 0, and try again.
d1985 3
a1987 2
			ahc->msgout_index = 0;
			ahc_assert_atn(ahc);
a1988 13

		lastbyte = ahc->msgout_index == (ahc->msgout_len - 1);
		if (lastbyte) {
			/* Last byte is signified by dropping ATN */
			ahc_outb(ahc, CLRSINT1, CLRATNO);
		}

		/*
		 * Clear our interrupt status and present
		 * the next byte on the bus.
		 */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
d1991 12
a2002 1
	case MSG_TYPE_INITIATOR_MSGIN:
d2004 12
a2015 2
		int phasemis;
		int message_done;
d2017 12
a2028 10
		phasemis = bus_phase != P_MESGIN;

		if (phasemis) {
			ahc->msgin_index = 0;
			if (bus_phase == P_MESGOUT
			 && (ahc->send_msg_perror == TRUE
			  || (ahc->msgout_len != 0
			   && ahc->msgout_index == 0))) {
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
				goto reswitch;
a2029 3
			end_session = TRUE;
			break;
		}
d2031 3
a2033 2
		/* Pull the byte in without acking it */
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);
d2035 2
a2036 1
		message_done = ahc_parse_msg(ahc, &devinfo);
d2038 19
a2056 16
		if (message_done) {
			/*
			 * Clear our incoming message buffer in case there
			 * is another message following this one.
			 */
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response,
			 * assert ATN so the target takes us to the
			 * message out phase.
			 */
			if (ahc->msgout_len != 0)
				ahc_assert_atn(ahc);
		} else 
			ahc->msgin_index++;
d2058 2
a2059 3
		/* Ack the byte */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_inb(ahc, SCSIDATL);
d2062 1
a2062 1
	case MSG_TYPE_TARGET_MSGIN:
a2063 6
		int msgdone;
		int msgout_request;

		if (ahc->msgout_len == 0)
			panic("Target MSGIN with no active message");

d2065 9
a2073 4
		 * If we interrupted a mesgout session, the initiator
		 * will not know this until our first REQ.  So, we
		 * only honor mesgout requests after we've sent our
		 * first byte.
d2075 3
a2077 7
		if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0
		 && ahc->msgout_index > 0)
			msgout_request = TRUE;
		else
			msgout_request = FALSE;

		if (msgout_request) {
d2080 4
a2083 4
			 * Change gears and see if
			 * this messages is of interest to
			 * us or should be passed back to
			 * the sequencer.
d2085 3
a2087 4
			ahc->msg_type = MSG_TYPE_TARGET_MSGOUT;
			ahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);
			ahc->msgin_index = 0;
			/* Dummy read to REQ for first byte */
a2088 11
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
			break;
		}

		msgdone = ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
			end_session = TRUE;
			break;
a2089 6

		/*
		 * Present the next byte on the bus.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
d2092 1
a2092 1
	case MSG_TYPE_TARGET_MSGOUT:
a2093 3
		int lastbyte;
		int msgdone;

d2095 6
a2100 2
		 * The initiator signals that this is
		 * the last byte by dropping ATN.
d2102 3
a2104 1
		lastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;
d2106 4
a2109 16
		/*
		 * Read the latched byte, but turn off SPIOEN first
		 * so that we don't inadvertantly cause a REQ for the
		 * next byte.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);
		msgdone = ahc_parse_msg(ahc, &devinfo);
		if (msgdone == MSGLOOP_TERMINATED) {
			/*
			 * The message is *really* done in that it caused
			 * us to go to bus free.  The sequencer has already
			 * been reset at this point, so pull the ejection
			 * handle.
			 */
			return;
d2111 15
a2125 21
		
		ahc->msgin_index++;

		/*
		 * XXX Read spec about initiator dropping ATN too soon
		 *     and use msgdone to detect it.
		 */
		if (msgdone == MSGLOOP_MSGCOMPLETE) {
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response, transition
			 * to the Message in phase and send it.
			 */
			if (ahc->msgout_len != 0) {
				ahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);
				ahc_outb(ahc, SXFRCTL0,
					 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
				ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
				ahc->msgin_index = 0;
				break;
d2128 32
a2159 9

		if (lastbyte)
			end_session = TRUE;
		else {
			/* Ask for the next byte. */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		}

d2162 7
d2170 4
a2173 1
		panic("Unknown REQINIT message type");
d2175 8
a2182 6

	if (end_session) {
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);
	} else
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
d2185 4
a2188 8
/*
 * See if we sent a particular extended message to the target.
 * If "full" is true, return true only if the target saw the full
 * message.  If "full" is false, return true if the target saw at
 * least the first byte of the message.
 */
static int
ahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type, u_int msgval, int full)
d2190 12
a2201 2
	int found;
	u_int index;
d2203 14
a2216 2
	found = FALSE;
	index = 0;
d2218 8
a2225 3
	while (index < ahc->msgout_len) {
		if (ahc->msgout_buf[index] == MSG_EXTENDED) {
			u_int end_index;
d2227 20
a2246 3
			end_index = index + 1 + ahc->msgout_buf[index + 1];
			if (ahc->msgout_buf[index+2] == msgval
			 && type == AHCMSG_EXT) {
d2248 19
a2266 9
				if (full) {
					if (ahc->msgout_index > end_index)
						found = TRUE;
				} else if (ahc->msgout_index > index)
					found = TRUE;
			}
			index = end_index;
		} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_TASK
			&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
d2268 3
a2270 9
			/* Skip tag type and tag id or residue param*/
			index += 2;
		} else {
			/* Single byte message */
			if (type == AHCMSG_1B
			 && ahc->msgout_buf[index] == msgval
			 && ahc->msgout_index > index)
				found = TRUE;
			index++;
d2272 13
d2286 29
a2314 5
		if (found)
			break;
	}
	return (found);
}
d2316 5
a2320 12
/*
 * Wait for a complete incoming message, parse it, and respond accordingly.
 */
static int
ahc_parse_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	int	reject;
	int	done;
	int	response;
	u_int	targ_scsirate;
d2322 16
a2337 41
	done = MSGLOOP_IN_PROG;
	response = FALSE;
	reject = FALSE;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	targ_scsirate = tinfo->scsirate;

	/*
	 * Parse as much of the message as is availible,
	 * rejecting it if we don't support it.  When
	 * the entire message is availible and has been
	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
	 * that we have parsed an entire message.
	 *
	 * In the case of extended messages, we accept the length
	 * byte outright and perform more checking once we know the
	 * extended message type.
	 */
	switch (ahc->msgin_buf[0]) {
	case MSG_MESSAGE_REJECT:
		response = ahc_handle_msg_reject(ahc, devinfo);
		/* FALLTHROUGH */
	case MSG_NOOP:
		done = MSGLOOP_MSGCOMPLETE;
		break;
	case MSG_EXTENDED:
	{
		/* Wait for enough of the message to begin validation */
		if (ahc->msgin_index < 2)
			break;
		switch (ahc->msgin_buf[2]) {
		case MSG_EXT_SDTR:
		{
			struct	 ahc_syncrate *syncrate;
			u_int	 period;
			u_int	 ppr_options;
			u_int	 offset;
			u_int	 saved_offset;
			
			if (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
				reject = TRUE;
d2339 3
a2341 1
			}
d2343 19
a2361 8
			/*
			 * Wait until we have both args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_SDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))
a2362 53

			period = ahc->msgin_buf[3];
			ppr_options = 0;
			saved_offset = offset = ahc->msgin_buf[4];
			syncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,
							   &ppr_options,
							   devinfo->role);
			ahc_validate_offset(ahc, tinfo, syncrate, &offset,
					    targ_scsirate & WIDEXFER,
					    devinfo->role);
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received "
				       "SDTR period %x, offset %x\n\t"
				       "Filtered to period %x, offset %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       ahc->msgin_buf[3], saved_offset,
				       period, offset);
			}
			ahc_set_syncrate(ahc, devinfo, 
					 syncrate, period,
					 offset, ppr_options,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE);

			/*
			 * See if we initiated Sync Negotiation
			 * and didn't have to fall down to async
			 * transfers.
			 */
			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, TRUE)) {
				/* We started it */
				if (saved_offset != offset) {
					/* Went too low - force async */
					reject = TRUE;
				}
			} else {
				/*
				 * Send our own SDTR in reply
				 */
				if (bootverbose
				 && devinfo->role == ROLE_INITIATOR) {
					printf("(%s:%c:%d:%d): Target "
					       "Initiated SDTR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_sdtr(ahc, devinfo,
						   period, offset);
				ahc->msgout_index = 0;
				response = TRUE;
d2364 1
a2364 12
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		case MSG_EXT_WDTR:
		{
			u_int bus_width;
			u_int saved_width;
			u_int sending_reply;

			sending_reply = FALSE;
			if (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
				reject = TRUE;
d2367 3
d2371 2
a2372 9
			/*
			 * Wait until we have our arg before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_WDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))
				break;
d2374 9
a2382 28
			bus_width = ahc->msgin_buf[3];
			saved_width = bus_width;
			ahc_validate_width(ahc, tinfo, &bus_width,
					   devinfo->role);
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received WDTR "
				       "%x filtered to %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       saved_width, bus_width);
			}

			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, TRUE)) {
				/*
				 * Don't send a WDTR back to the
				 * target, since we asked first.
				 * If the width went higher than our
				 * request, reject it.
				 */
				if (saved_width > bus_width) {
					reject = TRUE;
					printf("(%s:%c:%d:%d): requested %dBit "
					       "transfers.  Rejecting...\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun,
					       8 * (0x01 << bus_width));
					bus_width = 0;
				}
d2385 2
a2386 1
				 * Send our own WDTR in reply
d2388 1
a2388 13
				if (bootverbose
				 && devinfo->role == ROLE_INITIATOR) {
					printf("(%s:%c:%d:%d): Target "
					       "Initiated WDTR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_wdtr(ahc, devinfo, bus_width);
				ahc->msgout_index = 0;
				response = TRUE;
				sending_reply = TRUE;
d2390 3
a2392 17
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE);
			/* After a wide message, we are async */
			ahc_set_syncrate(ahc, devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, /*ppr_options*/0,
					 AHC_TRANS_ACTIVE, /*paused*/TRUE);
			if (sending_reply == FALSE && reject == FALSE) {

				if (tinfo->goal.period) {
					ahc->msgout_index = 0;
					ahc->msgout_len = 0;
					ahc_build_transfer_msg(ahc, devinfo);
					ahc->msgout_index = 0;
					response = TRUE;
				}
d2394 4
a2397 2
			done = MSGLOOP_MSGCOMPLETE;
			break;
d2399 7
a2405 10
		case MSG_EXT_PPR:
		{
			struct	ahc_syncrate *syncrate;
			u_int	period;
			u_int	offset;
			u_int	bus_width;
			u_int	ppr_options;
			u_int	saved_width;
			u_int	saved_offset;
			u_int	saved_ppr_options;
d2407 3
a2409 4
			if (ahc->msgin_buf[1] != MSG_EXT_PPR_LEN) {
				reject = TRUE;
				break;
			}
d2411 6
a2416 9
			/*
			 * Wait until we have all args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_PPR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_PPR_LEN + 1))
				break;
d2418 6
a2423 15
			period = ahc->msgin_buf[3];
			offset = ahc->msgin_buf[5];
			bus_width = ahc->msgin_buf[6];
			saved_width = bus_width;
			ppr_options = ahc->msgin_buf[7];
			/*
			 * According to the spec, a DT only
			 * period factor with no DT option
			 * set implies async.
			 */
			if ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0
			 && period == 9)
				offset = 0;
			saved_ppr_options = ppr_options;
			saved_offset = offset;
d2425 3
a2427 17
			/*
			 * Mask out any options we don't support
			 * on any controller.  Transfer options are
			 * only available if we are negotiating wide.
			 */
			ppr_options &= MSG_EXT_PPR_DT_REQ;
			if (bus_width == 0)
				ppr_options = 0;

			ahc_validate_width(ahc, tinfo, &bus_width,
					   devinfo->role);
			syncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,
							   &ppr_options,
							   devinfo->role);
			ahc_validate_offset(ahc, tinfo, syncrate,
					    &offset, bus_width,
					    devinfo->role);
d2429 3
a2431 55
			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, TRUE)) {
				/*
				 * If we are unable to do any of the
				 * requested options (we went too low),
				 * then we'll have to reject the message.
				 */
				if (saved_width > bus_width
				 || saved_offset != offset
				 || saved_ppr_options != ppr_options) {
					reject = TRUE;
					period = 0;
					offset = 0;
					bus_width = 0;
					ppr_options = 0;
					syncrate = NULL;
				}
			} else {
				if (devinfo->role != ROLE_TARGET)
					printf("(%s:%c:%d:%d): Target "
					       "Initiated PPR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				else
					printf("(%s:%c:%d:%d): Initiator "
					       "Initiated PPR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_ppr(ahc, devinfo, period, offset,
						  bus_width, ppr_options);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received PPR width %x, "
				       "period %x, offset %x,options %x\n"
				       "\tFiltered to width %x, period %x, "
				       "offset %x, options %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       saved_width, ahc->msgin_buf[3],
				       saved_offset, saved_ppr_options,
				       bus_width, period, offset, ppr_options);
			}
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE);
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period,
					 offset, ppr_options,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE);
			done = MSGLOOP_MSGCOMPLETE;
			break;
d2433 71
a2503 6
		default:
			/* Unknown extended message.  Reject it. */
			reject = TRUE;
			break;
		}
		break;
d2505 19
a2523 23
	case MSG_BUS_DEV_RESET:
		ahc_handle_devreset(ahc, devinfo,
				    CAM_BDR_SENT,
				    "Bus Device Reset Received",
				    /*verbose_level*/0);
		ahc_restart(ahc);
		done = MSGLOOP_TERMINATED;
		break;
	case MSG_ABORT_TAG:
	case MSG_ABORT:
	case MSG_CLEAR_QUEUE:
#ifdef AHC_TARGET_MODE
		/* Target mode messages */
		if (devinfo->role != ROLE_TARGET) {
			reject = TRUE;
			break;
		}
		ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       devinfo->lun,
			       ahc->msgin_buf[0] == MSG_ABORT_TAG
						  ? SCB_LIST_NULL
						  : ahc_inb(ahc, INITIATOR_TAG),
			       ROLE_TARGET, CAM_REQ_ABORTED);
d2525 5
a2529 3
		tstate = ahc->enabled_targets[devinfo->our_scsiid];
		if (tstate != NULL) {
			struct ahc_tmode_lstate* lstate;
d2531 5
a2535 8
			lstate = tstate->enabled_luns[devinfo->lun];
			if (lstate != NULL) {
				ahc_queue_lstate_event(ahc, lstate,
						       devinfo->our_scsiid,
						       ahc->msgin_buf[0],
						       /*arg*/0);
				ahc_send_lstate_events(ahc, lstate);
			}
a2536 7
		done = MSGLOOP_MSGCOMPLETE;
		break;
#endif
	case MSG_TERM_IO_PROC:
	default:
		reject = TRUE;
		break;
d2539 45
a2583 10
	if (reject) {
		/*
		 * Setup to reject the message.
		 */
		ahc->msgout_index = 0;
		ahc->msgout_len = 1;
		ahc->msgout_buf[0] = MSG_MESSAGE_REJECT;
		done = MSGLOOP_MSGCOMPLETE;
		response = TRUE;
	}
d2585 4
a2588 3
	if (done != MSGLOOP_IN_PROG && !response)
		/* Clear the outgoing message buffer */
		ahc->msgout_len = 0;
d2590 2
a2591 1
	return (done);
d2594 4
a2597 5
/*
 * Process a message reject message.
 */
static int
ahc_handle_msg_reject(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
a2605 2
	struct ahc_initiator_tinfo *tinfo;
	struct ahc_tmode_tstate *tstate;
d2611 2
a2612 4
	scb = ahc_lookup_scb(ahc, scb_index);
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
d2616 3
a2618 20
	if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, /*full*/FALSE)) {
		/*
		 * Target does not support the PPR message.
		 * Attempt to negotiate SPI-2 style.
		 */
		if (bootverbose) {
			printf("(%s:%c:%d:%d): PPR Rejected. "
			       "Trying WDTR/SDTR\n",
			       ahc_name(ahc), devinfo->channel,
			       devinfo->target, devinfo->lun);
		}
		tinfo->goal.ppr_options = 0;
		tinfo->curr.transport_version = 2;
		tinfo->goal.transport_version = 2;
		ahc->msgout_index = 0;
		ahc->msgout_len = 0;
		ahc_build_transfer_msg(ahc, devinfo);
		ahc->msgout_index = 0;
		response = 1;
	} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, /*full*/FALSE)) {
d2621 6
a2626 4
		printf("(%s:%c:%d:%d): refuses WIDE negotiation.  Using "
		       "8bit transfers\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target, devinfo->lun);
		ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
d2628 1
a2628 1
			      /*paused*/TRUE);
d2636 3
d2640 1
d2643 2
d2647 1
a2647 1
			ahc_build_transfer_msg(ahc, devinfo);
d2651 1
a2651 1
	} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, /*full*/FALSE)) {
d2654 1
a2654 1
				 /*offset*/0, /*ppr_options*/0,
d2656 14
a2669 26
				 /*paused*/TRUE);
		printf("(%s:%c:%d:%d): refuses synchronous negotiation. "
		       "Using asynchronous transfers\n",
		       ahc_name(ahc), devinfo->channel,
		       devinfo->target, devinfo->lun);
	} else if ((scb->hscb->control & MSG_SIMPLE_TASK) != 0) {
		int tag_type;
		int mask;

		tag_type = (scb->hscb->control & MSG_SIMPLE_TASK);

		if (tag_type == MSG_SIMPLE_TASK) {
			printf("(%s:%c:%d:%d): refuses tagged commands.  "
			       "Performing non-tagged I/O\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target, devinfo->lun);
			ahc_set_tags(ahc, devinfo, AHC_QUEUE_NONE);
			mask = ~0x23;
		} else {
			printf("(%s:%c:%d:%d): refuses %s tagged commands.  "
			       "Performing simple queue tagged I/O only\n",
			       ahc_name(ahc), devinfo->channel, devinfo->target,
			       devinfo->lun, tag_type == MSG_ORDERED_TASK
			       ? "ordered" : "head of queue");
			ahc_set_tags(ahc, devinfo, AHC_QUEUE_BASIC);
			mask = ~0x03;
		}
d2675 3
a2677 5
		ahc_outb(ahc, SCB_CONTROL,
			 ahc_inb(ahc, SCB_CONTROL) & mask);
	 	scb->hscb->control &= mask;
		ahc_set_transaction_tag(scb, /*enabled*/FALSE,
					/*type*/MSG_SIMPLE_TASK);
d2679 1
a2679 16
		ahc_assert_atn(ahc);

		/*
		 * This transaction is now at the head of
		 * the untagged queue for this target.
		 */
		if ((ahc->flags & AHC_SCB_BTT) == 0) {
			struct scb_tailq *untagged_q;

			untagged_q =
			    &(ahc->untagged_queues[devinfo->target_offset]);
			TAILQ_INSERT_HEAD(untagged_q, scb, links.tqe);
			scb->flags |= SCB_UNTAGGEDQ;
		}
		ahc_busy_tcl(ahc, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),
			     scb->hscb->tag);
d2686 3
a2688 4
		ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
				   SCB_GET_CHANNEL(ahc, scb),
				   SCB_GET_LUN(scb), /*tag*/SCB_LIST_NULL,
				   ROLE_INITIATOR, CAM_REQUEUE_REQ,
d2701 3
a2703 5
/*
 * Process an ingnore wide residue message.
 */
static void
ahc_handle_ign_wide_residue(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
d2705 5
a2709 2
	u_int scb_index;
	struct scb *scb;
d2711 8
a2718 21
	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	/*
	 * XXX Actually check data direction in the sequencer?
	 * Perhaps add datadir to some spare bits in the hscb?
	 */
	if ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0
	 || ahc_get_transfer_dir(scb) != CAM_DIR_IN) {
		/*
		 * Ignore the message if we haven't
		 * seen an appropriate data phase yet.
		 */
	} else {
		/*
		 * If the residual occurred on the last
		 * transfer and the transfer request was
		 * expected to end on an odd count, do
		 * nothing.  Otherwise, subtract a byte
		 * and update the residual count accordingly.
		 */
		uint32_t sgptr;
d2720 3
a2722 24
		sgptr = ahc_inb(ahc, SCB_RESIDUAL_SGPTR);
		if ((sgptr & SG_LIST_NULL) != 0
		 && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {
			/*
			 * If the residual occurred on the last
			 * transfer and the transfer request was
			 * expected to end on an odd count, do
			 * nothing.
			 */
		} else {
			struct ahc_dma_seg *sg;
			uint32_t data_cnt;
			uint32_t data_addr;
			uint32_t sglen;

			/* Pull in the rest of the sgptr */
			sgptr |= (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8);
			sgptr &= SG_PTR_MASK;
			data_cnt = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+3) << 24)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+2) << 16)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+1) << 8)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT));
d2724 7
a2730 4
			data_addr = (ahc_inb(ahc, SHADDR + 3) << 24)
				  | (ahc_inb(ahc, SHADDR + 2) << 16)
				  | (ahc_inb(ahc, SHADDR + 1) << 8)
				  | (ahc_inb(ahc, SHADDR));
d2732 2
a2733 2
			data_cnt += 1;
			data_addr -= 1;
d2735 3
a2737 12
			sg = ahc_sg_bus_to_virt(scb, sgptr);
			/*
			 * The residual sg ptr points to the next S/G
			 * to load so we must go back one.
			 */
			sg--;
			sglen = ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
			if (sg != scb->sg_list
			 && sglen < (data_cnt & AHC_SG_LEN_MASK)) {

				sg--;
				sglen = ahc_le32toh(sg->len);
d2739 4
a2742 2
				 * Preserve High Address and SG_LIST bits
				 * while setting the count to 1.
d2744 5
a2748 17
				data_cnt = 1 | (sglen & (~AHC_SG_LEN_MASK));
				data_addr = ahc_le32toh(sg->addr)
					  + (sglen & AHC_SG_LEN_MASK) - 1;

				/*
				 * Increment sg so it points to the
				 * "next" sg.
				 */
				sg++;
				sgptr = ahc_sg_virt_to_bus(scb, sg);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 3,
					 sgptr >> 24);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 2,
					 sgptr >> 16);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 1,
					 sgptr >> 8);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR, sgptr);
d2750 3
d2754 5
a2758 4
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 3, data_cnt >> 24);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 2, data_cnt >> 16);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 1, data_cnt >> 8);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT, data_cnt);
a2759 2
	}
}
d2761 10
d2772 4
a2775 91
/*
 * Reinitialize the data pointers for the active transfer
 * based on its current residual.
 */
static void
ahc_reinitialize_dataptrs(struct ahc_softc *ahc)
{
	struct	 scb *scb;
	struct	 ahc_dma_seg *sg;
	u_int	 scb_index;
	uint32_t sgptr;
	uint32_t resid;
	uint32_t dataptr;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	sgptr = (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
	      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
	      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8)
	      |	ahc_inb(ahc, SCB_RESIDUAL_SGPTR);

	sgptr &= SG_PTR_MASK;
	sg = ahc_sg_bus_to_virt(scb, sgptr);

	/* The residual sg_ptr always points to the next sg */
	sg--;

	resid = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 2) << 16)
	      | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 1) << 8)
	      | ahc_inb(ahc, SCB_RESIDUAL_DATACNT);

	dataptr = ahc_le32toh(sg->addr)
		+ (ahc_le32toh(sg->len) & AHC_SG_LEN_MASK)
		- resid;
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		u_int dscommand1;

		dscommand1 = ahc_inb(ahc, DSCOMMAND1);
		ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
		ahc_outb(ahc, HADDR,
			 (ahc_le32toh(sg->len) >> 24) & SG_HIGH_ADDR_BITS);
		ahc_outb(ahc, DSCOMMAND1, dscommand1);
	}
	ahc_outb(ahc, HADDR + 3, dataptr >> 24);
	ahc_outb(ahc, HADDR + 2, dataptr >> 16);
	ahc_outb(ahc, HADDR + 1, dataptr >> 8);
	ahc_outb(ahc, HADDR, dataptr);
	ahc_outb(ahc, HCNT + 2, resid >> 16);
	ahc_outb(ahc, HCNT + 1, resid >> 8);
	ahc_outb(ahc, HCNT, resid);
	if ((ahc->features & AHC_ULTRA2) == 0) {
		ahc_outb(ahc, STCNT + 2, resid >> 16);
		ahc_outb(ahc, STCNT + 1, resid >> 8);
		ahc_outb(ahc, STCNT, resid);
	}
}

/*
 * Handle the effects of issuing a bus device reset message.
 */
static void
ahc_handle_devreset(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		    cam_status status, char *message, int verbose_level)
{
#ifdef AHC_TARGET_MODE
	struct ahc_tmode_tstate* tstate;
	u_int lun;
#endif
	int found;

	found = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       CAM_LUN_WILDCARD, SCB_LIST_NULL, devinfo->role,
			       status);

#ifdef AHC_TARGET_MODE
	/*
	 * Send an immediate notify ccb to all target mord peripheral
	 * drivers affected by this action.
	 */
	tstate = ahc->enabled_targets[devinfo->our_scsiid];
	if (tstate != NULL) {
		for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
			struct ahc_tmode_lstate* lstate;

			lstate = tstate->enabled_luns[lun];
			if (lstate == NULL)
				continue;

			ahc_queue_lstate_event(ahc, lstate, devinfo->our_scsiid,
					       MSG_BUS_DEV_RESET, /*arg*/0);
			ahc_send_lstate_events(ahc, lstate);
a2776 2
	}
#endif
d2778 7
a2784 61
	/*
	 * Go back to async/narrow transfers and renegotiate.
	 */
	ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
		      AHC_TRANS_CUR, /*paused*/TRUE);
	ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,
			 /*period*/0, /*offset*/0, /*ppr_options*/0,
			 AHC_TRANS_CUR, /*paused*/TRUE);
	
	ahc_send_async(ahc, devinfo->channel, devinfo->target,
		       CAM_LUN_WILDCARD, AC_SENT_BDR, NULL);

	if (message != NULL
	 && (verbose_level <= bootverbose))
		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahc_name(ahc),
		       message, devinfo->channel, devinfo->target, found);
}

#ifdef AHC_TARGET_MODE
static void
ahc_setup_target_msgin(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		       struct scb *scb)
{

	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)
		ahc_build_transfer_msg(ahc, devinfo);
	else
		panic("ahc_intr: AWAITING target message with no message");

	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
}
#endif
/**************************** Initialization **********************************/
/*
 * Allocate a controller structure for a new device
 * and perform initial initializion.
 */
struct ahc_softc *
ahc_alloc(void *platform_arg, char *name)
{
	struct  ahc_softc *ahc;
	int	i;

#ifdef __OpenBSD__	/* OpenBSD provides softc! */
	ahc = (struct ahc_softc *)platform_arg;
#else 
#ifndef	__FreeBSD__
	ahc = malloc(sizeof(*ahc), M_DEVBUF, M_NOWAIT);
	if (!ahc) {
		printf("aic7xxx: cannot malloc softc!\n");
		free(name, M_DEVBUF);
		return NULL;
d2786 4
a2789 25
#else
	ahc = device_get_softc((device_t)platform_arg);
#endif
	memset(ahc, 0, sizeof(*ahc));
#endif 
	LIST_INIT(&ahc->pending_scbs);
	/* We don't know our unit number until the OSM sets it */
	ahc->name = name;
	ahc->unit = -1;
	ahc->description = NULL;
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	ahc->chip = AHC_NONE;
	ahc->features = AHC_FENONE;
	ahc->bugs = AHC_BUGNONE;
	ahc->flags = AHC_FNONE;

	for (i = 0; i < 16; i++)
		TAILQ_INIT(&ahc->untagged_queues[i]);
	if (ahc_platform_alloc(ahc, platform_arg) != 0) {
		ahc_free(ahc);
		ahc = NULL;
	}
	return (ahc);
}
d2791 1
a2791 3
int
ahc_softc_init(struct ahc_softc *ahc)
{
d2793 8
a2800 55
	/* The IRQMS bit is only valid on VL and EISA chips */
	if ((ahc->chip & AHC_PCI) == 0)
		ahc->unpause = ahc_inb(ahc, HCNTRL) & IRQMS;
	else
		ahc->unpause = 0;
	ahc->pause = ahc->unpause | PAUSE; 
	/* XXX The shared scb data stuff should be deprecated */
	if (ahc->scb_data == NULL) {
		ahc->scb_data = malloc(sizeof(*ahc->scb_data),
				       M_DEVBUF, M_NOWAIT);
		if (ahc->scb_data == NULL)
			return (ENOMEM);
		memset(ahc->scb_data, 0, sizeof(*ahc->scb_data));
	}

	return (0);
}

void
ahc_softc_insert(struct ahc_softc *ahc)
{
	struct ahc_softc *list_ahc;

#if AHC_PCI_CONFIG > 0
	/*
	 * Second Function PCI devices need to inherit some
	 * settings from function 0.
	 */
	if ((ahc->chip & AHC_BUS_MASK) == AHC_PCI
	 && (ahc->features & AHC_MULTI_FUNC) != 0) {
		TAILQ_FOREACH(list_ahc, &ahc_tailq, links) {
			ahc_dev_softc_t list_pci;
			ahc_dev_softc_t pci;

			list_pci = list_ahc->dev_softc;
			pci = ahc->dev_softc;
			if (ahc_get_pci_slot(list_pci) == ahc_get_pci_slot(pci)
			 && ahc_get_pci_bus(list_pci) == ahc_get_pci_bus(pci)) {
				struct ahc_softc *master;
				struct ahc_softc *slave;

				if (ahc_get_pci_function(list_pci) == 0) {
					master = list_ahc;
					slave = ahc;
				} else {
					master = ahc;
					slave = list_ahc;
				}
				slave->flags &= ~AHC_BIOS_ENABLED; 
				slave->flags |=
				    master->flags & AHC_BIOS_ENABLED;
				slave->flags &= ~AHC_PRIMARY_CHANNEL; 
				slave->flags |=
				    master->flags & AHC_PRIMARY_CHANNEL;
				break;
d2802 2
a2804 2
	}
#endif
d2806 2
a2807 13
	/*
	 * Insertion sort into our list of softcs.
	 */
	list_ahc = TAILQ_FIRST(&ahc_tailq);
	while (list_ahc != NULL
	    && ahc_softc_comp(list_ahc, ahc) <= 0)
		list_ahc = TAILQ_NEXT(list_ahc, links);
	if (list_ahc != NULL)
		TAILQ_INSERT_BEFORE(list_ahc, ahc, links);
	else
		TAILQ_INSERT_TAIL(&ahc_tailq, ahc, links);
	ahc->init_level++;
}
d2809 1
a2809 5
void
ahc_set_unit(struct ahc_softc *ahc, int unit)
{
	ahc->unit = unit;
}
d2811 6
a2816 7
void
ahc_set_name(struct ahc_softc *ahc, char *name)
{
	if (ahc->name != NULL)
		free(ahc->name, M_DEVBUF);
	ahc->name = name;
}
d2818 10
a2827 5
#ifndef __OpenBSD__
void
ahc_free(struct ahc_softc *ahc)
{
	int i;
d2829 3
a2831 25
	ahc_fini_scbdata(ahc);
	switch (ahc->init_level) {
	default:
	case 5:
		ahc_shutdown(ahc);
		TAILQ_REMOVE(&ahc_tailq, ahc, links);
		/* FALLTHROUGH */
	case 4:
		ahc_dmamap_unload(ahc, ahc->shared_data_dmat,
				  ahc->shared_data_dmamap);
		/* FALLTHROUGH */
	case 3:
		ahc_dmamem_free(ahc, ahc->shared_data_dmat, ahc->qoutfifo,
				ahc->shared_data_dmamap);
		ahc_dmamap_destroy(ahc, ahc->shared_data_dmat,
				   ahc->shared_data_dmamap);
		/* FALLTHROUGH */
	case 2:
		ahc_dma_tag_destroy(ahc, ahc->shared_data_dmat);
	case 1:
#ifndef __linux__
		ahc_dma_tag_destroy(ahc, ahc->buffer_dmat);
#endif
		break;
	case 0:
d2834 4
d2839 2
a2840 6
#ifndef __linux__
	ahc_dma_tag_destroy(ahc, ahc->parent_dmat);
#endif
	ahc_platform_free(ahc);
	for (i = 0; i < AHC_NUM_TARGETS; i++) {
		struct ahc_tmode_tstate *tstate;
d2842 11
a2852 4
		tstate = ahc->enabled_targets[i];
		if (tstate != NULL) {
#if AHC_TARGET_MODE
			int j;
d2854 1
a2854 2
			for (j = 0; j < AHC_NUM_LUNS; j++) {
				struct ahc_tmode_lstate *lstate;
d2856 14
a2869 8
				lstate = tstate->enabled_luns[j];
				if (lstate != NULL) {
					xpt_free_path(lstate->path);
					free(lstate, M_DEVBUF);
				}
			}
#endif
			free(tstate, M_DEVBUF);
a2870 15
	}
#if AHC_TARGET_MODE
	if (ahc->black_hole != NULL) {
		xpt_free_path(ahc->black_hole->path);
		free(ahc->black_hole, M_DEVBUF);
	}
#endif
	if (ahc->name != NULL)
		free(ahc->name, M_DEVBUF);
#ifndef __FreeBSD__
	free(ahc, M_DEVBUF);
#endif
	return;
}
#endif /* __OpenBSD__ */
d2872 7
a2878 5
void
ahc_shutdown(void *arg)
{
	struct	ahc_softc *ahc;
	int	i;
d2880 11
a2890 1
	ahc = (struct ahc_softc *)arg;
d2892 5
a2896 5
	/* This will reset most registers to 0, but not all */
	ahc_reset(ahc);
	ahc_outb(ahc, SCSISEQ, 0);
	ahc_outb(ahc, SXFRCTL0, 0);
	ahc_outb(ahc, DSPCISTATUS, 0);
d2898 19
a2916 24
	for (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)
		ahc_outb(ahc, i, 0);
}

/*
 * Reset the controller and record some information about it
 * that is only availabel just after a reset.
 */
int
ahc_reset(struct ahc_softc *ahc)
{
	u_int	sblkctl;
	u_int	sxfrctl1_a, sxfrctl1_b;
	int	wait;
	
	/*
	 * Preserve the value of the SXFRCTL1 register for all channels.
	 * It contains settings that affect termination and we don't want
	 * to disturb the integrity of the bus.
	 */
	ahc_pause(ahc);
	sxfrctl1_b = 0;
	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7770) {
		u_int sblkctl;
d2919 2
a2920 2
		 * Save channel B's settings in case this chip
		 * is setup for TWIN channel operation.
d2922 2
a2923 6
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		sxfrctl1_b = ahc_inb(ahc, SXFRCTL1);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	sxfrctl1_a = ahc_inb(ahc, SXFRCTL1);
d2925 13
a2937 1
	ahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);
d2939 7
a2945 7
	/*
	 * Ensure that the reset has finished
	 */
	wait = 1000;
	do {
		ahc_delay(1000);
	} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));
d2947 1
a2947 3
	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", ahc_name(ahc));
a2948 19
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/* Determine channel configuration */
	sblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);
	/* No Twin Channel PCI cards */
	if ((ahc->chip & AHC_PCI) != 0)
		sblkctl &= ~SELBUSB;
	switch (sblkctl) {
	case 0:
		/* Single Narrow Channel */
		break;
	case 2:
		/* Wide Channel */
		ahc->features |= AHC_WIDE;
		break;
	case 8:
		/* Twin Channel */
		ahc->features |= AHC_TWIN;
		break;
d2950 1
a2950 2
		printf(" Unsupported adapter type.  Ignoring\n");
		return(-1);
d2953 6
a2958 10
	/*
	 * Reload sxfrctl1.
	 *
	 * We must always initialize STPWEN to 1 before we
	 * restore the saved values.  STPWEN is initialized
	 * to a tri-state condition which can only be cleared
	 * by turning it on.
	 */
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;
d2960 14
a2973 6
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		ahc_outb(ahc, SXFRCTL1, sxfrctl1_b);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	ahc_outb(ahc, SXFRCTL1, sxfrctl1_a);
d2975 2
a2976 4
#ifdef AHC_DUMP_SEQ
	if (ahc->init_level == 0)
		ahc_dumpseq(ahc);
#endif
d2978 2
a2979 9
	return (0);
}

/*
 * Determine the number of SCBs available on the controller
 */
int
ahc_probe_scbs(struct ahc_softc *ahc) {
	int i;
d2981 3
a2983 1
	for (i = 0; i < AHC_SCB_MAX; i++) {
d2985 8
a2992 6
		ahc_outb(ahc, SCBPTR, i);
		ahc_outb(ahc, SCB_BASE, i);
		if (ahc_inb(ahc, SCB_BASE) != i)
			break;
		ahc_outb(ahc, SCBPTR, 0);
		if (ahc_inb(ahc, SCB_BASE) != 0)
d2994 9
d3004 1
a3004 1
	return (i);
d3007 5
a3011 3
#ifndef __OpenBSD__
static void
ahc_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) 
d3013 6
a3018 1
	bus_addr_t *baddr;
d3020 6
a3025 4
	baddr = (bus_addr_t *)arg;
	*baddr = segs->ds_addr;
}
#endif 
d3027 30
a3056 23
#ifndef __OpenBSD__
static void
#else
void
#endif 
ahc_build_free_scb_list(struct ahc_softc *ahc)
{
	int i;

	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		ahc_outb(ahc, SCBPTR, i);

		/* Clear the control byte. */
		ahc_outb(ahc, SCB_CONTROL, 0);

		/* Set the next pointer */
		if ((ahc->flags & AHC_PAGESCBS) != 0)
			ahc_outb(ahc, SCB_NEXT, i+1);
		else 
			ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);

		/* Make the tag number invalid */
		ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
d3058 17
d3076 9
a3084 3
	/* Make sure that the last SCB terminates the free list */
	ahc_outb(ahc, SCBPTR, i-1);
	ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);
d3086 9
a3094 4
	/* Ensure we clear the 0 SCB's control byte. */
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outb(ahc, SCB_CONTROL, 0);
}
d3096 30
a3125 5
#ifndef __OpenBSD__
static int
ahc_init_scbdata(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;
d3127 5
a3131 3
	scb_data = ahc->scb_data;
	SLIST_INIT(&scb_data->free_scbs);
	SLIST_INIT(&scb_data->sg_maps);
d3133 9
a3141 7
	/* Allocate SCB resources */
	scb_data->scbarray =
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,
				 M_DEVBUF, M_NOWAIT);
	if (scb_data->scbarray == NULL)
		return (ENOMEM);
	memset(scb_data->scbarray, 0, sizeof(struct scb) * AHC_SCB_MAX);
d3143 54
a3196 1
	/* Determine the number of hardware SCBs and initialize them */
d3198 6
a3203 7
	scb_data->maxhscbs = ahc_probe_scbs(ahc);
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		/* SCB 0 heads the free list */
		ahc_outb(ahc, FREE_SCBH, 0);
	} else {
		ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	}
d3205 28
a3232 3
	if (ahc->scb_data->maxhscbs == 0) {
		printf("%s: No SCB space found\n", ahc_name(ahc));
		return (ENXIO);
d3234 21
d3256 3
a3258 1
	ahc_build_free_scb_list(ahc);
d3260 18
a3277 21
	/*
	 * Create our DMA tags.  These tags define the kinds of device
	 * accessible memory allocations and memory mappings we will
	 * need to perform during normal operation.
	 *
	 * Unless we need to further restrict the allocation, we rely
	 * on the restrictions of the parent dmat, hence the common
	 * use of MAXADDR and MAXSIZE.
	 */

	/* DMA tag for our hardware scb structures */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       AHC_SCB_MAX * sizeof(struct hardware_scb),
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->hscb_dmat) != 0) {
		goto error_exit;
d3280 9
a3288 7
	scb_data->init_level++;

	/* Allocation for our hscbs */
	if (ahc_dmamem_alloc(ahc, scb_data->hscb_dmat,
			     (void **)&scb_data->hscbs,
			     BUS_DMA_NOWAIT, &scb_data->hscb_dmamap) != 0) {
		goto error_exit;
d3291 3
a3293 1
	scb_data->init_level++;
d3295 2
a3296 5
	/* And permanently map them */
	ahc_dmamap_load(ahc, scb_data->hscb_dmat, scb_data->hscb_dmamap,
			scb_data->hscbs,
			AHC_SCB_MAX * sizeof(struct hardware_scb),
			ahc_dmamap_cb, &scb_data->hscb_busaddr, /*flags*/0);
d3298 7
a3304 1
	scb_data->init_level++;
d3306 17
a3322 12
	/* DMA tag for our sense buffers */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->sense_dmat) != 0) {
		goto error_exit;
	}
d3324 17
a3340 1
	scb_data->init_level++;
d3342 4
a3345 6
	/* Allocate them */
	if (ahc_dmamem_alloc(ahc, scb_data->sense_dmat,
			     (void **)&scb_data->sense,
			     BUS_DMA_NOWAIT, &scb_data->sense_dmamap) != 0) {
		goto error_exit;
	}
d3347 2
a3348 1
	scb_data->init_level++;
d3350 1
a3350 5
	/* And permanently map them */
	ahc_dmamap_load(ahc, scb_data->sense_dmat, scb_data->sense_dmamap,
			scb_data->sense,
			AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			ahc_dmamap_cb, &scb_data->sense_busaddr, /*flags*/0);
d3352 22
a3373 13
	scb_data->init_level++;

	/* DMA tag for our S/G structures.  We allocate in page sized chunks */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       PAGE_SIZE, /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->sg_dmat) != 0) {
		goto error_exit;
	}
d3375 3
a3377 1
	scb_data->init_level++;
d3379 5
a3383 9
	/* Perform initial CCB allocation */
	memset(scb_data->hscbs, 0, AHC_SCB_MAX * sizeof(struct hardware_scb));
	ahc_alloc_scbs(ahc);

	if (scb_data->numscbs == 0) {
		printf("%s: ahc_init_scbdata - "
		       "Unable to allocate initial scbs\n",
		       ahc_name(ahc));
		goto error_exit;
d3385 1
d3387 9
a3395 5
	/*
	 * Tell the sequencer which SCB will be the next one it receives.
	 */
	ahc->next_queued_scb = ahc_get_scb(ahc);
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);
d3397 4
d3402 3
a3404 1
	 * Note that we were successfull
d3406 10
a3415 5
	return (0); 

error_exit:

	return (ENOMEM);
d3418 9
a3426 2
static void
ahc_fini_scbdata(struct ahc_softc *ahc)
d3428 4
a3431 1
	struct scb_data *scb_data;
d3433 3
a3435 3
	scb_data = ahc->scb_data;
	if (scb_data == NULL)
		return;
d3437 1
a3437 5
	switch (scb_data->init_level) {
	default:
	case 7:
	{
		struct sg_map_node *sg_map;
d3439 5
a3443 10
		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
			ahc_dmamap_unload(ahc, scb_data->sg_dmat,
					  sg_map->sg_dmamap);
			ahc_dmamem_free(ahc, scb_data->sg_dmat,
					sg_map->sg_vaddr,
					sg_map->sg_dmamap);
			free(sg_map, M_DEVBUF);
		}
		ahc_dma_tag_destroy(ahc, scb_data->sg_dmat);
d3445 14
a3458 23
	case 6:
		ahc_dmamap_unload(ahc, scb_data->sense_dmat,
				  scb_data->sense_dmamap);
	case 5:
		ahc_dmamem_free(ahc, scb_data->sense_dmat, scb_data->sense,
				scb_data->sense_dmamap);
		ahc_dmamap_destroy(ahc, scb_data->sense_dmat,
				   scb_data->sense_dmamap);
	case 4:
		ahc_dma_tag_destroy(ahc, scb_data->sense_dmat);
	case 3:
		ahc_dmamap_unload(ahc, scb_data->hscb_dmat,
				  scb_data->hscb_dmamap);
	case 2:
		ahc_dmamem_free(ahc, scb_data->hscb_dmat, scb_data->hscbs,
				scb_data->hscb_dmamap);
		ahc_dmamap_destroy(ahc, scb_data->hscb_dmat,
				   scb_data->hscb_dmamap);
	case 1:
		ahc_dma_tag_destroy(ahc, scb_data->hscb_dmat);
		break;
	case 0:
		break;
a3459 3
	if (scb_data->scbarray != NULL)
		free(scb_data->scbarray, M_DEVBUF);
}
d3461 7
a3467 10
void
ahc_alloc_scbs(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;
	struct scb *next_scb;
	struct sg_map_node *sg_map;
	bus_addr_t physaddr;
	struct ahc_dma_seg *segs;
	int newcount;
	int i;
d3469 5
a3473 4
	scb_data = ahc->scb_data;
	if (scb_data->numscbs >= AHC_SCB_MAX)
		/* Can't allocate any more */
		return;
d3475 1
a3475 1
	next_scb = &scb_data->scbarray[scb_data->numscbs];
d3477 8
a3484 1
	sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);
d3486 5
a3490 2
	if (sg_map == NULL)
		return;
d3492 12
a3503 6
	/* Allocate S/G space for the next batch of SCBS */
	if (ahc_dmamem_alloc(ahc, scb_data->sg_dmat,
			     (void **)&sg_map->sg_vaddr,
			     BUS_DMA_NOWAIT, &sg_map->sg_dmamap) != 0) {
		free(sg_map, M_DEVBUF);
		return;
d3506 26
a3531 8
	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);

	ahc_dmamap_load(ahc, scb_data->sg_dmat, sg_map->sg_dmamap,
			sg_map->sg_vaddr, PAGE_SIZE, ahc_dmamap_cb,
			&sg_map->sg_physaddr, /*flags*/0);

	segs = sg_map->sg_vaddr;
	physaddr = sg_map->sg_physaddr;
d3533 1
a3533 13
	newcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));
	for (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {
		struct scb_platform_data *pdata;
#ifndef __linux__
		int error;
#endif
		pdata = (struct scb_platform_data *)malloc(sizeof(*pdata),
							   M_DEVBUF, M_NOWAIT);
		if (pdata == NULL)
			break;
		next_scb->platform_data = pdata;
		next_scb->sg_map = sg_map;
		next_scb->sg_list = segs;
d3535 2
a3536 2
		 * The sequencer always starts with the second entry.
		 * The first entry is embedded in the scb.
d3538 10
a3547 17
		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
		next_scb->ahc_softc = ahc;
		next_scb->flags = SCB_FREE;
#ifndef __linux__
		error = ahc_dmamap_create(ahc, ahc->buffer_dmat, /*flags*/0,
					  &next_scb->dmamap);
		if (error != 0)
			break;
#endif
		next_scb->hscb = &scb_data->hscbs[scb_data->numscbs];
		next_scb->hscb->tag = ahc->scb_data->numscbs;
		SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs,
				  next_scb, links.sle);
		segs += AHC_NSEG;
		physaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));
		next_scb++;
		ahc->scb_data->numscbs++;
d3549 11
a3560 1
#endif /* __OpenBSD__ */
d3562 6
a3567 2
void
ahc_controller_info(struct ahc_softc *ahc, char *buf)
d3569 1
a3569 1
	int len;
d3571 8
a3578 26
	len = sprintf(buf, "%s: ", ahc_chip_names[ahc->chip & AHC_CHIPID_MASK]);
	buf += len;
	if ((ahc->features & AHC_TWIN) != 0)
 		len = sprintf(buf, "Twin Channel, A SCSI Id=%d, "
			      "B SCSI Id=%d, primary %c, ",
			      ahc->our_id, ahc->our_id_b,
			      (ahc->flags & AHC_PRIMARY_CHANNEL) + 'A');
	else {
		const char *speed;
		const char *type;

		speed = "";
		if ((ahc->features & AHC_ULTRA) != 0) {
			speed = "Ultra ";
		} else if ((ahc->features & AHC_DT) != 0) {
			speed = "Ultra160 ";
		} else if ((ahc->features & AHC_ULTRA2) != 0) {
			speed = "Ultra2 ";
		}
		if ((ahc->features & AHC_WIDE) != 0) {
			type = "Wide";
		} else {
			type = "Single";
		}
		len = sprintf(buf, "%s%s Channel %c, SCSI Id=%d, ",
			      speed, type, ahc->channel, ahc->our_id);
d3580 2
a3581 7
	buf += len;

	if ((ahc->flags & AHC_PAGESCBS) != 0)
		sprintf(buf, "%d/%d SCBs",
			ahc->scb_data->maxhscbs, AHC_SCB_MAX);
	else
		sprintf(buf, "%d SCBs", ahc->scb_data->maxhscbs);
d3588 2
a3589 1
ahc_init(struct ahc_softc *ahc)
d3591 11
a3601 14
	int	 max_targ;
	int	 i;
	int	 term;
	u_int	 scsi_conf;
	u_int	 scsiseq_template;
	u_int	 ultraenb;
	u_int	 discenable;
	u_int	 tagenable;
	size_t	 driver_data_size;
	uint32_t physaddr;

#ifdef AHC_DEBUG_SEQUENCER
	ahc->flags |= AHC_SEQUENCER_DEBUG;
#endif
d3621 10
a3630 1
	max_targ = 15;
d3640 2
a3641 2
	ahc->flags |= AHC_INITIATORROLE;

d3643 7
a3649 1
	 * Only allow target mode features if this unit has them enabled.
d3651 1
a3651 2
	if ((AHC_TMODE_ENABLE & (0x1 << ahc->unit)) == 0)
		ahc->features &= ~AHC_TARGETMODE;
d3653 1
a3653 29
#if !defined(__linux__) && !defined(__OpenBSD__)
	/* DMA tag for mapping buffers into device visible space. */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       /*maxsize*/MAXBSIZE, /*nsegments*/AHC_NSEG,
			       /*maxsegsz*/AHC_MAXTRANSFER_SIZE,
			       /*flags*/BUS_DMA_ALLOCNOW,
			       &ahc->buffer_dmat) != 0) {
		return (ENOMEM);
	}
#endif

	ahc->init_level++;

	/*
	 * DMA tag for our command fifos and other data in system memory
	 * the card's sequencer must be able to access.  For initiator
	 * roles, we need to allocate space for the the qinfifo and qoutfifo.
	 * The qinfifo and qoutfifo are composed of 256 1 byte elements. 
	 * When providing for the target mode role, we must additionally
	 * provide space for the incoming target command fifo and an extra
	 * byte to deal with a dma bug in some chip versions.
	 */
	driver_data_size = 2 * 256 * sizeof(uint8_t);
#ifdef __OpenBSD__
	if (ahc_createdmamem(ahc, ahc->shared_data_dmat, driver_data_size, 
a3659 1
#else
d3661 4
a3664 16
	if ((ahc->features & AHC_TARGETMODE) != 0)
		driver_data_size += AHC_TMODE_CMDS * sizeof(struct target_cmd)
				 + /*DMA WideOdd Bug Buffer*/1;
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       driver_data_size,
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &ahc->shared_data_dmat) != 0) {
		return (ENOMEM);
	}

	ahc->init_level++;
a3665 28
	/* Allocation of driver data */
	if (ahc_dmamem_alloc(ahc, ahc->shared_data_dmat,
			     (void **)&ahc->qoutfifo,
			     BUS_DMA_NOWAIT, &ahc->shared_data_dmamap) != 0) {
		return (ENOMEM);
	}

	ahc->init_level++;

	/* And permanently map it in */
	ahc_dmamap_load(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
			ahc->qoutfifo, driver_data_size, ahc_dmamap_cb,
			&ahc->shared_data_busaddr, /*flags*/0);
	if ((ahc->features & AHC_TARGETMODE) != 0) {
		ahc->targetcmds = (struct target_cmd *)ahc->qoutfifo;
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[AHC_TMODE_CMDS];
		ahc->dma_bug_buf = ahc->shared_data_busaddr
				 + driver_data_size - 1;
		/* All target command blocks start out invalid. */
		for (i = 0; i < AHC_TMODE_CMDS; i++)
			ahc->targetcmds[i].cmd_valid = 0;
		ahc_sync_tqinfifo(ahc, BUS_DMASYNC_PREREAD);
		ahc->tqinfifonext = 1;
		ahc_outb(ahc, KERNEL_TQINPOS, ahc->tqinfifonext - 1);
		ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[256];
	}
#endif 
d3667 4
d3672 3
a3674 6
	ahc->init_level++;

	/* Allocate SCB data now that buffer_dmat is initialized */
	if (ahc->scb_data->maxhscbs == 0)
		if (ahc_init_scbdata(ahc) != 0)
			return (ENOMEM);
d3676 3
d3685 1
a3685 1
		printf("%s: unable to allocate ahc_tmode_tstate.  "
d3687 1
a3687 1
		return (ENOMEM);
d3691 13
a3703 4
		if (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {
			printf("%s: unable to allocate ahc_tmode_tstate.  "
			       "Failing attach\n", ahc_name(ahc));
			return (ENOMEM);
d3705 1
a3708 1
	ahc_outb(ahc, SEQ_FLAGS2, 0);
d3712 1
d3715 1
d3723 1
a3723 1
			sizeof(struct hardware_scb),
d3729 1
a3729 1
	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
a3735 1
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
d3737 4
a3740 1
		ahc_outb(ahc, SCSIID, ahc->our_id_b);
d3743 1
a3743 3
					|term|ahc->seltime_b|ENSTIMER|ACTNEGEN);
		if ((ahc->features & AHC_ULTRA2) != 0)
			ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
d3748 1
a3748 1
		 && (ahc->flags & AHC_INITIATORROLE) != 0)
a3753 1
	
d3761 1
a3761 1
				|term|ahc->seltime
a3762 2
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
d3767 1
a3767 1
	 && (ahc->flags & AHC_INITIATORROLE) != 0)
d3799 1
a3799 1
		struct ahc_tmode_tstate *tstate;
d3815 1
a3815 1
		memset(tinfo, 0, sizeof(*tinfo));
d3828 1
a3828 1
			uint16_t mask;
a3848 3
				if ((scsirate & ~WIDEXFER) == 0 && offset != 0)
					/* Set to the lowest sync rate, 5MHz */
					scsirate |= 0x1c;
a3857 4
				if ((scsirate & SXFR_ULTRA2) <= 8/*10MHz*/
				 && (ahc->features & AHC_DT) != 0)
					tinfo->user.ppr_options =
					    MSG_EXT_PPR_DT_REQ;
a3858 6
				if ((scsirate & SXFR) == 0x40
				 && (ultraenb & mask) != 0) {
					/* Treat 10MHz as a non-ultra speed */
					scsirate &= ~SXFR;
				 	ultraenb &= ~mask;
				}
a3866 2
			if (tinfo->user.period == 0)
				tinfo->user.offset = 0;
a3869 9
			tinfo->user.protocol_version = 4;
			if ((ahc->features & AHC_DT) != 0)
				tinfo->user.transport_version = 3;
			else
				tinfo->user.transport_version = 2;
			tinfo->goal.protocol_version = 2;
			tinfo->goal.transport_version = 2;
			tinfo->curr.protocol_version = 2;
			tinfo->curr.transport_version = 2;
d3871 1
d3873 3
a3879 29
	/* There are no untagged SCBs active yet. */
	for (i = 0; i < 16; i++) {
		ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, 0));
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			int lun;

			/*
			 * The SCB based BTT allows an entry per
			 * target and lun pair.
			 */
			for (lun = 1; lun < AHC_NUM_LUNS; lun++)
				ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, lun));
		}
	}

	/* All of our queues are empty */
	for (i = 0; i < 256; i++)
		ahc->qoutfifo[i] = SCB_LIST_NULL;
	
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREREAD);

	for (i = 0; i < 256; i++)
		ahc->qinfifo[i] = SCB_LIST_NULL;

	if ((ahc->features & AHC_MULTI_TID) != 0) {
		ahc_outb(ahc, TARGID, 0);
		ahc_outb(ahc, TARGID + 1, 0);
	}
	
d3890 11
a3900 4
	ahc_outb(ahc, SHARED_DATA_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 3, (physaddr >> 24) & 0xFF);
d3921 10
d3942 1
d3954 1
a3954 1
	 * If we are a target, we'll enalbe select in operations once
d3958 1
a3958 1
	if ((ahc->flags & AHC_INITIATORROLE) != 0)
d3965 1
a3965 1
	 */
d3972 18
a3989 2
	if ((ahc->features & AHC_ULTRA2) != 0) {
		int wait;
a3990 15
		/*
		 * Wait for up to 500ms for our transceivers
		 * to settle.  If the adapter does not have
		 * a cable attached, the tranceivers may
		 * never settle, so don't complain if we
		 * fail here.
		 */
		ahc_pause(ahc);
		for (wait = 5000;
		     (ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
		     wait--)
			ahc_delay(100);
		ahc_unpause(ahc);
	}
	return (0);
d3993 4
a3996 2
void
ahc_intr_enable(struct ahc_softc *ahc, int enable)
d3998 19
a4016 1
	u_int hcntrl;
d4018 15
a4032 8
	hcntrl = ahc_inb(ahc, HCNTRL);
	hcntrl &= ~INTEN;
	ahc->pause &= ~INTEN;
	ahc->unpause &= ~INTEN;
	if (enable) {
		hcntrl |= INTEN;
		ahc->pause |= INTEN;
		ahc->unpause |= INTEN;
d4034 12
a4045 1
	ahc_outb(ahc, HCNTRL, hcntrl);
d4049 1
a4049 5
 * Ensure that the card is paused in a location
 * outside of all critical sections and that all
 * pending work is completed prior to returning.
 * This routine should only be called from outside
 * an interrupt context.
d4051 2
a4052 2
void
ahc_pause_and_flushwork(struct ahc_softc *ahc)
d4054 2
a4055 2
	int intstat;
	int maxloops;
d4057 8
a4064 8
	maxloops = 1000;
	ahc->flags |= AHC_ALL_INTERRUPTS;
	intstat = 0;
	do {
		ahc_intr(ahc);
		ahc_pause(ahc);
		ahc_clear_critical_section(ahc);
		if (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0)
d4066 1
a4066 5
		maxloops--;
	} while (((intstat = ahc_inb(ahc, INTSTAT)) & INT_PEND) && --maxloops);
	if (maxloops == 0) {
		printf("Infinite interrupt loop, INTSTAT = %x",
		      ahc_inb(ahc, INTSTAT));
d4068 2
a4069 2
	ahc_platform_flushwork(ahc);
	ahc->flags &= ~AHC_ALL_INTERRUPTS;
d4072 3
a4074 2
int
ahc_suspend(struct ahc_softc *ahc)
d4076 12
a4087 2
	uint8_t *ptr;
	int	 i;
d4089 2
a4090 1
	ahc_pause_and_flushwork(ahc);
d4092 2
a4093 2
	if (LIST_FIRST(&ahc->pending_scbs) != NULL)
		return (EBUSY);
d4095 7
a4101 9
#if AHC_TARGET_MODE
	/*
	 * XXX What about ATIOs that have not yet been serviced?
	 * Perhaps we should just refuse to be suspended if we
	 * are acting in a target role.
	 */
	if (ahc->pending_device != NULL)
		return (EBUSY);
#endif
d4103 4
a4106 34
	/* Save volatile registers */
	if ((ahc->features & AHC_TWIN) != 0) {
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		ahc->suspend_state.channel[1].scsiseq = ahc_inb(ahc, SCSISEQ);
		ahc->suspend_state.channel[1].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
		ahc->suspend_state.channel[1].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
		ahc->suspend_state.channel[1].simode0 = ahc_inb(ahc, SIMODE0);
		ahc->suspend_state.channel[1].simode1 = ahc_inb(ahc, SIMODE1);
		ahc->suspend_state.channel[1].seltimer = ahc_inb(ahc, SELTIMER);
		ahc->suspend_state.channel[1].seqctl = ahc_inb(ahc, SEQCTL);
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
	}
	ahc->suspend_state.channel[0].scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc->suspend_state.channel[0].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
	ahc->suspend_state.channel[0].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
	ahc->suspend_state.channel[0].simode0 = ahc_inb(ahc, SIMODE0);
	ahc->suspend_state.channel[0].simode1 = ahc_inb(ahc, SIMODE1);
	ahc->suspend_state.channel[0].seltimer = ahc_inb(ahc, SELTIMER);
	ahc->suspend_state.channel[0].seqctl = ahc_inb(ahc, SEQCTL);

	if ((ahc->chip & AHC_PCI) != 0) {
		ahc->suspend_state.dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		ahc->suspend_state.dspcistatus = ahc_inb(ahc, DSPCISTATUS);
	}

	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;

		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc->suspend_state.optionmode = ahc_inb(ahc, OPTIONMODE);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc->suspend_state.crccontrol1 = ahc_inb(ahc, CRCCONTROL1);
	}
d4108 5
a4112 9
	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc->suspend_state.scbbaddr = ahc_inb(ahc, SCBBADDR);

	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc->suspend_state.dff_thrsh = ahc_inb(ahc, DFF_THRSH);

	ptr = ahc->suspend_state.scratch_ram;
	for (i = 0; i < 64; i++)
		*ptr++ = ahc_inb(ahc, SRAM_BASE + i);
d4114 4
a4117 3
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0; i < 16; i++)
			*ptr++ = ahc_inb(ahc, TARG_OFFSET + i);
d4120 8
a4127 4
	ptr = ahc->suspend_state.btt;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		for (i = 0;i < AHC_NUM_TARGETS; i++) {
			int j;
d4129 8
a4136 6
			for (j = 0;j < AHC_NUM_LUNS; j++) {
				u_int tcl;

				tcl = BUILD_TCL(i << 4, j);
				*ptr = ahc_index_busy_tcl(ahc, tcl);
			}
d4138 3
a4141 3
	ahc_shutdown(ahc);
	return (0);
}
d4143 1
a4143 5
int
ahc_resume(struct ahc_softc *ahc)
{
	uint8_t *ptr;
	int	 i;
d4145 2
a4146 1
	ahc_reset(ahc);
d4148 14
a4161 1
	ahc_build_free_scb_list(ahc);
d4163 8
a4170 24
	/* Restore volatile registers */
	if ((ahc->features & AHC_TWIN) != 0) {
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		ahc_outb(ahc, SCSIID, ahc->our_id);
		ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[1].scsiseq);
		ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[1].sxfrctl0);
		ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[1].sxfrctl1);
		ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[1].simode0);
		ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[1].simode1);
		ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[1].seltimer);
		ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[1].seqctl);
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
	}
	ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[0].scsiseq);
	ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[0].sxfrctl0);
	ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[0].sxfrctl1);
	ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[0].simode0);
	ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[0].simode1);
	ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[0].seltimer);
	ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[0].seqctl);
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);
	else
		ahc_outb(ahc, SCSIID, ahc->our_id);
a4171 3
	if ((ahc->chip & AHC_PCI) != 0) {
		ahc_outb(ahc, DSCOMMAND0, ahc->suspend_state.dscommand0);
		ahc_outb(ahc, DSPCISTATUS, ahc->suspend_state.dspcistatus);
d4174 1
a4174 2
	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;
d4176 2
a4177 6
		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc_outb(ahc, OPTIONMODE, ahc->suspend_state.optionmode);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc_outb(ahc, CRCCONTROL1, ahc->suspend_state.crccontrol1);
	}
d4179 4
a4182 2
	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc_outb(ahc, SCBBADDR, ahc->suspend_state.scbbaddr);
d4184 5
a4188 2
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, DFF_THRSH, ahc->suspend_state.dff_thrsh);
d4190 9
a4198 3
	ptr = ahc->suspend_state.scratch_ram;
	for (i = 0; i < 64; i++)
		ahc_outb(ahc, SRAM_BASE + i, *ptr++);
d4200 2
a4201 3
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0; i < 16; i++)
			ahc_outb(ahc, TARG_OFFSET + i, *ptr++);
d4204 12
a4215 4
	ptr = ahc->suspend_state.btt;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		for (i = 0;i < AHC_NUM_TARGETS; i++) {
			int j;
d4217 4
a4220 2
			for (j = 0;j < AHC_NUM_LUNS; j++) {
				u_int tcl;
d4222 9
a4230 3
				tcl = BUILD_TCL(i << 4, j);
				ahc_busy_tcl(ahc, tcl, *ptr);
			}
d4232 1
a4233 2
	return (0);
}
d4235 3
a4237 10
/************************** Busy Target Table *********************************/
/*
 * Return the untagged transaction id for a given target/channel lun.
 * Optionally, clear the entry.
 */
u_int
ahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl)
{
	u_int scbid;
	u_int target_offset;
d4239 5
a4243 14
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
		
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		scbid = ahc_inb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl));
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		scbid = ahc_inb(ahc, BUSY_TARGETS + target_offset);
	}

	return (scbid);
}
d4245 8
a4252 15
void
ahc_unbusy_tcl(struct ahc_softc *ahc, u_int tcl)
{
	u_int target_offset;

	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
		
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		ahc_outb(ahc, SCB_64_BTT+TCL_TARGET_OFFSET(tcl), SCB_LIST_NULL);
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		ahc_outb(ahc, BUSY_TARGETS + target_offset, SCB_LIST_NULL);
a4253 6
}

void
ahc_busy_tcl(struct ahc_softc *ahc, u_int tcl, u_int scbid)
{
	u_int target_offset;
d4255 4
a4258 2
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
d4260 2
a4261 19
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		ahc_outb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl), scbid);
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		ahc_outb(ahc, BUSY_TARGETS + target_offset, scbid);
	}
}

/************************** SCB and SCB queue management **********************/
int
ahc_match_scb(struct ahc_softc *ahc, struct scb *scb, int target,
	      char channel, int lun, u_int tag, role_t role)
{
	int targ = SCB_GET_TARGET(ahc, scb);
	char chan = SCB_GET_CHANNEL(ahc, scb);
	int slun = SCB_GET_LUN(scb);
	int match;
d4263 5
a4267 22
	match = ((chan == channel) || (channel == ALL_CHANNELS));
	if (match != 0)
		match = ((targ == target) || (target == CAM_TARGET_WILDCARD));
	if (match != 0)
		match = ((lun == slun) || (lun == CAM_LUN_WILDCARD));
	if (match != 0) {
#if AHC_TARGET_MODE
		int group;

		group = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);
		if (role == ROLE_INITIATOR) {
			match = (group != XPT_FC_GROUP_TMODE)
			      && ((tag == scb->hscb->tag)
			       || (tag == SCB_LIST_NULL));
		} else if (role == ROLE_TARGET) {
			match = (group == XPT_FC_GROUP_TMODE)
			      && ((tag == scb->io_ctx->csio.tag_id)
			       || (tag == SCB_LIST_NULL));
		}
#else /* !AHC_TARGET_MODE */
		match = ((tag == scb->hscb->tag) || (tag == SCB_LIST_NULL));
#endif /* AHC_TARGET_MODE */
d4270 1
a4270 1
	return match;
d4273 5
a4277 2
void
ahc_freeze_devq(struct ahc_softc *ahc, struct scb *scb)
d4279 4
a4282 3
	int	target;
	char	channel;
	int	lun;
d4284 3
a4286 7
	target = SCB_GET_TARGET(ahc, scb);
	lun = SCB_GET_LUN(scb);
	channel = SCB_GET_CHANNEL(ahc, scb);
	
	ahc_search_qinfifo(ahc, target, channel, lun,
			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
			   CAM_REQUEUE_REQ, SEARCH_COMPLETE);
a4287 2
	ahc_platform_freeze_devq(ahc, scb);
}
d4289 4
a4292 4
void
ahc_qinfifo_requeue_tail(struct ahc_softc *ahc, struct scb *scb)
{
	struct scb *prev_scb;
d4294 1
a4294 4
	prev_scb = NULL;
	if (ahc_qinfifo_count(ahc) != 0) {
		u_int prev_tag;
		uint8_t prev_pos;
d4296 13
a4308 11
		prev_pos = ahc->qinfifonext - 1;
		prev_tag = ahc->qinfifo[prev_pos];
		prev_scb = ahc_lookup_scb(ahc, prev_tag);
	}
	ahc_qinfifo_requeue(ahc, prev_scb, scb);
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}
}
d4310 8
a4317 6
static void
ahc_qinfifo_requeue(struct ahc_softc *ahc, struct scb *prev_scb,
		    struct scb *scb)
{
	if (prev_scb == NULL) {
		ahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);
d4319 3
a4321 3
		prev_scb->hscb->next = scb->hscb->tag;
		ahc_sync_scb(ahc, prev_scb, 
			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d4323 2
a4324 36
	ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;
	scb->hscb->next = ahc->next_queued_scb->hscb->tag;
	ahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
}

static int
ahc_qinfifo_count(struct ahc_softc *ahc)
{
	u_int8_t qinpos;
	u_int8_t diff;

	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		qinpos = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinpos);
	} else
		qinpos = ahc_inb(ahc, QINPOS);
	diff = ahc->qinfifonext - qinpos;
	return (diff);
}

int
ahc_search_qinfifo(struct ahc_softc *ahc, int target, char channel,
		   int lun, u_int tag, role_t role, uint32_t status,
		   ahc_search_action action)
{
	struct	scb *scb;
	struct	scb *prev_scb;
	uint8_t qinstart;
	uint8_t qinpos;
	uint8_t qintail;
	uint8_t next, prev;
	uint8_t curscbptr;
	int	found;
	int	maxtarget;
	int	i;
	int	have_qregs;
d4326 1
a4326 19
	qintail = ahc->qinfifonext;
	have_qregs = (ahc->features & AHC_QUEUE_REGS) != 0;
	if (have_qregs) {
		qinstart = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinstart);
	} else
		qinstart = ahc_inb(ahc, QINPOS);
	qinpos = qinstart;
	next = ahc_inb(ahc, NEXT_QUEUED_SCB);
	found = 0;
	prev_scb = NULL;
	
	if (action == SEARCH_COMPLETE) {
		/*
		 * Don't attempt to run any queued untagged transactions
		 * until we are done with the abort process.
		 */
		ahc_freeze_untagged_queues(ahc);
	}
d4329 2
a4330 2
	 * Start with an empty queue.  Entries that are not chosen
	 * for removal will be re-added to the queue as we go.
d4332 8
a4339 46
	ahc->qinfifonext = qinpos;
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);

	while (qinpos != qintail) {
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinpos]);
		if (scb == NULL) {
			printf("qinpos = %d, SCB index = %d\n",
				qinpos, ahc->qinfifo[qinpos]);
			panic("Loop 1\n");
		}

		if (ahc_match_scb(ahc, scb, target, channel, lun, tag, role)) {
			/*
			 * We found an scb that needs to be acted on.
			 */
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;

				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb,
								   status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in qinfifo\n");
				ahc_done(ahc, scb);
				/* FALLTHROUGH */
			}
			case SEARCH_REMOVE:
				break;
			case SEARCH_COUNT:
				ahc_qinfifo_requeue(ahc, prev_scb, scb);
				prev_scb = scb;
				break;
			}
		} else {
			ahc_qinfifo_requeue(ahc, prev_scb, scb);
			prev_scb = scb;
		}
		qinpos++;
d4342 4
a4345 5
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}
d4347 3
a4349 16
	if (action != SEARCH_COUNT
	 && (found != 0)
	 && (qinstart != ahc->qinfifonext)) {
		/*
		 * The sequencer may be in the process of dmaing
		 * down the SCB at the beginning of the queue.
		 * This could be problematic if either the first,
		 * or the second SCB is removed from the queue
		 * (the first SCB includes a pointer to the "next"
		 * SCB to dma). If we have removed any entries, swap
		 * the first element in the queue with the next HSCB
		 * so the sequencer will notice that NEXT_QUEUED_SCB
		 * has changed during its dma attempt and will retry
		 * the DMA.
		 */
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinstart]);
d4351 1
a4351 25
		if (scb == NULL) {
			printf("found = %d, qinstart = %d, qinfifionext = %d\n",
				found, qinstart, ahc->qinfifonext);
			panic("First/Second Qinfifo fixup\n");
		}
		/*
		 * ahc_swap_with_next_hscb forces our next pointer to
		 * point to the reserved SCB for future commands.  Save
		 * and restore our original next pointer to maintain
		 * queue integrity.
		 */
		next = scb->hscb->next;
		ahc->scb_data->scbindex[scb->hscb->tag] = NULL;
		ahc_swap_with_next_hscb(ahc, scb);
		scb->hscb->next = next;
		ahc->qinfifo[qinstart] = scb->hscb->tag;

		/* Tell the card about the new head of the qinfifo. */
		ahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);

		/* Fixup the tail "next" pointer. */
		qintail = ahc->qinfifonext - 1;
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qintail]);
		scb->hscb->next = ahc->next_queued_scb->hscb->tag;
	}
d4353 2
a4354 6
	/*
	 * Search waiting for selection list.
	 */
	curscbptr = ahc_inb(ahc, SCBPTR);
	next = ahc_inb(ahc, WAITING_SCBH);  /* Start at head of list. */
	prev = SCB_LIST_NULL;
d4356 13
a4368 2
	while (next != SCB_LIST_NULL) {
		uint8_t scb_index;
d4370 1
a4370 26
		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			printf("Waiting List inconsistency. "
			       "SCB index == %d, yet numscbs == %d.",
			       scb_index, ahc->scb_data->numscbs);
			ahc_dump_card_state(ahc);
			panic("for safety");
		}
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("scb_index = %d, next = %d\n",
				scb_index, next);
			panic("Waiting List traversal\n");
		}
		if (ahc_match_scb(ahc, scb, target, channel,
				  lun, SCB_LIST_NULL, role)) {
			/*
			 * We found an scb that needs to be acted on.
			 */
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;
d4372 5
a4376 20
				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb,
								   status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in Waiting List\n");
				ahc_done(ahc, scb);
				/* FALLTHROUGH */
			}
			case SEARCH_REMOVE:
				next = ahc_rem_wscb(ahc, next, prev);
				break;
			case SEARCH_COUNT:
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
				break;
			}
d4378 3
a4380 3
			
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
a4382 1
	ahc_outb(ahc, SCBPTR, curscbptr);
d4384 15
d4400 1
a4400 1
	 * And lastly, the untagged holding queues.
d4402 47
a4448 2
	i = 0;
	if ((ahc->flags & AHC_SCB_BTT) == 0) {
d4450 3
a4452 2
		maxtarget = 16;
		if (target != CAM_TARGET_WILDCARD) {
d4454 14
a4467 5
			i = target;
			if (channel == 'B')
				i += 8;
			maxtarget = i + 1;
		}
d4469 1
a4469 1
		maxtarget = 0;
d4471 1
d4473 8
a4480 3
	for (; i < maxtarget; i++) {
		struct scb_tailq *untagged_q;
		struct scb *next_scb;
d4482 8
a4489 3
		untagged_q = &(ahc->untagged_queues[i]);
		next_scb = TAILQ_FIRST(untagged_q);
		while (next_scb != NULL) {
d4491 12
a4502 2
			scb = next_scb;
			next_scb = TAILQ_NEXT(scb, links.tqe);
d4504 4
a4507 11
			/*
			 * The head of the list may be the currently
			 * active untagged command for a device.
			 * We're only searching for commands that
			 * have not been started.  A transaction
			 * marked active but still in the qinfifo
			 * is removed by the qinfifo scanning code
			 * above.
			 */
			if ((scb->flags & SCB_ACTIVE) != 0)
				continue;
d4509 1
a4509 34
			if (ahc_match_scb(ahc, scb, target, channel,
					  lun, SCB_LIST_NULL, role)) {
				/*
				 * We found an scb that needs to be acted on.
				 */
				found++;
				switch (action) {
				case SEARCH_COMPLETE:
				{
					cam_status ostat;
					cam_status cstat;

					ostat = ahc_get_transaction_status(scb);
					if (ostat == CAM_REQ_INPROG)
						ahc_set_transaction_status(scb,
								   status);
					cstat = ahc_get_transaction_status(scb);
					if (cstat != CAM_REQ_CMP)
						ahc_freeze_scb(scb);
					if ((scb->flags & SCB_ACTIVE) == 0)
						printf("Inactive SCB in untaggedQ\n");
					ahc_done(ahc, scb);
					break;
				}
				case SEARCH_REMOVE:
					TAILQ_REMOVE(untagged_q, scb,
						     links.tqe);
					break;
				case SEARCH_COUNT:
					break;
				}
			}
		}
	}
d4511 1
a4511 4
	if (action == SEARCH_COMPLETE)
		ahc_release_untagged_queues(ahc);
	return (found);
}
d4513 12
a4524 10
int
ahc_search_disc_list(struct ahc_softc *ahc, int target, char channel,
		     int lun, u_int tag, int stop_on_first, int remove,
		     int save_state)
{
	struct	scb *scbp;
	u_int	next;
	u_int	prev;
	u_int	count;
	u_int	active_scb;
d4526 2
a4527 3
	count = 0;
	next = ahc_inb(ahc, DISCONNECTED_SCBH);
	prev = SCB_LIST_NULL;
d4529 1
a4529 6
	if (save_state) {
		/* restore this when we're done */
		active_scb = ahc_inb(ahc, SCBPTR);
	} else
		/* Silence compiler */
		active_scb = SCB_LIST_NULL;
d4531 2
a4532 2
	while (next != SCB_LIST_NULL) {
		u_int scb_index;
d4534 18
a4551 9
		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			printf("Disconnected List inconsistency. "
			       "SCB index == %d, yet numscbs == %d.",
			       scb_index, ahc->scb_data->numscbs);
			ahc_dump_card_state(ahc);
			panic("for safety");
		}
d4553 12
a4564 22
		if (next == prev) {
			panic("Disconnected List Loop. "
			      "cur SCBPTR == %x, prev SCBPTR == %x.",
			      next, prev);
		}
		scbp = ahc_lookup_scb(ahc, scb_index);
		if (ahc_match_scb(ahc, scbp, target, channel, lun,
				  tag, ROLE_INITIATOR)) {
			count++;
			if (remove) {
				next =
				    ahc_rem_scb_from_disc_list(ahc, prev, next);
			} else {
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
			}
			if (stop_on_first)
				break;
		} else {
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
		}
a4565 3
	if (save_state)
		ahc_outb(ahc, SCBPTR, active_scb);
	return (count);
d4568 4
a4571 6
/*
 * Remove an SCB from the on chip list of disconnected transactions.
 * This is empty/unused if we are not performing SCB paging.
 */
static u_int
ahc_rem_scb_from_disc_list(struct ahc_softc *ahc, u_int prev, u_int scbptr)
d4573 2
a4574 1
	u_int next;
d4576 6
a4581 2
	ahc_outb(ahc, SCBPTR, scbptr);
	next = ahc_inb(ahc, SCB_NEXT);
d4583 5
a4587 1
	ahc_outb(ahc, SCB_CONTROL, 0);
d4589 8
a4596 1
	ahc_add_curscb_to_free_list(ahc);
d4598 9
a4606 5
	if (prev != SCB_LIST_NULL) {
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	} else
		ahc_outb(ahc, DISCONNECTED_SCBH, next);
d4608 5
a4612 2
	return (next);
}
d4614 6
a4619 13
/*
 * Add the SCB as selected by SCBPTR onto the on chip list of
 * free hardware SCBs.  This list is empty/unused if we are not
 * performing SCB paging.
 */
static void
ahc_add_curscb_to_free_list(struct ahc_softc *ahc)
{
	/*
	 * Invalidate the tag so that our abort
	 * routines don't think it's active.
	 */
	ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
d4621 10
a4630 3
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		ahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));
		ahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));
d4632 5
d4639 10
a4648 8
/*
 * Manipulate the waiting for selection list and return the
 * scb that follows the one that we remove.
 */
static u_int
ahc_rem_wscb(struct ahc_softc *ahc, u_int scbpos, u_int prev)
{       
	u_int curscb, next;
d4650 3
a4652 7
	/*
	 * Select the SCB we want to abort and
	 * pull the next pointer out of it.
	 */
	curscb = ahc_inb(ahc, SCBPTR);
	ahc_outb(ahc, SCBPTR, scbpos);
	next = ahc_inb(ahc, SCB_NEXT);
d4654 1
a4654 2
	/* Clear the necessary fields */
	ahc_outb(ahc, SCB_CONTROL, 0);
d4656 1
a4656 1
	ahc_add_curscb_to_free_list(ahc);
d4658 10
a4667 17
	/* update the waiting list */
	if (prev == SCB_LIST_NULL) {
		/* First in the list */
		ahc_outb(ahc, WAITING_SCBH, next); 

		/*
		 * Ensure we aren't attempting to perform
		 * selection for this entry.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else {
		/*
		 * Select the scb that pointed to us 
		 * and update its next pointer.
		 */
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
d4670 6
a4675 5
	/*
	 * Point us back at the original scb position.
	 */
	ahc_outb(ahc, SCBPTR, curscb);
	return next;
d4678 5
a4682 10
/******************************** Error Handling ******************************/
/*
 * Abort all SCBs that match the given description (target/channel/lun/tag),
 * setting their status to the passed in status if the status has not already
 * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
 * is paused before it is called.
 */
int
ahc_abort_scbs(struct ahc_softc *ahc, int target, char channel,
	       int lun, u_int tag, role_t role, uint32_t status)
d4684 7
a4690 7
	struct	scb *scbp;
	struct	scb *scbp_next;
	u_int	active_scb;
	int	i, j;
	int	maxtarget;
	int	minlun;
	int	maxlun;
d4692 1
a4692 1
	int	found;
d4694 2
a4695 5
	/*
	 * Don't attempt to run any queued untagged transactions
	 * until we are done with the abort process.
	 */
	ahc_freeze_untagged_queues(ahc);
d4697 17
a4713 2
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
d4715 5
a4719 2
	found = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,
				   role, CAM_REQUEUE_REQ, SEARCH_COMPLETE);
d4721 1
a4721 11
	/*
	 * Clean out the busy target table for any untagged commands.
	 */
	i = 0;
	maxtarget = 16;
	if (target != CAM_TARGET_WILDCARD) {
		i = target;
		if (channel == 'B')
			i += 8;
		maxtarget = i + 1;
	}
d4723 1
a4723 1
	if (lun == CAM_LUN_WILDCARD) {
d4725 2
a4726 14
		/*
		 * Unless we are using an SCB based
		 * busy targets table, there is only
		 * one table entry for all luns of
		 * a target.
		 */
		minlun = 0;
		maxlun = 1;
		if ((ahc->flags & AHC_SCB_BTT) != 0)
			maxlun = AHC_NUM_LUNS;
	} else {
		minlun = lun;
		maxlun = lun + 1;
	}
d4728 10
a4737 3
	for (;i < maxtarget; i++) {
		for (j = minlun;j < maxlun; j++)
			ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, j));
d4739 14
d4754 3
a4756 9
	/*
	 * Go through the disconnected list and remove any entries we
	 * have queued for completion, 0'ing their control byte too.
	 * We save the active SCB and restore it ourselves, so there
	 * is no reason for this search to restore it too.
	 */
	ahc_search_disc_list(ahc, target, channel, lun, tag,
			     /*stop_on_first*/FALSE, /*remove*/TRUE,
			     /*save_state*/FALSE);
d4758 22
a4779 37
	/*
	 * Go through the hardware SCB array looking for commands that
	 * were active but not on any list.
	 */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scbid;

		ahc_outb(ahc, SCBPTR, i);
		scbid = ahc_inb(ahc, SCB_TAG);
		scbp = ahc_lookup_scb(ahc, scbid);
		if (scbp != NULL
		 && ahc_match_scb(ahc, scbp, target, channel, lun, tag, role))
			ahc_add_curscb_to_free_list(ahc);
	}

	/*
	 * Go through the pending CCB list and look for
	 * commands for this target that are still active.
	 * These are other tagged commands that were
	 * disconnected when the reset occurred.
	 */
	scbp_next = LIST_FIRST(&ahc->pending_scbs);
	while (scbp_next != NULL) {
		scbp = scbp_next;
		scbp_next = LIST_NEXT(scbp, pending_links);
		if (ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)) {
			cam_status ostat;

			ostat = ahc_get_transaction_status(scbp);
			if (ostat == CAM_REQ_INPROG)
				ahc_set_transaction_status(scbp, status);
			if (ahc_get_transaction_status(scbp) != CAM_REQ_CMP)
				ahc_freeze_scb(scbp);
			if ((scbp->flags & SCB_ACTIVE) == 0)
				printf("Inactive SCB on pending list\n");
			ahc_done(ahc, scbp);
			found++;
d4781 6
a4787 4
	ahc_outb(ahc, SCBPTR, active_scb);
	ahc_platform_abort_scbs(ahc, target, channel, lun, tag, role, status);
	ahc_release_untagged_queues(ahc);
	return found;
d4790 4
a4793 2
static void
ahc_reset_current_bus(struct ahc_softc *ahc)
a4794 1
	uint8_t scsiseq;
d4796 4
a4799 6
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);
	scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);
	ahc_delay(AHC_BUSRESET_DELAY);
	/* Turn off the bus reset */
	ahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);
d4801 6
a4806 1
	ahc_clear_intstat(ahc);
d4808 11
a4818 2
	/* Re-enable reset interrupts */
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);
d4821 2
a4822 2
int
ahc_reset_channel(struct ahc_softc *ahc, char channel, int initiate_reset)
d4824 8
a4831 10
	struct	ahc_devinfo devinfo;
	u_int	initiator, target, max_scsiid;
	u_int	sblkctl;
	u_int	scsiseq;
	u_int	simode1;
	int	found;
	int	restart_needed;
	char	cur_channel;

	ahc->pending_device = NULL;
d4833 2
a4834 6
	ahc_compile_devinfo(&devinfo,
			    CAM_TARGET_WILDCARD,
			    CAM_TARGET_WILDCARD,
			    CAM_LUN_WILDCARD,
			    channel, ROLE_UNKNOWN);
	ahc_pause(ahc);
d4836 1
a4836 2
	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);
d4839 4
a4842 3
	 * Run our command complete fifos to ensure that we perform
	 * completion processing on any commands that 'completed'
	 * before the reset occurred.
d4844 11
a4854 4
	ahc_run_qoutfifo(ahc);
#if AHC_TARGET_MODE
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		ahc_run_tqinfifo(ahc, /*paused*/TRUE);
a4855 1
#endif
d4857 6
d4864 2
a4865 1
	 * Reset the bus if we are initiating this reset
d4867 40
a4906 18
	sblkctl = ahc_inb(ahc, SBLKCTL);
	cur_channel = 'A';
	if ((ahc->features & AHC_TWIN) != 0
	 && ((sblkctl & SELBUSB) != 0))
	    cur_channel = 'B';
	scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
	if (cur_channel != channel) {
		/* Case 1: Command for another bus is active
		 * Stealthily reset the other bus without
		 * upsetting the current bus.
		 */
		ahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);
		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
#if AHC_TARGET_MODE
d4908 2
a4909 3
		 * Bus resets clear ENSELI, so we cannot
		 * defer re-enabling bus reset interrupts
		 * if we are in target mode.
d4911 5
a4915 6
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			ahc_outb(ahc, SIMODE1, simode1 | ENSCSIRST);
#endif
		ahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));
		ahc_outb(ahc, SBLKCTL, sblkctl);
		restart_needed = FALSE;
a4916 8
		/* Case 2: A command from this bus is active or we're idle */
		ahc_clear_msg_state(ahc);
		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
#if AHC_TARGET_MODE
d4918 20
a4937 3
		 * Bus resets clear ENSELI, so we cannot
		 * defer re-enabling bus reset interrupts
		 * if we are in target mode.
d4939 59
a4997 6
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			ahc_outb(ahc, SIMODE1, simode1 | ENSCSIRST);
#endif
		ahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));
		restart_needed = TRUE;
	}
d4999 14
a5012 7
	/*
	 * Clean up all the state information for the
	 * pending transactions on this bus.
	 */
	found = ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, channel,
			       CAM_LUN_WILDCARD, SCB_LIST_NULL,
			       ROLE_UNKNOWN, CAM_SCSI_BUS_RESET);
d5014 7
a5020 1
	max_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;
d5022 2
a5023 8
#ifdef AHC_TARGET_MODE
	/*
	 * Send an immediate notify ccb to all target more peripheral
	 * drivers affected by this action.
	 */
	for (target = 0; target <= max_scsiid; target++) {
		struct ahc_tmode_tstate* tstate;
		u_int lun;
d5025 7
a5031 5
		tstate = ahc->enabled_targets[target];
		if (tstate == NULL)
			continue;
		for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
			struct ahc_tmode_lstate* lstate;
d5033 21
a5053 3
			lstate = tstate->enabled_luns[lun];
			if (lstate == NULL)
				continue;
d5055 42
a5096 3
			ahc_queue_lstate_event(ahc, lstate, CAM_TARGET_WILDCARD,
					       EVENT_TYPE_BUS_RESET, /*arg*/0);
			ahc_send_lstate_events(ahc, lstate);
d5099 22
a5120 4
#endif
	/* Notify the XPT that a bus reset occurred */
	ahc_send_async(ahc, devinfo.channel, CAM_TARGET_WILDCARD,
		       CAM_LUN_WILDCARD, AC_BUS_RESET, NULL);
d5123 2
a5124 1
	 * Revert to async/narrow transfers until we renegotiate.
d5126 3
a5128 1
	for (target = 0; target <= max_scsiid; target++) {
d5130 25
a5154 14
		if (ahc->enabled_targets[target] == NULL)
			continue;
		for (initiator = 0; initiator <= max_scsiid; initiator++) {
			struct ahc_devinfo devinfo;

			ahc_compile_devinfo(&devinfo, target, initiator,
					    CAM_LUN_WILDCARD,
					    channel, ROLE_UNKNOWN);
			ahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
				      AHC_TRANS_CUR, /*paused*/TRUE);
			ahc_set_syncrate(ahc, &devinfo, /*syncrate*/NULL,
					 /*period*/0, /*offset*/0,
					 /*ppr_options*/0, AHC_TRANS_CUR,
					 /*paused*/TRUE);
d5156 9
d5167 1
a5167 5
	if (restart_needed)
		ahc_restart(ahc);
	else
		ahc_unpause(ahc);
	return found;
a5169 2

/***************************** Residual Processing ****************************/
d5171 4
a5174 1
 * Calculate the residual for a just completed SCB.
d5176 9
a5184 2
void
ahc_calc_residual(struct scb *scb)
d5186 4
a5189 21
	struct hardware_scb *hscb;
	struct status_pkt *spkt;
	uint32_t sgptr;
	uint32_t resid_sgptr;
	uint32_t resid;

	/*
	 * 5 cases.
	 * 1) No residual.
	 *    SG_RESID_VALID clear in sgptr.
	 * 2) Transferless command
	 * 3) Never performed any transfers.
	 *    sgptr has SG_FULL_RESID set.
	 * 4) No residual but target did not
	 *    save data pointers after the
	 *    last transfer, so sgptr was
	 *    never updated.
	 * 5) We have a partial residual.
	 *    Use residual_sgptr to determine
	 *    where we are.
	 */
d5191 2
a5192 6
	hscb = scb->hscb;
	sgptr = ahc_le32toh(hscb->sgptr);
	if ((sgptr & SG_RESID_VALID) == 0)
		/* Case 1 */
		return;
	sgptr &= ~SG_RESID_VALID;
d5194 2
a5195 3
	if ((sgptr & SG_LIST_NULL) != 0)
		/* Case 2 */
		return;
d5197 8
a5204 12
	spkt = &hscb->shared_data.status;
	resid_sgptr = ahc_le32toh(spkt->residual_sg_ptr);
	if ((sgptr & SG_FULL_RESID) != 0) {
		/* Case 3 */
		resid = ahc_get_transfer_length(scb);
	} else if ((resid_sgptr & SG_LIST_NULL) != 0) {
		/* Case 4 */
		return;
	} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {
		panic("Bogus resid sgptr value 0x%x\n", resid_sgptr);
	} else {
		struct ahc_dma_seg *sg;
d5206 2
a5207 6
		/*
		 * Remainder of the SG where the transfer
		 * stopped.  
		 */
		resid = ahc_le32toh(spkt->residual_datacnt) & AHC_SG_LEN_MASK;
		sg = ahc_sg_bus_to_virt(scb, resid_sgptr & SG_PTR_MASK);
d5209 10
a5218 2
		/* The residual sg_ptr always points to the next sg */
		sg--;
d5220 6
a5225 8
		/*
		 * Add up the contents of all residual
		 * SG segments that are after the SG where
		 * the transfer stopped.
		 */
		while ((ahc_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {
			sg++;
			resid += ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
d5228 16
a5243 4
	if ((scb->flags & SCB_SENSE) == 0)
		ahc_set_residual(scb, resid);
	else
		ahc_set_sense_residual(scb, resid);
d5245 6
a5250 4
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC) {
		ahc_print_path(scb->ahc_softc, scb);
		printf("Handled Residual of %d bytes\n", resid);
a5251 2
#endif
}
d5253 8
a5260 18
/******************************* Target Mode **********************************/
#ifdef AHC_TARGET_MODE
/*
 * Add a target mode event to this lun's queue
 */
static void
ahc_queue_lstate_event(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate,
		       u_int initiator_id, u_int event_type, u_int event_arg)
{
	struct ahc_tmode_event *event;
	int pending;

	xpt_freeze_devq(lstate->path, /*count*/1);
	if (lstate->event_w_idx >= lstate->event_r_idx)
		pending = lstate->event_w_idx - lstate->event_r_idx;
	else
		pending = AHC_TMODE_EVENT_BUFFER_SIZE + 1
			- (lstate->event_r_idx - lstate->event_w_idx);
d5262 12
a5273 59
	if (event_type == EVENT_TYPE_BUS_RESET
	 || event_type == MSG_BUS_DEV_RESET) {
		/*
		 * Any earlier events are irrelevant, so reset our buffer.
		 * This has the effect of allowing us to deal with reset
		 * floods (an external device holding down the reset line)
		 * without losing the event that is really interesting.
		 */
		lstate->event_r_idx = 0;
		lstate->event_w_idx = 0;
		xpt_release_devq(lstate->path, pending, /*runqueue*/FALSE);
	}

	if (pending == AHC_TMODE_EVENT_BUFFER_SIZE) {
		xpt_print_path(lstate->path);
		printf("immediate event %x:%x lost\n",
		       lstate->event_buffer[lstate->event_r_idx].event_type,
		       lstate->event_buffer[lstate->event_r_idx].event_arg);
		lstate->event_r_idx++;
		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
			lstate->event_r_idx = 0;
		xpt_release_devq(lstate->path, /*count*/1, /*runqueue*/FALSE);
	}

	event = &lstate->event_buffer[lstate->event_w_idx];
	event->initiator_id = initiator_id;
	event->event_type = event_type;
	event->event_arg = event_arg;
	lstate->event_w_idx++;
	if (lstate->event_w_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
		lstate->event_w_idx = 0;
}

/*
 * Send any target mode events queued up waiting
 * for immediate notify resources.
 */
void
ahc_send_lstate_events(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate)
{
	struct ccb_hdr *ccbh;
	struct ccb_immed_notify *inot;

	while (lstate->event_r_idx != lstate->event_w_idx
	    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {
		struct ahc_tmode_event *event;

		event = &lstate->event_buffer[lstate->event_r_idx];
		SLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);
		inot = (struct ccb_immed_notify *)ccbh;
		switch (event->event_type) {
		case EVENT_TYPE_BUS_RESET:
			ccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;
			break;
		default:
			ccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;
			inot->message_args[0] = event->event_type;
			inot->message_args[1] = event->event_arg;
			break;
a5274 6
		inot->initiator_id = event->initiator_id;
		inot->sense_len = 0;
		xpt_done((union ccb *)inot);
		lstate->event_r_idx++;
		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
			lstate->event_r_idx = 0;
d5276 2
a5278 1
#endif
d5280 11
a5290 5
/******************** Sequencer Program Patching/Download *********************/

#ifdef AHC_DUMP_SEQ
void
ahc_dumpseq(struct ahc_softc* ahc)
d5292 5
a5296 2
	int i;
	int max_prog;
d5298 3
a5300 6
	if ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)
		max_prog = 448;
	else if ((ahc->features & AHC_ULTRA2) != 0)
		max_prog = 768;
	else
		max_prog = 512;
d5302 6
a5307 5
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	for (i = 0; i < max_prog; i++) {
		uint8_t ins_bytes[4];
d5309 2
a5310 8
		ahc_insb(ahc, SEQRAM, ins_bytes, 4);
		printf("0x%08x\n", ins_bytes[0] << 24
				 | ins_bytes[1] << 16
				 | ins_bytes[2] << 8
				 | ins_bytes[3]);
	}
}
#endif
d5312 6
a5317 52
static void
ahc_loadseq(struct ahc_softc *ahc)
{
	struct	cs cs_table[num_critical_sections];
	u_int	begin_set[num_critical_sections];
	u_int	end_set[num_critical_sections];
	struct	patch *cur_patch;
	u_int	cs_count;
	u_int	cur_cs;
	u_int	i;
	int	downloaded;
	u_int	skip_addr;
	u_int	sg_prefetch_cnt;
	uint8_t	download_consts[7];

	/*
	 * Start out with 0 critical sections
	 * that apply to this firmware load.
	 */
	cs_count = 0;
	cur_cs = 0;
	memset(begin_set, 0, sizeof(begin_set));
	memset(end_set, 0, sizeof(end_set));

	/* Setup downloadable constant table */
	download_consts[QOUTFIFO_OFFSET] = 0;
	if (ahc->targetcmds != NULL)
		download_consts[QOUTFIFO_OFFSET] += 32;
	download_consts[QINFIFO_OFFSET] = download_consts[QOUTFIFO_OFFSET] + 1;
	download_consts[CACHESIZE_MASK] = ahc->pci_cachesize - 1;
	download_consts[INVERTED_CACHESIZE_MASK] = ~(ahc->pci_cachesize - 1);
	sg_prefetch_cnt = ahc->pci_cachesize;
	if (sg_prefetch_cnt < (2 * sizeof(struct ahc_dma_seg)))
		sg_prefetch_cnt = 2 * sizeof(struct ahc_dma_seg);
	download_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;
	download_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_cnt - 1);
	download_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_cnt - 1);

	cur_patch = patches;
	downloaded = 0;
	skip_addr = 0;
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);

	for (i = 0; i < sizeof(seqprog)/4; i++) {
		if (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {
			/*
			 * Don't download this instruction as it
			 * is in a patch that was removed.
			 */
			continue;
d5319 10
a5328 13
		/*
		 * Move through the CS table until we find a CS
		 * that might apply to this instruction.
		 */
		for (; cur_cs < num_critical_sections; cur_cs++) {
			if (critical_sections[cur_cs].end <= i) {
				if (begin_set[cs_count] == TRUE
				 && end_set[cs_count] == FALSE) {
					cs_table[cs_count].end = downloaded;
				 	end_set[cs_count] = TRUE;
					cs_count++;
				}
				continue;
d5330 5
a5334 6
			if (critical_sections[cur_cs].begin <= i
			 && begin_set[cs_count] == FALSE) {
				cs_table[cs_count].begin = downloaded;
				begin_set[cs_count] = TRUE;
			}
			break;
a5335 2
		ahc_download_instr(ahc, i, download_consts);
		downloaded++;
d5337 3
a5339 15

	ahc->num_critical_sections = cs_count;
	if (cs_count != 0) {

		cs_count *= sizeof(struct cs);
		ahc->critical_sections = malloc(cs_count, M_DEVBUF, M_NOWAIT);
		if (ahc->critical_sections == NULL)
			panic("ahc_loadseq: Could not malloc");
		memcpy(ahc->critical_sections, cs_table, cs_count);
	}
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);
	ahc_restart(ahc);

	if (bootverbose)
		printf(" %d instructions downloaded\n", downloaded);
d5342 5
a5346 3
static int
ahc_check_patch(struct ahc_softc *ahc, struct patch **start_patch,
		u_int start_instr, u_int *skip_addr)
d5348 4
a5351 3
	struct	patch *cur_patch;
	struct	patch *last_patch;
	u_int	num_patches;
d5353 1
a5353 3
	num_patches = sizeof(patches)/sizeof(struct patch);
	last_patch = &patches[num_patches];
	cur_patch = *start_patch;
d5355 1
a5355 1
	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
d5357 5
a5361 1
		if (cur_patch->patch_func(ahc) == 0) {
d5363 2
a5364 11
			/* Start rejecting code */
			*skip_addr = start_instr + cur_patch->skip_instr;
			cur_patch += cur_patch->skip_patch;
		} else {
			/* Accepted this patch.  Advance to the next
			 * one and wait for our intruction pointer to
			 * hit this point.
			 */
			cur_patch++;
		}
	}
d5366 6
a5371 4
	*start_patch = cur_patch;
	if (start_instr < *skip_addr)
		/* Still skipping */
		return (0);
d5373 2
a5374 1
	return (1);
d5377 11
a5387 7
static void
ahc_download_instr(struct ahc_softc *ahc, u_int instrptr, uint8_t *dconsts)
{
	union	ins_formats instr;
	struct	ins_format1 *fmt1_ins;
	struct	ins_format3 *fmt3_ins;
	u_int	opcode;
d5390 2
a5391 1
	 * The firmware is always compiled into a little endian format.
d5393 6
a5398 1
	instr.integer = ahc_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
d5400 1
a5400 2
	fmt1_ins = &instr.format1;
	fmt3_ins = NULL;
d5402 4
a5405 17
	/* Pull the opcode */
	opcode = instr.format1.opcode;
	switch (opcode) {
	case AIC_OP_JMP:
	case AIC_OP_JC:
	case AIC_OP_JNC:
	case AIC_OP_CALL:
	case AIC_OP_JNE:
	case AIC_OP_JNZ:
	case AIC_OP_JE:
	case AIC_OP_JZ:
	{
		struct patch *cur_patch;
		int address_offset;
		u_int address;
		u_int skip_addr;
		u_int i;
d5407 13
a5419 5
		fmt3_ins = &instr.format3;
		address_offset = 0;
		address = fmt3_ins->address;
		cur_patch = patches;
		skip_addr = 0;
d5421 6
a5426 1
		for (i = 0; i < address;) {
d5428 11
a5438 1
			ahc_check_patch(ahc, &cur_patch, i, &skip_addr);
d5440 5
a5444 2
			if (skip_addr > i) {
				int end_addr;
d5446 6
a5451 40
				end_addr = MIN(address, skip_addr);
				address_offset += end_addr - i;
				i = skip_addr;
			} else {
				i++;
			}
		}
		address -= address_offset;
		fmt3_ins->address = address;
		/* FALLTHROUGH */
	}
	case AIC_OP_OR:
	case AIC_OP_AND:
	case AIC_OP_XOR:
	case AIC_OP_ADD:
	case AIC_OP_ADC:
	case AIC_OP_BMOV:
		if (fmt1_ins->parity != 0) {
			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
		}
		fmt1_ins->parity = 0;
		if ((ahc->features & AHC_CMD_CHAN) == 0
		 && opcode == AIC_OP_BMOV) {
			/*
			 * Block move was added at the same time
			 * as the command channel.  Verify that
			 * this is only a move of a single element
			 * and convert the BMOV to a MOV
			 * (AND with an immediate of FF).
			 */
			if (fmt1_ins->immediate != 1)
				panic("%s: BMOV not supported\n",
				      ahc_name(ahc));
			fmt1_ins->opcode = AIC_OP_AND;
			fmt1_ins->immediate = 0xff;
		}
		/* FALLTHROUGH */
	case AIC_OP_ROL:
		if ((ahc->features & AHC_ULTRA2) != 0) {
			int i, count;
d5453 1
a5453 3
			/* Calculate odd parity for the instruction */
			for (i = 0, count = 0; i < 31; i++) {
				uint32_t mask;
d5455 2
a5456 31
				mask = 0x01 << i;
				if ((instr.integer & mask) != 0)
					count++;
			}
			if ((count & 0x01) == 0)
				instr.format1.parity = 1;
		} else {
			/* Compress the instruction for older sequencers */
			if (fmt3_ins != NULL) {
				instr.integer =
					fmt3_ins->immediate
				      | (fmt3_ins->source << 8)
				      | (fmt3_ins->address << 16)
				      |	(fmt3_ins->opcode << 25);
			} else {
				instr.integer =
					fmt1_ins->immediate
				      | (fmt1_ins->source << 8)
				      | (fmt1_ins->destination << 16)
				      |	(fmt1_ins->ret << 24)
				      |	(fmt1_ins->opcode << 25);
			}
		}
		/* The sequencer is a little endian cpu */
		instr.integer = ahc_htole32(instr.integer);
		ahc_outsb(ahc, SEQRAM, instr.bytes, 4);
		break;
	default:
		panic("Unknown opcode encountered in seq program");
		break;
	}
d5459 5
a5463 2
void
ahc_dump_card_state(struct ahc_softc *ahc)
d5465 17
a5481 11
	struct scb *scb;
	struct scb_tailq *untagged_q;
	int target;
	int maxtarget;
	int i;
	uint8_t last_phase;
	uint8_t qinpos;
	uint8_t qintail;
	uint8_t qoutpos;
	uint8_t scb_index;
	uint8_t saved_scbptr;
d5483 31
a5513 1
	saved_scbptr = ahc_inb(ahc, SCBPTR);
d5515 11
a5525 37
	last_phase = ahc_inb(ahc, LASTPHASE);
	printf("%s: Dumping Card State %s, at SEQADDR 0x%x\n",
	       ahc_name(ahc), ahc_lookup_phase_entry(last_phase)->phasemsg,
	       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
	printf("ACCUM = 0x%x, SINDEX = 0x%x, DINDEX = 0x%x, ARG_2 = 0x%x\n",
	       ahc_inb(ahc, ACCUM), ahc_inb(ahc, SINDEX), ahc_inb(ahc, DINDEX),
	       ahc_inb(ahc, ARG_2));
	printf("HCNT = 0x%x\n", ahc_inb(ahc, HCNT));
	printf("SCSISEQ = 0x%x, SBLKCTL = 0x%x\n",
	       ahc_inb(ahc, SCSISEQ), ahc_inb(ahc, SBLKCTL));
	printf(" DFCNTRL = 0x%x, DFSTATUS = 0x%x\n",
	       ahc_inb(ahc, DFCNTRL), ahc_inb(ahc, DFSTATUS));
	printf("LASTPHASE = 0x%x, SCSISIGI = 0x%x, SXFRCTL0 = 0x%x\n",
	       last_phase, ahc_inb(ahc, SCSISIGI), ahc_inb(ahc, SXFRCTL0));
	printf("SSTAT0 = 0x%x, SSTAT1 = 0x%x\n",
	       ahc_inb(ahc, SSTAT0), ahc_inb(ahc, SSTAT1));
	if ((ahc->features & AHC_DT) != 0)
		printf("SCSIPHASE = 0x%x\n", ahc_inb(ahc, SCSIPHASE));
	printf("STACK == 0x%x, 0x%x, 0x%x, 0x%x\n",
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8));
	printf("SCB count = %d\n", ahc->scb_data->numscbs);
	printf("Kernel NEXTQSCB = %d\n", ahc->next_queued_scb->hscb->tag);
	printf("Card NEXTQSCB = %d\n", ahc_inb(ahc, NEXT_QUEUED_SCB));
	/* QINFIFO */
	printf("QINFIFO entries: ");
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		qinpos = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinpos);
	} else
		qinpos = ahc_inb(ahc, QINPOS);
	qintail = ahc->qinfifonext;
	while (qinpos != qintail) {
		printf("%d ", ahc->qinfifo[qinpos]);
		qinpos++;
a5526 1
	printf("\n");
d5528 11
a5538 53
	printf("Waiting Queue entries: ");
	scb_index = ahc_inb(ahc, WAITING_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	printf("Disconnected Queue entries: ");
	scb_index = ahc_inb(ahc, DISCONNECTED_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");
		
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);
	printf("QOUTFIFO entries: ");
	qoutpos = ahc->qoutfifonext;
	i = 0;
	while (ahc->qoutfifo[qoutpos] != SCB_LIST_NULL && i++ < 256) {
		printf("%d ", ahc->qoutfifo[qoutpos]);
		qoutpos++;
	}
	printf("\n");

	printf("Sequencer Free SCB List: ");
	scb_index = ahc_inb(ahc, FREE_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d ", scb_index);
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	printf("Pending list: ");
	i = 0;
	LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
		if (i++ > 256)
			break;
		if (scb != LIST_FIRST(&ahc->pending_scbs))
			printf(", ");
		printf("%d", scb->hscb->tag);
		if ((ahc->flags & AHC_PAGESCBS) == 0) {
			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
			printf("(0x%x, 0x%x)", ahc_inb(ahc, SCB_CONTROL),
			       ahc_inb(ahc, SCB_TAG));
		}
a5539 1
	printf("\n");
d5541 6
a5546 8
	printf("Kernel Free SCB list: ");
	i = 0;
	SLIST_FOREACH(scb, &ahc->scb_data->free_scbs, links.sle) {
		if (i++ > 256)
			break;
		printf("%d ", scb->hscb->tag);
	}
	printf("\n");
d5548 1
a5548 4
	maxtarget = (ahc->features & (AHC_WIDE|AHC_TWIN)) ? 15 : 7;
	for (target = 0; target <= maxtarget; target++) {
		untagged_q = &ahc->untagged_queues[target];
		if (TAILQ_FIRST(untagged_q) == NULL)
d5550 16
a5565 6
		printf("Untagged Q(%d): ", target);
		i = 0;
		TAILQ_FOREACH(scb, untagged_q, links.tqe) {
			if (i++ > 256)
				break;
			printf("%d ", scb->hscb->tag);
a5566 1
		printf("\n");
d5569 5
a5573 2
	ahc_platform_dump_card_state(ahc);
	ahc_outb(ahc, SCBPTR, saved_scbptr);
d5576 13
a5588 22
/************************* Target Mode ****************************************/
#ifdef AHC_TARGET_MODE
cam_status
ahc_find_tmode_devs(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb,
		    struct ahc_tmode_tstate **tstate,
		    struct ahc_tmode_lstate **lstate,
		    int notfound_failure)
{

	if ((ahc->features & AHC_TARGETMODE) == 0)
		return (CAM_REQ_INVALID);

	/*
	 * Handle the 'black hole' device that sucks up
	 * requests to unattached luns on enabled targets.
	 */
	if (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD
	 && ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {
		*tstate = NULL;
		*lstate = ahc->black_hole;
	} else {
		u_int max_id;
d5590 7
a5596 3
		max_id = (ahc->features & AHC_WIDE) ? 15 : 7;
		if (ccb->ccb_h.target_id > max_id)
			return (CAM_TID_INVALID);
d5598 13
a5610 2
		if (ccb->ccb_h.target_lun >= AHC_NUM_LUNS)
			return (CAM_LUN_INVALID);
d5612 10
a5621 11
		*tstate = ahc->enabled_targets[ccb->ccb_h.target_id];
		*lstate = NULL;
		if (*tstate != NULL)
			*lstate =
			    (*tstate)->enabled_luns[ccb->ccb_h.target_lun];
	}

	if (notfound_failure != 0 && *lstate == NULL)
		return (CAM_PATH_INVALID);

	return (CAM_REQ_CMP);
d5624 3
a5626 2
void
ahc_handle_en_lun(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb)
d5628 1
a5628 9
	struct	   ahc_tmode_tstate *tstate;
	struct	   ahc_tmode_lstate *lstate;
	struct	   ccb_en_lun *cel;
	cam_status status;
	u_int	   target;
	u_int	   lun;
	u_int	   target_mask;
	u_long	   s;
	char	   channel;
d5630 1
a5630 2
	status = ahc_find_tmode_devs(ahc, sim, ccb, &tstate, &lstate,
				     /*notfound_failure*/FALSE);
d5632 17
a5648 4
	if (status != CAM_REQ_CMP) {
		ccb->ccb_h.status = status;
		return;
	}
d5650 8
a5657 2
	if ((ahc->features & AHC_MULTIROLE) != 0) {
		u_int	   our_id;
d5659 3
a5661 27
		if (cam_sim_bus(sim) == 0)
			our_id = ahc->our_id;
		else
			our_id = ahc->our_id_b;

		if (ccb->ccb_h.target_id != our_id) {
			if ((ahc->features & AHC_MULTI_TID) != 0
		   	 && (ahc->flags & AHC_INITIATORROLE) != 0) {
				/*
				 * Only allow additional targets if
				 * the initiator role is disabled.
				 * The hardware cannot handle a re-select-in
				 * on the initiator id during a re-select-out
				 * on a different target id.
				 */
				status = CAM_TID_INVALID;
			} else if ((ahc->flags & AHC_INITIATORROLE) != 0
				|| ahc->enabled_luns > 0) {
				/*
				 * Only allow our target id to change
				 * if the initiator role is not configured
				 * and there are no enabled luns which
				 * are attached to the currently registered
				 * scsi id.
				 */
				status = CAM_TID_INVALID;
			}
d5663 1
d5666 10
a5675 3
	if (status != CAM_REQ_CMP) {
		ccb->ccb_h.status = status;
		return;
d5677 11
d5690 2
a5691 2
	 * We now have an id that is valid.
	 * If we aren't in target mode, switch modes.
d5693 31
a5723 25
	if ((ahc->flags & AHC_TARGETROLE) == 0
	 && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
		u_long	s;

		printf("Configuring Target Mode\n");
		ahc_lock(ahc, &s);
		if (LIST_FIRST(&ahc->pending_scbs) != NULL) {
			ccb->ccb_h.status = CAM_BUSY;
			ahc_unlock(ahc, &s);
			return;
		}
		ahc->flags |= AHC_TARGETROLE;
		if ((ahc->features & AHC_MULTIROLE) == 0)
			ahc->flags &= ~AHC_INITIATORROLE;
		ahc_pause(ahc);
		ahc_loadseq(ahc);
		ahc_unlock(ahc, &s);
	}
	cel = &ccb->cel;
	target = ccb->ccb_h.target_id;
	lun = ccb->ccb_h.target_lun;
	channel = SIM_CHANNEL(ahc, sim);
	target_mask = 0x01 << target;
	if (channel == 'B')
		target_mask <<= 8;
d5725 2
a5726 2
	if (cel->enable != 0) {
		u_int scsiseq;
d5728 4
a5731 7
		/* Are we already enabled?? */
		if (lstate != NULL) {
			xpt_print_path(ccb->ccb_h.path);
			printf("Lun already enabled\n");
			ccb->ccb_h.status = CAM_LUN_ALRDY_ENA;
			return;
		}
d5733 11
a5743 10
		if (cel->grp6_len != 0
		 || cel->grp7_len != 0) {
			/*
			 * Don't (yet?) support vendor
			 * specific commands.
			 */
			ccb->ccb_h.status = CAM_REQ_INVALID;
			printf("Non-zero Group Codes\n");
			return;
		}
d5745 21
a5765 12
		/*
		 * Seems to be okay.
		 * Setup our data structures.
		 */
		if (target != CAM_TARGET_WILDCARD && tstate == NULL) {
			tstate = ahc_alloc_tstate(ahc, target, channel);
			if (tstate == NULL) {
				xpt_print_path(ccb->ccb_h.path);
				printf("Couldn't allocate tstate\n");
				ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
				return;
			}
d5767 3
a5769 41
		lstate = malloc(sizeof(*lstate), M_DEVBUF, M_NOWAIT);
		if (lstate == NULL) {
			xpt_print_path(ccb->ccb_h.path);
			printf("Couldn't allocate lstate\n");
			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
			return;
		}
		memset(lstate, 0, sizeof(*lstate));
		status = xpt_create_path(&lstate->path, /*periph*/NULL,
					 xpt_path_path_id(ccb->ccb_h.path),
					 xpt_path_target_id(ccb->ccb_h.path),
					 xpt_path_lun_id(ccb->ccb_h.path));
		if (status != CAM_REQ_CMP) {
			free(lstate, M_DEVBUF);
			xpt_print_path(ccb->ccb_h.path);
			printf("Couldn't allocate path\n");
			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
			return;
		}
		SLIST_INIT(&lstate->accept_tios);
		SLIST_INIT(&lstate->immed_notifies);
		ahc_lock(ahc, &s);
		ahc_pause(ahc);
		if (target != CAM_TARGET_WILDCARD) {
			tstate->enabled_luns[lun] = lstate;
			ahc->enabled_luns++;

			if ((ahc->features & AHC_MULTI_TID) != 0) {
				u_int targid_mask;

				targid_mask = ahc_inb(ahc, TARGID)
					    | (ahc_inb(ahc, TARGID + 1) << 8);

				targid_mask |= target_mask;
				ahc_outb(ahc, TARGID, targid_mask);
				ahc_outb(ahc, TARGID+1, (targid_mask >> 8));
				
				ahc_update_scsiid(ahc, targid_mask);
			} else {
				u_int our_id;
				char  channel;
d5771 6
a5776 2
				channel = SIM_CHANNEL(ahc, sim);
				our_id = SIM_SCSI_ID(ahc, sim);
d5778 1
a5778 23
				/*
				 * This can only happen if selections
				 * are not enabled
				 */
				if (target != our_id) {
					u_int sblkctl;
					char  cur_channel;
					int   swap;

					sblkctl = ahc_inb(ahc, SBLKCTL);
					cur_channel = (sblkctl & SELBUSB)
						    ? 'B' : 'A';
					if ((ahc->features & AHC_TWIN) == 0)
						cur_channel = 'A';
					swap = cur_channel != channel;
					if (channel == 'A')
						ahc->our_id = target;
					else
						ahc->our_id_b = target;

					if (swap)
						ahc_outb(ahc, SBLKCTL,
							 sblkctl ^ SELBUSB);
d5780 1
a5780 1
					ahc_outb(ahc, SCSIID, target);
d5782 9
a5790 23
					if (swap)
						ahc_outb(ahc, SBLKCTL, sblkctl);
				}
			}
		} else
			ahc->black_hole = lstate;
		/* Allow select-in operations */
		if (ahc->black_hole != NULL && ahc->enabled_luns > 0) {
			scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
			scsiseq |= ENSELI;
			ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);
			scsiseq = ahc_inb(ahc, SCSISEQ);
			scsiseq |= ENSELI;
			ahc_outb(ahc, SCSISEQ, scsiseq);
		}
		ahc_unpause(ahc);
		ahc_unlock(ahc, &s);
		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_print_path(ccb->ccb_h.path);
		printf("Lun now enabled for target mode\n");
	} else {
		struct scb *scb;
		int i, empty;
d5792 5
a5796 4
		if (lstate == NULL) {
			ccb->ccb_h.status = CAM_LUN_INVALID;
			return;
		}
d5798 1
a5798 15
		ahc_lock(ahc, &s);
		
		ccb->ccb_h.status = CAM_REQ_CMP;
		LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
			struct ccb_hdr *ccbh;

			ccbh = &scb->io_ctx->ccb_h;
			if (ccbh->func_code == XPT_CONT_TARGET_IO
			 && !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){
				printf("CTIO pending\n");
				ccb->ccb_h.status = CAM_REQ_INVALID;
				ahc_unlock(ahc, &s);
				return;
			}
		}
d5800 2
a5801 4
		if (SLIST_FIRST(&lstate->accept_tios) != NULL) {
			printf("ATIOs pending\n");
			ccb->ccb_h.status = CAM_REQ_INVALID;
		}
d5803 2
a5804 4
		if (SLIST_FIRST(&lstate->immed_notifies) != NULL) {
			printf("INOTs pending\n");
			ccb->ccb_h.status = CAM_REQ_INVALID;
		}
d5806 6
a5811 4
		if (ccb->ccb_h.status != CAM_REQ_CMP) {
			ahc_unlock(ahc, &s);
			return;
		}
d5813 3
a5815 15
		xpt_print_path(ccb->ccb_h.path);
		printf("Target mode disabled\n");
		xpt_free_path(lstate->path);
		free(lstate, M_DEVBUF);

		ahc_pause(ahc);
		/* Can we clean up the target too? */
		if (target != CAM_TARGET_WILDCARD) {
			tstate->enabled_luns[lun] = NULL;
			ahc->enabled_luns--;
			for (empty = 1, i = 0; i < 8; i++)
				if (tstate->enabled_luns[i] != NULL) {
					empty = 0;
					break;
				}
d5817 2
a5818 49
			if (empty) {
				ahc_free_tstate(ahc, target, channel,
						/*force*/FALSE);
				if (ahc->features & AHC_MULTI_TID) {
					u_int targid_mask;

					targid_mask = ahc_inb(ahc, TARGID)
						    | (ahc_inb(ahc, TARGID + 1)
						       << 8);

					targid_mask &= ~target_mask;
					ahc_outb(ahc, TARGID, targid_mask);
					ahc_outb(ahc, TARGID+1,
					 	 (targid_mask >> 8));
					ahc_update_scsiid(ahc, targid_mask);
				}
			}
		} else {

			ahc->black_hole = NULL;

			/*
			 * We can't allow selections without
			 * our black hole device.
			 */
			empty = TRUE;
		}
		if (ahc->enabled_luns == 0) {
			/* Disallow select-in */
			u_int scsiseq;

			scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
			scsiseq &= ~ENSELI;
			ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);
			scsiseq = ahc_inb(ahc, SCSISEQ);
			scsiseq &= ~ENSELI;
			ahc_outb(ahc, SCSISEQ, scsiseq);

			if ((ahc->features & AHC_MULTIROLE) == 0) {
				printf("Configuring Initiator Mode\n");
				ahc->flags &= ~AHC_TARGETROLE;
				ahc->flags |= AHC_INITIATORROLE;
				ahc_pause(ahc);
				ahc_loadseq(ahc);
			}
		}
		ahc_unpause(ahc);
		ahc_unlock(ahc, &s);
	}
d5821 4
a5824 2
static void
ahc_update_scsiid(struct ahc_softc *ahc, u_int targid_mask)
d5826 5
a5830 2
	u_int scsiid_mask;
	u_int scsiid;
d5832 2
a5833 2
	if ((ahc->features & AHC_MULTI_TID) == 0)
		panic("ahc_update_scsiid called on non-multitid unit\n");
d5835 2
a5836 13
	/*
	 * Since we will rely on the the TARGID mask
	 * for selection enables, ensure that OID
	 * in SCSIID is not set to some other ID
	 * that we don't want to allow selections on.
	 */
	if ((ahc->features & AHC_ULTRA2) != 0)
		scsiid = ahc_inb(ahc, SCSIID_ULTRA2);
	else
		scsiid = ahc_inb(ahc, SCSIID);
	scsiid_mask = 0x1 << (scsiid & OID);
	if ((targid_mask & scsiid_mask) == 0) {
		u_int our_id;
d5838 7
a5844 14
		/* ffs counts from 1 */
		our_id = ffs(targid_mask);
		if (our_id == 0)
			our_id = ahc->our_id;
		else
			our_id--;
		scsiid &= TID;
		scsiid |= our_id;
	}
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, scsiid);
	else
		ahc_outb(ahc, SCSIID, scsiid);
}
d5846 2
a5847 4
void
ahc_run_tqinfifo(struct ahc_softc *ahc, int paused)
{
	struct target_cmd *cmd;
d5850 11
a5860 6
	 * If the card supports auto-access pause,
	 * we can access the card directly regardless
	 * of whether it is paused or not.
	 */
	if ((ahc->features & AHC_AUTOPAUSE) != 0)
		paused = TRUE;
d5862 14
a5875 38
	ahc_sync_tqinfifo(ahc, BUS_DMASYNC_POSTREAD);
	while ((cmd = &ahc->targetcmds[ahc->tqinfifonext])->cmd_valid != 0) {

		/*
		 * Only advance through the queue if we
		 * have the resources to process the command.
		 */
		if (ahc_handle_target_cmd(ahc, cmd) != 0)
			break;

		cmd->cmd_valid = 0;
		ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
				ahc->shared_data_dmamap,
				ahc_targetcmd_offset(ahc, ahc->tqinfifonext),
				sizeof(struct target_cmd),
				BUS_DMASYNC_PREREAD);
		ahc->tqinfifonext++;

		/*
		 * Lazily update our position in the target mode incoming
		 * command queue as seen by the sequencer.
		 */
		if ((ahc->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {
			if ((ahc->features & AHC_HS_MAILBOX) != 0) {
				u_int hs_mailbox;

				hs_mailbox = ahc_inb(ahc, HS_MAILBOX);
				hs_mailbox &= ~HOST_TQINPOS;
				hs_mailbox |= ahc->tqinfifonext & HOST_TQINPOS;
				ahc_outb(ahc, HS_MAILBOX, hs_mailbox);
			} else {
				if (!paused)
					ahc_pause(ahc);	
				ahc_outb(ahc, KERNEL_TQINPOS,
					 ahc->tqinfifonext & HOST_TQINPOS);
				if (!paused)
					ahc_unpause(ahc);
			}
d5880 5
a5884 2
static int
ahc_handle_target_cmd(struct ahc_softc *ahc, struct target_cmd *cmd)
d5886 4
a5889 17
	struct	  ahc_tmode_tstate *tstate;
	struct	  ahc_tmode_lstate *lstate;
	struct	  ccb_accept_tio *atio;
	uint8_t *byte;
	int	  initiator;
	int	  target;
	int	  lun;

	initiator = SCSIID_TARGET(ahc, cmd->scsiid);
	target = SCSIID_OUR_ID(cmd->scsiid);
	lun    = (cmd->identify & MSG_IDENTIFY_LUNMASK);

	byte = cmd->bytes;
	tstate = ahc->enabled_targets[target];
	lstate = NULL;
	if (tstate != NULL)
		lstate = tstate->enabled_luns[lun];
d5891 2
a5892 27
	/*
	 * Commands for disabled luns go to the black hole driver.
	 */
	if (lstate == NULL)
		lstate = ahc->black_hole;

	atio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);
	if (atio == NULL) {
		ahc->flags |= AHC_TQINFIFO_BLOCKED;
		/*
		 * Wait for more ATIOs from the peripheral driver for this lun.
		 */
		return (1);
	} else
		ahc->flags &= ~AHC_TQINFIFO_BLOCKED;
#if 0
	printf("Incoming command from %d for %d:%d%s\n",
	       initiator, target, lun,
	       lstate == ahc->black_hole ? "(Black Holed)" : "");
#endif
	SLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);

	if (lstate == ahc->black_hole) {
		/* Fill in the wildcards */
		atio->ccb_h.target_id = target;
		atio->ccb_h.target_lun = lun;
	}
d5895 2
a5896 2
	 * Package it up and send it off to
	 * whomever has this lun enabled.
d5898 4
a5901 11
	atio->sense_len = 0;
	atio->init_id = initiator;
	if (byte[0] != 0xFF) {
		/* Tag was included */
		atio->tag_action = *byte++;
		atio->tag_id = *byte++;
		atio->ccb_h.flags = CAM_TAG_ACTION_VALID;
	} else {
		atio->ccb_h.flags = 0;
	}
	byte++;
d5903 4
a5906 24
	/* Okay.  Now determine the cdb size based on the command code */
	switch (*byte >> CMD_GROUP_CODE_SHIFT) {
	case 0:
		atio->cdb_len = 6;
		break;
	case 1:
	case 2:
		atio->cdb_len = 10;
		break;
	case 4:
		atio->cdb_len = 16;
		break;
	case 5:
		atio->cdb_len = 12;
		break;
	case 3:
	default:
		/* Only copy the opcode. */
		atio->cdb_len = 1;
		printf("Reserved or VU command code type encountered\n");
		break;
	}
	
	memcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);
d5908 2
a5909 1
	atio->ccb_h.status |= CAM_CDB_RECVD;
d5911 1
a5911 17
	if ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {
		/*
		 * We weren't allowed to disconnect.
		 * We're hanging on the bus until a
		 * continue target I/O comes in response
		 * to this accept tio.
		 */
#if 0
		printf("Received Immediate Command %d:%d:%d - %p\n",
		       initiator, target, lun, ahc->pending_device);
#endif
		ahc->pending_device = lstate;
		ahc_freeze_ccb((union ccb *)atio);
		atio->ccb_h.flags |= CAM_DIS_DISCONNECT;
	}
	xpt_done((union ccb*)atio);
	return (0);
a5912 2

#endif
@


1.34
log
@Compile with AHC_DEBUG
@
text
@d2 1
a2 5
 * Generic driver for the aic7xxx based adaptec SCSI controllers
 * Product specific probe and attach routines can be found in:
 * i386/eisa/ahc_eisa.c	27/284X and aic7770 motherboard controllers
 * pci/ahc_pci.c	3985, 3980, 3940, 2940, aic7895, aic7890,
 *			aic7880, aic7870, aic7860, and aic7850 controllers
d4 1
a4 1
 * Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999, 2000 Justin T. Gibbs.
d17 1
a17 1
 * the GNU Public License ("GPL").
d31 1
a31 50
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.40 2000/01/07 23:08:17 gibbs Exp $
 * $OpenBSD: aic7xxx.c,v 1.33 2001/11/06 19:53:18 miod Exp $
 */
/*
 * A few notes on features of the driver.
 *
 * SCB paging takes advantage of the fact that devices stay disconnected
 * from the bus a relatively long time and that while they're disconnected,
 * having the SCBs for these transactions down on the host adapter is of
 * little use.  Instead of leaving this idle SCB down on the card we copy
 * it back up into kernel memory and reuse the SCB slot on the card to
 * schedule another transaction.  This can be a real payoff when doing random
 * I/O to tagged queueing devices since there are more transactions active at
 * once for the device to sort for optimal seek reduction. The algorithm goes
 * like this...
 *
 * The sequencer maintains two lists of its hardware SCBs.  The first is the
 * singly linked free list which tracks all SCBs that are not currently in
 * use.  The second is the doubly linked disconnected list which holds the
 * SCBs of transactions that are in the disconnected state sorted most
 * recently disconnected first.  When the kernel queues a transaction to
 * the card, a hardware SCB to "house" this transaction is retrieved from
 * either of these two lists.  If the SCB came from the disconnected list,
 * a check is made to see if any data transfer or SCB linking (more on linking
 * in a bit) information has been changed since it was copied from the host
 * and if so, DMAs the SCB back up before it can be used.  Once a hardware
 * SCB has been obtained, the SCB is DMAed from the host.  Before any work
 * can begin on this SCB, the sequencer must ensure that either the SCB is
 * for a tagged transaction or the target is not already working on another
 * non-tagged transaction.  If a conflict arises in the non-tagged case, the
 * sequencer finds the SCB for the active transactions and sets the SCB_LINKED
 * field in that SCB to this next SCB to execute.  To facilitate finding
 * active non-tagged SCBs, the last four bytes of up to the first four hardware
 * SCBs serve as a storage area for the currently active SCB ID for each
 * target.
 *
 * When a device reconnects, a search is made of the hardware SCBs to find
 * the SCB for this transaction.  If the search fails, a hardware SCB is
 * pulled from either the free or disconnected SCB list and the proper
 * SCB is DMAed from the host.  If the MK_MESSAGE control bit is set
 * in the control byte of the SCB while it was disconnected, the sequencer
 * will assert ATN and attempt to issue a message to the host.
 *
 * When a command completes, a check for non-zero status and residuals is
 * made.  If either of these conditions exists, the SCB is DMAed back up to
 * the host so that it can interpret this information.  Additionally, in the
 * case of bad status, the sequencer generates a special interrupt and pauses
 * itself.  This allows the host to setup a request sense command if it 
 * chooses for this target synchronously with the error so that sense
 * information isn't lost.
d33 1
d36 12
a47 14
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/proc.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_message.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>
d49 19
a67 7
#include <uvm/uvm_extern.h>

#include <dev/ic/aic7xxxreg.h>
#include <dev/ic/aic7xxxvar.h>
#include <dev/microcode/aic7xxx/aic7xxx_seq.h>
#include <dev/microcode/aic7xxx/sequencer.h>
#include "pci.h"
d70 1
a70 2
 * Some ISA devices (e.g. on a VLB) can perform 32-bit DMA.  This
 * flag is passed to bus_dmamap_create() to indicate that fact.
d72 4
a75 3
#ifndef ISABUS_DMA_32BIT
#define ISABUS_DMA_32BIT	BUS_DMA_BUS1
#endif 
d77 11
a87 4
#ifndef AHC_TMODE_ENABLE
#define AHC_TMODE_ENABLE 0
#endif
#include <sys/kernel.h>
d89 13
a101 3
#ifndef le32toh
#define le32toh	letoh32  /* to match Free/Net macros */
#endif
d103 5
a107 49
#define	IS_SCSIBUS_B(ahc, sc_link)	\
	((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
#define ALL_CHANNELS '\0'
#define ALL_TARGETS_MASK 0xFFFF
#define INITIATOR_WILDCARD	(~0)

#define	SIM_IS_SCSIBUS_B(ahc, sc_link)	\
	((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
#define	SIM_CHANNEL(ahc, sc_link)	\
	(SIM_IS_SCSIBUS_B(ahc, sc_link) ? 'B' : 'A')
#define	SIM_SCSI_ID(ahc, sc_link)	\
	(SIM_IS_SCSIBUS_B(ahc, sc_link) ? ahc->our_id_b : ahc->our_id)
#define	SCB_IS_SCSIBUS_B(scb)	\
	(((scb)->hscb->tcl & SELBUSB) != 0)
#define	SCB_TARGET(scb)	\
	(((scb)->hscb->tcl & TID) >> 4)
#define	SCB_CHANNEL(scb) \
	(SCB_IS_SCSIBUS_B(scb) ? 'B' : 'A')
#define	SCB_LUN(scb)	\
	((scb)->hscb->tcl & LID)
#define SCB_TARGET_OFFSET(scb)		\
	(SCB_TARGET(scb) + (SCB_IS_SCSIBUS_B(scb) ? 8 : 0))
#define SCB_TARGET_MASK(scb)		\
	(0x01 << (SCB_TARGET_OFFSET(scb)))
#define TCL_CHANNEL(ahc, tcl)		\
	((((ahc)->features & AHC_TWIN) && ((tcl) & SELBUSB)) ? 'B' : 'A')
#define TCL_SCSI_ID(ahc, tcl)		\
	(TCL_CHANNEL((ahc), (tcl)) == 'B' ? (ahc)->our_id_b : (ahc)->our_id)
#define TCL_TARGET(tcl) (((tcl) & TID) >> TCL_TARGET_SHIFT)
#define TCL_LUN(tcl) ((tcl) & LID)

#define XS_TCL(ahc, xs) \
	((((xs)->sc_link->target << 4) & 0xF0) \
	| (SIM_IS_SCSIBUS_B((ahc), (xs)->sc_link) ? SELBUSB : 0) \
	| ((xs)->sc_link->lun & 0x07))

/*
 * Under normal circumstances, these messages are unnecessary
 * and not terribly cosmetic.
 */
#ifdef DEBUG
#define bootverbose	1
#define STATIC
#define INLINE
#else
#define bootverbose	0
#define STATIC	static
#define INLINE __inline
#endif
d109 23
a131 17
typedef enum {
	ROLE_UNKNOWN,
	ROLE_INITIATOR,
	ROLE_TARGET
} role_t;

struct ahc_devinfo {
	int	  our_scsiid;
	int	  target_offset;
	u_int16_t target_mask;
	u_int8_t  target;
	u_int8_t  lun;
	char	  channel;
	role_t	  role;		/*
				 * Only guaranteed to be correct if not
				 * in the busfree state.
				 */
d134 6
a139 5
typedef enum {
	SEARCH_COMPLETE,
	SEARCH_COUNT,
	SEARCH_REMOVE
} ahc_search_action;
d141 7
a147 2
#ifdef AHC_DEBUG
static int     ahc_debug = AHC_DEBUG;
d149 52
a200 3

#if NPCI > 0
void ahc_pci_intr(struct ahc_softc *ahc);
d203 10
a212 40
STATIC int	ahcinitscbdata(struct ahc_softc *ahc);
STATIC void	ahcfiniscbdata(struct ahc_softc *ahc);

STATIC int	ahc_poll __P((struct ahc_softc *ahc, int wait));
STATIC void	ahc_shutdown __P((void *arg));
STATIC int	ahc_execute_scb __P((void *arg, bus_dma_segment_t *dm_segs,
				     int nsegments));
STATIC int	ahc_setup_data __P((struct ahc_softc *ahc,
				    struct scsi_xfer *xs, struct scb *scb));
STATIC void	ahc_freeze_devq __P((struct ahc_softc *ahc,
				     struct scsi_link *sc_link));
STATIC void	ahcallocscbs __P((struct ahc_softc *ahc));
STATIC void	ahc_fetch_devinfo __P((struct ahc_softc *ahc,
				       struct ahc_devinfo *devinfo));
STATIC void	ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,
					 u_int our_id, u_int target,
					 u_int lun, char channel,
					 role_t role));
STATIC u_int	ahc_abort_wscb __P((struct ahc_softc *ahc,
				    u_int scbpos, u_int prev));
STATIC void	ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));
STATIC struct tmode_tstate *
		ahc_alloc_tstate __P((struct ahc_softc *ahc, u_int scsi_id,
				      char channel));
STATIC void	ahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));
STATIC void	ahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));
STATIC void	ahc_build_transfer_msg __P((struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo));
STATIC void	ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,
						struct ahc_devinfo *devinfo,
						struct scb *scb));
STATIC void	ahc_setup_target_msgin __P((struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo));
STATIC int	ahc_handle_msg_reject __P((struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo));
STATIC void	ahc_clear_msg_state __P((struct ahc_softc *ahc));
STATIC void	ahc_handle_message_phase __P((struct ahc_softc *ahc,
					      struct scsi_link *sc_link));
STATIC int	ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,
				  int full));
d214 13
a226 15
typedef enum {
	MSGLOOP_IN_PROG,
	MSGLOOP_MSGCOMPLETE,
	MSGLOOP_TERMINATED
} msg_loop_stat;

STATIC int	ahc_parse_msg __P((struct ahc_softc *ahc,
				   struct scsi_link *sc_link,
				   struct ahc_devinfo *devinfo));
STATIC void	ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,
						 struct ahc_devinfo *devinfo));
STATIC void	ahc_handle_devreset __P((struct ahc_softc *ahc,
					 struct ahc_devinfo *devinfo,
					 int status, char *message,
					 int verbose_level));
d228 1
a228 1
STATIC void	ahc_dumpseq __P((struct ahc_softc *ahc));
d230 16
a245 10
STATIC void	ahc_loadseq __P((struct ahc_softc *ahc));
STATIC int	ahc_check_patch __P((struct ahc_softc *ahc,
				     struct patch **start_patch,
				     int start_instr, int *skip_addr));
STATIC void	ahc_download_instr __P((struct ahc_softc *ahc,
					int instrptr, u_int8_t *dconsts));
STATIC int	ahc_match_scb __P((struct scb *scb, int target, char channel,
				   int lun, u_int tag, role_t role));
#ifdef AHC_DEBUG
STATIC void	ahc_print_scb __P((struct scb *scb));
d247 1
a247 149
STATIC int	ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,
					char channel, int lun, u_int tag,
					role_t role, u_int32_t status,
					ahc_search_action action));
STATIC int	ahc_reset_channel __P((struct ahc_softc *ahc, char channel,
				       int initiate_reset));
STATIC int	ahc_abort_scbs __P((struct ahc_softc *ahc, int target,
				    char channel, int lun, u_int tag,
				    role_t role, u_int32_t status));
STATIC int	ahc_search_disc_list __P((struct ahc_softc *ahc, int target,
					  char channel, int lun, u_int tag,
					  int stop_on_first, int remove,
					  int save_state));
STATIC u_int	ahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,
						u_int prev, u_int scbptr));
STATIC void	ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));
STATIC void	ahc_clear_intstat __P((struct ahc_softc *ahc));
STATIC void	ahc_reset_current_bus __P((struct ahc_softc *ahc));
STATIC struct ahc_syncrate *
		ahc_devlimited_syncrate __P((struct ahc_softc *ahc, u_int *period));
STATIC struct ahc_syncrate *
		ahc_find_syncrate __P((struct ahc_softc *ahc, u_int *period,
				       u_int maxsync));
STATIC u_int ahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,
				  u_int maxsync));
STATIC void	ahc_validate_offset __P((struct ahc_softc *ahc,
					 struct ahc_syncrate *syncrate,
					 u_int *offset, int wide)); 
STATIC void	ahc_update_target_msg_request __P((struct ahc_softc *ahc,
					      struct ahc_devinfo *devinfo,
					      struct ahc_initiator_tinfo *tinfo,
					      int force, int paused));
STATIC void	ahc_set_syncrate __P((struct ahc_softc *ahc,
				      struct ahc_devinfo *devinfo,
				      struct ahc_syncrate *syncrate,
				      u_int period, u_int offset,
				      u_int type, int paused, int done));
STATIC void	ahc_set_width __P((struct ahc_softc *ahc,
			      struct ahc_devinfo *devinfo,
			      u_int width, u_int type, int paused, int done));
STATIC void	ahc_set_tags __P((struct ahc_softc *ahc,
				  struct ahc_devinfo *devinfo,int enable));
STATIC int      ahc_istagged_device __P((struct ahc_softc *ahc,
					 struct scsi_xfer *xs,
					 int nocmdcheck));
STATIC void     ahc_check_tags __P((struct ahc_softc *ahc,
				    struct scsi_xfer *xs));
STATIC void	ahc_construct_sdtr __P((struct ahc_softc *ahc,
				   u_int period, u_int offset));
STATIC void	ahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));

STATIC void	ahc_calc_residual __P((struct scb *scb));

STATIC void	ahc_update_pending_syncrates __P((struct ahc_softc *ahc));

STATIC void	ahc_set_recoveryscb __P((struct ahc_softc *ahc,
					 struct scb *scb));
STATIC void ahc_timeout __P((void *));

static __inline int  sequencer_paused __P((struct ahc_softc *ahc));
static __inline void pause_sequencer __P((struct ahc_softc *ahc));
static __inline void unpause_sequencer __P((struct ahc_softc *ahc));
STATIC void restart_sequencer __P((struct ahc_softc *ahc));
static __inline u_int ahc_index_busy_tcl __P((struct ahc_softc *ahc,
					      u_int tcl, int unbusy));
 
static __inline void	ahc_busy_tcl __P((struct ahc_softc *ahc,
					  struct scb *scb));
static __inline int	ahc_isbusy_tcl __P((struct ahc_softc *ahc,
					    struct scb *scb));
static __inline void ahc_freeze_ccb __P((struct scb* scb));
static __inline void ahcsetccbstatus __P((struct scsi_xfer *xs, int status));
STATIC void ahc_run_qoutfifo __P((struct ahc_softc *ahc));

static __inline struct ahc_initiator_tinfo *
	ahc_fetch_transinfo __P((struct ahc_softc *ahc, char channel,
				 u_int our_id, u_int target,
				 struct tmode_tstate **tstate));
STATIC void ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));
static __inline struct scb *ahcgetscb __P((struct ahc_softc *ahc));
int    ahc_createdmamem __P((struct ahc_softc *ahc, int size,
			     bus_dmamap_t *mapp, caddr_t *vaddr,
			     bus_addr_t *baddr, bus_dma_segment_t *segs,
			     int *nseg, const char *what));
STATIC void ahc_freedmamem __P((bus_dma_tag_t tag, int size,
				bus_dmamap_t map, caddr_t vaddr,
				bus_dma_segment_t *seg, int nseg));
STATIC void ahcminphys __P((struct buf *bp));

STATIC INLINE	struct scsi_xfer *ahc_first_xs __P((struct ahc_softc *));
STATIC INLINE	void   ahc_list_insert_before __P((struct ahc_softc *ahc,
						   struct scsi_xfer *xs,
						   struct scsi_xfer *next_xs));
STATIC INLINE	void   ahc_list_insert_head __P((struct ahc_softc *ahc,
						 struct scsi_xfer *xs));
STATIC INLINE	void   ahc_list_insert_tail __P((struct ahc_softc *ahc,
						 struct scsi_xfer *xs));
STATIC INLINE	void   ahc_list_remove __P((struct ahc_softc *ahc,
					    struct scsi_xfer *xs));
STATIC INLINE	struct scsi_xfer *ahc_list_next __P((struct ahc_softc *ahc,
						     struct scsi_xfer *xs));
STATIC int32_t ahc_scsi_cmd __P((struct scsi_xfer *xs));
static __inline void ahc_swap_hscb __P((struct hardware_scb *));
static __inline void ahc_swap_sg __P((struct ahc_dma_seg *));

struct cfdriver ahc_cd = {
	NULL, "ahc", DV_DULL
};

static struct scsi_adapter ahc_switch =
{
	ahc_scsi_cmd,
	ahcminphys,
	0,
	0,
};

/* the below structure is so we have a default dev struct for our link struct */
static struct scsi_device ahc_dev =
{
	NULL, /* Use default error handler */
	NULL, /* have a queue, served by this */
	NULL, /* have no async handler */
	NULL, /* Use default 'done' routine */
};

static __inline void
ahc_swap_hscb(struct hardware_scb *hscb)
{
	hscb->SG_pointer = htole32(hscb->SG_pointer);
	hscb->data = htole32(hscb->data);
	hscb->datalen = htole32(hscb->datalen);
	/*
	 * No need to swap cmdpointer; it's either 0 or set to
	 * cmdstore_busaddr, which is already swapped.
	 */
}

static __inline void
ahc_swap_sg(struct ahc_dma_seg *sg)
{
	sg->addr = htole32(sg->addr);
	sg->len = htole32(sg->len);
}

STATIC void
ahcminphys(bp)
	struct buf *bp;
{
d249 1
a249 5
 * Even though the card can transfer up to 16megs per command
 * we are limited by the number of segments in the dma segment
 * list that we can hold.  The worst case is that all pages are
 * discontinuous physically, hense the "page per segment" limit
 * enforced here.
d251 2
a252 9
	if (bp->b_bcount > ((AHC_NSEG - 1) * PAGE_SIZE)) {
		bp->b_bcount = ((AHC_NSEG - 1) * PAGE_SIZE);
	}
	minphys(bp);
}


static __inline u_int32_t
ahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)
a253 5
	return (ahc->scb_data->hscb_busaddr
		+ (sizeof(struct hardware_scb) * index));
}

#define AHC_BUSRESET_DELAY	25	/* Reset delay in us */
d255 1
a255 6
static __inline int
sequencer_paused(ahc)
	struct ahc_softc *ahc;
{
	return ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);
}
d257 3
a259 5
static __inline void
pause_sequencer(ahc)
	struct ahc_softc *ahc;
{
	ahc_outb(ahc, HCNTRL, ahc->pause);
d262 5
a266 36
	 * Since the sequencer can disable pausing in a critical section, we
	 * must loop until it actually stops.
	 */
	while (sequencer_paused(ahc) == 0)
		;
}

static __inline void
unpause_sequencer(ahc)
	struct ahc_softc *ahc;
{
	if ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)
		ahc_outb(ahc, HCNTRL, ahc->unpause);
}

/*
 * Restart the sequencer program from address zero
 */
STATIC void
restart_sequencer(ahc)
	struct ahc_softc *ahc;
{
	u_int i;

	pause_sequencer(ahc);

	/*
	 * Everytime we restart the sequencer, there
	 * is the possiblitity that we have restarted
	 * within a three instruction window where an
	 * SCB has been marked free but has not made it
	 * onto the free list.  Since SCSI events(bus reset,
	 * unexpected bus free) will always freeze the
	 * sequencer, we cannot close this window.  To
	 * avoid losing an SCB, we reconsitute the free
	 * list every time we restart the sequencer.
d268 1
a268 54
	ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		
		ahc_outb(ahc, SCBPTR, i);
		if (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)
			ahc_add_curscb_to_free_list(ahc);
	}
	ahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);
	unpause_sequencer(ahc);
}

static __inline u_int
ahc_index_busy_tcl(ahc, tcl, unbusy)
	struct ahc_softc *ahc;
	u_int tcl;
	int unbusy;
{
	u_int scbid;

	scbid = ahc->untagged_scbs[tcl];
	if (unbusy) {
		ahc->untagged_scbs[tcl] = SCB_LIST_NULL;
		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
		    UNTAGGEDSCB_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
	}

	return (scbid);
}

static __inline void
ahc_busy_tcl(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
	ahc->untagged_scbs[scb->hscb->tcl] = scb->hscb->tag;
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    UNTAGGEDSCB_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
}

static __inline int
ahc_isbusy_tcl(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
	return ahc->untagged_scbs[scb->hscb->tcl] != SCB_LIST_NULL;
}

static __inline void
ahc_freeze_ccb(scb)
	struct scb *scb;
{
	struct scsi_xfer *xs = scb->xs;
	struct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
	int target;
d270 8
a277 4
	target = xs->sc_link->target;
	if (!(scb->flags & SCB_FREEZE_QUEUE)) {
		ahc->devqueue_blocked[target]++;
		scb->flags |= SCB_FREEZE_QUEUE;
a278 18
}

static __inline void
ahcsetccbstatus(xs, status)
	struct scsi_xfer *xs;
	int status;
{
	xs->error = status;
}

static __inline struct ahc_initiator_tinfo *
ahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)
	struct ahc_softc *ahc;
	char channel;
	u_int our_id;
	u_int remote_id;
	struct tmode_tstate **tstate;
{
d280 3
a282 4
	 * Transfer data structures are stored from the perspective
	 * of the target role.  Since the parameters for a connection
	 * in the initiator role to a given target are the same as
	 * when the roles are reversed, we pretend we are the target.
d284 10
a293 4
	if (channel == 'B')
		our_id += 8;
	*tstate = ahc->enabled_targets[our_id];
	return (&(*tstate)->transinfo[remote_id]);
d296 3
a298 3
STATIC void
ahc_run_qoutfifo(ahc)
	struct ahc_softc *ahc;
d303 2
a304 2
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    0, 256, BUS_DMASYNC_POSTREAD);
a305 1
	while (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {
d307 18
a324 1
		ahc->qoutfifo[ahc->qoutfifonext++] = SCB_LIST_NULL;
d326 2
a327 3
		scb = &ahc->scb_data->scbarray[scb_index];
		if (scb_index >= ahc->scb_data->numscbs
		  || (scb->flags & SCB_ACTIVE) == 0) {
d339 1
a339 4
		if (scb->hscb->residual_SG_count != 0)
			ahc_calc_residual(scb);
		else
			scb->xs->resid = 0;
d344 8
d353 3
a355 7
/*
 * An scb (and hence an scb entry on the board) is put onto the
 * free list.
 */
STATIC void
ahcfreescb(ahc, scb)
	struct ahc_softc *ahc;
a356 3
{       
	struct hardware_scb *hscb;
	int opri;
d358 2
a359 8
	hscb = scb->hscb;

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWSCBS)
		printf("%s: free SCB tag %x\n", ahc_name(ahc), hscb->tag);
#endif

	opri = splbio();
d361 4
a364 4
	if ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||
	    (scb->flags & SCB_RECOVERY_SCB) != 0) {
		ahc->flags &= ~AHC_RESOURCE_SHORTAGE;
		ahc->queue_blocked = 0;
a365 10

	/* Clean up for the next user */
	scb->flags = SCB_FREE;
	hscb->control = 0;
	hscb->status = 0;
	timeout_del(&scb->xs->stimeout);

	SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links);

	splx(opri);
d368 3
a370 9
/*
 * Get a free scb, either one already assigned to a hardware slot
 * on the adapter or one that will require an SCB to be paged out before
 * use. If there are none, see if we can allocate a new SCB.  Otherwise
 * either return an error or sleep.
 */
static __inline struct scb *
ahcgetscb(ahc)
	struct ahc_softc *ahc;
d372 6
a377 12
	struct scb *scbp;
	int opri;

	opri = splbio();
	if ((scbp = SLIST_FIRST(&ahc->scb_data->free_scbs))) {
		SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links);
	} else {
		ahcallocscbs(ahc);
		scbp = SLIST_FIRST(&ahc->scb_data->free_scbs);
		if (scbp != NULL)
			SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links);
	}
d379 14
a392 1
	splx(opri);
d394 2
a395 1
	return (scbp);
d398 5
a402 17
int
ahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)
	struct ahc_softc *ahc;
	int size;
	bus_dmamap_t *mapp;
	caddr_t *vaddr;
	bus_addr_t *baddr;
	bus_dma_segment_t *seg;
	int *nseg;
	const char *what;
{
	int error, level = 0;
	int dma_flags = BUS_DMA_NOWAIT;
	bus_dma_tag_t tag = ahc->sc_dmat;
	const char *myname = ahc_name(ahc);
	if ((ahc->chip & AHC_VL) !=0)
		dma_flags |= ISABUS_DMA_32BIT;
d404 1
a404 47
	if ((error = bus_dmamem_alloc(tag, size, NBPG, 0,
			seg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to allocate DMA mem for %s, error = %d\n",
			myname, what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,
			BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: failed to map DMA mem for %s, error = %d\n",
			myname, what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamap_create(tag, size, 1, size, 0,
			dma_flags, mapp)) != 0) {
		printf("%s: failed to create DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }
	level++;

	if ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,
			BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to load DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }

	*baddr = (*mapp)->dm_segs[0].ds_addr;
	return 0;
out:
	switch (level) {
	case 3:
		bus_dmamap_destroy(tag, *mapp);
		/* FALLTHROUGH */
	case 2:
		bus_dmamem_unmap(tag, *vaddr, size);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(tag, seg, *nseg);
		break;
	default:
		break;
	}
d406 12
a417 2
	return error;
}
d419 6
a424 9
STATIC void
ahc_freedmamem(tag, size, map, vaddr, seg, nseg)
	bus_dma_tag_t tag;
	int size;
	bus_dmamap_t map;
	caddr_t vaddr;
	bus_dma_segment_t *seg;
	int nseg;
{
d426 20
a445 5
	bus_dmamap_unload(tag, map);
	bus_dmamap_destroy(tag, map);
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
}
d447 1
a447 6
#ifdef  AHC_DEBUG
STATIC void
ahc_print_scb(scb)
	struct scb *scb;
{
	struct hardware_scb *hscb = scb->hscb;
d449 1176
a1624 20
	printf("scb:%p tag %x control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n",
		scb,
		hscb->tag,
		hscb->control,
		hscb->tcl,
		hscb->cmdlen,
		(unsigned long)le32toh(hscb->cmdpointer));
	printf("        datlen:%u data:0x%lx segs:0x%x segp:0x%lx\n",
		le32toh(hscb->datalen),
		(unsigned long)(le32toh(hscb->data)),
		hscb->SG_count,
		(unsigned long)(le32toh(hscb->SG_pointer)));
	printf("	sg_addr:%lx sg_len:%lu\n",
		(unsigned long)(le32toh(scb->sg_list[0].addr)),
		(unsigned long)(le32toh(scb->sg_list[0].len)));
	printf("	cdb:%x %x %x %x %x %x %x %x %x %x %x %x\n",
		hscb->cmdstore[0], hscb->cmdstore[1], hscb->cmdstore[2],
		hscb->cmdstore[3], hscb->cmdstore[4], hscb->cmdstore[5],
		hscb->cmdstore[6], hscb->cmdstore[7], hscb->cmdstore[8],
		hscb->cmdstore[9], hscb->cmdstore[10], hscb->cmdstore[11]);
a1625 1
#endif
d1627 16
a1642 14
static struct {
        u_int8_t errno;
	char *errmesg;
} hard_error[] = {
	{ ILLHADDR,	"Illegal Host Access" },
	{ ILLSADDR,	"Illegal Sequencer Address referrenced" },
	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
	{ SQPARERR,	"Sequencer Parity Error" },
	{ DPARERR,	"Data-path Parity Error" },
	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
	{ PCIERRSTAT,	"PCI Error detected" },
	{ CIOPARERR,	"CIOBUS Parity Error" },
};
static const int num_errors = sizeof(hard_error)/sizeof(hard_error[0]);
d1644 12
a1655 15
static struct {
        u_int8_t phase;
        u_int8_t mesg_out; /* Message response to parity errors */
	char *phasemsg;
} phase_table[] = {
	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
	{ 0,		MSG_NOOP,		"in unknown phase"	}
};
static const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;
d1658 2
a1659 3
 * Valid SCSIRATE values.  (p. 3-17)
 * Provides a mapping of tranfer periods in ns to the proper value to
 * stick in the scsiscfr reg to use that transfer rate.
d1661 27
a1687 22
#define AHC_SYNCRATE_DT		0
#define AHC_SYNCRATE_ULTRA2	1
#define AHC_SYNCRATE_ULTRA	3
#define AHC_SYNCRATE_FAST	6
static struct ahc_syncrate ahc_syncrates[] = {
      /* ultra2    fast/ultra  period     rate */
	{ 0x42,      0x000,      9,      "80.0" },
	{ 0x03,      0x000,     10,      "40.0" },
	{ 0x04,      0x000,     11,      "33.0" },
	{ 0x05,      0x100,     12,      "20.0" },
	{ 0x06,      0x110,     15,      "16.0" },
	{ 0x07,      0x120,     18,      "13.4" },
	{ 0x08,      0x000,     25,      "10.0" },
	{ 0x19,      0x010,     31,      "8.0"  },
	{ 0x1a,      0x020,     37,      "6.67" },
	{ 0x1b,      0x030,     43,      "5.7"  },
	{ 0x1c,      0x040,     50,      "5.0"  },
	{ 0x00,      0x050,     56,      "4.4"  },
	{ 0x00,      0x060,     62,      "4.0"  },
	{ 0x00,      0x070,     68,      "3.6"  },
	{ 0x00,      0x000,      0,      NULL   }
};
d1690 2
a1691 3
 * Allocate a controller structure for a new device and initialize it.
 * ahc_reset should be called before now since we assume that the card
 * is paused.
d1694 2
a1695 8
ahc_construct(ahc, iot, ioh, chip, flags, features, channel)
	struct  ahc_softc *ahc;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ahc_chip chip;
	ahc_flag flags;
	ahc_feature features;
	u_char channel;
d1697 45
a1741 12
	/*
	 * find unit and check we have that many defined
	 */
	LIST_INIT(&ahc->pending_scbs);
	ahc->sc_iot = iot;
	ahc->sc_ioh = ioh;
	ahc->chip = chip;
	ahc->flags = flags;
	ahc->features = features;
	ahc->channel = channel;
	ahc->scb_data = NULL;
	ahc->pci_intr_func = NULL;
d1743 1
a1743 5
	ahc->unpause = (ahc_inb(ahc, HCNTRL) & IRQMS) | INTEN;
	/* The IRQMS bit is only valid on VL and EISA chips */
	if ((ahc->chip & AHC_PCI) != 0)
		ahc->unpause &= ~IRQMS;
	ahc->pause = ahc->unpause | PAUSE;
d1746 8
d1755 3
a1757 2
ahc_free(ahc)
	struct ahc_softc *ahc;
d1759 112
a1870 11
	ahcfiniscbdata(ahc);
	if (ahc->init_level != 0)
		ahc_freedmamem(ahc->sc_dmat, ahc->shared_data_size,
		    ahc->shared_data_dmamap, ahc->qoutfifo,
		    &ahc->shared_data_seg, ahc->shared_data_nseg);

	if (ahc->scb_data != NULL)
		free(ahc->scb_data, M_DEVBUF);
	if (ahc->pci_data != NULL)
		free(ahc->pci_data, M_DEVBUF);
	return;
d1873 11
a1883 3
STATIC int
ahcinitscbdata(ahc)
	struct ahc_softc *ahc;
d1885 16
a1900 6
	struct scb_data *scb_data;
	int i;
	
	scb_data = ahc->scb_data;
	SLIST_INIT(&scb_data->free_scbs);
	SLIST_INIT(&scb_data->sg_maps);
d1902 3
a1904 7
	/* Allocate SCB resources */
	scb_data->scbarray =
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,
				 M_DEVBUF, M_NOWAIT);
	if (scb_data->scbarray == NULL)
		return (ENOMEM);
	bzero(scb_data->scbarray, sizeof(struct scb) * AHC_SCB_MAX);
d1906 5
a1910 1
	/* Determine the number of hardware SCBs and initialize them */
d1912 1
a1912 5
	scb_data->maxhscbs = ahc_probe_scbs(ahc);
	/* SCB 0 heads the free list */
	ahc_outb(ahc, FREE_SCBH, 0);
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		ahc_outb(ahc, SCBPTR, i);
d1914 2
a1915 2
		/* Clear the control byte. */
		ahc_outb(ahc, SCB_CONTROL, 0);
d1917 1
a1917 2
		/* Set the next pointer */
		ahc_outb(ahc, SCB_NEXT, i+1);
d1919 7
a1925 2
		/* Make the tag number invalid */
		ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
d1928 5
a1932 3
	/* Make sure that the last SCB terminates the free list */
	ahc_outb(ahc, SCBPTR, i-1);
	ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);
d1934 11
a1944 3
	/* Ensure we clear the 0 SCB's control byte. */
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outb(ahc, SCB_CONTROL, 0);
d1946 13
a1958 4
	scb_data->maxhscbs = i;

	if (ahc->scb_data->maxhscbs == 0)
		panic("%s: No SCB space found", ahc_name(ahc));
d1961 2
a1962 7
	 * Create our DMA tags.  These tags define the kinds of device
	 * accessable memory allocations and memory mappings we will
	 * need to perform during normal operation.
	 *
	 * Unless we need to further restrict the allocation, we rely
	 * on the restrictions of the parent dmat, hence the common
	 * use of MAXADDR and MAXSIZE.
d1964 6
d1971 19
a1989 6
	if (ahc_createdmamem(ahc,
	    AHC_SCB_MAX * sizeof(struct hardware_scb), 
	    &scb_data->hscb_dmamap, (caddr_t *)&scb_data->hscbs, 
	    &scb_data->hscb_busaddr, &scb_data->hscb_seg,
	    &scb_data->hscb_nseg, "hardware SCB structures") < 0)
		goto error_exit;
d1991 2
a1992 1
	scb_data->init_level++;
d1994 6
a1999 6
	if (ahc_createdmamem(ahc,
	    AHC_SCB_MAX * sizeof(struct scsi_sense_data),
	    &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,
	    &scb_data->sense_busaddr, &scb_data->sense_seg,
	    &scb_data->sense_nseg, "sense buffers") < 0)
		goto error_exit;
d2001 6
a2006 1
	scb_data->init_level++;
d2008 5
a2012 3
	/* Perform initial CCB allocation */
	bzero(scb_data->hscbs, AHC_SCB_MAX * sizeof(struct hardware_scb));
	ahcallocscbs(ahc);
d2014 7
a2020 5
	if (scb_data->numscbs == 0) {
		printf("%s: ahc_init_scb_data - "
		       "Unable to allocate initial scbs\n",
		       ahc_name(ahc));
		goto error_exit;
d2022 1
d2024 11
a2034 1
	scb_data->init_level++;
d2036 4
a2039 4
	/*
	 * Note that we were successfull
	 */
	return 0; 
d2041 9
a2049 1
error_exit:
d2051 7
a2057 1
	return ENOMEM;
d2060 2
a2061 3
STATIC void
ahcfiniscbdata(ahc)
	struct ahc_softc *ahc;
d2063 2
a2064 1
	struct scb_data *scb_data;
d2066 8
a2073 15
	scb_data = ahc->scb_data;

	switch (scb_data->init_level) {
	default:
	case 3:
	{
		struct sg_map_node *sg_map;

		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
			ahc_freedmamem(ahc->sc_dmat, PAGE_SIZE,
			    sg_map->sg_dmamap, (caddr_t)sg_map->sg_vaddr,
			    &sg_map->sg_dmasegs, sg_map->sg_nseg);
			free(sg_map, M_DEVBUF);
		}
d2075 1
a2075 16
	/*FALLTHROUGH*/
	case 2:
		ahc_freedmamem(ahc->sc_dmat,
		    AHC_SCB_MAX * sizeof(struct scsi_sense_data),
		    scb_data->sense_dmamap, (caddr_t)scb_data->sense,
		    &scb_data->sense_seg, scb_data->sense_nseg);
	/*FALLTHROUGH*/
	case 1:
		ahc_freedmamem(ahc->sc_dmat,
		    AHC_SCB_MAX * sizeof(struct hardware_scb), 
		    scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,
		    &scb_data->hscb_seg, scb_data->hscb_nseg);
	/*FALLTHROUGH*/
	}
	if (scb_data->scbarray != NULL)
		free(scb_data->scbarray, M_DEVBUF);
d2079 2
a2080 4
ahc_xxx_reset(devname, iot, ioh)
	char *devname;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d2082 10
a2091 2
	u_char hcntrl;
	int wait;
d2093 6
a2098 5
#ifdef AHC_DUMP_SEQ
	ahc_dumpseq(ahc);
#endif
	/* Retain the IRQ type accross the chip reset */
	hcntrl = (bus_space_read_1(iot, ioh, HCNTRL) & IRQMS) | INTEN;
d2100 6
a2105 12
	bus_space_write_1(iot, ioh, HCNTRL, CHIPRST | PAUSE);
	/*
	 * Ensure that the reset has finished
	 */
	wait = 1000;
	while (--wait && !(bus_space_read_1(iot, ioh, HCNTRL) & CHIPRSTACK))
		DELAY(1000);
	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
				 "Trying to initialize anyway.\n", devname);
	}
	bus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);
d2108 4
a2111 3
int
ahc_reset(ahc)
	struct ahc_softc *ahc;
d2113 1
a2113 15
	u_int	sblkctl;
	int	wait;
	
#ifdef AHC_DUMP_SEQ
	if (ahc->init_level == 0)
		ahc_dumpseq(ahc);
#endif
	ahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);
	/*
	 * Ensure that the reset has finished
	 */
	wait = 1000;
	do {
		DELAY(1000);
	} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));
d2115 4
a2118 28
	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", ahc_name(ahc));
	}
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/* Determine channel configuration */
	sblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);
	/* No Twin Channel PCI cards */
	if ((ahc->chip & AHC_PCI) != 0)
		sblkctl &= ~SELBUSB;
	switch (sblkctl) {
	case 0:
		/* Single Narrow Channel */
		break;
	case 2:
		/* Wide Channel */
		ahc->features |= AHC_WIDE;
		break;
	case 8:
		/* Twin Channel */
		ahc->features |= AHC_TWIN;
		break;
	default:
		printf(" Unsupported adapter type.  Ignoring\n");
		return(-1);
	}
	return (0);
d2122 4
a2125 3
 * Called when we have an active connection to a target on the bus,
 * this function finds the nearest syncrate to the input period limited
 * by the capabilities of the bus connectivity of the target.
d2127 3
a2129 4
STATIC struct ahc_syncrate *
ahc_devlimited_syncrate(ahc, period)
	struct ahc_softc *ahc;
	u_int *period;
d2131 17
a2147 1
	u_int	maxsync;
d2149 5
a2153 6
	if ((ahc->features & AHC_ULTRA2) != 0) {
		if ((ahc_inb(ahc, SBLKCTL) & ENAB40) != 0
		 && (ahc_inb(ahc, SSTAT2) & EXP_ACTIVE) == 0) {
			maxsync = AHC_SYNCRATE_ULTRA2;
		} else {
			maxsync = AHC_SYNCRATE_ULTRA;
d2155 34
a2188 2
	} else if ((ahc->features & AHC_ULTRA) != 0) {
		maxsync = AHC_SYNCRATE_ULTRA;
d2190 17
a2206 3
		maxsync = AHC_SYNCRATE_FAST;
	}
	return (ahc_find_syncrate(ahc, period, maxsync));
d2210 2
a2211 3
 * Look up the valid period to SCSIRATE conversion in our table.
 * Return the period and offset that should be sent to the target
 * if this was the beginning of an SDTR.
d2213 2
a2214 5
STATIC struct ahc_syncrate *
ahc_find_syncrate(ahc, period, maxsync)
	struct ahc_softc *ahc;
	u_int *period;
	u_int maxsync;
d2216 15
a2230 1
	struct ahc_syncrate *syncrate;
d2232 18
a2249 4
	syncrate = &ahc_syncrates[maxsync];
	while ((syncrate->rate != NULL)
	    && ((ahc->features & AHC_ULTRA2) == 0
	     || (syncrate->sxfr_u2 != 0))) {
d2251 4
a2254 17
		if (*period <= syncrate->period) {
			/*
			 * When responding to a target that requests
			 * sync, the requested rate may fall between
			 * two rates that we can output, but still be
			 * a rate that we can receive.  Because of this,
			 * we want to respond to the target with
			 * the same rate that it sent to us even
			 * if the period we use to send data to it
			 * is lower.  Only lower the response period
			 * if we must.
			 */
			if (syncrate == &ahc_syncrates[maxsync])
				*period = syncrate->period;
			break;
		}
		syncrate++;
d2257 3
a2259 7
	if ((*period == 0)
	 || (syncrate->rate == NULL)
	 || ((ahc->features & AHC_ULTRA2) != 0
	  && (syncrate->sxfr_u2 == 0))) {
		/* Use asynchronous transfers. */
		*period = 0;
		syncrate = NULL;
a2260 10
	return (syncrate);
}

STATIC u_int
ahc_find_period(ahc, scsirate, maxsync)
	struct ahc_softc *ahc;
	u_int scsirate;
	u_int maxsync;
{
	struct ahc_syncrate *syncrate;
d2262 4
a2265 4
	if ((ahc->features & AHC_ULTRA2) != 0)
		scsirate &= SXFR_ULTRA2;
	else
		scsirate &= SXFR;
d2267 9
a2275 2
	syncrate = &ahc_syncrates[maxsync];
	while (syncrate->rate != NULL) {
d2277 10
a2286 7
		if ((ahc->features & AHC_ULTRA2) != 0) {
			if (syncrate->sxfr_u2 == 0)
				break;
			else if (scsirate == (syncrate->sxfr_u2 & SXFR_ULTRA2))
				return (syncrate->period);
		} else if (scsirate == (syncrate->sxfr & SXFR)) {
				return (syncrate->period);
d2288 2
a2289 1
		syncrate++;
a2290 1
	return (0); /* async */
d2293 7
a2299 6
STATIC void
ahc_validate_offset(ahc, syncrate, offset, wide)
	struct ahc_softc *ahc;
	struct ahc_syncrate *syncrate;
	u_int *offset;
	int wide;
d2301 12
a2312 1
	u_int maxoffset;
d2314 17
a2330 10
	/* Limit offset to what we can do */
	if (syncrate == NULL) {
		maxoffset = 0;
	} else if ((ahc->features & AHC_ULTRA2) != 0) {
		maxoffset = MAX_OFFSET_ULTRA2;
	} else {
		if (wide)
			maxoffset = MAX_OFFSET_16BIT;
		else
			maxoffset = MAX_OFFSET_8BIT;
a2331 1
	*offset = MIN(*offset, maxoffset);
d2334 8
a2341 7
STATIC void
ahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct ahc_initiator_tinfo *tinfo;
	int force;
	int paused;
d2343 14
a2356 36
	u_int targ_msg_req_orig;

	targ_msg_req_orig = ahc->targ_msg_req;
	if (tinfo->current.period != tinfo->goal.period
	    || tinfo->current.width != tinfo->goal.width
	    || tinfo->current.offset != tinfo->goal.offset
	    || (force && (tinfo->goal.period != 0
	    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))
		ahc->targ_msg_req |= devinfo->target_mask;
	else
		ahc->targ_msg_req &= ~devinfo->target_mask;

	if (ahc->targ_msg_req != targ_msg_req_orig) {
		/* Update the message request bit for this target */
		if ((ahc->features & AHC_HS_MAILBOX) != 0) {
			if (paused) {
				ahc_outb(ahc, TARGET_MSG_REQUEST,
					 ahc->targ_msg_req & 0xFF);
				ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
					 (ahc->targ_msg_req >> 8) & 0xFF);
			} else {
				ahc_outb(ahc, HS_MAILBOX,
					 0x01 << HOST_MAILBOX_SHIFT);
			}
		} else {
			if (!paused)
				pause_sequencer(ahc);

			ahc_outb(ahc, TARGET_MSG_REQUEST,
				 ahc->targ_msg_req & 0xFF);
			ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
				 (ahc->targ_msg_req >> 8) & 0xFF);

			if (!paused)
				unpause_sequencer(ahc);
		}
d2360 5
a2364 10
STATIC void
ahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct ahc_syncrate *syncrate;
	u_int period;
	u_int offset;
	u_int type;
	int paused;
	int done;
d2366 12
a2377 5
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	u_int	old_period;
	u_int	old_offset;
	int	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
d2379 9
a2387 4
	if (syncrate == NULL) {
		period = 0;
		offset = 0;
	}
d2389 3
a2391 5
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
	old_period = tinfo->current.period;
	old_offset = tinfo->current.offset;
d2393 7
a2399 3
	if ((type & AHC_TRANS_CUR) != 0
	 && (old_period != period || old_offset != offset)) {
		u_int	scsirate;
d2401 2
a2402 2
		scsirate = tinfo->scsirate;
		if ((ahc->features & AHC_ULTRA2) != 0) {
d2404 18
a2421 5
			/* XXX */
			/* Force single edge until DT is fully implemented */
			scsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);
			if (syncrate != NULL)
				scsirate |= syncrate->sxfr_u2|SINGLE_EDGE;
d2423 6
a2428 3
			if (active)
				ahc_outb(ahc, SCSIOFFSET, offset);
		} else {
d2430 2
a2431 1
			scsirate &= ~(SXFR|SOFS);
d2433 3
a2435 2
			 * Ensure Ultra mode is set properly for
			 * this target.
d2437 2
a2438 18
			tstate->ultraenb &= ~devinfo->target_mask;
			if (syncrate != NULL) {
				if (syncrate->sxfr & ULTRA_SXFR) {
					tstate->ultraenb |=
						devinfo->target_mask;
				}
				scsirate |= syncrate->sxfr & SXFR;
				scsirate |= offset & SOFS;
			}
			if (active) {
				u_int sxfrctl0;

				sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
				sxfrctl0 &= ~FAST20;
				if (tstate->ultraenb & devinfo->target_mask)
					sxfrctl0 |= FAST20;
				ahc_outb(ahc, SXFRCTL0, sxfrctl0);
			}
a2439 2
		if (active)
			ahc_outb(ahc, SCSIRATE, scsirate);
d2441 4
a2444 21
		tinfo->scsirate = scsirate;
		tinfo->current.period = period;
		tinfo->current.offset = offset;

		/* Update the syncrates in any pending scbs */
		ahc_update_pending_syncrates(ahc);
	}

	/*
	 * Print messages if we're verbose and at the end of a negotiation
	 * cycle.
	 */
	if (done) {
		if (offset != 0) {
			printf("%s: target %d synchronous at %sMHz, "
			       "offset = 0x%x\n", ahc_name(ahc),
			       devinfo->target, syncrate->rate, offset);
		} else {
			printf("%s: target %d using "
			       "asynchronous transfers\n",
			       ahc_name(ahc), devinfo->target);
a2445 1
	}
d2447 7
a2453 3
	if ((type & AHC_TRANS_GOAL) != 0) {
		tinfo->goal.period = period;
		tinfo->goal.offset = offset;
d2455 4
d2460 1
a2460 29
	if ((type & AHC_TRANS_USER) != 0) {
		tinfo->user.period = period;
		tinfo->user.offset = offset;
	}

	ahc_update_target_msg_request(ahc, devinfo, tinfo,
				      /*force*/FALSE,
				      paused);
}

STATIC void
ahc_set_width(ahc, devinfo, width, type, paused, done)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	u_int width;
	u_int type;
	int paused;
	int done;
{
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
	u_int  oldwidth;
	int    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target,
				    &tstate);
	oldwidth = tinfo->current.width;
d2462 12
a2473 2
	if ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {
		u_int	scsirate;
d2475 2
a2476 4
		scsirate =  tinfo->scsirate;
		scsirate &= ~WIDEXFER;
		if (width == MSG_EXT_WDTR_BUS_16_BIT)
			scsirate |= WIDEXFER;
d2478 1
a2478 1
		tinfo->scsirate = scsirate;
d2480 6
a2485 2
		if (active)
			ahc_outb(ahc, SCSIRATE, scsirate);
d2487 9
a2495 2
		tinfo->current.width = width;
	}
d2497 4
a2500 4
	if (done) {
		printf("%s: target %d using %dbit transfers\n",
		       ahc_name(ahc), devinfo->target,
		       8 * (0x01 << width));
d2502 4
d2507 2
a2508 4
	if ((type & AHC_TRANS_GOAL) != 0)
		tinfo->goal.width = width;
	if ((type & AHC_TRANS_USER) != 0)
		tinfo->user.width = width;
d2510 11
a2520 3
	ahc_update_target_msg_request(ahc, devinfo, tinfo,
				      /*force*/FALSE, paused);
}
d2522 1
a2522 8
STATIC void
ahc_set_tags(ahc, devinfo, enable)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	int enable;
{
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
d2524 15
a2538 11
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target,
				    &tstate);
	if (enable)
		tstate->tagenable |= devinfo->target_mask;
	else {
		tstate->tagenable &= ~devinfo->target_mask;
		tstate->tagdisable |= devinfo->target_mask;
	}
}
d2540 7
a2546 11
/*
 * Attach all the sub-devices we can find
 */
int
ahc_attach(ahc)
	struct ahc_softc *ahc;
{
	/*
	 * Initialize the software queue.
	 */
	LIST_INIT(&ahc->sc_xxxq);
d2548 6
a2553 22
#ifdef AHC_BROKEN_CACHE
	if (cpu_class == CPUCLASS_386)	/* doesn't have "wbinvd" instruction */
		ahc_broken_cache = 0;
#endif
	/*
	 * fill in the prototype scsi_links.
	 */
	ahc->sc_link.adapter_target = ahc->our_id;
	if (ahc->features & AHC_WIDE)
		ahc->sc_link.adapter_buswidth = 16;
	ahc->sc_link.adapter_softc = ahc;
	ahc->sc_link.adapter = &ahc_switch;
	ahc->sc_link.openings = 2;
	ahc->sc_link.device = &ahc_dev;
	ahc->sc_link.flags = SCSIDEBUG_LEVEL;
	
	if (ahc->features & AHC_TWIN) {
		/* Configure the second scsi bus */
		ahc->sc_link_b = ahc->sc_link;
		ahc->sc_link_b.adapter_target = ahc->our_id_b;
		if (ahc->features & AHC_WIDE)
			ahc->sc_link.adapter_buswidth = 16;
d2555 4
d2560 5
a2564 6
	/*
	 * ask the adapter what subunits are present
	 */
	if ((ahc->flags & AHC_CHANNEL_B_PRIMARY) == 0) {
		/* make IS_SCSIBUS_B() == false, while probing channel A */
		ahc->sc_link_b.scsibus = 0xff;
a2565 4
		config_found((void *)ahc, &ahc->sc_link, scsiprint);
		if (ahc->features & AHC_TWIN)
			config_found((void *)ahc, &ahc->sc_link_b, scsiprint);
	} else {
d2567 3
a2569 3
		 * if implementation of IS_SCSIBUS_B() is changed to use
		 * ahc->sc_link.scsibus, then "ahc->sc_link.scsibus = 0xff;"
		 * is needed, here.
d2571 14
d2586 6
a2591 6
		/* assert(ahc->features & AHC_TWIN); */
		config_found((void *)ahc, &ahc->sc_link_b, scsiprint);
		config_found((void *)ahc, &ahc->sc_link, scsiprint);
	}
	return 1;
}
d2593 13
a2605 8
STATIC void
ahc_fetch_devinfo(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	u_int	saved_tcl;
	role_t	role;
	int	our_id;
d2607 7
a2613 4
	if (ahc_inb(ahc, SSTAT0) & TARGET)
		role = ROLE_TARGET;
	else
		role = ROLE_INITIATOR;
d2615 5
a2619 9
	if (role == ROLE_TARGET
	 && (ahc->features & AHC_MULTI_TID) != 0
	 && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
		/* We were selected, so pull our id from TARGIDIN */
		our_id = ahc_inb(ahc, TARGIDIN) & OID;
	} else if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;
d2621 5
a2625 24
	saved_tcl = ahc_inb(ahc, SAVED_TCL);
	ahc_compile_devinfo(devinfo, our_id, TCL_TARGET(saved_tcl),
			    TCL_LUN(saved_tcl), TCL_CHANNEL(ahc, saved_tcl),
			    role);
}

STATIC void
ahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)
	struct ahc_devinfo *devinfo;
	u_int our_id;
	u_int target;
	u_int lun;
	char channel;
	role_t role;
{
	devinfo->our_scsiid = our_id;
	devinfo->target = target;
	devinfo->lun = lun;
	devinfo->target_offset = target;
	devinfo->channel = channel;
	devinfo->role = role;
	if (channel == 'B')
		devinfo->target_offset += 8;
	devinfo->target_mask = (0x01 << devinfo->target_offset);
d2629 4
a2632 1
 * Catch an interrupt from the adapter
d2634 2
a2635 2
int
ahc_intr(void *arg)
d2637 2
a2638 2
	struct	ahc_softc *ahc;
	u_int	intstat;
d2640 2
a2641 1
	ahc = (struct ahc_softc *)arg; 
d2643 3
a2645 1
	intstat = ahc_inb(ahc, INTSTAT);
d2647 3
a2649 22
	/*
	 * Any interrupts to process?
	 */
	if ((intstat & INT_PEND) == 0) {
		if (ahc->pci_intr_func && ahc->pci_intr_func(ahc)) {
#ifdef AHC_DEBUG
			printf("%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\n",
			    ahc_name(ahc),
			    ahc_inb(ahc, CCHADDR) |
			    (ahc_inb(ahc, CCHADDR+1) << 8)
			    | (ahc_inb(ahc, CCHADDR+2) << 16)
			    | (ahc_inb(ahc, CCHADDR+3) << 24),
			    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)
			    | (ahc_inb(ahc, HADDR+2) << 16)
			    | (ahc_inb(ahc, HADDR+3) << 24),
			    ahc_inb(ahc, SEQADDR0) |
			    (ahc_inb(ahc, SEQADDR1) << 8));
#endif
			return 1;
		}
		return 0;
	}
d2651 9
a2659 10
	if (intstat & CMDCMPLT) {
		ahc_outb(ahc, CLRINT, CLRCMDINT);
		ahc_run_qoutfifo(ahc);
	}
	if (intstat & BRKADRINT) {
		/*
		 * We upset the sequencer :-(
		 * Lookup the error message
		 */
		int i, error, num_errors;
d2661 10
a2670 44
		error = ahc_inb(ahc, ERROR);
		num_errors =  sizeof(hard_error)/sizeof(hard_error[0]);
		for (i = 0; error != 1 && i < num_errors; i++)
			error >>= 1;
		panic("%s: brkadrint, %s at seqaddr = 0x%x\n",
		      ahc_name(ahc), hard_error[i].errmesg,
		      ahc_inb(ahc, SEQADDR0) |
		      (ahc_inb(ahc, SEQADDR1) << 8));

		/* Tell everyone that this HBA is no longer availible */
		ahc_abort_scbs(ahc, ALL_TARGETS, ALL_CHANNELS,
			       ALL_LUNS, SCB_LIST_NULL, ROLE_UNKNOWN,
			       XS_DRIVER_STUFFUP);
	}
	if (intstat & SEQINT)
		ahc_handle_seqint(ahc, intstat);

	if (intstat & SCSIINT)
		ahc_handle_scsiint(ahc, intstat);
	return(1);
}

STATIC struct tmode_tstate *
ahc_alloc_tstate(ahc, scsi_id, channel)
	struct ahc_softc *ahc;
	u_int scsi_id;
	char channel;
{
	struct tmode_tstate *master_tstate;
	struct tmode_tstate *tstate;
	int i, s;

	master_tstate = ahc->enabled_targets[ahc->our_id];
	if (channel == 'B') {
		scsi_id += 8;
		master_tstate = ahc->enabled_targets[ahc->our_id_b + 8];
	}
	if (ahc->enabled_targets[scsi_id] != NULL
	 && ahc->enabled_targets[scsi_id] != master_tstate)
		panic("%s: ahc_alloc_tstate - Target already allocated",
		      ahc_name(ahc));
	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
	if (tstate == NULL)
		return (NULL);
d2672 4
a2675 21
	/*
	 * If we have allocated a master tstate, copy user settings from
	 * the master tstate (taken from SRAM or the EEPROM) for this
	 * channel, but reset our current and goal settings to async/narrow
	 * until an initiator talks to us.
	 */
	if (master_tstate != NULL) {
		bcopy(master_tstate, tstate, sizeof(*tstate));
		tstate->ultraenb = 0;
		for (i = 0; i < 16; i++) {
			bzero(&tstate->transinfo[i].current,
			      sizeof(tstate->transinfo[i].current));
			bzero(&tstate->transinfo[i].goal,
			      sizeof(tstate->transinfo[i].goal));
		}
	} else
		bzero(tstate, sizeof(*tstate));
	s = splbio();
	ahc->enabled_targets[scsi_id] = tstate;
	splx(s);
	return (tstate);
d2678 5
a2682 4
STATIC void
ahc_handle_seqint(ahc, intstat)
	struct ahc_softc *ahc;
	u_int intstat;
d2684 13
a2696 4
	struct scb *scb;
	struct ahc_devinfo devinfo;
	
	ahc_fetch_devinfo(ahc, &devinfo);
d2699 9
a2707 4
	 * Clear the upper byte that holds SEQINT status
	 * codes and clear the SEQINT bit. We will unpause
	 * the sequencer, if appropriate, after servicing
	 * the request.
d2709 6
a2714 20
	ahc_outb(ahc, CLRINT, CLRSEQINT);
	switch (intstat & SEQINT_MASK) {
	case NO_MATCH:
	{
		/* Ensure we don't leave the selection hardware on */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));

		printf("%s:%c:%d: no active SCB for reconnecting "
		       "target - issuing BUS DEVICE RESET\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target);
		printf("SAVED_TCL == 0x%x, ARG_1 == 0x%x, SEQ_FLAGS == 0x%x\n",
		       ahc_inb(ahc, SAVED_TCL), ahc_inb(ahc, ARG_1),
		       ahc_inb(ahc, SEQ_FLAGS));
		ahc->msgout_buf[0] = MSG_BUS_DEV_RESET;
		ahc->msgout_len = 1;
		ahc->msgout_index = 0;
		ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, LASTPHASE) | ATNO);
d2716 1
a2716 8
	}
	case UPDATE_TMSG_REQ:
		ahc_outb(ahc, TARGET_MSG_REQUEST, ahc->targ_msg_req & 0xFF);
		ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
			 (ahc->targ_msg_req >> 8) & 0xFF);
		ahc_outb(ahc, HS_MAILBOX, 0);
		break;
	case SEND_REJECT: 
d2718 16
a2733 16
		u_int rejbyte = ahc_inb(ahc, ACCUM);
		printf("%s:%c:%d: Warning - unknown message received from "
		       "target (0x%x).  Rejecting\n", 
		       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);
		break; 
	}
	case NO_IDENT: 
	{
		/*
		 * The reconnecting target either did not send an identify
		 * message, or did, but we didn't find and SCB to match and
		 * before it could respond to our ATN/abort, it hit a dataphase.
		 * The only safe thing to do is to blow it away with a bus
		 * reset.
		 */
		int found;
d2735 9
a2743 14
		printf("%s:%c:%d: Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x, SAVED_TCL == 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_TCL));
		found = ahc_reset_channel(ahc, devinfo.channel, 
					  /*initiate reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), devinfo.channel,
		       found);
		return;
	}
	case BAD_PHASE:
	{
		u_int lastphase;
d2745 23
a2767 31
		lastphase = ahc_inb(ahc, LASTPHASE);
		if (lastphase == P_BUSFREE) {
			printf("%s:%c:%d: Missed busfree.  Curphase = 0x%x\n",
			       ahc_name(ahc), devinfo.channel, devinfo.target,
			       ahc_inb(ahc, SCSISIGI));
			restart_sequencer(ahc);
			return;
		} else {
			printf("%s:%c:%d: unknown scsi bus phase %x.  "
			       "Attempting to continue\n",
			       ahc_name(ahc), devinfo.channel, devinfo.target,
			       ahc_inb(ahc, SCSISIGI));
		}
		break; 
	}
	case BAD_STATUS:
	{
		u_int  scb_index;
		struct hardware_scb *hscb;
		struct scsi_xfer *xs;
		/*
		 * The sequencer will notify us when a command
		 * has an error that would be of interest to
		 * the kernel.  This allows us to leave the sequencer
		 * running in the common case of command completes
		 * without error.  The sequencer will already have
		 * dma'd the SCB back up to us, so we can reference
		 * the in kernel copy directly.
		 */
		scb_index = ahc_inb(ahc, SCB_TAG);
		scb = &ahc->scb_data->scbarray[scb_index];
d2769 31
a2799 13
		/*
		 * Set the default return value to 0 (don't
		 * send sense).  The sense code will change
		 * this if needed.
		 */
		ahc_outb(ahc, RETURN_1, 0);
		if (!(scb_index < ahc->scb_data->numscbs
		   && (scb->flags & SCB_ACTIVE) != 0)) {
			printf("%s:%c:%d: ahc_intr - referenced scb "
			       "not valid during seqint 0x%x scb(%d)\n",
			       ahc_name(ahc), devinfo.channel,
			       devinfo.target, intstat, scb_index);
			goto unpause;
d2801 5
d2807 5
a2811 2
		hscb = scb->hscb; 
		xs = scb->xs;
a2812 2
		/* Don't want to clobber the original sense code */
		if ((scb->flags & SCB_SENSE) != 0) {
d2814 5
a2818 3
			 * Clear the SCB_SENSE Flag and have
			 * the sequencer do a normal command
			 * complete.
d2820 68
a2887 2
			scb->flags &= ~SCB_SENSE;
			ahcsetccbstatus(xs, XS_DRIVER_STUFFUP);
d2890 14
a2903 15
		/* Freeze the queue unit the client sees the error. */
		ahc_freeze_devq(ahc, xs->sc_link);
		ahc_freeze_ccb(scb);
		xs->status = hscb->status;
		switch (hscb->status) {
		case SCSI_OK:
			printf("%s: Interrupted for staus of 0???\n",
			       ahc_name(ahc));
			break;
		case SCSI_CHECK:
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d: requests Check Status\n",
				       scb->hscb->tag);
a2904 8
#endif
				
			if (xs->error == XS_NOERROR &&
			    !(scb->flags & SCB_SENSE)) {
				struct ahc_dma_seg *sg;
				struct scsi_sense *sc;
				struct ahc_initiator_tinfo *tinfo;
				struct tmode_tstate *tstate;
d2906 9
a2914 9
				sg = scb->sg_list;
				sc = (struct scsi_sense *)(&hscb->cmdstore); 
				/*
				 * Save off the residual if there is one.
				 */
				if (hscb->residual_SG_count != 0)
					ahc_calc_residual(scb);
				else
					xs->resid = 0;
d2916 15
a2930 10
#ifdef AHC_DEBUG
				if (ahc_debug & AHC_SHOWSENSE) {
					sc_print_addr(scb->xs->sc_link);
					printf("Sending Sense\n");
				}
#endif
				sg->addr = ahc->scb_data->sense_busaddr +
					(hscb->tag*sizeof(struct scsi_sense_data));
				
				sg->len = sizeof(struct scsi_sense_data);
d2932 17
a2948 6
				sc->opcode = REQUEST_SENSE;
				sc->byte2 =  SCB_LUN(scb) << 5;
				sc->unused[0] = 0;
				sc->unused[1] = 0;
				sc->length = sg->len;
				sc->control = 0;
d2950 1
d2952 3
a2954 2
				 * Would be nice to preserve DISCENB here,
				 * but due to the way we page SCBs, we can't.
d2956 9
a2964 18
				hscb->control = 0;

				/*
				 * This request sense could be because the
				 * the device lost power or in some other
				 * way has lost our transfer negotiations.
				 * Renegotiate if appropriate.
				 */
				ahc_calc_residual(scb);
#ifdef AHC_DEBUG
				if (ahc_debug & AHC_SHOWSENSE) {
					sc_print_addr(xs->sc_link);
					printf("Sense: datalen %d resid %d"
					       "chan %d id %d targ %d\n",
					       xs->datalen, xs->resid,
					       devinfo.channel,
					       devinfo.our_scsiid,
					       devinfo.target);
d2966 28
a2993 38
#endif
				if (xs->datalen > 0 &&
				    xs->resid == xs->datalen) {
				tinfo = ahc_fetch_transinfo(ahc,
							    devinfo.channel,
							    devinfo.our_scsiid,
							    devinfo.target,
							    &tstate);
					ahc_update_target_msg_request(ahc,
							      &devinfo,
							      tinfo,
							      /*force*/TRUE,
							      /*paused*/TRUE);
				}
				hscb->status = 0;
				hscb->SG_count = 1;
				hscb->SG_pointer = scb->sg_list_phys;
				hscb->data = sg->addr; 
				hscb->datalen = sg->len;
				hscb->cmdpointer = hscb->cmdstore_busaddr;
				hscb->cmdlen = sizeof(*sc);
				scb->sg_count = hscb->SG_count;
				ahc_swap_hscb(hscb);
				ahc_swap_sg(scb->sg_list);
				scb->flags |= SCB_SENSE;
				/*
				 * Ensure the target is busy since this
				 * will be an untagged request.
				 */
				ahc_busy_tcl(ahc, scb);
				ahc_outb(ahc, RETURN_1, SEND_SENSE);

				/*
				 * Ensure we have enough time to actually
				 * retrieve the sense.
				 */
				if (!(scb->xs->flags & SCSI_POLL))
					timeout_add(&scb->xs->stimeout, 5 * hz);
d2995 9
d3005 4
a3008 7
		case SCSI_BUSY:
			/*
			 * Requeue any transactions that haven't been
			 * sent yet.
			 */
			ahc_freeze_devq(ahc, xs->sc_link);
			ahc_freeze_ccb(scb);
d3013 7
a3019 9
	case TRACE_POINT:
	{
		printf("SSTAT2 = 0x%x DFCNTRL = 0x%x\n", ahc_inb(ahc, SSTAT2),
		       ahc_inb(ahc, DFCNTRL));
		printf("SSTAT3 = 0x%x DSTATUS = 0x%x\n", ahc_inb(ahc, SSTAT3),
		       ahc_inb(ahc, DFSTATUS));
		printf("SSTAT0 = 0x%x, SCB_DATACNT = 0x%x\n",
		       ahc_inb(ahc, SSTAT0),
		       ahc_inb(ahc, SCB_DATACNT));
d3021 15
a3035 15
	}
	case HOST_MSG_LOOP:
	{
		/*
		 * The sequencer has encountered a message phase
		 * that requires host assistance for completion.
		 * While handling the message phase(s), we will be
		 * notified by the sequencer after each byte is
		 * transfered so we can track bus phases.
		 *
		 * If this is the first time we've seen a HOST_MSG_LOOP,
		 * initialize the state of the host message loop.
		 */
		if (ahc->msg_type == MSG_TYPE_NONE) {
			u_int bus_phase;
d3037 3
a3039 13
			bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			if (bus_phase != P_MESGIN
			 && bus_phase != P_MESGOUT) {
				printf("ahc_intr: HOST_MSG_LOOP bad "
				       "phase 0x%x\n",
				      bus_phase);
				/*
				 * Probably transitioned to bus free before
				 * we got here.  Just punt the message.
				 */
				ahc_clear_intstat(ahc);
				restart_sequencer(ahc);
			}
d3041 7
a3047 24
			if (devinfo.role == ROLE_INITIATOR) {
				struct scb *scb;
				u_int scb_index;

				scb_index = ahc_inb(ahc, SCB_TAG);
				scb = &ahc->scb_data->scbarray[scb_index];

				if (bus_phase == P_MESGOUT)
					ahc_setup_initiator_msgout(ahc,
								   &devinfo,
								   scb);
				else {
					ahc->msg_type =
					    MSG_TYPE_INITIATOR_MSGIN;
					ahc->msgin_index = 0;
				}
			} else {
				if (bus_phase == P_MESGOUT) {
					ahc->msg_type =
					    MSG_TYPE_TARGET_MSGOUT;
					ahc->msgin_index = 0;
				} else 
					/* XXX Ever executed??? */
					ahc_setup_target_msgin(ahc, &devinfo);
d3050 6
a3055 3

		/* Pass a NULL path so that handlers generate their own */
		ahc_handle_message_phase(ahc, /*path*/NULL);
d3058 2
a3059 2
	case PERR_DETECTED:
	{
d3061 1
a3061 9
		 * If we've cleared the parity error interrupt
		 * but the sequencer still believes that SCSIPERR
		 * is true, it must be that the parity error is
		 * for the currently presented byte on the bus,
		 * and we are not in a phase (data-in) where we will
		 * eventually ack this byte.  Ack the byte and
		 * throw it away in the hope that the target will
		 * take us to message out to deliver the appropriate
		 * error message.
d3063 40
a3102 3
		if ((intstat & SCSIINT) == 0
		 && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {
			u_int curphase;
d3104 1
a3104 15
			/*
			 * The hardware will only let you ack bytes
			 * if the expected phase in SCSISIGO matches
			 * the current phase.  Make sure this is
			 * currently the case.
			 */
			curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			ahc_outb(ahc, LASTPHASE, curphase);
			ahc_outb(ahc, SCSISIGO, curphase);
			ahc_inb(ahc, SCSIDATL);
		}
		break;
	}
	case DATA_OVERRUN:
	{
d3106 2
a3107 6
		 * When the sequencer detects an overrun, it
		 * places the controller in "BITBUCKET" mode
		 * and allows the target to complete its transfer.
		 * Unfortunately, none of the counters get updated
		 * when the controller is in this mode, so we have
		 * no way of knowing how large the overrun was.
d3109 15
a3123 3
		u_int scbindex = ahc_inb(ahc, SCB_TAG);
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		int i;
d3125 7
a3131 22
		scb = &ahc->scb_data->scbarray[scbindex];
		for (i = 0; i < num_phases; i++) {
			if (lastphase == phase_table[i].phase)
				break;
		}
		sc_print_addr(scb->xs->sc_link);
		printf("data overrun detected %s."
		       "  Tag == 0x%x.\n",
		       phase_table[i].phasemsg,
  		       scb->hscb->tag);
		sc_print_addr(scb->xs->sc_link);
		printf("%s seen Data Phase.  Length = %d.  NumSGs = %d.\n",
		       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
		       scb->xs->datalen, scb->sg_count);
		if (scb->sg_count > 0) {
			for (i = 0; i < scb->sg_count; i++) {
				printf("sg[%d] - Addr 0x%x : Length %d\n",
				       i,
				       (unsigned int)le32toh(scb->sg_list[i].addr),
				       (unsigned int)le32toh(scb->sg_list[i].len));
			}
		}
d3133 5
a3137 2
		 * Set this and it will take affect when the
		 * target does a command complete.
d3139 1
a3139 52
		ahc_freeze_devq(ahc, scb->xs->sc_link);
		ahcsetccbstatus(scb->xs, XS_DRIVER_STUFFUP);
		ahc_freeze_ccb(scb);
		break;
	}
	case TRACEPOINT:
	{
		printf("TRACEPOINT: RETURN_2 = %d\n", ahc_inb(ahc, RETURN_2));
#if 0
		printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1));
		printf("SSTAT0 == 0x%x\n", ahc_inb(ahc, SSTAT0));
		printf(", SCSISIGI == 0x%x\n", ahc_inb(ahc, SCSISIGI));
		printf("TRACEPOINT: CCHCNT = %d, SG_COUNT = %d\n",
		       ahc_inb(ahc, CCHCNT), ahc_inb(ahc, SG_COUNT));
		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG));
		printf("TRACEPOINT1: CCHADDR = %d, CCHCNT = %d, SCBPTR = %d\n",
		       ahc_inb(ahc, CCHADDR)
		    | (ahc_inb(ahc, CCHADDR+1) << 8)
		    | (ahc_inb(ahc, CCHADDR+2) << 16)
		    | (ahc_inb(ahc, CCHADDR+3) << 24),
		       ahc_inb(ahc, CCHCNT)
		    | (ahc_inb(ahc, CCHCNT+1) << 8)
		    | (ahc_inb(ahc, CCHCNT+2) << 16),
		       ahc_inb(ahc, SCBPTR));
		printf("TRACEPOINT: WAITING_SCBH = %d\n", 
		       ahc_inb(ahc, WAITING_SCBH));
		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG));
#endif
		break;
	}
#if NOT_YET
	/* XXX Fill these in later */
	case MESG_BUFFER_BUSY:
		break;
	case MSGIN_PHASEMIS:
		break;
#endif
	default:
		printf("ahc_intr: seqint, "
		       "intstat == 0x%x, scsisigi = 0x%x\n",
		       intstat, ahc_inb(ahc, SCSISIGI));
		break;
	}
	
unpause:
	/*
	 *  The sequencer is paused immediately on
	 *  a SEQINT, so we should restart it when
	 *  we're done.
	 */
	unpause_sequencer(ahc);
}
d3141 6
a3146 26
STATIC void
ahc_handle_scsiint(ahc, intstat)
	struct ahc_softc *ahc;
	u_int intstat;
{
	u_int	scb_index;
	u_int	status;
	struct	scb *scb;
	char	cur_channel;
	char	intr_channel;

	if ((ahc->features & AHC_TWIN) != 0
	 && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
		cur_channel = 'B';
	else
		cur_channel = 'A';
	intr_channel = cur_channel;

	status = ahc_inb(ahc, SSTAT1);
	if (status == 0) {
		if ((ahc->features & AHC_TWIN) != 0) {
			/* Try the other channel */
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			status = ahc_inb(ahc, SSTAT1);
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			intr_channel = (cur_channel == 'A') ? 'B' : 'A';
d3148 30
a3177 3
		if (status == 0) {
			printf("%s: Spurious SCSI interrupt\n", ahc_name(ahc));
			return;
a3178 1
	}
d3180 11
a3190 8
	scb_index = ahc_inb(ahc, SCB_TAG);
	if (scb_index < ahc->scb_data->numscbs) {
		scb = &ahc->scb_data->scbarray[scb_index];
		if ((scb->flags & SCB_ACTIVE) == 0
		 || (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)
			scb = NULL;
	} else
		scb = NULL;
a3191 5
	if ((status & SCSIRSTI) != 0) {
		printf("%s: Someone reset channel %c\n",
			ahc_name(ahc), intr_channel);
		ahc_reset_channel(ahc, intr_channel, /* Initiate Reset */FALSE);
	} else if ((status & SCSIPERR) != 0) {
d3193 2
a3194 8
		 * Determine the bus phase and queue an appropriate message.
		 * SCSIPERR is latched true as soon as a parity error
		 * occurs.  If the sequencer acked the transfer that
		 * caused the parity error and the currently presented
		 * transfer on the bus has correct parity, SCSIPERR will
		 * be cleared by CLRSCSIPERR.  Use this to determine if
		 * we should look at the last phase the sequencer recorded,
		 * or the current phase presented on the bus.
d3196 10
a3205 5
		u_int mesg_out;
		u_int curphase;
		u_int errorphase;
		u_int lastphase;
		int   i;
a3206 3
		lastphase = ahc_inb(ahc, LASTPHASE);
		curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
		ahc_outb(ahc, CLRSINT1, CLRSCSIPERR);
d3208 12
a3219 9
		 * For all phases save DATA, the sequencer won't
		 * automatically ack a byte that has a parity error
		 * in it.  So the only way that the current phase
		 * could be 'data-in' is if the parity error is for
		 * an already acked byte in the data phase.  During
		 * synchronous data-in transfers, we may actually
		 * ack bytes before latching the current phase in
		 * LASTPHASE, leading to the discrepancy between
		 * curphase and lastphase.
d3221 6
a3226 5
		if ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0
		 || curphase == P_DATAIN)
			errorphase = curphase;
		else
			errorphase = lastphase;
d3228 8
a3235 17
		for (i = 0; i < num_phases; i++) {
			if (errorphase == phase_table[i].phase)
				break;
		}
		mesg_out = phase_table[i].mesg_out;
		if (scb != NULL)
			sc_print_addr(scb->xs->sc_link);
		else
			printf("%s:%c:%d: ", ahc_name(ahc),
			       intr_channel,
			       TCL_TARGET(ahc_inb(ahc, SAVED_TCL)));
		
		printf("parity error detected %s. "
		       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
		       phase_table[i].phasemsg,
		       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),
		       ahc_inb(ahc, SCSIRATE));
d3237 8
d3246 2
a3247 5
		 * We've set the hardware to assert ATN if we   
		 * get a parity error on "in" phases, so all we  
		 * need to do is stuff the message buffer with
		 * the appropriate message.  "In" phases have set
		 * mesg_out to something other than MSG_NOP.
d3249 1
a3249 10
		if (mesg_out != MSG_NOOP) {
			if (ahc->msg_type != MSG_TYPE_NONE)
				ahc->send_msg_perror = TRUE;
			else
				ahc_outb(ahc, MSG_OUT, mesg_out);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		unpause_sequencer(ahc);
	} else if ((status & BUSFREE) != 0
		&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {
d3251 5
a3255 4
		 * First look at what phase we were last in.
		 * If its message out, chances are pretty good
		 * that the busfree was in response to one of
		 * our abort requests.
d3257 26
a3282 6
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		u_int saved_tcl = ahc_inb(ahc, SAVED_TCL);
		u_int target = TCL_TARGET(saved_tcl);
		u_int initiator_role_id = TCL_SCSI_ID(ahc, saved_tcl);
		char channel = TCL_CHANNEL(ahc, saved_tcl);
		int printerror = 1;
d3284 4
a3287 5
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (lastphase == P_MESGOUT) {
			u_int message;
			u_int tag;
d3289 2
a3290 20
			message = ahc->msgout_buf[ahc->msgout_index - 1];
			tag = SCB_LIST_NULL;
			switch (message) {
			case MSG_ABORT_TAG:
				tag = scb->hscb->tag;
				/* FALLTRHOUGH */
			case MSG_ABORT:
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d - Abort %s Completed.\n",
				       scb->hscb->tag, tag == SCB_LIST_NULL ?
				       "" : "Tag");
				ahc_abort_scbs(ahc, target, channel,
					       TCL_LUN(saved_tcl), tag,
					       ROLE_INITIATOR,
					       XS_DRIVER_STUFFUP);
				printerror = 0;
				break;
			case MSG_BUS_DEV_RESET:
			{
				struct ahc_devinfo devinfo;
d3292 9
a3300 27
				if (scb != NULL &&
				    (scb->xs->flags & SCSI_RESET)
				 && ahc_match_scb(scb, target, channel,
						  TCL_LUN(saved_tcl),
						  SCB_LIST_NULL,
						  ROLE_INITIATOR)) {
					ahcsetccbstatus(scb->xs, XS_NOERROR);
				}
				ahc_compile_devinfo(&devinfo,
						    initiator_role_id,
						    target,
						    TCL_LUN(saved_tcl),
						    channel,
						    ROLE_INITIATOR);
				ahc_handle_devreset(ahc, &devinfo,
						    XS_RESET,
						    "Bus Device Reset",
						    /*verbose_level*/0);
				printerror = 0;
				break;
			}
			default:
				break;
			}
		}
		if (printerror != 0) {
			int i;
d3302 9
a3310 2
			if (scb != NULL) {
				u_int tag;
a3311 10
				if ((scb->hscb->control & TAG_ENB) != 0)
					tag = scb->hscb->tag;
				else
					tag = SCB_LIST_NULL;
				ahc_abort_scbs(ahc, target, channel,
					       SCB_LUN(scb), tag,
					       ROLE_INITIATOR,
					       XS_DRIVER_STUFFUP);
				sc_print_addr(scb->xs->sc_link);
			} else {
d3313 2
a3314 2
				 * We had not fully identified this connection,
				 * so we cannot abort anything.
d3316 9
a3324 5
				printf("%s: ", ahc_name(ahc));
			}
			for (i = 0; i < num_phases; i++) {
				if (lastphase == phase_table[i].phase)
					break;
a3325 34
			printf("Unexpected busfree %s\n"
			       "SEQADDR == 0x%x\n",
			       phase_table[i].phasemsg, ahc_inb(ahc, SEQADDR0)
				| (ahc_inb(ahc, SEQADDR1) << 8));
		}
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		restart_sequencer(ahc);
	} else if ((status & SELTO) != 0) {
		u_int scbptr;

		scbptr = ahc_inb(ahc, WAITING_SCBH);
		ahc_outb(ahc, SCBPTR, scbptr);
		scb_index = ahc_inb(ahc, SCB_TAG);

		if (scb_index < ahc->scb_data->numscbs) {
			scb = &ahc->scb_data->scbarray[scb_index];
			if ((scb->flags & SCB_ACTIVE) == 0)
				scb = NULL;
		} else
			scb = NULL;

		if (scb == NULL) {
			printf("%s: ahc_intr - referenced scb not "
			       "valid during SELTO scb(%d, %d)\n",
			       ahc_name(ahc), scbptr, scb_index);
		} else {
			u_int tag;

			tag = SCB_LIST_NULL;
			if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0)
				tag = scb->hscb->tag;
d3327 4
a3330 3
			ahc_abort_scbs(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				       SCB_LUN(scb), tag,
				       ROLE_INITIATOR, XS_SELTIMEOUT);
d3332 2
a3333 2
		/* Stop the selection */
		ahc_outb(ahc, SCSISEQ, 0);
a3334 2
		/* No more pending messages */
		ahc_clear_msg_state(ahc);
d3336 13
a3348 9
		/*
		 * Although the driver does not care about the
		 * 'Selection in Progress' status bit, the busy
		 * LED does.  SELINGO is only cleared by a sucessful
		 * selection, so we must manually clear it to ensure
		 * the LED turns off just incase no future successful
		 * selections occur (e.g. no devices on the bus).
		 */
		ahc_outb(ahc, CLRSINT0, CLRSELINGO);
d3350 40
a3389 10
		/* Clear interrupt state */
		ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		restart_sequencer(ahc);
	} else {
		sc_print_addr(scb->xs->sc_link);
		printf("Unknown SCSIINT. Status = 0x%x\n", status);
		ahc_outb(ahc, CLRSINT1, status);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		unpause_sequencer(ahc);
d3393 6
a3398 4
STATIC void
ahc_build_transfer_msg(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
d3400 5
a3404 39
	/*
	 * We need to initiate transfer negotiations.
	 * If our current and goal settings are identical,
	 * we want to renegotiate due to a check condition.
	 */
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	int	dowide;
	int	dosync;

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
	dowide = tinfo->current.width != tinfo->goal.width;
	dosync = tinfo->current.period != tinfo->goal.period;

	if (!dowide && !dosync) {
		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
		dosync = tinfo->goal.period != 0;
	}

	if (dowide) {
		ahc_construct_wdtr(ahc, tinfo->goal.width);
	} else if (dosync) {
		struct	ahc_syncrate *rate;
		u_int	period;
		u_int	offset;

		period = tinfo->goal.period;
		rate = ahc_devlimited_syncrate(ahc, &period);
		offset = tinfo->goal.offset;
		ahc_validate_offset(ahc, rate, &offset,
				    tinfo->current.width);
		ahc_construct_sdtr(ahc, period, offset);
	} else {
		panic("ahc_intr: AWAITING_MSG for negotiation, "
		      "but no negotiation needed\n");	
	}
}
d3406 3
a3408 13
STATIC void
ahc_setup_initiator_msgout(ahc, devinfo, scb)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct scb *scb;
{
	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;
d3410 9
a3418 3
	if ((scb->flags & SCB_DEVICE_RESET) == 0
	 && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {
		u_int identify_msg;
d3420 3
a3422 5
		identify_msg = MSG_IDENTIFYFLAG | SCB_LUN(scb);
		if ((scb->hscb->control & DISCENB) != 0)
			identify_msg |= MSG_IDENTIFY_DISCFLAG;
		ahc->msgout_buf[ahc->msgout_index++] = identify_msg;
		ahc->msgout_len++;
d3424 3
a3426 5
		if ((scb->hscb->control & TAG_ENB) != 0) {
			/* XXX fvdl FreeBSD has tag action passed down */
			ahc->msgout_buf[ahc->msgout_index++] = MSG_SIMPLE_Q_TAG;
			ahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;
			ahc->msgout_len += 2;
d3429 1
a3429 24

	if (scb->flags & SCB_DEVICE_RESET) {
		ahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;
		ahc->msgout_len++;
		
		sc_print_addr(scb->xs->sc_link);
		printf("Bus Device Reset Message Sent\n");
	} else if (scb->flags & SCB_ABORT) {
		if ((scb->hscb->control & TAG_ENB) != 0)
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;
		else
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;
		ahc->msgout_len++;
		sc_print_addr(scb->xs->sc_link);
		printf("Abort Message Sent\n");
	} else if ((ahc->targ_msg_req & devinfo->target_mask) != 0) {
		ahc_build_transfer_msg(ahc, devinfo);
	} else {
		printf("ahc_intr: AWAITING_MSG for an SCB that "
		       "does not have a waiting message");
		panic("SCB = %d, SCB Control = %x, MSG_OUT = %x "
		      "SCB flags = %x", scb->hscb->tag, scb->hscb->control,
		      ahc_inb(ahc, MSG_OUT), scb->flags);
	}
d3432 1
a3432 2
	 * Clear the MK_MESSAGE flag from the SCB so we aren't
	 * asked to send this message again.
d3434 13
a3446 3
	ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);
	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
d3449 4
a3452 4
STATIC void
ahc_setup_target_msgin(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
d3454 1
d3463 1
a3463 1
	if ((ahc->targ_msg_req & devinfo->target_mask) != 0)
d3471 47
d3519 2
a3520 4
STATIC int
ahc_handle_msg_reject(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
a3521 10
	/*
	 * What we care about here is if we had an
	 * outstanding SDTR or WDTR message for this
	 * target.  If we did, this is a signal that
	 * the target is refusing negotiation.
	 */
	struct scb *scb;
	u_int scb_index;
	u_int last_msg;
	int   response = 0;
d3523 14
a3536 2
	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = &ahc->scb_data->scbarray[scb_index];
d3538 2
a3539 2
	/* Might be necessary */
	last_msg = ahc_inb(ahc, LAST_MSG);
d3541 4
a3544 3
	if (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/FALSE)) {
		struct ahc_initiator_tinfo *tinfo;
		struct tmode_tstate *tstate;
d3546 33
a3578 30
		/* note 8bit xfers */
		if (bootverbose)
			printf("%s:%c:%d: refuses WIDE negotiation.  Using "
			       "8bit transfers\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target);
		ahc_set_width(ahc, devinfo,
			      MSG_EXT_WDTR_BUS_8_BIT,
			      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
			      /*paused*/TRUE, /*done*/TRUE);
		/*
		 * No need to clear the sync rate.  If the target
		 * did not accept the command, our syncrate is
		 * unaffected.  If the target started the negotiation,
		 * but rejected our response, we already cleared the
		 * sync rate before sending our WDTR.
		 */
		tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
					    devinfo->our_scsiid,
					    devinfo->target, &tstate);
		if (tinfo->goal.period) {
			u_int period;

			/* Start the sync negotiation */
			period = tinfo->goal.period;
			ahc_devlimited_syncrate(ahc, &period);
			ahc->msgout_index = 0;
			ahc->msgout_len = 0;
			ahc_construct_sdtr(ahc, period, tinfo->goal.offset);
			ahc->msgout_index = 0;
			response = 1;
d3580 2
a3581 19
	} else if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/FALSE)) {
		/* note asynch xfers and clear flag */
		ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL, /*period*/0,
				 /*offset*/0,
				 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				 /*paused*/TRUE,
				 /*done*/TRUE);
		if (bootverbose)
			printf("%s:%c:%d: refuses synchronous negotiation. "
			       "Using asynchronous transfers\n",
			       ahc_name(ahc),
			       devinfo->channel, devinfo->target);
	} else if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0) {
		if (bootverbose)
			printf("%s:%c:%d: refuses tagged commands.  Performing "
			       "non-tagged I/O\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target);
			
		ahc_set_tags(ahc, devinfo, FALSE);
d3583 13
a3595 9
		/*
		 * Resend the identify for this CCB as the target
		 * may believe that the selection is invalid otherwise.
		 */
		ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL)
					  & ~MSG_SIMPLE_Q_TAG);
	 	scb->hscb->control &= ~MSG_SIMPLE_Q_TAG;
		ahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);
		ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);
d3597 4
a3600 18
		/*
		 * Requeue all tagged commands for this target
		 * currently in our posession so they can be
		 * converted to untagged commands.
		 */
		ahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				   SCB_LUN(scb), /*tag*/SCB_LIST_NULL,
				   ROLE_INITIATOR, SCB_REQUEUE,
				   SEARCH_COMPLETE);
	} else {
		/*
		 * Otherwise, we ignore it.
		 */
		printf("%s:%c:%d: Message reject for %x -- ignored\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       last_msg);
	}
	return (response);
d3603 2
a3604 3
STATIC void
ahc_clear_msg_state(ahc)
	struct ahc_softc *ahc;
d3606 3
a3608 4
	ahc->msgout_len = 0;
	ahc->msgin_index = 0;
	ahc->msg_type = MSG_TYPE_NONE;
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
d3611 33
a3643 8
STATIC void
ahc_handle_message_phase(ahc, sc_link)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
{ 
	struct	ahc_devinfo devinfo;
	u_int	bus_phase;
	int	end_session;
d3645 6
a3650 3
	ahc_fetch_devinfo(ahc, &devinfo);
	end_session = FALSE;
	bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
d3652 4
a3655 7
reswitch:
	switch (ahc->msg_type) {
	case MSG_TYPE_INITIATOR_MSGOUT:
	{
		int lastbyte;
		int phasemis;
		int msgdone;
d3657 2
a3658 2
		if (ahc->msgout_len == 0)
			panic("REQINIT interrupt with no active message");
d3660 5
a3664 14
		phasemis = bus_phase != P_MESGOUT;
		if (phasemis) {
			if (bus_phase == P_MESGIN) {
				/*
				 * Change gears and see if
				 * this messages is of interest to
				 * us or should be passed back to
				 * the sequencer.
				 */
				ahc_outb(ahc, CLRSINT1, CLRATNO);
				ahc->send_msg_perror = FALSE;
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;
				ahc->msgin_index = 0;
				goto reswitch;
d3666 2
a3667 2
			end_session = TRUE;
			break;
d3669 23
d3693 9
a3701 6
		if (ahc->send_msg_perror) {
			ahc_outb(ahc, CLRSINT1, CLRATNO);
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
			ahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);
			break;
		}
d3703 20
a3722 16
		msgdone	= ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			/*
			 * The target has requested a retry.
			 * Re-assert ATN, reset our message index to
			 * 0, and try again.
			 */
			ahc->msgout_index = 0;
			ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);
		}

		lastbyte = ahc->msgout_index == (ahc->msgout_len - 1);
		if (lastbyte) {
			/* Last byte is signified by dropping ATN */
			ahc_outb(ahc, CLRSINT1, CLRATNO);
		}
d3725 2
a3726 2
		 * Clear our interrupt status and present
		 * the next byte on the bus.
d3728 4
a3731 3
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
		break;
d3733 1
a3733 4
	case MSG_TYPE_INITIATOR_MSGIN:
	{
		int phasemis;
		int message_done;
d3735 1
a3735 1
		phasemis = bus_phase != P_MESGIN;
d3737 7
a3743 12
		if (phasemis) {
			ahc->msgin_index = 0;
			if (bus_phase == P_MESGOUT
			 && (ahc->send_msg_perror == TRUE
			  || (ahc->msgout_len != 0
			   && ahc->msgout_index == 0))) {
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
				goto reswitch;
			}
			end_session = TRUE;
			break;
		}
d3745 5
a3749 2
		/* Pull the byte in without acking it */
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);
d3751 21
a3771 1
		message_done = ahc_parse_msg(ahc, sc_link, &devinfo);
d3773 10
a3782 6
		if (message_done) {
			/*
			 * Clear our incoming message buffer in case there
			 * is another message following this one.
			 */
			ahc->msgin_index = 0;
d3784 6
a3789 10
			/*
			 * If this message illicited a response,
			 * assert ATN so the target takes us to the
			 * message out phase.
			 */
			if (ahc->msgout_len != 0)
				ahc_outb(ahc, SCSISIGO,
					 ahc_inb(ahc, SCSISIGO) | ATNO);
		} else 
			ahc->msgin_index++;
d3791 4
a3794 9
		/* Ack the byte */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_inb(ahc, SCSIDATL);
		break;
	}
	case MSG_TYPE_TARGET_MSGIN:
	{
		int msgdone;
		int msgout_request;
d3796 2
a3797 2
		if (ahc->msgout_len == 0)
			panic("Target MSGIN with no active message");
d3799 6
a3804 11
		/*
		 * If we interrupted a mesgout session, the initiator
		 * will not know this until our first REQ.  So, we
		 * only honor mesgout requests after we've sent our
		 * first byte.
		 */
		if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0
		 && ahc->msgout_index > 0)
			msgout_request = TRUE;
		else
			msgout_request = FALSE;
d3806 1
a3806 1
		if (msgout_request) {
d3808 3
a3810 13
			/*
			 * Change gears and see if
			 * this messages is of interest to
			 * us or should be passed back to
			 * the sequencer.
			 */
			ahc->msg_type = MSG_TYPE_TARGET_MSGOUT;
			ahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);
			ahc->msgin_index = 0;
			/* Dummy read to REQ for first byte */
			ahc_inb(ahc, SCSIDATL);
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
d3812 2
a3813 7
		}

		msgdone = ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
			end_session = TRUE;
d3815 3
a3817 1
		}
d3819 5
a3823 11
		/*
		 * Present the next byte on the bus.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
		break;
	}
	case MSG_TYPE_TARGET_MSGOUT:
	{
		int lastbyte;
		int msgdone;
d3825 4
a3828 5
		/*
		 * The initiator signals that this is
		 * the last byte by dropping ATN.
		 */
		lastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;
d3830 8
a3837 19
		/*
		 * Read the latched byte, but turn off SPIOEN first
		 * so that we don't inadvertantly cause a REQ for the
		 * next byte.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);
		msgdone = ahc_parse_msg(ahc, sc_link, &devinfo);
		if (msgdone == MSGLOOP_TERMINATED) {
			/*
			 * The message is *really* done in that it caused
			 * us to go to bus free.  The sequencer has already
			 * been reset at this point, so pull the ejection
			 * handle.
			 */
			return;
		}
		
		ahc->msgin_index++;
d3839 2
a3840 6
		/*
		 * XXX Read spec about initiator dropping ATN too soon
		 *     and use msgdone to detect it.
		 */
		if (msgdone == MSGLOOP_MSGCOMPLETE) {
			ahc->msgin_index = 0;
d3842 2
a3843 13
			/*
			 * If this message illicited a response, transition
			 * to the Message in phase and send it.
			 */
			if (ahc->msgout_len != 0) {
				ahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);
				ahc_outb(ahc, SXFRCTL0,
					 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
				ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
				ahc->msgin_index = 0;
				break;
			}
		}
d3845 5
a3849 7
		if (lastbyte)
			end_session = TRUE;
		else {
			/* Ask for the next byte. */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		}
d3851 2
a3852 4
		break;
	}
	default:
		panic("Unknown REQINIT message type");
d3855 7
a3861 5
	if (end_session) {
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);
	} else
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
d3864 3
a3866 11
/*
 * See if we sent a particular extended message to the target.
 * If "full" is true, the target saw the full message.
 * If "full" is false, the target saw at least the first
 * byte of the message.
 */
STATIC int
ahc_sent_msg(ahc, msgtype, full)
	struct ahc_softc *ahc;
	u_int msgtype;
	int full;
d3868 1
a3868 2
	int found;
	int index;
d3870 3
a3872 2
	found = FALSE;
	index = 0;
d3874 7
a3880 2
	while (index < ahc->msgout_len) {
		if (ahc->msgout_buf[index] == MSG_EXTENDED) {
d3882 1
a3882 3
			/* Found a candidate */
			if (ahc->msgout_buf[index+2] == msgtype) {
				u_int end_index;
d3884 7
a3890 11
				end_index = index + 1
					  + ahc->msgout_buf[index + 1];
				if (full) {
					if (ahc->msgout_index > end_index)
						found = TRUE;
				} else if (ahc->msgout_index > index)
					found = TRUE;
			}
			break;
		} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_Q_TAG
			&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
d3892 3
a3894 6
			/* Skip tag type and tag id or residue param*/
			index += 2;
		} else {
			/* Single byte message */
			index++;
		}
a3895 15
	return (found);
}

STATIC int
ahc_parse_msg(ahc, sc_link, devinfo)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
	struct ahc_devinfo *devinfo;
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	int	reject;
	int	done;
	int	response;
	u_int	targ_scsirate;
d3897 1
a3897 6
	done = MSGLOOP_IN_PROG;
	response = FALSE;
	reject = FALSE;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	targ_scsirate = tinfo->scsirate;
d3900 3
a3902 5
	 * Parse as much of the message as is availible,
	 * rejecting it if we don't support it.  When
	 * the entire message is availible and has been
	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
	 * that we have parsed an entire message.
d3904 3
a3906 3
	 * In the case of extended messages, we accept the length
	 * byte outright and perform more checking once we know the
	 * extended message type.
d3908 12
a3919 19
	switch (ahc->msgin_buf[0]) {
	case MSG_MESSAGE_REJECT:
		response = ahc_handle_msg_reject(ahc, devinfo);
		/* FALLTHROUGH */
	case MSG_NOOP:
		done = MSGLOOP_MSGCOMPLETE;
		break;
	case MSG_IGN_WIDE_RESIDUE:
	{
		/* Wait for the whole message */
		if (ahc->msgin_index >= 1) {
			if (ahc->msgin_buf[1] != 1
			 || tinfo->current.width == MSG_EXT_WDTR_BUS_8_BIT) {
				reject = TRUE;
				done = MSGLOOP_MSGCOMPLETE;
			} else
				ahc_handle_ign_wide_residue(ahc, devinfo);
		}
		break;
a3920 17
	case MSG_EXTENDED:
	{
		/* Wait for enough of the message to begin validation */
		if (ahc->msgin_index < 2)
			break;
		switch (ahc->msgin_buf[2]) {
		case MSG_EXT_SDTR:
		{
			struct	 ahc_syncrate *syncrate;
			u_int	 period;
			u_int	 offset;
			u_int	 saved_offset;
			
			if (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
				reject = TRUE;
				break;
			}
d3922 1
a3922 9
			/*
			 * Wait until we have both args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_SDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))
				break;
d3924 6
a3929 9
			period = ahc->msgin_buf[3];
			saved_offset = offset = ahc->msgin_buf[4];
			syncrate = ahc_devlimited_syncrate(ahc, &period);
			ahc_validate_offset(ahc, syncrate, &offset,
					    targ_scsirate & WIDEXFER);
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period, offset,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE, /*done*/TRUE);
d3931 1
a3931 30
			/*
			 * See if we initiated Sync Negotiation
			 * and didn't have to fall down to async
			 * transfers.
			 */
			if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/TRUE)) {
				/* We started it */
				if (saved_offset != offset) {
					/* Went too low - force async */
					reject = TRUE;
				}
			} else {
				/*
				 * Send our own SDTR in reply
				 */
				if (bootverbose)
					printf("Sending SDTR!\n");
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_sdtr(ahc, period, offset);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		case MSG_EXT_WDTR:
		{
			u_int	bus_width;
			u_int	sending_reply;
d3933 5
a3937 5
			sending_reply = FALSE;
			if (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
				reject = TRUE;
				break;
			}
d3939 1
a3939 9
			/*
			 * Wait until we have our arg before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_WDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))
				break;
d3941 11
a3951 90
			bus_width = ahc->msgin_buf[3];
			if (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/TRUE)) {
				/*
				 * Don't send a WDTR back to the
				 * target, since we asked first.
				 */
				switch (bus_width){
				default:
					/*
					 * How can we do anything greater
					 * than 16bit transfers on a 16bit
					 * bus?
					 */
					reject = TRUE;
					printf("%s: target %d requested %dBit "
					       "transfers.  Rejecting...\n",
					       ahc_name(ahc), devinfo->target,
					       8 * (0x01 << bus_width));
					/* FALLTHROUGH */
				case MSG_EXT_WDTR_BUS_8_BIT:
					bus_width = MSG_EXT_WDTR_BUS_8_BIT;
					break;
				case MSG_EXT_WDTR_BUS_16_BIT:
					break;
				}
			} else {
				/*
				 * Send our own WDTR in reply
				 */
				if (bootverbose)
					printf("Sending WDTR!\n");
				switch (bus_width) {
				default:
					if (ahc->features & AHC_WIDE) {
						/* Respond Wide */
						bus_width =
						    MSG_EXT_WDTR_BUS_16_BIT;
						break;
					}
					/* FALLTHROUGH */
				case MSG_EXT_WDTR_BUS_8_BIT:
					bus_width = MSG_EXT_WDTR_BUS_8_BIT;
					break;
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_wdtr(ahc, bus_width);
				ahc->msgout_index = 0;
				response = TRUE;
				sending_reply = TRUE;
			}
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE, /*done*/TRUE);

			/* After a wide message, we are async */
			ahc_set_syncrate(ahc, devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, AHC_TRANS_ACTIVE,
					 /*paused*/TRUE, /*done*/FALSE);
			if (sending_reply == FALSE && reject == FALSE) {

				if (tinfo->goal.period) {
					struct	ahc_syncrate *rate;
					u_int	period;
					u_int	offset;

					/* Start the sync negotiation */
					period = tinfo->goal.period;
					rate = ahc_devlimited_syncrate(ahc,
								       &period);
					offset = tinfo->goal.offset;
					ahc_validate_offset(ahc, rate, &offset,
							  tinfo->current.width);
					ahc->msgout_index = 0;
					ahc->msgout_len = 0;
					ahc_construct_sdtr(ahc, period, offset);
					ahc->msgout_index = 0;
					response = TRUE;
				}
			}
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		default:
			/* Unknown extended message.  Reject it. */
			reject = TRUE;
			break;
		}
		break;
a3952 21
	case MSG_BUS_DEV_RESET:
		ahc_handle_devreset(ahc, devinfo,
				    XS_RESET, "Bus Device Reset Received",
				    /*verbose_level*/0);
		restart_sequencer(ahc);
		done = MSGLOOP_TERMINATED;
		break;
	case MSG_ABORT_TAG:
	case MSG_ABORT:
	case MSG_CLEAR_QUEUE:
		/* Target mode messages */
		if (devinfo->role != ROLE_TARGET) {
			reject = TRUE;
			break;
		}
#if AHC_TARGET_MODE
		ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       devinfo->lun,
			       ahc->msgin_buf[0] == MSG_ABORT_TAG ? SCB_LIST_NULL
			       : ahc_inb(ahc, INITIATOR_TAG),
				ROLE_TARGET, XS_DRIVER_STUFFUP);
d3954 1
a3954 3
		tstate = ahc->enabled_targets[devinfo->our_scsiid];
		if (tstate != NULL) {
			struct tmode_lstate* lstate;
d3956 5
a3960 29
			lstate = tstate->enabled_luns[devinfo->lun];
			if (lstate != NULL) {
				ahc_queue_lstate_event(ahc, lstate,
						       devinfo->our_scsiid,
						       ahc->msgin_buf[0],
						       /*arg*/0);
				ahc_send_lstate_events(ahc, lstate);
			}
		}
		done = MSGLOOP_MSGCOMPLETE;
#else
		panic("ahc: got target mode message");
#endif
		break;
	case MSG_TERM_IO_PROC:
	default:
		reject = TRUE;
		break;
	}

	if (reject) {
		/*
		 * Setup to reject the message.
		 */
		ahc->msgout_index = 0;
		ahc->msgout_len = 1;
		ahc->msgout_buf[0] = MSG_MESSAGE_REJECT;
		done = MSGLOOP_MSGCOMPLETE;
		response = TRUE;
d3963 1
a3963 50
	if (done != MSGLOOP_IN_PROG && !response)
		/* Clear the outgoing message buffer */
		ahc->msgout_len = 0;

	return (done);
}

STATIC void
ahc_handle_ign_wide_residue(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	u_int scb_index;
	struct scb *scb;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = &ahc->scb_data->scbarray[scb_index];
	if ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0
	 || !(scb->xs->flags & SCSI_DATA_IN)) {
		/*
		 * Ignore the message if we haven't
		 * seen an appropriate data phase yet.
		 */
	} else {
		/*
		 * If the residual occurred on the last
		 * transfer and the transfer request was
		 * expected to end on an odd count, do
		 * nothing.  Otherwise, subtract a byte
		 * and update the residual count accordingly.
		 */
		u_int resid_sgcnt;

		resid_sgcnt = ahc_inb(ahc, SCB_RESID_SGCNT);
		if (resid_sgcnt == 0
		 && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {
			/*
			 * If the residual occurred on the last
			 * transfer and the transfer request was
			 * expected to end on an odd count, do
			 * nothing.
			 */
		} else {
			u_int data_cnt;
			u_int data_addr;
			u_int sg_index;

			data_cnt = (ahc_inb(ahc, SCB_RESID_DCNT + 2) << 16)
				 | (ahc_inb(ahc, SCB_RESID_DCNT + 1) << 8)
				 | (ahc_inb(ahc, SCB_RESID_DCNT));
d3965 5
a3969 4
			data_addr = (ahc_inb(ahc, SHADDR + 3) << 24)
				  | (ahc_inb(ahc, SHADDR + 2) << 16)
				  | (ahc_inb(ahc, SHADDR + 1) << 8)
				  | (ahc_inb(ahc, SHADDR));
d3971 1
a3971 2
			data_cnt += 1;
			data_addr -= 1;
d3973 11
a3983 1
			sg_index = scb->sg_count - resid_sgcnt;
d3985 1
a3985 22
			if (sg_index != 0
			 && (le32toh(scb->sg_list[sg_index].len) < data_cnt)) {
				u_int32_t sg_addr;

				sg_index--;
				data_cnt = 1;
				data_addr = le32toh(scb->sg_list[sg_index].addr)
					  + le32toh(scb->sg_list[sg_index].len)
					  - 1;
				
				/*
				 * The physical address base points to the
				 * second entry as it is always used for
				 * calculating the "next S/G pointer".
				 */
				sg_addr = scb->sg_list_phys
					+ (sg_index* sizeof(*scb->sg_list));
				ahc_outb(ahc, SG_NEXT + 3, sg_addr >> 24);
				ahc_outb(ahc, SG_NEXT + 2, sg_addr >> 16);
				ahc_outb(ahc, SG_NEXT + 1, sg_addr >> 8);
				ahc_outb(ahc, SG_NEXT, sg_addr);
			}
d3987 3
a3989 3
			ahc_outb(ahc, SCB_RESID_DCNT + 2, data_cnt >> 16);
			ahc_outb(ahc, SCB_RESID_DCNT + 1, data_cnt >> 8);
			ahc_outb(ahc, SCB_RESID_DCNT, data_cnt);
d3991 5
a3995 5
			ahc_outb(ahc, SHADDR + 3, data_addr >> 24);
			ahc_outb(ahc, SHADDR + 2, data_addr >> 16);
			ahc_outb(ahc, SHADDR + 1, data_addr >> 8);
			ahc_outb(ahc, SHADDR, data_addr);
		}
a3996 1
}
d3998 5
a4002 9
STATIC void
ahc_handle_devreset(ahc, devinfo, status, message, verbose_level)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	int status;
	char *message;
	int verbose_level;
{
	int found;
a4003 4
	found = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       ALL_LUNS, SCB_LIST_NULL, devinfo->role,
			       status);
	
d4005 1
a4005 3
	 * Go back to async/narrow transfers and renegotiate.
	 * ahc_set_width and ahc_set_syncrate can cope with NULL
	 * paths.
d4007 5
a4011 10
	ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
		      AHC_TRANS_CUR, /*paused*/TRUE, /*done*/FALSE);
	ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,
			 /*period*/0, /*offset*/0, AHC_TRANS_CUR,
			 /*paused*/TRUE, /*done*/FALSE);
	
	if (message != NULL
	 && (verbose_level <= bootverbose))
		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahc_name(ahc),
		       message, devinfo->channel, devinfo->target, found);
d4014 2
a4015 9
/*
 * We have an scb which has been processed by the
 * adaptor, now we look to see how the operation
 * went.
 */
STATIC void
ahc_done(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
d4017 1
a4017 4
	struct scsi_xfer *xs = scb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	int requeue = 0;
	int target;
d4019 3
a4021 3
	SC_DEBUG(xs->sc_link, SDEV_DB2, ("ahc_done\n"));
	
	LIST_REMOVE(scb, pend_links);
d4023 5
a4027 1
	timeout_del(&scb->xs->stimeout);
d4029 10
a4038 5
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWCMDS) {
		sc_print_addr(sc_link);
		printf("ahc_done opcode %d tag %x\n", xs->cmdstore.opcode,
		    scb->hscb->tag);
d4040 23
a4062 14
#endif
	
	target = sc_link->target;
	
	if (xs->datalen) {
		int op;
	
		if ((xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_POSTREAD;
		else
			op = BUS_DMASYNC_POSTWRITE;
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
		    0, scb->dmamap->dm_mapsize, op);
		bus_dmamap_unload(ahc->sc_dmat, scb->dmamap);
d4064 3
d4068 10
a4077 7
	/*
	 * Unbusy this target/channel/lun.
	 * XXX if we are holding two commands per lun, 
	 *     send the next command.
	 */
	if (!(scb->hscb->control & TAG_ENB))
		ahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);
d4079 4
a4082 5
	/*
	 * If the recovery SCB completes, we have to be
	 * out of our timeout.
	 */
	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
d4084 1
a4084 1
		struct	scb *scbp;
d4086 1
a4086 8
		/*
		 * We were able to complete the command successfully,
		 * so reinstate the timeouts for all other pending
		 * commands.
		 */
		scbp = ahc->pending_scbs.lh_first;
		while (scbp != NULL) {
			struct scsi_xfer *txs = scbp->xs;
d4088 2
a4089 5
			if (!(txs->flags & SCSI_POLL))
				timeout_add(&scbp->xs->stimeout,
				    (scbp->xs->timeout * hz)/1000);
			scbp = LIST_NEXT(scbp, pend_links);
		}
d4091 6
a4096 12
		/*
		 * Ensure that we didn't put a second instance of this
		 * SCB into the QINFIFO.
		 */
		ahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				   SCB_LUN(scb), scb->hscb->tag,
				   ROLE_INITIATOR, /*status*/0,
				   SEARCH_REMOVE);
		if (xs->error != XS_NOERROR)
			ahcsetccbstatus(xs, XS_TIMEOUT);
		sc_print_addr(xs->sc_link);
		printf("no longer in timeout, status = %x\n", xs->status);
d4099 8
a4106 26
	if (xs->error != XS_NOERROR) {
		/* Don't clobber any existing error state */
	} else if ((scb->flags & SCB_SENSE) != 0) {
		/*
		 * We performed autosense retrieval.
		 *
		 * bzero the sense data before having
		 * the drive fill it.  The SCSI spec mandates
		 * that any untransfered data should be
		 * assumed to be zero.  Complete the 'bounce'
		 * of sense information through buffers accessible
		 * via bus-space by copying it into the clients
		 * csio.
		 */
		bzero(&xs->sense, sizeof(struct scsi_sense));
		bcopy(&ahc->scb_data->sense[scb->hscb->tag],
		      &xs->sense, le32toh(scb->sg_list->len));
		xs->error = XS_SENSE;
	}
	if (scb->flags & SCB_FREEZE_QUEUE) {
		ahc->devqueue_blocked[target]--;
		scb->flags &= ~SCB_FREEZE_QUEUE;
	}
	
	requeue = scb->flags & SCB_REQUEUE;
	ahcfreescb(ahc, scb);
d4108 13
a4120 1
	if (requeue) {
d4122 2
a4123 2
		 * Re-insert at the front of the private queue to
		 * preserve order.
d4125 17
a4141 10
		int s;

		s = splbio();
		/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */
		ahc_list_insert_head(ahc, xs);
		splx(s);
	} else {
		xs->flags |= ITSDONE;
		ahc_check_tags(ahc, xs);
		scsi_done(xs);
a4142 11

	/*
	 * If there are entries in the software queue, try to
	 * run the first one.  We should be more or less guaranteed
	 * to succeed, since we just freed an SCB.
	 *
	 * NOTE: ahc_scsi_cmd() relies on our calling it with
	 * the first entry in the queue.
	 */
	if ((xs = ahc->sc_xxxq.lh_first) != NULL)
		(void) ahc_scsi_cmd(xs);
d4144 1
d4146 2
a4147 6
/*
 * Determine the number of SCBs available on the controller
 */
int
ahc_probe_scbs(ahc)
	struct ahc_softc *ahc;
d4149 12
a4160 1
	int i;
d4162 15
a4176 8
	for (i = 0; i < AHC_SCB_MAX; i++) {
		ahc_outb(ahc, SCBPTR, i);
		ahc_outb(ahc, SCB_CONTROL, i);
		if (ahc_inb(ahc, SCB_CONTROL) != i)
			break;
		ahc_outb(ahc, SCBPTR, 0);
		if (ahc_inb(ahc, SCB_CONTROL) != 0)
			break;
d4178 7
a4184 2
	
	return (i);
d4191 1
a4191 2
ahc_init(ahc)
	struct ahc_softc *ahc;
d4193 14
a4206 11
	int	  max_targ = 15;
	int	  i;
	int	  term;
	u_int	  scsi_conf;
	u_int	  scsiseq_template;
	u_int	  ultraenb;
	u_int	  discenable;
	u_int	  tagenable;
	size_t	  driver_data_size;
	u_int32_t physaddr;
	struct scb_data *scb_data = NULL;
d4226 1
a4226 10

	if (ahc->scb_data == NULL) {
		scb_data = malloc(sizeof (struct scb_data), M_DEVBUF, M_NOWAIT);
		if (scb_data == NULL) {
			printf("%s: cannot malloc scb_data!\n", ahc_name(ahc));
			return (ENOMEM);
		}
		bzero(scb_data, sizeof(struct scb_data));
		ahc->scb_data = scb_data;
	}
d4236 25
a4260 2
	ahc->flags |= AHC_INITIATORMODE;
	
d4264 9
a4272 9
	 * roles, we need to allocate space for the qinfifo, qoutfifo,
	 * and untagged_scb arrays each of which are composed of 256
	 * 1 byte elements.  When providing for the target mode role,
	 * we additionally must provide space for the incoming target
	 * command fifo.
	 */
	driver_data_size = 3 * 256 * sizeof(u_int8_t);

	if (ahc_createdmamem(ahc, driver_data_size, 
d4279 25
d4305 1
a4305 4
	/* Allocate SCB data now that sc_dmat is initialized */
	if (ahc->scb_data->maxhscbs == 0)
		if (ahcinitscbdata(ahc) != 0)
			return (ENOMEM);
d4307 19
a4326 4
	ahc->untagged_scbs = &ahc->qinfifo[256];
	/* There are no untagged SCBs active yet. */
	for (i = 0; i < 256; i++)
		ahc->untagged_scbs[i] = SCB_LIST_NULL;
d4328 6
a4333 3
	/* All of our queues are empty */
	for (i = 0; i < 256; i++)
		ahc->qoutfifo[i] = SCB_LIST_NULL;
a4334 3
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
		 0, driver_data_size, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	
d4341 1
a4341 1
		printf("%s: unable to allocate tmode_tstate.  "
d4343 1
a4343 1
		return (-1);
d4348 1
a4348 1
			printf("%s: unable to allocate tmode_tstate.  "
d4350 1
a4350 10
			return (-1);
		}
 		printf("Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, ",
		       ahc->our_id, ahc->our_id_b,
		       ahc->flags & AHC_CHANNEL_B_PRIMARY? 'B': 'A');
	} else {
		if ((ahc->features & AHC_WIDE) != 0) {
			printf("Wide ");
		} else {
			printf("Single ");
a4351 1
		printf("Channel %c, SCSI Id=%d, ", ahc->channel, ahc->our_id);
d4355 1
a4358 1
		printf("%d/%d SCBs\n", ahc->scb_data->maxhscbs, AHC_SCB_MAX);
a4360 1
		printf("%d SCBs\n", ahc->scb_data->maxhscbs);
d4368 1
a4368 1
		        sizeof(struct hardware_scb),
d4374 1
a4374 1
	/* Set the SCSI Id,SXFRCTL0,SXFRCTL1, and SIMODE1, for both channels*/
d4381 1
d4383 1
a4383 4
		if ((ahc->features & AHC_ULTRA2) != 0)
			ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id_b);
		else
			ahc_outb(ahc, SCSIID, ahc->our_id_b);
d4386 3
a4388 1
					|term|ENSTIMER|ACTNEGEN);
d4393 1
a4393 1
		 && (ahc->flags & AHC_INITIATORMODE) != 0)
d4399 1
d4407 1
a4407 1
				|term
d4409 2
d4415 1
a4415 1
	 && (ahc->flags & AHC_INITIATORMODE) != 0)
d4447 1
a4447 1
		struct tmode_tstate *tstate;
d4463 1
a4463 1
		bzero(tinfo, sizeof(*tinfo));
d4476 1
a4476 1
			u_int16_t mask;
d4497 3
d4509 4
d4514 6
d4527 48
a4574 10
			}
			if ((scsirate & WIDEXFER) != 0
			 && (ahc->features & AHC_WIDE) != 0)
				tinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;
		}
		tinfo->goal = tinfo->user; /* force negotiation */
		tstate->ultraenb = ultraenb;
		tstate->discenable = discenable;
		tstate->tagenable = 0; /* Wait until the XPT says its okay */
		tstate->tagdisable = 0;
d4576 1
a4576 3
	ahc->user_discenable = discenable;
	ahc->user_tagenable = tagenable;

d4587 4
a4590 11
	ahc_outb(ahc, SCBID_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 3, (physaddr >> 24) & 0xFF);

	/* Target mode incomding command fifo */
	physaddr += 3 * 256 * sizeof(u_int8_t);
	ahc_outb(ahc, TMODE_CMDADDR, physaddr & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 3, (physaddr >> 24) & 0xFF);
a4610 10
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC)
		printf("DISCENABLE == 0x%x\nULTRAENB == 0x%x\n",
		    discenable, ultraenb);
#endif

	/* Don't have any special messages to send to targets */
	ahc_outb(ahc, TARGET_MSG_REQUEST, 0);
	ahc_outb(ahc, TARGET_MSG_REQUEST + 1, 0);

a4621 1

d4633 1
a4633 1
	 * If we are a target, we'll enable select in operations once
d4637 1
a4637 1
	if ((ahc->flags & AHC_INITIATORMODE) != 0)
d4644 1
a4644 1
         */
d4651 17
a4667 2
	/* We have to wait until after any system dumps... */
	shutdownhook_establish(ahc_shutdown, ahc);
d4671 17
d4689 5
a4693 4
 * Routines to manage a scsi_xfer into the software queue.  
 * We overload xs->free_list to to ensure we don't run into a queue 
 * resource shortage, and keep a pointer to the last entry around 
 * to make insertion O(C).
d4695 2
a4696 5
STATIC INLINE void
ahc_list_insert_before(ahc, xs, next_xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	struct scsi_xfer *next_xs;
d4698 2
a4699 1
	LIST_INSERT_BEFORE(xs, next_xs, free_list); 
d4701 17
d4720 2
a4721 4
STATIC INLINE void
ahc_list_insert_head(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
d4723 62
a4784 5
	if (ahc->sc_xxxq.lh_first == NULL)
		ahc->sc_xxxqlast = xs;
	LIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);
	return;
}
d4786 3
a4788 9
STATIC INLINE void
ahc_list_insert_tail(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	if (ahc->sc_xxxq.lh_first == NULL){
		ahc->sc_xxxqlast = xs;
		LIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);
		return;
a4789 3
	LIST_INSERT_AFTER(ahc->sc_xxxqlast, xs, free_list);
	ahc->sc_xxxqlast = xs;
}
d4791 10
a4800 12
STATIC INLINE void
ahc_list_remove(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	struct scsi_xfer *lxs;
	if (xs == ahc->sc_xxxqlast) {
		lxs = ahc->sc_xxxq.lh_first;
		while (lxs != NULL) {
			if (LIST_NEXT(lxs, free_list) == ahc->sc_xxxqlast) {
                                ahc->sc_xxxqlast = lxs;
				break;
a4801 1
			lxs = LIST_NEXT(xs, free_list);
d4804 2
a4805 4
	
	LIST_REMOVE(xs, free_list);
	if (ahc->sc_xxxq.lh_first == NULL)
		ahc->sc_xxxqlast = NULL;
d4808 2
a4809 4
STATIC INLINE struct scsi_xfer *
ahc_list_next(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
d4811 76
a4886 1
	return(LIST_NEXT(xs, free_list));
d4889 1
d4891 2
a4892 1
 * Pick the first xs for a non-blocked target.
d4894 2
a4895 2
STATIC INLINE struct scsi_xfer *
ahc_first_xs(struct ahc_softc *ahc)
d4897 2
a4898 2
	int target;
	struct scsi_xfer *xs = ahc->sc_xxxq.lh_first;
d4900 10
a4909 10
	if (ahc->queue_blocked)
        	return NULL;

	while (xs != NULL) {
		target = xs->sc_link->target;
		if (ahc->devqueue_blocked[target] == 0 &&
		    ahc_index_busy_tcl(ahc, XS_TCL(ahc, xs), FALSE) ==
			SCB_LIST_NULL)
			break;
		xs = LIST_NEXT(xs, free_list);
d4912 1
a4912 1
	return xs;
d4915 2
a4916 3
STATIC int32_t
ahc_scsi_cmd(xs)
	struct scsi_xfer *xs;
d4918 1
a4918 12
	struct scsi_xfer *first_xs, *next_xs = NULL;
	struct ahc_softc *ahc;
	struct scb *scb;
	struct hardware_scb *hscb;	
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
	u_int target_id;
	u_int our_id;
	char channel;
	int s, tcl;
	u_int16_t mask;
	int dontqueue = 0, fromqueue = 0;
d4920 12
a4931 2
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("ahc_scsi_cmd\n"));
	ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
d4933 4
a4936 2
	/* must protect the queue */
	s = splbio();
d4938 12
a4949 7
	if (xs == ahc->sc_xxxq.lh_first) {
		/*
		 * Called from ahc_done. Calling with the first entry in
		 * the queue is really just a way of seeing where we're
		 * called from. Now, find the first eligible SCB to send,
		 * e.g. one which will be accepted immediately.
		 */
d4951 9
a4959 4
		if (ahc->queue_blocked) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}
d4961 8
a4968 5
		xs = ahc_first_xs(ahc);
		if (xs == NULL) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}
d4970 13
a4982 4
		next_xs = ahc_list_next(ahc, xs);
		ahc_list_remove(ahc, xs);
		fromqueue = 1;
		goto get_scb;
d4985 2
a4986 8
	/* determine safety of software queueing */
	dontqueue = xs->flags & SCSI_POLL;
	
	/*
	 * If no new requests are accepted, just insert into the
	 * private queue to wait for our turn.
	 */
	tcl = XS_TCL(ahc, xs);
d4988 6
a4993 13
	if (ahc->queue_blocked ||
	    ahc->devqueue_blocked[xs->sc_link->target] ||
	    (!ahc_istagged_device(ahc, xs, 0) &&
	     ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)) {
		if (dontqueue) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return TRY_AGAIN_LATER;
		}
		ahc_list_insert_tail(ahc, xs);
		splx(s);
		return SUCCESSFULLY_QUEUED;
	}
d4995 7
a5001 1
	first_xs = ahc_first_xs(ahc);
d5003 2
a5004 2
	/* determine safety of software queueing */
	dontqueue = xs->flags & SCSI_POLL;
d5006 4
a5009 14
	/*
	 * Handle situations where there's already entries in the
	 * queue.
	 */
	if (first_xs != NULL) {
		/*
		 * If we can't queue, we have to abort, since
		 * we have to preserve order.
		 */
		if (dontqueue) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
d5011 4
a5014 8
		/*
		 * Swap with the first queue entry.
		 */
		ahc_list_insert_tail(ahc, xs);
		xs = first_xs;
		next_xs = ahc_list_next(ahc, xs);
		ahc_list_remove(ahc, xs);
		fromqueue = 1;
d5016 9
d5026 1
d5028 15
a5042 1
get_scb:
d5044 5
a5048 2
	target_id = xs->sc_link->target;
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
d5050 8
a5057 4
	/*
	 * get an scb to use.
	 */
	if ((scb = ahcgetscb(ahc)) == NULL) {
d5059 16
a5074 5
		if (dontqueue) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
d5076 13
d5090 2
a5091 3
		 * If we were pulled off the queue, put ourselves
		 * back to where we came from, otherwise tack ourselves
		 * onto the end.
d5093 1
a5093 7
		if (fromqueue && next_xs != NULL)
			ahc_list_insert_before(ahc, xs, next_xs);
		else
			ahc_list_insert_tail(ahc, xs);

		splx(s);
		return (SUCCESSFULLY_QUEUED);
d5096 6
a5101 1
	tcl = XS_TCL(ahc, xs);
d5103 7
a5109 10
#ifdef DIAGNOSTIC
	if (!ahc_istagged_device(ahc, xs, 0) &&
	    ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)
		panic("ahc: queuing for busy target");
#endif
	
	scb->xs = xs;
	hscb = scb->hscb;
	hscb->tcl = tcl;
	timeout_set(&xs->stimeout, ahc_timeout, scb);
d5111 10
a5120 4
	if (ahc_istagged_device(ahc, xs, 0))
		scb->hscb->control |= MSG_SIMPLE_Q_TAG;
	else
		ahc_busy_tcl(ahc, scb);
d5122 22
a5143 9
	splx(s);
 
	channel = SIM_CHANNEL(ahc, xs->sc_link);
	if (ahc->inited_channels[channel - 'A'] == 0) {
		if ((channel == 'A' && (ahc->flags & AHC_RESET_BUS_A)) ||
		    (channel == 'B' && (ahc->flags & AHC_RESET_BUS_B))) {
			s = splbio();
			ahc_reset_channel(ahc, channel, TRUE);
			splx(s);
d5145 1
a5145 1
		ahc->inited_channels[channel - 'A'] = 1;
d5148 4
a5151 18
	/*
	 * Put all the arguments for the xfer in the scb
	 */

	mask = SCB_TARGET_MASK(scb);
	tinfo = ahc_fetch_transinfo(ahc, SIM_CHANNEL(ahc, xs->sc_link), our_id,
				    target_id, &tstate);
	if (ahc->inited_targets[target_id] == 0) {
		struct ahc_devinfo devinfo;

		s = splbio();
		ahc_compile_devinfo(&devinfo, our_id, target_id,
		    xs->sc_link->lun, SIM_CHANNEL(ahc, xs->sc_link),
		    ROLE_INITIATOR);
		ahc_update_target_msg_request(ahc, &devinfo, tinfo, TRUE,
		    FALSE);
		ahc->inited_targets[target_id] = 1;
		splx(s);
d5154 16
a5169 7
	hscb->scsirate = tinfo->scsirate;
	hscb->scsioffset = tinfo->current.offset;
	if ((tstate->ultraenb & mask) != 0)
		hscb->control |= ULTRAENB;
		
	if ((tstate->discenable & mask) != 0)
		hscb->control |= DISCENB;
d5171 24
a5194 5
	if (xs->flags & SCSI_RESET) {
		hscb->cmdpointer = NULL;
		scb->flags |= SCB_DEVICE_RESET;
		hscb->control |= MK_MESSAGE;
		return ahc_execute_scb(scb, NULL, 0);
d5197 6
a5202 2
	return ahc_setup_data(ahc, xs, scb);
}
d5204 2
a5205 10
STATIC int
ahc_execute_scb(arg, dm_segs, nsegments)
	void *arg;
	bus_dma_segment_t *dm_segs;
	int nsegments;
{
	struct	 scb *scb;
	struct scsi_xfer *xs;
	struct	 ahc_softc *ahc;
	int	 s;
d5207 26
a5232 3
	scb = (struct scb *)arg;
	xs = scb->xs;
	ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
d5234 24
a5257 20

	if (nsegments != 0) {
		struct ahc_dma_seg *sg;
		bus_dma_segment_t *end_seg;
		int op;

		end_seg = dm_segs + nsegments;

		/* Copy the first SG into the data pointer area */
		scb->hscb->data = dm_segs->ds_addr;
		scb->hscb->datalen = dm_segs->ds_len;

		/* Copy the segments into our SG list */
		sg = scb->sg_list;
		while (dm_segs < end_seg) {
			sg->addr = dm_segs->ds_addr;
			sg->len = dm_segs->ds_len;
			ahc_swap_sg(sg);
			sg++;
			dm_segs++;
a5258 13

		/* Note where to find the SG entries in bus space */
		scb->hscb->SG_pointer = scb->sg_list_phys;
		if ((scb->xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_PREREAD;
		else
			op = BUS_DMASYNC_PREWRITE;
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
		    0, scb->dmamap->dm_mapsize, op);
	} else {
		scb->hscb->SG_pointer = 0;
		scb->hscb->data = 0;
		scb->hscb->datalen = 0;
d5260 1
a5260 4
	
	scb->sg_count = scb->hscb->SG_count = nsegments;

	s = splbio();
d5263 1
a5263 2
	 * Last time we need to check if this SCB needs to
	 * be aborted.
d5265 2
a5266 9
	if (xs->flags & ITSDONE) {
		if (!ahc_istagged_device(ahc, xs, 0))
			ahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);
		if (nsegments != 0)
			bus_dmamap_unload(ahc->sc_dmat, scb->dmamap);
		ahcfreescb(ahc, scb);
		splx(s);
		return (COMPLETE);
	}
d5268 2
a5269 4
#ifdef DIAGNOSTIC
	if (scb->sg_count > 255)
		panic("ahc bad sg_count");
#endif
d5271 8
a5278 3
	ahc_swap_hscb(scb->hscb);
		
	LIST_INSERT_HEAD(&ahc->pending_scbs, scb, pend_links);
d5280 3
a5282 1
	scb->flags |= SCB_ACTIVE;
d5284 3
a5286 2
	if (!(xs->flags & SCSI_POLL))
		timeout_add(&xs->stimeout, (xs->timeout * hz) / 1000);
d5288 2
a5289 13
	if ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {
#if 0
		printf("Continueing Immediate Command %d:%d\n",
		       xs->sc_link->target,
		       xs->sc_link->lun);
#endif
		pause_sequencer(ahc);
		if ((ahc->flags & AHC_PAGESCBS) == 0)
			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
		ahc_outb(ahc, SCB_TAG, scb->hscb->tag);
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
		unpause_sequencer(ahc);
	} else {
d5291 11
a5301 1
		ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;
d5303 32
a5334 9
		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
		    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
		
		if ((ahc->features & AHC_QUEUE_REGS) != 0) {
			ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
		} else {
			pause_sequencer(ahc);
			ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
			unpause_sequencer(ahc);
d5338 4
a5341 10
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWCMDS) {
		sc_print_addr(xs->sc_link);
		printf("opcode %d tag %x len %d flags %x control %x fpos %u"
		    " rate %x\n",
		    xs->cmdstore.opcode, scb->hscb->tag, scb->hscb->datalen,
		    scb->flags, scb->hscb->control, ahc->qinfifonext,
		    scb->hscb->scsirate);
	}
#endif
d5343 10
a5352 19
	if (!(xs->flags & SCSI_POLL)) {
		splx(s);
		return (SUCCESSFULLY_QUEUED);
	}
	/*
	 * If we can't use interrupts, poll for completion
	 */
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("cmd_poll\n"));
	do {
		if (ahc_poll(ahc, xs->timeout)) {
			if (!(xs->flags & SCSI_SILENT))
				printf("cmd fail\n");
			ahc_timeout(scb);
			break;
		}
	} while (!(xs->flags & ITSDONE));
	splx(s);
	return (COMPLETE);
}
d5354 3
a5356 10
STATIC int
ahc_poll(ahc, wait)
	struct   ahc_softc *ahc;
	int   wait;	/* in msec */
{
	while (--wait) {
		DELAY(1000);
		if (ahc_inb(ahc, INTSTAT) & INT_PEND)
			break;
	}
d5358 6
a5363 8
	if (wait == 0) {
		printf("%s: board is not responding\n", ahc_name(ahc));
		return (EIO);
	}
		
	ahc_intr((void *)ahc);
	return (0);
}
d5365 2
a5366 14
STATIC int
ahc_setup_data(ahc, xs, scb)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	struct scb *scb;
{
	struct hardware_scb *hscb;
	
	hscb = scb->hscb;
	xs->resid = xs->status = 0;
	
	hscb->cmdlen = xs->cmdlen;
	bcopy(xs->cmd, hscb->cmdstore, xs->cmdlen);
	hscb->cmdpointer = hscb->cmdstore_busaddr;
d5368 9
a5376 3
	/* Only use S/G if there is a transfer */
	if (xs->datalen) {
		int error;
d5378 22
a5399 16
		error = bus_dmamap_load(ahc->sc_dmat,
			    scb->dmamap, xs->data,
			    xs->datalen, NULL,
			    (xs->flags & SCSI_NOSLEEP) ?
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			if (!ahc_istagged_device(ahc, xs, 0))
				ahc_index_busy_tcl(ahc, hscb->tcl, TRUE);
			return (TRY_AGAIN_LATER);	/* XXX fvdl */
		}
		error = ahc_execute_scb(scb,
		    scb->dmamap->dm_segs,
		    scb->dmamap->dm_nsegs);
		return error;
	} else {
		return ahc_execute_scb(scb, NULL, 0);
d5401 3
d5406 6
a5411 4
STATIC void
ahc_freeze_devq(ahc, sc_link)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
d5413 1
a5413 3
	int	target;
	char	channel;
	int	lun;
d5415 2
a5416 8
	target = sc_link->target;
	lun = sc_link->lun;
	channel = SIM_CHANNEL(ahc, sc_link);
	
	ahc_search_qinfifo(ahc, target, channel, lun,
			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
			   SCB_REQUEUE, SEARCH_COMPLETE);
}
d5418 1
a5418 12
STATIC void
ahcallocscbs(ahc)
	struct ahc_softc *ahc;
{
	struct scb_data *scb_data;
	struct scb *next_scb;
	struct sg_map_node *sg_map;
	bus_addr_t physaddr;
	struct ahc_dma_seg *segs;
	int newcount;
	int i;
	int dma_flags = 0;
d5420 1
a5420 4
	scb_data = ahc->scb_data;
	if (scb_data->numscbs >= AHC_SCB_MAX)
		/* Can't allocate any more */
		return;
d5422 5
a5426 1
	next_scb = &scb_data->scbarray[scb_data->numscbs];
d5428 1
a5428 55
	sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);

	if (sg_map == NULL)
		return;
	bzero(sg_map, sizeof(struct sg_map_node));
	
	if (ahc_createdmamem(ahc, PAGE_SIZE, &sg_map->sg_dmamap,
	    (caddr_t *)&sg_map->sg_vaddr, &sg_map->sg_physaddr,
	    &sg_map->sg_dmasegs, &sg_map->sg_nseg, "SG space") < 0) {
		free(sg_map, M_DEVBUF);
		return;
	}
	
	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);

	segs = sg_map->sg_vaddr;
	physaddr = sg_map->sg_physaddr;

	newcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));

	for (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {
		int error;

		next_scb->sg_list = segs;
		/*
		 * The sequencer always starts with the second entry.
		 * The first entry is embedded in the scb.
		 */
		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
		next_scb->flags = SCB_FREE;
		
		/* set up AHA-284x right. */
		dma_flags = ((ahc->chip & AHC_VL) !=0) ? 
			BUS_DMA_NOWAIT|ISABUS_DMA_32BIT :
			BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW;
		
		error = bus_dmamap_create(ahc->sc_dmat,
				 AHC_MAXTRANSFER_SIZE, AHC_NSEG, MAXBSIZE, 0,
				 dma_flags, &next_scb->dmamap);
		if (error !=0) 
			break;

		next_scb->hscb = &scb_data->hscbs[scb_data->numscbs];
		next_scb->hscb->tag = ahc->scb_data->numscbs;
		next_scb->hscb->cmdstore_busaddr = 
		    ahc_hscb_busaddr(ahc, next_scb->hscb->tag)
		  + offsetof(struct hardware_scb, cmdstore);
		next_scb->hscb->cmdstore_busaddr =
		    htole32(next_scb->hscb->cmdstore_busaddr);
		SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, next_scb, links);
		segs += AHC_NSEG;
		physaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));
		next_scb++;
		ahc->scb_data->numscbs++;
	}
d5431 7
a5437 4
#ifdef AHC_DUMP_SEQ
STATIC void
ahc_dumpseq(ahc)
	struct ahc_softc* ahc;
d5439 5
a5443 15
	int i;
	int max_prog;

	if ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)
		max_prog = 448;
	else if ((ahc->features & AHC_ULTRA2) != 0)
		max_prog = 768;
	else
		max_prog = 512;

	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	for (i = 0; i < max_prog; i++) {
		u_int8_t ins_bytes[4];
d5445 3
a5447 5
		ahc_insb(ahc, SEQRAM, ins_bytes, 4);
		printf("0x%08x\n", ins_bytes[0] << 24
				 | ins_bytes[1] << 16
				 | ins_bytes[2] << 8
				 | ins_bytes[3]);
a5449 1
#endif
d5451 8
a5458 9
STATIC void
ahc_loadseq(ahc)
	struct ahc_softc* ahc;
{
	struct patch *cur_patch;
	int i;
	int downloaded;
	int skip_addr;
	u_int8_t download_consts[4];
d5460 7
a5466 5
	/* Setup downloadable constant table */
#if 0
	/* No downloaded constants are currently defined. */
	download_consts[TMODE_NUMCMDS] = ahc->num_targetcmds;
#endif
d5468 2
a5469 6
	cur_patch = patches;
	downloaded = 0;
	skip_addr = 0;
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
d5471 1
a5471 13
	for (i = 0; i < sizeof(seqprog)/4; i++) {
		if (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {
			/*
			 * Don't download this instruction as it
			 * is in a patch that was removed.
			 */
                        continue;
		}
		ahc_download_instr(ahc, i, download_consts);
		downloaded++;
	}
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);
	restart_sequencer(ahc);
d5473 4
a5476 3
	if (bootverbose)
		printf(" %d instructions downloaded\n", downloaded);
}
d5478 12
a5489 29
STATIC int
ahc_check_patch(ahc, start_patch, start_instr,skip_addr)
	struct ahc_softc *ahc;
	struct patch **start_patch;
	int start_instr;
	int *skip_addr;
{
	struct	patch *cur_patch;
	struct	patch *last_patch;
	int	num_patches;

	num_patches = sizeof(patches)/sizeof(struct patch);
	last_patch = &patches[num_patches];
	cur_patch = *start_patch;

	while (cur_patch < last_patch && start_instr == cur_patch->begin) {

		if (cur_patch->patch_func(ahc) == 0) {

			/* Start rejecting code */
			*skip_addr = start_instr + cur_patch->skip_instr;
			cur_patch += cur_patch->skip_patch;
		} else {
			/* Accepted this patch.  Advance to the next
			 * one and wait for our intruction pointer to
			 * hit this point.
			 */
			cur_patch++;
		}
d5492 5
a5496 6
	*start_patch = cur_patch;
	if (start_instr < *skip_addr)
		/* Still skipping */
		return (0);

	return (1);
d5499 10
a5508 5
STATIC void
ahc_download_instr(ahc, instrptr, dconsts)
	struct ahc_softc *ahc;
	int instrptr;
	u_int8_t *dconsts;
d5510 15
a5524 4
	union	ins_formats instr;
	struct	ins_format1 *fmt1_ins;
	struct	ins_format3 *fmt3_ins;
	u_int	opcode;
d5526 2
a5527 2
	/* Structure copy */
	instr = *(union ins_formats*)&seqprog[instrptr * 4];
d5529 2
a5530 1
	instr.integer = le32toh(instr.integer);
d5532 11
a5542 2
	fmt1_ins = &instr.format1;
	fmt3_ins = NULL;
d5544 1
a5544 17
	/* Pull the opcode */
	opcode = instr.format1.opcode;
	switch (opcode) {
	case AIC_OP_JMP:
	case AIC_OP_JC:
	case AIC_OP_JNC:
	case AIC_OP_CALL:
	case AIC_OP_JNE:
	case AIC_OP_JNZ:
	case AIC_OP_JE:
	case AIC_OP_JZ:
	{
		struct patch *cur_patch;
		int address_offset;
		u_int address;
		int skip_addr;
		int i;
d5546 14
a5559 5
		fmt3_ins = &instr.format3;
		address_offset = 0;
		address = fmt3_ins->address;
		cur_patch = patches;
		skip_addr = 0;
d5561 4
a5564 1
		for (i = 0; i < address;) {
d5566 9
a5574 1
			ahc_check_patch(ahc, &cur_patch, i, &skip_addr);
d5576 6
a5581 2
			if (skip_addr > i) {
				int end_addr;
d5583 6
a5588 10
				end_addr = MIN(address, skip_addr);
				address_offset += end_addr - i;
				i = skip_addr;
			} else {
				i++;
			}
		}
		address -= address_offset;
		fmt3_ins->address = address;
		/* FALLTHROUGH */
a5589 14
	case AIC_OP_OR:
	case AIC_OP_AND:
	case AIC_OP_XOR:
	case AIC_OP_ADD:
	case AIC_OP_ADC:
	case AIC_OP_BMOV:
		if (fmt1_ins->parity != 0) {
			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
		}
		fmt1_ins->parity = 0;
		/* FALLTHROUGH */
	case AIC_OP_ROL:
		if ((ahc->features & AHC_ULTRA2) != 0) {
			int i, count;
d5591 22
a5612 26
			/* Calculate odd parity for the instruction */
			for (i = 0, count = 0; i < 31; i++) {
				u_int32_t mask;

				mask = 0x01 << i;
				if ((instr.integer & mask) != 0)
					count++;
			}
			if ((count & 0x01) == 0)
				instr.format1.parity = 1;
		} else {
			/* Compress the instruction for older sequencers */
			if (fmt3_ins != NULL) {
				instr.integer =
					fmt3_ins->immediate
				      | (fmt3_ins->source << 8)
				      | (fmt3_ins->address << 16)
				      |	(fmt3_ins->opcode << 25);
			} else {
				instr.integer =
					fmt1_ins->immediate
				      | (fmt1_ins->source << 8)
				      | (fmt1_ins->destination << 16)
				      |	(fmt1_ins->ret << 24)
				      |	(fmt1_ins->opcode << 25);
			}
a5613 6
		instr.integer = htole32(instr.integer);
		ahc_outsb(ahc, SEQRAM, instr.bytes, 4);
		break;
	default:
		panic("Unknown opcode encountered in seq program");
		break;
d5615 4
d5621 2
a5622 4
STATIC void
ahc_set_recoveryscb(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
d5624 1
d5626 6
a5631 2
	if ((scb->flags & SCB_RECOVERY_SCB) == 0) {
		struct scb *scbp;
d5633 1
a5633 1
		scb->flags |= SCB_RECOVERY_SCB;
d5635 2
a5636 18
		/*
		 * Take all queued, but not sent SCBs out of the equation.
		 * Also ensure that no new CCBs are queued to us while we
		 * try to fix this problem.
		 */
		ahc->queue_blocked = 1;

		/*
		 * Go through all of our pending SCBs and remove
		 * any scheduled timeouts for them.  We will reschedule
		 * them after we've successfully fixed this problem.
		 */
		scbp = ahc->pending_scbs.lh_first;
		while (scbp != NULL) {
			timeout_del(&scbp->xs->stimeout);
			scbp = scbp->pend_links.le_next;
		}
	}
d5639 2
a5640 2
STATIC void
ahc_timeout(void *arg)
d5642 10
a5651 8
	struct	scb *scb;
	struct	ahc_softc *ahc;
	int	s, found;
	u_int	last_phase;
	int	target;
	int	lun;
	int	i;
	char	channel;
d5653 6
a5658 2
	scb = (struct scb *)arg; 
	ahc = (struct ahc_softc *)scb->xs->sc_link->adapter_softc;
d5660 2
a5661 1
	s = splbio();
d5664 3
a5666 4
	 * Ensure that the card doesn't do anything
	 * behind our back.  Also make sure that we
	 * didn't "just" miss an interrupt that would
	 * affect this timeout.
d5668 4
a5671 11
	do {
		ahc_intr(ahc);
		pause_sequencer(ahc);
	} while (ahc_inb(ahc, INTSTAT) & INT_PEND);

	if ((scb->flags & SCB_ACTIVE) == 0) {
		/* Previous timeout took care of me already */
		printf("Timedout SCB handled by another timeout\n");
		unpause_sequencer(ahc);
		splx(s);
		return;
d5673 1
a5674 6
	target = SCB_TARGET(scb);
	channel = SCB_CHANNEL(scb);
	lun = SCB_LUN(scb);

	sc_print_addr(scb->xs->sc_link);
	printf("SCB 0x%x - timed out ", scb->hscb->tag);
d5676 1
a5676 2
	 * Take a snapshot of the bus state and print out
	 * some information so we can track down driver bugs.
d5678 18
a5695 40
	last_phase = ahc_inb(ahc, LASTPHASE);

	for (i = 0; i < num_phases; i++) {
		if (last_phase == phase_table[i].phase)
			break;
	}
	printf("%s", phase_table[i].phasemsg);
  
	printf(", SEQADDR == 0x%x\n",
	       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
#if 0
	printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1));
	printf("SSTAT3 == 0x%x\n", ahc_inb(ahc, SSTAT3));
	printf("SCSIPHASE == 0x%x\n", ahc_inb(ahc, SCSIPHASE));
	printf("SCSIRATE == 0x%x\n", ahc_inb(ahc, SCSIRATE));
	printf("SCSIOFFSET == 0x%x\n", ahc_inb(ahc, SCSIOFFSET));
	printf("SEQ_FLAGS == 0x%x\n", ahc_inb(ahc, SEQ_FLAGS));
	printf("SCB_DATAPTR == 0x%x\n", ahc_inb(ahc, SCB_DATAPTR)
				      | ahc_inb(ahc, SCB_DATAPTR + 1) << 8
				      | ahc_inb(ahc, SCB_DATAPTR + 2) << 16
				      | ahc_inb(ahc, SCB_DATAPTR + 3) << 24);
	printf("SCB_DATACNT == 0x%x\n", ahc_inb(ahc, SCB_DATACNT)
				      | ahc_inb(ahc, SCB_DATACNT + 1) << 8
				      | ahc_inb(ahc, SCB_DATACNT + 2) << 16);
	printf("SCB_SGCOUNT == 0x%x\n", ahc_inb(ahc, SCB_SGCOUNT));
	printf("CCSCBCTL == 0x%x\n", ahc_inb(ahc, CCSCBCTL));
	printf("CCSCBCNT == 0x%x\n", ahc_inb(ahc, CCSCBCNT));
	printf("DFCNTRL == 0x%x\n", ahc_inb(ahc, DFCNTRL));
	printf("DFSTATUS == 0x%x\n", ahc_inb(ahc, DFSTATUS));
	printf("CCHCNT == 0x%x\n", ahc_inb(ahc, CCHCNT));
	if (scb->sg_count > 0) {
		for (i = 0; i < scb->sg_count; i++) {
			printf("sg[%d] - Addr 0x%x : Length %d\n",
			       i,
			       le32toh(scb->sg_list[i].addr),
			       le32toh(scb->sg_list[i].len));
		}
	}
#endif
	if (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {
d5697 3
a5699 2
		 * Been down this road before.
		 * Do a full bus reset.
d5701 6
a5706 5
bus_reset:
		ahcsetccbstatus(scb->xs, XS_TIMEOUT);
		found = ahc_reset_channel(ahc, channel, /*Initiate Reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), channel, found);
d5708 8
d5717 3
a5719 20
		 * If we are a target, transition to bus free and report
		 * the timeout.
		 * 
		 * The target/initiator that is holding up the bus may not
		 * be the same as the one that triggered this timeout
		 * (different commands have different timeout lengths).
		 * If the bus is idle and we are actiing as the initiator
		 * for this request, queue a BDR message to the timed out
		 * target.  Otherwise, if the timed out transaction is
		 * active:
		 *   Initiator transaction:
		 *	Stuff the message buffer with a BDR message and assert
		 *	ATN in the hopes that the target will let go of the bus
		 *	and go to the mesgout phase.  If this fails, we'll
		 *	get another timeout 2 seconds later which will attempt
		 *	a bus reset.
		 *
		 *   Target transaction:
		 *	Transition to BUS FREE and report the error.
		 *	It's good to be the target!
d5721 6
a5726 59
		u_int active_scb_index;

		active_scb_index = ahc_inb(ahc, SCB_TAG);

		if (last_phase != P_BUSFREE 
		  && (active_scb_index < ahc->scb_data->numscbs)) {
			struct scb *active_scb;

			/*
			 * If the active SCB is not from our device,
			 * assume that another device is hogging the bus
			 * and wait for it's timeout to expire before
			 * taking additional action.
			 */ 
			active_scb = &ahc->scb_data->scbarray[active_scb_index];
			if (active_scb->hscb->tcl != scb->hscb->tcl) {
				u_int	newtimeout;

				sc_print_addr(scb->xs->sc_link);
				printf("Other SCB Timeout%s",
			 	       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
				       ? " again\n" : "\n");
				scb->flags |= SCB_OTHERTCL_TIMEOUT;
				newtimeout = MAX(active_scb->xs->timeout,
						 scb->xs->timeout);
				timeout_add(&scb->xs->stimeout,
				    (newtimeout * hz) / 1000);
				splx(s);
				return;
			} 

			/* It's us */
			if ((scb->hscb->control & TARGET_SCB) != 0) {

				/*
				 * Send back any queued up transactions
				 * and properly record the error condition.
				 */
				ahc_freeze_devq(ahc, scb->xs->sc_link);
				ahcsetccbstatus(scb->xs, XS_TIMEOUT);
				ahc_freeze_ccb(scb);
				ahc_done(ahc, scb);

				/* Will clear us from the bus */
				restart_sequencer(ahc);
				splx(s);
				return;
			} 

			ahc_set_recoveryscb(ahc, active_scb);
			ahc_outb(ahc, MSG_OUT, MSG_BUS_DEV_RESET);
			ahc_outb(ahc, SCSISIGO, last_phase|ATNO);
			sc_print_addr(active_scb->xs->sc_link);
			printf("BDR message in message buffer\n");
			active_scb->flags |=  SCB_DEVICE_RESET;
			timeout_add(&active_scb->xs->stimeout, 2 * hz);
			unpause_sequencer(ahc);
		} else {
			int	 disconnected;
d5728 7
a5734 14
			/* XXX Shouldn't panic.  Just punt instead */
			if ((scb->hscb->control & TARGET_SCB) != 0)
				panic("Timed-out target SCB but bus idle");

			if (last_phase != P_BUSFREE
			 && (ahc_inb(ahc, SSTAT0) & TARGET) != 0) {
				/* XXX What happened to the SCB? */
				/* Hung target selection.  Goto busfree */
				printf("%s: Hung target selection\n",
				       ahc_name(ahc));
				restart_sequencer(ahc);
				splx(s);
				return;
			}
d5736 1
a5736 7
			if (ahc_search_qinfifo(ahc, target, channel, lun,
					       scb->hscb->tag, ROLE_INITIATOR,
					       /*status*/0, SEARCH_COUNT) > 0) {
				disconnected = FALSE;
			} else {
				disconnected = TRUE;
			}
d5738 8
a5745 2
			if (disconnected) {
				u_int active_scb;
d5747 5
a5751 7
				ahc_set_recoveryscb(ahc, scb);
				/*
				 * Simply set the MK_MESSAGE control bit.
				 */
				scb->hscb->control |= MK_MESSAGE;
				scb->flags |= SCB_QUEUED_MSG
					   |  SCB_DEVICE_RESET;
d5753 3
a5755 21
				/*
				 * Mark the cached copy of this SCB in the
				 * disconnected list too, so that a reconnect
				 * at this point causes a BDR or abort.
				 */
				active_scb = ahc_inb(ahc, SCBPTR);
				if (ahc_search_disc_list(ahc, target,
							 channel, lun,
							 scb->hscb->tag,
							 /*stop_on_first*/TRUE,
							 /*remove*/FALSE,
							 /*save_state*/FALSE)) {
					u_int scb_control;

					scb_control = ahc_inb(ahc, SCB_CONTROL);
					scb_control |= MK_MESSAGE;
					ahc_outb(ahc, SCB_CONTROL, scb_control);
				}
				ahc_outb(ahc, SCBPTR, active_scb);
				ahc_index_busy_tcl(ahc, scb->hscb->tcl,
						   /*unbusy*/TRUE);
d5757 3
a5759 42
				/*
				 * Actually re-queue this SCB in case we can
				 * select the device before it reconnects.
				 * Clear out any entries in the QINFIFO first
				 * so we are the next SCB for this target
				 * to run.
				 */
				ahc_search_qinfifo(ahc, SCB_TARGET(scb),
						   channel, SCB_LUN(scb),
						   SCB_LIST_NULL,
						   ROLE_INITIATOR,
						   SCB_REQUEUE,
						   SEARCH_COMPLETE);
				sc_print_addr(scb->xs->sc_link);
				printf("Queuing a BDR SCB\n");
				ahc->qinfifo[ahc->qinfifonext++] =
				    scb->hscb->tag;

				bus_dmamap_sync(ahc->sc_dmat,
				    ahc->shared_data_dmamap,
				    QINFIFO_OFFSET * 256, 256,
				    BUS_DMASYNC_PREWRITE);

				if ((ahc->features & AHC_QUEUE_REGS) != 0) {
					ahc_outb(ahc, HNSCB_QOFF,
						 ahc->qinfifonext);
				} else {
					ahc_outb(ahc, KERNEL_QINPOS,
						 ahc->qinfifonext);
				}
				timeout_add(&scb->xs->stimeout, 2 * hz);
				unpause_sequencer(ahc);
			} else {
				/* Go "immediatly" to the bus reset */
				/* This shouldn't happen */
				ahc_set_recoveryscb(ahc, scb);
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d: Immediate reset.  "
					"Flags = 0x%x\n", scb->hscb->tag,
					scb->flags);
				goto bus_reset;
			}
d5762 4
a5765 22
	splx(s);
}

STATIC int
ahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	role_t role;
	u_int32_t status;
	ahc_search_action action;
{
	struct	 scb *scbp;
	u_int8_t qinpos;
	u_int8_t qintail;
	int	 found;

	qinpos = ahc_inb(ahc, QINPOS);
	qintail = ahc->qinfifonext;
	found = 0;
d5768 1
a5768 2
	 * Start with an empty queue.  Entries that are not chosen
	 * for removal will be re-added to the queue as we go.
d5770 6
a5775 3
	ahc->qinfifonext = qinpos;
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_POSTREAD);
d5777 9
a5785 25
	while (qinpos != qintail) {
		scbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];
		if (ahc_match_scb(scbp, target, channel, lun, tag, role)) {
			/*
			 * We found an scb that needs to be removed.
			 */
			switch (action) {
			case SEARCH_COMPLETE:
				if (!(scbp->xs->flags & ITSDONE)) {
					scbp->flags |= status;
					scbp->xs->error = XS_NOERROR;
				}
				ahc_freeze_ccb(scbp);
				ahc_done(ahc, scbp);
				break;
			case SEARCH_COUNT:
				ahc->qinfifo[ahc->qinfifonext++] =
				    scbp->hscb->tag;
				break;
			case SEARCH_REMOVE:
				break;
			}
			found++;
		} else {
			ahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;
a5786 9
		qinpos++;
	}
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
	
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
d5789 5
a5793 1
	return (found);
d5796 2
d5799 1
a5799 4
 * Abort all SCBs that match the given description (target/channel/lun/tag),
 * setting their status to the passed in status if the status has not already
 * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
 * is paused before it is called.
d5801 2
a5802 9
STATIC int
ahc_abort_scbs(ahc, target, channel, lun, tag, role, status)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	role_t role;
	u_int32_t status;
d5804 21
a5824 4
	struct	scb *scbp;
	u_int	active_scb;
	int	i;
	int	found;
d5826 6
a5831 2
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
d5833 3
a5835 2
	found = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,
				   role, SCB_REQUEUE, SEARCH_COMPLETE);
d5837 12
a5848 8
	/*
	 * Search waiting for selection list.
	 */
	{
		u_int8_t next, prev;
                /* Start at head of list. */
		next = ahc_inb(ahc, WAITING_SCBH);
		prev = SCB_LIST_NULL;
d5850 6
a5855 2
		while (next != SCB_LIST_NULL) {
			u_int8_t scb_index;
d5857 2
a5858 10
			ahc_outb(ahc, SCBPTR, next);
			scb_index = ahc_inb(ahc, SCB_TAG);
			if (scb_index >= ahc->scb_data->numscbs) {
				panic("Waiting List inconsistency. "
				      "SCB index == %d, yet numscbs == %d.",
				      scb_index, ahc->scb_data->numscbs);
			}
			scbp = &ahc->scb_data->scbarray[scb_index];
			if (ahc_match_scb(scbp, target, channel,
					  lun, SCB_LIST_NULL, role)) {
d5860 8
a5867 6
				next = ahc_abort_wscb(ahc, next, prev);
			} else {
				
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
			}
d5870 12
a5881 9
	/*
	 * Go through the disconnected list and remove any entries we
	 * have queued for completion, 0'ing their control byte too.
	 * We save the active SCB and restore it ourselves, so there
	 * is no reason for this search to restore it too.
	 */
	ahc_search_disc_list(ahc, target, channel, lun, tag,
			     /*stop_on_first*/FALSE, /*remove*/TRUE,
			     /*save_state*/FALSE);
d5883 18
a5900 6
	/*
	 * Go through the hardware SCB array looking for commands that
	 * were active but not on any list.
	 */
	for(i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scbid;
d5902 32
a5933 7
		ahc_outb(ahc, SCBPTR, i);
		scbid = ahc_inb(ahc, SCB_TAG);
		scbp = &ahc->scb_data->scbarray[scbid];
		if (scbid < ahc->scb_data->numscbs && 
			 ahc_match_scb(scbp, target, channel, lun, tag, role))
				ahc_add_curscb_to_free_list(ahc);
	}
d5935 9
a5943 8
	/*
	 * Go through the pending CCB list and look for
	 * commands for this target that are still active.
	 * These are other tagged commands that were
	 * disconnected when the reset occurred.
	 */
	{
		struct scb *scb;
d5945 16
a5960 12
		scb = ahc->pending_scbs.lh_first;
		while (scb != NULL) {
			scbp = scb;
			scb = scb->pend_links.le_next;
			if (ahc_match_scb(scbp, target, channel,
					  lun, tag, role)) {
				if (!(scbp->xs->flags & ITSDONE))
					ahcsetccbstatus(scbp->xs, status);
				ahc_freeze_ccb(scbp);
				ahc_done(ahc, scbp);
				found++;
			}
d5962 6
a5968 2
	ahc_outb(ahc, SCBPTR, active_scb);
	return found;
d5970 3
d5974 3
a5976 11
STATIC int
ahc_search_disc_list(ahc, target, channel, lun, tag, stop_on_first, 
		     remove, save_state)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	int stop_on_first;
	int remove;
	int save_state;
d5978 24
a6001 5
	struct	scb *scbp;
	u_int	next;
	u_int	prev;
	u_int	count;
	u_int	active_scb;
d6003 23
a6025 3
	count = 0;
	next = ahc_inb(ahc, DISCONNECTED_SCBH);
	prev = SCB_LIST_NULL;
d6027 13
a6039 6
	if (save_state) {
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
	} else
		/* Silence compiler */
		active_scb = SCB_LIST_NULL;
d6041 6
a6046 2
	while (next != SCB_LIST_NULL) {
		u_int scb_index;
d6048 7
a6054 6
		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			panic("Disconnected List inconsistency. "
			      "SCB index == %d, yet numscbs == %d.",
			      scb_index, ahc->scb_data->numscbs);
d6056 18
a6073 10
		scbp = &ahc->scb_data->scbarray[scb_index];
		if (ahc_match_scb(scbp, target, channel, lun,
				  tag, ROLE_INITIATOR)) {
			count++;
			if (remove) {
				next =
				    ahc_rem_scb_from_disc_list(ahc, prev, next);
			} else {
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
d6075 1
a6075 5
			if (stop_on_first)
				break;
		} else {
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
d6077 12
d6090 5
a6094 3
	if (save_state)
	ahc_outb(ahc, SCBPTR, active_scb);
	return (count);
d6097 3
a6099 5
STATIC u_int
ahc_rem_scb_from_disc_list(ahc, prev, scbptr)
	struct ahc_softc *ahc;
	u_int prev;
	u_int scbptr;
d6101 7
a6107 1
	u_int next;
d6109 1
a6109 2
	ahc_outb(ahc, SCBPTR, scbptr);
	next = ahc_inb(ahc, SCB_NEXT);
d6111 1
a6111 1
	ahc_outb(ahc, SCB_CONTROL, 0);
d6113 11
a6123 1
	ahc_add_curscb_to_free_list(ahc);
d6125 4
a6128 5
	if (prev != SCB_LIST_NULL) {
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	} else
		ahc_outb(ahc, DISCONNECTED_SCBH, next);
d6130 1
a6130 1
	return (next);
d6133 2
a6134 3
STATIC void
ahc_add_curscb_to_free_list(ahc)
	struct ahc_softc *ahc;
d6136 4
a6139 18
	/* Invalidate the tag so that ahc_find_scb doesn't think it's active */
	ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);

	ahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));
	ahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));
}

/*
 * Manipulate the waiting for selection list and return the
 * scb that follows the one that we remove.
 */
STATIC u_int
ahc_abort_wscb(ahc, scbpos, prev)
	struct ahc_softc *ahc;
	u_int scbpos;
        u_int prev;
{       
	u_int curscb, next;
d6142 1
a6142 2
	 * Select the SCB we want to abort and
	 * pull the next pointer out of it.
d6144 1
a6144 3
	curscb = ahc_inb(ahc, SCBPTR);
	ahc_outb(ahc, SCBPTR, scbpos);
	next = ahc_inb(ahc, SCB_NEXT);
d6146 2
a6147 2
	/* Clear the necessary fields */
	ahc_outb(ahc, SCB_CONTROL, 0);
d6149 17
a6165 1
	ahc_add_curscb_to_free_list(ahc);
d6167 5
a6171 4
	/* update the waiting list */
	if (prev == SCB_LIST_NULL) {
		/* First in the list */
		ahc_outb(ahc, WAITING_SCBH, next); 
d6173 1
a6173 13
		/*
		 * Ensure we aren't attempting to perform
		 * selection for this entry.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else {
		/*
		 * Select the scb that pointed to us 
		 * and update its next pointer.
		 */
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	}
d6175 1
a6175 6
	/*
	 * Point us back at the original scb position.
	 */
	ahc_outb(ahc, SCBPTR, curscb);
	return next;
}
d6177 2
a6178 11
STATIC void
ahc_clear_intstat(ahc)
	struct ahc_softc *ahc;
{
	/* Clear any interrupt conditions this may have caused */
	ahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);
	ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
				|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|
				CLRREQINIT);
	ahc_outb(ahc, CLRINT, CLRSCSIINT);
}
d6180 40
a6219 5
STATIC void
ahc_reset_current_bus(ahc)
	struct ahc_softc *ahc;
{
	u_int8_t scsiseq;
d6221 3
a6223 6
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);
	scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);
	DELAY(AHC_BUSRESET_DELAY);
	/* Turn off the bus reset */
	ahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);
d6225 31
a6255 4
	ahc_clear_intstat(ahc);

	/* Re-enable reset interrupts */
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);
d6258 2
a6259 5
STATIC int
ahc_reset_channel(ahc, channel, initiate_reset)
	struct ahc_softc *ahc;
	char channel;
	int initiate_reset;
d6261 11
a6271 6
	u_int	initiator, target, max_scsiid;
	u_int	sblkctl;
	u_int	our_id;
	int	found;
	int	restart_needed;
	char	cur_channel;
d6273 1
a6273 1
	ahc->pending_device = NULL;
d6275 39
a6313 40
	pause_sequencer(ahc);

	/*
	 * Run our command complete fifos to ensure that we perform
	 * completion processing on any commands that 'completed'
	 * before the reset occurred.
	 */
	ahc_run_qoutfifo(ahc);

	/*
	 * Reset the bus if we are initiating this reset
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	cur_channel = 'A';
	if ((ahc->features & AHC_TWIN) != 0
	 && ((sblkctl & SELBUSB) != 0))
	    cur_channel = 'B';
	if (cur_channel != channel) {
		/* Case 1: Command for another bus is active
		 * Stealthily reset the other bus without
		 * upsetting the current bus.
		 */
		ahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
		ahc_outb(ahc, SBLKCTL, sblkctl);
		restart_needed = FALSE;
	} else {
		/* Case 2: A command from this bus is active or we're idle */
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
d6315 17
a6331 11
		/*
		 * Since we are going to restart the sequencer, avoid
		 * a race in the sequencer that could cause corruption
		 * of our Q pointers by starting over from index 0.
		 */
		ahc->qoutfifonext = 0;
		if ((ahc->features & AHC_QUEUE_REGS) != 0)
			ahc_outb(ahc, SDSCB_QOFF, 0);
		else
			ahc_outb(ahc, QOUTPOS, 0);
		restart_needed = TRUE;
d6333 35
a6367 12

	/*
	 * Clean up all the state information for the
	 * pending transactions on this bus.
	 */
	found = ahc_abort_scbs(ahc, ALL_TARGETS, channel,
			       ALL_LUNS, SCB_LIST_NULL,
			       ROLE_UNKNOWN, XS_RESET);
	if (channel == 'B') {
		our_id = ahc->our_id_b;
	} else {
		our_id = ahc->our_id;
d6369 1
d6371 8
a6378 6
	max_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;
	
	/*
	 * Revert to async/narrow transfers until we renegotiate.
	 */
	for (target = 0; target <= max_scsiid; target++) {
d6380 4
a6383 1
		if (ahc->enabled_targets[target] == NULL)
d6385 6
a6390 16
		for (initiator = 0; initiator <= max_scsiid; initiator++) {
			struct ahc_devinfo devinfo;

			ahc_compile_devinfo(&devinfo, target, initiator,
					    ALL_LUNS,
					    channel, ROLE_UNKNOWN);
			ahc_set_width(ahc, &devinfo,
				      MSG_EXT_WDTR_BUS_8_BIT,
				      AHC_TRANS_CUR,
				      /*paused*/TRUE,
				      /*done*/FALSE);
			ahc_set_syncrate(ahc, &devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, AHC_TRANS_CUR,
					 /*paused*/TRUE,
					 /*done*/FALSE);
d6392 1
d6395 2
a6396 5
	if (restart_needed)
		restart_sequencer(ahc);
	else
		unpause_sequencer(ahc);
	return found;
d6399 36
a6434 13
STATIC int
ahc_match_scb(scb, target, channel, lun, role, tag)
	struct scb *scb;
	int target;
	char channel;
	int lun;
	role_t role;
	u_int tag;
{
	int targ = SCB_TARGET(scb);
	char chan = SCB_CHANNEL(scb);
	int slun = SCB_LUN(scb);
	int match;
d6436 2
a6437 7
	match = ((chan == channel) || (channel == ALL_CHANNELS));
	if (match != 0)
		match = ((targ == target) || (target == ALL_TARGETS));
	if (match != 0)
		match = ((lun == slun) || (lun == ALL_LUNS));
	return match;
}
d6439 1
a6439 12
STATIC void
ahc_construct_sdtr(ahc, period, offset)
	struct ahc_softc *ahc;
	u_int period;
	u_int offset;
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_len += 5;
d6442 2
a6443 4
STATIC void
ahc_construct_wdtr(ahc, bus_width)
	struct ahc_softc *ahc;
	u_int bus_width;
d6445 9
a6453 6
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_len += 4;
}
d6455 2
a6456 5
STATIC void
ahc_calc_residual(scb)
	struct scb *scb;
{
	struct	hardware_scb *hscb;
d6458 4
a6461 1
	hscb = scb->hscb;
d6463 2
a6464 17
	/*
	 * If the disconnected flag is still set, this is bogus
	 * residual information left over from a sequencer
	 * pagin/pageout, so ignore this case.
	 */
	if ((scb->hscb->control & DISCONNECTED) == 0) {
		u_int32_t resid;
		int	  resid_sgs;
		int	  sg;
		
		/*
		 * Remainder of the SG where the transfer
		 * stopped.
		 */
		resid = (hscb->residual_data_count[2] << 16)
		      |	(hscb->residual_data_count[1] <<8)
		      |	(hscb->residual_data_count[0]);
d6466 4
a6469 8
		/*
		 * Add up the contents of all residual
		 * SG segments that are after the SG where
		 * the transfer stopped.
		 */
		resid_sgs = scb->hscb->residual_SG_count - 1/*current*/;
		sg = scb->sg_count - resid_sgs;
		while (resid_sgs > 0) {
d6471 22
a6492 3
			resid += le32toh(scb->sg_list[sg].len);
			sg++;
			resid_sgs--;
a6493 1
		scb->xs->resid = resid;
d6496 3
a6498 10
	/*
	 * Clean out the residual information in this SCB for its
	 * next consumer.
	 */
	hscb->residual_SG_count = 0;

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC) {
		sc_print_addr(scb->xs->sc_link);
		printf("Handled Residual of %ld bytes\n" ,scb->xs->resid);
a6499 11
#endif
}

STATIC void
ahc_update_pending_syncrates(ahc)
	struct ahc_softc *ahc;
{
	struct	scb *scb;
	int	pending_scb_count;
	int	i;
	u_int	saved_scbptr;
d6502 2
a6503 2
	 * Traverse the pending SCB list and ensure that all of the
	 * SCBs there have the proper settings.
d6505 25
a6529 31
	scb = LIST_FIRST(&ahc->pending_scbs);
	pending_scb_count = 0;
	while (scb != NULL) {
		struct ahc_devinfo devinfo;
		struct scsi_xfer *xs;
		struct scb *pending_scb;
		struct hardware_scb *pending_hscb;
		struct ahc_initiator_tinfo *tinfo;
		struct tmode_tstate *tstate;
		u_int  our_id, remote_id;
		
		xs = scb->xs;
		pending_scb = scb;
		pending_hscb = pending_scb->hscb;
		our_id = SCB_IS_SCSIBUS_B(pending_scb)
		       ? ahc->our_id_b : ahc->our_id;
		remote_id = xs->sc_link->target;
		ahc_compile_devinfo(&devinfo, our_id, remote_id,
				    SCB_LUN(pending_scb),
				    SCB_CHANNEL(pending_scb),
				    ROLE_UNKNOWN);
		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
					    our_id, remote_id, &tstate);
		pending_hscb->control &= ~ULTRAENB;
		if ((tstate->ultraenb & devinfo.target_mask) != 0)
			pending_hscb->control |= ULTRAENB;
		pending_hscb->scsirate = tinfo->scsirate;
		pending_hscb->scsioffset = tinfo->current.offset;
		pending_scb_count++;
		scb = LIST_NEXT(scb, pend_links);
	}
d6531 2
a6532 2
	if (pending_scb_count == 0)
		return;
d6534 7
a6540 4
	saved_scbptr = ahc_inb(ahc, SCBPTR);
	/* Ensure that the hscbs down on the card match the new information */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scb_tag;
d6542 10
a6551 11
		ahc_outb(ahc, SCBPTR, i);
		scb_tag = ahc_inb(ahc, SCB_TAG);
		if (scb_tag != SCB_LIST_NULL) {
			struct	ahc_devinfo devinfo;
			struct	scb *pending_scb;
			struct scsi_xfer *xs;
			struct	hardware_scb *pending_hscb;
			struct	ahc_initiator_tinfo *tinfo;
			struct	tmode_tstate *tstate;
			u_int	our_id, remote_id;
			u_int	control;
d6553 31
a6583 21
			pending_scb = &ahc->scb_data->scbarray[scb_tag];
			if (pending_scb->flags == SCB_FREE)
				continue;
			pending_hscb = pending_scb->hscb;
			xs = pending_scb->xs;
			our_id = SCB_IS_SCSIBUS_B(pending_scb)
			       ? ahc->our_id_b : ahc->our_id;
			remote_id = xs->sc_link->target;
			ahc_compile_devinfo(&devinfo, our_id, remote_id,
					    SCB_LUN(pending_scb),
					    SCB_CHANNEL(pending_scb),
					    ROLE_UNKNOWN);
			tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
						    our_id, remote_id, &tstate);
			control = ahc_inb(ahc, SCB_CONTROL);
			control &= ~ULTRAENB;
			if ((tstate->ultraenb & devinfo.target_mask) != 0)
				control |= ULTRAENB;
			ahc_outb(ahc, SCB_CONTROL, control);
			ahc_outb(ahc, SCB_SCSIRATE, tinfo->scsirate);
			ahc_outb(ahc, SCB_SCSIOFFSET, tinfo->current.offset);
d6585 49
a6633 3
	}
	ahc_outb(ahc, SCBPTR, saved_scbptr);
}
d6635 1
a6635 6
STATIC void
ahc_shutdown(void *arg)
{
	struct	ahc_softc *ahc;
	int	i;
	u_int	sxfrctl1_a, sxfrctl1_b;
d6637 23
a6659 1
	ahc = (struct ahc_softc *)arg;
d6661 4
a6664 1
	pause_sequencer(ahc);
d6666 15
a6680 9
	/*
	 * Preserve the value of the SXFRCTL1 register for all channels.
	 * It contains settings that affect termination and we don't want
	 * to disturb the integrity of the bus during shutdown in case
	 * we are in a multi-initiator setup.
	 */
	sxfrctl1_b = 0;
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;
d6682 4
a6685 5
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		sxfrctl1_b = ahc_inb(ahc, SXFRCTL1);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
d6687 4
a6690 1
	sxfrctl1_a = ahc_inb(ahc, SXFRCTL1);
d6692 4
a6695 2
	/* This will reset most registers to 0, but not all */
	ahc_reset(ahc);
d6697 15
a6711 2
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;
d6713 18
a6730 6
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		ahc_outb(ahc, SXFRCTL1, sxfrctl1_b);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	ahc_outb(ahc, SXFRCTL1, sxfrctl1_a);
d6732 1
a6732 3
	ahc_outb(ahc, SCSISEQ, 0);
	ahc_outb(ahc, SXFRCTL0, 0);
	ahc_outb(ahc, DSPCISTATUS, 0);
d6734 28
a6761 2
	for (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)
		ahc_outb(ahc, i, 0);
d6764 2
a6765 4
STATIC void
ahc_check_tags(ahc, xs)
struct ahc_softc *ahc;
struct scsi_xfer *xs;
d6767 2
a6768 5
	struct scsi_inquiry_data *inq;
	struct ahc_devinfo devinfo;
	struct tmode_tstate *tstate;
	int target_id, our_id;
	char channel;
d6770 2
a6771 2
	if (xs->cmd->opcode != INQUIRY || xs->error != XS_NOERROR)
		return;
d6773 13
a6785 2
	if (xs->sc_link->quirks & SDEV_NOTAGS)
		return;
d6787 14
a6800 7
	target_id = xs->sc_link->target;
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
	channel = SIM_CHANNEL(ahc, xs->sc_link);

	(void)ahc_fetch_transinfo(ahc, channel, our_id, target_id, &tstate);
	ahc_compile_devinfo(&devinfo, our_id, target_id,
	    xs->sc_link->lun, channel, ROLE_INITIATOR);
d6802 4
a6805 2
	if (tstate->tagdisable & devinfo.target_mask)
		return;
d6808 16
a6823 11
	 * Sneak a look at the results of the SCSI Inquiry
	 * command and see if we can do Tagged queing.  This
	 * should really be done by the higher level drivers.
	 */
	inq = (struct scsi_inquiry_data *)xs->data;
	if ((inq->flags & SID_CmdQue) && !(ahc_istagged_device(ahc, xs, 1))) {
#ifdef AHC_DEBUG 
		printf("%s: target %d using tagged queuing\n",
			ahc_name(ahc), xs->sc_link->target);
#endif 
		ahc_set_tags(ahc, &devinfo, TRUE);
d6825 28
a6852 14
		if (ahc->scb_data->maxhscbs >= 16 ||
		    (ahc->flags & AHC_PAGESCBS)) {
			/* Default to 16 tags */
			xs->sc_link->openings += 14;
		} else {
			/*
			 * Default to 4 tags on whimpy
			 * cards that don't have much SCB
			 * space and can't page.  This prevents
			 * a single device from hogging all
			 * slots.  We should really have a better
			 * way of providing fairness.
			 */
			xs->sc_link->openings += 2;
d6857 2
a6858 5
STATIC int
ahc_istagged_device(ahc, xs, nocmdcheck)
struct ahc_softc *ahc;
struct scsi_xfer *xs;
int nocmdcheck;
d6860 39
a6898 4
	char channel;
	u_int our_id, target;
	struct tmode_tstate *tstate;
	struct ahc_devinfo devinfo;
d6900 5
a6904 2
	if (xs->sc_link->quirks & SDEV_NOTAGS)
		return 0;
d6907 2
a6908 2
	 * XXX never do these commands with tags. Should really be
	 * in a higher layer.
d6910 11
a6920 4
	if (!nocmdcheck && (xs->cmd->opcode == INQUIRY ||
	     xs->cmd->opcode == TEST_UNIT_READY ||
	     xs->cmd->opcode == REQUEST_SENSE))
		return 0;
d6922 24
a6945 4
	channel = SIM_CHANNEL(ahc, xs->sc_link);
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
	target = xs->sc_link->target;
	(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);
d6947 1
a6947 2
	ahc_compile_devinfo(&devinfo, our_id, target,
	    xs->sc_link->lun, channel, ROLE_INITIATOR);
d6949 17
a6965 1
	return (tstate->tagenable & devinfo.target_mask);
d6967 2
@


1.34.2.1
log
@Sync UBC branch to -current
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.34 2001/11/15 10:57:01 ho Exp $
d214 18
a231 15
STATIC int	ahc_poll(struct ahc_softc *ahc, int wait);
STATIC void	ahc_shutdown(void *arg);
STATIC int	ahc_execute_scb(void *arg, bus_dma_segment_t *dm_segs,
		    int nsegments);
STATIC int	ahc_setup_data(struct ahc_softc *ahc, struct scsi_xfer *xs,
		    struct scb *scb);
STATIC void	ahc_freeze_devq(struct ahc_softc *ahc,
		    struct scsi_link *sc_link);
STATIC void	ahcallocscbs(struct ahc_softc *ahc);
STATIC void	ahc_fetch_devinfo(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_compile_devinfo(struct ahc_devinfo *devinfo, u_int our_id,
		    u_int target, u_int lun, char channel, role_t role);
STATIC u_int	ahc_abort_wscb(struct ahc_softc *ahc, u_int scbpos, u_int prev);
STATIC void	ahc_done(struct ahc_softc *ahc, struct scb *scbp);
d233 18
a250 16
		ahc_alloc_tstate(struct ahc_softc *ahc, u_int scsi_id,
		    char channel);
STATIC void	ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat);
STATIC void	ahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat);
STATIC void	ahc_build_transfer_msg(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_setup_initiator_msgout(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, struct scb *scb);
STATIC void	ahc_setup_target_msgin(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC int	ahc_handle_msg_reject(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_clear_msg_state(struct ahc_softc *ahc);
STATIC void	ahc_handle_message_phase(struct ahc_softc *ahc,
		    struct scsi_link *sc_link);
STATIC int	ahc_sent_msg(struct ahc_softc *ahc, u_int msgtype, int full);
d258 9
a266 7
STATIC int	ahc_parse_msg(struct ahc_softc *ahc, struct scsi_link *sc_link,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_handle_ign_wide_residue(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_handle_devreset(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, int status, char *message,
		    int verbose_level);
d268 1
a268 1
STATIC void	ahc_dumpseq(struct ahc_softc *ahc);
d270 8
a277 8
STATIC void	ahc_loadseq(struct ahc_softc *ahc);
STATIC int	ahc_check_patch(struct ahc_softc *ahc,
		    struct patch **start_patch, int start_instr,
		    int *skip_addr);
STATIC void	ahc_download_instr(struct ahc_softc *ahc, int instrptr,
		    u_int8_t *dconsts);
STATIC int	ahc_match_scb(struct scb *scb, int target, char channel,
		    int lun, u_int tag, role_t role);
d279 1
a279 1
STATIC void	ahc_print_scb(struct scb *scb);
d281 18
a298 15
STATIC int	ahc_search_qinfifo(struct ahc_softc *ahc, int target,
		    char channel, int lun, u_int tag, role_t role,
		    u_int32_t status, ahc_search_action action);
STATIC int	ahc_reset_channel(struct ahc_softc *ahc, char channel,
		    int initiate_reset);
STATIC int	ahc_abort_scbs(struct ahc_softc *ahc, int target, char channel,
		    int lun, u_int tag, role_t role, u_int32_t status);
STATIC int	ahc_search_disc_list(struct ahc_softc *ahc, int target,
		    char channel, int lun, u_int tag, int stop_on_first,
		    int remove, int save_state);
STATIC u_int	ahc_rem_scb_from_disc_list(struct ahc_softc *ahc, u_int prev,
		    u_int scbptr);
STATIC void	ahc_add_curscb_to_free_list(struct ahc_softc *ahc);
STATIC void	ahc_clear_intstat(struct ahc_softc *ahc);
STATIC void	ahc_reset_current_bus(struct ahc_softc *ahc);
d300 1
a300 1
		ahc_devlimited_syncrate(struct ahc_softc *ahc, u_int *period);
d302 5
a306 5
		ahc_find_syncrate(struct ahc_softc *ahc, u_int *period,
		    u_int maxsync);
STATIC u_int ahc_find_period(struct ahc_softc *ahc, u_int scsirate,
		u_int maxsync);
STATIC void	ahc_validate_offset(struct ahc_softc *ahc,
d308 38
a345 33
					 u_int *offset, int wide); 
STATIC void	ahc_update_target_msg_request(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo,
		    struct ahc_initiator_tinfo *tinfo, int force, int paused);
STATIC void	ahc_set_syncrate(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, struct ahc_syncrate *syncrate,
		    u_int period, u_int offset, u_int type, int paused,
		    int done);
STATIC void	ahc_set_width(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, u_int width, u_int type,
		    int paused, int done);
STATIC void	ahc_set_tags(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo,int enable);
STATIC int      ahc_istagged_device(struct ahc_softc *ahc,
		    struct scsi_xfer *xs, int nocmdcheck);
STATIC void     ahc_check_tags(struct ahc_softc *ahc, struct scsi_xfer *xs);
STATIC void	ahc_construct_sdtr(struct ahc_softc *ahc, u_int period,
		    u_int offset);
STATIC void	ahc_construct_wdtr(struct ahc_softc *ahc, u_int bus_width);

STATIC void	ahc_calc_residual(struct scb *scb);

STATIC void	ahc_update_pending_syncrates(struct ahc_softc *ahc);

STATIC void	ahc_set_recoveryscb(struct ahc_softc *ahc, struct scb *scb);
STATIC void ahc_timeout(void *);

static __inline int  sequencer_paused(struct ahc_softc *ahc);
static __inline void pause_sequencer(struct ahc_softc *ahc);
static __inline void unpause_sequencer(struct ahc_softc *ahc);
STATIC void restart_sequencer(struct ahc_softc *ahc);
static __inline u_int ahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl,
		    int unbusy);
d347 7
a353 5
static __inline void	ahc_busy_tcl(struct ahc_softc *ahc, struct scb *scb);
static __inline int	ahc_isbusy_tcl(struct ahc_softc *ahc, struct scb *scb);
static __inline void ahc_freeze_ccb(struct scb* scb);
static __inline void ahcsetccbstatus(struct scsi_xfer *xs, int status);
STATIC void ahc_run_qoutfifo(struct ahc_softc *ahc);
d356 29
a384 25
	ahc_fetch_transinfo(struct ahc_softc *ahc, char channel, u_int our_id,
	    u_int target, struct tmode_tstate **tstate);
STATIC void ahcfreescb(struct ahc_softc *ahc, struct scb *scb);
static __inline struct scb *ahcgetscb(struct ahc_softc *ahc);
int    ahc_createdmamem(struct ahc_softc *ahc, int size, bus_dmamap_t *mapp,
	    caddr_t *vaddr, bus_addr_t *baddr, bus_dma_segment_t *segs,
	    int *nseg, const char *what);
STATIC void ahc_freedmamem(bus_dma_tag_t tag, int size, bus_dmamap_t map,
	    caddr_t vaddr, bus_dma_segment_t *seg, int nseg);
STATIC void ahcminphys(struct buf *bp);

STATIC INLINE	struct scsi_xfer *ahc_first_xs(struct ahc_softc *);
STATIC INLINE	void   ahc_list_insert_before(struct ahc_softc *ahc,
			    struct scsi_xfer *xs, struct scsi_xfer *next_xs);
STATIC INLINE	void   ahc_list_insert_head(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC INLINE	void   ahc_list_insert_tail(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC INLINE	void   ahc_list_remove(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC INLINE	struct scsi_xfer *ahc_list_next(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC int32_t ahc_scsi_cmd(struct scsi_xfer *xs);
static __inline void ahc_swap_hscb(struct hardware_scb *);
static __inline void ahc_swap_sg(struct ahc_dma_seg *);
d1496 1
d2426 1
a2426 1
			if ((scb->hscb->control & TAG_ENB) != 0)
d2663 1
a2663 1
	} else if ((scb->hscb->control & TAG_ENB) != 0) {
d2677 1
a2677 1
	 	scb->hscb->control &= ~TAG_ENB;
a3544 3
		if (((xs->flags & SCSI_POLL) != 0) &&
		    (xs->error == XS_NOERROR))
			ahc_check_tags(ahc, xs);
d3546 1
d3875 1
d4218 1
a4218 1
		scb->hscb->control |= TAG_ENB;
d5826 1
d5828 6
d5838 10
a5847 2
	if (ahc_istagged_device(ahc, xs, 1))
 		return;
d5849 28
a5876 26
	ahc_compile_devinfo(&devinfo,
	    SIM_SCSI_ID(ahc, xs->sc_link),
	    xs->sc_link->target,
	    xs->sc_link->lun,
	    SIM_CHANNEL(ahc, xs->sc_link),
	    ROLE_INITIATOR);

	ahc_set_tags(ahc, &devinfo, TRUE);

	printf("%s: target %d using tagged queuing\n",
	    ahc_name(ahc), xs->sc_link->target);

	if (ahc->scb_data->maxhscbs >= 16 ||
	    (ahc->flags & AHC_PAGESCBS)) {
		/* Default to 16 tags */
		xs->sc_link->openings += 14;
	} else {
		/*	
		 * Default to 4 tags on whimpy
		 * cards that don't have much SCB
		 * space and can't page.  This prevents
		 * a single device from hogging all
		 * slots.  We should really have a better
		 * way of providing fairness.
		 */
		xs->sc_link->openings += 2;
@


1.34.2.2
log
@sync to -current
@
text
@d2 5
a6 1
 * Core routines and tables shareable across OS platforms.
d8 1
a8 1
 * Copyright (c) 1994-2001 Justin T. Gibbs.
d21 1
a21 1
 * GNU Public License ("GPL").
d35 50
a84 1
 * $Id$
a85 2
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.80 2001/12/16 17:38:30 gibbs Exp $
 * $OpenBSD$
d88 20
a107 3
#ifdef __OpenBSD__
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
d109 17
d127 49
a175 4
#ifdef __FreeBSD__
#include <dev/aic7xxx/aic7xxx_freebsd.h>
#include <dev/aic7xxx/aic7xxx_inline.h>
#include <dev/aic7xxx/aicasm/aicasm_insformat.h>
a176 2
/****************************** Softc Data ************************************/
struct ahc_softc_tailq ahc_tailq = TAILQ_HEAD_INITIALIZER(ahc_tailq);
d178 17
a194 17
/***************************** Lookup Tables **********************************/
char *ahc_chip_names[] =
{
	"NONE",
	"aic7770",
	"aic7850",
	"aic7855",
	"aic7859",
	"aic7860",
	"aic7870",
	"aic7880",
	"aic7895",
	"aic7895C",
	"aic7890/91",
	"aic7896/97",
	"aic7892",
	"aic7899"
a195 1
static const u_int num_chip_names = NUM_ELEMENTS(ahc_chip_names);
d197 170
a366 6
/*
 * Hardware error codes.
 */
struct ahc_hard_error_entry {
        uint8_t errno;
	char *errmesg;
d369 6
a374 9
static struct ahc_hard_error_entry ahc_hard_errors[] = {
	{ ILLHADDR,	"Illegal Host Access" },
	{ ILLSADDR,	"Illegal Sequencer Address referrenced" },
	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
	{ SQPARERR,	"Sequencer Parity Error" },
	{ DPARERR,	"Data-path Parity Error" },
	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
	{ PCIERRSTAT,	"PCI Error detected" },
	{ CIOPARERR,	"CIOBUS Parity Error" },
a375 1
static const u_int num_errors = NUM_ELEMENTS(ahc_hard_errors);
d377 2
a378 1
static struct ahc_phase_table_entry ahc_phase_table[] =
d380 4
a383 10
	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
	{ P_DATAOUT_DT,	MSG_NOOP,		"in DT Data-out phase"	},
	{ P_DATAIN_DT,	MSG_INITIATOR_DET_ERR,	"in DT Data-in phase"	},
	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
	{ 0,		MSG_NOOP,		"in unknown phase"	}
d386 23
d410 5
a414 2
 * In most cases we only wish to itterate over real phases, so
 * exclude the last element from the count.
d416 13
a428 1
static const u_int num_phases = NUM_ELEMENTS(ahc_phase_table) - 1;
d430 5
a434 6
/*
 * Valid SCSIRATE values.  (p. 3-17)
 * Provides a mapping of tranfer periods in ns to the proper value to
 * stick in the scsixfer reg.
 */
static struct ahc_syncrate ahc_syncrates[] =
d436 2
a437 17
      /* ultra2    fast/ultra  period     rate */
	{ 0x42,      0x000,      9,      "80.0" },
	{ 0x03,      0x000,     10,      "40.0" },
	{ 0x04,      0x000,     11,      "33.0" },
	{ 0x05,      0x100,     12,      "20.0" },
	{ 0x06,      0x110,     15,      "16.0" },
	{ 0x07,      0x120,     18,      "13.4" },
	{ 0x08,      0x000,     25,      "10.0" },
	{ 0x19,      0x010,     31,      "8.0"  },
	{ 0x1a,      0x020,     37,      "6.67" },
	{ 0x1b,      0x030,     43,      "5.7"  },
	{ 0x1c,      0x040,     50,      "5.0"  },
	{ 0x00,      0x050,     56,      "4.4"  },
	{ 0x00,      0x060,     62,      "4.0"  },
	{ 0x00,      0x070,     68,      "3.6"  },
	{ 0x00,      0x000,      0,      NULL   }
};
d439 5
a443 6
/* Our Sequencer Program */
#ifdef __OpenBSD__
#include <dev/microcode/aic7xxx/aic7xxx_seq.h>
#else
#include "aic7xxx_seq.h"
#endif 
d445 7
a451 61
/**************************** Function Declarations ***************************/
static struct ahc_tmode_tstate*
			ahc_alloc_tstate(struct ahc_softc *ahc,
					 u_int scsi_id, char channel);
#ifdef AHC_TARGET_MODE
static void		ahc_free_tstate(struct ahc_softc *ahc,
					u_int scsi_id, char channel, int force);
#endif
static struct ahc_syncrate*
			ahc_devlimited_syncrate(struct ahc_softc *ahc,
					        struct ahc_initiator_tinfo *,
						u_int *period,
						u_int *ppr_options,
						role_t role);
static void		ahc_update_pending_scbs(struct ahc_softc *ahc);
static void		ahc_fetch_devinfo(struct ahc_softc *ahc,
					  struct ahc_devinfo *devinfo);
static void		ahc_scb_devinfo(struct ahc_softc *ahc,
					struct ahc_devinfo *devinfo,
					struct scb *scb);
static void		ahc_assert_atn(struct ahc_softc *ahc);
static void		ahc_setup_initiator_msgout(struct ahc_softc *ahc,
						   struct ahc_devinfo *devinfo,
						   struct scb *scb);
static void		ahc_build_transfer_msg(struct ahc_softc *ahc,
					       struct ahc_devinfo *devinfo);
static void		ahc_construct_sdtr(struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo,
					   u_int period, u_int offset);
static void		ahc_construct_wdtr(struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo,
					   u_int bus_width);
static void		ahc_construct_ppr(struct ahc_softc *ahc,
					  struct ahc_devinfo *devinfo,
					  u_int period, u_int offset,
					  u_int bus_width, u_int ppr_options);
static void		ahc_clear_msg_state(struct ahc_softc *ahc);
static void		ahc_handle_message_phase(struct ahc_softc *ahc);
typedef enum {
	AHCMSG_1B,
	AHCMSG_2B,
	AHCMSG_EXT
} ahc_msgtype;
static int		ahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type,
				     u_int msgval, int full);
static int		ahc_parse_msg(struct ahc_softc *ahc,
				      struct ahc_devinfo *devinfo);
static int		ahc_handle_msg_reject(struct ahc_softc *ahc,
					      struct ahc_devinfo *devinfo);
static void		ahc_handle_ign_wide_residue(struct ahc_softc *ahc,
						struct ahc_devinfo *devinfo);
static void		ahc_reinitialize_dataptrs(struct ahc_softc *ahc);
static void		ahc_handle_devreset(struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo,
					    cam_status status, char *message,
					    int verbose_level);
#if AHC_TARGET_MODE
static void		ahc_setup_target_msgin(struct ahc_softc *ahc,
					       struct ahc_devinfo *devinfo,
					       struct scb *scb);
#endif
d453 7
a459 10
#ifdef __OpenBSD__
int			ahc_init_scbdata(struct ahc_softc *ahc);
void			ahc_fini_scbdata(struct ahc_softc *ahc);
void			ahc_build_free_scb_list(struct ahc_softc *ahc);
#else
static bus_dmamap_callback_t	ahc_dmamap_cb;
static int		ahc_init_scbdata(struct ahc_softc *ahc);
static void		ahc_fini_scbdata(struct ahc_softc *ahc);
static void		ahc_build_free_scb_list(struct ahc_softc *ahc);
#endif 
a460 34
static void		ahc_qinfifo_requeue(struct ahc_softc *ahc,
					    struct scb *prev_scb,
					    struct scb *scb);
static int		ahc_qinfifo_count(struct ahc_softc *ahc);
static u_int		ahc_rem_scb_from_disc_list(struct ahc_softc *ahc,
						   u_int prev, u_int scbptr);
static void		ahc_add_curscb_to_free_list(struct ahc_softc *ahc);
static u_int		ahc_rem_wscb(struct ahc_softc *ahc,
				     u_int scbpos, u_int prev);
static int		ahc_abort_scbs(struct ahc_softc *ahc, int target,
				       char channel, int lun, u_int tag,
				       role_t role, uint32_t status);
static void		ahc_reset_current_bus(struct ahc_softc *ahc);
#ifdef AHC_DUMP_SEQ
static void		ahc_dumpseq(struct ahc_softc *ahc);
#endif
static void		ahc_loadseq(struct ahc_softc *ahc);
static int		ahc_check_patch(struct ahc_softc *ahc,
					struct patch **start_patch,
					u_int start_instr, u_int *skip_addr);
static void		ahc_download_instr(struct ahc_softc *ahc,
					   u_int instrptr, uint8_t *dconsts);
#ifdef AHC_TARGET_MODE
static void		ahc_queue_lstate_event(struct ahc_softc *ahc,
					       struct ahc_tmode_lstate *lstate,
					       u_int initiator_id,
					       u_int event_type,
					       u_int event_arg);
static void		ahc_update_scsiid(struct ahc_softc *ahc,
					  u_int targid_mask);
static int		ahc_handle_target_cmd(struct ahc_softc *ahc,
					      struct target_cmd *cmd);
#endif
/************************* Sequencer Execution Control ************************/
d464 35
a498 2
void
ahc_restart(struct ahc_softc *ahc)
d500 11
d512 9
a520 1
	ahc_pause(ahc);
d522 7
a528 3
	ahc_outb(ahc, SCSISIGO, 0);		/* De-assert BSY */
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);	/* No message to send */
	ahc_outb(ahc, SXFRCTL1, ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);
d530 7
a536 8
	/*
	 * Ensure that the sequencer's idea of TQINPOS
	 * matches our own.  The sequencer increments TQINPOS
	 * only after it sees a DMA complete and a reset could
	 * occur before the increment leaving the kernel to believe
	 * the command arrived but the sequencer to not.
	 */
	ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
d538 4
a541 8
	/* Always allow reselection */
	ahc_outb(ahc, SCSISEQ,
		 ahc_inb(ahc, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Ensure that no DMA operations are in progress */
		ahc_outb(ahc, CCSCBCNT, 0);
		ahc_outb(ahc, CCSGCTL, 0);
		ahc_outb(ahc, CCSCBCTL, 0);
d543 18
d562 4
a565 3
	 * If we were in the process of DMA'ing SCB data into
	 * an SCB, replace that SCB on the free list.  This prevents
	 * an SCB leak.
d567 4
a570 10
	if ((ahc_inb(ahc, SEQ_FLAGS2) & SCB_DMA) != 0) {
		ahc_add_curscb_to_free_list(ahc);
		ahc_outb(ahc, SEQ_FLAGS2,
			 ahc_inb(ahc, SEQ_FLAGS2) & ~SCB_DMA);
	}
	ahc_outb(ahc, MWI_RESIDUAL, 0);
	ahc_outb(ahc, SEQCTL, FASTMODE);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	ahc_unpause(ahc);
d573 3
a575 3
/************************* Input/Output Queues ********************************/
void
ahc_run_qoutfifo(struct ahc_softc *ahc)
d580 3
a582 1
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);
a583 1

d585 1
a585 2
		if ((ahc->qoutfifonext & 0x03) == 0x03) {
			u_int modnext;
d587 3
a589 18
			/*
			 * Clear 32bits of QOUTFIFO at a time
			 * so that we don't clobber an incoming
			 * byte DMA to the array on architectures
			 * that only support 32bit load and store
			 * operations.
			 */
			modnext = ahc->qoutfifonext & ~0x3;
			*((uint32_t *)(&ahc->qoutfifo[modnext])) = 0xFFFFFFFFUL;
			ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
					ahc->shared_data_dmamap,
					/*offset*/modnext, /*len*/4,
					BUS_DMASYNC_PREREAD);
		}
		ahc->qoutfifonext++;

		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
d601 4
a604 1
		ahc_update_residual(scb);
a608 4
void
ahc_run_untagged_queues(struct ahc_softc *ahc)
{
	int i;
d610 13
a622 3
	for (i = 0; i < 16; i++)
		ahc_run_untagged_queue(ahc, &ahc->untagged_queues[i]);
}
d624 4
a627 4
void
ahc_run_untagged_queue(struct ahc_softc *ahc, struct scb_tailq *queue)
{
	struct scb *scb;
d629 1
a629 2
	if (ahc->untagged_queue_lock != 0)
		return;
d631 4
a634 4
	if ((scb = TAILQ_FIRST(queue)) != NULL
	 && (scb->flags & SCB_ACTIVE) == 0) {
		scb->flags |= SCB_ACTIVE;
		ahc_queue_scb(ahc, scb);
d636 10
d648 9
a656 3
/************************* Interrupt Handling *********************************/
void
ahc_handle_brkadrint(struct ahc_softc *ahc)
d658 12
a669 6
	/*
	 * We upset the sequencer :-(
	 * Lookup the error message
	 */
	int i;
	int error;
d671 1
a671 14
	error = ahc_inb(ahc, ERROR);
	for (i = 0; error != 1 && i < num_errors; i++)
		error >>= 1;
	printf("%s: brkadrint, %s at seqaddr = 0x%x\n",
	       ahc_name(ahc), ahc_hard_errors[i].errmesg,
	       ahc_inb(ahc, SEQADDR0) |
	       (ahc_inb(ahc, SEQADDR1) << 8));

	ahc_dump_card_state(ahc);

	/* Tell everyone that this HBA is no longer availible */
	ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,
		       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,
		       CAM_NO_HBA);
d673 1
a673 2
	/* Disable all interrupt sources by resetting the controller */
	ahc_shutdown(ahc);
d676 17
a692 5
void
ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat)
{
	struct scb *scb;
	struct ahc_devinfo devinfo;
d694 50
a743 1
	ahc_fetch_devinfo(ahc, &devinfo);
d745 9
a753 12
	/*
	 * Clear the upper byte that holds SEQINT status
	 * codes and clear the SEQINT bit. We will unpause
	 * the sequencer, if appropriate, after servicing
	 * the request.
	 */
	ahc_outb(ahc, CLRINT, CLRSEQINT);
	switch (intstat & SEQINT_MASK) {
	case BAD_STATUS:
	{
		u_int  scb_index;
		struct hardware_scb *hscb;
d755 5
a759 6
		/*
		 * Set the default return value to 0 (don't
		 * send sense).  The sense code will change
		 * this if needed.
		 */
		ahc_outb(ahc, RETURN_1, 0);
d761 6
a766 20
		/*
		 * The sequencer will notify us when a command
		 * has an error that would be of interest to
		 * the kernel.  This allows us to leave the sequencer
		 * running in the common case of command completes
		 * without error.  The sequencer will already have
		 * dma'd the SCB back up to us, so we can reference
		 * the in kernel copy directly.
		 */
		scb_index = ahc_inb(ahc, SCB_TAG);
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("%s:%c:%d: ahc_intr - referenced scb "
			       "not valid during seqint 0x%x scb(%d)\n",
			       ahc_name(ahc), devinfo.channel,
			       devinfo.target, intstat, scb_index);
			ahc_dump_card_state(ahc);
			panic("for safety");
			goto unpause;
		}
d768 22
a789 1
		hscb = scb->hscb; 
d791 14
a804 39
		/* Don't want to clobber the original sense code */
		if ((scb->flags & SCB_SENSE) != 0) {
			/*
			 * Clear the SCB_SENSE Flag and have
			 * the sequencer do a normal command
			 * complete.
			 */
			scb->flags &= ~SCB_SENSE;
			ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
			break;
		}
		ahc_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
		/* Freeze the queue until the client sees the error. */
		ahc_freeze_devq(ahc, scb);
		ahc_freeze_scb(scb);
		ahc_set_scsi_status(scb, hscb->shared_data.status.scsi_status);
		switch (hscb->shared_data.status.scsi_status) {
		case SCSI_STATUS_OK:
			printf("%s: Interrupted for staus of 0???\n",
			       ahc_name(ahc));
			break;
		case SCSI_STATUS_CMD_TERMINATED:
		case SCSI_STATUS_CHECK_COND:
		{
			struct ahc_dma_seg *sg;
			struct scsi_sense *sc;
			struct ahc_initiator_tinfo *targ_info;
			struct ahc_tmode_tstate *tstate;
			struct ahc_transinfo *tinfo;
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				ahc_print_path(ahc, scb);
				printf("SCB %d: requests Check Status\n",
				       scb->hscb->tag);
			}
#endif
				
			if (ahc_perform_autosense(scb) == 0)
				break;
d806 15
a820 35
			targ_info = ahc_fetch_transinfo(ahc,
							devinfo.channel,
							devinfo.our_scsiid,
							devinfo.target,
							&tstate);
			tinfo = &targ_info->curr;
			sg = scb->sg_list;
			sc = (struct scsi_sense *)(&hscb->shared_data.cdb); 
			/*
			 * Save off the residual if there is one.
 			 */
			ahc_update_residual(scb);
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				ahc_print_path(ahc, scb);
				printf("Sending Sense\n");
			}
#endif
			sg->addr = ahc_get_sense_bufaddr(ahc, scb);
			sg->len = ahc_get_sense_bufsize(ahc, scb);
			sg->len |= AHC_DMA_LAST_SEG;
			
			/* Fixup byte order */
			sg->addr = ahc_htole32(sg->addr);
			sg->len = ahc_htole32(sg->len);

			sc->opcode = REQUEST_SENSE;
			sc->byte2 = 0;
			if (tinfo->protocol_version <= SCSI_REV_2
			 && SCB_GET_LUN(scb) < 8)
				sc->byte2 = SCB_GET_LUN(scb) << 5;
			sc->unused[0] = 0;
			sc->unused[1] = 0;
			sc->length = sg->len;
			sc->control = 0;
d822 27
a848 8
			/*
			 * We can't allow the target to disconnect.
			 * This will be an untagged transaction and
			 * having the target disconnect will make this
			 * transaction indestinguishable from outstanding
			 * tagged transactions.
			 */
			hscb->control = 0;
d850 15
a864 395
			/*
			 * This request sense could be because the
			 * the device lost power or in some other
			 * way has lost our transfer negotiations.
			 * Renegotiate if appropriate.  Unit attention
			 * errors will be reported before any data
			 * phases occur.
			 */
#ifdef __OpenBSD__
			if (ahc_get_transfer_length(scb) > 0 &&
			    ahc_get_residual(scb) == 
			    ahc_get_transfer_length(scb)) {
#else 
			if (ahc_get_residual(scb) 
			 == ahc_get_transfer_length(scb)) {
#endif
				ahc_update_neg_request(ahc, &devinfo,
						       tstate, targ_info,
						       /*force*/TRUE);
			}
			if (tstate->auto_negotiate & devinfo.target_mask) {
				hscb->control |= MK_MESSAGE;
				scb->flags &= ~SCB_NEGOTIATE;
				scb->flags |= SCB_AUTO_NEGOTIATE;
			}
			hscb->cdb_len = sizeof(*sc);
			hscb->dataptr = ahc_htole32(sg->addr); 
			hscb->datacnt = ahc_htole32(sg->len);
			hscb->sgptr = scb->sg_list_phys | SG_FULL_RESID;
			hscb->sgptr = ahc_htole32(hscb->sgptr);
			scb->sg_count = 1;
			scb->flags |= SCB_SENSE;
			ahc_qinfifo_requeue_tail(ahc, scb);
			ahc_outb(ahc, RETURN_1, SEND_SENSE);
#ifdef __OpenBSD__
			if (!(scb->io_ctx->flags & SCSI_POLL))
				timeout_add(&scb->io_ctx->stimeout, 5 * hz);
#endif 
#ifdef __FreeBSD__
			/*
			 * Ensure we have enough time to actually
			 * retrieve the sense.
			 */
			untimeout(ahc_timeout, (caddr_t)scb,
				  scb->io_ctx->ccb_h.timeout_ch);
			scb->io_ctx->ccb_h.timeout_ch =
			    timeout(ahc_timeout, (caddr_t)scb, 5 * hz);
#endif
			break;
		}
		default:
			break;
		}
		break;
	}
	case NO_MATCH:
	{
		/* Ensure we don't leave the selection hardware on */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));

		printf("%s:%c:%d: no active SCB for reconnecting "
		       "target - issuing BUS DEVICE RESET\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target);
		printf("SAVED_SCSIID == 0x%02x, SAVED_LUN == 0x%x, "
		       "ARG_1 == 0x%x ACCUM = 0x%x\n",
		       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),
		       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));
		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
		       "SINDEX == 0x%x\n",
		       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),
		       ahc_index_busy_tcl(ahc,
			    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),
				      ahc_inb(ahc, SAVED_LUN))),
		       ahc_inb(ahc, SINDEX));
		printf("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
		       "SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",
		       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),
		       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),
		       ahc_inb(ahc, SCB_CONTROL));
		printf("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",
		       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));
		printf("SXFRCTL0 == 0x%x\n", ahc_inb(ahc, SXFRCTL0));
		printf("SEQCTL == 0x%x\n", ahc_inb(ahc, SEQCTL));
		ahc_dump_card_state(ahc);
		ahc->msgout_buf[0] = MSG_BUS_DEV_RESET;
		ahc->msgout_len = 1;
		ahc->msgout_index = 0;
		ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		ahc_assert_atn(ahc);
		break;
	}
	case SEND_REJECT: 
	{
		u_int rejbyte = ahc_inb(ahc, ACCUM);
		printf("%s:%c:%d: Warning - unknown message received from "
		       "target (0x%x).  Rejecting\n", 
		       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);
		break; 
	}
	case NO_IDENT: 
	{
		/*
		 * The reconnecting target either did not send an identify
		 * message, or did, but we didn't find an SCB to match and
		 * before it could respond to our ATN/abort, it hit a dataphase.
		 * The only safe thing to do is to blow it away with a bus
		 * reset.
		 */
		int found;

		printf("%s:%c:%d: Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x, SAVED_SCSIID == 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_SCSIID));
		found = ahc_reset_channel(ahc, devinfo.channel, 
					  /*initiate reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), devinfo.channel,
		       found);
		return;
	}
	case IGN_WIDE_RES:
		ahc_handle_ign_wide_residue(ahc, &devinfo);
		break;
	case PDATA_REINIT:
		ahc_reinitialize_dataptrs(ahc);
		break;
	case BAD_PHASE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		printf("%s:%c:%d: unknown scsi bus phase %x, "
		       "lastphase = 0x%x.  Attempting to continue\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       lastphase, ahc_inb(ahc, SCSISIGI));
		break;
	}
	case MISSED_BUSFREE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		printf("%s:%c:%d: Missed busfree. "
		       "Lastphase = 0x%x, Curphase = 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       lastphase, ahc_inb(ahc, SCSISIGI));
		ahc_restart(ahc);
		return;
	}
	case HOST_MSG_LOOP:
	{
		/*
		 * The sequencer has encountered a message phase
		 * that requires host assistance for completion.
		 * While handling the message phase(s), we will be
		 * notified by the sequencer after each byte is
		 * transfered so we can track bus phase changes.
		 *
		 * If this is the first time we've seen a HOST_MSG_LOOP
		 * interrupt, initialize the state of the host message
		 * loop.
		 */
		if (ahc->msg_type == MSG_TYPE_NONE) {
			struct scb *scb;
			u_int scb_index;
			u_int bus_phase;

			bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			if (bus_phase != P_MESGIN
			 && bus_phase != P_MESGOUT) {
				printf("ahc_intr: HOST_MSG_LOOP bad "
				       "phase 0x%x\n",
				      bus_phase);
				/*
				 * Probably transitioned to bus free before
				 * we got here.  Just punt the message.
				 */
				ahc_clear_intstat(ahc);
				ahc_restart(ahc);
				return;
			}

			scb_index = ahc_inb(ahc, SCB_TAG);
			scb = ahc_lookup_scb(ahc, scb_index);
			if (devinfo.role == ROLE_INITIATOR) {
				if (scb == NULL)
					panic("HOST_MSG_LOOP with "
					      "invalid SCB %x", scb_index);

				if (bus_phase == P_MESGOUT)
					ahc_setup_initiator_msgout(ahc,
								   &devinfo,
								   scb);
				else {
					ahc->msg_type =
					    MSG_TYPE_INITIATOR_MSGIN;
					ahc->msgin_index = 0;
				}
			} else {
				if (bus_phase == P_MESGOUT) {
					ahc->msg_type =
					    MSG_TYPE_TARGET_MSGOUT;
					ahc->msgin_index = 0;
				}
#if AHC_TARGET_MODE
				else 
					ahc_setup_target_msgin(ahc,
							       &devinfo,
							       scb);
#endif
			}
		}

		ahc_handle_message_phase(ahc);
		break;
	}
	case PERR_DETECTED:
	{
		/*
		 * If we've cleared the parity error interrupt
		 * but the sequencer still believes that SCSIPERR
		 * is true, it must be that the parity error is
		 * for the currently presented byte on the bus,
		 * and we are not in a phase (data-in) where we will
		 * eventually ack this byte.  Ack the byte and
		 * throw it away in the hope that the target will
		 * take us to message out to deliver the appropriate
		 * error message.
		 */
		if ((intstat & SCSIINT) == 0
		 && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {

			if ((ahc->features & AHC_DT) == 0) {
				u_int curphase;

				/*
				 * The hardware will only let you ack bytes
				 * if the expected phase in SCSISIGO matches
				 * the current phase.  Make sure this is
				 * currently the case.
				 */
				curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
				ahc_outb(ahc, LASTPHASE, curphase);
				ahc_outb(ahc, SCSISIGO, curphase);
			}
			ahc_inb(ahc, SCSIDATL);
		}
		break;
	}
	case DATA_OVERRUN:
	{
		/*
		 * When the sequencer detects an overrun, it
		 * places the controller in "BITBUCKET" mode
		 * and allows the target to complete its transfer.
		 * Unfortunately, none of the counters get updated
		 * when the controller is in this mode, so we have
		 * no way of knowing how large the overrun was.
		 */
		u_int scbindex = ahc_inb(ahc, SCB_TAG);
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		u_int i;

		scb = ahc_lookup_scb(ahc, scbindex);
		for (i = 0; i < num_phases; i++) {
			if (lastphase == ahc_phase_table[i].phase)
				break;
		}
		ahc_print_path(ahc, scb);
		printf("data overrun detected %s."
		       "  Tag == 0x%x.\n",
		       ahc_phase_table[i].phasemsg,
  		       scb->hscb->tag);
		ahc_print_path(ahc, scb);
		printf("%s seen Data Phase.  Length = %ld.  NumSGs = %d.\n",
		       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
		       ahc_get_transfer_length(scb), scb->sg_count);
		if (scb->sg_count > 0) {
			for (i = 0; i < scb->sg_count; i++) {

				printf("sg[%d] - Addr 0x%x%x : Length %d\n",
				       i,
				       (ahc_le32toh(scb->sg_list[i].len) >> 24
				        & SG_HIGH_ADDR_BITS),
				       ahc_le32toh(scb->sg_list[i].addr),
				       ahc_le32toh(scb->sg_list[i].len)
				       & AHC_SG_LEN_MASK);
			}
		}
		/*
		 * Set this and it will take effect when the
		 * target does a command complete.
		 */
		ahc_freeze_devq(ahc, scb);
		ahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);
		ahc_freeze_scb(scb);

		if ((ahc->features & AHC_ULTRA2) != 0) {
			/*
			 * Clear the channel in case we return
			 * to data phase later.
			 */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);
		}
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			u_int dscommand1;

			/* Ensure HHADDR is 0 for future DMA operations. */
			dscommand1 = ahc_inb(ahc, DSCOMMAND1);
			ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
			ahc_outb(ahc, HADDR, 0);
			ahc_outb(ahc, DSCOMMAND1, dscommand1);
		}
		break;
	}
	case MKMSG_FAILED:
	{
		u_int scbindex;

		printf("%s:%c:%d:%d: Attempt to issue message failed\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       devinfo.lun);
		scbindex = ahc_inb(ahc, SCB_TAG);
		scb = ahc_lookup_scb(ahc, scbindex);
		if (scb != NULL
		 && (scb->flags & SCB_RECOVERY_SCB) != 0)
			/*
			 * Ensure that we didn't put a second instance of this
			 * SCB into the QINFIFO.
			 */
			ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
					   SCB_GET_CHANNEL(ahc, scb),
					   SCB_GET_LUN(scb), scb->hscb->tag,
					   ROLE_INITIATOR, /*status*/0,
					   SEARCH_REMOVE);
		break;
	}
	case NO_FREE_SCB:
	{
		printf("%s: No free or disconnected SCBs\n", ahc_name(ahc));
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	case SCB_MISMATCH:
	{
		u_int scbptr;

		scbptr = ahc_inb(ahc, SCBPTR);
		printf("Bogus TAG after DMA.  SCBPTR %d, tag %d, our tag %d\n",
		       scbptr, ahc_inb(ahc, ARG_1),
		       ahc->scb_data->hscbs[scbptr].tag);
		ahc_dump_card_state(ahc);
		panic("for saftey");
		break;
	}
	case OUT_OF_RANGE:
	{
		printf("%s: BTT calculation out of range\n", ahc_name(ahc));
		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
		       "ARG_1 == 0x%x ACCUM = 0x%x\n",
		       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),
		       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));
		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
		       "SINDEX == 0x%x\n, A == 0x%x\n",
		       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),
		       ahc_index_busy_tcl(ahc,
			    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),
				      ahc_inb(ahc, SAVED_LUN))),
		       ahc_inb(ahc, SINDEX),
		       ahc_inb(ahc, ACCUM));
		printf("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
		       "SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",
		       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),
		       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),
		       ahc_inb(ahc, SCB_CONTROL));
		printf("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",
		       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	default:
		printf("ahc_intr: seqint, "
		       "intstat == 0x%x, scsisigi = 0x%x\n",
		       intstat, ahc_inb(ahc, SCSISIGI));
		break;
	}
unpause:
d866 1
a866 3
	 *  The sequencer is paused immediately on
	 *  a SEQINT, so we should restart it when
	 *  we're done.
d868 15
a882 1
	ahc_unpause(ahc);
d886 2
a887 1
ahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat)
d889 12
a900 6
	u_int	scb_index;
	u_int	status0;
	u_int	status;
	struct	scb *scb;
	char	cur_channel;
	char	intr_channel;
d902 10
a911 2
	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);
d913 7
a919 6
	if ((ahc->features & AHC_TWIN) != 0
	 && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
		cur_channel = 'B';
	else
		cur_channel = 'A';
	intr_channel = cur_channel;
d921 1
a921 20
	if ((ahc->features & AHC_ULTRA2) != 0)
		status0 = ahc_inb(ahc, SSTAT0) & IOERR;
	else
		status0 = 0;
	status = ahc_inb(ahc, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
	if (status == 0 && status0 == 0) {
		if ((ahc->features & AHC_TWIN) != 0) {
			/* Try the other channel */
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			status = ahc_inb(ahc, SSTAT1)
			       & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
			intr_channel = (cur_channel == 'A') ? 'B' : 'A';
		}
		if (status == 0) {
			printf("%s: Spurious SCSI interrupt\n", ahc_name(ahc));
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
			ahc_unpause(ahc);
			return;
		}
	}
d923 5
a927 5
	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	if (scb != NULL
	 && (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)
		scb = NULL;
d929 2
a930 44
	if ((ahc->features & AHC_ULTRA2) != 0
	 && (status0 & IOERR) != 0) {
		int now_lvd;

		now_lvd = ahc_inb(ahc, SBLKCTL) & ENAB40;
		printf("%s: Transceiver State Has Changed to %s mode\n",
		       ahc_name(ahc), now_lvd ? "LVD" : "SE");
		ahc_outb(ahc, CLRSINT0, CLRIOERR);
		/*
		 * When transitioning to SE mode, the reset line
		 * glitches, triggering an arbitration bug in some
		 * Ultra2 controllers.  This bug is cleared when we
		 * assert the reset line.  Since a reset glitch has
		 * already occurred with this transition and a
		 * transceiver state change is handled just like
		 * a bus reset anyway, asserting the reset line
		 * ourselves is safe.
		 */
		ahc_reset_channel(ahc, intr_channel,
				 /*Initiate Reset*/now_lvd == 0);
	} else if ((status & SCSIRSTI) != 0) {
		printf("%s: Someone reset channel %c\n",
			ahc_name(ahc), intr_channel);
		if (intr_channel != cur_channel)
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
		ahc_reset_channel(ahc, intr_channel, /*Initiate Reset*/FALSE);
	} else if ((status & SCSIPERR) != 0) {
		/*
		 * Determine the bus phase and queue an appropriate message.
		 * SCSIPERR is latched true as soon as a parity error
		 * occurs.  If the sequencer acked the transfer that
		 * caused the parity error and the currently presented
		 * transfer on the bus has correct parity, SCSIPERR will
		 * be cleared by CLRSCSIPERR.  Use this to determine if
		 * we should look at the last phase the sequencer recorded,
		 * or the current phase presented on the bus.
		 */
		u_int mesg_out;
		u_int curphase;
		u_int errorphase;
		u_int lastphase;
		u_int scsirate;
		u_int i;
		u_int sstat2;
d932 2
a933 20
		lastphase = ahc_inb(ahc, LASTPHASE);
		curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
		sstat2 = ahc_inb(ahc, SSTAT2);
		ahc_outb(ahc, CLRSINT1, CLRSCSIPERR);
		/*
		 * For all phases save DATA, the sequencer won't
		 * automatically ack a byte that has a parity error
		 * in it.  So the only way that the current phase
		 * could be 'data-in' is if the parity error is for
		 * an already acked byte in the data phase.  During
		 * synchronous data-in transfers, we may actually
		 * ack bytes before latching the current phase in
		 * LASTPHASE, leading to the discrepancy between
		 * curphase and lastphase.
		 */
		if ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0
		 || curphase == P_DATAIN || curphase == P_DATAIN_DT)
			errorphase = curphase;
		else
			errorphase = lastphase;
d935 3
a937 16
		for (i = 0; i < num_phases; i++) {
			if (errorphase == ahc_phase_table[i].phase)
				break;
		}
		mesg_out = ahc_phase_table[i].mesg_out;
		if (scb != NULL)
			ahc_print_path(ahc, scb);
		else
			printf("%s:%c:%d: ", ahc_name(ahc), intr_channel,
			       SCSIID_TARGET(ahc, ahc_inb(ahc, SAVED_SCSIID)));
		scsirate = ahc_inb(ahc, SCSIRATE);
		printf("parity error detected %s. "
		       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
		       ahc_phase_table[i].phasemsg,
		       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),
		       scsirate);
d939 3
a941 84
		if ((ahc->features & AHC_DT) != 0) {

			if ((sstat2 & CRCVALERR) != 0)
				printf("\tCRC Value Mismatch\n");
			if ((sstat2 & CRCENDERR) != 0)
				printf("\tNo terminal CRC packet recevied\n");
			if ((sstat2 & CRCREQERR) != 0)
				printf("\tIllegal CRC packet request\n");
			if ((sstat2 & DUAL_EDGE_ERR) != 0)
				printf("\tUnexpected %sDT Data Phase\n",
				       (scsirate & SINGLE_EDGE) ? "" : "non-");
		}

		/*
		 * We've set the hardware to assert ATN if we   
		 * get a parity error on "in" phases, so all we  
		 * need to do is stuff the message buffer with
		 * the appropriate message.  "In" phases have set
		 * mesg_out to something other than MSG_NOP.
		 */
		if (mesg_out != MSG_NOOP) {
			if (ahc->msg_type != MSG_TYPE_NONE)
				ahc->send_msg_perror = TRUE;
			else
				ahc_outb(ahc, MSG_OUT, mesg_out);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_unpause(ahc);
	} else if ((status & SELTO) != 0) {
		u_int scbptr;

		/* Stop the selection */
		ahc_outb(ahc, SCSISEQ, 0);

		/* No more pending messages */
		ahc_clear_msg_state(ahc);

		/* Clear interrupt state */
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);

		/*
		 * Although the driver does not care about the
		 * 'Selection in Progress' status bit, the busy
		 * LED does.  SELINGO is only cleared by a sucessfull
		 * selection, so we must manually clear it to insure
		 * the LED turns off just incase no future successful
		 * selections occur (e.g. no devices on the bus).
		 */
		ahc_outb(ahc, CLRSINT0, CLRSELINGO);

		scbptr = ahc_inb(ahc, WAITING_SCBH);
		ahc_outb(ahc, SCBPTR, scbptr);
		scb_index = ahc_inb(ahc, SCB_TAG);

		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("%s: ahc_intr - referenced scb not "
			       "valid during SELTO scb(%d, %d)\n",
			       ahc_name(ahc), scbptr, scb_index);
		} else {
			ahc_set_transaction_status(scb, CAM_SEL_TIMEOUT);
			ahc_freeze_devq(ahc, scb);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_restart(ahc);
	} else if ((status & BUSFREE) != 0
		&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {
		u_int lastphase;
		u_int saved_scsiid;
		u_int saved_lun;
		u_int target;
		u_int initiator_role_id;
		char channel;
		int printerror;

		/*
		 * Clear our selection hardware as soon as possible.
		 * We may have an entry in the waiting Q for this target,
		 * that is affected by this busfree and we don't want to
		 * go about selecting the target while we handle the event.
		 */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
d943 3
a945 8
		/*
		 * Disable busfree interrupts and clear the busfree
		 * interrupt status.  We do this here so that several
		 * bus transactions occur prior to clearing the SCSIINT
		 * latch.  It can take a bit for the clearing to take effect.
		 */
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);
d947 1
a947 13
		/*
		 * Look at what phase we were last in.
		 * If its message out, chances are pretty good
		 * that the busfree was in response to one of
		 * our abort requests.
		 */
		lastphase = ahc_inb(ahc, LASTPHASE);
		saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
		saved_lun = ahc_inb(ahc, SAVED_LUN);
		target = SCSIID_TARGET(ahc, saved_scsiid);
		initiator_role_id = SCSIID_OUR_ID(saved_scsiid);
		channel = SCSIID_CHANNEL(ahc, saved_scsiid);
		printerror = 1;
d949 2
a950 3
		if (lastphase == P_MESGOUT) {
			struct ahc_devinfo devinfo;
			u_int tag;
d952 9
a960 49
			ahc_fetch_devinfo(ahc, &devinfo);
			tag = SCB_LIST_NULL;
			if (ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT_TAG, TRUE)
			 || ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT, TRUE)) {
				if (ahc->msgout_buf[ahc->msgout_index - 1]
				 == MSG_ABORT_TAG)
					tag = scb->hscb->tag;
				ahc_print_path(ahc, scb);
				printf("SCB %d - Abort%s Completed.\n",
				       scb->hscb->tag, tag == SCB_LIST_NULL ?
				       "" : " Tag");
				ahc_abort_scbs(ahc, target, channel,
					       saved_lun, tag,
					       ROLE_INITIATOR,
					       CAM_REQ_ABORTED);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_1B,
						MSG_BUS_DEV_RESET, TRUE)) {
				struct ahc_devinfo devinfo;
#ifdef __FreeBSD__
				/*
				 * Don't mark the user's request for this BDR
				 * as completing with CAM_BDR_SENT.  CAM3
				 * specifies CAM_REQ_CMP.
				 */
				if (scb != NULL
				 && scb->io_ctx->ccb_h.func_code== XPT_RESET_DEV
				 && ahc_match_scb(ahc, scb, target, channel,
						  CAM_LUN_WILDCARD,
						  SCB_LIST_NULL,
						  ROLE_INITIATOR)) {
					ahc_set_transaction_status(scb, CAM_REQ_CMP);
				}
#endif
				ahc_compile_devinfo(&devinfo,
						    initiator_role_id,
						    target,
						    CAM_LUN_WILDCARD,
						    channel,
						    ROLE_INITIATOR);
				ahc_handle_devreset(ahc, &devinfo,
						    CAM_BDR_SENT,
						    "Bus Device Reset",
						    /*verbose_level*/0);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_PPR, FALSE)) {
				struct ahc_initiator_tinfo *tinfo;
				struct ahc_tmode_tstate *tstate;
d962 6
a967 38
				/*
				 * PPR Rejected.  Try non-ppr negotiation
				 * and retry command.
				 */
				tinfo = ahc_fetch_transinfo(ahc,
							    devinfo.channel,
							    devinfo.our_scsiid,
							    devinfo.target,
							    &tstate);
				tinfo->curr.transport_version = 2;
				tinfo->goal.transport_version = 2;
				tinfo->goal.ppr_options = 0;
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_WDTR, FALSE)
				|| ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_SDTR, FALSE)) {
				/*
				 * Negotiation Rejected.  Go-async and
				 * retry command.
				 */
				ahc_set_width(ahc, &devinfo,
					      MSG_EXT_WDTR_BUS_8_BIT,
					      AHC_TRANS_CUR|AHC_TRANS_GOAL,
					      /*paused*/TRUE);
				ahc_set_syncrate(ahc, &devinfo,
						/*syncrate*/NULL,
						/*period*/0, /*offset*/0,
						/*ppr_options*/0,
						AHC_TRANS_CUR|AHC_TRANS_GOAL,
						/*paused*/TRUE);
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			}
		}
		if (printerror != 0) {
			u_int i;
d969 1
a969 2
			if (scb != NULL) {
				u_int tag;
d971 6
a976 35
				if ((scb->hscb->control & TAG_ENB) != 0)
					tag = scb->hscb->tag;
				else
					tag = SCB_LIST_NULL;
				ahc_print_path(ahc, scb);
				ahc_abort_scbs(ahc, target, channel,
					       SCB_GET_LUN(scb), tag,
					       ROLE_INITIATOR,
					       CAM_UNEXP_BUSFREE);
			} else {
				/*
				 * We had not fully identified this connection,
				 * so we cannot abort anything.
				 */
				printf("%s: ", ahc_name(ahc));
			}
			for (i = 0; i < num_phases; i++) {
				if (lastphase == ahc_phase_table[i].phase)
					break;
			}
			printf("Unexpected busfree %s\n"
			       "SEQADDR == 0x%x\n",
			       ahc_phase_table[i].phasemsg,
			       ahc_inb(ahc, SEQADDR0)
				| (ahc_inb(ahc, SEQADDR1) << 8));
		}
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_restart(ahc);
	} else {
		printf("%s: Missing case in ahc_handle_scsiint. status = %x\n",
		       ahc_name(ahc), status);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
	}
}
d978 1
a978 8
#define AHC_MAX_STEPS 2000
void
ahc_clear_critical_section(struct ahc_softc *ahc)
{
	int	stepping;
	int	steps;
	u_int	simode0;
	u_int	simode1;
d980 3
a982 2
	if (ahc->num_critical_sections == 0)
		return;
d984 6
a989 25
	stepping = FALSE;
	steps = 0;
	simode0 = 0;
	simode1 = 0;
	for (;;) {
		struct	cs *cs;
		u_int	seqaddr;
		u_int	i;

		seqaddr = ahc_inb(ahc, SEQADDR0)
			| (ahc_inb(ahc, SEQADDR1) << 8);

		/*
		 * Seqaddr represents the next instruction to execute, 
		 * so we are really executing the instruction just
		 * before it.
		 */
		if (seqaddr != 0)
			seqaddr -= 1;
		cs = ahc->critical_sections;
		for (i = 0; i < ahc->num_critical_sections; i++, cs++) {
			
			if (cs->begin < seqaddr && cs->end >= seqaddr)
				break;
		}
d991 1
a991 2
		if (i == ahc->num_critical_sections)
			break;
d993 4
a996 6
		if (steps > AHC_MAX_STEPS) {
			printf("%s: Infinite loop in critical section\n",
			       ahc_name(ahc));
			ahc_dump_card_state(ahc);
			panic("critical section loop");
		}
d998 1
a998 2
		steps++;
		if (stepping == FALSE) {
d1000 1
a1000 24
			/*
			 * Disable all interrupt sources so that the
			 * sequencer will not be stuck by a pausing
			 * interrupt condition while we attempt to
			 * leave a critical section.
			 */
			simode0 = ahc_inb(ahc, SIMODE0);
			ahc_outb(ahc, SIMODE0, 0);
			simode1 = ahc_inb(ahc, SIMODE1);
			ahc_outb(ahc, SIMODE1, 0);
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
			ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) | STEP);
			stepping = TRUE;
		}
		ahc_outb(ahc, HCNTRL, ahc->unpause);
		do {
			ahc_delay(200);
		} while (!ahc_is_paused(ahc));
	}
	if (stepping) {
		ahc_outb(ahc, SIMODE0, simode0);
		ahc_outb(ahc, SIMODE1, simode1);
		ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) & ~STEP);
	}
d1003 3
a1005 5
/*
 * Clear any pending interrupt status.
 */
void
ahc_clear_intstat(struct ahc_softc *ahc)
d1007 1
a1007 7
	/* Clear any interrupt conditions this may have caused */
	ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
				|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|
				CLRREQINIT);
	ahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);
	ahc_outb(ahc, CLRINT, CLRSCSIINT);
}
d1009 1
a1009 5
/**************************** Debugging Routines ******************************/
void
ahc_print_scb(struct scb *scb)
{
	int i;
d1011 5
a1015 1
	struct hardware_scb *hscb = scb->hscb;
d1017 6
a1022 22
	printf("scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n",
	       (void *)scb,
	       hscb->control,
	       hscb->scsiid,
	       hscb->lun,
	       hscb->cdb_len);
	printf("Shared Data: ");
	for (i = 0; i < sizeof(hscb->shared_data.cdb); i++)
		printf("%#02x", hscb->shared_data.cdb[i]);
	printf("        dataptr:%#x datacnt:%#x sgptr:%#x tag:%#x\n",
		ahc_le32toh(hscb->dataptr),
		ahc_le32toh(hscb->datacnt),
		ahc_le32toh(hscb->sgptr),
		hscb->tag);
	if (scb->sg_count > 0) {
		for (i = 0; i < scb->sg_count; i++) {
			printf("sg[%d] - Addr 0x%x%x : Length %d\n",
			       i,
			       (ahc_le32toh(scb->sg_list[i].len) >> 24
			        & SG_HIGH_ADDR_BITS),
			       ahc_le32toh(scb->sg_list[i].addr),
			       ahc_le32toh(scb->sg_list[i].len));
d1025 16
d1043 5
a1047 7
/************************* Transfer Negotiation *******************************/
/*
 * Allocate per target mode instance (ID we respond to as a target)
 * transfer negotiation data structures.
 */
static struct ahc_tmode_tstate *
ahc_alloc_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel)
d1049 2
a1050 3
	struct ahc_tmode_tstate *master_tstate;
	struct ahc_tmode_tstate *tstate;
	int i;
d1052 5
a1056 12
	master_tstate = ahc->enabled_targets[ahc->our_id];
	if (channel == 'B') {
		scsi_id += 8;
		master_tstate = ahc->enabled_targets[ahc->our_id_b + 8];
	}
	if (ahc->enabled_targets[scsi_id] != NULL
	 && ahc->enabled_targets[scsi_id] != master_tstate)
		panic("%s: ahc_alloc_tstate - Target already allocated",
		      ahc_name(ahc));
	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
	if (tstate == NULL)
		return (NULL);
d1058 1
d1060 1
a1060 4
	 * If we have allocated a master tstate, copy user settings from
	 * the master tstate (taken from SRAM or the EEPROM) for this
	 * channel, but reset our current and goal settings to async/narrow
	 * until an initiator talks to us.
d1062 8
a1069 14
	if (master_tstate != NULL) {
		memcpy(tstate, master_tstate, sizeof(*tstate));
		memset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));
		tstate->ultraenb = 0;
		for (i = 0; i < 16; i++) {
			memset(&tstate->transinfo[i].curr, 0,
			      sizeof(tstate->transinfo[i].curr));
			memset(&tstate->transinfo[i].goal, 0,
			      sizeof(tstate->transinfo[i].goal));
		}
	} else
		memset(tstate, 0, sizeof(*tstate));
	ahc->enabled_targets[scsi_id] = tstate;
	return (tstate);
d1072 3
a1074 7
#ifdef AHC_TARGET_MODE
/*
 * Free per target mode instance (ID we respond to as a target)
 * transfer negotiation data structures.
 */
static void
ahc_free_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel, int force)
d1076 8
a1083 2
	struct ahc_tmode_tstate *tstate;

d1085 1
a1085 2
	 * Don't clean up our "master" tstate.
	 * It has our default user settings.
d1087 10
a1096 4
	if (((channel == 'B' && scsi_id == ahc->our_id_b)
	  || (channel == 'A' && scsi_id == ahc->our_id))
	 && force == FALSE)
		return;
d1098 22
a1119 6
	if (channel == 'B')
		scsi_id += 8;
	tstate = ahc->enabled_targets[scsi_id];
	if (tstate != NULL)
		free(tstate, M_DEVBUF);
	ahc->enabled_targets[scsi_id] = NULL;
a1120 1
#endif
d1125 1
a1125 2
 * by the capabilities of the bus connectivity of and sync settings for
 * the target.
d1127 5
a1131 5
struct ahc_syncrate *
ahc_devlimited_syncrate(struct ahc_softc *ahc,
			struct ahc_initiator_tinfo *tinfo,
			u_int *period, u_int *ppr_options, role_t role) {
	struct	ahc_transinfo *transinfo;
d1137 1
a1137 1
			maxsync = AHC_SYNCRATE_DT;
a1139 2
			/* Can't do DT on an SE bus */
			*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1146 1
a1146 22
	/*
	 * Never allow a value higher than our current goal
	 * period otherwise we may allow a target initiated
	 * negotiation to go above the limit as set by the
	 * user.  In the case of an initiator initiated
	 * sync negotiation, we limit based on the user
	 * setting.  This allows the system to still accept
	 * incoming negotiations even if target initiated
	 * negotiation is not performed.
	 */
	if (role == ROLE_TARGET)
		transinfo = &tinfo->user;
	else 
		transinfo = &tinfo->goal;
	*ppr_options &= transinfo->ppr_options;
	if (transinfo->period == 0) {
		*period = 0;
		*ppr_options = 0;
		return (NULL);
	}
	*period = MAX(*period, transinfo->period);
	return (ahc_find_syncrate(ahc, period, ppr_options, maxsync));
d1154 5
a1158 3
struct ahc_syncrate *
ahc_find_syncrate(struct ahc_softc *ahc, u_int *period,
		  u_int *ppr_options, u_int maxsync)
d1162 4
a1165 19
	if ((ahc->features & AHC_DT) == 0)
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;

	/* Skip all DT only entries if DT is not available */
	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0
	 && maxsync < AHC_SYNCRATE_ULTRA2)
		maxsync = AHC_SYNCRATE_ULTRA2;
	
	for (syncrate = &ahc_syncrates[maxsync];
	     syncrate->rate != NULL;
	     syncrate++) {

		/*
		 * The Ultra2 table doesn't go as low
		 * as for the Fast/Ultra cards.
		 */
		if ((ahc->features & AHC_ULTRA2) != 0
		 && (syncrate->sxfr_u2 == 0))
			break;
a1180 7

			/*
			 * At some speeds, we only support
			 * ST transfers.
			 */
		 	if ((syncrate->sxfr_u2 & ST_SXFR) != 0)
				*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1183 1
a1192 1
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1197 5
a1201 6
/*
 * Convert from an entry in our syncrate table to the SCSI equivalent
 * sync "period" factor.
 */
u_int
ahc_find_period(struct ahc_softc *ahc, u_int scsirate, u_int maxsync)
d1226 6
a1231 9
/*
 * Truncate the given synchronous offset to a value the
 * current adapter type and syncrate are capable of.
 */
void
ahc_validate_offset(struct ahc_softc *ahc,
		    struct ahc_initiator_tinfo *tinfo,
		    struct ahc_syncrate *syncrate,
		    u_int *offset, int wide, role_t role)
a1246 6
	if (tinfo != NULL) {
		if (role == ROLE_TARGET)
			*offset = MIN(*offset, tinfo->user.offset);
		else
			*offset = MIN(*offset, tinfo->goal.offset);
	}
d1249 7
a1255 7
/*
 * Truncate the given transfer width parameter to a value the
 * current adapter type is capable of.
 */
void
ahc_validate_width(struct ahc_softc *ahc, struct ahc_initiator_tinfo *tinfo,
		   u_int *bus_width, role_t role)
d1257 1
a1257 19
	switch (*bus_width) {
	default:
		if (ahc->features & AHC_WIDE) {
			/* Respond Wide */
			*bus_width = MSG_EXT_WDTR_BUS_16_BIT;
			break;
		}
		/* FALLTHROUGH */
	case MSG_EXT_WDTR_BUS_8_BIT:
		*bus_width = MSG_EXT_WDTR_BUS_8_BIT;
		break;
	}
	if (tinfo != NULL) {
		if (role == ROLE_TARGET)
			*bus_width = MIN(tinfo->user.width, *bus_width);
		else
			*bus_width = MIN(tinfo->goal.width, *bus_width);
	}
}
d1259 7
a1265 23
/*
 * Update the bitmask of targets for which the controller should
 * negotiate with at the next convenient oportunity.  This currently
 * means the next time we send the initial identify messages for
 * a new transaction.
 */
int
ahc_update_neg_request(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		       struct ahc_tmode_tstate *tstate,
		       struct ahc_initiator_tinfo *tinfo, int force)
{
	u_int auto_negotiate_orig;

	auto_negotiate_orig = tstate->auto_negotiate;
	if (tinfo->curr.period != tinfo->goal.period
	 || tinfo->curr.width != tinfo->goal.width
	 || tinfo->curr.offset != tinfo->goal.offset
	 || tinfo->curr.ppr_options != tinfo->goal.ppr_options
	 || (force
	  && (tinfo->goal.period != 0
	   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT
	   || tinfo->goal.ppr_options != 0)))
		tstate->auto_negotiate |= devinfo->target_mask;
d1267 22
a1288 1
		tstate->auto_negotiate &= ~devinfo->target_mask;
d1290 4
a1293 1
	return (auto_negotiate_orig != tstate->auto_negotiate);
d1296 10
a1305 12
/*
 * Update the user/goal/curr tables of synchronous negotiation
 * parameters as well as, in the case of a current or active update,
 * any data structures on the host controller.  In the case of an
 * active update, the specified target is currently talking to us on
 * the bus, so the transfer parameter update must take effect
 * immediately.
 */
void
ahc_set_syncrate(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		 struct ahc_syncrate *syncrate, u_int period,
		 u_int offset, u_int ppr_options, u_int type, int paused)
d1308 1
a1308 1
	struct	ahc_tmode_tstate *tstate;
d1311 1
a1311 6
	u_int	old_ppr;
	int	active;
	int	update_needed;

	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
	update_needed = 0;
d1318 2
a1319 1
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
d1321 2
a1322 16

	if ((type & AHC_TRANS_USER) != 0) {
		tinfo->user.period = period;
		tinfo->user.offset = offset;
		tinfo->user.ppr_options = ppr_options;
	}

	if ((type & AHC_TRANS_GOAL) != 0) {
		tinfo->goal.period = period;
		tinfo->goal.offset = offset;
		tinfo->goal.ppr_options = ppr_options;
	}

	old_period = tinfo->curr.period;
	old_offset = tinfo->curr.offset;
	old_ppr	   = tinfo->curr.ppr_options;
d1325 1
a1325 3
	 && (old_period != period
	  || old_offset != offset
	  || old_ppr != ppr_options)) {
a1327 1
		update_needed++;
d1331 2
d1334 5
a1338 7
			if (syncrate != NULL) {
				scsirate |= syncrate->sxfr_u2;
				if ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0)
					scsirate |= ENABLE_CRC;
				else
					scsirate |= SINGLE_EDGE;
			}
d1365 1
a1365 1
		if (active) {
a1366 3
			if ((ahc->features & AHC_ULTRA2) != 0)
				ahc_outb(ahc, SCSIOFFSET, offset);
		}
d1369 20
a1388 18
		tinfo->curr.period = period;
		tinfo->curr.offset = offset;
		tinfo->curr.ppr_options = ppr_options;

		ahc_send_async(ahc, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (1 /*bootverbose*/) {
			if (offset != 0) {
				printf("%s: target %d synchronous at %sMHz%s, "
				       "offset = 0x%x\n", ahc_name(ahc),
				       devinfo->target, syncrate->rate,
				       (ppr_options & MSG_EXT_PPR_DT_REQ)
				       ? " DT" : "", offset);
			} else {
				printf("%s: target %d using "
				       "asynchronous transfers\n",
				       ahc_name(ahc), devinfo->target);
			}
d1392 9
a1400 2
	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
						tinfo, /*force*/FALSE);
d1402 3
a1404 2
	if (update_needed)
		ahc_update_pending_scbs(ahc);
d1407 8
a1414 11
/*
 * Update the user/goal/curr tables of wide negotiation
 * parameters as well as, in the case of a current or active update,
 * any data structures on the host controller.  In the case of an
 * active update, the specified target is currently talking to us on
 * the bus, so the transfer parameter update must take effect
 * immediately.
 */
void
ahc_set_width(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
	      u_int width, u_int type, int paused)
d1416 4
a1419 5
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	u_int	oldwidth;
	int	active;
	int	update_needed;
d1421 5
a1425 7
	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
	update_needed = 0;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);

	if ((type & AHC_TRANS_USER) != 0)
		tinfo->user.width = width;
a1426 4
	if ((type & AHC_TRANS_GOAL) != 0)
		tinfo->goal.width = width;

	oldwidth = tinfo->curr.width;
a1429 1
		update_needed++;
d1440 1
a1440 9
		tinfo->curr.width = width;

		ahc_send_async(ahc, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (bootverbose) {
			printf("%s: target %d using %dbit transfers\n",
			       ahc_name(ahc), devinfo->target,
			       8 * (0x01 << width));
		}
d1443 4
a1446 61
	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
						tinfo, /*force*/FALSE);
	if (update_needed)
		ahc_update_pending_scbs(ahc);
}

/*
 * Update the current state of tagged queuing for a given target.
 */
void
ahc_set_tags(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
	     ahc_queue_alg alg)
{
 	ahc_platform_set_tags(ahc, devinfo, alg);
 	ahc_send_async(ahc, devinfo->channel, devinfo->target,
 		       devinfo->lun, AC_TRANSFER_NEG, &alg);
}

/*
 * When the transfer settings for a connection change, update any
 * in-transit SCBs to contain the new data so the hardware will
 * be set correctly during future (re)selections.
 */
static void
ahc_update_pending_scbs(struct ahc_softc *ahc)
{
	struct	scb *pending_scb;
	int	pending_scb_count;
	int	i;
	int	paused;
	u_int	saved_scbptr;

	/*
	 * Traverse the pending SCB list and ensure that all of the
	 * SCBs there have the proper settings.
	 */
	pending_scb_count = 0;
	LIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {
		struct ahc_devinfo devinfo;
		struct hardware_scb *pending_hscb;
		struct ahc_initiator_tinfo *tinfo;
		struct ahc_tmode_tstate *tstate;

		ahc_scb_devinfo(ahc, &devinfo, pending_scb);
		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
					    devinfo.our_scsiid,
					    devinfo.target, &tstate);
		pending_hscb = pending_scb->hscb;
		pending_hscb->control &= ~ULTRAENB;
		if ((tstate->ultraenb & devinfo.target_mask) != 0)
			pending_hscb->control |= ULTRAENB;
		pending_hscb->scsirate = tinfo->scsirate;
		pending_hscb->scsioffset = tinfo->curr.offset;
		if ((tstate->auto_negotiate & devinfo.target_mask) == 0
		 && (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {
			pending_scb->flags &= ~SCB_AUTO_NEGOTIATE;
			pending_hscb->control &= ~MK_MESSAGE;
		}
		ahc_sync_scb(ahc, pending_scb,
			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
		pending_scb_count++;
d1449 4
a1452 32
	if (pending_scb_count == 0)
		return;

	if (ahc_is_paused(ahc)) {
		paused = 1;
	} else {
		paused = 0;
		ahc_pause(ahc);
	}

	saved_scbptr = ahc_inb(ahc, SCBPTR);
	/* Ensure that the hscbs down on the card match the new information */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		struct	hardware_scb *pending_hscb;
		u_int	control;
		u_int	scb_tag;

		ahc_outb(ahc, SCBPTR, i);
		scb_tag = ahc_inb(ahc, SCB_TAG);
		pending_scb = ahc_lookup_scb(ahc, scb_tag);
		if (pending_scb == NULL)
			continue;

		pending_hscb = pending_scb->hscb;
		control = ahc_inb(ahc, SCB_CONTROL);
		control &= ~(ULTRAENB|MK_MESSAGE);
		control |= pending_hscb->control & (ULTRAENB|MK_MESSAGE);
		ahc_outb(ahc, SCB_CONTROL, control);
		ahc_outb(ahc, SCB_SCSIRATE, pending_hscb->scsirate);
		ahc_outb(ahc, SCB_SCSIOFFSET, pending_hscb->scsioffset);
	}
	ahc_outb(ahc, SCBPTR, saved_scbptr);
d1454 2
a1455 2
	if (paused == 0)
		ahc_unpause(ahc);
d1458 5
a1462 3
/**************************** Pathing Information *****************************/
static void
ahc_fetch_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
d1464 2
a1465 3
	u_int	saved_scsiid;
	role_t	role;
	int	our_id;
d1467 8
a1474 38
	if (ahc_inb(ahc, SSTAT0) & TARGET)
		role = ROLE_TARGET;
	else
		role = ROLE_INITIATOR;

	if (role == ROLE_TARGET
	 && (ahc->features & AHC_MULTI_TID) != 0
	 && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
		/* We were selected, so pull our id from TARGIDIN */
		our_id = ahc_inb(ahc, TARGIDIN) & OID;
	} else if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;

	saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
	ahc_compile_devinfo(devinfo,
			    our_id,
			    SCSIID_TARGET(ahc, saved_scsiid),
			    ahc_inb(ahc, SAVED_LUN),
			    SCSIID_CHANNEL(ahc, saved_scsiid),
			    role);
}

struct ahc_phase_table_entry*
ahc_lookup_phase_entry(int phase)
{
	struct ahc_phase_table_entry *entry;
	struct ahc_phase_table_entry *last_entry;

	/*
	 * num_phases doesn't include the default entry which
	 * will be returned if the phase doesn't match.
	 */
	last_entry = &ahc_phase_table[num_phases];
	for (entry = ahc_phase_table; entry < last_entry; entry++) {
		if (phase == entry->phase)
			break;
a1475 44
	return (entry);
}

void
ahc_compile_devinfo(struct ahc_devinfo *devinfo, u_int our_id, u_int target,
		    u_int lun, char channel, role_t role)
{
	devinfo->our_scsiid = our_id;
	devinfo->target = target;
	devinfo->lun = lun;
	devinfo->target_offset = target;
	devinfo->channel = channel;
	devinfo->role = role;
	if (channel == 'B')
		devinfo->target_offset += 8;
	devinfo->target_mask = (0x01 << devinfo->target_offset);
}

static void
ahc_scb_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		struct scb *scb)
{
	role_t	role;
	int	our_id;

	our_id = SCSIID_OUR_ID(scb->hscb->scsiid);
	role = ROLE_INITIATOR;
	if ((scb->hscb->control & TARGET_SCB) != 0)
		role = ROLE_TARGET;
	ahc_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahc, scb),
			    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahc, scb), role);
}


/************************ Message Phase Processing ****************************/
static void
ahc_assert_atn(struct ahc_softc *ahc)
{
	u_int scsisigo;

	scsisigo = ATNO;
	if ((ahc->features & AHC_DT) == 0)
		scsisigo |= ahc_inb(ahc, SCSISIGI);
	ahc_outb(ahc, SCSISIGO, scsisigo);
d1479 1
a1479 4
 * When an initiator transaction with the MK_MESSAGE flag either reconnects
 * or enters the initial message out phase, we are interrupted.  Fill our
 * outgoing message buffer with the appropriate message and beging handing
 * the message phase(s) manually.
d1481 3
a1483 3
static void
ahc_setup_initiator_msgout(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
			   struct scb *scb)
a1484 68
	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if ((scb->flags & SCB_DEVICE_RESET) == 0
	 && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {
		u_int identify_msg;

		identify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);
		if ((scb->hscb->control & DISCENB) != 0)
			identify_msg |= MSG_IDENTIFY_DISCFLAG;
		ahc->msgout_buf[ahc->msgout_index++] = identify_msg;
		ahc->msgout_len++;

		if ((scb->hscb->control & TAG_ENB) != 0) {
			ahc->msgout_buf[ahc->msgout_index++] =
			    scb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);
			ahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;
			ahc->msgout_len += 2;
		}
	}

	if (scb->flags & SCB_DEVICE_RESET) {
		ahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;
		ahc->msgout_len++;
		ahc_print_path(ahc, scb);
		printf("Bus Device Reset Message Sent\n");
		/*
		 * Clear our selection hardware in advance of
		 * the busfree.  We may have an entry in the waiting
		 * Q for this target, and we don't want to go about
		 * selecting while we handle the busfree and blow it
		 * away.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else if ((scb->flags & SCB_ABORT) != 0) {
		if ((scb->hscb->control & TAG_ENB) != 0)
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;
		else
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;
		ahc->msgout_len++;
		ahc_print_path(ahc, scb);
		printf("Abort%s Message Sent\n",
		       (scb->hscb->control & TAG_ENB) != 0 ? " Tag" : "");
		/*
		 * Clear our selection hardware in advance of
		 * the busfree.  We may have an entry in the waiting
		 * Q for this target, and we don't want to go about
		 * selecting while we handle the busfree and blow it
		 * away.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {
		ahc_build_transfer_msg(ahc, devinfo);
	} else {
		printf("ahc_intr: AWAITING_MSG for an SCB that "
		       "does not have a waiting message\n");
		printf("SCSIID = %x, target_mask = %x\n", scb->hscb->scsiid,
		       devinfo->target_mask);
		panic("SCB = %d, SCB Control = %x, MSG_OUT = %x "
		      "SCB flags = %x", scb->hscb->tag, scb->hscb->control,
		      ahc_inb(ahc, MSG_OUT), scb->flags);
	}

d1486 1
a1486 2
	 * Clear the MK_MESSAGE flag from the SCB so we aren't
	 * asked to send this message again.
d1488 1
a1488 28
	ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);
	scb->hscb->control &= ~MK_MESSAGE;
	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
}

/*
 * Build an appropriate transfer negotiation message for the
 * currently active target.
 */
static void
ahc_build_transfer_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	/*              
	 * We need to initiate transfer negotiations.
	 * If our current and goal settings are identical,
	 * we want to renegotiate due to a check condition.
	 */             
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	struct	ahc_syncrate *rate;
	int	dowide;
	int	dosync;
	int	doppr;
	int	use_ppr;
	u_int	period;
	u_int	ppr_options;
	u_int	offset;
d1490 4
a1493 2
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
d1495 17
a1511 25
	 * Filter our period based on the current connection.
	 * If we can't perform DT transfers on this segment (not in LVD
	 * mode for instance), then our decision to issue a PPR message
	 * may change.
	 */
	period = tinfo->goal.period;
	ppr_options = tinfo->goal.ppr_options;
	/* Target initiated PPR is not allowed in the SCSI spec */
	if (devinfo->role == ROLE_TARGET)
		ppr_options = 0;
	rate = ahc_devlimited_syncrate(ahc, tinfo, &period,
				       &ppr_options, devinfo->role);
	dowide = tinfo->curr.width != tinfo->goal.width;
	dosync = tinfo->curr.period != period;
	doppr = tinfo->curr.ppr_options != ppr_options;

	if (!dowide && !dosync && !doppr) {
		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
		dosync = tinfo->goal.period != 0;
		doppr = tinfo->goal.ppr_options != 0;
	}

	if (!dowide && !dosync && !doppr) {
		panic("ahc_intr: AWAITING_MSG for negotiation, "
		      "but no negotiation needed");	
a1513 5
	use_ppr = (tinfo->curr.transport_version >= 3) || doppr;
	/* Target initiated PPR is not allowed in the SCSI spec */
	if (devinfo->role == ROLE_TARGET)
		use_ppr = 0;

d1515 1
a1515 6
	 * Both the PPR message and SDTR message require the
	 * goal syncrate to be limited to what the target device
	 * is capable of handling (based on whether an LVD->SE
	 * expander is on the bus), so combine these two cases.
	 * Regardless, guarantee that if we are using WDTR and SDTR
	 * messages that WDTR comes first.
d1517 3
a1519 1
	if (use_ppr || (dosync && !dowide)) {
d1521 3
a1523 11
		offset = tinfo->goal.offset;
		ahc_validate_offset(ahc, tinfo, rate, &offset,
				    use_ppr ? tinfo->goal.width
					    : tinfo->curr.width,
				    devinfo->role);
		if (use_ppr) {
			ahc_construct_ppr(ahc, devinfo, period, offset,
					  tinfo->goal.width, ppr_options);
		} else {
			ahc_construct_sdtr(ahc, devinfo, period, offset);
		}
d1525 9
a1533 1
		ahc_construct_wdtr(ahc, devinfo, tinfo->goal.width);
d1535 1
d1538 4
a1541 7
/*
 * Build a synchronous negotiation message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_sdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		   u_int period, u_int offset)
d1543 23
a1565 11
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_len += 5;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       devinfo->lun, period, offset);
	}
d1568 8
a1575 7
/*
 * Build a wide negotiateion message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_wdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		   u_int bus_width)
d1577 9
a1585 10
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_len += 4;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending WDTR %x\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       devinfo->lun, bus_width);
	}
d1589 1
a1589 2
 * Build a parallel protocol request message in our message
 * buffer based on the input parameters.
d1591 2
a1592 4
static void
ahc_construct_ppr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		  u_int period, u_int offset, u_int bus_width,
		  u_int ppr_options)
d1594 77
a1670 14
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = 0;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_buf[ahc->msgout_index++] = ppr_options;
	ahc->msgout_len += 8;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "
		       "offset %x, ppr_options %x\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target, devinfo->lun,
		       bus_width, period, offset, ppr_options);
d1672 29
d1703 4
a1706 5
/*
 * Clear any active message state.
 */
static void
ahc_clear_msg_state(struct ahc_softc *ahc)
d1708 49
a1756 4
	ahc->msgout_len = 0;
	ahc->msgin_index = 0;
	ahc->msg_type = MSG_TYPE_NONE;
	if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0) {
d1758 5
a1762 2
		 * The target didn't care to respond to our
		 * message request, so clear ATN.
d1764 31
a1794 1
		ahc_outb(ahc, CLRSINT1, CLRATNO);
d1796 80
a1875 2
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
}
d1877 10
a1886 9
/*
 * Manual message loop handler.
 */
static void
ahc_handle_message_phase(struct ahc_softc *ahc)
{ 
	struct	ahc_devinfo devinfo;
	u_int	bus_phase;
	int	end_session;
d1888 6
a1893 3
	ahc_fetch_devinfo(ahc, &devinfo);
	end_session = FALSE;
	bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
d1895 5
a1899 7
reswitch:
	switch (ahc->msg_type) {
	case MSG_TYPE_INITIATOR_MSGOUT:
	{
		int lastbyte;
		int phasemis;
		int msgdone;
d1901 48
a1948 2
		if (ahc->msgout_len == 0)
			panic("HOST_MSG_LOOP interrupt with no active message");
a1949 3
		phasemis = bus_phase != P_MESGOUT;
		if (phasemis) {
			if (bus_phase == P_MESGIN) {
d1951 2
a1952 4
				 * Change gears and see if
				 * this messages is of interest to
				 * us or should be passed back to
				 * the sequencer.
d1954 2
a1955 5
				ahc_outb(ahc, CLRSINT1, CLRATNO);
				ahc->send_msg_perror = FALSE;
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;
				ahc->msgin_index = 0;
				goto reswitch;
a1956 8
			end_session = TRUE;
			break;
		}

		if (ahc->send_msg_perror) {
			ahc_outb(ahc, CLRSINT1, CLRATNO);
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
			ahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);
d1958 1
a1958 4
		}

		msgdone	= ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
d1960 2
a1961 3
			 * The target has requested a retry.
			 * Re-assert ATN, reset our message index to
			 * 0, and try again.
d1963 3
a1965 2
			ahc->msgout_index = 0;
			ahc_assert_atn(ahc);
a1966 13

		lastbyte = ahc->msgout_index == (ahc->msgout_len - 1);
		if (lastbyte) {
			/* Last byte is signified by dropping ATN */
			ahc_outb(ahc, CLRSINT1, CLRATNO);
		}

		/*
		 * Clear our interrupt status and present
		 * the next byte on the bus.
		 */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
d1969 12
a1980 1
	case MSG_TYPE_INITIATOR_MSGIN:
d1982 12
a1993 2
		int phasemis;
		int message_done;
d1995 12
a2006 10
		phasemis = bus_phase != P_MESGIN;

		if (phasemis) {
			ahc->msgin_index = 0;
			if (bus_phase == P_MESGOUT
			 && (ahc->send_msg_perror == TRUE
			  || (ahc->msgout_len != 0
			   && ahc->msgout_index == 0))) {
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
				goto reswitch;
a2007 3
			end_session = TRUE;
			break;
		}
d2009 3
a2011 2
		/* Pull the byte in without acking it */
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);
d2013 2
a2014 1
		message_done = ahc_parse_msg(ahc, &devinfo);
d2016 19
a2034 16
		if (message_done) {
			/*
			 * Clear our incoming message buffer in case there
			 * is another message following this one.
			 */
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response,
			 * assert ATN so the target takes us to the
			 * message out phase.
			 */
			if (ahc->msgout_len != 0)
				ahc_assert_atn(ahc);
		} else 
			ahc->msgin_index++;
d2036 2
a2037 3
		/* Ack the byte */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_inb(ahc, SCSIDATL);
d2040 1
a2040 1
	case MSG_TYPE_TARGET_MSGIN:
a2041 6
		int msgdone;
		int msgout_request;

		if (ahc->msgout_len == 0)
			panic("Target MSGIN with no active message");

d2043 9
a2051 4
		 * If we interrupted a mesgout session, the initiator
		 * will not know this until our first REQ.  So, we
		 * only honor mesgout requests after we've sent our
		 * first byte.
d2053 3
a2055 7
		if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0
		 && ahc->msgout_index > 0)
			msgout_request = TRUE;
		else
			msgout_request = FALSE;

		if (msgout_request) {
d2058 4
a2061 4
			 * Change gears and see if
			 * this messages is of interest to
			 * us or should be passed back to
			 * the sequencer.
d2063 3
a2065 4
			ahc->msg_type = MSG_TYPE_TARGET_MSGOUT;
			ahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);
			ahc->msgin_index = 0;
			/* Dummy read to REQ for first byte */
a2066 3
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
			break;
a2067 14

		msgdone = ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
			end_session = TRUE;
			break;
		}

		/*
		 * Present the next byte on the bus.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
d2070 1
a2070 1
	case MSG_TYPE_TARGET_MSGOUT:
a2071 3
		int lastbyte;
		int msgdone;

d2073 6
a2078 2
		 * The initiator signals that this is
		 * the last byte by dropping ATN.
d2080 3
a2082 1
		lastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;
d2084 4
a2087 16
		/*
		 * Read the latched byte, but turn off SPIOEN first
		 * so that we don't inadvertantly cause a REQ for the
		 * next byte.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);
		msgdone = ahc_parse_msg(ahc, &devinfo);
		if (msgdone == MSGLOOP_TERMINATED) {
			/*
			 * The message is *really* done in that it caused
			 * us to go to bus free.  The sequencer has already
			 * been reset at this point, so pull the ejection
			 * handle.
			 */
			return;
d2089 15
a2103 21
		
		ahc->msgin_index++;

		/*
		 * XXX Read spec about initiator dropping ATN too soon
		 *     and use msgdone to detect it.
		 */
		if (msgdone == MSGLOOP_MSGCOMPLETE) {
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response, transition
			 * to the Message in phase and send it.
			 */
			if (ahc->msgout_len != 0) {
				ahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);
				ahc_outb(ahc, SXFRCTL0,
					 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
				ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
				ahc->msgin_index = 0;
				break;
d2106 32
a2137 9

		if (lastbyte)
			end_session = TRUE;
		else {
			/* Ask for the next byte. */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		}

d2140 7
d2148 4
a2151 1
		panic("Unknown REQINIT message type");
d2153 8
a2160 6

	if (end_session) {
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);
	} else
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
d2163 4
a2166 8
/*
 * See if we sent a particular extended message to the target.
 * If "full" is true, return true only if the target saw the full
 * message.  If "full" is false, return true if the target saw at
 * least the first byte of the message.
 */
static int
ahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type, u_int msgval, int full)
d2168 12
a2179 2
	int found;
	u_int index;
d2181 14
a2194 2
	found = FALSE;
	index = 0;
d2196 8
a2203 3
	while (index < ahc->msgout_len) {
		if (ahc->msgout_buf[index] == MSG_EXTENDED) {
			u_int end_index;
d2205 20
a2224 3
			end_index = index + 1 + ahc->msgout_buf[index + 1];
			if (ahc->msgout_buf[index+2] == msgval
			 && type == AHCMSG_EXT) {
d2226 19
a2244 9
				if (full) {
					if (ahc->msgout_index > end_index)
						found = TRUE;
				} else if (ahc->msgout_index > index)
					found = TRUE;
			}
			index = end_index;
		} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_TASK
			&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
d2246 3
a2248 9
			/* Skip tag type and tag id or residue param*/
			index += 2;
		} else {
			/* Single byte message */
			if (type == AHCMSG_1B
			 && ahc->msgout_buf[index] == msgval
			 && ahc->msgout_index > index)
				found = TRUE;
			index++;
d2250 13
d2264 29
a2292 5
		if (found)
			break;
	}
	return (found);
}
d2294 5
a2298 12
/*
 * Wait for a complete incoming message, parse it, and respond accordingly.
 */
static int
ahc_parse_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	int	reject;
	int	done;
	int	response;
	u_int	targ_scsirate;
d2300 16
a2315 41
	done = MSGLOOP_IN_PROG;
	response = FALSE;
	reject = FALSE;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	targ_scsirate = tinfo->scsirate;

	/*
	 * Parse as much of the message as is availible,
	 * rejecting it if we don't support it.  When
	 * the entire message is availible and has been
	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
	 * that we have parsed an entire message.
	 *
	 * In the case of extended messages, we accept the length
	 * byte outright and perform more checking once we know the
	 * extended message type.
	 */
	switch (ahc->msgin_buf[0]) {
	case MSG_MESSAGE_REJECT:
		response = ahc_handle_msg_reject(ahc, devinfo);
		/* FALLTHROUGH */
	case MSG_NOOP:
		done = MSGLOOP_MSGCOMPLETE;
		break;
	case MSG_EXTENDED:
	{
		/* Wait for enough of the message to begin validation */
		if (ahc->msgin_index < 2)
			break;
		switch (ahc->msgin_buf[2]) {
		case MSG_EXT_SDTR:
		{
			struct	 ahc_syncrate *syncrate;
			u_int	 period;
			u_int	 ppr_options;
			u_int	 offset;
			u_int	 saved_offset;
			
			if (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
				reject = TRUE;
d2317 3
a2319 1
			}
d2321 7
a2327 44
			/*
			 * Wait until we have both args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_SDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))
				break;

			period = ahc->msgin_buf[3];
			ppr_options = 0;
			saved_offset = offset = ahc->msgin_buf[4];
			syncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,
							   &ppr_options,
							   devinfo->role);
			ahc_validate_offset(ahc, tinfo, syncrate, &offset,
					    targ_scsirate & WIDEXFER,
					    devinfo->role);
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received "
				       "SDTR period %x, offset %x\n\t"
				       "Filtered to period %x, offset %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       ahc->msgin_buf[3], saved_offset,
				       period, offset);
			}
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period,
					 offset, ppr_options,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE);

			/*
			 * See if we initiated Sync Negotiation
			 * and didn't have to fall down to async
			 * transfers.
			 */
			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, TRUE)) {
				/* We started it */
				if (saved_offset != offset) {
					/* Went too low - force async */
					reject = TRUE;
d2329 11
a2339 30
			} else {
				/*
				 * Send our own SDTR in reply
				 */
				if (bootverbose
				 && devinfo->role == ROLE_INITIATOR) {
					printf("(%s:%c:%d:%d): Target "
					       "Initiated SDTR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_sdtr(ahc, devinfo,
						   period, offset);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		case MSG_EXT_WDTR:
		{
			u_int bus_width;
			u_int saved_width;
			u_int sending_reply;

			sending_reply = FALSE;
			if (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
				reject = TRUE;
d2342 1
a2342 9

			/*
			 * Wait until we have our arg before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_WDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))
d2344 4
d2349 2
a2350 11
			bus_width = ahc->msgin_buf[3];
			saved_width = bus_width;
			ahc_validate_width(ahc, tinfo, &bus_width,
					   devinfo->role);
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received WDTR "
				       "%x filtered to %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       saved_width, bus_width);
			}
d2352 9
a2360 16
			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, TRUE)) {
				/*
				 * Don't send a WDTR back to the
				 * target, since we asked first.
				 * If the width went higher than our
				 * request, reject it.
				 */
				if (saved_width > bus_width) {
					reject = TRUE;
					printf("(%s:%c:%d:%d): requested %dBit "
					       "transfers.  Rejecting...\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun,
					       8 * (0x01 << bus_width));
					bus_width = 0;
				}
d2363 2
a2364 1
				 * Send our own WDTR in reply
d2366 1
a2366 13
				if (bootverbose
				 && devinfo->role == ROLE_INITIATOR) {
					printf("(%s:%c:%d:%d): Target "
					       "Initiated WDTR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_wdtr(ahc, devinfo, bus_width);
				ahc->msgout_index = 0;
				response = TRUE;
				sending_reply = TRUE;
d2368 3
a2370 17
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE);
			/* After a wide message, we are async */
			ahc_set_syncrate(ahc, devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, /*ppr_options*/0,
					 AHC_TRANS_ACTIVE, /*paused*/TRUE);
			if (sending_reply == FALSE && reject == FALSE) {

				if (tinfo->goal.period) {
					ahc->msgout_index = 0;
					ahc->msgout_len = 0;
					ahc_build_transfer_msg(ahc, devinfo);
					ahc->msgout_index = 0;
					response = TRUE;
				}
d2372 4
a2375 2
			done = MSGLOOP_MSGCOMPLETE;
			break;
d2377 7
a2383 10
		case MSG_EXT_PPR:
		{
			struct	ahc_syncrate *syncrate;
			u_int	period;
			u_int	offset;
			u_int	bus_width;
			u_int	ppr_options;
			u_int	saved_width;
			u_int	saved_offset;
			u_int	saved_ppr_options;
d2385 3
a2387 4
			if (ahc->msgin_buf[1] != MSG_EXT_PPR_LEN) {
				reject = TRUE;
				break;
			}
d2389 6
a2394 9
			/*
			 * Wait until we have all args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_PPR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_PPR_LEN + 1))
				break;
d2396 6
a2401 15
			period = ahc->msgin_buf[3];
			offset = ahc->msgin_buf[5];
			bus_width = ahc->msgin_buf[6];
			saved_width = bus_width;
			ppr_options = ahc->msgin_buf[7];
			/*
			 * According to the spec, a DT only
			 * period factor with no DT option
			 * set implies async.
			 */
			if ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0
			 && period == 9)
				offset = 0;
			saved_ppr_options = ppr_options;
			saved_offset = offset;
d2403 3
a2405 17
			/*
			 * Mask out any options we don't support
			 * on any controller.  Transfer options are
			 * only available if we are negotiating wide.
			 */
			ppr_options &= MSG_EXT_PPR_DT_REQ;
			if (bus_width == 0)
				ppr_options = 0;

			ahc_validate_width(ahc, tinfo, &bus_width,
					   devinfo->role);
			syncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,
							   &ppr_options,
							   devinfo->role);
			ahc_validate_offset(ahc, tinfo, syncrate,
					    &offset, bus_width,
					    devinfo->role);
d2407 3
a2409 55
			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, TRUE)) {
				/*
				 * If we are unable to do any of the
				 * requested options (we went too low),
				 * then we'll have to reject the message.
				 */
				if (saved_width > bus_width
				 || saved_offset != offset
				 || saved_ppr_options != ppr_options) {
					reject = TRUE;
					period = 0;
					offset = 0;
					bus_width = 0;
					ppr_options = 0;
					syncrate = NULL;
				}
			} else {
				if (devinfo->role != ROLE_TARGET)
					printf("(%s:%c:%d:%d): Target "
					       "Initiated PPR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				else
					printf("(%s:%c:%d:%d): Initiator "
					       "Initiated PPR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_ppr(ahc, devinfo, period, offset,
						  bus_width, ppr_options);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received PPR width %x, "
				       "period %x, offset %x,options %x\n"
				       "\tFiltered to width %x, period %x, "
				       "offset %x, options %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       saved_width, ahc->msgin_buf[3],
				       saved_offset, saved_ppr_options,
				       bus_width, period, offset, ppr_options);
			}
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE);
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period,
					 offset, ppr_options,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE);
			done = MSGLOOP_MSGCOMPLETE;
			break;
d2411 103
a2513 4
		default:
			/* Unknown extended message.  Reject it. */
			reject = TRUE;
			break;
a2514 1
		break;
a2515 23
	case MSG_BUS_DEV_RESET:
		ahc_handle_devreset(ahc, devinfo,
				    CAM_BDR_SENT,
				    "Bus Device Reset Received",
				    /*verbose_level*/0);
		ahc_restart(ahc);
		done = MSGLOOP_TERMINATED;
		break;
	case MSG_ABORT_TAG:
	case MSG_ABORT:
	case MSG_CLEAR_QUEUE:
#ifdef AHC_TARGET_MODE
		/* Target mode messages */
		if (devinfo->role != ROLE_TARGET) {
			reject = TRUE;
			break;
		}
		ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       devinfo->lun,
			       ahc->msgin_buf[0] == MSG_ABORT_TAG
						  ? SCB_LIST_NULL
						  : ahc_inb(ahc, INITIATOR_TAG),
			       ROLE_TARGET, CAM_REQ_ABORTED);
d2517 32
a2548 3
		tstate = ahc->enabled_targets[devinfo->our_scsiid];
		if (tstate != NULL) {
			struct ahc_tmode_lstate* lstate;
d2550 12
a2561 17
			lstate = tstate->enabled_luns[devinfo->lun];
			if (lstate != NULL) {
				ahc_queue_lstate_event(ahc, lstate,
						       devinfo->our_scsiid,
						       ahc->msgin_buf[0],
						       /*arg*/0);
				ahc_send_lstate_events(ahc, lstate);
			}
		}
		done = MSGLOOP_MSGCOMPLETE;
		break;
#endif
	case MSG_TERM_IO_PROC:
	default:
		reject = TRUE;
		break;
	}
d2563 4
a2566 10
	if (reject) {
		/*
		 * Setup to reject the message.
		 */
		ahc->msgout_index = 0;
		ahc->msgout_len = 1;
		ahc->msgout_buf[0] = MSG_MESSAGE_REJECT;
		done = MSGLOOP_MSGCOMPLETE;
		response = TRUE;
	}
d2568 2
a2569 5
	if (done != MSGLOOP_IN_PROG && !response)
		/* Clear the outgoing message buffer */
		ahc->msgout_len = 0;

	return (done);
d2572 4
a2575 5
/*
 * Process a message reject message.
 */
static int
ahc_handle_msg_reject(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
a2583 2
	struct ahc_initiator_tinfo *tinfo;
	struct ahc_tmode_tstate *tstate;
d2589 2
a2590 4
	scb = ahc_lookup_scb(ahc, scb_index);
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
d2594 3
a2596 20
	if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, /*full*/FALSE)) {
		/*
		 * Target does not support the PPR message.
		 * Attempt to negotiate SPI-2 style.
		 */
		if (bootverbose) {
			printf("(%s:%c:%d:%d): PPR Rejected. "
			       "Trying WDTR/SDTR\n",
			       ahc_name(ahc), devinfo->channel,
			       devinfo->target, devinfo->lun);
		}
		tinfo->goal.ppr_options = 0;
		tinfo->curr.transport_version = 2;
		tinfo->goal.transport_version = 2;
		ahc->msgout_index = 0;
		ahc->msgout_len = 0;
		ahc_build_transfer_msg(ahc, devinfo);
		ahc->msgout_index = 0;
		response = 1;
	} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, /*full*/FALSE)) {
d2599 6
a2604 4
		printf("(%s:%c:%d:%d): refuses WIDE negotiation.  Using "
		       "8bit transfers\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target, devinfo->lun);
		ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
d2606 1
a2606 1
			      /*paused*/TRUE);
d2614 3
d2618 1
d2621 2
d2625 1
a2625 1
			ahc_build_transfer_msg(ahc, devinfo);
d2629 1
a2629 1
	} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, /*full*/FALSE)) {
d2632 1
a2632 1
				 /*offset*/0, /*ppr_options*/0,
d2634 14
a2647 26
				 /*paused*/TRUE);
		printf("(%s:%c:%d:%d): refuses synchronous negotiation. "
		       "Using asynchronous transfers\n",
		       ahc_name(ahc), devinfo->channel,
		       devinfo->target, devinfo->lun);
	} else if ((scb->hscb->control & MSG_SIMPLE_TASK) != 0) {
		int tag_type;
		int mask;

		tag_type = (scb->hscb->control & MSG_SIMPLE_TASK);

		if (tag_type == MSG_SIMPLE_TASK) {
			printf("(%s:%c:%d:%d): refuses tagged commands.  "
			       "Performing non-tagged I/O\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target, devinfo->lun);
			ahc_set_tags(ahc, devinfo, AHC_QUEUE_NONE);
			mask = ~0x23;
		} else {
			printf("(%s:%c:%d:%d): refuses %s tagged commands.  "
			       "Performing simple queue tagged I/O only\n",
			       ahc_name(ahc), devinfo->channel, devinfo->target,
			       devinfo->lun, tag_type == MSG_ORDERED_TASK
			       ? "ordered" : "head of queue");
			ahc_set_tags(ahc, devinfo, AHC_QUEUE_BASIC);
			mask = ~0x03;
		}
d2653 3
a2655 5
		ahc_outb(ahc, SCB_CONTROL,
			 ahc_inb(ahc, SCB_CONTROL) & mask);
	 	scb->hscb->control &= mask;
		ahc_set_transaction_tag(scb, /*enabled*/FALSE,
					/*type*/MSG_SIMPLE_TASK);
d2657 1
a2657 16
		ahc_assert_atn(ahc);

		/*
		 * This transaction is now at the head of
		 * the untagged queue for this target.
		 */
		if ((ahc->flags & AHC_SCB_BTT) == 0) {
			struct scb_tailq *untagged_q;

			untagged_q =
			    &(ahc->untagged_queues[devinfo->target_offset]);
			TAILQ_INSERT_HEAD(untagged_q, scb, links.tqe);
			scb->flags |= SCB_UNTAGGEDQ;
		}
		ahc_busy_tcl(ahc, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),
			     scb->hscb->tag);
d2664 3
a2666 4
		ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
				   SCB_GET_CHANNEL(ahc, scb),
				   SCB_GET_LUN(scb), /*tag*/SCB_LIST_NULL,
				   ROLE_INITIATOR, CAM_REQUEUE_REQ,
d2679 3
a2681 5
/*
 * Process an ingnore wide residue message.
 */
static void
ahc_handle_ign_wide_residue(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
d2683 5
a2687 2
	u_int scb_index;
	struct scb *scb;
d2689 8
a2696 21
	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	/*
	 * XXX Actually check data direction in the sequencer?
	 * Perhaps add datadir to some spare bits in the hscb?
	 */
	if ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0
	 || ahc_get_transfer_dir(scb) != CAM_DIR_IN) {
		/*
		 * Ignore the message if we haven't
		 * seen an appropriate data phase yet.
		 */
	} else {
		/*
		 * If the residual occurred on the last
		 * transfer and the transfer request was
		 * expected to end on an odd count, do
		 * nothing.  Otherwise, subtract a byte
		 * and update the residual count accordingly.
		 */
		uint32_t sgptr;
d2698 3
a2700 24
		sgptr = ahc_inb(ahc, SCB_RESIDUAL_SGPTR);
		if ((sgptr & SG_LIST_NULL) != 0
		 && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {
			/*
			 * If the residual occurred on the last
			 * transfer and the transfer request was
			 * expected to end on an odd count, do
			 * nothing.
			 */
		} else {
			struct ahc_dma_seg *sg;
			uint32_t data_cnt;
			uint32_t data_addr;
			uint32_t sglen;

			/* Pull in the rest of the sgptr */
			sgptr |= (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8);
			sgptr &= SG_PTR_MASK;
			data_cnt = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+3) << 24)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+2) << 16)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+1) << 8)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT));
d2702 7
a2708 4
			data_addr = (ahc_inb(ahc, SHADDR + 3) << 24)
				  | (ahc_inb(ahc, SHADDR + 2) << 16)
				  | (ahc_inb(ahc, SHADDR + 1) << 8)
				  | (ahc_inb(ahc, SHADDR));
d2710 2
a2711 2
			data_cnt += 1;
			data_addr -= 1;
d2713 3
a2715 12
			sg = ahc_sg_bus_to_virt(scb, sgptr);
			/*
			 * The residual sg ptr points to the next S/G
			 * to load so we must go back one.
			 */
			sg--;
			sglen = ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
			if (sg != scb->sg_list
			 && sglen < (data_cnt & AHC_SG_LEN_MASK)) {

				sg--;
				sglen = ahc_le32toh(sg->len);
d2717 4
a2720 2
				 * Preserve High Address and SG_LIST bits
				 * while setting the count to 1.
d2722 5
a2726 17
				data_cnt = 1 | (sglen & (~AHC_SG_LEN_MASK));
				data_addr = ahc_le32toh(sg->addr)
					  + (sglen & AHC_SG_LEN_MASK) - 1;

				/*
				 * Increment sg so it points to the
				 * "next" sg.
				 */
				sg++;
				sgptr = ahc_sg_virt_to_bus(scb, sg);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 3,
					 sgptr >> 24);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 2,
					 sgptr >> 16);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 1,
					 sgptr >> 8);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR, sgptr);
d2728 3
d2732 5
a2736 4
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 3, data_cnt >> 24);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 2, data_cnt >> 16);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 1, data_cnt >> 8);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT, data_cnt);
a2737 2
	}
}
d2739 10
d2750 4
a2753 91
/*
 * Reinitialize the data pointers for the active transfer
 * based on its current residual.
 */
static void
ahc_reinitialize_dataptrs(struct ahc_softc *ahc)
{
	struct	 scb *scb;
	struct	 ahc_dma_seg *sg;
	u_int	 scb_index;
	uint32_t sgptr;
	uint32_t resid;
	uint32_t dataptr;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	sgptr = (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
	      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
	      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8)
	      |	ahc_inb(ahc, SCB_RESIDUAL_SGPTR);

	sgptr &= SG_PTR_MASK;
	sg = ahc_sg_bus_to_virt(scb, sgptr);

	/* The residual sg_ptr always points to the next sg */
	sg--;

	resid = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 2) << 16)
	      | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 1) << 8)
	      | ahc_inb(ahc, SCB_RESIDUAL_DATACNT);

	dataptr = ahc_le32toh(sg->addr)
		+ (ahc_le32toh(sg->len) & AHC_SG_LEN_MASK)
		- resid;
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		u_int dscommand1;

		dscommand1 = ahc_inb(ahc, DSCOMMAND1);
		ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
		ahc_outb(ahc, HADDR,
			 (ahc_le32toh(sg->len) >> 24) & SG_HIGH_ADDR_BITS);
		ahc_outb(ahc, DSCOMMAND1, dscommand1);
	}
	ahc_outb(ahc, HADDR + 3, dataptr >> 24);
	ahc_outb(ahc, HADDR + 2, dataptr >> 16);
	ahc_outb(ahc, HADDR + 1, dataptr >> 8);
	ahc_outb(ahc, HADDR, dataptr);
	ahc_outb(ahc, HCNT + 2, resid >> 16);
	ahc_outb(ahc, HCNT + 1, resid >> 8);
	ahc_outb(ahc, HCNT, resid);
	if ((ahc->features & AHC_ULTRA2) == 0) {
		ahc_outb(ahc, STCNT + 2, resid >> 16);
		ahc_outb(ahc, STCNT + 1, resid >> 8);
		ahc_outb(ahc, STCNT, resid);
	}
}

/*
 * Handle the effects of issuing a bus device reset message.
 */
static void
ahc_handle_devreset(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		    cam_status status, char *message, int verbose_level)
{
#ifdef AHC_TARGET_MODE
	struct ahc_tmode_tstate* tstate;
	u_int lun;
#endif
	int found;

	found = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       CAM_LUN_WILDCARD, SCB_LIST_NULL, devinfo->role,
			       status);
	
#ifdef AHC_TARGET_MODE
	/*
	 * Send an immediate notify ccb to all target mord peripheral
	 * drivers affected by this action.
	 */
	tstate = ahc->enabled_targets[devinfo->our_scsiid];
	if (tstate != NULL) {
		for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
			struct ahc_tmode_lstate* lstate;

			lstate = tstate->enabled_luns[lun];
			if (lstate == NULL)
				continue;

			ahc_queue_lstate_event(ahc, lstate, devinfo->our_scsiid,
					       MSG_BUS_DEV_RESET, /*arg*/0);
			ahc_send_lstate_events(ahc, lstate);
a2754 2
	}
#endif
d2756 7
a2762 61
	/*
	 * Go back to async/narrow transfers and renegotiate.
	 */
	ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
		      AHC_TRANS_CUR, /*paused*/TRUE);
	ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,
			 /*period*/0, /*offset*/0, /*ppr_options*/0,
			 AHC_TRANS_CUR, /*paused*/TRUE);
	
	ahc_send_async(ahc, devinfo->channel, devinfo->target,
		       CAM_LUN_WILDCARD, AC_SENT_BDR, NULL);

	if (message != NULL
	 && (verbose_level <= bootverbose))
		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahc_name(ahc),
		       message, devinfo->channel, devinfo->target, found);
}

#ifdef AHC_TARGET_MODE
static void
ahc_setup_target_msgin(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		       struct scb *scb)
{

	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)
		ahc_build_transfer_msg(ahc, devinfo);
	else
		panic("ahc_intr: AWAITING target message with no message");

	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
}
#endif
/**************************** Initialization **********************************/
/*
 * Allocate a controller structure for a new device
 * and perform initial initializion.
 */
struct ahc_softc *
ahc_alloc(void *platform_arg, char *name)
{
	struct  ahc_softc *ahc;
	int	i;

#ifdef __OpenBSD__	/* OpenBSD provides softc! */
	ahc = (struct ahc_softc *)platform_arg;
#else 
#ifndef	__FreeBSD__
	ahc = malloc(sizeof(*ahc), M_DEVBUF, M_NOWAIT);
	if (!ahc) {
		printf("aic7xxx: cannot malloc softc!\n");
		free(name, M_DEVBUF);
		return NULL;
d2764 4
a2767 25
#else
	ahc = device_get_softc((device_t)platform_arg);
#endif
	memset(ahc, 0, sizeof(*ahc));
#endif 
	LIST_INIT(&ahc->pending_scbs);
	/* We don't know our unit number until the OSM sets it */
	ahc->name = name;
	ahc->unit = -1;
	ahc->description = NULL;
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	ahc->chip = AHC_NONE;
	ahc->features = AHC_FENONE;
	ahc->bugs = AHC_BUGNONE;
	ahc->flags = AHC_FNONE;

	for (i = 0; i < 16; i++)
		TAILQ_INIT(&ahc->untagged_queues[i]);
	if (ahc_platform_alloc(ahc, platform_arg) != 0) {
		ahc_free(ahc);
		ahc = NULL;
	}
	return (ahc);
}
d2769 1
a2769 3
int
ahc_softc_init(struct ahc_softc *ahc)
{
d2771 8
a2778 55
	/* The IRQMS bit is only valid on VL and EISA chips */
	if ((ahc->chip & AHC_PCI) == 0)
		ahc->unpause = ahc_inb(ahc, HCNTRL) & IRQMS;
	else
		ahc->unpause = 0;
	ahc->pause = ahc->unpause | PAUSE; 
	/* XXX The shared scb data stuff should be deprecated */
	if (ahc->scb_data == NULL) {
		ahc->scb_data = malloc(sizeof(*ahc->scb_data),
				       M_DEVBUF, M_NOWAIT);
		if (ahc->scb_data == NULL)
			return (ENOMEM);
		memset(ahc->scb_data, 0, sizeof(*ahc->scb_data));
	}

	return (0);
}

void
ahc_softc_insert(struct ahc_softc *ahc)
{
	struct ahc_softc *list_ahc;

#if AHC_PCI_CONFIG > 0
	/*
	 * Second Function PCI devices need to inherit some
	 * settings from function 0.
	 */
	if ((ahc->chip & AHC_BUS_MASK) == AHC_PCI
	 && (ahc->features & AHC_MULTI_FUNC) != 0) {
		TAILQ_FOREACH(list_ahc, &ahc_tailq, links) {
			ahc_dev_softc_t list_pci;
			ahc_dev_softc_t pci;

			list_pci = list_ahc->dev_softc;
			pci = ahc->dev_softc;
			if (ahc_get_pci_slot(list_pci) == ahc_get_pci_slot(pci)
			 && ahc_get_pci_bus(list_pci) == ahc_get_pci_bus(pci)) {
				struct ahc_softc *master;
				struct ahc_softc *slave;

				if (ahc_get_pci_function(list_pci) == 0) {
					master = list_ahc;
					slave = ahc;
				} else {
					master = ahc;
					slave = list_ahc;
				}
				slave->flags &= ~AHC_BIOS_ENABLED; 
				slave->flags |=
				    master->flags & AHC_BIOS_ENABLED;
				slave->flags &= ~AHC_PRIMARY_CHANNEL; 
				slave->flags |=
				    master->flags & AHC_PRIMARY_CHANNEL;
				break;
d2780 2
a2782 2
	}
#endif
d2784 4
a2787 13
	/*
	 * Insertion sort into our list of softcs.
	 */
	list_ahc = TAILQ_FIRST(&ahc_tailq);
	while (list_ahc != NULL
	    && ahc_softc_comp(list_ahc, ahc) <= 0)
		list_ahc = TAILQ_NEXT(list_ahc, links);
	if (list_ahc != NULL)
		TAILQ_INSERT_BEFORE(list_ahc, ahc, links);
	else
		TAILQ_INSERT_TAIL(&ahc_tailq, ahc, links);
	ahc->init_level++;
}
d2789 6
a2794 5
void
ahc_set_unit(struct ahc_softc *ahc, int unit)
{
	ahc->unit = unit;
}
d2796 10
a2805 7
void
ahc_set_name(struct ahc_softc *ahc, char *name)
{
	if (ahc->name != NULL)
		free(ahc->name, M_DEVBUF);
	ahc->name = name;
}
d2807 3
a2809 31
#ifndef __OpenBSD__
void
ahc_free(struct ahc_softc *ahc)
{
	int i;

	ahc_fini_scbdata(ahc);
	switch (ahc->init_level) {
	default:
	case 5:
		ahc_shutdown(ahc);
		TAILQ_REMOVE(&ahc_tailq, ahc, links);
		/* FALLTHROUGH */
	case 4:
		ahc_dmamap_unload(ahc, ahc->shared_data_dmat,
				  ahc->shared_data_dmamap);
		/* FALLTHROUGH */
	case 3:
		ahc_dmamem_free(ahc, ahc->shared_data_dmat, ahc->qoutfifo,
				ahc->shared_data_dmamap);
		ahc_dmamap_destroy(ahc, ahc->shared_data_dmat,
				   ahc->shared_data_dmamap);
		/* FALLTHROUGH */
	case 2:
		ahc_dma_tag_destroy(ahc, ahc->shared_data_dmat);
	case 1:
#ifndef __linux__
		ahc_dma_tag_destroy(ahc, ahc->buffer_dmat);
#endif
		break;
	case 0:
d2812 4
d2817 2
a2818 6
#ifndef __linux__
	ahc_dma_tag_destroy(ahc, ahc->parent_dmat);
#endif
	ahc_platform_free(ahc);
	for (i = 0; i < AHC_NUM_TARGETS; i++) {
		struct ahc_tmode_tstate *tstate;
d2820 11
a2830 4
		tstate = ahc->enabled_targets[i];
		if (tstate != NULL) {
#if AHC_TARGET_MODE
			int j;
d2832 1
a2832 2
			for (j = 0; j < AHC_NUM_LUNS; j++) {
				struct ahc_tmode_lstate *lstate;
d2834 14
a2847 8
				lstate = tstate->enabled_luns[j];
				if (lstate != NULL) {
					xpt_free_path(lstate->path);
					free(lstate, M_DEVBUF);
				}
			}
#endif
			free(tstate, M_DEVBUF);
a2848 15
	}
#if AHC_TARGET_MODE
	if (ahc->black_hole != NULL) {
		xpt_free_path(ahc->black_hole->path);
		free(ahc->black_hole, M_DEVBUF);
	}
#endif
	if (ahc->name != NULL)
		free(ahc->name, M_DEVBUF);
#ifndef __FreeBSD__
	free(ahc, M_DEVBUF);
#endif
	return;
}
#endif /* __OpenBSD__ */
d2850 7
a2856 5
void
ahc_shutdown(void *arg)
{
	struct	ahc_softc *ahc;
	int	i;
d2858 11
a2868 1
	ahc = (struct ahc_softc *)arg;
d2870 5
a2874 5
	/* This will reset most registers to 0, but not all */
	ahc_reset(ahc);
	ahc_outb(ahc, SCSISEQ, 0);
	ahc_outb(ahc, SXFRCTL0, 0);
	ahc_outb(ahc, DSPCISTATUS, 0);
d2876 19
a2894 24
	for (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)
		ahc_outb(ahc, i, 0);
}

/*
 * Reset the controller and record some information about it
 * that is only availabel just after a reset.
 */
int
ahc_reset(struct ahc_softc *ahc)
{
	u_int	sblkctl;
	u_int	sxfrctl1_a, sxfrctl1_b;
	int	wait;
	
	/*
	 * Preserve the value of the SXFRCTL1 register for all channels.
	 * It contains settings that affect termination and we don't want
	 * to disturb the integrity of the bus.
	 */
	ahc_pause(ahc);
	sxfrctl1_b = 0;
	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7770) {
		u_int sblkctl;
d2897 2
a2898 2
		 * Save channel B's settings in case this chip
		 * is setup for TWIN channel operation.
d2900 2
a2901 6
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		sxfrctl1_b = ahc_inb(ahc, SXFRCTL1);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	sxfrctl1_a = ahc_inb(ahc, SXFRCTL1);
d2903 13
a2915 1
	ahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);
d2917 7
a2923 7
	/*
	 * Ensure that the reset has finished
	 */
	wait = 1000;
	do {
		ahc_delay(1000);
	} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));
d2925 1
a2925 3
	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", ahc_name(ahc));
a2926 19
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/* Determine channel configuration */
	sblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);
	/* No Twin Channel PCI cards */
	if ((ahc->chip & AHC_PCI) != 0)
		sblkctl &= ~SELBUSB;
	switch (sblkctl) {
	case 0:
		/* Single Narrow Channel */
		break;
	case 2:
		/* Wide Channel */
		ahc->features |= AHC_WIDE;
		break;
	case 8:
		/* Twin Channel */
		ahc->features |= AHC_TWIN;
		break;
d2928 1
a2928 2
		printf(" Unsupported adapter type.  Ignoring\n");
		return(-1);
d2931 6
a2936 10
	/*
	 * Reload sxfrctl1.
	 *
	 * We must always initialize STPWEN to 1 before we
	 * restore the saved values.  STPWEN is initialized
	 * to a tri-state condition which can only be cleared
	 * by turning it on.
	 */
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;
d2938 14
a2951 6
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		ahc_outb(ahc, SXFRCTL1, sxfrctl1_b);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	ahc_outb(ahc, SXFRCTL1, sxfrctl1_a);
d2953 2
a2954 4
#ifdef AHC_DUMP_SEQ
	if (ahc->init_level == 0)
		ahc_dumpseq(ahc);
#endif
d2956 2
a2957 9
	return (0);
}

/*
 * Determine the number of SCBs available on the controller
 */
int
ahc_probe_scbs(struct ahc_softc *ahc) {
	int i;
d2959 3
a2961 1
	for (i = 0; i < AHC_SCB_MAX; i++) {
d2963 8
a2970 6
		ahc_outb(ahc, SCBPTR, i);
		ahc_outb(ahc, SCB_BASE, i);
		if (ahc_inb(ahc, SCB_BASE) != i)
			break;
		ahc_outb(ahc, SCBPTR, 0);
		if (ahc_inb(ahc, SCB_BASE) != 0)
d2972 9
d2982 1
a2982 1
	return (i);
d2985 5
a2989 3
#ifndef __OpenBSD__
static void
ahc_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) 
d2991 6
a2996 1
	bus_addr_t *baddr;
d2998 6
a3003 4
	baddr = (bus_addr_t *)arg;
	*baddr = segs->ds_addr;
}
#endif 
d3005 30
a3034 23
#ifndef __OpenBSD__
static void
#else
void
#endif 
ahc_build_free_scb_list(struct ahc_softc *ahc)
{
	int i;

	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		ahc_outb(ahc, SCBPTR, i);

		/* Clear the control byte. */
		ahc_outb(ahc, SCB_CONTROL, 0);

		/* Set the next pointer */
		if ((ahc->flags & AHC_PAGESCBS) != 0)
			ahc_outb(ahc, SCB_NEXT, i+1);
		else 
			ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);

		/* Make the tag number invalid */
		ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
d3036 17
d3054 9
a3062 3
	/* Make sure that the last SCB terminates the free list */
	ahc_outb(ahc, SCBPTR, i-1);
	ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);
d3064 9
a3072 4
	/* Ensure we clear the 0 SCB's control byte. */
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outb(ahc, SCB_CONTROL, 0);
}
d3074 30
a3103 5
#ifndef __OpenBSD__
static int
ahc_init_scbdata(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;
d3105 5
a3109 3
	scb_data = ahc->scb_data;
	SLIST_INIT(&scb_data->free_scbs);
	SLIST_INIT(&scb_data->sg_maps);
d3111 9
a3119 7
	/* Allocate SCB resources */
	scb_data->scbarray =
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,
				 M_DEVBUF, M_NOWAIT);
	if (scb_data->scbarray == NULL)
		return (ENOMEM);
	memset(scb_data->scbarray, 0, sizeof(struct scb) * AHC_SCB_MAX);
d3121 54
a3174 1
	/* Determine the number of hardware SCBs and initialize them */
d3176 6
a3181 7
	scb_data->maxhscbs = ahc_probe_scbs(ahc);
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		/* SCB 0 heads the free list */
		ahc_outb(ahc, FREE_SCBH, 0);
	} else {
		ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	}
d3183 28
a3210 3
	if (ahc->scb_data->maxhscbs == 0) {
		printf("%s: No SCB space found\n", ahc_name(ahc));
		return (ENXIO);
d3212 21
d3234 3
a3236 1
	ahc_build_free_scb_list(ahc);
d3238 18
a3255 21
	/*
	 * Create our DMA tags.  These tags define the kinds of device
	 * accessible memory allocations and memory mappings we will
	 * need to perform during normal operation.
	 *
	 * Unless we need to further restrict the allocation, we rely
	 * on the restrictions of the parent dmat, hence the common
	 * use of MAXADDR and MAXSIZE.
	 */

	/* DMA tag for our hardware scb structures */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       AHC_SCB_MAX * sizeof(struct hardware_scb),
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->hscb_dmat) != 0) {
		goto error_exit;
d3258 9
a3266 7
	scb_data->init_level++;

	/* Allocation for our hscbs */
	if (ahc_dmamem_alloc(ahc, scb_data->hscb_dmat,
			     (void **)&scb_data->hscbs,
			     BUS_DMA_NOWAIT, &scb_data->hscb_dmamap) != 0) {
		goto error_exit;
d3269 3
a3271 1
	scb_data->init_level++;
d3273 2
a3274 5
	/* And permanently map them */
	ahc_dmamap_load(ahc, scb_data->hscb_dmat, scb_data->hscb_dmamap,
			scb_data->hscbs,
			AHC_SCB_MAX * sizeof(struct hardware_scb),
			ahc_dmamap_cb, &scb_data->hscb_busaddr, /*flags*/0);
d3276 7
a3282 1
	scb_data->init_level++;
d3284 17
a3300 12
	/* DMA tag for our sense buffers */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->sense_dmat) != 0) {
		goto error_exit;
	}
d3302 17
a3318 1
	scb_data->init_level++;
d3320 4
a3323 6
	/* Allocate them */
	if (ahc_dmamem_alloc(ahc, scb_data->sense_dmat,
			     (void **)&scb_data->sense,
			     BUS_DMA_NOWAIT, &scb_data->sense_dmamap) != 0) {
		goto error_exit;
	}
d3325 2
a3326 1
	scb_data->init_level++;
d3328 1
a3328 5
	/* And permanently map them */
	ahc_dmamap_load(ahc, scb_data->sense_dmat, scb_data->sense_dmamap,
			scb_data->sense,
			AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			ahc_dmamap_cb, &scb_data->sense_busaddr, /*flags*/0);
d3330 22
a3351 1
	scb_data->init_level++;
d3353 3
a3355 11
	/* DMA tag for our S/G structures.  We allocate in page sized chunks */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       PAGE_SIZE, /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->sg_dmat) != 0) {
		goto error_exit;
	}
d3357 5
a3361 11
	scb_data->init_level++;

	/* Perform initial CCB allocation */
	memset(scb_data->hscbs, 0, AHC_SCB_MAX * sizeof(struct hardware_scb));
	ahc_alloc_scbs(ahc);

	if (scb_data->numscbs == 0) {
		printf("%s: ahc_init_scbdata - "
		       "Unable to allocate initial scbs\n",
		       ahc_name(ahc));
		goto error_exit;
d3363 1
d3365 9
a3373 5
	/*
	 * Tell the sequencer which SCB will be the next one it receives.
	 */
	ahc->next_queued_scb = ahc_get_scb(ahc);
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);
d3375 4
d3380 3
a3382 1
	 * Note that we were successfull
d3384 10
a3393 5
	return (0); 

error_exit:

	return (ENOMEM);
d3396 9
a3404 2
static void
ahc_fini_scbdata(struct ahc_softc *ahc)
d3406 4
a3409 1
	struct scb_data *scb_data;
d3411 3
a3413 3
	scb_data = ahc->scb_data;
	if (scb_data == NULL)
		return;
d3415 1
a3415 5
	switch (scb_data->init_level) {
	default:
	case 7:
	{
		struct sg_map_node *sg_map;
d3417 5
a3421 10
		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
			ahc_dmamap_unload(ahc, scb_data->sg_dmat,
					  sg_map->sg_dmamap);
			ahc_dmamem_free(ahc, scb_data->sg_dmat,
					sg_map->sg_vaddr,
					sg_map->sg_dmamap);
			free(sg_map, M_DEVBUF);
		}
		ahc_dma_tag_destroy(ahc, scb_data->sg_dmat);
d3423 14
a3436 23
	case 6:
		ahc_dmamap_unload(ahc, scb_data->sense_dmat,
				  scb_data->sense_dmamap);
	case 5:
		ahc_dmamem_free(ahc, scb_data->sense_dmat, scb_data->sense,
				scb_data->sense_dmamap);
		ahc_dmamap_destroy(ahc, scb_data->sense_dmat,
				   scb_data->sense_dmamap);
	case 4:
		ahc_dma_tag_destroy(ahc, scb_data->sense_dmat);
	case 3:
		ahc_dmamap_unload(ahc, scb_data->hscb_dmat,
				  scb_data->hscb_dmamap);
	case 2:
		ahc_dmamem_free(ahc, scb_data->hscb_dmat, scb_data->hscbs,
				scb_data->hscb_dmamap);
		ahc_dmamap_destroy(ahc, scb_data->hscb_dmat,
				   scb_data->hscb_dmamap);
	case 1:
		ahc_dma_tag_destroy(ahc, scb_data->hscb_dmat);
		break;
	case 0:
		break;
a3437 3
	if (scb_data->scbarray != NULL)
		free(scb_data->scbarray, M_DEVBUF);
}
d3439 7
a3445 10
void
ahc_alloc_scbs(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;
	struct scb *next_scb;
	struct sg_map_node *sg_map;
	bus_addr_t physaddr;
	struct ahc_dma_seg *segs;
	int newcount;
	int i;
d3447 5
a3451 4
	scb_data = ahc->scb_data;
	if (scb_data->numscbs >= AHC_SCB_MAX)
		/* Can't allocate any more */
		return;
d3453 1
a3453 1
	next_scb = &scb_data->scbarray[scb_data->numscbs];
d3455 8
a3462 1
	sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);
d3464 5
a3468 2
	if (sg_map == NULL)
		return;
d3470 12
a3481 6
	/* Allocate S/G space for the next batch of SCBS */
	if (ahc_dmamem_alloc(ahc, scb_data->sg_dmat,
			     (void **)&sg_map->sg_vaddr,
			     BUS_DMA_NOWAIT, &sg_map->sg_dmamap) != 0) {
		free(sg_map, M_DEVBUF);
		return;
d3484 26
a3509 5
	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);

	ahc_dmamap_load(ahc, scb_data->sg_dmat, sg_map->sg_dmamap,
			sg_map->sg_vaddr, PAGE_SIZE, ahc_dmamap_cb,
			&sg_map->sg_physaddr, /*flags*/0);
d3511 1
a3511 16
	segs = sg_map->sg_vaddr;
	physaddr = sg_map->sg_physaddr;

	newcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));
	for (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {
		struct scb_platform_data *pdata;
#ifndef __linux__
		int error;
#endif
		pdata = (struct scb_platform_data *)malloc(sizeof(*pdata),
							   M_DEVBUF, M_NOWAIT);
		if (pdata == NULL)
			break;
		next_scb->platform_data = pdata;
		next_scb->sg_map = sg_map;
		next_scb->sg_list = segs;
d3513 2
a3514 2
		 * The sequencer always starts with the second entry.
		 * The first entry is embedded in the scb.
d3516 12
a3527 17
		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
		next_scb->ahc_softc = ahc;
		next_scb->flags = SCB_FREE;
#ifndef __linux__
		error = ahc_dmamap_create(ahc, ahc->buffer_dmat, /*flags*/0,
					  &next_scb->dmamap);
		if (error != 0)
			break;
#endif
		next_scb->hscb = &scb_data->hscbs[scb_data->numscbs];
		next_scb->hscb->tag = ahc->scb_data->numscbs;
		SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs,
				  next_scb, links.sle);
		segs += AHC_NSEG;
		physaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));
		next_scb++;
		ahc->scb_data->numscbs++;
d3529 11
a3540 1
#endif /* __OpenBSD__ */
d3542 6
a3547 2
void
ahc_controller_info(struct ahc_softc *ahc, char *buf)
d3549 1
a3549 1
	int len;
d3551 8
a3558 26
	len = sprintf(buf, "%s: ", ahc_chip_names[ahc->chip & AHC_CHIPID_MASK]);
	buf += len;
	if ((ahc->features & AHC_TWIN) != 0)
 		len = sprintf(buf, "Twin Channel, A SCSI Id=%d, "
			      "B SCSI Id=%d, primary %c, ",
			      ahc->our_id, ahc->our_id_b,
			      (ahc->flags & AHC_PRIMARY_CHANNEL) + 'A');
	else {
		const char *speed;
		const char *type;

		speed = "";
		if ((ahc->features & AHC_ULTRA) != 0) {
			speed = "Ultra ";
		} else if ((ahc->features & AHC_DT) != 0) {
			speed = "Ultra160 ";
		} else if ((ahc->features & AHC_ULTRA2) != 0) {
			speed = "Ultra2 ";
		}
		if ((ahc->features & AHC_WIDE) != 0) {
			type = "Wide";
		} else {
			type = "Single";
		}
		len = sprintf(buf, "%s%s Channel %c, SCSI Id=%d, ",
			      speed, type, ahc->channel, ahc->our_id);
d3560 2
a3561 7
	buf += len;

	if ((ahc->flags & AHC_PAGESCBS) != 0)
		sprintf(buf, "%d/%d SCBs",
			ahc->scb_data->maxhscbs, AHC_SCB_MAX);
	else
		sprintf(buf, "%d SCBs", ahc->scb_data->maxhscbs);
d3568 2
a3569 1
ahc_init(struct ahc_softc *ahc)
d3571 11
a3581 15
	int	 max_targ;
	int	 i;
	int	 term;
	u_int	 scsi_conf;
	u_int	 scsiseq_template;
	u_int	 ultraenb;
	u_int	 discenable;
	u_int	 tagenable;
	size_t	 driver_data_size;
	uint32_t physaddr;

#define AHC_DEBUG_SEQUENCER
#ifdef AHC_DEBUG_SEQUENCER
	ahc->flags |= AHC_SEQUENCER_DEBUG;
#endif
d3601 10
a3610 1
	max_targ = 15;
d3620 2
a3621 2
	ahc->flags |= AHC_INITIATORROLE;

d3623 7
a3629 1
	 * Only allow target mode features if this unit has them enabled.
d3631 1
a3631 19
	if ((AHC_TMODE_ENABLE & (0x1 << ahc->unit)) == 0)
		ahc->features &= ~AHC_TARGETMODE;

#if !defined(__linux__) && !defined(__OpenBSD__)
	/* DMA tag for mapping buffers into device visible space. */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       /*maxsize*/MAXBSIZE, /*nsegments*/AHC_NSEG,
			       /*maxsegsz*/AHC_MAXTRANSFER_SIZE,
			       /*flags*/BUS_DMA_ALLOCNOW,
			       &ahc->buffer_dmat) != 0) {
		return (ENOMEM);
	}
#endif

	ahc->init_level++;
d3633 1
a3633 12
	/*
	 * DMA tag for our command fifos and other data in system memory
	 * the card's sequencer must be able to access.  For initiator
	 * roles, we need to allocate space for the the qinfifo and qoutfifo.
	 * The qinfifo and qoutfifo are composed of 256 1 byte elements. 
	 * When providing for the target mode role, we must additionally
	 * provide space for the incoming target command fifo and an extra
	 * byte to deal with a dma bug in some chip versions.
	 */
	driver_data_size = 2 * 256 * sizeof(uint8_t);
#ifdef __OpenBSD__
	if (ahc_createdmamem(ahc, ahc->shared_data_dmat, driver_data_size, 
a3639 18
#else

	if ((ahc->features & AHC_TARGETMODE) != 0)
		driver_data_size += AHC_TMODE_CMDS * sizeof(struct target_cmd)
				 + /*DMA WideOdd Bug Buffer*/1;
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       driver_data_size,
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &ahc->shared_data_dmat) != 0) {
		return (ENOMEM);
	}

	ahc->init_level++;
d3641 4
a3644 8
	/* Allocation of driver data */
	if (ahc_dmamem_alloc(ahc, ahc->shared_data_dmat,
			     (void **)&ahc->qoutfifo,
			     BUS_DMA_NOWAIT, &ahc->shared_data_dmamap) != 0) {
		return (ENOMEM);
	}

	ahc->init_level++;
a3645 19
	/* And permanently map it in */
	ahc_dmamap_load(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
			ahc->qoutfifo, driver_data_size, ahc_dmamap_cb,
			&ahc->shared_data_busaddr, /*flags*/0);
	if ((ahc->features & AHC_TARGETMODE) != 0) {
		ahc->targetcmds = (struct target_cmd *)ahc->qoutfifo;
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[AHC_TMODE_CMDS];
		ahc->dma_bug_buf = ahc->shared_data_busaddr
				 + driver_data_size - 1;
		/* All target command blocks start out invalid. */
		for (i = 0; i < AHC_TMODE_CMDS; i++)
			ahc->targetcmds[i].cmd_valid = 0;
		ahc_sync_tqinfifo(ahc, BUS_DMASYNC_PREREAD);
		ahc->tqinfifonext = 1;
		ahc_outb(ahc, KERNEL_TQINPOS, ahc->tqinfifonext - 1);
		ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[256];
	}
#endif 
d3647 4
d3652 3
a3654 6
	ahc->init_level++;

	/* Allocate SCB data now that buffer_dmat is initialized */
	if (ahc->scb_data->maxhscbs == 0)
		if (ahc_init_scbdata(ahc) != 0)
			return (ENOMEM);
d3656 3
d3665 1
a3665 1
		printf("%s: unable to allocate ahc_tmode_tstate.  "
d3667 1
a3667 1
		return (ENOMEM);
d3672 1
a3672 1
			printf("%s: unable to allocate ahc_tmode_tstate.  "
d3674 10
a3683 1
			return (ENOMEM);
d3685 1
a3688 1
	ahc_outb(ahc, SEQ_FLAGS2, 0);
d3692 1
d3695 1
d3709 1
a3709 1
	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
d3716 5
a3720 3
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		term = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;
		ahc_outb(ahc, SCSIID, ahc->our_id_b);
d3723 1
a3723 3
					|term|ahc->seltime_b|ENSTIMER|ACTNEGEN);
		if ((ahc->features & AHC_ULTRA2) != 0)
			ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
d3728 1
a3728 1
		 && (ahc->flags & AHC_INITIATORROLE) != 0)
a3733 1
	
d3741 1
a3741 1
				|term|ahc->seltime
a3742 2
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
d3747 1
a3747 1
	 && (ahc->flags & AHC_INITIATORROLE) != 0)
d3779 1
a3779 1
		struct ahc_tmode_tstate *tstate;
d3795 1
a3795 1
		memset(tinfo, 0, sizeof(*tinfo));
d3808 1
a3808 1
			uint16_t mask;
a3828 3
				if ((scsirate & ~WIDEXFER) == 0 && offset != 0)
					/* Set to the lowest sync rate, 5MHz */
					scsirate |= 0x1c;
a3837 4
				if ((scsirate & SXFR_ULTRA2) <= 8/*10MHz*/
				 && (ahc->features & AHC_DT) != 0)
					tinfo->user.ppr_options =
					    MSG_EXT_PPR_DT_REQ;
a3838 6
				if ((scsirate & SXFR) == 0x40
				 && (ultraenb & mask) != 0) {
					/* Treat 10MHz as a non-ultra speed */
					scsirate &= ~SXFR;
				 	ultraenb &= ~mask;
				}
a3846 2
			if (tinfo->user.period == 0)
				tinfo->user.offset = 0;
a3849 9
			tinfo->user.protocol_version = 4;
			if ((ahc->features & AHC_DT) != 0)
				tinfo->user.transport_version = 3;
			else
				tinfo->user.transport_version = 2;
			tinfo->goal.protocol_version = 2;
			tinfo->goal.transport_version = 2;
			tinfo->curr.protocol_version = 2;
			tinfo->curr.transport_version = 2;
d3851 1
d3853 2
a3858 29
	/* There are no untagged SCBs active yet. */
	for (i = 0; i < 16; i++) {
		ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, 0));
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			int lun;

			/*
			 * The SCB based BTT allows an entry per
			 * target and lun pair.
			 */
			for (lun = 1; lun < AHC_NUM_LUNS; lun++)
				ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, lun));
		}
	}

	/* All of our queues are empty */
	for (i = 0; i < 256; i++)
		ahc->qoutfifo[i] = SCB_LIST_NULL;
	
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREREAD);

	for (i = 0; i < 256; i++)
		ahc->qinfifo[i] = SCB_LIST_NULL;

	if ((ahc->features & AHC_MULTI_TID) != 0) {
		ahc_outb(ahc, TARGID, 0);
		ahc_outb(ahc, TARGID + 1, 0);
	}
	
d3869 11
a3879 4
	ahc_outb(ahc, SHARED_DATA_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 3, (physaddr >> 24) & 0xFF);
d3900 10
d3921 1
d3933 1
a3933 1
	 * If we are a target, we'll enalbe select in operations once
d3937 1
a3937 1
	if ((ahc->flags & AHC_INITIATORROLE) != 0)
d3951 18
a3968 2
	if ((ahc->features & AHC_ULTRA2) != 0) {
		int wait;
a3969 15
		/*
		 * Wait for up to 500ms for our transceivers
		 * to settle.  If the adapter does not have
		 * a cable attached, the tranceivers may
		 * never settle, so don't complain if we
		 * fail here.
		 */
		ahc_pause(ahc);
		for (wait = 5000;
		     (ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
		     wait--)
			ahc_delay(100);
		ahc_unpause(ahc);
	}
	return (0);
d3972 4
a3975 2
void
ahc_intr_enable(struct ahc_softc *ahc, int enable)
d3977 5
a3981 1
	u_int hcntrl;
d3983 29
a4011 8
	hcntrl = ahc_inb(ahc, HCNTRL);
	hcntrl &= ~INTEN;
	ahc->pause &= ~INTEN;
	ahc->unpause &= ~INTEN;
	if (enable) {
		hcntrl |= INTEN;
		ahc->pause |= INTEN;
		ahc->unpause |= INTEN;
d4013 12
a4024 1
	ahc_outb(ahc, HCNTRL, hcntrl);
d4028 1
a4028 5
 * Ensure that the card is paused in a location
 * outside of all critical sections and that all
 * pending work is completed prior to returning.
 * This routine should only be called from outside
 * an interrupt context.
d4030 2
a4031 2
void
ahc_pause_and_flushwork(struct ahc_softc *ahc)
d4033 5
a4037 2
	int intstat;
	int maxloops;
d4039 5
a4043 8
	maxloops = 1000;
	ahc->flags |= AHC_ALL_INTERRUPTS;
	intstat = 0;
	do {
		ahc_intr(ahc);
		ahc_pause(ahc);
		ahc_clear_critical_section(ahc);
		if (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0)
d4045 1
a4045 5
		maxloops--;
	} while (((intstat = ahc_inb(ahc, INTSTAT)) & INT_PEND) && --maxloops);
	if (maxloops == 0) {
		printf("Infinite interrupt loop, INTSTAT = %x",
		      ahc_inb(ahc, INTSTAT));
d4047 2
a4048 2
	ahc_platform_flushwork(ahc);
	ahc->flags &= ~AHC_ALL_INTERRUPTS;
d4051 3
a4053 2
int
ahc_suspend(struct ahc_softc *ahc)
d4055 31
a4085 2
	uint8_t *ptr;
	int	 i;
d4087 5
a4091 1
	ahc_pause_and_flushwork(ahc);
d4093 5
a4097 2
	if (LIST_FIRST(&ahc->pending_scbs) != NULL)
		return (EBUSY);
d4099 3
a4101 1
#if AHC_TARGET_MODE
d4103 2
a4104 3
	 * XXX What about ATIOs that have not yet been serviced?
	 * Perhaps we should just refuse to be suspended if we
	 * are acting in a target role.
d4106 14
a4119 15
	if (ahc->pending_device != NULL)
		return (EBUSY);
#endif
	
	/* Save volatile registers */
	if ((ahc->features & AHC_TWIN) != 0) {
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		ahc->suspend_state.channel[1].scsiseq = ahc_inb(ahc, SCSISEQ);
		ahc->suspend_state.channel[1].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
		ahc->suspend_state.channel[1].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
		ahc->suspend_state.channel[1].simode0 = ahc_inb(ahc, SIMODE0);
		ahc->suspend_state.channel[1].simode1 = ahc_inb(ahc, SIMODE1);
		ahc->suspend_state.channel[1].seltimer = ahc_inb(ahc, SELTIMER);
		ahc->suspend_state.channel[1].seqctl = ahc_inb(ahc, SEQCTL);
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
d4121 30
a4150 21
	ahc->suspend_state.channel[0].scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc->suspend_state.channel[0].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
	ahc->suspend_state.channel[0].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
	ahc->suspend_state.channel[0].simode0 = ahc_inb(ahc, SIMODE0);
	ahc->suspend_state.channel[0].simode1 = ahc_inb(ahc, SIMODE1);
	ahc->suspend_state.channel[0].seltimer = ahc_inb(ahc, SELTIMER);
	ahc->suspend_state.channel[0].seqctl = ahc_inb(ahc, SEQCTL);

	if ((ahc->chip & AHC_PCI) != 0) {
		ahc->suspend_state.dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		ahc->suspend_state.dspcistatus = ahc_inb(ahc, DSPCISTATUS);
	}

	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;

		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc->suspend_state.optionmode = ahc_inb(ahc, OPTIONMODE);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc->suspend_state.crccontrol1 = ahc_inb(ahc, CRCCONTROL1);
d4153 9
a4161 2
	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc->suspend_state.scbbaddr = ahc_inb(ahc, SCBBADDR);
d4163 5
a4167 2
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc->suspend_state.dff_thrsh = ahc_inb(ahc, DFF_THRSH);
d4169 9
a4177 3
	ptr = ahc->suspend_state.scratch_ram;
	for (i = 0; i < 64; i++)
		*ptr++ = ahc_inb(ahc, SRAM_BASE + i);
d4179 2
a4180 3
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0; i < 16; i++)
			*ptr++ = ahc_inb(ahc, TARG_OFFSET + i);
d4183 12
a4194 4
	ptr = ahc->suspend_state.btt;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		for (i = 0;i < AHC_NUM_TARGETS; i++) {
			int j;
d4196 4
a4199 2
			for (j = 0;j < AHC_NUM_LUNS; j++) {
				u_int tcl;
d4201 9
a4209 3
				tcl = BUILD_TCL(i << 4, j);
				*ptr = ahc_index_busy_tcl(ahc, tcl);
			}
d4211 21
d4233 17
a4249 2
	ahc_shutdown(ahc);
	return (0);
d4252 5
a4256 2
int
ahc_resume(struct ahc_softc *ahc)
d4258 4
a4261 2
	uint8_t *ptr;
	int	 i;
d4263 9
a4271 1
	ahc_reset(ahc);
d4273 1
a4273 1
	ahc_build_free_scb_list(ahc);
d4275 13
a4287 24
	/* Restore volatile registers */
	if ((ahc->features & AHC_TWIN) != 0) {
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		ahc_outb(ahc, SCSIID, ahc->our_id);
		ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[1].scsiseq);
		ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[1].sxfrctl0);
		ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[1].sxfrctl1);
		ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[1].simode0);
		ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[1].simode1);
		ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[1].seltimer);
		ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[1].seqctl);
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
	}
	ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[0].scsiseq);
	ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[0].sxfrctl0);
	ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[0].sxfrctl1);
	ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[0].simode0);
	ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[0].simode1);
	ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[0].seltimer);
	ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[0].seqctl);
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);
	else
		ahc_outb(ahc, SCSIID, ahc->our_id);
d4289 12
a4300 3
	if ((ahc->chip & AHC_PCI) != 0) {
		ahc_outb(ahc, DSCOMMAND0, ahc->suspend_state.dscommand0);
		ahc_outb(ahc, DSPCISTATUS, ahc->suspend_state.dspcistatus);
d4302 2
d4305 1
a4305 2
	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;
d4307 12
a4318 5
		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc_outb(ahc, OPTIONMODE, ahc->suspend_state.optionmode);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc_outb(ahc, CRCCONTROL1, ahc->suspend_state.crccontrol1);
d4321 4
a4324 2
	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc_outb(ahc, SCBBADDR, ahc->suspend_state.scbbaddr);
d4326 3
a4328 2
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, DFF_THRSH, ahc->suspend_state.dff_thrsh);
d4330 1
a4330 3
	ptr = ahc->suspend_state.scratch_ram;
	for (i = 0; i < 64; i++)
		ahc_outb(ahc, SRAM_BASE + i, *ptr++);
d4332 2
a4333 4
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0; i < 16; i++)
			ahc_outb(ahc, TARG_OFFSET + i, *ptr++);
	}
d4335 13
a4347 4
	ptr = ahc->suspend_state.btt;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		for (i = 0;i < AHC_NUM_TARGETS; i++) {
			int j;
d4349 1
a4349 2
			for (j = 0;j < AHC_NUM_LUNS; j++) {
				u_int tcl;
d4351 9
a4359 3
				tcl = BUILD_TCL(i << 4, j);
				ahc_busy_tcl(ahc, tcl, *ptr);
			}
d4362 30
a4391 1
	return (0);
d4394 10
a4403 10
/************************** Busy Target Table *********************************/
/*
 * Return the untagged transaction id for a given target/channel lun.
 * Optionally, clear the entry.
 */
u_int
ahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl)
{
	u_int scbid;
	u_int target_offset;
d4405 4
a4408 2
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
d4410 2
a4411 10
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		scbid = ahc_inb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl));
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		scbid = ahc_inb(ahc, BUSY_TARGETS + target_offset);
	}

	return (scbid);
d4414 5
a4418 2
void
ahc_unbusy_tcl(struct ahc_softc *ahc, u_int tcl)
d4420 12
a4431 1
	u_int target_offset;
d4433 14
a4446 7
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
		
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		ahc_outb(ahc, SCB_64_BTT+TCL_TARGET_OFFSET(tcl), SCB_LIST_NULL);
		ahc_outb(ahc, SCBPTR, saved_scbptr);
d4448 1
a4448 2
		target_offset = TCL_TARGET_OFFSET(tcl);
		ahc_outb(ahc, BUSY_TARGETS + target_offset, SCB_LIST_NULL);
d4452 4
a4455 2
void
ahc_busy_tcl(struct ahc_softc *ahc, u_int tcl, u_int scbid)
d4457 3
a4459 1
	u_int target_offset;
d4461 7
a4467 11
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
		
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		ahc_outb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl), scbid);
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		ahc_outb(ahc, BUSY_TARGETS + target_offset, scbid);
	}
d4470 3
a4472 4
/************************** SCB and SCB queue management **********************/
int
ahc_match_scb(struct ahc_softc *ahc, struct scb *scb, int target,
	      char channel, int lun, u_int tag, role_t role)
d4474 15
a4488 4
	int targ = SCB_GET_TARGET(ahc, scb);
	char chan = SCB_GET_CHANNEL(ahc, scb);
	int slun = SCB_GET_LUN(scb);
	int match;
d4490 1
a4490 8
	match = ((chan == channel) || (channel == ALL_CHANNELS));
	if (match != 0)
		match = ((targ == target) || (target == CAM_TARGET_WILDCARD));
	if (match != 0)
		match = ((lun == slun) || (lun == CAM_LUN_WILDCARD));
	if (match != 0) {
#if AHC_TARGET_MODE
		int group;
d4492 9
a4500 13
		group = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);
		if (role == ROLE_INITIATOR) {
			match = (group != XPT_FC_GROUP_TMODE)
			      && ((tag == scb->hscb->tag)
			       || (tag == SCB_LIST_NULL));
		} else if (role == ROLE_TARGET) {
			match = (group == XPT_FC_GROUP_TMODE)
			      && ((tag == scb->io_ctx->csio.tag_id)
			       || (tag == SCB_LIST_NULL));
		}
#else /* !AHC_TARGET_MODE */
		match = ((tag == scb->hscb->tag) || (tag == SCB_LIST_NULL));
#endif /* AHC_TARGET_MODE */
d4502 2
d4505 26
a4530 2
	return match;
}
d4532 13
a4544 16
void
ahc_freeze_devq(struct ahc_softc *ahc, struct scb *scb)
{
	int	target;
	char	channel;
	int	lun;

	target = SCB_GET_TARGET(ahc, scb);
	lun = SCB_GET_LUN(scb);
	channel = SCB_GET_CHANNEL(ahc, scb);
	
	ahc_search_qinfifo(ahc, target, channel, lun,
			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
			   CAM_REQUEUE_REQ, SEARCH_COMPLETE);

	ahc_platform_freeze_devq(ahc, scb);
d4547 4
a4550 2
void
ahc_qinfifo_requeue_tail(struct ahc_softc *ahc, struct scb *scb)
d4552 2
a4553 1
	struct scb *prev_scb;
d4555 6
a4560 4
	prev_scb = NULL;
	if (ahc_qinfifo_count(ahc) != 0) {
		u_int prev_tag;
		uint8_t prev_pos;
d4562 5
a4566 11
		prev_pos = ahc->qinfifonext - 1;
		prev_tag = ahc->qinfifo[prev_pos];
		prev_scb = ahc_lookup_scb(ahc, prev_tag);
	}
	ahc_qinfifo_requeue(ahc, prev_scb, scb);
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}
}
d4568 5
a4572 10
static void
ahc_qinfifo_requeue(struct ahc_softc *ahc, struct scb *prev_scb,
		    struct scb *scb)
{
	if (prev_scb == NULL) {
		ahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);
	} else {
		prev_scb->hscb->next = scb->hscb->tag;
		ahc_sync_scb(ahc, prev_scb, 
			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
a4573 3
	ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;
	scb->hscb->next = ahc->next_queued_scb->hscb->tag;
	ahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d4575 1
d4577 3
a4579 2
static int
ahc_qinfifo_count(struct ahc_softc *ahc)
d4581 5
a4585 2
	u_int8_t qinpos;
	u_int8_t diff;
d4587 5
a4591 8
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		qinpos = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinpos);
	} else
		qinpos = ahc_inb(ahc, QINPOS);
	diff = ahc->qinfifonext - qinpos;
	return (diff);
}
d4593 6
a4598 16
int
ahc_search_qinfifo(struct ahc_softc *ahc, int target, char channel,
		   int lun, u_int tag, role_t role, uint32_t status,
		   ahc_search_action action)
{
	struct	scb *scb;
	struct	scb *prev_scb;
	uint8_t qinstart;
	uint8_t qinpos;
	uint8_t qintail;
	uint8_t next, prev;
	uint8_t curscbptr;
	int	found;
	int	maxtarget;
	int	i;
	int	have_qregs;
d4600 2
a4601 36
	qintail = ahc->qinfifonext;
	have_qregs = (ahc->features & AHC_QUEUE_REGS) != 0;
	if (have_qregs) {
		qinstart = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinstart);
	} else
		qinstart = ahc_inb(ahc, QINPOS);
	qinpos = qinstart;
	next = ahc_inb(ahc, NEXT_QUEUED_SCB);
	found = 0;
	prev_scb = NULL;
	
	if (action == SEARCH_COMPLETE) {
		/*
		 * Don't attempt to run any queued untagged transactions
		 * until we are done with the abort process.
		 */
		ahc_freeze_untagged_queues(ahc);
	}

	/*
	 * Start with an empty queue.  Entries that are not chosen
	 * for removal will be re-added to the queue as we go.
	 */
	ahc->qinfifonext = qinpos;
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);

	while (qinpos != qintail) {
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinpos]);
		if (scb == NULL) {
			printf("qinpos = %d, SCB index = %d\n",
				qinpos, ahc->qinfifo[qinpos]);
			panic("Loop 1");
		}

		if (ahc_match_scb(ahc, scb, target, channel, lun, tag, role)) {
d4603 2
a4604 1
			 * We found an scb that needs to be acted on.
d4606 1
a4606 29
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;

				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb,
								   status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in qinfifo\n");
				ahc_done(ahc, scb);
				/* FALLTHROUGH */
			}
			case SEARCH_REMOVE:
				break;
			case SEARCH_COUNT:
				ahc_qinfifo_requeue(ahc, prev_scb, scb);
				prev_scb = scb;
				break;
			}
		} else {
			ahc_qinfifo_requeue(ahc, prev_scb, scb);
			prev_scb = scb;
d4608 2
a4609 1
		qinpos++;
d4611 2
d4614 3
a4616 5
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}
d4618 10
a4627 16
	if (action != SEARCH_COUNT
	 && (found != 0)
	 && (qinstart != ahc->qinfifonext)) {
		/*
		 * The sequencer may be in the process of dmaing
		 * down the SCB at the beginning of the queue.
		 * This could be problematic if either the first,
		 * or the second SCB is removed from the queue
		 * (the first SCB includes a pointer to the "next"
		 * SCB to dma). If we have removed any entries, swap
		 * the first element in the queue with the next HSCB
		 * so the sequencer will notice that NEXT_QUEUED_SCB
		 * has changed during its dma attempt and will retry
		 * the DMA.
		 */
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinstart]);
d4629 3
a4631 25
		if (scb == NULL) {
			printf("found = %d, qinstart = %d, qinfifionext = %d\n",
				found, qinstart, ahc->qinfifonext);
			panic("First/Second Qinfifo fixup");
		}
		/*
		 * ahc_swap_with_next_hscb forces our next pointer to
		 * point to the reserved SCB for future commands.  Save
		 * and restore our original next pointer to maintain
		 * queue integrity.
		 */
		next = scb->hscb->next;
		ahc->scb_data->scbindex[scb->hscb->tag] = NULL;
		ahc_swap_with_next_hscb(ahc, scb);
		scb->hscb->next = next;
		ahc->qinfifo[qinstart] = scb->hscb->tag;

		/* Tell the card about the new head of the qinfifo. */
		ahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);

		/* Fixup the tail "next" pointer. */
		qintail = ahc->qinfifonext - 1;
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qintail]);
		scb->hscb->next = ahc->next_queued_scb->hscb->tag;
	}
d4633 1
a4633 6
	/*
	 * Search waiting for selection list.
	 */
	curscbptr = ahc_inb(ahc, SCBPTR);
	next = ahc_inb(ahc, WAITING_SCBH);  /* Start at head of list. */
	prev = SCB_LIST_NULL;
d4635 1
a4635 2
	while (next != SCB_LIST_NULL) {
		uint8_t scb_index;
d4637 7
a4643 19
		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			printf("Waiting List inconsistency. "
			       "SCB index == %d, yet numscbs == %d.",
			       scb_index, ahc->scb_data->numscbs);
			ahc_dump_card_state(ahc);
			panic("for safety");
		}
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("scb_index = %d, next = %d\n",
				scb_index, next);
			panic("Waiting List traversal");
		}
		if (ahc_match_scb(ahc, scb, target, channel,
				  lun, SCB_LIST_NULL, role)) {
			/*
			 * We found an scb that needs to be acted on.
d4645 1
a4645 31
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;

				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb,
								   status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in Waiting List\n");
				ahc_done(ahc, scb);
				/* FALLTHROUGH */
			}
			case SEARCH_REMOVE:
				next = ahc_rem_wscb(ahc, next, prev);
				break;
			case SEARCH_COUNT:
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
				break;
			}
		} else {
			
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
a4647 1
	ahc_outb(ahc, SCBPTR, curscbptr);
d4649 4
a4652 5
	/*
	 * And lastly, the untagged holding queues.
	 */
	i = 0;
	if ((ahc->flags & AHC_SCB_BTT) == 0) {
d4654 2
a4655 2
		maxtarget = 16;
		if (target != CAM_TARGET_WILDCARD) {
d4657 10
a4666 8
			i = target;
			if (channel == 'B')
				i += 8;
			maxtarget = i + 1;
		}
	} else {
		maxtarget = 0;
	}
d4668 2
a4669 3
	for (; i < maxtarget; i++) {
		struct scb_tailq *untagged_q;
		struct scb *next_scb;
d4671 1
a4671 3
		untagged_q = &(ahc->untagged_queues[i]);
		next_scb = TAILQ_FIRST(untagged_q);
		while (next_scb != NULL) {
d4673 2
a4674 2
			scb = next_scb;
			next_scb = TAILQ_NEXT(scb, links.tqe);
d4676 17
a4692 11
			/*
			 * The head of the list may be the currently
			 * active untagged command for a device.
			 * We're only searching for commands that
			 * have not been started.  A transaction
			 * marked active but still in the qinfifo
			 * is removed by the qinfifo scanning code
			 * above.
			 */
			if ((scb->flags & SCB_ACTIVE) != 0)
				continue;
d4694 5
a4698 34
			if (ahc_match_scb(ahc, scb, target, channel,
					  lun, SCB_LIST_NULL, role)) {
				/*
				 * We found an scb that needs to be acted on.
				 */
				found++;
				switch (action) {
				case SEARCH_COMPLETE:
				{
					cam_status ostat;
					cam_status cstat;

					ostat = ahc_get_transaction_status(scb);
					if (ostat == CAM_REQ_INPROG)
						ahc_set_transaction_status(scb,
								   status);
					cstat = ahc_get_transaction_status(scb);
					if (cstat != CAM_REQ_CMP)
						ahc_freeze_scb(scb);
					if ((scb->flags & SCB_ACTIVE) == 0)
						printf("Inactive SCB in untaggedQ\n");
					ahc_done(ahc, scb);
					break;
				}
				case SEARCH_REMOVE:
					TAILQ_REMOVE(untagged_q, scb,
						     links.tqe);
					break;
				case SEARCH_COUNT:
					break;
				}
			}
		}
	}
d4700 1
a4700 4
	if (action == SEARCH_COMPLETE)
		ahc_release_untagged_queues(ahc);
	return (found);
}
d4702 1
a4702 10
int
ahc_search_disc_list(struct ahc_softc *ahc, int target, char channel,
		     int lun, u_int tag, int stop_on_first, int remove,
		     int save_state)
{
	struct	scb *scbp;
	u_int	next;
	u_int	prev;
	u_int	count;
	u_int	active_scb;
d4704 2
a4705 3
	count = 0;
	next = ahc_inb(ahc, DISCONNECTED_SCBH);
	prev = SCB_LIST_NULL;
d4707 25
a4731 6
	if (save_state) {
		/* restore this when we're done */
		active_scb = ahc_inb(ahc, SCBPTR);
	} else
		/* Silence compiler */
		active_scb = SCB_LIST_NULL;
d4733 3
a4735 12
	while (next != SCB_LIST_NULL) {
		u_int scb_index;

		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			printf("Disconnected List inconsistency. "
			       "SCB index == %d, yet numscbs == %d.",
			       scb_index, ahc->scb_data->numscbs);
			ahc_dump_card_state(ahc);
			panic("for safety");
		}
d4737 14
a4750 12
		if (next == prev) {
			panic("Disconnected List Loop. "
			      "cur SCBPTR == %x, prev SCBPTR == %x.",
			      next, prev);
		}
		scbp = ahc_lookup_scb(ahc, scb_index);
		if (ahc_match_scb(ahc, scbp, target, channel, lun,
				  tag, ROLE_INITIATOR)) {
			count++;
			if (remove) {
				next =
				    ahc_rem_scb_from_disc_list(ahc, prev, next);
d4752 6
a4757 2
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
a4758 5
			if (stop_on_first)
				break;
		} else {
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
d4760 6
a4766 3
	if (save_state)
		ahc_outb(ahc, SCBPTR, active_scb);
	return (count);
d4769 4
a4772 32
/*
 * Remove an SCB from the on chip list of disconnected transactions.
 * This is empty/unused if we are not performing SCB paging.
 */
static u_int
ahc_rem_scb_from_disc_list(struct ahc_softc *ahc, u_int prev, u_int scbptr)
{
	u_int next;

	ahc_outb(ahc, SCBPTR, scbptr);
	next = ahc_inb(ahc, SCB_NEXT);

	ahc_outb(ahc, SCB_CONTROL, 0);

	ahc_add_curscb_to_free_list(ahc);

	if (prev != SCB_LIST_NULL) {
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	} else
		ahc_outb(ahc, DISCONNECTED_SCBH, next);

	return (next);
}

/*
 * Add the SCB as selected by SCBPTR onto the on chip list of
 * free hardware SCBs.  This list is empty/unused if we are not
 * performing SCB paging.
 */
static void
ahc_add_curscb_to_free_list(struct ahc_softc *ahc)
a4773 31
	/*
	 * Invalidate the tag so that our abort
	 * routines don't think it's active.
	 */
	ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);

	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		ahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));
		ahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));
	}
}

/*
 * Manipulate the waiting for selection list and return the
 * scb that follows the one that we remove.
 */
static u_int
ahc_rem_wscb(struct ahc_softc *ahc, u_int scbpos, u_int prev)
{       
	u_int curscb, next;

	/*
	 * Select the SCB we want to abort and
	 * pull the next pointer out of it.
	 */
	curscb = ahc_inb(ahc, SCBPTR);
	ahc_outb(ahc, SCBPTR, scbpos);
	next = ahc_inb(ahc, SCB_NEXT);

	/* Clear the necessary fields */
	ahc_outb(ahc, SCB_CONTROL, 0);
d4775 2
a4776 1
	ahc_add_curscb_to_free_list(ahc);
d4778 1
a4778 4
	/* update the waiting list */
	if (prev == SCB_LIST_NULL) {
		/* First in the list */
		ahc_outb(ahc, WAITING_SCBH, next); 
d4781 3
a4783 2
		 * Ensure we aren't attempting to perform
		 * selection for this entry.
d4785 2
a4786 2
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else {
d4788 3
a4790 2
		 * Select the scb that pointed to us 
		 * and update its next pointer.
d4792 5
a4796 2
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
a4797 6

	/*
	 * Point us back at the original scb position.
	 */
	ahc_outb(ahc, SCBPTR, curscb);
	return next;
d4800 2
a4801 10
/******************************** Error Handling ******************************/
/*
 * Abort all SCBs that match the given description (target/channel/lun/tag),
 * setting their status to the passed in status if the status has not already
 * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
 * is paused before it is called.
 */
int
ahc_abort_scbs(struct ahc_softc *ahc, int target, char channel,
	       int lun, u_int tag, role_t role, uint32_t status)
d4803 8
a4810 15
	struct	scb *scbp;
	struct	scb *scbp_next;
	u_int	active_scb;
	int	i, j;
	int	maxtarget;
	int	minlun;
	int	maxlun;

	int	found;

	/*
	 * Don't attempt to run any queued untagged transactions
	 * until we are done with the abort process.
	 */
	ahc_freeze_untagged_queues(ahc);
d4812 2
a4813 2
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
d4815 1
a4815 2
	found = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,
				   role, CAM_REQUEUE_REQ, SEARCH_COMPLETE);
d4818 4
a4821 1
	 * Clean out the busy target table for any untagged commands.
d4823 4
a4826 8
	i = 0;
	maxtarget = 16;
	if (target != CAM_TARGET_WILDCARD) {
		i = target;
		if (channel == 'B')
			i += 8;
		maxtarget = i + 1;
	}
d4828 6
a4833 15
	if (lun == CAM_LUN_WILDCARD) {

		/*
		 * Unless we are using an SCB based
		 * busy targets table, there is only
		 * one table entry for all luns of
		 * a target.
		 */
		minlun = 0;
		maxlun = 1;
		if ((ahc->flags & AHC_SCB_BTT) != 0)
			maxlun = AHC_NUM_LUNS;
	} else {
		minlun = lun;
		maxlun = lun + 1;
d4836 3
a4838 14
	for (;i < maxtarget; i++) {
		for (j = minlun;j < maxlun; j++)
			ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, j));
	}

	/*
	 * Go through the disconnected list and remove any entries we
	 * have queued for completion, 0'ing their control byte too.
	 * We save the active SCB and restore it ourselves, so there
	 * is no reason for this search to restore it too.
	 */
	ahc_search_disc_list(ahc, target, channel, lun, tag,
			     /*stop_on_first*/FALSE, /*remove*/TRUE,
			     /*save_state*/FALSE);
d4840 2
d4843 2
a4844 2
	 * Go through the hardware SCB array looking for commands that
	 * were active but not on any list.
d4846 1
a4846 2
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scbid;
d4848 3
a4850 6
		ahc_outb(ahc, SCBPTR, i);
		scbid = ahc_inb(ahc, SCB_TAG);
		scbp = ahc_lookup_scb(ahc, scbid);
		if (scbp != NULL
		 && ahc_match_scb(ahc, scbp, target, channel, lun, tag, role))
			ahc_add_curscb_to_free_list(ahc);
d4852 30
a4881 23

	/*
	 * Go through the pending CCB list and look for
	 * commands for this target that are still active.
	 * These are other tagged commands that were
	 * disconnected when the reset occurred.
	 */
	scbp_next = LIST_FIRST(&ahc->pending_scbs);
	while (scbp_next != NULL) {
		scbp = scbp_next;
		scbp_next = LIST_NEXT(scbp, pending_links);
		if (ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)) {
			cam_status ostat;

			ostat = ahc_get_transaction_status(scbp);
			if (ostat == CAM_REQ_INPROG)
				ahc_set_transaction_status(scbp, status);
			if (ahc_get_transaction_status(scbp) != CAM_REQ_CMP)
				ahc_freeze_scb(scbp);
			if ((scbp->flags & SCB_ACTIVE) == 0)
				printf("Inactive SCB on pending list\n");
			ahc_done(ahc, scbp);
			found++;
d4884 35
a4918 5
	ahc_outb(ahc, SCBPTR, active_scb);
	ahc_platform_abort_scbs(ahc, target, channel, lun, tag, role, status);
	ahc_release_untagged_queues(ahc);
	return found;
}
d4920 1
a4920 4
static void
ahc_reset_current_bus(struct ahc_softc *ahc)
{
	uint8_t scsiseq;
d4922 3
a4924 6
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);
	scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);
	ahc_delay(AHC_BUSRESET_DELAY);
	/* Turn off the bus reset */
	ahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);
d4926 22
a4947 1
	ahc_clear_intstat(ahc);
d4949 2
a4950 3
	/* Re-enable reset interrupts */
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);
}
d4952 8
a4959 11
int
ahc_reset_channel(struct ahc_softc *ahc, char channel, int initiate_reset)
{
	struct	ahc_devinfo devinfo;
	u_int	initiator, target, max_scsiid;
	u_int	sblkctl;
	u_int	scsiseq;
	u_int	simode1;
	int	found;
	int	restart_needed;
	char	cur_channel;
d4961 5
a4965 1
	ahc->pending_device = NULL;
d4967 10
a4976 6
	ahc_compile_devinfo(&devinfo,
			    CAM_TARGET_WILDCARD,
			    CAM_TARGET_WILDCARD,
			    CAM_LUN_WILDCARD,
			    channel, ROLE_UNKNOWN);
	ahc_pause(ahc);
d4978 14
a4991 67
	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);

	/*
	 * Run our command complete fifos to ensure that we perform
	 * completion processing on any commands that 'completed'
	 * before the reset occurred.
	 */
	ahc_run_qoutfifo(ahc);
#if AHC_TARGET_MODE
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		ahc_run_tqinfifo(ahc, /*paused*/TRUE);
	}
#endif

	/*
	 * Reset the bus if we are initiating this reset
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	cur_channel = 'A';
	if ((ahc->features & AHC_TWIN) != 0
	 && ((sblkctl & SELBUSB) != 0))
	    cur_channel = 'B';
	scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
	if (cur_channel != channel) {
		/* Case 1: Command for another bus is active
		 * Stealthily reset the other bus without
		 * upsetting the current bus.
		 */
		ahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);
		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
#if AHC_TARGET_MODE
		/*
		 * Bus resets clear ENSELI, so we cannot
		 * defer re-enabling bus reset interrupts
		 * if we are in target mode.
		 */
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			ahc_outb(ahc, SIMODE1, simode1 | ENSCSIRST);
#endif
		ahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));
		ahc_outb(ahc, SBLKCTL, sblkctl);
		restart_needed = FALSE;
	} else {
		/* Case 2: A command from this bus is active or we're idle */
		ahc_clear_msg_state(ahc);
		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
#if AHC_TARGET_MODE
		/*
		 * Bus resets clear ENSELI, so we cannot
		 * defer re-enabling bus reset interrupts
		 * if we are in target mode.
		 */
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			ahc_outb(ahc, SIMODE1, simode1 | ENSCSIRST);
#endif
		ahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));
		restart_needed = TRUE;
	}
d4993 7
a4999 7
	/*
	 * Clean up all the state information for the
	 * pending transactions on this bus.
	 */
	found = ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, channel,
			       CAM_LUN_WILDCARD, SCB_LIST_NULL,
			       ROLE_UNKNOWN, CAM_SCSI_BUS_RESET);
d5001 2
a5002 10
	max_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;
	
#ifdef AHC_TARGET_MODE
	/*
	 * Send an immediate notify ccb to all target more peripheral
	 * drivers affected by this action.
	 */
	for (target = 0; target <= max_scsiid; target++) {
		struct ahc_tmode_tstate* tstate;
		u_int lun;
d5004 7
a5010 5
		tstate = ahc->enabled_targets[target];
		if (tstate == NULL)
			continue;
		for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
			struct ahc_tmode_lstate* lstate;
d5012 21
a5032 3
			lstate = tstate->enabled_luns[lun];
			if (lstate == NULL)
				continue;
d5034 42
a5075 3
			ahc_queue_lstate_event(ahc, lstate, CAM_TARGET_WILDCARD,
					       EVENT_TYPE_BUS_RESET, /*arg*/0);
			ahc_send_lstate_events(ahc, lstate);
d5078 22
a5099 4
#endif
	/* Notify the XPT that a bus reset occurred */
	ahc_send_async(ahc, devinfo.channel, CAM_TARGET_WILDCARD,
		       CAM_LUN_WILDCARD, AC_BUS_RESET, NULL);
d5102 2
a5103 1
	 * Revert to async/narrow transfers until we renegotiate.
d5105 3
a5107 1
	for (target = 0; target <= max_scsiid; target++) {
d5109 25
a5133 14
		if (ahc->enabled_targets[target] == NULL)
			continue;
		for (initiator = 0; initiator <= max_scsiid; initiator++) {
			struct ahc_devinfo devinfo;

			ahc_compile_devinfo(&devinfo, target, initiator,
					    CAM_LUN_WILDCARD,
					    channel, ROLE_UNKNOWN);
			ahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
				      AHC_TRANS_CUR, /*paused*/TRUE);
			ahc_set_syncrate(ahc, &devinfo, /*syncrate*/NULL,
					 /*period*/0, /*offset*/0,
					 /*ppr_options*/0, AHC_TRANS_CUR,
					 /*paused*/TRUE);
d5135 9
d5146 1
a5146 5
	if (restart_needed)
		ahc_restart(ahc);
	else
		ahc_unpause(ahc);
	return found;
a5148 2

/***************************** Residual Processing ****************************/
d5150 4
a5153 1
 * Calculate the residual for a just completed SCB.
d5155 9
a5163 2
void
ahc_calc_residual(struct scb *scb)
d5165 4
a5168 21
	struct hardware_scb *hscb;
	struct status_pkt *spkt;
	uint32_t sgptr;
	uint32_t resid_sgptr;
	uint32_t resid;

	/*
	 * 5 cases.
	 * 1) No residual.
	 *    SG_RESID_VALID clear in sgptr.
	 * 2) Transferless command
	 * 3) Never performed any transfers.
	 *    sgptr has SG_FULL_RESID set.
	 * 4) No residual but target did not
	 *    save data pointers after the
	 *    last transfer, so sgptr was
	 *    never updated.
	 * 5) We have a partial residual.
	 *    Use residual_sgptr to determine
	 *    where we are.
	 */
d5170 2
a5171 6
	hscb = scb->hscb;
	sgptr = ahc_le32toh(hscb->sgptr);
	if ((sgptr & SG_RESID_VALID) == 0)
		/* Case 1 */
		return;
	sgptr &= ~SG_RESID_VALID;
d5173 2
a5174 3
	if ((sgptr & SG_LIST_NULL) != 0)
		/* Case 2 */
		return;
d5176 8
a5183 12
	spkt = &hscb->shared_data.status;
	resid_sgptr = ahc_le32toh(spkt->residual_sg_ptr);
	if ((sgptr & SG_FULL_RESID) != 0) {
		/* Case 3 */
		resid = ahc_get_transfer_length(scb);
	} else if ((resid_sgptr & SG_LIST_NULL) != 0) {
		/* Case 4 */
		return;
	} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {
		panic("Bogus resid sgptr value 0x%x", resid_sgptr);
	} else {
		struct ahc_dma_seg *sg;
d5185 2
a5186 6
		/*
		 * Remainder of the SG where the transfer
		 * stopped.
		 */
		resid = ahc_le32toh(spkt->residual_datacnt) & AHC_SG_LEN_MASK;
		sg = ahc_sg_bus_to_virt(scb, resid_sgptr & SG_PTR_MASK);
d5188 10
a5197 2
		/* The residual sg_ptr always points to the next sg */
		sg--;
d5199 6
a5204 8
		/*
		 * Add up the contents of all residual
		 * SG segments that are after the SG where
		 * the transfer stopped.
		 */
		while ((ahc_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {
			sg++;
			resid += ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
d5207 16
a5222 4
	if ((scb->flags & SCB_SENSE) == 0)
		ahc_set_residual(scb, resid);
	else
		ahc_set_sense_residual(scb, resid);
d5224 6
a5229 4
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC) {
		ahc_print_path(scb->ahc_softc, scb);
		printf("Handled Residual of %d bytes\n", resid);
a5230 2
#endif
}
d5232 8
a5239 18
/******************************* Target Mode **********************************/
#ifdef AHC_TARGET_MODE
/*
 * Add a target mode event to this lun's queue
 */
static void
ahc_queue_lstate_event(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate,
		       u_int initiator_id, u_int event_type, u_int event_arg)
{
	struct ahc_tmode_event *event;
	int pending;

	xpt_freeze_devq(lstate->path, /*count*/1);
	if (lstate->event_w_idx >= lstate->event_r_idx)
		pending = lstate->event_w_idx - lstate->event_r_idx;
	else
		pending = AHC_TMODE_EVENT_BUFFER_SIZE + 1
			- (lstate->event_r_idx - lstate->event_w_idx);
d5241 12
a5252 59
	if (event_type == EVENT_TYPE_BUS_RESET
	 || event_type == MSG_BUS_DEV_RESET) {
		/*
		 * Any earlier events are irrelevant, so reset our buffer.
		 * This has the effect of allowing us to deal with reset
		 * floods (an external device holding down the reset line)
		 * without losing the event that is really interesting.
		 */
		lstate->event_r_idx = 0;
		lstate->event_w_idx = 0;
		xpt_release_devq(lstate->path, pending, /*runqueue*/FALSE);
	}

	if (pending == AHC_TMODE_EVENT_BUFFER_SIZE) {
		xpt_print_path(lstate->path);
		printf("immediate event %x:%x lost\n",
		       lstate->event_buffer[lstate->event_r_idx].event_type,
		       lstate->event_buffer[lstate->event_r_idx].event_arg);
		lstate->event_r_idx++;
		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
			lstate->event_r_idx = 0;
		xpt_release_devq(lstate->path, /*count*/1, /*runqueue*/FALSE);
	}

	event = &lstate->event_buffer[lstate->event_w_idx];
	event->initiator_id = initiator_id;
	event->event_type = event_type;
	event->event_arg = event_arg;
	lstate->event_w_idx++;
	if (lstate->event_w_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
		lstate->event_w_idx = 0;
}

/*
 * Send any target mode events queued up waiting
 * for immediate notify resources.
 */
void
ahc_send_lstate_events(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate)
{
	struct ccb_hdr *ccbh;
	struct ccb_immed_notify *inot;

	while (lstate->event_r_idx != lstate->event_w_idx
	    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {
		struct ahc_tmode_event *event;

		event = &lstate->event_buffer[lstate->event_r_idx];
		SLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);
		inot = (struct ccb_immed_notify *)ccbh;
		switch (event->event_type) {
		case EVENT_TYPE_BUS_RESET:
			ccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;
			break;
		default:
			ccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;
			inot->message_args[0] = event->event_type;
			inot->message_args[1] = event->event_arg;
			break;
a5253 6
		inot->initiator_id = event->initiator_id;
		inot->sense_len = 0;
		xpt_done((union ccb *)inot);
		lstate->event_r_idx++;
		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
			lstate->event_r_idx = 0;
d5255 2
a5257 1
#endif
d5259 11
a5269 5
/******************** Sequencer Program Patching/Download *********************/

#ifdef AHC_DUMP_SEQ
void
ahc_dumpseq(struct ahc_softc* ahc)
d5271 5
a5275 2
	int i;
	int max_prog;
d5277 3
a5279 6
	if ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)
		max_prog = 448;
	else if ((ahc->features & AHC_ULTRA2) != 0)
		max_prog = 768;
	else
		max_prog = 512;
d5281 6
a5286 5
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	for (i = 0; i < max_prog; i++) {
		uint8_t ins_bytes[4];
d5288 2
a5289 8
		ahc_insb(ahc, SEQRAM, ins_bytes, 4);
		printf("0x%08x\n", ins_bytes[0] << 24
				 | ins_bytes[1] << 16
				 | ins_bytes[2] << 8
				 | ins_bytes[3]);
	}
}
#endif
d5291 6
a5296 52
static void
ahc_loadseq(struct ahc_softc *ahc)
{
	struct	cs cs_table[num_critical_sections];
	u_int	begin_set[num_critical_sections];
	u_int	end_set[num_critical_sections];
	struct	patch *cur_patch;
	u_int	cs_count;
	u_int	cur_cs;
	u_int	i;
	int	downloaded;
	u_int	skip_addr;
	u_int	sg_prefetch_cnt;
	uint8_t	download_consts[7];

	/*
	 * Start out with 0 critical sections
	 * that apply to this firmware load.
	 */
	cs_count = 0;
	cur_cs = 0;
	memset(begin_set, 0, sizeof(begin_set));
	memset(end_set, 0, sizeof(end_set));

	/* Setup downloadable constant table */
	download_consts[QOUTFIFO_OFFSET] = 0;
	if (ahc->targetcmds != NULL)
		download_consts[QOUTFIFO_OFFSET] += 32;
	download_consts[QINFIFO_OFFSET] = download_consts[QOUTFIFO_OFFSET] + 1;
	download_consts[CACHESIZE_MASK] = ahc->pci_cachesize - 1;
	download_consts[INVERTED_CACHESIZE_MASK] = ~(ahc->pci_cachesize - 1);
	sg_prefetch_cnt = ahc->pci_cachesize;
	if (sg_prefetch_cnt < (2 * sizeof(struct ahc_dma_seg)))
		sg_prefetch_cnt = 2 * sizeof(struct ahc_dma_seg);
	download_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;
	download_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_cnt - 1);
	download_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_cnt - 1);

	cur_patch = patches;
	downloaded = 0;
	skip_addr = 0;
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);

	for (i = 0; i < sizeof(seqprog)/4; i++) {
		if (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {
			/*
			 * Don't download this instruction as it
			 * is in a patch that was removed.
			 */
			continue;
d5298 10
a5307 13
		/*
		 * Move through the CS table until we find a CS
		 * that might apply to this instruction.
		 */
		for (; cur_cs < num_critical_sections; cur_cs++) {
			if (critical_sections[cur_cs].end <= i) {
				if (begin_set[cs_count] == TRUE
				 && end_set[cs_count] == FALSE) {
					cs_table[cs_count].end = downloaded;
				 	end_set[cs_count] = TRUE;
					cs_count++;
				}
				continue;
d5309 5
a5313 6
			if (critical_sections[cur_cs].begin <= i
			 && begin_set[cs_count] == FALSE) {
				cs_table[cs_count].begin = downloaded;
				begin_set[cs_count] = TRUE;
			}
			break;
a5314 2
		ahc_download_instr(ahc, i, download_consts);
		downloaded++;
d5316 3
a5318 15

	ahc->num_critical_sections = cs_count;
	if (cs_count != 0) {

		cs_count *= sizeof(struct cs);
		ahc->critical_sections = malloc(cs_count, M_DEVBUF, M_NOWAIT);
		if (ahc->critical_sections == NULL)
			panic("ahc_loadseq: Could not malloc");
		memcpy(ahc->critical_sections, cs_table, cs_count);
	}
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);
	ahc_restart(ahc);

	if (bootverbose)
		printf(" %d instructions downloaded\n", downloaded);
d5321 5
a5325 3
static int
ahc_check_patch(struct ahc_softc *ahc, struct patch **start_patch,
		u_int start_instr, u_int *skip_addr)
d5327 4
a5330 3
	struct	patch *cur_patch;
	struct	patch *last_patch;
	u_int	num_patches;
d5332 1
a5332 3
	num_patches = sizeof(patches)/sizeof(struct patch);
	last_patch = &patches[num_patches];
	cur_patch = *start_patch;
d5334 1
a5334 1
	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
d5336 5
a5340 1
		if (cur_patch->patch_func(ahc) == 0) {
d5342 2
a5343 11
			/* Start rejecting code */
			*skip_addr = start_instr + cur_patch->skip_instr;
			cur_patch += cur_patch->skip_patch;
		} else {
			/* Accepted this patch.  Advance to the next
			 * one and wait for our intruction pointer to
			 * hit this point.
			 */
			cur_patch++;
		}
	}
d5345 6
a5350 4
	*start_patch = cur_patch;
	if (start_instr < *skip_addr)
		/* Still skipping */
		return (0);
d5352 2
a5353 1
	return (1);
d5356 11
a5366 7
static void
ahc_download_instr(struct ahc_softc *ahc, u_int instrptr, uint8_t *dconsts)
{
	union	ins_formats instr;
	struct	ins_format1 *fmt1_ins;
	struct	ins_format3 *fmt3_ins;
	u_int	opcode;
d5369 2
a5370 1
	 * The firmware is always compiled into a little endian format.
d5372 6
a5377 1
	instr.integer = ahc_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
d5379 1
a5379 2
	fmt1_ins = &instr.format1;
	fmt3_ins = NULL;
d5381 4
a5384 17
	/* Pull the opcode */
	opcode = instr.format1.opcode;
	switch (opcode) {
	case AIC_OP_JMP:
	case AIC_OP_JC:
	case AIC_OP_JNC:
	case AIC_OP_CALL:
	case AIC_OP_JNE:
	case AIC_OP_JNZ:
	case AIC_OP_JE:
	case AIC_OP_JZ:
	{
		struct patch *cur_patch;
		int address_offset;
		u_int address;
		u_int skip_addr;
		u_int i;
d5386 13
a5398 5
		fmt3_ins = &instr.format3;
		address_offset = 0;
		address = fmt3_ins->address;
		cur_patch = patches;
		skip_addr = 0;
d5400 6
a5405 1
		for (i = 0; i < address;) {
d5407 11
a5417 1
			ahc_check_patch(ahc, &cur_patch, i, &skip_addr);
d5419 5
a5423 2
			if (skip_addr > i) {
				int end_addr;
d5425 6
a5430 40
				end_addr = MIN(address, skip_addr);
				address_offset += end_addr - i;
				i = skip_addr;
			} else {
				i++;
			}
		}
		address -= address_offset;
		fmt3_ins->address = address;
		/* FALLTHROUGH */
	}
	case AIC_OP_OR:
	case AIC_OP_AND:
	case AIC_OP_XOR:
	case AIC_OP_ADD:
	case AIC_OP_ADC:
	case AIC_OP_BMOV:
		if (fmt1_ins->parity != 0) {
			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
		}
		fmt1_ins->parity = 0;
		if ((ahc->features & AHC_CMD_CHAN) == 0
		 && opcode == AIC_OP_BMOV) {
			/*
			 * Block move was added at the same time
			 * as the command channel.  Verify that
			 * this is only a move of a single element
			 * and convert the BMOV to a MOV
			 * (AND with an immediate of FF).
			 */
			if (fmt1_ins->immediate != 1)
				panic("%s: BMOV not supported",
				      ahc_name(ahc));
			fmt1_ins->opcode = AIC_OP_AND;
			fmt1_ins->immediate = 0xff;
		}
		/* FALLTHROUGH */
	case AIC_OP_ROL:
		if ((ahc->features & AHC_ULTRA2) != 0) {
			int i, count;
d5432 1
a5432 3
			/* Calculate odd parity for the instruction */
			for (i = 0, count = 0; i < 31; i++) {
				uint32_t mask;
d5434 2
a5435 31
				mask = 0x01 << i;
				if ((instr.integer & mask) != 0)
					count++;
			}
			if ((count & 0x01) == 0)
				instr.format1.parity = 1;
		} else {
			/* Compress the instruction for older sequencers */
			if (fmt3_ins != NULL) {
				instr.integer =
					fmt3_ins->immediate
				      | (fmt3_ins->source << 8)
				      | (fmt3_ins->address << 16)
				      |	(fmt3_ins->opcode << 25);
			} else {
				instr.integer =
					fmt1_ins->immediate
				      | (fmt1_ins->source << 8)
				      | (fmt1_ins->destination << 16)
				      |	(fmt1_ins->ret << 24)
				      |	(fmt1_ins->opcode << 25);
			}
		}
		/* The sequencer is a little endian cpu */
		instr.integer = ahc_htole32(instr.integer);
		ahc_outsb(ahc, SEQRAM, instr.bytes, 4);
		break;
	default:
		panic("Unknown opcode encountered in seq program");
		break;
	}
d5438 5
a5442 2
void
ahc_dump_card_state(struct ahc_softc *ahc)
d5444 17
a5460 11
	struct scb *scb;
	struct scb_tailq *untagged_q;
	int target;
	int maxtarget;
	int i;
	uint8_t last_phase;
	uint8_t qinpos;
	uint8_t qintail;
	uint8_t qoutpos;
	uint8_t scb_index;
	uint8_t saved_scbptr;
d5462 31
a5492 1
	saved_scbptr = ahc_inb(ahc, SCBPTR);
d5494 11
a5504 37
	last_phase = ahc_inb(ahc, LASTPHASE);
	printf("%s: Dumping Card State %s, at SEQADDR 0x%x\n",
	       ahc_name(ahc), ahc_lookup_phase_entry(last_phase)->phasemsg,
	       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
	printf("ACCUM = 0x%x, SINDEX = 0x%x, DINDEX = 0x%x, ARG_2 = 0x%x\n",
	       ahc_inb(ahc, ACCUM), ahc_inb(ahc, SINDEX), ahc_inb(ahc, DINDEX),
	       ahc_inb(ahc, ARG_2));
	printf("HCNT = 0x%x\n", ahc_inb(ahc, HCNT));
	printf("SCSISEQ = 0x%x, SBLKCTL = 0x%x\n",
	       ahc_inb(ahc, SCSISEQ), ahc_inb(ahc, SBLKCTL));
	printf(" DFCNTRL = 0x%x, DFSTATUS = 0x%x\n",
	       ahc_inb(ahc, DFCNTRL), ahc_inb(ahc, DFSTATUS));
	printf("LASTPHASE = 0x%x, SCSISIGI = 0x%x, SXFRCTL0 = 0x%x\n",
	       last_phase, ahc_inb(ahc, SCSISIGI), ahc_inb(ahc, SXFRCTL0));
	printf("SSTAT0 = 0x%x, SSTAT1 = 0x%x\n",
	       ahc_inb(ahc, SSTAT0), ahc_inb(ahc, SSTAT1));
	if ((ahc->features & AHC_DT) != 0)
		printf("SCSIPHASE = 0x%x\n", ahc_inb(ahc, SCSIPHASE));
	printf("STACK == 0x%x, 0x%x, 0x%x, 0x%x\n",
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8));
	printf("SCB count = %d\n", ahc->scb_data->numscbs);
	printf("Kernel NEXTQSCB = %d\n", ahc->next_queued_scb->hscb->tag);
	printf("Card NEXTQSCB = %d\n", ahc_inb(ahc, NEXT_QUEUED_SCB));
	/* QINFIFO */
	printf("QINFIFO entries: ");
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		qinpos = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinpos);
	} else
		qinpos = ahc_inb(ahc, QINPOS);
	qintail = ahc->qinfifonext;
	while (qinpos != qintail) {
		printf("%d ", ahc->qinfifo[qinpos]);
		qinpos++;
a5505 1
	printf("\n");
d5507 11
a5517 53
	printf("Waiting Queue entries: ");
	scb_index = ahc_inb(ahc, WAITING_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	printf("Disconnected Queue entries: ");
	scb_index = ahc_inb(ahc, DISCONNECTED_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");
		
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);
	printf("QOUTFIFO entries: ");
	qoutpos = ahc->qoutfifonext;
	i = 0;
	while (ahc->qoutfifo[qoutpos] != SCB_LIST_NULL && i++ < 256) {
		printf("%d ", ahc->qoutfifo[qoutpos]);
		qoutpos++;
	}
	printf("\n");

	printf("Sequencer Free SCB List: ");
	scb_index = ahc_inb(ahc, FREE_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d ", scb_index);
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	printf("Pending list: ");
	i = 0;
	LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
		if (i++ > 256)
			break;
		if (scb != LIST_FIRST(&ahc->pending_scbs))
			printf(", ");
		printf("%d", scb->hscb->tag);
		if ((ahc->flags & AHC_PAGESCBS) == 0) {
			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
			printf("(0x%x, 0x%x)", ahc_inb(ahc, SCB_CONTROL),
			       ahc_inb(ahc, SCB_TAG));
		}
a5518 1
	printf("\n");
d5520 6
a5525 8
	printf("Kernel Free SCB list: ");
	i = 0;
	SLIST_FOREACH(scb, &ahc->scb_data->free_scbs, links.sle) {
		if (i++ > 256)
			break;
		printf("%d ", scb->hscb->tag);
	}
	printf("\n");
d5527 1
a5527 4
	maxtarget = (ahc->features & (AHC_WIDE|AHC_TWIN)) ? 15 : 7;
	for (target = 0; target <= maxtarget; target++) {
		untagged_q = &ahc->untagged_queues[target];
		if (TAILQ_FIRST(untagged_q) == NULL)
d5529 16
a5544 6
		printf("Untagged Q(%d): ", target);
		i = 0;
		TAILQ_FOREACH(scb, untagged_q, links.tqe) {
			if (i++ > 256)
				break;
			printf("%d ", scb->hscb->tag);
a5545 1
		printf("\n");
d5548 5
a5552 2
	ahc_platform_dump_card_state(ahc);
	ahc_outb(ahc, SCBPTR, saved_scbptr);
d5555 13
a5567 22
/************************* Target Mode ****************************************/
#ifdef AHC_TARGET_MODE
cam_status
ahc_find_tmode_devs(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb,
		    struct ahc_tmode_tstate **tstate,
		    struct ahc_tmode_lstate **lstate,
		    int notfound_failure)
{

	if ((ahc->features & AHC_TARGETMODE) == 0)
		return (CAM_REQ_INVALID);

	/*
	 * Handle the 'black hole' device that sucks up
	 * requests to unattached luns on enabled targets.
	 */
	if (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD
	 && ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {
		*tstate = NULL;
		*lstate = ahc->black_hole;
	} else {
		u_int max_id;
d5569 7
a5575 3
		max_id = (ahc->features & AHC_WIDE) ? 15 : 7;
		if (ccb->ccb_h.target_id > max_id)
			return (CAM_TID_INVALID);
d5577 13
a5589 2
		if (ccb->ccb_h.target_lun >= AHC_NUM_LUNS)
			return (CAM_LUN_INVALID);
d5591 10
a5600 11
		*tstate = ahc->enabled_targets[ccb->ccb_h.target_id];
		*lstate = NULL;
		if (*tstate != NULL)
			*lstate =
			    (*tstate)->enabled_luns[ccb->ccb_h.target_lun];
	}

	if (notfound_failure != 0 && *lstate == NULL)
		return (CAM_PATH_INVALID);

	return (CAM_REQ_CMP);
d5603 3
a5605 2
void
ahc_handle_en_lun(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb)
d5607 1
a5607 9
	struct	   ahc_tmode_tstate *tstate;
	struct	   ahc_tmode_lstate *lstate;
	struct	   ccb_en_lun *cel;
	cam_status status;
	u_int	   target;
	u_int	   lun;
	u_int	   target_mask;
	u_long	   s;
	char	   channel;
d5609 1
a5609 2
	status = ahc_find_tmode_devs(ahc, sim, ccb, &tstate, &lstate,
				     /*notfound_failure*/FALSE);
d5611 17
a5627 4
	if (status != CAM_REQ_CMP) {
		ccb->ccb_h.status = status;
		return;
	}
d5629 8
a5636 2
	if ((ahc->features & AHC_MULTIROLE) != 0) {
		u_int	   our_id;
d5638 3
a5640 27
		if (cam_sim_bus(sim) == 0)
			our_id = ahc->our_id;
		else
			our_id = ahc->our_id_b;

		if (ccb->ccb_h.target_id != our_id) {
			if ((ahc->features & AHC_MULTI_TID) != 0
		   	 && (ahc->flags & AHC_INITIATORROLE) != 0) {
				/*
				 * Only allow additional targets if
				 * the initiator role is disabled.
				 * The hardware cannot handle a re-select-in
				 * on the initiator id during a re-select-out
				 * on a different target id.
				 */
				status = CAM_TID_INVALID;
			} else if ((ahc->flags & AHC_INITIATORROLE) != 0
				|| ahc->enabled_luns > 0) {
				/*
				 * Only allow our target id to change
				 * if the initiator role is not configured
				 * and there are no enabled luns which
				 * are attached to the currently registered
				 * scsi id.
				 */
				status = CAM_TID_INVALID;
			}
d5642 1
a5642 5
	}

	if (status != CAM_REQ_CMP) {
		ccb->ccb_h.status = status;
 		return;
d5646 2
a5647 2
	 * We now have an id that is valid.
	 * If we aren't in target mode, switch modes.
d5649 1
a5649 25
	if ((ahc->flags & AHC_TARGETROLE) == 0
	 && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
		u_long	s;

		printf("Configuring Target Mode\n");
		ahc_lock(ahc, &s);
		if (LIST_FIRST(&ahc->pending_scbs) != NULL) {
			ccb->ccb_h.status = CAM_BUSY;
			ahc_unlock(ahc, &s);
			return;
		}
		ahc->flags |= AHC_TARGETROLE;
		if ((ahc->features & AHC_MULTIROLE) == 0)
			ahc->flags &= ~AHC_INITIATORROLE;
		ahc_pause(ahc);
		ahc_loadseq(ahc);
		ahc_unlock(ahc, &s);
	}
	cel = &ccb->cel;
	target = ccb->ccb_h.target_id;
	lun = ccb->ccb_h.target_lun;
	channel = SIM_CHANNEL(ahc, sim);
	target_mask = 0x01 << target;
	if (channel == 'B')
		target_mask <<= 8;
d5651 7
a5657 2
	if (cel->enable != 0) {
		u_int scsiseq;
d5659 8
a5666 7
		/* Are we already enabled?? */
		if (lstate != NULL) {
			xpt_print_path(ccb->ccb_h.path);
			printf("Lun already enabled\n");
			ccb->ccb_h.status = CAM_LUN_ALRDY_ENA;
			return;
		}
d5668 14
a5681 125
		if (cel->grp6_len != 0
		 || cel->grp7_len != 0) {
			/*
			 * Don't (yet?) support vendor
			 * specific commands.
			 */
			ccb->ccb_h.status = CAM_REQ_INVALID;
			printf("Non-zero Group Codes\n");
			return;
		}

		/*	
		 * Seems to be okay.
		 * Setup our data structures.
		 */
		if (target != CAM_TARGET_WILDCARD && tstate == NULL) {
			tstate = ahc_alloc_tstate(ahc, target, channel);
			if (tstate == NULL) {
				xpt_print_path(ccb->ccb_h.path);
				printf("Couldn't allocate tstate\n");
				ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
				return;
			}
		}
		lstate = malloc(sizeof(*lstate), M_DEVBUF, M_NOWAIT);
		if (lstate == NULL) {
			xpt_print_path(ccb->ccb_h.path);
			printf("Couldn't allocate lstate\n");
			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
			return;
		}
		memset(lstate, 0, sizeof(*lstate));
		status = xpt_create_path(&lstate->path, /*periph*/NULL,
					 xpt_path_path_id(ccb->ccb_h.path),
					 xpt_path_target_id(ccb->ccb_h.path),
					 xpt_path_lun_id(ccb->ccb_h.path));
		if (status != CAM_REQ_CMP) {
			free(lstate, M_DEVBUF);
			xpt_print_path(ccb->ccb_h.path);
			printf("Couldn't allocate path\n");
			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
			return;
		}
		SLIST_INIT(&lstate->accept_tios);
		SLIST_INIT(&lstate->immed_notifies);
		ahc_lock(ahc, &s);
		ahc_pause(ahc);
		if (target != CAM_TARGET_WILDCARD) {
			tstate->enabled_luns[lun] = lstate;
			ahc->enabled_luns++;

			if ((ahc->features & AHC_MULTI_TID) != 0) {
				u_int targid_mask;

				targid_mask = ahc_inb(ahc, TARGID)
					    | (ahc_inb(ahc, TARGID + 1) << 8);

				targid_mask |= target_mask;
				ahc_outb(ahc, TARGID, targid_mask);
				ahc_outb(ahc, TARGID+1, (targid_mask >> 8));
				
				ahc_update_scsiid(ahc, targid_mask);
			} else {
				u_int our_id;
				char  channel;

				channel = SIM_CHANNEL(ahc, sim);
				our_id = SIM_SCSI_ID(ahc, sim);

				/*
				 * This can only happen if selections
				 * are not enabled
				 */
				if (target != our_id) {
					u_int sblkctl;
					char  cur_channel;
					int   swap;

					sblkctl = ahc_inb(ahc, SBLKCTL);
					cur_channel = (sblkctl & SELBUSB)
						    ? 'B' : 'A';
					if ((ahc->features & AHC_TWIN) == 0)
						cur_channel = 'A';
					swap = cur_channel != channel;
					if (channel == 'A')
						ahc->our_id = target;
					else
						ahc->our_id_b = target;

					if (swap)
						ahc_outb(ahc, SBLKCTL,
							 sblkctl ^ SELBUSB);

					ahc_outb(ahc, SCSIID, target);

					if (swap)
						ahc_outb(ahc, SBLKCTL, sblkctl);
				}
			}
		} else
			ahc->black_hole = lstate;
		/* Allow select-in operations */
		if (ahc->black_hole != NULL && ahc->enabled_luns > 0) {
			scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
			scsiseq |= ENSELI;
			ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);
			scsiseq = ahc_inb(ahc, SCSISEQ);
			scsiseq |= ENSELI;
			ahc_outb(ahc, SCSISEQ, scsiseq);
		}
		ahc_unpause(ahc);
		ahc_unlock(ahc, &s);
		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_print_path(ccb->ccb_h.path);
		printf("Lun now enabled for target mode\n");
	} else {
		struct scb *scb;
		int i, empty;

		if (lstate == NULL) {
			ccb->ccb_h.status = CAM_LUN_INVALID;
			return;
		}

		ahc_lock(ahc, &s);
d5683 20
a5702 13
		ccb->ccb_h.status = CAM_REQ_CMP;
		LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
			struct ccb_hdr *ccbh;

			ccbh = &scb->io_ctx->ccb_h;
			if (ccbh->func_code == XPT_CONT_TARGET_IO
			 && !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){
				printf("CTIO pending\n");
				ccb->ccb_h.status = CAM_REQ_INVALID;
				ahc_unlock(ahc, &s);
				return;
			}
		}
d5704 2
a5705 4
		if (SLIST_FIRST(&lstate->accept_tios) != NULL) {
			printf("ATIOs pending\n");
			ccb->ccb_h.status = CAM_REQ_INVALID;
		}
d5707 4
a5710 4
		if (SLIST_FIRST(&lstate->immed_notifies) != NULL) {
			printf("INOTs pending\n");
			ccb->ccb_h.status = CAM_REQ_INVALID;
		}
d5712 11
a5722 4
		if (ccb->ccb_h.status != CAM_REQ_CMP) {
			ahc_unlock(ahc, &s);
			return;
		}
d5724 21
a5744 42
		xpt_print_path(ccb->ccb_h.path);
		printf("Target mode disabled\n");
		xpt_free_path(lstate->path);
		free(lstate, M_DEVBUF);

		ahc_pause(ahc);
		/* Can we clean up the target too? */
		if (target != CAM_TARGET_WILDCARD) {
			tstate->enabled_luns[lun] = NULL;
			ahc->enabled_luns--;
			for (empty = 1, i = 0; i < 8; i++)
				if (tstate->enabled_luns[i] != NULL) {
					empty = 0;
					break;
				}

			if (empty) {
				ahc_free_tstate(ahc, target, channel,
						/*force*/FALSE);
				if (ahc->features & AHC_MULTI_TID) {
					u_int targid_mask;

					targid_mask = ahc_inb(ahc, TARGID)
						    | (ahc_inb(ahc, TARGID + 1)
						       << 8);

					targid_mask &= ~target_mask;
					ahc_outb(ahc, TARGID, targid_mask);
					ahc_outb(ahc, TARGID+1,
					 	 (targid_mask >> 8));
					ahc_update_scsiid(ahc, targid_mask);
				}
			}
		} else {

			ahc->black_hole = NULL;

			/*
			 * We can't allow selections without
			 * our black hole device.
			 */
			empty = TRUE;
a5745 21
		if (ahc->enabled_luns == 0) {
			/* Disallow select-in */
			u_int scsiseq;

			scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
			scsiseq &= ~ENSELI;
			ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);
			scsiseq = ahc_inb(ahc, SCSISEQ);
			scsiseq &= ~ENSELI;
			ahc_outb(ahc, SCSISEQ, scsiseq);

			if ((ahc->features & AHC_MULTIROLE) == 0) {
				printf("Configuring Initiator Mode\n");
				ahc->flags &= ~AHC_TARGETROLE;
				ahc->flags |= AHC_INITIATORROLE;
				ahc_pause(ahc);
				ahc_loadseq(ahc);
			}
		}
		ahc_unpause(ahc);
		ahc_unlock(ahc, &s);
d5747 1
d5750 2
a5751 2
static void
ahc_update_scsiid(struct ahc_softc *ahc, u_int targid_mask)
d5753 5
a5757 2
	u_int scsiid_mask;
	u_int scsiid;
d5759 1
a5759 2
	if ((ahc->features & AHC_MULTI_TID) == 0)
		panic("ahc_update_scsiid called on non-multitid unit");
d5762 4
a5765 4
	 * Since we will rely on the the TARGID mask
	 * for selection enables, ensure that OID
	 * in SCSIID is not set to some other ID
	 * that we don't want to allow selections on.
d5767 3
a5769 7
	if ((ahc->features & AHC_ULTRA2) != 0)
		scsiid = ahc_inb(ahc, SCSIID_ULTRA2);
	else
		scsiid = ahc_inb(ahc, SCSIID);
	scsiid_mask = 0x1 << (scsiid & OID);
	if ((targid_mask & scsiid_mask) == 0) {
		u_int our_id;
d5771 4
a5774 8
		/* ffs counts from 1 */
		our_id = ffs(targid_mask);
		if (our_id == 0)
			our_id = ahc->our_id;
		else
			our_id--;
		scsiid &= TID;
		scsiid |= our_id;
a5775 5
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, scsiid);
	else
		ahc_outb(ahc, SCSIID, scsiid);
}
d5777 4
a5780 4
void
ahc_run_tqinfifo(struct ahc_softc *ahc, int paused)
{
	struct target_cmd *cmd;
d5782 2
a5783 7
	/*
	 * If the card supports auto-access pause,
	 * we can access the card directly regardless
	 * of whether it is paused or not.
	 */
	if ((ahc->features & AHC_AUTOPAUSE) != 0)
		paused = TRUE;
d5785 6
a5790 2
	ahc_sync_tqinfifo(ahc, BUS_DMASYNC_POSTREAD);
	while ((cmd = &ahc->targetcmds[ahc->tqinfifonext])->cmd_valid != 0) {
d5792 3
a5794 6
		/*
		 * Only advance through the queue if we
		 * have the resources to process the command.
		 */
		if (ahc_handle_target_cmd(ahc, cmd) != 0)
			break;
d5796 2
a5797 30
		cmd->cmd_valid = 0;
		ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
				ahc->shared_data_dmamap,
				ahc_targetcmd_offset(ahc, ahc->tqinfifonext),
				sizeof(struct target_cmd),
				BUS_DMASYNC_PREREAD);
		ahc->tqinfifonext++;

		/*
		 * Lazily update our position in the target mode incoming
		 * command queue as seen by the sequencer.
		 */
		if ((ahc->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {
			if ((ahc->features & AHC_HS_MAILBOX) != 0) {
				u_int hs_mailbox;

				hs_mailbox = ahc_inb(ahc, HS_MAILBOX);
				hs_mailbox &= ~HOST_TQINPOS;
				hs_mailbox |= ahc->tqinfifonext & HOST_TQINPOS;
				ahc_outb(ahc, HS_MAILBOX, hs_mailbox);
			} else {
				if (!paused)
					ahc_pause(ahc);	
				ahc_outb(ahc, KERNEL_TQINPOS,
					 ahc->tqinfifonext & HOST_TQINPOS);
				if (!paused)
					ahc_unpause(ahc);
			}
		}
	}
d5800 4
a5803 2
static int
ahc_handle_target_cmd(struct ahc_softc *ahc, struct target_cmd *cmd)
d5805 1
a5805 7
	struct	  ahc_tmode_tstate *tstate;
	struct	  ahc_tmode_lstate *lstate;
	struct	  ccb_accept_tio *atio;
	uint8_t *byte;
	int	  initiator;
	int	  target;
	int	  lun;
d5807 2
a5808 3
	initiator = SCSIID_TARGET(ahc, cmd->scsiid);
	target = SCSIID_OUR_ID(cmd->scsiid);
	lun    = (cmd->identify & MSG_IDENTIFY_LUNMASK);
d5810 2
a5811 5
	byte = cmd->bytes;
	tstate = ahc->enabled_targets[target];
	lstate = NULL;
	if (tstate != NULL)
		lstate = tstate->enabled_luns[lun];
d5813 28
a5840 5
	/*
	 * Commands for disabled luns go to the black hole driver.
	 */
	if (lstate == NULL)
		lstate = ahc->black_hole;
d5842 10
a5851 15
	atio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);
	if (atio == NULL) {
		ahc->flags |= AHC_TQINFIFO_BLOCKED;
		/*
		 * Wait for more ATIOs from the peripheral driver for this lun.
		 */
		return (1);
	} else
		ahc->flags &= ~AHC_TQINFIFO_BLOCKED;
#if 0
	printf("Incoming command from %d for %d:%d%s\n",
	       initiator, target, lun,
	       lstate == ahc->black_hole ? "(Black Holed)" : "");
#endif
	SLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);
d5853 2
a5854 5
	if (lstate == ahc->black_hole) {
		/* Fill in the wildcards */
		atio->ccb_h.target_id = target;
		atio->ccb_h.target_lun = lun;
	}
d5857 2
a5858 2
	 * Package it up and send it off to
	 * whomever has this lun enabled.
d5860 4
a5863 11
	atio->sense_len = 0;
	atio->init_id = initiator;
	if (byte[0] != 0xFF) {
		/* Tag was included */
		atio->tag_action = *byte++;
		atio->tag_id = *byte++;
		atio->ccb_h.flags = CAM_TAG_ACTION_VALID;
	} else {
		atio->ccb_h.flags = 0;
	}
	byte++;
d5865 4
a5868 24
	/* Okay.  Now determine the cdb size based on the command code */
	switch (*byte >> CMD_GROUP_CODE_SHIFT) {
	case 0:
		atio->cdb_len = 6;
		break;
	case 1:
	case 2:
		atio->cdb_len = 10;
		break;
	case 4:
		atio->cdb_len = 16;
		break;
	case 5:
		atio->cdb_len = 12;
		break;
	case 3:
	default:
		/* Only copy the opcode. */
		atio->cdb_len = 1;
		printf("Reserved or VU command code type encountered\n");
		break;
	}
	
	memcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);
d5870 2
a5871 1
	atio->ccb_h.status |= CAM_CDB_RECVD;
d5873 1
a5873 17
	if ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {
		/*
		 * We weren't allowed to disconnect.
		 * We're hanging on the bus until a
		 * continue target I/O comes in response
		 * to this accept tio.
		 */
#if 0
		printf("Received Immediate Command %d:%d:%d - %p\n",
		       initiator, target, lun, ahc->pending_device);
#endif
		ahc->pending_device = lstate;
		ahc_freeze_ccb((union ccb *)atio);
		atio->ccb_h.flags |= CAM_DIS_DISCONNECT;
	}
	xpt_done((union ccb*)atio);
	return (0);
a5874 2

#endif
@


1.34.2.3
log
@sync
@
text
@d561 2
a562 2
			hscb->dataptr = sg->addr; 
			hscb->datacnt = sg->len;
d1112 1
a1112 1
		 * LED does.  SELINGO is only cleared by a successful
a1391 1
	ahc_flush_device_writes(ahc);
a1394 1
	ahc_flush_device_writes(ahc);
a1395 1
	ahc_flush_device_writes(ahc);
a1396 1
	ahc_flush_device_writes(ahc);
d4005 1
a4005 1
	 * Note that we were successful
d4147 1
a4147 1
ahc_controller_info(struct ahc_softc *ahc, char *buf, size_t buf_len)
d4149 1
a4149 1
	int len = 0;
d4151 2
a4152 3
	snprintf(buf + len, buf_len - len, "%s: ",
		 ahc_chip_names[ahc->chip & AHC_CHIPID_MASK]);
	len = strlen(buf);
d4154 4
a4157 4
		snprintf(buf + len, buf_len - len,
			 "Twin Channel, A SCSI Id=%d, B SCSI Id=%d, "
			 "primary %c, ", ahc->our_id, ahc->our_id_b,
			 (ahc->flags & AHC_PRIMARY_CHANNEL) + 'A');
d4175 2
a4176 3
		snprintf(buf + len, buf_len - len,
			 "%s%s Channel %c, SCSI Id=%d, ",
			 speed, type, ahc->channel, ahc->our_id);
d4178 1
a4178 1
	len = strlen(buf);
d4181 2
a4182 2
		snprintf(buf + len, buf_len - len, "%d/%d SCBs",
			 ahc->scb_data->maxhscbs, AHC_SCB_MAX);
d4184 1
a4184 2
		snprintf(buf + len, buf_len - len, "%d SCBs",
			 ahc->scb_data->maxhscbs);
a5629 1
	ahc_flush_device_writes(ahc);
@


1.33
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.32 2001/11/05 17:25:58 art Exp $
d646 1
a646 1
	if (ahc_debug & AHC_SHOWSCBALLOC)
d3923 2
a3924 4
		printf("NEEDSDTR == 0x%x\nNEEDWDTR == 0x%x\n"
		       "DISCENABLE == 0x%x\nULTRAENB == 0x%x\n",
		       ahc->needsdtr_orig, ahc->needwdtr_orig,
		       discenable, ultraenb);
d4994 1
a4994 1
			    timeout_add(&active_scb->xs->stimeout, 2 * hz);
@


1.32
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.31 2001/09/20 17:02:31 mpech Exp $
d103 1
a103 1
#include <vm/vm.h>
@


1.31
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.30 2001/08/31 02:52:19 krw Exp $
a257 8
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define	ahc_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (off), (len), (op))
#else
#define	ahc_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (op))
#endif

d526 1
a526 1
		ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
d539 1
a539 1
	ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
d601 1
a601 1
	ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
d3450 1
a3450 1
		bus_dmasync_op_t op;
d3456 1
a3456 1
		ahc_bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
d3676 1
a3676 1
	ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
d4292 1
a4292 1
		struct	  ahc_dma_seg *sg;
d4294 1
a4294 1
		bus_dmasync_op_t op;
d4318 1
a4318 1
		ahc_bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
d4374 1
a4374 1
		ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
d5075 1
a5075 1
				ahc_bus_dmamap_sync(ahc->sc_dmat,
d5129 1
a5129 1
	ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
d5160 1
a5160 1
	ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
@


1.30
log
@Prepare for transition to 5-parameter bus_dmamap_sync() by creating and
using ahc_bus_dmamap_sync() defines that are defined appropriately
depending on __HAS_NEW_BUS_DMAMAP_SYNC.

The code changes are simple reversions to the original NetBSD code.
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.29 2001/08/12 20:33:50 mickey Exp $
d5267 1
a5267 1
	 * disconnected when the reset occured.
@


1.29
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.28 2001/08/12 20:12:11 mickey Exp $
d258 8
d534 2
a535 2
		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
				BUS_DMASYNC_PREWRITE);
d547 2
a548 2
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
			BUS_DMASYNC_PREWRITE);
d609 2
a610 2
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
			BUS_DMASYNC_POSTREAD);
d3464 2
a3465 1
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);
d3684 2
a3685 2
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
			BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d4326 2
a4327 1
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);
d4382 2
a4383 2
		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
				BUS_DMASYNC_PREWRITE);
d5083 1
a5083 1
				bus_dmamap_sync(ahc->sc_dmat,
d5085 1
d5137 2
a5138 2
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
			BUS_DMASYNC_POSTREAD);
d5168 2
a5169 2
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
			BUS_DMASYNC_PREWRITE);
@


1.28
log
@remove some of the redundant vm includes
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.27 2001/04/24 18:22:31 deraadt Exp $
a103 1
#include <vm/vm_param.h>
@


1.27
log
@missing splx, found by art, not yet tested by smurph, but he has run out of time
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.26 2001/04/06 04:42:06 csapuntz Exp $
a104 1
#include <vm/pmap.h>
@


1.26
log
@

Move offsetof define into sys/param.h
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.25 2001/03/25 06:15:37 csapuntz Exp $
d5012 1
@


1.25
log
@

Missing splx(). Thanks to Dawson and team for finding this one
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.24 2000/12/06 15:46:51 mickey Exp $
a124 1
#define offsetof(s, e) ((char *)&((s *)0)->e - (char *)((s *)0))
@


1.24
log
@new timeouts; art@@ ok
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.23 2000/08/02 18:50:17 aaron Exp $
d4987 1
@


1.23
log
@No need to include pci header files here.
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.22 2000/07/03 22:18:36 smurph Exp $
d665 1
d1979 2
a1980 5
				if (!(scb->xs->flags & SCSI_POLL)) {
				untimeout(ahc_timeout, (caddr_t)scb);
					timeout(ahc_timeout, (caddr_t)scb,
					    5 * hz);
				}
d3440 1
a3440 1
	untimeout(ahc_timeout, (caddr_t)scb);
d3488 2
a3489 2
			if (!(txs->flags & SCSI_POLL)) {
				timeout(ahc_timeout, scbp,
a3490 1
			}
d4219 1
d4357 1
a4357 2
	timeout(ahc_timeout, (caddr_t)scb, 
		    (xs->timeout * hz) / 1000);
d4818 1
a4818 1
			untimeout(ahc_timeout, scbp);
d4967 2
a4968 2
				timeout(ahc_timeout, scb,
					    (newtimeout * hz) / 1000);
d4996 1
a4996 1
			    timeout(ahc_timeout, (caddr_t)active_scb, 2 * hz);
d5085 1
a5085 1
				timeout(ahc_timeout, (caddr_t)scb, 2 * hz);
@


1.22
log
@Add support for big endian hardware.  Clean up memory vs. io mapping code.
Fix for drives with Tag quirks.
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.21 2000/04/05 04:29:58 smurph Exp $
a92 4

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
@


1.21
log
@Changed boot messages and fixed Ultra160 boot messages.
AHA-29160 Ultra160 verified working.
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.20 2000/04/04 03:48:47 smurph Exp $
d131 4
d331 2
a332 1
					 struct scsi_xfer *xs));
a388 1

d390 2
d414 19
d795 1
a795 1
	printf("scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n",
d797 1
d801 4
a804 4
		hscb->cmdpointer );
	printf("        datlen:%d data:0x%lx segs:0x%x segp:0x%lx\n",
		hscb->datalen,
		hscb->data,
d806 4
a809 4
		hscb->SG_pointer);
	printf("	sg_addr:%lx sg_len:%ld\n",
		scb->sg_list[0].addr,
		scb->sg_list[0].len);
d1500 1
a1500 1
	else
d1502 2
d1968 2
d2133 2
a2134 2
				       scb->sg_list[i].addr,
				       scb->sg_list[i].len);
d3362 2
a3363 2
			 && (scb->sg_list[sg_index].len < data_cnt)) {
				u_int sg_addr;
d3367 3
a3369 2
				data_addr = scb->sg_list[sg_index].addr
					  + scb->sg_list[sg_index].len - 1;
d3474 2
a3475 1
	ahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);
d3531 1
a3531 1
		      &xs->sense, scb->sg_list->len);
d3884 1
d3965 1
a3965 1
	 * If we are a target, we'll enalbe select in operations once
d4095 1
d4142 1
a4142 1
	    (!ahc_istagged_device(ahc, xs) &&
d4218 2
a4219 1
	if (ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)
d4227 1
a4227 1
	if (ahc_istagged_device(ahc, xs))
d4234 11
d4315 1
d4342 1
a4342 1
		if (!ahc_istagged_device(ahc, xs))
d4355 2
d4470 1
a4470 1
			if (!ahc_istagged_device(ahc, xs))
d4566 4
a4569 2
			ahc_hscb_busaddr(ahc, next_scb->hscb->tag) + 
			offsetof(struct hardware_scb, cmdstore);	
d4702 2
d4791 1
d4911 2
a4912 2
			       scb->sg_list[i].addr,
			       scb->sg_list[i].len);
d5666 1
a5666 1
			resid += scb->sg_list[sg].len;
d5835 1
d5837 1
d5842 3
d5847 8
d5862 1
a5862 1
	if ((inq->flags & SID_CmdQue) && !(ahc_istagged_device(ahc, xs))) {
a5866 3
		ahc_compile_devinfo(&devinfo,
		    our_id, target_id, xs->sc_link->lun,	
		    SIM_CHANNEL(ahc, xs->sc_link), ROLE_INITIATOR);
d5888 1
a5888 1
ahc_istagged_device(ahc, xs)
d5891 1
d5897 12
@


1.20
log
@Import tagging code and try to resolve locking problem.
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.19 2000/03/22 02:48:47 smurph Exp $
d1381 1
a1381 1
	if (done && bootverbose) {
d2600 4
a2603 3
		printf("%s:%c:%d: refuses WIDE negotiation.  Using "
		       "8bit transfers\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target);
d2637 5
a2641 4
		printf("%s:%c:%d: refuses synchronous negotiation. "
		       "Using asynchronous transfers\n",
		       ahc_name(ahc),
		       devinfo->channel, devinfo->target);
d2643 4
a2646 3
		printf("%s:%c:%d: refuses tagged commands.  Performing "
		       "non-tagged I/O\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target);
@


1.19
log
@new ahc driver.  Adds suport for newer Adaptec controllers.  This represents two months of work.
@
text
@d36 1
a36 1
 * $OpenBSD: src/sys/dev/ic/aic7xxx.c,v 1.0 2000/03/14 23:08:17 smurph Exp $
d326 4
d626 6
d646 1
d689 1
a689 1
	int error, rseg, level = 0;
d727 1
a727 6
	*baddr = seg[0].ds_addr;

	if (bootverbose)
		printf("%s: dmamem for %s at phys %lx virt %lx nseg %d size %d\n",
		       myname, what, (unsigned long)*baddr,
		       (unsigned long)*vaddr, *nseg, size);
d738 1
a738 1
		bus_dmamem_free(tag, seg, rseg);
d830 2
a831 2
#define AHC_SYNCRATE_ULTRA	2
#define AHC_SYNCRATE_FAST	5
d1514 1
a1514 1
/*
d2035 1
a2035 1
			}
d2040 1
a2040 1
		}
d2361 1
d3425 1
a3425 1
		int op;
d3520 1
d3650 3
d4094 3
d4105 2
a4106 1
	    ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL) {
d4189 4
a4192 1
	ahc_busy_tcl(ahc, scb);
d4292 2
a4293 1
		ahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);
d4344 1
d4418 2
a4419 1
			ahc_index_busy_tcl(ahc, hscb->tcl, TRUE);
d4947 1
d5023 5
d5769 70
@


1.18
log
@panic prints a newline for you, don't do it in the panic string
@
text
@a0 3
/*	$OpenBSD: aic7xxx.c,v 1.17 1997/07/03 17:46:53 deraadt Exp $	*/
/*	$NetBSD: aic7xxx.c,v 1.17 1996/10/21 22:34:04 thorpej Exp $	*/

d4 3
a6 2
 * i386/eisa/aic7770.c	27/284X and aic7770 motherboard controllers
 * pci/aic7870.c	3940, 2940, aic7880, aic7870 and aic7850 controllers
d8 1
a8 1
 * Copyright (c) 1994, 1995, 1996 Justin T. Gibbs.
d15 3
a17 6
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
d20 3
d35 2
a36 1
 * from Id: aic7xxx.c,v 1.75 1996/06/23 20:02:37 gibbs Exp
d39 1
a39 4
 * TODO:
 *	Implement Target Mode
 *
 * A few notes on how SCB paging works...
d43 7
a49 26
 * having the SCBs for that device down on the host adapter is of little use.
 * Instead we copy the SCB back up into kernel memory and reuse the SCB slot
 * on the card to schedule another transaction.  This can be a real payoff
 * when doing random I/O to tagged queueing devices since there are more 
 * transactions active at once for the device to sort for optimal seek
 * reduction. The algorithm goes like this...
 *
 * At the sequencer level:
 * 1) Disconnected SCBs are threaded onto a doubly linked list, headed by
 *    DISCONNECTED_SCBH using the SCB_NEXT and SCB_PREV fields.  The most
 *    recently disconnected device is always at the head.
 *
 * 2) The SCB has an added field SCB_TAG that corresponds to the kernel
 *    SCB number (ie 0-254).
 *
 * 3) When a command is queued, the hardware index of the SCB it was downloaded
 *    into is placed into the QINFIFO for easy indexing by the sequencer.
 *
 * 4) The tag field is used as the tag for tagged-queueing, for determining
 *    the related kernel SCB, and is the value put into the QOUTFIFO
 *    so the kernel doesn't have to upload the SCB to determine the kernel SCB
 *    that completed on command completes.
 *
 * 5) When a reconnect occurs, the sequencer must scan the SCB array (even
 *    in the tag case) looking for the appropriate SCB and if it can't find
 *    it, it interrupts the kernel so it can page the SCB in.
d51 19
a69 2
 * 6) If the sequencer is successful in finding the SCB, it removes it from
 *    the doubly linked list of disconnected SCBS.
d71 6
a76 12
 * At the kernel level:
 * 1) There are four queues that a kernel SCB may reside on:
 *	free_scbs - SCBs that are not in use and have a hardware slot assigned
 *		    to them.
 *      page_scbs - SCBs that are not in use and need to have a hardware slot
 *		    assigned to them (i.e. they will most likely cause a page
 *		    out event).
 *	waiting_scbs - SCBs that are active, don't have an assigned hardware
 *		    slot assigned to them and are waiting for either a
 *		    disconnection or a command complete to free up a slot.
 *	assigned_scbs - SCBs that were in the waiting_scbs queue, but were
 *		    assigned a slot by ahc_free_scb.
d78 7
a84 2
 * 2) When a new request comes in, an SCB is allocated from the free_scbs or
 *    page_scbs queue with preference to SCBs on the free_scbs queue.
a85 24
 * 3) If there are no free slots (we retrieved the SCB off of the page_scbs
 *    queue), the SCB is inserted onto the tail of the waiting_scbs list and
 *    we attempt to run this queue down.
 *
 * 4) ahc_run_waiting_queues() looks at both the assigned_scbs and waiting_scbs
 *    queues.  In the case of the assigned_scbs, the commands are immediately
 *    downloaded and started.  For waiting_scbs, we page in all that we can
 *    ensuring we don't create a resource deadlock (see comments in
 *    ahc_run_waiting_queues()).
 *
 * 5) After we handle a bunch of command completes, we also try running the
 *    queues since many SCBs may have disconnected since the last command
 *    was started and we have at least one free slot on the card.
 *
 * 6) ahc_free_scb looks at the waiting_scbs queue for a transaction
 *    requiring a slot and moves it to the assigned_scbs queue if it
 *    finds one.  Otherwise it puts the current SCB onto the free_scbs
 *    queue for later use.
 *
 * 7) The driver handles page-in requests from the sequencer in response to
 *    the NO_MATCH sequencer interrupt.  For tagged commands, the appropriate
 *    SCB is easily found since the tag is a direct index into our kernel SCB
 *    array.  For non-tagged commands, we keep a separate array of 16 pointers
 *    that point to the single possible SCB that was paged out for that target.
a89 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d93 4
a96 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a103 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a104 1
#endif
a106 4
#if defined(__FreeBSD__)
#include <machine/clock.h>
#endif

a110 7
#if defined(__FreeBSD__)
#include <i386/scsi/aic7xxx.h>

#include <dev/aic7xxx/aic7xxx_reg.h>
#endif /* defined(__FreeBSD__) */

#if defined(__NetBSD__) || defined(__OpenBSD__)
d113 11
d125 5
a129 1
#define bootverbose	1
d131 5
a135 12
#define DEBUGTARG	DEBUGTARGET
#if DEBUGTARG < 0	/* Negative numbers for disabling cause warnings */
#undef DEBUGTARG
#define DEBUGTARG	17
#endif
#ifdef alpha		/* XXX */
/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */ 
extern vm_offset_t alpha_XXX_dmamap(vm_offset_t);
#undef vtophys
#define	vtophys(va)	alpha_XXX_dmamap((vm_offset_t) va)
#endif	/* alpha */
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d137 29
a165 2
#include <sys/kernel.h>
#define KVTOPHYS(x)   vtophys(x)
d167 32
a198 2
#define MIN(a,b) ((a < b) ? a : b)
#define ALL_TARGETS -1
d200 5
a204 3
#if defined(__FreeBSD__)
u_long ahc_unit = 0;
#endif
d210 6
a215 2
#ifdef AHC_BROKEN_CACHE
int ahc_broken_cache = 1;
d217 66
a282 6
/*
 * "wbinvd" cause writing back whole cache (both CPU internal & external)
 * to memory, so that the instruction takes a lot of time.
 * This makes machine slow.
 */
#define	INVALIDATE_CACHE()	__asm __volatile("wbinvd")
d284 96
d381 1
a381 3
/**** bit definitions for SCSIDEF ****/
#define	HSCSIID		0x07		/* our SCSI ID */
#define HWSCSIID	0x0f		/* our SCSI ID if Wide Bus */
d383 3
a385 6
static void	 ahcminphys __P((struct buf *bp));
static int32_t	 ahc_scsi_cmd __P((struct scsi_xfer *xs));
static inline void pause_sequencer __P((struct ahc_data *ahc));
static inline void unpause_sequencer __P((struct ahc_data *ahc,
					  int unpause_always));
static inline void restart_sequencer __P((struct ahc_data *ahc));
d389 4
a392 9
        ahc_scsi_cmd,
        ahcminphys,
        0,
        0,
#if defined(__FreeBSD__)
        0,
        "ahc",
        { 0, 0 }
#endif
d398 4
a401 9
    NULL,                       /* Use default error handler */
    NULL,                       /* have a queue, served by this */
    NULL,                       /* have no async handler */
    NULL,                       /* Use default 'done' routine */
#if defined(__FreeBSD__)
    "ahc",
    0,
    { 0, 0 }
#endif
d404 35
a438 1
static inline void
d440 1
a440 1
	struct ahc_data *ahc;
d442 1
a442 1
	AHC_OUTB(ahc, HCNTRL, ahc->pause);
d448 1
a448 1
	while ((AHC_INB(ahc, HCNTRL) & PAUSE) == 0)
d452 6
a457 8
static inline void
unpause_sequencer(ahc, unpause_always)
	struct ahc_data *ahc;
	int unpause_always;
{
	if (unpause_always
	 ||(AHC_INB(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)
		AHC_OUTB(ahc, HCNTRL, ahc->unpause);
d463 1
a463 1
static inline void
d465 110
a574 1
	struct ahc_data *ahc;
d576 19
a594 4
	do {
		AHC_OUTB(ahc, SEQCTL, SEQRESET|FASTMODE);
	} while((AHC_INB(ahc, SEQADDR0) != 0)
		|| (AHC_INB(ahc, SEQADDR1) != 0));
d596 10
a605 1
	unpause_sequencer(ahc, /*unpause_always*/TRUE);
d608 1
a608 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d610 2
a611 1
 * Is device which is pointed by sc_link connected on second scsi bus ?
d613 25
a637 2
#define	IS_SCSIBUS_B(ahc, sc_link)	\
	((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
d640 4
a643 1
 * convert FreeBSD's SCSI symbols to Net- & OpenBSD's
d645 21
a665 3
#define	SCSI_NOMASK	SCSI_POLL
#define	opennings	openings
#endif
d667 10
a676 58
static u_char	ahc_abort_wscb __P((struct ahc_data *ahc, struct scb *scbp,
				    u_char prev,
				    u_char timedout_scb, u_int32_t xs_error));
static void	ahc_add_waiting_scb __P((struct ahc_data *ahc,
					 struct scb *scb));
static void	ahc_done __P((struct ahc_data *ahc, struct scb *scbp));
static void	ahc_free_scb __P((struct ahc_data *ahc, struct scb *scb,
				  int flags));
static inline void ahc_send_scb __P((struct ahc_data *ahc, struct scb *scb));
static inline void ahc_fetch_scb __P((struct ahc_data *ahc, struct scb *scb));
static inline void ahc_page_scb __P((struct ahc_data *ahc, struct scb *out_scb,
				struct scb *in_scb));
static inline void ahc_run_waiting_queues __P((struct ahc_data *ahc));
static void	ahc_handle_seqint __P((struct ahc_data *ahc, u_int8_t intstat));
static struct scb *
		ahc_get_scb __P((struct ahc_data *ahc, int flags));
static void	ahc_loadseq __P((struct ahc_data *ahc));
static int	ahc_match_scb __P((struct scb *scb, int target, char channel));
static int	ahc_poll __P((struct ahc_data *ahc, int wait));
#ifdef AHC_DEBUG
static void	ahc_print_scb __P((struct scb *scb));
#endif
static int	ahc_reset_channel __P((struct ahc_data *ahc, char channel,
				       u_char timedout_scb, u_int32_t xs_error,
				       u_char initiate_reset));
static int	ahc_reset_device __P((struct ahc_data *ahc, int target,
				      char channel, u_char timedout_scb,
				      u_int32_t xs_error));
static void	ahc_reset_current_bus __P((struct ahc_data *ahc));
static void	ahc_run_done_queue __P((struct ahc_data *ahc));
static void	ahc_scsirate __P((struct ahc_data* ahc, u_int8_t *scsirate,
				  u_int8_t *period, u_int8_t *offset,
				  char channel, int target));
#if defined(__FreeBSD__)
static timeout_t
		ahc_timeout;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
static void	ahc_timeout __P((void *));
#endif
static void	ahc_busy_target __P((struct ahc_data *ahc,
				     int target, char channel));
static void	ahc_unbusy_target __P((struct ahc_data *ahc,
				       int target, char channel));
static void	ahc_construct_sdtr __P((struct ahc_data *ahc, int start_byte,
					u_int8_t period, u_int8_t offset));  
static void	ahc_construct_wdtr __P((struct ahc_data *ahc, int start_byte,
					u_int8_t bus_width));

#if defined(__NetBSD__) || defined(__OpenBSD__)	/* XXX */
static void	ahc_xxx_enqueue __P((struct ahc_data *ahc,
		    struct scsi_xfer *xs, int infront));
static struct scsi_xfer *ahc_xxx_dequeue __P((struct ahc_data *ahc));
#endif

#if defined(__FreeBSD__)

char *ahc_name(ahc)
	struct ahc_data *ahc;
d678 59
a736 1
	static char name[10];
d738 1
a738 2
	sprintf(name, "ahc%d", ahc->unit);
	return (name);
d741 15
a755 5
#elif defined(__NetBSD__) || defined(__OpenBSD__)
struct cfdriver ahc_cd = {
	NULL, "ahc", DV_DULL
};
#endif
d758 1
a758 1
static void
d760 1
a760 1
        struct scb *scb;
d762 21
a782 14
        printf("scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n"
	    ,scb
	    ,scb->control
	    ,scb->tcl
	    ,scb->cmdlen
	    ,scb->cmdpointer );
        printf("        datlen:%d data:0x%lx segs:0x%x segp:0x%lx\n"
	    ,scb->datalen
	    ,scb->data
	    ,scb->SG_segment_count
	    ,scb->SG_list_pointer);
	printf("	sg_addr:%lx sg_len:%ld\n"
	    ,scb->ahc_dma[0].addr
	    ,scb->ahc_dma[0].len);
a783 1

d787 1
a787 1
        u_char errno;
d790 8
a797 4
	{ ILLHADDR,  "Illegal Host Access" },
	{ ILLSADDR,  "Illegal Sequencer Address referenced" },
	{ ILLOPCODE, "Illegal Opcode in sequencer program" },
	{ PARERR,    "Sequencer Ram Parity Error" }
d799 1
d801 15
d822 21
a842 18
static struct {
	short sxfr;
	/* Rates in Ultra mode have bit 8 of sxfr set */
#define		ULTRA_SXFR 0x100
	int period; /* in ns/4 */
	char *rate;
} ahc_syncrates[] = {
	{ 0x100, 12, "20.0"  },
	{ 0x110, 15, "16.0"  },
	{ 0x120, 18, "13.4"  },
	{ 0x000, 25, "10.0"  },
	{ 0x010, 31,  "8.0"  },
	{ 0x020, 37,  "6.67" },
	{ 0x030, 43,  "5.7"  },
	{ 0x040, 50,  "5.0"  },
	{ 0x050, 56,  "4.4"  },
	{ 0x060, 62,  "4.0"  },
	{ 0x070, 68,  "3.6"  }
a844 3
static int ahc_num_syncrates =
	sizeof(ahc_syncrates) / sizeof(ahc_syncrates[0]);

a849 6
#if defined(__FreeBSD__)
struct ahc_data *
ahc_alloc(unit, iobase, type, flags)
	int unit;
	u_long iobase;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d851 2
a852 2
ahc_construct(ahc, iot, ioh, type, flags)
	struct  ahc_data *ahc;
d855 1
a855 2
#endif
	ahc_type type;
d857 2
a859 1

d863 16
d880 66
a945 2
#if defined(__FreeBSD__)
	struct  ahc_data *ahc;
d948 7
a954 1
	 * Allocate a storage area for us
d957 27
a983 4
	ahc = malloc(sizeof(struct ahc_data), M_TEMP, M_NOWAIT);
	if (!ahc) {
		printf("ahc%d: cannot malloc!\n", unit);
		return NULL;
a984 19
	bzero(ahc, sizeof(struct ahc_data));
#endif
	STAILQ_INIT(&ahc->free_scbs);
	STAILQ_INIT(&ahc->page_scbs);
	STAILQ_INIT(&ahc->waiting_scbs);
	STAILQ_INIT(&ahc->assigned_scbs);
#if defined(__FreeBSD__)
	ahc->unit = unit;
#endif
#if defined(__FreeBSD__)
	ahc->baseport = iobase;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	ahc->sc_iot = iot;
	ahc->sc_ioh = ioh;
#endif
	ahc->type = type;
	ahc->flags = flags;
	ahc->unpause = (AHC_INB(ahc, HCNTRL) & IRQMS) | INTEN;
	ahc->pause = ahc->unpause | PAUSE;
d986 10
a995 3
#if defined(__FreeBSD__)
	return (ahc);
#endif
d998 3
a1000 3
void
ahc_free(ahc)
	struct ahc_data *ahc;
d1002 34
a1035 4
#if defined(__FreeBSD__)
	free(ahc, M_DEVBUF);
	return;
#endif
d1039 1
a1039 5
#if defined(__FreeBSD__)
ahc_reset(iobase)
	u_long iobase;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
ahc_reset(devname, iot, ioh)
a1042 1
#endif
d1044 1
a1044 1
        u_char hcntrl;
d1047 3
a1050 5
#if defined(__FreeBSD__)
	hcntrl = (inb(HCNTRL + iobase) & IRQMS) | INTEN;

	outb(HCNTRL + iobase, CHIPRST | PAUSE);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1053 1
#endif
a1057 3
#if defined(__FreeBSD__)
	while (--wait && !(inb(HCNTRL + iobase) & CHIPRSTACK))
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1058 1
#endif
d1060 1
a1060 5
	if(wait == 0) {
#if defined(__FreeBSD__)
		printf("ahc at 0x%lx: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", iobase);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d1062 1
a1062 2
		       "Trying to initialize anyway.\n", devname);
#endif
a1063 3
#if defined(__FreeBSD__)
	outb(HCNTRL + iobase, hcntrl | PAUSE);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1064 1
#endif
d1067 3
a1069 11
/*
 * Look up the valid period to SCSIRATE conversion in our table.
 */
static void
ahc_scsirate(ahc, scsirate, period, offset, channel, target )
	struct	 ahc_data *ahc;
	u_int8_t *scsirate;
	u_int8_t *period;
	u_int8_t *offset;
	char	 channel;
	int	 target;
d1071 2
a1072 6
	int i;
	u_int32_t ultra_enb_addr;
	u_int8_t  sxfrctl0;
	u_int8_t  ultra_enb;

	i = ahc_num_syncrates; /* Default to async */
d1074 216
a1289 2
	if (*period >= ahc_syncrates[0].period && *offset != 0) {
		for (i = 0; i < ahc_num_syncrates; i++) {
d1291 55
a1345 15
			if (*period <= ahc_syncrates[i].period) {
				/*
				 * Watch out for Ultra speeds when ultra is not
				 * enabled and vice-versa.
				 */
				if(!(ahc->type & AHC_ULTRA) 
				 && (ahc_syncrates[i].sxfr & ULTRA_SXFR)) {
					/*
					 * This should only happen if the
					 * drive is the first to negotiate
					 * and chooses a high rate.  We'll
					 * just move down the table util
					 * we hit a non ultra speed.
					 */
					continue;
d1347 11
a1357 11
				*scsirate = (ahc_syncrates[i].sxfr & 0xF0)
					  | (*offset & 0x0f);
				*period = ahc_syncrates[i].period;

				if(bootverbose) {
					printf("%s: target %d synchronous at %sMHz,"
					       " offset = 0x%x\n",
					        ahc_name(ahc), target,
						ahc_syncrates[i].rate, *offset );
				}
				break;
d1360 30
d1391 4
a1394 25
	if (i >= ahc_num_syncrates) {
		/* Use asynchronous transfers. */
		*scsirate = 0;
		*period = 0;
		*offset = 0;
		if (bootverbose)
			printf("%s: target %d using asynchronous transfers\n",
			       ahc_name(ahc), target );
	}
	/*
	 * Ensure Ultra mode is set properly for
	 * this target.
	 */
	ultra_enb_addr = ULTRA_ENB;
	if(channel == 'B' || target > 7)
		ultra_enb_addr++;
	ultra_enb = AHC_INB(ahc, ultra_enb_addr);	
	sxfrctl0 = AHC_INB(ahc, SXFRCTL0);
	if (*scsirate != 0 && ahc_syncrates[i].sxfr & ULTRA_SXFR) {
		ultra_enb |= 0x01 << (target & 0x07);
		sxfrctl0 |= ULTRAEN;
	}
	else {
		ultra_enb &= ~(0x01 << (target & 0x07));
		sxfrctl0 &= ~ULTRAEN;
d1396 74
a1469 2
	AHC_OUTB(ahc, ultra_enb_addr, ultra_enb);
	AHC_OUTB(ahc, SXFRCTL0, sxfrctl0);
d1477 1
a1477 1
	struct ahc_data *ahc;
a1478 5
#if defined(__FreeBSD__)
	struct scsibus_data *scbus;
#endif

#if defined(__NetBSD__) || defined(__OpenBSD__)	/* XXX */
a1482 1
#endif
a1490 5
#if defined(__FreeBSD__)
	ahc->sc_link.adapter_unit = ahc->unit;
	ahc->sc_link.adapter_targ = ahc->our_id;
	ahc->sc_link.fordriver = 0;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d1492 1
a1492 2
#ifdef __OpenBSD__
	if(ahc->type & AHC_WIDE)
a1493 5
#endif
#ifndef __OpenBSD__
	ahc->sc_link.channel = 0;
#endif
#endif
d1496 1
a1496 1
	ahc->sc_link.opennings = 2;
a1497 1
#ifdef __OpenBSD__
d1499 2
a1500 5
#else
	ahc->sc_link.flags = DEBUGLEVEL;
#endif

	if(ahc->type & AHC_TWIN) {
a1502 5
#if defined(__FreeBSD__)
		ahc->sc_link_b.adapter_targ = ahc->our_id_b;
		ahc->sc_link_b.adapter_bus = 1;
		ahc->sc_link_b.fordriver = (void *)SELBUSB;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d1504 1
a1504 2
#ifdef __OpenBSD__
		if(ahc->type & AHC_WIDE)
a1505 5
#endif
#ifndef __OpenBSD__
		ahc->sc_link_b.channel = 1;
#endif
#endif
d1508 1
a1508 39

#if defined(__FreeBSD__)
	/*
	 * Prepare the scsibus_data area for the upperlevel
	 * scsi code.
	 */
	scbus = scsi_alloc_bus();
	if(!scbus) 
		return 0;
	scbus->adapter_link = (ahc->flags & AHC_CHANNEL_B_PRIMARY) ?
				&ahc->sc_link_b : &ahc->sc_link;
	if(ahc->type & AHC_WIDE)
		scbus->maxtarg = 15;
	
	/*
	 * ask the adapter what subunits are present
	 */
	if(bootverbose)
		printf("ahc%d: Probing channel %c\n", ahc->unit,
			(ahc->flags & AHC_CHANNEL_B_PRIMARY) ? 'B' : 'A');
	scsi_attachdevs(scbus);
	scbus = NULL;	/* Upper-level SCSI code owns this now */

	if(ahc->type & AHC_TWIN) {
		scbus =  scsi_alloc_bus();
		if(!scbus) 
			return 0;
		scbus->adapter_link = (ahc->flags & AHC_CHANNEL_B_PRIMARY) ? 
					&ahc->sc_link : &ahc->sc_link_b;
		if(ahc->type & AHC_WIDE)
			scbus->maxtarg = 15;
		if(bootverbose)
			printf("ahc%d: Probing Channel %c\n", ahc->unit,
			       (ahc->flags & AHC_CHANNEL_B_PRIMARY) ? 'A': 'B');
		scsi_attachdevs(scbus);
		scbus = NULL;	/* Upper-level SCSI code owns this now */
	}
#elif defined(__NetBSD__) || defined (__OpenBSD__)
	/*
d1516 1
a1516 1
		if (ahc->type & AHC_TWIN)
d1525 1
a1525 1
		/* assert(ahc->type & AHC_TWIN); */
a1528 1
#endif
d1532 21
a1552 13
/*
 * Send an SCB down to the card via PIO.
 * We assume that the proper SCB is already selected in SCBPTR. 
 */
static inline void
ahc_send_scb(ahc, scb)
        struct	ahc_data *ahc;
        struct	scb *scb;
{
	AHC_OUTB(ahc, SCBCNT, SCBAUTO);
	if( ahc->type == AHC_284 )
		/* Can only do 8bit PIO */
		AHC_OUTSB(ahc, SCBARRAY, scb, SCB_PIO_TRANSFER_SIZE);
d1554 26
a1579 3
		AHC_OUTSL(ahc, SCBARRAY, scb,
		      (SCB_PIO_TRANSFER_SIZE + 3) / 4);
	AHC_OUTB(ahc, SCBCNT, 0); 
d1583 1
a1583 2
 * Retrieve an SCB from the card via PIO.
 * We assume that the proper SCB is already selected in SCBPTR.
d1585 2
a1586 4
static inline void
ahc_fetch_scb(ahc, scb)
	struct	ahc_data *ahc;
	struct	scb *scb;
d1588 2
a1589 1
	AHC_OUTB(ahc, SCBCNT, 0x80);	/* SCBAUTO */
d1591 1
a1591 2
	/* Can only do 8bit PIO for reads */
	AHC_INSB(ahc, SCBARRAY, scb, SCB_PIO_TRANSFER_SIZE);
d1593 44
a1636 2
	AHC_OUTB(ahc, SCBCNT, 0);
}
d1638 4
a1641 19
/*
 * Swap in_scbp for out_scbp down in the cards SCB array.
 * We assume that the SCB for out_scbp is already selected in SCBPTR.
 */
static inline void
ahc_page_scb(ahc, out_scbp, in_scbp)
	struct ahc_data *ahc;
	struct scb *out_scbp;
	struct scb *in_scbp;
{
	/* Page-out */
	ahc_fetch_scb(ahc, out_scbp);
	out_scbp->flags |= SCB_PAGED_OUT;
	if(!(out_scbp->control & TAG_ENB))
	{
		/* Stick in non-tagged array */
		int index =  (out_scbp->tcl >> 4)
			   | (out_scbp->tcl & SELBUSB);
		ahc->pagedout_ntscbs[index] = out_scbp;
d1643 2
d1646 3
a1648 5
	/* Page-in */
	in_scbp->position = out_scbp->position;
	out_scbp->position = SCB_LIST_NULL;
	ahc_send_scb(ahc, in_scbp);
	in_scbp->flags &= ~SCB_PAGED_OUT;
d1651 5
a1655 3
static inline void
ahc_run_waiting_queues(ahc)
	struct ahc_data *ahc;
d1657 16
a1672 2
	struct scb* scb;
	u_char cur_scb;
d1674 22
a1695 2
	if(!(ahc->assigned_scbs.stqh_first || ahc->waiting_scbs.stqh_first))
		return;
d1697 9
a1705 2
	pause_sequencer(ahc);
	cur_scb = AHC_INB(ahc, SCBPTR);
d1708 4
a1711 2
	 * First handle SCBs that are waiting but have been
	 * assigned a slot.
d1713 46
a1758 4
	while((scb = ahc->assigned_scbs.stqh_first) != NULL) {
		STAILQ_REMOVE_HEAD(&ahc->assigned_scbs, links);
		AHC_OUTB(ahc, SCBPTR, scb->position);
		ahc_send_scb(ahc, scb);
d1760 14
a1773 2
		/* Mark this as an active command */
		scb->flags ^= SCB_ASSIGNEDQ|SCB_ACTIVE;
d1775 12
a1786 4
		AHC_OUTB(ahc, QINFIFO, scb->position);
		if (!(scb->xs->flags & SCSI_NOMASK)) {
			timeout(ahc_timeout, (caddr_t)scb,
				(scb->xs->timeout * hz) / 1000);
d1788 1
a1788 1
		SC_DEBUG(scb->xs->sc_link, SDEV_DB3, ("cmd_sent\n"));
d1790 16
a1805 5
	/* Now deal with SCBs that require paging */
	if((scb = ahc->waiting_scbs.stqh_first) != NULL) {
		u_char disc_scb = AHC_INB(ahc, DISCONNECTED_SCBH);
		u_char active = AHC_INB(ahc, FLAGS) & (SELECTED|IDENTIFY_SEEN);
		int count = 0;
d1807 14
a1820 2
		do {
			u_char next_scb;
d1822 2
a1823 3
			/* Attempt to page this SCB in */
			if(disc_scb == SCB_LIST_NULL)
				break;
d1825 2
d1828 3
a1830 1
			 * Check the next SCB on in the list.
d1832 38
a1869 2
			AHC_OUTB(ahc, SCBPTR, disc_scb);
			next_scb = AHC_INB(ahc, SCB_NEXT); 
d1871 10
a1880 17
			/*
			 * We have to be careful about when we allow
			 * an SCB to be paged out.  There must always
			 * be at least one slot available for a
			 * reconnecting target in case it references
			 * an SCB that has been paged out.  Our
			 * heuristic is that either the disconnected
			 * list has at least two entries in it or
			 * there is one entry and the sequencer is
			 * actively working on an SCB which implies that
			 * it will either complete or disconnect before
			 * another reconnection can occur.
			 */
			if((next_scb != SCB_LIST_NULL) || active)
			{
				u_char out_scbi;
				struct scb* out_scbp;
d1882 6
a1887 1
				STAILQ_REMOVE_HEAD(&ahc->waiting_scbs, links);
d1890 2
a1891 2
				 * Find the in-core SCB for the one
				 * we're paging out.
d1893 1
a1893 2
				out_scbi = AHC_INB(ahc, SCB_TAG); 
				out_scbp = ahc->scbarray[out_scbi];
d1895 46
a1940 2
				/* Do the page out */
				ahc_page_scb(ahc, out_scbp, scb);
d1942 61
a2002 2
				/* Mark this as an active command */
				scb->flags ^= SCB_WAITINGQ|SCB_ACTIVE;
d2004 15
a2018 5
				/* Queue the command */
				AHC_OUTB(ahc, QINFIFO, scb->position);
				if (!(scb->xs->flags & SCSI_NOMASK)) {
					timeout(ahc_timeout, (caddr_t)scb,
						(scb->xs->timeout * hz) / 1000);
d2020 31
a2050 3
				SC_DEBUG(scb->xs->sc_link, SDEV_DB3,
					("cmd_paged-in\n"));
				count++;
d2052 47
a2098 2
				/* Advance to the next disconnected SCB */
				disc_scb = next_scb;
d2100 169
d2270 68
d2339 4
a2342 1
		} while((scb = ahc->waiting_scbs.stqh_first) != NULL);
d2344 21
a2364 8
		if(count) {
			/* 
			 * Update the head of the disconnected list.
			 */
			AHC_OUTB(ahc, DISCONNECTED_SCBH, disc_scb);
			if(disc_scb != SCB_LIST_NULL) {
				AHC_OUTB(ahc, SCBPTR, disc_scb);
				AHC_OUTB(ahc, SCB_PREV, SCB_LIST_NULL);
d2366 38
d2405 71
a2476 3
	/* Restore old position */
	AHC_OUTB(ahc, SCBPTR, cur_scb);
	unpause_sequencer(ahc, /*unpause_always*/FALSE);
d2479 4
a2482 6
/*
 * Add this SCB to the head of the "waiting for selection" list.
 */
static
void ahc_add_waiting_scb(ahc, scb)
	struct ahc_data *ahc;
d2485 25
a2509 2
	u_char next; 
	u_char curscb;
d2511 23
a2533 2
	curscb = AHC_INB(ahc, SCBPTR);
	next = AHC_INB(ahc, WAITING_SCBH);
d2535 21
a2555 3
	AHC_OUTB(ahc, SCBPTR, scb->position);
	AHC_OUTB(ahc, SCB_NEXT, next);
	AHC_OUTB(ahc, WAITING_SCBH, scb->position);
d2557 7
a2563 1
	AHC_OUTB(ahc, SCBPTR, curscb);
d2566 4
a2569 10
/*
 * Catch an interrupt from the adapter
 */
#if defined(__FreeBSD__)
void
#elif defined (__NetBSD__) || defined (__OpenBSD__)
int
#endif
ahc_intr(arg)
        void *arg;
a2570 7
	int     intstat;
	u_char	status;
	struct	scb *scb;
	struct	scsi_xfer *xs;
	struct	ahc_data *ahc = (struct ahc_data *)arg;

	intstat = AHC_INB(ahc, INTSTAT);
d2572 4
a2575 2
	 * Is this interrupt for me? or for
	 * someone who is sharing my interrupt?
d2577 62
a2638 6
	if (!(intstat & INT_PEND))
#if defined(__FreeBSD__)
		return;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
		return 0;
#endif
d2640 9
a2648 2
        if (intstat & BRKADRINT) {
		/* We upset the sequencer :-( */
d2650 19
a2668 12
		/* Lookup the error message */
		int i, error = AHC_INB(ahc, ERROR);
		int num_errors =  sizeof(hard_error)/sizeof(hard_error[0]);
		for(i = 0; error != 1 && i < num_errors; i++)
			error >>= 1;
                panic("%s: brkadrint, %s at seqaddr = 0x%x",
		      ahc_name(ahc), hard_error[i].errmesg,
		      (AHC_INB(ahc, SEQADDR1) << 8) |
		      AHC_INB(ahc, SEQADDR0));
        }
        if (intstat & SEQINT)
		ahc_handle_seqint(ahc, intstat);
d2670 9
a2678 1
	if (intstat & SCSIINT) {
d2680 41
a2720 16
		int scb_index = AHC_INB(ahc, SCB_TAG);
		status = AHC_INB(ahc, SSTAT1);
		scb = ahc->scbarray[scb_index];

		if (status & SCSIRSTI) {
			char channel;
			channel = AHC_INB(ahc, SBLKCTL);
			channel = channel & SELBUSB ? 'B' : 'A';
			printf("%s: Someone reset channel %c\n",
				ahc_name(ahc), channel);
			ahc_reset_channel(ahc, 
					  channel,
					  SCB_LIST_NULL,
					  XS_BUSY,
					  /* Initiate Reset */FALSE);
			scb = NULL;
d2722 6
a2727 8
		else if (!(scb && (scb->flags & SCB_ACTIVE))){
			printf("%s: ahc_intr - referenced scb not "
			       "valid during scsiint 0x%x scb(%d)\n",
				ahc_name(ahc), status, scb_index);
			AHC_OUTB(ahc, CLRSINT1, status);
			unpause_sequencer(ahc, /*unpause_always*/TRUE);
			AHC_OUTB(ahc, CLRINT, CLRSCSIINT);
			scb = NULL;
d2729 3
a2731 1
		else if (status & SCSIPERR) {
d2733 3
a2735 2
			 * Determine the bus phase and
			 * queue an appropriate message
d2737 42
a2778 34
			char	*phase;
			u_char	mesg_out = MSG_NOOP;
			u_char	lastphase = AHC_INB(ahc, LASTPHASE);

			xs = scb->xs;
			sc_print_addr(xs->sc_link);

			switch(lastphase) {
				case P_DATAOUT:
					phase = "Data-Out";
					break;
				case P_DATAIN:
					phase = "Data-In";
					mesg_out = MSG_INITIATOR_DET_ERR;
					break;
				case P_COMMAND:
					phase = "Command";
					break;
				case P_MESGOUT:
					phase = "Message-Out";
					break;
				case P_STATUS:
					phase = "Status";
					mesg_out = MSG_INITIATOR_DET_ERR;
					break;
				case P_MESGIN:
					phase = "Message-In";
					mesg_out = MSG_PARITY_ERROR;
					break;
				default:
					phase = "unknown";
					break;
			}
			printf("parity error during %s phase.\n", phase);
d2780 1
d2782 2
a2783 5
			 * We've set the hardware to assert ATN if we   
			 * get a parity error on "in" phases, so all we  
			 * need to do is stuff the message buffer with
			 * the appropriate message.  "In" phases have set
			 * mesg_out to something other than MSG_NOP.
d2785 1
a2785 14
			if(mesg_out != MSG_NOOP) {
				AHC_OUTB(ahc, MSG0, mesg_out);
				AHC_OUTB(ahc, MSG_LEN, 1);
			}
			else
				/*
				 * Should we allow the target to make
				 * this decision for us?
				 */
				xs->error = XS_DRIVER_STUFFUP;
		}
		else if (status & SELTO) {
			u_char waiting;
			u_char flags;
a2786 2
			xs = scb->xs;
			xs->error = XS_SELTIMEOUT;
d2788 3
a2790 2
			 * Clear any pending messages for the timed out
			 * target, and mark the target as free
d2792 15
a2806 23
			flags = AHC_INB(ahc, FLAGS);
			AHC_OUTB(ahc, MSG_LEN, 0);
			ahc_unbusy_target(ahc, xs->sc_link->target,
#if defined(__FreeBSD__)
			 	((long)xs->sc_link->fordriver & SELBUSB)
#elif defined(__NetBSD__) || defined(__OpenBSD__)
				IS_SCSIBUS_B(ahc, xs->sc_link)
#endif
				 	? 'B' : 'A');
			/* Stop the selection */
			AHC_OUTB(ahc, SCSISEQ, 0);

			AHC_OUTB(ahc, SCB_CONTROL, 0);

			AHC_OUTB(ahc, CLRSINT1, CLRSELTIMEO);

			AHC_OUTB(ahc, CLRINT, CLRSCSIINT);

			/* Shift the waiting for selection queue forward */
			waiting = AHC_INB(ahc, WAITING_SCBH);
			AHC_OUTB(ahc, SCBPTR, waiting);
			waiting = AHC_INB(ahc, SCB_NEXT);
			AHC_OUTB(ahc, WAITING_SCBH, waiting);
d2808 2
a2809 18
			restart_sequencer(ahc);
		}       
		else if (!(status & BUSFREE)) {
		      sc_print_addr(scb->xs->sc_link);
		      printf("Unknown SCSIINT. Status = 0x%x\n", status);
		      AHC_OUTB(ahc, CLRSINT1, status);
		      unpause_sequencer(ahc, /*unpause_always*/TRUE);
		      AHC_OUTB(ahc, CLRINT, CLRSCSIINT);
		      scb = NULL;
		}
		if(scb != NULL) {
		    /* We want to process the command */
		    untimeout(ahc_timeout, (caddr_t)scb);
		    ahc_done(ahc, scb);
		}
	}
	if (intstat & CMDCMPLT) {
		int   scb_index;
d2811 11
a2821 15
		do {
			scb_index = AHC_INB(ahc, QOUTFIFO);
			scb = ahc->scbarray[scb_index];
			if (!scb || !(scb->flags & SCB_ACTIVE)) {
				printf("%s: WARNING "
				       "no command for scb %d (cmdcmplt)\n"
				       "QOUTCNT == %d\n",
					ahc_name(ahc), scb_index,
					AHC_INB(ahc, QOUTCNT));
				AHC_OUTB(ahc, CLRINT, CLRCMDINT);
				continue;
			}
			AHC_OUTB(ahc, CLRINT, CLRCMDINT);
			untimeout(ahc_timeout, (caddr_t)scb);
			ahc_done(ahc, scb);
d2823 1
a2823 1
		} while (AHC_INB(ahc, QOUTCNT) & ahc->qcntmask);
d2825 15
a2839 6
		ahc_run_waiting_queues(ahc);
	}
#if defined(__NetBSD__) || defined(__OpenBSD__)
	return 1;
#endif
}
d2841 7
a2847 10
static void
ahc_handle_seqint(ahc, intstat)
	struct ahc_data *ahc;
	u_int8_t intstat;
{
	struct scb *scb;
	u_short targ_mask;
	u_char target = (AHC_INB(ahc, SCSIID) >> 4) & 0x0f;
	u_char scratch_offset = target;
	char channel = AHC_INB(ahc, SBLKCTL) & SELBUSB ? 'B': 'A';
d2849 11
a2859 3
	if (channel == 'B')
		scratch_offset += 8;
	targ_mask = (0x01 << scratch_offset); 
d2861 5
a2865 9
	switch (intstat & SEQINT_MASK) {
	case NO_MATCH:
		if (ahc->flags & AHC_PAGESCBS) {
			/* SCB Page-in request */
			u_char tag;
			u_char next;
			u_char disc_scb;
			struct scb *outscb;
			u_char arg_1 = AHC_INB(ahc, ARG_1);
d2867 9
d2877 4
a2880 7
			 * We should succeed, so set this now.
			 * If we don't, and one of the methods
			 * we use to aquire an SCB calls ahc_done,
			 * we may wind up in our start routine
			 * and unpause the adapter without giving
			 * it the correct return value, which will
			 * cause a hang.
d2882 4
a2885 1
			AHC_OUTB(ahc, RETURN_1, SCB_PAGEDIN);
d2887 6
a2892 8
			if (arg_1 == SCB_LIST_NULL) {
				/* Non-tagged command */
				int index;
				
				index = target|(channel == 'B' ? SELBUSB : 0);
				scb = ahc->pagedout_ntscbs[index];
			} else
				scb = ahc->scbarray[arg_1];
a2893 3
			if (!(scb->flags & SCB_PAGED_OUT))
				panic("%s: Request to page in a non paged out "
				      "SCB.", ahc_name(ahc));
d2895 2
a2896 5
			 * Now to pick the SCB to page out.
			 * Either take a free SCB, an assigned SCB,
			 * an SCB that just completed, the first
			 * one on the disconnected SCB list, or
			 * as a last resort a queued SCB.
d2898 7
a2904 41
			if (ahc->free_scbs.stqh_first) {
				outscb = ahc->free_scbs.stqh_first; 
				STAILQ_REMOVE_HEAD(&ahc->free_scbs, links);
				scb->position = outscb->position;
				outscb->position = SCB_LIST_NULL;
				STAILQ_INSERT_HEAD(&ahc->page_scbs, outscb,
						   links);
				AHC_OUTB(ahc, SCBPTR, scb->position);
				ahc_send_scb(ahc, scb);
				scb->flags &= ~SCB_PAGED_OUT;
				goto pagein_done;
			}
			if (intstat & CMDCMPLT) {
				int   scb_index;

				AHC_OUTB(ahc, CLRINT, CLRCMDINT);
				scb_index = AHC_INB(ahc, QOUTFIFO);
				if (!(AHC_INB(ahc, QOUTCNT) & ahc->qcntmask))
					intstat &= ~CMDCMPLT;

				outscb = ahc->scbarray[scb_index];
				if (!outscb || !(outscb->flags & SCB_ACTIVE)) {
					printf("%s: WARNING no command for "
					       "scb %d (cmdcmplt)\n",
					       ahc_name(ahc),
					       scb_index);
					/*
					 * Fall through in hopes of finding
					 * another SCB
					 */
				} else {
					scb->position = outscb->position;
					outscb->position = SCB_LIST_NULL;
					AHC_OUTB(ahc, SCBPTR, scb->position);
					ahc_send_scb(ahc, scb);
					scb->flags &= ~SCB_PAGED_OUT;
					untimeout(ahc_timeout,
						  (caddr_t)outscb);
					ahc_done(ahc, outscb);
					goto pagein_done;
				}
d2906 37
a2942 34
			disc_scb = AHC_INB(ahc, DISCONNECTED_SCBH);
			if (disc_scb != SCB_LIST_NULL) {
				AHC_OUTB(ahc, SCBPTR, disc_scb);
				tag = AHC_INB(ahc, SCB_TAG); 
				outscb = ahc->scbarray[tag];
				next = AHC_INB(ahc, SCB_NEXT);
				if (next != SCB_LIST_NULL) {
					AHC_OUTB(ahc, SCBPTR, next);
					AHC_OUTB(ahc, SCB_PREV,
						 SCB_LIST_NULL);
					AHC_OUTB(ahc, SCBPTR, disc_scb);
				}
				AHC_OUTB(ahc, DISCONNECTED_SCBH, next);
				ahc_page_scb(ahc, outscb, scb);
			} else if (AHC_INB(ahc, QINCNT) & ahc->qcntmask) {
				/*
				 * Pull one of our queued commands
				 * as a last resort
				 */
				disc_scb = AHC_INB(ahc, QINFIFO);
				AHC_OUTB(ahc, SCBPTR, disc_scb);
				tag = AHC_INB(ahc, SCB_TAG);
				outscb = ahc->scbarray[tag];
				if ((outscb->control & 0x23) != TAG_ENB) {
					/*
					 * This is not a simple tagged command
					 * so its position in the queue
					 * matters.  Take the command at the
					 * end of the queue instead.
					 */
					int i;
					u_char saved_queue[AHC_SCB_MAX];
					u_char queued = AHC_INB(ahc, QINCNT)
							& ahc->qcntmask;
d2944 2
a2945 6
					/*
					 * Count the command we removed
					 * already
					 */
					saved_queue[0] = disc_scb;
					queued++;
d2947 2
a2948 3
					/* Empty the input queue */
					for (i = 1; i < queued; i++) 
						saved_queue[i] = AHC_INB(ahc, QINFIFO);
d2950 11
a2960 26
					/*
					 * Put everyone back but the
					 * last entry
					 */
					queued--;
					for (i = 0; i < queued; i++)
						AHC_OUTB(ahc, QINFIFO,
							 saved_queue[i]);

					AHC_OUTB(ahc, SCBPTR,
						 saved_queue[queued]);
					tag = AHC_INB(ahc, SCB_TAG);
					outscb = ahc->scbarray[tag];
				}	
				untimeout(ahc_timeout, (caddr_t)outscb);
				scb->position = outscb->position;
				outscb->position = SCB_LIST_NULL;
				STAILQ_INSERT_HEAD(&ahc->waiting_scbs,
						   outscb, links);
				outscb->flags |= SCB_WAITINGQ;
				ahc_send_scb(ahc, scb);
				scb->flags &= ~SCB_PAGED_OUT;
			}
			else {
				panic("Page-in request with no candidates");
				AHC_OUTB(ahc, RETURN_1, 0);
d2962 6
a2967 1
		  pagein_done:
d2969 2
a2970 9
			printf("%s:%c:%d: no active SCB for reconnecting "
			       "target - issuing ABORT\n",
			       ahc_name(ahc), channel, target);
			printf("SAVED_TCL == 0x%x\n",
			       AHC_INB(ahc, SAVED_TCL));
			ahc_unbusy_target(ahc, target, channel);
			AHC_OUTB(ahc, SCB_CONTROL, 0);
			AHC_OUTB(ahc, CLRSINT1, CLRSELTIMEO);
			AHC_OUTB(ahc, RETURN_1, 0);
d2972 41
d3014 1
a3014 1
	case SEND_REJECT: 
d3016 10
a3025 5
		u_char rejbyte = AHC_INB(ahc, REJBYTE);
		printf("%s:%c:%d: Warning - unknown message received from "
		       "target (0x%x).  Rejecting\n", 
		       ahc_name(ahc), channel, target, rejbyte);
		break; 
d3027 1
a3027 11
	case NO_IDENT: 
		panic("%s:%c:%d: Target did not send an IDENTIFY message. "
		      "SAVED_TCL == 0x%x\n",
		      ahc_name(ahc), channel, target,
		      AHC_INB(ahc, SAVED_TCL));
		break;
	case BAD_PHASE:
		printf("%s:%c:%d: unknown scsi bus phase.  Attempting to "
		       "continue\n", ahc_name(ahc), channel, target);	
		break; 
	case EXTENDED_MSG:
d3029 4
a3032 6
		u_int8_t message_length;
		u_int8_t message_code;

		message_length = AHC_INB(ahc, MSGIN_EXT_LEN);
		message_code = AHC_INB(ahc, MSGIN_EXT_OPCODE);
		switch(message_code) {
d3035 4
a3038 6
			u_int8_t period;
			u_int8_t offset;
			u_int8_t saved_offset;
			u_int8_t targ_scratch;
			u_int8_t maxoffset;
			u_int8_t rate;
d3040 2
a3041 3
			if (message_length != MSG_EXT_SDTR_LEN) {
				AHC_OUTB(ahc, RETURN_1, SEND_REJ);
				ahc->sdtrpending &= ~targ_mask;
a3043 13
			period = AHC_INB(ahc, MSGIN_EXT_BYTE0);
			saved_offset = AHC_INB(ahc, MSGIN_EXT_BYTE1);
			targ_scratch = AHC_INB(ahc, TARG_SCRATCH
					       + scratch_offset);
			if (targ_scratch & WIDEXFER)
				maxoffset = MAX_OFFSET_16BIT;
			else
				maxoffset = MAX_OFFSET_8BIT;
			offset = MIN(saved_offset, maxoffset);
			ahc_scsirate(ahc, &rate, &period, &offset,
				     channel, target);
			/* Preserve the WideXfer flag */
			targ_scratch = rate | (targ_scratch & WIDEXFER);
d3046 5
a3050 2
			 * Update both the target scratch area and the
			 * current SCSIRATE.
d3052 12
a3063 3
			AHC_OUTB(ahc, TARG_SCRATCH + scratch_offset,
				 targ_scratch);
			AHC_OUTB(ahc, SCSIRATE, targ_scratch); 
d3070 6
a3075 9
			if ((ahc->sdtrpending & targ_mask) != 0
			 && (saved_offset == offset)) {
				/*
				 * Don't send an SDTR back to
				 * the target
				 */
				AHC_OUTB(ahc, RETURN_1, 0);
				ahc->needsdtr &= ~targ_mask;
				ahc->sdtrpending &= ~targ_mask;
d3080 7
a3086 18
#ifdef AHC_DEBUG
				if(ahc_debug & AHC_SHOWMISC)
					printf("Sending SDTR!!\n");
#endif
				ahc_construct_sdtr(ahc, /*start_byte*/0,
						   period, offset);
				AHC_OUTB(ahc, RETURN_1, SEND_MSG);

				/*
				 * If we aren't starting a re-negotiation
				 * because we had to go async in response
				 * to a "too low" response from the target
				 * clear the needsdtr flag for this target.
				 */
				if ((ahc->sdtrpending & targ_mask) == 0)
					ahc->needsdtr &= ~targ_mask;
				else
					ahc->sdtrpending |= targ_mask;
d3088 1
d3093 2
a3094 1
			u_int8_t scratch, bus_width;
d3096 3
a3098 3
			if (message_length != MSG_EXT_WDTR_LEN) {
				AHC_OUTB(ahc, RETURN_1, SEND_REJ);
				ahc->wdtrpending &= ~targ_mask;
d3102 9
a3110 3
			bus_width = AHC_INB(ahc, MSGIN_EXT_BYTE0);
			scratch = AHC_INB(ahc, TARG_SCRATCH
					  + scratch_offset);
d3112 2
a3113 1
			if (ahc->wdtrpending & targ_mask) {
d3118 2
a3119 13
				AHC_OUTB(ahc, RETURN_1, 0);
				switch(bus_width){
				case BUS_8_BIT:
					scratch &= 0x7f;
					break;
				case BUS_16_BIT:
					if(bootverbose)
						printf("%s: target %d using "
						       "16Bit transfers\n",
						       ahc_name(ahc), target);
					scratch |= WIDEXFER;	
					break;
				case BUS_32_BIT:
d3121 3
a3123 2
					 * How can we do 32bit transfers
					 * on a 16bit bus?
d3125 2
a3126 2
					AHC_OUTB(ahc, RETURN_1, SEND_REJ);
					printf("%s: target %d requested 32Bit "
d3128 5
a3132 1
					       ahc_name(ahc), target);
d3134 1
a3134 1
				default:
d3141 3
a3143 19
				switch(bus_width) {
				case BUS_8_BIT:
					scratch &= 0x7f;
					break;
				case BUS_32_BIT:
				case BUS_16_BIT:
					if(ahc->type & AHC_WIDE) {
						/* Negotiate 16_BITS */
						bus_width = BUS_16_BIT;
						if(bootverbose)
							printf("%s: target %d "
							       "using 16Bit "
							       "transfers\n",
							       ahc_name(ahc),
							       target);
						scratch |= WIDEXFER;	
					} else
						bus_width = BUS_8_BIT;
					break;
d3145 9
d3156 36
a3191 3
				ahc_construct_wdtr(ahc, /*start_byte*/0,
						   bus_width);
				AHC_OUTB(ahc, RETURN_1, SEND_MSG);
d3193 1
a3193 5
			
			ahc->needwdtr &= ~targ_mask;
			ahc->wdtrpending &= ~targ_mask;
			AHC_OUTB(ahc, TARG_SCRATCH + scratch_offset, scratch);
			AHC_OUTB(ahc, SCSIRATE, scratch); 
d3198 1
a3198 47
			AHC_OUTB(ahc, RETURN_1, SEND_REJ);
		}
	}
	case REJECT_MSG:
	{
		/*
		 * What we care about here is if we had an
		 * outstanding SDTR or WDTR message for this
		 * target.  If we did, this is a signal that
		 * the target is refusing negotiation.
		 */

		u_char targ_scratch;

		targ_scratch = AHC_INB(ahc, TARG_SCRATCH
				       + scratch_offset);

		if (ahc->wdtrpending & targ_mask){
			/* note 8bit xfers and clear flag */
			targ_scratch &= 0x7f;
			ahc->needwdtr &= ~targ_mask;
			ahc->wdtrpending &= ~targ_mask;
#if !(defined(__NetBSD__) || defined(__OpenBSD__)) || defined(DEBUG)
			printf("%s:%c:%d: refuses WIDE negotiation.  Using "
			       "8bit transfers\n", ahc_name(ahc),
			       channel, target);
#endif
		} else if(ahc->sdtrpending & targ_mask){
			/* note asynch xfers and clear flag */
			targ_scratch &= 0xf0;
			ahc->needsdtr &= ~targ_mask;
			ahc->sdtrpending &= ~targ_mask;
#if !(defined(__NetBSD__) || defined(__OpenBSD__)) || defined(DEBUG)
			printf("%s:%c:%d: refuses synchronous negotiation. "
			       "Using asynchronous transfers\n",
			       ahc_name(ahc),
			       channel, target);
#endif
		} else {
			/*
			 * Otherwise, we ignore it.
			 */
#ifdef AHC_DEBUG
			if(ahc_debug & AHC_SHOWMISC)
				printf("%s:%c:%d: Message reject -- ignored\n",
				       ahc_name(ahc), channel, target);
#endif
a3200 2
		AHC_OUTB(ahc, TARG_SCRATCH + scratch_offset, targ_scratch);
		AHC_OUTB(ahc, SCSIRATE, targ_scratch);
d3203 14
a3216 29
	case BAD_STATUS:
	{
		int	scb_index;
		struct	scsi_xfer *xs;

		/* The sequencer will notify us when a command
		 * has an error that would be of interest to
		 * the kernel.  This allows us to leave the sequencer
		 * running in the common case of command completes
		 * without error.
		 */

		scb_index = AHC_INB(ahc, SCB_TAG);
		scb = ahc->scbarray[scb_index];

		/*
		 * Set the default return value to 0 (don't
		 * send sense).  The sense code will change
		 * this if needed and this reduces code
		 * duplication.
		 */
		AHC_OUTB(ahc, RETURN_1, 0);
		if (!(scb && (scb->flags & SCB_ACTIVE))) {
			printf("%s:%c:%d: ahc_intr - referenced scb "
			       "not valid during seqint 0x%x scb(%d)\n",
			       ahc_name(ahc),
			       channel, target, intstat,
			       scb_index);
			goto clear;
d3218 18
a3235 23

		xs = scb->xs;

		scb->status = AHC_INB(ahc, SCB_TARGET_STATUS);

#ifdef AHC_DEBUG
		if((ahc_debug & AHC_SHOWSCBS)
		   && xs->sc_link->target == DEBUGTARGET)
			ahc_print_scb(scb);
#endif
		xs->status = scb->status;
		switch(scb->status){
		case SCSI_OK:
			printf("%s: Interrupted for staus of"
			       " 0???\n", ahc_name(ahc));
			break;
		case SCSI_CHECK:
#ifdef AHC_DEBUG
			if(ahc_debug & AHC_SHOWSENSE)
			{

				sc_print_addr(xs->sc_link);
				printf("requests Check Status\n");
d3237 4
d3242 4
a3245 86

			if ((xs->error == XS_NOERROR)
			    && !(scb->flags & SCB_SENSE)) {
				struct ahc_dma_seg *sg = scb->ahc_dma;
				struct scsi_sense *sc = &(scb->sense_cmd);
#ifdef AHC_DEBUG
				if (ahc_debug & AHC_SHOWSENSE)
				{
					sc_print_addr(xs->sc_link);
					printf("Sending Sense\n");
				}
#endif
#if defined(__FreeBSD__)
				sc->op_code = REQUEST_SENSE;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
				sc->opcode = REQUEST_SENSE;
#endif
				sc->byte2 =  xs->sc_link->lun << 5;
				sc->length = sizeof(struct scsi_sense_data);
				sc->control = 0;
				sg->addr = KVTOPHYS(&xs->sense);
				sg->len = sizeof(struct scsi_sense_data);

				scb->control &= DISCENB;
				scb->status = 0;
				scb->SG_segment_count = 1;
				scb->SG_list_pointer = KVTOPHYS(sg);
				scb->data = sg->addr; 
				scb->datalen = sg->len;
#ifdef AHC_BROKEN_CACHE
				if (ahc_broken_cache)
					INVALIDATE_CACHE();
#endif
				scb->cmdpointer = KVTOPHYS(sc);
				scb->cmdlen = sizeof(*sc);

				scb->flags |= SCB_SENSE;
				ahc_send_scb(ahc, scb);
				/*
				 * Ensure that the target is "BUSY"
				 * so we don't get overlapping 
				 * commands if we happen to be doing
				 * tagged I/O.
				 */
				ahc_busy_target(ahc, target, channel);

				/*
				 * Make us the next command to run
				 */
				ahc_add_waiting_scb(ahc, scb);
				AHC_OUTB(ahc, RETURN_1, SEND_SENSE);
				break;
			}
			/*
			 * Clear the SCB_SENSE Flag and have
			 * the sequencer do a normal command
			 * complete with either a "DRIVER_STUFFUP"
			 * error or whatever other error condition
			 * we already had.
			 */
			scb->flags &= ~SCB_SENSE;
			if (xs->error == XS_NOERROR)
				xs->error = XS_DRIVER_STUFFUP;
			break;
		case SCSI_BUSY:
			xs->error = XS_BUSY;
			sc_print_addr(xs->sc_link);
			printf("Target Busy\n");
			break;
		case SCSI_QUEUE_FULL:
			/*
			 * The upper level SCSI code will someday
			 * handle this properly.
			 */
			sc_print_addr(xs->sc_link);
			printf("Queue Full\n");
			scb->flags |= SCB_ASSIGNEDQ;
			STAILQ_INSERT_TAIL(&ahc->assigned_scbs,scb, links);
			AHC_OUTB(ahc, RETURN_1, SEND_SENSE);
			break;
		default:
			sc_print_addr(xs->sc_link);
			printf("unexpected targ_status: %x\n", scb->status);
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
a3247 4
	case RESIDUAL:
	{
		int scb_index;
		struct scsi_xfer *xs;
d3249 1
a3249 3
		scb_index = AHC_INB(ahc, SCB_TAG);
		scb = ahc->scbarray[scb_index];
		xs = scb->xs;
d3251 1
a3251 3
		 * Don't clobber valid resid info with
		 * a resid coming from a check sense
		 * operation.
d3253 6
a3258 2
		if (!(scb->flags & SCB_SENSE)) {
			int resid_sgs;
d3260 3
a3262 7
			/*
			 * Remainder of the SG where the transfer
			 * stopped.
			 */
			xs->resid = (AHC_INB(ahc, SCB_RESID_DCNT2)<<16) |
				    (AHC_INB(ahc, SCB_RESID_DCNT1)<<8)  |
				    AHC_INB(ahc, SCB_RESID_DCNT0);
d3264 2
a3265 13
			/*
			 * Add up the contents of all residual
			 * SG segments that are after the SG where
			 * the transfer stopped.
			 */
			resid_sgs = AHC_INB(ahc, SCB_RESID_SGCNT) - 1;
			while (resid_sgs > 0) {
				int sg;

				sg = scb->SG_segment_count - resid_sgs;
				xs->resid += scb->ahc_dma[sg].len;
				resid_sgs--;
			}
d3267 7
a3273 58
#if defined(__FreeBSD__)
			xs->flags |= SCSI_RESID_VALID;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
			/* XXX - Update to do this right */
#endif
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWMISC) {
				sc_print_addr(xs->sc_link);
				printf("Handled Residual of %ld bytes\n"
				       ,xs->resid);
			}
#endif
		}
		break;
	}
	case ABORT_TAG:
	{
		int   scb_index;
		struct scsi_xfer *xs;

		scb_index = AHC_INB(ahc, SCB_TAG);
		scb = ahc->scbarray[scb_index];
		xs = scb->xs;
		/*
		 * We didn't recieve a valid tag back from
		 * the target on a reconnect.
		 */
		sc_print_addr(xs->sc_link);
		printf("invalid tag received -- sending ABORT_TAG\n");
		xs->error = XS_DRIVER_STUFFUP;
		untimeout(ahc_timeout, (caddr_t)scb);
		ahc_done(ahc, scb);
		break;
	}
	case AWAITING_MSG:
	{
		int   scb_index;
		scb_index = AHC_INB(ahc, SCB_TAG);
		scb = ahc->scbarray[scb_index];
		/*
		 * This SCB had a zero length command, informing
		 * the sequencer that we wanted to send a special
		 * message to this target.  We only do this for
		 * BUS_DEVICE_RESET messages currently.
		 */
		if (scb->flags & SCB_DEVICE_RESET) {
			AHC_OUTB(ahc, MSG0,
				 MSG_BUS_DEV_RESET);
			AHC_OUTB(ahc, MSG_LEN, 1);
			printf("Bus Device Reset Message Sent\n");
		} else if (scb->flags & SCB_MSGOUT_WDTR) {
			ahc_construct_wdtr(ahc, AHC_INB(ahc, MSG_LEN),
					   BUS_16_BIT);
		} else if (scb->flags & SCB_MSGOUT_SDTR) {
			u_int8_t target_scratch;
			u_int8_t ultraenable;			
			int sxfr;
			int i;
d3275 4
a3278 66
			/* Pull the user defined setting */
			target_scratch = AHC_INB(ahc, TARG_SCRATCH
						 + scratch_offset);
			
			sxfr = target_scratch & SXFR;
			if (scratch_offset < 8)
				ultraenable = AHC_INB(ahc, ULTRA_ENB);
			else
				ultraenable = AHC_INB(ahc, ULTRA_ENB + 1);
			
			if (ultraenable & targ_mask)
				/* Want an ultra speed in the table */
				sxfr |= 0x100;
			
			for (i = 0; i < ahc_num_syncrates; i++)
				if (sxfr == ahc_syncrates[i].sxfr)
					break;
							
			ahc_construct_sdtr(ahc, AHC_INB(ahc, MSG_LEN),
					   ahc_syncrates[i].period,
					   target_scratch & WIDEXFER ?
					   MAX_OFFSET_16BIT : MAX_OFFSET_8BIT);
		} else	
			panic("ahc_intr: AWAITING_MSG for an SCB that "
			      "does not have a waiting message");
		break;
	}
	case IMMEDDONE:
	{
		/*
		 * Take care of device reset messages
		 */
		u_char scbindex = AHC_INB(ahc, SCB_TAG);
		scb = ahc->scbarray[scbindex];
		if (scb->flags & SCB_DEVICE_RESET) {
			u_char targ_scratch;
			int found;
			/*
			 * Go back to async/narrow transfers and
			 * renegotiate.
			 */
			ahc_unbusy_target(ahc, target, channel);
			ahc->needsdtr |= ahc->needsdtr_orig & targ_mask;
			ahc->needwdtr |= ahc->needwdtr_orig & targ_mask;
			ahc->sdtrpending &= ~targ_mask;
			ahc->wdtrpending &= ~targ_mask;
			targ_scratch = AHC_INB(ahc, TARG_SCRATCH 
					       + scratch_offset);
			targ_scratch &= SXFR;
			AHC_OUTB(ahc, TARG_SCRATCH + scratch_offset,
				 targ_scratch);
			found = ahc_reset_device(ahc, target,
						 channel, SCB_LIST_NULL, 
						 XS_NOERROR);
			sc_print_addr(scb->xs->sc_link);
			printf("Bus Device Reset delivered. "
			       "%d SCBs aborted\n", found);
			ahc->in_timeout = FALSE;
			ahc_run_done_queue(ahc);
		} else
			panic("ahc_intr: Immediate complete for "
			      "unknown operation.");
		break;
	}
	case DATA_OVERRUN:
	{
d3280 4
a3283 15
		 * When the sequencer detects an overrun, it
		 * sets STCNT to 0x00ffffff and allows the
		 * target to complete its transfer in
		 * BITBUCKET mode.
		 */
		u_char scbindex = AHC_INB(ahc, SCB_TAG);
		u_int32_t overrun;
		scb = ahc->scbarray[scbindex];
		overrun = AHC_INB(ahc, STCNT0)
			| (AHC_INB(ahc, STCNT1) << 8)
			| (AHC_INB(ahc, STCNT2) << 16);
		overrun = 0x00ffffff - overrun;
		sc_print_addr(scb->xs->sc_link);
		printf("data overrun of %d bytes detected."
		       "  Forcing a retry.\n", overrun);
d3285 5
a3289 2
		 * Set this and it will take affect when the
		 * target does a command complete.
d3291 61
a3351 15
		scb->xs->error = XS_DRIVER_STUFFUP;
		break;
	}
#if NOT_YET
	/* XXX Fill these in later */
	case MESG_BUFFER_BUSY:
		break;
	case MSGIN_PHASEMIS:
		break;
#endif
	default:
		printf("ahc_intr: seqint, "
		       "intstat == 0x%x, scsisigi = 0x%x\n",
		       intstat, AHC_INB(ahc, SCSISIGI));
		break;
d3353 15
a3368 1
clear:
d3370 3
a3372 2
	 * Clear the upper byte that holds SEQINT status
	 * codes and clear the SEQINT bit.
d3374 10
a3383 8
	AHC_OUTB(ahc, CLRINT, CLRSEQINT);

	/*
	 *  The sequencer is paused immediately on
	 *  a SEQINT, so we should restart it when
	 *  we're done.
	 */
	unpause_sequencer(ahc, /*unpause_always*/TRUE);
d3387 1
a3387 1
 * We have a scb which has been processed by the
d3391 1
a3391 1
static void
d3393 1
a3393 1
	struct ahc_data *ahc;
d3397 3
d3402 33
d3436 2
a3437 2
	 * Put the results of the operation
	 * into the xfer and call whoever started it
d3439 34
a3472 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d3474 16
a3489 6
		/* Don't override the error value. */
	} else if (scb->flags & SCB_ABORTED) {
		xs->error = XS_DRIVER_STUFFUP;
	} else
#endif
	if(scb->flags & SCB_SENSE)
d3491 13
a3503 24
	if(scb->flags & SCB_SENTORDEREDTAG)
		ahc->in_timeout = FALSE;
#if defined(__FreeBSD__)
	if ((xs->flags & SCSI_ERR_OK) && !(xs->error == XS_SENSE)) {
		/* All went correctly  OR errors expected */
		xs->error = XS_NOERROR;
	}
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	/*
	 * Since NetBSD nor OpenBSD doesn't have error ignoring operation mode
	 * (SCSI_ERR_OK in FreeBSD), we don't have to care this case.
	 */
#endif
	xs->flags |= ITSDONE;
#ifdef AHC_TAGENABLE
	if(xs->cmd->opcode == INQUIRY && xs->error == XS_NOERROR)
	{
		struct scsi_inquiry_data *inq_data;
		u_short mask = 0x01 << (xs->sc_link->target |
				(scb->tcl & 0x08));
		/*
		 * Sneak a look at the results of the SCSI Inquiry
		 * command and see if we can do Tagged queing.  This
		 * should really be done by the higher level drivers.
d3505 9
a3513 23
		inq_data = (struct scsi_inquiry_data *)xs->data;
		if((inq_data->flags & SID_CmdQue) && !(ahc->tagenable & mask))
		{
		        printf("%s: target %d Tagged Queuing Device\n",
				ahc_name(ahc), xs->sc_link->target);
			ahc->tagenable |= mask;
			if(ahc->maxhscbs >= 16 || (ahc->flags & AHC_PAGESCBS)) {
				/* Default to 8 tags */
				xs->sc_link->opennings += 6;
			}
			else
			{
				/*
				 * Default to 4 tags on whimpy
				 * cards that don't have much SCB
				 * space and can't page.  This prevents
				 * a single device from hogging all
				 * slots.  We should really have a better
				 * way of providing fairness.
				 */
				xs->sc_link->opennings += 2;
			}
		}
a3514 3
#endif
	ahc_free_scb(ahc, scb, xs->flags);
	scsi_done(xs);
a3515 1
#if defined(__NetBSD__) || defined(__OpenBSD__)	/* XXX */
d3524 24
a3547 3
	if (ahc->sc_xxxq.lh_first != NULL)
		(void) ahc_scsi_cmd(ahc->sc_xxxq.lh_first);
#endif /* __NetBSD__ || __OpenBSD__ */
d3555 1
a3555 1
	struct  ahc_data *ahc;
a3556 2
	u_int8_t  scsi_conf, sblkctl, i;
	u_int16_t ultraenable = 0;
d3558 39
d3600 18
d3619 22
a3640 4
	/* Handle the SCBPAGING option */
#ifndef AHC_SCBPAGING_ENABLE
	ahc->flags &= ~AHC_PAGESCBS;
#endif
d3642 9
a3650 36
	/* Determine channel configuration and who we are on the scsi bus. */
	switch ( (sblkctl = AHC_INB(ahc, SBLKCTL) & 0x0a) ) {
	    case 0:
		ahc->our_id = (AHC_INB(ahc, SCSICONF) & HSCSIID);
		ahc->flags &= ~AHC_CHANNEL_B_PRIMARY;
		if(ahc->type == AHC_394)
			printf("Channel %c, SCSI Id=%d, ", 
				ahc->flags & AHC_CHNLB ? 'B' : 'A',
				ahc->our_id);
		else
			printf("Single Channel, SCSI Id=%d, ", ahc->our_id);
		AHC_OUTB(ahc, FLAGS, SINGLE_BUS | (ahc->flags & AHC_PAGESCBS));
		break;
	    case 2:
		ahc->our_id = (AHC_INB(ahc, SCSICONF + 1) & HWSCSIID);
		ahc->flags &= ~AHC_CHANNEL_B_PRIMARY;
		if(ahc->type == AHC_394)
			printf("Wide Channel %c, SCSI Id=%d, ", 
				ahc->flags & AHC_CHNLB ? 'B' : 'A',
				ahc->our_id);
		else
			printf("Wide Channel, SCSI Id=%d, ", ahc->our_id);
		ahc->type |= AHC_WIDE;
		AHC_OUTB(ahc, FLAGS, WIDE_BUS | (ahc->flags & AHC_PAGESCBS));
		break;
	    case 8:
		ahc->our_id = (AHC_INB(ahc, SCSICONF) & HSCSIID);
		ahc->our_id_b = (AHC_INB(ahc, SCSICONF + 1) & HSCSIID);
		printf("Twin Channel, A SCSI Id=%d, B SCSI Id=%d, ",
			ahc->our_id, ahc->our_id_b);
		ahc->type |= AHC_TWIN;
		AHC_OUTB(ahc, FLAGS, TWIN_BUS | (ahc->flags & AHC_PAGESCBS));
		break;
	    default:
		printf(" Unsupported adapter type.  Ignoring\n");
		return(-1);
d3653 14
a3666 18
	/* Determine the number of SCBs */

	{
		AHC_OUTB(ahc, SCBPTR, 0);
		AHC_OUTB(ahc, SCB_CONTROL, 0);
		for(i = 1; i < AHC_SCB_MAX; i++) {
			AHC_OUTB(ahc, SCBPTR, i);
			AHC_OUTB(ahc, SCB_CONTROL, i);
			if(AHC_INB(ahc, SCB_CONTROL) != i)
				break;
			AHC_OUTB(ahc, SCBPTR, 0);
			if(AHC_INB(ahc, SCB_CONTROL) != 0)
				break;
			/* Clear the control byte. */
			AHC_OUTB(ahc, SCBPTR, i);
			AHC_OUTB(ahc, SCB_CONTROL, 0);

			ahc->qcntmask |= i;     /* Update the count mask. */
d3668 2
d3671 1
a3671 3
		/* Ensure we clear the 0 SCB's control byte. */
		AHC_OUTB(ahc, SCBPTR, 0);
		AHC_OUTB(ahc, SCB_CONTROL, 0);
d3673 4
a3676 8
		ahc->qcntmask |= i;
		ahc->maxhscbs = i;
	}

	if((ahc->maxhscbs < AHC_SCB_MAX) && (ahc->flags & AHC_PAGESCBS))
		ahc->maxscbs = AHC_SCB_MAX;
	else {
		ahc->maxscbs = ahc->maxhscbs;
d3678 1
a3680 2
	printf("%d SCBs\n", ahc->maxhscbs);

d3682 2
a3683 3
	if(ahc_debug & AHC_SHOWMISC) {
		struct scb	test;
		printf("%s: hardware scb %ld bytes; kernel scb; "
d3686 2
a3687 2
		        (u_long)&(test.next) - (u_long)(&test),
			sizeof(test),
d3692 3
a3694 3
	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
	if(ahc->type & AHC_TWIN)
	{
d3699 3
a3701 7
		AHC_OUTB(ahc, SCSIID, ahc->our_id_b);
		scsi_conf = AHC_INB(ahc, SCSICONF + 1);
		AHC_OUTB(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))
					| ENSTIMER|ACTNEGEN|STPWEN);
		AHC_OUTB(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
		if(ahc->type & AHC_ULTRA)
			AHC_OUTB(ahc, SXFRCTL0, DFON|SPIOEN|ULTRAEN);
d3703 10
a3712 17
			AHC_OUTB(ahc, SXFRCTL0, DFON|SPIOEN);

		if(scsi_conf & RESET_SCSI) {
			/* Reset the bus */
#if (!defined(__NetBSD__) && !defined(__OpenBSD__)) || defined(DEBUG)
			if(bootverbose)
				printf("%s: Resetting Channel B\n",
				       ahc_name(ahc));
#endif
			AHC_OUTB(ahc, SCSISEQ, SCSIRSTO);
			DELAY(1000);
			AHC_OUTB(ahc, SCSISEQ, 0);

			/* Ensure we don't get a RSTI interrupt from this */
			AHC_OUTB(ahc, CLRSINT1, CLRSCSIRSTI);
			AHC_OUTB(ahc, CLRINT, CLRSCSIINT);
		}
d3715 1
a3715 1
		AHC_OUTB(ahc, SBLKCTL, 0);
d3717 3
a3719 7
	AHC_OUTB(ahc, SCSIID, ahc->our_id);
	scsi_conf = AHC_INB(ahc, SCSICONF);
	AHC_OUTB(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))
				| ENSTIMER|ACTNEGEN|STPWEN);
	AHC_OUTB(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
	if(ahc->type & AHC_ULTRA)
		AHC_OUTB(ahc, SXFRCTL0, DFON|SPIOEN|ULTRAEN);
d3721 11
a3731 17
		AHC_OUTB(ahc, SXFRCTL0, DFON|SPIOEN);

	if(scsi_conf & RESET_SCSI) {
		/* Reset the bus */
#if (!defined(__NetBSD__) && !defined(__OpenBSD__)) || defined(DEBUG)
		if(bootverbose)
			printf("%s: Resetting Channel A\n", ahc_name(ahc));
#endif

		AHC_OUTB(ahc, SCSISEQ, SCSIRSTO);
		DELAY(1000);
		AHC_OUTB(ahc, SCSISEQ, 0);

		/* Ensure we don't get a RSTI interrupt from this */
		AHC_OUTB(ahc, CLRSINT1, CLRSCSIRSTI);
		AHC_OUTB(ahc, CLRINT, CLRSCSIINT);
	}
d3735 1
a3735 6
	 * the board bios has left us.  In the lower four bits of each
	 * target's scratch space any value other than 0 indicates
	 * that we should initiate synchronous transfers.  If it's zero,
	 * the user or the BIOS has decided to disable synchronous
	 * negotiation to that target so we don't activate the needsdtr
	 * flag.
d3737 2
a3738 2
	ahc->needsdtr_orig = 0;
	ahc->needwdtr_orig = 0;
d3741 1
a3741 1
	if(ahc->flags & AHC_USEDEFAULTS) {
d3744 11
a3754 1
		ahc->discenable = 0xff;
a3755 3
	else
		ahc->discenable = ~((AHC_INB(ahc, DISC_DSB + 1) << 8)
				   | AHC_INB(ahc, DISC_DSB));
d3757 1
a3757 1
	if(!(ahc->type & (AHC_WIDE|AHC_TWIN)))
d3760 19
a3778 2
	for(i = 0; i <= max_targ; i++){
		u_char target_settings;
d3780 13
a3792 5
			target_settings = 0; /* 10MHz */
			ahc->needsdtr_orig |= (0x01 << i);
			ahc->needwdtr_orig |= (0x01 << i);
		}
		else {
d3794 5
a3798 1
			target_settings = AHC_INB(ahc, TARG_SCRATCH + i);
d3800 29
a3828 30
			if(target_settings & 0x0f){
				ahc->needsdtr_orig |= (0x01 << i);
				/*Default to asynchronous transfers(0 offset)*/
				target_settings &= 0xf0;
			}
			if(target_settings & 0x80){
				ahc->needwdtr_orig |= (0x01 << i);
				/*
				 * We'll set the Wide flag when we
				 * are successful with Wide negotiation.
				 * Turn it off for now so we aren't
				 * confused.
				 */
				target_settings &= 0x7f;
			}
			if(ahc->type & AHC_ULTRA) {
				/*
				 * Enable Ultra for any target that
				 * has a valid ultra syncrate setting.
				 */
				u_char rate = target_settings & 0x70;
				if(rate == 0x00 || rate == 0x10 ||
				   rate == 0x20 || rate == 0x40) {
					if(rate == 0x40) {
						/* Treat 10MHz specially */
						target_settings &= ~0x70;
					}
					else
						ultraenable |= (0x01 << i);
				}
d3830 8
a3837 2
		}
		AHC_OUTB(ahc, TARG_SCRATCH+i,target_settings);
d3839 3
d3843 20
a3862 13
	 * If we are not a WIDE device, forget WDTR.  This
	 * makes the driver work on some cards that don't
	 * leave these fields cleared when the BIOS is not
	 * installed.
	 */
	if(!(ahc->type & AHC_WIDE))
		ahc->needwdtr_orig = 0;
	ahc->needsdtr = ahc->needsdtr_orig;
	ahc->needwdtr = ahc->needwdtr_orig;
	ahc->sdtrpending = 0;
	ahc->wdtrpending = 0;
	ahc->tagenable = 0;
	ahc->orderedtag = 0;
d3864 18
a3881 2
	AHC_OUTB(ahc, ULTRA_ENB, ultraenable & 0xff);
	AHC_OUTB(ahc, ULTRA_ENB + 1, (ultraenable >> 8) & 0xff);
d3884 1
a3884 2
	/* How did we do? */
	if(ahc_debug & AHC_SHOWMISC)
d3886 3
a3888 2
			"DISCENABLE == 0x%x\n", ahc->needsdtr, 
			ahc->needwdtr, ahc->discenable);
a3889 4
	/*
	 * Set the number of available SCBs
	 */
	AHC_OUTB(ahc, SCBCOUNT, ahc->maxhscbs);
d3891 3
a3893 5
	/*
	 * 2's compliment of maximum tag value
	 */
	i = ahc->maxscbs;
	AHC_OUTB(ahc, COMP_SCBCOUNT, -i & 0xff);
d3896 2
a3897 3
	 * QCount mask to deal with broken aic7850s that
	 * sporadically get garbage in the upper bits of
	 * their QCount registers.
d3899 6
a3904 1
	AHC_OUTB(ahc, QCNTMASK, ahc->qcntmask);
a3905 3
	/* We don't have any busy targets right now */
	AHC_OUTB(ahc, ACTIVE_A, 0);
	AHC_OUTB(ahc, ACTIVE_B, 0);
d3908 1
a3908 1
	AHC_OUTB(ahc, WAITING_SCBH, SCB_LIST_NULL);
d3911 1
a3911 1
	AHC_OUTB(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);
d3914 11
a3924 1
	AHC_OUTB(ahc, MSG_LEN, 0x00);
d3930 1
a3930 2
#if (!defined(__NetBSD__) && !defined(__OpenBSD__)) || defined(DEBUG)
	if(bootverbose)
a3932 1
#endif
d3936 2
a3937 13
#if (!defined(__NetBSD__) && !defined(__OpenBSD__)) || defined(DEBUG)
	if(bootverbose)
		printf("Done\n");
#endif

	AHC_OUTB(ahc, SEQCTL, FASTMODE);

	unpause_sequencer(ahc, /*unpause_always*/TRUE);

	/*
	 * Note that we are going and return (to probe)
	 */
	ahc->flags |= AHC_INIT;
a3940 4
static void
ahcminphys(bp)
        struct buf *bp;
{
d3942 4
a3945 5
 * Even though the card can transfer up to 16megs per command
 * we are limited by the number of segments in the dma segment
 * list that we can hold.  The worst case is that all pages are
 * discontinuous physically, hense the "page per segment" limit
 * enforced here.
d3947 8
a3954 6
        if (bp->b_bcount > ((AHC_NSEG - 1) * PAGE_SIZE)) {
                bp->b_bcount = ((AHC_NSEG - 1) * PAGE_SIZE);
        }
#if defined(__NetBSD__) || defined(__OpenBSD__)
	minphys(bp);
#endif
d3957 3
a3959 9
#if defined(__NetBSD__)	|| defined(__OpenBSD__)	/* XXX */
/*
 * Insert a scsi_xfer into the software queue.  We overload xs->free_list
 * to to ensure we don't run into a queue resource shortage, and keep
 * a pointer to the last entry around to make insertion O(C).
 */
static void
ahc_xxx_enqueue(ahc, xs, infront)
	struct ahc_data *ahc;
a3960 1
	int infront;
d3962 5
d3968 7
a3974 3
	if (infront || ahc->sc_xxxq.lh_first == NULL) {
		if (ahc->sc_xxxq.lh_first == NULL)
			ahc->sc_xxxqlast = xs;
a3977 1

d3982 4
a3985 8
/*
 * Pull a scsi_xfer off the front of the software queue.  When we
 * pull the last one off, we need to clear the pointer to the last
 * entry.
 */
static struct scsi_xfer *
ahc_xxx_dequeue(ahc)
	struct ahc_data *ahc;
d3987 12
a3998 3
	struct scsi_xfer *xs;

	xs = ahc->sc_xxxq.lh_first;
a3999 1

d4002 1
d4004 6
a4009 1
	return (xs);
a4010 1
#endif
d4013 1
a4013 3
 * start a scsi operation given the command and
 * the data address, target, and lun all of which
 * are stored in the scsi_xfer struct
d4015 22
a4036 1
static int32_t
d4038 1
a4038 1
        struct scsi_xfer *xs;
d4040 30
a4069 20
	struct	scb *scb;
	struct	ahc_dma_seg *sg;
	int	seg;		/* scatter gather seg being worked on */
	unsigned long thiskv, nextkv;
	physaddr thisphys, nextphys;
	int	bytes_this_seg, bytes_this_page, datalen, flags;
	struct	ahc_data *ahc;
	u_short	mask;
	int	s;
#if defined(__NetBSD__) || defined(__OpenBSD__)	/* XXX */
	int	dontqueue = 0, fromqueue = 0;
#endif

	ahc = (struct ahc_data *)xs->sc_link->adapter_softc;
	mask = (0x01 << (xs->sc_link->target
#if defined(__FreeBSD__)
				| ((u_long)xs->sc_link->fordriver & 0x08)));
#elif defined(__NetBSD__) || defined(__OpenBSD__)
			| (IS_SCSIBUS_B(ahc, xs->sc_link) ? SELBUSB : 0) ));
#endif
d4071 5
a4075 1
	SC_DEBUG(xs->sc_link, SDEV_DB2, ("ahc_scsi_cmd\n"));
d4077 5
a4081 3
#if defined(__NetBSD__) || (__OpenBSD__)	/* XXX */
	/* must protect the queue */
	s = splbio();
d4084 2
a4085 4
	 * If we're running the queue from ahc_done(), we're called
	 * with the first entry in the queue as our argument.
	 * Pull it off; if we can't run the job, it will get placed
	 * back at the front.
d4087 13
a4099 4
	if (xs == ahc->sc_xxxq.lh_first) {
		xs = ahc_xxx_dequeue(ahc);
		fromqueue = 1;
		goto get_scb;
d4102 2
d4111 1
a4111 1
	if (ahc->sc_xxxq.lh_first != NULL) {
d4125 4
a4128 2
		ahc_xxx_enqueue(ahc, xs, 0);
		xs = ahc_xxx_dequeue(ahc);
d4130 1
d4133 5
a4137 2
 get_scb:
#endif /* __NetBSD__ || __OpenBSD__ */
d4139 4
a4142 18
	 * get an scb to use. If the transfer
	 * is from a buf (possibly from interrupt time)
	 * then we can't allow it to sleep
	 */
	flags = xs->flags;
	if (flags & ITSDONE) {
		printf("%s: Already done?", ahc_name(ahc));
		xs->flags &= ~ITSDONE;
	}
	if (!(flags & INUSE)) {
		printf("%s: Not in use?", ahc_name(ahc));
		xs->flags |= INUSE;
	}
	if (!(scb = ahc_get_scb(ahc, flags))) {
#if defined(__NetBSD__) || defined(__OpenBSD__)	/* XXX */
		/*
		 * If we can't queue, we lose.
		 */
d4151 2
a4152 2
		 * back in the front, otherwise tack ourselves onto
		 * the end.
d4154 4
a4157 1
		ahc_xxx_enqueue(ahc, xs, fromqueue);
a4160 4
#else
		xs->error = XS_DRIVER_STUFFUP;
		return (TRY_AGAIN_LATER);
#endif /* __NetBSD__ || __OpenBSD__ */
d4163 5
a4167 3
#if defined(__NetBSD__) || defined(__OpenBSD__)
	/* we're done playing with the queue */
	splx(s);
d4169 6
d4176 2
a4177 6
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("start scb(%p)\n", scb));
	scb->xs = xs;
	if (flags & SCSI_RESET) {
		scb->flags |= SCB_DEVICE_RESET|SCB_IMMED;
		scb->control |= MK_MESSAGE;
	}
d4182 14
a4195 7
	if(ahc->tagenable & mask) {
		scb->control |= TAG_ENB;
		if(ahc->orderedtag & mask) {
			printf("Ordered Tag sent\n");
			scb->control |= 0x02;
			ahc->orderedtag &= ~mask;
		}
d4197 14
a4210 7
	if(ahc->discenable & mask)
		scb->control |= DISCENB;
	if((ahc->needwdtr & mask) && !(ahc->wdtrpending & mask))
	{
		scb->control |= MK_MESSAGE;
		scb->flags |= SCB_MSGOUT_WDTR;
		ahc->wdtrpending |= mask;
d4212 36
a4247 69
	else if((ahc->needsdtr & mask) && !(ahc->sdtrpending & mask))
	{
		scb->control |= MK_MESSAGE;
		scb->flags |= SCB_MSGOUT_SDTR;
		ahc->sdtrpending |= mask;
	}
	scb->tcl = ((xs->sc_link->target << 4) & 0xF0) |
#if defined(__FreeBSD__)
				  ((u_long)xs->sc_link->fordriver & 0x08) |
#elif defined(__NetBSD__) || defined(__OpenBSD__)
				  (IS_SCSIBUS_B(ahc,xs->sc_link)? SELBUSB : 0)|
#endif
				  (xs->sc_link->lun & 0x07);
	scb->cmdlen = xs->cmdlen;
	scb->cmdpointer = KVTOPHYS(xs->cmd);
	xs->resid = 0;
	xs->status = 0;
	if (xs->datalen) {      /* should use S/G only if not zero length */
		scb->SG_list_pointer = KVTOPHYS(scb->ahc_dma);
		sg = scb->ahc_dma;
		seg = 0;
		/*
		 * Set up the scatter gather block
		 */
		SC_DEBUG(xs->sc_link, SDEV_DB4,
			 ("%ld @@%p:- ", xs->datalen, xs->data));
		datalen = xs->datalen;
		thiskv = (unsigned long) xs->data;
		thisphys = KVTOPHYS(thiskv);

		while ((datalen) && (seg < AHC_NSEG)) {
			bytes_this_seg = 0;

			/* put in the base address */
			sg->addr = thisphys;

			SC_DEBUGN(xs->sc_link, SDEV_DB4, ("0x%lx", thisphys));

			/* do it at least once */
			nextphys = thisphys;
			while ((datalen) && (thisphys == nextphys)) {
				/*
				 * This page is contiguous (physically)
				 * with the the last, just extend the
				 * length
				 */
				/* how far to the end of the page */
				nextphys = (thisphys & (~(PAGE_SIZE- 1)))
					   + PAGE_SIZE;
				bytes_this_page = nextphys - thisphys;
				/**** or the data ****/
				bytes_this_page = min(bytes_this_page, datalen);
				bytes_this_seg += bytes_this_page;
				datalen -= bytes_this_page;

				/* get more ready for the next page */
				nextkv = thiskv;
				nextkv &= ~((unsigned long) PAGE_SIZE - 1);
				nextkv += PAGE_SIZE;
				if (datalen)
					thisphys = KVTOPHYS(nextkv);
				thiskv = nextkv;
			}
			/*
			 * next page isn't contiguous, finish the seg
			 */
			SC_DEBUGN(xs->sc_link, SDEV_DB4,
					("(0x%x)", bytes_this_seg));
			sg->len = bytes_this_seg;
d4249 1
a4249 1
			seg++;
a4250 1
		scb->SG_segment_count = seg;
d4252 11
a4262 16
		/* Copy the first SG into the data pointer area */
		scb->data = scb->ahc_dma->addr;
		scb->datalen = scb->ahc_dma->len;
		SC_DEBUGN(xs->sc_link, SDEV_DB4, ("\n"));
		if (datalen) { 
			/* there's still data, must have run out of segs! */
			printf("%s: ahc_scsi_cmd: more than %d DMA segs\n",
				ahc_name(ahc), AHC_NSEG);
			xs->error = XS_DRIVER_STUFFUP;
			ahc_free_scb(ahc, scb, flags);
			return (COMPLETE);
		}
#ifdef AHC_BROKEN_CACHE
		if (ahc_broken_cache)
			INVALIDATE_CACHE();
#endif
d4264 16
a4279 8
	else {
		/*
		 * No data xfer, use non S/G values
	 	 */
		scb->SG_segment_count = 0;
		scb->SG_list_pointer = 0;
		scb->data = 0;
		scb->datalen = 0;
d4282 3
a4284 3
#ifdef AHC_DEBUG
	if((ahc_debug & AHC_SHOWSCBS) && (xs->sc_link->target == DEBUGTARG))
		ahc_print_scb(scb);
d4286 4
a4289 1
	s = splbio();
d4291 3
a4293 4
	if( scb->position != SCB_LIST_NULL )
	{
		/* We already have a valid slot */
		u_char curscb;
d4295 6
d4302 19
a4320 17
		curscb = AHC_INB(ahc, SCBPTR);
		AHC_OUTB(ahc, SCBPTR, scb->position);
		ahc_send_scb(ahc, scb);
		AHC_OUTB(ahc, SCBPTR, curscb);
		AHC_OUTB(ahc, QINFIFO, scb->position);
		unpause_sequencer(ahc, /*unpause_always*/FALSE);
		scb->flags |= SCB_ACTIVE;
		if (!(flags & SCSI_NOMASK)) {
			timeout(ahc_timeout, (caddr_t)scb,
				(xs->timeout * hz) / 1000);
		}
		SC_DEBUG(xs->sc_link, SDEV_DB3, ("cmd_sent\n"));
	}
	else {
		scb->flags |= SCB_WAITINGQ;
		STAILQ_INSERT_TAIL(&ahc->waiting_scbs, scb, links);
		ahc_run_waiting_queues(ahc);
d4322 12
a4333 1
	if (!(flags & SCSI_NOMASK)) {
d4348 2
a4349 2
	} while (!(xs->flags & ITSDONE));  /* a non command complete intr */
	splx(s); 
d4353 74
d4428 3
a4430 9
/*
 * A scb (and hence an scb entry on the board) is put onto the
 * free list.
 */
static void
ahc_free_scb(ahc, scb, flags)
        struct	ahc_data *ahc;
        int     flags;
        struct  scb *scb;
d4432 30
a4461 2
	struct scb *wscb;
	unsigned int opri;
d4463 47
a4509 1
	opri = splbio();
d4511 6
a4516 4
	/* Clean up for the next user */
	scb->flags = SCB_FREE;
	scb->control = 0;
	scb->status = 0;
d4518 11
a4528 8
	if(scb->position == SCB_LIST_NULL) {
		STAILQ_INSERT_HEAD(&ahc->page_scbs, scb, links);
		if(!scb->links.stqe_next && !ahc->free_scbs.stqh_first)
			/*
			 * If there were no SCBs available, wake anybody waiting
			 * for one to come free.
			 */
			wakeup((caddr_t)&ahc->free_scbs);
d4530 28
a4557 21
	/*
	 * If there are any SCBS on the waiting queue,
	 * assign the slot of this "freed" SCB to the first
	 * one.  We'll run the waiting queues after all command
	 * completes for a particular interrupt are completed
	 * or when we start another command.
	 */
	else if((wscb = ahc->waiting_scbs.stqh_first) != NULL) {
		STAILQ_REMOVE_HEAD(&ahc->waiting_scbs, links);
		wscb->position = scb->position;
		STAILQ_INSERT_TAIL(&ahc->assigned_scbs, wscb, links);
		wscb->flags ^= SCB_WAITINGQ|SCB_ASSIGNEDQ;

		/* 
		 * The "freed" SCB will need to be assigned a slot
		 * before being used, so put it in the page_scbs
		 * queue.
		 */
		scb->position = SCB_LIST_NULL;
		STAILQ_INSERT_HEAD(&ahc->page_scbs, scb, links);
		if(!scb->links.stqe_next && !ahc->free_scbs.stqh_first)
d4559 2
a4560 2
			 * If there were no SCBs available, wake anybody waiting
			 * for one to come free.
d4562 4
a4565 1
			wakeup((caddr_t)&ahc->free_scbs);
d4567 33
a4599 6
	else {
		STAILQ_INSERT_HEAD(&ahc->free_scbs, scb, links);
		if(!scb->links.stqe_next && !ahc->page_scbs.stqh_first)
			/*
			 * If there were no SCBs available, wake anybody waiting
			 * for one to come free.
d4601 2
a4602 1
			wakeup((caddr_t)&ahc->free_scbs);
d4604 7
a4610 4
#ifdef AHC_DEBUG
	ahc->activescbs--;
#endif
	splx(opri);
d4613 5
a4617 10
/*
 * Get a free scb, either one already assigned to a hardware slot
 * on the adapter or one that will require an SCB to be paged out before
 * use. If there are none, see if we can allocate a new SCB.  Otherwise
 * either return an error or sleep.
 */
static struct scb *
ahc_get_scb(ahc, flags)
        struct	ahc_data *ahc;
        int	flags;
d4619 47
a4665 31
	unsigned opri;
	struct scb *scbp;

	opri = splbio();
	/*
	 * If we can and have to, sleep waiting for one to come free
	 * but only if we can't allocate a new one.
	 */
	while (1) {
		if((scbp = ahc->free_scbs.stqh_first)) {
			STAILQ_REMOVE_HEAD(&ahc->free_scbs, links);
		}
		else if((scbp = ahc->page_scbs.stqh_first)) {
			STAILQ_REMOVE_HEAD(&ahc->page_scbs, links);
		}
		else if(ahc->numscbs < ahc->maxscbs) {
			scbp = (struct scb *) malloc(sizeof(struct scb),
				M_TEMP, M_NOWAIT);
			if (scbp) {
				bzero(scbp, sizeof(struct scb));
				scbp->tag = ahc->numscbs;
				if( ahc->numscbs < ahc->maxhscbs )
					scbp->position = ahc->numscbs;
				else
					scbp->position = SCB_LIST_NULL;
				ahc->numscbs++;
				/*
				 * Place in the scbarray
				 * Never is removed.
				 */
				ahc->scbarray[scbp->tag] = scbp;
d4667 27
a4693 3
			else {
				printf("%s: Can't malloc SCB\n",
				       ahc_name(ahc));
d4695 17
a4711 6
		}
		else {
			if (!(flags & SCSI_NOSLEEP)) {
				tsleep((caddr_t)&ahc->free_scbs, PRIBIO,
					"ahcscb", 0);
				continue;
d4714 4
a4719 13

#ifdef AHC_DEBUG
	if (scbp) {
		ahc->activescbs++;
		if((ahc_debug & AHC_SHOWSCBCNT)
		  && (ahc->activescbs == ahc->maxhscbs))
			printf("%s: Max SCBs active\n", ahc_name(ahc));
	}
#endif

	splx(opri);

	return (scbp);
d4722 4
a4725 2
static void ahc_loadseq(ahc)
	struct ahc_data *ahc;
a4726 8
        static u_char seqprog[] = {
#if defined(__FreeBSD__)
#               include "aic7xxx_seq.h"
#endif
#if defined(__NetBSD__) || defined(__OpenBSD__)
#		include <dev/microcode/aic7xxx/aic7xxx_seq.h>
#endif
	};
d4728 2
a4729 1
	AHC_OUTB(ahc, SEQCTL, PERRORDIS|SEQRESET|LOADRAM);
d4731 1
a4731 1
	AHC_OUTSB(ahc, SEQRAM, seqprog, sizeof(seqprog));
d4733 6
a4738 5
	do {
		AHC_OUTB(ahc, SEQCTL, SEQRESET|FASTMODE);
	} while((AHC_INB(ahc, SEQADDR0) != 0)
		|| (AHC_INB(ahc, SEQADDR1) != 0));
}
d4740 10
a4749 16
/*
 * Function to poll for command completion when
 * interrupts are disabled (crash dumps)
 */
static int
ahc_poll(ahc, wait)
	struct	ahc_data *ahc;
	int	wait; /* in msec */
{
	while (--wait) {
		DELAY(1000);
		if (AHC_INB(ahc, INTSTAT) & INT_PEND)
			break;
	} if (wait == 0) {
		printf("%s: board is not responding\n", ahc_name(ahc));
		return (EIO);
a4750 2
	ahc_intr((void *)ahc);
	return (0);
d4753 2
a4754 3
static void
ahc_timeout(arg)
	void	*arg;
d4756 2
a4757 2
	struct	scb *scb = (struct scb *)arg;
	struct	ahc_data *ahc;
d4759 4
a4762 1
	u_char	bus_state;
d4765 3
d4770 12
a4781 1
	if (!(scb->flags & SCB_ACTIVE)) {
d4783 2
d4789 3
a4791 38
	ahc = (struct ahc_data *)scb->xs->sc_link->adapter_softc;

	if (ahc->in_timeout) {
		/*
		 * Some other SCB has started a recovery operation
		 * and is still working on cleaning things up.
		 */
		if (scb->flags & SCB_TIMEDOUT) {
			/*
			 * This SCB has been here before and is not the
			 * recovery SCB. Cut our losses and panic.  Its
			 * better to do this than trash a filesystem.
			 */
			panic("%s: Timed-out command times out "
				"again\n", ahc_name(ahc));
		}
		else if (!(scb->flags & SCB_ABORTED))
		{
			/*
			 * This is not the SCB that started this timeout
			 * processing.  Give this scb another lifetime so
			 * that it can continue once we deal with the
			 * timeout.
			 */
			scb->flags |= SCB_TIMEDOUT;
			timeout(ahc_timeout, (caddr_t)scb, 
				(scb->xs->timeout * hz) / 1000);
			splx(s);
			return;
		}
	}
	ahc->in_timeout = TRUE;

	/*      
	 * Ensure that the card doesn't do anything
	 * behind our back.
	 */
	pause_sequencer(ahc);
d4794 1
a4794 1
	printf("timed out ");
d4799 1
a4799 1
	bus_state = AHC_INB(ahc, LASTPHASE);
d4801 2
a4802 28
	switch(bus_state & PHASE_MASK)
	{
		case P_DATAOUT:
			printf("in dataout phase");
			break;
		case P_DATAIN:
			printf("in datain phase");
			break;
		case P_COMMAND:
			printf("in command phase");
			break;
		case P_MESGOUT:
			printf("in message out phase");
			break;
		case P_STATUS:
			printf("in status phase");
			break;
		case P_MESGIN:
			printf("in message in phase");
			break;
		default:
			printf("while idle, LASTPHASE == 0x%x",
				bus_state);
			/* 
			 * We aren't in a valid phase, so assume we're
			 * idle.
			 */
			bus_state = 0;
d4805 34
a4838 7

	printf(", SCSISIGI == 0x%x\n", AHC_INB(ahc, SCSISIGI));

	/* Decide our course of action */

	if(scb->flags & SCB_ABORTED)
	{
d4843 4
a4846 5
		char channel = (scb->tcl & SELBUSB)
			   ? 'B': 'A';	
		found = ahc_reset_channel(ahc, channel, scb->tag,
					  XS_TIMEOUT, /*Initiate Reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset #1. "
d4848 1
a4848 16
		ahc->in_timeout = FALSE;
	}
	else if(scb->control & TAG_ENB) {
		/*
		 * We could be starving this command
		 * try sending an ordered tag command
		 * to the target we come from.
		 */
		scb->flags |= SCB_ABORTED|SCB_SENTORDEREDTAG;
		ahc->orderedtag |= 0xFF;
		timeout(ahc_timeout, (caddr_t)scb, (5 * hz));
		unpause_sequencer(ahc, /*unpause_always*/FALSE);
		printf("Ordered Tag queued\n");
		goto done;
	}
	else {
d4850 4
a4853 2
		 * Send a Bus Device Reset Message:
		 * The target that is holding up the bus may not
d4856 10
a4865 10
		 * It is also impossible to get a message to a target
		 * if we are in a "frozen" data transfer phase.  Our
		 * strategy here is to queue a bus device reset message
		 * to the timed out target if it is disconnected.
		 * Otherwise, if we have an active target we stuff the
		 * message buffer with a bus device reset message and
		 * assert ATN in the hopes that the target will let go
		 * of the bus and finally disconnect.  If this fails,
		 * we'll get another timeout 2 seconds later which will
		 * cause a bus reset.
d4867 83
a4949 13
		 * XXX If the SCB is paged out, we simply reset the
		 *     bus.  We should probably queue a new command
		 *     instead.
		 */

		/* Test to see if scb is disconnected */
		if( !(scb->flags & SCB_PAGED_OUT ) ){
			u_char active_scb;
			struct scb *active_scbp;

			active_scb = AHC_INB(ahc, SCBPTR);
			active_scbp = ahc->scbarray[AHC_INB(ahc, SCB_TAG)];
			AHC_OUTB(ahc, SCBPTR, scb->position);
d4951 28
a4978 25
			if(AHC_INB(ahc, SCB_CONTROL) & DISCONNECTED) {
				if(ahc->flags & AHC_PAGESCBS) {
					/*
					 * Pull this SCB out of the 
					 * disconnected list.
					 */
					u_char prev = AHC_INB(ahc, SCB_PREV);
					u_char next = AHC_INB(ahc, SCB_NEXT);
					if(prev == SCB_LIST_NULL) {
						/* At the head */
						AHC_OUTB(ahc, DISCONNECTED_SCBH,
						     next );
					}
					else {
						AHC_OUTB(ahc, SCBPTR, prev);
						AHC_OUTB(ahc, SCB_NEXT, next);
						if(next != SCB_LIST_NULL) {
							AHC_OUTB(ahc, SCBPTR,
							     next);
							AHC_OUTB(ahc, SCB_PREV,
							     prev);
						}
						AHC_OUTB(ahc, SCBPTR,
						     scb->position);
					}
d4980 17
a4996 11
				scb->flags |= SCB_DEVICE_RESET|SCB_ABORTED;
				scb->control &= DISCENB;
				scb->control |= MK_MESSAGE;
				scb->cmdlen = 0;
				scb->SG_segment_count = 0;
				scb->SG_list_pointer = 0;
				scb->data = 0;
				scb->datalen = 0;
				ahc_send_scb(ahc, scb);
				ahc_add_waiting_scb(ahc, scb);
				timeout(ahc_timeout, (caddr_t)scb, (2 * hz));
d4998 9
a5006 21
				printf("BUS DEVICE RESET message queued.\n");
				AHC_OUTB(ahc, SCBPTR, active_scb);
				unpause_sequencer(ahc, /*unpause_always*/FALSE);
				goto done;
			}
			/* Is the active SCB really active? */
			else if((active_scbp->flags & SCB_ACTIVE) && bus_state){
				AHC_OUTB(ahc, MSG_LEN, 1);
				AHC_OUTB(ahc, MSG0, MSG_BUS_DEV_RESET);
				AHC_OUTB(ahc, SCSISIGO, bus_state|ATNO);
				sc_print_addr(active_scbp->xs->sc_link);
				printf("asserted ATN - device reset in "
				       "message buffer\n");
				active_scbp->flags |=   SCB_DEVICE_RESET
						      | SCB_ABORTED;
				if(active_scbp != scb) {
					untimeout(ahc_timeout, 
						  (caddr_t)active_scbp);
					/* Give scb a new lease on life */
					timeout(ahc_timeout, (caddr_t)scb, 
						(scb->xs->timeout * hz) / 1000);
d5008 11
a5018 5
				timeout(ahc_timeout, (caddr_t)active_scbp, 
					(2 * hz));
				AHC_OUTB(ahc, SCBPTR, active_scb);
				unpause_sequencer(ahc, /*unpause_always*/FALSE);
				goto done;
a5020 12
		/*
		 * No active target or a paged out SCB.
		 * Try resetting the bus.
		 */
		channel = (scb->tcl & SELBUSB) ? 'B': 'A';	
		found = ahc_reset_channel(ahc, channel, scb->tag, 
					  XS_TIMEOUT,
					  /*Initiate Reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset #2. "
			"%d SCBs aborted\n", ahc_name(ahc), channel,
			found);
		ahc->in_timeout = FALSE;
a5021 1
done:
d5025 67
d5094 4
a5097 2
 * The device at the given target/channel has been reset.  Abort 
 * all active and queued scbs for that target/channel. 
d5099 3
a5101 3
static int
ahc_reset_device(ahc, target, channel, timedout_scb, xs_error)
	struct ahc_data *ahc;
d5104 4
a5107 2
	u_char timedout_scb;
	u_int32_t xs_error;
d5109 4
a5112 4
        struct scb *scbp;
	u_char active_scb;
	int i = 0;
	int found = 0;
d5115 4
a5118 1
	active_scb = AHC_INB(ahc, SCBPTR);
d5121 1
a5121 1
	 * Search the QINFIFO.
d5124 7
a5130 2
		u_char saved_queue[AHC_SCB_MAX];
		u_char queued = AHC_INB(ahc, QINCNT) & ahc->qcntmask;
d5132 16
a5147 15
		for (i = 0; i < (queued - found); i++) {
			saved_queue[i] = AHC_INB(ahc, QINFIFO);
			AHC_OUTB(ahc, SCBPTR, saved_queue[i]);
			scbp = ahc->scbarray[AHC_INB(ahc, SCB_TAG)];
			if (ahc_match_scb (scbp, target, channel)){
				/*
				 * We found an scb that needs to be aborted.
				 */
				scbp->flags = SCB_ABORTED|SCB_QUEUED_FOR_DONE;
				scbp->xs->error |= xs_error;
				if(scbp->position != timedout_scb)
					untimeout(ahc_timeout, (caddr_t)scbp);
				AHC_OUTB(ahc, SCB_CONTROL, 0);
				i--;
				found++;
d5150 24
a5173 4
		/* Now put the saved scbs back. */
		for (queued = 0; queued < i; queued++) {
			AHC_OUTB(ahc, QINFIFO, saved_queue[queued]);
		}
d5177 4
a5180 1
	 * Search waiting for selection list.
d5183 1
a5183 4
		u_char next, prev;

		next = AHC_INB(ahc, WAITING_SCBH);  /* Start at head of list. */
		prev = SCB_LIST_NULL;
d5185 10
a5194 9
		while (next != SCB_LIST_NULL) {
			AHC_OUTB(ahc, SCBPTR, next);
			scbp = ahc->scbarray[AHC_INB(ahc, SCB_TAG)];
			/*
			 * Select the SCB.
			 */
			if (ahc_match_scb(scbp, target, channel)) {
				next = ahc_abort_wscb(ahc, scbp, prev,
						timedout_scb, xs_error);
d5197 53
a5249 1
			else {
d5251 1
a5251 1
				next = AHC_INB(ahc, SCB_NEXT);
d5253 5
d5260 38
a5297 26
	/*
	 * Go through the entire SCB array now and look for 
	 * commands for this target that are active.  These
	 * are other (most likely tagged) commands that 
	 * were disconnected when the reset occured.
	 */
	for(i = 0; i < ahc->numscbs; i++) {
		scbp = ahc->scbarray[i];
		if((scbp->flags & SCB_ACTIVE)
		  && ahc_match_scb(scbp, target, channel)) {
			/* Ensure the target is "free" */
			ahc_unbusy_target(ahc, target, channel);
			if( !(scbp->flags & SCB_PAGED_OUT) )
			{
				AHC_OUTB(ahc, SCBPTR, scbp->position);
				AHC_OUTB(ahc, SCB_CONTROL, 0);
			}
			scbp->flags = SCB_ABORTED|SCB_QUEUED_FOR_DONE;
			scbp->xs->error |= xs_error;
			if(scbp->tag != timedout_scb)
				untimeout(ahc_timeout, (caddr_t)scbp);
			found++;
		}
	}			
	AHC_OUTB(ahc, SCBPTR, active_scb);
	return found;
d5304 5
a5308 7
static u_char
ahc_abort_wscb (ahc, scbp, prev, timedout_scb, xs_error)
	struct ahc_data *ahc;
        struct scb *scbp;
	u_char prev;
	u_char timedout_scb;
	u_int32_t xs_error;
d5310 2
a5311 3
	u_char curscbp, next;
	int target = ((scbp->tcl >> 4) & 0x0f);
	char channel = (scbp->tcl & SELBUSB) ? 'B' : 'A';
d5316 3
a5318 3
	curscbp = AHC_INB(ahc, SCBPTR);
	AHC_OUTB(ahc, SCBPTR, scbp->position);
	next = AHC_INB(ahc, SCB_NEXT);
d5321 3
a5323 3
	AHC_OUTB(ahc, SCB_CONTROL, 0);
	AHC_OUTB(ahc, SCB_NEXT, SCB_LIST_NULL);
	ahc_unbusy_target(ahc, target, channel);
d5326 1
a5326 1
	if( prev == SCB_LIST_NULL ) 
d5328 8
a5335 2
		AHC_OUTB(ahc, WAITING_SCBH, next); 
	else {
d5340 2
a5341 2
		AHC_OUTB(ahc, SCBPTR, prev);
		AHC_OUTB(ahc, SCB_NEXT, next);
d5343 1
d5345 3
a5347 9
	 * Point us back at the original scb position
	 * and inform the SCSI system that the command
	 * has been aborted.
	 */
	AHC_OUTB(ahc, SCBPTR, curscbp);
	scbp->flags = SCB_ABORTED|SCB_QUEUED_FOR_DONE;
	scbp->xs->error |= xs_error;
	if(scbp->tag != timedout_scb)
		untimeout(ahc_timeout, (caddr_t)scbp);
d5351 15
a5365 5
static void
ahc_busy_target(ahc, target, channel)
	struct ahc_data *ahc;
	u_char target;
	char   channel;
d5367 10
a5376 2
	u_char active;
	u_long active_port = ACTIVE_A;
d5378 2
a5379 11
	if(target > 0x07 || channel == 'B') {
		/* 
		 * targets on the Second channel or
		 * above id 7 store info in byte two 
		 * of HA_ACTIVE
		 */
		active_port++;
	}
	active = AHC_INB(ahc, active_port);
	active |= (0x01 << (target & 0x07));
	AHC_OUTB(ahc, active_port, active);
d5382 5
a5386 5
static void
ahc_unbusy_target(ahc, target, channel)
	struct ahc_data *ahc;
	u_char target;
	char   channel;
d5388 49
a5436 2
	u_char active;
	u_long active_port = ACTIVE_A;
d5438 4
a5441 5
	if(target > 0x07 || channel == 'B') {
		/* 
		 * targets on the Second channel or
		 * above id 7 store info in byte two 
		 * of HA_ACTIVE
d5443 6
a5448 1
		active_port++;
a5449 26
	active = AHC_INB(ahc, active_port);
	active &= ~(0x01 << (target & 0x07));
	AHC_OUTB(ahc, active_port, active);
}

static void
ahc_reset_current_bus(ahc)
	struct ahc_data *ahc;
{
	AHC_OUTB(ahc, SCSISEQ, SCSIRSTO);
	DELAY(1000);
	AHC_OUTB(ahc, SCSISEQ, 0);
}

static int
ahc_reset_channel(ahc, channel, timedout_scb, xs_error, initiate_reset)
	struct ahc_data *ahc;
	char   channel;
	u_char timedout_scb;
	u_int32_t xs_error;
	u_char initiate_reset;
{
	u_char sblkctl;
	char cur_channel;
	u_long offset, offset_max;
	int found;
d5455 35
a5489 36
	found = ahc_reset_device(ahc, ALL_TARGETS, channel, 
				 timedout_scb, xs_error);
	if(channel == 'B'){
		ahc->needsdtr |= (ahc->needsdtr_orig & 0xff00);
		ahc->sdtrpending &= 0x00ff;
		AHC_OUTB(ahc, ACTIVE_B, 0);
		offset = TARG_SCRATCH + 8;
		offset_max = TARG_SCRATCH + 16;
	}
	else if (ahc->type & AHC_WIDE){
		ahc->needsdtr = ahc->needsdtr_orig;
		ahc->needwdtr = ahc->needwdtr_orig;
		ahc->sdtrpending = 0;
		ahc->wdtrpending = 0;
		AHC_OUTB(ahc, ACTIVE_A, 0);
		AHC_OUTB(ahc, ACTIVE_B, 0);
		offset = TARG_SCRATCH;
		offset_max = TARG_SCRATCH + 16;
	}
	else{
		ahc->needsdtr |= (ahc->needsdtr_orig & 0x00ff);
		ahc->sdtrpending &= 0xff00;
		AHC_OUTB(ahc, ACTIVE_A, 0);
		offset = TARG_SCRATCH;
		offset_max = TARG_SCRATCH + 8;
	}
	for(;offset < offset_max;offset++) {
		/*
		 * Revert to async/narrow transfers
		 * until we renegotiate.
		 */
		u_char targ_scratch;

		targ_scratch = AHC_INB(ahc, offset);
		targ_scratch &= SXFR;
		AHC_OUTB(ahc, offset, targ_scratch);
d5492 63
d5556 17
a5572 8
	 * Reset the bus if we are initiating this reset and
	 * restart/unpause the sequencer
	 */
	/* Case 1: Command for another bus is active */
	sblkctl = AHC_INB(ahc, SBLKCTL);
	cur_channel = (sblkctl & SELBUSB) ? 'B' : 'A';
	if(cur_channel != channel)
	{
d5574 3
a5576 2
		 * Stealthily reset the other bus
		 * without upsetting the current bus
d5578 7
a5584 4
		AHC_OUTB(ahc, SBLKCTL, sblkctl ^ SELBUSB);
		if( initiate_reset )
		{
			ahc_reset_current_bus(ahc);
d5586 13
a5598 14
		AHC_OUTB(ahc, CLRSINT1, CLRSCSIRSTI|CLRSELTIMEO);
		AHC_OUTB(ahc, CLRINT, CLRSCSIINT);
		AHC_OUTB(ahc, SBLKCTL, sblkctl);
		unpause_sequencer(ahc, /*unpause_always*/TRUE);
	}
	/* Case 2: A command from this bus is active or we're idle */ 
	else {
		if( initiate_reset )
		{
			ahc_reset_current_bus(ahc);
		}
		AHC_OUTB(ahc, CLRSINT1, CLRSCSIRSTI|CLRSELTIMEO);
		AHC_OUTB(ahc, CLRINT, CLRSCSIINT);
		restart_sequencer(ahc);
d5600 1
a5600 2
	ahc_run_done_queue(ahc);
	return found;
d5603 3
a5605 3
void
ahc_run_done_queue(ahc)
	struct ahc_data *ahc;
d5607 83
a5689 7
	int i;
	struct scb *scbp;
	
	for(i = 0; i < ahc->numscbs; i++) {
		scbp = ahc->scbarray[i];
		if(scbp->flags & SCB_QUEUED_FOR_DONE) 
			ahc_done(ahc, scbp);
d5691 1
d5693 3
a5695 6
	
static int
ahc_match_scb (scb, target, channel)
        struct scb *scb;
        int target;
	char channel;
d5697 17
a5713 2
	int targ = (scb->tcl >> 4) & 0x0f;
	char chan = (scb->tcl & SELBUSB) ? 'B' : 'A';
d5715 20
a5734 5
	if (target == ALL_TARGETS) 
		return (chan == channel);
	else
		return ((chan == channel) && (targ == target));
}
d5736 3
d5740 2
a5741 26
static void
ahc_construct_sdtr(ahc, start_byte, period, offset)
	struct ahc_data *ahc;
	int start_byte;
	u_int8_t period;
	u_int8_t offset;
{
	AHC_OUTB(ahc, MSG0 + start_byte, MSG_EXTENDED);
	AHC_OUTB(ahc, MSG1 + start_byte, MSG_EXT_SDTR_LEN);
	AHC_OUTB(ahc, MSG2 + start_byte, MSG_EXT_SDTR);
	AHC_OUTB(ahc, MSG3 + start_byte, period);
	AHC_OUTB(ahc, MSG4 + start_byte, offset);
	AHC_OUTB(ahc, MSG_LEN, start_byte + 5);
}

static void
ahc_construct_wdtr(ahc, start_byte, bus_width)
	struct ahc_data *ahc;
	int start_byte;
	u_int8_t bus_width;
{
	AHC_OUTB(ahc, MSG0 + start_byte, MSG_EXTENDED);
	AHC_OUTB(ahc, MSG1 + start_byte, MSG_EXT_WDTR_LEN);
	AHC_OUTB(ahc, MSG2 + start_byte, MSG_EXT_WDTR);
	AHC_OUTB(ahc, MSG3 + start_byte, bus_width);
	AHC_OUTB(ahc, MSG_LEN, start_byte + 4);
@


1.18.6.1
log
@Sync with -current
@
text
@d1 3
d7 2
a8 3
 * i386/eisa/ahc_eisa.c	27/284X and aic7770 motherboard controllers
 * pci/ahc_pci.c	3985, 3980, 3940, 2940, aic7895, aic7890,
 *			aic7880, aic7870, aic7860, and aic7850 controllers
d10 1
a10 1
 * Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999, 2000 Justin T. Gibbs.
d17 6
a22 3
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. The name of the author may not be used to endorse or promote products
a24 3
 * Alternatively, this software may be distributed under the terms of the
 * the GNU Public License ("GPL").
 *
d37 1
a37 2
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.40 2000/01/07 23:08:17 gibbs Exp $
 * $OpenBSD$
d40 4
a43 1
 * A few notes on features of the driver.
d47 26
a72 7
 * having the SCBs for these transactions down on the host adapter is of
 * little use.  Instead of leaving this idle SCB down on the card we copy
 * it back up into kernel memory and reuse the SCB slot on the card to
 * schedule another transaction.  This can be a real payoff when doing random
 * I/O to tagged queueing devices since there are more transactions active at
 * once for the device to sort for optimal seek reduction. The algorithm goes
 * like this...
d74 2
a75 19
 * The sequencer maintains two lists of its hardware SCBs.  The first is the
 * singly linked free list which tracks all SCBs that are not currently in
 * use.  The second is the doubly linked disconnected list which holds the
 * SCBs of transactions that are in the disconnected state sorted most
 * recently disconnected first.  When the kernel queues a transaction to
 * the card, a hardware SCB to "house" this transaction is retrieved from
 * either of these two lists.  If the SCB came from the disconnected list,
 * a check is made to see if any data transfer or SCB linking (more on linking
 * in a bit) information has been changed since it was copied from the host
 * and if so, DMAs the SCB back up before it can be used.  Once a hardware
 * SCB has been obtained, the SCB is DMAed from the host.  Before any work
 * can begin on this SCB, the sequencer must ensure that either the SCB is
 * for a tagged transaction or the target is not already working on another
 * non-tagged transaction.  If a conflict arises in the non-tagged case, the
 * sequencer finds the SCB for the active transactions and sets the SCB_LINKED
 * field in that SCB to this next SCB to execute.  To facilitate finding
 * active non-tagged SCBs, the last four bytes of up to the first four hardware
 * SCBs serve as a storage area for the currently active SCB ID for each
 * target.
d77 12
a88 6
 * When a device reconnects, a search is made of the hardware SCBs to find
 * the SCB for this transaction.  If the search fails, a hardware SCB is
 * pulled from either the free or disconnected SCB list and the proper
 * SCB is DMAed from the host.  If the MK_MESSAGE control bit is set
 * in the control byte of the SCB while it was disconnected, the sequencer
 * will assert ATN and attempt to issue a message to the host.
d90 2
a91 7
 * When a command completes, a check for non-zero status and residuals is
 * made.  If either of these conditions exists, the SCB is DMAed back up to
 * the host so that it can interpret this information.  Additionally, in the
 * case of bad status, the sequencer generates a special interrupt and pauses
 * itself.  This allows the host to setup a request sense command if it 
 * chooses for this target synchronously with the error so that sense
 * information isn't lost.
d93 24
d121 1
d125 1
a125 4

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
d133 1
d135 1
d138 4
d146 7
a154 3
#include <dev/microcode/aic7xxx/aic7xxx_seq.h>
#include <dev/microcode/aic7xxx/sequencer.h>
#include "pci.h"
d156 14
a169 7
/*
 * Some ISA devices (e.g. on a VLB) can perform 32-bit DMA.  This
 * flag is passed to bus_dmamap_create() to indicate that fact.
 */
#ifndef ISABUS_DMA_32BIT
#define ISABUS_DMA_32BIT	BUS_DMA_BUS1
#endif 
a170 3
#ifndef AHC_TMODE_ENABLE
#define AHC_TMODE_ENABLE 0
#endif
d172 1
a172 7
#define offsetof(s, e) ((char *)&((s *)0)->e - (char *)((s *)0))

#define	IS_SCSIBUS_B(ahc, sc_link)	\
	((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
#define ALL_CHANNELS '\0'
#define ALL_TARGETS_MASK 0xFFFF
#define INITIATOR_WILDCARD	(~0)
d174 2
a175 29
#define	SIM_IS_SCSIBUS_B(ahc, sc_link)	\
	((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
#define	SIM_CHANNEL(ahc, sc_link)	\
	(SIM_IS_SCSIBUS_B(ahc, sc_link) ? 'B' : 'A')
#define	SIM_SCSI_ID(ahc, sc_link)	\
	(SIM_IS_SCSIBUS_B(ahc, sc_link) ? ahc->our_id_b : ahc->our_id)
#define	SCB_IS_SCSIBUS_B(scb)	\
	(((scb)->hscb->tcl & SELBUSB) != 0)
#define	SCB_TARGET(scb)	\
	(((scb)->hscb->tcl & TID) >> 4)
#define	SCB_CHANNEL(scb) \
	(SCB_IS_SCSIBUS_B(scb) ? 'B' : 'A')
#define	SCB_LUN(scb)	\
	((scb)->hscb->tcl & LID)
#define SCB_TARGET_OFFSET(scb)		\
	(SCB_TARGET(scb) + (SCB_IS_SCSIBUS_B(scb) ? 8 : 0))
#define SCB_TARGET_MASK(scb)		\
	(0x01 << (SCB_TARGET_OFFSET(scb)))
#define TCL_CHANNEL(ahc, tcl)		\
	((((ahc)->features & AHC_TWIN) && ((tcl) & SELBUSB)) ? 'B' : 'A')
#define TCL_SCSI_ID(ahc, tcl)		\
	(TCL_CHANNEL((ahc), (tcl)) == 'B' ? (ahc)->our_id_b : (ahc)->our_id)
#define TCL_TARGET(tcl) (((tcl) & TID) >> TCL_TARGET_SHIFT)
#define TCL_LUN(tcl) ((tcl) & LID)

#define XS_TCL(ahc, xs) \
	((((xs)->sc_link->target << 4) & 0xF0) \
	| (SIM_IS_SCSIBUS_B((ahc), (xs)->sc_link) ? SELBUSB : 0) \
	| ((xs)->sc_link->lun & 0x07))
d177 3
a179 38
/*
 * Under normal circumstances, these messages are unnecessary
 * and not terribly cosmetic.
 */
#ifdef DEBUG
#define bootverbose	1
#define STATIC
#define INLINE
#else
#define bootverbose	0
#define STATIC	static
#define INLINE __inline
#endif

typedef enum {
	ROLE_UNKNOWN,
	ROLE_INITIATOR,
	ROLE_TARGET
} role_t;

struct ahc_devinfo {
	int	  our_scsiid;
	int	  target_offset;
	u_int16_t target_mask;
	u_int8_t  target;
	u_int8_t  lun;
	char	  channel;
	role_t	  role;		/*
				 * Only guaranteed to be correct if not
				 * in the busfree state.
				 */
};

typedef enum {
	SEARCH_COMPLETE,
	SEARCH_COUNT,
	SEARCH_REMOVE
} ahc_search_action;
d185 2
a186 3
#if NPCI > 0
void ahc_pci_intr(struct ahc_softc *ahc);
#endif
d188 6
a193 69
STATIC int	ahcinitscbdata(struct ahc_softc *ahc);
STATIC void	ahcfiniscbdata(struct ahc_softc *ahc);

STATIC int	ahc_poll __P((struct ahc_softc *ahc, int wait));
STATIC void	ahc_shutdown __P((void *arg));
STATIC int	ahc_execute_scb __P((void *arg, bus_dma_segment_t *dm_segs,
				     int nsegments));
STATIC int	ahc_setup_data __P((struct ahc_softc *ahc,
				    struct scsi_xfer *xs, struct scb *scb));
STATIC void	ahc_freeze_devq __P((struct ahc_softc *ahc,
				     struct scsi_link *sc_link));
STATIC void	ahcallocscbs __P((struct ahc_softc *ahc));
STATIC void	ahc_fetch_devinfo __P((struct ahc_softc *ahc,
				       struct ahc_devinfo *devinfo));
STATIC void	ahc_compile_devinfo __P((struct ahc_devinfo *devinfo,
					 u_int our_id, u_int target,
					 u_int lun, char channel,
					 role_t role));
STATIC u_int	ahc_abort_wscb __P((struct ahc_softc *ahc,
				    u_int scbpos, u_int prev));
STATIC void	ahc_done __P((struct ahc_softc *ahc, struct scb *scbp));
STATIC struct tmode_tstate *
		ahc_alloc_tstate __P((struct ahc_softc *ahc, u_int scsi_id,
				      char channel));
STATIC void	ahc_handle_seqint __P((struct ahc_softc *ahc, u_int intstat));
STATIC void	ahc_handle_scsiint __P((struct ahc_softc *ahc, u_int intstat));
STATIC void	ahc_build_transfer_msg __P((struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo));
STATIC void	ahc_setup_initiator_msgout __P((struct ahc_softc *ahc,
						struct ahc_devinfo *devinfo,
						struct scb *scb));
STATIC void	ahc_setup_target_msgin __P((struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo));
STATIC int	ahc_handle_msg_reject __P((struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo));
STATIC void	ahc_clear_msg_state __P((struct ahc_softc *ahc));
STATIC void	ahc_handle_message_phase __P((struct ahc_softc *ahc,
					      struct scsi_link *sc_link));
STATIC int	ahc_sent_msg __P((struct ahc_softc *ahc, u_int msgtype,
				  int full));

typedef enum {
	MSGLOOP_IN_PROG,
	MSGLOOP_MSGCOMPLETE,
	MSGLOOP_TERMINATED
} msg_loop_stat;

STATIC int	ahc_parse_msg __P((struct ahc_softc *ahc,
				   struct scsi_link *sc_link,
				   struct ahc_devinfo *devinfo));
STATIC void	ahc_handle_ign_wide_residue __P((struct ahc_softc *ahc,
						 struct ahc_devinfo *devinfo));
STATIC void	ahc_handle_devreset __P((struct ahc_softc *ahc,
					 struct ahc_devinfo *devinfo,
					 int status, char *message,
					 int verbose_level));
#ifdef AHC_DUMP_SEQ
STATIC void	ahc_dumpseq __P((struct ahc_softc *ahc));
#endif
STATIC void	ahc_loadseq __P((struct ahc_softc *ahc));
STATIC int	ahc_check_patch __P((struct ahc_softc *ahc,
				     struct patch **start_patch,
				     int start_instr, int *skip_addr));
STATIC void	ahc_download_instr __P((struct ahc_softc *ahc,
					int instrptr, u_int8_t *dconsts));
STATIC int	ahc_match_scb __P((struct scb *scb, int target, char channel,
				   int lun, u_int tag, role_t role));
#ifdef AHC_DEBUG
STATIC void	ahc_print_scb __P((struct scb *scb));
a194 96
STATIC int	ahc_search_qinfifo __P((struct ahc_softc *ahc, int target,
					char channel, int lun, u_int tag,
					role_t role, u_int32_t status,
					ahc_search_action action));
STATIC int	ahc_reset_channel __P((struct ahc_softc *ahc, char channel,
				       int initiate_reset));
STATIC int	ahc_abort_scbs __P((struct ahc_softc *ahc, int target,
				    char channel, int lun, u_int tag,
				    role_t role, u_int32_t status));
STATIC int	ahc_search_disc_list __P((struct ahc_softc *ahc, int target,
					  char channel, int lun, u_int tag,
					  int stop_on_first, int remove,
					  int save_state));
STATIC u_int	ahc_rem_scb_from_disc_list __P((struct ahc_softc *ahc,
						u_int prev, u_int scbptr));
STATIC void	ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));
STATIC void	ahc_clear_intstat __P((struct ahc_softc *ahc));
STATIC void	ahc_reset_current_bus __P((struct ahc_softc *ahc));
STATIC struct ahc_syncrate *
		ahc_devlimited_syncrate __P((struct ahc_softc *ahc, u_int *period));
STATIC struct ahc_syncrate *
		ahc_find_syncrate __P((struct ahc_softc *ahc, u_int *period,
				       u_int maxsync));
STATIC u_int ahc_find_period __P((struct ahc_softc *ahc, u_int scsirate,
				  u_int maxsync));
STATIC void	ahc_validate_offset __P((struct ahc_softc *ahc,
					 struct ahc_syncrate *syncrate,
					 u_int *offset, int wide)); 
STATIC void	ahc_update_target_msg_request __P((struct ahc_softc *ahc,
					      struct ahc_devinfo *devinfo,
					      struct ahc_initiator_tinfo *tinfo,
					      int force, int paused));
STATIC void	ahc_set_syncrate __P((struct ahc_softc *ahc,
				      struct ahc_devinfo *devinfo,
				      struct ahc_syncrate *syncrate,
				      u_int period, u_int offset,
				      u_int type, int paused, int done));
STATIC void	ahc_set_width __P((struct ahc_softc *ahc,
			      struct ahc_devinfo *devinfo,
			      u_int width, u_int type, int paused, int done));
STATIC void	ahc_set_tags __P((struct ahc_softc *ahc,
				  struct ahc_devinfo *devinfo,int enable));
STATIC void	ahc_construct_sdtr __P((struct ahc_softc *ahc,
				   u_int period, u_int offset));
STATIC void	ahc_construct_wdtr __P((struct ahc_softc *ahc, u_int bus_width));

STATIC void	ahc_calc_residual __P((struct scb *scb));

STATIC void	ahc_update_pending_syncrates __P((struct ahc_softc *ahc));

STATIC void	ahc_set_recoveryscb __P((struct ahc_softc *ahc,
					 struct scb *scb));
STATIC void ahc_timeout __P((void *));

static __inline int  sequencer_paused __P((struct ahc_softc *ahc));
static __inline void pause_sequencer __P((struct ahc_softc *ahc));
static __inline void unpause_sequencer __P((struct ahc_softc *ahc));
STATIC void restart_sequencer __P((struct ahc_softc *ahc));
static __inline u_int ahc_index_busy_tcl __P((struct ahc_softc *ahc,
					      u_int tcl, int unbusy));
 
static __inline void	ahc_busy_tcl __P((struct ahc_softc *ahc,
					  struct scb *scb));
static __inline int	ahc_isbusy_tcl __P((struct ahc_softc *ahc,
					    struct scb *scb));
static __inline void ahc_freeze_ccb __P((struct scb* scb));
static __inline void ahcsetccbstatus __P((struct scsi_xfer *xs, int status));
STATIC void ahc_run_qoutfifo __P((struct ahc_softc *ahc));

static __inline struct ahc_initiator_tinfo *
	ahc_fetch_transinfo __P((struct ahc_softc *ahc, char channel,
				 u_int our_id, u_int target,
				 struct tmode_tstate **tstate));
STATIC void ahcfreescb __P((struct ahc_softc *ahc, struct scb *scb));
static __inline struct scb *ahcgetscb __P((struct ahc_softc *ahc));
int    ahc_createdmamem __P((struct ahc_softc *ahc, int size,
			     bus_dmamap_t *mapp, caddr_t *vaddr,
			     bus_addr_t *baddr, bus_dma_segment_t *segs,
			     int *nseg, const char *what));
STATIC void ahc_freedmamem __P((bus_dma_tag_t tag, int size,
				bus_dmamap_t map, caddr_t vaddr,
				bus_dma_segment_t *seg, int nseg));
STATIC void ahcminphys __P((struct buf *bp));

STATIC INLINE	struct scsi_xfer *ahc_first_xs __P((struct ahc_softc *));
STATIC INLINE	void   ahc_list_insert_before __P((struct ahc_softc *ahc,
						   struct scsi_xfer *xs,
						   struct scsi_xfer *next_xs));
STATIC INLINE	void   ahc_list_insert_head __P((struct ahc_softc *ahc,
						 struct scsi_xfer *xs));
STATIC INLINE	void   ahc_list_insert_tail __P((struct ahc_softc *ahc,
						 struct scsi_xfer *xs));
STATIC INLINE	void   ahc_list_remove __P((struct ahc_softc *ahc,
					    struct scsi_xfer *xs));
STATIC INLINE	struct scsi_xfer *ahc_list_next __P((struct ahc_softc *ahc,
						     struct scsi_xfer *xs));
d196 3
a198 1
STATIC int32_t ahc_scsi_cmd __P((struct scsi_xfer *xs));
d200 6
a205 3
struct cfdriver ahc_cd = {
	NULL, "ahc", DV_DULL
};
d209 9
a217 4
	ahc_scsi_cmd,
	ahcminphys,
	0,
	0,
d223 9
a231 4
	NULL, /* Use default error handler */
	NULL, /* have a queue, served by this */
	NULL, /* have no async handler */
	NULL, /* Use default 'done' routine */
d234 1
a234 35
STATIC void
ahcminphys(bp)
	struct buf *bp;
{
/*
 * Even though the card can transfer up to 16megs per command
 * we are limited by the number of segments in the dma segment
 * list that we can hold.  The worst case is that all pages are
 * discontinuous physically, hense the "page per segment" limit
 * enforced here.
 */
	if (bp->b_bcount > ((AHC_NSEG - 1) * PAGE_SIZE)) {
		bp->b_bcount = ((AHC_NSEG - 1) * PAGE_SIZE);
	}
	minphys(bp);
}


static __inline u_int32_t
ahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)
{
	return (ahc->scb_data->hscb_busaddr
		+ (sizeof(struct hardware_scb) * index));
}

#define AHC_BUSRESET_DELAY	25	/* Reset delay in us */

static __inline int
sequencer_paused(ahc)
	struct ahc_softc *ahc;
{
	return ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);
}

static __inline void
d236 1
a236 1
	struct ahc_softc *ahc;
d238 1
a238 1
	ahc_outb(ahc, HCNTRL, ahc->pause);
d244 1
a244 1
	while (sequencer_paused(ahc) == 0)
d248 8
a255 6
static __inline void
unpause_sequencer(ahc)
	struct ahc_softc *ahc;
{
	if ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)
		ahc_outb(ahc, HCNTRL, ahc->unpause);
d261 1
a261 1
STATIC void
d263 1
a263 1
	struct ahc_softc *ahc;
d265 4
a268 128
	u_int i;

	pause_sequencer(ahc);

	/*
	 * Everytime we restart the sequencer, there
	 * is the possiblitity that we have restarted
	 * within a three instruction window where an
	 * SCB has been marked free but has not made it
	 * onto the free list.  Since SCSI events(bus reset,
	 * unexpected bus free) will always freeze the
	 * sequencer, we cannot close this window.  To
	 * avoid losing an SCB, we reconsitute the free
	 * list every time we restart the sequencer.
	 */
	ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		
		ahc_outb(ahc, SCBPTR, i);
		if (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)
			ahc_add_curscb_to_free_list(ahc);
	}
	ahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);
	unpause_sequencer(ahc);
}

static __inline u_int
ahc_index_busy_tcl(ahc, tcl, unbusy)
	struct ahc_softc *ahc;
	u_int tcl;
	int unbusy;
{
	u_int scbid;

	scbid = ahc->untagged_scbs[tcl];
	if (unbusy) {
		ahc->untagged_scbs[tcl] = SCB_LIST_NULL;
		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
				BUS_DMASYNC_PREWRITE);
	}

	return (scbid);
}

static __inline void
ahc_busy_tcl(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
	ahc->untagged_scbs[scb->hscb->tcl] = scb->hscb->tag;
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
			BUS_DMASYNC_PREWRITE);
}

static __inline int
ahc_isbusy_tcl(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
	return ahc->untagged_scbs[scb->hscb->tcl] != SCB_LIST_NULL;
}

static __inline void
ahc_freeze_ccb(scb)
	struct scb *scb;
{
	struct scsi_xfer *xs = scb->xs;
	struct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
	int target;

	target = xs->sc_link->target;
	if (!(scb->flags & SCB_FREEZE_QUEUE)) {
		ahc->devqueue_blocked[target]++;
		scb->flags |= SCB_FREEZE_QUEUE;
	}
}

static __inline void
ahcsetccbstatus(xs, status)
	struct scsi_xfer *xs;
	int status;
{
	xs->error = status;
}

static __inline struct ahc_initiator_tinfo *
ahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)
	struct ahc_softc *ahc;
	char channel;
	u_int our_id;
	u_int remote_id;
	struct tmode_tstate **tstate;
{
	/*
	 * Transfer data structures are stored from the perspective
	 * of the target role.  Since the parameters for a connection
	 * in the initiator role to a given target are the same as
	 * when the roles are reversed, we pretend we are the target.
	 */
	if (channel == 'B')
		our_id += 8;
	*tstate = ahc->enabled_targets[our_id];
	return (&(*tstate)->transinfo[remote_id]);
}

STATIC void
ahc_run_qoutfifo(ahc)
	struct ahc_softc *ahc;
{
	struct scb *scb;
	u_int  scb_index;

	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
			BUS_DMASYNC_POSTREAD);

	while (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {
		scb_index = ahc->qoutfifo[ahc->qoutfifonext];
		ahc->qoutfifo[ahc->qoutfifonext++] = SCB_LIST_NULL;

		scb = &ahc->scb_data->scbarray[scb_index];
		if (scb_index >= ahc->scb_data->numscbs
		  || (scb->flags & SCB_ACTIVE) == 0) {
			printf("%s: WARNING no command for scb %d "
			       "(cmdcmplt)\nQOUTPOS = %d\n",
			       ahc_name(ahc), scb_index,
			       ahc->qoutfifonext - 1);
			continue;
		}
d270 1
a270 10
		/*
		 * Save off the residual
		 * if there is one.
		 */
		if (scb->hscb->residual_SG_count != 0)
			ahc_calc_residual(scb);
		else
			scb->xs->resid = 0;
		ahc_done(ahc, scb);
	}
d273 1
a273 1

d275 1
a275 2
 * An scb (and hence an scb entry on the board) is put onto the
 * free list.
d277 2
a278 25
STATIC void
ahcfreescb(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{       
	struct hardware_scb *hscb;
	int opri;

	hscb = scb->hscb;
	opri = splbio();

	if ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||
	    (scb->flags & SCB_RECOVERY_SCB) != 0) {
		ahc->flags &= ~AHC_RESOURCE_SHORTAGE;
		ahc->queue_blocked = 0;
	}

	/* Clean up for the next user */
	scb->flags = SCB_FREE;
	hscb->control = 0;
	hscb->status = 0;

	SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links);
	splx(opri);
}
d281 1
a281 4
 * Get a free scb, either one already assigned to a hardware slot
 * on the adapter or one that will require an SCB to be paged out before
 * use. If there are none, see if we can allocate a new SCB.  Otherwise
 * either return an error or sleep.
d283 3
a285 6
static __inline struct scb *
ahcgetscb(ahc)
	struct ahc_softc *ahc;
{
	struct scb *scbp;
	int opri;
d287 58
a344 25
	opri = splbio();
	if ((scbp = SLIST_FIRST(&ahc->scb_data->free_scbs))) {
		SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links);
	} else {
		ahcallocscbs(ahc);
		scbp = SLIST_FIRST(&ahc->scb_data->free_scbs);
		if (scbp != NULL)
			SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links);
	}

	splx(opri);

	return (scbp);
}

int
ahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)
	struct ahc_softc *ahc;
	int size;
	bus_dmamap_t *mapp;
	caddr_t *vaddr;
	bus_addr_t *baddr;
	bus_dma_segment_t *seg;
	int *nseg;
	const char *what;
d346 1
a346 59
	int error, rseg, level = 0;
	int dma_flags = BUS_DMA_NOWAIT;
	bus_dma_tag_t tag = ahc->sc_dmat;
	const char *myname = ahc_name(ahc);
	if ((ahc->chip & AHC_VL) !=0)
		dma_flags |= ISABUS_DMA_32BIT;
	
	if ((error = bus_dmamem_alloc(tag, size, NBPG, 0,
			seg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to allocate DMA mem for %s, error = %d\n",
			myname, what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,
			BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: failed to map DMA mem for %s, error = %d\n",
			myname, what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamap_create(tag, size, 1, size, 0,
			dma_flags, mapp)) != 0) {
		printf("%s: failed to create DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }
	level++;

	if ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,
			BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to load DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }

	*baddr = seg[0].ds_addr;

	if (bootverbose)
		printf("%s: dmamem for %s at phys %lx virt %lx nseg %d size %d\n",
		       myname, what, (unsigned long)*baddr,
		       (unsigned long)*vaddr, *nseg, size);
	return 0;
out:
	switch (level) {
	case 3:
		bus_dmamap_destroy(tag, *mapp);
		/* FALLTHROUGH */
	case 2:
		bus_dmamem_unmap(tag, *vaddr, size);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(tag, seg, rseg);
		break;
	default:
		break;
	}
d348 2
a349 1
	return error;
d352 5
a356 15
STATIC void
ahc_freedmamem(tag, size, map, vaddr, seg, nseg)
	bus_dma_tag_t tag;
	int size;
	bus_dmamap_t map;
	caddr_t vaddr;
	bus_dma_segment_t *seg;
	int nseg;
{

	bus_dmamap_unload(tag, map);
	bus_dmamap_destroy(tag, map);
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
}
d359 1
a359 1
STATIC void
d361 1
a361 1
	struct scb *scb;
d363 15
a377 1
	struct hardware_scb *hscb = scb->hscb;
a378 20
	printf("scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n",
		scb,
		hscb->control,
		hscb->tcl,
		hscb->cmdlen,
		hscb->cmdpointer );
	printf("        datlen:%d data:0x%lx segs:0x%x segp:0x%lx\n",
		hscb->datalen,
		hscb->data,
		hscb->SG_count,
		hscb->SG_pointer);
	printf("	sg_addr:%lx sg_len:%ld\n",
		scb->sg_list[0].addr,
		scb->sg_list[0].len);
	printf("	cdb:%x %x %x %x %x %x %x %x %x %x %x %x\n",
		hscb->cmdstore[0], hscb->cmdstore[1], hscb->cmdstore[2],
		hscb->cmdstore[3], hscb->cmdstore[4], hscb->cmdstore[5],
		hscb->cmdstore[6], hscb->cmdstore[7], hscb->cmdstore[8],
		hscb->cmdstore[9], hscb->cmdstore[10], hscb->cmdstore[11]);
}
d382 1
a382 1
        u_int8_t errno;
d385 4
a388 8
	{ ILLHADDR,	"Illegal Host Access" },
	{ ILLSADDR,	"Illegal Sequencer Address referrenced" },
	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
	{ SQPARERR,	"Sequencer Parity Error" },
	{ DPARERR,	"Data-path Parity Error" },
	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
	{ PCIERRSTAT,	"PCI Error detected" },
	{ CIOPARERR,	"CIOBUS Parity Error" },
a389 1
static const int num_errors = sizeof(hard_error)/sizeof(hard_error[0]);
a390 15
static struct {
        u_int8_t phase;
        u_int8_t mesg_out; /* Message response to parity errors */
	char *phasemsg;
} phase_table[] = {
	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
	{ 0,		MSG_NOOP,		"in unknown phase"	}
};
static const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;
d397 18
a414 21
#define AHC_SYNCRATE_DT		0
#define AHC_SYNCRATE_ULTRA2	1
#define AHC_SYNCRATE_ULTRA	2
#define AHC_SYNCRATE_FAST	5
static struct ahc_syncrate ahc_syncrates[] = {
      /* ultra2    fast/ultra  period     rate */
	{ 0x42,      0x000,      9,      "80.0" },
	{ 0x03,      0x000,     10,      "40.0" },
	{ 0x04,      0x000,     11,      "33.0" },
	{ 0x05,      0x100,     12,      "20.0" },
	{ 0x06,      0x110,     15,      "16.0" },
	{ 0x07,      0x120,     18,      "13.4" },
	{ 0x08,      0x000,     25,      "10.0" },
	{ 0x19,      0x010,     31,      "8.0"  },
	{ 0x1a,      0x020,     37,      "6.67" },
	{ 0x1b,      0x030,     43,      "5.7"  },
	{ 0x1c,      0x040,     50,      "5.0"  },
	{ 0x00,      0x050,     56,      "4.4"  },
	{ 0x00,      0x060,     62,      "4.0"  },
	{ 0x00,      0x070,     68,      "3.6"  },
	{ 0x00,      0x000,      0,      NULL   }
d417 3
d425 6
d432 2
a433 2
ahc_construct(ahc, iot, ioh, chip, flags, features, channel)
	struct  ahc_softc *ahc;
d436 2
a437 1
	ahc_chip chip;
a438 2
	ahc_feature features;
	u_char channel;
d440 1
d444 25
a468 1
	LIST_INIT(&ahc->pending_scbs);
d471 2
a472 1
	ahc->chip = chip;
d474 1
a474 9
	ahc->features = features;
	ahc->channel = channel;
	ahc->scb_data = NULL;
	ahc->pci_intr_func = NULL;

	ahc->unpause = (ahc_inb(ahc, HCNTRL) & IRQMS) | INTEN;
	/* The IRQMS bit is only valid on VL and EISA chips */
	if ((ahc->chip & AHC_PCI) != 0)
		ahc->unpause &= ~IRQMS;
d476 4
d484 1
a484 1
	struct ahc_softc *ahc;
d486 2
a487 10
	ahcfiniscbdata(ahc);
	if (ahc->init_level != 0)
		ahc_freedmamem(ahc->sc_dmat, ahc->shared_data_size,
		    ahc->shared_data_dmamap, ahc->qoutfifo,
		    &ahc->shared_data_seg, ahc->shared_data_nseg);

	if (ahc->scb_data != NULL)
		free(ahc->scb_data, M_DEVBUF);
	if (ahc->pci_data != NULL)
		free(ahc->pci_data, M_DEVBUF);
d489 1
a489 141
}

STATIC int
ahcinitscbdata(ahc)
	struct ahc_softc *ahc;
{
	struct scb_data *scb_data;
	int i;
	
	scb_data = ahc->scb_data;
	SLIST_INIT(&scb_data->free_scbs);
	SLIST_INIT(&scb_data->sg_maps);

	/* Allocate SCB resources */
	scb_data->scbarray =
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,
				 M_DEVBUF, M_NOWAIT);
	if (scb_data->scbarray == NULL)
		return (ENOMEM);
	bzero(scb_data->scbarray, sizeof(struct scb) * AHC_SCB_MAX);

	/* Determine the number of hardware SCBs and initialize them */

	scb_data->maxhscbs = ahc_probe_scbs(ahc);
	/* SCB 0 heads the free list */
	ahc_outb(ahc, FREE_SCBH, 0);
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		ahc_outb(ahc, SCBPTR, i);

		/* Clear the control byte. */
		ahc_outb(ahc, SCB_CONTROL, 0);

		/* Set the next pointer */
		ahc_outb(ahc, SCB_NEXT, i+1);

		/* Make the tag number invalid */
		ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
	}

	/* Make sure that the last SCB terminates the free list */
	ahc_outb(ahc, SCBPTR, i-1);
	ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);

	/* Ensure we clear the 0 SCB's control byte. */
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outb(ahc, SCB_CONTROL, 0);

	scb_data->maxhscbs = i;

	if (ahc->scb_data->maxhscbs == 0)
		panic("%s: No SCB space found", ahc_name(ahc));

	/*
	 * Create our DMA tags.  These tags define the kinds of device
	 * accessable memory allocations and memory mappings we will
	 * need to perform during normal operation.
	 *
	 * Unless we need to further restrict the allocation, we rely
	 * on the restrictions of the parent dmat, hence the common
	 * use of MAXADDR and MAXSIZE.
	 */

	if (ahc_createdmamem(ahc,
	    AHC_SCB_MAX * sizeof(struct hardware_scb), 
	    &scb_data->hscb_dmamap, (caddr_t *)&scb_data->hscbs, 
	    &scb_data->hscb_busaddr, &scb_data->hscb_seg,
	    &scb_data->hscb_nseg, "hardware SCB structures") < 0)
		goto error_exit;

	scb_data->init_level++;

	if (ahc_createdmamem(ahc,
	    AHC_SCB_MAX * sizeof(struct scsi_sense_data),
	    &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,
	    &scb_data->sense_busaddr, &scb_data->sense_seg,
	    &scb_data->sense_nseg, "sense buffers") < 0)
		goto error_exit;

	scb_data->init_level++;

	/* Perform initial CCB allocation */
	bzero(scb_data->hscbs, AHC_SCB_MAX * sizeof(struct hardware_scb));
	ahcallocscbs(ahc);

	if (scb_data->numscbs == 0) {
		printf("%s: ahc_init_scb_data - "
		       "Unable to allocate initial scbs\n",
		       ahc_name(ahc));
		goto error_exit;
	}

	scb_data->init_level++;

	/*
	 * Note that we were successfull
	 */
	return 0; 

error_exit:

	return ENOMEM;
}

STATIC void
ahcfiniscbdata(ahc)
	struct ahc_softc *ahc;
{
	struct scb_data *scb_data;

	scb_data = ahc->scb_data;

	switch (scb_data->init_level) {
	default:
	case 3:
	{
		struct sg_map_node *sg_map;

		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
			ahc_freedmamem(ahc->sc_dmat, PAGE_SIZE,
			    sg_map->sg_dmamap, (caddr_t)sg_map->sg_vaddr,
			    &sg_map->sg_dmasegs, sg_map->sg_nseg);
			free(sg_map, M_DEVBUF);
		}
	}
	/*FALLTHROUGH*/
	case 2:
		ahc_freedmamem(ahc->sc_dmat,
		    AHC_SCB_MAX * sizeof(struct scsi_sense_data),
		    scb_data->sense_dmamap, (caddr_t)scb_data->sense,
		    &scb_data->sense_seg, scb_data->sense_nseg);
	/*FALLTHROUGH*/
	case 1:
		ahc_freedmamem(ahc->sc_dmat,
		    AHC_SCB_MAX * sizeof(struct hardware_scb), 
		    scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,
		    &scb_data->hscb_seg, scb_data->hscb_nseg);
	/*FALLTHROUGH*/
	}
	if (scb_data->scbarray != NULL)
		free(scb_data->scbarray, M_DEVBUF);
d493 5
a497 1
ahc_xxx_reset(devname, iot, ioh)
d501 1
d503 1
a503 1
	u_char hcntrl;
a505 3
#ifdef AHC_DUMP_SEQ
	ahc_dumpseq(ahc);
#endif
d507 5
d515 1
d520 3
d524 1
d526 5
a530 1
	if (wait == 0) {
d532 2
a533 1
				 "Trying to initialize anyway.\n", devname);
d535 3
d539 1
d542 11
a552 3
int
ahc_reset(ahc)
	struct ahc_softc *ahc;
d554 6
a559 2
	u_int	sblkctl;
	int	wait;
d561 31
a591 103
#ifdef AHC_DUMP_SEQ
	if (ahc->init_level == 0)
		ahc_dumpseq(ahc);
#endif
	ahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);
	/*
	 * Ensure that the reset has finished
	 */
	wait = 1000;
	do {
		DELAY(1000);
	} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));

	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", ahc_name(ahc));
	}
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/* Determine channel configuration */
	sblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);
	/* No Twin Channel PCI cards */
	if ((ahc->chip & AHC_PCI) != 0)
		sblkctl &= ~SELBUSB;
	switch (sblkctl) {
	case 0:
		/* Single Narrow Channel */
		break;
	case 2:
		/* Wide Channel */
		ahc->features |= AHC_WIDE;
		break;
	case 8:
		/* Twin Channel */
		ahc->features |= AHC_TWIN;
		break;
	default:
		printf(" Unsupported adapter type.  Ignoring\n");
		return(-1);
	}
	return (0);
}

/*
 * Called when we have an active connection to a target on the bus,
 * this function finds the nearest syncrate to the input period limited
 * by the capabilities of the bus connectivity of the target.
 */
STATIC struct ahc_syncrate *
ahc_devlimited_syncrate(ahc, period)
	struct ahc_softc *ahc;
	u_int *period;
{
	u_int	maxsync;

	if ((ahc->features & AHC_ULTRA2) != 0) {
		if ((ahc_inb(ahc, SBLKCTL) & ENAB40) != 0
		 && (ahc_inb(ahc, SSTAT2) & EXP_ACTIVE) == 0) {
			maxsync = AHC_SYNCRATE_ULTRA2;
		} else {
			maxsync = AHC_SYNCRATE_ULTRA;
		}
	} else if ((ahc->features & AHC_ULTRA) != 0) {
		maxsync = AHC_SYNCRATE_ULTRA;
	} else {
		maxsync = AHC_SYNCRATE_FAST;
	}
	return (ahc_find_syncrate(ahc, period, maxsync));
}

/*
 * Look up the valid period to SCSIRATE conversion in our table.
 * Return the period and offset that should be sent to the target
 * if this was the beginning of an SDTR.
 */
STATIC struct ahc_syncrate *
ahc_find_syncrate(ahc, period, maxsync)
	struct ahc_softc *ahc;
	u_int *period;
	u_int maxsync;
{
	struct ahc_syncrate *syncrate;

	syncrate = &ahc_syncrates[maxsync];
	while ((syncrate->rate != NULL)
	    && ((ahc->features & AHC_ULTRA2) == 0
	     || (syncrate->sxfr_u2 != 0))) {

		if (*period <= syncrate->period) {
			/*
			 * When responding to a target that requests
			 * sync, the requested rate may fall between
			 * two rates that we can output, but still be
			 * a rate that we can receive.  Because of this,
			 * we want to respond to the target with
			 * the same rate that it sent to us even
			 * if the period we use to send data to it
			 * is lower.  Only lower the response period
			 * if we must.
			 */
			if (syncrate == &ahc_syncrates[maxsync])
				*period = syncrate->period;
			break;
a592 1
		syncrate++;
d594 1
a594 5

	if ((*period == 0)
	 || (syncrate->rate == NULL)
	 || ((ahc->features & AHC_ULTRA2) != 0
	  && (syncrate->sxfr_u2 == 0))) {
d596 1
d598 21
a618 198
		syncrate = NULL;
	}
	return (syncrate);
}

STATIC u_int
ahc_find_period(ahc, scsirate, maxsync)
	struct ahc_softc *ahc;
	u_int scsirate;
	u_int maxsync;
{
	struct ahc_syncrate *syncrate;

	if ((ahc->features & AHC_ULTRA2) != 0)
		scsirate &= SXFR_ULTRA2;
	else
		scsirate &= SXFR;

	syncrate = &ahc_syncrates[maxsync];
	while (syncrate->rate != NULL) {

		if ((ahc->features & AHC_ULTRA2) != 0) {
			if (syncrate->sxfr_u2 == 0)
				break;
			else if (scsirate == (syncrate->sxfr_u2 & SXFR_ULTRA2))
				return (syncrate->period);
		} else if (scsirate == (syncrate->sxfr & SXFR)) {
				return (syncrate->period);
		}
		syncrate++;
	}
	return (0); /* async */
}

STATIC void
ahc_validate_offset(ahc, syncrate, offset, wide)
	struct ahc_softc *ahc;
	struct ahc_syncrate *syncrate;
	u_int *offset;
	int wide;
{
	u_int maxoffset;

	/* Limit offset to what we can do */
	if (syncrate == NULL) {
		maxoffset = 0;
	} else if ((ahc->features & AHC_ULTRA2) != 0) {
		maxoffset = MAX_OFFSET_ULTRA2;
	} else {
		if (wide)
			maxoffset = MAX_OFFSET_16BIT;
		else
			maxoffset = MAX_OFFSET_8BIT;
	}
	*offset = MIN(*offset, maxoffset);
}

STATIC void
ahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct ahc_initiator_tinfo *tinfo;
	int force;
	int paused;
{
	u_int targ_msg_req_orig;

	targ_msg_req_orig = ahc->targ_msg_req;
	if (tinfo->current.period != tinfo->goal.period
	    || tinfo->current.width != tinfo->goal.width
	    || tinfo->current.offset != tinfo->goal.offset
	    || (force && (tinfo->goal.period != 0
	    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))
		ahc->targ_msg_req |= devinfo->target_mask;
	else
		ahc->targ_msg_req &= ~devinfo->target_mask;

	if (ahc->targ_msg_req != targ_msg_req_orig) {
		/* Update the message request bit for this target */
		if ((ahc->features & AHC_HS_MAILBOX) != 0) {
			if (paused) {
				ahc_outb(ahc, TARGET_MSG_REQUEST,
					 ahc->targ_msg_req & 0xFF);
				ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
					 (ahc->targ_msg_req >> 8) & 0xFF);
			} else {
				ahc_outb(ahc, HS_MAILBOX,
					 0x01 << HOST_MAILBOX_SHIFT);
			}
		} else {
			if (!paused)
				pause_sequencer(ahc);

			ahc_outb(ahc, TARGET_MSG_REQUEST,
				 ahc->targ_msg_req & 0xFF);
			ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
				 (ahc->targ_msg_req >> 8) & 0xFF);

			if (!paused)
				unpause_sequencer(ahc);
		}
	}
}

STATIC void
ahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct ahc_syncrate *syncrate;
	u_int period;
	u_int offset;
	u_int type;
	int paused;
	int done;
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	u_int	old_period;
	u_int	old_offset;
	int	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;

	if (syncrate == NULL) {
		period = 0;
		offset = 0;
	}

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
	old_period = tinfo->current.period;
	old_offset = tinfo->current.offset;

	if ((type & AHC_TRANS_CUR) != 0
	 && (old_period != period || old_offset != offset)) {
		u_int	scsirate;

		scsirate = tinfo->scsirate;
		if ((ahc->features & AHC_ULTRA2) != 0) {

			/* XXX */
			/* Force single edge until DT is fully implemented */
			scsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);
			if (syncrate != NULL)
				scsirate |= syncrate->sxfr_u2|SINGLE_EDGE;

			if (active)
				ahc_outb(ahc, SCSIOFFSET, offset);
		} else {

			scsirate &= ~(SXFR|SOFS);
			/*
			 * Ensure Ultra mode is set properly for
			 * this target.
			 */
			tstate->ultraenb &= ~devinfo->target_mask;
			if (syncrate != NULL) {
				if (syncrate->sxfr & ULTRA_SXFR) {
					tstate->ultraenb |=
						devinfo->target_mask;
				}
				scsirate |= syncrate->sxfr & SXFR;
				scsirate |= offset & SOFS;
			}
			if (active) {
				u_int sxfrctl0;

				sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
				sxfrctl0 &= ~FAST20;
				if (tstate->ultraenb & devinfo->target_mask)
					sxfrctl0 |= FAST20;
				ahc_outb(ahc, SXFRCTL0, sxfrctl0);
			}
		}
		if (active)
			ahc_outb(ahc, SCSIRATE, scsirate);

		tinfo->scsirate = scsirate;
		tinfo->current.period = period;
		tinfo->current.offset = offset;

		/* Update the syncrates in any pending scbs */
		ahc_update_pending_syncrates(ahc);
	}

	/*
	 * Print messages if we're verbose and at the end of a negotiation
	 * cycle.
	 */
	if (done && bootverbose) {
		if (offset != 0) {
			printf("%s: target %d synchronous at %sMHz, "
			       "offset = 0x%x\n", ahc_name(ahc),
			       devinfo->target, syncrate->rate, offset);
		} else {
			printf("%s: target %d using "
			       "asynchronous transfers\n",
			       ahc_name(ahc), devinfo->target);
		}
d620 2
a621 84

	if ((type & AHC_TRANS_GOAL) != 0) {
		tinfo->goal.period = period;
		tinfo->goal.offset = offset;
	}

	if ((type & AHC_TRANS_USER) != 0) {
		tinfo->user.period = period;
		tinfo->user.offset = offset;
	}

	ahc_update_target_msg_request(ahc, devinfo, tinfo,
				      /*force*/FALSE,
				      paused);
}

STATIC void
ahc_set_width(ahc, devinfo, width, type, paused, done)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	u_int width;
	u_int type;
	int paused;
	int done;
{
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
	u_int  oldwidth;
	int    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target,
				    &tstate);
	oldwidth = tinfo->current.width;

	if ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {
		u_int	scsirate;

		scsirate =  tinfo->scsirate;
		scsirate &= ~WIDEXFER;
		if (width == MSG_EXT_WDTR_BUS_16_BIT)
			scsirate |= WIDEXFER;

		tinfo->scsirate = scsirate;

		if (active)
			ahc_outb(ahc, SCSIRATE, scsirate);

		tinfo->current.width = width;
	}

	if (done) {
		printf("%s: target %d using %dbit transfers\n",
		       ahc_name(ahc), devinfo->target,
		       8 * (0x01 << width));
	}

	if ((type & AHC_TRANS_GOAL) != 0)
		tinfo->goal.width = width;
	if ((type & AHC_TRANS_USER) != 0)
		tinfo->user.width = width;

	ahc_update_target_msg_request(ahc, devinfo, tinfo,
				      /*force*/FALSE, paused);
}

STATIC void
ahc_set_tags(ahc, devinfo, enable)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	int enable;
{
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target,
				    &tstate);
	if (enable)
		tstate->tagenable |= devinfo->target_mask;
	else
		tstate->tagenable &= ~devinfo->target_mask;
d629 1
a629 1
	struct ahc_softc *ahc;
d631 5
d640 1
d649 5
d655 2
a656 1
	if (ahc->features & AHC_WIDE)
d658 5
d665 1
a665 1
	ahc->sc_link.openings = 2;
d667 1
d669 5
a673 2
	
	if (ahc->features & AHC_TWIN) {
d676 5
d682 2
a683 1
		if (ahc->features & AHC_WIDE)
d685 5
d692 39
a730 1
/*
d738 1
a738 1
		if (ahc->features & AHC_TWIN)
d747 1
a747 1
		/* assert(ahc->features & AHC_TWIN); */
d751 1
d755 27
a781 4
STATIC void
ahc_fetch_devinfo(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
d783 1
a783 8
	u_int	saved_tcl;
	role_t	role;
	int	our_id;

	if (ahc_inb(ahc, SSTAT0) & TARGET)
		role = ROLE_TARGET;
	else
		role = ROLE_INITIATOR;
d785 2
a786 9
	if (role == ROLE_TARGET
	 && (ahc->features & AHC_MULTI_TID) != 0
	 && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
		/* We were selected, so pull our id from TARGIDIN */
		our_id = ahc_inb(ahc, TARGIDIN) & OID;
	} else if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;
d788 1
a788 4
	saved_tcl = ahc_inb(ahc, SAVED_TCL);
	ahc_compile_devinfo(devinfo, our_id, TCL_TARGET(saved_tcl),
			    TCL_LUN(saved_tcl), TCL_CHANNEL(ahc, saved_tcl),
			    role);
d791 9
a799 8
STATIC void
ahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)
	struct ahc_devinfo *devinfo;
	u_int our_id;
	u_int target;
	u_int lun;
	char channel;
	role_t role;
d801 16
a816 9
	devinfo->our_scsiid = our_id;
	devinfo->target = target;
	devinfo->lun = lun;
	devinfo->target_offset = target;
	devinfo->channel = channel;
	devinfo->role = role;
	if (channel == 'B')
		devinfo->target_offset += 8;
	devinfo->target_mask = (0x01 << devinfo->target_offset);
d819 3
a821 5
/*
 * Catch an interrupt from the adapter
 */
int
ahc_intr(void *arg)
d823 2
a824 2
	struct	ahc_softc *ahc;
	u_int	intstat;
d826 2
a827 1
	ahc = (struct ahc_softc *)arg; 
d829 2
a830 1
	intstat = ahc_inb(ahc, INTSTAT);
d833 2
a834 1
	 * Any interrupts to process?
d836 12
a847 16
	if ((intstat & INT_PEND) == 0) {
		if (ahc->pci_intr_func && ahc->pci_intr_func(ahc)) {
#ifdef AHC_DEBUG
			printf("%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\n",
			    ahc_name(ahc),
			    ahc_inb(ahc, CCHADDR) |
			    (ahc_inb(ahc, CCHADDR+1) << 8)
			    | (ahc_inb(ahc, CCHADDR+2) << 16)
			    | (ahc_inb(ahc, CCHADDR+3) << 24),
			    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)
			    | (ahc_inb(ahc, HADDR+2) << 16)
			    | (ahc_inb(ahc, HADDR+3) << 24),
			    ahc_inb(ahc, SEQADDR0) |
			    (ahc_inb(ahc, SEQADDR1) << 8));
#endif
			return 1;
d849 1
a849 1
		return 0;
d851 36
d888 24
a911 10
	if (intstat & CMDCMPLT) {
		ahc_outb(ahc, CLRINT, CLRCMDINT);
		ahc_run_qoutfifo(ahc);
	}
	if (intstat & BRKADRINT) {
		/*
		 * We upset the sequencer :-(
		 * Lookup the error message
		 */
		int i, error, num_errors;
d913 6
a918 8
		error = ahc_inb(ahc, ERROR);
		num_errors =  sizeof(hard_error)/sizeof(hard_error[0]);
		for (i = 0; error != 1 && i < num_errors; i++)
			error >>= 1;
		panic("%s: brkadrint, %s at seqaddr = 0x%x\n",
		      ahc_name(ahc), hard_error[i].errmesg,
		      ahc_inb(ahc, SEQADDR0) |
		      (ahc_inb(ahc, SEQADDR1) << 8));
d920 10
a929 4
		/* Tell everyone that this HBA is no longer availible */
		ahc_abort_scbs(ahc, ALL_TARGETS, ALL_CHANNELS,
			       ALL_LUNS, SCB_LIST_NULL, ROLE_UNKNOWN,
			       XS_DRIVER_STUFFUP);
d931 3
a933 6
	if (intstat & SEQINT)
		ahc_handle_seqint(ahc, intstat);

	if (intstat & SCSIINT)
		ahc_handle_scsiint(ahc, intstat);
	return(1);
d936 7
a942 5
STATIC struct tmode_tstate *
ahc_alloc_tstate(ahc, scsi_id, channel)
	struct ahc_softc *ahc;
	u_int scsi_id;
	char channel;
d944 9
a952 16
	struct tmode_tstate *master_tstate;
	struct tmode_tstate *tstate;
	int i, s;

	master_tstate = ahc->enabled_targets[ahc->our_id];
	if (channel == 'B') {
		scsi_id += 8;
		master_tstate = ahc->enabled_targets[ahc->our_id_b + 8];
	}
	if (ahc->enabled_targets[scsi_id] != NULL
	 && ahc->enabled_targets[scsi_id] != master_tstate)
		panic("%s: ahc_alloc_tstate - Target already allocated",
		      ahc_name(ahc));
	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
	if (tstate == NULL)
		return (NULL);
d954 1
a954 21
	/*
	 * If we have allocated a master tstate, copy user settings from
	 * the master tstate (taken from SRAM or the EEPROM) for this
	 * channel, but reset our current and goal settings to async/narrow
	 * until an initiator talks to us.
	 */
	if (master_tstate != NULL) {
		bcopy(master_tstate, tstate, sizeof(*tstate));
		tstate->ultraenb = 0;
		for (i = 0; i < 16; i++) {
			bzero(&tstate->transinfo[i].current,
			      sizeof(tstate->transinfo[i].current));
			bzero(&tstate->transinfo[i].goal,
			      sizeof(tstate->transinfo[i].goal));
		}
	} else
		bzero(tstate, sizeof(*tstate));
	s = splbio();
	ahc->enabled_targets[scsi_id] = tstate;
	splx(s);
	return (tstate);
d957 10
a966 4
STATIC void
ahc_handle_seqint(ahc, intstat)
	struct ahc_softc *ahc;
	u_int intstat;
d968 5
a972 4
	struct scb *scb;
	struct ahc_devinfo devinfo;
	
	ahc_fetch_devinfo(ahc, &devinfo);
d974 1
d976 2
a977 4
	 * Clear the upper byte that holds SEQINT status
	 * codes and clear the SEQINT bit. We will unpause
	 * the sequencer, if appropriate, after servicing
	 * the request.
d979 6
a984 46
	ahc_outb(ahc, CLRINT, CLRSEQINT);
	switch (intstat & SEQINT_MASK) {
	case NO_MATCH:
	{
		/* Ensure we don't leave the selection hardware on */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));

		printf("%s:%c:%d: no active SCB for reconnecting "
		       "target - issuing BUS DEVICE RESET\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target);
		printf("SAVED_TCL == 0x%x, ARG_1 == 0x%x, SEQ_FLAGS == 0x%x\n",
		       ahc_inb(ahc, SAVED_TCL), ahc_inb(ahc, ARG_1),
		       ahc_inb(ahc, SEQ_FLAGS));
		ahc->msgout_buf[0] = MSG_BUS_DEV_RESET;
		ahc->msgout_len = 1;
		ahc->msgout_index = 0;
		ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, LASTPHASE) | ATNO);
		break;
	}
	case UPDATE_TMSG_REQ:
		ahc_outb(ahc, TARGET_MSG_REQUEST, ahc->targ_msg_req & 0xFF);
		ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
			 (ahc->targ_msg_req >> 8) & 0xFF);
		ahc_outb(ahc, HS_MAILBOX, 0);
		break;
	case SEND_REJECT: 
	{
		u_int rejbyte = ahc_inb(ahc, ACCUM);
		printf("%s:%c:%d: Warning - unknown message received from "
		       "target (0x%x).  Rejecting\n", 
		       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);
		break; 
	}
	case NO_IDENT: 
	{
		/*
		 * The reconnecting target either did not send an identify
		 * message, or did, but we didn't find and SCB to match and
		 * before it could respond to our ATN/abort, it hit a dataphase.
		 * The only safe thing to do is to blow it away with a bus
		 * reset.
		 */
		int found;
d986 2
a987 14
		printf("%s:%c:%d: Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x, SAVED_TCL == 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_TCL));
		found = ahc_reset_channel(ahc, devinfo.channel, 
					  /*initiate reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), devinfo.channel,
		       found);
		return;
	}
	case BAD_PHASE:
	{
		u_int lastphase;
d989 12
a1000 400
		lastphase = ahc_inb(ahc, LASTPHASE);
		if (lastphase == P_BUSFREE) {
			printf("%s:%c:%d: Missed busfree.  Curphase = 0x%x\n",
			       ahc_name(ahc), devinfo.channel, devinfo.target,
			       ahc_inb(ahc, SCSISIGI));
			restart_sequencer(ahc);
			return;
		} else {
			printf("%s:%c:%d: unknown scsi bus phase %x.  "
			       "Attempting to continue\n",
			       ahc_name(ahc), devinfo.channel, devinfo.target,
			       ahc_inb(ahc, SCSISIGI));
		}
		break; 
	}
	case BAD_STATUS:
	{
		u_int  scb_index;
		struct hardware_scb *hscb;
		struct scsi_xfer *xs;
		/*
		 * The sequencer will notify us when a command
		 * has an error that would be of interest to
		 * the kernel.  This allows us to leave the sequencer
		 * running in the common case of command completes
		 * without error.  The sequencer will already have
		 * dma'd the SCB back up to us, so we can reference
		 * the in kernel copy directly.
		 */
		scb_index = ahc_inb(ahc, SCB_TAG);
		scb = &ahc->scb_data->scbarray[scb_index];

		/*
		 * Set the default return value to 0 (don't
		 * send sense).  The sense code will change
		 * this if needed.
		 */
		ahc_outb(ahc, RETURN_1, 0);
		if (!(scb_index < ahc->scb_data->numscbs
		   && (scb->flags & SCB_ACTIVE) != 0)) {
			printf("%s:%c:%d: ahc_intr - referenced scb "
			       "not valid during seqint 0x%x scb(%d)\n",
			       ahc_name(ahc), devinfo.channel,
			       devinfo.target, intstat, scb_index);
			goto unpause;
		}

		hscb = scb->hscb; 
		xs = scb->xs;

		/* Don't want to clobber the original sense code */
		if ((scb->flags & SCB_SENSE) != 0) {
			/*
			 * Clear the SCB_SENSE Flag and have
			 * the sequencer do a normal command
			 * complete.
			 */
			scb->flags &= ~SCB_SENSE;
			ahcsetccbstatus(xs, XS_DRIVER_STUFFUP);
			break;
		}
		/* Freeze the queue unit the client sees the error. */
		ahc_freeze_devq(ahc, xs->sc_link);
		ahc_freeze_ccb(scb);
		xs->status = hscb->status;
		switch (hscb->status) {
		case SCSI_OK:
			printf("%s: Interrupted for staus of 0???\n",
			       ahc_name(ahc));
			break;
		case SCSI_CHECK:
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d: requests Check Status\n",
				       scb->hscb->tag);
			}
#endif
				
			if (xs->error == XS_NOERROR &&
			    !(scb->flags & SCB_SENSE)) {
				struct ahc_dma_seg *sg;
				struct scsi_sense *sc;
				struct ahc_initiator_tinfo *tinfo;
				struct tmode_tstate *tstate;

				sg = scb->sg_list;
				sc = (struct scsi_sense *)(&hscb->cmdstore); 
				/*
				 * Save off the residual if there is one.
				 */
				if (hscb->residual_SG_count != 0)
					ahc_calc_residual(scb);
				else
					xs->resid = 0;

#ifdef AHC_DEBUG
				if (ahc_debug & AHC_SHOWSENSE) {
					sc_print_addr(scb->xs->sc_link);
					printf("Sending Sense\n");
				}
#endif
				sg->addr = ahc->scb_data->sense_busaddr +
					(hscb->tag*sizeof(struct scsi_sense_data));
				
				sg->len = sizeof(struct scsi_sense_data);

				sc->opcode = REQUEST_SENSE;
				sc->byte2 =  SCB_LUN(scb) << 5;
				sc->unused[0] = 0;
				sc->unused[1] = 0;
				sc->length = sg->len;
				sc->control = 0;

				/*
				 * Would be nice to preserve DISCENB here,
				 * but due to the way we page SCBs, we can't.
				 */
				hscb->control = 0;

				/*
				 * This request sense could be because the
				 * the device lost power or in some other
				 * way has lost our transfer negotiations.
				 * Renegotiate if appropriate.
				 */
				ahc_calc_residual(scb);
#ifdef AHC_DEBUG
				if (ahc_debug & AHC_SHOWSENSE) {
					sc_print_addr(xs->sc_link);
					printf("Sense: datalen %d resid %d"
					       "chan %d id %d targ %d\n",
					       xs->datalen, xs->resid,
					       devinfo.channel,
					       devinfo.our_scsiid,
					       devinfo.target);
				}
#endif
				if (xs->datalen > 0 &&
				    xs->resid == xs->datalen) {
				tinfo = ahc_fetch_transinfo(ahc,
							    devinfo.channel,
							    devinfo.our_scsiid,
							    devinfo.target,
							    &tstate);
					ahc_update_target_msg_request(ahc,
							      &devinfo,
							      tinfo,
							      /*force*/TRUE,
							      /*paused*/TRUE);
				}
				hscb->status = 0;
				hscb->SG_count = 1;
				hscb->SG_pointer = scb->sg_list_phys;
				hscb->data = sg->addr; 
				hscb->datalen = sg->len;
				hscb->cmdpointer = hscb->cmdstore_busaddr;
				hscb->cmdlen = sizeof(*sc);
				scb->sg_count = hscb->SG_count;
				scb->flags |= SCB_SENSE;
				/*
				 * Ensure the target is busy since this
				 * will be an untagged request.
				 */
				ahc_busy_tcl(ahc, scb);
				ahc_outb(ahc, RETURN_1, SEND_SENSE);

				/*
				 * Ensure we have enough time to actually
				 * retrieve the sense.
				 */
				if (!(scb->xs->flags & SCSI_POLL)) {
				untimeout(ahc_timeout, (caddr_t)scb);
					timeout(ahc_timeout, (caddr_t)scb,
					    5 * hz);
				}
			}
			break;
		case SCSI_BUSY:
			/*
			 * Requeue any transactions that haven't been
			 * sent yet.
			 */
			ahc_freeze_devq(ahc, xs->sc_link);
			ahc_freeze_ccb(scb);
			break;
		}
		break;
	}
	case TRACE_POINT:
	{
		printf("SSTAT2 = 0x%x DFCNTRL = 0x%x\n", ahc_inb(ahc, SSTAT2),
		       ahc_inb(ahc, DFCNTRL));
		printf("SSTAT3 = 0x%x DSTATUS = 0x%x\n", ahc_inb(ahc, SSTAT3),
		       ahc_inb(ahc, DFSTATUS));
		printf("SSTAT0 = 0x%x, SCB_DATACNT = 0x%x\n",
		       ahc_inb(ahc, SSTAT0),
		       ahc_inb(ahc, SCB_DATACNT));
		break;
	}
	case HOST_MSG_LOOP:
	{
		/*
		 * The sequencer has encountered a message phase
		 * that requires host assistance for completion.
		 * While handling the message phase(s), we will be
		 * notified by the sequencer after each byte is
		 * transfered so we can track bus phases.
		 *
		 * If this is the first time we've seen a HOST_MSG_LOOP,
		 * initialize the state of the host message loop.
		 */
		if (ahc->msg_type == MSG_TYPE_NONE) {
			u_int bus_phase;

			bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			if (bus_phase != P_MESGIN
			 && bus_phase != P_MESGOUT) {
				printf("ahc_intr: HOST_MSG_LOOP bad "
				       "phase 0x%x\n",
				      bus_phase);
				/*
				 * Probably transitioned to bus free before
				 * we got here.  Just punt the message.
				 */
				ahc_clear_intstat(ahc);
				restart_sequencer(ahc);
			}

			if (devinfo.role == ROLE_INITIATOR) {
				struct scb *scb;
				u_int scb_index;

				scb_index = ahc_inb(ahc, SCB_TAG);
				scb = &ahc->scb_data->scbarray[scb_index];

				if (bus_phase == P_MESGOUT)
					ahc_setup_initiator_msgout(ahc,
								   &devinfo,
								   scb);
				else {
					ahc->msg_type =
					    MSG_TYPE_INITIATOR_MSGIN;
					ahc->msgin_index = 0;
				}
			} else {
				if (bus_phase == P_MESGOUT) {
					ahc->msg_type =
					    MSG_TYPE_TARGET_MSGOUT;
					ahc->msgin_index = 0;
				} else 
					/* XXX Ever executed??? */
					ahc_setup_target_msgin(ahc, &devinfo);
			}
			}

		/* Pass a NULL path so that handlers generate their own */
		ahc_handle_message_phase(ahc, /*path*/NULL);
		break;
		}
	case PERR_DETECTED:
	{
		/*
		 * If we've cleared the parity error interrupt
		 * but the sequencer still believes that SCSIPERR
		 * is true, it must be that the parity error is
		 * for the currently presented byte on the bus,
		 * and we are not in a phase (data-in) where we will
		 * eventually ack this byte.  Ack the byte and
		 * throw it away in the hope that the target will
		 * take us to message out to deliver the appropriate
		 * error message.
		 */
		if ((intstat & SCSIINT) == 0
		 && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {
			u_int curphase;

			/*
			 * The hardware will only let you ack bytes
			 * if the expected phase in SCSISIGO matches
			 * the current phase.  Make sure this is
			 * currently the case.
			 */
			curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			ahc_outb(ahc, LASTPHASE, curphase);
			ahc_outb(ahc, SCSISIGO, curphase);
			ahc_inb(ahc, SCSIDATL);
		}
		break;
	}
	case DATA_OVERRUN:
	{
		/*
		 * When the sequencer detects an overrun, it
		 * places the controller in "BITBUCKET" mode
		 * and allows the target to complete its transfer.
		 * Unfortunately, none of the counters get updated
		 * when the controller is in this mode, so we have
		 * no way of knowing how large the overrun was.
		 */
		u_int scbindex = ahc_inb(ahc, SCB_TAG);
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		int i;

		scb = &ahc->scb_data->scbarray[scbindex];
		for (i = 0; i < num_phases; i++) {
			if (lastphase == phase_table[i].phase)
				break;
		}
		sc_print_addr(scb->xs->sc_link);
		printf("data overrun detected %s."
		       "  Tag == 0x%x.\n",
		       phase_table[i].phasemsg,
  		       scb->hscb->tag);
		sc_print_addr(scb->xs->sc_link);
		printf("%s seen Data Phase.  Length = %d.  NumSGs = %d.\n",
		       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
		       scb->xs->datalen, scb->sg_count);
		if (scb->sg_count > 0) {
			for (i = 0; i < scb->sg_count; i++) {
				printf("sg[%d] - Addr 0x%x : Length %d\n",
				       i,
				       scb->sg_list[i].addr,
				       scb->sg_list[i].len);
			}
		}
		/*
		 * Set this and it will take affect when the
		 * target does a command complete.
		 */
		ahc_freeze_devq(ahc, scb->xs->sc_link);
		ahcsetccbstatus(scb->xs, XS_DRIVER_STUFFUP);
		ahc_freeze_ccb(scb);
		break;
	}
	case TRACEPOINT:
	{
		printf("TRACEPOINT: RETURN_2 = %d\n", ahc_inb(ahc, RETURN_2));
#if 0
		printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1));
		printf("SSTAT0 == 0x%x\n", ahc_inb(ahc, SSTAT0));
		printf(", SCSISIGI == 0x%x\n", ahc_inb(ahc, SCSISIGI));
		printf("TRACEPOINT: CCHCNT = %d, SG_COUNT = %d\n",
		       ahc_inb(ahc, CCHCNT), ahc_inb(ahc, SG_COUNT));
		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG));
		printf("TRACEPOINT1: CCHADDR = %d, CCHCNT = %d, SCBPTR = %d\n",
		       ahc_inb(ahc, CCHADDR)
		    | (ahc_inb(ahc, CCHADDR+1) << 8)
		    | (ahc_inb(ahc, CCHADDR+2) << 16)
		    | (ahc_inb(ahc, CCHADDR+3) << 24),
		       ahc_inb(ahc, CCHCNT)
		    | (ahc_inb(ahc, CCHCNT+1) << 8)
		    | (ahc_inb(ahc, CCHCNT+2) << 16),
		       ahc_inb(ahc, SCBPTR));
		printf("TRACEPOINT: WAITING_SCBH = %d\n", 
		       ahc_inb(ahc, WAITING_SCBH));
		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG));
#endif
		break;
	}
#if NOT_YET
	/* XXX Fill these in later */
	case MESG_BUFFER_BUSY:
		break;
	case MSGIN_PHASEMIS:
		break;
#endif
	default:
		printf("ahc_intr: seqint, "
		       "intstat == 0x%x, scsisigi = 0x%x\n",
		       intstat, ahc_inb(ahc, SCSISIGI));
		break;
	}
	
unpause:
	/*
	 *  The sequencer is paused immediately on
	 *  a SEQINT, so we should restart it when
	 *  we're done.
	 */
	unpause_sequencer(ahc);
}

STATIC void
ahc_handle_scsiint(ahc, intstat)
	struct ahc_softc *ahc;
	u_int intstat;
{
	u_int	scb_index;
	u_int	status;
	struct	scb *scb;
	char	cur_channel;
	char	intr_channel;

	if ((ahc->features & AHC_TWIN) != 0
	 && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
		cur_channel = 'B';
	else
		cur_channel = 'A';
	intr_channel = cur_channel;
d1002 1
a1002 14
	status = ahc_inb(ahc, SSTAT1);
	if (status == 0) {
		if ((ahc->features & AHC_TWIN) != 0) {
			/* Try the other channel */
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			status = ahc_inb(ahc, SSTAT1);
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			intr_channel = (cur_channel == 'A') ? 'B' : 'A';
		}
		if (status == 0) {
			printf("%s: Spurious SCSI interrupt\n", ahc_name(ahc));
			return;
		}
	}
d1004 15
a1018 5
	scb_index = ahc_inb(ahc, SCB_TAG);
	if (scb_index < ahc->scb_data->numscbs) {
		scb = &ahc->scb_data->scbarray[scb_index];
		if ((scb->flags & SCB_ACTIVE) == 0
		 || (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)
a1019 47
	} else
		scb = NULL;

	if ((status & SCSIRSTI) != 0) {
		printf("%s: Someone reset channel %c\n",
			ahc_name(ahc), intr_channel);
		ahc_reset_channel(ahc, intr_channel, /* Initiate Reset */FALSE);
	} else if ((status & SCSIPERR) != 0) {
		/*
		 * Determine the bus phase and queue an appropriate message.
		 * SCSIPERR is latched true as soon as a parity error
		 * occurs.  If the sequencer acked the transfer that
		 * caused the parity error and the currently presented
		 * transfer on the bus has correct parity, SCSIPERR will
		 * be cleared by CLRSCSIPERR.  Use this to determine if
		 * we should look at the last phase the sequencer recorded,
		 * or the current phase presented on the bus.
		 */
		u_int mesg_out;
		u_int curphase;
		u_int errorphase;
		u_int lastphase;
		int   i;

		lastphase = ahc_inb(ahc, LASTPHASE);
		curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
		ahc_outb(ahc, CLRSINT1, CLRSCSIPERR);
		/*
		 * For all phases save DATA, the sequencer won't
		 * automatically ack a byte that has a parity error
		 * in it.  So the only way that the current phase
		 * could be 'data-in' is if the parity error is for
		 * an already acked byte in the data phase.  During
		 * synchronous data-in transfers, we may actually
		 * ack bytes before latching the current phase in
		 * LASTPHASE, leading to the discrepancy between
		 * curphase and lastphase.
		 */
		if ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0
		 || curphase == P_DATAIN)
			errorphase = curphase;
		else
			errorphase = lastphase;

		for (i = 0; i < num_phases; i++) {
			if (errorphase == phase_table[i].phase)
				break;
d1021 7
a1027 143
		mesg_out = phase_table[i].mesg_out;
		if (scb != NULL)
			sc_print_addr(scb->xs->sc_link);
		else
			printf("%s:%c:%d: ", ahc_name(ahc),
			       intr_channel,
			       TCL_TARGET(ahc_inb(ahc, SAVED_TCL)));
		
		printf("parity error detected %s. "
		       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
		       phase_table[i].phasemsg,
		       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),
		       ahc_inb(ahc, SCSIRATE));

		/*
		 * We've set the hardware to assert ATN if we   
		 * get a parity error on "in" phases, so all we  
		 * need to do is stuff the message buffer with
		 * the appropriate message.  "In" phases have set
		 * mesg_out to something other than MSG_NOP.
		 */
		if (mesg_out != MSG_NOOP) {
			if (ahc->msg_type != MSG_TYPE_NONE)
				ahc->send_msg_perror = TRUE;
			else
				ahc_outb(ahc, MSG_OUT, mesg_out);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		unpause_sequencer(ahc);
	} else if ((status & BUSFREE) != 0
		&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {
		/*
		 * First look at what phase we were last in.
		 * If its message out, chances are pretty good
		 * that the busfree was in response to one of
		 * our abort requests.
		 */
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		u_int saved_tcl = ahc_inb(ahc, SAVED_TCL);
		u_int target = TCL_TARGET(saved_tcl);
		u_int initiator_role_id = TCL_SCSI_ID(ahc, saved_tcl);
		char channel = TCL_CHANNEL(ahc, saved_tcl);
		int printerror = 1;

		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (lastphase == P_MESGOUT) {
			u_int message;
			u_int tag;

			message = ahc->msgout_buf[ahc->msgout_index - 1];
			tag = SCB_LIST_NULL;
			switch (message) {
			case MSG_ABORT_TAG:
				tag = scb->hscb->tag;
				/* FALLTRHOUGH */
			case MSG_ABORT:
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d - Abort %s Completed.\n",
				       scb->hscb->tag, tag == SCB_LIST_NULL ?
				       "" : "Tag");
				ahc_abort_scbs(ahc, target, channel,
					       TCL_LUN(saved_tcl), tag,
					       ROLE_INITIATOR,
					       XS_DRIVER_STUFFUP);
				printerror = 0;
				break;
			case MSG_BUS_DEV_RESET:
			{
				struct ahc_devinfo devinfo;

				if (scb != NULL &&
				    (scb->xs->flags & SCSI_RESET)
				 && ahc_match_scb(scb, target, channel,
						  TCL_LUN(saved_tcl),
						  SCB_LIST_NULL,
						  ROLE_INITIATOR)) {
					ahcsetccbstatus(scb->xs, XS_NOERROR);
				}
				ahc_compile_devinfo(&devinfo,
						    initiator_role_id,
						    target,
						    TCL_LUN(saved_tcl),
						    channel,
						    ROLE_INITIATOR);
				ahc_handle_devreset(ahc, &devinfo,
						    XS_RESET,
						    "Bus Device Reset",
						    /*verbose_level*/0);
				printerror = 0;
				break;
			}
			default:
				break;
			}
		}
		if (printerror != 0) {
			int i;

			if (scb != NULL) {
				u_int tag;

				if ((scb->hscb->control & TAG_ENB) != 0)
					tag = scb->hscb->tag;
				else
					tag = SCB_LIST_NULL;
				ahc_abort_scbs(ahc, target, channel,
					       SCB_LUN(scb), tag,
					       ROLE_INITIATOR,
					       XS_DRIVER_STUFFUP);
			} else {
				/*
				 * We had not fully identified this connection,
				 * so we cannot abort anything.
				 */
				printf("%s: ", ahc_name(ahc));
			}
			for (i = 0; i < num_phases; i++) {
				if (lastphase == phase_table[i].phase)
					break;
			}
			printf("Unexpected busfree %s\n"
			       "SEQADDR == 0x%x\n",
			       phase_table[i].phasemsg, ahc_inb(ahc, SEQADDR0)
				| (ahc_inb(ahc, SEQADDR1) << 8));
		}
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		restart_sequencer(ahc);
	} else if ((status & SELTO) != 0) {
		u_int scbptr;

		scbptr = ahc_inb(ahc, WAITING_SCBH);
		ahc_outb(ahc, SCBPTR, scbptr);
		scb_index = ahc_inb(ahc, SCB_TAG);

		if (scb_index < ahc->scb_data->numscbs) {
			scb = &ahc->scb_data->scbarray[scb_index];
			if ((scb->flags & SCB_ACTIVE) == 0)
				scb = NULL;
		} else
a1028 332

		if (scb == NULL) {
			printf("%s: ahc_intr - referenced scb not "
			       "valid during SELTO scb(%d, %d)\n",
			       ahc_name(ahc), scbptr, scb_index);
		} else {
			u_int tag;

			tag = SCB_LIST_NULL;
			if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0)
				tag = scb->hscb->tag;

			ahc_abort_scbs(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				       SCB_LUN(scb), tag,
				       ROLE_INITIATOR, XS_SELTIMEOUT);
		}
		/* Stop the selection */
		ahc_outb(ahc, SCSISEQ, 0);

		/* No more pending messages */
		ahc_clear_msg_state(ahc);

		/*
		 * Although the driver does not care about the
		 * 'Selection in Progress' status bit, the busy
		 * LED does.  SELINGO is only cleared by a sucessful
		 * selection, so we must manually clear it to ensure
		 * the LED turns off just incase no future successful
		 * selections occur (e.g. no devices on the bus).
		 */
		ahc_outb(ahc, CLRSINT0, CLRSELINGO);

		/* Clear interrupt state */
		ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		restart_sequencer(ahc);
	} else {
		sc_print_addr(scb->xs->sc_link);
		printf("Unknown SCSIINT. Status = 0x%x\n", status);
		ahc_outb(ahc, CLRSINT1, status);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		unpause_sequencer(ahc);
	}
}

STATIC void
ahc_build_transfer_msg(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	/*
	 * We need to initiate transfer negotiations.
	 * If our current and goal settings are identical,
	 * we want to renegotiate due to a check condition.
	 */
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	int	dowide;
	int	dosync;

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
	dowide = tinfo->current.width != tinfo->goal.width;
	dosync = tinfo->current.period != tinfo->goal.period;

	if (!dowide && !dosync) {
		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
		dosync = tinfo->goal.period != 0;
	}

	if (dowide) {
		ahc_construct_wdtr(ahc, tinfo->goal.width);
	} else if (dosync) {
		struct	ahc_syncrate *rate;
		u_int	period;
		u_int	offset;

		period = tinfo->goal.period;
		rate = ahc_devlimited_syncrate(ahc, &period);
		offset = tinfo->goal.offset;
		ahc_validate_offset(ahc, rate, &offset,
				    tinfo->current.width);
		ahc_construct_sdtr(ahc, period, offset);
	} else {
		panic("ahc_intr: AWAITING_MSG for negotiation, "
		      "but no negotiation needed\n");	
	}
}

STATIC void
ahc_setup_initiator_msgout(ahc, devinfo, scb)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct scb *scb;
{
	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if ((scb->flags & SCB_DEVICE_RESET) == 0
	 && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {
		u_int identify_msg;

		identify_msg = MSG_IDENTIFYFLAG | SCB_LUN(scb);
		if ((scb->hscb->control & DISCENB) != 0)
			identify_msg |= MSG_IDENTIFY_DISCFLAG;
		ahc->msgout_buf[ahc->msgout_index++] = identify_msg;
		ahc->msgout_len++;

		if ((scb->hscb->control & TAG_ENB) != 0) {
			/* XXX fvdl FreeBSD has tag action passed down */
			ahc->msgout_buf[ahc->msgout_index++] = MSG_SIMPLE_Q_TAG;
			ahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;
			ahc->msgout_len += 2;
		}
	}

	if (scb->flags & SCB_DEVICE_RESET) {
		ahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;
		ahc->msgout_len++;
		
		sc_print_addr(scb->xs->sc_link);
		printf("Bus Device Reset Message Sent\n");
	} else if (scb->flags & SCB_ABORT) {
		if ((scb->hscb->control & TAG_ENB) != 0)
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;
		else
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;
		ahc->msgout_len++;
		sc_print_addr(scb->xs->sc_link);
		printf("Abort Message Sent\n");
	} else if ((ahc->targ_msg_req & devinfo->target_mask) != 0) {
		ahc_build_transfer_msg(ahc, devinfo);
	} else {
		printf("ahc_intr: AWAITING_MSG for an SCB that "
		       "does not have a waiting message");
		panic("SCB = %d, SCB Control = %x, MSG_OUT = %x "
		      "SCB flags = %x", scb->hscb->tag, scb->hscb->control,
		      ahc_inb(ahc, MSG_OUT), scb->flags);
	}

	/*
	 * Clear the MK_MESSAGE flag from the SCB so we aren't
	 * asked to send this message again.
	 */
	ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);
	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
}

STATIC void
ahc_setup_target_msgin(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if ((ahc->targ_msg_req & devinfo->target_mask) != 0)
		ahc_build_transfer_msg(ahc, devinfo);
	else
		panic("ahc_intr: AWAITING target message with no message");

	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
}

STATIC int
ahc_handle_msg_reject(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	/*
	 * What we care about here is if we had an
	 * outstanding SDTR or WDTR message for this
	 * target.  If we did, this is a signal that
	 * the target is refusing negotiation.
	 */
	struct scb *scb;
	u_int scb_index;
	u_int last_msg;
	int   response = 0;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = &ahc->scb_data->scbarray[scb_index];

	/* Might be necessary */
	last_msg = ahc_inb(ahc, LAST_MSG);

	if (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/FALSE)) {
		struct ahc_initiator_tinfo *tinfo;
		struct tmode_tstate *tstate;

		/* note 8bit xfers */
		printf("%s:%c:%d: refuses WIDE negotiation.  Using "
		       "8bit transfers\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target);
		ahc_set_width(ahc, devinfo,
			      MSG_EXT_WDTR_BUS_8_BIT,
			      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
			      /*paused*/TRUE, /*done*/TRUE);
		/*
		 * No need to clear the sync rate.  If the target
		 * did not accept the command, our syncrate is
		 * unaffected.  If the target started the negotiation,
		 * but rejected our response, we already cleared the
		 * sync rate before sending our WDTR.
		 */
		tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
					    devinfo->our_scsiid,
					    devinfo->target, &tstate);
		if (tinfo->goal.period) {
			u_int period;

			/* Start the sync negotiation */
			period = tinfo->goal.period;
			ahc_devlimited_syncrate(ahc, &period);
			ahc->msgout_index = 0;
			ahc->msgout_len = 0;
			ahc_construct_sdtr(ahc, period, tinfo->goal.offset);
			ahc->msgout_index = 0;
			response = 1;
		}
	} else if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/FALSE)) {
		/* note asynch xfers and clear flag */
		ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL, /*period*/0,
				 /*offset*/0,
				 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				 /*paused*/TRUE,
				 /*done*/TRUE);
		printf("%s:%c:%d: refuses synchronous negotiation. "
		       "Using asynchronous transfers\n",
		       ahc_name(ahc),
		       devinfo->channel, devinfo->target);
	} else if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0) {
		printf("%s:%c:%d: refuses tagged commands.  Performing "
		       "non-tagged I/O\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target);
			
		ahc_set_tags(ahc, devinfo, FALSE);

		/*
		 * Resend the identify for this CCB as the target
		 * may believe that the selection is invalid otherwise.
		 */
		ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL)
					  & ~MSG_SIMPLE_Q_TAG);
	 	scb->hscb->control &= ~MSG_SIMPLE_Q_TAG;
		ahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);
		ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);

		/*
		 * Requeue all tagged commands for this target
		 * currently in our posession so they can be
		 * converted to untagged commands.
		 */
		ahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				   SCB_LUN(scb), /*tag*/SCB_LIST_NULL,
				   ROLE_INITIATOR, SCB_REQUEUE,
				   SEARCH_COMPLETE);
	} else {
		/*
		 * Otherwise, we ignore it.
		 */
		printf("%s:%c:%d: Message reject for %x -- ignored\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       last_msg);
	}
	return (response);
}

STATIC void
ahc_clear_msg_state(ahc)
	struct ahc_softc *ahc;
{
	ahc->msgout_len = 0;
	ahc->msgin_index = 0;
	ahc->msg_type = MSG_TYPE_NONE;
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
}

STATIC void
ahc_handle_message_phase(ahc, sc_link)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
{ 
	struct	ahc_devinfo devinfo;
	u_int	bus_phase;
	int	end_session;

	ahc_fetch_devinfo(ahc, &devinfo);
	end_session = FALSE;
	bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;

reswitch:
	switch (ahc->msg_type) {
	case MSG_TYPE_INITIATOR_MSGOUT:
	{
		int lastbyte;
		int phasemis;
		int msgdone;

		if (ahc->msgout_len == 0)
			panic("REQINIT interrupt with no active message");

		phasemis = bus_phase != P_MESGOUT;
		if (phasemis) {
			if (bus_phase == P_MESGIN) {
				/*
				 * Change gears and see if
				 * this messages is of interest to
				 * us or should be passed back to
				 * the sequencer.
				 */
				ahc_outb(ahc, CLRSINT1, CLRATNO);
				ahc->send_msg_perror = FALSE;
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;
				ahc->msgin_index = 0;
				goto reswitch;
			}
			end_session = TRUE;
			break;
d1030 1
a1030 10

		if (ahc->send_msg_perror) {
			ahc_outb(ahc, CLRSINT1, CLRATNO);
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
			ahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);
			break;
		}

		msgdone	= ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
d1032 2
a1033 3
			 * The target has requested a retry.
			 * Re-assert ATN, reset our message index to
			 * 0, and try again.
d1035 32
a1066 33
			ahc->msgout_index = 0;
			ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);
		}

		lastbyte = ahc->msgout_index == (ahc->msgout_len - 1);
		if (lastbyte) {
			/* Last byte is signified by dropping ATN */
			ahc_outb(ahc, CLRSINT1, CLRATNO);
		}

		/*
		 * Clear our interrupt status and present
		 * the next byte on the bus.
		 */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
		break;
	}
	case MSG_TYPE_INITIATOR_MSGIN:
	{
		int phasemis;
		int message_done;

		phasemis = bus_phase != P_MESGIN;

		if (phasemis) {
			ahc->msgin_index = 0;
			if (bus_phase == P_MESGOUT
			 && (ahc->send_msg_perror == TRUE
			  || (ahc->msgout_len != 0
			   && ahc->msgout_index == 0))) {
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
				goto reswitch;
d1068 1
a1068 95
			end_session = TRUE;
			break;
		}

		/* Pull the byte in without acking it */
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);

		message_done = ahc_parse_msg(ahc, sc_link, &devinfo);

		if (message_done) {
			/*
			 * Clear our incoming message buffer in case there
			 * is another message following this one.
			 */
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response,
			 * assert ATN so the target takes us to the
			 * message out phase.
			 */
			if (ahc->msgout_len != 0)
				ahc_outb(ahc, SCSISIGO,
					 ahc_inb(ahc, SCSISIGO) | ATNO);
		} else 
			ahc->msgin_index++;

		/* Ack the byte */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_inb(ahc, SCSIDATL);
		break;
	}
	case MSG_TYPE_TARGET_MSGIN:
	{
		int msgdone;
		int msgout_request;

		if (ahc->msgout_len == 0)
			panic("Target MSGIN with no active message");

		/*
		 * If we interrupted a mesgout session, the initiator
		 * will not know this until our first REQ.  So, we
		 * only honor mesgout requests after we've sent our
		 * first byte.
		 */
		if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0
		 && ahc->msgout_index > 0)
			msgout_request = TRUE;
		else
			msgout_request = FALSE;

		if (msgout_request) {

			/*
			 * Change gears and see if
			 * this messages is of interest to
			 * us or should be passed back to
			 * the sequencer.
			 */
			ahc->msg_type = MSG_TYPE_TARGET_MSGOUT;
			ahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);
			ahc->msgin_index = 0;
			/* Dummy read to REQ for first byte */
			ahc_inb(ahc, SCSIDATL);
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
			break;
		}

		msgdone = ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
			end_session = TRUE;
			break;
		}

		/*
		 * Present the next byte on the bus.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
		break;
	}
	case MSG_TYPE_TARGET_MSGOUT:
	{
		int lastbyte;
		int msgdone;

		/*
		 * The initiator signals that this is
		 * the last byte by dropping ATN.
		 */
		lastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;
a1069 9
		/*
		 * Read the latched byte, but turn off SPIOEN first
		 * so that we don't inadvertantly cause a REQ for the
		 * next byte.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);
		msgdone = ahc_parse_msg(ahc, sc_link, &devinfo);
		if (msgdone == MSGLOOP_TERMINATED) {
d1071 5
a1075 4
			 * The message is *really* done in that it caused
			 * us to go to bus free.  The sequencer has already
			 * been reset at this point, so pull the ejection
			 * handle.
d1077 10
a1086 1
			return;
d1088 3
a1090 9
		
		ahc->msgin_index++;

		/*
		 * XXX Read spec about initiator dropping ATN too soon
		 *     and use msgdone to detect it.
		 */
		if (msgdone == MSGLOOP_MSGCOMPLETE) {
			ahc->msgin_index = 0;
d1092 2
d1095 2
a1096 2
			 * If this message illicited a response, transition
			 * to the Message in phase and send it.
d1098 54
a1151 7
			if (ahc->msgout_len != 0) {
				ahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);
				ahc_outb(ahc, SXFRCTL0,
					 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
				ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
				ahc->msgin_index = 0;
				break;
d1153 3
a1155 1
		}
d1157 1
a1157 7
		if (lastbyte)
			end_session = TRUE;
		else {
			/* Ask for the next byte. */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		}
d1159 1
a1159 1
		break;
d1161 3
a1163 9
	default:
		panic("Unknown REQINIT message type");
	}

	if (end_session) {
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);
	} else
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
d1166 4
a1169 11
/*
 * See if we sent a particular extended message to the target.
 * If "full" is true, the target saw the full message.
 * If "full" is false, the target saw at least the first
 * byte of the message.
 */
STATIC int
ahc_sent_msg(ahc, msgtype, full)
	struct ahc_softc *ahc;
	u_int msgtype;
	int full;
d1171 19
a1189 2
	int found;
	int index;
d1191 10
a1200 2
	found = FALSE;
	index = 0;
d1202 8
a1209 2
	while (index < ahc->msgout_len) {
		if (ahc->msgout_buf[index] == MSG_EXTENDED) {
d1211 51
a1261 11
			/* Found a candidate */
			if (ahc->msgout_buf[index+2] == msgtype) {
				u_int end_index;

				end_index = index + 1
					  + ahc->msgout_buf[index + 1];
				if (full) {
					if (ahc->msgout_index > end_index)
						found = TRUE;
				} else if (ahc->msgout_index > index)
					found = TRUE;
d1263 45
a1307 3
			break;
		} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_Q_TAG
			&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
d1309 28
a1336 2
			/* Skip tag type and tag id or residue param*/
			index += 2;
d1338 9
a1346 2
			/* Single byte message */
			index++;
a1347 41
	}
	return (found);
}

STATIC int
ahc_parse_msg(ahc, sc_link, devinfo)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
	struct ahc_devinfo *devinfo;
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	int	reject;
	int	done;
	int	response;
	u_int	targ_scsirate;

	done = MSGLOOP_IN_PROG;
	response = FALSE;
	reject = FALSE;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	targ_scsirate = tinfo->scsirate;

	/*
	 * Parse as much of the message as is availible,
	 * rejecting it if we don't support it.  When
	 * the entire message is availible and has been
	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
	 * that we have parsed an entire message.
	 *
	 * In the case of extended messages, we accept the length
	 * byte outright and perform more checking once we know the
	 * extended message type.
	 */
	switch (ahc->msgin_buf[0]) {
	case MSG_MESSAGE_REJECT:
		response = ahc_handle_msg_reject(ahc, devinfo);
		/* FALLTHROUGH */
	case MSG_NOOP:
		done = MSGLOOP_MSGCOMPLETE;
d1349 1
a1349 1
	case MSG_IGN_WIDE_RESIDUE:
d1351 11
a1361 9
		/* Wait for the whole message */
		if (ahc->msgin_index >= 1) {
			if (ahc->msgin_buf[1] != 1
			 || tinfo->current.width == MSG_EXT_WDTR_BUS_8_BIT) {
				reject = TRUE;
				done = MSGLOOP_MSGCOMPLETE;
			} else
				ahc_handle_ign_wide_residue(ahc, devinfo);
		}
d1363 5
a1367 2
	}
	case MSG_EXTENDED:
d1369 6
a1374 4
		/* Wait for enough of the message to begin validation */
		if (ahc->msgin_index < 2)
			break;
		switch (ahc->msgin_buf[2]) {
d1377 6
a1382 4
			struct	 ahc_syncrate *syncrate;
			u_int	 period;
			u_int	 offset;
			u_int	 saved_offset;
d1384 3
a1386 2
			if (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
				reject = TRUE;
d1389 13
d1404 2
a1405 5
			 * Wait until we have both args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_SDTR_LEN to account for
			 * the extended message preamble.
d1407 3
a1409 12
			if (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))
				break;

			period = ahc->msgin_buf[3];
			saved_offset = offset = ahc->msgin_buf[4];
			syncrate = ahc_devlimited_syncrate(ahc, &period);
			ahc_validate_offset(ahc, syncrate, &offset,
					    targ_scsirate & WIDEXFER);
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period, offset,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE, /*done*/TRUE);
d1416 9
a1424 6
			if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/TRUE)) {
				/* We started it */
				if (saved_offset != offset) {
					/* Went too low - force async */
					reject = TRUE;
				}
d1429 18
a1446 7
				if (bootverbose)
					printf("Sending SDTR!\n");
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_sdtr(ahc, period, offset);
				ahc->msgout_index = 0;
				response = TRUE;
a1447 1
			done = MSGLOOP_MSGCOMPLETE;
d1452 1
a1452 2
			u_int	bus_width;
			u_int	sending_reply;
d1454 3
a1456 3
			sending_reply = FALSE;
			if (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
				reject = TRUE;
d1460 3
a1462 9
			/*
			 * Wait until we have our arg before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_WDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))
				break;
d1464 1
a1464 2
			bus_width = ahc->msgin_buf[3];
			if (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/TRUE)) {
d1469 13
a1481 2
				switch (bus_width){
				default:
d1483 2
a1484 3
					 * How can we do anything greater
					 * than 16bit transfers on a 16bit
					 * bus?
d1486 2
a1487 2
					reject = TRUE;
					printf("%s: target %d requested %dBit "
d1489 1
a1489 5
					       ahc_name(ahc), devinfo->target,
					       8 * (0x01 << bus_width));
					/* FALLTHROUGH */
				case MSG_EXT_WDTR_BUS_8_BIT:
					bus_width = MSG_EXT_WDTR_BUS_8_BIT;
d1491 1
a1491 1
				case MSG_EXT_WDTR_BUS_16_BIT:
d1498 19
a1516 3
				if (bootverbose)
					printf("Sending WDTR!\n");
				switch (bus_width) {
a1517 9
					if (ahc->features & AHC_WIDE) {
						/* Respond Wide */
						bus_width =
						    MSG_EXT_WDTR_BUS_16_BIT;
						break;
					}
					/* FALLTHROUGH */
				case MSG_EXT_WDTR_BUS_8_BIT:
					bus_width = MSG_EXT_WDTR_BUS_8_BIT;
d1520 3
a1522 6
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_wdtr(ahc, bus_width);
				ahc->msgout_index = 0;
				response = TRUE;
				sending_reply = TRUE;
d1524 5
a1528 31
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE, /*done*/TRUE);

			/* After a wide message, we are async */
			ahc_set_syncrate(ahc, devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, AHC_TRANS_ACTIVE,
					 /*paused*/TRUE, /*done*/FALSE);
			if (sending_reply == FALSE && reject == FALSE) {

				if (tinfo->goal.period) {
					struct	ahc_syncrate *rate;
					u_int	period;
					u_int	offset;

					/* Start the sync negotiation */
					period = tinfo->goal.period;
					rate = ahc_devlimited_syncrate(ahc,
								       &period);
					offset = tinfo->goal.offset;
					ahc_validate_offset(ahc, rate, &offset,
							  tinfo->current.width);
					ahc->msgout_index = 0;
					ahc->msgout_len = 0;
					ahc_construct_sdtr(ahc, period, offset);
					ahc->msgout_index = 0;
					response = TRUE;
				}
			}
			done = MSGLOOP_MSGCOMPLETE;
d1533 47
a1579 1
			reject = TRUE;
d1582 2
d1586 139
a1724 13
	case MSG_BUS_DEV_RESET:
		ahc_handle_devreset(ahc, devinfo,
				    XS_RESET, "Bus Device Reset Received",
				    /*verbose_level*/0);
		restart_sequencer(ahc);
		done = MSGLOOP_TERMINATED;
		break;
	case MSG_ABORT_TAG:
	case MSG_ABORT:
	case MSG_CLEAR_QUEUE:
		/* Target mode messages */
		if (devinfo->role != ROLE_TARGET) {
			reject = TRUE;
d1727 50
a1776 18
#if AHC_TARGET_MODE
		ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       devinfo->lun,
			       ahc->msgin_buf[0] == MSG_ABORT_TAG ? SCB_LIST_NULL
			       : ahc_inb(ahc, INITIATOR_TAG),
				ROLE_TARGET, XS_DRIVER_STUFFUP);

		tstate = ahc->enabled_targets[devinfo->our_scsiid];
		if (tstate != NULL) {
			struct tmode_lstate* lstate;

			lstate = tstate->enabled_luns[devinfo->lun];
			if (lstate != NULL) {
				ahc_queue_lstate_event(ahc, lstate,
						       devinfo->our_scsiid,
						       ahc->msgin_buf[0],
						       /*arg*/0);
				ahc_send_lstate_events(ahc, lstate);
a1777 4
		}
		done = MSGLOOP_MSGCOMPLETE;
#else
		panic("ahc: got target mode message");
d1779 143
a1921 2
		break;
	case MSG_TERM_IO_PROC:
d1923 3
a1925 1
		reject = TRUE;
d1928 7
a1935 120
	if (reject) {
		/*
		 * Setup to reject the message.
		 */
		ahc->msgout_index = 0;
		ahc->msgout_len = 1;
		ahc->msgout_buf[0] = MSG_MESSAGE_REJECT;
		done = MSGLOOP_MSGCOMPLETE;
		response = TRUE;
	}

	if (done != MSGLOOP_IN_PROG && !response)
		/* Clear the outgoing message buffer */
		ahc->msgout_len = 0;

	return (done);
}

STATIC void
ahc_handle_ign_wide_residue(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	u_int scb_index;
	struct scb *scb;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = &ahc->scb_data->scbarray[scb_index];
	if ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0
	 || !(scb->xs->flags & SCSI_DATA_IN)) {
		/*
		 * Ignore the message if we haven't
		 * seen an appropriate data phase yet.
		 */
	} else {
		/*
		 * If the residual occurred on the last
		 * transfer and the transfer request was
		 * expected to end on an odd count, do
		 * nothing.  Otherwise, subtract a byte
		 * and update the residual count accordingly.
		 */
		u_int resid_sgcnt;

		resid_sgcnt = ahc_inb(ahc, SCB_RESID_SGCNT);
		if (resid_sgcnt == 0
		 && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {
			/*
			 * If the residual occurred on the last
			 * transfer and the transfer request was
			 * expected to end on an odd count, do
			 * nothing.
			 */
		} else {
			u_int data_cnt;
			u_int data_addr;
			u_int sg_index;

			data_cnt = (ahc_inb(ahc, SCB_RESID_DCNT + 2) << 16)
				 | (ahc_inb(ahc, SCB_RESID_DCNT + 1) << 8)
				 | (ahc_inb(ahc, SCB_RESID_DCNT));

			data_addr = (ahc_inb(ahc, SHADDR + 3) << 24)
				  | (ahc_inb(ahc, SHADDR + 2) << 16)
				  | (ahc_inb(ahc, SHADDR + 1) << 8)
				  | (ahc_inb(ahc, SHADDR));

			data_cnt += 1;
			data_addr -= 1;

			sg_index = scb->sg_count - resid_sgcnt;

			if (sg_index != 0
			 && (scb->sg_list[sg_index].len < data_cnt)) {
				u_int sg_addr;

				sg_index--;
				data_cnt = 1;
				data_addr = scb->sg_list[sg_index].addr
					  + scb->sg_list[sg_index].len - 1;
				
				/*
				 * The physical address base points to the
				 * second entry as it is always used for
				 * calculating the "next S/G pointer".
				 */
				sg_addr = scb->sg_list_phys
					+ (sg_index* sizeof(*scb->sg_list));
				ahc_outb(ahc, SG_NEXT + 3, sg_addr >> 24);
				ahc_outb(ahc, SG_NEXT + 2, sg_addr >> 16);
				ahc_outb(ahc, SG_NEXT + 1, sg_addr >> 8);
				ahc_outb(ahc, SG_NEXT, sg_addr);
			}

			ahc_outb(ahc, SCB_RESID_DCNT + 2, data_cnt >> 16);
			ahc_outb(ahc, SCB_RESID_DCNT + 1, data_cnt >> 8);
			ahc_outb(ahc, SCB_RESID_DCNT, data_cnt);

			ahc_outb(ahc, SHADDR + 3, data_addr >> 24);
			ahc_outb(ahc, SHADDR + 2, data_addr >> 16);
			ahc_outb(ahc, SHADDR + 1, data_addr >> 8);
			ahc_outb(ahc, SHADDR, data_addr);
		}
	}
}

STATIC void
ahc_handle_devreset(ahc, devinfo, status, message, verbose_level)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	int status;
	char *message;
	int verbose_level;
{
	int found;

	found = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       ALL_LUNS, SCB_LIST_NULL, devinfo->role,
			       status);
	
d1937 3
a1939 3
	 * Go back to async/narrow transfers and renegotiate.
	 * ahc_set_width and ahc_set_syncrate can cope with NULL
	 * paths.
d1941 1
a1941 10
	ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
		      AHC_TRANS_CUR, /*paused*/TRUE, /*done*/FALSE);
	ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,
			 /*period*/0, /*offset*/0, AHC_TRANS_CUR,
			 /*paused*/TRUE, /*done*/FALSE);
	
	if (message != NULL
	 && (verbose_level <= bootverbose))
		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahc_name(ahc),
		       message, devinfo->channel, devinfo->target, found);
d1945 1
a1945 1
 * We have an scb which has been processed by the
d1949 1
a1949 1
STATIC void
d1951 1
a1951 1
	struct ahc_softc *ahc;
a1954 3
	struct scsi_link *sc_link = xs->sc_link;
	int requeue = 0;
	int target;
a1956 26
	
	LIST_REMOVE(scb, pend_links);

	untimeout(ahc_timeout, (caddr_t)scb);

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWCMDS) {
		sc_print_addr(sc_link);
		printf("ahc_done opcode %d tag %x\n", xs->cmdstore.opcode,
		    scb->hscb->tag);
	}
#endif
	
	target = sc_link->target;
	
	if (xs->datalen) {
		int op;
	
		if ((xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_POSTREAD;
		else
			op = BUS_DMASYNC_POSTWRITE;
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);
		bus_dmamap_unload(ahc->sc_dmat, scb->dmamap);
	}

d1958 2
a1959 3
	 * Unbusy this target/channel/lun.
	 * XXX if we are holding two commands per lun, 
	 *     send the next command.
d1961 33
a1993 14
	ahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);

	/*
	 * If the recovery SCB completes, we have to be
	 * out of our timeout.
	 */
	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {

		struct	scb *scbp;

		/*
		 * We were able to complete the command successfully,
		 * so reinstate the timeouts for all other pending
		 * commands.
d1995 21
a2015 7
		scbp = ahc->pending_scbs.lh_first;
		while (scbp != NULL) {
			struct scsi_xfer *txs = scbp->xs;

			if (!(txs->flags & SCSI_POLL)) {
				timeout(ahc_timeout, scbp,
				    (scbp->xs->timeout * hz)/1000);
a2016 1
			scbp = LIST_NEXT(scbp, pend_links);
a2017 56

		/*
		 * Ensure that we didn't put a second instance of this
		 * SCB into the QINFIFO.
		 */
		ahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				   SCB_LUN(scb), scb->hscb->tag,
				   ROLE_INITIATOR, /*status*/0,
				   SEARCH_REMOVE);
		if (xs->error != XS_NOERROR)
			ahcsetccbstatus(xs, XS_TIMEOUT);
		sc_print_addr(xs->sc_link);
		printf("no longer in timeout, status = %x\n", xs->status);
	}

	if (xs->error != XS_NOERROR) {
		/* Don't clobber any existing error state */
	} else if ((scb->flags & SCB_SENSE) != 0) {
		/*
		 * We performed autosense retrieval.
		 *
		 * bzero the sense data before having
		 * the drive fill it.  The SCSI spec mandates
		 * that any untransfered data should be
		 * assumed to be zero.  Complete the 'bounce'
		 * of sense information through buffers accessible
		 * via bus-space by copying it into the clients
		 * csio.
		 */
		bzero(&xs->sense, sizeof(struct scsi_sense));
		bcopy(&ahc->scb_data->sense[scb->hscb->tag],
		      &xs->sense, scb->sg_list->len);
		xs->error = XS_SENSE;
	}
	if (scb->flags & SCB_FREEZE_QUEUE) {
		ahc->devqueue_blocked[target]--;
		scb->flags &= ~SCB_FREEZE_QUEUE;
	}
	
	requeue = scb->flags & SCB_REQUEUE;
	ahcfreescb(ahc, scb);

	if (requeue) {
		/*
		 * Re-insert at the front of the private queue to
		 * preserve order.
		 */
		int s;

		s = splbio();
		/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */
		ahc_list_insert_head(ahc, xs);
		splx(s);
	} else {
		xs->flags |= ITSDONE;
		scsi_done(xs);
d2019 3
d2023 1
d2032 3
a2034 24
	if ((xs = ahc->sc_xxxq.lh_first) != NULL)
		(void) ahc_scsi_cmd(xs);
}

/*
 * Determine the number of SCBs available on the controller
 */
int
ahc_probe_scbs(ahc)
	struct ahc_softc *ahc;
{
	int i;

	for (i = 0; i < AHC_SCB_MAX; i++) {
		ahc_outb(ahc, SCBPTR, i);
		ahc_outb(ahc, SCB_CONTROL, i);
		if (ahc_inb(ahc, SCB_CONTROL) != i)
			break;
		ahc_outb(ahc, SCBPTR, 0);
		if (ahc_inb(ahc, SCB_CONTROL) != 0)
			break;
	}
	
	return (i);
d2042 1
a2042 1
	struct ahc_softc *ahc;
d2044 2
a2046 39
	int	  i;
	int	  term;
	u_int	  scsi_conf;
	u_int	  scsiseq_template;
	u_int	  ultraenb;
	u_int	  discenable;
	u_int	  tagenable;
	size_t	  driver_data_size;
	u_int32_t physaddr;
	struct scb_data *scb_data = NULL;

#ifdef AHC_PRINT_SRAM
	printf("Scratch Ram:");
	for (i = 0x20; i < 0x5f; i++) {
		if (((i % 8) == 0) && (i != 0)) {
			printf ("\n              ");
		}
		printf (" 0x%x", ahc_inb(ahc, i));
	}
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0x70; i < 0x7f; i++) {
			if (((i % 8) == 0) && (i != 0)) {
				printf ("\n              ");
			}
			printf (" 0x%x", ahc_inb(ahc, i));
		}
	}
	printf ("\n");
#endif

	if (ahc->scb_data == NULL) {
		scb_data = malloc(sizeof (struct scb_data), M_DEVBUF, M_NOWAIT);
		if (scb_data == NULL) {
			printf("%s: cannot malloc scb_data!\n", ahc_name(ahc));
			return (ENOMEM);
		}
		bzero(scb_data, sizeof(struct scb_data));
		ahc->scb_data = scb_data;
	}
a2049 18
	if ((ahc->flags & AHC_USEDEFAULTS) != 0)
		ahc->our_id = ahc->our_id_b = 7;
	
	/*
	 * Default to allowing initiator operations.
	 */
	ahc->flags |= AHC_INITIATORMODE;
	
	/*
	 * DMA tag for our command fifos and other data in system memory
	 * the card's sequencer must be able to access.  For initiator
	 * roles, we need to allocate space for the qinfifo, qoutfifo,
	 * and untagged_scb arrays each of which are composed of 256
	 * 1 byte elements.  When providing for the target mode role,
	 * we additionally must provide space for the incoming target
	 * command fifo.
	 */
	driver_data_size = 3 * 256 * sizeof(u_int8_t);
d2051 4
a2054 22
	if (ahc_createdmamem(ahc, driver_data_size, 
	    &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,
	    &ahc->shared_data_busaddr, &ahc->shared_data_seg,
	    &ahc->shared_data_nseg, "shared data") < 0)
		return (ENOMEM);

	ahc->init_level++;

	/* Allocate SCB data now that sc_dmat is initialized */
	if (ahc->scb_data->maxhscbs == 0)
		if (ahcinitscbdata(ahc) != 0)
			return (ENOMEM);

	ahc->qinfifo = &ahc->qoutfifo[256];
	ahc->untagged_scbs = &ahc->qinfifo[256];
	/* There are no untagged SCBs active yet. */
	for (i = 0; i < 256; i++)
		ahc->untagged_scbs[i] = SCB_LIST_NULL;

	/* All of our queues are empty */
	for (i = 0; i < 256; i++)
		ahc->qoutfifo[i] = SCB_LIST_NULL;
d2056 36
a2091 9
	/*
	 * Allocate a tstate to house information for our
	 * initiator presence on the bus as well as the user
	 * data for any target mode initiator.
	 */
	if (ahc_alloc_tstate(ahc, ahc->our_id, 'A') == NULL) {
		printf("%s: unable to allocate tmode_tstate.  "
		       "Failing attach\n", ahc_name(ahc));
		return (-1);
d2094 18
a2111 14
	if ((ahc->features & AHC_TWIN) != 0) {
		if (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {
			printf("%s: unable to allocate tmode_tstate.  "
			       "Failing attach\n", ahc_name(ahc));
			return (-1);
		}
 		printf("Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, ",
		       ahc->our_id, ahc->our_id_b,
		       ahc->flags & AHC_CHANNEL_B_PRIMARY? 'B': 'A');
	} else {
		if ((ahc->features & AHC_WIDE) != 0) {
			printf("Wide ");
		} else {
			printf("Single ");
d2113 7
a2119 1
		printf("Channel %c, SCSI Id=%d, ", ahc->channel, ahc->our_id);
d2122 4
a2125 6
	ahc_outb(ahc, SEQ_FLAGS, 0);

	if (ahc->scb_data->maxhscbs < AHC_SCB_MAX) {
		ahc->flags |= AHC_PAGESCBS;
		printf("%d/%d SCBs\n", ahc->scb_data->maxhscbs, AHC_SCB_MAX);
	} else {
a2126 1
		printf("%d SCBs\n", ahc->scb_data->maxhscbs);
d2129 2
d2132 3
a2134 2
	if (ahc_debug & AHC_SHOWMISC) {
		printf("%s: hardware scb %d bytes; kernel scb %d bytes; "
d2137 2
a2138 2
		        sizeof(struct hardware_scb),
			sizeof(struct scb),
d2143 3
a2145 3
	/* Set the SCSI Id,SXFRCTL0,SXFRCTL1, and SIMODE1, for both channels*/
	if (ahc->features & AHC_TWIN) {

d2150 7
a2156 3
		term = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;
		if ((ahc->features & AHC_ULTRA2) != 0)
			ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id_b);
d2158 17
a2174 10
			ahc_outb(ahc, SCSIID, ahc->our_id_b);
		scsi_conf = ahc_inb(ahc, SCSICONF + 1);
		ahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))
					|term|ENSTIMER|ACTNEGEN);
		ahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
		ahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);

		if ((scsi_conf & RESET_SCSI) != 0
		 && (ahc->flags & AHC_INITIATORMODE) != 0)
			ahc->flags |= AHC_RESET_BUS_B;
d2177 1
a2177 1
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
d2179 7
a2185 3
	term = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);
d2187 17
a2203 11
		ahc_outb(ahc, SCSIID, ahc->our_id);
	scsi_conf = ahc_inb(ahc, SCSICONF);
	ahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))
				|term
				|ENSTIMER|ACTNEGEN);
	ahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
	ahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);

	if ((scsi_conf & RESET_SCSI) != 0
	 && (ahc->flags & AHC_INITIATORMODE) != 0)
		ahc->flags |= AHC_RESET_BUS_A;
d2207 6
a2212 1
	 * the board bios has left us.
d2214 2
a2215 2
	ultraenb = 0;	
	tagenable = ALL_TARGETS_MASK;
d2218 1
a2218 1
	if (ahc->flags & AHC_USEDEFAULTS) {
d2221 1
a2221 11
		ahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B|
			      AHC_TERM_ENB_A|AHC_TERM_ENB_B;
		discenable = ALL_TARGETS_MASK;
		if ((ahc->features & AHC_ULTRA) != 0)
			ultraenb = ALL_TARGETS_MASK;
	} else {
		discenable = ~((ahc_inb(ahc, DISC_DSB + 1) << 8)
			   | ahc_inb(ahc, DISC_DSB));
		if ((ahc->features & (AHC_ULTRA|AHC_ULTRA2)) != 0)
			ultraenb = (ahc_inb(ahc, ULTRA_ENB + 1) << 8)
				      | ahc_inb(ahc, ULTRA_ENB);
d2223 3
d2227 1
a2227 1
	if ((ahc->features & (AHC_WIDE|AHC_TWIN)) == 0)
d2230 2
a2231 19
	for (i = 0; i <= max_targ; i++) {
		struct ahc_initiator_tinfo *tinfo;
		struct tmode_tstate *tstate;
		u_int our_id;
		u_int target_id;
		char channel;

		channel = 'A';
		our_id = ahc->our_id;
		target_id = i;
		if (i > 7 && (ahc->features & AHC_TWIN) != 0) {
			channel = 'B';
			our_id = ahc->our_id_b;
			target_id = i % 8;
		}
		tinfo = ahc_fetch_transinfo(ahc, channel, our_id,
					    target_id, &tstate);
		/* Default to async narrow across the board */
		bzero(tinfo, sizeof(*tinfo));
d2233 5
a2237 13
			if ((ahc->features & AHC_WIDE) != 0)
				tinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;

			/*
			 * These will be truncated when we determine the
			 * connection type we have with the target.
			 */
			tinfo->user.period = ahc_syncrates->period;
			tinfo->user.offset = ~0;
		} else {
			u_int scsirate;
			u_int16_t mask;

d2239 1
a2239 5
			scsirate = ahc_inb(ahc, TARG_SCSIRATE + i);
			mask = (0x01 << i);
			if ((ahc->features & AHC_ULTRA2) != 0) {
				u_int offset;
				u_int maxsync;
d2241 30
a2270 29
				if ((scsirate & SOFS) == 0x0F) {
					/*
					 * Haven't negotiated yet,
					 * so the format is different.
					 */
					scsirate = (scsirate & SXFR) >> 4
						 | (ultraenb & mask)
						  ? 0x08 : 0x0
						 | (scsirate & WIDEXFER);
					offset = MAX_OFFSET_ULTRA2;
				} else
					offset = ahc_inb(ahc, TARG_OFFSET + i);
				maxsync = AHC_SYNCRATE_ULTRA2;
				if ((ahc->features & AHC_DT) != 0)
					maxsync = AHC_SYNCRATE_DT;
				tinfo->user.period =
				    ahc_find_period(ahc, scsirate, maxsync);
				if (offset == 0)
					tinfo->user.period = 0;
				else
					tinfo->user.offset = ~0;
			} else if ((scsirate & SOFS) != 0) {
				tinfo->user.period = 
				    ahc_find_period(ahc, scsirate,
						    (ultraenb & mask)
						   ? AHC_SYNCRATE_ULTRA
						   : AHC_SYNCRATE_FAST);
				if (tinfo->user.period != 0)
					tinfo->user.offset = ~0;
d2272 2
a2273 8
			if ((scsirate & WIDEXFER) != 0
			 && (ahc->features & AHC_WIDE) != 0)
				tinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;
		}
		tinfo->goal = tinfo->user; /* force negotiation */
		tstate->ultraenb = ultraenb;
		tstate->discenable = discenable;
		tstate->tagenable = 0; /* Wait until the XPT says its okay */
a2274 3
	ahc->user_discenable = discenable;
	ahc->user_tagenable = tagenable;

d2276 13
a2288 20
	 * Tell the sequencer where it can find our arrays in memory.
	 */
	physaddr = ahc->scb_data->hscb_busaddr;
	ahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);

	physaddr = ahc->shared_data_busaddr;
	ahc_outb(ahc, SCBID_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 3, (physaddr >> 24) & 0xFF);

	/* Target mode incomding command fifo */
	physaddr += 3 * 256 * sizeof(u_int8_t);
	ahc_outb(ahc, TMODE_CMDADDR, physaddr & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 3, (physaddr >> 24) & 0xFF);
d2290 2
a2291 18
	/*
	 * Initialize the group code to command length table.
	 * This overrides the values in TARG_SCSIRATE, so only
	 * setup the table after we have processed that information.
	 */
	ahc_outb(ahc, CMDSIZE_TABLE, 5);
	ahc_outb(ahc, CMDSIZE_TABLE + 1, 9);
	ahc_outb(ahc, CMDSIZE_TABLE + 2, 9);
	ahc_outb(ahc, CMDSIZE_TABLE + 3, 0);
	ahc_outb(ahc, CMDSIZE_TABLE + 4, 15);
	ahc_outb(ahc, CMDSIZE_TABLE + 5, 11);
	ahc_outb(ahc, CMDSIZE_TABLE + 6, 0);
	ahc_outb(ahc, CMDSIZE_TABLE + 7, 0);
		
	/* Tell the sequencer of our initial queue positions */
	ahc_outb(ahc, KERNEL_QINPOS, 0);
	ahc_outb(ahc, QINPOS, 0);
	ahc_outb(ahc, QOUTPOS, 0);
d2294 2
a2295 1
	if (ahc_debug & AHC_SHOWMISC)
d2297 2
a2298 3
		       "DISCENABLE == 0x%x\nULTRAENB == 0x%x\n",
		       ahc->needsdtr_orig, ahc->needwdtr_orig,
		       discenable, ultraenb);
d2300 4
d2305 5
a2309 3
	/* Don't have any special messages to send to targets */
	ahc_outb(ahc, TARGET_MSG_REQUEST, 0);
	ahc_outb(ahc, TARGET_MSG_REQUEST + 1, 0);
d2312 3
a2314 2
	 * Use the built in queue management registers
	 * if they are available.
d2316 1
a2316 6
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);
		ahc_outb(ahc, SDSCB_QOFF, 0);
		ahc_outb(ahc, SNSCB_QOFF, 0);
		ahc_outb(ahc, HNSCB_QOFF, 0);
	}
d2318 3
d2323 1
a2323 1
	ahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);
d2326 1
a2326 1
	ahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);
d2329 1
a2329 11
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);

	/*
	 * Setup the allowed SCSI Sequences based on operational mode.
	 * If we are a target, we'll enalbe select in operations once
	 * we've had a lun enabled.
	 */
	scsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;
	if ((ahc->flags & AHC_INITIATORMODE) != 0)
		scsiseq_template |= ENRSELI;
	ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);
d2335 2
a2336 1
	if (bootverbose)
d2339 1
d2343 13
a2355 2
	/* We have to wait until after any system dumps... */
	shutdownhook_establish(ahc_shutdown, ahc);
d2359 4
d2364 5
a2368 4
 * Routines to manage a scsi_xfer into the software queue.  
 * We overload xs->free_list to to ensure we don't run into a queue 
 * resource shortage, and keep a pointer to the last entry around 
 * to make insertion O(C).
d2370 6
a2375 8
STATIC INLINE void
ahc_list_insert_before(ahc, xs, next_xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	struct scsi_xfer *next_xs;
{
	LIST_INSERT_BEFORE(xs, next_xs, free_list); 

d2378 9
a2386 3
STATIC INLINE void
ahc_list_insert_head(ahc, xs)
	struct ahc_softc *ahc;
d2388 1
a2389 5
	if (ahc->sc_xxxq.lh_first == NULL)
		ahc->sc_xxxqlast = xs;
	LIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);
	return;
}
d2391 3
a2393 7
STATIC INLINE void
ahc_list_insert_tail(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	if (ahc->sc_xxxq.lh_first == NULL){
		ahc->sc_xxxqlast = xs;
d2397 1
d2402 9
a2410 3
STATIC INLINE void
ahc_list_remove(ahc, xs)
	struct ahc_softc *ahc;
d2412 2
a2413 13
{
	struct scsi_xfer *lxs;
	if (xs == ahc->sc_xxxqlast) {
		lxs = ahc->sc_xxxq.lh_first;
		while (lxs != NULL) {
			if (LIST_NEXT(lxs, free_list) == ahc->sc_xxxqlast) {
                                ahc->sc_xxxqlast = lxs;
				break;
			}
			lxs = LIST_NEXT(xs, free_list);
		}
	}
	
d2415 1
a2417 1
}
d2419 1
a2419 6
STATIC INLINE struct scsi_xfer *
ahc_list_next(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	return(LIST_NEXT(xs, free_list));
d2421 1
d2424 3
a2426 1
 * Pick the first xs for a non-blocked target.
d2428 1
a2428 22
STATIC INLINE struct scsi_xfer *
ahc_first_xs(struct ahc_softc *ahc)
{
	int target;
	struct scsi_xfer *xs = ahc->sc_xxxq.lh_first;

	if (ahc->queue_blocked)
        	return NULL;

	while (xs != NULL) {
		target = xs->sc_link->target;
		if (ahc->devqueue_blocked[target] == 0 &&
		    ahc_index_busy_tcl(ahc, XS_TCL(ahc, xs), FALSE) ==
			SCB_LIST_NULL)
			break;
		xs = LIST_NEXT(xs, free_list);
	}

	return xs;
}

STATIC int32_t
d2430 1
a2430 1
	struct scsi_xfer *xs;
d2432 20
a2451 11
	struct scsi_xfer *first_xs, *next_xs = NULL;
	struct ahc_softc *ahc;
	struct scb *scb;
	struct hardware_scb *hscb;	
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
	u_int target_id;
	u_int our_id;
	int s, tcl;
	u_int16_t mask;
	int dontqueue = 0, fromqueue = 0;
d2453 1
a2453 2
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("ahc_scsi_cmd\n"));
	ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
d2455 1
a2458 25
	if (xs == ahc->sc_xxxq.lh_first) {
		/*
		 * Called from ahc_done. Calling with the first entry in
		 * the queue is really just a way of seeing where we're
		 * called from. Now, find the first eligible SCB to send,
		 * e.g. one which will be accepted immediately.
		 */

		if (ahc->queue_blocked) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}

		xs = ahc_first_xs(ahc);
		if (xs == NULL) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}

		next_xs = ahc_list_next(ahc, xs);
		ahc_list_remove(ahc, xs);
		fromqueue = 1;
		goto get_scb;
	}

d2460 4
a2463 2
	 * If no new requests are accepted, just insert into the
	 * private queue to wait for our turn.
d2465 4
a2468 13
	tcl = XS_TCL(ahc, xs);

	if (ahc->queue_blocked ||
	    ahc->devqueue_blocked[xs->sc_link->target] ||
	    ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL) {
		if (dontqueue) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return TRY_AGAIN_LATER;
		}
		ahc_list_insert_tail(ahc, xs);
		splx(s);
		return SUCCESSFULLY_QUEUED;
a2470 2
	first_xs = ahc_first_xs(ahc);

d2478 1
a2478 1
	if (first_xs != NULL) {
d2492 2
a2493 4
		ahc_list_insert_tail(ahc, xs);
		xs = first_xs;
		next_xs = ahc_list_next(ahc, xs);
		ahc_list_remove(ahc, xs);
a2494 1

d2497 2
a2498 5
get_scb:

	target_id = xs->sc_link->target;
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);

d2500 18
a2517 4
	 * get an scb to use.
	 */
	if ((scb = ahcgetscb(ahc)) == NULL) {

d2526 2
a2527 2
		 * back to where we came from, otherwise tack ourselves
		 * onto the end.
d2529 1
a2529 4
		if (fromqueue && next_xs != NULL)
			ahc_list_insert_before(ahc, xs, next_xs);
		else
			ahc_list_insert_tail(ahc, xs);
d2533 4
d2539 4
a2542 1
	tcl = XS_TCL(ahc, xs);
d2544 1
a2544 5
#ifdef DIAGNOSTIC
	if (ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)
		panic("ahc: queuing for busy target");
#endif
	
d2546 4
a2549 7
	hscb = scb->hscb;
	hscb->tcl = tcl;

	ahc_busy_tcl(ahc, scb);

	splx(s);
 
d2554 7
a2560 14
	mask = SCB_TARGET_MASK(scb);
	tinfo = ahc_fetch_transinfo(ahc, SIM_CHANNEL(ahc, xs->sc_link), our_id,
				    target_id, &tstate);
	if (ahc->inited_targets[target_id] == 0) {
		struct ahc_devinfo devinfo;

		s = splbio();
		ahc_compile_devinfo(&devinfo, our_id, target_id,
		    xs->sc_link->lun, SIM_CHANNEL(ahc, xs->sc_link),
		    ROLE_INITIATOR);
		ahc_update_target_msg_request(ahc, &devinfo, tinfo, TRUE,
		    FALSE);
		ahc->inited_targets[target_id] = 1;
		splx(s);
d2562 7
a2568 14

	hscb->scsirate = tinfo->scsirate;
	hscb->scsioffset = tinfo->current.offset;
	if ((tstate->ultraenb & mask) != 0)
		hscb->control |= ULTRAENB;
		
	if ((tstate->discenable & mask) != 0)
		hscb->control |= DISCENB;

	if (xs->flags & SCSI_RESET) {
		hscb->cmdpointer = NULL;
		scb->flags |= SCB_DEVICE_RESET;
		hscb->control |= MK_MESSAGE;
		return ahc_execute_scb(scb, NULL, 0);
d2570 73
a2642 26

	return ahc_setup_data(ahc, xs, scb);
}

STATIC int
ahc_execute_scb(arg, dm_segs, nsegments)
	void *arg;
	bus_dma_segment_t *dm_segs;
	int nsegments;
{
	struct	 scb *scb;
	struct scsi_xfer *xs;
	struct	 ahc_softc *ahc;
	int	 s;

	scb = (struct scb *)arg;
	xs = scb->xs;
	ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;


	if (nsegments != 0) {
		struct	  ahc_dma_seg *sg;
		bus_dma_segment_t *end_seg;
		bus_dmasync_op_t op;

		end_seg = dm_segs + nsegments;
d2645 10
a2654 10
		scb->hscb->data = dm_segs->ds_addr;
		scb->hscb->datalen = dm_segs->ds_len;

		/* Copy the segments into our SG list */
		sg = scb->sg_list;
		while (dm_segs < end_seg) {
			sg->addr = dm_segs->ds_addr;
			sg->len = dm_segs->ds_len;
			sg++;
			dm_segs++;
d2656 4
a2659 12

		/* Note where to find the SG entries in bus space */
		scb->hscb->SG_pointer = scb->sg_list_phys;
		if ((scb->xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_PREREAD;
		else
			op = BUS_DMASYNC_PREWRITE;
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap, op);
	} else {
		scb->hscb->SG_pointer = 0;
		scb->hscb->data = 0;
		scb->hscb->datalen = 0;
d2661 8
a2668 16
	
	scb->sg_count = scb->hscb->SG_count = nsegments;

	s = splbio();

	/*
	 * Last time we need to check if this SCB needs to
	 * be aborted.
	 */
	if (xs->flags & ITSDONE) {
		ahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);
		if (nsegments != 0)
			bus_dmamap_unload(ahc->sc_dmat, scb->dmamap);
		ahcfreescb(ahc, scb);
		splx(s);
		return (COMPLETE);
d2671 3
a2673 3
#ifdef DIAGNOSTIC
	if (scb->sg_count > 255)
		panic("ahc bad sg_count");
d2675 1
a2675 2
		
	LIST_INSERT_HEAD(&ahc->pending_scbs, scb, pend_links);
d2677 4
a2680 5
	scb->flags |= SCB_ACTIVE;

	if (!(xs->flags & SCSI_POLL))
	timeout(ahc_timeout, (caddr_t)scb, 
		    (xs->timeout * hz) / 1000);
a2681 6
	if ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {
#if 0
		printf("Continueing Immediate Command %d:%d\n",
		       xs->sc_link->target,
		       xs->sc_link->lun);
#endif
d2683 17
a2699 19
		if ((ahc->flags & AHC_PAGESCBS) == 0)
			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
		ahc_outb(ahc, SCB_TAG, scb->hscb->tag);
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
		unpause_sequencer(ahc);
	} else {

		ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;

		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
				BUS_DMASYNC_PREWRITE);
		
		if ((ahc->features & AHC_QUEUE_REGS) != 0) {
			ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
		} else {
			pause_sequencer(ahc);
			ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
			unpause_sequencer(ahc);
		}
d2701 1
a2701 12

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWCMDS) {
		printf("opcode %d tag %x len %d flags %x control %x fpos %u"
		    " rate %x\n",
		    xs->cmdstore.opcode, scb->hscb->tag, scb->hscb->datalen,
		    scb->flags, scb->hscb->control, ahc->qinfifonext,
		    scb->hscb->scsirate);
	}
#endif

	if (!(xs->flags & SCSI_POLL)) {
d2716 2
a2717 2
	} while (!(xs->flags & ITSDONE));
	splx(s);
a2720 10
STATIC int
ahc_poll(ahc, wait)
	struct   ahc_softc *ahc;
	int   wait;	/* in msec */
{
	while (--wait) {
		DELAY(1000);
		if (ahc_inb(ahc, INTSTAT) & INT_PEND)
			break;
	}
d2722 9
a2730 14
	if (wait == 0) {
		printf("%s: board is not responding\n", ahc_name(ahc));
		return (EIO);
	}
		
	ahc_intr((void *)ahc);
	return (0);
}

STATIC int
ahc_setup_data(ahc, xs, scb)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	struct scb *scb;
d2732 2
a2733 30
	struct hardware_scb *hscb;
	
	hscb = scb->hscb;
	xs->resid = xs->status = 0;
	
	hscb->cmdlen = xs->cmdlen;
	bcopy(xs->cmd, hscb->cmdstore, xs->cmdlen);
	hscb->cmdpointer = hscb->cmdstore_busaddr;

	/* Only use S/G if there is a transfer */
	if (xs->datalen) {
		int error;

		error = bus_dmamap_load(ahc->sc_dmat,
			    scb->dmamap, xs->data,
			    xs->datalen, NULL,
			    (xs->flags & SCSI_NOSLEEP) ?
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			ahc_index_busy_tcl(ahc, hscb->tcl, TRUE);
			return (TRY_AGAIN_LATER);	/* XXX fvdl */
		}
		error = ahc_execute_scb(scb,
		    scb->dmamap->dm_segs,
		    scb->dmamap->dm_nsegs);
		return error;
	} else {
		return ahc_execute_scb(scb, NULL, 0);
	}
}
d2735 1
a2735 8
STATIC void
ahc_freeze_devq(ahc, sc_link)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
{
	int	target;
	char	channel;
	int	lun;
d2737 4
a2740 8
	target = sc_link->target;
	lun = sc_link->lun;
	channel = SIM_CHANNEL(ahc, sc_link);
	
	ahc_search_qinfifo(ahc, target, channel, lun,
			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
			   SCB_REQUEUE, SEARCH_COMPLETE);
}
d2742 8
a2749 31
STATIC void
ahcallocscbs(ahc)
	struct ahc_softc *ahc;
{
	struct scb_data *scb_data;
	struct scb *next_scb;
	struct sg_map_node *sg_map;
	bus_addr_t physaddr;
	struct ahc_dma_seg *segs;
	int newcount;
	int i;
	int dma_flags = 0;

	scb_data = ahc->scb_data;
	if (scb_data->numscbs >= AHC_SCB_MAX)
		/* Can't allocate any more */
		return;

	next_scb = &scb_data->scbarray[scb_data->numscbs];

	sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);

	if (sg_map == NULL)
		return;
	bzero(sg_map, sizeof(struct sg_map_node));
	
	if (ahc_createdmamem(ahc, PAGE_SIZE, &sg_map->sg_dmamap,
	    (caddr_t *)&sg_map->sg_vaddr, &sg_map->sg_physaddr,
	    &sg_map->sg_dmasegs, &sg_map->sg_nseg, "SG space") < 0) {
		free(sg_map, M_DEVBUF);
		return;
d2751 26
a2776 69
	
	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);

	segs = sg_map->sg_vaddr;
	physaddr = sg_map->sg_physaddr;

	newcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));

	for (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {
		int error;

		next_scb->sg_list = segs;
		/*
		 * The sequencer always starts with the second entry.
		 * The first entry is embedded in the scb.
		 */
		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
		next_scb->flags = SCB_FREE;
		
		/* set up AHA-284x right. */
		dma_flags = ((ahc->chip & AHC_VL) !=0) ? 
			BUS_DMA_NOWAIT|ISABUS_DMA_32BIT :
			BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW;
		
		error = bus_dmamap_create(ahc->sc_dmat,
				 AHC_MAXTRANSFER_SIZE, AHC_NSEG, MAXBSIZE, 0,
				 dma_flags, &next_scb->dmamap);
		if (error !=0) 
			break;

		next_scb->hscb = &scb_data->hscbs[scb_data->numscbs];
		next_scb->hscb->tag = ahc->scb_data->numscbs;
		next_scb->hscb->cmdstore_busaddr = 
			ahc_hscb_busaddr(ahc, next_scb->hscb->tag) + 
			offsetof(struct hardware_scb, cmdstore);	
		SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, next_scb, links);
		segs += AHC_NSEG;
		physaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));
		next_scb++;
		ahc->scb_data->numscbs++;
	}
}

#ifdef AHC_DUMP_SEQ
STATIC void
ahc_dumpseq(ahc)
	struct ahc_softc* ahc;
{
	int i;
	int max_prog;

	if ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)
		max_prog = 448;
	else if ((ahc->features & AHC_ULTRA2) != 0)
		max_prog = 768;
	else
		max_prog = 512;

	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	for (i = 0; i < max_prog; i++) {
		u_int8_t ins_bytes[4];

		ahc_insb(ahc, SEQRAM, ins_bytes, 4);
		printf("0x%08x\n", ins_bytes[0] << 24
				 | ins_bytes[1] << 16
				 | ins_bytes[2] << 8
				 | ins_bytes[3]);
d2778 3
a2780 28
}
#endif

STATIC void
ahc_loadseq(ahc)
	struct ahc_softc* ahc;
{
	struct patch *cur_patch;
	int i;
	int downloaded;
	int skip_addr;
	u_int8_t download_consts[4];

	/* Setup downloadable constant table */
#if 0
	/* No downloaded constants are currently defined. */
	download_consts[TMODE_NUMCMDS] = ahc->num_targetcmds;
#endif

	cur_patch = patches;
	downloaded = 0;
	skip_addr = 0;
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);

	for (i = 0; i < sizeof(seqprog)/4; i++) {
		if (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {
d2782 2
a2783 2
			 * Don't download this instruction as it
			 * is in a patch that was removed.
d2785 1
a2785 4
                        continue;
		}
		ahc_download_instr(ahc, i, download_consts);
		downloaded++;
d2787 4
a2790 5
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);
	restart_sequencer(ahc);

	if (bootverbose)
		printf(" %d instructions downloaded\n", downloaded);
d2793 10
a2802 6
STATIC int
ahc_check_patch(ahc, start_patch, start_instr,skip_addr)
	struct ahc_softc *ahc;
	struct patch **start_patch;
	int start_instr;
	int *skip_addr;
d2804 2
a2805 3
	struct	patch *cur_patch;
	struct	patch *last_patch;
	int	num_patches;
d2807 32
a2838 81
	num_patches = sizeof(patches)/sizeof(struct patch);
	last_patch = &patches[num_patches];
	cur_patch = *start_patch;

	while (cur_patch < last_patch && start_instr == cur_patch->begin) {

		if (cur_patch->patch_func(ahc) == 0) {

			/* Start rejecting code */
			*skip_addr = start_instr + cur_patch->skip_instr;
			cur_patch += cur_patch->skip_patch;
		} else {
			/* Accepted this patch.  Advance to the next
			 * one and wait for our intruction pointer to
			 * hit this point.
			 */
			cur_patch++;
		}
	}

	*start_patch = cur_patch;
	if (start_instr < *skip_addr)
		/* Still skipping */
		return (0);

	return (1);
}

STATIC void
ahc_download_instr(ahc, instrptr, dconsts)
	struct ahc_softc *ahc;
	int instrptr;
	u_int8_t *dconsts;
{
	union	ins_formats instr;
	struct	ins_format1 *fmt1_ins;
	struct	ins_format3 *fmt3_ins;
	u_int	opcode;

	/* Structure copy */
	instr = *(union ins_formats*)&seqprog[instrptr * 4];

	fmt1_ins = &instr.format1;
	fmt3_ins = NULL;

	/* Pull the opcode */
	opcode = instr.format1.opcode;
	switch (opcode) {
	case AIC_OP_JMP:
	case AIC_OP_JC:
	case AIC_OP_JNC:
	case AIC_OP_CALL:
	case AIC_OP_JNE:
	case AIC_OP_JNZ:
	case AIC_OP_JE:
	case AIC_OP_JZ:
	{
		struct patch *cur_patch;
		int address_offset;
		u_int address;
		int skip_addr;
		int i;

		fmt3_ins = &instr.format3;
		address_offset = 0;
		address = fmt3_ins->address;
		cur_patch = patches;
		skip_addr = 0;

		for (i = 0; i < address;) {

			ahc_check_patch(ahc, &cur_patch, i, &skip_addr);

			if (skip_addr > i) {
				int end_addr;

				end_addr = MIN(address, skip_addr);
				address_offset += end_addr - i;
				i = skip_addr;
			} else {
				i++;
d2841 5
a2845 44
		address -= address_offset;
		fmt3_ins->address = address;
		/* FALLTHROUGH */
	}
	case AIC_OP_OR:
	case AIC_OP_AND:
	case AIC_OP_XOR:
	case AIC_OP_ADD:
	case AIC_OP_ADC:
	case AIC_OP_BMOV:
		if (fmt1_ins->parity != 0) {
			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
		}
		fmt1_ins->parity = 0;
		/* FALLTHROUGH */
	case AIC_OP_ROL:
		if ((ahc->features & AHC_ULTRA2) != 0) {
			int i, count;

			/* Calculate odd parity for the instruction */
			for (i = 0, count = 0; i < 31; i++) {
				u_int32_t mask;

				mask = 0x01 << i;
				if ((instr.integer & mask) != 0)
					count++;
			}
			if ((count & 0x01) == 0)
				instr.format1.parity = 1;
		} else {
			/* Compress the instruction for older sequencers */
			if (fmt3_ins != NULL) {
				instr.integer =
					fmt3_ins->immediate
				      | (fmt3_ins->source << 8)
				      | (fmt3_ins->address << 16)
				      |	(fmt3_ins->opcode << 25);
			} else {
				instr.integer =
					fmt1_ins->immediate
				      | (fmt1_ins->source << 8)
				      | (fmt1_ins->destination << 16)
				      |	(fmt1_ins->ret << 24)
				      |	(fmt1_ins->opcode << 25);
a2847 4
		ahc_outsb(ahc, SEQRAM, instr.bytes, 4);
		break;
	default:
		panic("Unknown opcode encountered in seq program");
d2850 13
d2865 2
a2866 4
STATIC void
ahc_set_recoveryscb(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
d2868 8
d2877 1
a2877 2
	if ((scb->flags & SCB_RECOVERY_SCB) == 0) {
		struct scb *scbp;
d2879 1
a2879 1
		scb->flags |= SCB_RECOVERY_SCB;
d2881 5
a2885 6
		/*
		 * Take all queued, but not sent SCBs out of the equation.
		 * Also ensure that no new CCBs are queued to us while we
		 * try to fix this problem.
		 */
		ahc->queue_blocked = 1;
d2887 16
a2902 10
		/*
		 * Go through all of our pending SCBs and remove
		 * any scheduled timeouts for them.  We will reschedule
		 * them after we've successfully fixed this problem.
		 */
		scbp = ahc->pending_scbs.lh_first;
		while (scbp != NULL) {
			untimeout(ahc_timeout, scbp);
			scbp = scbp->pend_links.le_next;
		}
d2904 2
d2908 3
a2910 2
STATIC void
ahc_timeout(void *arg)
d2912 2
a2913 2
	struct	scb *scb;
	struct	ahc_softc *ahc;
d2915 1
a2915 4
	u_int	last_phase;
	int	target;
	int	lun;
	int	i;
a2917 3
	scb = (struct scb *)arg; 
	ahc = (struct ahc_softc *)scb->xs->sc_link->adapter_softc;

d2920 1
a2920 12
	/*
	 * Ensure that the card doesn't do anything
	 * behind our back.  Also make sure that we
	 * didn't "just" miss an interrupt that would
	 * affect this timeout.
	 */
	do {
		ahc_intr(ahc);
		pause_sequencer(ahc);
	} while (ahc_inb(ahc, INTSTAT) & INT_PEND);

	if ((scb->flags & SCB_ACTIVE) == 0) {
a2921 2
		printf("Timedout SCB handled by another timeout\n");
		unpause_sequencer(ahc);
d2926 38
a2963 3
	target = SCB_TARGET(scb);
	channel = SCB_CHANNEL(scb);
	lun = SCB_LUN(scb);
d2966 1
a2966 1
	printf("SCB 0x%x - timed out ", scb->hscb->tag);
d2970 31
a3000 5
	 */
	last_phase = ahc_inb(ahc, LASTPHASE);

	for (i = 0; i < num_phases; i++) {
		if (last_phase == phase_table[i].phase)
d3003 7
a3009 34
	printf("%s", phase_table[i].phasemsg);
  
	printf(", SEQADDR == 0x%x\n",
	       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
#if 0
	printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1));
	printf("SSTAT3 == 0x%x\n", ahc_inb(ahc, SSTAT3));
	printf("SCSIPHASE == 0x%x\n", ahc_inb(ahc, SCSIPHASE));
	printf("SCSIRATE == 0x%x\n", ahc_inb(ahc, SCSIRATE));
	printf("SCSIOFFSET == 0x%x\n", ahc_inb(ahc, SCSIOFFSET));
	printf("SEQ_FLAGS == 0x%x\n", ahc_inb(ahc, SEQ_FLAGS));
	printf("SCB_DATAPTR == 0x%x\n", ahc_inb(ahc, SCB_DATAPTR)
				      | ahc_inb(ahc, SCB_DATAPTR + 1) << 8
				      | ahc_inb(ahc, SCB_DATAPTR + 2) << 16
				      | ahc_inb(ahc, SCB_DATAPTR + 3) << 24);
	printf("SCB_DATACNT == 0x%x\n", ahc_inb(ahc, SCB_DATACNT)
				      | ahc_inb(ahc, SCB_DATACNT + 1) << 8
				      | ahc_inb(ahc, SCB_DATACNT + 2) << 16);
	printf("SCB_SGCOUNT == 0x%x\n", ahc_inb(ahc, SCB_SGCOUNT));
	printf("CCSCBCTL == 0x%x\n", ahc_inb(ahc, CCSCBCTL));
	printf("CCSCBCNT == 0x%x\n", ahc_inb(ahc, CCSCBCNT));
	printf("DFCNTRL == 0x%x\n", ahc_inb(ahc, DFCNTRL));
	printf("DFSTATUS == 0x%x\n", ahc_inb(ahc, DFSTATUS));
	printf("CCHCNT == 0x%x\n", ahc_inb(ahc, CCHCNT));
	if (scb->sg_count > 0) {
		for (i = 0; i < scb->sg_count; i++) {
			printf("sg[%d] - Addr 0x%x : Length %d\n",
			       i,
			       scb->sg_list[i].addr,
			       scb->sg_list[i].len);
		}
	}
#endif
	if (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {
d3014 5
a3018 4
bus_reset:
		ahcsetccbstatus(scb->xs, XS_TIMEOUT);
		found = ahc_reset_channel(ahc, channel, /*Initiate Reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
d3020 16
a3035 1
	} else {
d3037 2
a3038 4
		 * If we are a target, transition to bus free and report
		 * the timeout.
		 * 
		 * The target/initiator that is holding up the bus may not
d3041 10
a3050 10
		 * If the bus is idle and we are actiing as the initiator
		 * for this request, queue a BDR message to the timed out
		 * target.  Otherwise, if the timed out transaction is
		 * active:
		 *   Initiator transaction:
		 *	Stuff the message buffer with a BDR message and assert
		 *	ATN in the hopes that the target will let go of the bus
		 *	and go to the mesgout phase.  If this fails, we'll
		 *	get another timeout 2 seconds later which will attempt
		 *	a bus reset.
d3052 13
a3064 5
		 *   Target transaction:
		 *	Transition to BUS FREE and report the error.
		 *	It's good to be the target!
		 */
		u_int active_scb_index;
d3066 25
a3090 106
		active_scb_index = ahc_inb(ahc, SCB_TAG);

		if (last_phase != P_BUSFREE 
		  && (active_scb_index < ahc->scb_data->numscbs)) {
			struct scb *active_scb;

			/*
			 * If the active SCB is not from our device,
			 * assume that another device is hogging the bus
			 * and wait for it's timeout to expire before
			 * taking additional action.
			 */ 
			active_scb = &ahc->scb_data->scbarray[active_scb_index];
			if (active_scb->hscb->tcl != scb->hscb->tcl) {
				u_int	newtimeout;

				sc_print_addr(scb->xs->sc_link);
				printf("Other SCB Timeout%s",
			 	       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
				       ? " again\n" : "\n");
				scb->flags |= SCB_OTHERTCL_TIMEOUT;
				newtimeout = MAX(active_scb->xs->timeout,
						 scb->xs->timeout);
				timeout(ahc_timeout, scb,
					    (newtimeout * hz) / 1000);
				splx(s);
				return;
			} 

			/* It's us */
			if ((scb->hscb->control & TARGET_SCB) != 0) {

				/*
				 * Send back any queued up transactions
				 * and properly record the error condition.
				 */
				ahc_freeze_devq(ahc, scb->xs->sc_link);
				ahcsetccbstatus(scb->xs, XS_TIMEOUT);
				ahc_freeze_ccb(scb);
				ahc_done(ahc, scb);

				/* Will clear us from the bus */
				restart_sequencer(ahc);
				return;
			} 

			ahc_set_recoveryscb(ahc, active_scb);
			ahc_outb(ahc, MSG_OUT, MSG_BUS_DEV_RESET);
			ahc_outb(ahc, SCSISIGO, last_phase|ATNO);
			sc_print_addr(active_scb->xs->sc_link);
			printf("BDR message in message buffer\n");
			active_scb->flags |=  SCB_DEVICE_RESET;
			    timeout(ahc_timeout, (caddr_t)active_scb, 2 * hz);
		} else {
			int	 disconnected;

			/* XXX Shouldn't panic.  Just punt instead */
			if ((scb->hscb->control & TARGET_SCB) != 0)
				panic("Timed-out target SCB but bus idle");

			if (last_phase != P_BUSFREE
			 && (ahc_inb(ahc, SSTAT0) & TARGET) != 0) {
				/* XXX What happened to the SCB? */
				/* Hung target selection.  Goto busfree */
				printf("%s: Hung target selection\n",
				       ahc_name(ahc));
				restart_sequencer(ahc);
				return;
			}

			if (ahc_search_qinfifo(ahc, target, channel, lun,
					       scb->hscb->tag, ROLE_INITIATOR,
					       /*status*/0, SEARCH_COUNT) > 0) {
				disconnected = FALSE;
			} else {
				disconnected = TRUE;
			}

			if (disconnected) {
				u_int active_scb;

				ahc_set_recoveryscb(ahc, scb);
				/*
				 * Simply set the MK_MESSAGE control bit.
				 */
				scb->hscb->control |= MK_MESSAGE;
				scb->flags |= SCB_QUEUED_MSG
					   |  SCB_DEVICE_RESET;

				/*
				 * Mark the cached copy of this SCB in the
				 * disconnected list too, so that a reconnect
				 * at this point causes a BDR or abort.
				 */
				active_scb = ahc_inb(ahc, SCBPTR);
				if (ahc_search_disc_list(ahc, target,
							 channel, lun,
							 scb->hscb->tag,
							 /*stop_on_first*/TRUE,
							 /*remove*/FALSE,
							 /*save_state*/FALSE)) {
					u_int scb_control;

					scb_control = ahc_inb(ahc, SCB_CONTROL);
					scb_control |= MK_MESSAGE;
					ahc_outb(ahc, SCB_CONTROL, scb_control);
d3092 11
a3102 17
				ahc_outb(ahc, SCBPTR, active_scb);
				ahc_index_busy_tcl(ahc, scb->hscb->tcl,
						   /*unbusy*/TRUE);

				/*
				 * Actually re-queue this SCB in case we can
				 * select the device before it reconnects.
				 * Clear out any entries in the QINFIFO first
				 * so we are the next SCB for this target
				 * to run.
				 */
				ahc_search_qinfifo(ahc, SCB_TARGET(scb),
						   channel, SCB_LUN(scb),
						   SCB_LIST_NULL,
						   ROLE_INITIATOR,
						   SCB_REQUEUE,
						   SEARCH_COMPLETE);
d3104 21
a3124 9
				printf("Queuing a BDR SCB\n");
				ahc->qinfifo[ahc->qinfifonext++] =
				    scb->hscb->tag;
				if ((ahc->features & AHC_QUEUE_REGS) != 0) {
					ahc_outb(ahc, HNSCB_QOFF,
						 ahc->qinfifonext);
				} else {
					ahc_outb(ahc, KERNEL_QINPOS,
						 ahc->qinfifonext);
d3126 5
a3130 11
				timeout(ahc_timeout, (caddr_t)scb, 2 * hz);
				unpause_sequencer(ahc);
			} else {
				/* Go "immediatly" to the bus reset */
				/* This shouldn't happen */
				ahc_set_recoveryscb(ahc, scb);
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d: Immediate reset.  "
					"Flags = 0x%x\n", scb->hscb->tag,
					scb->flags);
				goto bus_reset;
d3133 12
d3146 1
d3150 8
a3157 3
STATIC int
ahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)
	struct ahc_softc *ahc;
d3160 2
a3161 5
	int lun;
	u_int tag;
	role_t role;
	u_int32_t status;
	ahc_search_action action;
d3163 7
a3169 8
	struct	 scb *scbp;
	u_int8_t qinpos;
	u_int8_t qintail;
	int	 found;

	qinpos = ahc_inb(ahc, QINPOS);
	qintail = ahc->qinfifonext;
	found = 0;
d3172 1
a3172 2
	 * Start with an empty queue.  Entries that are not chosen
	 * for removal will be re-added to the queue as we go.
d3174 19
a3192 25
	ahc->qinfifonext = qinpos;
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
			BUS_DMASYNC_POSTREAD);

	while (qinpos != qintail) {
		scbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];
		if (ahc_match_scb(scbp, target, channel, lun, tag, role)) {
			/*
			 * We found an scb that needs to be removed.
			 */
			switch (action) {
			case SEARCH_COMPLETE:
				if (!(scbp->xs->flags & ITSDONE)) {
					scbp->flags |= status;
					scbp->xs->error = XS_NOERROR;
				}
				ahc_freeze_ccb(scbp);
				ahc_done(ahc, scbp);
				break;
			case SEARCH_COUNT:
				ahc->qinfifo[ahc->qinfifonext++] =
				    scbp->hscb->tag;
				break;
			case SEARCH_REMOVE:
				break;
a3193 3
			found++;
		} else {
			ahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;
d3195 4
a3198 1
		qinpos++;
a3199 38
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
			BUS_DMASYNC_PREWRITE);
	
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}

	return (found);
}

/*
 * Abort all SCBs that match the given description (target/channel/lun/tag),
 * setting their status to the passed in status if the status has not already
 * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
 * is paused before it is called.
 */
STATIC int
ahc_abort_scbs(ahc, target, channel, lun, tag, role, status)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	role_t role;
	u_int32_t status;
{
	struct	scb *scbp;
	u_int	active_scb;
	int	i;
	int	found;

	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);

	found = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,
				   role, SCB_REQUEUE, SEARCH_COMPLETE);
d3205 3
a3207 3
		u_int8_t next, prev;
                /* Start at head of list. */
		next = ahc_inb(ahc, WAITING_SCBH);
d3211 9
a3219 8
			u_int8_t scb_index;

			ahc_outb(ahc, SCBPTR, next);
			scb_index = ahc_inb(ahc, SCB_TAG);
			if (scb_index >= ahc->scb_data->numscbs) {
				panic("Waiting List inconsistency. "
				      "SCB index == %d, yet numscbs == %d.",
				      scb_index, ahc->scb_data->numscbs);
d3221 1
a3221 7
			scbp = &ahc->scb_data->scbarray[scb_index];
			if (ahc_match_scb(scbp, target, channel,
					  lun, SCB_LIST_NULL, role)) {

				next = ahc_abort_wscb(ahc, next, prev);
			} else {
				
d3223 1
a3223 1
				next = ahc_inb(ahc, SCB_NEXT);
d3228 4
a3231 4
	 * Go through the disconnected list and remove any entries we
	 * have queued for completion, 0'ing their control byte too.
	 * We save the active SCB and restore it ourselves, so there
	 * is no reason for this search to restore it too.
d3233 10
a3242 39
	ahc_search_disc_list(ahc, target, channel, lun, tag,
			     /*stop_on_first*/FALSE, /*remove*/TRUE,
			     /*save_state*/FALSE);

	/*
	 * Go through the hardware SCB array looking for commands that
	 * were active but not on any list.
	 */
	for(i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scbid;

		ahc_outb(ahc, SCBPTR, i);
		scbid = ahc_inb(ahc, SCB_TAG);
		scbp = &ahc->scb_data->scbarray[scbid];
		if (scbid < ahc->scb_data->numscbs && 
			 ahc_match_scb(scbp, target, channel, lun, tag, role))
				ahc_add_curscb_to_free_list(ahc);
	}

	/*
	 * Go through the pending CCB list and look for
	 * commands for this target that are still active.
	 * These are other tagged commands that were
	 * disconnected when the reset occured.
	 */
	{
		struct scb *scb;

		scb = ahc->pending_scbs.lh_first;
		while (scb != NULL) {
			scbp = scb;
			scb = scb->pend_links.le_next;
			if (ahc_match_scb(scbp, target, channel,
					  lun, tag, role)) {
				if (!(scbp->xs->flags & ITSDONE))
					ahcsetccbstatus(scbp->xs, status);
				ahc_freeze_ccb(scbp);
				ahc_done(ahc, scbp);
				found++;
d3244 5
d3250 2
a3251 2
	}
	ahc_outb(ahc, SCBPTR, active_scb);
a3254 97
STATIC int
ahc_search_disc_list(ahc, target, channel, lun, tag, stop_on_first, 
		     remove, save_state)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	int stop_on_first;
	int remove;
	int save_state;
{
	struct	scb *scbp;
	u_int	next;
	u_int	prev;
	u_int	count;
	u_int	active_scb;

	count = 0;
	next = ahc_inb(ahc, DISCONNECTED_SCBH);
	prev = SCB_LIST_NULL;

	if (save_state) {
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
	} else
		/* Silence compiler */
		active_scb = SCB_LIST_NULL;

	while (next != SCB_LIST_NULL) {
		u_int scb_index;

		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			panic("Disconnected List inconsistency. "
			      "SCB index == %d, yet numscbs == %d.",
			      scb_index, ahc->scb_data->numscbs);
		}
		scbp = &ahc->scb_data->scbarray[scb_index];
		if (ahc_match_scb(scbp, target, channel, lun,
				  tag, ROLE_INITIATOR)) {
			count++;
			if (remove) {
				next =
				    ahc_rem_scb_from_disc_list(ahc, prev, next);
			} else {
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
			}
			if (stop_on_first)
				break;
		} else {
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
		}
	}
	if (save_state)
	ahc_outb(ahc, SCBPTR, active_scb);
	return (count);
}

STATIC u_int
ahc_rem_scb_from_disc_list(ahc, prev, scbptr)
	struct ahc_softc *ahc;
	u_int prev;
	u_int scbptr;
{
	u_int next;

	ahc_outb(ahc, SCBPTR, scbptr);
	next = ahc_inb(ahc, SCB_NEXT);

	ahc_outb(ahc, SCB_CONTROL, 0);

	ahc_add_curscb_to_free_list(ahc);

	if (prev != SCB_LIST_NULL) {
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	} else
		ahc_outb(ahc, DISCONNECTED_SCBH, next);

	return (next);
}

STATIC void
ahc_add_curscb_to_free_list(ahc)
	struct ahc_softc *ahc;
{
	/* Invalidate the tag so that ahc_find_scb doesn't think it's active */
	ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);

	ahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));
	ahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));
}

d3259 7
a3265 5
STATIC u_int
ahc_abort_wscb(ahc, scbpos, prev)
	struct ahc_softc *ahc;
	u_int scbpos;
        u_int prev;
d3267 3
a3269 2
	u_int curscb, next;

d3274 3
a3276 3
	curscb = ahc_inb(ahc, SCBPTR);
	ahc_outb(ahc, SCBPTR, scbpos);
	next = ahc_inb(ahc, SCB_NEXT);
d3279 3
a3281 3
	ahc_outb(ahc, SCB_CONTROL, 0);

	ahc_add_curscb_to_free_list(ahc);
d3284 1
a3284 1
	if (prev == SCB_LIST_NULL) {
d3286 2
a3287 8
		ahc_outb(ahc, WAITING_SCBH, next); 

		/*
		 * Ensure we aren't attempting to perform
		 * selection for this entry.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else {
d3292 2
a3293 2
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
a3294 1

d3296 9
a3304 3
	 * Point us back at the original scb position.
	 */
	ahc_outb(ahc, SCBPTR, curscb);
d3308 5
a3312 3
STATIC void
ahc_clear_intstat(ahc)
	struct ahc_softc *ahc;
d3314 14
a3327 6
	/* Clear any interrupt conditions this may have caused */
	ahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);
	ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
				|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|
				CLRREQINIT);
	ahc_outb(ahc, CLRINT, CLRSCSIINT);
d3330 5
a3334 3
STATIC void
ahc_reset_current_bus(ahc)
	struct ahc_softc *ahc;
d3336 2
a3337 1
	u_int8_t scsiseq;
d3339 11
a3349 11
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);
	scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);
	DELAY(AHC_BUSRESET_DELAY);
	/* Turn off the bus reset */
	ahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);

	ahc_clear_intstat(ahc);

	/* Re-enable reset interrupts */
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);
d3352 3
a3354 5
STATIC int
ahc_reset_channel(ahc, channel, initiate_reset)
	struct ahc_softc *ahc;
	char channel;
	int initiate_reset;
d3356 17
a3372 10
	u_int	initiator, target, max_scsiid;
	u_int	sblkctl;
	u_int	our_id;
	int	found;
	int	restart_needed;
	char	cur_channel;

	ahc->pending_device = NULL;

	pause_sequencer(ahc);
d3375 2
a3376 3
	 * Run our command complete fifos to ensure that we perform
	 * completion processing on any commands that 'completed'
	 * before the reset occurred.
d3378 37
a3414 1
	ahc_run_qoutfifo(ahc);
d3417 11
a3427 11
	 * Reset the bus if we are initiating this reset
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	cur_channel = 'A';
	if ((ahc->features & AHC_TWIN) != 0
	 && ((sblkctl & SELBUSB) != 0))
	    cur_channel = 'B';
	if (cur_channel != channel) {
		/* Case 1: Command for another bus is active
		 * Stealthily reset the other bus without
		 * upsetting the current bus.
d3429 3
a3431 5
		ahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (initiate_reset)
d3433 10
a3442 10
		ahc_clear_intstat(ahc);
		ahc_outb(ahc, SBLKCTL, sblkctl);
		restart_needed = FALSE;
	} else {
		/* Case 2: A command from this bus is active or we're idle */
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (initiate_reset)
a3443 53
		ahc_clear_intstat(ahc);

		/*
		 * Since we are going to restart the sequencer, avoid
		 * a race in the sequencer that could cause corruption
		 * of our Q pointers by starting over from index 0.
		 */
		ahc->qoutfifonext = 0;
		if ((ahc->features & AHC_QUEUE_REGS) != 0)
			ahc_outb(ahc, SDSCB_QOFF, 0);
		else
			ahc_outb(ahc, QOUTPOS, 0);
		restart_needed = TRUE;
	}

	/*
	 * Clean up all the state information for the
	 * pending transactions on this bus.
	 */
	found = ahc_abort_scbs(ahc, ALL_TARGETS, channel,
			       ALL_LUNS, SCB_LIST_NULL,
			       ROLE_UNKNOWN, XS_RESET);
	if (channel == 'B') {
		our_id = ahc->our_id_b;
	} else {
		our_id = ahc->our_id;
	}

	max_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;
	
	/*
	 * Revert to async/narrow transfers until we renegotiate.
	 */
	for (target = 0; target <= max_scsiid; target++) {

		if (ahc->enabled_targets[target] == NULL)
			continue;
		for (initiator = 0; initiator <= max_scsiid; initiator++) {
			struct ahc_devinfo devinfo;

			ahc_compile_devinfo(&devinfo, target, initiator,
					    ALL_LUNS,
					    channel, ROLE_UNKNOWN);
			ahc_set_width(ahc, &devinfo,
				      MSG_EXT_WDTR_BUS_8_BIT,
				      AHC_TRANS_CUR,
				      /*paused*/TRUE,
				      /*done*/FALSE);
			ahc_set_syncrate(ahc, &devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, AHC_TRANS_CUR,
					 /*paused*/TRUE,
					 /*done*/FALSE);
d3445 3
d3449 1
a3449 5

	if (restart_needed)
		restart_sequencer(ahc);
	else
		unpause_sequencer(ahc);
d3453 3
a3455 8
STATIC int
ahc_match_scb(scb, target, channel, lun, role, tag)
	struct scb *scb;
	int target;
	char channel;
	int lun;
	role_t role;
	u_int tag;
d3457 7
a3463 79
	int targ = SCB_TARGET(scb);
	char chan = SCB_CHANNEL(scb);
	int slun = SCB_LUN(scb);
	int match;

	match = ((chan == channel) || (channel == ALL_CHANNELS));
	if (match != 0)
		match = ((targ == target) || (target == ALL_TARGETS));
	if (match != 0)
		match = ((lun == slun) || (lun == ALL_LUNS));
	return match;
}

STATIC void
ahc_construct_sdtr(ahc, period, offset)
	struct ahc_softc *ahc;
	u_int period;
	u_int offset;
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_len += 5;
}

STATIC void
ahc_construct_wdtr(ahc, bus_width)
	struct ahc_softc *ahc;
	u_int bus_width;
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_len += 4;
}

STATIC void
ahc_calc_residual(scb)
	struct scb *scb;
{
	struct	hardware_scb *hscb;

	hscb = scb->hscb;

	/*
	 * If the disconnected flag is still set, this is bogus
	 * residual information left over from a sequencer
	 * pagin/pageout, so ignore this case.
	 */
	if ((scb->hscb->control & DISCONNECTED) == 0) {
		u_int32_t resid;
		int	  resid_sgs;
		int	  sg;
		
		/*
		 * Remainder of the SG where the transfer
		 * stopped.
		 */
		resid = (hscb->residual_data_count[2] << 16)
		      |	(hscb->residual_data_count[1] <<8)
		      |	(hscb->residual_data_count[0]);

		/*
		 * Add up the contents of all residual
		 * SG segments that are after the SG where
		 * the transfer stopped.
		 */
		resid_sgs = scb->hscb->residual_SG_count - 1/*current*/;
		sg = scb->sg_count - resid_sgs;
		while (resid_sgs > 0) {

			resid += scb->sg_list[sg].len;
			sg++;
			resid_sgs--;
		}
		scb->xs->resid = resid;
a3464 13

	/*
	 * Clean out the residual information in this SCB for its
	 * next consumer.
	 */
	hscb->residual_SG_count = 0;

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC) {
		sc_print_addr(scb->xs->sc_link);
		printf("Handled Residual of %ld bytes\n" ,scb->xs->resid);
	}
#endif
d3466 6
a3471 4

STATIC void
ahc_update_pending_syncrates(ahc)
	struct ahc_softc *ahc;
d3473 2
a3474 4
	struct	scb *scb;
	int	pending_scb_count;
	int	i;
	u_int	saved_scbptr;
d3476 4
a3479 80
	/*
	 * Traverse the pending SCB list and ensure that all of the
	 * SCBs there have the proper settings.
	 */
	scb = LIST_FIRST(&ahc->pending_scbs);
	pending_scb_count = 0;
	while (scb != NULL) {
		struct ahc_devinfo devinfo;
		struct scsi_xfer *xs;
		struct scb *pending_scb;
		struct hardware_scb *pending_hscb;
		struct ahc_initiator_tinfo *tinfo;
		struct tmode_tstate *tstate;
		u_int  our_id, remote_id;
		
		xs = scb->xs;
		pending_scb = scb;
		pending_hscb = pending_scb->hscb;
		our_id = SCB_IS_SCSIBUS_B(pending_scb)
		       ? ahc->our_id_b : ahc->our_id;
		remote_id = xs->sc_link->target;
		ahc_compile_devinfo(&devinfo, our_id, remote_id,
				    SCB_LUN(pending_scb),
				    SCB_CHANNEL(pending_scb),
				    ROLE_UNKNOWN);
		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
					    our_id, remote_id, &tstate);
		pending_hscb->control &= ~ULTRAENB;
		if ((tstate->ultraenb & devinfo.target_mask) != 0)
			pending_hscb->control |= ULTRAENB;
		pending_hscb->scsirate = tinfo->scsirate;
		pending_hscb->scsioffset = tinfo->current.offset;
		pending_scb_count++;
		scb = LIST_NEXT(scb, pend_links);
	}

	if (pending_scb_count == 0)
		return;

	saved_scbptr = ahc_inb(ahc, SCBPTR);
	/* Ensure that the hscbs down on the card match the new information */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scb_tag;

		ahc_outb(ahc, SCBPTR, i);
		scb_tag = ahc_inb(ahc, SCB_TAG);
		if (scb_tag != SCB_LIST_NULL) {
			struct	ahc_devinfo devinfo;
			struct	scb *pending_scb;
			struct scsi_xfer *xs;
			struct	hardware_scb *pending_hscb;
			struct	ahc_initiator_tinfo *tinfo;
			struct	tmode_tstate *tstate;
			u_int	our_id, remote_id;
			u_int	control;

			pending_scb = &ahc->scb_data->scbarray[scb_tag];
			if (pending_scb->flags == SCB_FREE)
				continue;
			pending_hscb = pending_scb->hscb;
			xs = pending_scb->xs;
			our_id = SCB_IS_SCSIBUS_B(pending_scb)
			       ? ahc->our_id_b : ahc->our_id;
			remote_id = xs->sc_link->target;
			ahc_compile_devinfo(&devinfo, our_id, remote_id,
					    SCB_LUN(pending_scb),
					    SCB_CHANNEL(pending_scb),
					    ROLE_UNKNOWN);
			tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
						    our_id, remote_id, &tstate);
			control = ahc_inb(ahc, SCB_CONTROL);
			control &= ~ULTRAENB;
			if ((tstate->ultraenb & devinfo.target_mask) != 0)
				control |= ULTRAENB;
			ahc_outb(ahc, SCB_CONTROL, control);
			ahc_outb(ahc, SCB_SCSIRATE, tinfo->scsirate);
			ahc_outb(ahc, SCB_SCSIOFFSET, tinfo->current.offset);
		}
	}
	ahc_outb(ahc, SCBPTR, saved_scbptr);
a3481 45
STATIC void
ahc_shutdown(void *arg)
{
	struct	ahc_softc *ahc;
	int	i;
	u_int	sxfrctl1_a, sxfrctl1_b;

	ahc = (struct ahc_softc *)arg;

	pause_sequencer(ahc);

	/*
	 * Preserve the value of the SXFRCTL1 register for all channels.
	 * It contains settings that affect termination and we don't want
	 * to disturb the integrity of the bus during shutdown in case
	 * we are in a multi-initiator setup.
	 */
	sxfrctl1_b = 0;
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;

		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		sxfrctl1_b = ahc_inb(ahc, SXFRCTL1);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}

	sxfrctl1_a = ahc_inb(ahc, SXFRCTL1);

	/* This will reset most registers to 0, but not all */
	ahc_reset(ahc);

	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;

		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		ahc_outb(ahc, SXFRCTL1, sxfrctl1_b);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	ahc_outb(ahc, SXFRCTL1, sxfrctl1_a);

	ahc_outb(ahc, SCSISEQ, 0);
	ahc_outb(ahc, SXFRCTL0, 0);
	ahc_outb(ahc, DSPCISTATUS, 0);
d3483 26
a3508 2
	for (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)
		ahc_outb(ahc, i, 0);
@


1.18.6.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.26 2001/04/06 04:42:06 csapuntz Exp $
d94 4
d129 1
a129 4

#ifndef le32toh
#define le32toh	letoh32  /* to match Free/Net macros */
#endif
a325 5
STATIC int      ahc_istagged_device __P((struct ahc_softc *ahc,
					 struct scsi_xfer *xs,
					 int nocmdcheck));
STATIC void     ahc_check_tags __P((struct ahc_softc *ahc,
				    struct scsi_xfer *xs));
d380 1
a381 2
static __inline void ahc_swap_hscb __P((struct hardware_scb *));
static __inline void ahc_swap_sg __P((struct ahc_dma_seg *));
a403 19
static __inline void
ahc_swap_hscb(struct hardware_scb *hscb)
{
	hscb->SG_pointer = htole32(hscb->SG_pointer);
	hscb->data = htole32(hscb->data);
	hscb->datalen = htole32(hscb->datalen);
	/*
	 * No need to swap cmdpointer; it's either 0 or set to
	 * cmdstore_busaddr, which is already swapped.
	 */
}

static __inline void
ahc_swap_sg(struct ahc_dma_seg *sg)
{
	sg->addr = htole32(sg->addr);
	sg->len = htole32(sg->len);
}

a621 6

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWSCBALLOC)
		printf("%s: free SCB tag %x\n", ahc_name(ahc), hscb->tag);
#endif

a633 1
	timeout_del(&scb->xs->stimeout);
a635 1

d678 1
a678 1
	int error, level = 0;
d716 6
a721 1
	*baddr = (*mapp)->dm_segs[0].ds_addr;
d732 1
a732 1
		bus_dmamem_free(tag, seg, *nseg);
d764 1
a764 1
	printf("scb:%p tag %x control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n",
a765 1
		hscb->tag,
d769 4
a772 4
		(unsigned long)le32toh(hscb->cmdpointer));
	printf("        datlen:%u data:0x%lx segs:0x%x segp:0x%lx\n",
		le32toh(hscb->datalen),
		(unsigned long)(le32toh(hscb->data)),
d774 4
a777 4
		(unsigned long)(le32toh(hscb->SG_pointer)));
	printf("	sg_addr:%lx sg_len:%lu\n",
		(unsigned long)(le32toh(scb->sg_list[0].addr)),
		(unsigned long)(le32toh(scb->sg_list[0].len)));
d824 2
a825 2
#define AHC_SYNCRATE_ULTRA	3
#define AHC_SYNCRATE_FAST	6
d1375 1
a1375 1
	if (done) {
d1468 1
a1468 1
	else {
a1469 2
		tstate->tagdisable |= devinfo->target_mask;
	}
d1508 1
a1508 1
	/*
a1933 2
				ahc_swap_hscb(hscb);
				ahc_swap_sg(scb->sg_list);
d1946 5
a1950 2
				if (!(scb->xs->flags & SCSI_POLL))
					timeout_add(&scb->xs->stimeout, 5 * hz);
d2029 1
a2029 1
		}
d2034 1
a2034 1
	}
d2097 2
a2098 2
				       (unsigned int)le32toh(scb->sg_list[i].addr),
				       (unsigned int)le32toh(scb->sg_list[i].len));
a2354 1
				sc_print_addr(scb->xs->sc_link);
d2593 3
a2595 4
		if (bootverbose)
			printf("%s:%c:%d: refuses WIDE negotiation.  Using "
			       "8bit transfers\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target);
d2629 4
a2632 5
		if (bootverbose)
			printf("%s:%c:%d: refuses synchronous negotiation. "
			       "Using asynchronous transfers\n",
			       ahc_name(ahc),
			       devinfo->channel, devinfo->target);
d2634 3
a2636 4
		if (bootverbose)
			printf("%s:%c:%d: refuses tagged commands.  Performing "
			       "non-tagged I/O\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target);
d3322 2
a3323 2
			 && (le32toh(scb->sg_list[sg_index].len) < data_cnt)) {
				u_int32_t sg_addr;
d3327 2
a3328 3
				data_addr = le32toh(scb->sg_list[sg_index].addr)
					  + le32toh(scb->sg_list[sg_index].len)
					  - 1;
d3405 1
a3405 1
	timeout_del(&scb->xs->stimeout);
d3418 1
a3418 1
		bus_dmasync_op_t op;
d3433 1
a3433 2
	if (!(scb->hscb->control & TAG_ENB))
		ahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);
d3452 2
a3453 2
			if (!(txs->flags & SCSI_POLL))
				timeout_add(&scbp->xs->stimeout,
d3455 1
d3489 1
a3489 1
		      &xs->sense, le32toh(scb->sg_list->len));
a3512 1
		ahc_check_tags(ahc, xs);
a3641 3
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
			BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	
a3837 1
		tstate->tagdisable = 0;
d3918 1
a3918 1
	 * If we are a target, we'll enable select in operations once
a4047 1
	char channel;
a4082 3
	/* determine safety of software queueing */
	dontqueue = xs->flags & SCSI_POLL;
	
d4091 1
a4091 2
	    (!ahc_istagged_device(ahc, xs, 0) &&
	     ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)) {
d4166 1
a4166 2
	if (!ahc_istagged_device(ahc, xs, 0) &&
	    ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)
a4172 1
	timeout_set(&xs->stimeout, ahc_timeout, scb);
d4174 1
a4174 4
	if (ahc_istagged_device(ahc, xs, 0))
		scb->hscb->control |= MSG_SIMPLE_Q_TAG;
	else
		ahc_busy_tcl(ahc, scb);
a4177 11
	channel = SIM_CHANNEL(ahc, xs->sc_link);
	if (ahc->inited_channels[channel - 'A'] == 0) {
		if ((channel == 'A' && (ahc->flags & AHC_RESET_BUS_A)) ||
		    (channel == 'B' && (ahc->flags & AHC_RESET_BUS_B))) {
			s = splbio();
			ahc_reset_channel(ahc, channel, TRUE);
			splx(s);
		}
		ahc->inited_channels[channel - 'A'] = 1;
	}

a4247 1
			ahc_swap_sg(sg);
d4274 1
a4274 2
		if (!ahc_istagged_device(ahc, xs, 0))
			ahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);
a4285 2

	ahc_swap_hscb(scb->hscb);
d4292 2
a4293 1
		timeout_add(&xs->stimeout, (xs->timeout * hz) / 1000);
a4324 1
		sc_print_addr(xs->sc_link);
d4398 1
a4398 2
			if (!ahc_istagged_device(ahc, xs, 0))
				ahc_index_busy_tcl(ahc, hscb->tcl, TRUE);
d4493 2
a4494 4
		    ahc_hscb_busaddr(ahc, next_scb->hscb->tag)
		  + offsetof(struct hardware_scb, cmdstore);
		next_scb->hscb->cmdstore_busaddr =
		    htole32(next_scb->hscb->cmdstore_busaddr);
a4626 2
	instr.integer = le32toh(instr.integer);

a4713 1
		instr.integer = htole32(instr.integer);
d4747 1
a4747 1
			timeout_del(&scbp->xs->stimeout);
d4833 2
a4834 2
			       le32toh(scb->sg_list[i].addr),
			       le32toh(scb->sg_list[i].len));
d4896 2
a4897 2
				timeout_add(&scb->xs->stimeout,
				    (newtimeout * hz) / 1000);
a4915 1
				splx(s);
d4925 1
a4925 2
			    timeout_add(&active_scb->xs->stimeout, 2 * hz);
			unpause_sequencer(ahc);
a5000 5

				bus_dmamap_sync(ahc->sc_dmat,
				    ahc->shared_data_dmamap,
				    BUS_DMASYNC_PREWRITE);

d5008 1
a5008 1
				timeout_add(&scb->xs->stimeout, 2 * hz);
d5582 1
a5582 1
			resid += le32toh(scb->sg_list[sg].len);
a5741 93
}

STATIC void
ahc_check_tags(ahc, xs)
struct ahc_softc *ahc;
struct scsi_xfer *xs;
{
	struct scsi_inquiry_data *inq;
	struct ahc_devinfo devinfo;
	struct tmode_tstate *tstate;
	int target_id, our_id;
	char channel;

	if (xs->cmd->opcode != INQUIRY || xs->error != XS_NOERROR)
		return;

	if (xs->sc_link->quirks & SDEV_NOTAGS)
		return;

	target_id = xs->sc_link->target;
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
	channel = SIM_CHANNEL(ahc, xs->sc_link);

	(void)ahc_fetch_transinfo(ahc, channel, our_id, target_id, &tstate);
	ahc_compile_devinfo(&devinfo, our_id, target_id,
	    xs->sc_link->lun, channel, ROLE_INITIATOR);

	if (tstate->tagdisable & devinfo.target_mask)
		return;

	/*
	 * Sneak a look at the results of the SCSI Inquiry
	 * command and see if we can do Tagged queing.  This
	 * should really be done by the higher level drivers.
	 */
	inq = (struct scsi_inquiry_data *)xs->data;
	if ((inq->flags & SID_CmdQue) && !(ahc_istagged_device(ahc, xs, 1))) {
#ifdef AHC_DEBUG 
		printf("%s: target %d using tagged queuing\n",
			ahc_name(ahc), xs->sc_link->target);
#endif 
		ahc_set_tags(ahc, &devinfo, TRUE);

		if (ahc->scb_data->maxhscbs >= 16 ||
		    (ahc->flags & AHC_PAGESCBS)) {
			/* Default to 16 tags */
			xs->sc_link->openings += 14;
		} else {
			/*
			 * Default to 4 tags on whimpy
			 * cards that don't have much SCB
			 * space and can't page.  This prevents
			 * a single device from hogging all
			 * slots.  We should really have a better
			 * way of providing fairness.
			 */
			xs->sc_link->openings += 2;
		}
	}
}

STATIC int
ahc_istagged_device(ahc, xs, nocmdcheck)
struct ahc_softc *ahc;
struct scsi_xfer *xs;
int nocmdcheck;
{
	char channel;
	u_int our_id, target;
	struct tmode_tstate *tstate;
	struct ahc_devinfo devinfo;

	if (xs->sc_link->quirks & SDEV_NOTAGS)
		return 0;

	/*
	 * XXX never do these commands with tags. Should really be
	 * in a higher layer.
	 */
	if (!nocmdcheck && (xs->cmd->opcode == INQUIRY ||
	     xs->cmd->opcode == TEST_UNIT_READY ||
	     xs->cmd->opcode == REQUEST_SENSE))
		return 0;

	channel = SIM_CHANNEL(ahc, xs->sc_link);
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
	target = xs->sc_link->target;
	(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);

	ahc_compile_devinfo(&devinfo, our_id, target,
	    xs->sc_link->lun, channel, ROLE_INITIATOR);

	return (tstate->tagenable & devinfo.target_mask);
@


1.18.6.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.18.6.2 2001/05/14 22:23:24 niklas Exp $
a5011 1
				splx(s);
@


1.18.6.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.18.6.3 2001/07/04 10:40:27 niklas Exp $
d104 2
a259 8
#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define	ahc_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (off), (len), (op))
#else
#define	ahc_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (op))
#endif

d528 2
a529 2
		ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
		    UNTAGGEDSCB_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
d541 2
a542 2
	ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    UNTAGGEDSCB_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
d603 2
a604 2
	ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    0, 256, BUS_DMASYNC_POSTREAD);
d3458 1
a3458 2
		ahc_bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
		    0, scb->dmamap->dm_mapsize, op);
d3677 2
a3678 2
	ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
		 0, driver_data_size, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d4319 1
a4319 2
		ahc_bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
		    0, scb->dmamap->dm_mapsize, op);
d4374 2
a4375 2
		ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
		    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
d5075 1
a5075 1
				ahc_bus_dmamap_sync(ahc->sc_dmat,
a5076 1
				    QINFIFO_OFFSET * 256, 256,
d5128 2
a5129 2
	ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_POSTREAD);
d5159 2
a5160 2
	ahc_bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
d5258 1
a5258 1
	 * disconnected when the reset occurred.
@


1.18.6.5
log
@Merge in -current
@
text
@d36 1
a36 1
 * $OpenBSD$
d103 1
a103 1
#include <uvm/uvm_extern.h>
d258 8
d534 1
a534 1
		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
d547 1
a547 1
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
d609 1
a609 1
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
d3458 1
a3458 1
		int op;
d3464 1
a3464 1
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
d3684 1
a3684 1
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
d4300 1
a4300 1
		struct ahc_dma_seg *sg;
d4302 1
a4302 1
		int op;
d4326 1
a4326 1
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
d4382 1
a4382 1
		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
d5083 1
a5083 1
				bus_dmamap_sync(ahc->sc_dmat,
d5137 1
a5137 1
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
d5168 1
a5168 1
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
@


1.18.6.6
log
@Merge in -current
@
text
@d36 1
a36 1
 * $OpenBSD: aic7xxx.c,v 1.18.6.5 2001/11/13 21:10:00 niklas Exp $
d646 1
a646 1
	if (ahc_debug & AHC_SHOWSCBS)
d3923 4
a3926 2
		printf("DISCENABLE == 0x%x\nULTRAENB == 0x%x\n",
		    discenable, ultraenb);
d4996 1
a4996 1
			timeout_add(&active_scb->xs->stimeout, 2 * hz);
@


1.18.6.7
log
@Merge in trunk
@
text
@d2 5
a6 1
 * Core routines and tables shareable across OS platforms.
d8 1
a8 1
 * Copyright (c) 1994-2001 Justin T. Gibbs.
d21 1
a21 1
 * GNU Public License ("GPL").
d35 50
a84 1
 * $Id$
a85 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.80 2001/12/16 17:38:30 gibbs Exp $
d88 29
a116 4
#ifdef __OpenBSD__
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
#include <dev/microcode/aic7xxx/aicasm_insformat.h>
a117 7
#ifdef __FreeBSD__
#include <dev/aic7xxx/aic7xxx_freebsd.h>
#include <dev/aic7xxx/aic7xxx_inline.h>
#include <dev/aic7xxx/aicasm/aicasm_insformat.h>
#endif 
/****************************** Softc Data ************************************/
struct ahc_softc_tailq ahc_tailq = TAILQ_HEAD_INITIALIZER(ahc_tailq);
d119 76
a194 17
/***************************** Lookup Tables **********************************/
char *ahc_chip_names[] =
{
	"NONE",
	"aic7770",
	"aic7850",
	"aic7855",
	"aic7859",
	"aic7860",
	"aic7870",
	"aic7880",
	"aic7895",
	"aic7895C",
	"aic7890/91",
	"aic7896/97",
	"aic7892",
	"aic7899"
a195 1
static const u_int num_chip_names = NUM_ELEMENTS(ahc_chip_names);
d197 191
a387 6
/*
 * Hardware error codes.
 */
struct ahc_hard_error_entry {
        uint8_t errno;
	char *errmesg;
d390 6
a395 9
static struct ahc_hard_error_entry ahc_hard_errors[] = {
	{ ILLHADDR,	"Illegal Host Access" },
	{ ILLSADDR,	"Illegal Sequencer Address referrenced" },
	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
	{ SQPARERR,	"Sequencer Parity Error" },
	{ DPARERR,	"Data-path Parity Error" },
	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
	{ PCIERRSTAT,	"PCI Error detected" },
	{ CIOPARERR,	"CIOBUS Parity Error" },
a396 1
static const u_int num_errors = NUM_ELEMENTS(ahc_hard_errors);
d398 2
a399 1
static struct ahc_phase_table_entry ahc_phase_table[] =
d401 4
a404 10
	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
	{ P_DATAOUT_DT,	MSG_NOOP,		"in DT Data-out phase"	},
	{ P_DATAIN_DT,	MSG_INITIATOR_DET_ERR,	"in DT Data-in phase"	},
	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
	{ 0,		MSG_NOOP,		"in unknown phase"	}
d407 23
d431 5
a435 2
 * In most cases we only wish to itterate over real phases, so
 * exclude the last element from the count.
d437 15
a451 1
static const u_int num_phases = NUM_ELEMENTS(ahc_phase_table) - 1;
d453 3
a455 6
/*
 * Valid SCSIRATE values.  (p. 3-17)
 * Provides a mapping of tranfer periods in ns to the proper value to
 * stick in the scsixfer reg.
 */
static struct ahc_syncrate ahc_syncrates[] =
d457 2
a458 17
      /* ultra2    fast/ultra  period     rate */
	{ 0x42,      0x000,      9,      "80.0" },
	{ 0x03,      0x000,     10,      "40.0" },
	{ 0x04,      0x000,     11,      "33.0" },
	{ 0x05,      0x100,     12,      "20.0" },
	{ 0x06,      0x110,     15,      "16.0" },
	{ 0x07,      0x120,     18,      "13.4" },
	{ 0x08,      0x000,     25,      "10.0" },
	{ 0x19,      0x010,     31,      "8.0"  },
	{ 0x1a,      0x020,     37,      "6.67" },
	{ 0x1b,      0x030,     43,      "5.7"  },
	{ 0x1c,      0x040,     50,      "5.0"  },
	{ 0x00,      0x050,     56,      "4.4"  },
	{ 0x00,      0x060,     62,      "4.0"  },
	{ 0x00,      0x070,     68,      "3.6"  },
	{ 0x00,      0x000,      0,      NULL   }
};
d460 5
a464 6
/* Our Sequencer Program */
#ifdef __OpenBSD__
#include <dev/microcode/aic7xxx/aic7xxx_seq.h>
#else
#include "aic7xxx_seq.h"
#endif 
d466 7
a472 61
/**************************** Function Declarations ***************************/
static struct ahc_tmode_tstate*
			ahc_alloc_tstate(struct ahc_softc *ahc,
					 u_int scsi_id, char channel);
#ifdef AHC_TARGET_MODE
static void		ahc_free_tstate(struct ahc_softc *ahc,
					u_int scsi_id, char channel, int force);
#endif
static struct ahc_syncrate*
			ahc_devlimited_syncrate(struct ahc_softc *ahc,
					        struct ahc_initiator_tinfo *,
						u_int *period,
						u_int *ppr_options,
						role_t role);
static void		ahc_update_pending_scbs(struct ahc_softc *ahc);
static void		ahc_fetch_devinfo(struct ahc_softc *ahc,
					  struct ahc_devinfo *devinfo);
static void		ahc_scb_devinfo(struct ahc_softc *ahc,
					struct ahc_devinfo *devinfo,
					struct scb *scb);
static void		ahc_assert_atn(struct ahc_softc *ahc);
static void		ahc_setup_initiator_msgout(struct ahc_softc *ahc,
						   struct ahc_devinfo *devinfo,
						   struct scb *scb);
static void		ahc_build_transfer_msg(struct ahc_softc *ahc,
					       struct ahc_devinfo *devinfo);
static void		ahc_construct_sdtr(struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo,
					   u_int period, u_int offset);
static void		ahc_construct_wdtr(struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo,
					   u_int bus_width);
static void		ahc_construct_ppr(struct ahc_softc *ahc,
					  struct ahc_devinfo *devinfo,
					  u_int period, u_int offset,
					  u_int bus_width, u_int ppr_options);
static void		ahc_clear_msg_state(struct ahc_softc *ahc);
static void		ahc_handle_message_phase(struct ahc_softc *ahc);
typedef enum {
	AHCMSG_1B,
	AHCMSG_2B,
	AHCMSG_EXT
} ahc_msgtype;
static int		ahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type,
				     u_int msgval, int full);
static int		ahc_parse_msg(struct ahc_softc *ahc,
				      struct ahc_devinfo *devinfo);
static int		ahc_handle_msg_reject(struct ahc_softc *ahc,
					      struct ahc_devinfo *devinfo);
static void		ahc_handle_ign_wide_residue(struct ahc_softc *ahc,
						struct ahc_devinfo *devinfo);
static void		ahc_reinitialize_dataptrs(struct ahc_softc *ahc);
static void		ahc_handle_devreset(struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo,
					    cam_status status, char *message,
					    int verbose_level);
#if AHC_TARGET_MODE
static void		ahc_setup_target_msgin(struct ahc_softc *ahc,
					       struct ahc_devinfo *devinfo,
					       struct scb *scb);
#endif
d474 7
a480 10
#ifdef __OpenBSD__
int			ahc_init_scbdata(struct ahc_softc *ahc);
void			ahc_fini_scbdata(struct ahc_softc *ahc);
void			ahc_build_free_scb_list(struct ahc_softc *ahc);
#else
static bus_dmamap_callback_t	ahc_dmamap_cb;
static int		ahc_init_scbdata(struct ahc_softc *ahc);
static void		ahc_fini_scbdata(struct ahc_softc *ahc);
static void		ahc_build_free_scb_list(struct ahc_softc *ahc);
#endif 
a481 34
static void		ahc_qinfifo_requeue(struct ahc_softc *ahc,
					    struct scb *prev_scb,
					    struct scb *scb);
static int		ahc_qinfifo_count(struct ahc_softc *ahc);
static u_int		ahc_rem_scb_from_disc_list(struct ahc_softc *ahc,
						   u_int prev, u_int scbptr);
static void		ahc_add_curscb_to_free_list(struct ahc_softc *ahc);
static u_int		ahc_rem_wscb(struct ahc_softc *ahc,
				     u_int scbpos, u_int prev);
static int		ahc_abort_scbs(struct ahc_softc *ahc, int target,
				       char channel, int lun, u_int tag,
				       role_t role, uint32_t status);
static void		ahc_reset_current_bus(struct ahc_softc *ahc);
#ifdef AHC_DUMP_SEQ
static void		ahc_dumpseq(struct ahc_softc *ahc);
#endif
static void		ahc_loadseq(struct ahc_softc *ahc);
static int		ahc_check_patch(struct ahc_softc *ahc,
					struct patch **start_patch,
					u_int start_instr, u_int *skip_addr);
static void		ahc_download_instr(struct ahc_softc *ahc,
					   u_int instrptr, uint8_t *dconsts);
#ifdef AHC_TARGET_MODE
static void		ahc_queue_lstate_event(struct ahc_softc *ahc,
					       struct ahc_tmode_lstate *lstate,
					       u_int initiator_id,
					       u_int event_type,
					       u_int event_arg);
static void		ahc_update_scsiid(struct ahc_softc *ahc,
					  u_int targid_mask);
static int		ahc_handle_target_cmd(struct ahc_softc *ahc,
					      struct target_cmd *cmd);
#endif
/************************* Sequencer Execution Control ************************/
d485 35
a519 2
void
ahc_restart(struct ahc_softc *ahc)
d521 8
d530 12
a541 1
	ahc_pause(ahc);
d543 7
a549 3
	ahc_outb(ahc, SCSISIGO, 0);		/* De-assert BSY */
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);	/* No message to send */
	ahc_outb(ahc, SXFRCTL1, ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);
d551 7
a557 8
	/*
	 * Ensure that the sequencer's idea of TQINPOS
	 * matches our own.  The sequencer increments TQINPOS
	 * only after it sees a DMA complete and a reset could
	 * occur before the increment leaving the kernel to believe
	 * the command arrived but the sequencer to not.
	 */
	ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
d559 4
a562 8
	/* Always allow reselection */
	ahc_outb(ahc, SCSISEQ,
		 ahc_inb(ahc, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Ensure that no DMA operations are in progress */
		ahc_outb(ahc, CCSCBCNT, 0);
		ahc_outb(ahc, CCSGCTL, 0);
		ahc_outb(ahc, CCSCBCTL, 0);
d564 18
d583 4
a586 3
	 * If we were in the process of DMA'ing SCB data into
	 * an SCB, replace that SCB on the free list.  This prevents
	 * an SCB leak.
d588 4
a591 10
	if ((ahc_inb(ahc, SEQ_FLAGS2) & SCB_DMA) != 0) {
		ahc_add_curscb_to_free_list(ahc);
		ahc_outb(ahc, SEQ_FLAGS2,
			 ahc_inb(ahc, SEQ_FLAGS2) & ~SCB_DMA);
	}
	ahc_outb(ahc, MWI_RESIDUAL, 0);
	ahc_outb(ahc, SEQCTL, FASTMODE);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	ahc_unpause(ahc);
d594 3
a596 3
/************************* Input/Output Queues ********************************/
void
ahc_run_qoutfifo(struct ahc_softc *ahc)
d601 3
a603 1
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);
a604 1

d606 1
a606 18
		if ((ahc->qoutfifonext & 0x03) == 0x03) {
			u_int modnext;

			/*
			 * Clear 32bits of QOUTFIFO at a time
			 * so that we don't clobber an incoming
			 * byte DMA to the array on architectures
			 * that only support 32bit load and store
			 * operations.
			 */
			modnext = ahc->qoutfifonext & ~0x3;
			*((uint32_t *)(&ahc->qoutfifo[modnext])) = 0xFFFFFFFFUL;
			ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
					ahc->shared_data_dmamap,
					/*offset*/modnext, /*len*/4,
					BUS_DMASYNC_PREREAD);
		}
		ahc->qoutfifonext++;
d608 3
a610 2
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
d622 4
a625 1
		ahc_update_residual(scb);
a629 4
void
ahc_run_untagged_queues(struct ahc_softc *ahc)
{
	int i;
d631 13
a643 3
	for (i = 0; i < 16; i++)
		ahc_run_untagged_queue(ahc, &ahc->untagged_queues[i]);
}
d645 4
a648 4
void
ahc_run_untagged_queue(struct ahc_softc *ahc, struct scb_tailq *queue)
{
	struct scb *scb;
d650 1
a650 2
	if (ahc->untagged_queue_lock != 0)
		return;
d652 4
a655 4
	if ((scb = TAILQ_FIRST(queue)) != NULL
	 && (scb->flags & SCB_ACTIVE) == 0) {
		scb->flags |= SCB_ACTIVE;
		ahc_queue_scb(ahc, scb);
d657 10
d669 9
a677 3
/************************* Interrupt Handling *********************************/
void
ahc_handle_brkadrint(struct ahc_softc *ahc)
d679 12
a690 6
	/*
	 * We upset the sequencer :-(
	 * Lookup the error message
	 */
	int i;
	int error;
d692 1
a692 14
	error = ahc_inb(ahc, ERROR);
	for (i = 0; error != 1 && i < num_errors; i++)
		error >>= 1;
	printf("%s: brkadrint, %s at seqaddr = 0x%x\n",
	       ahc_name(ahc), ahc_hard_errors[i].errmesg,
	       ahc_inb(ahc, SEQADDR0) |
	       (ahc_inb(ahc, SEQADDR1) << 8));

	ahc_dump_card_state(ahc);

	/* Tell everyone that this HBA is no longer availible */
	ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,
		       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,
		       CAM_NO_HBA);
d694 1
a694 2
	/* Disable all interrupt sources by resetting the controller */
	ahc_shutdown(ahc);
d697 17
a713 5
void
ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat)
{
	struct scb *scb;
	struct ahc_devinfo devinfo;
d715 50
a764 1
	ahc_fetch_devinfo(ahc, &devinfo);
d766 9
a774 12
	/*
	 * Clear the upper byte that holds SEQINT status
	 * codes and clear the SEQINT bit. We will unpause
	 * the sequencer, if appropriate, after servicing
	 * the request.
	 */
	ahc_outb(ahc, CLRINT, CLRSEQINT);
	switch (intstat & SEQINT_MASK) {
	case BAD_STATUS:
	{
		u_int  scb_index;
		struct hardware_scb *hscb;
d776 5
a780 6
		/*
		 * Set the default return value to 0 (don't
		 * send sense).  The sense code will change
		 * this if needed.
		 */
		ahc_outb(ahc, RETURN_1, 0);
d782 6
a787 20
		/*
		 * The sequencer will notify us when a command
		 * has an error that would be of interest to
		 * the kernel.  This allows us to leave the sequencer
		 * running in the common case of command completes
		 * without error.  The sequencer will already have
		 * dma'd the SCB back up to us, so we can reference
		 * the in kernel copy directly.
		 */
		scb_index = ahc_inb(ahc, SCB_TAG);
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("%s:%c:%d: ahc_intr - referenced scb "
			       "not valid during seqint 0x%x scb(%d)\n",
			       ahc_name(ahc), devinfo.channel,
			       devinfo.target, intstat, scb_index);
			ahc_dump_card_state(ahc);
			panic("for safety");
			goto unpause;
		}
d789 22
a810 1
		hscb = scb->hscb; 
d812 14
a825 37
		/* Don't want to clobber the original sense code */
		if ((scb->flags & SCB_SENSE) != 0) {
			/*
			 * Clear the SCB_SENSE Flag and have
			 * the sequencer do a normal command
			 * complete.
			 */
			scb->flags &= ~SCB_SENSE;
			printf("ahc_handle_seqint: sense fail\n");
			ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
			break;
		}
		ahc_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
		/* Freeze the queue until the client sees the error. */
		ahc_freeze_devq(ahc, scb);
		ahc_freeze_scb(scb);
		ahc_set_scsi_status(scb, hscb->shared_data.status.scsi_status);
		switch (hscb->shared_data.status.scsi_status) {
		case SCSI_STATUS_OK:
			printf("%s: Interrupted for staus of 0???\n",
			       ahc_name(ahc));
			break;
		case SCSI_STATUS_CMD_TERMINATED:
		case SCSI_STATUS_CHECK_COND:
		{
			struct ahc_dma_seg *sg;
			struct scsi_sense *sc;
			struct ahc_initiator_tinfo *targ_info;
			struct ahc_tmode_tstate *tstate;
			struct ahc_transinfo *tinfo;
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				ahc_print_path(ahc, scb);
				printf("SCB %d: requests Check Status\n",
				       scb->hscb->tag);
			}
#endif
d827 15
a841 2
			if (ahc_perform_autosense(scb) == 0)
				break;
d843 27
a869 35
			targ_info = ahc_fetch_transinfo(ahc,
							devinfo.channel,
							devinfo.our_scsiid,
							devinfo.target,
							&tstate);
			tinfo = &targ_info->curr;
			sg = scb->sg_list;
			sc = (struct scsi_sense *)(&hscb->shared_data.cdb); 
			/*
			 * Save off the residual if there is one.
 			 */
			ahc_update_residual(scb);
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				ahc_print_path(ahc, scb);
				printf("Sending Sense\n");
			}
#endif
			sg->addr = ahc_get_sense_bufaddr(ahc, scb);
			sg->len = ahc_get_sense_bufsize(ahc, scb);
			sg->len |= AHC_DMA_LAST_SEG;
			
			/* Fixup byte order */
			sg->addr = ahc_htole32(sg->addr);
			sg->len = ahc_htole32(sg->len);

			sc->opcode = REQUEST_SENSE;
			sc->byte2 = 0;
			if (tinfo->protocol_version <= SCSI_REV_2
			 && SCB_GET_LUN(scb) < 8)
				sc->byte2 = SCB_GET_LUN(scb) << 5;
			sc->unused[0] = 0;
			sc->unused[1] = 0;
			sc->length = sg->len;
			sc->control = 0;
d871 15
a885 404
			/*
			 * We can't allow the target to disconnect.
			 * This will be an untagged transaction and
			 * having the target disconnect will make this
			 * transaction indestinguishable from outstanding
			 * tagged transactions.
			 */
			hscb->control = 0;

			/*
			 * This request sense could be because the
			 * the device lost power or in some other
			 * way has lost our transfer negotiations.
			 * Renegotiate if appropriate.  Unit attention
			 * errors will be reported before any data
			 * phases occur.
			 */
#ifdef __OpenBSD__
			if (ahc_get_transfer_length(scb) > 0 &&
			    ahc_get_residual(scb) == 
			    ahc_get_transfer_length(scb)) {
#else 
			if (ahc_get_residual(scb) 
			 == ahc_get_transfer_length(scb)) {
#endif
				ahc_update_neg_request(ahc, &devinfo,
						       tstate, targ_info,
						       /*force*/TRUE);
			}
			if (tstate->auto_negotiate & devinfo.target_mask) {
				hscb->control |= MK_MESSAGE;
				scb->flags &= ~SCB_NEGOTIATE;
				scb->flags |= SCB_AUTO_NEGOTIATE;
			}
			hscb->cdb_len = sizeof(*sc);
			hscb->dataptr = ahc_htole32(sg->addr); 
			hscb->datacnt = ahc_htole32(sg->len);
			hscb->sgptr = scb->sg_list_phys | SG_FULL_RESID;
			hscb->sgptr = ahc_htole32(hscb->sgptr);
			scb->sg_count = 1;
			scb->flags |= SCB_SENSE;
			ahc_qinfifo_requeue_tail(ahc, scb);
			ahc_outb(ahc, RETURN_1, SEND_SENSE);
#ifdef __OpenBSD__
			if (!(scb->io_ctx->flags & SCSI_POLL))
				timeout_add(&scb->io_ctx->stimeout, 5 * hz);
#endif 
#ifdef __FreeBSD__
			/*
			 * Ensure we have enough time to actually
			 * retrieve the sense.
			 */
			untimeout(ahc_timeout, (caddr_t)scb,
				  scb->io_ctx->ccb_h.timeout_ch);
			scb->io_ctx->ccb_h.timeout_ch =
			    timeout(ahc_timeout, (caddr_t)scb, 5 * hz);
#endif
			break;
		}
		default:
			break;
		}
		break;
	}
	case NO_MATCH:
	{
		/* Ensure we don't leave the selection hardware on */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));

		printf("%s:%c:%d: no active SCB for reconnecting "
		       "target - issuing BUS DEVICE RESET\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target);
		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
		       "ARG_1 == 0x%x ACCUM = 0x%x\n",
		       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),
		       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));
		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
		       "SINDEX == 0x%x\n",
		       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),
		       ahc_index_busy_tcl(ahc,
			    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),
				      ahc_inb(ahc, SAVED_LUN))),
		       ahc_inb(ahc, SINDEX));
		printf("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
		       "SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",
		       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),
		       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),
		       ahc_inb(ahc, SCB_CONTROL));
		printf("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",
		       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));
		printf("SXFRCTL0 == 0x%x\n", ahc_inb(ahc, SXFRCTL0));
		printf("SEQCTL == 0x%x\n", ahc_inb(ahc, SEQCTL));
		ahc_dump_card_state(ahc);
		ahc->msgout_buf[0] = MSG_BUS_DEV_RESET;
		ahc->msgout_len = 1;
		ahc->msgout_index = 0;
		ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		ahc_assert_atn(ahc);
		break;
	}
	case SEND_REJECT: 
	{
		u_int rejbyte = ahc_inb(ahc, ACCUM);
		printf("%s:%c:%d: Warning - unknown message received from "
		       "target (0x%x).  Rejecting\n", 
		       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);
		break; 
	}
	case NO_IDENT: 
	{
		/*
		 * The reconnecting target either did not send an identify
		 * message, or did, but we didn't find an SCB to match and
		 * before it could respond to our ATN/abort, it hit a dataphase.
		 * The only safe thing to do is to blow it away with a bus
		 * reset.
		 */
		int found;

		printf("%s:%c:%d: Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x, SAVED_SCSIID == 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_SCSIID));
		found = ahc_reset_channel(ahc, devinfo.channel, 
					  /*initiate reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), devinfo.channel,
		       found);
		return;
	}
	case IGN_WIDE_RES:
		ahc_handle_ign_wide_residue(ahc, &devinfo);
		break;
	case PDATA_REINIT:
		ahc_reinitialize_dataptrs(ahc);
		break;
	case BAD_PHASE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		printf("%s:%c:%d: unknown scsi bus phase %x, "
		       "lastphase = 0x%x.  Attempting to continue\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       lastphase, ahc_inb(ahc, SCSISIGI));
		break;
	}
	case MISSED_BUSFREE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		printf("%s:%c:%d: Missed busfree. "
		       "Lastphase = 0x%x, Curphase = 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       lastphase, ahc_inb(ahc, SCSISIGI));
		ahc_restart(ahc);
		return;
	}
	case HOST_MSG_LOOP:
	{
		/*
		 * The sequencer has encountered a message phase
		 * that requires host assistance for completion.
		 * While handling the message phase(s), we will be
		 * notified by the sequencer after each byte is
		 * transfered so we can track bus phase changes.
		 *
		 * If this is the first time we've seen a HOST_MSG_LOOP
		 * interrupt, initialize the state of the host message
		 * loop.
		 */
		if (ahc->msg_type == MSG_TYPE_NONE) {
			struct scb *scb;
			u_int scb_index;
			u_int bus_phase;

			bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			if (bus_phase != P_MESGIN
			 && bus_phase != P_MESGOUT) {
				printf("ahc_intr: HOST_MSG_LOOP bad "
				       "phase 0x%x\n",
				      bus_phase);
				/*
				 * Probably transitioned to bus free before
				 * we got here.  Just punt the message.
				 */
				ahc_clear_intstat(ahc);
				ahc_restart(ahc);
				return;
			}

			scb_index = ahc_inb(ahc, SCB_TAG);
			scb = ahc_lookup_scb(ahc, scb_index);
			if (devinfo.role == ROLE_INITIATOR) {
				if (scb == NULL)
					panic("HOST_MSG_LOOP with "
					      "invalid SCB %x\n", scb_index);

				if (bus_phase == P_MESGOUT)
					ahc_setup_initiator_msgout(ahc,
								   &devinfo,
								   scb);
				else {
					ahc->msg_type =
					    MSG_TYPE_INITIATOR_MSGIN;
					ahc->msgin_index = 0;
				}
			} else {
				if (bus_phase == P_MESGOUT) {
					ahc->msg_type =
					    MSG_TYPE_TARGET_MSGOUT;
					ahc->msgin_index = 0;
				}
#if AHC_TARGET_MODE
				else 
					ahc_setup_target_msgin(ahc,
							       &devinfo,
							       scb);
#endif
			}
		}

		ahc_handle_message_phase(ahc);
		break;
	}
	case PERR_DETECTED:
	{
		/*
		 * If we've cleared the parity error interrupt
		 * but the sequencer still believes that SCSIPERR
		 * is true, it must be that the parity error is
		 * for the currently presented byte on the bus,
		 * and we are not in a phase (data-in) where we will
		 * eventually ack this byte.  Ack the byte and
		 * throw it away in the hope that the target will
		 * take us to message out to deliver the appropriate
		 * error message.
		 */
		if ((intstat & SCSIINT) == 0
		 && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {

			if ((ahc->features & AHC_DT) == 0) {
				u_int curphase;

				/*
				 * The hardware will only let you ack bytes
				 * if the expected phase in SCSISIGO matches
				 * the current phase.  Make sure this is
				 * currently the case.
				 */
				curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
				ahc_outb(ahc, LASTPHASE, curphase);
				ahc_outb(ahc, SCSISIGO, curphase);
			}
			ahc_inb(ahc, SCSIDATL);
		}
		break;
	}
	case DATA_OVERRUN:
	{
		/*
		 * When the sequencer detects an overrun, it
		 * places the controller in "BITBUCKET" mode
		 * and allows the target to complete its transfer.
		 * Unfortunately, none of the counters get updated
		 * when the controller is in this mode, so we have
		 * no way of knowing how large the overrun was.
		 */
		u_int scbindex = ahc_inb(ahc, SCB_TAG);
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		u_int i;

		scb = ahc_lookup_scb(ahc, scbindex);
		for (i = 0; i < num_phases; i++) {
			if (lastphase == ahc_phase_table[i].phase)
				break;
		}
		ahc_print_path(ahc, scb);
		printf("data overrun detected %s."
		       "  Tag == 0x%x.\n",
		       ahc_phase_table[i].phasemsg,
  		       scb->hscb->tag);
		ahc_print_path(ahc, scb);
		printf("%s seen Data Phase.  Length = %ld.  NumSGs = %d.\n",
		       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
		       ahc_get_transfer_length(scb), scb->sg_count);
		if (scb->sg_count > 0) {
			for (i = 0; i < scb->sg_count; i++) {

				printf("sg[%d] - Addr 0x%x%x : Length %d\n",
				       i,
				       (ahc_le32toh(scb->sg_list[i].len) >> 24
				        & SG_HIGH_ADDR_BITS),
				       ahc_le32toh(scb->sg_list[i].addr),
				       ahc_le32toh(scb->sg_list[i].len)
				       & AHC_SG_LEN_MASK);
			}
		}
		/*
		 * Set this and it will take effect when the
		 * target does a command complete.
		 */
		ahc_freeze_devq(ahc, scb);
		ahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);
		ahc_freeze_scb(scb);

		if ((ahc->features & AHC_ULTRA2) != 0) {
			/*
			 * Clear the channel in case we return
			 * to data phase later.
			 */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);
		}
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			u_int dscommand1;

			/* Ensure HHADDR is 0 for future DMA operations. */
			dscommand1 = ahc_inb(ahc, DSCOMMAND1);
			ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
			ahc_outb(ahc, HADDR, 0);
			ahc_outb(ahc, DSCOMMAND1, dscommand1);
		}
		break;
	}
	case MKMSG_FAILED:
	{
		u_int scbindex;

		printf("%s:%c:%d:%d: Attempt to issue message failed\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       devinfo.lun);
		scbindex = ahc_inb(ahc, SCB_TAG);
		scb = ahc_lookup_scb(ahc, scbindex);
		if (scb != NULL
		 && (scb->flags & SCB_RECOVERY_SCB) != 0)
			/*
			 * Ensure that we didn't put a second instance of this
			 * SCB into the QINFIFO.
			 */
			ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
					   SCB_GET_CHANNEL(ahc, scb),
					   SCB_GET_LUN(scb), scb->hscb->tag,
					   ROLE_INITIATOR, /*status*/0,
					   SEARCH_REMOVE);
		break;
	}
	case NO_FREE_SCB:
	{
		printf("%s: No free or disconnected SCBs\n", ahc_name(ahc));
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	case SCB_MISMATCH:
	{
		u_int scbptr;

		scbptr = ahc_inb(ahc, SCBPTR);
		printf("Bogus TAG after DMA.  SCBPTR %d, tag %d, our tag %d\n",
		       scbptr, ahc_inb(ahc, ARG_1),
		       ahc->scb_data->hscbs[scbptr].tag);
		ahc_dump_card_state(ahc);
		panic("for saftey");
		break;
	}
	case OUT_OF_RANGE:
	{
		printf("%s: BTT calculation out of range\n", ahc_name(ahc));
		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
		       "ARG_1 == 0x%x ACCUM = 0x%x\n",
		       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),
		       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));
		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
		       "SINDEX == 0x%x\n, A == 0x%x\n",
		       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),
		       ahc_index_busy_tcl(ahc,
			    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),
				      ahc_inb(ahc, SAVED_LUN))),
		       ahc_inb(ahc, SINDEX),
		       ahc_inb(ahc, ACCUM));
		printf("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
		       "SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",
		       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),
		       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),
		       ahc_inb(ahc, SCB_CONTROL));
		printf("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",
		       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	default:
		printf("ahc_intr: seqint, "
		       "intstat == 0x%x, scsisigi = 0x%x\n",
		       intstat, ahc_inb(ahc, SCSISIGI));
		break;
	}
unpause:
d887 1
a887 3
	 *  The sequencer is paused immediately on
	 *  a SEQINT, so we should restart it when
	 *  we're done.
d889 9
a897 132
	ahc_unpause(ahc);
}

void
ahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat)
{
	u_int	scb_index;
	u_int	status0;
	u_int	status;
	struct	scb *scb;
	char	cur_channel;
	char	intr_channel;

	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);

	if ((ahc->features & AHC_TWIN) != 0
	 && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
		cur_channel = 'B';
	else
		cur_channel = 'A';
	intr_channel = cur_channel;

	if ((ahc->features & AHC_ULTRA2) != 0)
		status0 = ahc_inb(ahc, SSTAT0) & IOERR;
	else
		status0 = 0;
	status = ahc_inb(ahc, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
	if (status == 0 && status0 == 0) {
		if ((ahc->features & AHC_TWIN) != 0) {
			/* Try the other channel */
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			status = ahc_inb(ahc, SSTAT1)
			       & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
			intr_channel = (cur_channel == 'A') ? 'B' : 'A';
		}
		if (status == 0) {
			printf("%s: Spurious SCSI interrupt\n", ahc_name(ahc));
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
			ahc_unpause(ahc);
			return;
		}
	}

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	if (scb != NULL
	 && (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)
		scb = NULL;

	if ((ahc->features & AHC_ULTRA2) != 0
	 && (status0 & IOERR) != 0) {
		int now_lvd;

		now_lvd = ahc_inb(ahc, SBLKCTL) & ENAB40;
		printf("%s: Transceiver State Has Changed to %s mode\n",
		       ahc_name(ahc), now_lvd ? "LVD" : "SE");
		ahc_outb(ahc, CLRSINT0, CLRIOERR);
		/*
		 * When transitioning to SE mode, the reset line
		 * glitches, triggering an arbitration bug in some
		 * Ultra2 controllers.  This bug is cleared when we
		 * assert the reset line.  Since a reset glitch has
		 * already occurred with this transition and a
		 * transceiver state change is handled just like
		 * a bus reset anyway, asserting the reset line
		 * ourselves is safe.
		 */
		ahc_reset_channel(ahc, intr_channel,
				 /*Initiate Reset*/now_lvd == 0);
	} else if ((status & SCSIRSTI) != 0) {
		printf("%s: Someone reset channel %c\n",
			ahc_name(ahc), intr_channel);
		if (intr_channel != cur_channel)
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
		ahc_reset_channel(ahc, intr_channel, /*Initiate Reset*/FALSE);
	} else if ((status & SCSIPERR) != 0) {
		/*
		 * Determine the bus phase and queue an appropriate message.
		 * SCSIPERR is latched true as soon as a parity error
		 * occurs.  If the sequencer acked the transfer that
		 * caused the parity error and the currently presented
		 * transfer on the bus has correct parity, SCSIPERR will
		 * be cleared by CLRSCSIPERR.  Use this to determine if
		 * we should look at the last phase the sequencer recorded,
		 * or the current phase presented on the bus.
		 */
		u_int mesg_out;
		u_int curphase;
		u_int errorphase;
		u_int lastphase;
		u_int scsirate;
		u_int i;
		u_int sstat2;

		lastphase = ahc_inb(ahc, LASTPHASE);
		curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
		sstat2 = ahc_inb(ahc, SSTAT2);
		ahc_outb(ahc, CLRSINT1, CLRSCSIPERR);
		/*
		 * For all phases save DATA, the sequencer won't
		 * automatically ack a byte that has a parity error
		 * in it.  So the only way that the current phase
		 * could be 'data-in' is if the parity error is for
		 * an already acked byte in the data phase.  During
		 * synchronous data-in transfers, we may actually
		 * ack bytes before latching the current phase in
		 * LASTPHASE, leading to the discrepancy between
		 * curphase and lastphase.
		 */
		if ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0
		 || curphase == P_DATAIN || curphase == P_DATAIN_DT)
			errorphase = curphase;
		else
			errorphase = lastphase;

		for (i = 0; i < num_phases; i++) {
			if (errorphase == ahc_phase_table[i].phase)
				break;
		}
		mesg_out = ahc_phase_table[i].mesg_out;
		if (scb != NULL)
			ahc_print_path(ahc, scb);
		else
			printf("%s:%c:%d: ", ahc_name(ahc), intr_channel,
			       SCSIID_TARGET(ahc, ahc_inb(ahc, SAVED_SCSIID)));
		scsirate = ahc_inb(ahc, SCSIRATE);
		printf("parity error detected %s. "
		       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
		       ahc_phase_table[i].phasemsg,
		       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),
		       scsirate);
d899 6
a904 1
		if ((ahc->features & AHC_DT) != 0) {
d906 16
a921 10
			if ((sstat2 & CRCVALERR) != 0)
				printf("\tCRC Value Mismatch\n");
			if ((sstat2 & CRCENDERR) != 0)
				printf("\tNo terminal CRC packet recevied\n");
			if ((sstat2 & CRCREQERR) != 0)
				printf("\tIllegal CRC packet request\n");
			if ((sstat2 & DUAL_EDGE_ERR) != 0)
				printf("\tUnexpected %sDT Data Phase\n",
				       (scsirate & SINGLE_EDGE) ? "" : "non-");
		}
d923 10
a932 17
		/*
		 * We've set the hardware to assert ATN if we   
		 * get a parity error on "in" phases, so all we  
		 * need to do is stuff the message buffer with
		 * the appropriate message.  "In" phases have set
		 * mesg_out to something other than MSG_NOP.
		 */
		if (mesg_out != MSG_NOOP) {
			if (ahc->msg_type != MSG_TYPE_NONE)
				ahc->send_msg_perror = TRUE;
			else
				ahc_outb(ahc, MSG_OUT, mesg_out);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_unpause(ahc);
	} else if ((status & SELTO) != 0) {
		u_int scbptr;
d934 7
a940 2
		/* Stop the selection */
		ahc_outb(ahc, SCSISEQ, 0);
d942 1
a942 2
		/* No more pending messages */
		ahc_clear_msg_state(ahc);
d944 5
a948 3
		/* Clear interrupt state */
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);
d950 2
a951 9
		/*
		 * Although the driver does not care about the
		 * 'Selection in Progress' status bit, the busy
		 * LED does.  SELINGO is only cleared by a sucessfull
		 * selection, so we must manually clear it to insure
		 * the LED turns off just incase no future successful
		 * selections occur (e.g. no devices on the bus).
		 */
		ahc_outb(ahc, CLRSINT0, CLRSELINGO);
d953 2
a954 3
		scbptr = ahc_inb(ahc, WAITING_SCBH);
		ahc_outb(ahc, SCBPTR, scbptr);
		scb_index = ahc_inb(ahc, SCB_TAG);
d956 3
a958 20
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("%s: ahc_intr - referenced scb not "
			       "valid during SELTO scb(%d, %d)\n",
			       ahc_name(ahc), scbptr, scb_index);
		} else {
			ahc_set_transaction_status(scb, CAM_SEL_TIMEOUT);
			ahc_freeze_devq(ahc, scb);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_restart(ahc);
	} else if ((status & BUSFREE) != 0
		&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {
		u_int lastphase;
		u_int saved_scsiid;
		u_int saved_lun;
		u_int target;
		u_int initiator_role_id;
		char channel;
		int printerror;
d960 3
a962 8
		/*
		 * Clear our selection hardware as soon as possible.
		 * We may have an entry in the waiting Q for this target,
		 * that is affected by this busfree and we don't want to
		 * go about selecting the target while we handle the event.
		 */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
d964 3
a966 8
		/*
		 * Disable busfree interrupts and clear the busfree
		 * interrupt status.  We do this here so that several
		 * bus transactions occur prior to clearing the SCSIINT
		 * latch.  It can take a bit for the clearing to take effect.
		 */
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);
d968 1
a968 13
		/*
		 * Look at what phase we were last in.
		 * If its message out, chances are pretty good
		 * that the busfree was in response to one of
		 * our abort requests.
		 */
		lastphase = ahc_inb(ahc, LASTPHASE);
		saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
		saved_lun = ahc_inb(ahc, SAVED_LUN);
		target = SCSIID_TARGET(ahc, saved_scsiid);
		initiator_role_id = SCSIID_OUR_ID(saved_scsiid);
		channel = SCSIID_CHANNEL(ahc, saved_scsiid);
		printerror = 1;
d970 2
a971 3
		if (lastphase == P_MESGOUT) {
			struct ahc_devinfo devinfo;
			u_int tag;
d973 9
a981 49
			ahc_fetch_devinfo(ahc, &devinfo);
			tag = SCB_LIST_NULL;
			if (ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT_TAG, TRUE)
			 || ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT, TRUE)) {
				if (ahc->msgout_buf[ahc->msgout_index - 1]
				 == MSG_ABORT_TAG)
					tag = scb->hscb->tag;
				ahc_print_path(ahc, scb);
				printf("SCB %d - Abort%s Completed.\n",
				       scb->hscb->tag, tag == SCB_LIST_NULL ?
				       "" : " Tag");
				ahc_abort_scbs(ahc, target, channel,
					       saved_lun, tag,
					       ROLE_INITIATOR,
					       CAM_REQ_ABORTED);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_1B,
						MSG_BUS_DEV_RESET, TRUE)) {
				struct ahc_devinfo devinfo;
#ifdef __FreeBSD__
				/*
				 * Don't mark the user's request for this BDR
				 * as completing with CAM_BDR_SENT.  CAM3
				 * specifies CAM_REQ_CMP.
				 */
				if (scb != NULL
				 && scb->io_ctx->ccb_h.func_code== XPT_RESET_DEV
				 && ahc_match_scb(ahc, scb, target, channel,
						  CAM_LUN_WILDCARD,
						  SCB_LIST_NULL,
						  ROLE_INITIATOR)) {
					ahc_set_transaction_status(scb, CAM_REQ_CMP);
				}
#endif
				ahc_compile_devinfo(&devinfo,
						    initiator_role_id,
						    target,
						    CAM_LUN_WILDCARD,
						    channel,
						    ROLE_INITIATOR);
				ahc_handle_devreset(ahc, &devinfo,
						    CAM_BDR_SENT,
						    "Bus Device Reset",
						    /*verbose_level*/0);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_PPR, FALSE)) {
				struct ahc_initiator_tinfo *tinfo;
				struct ahc_tmode_tstate *tstate;
d983 6
a988 38
				/*
				 * PPR Rejected.  Try non-ppr negotiation
				 * and retry command.
				 */
				tinfo = ahc_fetch_transinfo(ahc,
							    devinfo.channel,
							    devinfo.our_scsiid,
							    devinfo.target,
							    &tstate);
				tinfo->curr.transport_version = 2;
				tinfo->goal.transport_version = 2;
				tinfo->goal.ppr_options = 0;
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_WDTR, FALSE)
				|| ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_SDTR, FALSE)) {
				/*
				 * Negotiation Rejected.  Go-async and
				 * retry command.
				 */
				ahc_set_width(ahc, &devinfo,
					      MSG_EXT_WDTR_BUS_8_BIT,
					      AHC_TRANS_CUR|AHC_TRANS_GOAL,
					      /*paused*/TRUE);
				ahc_set_syncrate(ahc, &devinfo,
						/*syncrate*/NULL,
						/*period*/0, /*offset*/0,
						/*ppr_options*/0,
						AHC_TRANS_CUR|AHC_TRANS_GOAL,
						/*paused*/TRUE);
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			}
		}
		if (printerror != 0) {
			u_int i;
d990 1
a990 2
			if (scb != NULL) {
				u_int tag;
d992 6
a997 35
				if ((scb->hscb->control & TAG_ENB) != 0)
					tag = scb->hscb->tag;
				else
					tag = SCB_LIST_NULL;
				ahc_print_path(ahc, scb);
				ahc_abort_scbs(ahc, target, channel,
					       SCB_GET_LUN(scb), tag,
					       ROLE_INITIATOR,
					       CAM_UNEXP_BUSFREE);
			} else {
				/*
				 * We had not fully identified this connection,
				 * so we cannot abort anything.
				 */
				printf("%s: ", ahc_name(ahc));
			}
			for (i = 0; i < num_phases; i++) {
				if (lastphase == ahc_phase_table[i].phase)
					break;
			}
			printf("Unexpected busfree %s\n"
			       "SEQADDR == 0x%x\n",
			       ahc_phase_table[i].phasemsg,
			       ahc_inb(ahc, SEQADDR0)
				| (ahc_inb(ahc, SEQADDR1) << 8));
		}
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_restart(ahc);
	} else {
		printf("%s: Missing case in ahc_handle_scsiint. status = %x\n",
		       ahc_name(ahc), status);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
	}
}
d999 1
a999 8
#define AHC_MAX_STEPS 2000
void
ahc_clear_critical_section(struct ahc_softc *ahc)
{
	int	stepping;
	int	steps;
	u_int	simode0;
	u_int	simode1;
d1001 3
a1003 2
	if (ahc->num_critical_sections == 0)
		return;
d1005 6
a1010 25
	stepping = FALSE;
	steps = 0;
	simode0 = 0;
	simode1 = 0;
	for (;;) {
		struct	cs *cs;
		u_int	seqaddr;
		u_int	i;

		seqaddr = ahc_inb(ahc, SEQADDR0)
			| (ahc_inb(ahc, SEQADDR1) << 8);

		/*
		 * Seqaddr represents the next instruction to execute, 
		 * so we are really executing the instruction just
		 * before it.
		 */
		if (seqaddr != 0)
			seqaddr -= 1;
		cs = ahc->critical_sections;
		for (i = 0; i < ahc->num_critical_sections; i++, cs++) {
			
			if (cs->begin < seqaddr && cs->end >= seqaddr)
				break;
		}
d1012 1
a1012 2
		if (i == ahc->num_critical_sections)
			break;
d1014 4
a1017 6
		if (steps > AHC_MAX_STEPS) {
			printf("%s: Infinite loop in critical section\n",
			       ahc_name(ahc));
			ahc_dump_card_state(ahc);
			panic("critical section loop");
		}
d1019 1
a1019 2
		steps++;
		if (stepping == FALSE) {
d1021 1
a1021 24
			/*
			 * Disable all interrupt sources so that the
			 * sequencer will not be stuck by a pausing
			 * interrupt condition while we attempt to
			 * leave a critical section.
			 */
			simode0 = ahc_inb(ahc, SIMODE0);
			ahc_outb(ahc, SIMODE0, 0);
			simode1 = ahc_inb(ahc, SIMODE1);
			ahc_outb(ahc, SIMODE1, 0);
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
			ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) | STEP);
			stepping = TRUE;
		}
		ahc_outb(ahc, HCNTRL, ahc->unpause);
		do {
			ahc_delay(200);
		} while (!ahc_is_paused(ahc));
	}
	if (stepping) {
		ahc_outb(ahc, SIMODE0, simode0);
		ahc_outb(ahc, SIMODE1, simode1);
		ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) & ~STEP);
	}
d1024 3
a1026 5
/*
 * Clear any pending interrupt status.
 */
void
ahc_clear_intstat(struct ahc_softc *ahc)
d1028 1
a1028 7
	/* Clear any interrupt conditions this may have caused */
	ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
				|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|
				CLRREQINIT);
	ahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);
	ahc_outb(ahc, CLRINT, CLRSCSIINT);
}
d1030 1
a1030 5
/**************************** Debugging Routines ******************************/
void
ahc_print_scb(struct scb *scb)
{
	int i;
d1032 5
a1036 1
	struct hardware_scb *hscb = scb->hscb;
d1038 6
a1043 22
	printf("scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n",
	       (void *)scb,
	       hscb->control,
	       hscb->scsiid,
	       hscb->lun,
	       hscb->cdb_len);
	printf("Shared Data: ");
	for (i = 0; i < sizeof(hscb->shared_data.cdb); i++)
		printf("%#02x", hscb->shared_data.cdb[i]);
	printf("        dataptr:%#x datacnt:%#x sgptr:%#x tag:%#x\n",
		ahc_le32toh(hscb->dataptr),
		ahc_le32toh(hscb->datacnt),
		ahc_le32toh(hscb->sgptr),
		hscb->tag);
	if (scb->sg_count > 0) {
		for (i = 0; i < scb->sg_count; i++) {
			printf("sg[%d] - Addr 0x%x%x : Length %d\n",
			       i,
			       (ahc_le32toh(scb->sg_list[i].len) >> 24
			        & SG_HIGH_ADDR_BITS),
			       ahc_le32toh(scb->sg_list[i].addr),
			       ahc_le32toh(scb->sg_list[i].len));
d1046 16
d1064 5
a1068 7
/************************* Transfer Negotiation *******************************/
/*
 * Allocate per target mode instance (ID we respond to as a target)
 * transfer negotiation data structures.
 */
static struct ahc_tmode_tstate *
ahc_alloc_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel)
d1070 2
a1071 3
	struct ahc_tmode_tstate *master_tstate;
	struct ahc_tmode_tstate *tstate;
	int i;
d1073 5
a1077 12
	master_tstate = ahc->enabled_targets[ahc->our_id];
	if (channel == 'B') {
		scsi_id += 8;
		master_tstate = ahc->enabled_targets[ahc->our_id_b + 8];
	}
	if (ahc->enabled_targets[scsi_id] != NULL
	 && ahc->enabled_targets[scsi_id] != master_tstate)
		panic("%s: ahc_alloc_tstate - Target already allocated",
		      ahc_name(ahc));
	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
	if (tstate == NULL)
		return (NULL);
d1079 1
d1081 1
a1081 4
	 * If we have allocated a master tstate, copy user settings from
	 * the master tstate (taken from SRAM or the EEPROM) for this
	 * channel, but reset our current and goal settings to async/narrow
	 * until an initiator talks to us.
d1083 8
a1090 14
	if (master_tstate != NULL) {
		memcpy(tstate, master_tstate, sizeof(*tstate));
		memset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));
		tstate->ultraenb = 0;
		for (i = 0; i < 16; i++) {
			memset(&tstate->transinfo[i].curr, 0,
			      sizeof(tstate->transinfo[i].curr));
			memset(&tstate->transinfo[i].goal, 0,
			      sizeof(tstate->transinfo[i].goal));
		}
	} else
		memset(tstate, 0, sizeof(*tstate));
	ahc->enabled_targets[scsi_id] = tstate;
	return (tstate);
d1093 3
a1095 7
#ifdef AHC_TARGET_MODE
/*
 * Free per target mode instance (ID we respond to as a target)
 * transfer negotiation data structures.
 */
static void
ahc_free_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel, int force)
d1097 8
a1104 2
	struct ahc_tmode_tstate *tstate;

d1106 1
a1106 2
	 * Don't clean up our "master" tstate.
	 * It has our default user settings.
d1108 10
a1117 4
	if (((channel == 'B' && scsi_id == ahc->our_id_b)
	  || (channel == 'A' && scsi_id == ahc->our_id))
	 && force == FALSE)
		return;
d1119 22
a1140 6
	if (channel == 'B')
		scsi_id += 8;
	tstate = ahc->enabled_targets[scsi_id];
	if (tstate != NULL)
		free(tstate, M_DEVBUF);
	ahc->enabled_targets[scsi_id] = NULL;
a1141 1
#endif
d1146 1
a1146 2
 * by the capabilities of the bus connectivity of and sync settings for
 * the target.
d1148 5
a1152 5
struct ahc_syncrate *
ahc_devlimited_syncrate(struct ahc_softc *ahc,
			struct ahc_initiator_tinfo *tinfo,
			u_int *period, u_int *ppr_options, role_t role) {
	struct	ahc_transinfo *transinfo;
d1158 1
a1158 1
			maxsync = AHC_SYNCRATE_DT;
a1160 2
			/* Can't do DT on an SE bus */
			*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1167 1
a1167 22
	/*
	 * Never allow a value higher than our current goal
	 * period otherwise we may allow a target initiated
	 * negotiation to go above the limit as set by the
	 * user.  In the case of an initiator initiated
	 * sync negotiation, we limit based on the user
	 * setting.  This allows the system to still accept
	 * incoming negotiations even if target initiated
	 * negotiation is not performed.
	 */
	if (role == ROLE_TARGET)
		transinfo = &tinfo->user;
	else 
		transinfo = &tinfo->goal;
	*ppr_options &= transinfo->ppr_options;
	if (transinfo->period == 0) {
		*period = 0;
		*ppr_options = 0;
		return (NULL);
	}
	*period = MAX(*period, transinfo->period);
	return (ahc_find_syncrate(ahc, period, ppr_options, maxsync));
d1175 5
a1179 3
struct ahc_syncrate *
ahc_find_syncrate(struct ahc_softc *ahc, u_int *period,
		  u_int *ppr_options, u_int maxsync)
d1183 4
a1186 19
	if ((ahc->features & AHC_DT) == 0)
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;

	/* Skip all DT only entries if DT is not available */
	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0
	 && maxsync < AHC_SYNCRATE_ULTRA2)
		maxsync = AHC_SYNCRATE_ULTRA2;
	
	for (syncrate = &ahc_syncrates[maxsync];
	     syncrate->rate != NULL;
	     syncrate++) {

		/*
		 * The Ultra2 table doesn't go as low
		 * as for the Fast/Ultra cards.
		 */
		if ((ahc->features & AHC_ULTRA2) != 0
		 && (syncrate->sxfr_u2 == 0))
			break;
a1201 7

			/*
			 * At some speeds, we only support
			 * ST transfers.
			 */
		 	if ((syncrate->sxfr_u2 & ST_SXFR) != 0)
				*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1204 1
a1213 1
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1218 5
a1222 6
/*
 * Convert from an entry in our syncrate table to the SCSI equivalent
 * sync "period" factor.
 */
u_int
ahc_find_period(struct ahc_softc *ahc, u_int scsirate, u_int maxsync)
d1247 6
a1252 9
/*
 * Truncate the given synchronous offset to a value the
 * current adapter type and syncrate are capable of.
 */
void
ahc_validate_offset(struct ahc_softc *ahc,
		    struct ahc_initiator_tinfo *tinfo,
		    struct ahc_syncrate *syncrate,
		    u_int *offset, int wide, role_t role)
a1267 6
	if (tinfo != NULL) {
		if (role == ROLE_TARGET)
			*offset = MIN(*offset, tinfo->user.offset);
		else
			*offset = MIN(*offset, tinfo->goal.offset);
	}
d1270 7
a1276 7
/*
 * Truncate the given transfer width parameter to a value the
 * current adapter type is capable of.
 */
void
ahc_validate_width(struct ahc_softc *ahc, struct ahc_initiator_tinfo *tinfo,
		   u_int *bus_width, role_t role)
d1278 1
a1278 19
	switch (*bus_width) {
	default:
		if (ahc->features & AHC_WIDE) {
			/* Respond Wide */
			*bus_width = MSG_EXT_WDTR_BUS_16_BIT;
			break;
		}
		/* FALLTHROUGH */
	case MSG_EXT_WDTR_BUS_8_BIT:
		*bus_width = MSG_EXT_WDTR_BUS_8_BIT;
		break;
	}
	if (tinfo != NULL) {
		if (role == ROLE_TARGET)
			*bus_width = MIN(tinfo->user.width, *bus_width);
		else
			*bus_width = MIN(tinfo->goal.width, *bus_width);
	}
}
d1280 7
a1286 23
/*
 * Update the bitmask of targets for which the controller should
 * negotiate with at the next convenient oportunity.  This currently
 * means the next time we send the initial identify messages for
 * a new transaction.
 */
int
ahc_update_neg_request(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		       struct ahc_tmode_tstate *tstate,
		       struct ahc_initiator_tinfo *tinfo, int force)
{
	u_int auto_negotiate_orig;

	auto_negotiate_orig = tstate->auto_negotiate;
	if (tinfo->curr.period != tinfo->goal.period
	 || tinfo->curr.width != tinfo->goal.width
	 || tinfo->curr.offset != tinfo->goal.offset
	 || tinfo->curr.ppr_options != tinfo->goal.ppr_options
	 || (force
	  && (tinfo->goal.period != 0
	   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT
	   || tinfo->goal.ppr_options != 0)))
		tstate->auto_negotiate |= devinfo->target_mask;
d1288 22
a1309 1
		tstate->auto_negotiate &= ~devinfo->target_mask;
d1311 4
a1314 1
	return (auto_negotiate_orig != tstate->auto_negotiate);
d1317 10
a1326 12
/*
 * Update the user/goal/curr tables of synchronous negotiation
 * parameters as well as, in the case of a current or active update,
 * any data structures on the host controller.  In the case of an
 * active update, the specified target is currently talking to us on
 * the bus, so the transfer parameter update must take effect
 * immediately.
 */
void
ahc_set_syncrate(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		 struct ahc_syncrate *syncrate, u_int period,
		 u_int offset, u_int ppr_options, u_int type, int paused)
d1329 1
a1329 1
	struct	ahc_tmode_tstate *tstate;
d1332 1
a1332 6
	u_int	old_ppr;
	int	active;
	int	update_needed;

	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
	update_needed = 0;
d1339 2
a1340 1
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
d1342 2
a1343 16

	if ((type & AHC_TRANS_USER) != 0) {
		tinfo->user.period = period;
		tinfo->user.offset = offset;
		tinfo->user.ppr_options = ppr_options;
	}

	if ((type & AHC_TRANS_GOAL) != 0) {
		tinfo->goal.period = period;
		tinfo->goal.offset = offset;
		tinfo->goal.ppr_options = ppr_options;
	}

	old_period = tinfo->curr.period;
	old_offset = tinfo->curr.offset;
	old_ppr	   = tinfo->curr.ppr_options;
d1346 1
a1346 3
	 && (old_period != period
	  || old_offset != offset
	  || old_ppr != ppr_options)) {
a1348 1
		update_needed++;
d1352 2
d1355 5
a1359 7
			if (syncrate != NULL) {
				scsirate |= syncrate->sxfr_u2;
				if ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0)
					scsirate |= ENABLE_CRC;
				else
					scsirate |= SINGLE_EDGE;
			}
d1386 1
a1386 1
		if (active) {
a1387 3
			if ((ahc->features & AHC_ULTRA2) != 0)
				ahc_outb(ahc, SCSIOFFSET, offset);
		}
d1390 20
a1409 18
		tinfo->curr.period = period;
		tinfo->curr.offset = offset;
		tinfo->curr.ppr_options = ppr_options;

		ahc_send_async(ahc, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (1 /*bootverbose*/) {
			if (offset != 0) {
				printf("%s: target %d synchronous at %sMHz%s, "
				       "offset = 0x%x\n", ahc_name(ahc),
				       devinfo->target, syncrate->rate,
				       (ppr_options & MSG_EXT_PPR_DT_REQ)
				       ? " DT" : "", offset);
			} else {
				printf("%s: target %d using "
				       "asynchronous transfers\n",
				       ahc_name(ahc), devinfo->target);
			}
d1413 9
a1421 2
	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
						tinfo, /*force*/FALSE);
d1423 3
a1425 2
	if (update_needed)
		ahc_update_pending_scbs(ahc);
d1428 8
a1435 11
/*
 * Update the user/goal/curr tables of wide negotiation
 * parameters as well as, in the case of a current or active update,
 * any data structures on the host controller.  In the case of an
 * active update, the specified target is currently talking to us on
 * the bus, so the transfer parameter update must take effect
 * immediately.
 */
void
ahc_set_width(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
	      u_int width, u_int type, int paused)
d1437 4
a1440 5
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	u_int	oldwidth;
	int	active;
	int	update_needed;
d1442 5
a1446 10
	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
	update_needed = 0;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);

	if ((type & AHC_TRANS_USER) != 0)
		tinfo->user.width = width;

	if ((type & AHC_TRANS_GOAL) != 0)
		tinfo->goal.width = width;
a1447 1
	oldwidth = tinfo->curr.width;
a1450 1
		update_needed++;
d1461 2
a1462 1
		tinfo->curr.width = width;
d1464 4
a1467 7
		ahc_send_async(ahc, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (bootverbose) {
			printf("%s: target %d using %dbit transfers\n",
			       ahc_name(ahc), devinfo->target,
			       8 * (0x01 << width));
		}
d1470 7
a1476 4
	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
						tinfo, /*force*/FALSE);
	if (update_needed)
		ahc_update_pending_scbs(ahc);
d1479 5
a1483 6
/*
 * Update the current state of tagged queuing for a given target.
 */
void
ahc_set_tags(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
	     ahc_queue_alg alg)
d1485 13
a1497 3
 	ahc_platform_set_tags(ahc, devinfo, alg);
 	ahc_send_async(ahc, devinfo->channel, devinfo->target,
 		       devinfo->lun, AC_TRANSFER_NEG, &alg);
d1501 1
a1501 3
 * When the transfer settings for a connection change, update any
 * in-transit SCBs to contain the new data so the hardware will
 * be set correctly during future (re)selections.
d1503 3
a1505 2
static void
ahc_update_pending_scbs(struct ahc_softc *ahc)
d1507 4
a1510 5
	struct	scb *pending_scb;
	int	pending_scb_count;
	int	i;
	int	paused;
	u_int	saved_scbptr;
d1512 4
d1517 1
a1517 2
	 * Traverse the pending SCB list and ensure that all of the
	 * SCBs there have the proper settings.
d1519 15
a1533 25
	pending_scb_count = 0;
	LIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {
		struct ahc_devinfo devinfo;
		struct hardware_scb *pending_hscb;
		struct ahc_initiator_tinfo *tinfo;
		struct ahc_tmode_tstate *tstate;

		ahc_scb_devinfo(ahc, &devinfo, pending_scb);
		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
					    devinfo.our_scsiid,
					    devinfo.target, &tstate);
		pending_hscb = pending_scb->hscb;
		pending_hscb->control &= ~ULTRAENB;
		if ((tstate->ultraenb & devinfo.target_mask) != 0)
			pending_hscb->control |= ULTRAENB;
		pending_hscb->scsirate = tinfo->scsirate;
		pending_hscb->scsioffset = tinfo->curr.offset;
		if ((tstate->auto_negotiate & devinfo.target_mask) == 0
		 && (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {
			pending_scb->flags &= ~SCB_AUTO_NEGOTIATE;
			pending_hscb->control &= ~MK_MESSAGE;
		}
		ahc_sync_scb(ahc, pending_scb,
			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
		pending_scb_count++;
d1536 6
a1541 2
	if (pending_scb_count == 0)
		return;
d1543 3
a1545 2
	if (ahc_is_paused(ahc)) {
		paused = 1;
d1547 5
a1551 16
		paused = 0;
		ahc_pause(ahc);
	}

	saved_scbptr = ahc_inb(ahc, SCBPTR);
	/* Ensure that the hscbs down on the card match the new information */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		struct	hardware_scb *pending_hscb;
		u_int	control;
		u_int	scb_tag;

		ahc_outb(ahc, SCBPTR, i);
		scb_tag = ahc_inb(ahc, SCB_TAG);
		pending_scb = ahc_lookup_scb(ahc, scb_tag);
		if (pending_scb == NULL)
			continue;
d1553 3
a1555 7
		pending_hscb = pending_scb->hscb;
		control = ahc_inb(ahc, SCB_CONTROL);
		control &= ~(ULTRAENB|MK_MESSAGE);
		control |= pending_hscb->control & (ULTRAENB|MK_MESSAGE);
		ahc_outb(ahc, SCB_CONTROL, control);
		ahc_outb(ahc, SCB_SCSIRATE, pending_hscb->scsirate);
		ahc_outb(ahc, SCB_SCSIOFFSET, pending_hscb->scsioffset);
d1557 1
a1557 4
	ahc_outb(ahc, SCBPTR, saved_scbptr);

	if (paused == 0)
		ahc_unpause(ahc);
d1560 4
a1563 3
/**************************** Pathing Information *****************************/
static void
ahc_fetch_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
d1565 1
a1565 1
	u_int	saved_scsiid;
d1584 3
a1586 6
	saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
	ahc_compile_devinfo(devinfo,
			    our_id,
			    SCSIID_TARGET(ahc, saved_scsiid),
			    ahc_inb(ahc, SAVED_LUN),
			    SCSIID_CHANNEL(ahc, saved_scsiid),
d1590 8
a1597 21
struct ahc_phase_table_entry*
ahc_lookup_phase_entry(int phase)
{
	struct ahc_phase_table_entry *entry;
	struct ahc_phase_table_entry *last_entry;

	/*
	 * num_phases doesn't include the default entry which
	 * will be returned if the phase doesn't match.
	 */
	last_entry = &ahc_phase_table[num_phases];
	for (entry = ahc_phase_table; entry < last_entry; entry++) {
		if (phase == entry->phase)
			break;
	}
	return (entry);
}

void
ahc_compile_devinfo(struct ahc_devinfo *devinfo, u_int our_id, u_int target,
		    u_int lun, char channel, role_t role)
a1609 28
static void
ahc_scb_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		struct scb *scb)
{
	role_t	role;
	int	our_id;

	our_id = SCSIID_OUR_ID(scb->hscb->scsiid);
	role = ROLE_INITIATOR;
	if ((scb->hscb->control & TARGET_SCB) != 0)
		role = ROLE_TARGET;
	ahc_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahc, scb),
			    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahc, scb), role);
}


/************************ Message Phase Processing ****************************/
static void
ahc_assert_atn(struct ahc_softc *ahc)
{
	u_int scsisigo;

	scsisigo = ATNO;
	if ((ahc->features & AHC_DT) == 0)
		scsisigo |= ahc_inb(ahc, SCSISIGI);
	ahc_outb(ahc, SCSISIGO, scsisigo);
}

d1611 1
a1611 4
 * When an initiator transaction with the MK_MESSAGE flag either reconnects
 * or enters the initial message out phase, we are interrupted.  Fill our
 * outgoing message buffer with the appropriate message and beging handing
 * the message phase(s) manually.
d1613 2
a1614 3
static void
ahc_setup_initiator_msgout(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
			   struct scb *scb)
d1616 2
a1617 7
	/*
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;
d1619 1
a1619 3
	if ((scb->flags & SCB_DEVICE_RESET) == 0
	 && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {
		u_int identify_msg;
d1621 1
a1621 5
		identify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);
		if ((scb->hscb->control & DISCENB) != 0)
			identify_msg |= MSG_IDENTIFY_DISCFLAG;
		ahc->msgout_buf[ahc->msgout_index++] = identify_msg;
		ahc->msgout_len++;
d1623 19
a1641 5
		if ((scb->hscb->control & TAG_ENB) != 0) {
			ahc->msgout_buf[ahc->msgout_index++] =
			    scb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);
			ahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;
			ahc->msgout_len += 2;
d1643 1
d1646 5
a1650 5
	if (scb->flags & SCB_DEVICE_RESET) {
		ahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;
		ahc->msgout_len++;
		ahc_print_path(ahc, scb);
		printf("Bus Device Reset Message Sent\n");
d1652 2
a1653 5
		 * Clear our selection hardware in advance of
		 * the busfree.  We may have an entry in the waiting
		 * Q for this target, and we don't want to go about
		 * selecting while we handle the busfree and blow it
		 * away.
d1655 15
a1669 28
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else if ((scb->flags & SCB_ABORT) != 0) {
		if ((scb->hscb->control & TAG_ENB) != 0)
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;
		else
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;
		ahc->msgout_len++;
		ahc_print_path(ahc, scb);
		printf("Abort%s Message Sent\n",
		       (scb->hscb->control & TAG_ENB) != 0 ? " Tag" : "");
		/*
		 * Clear our selection hardware in advance of
		 * the busfree.  We may have an entry in the waiting
		 * Q for this target, and we don't want to go about
		 * selecting while we handle the busfree and blow it
		 * away.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {
		ahc_build_transfer_msg(ahc, devinfo);
	} else {
		printf("ahc_intr: AWAITING_MSG for an SCB that "
		       "does not have a waiting message\n");
		printf("SCSIID = %x, target_mask = %x\n", scb->hscb->scsiid,
		       devinfo->target_mask);
		panic("SCB = %d, SCB Control = %x, MSG_OUT = %x "
		      "SCB flags = %x", scb->hscb->tag, scb->hscb->control,
		      ahc_inb(ahc, MSG_OUT), scb->flags);
d1671 2
d1674 3
a1676 8
	/*
	 * Clear the MK_MESSAGE flag from the SCB so we aren't
	 * asked to send this message again.
	 */
	ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);
	scb->hscb->control &= ~MK_MESSAGE;
	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
d1679 5
a1683 6
/*
 * Build an appropriate transfer negotiation message for the
 * currently active target.
 */
static void
ahc_build_transfer_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
d1685 3
a1687 15
	/*
	 * We need to initiate transfer negotiations.
	 * If our current and goal settings are identical,
	 * we want to renegotiate due to a check condition.
	 */
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	struct	ahc_syncrate *rate;
	int	dowide;
	int	dosync;
	int	doppr;
	int	use_ppr;
	u_int	period;
	u_int	ppr_options;
	u_int	offset;
d1689 4
a1692 23
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	/*
	 * Filter our period based on the current connection.
	 * If we can't perform DT transfers on this segment (not in LVD
	 * mode for instance), then our decision to issue a PPR message
	 * may change.
	 */
	period = tinfo->goal.period;
	ppr_options = tinfo->goal.ppr_options;
	/* Target initiated PPR is not allowed in the SCSI spec */
	if (devinfo->role == ROLE_TARGET)
		ppr_options = 0;
	rate = ahc_devlimited_syncrate(ahc, tinfo, &period,
				       &ppr_options, devinfo->role);
	dowide = tinfo->curr.width != tinfo->goal.width;
	dosync = tinfo->curr.period != period;
	doppr = tinfo->curr.ppr_options != ppr_options;

	if (!dowide && !dosync && !doppr) {
		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
		dosync = tinfo->goal.period != 0;
		doppr = tinfo->goal.ppr_options != 0;
d1694 7
d1702 22
a1723 4
	if (!dowide && !dosync && !doppr) {
		panic("ahc_intr: AWAITING_MSG for negotiation, "
		      "but no negotiation needed\n");	
	}
d1725 9
a1733 4
	use_ppr = (tinfo->curr.transport_version >= 3) || doppr;
	/* Target initiated PPR is not allowed in the SCSI spec */
	if (devinfo->role == ROLE_TARGET)
		use_ppr = 0;
d1736 4
a1739 6
	 * Both the PPR message and SDTR message require the
	 * goal syncrate to be limited to what the target device
	 * is capable of handling (based on whether an LVD->SE
	 * expander is on the bus), so combine these two cases.
	 * Regardless, guarantee that if we are using WDTR and SDTR
	 * messages that WDTR comes first.
d1741 7
a1747 1
	if (use_ppr || (dosync && !dowide)) {
d1749 13
a1761 13
		offset = tinfo->goal.offset;
		ahc_validate_offset(ahc, tinfo, rate, &offset,
				    use_ppr ? tinfo->goal.width
					    : tinfo->curr.width,
				    devinfo->role);
		if (use_ppr) {
			ahc_construct_ppr(ahc, devinfo, period, offset,
					  tinfo->goal.width, ppr_options);
		} else {
			ahc_construct_sdtr(ahc, devinfo, period, offset);
		}
	} else {
		ahc_construct_wdtr(ahc, devinfo, tinfo->goal.width);
d1763 13
a1775 20
}

/*
 * Build a synchronous negotiation message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_sdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		   u_int period, u_int offset)
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_len += 5;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       devinfo->lun, period, offset);
d1777 10
a1786 1
}
d1788 10
a1797 17
/*
 * Build a wide negotiateion message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_wdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		   u_int bus_width)
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_len += 4;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending WDTR %x\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       devinfo->lun, bus_width);
d1799 3
a1801 1
}
d1803 14
a1816 23
/*
 * Build a parallel protocol request message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_ppr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		  u_int period, u_int offset, u_int bus_width,
		  u_int ppr_options)
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = 0;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_buf[ahc->msgout_index++] = ppr_options;
	ahc->msgout_len += 8;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "
		       "offset %x, ppr_options %x\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target, devinfo->lun,
		       bus_width, period, offset, ppr_options);
d1818 16
a1833 1
}
a1834 10
/*
 * Clear any active message state.
 */
static void
ahc_clear_msg_state(struct ahc_softc *ahc)
{
	ahc->msgout_len = 0;
	ahc->msgin_index = 0;
	ahc->msg_type = MSG_TYPE_NONE;
	if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0) {
d1836 3
a1838 2
		 * The target didn't care to respond to our
		 * message request, so clear ATN.
d1840 58
a1897 4
		ahc_outb(ahc, CLRSINT1, CLRATNO);
	}
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
}
d1899 10
a1908 9
/*
 * Manual message loop handler.
 */
static void
ahc_handle_message_phase(struct ahc_softc *ahc)
{ 
	struct	ahc_devinfo devinfo;
	u_int	bus_phase;
	int	end_session;
d1910 6
a1915 3
	ahc_fetch_devinfo(ahc, &devinfo);
	end_session = FALSE;
	bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
d1917 5
a1921 7
reswitch:
	switch (ahc->msg_type) {
	case MSG_TYPE_INITIATOR_MSGOUT:
	{
		int lastbyte;
		int phasemis;
		int msgdone;
d1923 48
a1970 2
		if (ahc->msgout_len == 0)
			panic("HOST_MSG_LOOP interrupt with no active message");
a1971 3
		phasemis = bus_phase != P_MESGOUT;
		if (phasemis) {
			if (bus_phase == P_MESGIN) {
d1973 2
a1974 4
				 * Change gears and see if
				 * this messages is of interest to
				 * us or should be passed back to
				 * the sequencer.
d1976 2
a1977 5
				ahc_outb(ahc, CLRSINT1, CLRATNO);
				ahc->send_msg_perror = FALSE;
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;
				ahc->msgin_index = 0;
				goto reswitch;
a1978 8
			end_session = TRUE;
			break;
		}

		if (ahc->send_msg_perror) {
			ahc_outb(ahc, CLRSINT1, CLRATNO);
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
			ahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);
d1980 1
a1980 4
		}

		msgdone	= ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
d1982 2
a1983 3
			 * The target has requested a retry.
			 * Re-assert ATN, reset our message index to
			 * 0, and try again.
d1985 3
a1987 2
			ahc->msgout_index = 0;
			ahc_assert_atn(ahc);
a1988 13

		lastbyte = ahc->msgout_index == (ahc->msgout_len - 1);
		if (lastbyte) {
			/* Last byte is signified by dropping ATN */
			ahc_outb(ahc, CLRSINT1, CLRATNO);
		}

		/*
		 * Clear our interrupt status and present
		 * the next byte on the bus.
		 */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
d1991 12
a2002 1
	case MSG_TYPE_INITIATOR_MSGIN:
d2004 12
a2015 2
		int phasemis;
		int message_done;
d2017 12
a2028 10
		phasemis = bus_phase != P_MESGIN;

		if (phasemis) {
			ahc->msgin_index = 0;
			if (bus_phase == P_MESGOUT
			 && (ahc->send_msg_perror == TRUE
			  || (ahc->msgout_len != 0
			   && ahc->msgout_index == 0))) {
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
				goto reswitch;
a2029 3
			end_session = TRUE;
			break;
		}
d2031 3
a2033 2
		/* Pull the byte in without acking it */
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);
d2035 2
a2036 1
		message_done = ahc_parse_msg(ahc, &devinfo);
d2038 19
a2056 16
		if (message_done) {
			/*
			 * Clear our incoming message buffer in case there
			 * is another message following this one.
			 */
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response,
			 * assert ATN so the target takes us to the
			 * message out phase.
			 */
			if (ahc->msgout_len != 0)
				ahc_assert_atn(ahc);
		} else 
			ahc->msgin_index++;
d2058 2
a2059 3
		/* Ack the byte */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_inb(ahc, SCSIDATL);
d2062 1
a2062 1
	case MSG_TYPE_TARGET_MSGIN:
a2063 6
		int msgdone;
		int msgout_request;

		if (ahc->msgout_len == 0)
			panic("Target MSGIN with no active message");

d2065 9
a2073 4
		 * If we interrupted a mesgout session, the initiator
		 * will not know this until our first REQ.  So, we
		 * only honor mesgout requests after we've sent our
		 * first byte.
d2075 3
a2077 7
		if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0
		 && ahc->msgout_index > 0)
			msgout_request = TRUE;
		else
			msgout_request = FALSE;

		if (msgout_request) {
d2080 4
a2083 4
			 * Change gears and see if
			 * this messages is of interest to
			 * us or should be passed back to
			 * the sequencer.
d2085 3
a2087 4
			ahc->msg_type = MSG_TYPE_TARGET_MSGOUT;
			ahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);
			ahc->msgin_index = 0;
			/* Dummy read to REQ for first byte */
a2088 11
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
			break;
		}

		msgdone = ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
			end_session = TRUE;
			break;
a2089 6

		/*
		 * Present the next byte on the bus.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
d2092 1
a2092 1
	case MSG_TYPE_TARGET_MSGOUT:
a2093 3
		int lastbyte;
		int msgdone;

d2095 6
a2100 2
		 * The initiator signals that this is
		 * the last byte by dropping ATN.
d2102 3
a2104 1
		lastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;
d2106 4
a2109 16
		/*
		 * Read the latched byte, but turn off SPIOEN first
		 * so that we don't inadvertantly cause a REQ for the
		 * next byte.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);
		msgdone = ahc_parse_msg(ahc, &devinfo);
		if (msgdone == MSGLOOP_TERMINATED) {
			/*
			 * The message is *really* done in that it caused
			 * us to go to bus free.  The sequencer has already
			 * been reset at this point, so pull the ejection
			 * handle.
			 */
			return;
d2111 15
a2125 21
		
		ahc->msgin_index++;

		/*
		 * XXX Read spec about initiator dropping ATN too soon
		 *     and use msgdone to detect it.
		 */
		if (msgdone == MSGLOOP_MSGCOMPLETE) {
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response, transition
			 * to the Message in phase and send it.
			 */
			if (ahc->msgout_len != 0) {
				ahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);
				ahc_outb(ahc, SXFRCTL0,
					 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
				ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
				ahc->msgin_index = 0;
				break;
d2128 32
a2159 9

		if (lastbyte)
			end_session = TRUE;
		else {
			/* Ask for the next byte. */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		}

d2162 7
d2170 4
a2173 1
		panic("Unknown REQINIT message type");
d2175 8
a2182 6

	if (end_session) {
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);
	} else
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
d2185 4
a2188 8
/*
 * See if we sent a particular extended message to the target.
 * If "full" is true, return true only if the target saw the full
 * message.  If "full" is false, return true if the target saw at
 * least the first byte of the message.
 */
static int
ahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type, u_int msgval, int full)
d2190 12
a2201 2
	int found;
	u_int index;
d2203 14
a2216 2
	found = FALSE;
	index = 0;
d2218 8
a2225 3
	while (index < ahc->msgout_len) {
		if (ahc->msgout_buf[index] == MSG_EXTENDED) {
			u_int end_index;
d2227 20
a2246 3
			end_index = index + 1 + ahc->msgout_buf[index + 1];
			if (ahc->msgout_buf[index+2] == msgval
			 && type == AHCMSG_EXT) {
d2248 19
a2266 9
				if (full) {
					if (ahc->msgout_index > end_index)
						found = TRUE;
				} else if (ahc->msgout_index > index)
					found = TRUE;
			}
			index = end_index;
		} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_TASK
			&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
d2268 3
a2270 9
			/* Skip tag type and tag id or residue param*/
			index += 2;
		} else {
			/* Single byte message */
			if (type == AHCMSG_1B
			 && ahc->msgout_buf[index] == msgval
			 && ahc->msgout_index > index)
				found = TRUE;
			index++;
d2272 13
d2286 29
a2314 5
		if (found)
			break;
	}
	return (found);
}
d2316 5
a2320 12
/*
 * Wait for a complete incoming message, parse it, and respond accordingly.
 */
static int
ahc_parse_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	int	reject;
	int	done;
	int	response;
	u_int	targ_scsirate;
d2322 16
a2337 41
	done = MSGLOOP_IN_PROG;
	response = FALSE;
	reject = FALSE;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	targ_scsirate = tinfo->scsirate;

	/*
	 * Parse as much of the message as is availible,
	 * rejecting it if we don't support it.  When
	 * the entire message is availible and has been
	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
	 * that we have parsed an entire message.
	 *
	 * In the case of extended messages, we accept the length
	 * byte outright and perform more checking once we know the
	 * extended message type.
	 */
	switch (ahc->msgin_buf[0]) {
	case MSG_MESSAGE_REJECT:
		response = ahc_handle_msg_reject(ahc, devinfo);
		/* FALLTHROUGH */
	case MSG_NOOP:
		done = MSGLOOP_MSGCOMPLETE;
		break;
	case MSG_EXTENDED:
	{
		/* Wait for enough of the message to begin validation */
		if (ahc->msgin_index < 2)
			break;
		switch (ahc->msgin_buf[2]) {
		case MSG_EXT_SDTR:
		{
			struct	 ahc_syncrate *syncrate;
			u_int	 period;
			u_int	 ppr_options;
			u_int	 offset;
			u_int	 saved_offset;
			
			if (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
				reject = TRUE;
d2339 3
a2341 1
			}
d2343 19
a2361 8
			/*
			 * Wait until we have both args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_SDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))
a2362 53

			period = ahc->msgin_buf[3];
			ppr_options = 0;
			saved_offset = offset = ahc->msgin_buf[4];
			syncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,
							   &ppr_options,
							   devinfo->role);
			ahc_validate_offset(ahc, tinfo, syncrate, &offset,
					    targ_scsirate & WIDEXFER,
					    devinfo->role);
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received "
				       "SDTR period %x, offset %x\n\t"
				       "Filtered to period %x, offset %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       ahc->msgin_buf[3], saved_offset,
				       period, offset);
			}
			ahc_set_syncrate(ahc, devinfo, 
					 syncrate, period,
					 offset, ppr_options,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE);

			/*
			 * See if we initiated Sync Negotiation
			 * and didn't have to fall down to async
			 * transfers.
			 */
			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, TRUE)) {
				/* We started it */
				if (saved_offset != offset) {
					/* Went too low - force async */
					reject = TRUE;
				}
			} else {
				/*
				 * Send our own SDTR in reply
				 */
				if (bootverbose
				 && devinfo->role == ROLE_INITIATOR) {
					printf("(%s:%c:%d:%d): Target "
					       "Initiated SDTR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_sdtr(ahc, devinfo,
						   period, offset);
				ahc->msgout_index = 0;
				response = TRUE;
d2364 1
a2364 12
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		case MSG_EXT_WDTR:
		{
			u_int bus_width;
			u_int saved_width;
			u_int sending_reply;

			sending_reply = FALSE;
			if (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
				reject = TRUE;
d2367 3
d2371 2
a2372 9
			/*
			 * Wait until we have our arg before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_WDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))
				break;
d2374 9
a2382 28
			bus_width = ahc->msgin_buf[3];
			saved_width = bus_width;
			ahc_validate_width(ahc, tinfo, &bus_width,
					   devinfo->role);
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received WDTR "
				       "%x filtered to %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       saved_width, bus_width);
			}

			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, TRUE)) {
				/*
				 * Don't send a WDTR back to the
				 * target, since we asked first.
				 * If the width went higher than our
				 * request, reject it.
				 */
				if (saved_width > bus_width) {
					reject = TRUE;
					printf("(%s:%c:%d:%d): requested %dBit "
					       "transfers.  Rejecting...\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun,
					       8 * (0x01 << bus_width));
					bus_width = 0;
				}
d2385 2
a2386 1
				 * Send our own WDTR in reply
d2388 1
a2388 13
				if (bootverbose
				 && devinfo->role == ROLE_INITIATOR) {
					printf("(%s:%c:%d:%d): Target "
					       "Initiated WDTR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_wdtr(ahc, devinfo, bus_width);
				ahc->msgout_index = 0;
				response = TRUE;
				sending_reply = TRUE;
d2390 3
a2392 17
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE);
			/* After a wide message, we are async */
			ahc_set_syncrate(ahc, devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, /*ppr_options*/0,
					 AHC_TRANS_ACTIVE, /*paused*/TRUE);
			if (sending_reply == FALSE && reject == FALSE) {

				if (tinfo->goal.period) {
					ahc->msgout_index = 0;
					ahc->msgout_len = 0;
					ahc_build_transfer_msg(ahc, devinfo);
					ahc->msgout_index = 0;
					response = TRUE;
				}
d2394 4
a2397 2
			done = MSGLOOP_MSGCOMPLETE;
			break;
d2399 7
a2405 10
		case MSG_EXT_PPR:
		{
			struct	ahc_syncrate *syncrate;
			u_int	period;
			u_int	offset;
			u_int	bus_width;
			u_int	ppr_options;
			u_int	saved_width;
			u_int	saved_offset;
			u_int	saved_ppr_options;
d2407 3
a2409 4
			if (ahc->msgin_buf[1] != MSG_EXT_PPR_LEN) {
				reject = TRUE;
				break;
			}
d2411 6
a2416 9
			/*
			 * Wait until we have all args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_PPR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_PPR_LEN + 1))
				break;
d2418 6
a2423 15
			period = ahc->msgin_buf[3];
			offset = ahc->msgin_buf[5];
			bus_width = ahc->msgin_buf[6];
			saved_width = bus_width;
			ppr_options = ahc->msgin_buf[7];
			/*
			 * According to the spec, a DT only
			 * period factor with no DT option
			 * set implies async.
			 */
			if ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0
			 && period == 9)
				offset = 0;
			saved_ppr_options = ppr_options;
			saved_offset = offset;
d2425 3
a2427 17
			/*
			 * Mask out any options we don't support
			 * on any controller.  Transfer options are
			 * only available if we are negotiating wide.
			 */
			ppr_options &= MSG_EXT_PPR_DT_REQ;
			if (bus_width == 0)
				ppr_options = 0;

			ahc_validate_width(ahc, tinfo, &bus_width,
					   devinfo->role);
			syncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,
							   &ppr_options,
							   devinfo->role);
			ahc_validate_offset(ahc, tinfo, syncrate,
					    &offset, bus_width,
					    devinfo->role);
d2429 3
a2431 55
			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, TRUE)) {
				/*
				 * If we are unable to do any of the
				 * requested options (we went too low),
				 * then we'll have to reject the message.
				 */
				if (saved_width > bus_width
				 || saved_offset != offset
				 || saved_ppr_options != ppr_options) {
					reject = TRUE;
					period = 0;
					offset = 0;
					bus_width = 0;
					ppr_options = 0;
					syncrate = NULL;
				}
			} else {
				if (devinfo->role != ROLE_TARGET)
					printf("(%s:%c:%d:%d): Target "
					       "Initiated PPR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				else
					printf("(%s:%c:%d:%d): Initiator "
					       "Initiated PPR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_ppr(ahc, devinfo, period, offset,
						  bus_width, ppr_options);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received PPR width %x, "
				       "period %x, offset %x,options %x\n"
				       "\tFiltered to width %x, period %x, "
				       "offset %x, options %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       saved_width, ahc->msgin_buf[3],
				       saved_offset, saved_ppr_options,
				       bus_width, period, offset, ppr_options);
			}
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE);
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period,
					 offset, ppr_options,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE);
			done = MSGLOOP_MSGCOMPLETE;
			break;
d2433 71
a2503 6
		default:
			/* Unknown extended message.  Reject it. */
			reject = TRUE;
			break;
		}
		break;
d2505 19
a2523 23
	case MSG_BUS_DEV_RESET:
		ahc_handle_devreset(ahc, devinfo,
				    CAM_BDR_SENT,
				    "Bus Device Reset Received",
				    /*verbose_level*/0);
		ahc_restart(ahc);
		done = MSGLOOP_TERMINATED;
		break;
	case MSG_ABORT_TAG:
	case MSG_ABORT:
	case MSG_CLEAR_QUEUE:
#ifdef AHC_TARGET_MODE
		/* Target mode messages */
		if (devinfo->role != ROLE_TARGET) {
			reject = TRUE;
			break;
		}
		ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       devinfo->lun,
			       ahc->msgin_buf[0] == MSG_ABORT_TAG
						  ? SCB_LIST_NULL
						  : ahc_inb(ahc, INITIATOR_TAG),
			       ROLE_TARGET, CAM_REQ_ABORTED);
d2525 5
a2529 3
		tstate = ahc->enabled_targets[devinfo->our_scsiid];
		if (tstate != NULL) {
			struct ahc_tmode_lstate* lstate;
d2531 5
a2535 8
			lstate = tstate->enabled_luns[devinfo->lun];
			if (lstate != NULL) {
				ahc_queue_lstate_event(ahc, lstate,
						       devinfo->our_scsiid,
						       ahc->msgin_buf[0],
						       /*arg*/0);
				ahc_send_lstate_events(ahc, lstate);
			}
a2536 7
		done = MSGLOOP_MSGCOMPLETE;
		break;
#endif
	case MSG_TERM_IO_PROC:
	default:
		reject = TRUE;
		break;
d2539 45
a2583 10
	if (reject) {
		/*
		 * Setup to reject the message.
		 */
		ahc->msgout_index = 0;
		ahc->msgout_len = 1;
		ahc->msgout_buf[0] = MSG_MESSAGE_REJECT;
		done = MSGLOOP_MSGCOMPLETE;
		response = TRUE;
	}
d2585 4
a2588 3
	if (done != MSGLOOP_IN_PROG && !response)
		/* Clear the outgoing message buffer */
		ahc->msgout_len = 0;
d2590 2
a2591 1
	return (done);
d2594 4
a2597 5
/*
 * Process a message reject message.
 */
static int
ahc_handle_msg_reject(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
a2605 2
	struct ahc_initiator_tinfo *tinfo;
	struct ahc_tmode_tstate *tstate;
d2611 2
a2612 4
	scb = ahc_lookup_scb(ahc, scb_index);
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
d2616 3
a2618 20
	if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, /*full*/FALSE)) {
		/*
		 * Target does not support the PPR message.
		 * Attempt to negotiate SPI-2 style.
		 */
		if (bootverbose) {
			printf("(%s:%c:%d:%d): PPR Rejected. "
			       "Trying WDTR/SDTR\n",
			       ahc_name(ahc), devinfo->channel,
			       devinfo->target, devinfo->lun);
		}
		tinfo->goal.ppr_options = 0;
		tinfo->curr.transport_version = 2;
		tinfo->goal.transport_version = 2;
		ahc->msgout_index = 0;
		ahc->msgout_len = 0;
		ahc_build_transfer_msg(ahc, devinfo);
		ahc->msgout_index = 0;
		response = 1;
	} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, /*full*/FALSE)) {
d2621 6
a2626 4
		printf("(%s:%c:%d:%d): refuses WIDE negotiation.  Using "
		       "8bit transfers\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target, devinfo->lun);
		ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
d2628 1
a2628 1
			      /*paused*/TRUE);
d2636 3
d2640 1
d2643 2
d2647 1
a2647 1
			ahc_build_transfer_msg(ahc, devinfo);
d2651 1
a2651 1
	} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, /*full*/FALSE)) {
d2654 1
a2654 1
				 /*offset*/0, /*ppr_options*/0,
d2656 14
a2669 26
				 /*paused*/TRUE);
		printf("(%s:%c:%d:%d): refuses synchronous negotiation. "
		       "Using asynchronous transfers\n",
		       ahc_name(ahc), devinfo->channel,
		       devinfo->target, devinfo->lun);
	} else if ((scb->hscb->control & MSG_SIMPLE_TASK) != 0) {
		int tag_type;
		int mask;

		tag_type = (scb->hscb->control & MSG_SIMPLE_TASK);

		if (tag_type == MSG_SIMPLE_TASK) {
			printf("(%s:%c:%d:%d): refuses tagged commands.  "
			       "Performing non-tagged I/O\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target, devinfo->lun);
			ahc_set_tags(ahc, devinfo, AHC_QUEUE_NONE);
			mask = ~0x23;
		} else {
			printf("(%s:%c:%d:%d): refuses %s tagged commands.  "
			       "Performing simple queue tagged I/O only\n",
			       ahc_name(ahc), devinfo->channel, devinfo->target,
			       devinfo->lun, tag_type == MSG_ORDERED_TASK
			       ? "ordered" : "head of queue");
			ahc_set_tags(ahc, devinfo, AHC_QUEUE_BASIC);
			mask = ~0x03;
		}
d2675 3
a2677 5
		ahc_outb(ahc, SCB_CONTROL,
			 ahc_inb(ahc, SCB_CONTROL) & mask);
	 	scb->hscb->control &= mask;
		ahc_set_transaction_tag(scb, /*enabled*/FALSE,
					/*type*/MSG_SIMPLE_TASK);
d2679 1
a2679 16
		ahc_assert_atn(ahc);

		/*
		 * This transaction is now at the head of
		 * the untagged queue for this target.
		 */
		if ((ahc->flags & AHC_SCB_BTT) == 0) {
			struct scb_tailq *untagged_q;

			untagged_q =
			    &(ahc->untagged_queues[devinfo->target_offset]);
			TAILQ_INSERT_HEAD(untagged_q, scb, links.tqe);
			scb->flags |= SCB_UNTAGGEDQ;
		}
		ahc_busy_tcl(ahc, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),
			     scb->hscb->tag);
d2686 3
a2688 4
		ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
				   SCB_GET_CHANNEL(ahc, scb),
				   SCB_GET_LUN(scb), /*tag*/SCB_LIST_NULL,
				   ROLE_INITIATOR, CAM_REQUEUE_REQ,
d2701 3
a2703 5
/*
 * Process an ingnore wide residue message.
 */
static void
ahc_handle_ign_wide_residue(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
d2705 5
a2709 2
	u_int scb_index;
	struct scb *scb;
d2711 8
a2718 21
	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	/*
	 * XXX Actually check data direction in the sequencer?
	 * Perhaps add datadir to some spare bits in the hscb?
	 */
	if ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0
	 || ahc_get_transfer_dir(scb) != CAM_DIR_IN) {
		/*
		 * Ignore the message if we haven't
		 * seen an appropriate data phase yet.
		 */
	} else {
		/*
		 * If the residual occurred on the last
		 * transfer and the transfer request was
		 * expected to end on an odd count, do
		 * nothing.  Otherwise, subtract a byte
		 * and update the residual count accordingly.
		 */
		uint32_t sgptr;
d2720 3
a2722 24
		sgptr = ahc_inb(ahc, SCB_RESIDUAL_SGPTR);
		if ((sgptr & SG_LIST_NULL) != 0
		 && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {
			/*
			 * If the residual occurred on the last
			 * transfer and the transfer request was
			 * expected to end on an odd count, do
			 * nothing.
			 */
		} else {
			struct ahc_dma_seg *sg;
			uint32_t data_cnt;
			uint32_t data_addr;
			uint32_t sglen;

			/* Pull in the rest of the sgptr */
			sgptr |= (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8);
			sgptr &= SG_PTR_MASK;
			data_cnt = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+3) << 24)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+2) << 16)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+1) << 8)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT));
d2724 7
a2730 4
			data_addr = (ahc_inb(ahc, SHADDR + 3) << 24)
				  | (ahc_inb(ahc, SHADDR + 2) << 16)
				  | (ahc_inb(ahc, SHADDR + 1) << 8)
				  | (ahc_inb(ahc, SHADDR));
d2732 2
a2733 2
			data_cnt += 1;
			data_addr -= 1;
d2735 3
a2737 12
			sg = ahc_sg_bus_to_virt(scb, sgptr);
			/*
			 * The residual sg ptr points to the next S/G
			 * to load so we must go back one.
			 */
			sg--;
			sglen = ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
			if (sg != scb->sg_list
			 && sglen < (data_cnt & AHC_SG_LEN_MASK)) {

				sg--;
				sglen = ahc_le32toh(sg->len);
d2739 4
a2742 2
				 * Preserve High Address and SG_LIST bits
				 * while setting the count to 1.
d2744 5
a2748 17
				data_cnt = 1 | (sglen & (~AHC_SG_LEN_MASK));
				data_addr = ahc_le32toh(sg->addr)
					  + (sglen & AHC_SG_LEN_MASK) - 1;

				/*
				 * Increment sg so it points to the
				 * "next" sg.
				 */
				sg++;
				sgptr = ahc_sg_virt_to_bus(scb, sg);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 3,
					 sgptr >> 24);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 2,
					 sgptr >> 16);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 1,
					 sgptr >> 8);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR, sgptr);
d2750 3
d2754 5
a2758 4
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 3, data_cnt >> 24);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 2, data_cnt >> 16);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 1, data_cnt >> 8);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT, data_cnt);
a2759 2
	}
}
d2761 10
d2772 4
a2775 91
/*
 * Reinitialize the data pointers for the active transfer
 * based on its current residual.
 */
static void
ahc_reinitialize_dataptrs(struct ahc_softc *ahc)
{
	struct	 scb *scb;
	struct	 ahc_dma_seg *sg;
	u_int	 scb_index;
	uint32_t sgptr;
	uint32_t resid;
	uint32_t dataptr;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	sgptr = (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
	      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
	      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8)
	      |	ahc_inb(ahc, SCB_RESIDUAL_SGPTR);

	sgptr &= SG_PTR_MASK;
	sg = ahc_sg_bus_to_virt(scb, sgptr);

	/* The residual sg_ptr always points to the next sg */
	sg--;

	resid = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 2) << 16)
	      | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 1) << 8)
	      | ahc_inb(ahc, SCB_RESIDUAL_DATACNT);

	dataptr = ahc_le32toh(sg->addr)
		+ (ahc_le32toh(sg->len) & AHC_SG_LEN_MASK)
		- resid;
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		u_int dscommand1;

		dscommand1 = ahc_inb(ahc, DSCOMMAND1);
		ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
		ahc_outb(ahc, HADDR,
			 (ahc_le32toh(sg->len) >> 24) & SG_HIGH_ADDR_BITS);
		ahc_outb(ahc, DSCOMMAND1, dscommand1);
	}
	ahc_outb(ahc, HADDR + 3, dataptr >> 24);
	ahc_outb(ahc, HADDR + 2, dataptr >> 16);
	ahc_outb(ahc, HADDR + 1, dataptr >> 8);
	ahc_outb(ahc, HADDR, dataptr);
	ahc_outb(ahc, HCNT + 2, resid >> 16);
	ahc_outb(ahc, HCNT + 1, resid >> 8);
	ahc_outb(ahc, HCNT, resid);
	if ((ahc->features & AHC_ULTRA2) == 0) {
		ahc_outb(ahc, STCNT + 2, resid >> 16);
		ahc_outb(ahc, STCNT + 1, resid >> 8);
		ahc_outb(ahc, STCNT, resid);
	}
}

/*
 * Handle the effects of issuing a bus device reset message.
 */
static void
ahc_handle_devreset(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		    cam_status status, char *message, int verbose_level)
{
#ifdef AHC_TARGET_MODE
	struct ahc_tmode_tstate* tstate;
	u_int lun;
#endif
	int found;

	found = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       CAM_LUN_WILDCARD, SCB_LIST_NULL, devinfo->role,
			       status);

#ifdef AHC_TARGET_MODE
	/*
	 * Send an immediate notify ccb to all target mord peripheral
	 * drivers affected by this action.
	 */
	tstate = ahc->enabled_targets[devinfo->our_scsiid];
	if (tstate != NULL) {
		for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
			struct ahc_tmode_lstate* lstate;

			lstate = tstate->enabled_luns[lun];
			if (lstate == NULL)
				continue;

			ahc_queue_lstate_event(ahc, lstate, devinfo->our_scsiid,
					       MSG_BUS_DEV_RESET, /*arg*/0);
			ahc_send_lstate_events(ahc, lstate);
a2776 2
	}
#endif
d2778 7
a2784 61
	/*
	 * Go back to async/narrow transfers and renegotiate.
	 */
	ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
		      AHC_TRANS_CUR, /*paused*/TRUE);
	ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,
			 /*period*/0, /*offset*/0, /*ppr_options*/0,
			 AHC_TRANS_CUR, /*paused*/TRUE);
	
	ahc_send_async(ahc, devinfo->channel, devinfo->target,
		       CAM_LUN_WILDCARD, AC_SENT_BDR, NULL);

	if (message != NULL
	 && (verbose_level <= bootverbose))
		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahc_name(ahc),
		       message, devinfo->channel, devinfo->target, found);
}

#ifdef AHC_TARGET_MODE
static void
ahc_setup_target_msgin(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		       struct scb *scb)
{

	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)
		ahc_build_transfer_msg(ahc, devinfo);
	else
		panic("ahc_intr: AWAITING target message with no message");

	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
}
#endif
/**************************** Initialization **********************************/
/*
 * Allocate a controller structure for a new device
 * and perform initial initializion.
 */
struct ahc_softc *
ahc_alloc(void *platform_arg, char *name)
{
	struct  ahc_softc *ahc;
	int	i;

#ifdef __OpenBSD__	/* OpenBSD provides softc! */
	ahc = (struct ahc_softc *)platform_arg;
#else 
#ifndef	__FreeBSD__
	ahc = malloc(sizeof(*ahc), M_DEVBUF, M_NOWAIT);
	if (!ahc) {
		printf("aic7xxx: cannot malloc softc!\n");
		free(name, M_DEVBUF);
		return NULL;
d2786 4
a2789 25
#else
	ahc = device_get_softc((device_t)platform_arg);
#endif
	memset(ahc, 0, sizeof(*ahc));
#endif 
	LIST_INIT(&ahc->pending_scbs);
	/* We don't know our unit number until the OSM sets it */
	ahc->name = name;
	ahc->unit = -1;
	ahc->description = NULL;
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	ahc->chip = AHC_NONE;
	ahc->features = AHC_FENONE;
	ahc->bugs = AHC_BUGNONE;
	ahc->flags = AHC_FNONE;

	for (i = 0; i < 16; i++)
		TAILQ_INIT(&ahc->untagged_queues[i]);
	if (ahc_platform_alloc(ahc, platform_arg) != 0) {
		ahc_free(ahc);
		ahc = NULL;
	}
	return (ahc);
}
d2791 1
a2791 3
int
ahc_softc_init(struct ahc_softc *ahc)
{
d2793 8
a2800 55
	/* The IRQMS bit is only valid on VL and EISA chips */
	if ((ahc->chip & AHC_PCI) == 0)
		ahc->unpause = ahc_inb(ahc, HCNTRL) & IRQMS;
	else
		ahc->unpause = 0;
	ahc->pause = ahc->unpause | PAUSE; 
	/* XXX The shared scb data stuff should be deprecated */
	if (ahc->scb_data == NULL) {
		ahc->scb_data = malloc(sizeof(*ahc->scb_data),
				       M_DEVBUF, M_NOWAIT);
		if (ahc->scb_data == NULL)
			return (ENOMEM);
		memset(ahc->scb_data, 0, sizeof(*ahc->scb_data));
	}

	return (0);
}

void
ahc_softc_insert(struct ahc_softc *ahc)
{
	struct ahc_softc *list_ahc;

#if AHC_PCI_CONFIG > 0
	/*
	 * Second Function PCI devices need to inherit some
	 * settings from function 0.
	 */
	if ((ahc->chip & AHC_BUS_MASK) == AHC_PCI
	 && (ahc->features & AHC_MULTI_FUNC) != 0) {
		TAILQ_FOREACH(list_ahc, &ahc_tailq, links) {
			ahc_dev_softc_t list_pci;
			ahc_dev_softc_t pci;

			list_pci = list_ahc->dev_softc;
			pci = ahc->dev_softc;
			if (ahc_get_pci_slot(list_pci) == ahc_get_pci_slot(pci)
			 && ahc_get_pci_bus(list_pci) == ahc_get_pci_bus(pci)) {
				struct ahc_softc *master;
				struct ahc_softc *slave;

				if (ahc_get_pci_function(list_pci) == 0) {
					master = list_ahc;
					slave = ahc;
				} else {
					master = ahc;
					slave = list_ahc;
				}
				slave->flags &= ~AHC_BIOS_ENABLED; 
				slave->flags |=
				    master->flags & AHC_BIOS_ENABLED;
				slave->flags &= ~AHC_PRIMARY_CHANNEL; 
				slave->flags |=
				    master->flags & AHC_PRIMARY_CHANNEL;
				break;
d2802 2
a2804 2
	}
#endif
d2806 2
a2807 13
	/*
	 * Insertion sort into our list of softcs.
	 */
	list_ahc = TAILQ_FIRST(&ahc_tailq);
	while (list_ahc != NULL
	    && ahc_softc_comp(list_ahc, ahc) <= 0)
		list_ahc = TAILQ_NEXT(list_ahc, links);
	if (list_ahc != NULL)
		TAILQ_INSERT_BEFORE(list_ahc, ahc, links);
	else
		TAILQ_INSERT_TAIL(&ahc_tailq, ahc, links);
	ahc->init_level++;
}
d2809 1
a2809 5
void
ahc_set_unit(struct ahc_softc *ahc, int unit)
{
	ahc->unit = unit;
}
d2811 6
a2816 7
void
ahc_set_name(struct ahc_softc *ahc, char *name)
{
	if (ahc->name != NULL)
		free(ahc->name, M_DEVBUF);
	ahc->name = name;
}
d2818 10
a2827 5
#ifndef __OpenBSD__
void
ahc_free(struct ahc_softc *ahc)
{
	int i;
d2829 3
a2831 25
	ahc_fini_scbdata(ahc);
	switch (ahc->init_level) {
	default:
	case 5:
		ahc_shutdown(ahc);
		TAILQ_REMOVE(&ahc_tailq, ahc, links);
		/* FALLTHROUGH */
	case 4:
		ahc_dmamap_unload(ahc, ahc->shared_data_dmat,
				  ahc->shared_data_dmamap);
		/* FALLTHROUGH */
	case 3:
		ahc_dmamem_free(ahc, ahc->shared_data_dmat, ahc->qoutfifo,
				ahc->shared_data_dmamap);
		ahc_dmamap_destroy(ahc, ahc->shared_data_dmat,
				   ahc->shared_data_dmamap);
		/* FALLTHROUGH */
	case 2:
		ahc_dma_tag_destroy(ahc, ahc->shared_data_dmat);
	case 1:
#ifndef __linux__
		ahc_dma_tag_destroy(ahc, ahc->buffer_dmat);
#endif
		break;
	case 0:
d2834 4
d2839 2
a2840 6
#ifndef __linux__
	ahc_dma_tag_destroy(ahc, ahc->parent_dmat);
#endif
	ahc_platform_free(ahc);
	for (i = 0; i < AHC_NUM_TARGETS; i++) {
		struct ahc_tmode_tstate *tstate;
d2842 11
a2852 4
		tstate = ahc->enabled_targets[i];
		if (tstate != NULL) {
#if AHC_TARGET_MODE
			int j;
d2854 1
a2854 2
			for (j = 0; j < AHC_NUM_LUNS; j++) {
				struct ahc_tmode_lstate *lstate;
d2856 14
a2869 8
				lstate = tstate->enabled_luns[j];
				if (lstate != NULL) {
					xpt_free_path(lstate->path);
					free(lstate, M_DEVBUF);
				}
			}
#endif
			free(tstate, M_DEVBUF);
a2870 15
	}
#if AHC_TARGET_MODE
	if (ahc->black_hole != NULL) {
		xpt_free_path(ahc->black_hole->path);
		free(ahc->black_hole, M_DEVBUF);
	}
#endif
	if (ahc->name != NULL)
		free(ahc->name, M_DEVBUF);
#ifndef __FreeBSD__
	free(ahc, M_DEVBUF);
#endif
	return;
}
#endif /* __OpenBSD__ */
d2872 7
a2878 5
void
ahc_shutdown(void *arg)
{
	struct	ahc_softc *ahc;
	int	i;
d2880 11
a2890 1
	ahc = (struct ahc_softc *)arg;
d2892 5
a2896 5
	/* This will reset most registers to 0, but not all */
	ahc_reset(ahc);
	ahc_outb(ahc, SCSISEQ, 0);
	ahc_outb(ahc, SXFRCTL0, 0);
	ahc_outb(ahc, DSPCISTATUS, 0);
d2898 19
a2916 24
	for (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)
		ahc_outb(ahc, i, 0);
}

/*
 * Reset the controller and record some information about it
 * that is only availabel just after a reset.
 */
int
ahc_reset(struct ahc_softc *ahc)
{
	u_int	sblkctl;
	u_int	sxfrctl1_a, sxfrctl1_b;
	int	wait;
	
	/*
	 * Preserve the value of the SXFRCTL1 register for all channels.
	 * It contains settings that affect termination and we don't want
	 * to disturb the integrity of the bus.
	 */
	ahc_pause(ahc);
	sxfrctl1_b = 0;
	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7770) {
		u_int sblkctl;
d2919 2
a2920 2
		 * Save channel B's settings in case this chip
		 * is setup for TWIN channel operation.
d2922 2
a2923 6
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		sxfrctl1_b = ahc_inb(ahc, SXFRCTL1);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	sxfrctl1_a = ahc_inb(ahc, SXFRCTL1);
d2925 13
a2937 1
	ahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);
d2939 7
a2945 7
	/*
	 * Ensure that the reset has finished
	 */
	wait = 1000;
	do {
		ahc_delay(1000);
	} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));
d2947 1
a2947 3
	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", ahc_name(ahc));
a2948 19
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/* Determine channel configuration */
	sblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);
	/* No Twin Channel PCI cards */
	if ((ahc->chip & AHC_PCI) != 0)
		sblkctl &= ~SELBUSB;
	switch (sblkctl) {
	case 0:
		/* Single Narrow Channel */
		break;
	case 2:
		/* Wide Channel */
		ahc->features |= AHC_WIDE;
		break;
	case 8:
		/* Twin Channel */
		ahc->features |= AHC_TWIN;
		break;
d2950 1
a2950 2
		printf(" Unsupported adapter type.  Ignoring\n");
		return(-1);
d2953 6
a2958 10
	/*
	 * Reload sxfrctl1.
	 *
	 * We must always initialize STPWEN to 1 before we
	 * restore the saved values.  STPWEN is initialized
	 * to a tri-state condition which can only be cleared
	 * by turning it on.
	 */
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;
d2960 14
a2973 6
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		ahc_outb(ahc, SXFRCTL1, sxfrctl1_b);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	ahc_outb(ahc, SXFRCTL1, sxfrctl1_a);
d2975 2
a2976 4
#ifdef AHC_DUMP_SEQ
	if (ahc->init_level == 0)
		ahc_dumpseq(ahc);
#endif
d2978 2
a2979 9
	return (0);
}

/*
 * Determine the number of SCBs available on the controller
 */
int
ahc_probe_scbs(struct ahc_softc *ahc) {
	int i;
d2981 3
a2983 1
	for (i = 0; i < AHC_SCB_MAX; i++) {
d2985 8
a2992 6
		ahc_outb(ahc, SCBPTR, i);
		ahc_outb(ahc, SCB_BASE, i);
		if (ahc_inb(ahc, SCB_BASE) != i)
			break;
		ahc_outb(ahc, SCBPTR, 0);
		if (ahc_inb(ahc, SCB_BASE) != 0)
d2994 9
d3004 1
a3004 1
	return (i);
d3007 5
a3011 3
#ifndef __OpenBSD__
static void
ahc_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) 
d3013 6
a3018 1
	bus_addr_t *baddr;
d3020 6
a3025 4
	baddr = (bus_addr_t *)arg;
	*baddr = segs->ds_addr;
}
#endif 
d3027 30
a3056 23
#ifndef __OpenBSD__
static void
#else
void
#endif 
ahc_build_free_scb_list(struct ahc_softc *ahc)
{
	int i;

	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		ahc_outb(ahc, SCBPTR, i);

		/* Clear the control byte. */
		ahc_outb(ahc, SCB_CONTROL, 0);

		/* Set the next pointer */
		if ((ahc->flags & AHC_PAGESCBS) != 0)
			ahc_outb(ahc, SCB_NEXT, i+1);
		else 
			ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);

		/* Make the tag number invalid */
		ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
d3058 17
d3076 9
a3084 3
	/* Make sure that the last SCB terminates the free list */
	ahc_outb(ahc, SCBPTR, i-1);
	ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);
d3086 9
a3094 4
	/* Ensure we clear the 0 SCB's control byte. */
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outb(ahc, SCB_CONTROL, 0);
}
d3096 30
a3125 5
#ifndef __OpenBSD__
static int
ahc_init_scbdata(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;
d3127 5
a3131 3
	scb_data = ahc->scb_data;
	SLIST_INIT(&scb_data->free_scbs);
	SLIST_INIT(&scb_data->sg_maps);
d3133 9
a3141 7
	/* Allocate SCB resources */
	scb_data->scbarray =
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,
				 M_DEVBUF, M_NOWAIT);
	if (scb_data->scbarray == NULL)
		return (ENOMEM);
	memset(scb_data->scbarray, 0, sizeof(struct scb) * AHC_SCB_MAX);
d3143 54
a3196 1
	/* Determine the number of hardware SCBs and initialize them */
d3198 6
a3203 7
	scb_data->maxhscbs = ahc_probe_scbs(ahc);
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		/* SCB 0 heads the free list */
		ahc_outb(ahc, FREE_SCBH, 0);
	} else {
		ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	}
d3205 28
a3232 3
	if (ahc->scb_data->maxhscbs == 0) {
		printf("%s: No SCB space found\n", ahc_name(ahc));
		return (ENXIO);
d3234 21
d3256 3
a3258 1
	ahc_build_free_scb_list(ahc);
d3260 18
a3277 21
	/*
	 * Create our DMA tags.  These tags define the kinds of device
	 * accessible memory allocations and memory mappings we will
	 * need to perform during normal operation.
	 *
	 * Unless we need to further restrict the allocation, we rely
	 * on the restrictions of the parent dmat, hence the common
	 * use of MAXADDR and MAXSIZE.
	 */

	/* DMA tag for our hardware scb structures */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       AHC_SCB_MAX * sizeof(struct hardware_scb),
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->hscb_dmat) != 0) {
		goto error_exit;
d3280 9
a3288 7
	scb_data->init_level++;

	/* Allocation for our hscbs */
	if (ahc_dmamem_alloc(ahc, scb_data->hscb_dmat,
			     (void **)&scb_data->hscbs,
			     BUS_DMA_NOWAIT, &scb_data->hscb_dmamap) != 0) {
		goto error_exit;
d3291 3
a3293 1
	scb_data->init_level++;
d3295 2
a3296 5
	/* And permanently map them */
	ahc_dmamap_load(ahc, scb_data->hscb_dmat, scb_data->hscb_dmamap,
			scb_data->hscbs,
			AHC_SCB_MAX * sizeof(struct hardware_scb),
			ahc_dmamap_cb, &scb_data->hscb_busaddr, /*flags*/0);
d3298 7
a3304 1
	scb_data->init_level++;
d3306 17
a3322 12
	/* DMA tag for our sense buffers */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->sense_dmat) != 0) {
		goto error_exit;
	}
d3324 17
a3340 1
	scb_data->init_level++;
d3342 4
a3345 6
	/* Allocate them */
	if (ahc_dmamem_alloc(ahc, scb_data->sense_dmat,
			     (void **)&scb_data->sense,
			     BUS_DMA_NOWAIT, &scb_data->sense_dmamap) != 0) {
		goto error_exit;
	}
d3347 2
a3348 1
	scb_data->init_level++;
d3350 1
a3350 5
	/* And permanently map them */
	ahc_dmamap_load(ahc, scb_data->sense_dmat, scb_data->sense_dmamap,
			scb_data->sense,
			AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			ahc_dmamap_cb, &scb_data->sense_busaddr, /*flags*/0);
d3352 22
a3373 13
	scb_data->init_level++;

	/* DMA tag for our S/G structures.  We allocate in page sized chunks */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       PAGE_SIZE, /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->sg_dmat) != 0) {
		goto error_exit;
	}
d3375 3
a3377 1
	scb_data->init_level++;
d3379 5
a3383 9
	/* Perform initial CCB allocation */
	memset(scb_data->hscbs, 0, AHC_SCB_MAX * sizeof(struct hardware_scb));
	ahc_alloc_scbs(ahc);

	if (scb_data->numscbs == 0) {
		printf("%s: ahc_init_scbdata - "
		       "Unable to allocate initial scbs\n",
		       ahc_name(ahc));
		goto error_exit;
d3385 1
d3387 9
a3395 5
	/*
	 * Tell the sequencer which SCB will be the next one it receives.
	 */
	ahc->next_queued_scb = ahc_get_scb(ahc);
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);
d3397 4
d3402 3
a3404 1
	 * Note that we were successfull
d3406 10
a3415 5
	return (0); 

error_exit:

	return (ENOMEM);
d3418 9
a3426 2
static void
ahc_fini_scbdata(struct ahc_softc *ahc)
d3428 4
a3431 1
	struct scb_data *scb_data;
d3433 3
a3435 3
	scb_data = ahc->scb_data;
	if (scb_data == NULL)
		return;
d3437 1
a3437 5
	switch (scb_data->init_level) {
	default:
	case 7:
	{
		struct sg_map_node *sg_map;
d3439 5
a3443 10
		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
			ahc_dmamap_unload(ahc, scb_data->sg_dmat,
					  sg_map->sg_dmamap);
			ahc_dmamem_free(ahc, scb_data->sg_dmat,
					sg_map->sg_vaddr,
					sg_map->sg_dmamap);
			free(sg_map, M_DEVBUF);
		}
		ahc_dma_tag_destroy(ahc, scb_data->sg_dmat);
d3445 14
a3458 23
	case 6:
		ahc_dmamap_unload(ahc, scb_data->sense_dmat,
				  scb_data->sense_dmamap);
	case 5:
		ahc_dmamem_free(ahc, scb_data->sense_dmat, scb_data->sense,
				scb_data->sense_dmamap);
		ahc_dmamap_destroy(ahc, scb_data->sense_dmat,
				   scb_data->sense_dmamap);
	case 4:
		ahc_dma_tag_destroy(ahc, scb_data->sense_dmat);
	case 3:
		ahc_dmamap_unload(ahc, scb_data->hscb_dmat,
				  scb_data->hscb_dmamap);
	case 2:
		ahc_dmamem_free(ahc, scb_data->hscb_dmat, scb_data->hscbs,
				scb_data->hscb_dmamap);
		ahc_dmamap_destroy(ahc, scb_data->hscb_dmat,
				   scb_data->hscb_dmamap);
	case 1:
		ahc_dma_tag_destroy(ahc, scb_data->hscb_dmat);
		break;
	case 0:
		break;
a3459 3
	if (scb_data->scbarray != NULL)
		free(scb_data->scbarray, M_DEVBUF);
}
d3461 7
a3467 10
void
ahc_alloc_scbs(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;
	struct scb *next_scb;
	struct sg_map_node *sg_map;
	bus_addr_t physaddr;
	struct ahc_dma_seg *segs;
	int newcount;
	int i;
d3469 5
a3473 4
	scb_data = ahc->scb_data;
	if (scb_data->numscbs >= AHC_SCB_MAX)
		/* Can't allocate any more */
		return;
d3475 1
a3475 1
	next_scb = &scb_data->scbarray[scb_data->numscbs];
d3477 8
a3484 1
	sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);
d3486 5
a3490 2
	if (sg_map == NULL)
		return;
d3492 12
a3503 6
	/* Allocate S/G space for the next batch of SCBS */
	if (ahc_dmamem_alloc(ahc, scb_data->sg_dmat,
			     (void **)&sg_map->sg_vaddr,
			     BUS_DMA_NOWAIT, &sg_map->sg_dmamap) != 0) {
		free(sg_map, M_DEVBUF);
		return;
d3506 26
a3531 8
	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);

	ahc_dmamap_load(ahc, scb_data->sg_dmat, sg_map->sg_dmamap,
			sg_map->sg_vaddr, PAGE_SIZE, ahc_dmamap_cb,
			&sg_map->sg_physaddr, /*flags*/0);

	segs = sg_map->sg_vaddr;
	physaddr = sg_map->sg_physaddr;
d3533 1
a3533 13
	newcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));
	for (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {
		struct scb_platform_data *pdata;
#ifndef __linux__
		int error;
#endif
		pdata = (struct scb_platform_data *)malloc(sizeof(*pdata),
							   M_DEVBUF, M_NOWAIT);
		if (pdata == NULL)
			break;
		next_scb->platform_data = pdata;
		next_scb->sg_map = sg_map;
		next_scb->sg_list = segs;
d3535 2
a3536 2
		 * The sequencer always starts with the second entry.
		 * The first entry is embedded in the scb.
d3538 10
a3547 17
		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
		next_scb->ahc_softc = ahc;
		next_scb->flags = SCB_FREE;
#ifndef __linux__
		error = ahc_dmamap_create(ahc, ahc->buffer_dmat, /*flags*/0,
					  &next_scb->dmamap);
		if (error != 0)
			break;
#endif
		next_scb->hscb = &scb_data->hscbs[scb_data->numscbs];
		next_scb->hscb->tag = ahc->scb_data->numscbs;
		SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs,
				  next_scb, links.sle);
		segs += AHC_NSEG;
		physaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));
		next_scb++;
		ahc->scb_data->numscbs++;
d3549 11
a3560 1
#endif /* __OpenBSD__ */
d3562 6
a3567 2
void
ahc_controller_info(struct ahc_softc *ahc, char *buf)
d3569 1
a3569 1
	int len;
d3571 8
a3578 26
	len = sprintf(buf, "%s: ", ahc_chip_names[ahc->chip & AHC_CHIPID_MASK]);
	buf += len;
	if ((ahc->features & AHC_TWIN) != 0)
 		len = sprintf(buf, "Twin Channel, A SCSI Id=%d, "
			      "B SCSI Id=%d, primary %c, ",
			      ahc->our_id, ahc->our_id_b,
			      (ahc->flags & AHC_PRIMARY_CHANNEL) + 'A');
	else {
		const char *speed;
		const char *type;

		speed = "";
		if ((ahc->features & AHC_ULTRA) != 0) {
			speed = "Ultra ";
		} else if ((ahc->features & AHC_DT) != 0) {
			speed = "Ultra160 ";
		} else if ((ahc->features & AHC_ULTRA2) != 0) {
			speed = "Ultra2 ";
		}
		if ((ahc->features & AHC_WIDE) != 0) {
			type = "Wide";
		} else {
			type = "Single";
		}
		len = sprintf(buf, "%s%s Channel %c, SCSI Id=%d, ",
			      speed, type, ahc->channel, ahc->our_id);
d3580 2
a3581 7
	buf += len;

	if ((ahc->flags & AHC_PAGESCBS) != 0)
		sprintf(buf, "%d/%d SCBs",
			ahc->scb_data->maxhscbs, AHC_SCB_MAX);
	else
		sprintf(buf, "%d SCBs", ahc->scb_data->maxhscbs);
d3588 2
a3589 1
ahc_init(struct ahc_softc *ahc)
d3591 11
a3601 14
	int	 max_targ;
	int	 i;
	int	 term;
	u_int	 scsi_conf;
	u_int	 scsiseq_template;
	u_int	 ultraenb;
	u_int	 discenable;
	u_int	 tagenable;
	size_t	 driver_data_size;
	uint32_t physaddr;

#ifdef AHC_DEBUG_SEQUENCER
	ahc->flags |= AHC_SEQUENCER_DEBUG;
#endif
d3621 10
a3630 1
	max_targ = 15;
d3640 2
a3641 2
	ahc->flags |= AHC_INITIATORROLE;

d3643 7
a3649 1
	 * Only allow target mode features if this unit has them enabled.
d3651 1
a3651 2
	if ((AHC_TMODE_ENABLE & (0x1 << ahc->unit)) == 0)
		ahc->features &= ~AHC_TARGETMODE;
d3653 1
a3653 29
#if !defined(__linux__) && !defined(__OpenBSD__)
	/* DMA tag for mapping buffers into device visible space. */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       /*maxsize*/MAXBSIZE, /*nsegments*/AHC_NSEG,
			       /*maxsegsz*/AHC_MAXTRANSFER_SIZE,
			       /*flags*/BUS_DMA_ALLOCNOW,
			       &ahc->buffer_dmat) != 0) {
		return (ENOMEM);
	}
#endif

	ahc->init_level++;

	/*
	 * DMA tag for our command fifos and other data in system memory
	 * the card's sequencer must be able to access.  For initiator
	 * roles, we need to allocate space for the the qinfifo and qoutfifo.
	 * The qinfifo and qoutfifo are composed of 256 1 byte elements. 
	 * When providing for the target mode role, we must additionally
	 * provide space for the incoming target command fifo and an extra
	 * byte to deal with a dma bug in some chip versions.
	 */
	driver_data_size = 2 * 256 * sizeof(uint8_t);
#ifdef __OpenBSD__
	if (ahc_createdmamem(ahc, ahc->shared_data_dmat, driver_data_size, 
a3659 1
#else
d3661 4
a3664 16
	if ((ahc->features & AHC_TARGETMODE) != 0)
		driver_data_size += AHC_TMODE_CMDS * sizeof(struct target_cmd)
				 + /*DMA WideOdd Bug Buffer*/1;
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       driver_data_size,
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &ahc->shared_data_dmat) != 0) {
		return (ENOMEM);
	}

	ahc->init_level++;
a3665 28
	/* Allocation of driver data */
	if (ahc_dmamem_alloc(ahc, ahc->shared_data_dmat,
			     (void **)&ahc->qoutfifo,
			     BUS_DMA_NOWAIT, &ahc->shared_data_dmamap) != 0) {
		return (ENOMEM);
	}

	ahc->init_level++;

	/* And permanently map it in */
	ahc_dmamap_load(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
			ahc->qoutfifo, driver_data_size, ahc_dmamap_cb,
			&ahc->shared_data_busaddr, /*flags*/0);
	if ((ahc->features & AHC_TARGETMODE) != 0) {
		ahc->targetcmds = (struct target_cmd *)ahc->qoutfifo;
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[AHC_TMODE_CMDS];
		ahc->dma_bug_buf = ahc->shared_data_busaddr
				 + driver_data_size - 1;
		/* All target command blocks start out invalid. */
		for (i = 0; i < AHC_TMODE_CMDS; i++)
			ahc->targetcmds[i].cmd_valid = 0;
		ahc_sync_tqinfifo(ahc, BUS_DMASYNC_PREREAD);
		ahc->tqinfifonext = 1;
		ahc_outb(ahc, KERNEL_TQINPOS, ahc->tqinfifonext - 1);
		ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[256];
	}
#endif 
d3667 4
d3672 3
a3674 6
	ahc->init_level++;

	/* Allocate SCB data now that buffer_dmat is initialized */
	if (ahc->scb_data->maxhscbs == 0)
		if (ahc_init_scbdata(ahc) != 0)
			return (ENOMEM);
d3676 3
d3685 1
a3685 1
		printf("%s: unable to allocate ahc_tmode_tstate.  "
d3687 1
a3687 1
		return (ENOMEM);
d3691 13
a3703 4
		if (ahc_alloc_tstate(ahc, ahc->our_id_b, 'B') == NULL) {
			printf("%s: unable to allocate ahc_tmode_tstate.  "
			       "Failing attach\n", ahc_name(ahc));
			return (ENOMEM);
d3705 1
a3708 1
	ahc_outb(ahc, SEQ_FLAGS2, 0);
d3712 1
d3715 1
d3723 1
a3723 1
			sizeof(struct hardware_scb),
d3729 1
a3729 1
	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
a3735 1
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
d3737 4
a3740 1
		ahc_outb(ahc, SCSIID, ahc->our_id_b);
d3743 1
a3743 3
					|term|ahc->seltime_b|ENSTIMER|ACTNEGEN);
		if ((ahc->features & AHC_ULTRA2) != 0)
			ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
d3748 1
a3748 1
		 && (ahc->flags & AHC_INITIATORROLE) != 0)
a3753 1
	
d3761 1
a3761 1
				|term|ahc->seltime
a3762 2
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
d3767 1
a3767 1
	 && (ahc->flags & AHC_INITIATORROLE) != 0)
d3799 1
a3799 1
		struct ahc_tmode_tstate *tstate;
d3815 1
a3815 1
		memset(tinfo, 0, sizeof(*tinfo));
d3828 1
a3828 1
			uint16_t mask;
a3848 3
				if ((scsirate & ~WIDEXFER) == 0 && offset != 0)
					/* Set to the lowest sync rate, 5MHz */
					scsirate |= 0x1c;
a3857 4
				if ((scsirate & SXFR_ULTRA2) <= 8/*10MHz*/
				 && (ahc->features & AHC_DT) != 0)
					tinfo->user.ppr_options =
					    MSG_EXT_PPR_DT_REQ;
a3858 6
				if ((scsirate & SXFR) == 0x40
				 && (ultraenb & mask) != 0) {
					/* Treat 10MHz as a non-ultra speed */
					scsirate &= ~SXFR;
				 	ultraenb &= ~mask;
				}
a3866 2
			if (tinfo->user.period == 0)
				tinfo->user.offset = 0;
a3869 9
			tinfo->user.protocol_version = 4;
			if ((ahc->features & AHC_DT) != 0)
				tinfo->user.transport_version = 3;
			else
				tinfo->user.transport_version = 2;
			tinfo->goal.protocol_version = 2;
			tinfo->goal.transport_version = 2;
			tinfo->curr.protocol_version = 2;
			tinfo->curr.transport_version = 2;
d3871 1
d3873 3
a3879 29
	/* There are no untagged SCBs active yet. */
	for (i = 0; i < 16; i++) {
		ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, 0));
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			int lun;

			/*
			 * The SCB based BTT allows an entry per
			 * target and lun pair.
			 */
			for (lun = 1; lun < AHC_NUM_LUNS; lun++)
				ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, lun));
		}
	}

	/* All of our queues are empty */
	for (i = 0; i < 256; i++)
		ahc->qoutfifo[i] = SCB_LIST_NULL;
	
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREREAD);

	for (i = 0; i < 256; i++)
		ahc->qinfifo[i] = SCB_LIST_NULL;

	if ((ahc->features & AHC_MULTI_TID) != 0) {
		ahc_outb(ahc, TARGID, 0);
		ahc_outb(ahc, TARGID + 1, 0);
	}
	
d3890 11
a3900 4
	ahc_outb(ahc, SHARED_DATA_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 3, (physaddr >> 24) & 0xFF);
d3921 10
d3942 1
d3954 1
a3954 1
	 * If we are a target, we'll enalbe select in operations once
d3958 1
a3958 1
	if ((ahc->flags & AHC_INITIATORROLE) != 0)
d3965 1
a3965 1
	 */
d3972 18
a3989 2
	if ((ahc->features & AHC_ULTRA2) != 0) {
		int wait;
a3990 15
		/*
		 * Wait for up to 500ms for our transceivers
		 * to settle.  If the adapter does not have
		 * a cable attached, the tranceivers may
		 * never settle, so don't complain if we
		 * fail here.
		 */
		ahc_pause(ahc);
		for (wait = 5000;
		     (ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
		     wait--)
			ahc_delay(100);
		ahc_unpause(ahc);
	}
	return (0);
d3993 4
a3996 2
void
ahc_intr_enable(struct ahc_softc *ahc, int enable)
d3998 19
a4016 1
	u_int hcntrl;
d4018 15
a4032 8
	hcntrl = ahc_inb(ahc, HCNTRL);
	hcntrl &= ~INTEN;
	ahc->pause &= ~INTEN;
	ahc->unpause &= ~INTEN;
	if (enable) {
		hcntrl |= INTEN;
		ahc->pause |= INTEN;
		ahc->unpause |= INTEN;
d4034 12
a4045 1
	ahc_outb(ahc, HCNTRL, hcntrl);
d4049 1
a4049 5
 * Ensure that the card is paused in a location
 * outside of all critical sections and that all
 * pending work is completed prior to returning.
 * This routine should only be called from outside
 * an interrupt context.
d4051 2
a4052 2
void
ahc_pause_and_flushwork(struct ahc_softc *ahc)
d4054 2
a4055 2
	int intstat;
	int maxloops;
d4057 8
a4064 8
	maxloops = 1000;
	ahc->flags |= AHC_ALL_INTERRUPTS;
	intstat = 0;
	do {
		ahc_intr(ahc);
		ahc_pause(ahc);
		ahc_clear_critical_section(ahc);
		if (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0)
d4066 1
a4066 5
		maxloops--;
	} while (((intstat = ahc_inb(ahc, INTSTAT)) & INT_PEND) && --maxloops);
	if (maxloops == 0) {
		printf("Infinite interrupt loop, INTSTAT = %x",
		      ahc_inb(ahc, INTSTAT));
d4068 2
a4069 2
	ahc_platform_flushwork(ahc);
	ahc->flags &= ~AHC_ALL_INTERRUPTS;
d4072 3
a4074 2
int
ahc_suspend(struct ahc_softc *ahc)
d4076 12
a4087 2
	uint8_t *ptr;
	int	 i;
d4089 2
a4090 1
	ahc_pause_and_flushwork(ahc);
d4092 2
a4093 2
	if (LIST_FIRST(&ahc->pending_scbs) != NULL)
		return (EBUSY);
d4095 7
a4101 9
#if AHC_TARGET_MODE
	/*
	 * XXX What about ATIOs that have not yet been serviced?
	 * Perhaps we should just refuse to be suspended if we
	 * are acting in a target role.
	 */
	if (ahc->pending_device != NULL)
		return (EBUSY);
#endif
d4103 4
a4106 34
	/* Save volatile registers */
	if ((ahc->features & AHC_TWIN) != 0) {
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		ahc->suspend_state.channel[1].scsiseq = ahc_inb(ahc, SCSISEQ);
		ahc->suspend_state.channel[1].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
		ahc->suspend_state.channel[1].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
		ahc->suspend_state.channel[1].simode0 = ahc_inb(ahc, SIMODE0);
		ahc->suspend_state.channel[1].simode1 = ahc_inb(ahc, SIMODE1);
		ahc->suspend_state.channel[1].seltimer = ahc_inb(ahc, SELTIMER);
		ahc->suspend_state.channel[1].seqctl = ahc_inb(ahc, SEQCTL);
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
	}
	ahc->suspend_state.channel[0].scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc->suspend_state.channel[0].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
	ahc->suspend_state.channel[0].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
	ahc->suspend_state.channel[0].simode0 = ahc_inb(ahc, SIMODE0);
	ahc->suspend_state.channel[0].simode1 = ahc_inb(ahc, SIMODE1);
	ahc->suspend_state.channel[0].seltimer = ahc_inb(ahc, SELTIMER);
	ahc->suspend_state.channel[0].seqctl = ahc_inb(ahc, SEQCTL);

	if ((ahc->chip & AHC_PCI) != 0) {
		ahc->suspend_state.dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		ahc->suspend_state.dspcistatus = ahc_inb(ahc, DSPCISTATUS);
	}

	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;

		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc->suspend_state.optionmode = ahc_inb(ahc, OPTIONMODE);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc->suspend_state.crccontrol1 = ahc_inb(ahc, CRCCONTROL1);
	}
d4108 5
a4112 9
	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc->suspend_state.scbbaddr = ahc_inb(ahc, SCBBADDR);

	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc->suspend_state.dff_thrsh = ahc_inb(ahc, DFF_THRSH);

	ptr = ahc->suspend_state.scratch_ram;
	for (i = 0; i < 64; i++)
		*ptr++ = ahc_inb(ahc, SRAM_BASE + i);
d4114 4
a4117 3
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0; i < 16; i++)
			*ptr++ = ahc_inb(ahc, TARG_OFFSET + i);
d4120 8
a4127 4
	ptr = ahc->suspend_state.btt;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		for (i = 0;i < AHC_NUM_TARGETS; i++) {
			int j;
d4129 8
a4136 6
			for (j = 0;j < AHC_NUM_LUNS; j++) {
				u_int tcl;

				tcl = BUILD_TCL(i << 4, j);
				*ptr = ahc_index_busy_tcl(ahc, tcl);
			}
d4138 3
a4141 3
	ahc_shutdown(ahc);
	return (0);
}
d4143 1
a4143 5
int
ahc_resume(struct ahc_softc *ahc)
{
	uint8_t *ptr;
	int	 i;
d4145 2
a4146 1
	ahc_reset(ahc);
d4148 14
a4161 1
	ahc_build_free_scb_list(ahc);
d4163 8
a4170 24
	/* Restore volatile registers */
	if ((ahc->features & AHC_TWIN) != 0) {
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		ahc_outb(ahc, SCSIID, ahc->our_id);
		ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[1].scsiseq);
		ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[1].sxfrctl0);
		ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[1].sxfrctl1);
		ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[1].simode0);
		ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[1].simode1);
		ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[1].seltimer);
		ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[1].seqctl);
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
	}
	ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[0].scsiseq);
	ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[0].sxfrctl0);
	ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[0].sxfrctl1);
	ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[0].simode0);
	ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[0].simode1);
	ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[0].seltimer);
	ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[0].seqctl);
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);
	else
		ahc_outb(ahc, SCSIID, ahc->our_id);
a4171 3
	if ((ahc->chip & AHC_PCI) != 0) {
		ahc_outb(ahc, DSCOMMAND0, ahc->suspend_state.dscommand0);
		ahc_outb(ahc, DSPCISTATUS, ahc->suspend_state.dspcistatus);
d4174 1
a4174 2
	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;
d4176 2
a4177 6
		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc_outb(ahc, OPTIONMODE, ahc->suspend_state.optionmode);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc_outb(ahc, CRCCONTROL1, ahc->suspend_state.crccontrol1);
	}
d4179 4
a4182 2
	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc_outb(ahc, SCBBADDR, ahc->suspend_state.scbbaddr);
d4184 5
a4188 2
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, DFF_THRSH, ahc->suspend_state.dff_thrsh);
d4190 9
a4198 3
	ptr = ahc->suspend_state.scratch_ram;
	for (i = 0; i < 64; i++)
		ahc_outb(ahc, SRAM_BASE + i, *ptr++);
d4200 2
a4201 3
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0; i < 16; i++)
			ahc_outb(ahc, TARG_OFFSET + i, *ptr++);
d4204 12
a4215 4
	ptr = ahc->suspend_state.btt;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		for (i = 0;i < AHC_NUM_TARGETS; i++) {
			int j;
d4217 4
a4220 2
			for (j = 0;j < AHC_NUM_LUNS; j++) {
				u_int tcl;
d4222 9
a4230 3
				tcl = BUILD_TCL(i << 4, j);
				ahc_busy_tcl(ahc, tcl, *ptr);
			}
d4232 1
a4233 2
	return (0);
}
d4235 3
a4237 10
/************************** Busy Target Table *********************************/
/*
 * Return the untagged transaction id for a given target/channel lun.
 * Optionally, clear the entry.
 */
u_int
ahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl)
{
	u_int scbid;
	u_int target_offset;
d4239 5
a4243 14
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
		
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		scbid = ahc_inb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl));
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		scbid = ahc_inb(ahc, BUSY_TARGETS + target_offset);
	}

	return (scbid);
}
d4245 8
a4252 15
void
ahc_unbusy_tcl(struct ahc_softc *ahc, u_int tcl)
{
	u_int target_offset;

	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
		
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		ahc_outb(ahc, SCB_64_BTT+TCL_TARGET_OFFSET(tcl), SCB_LIST_NULL);
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		ahc_outb(ahc, BUSY_TARGETS + target_offset, SCB_LIST_NULL);
a4253 6
}

void
ahc_busy_tcl(struct ahc_softc *ahc, u_int tcl, u_int scbid)
{
	u_int target_offset;
d4255 4
a4258 2
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
d4260 2
a4261 19
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		ahc_outb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl), scbid);
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		ahc_outb(ahc, BUSY_TARGETS + target_offset, scbid);
	}
}

/************************** SCB and SCB queue management **********************/
int
ahc_match_scb(struct ahc_softc *ahc, struct scb *scb, int target,
	      char channel, int lun, u_int tag, role_t role)
{
	int targ = SCB_GET_TARGET(ahc, scb);
	char chan = SCB_GET_CHANNEL(ahc, scb);
	int slun = SCB_GET_LUN(scb);
	int match;
d4263 5
a4267 22
	match = ((chan == channel) || (channel == ALL_CHANNELS));
	if (match != 0)
		match = ((targ == target) || (target == CAM_TARGET_WILDCARD));
	if (match != 0)
		match = ((lun == slun) || (lun == CAM_LUN_WILDCARD));
	if (match != 0) {
#if AHC_TARGET_MODE
		int group;

		group = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);
		if (role == ROLE_INITIATOR) {
			match = (group != XPT_FC_GROUP_TMODE)
			      && ((tag == scb->hscb->tag)
			       || (tag == SCB_LIST_NULL));
		} else if (role == ROLE_TARGET) {
			match = (group == XPT_FC_GROUP_TMODE)
			      && ((tag == scb->io_ctx->csio.tag_id)
			       || (tag == SCB_LIST_NULL));
		}
#else /* !AHC_TARGET_MODE */
		match = ((tag == scb->hscb->tag) || (tag == SCB_LIST_NULL));
#endif /* AHC_TARGET_MODE */
d4270 1
a4270 1
	return match;
d4273 5
a4277 2
void
ahc_freeze_devq(struct ahc_softc *ahc, struct scb *scb)
d4279 4
a4282 3
	int	target;
	char	channel;
	int	lun;
d4284 3
a4286 7
	target = SCB_GET_TARGET(ahc, scb);
	lun = SCB_GET_LUN(scb);
	channel = SCB_GET_CHANNEL(ahc, scb);
	
	ahc_search_qinfifo(ahc, target, channel, lun,
			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
			   CAM_REQUEUE_REQ, SEARCH_COMPLETE);
a4287 2
	ahc_platform_freeze_devq(ahc, scb);
}
d4289 4
a4292 4
void
ahc_qinfifo_requeue_tail(struct ahc_softc *ahc, struct scb *scb)
{
	struct scb *prev_scb;
d4294 1
a4294 4
	prev_scb = NULL;
	if (ahc_qinfifo_count(ahc) != 0) {
		u_int prev_tag;
		uint8_t prev_pos;
d4296 13
a4308 11
		prev_pos = ahc->qinfifonext - 1;
		prev_tag = ahc->qinfifo[prev_pos];
		prev_scb = ahc_lookup_scb(ahc, prev_tag);
	}
	ahc_qinfifo_requeue(ahc, prev_scb, scb);
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}
}
d4310 8
a4317 6
static void
ahc_qinfifo_requeue(struct ahc_softc *ahc, struct scb *prev_scb,
		    struct scb *scb)
{
	if (prev_scb == NULL) {
		ahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);
d4319 3
a4321 3
		prev_scb->hscb->next = scb->hscb->tag;
		ahc_sync_scb(ahc, prev_scb, 
			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d4323 2
a4324 36
	ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;
	scb->hscb->next = ahc->next_queued_scb->hscb->tag;
	ahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
}

static int
ahc_qinfifo_count(struct ahc_softc *ahc)
{
	u_int8_t qinpos;
	u_int8_t diff;

	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		qinpos = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinpos);
	} else
		qinpos = ahc_inb(ahc, QINPOS);
	diff = ahc->qinfifonext - qinpos;
	return (diff);
}

int
ahc_search_qinfifo(struct ahc_softc *ahc, int target, char channel,
		   int lun, u_int tag, role_t role, uint32_t status,
		   ahc_search_action action)
{
	struct	scb *scb;
	struct	scb *prev_scb;
	uint8_t qinstart;
	uint8_t qinpos;
	uint8_t qintail;
	uint8_t next, prev;
	uint8_t curscbptr;
	int	found;
	int	maxtarget;
	int	i;
	int	have_qregs;
d4326 1
a4326 19
	qintail = ahc->qinfifonext;
	have_qregs = (ahc->features & AHC_QUEUE_REGS) != 0;
	if (have_qregs) {
		qinstart = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinstart);
	} else
		qinstart = ahc_inb(ahc, QINPOS);
	qinpos = qinstart;
	next = ahc_inb(ahc, NEXT_QUEUED_SCB);
	found = 0;
	prev_scb = NULL;
	
	if (action == SEARCH_COMPLETE) {
		/*
		 * Don't attempt to run any queued untagged transactions
		 * until we are done with the abort process.
		 */
		ahc_freeze_untagged_queues(ahc);
	}
d4329 2
a4330 2
	 * Start with an empty queue.  Entries that are not chosen
	 * for removal will be re-added to the queue as we go.
d4332 8
a4339 46
	ahc->qinfifonext = qinpos;
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);

	while (qinpos != qintail) {
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinpos]);
		if (scb == NULL) {
			printf("qinpos = %d, SCB index = %d\n",
				qinpos, ahc->qinfifo[qinpos]);
			panic("Loop 1\n");
		}

		if (ahc_match_scb(ahc, scb, target, channel, lun, tag, role)) {
			/*
			 * We found an scb that needs to be acted on.
			 */
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;

				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb,
								   status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in qinfifo\n");
				ahc_done(ahc, scb);
				/* FALLTHROUGH */
			}
			case SEARCH_REMOVE:
				break;
			case SEARCH_COUNT:
				ahc_qinfifo_requeue(ahc, prev_scb, scb);
				prev_scb = scb;
				break;
			}
		} else {
			ahc_qinfifo_requeue(ahc, prev_scb, scb);
			prev_scb = scb;
		}
		qinpos++;
d4342 4
a4345 5
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}
d4347 3
a4349 16
	if (action != SEARCH_COUNT
	 && (found != 0)
	 && (qinstart != ahc->qinfifonext)) {
		/*
		 * The sequencer may be in the process of dmaing
		 * down the SCB at the beginning of the queue.
		 * This could be problematic if either the first,
		 * or the second SCB is removed from the queue
		 * (the first SCB includes a pointer to the "next"
		 * SCB to dma). If we have removed any entries, swap
		 * the first element in the queue with the next HSCB
		 * so the sequencer will notice that NEXT_QUEUED_SCB
		 * has changed during its dma attempt and will retry
		 * the DMA.
		 */
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinstart]);
d4351 1
a4351 25
		if (scb == NULL) {
			printf("found = %d, qinstart = %d, qinfifionext = %d\n",
				found, qinstart, ahc->qinfifonext);
			panic("First/Second Qinfifo fixup\n");
		}
		/*
		 * ahc_swap_with_next_hscb forces our next pointer to
		 * point to the reserved SCB for future commands.  Save
		 * and restore our original next pointer to maintain
		 * queue integrity.
		 */
		next = scb->hscb->next;
		ahc->scb_data->scbindex[scb->hscb->tag] = NULL;
		ahc_swap_with_next_hscb(ahc, scb);
		scb->hscb->next = next;
		ahc->qinfifo[qinstart] = scb->hscb->tag;

		/* Tell the card about the new head of the qinfifo. */
		ahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);

		/* Fixup the tail "next" pointer. */
		qintail = ahc->qinfifonext - 1;
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qintail]);
		scb->hscb->next = ahc->next_queued_scb->hscb->tag;
	}
d4353 2
a4354 6
	/*
	 * Search waiting for selection list.
	 */
	curscbptr = ahc_inb(ahc, SCBPTR);
	next = ahc_inb(ahc, WAITING_SCBH);  /* Start at head of list. */
	prev = SCB_LIST_NULL;
d4356 13
a4368 2
	while (next != SCB_LIST_NULL) {
		uint8_t scb_index;
d4370 1
a4370 26
		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			printf("Waiting List inconsistency. "
			       "SCB index == %d, yet numscbs == %d.",
			       scb_index, ahc->scb_data->numscbs);
			ahc_dump_card_state(ahc);
			panic("for safety");
		}
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("scb_index = %d, next = %d\n",
				scb_index, next);
			panic("Waiting List traversal\n");
		}
		if (ahc_match_scb(ahc, scb, target, channel,
				  lun, SCB_LIST_NULL, role)) {
			/*
			 * We found an scb that needs to be acted on.
			 */
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;
d4372 5
a4376 20
				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb,
								   status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in Waiting List\n");
				ahc_done(ahc, scb);
				/* FALLTHROUGH */
			}
			case SEARCH_REMOVE:
				next = ahc_rem_wscb(ahc, next, prev);
				break;
			case SEARCH_COUNT:
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
				break;
			}
d4378 3
a4380 3
			
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
a4382 1
	ahc_outb(ahc, SCBPTR, curscbptr);
d4384 15
d4400 1
a4400 1
	 * And lastly, the untagged holding queues.
d4402 47
a4448 2
	i = 0;
	if ((ahc->flags & AHC_SCB_BTT) == 0) {
d4450 3
a4452 2
		maxtarget = 16;
		if (target != CAM_TARGET_WILDCARD) {
d4454 14
a4467 5
			i = target;
			if (channel == 'B')
				i += 8;
			maxtarget = i + 1;
		}
d4469 1
a4469 1
		maxtarget = 0;
d4471 1
d4473 8
a4480 3
	for (; i < maxtarget; i++) {
		struct scb_tailq *untagged_q;
		struct scb *next_scb;
d4482 8
a4489 3
		untagged_q = &(ahc->untagged_queues[i]);
		next_scb = TAILQ_FIRST(untagged_q);
		while (next_scb != NULL) {
d4491 12
a4502 2
			scb = next_scb;
			next_scb = TAILQ_NEXT(scb, links.tqe);
d4504 4
a4507 11
			/*
			 * The head of the list may be the currently
			 * active untagged command for a device.
			 * We're only searching for commands that
			 * have not been started.  A transaction
			 * marked active but still in the qinfifo
			 * is removed by the qinfifo scanning code
			 * above.
			 */
			if ((scb->flags & SCB_ACTIVE) != 0)
				continue;
d4509 1
a4509 34
			if (ahc_match_scb(ahc, scb, target, channel,
					  lun, SCB_LIST_NULL, role)) {
				/*
				 * We found an scb that needs to be acted on.
				 */
				found++;
				switch (action) {
				case SEARCH_COMPLETE:
				{
					cam_status ostat;
					cam_status cstat;

					ostat = ahc_get_transaction_status(scb);
					if (ostat == CAM_REQ_INPROG)
						ahc_set_transaction_status(scb,
								   status);
					cstat = ahc_get_transaction_status(scb);
					if (cstat != CAM_REQ_CMP)
						ahc_freeze_scb(scb);
					if ((scb->flags & SCB_ACTIVE) == 0)
						printf("Inactive SCB in untaggedQ\n");
					ahc_done(ahc, scb);
					break;
				}
				case SEARCH_REMOVE:
					TAILQ_REMOVE(untagged_q, scb,
						     links.tqe);
					break;
				case SEARCH_COUNT:
					break;
				}
			}
		}
	}
d4511 1
a4511 4
	if (action == SEARCH_COMPLETE)
		ahc_release_untagged_queues(ahc);
	return (found);
}
d4513 12
a4524 10
int
ahc_search_disc_list(struct ahc_softc *ahc, int target, char channel,
		     int lun, u_int tag, int stop_on_first, int remove,
		     int save_state)
{
	struct	scb *scbp;
	u_int	next;
	u_int	prev;
	u_int	count;
	u_int	active_scb;
d4526 2
a4527 3
	count = 0;
	next = ahc_inb(ahc, DISCONNECTED_SCBH);
	prev = SCB_LIST_NULL;
d4529 1
a4529 6
	if (save_state) {
		/* restore this when we're done */
		active_scb = ahc_inb(ahc, SCBPTR);
	} else
		/* Silence compiler */
		active_scb = SCB_LIST_NULL;
d4531 2
a4532 2
	while (next != SCB_LIST_NULL) {
		u_int scb_index;
d4534 18
a4551 9
		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			printf("Disconnected List inconsistency. "
			       "SCB index == %d, yet numscbs == %d.",
			       scb_index, ahc->scb_data->numscbs);
			ahc_dump_card_state(ahc);
			panic("for safety");
		}
d4553 12
a4564 22
		if (next == prev) {
			panic("Disconnected List Loop. "
			      "cur SCBPTR == %x, prev SCBPTR == %x.",
			      next, prev);
		}
		scbp = ahc_lookup_scb(ahc, scb_index);
		if (ahc_match_scb(ahc, scbp, target, channel, lun,
				  tag, ROLE_INITIATOR)) {
			count++;
			if (remove) {
				next =
				    ahc_rem_scb_from_disc_list(ahc, prev, next);
			} else {
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
			}
			if (stop_on_first)
				break;
		} else {
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
		}
a4565 3
	if (save_state)
		ahc_outb(ahc, SCBPTR, active_scb);
	return (count);
d4568 4
a4571 6
/*
 * Remove an SCB from the on chip list of disconnected transactions.
 * This is empty/unused if we are not performing SCB paging.
 */
static u_int
ahc_rem_scb_from_disc_list(struct ahc_softc *ahc, u_int prev, u_int scbptr)
d4573 2
a4574 1
	u_int next;
d4576 6
a4581 2
	ahc_outb(ahc, SCBPTR, scbptr);
	next = ahc_inb(ahc, SCB_NEXT);
d4583 5
a4587 1
	ahc_outb(ahc, SCB_CONTROL, 0);
d4589 8
a4596 1
	ahc_add_curscb_to_free_list(ahc);
d4598 9
a4606 5
	if (prev != SCB_LIST_NULL) {
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	} else
		ahc_outb(ahc, DISCONNECTED_SCBH, next);
d4608 5
a4612 2
	return (next);
}
d4614 6
a4619 13
/*
 * Add the SCB as selected by SCBPTR onto the on chip list of
 * free hardware SCBs.  This list is empty/unused if we are not
 * performing SCB paging.
 */
static void
ahc_add_curscb_to_free_list(struct ahc_softc *ahc)
{
	/*
	 * Invalidate the tag so that our abort
	 * routines don't think it's active.
	 */
	ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
d4621 10
a4630 3
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		ahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));
		ahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));
d4632 5
d4639 10
a4648 8
/*
 * Manipulate the waiting for selection list and return the
 * scb that follows the one that we remove.
 */
static u_int
ahc_rem_wscb(struct ahc_softc *ahc, u_int scbpos, u_int prev)
{       
	u_int curscb, next;
d4650 3
a4652 7
	/*
	 * Select the SCB we want to abort and
	 * pull the next pointer out of it.
	 */
	curscb = ahc_inb(ahc, SCBPTR);
	ahc_outb(ahc, SCBPTR, scbpos);
	next = ahc_inb(ahc, SCB_NEXT);
d4654 1
a4654 2
	/* Clear the necessary fields */
	ahc_outb(ahc, SCB_CONTROL, 0);
d4656 1
a4656 1
	ahc_add_curscb_to_free_list(ahc);
d4658 10
a4667 17
	/* update the waiting list */
	if (prev == SCB_LIST_NULL) {
		/* First in the list */
		ahc_outb(ahc, WAITING_SCBH, next); 

		/*
		 * Ensure we aren't attempting to perform
		 * selection for this entry.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else {
		/*
		 * Select the scb that pointed to us 
		 * and update its next pointer.
		 */
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
d4670 6
a4675 5
	/*
	 * Point us back at the original scb position.
	 */
	ahc_outb(ahc, SCBPTR, curscb);
	return next;
d4678 5
a4682 10
/******************************** Error Handling ******************************/
/*
 * Abort all SCBs that match the given description (target/channel/lun/tag),
 * setting their status to the passed in status if the status has not already
 * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
 * is paused before it is called.
 */
int
ahc_abort_scbs(struct ahc_softc *ahc, int target, char channel,
	       int lun, u_int tag, role_t role, uint32_t status)
d4684 7
a4690 7
	struct	scb *scbp;
	struct	scb *scbp_next;
	u_int	active_scb;
	int	i, j;
	int	maxtarget;
	int	minlun;
	int	maxlun;
d4692 1
a4692 1
	int	found;
d4694 2
a4695 5
	/*
	 * Don't attempt to run any queued untagged transactions
	 * until we are done with the abort process.
	 */
	ahc_freeze_untagged_queues(ahc);
d4697 17
a4713 2
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
d4715 5
a4719 2
	found = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,
				   role, CAM_REQUEUE_REQ, SEARCH_COMPLETE);
d4721 1
a4721 11
	/*
	 * Clean out the busy target table for any untagged commands.
	 */
	i = 0;
	maxtarget = 16;
	if (target != CAM_TARGET_WILDCARD) {
		i = target;
		if (channel == 'B')
			i += 8;
		maxtarget = i + 1;
	}
d4723 1
a4723 1
	if (lun == CAM_LUN_WILDCARD) {
d4725 2
a4726 14
		/*
		 * Unless we are using an SCB based
		 * busy targets table, there is only
		 * one table entry for all luns of
		 * a target.
		 */
		minlun = 0;
		maxlun = 1;
		if ((ahc->flags & AHC_SCB_BTT) != 0)
			maxlun = AHC_NUM_LUNS;
	} else {
		minlun = lun;
		maxlun = lun + 1;
	}
d4728 10
a4737 3
	for (;i < maxtarget; i++) {
		for (j = minlun;j < maxlun; j++)
			ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, j));
d4739 14
d4754 3
a4756 9
	/*
	 * Go through the disconnected list and remove any entries we
	 * have queued for completion, 0'ing their control byte too.
	 * We save the active SCB and restore it ourselves, so there
	 * is no reason for this search to restore it too.
	 */
	ahc_search_disc_list(ahc, target, channel, lun, tag,
			     /*stop_on_first*/FALSE, /*remove*/TRUE,
			     /*save_state*/FALSE);
d4758 22
a4779 37
	/*
	 * Go through the hardware SCB array looking for commands that
	 * were active but not on any list.
	 */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scbid;

		ahc_outb(ahc, SCBPTR, i);
		scbid = ahc_inb(ahc, SCB_TAG);
		scbp = ahc_lookup_scb(ahc, scbid);
		if (scbp != NULL
		 && ahc_match_scb(ahc, scbp, target, channel, lun, tag, role))
			ahc_add_curscb_to_free_list(ahc);
	}

	/*
	 * Go through the pending CCB list and look for
	 * commands for this target that are still active.
	 * These are other tagged commands that were
	 * disconnected when the reset occurred.
	 */
	scbp_next = LIST_FIRST(&ahc->pending_scbs);
	while (scbp_next != NULL) {
		scbp = scbp_next;
		scbp_next = LIST_NEXT(scbp, pending_links);
		if (ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)) {
			cam_status ostat;

			ostat = ahc_get_transaction_status(scbp);
			if (ostat == CAM_REQ_INPROG)
				ahc_set_transaction_status(scbp, status);
			if (ahc_get_transaction_status(scbp) != CAM_REQ_CMP)
				ahc_freeze_scb(scbp);
			if ((scbp->flags & SCB_ACTIVE) == 0)
				printf("Inactive SCB on pending list\n");
			ahc_done(ahc, scbp);
			found++;
d4781 6
a4787 4
	ahc_outb(ahc, SCBPTR, active_scb);
	ahc_platform_abort_scbs(ahc, target, channel, lun, tag, role, status);
	ahc_release_untagged_queues(ahc);
	return found;
d4790 4
a4793 2
static void
ahc_reset_current_bus(struct ahc_softc *ahc)
a4794 1
	uint8_t scsiseq;
d4796 4
a4799 6
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);
	scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);
	ahc_delay(AHC_BUSRESET_DELAY);
	/* Turn off the bus reset */
	ahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);
d4801 6
a4806 1
	ahc_clear_intstat(ahc);
d4808 11
a4818 2
	/* Re-enable reset interrupts */
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);
d4821 2
a4822 2
int
ahc_reset_channel(struct ahc_softc *ahc, char channel, int initiate_reset)
d4824 8
a4831 10
	struct	ahc_devinfo devinfo;
	u_int	initiator, target, max_scsiid;
	u_int	sblkctl;
	u_int	scsiseq;
	u_int	simode1;
	int	found;
	int	restart_needed;
	char	cur_channel;

	ahc->pending_device = NULL;
d4833 2
a4834 6
	ahc_compile_devinfo(&devinfo,
			    CAM_TARGET_WILDCARD,
			    CAM_TARGET_WILDCARD,
			    CAM_LUN_WILDCARD,
			    channel, ROLE_UNKNOWN);
	ahc_pause(ahc);
d4836 1
a4836 2
	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);
d4839 4
a4842 3
	 * Run our command complete fifos to ensure that we perform
	 * completion processing on any commands that 'completed'
	 * before the reset occurred.
d4844 11
a4854 4
	ahc_run_qoutfifo(ahc);
#if AHC_TARGET_MODE
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		ahc_run_tqinfifo(ahc, /*paused*/TRUE);
a4855 1
#endif
d4857 6
d4864 2
a4865 1
	 * Reset the bus if we are initiating this reset
d4867 40
a4906 18
	sblkctl = ahc_inb(ahc, SBLKCTL);
	cur_channel = 'A';
	if ((ahc->features & AHC_TWIN) != 0
	 && ((sblkctl & SELBUSB) != 0))
	    cur_channel = 'B';
	scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
	if (cur_channel != channel) {
		/* Case 1: Command for another bus is active
		 * Stealthily reset the other bus without
		 * upsetting the current bus.
		 */
		ahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);
		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
#if AHC_TARGET_MODE
d4908 2
a4909 3
		 * Bus resets clear ENSELI, so we cannot
		 * defer re-enabling bus reset interrupts
		 * if we are in target mode.
d4911 5
a4915 6
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			ahc_outb(ahc, SIMODE1, simode1 | ENSCSIRST);
#endif
		ahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));
		ahc_outb(ahc, SBLKCTL, sblkctl);
		restart_needed = FALSE;
a4916 8
		/* Case 2: A command from this bus is active or we're idle */
		ahc_clear_msg_state(ahc);
		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
#if AHC_TARGET_MODE
d4918 20
a4937 3
		 * Bus resets clear ENSELI, so we cannot
		 * defer re-enabling bus reset interrupts
		 * if we are in target mode.
d4939 59
a4997 6
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			ahc_outb(ahc, SIMODE1, simode1 | ENSCSIRST);
#endif
		ahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));
		restart_needed = TRUE;
	}
d4999 14
a5012 7
	/*
	 * Clean up all the state information for the
	 * pending transactions on this bus.
	 */
	found = ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, channel,
			       CAM_LUN_WILDCARD, SCB_LIST_NULL,
			       ROLE_UNKNOWN, CAM_SCSI_BUS_RESET);
d5014 7
a5020 1
	max_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;
d5022 2
a5023 8
#ifdef AHC_TARGET_MODE
	/*
	 * Send an immediate notify ccb to all target more peripheral
	 * drivers affected by this action.
	 */
	for (target = 0; target <= max_scsiid; target++) {
		struct ahc_tmode_tstate* tstate;
		u_int lun;
d5025 7
a5031 5
		tstate = ahc->enabled_targets[target];
		if (tstate == NULL)
			continue;
		for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
			struct ahc_tmode_lstate* lstate;
d5033 21
a5053 3
			lstate = tstate->enabled_luns[lun];
			if (lstate == NULL)
				continue;
d5055 42
a5096 3
			ahc_queue_lstate_event(ahc, lstate, CAM_TARGET_WILDCARD,
					       EVENT_TYPE_BUS_RESET, /*arg*/0);
			ahc_send_lstate_events(ahc, lstate);
d5099 22
a5120 4
#endif
	/* Notify the XPT that a bus reset occurred */
	ahc_send_async(ahc, devinfo.channel, CAM_TARGET_WILDCARD,
		       CAM_LUN_WILDCARD, AC_BUS_RESET, NULL);
d5123 2
a5124 1
	 * Revert to async/narrow transfers until we renegotiate.
d5126 3
a5128 1
	for (target = 0; target <= max_scsiid; target++) {
d5130 25
a5154 14
		if (ahc->enabled_targets[target] == NULL)
			continue;
		for (initiator = 0; initiator <= max_scsiid; initiator++) {
			struct ahc_devinfo devinfo;

			ahc_compile_devinfo(&devinfo, target, initiator,
					    CAM_LUN_WILDCARD,
					    channel, ROLE_UNKNOWN);
			ahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
				      AHC_TRANS_CUR, /*paused*/TRUE);
			ahc_set_syncrate(ahc, &devinfo, /*syncrate*/NULL,
					 /*period*/0, /*offset*/0,
					 /*ppr_options*/0, AHC_TRANS_CUR,
					 /*paused*/TRUE);
d5156 9
d5167 1
a5167 5
	if (restart_needed)
		ahc_restart(ahc);
	else
		ahc_unpause(ahc);
	return found;
a5169 2

/***************************** Residual Processing ****************************/
d5171 4
a5174 1
 * Calculate the residual for a just completed SCB.
d5176 9
a5184 2
void
ahc_calc_residual(struct scb *scb)
d5186 4
a5189 21
	struct hardware_scb *hscb;
	struct status_pkt *spkt;
	uint32_t sgptr;
	uint32_t resid_sgptr;
	uint32_t resid;

	/*
	 * 5 cases.
	 * 1) No residual.
	 *    SG_RESID_VALID clear in sgptr.
	 * 2) Transferless command
	 * 3) Never performed any transfers.
	 *    sgptr has SG_FULL_RESID set.
	 * 4) No residual but target did not
	 *    save data pointers after the
	 *    last transfer, so sgptr was
	 *    never updated.
	 * 5) We have a partial residual.
	 *    Use residual_sgptr to determine
	 *    where we are.
	 */
d5191 2
a5192 6
	hscb = scb->hscb;
	sgptr = ahc_le32toh(hscb->sgptr);
	if ((sgptr & SG_RESID_VALID) == 0)
		/* Case 1 */
		return;
	sgptr &= ~SG_RESID_VALID;
d5194 2
a5195 3
	if ((sgptr & SG_LIST_NULL) != 0)
		/* Case 2 */
		return;
d5197 8
a5204 12
	spkt = &hscb->shared_data.status;
	resid_sgptr = ahc_le32toh(spkt->residual_sg_ptr);
	if ((sgptr & SG_FULL_RESID) != 0) {
		/* Case 3 */
		resid = ahc_get_transfer_length(scb);
	} else if ((resid_sgptr & SG_LIST_NULL) != 0) {
		/* Case 4 */
		return;
	} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {
		panic("Bogus resid sgptr value 0x%x\n", resid_sgptr);
	} else {
		struct ahc_dma_seg *sg;
d5206 2
a5207 6
		/*
		 * Remainder of the SG where the transfer
		 * stopped.  
		 */
		resid = ahc_le32toh(spkt->residual_datacnt) & AHC_SG_LEN_MASK;
		sg = ahc_sg_bus_to_virt(scb, resid_sgptr & SG_PTR_MASK);
d5209 10
a5218 2
		/* The residual sg_ptr always points to the next sg */
		sg--;
d5220 6
a5225 8
		/*
		 * Add up the contents of all residual
		 * SG segments that are after the SG where
		 * the transfer stopped.
		 */
		while ((ahc_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {
			sg++;
			resid += ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
d5228 16
a5243 4
	if ((scb->flags & SCB_SENSE) == 0)
		ahc_set_residual(scb, resid);
	else
		ahc_set_sense_residual(scb, resid);
d5245 6
a5250 4
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC) {
		ahc_print_path(scb->ahc_softc, scb);
		printf("Handled Residual of %d bytes\n", resid);
a5251 2
#endif
}
d5253 8
a5260 18
/******************************* Target Mode **********************************/
#ifdef AHC_TARGET_MODE
/*
 * Add a target mode event to this lun's queue
 */
static void
ahc_queue_lstate_event(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate,
		       u_int initiator_id, u_int event_type, u_int event_arg)
{
	struct ahc_tmode_event *event;
	int pending;

	xpt_freeze_devq(lstate->path, /*count*/1);
	if (lstate->event_w_idx >= lstate->event_r_idx)
		pending = lstate->event_w_idx - lstate->event_r_idx;
	else
		pending = AHC_TMODE_EVENT_BUFFER_SIZE + 1
			- (lstate->event_r_idx - lstate->event_w_idx);
d5262 12
a5273 59
	if (event_type == EVENT_TYPE_BUS_RESET
	 || event_type == MSG_BUS_DEV_RESET) {
		/*
		 * Any earlier events are irrelevant, so reset our buffer.
		 * This has the effect of allowing us to deal with reset
		 * floods (an external device holding down the reset line)
		 * without losing the event that is really interesting.
		 */
		lstate->event_r_idx = 0;
		lstate->event_w_idx = 0;
		xpt_release_devq(lstate->path, pending, /*runqueue*/FALSE);
	}

	if (pending == AHC_TMODE_EVENT_BUFFER_SIZE) {
		xpt_print_path(lstate->path);
		printf("immediate event %x:%x lost\n",
		       lstate->event_buffer[lstate->event_r_idx].event_type,
		       lstate->event_buffer[lstate->event_r_idx].event_arg);
		lstate->event_r_idx++;
		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
			lstate->event_r_idx = 0;
		xpt_release_devq(lstate->path, /*count*/1, /*runqueue*/FALSE);
	}

	event = &lstate->event_buffer[lstate->event_w_idx];
	event->initiator_id = initiator_id;
	event->event_type = event_type;
	event->event_arg = event_arg;
	lstate->event_w_idx++;
	if (lstate->event_w_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
		lstate->event_w_idx = 0;
}

/*
 * Send any target mode events queued up waiting
 * for immediate notify resources.
 */
void
ahc_send_lstate_events(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate)
{
	struct ccb_hdr *ccbh;
	struct ccb_immed_notify *inot;

	while (lstate->event_r_idx != lstate->event_w_idx
	    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {
		struct ahc_tmode_event *event;

		event = &lstate->event_buffer[lstate->event_r_idx];
		SLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);
		inot = (struct ccb_immed_notify *)ccbh;
		switch (event->event_type) {
		case EVENT_TYPE_BUS_RESET:
			ccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;
			break;
		default:
			ccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;
			inot->message_args[0] = event->event_type;
			inot->message_args[1] = event->event_arg;
			break;
a5274 6
		inot->initiator_id = event->initiator_id;
		inot->sense_len = 0;
		xpt_done((union ccb *)inot);
		lstate->event_r_idx++;
		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
			lstate->event_r_idx = 0;
d5276 2
a5278 1
#endif
d5280 11
a5290 5
/******************** Sequencer Program Patching/Download *********************/

#ifdef AHC_DUMP_SEQ
void
ahc_dumpseq(struct ahc_softc* ahc)
d5292 5
a5296 2
	int i;
	int max_prog;
d5298 3
a5300 6
	if ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)
		max_prog = 448;
	else if ((ahc->features & AHC_ULTRA2) != 0)
		max_prog = 768;
	else
		max_prog = 512;
d5302 6
a5307 5
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	for (i = 0; i < max_prog; i++) {
		uint8_t ins_bytes[4];
d5309 2
a5310 8
		ahc_insb(ahc, SEQRAM, ins_bytes, 4);
		printf("0x%08x\n", ins_bytes[0] << 24
				 | ins_bytes[1] << 16
				 | ins_bytes[2] << 8
				 | ins_bytes[3]);
	}
}
#endif
d5312 6
a5317 52
static void
ahc_loadseq(struct ahc_softc *ahc)
{
	struct	cs cs_table[num_critical_sections];
	u_int	begin_set[num_critical_sections];
	u_int	end_set[num_critical_sections];
	struct	patch *cur_patch;
	u_int	cs_count;
	u_int	cur_cs;
	u_int	i;
	int	downloaded;
	u_int	skip_addr;
	u_int	sg_prefetch_cnt;
	uint8_t	download_consts[7];

	/*
	 * Start out with 0 critical sections
	 * that apply to this firmware load.
	 */
	cs_count = 0;
	cur_cs = 0;
	memset(begin_set, 0, sizeof(begin_set));
	memset(end_set, 0, sizeof(end_set));

	/* Setup downloadable constant table */
	download_consts[QOUTFIFO_OFFSET] = 0;
	if (ahc->targetcmds != NULL)
		download_consts[QOUTFIFO_OFFSET] += 32;
	download_consts[QINFIFO_OFFSET] = download_consts[QOUTFIFO_OFFSET] + 1;
	download_consts[CACHESIZE_MASK] = ahc->pci_cachesize - 1;
	download_consts[INVERTED_CACHESIZE_MASK] = ~(ahc->pci_cachesize - 1);
	sg_prefetch_cnt = ahc->pci_cachesize;
	if (sg_prefetch_cnt < (2 * sizeof(struct ahc_dma_seg)))
		sg_prefetch_cnt = 2 * sizeof(struct ahc_dma_seg);
	download_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;
	download_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_cnt - 1);
	download_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_cnt - 1);

	cur_patch = patches;
	downloaded = 0;
	skip_addr = 0;
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);

	for (i = 0; i < sizeof(seqprog)/4; i++) {
		if (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {
			/*
			 * Don't download this instruction as it
			 * is in a patch that was removed.
			 */
			continue;
d5319 10
a5328 13
		/*
		 * Move through the CS table until we find a CS
		 * that might apply to this instruction.
		 */
		for (; cur_cs < num_critical_sections; cur_cs++) {
			if (critical_sections[cur_cs].end <= i) {
				if (begin_set[cs_count] == TRUE
				 && end_set[cs_count] == FALSE) {
					cs_table[cs_count].end = downloaded;
				 	end_set[cs_count] = TRUE;
					cs_count++;
				}
				continue;
d5330 5
a5334 6
			if (critical_sections[cur_cs].begin <= i
			 && begin_set[cs_count] == FALSE) {
				cs_table[cs_count].begin = downloaded;
				begin_set[cs_count] = TRUE;
			}
			break;
a5335 2
		ahc_download_instr(ahc, i, download_consts);
		downloaded++;
d5337 3
a5339 15

	ahc->num_critical_sections = cs_count;
	if (cs_count != 0) {

		cs_count *= sizeof(struct cs);
		ahc->critical_sections = malloc(cs_count, M_DEVBUF, M_NOWAIT);
		if (ahc->critical_sections == NULL)
			panic("ahc_loadseq: Could not malloc");
		memcpy(ahc->critical_sections, cs_table, cs_count);
	}
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);
	ahc_restart(ahc);

	if (bootverbose)
		printf(" %d instructions downloaded\n", downloaded);
d5342 5
a5346 3
static int
ahc_check_patch(struct ahc_softc *ahc, struct patch **start_patch,
		u_int start_instr, u_int *skip_addr)
d5348 4
a5351 3
	struct	patch *cur_patch;
	struct	patch *last_patch;
	u_int	num_patches;
d5353 1
a5353 3
	num_patches = sizeof(patches)/sizeof(struct patch);
	last_patch = &patches[num_patches];
	cur_patch = *start_patch;
d5355 1
a5355 1
	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
d5357 5
a5361 1
		if (cur_patch->patch_func(ahc) == 0) {
d5363 2
a5364 11
			/* Start rejecting code */
			*skip_addr = start_instr + cur_patch->skip_instr;
			cur_patch += cur_patch->skip_patch;
		} else {
			/* Accepted this patch.  Advance to the next
			 * one and wait for our intruction pointer to
			 * hit this point.
			 */
			cur_patch++;
		}
	}
d5366 6
a5371 4
	*start_patch = cur_patch;
	if (start_instr < *skip_addr)
		/* Still skipping */
		return (0);
d5373 2
a5374 1
	return (1);
d5377 11
a5387 7
static void
ahc_download_instr(struct ahc_softc *ahc, u_int instrptr, uint8_t *dconsts)
{
	union	ins_formats instr;
	struct	ins_format1 *fmt1_ins;
	struct	ins_format3 *fmt3_ins;
	u_int	opcode;
d5390 2
a5391 1
	 * The firmware is always compiled into a little endian format.
d5393 6
a5398 1
	instr.integer = ahc_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
d5400 1
a5400 2
	fmt1_ins = &instr.format1;
	fmt3_ins = NULL;
d5402 4
a5405 17
	/* Pull the opcode */
	opcode = instr.format1.opcode;
	switch (opcode) {
	case AIC_OP_JMP:
	case AIC_OP_JC:
	case AIC_OP_JNC:
	case AIC_OP_CALL:
	case AIC_OP_JNE:
	case AIC_OP_JNZ:
	case AIC_OP_JE:
	case AIC_OP_JZ:
	{
		struct patch *cur_patch;
		int address_offset;
		u_int address;
		u_int skip_addr;
		u_int i;
d5407 13
a5419 5
		fmt3_ins = &instr.format3;
		address_offset = 0;
		address = fmt3_ins->address;
		cur_patch = patches;
		skip_addr = 0;
d5421 6
a5426 1
		for (i = 0; i < address;) {
d5428 11
a5438 1
			ahc_check_patch(ahc, &cur_patch, i, &skip_addr);
d5440 5
a5444 2
			if (skip_addr > i) {
				int end_addr;
d5446 6
a5451 40
				end_addr = MIN(address, skip_addr);
				address_offset += end_addr - i;
				i = skip_addr;
			} else {
				i++;
			}
		}
		address -= address_offset;
		fmt3_ins->address = address;
		/* FALLTHROUGH */
	}
	case AIC_OP_OR:
	case AIC_OP_AND:
	case AIC_OP_XOR:
	case AIC_OP_ADD:
	case AIC_OP_ADC:
	case AIC_OP_BMOV:
		if (fmt1_ins->parity != 0) {
			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
		}
		fmt1_ins->parity = 0;
		if ((ahc->features & AHC_CMD_CHAN) == 0
		 && opcode == AIC_OP_BMOV) {
			/*
			 * Block move was added at the same time
			 * as the command channel.  Verify that
			 * this is only a move of a single element
			 * and convert the BMOV to a MOV
			 * (AND with an immediate of FF).
			 */
			if (fmt1_ins->immediate != 1)
				panic("%s: BMOV not supported\n",
				      ahc_name(ahc));
			fmt1_ins->opcode = AIC_OP_AND;
			fmt1_ins->immediate = 0xff;
		}
		/* FALLTHROUGH */
	case AIC_OP_ROL:
		if ((ahc->features & AHC_ULTRA2) != 0) {
			int i, count;
d5453 1
a5453 3
			/* Calculate odd parity for the instruction */
			for (i = 0, count = 0; i < 31; i++) {
				uint32_t mask;
d5455 2
a5456 31
				mask = 0x01 << i;
				if ((instr.integer & mask) != 0)
					count++;
			}
			if ((count & 0x01) == 0)
				instr.format1.parity = 1;
		} else {
			/* Compress the instruction for older sequencers */
			if (fmt3_ins != NULL) {
				instr.integer =
					fmt3_ins->immediate
				      | (fmt3_ins->source << 8)
				      | (fmt3_ins->address << 16)
				      |	(fmt3_ins->opcode << 25);
			} else {
				instr.integer =
					fmt1_ins->immediate
				      | (fmt1_ins->source << 8)
				      | (fmt1_ins->destination << 16)
				      |	(fmt1_ins->ret << 24)
				      |	(fmt1_ins->opcode << 25);
			}
		}
		/* The sequencer is a little endian cpu */
		instr.integer = ahc_htole32(instr.integer);
		ahc_outsb(ahc, SEQRAM, instr.bytes, 4);
		break;
	default:
		panic("Unknown opcode encountered in seq program");
		break;
	}
d5459 5
a5463 2
void
ahc_dump_card_state(struct ahc_softc *ahc)
d5465 17
a5481 11
	struct scb *scb;
	struct scb_tailq *untagged_q;
	int target;
	int maxtarget;
	int i;
	uint8_t last_phase;
	uint8_t qinpos;
	uint8_t qintail;
	uint8_t qoutpos;
	uint8_t scb_index;
	uint8_t saved_scbptr;
d5483 31
a5513 1
	saved_scbptr = ahc_inb(ahc, SCBPTR);
d5515 11
a5525 37
	last_phase = ahc_inb(ahc, LASTPHASE);
	printf("%s: Dumping Card State %s, at SEQADDR 0x%x\n",
	       ahc_name(ahc), ahc_lookup_phase_entry(last_phase)->phasemsg,
	       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
	printf("ACCUM = 0x%x, SINDEX = 0x%x, DINDEX = 0x%x, ARG_2 = 0x%x\n",
	       ahc_inb(ahc, ACCUM), ahc_inb(ahc, SINDEX), ahc_inb(ahc, DINDEX),
	       ahc_inb(ahc, ARG_2));
	printf("HCNT = 0x%x\n", ahc_inb(ahc, HCNT));
	printf("SCSISEQ = 0x%x, SBLKCTL = 0x%x\n",
	       ahc_inb(ahc, SCSISEQ), ahc_inb(ahc, SBLKCTL));
	printf(" DFCNTRL = 0x%x, DFSTATUS = 0x%x\n",
	       ahc_inb(ahc, DFCNTRL), ahc_inb(ahc, DFSTATUS));
	printf("LASTPHASE = 0x%x, SCSISIGI = 0x%x, SXFRCTL0 = 0x%x\n",
	       last_phase, ahc_inb(ahc, SCSISIGI), ahc_inb(ahc, SXFRCTL0));
	printf("SSTAT0 = 0x%x, SSTAT1 = 0x%x\n",
	       ahc_inb(ahc, SSTAT0), ahc_inb(ahc, SSTAT1));
	if ((ahc->features & AHC_DT) != 0)
		printf("SCSIPHASE = 0x%x\n", ahc_inb(ahc, SCSIPHASE));
	printf("STACK == 0x%x, 0x%x, 0x%x, 0x%x\n",
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8));
	printf("SCB count = %d\n", ahc->scb_data->numscbs);
	printf("Kernel NEXTQSCB = %d\n", ahc->next_queued_scb->hscb->tag);
	printf("Card NEXTQSCB = %d\n", ahc_inb(ahc, NEXT_QUEUED_SCB));
	/* QINFIFO */
	printf("QINFIFO entries: ");
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		qinpos = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinpos);
	} else
		qinpos = ahc_inb(ahc, QINPOS);
	qintail = ahc->qinfifonext;
	while (qinpos != qintail) {
		printf("%d ", ahc->qinfifo[qinpos]);
		qinpos++;
a5526 1
	printf("\n");
d5528 11
a5538 53
	printf("Waiting Queue entries: ");
	scb_index = ahc_inb(ahc, WAITING_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	printf("Disconnected Queue entries: ");
	scb_index = ahc_inb(ahc, DISCONNECTED_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");
		
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);
	printf("QOUTFIFO entries: ");
	qoutpos = ahc->qoutfifonext;
	i = 0;
	while (ahc->qoutfifo[qoutpos] != SCB_LIST_NULL && i++ < 256) {
		printf("%d ", ahc->qoutfifo[qoutpos]);
		qoutpos++;
	}
	printf("\n");

	printf("Sequencer Free SCB List: ");
	scb_index = ahc_inb(ahc, FREE_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d ", scb_index);
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	printf("Pending list: ");
	i = 0;
	LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
		if (i++ > 256)
			break;
		if (scb != LIST_FIRST(&ahc->pending_scbs))
			printf(", ");
		printf("%d", scb->hscb->tag);
		if ((ahc->flags & AHC_PAGESCBS) == 0) {
			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
			printf("(0x%x, 0x%x)", ahc_inb(ahc, SCB_CONTROL),
			       ahc_inb(ahc, SCB_TAG));
		}
a5539 1
	printf("\n");
d5541 6
a5546 8
	printf("Kernel Free SCB list: ");
	i = 0;
	SLIST_FOREACH(scb, &ahc->scb_data->free_scbs, links.sle) {
		if (i++ > 256)
			break;
		printf("%d ", scb->hscb->tag);
	}
	printf("\n");
d5548 1
a5548 4
	maxtarget = (ahc->features & (AHC_WIDE|AHC_TWIN)) ? 15 : 7;
	for (target = 0; target <= maxtarget; target++) {
		untagged_q = &ahc->untagged_queues[target];
		if (TAILQ_FIRST(untagged_q) == NULL)
d5550 16
a5565 6
		printf("Untagged Q(%d): ", target);
		i = 0;
		TAILQ_FOREACH(scb, untagged_q, links.tqe) {
			if (i++ > 256)
				break;
			printf("%d ", scb->hscb->tag);
a5566 1
		printf("\n");
d5569 5
a5573 2
	ahc_platform_dump_card_state(ahc);
	ahc_outb(ahc, SCBPTR, saved_scbptr);
d5576 13
a5588 22
/************************* Target Mode ****************************************/
#ifdef AHC_TARGET_MODE
cam_status
ahc_find_tmode_devs(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb,
		    struct ahc_tmode_tstate **tstate,
		    struct ahc_tmode_lstate **lstate,
		    int notfound_failure)
{

	if ((ahc->features & AHC_TARGETMODE) == 0)
		return (CAM_REQ_INVALID);

	/*
	 * Handle the 'black hole' device that sucks up
	 * requests to unattached luns on enabled targets.
	 */
	if (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD
	 && ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {
		*tstate = NULL;
		*lstate = ahc->black_hole;
	} else {
		u_int max_id;
d5590 7
a5596 3
		max_id = (ahc->features & AHC_WIDE) ? 15 : 7;
		if (ccb->ccb_h.target_id > max_id)
			return (CAM_TID_INVALID);
d5598 13
a5610 2
		if (ccb->ccb_h.target_lun >= AHC_NUM_LUNS)
			return (CAM_LUN_INVALID);
d5612 10
a5621 11
		*tstate = ahc->enabled_targets[ccb->ccb_h.target_id];
		*lstate = NULL;
		if (*tstate != NULL)
			*lstate =
			    (*tstate)->enabled_luns[ccb->ccb_h.target_lun];
	}

	if (notfound_failure != 0 && *lstate == NULL)
		return (CAM_PATH_INVALID);

	return (CAM_REQ_CMP);
d5624 3
a5626 2
void
ahc_handle_en_lun(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb)
d5628 1
a5628 9
	struct	   ahc_tmode_tstate *tstate;
	struct	   ahc_tmode_lstate *lstate;
	struct	   ccb_en_lun *cel;
	cam_status status;
	u_int	   target;
	u_int	   lun;
	u_int	   target_mask;
	u_long	   s;
	char	   channel;
d5630 1
a5630 2
	status = ahc_find_tmode_devs(ahc, sim, ccb, &tstate, &lstate,
				     /*notfound_failure*/FALSE);
d5632 17
a5648 4
	if (status != CAM_REQ_CMP) {
		ccb->ccb_h.status = status;
		return;
	}
d5650 8
a5657 2
	if ((ahc->features & AHC_MULTIROLE) != 0) {
		u_int	   our_id;
d5659 3
a5661 27
		if (cam_sim_bus(sim) == 0)
			our_id = ahc->our_id;
		else
			our_id = ahc->our_id_b;

		if (ccb->ccb_h.target_id != our_id) {
			if ((ahc->features & AHC_MULTI_TID) != 0
		   	 && (ahc->flags & AHC_INITIATORROLE) != 0) {
				/*
				 * Only allow additional targets if
				 * the initiator role is disabled.
				 * The hardware cannot handle a re-select-in
				 * on the initiator id during a re-select-out
				 * on a different target id.
				 */
				status = CAM_TID_INVALID;
			} else if ((ahc->flags & AHC_INITIATORROLE) != 0
				|| ahc->enabled_luns > 0) {
				/*
				 * Only allow our target id to change
				 * if the initiator role is not configured
				 * and there are no enabled luns which
				 * are attached to the currently registered
				 * scsi id.
				 */
				status = CAM_TID_INVALID;
			}
d5663 1
d5666 10
a5675 3
	if (status != CAM_REQ_CMP) {
		ccb->ccb_h.status = status;
		return;
d5677 11
d5690 2
a5691 2
	 * We now have an id that is valid.
	 * If we aren't in target mode, switch modes.
d5693 31
a5723 25
	if ((ahc->flags & AHC_TARGETROLE) == 0
	 && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
		u_long	s;

		printf("Configuring Target Mode\n");
		ahc_lock(ahc, &s);
		if (LIST_FIRST(&ahc->pending_scbs) != NULL) {
			ccb->ccb_h.status = CAM_BUSY;
			ahc_unlock(ahc, &s);
			return;
		}
		ahc->flags |= AHC_TARGETROLE;
		if ((ahc->features & AHC_MULTIROLE) == 0)
			ahc->flags &= ~AHC_INITIATORROLE;
		ahc_pause(ahc);
		ahc_loadseq(ahc);
		ahc_unlock(ahc, &s);
	}
	cel = &ccb->cel;
	target = ccb->ccb_h.target_id;
	lun = ccb->ccb_h.target_lun;
	channel = SIM_CHANNEL(ahc, sim);
	target_mask = 0x01 << target;
	if (channel == 'B')
		target_mask <<= 8;
d5725 2
a5726 2
	if (cel->enable != 0) {
		u_int scsiseq;
d5728 4
a5731 7
		/* Are we already enabled?? */
		if (lstate != NULL) {
			xpt_print_path(ccb->ccb_h.path);
			printf("Lun already enabled\n");
			ccb->ccb_h.status = CAM_LUN_ALRDY_ENA;
			return;
		}
d5733 11
a5743 10
		if (cel->grp6_len != 0
		 || cel->grp7_len != 0) {
			/*
			 * Don't (yet?) support vendor
			 * specific commands.
			 */
			ccb->ccb_h.status = CAM_REQ_INVALID;
			printf("Non-zero Group Codes\n");
			return;
		}
d5745 21
a5765 12
		/*
		 * Seems to be okay.
		 * Setup our data structures.
		 */
		if (target != CAM_TARGET_WILDCARD && tstate == NULL) {
			tstate = ahc_alloc_tstate(ahc, target, channel);
			if (tstate == NULL) {
				xpt_print_path(ccb->ccb_h.path);
				printf("Couldn't allocate tstate\n");
				ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
				return;
			}
d5767 3
a5769 41
		lstate = malloc(sizeof(*lstate), M_DEVBUF, M_NOWAIT);
		if (lstate == NULL) {
			xpt_print_path(ccb->ccb_h.path);
			printf("Couldn't allocate lstate\n");
			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
			return;
		}
		memset(lstate, 0, sizeof(*lstate));
		status = xpt_create_path(&lstate->path, /*periph*/NULL,
					 xpt_path_path_id(ccb->ccb_h.path),
					 xpt_path_target_id(ccb->ccb_h.path),
					 xpt_path_lun_id(ccb->ccb_h.path));
		if (status != CAM_REQ_CMP) {
			free(lstate, M_DEVBUF);
			xpt_print_path(ccb->ccb_h.path);
			printf("Couldn't allocate path\n");
			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
			return;
		}
		SLIST_INIT(&lstate->accept_tios);
		SLIST_INIT(&lstate->immed_notifies);
		ahc_lock(ahc, &s);
		ahc_pause(ahc);
		if (target != CAM_TARGET_WILDCARD) {
			tstate->enabled_luns[lun] = lstate;
			ahc->enabled_luns++;

			if ((ahc->features & AHC_MULTI_TID) != 0) {
				u_int targid_mask;

				targid_mask = ahc_inb(ahc, TARGID)
					    | (ahc_inb(ahc, TARGID + 1) << 8);

				targid_mask |= target_mask;
				ahc_outb(ahc, TARGID, targid_mask);
				ahc_outb(ahc, TARGID+1, (targid_mask >> 8));
				
				ahc_update_scsiid(ahc, targid_mask);
			} else {
				u_int our_id;
				char  channel;
d5771 6
a5776 2
				channel = SIM_CHANNEL(ahc, sim);
				our_id = SIM_SCSI_ID(ahc, sim);
d5778 1
a5778 23
				/*
				 * This can only happen if selections
				 * are not enabled
				 */
				if (target != our_id) {
					u_int sblkctl;
					char  cur_channel;
					int   swap;

					sblkctl = ahc_inb(ahc, SBLKCTL);
					cur_channel = (sblkctl & SELBUSB)
						    ? 'B' : 'A';
					if ((ahc->features & AHC_TWIN) == 0)
						cur_channel = 'A';
					swap = cur_channel != channel;
					if (channel == 'A')
						ahc->our_id = target;
					else
						ahc->our_id_b = target;

					if (swap)
						ahc_outb(ahc, SBLKCTL,
							 sblkctl ^ SELBUSB);
d5780 1
a5780 1
					ahc_outb(ahc, SCSIID, target);
d5782 9
a5790 23
					if (swap)
						ahc_outb(ahc, SBLKCTL, sblkctl);
				}
			}
		} else
			ahc->black_hole = lstate;
		/* Allow select-in operations */
		if (ahc->black_hole != NULL && ahc->enabled_luns > 0) {
			scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
			scsiseq |= ENSELI;
			ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);
			scsiseq = ahc_inb(ahc, SCSISEQ);
			scsiseq |= ENSELI;
			ahc_outb(ahc, SCSISEQ, scsiseq);
		}
		ahc_unpause(ahc);
		ahc_unlock(ahc, &s);
		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_print_path(ccb->ccb_h.path);
		printf("Lun now enabled for target mode\n");
	} else {
		struct scb *scb;
		int i, empty;
d5792 5
a5796 4
		if (lstate == NULL) {
			ccb->ccb_h.status = CAM_LUN_INVALID;
			return;
		}
d5798 1
a5798 15
		ahc_lock(ahc, &s);
		
		ccb->ccb_h.status = CAM_REQ_CMP;
		LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
			struct ccb_hdr *ccbh;

			ccbh = &scb->io_ctx->ccb_h;
			if (ccbh->func_code == XPT_CONT_TARGET_IO
			 && !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){
				printf("CTIO pending\n");
				ccb->ccb_h.status = CAM_REQ_INVALID;
				ahc_unlock(ahc, &s);
				return;
			}
		}
d5800 2
a5801 4
		if (SLIST_FIRST(&lstate->accept_tios) != NULL) {
			printf("ATIOs pending\n");
			ccb->ccb_h.status = CAM_REQ_INVALID;
		}
d5803 2
a5804 4
		if (SLIST_FIRST(&lstate->immed_notifies) != NULL) {
			printf("INOTs pending\n");
			ccb->ccb_h.status = CAM_REQ_INVALID;
		}
d5806 6
a5811 4
		if (ccb->ccb_h.status != CAM_REQ_CMP) {
			ahc_unlock(ahc, &s);
			return;
		}
d5813 3
a5815 15
		xpt_print_path(ccb->ccb_h.path);
		printf("Target mode disabled\n");
		xpt_free_path(lstate->path);
		free(lstate, M_DEVBUF);

		ahc_pause(ahc);
		/* Can we clean up the target too? */
		if (target != CAM_TARGET_WILDCARD) {
			tstate->enabled_luns[lun] = NULL;
			ahc->enabled_luns--;
			for (empty = 1, i = 0; i < 8; i++)
				if (tstate->enabled_luns[i] != NULL) {
					empty = 0;
					break;
				}
d5817 2
a5818 49
			if (empty) {
				ahc_free_tstate(ahc, target, channel,
						/*force*/FALSE);
				if (ahc->features & AHC_MULTI_TID) {
					u_int targid_mask;

					targid_mask = ahc_inb(ahc, TARGID)
						    | (ahc_inb(ahc, TARGID + 1)
						       << 8);

					targid_mask &= ~target_mask;
					ahc_outb(ahc, TARGID, targid_mask);
					ahc_outb(ahc, TARGID+1,
					 	 (targid_mask >> 8));
					ahc_update_scsiid(ahc, targid_mask);
				}
			}
		} else {

			ahc->black_hole = NULL;

			/*
			 * We can't allow selections without
			 * our black hole device.
			 */
			empty = TRUE;
		}
		if (ahc->enabled_luns == 0) {
			/* Disallow select-in */
			u_int scsiseq;

			scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
			scsiseq &= ~ENSELI;
			ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);
			scsiseq = ahc_inb(ahc, SCSISEQ);
			scsiseq &= ~ENSELI;
			ahc_outb(ahc, SCSISEQ, scsiseq);

			if ((ahc->features & AHC_MULTIROLE) == 0) {
				printf("Configuring Initiator Mode\n");
				ahc->flags &= ~AHC_TARGETROLE;
				ahc->flags |= AHC_INITIATORROLE;
				ahc_pause(ahc);
				ahc_loadseq(ahc);
			}
		}
		ahc_unpause(ahc);
		ahc_unlock(ahc, &s);
	}
d5821 4
a5824 2
static void
ahc_update_scsiid(struct ahc_softc *ahc, u_int targid_mask)
d5826 5
a5830 2
	u_int scsiid_mask;
	u_int scsiid;
d5832 2
a5833 2
	if ((ahc->features & AHC_MULTI_TID) == 0)
		panic("ahc_update_scsiid called on non-multitid unit\n");
d5835 2
a5836 13
	/*
	 * Since we will rely on the the TARGID mask
	 * for selection enables, ensure that OID
	 * in SCSIID is not set to some other ID
	 * that we don't want to allow selections on.
	 */
	if ((ahc->features & AHC_ULTRA2) != 0)
		scsiid = ahc_inb(ahc, SCSIID_ULTRA2);
	else
		scsiid = ahc_inb(ahc, SCSIID);
	scsiid_mask = 0x1 << (scsiid & OID);
	if ((targid_mask & scsiid_mask) == 0) {
		u_int our_id;
d5838 7
a5844 14
		/* ffs counts from 1 */
		our_id = ffs(targid_mask);
		if (our_id == 0)
			our_id = ahc->our_id;
		else
			our_id--;
		scsiid &= TID;
		scsiid |= our_id;
	}
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, scsiid);
	else
		ahc_outb(ahc, SCSIID, scsiid);
}
d5846 2
a5847 4
void
ahc_run_tqinfifo(struct ahc_softc *ahc, int paused)
{
	struct target_cmd *cmd;
d5850 11
a5860 6
	 * If the card supports auto-access pause,
	 * we can access the card directly regardless
	 * of whether it is paused or not.
	 */
	if ((ahc->features & AHC_AUTOPAUSE) != 0)
		paused = TRUE;
d5862 14
a5875 38
	ahc_sync_tqinfifo(ahc, BUS_DMASYNC_POSTREAD);
	while ((cmd = &ahc->targetcmds[ahc->tqinfifonext])->cmd_valid != 0) {

		/*
		 * Only advance through the queue if we
		 * have the resources to process the command.
		 */
		if (ahc_handle_target_cmd(ahc, cmd) != 0)
			break;

		cmd->cmd_valid = 0;
		ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
				ahc->shared_data_dmamap,
				ahc_targetcmd_offset(ahc, ahc->tqinfifonext),
				sizeof(struct target_cmd),
				BUS_DMASYNC_PREREAD);
		ahc->tqinfifonext++;

		/*
		 * Lazily update our position in the target mode incoming
		 * command queue as seen by the sequencer.
		 */
		if ((ahc->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {
			if ((ahc->features & AHC_HS_MAILBOX) != 0) {
				u_int hs_mailbox;

				hs_mailbox = ahc_inb(ahc, HS_MAILBOX);
				hs_mailbox &= ~HOST_TQINPOS;
				hs_mailbox |= ahc->tqinfifonext & HOST_TQINPOS;
				ahc_outb(ahc, HS_MAILBOX, hs_mailbox);
			} else {
				if (!paused)
					ahc_pause(ahc);	
				ahc_outb(ahc, KERNEL_TQINPOS,
					 ahc->tqinfifonext & HOST_TQINPOS);
				if (!paused)
					ahc_unpause(ahc);
			}
d5880 5
a5884 2
static int
ahc_handle_target_cmd(struct ahc_softc *ahc, struct target_cmd *cmd)
d5886 4
a5889 17
	struct	  ahc_tmode_tstate *tstate;
	struct	  ahc_tmode_lstate *lstate;
	struct	  ccb_accept_tio *atio;
	uint8_t *byte;
	int	  initiator;
	int	  target;
	int	  lun;

	initiator = SCSIID_TARGET(ahc, cmd->scsiid);
	target = SCSIID_OUR_ID(cmd->scsiid);
	lun    = (cmd->identify & MSG_IDENTIFY_LUNMASK);

	byte = cmd->bytes;
	tstate = ahc->enabled_targets[target];
	lstate = NULL;
	if (tstate != NULL)
		lstate = tstate->enabled_luns[lun];
d5891 2
a5892 27
	/*
	 * Commands for disabled luns go to the black hole driver.
	 */
	if (lstate == NULL)
		lstate = ahc->black_hole;

	atio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);
	if (atio == NULL) {
		ahc->flags |= AHC_TQINFIFO_BLOCKED;
		/*
		 * Wait for more ATIOs from the peripheral driver for this lun.
		 */
		return (1);
	} else
		ahc->flags &= ~AHC_TQINFIFO_BLOCKED;
#if 0
	printf("Incoming command from %d for %d:%d%s\n",
	       initiator, target, lun,
	       lstate == ahc->black_hole ? "(Black Holed)" : "");
#endif
	SLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);

	if (lstate == ahc->black_hole) {
		/* Fill in the wildcards */
		atio->ccb_h.target_id = target;
		atio->ccb_h.target_lun = lun;
	}
d5895 2
a5896 2
	 * Package it up and send it off to
	 * whomever has this lun enabled.
d5898 4
a5901 11
	atio->sense_len = 0;
	atio->init_id = initiator;
	if (byte[0] != 0xFF) {
		/* Tag was included */
		atio->tag_action = *byte++;
		atio->tag_id = *byte++;
		atio->ccb_h.flags = CAM_TAG_ACTION_VALID;
	} else {
		atio->ccb_h.flags = 0;
	}
	byte++;
d5903 4
a5906 24
	/* Okay.  Now determine the cdb size based on the command code */
	switch (*byte >> CMD_GROUP_CODE_SHIFT) {
	case 0:
		atio->cdb_len = 6;
		break;
	case 1:
	case 2:
		atio->cdb_len = 10;
		break;
	case 4:
		atio->cdb_len = 16;
		break;
	case 5:
		atio->cdb_len = 12;
		break;
	case 3:
	default:
		/* Only copy the opcode. */
		atio->cdb_len = 1;
		printf("Reserved or VU command code type encountered\n");
		break;
	}
	
	memcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);
d5908 2
a5909 1
	atio->ccb_h.status |= CAM_CDB_RECVD;
d5911 1
a5911 17
	if ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {
		/*
		 * We weren't allowed to disconnect.
		 * We're hanging on the bus until a
		 * continue target I/O comes in response
		 * to this accept tio.
		 */
#if 0
		printf("Received Immediate Command %d:%d:%d - %p\n",
		       initiator, target, lun, ahc->pending_device);
#endif
		ahc->pending_device = lstate;
		ahc_freeze_ccb((union ccb *)atio);
		atio->ccb_h.flags |= CAM_DIS_DISCONNECT;
	}
	xpt_done((union ccb*)atio);
	return (0);
a5912 2

#endif
@


1.18.6.8
log
@Merge in -current from about a week ago
@
text
@d2 1
a2 5
 * Generic driver for the aic7xxx based adaptec SCSI controllers
 * Product specific probe and attach routines can be found in:
 * i386/eisa/ahc_eisa.c	27/284X and aic7770 motherboard controllers
 * pci/ahc_pci.c	3985, 3980, 3940, 2940, aic7895, aic7890,
 *			aic7880, aic7870, aic7860, and aic7850 controllers
d4 1
a4 1
 * Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999, 2000 Justin T. Gibbs.
d17 1
a17 1
 * the GNU Public License ("GPL").
d31 1
a31 50
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.40 2000/01/07 23:08:17 gibbs Exp $
 * $OpenBSD$
 */
/*
 * A few notes on features of the driver.
 *
 * SCB paging takes advantage of the fact that devices stay disconnected
 * from the bus a relatively long time and that while they're disconnected,
 * having the SCBs for these transactions down on the host adapter is of
 * little use.  Instead of leaving this idle SCB down on the card we copy
 * it back up into kernel memory and reuse the SCB slot on the card to
 * schedule another transaction.  This can be a real payoff when doing random
 * I/O to tagged queueing devices since there are more transactions active at
 * once for the device to sort for optimal seek reduction. The algorithm goes
 * like this...
 *
 * The sequencer maintains two lists of its hardware SCBs.  The first is the
 * singly linked free list which tracks all SCBs that are not currently in
 * use.  The second is the doubly linked disconnected list which holds the
 * SCBs of transactions that are in the disconnected state sorted most
 * recently disconnected first.  When the kernel queues a transaction to
 * the card, a hardware SCB to "house" this transaction is retrieved from
 * either of these two lists.  If the SCB came from the disconnected list,
 * a check is made to see if any data transfer or SCB linking (more on linking
 * in a bit) information has been changed since it was copied from the host
 * and if so, DMAs the SCB back up before it can be used.  Once a hardware
 * SCB has been obtained, the SCB is DMAed from the host.  Before any work
 * can begin on this SCB, the sequencer must ensure that either the SCB is
 * for a tagged transaction or the target is not already working on another
 * non-tagged transaction.  If a conflict arises in the non-tagged case, the
 * sequencer finds the SCB for the active transactions and sets the SCB_LINKED
 * field in that SCB to this next SCB to execute.  To facilitate finding
 * active non-tagged SCBs, the last four bytes of up to the first four hardware
 * SCBs serve as a storage area for the currently active SCB ID for each
 * target.
 *
 * When a device reconnects, a search is made of the hardware SCBs to find
 * the SCB for this transaction.  If the search fails, a hardware SCB is
 * pulled from either the free or disconnected SCB list and the proper
 * SCB is DMAed from the host.  If the MK_MESSAGE control bit is set
 * in the control byte of the SCB while it was disconnected, the sequencer
 * will assert ATN and attempt to issue a message to the host.
 *
 * When a command completes, a check for non-zero status and residuals is
 * made.  If either of these conditions exists, the SCB is DMAed back up to
 * the host so that it can interpret this information.  Additionally, in the
 * case of bad status, the sequencer generates a special interrupt and pauses
 * itself.  This allows the host to setup a request sense command if it 
 * chooses for this target synchronously with the error so that sense
 * information isn't lost.
d33 1
d36 12
a47 14
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/proc.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_message.h>
#include <scsi/scsi_debug.h>
#include <scsi/scsiconf.h>
d49 19
a67 7
#include <uvm/uvm_extern.h>

#include <dev/ic/aic7xxxreg.h>
#include <dev/ic/aic7xxxvar.h>
#include <dev/microcode/aic7xxx/aic7xxx_seq.h>
#include <dev/microcode/aic7xxx/sequencer.h>
#include "pci.h"
d70 1
a70 2
 * Some ISA devices (e.g. on a VLB) can perform 32-bit DMA.  This
 * flag is passed to bus_dmamap_create() to indicate that fact.
d72 4
a75 3
#ifndef ISABUS_DMA_32BIT
#define ISABUS_DMA_32BIT	BUS_DMA_BUS1
#endif 
d77 11
a87 4
#ifndef AHC_TMODE_ENABLE
#define AHC_TMODE_ENABLE 0
#endif
#include <sys/kernel.h>
d89 13
a101 3
#ifndef le32toh
#define le32toh	letoh32  /* to match Free/Net macros */
#endif
d103 5
a107 49
#define	IS_SCSIBUS_B(ahc, sc_link)	\
	((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
#define ALL_CHANNELS '\0'
#define ALL_TARGETS_MASK 0xFFFF
#define INITIATOR_WILDCARD	(~0)

#define	SIM_IS_SCSIBUS_B(ahc, sc_link)	\
	((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
#define	SIM_CHANNEL(ahc, sc_link)	\
	(SIM_IS_SCSIBUS_B(ahc, sc_link) ? 'B' : 'A')
#define	SIM_SCSI_ID(ahc, sc_link)	\
	(SIM_IS_SCSIBUS_B(ahc, sc_link) ? ahc->our_id_b : ahc->our_id)
#define	SCB_IS_SCSIBUS_B(scb)	\
	(((scb)->hscb->tcl & SELBUSB) != 0)
#define	SCB_TARGET(scb)	\
	(((scb)->hscb->tcl & TID) >> 4)
#define	SCB_CHANNEL(scb) \
	(SCB_IS_SCSIBUS_B(scb) ? 'B' : 'A')
#define	SCB_LUN(scb)	\
	((scb)->hscb->tcl & LID)
#define SCB_TARGET_OFFSET(scb)		\
	(SCB_TARGET(scb) + (SCB_IS_SCSIBUS_B(scb) ? 8 : 0))
#define SCB_TARGET_MASK(scb)		\
	(0x01 << (SCB_TARGET_OFFSET(scb)))
#define TCL_CHANNEL(ahc, tcl)		\
	((((ahc)->features & AHC_TWIN) && ((tcl) & SELBUSB)) ? 'B' : 'A')
#define TCL_SCSI_ID(ahc, tcl)		\
	(TCL_CHANNEL((ahc), (tcl)) == 'B' ? (ahc)->our_id_b : (ahc)->our_id)
#define TCL_TARGET(tcl) (((tcl) & TID) >> TCL_TARGET_SHIFT)
#define TCL_LUN(tcl) ((tcl) & LID)

#define XS_TCL(ahc, xs) \
	((((xs)->sc_link->target << 4) & 0xF0) \
	| (SIM_IS_SCSIBUS_B((ahc), (xs)->sc_link) ? SELBUSB : 0) \
	| ((xs)->sc_link->lun & 0x07))

/*
 * Under normal circumstances, these messages are unnecessary
 * and not terribly cosmetic.
 */
#ifdef DEBUG
#define bootverbose	1
#define STATIC
#define INLINE
#else
#define bootverbose	0
#define STATIC	static
#define INLINE __inline
#endif
d109 23
a131 17
typedef enum {
	ROLE_UNKNOWN,
	ROLE_INITIATOR,
	ROLE_TARGET
} role_t;

struct ahc_devinfo {
	int	  our_scsiid;
	int	  target_offset;
	u_int16_t target_mask;
	u_int8_t  target;
	u_int8_t  lun;
	char	  channel;
	role_t	  role;		/*
				 * Only guaranteed to be correct if not
				 * in the busfree state.
				 */
d134 6
a139 5
typedef enum {
	SEARCH_COMPLETE,
	SEARCH_COUNT,
	SEARCH_REMOVE
} ahc_search_action;
d141 7
a147 2
#ifdef AHC_DEBUG
static int     ahc_debug = AHC_DEBUG;
d149 52
a200 3

#if NPCI > 0
void ahc_pci_intr(struct ahc_softc *ahc);
d203 10
a212 35
STATIC int	ahcinitscbdata(struct ahc_softc *ahc);
STATIC void	ahcfiniscbdata(struct ahc_softc *ahc);

STATIC int	ahc_poll(struct ahc_softc *ahc, int wait);
STATIC void	ahc_shutdown(void *arg);
STATIC int	ahc_execute_scb(void *arg, bus_dma_segment_t *dm_segs,
		    int nsegments);
STATIC int	ahc_setup_data(struct ahc_softc *ahc, struct scsi_xfer *xs,
		    struct scb *scb);
STATIC void	ahc_freeze_devq(struct ahc_softc *ahc,
		    struct scsi_link *sc_link);
STATIC void	ahcallocscbs(struct ahc_softc *ahc);
STATIC void	ahc_fetch_devinfo(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_compile_devinfo(struct ahc_devinfo *devinfo, u_int our_id,
		    u_int target, u_int lun, char channel, role_t role);
STATIC u_int	ahc_abort_wscb(struct ahc_softc *ahc, u_int scbpos, u_int prev);
STATIC void	ahc_done(struct ahc_softc *ahc, struct scb *scbp);
STATIC struct tmode_tstate *
		ahc_alloc_tstate(struct ahc_softc *ahc, u_int scsi_id,
		    char channel);
STATIC void	ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat);
STATIC void	ahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat);
STATIC void	ahc_build_transfer_msg(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_setup_initiator_msgout(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, struct scb *scb);
STATIC void	ahc_setup_target_msgin(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC int	ahc_handle_msg_reject(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_clear_msg_state(struct ahc_softc *ahc);
STATIC void	ahc_handle_message_phase(struct ahc_softc *ahc,
		    struct scsi_link *sc_link);
STATIC int	ahc_sent_msg(struct ahc_softc *ahc, u_int msgtype, int full);
d214 13
a226 13
typedef enum {
	MSGLOOP_IN_PROG,
	MSGLOOP_MSGCOMPLETE,
	MSGLOOP_TERMINATED
} msg_loop_stat;

STATIC int	ahc_parse_msg(struct ahc_softc *ahc, struct scsi_link *sc_link,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_handle_ign_wide_residue(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo);
STATIC void	ahc_handle_devreset(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, int status, char *message,
		    int verbose_level);
d228 1
a228 1
STATIC void	ahc_dumpseq(struct ahc_softc *ahc);
d230 16
a245 10
STATIC void	ahc_loadseq(struct ahc_softc *ahc);
STATIC int	ahc_check_patch(struct ahc_softc *ahc,
		    struct patch **start_patch, int start_instr,
		    int *skip_addr);
STATIC void	ahc_download_instr(struct ahc_softc *ahc, int instrptr,
		    u_int8_t *dconsts);
STATIC int	ahc_match_scb(struct scb *scb, int target, char channel,
		    int lun, u_int tag, role_t role);
#ifdef AHC_DEBUG
STATIC void	ahc_print_scb(struct scb *scb);
d247 1
a247 135
STATIC int	ahc_search_qinfifo(struct ahc_softc *ahc, int target,
		    char channel, int lun, u_int tag, role_t role,
		    u_int32_t status, ahc_search_action action);
STATIC int	ahc_reset_channel(struct ahc_softc *ahc, char channel,
		    int initiate_reset);
STATIC int	ahc_abort_scbs(struct ahc_softc *ahc, int target, char channel,
		    int lun, u_int tag, role_t role, u_int32_t status);
STATIC int	ahc_search_disc_list(struct ahc_softc *ahc, int target,
		    char channel, int lun, u_int tag, int stop_on_first,
		    int remove, int save_state);
STATIC u_int	ahc_rem_scb_from_disc_list(struct ahc_softc *ahc, u_int prev,
		    u_int scbptr);
STATIC void	ahc_add_curscb_to_free_list(struct ahc_softc *ahc);
STATIC void	ahc_clear_intstat(struct ahc_softc *ahc);
STATIC void	ahc_reset_current_bus(struct ahc_softc *ahc);
STATIC struct ahc_syncrate *
		ahc_devlimited_syncrate(struct ahc_softc *ahc, u_int *period);
STATIC struct ahc_syncrate *
		ahc_find_syncrate(struct ahc_softc *ahc, u_int *period,
		    u_int maxsync);
STATIC u_int ahc_find_period(struct ahc_softc *ahc, u_int scsirate,
		u_int maxsync);
STATIC void	ahc_validate_offset(struct ahc_softc *ahc,
					 struct ahc_syncrate *syncrate,
					 u_int *offset, int wide); 
STATIC void	ahc_update_target_msg_request(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo,
		    struct ahc_initiator_tinfo *tinfo, int force, int paused);
STATIC void	ahc_set_syncrate(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, struct ahc_syncrate *syncrate,
		    u_int period, u_int offset, u_int type, int paused,
		    int done);
STATIC void	ahc_set_width(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo, u_int width, u_int type,
		    int paused, int done);
STATIC void	ahc_set_tags(struct ahc_softc *ahc,
		    struct ahc_devinfo *devinfo,int enable);
STATIC int      ahc_istagged_device(struct ahc_softc *ahc,
		    struct scsi_xfer *xs, int nocmdcheck);
STATIC void     ahc_check_tags(struct ahc_softc *ahc, struct scsi_xfer *xs);
STATIC void	ahc_construct_sdtr(struct ahc_softc *ahc, u_int period,
		    u_int offset);
STATIC void	ahc_construct_wdtr(struct ahc_softc *ahc, u_int bus_width);

STATIC void	ahc_calc_residual(struct scb *scb);

STATIC void	ahc_update_pending_syncrates(struct ahc_softc *ahc);

STATIC void	ahc_set_recoveryscb(struct ahc_softc *ahc, struct scb *scb);
STATIC void ahc_timeout(void *);

static __inline int  sequencer_paused(struct ahc_softc *ahc);
static __inline void pause_sequencer(struct ahc_softc *ahc);
static __inline void unpause_sequencer(struct ahc_softc *ahc);
STATIC void restart_sequencer(struct ahc_softc *ahc);
static __inline u_int ahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl,
		    int unbusy);
 
static __inline void	ahc_busy_tcl(struct ahc_softc *ahc, struct scb *scb);
static __inline int	ahc_isbusy_tcl(struct ahc_softc *ahc, struct scb *scb);
static __inline void ahc_freeze_ccb(struct scb* scb);
static __inline void ahcsetccbstatus(struct scsi_xfer *xs, int status);
STATIC void ahc_run_qoutfifo(struct ahc_softc *ahc);

static __inline struct ahc_initiator_tinfo *
	ahc_fetch_transinfo(struct ahc_softc *ahc, char channel, u_int our_id,
	    u_int target, struct tmode_tstate **tstate);
STATIC void ahcfreescb(struct ahc_softc *ahc, struct scb *scb);
static __inline struct scb *ahcgetscb(struct ahc_softc *ahc);
int    ahc_createdmamem(struct ahc_softc *ahc, int size, bus_dmamap_t *mapp,
	    caddr_t *vaddr, bus_addr_t *baddr, bus_dma_segment_t *segs,
	    int *nseg, const char *what);
STATIC void ahc_freedmamem(bus_dma_tag_t tag, int size, bus_dmamap_t map,
	    caddr_t vaddr, bus_dma_segment_t *seg, int nseg);
STATIC void ahcminphys(struct buf *bp);

STATIC INLINE	struct scsi_xfer *ahc_first_xs(struct ahc_softc *);
STATIC INLINE	void   ahc_list_insert_before(struct ahc_softc *ahc,
			    struct scsi_xfer *xs, struct scsi_xfer *next_xs);
STATIC INLINE	void   ahc_list_insert_head(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC INLINE	void   ahc_list_insert_tail(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC INLINE	void   ahc_list_remove(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC INLINE	struct scsi_xfer *ahc_list_next(struct ahc_softc *ahc,
			    struct scsi_xfer *xs);
STATIC int32_t ahc_scsi_cmd(struct scsi_xfer *xs);
static __inline void ahc_swap_hscb(struct hardware_scb *);
static __inline void ahc_swap_sg(struct ahc_dma_seg *);

struct cfdriver ahc_cd = {
	NULL, "ahc", DV_DULL
};

static struct scsi_adapter ahc_switch =
{
	ahc_scsi_cmd,
	ahcminphys,
	0,
	0,
};

/* the below structure is so we have a default dev struct for our link struct */
static struct scsi_device ahc_dev =
{
	NULL, /* Use default error handler */
	NULL, /* have a queue, served by this */
	NULL, /* have no async handler */
	NULL, /* Use default 'done' routine */
};

static __inline void
ahc_swap_hscb(struct hardware_scb *hscb)
{
	hscb->SG_pointer = htole32(hscb->SG_pointer);
	hscb->data = htole32(hscb->data);
	hscb->datalen = htole32(hscb->datalen);
	/*
	 * No need to swap cmdpointer; it's either 0 or set to
	 * cmdstore_busaddr, which is already swapped.
	 */
}

static __inline void
ahc_swap_sg(struct ahc_dma_seg *sg)
{
	sg->addr = htole32(sg->addr);
	sg->len = htole32(sg->len);
}

STATIC void
ahcminphys(bp)
	struct buf *bp;
{
d249 1
a249 5
 * Even though the card can transfer up to 16megs per command
 * we are limited by the number of segments in the dma segment
 * list that we can hold.  The worst case is that all pages are
 * discontinuous physically, hense the "page per segment" limit
 * enforced here.
d251 2
a252 9
	if (bp->b_bcount > ((AHC_NSEG - 1) * PAGE_SIZE)) {
		bp->b_bcount = ((AHC_NSEG - 1) * PAGE_SIZE);
	}
	minphys(bp);
}


static __inline u_int32_t
ahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)
a253 5
	return (ahc->scb_data->hscb_busaddr
		+ (sizeof(struct hardware_scb) * index));
}

#define AHC_BUSRESET_DELAY	25	/* Reset delay in us */
d255 1
a255 6
static __inline int
sequencer_paused(ahc)
	struct ahc_softc *ahc;
{
	return ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);
}
d257 3
a259 5
static __inline void
pause_sequencer(ahc)
	struct ahc_softc *ahc;
{
	ahc_outb(ahc, HCNTRL, ahc->pause);
d262 5
a266 36
	 * Since the sequencer can disable pausing in a critical section, we
	 * must loop until it actually stops.
	 */
	while (sequencer_paused(ahc) == 0)
		;
}

static __inline void
unpause_sequencer(ahc)
	struct ahc_softc *ahc;
{
	if ((ahc_inb(ahc, INTSTAT) & (SCSIINT | SEQINT | BRKADRINT)) == 0)
		ahc_outb(ahc, HCNTRL, ahc->unpause);
}

/*
 * Restart the sequencer program from address zero
 */
STATIC void
restart_sequencer(ahc)
	struct ahc_softc *ahc;
{
	u_int i;

	pause_sequencer(ahc);

	/*
	 * Everytime we restart the sequencer, there
	 * is the possiblitity that we have restarted
	 * within a three instruction window where an
	 * SCB has been marked free but has not made it
	 * onto the free list.  Since SCSI events(bus reset,
	 * unexpected bus free) will always freeze the
	 * sequencer, we cannot close this window.  To
	 * avoid losing an SCB, we reconsitute the free
	 * list every time we restart the sequencer.
d268 1
a268 54
	ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		
		ahc_outb(ahc, SCBPTR, i);
		if (ahc_inb(ahc, SCB_TAG) == SCB_LIST_NULL)
			ahc_add_curscb_to_free_list(ahc);
	}
	ahc_outb(ahc, SEQCTL, FASTMODE|SEQRESET);
	unpause_sequencer(ahc);
}

static __inline u_int
ahc_index_busy_tcl(ahc, tcl, unbusy)
	struct ahc_softc *ahc;
	u_int tcl;
	int unbusy;
{
	u_int scbid;

	scbid = ahc->untagged_scbs[tcl];
	if (unbusy) {
		ahc->untagged_scbs[tcl] = SCB_LIST_NULL;
		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
		    UNTAGGEDSCB_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
	}

	return (scbid);
}

static __inline void
ahc_busy_tcl(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
	ahc->untagged_scbs[scb->hscb->tcl] = scb->hscb->tag;
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    UNTAGGEDSCB_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
}

static __inline int
ahc_isbusy_tcl(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
{
	return ahc->untagged_scbs[scb->hscb->tcl] != SCB_LIST_NULL;
}

static __inline void
ahc_freeze_ccb(scb)
	struct scb *scb;
{
	struct scsi_xfer *xs = scb->xs;
	struct ahc_softc *ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
	int target;
d270 8
a277 4
	target = xs->sc_link->target;
	if (!(scb->flags & SCB_FREEZE_QUEUE)) {
		ahc->devqueue_blocked[target]++;
		scb->flags |= SCB_FREEZE_QUEUE;
a278 18
}

static __inline void
ahcsetccbstatus(xs, status)
	struct scsi_xfer *xs;
	int status;
{
	xs->error = status;
}

static __inline struct ahc_initiator_tinfo *
ahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)
	struct ahc_softc *ahc;
	char channel;
	u_int our_id;
	u_int remote_id;
	struct tmode_tstate **tstate;
{
d280 3
a282 4
	 * Transfer data structures are stored from the perspective
	 * of the target role.  Since the parameters for a connection
	 * in the initiator role to a given target are the same as
	 * when the roles are reversed, we pretend we are the target.
d284 10
a293 4
	if (channel == 'B')
		our_id += 8;
	*tstate = ahc->enabled_targets[our_id];
	return (&(*tstate)->transinfo[remote_id]);
d296 3
a298 3
STATIC void
ahc_run_qoutfifo(ahc)
	struct ahc_softc *ahc;
d303 2
a304 2
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    0, 256, BUS_DMASYNC_POSTREAD);
a305 1
	while (ahc->qoutfifo[ahc->qoutfifonext] != SCB_LIST_NULL) {
d307 18
a324 1
		ahc->qoutfifo[ahc->qoutfifonext++] = SCB_LIST_NULL;
d326 2
a327 3
		scb = &ahc->scb_data->scbarray[scb_index];
		if (scb_index >= ahc->scb_data->numscbs
		  || (scb->flags & SCB_ACTIVE) == 0) {
d339 1
a339 4
		if (scb->hscb->residual_SG_count != 0)
			ahc_calc_residual(scb);
		else
			scb->xs->resid = 0;
d344 8
d353 3
a355 7
/*
 * An scb (and hence an scb entry on the board) is put onto the
 * free list.
 */
STATIC void
ahcfreescb(ahc, scb)
	struct ahc_softc *ahc;
a356 3
{       
	struct hardware_scb *hscb;
	int opri;
d358 2
a359 8
	hscb = scb->hscb;

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWSCBS)
		printf("%s: free SCB tag %x\n", ahc_name(ahc), hscb->tag);
#endif

	opri = splbio();
d361 4
a364 4
	if ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0 ||
	    (scb->flags & SCB_RECOVERY_SCB) != 0) {
		ahc->flags &= ~AHC_RESOURCE_SHORTAGE;
		ahc->queue_blocked = 0;
a365 10

	/* Clean up for the next user */
	scb->flags = SCB_FREE;
	hscb->control = 0;
	hscb->status = 0;
	timeout_del(&scb->xs->stimeout);

	SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, scb, links);

	splx(opri);
d368 3
a370 9
/*
 * Get a free scb, either one already assigned to a hardware slot
 * on the adapter or one that will require an SCB to be paged out before
 * use. If there are none, see if we can allocate a new SCB.  Otherwise
 * either return an error or sleep.
 */
static __inline struct scb *
ahcgetscb(ahc)
	struct ahc_softc *ahc;
d372 6
a377 12
	struct scb *scbp;
	int opri;

	opri = splbio();
	if ((scbp = SLIST_FIRST(&ahc->scb_data->free_scbs))) {
		SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links);
	} else {
		ahcallocscbs(ahc);
		scbp = SLIST_FIRST(&ahc->scb_data->free_scbs);
		if (scbp != NULL)
			SLIST_REMOVE_HEAD(&ahc->scb_data->free_scbs, links);
	}
d379 14
a392 1
	splx(opri);
d394 2
a395 1
	return (scbp);
d398 5
a402 17
int
ahc_createdmamem(ahc, size, mapp, vaddr, baddr, seg, nseg, what)
	struct ahc_softc *ahc;
	int size;
	bus_dmamap_t *mapp;
	caddr_t *vaddr;
	bus_addr_t *baddr;
	bus_dma_segment_t *seg;
	int *nseg;
	const char *what;
{
	int error, level = 0;
	int dma_flags = BUS_DMA_NOWAIT;
	bus_dma_tag_t tag = ahc->sc_dmat;
	const char *myname = ahc_name(ahc);
	if ((ahc->chip & AHC_VL) !=0)
		dma_flags |= ISABUS_DMA_32BIT;
d404 1
a404 47
	if ((error = bus_dmamem_alloc(tag, size, NBPG, 0,
			seg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to allocate DMA mem for %s, error = %d\n",
			myname, what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,
			BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: failed to map DMA mem for %s, error = %d\n",
			myname, what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamap_create(tag, size, 1, size, 0,
			dma_flags, mapp)) != 0) {
		printf("%s: failed to create DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }
	level++;

	if ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,
			BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to load DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }

	*baddr = (*mapp)->dm_segs[0].ds_addr;
	return 0;
out:
	switch (level) {
	case 3:
		bus_dmamap_destroy(tag, *mapp);
		/* FALLTHROUGH */
	case 2:
		bus_dmamem_unmap(tag, *vaddr, size);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(tag, seg, *nseg);
		break;
	default:
		break;
	}
d406 12
a417 2
	return error;
}
d419 6
a424 9
STATIC void
ahc_freedmamem(tag, size, map, vaddr, seg, nseg)
	bus_dma_tag_t tag;
	int size;
	bus_dmamap_t map;
	caddr_t vaddr;
	bus_dma_segment_t *seg;
	int nseg;
{
d426 20
a445 5
	bus_dmamap_unload(tag, map);
	bus_dmamap_destroy(tag, map);
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
}
d447 1
a447 6
#ifdef  AHC_DEBUG
STATIC void
ahc_print_scb(scb)
	struct scb *scb;
{
	struct hardware_scb *hscb = scb->hscb;
d449 1176
a1624 20
	printf("scb:%p tag %x control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n",
		scb,
		hscb->tag,
		hscb->control,
		hscb->tcl,
		hscb->cmdlen,
		(unsigned long)le32toh(hscb->cmdpointer));
	printf("        datlen:%u data:0x%lx segs:0x%x segp:0x%lx\n",
		le32toh(hscb->datalen),
		(unsigned long)(le32toh(hscb->data)),
		hscb->SG_count,
		(unsigned long)(le32toh(hscb->SG_pointer)));
	printf("	sg_addr:%lx sg_len:%lu\n",
		(unsigned long)(le32toh(scb->sg_list[0].addr)),
		(unsigned long)(le32toh(scb->sg_list[0].len)));
	printf("	cdb:%x %x %x %x %x %x %x %x %x %x %x %x\n",
		hscb->cmdstore[0], hscb->cmdstore[1], hscb->cmdstore[2],
		hscb->cmdstore[3], hscb->cmdstore[4], hscb->cmdstore[5],
		hscb->cmdstore[6], hscb->cmdstore[7], hscb->cmdstore[8],
		hscb->cmdstore[9], hscb->cmdstore[10], hscb->cmdstore[11]);
a1625 1
#endif
d1627 16
a1642 14
static struct {
        u_int8_t errno;
	char *errmesg;
} hard_error[] = {
	{ ILLHADDR,	"Illegal Host Access" },
	{ ILLSADDR,	"Illegal Sequencer Address referrenced" },
	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
	{ SQPARERR,	"Sequencer Parity Error" },
	{ DPARERR,	"Data-path Parity Error" },
	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
	{ PCIERRSTAT,	"PCI Error detected" },
	{ CIOPARERR,	"CIOBUS Parity Error" },
};
static const int num_errors = sizeof(hard_error)/sizeof(hard_error[0]);
d1644 12
a1655 15
static struct {
        u_int8_t phase;
        u_int8_t mesg_out; /* Message response to parity errors */
	char *phasemsg;
} phase_table[] = {
	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
	{ 0,		MSG_NOOP,		"in unknown phase"	}
};
static const int num_phases = (sizeof(phase_table)/sizeof(phase_table[0])) - 1;
d1658 2
a1659 3
 * Valid SCSIRATE values.  (p. 3-17)
 * Provides a mapping of tranfer periods in ns to the proper value to
 * stick in the scsiscfr reg to use that transfer rate.
d1661 27
a1687 22
#define AHC_SYNCRATE_DT		0
#define AHC_SYNCRATE_ULTRA2	1
#define AHC_SYNCRATE_ULTRA	3
#define AHC_SYNCRATE_FAST	6
static struct ahc_syncrate ahc_syncrates[] = {
      /* ultra2    fast/ultra  period     rate */
	{ 0x42,      0x000,      9,      "80.0" },
	{ 0x03,      0x000,     10,      "40.0" },
	{ 0x04,      0x000,     11,      "33.0" },
	{ 0x05,      0x100,     12,      "20.0" },
	{ 0x06,      0x110,     15,      "16.0" },
	{ 0x07,      0x120,     18,      "13.4" },
	{ 0x08,      0x000,     25,      "10.0" },
	{ 0x19,      0x010,     31,      "8.0"  },
	{ 0x1a,      0x020,     37,      "6.67" },
	{ 0x1b,      0x030,     43,      "5.7"  },
	{ 0x1c,      0x040,     50,      "5.0"  },
	{ 0x00,      0x050,     56,      "4.4"  },
	{ 0x00,      0x060,     62,      "4.0"  },
	{ 0x00,      0x070,     68,      "3.6"  },
	{ 0x00,      0x000,      0,      NULL   }
};
d1690 2
a1691 3
 * Allocate a controller structure for a new device and initialize it.
 * ahc_reset should be called before now since we assume that the card
 * is paused.
d1694 2
a1695 8
ahc_construct(ahc, iot, ioh, chip, flags, features, channel)
	struct  ahc_softc *ahc;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	ahc_chip chip;
	ahc_flag flags;
	ahc_feature features;
	u_char channel;
d1697 45
a1741 12
	/*
	 * find unit and check we have that many defined
	 */
	LIST_INIT(&ahc->pending_scbs);
	ahc->sc_iot = iot;
	ahc->sc_ioh = ioh;
	ahc->chip = chip;
	ahc->flags = flags;
	ahc->features = features;
	ahc->channel = channel;
	ahc->scb_data = NULL;
	ahc->pci_intr_func = NULL;
d1743 1
a1743 5
	ahc->unpause = (ahc_inb(ahc, HCNTRL) & IRQMS) | INTEN;
	/* The IRQMS bit is only valid on VL and EISA chips */
	if ((ahc->chip & AHC_PCI) != 0)
		ahc->unpause &= ~IRQMS;
	ahc->pause = ahc->unpause | PAUSE;
d1746 8
d1755 3
a1757 2
ahc_free(ahc)
	struct ahc_softc *ahc;
d1759 112
a1870 11
	ahcfiniscbdata(ahc);
	if (ahc->init_level != 0)
		ahc_freedmamem(ahc->sc_dmat, ahc->shared_data_size,
		    ahc->shared_data_dmamap, ahc->qoutfifo,
		    &ahc->shared_data_seg, ahc->shared_data_nseg);

	if (ahc->scb_data != NULL)
		free(ahc->scb_data, M_DEVBUF);
	if (ahc->pci_data != NULL)
		free(ahc->pci_data, M_DEVBUF);
	return;
d1873 11
a1883 3
STATIC int
ahcinitscbdata(ahc)
	struct ahc_softc *ahc;
d1885 16
a1900 6
	struct scb_data *scb_data;
	int i;
	
	scb_data = ahc->scb_data;
	SLIST_INIT(&scb_data->free_scbs);
	SLIST_INIT(&scb_data->sg_maps);
d1902 3
a1904 7
	/* Allocate SCB resources */
	scb_data->scbarray =
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,
				 M_DEVBUF, M_NOWAIT);
	if (scb_data->scbarray == NULL)
		return (ENOMEM);
	bzero(scb_data->scbarray, sizeof(struct scb) * AHC_SCB_MAX);
d1906 5
a1910 1
	/* Determine the number of hardware SCBs and initialize them */
d1912 1
a1912 5
	scb_data->maxhscbs = ahc_probe_scbs(ahc);
	/* SCB 0 heads the free list */
	ahc_outb(ahc, FREE_SCBH, 0);
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		ahc_outb(ahc, SCBPTR, i);
d1914 2
a1915 2
		/* Clear the control byte. */
		ahc_outb(ahc, SCB_CONTROL, 0);
d1917 1
a1917 2
		/* Set the next pointer */
		ahc_outb(ahc, SCB_NEXT, i+1);
d1919 7
a1925 2
		/* Make the tag number invalid */
		ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
d1928 5
a1932 3
	/* Make sure that the last SCB terminates the free list */
	ahc_outb(ahc, SCBPTR, i-1);
	ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);
d1934 11
a1944 3
	/* Ensure we clear the 0 SCB's control byte. */
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outb(ahc, SCB_CONTROL, 0);
d1946 13
a1958 4
	scb_data->maxhscbs = i;

	if (ahc->scb_data->maxhscbs == 0)
		panic("%s: No SCB space found", ahc_name(ahc));
d1961 2
a1962 7
	 * Create our DMA tags.  These tags define the kinds of device
	 * accessable memory allocations and memory mappings we will
	 * need to perform during normal operation.
	 *
	 * Unless we need to further restrict the allocation, we rely
	 * on the restrictions of the parent dmat, hence the common
	 * use of MAXADDR and MAXSIZE.
d1964 6
d1971 19
a1989 6
	if (ahc_createdmamem(ahc,
	    AHC_SCB_MAX * sizeof(struct hardware_scb), 
	    &scb_data->hscb_dmamap, (caddr_t *)&scb_data->hscbs, 
	    &scb_data->hscb_busaddr, &scb_data->hscb_seg,
	    &scb_data->hscb_nseg, "hardware SCB structures") < 0)
		goto error_exit;
d1991 2
a1992 1
	scb_data->init_level++;
d1994 6
a1999 6
	if (ahc_createdmamem(ahc,
	    AHC_SCB_MAX * sizeof(struct scsi_sense_data),
	    &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,
	    &scb_data->sense_busaddr, &scb_data->sense_seg,
	    &scb_data->sense_nseg, "sense buffers") < 0)
		goto error_exit;
d2001 6
a2006 1
	scb_data->init_level++;
d2008 5
a2012 3
	/* Perform initial CCB allocation */
	bzero(scb_data->hscbs, AHC_SCB_MAX * sizeof(struct hardware_scb));
	ahcallocscbs(ahc);
d2014 7
a2020 5
	if (scb_data->numscbs == 0) {
		printf("%s: ahc_init_scb_data - "
		       "Unable to allocate initial scbs\n",
		       ahc_name(ahc));
		goto error_exit;
d2022 1
d2024 11
a2034 1
	scb_data->init_level++;
d2036 4
a2039 4
	/*
	 * Note that we were successfull
	 */
	return 0; 
d2041 9
a2049 1
error_exit:
d2051 7
a2057 1
	return ENOMEM;
d2060 2
a2061 3
STATIC void
ahcfiniscbdata(ahc)
	struct ahc_softc *ahc;
d2063 2
a2064 1
	struct scb_data *scb_data;
d2066 8
a2073 15
	scb_data = ahc->scb_data;

	switch (scb_data->init_level) {
	default:
	case 3:
	{
		struct sg_map_node *sg_map;

		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
			ahc_freedmamem(ahc->sc_dmat, PAGE_SIZE,
			    sg_map->sg_dmamap, (caddr_t)sg_map->sg_vaddr,
			    &sg_map->sg_dmasegs, sg_map->sg_nseg);
			free(sg_map, M_DEVBUF);
		}
d2075 1
a2075 16
	/*FALLTHROUGH*/
	case 2:
		ahc_freedmamem(ahc->sc_dmat,
		    AHC_SCB_MAX * sizeof(struct scsi_sense_data),
		    scb_data->sense_dmamap, (caddr_t)scb_data->sense,
		    &scb_data->sense_seg, scb_data->sense_nseg);
	/*FALLTHROUGH*/
	case 1:
		ahc_freedmamem(ahc->sc_dmat,
		    AHC_SCB_MAX * sizeof(struct hardware_scb), 
		    scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,
		    &scb_data->hscb_seg, scb_data->hscb_nseg);
	/*FALLTHROUGH*/
	}
	if (scb_data->scbarray != NULL)
		free(scb_data->scbarray, M_DEVBUF);
d2079 2
a2080 4
ahc_xxx_reset(devname, iot, ioh)
	char *devname;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d2082 10
a2091 2
	u_char hcntrl;
	int wait;
d2093 6
a2098 5
#ifdef AHC_DUMP_SEQ
	ahc_dumpseq(ahc);
#endif
	/* Retain the IRQ type accross the chip reset */
	hcntrl = (bus_space_read_1(iot, ioh, HCNTRL) & IRQMS) | INTEN;
d2100 6
a2105 12
	bus_space_write_1(iot, ioh, HCNTRL, CHIPRST | PAUSE);
	/*
	 * Ensure that the reset has finished
	 */
	wait = 1000;
	while (--wait && !(bus_space_read_1(iot, ioh, HCNTRL) & CHIPRSTACK))
		DELAY(1000);
	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
				 "Trying to initialize anyway.\n", devname);
	}
	bus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);
d2108 4
a2111 3
int
ahc_reset(ahc)
	struct ahc_softc *ahc;
d2113 1
a2113 15
	u_int	sblkctl;
	int	wait;
	
#ifdef AHC_DUMP_SEQ
	if (ahc->init_level == 0)
		ahc_dumpseq(ahc);
#endif
	ahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);
	/*
	 * Ensure that the reset has finished
	 */
	wait = 1000;
	do {
		DELAY(1000);
	} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));
d2115 4
a2118 28
	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", ahc_name(ahc));
	}
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/* Determine channel configuration */
	sblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);
	/* No Twin Channel PCI cards */
	if ((ahc->chip & AHC_PCI) != 0)
		sblkctl &= ~SELBUSB;
	switch (sblkctl) {
	case 0:
		/* Single Narrow Channel */
		break;
	case 2:
		/* Wide Channel */
		ahc->features |= AHC_WIDE;
		break;
	case 8:
		/* Twin Channel */
		ahc->features |= AHC_TWIN;
		break;
	default:
		printf(" Unsupported adapter type.  Ignoring\n");
		return(-1);
	}
	return (0);
d2122 4
a2125 3
 * Called when we have an active connection to a target on the bus,
 * this function finds the nearest syncrate to the input period limited
 * by the capabilities of the bus connectivity of the target.
d2127 3
a2129 4
STATIC struct ahc_syncrate *
ahc_devlimited_syncrate(ahc, period)
	struct ahc_softc *ahc;
	u_int *period;
d2131 17
a2147 1
	u_int	maxsync;
d2149 5
a2153 6
	if ((ahc->features & AHC_ULTRA2) != 0) {
		if ((ahc_inb(ahc, SBLKCTL) & ENAB40) != 0
		 && (ahc_inb(ahc, SSTAT2) & EXP_ACTIVE) == 0) {
			maxsync = AHC_SYNCRATE_ULTRA2;
		} else {
			maxsync = AHC_SYNCRATE_ULTRA;
d2155 34
a2188 2
	} else if ((ahc->features & AHC_ULTRA) != 0) {
		maxsync = AHC_SYNCRATE_ULTRA;
d2190 17
a2206 3
		maxsync = AHC_SYNCRATE_FAST;
	}
	return (ahc_find_syncrate(ahc, period, maxsync));
d2210 2
a2211 3
 * Look up the valid period to SCSIRATE conversion in our table.
 * Return the period and offset that should be sent to the target
 * if this was the beginning of an SDTR.
d2213 2
a2214 5
STATIC struct ahc_syncrate *
ahc_find_syncrate(ahc, period, maxsync)
	struct ahc_softc *ahc;
	u_int *period;
	u_int maxsync;
d2216 15
a2230 1
	struct ahc_syncrate *syncrate;
d2232 18
a2249 4
	syncrate = &ahc_syncrates[maxsync];
	while ((syncrate->rate != NULL)
	    && ((ahc->features & AHC_ULTRA2) == 0
	     || (syncrate->sxfr_u2 != 0))) {
d2251 4
a2254 17
		if (*period <= syncrate->period) {
			/*
			 * When responding to a target that requests
			 * sync, the requested rate may fall between
			 * two rates that we can output, but still be
			 * a rate that we can receive.  Because of this,
			 * we want to respond to the target with
			 * the same rate that it sent to us even
			 * if the period we use to send data to it
			 * is lower.  Only lower the response period
			 * if we must.
			 */
			if (syncrate == &ahc_syncrates[maxsync])
				*period = syncrate->period;
			break;
		}
		syncrate++;
d2257 3
a2259 7
	if ((*period == 0)
	 || (syncrate->rate == NULL)
	 || ((ahc->features & AHC_ULTRA2) != 0
	  && (syncrate->sxfr_u2 == 0))) {
		/* Use asynchronous transfers. */
		*period = 0;
		syncrate = NULL;
a2260 10
	return (syncrate);
}

STATIC u_int
ahc_find_period(ahc, scsirate, maxsync)
	struct ahc_softc *ahc;
	u_int scsirate;
	u_int maxsync;
{
	struct ahc_syncrate *syncrate;
d2262 4
a2265 4
	if ((ahc->features & AHC_ULTRA2) != 0)
		scsirate &= SXFR_ULTRA2;
	else
		scsirate &= SXFR;
d2267 9
a2275 2
	syncrate = &ahc_syncrates[maxsync];
	while (syncrate->rate != NULL) {
d2277 10
a2286 7
		if ((ahc->features & AHC_ULTRA2) != 0) {
			if (syncrate->sxfr_u2 == 0)
				break;
			else if (scsirate == (syncrate->sxfr_u2 & SXFR_ULTRA2))
				return (syncrate->period);
		} else if (scsirate == (syncrate->sxfr & SXFR)) {
				return (syncrate->period);
d2288 2
a2289 1
		syncrate++;
a2290 1
	return (0); /* async */
d2293 7
a2299 6
STATIC void
ahc_validate_offset(ahc, syncrate, offset, wide)
	struct ahc_softc *ahc;
	struct ahc_syncrate *syncrate;
	u_int *offset;
	int wide;
d2301 12
a2312 1
	u_int maxoffset;
d2314 17
a2330 10
	/* Limit offset to what we can do */
	if (syncrate == NULL) {
		maxoffset = 0;
	} else if ((ahc->features & AHC_ULTRA2) != 0) {
		maxoffset = MAX_OFFSET_ULTRA2;
	} else {
		if (wide)
			maxoffset = MAX_OFFSET_16BIT;
		else
			maxoffset = MAX_OFFSET_8BIT;
a2331 1
	*offset = MIN(*offset, maxoffset);
d2334 8
a2341 7
STATIC void
ahc_update_target_msg_request(ahc, devinfo, tinfo, force, paused)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct ahc_initiator_tinfo *tinfo;
	int force;
	int paused;
d2343 14
a2356 36
	u_int targ_msg_req_orig;

	targ_msg_req_orig = ahc->targ_msg_req;
	if (tinfo->current.period != tinfo->goal.period
	    || tinfo->current.width != tinfo->goal.width
	    || tinfo->current.offset != tinfo->goal.offset
	    || (force && (tinfo->goal.period != 0
	    || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT)))
		ahc->targ_msg_req |= devinfo->target_mask;
	else
		ahc->targ_msg_req &= ~devinfo->target_mask;

	if (ahc->targ_msg_req != targ_msg_req_orig) {
		/* Update the message request bit for this target */
		if ((ahc->features & AHC_HS_MAILBOX) != 0) {
			if (paused) {
				ahc_outb(ahc, TARGET_MSG_REQUEST,
					 ahc->targ_msg_req & 0xFF);
				ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
					 (ahc->targ_msg_req >> 8) & 0xFF);
			} else {
				ahc_outb(ahc, HS_MAILBOX,
					 0x01 << HOST_MAILBOX_SHIFT);
			}
		} else {
			if (!paused)
				pause_sequencer(ahc);

			ahc_outb(ahc, TARGET_MSG_REQUEST,
				 ahc->targ_msg_req & 0xFF);
			ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
				 (ahc->targ_msg_req >> 8) & 0xFF);

			if (!paused)
				unpause_sequencer(ahc);
		}
d2360 5
a2364 10
STATIC void
ahc_set_syncrate(ahc, devinfo, syncrate, period, offset, type, paused, done)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct ahc_syncrate *syncrate;
	u_int period;
	u_int offset;
	u_int type;
	int paused;
	int done;
d2366 12
a2377 5
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	u_int	old_period;
	u_int	old_offset;
	int	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
d2379 9
a2387 4
	if (syncrate == NULL) {
		period = 0;
		offset = 0;
	}
d2389 3
a2391 5
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
	old_period = tinfo->current.period;
	old_offset = tinfo->current.offset;
d2393 7
a2399 3
	if ((type & AHC_TRANS_CUR) != 0
	 && (old_period != period || old_offset != offset)) {
		u_int	scsirate;
d2401 2
a2402 2
		scsirate = tinfo->scsirate;
		if ((ahc->features & AHC_ULTRA2) != 0) {
d2404 18
a2421 5
			/* XXX */
			/* Force single edge until DT is fully implemented */
			scsirate &= ~(SXFR_ULTRA2|SINGLE_EDGE|ENABLE_CRC);
			if (syncrate != NULL)
				scsirate |= syncrate->sxfr_u2|SINGLE_EDGE;
d2423 6
a2428 3
			if (active)
				ahc_outb(ahc, SCSIOFFSET, offset);
		} else {
d2430 2
a2431 1
			scsirate &= ~(SXFR|SOFS);
d2433 3
a2435 2
			 * Ensure Ultra mode is set properly for
			 * this target.
d2437 2
a2438 18
			tstate->ultraenb &= ~devinfo->target_mask;
			if (syncrate != NULL) {
				if (syncrate->sxfr & ULTRA_SXFR) {
					tstate->ultraenb |=
						devinfo->target_mask;
				}
				scsirate |= syncrate->sxfr & SXFR;
				scsirate |= offset & SOFS;
			}
			if (active) {
				u_int sxfrctl0;

				sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
				sxfrctl0 &= ~FAST20;
				if (tstate->ultraenb & devinfo->target_mask)
					sxfrctl0 |= FAST20;
				ahc_outb(ahc, SXFRCTL0, sxfrctl0);
			}
a2439 2
		if (active)
			ahc_outb(ahc, SCSIRATE, scsirate);
d2441 4
a2444 21
		tinfo->scsirate = scsirate;
		tinfo->current.period = period;
		tinfo->current.offset = offset;

		/* Update the syncrates in any pending scbs */
		ahc_update_pending_syncrates(ahc);
	}

	/*
	 * Print messages if we're verbose and at the end of a negotiation
	 * cycle.
	 */
	if (done) {
		if (offset != 0) {
			printf("%s: target %d synchronous at %sMHz, "
			       "offset = 0x%x\n", ahc_name(ahc),
			       devinfo->target, syncrate->rate, offset);
		} else {
			printf("%s: target %d using "
			       "asynchronous transfers\n",
			       ahc_name(ahc), devinfo->target);
a2445 1
	}
d2447 7
a2453 3
	if ((type & AHC_TRANS_GOAL) != 0) {
		tinfo->goal.period = period;
		tinfo->goal.offset = offset;
d2455 4
d2460 1
a2460 29
	if ((type & AHC_TRANS_USER) != 0) {
		tinfo->user.period = period;
		tinfo->user.offset = offset;
	}

	ahc_update_target_msg_request(ahc, devinfo, tinfo,
				      /*force*/FALSE,
				      paused);
}

STATIC void
ahc_set_width(ahc, devinfo, width, type, paused, done)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	u_int width;
	u_int type;
	int paused;
	int done;
{
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
	u_int  oldwidth;
	int    active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target,
				    &tstate);
	oldwidth = tinfo->current.width;
d2462 12
a2473 2
	if ((type & AHC_TRANS_CUR) != 0 && oldwidth != width) {
		u_int	scsirate;
d2475 2
a2476 4
		scsirate =  tinfo->scsirate;
		scsirate &= ~WIDEXFER;
		if (width == MSG_EXT_WDTR_BUS_16_BIT)
			scsirate |= WIDEXFER;
d2478 1
a2478 1
		tinfo->scsirate = scsirate;
d2480 6
a2485 2
		if (active)
			ahc_outb(ahc, SCSIRATE, scsirate);
d2487 9
a2495 2
		tinfo->current.width = width;
	}
d2497 4
a2500 4
	if (done) {
		printf("%s: target %d using %dbit transfers\n",
		       ahc_name(ahc), devinfo->target,
		       8 * (0x01 << width));
d2502 4
d2507 2
a2508 4
	if ((type & AHC_TRANS_GOAL) != 0)
		tinfo->goal.width = width;
	if ((type & AHC_TRANS_USER) != 0)
		tinfo->user.width = width;
d2510 11
a2520 3
	ahc_update_target_msg_request(ahc, devinfo, tinfo,
				      /*force*/FALSE, paused);
}
d2522 1
a2522 8
STATIC void
ahc_set_tags(ahc, devinfo, enable)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	int enable;
{
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
d2524 15
a2538 11
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target,
				    &tstate);
	if (enable)
		tstate->tagenable |= devinfo->target_mask;
	else {
		tstate->tagenable &= ~devinfo->target_mask;
		tstate->tagdisable |= devinfo->target_mask;
	}
}
d2540 7
a2546 11
/*
 * Attach all the sub-devices we can find
 */
int
ahc_attach(ahc)
	struct ahc_softc *ahc;
{
	/*
	 * Initialize the software queue.
	 */
	LIST_INIT(&ahc->sc_xxxq);
d2548 6
a2553 22
#ifdef AHC_BROKEN_CACHE
	if (cpu_class == CPUCLASS_386)	/* doesn't have "wbinvd" instruction */
		ahc_broken_cache = 0;
#endif
	/*
	 * fill in the prototype scsi_links.
	 */
	ahc->sc_link.adapter_target = ahc->our_id;
	if (ahc->features & AHC_WIDE)
		ahc->sc_link.adapter_buswidth = 16;
	ahc->sc_link.adapter_softc = ahc;
	ahc->sc_link.adapter = &ahc_switch;
	ahc->sc_link.openings = 2;
	ahc->sc_link.device = &ahc_dev;
	ahc->sc_link.flags = SCSIDEBUG_LEVEL;
	
	if (ahc->features & AHC_TWIN) {
		/* Configure the second scsi bus */
		ahc->sc_link_b = ahc->sc_link;
		ahc->sc_link_b.adapter_target = ahc->our_id_b;
		if (ahc->features & AHC_WIDE)
			ahc->sc_link.adapter_buswidth = 16;
d2555 4
d2560 5
a2564 6
	/*
	 * ask the adapter what subunits are present
	 */
	if ((ahc->flags & AHC_CHANNEL_B_PRIMARY) == 0) {
		/* make IS_SCSIBUS_B() == false, while probing channel A */
		ahc->sc_link_b.scsibus = 0xff;
a2565 4
		config_found((void *)ahc, &ahc->sc_link, scsiprint);
		if (ahc->features & AHC_TWIN)
			config_found((void *)ahc, &ahc->sc_link_b, scsiprint);
	} else {
d2567 3
a2569 3
		 * if implementation of IS_SCSIBUS_B() is changed to use
		 * ahc->sc_link.scsibus, then "ahc->sc_link.scsibus = 0xff;"
		 * is needed, here.
d2571 14
d2586 6
a2591 6
		/* assert(ahc->features & AHC_TWIN); */
		config_found((void *)ahc, &ahc->sc_link_b, scsiprint);
		config_found((void *)ahc, &ahc->sc_link, scsiprint);
	}
	return 1;
}
d2593 13
a2605 8
STATIC void
ahc_fetch_devinfo(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	u_int	saved_tcl;
	role_t	role;
	int	our_id;
d2607 7
a2613 4
	if (ahc_inb(ahc, SSTAT0) & TARGET)
		role = ROLE_TARGET;
	else
		role = ROLE_INITIATOR;
d2615 5
a2619 9
	if (role == ROLE_TARGET
	 && (ahc->features & AHC_MULTI_TID) != 0
	 && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
		/* We were selected, so pull our id from TARGIDIN */
		our_id = ahc_inb(ahc, TARGIDIN) & OID;
	} else if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;
d2621 5
a2625 24
	saved_tcl = ahc_inb(ahc, SAVED_TCL);
	ahc_compile_devinfo(devinfo, our_id, TCL_TARGET(saved_tcl),
			    TCL_LUN(saved_tcl), TCL_CHANNEL(ahc, saved_tcl),
			    role);
}

STATIC void
ahc_compile_devinfo(devinfo, our_id, target, lun, channel, role)
	struct ahc_devinfo *devinfo;
	u_int our_id;
	u_int target;
	u_int lun;
	char channel;
	role_t role;
{
	devinfo->our_scsiid = our_id;
	devinfo->target = target;
	devinfo->lun = lun;
	devinfo->target_offset = target;
	devinfo->channel = channel;
	devinfo->role = role;
	if (channel == 'B')
		devinfo->target_offset += 8;
	devinfo->target_mask = (0x01 << devinfo->target_offset);
d2629 4
a2632 1
 * Catch an interrupt from the adapter
d2634 2
a2635 2
int
ahc_intr(void *arg)
d2637 2
a2638 2
	struct	ahc_softc *ahc;
	u_int	intstat;
d2640 2
a2641 1
	ahc = (struct ahc_softc *)arg; 
d2643 3
a2645 1
	intstat = ahc_inb(ahc, INTSTAT);
d2647 3
a2649 22
	/*
	 * Any interrupts to process?
	 */
	if ((intstat & INT_PEND) == 0) {
		if (ahc->pci_intr_func && ahc->pci_intr_func(ahc)) {
#ifdef AHC_DEBUG
			printf("%s: bus intr: CCHADDR %x HADDR %x SEQADDR %x\n",
			    ahc_name(ahc),
			    ahc_inb(ahc, CCHADDR) |
			    (ahc_inb(ahc, CCHADDR+1) << 8)
			    | (ahc_inb(ahc, CCHADDR+2) << 16)
			    | (ahc_inb(ahc, CCHADDR+3) << 24),
			    ahc_inb(ahc, HADDR) | (ahc_inb(ahc, HADDR+1) << 8)
			    | (ahc_inb(ahc, HADDR+2) << 16)
			    | (ahc_inb(ahc, HADDR+3) << 24),
			    ahc_inb(ahc, SEQADDR0) |
			    (ahc_inb(ahc, SEQADDR1) << 8));
#endif
			return 1;
		}
		return 0;
	}
d2651 9
a2659 10
	if (intstat & CMDCMPLT) {
		ahc_outb(ahc, CLRINT, CLRCMDINT);
		ahc_run_qoutfifo(ahc);
	}
	if (intstat & BRKADRINT) {
		/*
		 * We upset the sequencer :-(
		 * Lookup the error message
		 */
		int i, error, num_errors;
d2661 10
a2670 44
		error = ahc_inb(ahc, ERROR);
		num_errors =  sizeof(hard_error)/sizeof(hard_error[0]);
		for (i = 0; error != 1 && i < num_errors; i++)
			error >>= 1;
		panic("%s: brkadrint, %s at seqaddr = 0x%x\n",
		      ahc_name(ahc), hard_error[i].errmesg,
		      ahc_inb(ahc, SEQADDR0) |
		      (ahc_inb(ahc, SEQADDR1) << 8));

		/* Tell everyone that this HBA is no longer availible */
		ahc_abort_scbs(ahc, ALL_TARGETS, ALL_CHANNELS,
			       ALL_LUNS, SCB_LIST_NULL, ROLE_UNKNOWN,
			       XS_DRIVER_STUFFUP);
	}
	if (intstat & SEQINT)
		ahc_handle_seqint(ahc, intstat);

	if (intstat & SCSIINT)
		ahc_handle_scsiint(ahc, intstat);
	return(1);
}

STATIC struct tmode_tstate *
ahc_alloc_tstate(ahc, scsi_id, channel)
	struct ahc_softc *ahc;
	u_int scsi_id;
	char channel;
{
	struct tmode_tstate *master_tstate;
	struct tmode_tstate *tstate;
	int i, s;

	master_tstate = ahc->enabled_targets[ahc->our_id];
	if (channel == 'B') {
		scsi_id += 8;
		master_tstate = ahc->enabled_targets[ahc->our_id_b + 8];
	}
	if (ahc->enabled_targets[scsi_id] != NULL
	 && ahc->enabled_targets[scsi_id] != master_tstate)
		panic("%s: ahc_alloc_tstate - Target already allocated",
		      ahc_name(ahc));
	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
	if (tstate == NULL)
		return (NULL);
d2672 4
a2675 21
	/*
	 * If we have allocated a master tstate, copy user settings from
	 * the master tstate (taken from SRAM or the EEPROM) for this
	 * channel, but reset our current and goal settings to async/narrow
	 * until an initiator talks to us.
	 */
	if (master_tstate != NULL) {
		bcopy(master_tstate, tstate, sizeof(*tstate));
		tstate->ultraenb = 0;
		for (i = 0; i < 16; i++) {
			bzero(&tstate->transinfo[i].current,
			      sizeof(tstate->transinfo[i].current));
			bzero(&tstate->transinfo[i].goal,
			      sizeof(tstate->transinfo[i].goal));
		}
	} else
		bzero(tstate, sizeof(*tstate));
	s = splbio();
	ahc->enabled_targets[scsi_id] = tstate;
	splx(s);
	return (tstate);
d2678 5
a2682 4
STATIC void
ahc_handle_seqint(ahc, intstat)
	struct ahc_softc *ahc;
	u_int intstat;
d2684 13
a2696 4
	struct scb *scb;
	struct ahc_devinfo devinfo;
	
	ahc_fetch_devinfo(ahc, &devinfo);
d2699 9
a2707 4
	 * Clear the upper byte that holds SEQINT status
	 * codes and clear the SEQINT bit. We will unpause
	 * the sequencer, if appropriate, after servicing
	 * the request.
d2709 6
a2714 20
	ahc_outb(ahc, CLRINT, CLRSEQINT);
	switch (intstat & SEQINT_MASK) {
	case NO_MATCH:
	{
		/* Ensure we don't leave the selection hardware on */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));

		printf("%s:%c:%d: no active SCB for reconnecting "
		       "target - issuing BUS DEVICE RESET\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target);
		printf("SAVED_TCL == 0x%x, ARG_1 == 0x%x, SEQ_FLAGS == 0x%x\n",
		       ahc_inb(ahc, SAVED_TCL), ahc_inb(ahc, ARG_1),
		       ahc_inb(ahc, SEQ_FLAGS));
		ahc->msgout_buf[0] = MSG_BUS_DEV_RESET;
		ahc->msgout_len = 1;
		ahc->msgout_index = 0;
		ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, LASTPHASE) | ATNO);
d2716 1
a2716 8
	}
	case UPDATE_TMSG_REQ:
		ahc_outb(ahc, TARGET_MSG_REQUEST, ahc->targ_msg_req & 0xFF);
		ahc_outb(ahc, TARGET_MSG_REQUEST + 1,
			 (ahc->targ_msg_req >> 8) & 0xFF);
		ahc_outb(ahc, HS_MAILBOX, 0);
		break;
	case SEND_REJECT: 
d2718 16
a2733 16
		u_int rejbyte = ahc_inb(ahc, ACCUM);
		printf("%s:%c:%d: Warning - unknown message received from "
		       "target (0x%x).  Rejecting\n", 
		       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);
		break; 
	}
	case NO_IDENT: 
	{
		/*
		 * The reconnecting target either did not send an identify
		 * message, or did, but we didn't find and SCB to match and
		 * before it could respond to our ATN/abort, it hit a dataphase.
		 * The only safe thing to do is to blow it away with a bus
		 * reset.
		 */
		int found;
d2735 9
a2743 14
		printf("%s:%c:%d: Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x, SAVED_TCL == 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_TCL));
		found = ahc_reset_channel(ahc, devinfo.channel, 
					  /*initiate reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), devinfo.channel,
		       found);
		return;
	}
	case BAD_PHASE:
	{
		u_int lastphase;
d2745 23
a2767 31
		lastphase = ahc_inb(ahc, LASTPHASE);
		if (lastphase == P_BUSFREE) {
			printf("%s:%c:%d: Missed busfree.  Curphase = 0x%x\n",
			       ahc_name(ahc), devinfo.channel, devinfo.target,
			       ahc_inb(ahc, SCSISIGI));
			restart_sequencer(ahc);
			return;
		} else {
			printf("%s:%c:%d: unknown scsi bus phase %x.  "
			       "Attempting to continue\n",
			       ahc_name(ahc), devinfo.channel, devinfo.target,
			       ahc_inb(ahc, SCSISIGI));
		}
		break; 
	}
	case BAD_STATUS:
	{
		u_int  scb_index;
		struct hardware_scb *hscb;
		struct scsi_xfer *xs;
		/*
		 * The sequencer will notify us when a command
		 * has an error that would be of interest to
		 * the kernel.  This allows us to leave the sequencer
		 * running in the common case of command completes
		 * without error.  The sequencer will already have
		 * dma'd the SCB back up to us, so we can reference
		 * the in kernel copy directly.
		 */
		scb_index = ahc_inb(ahc, SCB_TAG);
		scb = &ahc->scb_data->scbarray[scb_index];
d2769 31
a2799 13
		/*
		 * Set the default return value to 0 (don't
		 * send sense).  The sense code will change
		 * this if needed.
		 */
		ahc_outb(ahc, RETURN_1, 0);
		if (!(scb_index < ahc->scb_data->numscbs
		   && (scb->flags & SCB_ACTIVE) != 0)) {
			printf("%s:%c:%d: ahc_intr - referenced scb "
			       "not valid during seqint 0x%x scb(%d)\n",
			       ahc_name(ahc), devinfo.channel,
			       devinfo.target, intstat, scb_index);
			goto unpause;
d2801 5
d2807 5
a2811 2
		hscb = scb->hscb; 
		xs = scb->xs;
a2812 2
		/* Don't want to clobber the original sense code */
		if ((scb->flags & SCB_SENSE) != 0) {
d2814 5
a2818 3
			 * Clear the SCB_SENSE Flag and have
			 * the sequencer do a normal command
			 * complete.
d2820 68
a2887 2
			scb->flags &= ~SCB_SENSE;
			ahcsetccbstatus(xs, XS_DRIVER_STUFFUP);
d2890 14
a2903 15
		/* Freeze the queue unit the client sees the error. */
		ahc_freeze_devq(ahc, xs->sc_link);
		ahc_freeze_ccb(scb);
		xs->status = hscb->status;
		switch (hscb->status) {
		case SCSI_OK:
			printf("%s: Interrupted for staus of 0???\n",
			       ahc_name(ahc));
			break;
		case SCSI_CHECK:
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d: requests Check Status\n",
				       scb->hscb->tag);
a2904 8
#endif
				
			if (xs->error == XS_NOERROR &&
			    !(scb->flags & SCB_SENSE)) {
				struct ahc_dma_seg *sg;
				struct scsi_sense *sc;
				struct ahc_initiator_tinfo *tinfo;
				struct tmode_tstate *tstate;
d2906 9
a2914 9
				sg = scb->sg_list;
				sc = (struct scsi_sense *)(&hscb->cmdstore); 
				/*
				 * Save off the residual if there is one.
				 */
				if (hscb->residual_SG_count != 0)
					ahc_calc_residual(scb);
				else
					xs->resid = 0;
d2916 15
a2930 10
#ifdef AHC_DEBUG
				if (ahc_debug & AHC_SHOWSENSE) {
					sc_print_addr(scb->xs->sc_link);
					printf("Sending Sense\n");
				}
#endif
				sg->addr = ahc->scb_data->sense_busaddr +
					(hscb->tag*sizeof(struct scsi_sense_data));
				
				sg->len = sizeof(struct scsi_sense_data);
d2932 17
a2948 6
				sc->opcode = REQUEST_SENSE;
				sc->byte2 =  SCB_LUN(scb) << 5;
				sc->unused[0] = 0;
				sc->unused[1] = 0;
				sc->length = sg->len;
				sc->control = 0;
d2950 1
d2952 3
a2954 2
				 * Would be nice to preserve DISCENB here,
				 * but due to the way we page SCBs, we can't.
d2956 9
a2964 18
				hscb->control = 0;

				/*
				 * This request sense could be because the
				 * the device lost power or in some other
				 * way has lost our transfer negotiations.
				 * Renegotiate if appropriate.
				 */
				ahc_calc_residual(scb);
#ifdef AHC_DEBUG
				if (ahc_debug & AHC_SHOWSENSE) {
					sc_print_addr(xs->sc_link);
					printf("Sense: datalen %d resid %d"
					       "chan %d id %d targ %d\n",
					       xs->datalen, xs->resid,
					       devinfo.channel,
					       devinfo.our_scsiid,
					       devinfo.target);
d2966 28
a2993 38
#endif
				if (xs->datalen > 0 &&
				    xs->resid == xs->datalen) {
				tinfo = ahc_fetch_transinfo(ahc,
							    devinfo.channel,
							    devinfo.our_scsiid,
							    devinfo.target,
							    &tstate);
					ahc_update_target_msg_request(ahc,
							      &devinfo,
							      tinfo,
							      /*force*/TRUE,
							      /*paused*/TRUE);
				}
				hscb->status = 0;
				hscb->SG_count = 1;
				hscb->SG_pointer = scb->sg_list_phys;
				hscb->data = sg->addr; 
				hscb->datalen = sg->len;
				hscb->cmdpointer = hscb->cmdstore_busaddr;
				hscb->cmdlen = sizeof(*sc);
				scb->sg_count = hscb->SG_count;
				ahc_swap_hscb(hscb);
				ahc_swap_sg(scb->sg_list);
				scb->flags |= SCB_SENSE;
				/*
				 * Ensure the target is busy since this
				 * will be an untagged request.
				 */
				ahc_busy_tcl(ahc, scb);
				ahc_outb(ahc, RETURN_1, SEND_SENSE);

				/*
				 * Ensure we have enough time to actually
				 * retrieve the sense.
				 */
				if (!(scb->xs->flags & SCSI_POLL))
					timeout_add(&scb->xs->stimeout, 5 * hz);
d2995 9
d3005 4
a3008 7
		case SCSI_BUSY:
			/*
			 * Requeue any transactions that haven't been
			 * sent yet.
			 */
			ahc_freeze_devq(ahc, xs->sc_link);
			ahc_freeze_ccb(scb);
d3013 7
a3019 9
	case TRACE_POINT:
	{
		printf("SSTAT2 = 0x%x DFCNTRL = 0x%x\n", ahc_inb(ahc, SSTAT2),
		       ahc_inb(ahc, DFCNTRL));
		printf("SSTAT3 = 0x%x DSTATUS = 0x%x\n", ahc_inb(ahc, SSTAT3),
		       ahc_inb(ahc, DFSTATUS));
		printf("SSTAT0 = 0x%x, SCB_DATACNT = 0x%x\n",
		       ahc_inb(ahc, SSTAT0),
		       ahc_inb(ahc, SCB_DATACNT));
d3021 15
a3035 15
	}
	case HOST_MSG_LOOP:
	{
		/*
		 * The sequencer has encountered a message phase
		 * that requires host assistance for completion.
		 * While handling the message phase(s), we will be
		 * notified by the sequencer after each byte is
		 * transfered so we can track bus phases.
		 *
		 * If this is the first time we've seen a HOST_MSG_LOOP,
		 * initialize the state of the host message loop.
		 */
		if (ahc->msg_type == MSG_TYPE_NONE) {
			u_int bus_phase;
d3037 3
a3039 13
			bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			if (bus_phase != P_MESGIN
			 && bus_phase != P_MESGOUT) {
				printf("ahc_intr: HOST_MSG_LOOP bad "
				       "phase 0x%x\n",
				      bus_phase);
				/*
				 * Probably transitioned to bus free before
				 * we got here.  Just punt the message.
				 */
				ahc_clear_intstat(ahc);
				restart_sequencer(ahc);
			}
d3041 7
a3047 24
			if (devinfo.role == ROLE_INITIATOR) {
				struct scb *scb;
				u_int scb_index;

				scb_index = ahc_inb(ahc, SCB_TAG);
				scb = &ahc->scb_data->scbarray[scb_index];

				if (bus_phase == P_MESGOUT)
					ahc_setup_initiator_msgout(ahc,
								   &devinfo,
								   scb);
				else {
					ahc->msg_type =
					    MSG_TYPE_INITIATOR_MSGIN;
					ahc->msgin_index = 0;
				}
			} else {
				if (bus_phase == P_MESGOUT) {
					ahc->msg_type =
					    MSG_TYPE_TARGET_MSGOUT;
					ahc->msgin_index = 0;
				} else 
					/* XXX Ever executed??? */
					ahc_setup_target_msgin(ahc, &devinfo);
d3050 6
a3055 3

		/* Pass a NULL path so that handlers generate their own */
		ahc_handle_message_phase(ahc, /*path*/NULL);
d3058 2
a3059 2
	case PERR_DETECTED:
	{
d3061 1
a3061 9
		 * If we've cleared the parity error interrupt
		 * but the sequencer still believes that SCSIPERR
		 * is true, it must be that the parity error is
		 * for the currently presented byte on the bus,
		 * and we are not in a phase (data-in) where we will
		 * eventually ack this byte.  Ack the byte and
		 * throw it away in the hope that the target will
		 * take us to message out to deliver the appropriate
		 * error message.
d3063 40
a3102 3
		if ((intstat & SCSIINT) == 0
		 && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {
			u_int curphase;
d3104 1
a3104 15
			/*
			 * The hardware will only let you ack bytes
			 * if the expected phase in SCSISIGO matches
			 * the current phase.  Make sure this is
			 * currently the case.
			 */
			curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			ahc_outb(ahc, LASTPHASE, curphase);
			ahc_outb(ahc, SCSISIGO, curphase);
			ahc_inb(ahc, SCSIDATL);
		}
		break;
	}
	case DATA_OVERRUN:
	{
d3106 2
a3107 6
		 * When the sequencer detects an overrun, it
		 * places the controller in "BITBUCKET" mode
		 * and allows the target to complete its transfer.
		 * Unfortunately, none of the counters get updated
		 * when the controller is in this mode, so we have
		 * no way of knowing how large the overrun was.
d3109 15
a3123 3
		u_int scbindex = ahc_inb(ahc, SCB_TAG);
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		int i;
d3125 7
a3131 22
		scb = &ahc->scb_data->scbarray[scbindex];
		for (i = 0; i < num_phases; i++) {
			if (lastphase == phase_table[i].phase)
				break;
		}
		sc_print_addr(scb->xs->sc_link);
		printf("data overrun detected %s."
		       "  Tag == 0x%x.\n",
		       phase_table[i].phasemsg,
  		       scb->hscb->tag);
		sc_print_addr(scb->xs->sc_link);
		printf("%s seen Data Phase.  Length = %d.  NumSGs = %d.\n",
		       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
		       scb->xs->datalen, scb->sg_count);
		if (scb->sg_count > 0) {
			for (i = 0; i < scb->sg_count; i++) {
				printf("sg[%d] - Addr 0x%x : Length %d\n",
				       i,
				       (unsigned int)le32toh(scb->sg_list[i].addr),
				       (unsigned int)le32toh(scb->sg_list[i].len));
			}
		}
d3133 5
a3137 2
		 * Set this and it will take affect when the
		 * target does a command complete.
d3139 1
a3139 52
		ahc_freeze_devq(ahc, scb->xs->sc_link);
		ahcsetccbstatus(scb->xs, XS_DRIVER_STUFFUP);
		ahc_freeze_ccb(scb);
		break;
	}
	case TRACEPOINT:
	{
		printf("TRACEPOINT: RETURN_2 = %d\n", ahc_inb(ahc, RETURN_2));
#if 0
		printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1));
		printf("SSTAT0 == 0x%x\n", ahc_inb(ahc, SSTAT0));
		printf(", SCSISIGI == 0x%x\n", ahc_inb(ahc, SCSISIGI));
		printf("TRACEPOINT: CCHCNT = %d, SG_COUNT = %d\n",
		       ahc_inb(ahc, CCHCNT), ahc_inb(ahc, SG_COUNT));
		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG));
		printf("TRACEPOINT1: CCHADDR = %d, CCHCNT = %d, SCBPTR = %d\n",
		       ahc_inb(ahc, CCHADDR)
		    | (ahc_inb(ahc, CCHADDR+1) << 8)
		    | (ahc_inb(ahc, CCHADDR+2) << 16)
		    | (ahc_inb(ahc, CCHADDR+3) << 24),
		       ahc_inb(ahc, CCHCNT)
		    | (ahc_inb(ahc, CCHCNT+1) << 8)
		    | (ahc_inb(ahc, CCHCNT+2) << 16),
		       ahc_inb(ahc, SCBPTR));
		printf("TRACEPOINT: WAITING_SCBH = %d\n", 
		       ahc_inb(ahc, WAITING_SCBH));
		printf("TRACEPOINT: SCB_TAG = %d\n", ahc_inb(ahc, SCB_TAG));
#endif
		break;
	}
#if NOT_YET
	/* XXX Fill these in later */
	case MESG_BUFFER_BUSY:
		break;
	case MSGIN_PHASEMIS:
		break;
#endif
	default:
		printf("ahc_intr: seqint, "
		       "intstat == 0x%x, scsisigi = 0x%x\n",
		       intstat, ahc_inb(ahc, SCSISIGI));
		break;
	}
	
unpause:
	/*
	 *  The sequencer is paused immediately on
	 *  a SEQINT, so we should restart it when
	 *  we're done.
	 */
	unpause_sequencer(ahc);
}
d3141 6
a3146 26
STATIC void
ahc_handle_scsiint(ahc, intstat)
	struct ahc_softc *ahc;
	u_int intstat;
{
	u_int	scb_index;
	u_int	status;
	struct	scb *scb;
	char	cur_channel;
	char	intr_channel;

	if ((ahc->features & AHC_TWIN) != 0
	 && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
		cur_channel = 'B';
	else
		cur_channel = 'A';
	intr_channel = cur_channel;

	status = ahc_inb(ahc, SSTAT1);
	if (status == 0) {
		if ((ahc->features & AHC_TWIN) != 0) {
			/* Try the other channel */
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			status = ahc_inb(ahc, SSTAT1);
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			intr_channel = (cur_channel == 'A') ? 'B' : 'A';
d3148 30
a3177 3
		if (status == 0) {
			printf("%s: Spurious SCSI interrupt\n", ahc_name(ahc));
			return;
a3178 1
	}
d3180 11
a3190 8
	scb_index = ahc_inb(ahc, SCB_TAG);
	if (scb_index < ahc->scb_data->numscbs) {
		scb = &ahc->scb_data->scbarray[scb_index];
		if ((scb->flags & SCB_ACTIVE) == 0
		 || (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)
			scb = NULL;
	} else
		scb = NULL;
a3191 5
	if ((status & SCSIRSTI) != 0) {
		printf("%s: Someone reset channel %c\n",
			ahc_name(ahc), intr_channel);
		ahc_reset_channel(ahc, intr_channel, /* Initiate Reset */FALSE);
	} else if ((status & SCSIPERR) != 0) {
d3193 2
a3194 8
		 * Determine the bus phase and queue an appropriate message.
		 * SCSIPERR is latched true as soon as a parity error
		 * occurs.  If the sequencer acked the transfer that
		 * caused the parity error and the currently presented
		 * transfer on the bus has correct parity, SCSIPERR will
		 * be cleared by CLRSCSIPERR.  Use this to determine if
		 * we should look at the last phase the sequencer recorded,
		 * or the current phase presented on the bus.
d3196 10
a3205 5
		u_int mesg_out;
		u_int curphase;
		u_int errorphase;
		u_int lastphase;
		int   i;
a3206 3
		lastphase = ahc_inb(ahc, LASTPHASE);
		curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
		ahc_outb(ahc, CLRSINT1, CLRSCSIPERR);
d3208 12
a3219 9
		 * For all phases save DATA, the sequencer won't
		 * automatically ack a byte that has a parity error
		 * in it.  So the only way that the current phase
		 * could be 'data-in' is if the parity error is for
		 * an already acked byte in the data phase.  During
		 * synchronous data-in transfers, we may actually
		 * ack bytes before latching the current phase in
		 * LASTPHASE, leading to the discrepancy between
		 * curphase and lastphase.
d3221 6
a3226 5
		if ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0
		 || curphase == P_DATAIN)
			errorphase = curphase;
		else
			errorphase = lastphase;
d3228 8
a3235 17
		for (i = 0; i < num_phases; i++) {
			if (errorphase == phase_table[i].phase)
				break;
		}
		mesg_out = phase_table[i].mesg_out;
		if (scb != NULL)
			sc_print_addr(scb->xs->sc_link);
		else
			printf("%s:%c:%d: ", ahc_name(ahc),
			       intr_channel,
			       TCL_TARGET(ahc_inb(ahc, SAVED_TCL)));
		
		printf("parity error detected %s. "
		       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
		       phase_table[i].phasemsg,
		       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),
		       ahc_inb(ahc, SCSIRATE));
d3237 8
d3246 2
a3247 5
		 * We've set the hardware to assert ATN if we   
		 * get a parity error on "in" phases, so all we  
		 * need to do is stuff the message buffer with
		 * the appropriate message.  "In" phases have set
		 * mesg_out to something other than MSG_NOP.
d3249 1
a3249 10
		if (mesg_out != MSG_NOOP) {
			if (ahc->msg_type != MSG_TYPE_NONE)
				ahc->send_msg_perror = TRUE;
			else
				ahc_outb(ahc, MSG_OUT, mesg_out);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		unpause_sequencer(ahc);
	} else if ((status & BUSFREE) != 0
		&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {
d3251 5
a3255 4
		 * First look at what phase we were last in.
		 * If its message out, chances are pretty good
		 * that the busfree was in response to one of
		 * our abort requests.
d3257 26
a3282 6
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		u_int saved_tcl = ahc_inb(ahc, SAVED_TCL);
		u_int target = TCL_TARGET(saved_tcl);
		u_int initiator_role_id = TCL_SCSI_ID(ahc, saved_tcl);
		char channel = TCL_CHANNEL(ahc, saved_tcl);
		int printerror = 1;
d3284 4
a3287 5
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (lastphase == P_MESGOUT) {
			u_int message;
			u_int tag;
d3289 2
a3290 20
			message = ahc->msgout_buf[ahc->msgout_index - 1];
			tag = SCB_LIST_NULL;
			switch (message) {
			case MSG_ABORT_TAG:
				tag = scb->hscb->tag;
				/* FALLTRHOUGH */
			case MSG_ABORT:
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d - Abort %s Completed.\n",
				       scb->hscb->tag, tag == SCB_LIST_NULL ?
				       "" : "Tag");
				ahc_abort_scbs(ahc, target, channel,
					       TCL_LUN(saved_tcl), tag,
					       ROLE_INITIATOR,
					       XS_DRIVER_STUFFUP);
				printerror = 0;
				break;
			case MSG_BUS_DEV_RESET:
			{
				struct ahc_devinfo devinfo;
d3292 9
a3300 27
				if (scb != NULL &&
				    (scb->xs->flags & SCSI_RESET)
				 && ahc_match_scb(scb, target, channel,
						  TCL_LUN(saved_tcl),
						  SCB_LIST_NULL,
						  ROLE_INITIATOR)) {
					ahcsetccbstatus(scb->xs, XS_NOERROR);
				}
				ahc_compile_devinfo(&devinfo,
						    initiator_role_id,
						    target,
						    TCL_LUN(saved_tcl),
						    channel,
						    ROLE_INITIATOR);
				ahc_handle_devreset(ahc, &devinfo,
						    XS_RESET,
						    "Bus Device Reset",
						    /*verbose_level*/0);
				printerror = 0;
				break;
			}
			default:
				break;
			}
		}
		if (printerror != 0) {
			int i;
d3302 9
a3310 2
			if (scb != NULL) {
				u_int tag;
a3311 10
				if ((scb->hscb->control & TAG_ENB) != 0)
					tag = scb->hscb->tag;
				else
					tag = SCB_LIST_NULL;
				ahc_abort_scbs(ahc, target, channel,
					       SCB_LUN(scb), tag,
					       ROLE_INITIATOR,
					       XS_DRIVER_STUFFUP);
				sc_print_addr(scb->xs->sc_link);
			} else {
d3313 2
a3314 2
				 * We had not fully identified this connection,
				 * so we cannot abort anything.
d3316 9
a3324 5
				printf("%s: ", ahc_name(ahc));
			}
			for (i = 0; i < num_phases; i++) {
				if (lastphase == phase_table[i].phase)
					break;
a3325 34
			printf("Unexpected busfree %s\n"
			       "SEQADDR == 0x%x\n",
			       phase_table[i].phasemsg, ahc_inb(ahc, SEQADDR0)
				| (ahc_inb(ahc, SEQADDR1) << 8));
		}
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		restart_sequencer(ahc);
	} else if ((status & SELTO) != 0) {
		u_int scbptr;

		scbptr = ahc_inb(ahc, WAITING_SCBH);
		ahc_outb(ahc, SCBPTR, scbptr);
		scb_index = ahc_inb(ahc, SCB_TAG);

		if (scb_index < ahc->scb_data->numscbs) {
			scb = &ahc->scb_data->scbarray[scb_index];
			if ((scb->flags & SCB_ACTIVE) == 0)
				scb = NULL;
		} else
			scb = NULL;

		if (scb == NULL) {
			printf("%s: ahc_intr - referenced scb not "
			       "valid during SELTO scb(%d, %d)\n",
			       ahc_name(ahc), scbptr, scb_index);
		} else {
			u_int tag;

			tag = SCB_LIST_NULL;
			if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0)
				tag = scb->hscb->tag;
d3327 4
a3330 3
			ahc_abort_scbs(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				       SCB_LUN(scb), tag,
				       ROLE_INITIATOR, XS_SELTIMEOUT);
d3332 2
a3333 2
		/* Stop the selection */
		ahc_outb(ahc, SCSISEQ, 0);
a3334 2
		/* No more pending messages */
		ahc_clear_msg_state(ahc);
d3336 13
a3348 9
		/*
		 * Although the driver does not care about the
		 * 'Selection in Progress' status bit, the busy
		 * LED does.  SELINGO is only cleared by a sucessful
		 * selection, so we must manually clear it to ensure
		 * the LED turns off just incase no future successful
		 * selections occur (e.g. no devices on the bus).
		 */
		ahc_outb(ahc, CLRSINT0, CLRSELINGO);
d3350 40
a3389 10
		/* Clear interrupt state */
		ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		restart_sequencer(ahc);
	} else {
		sc_print_addr(scb->xs->sc_link);
		printf("Unknown SCSIINT. Status = 0x%x\n", status);
		ahc_outb(ahc, CLRSINT1, status);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		unpause_sequencer(ahc);
d3393 6
a3398 4
STATIC void
ahc_build_transfer_msg(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
d3400 5
a3404 39
	/*
	 * We need to initiate transfer negotiations.
	 * If our current and goal settings are identical,
	 * we want to renegotiate due to a check condition.
	 */
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	int	dowide;
	int	dosync;

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
	dowide = tinfo->current.width != tinfo->goal.width;
	dosync = tinfo->current.period != tinfo->goal.period;

	if (!dowide && !dosync) {
		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
		dosync = tinfo->goal.period != 0;
	}

	if (dowide) {
		ahc_construct_wdtr(ahc, tinfo->goal.width);
	} else if (dosync) {
		struct	ahc_syncrate *rate;
		u_int	period;
		u_int	offset;

		period = tinfo->goal.period;
		rate = ahc_devlimited_syncrate(ahc, &period);
		offset = tinfo->goal.offset;
		ahc_validate_offset(ahc, rate, &offset,
				    tinfo->current.width);
		ahc_construct_sdtr(ahc, period, offset);
	} else {
		panic("ahc_intr: AWAITING_MSG for negotiation, "
		      "but no negotiation needed\n");	
	}
}
d3406 3
a3408 13
STATIC void
ahc_setup_initiator_msgout(ahc, devinfo, scb)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	struct scb *scb;
{
	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;
d3410 9
a3418 3
	if ((scb->flags & SCB_DEVICE_RESET) == 0
	 && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {
		u_int identify_msg;
d3420 3
a3422 5
		identify_msg = MSG_IDENTIFYFLAG | SCB_LUN(scb);
		if ((scb->hscb->control & DISCENB) != 0)
			identify_msg |= MSG_IDENTIFY_DISCFLAG;
		ahc->msgout_buf[ahc->msgout_index++] = identify_msg;
		ahc->msgout_len++;
d3424 3
a3426 5
		if ((scb->hscb->control & TAG_ENB) != 0) {
			/* XXX fvdl FreeBSD has tag action passed down */
			ahc->msgout_buf[ahc->msgout_index++] = MSG_SIMPLE_Q_TAG;
			ahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;
			ahc->msgout_len += 2;
d3429 1
a3429 24

	if (scb->flags & SCB_DEVICE_RESET) {
		ahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;
		ahc->msgout_len++;
		
		sc_print_addr(scb->xs->sc_link);
		printf("Bus Device Reset Message Sent\n");
	} else if (scb->flags & SCB_ABORT) {
		if ((scb->hscb->control & TAG_ENB) != 0)
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;
		else
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;
		ahc->msgout_len++;
		sc_print_addr(scb->xs->sc_link);
		printf("Abort Message Sent\n");
	} else if ((ahc->targ_msg_req & devinfo->target_mask) != 0) {
		ahc_build_transfer_msg(ahc, devinfo);
	} else {
		printf("ahc_intr: AWAITING_MSG for an SCB that "
		       "does not have a waiting message");
		panic("SCB = %d, SCB Control = %x, MSG_OUT = %x "
		      "SCB flags = %x", scb->hscb->tag, scb->hscb->control,
		      ahc_inb(ahc, MSG_OUT), scb->flags);
	}
d3432 1
a3432 2
	 * Clear the MK_MESSAGE flag from the SCB so we aren't
	 * asked to send this message again.
d3434 13
a3446 3
	ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);
	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
d3449 4
a3452 4
STATIC void
ahc_setup_target_msgin(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
d3454 1
d3463 1
a3463 1
	if ((ahc->targ_msg_req & devinfo->target_mask) != 0)
d3471 47
d3519 2
a3520 4
STATIC int
ahc_handle_msg_reject(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
a3521 10
	/*
	 * What we care about here is if we had an
	 * outstanding SDTR or WDTR message for this
	 * target.  If we did, this is a signal that
	 * the target is refusing negotiation.
	 */
	struct scb *scb;
	u_int scb_index;
	u_int last_msg;
	int   response = 0;
d3523 14
a3536 2
	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = &ahc->scb_data->scbarray[scb_index];
d3538 2
a3539 2
	/* Might be necessary */
	last_msg = ahc_inb(ahc, LAST_MSG);
d3541 4
a3544 3
	if (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/FALSE)) {
		struct ahc_initiator_tinfo *tinfo;
		struct tmode_tstate *tstate;
d3546 33
a3578 30
		/* note 8bit xfers */
		if (bootverbose)
			printf("%s:%c:%d: refuses WIDE negotiation.  Using "
			       "8bit transfers\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target);
		ahc_set_width(ahc, devinfo,
			      MSG_EXT_WDTR_BUS_8_BIT,
			      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
			      /*paused*/TRUE, /*done*/TRUE);
		/*
		 * No need to clear the sync rate.  If the target
		 * did not accept the command, our syncrate is
		 * unaffected.  If the target started the negotiation,
		 * but rejected our response, we already cleared the
		 * sync rate before sending our WDTR.
		 */
		tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
					    devinfo->our_scsiid,
					    devinfo->target, &tstate);
		if (tinfo->goal.period) {
			u_int period;

			/* Start the sync negotiation */
			period = tinfo->goal.period;
			ahc_devlimited_syncrate(ahc, &period);
			ahc->msgout_index = 0;
			ahc->msgout_len = 0;
			ahc_construct_sdtr(ahc, period, tinfo->goal.offset);
			ahc->msgout_index = 0;
			response = 1;
d3580 2
a3581 19
	} else if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/FALSE)) {
		/* note asynch xfers and clear flag */
		ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL, /*period*/0,
				 /*offset*/0,
				 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				 /*paused*/TRUE,
				 /*done*/TRUE);
		if (bootverbose)
			printf("%s:%c:%d: refuses synchronous negotiation. "
			       "Using asynchronous transfers\n",
			       ahc_name(ahc),
			       devinfo->channel, devinfo->target);
	} else if ((scb->hscb->control & MSG_SIMPLE_Q_TAG) != 0) {
		if (bootverbose)
			printf("%s:%c:%d: refuses tagged commands.  Performing "
			       "non-tagged I/O\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target);
			
		ahc_set_tags(ahc, devinfo, FALSE);
d3583 13
a3595 9
		/*
		 * Resend the identify for this CCB as the target
		 * may believe that the selection is invalid otherwise.
		 */
		ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL)
					  & ~MSG_SIMPLE_Q_TAG);
	 	scb->hscb->control &= ~MSG_SIMPLE_Q_TAG;
		ahc_outb(ahc, MSG_OUT, MSG_IDENTIFYFLAG);
		ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);
d3597 4
a3600 18
		/*
		 * Requeue all tagged commands for this target
		 * currently in our posession so they can be
		 * converted to untagged commands.
		 */
		ahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				   SCB_LUN(scb), /*tag*/SCB_LIST_NULL,
				   ROLE_INITIATOR, SCB_REQUEUE,
				   SEARCH_COMPLETE);
	} else {
		/*
		 * Otherwise, we ignore it.
		 */
		printf("%s:%c:%d: Message reject for %x -- ignored\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       last_msg);
	}
	return (response);
d3603 2
a3604 3
STATIC void
ahc_clear_msg_state(ahc)
	struct ahc_softc *ahc;
d3606 3
a3608 4
	ahc->msgout_len = 0;
	ahc->msgin_index = 0;
	ahc->msg_type = MSG_TYPE_NONE;
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
d3611 33
a3643 8
STATIC void
ahc_handle_message_phase(ahc, sc_link)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
{ 
	struct	ahc_devinfo devinfo;
	u_int	bus_phase;
	int	end_session;
d3645 6
a3650 3
	ahc_fetch_devinfo(ahc, &devinfo);
	end_session = FALSE;
	bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
d3652 4
a3655 7
reswitch:
	switch (ahc->msg_type) {
	case MSG_TYPE_INITIATOR_MSGOUT:
	{
		int lastbyte;
		int phasemis;
		int msgdone;
d3657 2
a3658 2
		if (ahc->msgout_len == 0)
			panic("REQINIT interrupt with no active message");
d3660 5
a3664 14
		phasemis = bus_phase != P_MESGOUT;
		if (phasemis) {
			if (bus_phase == P_MESGIN) {
				/*
				 * Change gears and see if
				 * this messages is of interest to
				 * us or should be passed back to
				 * the sequencer.
				 */
				ahc_outb(ahc, CLRSINT1, CLRATNO);
				ahc->send_msg_perror = FALSE;
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;
				ahc->msgin_index = 0;
				goto reswitch;
d3666 2
a3667 2
			end_session = TRUE;
			break;
d3669 23
d3693 9
a3701 6
		if (ahc->send_msg_perror) {
			ahc_outb(ahc, CLRSINT1, CLRATNO);
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
			ahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);
			break;
		}
d3703 20
a3722 16
		msgdone	= ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			/*
			 * The target has requested a retry.
			 * Re-assert ATN, reset our message index to
			 * 0, and try again.
			 */
			ahc->msgout_index = 0;
			ahc_outb(ahc, SCSISIGO, ahc_inb(ahc, SCSISIGO) | ATNO);
		}

		lastbyte = ahc->msgout_index == (ahc->msgout_len - 1);
		if (lastbyte) {
			/* Last byte is signified by dropping ATN */
			ahc_outb(ahc, CLRSINT1, CLRATNO);
		}
d3725 2
a3726 2
		 * Clear our interrupt status and present
		 * the next byte on the bus.
d3728 4
a3731 3
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
		break;
d3733 1
a3733 4
	case MSG_TYPE_INITIATOR_MSGIN:
	{
		int phasemis;
		int message_done;
d3735 1
a3735 1
		phasemis = bus_phase != P_MESGIN;
d3737 7
a3743 12
		if (phasemis) {
			ahc->msgin_index = 0;
			if (bus_phase == P_MESGOUT
			 && (ahc->send_msg_perror == TRUE
			  || (ahc->msgout_len != 0
			   && ahc->msgout_index == 0))) {
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
				goto reswitch;
			}
			end_session = TRUE;
			break;
		}
d3745 5
a3749 2
		/* Pull the byte in without acking it */
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);
d3751 21
a3771 1
		message_done = ahc_parse_msg(ahc, sc_link, &devinfo);
d3773 10
a3782 6
		if (message_done) {
			/*
			 * Clear our incoming message buffer in case there
			 * is another message following this one.
			 */
			ahc->msgin_index = 0;
d3784 6
a3789 10
			/*
			 * If this message illicited a response,
			 * assert ATN so the target takes us to the
			 * message out phase.
			 */
			if (ahc->msgout_len != 0)
				ahc_outb(ahc, SCSISIGO,
					 ahc_inb(ahc, SCSISIGO) | ATNO);
		} else 
			ahc->msgin_index++;
d3791 4
a3794 9
		/* Ack the byte */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_inb(ahc, SCSIDATL);
		break;
	}
	case MSG_TYPE_TARGET_MSGIN:
	{
		int msgdone;
		int msgout_request;
d3796 2
a3797 2
		if (ahc->msgout_len == 0)
			panic("Target MSGIN with no active message");
d3799 6
a3804 11
		/*
		 * If we interrupted a mesgout session, the initiator
		 * will not know this until our first REQ.  So, we
		 * only honor mesgout requests after we've sent our
		 * first byte.
		 */
		if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0
		 && ahc->msgout_index > 0)
			msgout_request = TRUE;
		else
			msgout_request = FALSE;
d3806 1
a3806 1
		if (msgout_request) {
d3808 3
a3810 13
			/*
			 * Change gears and see if
			 * this messages is of interest to
			 * us or should be passed back to
			 * the sequencer.
			 */
			ahc->msg_type = MSG_TYPE_TARGET_MSGOUT;
			ahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);
			ahc->msgin_index = 0;
			/* Dummy read to REQ for first byte */
			ahc_inb(ahc, SCSIDATL);
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
d3812 2
a3813 7
		}

		msgdone = ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
			end_session = TRUE;
d3815 3
a3817 1
		}
d3819 5
a3823 11
		/*
		 * Present the next byte on the bus.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
		break;
	}
	case MSG_TYPE_TARGET_MSGOUT:
	{
		int lastbyte;
		int msgdone;
d3825 4
a3828 5
		/*
		 * The initiator signals that this is
		 * the last byte by dropping ATN.
		 */
		lastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;
d3830 8
a3837 19
		/*
		 * Read the latched byte, but turn off SPIOEN first
		 * so that we don't inadvertantly cause a REQ for the
		 * next byte.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);
		msgdone = ahc_parse_msg(ahc, sc_link, &devinfo);
		if (msgdone == MSGLOOP_TERMINATED) {
			/*
			 * The message is *really* done in that it caused
			 * us to go to bus free.  The sequencer has already
			 * been reset at this point, so pull the ejection
			 * handle.
			 */
			return;
		}
		
		ahc->msgin_index++;
d3839 2
a3840 6
		/*
		 * XXX Read spec about initiator dropping ATN too soon
		 *     and use msgdone to detect it.
		 */
		if (msgdone == MSGLOOP_MSGCOMPLETE) {
			ahc->msgin_index = 0;
d3842 2
a3843 13
			/*
			 * If this message illicited a response, transition
			 * to the Message in phase and send it.
			 */
			if (ahc->msgout_len != 0) {
				ahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);
				ahc_outb(ahc, SXFRCTL0,
					 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
				ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
				ahc->msgin_index = 0;
				break;
			}
		}
d3845 5
a3849 7
		if (lastbyte)
			end_session = TRUE;
		else {
			/* Ask for the next byte. */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		}
d3851 2
a3852 4
		break;
	}
	default:
		panic("Unknown REQINIT message type");
d3855 7
a3861 5
	if (end_session) {
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);
	} else
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
d3864 3
a3866 11
/*
 * See if we sent a particular extended message to the target.
 * If "full" is true, the target saw the full message.
 * If "full" is false, the target saw at least the first
 * byte of the message.
 */
STATIC int
ahc_sent_msg(ahc, msgtype, full)
	struct ahc_softc *ahc;
	u_int msgtype;
	int full;
d3868 1
a3868 2
	int found;
	int index;
d3870 3
a3872 2
	found = FALSE;
	index = 0;
d3874 7
a3880 2
	while (index < ahc->msgout_len) {
		if (ahc->msgout_buf[index] == MSG_EXTENDED) {
d3882 1
a3882 3
			/* Found a candidate */
			if (ahc->msgout_buf[index+2] == msgtype) {
				u_int end_index;
d3884 7
a3890 11
				end_index = index + 1
					  + ahc->msgout_buf[index + 1];
				if (full) {
					if (ahc->msgout_index > end_index)
						found = TRUE;
				} else if (ahc->msgout_index > index)
					found = TRUE;
			}
			break;
		} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_Q_TAG
			&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
d3892 3
a3894 6
			/* Skip tag type and tag id or residue param*/
			index += 2;
		} else {
			/* Single byte message */
			index++;
		}
a3895 15
	return (found);
}

STATIC int
ahc_parse_msg(ahc, sc_link, devinfo)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
	struct ahc_devinfo *devinfo;
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	tmode_tstate *tstate;
	int	reject;
	int	done;
	int	response;
	u_int	targ_scsirate;
d3897 1
a3897 6
	done = MSGLOOP_IN_PROG;
	response = FALSE;
	reject = FALSE;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	targ_scsirate = tinfo->scsirate;
d3900 3
a3902 5
	 * Parse as much of the message as is availible,
	 * rejecting it if we don't support it.  When
	 * the entire message is availible and has been
	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
	 * that we have parsed an entire message.
d3904 3
a3906 3
	 * In the case of extended messages, we accept the length
	 * byte outright and perform more checking once we know the
	 * extended message type.
d3908 12
a3919 19
	switch (ahc->msgin_buf[0]) {
	case MSG_MESSAGE_REJECT:
		response = ahc_handle_msg_reject(ahc, devinfo);
		/* FALLTHROUGH */
	case MSG_NOOP:
		done = MSGLOOP_MSGCOMPLETE;
		break;
	case MSG_IGN_WIDE_RESIDUE:
	{
		/* Wait for the whole message */
		if (ahc->msgin_index >= 1) {
			if (ahc->msgin_buf[1] != 1
			 || tinfo->current.width == MSG_EXT_WDTR_BUS_8_BIT) {
				reject = TRUE;
				done = MSGLOOP_MSGCOMPLETE;
			} else
				ahc_handle_ign_wide_residue(ahc, devinfo);
		}
		break;
a3920 17
	case MSG_EXTENDED:
	{
		/* Wait for enough of the message to begin validation */
		if (ahc->msgin_index < 2)
			break;
		switch (ahc->msgin_buf[2]) {
		case MSG_EXT_SDTR:
		{
			struct	 ahc_syncrate *syncrate;
			u_int	 period;
			u_int	 offset;
			u_int	 saved_offset;
			
			if (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
				reject = TRUE;
				break;
			}
d3922 1
a3922 9
			/*
			 * Wait until we have both args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_SDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))
				break;
d3924 6
a3929 9
			period = ahc->msgin_buf[3];
			saved_offset = offset = ahc->msgin_buf[4];
			syncrate = ahc_devlimited_syncrate(ahc, &period);
			ahc_validate_offset(ahc, syncrate, &offset,
					    targ_scsirate & WIDEXFER);
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period, offset,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE, /*done*/TRUE);
d3931 1
a3931 30
			/*
			 * See if we initiated Sync Negotiation
			 * and didn't have to fall down to async
			 * transfers.
			 */
			if (ahc_sent_msg(ahc, MSG_EXT_SDTR, /*full*/TRUE)) {
				/* We started it */
				if (saved_offset != offset) {
					/* Went too low - force async */
					reject = TRUE;
				}
			} else {
				/*
				 * Send our own SDTR in reply
				 */
				if (bootverbose)
					printf("Sending SDTR!\n");
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_sdtr(ahc, period, offset);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		case MSG_EXT_WDTR:
		{
			u_int	bus_width;
			u_int	sending_reply;
d3933 5
a3937 5
			sending_reply = FALSE;
			if (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
				reject = TRUE;
				break;
			}
d3939 1
a3939 9
			/*
			 * Wait until we have our arg before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_WDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))
				break;
d3941 11
a3951 90
			bus_width = ahc->msgin_buf[3];
			if (ahc_sent_msg(ahc, MSG_EXT_WDTR, /*full*/TRUE)) {
				/*
				 * Don't send a WDTR back to the
				 * target, since we asked first.
				 */
				switch (bus_width){
				default:
					/*
					 * How can we do anything greater
					 * than 16bit transfers on a 16bit
					 * bus?
					 */
					reject = TRUE;
					printf("%s: target %d requested %dBit "
					       "transfers.  Rejecting...\n",
					       ahc_name(ahc), devinfo->target,
					       8 * (0x01 << bus_width));
					/* FALLTHROUGH */
				case MSG_EXT_WDTR_BUS_8_BIT:
					bus_width = MSG_EXT_WDTR_BUS_8_BIT;
					break;
				case MSG_EXT_WDTR_BUS_16_BIT:
					break;
				}
			} else {
				/*
				 * Send our own WDTR in reply
				 */
				if (bootverbose)
					printf("Sending WDTR!\n");
				switch (bus_width) {
				default:
					if (ahc->features & AHC_WIDE) {
						/* Respond Wide */
						bus_width =
						    MSG_EXT_WDTR_BUS_16_BIT;
						break;
					}
					/* FALLTHROUGH */
				case MSG_EXT_WDTR_BUS_8_BIT:
					bus_width = MSG_EXT_WDTR_BUS_8_BIT;
					break;
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_wdtr(ahc, bus_width);
				ahc->msgout_index = 0;
				response = TRUE;
				sending_reply = TRUE;
			}
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE, /*done*/TRUE);

			/* After a wide message, we are async */
			ahc_set_syncrate(ahc, devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, AHC_TRANS_ACTIVE,
					 /*paused*/TRUE, /*done*/FALSE);
			if (sending_reply == FALSE && reject == FALSE) {

				if (tinfo->goal.period) {
					struct	ahc_syncrate *rate;
					u_int	period;
					u_int	offset;

					/* Start the sync negotiation */
					period = tinfo->goal.period;
					rate = ahc_devlimited_syncrate(ahc,
								       &period);
					offset = tinfo->goal.offset;
					ahc_validate_offset(ahc, rate, &offset,
							  tinfo->current.width);
					ahc->msgout_index = 0;
					ahc->msgout_len = 0;
					ahc_construct_sdtr(ahc, period, offset);
					ahc->msgout_index = 0;
					response = TRUE;
				}
			}
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		default:
			/* Unknown extended message.  Reject it. */
			reject = TRUE;
			break;
		}
		break;
a3952 21
	case MSG_BUS_DEV_RESET:
		ahc_handle_devreset(ahc, devinfo,
				    XS_RESET, "Bus Device Reset Received",
				    /*verbose_level*/0);
		restart_sequencer(ahc);
		done = MSGLOOP_TERMINATED;
		break;
	case MSG_ABORT_TAG:
	case MSG_ABORT:
	case MSG_CLEAR_QUEUE:
		/* Target mode messages */
		if (devinfo->role != ROLE_TARGET) {
			reject = TRUE;
			break;
		}
#if AHC_TARGET_MODE
		ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       devinfo->lun,
			       ahc->msgin_buf[0] == MSG_ABORT_TAG ? SCB_LIST_NULL
			       : ahc_inb(ahc, INITIATOR_TAG),
				ROLE_TARGET, XS_DRIVER_STUFFUP);
d3954 1
a3954 3
		tstate = ahc->enabled_targets[devinfo->our_scsiid];
		if (tstate != NULL) {
			struct tmode_lstate* lstate;
d3956 5
a3960 29
			lstate = tstate->enabled_luns[devinfo->lun];
			if (lstate != NULL) {
				ahc_queue_lstate_event(ahc, lstate,
						       devinfo->our_scsiid,
						       ahc->msgin_buf[0],
						       /*arg*/0);
				ahc_send_lstate_events(ahc, lstate);
			}
		}
		done = MSGLOOP_MSGCOMPLETE;
#else
		panic("ahc: got target mode message");
#endif
		break;
	case MSG_TERM_IO_PROC:
	default:
		reject = TRUE;
		break;
	}

	if (reject) {
		/*
		 * Setup to reject the message.
		 */
		ahc->msgout_index = 0;
		ahc->msgout_len = 1;
		ahc->msgout_buf[0] = MSG_MESSAGE_REJECT;
		done = MSGLOOP_MSGCOMPLETE;
		response = TRUE;
d3963 1
a3963 50
	if (done != MSGLOOP_IN_PROG && !response)
		/* Clear the outgoing message buffer */
		ahc->msgout_len = 0;

	return (done);
}

STATIC void
ahc_handle_ign_wide_residue(ahc, devinfo)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
{
	u_int scb_index;
	struct scb *scb;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = &ahc->scb_data->scbarray[scb_index];
	if ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0
	 || !(scb->xs->flags & SCSI_DATA_IN)) {
		/*
		 * Ignore the message if we haven't
		 * seen an appropriate data phase yet.
		 */
	} else {
		/*
		 * If the residual occurred on the last
		 * transfer and the transfer request was
		 * expected to end on an odd count, do
		 * nothing.  Otherwise, subtract a byte
		 * and update the residual count accordingly.
		 */
		u_int resid_sgcnt;

		resid_sgcnt = ahc_inb(ahc, SCB_RESID_SGCNT);
		if (resid_sgcnt == 0
		 && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {
			/*
			 * If the residual occurred on the last
			 * transfer and the transfer request was
			 * expected to end on an odd count, do
			 * nothing.
			 */
		} else {
			u_int data_cnt;
			u_int data_addr;
			u_int sg_index;

			data_cnt = (ahc_inb(ahc, SCB_RESID_DCNT + 2) << 16)
				 | (ahc_inb(ahc, SCB_RESID_DCNT + 1) << 8)
				 | (ahc_inb(ahc, SCB_RESID_DCNT));
d3965 5
a3969 4
			data_addr = (ahc_inb(ahc, SHADDR + 3) << 24)
				  | (ahc_inb(ahc, SHADDR + 2) << 16)
				  | (ahc_inb(ahc, SHADDR + 1) << 8)
				  | (ahc_inb(ahc, SHADDR));
d3971 1
a3971 2
			data_cnt += 1;
			data_addr -= 1;
d3973 11
a3983 1
			sg_index = scb->sg_count - resid_sgcnt;
d3985 1
a3985 22
			if (sg_index != 0
			 && (le32toh(scb->sg_list[sg_index].len) < data_cnt)) {
				u_int32_t sg_addr;

				sg_index--;
				data_cnt = 1;
				data_addr = le32toh(scb->sg_list[sg_index].addr)
					  + le32toh(scb->sg_list[sg_index].len)
					  - 1;
				
				/*
				 * The physical address base points to the
				 * second entry as it is always used for
				 * calculating the "next S/G pointer".
				 */
				sg_addr = scb->sg_list_phys
					+ (sg_index* sizeof(*scb->sg_list));
				ahc_outb(ahc, SG_NEXT + 3, sg_addr >> 24);
				ahc_outb(ahc, SG_NEXT + 2, sg_addr >> 16);
				ahc_outb(ahc, SG_NEXT + 1, sg_addr >> 8);
				ahc_outb(ahc, SG_NEXT, sg_addr);
			}
d3987 3
a3989 3
			ahc_outb(ahc, SCB_RESID_DCNT + 2, data_cnt >> 16);
			ahc_outb(ahc, SCB_RESID_DCNT + 1, data_cnt >> 8);
			ahc_outb(ahc, SCB_RESID_DCNT, data_cnt);
d3991 5
a3995 5
			ahc_outb(ahc, SHADDR + 3, data_addr >> 24);
			ahc_outb(ahc, SHADDR + 2, data_addr >> 16);
			ahc_outb(ahc, SHADDR + 1, data_addr >> 8);
			ahc_outb(ahc, SHADDR, data_addr);
		}
a3996 1
}
d3998 5
a4002 9
STATIC void
ahc_handle_devreset(ahc, devinfo, status, message, verbose_level)
	struct ahc_softc *ahc;
	struct ahc_devinfo *devinfo;
	int status;
	char *message;
	int verbose_level;
{
	int found;
a4003 4
	found = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       ALL_LUNS, SCB_LIST_NULL, devinfo->role,
			       status);
	
d4005 1
a4005 3
	 * Go back to async/narrow transfers and renegotiate.
	 * ahc_set_width and ahc_set_syncrate can cope with NULL
	 * paths.
d4007 5
a4011 10
	ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
		      AHC_TRANS_CUR, /*paused*/TRUE, /*done*/FALSE);
	ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,
			 /*period*/0, /*offset*/0, AHC_TRANS_CUR,
			 /*paused*/TRUE, /*done*/FALSE);
	
	if (message != NULL
	 && (verbose_level <= bootverbose))
		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahc_name(ahc),
		       message, devinfo->channel, devinfo->target, found);
d4014 2
a4015 9
/*
 * We have an scb which has been processed by the
 * adaptor, now we look to see how the operation
 * went.
 */
STATIC void
ahc_done(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
d4017 1
a4017 4
	struct scsi_xfer *xs = scb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	int requeue = 0;
	int target;
d4019 3
a4021 3
	SC_DEBUG(xs->sc_link, SDEV_DB2, ("ahc_done\n"));
	
	LIST_REMOVE(scb, pend_links);
d4023 5
a4027 1
	timeout_del(&scb->xs->stimeout);
d4029 10
a4038 5
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWCMDS) {
		sc_print_addr(sc_link);
		printf("ahc_done opcode %d tag %x\n", xs->cmdstore.opcode,
		    scb->hscb->tag);
d4040 23
a4062 14
#endif
	
	target = sc_link->target;
	
	if (xs->datalen) {
		int op;
	
		if ((xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_POSTREAD;
		else
			op = BUS_DMASYNC_POSTWRITE;
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
		    0, scb->dmamap->dm_mapsize, op);
		bus_dmamap_unload(ahc->sc_dmat, scb->dmamap);
d4064 3
d4068 10
a4077 7
	/*
	 * Unbusy this target/channel/lun.
	 * XXX if we are holding two commands per lun, 
	 *     send the next command.
	 */
	if (!(scb->hscb->control & TAG_ENB))
		ahc_index_busy_tcl(ahc, scb->hscb->tcl, /*unbusy*/TRUE);
d4079 4
a4082 5
	/*
	 * If the recovery SCB completes, we have to be
	 * out of our timeout.
	 */
	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
d4084 1
a4084 1
		struct	scb *scbp;
d4086 1
a4086 8
		/*
		 * We were able to complete the command successfully,
		 * so reinstate the timeouts for all other pending
		 * commands.
		 */
		scbp = ahc->pending_scbs.lh_first;
		while (scbp != NULL) {
			struct scsi_xfer *txs = scbp->xs;
d4088 2
a4089 5
			if (!(txs->flags & SCSI_POLL))
				timeout_add(&scbp->xs->stimeout,
				    (scbp->xs->timeout * hz)/1000);
			scbp = LIST_NEXT(scbp, pend_links);
		}
d4091 6
a4096 12
		/*
		 * Ensure that we didn't put a second instance of this
		 * SCB into the QINFIFO.
		 */
		ahc_search_qinfifo(ahc, SCB_TARGET(scb), SCB_CHANNEL(scb),
				   SCB_LUN(scb), scb->hscb->tag,
				   ROLE_INITIATOR, /*status*/0,
				   SEARCH_REMOVE);
		if (xs->error != XS_NOERROR)
			ahcsetccbstatus(xs, XS_TIMEOUT);
		sc_print_addr(xs->sc_link);
		printf("no longer in timeout, status = %x\n", xs->status);
d4099 8
a4106 26
	if (xs->error != XS_NOERROR) {
		/* Don't clobber any existing error state */
	} else if ((scb->flags & SCB_SENSE) != 0) {
		/*
		 * We performed autosense retrieval.
		 *
		 * bzero the sense data before having
		 * the drive fill it.  The SCSI spec mandates
		 * that any untransfered data should be
		 * assumed to be zero.  Complete the 'bounce'
		 * of sense information through buffers accessible
		 * via bus-space by copying it into the clients
		 * csio.
		 */
		bzero(&xs->sense, sizeof(struct scsi_sense));
		bcopy(&ahc->scb_data->sense[scb->hscb->tag],
		      &xs->sense, le32toh(scb->sg_list->len));
		xs->error = XS_SENSE;
	}
	if (scb->flags & SCB_FREEZE_QUEUE) {
		ahc->devqueue_blocked[target]--;
		scb->flags &= ~SCB_FREEZE_QUEUE;
	}
	
	requeue = scb->flags & SCB_REQUEUE;
	ahcfreescb(ahc, scb);
d4108 13
a4120 1
	if (requeue) {
d4122 2
a4123 2
		 * Re-insert at the front of the private queue to
		 * preserve order.
d4125 17
a4141 10
		int s;

		s = splbio();
		/* TAILQ_INSERT_HEAD(&ahc->sc_q, xs, adapter_q); */
		ahc_list_insert_head(ahc, xs);
		splx(s);
	} else {
		xs->flags |= ITSDONE;
		ahc_check_tags(ahc, xs);
		scsi_done(xs);
a4142 11

	/*
	 * If there are entries in the software queue, try to
	 * run the first one.  We should be more or less guaranteed
	 * to succeed, since we just freed an SCB.
	 *
	 * NOTE: ahc_scsi_cmd() relies on our calling it with
	 * the first entry in the queue.
	 */
	if ((xs = ahc->sc_xxxq.lh_first) != NULL)
		(void) ahc_scsi_cmd(xs);
d4144 1
d4146 2
a4147 6
/*
 * Determine the number of SCBs available on the controller
 */
int
ahc_probe_scbs(ahc)
	struct ahc_softc *ahc;
d4149 12
a4160 1
	int i;
d4162 15
a4176 8
	for (i = 0; i < AHC_SCB_MAX; i++) {
		ahc_outb(ahc, SCBPTR, i);
		ahc_outb(ahc, SCB_CONTROL, i);
		if (ahc_inb(ahc, SCB_CONTROL) != i)
			break;
		ahc_outb(ahc, SCBPTR, 0);
		if (ahc_inb(ahc, SCB_CONTROL) != 0)
			break;
d4178 7
a4184 2
	
	return (i);
d4191 1
a4191 2
ahc_init(ahc)
	struct ahc_softc *ahc;
d4193 14
a4206 11
	int	  max_targ = 15;
	int	  i;
	int	  term;
	u_int	  scsi_conf;
	u_int	  scsiseq_template;
	u_int	  ultraenb;
	u_int	  discenable;
	u_int	  tagenable;
	size_t	  driver_data_size;
	u_int32_t physaddr;
	struct scb_data *scb_data = NULL;
d4226 1
a4226 10

	if (ahc->scb_data == NULL) {
		scb_data = malloc(sizeof (struct scb_data), M_DEVBUF, M_NOWAIT);
		if (scb_data == NULL) {
			printf("%s: cannot malloc scb_data!\n", ahc_name(ahc));
			return (ENOMEM);
		}
		bzero(scb_data, sizeof(struct scb_data));
		ahc->scb_data = scb_data;
	}
d4236 25
a4260 2
	ahc->flags |= AHC_INITIATORMODE;
	
d4264 9
a4272 9
	 * roles, we need to allocate space for the qinfifo, qoutfifo,
	 * and untagged_scb arrays each of which are composed of 256
	 * 1 byte elements.  When providing for the target mode role,
	 * we additionally must provide space for the incoming target
	 * command fifo.
	 */
	driver_data_size = 3 * 256 * sizeof(u_int8_t);

	if (ahc_createdmamem(ahc, driver_data_size, 
d4279 25
d4305 1
a4305 4
	/* Allocate SCB data now that sc_dmat is initialized */
	if (ahc->scb_data->maxhscbs == 0)
		if (ahcinitscbdata(ahc) != 0)
			return (ENOMEM);
d4307 19
a4326 4
	ahc->untagged_scbs = &ahc->qinfifo[256];
	/* There are no untagged SCBs active yet. */
	for (i = 0; i < 256; i++)
		ahc->untagged_scbs[i] = SCB_LIST_NULL;
d4328 6
a4333 3
	/* All of our queues are empty */
	for (i = 0; i < 256; i++)
		ahc->qoutfifo[i] = SCB_LIST_NULL;
a4334 3
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap,
		 0, driver_data_size, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	
d4341 1
a4341 1
		printf("%s: unable to allocate tmode_tstate.  "
d4343 1
a4343 1
		return (-1);
d4348 1
a4348 1
			printf("%s: unable to allocate tmode_tstate.  "
d4350 1
a4350 10
			return (-1);
		}
 		printf("Twin Channel, A SCSI Id=%d, B SCSI Id=%d, primary %c, ",
		       ahc->our_id, ahc->our_id_b,
		       ahc->flags & AHC_CHANNEL_B_PRIMARY? 'B': 'A');
	} else {
		if ((ahc->features & AHC_WIDE) != 0) {
			printf("Wide ");
		} else {
			printf("Single ");
a4351 1
		printf("Channel %c, SCSI Id=%d, ", ahc->channel, ahc->our_id);
d4355 1
a4358 1
		printf("%d/%d SCBs\n", ahc->scb_data->maxhscbs, AHC_SCB_MAX);
a4360 1
		printf("%d SCBs\n", ahc->scb_data->maxhscbs);
d4368 1
a4368 1
		        sizeof(struct hardware_scb),
d4374 1
a4374 1
	/* Set the SCSI Id,SXFRCTL0,SXFRCTL1, and SIMODE1, for both channels*/
d4381 1
d4383 1
a4383 4
		if ((ahc->features & AHC_ULTRA2) != 0)
			ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id_b);
		else
			ahc_outb(ahc, SCSIID, ahc->our_id_b);
d4386 3
a4388 1
					|term|ENSTIMER|ACTNEGEN);
d4393 1
a4393 1
		 && (ahc->flags & AHC_INITIATORMODE) != 0)
d4399 1
d4407 1
a4407 1
				|term
d4409 2
d4415 1
a4415 1
	 && (ahc->flags & AHC_INITIATORMODE) != 0)
d4447 1
a4447 1
		struct tmode_tstate *tstate;
d4463 1
a4463 1
		bzero(tinfo, sizeof(*tinfo));
d4476 1
a4476 1
			u_int16_t mask;
d4497 3
d4509 4
d4514 6
d4527 48
a4574 10
			}
			if ((scsirate & WIDEXFER) != 0
			 && (ahc->features & AHC_WIDE) != 0)
				tinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;
		}
		tinfo->goal = tinfo->user; /* force negotiation */
		tstate->ultraenb = ultraenb;
		tstate->discenable = discenable;
		tstate->tagenable = 0; /* Wait until the XPT says its okay */
		tstate->tagdisable = 0;
d4576 1
a4576 3
	ahc->user_discenable = discenable;
	ahc->user_tagenable = tagenable;

d4587 4
a4590 11
	ahc_outb(ahc, SCBID_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, SCBID_ADDR + 3, (physaddr >> 24) & 0xFF);

	/* Target mode incomding command fifo */
	physaddr += 3 * 256 * sizeof(u_int8_t);
	ahc_outb(ahc, TMODE_CMDADDR, physaddr & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, TMODE_CMDADDR + 3, (physaddr >> 24) & 0xFF);
a4610 10
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC)
		printf("DISCENABLE == 0x%x\nULTRAENB == 0x%x\n",
		    discenable, ultraenb);
#endif

	/* Don't have any special messages to send to targets */
	ahc_outb(ahc, TARGET_MSG_REQUEST, 0);
	ahc_outb(ahc, TARGET_MSG_REQUEST + 1, 0);

a4621 1

d4633 1
a4633 1
	 * If we are a target, we'll enable select in operations once
d4637 1
a4637 1
	if ((ahc->flags & AHC_INITIATORMODE) != 0)
d4644 1
a4644 1
         */
d4651 17
a4667 2
	/* We have to wait until after any system dumps... */
	shutdownhook_establish(ahc_shutdown, ahc);
d4671 17
d4689 5
a4693 4
 * Routines to manage a scsi_xfer into the software queue.  
 * We overload xs->free_list to to ensure we don't run into a queue 
 * resource shortage, and keep a pointer to the last entry around 
 * to make insertion O(C).
d4695 2
a4696 5
STATIC INLINE void
ahc_list_insert_before(ahc, xs, next_xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	struct scsi_xfer *next_xs;
d4698 2
a4699 1
	LIST_INSERT_BEFORE(xs, next_xs, free_list); 
d4701 17
d4720 2
a4721 4
STATIC INLINE void
ahc_list_insert_head(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
d4723 62
a4784 5
	if (ahc->sc_xxxq.lh_first == NULL)
		ahc->sc_xxxqlast = xs;
	LIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);
	return;
}
d4786 3
a4788 9
STATIC INLINE void
ahc_list_insert_tail(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	if (ahc->sc_xxxq.lh_first == NULL){
		ahc->sc_xxxqlast = xs;
		LIST_INSERT_HEAD(&ahc->sc_xxxq, xs, free_list);
		return;
a4789 3
	LIST_INSERT_AFTER(ahc->sc_xxxqlast, xs, free_list);
	ahc->sc_xxxqlast = xs;
}
d4791 10
a4800 12
STATIC INLINE void
ahc_list_remove(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
{
	struct scsi_xfer *lxs;
	if (xs == ahc->sc_xxxqlast) {
		lxs = ahc->sc_xxxq.lh_first;
		while (lxs != NULL) {
			if (LIST_NEXT(lxs, free_list) == ahc->sc_xxxqlast) {
                                ahc->sc_xxxqlast = lxs;
				break;
a4801 1
			lxs = LIST_NEXT(xs, free_list);
d4804 2
a4805 4
	
	LIST_REMOVE(xs, free_list);
	if (ahc->sc_xxxq.lh_first == NULL)
		ahc->sc_xxxqlast = NULL;
d4808 2
a4809 4
STATIC INLINE struct scsi_xfer *
ahc_list_next(ahc, xs)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
d4811 76
a4886 1
	return(LIST_NEXT(xs, free_list));
d4889 1
d4891 2
a4892 1
 * Pick the first xs for a non-blocked target.
d4894 2
a4895 2
STATIC INLINE struct scsi_xfer *
ahc_first_xs(struct ahc_softc *ahc)
d4897 2
a4898 2
	int target;
	struct scsi_xfer *xs = ahc->sc_xxxq.lh_first;
d4900 10
a4909 10
	if (ahc->queue_blocked)
        	return NULL;

	while (xs != NULL) {
		target = xs->sc_link->target;
		if (ahc->devqueue_blocked[target] == 0 &&
		    ahc_index_busy_tcl(ahc, XS_TCL(ahc, xs), FALSE) ==
			SCB_LIST_NULL)
			break;
		xs = LIST_NEXT(xs, free_list);
d4912 1
a4912 1
	return xs;
d4915 2
a4916 3
STATIC int32_t
ahc_scsi_cmd(xs)
	struct scsi_xfer *xs;
d4918 1
a4918 12
	struct scsi_xfer *first_xs, *next_xs = NULL;
	struct ahc_softc *ahc;
	struct scb *scb;
	struct hardware_scb *hscb;	
	struct ahc_initiator_tinfo *tinfo;
	struct tmode_tstate *tstate;
	u_int target_id;
	u_int our_id;
	char channel;
	int s, tcl;
	u_int16_t mask;
	int dontqueue = 0, fromqueue = 0;
d4920 12
a4931 2
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("ahc_scsi_cmd\n"));
	ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
d4933 4
a4936 2
	/* must protect the queue */
	s = splbio();
d4938 12
a4949 7
	if (xs == ahc->sc_xxxq.lh_first) {
		/*
		 * Called from ahc_done. Calling with the first entry in
		 * the queue is really just a way of seeing where we're
		 * called from. Now, find the first eligible SCB to send,
		 * e.g. one which will be accepted immediately.
		 */
d4951 9
a4959 4
		if (ahc->queue_blocked) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}
d4961 8
a4968 5
		xs = ahc_first_xs(ahc);
		if (xs == NULL) {
			splx(s);
			return (TRY_AGAIN_LATER);
		}
d4970 13
a4982 4
		next_xs = ahc_list_next(ahc, xs);
		ahc_list_remove(ahc, xs);
		fromqueue = 1;
		goto get_scb;
d4985 2
a4986 8
	/* determine safety of software queueing */
	dontqueue = xs->flags & SCSI_POLL;
	
	/*
	 * If no new requests are accepted, just insert into the
	 * private queue to wait for our turn.
	 */
	tcl = XS_TCL(ahc, xs);
d4988 6
a4993 13
	if (ahc->queue_blocked ||
	    ahc->devqueue_blocked[xs->sc_link->target] ||
	    (!ahc_istagged_device(ahc, xs, 0) &&
	     ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)) {
		if (dontqueue) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return TRY_AGAIN_LATER;
		}
		ahc_list_insert_tail(ahc, xs);
		splx(s);
		return SUCCESSFULLY_QUEUED;
	}
d4995 7
a5001 1
	first_xs = ahc_first_xs(ahc);
d5003 2
a5004 2
	/* determine safety of software queueing */
	dontqueue = xs->flags & SCSI_POLL;
d5006 4
a5009 14
	/*
	 * Handle situations where there's already entries in the
	 * queue.
	 */
	if (first_xs != NULL) {
		/*
		 * If we can't queue, we have to abort, since
		 * we have to preserve order.
		 */
		if (dontqueue) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
d5011 4
a5014 8
		/*
		 * Swap with the first queue entry.
		 */
		ahc_list_insert_tail(ahc, xs);
		xs = first_xs;
		next_xs = ahc_list_next(ahc, xs);
		ahc_list_remove(ahc, xs);
		fromqueue = 1;
d5016 9
d5026 1
d5028 15
a5042 1
get_scb:
d5044 5
a5048 2
	target_id = xs->sc_link->target;
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
d5050 8
a5057 4
	/*
	 * get an scb to use.
	 */
	if ((scb = ahcgetscb(ahc)) == NULL) {
d5059 16
a5074 5
		if (dontqueue) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
		}
d5076 13
d5090 2
a5091 3
		 * If we were pulled off the queue, put ourselves
		 * back to where we came from, otherwise tack ourselves
		 * onto the end.
d5093 1
a5093 7
		if (fromqueue && next_xs != NULL)
			ahc_list_insert_before(ahc, xs, next_xs);
		else
			ahc_list_insert_tail(ahc, xs);

		splx(s);
		return (SUCCESSFULLY_QUEUED);
d5096 6
a5101 1
	tcl = XS_TCL(ahc, xs);
d5103 7
a5109 10
#ifdef DIAGNOSTIC
	if (!ahc_istagged_device(ahc, xs, 0) &&
	    ahc_index_busy_tcl(ahc, tcl, FALSE) != SCB_LIST_NULL)
		panic("ahc: queuing for busy target");
#endif
	
	scb->xs = xs;
	hscb = scb->hscb;
	hscb->tcl = tcl;
	timeout_set(&xs->stimeout, ahc_timeout, scb);
d5111 10
a5120 4
	if (ahc_istagged_device(ahc, xs, 0))
		scb->hscb->control |= MSG_SIMPLE_Q_TAG;
	else
		ahc_busy_tcl(ahc, scb);
d5122 22
a5143 9
	splx(s);
 
	channel = SIM_CHANNEL(ahc, xs->sc_link);
	if (ahc->inited_channels[channel - 'A'] == 0) {
		if ((channel == 'A' && (ahc->flags & AHC_RESET_BUS_A)) ||
		    (channel == 'B' && (ahc->flags & AHC_RESET_BUS_B))) {
			s = splbio();
			ahc_reset_channel(ahc, channel, TRUE);
			splx(s);
d5145 1
a5145 1
		ahc->inited_channels[channel - 'A'] = 1;
d5148 4
a5151 18
	/*
	 * Put all the arguments for the xfer in the scb
	 */

	mask = SCB_TARGET_MASK(scb);
	tinfo = ahc_fetch_transinfo(ahc, SIM_CHANNEL(ahc, xs->sc_link), our_id,
				    target_id, &tstate);
	if (ahc->inited_targets[target_id] == 0) {
		struct ahc_devinfo devinfo;

		s = splbio();
		ahc_compile_devinfo(&devinfo, our_id, target_id,
		    xs->sc_link->lun, SIM_CHANNEL(ahc, xs->sc_link),
		    ROLE_INITIATOR);
		ahc_update_target_msg_request(ahc, &devinfo, tinfo, TRUE,
		    FALSE);
		ahc->inited_targets[target_id] = 1;
		splx(s);
d5154 16
a5169 7
	hscb->scsirate = tinfo->scsirate;
	hscb->scsioffset = tinfo->current.offset;
	if ((tstate->ultraenb & mask) != 0)
		hscb->control |= ULTRAENB;
		
	if ((tstate->discenable & mask) != 0)
		hscb->control |= DISCENB;
d5171 24
a5194 5
	if (xs->flags & SCSI_RESET) {
		hscb->cmdpointer = NULL;
		scb->flags |= SCB_DEVICE_RESET;
		hscb->control |= MK_MESSAGE;
		return ahc_execute_scb(scb, NULL, 0);
d5197 6
a5202 2
	return ahc_setup_data(ahc, xs, scb);
}
d5204 2
a5205 10
STATIC int
ahc_execute_scb(arg, dm_segs, nsegments)
	void *arg;
	bus_dma_segment_t *dm_segs;
	int nsegments;
{
	struct	 scb *scb;
	struct scsi_xfer *xs;
	struct	 ahc_softc *ahc;
	int	 s;
d5207 26
a5232 3
	scb = (struct scb *)arg;
	xs = scb->xs;
	ahc = (struct ahc_softc *)xs->sc_link->adapter_softc;
d5234 24
a5257 20

	if (nsegments != 0) {
		struct ahc_dma_seg *sg;
		bus_dma_segment_t *end_seg;
		int op;

		end_seg = dm_segs + nsegments;

		/* Copy the first SG into the data pointer area */
		scb->hscb->data = dm_segs->ds_addr;
		scb->hscb->datalen = dm_segs->ds_len;

		/* Copy the segments into our SG list */
		sg = scb->sg_list;
		while (dm_segs < end_seg) {
			sg->addr = dm_segs->ds_addr;
			sg->len = dm_segs->ds_len;
			ahc_swap_sg(sg);
			sg++;
			dm_segs++;
a5258 13

		/* Note where to find the SG entries in bus space */
		scb->hscb->SG_pointer = scb->sg_list_phys;
		if ((scb->xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_PREREAD;
		else
			op = BUS_DMASYNC_PREWRITE;
		bus_dmamap_sync(ahc->sc_dmat, scb->dmamap,
		    0, scb->dmamap->dm_mapsize, op);
	} else {
		scb->hscb->SG_pointer = 0;
		scb->hscb->data = 0;
		scb->hscb->datalen = 0;
d5260 1
a5260 4
	
	scb->sg_count = scb->hscb->SG_count = nsegments;

	s = splbio();
d5263 1
a5263 2
	 * Last time we need to check if this SCB needs to
	 * be aborted.
d5265 2
a5266 9
	if (xs->flags & ITSDONE) {
		if (!ahc_istagged_device(ahc, xs, 0))
			ahc_index_busy_tcl(ahc, scb->hscb->tcl, TRUE);
		if (nsegments != 0)
			bus_dmamap_unload(ahc->sc_dmat, scb->dmamap);
		ahcfreescb(ahc, scb);
		splx(s);
		return (COMPLETE);
	}
d5268 2
a5269 4
#ifdef DIAGNOSTIC
	if (scb->sg_count > 255)
		panic("ahc bad sg_count");
#endif
d5271 8
a5278 3
	ahc_swap_hscb(scb->hscb);
		
	LIST_INSERT_HEAD(&ahc->pending_scbs, scb, pend_links);
d5280 3
a5282 1
	scb->flags |= SCB_ACTIVE;
d5284 3
a5286 2
	if (!(xs->flags & SCSI_POLL))
		timeout_add(&xs->stimeout, (xs->timeout * hz) / 1000);
d5288 2
a5289 13
	if ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {
#if 0
		printf("Continueing Immediate Command %d:%d\n",
		       xs->sc_link->target,
		       xs->sc_link->lun);
#endif
		pause_sequencer(ahc);
		if ((ahc->flags & AHC_PAGESCBS) == 0)
			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
		ahc_outb(ahc, SCB_TAG, scb->hscb->tag);
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
		unpause_sequencer(ahc);
	} else {
d5291 11
a5301 1
		ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;
d5303 32
a5334 9
		bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
		    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
		
		if ((ahc->features & AHC_QUEUE_REGS) != 0) {
			ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
		} else {
			pause_sequencer(ahc);
			ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
			unpause_sequencer(ahc);
d5338 4
a5341 10
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWCMDS) {
		sc_print_addr(xs->sc_link);
		printf("opcode %d tag %x len %d flags %x control %x fpos %u"
		    " rate %x\n",
		    xs->cmdstore.opcode, scb->hscb->tag, scb->hscb->datalen,
		    scb->flags, scb->hscb->control, ahc->qinfifonext,
		    scb->hscb->scsirate);
	}
#endif
d5343 10
a5352 19
	if (!(xs->flags & SCSI_POLL)) {
		splx(s);
		return (SUCCESSFULLY_QUEUED);
	}
	/*
	 * If we can't use interrupts, poll for completion
	 */
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("cmd_poll\n"));
	do {
		if (ahc_poll(ahc, xs->timeout)) {
			if (!(xs->flags & SCSI_SILENT))
				printf("cmd fail\n");
			ahc_timeout(scb);
			break;
		}
	} while (!(xs->flags & ITSDONE));
	splx(s);
	return (COMPLETE);
}
d5354 3
a5356 10
STATIC int
ahc_poll(ahc, wait)
	struct   ahc_softc *ahc;
	int   wait;	/* in msec */
{
	while (--wait) {
		DELAY(1000);
		if (ahc_inb(ahc, INTSTAT) & INT_PEND)
			break;
	}
d5358 6
a5363 8
	if (wait == 0) {
		printf("%s: board is not responding\n", ahc_name(ahc));
		return (EIO);
	}
		
	ahc_intr((void *)ahc);
	return (0);
}
d5365 2
a5366 14
STATIC int
ahc_setup_data(ahc, xs, scb)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	struct scb *scb;
{
	struct hardware_scb *hscb;
	
	hscb = scb->hscb;
	xs->resid = xs->status = 0;
	
	hscb->cmdlen = xs->cmdlen;
	bcopy(xs->cmd, hscb->cmdstore, xs->cmdlen);
	hscb->cmdpointer = hscb->cmdstore_busaddr;
d5368 9
a5376 3
	/* Only use S/G if there is a transfer */
	if (xs->datalen) {
		int error;
d5378 22
a5399 16
		error = bus_dmamap_load(ahc->sc_dmat,
			    scb->dmamap, xs->data,
			    xs->datalen, NULL,
			    (xs->flags & SCSI_NOSLEEP) ?
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			if (!ahc_istagged_device(ahc, xs, 0))
				ahc_index_busy_tcl(ahc, hscb->tcl, TRUE);
			return (TRY_AGAIN_LATER);	/* XXX fvdl */
		}
		error = ahc_execute_scb(scb,
		    scb->dmamap->dm_segs,
		    scb->dmamap->dm_nsegs);
		return error;
	} else {
		return ahc_execute_scb(scb, NULL, 0);
d5401 3
d5406 6
a5411 4
STATIC void
ahc_freeze_devq(ahc, sc_link)
	struct ahc_softc *ahc;
	struct scsi_link *sc_link;
d5413 1
a5413 3
	int	target;
	char	channel;
	int	lun;
d5415 2
a5416 8
	target = sc_link->target;
	lun = sc_link->lun;
	channel = SIM_CHANNEL(ahc, sc_link);
	
	ahc_search_qinfifo(ahc, target, channel, lun,
			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
			   SCB_REQUEUE, SEARCH_COMPLETE);
}
d5418 1
a5418 12
STATIC void
ahcallocscbs(ahc)
	struct ahc_softc *ahc;
{
	struct scb_data *scb_data;
	struct scb *next_scb;
	struct sg_map_node *sg_map;
	bus_addr_t physaddr;
	struct ahc_dma_seg *segs;
	int newcount;
	int i;
	int dma_flags = 0;
d5420 1
a5420 4
	scb_data = ahc->scb_data;
	if (scb_data->numscbs >= AHC_SCB_MAX)
		/* Can't allocate any more */
		return;
d5422 5
a5426 1
	next_scb = &scb_data->scbarray[scb_data->numscbs];
d5428 1
a5428 55
	sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);

	if (sg_map == NULL)
		return;
	bzero(sg_map, sizeof(struct sg_map_node));
	
	if (ahc_createdmamem(ahc, PAGE_SIZE, &sg_map->sg_dmamap,
	    (caddr_t *)&sg_map->sg_vaddr, &sg_map->sg_physaddr,
	    &sg_map->sg_dmasegs, &sg_map->sg_nseg, "SG space") < 0) {
		free(sg_map, M_DEVBUF);
		return;
	}
	
	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);

	segs = sg_map->sg_vaddr;
	physaddr = sg_map->sg_physaddr;

	newcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));

	for (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {
		int error;

		next_scb->sg_list = segs;
		/*
		 * The sequencer always starts with the second entry.
		 * The first entry is embedded in the scb.
		 */
		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
		next_scb->flags = SCB_FREE;
		
		/* set up AHA-284x right. */
		dma_flags = ((ahc->chip & AHC_VL) !=0) ? 
			BUS_DMA_NOWAIT|ISABUS_DMA_32BIT :
			BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW;
		
		error = bus_dmamap_create(ahc->sc_dmat,
				 AHC_MAXTRANSFER_SIZE, AHC_NSEG, MAXBSIZE, 0,
				 dma_flags, &next_scb->dmamap);
		if (error !=0) 
			break;

		next_scb->hscb = &scb_data->hscbs[scb_data->numscbs];
		next_scb->hscb->tag = ahc->scb_data->numscbs;
		next_scb->hscb->cmdstore_busaddr = 
		    ahc_hscb_busaddr(ahc, next_scb->hscb->tag)
		  + offsetof(struct hardware_scb, cmdstore);
		next_scb->hscb->cmdstore_busaddr =
		    htole32(next_scb->hscb->cmdstore_busaddr);
		SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs, next_scb, links);
		segs += AHC_NSEG;
		physaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));
		next_scb++;
		ahc->scb_data->numscbs++;
	}
d5431 7
a5437 4
#ifdef AHC_DUMP_SEQ
STATIC void
ahc_dumpseq(ahc)
	struct ahc_softc* ahc;
d5439 5
a5443 15
	int i;
	int max_prog;

	if ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)
		max_prog = 448;
	else if ((ahc->features & AHC_ULTRA2) != 0)
		max_prog = 768;
	else
		max_prog = 512;

	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	for (i = 0; i < max_prog; i++) {
		u_int8_t ins_bytes[4];
d5445 3
a5447 5
		ahc_insb(ahc, SEQRAM, ins_bytes, 4);
		printf("0x%08x\n", ins_bytes[0] << 24
				 | ins_bytes[1] << 16
				 | ins_bytes[2] << 8
				 | ins_bytes[3]);
a5449 1
#endif
d5451 8
a5458 9
STATIC void
ahc_loadseq(ahc)
	struct ahc_softc* ahc;
{
	struct patch *cur_patch;
	int i;
	int downloaded;
	int skip_addr;
	u_int8_t download_consts[4];
d5460 7
a5466 5
	/* Setup downloadable constant table */
#if 0
	/* No downloaded constants are currently defined. */
	download_consts[TMODE_NUMCMDS] = ahc->num_targetcmds;
#endif
d5468 2
a5469 6
	cur_patch = patches;
	downloaded = 0;
	skip_addr = 0;
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
d5471 1
a5471 13
	for (i = 0; i < sizeof(seqprog)/4; i++) {
		if (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {
			/*
			 * Don't download this instruction as it
			 * is in a patch that was removed.
			 */
                        continue;
		}
		ahc_download_instr(ahc, i, download_consts);
		downloaded++;
	}
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);
	restart_sequencer(ahc);
d5473 4
a5476 3
	if (bootverbose)
		printf(" %d instructions downloaded\n", downloaded);
}
d5478 12
a5489 29
STATIC int
ahc_check_patch(ahc, start_patch, start_instr,skip_addr)
	struct ahc_softc *ahc;
	struct patch **start_patch;
	int start_instr;
	int *skip_addr;
{
	struct	patch *cur_patch;
	struct	patch *last_patch;
	int	num_patches;

	num_patches = sizeof(patches)/sizeof(struct patch);
	last_patch = &patches[num_patches];
	cur_patch = *start_patch;

	while (cur_patch < last_patch && start_instr == cur_patch->begin) {

		if (cur_patch->patch_func(ahc) == 0) {

			/* Start rejecting code */
			*skip_addr = start_instr + cur_patch->skip_instr;
			cur_patch += cur_patch->skip_patch;
		} else {
			/* Accepted this patch.  Advance to the next
			 * one and wait for our intruction pointer to
			 * hit this point.
			 */
			cur_patch++;
		}
d5492 5
a5496 6
	*start_patch = cur_patch;
	if (start_instr < *skip_addr)
		/* Still skipping */
		return (0);

	return (1);
d5499 10
a5508 5
STATIC void
ahc_download_instr(ahc, instrptr, dconsts)
	struct ahc_softc *ahc;
	int instrptr;
	u_int8_t *dconsts;
d5510 15
a5524 4
	union	ins_formats instr;
	struct	ins_format1 *fmt1_ins;
	struct	ins_format3 *fmt3_ins;
	u_int	opcode;
d5526 2
a5527 2
	/* Structure copy */
	instr = *(union ins_formats*)&seqprog[instrptr * 4];
d5529 2
a5530 1
	instr.integer = le32toh(instr.integer);
d5532 11
a5542 2
	fmt1_ins = &instr.format1;
	fmt3_ins = NULL;
d5544 1
a5544 17
	/* Pull the opcode */
	opcode = instr.format1.opcode;
	switch (opcode) {
	case AIC_OP_JMP:
	case AIC_OP_JC:
	case AIC_OP_JNC:
	case AIC_OP_CALL:
	case AIC_OP_JNE:
	case AIC_OP_JNZ:
	case AIC_OP_JE:
	case AIC_OP_JZ:
	{
		struct patch *cur_patch;
		int address_offset;
		u_int address;
		int skip_addr;
		int i;
d5546 14
a5559 5
		fmt3_ins = &instr.format3;
		address_offset = 0;
		address = fmt3_ins->address;
		cur_patch = patches;
		skip_addr = 0;
d5561 4
a5564 1
		for (i = 0; i < address;) {
d5566 9
a5574 1
			ahc_check_patch(ahc, &cur_patch, i, &skip_addr);
d5576 6
a5581 2
			if (skip_addr > i) {
				int end_addr;
d5583 6
a5588 10
				end_addr = MIN(address, skip_addr);
				address_offset += end_addr - i;
				i = skip_addr;
			} else {
				i++;
			}
		}
		address -= address_offset;
		fmt3_ins->address = address;
		/* FALLTHROUGH */
a5589 14
	case AIC_OP_OR:
	case AIC_OP_AND:
	case AIC_OP_XOR:
	case AIC_OP_ADD:
	case AIC_OP_ADC:
	case AIC_OP_BMOV:
		if (fmt1_ins->parity != 0) {
			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
		}
		fmt1_ins->parity = 0;
		/* FALLTHROUGH */
	case AIC_OP_ROL:
		if ((ahc->features & AHC_ULTRA2) != 0) {
			int i, count;
d5591 22
a5612 26
			/* Calculate odd parity for the instruction */
			for (i = 0, count = 0; i < 31; i++) {
				u_int32_t mask;

				mask = 0x01 << i;
				if ((instr.integer & mask) != 0)
					count++;
			}
			if ((count & 0x01) == 0)
				instr.format1.parity = 1;
		} else {
			/* Compress the instruction for older sequencers */
			if (fmt3_ins != NULL) {
				instr.integer =
					fmt3_ins->immediate
				      | (fmt3_ins->source << 8)
				      | (fmt3_ins->address << 16)
				      |	(fmt3_ins->opcode << 25);
			} else {
				instr.integer =
					fmt1_ins->immediate
				      | (fmt1_ins->source << 8)
				      | (fmt1_ins->destination << 16)
				      |	(fmt1_ins->ret << 24)
				      |	(fmt1_ins->opcode << 25);
			}
a5613 6
		instr.integer = htole32(instr.integer);
		ahc_outsb(ahc, SEQRAM, instr.bytes, 4);
		break;
	default:
		panic("Unknown opcode encountered in seq program");
		break;
d5615 4
d5621 2
a5622 4
STATIC void
ahc_set_recoveryscb(ahc, scb)
	struct ahc_softc *ahc;
	struct scb *scb;
d5624 1
d5626 6
a5631 2
	if ((scb->flags & SCB_RECOVERY_SCB) == 0) {
		struct scb *scbp;
d5633 1
a5633 1
		scb->flags |= SCB_RECOVERY_SCB;
d5635 2
a5636 18
		/*
		 * Take all queued, but not sent SCBs out of the equation.
		 * Also ensure that no new CCBs are queued to us while we
		 * try to fix this problem.
		 */
		ahc->queue_blocked = 1;

		/*
		 * Go through all of our pending SCBs and remove
		 * any scheduled timeouts for them.  We will reschedule
		 * them after we've successfully fixed this problem.
		 */
		scbp = ahc->pending_scbs.lh_first;
		while (scbp != NULL) {
			timeout_del(&scbp->xs->stimeout);
			scbp = scbp->pend_links.le_next;
		}
	}
d5639 2
a5640 2
STATIC void
ahc_timeout(void *arg)
d5642 10
a5651 8
	struct	scb *scb;
	struct	ahc_softc *ahc;
	int	s, found;
	u_int	last_phase;
	int	target;
	int	lun;
	int	i;
	char	channel;
d5653 6
a5658 2
	scb = (struct scb *)arg; 
	ahc = (struct ahc_softc *)scb->xs->sc_link->adapter_softc;
d5660 2
a5661 1
	s = splbio();
d5664 3
a5666 4
	 * Ensure that the card doesn't do anything
	 * behind our back.  Also make sure that we
	 * didn't "just" miss an interrupt that would
	 * affect this timeout.
d5668 4
a5671 11
	do {
		ahc_intr(ahc);
		pause_sequencer(ahc);
	} while (ahc_inb(ahc, INTSTAT) & INT_PEND);

	if ((scb->flags & SCB_ACTIVE) == 0) {
		/* Previous timeout took care of me already */
		printf("Timedout SCB handled by another timeout\n");
		unpause_sequencer(ahc);
		splx(s);
		return;
d5673 1
a5674 6
	target = SCB_TARGET(scb);
	channel = SCB_CHANNEL(scb);
	lun = SCB_LUN(scb);

	sc_print_addr(scb->xs->sc_link);
	printf("SCB 0x%x - timed out ", scb->hscb->tag);
d5676 1
a5676 2
	 * Take a snapshot of the bus state and print out
	 * some information so we can track down driver bugs.
d5678 18
a5695 40
	last_phase = ahc_inb(ahc, LASTPHASE);

	for (i = 0; i < num_phases; i++) {
		if (last_phase == phase_table[i].phase)
			break;
	}
	printf("%s", phase_table[i].phasemsg);
  
	printf(", SEQADDR == 0x%x\n",
	       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
#if 0
	printf("SSTAT1 == 0x%x\n", ahc_inb(ahc, SSTAT1));
	printf("SSTAT3 == 0x%x\n", ahc_inb(ahc, SSTAT3));
	printf("SCSIPHASE == 0x%x\n", ahc_inb(ahc, SCSIPHASE));
	printf("SCSIRATE == 0x%x\n", ahc_inb(ahc, SCSIRATE));
	printf("SCSIOFFSET == 0x%x\n", ahc_inb(ahc, SCSIOFFSET));
	printf("SEQ_FLAGS == 0x%x\n", ahc_inb(ahc, SEQ_FLAGS));
	printf("SCB_DATAPTR == 0x%x\n", ahc_inb(ahc, SCB_DATAPTR)
				      | ahc_inb(ahc, SCB_DATAPTR + 1) << 8
				      | ahc_inb(ahc, SCB_DATAPTR + 2) << 16
				      | ahc_inb(ahc, SCB_DATAPTR + 3) << 24);
	printf("SCB_DATACNT == 0x%x\n", ahc_inb(ahc, SCB_DATACNT)
				      | ahc_inb(ahc, SCB_DATACNT + 1) << 8
				      | ahc_inb(ahc, SCB_DATACNT + 2) << 16);
	printf("SCB_SGCOUNT == 0x%x\n", ahc_inb(ahc, SCB_SGCOUNT));
	printf("CCSCBCTL == 0x%x\n", ahc_inb(ahc, CCSCBCTL));
	printf("CCSCBCNT == 0x%x\n", ahc_inb(ahc, CCSCBCNT));
	printf("DFCNTRL == 0x%x\n", ahc_inb(ahc, DFCNTRL));
	printf("DFSTATUS == 0x%x\n", ahc_inb(ahc, DFSTATUS));
	printf("CCHCNT == 0x%x\n", ahc_inb(ahc, CCHCNT));
	if (scb->sg_count > 0) {
		for (i = 0; i < scb->sg_count; i++) {
			printf("sg[%d] - Addr 0x%x : Length %d\n",
			       i,
			       le32toh(scb->sg_list[i].addr),
			       le32toh(scb->sg_list[i].len));
		}
	}
#endif
	if (scb->flags & (SCB_DEVICE_RESET|SCB_ABORT)) {
d5697 3
a5699 2
		 * Been down this road before.
		 * Do a full bus reset.
d5701 6
a5706 5
bus_reset:
		ahcsetccbstatus(scb->xs, XS_TIMEOUT);
		found = ahc_reset_channel(ahc, channel, /*Initiate Reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), channel, found);
d5708 8
d5717 3
a5719 20
		 * If we are a target, transition to bus free and report
		 * the timeout.
		 * 
		 * The target/initiator that is holding up the bus may not
		 * be the same as the one that triggered this timeout
		 * (different commands have different timeout lengths).
		 * If the bus is idle and we are actiing as the initiator
		 * for this request, queue a BDR message to the timed out
		 * target.  Otherwise, if the timed out transaction is
		 * active:
		 *   Initiator transaction:
		 *	Stuff the message buffer with a BDR message and assert
		 *	ATN in the hopes that the target will let go of the bus
		 *	and go to the mesgout phase.  If this fails, we'll
		 *	get another timeout 2 seconds later which will attempt
		 *	a bus reset.
		 *
		 *   Target transaction:
		 *	Transition to BUS FREE and report the error.
		 *	It's good to be the target!
d5721 6
a5726 59
		u_int active_scb_index;

		active_scb_index = ahc_inb(ahc, SCB_TAG);

		if (last_phase != P_BUSFREE 
		  && (active_scb_index < ahc->scb_data->numscbs)) {
			struct scb *active_scb;

			/*
			 * If the active SCB is not from our device,
			 * assume that another device is hogging the bus
			 * and wait for it's timeout to expire before
			 * taking additional action.
			 */ 
			active_scb = &ahc->scb_data->scbarray[active_scb_index];
			if (active_scb->hscb->tcl != scb->hscb->tcl) {
				u_int	newtimeout;

				sc_print_addr(scb->xs->sc_link);
				printf("Other SCB Timeout%s",
			 	       (scb->flags & SCB_OTHERTCL_TIMEOUT) != 0
				       ? " again\n" : "\n");
				scb->flags |= SCB_OTHERTCL_TIMEOUT;
				newtimeout = MAX(active_scb->xs->timeout,
						 scb->xs->timeout);
				timeout_add(&scb->xs->stimeout,
				    (newtimeout * hz) / 1000);
				splx(s);
				return;
			} 

			/* It's us */
			if ((scb->hscb->control & TARGET_SCB) != 0) {

				/*
				 * Send back any queued up transactions
				 * and properly record the error condition.
				 */
				ahc_freeze_devq(ahc, scb->xs->sc_link);
				ahcsetccbstatus(scb->xs, XS_TIMEOUT);
				ahc_freeze_ccb(scb);
				ahc_done(ahc, scb);

				/* Will clear us from the bus */
				restart_sequencer(ahc);
				splx(s);
				return;
			} 

			ahc_set_recoveryscb(ahc, active_scb);
			ahc_outb(ahc, MSG_OUT, MSG_BUS_DEV_RESET);
			ahc_outb(ahc, SCSISIGO, last_phase|ATNO);
			sc_print_addr(active_scb->xs->sc_link);
			printf("BDR message in message buffer\n");
			active_scb->flags |=  SCB_DEVICE_RESET;
			timeout_add(&active_scb->xs->stimeout, 2 * hz);
			unpause_sequencer(ahc);
		} else {
			int	 disconnected;
d5728 7
a5734 14
			/* XXX Shouldn't panic.  Just punt instead */
			if ((scb->hscb->control & TARGET_SCB) != 0)
				panic("Timed-out target SCB but bus idle");

			if (last_phase != P_BUSFREE
			 && (ahc_inb(ahc, SSTAT0) & TARGET) != 0) {
				/* XXX What happened to the SCB? */
				/* Hung target selection.  Goto busfree */
				printf("%s: Hung target selection\n",
				       ahc_name(ahc));
				restart_sequencer(ahc);
				splx(s);
				return;
			}
d5736 1
a5736 7
			if (ahc_search_qinfifo(ahc, target, channel, lun,
					       scb->hscb->tag, ROLE_INITIATOR,
					       /*status*/0, SEARCH_COUNT) > 0) {
				disconnected = FALSE;
			} else {
				disconnected = TRUE;
			}
d5738 8
a5745 2
			if (disconnected) {
				u_int active_scb;
d5747 5
a5751 7
				ahc_set_recoveryscb(ahc, scb);
				/*
				 * Simply set the MK_MESSAGE control bit.
				 */
				scb->hscb->control |= MK_MESSAGE;
				scb->flags |= SCB_QUEUED_MSG
					   |  SCB_DEVICE_RESET;
d5753 3
a5755 21
				/*
				 * Mark the cached copy of this SCB in the
				 * disconnected list too, so that a reconnect
				 * at this point causes a BDR or abort.
				 */
				active_scb = ahc_inb(ahc, SCBPTR);
				if (ahc_search_disc_list(ahc, target,
							 channel, lun,
							 scb->hscb->tag,
							 /*stop_on_first*/TRUE,
							 /*remove*/FALSE,
							 /*save_state*/FALSE)) {
					u_int scb_control;

					scb_control = ahc_inb(ahc, SCB_CONTROL);
					scb_control |= MK_MESSAGE;
					ahc_outb(ahc, SCB_CONTROL, scb_control);
				}
				ahc_outb(ahc, SCBPTR, active_scb);
				ahc_index_busy_tcl(ahc, scb->hscb->tcl,
						   /*unbusy*/TRUE);
d5757 3
a5759 42
				/*
				 * Actually re-queue this SCB in case we can
				 * select the device before it reconnects.
				 * Clear out any entries in the QINFIFO first
				 * so we are the next SCB for this target
				 * to run.
				 */
				ahc_search_qinfifo(ahc, SCB_TARGET(scb),
						   channel, SCB_LUN(scb),
						   SCB_LIST_NULL,
						   ROLE_INITIATOR,
						   SCB_REQUEUE,
						   SEARCH_COMPLETE);
				sc_print_addr(scb->xs->sc_link);
				printf("Queuing a BDR SCB\n");
				ahc->qinfifo[ahc->qinfifonext++] =
				    scb->hscb->tag;

				bus_dmamap_sync(ahc->sc_dmat,
				    ahc->shared_data_dmamap,
				    QINFIFO_OFFSET * 256, 256,
				    BUS_DMASYNC_PREWRITE);

				if ((ahc->features & AHC_QUEUE_REGS) != 0) {
					ahc_outb(ahc, HNSCB_QOFF,
						 ahc->qinfifonext);
				} else {
					ahc_outb(ahc, KERNEL_QINPOS,
						 ahc->qinfifonext);
				}
				timeout_add(&scb->xs->stimeout, 2 * hz);
				unpause_sequencer(ahc);
			} else {
				/* Go "immediatly" to the bus reset */
				/* This shouldn't happen */
				ahc_set_recoveryscb(ahc, scb);
				sc_print_addr(scb->xs->sc_link);
				printf("SCB %d: Immediate reset.  "
					"Flags = 0x%x\n", scb->hscb->tag,
					scb->flags);
				goto bus_reset;
			}
d5762 4
a5765 22
	splx(s);
}

STATIC int
ahc_search_qinfifo(ahc, target, channel, lun, tag, role, status, action)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	role_t role;
	u_int32_t status;
	ahc_search_action action;
{
	struct	 scb *scbp;
	u_int8_t qinpos;
	u_int8_t qintail;
	int	 found;

	qinpos = ahc_inb(ahc, QINPOS);
	qintail = ahc->qinfifonext;
	found = 0;
d5768 1
a5768 2
	 * Start with an empty queue.  Entries that are not chosen
	 * for removal will be re-added to the queue as we go.
d5770 6
a5775 3
	ahc->qinfifonext = qinpos;
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_POSTREAD);
d5777 9
a5785 25
	while (qinpos != qintail) {
		scbp = &ahc->scb_data->scbarray[ahc->qinfifo[qinpos]];
		if (ahc_match_scb(scbp, target, channel, lun, tag, role)) {
			/*
			 * We found an scb that needs to be removed.
			 */
			switch (action) {
			case SEARCH_COMPLETE:
				if (!(scbp->xs->flags & ITSDONE)) {
					scbp->flags |= status;
					scbp->xs->error = XS_NOERROR;
				}
				ahc_freeze_ccb(scbp);
				ahc_done(ahc, scbp);
				break;
			case SEARCH_COUNT:
				ahc->qinfifo[ahc->qinfifonext++] =
				    scbp->hscb->tag;
				break;
			case SEARCH_REMOVE:
				break;
			}
			found++;
		} else {
			ahc->qinfifo[ahc->qinfifonext++] = scbp->hscb->tag;
a5786 9
		qinpos++;
	}
	bus_dmamap_sync(ahc->sc_dmat, ahc->shared_data_dmamap, 
	    QINFIFO_OFFSET * 256, 256, BUS_DMASYNC_PREWRITE);
	
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
d5789 5
a5793 1
	return (found);
d5796 2
d5799 1
a5799 4
 * Abort all SCBs that match the given description (target/channel/lun/tag),
 * setting their status to the passed in status if the status has not already
 * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
 * is paused before it is called.
d5801 2
a5802 9
STATIC int
ahc_abort_scbs(ahc, target, channel, lun, tag, role, status)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	role_t role;
	u_int32_t status;
d5804 21
a5824 4
	struct	scb *scbp;
	u_int	active_scb;
	int	i;
	int	found;
d5826 6
a5831 2
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
d5833 3
a5835 2
	found = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,
				   role, SCB_REQUEUE, SEARCH_COMPLETE);
d5837 12
a5848 8
	/*
	 * Search waiting for selection list.
	 */
	{
		u_int8_t next, prev;
                /* Start at head of list. */
		next = ahc_inb(ahc, WAITING_SCBH);
		prev = SCB_LIST_NULL;
d5850 6
a5855 2
		while (next != SCB_LIST_NULL) {
			u_int8_t scb_index;
d5857 2
a5858 10
			ahc_outb(ahc, SCBPTR, next);
			scb_index = ahc_inb(ahc, SCB_TAG);
			if (scb_index >= ahc->scb_data->numscbs) {
				panic("Waiting List inconsistency. "
				      "SCB index == %d, yet numscbs == %d.",
				      scb_index, ahc->scb_data->numscbs);
			}
			scbp = &ahc->scb_data->scbarray[scb_index];
			if (ahc_match_scb(scbp, target, channel,
					  lun, SCB_LIST_NULL, role)) {
d5860 8
a5867 6
				next = ahc_abort_wscb(ahc, next, prev);
			} else {
				
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
			}
d5870 12
a5881 9
	/*
	 * Go through the disconnected list and remove any entries we
	 * have queued for completion, 0'ing their control byte too.
	 * We save the active SCB and restore it ourselves, so there
	 * is no reason for this search to restore it too.
	 */
	ahc_search_disc_list(ahc, target, channel, lun, tag,
			     /*stop_on_first*/FALSE, /*remove*/TRUE,
			     /*save_state*/FALSE);
d5883 18
a5900 6
	/*
	 * Go through the hardware SCB array looking for commands that
	 * were active but not on any list.
	 */
	for(i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scbid;
d5902 32
a5933 7
		ahc_outb(ahc, SCBPTR, i);
		scbid = ahc_inb(ahc, SCB_TAG);
		scbp = &ahc->scb_data->scbarray[scbid];
		if (scbid < ahc->scb_data->numscbs && 
			 ahc_match_scb(scbp, target, channel, lun, tag, role))
				ahc_add_curscb_to_free_list(ahc);
	}
d5935 9
a5943 8
	/*
	 * Go through the pending CCB list and look for
	 * commands for this target that are still active.
	 * These are other tagged commands that were
	 * disconnected when the reset occurred.
	 */
	{
		struct scb *scb;
d5945 16
a5960 12
		scb = ahc->pending_scbs.lh_first;
		while (scb != NULL) {
			scbp = scb;
			scb = scb->pend_links.le_next;
			if (ahc_match_scb(scbp, target, channel,
					  lun, tag, role)) {
				if (!(scbp->xs->flags & ITSDONE))
					ahcsetccbstatus(scbp->xs, status);
				ahc_freeze_ccb(scbp);
				ahc_done(ahc, scbp);
				found++;
			}
d5962 6
a5968 2
	ahc_outb(ahc, SCBPTR, active_scb);
	return found;
d5970 3
d5974 3
a5976 11
STATIC int
ahc_search_disc_list(ahc, target, channel, lun, tag, stop_on_first, 
		     remove, save_state)
	struct ahc_softc *ahc;
	int target;
	char channel;
	int lun;
	u_int tag;
	int stop_on_first;
	int remove;
	int save_state;
d5978 24
a6001 5
	struct	scb *scbp;
	u_int	next;
	u_int	prev;
	u_int	count;
	u_int	active_scb;
d6003 23
a6025 3
	count = 0;
	next = ahc_inb(ahc, DISCONNECTED_SCBH);
	prev = SCB_LIST_NULL;
d6027 13
a6039 6
	if (save_state) {
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
	} else
		/* Silence compiler */
		active_scb = SCB_LIST_NULL;
d6041 6
a6046 2
	while (next != SCB_LIST_NULL) {
		u_int scb_index;
d6048 7
a6054 6
		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			panic("Disconnected List inconsistency. "
			      "SCB index == %d, yet numscbs == %d.",
			      scb_index, ahc->scb_data->numscbs);
d6056 18
a6073 10
		scbp = &ahc->scb_data->scbarray[scb_index];
		if (ahc_match_scb(scbp, target, channel, lun,
				  tag, ROLE_INITIATOR)) {
			count++;
			if (remove) {
				next =
				    ahc_rem_scb_from_disc_list(ahc, prev, next);
			} else {
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
d6075 1
a6075 5
			if (stop_on_first)
				break;
		} else {
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
d6077 12
d6090 5
a6094 3
	if (save_state)
	ahc_outb(ahc, SCBPTR, active_scb);
	return (count);
d6097 3
a6099 5
STATIC u_int
ahc_rem_scb_from_disc_list(ahc, prev, scbptr)
	struct ahc_softc *ahc;
	u_int prev;
	u_int scbptr;
d6101 7
a6107 1
	u_int next;
d6109 1
a6109 2
	ahc_outb(ahc, SCBPTR, scbptr);
	next = ahc_inb(ahc, SCB_NEXT);
d6111 1
a6111 1
	ahc_outb(ahc, SCB_CONTROL, 0);
d6113 11
a6123 1
	ahc_add_curscb_to_free_list(ahc);
d6125 4
a6128 5
	if (prev != SCB_LIST_NULL) {
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	} else
		ahc_outb(ahc, DISCONNECTED_SCBH, next);
d6130 1
a6130 1
	return (next);
d6133 2
a6134 3
STATIC void
ahc_add_curscb_to_free_list(ahc)
	struct ahc_softc *ahc;
d6136 4
a6139 18
	/* Invalidate the tag so that ahc_find_scb doesn't think it's active */
	ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);

	ahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));
	ahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));
}

/*
 * Manipulate the waiting for selection list and return the
 * scb that follows the one that we remove.
 */
STATIC u_int
ahc_abort_wscb(ahc, scbpos, prev)
	struct ahc_softc *ahc;
	u_int scbpos;
        u_int prev;
{       
	u_int curscb, next;
d6142 1
a6142 2
	 * Select the SCB we want to abort and
	 * pull the next pointer out of it.
d6144 1
a6144 3
	curscb = ahc_inb(ahc, SCBPTR);
	ahc_outb(ahc, SCBPTR, scbpos);
	next = ahc_inb(ahc, SCB_NEXT);
d6146 2
a6147 2
	/* Clear the necessary fields */
	ahc_outb(ahc, SCB_CONTROL, 0);
d6149 17
a6165 1
	ahc_add_curscb_to_free_list(ahc);
d6167 5
a6171 4
	/* update the waiting list */
	if (prev == SCB_LIST_NULL) {
		/* First in the list */
		ahc_outb(ahc, WAITING_SCBH, next); 
d6173 1
a6173 13
		/*
		 * Ensure we aren't attempting to perform
		 * selection for this entry.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else {
		/*
		 * Select the scb that pointed to us 
		 * and update its next pointer.
		 */
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	}
d6175 1
a6175 6
	/*
	 * Point us back at the original scb position.
	 */
	ahc_outb(ahc, SCBPTR, curscb);
	return next;
}
d6177 2
a6178 11
STATIC void
ahc_clear_intstat(ahc)
	struct ahc_softc *ahc;
{
	/* Clear any interrupt conditions this may have caused */
	ahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);
	ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
				|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|
				CLRREQINIT);
	ahc_outb(ahc, CLRINT, CLRSCSIINT);
}
d6180 40
a6219 5
STATIC void
ahc_reset_current_bus(ahc)
	struct ahc_softc *ahc;
{
	u_int8_t scsiseq;
d6221 3
a6223 6
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);
	scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);
	DELAY(AHC_BUSRESET_DELAY);
	/* Turn off the bus reset */
	ahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);
d6225 31
a6255 4
	ahc_clear_intstat(ahc);

	/* Re-enable reset interrupts */
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);
d6258 2
a6259 5
STATIC int
ahc_reset_channel(ahc, channel, initiate_reset)
	struct ahc_softc *ahc;
	char channel;
	int initiate_reset;
d6261 11
a6271 6
	u_int	initiator, target, max_scsiid;
	u_int	sblkctl;
	u_int	our_id;
	int	found;
	int	restart_needed;
	char	cur_channel;
d6273 1
a6273 1
	ahc->pending_device = NULL;
d6275 39
a6313 40
	pause_sequencer(ahc);

	/*
	 * Run our command complete fifos to ensure that we perform
	 * completion processing on any commands that 'completed'
	 * before the reset occurred.
	 */
	ahc_run_qoutfifo(ahc);

	/*
	 * Reset the bus if we are initiating this reset
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	cur_channel = 'A';
	if ((ahc->features & AHC_TWIN) != 0
	 && ((sblkctl & SELBUSB) != 0))
	    cur_channel = 'B';
	if (cur_channel != channel) {
		/* Case 1: Command for another bus is active
		 * Stealthily reset the other bus without
		 * upsetting the current bus.
		 */
		ahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
		ahc_outb(ahc, SBLKCTL, sblkctl);
		restart_needed = FALSE;
	} else {
		/* Case 2: A command from this bus is active or we're idle */
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
d6315 17
a6331 11
		/*
		 * Since we are going to restart the sequencer, avoid
		 * a race in the sequencer that could cause corruption
		 * of our Q pointers by starting over from index 0.
		 */
		ahc->qoutfifonext = 0;
		if ((ahc->features & AHC_QUEUE_REGS) != 0)
			ahc_outb(ahc, SDSCB_QOFF, 0);
		else
			ahc_outb(ahc, QOUTPOS, 0);
		restart_needed = TRUE;
d6333 35
a6367 12

	/*
	 * Clean up all the state information for the
	 * pending transactions on this bus.
	 */
	found = ahc_abort_scbs(ahc, ALL_TARGETS, channel,
			       ALL_LUNS, SCB_LIST_NULL,
			       ROLE_UNKNOWN, XS_RESET);
	if (channel == 'B') {
		our_id = ahc->our_id_b;
	} else {
		our_id = ahc->our_id;
d6369 1
d6371 8
a6378 6
	max_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;
	
	/*
	 * Revert to async/narrow transfers until we renegotiate.
	 */
	for (target = 0; target <= max_scsiid; target++) {
d6380 4
a6383 1
		if (ahc->enabled_targets[target] == NULL)
d6385 6
a6390 16
		for (initiator = 0; initiator <= max_scsiid; initiator++) {
			struct ahc_devinfo devinfo;

			ahc_compile_devinfo(&devinfo, target, initiator,
					    ALL_LUNS,
					    channel, ROLE_UNKNOWN);
			ahc_set_width(ahc, &devinfo,
				      MSG_EXT_WDTR_BUS_8_BIT,
				      AHC_TRANS_CUR,
				      /*paused*/TRUE,
				      /*done*/FALSE);
			ahc_set_syncrate(ahc, &devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, AHC_TRANS_CUR,
					 /*paused*/TRUE,
					 /*done*/FALSE);
d6392 1
d6395 2
a6396 5
	if (restart_needed)
		restart_sequencer(ahc);
	else
		unpause_sequencer(ahc);
	return found;
d6399 36
a6434 13
STATIC int
ahc_match_scb(scb, target, channel, lun, role, tag)
	struct scb *scb;
	int target;
	char channel;
	int lun;
	role_t role;
	u_int tag;
{
	int targ = SCB_TARGET(scb);
	char chan = SCB_CHANNEL(scb);
	int slun = SCB_LUN(scb);
	int match;
d6436 2
a6437 7
	match = ((chan == channel) || (channel == ALL_CHANNELS));
	if (match != 0)
		match = ((targ == target) || (target == ALL_TARGETS));
	if (match != 0)
		match = ((lun == slun) || (lun == ALL_LUNS));
	return match;
}
d6439 1
a6439 12
STATIC void
ahc_construct_sdtr(ahc, period, offset)
	struct ahc_softc *ahc;
	u_int period;
	u_int offset;
{
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_len += 5;
d6442 2
a6443 4
STATIC void
ahc_construct_wdtr(ahc, bus_width)
	struct ahc_softc *ahc;
	u_int bus_width;
d6445 9
a6453 6
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_len += 4;
}
d6455 2
a6456 5
STATIC void
ahc_calc_residual(scb)
	struct scb *scb;
{
	struct	hardware_scb *hscb;
d6458 4
a6461 1
	hscb = scb->hscb;
d6463 2
a6464 17
	/*
	 * If the disconnected flag is still set, this is bogus
	 * residual information left over from a sequencer
	 * pagin/pageout, so ignore this case.
	 */
	if ((scb->hscb->control & DISCONNECTED) == 0) {
		u_int32_t resid;
		int	  resid_sgs;
		int	  sg;
		
		/*
		 * Remainder of the SG where the transfer
		 * stopped.
		 */
		resid = (hscb->residual_data_count[2] << 16)
		      |	(hscb->residual_data_count[1] <<8)
		      |	(hscb->residual_data_count[0]);
d6466 4
a6469 8
		/*
		 * Add up the contents of all residual
		 * SG segments that are after the SG where
		 * the transfer stopped.
		 */
		resid_sgs = scb->hscb->residual_SG_count - 1/*current*/;
		sg = scb->sg_count - resid_sgs;
		while (resid_sgs > 0) {
d6471 22
a6492 3
			resid += le32toh(scb->sg_list[sg].len);
			sg++;
			resid_sgs--;
a6493 1
		scb->xs->resid = resid;
d6496 3
a6498 10
	/*
	 * Clean out the residual information in this SCB for its
	 * next consumer.
	 */
	hscb->residual_SG_count = 0;

#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC) {
		sc_print_addr(scb->xs->sc_link);
		printf("Handled Residual of %ld bytes\n" ,scb->xs->resid);
a6499 11
#endif
}

STATIC void
ahc_update_pending_syncrates(ahc)
	struct ahc_softc *ahc;
{
	struct	scb *scb;
	int	pending_scb_count;
	int	i;
	u_int	saved_scbptr;
d6502 2
a6503 2
	 * Traverse the pending SCB list and ensure that all of the
	 * SCBs there have the proper settings.
d6505 25
a6529 31
	scb = LIST_FIRST(&ahc->pending_scbs);
	pending_scb_count = 0;
	while (scb != NULL) {
		struct ahc_devinfo devinfo;
		struct scsi_xfer *xs;
		struct scb *pending_scb;
		struct hardware_scb *pending_hscb;
		struct ahc_initiator_tinfo *tinfo;
		struct tmode_tstate *tstate;
		u_int  our_id, remote_id;
		
		xs = scb->xs;
		pending_scb = scb;
		pending_hscb = pending_scb->hscb;
		our_id = SCB_IS_SCSIBUS_B(pending_scb)
		       ? ahc->our_id_b : ahc->our_id;
		remote_id = xs->sc_link->target;
		ahc_compile_devinfo(&devinfo, our_id, remote_id,
				    SCB_LUN(pending_scb),
				    SCB_CHANNEL(pending_scb),
				    ROLE_UNKNOWN);
		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
					    our_id, remote_id, &tstate);
		pending_hscb->control &= ~ULTRAENB;
		if ((tstate->ultraenb & devinfo.target_mask) != 0)
			pending_hscb->control |= ULTRAENB;
		pending_hscb->scsirate = tinfo->scsirate;
		pending_hscb->scsioffset = tinfo->current.offset;
		pending_scb_count++;
		scb = LIST_NEXT(scb, pend_links);
	}
d6531 2
a6532 2
	if (pending_scb_count == 0)
		return;
d6534 7
a6540 4
	saved_scbptr = ahc_inb(ahc, SCBPTR);
	/* Ensure that the hscbs down on the card match the new information */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scb_tag;
d6542 10
a6551 11
		ahc_outb(ahc, SCBPTR, i);
		scb_tag = ahc_inb(ahc, SCB_TAG);
		if (scb_tag != SCB_LIST_NULL) {
			struct	ahc_devinfo devinfo;
			struct	scb *pending_scb;
			struct scsi_xfer *xs;
			struct	hardware_scb *pending_hscb;
			struct	ahc_initiator_tinfo *tinfo;
			struct	tmode_tstate *tstate;
			u_int	our_id, remote_id;
			u_int	control;
d6553 31
a6583 21
			pending_scb = &ahc->scb_data->scbarray[scb_tag];
			if (pending_scb->flags == SCB_FREE)
				continue;
			pending_hscb = pending_scb->hscb;
			xs = pending_scb->xs;
			our_id = SCB_IS_SCSIBUS_B(pending_scb)
			       ? ahc->our_id_b : ahc->our_id;
			remote_id = xs->sc_link->target;
			ahc_compile_devinfo(&devinfo, our_id, remote_id,
					    SCB_LUN(pending_scb),
					    SCB_CHANNEL(pending_scb),
					    ROLE_UNKNOWN);
			tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
						    our_id, remote_id, &tstate);
			control = ahc_inb(ahc, SCB_CONTROL);
			control &= ~ULTRAENB;
			if ((tstate->ultraenb & devinfo.target_mask) != 0)
				control |= ULTRAENB;
			ahc_outb(ahc, SCB_CONTROL, control);
			ahc_outb(ahc, SCB_SCSIRATE, tinfo->scsirate);
			ahc_outb(ahc, SCB_SCSIOFFSET, tinfo->current.offset);
d6585 49
a6633 3
	}
	ahc_outb(ahc, SCBPTR, saved_scbptr);
}
d6635 1
a6635 6
STATIC void
ahc_shutdown(void *arg)
{
	struct	ahc_softc *ahc;
	int	i;
	u_int	sxfrctl1_a, sxfrctl1_b;
d6637 23
a6659 1
	ahc = (struct ahc_softc *)arg;
d6661 4
a6664 1
	pause_sequencer(ahc);
d6666 15
a6680 9
	/*
	 * Preserve the value of the SXFRCTL1 register for all channels.
	 * It contains settings that affect termination and we don't want
	 * to disturb the integrity of the bus during shutdown in case
	 * we are in a multi-initiator setup.
	 */
	sxfrctl1_b = 0;
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;
d6682 4
a6685 5
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		sxfrctl1_b = ahc_inb(ahc, SXFRCTL1);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
d6687 4
a6690 1
	sxfrctl1_a = ahc_inb(ahc, SXFRCTL1);
d6692 4
a6695 2
	/* This will reset most registers to 0, but not all */
	ahc_reset(ahc);
d6697 15
a6711 2
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;
d6713 18
a6730 6
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		ahc_outb(ahc, SXFRCTL1, sxfrctl1_b);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	ahc_outb(ahc, SXFRCTL1, sxfrctl1_a);
d6732 1
a6732 3
	ahc_outb(ahc, SCSISEQ, 0);
	ahc_outb(ahc, SXFRCTL0, 0);
	ahc_outb(ahc, DSPCISTATUS, 0);
d6734 28
a6761 2
	for (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)
		ahc_outb(ahc, i, 0);
d6764 2
a6765 4
STATIC void
ahc_check_tags(ahc, xs)
struct ahc_softc *ahc;
struct scsi_xfer *xs;
d6767 2
a6768 5
	struct scsi_inquiry_data *inq;
	struct ahc_devinfo devinfo;
	struct tmode_tstate *tstate;
	int target_id, our_id;
	char channel;
d6770 2
a6771 2
	if (xs->cmd->opcode != INQUIRY || xs->error != XS_NOERROR)
		return;
d6773 13
a6785 2
	if (xs->sc_link->quirks & SDEV_NOTAGS)
		return;
d6787 14
a6800 7
	target_id = xs->sc_link->target;
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
	channel = SIM_CHANNEL(ahc, xs->sc_link);

	(void)ahc_fetch_transinfo(ahc, channel, our_id, target_id, &tstate);
	ahc_compile_devinfo(&devinfo, our_id, target_id,
	    xs->sc_link->lun, channel, ROLE_INITIATOR);
d6802 4
a6805 2
	if (tstate->tagdisable & devinfo.target_mask)
		return;
d6808 16
a6823 11
	 * Sneak a look at the results of the SCSI Inquiry
	 * command and see if we can do Tagged queing.  This
	 * should really be done by the higher level drivers.
	 */
	inq = (struct scsi_inquiry_data *)xs->data;
	if ((inq->flags & SID_CmdQue) && !(ahc_istagged_device(ahc, xs, 1))) {
#ifdef AHC_DEBUG 
		printf("%s: target %d using tagged queuing\n",
			ahc_name(ahc), xs->sc_link->target);
#endif 
		ahc_set_tags(ahc, &devinfo, TRUE);
d6825 28
a6852 14
		if (ahc->scb_data->maxhscbs >= 16 ||
		    (ahc->flags & AHC_PAGESCBS)) {
			/* Default to 16 tags */
			xs->sc_link->openings += 14;
		} else {
			/*
			 * Default to 4 tags on whimpy
			 * cards that don't have much SCB
			 * space and can't page.  This prevents
			 * a single device from hogging all
			 * slots.  We should really have a better
			 * way of providing fairness.
			 */
			xs->sc_link->openings += 2;
d6857 2
a6858 5
STATIC int
ahc_istagged_device(ahc, xs, nocmdcheck)
struct ahc_softc *ahc;
struct scsi_xfer *xs;
int nocmdcheck;
d6860 39
a6898 4
	char channel;
	u_int our_id, target;
	struct tmode_tstate *tstate;
	struct ahc_devinfo devinfo;
d6900 5
a6904 2
	if (xs->sc_link->quirks & SDEV_NOTAGS)
		return 0;
d6907 2
a6908 2
	 * XXX never do these commands with tags. Should really be
	 * in a higher layer.
d6910 11
a6920 4
	if (!nocmdcheck && (xs->cmd->opcode == INQUIRY ||
	     xs->cmd->opcode == TEST_UNIT_READY ||
	     xs->cmd->opcode == REQUEST_SENSE))
		return 0;
d6922 24
a6945 4
	channel = SIM_CHANNEL(ahc, xs->sc_link);
	our_id = SIM_SCSI_ID(ahc, xs->sc_link);
	target = xs->sc_link->target;
	(void)ahc_fetch_transinfo(ahc, channel, our_id, target, &tstate);
d6947 1
a6947 2
	ahc_compile_devinfo(&devinfo, our_id, target,
	    xs->sc_link->lun, channel, ROLE_INITIATOR);
d6949 17
a6965 1
	return (tstate->tagenable & devinfo.target_mask);
d6967 2
@


1.18.6.9
log
@Sync the SMP branch with 3.3
@
text
@d2 5
a6 1
 * Core routines and tables shareable across OS platforms.
d8 1
a8 1
 * Copyright (c) 1994-2001 Justin T. Gibbs.
d21 1
a21 1
 * GNU Public License ("GPL").
d35 50
a84 1
 * $Id$
a85 2
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.80 2001/12/16 17:38:30 gibbs Exp $
 * $OpenBSD$
d88 20
a107 3
#ifdef __OpenBSD__
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
d109 12
d122 54
a175 4
#ifdef __FreeBSD__
#include <dev/aic7xxx/aic7xxx_freebsd.h>
#include <dev/aic7xxx/aic7xxx_inline.h>
#include <dev/aic7xxx/aicasm/aicasm_insformat.h>
a176 2
/****************************** Softc Data ************************************/
struct ahc_softc_tailq ahc_tailq = TAILQ_HEAD_INITIALIZER(ahc_tailq);
d178 17
a194 17
/***************************** Lookup Tables **********************************/
char *ahc_chip_names[] =
{
	"NONE",
	"aic7770",
	"aic7850",
	"aic7855",
	"aic7859",
	"aic7860",
	"aic7870",
	"aic7880",
	"aic7895",
	"aic7895C",
	"aic7890/91",
	"aic7896/97",
	"aic7892",
	"aic7899"
a195 1
static const u_int num_chip_names = NUM_ELEMENTS(ahc_chip_names);
d197 170
a366 6
/*
 * Hardware error codes.
 */
struct ahc_hard_error_entry {
        uint8_t errno;
	char *errmesg;
d369 6
a374 9
static struct ahc_hard_error_entry ahc_hard_errors[] = {
	{ ILLHADDR,	"Illegal Host Access" },
	{ ILLSADDR,	"Illegal Sequencer Address referrenced" },
	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
	{ SQPARERR,	"Sequencer Parity Error" },
	{ DPARERR,	"Data-path Parity Error" },
	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
	{ PCIERRSTAT,	"PCI Error detected" },
	{ CIOPARERR,	"CIOBUS Parity Error" },
a375 1
static const u_int num_errors = NUM_ELEMENTS(ahc_hard_errors);
d377 2
a378 1
static struct ahc_phase_table_entry ahc_phase_table[] =
d380 4
a383 10
	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
	{ P_DATAOUT_DT,	MSG_NOOP,		"in DT Data-out phase"	},
	{ P_DATAIN_DT,	MSG_INITIATOR_DET_ERR,	"in DT Data-in phase"	},
	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
	{ 0,		MSG_NOOP,		"in unknown phase"	}
d386 23
d410 5
a414 2
 * In most cases we only wish to itterate over real phases, so
 * exclude the last element from the count.
d416 13
a428 1
static const u_int num_phases = NUM_ELEMENTS(ahc_phase_table) - 1;
d430 5
a434 6
/*
 * Valid SCSIRATE values.  (p. 3-17)
 * Provides a mapping of tranfer periods in ns to the proper value to
 * stick in the scsixfer reg.
 */
static struct ahc_syncrate ahc_syncrates[] =
d436 2
a437 17
      /* ultra2    fast/ultra  period     rate */
	{ 0x42,      0x000,      9,      "80.0" },
	{ 0x03,      0x000,     10,      "40.0" },
	{ 0x04,      0x000,     11,      "33.0" },
	{ 0x05,      0x100,     12,      "20.0" },
	{ 0x06,      0x110,     15,      "16.0" },
	{ 0x07,      0x120,     18,      "13.4" },
	{ 0x08,      0x000,     25,      "10.0" },
	{ 0x19,      0x010,     31,      "8.0"  },
	{ 0x1a,      0x020,     37,      "6.67" },
	{ 0x1b,      0x030,     43,      "5.7"  },
	{ 0x1c,      0x040,     50,      "5.0"  },
	{ 0x00,      0x050,     56,      "4.4"  },
	{ 0x00,      0x060,     62,      "4.0"  },
	{ 0x00,      0x070,     68,      "3.6"  },
	{ 0x00,      0x000,      0,      NULL   }
};
d439 5
a443 6
/* Our Sequencer Program */
#ifdef __OpenBSD__
#include <dev/microcode/aic7xxx/aic7xxx_seq.h>
#else
#include "aic7xxx_seq.h"
#endif 
d445 7
a451 61
/**************************** Function Declarations ***************************/
static struct ahc_tmode_tstate*
			ahc_alloc_tstate(struct ahc_softc *ahc,
					 u_int scsi_id, char channel);
#ifdef AHC_TARGET_MODE
static void		ahc_free_tstate(struct ahc_softc *ahc,
					u_int scsi_id, char channel, int force);
#endif
static struct ahc_syncrate*
			ahc_devlimited_syncrate(struct ahc_softc *ahc,
					        struct ahc_initiator_tinfo *,
						u_int *period,
						u_int *ppr_options,
						role_t role);
static void		ahc_update_pending_scbs(struct ahc_softc *ahc);
static void		ahc_fetch_devinfo(struct ahc_softc *ahc,
					  struct ahc_devinfo *devinfo);
static void		ahc_scb_devinfo(struct ahc_softc *ahc,
					struct ahc_devinfo *devinfo,
					struct scb *scb);
static void		ahc_assert_atn(struct ahc_softc *ahc);
static void		ahc_setup_initiator_msgout(struct ahc_softc *ahc,
						   struct ahc_devinfo *devinfo,
						   struct scb *scb);
static void		ahc_build_transfer_msg(struct ahc_softc *ahc,
					       struct ahc_devinfo *devinfo);
static void		ahc_construct_sdtr(struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo,
					   u_int period, u_int offset);
static void		ahc_construct_wdtr(struct ahc_softc *ahc,
					   struct ahc_devinfo *devinfo,
					   u_int bus_width);
static void		ahc_construct_ppr(struct ahc_softc *ahc,
					  struct ahc_devinfo *devinfo,
					  u_int period, u_int offset,
					  u_int bus_width, u_int ppr_options);
static void		ahc_clear_msg_state(struct ahc_softc *ahc);
static void		ahc_handle_message_phase(struct ahc_softc *ahc);
typedef enum {
	AHCMSG_1B,
	AHCMSG_2B,
	AHCMSG_EXT
} ahc_msgtype;
static int		ahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type,
				     u_int msgval, int full);
static int		ahc_parse_msg(struct ahc_softc *ahc,
				      struct ahc_devinfo *devinfo);
static int		ahc_handle_msg_reject(struct ahc_softc *ahc,
					      struct ahc_devinfo *devinfo);
static void		ahc_handle_ign_wide_residue(struct ahc_softc *ahc,
						struct ahc_devinfo *devinfo);
static void		ahc_reinitialize_dataptrs(struct ahc_softc *ahc);
static void		ahc_handle_devreset(struct ahc_softc *ahc,
					    struct ahc_devinfo *devinfo,
					    cam_status status, char *message,
					    int verbose_level);
#if AHC_TARGET_MODE
static void		ahc_setup_target_msgin(struct ahc_softc *ahc,
					       struct ahc_devinfo *devinfo,
					       struct scb *scb);
#endif
d453 7
a459 10
#ifdef __OpenBSD__
int			ahc_init_scbdata(struct ahc_softc *ahc);
void			ahc_fini_scbdata(struct ahc_softc *ahc);
void			ahc_build_free_scb_list(struct ahc_softc *ahc);
#else
static bus_dmamap_callback_t	ahc_dmamap_cb;
static int		ahc_init_scbdata(struct ahc_softc *ahc);
static void		ahc_fini_scbdata(struct ahc_softc *ahc);
static void		ahc_build_free_scb_list(struct ahc_softc *ahc);
#endif 
a460 34
static void		ahc_qinfifo_requeue(struct ahc_softc *ahc,
					    struct scb *prev_scb,
					    struct scb *scb);
static int		ahc_qinfifo_count(struct ahc_softc *ahc);
static u_int		ahc_rem_scb_from_disc_list(struct ahc_softc *ahc,
						   u_int prev, u_int scbptr);
static void		ahc_add_curscb_to_free_list(struct ahc_softc *ahc);
static u_int		ahc_rem_wscb(struct ahc_softc *ahc,
				     u_int scbpos, u_int prev);
static int		ahc_abort_scbs(struct ahc_softc *ahc, int target,
				       char channel, int lun, u_int tag,
				       role_t role, uint32_t status);
static void		ahc_reset_current_bus(struct ahc_softc *ahc);
#ifdef AHC_DUMP_SEQ
static void		ahc_dumpseq(struct ahc_softc *ahc);
#endif
static void		ahc_loadseq(struct ahc_softc *ahc);
static int		ahc_check_patch(struct ahc_softc *ahc,
					struct patch **start_patch,
					u_int start_instr, u_int *skip_addr);
static void		ahc_download_instr(struct ahc_softc *ahc,
					   u_int instrptr, uint8_t *dconsts);
#ifdef AHC_TARGET_MODE
static void		ahc_queue_lstate_event(struct ahc_softc *ahc,
					       struct ahc_tmode_lstate *lstate,
					       u_int initiator_id,
					       u_int event_type,
					       u_int event_arg);
static void		ahc_update_scsiid(struct ahc_softc *ahc,
					  u_int targid_mask);
static int		ahc_handle_target_cmd(struct ahc_softc *ahc,
					      struct target_cmd *cmd);
#endif
/************************* Sequencer Execution Control ************************/
d464 35
a498 2
void
ahc_restart(struct ahc_softc *ahc)
d500 11
d512 9
a520 1
	ahc_pause(ahc);
d522 7
a528 3
	ahc_outb(ahc, SCSISIGO, 0);		/* De-assert BSY */
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);	/* No message to send */
	ahc_outb(ahc, SXFRCTL1, ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);
d530 7
a536 8
	/*
	 * Ensure that the sequencer's idea of TQINPOS
	 * matches our own.  The sequencer increments TQINPOS
	 * only after it sees a DMA complete and a reset could
	 * occur before the increment leaving the kernel to believe
	 * the command arrived but the sequencer to not.
	 */
	ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
d538 4
a541 8
	/* Always allow reselection */
	ahc_outb(ahc, SCSISEQ,
		 ahc_inb(ahc, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Ensure that no DMA operations are in progress */
		ahc_outb(ahc, CCSCBCNT, 0);
		ahc_outb(ahc, CCSGCTL, 0);
		ahc_outb(ahc, CCSCBCTL, 0);
d543 18
d562 4
a565 3
	 * If we were in the process of DMA'ing SCB data into
	 * an SCB, replace that SCB on the free list.  This prevents
	 * an SCB leak.
d567 4
a570 10
	if ((ahc_inb(ahc, SEQ_FLAGS2) & SCB_DMA) != 0) {
		ahc_add_curscb_to_free_list(ahc);
		ahc_outb(ahc, SEQ_FLAGS2,
			 ahc_inb(ahc, SEQ_FLAGS2) & ~SCB_DMA);
	}
	ahc_outb(ahc, MWI_RESIDUAL, 0);
	ahc_outb(ahc, SEQCTL, FASTMODE);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	ahc_unpause(ahc);
d573 3
a575 3
/************************* Input/Output Queues ********************************/
void
ahc_run_qoutfifo(struct ahc_softc *ahc)
d580 3
a582 1
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);
a583 1

d585 1
a585 18
		if ((ahc->qoutfifonext & 0x03) == 0x03) {
			u_int modnext;

			/*
			 * Clear 32bits of QOUTFIFO at a time
			 * so that we don't clobber an incoming
			 * byte DMA to the array on architectures
			 * that only support 32bit load and store
			 * operations.
			 */
			modnext = ahc->qoutfifonext & ~0x3;
			*((uint32_t *)(&ahc->qoutfifo[modnext])) = 0xFFFFFFFFUL;
			ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
					ahc->shared_data_dmamap,
					/*offset*/modnext, /*len*/4,
					BUS_DMASYNC_PREREAD);
		}
		ahc->qoutfifonext++;
d587 3
a589 2
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
d601 4
a604 1
		ahc_update_residual(scb);
a608 4
void
ahc_run_untagged_queues(struct ahc_softc *ahc)
{
	int i;
d610 13
a622 3
	for (i = 0; i < 16; i++)
		ahc_run_untagged_queue(ahc, &ahc->untagged_queues[i]);
}
d624 4
a627 4
void
ahc_run_untagged_queue(struct ahc_softc *ahc, struct scb_tailq *queue)
{
	struct scb *scb;
d629 1
a629 2
	if (ahc->untagged_queue_lock != 0)
		return;
d631 4
a634 4
	if ((scb = TAILQ_FIRST(queue)) != NULL
	 && (scb->flags & SCB_ACTIVE) == 0) {
		scb->flags |= SCB_ACTIVE;
		ahc_queue_scb(ahc, scb);
d636 10
d648 9
a656 3
/************************* Interrupt Handling *********************************/
void
ahc_handle_brkadrint(struct ahc_softc *ahc)
d658 12
a669 6
	/*
	 * We upset the sequencer :-(
	 * Lookup the error message
	 */
	int i;
	int error;
d671 1
a671 14
	error = ahc_inb(ahc, ERROR);
	for (i = 0; error != 1 && i < num_errors; i++)
		error >>= 1;
	printf("%s: brkadrint, %s at seqaddr = 0x%x\n",
	       ahc_name(ahc), ahc_hard_errors[i].errmesg,
	       ahc_inb(ahc, SEQADDR0) |
	       (ahc_inb(ahc, SEQADDR1) << 8));

	ahc_dump_card_state(ahc);

	/* Tell everyone that this HBA is no longer availible */
	ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,
		       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,
		       CAM_NO_HBA);
d673 1
a673 2
	/* Disable all interrupt sources by resetting the controller */
	ahc_shutdown(ahc);
d676 17
a692 5
void
ahc_handle_seqint(struct ahc_softc *ahc, u_int intstat)
{
	struct scb *scb;
	struct ahc_devinfo devinfo;
d694 50
a743 1
	ahc_fetch_devinfo(ahc, &devinfo);
d745 9
a753 12
	/*
	 * Clear the upper byte that holds SEQINT status
	 * codes and clear the SEQINT bit. We will unpause
	 * the sequencer, if appropriate, after servicing
	 * the request.
	 */
	ahc_outb(ahc, CLRINT, CLRSEQINT);
	switch (intstat & SEQINT_MASK) {
	case BAD_STATUS:
	{
		u_int  scb_index;
		struct hardware_scb *hscb;
d755 5
a759 6
		/*
		 * Set the default return value to 0 (don't
		 * send sense).  The sense code will change
		 * this if needed.
		 */
		ahc_outb(ahc, RETURN_1, 0);
d761 6
a766 20
		/*
		 * The sequencer will notify us when a command
		 * has an error that would be of interest to
		 * the kernel.  This allows us to leave the sequencer
		 * running in the common case of command completes
		 * without error.  The sequencer will already have
		 * dma'd the SCB back up to us, so we can reference
		 * the in kernel copy directly.
		 */
		scb_index = ahc_inb(ahc, SCB_TAG);
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("%s:%c:%d: ahc_intr - referenced scb "
			       "not valid during seqint 0x%x scb(%d)\n",
			       ahc_name(ahc), devinfo.channel,
			       devinfo.target, intstat, scb_index);
			ahc_dump_card_state(ahc);
			panic("for safety");
			goto unpause;
		}
d768 22
a789 1
		hscb = scb->hscb; 
d791 14
a804 39
		/* Don't want to clobber the original sense code */
		if ((scb->flags & SCB_SENSE) != 0) {
			/*
			 * Clear the SCB_SENSE Flag and have
			 * the sequencer do a normal command
			 * complete.
			 */
			scb->flags &= ~SCB_SENSE;
			ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
			break;
		}
		ahc_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
		/* Freeze the queue until the client sees the error. */
		ahc_freeze_devq(ahc, scb);
		ahc_freeze_scb(scb);
		ahc_set_scsi_status(scb, hscb->shared_data.status.scsi_status);
		switch (hscb->shared_data.status.scsi_status) {
		case SCSI_STATUS_OK:
			printf("%s: Interrupted for staus of 0???\n",
			       ahc_name(ahc));
			break;
		case SCSI_STATUS_CMD_TERMINATED:
		case SCSI_STATUS_CHECK_COND:
		{
			struct ahc_dma_seg *sg;
			struct scsi_sense *sc;
			struct ahc_initiator_tinfo *targ_info;
			struct ahc_tmode_tstate *tstate;
			struct ahc_transinfo *tinfo;
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				ahc_print_path(ahc, scb);
				printf("SCB %d: requests Check Status\n",
				       scb->hscb->tag);
			}
#endif
				
			if (ahc_perform_autosense(scb) == 0)
				break;
d806 15
a820 35
			targ_info = ahc_fetch_transinfo(ahc,
							devinfo.channel,
							devinfo.our_scsiid,
							devinfo.target,
							&tstate);
			tinfo = &targ_info->curr;
			sg = scb->sg_list;
			sc = (struct scsi_sense *)(&hscb->shared_data.cdb); 
			/*
			 * Save off the residual if there is one.
 			 */
			ahc_update_residual(scb);
#ifdef AHC_DEBUG
			if (ahc_debug & AHC_SHOWSENSE) {
				ahc_print_path(ahc, scb);
				printf("Sending Sense\n");
			}
#endif
			sg->addr = ahc_get_sense_bufaddr(ahc, scb);
			sg->len = ahc_get_sense_bufsize(ahc, scb);
			sg->len |= AHC_DMA_LAST_SEG;
			
			/* Fixup byte order */
			sg->addr = ahc_htole32(sg->addr);
			sg->len = ahc_htole32(sg->len);

			sc->opcode = REQUEST_SENSE;
			sc->byte2 = 0;
			if (tinfo->protocol_version <= SCSI_REV_2
			 && SCB_GET_LUN(scb) < 8)
				sc->byte2 = SCB_GET_LUN(scb) << 5;
			sc->unused[0] = 0;
			sc->unused[1] = 0;
			sc->length = sg->len;
			sc->control = 0;
d822 27
a848 8
			/*
			 * We can't allow the target to disconnect.
			 * This will be an untagged transaction and
			 * having the target disconnect will make this
			 * transaction indestinguishable from outstanding
			 * tagged transactions.
			 */
			hscb->control = 0;
d850 15
a864 395
			/*
			 * This request sense could be because the
			 * the device lost power or in some other
			 * way has lost our transfer negotiations.
			 * Renegotiate if appropriate.  Unit attention
			 * errors will be reported before any data
			 * phases occur.
			 */
#ifdef __OpenBSD__
			if (ahc_get_transfer_length(scb) > 0 &&
			    ahc_get_residual(scb) == 
			    ahc_get_transfer_length(scb)) {
#else 
			if (ahc_get_residual(scb) 
			 == ahc_get_transfer_length(scb)) {
#endif
				ahc_update_neg_request(ahc, &devinfo,
						       tstate, targ_info,
						       /*force*/TRUE);
			}
			if (tstate->auto_negotiate & devinfo.target_mask) {
				hscb->control |= MK_MESSAGE;
				scb->flags &= ~SCB_NEGOTIATE;
				scb->flags |= SCB_AUTO_NEGOTIATE;
			}
			hscb->cdb_len = sizeof(*sc);
			hscb->dataptr = sg->addr; 
			hscb->datacnt = sg->len;
			hscb->sgptr = scb->sg_list_phys | SG_FULL_RESID;
			hscb->sgptr = ahc_htole32(hscb->sgptr);
			scb->sg_count = 1;
			scb->flags |= SCB_SENSE;
			ahc_qinfifo_requeue_tail(ahc, scb);
			ahc_outb(ahc, RETURN_1, SEND_SENSE);
#ifdef __OpenBSD__
			if (!(scb->io_ctx->flags & SCSI_POLL))
				timeout_add(&scb->io_ctx->stimeout, 5 * hz);
#endif 
#ifdef __FreeBSD__
			/*
			 * Ensure we have enough time to actually
			 * retrieve the sense.
			 */
			untimeout(ahc_timeout, (caddr_t)scb,
				  scb->io_ctx->ccb_h.timeout_ch);
			scb->io_ctx->ccb_h.timeout_ch =
			    timeout(ahc_timeout, (caddr_t)scb, 5 * hz);
#endif
			break;
		}
		default:
			break;
		}
		break;
	}
	case NO_MATCH:
	{
		/* Ensure we don't leave the selection hardware on */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));

		printf("%s:%c:%d: no active SCB for reconnecting "
		       "target - issuing BUS DEVICE RESET\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target);
		printf("SAVED_SCSIID == 0x%02x, SAVED_LUN == 0x%x, "
		       "ARG_1 == 0x%x ACCUM = 0x%x\n",
		       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),
		       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));
		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
		       "SINDEX == 0x%x\n",
		       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),
		       ahc_index_busy_tcl(ahc,
			    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),
				      ahc_inb(ahc, SAVED_LUN))),
		       ahc_inb(ahc, SINDEX));
		printf("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
		       "SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",
		       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),
		       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),
		       ahc_inb(ahc, SCB_CONTROL));
		printf("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",
		       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));
		printf("SXFRCTL0 == 0x%x\n", ahc_inb(ahc, SXFRCTL0));
		printf("SEQCTL == 0x%x\n", ahc_inb(ahc, SEQCTL));
		ahc_dump_card_state(ahc);
		ahc->msgout_buf[0] = MSG_BUS_DEV_RESET;
		ahc->msgout_len = 1;
		ahc->msgout_index = 0;
		ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		ahc_assert_atn(ahc);
		break;
	}
	case SEND_REJECT: 
	{
		u_int rejbyte = ahc_inb(ahc, ACCUM);
		printf("%s:%c:%d: Warning - unknown message received from "
		       "target (0x%x).  Rejecting\n", 
		       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);
		break; 
	}
	case NO_IDENT: 
	{
		/*
		 * The reconnecting target either did not send an identify
		 * message, or did, but we didn't find an SCB to match and
		 * before it could respond to our ATN/abort, it hit a dataphase.
		 * The only safe thing to do is to blow it away with a bus
		 * reset.
		 */
		int found;

		printf("%s:%c:%d: Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x, SAVED_SCSIID == 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_SCSIID));
		found = ahc_reset_channel(ahc, devinfo.channel, 
					  /*initiate reset*/TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), devinfo.channel,
		       found);
		return;
	}
	case IGN_WIDE_RES:
		ahc_handle_ign_wide_residue(ahc, &devinfo);
		break;
	case PDATA_REINIT:
		ahc_reinitialize_dataptrs(ahc);
		break;
	case BAD_PHASE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		printf("%s:%c:%d: unknown scsi bus phase %x, "
		       "lastphase = 0x%x.  Attempting to continue\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       lastphase, ahc_inb(ahc, SCSISIGI));
		break;
	}
	case MISSED_BUSFREE:
	{
		u_int lastphase;

		lastphase = ahc_inb(ahc, LASTPHASE);
		printf("%s:%c:%d: Missed busfree. "
		       "Lastphase = 0x%x, Curphase = 0x%x\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       lastphase, ahc_inb(ahc, SCSISIGI));
		ahc_restart(ahc);
		return;
	}
	case HOST_MSG_LOOP:
	{
		/*
		 * The sequencer has encountered a message phase
		 * that requires host assistance for completion.
		 * While handling the message phase(s), we will be
		 * notified by the sequencer after each byte is
		 * transfered so we can track bus phase changes.
		 *
		 * If this is the first time we've seen a HOST_MSG_LOOP
		 * interrupt, initialize the state of the host message
		 * loop.
		 */
		if (ahc->msg_type == MSG_TYPE_NONE) {
			struct scb *scb;
			u_int scb_index;
			u_int bus_phase;

			bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
			if (bus_phase != P_MESGIN
			 && bus_phase != P_MESGOUT) {
				printf("ahc_intr: HOST_MSG_LOOP bad "
				       "phase 0x%x\n",
				      bus_phase);
				/*
				 * Probably transitioned to bus free before
				 * we got here.  Just punt the message.
				 */
				ahc_clear_intstat(ahc);
				ahc_restart(ahc);
				return;
			}

			scb_index = ahc_inb(ahc, SCB_TAG);
			scb = ahc_lookup_scb(ahc, scb_index);
			if (devinfo.role == ROLE_INITIATOR) {
				if (scb == NULL)
					panic("HOST_MSG_LOOP with "
					      "invalid SCB %x", scb_index);

				if (bus_phase == P_MESGOUT)
					ahc_setup_initiator_msgout(ahc,
								   &devinfo,
								   scb);
				else {
					ahc->msg_type =
					    MSG_TYPE_INITIATOR_MSGIN;
					ahc->msgin_index = 0;
				}
			} else {
				if (bus_phase == P_MESGOUT) {
					ahc->msg_type =
					    MSG_TYPE_TARGET_MSGOUT;
					ahc->msgin_index = 0;
				}
#if AHC_TARGET_MODE
				else 
					ahc_setup_target_msgin(ahc,
							       &devinfo,
							       scb);
#endif
			}
		}

		ahc_handle_message_phase(ahc);
		break;
	}
	case PERR_DETECTED:
	{
		/*
		 * If we've cleared the parity error interrupt
		 * but the sequencer still believes that SCSIPERR
		 * is true, it must be that the parity error is
		 * for the currently presented byte on the bus,
		 * and we are not in a phase (data-in) where we will
		 * eventually ack this byte.  Ack the byte and
		 * throw it away in the hope that the target will
		 * take us to message out to deliver the appropriate
		 * error message.
		 */
		if ((intstat & SCSIINT) == 0
		 && (ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0) {

			if ((ahc->features & AHC_DT) == 0) {
				u_int curphase;

				/*
				 * The hardware will only let you ack bytes
				 * if the expected phase in SCSISIGO matches
				 * the current phase.  Make sure this is
				 * currently the case.
				 */
				curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
				ahc_outb(ahc, LASTPHASE, curphase);
				ahc_outb(ahc, SCSISIGO, curphase);
			}
			ahc_inb(ahc, SCSIDATL);
		}
		break;
	}
	case DATA_OVERRUN:
	{
		/*
		 * When the sequencer detects an overrun, it
		 * places the controller in "BITBUCKET" mode
		 * and allows the target to complete its transfer.
		 * Unfortunately, none of the counters get updated
		 * when the controller is in this mode, so we have
		 * no way of knowing how large the overrun was.
		 */
		u_int scbindex = ahc_inb(ahc, SCB_TAG);
		u_int lastphase = ahc_inb(ahc, LASTPHASE);
		u_int i;

		scb = ahc_lookup_scb(ahc, scbindex);
		for (i = 0; i < num_phases; i++) {
			if (lastphase == ahc_phase_table[i].phase)
				break;
		}
		ahc_print_path(ahc, scb);
		printf("data overrun detected %s."
		       "  Tag == 0x%x.\n",
		       ahc_phase_table[i].phasemsg,
  		       scb->hscb->tag);
		ahc_print_path(ahc, scb);
		printf("%s seen Data Phase.  Length = %ld.  NumSGs = %d.\n",
		       ahc_inb(ahc, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
		       ahc_get_transfer_length(scb), scb->sg_count);
		if (scb->sg_count > 0) {
			for (i = 0; i < scb->sg_count; i++) {

				printf("sg[%d] - Addr 0x%x%x : Length %d\n",
				       i,
				       (ahc_le32toh(scb->sg_list[i].len) >> 24
				        & SG_HIGH_ADDR_BITS),
				       ahc_le32toh(scb->sg_list[i].addr),
				       ahc_le32toh(scb->sg_list[i].len)
				       & AHC_SG_LEN_MASK);
			}
		}
		/*
		 * Set this and it will take effect when the
		 * target does a command complete.
		 */
		ahc_freeze_devq(ahc, scb);
		ahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);
		ahc_freeze_scb(scb);

		if ((ahc->features & AHC_ULTRA2) != 0) {
			/*
			 * Clear the channel in case we return
			 * to data phase later.
			 */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | CLRSTCNT|CLRCHN);
		}
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			u_int dscommand1;

			/* Ensure HHADDR is 0 for future DMA operations. */
			dscommand1 = ahc_inb(ahc, DSCOMMAND1);
			ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
			ahc_outb(ahc, HADDR, 0);
			ahc_outb(ahc, DSCOMMAND1, dscommand1);
		}
		break;
	}
	case MKMSG_FAILED:
	{
		u_int scbindex;

		printf("%s:%c:%d:%d: Attempt to issue message failed\n",
		       ahc_name(ahc), devinfo.channel, devinfo.target,
		       devinfo.lun);
		scbindex = ahc_inb(ahc, SCB_TAG);
		scb = ahc_lookup_scb(ahc, scbindex);
		if (scb != NULL
		 && (scb->flags & SCB_RECOVERY_SCB) != 0)
			/*
			 * Ensure that we didn't put a second instance of this
			 * SCB into the QINFIFO.
			 */
			ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
					   SCB_GET_CHANNEL(ahc, scb),
					   SCB_GET_LUN(scb), scb->hscb->tag,
					   ROLE_INITIATOR, /*status*/0,
					   SEARCH_REMOVE);
		break;
	}
	case NO_FREE_SCB:
	{
		printf("%s: No free or disconnected SCBs\n", ahc_name(ahc));
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	case SCB_MISMATCH:
	{
		u_int scbptr;

		scbptr = ahc_inb(ahc, SCBPTR);
		printf("Bogus TAG after DMA.  SCBPTR %d, tag %d, our tag %d\n",
		       scbptr, ahc_inb(ahc, ARG_1),
		       ahc->scb_data->hscbs[scbptr].tag);
		ahc_dump_card_state(ahc);
		panic("for saftey");
		break;
	}
	case OUT_OF_RANGE:
	{
		printf("%s: BTT calculation out of range\n", ahc_name(ahc));
		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
		       "ARG_1 == 0x%x ACCUM = 0x%x\n",
		       ahc_inb(ahc, SAVED_SCSIID), ahc_inb(ahc, SAVED_LUN),
		       ahc_inb(ahc, ARG_1), ahc_inb(ahc, ACCUM));
		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
		       "SINDEX == 0x%x\n, A == 0x%x\n",
		       ahc_inb(ahc, SEQ_FLAGS), ahc_inb(ahc, SCBPTR),
		       ahc_index_busy_tcl(ahc,
			    BUILD_TCL(ahc_inb(ahc, SAVED_SCSIID),
				      ahc_inb(ahc, SAVED_LUN))),
		       ahc_inb(ahc, SINDEX),
		       ahc_inb(ahc, ACCUM));
		printf("SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
		       "SCB_TAG == 0x%x, SCB_CONTROL == 0x%x\n",
		       ahc_inb(ahc, SCSIID), ahc_inb(ahc, SCB_SCSIID),
		       ahc_inb(ahc, SCB_LUN), ahc_inb(ahc, SCB_TAG),
		       ahc_inb(ahc, SCB_CONTROL));
		printf("SCSIBUSL == 0x%x, SCSISIGI == 0x%x\n",
		       ahc_inb(ahc, SCSIBUSL), ahc_inb(ahc, SCSISIGI));
		ahc_dump_card_state(ahc);
		panic("for safety");
		break;
	}
	default:
		printf("ahc_intr: seqint, "
		       "intstat == 0x%x, scsisigi = 0x%x\n",
		       intstat, ahc_inb(ahc, SCSISIGI));
		break;
	}
unpause:
d866 1
a866 3
	 *  The sequencer is paused immediately on
	 *  a SEQINT, so we should restart it when
	 *  we're done.
d868 15
a882 1
	ahc_unpause(ahc);
d886 2
a887 1
ahc_handle_scsiint(struct ahc_softc *ahc, u_int intstat)
d889 12
a900 6
	u_int	scb_index;
	u_int	status0;
	u_int	status;
	struct	scb *scb;
	char	cur_channel;
	char	intr_channel;
d902 10
a911 2
	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);
d913 7
a919 6
	if ((ahc->features & AHC_TWIN) != 0
	 && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
		cur_channel = 'B';
	else
		cur_channel = 'A';
	intr_channel = cur_channel;
d921 1
a921 20
	if ((ahc->features & AHC_ULTRA2) != 0)
		status0 = ahc_inb(ahc, SSTAT0) & IOERR;
	else
		status0 = 0;
	status = ahc_inb(ahc, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
	if (status == 0 && status0 == 0) {
		if ((ahc->features & AHC_TWIN) != 0) {
			/* Try the other channel */
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
			status = ahc_inb(ahc, SSTAT1)
			       & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
			intr_channel = (cur_channel == 'A') ? 'B' : 'A';
		}
		if (status == 0) {
			printf("%s: Spurious SCSI interrupt\n", ahc_name(ahc));
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
			ahc_unpause(ahc);
			return;
		}
	}
d923 5
a927 5
	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	if (scb != NULL
	 && (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)
		scb = NULL;
d929 2
a930 44
	if ((ahc->features & AHC_ULTRA2) != 0
	 && (status0 & IOERR) != 0) {
		int now_lvd;

		now_lvd = ahc_inb(ahc, SBLKCTL) & ENAB40;
		printf("%s: Transceiver State Has Changed to %s mode\n",
		       ahc_name(ahc), now_lvd ? "LVD" : "SE");
		ahc_outb(ahc, CLRSINT0, CLRIOERR);
		/*
		 * When transitioning to SE mode, the reset line
		 * glitches, triggering an arbitration bug in some
		 * Ultra2 controllers.  This bug is cleared when we
		 * assert the reset line.  Since a reset glitch has
		 * already occurred with this transition and a
		 * transceiver state change is handled just like
		 * a bus reset anyway, asserting the reset line
		 * ourselves is safe.
		 */
		ahc_reset_channel(ahc, intr_channel,
				 /*Initiate Reset*/now_lvd == 0);
	} else if ((status & SCSIRSTI) != 0) {
		printf("%s: Someone reset channel %c\n",
			ahc_name(ahc), intr_channel);
		if (intr_channel != cur_channel)
		 	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) ^ SELBUSB);
		ahc_reset_channel(ahc, intr_channel, /*Initiate Reset*/FALSE);
	} else if ((status & SCSIPERR) != 0) {
		/*
		 * Determine the bus phase and queue an appropriate message.
		 * SCSIPERR is latched true as soon as a parity error
		 * occurs.  If the sequencer acked the transfer that
		 * caused the parity error and the currently presented
		 * transfer on the bus has correct parity, SCSIPERR will
		 * be cleared by CLRSCSIPERR.  Use this to determine if
		 * we should look at the last phase the sequencer recorded,
		 * or the current phase presented on the bus.
		 */
		u_int mesg_out;
		u_int curphase;
		u_int errorphase;
		u_int lastphase;
		u_int scsirate;
		u_int i;
		u_int sstat2;
d932 2
a933 20
		lastphase = ahc_inb(ahc, LASTPHASE);
		curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
		sstat2 = ahc_inb(ahc, SSTAT2);
		ahc_outb(ahc, CLRSINT1, CLRSCSIPERR);
		/*
		 * For all phases save DATA, the sequencer won't
		 * automatically ack a byte that has a parity error
		 * in it.  So the only way that the current phase
		 * could be 'data-in' is if the parity error is for
		 * an already acked byte in the data phase.  During
		 * synchronous data-in transfers, we may actually
		 * ack bytes before latching the current phase in
		 * LASTPHASE, leading to the discrepancy between
		 * curphase and lastphase.
		 */
		if ((ahc_inb(ahc, SSTAT1) & SCSIPERR) != 0
		 || curphase == P_DATAIN || curphase == P_DATAIN_DT)
			errorphase = curphase;
		else
			errorphase = lastphase;
d935 3
a937 16
		for (i = 0; i < num_phases; i++) {
			if (errorphase == ahc_phase_table[i].phase)
				break;
		}
		mesg_out = ahc_phase_table[i].mesg_out;
		if (scb != NULL)
			ahc_print_path(ahc, scb);
		else
			printf("%s:%c:%d: ", ahc_name(ahc), intr_channel,
			       SCSIID_TARGET(ahc, ahc_inb(ahc, SAVED_SCSIID)));
		scsirate = ahc_inb(ahc, SCSIRATE);
		printf("parity error detected %s. "
		       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
		       ahc_phase_table[i].phasemsg,
		       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),
		       scsirate);
d939 3
a941 1
		if ((ahc->features & AHC_DT) != 0) {
d943 3
a945 28
			if ((sstat2 & CRCVALERR) != 0)
				printf("\tCRC Value Mismatch\n");
			if ((sstat2 & CRCENDERR) != 0)
				printf("\tNo terminal CRC packet recevied\n");
			if ((sstat2 & CRCREQERR) != 0)
				printf("\tIllegal CRC packet request\n");
			if ((sstat2 & DUAL_EDGE_ERR) != 0)
				printf("\tUnexpected %sDT Data Phase\n",
				       (scsirate & SINGLE_EDGE) ? "" : "non-");
		}

		/*
		 * We've set the hardware to assert ATN if we   
		 * get a parity error on "in" phases, so all we  
		 * need to do is stuff the message buffer with
		 * the appropriate message.  "In" phases have set
		 * mesg_out to something other than MSG_NOP.
		 */
		if (mesg_out != MSG_NOOP) {
			if (ahc->msg_type != MSG_TYPE_NONE)
				ahc->send_msg_perror = TRUE;
			else
				ahc_outb(ahc, MSG_OUT, mesg_out);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_unpause(ahc);
	} else if ((status & SELTO) != 0) {
		u_int scbptr;
d947 1
a947 76
		/* Stop the selection */
		ahc_outb(ahc, SCSISEQ, 0);

		/* No more pending messages */
		ahc_clear_msg_state(ahc);

		/* Clear interrupt state */
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);

		/*
		 * Although the driver does not care about the
		 * 'Selection in Progress' status bit, the busy
		 * LED does.  SELINGO is only cleared by a successful
		 * selection, so we must manually clear it to insure
		 * the LED turns off just incase no future successful
		 * selections occur (e.g. no devices on the bus).
		 */
		ahc_outb(ahc, CLRSINT0, CLRSELINGO);

		scbptr = ahc_inb(ahc, WAITING_SCBH);
		ahc_outb(ahc, SCBPTR, scbptr);
		scb_index = ahc_inb(ahc, SCB_TAG);

		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("%s: ahc_intr - referenced scb not "
			       "valid during SELTO scb(%d, %d)\n",
			       ahc_name(ahc), scbptr, scb_index);
		} else {
			ahc_set_transaction_status(scb, CAM_SEL_TIMEOUT);
			ahc_freeze_devq(ahc, scb);
		}
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_restart(ahc);
	} else if ((status & BUSFREE) != 0
		&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {
		u_int lastphase;
		u_int saved_scsiid;
		u_int saved_lun;
		u_int target;
		u_int initiator_role_id;
		char channel;
		int printerror;

		/*
		 * Clear our selection hardware as soon as possible.
		 * We may have an entry in the waiting Q for this target,
		 * that is affected by this busfree and we don't want to
		 * go about selecting the target while we handle the event.
		 */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & (ENSELI|ENRSELI|ENAUTOATNP));

		/*
		 * Disable busfree interrupts and clear the busfree
		 * interrupt status.  We do this here so that several
		 * bus transactions occur prior to clearing the SCSIINT
		 * latch.  It can take a bit for the clearing to take effect.
		 */
		ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENBUSFREE);
		ahc_outb(ahc, CLRSINT1, CLRBUSFREE|CLRSCSIPERR);

		/*
		 * Look at what phase we were last in.
		 * If its message out, chances are pretty good
		 * that the busfree was in response to one of
		 * our abort requests.
		 */
		lastphase = ahc_inb(ahc, LASTPHASE);
		saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
		saved_lun = ahc_inb(ahc, SAVED_LUN);
		target = SCSIID_TARGET(ahc, saved_scsiid);
		initiator_role_id = SCSIID_OUR_ID(saved_scsiid);
		channel = SCSIID_CHANNEL(ahc, saved_scsiid);
		printerror = 1;
d949 2
a950 3
		if (lastphase == P_MESGOUT) {
			struct ahc_devinfo devinfo;
			u_int tag;
d952 9
a960 49
			ahc_fetch_devinfo(ahc, &devinfo);
			tag = SCB_LIST_NULL;
			if (ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT_TAG, TRUE)
			 || ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT, TRUE)) {
				if (ahc->msgout_buf[ahc->msgout_index - 1]
				 == MSG_ABORT_TAG)
					tag = scb->hscb->tag;
				ahc_print_path(ahc, scb);
				printf("SCB %d - Abort%s Completed.\n",
				       scb->hscb->tag, tag == SCB_LIST_NULL ?
				       "" : " Tag");
				ahc_abort_scbs(ahc, target, channel,
					       saved_lun, tag,
					       ROLE_INITIATOR,
					       CAM_REQ_ABORTED);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_1B,
						MSG_BUS_DEV_RESET, TRUE)) {
				struct ahc_devinfo devinfo;
#ifdef __FreeBSD__
				/*
				 * Don't mark the user's request for this BDR
				 * as completing with CAM_BDR_SENT.  CAM3
				 * specifies CAM_REQ_CMP.
				 */
				if (scb != NULL
				 && scb->io_ctx->ccb_h.func_code== XPT_RESET_DEV
				 && ahc_match_scb(ahc, scb, target, channel,
						  CAM_LUN_WILDCARD,
						  SCB_LIST_NULL,
						  ROLE_INITIATOR)) {
					ahc_set_transaction_status(scb, CAM_REQ_CMP);
				}
#endif
				ahc_compile_devinfo(&devinfo,
						    initiator_role_id,
						    target,
						    CAM_LUN_WILDCARD,
						    channel,
						    ROLE_INITIATOR);
				ahc_handle_devreset(ahc, &devinfo,
						    CAM_BDR_SENT,
						    "Bus Device Reset",
						    /*verbose_level*/0);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_PPR, FALSE)) {
				struct ahc_initiator_tinfo *tinfo;
				struct ahc_tmode_tstate *tstate;
d962 6
a967 38
				/*
				 * PPR Rejected.  Try non-ppr negotiation
				 * and retry command.
				 */
				tinfo = ahc_fetch_transinfo(ahc,
							    devinfo.channel,
							    devinfo.our_scsiid,
							    devinfo.target,
							    &tstate);
				tinfo->curr.transport_version = 2;
				tinfo->goal.transport_version = 2;
				tinfo->goal.ppr_options = 0;
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_WDTR, FALSE)
				|| ahc_sent_msg(ahc, AHCMSG_EXT,
						MSG_EXT_SDTR, FALSE)) {
				/*
				 * Negotiation Rejected.  Go-async and
				 * retry command.
				 */
				ahc_set_width(ahc, &devinfo,
					      MSG_EXT_WDTR_BUS_8_BIT,
					      AHC_TRANS_CUR|AHC_TRANS_GOAL,
					      /*paused*/TRUE);
				ahc_set_syncrate(ahc, &devinfo,
						/*syncrate*/NULL,
						/*period*/0, /*offset*/0,
						/*ppr_options*/0,
						AHC_TRANS_CUR|AHC_TRANS_GOAL,
						/*paused*/TRUE);
				ahc_qinfifo_requeue_tail(ahc, scb);
				printerror = 0;
			}
		}
		if (printerror != 0) {
			u_int i;
d969 1
a969 2
			if (scb != NULL) {
				u_int tag;
d971 6
a976 35
				if ((scb->hscb->control & TAG_ENB) != 0)
					tag = scb->hscb->tag;
				else
					tag = SCB_LIST_NULL;
				ahc_print_path(ahc, scb);
				ahc_abort_scbs(ahc, target, channel,
					       SCB_GET_LUN(scb), tag,
					       ROLE_INITIATOR,
					       CAM_UNEXP_BUSFREE);
			} else {
				/*
				 * We had not fully identified this connection,
				 * so we cannot abort anything.
				 */
				printf("%s: ", ahc_name(ahc));
			}
			for (i = 0; i < num_phases; i++) {
				if (lastphase == ahc_phase_table[i].phase)
					break;
			}
			printf("Unexpected busfree %s\n"
			       "SEQADDR == 0x%x\n",
			       ahc_phase_table[i].phasemsg,
			       ahc_inb(ahc, SEQADDR0)
				| (ahc_inb(ahc, SEQADDR1) << 8));
		}
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
		ahc_restart(ahc);
	} else {
		printf("%s: Missing case in ahc_handle_scsiint. status = %x\n",
		       ahc_name(ahc), status);
		ahc_outb(ahc, CLRINT, CLRSCSIINT);
	}
}
d978 1
a978 8
#define AHC_MAX_STEPS 2000
void
ahc_clear_critical_section(struct ahc_softc *ahc)
{
	int	stepping;
	int	steps;
	u_int	simode0;
	u_int	simode1;
d980 3
a982 2
	if (ahc->num_critical_sections == 0)
		return;
d984 6
a989 25
	stepping = FALSE;
	steps = 0;
	simode0 = 0;
	simode1 = 0;
	for (;;) {
		struct	cs *cs;
		u_int	seqaddr;
		u_int	i;

		seqaddr = ahc_inb(ahc, SEQADDR0)
			| (ahc_inb(ahc, SEQADDR1) << 8);

		/*
		 * Seqaddr represents the next instruction to execute, 
		 * so we are really executing the instruction just
		 * before it.
		 */
		if (seqaddr != 0)
			seqaddr -= 1;
		cs = ahc->critical_sections;
		for (i = 0; i < ahc->num_critical_sections; i++, cs++) {
			
			if (cs->begin < seqaddr && cs->end >= seqaddr)
				break;
		}
d991 1
a991 2
		if (i == ahc->num_critical_sections)
			break;
d993 4
a996 6
		if (steps > AHC_MAX_STEPS) {
			printf("%s: Infinite loop in critical section\n",
			       ahc_name(ahc));
			ahc_dump_card_state(ahc);
			panic("critical section loop");
		}
d998 1
a998 2
		steps++;
		if (stepping == FALSE) {
d1000 1
a1000 24
			/*
			 * Disable all interrupt sources so that the
			 * sequencer will not be stuck by a pausing
			 * interrupt condition while we attempt to
			 * leave a critical section.
			 */
			simode0 = ahc_inb(ahc, SIMODE0);
			ahc_outb(ahc, SIMODE0, 0);
			simode1 = ahc_inb(ahc, SIMODE1);
			ahc_outb(ahc, SIMODE1, 0);
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
			ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) | STEP);
			stepping = TRUE;
		}
		ahc_outb(ahc, HCNTRL, ahc->unpause);
		do {
			ahc_delay(200);
		} while (!ahc_is_paused(ahc));
	}
	if (stepping) {
		ahc_outb(ahc, SIMODE0, simode0);
		ahc_outb(ahc, SIMODE1, simode1);
		ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) & ~STEP);
	}
d1003 3
a1005 5
/*
 * Clear any pending interrupt status.
 */
void
ahc_clear_intstat(struct ahc_softc *ahc)
d1007 1
a1007 7
	/* Clear any interrupt conditions this may have caused */
	ahc_outb(ahc, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
				|CLRBUSFREE|CLRSCSIPERR|CLRPHASECHG|
				CLRREQINIT);
	ahc_outb(ahc, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO);
	ahc_outb(ahc, CLRINT, CLRSCSIINT);
}
d1009 1
a1009 5
/**************************** Debugging Routines ******************************/
void
ahc_print_scb(struct scb *scb)
{
	int i;
d1011 5
a1015 1
	struct hardware_scb *hscb = scb->hscb;
d1017 6
a1022 22
	printf("scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n",
	       (void *)scb,
	       hscb->control,
	       hscb->scsiid,
	       hscb->lun,
	       hscb->cdb_len);
	printf("Shared Data: ");
	for (i = 0; i < sizeof(hscb->shared_data.cdb); i++)
		printf("%#02x", hscb->shared_data.cdb[i]);
	printf("        dataptr:%#x datacnt:%#x sgptr:%#x tag:%#x\n",
		ahc_le32toh(hscb->dataptr),
		ahc_le32toh(hscb->datacnt),
		ahc_le32toh(hscb->sgptr),
		hscb->tag);
	if (scb->sg_count > 0) {
		for (i = 0; i < scb->sg_count; i++) {
			printf("sg[%d] - Addr 0x%x%x : Length %d\n",
			       i,
			       (ahc_le32toh(scb->sg_list[i].len) >> 24
			        & SG_HIGH_ADDR_BITS),
			       ahc_le32toh(scb->sg_list[i].addr),
			       ahc_le32toh(scb->sg_list[i].len));
d1025 16
d1043 5
a1047 7
/************************* Transfer Negotiation *******************************/
/*
 * Allocate per target mode instance (ID we respond to as a target)
 * transfer negotiation data structures.
 */
static struct ahc_tmode_tstate *
ahc_alloc_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel)
d1049 2
a1050 3
	struct ahc_tmode_tstate *master_tstate;
	struct ahc_tmode_tstate *tstate;
	int i;
d1052 5
a1056 12
	master_tstate = ahc->enabled_targets[ahc->our_id];
	if (channel == 'B') {
		scsi_id += 8;
		master_tstate = ahc->enabled_targets[ahc->our_id_b + 8];
	}
	if (ahc->enabled_targets[scsi_id] != NULL
	 && ahc->enabled_targets[scsi_id] != master_tstate)
		panic("%s: ahc_alloc_tstate - Target already allocated",
		      ahc_name(ahc));
	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
	if (tstate == NULL)
		return (NULL);
d1058 1
d1060 1
a1060 4
	 * If we have allocated a master tstate, copy user settings from
	 * the master tstate (taken from SRAM or the EEPROM) for this
	 * channel, but reset our current and goal settings to async/narrow
	 * until an initiator talks to us.
d1062 8
a1069 14
	if (master_tstate != NULL) {
		memcpy(tstate, master_tstate, sizeof(*tstate));
		memset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));
		tstate->ultraenb = 0;
		for (i = 0; i < 16; i++) {
			memset(&tstate->transinfo[i].curr, 0,
			      sizeof(tstate->transinfo[i].curr));
			memset(&tstate->transinfo[i].goal, 0,
			      sizeof(tstate->transinfo[i].goal));
		}
	} else
		memset(tstate, 0, sizeof(*tstate));
	ahc->enabled_targets[scsi_id] = tstate;
	return (tstate);
d1072 3
a1074 7
#ifdef AHC_TARGET_MODE
/*
 * Free per target mode instance (ID we respond to as a target)
 * transfer negotiation data structures.
 */
static void
ahc_free_tstate(struct ahc_softc *ahc, u_int scsi_id, char channel, int force)
d1076 8
a1083 2
	struct ahc_tmode_tstate *tstate;

d1085 1
a1085 2
	 * Don't clean up our "master" tstate.
	 * It has our default user settings.
d1087 10
a1096 4
	if (((channel == 'B' && scsi_id == ahc->our_id_b)
	  || (channel == 'A' && scsi_id == ahc->our_id))
	 && force == FALSE)
		return;
d1098 22
a1119 6
	if (channel == 'B')
		scsi_id += 8;
	tstate = ahc->enabled_targets[scsi_id];
	if (tstate != NULL)
		free(tstate, M_DEVBUF);
	ahc->enabled_targets[scsi_id] = NULL;
a1120 1
#endif
d1125 1
a1125 2
 * by the capabilities of the bus connectivity of and sync settings for
 * the target.
d1127 5
a1131 5
struct ahc_syncrate *
ahc_devlimited_syncrate(struct ahc_softc *ahc,
			struct ahc_initiator_tinfo *tinfo,
			u_int *period, u_int *ppr_options, role_t role) {
	struct	ahc_transinfo *transinfo;
d1137 1
a1137 1
			maxsync = AHC_SYNCRATE_DT;
a1139 2
			/* Can't do DT on an SE bus */
			*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1146 1
a1146 22
	/*
	 * Never allow a value higher than our current goal
	 * period otherwise we may allow a target initiated
	 * negotiation to go above the limit as set by the
	 * user.  In the case of an initiator initiated
	 * sync negotiation, we limit based on the user
	 * setting.  This allows the system to still accept
	 * incoming negotiations even if target initiated
	 * negotiation is not performed.
	 */
	if (role == ROLE_TARGET)
		transinfo = &tinfo->user;
	else 
		transinfo = &tinfo->goal;
	*ppr_options &= transinfo->ppr_options;
	if (transinfo->period == 0) {
		*period = 0;
		*ppr_options = 0;
		return (NULL);
	}
	*period = MAX(*period, transinfo->period);
	return (ahc_find_syncrate(ahc, period, ppr_options, maxsync));
d1154 5
a1158 3
struct ahc_syncrate *
ahc_find_syncrate(struct ahc_softc *ahc, u_int *period,
		  u_int *ppr_options, u_int maxsync)
d1162 4
a1165 19
	if ((ahc->features & AHC_DT) == 0)
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;

	/* Skip all DT only entries if DT is not available */
	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0
	 && maxsync < AHC_SYNCRATE_ULTRA2)
		maxsync = AHC_SYNCRATE_ULTRA2;
	
	for (syncrate = &ahc_syncrates[maxsync];
	     syncrate->rate != NULL;
	     syncrate++) {

		/*
		 * The Ultra2 table doesn't go as low
		 * as for the Fast/Ultra cards.
		 */
		if ((ahc->features & AHC_ULTRA2) != 0
		 && (syncrate->sxfr_u2 == 0))
			break;
a1180 7

			/*
			 * At some speeds, we only support
			 * ST transfers.
			 */
		 	if ((syncrate->sxfr_u2 & ST_SXFR) != 0)
				*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1183 1
a1192 1
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
d1197 5
a1201 6
/*
 * Convert from an entry in our syncrate table to the SCSI equivalent
 * sync "period" factor.
 */
u_int
ahc_find_period(struct ahc_softc *ahc, u_int scsirate, u_int maxsync)
d1226 6
a1231 9
/*
 * Truncate the given synchronous offset to a value the
 * current adapter type and syncrate are capable of.
 */
void
ahc_validate_offset(struct ahc_softc *ahc,
		    struct ahc_initiator_tinfo *tinfo,
		    struct ahc_syncrate *syncrate,
		    u_int *offset, int wide, role_t role)
d1244 1
a1244 36
			maxoffset = MAX_OFFSET_8BIT;
	}
	*offset = MIN(*offset, maxoffset);
	if (tinfo != NULL) {
		if (role == ROLE_TARGET)
			*offset = MIN(*offset, tinfo->user.offset);
		else
			*offset = MIN(*offset, tinfo->goal.offset);
	}
}

/*
 * Truncate the given transfer width parameter to a value the
 * current adapter type is capable of.
 */
void
ahc_validate_width(struct ahc_softc *ahc, struct ahc_initiator_tinfo *tinfo,
		   u_int *bus_width, role_t role)
{
	switch (*bus_width) {
	default:
		if (ahc->features & AHC_WIDE) {
			/* Respond Wide */
			*bus_width = MSG_EXT_WDTR_BUS_16_BIT;
			break;
		}
		/* FALLTHROUGH */
	case MSG_EXT_WDTR_BUS_8_BIT:
		*bus_width = MSG_EXT_WDTR_BUS_8_BIT;
		break;
	}
	if (tinfo != NULL) {
		if (role == ROLE_TARGET)
			*bus_width = MIN(tinfo->user.width, *bus_width);
		else
			*bus_width = MIN(tinfo->goal.width, *bus_width);
d1246 1
d1249 17
a1265 23
/*
 * Update the bitmask of targets for which the controller should
 * negotiate with at the next convenient oportunity.  This currently
 * means the next time we send the initial identify messages for
 * a new transaction.
 */
int
ahc_update_neg_request(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		       struct ahc_tmode_tstate *tstate,
		       struct ahc_initiator_tinfo *tinfo, int force)
{
	u_int auto_negotiate_orig;

	auto_negotiate_orig = tstate->auto_negotiate;
	if (tinfo->curr.period != tinfo->goal.period
	 || tinfo->curr.width != tinfo->goal.width
	 || tinfo->curr.offset != tinfo->goal.offset
	 || tinfo->curr.ppr_options != tinfo->goal.ppr_options
	 || (force
	  && (tinfo->goal.period != 0
	   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT
	   || tinfo->goal.ppr_options != 0)))
		tstate->auto_negotiate |= devinfo->target_mask;
d1267 22
a1288 1
		tstate->auto_negotiate &= ~devinfo->target_mask;
d1290 4
a1293 1
	return (auto_negotiate_orig != tstate->auto_negotiate);
d1296 10
a1305 12
/*
 * Update the user/goal/curr tables of synchronous negotiation
 * parameters as well as, in the case of a current or active update,
 * any data structures on the host controller.  In the case of an
 * active update, the specified target is currently talking to us on
 * the bus, so the transfer parameter update must take effect
 * immediately.
 */
void
ahc_set_syncrate(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		 struct ahc_syncrate *syncrate, u_int period,
		 u_int offset, u_int ppr_options, u_int type, int paused)
d1308 1
a1308 1
	struct	ahc_tmode_tstate *tstate;
d1311 1
a1311 6
	u_int	old_ppr;
	int	active;
	int	update_needed;

	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
	update_needed = 0;
d1318 2
a1319 1
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
d1321 2
a1322 16

	if ((type & AHC_TRANS_USER) != 0) {
		tinfo->user.period = period;
		tinfo->user.offset = offset;
		tinfo->user.ppr_options = ppr_options;
	}

	if ((type & AHC_TRANS_GOAL) != 0) {
		tinfo->goal.period = period;
		tinfo->goal.offset = offset;
		tinfo->goal.ppr_options = ppr_options;
	}

	old_period = tinfo->curr.period;
	old_offset = tinfo->curr.offset;
	old_ppr	   = tinfo->curr.ppr_options;
d1325 1
a1325 3
	 && (old_period != period
	  || old_offset != offset
	  || old_ppr != ppr_options)) {
a1327 1
		update_needed++;
d1331 2
d1334 5
a1338 7
			if (syncrate != NULL) {
				scsirate |= syncrate->sxfr_u2;
				if ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0)
					scsirate |= ENABLE_CRC;
				else
					scsirate |= SINGLE_EDGE;
			}
d1365 1
a1365 1
		if (active) {
a1366 3
			if ((ahc->features & AHC_ULTRA2) != 0)
				ahc_outb(ahc, SCSIOFFSET, offset);
		}
d1369 20
a1388 18
		tinfo->curr.period = period;
		tinfo->curr.offset = offset;
		tinfo->curr.ppr_options = ppr_options;

		ahc_send_async(ahc, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (1 /*bootverbose*/) {
			if (offset != 0) {
				printf("%s: target %d synchronous at %sMHz%s, "
				       "offset = 0x%x\n", ahc_name(ahc),
				       devinfo->target, syncrate->rate,
				       (ppr_options & MSG_EXT_PPR_DT_REQ)
				       ? " DT" : "", offset);
			} else {
				printf("%s: target %d using "
				       "asynchronous transfers\n",
				       ahc_name(ahc), devinfo->target);
			}
d1392 9
a1400 2
	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
						tinfo, /*force*/FALSE);
d1402 3
a1404 2
	if (update_needed)
		ahc_update_pending_scbs(ahc);
d1407 8
a1414 11
/*
 * Update the user/goal/curr tables of wide negotiation
 * parameters as well as, in the case of a current or active update,
 * any data structures on the host controller.  In the case of an
 * active update, the specified target is currently talking to us on
 * the bus, so the transfer parameter update must take effect
 * immediately.
 */
void
ahc_set_width(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
	      u_int width, u_int type, int paused)
d1416 4
a1419 5
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	u_int	oldwidth;
	int	active;
	int	update_needed;
d1421 5
a1425 10
	active = (type & AHC_TRANS_ACTIVE) == AHC_TRANS_ACTIVE;
	update_needed = 0;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);

	if ((type & AHC_TRANS_USER) != 0)
		tinfo->user.width = width;

	if ((type & AHC_TRANS_GOAL) != 0)
		tinfo->goal.width = width;
a1426 1
	oldwidth = tinfo->curr.width;
a1429 1
		update_needed++;
d1440 1
a1440 72
		tinfo->curr.width = width;

		ahc_send_async(ahc, devinfo->channel, devinfo->target,
			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
		if (bootverbose) {
			printf("%s: target %d using %dbit transfers\n",
			       ahc_name(ahc), devinfo->target,
			       8 * (0x01 << width));
		}
	}

	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
						tinfo, /*force*/FALSE);
	if (update_needed)
		ahc_update_pending_scbs(ahc);
}

/*
 * Update the current state of tagged queuing for a given target.
 */
void
ahc_set_tags(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
	     ahc_queue_alg alg)
{
 	ahc_platform_set_tags(ahc, devinfo, alg);
 	ahc_send_async(ahc, devinfo->channel, devinfo->target,
 		       devinfo->lun, AC_TRANSFER_NEG, &alg);
}

/*
 * When the transfer settings for a connection change, update any
 * in-transit SCBs to contain the new data so the hardware will
 * be set correctly during future (re)selections.
 */
static void
ahc_update_pending_scbs(struct ahc_softc *ahc)
{
	struct	scb *pending_scb;
	int	pending_scb_count;
	int	i;
	int	paused;
	u_int	saved_scbptr;

	/*
	 * Traverse the pending SCB list and ensure that all of the
	 * SCBs there have the proper settings.
	 */
	pending_scb_count = 0;
	LIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {
		struct ahc_devinfo devinfo;
		struct hardware_scb *pending_hscb;
		struct ahc_initiator_tinfo *tinfo;
		struct ahc_tmode_tstate *tstate;

		ahc_scb_devinfo(ahc, &devinfo, pending_scb);
		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
					    devinfo.our_scsiid,
					    devinfo.target, &tstate);
		pending_hscb = pending_scb->hscb;
		pending_hscb->control &= ~ULTRAENB;
		if ((tstate->ultraenb & devinfo.target_mask) != 0)
			pending_hscb->control |= ULTRAENB;
		pending_hscb->scsirate = tinfo->scsirate;
		pending_hscb->scsioffset = tinfo->curr.offset;
		if ((tstate->auto_negotiate & devinfo.target_mask) == 0
		 && (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {
			pending_scb->flags &= ~SCB_AUTO_NEGOTIATE;
			pending_hscb->control &= ~MK_MESSAGE;
		}
		ahc_sync_scb(ahc, pending_scb,
			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
		pending_scb_count++;
d1443 4
a1446 8
	if (pending_scb_count == 0)
		return;

	if (ahc_is_paused(ahc)) {
		paused = 1;
	} else {
		paused = 0;
		ahc_pause(ahc);
d1449 4
a1452 6
	saved_scbptr = ahc_inb(ahc, SCBPTR);
	/* Ensure that the hscbs down on the card match the new information */
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		struct	hardware_scb *pending_hscb;
		u_int	control;
		u_int	scb_tag;
d1454 2
a1455 18
		ahc_outb(ahc, SCBPTR, i);
		scb_tag = ahc_inb(ahc, SCB_TAG);
		pending_scb = ahc_lookup_scb(ahc, scb_tag);
		if (pending_scb == NULL)
			continue;

		pending_hscb = pending_scb->hscb;
		control = ahc_inb(ahc, SCB_CONTROL);
		control &= ~(ULTRAENB|MK_MESSAGE);
		control |= pending_hscb->control & (ULTRAENB|MK_MESSAGE);
		ahc_outb(ahc, SCB_CONTROL, control);
		ahc_outb(ahc, SCB_SCSIRATE, pending_hscb->scsirate);
		ahc_outb(ahc, SCB_SCSIOFFSET, pending_hscb->scsioffset);
	}
	ahc_outb(ahc, SCBPTR, saved_scbptr);

	if (paused == 0)
		ahc_unpause(ahc);
d1458 5
a1462 3
/**************************** Pathing Information *****************************/
static void
ahc_fetch_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
d1464 2
a1465 3
	u_int	saved_scsiid;
	role_t	role;
	int	our_id;
d1467 9
a1475 161
	if (ahc_inb(ahc, SSTAT0) & TARGET)
		role = ROLE_TARGET;
	else
		role = ROLE_INITIATOR;

	if (role == ROLE_TARGET
	 && (ahc->features & AHC_MULTI_TID) != 0
	 && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
		/* We were selected, so pull our id from TARGIDIN */
		our_id = ahc_inb(ahc, TARGIDIN) & OID;
	} else if ((ahc->features & AHC_ULTRA2) != 0)
		our_id = ahc_inb(ahc, SCSIID_ULTRA2) & OID;
	else
		our_id = ahc_inb(ahc, SCSIID) & OID;

	saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
	ahc_compile_devinfo(devinfo,
			    our_id,
			    SCSIID_TARGET(ahc, saved_scsiid),
			    ahc_inb(ahc, SAVED_LUN),
			    SCSIID_CHANNEL(ahc, saved_scsiid),
			    role);
}

struct ahc_phase_table_entry*
ahc_lookup_phase_entry(int phase)
{
	struct ahc_phase_table_entry *entry;
	struct ahc_phase_table_entry *last_entry;

	/*
	 * num_phases doesn't include the default entry which
	 * will be returned if the phase doesn't match.
	 */
	last_entry = &ahc_phase_table[num_phases];
	for (entry = ahc_phase_table; entry < last_entry; entry++) {
		if (phase == entry->phase)
			break;
	}
	return (entry);
}

void
ahc_compile_devinfo(struct ahc_devinfo *devinfo, u_int our_id, u_int target,
		    u_int lun, char channel, role_t role)
{
	devinfo->our_scsiid = our_id;
	devinfo->target = target;
	devinfo->lun = lun;
	devinfo->target_offset = target;
	devinfo->channel = channel;
	devinfo->role = role;
	if (channel == 'B')
		devinfo->target_offset += 8;
	devinfo->target_mask = (0x01 << devinfo->target_offset);
}

static void
ahc_scb_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		struct scb *scb)
{
	role_t	role;
	int	our_id;

	our_id = SCSIID_OUR_ID(scb->hscb->scsiid);
	role = ROLE_INITIATOR;
	if ((scb->hscb->control & TARGET_SCB) != 0)
		role = ROLE_TARGET;
	ahc_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahc, scb),
			    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahc, scb), role);
}


/************************ Message Phase Processing ****************************/
static void
ahc_assert_atn(struct ahc_softc *ahc)
{
	u_int scsisigo;

	scsisigo = ATNO;
	if ((ahc->features & AHC_DT) == 0)
		scsisigo |= ahc_inb(ahc, SCSISIGI);
	ahc_outb(ahc, SCSISIGO, scsisigo);
}

/*
 * When an initiator transaction with the MK_MESSAGE flag either reconnects
 * or enters the initial message out phase, we are interrupted.  Fill our
 * outgoing message buffer with the appropriate message and beging handing
 * the message phase(s) manually.
 */
static void
ahc_setup_initiator_msgout(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
			   struct scb *scb)
{
	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if ((scb->flags & SCB_DEVICE_RESET) == 0
	 && ahc_inb(ahc, MSG_OUT) == MSG_IDENTIFYFLAG) {
		u_int identify_msg;

		identify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);
		if ((scb->hscb->control & DISCENB) != 0)
			identify_msg |= MSG_IDENTIFY_DISCFLAG;
		ahc->msgout_buf[ahc->msgout_index++] = identify_msg;
		ahc->msgout_len++;

		if ((scb->hscb->control & TAG_ENB) != 0) {
			ahc->msgout_buf[ahc->msgout_index++] =
			    scb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);
			ahc->msgout_buf[ahc->msgout_index++] = scb->hscb->tag;
			ahc->msgout_len += 2;
		}
	}

	if (scb->flags & SCB_DEVICE_RESET) {
		ahc->msgout_buf[ahc->msgout_index++] = MSG_BUS_DEV_RESET;
		ahc->msgout_len++;
		ahc_print_path(ahc, scb);
		printf("Bus Device Reset Message Sent\n");
		/*
		 * Clear our selection hardware in advance of
		 * the busfree.  We may have an entry in the waiting
		 * Q for this target, and we don't want to go about
		 * selecting while we handle the busfree and blow it
		 * away.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else if ((scb->flags & SCB_ABORT) != 0) {
		if ((scb->hscb->control & TAG_ENB) != 0)
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT_TAG;
		else
			ahc->msgout_buf[ahc->msgout_index++] = MSG_ABORT;
		ahc->msgout_len++;
		ahc_print_path(ahc, scb);
		printf("Abort%s Message Sent\n",
		       (scb->hscb->control & TAG_ENB) != 0 ? " Tag" : "");
		/*
		 * Clear our selection hardware in advance of
		 * the busfree.  We may have an entry in the waiting
		 * Q for this target, and we don't want to go about
		 * selecting while we handle the busfree and blow it
		 * away.
		 */
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {
		ahc_build_transfer_msg(ahc, devinfo);
	} else {
		printf("ahc_intr: AWAITING_MSG for an SCB that "
		       "does not have a waiting message\n");
		printf("SCSIID = %x, target_mask = %x\n", scb->hscb->scsiid,
		       devinfo->target_mask);
		panic("SCB = %d, SCB Control = %x, MSG_OUT = %x "
		      "SCB flags = %x", scb->hscb->tag, scb->hscb->control,
		      ahc_inb(ahc, MSG_OUT), scb->flags);
a1476 9

	/*
	 * Clear the MK_MESSAGE flag from the SCB so we aren't
	 * asked to send this message again.
	 */
	ahc_outb(ahc, SCB_CONTROL, ahc_inb(ahc, SCB_CONTROL) & ~MK_MESSAGE);
	scb->hscb->control &= ~MK_MESSAGE;
	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
d1479 7
a1485 25
/*
 * Build an appropriate transfer negotiation message for the
 * currently active target.
 */
static void
ahc_build_transfer_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	/*              
	 * We need to initiate transfer negotiations.
	 * If our current and goal settings are identical,
	 * we want to renegotiate due to a check condition.
	 */             
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	struct	ahc_syncrate *rate;
	int	dowide;
	int	dosync;
	int	doppr;
	int	use_ppr;
	u_int	period;
	u_int	ppr_options;
	u_int	offset;

	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
d1487 3
a1489 15
	 * Filter our period based on the current connection.
	 * If we can't perform DT transfers on this segment (not in LVD
	 * mode for instance), then our decision to issue a PPR message
	 * may change.
	 */
	period = tinfo->goal.period;
	ppr_options = tinfo->goal.ppr_options;
	/* Target initiated PPR is not allowed in the SCSI spec */
	if (devinfo->role == ROLE_TARGET)
		ppr_options = 0;
	rate = ahc_devlimited_syncrate(ahc, tinfo, &period,
				       &ppr_options, devinfo->role);
	dowide = tinfo->curr.width != tinfo->goal.width;
	dosync = tinfo->curr.period != period;
	doppr = tinfo->curr.ppr_options != ppr_options;
d1491 22
a1512 9
	if (!dowide && !dosync && !doppr) {
		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
		dosync = tinfo->goal.period != 0;
		doppr = tinfo->goal.ppr_options != 0;
	}

	if (!dowide && !dosync && !doppr) {
		panic("ahc_intr: AWAITING_MSG for negotiation, "
		      "but no negotiation needed");	
a1514 5
	use_ppr = (tinfo->curr.transport_version >= 3) || doppr;
	/* Target initiated PPR is not allowed in the SCSI spec */
	if (devinfo->role == ROLE_TARGET)
		use_ppr = 0;

d1516 1
a1516 6
	 * Both the PPR message and SDTR message require the
	 * goal syncrate to be limited to what the target device
	 * is capable of handling (based on whether an LVD->SE
	 * expander is on the bus), so combine these two cases.
	 * Regardless, guarantee that if we are using WDTR and SDTR
	 * messages that WDTR comes first.
d1518 3
a1520 1
	if (use_ppr || (dosync && !dowide)) {
d1522 3
a1524 11
		offset = tinfo->goal.offset;
		ahc_validate_offset(ahc, tinfo, rate, &offset,
				    use_ppr ? tinfo->goal.width
					    : tinfo->curr.width,
				    devinfo->role);
		if (use_ppr) {
			ahc_construct_ppr(ahc, devinfo, period, offset,
					  tinfo->goal.width, ppr_options);
		} else {
			ahc_construct_sdtr(ahc, devinfo, period, offset);
		}
d1526 9
a1534 1
		ahc_construct_wdtr(ahc, devinfo, tinfo->goal.width);
d1536 1
d1539 4
a1542 7
/*
 * Build a synchronous negotiation message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_sdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		   u_int period, u_int offset)
d1544 23
a1566 11
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_len += 5;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       devinfo->lun, period, offset);
	}
d1569 8
a1576 7
/*
 * Build a wide negotiateion message in our message
 * buffer based on the input parameters.
 */
static void
ahc_construct_wdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		   u_int bus_width)
d1578 9
a1586 10
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_WDTR;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_len += 4;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending WDTR %x\n",
		       ahc_name(ahc), devinfo->channel, devinfo->target,
		       devinfo->lun, bus_width);
	}
d1590 1
a1590 2
 * Build a parallel protocol request message in our message
 * buffer based on the input parameters.
d1592 2
a1593 4
static void
ahc_construct_ppr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		  u_int period, u_int offset, u_int bus_width,
		  u_int ppr_options)
d1595 77
a1671 14
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR_LEN;
	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR;
	ahc->msgout_buf[ahc->msgout_index++] = period;
	ahc->msgout_buf[ahc->msgout_index++] = 0;
	ahc->msgout_buf[ahc->msgout_index++] = offset;
	ahc->msgout_buf[ahc->msgout_index++] = bus_width;
	ahc->msgout_buf[ahc->msgout_index++] = ppr_options;
	ahc->msgout_len += 8;
	if (bootverbose) {
		printf("(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "
		       "offset %x, ppr_options %x\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target, devinfo->lun,
		       bus_width, period, offset, ppr_options);
d1673 29
d1704 4
a1707 5
/*
 * Clear any active message state.
 */
static void
ahc_clear_msg_state(struct ahc_softc *ahc)
d1709 49
a1757 4
	ahc->msgout_len = 0;
	ahc->msgin_index = 0;
	ahc->msg_type = MSG_TYPE_NONE;
	if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0) {
d1759 5
a1763 2
		 * The target didn't care to respond to our
		 * message request, so clear ATN.
d1765 31
a1795 1
		ahc_outb(ahc, CLRSINT1, CLRATNO);
d1797 91
a1887 2
	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
}
d1889 6
a1894 9
/*
 * Manual message loop handler.
 */
static void
ahc_handle_message_phase(struct ahc_softc *ahc)
{ 
	struct	ahc_devinfo devinfo;
	u_int	bus_phase;
	int	end_session;
d1896 5
a1900 3
	ahc_fetch_devinfo(ahc, &devinfo);
	end_session = FALSE;
	bus_phase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
d1902 48
a1949 7
reswitch:
	switch (ahc->msg_type) {
	case MSG_TYPE_INITIATOR_MSGOUT:
	{
		int lastbyte;
		int phasemis;
		int msgdone;
a1950 6
		if (ahc->msgout_len == 0)
			panic("HOST_MSG_LOOP interrupt with no active message");

		phasemis = bus_phase != P_MESGOUT;
		if (phasemis) {
			if (bus_phase == P_MESGIN) {
d1952 2
a1953 4
				 * Change gears and see if
				 * this messages is of interest to
				 * us or should be passed back to
				 * the sequencer.
d1955 2
a1956 5
				ahc_outb(ahc, CLRSINT1, CLRATNO);
				ahc->send_msg_perror = FALSE;
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGIN;
				ahc->msgin_index = 0;
				goto reswitch;
a1957 8
			end_session = TRUE;
			break;
		}

		if (ahc->send_msg_perror) {
			ahc_outb(ahc, CLRSINT1, CLRATNO);
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
			ahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);
d1959 1
a1959 4
		}

		msgdone	= ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
d1961 2
a1962 3
			 * The target has requested a retry.
			 * Re-assert ATN, reset our message index to
			 * 0, and try again.
d1964 3
a1966 2
			ahc->msgout_index = 0;
			ahc_assert_atn(ahc);
a1967 13

		lastbyte = ahc->msgout_index == (ahc->msgout_len - 1);
		if (lastbyte) {
			/* Last byte is signified by dropping ATN */
			ahc_outb(ahc, CLRSINT1, CLRATNO);
		}

		/*
		 * Clear our interrupt status and present
		 * the next byte on the bus.
		 */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
d1970 12
a1981 1
	case MSG_TYPE_INITIATOR_MSGIN:
d1983 12
a1994 2
		int phasemis;
		int message_done;
d1996 12
a2007 10
		phasemis = bus_phase != P_MESGIN;

		if (phasemis) {
			ahc->msgin_index = 0;
			if (bus_phase == P_MESGOUT
			 && (ahc->send_msg_perror == TRUE
			  || (ahc->msgout_len != 0
			   && ahc->msgout_index == 0))) {
				ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
				goto reswitch;
a2008 3
			end_session = TRUE;
			break;
		}
d2010 3
a2012 2
		/* Pull the byte in without acking it */
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);
d2014 2
a2015 1
		message_done = ahc_parse_msg(ahc, &devinfo);
d2017 19
a2035 16
		if (message_done) {
			/*
			 * Clear our incoming message buffer in case there
			 * is another message following this one.
			 */
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response,
			 * assert ATN so the target takes us to the
			 * message out phase.
			 */
			if (ahc->msgout_len != 0)
				ahc_assert_atn(ahc);
		} else 
			ahc->msgin_index++;
d2037 2
a2038 3
		/* Ack the byte */
		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
		ahc_inb(ahc, SCSIDATL);
d2041 1
a2041 1
	case MSG_TYPE_TARGET_MSGIN:
a2042 6
		int msgdone;
		int msgout_request;

		if (ahc->msgout_len == 0)
			panic("Target MSGIN with no active message");

d2044 9
a2052 4
		 * If we interrupted a mesgout session, the initiator
		 * will not know this until our first REQ.  So, we
		 * only honor mesgout requests after we've sent our
		 * first byte.
d2054 3
a2056 7
		if ((ahc_inb(ahc, SCSISIGI) & ATNI) != 0
		 && ahc->msgout_index > 0)
			msgout_request = TRUE;
		else
			msgout_request = FALSE;

		if (msgout_request) {
d2059 4
a2062 4
			 * Change gears and see if
			 * this messages is of interest to
			 * us or should be passed back to
			 * the sequencer.
d2064 3
a2066 4
			ahc->msg_type = MSG_TYPE_TARGET_MSGOUT;
			ahc_outb(ahc, SCSISIGO, P_MESGOUT | BSYO);
			ahc->msgin_index = 0;
			/* Dummy read to REQ for first byte */
a2067 11
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
			break;
		}

		msgdone = ahc->msgout_index == ahc->msgout_len;
		if (msgdone) {
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
			end_session = TRUE;
			break;
a2068 6

		/*
		 * Present the next byte on the bus.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
d2071 1
a2071 1
	case MSG_TYPE_TARGET_MSGOUT:
a2072 3
		int lastbyte;
		int msgdone;

d2074 6
a2079 2
		 * The initiator signals that this is
		 * the last byte by dropping ATN.
d2081 3
a2083 1
		lastbyte = (ahc_inb(ahc, SCSISIGI) & ATNI) == 0;
d2085 4
a2088 16
		/*
		 * Read the latched byte, but turn off SPIOEN first
		 * so that we don't inadvertantly cause a REQ for the
		 * next byte.
		 */
		ahc_outb(ahc, SXFRCTL0, ahc_inb(ahc, SXFRCTL0) & ~SPIOEN);
		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIDATL);
		msgdone = ahc_parse_msg(ahc, &devinfo);
		if (msgdone == MSGLOOP_TERMINATED) {
			/*
			 * The message is *really* done in that it caused
			 * us to go to bus free.  The sequencer has already
			 * been reset at this point, so pull the ejection
			 * handle.
			 */
			return;
d2090 15
a2104 21
		
		ahc->msgin_index++;

		/*
		 * XXX Read spec about initiator dropping ATN too soon
		 *     and use msgdone to detect it.
		 */
		if (msgdone == MSGLOOP_MSGCOMPLETE) {
			ahc->msgin_index = 0;

			/*
			 * If this message illicited a response, transition
			 * to the Message in phase and send it.
			 */
			if (ahc->msgout_len != 0) {
				ahc_outb(ahc, SCSISIGO, P_MESGIN | BSYO);
				ahc_outb(ahc, SXFRCTL0,
					 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
				ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
				ahc->msgin_index = 0;
				break;
d2107 32
a2138 9

		if (lastbyte)
			end_session = TRUE;
		else {
			/* Ask for the next byte. */
			ahc_outb(ahc, SXFRCTL0,
				 ahc_inb(ahc, SXFRCTL0) | SPIOEN);
		}

d2141 7
d2149 4
a2152 1
		panic("Unknown REQINIT message type");
d2154 8
a2161 6

	if (end_session) {
		ahc_clear_msg_state(ahc);
		ahc_outb(ahc, RETURN_1, EXIT_MSG_LOOP);
	} else
		ahc_outb(ahc, RETURN_1, CONT_MSG_LOOP);
d2164 4
a2167 8
/*
 * See if we sent a particular extended message to the target.
 * If "full" is true, return true only if the target saw the full
 * message.  If "full" is false, return true if the target saw at
 * least the first byte of the message.
 */
static int
ahc_sent_msg(struct ahc_softc *ahc, ahc_msgtype type, u_int msgval, int full)
d2169 12
a2180 2
	int found;
	u_int index;
d2182 14
a2195 2
	found = FALSE;
	index = 0;
d2197 8
a2204 3
	while (index < ahc->msgout_len) {
		if (ahc->msgout_buf[index] == MSG_EXTENDED) {
			u_int end_index;
d2206 20
a2225 3
			end_index = index + 1 + ahc->msgout_buf[index + 1];
			if (ahc->msgout_buf[index+2] == msgval
			 && type == AHCMSG_EXT) {
d2227 19
a2245 9
				if (full) {
					if (ahc->msgout_index > end_index)
						found = TRUE;
				} else if (ahc->msgout_index > index)
					found = TRUE;
			}
			index = end_index;
		} else if (ahc->msgout_buf[index] >= MSG_SIMPLE_TASK
			&& ahc->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
d2247 3
a2249 9
			/* Skip tag type and tag id or residue param*/
			index += 2;
		} else {
			/* Single byte message */
			if (type == AHCMSG_1B
			 && ahc->msgout_buf[index] == msgval
			 && ahc->msgout_index > index)
				found = TRUE;
			index++;
d2251 13
d2265 29
a2293 5
		if (found)
			break;
	}
	return (found);
}
d2295 5
a2299 12
/*
 * Wait for a complete incoming message, parse it, and respond accordingly.
 */
static int
ahc_parse_msg(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	struct	ahc_initiator_tinfo *tinfo;
	struct	ahc_tmode_tstate *tstate;
	int	reject;
	int	done;
	int	response;
	u_int	targ_scsirate;
d2301 16
a2316 41
	done = MSGLOOP_IN_PROG;
	response = FALSE;
	reject = FALSE;
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel, devinfo->our_scsiid,
				    devinfo->target, &tstate);
	targ_scsirate = tinfo->scsirate;

	/*
	 * Parse as much of the message as is availible,
	 * rejecting it if we don't support it.  When
	 * the entire message is availible and has been
	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
	 * that we have parsed an entire message.
	 *
	 * In the case of extended messages, we accept the length
	 * byte outright and perform more checking once we know the
	 * extended message type.
	 */
	switch (ahc->msgin_buf[0]) {
	case MSG_MESSAGE_REJECT:
		response = ahc_handle_msg_reject(ahc, devinfo);
		/* FALLTHROUGH */
	case MSG_NOOP:
		done = MSGLOOP_MSGCOMPLETE;
		break;
	case MSG_EXTENDED:
	{
		/* Wait for enough of the message to begin validation */
		if (ahc->msgin_index < 2)
			break;
		switch (ahc->msgin_buf[2]) {
		case MSG_EXT_SDTR:
		{
			struct	 ahc_syncrate *syncrate;
			u_int	 period;
			u_int	 ppr_options;
			u_int	 offset;
			u_int	 saved_offset;
			
			if (ahc->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
				reject = TRUE;
d2318 3
a2320 1
			}
d2322 19
a2340 8
			/*
			 * Wait until we have both args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_SDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_SDTR_LEN + 1))
a2341 53

			period = ahc->msgin_buf[3];
			ppr_options = 0;
			saved_offset = offset = ahc->msgin_buf[4];
			syncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,
							   &ppr_options,
							   devinfo->role);
			ahc_validate_offset(ahc, tinfo, syncrate, &offset,
					    targ_scsirate & WIDEXFER,
					    devinfo->role);
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received "
				       "SDTR period %x, offset %x\n\t"
				       "Filtered to period %x, offset %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       ahc->msgin_buf[3], saved_offset,
				       period, offset);
			}
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period,
					 offset, ppr_options,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE);

			/*
			 * See if we initiated Sync Negotiation
			 * and didn't have to fall down to async
			 * transfers.
			 */
			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, TRUE)) {
				/* We started it */
				if (saved_offset != offset) {
					/* Went too low - force async */
					reject = TRUE;
				}
			} else {
				/*
				 * Send our own SDTR in reply
				 */
				if (bootverbose
				 && devinfo->role == ROLE_INITIATOR) {
					printf("(%s:%c:%d:%d): Target "
					       "Initiated SDTR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_sdtr(ahc, devinfo,
						   period, offset);
				ahc->msgout_index = 0;
				response = TRUE;
d2343 1
a2343 12
			done = MSGLOOP_MSGCOMPLETE;
			break;
		}
		case MSG_EXT_WDTR:
		{
			u_int bus_width;
			u_int saved_width;
			u_int sending_reply;

			sending_reply = FALSE;
			if (ahc->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
				reject = TRUE;
d2346 3
d2350 2
a2351 9
			/*
			 * Wait until we have our arg before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_WDTR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_WDTR_LEN + 1))
				break;
d2353 9
a2361 28
			bus_width = ahc->msgin_buf[3];
			saved_width = bus_width;
			ahc_validate_width(ahc, tinfo, &bus_width,
					   devinfo->role);
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received WDTR "
				       "%x filtered to %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       saved_width, bus_width);
			}

			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, TRUE)) {
				/*
				 * Don't send a WDTR back to the
				 * target, since we asked first.
				 * If the width went higher than our
				 * request, reject it.
				 */
				if (saved_width > bus_width) {
					reject = TRUE;
					printf("(%s:%c:%d:%d): requested %dBit "
					       "transfers.  Rejecting...\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun,
					       8 * (0x01 << bus_width));
					bus_width = 0;
				}
d2364 2
a2365 1
				 * Send our own WDTR in reply
d2367 1
a2367 13
				if (bootverbose
				 && devinfo->role == ROLE_INITIATOR) {
					printf("(%s:%c:%d:%d): Target "
					       "Initiated WDTR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				}
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_wdtr(ahc, devinfo, bus_width);
				ahc->msgout_index = 0;
				response = TRUE;
				sending_reply = TRUE;
d2369 3
a2371 17
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE);
			/* After a wide message, we are async */
			ahc_set_syncrate(ahc, devinfo,
					 /*syncrate*/NULL, /*period*/0,
					 /*offset*/0, /*ppr_options*/0,
					 AHC_TRANS_ACTIVE, /*paused*/TRUE);
			if (sending_reply == FALSE && reject == FALSE) {

				if (tinfo->goal.period) {
					ahc->msgout_index = 0;
					ahc->msgout_len = 0;
					ahc_build_transfer_msg(ahc, devinfo);
					ahc->msgout_index = 0;
					response = TRUE;
				}
d2373 4
a2376 2
			done = MSGLOOP_MSGCOMPLETE;
			break;
d2378 7
a2384 10
		case MSG_EXT_PPR:
		{
			struct	ahc_syncrate *syncrate;
			u_int	period;
			u_int	offset;
			u_int	bus_width;
			u_int	ppr_options;
			u_int	saved_width;
			u_int	saved_offset;
			u_int	saved_ppr_options;
d2386 3
a2388 4
			if (ahc->msgin_buf[1] != MSG_EXT_PPR_LEN) {
				reject = TRUE;
				break;
			}
d2390 6
a2395 9
			/*
			 * Wait until we have all args before validating
			 * and acting on this message.
			 *
			 * Add one to MSG_EXT_PPR_LEN to account for
			 * the extended message preamble.
			 */
			if (ahc->msgin_index < (MSG_EXT_PPR_LEN + 1))
				break;
d2397 6
a2402 15
			period = ahc->msgin_buf[3];
			offset = ahc->msgin_buf[5];
			bus_width = ahc->msgin_buf[6];
			saved_width = bus_width;
			ppr_options = ahc->msgin_buf[7];
			/*
			 * According to the spec, a DT only
			 * period factor with no DT option
			 * set implies async.
			 */
			if ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0
			 && period == 9)
				offset = 0;
			saved_ppr_options = ppr_options;
			saved_offset = offset;
d2404 3
a2406 17
			/*
			 * Mask out any options we don't support
			 * on any controller.  Transfer options are
			 * only available if we are negotiating wide.
			 */
			ppr_options &= MSG_EXT_PPR_DT_REQ;
			if (bus_width == 0)
				ppr_options = 0;

			ahc_validate_width(ahc, tinfo, &bus_width,
					   devinfo->role);
			syncrate = ahc_devlimited_syncrate(ahc, tinfo, &period,
							   &ppr_options,
							   devinfo->role);
			ahc_validate_offset(ahc, tinfo, syncrate,
					    &offset, bus_width,
					    devinfo->role);
d2408 3
a2410 55
			if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, TRUE)) {
				/*
				 * If we are unable to do any of the
				 * requested options (we went too low),
				 * then we'll have to reject the message.
				 */
				if (saved_width > bus_width
				 || saved_offset != offset
				 || saved_ppr_options != ppr_options) {
					reject = TRUE;
					period = 0;
					offset = 0;
					bus_width = 0;
					ppr_options = 0;
					syncrate = NULL;
				}
			} else {
				if (devinfo->role != ROLE_TARGET)
					printf("(%s:%c:%d:%d): Target "
					       "Initiated PPR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				else
					printf("(%s:%c:%d:%d): Initiator "
					       "Initiated PPR\n",
					       ahc_name(ahc), devinfo->channel,
					       devinfo->target, devinfo->lun);
				ahc->msgout_index = 0;
				ahc->msgout_len = 0;
				ahc_construct_ppr(ahc, devinfo, period, offset,
						  bus_width, ppr_options);
				ahc->msgout_index = 0;
				response = TRUE;
			}
			if (bootverbose) {
				printf("(%s:%c:%d:%d): Received PPR width %x, "
				       "period %x, offset %x,options %x\n"
				       "\tFiltered to width %x, period %x, "
				       "offset %x, options %x\n",
				       ahc_name(ahc), devinfo->channel,
				       devinfo->target, devinfo->lun,
				       saved_width, ahc->msgin_buf[3],
				       saved_offset, saved_ppr_options,
				       bus_width, period, offset, ppr_options);
			}
			ahc_set_width(ahc, devinfo, bus_width,
				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
				      /*paused*/TRUE);
			ahc_set_syncrate(ahc, devinfo,
					 syncrate, period,
					 offset, ppr_options,
					 AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
					 /*paused*/TRUE);
			done = MSGLOOP_MSGCOMPLETE;
			break;
d2412 103
a2514 4
		default:
			/* Unknown extended message.  Reject it. */
			reject = TRUE;
			break;
a2515 1
		break;
a2516 23
	case MSG_BUS_DEV_RESET:
		ahc_handle_devreset(ahc, devinfo,
				    CAM_BDR_SENT,
				    "Bus Device Reset Received",
				    /*verbose_level*/0);
		ahc_restart(ahc);
		done = MSGLOOP_TERMINATED;
		break;
	case MSG_ABORT_TAG:
	case MSG_ABORT:
	case MSG_CLEAR_QUEUE:
#ifdef AHC_TARGET_MODE
		/* Target mode messages */
		if (devinfo->role != ROLE_TARGET) {
			reject = TRUE;
			break;
		}
		ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       devinfo->lun,
			       ahc->msgin_buf[0] == MSG_ABORT_TAG
						  ? SCB_LIST_NULL
						  : ahc_inb(ahc, INITIATOR_TAG),
			       ROLE_TARGET, CAM_REQ_ABORTED);
d2518 23
a2540 3
		tstate = ahc->enabled_targets[devinfo->our_scsiid];
		if (tstate != NULL) {
			struct ahc_tmode_lstate* lstate;
d2542 8
a2549 17
			lstate = tstate->enabled_luns[devinfo->lun];
			if (lstate != NULL) {
				ahc_queue_lstate_event(ahc, lstate,
						       devinfo->our_scsiid,
						       ahc->msgin_buf[0],
						       /*arg*/0);
				ahc_send_lstate_events(ahc, lstate);
			}
		}
		done = MSGLOOP_MSGCOMPLETE;
		break;
#endif
	case MSG_TERM_IO_PROC:
	default:
		reject = TRUE;
		break;
	}
d2551 12
a2562 10
	if (reject) {
		/*
		 * Setup to reject the message.
		 */
		ahc->msgout_index = 0;
		ahc->msgout_len = 1;
		ahc->msgout_buf[0] = MSG_MESSAGE_REJECT;
		done = MSGLOOP_MSGCOMPLETE;
		response = TRUE;
	}
d2564 4
a2567 3
	if (done != MSGLOOP_IN_PROG && !response)
		/* Clear the outgoing message buffer */
		ahc->msgout_len = 0;
d2569 2
a2570 1
	return (done);
d2573 4
a2576 5
/*
 * Process a message reject message.
 */
static int
ahc_handle_msg_reject(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
a2584 2
	struct ahc_initiator_tinfo *tinfo;
	struct ahc_tmode_tstate *tstate;
d2590 2
a2591 4
	scb = ahc_lookup_scb(ahc, scb_index);
	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
				    devinfo->our_scsiid,
				    devinfo->target, &tstate);
d2595 3
a2597 20
	if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_PPR, /*full*/FALSE)) {
		/*
		 * Target does not support the PPR message.
		 * Attempt to negotiate SPI-2 style.
		 */
		if (bootverbose) {
			printf("(%s:%c:%d:%d): PPR Rejected. "
			       "Trying WDTR/SDTR\n",
			       ahc_name(ahc), devinfo->channel,
			       devinfo->target, devinfo->lun);
		}
		tinfo->goal.ppr_options = 0;
		tinfo->curr.transport_version = 2;
		tinfo->goal.transport_version = 2;
		ahc->msgout_index = 0;
		ahc->msgout_len = 0;
		ahc_build_transfer_msg(ahc, devinfo);
		ahc->msgout_index = 0;
		response = 1;
	} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_WDTR, /*full*/FALSE)) {
d2600 6
a2605 4
		printf("(%s:%c:%d:%d): refuses WIDE negotiation.  Using "
		       "8bit transfers\n", ahc_name(ahc),
		       devinfo->channel, devinfo->target, devinfo->lun);
		ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
d2607 1
a2607 1
			      /*paused*/TRUE);
d2615 3
d2619 1
d2622 2
d2626 1
a2626 1
			ahc_build_transfer_msg(ahc, devinfo);
d2630 1
a2630 1
	} else if (ahc_sent_msg(ahc, AHCMSG_EXT, MSG_EXT_SDTR, /*full*/FALSE)) {
d2633 1
a2633 1
				 /*offset*/0, /*ppr_options*/0,
d2635 14
a2648 26
				 /*paused*/TRUE);
		printf("(%s:%c:%d:%d): refuses synchronous negotiation. "
		       "Using asynchronous transfers\n",
		       ahc_name(ahc), devinfo->channel,
		       devinfo->target, devinfo->lun);
	} else if ((scb->hscb->control & MSG_SIMPLE_TASK) != 0) {
		int tag_type;
		int mask;

		tag_type = (scb->hscb->control & MSG_SIMPLE_TASK);

		if (tag_type == MSG_SIMPLE_TASK) {
			printf("(%s:%c:%d:%d): refuses tagged commands.  "
			       "Performing non-tagged I/O\n", ahc_name(ahc),
			       devinfo->channel, devinfo->target, devinfo->lun);
			ahc_set_tags(ahc, devinfo, AHC_QUEUE_NONE);
			mask = ~0x23;
		} else {
			printf("(%s:%c:%d:%d): refuses %s tagged commands.  "
			       "Performing simple queue tagged I/O only\n",
			       ahc_name(ahc), devinfo->channel, devinfo->target,
			       devinfo->lun, tag_type == MSG_ORDERED_TASK
			       ? "ordered" : "head of queue");
			ahc_set_tags(ahc, devinfo, AHC_QUEUE_BASIC);
			mask = ~0x03;
		}
d2654 3
a2656 5
		ahc_outb(ahc, SCB_CONTROL,
			 ahc_inb(ahc, SCB_CONTROL) & mask);
	 	scb->hscb->control &= mask;
		ahc_set_transaction_tag(scb, /*enabled*/FALSE,
					/*type*/MSG_SIMPLE_TASK);
d2658 1
a2658 16
		ahc_assert_atn(ahc);

		/*
		 * This transaction is now at the head of
		 * the untagged queue for this target.
		 */
		if ((ahc->flags & AHC_SCB_BTT) == 0) {
			struct scb_tailq *untagged_q;

			untagged_q =
			    &(ahc->untagged_queues[devinfo->target_offset]);
			TAILQ_INSERT_HEAD(untagged_q, scb, links.tqe);
			scb->flags |= SCB_UNTAGGEDQ;
		}
		ahc_busy_tcl(ahc, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),
			     scb->hscb->tag);
d2665 3
a2667 4
		ahc_search_qinfifo(ahc, SCB_GET_TARGET(ahc, scb),
				   SCB_GET_CHANNEL(ahc, scb),
				   SCB_GET_LUN(scb), /*tag*/SCB_LIST_NULL,
				   ROLE_INITIATOR, CAM_REQUEUE_REQ,
d2680 3
a2682 5
/*
 * Process an ingnore wide residue message.
 */
static void
ahc_handle_ign_wide_residue(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
d2684 5
a2688 2
	u_int scb_index;
	struct scb *scb;
d2690 8
a2697 21
	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	/*
	 * XXX Actually check data direction in the sequencer?
	 * Perhaps add datadir to some spare bits in the hscb?
	 */
	if ((ahc_inb(ahc, SEQ_FLAGS) & DPHASE) == 0
	 || ahc_get_transfer_dir(scb) != CAM_DIR_IN) {
		/*
		 * Ignore the message if we haven't
		 * seen an appropriate data phase yet.
		 */
	} else {
		/*
		 * If the residual occurred on the last
		 * transfer and the transfer request was
		 * expected to end on an odd count, do
		 * nothing.  Otherwise, subtract a byte
		 * and update the residual count accordingly.
		 */
		uint32_t sgptr;
d2699 3
a2701 24
		sgptr = ahc_inb(ahc, SCB_RESIDUAL_SGPTR);
		if ((sgptr & SG_LIST_NULL) != 0
		 && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {
			/*
			 * If the residual occurred on the last
			 * transfer and the transfer request was
			 * expected to end on an odd count, do
			 * nothing.
			 */
		} else {
			struct ahc_dma_seg *sg;
			uint32_t data_cnt;
			uint32_t data_addr;
			uint32_t sglen;

			/* Pull in the rest of the sgptr */
			sgptr |= (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8);
			sgptr &= SG_PTR_MASK;
			data_cnt = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+3) << 24)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+2) << 16)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+1) << 8)
				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT));
d2703 7
a2709 4
			data_addr = (ahc_inb(ahc, SHADDR + 3) << 24)
				  | (ahc_inb(ahc, SHADDR + 2) << 16)
				  | (ahc_inb(ahc, SHADDR + 1) << 8)
				  | (ahc_inb(ahc, SHADDR));
d2711 2
a2712 2
			data_cnt += 1;
			data_addr -= 1;
d2714 3
a2716 12
			sg = ahc_sg_bus_to_virt(scb, sgptr);
			/*
			 * The residual sg ptr points to the next S/G
			 * to load so we must go back one.
			 */
			sg--;
			sglen = ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
			if (sg != scb->sg_list
			 && sglen < (data_cnt & AHC_SG_LEN_MASK)) {

				sg--;
				sglen = ahc_le32toh(sg->len);
d2718 4
a2721 2
				 * Preserve High Address and SG_LIST bits
				 * while setting the count to 1.
d2723 5
a2727 17
				data_cnt = 1 | (sglen & (~AHC_SG_LEN_MASK));
				data_addr = ahc_le32toh(sg->addr)
					  + (sglen & AHC_SG_LEN_MASK) - 1;

				/*
				 * Increment sg so it points to the
				 * "next" sg.
				 */
				sg++;
				sgptr = ahc_sg_virt_to_bus(scb, sg);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 3,
					 sgptr >> 24);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 2,
					 sgptr >> 16);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 1,
					 sgptr >> 8);
				ahc_outb(ahc, SCB_RESIDUAL_SGPTR, sgptr);
d2729 3
d2733 5
a2737 4
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 3, data_cnt >> 24);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 2, data_cnt >> 16);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 1, data_cnt >> 8);
			ahc_outb(ahc, SCB_RESIDUAL_DATACNT, data_cnt);
a2738 2
	}
}
d2740 10
d2751 4
a2754 91
/*
 * Reinitialize the data pointers for the active transfer
 * based on its current residual.
 */
static void
ahc_reinitialize_dataptrs(struct ahc_softc *ahc)
{
	struct	 scb *scb;
	struct	 ahc_dma_seg *sg;
	u_int	 scb_index;
	uint32_t sgptr;
	uint32_t resid;
	uint32_t dataptr;

	scb_index = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scb_index);
	sgptr = (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
	      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
	      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8)
	      |	ahc_inb(ahc, SCB_RESIDUAL_SGPTR);

	sgptr &= SG_PTR_MASK;
	sg = ahc_sg_bus_to_virt(scb, sgptr);

	/* The residual sg_ptr always points to the next sg */
	sg--;

	resid = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 2) << 16)
	      | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT + 1) << 8)
	      | ahc_inb(ahc, SCB_RESIDUAL_DATACNT);

	dataptr = ahc_le32toh(sg->addr)
		+ (ahc_le32toh(sg->len) & AHC_SG_LEN_MASK)
		- resid;
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		u_int dscommand1;

		dscommand1 = ahc_inb(ahc, DSCOMMAND1);
		ahc_outb(ahc, DSCOMMAND1, dscommand1 | HADDLDSEL0);
		ahc_outb(ahc, HADDR,
			 (ahc_le32toh(sg->len) >> 24) & SG_HIGH_ADDR_BITS);
		ahc_outb(ahc, DSCOMMAND1, dscommand1);
	}
	ahc_outb(ahc, HADDR + 3, dataptr >> 24);
	ahc_outb(ahc, HADDR + 2, dataptr >> 16);
	ahc_outb(ahc, HADDR + 1, dataptr >> 8);
	ahc_outb(ahc, HADDR, dataptr);
	ahc_outb(ahc, HCNT + 2, resid >> 16);
	ahc_outb(ahc, HCNT + 1, resid >> 8);
	ahc_outb(ahc, HCNT, resid);
	if ((ahc->features & AHC_ULTRA2) == 0) {
		ahc_outb(ahc, STCNT + 2, resid >> 16);
		ahc_outb(ahc, STCNT + 1, resid >> 8);
		ahc_outb(ahc, STCNT, resid);
	}
}

/*
 * Handle the effects of issuing a bus device reset message.
 */
static void
ahc_handle_devreset(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		    cam_status status, char *message, int verbose_level)
{
#ifdef AHC_TARGET_MODE
	struct ahc_tmode_tstate* tstate;
	u_int lun;
#endif
	int found;

	found = ahc_abort_scbs(ahc, devinfo->target, devinfo->channel,
			       CAM_LUN_WILDCARD, SCB_LIST_NULL, devinfo->role,
			       status);
	
#ifdef AHC_TARGET_MODE
	/*
	 * Send an immediate notify ccb to all target mord peripheral
	 * drivers affected by this action.
	 */
	tstate = ahc->enabled_targets[devinfo->our_scsiid];
	if (tstate != NULL) {
		for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
			struct ahc_tmode_lstate* lstate;

			lstate = tstate->enabled_luns[lun];
			if (lstate == NULL)
				continue;

			ahc_queue_lstate_event(ahc, lstate, devinfo->our_scsiid,
					       MSG_BUS_DEV_RESET, /*arg*/0);
			ahc_send_lstate_events(ahc, lstate);
a2755 2
	}
#endif
d2757 7
a2763 61
	/*
	 * Go back to async/narrow transfers and renegotiate.
	 */
	ahc_set_width(ahc, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
		      AHC_TRANS_CUR, /*paused*/TRUE);
	ahc_set_syncrate(ahc, devinfo, /*syncrate*/NULL,
			 /*period*/0, /*offset*/0, /*ppr_options*/0,
			 AHC_TRANS_CUR, /*paused*/TRUE);
	
	ahc_send_async(ahc, devinfo->channel, devinfo->target,
		       CAM_LUN_WILDCARD, AC_SENT_BDR, NULL);

	if (message != NULL
	 && (verbose_level <= bootverbose))
		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahc_name(ahc),
		       message, devinfo->channel, devinfo->target, found);
}

#ifdef AHC_TARGET_MODE
static void
ahc_setup_target_msgin(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
		       struct scb *scb)
{

	/*              
	 * To facilitate adding multiple messages together,
	 * each routine should increment the index and len
	 * variables instead of setting them explicitly.
	 */             
	ahc->msgout_index = 0;
	ahc->msgout_len = 0;

	if (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)
		ahc_build_transfer_msg(ahc, devinfo);
	else
		panic("ahc_intr: AWAITING target message with no message");

	ahc->msgout_index = 0;
	ahc->msg_type = MSG_TYPE_TARGET_MSGIN;
}
#endif
/**************************** Initialization **********************************/
/*
 * Allocate a controller structure for a new device
 * and perform initial initializion.
 */
struct ahc_softc *
ahc_alloc(void *platform_arg, char *name)
{
	struct  ahc_softc *ahc;
	int	i;

#ifdef __OpenBSD__	/* OpenBSD provides softc! */
	ahc = (struct ahc_softc *)platform_arg;
#else 
#ifndef	__FreeBSD__
	ahc = malloc(sizeof(*ahc), M_DEVBUF, M_NOWAIT);
	if (!ahc) {
		printf("aic7xxx: cannot malloc softc!\n");
		free(name, M_DEVBUF);
		return NULL;
d2765 4
a2768 25
#else
	ahc = device_get_softc((device_t)platform_arg);
#endif
	memset(ahc, 0, sizeof(*ahc));
#endif 
	LIST_INIT(&ahc->pending_scbs);
	/* We don't know our unit number until the OSM sets it */
	ahc->name = name;
	ahc->unit = -1;
	ahc->description = NULL;
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	ahc->chip = AHC_NONE;
	ahc->features = AHC_FENONE;
	ahc->bugs = AHC_BUGNONE;
	ahc->flags = AHC_FNONE;

	for (i = 0; i < 16; i++)
		TAILQ_INIT(&ahc->untagged_queues[i]);
	if (ahc_platform_alloc(ahc, platform_arg) != 0) {
		ahc_free(ahc);
		ahc = NULL;
	}
	return (ahc);
}
d2770 1
a2770 3
int
ahc_softc_init(struct ahc_softc *ahc)
{
d2772 11
a2782 56
	/* The IRQMS bit is only valid on VL and EISA chips */
	if ((ahc->chip & AHC_PCI) == 0)
		ahc->unpause = ahc_inb(ahc, HCNTRL) & IRQMS;
	else
		ahc->unpause = 0;
	ahc->pause = ahc->unpause | PAUSE; 
	/* XXX The shared scb data stuff should be deprecated */
	if (ahc->scb_data == NULL) {
		ahc->scb_data = malloc(sizeof(*ahc->scb_data),
				       M_DEVBUF, M_NOWAIT);
		if (ahc->scb_data == NULL)
			return (ENOMEM);
		memset(ahc->scb_data, 0, sizeof(*ahc->scb_data));
	}

	return (0);
}

void
ahc_softc_insert(struct ahc_softc *ahc)
{
	struct ahc_softc *list_ahc;

#if AHC_PCI_CONFIG > 0
	/*
	 * Second Function PCI devices need to inherit some
	 * settings from function 0.
	 */
	if ((ahc->chip & AHC_BUS_MASK) == AHC_PCI
	 && (ahc->features & AHC_MULTI_FUNC) != 0) {
		TAILQ_FOREACH(list_ahc, &ahc_tailq, links) {
			ahc_dev_softc_t list_pci;
			ahc_dev_softc_t pci;

			list_pci = list_ahc->dev_softc;
			pci = ahc->dev_softc;
			if (ahc_get_pci_slot(list_pci) == ahc_get_pci_slot(pci)
			 && ahc_get_pci_bus(list_pci) == ahc_get_pci_bus(pci)) {
				struct ahc_softc *master;
				struct ahc_softc *slave;

				if (ahc_get_pci_function(list_pci) == 0) {
					master = list_ahc;
					slave = ahc;
				} else {
					master = ahc;
					slave = list_ahc;
				}
				slave->flags &= ~AHC_BIOS_ENABLED; 
				slave->flags |=
				    master->flags & AHC_BIOS_ENABLED;
				slave->flags &= ~AHC_PRIMARY_CHANNEL; 
				slave->flags |=
				    master->flags & AHC_PRIMARY_CHANNEL;
				break;
			}
a2783 2
	}
#endif
d2785 2
a2786 13
	/*
	 * Insertion sort into our list of softcs.
	 */
	list_ahc = TAILQ_FIRST(&ahc_tailq);
	while (list_ahc != NULL
	    && ahc_softc_comp(list_ahc, ahc) <= 0)
		list_ahc = TAILQ_NEXT(list_ahc, links);
	if (list_ahc != NULL)
		TAILQ_INSERT_BEFORE(list_ahc, ahc, links);
	else
		TAILQ_INSERT_TAIL(&ahc_tailq, ahc, links);
	ahc->init_level++;
}
d2788 1
a2788 5
void
ahc_set_unit(struct ahc_softc *ahc, int unit)
{
	ahc->unit = unit;
}
d2790 6
a2795 7
void
ahc_set_name(struct ahc_softc *ahc, char *name)
{
	if (ahc->name != NULL)
		free(ahc->name, M_DEVBUF);
	ahc->name = name;
}
d2797 10
a2806 5
#ifndef __OpenBSD__
void
ahc_free(struct ahc_softc *ahc)
{
	int i;
d2808 3
a2810 25
	ahc_fini_scbdata(ahc);
	switch (ahc->init_level) {
	default:
	case 5:
		ahc_shutdown(ahc);
		TAILQ_REMOVE(&ahc_tailq, ahc, links);
		/* FALLTHROUGH */
	case 4:
		ahc_dmamap_unload(ahc, ahc->shared_data_dmat,
				  ahc->shared_data_dmamap);
		/* FALLTHROUGH */
	case 3:
		ahc_dmamem_free(ahc, ahc->shared_data_dmat, ahc->qoutfifo,
				ahc->shared_data_dmamap);
		ahc_dmamap_destroy(ahc, ahc->shared_data_dmat,
				   ahc->shared_data_dmamap);
		/* FALLTHROUGH */
	case 2:
		ahc_dma_tag_destroy(ahc, ahc->shared_data_dmat);
	case 1:
#ifndef __linux__
		ahc_dma_tag_destroy(ahc, ahc->buffer_dmat);
#endif
		break;
	case 0:
d2813 4
d2818 2
a2819 6
#ifndef __linux__
	ahc_dma_tag_destroy(ahc, ahc->parent_dmat);
#endif
	ahc_platform_free(ahc);
	for (i = 0; i < AHC_NUM_TARGETS; i++) {
		struct ahc_tmode_tstate *tstate;
d2821 11
a2831 4
		tstate = ahc->enabled_targets[i];
		if (tstate != NULL) {
#if AHC_TARGET_MODE
			int j;
d2833 1
a2833 2
			for (j = 0; j < AHC_NUM_LUNS; j++) {
				struct ahc_tmode_lstate *lstate;
d2835 14
a2848 8
				lstate = tstate->enabled_luns[j];
				if (lstate != NULL) {
					xpt_free_path(lstate->path);
					free(lstate, M_DEVBUF);
				}
			}
#endif
			free(tstate, M_DEVBUF);
a2849 15
	}
#if AHC_TARGET_MODE
	if (ahc->black_hole != NULL) {
		xpt_free_path(ahc->black_hole->path);
		free(ahc->black_hole, M_DEVBUF);
	}
#endif
	if (ahc->name != NULL)
		free(ahc->name, M_DEVBUF);
#ifndef __FreeBSD__
	free(ahc, M_DEVBUF);
#endif
	return;
}
#endif /* __OpenBSD__ */
d2851 7
a2857 5
void
ahc_shutdown(void *arg)
{
	struct	ahc_softc *ahc;
	int	i;
d2859 11
a2869 1
	ahc = (struct ahc_softc *)arg;
d2871 5
a2875 5
	/* This will reset most registers to 0, but not all */
	ahc_reset(ahc);
	ahc_outb(ahc, SCSISEQ, 0);
	ahc_outb(ahc, SXFRCTL0, 0);
	ahc_outb(ahc, DSPCISTATUS, 0);
d2877 19
a2895 24
	for (i = TARG_SCSIRATE; i < HA_274_BIOSCTRL; i++)
		ahc_outb(ahc, i, 0);
}

/*
 * Reset the controller and record some information about it
 * that is only availabel just after a reset.
 */
int
ahc_reset(struct ahc_softc *ahc)
{
	u_int	sblkctl;
	u_int	sxfrctl1_a, sxfrctl1_b;
	int	wait;
	
	/*
	 * Preserve the value of the SXFRCTL1 register for all channels.
	 * It contains settings that affect termination and we don't want
	 * to disturb the integrity of the bus.
	 */
	ahc_pause(ahc);
	sxfrctl1_b = 0;
	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7770) {
		u_int sblkctl;
d2898 2
a2899 2
		 * Save channel B's settings in case this chip
		 * is setup for TWIN channel operation.
d2901 2
a2902 6
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		sxfrctl1_b = ahc_inb(ahc, SXFRCTL1);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	sxfrctl1_a = ahc_inb(ahc, SXFRCTL1);
d2904 13
a2916 1
	ahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);
d2918 7
a2924 7
	/*
	 * Ensure that the reset has finished
	 */
	wait = 1000;
	do {
		ahc_delay(1000);
	} while (--wait && !(ahc_inb(ahc, HCNTRL) & CHIPRSTACK));
d2926 1
a2926 3
	if (wait == 0) {
		printf("%s: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", ahc_name(ahc));
a2927 19
	ahc_outb(ahc, HCNTRL, ahc->pause);

	/* Determine channel configuration */
	sblkctl = ahc_inb(ahc, SBLKCTL) & (SELBUSB|SELWIDE);
	/* No Twin Channel PCI cards */
	if ((ahc->chip & AHC_PCI) != 0)
		sblkctl &= ~SELBUSB;
	switch (sblkctl) {
	case 0:
		/* Single Narrow Channel */
		break;
	case 2:
		/* Wide Channel */
		ahc->features |= AHC_WIDE;
		break;
	case 8:
		/* Twin Channel */
		ahc->features |= AHC_TWIN;
		break;
d2929 1
a2929 2
		printf(" Unsupported adapter type.  Ignoring\n");
		return(-1);
d2932 6
a2937 10
	/*
	 * Reload sxfrctl1.
	 *
	 * We must always initialize STPWEN to 1 before we
	 * restore the saved values.  STPWEN is initialized
	 * to a tri-state condition which can only be cleared
	 * by turning it on.
	 */
	if ((ahc->features & AHC_TWIN) != 0) {
		u_int sblkctl;
d2939 14
a2952 6
		sblkctl = ahc_inb(ahc, SBLKCTL);
		ahc_outb(ahc, SBLKCTL, sblkctl | SELBUSB);
		ahc_outb(ahc, SXFRCTL1, sxfrctl1_b);
		ahc_outb(ahc, SBLKCTL, sblkctl & ~SELBUSB);
	}
	ahc_outb(ahc, SXFRCTL1, sxfrctl1_a);
d2954 2
a2955 4
#ifdef AHC_DUMP_SEQ
	if (ahc->init_level == 0)
		ahc_dumpseq(ahc);
#endif
d2957 2
a2958 9
	return (0);
}

/*
 * Determine the number of SCBs available on the controller
 */
int
ahc_probe_scbs(struct ahc_softc *ahc) {
	int i;
d2960 3
a2962 1
	for (i = 0; i < AHC_SCB_MAX; i++) {
d2964 8
a2971 6
		ahc_outb(ahc, SCBPTR, i);
		ahc_outb(ahc, SCB_BASE, i);
		if (ahc_inb(ahc, SCB_BASE) != i)
			break;
		ahc_outb(ahc, SCBPTR, 0);
		if (ahc_inb(ahc, SCB_BASE) != 0)
d2973 9
d2983 1
a2983 1
	return (i);
d2986 5
a2990 3
#ifndef __OpenBSD__
static void
ahc_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) 
d2992 6
a2997 1
	bus_addr_t *baddr;
d2999 6
a3004 4
	baddr = (bus_addr_t *)arg;
	*baddr = segs->ds_addr;
}
#endif 
d3006 30
a3035 23
#ifndef __OpenBSD__
static void
#else
void
#endif 
ahc_build_free_scb_list(struct ahc_softc *ahc)
{
	int i;

	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		ahc_outb(ahc, SCBPTR, i);

		/* Clear the control byte. */
		ahc_outb(ahc, SCB_CONTROL, 0);

		/* Set the next pointer */
		if ((ahc->flags & AHC_PAGESCBS) != 0)
			ahc_outb(ahc, SCB_NEXT, i+1);
		else 
			ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);

		/* Make the tag number invalid */
		ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);
d3037 17
d3055 9
a3063 3
	/* Make sure that the last SCB terminates the free list */
	ahc_outb(ahc, SCBPTR, i-1);
	ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);
d3065 9
a3073 4
	/* Ensure we clear the 0 SCB's control byte. */
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outb(ahc, SCB_CONTROL, 0);
}
d3075 30
a3104 5
#ifndef __OpenBSD__
static int
ahc_init_scbdata(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;
d3106 5
a3110 3
	scb_data = ahc->scb_data;
	SLIST_INIT(&scb_data->free_scbs);
	SLIST_INIT(&scb_data->sg_maps);
d3112 9
a3120 7
	/* Allocate SCB resources */
	scb_data->scbarray =
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX,
				 M_DEVBUF, M_NOWAIT);
	if (scb_data->scbarray == NULL)
		return (ENOMEM);
	memset(scb_data->scbarray, 0, sizeof(struct scb) * AHC_SCB_MAX);
d3122 54
a3175 1
	/* Determine the number of hardware SCBs and initialize them */
d3177 6
a3182 7
	scb_data->maxhscbs = ahc_probe_scbs(ahc);
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		/* SCB 0 heads the free list */
		ahc_outb(ahc, FREE_SCBH, 0);
	} else {
		ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
	}
d3184 28
a3211 3
	if (ahc->scb_data->maxhscbs == 0) {
		printf("%s: No SCB space found\n", ahc_name(ahc));
		return (ENXIO);
d3213 21
d3235 3
a3237 1
	ahc_build_free_scb_list(ahc);
d3239 18
a3256 21
	/*
	 * Create our DMA tags.  These tags define the kinds of device
	 * accessible memory allocations and memory mappings we will
	 * need to perform during normal operation.
	 *
	 * Unless we need to further restrict the allocation, we rely
	 * on the restrictions of the parent dmat, hence the common
	 * use of MAXADDR and MAXSIZE.
	 */

	/* DMA tag for our hardware scb structures */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       AHC_SCB_MAX * sizeof(struct hardware_scb),
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->hscb_dmat) != 0) {
		goto error_exit;
d3259 9
a3267 7
	scb_data->init_level++;

	/* Allocation for our hscbs */
	if (ahc_dmamem_alloc(ahc, scb_data->hscb_dmat,
			     (void **)&scb_data->hscbs,
			     BUS_DMA_NOWAIT, &scb_data->hscb_dmamap) != 0) {
		goto error_exit;
d3270 3
a3272 1
	scb_data->init_level++;
d3274 2
a3275 5
	/* And permanently map them */
	ahc_dmamap_load(ahc, scb_data->hscb_dmat, scb_data->hscb_dmamap,
			scb_data->hscbs,
			AHC_SCB_MAX * sizeof(struct hardware_scb),
			ahc_dmamap_cb, &scb_data->hscb_busaddr, /*flags*/0);
d3277 7
a3283 1
	scb_data->init_level++;
d3285 17
a3301 12
	/* DMA tag for our sense buffers */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->sense_dmat) != 0) {
		goto error_exit;
	}
d3303 17
a3319 1
	scb_data->init_level++;
d3321 4
a3324 6
	/* Allocate them */
	if (ahc_dmamem_alloc(ahc, scb_data->sense_dmat,
			     (void **)&scb_data->sense,
			     BUS_DMA_NOWAIT, &scb_data->sense_dmamap) != 0) {
		goto error_exit;
	}
d3326 2
a3327 1
	scb_data->init_level++;
d3329 1
a3329 5
	/* And permanently map them */
	ahc_dmamap_load(ahc, scb_data->sense_dmat, scb_data->sense_dmamap,
			scb_data->sense,
			AHC_SCB_MAX * sizeof(struct scsi_sense_data),
			ahc_dmamap_cb, &scb_data->sense_busaddr, /*flags*/0);
d3331 22
a3352 1
	scb_data->init_level++;
d3354 3
a3356 11
	/* DMA tag for our S/G structures.  We allocate in page sized chunks */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       PAGE_SIZE, /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &scb_data->sg_dmat) != 0) {
		goto error_exit;
	}
d3358 5
a3362 11
	scb_data->init_level++;

	/* Perform initial CCB allocation */
	memset(scb_data->hscbs, 0, AHC_SCB_MAX * sizeof(struct hardware_scb));
	ahc_alloc_scbs(ahc);

	if (scb_data->numscbs == 0) {
		printf("%s: ahc_init_scbdata - "
		       "Unable to allocate initial scbs\n",
		       ahc_name(ahc));
		goto error_exit;
d3364 1
d3366 9
a3374 5
	/*
	 * Tell the sequencer which SCB will be the next one it receives.
	 */
	ahc->next_queued_scb = ahc_get_scb(ahc);
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);
d3376 4
d3381 3
a3383 1
	 * Note that we were successful
d3385 10
a3394 5
	return (0); 

error_exit:

	return (ENOMEM);
d3397 9
a3405 2
static void
ahc_fini_scbdata(struct ahc_softc *ahc)
d3407 4
a3410 1
	struct scb_data *scb_data;
d3412 3
a3414 3
	scb_data = ahc->scb_data;
	if (scb_data == NULL)
		return;
d3416 1
a3416 5
	switch (scb_data->init_level) {
	default:
	case 7:
	{
		struct sg_map_node *sg_map;
d3418 5
a3422 10
		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps))!= NULL) {
			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
			ahc_dmamap_unload(ahc, scb_data->sg_dmat,
					  sg_map->sg_dmamap);
			ahc_dmamem_free(ahc, scb_data->sg_dmat,
					sg_map->sg_vaddr,
					sg_map->sg_dmamap);
			free(sg_map, M_DEVBUF);
		}
		ahc_dma_tag_destroy(ahc, scb_data->sg_dmat);
d3424 14
a3437 23
	case 6:
		ahc_dmamap_unload(ahc, scb_data->sense_dmat,
				  scb_data->sense_dmamap);
	case 5:
		ahc_dmamem_free(ahc, scb_data->sense_dmat, scb_data->sense,
				scb_data->sense_dmamap);
		ahc_dmamap_destroy(ahc, scb_data->sense_dmat,
				   scb_data->sense_dmamap);
	case 4:
		ahc_dma_tag_destroy(ahc, scb_data->sense_dmat);
	case 3:
		ahc_dmamap_unload(ahc, scb_data->hscb_dmat,
				  scb_data->hscb_dmamap);
	case 2:
		ahc_dmamem_free(ahc, scb_data->hscb_dmat, scb_data->hscbs,
				scb_data->hscb_dmamap);
		ahc_dmamap_destroy(ahc, scb_data->hscb_dmat,
				   scb_data->hscb_dmamap);
	case 1:
		ahc_dma_tag_destroy(ahc, scb_data->hscb_dmat);
		break;
	case 0:
		break;
a3438 3
	if (scb_data->scbarray != NULL)
		free(scb_data->scbarray, M_DEVBUF);
}
d3440 7
a3446 10
void
ahc_alloc_scbs(struct ahc_softc *ahc)
{
	struct scb_data *scb_data;
	struct scb *next_scb;
	struct sg_map_node *sg_map;
	bus_addr_t physaddr;
	struct ahc_dma_seg *segs;
	int newcount;
	int i;
d3448 5
a3452 4
	scb_data = ahc->scb_data;
	if (scb_data->numscbs >= AHC_SCB_MAX)
		/* Can't allocate any more */
		return;
d3454 1
a3454 1
	next_scb = &scb_data->scbarray[scb_data->numscbs];
d3456 8
a3463 1
	sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);
d3465 5
a3469 2
	if (sg_map == NULL)
		return;
d3471 12
a3482 6
	/* Allocate S/G space for the next batch of SCBS */
	if (ahc_dmamem_alloc(ahc, scb_data->sg_dmat,
			     (void **)&sg_map->sg_vaddr,
			     BUS_DMA_NOWAIT, &sg_map->sg_dmamap) != 0) {
		free(sg_map, M_DEVBUF);
		return;
d3485 26
a3510 8
	SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);

	ahc_dmamap_load(ahc, scb_data->sg_dmat, sg_map->sg_dmamap,
			sg_map->sg_vaddr, PAGE_SIZE, ahc_dmamap_cb,
			&sg_map->sg_physaddr, /*flags*/0);

	segs = sg_map->sg_vaddr;
	physaddr = sg_map->sg_physaddr;
d3512 1
a3512 13
	newcount = (PAGE_SIZE / (AHC_NSEG * sizeof(struct ahc_dma_seg)));
	for (i = 0; scb_data->numscbs < AHC_SCB_MAX && i < newcount; i++) {
		struct scb_platform_data *pdata;
#ifndef __linux__
		int error;
#endif
		pdata = (struct scb_platform_data *)malloc(sizeof(*pdata),
							   M_DEVBUF, M_NOWAIT);
		if (pdata == NULL)
			break;
		next_scb->platform_data = pdata;
		next_scb->sg_map = sg_map;
		next_scb->sg_list = segs;
d3514 2
a3515 2
		 * The sequencer always starts with the second entry.
		 * The first entry is embedded in the scb.
d3517 10
a3526 17
		next_scb->sg_list_phys = physaddr + sizeof(struct ahc_dma_seg);
		next_scb->ahc_softc = ahc;
		next_scb->flags = SCB_FREE;
#ifndef __linux__
		error = ahc_dmamap_create(ahc, ahc->buffer_dmat, /*flags*/0,
					  &next_scb->dmamap);
		if (error != 0)
			break;
#endif
		next_scb->hscb = &scb_data->hscbs[scb_data->numscbs];
		next_scb->hscb->tag = ahc->scb_data->numscbs;
		SLIST_INSERT_HEAD(&ahc->scb_data->free_scbs,
				  next_scb, links.sle);
		segs += AHC_NSEG;
		physaddr += (AHC_NSEG * sizeof(struct ahc_dma_seg));
		next_scb++;
		ahc->scb_data->numscbs++;
d3528 11
a3539 1
#endif /* __OpenBSD__ */
d3541 6
a3546 2
void
ahc_controller_info(struct ahc_softc *ahc, char *buf)
d3548 1
a3548 1
	int len;
d3550 8
a3557 26
	len = sprintf(buf, "%s: ", ahc_chip_names[ahc->chip & AHC_CHIPID_MASK]);
	buf += len;
	if ((ahc->features & AHC_TWIN) != 0)
 		len = sprintf(buf, "Twin Channel, A SCSI Id=%d, "
			      "B SCSI Id=%d, primary %c, ",
			      ahc->our_id, ahc->our_id_b,
			      (ahc->flags & AHC_PRIMARY_CHANNEL) + 'A');
	else {
		const char *speed;
		const char *type;

		speed = "";
		if ((ahc->features & AHC_ULTRA) != 0) {
			speed = "Ultra ";
		} else if ((ahc->features & AHC_DT) != 0) {
			speed = "Ultra160 ";
		} else if ((ahc->features & AHC_ULTRA2) != 0) {
			speed = "Ultra2 ";
		}
		if ((ahc->features & AHC_WIDE) != 0) {
			type = "Wide";
		} else {
			type = "Single";
		}
		len = sprintf(buf, "%s%s Channel %c, SCSI Id=%d, ",
			      speed, type, ahc->channel, ahc->our_id);
d3559 2
a3560 7
	buf += len;

	if ((ahc->flags & AHC_PAGESCBS) != 0)
		sprintf(buf, "%d/%d SCBs",
			ahc->scb_data->maxhscbs, AHC_SCB_MAX);
	else
		sprintf(buf, "%d SCBs", ahc->scb_data->maxhscbs);
d3567 2
a3568 1
ahc_init(struct ahc_softc *ahc)
d3570 11
a3580 15
	int	 max_targ;
	int	 i;
	int	 term;
	u_int	 scsi_conf;
	u_int	 scsiseq_template;
	u_int	 ultraenb;
	u_int	 discenable;
	u_int	 tagenable;
	size_t	 driver_data_size;
	uint32_t physaddr;

#define AHC_DEBUG_SEQUENCER
#ifdef AHC_DEBUG_SEQUENCER
	ahc->flags |= AHC_SEQUENCER_DEBUG;
#endif
d3600 10
a3609 1
	max_targ = 15;
d3619 2
a3620 2
	ahc->flags |= AHC_INITIATORROLE;

d3622 7
a3628 1
	 * Only allow target mode features if this unit has them enabled.
d3630 1
a3630 19
	if ((AHC_TMODE_ENABLE & (0x1 << ahc->unit)) == 0)
		ahc->features &= ~AHC_TARGETMODE;

#if !defined(__linux__) && !defined(__OpenBSD__)
	/* DMA tag for mapping buffers into device visible space. */
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       /*maxsize*/MAXBSIZE, /*nsegments*/AHC_NSEG,
			       /*maxsegsz*/AHC_MAXTRANSFER_SIZE,
			       /*flags*/BUS_DMA_ALLOCNOW,
			       &ahc->buffer_dmat) != 0) {
		return (ENOMEM);
	}
#endif

	ahc->init_level++;
d3632 1
a3632 12
	/*
	 * DMA tag for our command fifos and other data in system memory
	 * the card's sequencer must be able to access.  For initiator
	 * roles, we need to allocate space for the the qinfifo and qoutfifo.
	 * The qinfifo and qoutfifo are composed of 256 1 byte elements. 
	 * When providing for the target mode role, we must additionally
	 * provide space for the incoming target command fifo and an extra
	 * byte to deal with a dma bug in some chip versions.
	 */
	driver_data_size = 2 * 256 * sizeof(uint8_t);
#ifdef __OpenBSD__
	if (ahc_createdmamem(ahc, ahc->shared_data_dmat, driver_data_size, 
a3638 1
#else
d3640 4
a3643 23
	if ((ahc->features & AHC_TARGETMODE) != 0)
		driver_data_size += AHC_TMODE_CMDS * sizeof(struct target_cmd)
				 + /*DMA WideOdd Bug Buffer*/1;
	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
			       /*highaddr*/BUS_SPACE_MAXADDR,
			       /*filter*/NULL, /*filterarg*/NULL,
			       driver_data_size,
			       /*nsegments*/1,
			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
			       /*flags*/0, &ahc->shared_data_dmat) != 0) {
		return (ENOMEM);
	}

	ahc->init_level++;

	/* Allocation of driver data */
	if (ahc_dmamem_alloc(ahc, ahc->shared_data_dmat,
			     (void **)&ahc->qoutfifo,
			     BUS_DMA_NOWAIT, &ahc->shared_data_dmamap) != 0) {
		return (ENOMEM);
	}
a3644 21
	ahc->init_level++;

	/* And permanently map it in */
	ahc_dmamap_load(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
			ahc->qoutfifo, driver_data_size, ahc_dmamap_cb,
			&ahc->shared_data_busaddr, /*flags*/0);
	if ((ahc->features & AHC_TARGETMODE) != 0) {
		ahc->targetcmds = (struct target_cmd *)ahc->qoutfifo;
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[AHC_TMODE_CMDS];
		ahc->dma_bug_buf = ahc->shared_data_busaddr
				 + driver_data_size - 1;
		/* All target command blocks start out invalid. */
		for (i = 0; i < AHC_TMODE_CMDS; i++)
			ahc->targetcmds[i].cmd_valid = 0;
		ahc_sync_tqinfifo(ahc, BUS_DMASYNC_PREREAD);
		ahc->tqinfifonext = 1;
		ahc_outb(ahc, KERNEL_TQINPOS, ahc->tqinfifonext - 1);
		ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[256];
	}
#endif 
d3646 4
d3651 3
a3653 6
	ahc->init_level++;

	/* Allocate SCB data now that buffer_dmat is initialized */
	if (ahc->scb_data->maxhscbs == 0)
		if (ahc_init_scbdata(ahc) != 0)
			return (ENOMEM);
d3655 3
d3664 1
a3664 1
		printf("%s: unable to allocate ahc_tmode_tstate.  "
d3666 1
a3666 1
		return (ENOMEM);
d3671 12
a3682 3
			printf("%s: unable to allocate ahc_tmode_tstate.  "
			       "Failing attach\n", ahc_name(ahc));
			return (ENOMEM);
d3684 1
a3687 1
	ahc_outb(ahc, SEQ_FLAGS2, 0);
d3691 1
d3694 1
d3708 1
a3708 1
	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
a3714 1
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
d3716 4
a3719 1
		ahc_outb(ahc, SCSIID, ahc->our_id_b);
d3722 1
a3722 3
					|term|ahc->seltime_b|ENSTIMER|ACTNEGEN);
		if ((ahc->features & AHC_ULTRA2) != 0)
			ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
d3727 1
a3727 1
		 && (ahc->flags & AHC_INITIATORROLE) != 0)
a3732 1
	
d3740 1
a3740 1
				|term|ahc->seltime
a3741 2
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
d3746 1
a3746 1
	 && (ahc->flags & AHC_INITIATORROLE) != 0)
d3778 1
a3778 1
		struct ahc_tmode_tstate *tstate;
d3794 1
a3794 1
		memset(tinfo, 0, sizeof(*tinfo));
d3807 1
a3807 1
			uint16_t mask;
a3827 3
				if ((scsirate & ~WIDEXFER) == 0 && offset != 0)
					/* Set to the lowest sync rate, 5MHz */
					scsirate |= 0x1c;
a3836 4
				if ((scsirate & SXFR_ULTRA2) <= 8/*10MHz*/
				 && (ahc->features & AHC_DT) != 0)
					tinfo->user.ppr_options =
					    MSG_EXT_PPR_DT_REQ;
a3837 6
				if ((scsirate & SXFR) == 0x40
				 && (ultraenb & mask) != 0) {
					/* Treat 10MHz as a non-ultra speed */
					scsirate &= ~SXFR;
				 	ultraenb &= ~mask;
				}
a3845 2
			if (tinfo->user.period == 0)
				tinfo->user.offset = 0;
a3848 9
			tinfo->user.protocol_version = 4;
			if ((ahc->features & AHC_DT) != 0)
				tinfo->user.transport_version = 3;
			else
				tinfo->user.transport_version = 2;
			tinfo->goal.protocol_version = 2;
			tinfo->goal.transport_version = 2;
			tinfo->curr.protocol_version = 2;
			tinfo->curr.transport_version = 2;
d3850 1
d3852 3
a3858 29
	/* There are no untagged SCBs active yet. */
	for (i = 0; i < 16; i++) {
		ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, 0));
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			int lun;

			/*
			 * The SCB based BTT allows an entry per
			 * target and lun pair.
			 */
			for (lun = 1; lun < AHC_NUM_LUNS; lun++)
				ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, lun));
		}
	}

	/* All of our queues are empty */
	for (i = 0; i < 256; i++)
		ahc->qoutfifo[i] = SCB_LIST_NULL;
	
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREREAD);

	for (i = 0; i < 256; i++)
		ahc->qinfifo[i] = SCB_LIST_NULL;

	if ((ahc->features & AHC_MULTI_TID) != 0) {
		ahc_outb(ahc, TARGID, 0);
		ahc_outb(ahc, TARGID + 1, 0);
	}
	
d3869 11
a3879 4
	ahc_outb(ahc, SHARED_DATA_ADDR, physaddr & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 1, (physaddr >> 8) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 2, (physaddr >> 16) & 0xFF);
	ahc_outb(ahc, SHARED_DATA_ADDR + 3, (physaddr >> 24) & 0xFF);
d3900 10
d3921 1
d3933 1
a3933 1
	 * If we are a target, we'll enalbe select in operations once
d3937 1
a3937 1
	if ((ahc->flags & AHC_INITIATORROLE) != 0)
d3951 18
a3968 2
	if ((ahc->features & AHC_ULTRA2) != 0) {
		int wait;
a3969 15
		/*
		 * Wait for up to 500ms for our transceivers
		 * to settle.  If the adapter does not have
		 * a cable attached, the tranceivers may
		 * never settle, so don't complain if we
		 * fail here.
		 */
		ahc_pause(ahc);
		for (wait = 5000;
		     (ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
		     wait--)
			ahc_delay(100);
		ahc_unpause(ahc);
	}
	return (0);
d3972 4
a3975 2
void
ahc_intr_enable(struct ahc_softc *ahc, int enable)
d3977 19
a3995 1
	u_int hcntrl;
d3997 15
a4011 8
	hcntrl = ahc_inb(ahc, HCNTRL);
	hcntrl &= ~INTEN;
	ahc->pause &= ~INTEN;
	ahc->unpause &= ~INTEN;
	if (enable) {
		hcntrl |= INTEN;
		ahc->pause |= INTEN;
		ahc->unpause |= INTEN;
d4013 12
a4024 1
	ahc_outb(ahc, HCNTRL, hcntrl);
d4028 1
a4028 5
 * Ensure that the card is paused in a location
 * outside of all critical sections and that all
 * pending work is completed prior to returning.
 * This routine should only be called from outside
 * an interrupt context.
d4030 2
a4031 2
void
ahc_pause_and_flushwork(struct ahc_softc *ahc)
d4033 2
a4034 2
	int intstat;
	int maxloops;
d4036 8
a4043 8
	maxloops = 1000;
	ahc->flags |= AHC_ALL_INTERRUPTS;
	intstat = 0;
	do {
		ahc_intr(ahc);
		ahc_pause(ahc);
		ahc_clear_critical_section(ahc);
		if (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0)
d4045 1
a4045 5
		maxloops--;
	} while (((intstat = ahc_inb(ahc, INTSTAT)) & INT_PEND) && --maxloops);
	if (maxloops == 0) {
		printf("Infinite interrupt loop, INTSTAT = %x",
		      ahc_inb(ahc, INTSTAT));
d4047 2
a4048 2
	ahc_platform_flushwork(ahc);
	ahc->flags &= ~AHC_ALL_INTERRUPTS;
d4051 3
a4053 2
int
ahc_suspend(struct ahc_softc *ahc)
d4055 15
a4069 2
	uint8_t *ptr;
	int	 i;
d4071 2
a4072 1
	ahc_pause_and_flushwork(ahc);
d4074 24
a4097 2
	if (LIST_FIRST(&ahc->pending_scbs) != NULL)
		return (EBUSY);
d4099 3
a4101 1
#if AHC_TARGET_MODE
d4103 2
a4104 3
	 * XXX What about ATIOs that have not yet been serviced?
	 * Perhaps we should just refuse to be suspended if we
	 * are acting in a target role.
d4106 14
a4119 37
	if (ahc->pending_device != NULL)
		return (EBUSY);
#endif
	
	/* Save volatile registers */
	if ((ahc->features & AHC_TWIN) != 0) {
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		ahc->suspend_state.channel[1].scsiseq = ahc_inb(ahc, SCSISEQ);
		ahc->suspend_state.channel[1].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
		ahc->suspend_state.channel[1].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
		ahc->suspend_state.channel[1].simode0 = ahc_inb(ahc, SIMODE0);
		ahc->suspend_state.channel[1].simode1 = ahc_inb(ahc, SIMODE1);
		ahc->suspend_state.channel[1].seltimer = ahc_inb(ahc, SELTIMER);
		ahc->suspend_state.channel[1].seqctl = ahc_inb(ahc, SEQCTL);
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
	}
	ahc->suspend_state.channel[0].scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc->suspend_state.channel[0].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
	ahc->suspend_state.channel[0].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
	ahc->suspend_state.channel[0].simode0 = ahc_inb(ahc, SIMODE0);
	ahc->suspend_state.channel[0].simode1 = ahc_inb(ahc, SIMODE1);
	ahc->suspend_state.channel[0].seltimer = ahc_inb(ahc, SELTIMER);
	ahc->suspend_state.channel[0].seqctl = ahc_inb(ahc, SEQCTL);

	if ((ahc->chip & AHC_PCI) != 0) {
		ahc->suspend_state.dscommand0 = ahc_inb(ahc, DSCOMMAND0);
		ahc->suspend_state.dspcistatus = ahc_inb(ahc, DSPCISTATUS);
	}

	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;

		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc->suspend_state.optionmode = ahc_inb(ahc, OPTIONMODE);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc->suspend_state.crccontrol1 = ahc_inb(ahc, CRCCONTROL1);
d4122 4
a4125 2
	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc->suspend_state.scbbaddr = ahc_inb(ahc, SCBBADDR);
d4127 14
a4140 2
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc->suspend_state.dff_thrsh = ahc_inb(ahc, DFF_THRSH);
d4142 8
a4149 3
	ptr = ahc->suspend_state.scratch_ram;
	for (i = 0; i < 64; i++)
		*ptr++ = ahc_inb(ahc, SRAM_BASE + i);
a4150 3
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0; i < 16; i++)
			*ptr++ = ahc_inb(ahc, TARG_OFFSET + i);
d4153 4
a4156 4
	ptr = ahc->suspend_state.btt;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		for (i = 0;i < AHC_NUM_TARGETS; i++) {
			int j;
d4158 4
a4161 2
			for (j = 0;j < AHC_NUM_LUNS; j++) {
				u_int tcl;
d4163 4
a4166 3
				tcl = BUILD_TCL(i << 4, j);
				*ptr = ahc_index_busy_tcl(ahc, tcl);
			}
d4168 13
a4181 3
	ahc_shutdown(ahc);
	return (0);
}
d4183 1
a4183 5
int
ahc_resume(struct ahc_softc *ahc)
{
	uint8_t *ptr;
	int	 i;
d4185 10
a4194 1
	ahc_reset(ahc);
d4196 4
a4199 1
	ahc_build_free_scb_list(ahc);
d4201 11
a4211 12
	/* Restore volatile registers */
	if ((ahc->features & AHC_TWIN) != 0) {
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
		ahc_outb(ahc, SCSIID, ahc->our_id);
		ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[1].scsiseq);
		ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[1].sxfrctl0);
		ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[1].sxfrctl1);
		ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[1].simode0);
		ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[1].simode1);
		ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[1].seltimer);
		ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[1].seqctl);
		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
a4212 11
	ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[0].scsiseq);
	ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[0].sxfrctl0);
	ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[0].sxfrctl1);
	ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[0].simode0);
	ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[0].simode1);
	ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[0].seltimer);
	ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[0].seqctl);
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);
	else
		ahc_outb(ahc, SCSIID, ahc->our_id);
d4214 18
a4231 3
	if ((ahc->chip & AHC_PCI) != 0) {
		ahc_outb(ahc, DSCOMMAND0, ahc->suspend_state.dscommand0);
		ahc_outb(ahc, DSPCISTATUS, ahc->suspend_state.dspcistatus);
d4234 7
a4240 2
	if ((ahc->features & AHC_DT) != 0) {
		u_int sfunct;
d4242 5
a4246 5
		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
		ahc_outb(ahc, OPTIONMODE, ahc->suspend_state.optionmode);
		ahc_outb(ahc, SFUNCT, sfunct);
		ahc_outb(ahc, CRCCONTROL1, ahc->suspend_state.crccontrol1);
d4249 2
a4250 2
	if ((ahc->features & AHC_MULTI_FUNC) != 0)
		ahc_outb(ahc, SCBBADDR, ahc->suspend_state.scbbaddr);
d4252 10
a4261 2
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, DFF_THRSH, ahc->suspend_state.dff_thrsh);
d4263 3
a4265 3
	ptr = ahc->suspend_state.scratch_ram;
	for (i = 0; i < 64; i++)
		ahc_outb(ahc, SRAM_BASE + i, *ptr++);
a4266 4
	if ((ahc->features & AHC_MORE_SRAM) != 0) {
		for (i = 0; i < 16; i++)
			ahc_outb(ahc, TARG_OFFSET + i, *ptr++);
	}
d4268 4
a4271 4
	ptr = ahc->suspend_state.btt;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		for (i = 0;i < AHC_NUM_TARGETS; i++) {
			int j;
d4273 1
a4273 2
			for (j = 0;j < AHC_NUM_LUNS; j++) {
				u_int tcl;
d4275 12
a4286 3
				tcl = BUILD_TCL(i << 4, j);
				ahc_busy_tcl(ahc, tcl, *ptr);
			}
d4288 31
a4319 2
	return (0);
}
d4321 4
a4324 10
/************************** Busy Target Table *********************************/
/*
 * Return the untagged transaction id for a given target/channel lun.
 * Optionally, clear the entry.
 */
u_int
ahc_index_busy_tcl(struct ahc_softc *ahc, u_int tcl)
{
	u_int scbid;
	u_int target_offset;
d4326 1
a4326 2
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
d4328 19
a4346 4
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		scbid = ahc_inb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl));
		ahc_outb(ahc, SCBPTR, saved_scbptr);
d4348 13
a4360 2
		target_offset = TCL_TARGET_OFFSET(tcl);
		scbid = ahc_inb(ahc, BUSY_TARGETS + target_offset);
d4363 10
a4372 7
	return (scbid);
}

void
ahc_unbusy_tcl(struct ahc_softc *ahc, u_int tcl)
{
	u_int target_offset;
d4374 3
a4376 10
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
		
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		ahc_outb(ahc, SCB_64_BTT+TCL_TARGET_OFFSET(tcl), SCB_LIST_NULL);
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		ahc_outb(ahc, BUSY_TARGETS + target_offset, SCB_LIST_NULL);
d4378 14
d4394 10
a4403 4
void
ahc_busy_tcl(struct ahc_softc *ahc, u_int tcl, u_int scbid)
{
	u_int target_offset;
d4405 4
a4408 2
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		u_int saved_scbptr;
d4410 2
a4411 8
		saved_scbptr = ahc_inb(ahc, SCBPTR);
		ahc_outb(ahc, SCBPTR, TCL_LUN(tcl));
		ahc_outb(ahc, SCB_64_BTT + TCL_TARGET_OFFSET(tcl), scbid);
		ahc_outb(ahc, SCBPTR, saved_scbptr);
	} else {
		target_offset = TCL_TARGET_OFFSET(tcl);
		ahc_outb(ahc, BUSY_TARGETS + target_offset, scbid);
	}
d4414 5
a4418 4
/************************** SCB and SCB queue management **********************/
int
ahc_match_scb(struct ahc_softc *ahc, struct scb *scb, int target,
	      char channel, int lun, u_int tag, role_t role)
d4420 8
a4427 4
	int targ = SCB_GET_TARGET(ahc, scb);
	char chan = SCB_GET_CHANNEL(ahc, scb);
	int slun = SCB_GET_LUN(scb);
	int match;
d4429 3
a4431 8
	match = ((chan == channel) || (channel == ALL_CHANNELS));
	if (match != 0)
		match = ((targ == target) || (target == CAM_TARGET_WILDCARD));
	if (match != 0)
		match = ((lun == slun) || (lun == CAM_LUN_WILDCARD));
	if (match != 0) {
#if AHC_TARGET_MODE
		int group;
d4433 16
a4448 13
		group = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);
		if (role == ROLE_INITIATOR) {
			match = (group != XPT_FC_GROUP_TMODE)
			      && ((tag == scb->hscb->tag)
			       || (tag == SCB_LIST_NULL));
		} else if (role == ROLE_TARGET) {
			match = (group == XPT_FC_GROUP_TMODE)
			      && ((tag == scb->io_ctx->csio.tag_id)
			       || (tag == SCB_LIST_NULL));
		}
#else /* !AHC_TARGET_MODE */
		match = ((tag == scb->hscb->tag) || (tag == SCB_LIST_NULL));
#endif /* AHC_TARGET_MODE */
a4449 2

	return match;
d4452 4
a4455 2
void
ahc_freeze_devq(struct ahc_softc *ahc, struct scb *scb)
d4461 3
a4463 3
	target = SCB_GET_TARGET(ahc, scb);
	lun = SCB_GET_LUN(scb);
	channel = SCB_GET_CHANNEL(ahc, scb);
d4466 79
a4544 4
			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
			   CAM_REQUEUE_REQ, SEARCH_COMPLETE);

	ahc_platform_freeze_devq(ahc, scb);
d4547 4
a4550 2
void
ahc_qinfifo_requeue_tail(struct ahc_softc *ahc, struct scb *scb)
d4552 2
a4553 1
	struct scb *prev_scb;
d4555 6
a4560 4
	prev_scb = NULL;
	if (ahc_qinfifo_count(ahc) != 0) {
		u_int prev_tag;
		uint8_t prev_pos;
d4562 5
a4566 11
		prev_pos = ahc->qinfifonext - 1;
		prev_tag = ahc->qinfifo[prev_pos];
		prev_scb = ahc_lookup_scb(ahc, prev_tag);
	}
	ahc_qinfifo_requeue(ahc, prev_scb, scb);
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}
}
d4568 5
a4572 10
static void
ahc_qinfifo_requeue(struct ahc_softc *ahc, struct scb *prev_scb,
		    struct scb *scb)
{
	if (prev_scb == NULL) {
		ahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);
	} else {
		prev_scb->hscb->next = scb->hscb->tag;
		ahc_sync_scb(ahc, prev_scb, 
			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
a4573 3
	ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;
	scb->hscb->next = ahc->next_queued_scb->hscb->tag;
	ahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
d4575 1
d4577 3
a4579 2
static int
ahc_qinfifo_count(struct ahc_softc *ahc)
d4581 5
a4585 2
	u_int8_t qinpos;
	u_int8_t diff;
d4587 5
a4591 8
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		qinpos = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinpos);
	} else
		qinpos = ahc_inb(ahc, QINPOS);
	diff = ahc->qinfifonext - qinpos;
	return (diff);
}
d4593 6
a4598 16
int
ahc_search_qinfifo(struct ahc_softc *ahc, int target, char channel,
		   int lun, u_int tag, role_t role, uint32_t status,
		   ahc_search_action action)
{
	struct	scb *scb;
	struct	scb *prev_scb;
	uint8_t qinstart;
	uint8_t qinpos;
	uint8_t qintail;
	uint8_t next, prev;
	uint8_t curscbptr;
	int	found;
	int	maxtarget;
	int	i;
	int	have_qregs;
d4600 2
a4601 36
	qintail = ahc->qinfifonext;
	have_qregs = (ahc->features & AHC_QUEUE_REGS) != 0;
	if (have_qregs) {
		qinstart = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinstart);
	} else
		qinstart = ahc_inb(ahc, QINPOS);
	qinpos = qinstart;
	next = ahc_inb(ahc, NEXT_QUEUED_SCB);
	found = 0;
	prev_scb = NULL;
	
	if (action == SEARCH_COMPLETE) {
		/*
		 * Don't attempt to run any queued untagged transactions
		 * until we are done with the abort process.
		 */
		ahc_freeze_untagged_queues(ahc);
	}

	/*
	 * Start with an empty queue.  Entries that are not chosen
	 * for removal will be re-added to the queue as we go.
	 */
	ahc->qinfifonext = qinpos;
	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);

	while (qinpos != qintail) {
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinpos]);
		if (scb == NULL) {
			printf("qinpos = %d, SCB index = %d\n",
				qinpos, ahc->qinfifo[qinpos]);
			panic("Loop 1");
		}

		if (ahc_match_scb(ahc, scb, target, channel, lun, tag, role)) {
d4603 2
a4604 1
			 * We found an scb that needs to be acted on.
d4606 1
a4606 29
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;

				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb,
								   status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in qinfifo\n");
				ahc_done(ahc, scb);
				/* FALLTHROUGH */
			}
			case SEARCH_REMOVE:
				break;
			case SEARCH_COUNT:
				ahc_qinfifo_requeue(ahc, prev_scb, scb);
				prev_scb = scb;
				break;
			}
		} else {
			ahc_qinfifo_requeue(ahc, prev_scb, scb);
			prev_scb = scb;
d4608 2
a4609 1
		qinpos++;
d4611 2
d4614 3
a4616 5
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
	} else {
		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
	}
d4618 10
a4627 16
	if (action != SEARCH_COUNT
	 && (found != 0)
	 && (qinstart != ahc->qinfifonext)) {
		/*
		 * The sequencer may be in the process of dmaing
		 * down the SCB at the beginning of the queue.
		 * This could be problematic if either the first,
		 * or the second SCB is removed from the queue
		 * (the first SCB includes a pointer to the "next"
		 * SCB to dma). If we have removed any entries, swap
		 * the first element in the queue with the next HSCB
		 * so the sequencer will notice that NEXT_QUEUED_SCB
		 * has changed during its dma attempt and will retry
		 * the DMA.
		 */
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qinstart]);
d4629 3
a4631 25
		if (scb == NULL) {
			printf("found = %d, qinstart = %d, qinfifionext = %d\n",
				found, qinstart, ahc->qinfifonext);
			panic("First/Second Qinfifo fixup");
		}
		/*
		 * ahc_swap_with_next_hscb forces our next pointer to
		 * point to the reserved SCB for future commands.  Save
		 * and restore our original next pointer to maintain
		 * queue integrity.
		 */
		next = scb->hscb->next;
		ahc->scb_data->scbindex[scb->hscb->tag] = NULL;
		ahc_swap_with_next_hscb(ahc, scb);
		scb->hscb->next = next;
		ahc->qinfifo[qinstart] = scb->hscb->tag;

		/* Tell the card about the new head of the qinfifo. */
		ahc_outb(ahc, NEXT_QUEUED_SCB, scb->hscb->tag);

		/* Fixup the tail "next" pointer. */
		qintail = ahc->qinfifonext - 1;
		scb = ahc_lookup_scb(ahc, ahc->qinfifo[qintail]);
		scb->hscb->next = ahc->next_queued_scb->hscb->tag;
	}
d4633 1
a4633 6
	/*
	 * Search waiting for selection list.
	 */
	curscbptr = ahc_inb(ahc, SCBPTR);
	next = ahc_inb(ahc, WAITING_SCBH);  /* Start at head of list. */
	prev = SCB_LIST_NULL;
d4635 1
a4635 2
	while (next != SCB_LIST_NULL) {
		uint8_t scb_index;
d4637 7
a4643 19
		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			printf("Waiting List inconsistency. "
			       "SCB index == %d, yet numscbs == %d.",
			       scb_index, ahc->scb_data->numscbs);
			ahc_dump_card_state(ahc);
			panic("for safety");
		}
		scb = ahc_lookup_scb(ahc, scb_index);
		if (scb == NULL) {
			printf("scb_index = %d, next = %d\n",
				scb_index, next);
			panic("Waiting List traversal");
		}
		if (ahc_match_scb(ahc, scb, target, channel,
				  lun, SCB_LIST_NULL, role)) {
			/*
			 * We found an scb that needs to be acted on.
d4645 1
a4645 31
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;

				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb,
								   status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in Waiting List\n");
				ahc_done(ahc, scb);
				/* FALLTHROUGH */
			}
			case SEARCH_REMOVE:
				next = ahc_rem_wscb(ahc, next, prev);
				break;
			case SEARCH_COUNT:
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
				break;
			}
		} else {
			
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
a4647 1
	ahc_outb(ahc, SCBPTR, curscbptr);
d4649 23
a4671 5
	/*
	 * And lastly, the untagged holding queues.
	 */
	i = 0;
	if ((ahc->flags & AHC_SCB_BTT) == 0) {
d4673 2
a4674 2
		maxtarget = 16;
		if (target != CAM_TARGET_WILDCARD) {
d4676 17
a4692 8
			i = target;
			if (channel == 'B')
				i += 8;
			maxtarget = i + 1;
		}
	} else {
		maxtarget = 0;
	}
d4694 5
a4698 3
	for (; i < maxtarget; i++) {
		struct scb_tailq *untagged_q;
		struct scb *next_scb;
d4700 1
a4700 3
		untagged_q = &(ahc->untagged_queues[i]);
		next_scb = TAILQ_FIRST(untagged_q);
		while (next_scb != NULL) {
d4702 1
a4702 2
			scb = next_scb;
			next_scb = TAILQ_NEXT(scb, links.tqe);
d4704 2
a4705 11
			/*
			 * The head of the list may be the currently
			 * active untagged command for a device.
			 * We're only searching for commands that
			 * have not been started.  A transaction
			 * marked active but still in the qinfifo
			 * is removed by the qinfifo scanning code
			 * above.
			 */
			if ((scb->flags & SCB_ACTIVE) != 0)
				continue;
d4707 5
a4711 31
			if (ahc_match_scb(ahc, scb, target, channel,
					  lun, SCB_LIST_NULL, role)) {
				/*
				 * We found an scb that needs to be acted on.
				 */
				found++;
				switch (action) {
				case SEARCH_COMPLETE:
				{
					cam_status ostat;
					cam_status cstat;

					ostat = ahc_get_transaction_status(scb);
					if (ostat == CAM_REQ_INPROG)
						ahc_set_transaction_status(scb,
								   status);
					cstat = ahc_get_transaction_status(scb);
					if (cstat != CAM_REQ_CMP)
						ahc_freeze_scb(scb);
					if ((scb->flags & SCB_ACTIVE) == 0)
						printf("Inactive SCB in untaggedQ\n");
					ahc_done(ahc, scb);
					break;
				}
				case SEARCH_REMOVE:
					TAILQ_REMOVE(untagged_q, scb,
						     links.tqe);
					break;
				case SEARCH_COUNT:
					break;
				}
d4714 3
d4718 14
d4733 3
a4735 4
	if (action == SEARCH_COMPLETE)
		ahc_release_untagged_queues(ahc);
	return (found);
}
d4737 14
a4750 47
int
ahc_search_disc_list(struct ahc_softc *ahc, int target, char channel,
		     int lun, u_int tag, int stop_on_first, int remove,
		     int save_state)
{
	struct	scb *scbp;
	u_int	next;
	u_int	prev;
	u_int	count;
	u_int	active_scb;

	count = 0;
	next = ahc_inb(ahc, DISCONNECTED_SCBH);
	prev = SCB_LIST_NULL;

	if (save_state) {
		/* restore this when we're done */
		active_scb = ahc_inb(ahc, SCBPTR);
	} else
		/* Silence compiler */
		active_scb = SCB_LIST_NULL;

	while (next != SCB_LIST_NULL) {
		u_int scb_index;

		ahc_outb(ahc, SCBPTR, next);
		scb_index = ahc_inb(ahc, SCB_TAG);
		if (scb_index >= ahc->scb_data->numscbs) {
			printf("Disconnected List inconsistency. "
			       "SCB index == %d, yet numscbs == %d.",
			       scb_index, ahc->scb_data->numscbs);
			ahc_dump_card_state(ahc);
			panic("for safety");
		}

		if (next == prev) {
			panic("Disconnected List Loop. "
			      "cur SCBPTR == %x, prev SCBPTR == %x.",
			      next, prev);
		}
		scbp = ahc_lookup_scb(ahc, scb_index);
		if (ahc_match_scb(ahc, scbp, target, channel, lun,
				  tag, ROLE_INITIATOR)) {
			count++;
			if (remove) {
				next =
				    ahc_rem_scb_from_disc_list(ahc, prev, next);
d4752 6
a4757 2
				prev = next;
				next = ahc_inb(ahc, SCB_NEXT);
a4758 5
			if (stop_on_first)
				break;
		} else {
			prev = next;
			next = ahc_inb(ahc, SCB_NEXT);
d4760 6
a4766 3
	if (save_state)
		ahc_outb(ahc, SCBPTR, active_scb);
	return (count);
d4769 4
a4772 32
/*
 * Remove an SCB from the on chip list of disconnected transactions.
 * This is empty/unused if we are not performing SCB paging.
 */
static u_int
ahc_rem_scb_from_disc_list(struct ahc_softc *ahc, u_int prev, u_int scbptr)
{
	u_int next;

	ahc_outb(ahc, SCBPTR, scbptr);
	next = ahc_inb(ahc, SCB_NEXT);

	ahc_outb(ahc, SCB_CONTROL, 0);

	ahc_add_curscb_to_free_list(ahc);

	if (prev != SCB_LIST_NULL) {
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
	} else
		ahc_outb(ahc, DISCONNECTED_SCBH, next);

	return (next);
}

/*
 * Add the SCB as selected by SCBPTR onto the on chip list of
 * free hardware SCBs.  This list is empty/unused if we are not
 * performing SCB paging.
 */
static void
ahc_add_curscb_to_free_list(struct ahc_softc *ahc)
a4773 28
	/*
	 * Invalidate the tag so that our abort
	 * routines don't think it's active.
	 */
	ahc_outb(ahc, SCB_TAG, SCB_LIST_NULL);

	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		ahc_outb(ahc, SCB_NEXT, ahc_inb(ahc, FREE_SCBH));
		ahc_outb(ahc, FREE_SCBH, ahc_inb(ahc, SCBPTR));
	}
}

/*
 * Manipulate the waiting for selection list and return the
 * scb that follows the one that we remove.
 */
static u_int
ahc_rem_wscb(struct ahc_softc *ahc, u_int scbpos, u_int prev)
{       
	u_int curscb, next;

	/*
	 * Select the SCB we want to abort and
	 * pull the next pointer out of it.
	 */
	curscb = ahc_inb(ahc, SCBPTR);
	ahc_outb(ahc, SCBPTR, scbpos);
	next = ahc_inb(ahc, SCB_NEXT);
d4775 2
a4776 4
	/* Clear the necessary fields */
	ahc_outb(ahc, SCB_CONTROL, 0);

	ahc_add_curscb_to_free_list(ahc);
d4778 1
a4778 4
	/* update the waiting list */
	if (prev == SCB_LIST_NULL) {
		/* First in the list */
		ahc_outb(ahc, WAITING_SCBH, next); 
d4781 3
a4783 2
		 * Ensure we aren't attempting to perform
		 * selection for this entry.
d4785 2
a4786 2
		ahc_outb(ahc, SCSISEQ, (ahc_inb(ahc, SCSISEQ) & ~ENSELO));
	} else {
d4788 3
a4790 2
		 * Select the scb that pointed to us 
		 * and update its next pointer.
d4792 5
a4796 2
		ahc_outb(ahc, SCBPTR, prev);
		ahc_outb(ahc, SCB_NEXT, next);
a4797 6

	/*
	 * Point us back at the original scb position.
	 */
	ahc_outb(ahc, SCBPTR, curscb);
	return next;
d4800 2
a4801 10
/******************************** Error Handling ******************************/
/*
 * Abort all SCBs that match the given description (target/channel/lun/tag),
 * setting their status to the passed in status if the status has not already
 * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
 * is paused before it is called.
 */
int
ahc_abort_scbs(struct ahc_softc *ahc, int target, char channel,
	       int lun, u_int tag, role_t role, uint32_t status)
d4803 8
a4810 15
	struct	scb *scbp;
	struct	scb *scbp_next;
	u_int	active_scb;
	int	i, j;
	int	maxtarget;
	int	minlun;
	int	maxlun;

	int	found;

	/*
	 * Don't attempt to run any queued untagged transactions
	 * until we are done with the abort process.
	 */
	ahc_freeze_untagged_queues(ahc);
d4812 2
a4813 2
	/* restore this when we're done */
	active_scb = ahc_inb(ahc, SCBPTR);
d4815 1
a4815 2
	found = ahc_search_qinfifo(ahc, target, channel, lun, SCB_LIST_NULL,
				   role, CAM_REQUEUE_REQ, SEARCH_COMPLETE);
d4818 4
a4821 1
	 * Clean out the busy target table for any untagged commands.
d4823 4
a4826 8
	i = 0;
	maxtarget = 16;
	if (target != CAM_TARGET_WILDCARD) {
		i = target;
		if (channel == 'B')
			i += 8;
		maxtarget = i + 1;
	}
d4828 6
a4833 20
	if (lun == CAM_LUN_WILDCARD) {

		/*
		 * Unless we are using an SCB based
		 * busy targets table, there is only
		 * one table entry for all luns of
		 * a target.
		 */
		minlun = 0;
		maxlun = 1;
		if ((ahc->flags & AHC_SCB_BTT) != 0)
			maxlun = AHC_NUM_LUNS;
	} else {
		minlun = lun;
		maxlun = lun + 1;
	}

	for (;i < maxtarget; i++) {
		for (j = minlun;j < maxlun; j++)
			ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, j));
d4836 3
a4838 9
	/*
	 * Go through the disconnected list and remove any entries we
	 * have queued for completion, 0'ing their control byte too.
	 * We save the active SCB and restore it ourselves, so there
	 * is no reason for this search to restore it too.
	 */
	ahc_search_disc_list(ahc, target, channel, lun, tag,
			     /*stop_on_first*/FALSE, /*remove*/TRUE,
			     /*save_state*/FALSE);
d4840 2
d4843 2
a4844 2
	 * Go through the hardware SCB array looking for commands that
	 * were active but not on any list.
d4846 1
a4846 2
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		u_int scbid;
d4848 3
a4850 6
		ahc_outb(ahc, SCBPTR, i);
		scbid = ahc_inb(ahc, SCB_TAG);
		scbp = ahc_lookup_scb(ahc, scbid);
		if (scbp != NULL
		 && ahc_match_scb(ahc, scbp, target, channel, lun, tag, role))
			ahc_add_curscb_to_free_list(ahc);
d4852 30
a4881 23

	/*
	 * Go through the pending CCB list and look for
	 * commands for this target that are still active.
	 * These are other tagged commands that were
	 * disconnected when the reset occurred.
	 */
	scbp_next = LIST_FIRST(&ahc->pending_scbs);
	while (scbp_next != NULL) {
		scbp = scbp_next;
		scbp_next = LIST_NEXT(scbp, pending_links);
		if (ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)) {
			cam_status ostat;

			ostat = ahc_get_transaction_status(scbp);
			if (ostat == CAM_REQ_INPROG)
				ahc_set_transaction_status(scbp, status);
			if (ahc_get_transaction_status(scbp) != CAM_REQ_CMP)
				ahc_freeze_scb(scbp);
			if ((scbp->flags & SCB_ACTIVE) == 0)
				printf("Inactive SCB on pending list\n");
			ahc_done(ahc, scbp);
			found++;
d4884 35
a4918 5
	ahc_outb(ahc, SCBPTR, active_scb);
	ahc_platform_abort_scbs(ahc, target, channel, lun, tag, role, status);
	ahc_release_untagged_queues(ahc);
	return found;
}
d4920 1
a4920 4
static void
ahc_reset_current_bus(struct ahc_softc *ahc)
{
	uint8_t scsiseq;
d4922 3
a4924 6
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) & ~ENSCSIRST);
	scsiseq = ahc_inb(ahc, SCSISEQ);
	ahc_outb(ahc, SCSISEQ, scsiseq | SCSIRSTO);
	ahc_delay(AHC_BUSRESET_DELAY);
	/* Turn off the bus reset */
	ahc_outb(ahc, SCSISEQ, scsiseq & ~SCSIRSTO);
d4926 22
a4947 1
	ahc_clear_intstat(ahc);
d4949 2
a4950 3
	/* Re-enable reset interrupts */
	ahc_outb(ahc, SIMODE1, ahc_inb(ahc, SIMODE1) | ENSCSIRST);
}
d4952 8
a4959 11
int
ahc_reset_channel(struct ahc_softc *ahc, char channel, int initiate_reset)
{
	struct	ahc_devinfo devinfo;
	u_int	initiator, target, max_scsiid;
	u_int	sblkctl;
	u_int	scsiseq;
	u_int	simode1;
	int	found;
	int	restart_needed;
	char	cur_channel;
d4961 5
a4965 1
	ahc->pending_device = NULL;
d4967 10
a4976 6
	ahc_compile_devinfo(&devinfo,
			    CAM_TARGET_WILDCARD,
			    CAM_TARGET_WILDCARD,
			    CAM_LUN_WILDCARD,
			    channel, ROLE_UNKNOWN);
	ahc_pause(ahc);
d4978 14
a4991 67
	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);

	/*
	 * Run our command complete fifos to ensure that we perform
	 * completion processing on any commands that 'completed'
	 * before the reset occurred.
	 */
	ahc_run_qoutfifo(ahc);
#if AHC_TARGET_MODE
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		ahc_run_tqinfifo(ahc, /*paused*/TRUE);
	}
#endif

	/*
	 * Reset the bus if we are initiating this reset
	 */
	sblkctl = ahc_inb(ahc, SBLKCTL);
	cur_channel = 'A';
	if ((ahc->features & AHC_TWIN) != 0
	 && ((sblkctl & SELBUSB) != 0))
	    cur_channel = 'B';
	scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
	if (cur_channel != channel) {
		/* Case 1: Command for another bus is active
		 * Stealthily reset the other bus without
		 * upsetting the current bus.
		 */
		ahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);
		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
#if AHC_TARGET_MODE
		/*
		 * Bus resets clear ENSELI, so we cannot
		 * defer re-enabling bus reset interrupts
		 * if we are in target mode.
		 */
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			ahc_outb(ahc, SIMODE1, simode1 | ENSCSIRST);
#endif
		ahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));
		ahc_outb(ahc, SBLKCTL, sblkctl);
		restart_needed = FALSE;
	} else {
		/* Case 2: A command from this bus is active or we're idle */
		ahc_clear_msg_state(ahc);
		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
#if AHC_TARGET_MODE
		/*
		 * Bus resets clear ENSELI, so we cannot
		 * defer re-enabling bus reset interrupts
		 * if we are in target mode.
		 */
		if ((ahc->flags & AHC_TARGETROLE) != 0)
			ahc_outb(ahc, SIMODE1, simode1 | ENSCSIRST);
#endif
		ahc_outb(ahc, SCSISEQ, scsiseq & (ENSELI|ENRSELI|ENAUTOATNP));
		restart_needed = TRUE;
	}
d4993 7
a4999 7
	/*
	 * Clean up all the state information for the
	 * pending transactions on this bus.
	 */
	found = ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, channel,
			       CAM_LUN_WILDCARD, SCB_LIST_NULL,
			       ROLE_UNKNOWN, CAM_SCSI_BUS_RESET);
d5001 2
a5002 10
	max_scsiid = (ahc->features & AHC_WIDE) ? 15 : 7;
	
#ifdef AHC_TARGET_MODE
	/*
	 * Send an immediate notify ccb to all target more peripheral
	 * drivers affected by this action.
	 */
	for (target = 0; target <= max_scsiid; target++) {
		struct ahc_tmode_tstate* tstate;
		u_int lun;
d5004 7
a5010 5
		tstate = ahc->enabled_targets[target];
		if (tstate == NULL)
			continue;
		for (lun = 0; lun < AHC_NUM_LUNS; lun++) {
			struct ahc_tmode_lstate* lstate;
d5012 21
a5032 3
			lstate = tstate->enabled_luns[lun];
			if (lstate == NULL)
				continue;
d5034 42
a5075 3
			ahc_queue_lstate_event(ahc, lstate, CAM_TARGET_WILDCARD,
					       EVENT_TYPE_BUS_RESET, /*arg*/0);
			ahc_send_lstate_events(ahc, lstate);
d5078 22
a5099 4
#endif
	/* Notify the XPT that a bus reset occurred */
	ahc_send_async(ahc, devinfo.channel, CAM_TARGET_WILDCARD,
		       CAM_LUN_WILDCARD, AC_BUS_RESET, NULL);
d5102 2
a5103 1
	 * Revert to async/narrow transfers until we renegotiate.
d5105 3
a5107 1
	for (target = 0; target <= max_scsiid; target++) {
d5109 25
a5133 14
		if (ahc->enabled_targets[target] == NULL)
			continue;
		for (initiator = 0; initiator <= max_scsiid; initiator++) {
			struct ahc_devinfo devinfo;

			ahc_compile_devinfo(&devinfo, target, initiator,
					    CAM_LUN_WILDCARD,
					    channel, ROLE_UNKNOWN);
			ahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
				      AHC_TRANS_CUR, /*paused*/TRUE);
			ahc_set_syncrate(ahc, &devinfo, /*syncrate*/NULL,
					 /*period*/0, /*offset*/0,
					 /*ppr_options*/0, AHC_TRANS_CUR,
					 /*paused*/TRUE);
d5135 9
d5146 1
a5146 5
	if (restart_needed)
		ahc_restart(ahc);
	else
		ahc_unpause(ahc);
	return found;
a5148 2

/***************************** Residual Processing ****************************/
d5150 4
a5153 1
 * Calculate the residual for a just completed SCB.
d5155 9
a5163 2
void
ahc_calc_residual(struct scb *scb)
d5165 4
a5168 21
	struct hardware_scb *hscb;
	struct status_pkt *spkt;
	uint32_t sgptr;
	uint32_t resid_sgptr;
	uint32_t resid;

	/*
	 * 5 cases.
	 * 1) No residual.
	 *    SG_RESID_VALID clear in sgptr.
	 * 2) Transferless command
	 * 3) Never performed any transfers.
	 *    sgptr has SG_FULL_RESID set.
	 * 4) No residual but target did not
	 *    save data pointers after the
	 *    last transfer, so sgptr was
	 *    never updated.
	 * 5) We have a partial residual.
	 *    Use residual_sgptr to determine
	 *    where we are.
	 */
d5170 2
a5171 6
	hscb = scb->hscb;
	sgptr = ahc_le32toh(hscb->sgptr);
	if ((sgptr & SG_RESID_VALID) == 0)
		/* Case 1 */
		return;
	sgptr &= ~SG_RESID_VALID;
d5173 2
a5174 3
	if ((sgptr & SG_LIST_NULL) != 0)
		/* Case 2 */
		return;
d5176 8
a5183 12
	spkt = &hscb->shared_data.status;
	resid_sgptr = ahc_le32toh(spkt->residual_sg_ptr);
	if ((sgptr & SG_FULL_RESID) != 0) {
		/* Case 3 */
		resid = ahc_get_transfer_length(scb);
	} else if ((resid_sgptr & SG_LIST_NULL) != 0) {
		/* Case 4 */
		return;
	} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {
		panic("Bogus resid sgptr value 0x%x", resid_sgptr);
	} else {
		struct ahc_dma_seg *sg;
d5185 2
a5186 6
		/*
		 * Remainder of the SG where the transfer
		 * stopped.
		 */
		resid = ahc_le32toh(spkt->residual_datacnt) & AHC_SG_LEN_MASK;
		sg = ahc_sg_bus_to_virt(scb, resid_sgptr & SG_PTR_MASK);
d5188 10
a5197 2
		/* The residual sg_ptr always points to the next sg */
		sg--;
d5199 6
a5204 8
		/*
		 * Add up the contents of all residual
		 * SG segments that are after the SG where
		 * the transfer stopped.
		 */
		while ((ahc_le32toh(sg->len) & AHC_DMA_LAST_SEG) == 0) {
			sg++;
			resid += ahc_le32toh(sg->len) & AHC_SG_LEN_MASK;
d5207 16
a5222 4
	if ((scb->flags & SCB_SENSE) == 0)
		ahc_set_residual(scb, resid);
	else
		ahc_set_sense_residual(scb, resid);
d5224 6
a5229 4
#ifdef AHC_DEBUG
	if (ahc_debug & AHC_SHOWMISC) {
		ahc_print_path(scb->ahc_softc, scb);
		printf("Handled Residual of %d bytes\n", resid);
a5230 2
#endif
}
d5232 8
a5239 18
/******************************* Target Mode **********************************/
#ifdef AHC_TARGET_MODE
/*
 * Add a target mode event to this lun's queue
 */
static void
ahc_queue_lstate_event(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate,
		       u_int initiator_id, u_int event_type, u_int event_arg)
{
	struct ahc_tmode_event *event;
	int pending;

	xpt_freeze_devq(lstate->path, /*count*/1);
	if (lstate->event_w_idx >= lstate->event_r_idx)
		pending = lstate->event_w_idx - lstate->event_r_idx;
	else
		pending = AHC_TMODE_EVENT_BUFFER_SIZE + 1
			- (lstate->event_r_idx - lstate->event_w_idx);
d5241 12
a5252 59
	if (event_type == EVENT_TYPE_BUS_RESET
	 || event_type == MSG_BUS_DEV_RESET) {
		/*
		 * Any earlier events are irrelevant, so reset our buffer.
		 * This has the effect of allowing us to deal with reset
		 * floods (an external device holding down the reset line)
		 * without losing the event that is really interesting.
		 */
		lstate->event_r_idx = 0;
		lstate->event_w_idx = 0;
		xpt_release_devq(lstate->path, pending, /*runqueue*/FALSE);
	}

	if (pending == AHC_TMODE_EVENT_BUFFER_SIZE) {
		xpt_print_path(lstate->path);
		printf("immediate event %x:%x lost\n",
		       lstate->event_buffer[lstate->event_r_idx].event_type,
		       lstate->event_buffer[lstate->event_r_idx].event_arg);
		lstate->event_r_idx++;
		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
			lstate->event_r_idx = 0;
		xpt_release_devq(lstate->path, /*count*/1, /*runqueue*/FALSE);
	}

	event = &lstate->event_buffer[lstate->event_w_idx];
	event->initiator_id = initiator_id;
	event->event_type = event_type;
	event->event_arg = event_arg;
	lstate->event_w_idx++;
	if (lstate->event_w_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
		lstate->event_w_idx = 0;
}

/*
 * Send any target mode events queued up waiting
 * for immediate notify resources.
 */
void
ahc_send_lstate_events(struct ahc_softc *ahc, struct ahc_tmode_lstate *lstate)
{
	struct ccb_hdr *ccbh;
	struct ccb_immed_notify *inot;

	while (lstate->event_r_idx != lstate->event_w_idx
	    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {
		struct ahc_tmode_event *event;

		event = &lstate->event_buffer[lstate->event_r_idx];
		SLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);
		inot = (struct ccb_immed_notify *)ccbh;
		switch (event->event_type) {
		case EVENT_TYPE_BUS_RESET:
			ccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;
			break;
		default:
			ccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;
			inot->message_args[0] = event->event_type;
			inot->message_args[1] = event->event_arg;
			break;
a5253 6
		inot->initiator_id = event->initiator_id;
		inot->sense_len = 0;
		xpt_done((union ccb *)inot);
		lstate->event_r_idx++;
		if (lstate->event_r_idx == AHC_TMODE_EVENT_BUFFER_SIZE)
			lstate->event_r_idx = 0;
d5255 2
a5257 1
#endif
d5259 11
a5269 5
/******************** Sequencer Program Patching/Download *********************/

#ifdef AHC_DUMP_SEQ
void
ahc_dumpseq(struct ahc_softc* ahc)
d5271 5
a5275 2
	int i;
	int max_prog;
d5277 3
a5279 6
	if ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)
		max_prog = 448;
	else if ((ahc->features & AHC_ULTRA2) != 0)
		max_prog = 768;
	else
		max_prog = 512;
d5281 6
a5286 5
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);
	for (i = 0; i < max_prog; i++) {
		uint8_t ins_bytes[4];
d5288 2
a5289 8
		ahc_insb(ahc, SEQRAM, ins_bytes, 4);
		printf("0x%08x\n", ins_bytes[0] << 24
				 | ins_bytes[1] << 16
				 | ins_bytes[2] << 8
				 | ins_bytes[3]);
	}
}
#endif
d5291 6
a5296 52
static void
ahc_loadseq(struct ahc_softc *ahc)
{
	struct	cs cs_table[num_critical_sections];
	u_int	begin_set[num_critical_sections];
	u_int	end_set[num_critical_sections];
	struct	patch *cur_patch;
	u_int	cs_count;
	u_int	cur_cs;
	u_int	i;
	int	downloaded;
	u_int	skip_addr;
	u_int	sg_prefetch_cnt;
	uint8_t	download_consts[7];

	/*
	 * Start out with 0 critical sections
	 * that apply to this firmware load.
	 */
	cs_count = 0;
	cur_cs = 0;
	memset(begin_set, 0, sizeof(begin_set));
	memset(end_set, 0, sizeof(end_set));

	/* Setup downloadable constant table */
	download_consts[QOUTFIFO_OFFSET] = 0;
	if (ahc->targetcmds != NULL)
		download_consts[QOUTFIFO_OFFSET] += 32;
	download_consts[QINFIFO_OFFSET] = download_consts[QOUTFIFO_OFFSET] + 1;
	download_consts[CACHESIZE_MASK] = ahc->pci_cachesize - 1;
	download_consts[INVERTED_CACHESIZE_MASK] = ~(ahc->pci_cachesize - 1);
	sg_prefetch_cnt = ahc->pci_cachesize;
	if (sg_prefetch_cnt < (2 * sizeof(struct ahc_dma_seg)))
		sg_prefetch_cnt = 2 * sizeof(struct ahc_dma_seg);
	download_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;
	download_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_cnt - 1);
	download_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_cnt - 1);

	cur_patch = patches;
	downloaded = 0;
	skip_addr = 0;
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
	ahc_outb(ahc, SEQADDR0, 0);
	ahc_outb(ahc, SEQADDR1, 0);

	for (i = 0; i < sizeof(seqprog)/4; i++) {
		if (ahc_check_patch(ahc, &cur_patch, i, &skip_addr) == 0) {
			/*
			 * Don't download this instruction as it
			 * is in a patch that was removed.
			 */
			continue;
d5298 10
a5307 13
		/*
		 * Move through the CS table until we find a CS
		 * that might apply to this instruction.
		 */
		for (; cur_cs < num_critical_sections; cur_cs++) {
			if (critical_sections[cur_cs].end <= i) {
				if (begin_set[cs_count] == TRUE
				 && end_set[cs_count] == FALSE) {
					cs_table[cs_count].end = downloaded;
				 	end_set[cs_count] = TRUE;
					cs_count++;
				}
				continue;
d5309 5
a5313 6
			if (critical_sections[cur_cs].begin <= i
			 && begin_set[cs_count] == FALSE) {
				cs_table[cs_count].begin = downloaded;
				begin_set[cs_count] = TRUE;
			}
			break;
a5314 2
		ahc_download_instr(ahc, i, download_consts);
		downloaded++;
d5316 3
a5318 15

	ahc->num_critical_sections = cs_count;
	if (cs_count != 0) {

		cs_count *= sizeof(struct cs);
		ahc->critical_sections = malloc(cs_count, M_DEVBUF, M_NOWAIT);
		if (ahc->critical_sections == NULL)
			panic("ahc_loadseq: Could not malloc");
		memcpy(ahc->critical_sections, cs_table, cs_count);
	}
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);
	ahc_restart(ahc);

	if (bootverbose)
		printf(" %d instructions downloaded\n", downloaded);
d5321 5
a5325 3
static int
ahc_check_patch(struct ahc_softc *ahc, struct patch **start_patch,
		u_int start_instr, u_int *skip_addr)
d5327 4
a5330 3
	struct	patch *cur_patch;
	struct	patch *last_patch;
	u_int	num_patches;
d5332 1
a5332 3
	num_patches = sizeof(patches)/sizeof(struct patch);
	last_patch = &patches[num_patches];
	cur_patch = *start_patch;
d5334 1
a5334 1
	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
d5336 5
a5340 1
		if (cur_patch->patch_func(ahc) == 0) {
d5342 2
a5343 11
			/* Start rejecting code */
			*skip_addr = start_instr + cur_patch->skip_instr;
			cur_patch += cur_patch->skip_patch;
		} else {
			/* Accepted this patch.  Advance to the next
			 * one and wait for our intruction pointer to
			 * hit this point.
			 */
			cur_patch++;
		}
	}
d5345 6
a5350 4
	*start_patch = cur_patch;
	if (start_instr < *skip_addr)
		/* Still skipping */
		return (0);
d5352 2
a5353 1
	return (1);
d5356 11
a5366 7
static void
ahc_download_instr(struct ahc_softc *ahc, u_int instrptr, uint8_t *dconsts)
{
	union	ins_formats instr;
	struct	ins_format1 *fmt1_ins;
	struct	ins_format3 *fmt3_ins;
	u_int	opcode;
d5369 2
a5370 1
	 * The firmware is always compiled into a little endian format.
d5372 6
a5377 1
	instr.integer = ahc_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
d5379 1
a5379 2
	fmt1_ins = &instr.format1;
	fmt3_ins = NULL;
d5381 4
a5384 17
	/* Pull the opcode */
	opcode = instr.format1.opcode;
	switch (opcode) {
	case AIC_OP_JMP:
	case AIC_OP_JC:
	case AIC_OP_JNC:
	case AIC_OP_CALL:
	case AIC_OP_JNE:
	case AIC_OP_JNZ:
	case AIC_OP_JE:
	case AIC_OP_JZ:
	{
		struct patch *cur_patch;
		int address_offset;
		u_int address;
		u_int skip_addr;
		u_int i;
d5386 13
a5398 5
		fmt3_ins = &instr.format3;
		address_offset = 0;
		address = fmt3_ins->address;
		cur_patch = patches;
		skip_addr = 0;
d5400 6
a5405 1
		for (i = 0; i < address;) {
d5407 11
a5417 1
			ahc_check_patch(ahc, &cur_patch, i, &skip_addr);
d5419 5
a5423 2
			if (skip_addr > i) {
				int end_addr;
d5425 6
a5430 40
				end_addr = MIN(address, skip_addr);
				address_offset += end_addr - i;
				i = skip_addr;
			} else {
				i++;
			}
		}
		address -= address_offset;
		fmt3_ins->address = address;
		/* FALLTHROUGH */
	}
	case AIC_OP_OR:
	case AIC_OP_AND:
	case AIC_OP_XOR:
	case AIC_OP_ADD:
	case AIC_OP_ADC:
	case AIC_OP_BMOV:
		if (fmt1_ins->parity != 0) {
			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
		}
		fmt1_ins->parity = 0;
		if ((ahc->features & AHC_CMD_CHAN) == 0
		 && opcode == AIC_OP_BMOV) {
			/*
			 * Block move was added at the same time
			 * as the command channel.  Verify that
			 * this is only a move of a single element
			 * and convert the BMOV to a MOV
			 * (AND with an immediate of FF).
			 */
			if (fmt1_ins->immediate != 1)
				panic("%s: BMOV not supported",
				      ahc_name(ahc));
			fmt1_ins->opcode = AIC_OP_AND;
			fmt1_ins->immediate = 0xff;
		}
		/* FALLTHROUGH */
	case AIC_OP_ROL:
		if ((ahc->features & AHC_ULTRA2) != 0) {
			int i, count;
d5432 1
a5432 3
			/* Calculate odd parity for the instruction */
			for (i = 0, count = 0; i < 31; i++) {
				uint32_t mask;
d5434 2
a5435 31
				mask = 0x01 << i;
				if ((instr.integer & mask) != 0)
					count++;
			}
			if ((count & 0x01) == 0)
				instr.format1.parity = 1;
		} else {
			/* Compress the instruction for older sequencers */
			if (fmt3_ins != NULL) {
				instr.integer =
					fmt3_ins->immediate
				      | (fmt3_ins->source << 8)
				      | (fmt3_ins->address << 16)
				      |	(fmt3_ins->opcode << 25);
			} else {
				instr.integer =
					fmt1_ins->immediate
				      | (fmt1_ins->source << 8)
				      | (fmt1_ins->destination << 16)
				      |	(fmt1_ins->ret << 24)
				      |	(fmt1_ins->opcode << 25);
			}
		}
		/* The sequencer is a little endian cpu */
		instr.integer = ahc_htole32(instr.integer);
		ahc_outsb(ahc, SEQRAM, instr.bytes, 4);
		break;
	default:
		panic("Unknown opcode encountered in seq program");
		break;
	}
d5438 5
a5442 2
void
ahc_dump_card_state(struct ahc_softc *ahc)
d5444 17
a5460 11
	struct scb *scb;
	struct scb_tailq *untagged_q;
	int target;
	int maxtarget;
	int i;
	uint8_t last_phase;
	uint8_t qinpos;
	uint8_t qintail;
	uint8_t qoutpos;
	uint8_t scb_index;
	uint8_t saved_scbptr;
d5462 31
a5492 1
	saved_scbptr = ahc_inb(ahc, SCBPTR);
d5494 11
a5504 37
	last_phase = ahc_inb(ahc, LASTPHASE);
	printf("%s: Dumping Card State %s, at SEQADDR 0x%x\n",
	       ahc_name(ahc), ahc_lookup_phase_entry(last_phase)->phasemsg,
	       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
	printf("ACCUM = 0x%x, SINDEX = 0x%x, DINDEX = 0x%x, ARG_2 = 0x%x\n",
	       ahc_inb(ahc, ACCUM), ahc_inb(ahc, SINDEX), ahc_inb(ahc, DINDEX),
	       ahc_inb(ahc, ARG_2));
	printf("HCNT = 0x%x\n", ahc_inb(ahc, HCNT));
	printf("SCSISEQ = 0x%x, SBLKCTL = 0x%x\n",
	       ahc_inb(ahc, SCSISEQ), ahc_inb(ahc, SBLKCTL));
	printf(" DFCNTRL = 0x%x, DFSTATUS = 0x%x\n",
	       ahc_inb(ahc, DFCNTRL), ahc_inb(ahc, DFSTATUS));
	printf("LASTPHASE = 0x%x, SCSISIGI = 0x%x, SXFRCTL0 = 0x%x\n",
	       last_phase, ahc_inb(ahc, SCSISIGI), ahc_inb(ahc, SXFRCTL0));
	printf("SSTAT0 = 0x%x, SSTAT1 = 0x%x\n",
	       ahc_inb(ahc, SSTAT0), ahc_inb(ahc, SSTAT1));
	if ((ahc->features & AHC_DT) != 0)
		printf("SCSIPHASE = 0x%x\n", ahc_inb(ahc, SCSIPHASE));
	printf("STACK == 0x%x, 0x%x, 0x%x, 0x%x\n",
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8));
	printf("SCB count = %d\n", ahc->scb_data->numscbs);
	printf("Kernel NEXTQSCB = %d\n", ahc->next_queued_scb->hscb->tag);
	printf("Card NEXTQSCB = %d\n", ahc_inb(ahc, NEXT_QUEUED_SCB));
	/* QINFIFO */
	printf("QINFIFO entries: ");
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		qinpos = ahc_inb(ahc, SNSCB_QOFF);
		ahc_outb(ahc, SNSCB_QOFF, qinpos);
	} else
		qinpos = ahc_inb(ahc, QINPOS);
	qintail = ahc->qinfifonext;
	while (qinpos != qintail) {
		printf("%d ", ahc->qinfifo[qinpos]);
		qinpos++;
a5505 1
	printf("\n");
d5507 11
a5517 53
	printf("Waiting Queue entries: ");
	scb_index = ahc_inb(ahc, WAITING_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	printf("Disconnected Queue entries: ");
	scb_index = ahc_inb(ahc, DISCONNECTED_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d:%d ", scb_index, ahc_inb(ahc, SCB_TAG));
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");
		
	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_POSTREAD);
	printf("QOUTFIFO entries: ");
	qoutpos = ahc->qoutfifonext;
	i = 0;
	while (ahc->qoutfifo[qoutpos] != SCB_LIST_NULL && i++ < 256) {
		printf("%d ", ahc->qoutfifo[qoutpos]);
		qoutpos++;
	}
	printf("\n");

	printf("Sequencer Free SCB List: ");
	scb_index = ahc_inb(ahc, FREE_SCBH);
	i = 0;
	while (scb_index != SCB_LIST_NULL && i++ < 256) {
		ahc_outb(ahc, SCBPTR, scb_index);
		printf("%d ", scb_index);
		scb_index = ahc_inb(ahc, SCB_NEXT);
	}
	printf("\n");

	printf("Pending list: ");
	i = 0;
	LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
		if (i++ > 256)
			break;
		if (scb != LIST_FIRST(&ahc->pending_scbs))
			printf(", ");
		printf("%d", scb->hscb->tag);
		if ((ahc->flags & AHC_PAGESCBS) == 0) {
			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
			printf("(0x%x, 0x%x)", ahc_inb(ahc, SCB_CONTROL),
			       ahc_inb(ahc, SCB_TAG));
		}
a5518 1
	printf("\n");
d5520 6
a5525 8
	printf("Kernel Free SCB list: ");
	i = 0;
	SLIST_FOREACH(scb, &ahc->scb_data->free_scbs, links.sle) {
		if (i++ > 256)
			break;
		printf("%d ", scb->hscb->tag);
	}
	printf("\n");
d5527 1
a5527 4
	maxtarget = (ahc->features & (AHC_WIDE|AHC_TWIN)) ? 15 : 7;
	for (target = 0; target <= maxtarget; target++) {
		untagged_q = &ahc->untagged_queues[target];
		if (TAILQ_FIRST(untagged_q) == NULL)
d5529 16
a5544 6
		printf("Untagged Q(%d): ", target);
		i = 0;
		TAILQ_FOREACH(scb, untagged_q, links.tqe) {
			if (i++ > 256)
				break;
			printf("%d ", scb->hscb->tag);
a5545 1
		printf("\n");
d5548 5
a5552 2
	ahc_platform_dump_card_state(ahc);
	ahc_outb(ahc, SCBPTR, saved_scbptr);
d5555 13
a5567 22
/************************* Target Mode ****************************************/
#ifdef AHC_TARGET_MODE
cam_status
ahc_find_tmode_devs(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb,
		    struct ahc_tmode_tstate **tstate,
		    struct ahc_tmode_lstate **lstate,
		    int notfound_failure)
{

	if ((ahc->features & AHC_TARGETMODE) == 0)
		return (CAM_REQ_INVALID);

	/*
	 * Handle the 'black hole' device that sucks up
	 * requests to unattached luns on enabled targets.
	 */
	if (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD
	 && ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {
		*tstate = NULL;
		*lstate = ahc->black_hole;
	} else {
		u_int max_id;
d5569 7
a5575 3
		max_id = (ahc->features & AHC_WIDE) ? 15 : 7;
		if (ccb->ccb_h.target_id > max_id)
			return (CAM_TID_INVALID);
d5577 13
a5589 2
		if (ccb->ccb_h.target_lun >= AHC_NUM_LUNS)
			return (CAM_LUN_INVALID);
d5591 10
a5600 11
		*tstate = ahc->enabled_targets[ccb->ccb_h.target_id];
		*lstate = NULL;
		if (*tstate != NULL)
			*lstate =
			    (*tstate)->enabled_luns[ccb->ccb_h.target_lun];
	}

	if (notfound_failure != 0 && *lstate == NULL)
		return (CAM_PATH_INVALID);

	return (CAM_REQ_CMP);
d5603 3
a5605 2
void
ahc_handle_en_lun(struct ahc_softc *ahc, struct cam_sim *sim, union ccb *ccb)
d5607 1
a5607 9
	struct	   ahc_tmode_tstate *tstate;
	struct	   ahc_tmode_lstate *lstate;
	struct	   ccb_en_lun *cel;
	cam_status status;
	u_int	   target;
	u_int	   lun;
	u_int	   target_mask;
	u_long	   s;
	char	   channel;
d5609 1
a5609 2
	status = ahc_find_tmode_devs(ahc, sim, ccb, &tstate, &lstate,
				     /*notfound_failure*/FALSE);
d5611 17
a5627 4
	if (status != CAM_REQ_CMP) {
		ccb->ccb_h.status = status;
		return;
	}
d5629 8
a5636 2
	if ((ahc->features & AHC_MULTIROLE) != 0) {
		u_int	   our_id;
d5638 3
a5640 27
		if (cam_sim_bus(sim) == 0)
			our_id = ahc->our_id;
		else
			our_id = ahc->our_id_b;

		if (ccb->ccb_h.target_id != our_id) {
			if ((ahc->features & AHC_MULTI_TID) != 0
		   	 && (ahc->flags & AHC_INITIATORROLE) != 0) {
				/*
				 * Only allow additional targets if
				 * the initiator role is disabled.
				 * The hardware cannot handle a re-select-in
				 * on the initiator id during a re-select-out
				 * on a different target id.
				 */
				status = CAM_TID_INVALID;
			} else if ((ahc->flags & AHC_INITIATORROLE) != 0
				|| ahc->enabled_luns > 0) {
				/*
				 * Only allow our target id to change
				 * if the initiator role is not configured
				 * and there are no enabled luns which
				 * are attached to the currently registered
				 * scsi id.
				 */
				status = CAM_TID_INVALID;
			}
d5642 1
d5645 10
a5654 3
	if (status != CAM_REQ_CMP) {
		ccb->ccb_h.status = status;
 		return;
d5656 11
d5669 2
a5670 2
	 * We now have an id that is valid.
	 * If we aren't in target mode, switch modes.
d5672 31
a5702 3
	if ((ahc->flags & AHC_TARGETROLE) == 0
	 && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
		u_long	s;
d5704 2
a5705 21
		printf("Configuring Target Mode\n");
		ahc_lock(ahc, &s);
		if (LIST_FIRST(&ahc->pending_scbs) != NULL) {
			ccb->ccb_h.status = CAM_BUSY;
			ahc_unlock(ahc, &s);
			return;
		}
		ahc->flags |= AHC_TARGETROLE;
		if ((ahc->features & AHC_MULTIROLE) == 0)
			ahc->flags &= ~AHC_INITIATORROLE;
		ahc_pause(ahc);
		ahc_loadseq(ahc);
		ahc_unlock(ahc, &s);
	}
	cel = &ccb->cel;
	target = ccb->ccb_h.target_id;
	lun = ccb->ccb_h.target_lun;
	channel = SIM_CHANNEL(ahc, sim);
	target_mask = 0x01 << target;
	if (channel == 'B')
		target_mask <<= 8;
d5707 4
a5710 2
	if (cel->enable != 0) {
		u_int scsiseq;
d5712 11
a5722 7
		/* Are we already enabled?? */
		if (lstate != NULL) {
			xpt_print_path(ccb->ccb_h.path);
			printf("Lun already enabled\n");
			ccb->ccb_h.status = CAM_LUN_ALRDY_ENA;
			return;
		}
d5724 21
a5744 9
		if (cel->grp6_len != 0
		 || cel->grp7_len != 0) {
			/*
			 * Don't (yet?) support vendor
			 * specific commands.
			 */
			ccb->ccb_h.status = CAM_REQ_INVALID;
			printf("Non-zero Group Codes\n");
			return;
d5746 3
d5750 6
a5755 54
		/*	
		 * Seems to be okay.
		 * Setup our data structures.
		 */
		if (target != CAM_TARGET_WILDCARD && tstate == NULL) {
			tstate = ahc_alloc_tstate(ahc, target, channel);
			if (tstate == NULL) {
				xpt_print_path(ccb->ccb_h.path);
				printf("Couldn't allocate tstate\n");
				ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
				return;
			}
		}
		lstate = malloc(sizeof(*lstate), M_DEVBUF, M_NOWAIT);
		if (lstate == NULL) {
			xpt_print_path(ccb->ccb_h.path);
			printf("Couldn't allocate lstate\n");
			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
			return;
		}
		memset(lstate, 0, sizeof(*lstate));
		status = xpt_create_path(&lstate->path, /*periph*/NULL,
					 xpt_path_path_id(ccb->ccb_h.path),
					 xpt_path_target_id(ccb->ccb_h.path),
					 xpt_path_lun_id(ccb->ccb_h.path));
		if (status != CAM_REQ_CMP) {
			free(lstate, M_DEVBUF);
			xpt_print_path(ccb->ccb_h.path);
			printf("Couldn't allocate path\n");
			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
			return;
		}
		SLIST_INIT(&lstate->accept_tios);
		SLIST_INIT(&lstate->immed_notifies);
		ahc_lock(ahc, &s);
		ahc_pause(ahc);
		if (target != CAM_TARGET_WILDCARD) {
			tstate->enabled_luns[lun] = lstate;
			ahc->enabled_luns++;

			if ((ahc->features & AHC_MULTI_TID) != 0) {
				u_int targid_mask;

				targid_mask = ahc_inb(ahc, TARGID)
					    | (ahc_inb(ahc, TARGID + 1) << 8);

				targid_mask |= target_mask;
				ahc_outb(ahc, TARGID, targid_mask);
				ahc_outb(ahc, TARGID+1, (targid_mask >> 8));
				
				ahc_update_scsiid(ahc, targid_mask);
			} else {
				u_int our_id;
				char  channel;
d5757 1
a5757 2
				channel = SIM_CHANNEL(ahc, sim);
				our_id = SIM_SCSI_ID(ahc, sim);
d5759 1
a5759 23
				/*
				 * This can only happen if selections
				 * are not enabled
				 */
				if (target != our_id) {
					u_int sblkctl;
					char  cur_channel;
					int   swap;

					sblkctl = ahc_inb(ahc, SBLKCTL);
					cur_channel = (sblkctl & SELBUSB)
						    ? 'B' : 'A';
					if ((ahc->features & AHC_TWIN) == 0)
						cur_channel = 'A';
					swap = cur_channel != channel;
					if (channel == 'A')
						ahc->our_id = target;
					else
						ahc->our_id_b = target;

					if (swap)
						ahc_outb(ahc, SBLKCTL,
							 sblkctl ^ SELBUSB);
d5761 9
a5769 1
					ahc_outb(ahc, SCSIID, target);
d5771 5
a5775 23
					if (swap)
						ahc_outb(ahc, SBLKCTL, sblkctl);
				}
			}
		} else
			ahc->black_hole = lstate;
		/* Allow select-in operations */
		if (ahc->black_hole != NULL && ahc->enabled_luns > 0) {
			scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
			scsiseq |= ENSELI;
			ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);
			scsiseq = ahc_inb(ahc, SCSISEQ);
			scsiseq |= ENSELI;
			ahc_outb(ahc, SCSISEQ, scsiseq);
		}
		ahc_unpause(ahc);
		ahc_unlock(ahc, &s);
		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_print_path(ccb->ccb_h.path);
		printf("Lun now enabled for target mode\n");
	} else {
		struct scb *scb;
		int i, empty;
d5777 1
a5777 4
		if (lstate == NULL) {
			ccb->ccb_h.status = CAM_LUN_INVALID;
			return;
		}
d5779 2
a5780 15
		ahc_lock(ahc, &s);
		
		ccb->ccb_h.status = CAM_REQ_CMP;
		LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
			struct ccb_hdr *ccbh;

			ccbh = &scb->io_ctx->ccb_h;
			if (ccbh->func_code == XPT_CONT_TARGET_IO
			 && !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){
				printf("CTIO pending\n");
				ccb->ccb_h.status = CAM_REQ_INVALID;
				ahc_unlock(ahc, &s);
				return;
			}
		}
d5782 2
a5783 4
		if (SLIST_FIRST(&lstate->accept_tios) != NULL) {
			printf("ATIOs pending\n");
			ccb->ccb_h.status = CAM_REQ_INVALID;
		}
d5785 6
a5790 4
		if (SLIST_FIRST(&lstate->immed_notifies) != NULL) {
			printf("INOTs pending\n");
			ccb->ccb_h.status = CAM_REQ_INVALID;
		}
d5792 3
a5794 4
		if (ccb->ccb_h.status != CAM_REQ_CMP) {
			ahc_unlock(ahc, &s);
			return;
		}
d5796 2
a5797 65
		xpt_print_path(ccb->ccb_h.path);
		printf("Target mode disabled\n");
		xpt_free_path(lstate->path);
		free(lstate, M_DEVBUF);

		ahc_pause(ahc);
		/* Can we clean up the target too? */
		if (target != CAM_TARGET_WILDCARD) {
			tstate->enabled_luns[lun] = NULL;
			ahc->enabled_luns--;
			for (empty = 1, i = 0; i < 8; i++)
				if (tstate->enabled_luns[i] != NULL) {
					empty = 0;
					break;
				}

			if (empty) {
				ahc_free_tstate(ahc, target, channel,
						/*force*/FALSE);
				if (ahc->features & AHC_MULTI_TID) {
					u_int targid_mask;

					targid_mask = ahc_inb(ahc, TARGID)
						    | (ahc_inb(ahc, TARGID + 1)
						       << 8);

					targid_mask &= ~target_mask;
					ahc_outb(ahc, TARGID, targid_mask);
					ahc_outb(ahc, TARGID+1,
					 	 (targid_mask >> 8));
					ahc_update_scsiid(ahc, targid_mask);
				}
			}
		} else {

			ahc->black_hole = NULL;

			/*
			 * We can't allow selections without
			 * our black hole device.
			 */
			empty = TRUE;
		}
		if (ahc->enabled_luns == 0) {
			/* Disallow select-in */
			u_int scsiseq;

			scsiseq = ahc_inb(ahc, SCSISEQ_TEMPLATE);
			scsiseq &= ~ENSELI;
			ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq);
			scsiseq = ahc_inb(ahc, SCSISEQ);
			scsiseq &= ~ENSELI;
			ahc_outb(ahc, SCSISEQ, scsiseq);

			if ((ahc->features & AHC_MULTIROLE) == 0) {
				printf("Configuring Initiator Mode\n");
				ahc->flags &= ~AHC_TARGETROLE;
				ahc->flags |= AHC_INITIATORROLE;
				ahc_pause(ahc);
				ahc_loadseq(ahc);
			}
		}
		ahc_unpause(ahc);
		ahc_unlock(ahc, &s);
	}
d5800 4
a5803 2
static void
ahc_update_scsiid(struct ahc_softc *ahc, u_int targid_mask)
d5805 5
a5809 2
	u_int scsiid_mask;
	u_int scsiid;
d5811 2
a5812 2
	if ((ahc->features & AHC_MULTI_TID) == 0)
		panic("ahc_update_scsiid called on non-multitid unit");
d5814 2
a5815 13
	/*
	 * Since we will rely on the the TARGID mask
	 * for selection enables, ensure that OID
	 * in SCSIID is not set to some other ID
	 * that we don't want to allow selections on.
	 */
	if ((ahc->features & AHC_ULTRA2) != 0)
		scsiid = ahc_inb(ahc, SCSIID_ULTRA2);
	else
		scsiid = ahc_inb(ahc, SCSIID);
	scsiid_mask = 0x1 << (scsiid & OID);
	if ((targid_mask & scsiid_mask) == 0) {
		u_int our_id;
d5817 7
a5823 14
		/* ffs counts from 1 */
		our_id = ffs(targid_mask);
		if (our_id == 0)
			our_id = ahc->our_id;
		else
			our_id--;
		scsiid &= TID;
		scsiid |= our_id;
	}
	if ((ahc->features & AHC_ULTRA2) != 0)
		ahc_outb(ahc, SCSIID_ULTRA2, scsiid);
	else
		ahc_outb(ahc, SCSIID, scsiid);
}
d5825 2
a5826 4
void
ahc_run_tqinfifo(struct ahc_softc *ahc, int paused)
{
	struct target_cmd *cmd;
d5829 11
a5839 6
	 * If the card supports auto-access pause,
	 * we can access the card directly regardless
	 * of whether it is paused or not.
	 */
	if ((ahc->features & AHC_AUTOPAUSE) != 0)
		paused = TRUE;
d5841 14
a5854 38
	ahc_sync_tqinfifo(ahc, BUS_DMASYNC_POSTREAD);
	while ((cmd = &ahc->targetcmds[ahc->tqinfifonext])->cmd_valid != 0) {

		/*
		 * Only advance through the queue if we
		 * have the resources to process the command.
		 */
		if (ahc_handle_target_cmd(ahc, cmd) != 0)
			break;

		cmd->cmd_valid = 0;
		ahc_dmamap_sync(ahc, ahc->shared_data_dmat,
				ahc->shared_data_dmamap,
				ahc_targetcmd_offset(ahc, ahc->tqinfifonext),
				sizeof(struct target_cmd),
				BUS_DMASYNC_PREREAD);
		ahc->tqinfifonext++;

		/*
		 * Lazily update our position in the target mode incoming
		 * command queue as seen by the sequencer.
		 */
		if ((ahc->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {
			if ((ahc->features & AHC_HS_MAILBOX) != 0) {
				u_int hs_mailbox;

				hs_mailbox = ahc_inb(ahc, HS_MAILBOX);
				hs_mailbox &= ~HOST_TQINPOS;
				hs_mailbox |= ahc->tqinfifonext & HOST_TQINPOS;
				ahc_outb(ahc, HS_MAILBOX, hs_mailbox);
			} else {
				if (!paused)
					ahc_pause(ahc);	
				ahc_outb(ahc, KERNEL_TQINPOS,
					 ahc->tqinfifonext & HOST_TQINPOS);
				if (!paused)
					ahc_unpause(ahc);
			}
d5859 5
a5863 2
static int
ahc_handle_target_cmd(struct ahc_softc *ahc, struct target_cmd *cmd)
d5865 4
a5868 17
	struct	  ahc_tmode_tstate *tstate;
	struct	  ahc_tmode_lstate *lstate;
	struct	  ccb_accept_tio *atio;
	uint8_t *byte;
	int	  initiator;
	int	  target;
	int	  lun;

	initiator = SCSIID_TARGET(ahc, cmd->scsiid);
	target = SCSIID_OUR_ID(cmd->scsiid);
	lun    = (cmd->identify & MSG_IDENTIFY_LUNMASK);

	byte = cmd->bytes;
	tstate = ahc->enabled_targets[target];
	lstate = NULL;
	if (tstate != NULL)
		lstate = tstate->enabled_luns[lun];
d5870 2
a5871 27
	/*
	 * Commands for disabled luns go to the black hole driver.
	 */
	if (lstate == NULL)
		lstate = ahc->black_hole;

	atio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);
	if (atio == NULL) {
		ahc->flags |= AHC_TQINFIFO_BLOCKED;
		/*
		 * Wait for more ATIOs from the peripheral driver for this lun.
		 */
		return (1);
	} else
		ahc->flags &= ~AHC_TQINFIFO_BLOCKED;
#if 0
	printf("Incoming command from %d for %d:%d%s\n",
	       initiator, target, lun,
	       lstate == ahc->black_hole ? "(Black Holed)" : "");
#endif
	SLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);

	if (lstate == ahc->black_hole) {
		/* Fill in the wildcards */
		atio->ccb_h.target_id = target;
		atio->ccb_h.target_lun = lun;
	}
d5874 2
a5875 2
	 * Package it up and send it off to
	 * whomever has this lun enabled.
d5877 4
a5880 11
	atio->sense_len = 0;
	atio->init_id = initiator;
	if (byte[0] != 0xFF) {
		/* Tag was included */
		atio->tag_action = *byte++;
		atio->tag_id = *byte++;
		atio->ccb_h.flags = CAM_TAG_ACTION_VALID;
	} else {
		atio->ccb_h.flags = 0;
	}
	byte++;
d5882 4
a5885 24
	/* Okay.  Now determine the cdb size based on the command code */
	switch (*byte >> CMD_GROUP_CODE_SHIFT) {
	case 0:
		atio->cdb_len = 6;
		break;
	case 1:
	case 2:
		atio->cdb_len = 10;
		break;
	case 4:
		atio->cdb_len = 16;
		break;
	case 5:
		atio->cdb_len = 12;
		break;
	case 3:
	default:
		/* Only copy the opcode. */
		atio->cdb_len = 1;
		printf("Reserved or VU command code type encountered\n");
		break;
	}
	
	memcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);
d5887 2
a5888 1
	atio->ccb_h.status |= CAM_CDB_RECVD;
d5890 1
a5890 17
	if ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {
		/*
		 * We weren't allowed to disconnect.
		 * We're hanging on the bus until a
		 * continue target I/O comes in response
		 * to this accept tio.
		 */
#if 0
		printf("Received Immediate Command %d:%d:%d - %p\n",
		       initiator, target, lun, ahc->pending_device);
#endif
		ahc->pending_device = lstate;
		ahc_freeze_ccb((union ccb *)atio);
		atio->ccb_h.flags |= CAM_DIS_DISCONNECT;
	}
	xpt_done((union ccb*)atio);
	return (0);
a5891 2

#endif
@


1.18.6.10
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d31 1
a31 1
 * $Id: aic7xxx.c,v 1.18.6.9 2003/03/28 00:38:11 niklas Exp $
d34 1
a34 1
 * $OpenBSD: aic7xxx.c,v 1.18.6.9 2003/03/28 00:38:11 niklas Exp $
a1391 1
	ahc_flush_device_writes(ahc);
a1394 1
	ahc_flush_device_writes(ahc);
a1395 1
	ahc_flush_device_writes(ahc);
a1396 1
	ahc_flush_device_writes(ahc);
d4147 1
a4147 1
ahc_controller_info(struct ahc_softc *ahc, char *buf, size_t buf_len)
d4149 1
a4149 1
	int len = 0;
d4151 2
a4152 3
	snprintf(buf + len, buf_len - len, "%s: ",
		 ahc_chip_names[ahc->chip & AHC_CHIPID_MASK]);
	len = strlen(buf);
d4154 4
a4157 4
		snprintf(buf + len, buf_len - len,
			 "Twin Channel, A SCSI Id=%d, B SCSI Id=%d, "
			 "primary %c, ", ahc->our_id, ahc->our_id_b,
			 (ahc->flags & AHC_PRIMARY_CHANNEL) + 'A');
d4175 2
a4176 3
		snprintf(buf + len, buf_len - len,
			 "%s%s Channel %c, SCSI Id=%d, ",
			 speed, type, ahc->channel, ahc->our_id);
d4178 1
a4178 1
	len = strlen(buf);
d4181 2
a4182 2
		snprintf(buf + len, buf_len - len, "%d/%d SCBs",
			 ahc->scb_data->maxhscbs, AHC_SCB_MAX);
d4184 1
a4184 2
		snprintf(buf + len, buf_len - len, "%d SCBs",
			 ahc->scb_data->maxhscbs);
a5629 1
	ahc_flush_device_writes(ahc);
@


1.18.6.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a0 3
/*	$OpenBSD$	*/
/*	$NetBSD: aic7xxx.c,v 1.108 2003/11/02 11:07:44 wiz Exp $	*/

d4 1
a4 2
 * Copyright (c) 1994-2002 Justin T. Gibbs.
 * Copyright (c) 2000-2002 Adaptec Inc.
d13 2
a14 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d17 1
a17 2
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
d19 5
a23 6
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d26 4
a29 6
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $Id$
d31 1
a31 1
 * //depot/aic7xxx/aic7xxx/aic7xxx.c#112 $
d33 2
a34 4
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx.c,v 1.88 2003/01/20 20:44:55 gibbs Exp $
 */
/*
 * Ported from FreeBSD by Pascal Renauld, Network Storage Solutions, Inc. - April 2003
d37 1
a37 3
#include <sys/cdefs.h>
/* __KERNEL_RCSID(0, "$NetBSD: aic7xxx.c,v 1.108 2003/11/02 11:07:44 wiz Exp $"); */

d40 7
a46 2
#include <dev/microcode/aic7xxx/aicasm_insformat.h>

d68 1
d112 1
a112 1
 * Provides a mapping of transfer periods in ns to the proper value to
d136 1
d138 3
a142 1
static void		ahc_force_renegotiation(struct ahc_softc *);
d159 3
a178 1
static void		ahc_handle_proto_violation(struct ahc_softc *ahc);
d204 11
a214 4
//static bus_dmamap_callback_t	ahc_dmamap_cb; 
static void			ahc_build_free_scb_list(struct ahc_softc *ahc);
static int			ahc_init_scbdata(struct ahc_softc *ahc);
static void			ahc_fini_scbdata(struct ahc_softc *ahc);
d224 3
d233 1
a233 1
					const struct patch **start_patch,
a247 18

/************************** Added for porting to NetBSD ***********************/
static int ahc_createdmamem(bus_dma_tag_t tag,
			    int size,
			    int flags,
			    bus_dmamap_t *mapp,
			    caddr_t *vaddr,
			    bus_addr_t *baddr,
			    bus_dma_segment_t *seg,
			    int *nseg,
			    const char *myname, const char *what);
static void ahc_freedmamem(bus_dma_tag_t tag,
			   int size,
			   bus_dmamap_t map,
			   caddr_t vaddr,
			   bus_dma_segment_t *seg,
			   int nseg);

a257 3
	/* No more pending messages. */
	ahc_clear_msg_state(ahc);

a260 3
	ahc_outb(ahc, LASTPHASE, P_BUSFREE);
	ahc_outb(ahc, SAVED_SCSIID, 0xFF);
	ahc_outb(ahc, SAVED_LUN, 0xFF);
d320 1
a320 1
			ahc_dmamap_sync(ahc, ahc->parent_dmat /*shared_data_dmat*/,
d332 1
a332 1
			       (ahc->qoutfifonext - 1) & 0xFF);
d340 1
a340 1
		ahc_update_residual(ahc, scb);
d363 1
a363 1
	    && (scb->flags & SCB_ACTIVE) == 0) {
d390 1
a390 1
	/* Tell everyone that this HBA is no longer available */
d433 1
a433 1
		 * DMA'd the SCB back up to us, so we can reference
d439 1
a439 2
			ahc_print_devinfo(ahc, &devinfo);
			printf("ahc_intr - referenced scb "
d441 2
a442 1
			       intstat, scb_index);
d458 1
d461 1
d468 1
a468 1
			printf("%s: Interrupted for status of 0 (?)\n",
d480 1
a480 1
			if (ahc_debug & AHC_SHOW_SENSE) {
d486 1
a486 1

d500 2
a501 2
			 */
			ahc_update_residual(ahc, scb);
d503 1
a503 1
			if (ahc_debug & AHC_SHOW_SENSE) {
d511 1
a511 1

d519 1
a519 1
			    && SCB_GET_LUN(scb) < 8)
d530 1
a530 1
			 * transaction indistinguishable from outstanding
d543 5
d549 2
a550 1
			    == ahc_get_transfer_length(scb)) {
d553 1
a553 1
						       AHC_NEG_IF_NON_ASYNC);
a564 16
#ifdef __OpenBSD__
			bus_dmamap_sync(ahc->parent_dmat,
			    ahc->scb_data->sense_dmamap,
			    (scb - ahc->scb_data->scbarray) *
			    sizeof(struct scsi_sense_data),
			    sizeof(struct scsi_sense_data),
			    BUS_DMASYNC_PREREAD);
			bus_dmamap_sync(ahc->parent_dmat,
			    scb->sg_map->sg_dmamap,
			    0, scb->sg_map->sg_dmamap->dm_mapsize,
			    BUS_DMASYNC_PREWRITE);
			bus_dmamap_sync(ahc->parent_dmat,
			    ahc->scb_data->hscb_dmamap,
			    0, ahc->scb_data->hscb_dmamap->dm_mapsize,
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
#endif
d569 5
d578 5
a582 1
			ahc_scb_timer_reset(scb, 5 * 1000000);
d599 1
a599 1
		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
d636 1
a636 1
	case PROTO_VIOLATION:
d638 19
a656 2
		ahc_handle_proto_violation(ahc);
		break;
d694 1
a694 1
		 * transferred so we can track bus phase changes.
d725 1
a725 1
					      "invalid SCB %x\n", scb_index);
d736 1
a736 3
			}
#if AHC_TARGET_MODE
			else {
d742 1
d747 1
a748 1
#endif
d783 1
a783 38
			if ((ahc_inb(ahc, SCSISIGI) & (CDI|MSGI)) == 0) {
				int wait;

				/*
				 * In a data phase.  Faster to bitbucket
				 * the data than to individually ack each
				 * byte.  This is also the only strategy
				 * that will work with AUTOACK enabled.
				 */
				ahc_outb(ahc, SXFRCTL1,
					 ahc_inb(ahc, SXFRCTL1) | BITBUCKET);
				wait = 5000;
				while (--wait != 0) {
					if ((ahc_inb(ahc, SCSISIGI)
					  & (CDI|MSGI)) != 0)
						break;
					ahc_delay(100);
				}
				ahc_outb(ahc, SXFRCTL1,
					 ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);
				if (wait == 0) {
					struct	scb *scb;
					u_int	scb_index;

					ahc_print_devinfo(ahc, &devinfo);
					printf("Unable to clear parity error.  "
					       "Resetting bus.\n");
					scb_index = ahc_inb(ahc, SCB_TAG);
					scb = ahc_lookup_scb(ahc, scb_index);
					if (scb != NULL)
						ahc_set_transaction_status(scb,
						    CAM_UNCOR_PARITY);
					ahc_reset_channel(ahc, devinfo.channel, 
							  /*init reset*/TRUE);
				}
			} else {
				ahc_inb(ahc, SCSIDATL);
			}
d832 1
a832 6
		if ((scb->flags & SCB_SENSE) == 0) {
			ahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);
		} else {
			scb->flags &= ~SCB_SENSE;
			ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
		}
d948 3
d952 1
a952 1
	    && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
a978 3
	/* Make sure the sequencer is in a safe location. */
	ahc_clear_critical_section(ahc);

d982 1
a982 1
	 && (ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)
a1028 1
		int   silent;
d1056 3
a1058 8
		silent = FALSE;
		if (scb != NULL) {
			if (SCB_IS_SILENT(scb))
				silent = TRUE;
			else
				ahc_print_path(ahc, scb);
			scb->flags |= SCB_TRANSMISSION_ERROR;
		} else
d1062 7
a1068 21
		if (silent == FALSE) {
			printf("parity error detected %s. "
			       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
			       ahc_phase_table[i].phasemsg,
			       ahc_inw(ahc, SEQADDR0),
			       scsirate);
			if ((ahc->features & AHC_DT) != 0) {
				if ((sstat2 & CRCVALERR) != 0)
					printf("\tCRC Value Mismatch\n");
				if ((sstat2 & CRCENDERR) != 0)
					printf("\tNo terminal CRC packet "
					       "recevied\n");
				if ((sstat2 & CRCREQERR) != 0)
					printf("\tIllegal CRC packet "
					       "request\n");
				if ((sstat2 & DUAL_EDGE_ERR) != 0)
					printf("\tUnexpected %sDT Data Phase\n",
					       (scsirate & SINGLE_EDGE)
					     ? "" : "non-");
			}
		}
d1070 9
a1078 8
		if ((ahc->features & AHC_DT) != 0
		 && (sstat2 & DUAL_EDGE_ERR) != 0) {
			/*
			 * This error applies regardless of
			 * data direction, so ignore the value
			 * in the phase table.
			 */
			mesg_out = MSG_INITIATOR_DET_ERR;
a1093 6
		/*
		 * Force a renegotiation with this target just in
		 * case we are out of sync for some external reason
		 * unknown (or unreported) by the target.
		 */
		ahc_force_renegotiation(ahc);
d1097 1
a1097 1
		u_int	scbptr;
d1112 1
a1112 1
		 * LED does.  SELINGO is only cleared by a sucessfull
a1127 1
			ahc_dump_card_state(ahc);
a1128 17
#ifdef AHC_DEBUG
			if ((ahc_debug & AHC_SHOW_SELTO) != 0) {
				ahc_print_path(ahc, scb);
				printf("Saw Selection Timeout for SCB 0x%x\n",
				       scb_index);
			}
#endif
			/*
			 * Force a renegotiation with this target just in
			 * case the cable was pulled and will later be
			 * re-attached.  The target may forget its negotiation
			 * settings with us should it attempt to reselect
			 * during the interruption.  The target will not issue
			 * a unit attention in this case, so we must always
			 * renegotiate.
			 */
			ahc_force_renegotiation(ahc);
d1183 1
a1183 1
			    || ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT, TRUE)) {
d1185 2
a1186 2
				    == MSG_ABORT_TAG)
				tag = scb->hscb->tag;
d1198 1
a1291 7
			/*
			 * Renegotiate with this device at the
			 * next opportunity just in case this busfree
			 * is due to a negotiation mismatch with the
			 * device.
			 */
			ahc_force_renegotiation(ahc);
d1298 1
a1307 21
/*
 * Force renegotiation to occur the next time we initiate
 * a command to the current device.
 */
void
ahc_force_renegotiation(struct ahc_softc *ahc)
{
	struct	ahc_devinfo devinfo;
	struct	ahc_initiator_tinfo *targ_info;
	struct	ahc_tmode_tstate *tstate;

	ahc_fetch_devinfo(ahc, &devinfo);
	targ_info = ahc_fetch_transinfo(ahc,
					devinfo.channel,
					devinfo.our_scsiid,
					devinfo.target,
					&tstate);
	ahc_update_neg_request(ahc, &devinfo, tstate,
			       targ_info, AHC_NEG_IF_NON_ASYNC);
}

d1368 1
a1368 12
			if ((ahc->features & AHC_DT) != 0)
				/*
				 * On DT class controllers, we
				 * use the enhanced busfree logic.
				 * Unfortunately we cannot re-enable
				 * busfree detection within the
				 * current connection, so we must
				 * leave it on while single stepping.
				 */
				ahc_outb(ahc, SIMODE1, ENBUSFREE);
			else
				ahc_outb(ahc, SIMODE1, 0);
a1372 4
		if ((ahc->features & AHC_DT) != 0) {
			ahc_outb(ahc, CLRSINT1, CLRBUSFREE);
			ahc_outb(ahc, CLRINT, CLRSCSIINT);
		}
d1374 1
a1374 1
		while (!ahc_is_paused(ahc))
d1376 1
d1398 1
a1398 1
 	ahc_flush_device_writes(ahc);
a1403 4
#ifdef AHC_DEBUG
uint32_t ahc_debug = 0; /* AHC_SHOW_MISC|AHC_SHOW_SENSE|AHC_DEBUG_OPTS;*/
#endif

d1455 1
a1455 1
	    && ahc->enabled_targets[scsi_id] != master_tstate)
d1458 1
a1458 2
	tstate = (struct ahc_tmode_tstate*)malloc(sizeof(*tstate),
						   M_DEVBUF, M_NOWAIT);
d1472 1
a1472 1
		for (i = 0; i < AHC_NUM_TARGETS; i++) {
d1521 1
a1521 2
			u_int *period, u_int *ppr_options, role_t role)
{
a1553 4
	if (transinfo->width == MSG_EXT_WDTR_BUS_8_BIT) {
		maxsync = MAX(maxsync, AHC_SYNCRATE_ULTRA2);
		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
	}
d1723 1
a1723 1
 * negotiate with at the next convenient opportunity.  This currently
d1730 1
a1730 1
		       struct ahc_initiator_tinfo *tinfo, ahc_neg_type neg_type)
a1734 12
	if (neg_type == AHC_NEG_ALWAYS) {
		/*
		 * Force our "current" settings to be
		 * unknown so that unless a bus reset
		 * occurs the need to renegotiate is
		 * recorded persistently.
		 */
		if ((ahc->features & AHC_WIDE) != 0)
			tinfo->curr.width = AHC_WIDTH_UNKNOWN;
		tinfo->curr.period = AHC_PERIOD_UNKNOWN;
		tinfo->curr.offset = AHC_OFFSET_UNKNOWN;
	}
d1739 2
a1740 2
	 || (neg_type == AHC_NEG_IF_NON_ASYNC
	  && (tinfo->goal.offset != 0
d1854 1
a1854 1
		  CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
d1871 1
a1871 1
						tinfo, AHC_NEG_TO_GOAL);
d1925 1
a1925 1
		if (1 /*bootverbose*/) {
d1933 1
a1933 1
						tinfo, AHC_NEG_TO_GOAL);
d1946 2
d2047 1
a2047 2
	 && (ahc_inb(ahc, SEQ_FLAGS)
 	   & (CMDPHASE_PENDING|TARG_CMD_PENDING|NO_DISCONNECT)) != 0) {
d2097 1
a2097 8
void
ahc_print_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	printf("%s:%c:%d:%d: ", ahc_name(ahc), devinfo->channel,
	       devinfo->target, devinfo->lun);
}

void
d2106 1
a2106 1
	if ((scb->flags & SCB_TARGET_SCB) != 0)
d2128 1
a2128 1
 * outgoing message buffer with the appropriate message and begin handing
d2135 1
a2135 1
	/*
d2139 1
a2139 1
	 */
d2220 1
a2220 1
	/*
d2224 1
a2224 1
	 */
d2231 1
d2253 1
a2253 6
	/*
	 * Only use PPR if we have options that need it, even if the device
	 * claims to support it.  There might be an expander in the way
	 * that doesn't.
	 */
	doppr = ppr_options != 0;
d2257 2
a2258 1
		dosync = tinfo->goal.offset != 0;
d2262 2
a2263 13
		/*
		 * Force async with a WDTR message if we have a wide bus,
		 * or just issue an SDTR with a 0 offset.
		 */
		if ((ahc->features & AHC_WIDE) != 0)
			dowide = 1;
		else
			dosync = 1;

		if (bootverbose) {
			ahc_print_devinfo(ahc, devinfo);
			printf("Ensuring async\n");
		}
d2266 1
d2269 1
a2269 1
		doppr = 0;
d2279 1
a2279 1
	if (doppr || (dosync && !dowide)) {
d2283 2
a2284 2
				    doppr ? tinfo->goal.width
					  : tinfo->curr.width,
d2286 1
a2286 1
		if (doppr) {
a2304 2
	if (offset == 0)
		period = AHC_ASYNC_XFER_PERIOD;
d2319 1
a2319 1
 * Build a wide negotiation message in our message
a2346 2
	if (offset == 0)
		period = AHC_ASYNC_XFER_PERIOD;
a2380 96
	ahc_outb(ahc, SEQ_FLAGS2,
		 ahc_inb(ahc, SEQ_FLAGS2) & ~TARGET_MSG_PENDING);
}

static void
ahc_handle_proto_violation(struct ahc_softc *ahc)
{
	struct	ahc_devinfo devinfo;
	struct	scb *scb;
	u_int	scbid;
	u_int	seq_flags;
	u_int	curphase;
	u_int	lastphase;
	int	found;

	ahc_fetch_devinfo(ahc, &devinfo);
	scbid = ahc_inb(ahc, SCB_TAG);
	scb = ahc_lookup_scb(ahc, scbid);
	seq_flags = ahc_inb(ahc, SEQ_FLAGS);
	curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
	lastphase = ahc_inb(ahc, LASTPHASE);
	if ((seq_flags & NOT_IDENTIFIED) != 0) {

		/*
		 * The reconnecting target either did not send an
		 * identify message, or did, but we didn't find an SCB
		 * to match.
		 */
		ahc_print_devinfo(ahc, &devinfo);
		printf("Target did not send an IDENTIFY message. "
		       "LASTPHASE = 0x%x.\n", lastphase);
		scb = NULL;
	} else if (scb == NULL) {
		/*
		 * We don't seem to have an SCB active for this
		 * transaction.  Print an error and reset the bus.
		 */
		ahc_print_devinfo(ahc, &devinfo);
		printf("No SCB found during protocol violation\n");
		goto proto_violation_reset;
	} else {
		ahc_set_transaction_status(scb, CAM_SEQUENCE_FAIL);
		if ((seq_flags & NO_CDB_SENT) != 0) {
			ahc_print_path(ahc, scb);
			printf("No or incomplete CDB sent to device.\n");
		} else if ((ahc_inb(ahc, SCB_CONTROL) & STATUS_RCVD) == 0) {
			/*
			 * The target never bothered to provide status to
			 * us prior to completing the command.  Since we don't
			 * know the disposition of this command, we must attempt
			 * to abort it.  Assert ATN and prepare to send an abort
			 * message.
			 */
			ahc_print_path(ahc, scb);
			printf("Completed command without status.\n");
		} else {
			ahc_print_path(ahc, scb);
			printf("Unknown protocol violation.\n");
			ahc_dump_card_state(ahc);
		}
	}
	if ((lastphase & ~P_DATAIN_DT) == 0
	 || lastphase == P_COMMAND) {
proto_violation_reset:
		/*
		 * Target either went directly to data/command
		 * phase or didn't respond to our ATN.
		 * The only safe thing to do is to blow
		 * it away with a bus reset.
		 */
		found = ahc_reset_channel(ahc, 'A', TRUE);
		printf("%s: Issued Channel %c Bus Reset. "
		       "%d SCBs aborted\n", ahc_name(ahc), 'A', found);
	} else {
		/*
		 * Leave the selection hardware off in case
		 * this abort attempt will affect yet to
		 * be sent commands.
		 */
		ahc_outb(ahc, SCSISEQ,
			 ahc_inb(ahc, SCSISEQ) & ~ENSELO);
		ahc_assert_atn(ahc);
		ahc_outb(ahc, MSG_OUT, HOST_MSG);
		if (scb == NULL) {
			ahc_print_devinfo(ahc, &devinfo);
			ahc->msgout_buf[0] = MSG_ABORT_TASK;
			ahc->msgout_len = 1;
			ahc->msgout_index = 0;
			ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
		} else {
			ahc_print_path(ahc, scb);
			scb->flags |= SCB_ABORT;
		}
		printf("Protocol violation %s.  Attempting to abort.\n",
		       ahc_lookup_phase_entry(curphase)->phasemsg);
	}
a2407 6
#ifdef AHC_DEBUG
		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
			ahc_print_devinfo(ahc, &devinfo);
			printf("INITIATOR_MSG_OUT");
		}
#endif
a2409 7
#ifdef AHC_DEBUG
			if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
				printf(" PHASEMIS %s\n",
				       ahc_lookup_phase_entry(bus_phase)
							     ->phasemsg);
			}
#endif
a2429 4
#ifdef AHC_DEBUG
			if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
				printf(" byte 0x%x\n", ahc->send_msg_perror);
#endif
a2455 5
#ifdef AHC_DEBUG
		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
			printf(" byte 0x%x\n",
			       ahc->msgout_buf[ahc->msgout_index]);
#endif
a2463 6
#ifdef AHC_DEBUG
		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
			ahc_print_devinfo(ahc, &devinfo);
			printf("INITIATOR_MSG_IN");
		}
#endif
d2465 1
a2466 7
#ifdef AHC_DEBUG
			if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
				printf(" PHASEMIS %s\n",
				       ahc_lookup_phase_entry(bus_phase)
							     ->phasemsg);
			}
#endif
a2480 5
#ifdef AHC_DEBUG
		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
			printf(" byte 0x%x\n",
			       ahc->msgin_buf[ahc->msgin_index]);
#endif
d2496 1
a2496 7
			if (ahc->msgout_len != 0) {
#ifdef AHC_DEBUG
				if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
					ahc_print_devinfo(ahc, &devinfo);
					printf("Asserting ATN for response\n");
				}
#endif
a2497 1
			}
d2501 3
a2503 7
		if (message_done == MSGLOOP_TERMINATED) {
			end_session = TRUE;
		} else {
			/* Ack the byte */
			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
			ahc_inb(ahc, SCSIDATL);
		}
d2572 1
a2572 1
		 * so that we don't inadvertently cause a REQ for the
d2703 1
a2703 1
	 * Parse as much of the message as is available,
d2705 1
a2705 1
	 * the entire message is available and has been
a2713 11
	case MSG_DISCONNECT:
	case MSG_SAVEDATAPOINTER:
	case MSG_CMDCOMPLETE:
	case MSG_RESTOREPOINTERS:
	case MSG_IGN_WIDE_RESIDUE:
		/*
		 * End our message loop as these are messages
		 * the sequencer handles on its own.
		 */
		done = MSGLOOP_TERMINATED;
		break;
d2767 1
a2767 1
			ahc_set_syncrate(ahc, devinfo, 
d2883 1
a2883 1
				if (tinfo->goal.offset) {
a3016 1
#ifdef AHC_TARGET_MODE
d3028 1
a3028 3
	{
		int tag;

a3033 3
		tag = SCB_LIST_NULL;
		if (ahc->msgin_buf[0] == MSG_ABORT_TAG)
			tag = ahc_inb(ahc, INITIATOR_TAG);
d3035 5
a3039 2
			       devinfo->lun, tag, ROLE_TARGET,
			       CAM_REQ_ABORTED);
d3050 1
a3050 1
						       /*arg*/tag);
d3054 1
a3054 2
		ahc_restart(ahc);
		done = MSGLOOP_TERMINATED;
a3055 1
	}
d3143 1
a3143 1
		if (tinfo->goal.offset != tinfo->curr.offset) {
d3213 1
a3213 1
		 * currently in our possession so they can be
d3413 1
a3413 1

d3445 1
a3445 1
	  CAM_LUN_WILDCARD, AC_SENT_BDR, NULL);
d3476 46
a3600 16
/*
 * Verify that the passed in softc pointer is for a
 * controller that is still configured.
 */
struct ahc_softc *
ahc_find_softc(struct ahc_softc *ahc)
{
	struct ahc_softc *list_ahc;

	TAILQ_FOREACH(list_ahc, &ahc_tailq, links) {
		if (list_ahc == ahc)
			return (ahc);
	}
	return (NULL);
}

d3615 1
d3624 1
a3624 1
	case 2:
d3626 11
a3636 1
		/* TAILQ_REMOVE(&ahc_tailq, ahc, links); XXX */
d3638 2
d3641 3
a3643 4
		bus_dmamap_unload(ahc->parent_dmat, ahc->shared_data_dmamap);
		bus_dmamap_destroy(ahc->parent_dmat, ahc->shared_data_dmamap);
		bus_dmamem_unmap(ahc->parent_dmat, (caddr_t)ahc->qoutfifo, ahc->shared_data_size);
		bus_dmamem_free(ahc->parent_dmat, &ahc->shared_data_seg, ahc->shared_data_nseg);
d3649 3
d3666 1
a3666 1
					  /*xpt_free_path(lstate->path);*/
d3676 1
a3676 1
	  /*xpt_free_path(ahc->black_hole->path);*/
a3679 1
#ifndef __NetBSD__
a3681 3
#endif
	if (ahc->seep_config != NULL)
		free(ahc->seep_config, M_DEVBUF);
d3687 1
d3703 1
a3703 1
	for (i = TARG_SCSIRATE; i < SCSICONF; i++)
d3709 1
a3709 1
 * that is only available just after a reset.
a3723 8
	if ((ahc_inb(ahc, HCNTRL) & CHIPRST) != 0) {
		/*
		 * The chip has not been initialized since
		 * PCI/EISA/VLB bus reset.  Don't trust
		 * "left over BIOS data".
		 */
		ahc->flags |= AHC_NO_BIOS_INIT;
	}
d3742 1
a3742 4
	 * Ensure that the reset has finished.  We delay 1000us
	 * prior to reading the register to make sure the chip
	 * has sufficiently completed its reset to handle register
	 * accesses.
d3773 1
a3773 1
		printf(" Unsupported adapter type (0x%x).  Ignoring\n", sblkctl);
d3823 1
a3823 1
#if 0
d3832 1
a3832 1
#endif
d3834 1
d3836 3
a3840 1
	int scbsize;
a3842 4
	scbsize = 32;
	if ((ahc->flags & AHC_LSCBS_ENABLED) != 0)
		scbsize = 64;

a3843 2
		int j;

a3845 8
		/*
		 * Touch all SCB bytes to avoid parity errors
		 * should one of our debugging routines read
		 * an otherwise uninitiatlized byte.
		 */
		for (j = 0; j < scbsize; j++)
			ahc_outb(ahc, SCB_BASE+j, 0xFF);

d3855 1
a3855 1
		/* Make the tag number, SCSIID, and lun invalid */
a3856 2
		ahc_outb(ahc, SCB_SCSIID, 0xFF);
		ahc_outb(ahc, SCB_LUN, 0xFF);
d3862 4
d3868 1
d3880 1
a3880 1
	    (struct scb *)malloc(sizeof(struct scb) * AHC_SCB_MAX_ALLOC,
d3884 1
a3884 1
	memset(scb_data->scbarray, 0, sizeof(struct scb) * AHC_SCB_MAX_ALLOC);
d3913 10
a3922 6
	if (ahc_createdmamem(ahc->parent_dmat,
	     AHC_SCB_MAX * sizeof(struct hardware_scb), ahc->sc_dmaflags,
	     &scb_data->hscb_dmamap,
	     (caddr_t *)&scb_data->hscbs, &scb_data->hscb_busaddr,
	     &scb_data->hscb_seg, &scb_data->hscb_nseg, ahc_name(ahc),
	     "hardware SCB structures") < 0)
d3924 1
d3928 4
a3931 5
	if (ahc_createdmamem(ahc->parent_dmat,
	     AHC_SCB_MAX * sizeof(struct scsi_sense_data), ahc->sc_dmaflags,
	     &scb_data->sense_dmamap, (caddr_t *)&scb_data->sense,
	     &scb_data->sense_busaddr, &scb_data->sense_seg,
	     &scb_data->sense_nseg, ahc_name(ahc), "sense buffers") < 0)
d3933 55
d3992 1
a3992 2
	memset(scb_data->hscbs, 0,
	       AHC_SCB_MAX_ALLOC * sizeof(struct hardware_scb));
a3993 1
	scb_data->init_level++;
d4009 1
a4009 1
	 * Note that we were successfull
d4029 1
a4029 1
	case 5:
d4035 5
a4039 3
			ahc_freedmamem(ahc->parent_dmat, PAGE_SIZE,
			    sg_map->sg_dmamap, (caddr_t)sg_map->sg_vaddr,
			    &sg_map->sg_dmasegs, sg_map->sg_nseg);
d4042 1
d4044 8
a4051 1
	/*FALLTHROUGH*/
d4053 1
a4053 5
		ahc_freedmamem(ahc->parent_dmat,
		    AHC_SCB_MAX * sizeof(struct scsipi_sense_data),
		    scb_data->sense_dmamap, (caddr_t)scb_data->sense,
		    &scb_data->sense_seg, scb_data->sense_nseg);
	/*FALLTHROUGH*/
d4055 2
a4056 5
		ahc_freedmamem(ahc->parent_dmat,
		    AHC_SCB_MAX * sizeof(struct hardware_scb),
		    scb_data->hscb_dmamap, (caddr_t)scb_data->hscbs,
		    &scb_data->hscb_seg, scb_data->hscb_nseg);
	/*FALLTHROUGH*/
d4058 4
d4063 2
d4084 1
a4084 1
	if (scb_data->numscbs >= AHC_SCB_MAX_ALLOC)
d4096 3
a4098 5
	if (ahc_createdmamem(ahc->parent_dmat, PAGE_SIZE, ahc->sc_dmaflags,
			     &sg_map->sg_dmamap,
			     (caddr_t *)&sg_map->sg_vaddr, &sg_map->sg_physaddr,
			     &sg_map->sg_dmasegs, &sg_map->sg_nseg, ahc_name(ahc),
			     "SG space") < 0) {
d4105 4
d4113 3
a4115 3
	newcount = MIN(newcount, (AHC_SCB_MAX_ALLOC - scb_data->numscbs));
	for (i = 0; i < newcount; i++) {
		struct scb_platform_data *pdata = NULL;
d4117 5
a4121 9

		if (sizeof(*pdata) > 0) { 
			pdata = (struct scb_platform_data *)
			    malloc(sizeof(*pdata), M_DEVBUF, M_NOWAIT);
			if (pdata == NULL)
				break;
			bzero(pdata, sizeof(*pdata));
		}

d4132 3
a4134 5

		error = bus_dmamap_create(ahc->parent_dmat, 
			  AHC_MAXTRANSFER_SIZE, AHC_NSEG, MAXPHYS, 0,
			  BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW|ahc->sc_dmaflags,
			  &next_scb->dmamap);
d4137 1
a4137 1

d4148 1
d4211 3
a4213 3
#ifdef AHC_DEBUG
	if ((ahc_debug & AHC_DEBUG_SEQUENCER) != 0)
		ahc->flags |= AHC_SEQUENCER_DEBUG;
a4232 6
	/*
	 * Reading uninitialized scratch ram may
	 * generate parity errors.
	 */
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
a4234 1

d4249 1
a4249 1
	//if ((AHC_TMODE_ENABLE & (0x1 << ahc->unit)) == 0)
d4252 17
d4272 1
a4272 1
	 * roles, we need to allocate space for the qinfifo and qoutfifo.
d4276 1
a4276 1
	 * byte to deal with a DMA bug in some chip versions.
d4279 10
d4292 11
d4304 6
a4309 5
	if (ahc_createdmamem(ahc->parent_dmat, driver_data_size,
			     ahc->sc_dmaflags,
			     &ahc->shared_data_dmamap, (caddr_t *)&ahc->qoutfifo,
			     &ahc->shared_data_busaddr, &ahc->shared_data_seg,
			     &ahc->shared_data_nseg, ahc_name(ahc), "shared data") < 0)
d4311 1
d4315 4
d4333 1
d4341 1
a4341 5
		  return (ENOMEM);

	if (bootverbose)
		printf("%s: found %d SCBs\n", ahc_name(ahc),
		    ahc->scb_data->maxhscbs);
d4365 1
a4365 1
	if (ahc->scb_data->maxhscbs < AHC_SCB_MAX_ALLOC) {
d4372 3
a4374 3
	if (ahc_debug & AHC_SHOW_MISC) {
		printf("%s: hardware scb %lu bytes; kernel scb %lu bytes; "
		       "ahc_dma %lu bytes\n",
d4376 3
a4378 3
			(u_long)sizeof(struct hardware_scb),
			(u_long)sizeof(struct scb),
			(u_long)sizeof(struct ahc_dma_seg));
d4407 1
a4407 1

d4434 1
a4434 1
	if ((ahc->flags & AHC_USEDEFAULTS) != 0) {
d4551 1
a4551 2
		tstate->ultraenb = 0;
		tstate->discenable = discenable;
d4574 1
a4574 1

a4579 2
	ahc_sync_qinfifo(ahc, BUS_DMASYNC_PREWRITE);

d4584 1
a4584 1

a4629 1

d4652 1
a4652 1
	 */
d4665 1
a4665 1
		 * a cable attached, the transceivers may
a4707 1
	int paused;
a4711 1
	paused = FALSE;
a4712 2
		if (paused)
			ahc_unpause(ahc);
a4714 2
		paused = TRUE;
		ahc_outb(ahc, SCSISEQ, ahc_inb(ahc, SCSISEQ) & ~ENSELO);
d4718 2
a4719 3
	} while (--maxloops
	      && (((intstat = ahc_inb(ahc, INTSTAT)) & INT_PEND) != 0
	       || (ahc_inb(ahc, SSTAT0) & (SELDO|SELINGO))));
d4722 1
a4722 1
		       ahc_inb(ahc, INTSTAT));
d4748 1
a4748 1

a4974 1
#if 0
a4990 1
#endif
d5047 1
a5047 5
	ahc->qinfifo[ahc->qinfifonext] = scb->hscb->tag;
	ahc_dmamap_sync(ahc, ahc->parent_dmat, ahc->shared_data_dmamap,
			/*offset*/ahc->qinfifonext+256, /*len*/1,
			BUS_DMASYNC_PREWRITE);
	ahc->qinfifonext++;
d5055 2
a5056 2
	uint8_t qinpos;
	uint8_t diff;
d5077 1
a5077 2
	uint8_t next;
	uint8_t prev;
d5080 2
d5092 1
d5095 1
a5095 1

d5132 2
a5133 1
					ahc_set_transaction_status(scb, status);
a5139 1

d5166 1
a5166 1
		 * The sequencer may be in the process of DMA'ing
d5171 1
a5171 1
		 * SCB to DMA). If we have removed any entries, swap
d5174 1
a5174 1
		 * has changed during its DMA attempt and will retry
d5244 2
a5245 1
					ahc_set_transaction_status(scb, status);
d5270 3
a5272 27
	found += ahc_search_untagged_queues(ahc, /*ahc_io_ctx_t*/NULL, target,
					    channel, lun, status, action);

	if (action == SEARCH_COMPLETE)
		ahc_release_untagged_queues(ahc);
	return (found);
}

int
ahc_search_untagged_queues(struct ahc_softc *ahc, struct scsi_xfer *xs,
			   int target, char channel, int lun, uint32_t status,
			   ahc_search_action action)
{
	struct	scb *scb;
	int	maxtarget;
	int	found;
	int	i;

	if (action == SEARCH_COMPLETE) {
		/*
		 * Don't attempt to run any queued untagged transactions
		 * until we are done with the abort process.
		 */
		ahc_freeze_untagged_queues(ahc);
	}

	found = 0;
d5311 11
a5321 4
			if (ahc_match_scb(ahc, scb, target, channel, lun,
					  SCB_LIST_NULL, ROLE_INITIATOR) == 0
			    /*|| (ctx != NULL && ctx != scb->io_ctx)*/)
				continue;
d5323 19
a5341 27
			/*
			 * We found an scb that needs to be acted on.
			 */
			found++;
			switch (action) {
			case SEARCH_COMPLETE:
			{
				cam_status ostat;
				cam_status cstat;

				ostat = ahc_get_transaction_status(scb);
				if (ostat == CAM_REQ_INPROG)
					ahc_set_transaction_status(scb, status);
				cstat = ahc_get_transaction_status(scb);
				if (cstat != CAM_REQ_CMP)
					ahc_freeze_scb(scb);
				if ((scb->flags & SCB_ACTIVE) == 0)
					printf("Inactive SCB in untaggedQ\n");
				ahc_done(ahc, scb);
				break;
			}
			case SEARCH_REMOVE:
				scb->flags &= ~SCB_UNTAGGEDQ;
				TAILQ_REMOVE(untagged_q, scb, links.tqe);
				break;
			case SEARCH_COUNT:
				break;
d5569 4
a5572 5
	if (role != ROLE_TARGET) {
		for (;i < maxtarget; i++) {
			for (j = minlun;j < maxlun; j++) {
				u_int scbid;
				u_int tcl;
d5574 9
a5582 21
				tcl = BUILD_TCL(i << 4, j);
				scbid = ahc_index_busy_tcl(ahc, tcl);
				scbp = ahc_lookup_scb(ahc, scbid);
				if (scbp == NULL
				 || ahc_match_scb(ahc, scbp, target, channel,
						  lun, tag, role) == 0)
					continue;
				ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, j));
			}
		}

		/*
		 * Go through the disconnected list and remove any entries we
		 * have queued for completion, 0'ing their control byte too.
		 * We save the active SCB and restore it ourselves, so there
		 * is no reason for this search to restore it too.
		 */
		ahc_search_disc_list(ahc, target, channel, lun, tag,
				     /*stop_on_first*/FALSE, /*remove*/TRUE,
				     /*save_state*/FALSE);
	}
d5586 1
a5586 4
	 * were active but not on any list.  In some cases, these remnants
	 * might not still have mappings in the scbindex array (e.g. unexpected
	 * bus free with the same scb queued for an abort).  Don't hold this
	 * against them.
d5594 2
a5595 3
		if ((scbp == NULL && scbid != SCB_LIST_NULL)
		 || (scbp != NULL
		  && ahc_match_scb(ahc, scbp, target, channel, lun, tag, role)))
a5678 10
	/*
	 * XXX - In Twin mode, the tqinfifo may have commands
	 *	 for an unaffected channel in it.  However, if
	 *	 we have run out of ATIO resources to drain that
	 *	 queue, we may not get them all out here.  Further,
	 *	 the blocked transactions for the reset channel
	 *	 should just be killed off, irrespecitve of whether
	 *	 we are blocked on ATIO resources.  Write a routine
	 *	 to compact the tqinfifo appropriately.
	 */
d5700 4
d5711 1
a5711 1
			simode1 |= ENSCSIRST;
a5712 4
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
d5718 1
d5720 4
d5731 1
a5731 1
			simode1 |= ENSCSIRST;
a5732 4
		ahc_outb(ahc, SIMODE1, simode1);
		if (initiate_reset)
			ahc_reset_current_bus(ahc);
		ahc_clear_intstat(ahc);
d5746 1
a5746 1

d5772 4
d5811 1
a5811 1
ahc_calc_residual(struct ahc_softc *ahc, struct scb *scb)
d5855 1
a5855 1
		panic("Bogus resid sgptr value 0x%x\n", resid_sgptr);
d5861 1
a5861 1
		 * stopped.  
d5885 3
a5887 4
	if ((ahc_debug & AHC_SHOW_MISC) != 0) {
		ahc_print_path(ahc, scb);
		printf("Handled %sResidual of %d bytes\n",
		       (scb->flags & SCB_SENSE) ? "Sense " : "", resid);
d6018 1
a6018 1
	const struct	patch *cur_patch;
d6102 1
a6102 1
	if (bootverbose) {
a6103 3
		printf("%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\n",
		       ahc_name(ahc), ahc->features, ahc->bugs, ahc->flags);
	}
d6107 1
a6107 1
ahc_check_patch(struct ahc_softc *ahc, const struct patch **start_patch,
d6110 2
a6111 2
	const struct	patch *cur_patch;
	const struct	patch *last_patch;
d6170 1
a6170 1
		const struct patch *cur_patch;
d6181 1
d6183 1
a6266 58
int
ahc_print_register(ahc_reg_parse_entry_t *table, u_int num_entries,
		   const char *name, u_int address, u_int value,
		   u_int *cur_column, u_int wrap_point)
{
	int	printed;
	u_int	printed_mask;
	char    line[1024];

	line[0] = 0;

	if (cur_column != NULL && *cur_column >= wrap_point) {
		printf("\n");
		*cur_column = 0;
	}
	printed = snprintf(line, sizeof(line), "%s[0x%x]", name, value);
	if (table == NULL) {
		printed += snprintf(&line[printed], (sizeof line) - printed,
		    " ");
		printf("%s", line);
		if (cur_column != NULL)
			*cur_column += printed;
		return (printed);
	}
	printed_mask = 0;
	while (printed_mask != 0xFF) {
		int entry;

		for (entry = 0; entry < num_entries; entry++) {
			if (((value & table[entry].mask)
			  != table[entry].value)
			 || ((printed_mask & table[entry].mask)
			  == table[entry].mask))
				continue;
			printed += snprintf(&line[printed],
			    (sizeof line) - printed, "%s%s", 
				printed_mask == 0 ? ":(" : "|",
				table[entry].name);
			printed_mask |= table[entry].mask;
			
			break;
		}
		if (entry >= num_entries)
			break;
	}
	if (printed_mask != 0)
		printed += snprintf(&line[printed],
		    (sizeof line) - printed, ") ");
	else
		printed += snprintf(&line[printed],
		    (sizeof line) - printed, " ");
	if (cur_column != NULL)
		*cur_column += printed;
	printf("%s", line);

	return (printed);
}

d6270 5
a6274 7
	struct	scb *scb;
	struct	scb_tailq *untagged_q;
	u_int	cur_col;
	int	paused;
	int	target;
	int	maxtarget;
	int	i;
d6282 1
a6282 6
	if (ahc_is_paused(ahc)) {
		paused = 1;
	} else {
		paused = 0;
		ahc_pause(ahc);
	}
a6283 1
	saved_scbptr = ahc_inb(ahc, SCBPTR);
d6285 1
a6285 2
	printf(">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\n"
	       "%s: Dumping Card State %s, at SEQADDR 0x%x\n",
a6287 2
	if (paused)
		printf("Card was paused\n");
d6291 9
a6299 3
	printf("HCNT = 0x%x SCBPTR = 0x%x\n", ahc_inb(ahc, HCNT),
	       ahc_inb(ahc, SCBPTR));
	cur_col = 0;
d6301 7
a6307 25
		ahc_scsiphase_print(ahc_inb(ahc, SCSIPHASE), &cur_col, 50);
	ahc_scsisigi_print(ahc_inb(ahc, SCSISIGI), &cur_col, 50);
	ahc_error_print(ahc_inb(ahc, ERROR), &cur_col, 50);
	ahc_scsibusl_print(ahc_inb(ahc, SCSIBUSL), &cur_col, 50);
	ahc_lastphase_print(ahc_inb(ahc, LASTPHASE), &cur_col, 50);
	ahc_scsiseq_print(ahc_inb(ahc, SCSISEQ), &cur_col, 50);
	ahc_sblkctl_print(ahc_inb(ahc, SBLKCTL), &cur_col, 50);
	ahc_scsirate_print(ahc_inb(ahc, SCSIRATE), &cur_col, 50);
	ahc_seqctl_print(ahc_inb(ahc, SEQCTL), &cur_col, 50);
	ahc_seq_flags_print(ahc_inb(ahc, SEQ_FLAGS), &cur_col, 50);
	ahc_sstat0_print(ahc_inb(ahc, SSTAT0), &cur_col, 50);
	ahc_sstat1_print(ahc_inb(ahc, SSTAT1), &cur_col, 50);
	ahc_sstat2_print(ahc_inb(ahc, SSTAT2), &cur_col, 50);
	ahc_sstat3_print(ahc_inb(ahc, SSTAT3), &cur_col, 50);
	ahc_simode0_print(ahc_inb(ahc, SIMODE0), &cur_col, 50);
	ahc_simode1_print(ahc_inb(ahc, SIMODE1), &cur_col, 50);
	ahc_sxfrctl0_print(ahc_inb(ahc, SXFRCTL0), &cur_col, 50);
	ahc_dfcntrl_print(ahc_inb(ahc, DFCNTRL), &cur_col, 50);
	ahc_dfstatus_print(ahc_inb(ahc, DFSTATUS), &cur_col, 50);
	if (cur_col != 0)
		printf("\n");
	printf("STACK:");
	for (i = 0; i < STACK_SIZE; i++)
	       printf(" 0x%x", ahc_inb(ahc, STACK)|(ahc_inb(ahc, STACK) << 8));
	printf("\nSCB count = %d\n", ahc->scb_data->numscbs);
a6363 12
	printf("Sequencer SCB Info: ");
	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
		ahc_outb(ahc, SCBPTR, i);
		/*cur_col =*/ printf("\n%3d ", i);

		ahc_scb_control_print(ahc_inb(ahc, SCB_CONTROL), &cur_col, 60);
		ahc_scb_scsiid_print(ahc_inb(ahc, SCB_SCSIID), &cur_col, 60);
		ahc_scb_lun_print(ahc_inb(ahc, SCB_LUN), &cur_col, 60);
		ahc_scb_tag_print(ahc_inb(ahc, SCB_TAG), &cur_col, 60);
	}
	printf("\n");

d6369 3
a6371 4
		/*cur_col =*/ printf("\n%3d ", scb->hscb->tag);
		ahc_scb_control_print(scb->hscb->control, &cur_col, 60);
		ahc_scb_scsiid_print(scb->hscb->scsiid, &cur_col, 60);
		ahc_scb_lun_print(scb->hscb->lun, &cur_col, 60);
d6374 2
a6375 5
			printf("(");
			ahc_scb_control_print(ahc_inb(ahc, SCB_CONTROL),
					      &cur_col, 60);
			ahc_scb_tag_print(ahc_inb(ahc, SCB_TAG), &cur_col, 60);
			printf(")");
a6404 1
	printf("\n<<<<<<<<<<<<<<<<< Dump Card State Ends >>>>>>>>>>>>>>>>>>\n");
a6405 2
	if (paused == 0)
		ahc_unpause(ahc);
a6460 1
	u_int	   our_id;
d6472 2
a6473 4
	if (cam_sim_bus(sim) == 0)
		our_id = ahc->our_id;
	else
		our_id = ahc->our_id_b;
d6475 4
a6478 21
	if (ccb->ccb_h.target_id != our_id) {
		/*
		 * our_id represents our initiator ID, or
		 * the ID of the first target to have an
		 * enabled lun in target mode.  There are
		 * two cases that may preclude enabling a
		 * target id other than our_id.
		 *
		 *   o our_id is for an active initiator role.
		 *     Since the hardware does not support
		 *     reselections to the initiator role at
		 *     anything other than our_id, and our_id
		 *     is used by the hardware to indicate the
		 *     ID to use for both select-out and
		 *     reselect-out operations, the only target
		 *     ID we can support in this mode is our_id.
		 *
		 *   o The MULTARGID feature is not available and
		 *     a previous target mode ID has been enabled.
		 */
		if ((ahc->features & AHC_MULTIROLE) != 0) {
d6480 1
a6501 4
		} else if ((ahc->features & AHC_MULTI_TID) == 0
			&& ahc->enabled_luns > 0) {

			status = CAM_TID_INVALID;
d6507 1
a6507 1
		return;
d6562 1
a6562 1
		/*
d6783 1
a6783 1
	 * Since we will rely on the TARGID mask
d6835 1
a6835 1
		ahc_dmamap_sync(ahc, ahc->parent_dmat/*shared_data_dmat*/,
a6898 2
		if (bootverbose)
			printf("%s: ATIOs exhausted\n", ahc_name(ahc));
d6976 1
a6977 72

static int
ahc_createdmamem(bus_dma_tag_t tag, int size, int flags, bus_dmamap_t *mapp,
    caddr_t *vaddr, bus_addr_t *baddr, bus_dma_segment_t *seg, int *nseg,
    const char *myname, const char *what)
{
	int error, level = 0;

	if ((error = bus_dmamem_alloc(tag, size, PAGE_SIZE, 0,
				      seg, 1, nseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: failed to allocate DMA mem for %s, error = %d\n",
			myname, what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamem_map(tag, seg, *nseg, size, vaddr,
				    BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: failed to map DMA mem for %s, error = %d\n",
			myname, what, error);
		goto out;
	}
	level++;

	if ((error = bus_dmamap_create(tag, size, 1, size, 0,
				       BUS_DMA_NOWAIT | flags, mapp)) != 0) {
                printf("%s: failed to create DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }
	level++;


	if ((error = bus_dmamap_load(tag, *mapp, *vaddr, size, NULL,
				     BUS_DMA_NOWAIT)) != 0) {
                printf("%s: failed to load DMA map for %s, error = %d\n",
			myname, what, error);
		goto out;
        }

	*baddr = (*mapp)->dm_segs[0].ds_addr;

	return 0;
out:
	printf("ahc_createdmamem error (%d)\n", level);
	switch (level) {
	case 3:
		bus_dmamap_destroy(tag, *mapp);
		/* FALLTHROUGH */
	case 2:
		bus_dmamem_unmap(tag, *vaddr, size);
		/* FALLTHROUGH */
	case 1:
		bus_dmamem_free(tag, seg, *nseg);
		break;
	default:
		break;
	}

	return error;
}

static void
ahc_freedmamem(bus_dma_tag_t tag, int size, bus_dmamap_t map, caddr_t vaddr,
    bus_dma_segment_t *seg, int nseg)
{

	bus_dmamap_unload(tag, map);
	bus_dmamap_destroy(tag, map);
	bus_dmamem_unmap(tag, vaddr, size);
	bus_dmamem_free(tag, seg, nseg);
}
@


1.18.6.12
log
@Merge with the trunk
@
text
@d4935 1
a4935 1
		if (paused) {
a4936 6
			/*
			 * Give the sequencer some time to service
			 * any active selections.
			 */
			ahc_delay(200);
		}
d5191 4
a5194 9
	char chan;
	int targ, slun, match;

	if (scb == NULL)
		return 0;

	targ = SCB_GET_TARGET(ahc, scb);
	chan = SCB_GET_CHANNEL(ahc, scb);
	slun = SCB_GET_LUN(scb);
d5202 1
d5219 1
d5480 1
a5480 1
					printf("Inactive SCB in Wait List\n");
d5586 2
@


1.17
log
@do not whine about failed negotiations
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.16 1997/04/10 22:52:18 deraadt Exp $	*/
d994 1
a994 1
                panic("%s: brkadrint, %s at seqaddr = 0x%x\n",
@


1.16
log
@queue handling hacks for chips like aic7860 which have small numbers of SCB's.
by gibbs@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.15 1997/01/15 05:50:38 deraadt Exp $	*/
d1555 1
d1559 1
d1565 1
d1570 1
@


1.15
log
@sc_link.adapter_buswidth, set to 16 if wide scsi. if 0 it gets converted
to 8 internally so that drivers do not need to init it for regular scsi :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.14 1996/11/28 23:27:43 niklas Exp $	*/
d97 1
a97 1
 * 4) ahc_run_waiing_queues() looks at both the assigned_scbs and waiting_scbs
d101 1
a101 1
 *    ahc_run_waing_queues()).
d113 1
a113 1
 *    the NO_MATCH sequencer interrupt.  For tagged commands, the approprite
d159 1
a159 1
#if DEBUGTARG < 0	/* Negative numbrs for disabling cause warnings */
d163 6
d335 6
d386 1
a386 1
	{ ILLSADDR,  "Illegal Sequencer Address referrenced" },
d421 1
a421 1
 * Allocate a controller structures for a new device and initialize it.
d595 1
a595 1
		/* Use asyncronous transfers. */
d600 1
a600 1
			printf("%s: target %d using asyncronous transfers\n",
a623 18
#if defined(__OpenBSD__)
/* XXX we'll get rid of this soon */
#define scsiprint ahcprint

int	ahcprint __P((void *, const char *));

int
ahcprint(aux, name)
	void *aux;
	const char *name;
{

	if (name != NULL)
		printf("%s: scsibus ", name);
	return UNCONF;
}
#endif

d635 7
a730 7
	 * XXX - Update MI SCSI code
	 *
	 * if(ahc->type & AHC_WIDE)
	 *	max target of both channel A and B = 15;
	 */
	
	/*
d873 1
a873 1
			 * be at least one slot availible for a
d879 1
a879 1
			 * activily working on an SCB which implies that
d977 1
a977 1
	 * someone who is sharing my interrupt
d1352 1
a1352 1
		printf("%s:%c:%d: Warning - unknown message recieved from "
d1563 2
a1564 2
			printf("%s:%c:%d: refuses syncronous negotiation. "
			       "Using asyncronous transfers\n",
d1632 1
a1656 1

d1791 1
a1791 1
		printf("invalid tag recieved -- sending ABORT_TAG\n");
d2018 13
d2160 1
a2160 1
				printf("%s: Reseting Channel B\n",
d2189 1
a2189 1
			printf("%s: Reseting Channel A\n", ahc_name(ahc));
d2205 2
a2206 2
	 * that we should initiate syncronous transfers.  If it's zero,
	 * the user or the BIOS has decided to disable syncronous
d2239 1
a2239 1
				/*Default to a asyncronous transfers(0 offset)*/
d2297 1
a2297 1
	 * Set the number of availible SCBs
d2309 1
a2309 1
	 * sporatically get garbage in the upper bits of
d2374 45
d2431 1
a2431 1
	int	thiskv;
d2437 3
d2448 1
d2450 45
d2510 20
d2532 1
d2534 6
d2593 1
a2593 1
		thiskv = (int) xs->data;
d2617 1
a2617 1
				bytes_this_page = min(bytes_this_page ,datalen);
d2622 3
a2624 2
				thiskv = (thiskv & (~(PAGE_SIZE - 1)))
					 + PAGE_SIZE;
d2626 2
a2627 1
					thisphys = KVTOPHYS(thiskv);
d2719 1
a2719 1
 * A scb (and hence an scb entry on the board is put onto the
d2742 1
a2742 1
			 * If there were no SCBs availible, wake anybody waiting
d2769 1
a2769 1
			 * If there were no SCBs availible, wake anybody waiting
d2778 1
a2778 1
			 * If there were no SCBs availible, wake anybody waiting
d3131 1
a3131 1
		 * Try reseting the bus.
@


1.14
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.13 1996/11/23 21:46:33 kstailey Exp $	*/
d654 4
d681 4
@


1.13
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 1
/*	$OpenBSD: aic7xxx.c,v 1.12 1996/11/12 20:30:15 niklas Exp $	*/
d36 2
a38 1

d123 1
a123 1
#include <machine/bus.old.h>
d125 1
a125 1
#endif /* defined(__NetBSD__) */
d132 1
d161 1
a161 1
#define DEBUGTARG	9
d163 1
a163 1
#endif /* defined(__NetBSD__) */
d196 4
d228 11
a238 9
/*
 * Since the sequencer can disable pausing in a critical section, we
 * must loop until it actually stops.
 * XXX Should add a timeout in here??
 */
#define PAUSE_SEQUENCER(ahc)					\
	AHC_OUTB(ahc, HCNTRL, ahc->pause);			\
								\
	while ((AHC_INB(ahc, HCNTRL) & PAUSE) == 0)		\
d240 1
d242 9
a250 2
#define UNPAUSE_SEQUENCER(ahc)					\
	AHC_OUTB(ahc, HCNTRL, ahc->unpause )
d255 11
a265 7
#define RESTART_SEQUENCER(ahc)						\
	do {								\
		AHC_OUTB(ahc, SEQCTL, SEQRESET|FASTMODE);		\
	} while((AHC_INB(ahc, SEQADDR0) != 0)				\
		|| (AHC_INB(ahc, SEQADDR1) != 0));			\
									\
	UNPAUSE_SEQUENCER(ahc);
d275 1
a275 1
 * convert FreeBSD's SCSI symbols to NetBSD's
d294 1
d311 3
a313 3
static void	ahc_scsirate __P((struct ahc_data* ahc, u_char *scsirate,
				  int period, int offset, char channel,
				  int target));
d324 4
d389 1
a389 1
	short period; /* in ns */
d392 11
a402 11
	{ 0x100,  50, "20.0"  },
	{ 0x110,  62, "16.0"  },
	{ 0x120,  75, "13.4"  },
	{ 0x000, 100, "10.0"  },
	{ 0x010, 125,  "8.0"  },
	{ 0x020, 150,  "6.67" },
	{ 0x030, 175,  "5.7"  },
	{ 0x040, 200,  "5.0"  },
	{ 0x050, 225,  "4.4"  },
	{ 0x060, 250,  "4.0"  },
	{ 0x070, 275,  "3.6"  }
a411 1
 *
d420 1
a420 1
ahc_construct(ahc, bc, ioh, type, flags)
d422 2
a423 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d457 1
a457 1
	ahc->sc_bc = bc;
d485 1
a485 1
ahc_reset(devname, bc, ioh)
d487 2
a488 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d500 1
a500 1
	hcntrl = (bus_io_read_1(bc, ioh, HCNTRL) & IRQMS) | INTEN;
d502 1
a502 1
	bus_io_write_1(bc, ioh, HCNTRL, CHIPRST | PAUSE);
d511 1
a511 1
	while (--wait && !(bus_io_read_1(bc, ioh, HCNTRL) & CHIPRSTACK))
d526 1
a526 1
	bus_io_write_1(bc, ioh, HCNTRL, hcntrl | PAUSE);
d535 6
a540 6
	struct	ahc_data *ahc;
	u_char	*scsirate;
	short	period;
	u_char	offset;
	char	channel;
	int	target;
d543 3
d547 4
a550 4
	for (i = 0; i < ahc_num_syncrates; i++) {
		u_char ultra_enb;
		u_char sxfrctl0;
		u_long ultra_enb_addr;
d552 1
a552 7
		if ((ahc_syncrates[i].period - period) >= 0) {
			/*
			 * Watch out for Ultra speeds when ultra is not
			 * enabled and vice-versa.
			 */
			if(!(ahc->type & AHC_ULTRA) 
			 && (ahc_syncrates[i].sxfr & ULTRA_SXFR)) {
d554 2
a555 5
				 * This should only happen if the
				 * drive is the first to negotiate
				 * and chooses a high rate.  We'll
				 * just move down the table util
				 * we hit a non ultra speed.
d557 22
a578 29
				continue;
			}
			*scsirate = (ahc_syncrates[i].sxfr) | (offset & 0x0f);

			/*
			 * Ensure Ultra mode is set properly for
			 * this target.
			 */
			ultra_enb_addr = ULTRA_ENB;
			if(channel == 'B' || target > 7)
				ultra_enb_addr++;
			ultra_enb = AHC_INB(ahc, ultra_enb_addr);	
			sxfrctl0 = AHC_INB(ahc, SXFRCTL0);
			if (ahc_syncrates[i].sxfr & ULTRA_SXFR) {
				ultra_enb |= 0x01 << (target & 0x07);
				sxfrctl0 |= ULTRAEN;
			}
			else {
				ultra_enb &= ~(0x01 << (target & 0x07));
				sxfrctl0 &= ~ULTRAEN;
			}
			AHC_OUTB(ahc, ultra_enb_addr, ultra_enb);
			AHC_OUTB(ahc, SXFRCTL0, sxfrctl0);
			
			if(bootverbose) {
				printf("%s: target %d synchronous at %sMHz,"
				       " offset = 0x%x\n",
				        ahc_name(ahc), target,
					ahc_syncrates[i].rate, offset );
a579 1
			return;
d582 25
a606 5
	/* Default to asyncronous transfers.  Also reject this SDTR request. */
	*scsirate = 0;
	if(bootverbose) {
		printf("%s: target %d using asyncronous transfers\n",
			ahc_name(ahc), target );
d608 2
d612 4
a615 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d654 3
d662 3
d666 1
d677 3
d720 1
a720 1
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d735 1
d737 1
a737 6
			printf("%s: Probing channel A\n", ahc_name(ahc));
		config_found((void *)ahc, &ahc->sc_link, ahcprint);
		if (ahc->type & AHC_TWIN) {
			printf("%s: Probing channel B\n", ahc_name(ahc));
			config_found((void *)ahc, &ahc->sc_link_b, ahcprint);
		}
d746 2
a747 4
		printf("%s: Probing channel B\n", ahc_name(ahc));
		config_found((void *)ahc, &ahc->sc_link_b, ahcprint);
		printf("%s: Probing channel A\n", ahc_name(ahc));
		config_found((void *)ahc, &ahc->sc_link, ahcprint);
d827 1
a827 1
	PAUSE_SEQUENCER(ahc);
d931 1
a931 1
	UNPAUSE_SEQUENCER(ahc);
d960 1
a960 1
#elif defined (__NetBSD__) || defined(__OpenBSD__)
d997 39
a1035 20
        if (intstat & SEQINT) { 
		u_short targ_mask;
		u_char target = (AHC_INB(ahc, SCSIID) >> 4) & 0x0f;
		u_char scratch_offset = target;
		char channel = 
			AHC_INB(ahc, SBLKCTL) & SELBUSB ? 'B': 'A';

		if (channel == 'B')
			scratch_offset += 8;
		targ_mask = (0x01 << scratch_offset); 
		
                switch (intstat & SEQINT_MASK) {
                    case NO_MATCH:
			if(ahc->flags & AHC_PAGESCBS) {
				/* SCB Page-in request */
				u_char tag;
				u_char next;
				u_char disc_scb;
				struct scb *outscb;
				u_char arg_1 = AHC_INB(ahc, ARG_1);
d1037 43
d1081 2
a1082 7
				 * We should succeed, so set this now.
				 * If we don't, and one of the methods
				 * we use to aquire an SCB calls ahc_done,
				 * we may wind up in our start routine
				 * and unpause the adapter without giving
				 * it the correct return value, which will
				 * cause a hang.
d1084 27
a1110 1
				AHC_OUTB(ahc, RETURN_1, SCB_PAGEDIN);
d1112 121
a1232 8
				if(arg_1 == SCB_LIST_NULL) {
					/* Non-tagged command */
					int index = target |
						(channel == 'B' ? SELBUSB : 0);
					scb = ahc->pagedout_ntscbs[index];
				}
				else
					scb = ahc->scbarray[arg_1];
d1234 16
a1249 15
				if(!(scb->flags & SCB_PAGED_OUT))
					panic("%s: Request to page in a"
					      "non paged out SCB.",
					      ahc_name(ahc));
				/*
				 * Now to pick the SCB to page out.
				 * Either take a free SCB, an assigned SCB,
				 * an SCB that just completed, the first
				 * one on the disconnected SCB list, or
				 * as a last resort a queued SCB.
				 */
				if(ahc->free_scbs.stqh_first) {
					outscb = ahc->free_scbs.stqh_first; 
					STAILQ_REMOVE_HEAD(&ahc->free_scbs,
							   links);
a1251 2
					STAILQ_INSERT_HEAD(&ahc->page_scbs,
							   outscb, links);
d1255 3
d1260 12
a1271 14
				if(ahc->assigned_scbs.stqh_first) {
					outscb = ahc->assigned_scbs.stqh_first; 
					STAILQ_REMOVE_HEAD(&ahc->assigned_scbs,
							   links);
					outscb->flags ^= SCB_ASSIGNEDQ
							|SCB_WAITINGQ;
					scb->position = outscb->position;
					outscb->position = SCB_LIST_NULL;
					STAILQ_INSERT_HEAD(&ahc->waiting_scbs,
							   outscb, links);
					AHC_OUTB(ahc, SCBPTR, scb->position);
					ahc_send_scb(ahc, scb);
					scb->flags &= ~SCB_PAGED_OUT;
					goto pagein_done;
d1273 33
a1305 2
				if(intstat & CMDCMPLT) {
					int   scb_index;
d1307 11
a1317 43
					AHC_OUTB(ahc, CLRINT, CLRCMDINT);
					scb_index = AHC_INB(ahc, QOUTFIFO);
					if(!(AHC_INB(ahc, QOUTCNT) & ahc->qcntmask))
						intstat &= ~CMDCMPLT;

					outscb = ahc->scbarray[scb_index];
					if (!outscb || !(outscb->flags & SCB_ACTIVE)) {
						printf("%s: WARNING "
						       "no command for scb %d (cmdcmplt)\n",
							ahc_name(ahc),
						        scb_index);
						/* Fall through in hopes of finding another SCB */
					}
					else {
						scb->position = outscb->position;
						outscb->position = SCB_LIST_NULL;
						AHC_OUTB(ahc, SCBPTR, scb->position);
						ahc_send_scb(ahc, scb);
						scb->flags &= ~SCB_PAGED_OUT;
						untimeout(ahc_timeout, (caddr_t)outscb);
						ahc_done(ahc, outscb);
						goto pagein_done;
					}
				}
				disc_scb = AHC_INB(ahc, DISCONNECTED_SCBH);
				if(disc_scb != SCB_LIST_NULL) {
					AHC_OUTB(ahc, SCBPTR, disc_scb);
					tag = AHC_INB(ahc, SCB_TAG); 
					outscb = ahc->scbarray[tag];
					next = AHC_INB(ahc, SCB_NEXT);
					if(next != SCB_LIST_NULL) {
						AHC_OUTB(ahc, SCBPTR, next);
						AHC_OUTB(ahc, SCB_PREV,
						     SCB_LIST_NULL);
						AHC_OUTB(ahc, SCBPTR, disc_scb);
					}
					AHC_OUTB(ahc, DISCONNECTED_SCBH, next);
					ahc_page_scb(ahc, outscb, scb);
				}
				else if(AHC_INB(ahc, QINCNT) & ahc->qcntmask) {
					/* Pull one of our queued commands as a last resort */
					disc_scb = AHC_INB(ahc, QINFIFO);
					AHC_OUTB(ahc, SCBPTR, disc_scb);
d1320 9
a1328 42
					if((outscb->control & 0x23) != TAG_ENB) {
						/*
						 * This is not a simple tagged command
						 * so its position in the queue
						 * matters.  Take the command at the
						 * end of the queue instead.
						 */
						int i;
						u_char saved_queue[AHC_SCB_MAX];
						u_char queued = AHC_INB(ahc, QINCNT) & ahc->qcntmask;

						/* Count the command we removed already */
						saved_queue[0] = disc_scb;
						queued++;

						/* Empty the input queue */
						for (i = 1; i < queued; i++) 
							saved_queue[i] = AHC_INB(ahc, QINFIFO);

						/* Put everyone back put the last entry */
						queued--;
						for (i = 0; i < queued; i++)
							AHC_OUTB(ahc, QINFIFO, saved_queue[i]);

						AHC_OUTB(ahc, SCBPTR, saved_queue[queued]);
						tag = AHC_INB(ahc, SCB_TAG);
						outscb = ahc->scbarray[tag];
					}	
					untimeout(ahc_timeout, (caddr_t)outscb);
					scb->position = outscb->position;
					outscb->position = SCB_LIST_NULL;
					STAILQ_INSERT_HEAD(&ahc->waiting_scbs,
							   outscb, links);
					outscb->flags |= SCB_WAITINGQ;
					ahc_send_scb(ahc, scb);
					scb->flags &= ~SCB_PAGED_OUT;
				}
				else {
					panic("Page-in request with no candidates");
					AHC_OUTB(ahc, RETURN_1, 0);
				}
pagein_done:
d1331 1
a1331 9
				printf("%s:%c:%d: no active SCB for "
				       "reconnecting target - "
				       "issuing ABORT\n",
				       ahc_name(ahc), channel, target);
				printf("SAVED_TCL == 0x%x\n",
					AHC_INB(ahc, SAVED_TCL));
				ahc_unbusy_target(ahc, target, channel);
				AHC_OUTB(ahc, SCB_CONTROL, 0);
				AHC_OUTB(ahc, CLRSINT1, CLRSELTIMEO);
d1334 92
a1425 46
			break;
                    case SEND_REJECT: 
			{
				u_char rejbyte = AHC_INB(ahc, REJBYTE);
				if(( rejbyte & 0xf0) == 0x20) {
					/* Tagged Message */
					printf("\n%s:%c:%d: Tagged message "
						"received without identify. "
						"Disabling tagged commands "
						"for this target.\n", 
						ahc_name(ahc),
					        channel, target);
					ahc->tagenable &= ~targ_mask;
				}
				else
					printf("%s:%c:%d: Warning - "
					       "unknown message recieved from "
					       "target (0x%x - 0x%x).  Rejecting\n", 
						ahc_name(ahc), channel, target,
						rejbyte,
					        AHC_INB(ahc, REJBYTE_EXT));
				break; 
			}
                    case NO_IDENT: 
                        panic("%s:%c:%d: Target did not send an IDENTIFY "
			      "message. SAVED_TCL == 0x%x\n",
                              ahc_name(ahc), channel, target,
			      AHC_INB(ahc, SAVED_TCL));
			break;
                    case BAD_PHASE:
                        printf("%s:%c:%d: unknown scsi bus phase.  "
			      "Attempting to continue\n",
			      ahc_name(ahc), channel, target);  
                        break; 
                    case SDTR_MSG:
			{
				short period;
				u_char offset, rate;
				u_char targ_scratch;
				u_char maxoffset;
	                        /* 
				 * Help the sequencer to translate the 
				 * negotiated transfer rate.  Transfer is 
				 * 1/4 the period in ns as is returned by 
				 * the sync negotiation message.  So, we must 
				 * multiply by four
a1426 42
	                        period = AHC_INB(ahc, ARG_1) << 2;
				offset = AHC_INB(ahc, ACCUM);
				targ_scratch = AHC_INB(ahc, TARG_SCRATCH 
						   + scratch_offset);
				if(targ_scratch & WIDEXFER)
					maxoffset = 0x08;
				else
					maxoffset = 0x0f;
				ahc_scsirate(ahc, &rate, period,
					     MIN(offset, maxoffset),
					     channel, target);
				/* Preserve the WideXfer flag */
				targ_scratch = rate | (targ_scratch & WIDEXFER);
				AHC_OUTB(ahc, TARG_SCRATCH + scratch_offset,
				     targ_scratch);
				AHC_OUTB(ahc, SCSIRATE, targ_scratch); 
				if( (targ_scratch & 0x0f) == 0 ) 
				{
					/*
					 * The requested rate was so low
					 * that asyncronous transfers are
					 * faster (not to mention the
					 * controller won't support them),
					 * so we issue a message reject to
					 * ensure we go to asyncronous
					 * transfers.
					 */
					AHC_OUTB(ahc, RETURN_1, SEND_REJ);
				}
				/* See if we initiated Sync Negotiation */
				else if(ahc->sdtrpending & targ_mask)
				{
					/*
					 * Don't send an SDTR back to
					 * the target
					 */
					AHC_OUTB(ahc, RETURN_1, 0);
				}
				else{
					/*
					 * Send our own SDTR in reply
					 */
d1428 2
a1429 2
					if(ahc_debug & AHC_SHOWMISC)
						printf("Sending SDTR!!\n");
d1431 4
a1434 2
					AHC_OUTB(ahc, RETURN_1, SEND_SDTR);
				}
d1436 4
a1439 1
				 * Negate the flags
d1441 4
a1444 3
				ahc->needsdtr &= ~targ_mask;
				ahc->sdtrpending &= ~targ_mask;
	                        break;
d1446 5
a1450 3
                    case WDTR_MSG:
			{
				u_char scratch, bus_width;
d1452 5
a1456 1
				bus_width = AHC_INB(ahc, ARG_1);
d1458 3
a1460 2
				scratch = AHC_INB(ahc, TARG_SCRATCH
					      + scratch_offset);
d1462 18
a1479 2
				if(ahc->wdtrpending & targ_mask)
				{
d1481 2
a1482 2
					 * Don't send a WDTR back to the
					 * target, since we asked first.
d1484 24
a1507 10
					AHC_OUTB(ahc, RETURN_1, 0);
					switch(bus_width)
					{
						case BUS_8_BIT:
						    scratch &= 0x7f;
						    break;
						case BUS_16_BIT:
						    if(bootverbose)
		        				printf("%s: target "
							       "%d using 16Bit "
d1511 5
a1515 107
						    scratch |= 0x80;	
						    break;
						case BUS_32_BIT:
						    /*
						     * How can we do 32bit
						     * transfers on a 16bit
						     * bus?
						     */
						    AHC_OUTB(ahc, RETURN_1,
							 SEND_REJ);
		        			    printf("%s: target "
						           "%d requested 32Bit "
						           "transfers.  "
							   "Rejecting...\n",
							   ahc_name(ahc),
							   target);
						    break;
						default:
						    break;
					}
				}
				else {
					/*
					 * Send our own WDTR in reply
					 */
					switch(bus_width)
					{
						case BUS_8_BIT:
							scratch &= 0x7f;
							break;
						case BUS_32_BIT:
						case BUS_16_BIT:
						    if(ahc->type & AHC_WIDE) {
							/* Negotiate 16_BITS */
							bus_width = BUS_16_BIT;
							if(bootverbose)
							    printf("%s: "
								"target %d "
								"using 16Bit "
							        "transfers\n",
								ahc_name(ahc),
								target);
						 	scratch |= 0x80;	
						    }
						    else
							bus_width = BUS_8_BIT;
						    break;
						default:
						    break;
					}
					AHC_OUTB(ahc, RETURN_1,
						bus_width | SEND_WDTR);
				}
				ahc->needwdtr &= ~targ_mask;
				ahc->wdtrpending &= ~targ_mask;
				AHC_OUTB(ahc, TARG_SCRATCH + scratch_offset, 
				     scratch);
				AHC_OUTB(ahc, SCSIRATE, scratch); 
	                        break;
			}
		    case REJECT_MSG:
			{
				/*
				 * What we care about here is if we had an
				 * outstanding SDTR or WDTR message for this
				 * target.  If we did, this is a signal that
				 * the target is refusing negotiation.
				 */

				u_char targ_scratch;

				targ_scratch = AHC_INB(ahc, TARG_SCRATCH
						   + scratch_offset);

				if(ahc->wdtrpending & targ_mask){
					/* note 8bit xfers and clear flag */
					targ_scratch &= 0x7f;
					ahc->needwdtr &= ~targ_mask;
					ahc->wdtrpending &= ~targ_mask;
        				printf("%s:%c:%d: refuses "
					       "WIDE negotiation.  Using "
					       "8bit transfers\n",
						ahc_name(ahc),
					        channel, target);
				}
				else if(ahc->sdtrpending & targ_mask){
					/* note asynch xfers and clear flag */
					targ_scratch &= 0xf0;
					ahc->needsdtr &= ~targ_mask;
					ahc->sdtrpending &= ~targ_mask;
        				printf("%s:%c:%d: refuses "
					       "syncronous negotiation.  Using "
					       "asyncronous transfers\n",
						ahc_name(ahc),
					        channel, target);
				}
				else {
					/*
					 * Otherwise, we ignore it.
					 */
#ifdef AHC_DEBUG
					if(ahc_debug & AHC_SHOWMISC)
						printf("%s:%c:%d: Message "
						       "reject -- ignored\n",
							ahc_name(ahc),
						        channel, target);
#endif
d1518 3
a1520 4
				AHC_OUTB(ahc, TARG_SCRATCH + scratch_offset,
				     targ_scratch);
				AHC_OUTB(ahc, SCSIRATE, targ_scratch);
				break;
d1522 20
a1541 3
                    case BAD_STATUS:
			{
			  int	scb_index;
d1543 1
a1543 25
			  /* The sequencer will notify us when a command
			   * has an error that would be of interest to
			   * the kernel.  This allows us to leave the sequencer
			   * running in the common case of command completes
			   * without error.
			   */

  			  scb_index = AHC_INB(ahc, SCB_TAG);
			  scb = ahc->scbarray[scb_index];

			  /*
			   * Set the default return value to 0 (don't
			   * send sense).  The sense code will change
			   * this if needed and this reduces code
			   * duplication.
			   */
			  AHC_OUTB(ahc, RETURN_1, 0);
		 	  if (!(scb && (scb->flags & SCB_ACTIVE))) {
				printf("%s:%c:%d: ahc_intr - referenced scb "
				       "not valid during seqint 0x%x scb(%d)\n",
				       ahc_name(ahc),
				       channel, target, intstat,
				       scb_index);
			      goto clear;
			  }
d1545 2
a1546 3
			  xs = scb->xs;

			  scb->status = AHC_INB(ahc, SCB_TARGET_STATUS);
d1548 21
d1570 3
a1572 17
			  if((ahc_debug & AHC_SHOWSCBS)
			    && xs->sc_link->target == DEBUGTARG)
				ahc_print_scb(scb);
#endif
			  xs->status = scb->status;
			  switch(scb->status){
			    case SCSI_OK:
				printf("%s: Interrupted for staus of"
					" 0???\n", ahc_name(ahc));
				break;
			    case SCSI_CHECK:
#ifdef AHC_DEBUG
				if(ahc_debug & AHC_SHOWSENSE)
				{
					sc_print_addr(xs->sc_link);
					printf("requests Check Status\n");
				}
d1574 10
d1585 6
a1590 35
				if((xs->error == XS_NOERROR) &&
				    !(scb->flags & SCB_SENSE)) {
					struct ahc_dma_seg *sg = scb->ahc_dma;
					struct scsi_sense *sc = &(scb->sense_cmd);
#ifdef AHC_DEBUG
					if(ahc_debug & AHC_SHOWSENSE)
					{
						sc_print_addr(xs->sc_link);
						printf("Sending Sense\n");
					}
#endif
#if defined(__FreeBSD__)
					sc->op_code = REQUEST_SENSE;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
					sc->opcode = REQUEST_SENSE;
#endif
					sc->byte2 =  xs->sc_link->lun << 5;
					sc->length = sizeof(struct scsi_sense_data);
					sc->control = 0;

					sg->addr = KVTOPHYS(&xs->sense);
					sg->len = sizeof(struct scsi_sense_data);

					scb->control &= DISCENB;
					scb->status = 0;
					scb->SG_segment_count = 1;
					scb->SG_list_pointer = KVTOPHYS(sg);
			                scb->data = sg->addr; 
					scb->datalen = sg->len;
#ifdef AHC_BROKEN_CACHE
					if (ahc_broken_cache)
						INVALIDATE_CACHE();
#endif
					scb->cmdpointer = KVTOPHYS(sc);
					scb->cmdlen = sizeof(*sc);
d1592 2
a1593 9
					scb->flags |= SCB_SENSE;
					ahc_send_scb(ahc, scb);
					/*
					 * Ensure that the target is "BUSY"
					 * so we don't get overlapping 
					 * commands if we happen to be doing
					 * tagged I/O.
					 */
					ahc_busy_target(ahc, target, channel);
d1595 15
a1609 56
					/*
					 * Make us the next command to run
					 */
					ahc_add_waiting_scb(ahc, scb);
					AHC_OUTB(ahc, RETURN_1, SEND_SENSE);
					break;
				}
				/*
				 * Clear the SCB_SENSE Flag and have
				 * the sequencer do a normal command
				 * complete with either a "DRIVER_STUFFUP"
				 * error or whatever other error condition
				 * we already had.
				 */
				scb->flags &= ~SCB_SENSE;
				if(xs->error == XS_NOERROR)
					xs->error = XS_DRIVER_STUFFUP;
				break;
			    case SCSI_BUSY:
				xs->error = XS_BUSY;
				sc_print_addr(xs->sc_link);
				printf("Target Busy\n");
				break;
			    case SCSI_QUEUE_FULL:
				/*
				 * The upper level SCSI code will someday
				 * handle this properly.
				 */
				sc_print_addr(xs->sc_link);
				printf("Queue Full\n");
				scb->flags |= SCB_ASSIGNEDQ;
				STAILQ_INSERT_TAIL(&ahc->assigned_scbs,
						   scb, links);
				break;
			    default:
				sc_print_addr(xs->sc_link);
				printf("unexpected targ_status: %x\n",
					scb->status);
				xs->error = XS_DRIVER_STUFFUP;
				break;
			}
			break;
		  }
		  case RESIDUAL:
		  {
			int   scb_index;
			scb_index = AHC_INB(ahc, SCB_TAG);
			scb = ahc->scbarray[scb_index];
			xs = scb->xs;
			/*
			 * Don't clobber valid resid info with
			 * a resid coming from a check sense
			 * operation.
			 */
			if(!(scb->flags & SCB_SENSE)) {
				int resid_sgs;
d1611 1
a1611 8
				/*
				 * Remainder of the SG where the transfer
				 * stopped.
				 */
				xs->resid =
					(AHC_INB(ahc, SCB_RESID_DCNT2)<<16) |
					(AHC_INB(ahc, SCB_RESID_DCNT1)<<8)  |
					 AHC_INB(ahc, SCB_RESID_DCNT0);
d1613 1
a1613 13
				/*
				 * Add up the contents of all residual
				 * SG segments that are after the SG where
				 * the transfer stopped.
				 */
				resid_sgs = AHC_INB(ahc, SCB_RESID_SGCNT) - 1;
				while(resid_sgs > 0) {
					int sg;

					sg = scb->SG_segment_count - resid_sgs;
					xs->resid += scb->ahc_dma[sg].len;
					resid_sgs--;
				}
a1614 5
#if defined(__FreeBSD__)
				xs->flags |= SCSI_RESID_VALID;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
				/* XXX - Update to do this right */
#endif
d1616 9
a1624 7
				if(ahc_debug & AHC_SHOWMISC) {
					sc_print_addr(xs->sc_link);
					printf("Handled Residual of %ld bytes\n"
						,xs->resid);
				}
#endif
			}
d1626 3
a1628 30
		  }
		  case ABORT_TAG:
		  {
			int   scb_index;
			scb_index = AHC_INB(ahc, SCB_TAG);
			scb = ahc->scbarray[scb_index];
			xs = scb->xs;
			/*
			 * We didn't recieve a valid tag back from
			 * the target on a reconnect.
			 */
			sc_print_addr(xs->sc_link);
			printf("invalid tag recieved -- sending ABORT_TAG\n");
			xs->error = XS_DRIVER_STUFFUP;
			untimeout(ahc_timeout, (caddr_t)scb);
			ahc_done(ahc, scb);
			break;
		  }
		  case AWAITING_MSG:
		  {
			int   scb_index;
			scb_index = AHC_INB(ahc, SCB_TAG);
			scb = ahc->scbarray[scb_index];
			/*
			 * This SCB had a zero length command, informing
			 * the sequencer that we wanted to send a special
			 * message to this target.  We only do this for
			 * BUS_DEVICE_RESET messages currently.
			 */
			if(scb->flags & SCB_DEVICE_RESET)
d1630 2
a1631 4
				AHC_OUTB(ahc, MSG0,
					MSG_BUS_DEVICE_RESET);
				AHC_OUTB(ahc, MSG_LEN, 1);
				printf("Bus Device Reset Message Sent\n");
d1633 48
a1680 15
			else
				panic("ahc_intr: AWAITING_MSG for an SCB that "
					"does not have a waiting message");
			break;
		  }
		  case IMMEDDONE:
		  {
			/*
			 * Take care of device reset messages
			 */
			u_char scbindex = AHC_INB(ahc, SCB_TAG);
			scb = ahc->scbarray[scbindex];
			if(scb->flags & SCB_DEVICE_RESET) {
				u_char targ_scratch;
				int found;
d1682 1
a1682 2
				 * Go back to async/narrow transfers and
				 * renegotiate.
d1684 3
a1686 18
				ahc_unbusy_target(ahc, target, channel);
				ahc->needsdtr |= ahc->needsdtr_orig & targ_mask;
				ahc->needwdtr |= ahc->needwdtr_orig & targ_mask;
				ahc->sdtrpending &= ~targ_mask;
				ahc->wdtrpending &= ~targ_mask;
				targ_scratch = AHC_INB(ahc, TARG_SCRATCH 
							+ scratch_offset);
				targ_scratch &= SXFR;
				AHC_OUTB(ahc, TARG_SCRATCH + scratch_offset,
					targ_scratch);
				found = ahc_reset_device(ahc, target,
						channel, SCB_LIST_NULL, 
						XS_NOERROR);
				sc_print_addr(scb->xs->sc_link);
				printf("Bus Device Reset delivered. "
					"%d SCBs aborted\n", found);
				ahc->in_timeout = FALSE;
				ahc_run_done_queue(ahc);
a1687 23
			else
				panic("ahc_intr: Immediate complete for "
				      "unknown operation.");
			break;
		  }
		  case DATA_OVERRUN:
		  {
			/*
			 * When the sequencer detects an overrun, it
			 * sets STCNT to 0x00ffffff and allows the
			 * target to complete its transfer in
			 * BITBUCKET mode.
			 */
			u_char scbindex = AHC_INB(ahc, SCB_TAG);
			u_int32_t overrun;
			scb = ahc->scbarray[scbindex];
			overrun = AHC_INB(ahc, STCNT0)
				| (AHC_INB(ahc, STCNT1) << 8)
				| (AHC_INB(ahc, STCNT2) << 16);
			overrun = 0x00ffffff - overrun;
			sc_print_addr(scb->xs->sc_link);
			printf("data overrun of %d bytes detected."
			       "  Forcing a retry.\n", overrun);
d1689 5
a1693 2
			 * Set this and it will take affect when the
			 * target does a command complete.
d1695 3
a1697 1
			scb->xs->error = XS_DRIVER_STUFFUP;
d1699 4
a1702 4
		  }
#if NOT_YET
		  /* XXX Fill these in later */
		  case MESG_BUFFER_BUSY:
d1704 10
a1713 1
		  case MSGIN_PHASEMIS:
d1715 4
a1718 5
#endif
		  default:
			printf("ahc_intr: seqint, "
			       "intstat == 0x%x, scsisigi = 0x%x\n",
			       intstat, AHC_INB(ahc, SCSISIGI));
d1721 6
a1726 6
clear:
		/*
		 * Clear the upper byte that holds SEQINT status
		 * codes and clear the SEQINT bit.
		 */
		AHC_OUTB(ahc, CLRINT, CLRSEQINT);
d1728 3
d1732 3
a1734 3
		 *  The sequencer is paused immediately on
		 *  a SEQINT, so we should restart it when
		 *  we leave this section.
d1736 2
a1737 2
		UNPAUSE_SEQUENCER(ahc);
	   }
a1738 30

	   if (intstat & SCSIINT) {

		int scb_index = AHC_INB(ahc, SCB_TAG);
		status = AHC_INB(ahc, SSTAT1);
		scb = ahc->scbarray[scb_index];

		if (status & SCSIRSTI) {
			char channel;
			channel = AHC_INB(ahc, SBLKCTL);
			channel = channel & SELBUSB ? 'B' : 'A';
			printf("%s: Someone reset channel %c\n",
				ahc_name(ahc), channel);
			ahc_reset_channel(ahc, 
					  channel,
					  SCB_LIST_NULL,
					  XS_BUSY,
					  /* Initiate Reset */FALSE);
			scb = NULL;
		}
		else if (!(scb && (scb->flags & SCB_ACTIVE))){
			printf("%s: ahc_intr - referenced scb not "
			       "valid during scsiint 0x%x scb(%d)\n",
				ahc_name(ahc), status, scb_index);
			AHC_OUTB(ahc, CLRSINT1, status);
			UNPAUSE_SEQUENCER(ahc);
			AHC_OUTB(ahc, CLRINT, CLRSCSIINT);
			scb = NULL;
		}
		else if (status & SCSIPERR) {
d1740 2
a1741 2
			 * Determine the bus phase and
			 * queue an appropriate message
d1743 3
a1745 34
			char	*phase;
			u_char	mesg_out = MSG_NOP;
			u_char	lastphase = AHC_INB(ahc, LASTPHASE);

			xs = scb->xs;
			sc_print_addr(xs->sc_link);

			switch(lastphase) {
				case P_DATAOUT:
					phase = "Data-Out";
					break;
				case P_DATAIN:
					phase = "Data-In";
					mesg_out = MSG_INITIATOR_DET_ERROR;
					break;
				case P_COMMAND:
					phase = "Command";
					break;
				case P_MESGOUT:
					phase = "Message-Out";
					break;
				case P_STATUS:
					phase = "Status";
					mesg_out = MSG_INITIATOR_DET_ERROR;
					break;
				case P_MESGIN:
					phase = "Message-In";
					mesg_out = MSG_MSG_PARITY_ERROR;
					break;
				default:
					phase = "unknown";
					break;
			}
                        printf("parity error during %s phase.\n", phase);
d1748 3
a1750 5
			 * We've set the hardware to assert ATN if we   
			 * get a parity error on "in" phases, so all we  
			 * need to do is stuff the message buffer with
			 * the appropriate message.  "In" phases have set
			 * mesg_out to something other than MSG_NOP.
d1752 7
a1758 3
			if(mesg_out != MSG_NOP) {
				AHC_OUTB(ahc, MSG0, mesg_out);
				AHC_OUTB(ahc, MSG_LEN, 1);
a1759 10
			else
				/*
				 * Should we allow the target to make
				 * this decision for us?
				 */
				xs->error = XS_DRIVER_STUFFUP;
		}
		else if (status & SELTO) {
			u_char waiting;
			u_char flags;
a1760 9
			xs = scb->xs;
			xs->error = XS_SELTIMEOUT;
			/*
			 * Clear any pending messages for the timed out
			 * target, and mark the target as free
			 */
			flags = AHC_INB(ahc, FLAGS);
			AHC_OUTB(ahc, MSG_LEN, 0);
			ahc_unbusy_target(ahc, xs->sc_link->target,
d1762 1
a1762 1
			 	((long)xs->sc_link->fordriver & SELBUSB)
d1764 8
a1771 1
				IS_SCSIBUS_B(ahc, xs->sc_link)
a1772 30
				 	? 'B' : 'A');
			/* Stop the selection */
			AHC_OUTB(ahc, SCSISEQ, 0);

			AHC_OUTB(ahc, SCB_CONTROL, 0);

			AHC_OUTB(ahc, CLRSINT1, CLRSELTIMEO);

			AHC_OUTB(ahc, CLRINT, CLRSCSIINT);

			/* Shift the waiting for selection queue forward */
			waiting = AHC_INB(ahc, WAITING_SCBH);
			AHC_OUTB(ahc, SCBPTR, waiting);
			waiting = AHC_INB(ahc, SCB_NEXT);
			AHC_OUTB(ahc, WAITING_SCBH, waiting);

			RESTART_SEQUENCER(ahc);
		}       
		else if (!(status & BUSFREE)) {
		      sc_print_addr(scb->xs->sc_link);
		      printf("Unknown SCSIINT. Status = 0x%x\n", status);
		      AHC_OUTB(ahc, CLRSINT1, status);
		      UNPAUSE_SEQUENCER(ahc);
		      AHC_OUTB(ahc, CLRINT, CLRSCSIINT);
		      scb = NULL;
		}
		if(scb != NULL) {
		    /* We want to process the command */
		    untimeout(ahc_timeout, (caddr_t)scb);
		    ahc_done(ahc, scb);
d1774 1
d1776 2
a1777 1
	if (intstat & CMDCMPLT) {
d1779 1
d1781 127
a1907 19
		do {
			scb_index = AHC_INB(ahc, QOUTFIFO);
			scb = ahc->scbarray[scb_index];
			if (!scb || !(scb->flags & SCB_ACTIVE)) {
				printf("%s: WARNING "
				       "no command for scb %d (cmdcmplt)\n"
				       "QOUTCNT == %d\n",
					ahc_name(ahc), scb_index,
					AHC_INB(ahc, QOUTCNT));
				AHC_OUTB(ahc, CLRINT, CLRCMDINT);
				continue;
			}
			AHC_OUTB(ahc, CLRINT, CLRCMDINT);
			untimeout(ahc_timeout, (caddr_t)scb);
			ahc_done(ahc, scb);

		} while (AHC_INB(ahc, QOUTCNT) & ahc->qcntmask);

		ahc_run_waiting_queues(ahc);
d1909 6
a1914 2
#if defined(__NetBSD__) || defined(__OpenBSD__)
	return 1;
d1916 20
d1973 1
a1973 1
	 * Since NetBSD doesn't have error ignoring operation mode
d2025 3
a2027 3
	u_char	scsi_conf, sblkctl, i;
	u_short	ultraenable = 0;
	int     max_targ = 15;
d2143 1
d2147 1
d2172 1
d2175 1
d2316 1
d2320 1
d2324 1
d2327 1
d2331 1
a2331 1
	UNPAUSE_SEQUENCER(ahc);
d2406 1
a2406 1
	if (flags & SCSI_RESET)
d2408 2
d2426 2
a2427 1
		scb->control |= NEEDWDTR;
d2432 2
a2433 1
		scb->control |= NEEDSDTR;
d2540 1
a2540 1
		PAUSE_SEQUENCER(ahc);
d2546 1
a2546 1
		UNPAUSE_SEQUENCER(ahc);
d2619 1
a2619 1
		STAILQ_INSERT_HEAD(&ahc->assigned_scbs, wscb, links);
d2727 1
d2729 4
d2821 1
a2821 1
	PAUSE_SEQUENCER(ahc);
d2889 1
a2889 1
		UNPAUSE_SEQUENCER(ahc);
d2952 1
d2964 1
a2964 1
				UNPAUSE_SEQUENCER(ahc);
d2970 1
a2970 1
				AHC_OUTB(ahc, MSG0, MSG_BUS_DEVICE_RESET);
d2987 1
a2987 1
				UNPAUSE_SEQUENCER(ahc);
d3295 1
a3295 1
		UNPAUSE_SEQUENCER(ahc);
d3305 1
a3305 1
		RESTART_SEQUENCER(ahc);
d3338 29
@


1.12
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.11 1996/10/31 01:01:24 niklas Exp $	*/
d580 1
a580 1
int	ahcprint __P((void *, char *));
d585 1
a585 1
	char *name;
@


1.11
log
@$OpenBSD RCSIDs
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.c,v 1.10 1996/10/16 10:25:07 deraadt Exp $	*/
d121 1
a121 1
#include <machine/bus.h>
@


1.10
log
@-W clean
@
text
@d1 2
a34 2
 *
 *      $Id: aic7xxx.c,v 1.9 1996/08/21 22:27:32 deraadt Exp $
d36 1
@


1.9
log
@check for __OpenBSD__, prep for tossing __NetBSD__?
@
text
@d34 1
a34 1
 *      $Id: aic7xxx.c,v 1.8 1996/07/02 20:18:51 deraadt Exp $
d579 2
d600 1
d602 1
@


1.8
log
@handle SCSI_QUEUE_FULL correctly
@
text
@d34 1
a34 1
 *      $Id: aic7xxx.c,v 1.7 1996/06/27 21:15:47 shawn Exp $
d118 1
a118 1
#if defined(__NetBSD__)
d129 1
a129 1
#if defined(__NetBSD__)
d148 1
a148 1
#if defined(__NetBSD__)
d245 1
a245 1
#if defined(__NetBSD__)
d294 1
a294 1
#elif defined(__NetBSD__)
d313 1
a313 1
#elif defined(__NetBSD__)
d392 1
a392 1
#elif defined(__NetBSD__)
d430 1
a430 1
#elif defined(__NetBSD__)
d458 1
a458 1
#elif defined(__NetBSD__)
d473 1
a473 1
#elif defined(__NetBSD__)
d484 1
a484 1
#elif defined(__NetBSD__)
d492 1
a492 1
#elif defined(__NetBSD__)
d499 1
a499 1
#elif defined(__NetBSD__)
d578 1
a578 1
#if defined(__NetBSD__)
d611 1
a611 1
#elif defined(__NetBSD__)
d627 1
a627 1
#elif defined(__NetBSD__)
d669 1
a669 1
#elif defined(__NetBSD__)
d915 1
a915 1
#elif defined (__NetBSD__)
d935 1
a935 1
#elif defined(__NetBSD__)
d1446 1
a1446 1
#elif defined(__NetBSD__)
d1561 1
a1561 1
#elif defined(__NetBSD__)
d1807 1
a1807 1
#elif defined(__NetBSD__)
d1865 1
a1865 1
#if defined(__NetBSD__)
d1887 1
a1887 1
#if defined(__NetBSD__)
d1903 1
a1903 1
#elif defined(__NetBSD__)
d2278 1
a2278 1
#if defined(__NetBSD__)
d2306 1
a2306 1
#elif defined(__NetBSD__)
d2359 1
a2359 1
#elif defined(__NetBSD__)
@


1.7
log
@new 2940 driver merged from freebsd sources 960623
@
text
@d34 1
a34 1
 *      $Id: aic7xxx.c,v 1.75 1996/06/23 20:02:37 gibbs Exp $
a1501 1
#ifdef __FreeBSD__
a1512 1
#endif
@


1.6
log
@sync 0521
@
text
@a0 2
/*	$NetBSD: aic7xxx.c,v 1.8 1996/05/20 00:58:07 thorpej Exp $	*/

d5 1
a5 1
 * pci/aic7870.c	3940, 2940, aic7870 and aic7850 controllers
d33 2
a160 2
#define PAGESIZ NBPG

d172 1
a172 1
static int     ahc_debug = AHC_SHOWSENSE;
d240 2
a241 2
	} while (AHC_INB(ahc, SEQADDR0) != 0 &&				\
		 AHC_INB(ahc, SEQADDR1) != 0);				\
d289 2
a290 1
				  int period, int offset, int target));
a367 5
	{ 0x130, 175,  "5.7"  },
	{ 0x140, 200,  "5.0"  },
	{ 0x150, 225,  "4.4"  },
	{ 0x160, 250,  "4.0"  },
	{ 0x170, 275,  "3.6"  },
d421 4
a424 4
	SIMPLEQ_INIT(&ahc->free_scbs);
	SIMPLEQ_INIT(&ahc->page_scbs);
	SIMPLEQ_INIT(&ahc->waiting_scbs);
	SIMPLEQ_INIT(&ahc->assigned_scbs);
d427 2
d508 1
a508 1
ahc_scsirate(ahc, scsirate, period, offset, target )
d513 1
d519 3
d528 25
a552 3
			if (ahc->type & AHC_ULTRA) {
				if (!(ahc_syncrates[i].sxfr & ULTRA_SXFR))
					break; /* Use Async */
d555 2
a556 10
				if (ahc_syncrates[i].sxfr & ULTRA_SXFR) {
					/*
					 * This should only happen if the
					 * drive is the first to negotiate
					 * and chooses a high rate.  We'll
					 * just move down the table util
					 * we hit a non ultra speed.
					 */
					continue;
				}
d558 3
a560 1
			*scsirate = (ahc_syncrates[i].sxfr) | (offset & 0x0f);
d779 1
a779 1
	if(!(ahc->assigned_scbs.sqh_first || ahc->waiting_scbs.sqh_first))
d789 2
a790 2
	while((scb = ahc->assigned_scbs.sqh_first) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&ahc->assigned_scbs, scb, links);
d795 1
a795 1
		scb->flags = SCB_ACTIVE;
d805 1
a805 1
	if((scb = ahc->waiting_scbs.sqh_first) != NULL) {
d818 1
a818 2
			 * Advance disc_scb to the next on in the
			 * list.
d841 1
a841 2
				SIMPLEQ_REMOVE_HEAD(&ahc->waiting_scbs, scb,
				    links);
d854 1
a854 1
				scb->flags = SCB_ACTIVE;
d871 1
a871 1
		} while((scb = ahc->waiting_scbs.sqh_first) != NULL);
d923 3
a925 3
	struct scb *scb = NULL;
	struct scsi_xfer *xs = NULL;
	struct ahc_data *ahc = (struct ahc_data *)arg;
d927 1
a927 1
        intstat = AHC_INB(ahc, INTSTAT);
a952 5
		/*
		 * This code isn't used by the SCB page-in code.  It
		 * should probably be moved to cut out the extra
		 * inb.
		 */
a963 33
                    case BAD_PHASE:
                        panic("%s:%c:%d: unknown scsi bus phase.  "
			      "Attempting to continue\n",
			      ahc_name(ahc), channel, target);  
                        break; 
                    case SEND_REJECT: 
			{
				u_char rejbyte = AHC_INB(ahc, REJBYTE);
				if(( rejbyte & 0xf0) == 0x20) {
					/* Tagged Message */
					printf("\n%s:%c:%d: Tagged message "
						"received without identify. "
						"Disabling tagged commands "
						"for this target.\n", 
						ahc_name(ahc),
					        channel, target);
					ahc->tagenable &= ~targ_mask;
				}
				else
					printf("%s:%c:%d: Warning - "
					       "unknown message recieved from "
					       "target (0x%x - 0x%x).  Rejecting\n", 
						ahc_name(ahc), channel, target,
						rejbyte,
					        AHC_INB(ahc, REJBYTE_EXT));
				break; 
			}
                    case NO_IDENT: 
                        panic("%s:%c:%d: Target did not send an IDENTIFY "
			      "message. SAVED_TCL == 0x%x\n",
                              ahc_name(ahc), channel, target,
			      AHC_INB(ahc, SAVED_TCL));
			break;
d972 12
d993 4
d1004 4
a1007 3
				if((outscb = ahc->free_scbs.sqh_first) != NULL) {
					SIMPLEQ_REMOVE_HEAD(&ahc->free_scbs,
					    outscb, links);
d1010 2
a1011 2
					SIMPLEQ_INSERT_HEAD(&ahc->page_scbs,
					    outscb, links);
d1017 6
a1022 3
				if((outscb = ahc->assigned_scbs.sqh_first) != NULL) {
					SIMPLEQ_REMOVE_HEAD(&ahc->assigned_scbs,
					    outscb, links);
d1025 2
a1026 3
					SIMPLEQ_INSERT_HEAD(&ahc->waiting_scbs,
					    outscb, links);
					outscb->flags = SCB_WAITINGQ;
a1034 1
					printf("PIC\n");
d1088 2
a1089 2
						int saved_queue[AHC_SCB_MAX];
						int queued = AHC_INB(ahc, QINCNT) & ahc->qcntmask;
d1111 1
a1111 1
					SIMPLEQ_INSERT_HEAD(&ahc->waiting_scbs,
d1113 1
a1113 1
					outscb->flags = SCB_WAITINGQ;
d1117 1
a1117 1
				else
d1119 2
a1121 1
				AHC_OUTB(ahc, RETURN_1, SCB_PAGEDIN);
d1136 33
d1190 3
a1192 3
				ahc_scsirate(ahc, &rate, period, 
					     MIN(offset,maxoffset),
					    target);
d1502 1
a1502 1
#if defined(__FreeBSD__)
d1505 1
a1505 1
				 * The upper level SCSI code will eventually
d1510 2
a1511 2
				scb->flags = SCB_ASSIGNEDQ;
				SIMPLEQ_INSERT_TAIL(&ahc->assigned_scbs,
a1513 7
#elif defined(__NetBSD__)
				 /*
				  * XXX -
				  *	Do we need to handle this ?
				  *	But FreeBSD MI SCSI code seems to
				  *	do nothing about this.
				  */
d1654 25
a1711 1

a1712 2
		if (scb != NULL) /* XXX - is this case exist ? */
			xs = scb->xs;
d1745 1
d1777 2
a1778 2
			 * We've set the hardware to assert ATN if we
			 * get a parity error on "in" phases, so all we
d1780 1
a1780 1
			 * the appropriate message.  In phases have set
d1797 3
a1799 1
                        xs->error = XS_SELTIMEOUT;
d1813 2
d1831 1
a1831 1
		      sc_print_addr(xs->sc_link);
d1960 1
d2167 16
d2201 3
d2277 2
a2278 2
        if (bp->b_bcount > ((AHC_NSEG - 1) * PAGESIZ)) {
                bp->b_bcount = ((AHC_NSEG - 1) * PAGESIZ);
d2294 7
a2300 7
        struct	scb *scb;
        struct	ahc_dma_seg *sg;
        int     seg;            /* scatter gather seg being worked on */
        int     thiskv;
        physaddr thisphys, nextphys;
        int     bytes_this_seg, bytes_this_page, datalen, flags;
        struct	ahc_data *ahc;
d2302 1
a2302 1
        int     s;
d2305 1
a2305 1
	mask  = (0x01 << (xs->sc_link->target
d2311 22
a2332 22
        SC_DEBUG(xs->sc_link, SDEV_DB2, ("ahc_scsi_cmd\n"));
        /*
         * get an scb to use. If the transfer
         * is from a buf (possibly from interrupt time)
         * then we can't allow it to sleep
         */
        flags = xs->flags;
        if (flags & ITSDONE) {
                printf("%s: Already done?", ahc_name(ahc));
                xs->flags &= ~ITSDONE;
        }
        if (!(flags & INUSE)) {
                printf("%s: Not in use?", ahc_name(ahc));
                xs->flags |= INUSE;
        }
        if (!(scb = ahc_get_scb(ahc, flags))) {
                xs->error = XS_DRIVER_STUFFUP;
                return (TRY_AGAIN_LATER);
        }
        SC_DEBUG(xs->sc_link, SDEV_DB3, ("start scb(%p)\n", scb));
        scb->xs = xs;
        if (flags & SCSI_RESET)
d2334 3
a2336 3
        /*
         * Put all the arguments for the xfer in the scb
         */
d2399 2
a2400 2
				nextphys = (thisphys & (~(PAGESIZ - 1)))
					   + PAGESIZ;
d2408 2
a2409 2
				thiskv = (thiskv & (~(PAGESIZ - 1)))
					 + PAGESIZ;
d2469 1
a2469 1
		scb->flags = SCB_ACTIVE;
d2477 2
a2478 2
		scb->flags = SCB_WAITINGQ;
		SIMPLEQ_INSERT_TAIL(&ahc->waiting_scbs, scb, links);
d2517 1
d2519 3
d2523 2
a2524 2
		SIMPLEQ_INSERT_HEAD(&ahc->page_scbs, scb, links);
		if(!scb->links.sqe_next && !ahc->free_scbs.sqh_first)
d2538 2
a2539 2
	else if((wscb = ahc->waiting_scbs.sqh_first) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&ahc->waiting_scbs, wscb, links);
d2541 2
a2542 2
		SIMPLEQ_INSERT_HEAD(&ahc->assigned_scbs, wscb, links);
		wscb->flags = SCB_ASSIGNEDQ;
d2550 2
a2551 2
		SIMPLEQ_INSERT_HEAD(&ahc->page_scbs, scb, links);
		if(!scb->links.sqe_next && !ahc->free_scbs.sqh_first)
d2559 2
a2560 5
		SIMPLEQ_INSERT_HEAD(&ahc->free_scbs, scb, links);
#ifdef AHC_DEBUG
		ahc->activescbs--;
#endif
		if(!scb->links.sqe_next && !ahc->page_scbs.sqh_first)
d2567 3
d2593 2
a2594 2
		if((scbp = ahc->free_scbs.sqh_first)) {
			SIMPLEQ_REMOVE_HEAD(&ahc->free_scbs, scbp, links);
d2596 2
a2597 2
		else if((scbp = ahc->page_scbs.sqh_first)) {
			SIMPLEQ_REMOVE_HEAD(&ahc->page_scbs, scbp, links);
d2599 1
a2599 1
		else if (ahc->numscbs < ahc->maxscbs) {
d2631 1
a2632 4
		scbp->control = 0;
		scbp->status = 0;
		scbp->flags = 0;
#ifdef AHC_DEBUG
d2637 1
a2638 1
	}
d2648 1
a2648 1
        static unsigned char seqprog[] = {
a2655 1
	AHC_OUTB(ahc, SEQCTL, FASTMODE|SEQRESET);
d2658 2
a2659 3

	} while (AHC_INB(ahc, SEQADDR0) != 0 &&
		 AHC_INB(ahc, SEQADDR1) != 0);
d2676 1
a2676 1
		printf("%s: board not responding\n", ahc_name(ahc));
d2689 1
a2689 1
	int	s, h, found;
a2694 2
	h = splhigh();

a2696 1
		splx(h);
a2727 1
			splx(h);
a2732 1
	splx(h);
d2949 2
a2950 2
		int saved_queue[AHC_SCB_MAX];
		int queued = AHC_INB(ahc, QINCNT) & ahc->qcntmask;
@


1.5
log
@ahc/ahe driver update from freebsd; merged by soda@@sra.co.jp and
pete@@demon.net
@
text
@d1 2
a34 2
 *
 *      $Id: aic7xxx.c,v 1.65 1996/04/28 19:21:19 gibbs Exp $
a119 3
#if NetBSD1_1 < 3
#include <machine/pio.h>
#else
a120 1
#ifdef __alpha__
a121 2
#endif
#endif
a145 3

#define	AHCNAME_FMT		"ahc%d"
#define	AHCNAME_VAR(ahc)	(ahc)->unit
d149 1
a150 1
#include <dev/microcode/aic7xxx/aic7xxx_reg.h>
a158 3

#define	AHCNAME_FMT		"%s"
#define	AHCNAME_VAR(ahc)	(ahc)->sc_dev.dv_xname
d169 1
d171 1
d177 2
a178 2
#ifdef AIC7XXX_BROKEN_CACHE
int aic7xxx_broken_cache = 1;
d228 1
a228 1
	outb(HCNTRL + ahc->baseport, ahc->pause);		\
d230 1
a230 1
	while ((inb(HCNTRL + ahc->baseport) & PAUSE) == 0)	\
d234 1
a234 1
	outb( HCNTRL + ahc->baseport, ahc->unpause )
d241 3
a243 3
		outb( SEQCTL + ahc->baseport, SEQRESET|FASTMODE );	\
	} while (inb(SEQADDR0 + ahc->baseport) != 0 &&			\
		 inb(SEQADDR1 + ahc->baseport) != 0);			\
d262 1
a262 1
				    u_char prev, u_long iobase,
d264 2
a265 1
static void	ahc_add_waiting_scb __P((u_long iobase, struct scb *scb));
d276 1
a276 1
static void	ahc_loadseq __P((u_long iobase));
d288 1
a288 1
static void	ahc_reset_current_bus __P((u_long iobase));
d298 21
a318 4
static void	ahc_busy_target __P((int target, char channel,
				     u_long iobase));
static void	ahc_unbusy_target __P((int target, char channel,
				       u_long iobase));
d369 5
a373 5
	{ 0x130,  87, "11.4"  },
	{ 0x140, 100, "10.0"  },
	{ 0x150, 112,  "8.8"  },
	{ 0x160, 125,  "8.0"  },
	{ 0x170, 137,  "7.2"  },
d396 1
d400 1
a400 1
ahc_construct(ahc, unit, bc, iobase, type, flags)
d403 1
a403 1
	bus_io_handle_t iobase;		/* XXX - ioh */
a404 1
	int unit;
d427 5
a431 4
	STAILQ_INIT(&ahc->free_scbs);
	STAILQ_INIT(&ahc->page_scbs);
	STAILQ_INIT(&ahc->waiting_scbs);
	STAILQ_INIT(&ahc->assigned_scbs);
d433 2
a434 1
#if defined(__NetBSD__)
d436 1
a437 1
	ahc->baseport = iobase;
d440 1
a440 1
	ahc->unpause = (inb(HCNTRL + iobase) & IRQMS) | INTEN;
d463 1
a463 1
ahc_reset(devname, bc, iobase)
d466 1
a466 1
	bus_io_handle_t iobase;		/* XXX - ioh */
d473 1
d475 1
d477 5
d486 5
a490 1
	while (wait--) {
a491 3
		if(!(inb(HCNTRL + iobase) & CHIPRST))
			break;
	}
d501 1
d503 3
d529 1
a529 8
				if (!(ahc_syncrates[i].sxfr & ULTRA_SXFR)) {
					printf(AHCNAME_FMT
					       ": target %d requests "
					       "%sMHz transfers, but adapter "
					       "in Ultra mode can only sync at "
					       "7.2MHz or above\n",
					       AHCNAME_VAR(ahc),
					       target, ahc_syncrates[i].rate);
a530 1
				}
d546 1
a546 2
				printf(AHCNAME_FMT
				       ": target %d synchronous at %sMHz,"
d548 1
a548 1
				        AHCNAME_VAR(ahc), target,
d557 2
a558 2
		printf(AHCNAME_FMT ": target %d using asyncronous transfers\n",
			AHCNAME_VAR(ahc), target );
d584 1
a584 1
#ifdef AIC7XXX_BROKEN_CACHE
d586 1
a586 1
		aic7xxx_broken_cache = 0;
d589 1
a589 1
	 * fill in the prototype scsi_link.
d604 14
a621 1
#if defined(__FreeBSD__)
d625 2
a626 1
	scbus->adapter_link = &ahc->sc_link;
a628 8
#elif defined(__NetBSD__)
	/*
	 * XXX - Update MI SCSI code
	 *
	 * if(ahc->type & AHC_WIDE)
	 *	XXX max target XXX = 15;
	 */
#endif
a632 1
#if defined(__FreeBSD__)
d634 2
a635 1
		printf("ahc%d: Probing channel A\n", ahc->unit);
a637 2
#elif defined(__NetBSD__)
	ahc->sc_link_b.scsibus = 0xff;	/* for IS_SCSIBUS_B(), never match */
a638 3
	printf("%s: Probing channel A\n", ahc->sc_dev.dv_xname);
	config_found((void *)ahc, &ahc->sc_link, ahcprint);
#endif
a639 6
		/* Configure the second scsi bus */
		ahc->sc_link_b = ahc->sc_link;
#if defined(__FreeBSD__)
		ahc->sc_link_b.adapter_targ = ahc->our_id_b;
		ahc->sc_link_b.adapter_bus = 1;
		ahc->sc_link_b.fordriver = (void *)SELBUSB;
d643 2
a644 1
		scbus->adapter_link = &ahc->sc_link_b;
d648 2
a649 1
			printf("ahc%d: Probing Channel B\n", ahc->unit);
d652 1
d654 22
d677 3
a679 4
		 * XXX - Update MI SCSI code
		 *
		 * if(ahc->type & AHC_WIDE)
		 *	XXX max target XXX = 15;
d681 3
a683 2
		ahc->sc_link_b.adapter_target = ahc->our_id_b;
		printf("%s: Probing channel B\n", ahc->sc_dev.dv_xname);
d685 3
a688 1
	}
d701 1
a701 3
	u_long iobase = ahc->baseport;

	outb(SCBCNT + iobase, SCBAUTO);
d704 1
a704 1
		outsb(SCBARRAY+iobase, scb, SCB_PIO_TRANSFER_SIZE);
d706 1
a706 1
		outsl(SCBARRAY+iobase, scb, 
d708 1
a708 1
	outb(SCBCNT + iobase, 0); 
d720 1
a720 3
	u_long	iobase = ahc->baseport;

	outb(SCBCNT + iobase, 0x80);     /* SCBAUTO */
d723 1
a723 1
	insb(SCBARRAY+iobase, scb, SCB_PIO_TRANSFER_SIZE);
d725 1
a725 1
	outb(SCBCNT + iobase, 0);
a761 1
	u_long iobase = ahc->baseport;
d763 1
a763 1
	if(!(ahc->assigned_scbs.stqh_first || ahc->waiting_scbs.stqh_first))
d767 1
a767 1
	cur_scb = inb(SCBPTR + iobase);
d773 3
a775 3
	while((scb = ahc->assigned_scbs.stqh_first) != NULL) {
		STAILQ_REMOVE_HEAD(&ahc->assigned_scbs, links);
		outb(SCBPTR + iobase, scb->position);
d781 1
a781 1
		outb(QINFIFO + iobase, scb->position);
d789 3
a791 3
	if((scb = ahc->waiting_scbs.stqh_first) != NULL) {
		u_char disc_scb = inb(DISCONNECTED_SCBH + iobase);
		u_char active = inb(FLAGS+iobase) & (SELECTED|IDENTIFY_SEEN);
d805 2
a806 2
			outb(SCBPTR + iobase, disc_scb);
			next_scb = inb(SCB_NEXT + iobase); 
d826 2
a827 1
				STAILQ_REMOVE_HEAD(&ahc->waiting_scbs, links);
d833 1
a833 1
				out_scbi = inb(SCB_TAG + iobase); 
d843 1
a843 1
				outb(QINFIFO + iobase, scb->position);
d857 1
a857 1
		} while((scb = ahc->waiting_scbs.stqh_first) != NULL);
d863 1
a863 1
			outb(DISCONNECTED_SCBH + iobase, disc_scb);
d865 2
a866 2
				outb(SCBPTR + iobase, disc_scb);
				outb(SCB_PREV + iobase, SCB_LIST_NULL);
d871 1
a871 1
	outb(SCBPTR + iobase, cur_scb);
d879 2
a880 2
void ahc_add_waiting_scb (iobase, scb)
	u_long iobase;
d886 2
a887 2
	curscb = inb(SCBPTR + iobase);
	next = inb(WAITING_SCBH + iobase);
d889 3
a891 3
	outb(SCBPTR+iobase, scb->position);
	outb(SCB_NEXT+iobase, next);
	outb(WAITING_SCBH + iobase, scb->position);
d893 1
a893 1
	outb(SCBPTR + iobase, curscb);
a908 1
        u_long	iobase;
d913 1
a913 2
	iobase = ahc->baseport;
        intstat = inb(INTSTAT + iobase);
d929 1
a929 1
		int i, error = inb(ERROR + iobase);
d933 4
a936 4
                panic(AHCNAME_FMT ": brkadrint, %s at seqaddr = 0x%x\n",
		      AHCNAME_VAR(ahc), hard_error[i].errmesg,
		      (inb(SEQADDR1 + iobase) << 8) |
		      inb(SEQADDR0 + iobase));
d945 1
a945 1
		u_char target = (inb(SCSIID + iobase) >> 4) & 0x0f;
d948 1
a948 1
			inb(SBLKCTL + iobase) & SELBUSB ? 'B': 'A';
d956 1
a956 1
                        panic(AHCNAME_FMT ":%c:%d: unknown scsi bus phase.  "
d958 1
a958 1
			      AHCNAME_VAR(ahc), channel, target);  
d962 1
a962 1
				u_char rejbyte = inb(REJBYTE + iobase);
d965 1
a965 2
					printf("\n" AHCNAME_FMT
					       ":%c:%d: Tagged message "
d969 1
a969 1
						AHCNAME_VAR(ahc),
d974 1
a974 1
					printf(AHCNAME_FMT ":%c:%d: Warning - "
d977 3
a979 3
						AHCNAME_VAR(ahc),
						channel, target,
						rejbyte, inb(REJBYTE_EXT + iobase));
d983 1
a983 2
                        panic(AHCNAME_FMT
			      ":%c:%d: Target did not send an IDENTIFY "
d985 2
a986 2
                              AHCNAME_VAR(ahc), channel, target,
			      inb(SAVED_TCL + iobase));
d991 3
d995 1
a995 1
				u_char arg_1 = inb(ARG_1 + iobase);
d1008 3
a1010 2
				 * an SCB that just completed or the first
				 * one on the disconnected SCB list.
d1012 3
a1014 4
				if(ahc->free_scbs.stqh_first) {
					outscb = ahc->free_scbs.stqh_first; 
					STAILQ_REMOVE_HEAD(&ahc->free_scbs,
							   links);
d1017 3
a1019 3
					STAILQ_INSERT_HEAD(&ahc->page_scbs,
							   outscb, links);
					outb(SCBPTR + iobase, scb->position);
d1022 1
d1024 3
a1026 4
				else if(ahc->assigned_scbs.stqh_first) {
					outscb = ahc->assigned_scbs.stqh_first; 
					STAILQ_REMOVE_HEAD(&ahc->assigned_scbs,
							   links);
d1029 2
a1030 2
					STAILQ_INSERT_HEAD(&ahc->waiting_scbs,
							   outscb, links);
d1032 1
a1032 1
					outb(SCBPTR + iobase, scb->position);
d1035 1
d1037 1
a1037 1
				else if(intstat & CMDCMPLT) {
d1041 3
a1043 3
					outb(CLRINT + iobase, CLRCMDINT);
					scb_index = inb(QOUTFIFO + iobase);
					if(!(inb(QOUTCNT + iobase) & ahc->qcntmask))
d1048 1
a1048 2
						printf(AHCNAME_FMT
						       ": WARNING "
d1050 3
a1052 3
							AHCNAME_VAR(ahc),
						        scb_index );
						goto use_disconnected_scb;
d1057 1
a1057 1
						outb(SCBPTR + iobase, scb->position);
d1062 1
d1065 4
a1068 12
				else {
					u_char tag;
					u_char next;
					u_char disc_scb;
use_disconnected_scb:
					disc_scb =
						inb(DISCONNECTED_SCBH + iobase);
					if(disc_scb == SCB_LIST_NULL)
						panic("Page-in request with no "
						      "candidates");
					outb(SCBPTR + iobase, disc_scb);
					tag = inb(SCB_TAG + iobase); 
d1070 1
a1070 1
					next = inb(SCB_NEXT + iobase);
d1072 2
a1073 2
						outb(SCBPTR + iobase, next);
						outb(SCB_PREV + iobase,
d1075 1
a1075 1
						outb(SCBPTR + iobase, disc_scb);
d1077 1
a1077 1
					outb(DISCONNECTED_SCBH + iobase, next);
d1080 47
a1126 1
				outb(RETURN_1 + iobase, SCB_PAGEDIN);
d1129 1
a1129 1
				printf(AHCNAME_FMT ":%c:%d: no active SCB for "
d1132 1
a1132 1
				       AHCNAME_VAR(ahc), channel, target);
d1134 5
a1138 5
					inb(SAVED_TCL + iobase));
				ahc_unbusy_target(target, channel, iobase);
				outb(SCB_CONTROL + iobase, 0);
				outb(CLRSINT1 + iobase, CLRSELTIMEO);
				outb(RETURN_1 + iobase, 0);
d1154 3
a1156 3
	                        period = inb(ARG_1 + iobase) << 2;
				offset = inb(ACCUM + iobase);
				targ_scratch = inb(TARG_SCRATCH + iobase 
d1167 1
a1167 1
				outb(TARG_SCRATCH + iobase + scratch_offset,
d1169 1
a1169 1
				outb(SCSIRATE + iobase, targ_scratch); 
d1181 1
a1181 1
					outb(RETURN_1 + iobase, SEND_REJ);
d1190 1
a1190 1
					outb(RETURN_1 + iobase, 0);
d1200 1
a1200 1
					outb(RETURN_1 + iobase, SEND_SDTR);
d1213 1
a1213 1
				bus_width = inb(ARG_1 + iobase);
d1215 1
a1215 1
				scratch = inb(TARG_SCRATCH + iobase 
d1224 1
a1224 1
					outb(RETURN_1 + iobase, 0);
d1232 1
a1232 2
		        				printf(AHCNAME_FMT
							       ": target "
d1235 1
a1235 1
							       AHCNAME_VAR(ahc),
d1245 1
a1245 1
						    outb(RETURN_1 + iobase,
d1247 1
a1247 2
		        			    printf(AHCNAME_FMT
							   ": target "
d1251 1
a1251 1
							   AHCNAME_VAR(ahc),
d1273 1
a1273 2
							    printf(AHCNAME_FMT
								": "
d1277 1
a1277 1
								AHCNAME_VAR(ahc),
d1287 1
a1287 1
					outb(RETURN_1 + iobase,
d1292 1
a1292 1
				outb(TARG_SCRATCH + iobase + scratch_offset, 
d1294 1
a1294 1
				outb(SCSIRATE + iobase, scratch); 
d1308 1
a1308 1
				targ_scratch = inb(TARG_SCRATCH + iobase
d1316 1
a1316 1
        				printf(AHCNAME_FMT ":%c:%d: refuses "
d1319 1
a1319 1
						AHCNAME_VAR(ahc),
d1327 1
a1327 1
        				printf(AHCNAME_FMT ":%c:%d: refuses "
d1330 1
a1330 1
						AHCNAME_VAR(ahc),
d1339 1
a1339 2
						printf(AHCNAME_FMT
						       ":%c:%d: Message "
d1341 1
a1341 1
							AHCNAME_VAR(ahc),
d1346 1
a1346 1
				outb(TARG_SCRATCH + iobase + scratch_offset,
d1348 1
a1348 1
				outb(SCSIRATE + iobase, targ_scratch);
d1362 1
a1362 1
  			  scb_index = inb(SCB_TAG + iobase);
d1371 1
a1371 1
			  outb(RETURN_1 + iobase, 0);
d1373 1
a1373 1
				printf(AHCNAME_FMT ":%c:%d: ahc_intr - referenced scb "
d1375 1
a1375 1
				       AHCNAME_VAR(ahc),
d1383 1
a1383 1
			  scb->status = inb(SCB_TARGET_STATUS + iobase);
d1393 2
a1394 2
				printf(AHCNAME_FMT ": Interrupted for staus of"
					" 0???\n", AHCNAME_VAR(ahc));
d1434 2
a1435 2
#ifdef AIC7XXX_BROKEN_CACHE
					if (aic7xxx_broken_cache)
d1449 1
a1449 1
					ahc_busy_target(target,channel,iobase);
d1454 2
a1455 2
					ahc_add_waiting_scb(iobase, scb);
					outb(RETURN_1 + iobase, SEND_SENSE);
d1483 1
a1483 1
				STAILQ_INSERT_TAIL(&ahc->assigned_scbs,
d1506 1
a1506 1
			scb_index = inb(SCB_TAG + iobase);
d1522 3
a1524 3
					(inb(iobase+SCB_RESID_DCNT2)<<16) |
					(inb(iobase+SCB_RESID_DCNT1)<<8)  |
					 inb(iobase+SCB_RESID_DCNT0);
d1531 1
a1531 1
				resid_sgs = inb(SCB_RESID_SGCNT + iobase) - 1;
d1558 1
a1558 1
			scb_index = inb(SCB_TAG + iobase);
d1575 1
a1575 1
			scb_index = inb(SCB_TAG + iobase);
d1585 1
a1585 1
				outb(MSG0 + iobase,
d1587 1
a1587 1
				outb(MSG_LEN + iobase, 1);
d1600 1
a1600 1
			u_char scbindex = inb(SCB_TAG + iobase);
d1609 1
a1609 1
				ahc_unbusy_target(target, channel, iobase);
d1614 1
a1614 1
				targ_scratch = inb(TARG_SCRATCH + iobase 
d1617 1
a1617 1
				outb(TARG_SCRATCH + iobase + scratch_offset,
d1643 1
a1643 1
			       intstat, inb(SCSISIGI + iobase));
d1651 1
a1651 1
		outb(CLRINT + iobase, CLRSEQINT);
d1664 2
a1665 2
		int scb_index = inb(SCB_TAG + iobase);
		status = inb(SSTAT1 + iobase);
d1673 1
a1673 1
			channel = inb(SBLKCTL + iobase);
d1675 2
a1676 2
			printf(AHCNAME_FMT ": Someone reset channel %c\n",
				AHCNAME_VAR(ahc), channel);
d1685 1
a1685 1
			printf(AHCNAME_FMT ": ahc_intr - referenced scb not "
d1687 2
a1688 2
				AHCNAME_VAR(ahc), status, scb_index);
			outb(CLRSINT1 + iobase, status);
d1690 1
a1690 1
			outb(CLRINT + iobase, CLRSCSIINT);
d1700 1
a1700 1
			u_char	lastphase = inb(LASTPHASE + iobase);
d1740 2
a1741 2
				outb(MSG0 + iobase, mesg_out);
				outb(MSG_LEN + iobase, 1);
d1758 3
a1760 3
			flags = inb(FLAGS + iobase);
			outb(MSG_LEN + iobase, 0);
			ahc_unbusy_target(xs->sc_link->target,
d1766 1
a1766 2
				 	? 'B' : 'A',
				 iobase);
d1768 1
a1768 1
			outb(SCB_CONTROL + iobase, 0);
d1770 1
a1770 1
			outb(CLRSINT1 + iobase, CLRSELTIMEO);
d1772 1
a1772 1
			outb(CLRINT + iobase, CLRSCSIINT);
d1775 4
a1778 4
			waiting = inb(WAITING_SCBH + iobase);
			outb(SCBPTR + iobase, waiting);
			waiting = inb(SCB_NEXT + iobase);
			outb(WAITING_SCBH + iobase, waiting);
d1785 1
a1785 1
		      outb(CLRSINT1 + iobase, status);
d1787 1
a1787 1
		      outb(CLRINT + iobase, CLRSCSIINT);
d1800 1
a1800 1
			scb_index = inb(QOUTFIFO + iobase);
d1803 1
a1803 1
				printf(AHCNAME_FMT ": WARNING "
d1806 3
a1808 3
					AHCNAME_VAR(ahc), scb_index,
					inb(QOUTCNT + iobase));
				outb(CLRINT + iobase, CLRCMDINT);
d1811 1
a1811 1
			outb(CLRINT + iobase, CLRCMDINT);
d1815 1
a1815 1
		} while (inb(QOUTCNT + iobase) & ahc->qcntmask);
d1878 2
a1879 3
		        printf(AHCNAME_FMT
			       ": target %d Tagged Queuing Device\n",
				AHCNAME_VAR(ahc), xs->sc_link->target);
a1910 1
	u_long	iobase = ahc->baseport;
d1923 1
a1923 1
	switch ( (sblkctl = inb(SBLKCTL + iobase) & 0x0a) ) {
d1925 2
a1926 1
		ahc->our_id = (inb(SCSICONF + iobase) & HSCSIID);
d1933 1
a1933 1
		outb(FLAGS + iobase, SINGLE_BUS | (ahc->flags & AHC_PAGESCBS));
d1936 2
a1937 1
		ahc->our_id = (inb(SCSICONF + 1 + iobase) & HWSCSIID);
d1945 1
a1945 1
		outb(FLAGS + iobase, WIDE_BUS | (ahc->flags & AHC_PAGESCBS));
d1948 2
a1949 2
		ahc->our_id = (inb(SCSICONF + iobase) & HSCSIID);
		ahc->our_id_b = (inb(SCSICONF + 1 + iobase) & HSCSIID);
d1953 1
a1953 1
		outb(FLAGS + iobase, TWIN_BUS | (ahc->flags & AHC_PAGESCBS));
d1963 2
a1964 2
		outb(SCBPTR + iobase, 0);
		outb(SCB_CONTROL + iobase, 0);
d1966 3
a1968 3
			outb(SCBPTR + iobase, i);
			outb(SCB_CONTROL + iobase, i);
			if(inb(SCB_CONTROL + iobase) != i)
d1970 2
a1971 2
			outb(SCBPTR + iobase, 0);
			if(inb(SCB_CONTROL + iobase) != 0)
d1974 2
a1975 2
			outb(SCBPTR + iobase, i);
			outb(SCB_CONTROL + iobase, 0);
d1981 2
a1982 2
		outb(SCBPTR + iobase, 0);
		outb(SCB_CONTROL + iobase, 0);
d2000 1
a2000 1
		printf(AHCNAME_FMT ": hardware scb %ld bytes; kernel scb; "
d2002 1
a2002 1
			AHCNAME_VAR(ahc),
d2016 5
a2020 4
		outb(SCSIID + iobase, ahc->our_id_b);
		scsi_conf = inb(SCSICONF + 1 + iobase) & (ENSPCHK|STIMESEL);
		outb(SXFRCTL1 + iobase, scsi_conf|ENSTIMER|ACTNEGEN|STPWEN);
		outb(SIMODE1 + iobase, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
d2022 1
a2022 1
			outb(SXFRCTL0 + iobase, DFON|SPIOEN|ULTRAEN);
d2024 1
a2024 1
			outb(SXFRCTL0 + iobase, DFON|SPIOEN);
d2026 13
a2038 8
		/* Reset the bus */
		outb(SCSISEQ + iobase, SCSIRSTO);
		DELAY(1000);
		outb(SCSISEQ + iobase, 0);

		/* Ensure we don't get a RSTI interrupt from this */
		outb(CLRSINT1 + iobase, CLRSCSIRSTI);
		outb(CLRINT + iobase, CLRSCSIINT);
d2041 1
a2041 1
		outb(SBLKCTL + iobase, 0);
d2043 5
a2047 4
	outb(SCSIID + iobase, ahc->our_id);
	scsi_conf = inb(SCSICONF + iobase) & (ENSPCHK|STIMESEL);
	outb(SXFRCTL1 + iobase, scsi_conf|ENSTIMER|ACTNEGEN|STPWEN);
	outb(SIMODE1 + iobase, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
d2049 1
a2049 1
		outb(SXFRCTL0 + iobase, DFON|SPIOEN|ULTRAEN);
d2051 1
a2051 1
		outb(SXFRCTL0 + iobase, DFON|SPIOEN);
d2053 8
a2060 4
	/* Reset the bus */
	outb(SCSISEQ + iobase, SCSIRSTO);
	DELAY(1000);
	outb(SCSISEQ + iobase, 0);
d2062 4
a2065 3
	/* Ensure we don't get a RSTI interrupt from this */
	outb(CLRSINT1 + iobase, CLRSCSIRSTI);
	outb(CLRINT + iobase, CLRSCSIINT);
d2081 2
a2082 3
		printf(AHCNAME_FMT
		       ": Host Adapter Bios disabled.  Using default SCSI "
			"device parameters\n", AHCNAME_VAR(ahc));
d2086 2
a2087 2
		ahc->discenable = ~((inb(DISC_DSB + iobase + 1) << 8)
				   | inb(DISC_DSB + iobase));
d2101 1
a2101 1
			target_settings = inb(TARG_SCRATCH + i + iobase);
d2119 1
a2119 1
		outb(TARG_SCRATCH+i+iobase,target_settings);
d2146 1
a2146 1
	outb(SCBCOUNT + iobase, ahc->maxhscbs);
d2152 1
a2152 1
	outb(COMP_SCBCOUNT + iobase, -i & 0xff);
d2159 1
a2159 1
	outb(QCNTMASK + iobase, ahc->qcntmask);
d2162 2
a2163 2
	outb(ACTIVE_A + iobase, 0);
	outb(ACTIVE_B + iobase, 0);
d2166 1
a2166 1
	outb(WAITING_SCBH + iobase, SCB_LIST_NULL);
d2169 1
a2169 1
	outb(DISCONNECTED_SCBH + iobase, SCB_LIST_NULL);
d2172 1
a2172 1
	outb(MSG_LEN + iobase, 0x00);
d2179 2
a2180 2
		printf(AHCNAME_FMT ": Downloading Sequencer Program...",
		       AHCNAME_VAR(ahc));
d2182 1
a2182 1
	ahc_loadseq(iobase);
d2187 1
a2187 1
        outb(SEQCTL + iobase, FASTMODE);
d2189 1
a2189 1
        UNPAUSE_SEQUENCER(ahc);
d2251 1
a2251 1
                printf(AHCNAME_FMT ": Already done?", AHCNAME_VAR(ahc));
d2255 1
a2255 1
                printf(AHCNAME_FMT ": Not in use?", AHCNAME_VAR(ahc));
d2362 2
a2363 3
			printf(AHCNAME_FMT
			       ": ahc_scsi_cmd: more than %d DMA segs\n",
				AHCNAME_VAR(ahc), AHC_NSEG);
d2368 2
a2369 2
#ifdef AIC7XXX_BROKEN_CACHE
		if (aic7xxx_broken_cache)
a2391 1
		u_long iobase = ahc->baseport;
d2395 2
a2396 2
		curscb = inb(SCBPTR + iobase);
		outb(SCBPTR + iobase, scb->position);
d2398 2
a2399 2
		outb(SCBPTR + iobase, curscb);
		outb(QINFIFO + iobase, scb->position);
d2410 1
a2410 1
		STAILQ_INSERT_TAIL(&ahc->waiting_scbs, scb, links);
d2451 2
a2452 2
		STAILQ_INSERT_HEAD(&ahc->page_scbs, scb, links);
		if(!scb->links.stqe_next && !ahc->free_scbs.stqh_first)
d2466 2
a2467 1
	else if((wscb = ahc->waiting_scbs.stqh_first) != NULL) {
d2469 1
a2469 2
		STAILQ_REMOVE_HEAD(&ahc->waiting_scbs, links);
		STAILQ_INSERT_HEAD(&ahc->assigned_scbs, wscb, links);
d2478 2
a2479 2
		STAILQ_INSERT_HEAD(&ahc->page_scbs, scb, links);
		if(!scb->links.stqe_next && !ahc->free_scbs.stqh_first)
d2487 1
a2487 1
		STAILQ_INSERT_HEAD(&ahc->free_scbs, scb, links);
d2491 1
a2491 1
		if(!scb->links.stqe_next && !ahc->page_scbs.stqh_first)
d2521 2
a2522 2
		if((scbp = ahc->free_scbs.stqh_first)) {
			STAILQ_REMOVE_HEAD(&ahc->free_scbs, links);
d2524 2
a2525 2
		else if((scbp = ahc->page_scbs.stqh_first)) {
			STAILQ_REMOVE_HEAD(&ahc->page_scbs, links);
d2545 2
a2546 2
				printf(AHCNAME_FMT ": Can't malloc SCB\n",
				       AHCNAME_VAR(ahc));
d2567 1
a2567 2
			printf(AHCNAME_FMT ": Max SCBs active\n",
			       AHCNAME_VAR(ahc));
d2576 2
a2577 2
static void ahc_loadseq(iobase)
	u_long iobase;
d2583 1
a2583 1
	outb(SEQCTL + iobase, PERRORDIS|SEQRESET|LOADRAM);
d2585 1
a2585 1
	outsb(SEQRAM + iobase, seqprog, sizeof(seqprog));
d2587 1
a2587 1
	outb(SEQCTL + iobase, FASTMODE|SEQRESET);
d2589 1
a2589 1
		outb(SEQCTL + iobase, SEQRESET|FASTMODE);
d2591 2
a2592 2
	} while (inb(SEQADDR0 + iobase) != 0 &&
		 inb(SEQADDR1 + iobase) != 0);
a2603 3
	u_long	iobase = ahc->baseport;
	u_long	stport = INTSTAT + iobase;

d2606 1
a2606 1
		if (inb(stport) & INT_PEND)
d2609 1
a2609 2
		printf(AHCNAME_FMT ": board not responding\n",
		       AHCNAME_VAR(ahc));
a2623 1
	u_long	iobase;
d2650 2
a2651 2
			panic(AHCNAME_FMT ": Timed-out command times out "
				"again\n", AHCNAME_VAR(ahc));
d2684 1
a2684 2
	iobase = ahc->baseport;
	bus_state = inb(iobase + LASTPHASE);
d2717 1
a2717 1
	printf(", SCSISIGI == 0x%x\n", inb(iobase + SCSISIGI));
d2731 2
a2732 2
		printf(AHCNAME_FMT ": Issued Channel %c Bus Reset #1. "
		       "%d SCBs aborted\n", AHCNAME_VAR(ahc), channel, found);
d2775 3
a2777 3
			active_scb = inb(SCBPTR + iobase);
			active_scbp = ahc->scbarray[inb(SCB_TAG + iobase)];
			outb(SCBPTR + iobase, scb->position);
d2779 1
a2779 1
			if(inb(SCB_CONTROL + iobase) & DISCONNECTED) {
d2785 2
a2786 2
					u_char prev = inb(SCB_PREV + iobase);
					u_char next = inb(SCB_NEXT + iobase);
d2789 1
a2789 1
						outb(DISCONNECTED_SCBH + iobase,
d2793 2
a2794 2
						outb(SCBPTR + iobase, prev);
						outb(SCB_NEXT + iobase, next);
d2796 1
a2796 1
							outb(SCBPTR + iobase,
d2798 1
a2798 1
							outb(SCB_PREV + iobase,
d2801 1
a2801 1
						outb(SCBPTR + iobase,
d2813 1
a2813 1
				ahc_add_waiting_scb(iobase, scb);
d2817 1
a2817 1
				outb(SCBPTR + iobase, active_scb);
d2823 3
a2825 3
				outb(MSG_LEN + iobase, 1);
				outb(MSG0 + iobase, MSG_BUS_DEVICE_RESET);
				outb(SCSISIGO + iobase, bus_state|ATNO);
d2840 1
a2840 1
				outb(SCBPTR + iobase, active_scb);
d2853 2
a2854 2
		printf(AHCNAME_FMT ": Issued Channel %c Bus Reset #2. "
			"%d SCBs aborted\n", AHCNAME_VAR(ahc), channel,
a2874 1
	u_long iobase = ahc->baseport;
d2881 1
a2881 1
	active_scb = inb(SCBPTR + iobase);
d2888 1
a2888 1
		int queued = inb(QINCNT + iobase) & ahc->qcntmask;
d2891 3
a2893 3
			saved_queue[i] = inb(QINFIFO + iobase);
			outb(SCBPTR + iobase, saved_queue[i]);
			scbp = ahc->scbarray[inb(SCB_TAG + iobase)];
d2902 1
a2902 1
				outb(SCB_CONTROL + iobase, 0);
d2909 1
a2909 1
			outb (QINFIFO + iobase, saved_queue[queued]);
d2919 1
a2919 1
		next = inb(WAITING_SCBH + iobase);  /* Start at head of list. */
d2923 2
a2924 2
			outb(SCBPTR + iobase, next);
			scbp = ahc->scbarray[inb(SCB_TAG + iobase)];
d2930 1
a2930 1
						iobase, timedout_scb, xs_error);
d2935 1
a2935 1
				next = inb(SCB_NEXT + iobase);
d2950 1
a2950 1
			ahc_unbusy_target(target, channel, iobase);
d2953 2
a2954 2
				outb(SCBPTR + iobase, scbp->position);
				outb(SCB_CONTROL + iobase, 0);
d2963 1
a2963 1
	outb(SCBPTR + iobase, active_scb);
d2972 1
a2972 1
ahc_abort_wscb (ahc, scbp, prev, iobase, timedout_scb, xs_error)
a2975 1
        u_long iobase;
d2986 3
a2988 3
	curscbp = inb(SCBPTR + iobase);
	outb(SCBPTR + iobase, scbp->position);
	next = inb(SCB_NEXT + iobase);
d2991 3
a2993 3
	outb(SCB_CONTROL + iobase, 0);
	outb(SCB_NEXT + iobase, SCB_LIST_NULL);
	ahc_unbusy_target(target, channel, iobase);
d2998 1
a2998 1
		outb(WAITING_SCBH + iobase, next); 
d3004 2
a3005 2
		outb(SCBPTR + iobase, prev);
		outb(SCB_NEXT + iobase, next);
d3012 1
a3012 1
	outb(SCBPTR + iobase, curscbp);
d3021 2
a3022 1
ahc_busy_target(target, channel, iobase)
a3024 1
	u_long iobase;
d3027 2
a3028 1
	u_long active_port = ACTIVE_A + iobase;
d3037 1
a3037 1
	active = inb(active_port);
d3039 1
a3039 1
	outb(active_port, active);
d3043 2
a3044 1
ahc_unbusy_target(target, channel, iobase)
a3046 1
	u_long iobase;
d3049 2
a3050 1
	u_long active_port = ACTIVE_A + iobase;
d3059 1
a3059 1
	active = inb(active_port);
d3061 1
a3061 1
	outb(active_port, active);
d3065 2
a3066 2
ahc_reset_current_bus(iobase)
	u_long iobase;
d3068 1
a3068 1
	outb(SCSISEQ + iobase, SCSIRSTO);
d3070 1
a3070 1
	outb(SCSISEQ + iobase, 0);
a3080 1
	u_long iobase = ahc->baseport;
d3095 3
a3097 3
		outb(ACTIVE_B + iobase, 0);
		offset = TARG_SCRATCH + iobase + 8;
		offset_max = TARG_SCRATCH + iobase + 16;
d3104 4
a3107 4
		outb(ACTIVE_A + iobase, 0);
		outb(ACTIVE_B + iobase, 0);
		offset = TARG_SCRATCH + iobase;
		offset_max = TARG_SCRATCH + iobase + 16;
d3112 3
a3114 3
		outb(ACTIVE_A + iobase, 0);
		offset = TARG_SCRATCH + iobase;
		offset_max = TARG_SCRATCH + iobase + 8;
d3122 2
a3123 1
		targ_scratch = inb(offset);
d3125 1
a3125 1
		outb(offset, targ_scratch);
d3133 1
a3133 1
	sblkctl = inb(SBLKCTL + iobase);
d3141 1
a3141 1
		outb(SBLKCTL + iobase, sblkctl ^ SELBUSB);
d3144 1
a3144 1
			ahc_reset_current_bus(iobase);
d3146 3
a3148 3
		outb(CLRSINT1 + iobase, CLRSCSIRSTI|CLRSELTIMEO);
		outb(CLRINT + iobase, CLRSCSIINT);
		outb(SBLKCTL + iobase, sblkctl);
d3155 1
a3155 1
			ahc_reset_current_bus(iobase);
d3157 2
a3158 2
		outb(CLRSINT1 + iobase, CLRSCSIRSTI|CLRSELTIMEO);
		outb(CLRINT + iobase, CLRSCSIINT);
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@a0 3
/*	$OpenBSD: aic7xxx.c,v 1.3 1996/04/18 23:47:15 niklas Exp $	*/
/*	$NetBSD: aic7xxx.c,v 1.5 1996/03/29 00:24:58 mycroft Exp $	*/

a2 3
 * Copyright (c) 1994, 1995 Justin T. Gibbs.
 * All rights reserved.
 *
d4 2
a5 2
 * i386/isa/aic7770.c	27/284X and aic7770 motherboard controllers
 * /pci/aic7870.c	294x and aic7870 motherboard controllers
d7 2
a8 1
 * Portions of this driver are based on the FreeBSD 1742 Driver:
d10 11
a20 2
 * Written by Julian Elischer (julian@@tfs.com)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
d22 11
a32 5
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
d34 1
a34 5
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 *
 * commenced: Sun Sep 27 18:14:01 PDT 1992
a37 1
 *	Add target reset capabilities
d39 75
a115 1
#include <sys/types.h>
d118 1
a118 1
#include <sys/kernel.h>
d120 10
a132 3
#include <sys/user.h>

#include <machine/pio.h>
d135 1
d137 1
d140 2
a141 24
#include <dev/ic/aic7xxxvar.h>

int     ahc_init __P((struct ahc_softc *));
void    ahc_loadseq __P((int));
int     ahc_scsi_cmd __P((struct scsi_xfer *));
void    ahc_timeout __P((void *));
void    ahc_done __P((struct ahc_softc *, struct ahc_scb *));
struct  ahc_scb *ahc_get_scb __P((struct ahc_softc *, int));
void    ahc_free_scb __P((struct ahc_softc *, struct ahc_scb *, int));
void	ahc_abort_scb __P((struct ahc_softc *, struct ahc_scb *));
void    ahcminphys __P((struct buf *));
int	ahc_poll __P((struct ahc_softc *, struct scsi_xfer *, int));

/* Different debugging levels */
#ifdef AHC_DEBUG
#define AHC_SHOWMISC 0x0001
#define AHC_SHOWCMDS 0x0002
#define AHC_SHOWSCBS 0x0004
int     ahc_debug = AHC_SHOWMISC;
#endif

#ifdef AHC_MORE_DEBUG
#define DEBUGLEVEL  -1
#define DEBUGTARGET 0x0
d144 3
a146 3
/**** bit definitions for SCSIDEF ****/
#define	HSCSIID		0x07		/* our SCSI ID */
#define HWSCSIID	0x0f		/* our SCSI ID if Wide Bus */
d148 2
a149 6
struct scsi_adapter ahc_switch = {
	ahc_scsi_cmd,
	ahcminphys,
	0,
	0,
};
d151 1
d153 3
a155 7
/* the below structure is so we have a default dev struct for our link struct */
struct scsi_device ahc_dev = {
	NULL,				/* Use default error handler */
	NULL,				/* have a queue, served by this */
	NULL,				/* have no async handler */
	NULL,				/* Use default 'done' routine */
};
d157 3
d161 1
a161 8
/*
 * All of these should be in a separate header file shared by the sequencer
 * code and the kernel level driver.  The only catch is that we would need to
 * add an additional 0xc00 offset when using them in the kernel driver.  The
 * aic7770 assembler must be modified to allow include files as well.  All
 * page numbers refer to the Adaptec AIC-7770 Data Book available from
 * Adaptec's Technical Documents Department 1-800-934-2766
 */
d163 5
a167 1
/* -------------------- AIC-7770 offset definitions ----------------------- */
d169 3
a171 13
/*
 * SCSI Sequence Control (p. 3-11).
 * Each bit, when set starts a specific SCSI sequence on the bus
 */
#define SCSISEQ			0xc00ul
#define		TEMODEO		0x80
#define		ENSELO		0x40
#define		ENSELI		0x20
#define		ENRSELI		0x10
#define		ENAUTOATNO	0x08
#define		ENAUTOATNI	0x04
#define		ENAUTOATNP	0x02
#define		SCSIRSTO	0x01
d173 1
a173 12
/*
 * SCSI Transfer Control 1 Register (pp. 3-14,15).
 * Controls the SCSI module data path.
 */
#define	SXFRCTL1		0xc02ul
#define		BITBUCKET	0x80
#define		SWRAPEN		0x40
#define		ENSPCHK		0x20
#define		STIMESEL	0x18
#define		ENSTIMER	0x04
#define		ACTNEGEN	0x02
#define		STPWEN		0x01	/* Powered Termination */
d175 2
a176 14
/*
 * SCSI Interrrupt Mode 1 (pp. 3-28,29).
 * Set bits in this register enable the corresponding
 * interrupt source.
 */
#define	SIMODE1			0xc11ul
#define		ENSELTIMO	0x80
#define		ENATNTARG	0x40
#define		ENSCSIRST	0x20
#define		ENPHASEMIS	0x10
#define		ENBUSFREE	0x08
#define		ENSCSIPERR	0x04
#define		ENPHASECHG	0x02
#define		ENREQINIT	0x01
d178 2
a179 13
/*
 * SCSI Control Signal Read Register (p. 3-15).
 * Reads the actual state of the SCSI bus pins
 */
#define SCSISIGI		0xc03ul
#define		CDI		0x80
#define		IOI		0x40
#define		MSGI		0x20
#define		ATNI		0x10
#define		SELI		0x08
#define		BSYI		0x04
#define		REQI		0x02
#define		ACKI		0x01
d181 1
a181 15
/*
 * SCSI Contol Signal Write Register (p. 3-16).
 * Writing to this register modifies the control signals on the bus.  Only
 * those signals that are allowed in the current mode (Initiator/Target) are
 * asserted.
 */
#define SCSISIGO		0xc03ul
#define		CDO		0x80
#define		IOO		0x40
#define		MSGO		0x20
#define		ATNO		0x10
#define		SELO		0x08
#define		BSYO		0x04
#define		REQO		0x02
#define		ACKO		0x01
d183 3
a185 2
/* XXX document this thing */
#define SCSIRATE		0xc04ul
d187 2
a188 8
/*
 * SCSI ID (p. 3-18).
 * Contains the ID of the board and the current target on the
 * selected channel
 */
#define SCSIID			0xc05ul
#define		TID		0xf0		/* Target ID mask */
#define		OID		0x0f		/* Our ID mask */
d191 3
a193 3
 * SCSI Status 0 (p. 3-21)
 * Contains one set of SCSI Interrupt codes
 * These are most likely of interest to the sequencer
d195 2
a196 9
#define SSTAT0			0xc0bul
#define		TARGET		0x80		/* Board is a target */
#define		SELDO		0x40		/* Selection Done */
#define		SELDI		0x20		/* Board has been selected */
#define		SELINGO		0x10		/* Selection In Progress */
#define		SWRAP		0x08		/* 24bit counter wrap */
#define		SDONE		0x04		/* STCNT = 0x000000 */
#define		SPIORDY		0x02		/* SCSI PIO Ready */
#define		DMADONE		0x01		/* DMA transfer completed */
d198 3
a200 13
/*
 * Clear SCSI Interrupt 1 (p. 3-23)
 * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT1.
 */
#define CLRSINT1		0xc0cul
#define		CLRSELTIMEO	0x80
#define		CLRATNO		0x40
#define		CLRSCSIRSTI	0x20
/*  UNUSED			0x10 */
#define		CLRBUSFREE	0x08
#define		CLRSCSIPERR	0x04
#define		CLRPHASECHG	0x02
#define		CLRREQINIT	0x01
d202 2
a203 13
/*
 * SCSI Status 1 (p. 3-24)
 * These interrupt bits are of interest to the kernel driver
 */
#define SSTAT1			0xc0cul
#define		SELTO		0x80
#define		ATNTARG		0x40
#define		SCSIRSTI	0x20
#define		PHASEMIS	0x10
#define		BUSFREE		0x08
#define		SCSIPERR	0x04
#define		PHASECHG	0x02
#define		REQINIT		0x01
d205 12
a216 9
/*
 * Selection/Reselection ID (p. 3-31)
 * Upper four bits are the device id.  The ONEBIT is set when the re/selecting
 * device did not set its own ID.
 */
#define SELID			0xc19ul
#define		SELID_MASK	0xf0
#define		ONEBIT		0x08
/*  UNUSED			0x07 */
d218 13
a230 233
/*
 * SCSI Block Control (p. 3-32)
 * Controls Bus type and channel selection.  In a twin channel configuration
 * addresses 0x00-0x1e are gated to the appropriate channel based on this
 * register.  SELWIDE allows for the coexistence of 8bit and 16bit devices
 * on a wide bus.
 */
#define SBLKCTL			0xc1ful
/*  UNUSED			0xc0 */
#define		AUTOFLUSHDIS	0x20
/*  UNUSED			0x10 */
#define		SELBUSB		0x08
/*  UNUSED			0x04 */
#define		SELWIDE		0x02
/*  UNUSED			0x01 */

/*
 * Sequencer Control (p. 3-33)
 * Error detection mode and speed configuration
 */
#define SEQCTL			0xc60ul
#define		PERRORDIS	0x80
#define		PAUSEDIS	0x40
#define		FAILDIS		0x20
#define		FASTMODE	0x10
#define		BRKADRINTEN	0x08
#define		STEP		0x04
#define		SEQRESET	0x02
#define		LOADRAM		0x01

/*
 * Sequencer RAM Data (p. 3-34)
 * Single byte window into the Scratch Ram area starting at the address
 * specified by SEQADDR0 and SEQADDR1.  To write a full word, simply write
 * four bytes in sucessesion.  The SEQADDRs will increment after the most
 * significant byte is written
 */
#define SEQRAM			0xc61ul

/*
 * Sequencer Address Registers (p. 3-35)
 * Only the first bit of SEQADDR1 holds addressing information
 */
#define SEQADDR0		0xc62ul
#define SEQADDR1		0xc63ul
#define		SEQADDR1_MASK	0x01

/*
 * Accumulator
 * We cheat by passing arguments in the Accumulator up to the kernel driver
 */
#define ACCUM			0xc64ul

#define SINDEX			0xc65ul

/*
 * Board Control (p. 3-43)
 */
#define BCTL			0xc84ul
/*   RSVD			0xf0 */
#define		ACE		0x08	/* Support for external processors */
/*   RSVD			0x06 */
#define		ENABLE		0x01

/*
 * Host Control (p. 3-47) R/W
 * Overal host control of the device.
 */
#define HCNTRL			0xc87ul
/*    UNUSED			0x80 */
#define		POWRDN		0x40
/*    UNUSED			0x20 */
#define		SWINT		0x10
#define		IRQMS		0x08
#define		PAUSE		0x04
#define		INTEN		0x02
#define		CHIPRST		0x01

/*
 * SCB Pointer (p. 3-49)
 * Gate one of the four SCBs into the SCBARRAY window.
 */
#define SCBPTR			0xc90ul

/*
 * Interrupt Status (p. 3-50)
 * Status for system interrupts
 */
#define INTSTAT			0xc91ul
#define		SEQINT_MASK	0xf0		/* SEQINT Status Codes */
#define			BAD_PHASE	0x00
#define			SEND_REJECT	0x10
#define			NO_IDENT	0x20
#define			NO_MATCH	0x30
#define			MSG_SDTR	0x40
#define			MSG_WDTR	0x50
#define			MSG_REJECT	0x60
#define			BAD_STATUS	0x70
#define			RESIDUAL	0x80
#define			ABORT_TAG	0x90
#define		BRKADRINT 0x08
#define		SCSIINT	  0x04
#define		CMDCMPLT  0x02
#define		SEQINT    0x01
#define		INT_PEND  (BRKADRINT | SEQINT | SCSIINT | CMDCMPLT)

/*
 * Hard Error (p. 3-53)
 * Reporting of catastrophic errors.  You usually cannot recover from
 * these without a full board reset.
 */
#define ERROR			0xc92ul
/*    UNUSED			0xf0 */
#define		PARERR		0x08
#define		ILLOPCODE	0x04
#define		ILLSADDR	0x02
#define		ILLHADDR	0x01

/*
 * Clear Interrupt Status (p. 3-52)
 */
#define CLRINT			0xc92ul
#define		CLRBRKADRINT	0x08
#define		CLRSCSIINT      0x04
#define		CLRCMDINT	0x02
#define		CLRSEQINT	0x01

/*
 * SCB Auto Increment (p. 3-59)
 * Byte offset into the SCB Array and an optional bit to allow auto
 * incrementing of the address during download and upload operations
 */
#define SCBCNT			0xc9aul
#define		SCBAUTO		0x80
#define		SCBCNT_MASK	0x1f

/*
 * Queue In FIFO (p. 3-60)
 * Input queue for queued SCBs (commands that the seqencer has yet to start)
 */
#define QINFIFO			0xc9bul

/*
 * Queue In Count (p. 3-60)
 * Number of queued SCBs
 */
#define QINCNT			0xc9cul

/*
 * Queue Out FIFO (p. 3-61)
 * Queue of SCBs that have completed and await the host
 */
#define QOUTFIFO		0xc9dul

/*
 * Queue Out Count (p. 3-61)
 * Number of queued SCBs in the Out FIFO
 */
#define QOUTCNT			0xc9eul

#define SCBARRAY		0xca0ul

/* ---------------- END AIC-7770 Register Definitions ----------------- */

/* --------------------- AIC-7870-only definitions -------------------- */

#define DSPCISTATUS		0xc86ul

/* ---------------------- Scratch RAM Offsets ------------------------- */
/* These offsets are either to values that are initialized by the board's
 * BIOS or are specified by the Linux sequencer code.  If I can figure out
 * how to read the EISA configuration info at probe time, the cards could
 * be run without BIOS support installed
 */

/*
 * 1 byte per target starting at this address for configuration values
 */
#define HA_TARG_SCRATCH		0xc20ul

/*
 * The sequencer will stick the frist byte of any rejected message here so
 * we can see what is getting thrown away.
 */
#define HA_REJBYTE		0xc31ul

/*
 * Length of pending message
 */
#define HA_MSG_LEN		0xc34ul

/*
 * message body
 */
#define HA_MSG_START		0xc35ul	/* outgoing message body */

/*
 * These are offsets into the card's scratch ram.  Some of the values are
 * specified in the AHA2742 technical reference manual and are initialized
 * by the BIOS at boot time.
 */
#define HA_ARG_1		0xc4aul
#define HA_RETURN_1		0xc4aul
#define		SEND_SENSE	0x80
#define		SEND_WDTR	0x80
#define		SEND_SDTR	0x80
#define		SEND_REJ	0x40

#define HA_SIGSTATE		0xc4bul

#define HA_SCBCOUNT		0xc52ul
#define HA_FLAGS		0xc53ul
#define		SINGLE_BUS	0x00
#define		TWIN_BUS	0x01
#define		WIDE_BUS	0x02
#define		ACTIVE_MSG	0x20
#define		IDENTIFY_SEEN	0x40
#define		RESELECTING	0x80

#define	HA_ACTIVE0		0xc54ul
#define	HA_ACTIVE1		0xc55ul
#define	SAVED_TCL		0xc56ul
#define WAITING_SCBH		0xc57ul
#define WAITING_SCBT		0xc58ul

#define HA_SCSICONF		0xc5aul
#define INTDEF			0xc5cul
#define HA_HOSTCONF		0xc5dul

#define MSG_ABORT               0x06
#define	BUS_8_BIT		0x00
#define BUS_16_BIT		0x01
#define BUS_32_BIT		0x02
d237 5
a241 6
#define PAUSE_SEQUENCER(ahc) \
	do {								\
		outb(HCNTRL + ahc->sc_iobase, ahc->pause);		\
		while ((inb(HCNTRL + ahc->sc_iobase) & PAUSE) == 0)	\
			;						\
	} while (0)
d243 2
a244 4
#define UNPAUSE_SEQUENCER(ahc) \
	do {								\
		outb(HCNTRL + ahc->sc_iobase, ahc->unpause);		\
	} while (0)
a247 1
 * XXX Should add a timeout in here??
d249 1
a249 1
#define RESET_SEQUENCER(ahc) \
d251 12
a262 5
		do {							\
			outb(SEQCTL + ahc->sc_iobase, SEQRESET|FASTMODE); \
		} while (inb(SEQADDR0 + ahc->sc_iobase) != 0 &&		\
			 inb(SEQADDR1 + ahc->sc_iobase) != 0);		\
	} while (0)
d264 47
a310 5
#define RESTART_SEQUENCER(ahc) \
	do {								\
		RESET_SEQUENCER(ahc);					\
		UNPAUSE_SEQUENCER(ahc);					\
	} while (0)
d313 1
a313 1
void
d315 1
a315 1
	struct ahc_scb *scb;
d317 14
a330 18

	printf("scb:0x%x control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%x\n",
	    scb,
	    scb->control,
	    scb->target_channel_lun,
	    scb->cmdlen,
	    scb->cmdpointer);
	printf("\tdatlen:%d data:0x%x res:0x%x segs:0x%x segp:0x%x\n",
	    scb->datalen[2] << 16 | scb->datalen[1] << 8 | scb->datalen[0],
	    scb->data,
	    scb->RESERVED[1] << 8 | scb->RESERVED[0],
	    scb->SG_segment_count,
	    scb->SG_list_pointer);
	printf("\tsg_addr:%x sg_len:%d\n",
	    scb->ahc_dma[0].seg_addr,
	    scb->ahc_dma[0].seg_len);
	printf("	size:%d\n",
	    (int)&scb->next_waiting - (int)scb);
a332 13
void
ahc_print_active_scb(ahc)
	struct ahc_softc *ahc;
{
	int iobase = ahc->sc_iobase;
	int scb_index;

	PAUSE_SEQUENCER(ahc);
	scb_index = inb(SCBPTR + iobase);
	UNPAUSE_SEQUENCER(ahc);

	ahc_print_scb(ahc->scbarray[scb_index]);
}
a334 5
#define         PARERR          0x08
#define         ILLOPCODE       0x04
#define         ILLSADDR        0x02
#define         ILLHADDR        0x01

d336 1
a336 1
	u_char errno;
d352 4
a355 2
	u_char sxfr;
	int period; /* in ns */
d358 16
a373 8
	{ 0x00, 100, "10.0"  },
	{ 0x10, 125,  "8.0"  },
	{ 0x20, 150,  "6.67" },
	{ 0x30, 175,  "5.7"  },
	{ 0x40, 200,  "5.0"  },
	{ 0x50, 225,  "4.4"  },
	{ 0x60, 250,  "4.0"  },
	{ 0x70, 275,  "3.6"  }
d380 4
a383 2
 * Check if the device can be found at the port given
 * and if so, determine configuration and set it up for further work.
d385 15
d401 3
a403 5
int
ahcprobe(ahc, iobase)
	struct ahc_softc *ahc;
	int iobase;
{
d405 2
a406 1
	ahc->sc_iobase = iobase;
d409 1
a409 3
	 * Try to initialize a unit at this location
	 * reset the AIC-7770, read its registers,
	 * and fill in the dev structure accordingly
d412 25
a436 2
	if (ahc_init(ahc) != 0)
		return (0);
d438 8
a445 1
	return (1);
d448 37
d489 7
a495 6
static u_char
ahc_scsirate(offset, period, ahc, target)
	u_char offset;
	int period;
	struct ahc_softc *ahc;
	int target;
d500 1
d502 37
a538 7
			printf("%s: target %d synchronous at %sMB/s, "
			       "offset = %d\n",
			    ahc->sc_dev.dv_xname, target,
			    ahc_syncrates[i].rate, offset);
#ifdef AHC_DEBUG
#endif /* AHC_DEBUG */
			return ((ahc_syncrates[i].sxfr) | (offset & 0x0f));
a540 1

d542 5
a546 5
	printf("%s: target %d using asyncronous transfers\n",
	    ahc->sc_dev.dv_xname, target);
	return (0);
#ifdef AHC_DEBUG
#endif /* AHC_DEBUG */
d549 1
d560 1
d566 2
a567 2
ahcattach(ahc)
	struct ahc_softc *ahc;
d569 1
d571 4
a574 2
	TAILQ_INIT(&ahc->free_scb);

d578 7
a585 1
	ahc->sc_link.adapter_target = ahc->ahc_scsi_dev;
d587 1
a588 1
	ahc->sc_link.openings = 1;
d590 20
a609 1
	ahc->sc_link.quirks = 0;
d614 8
d624 2
a625 1
	if (ahc->type & AHC_TWIN) {
d628 22
a649 3
		/* XXXX Didn't do this before. */
		ahc->sc_link_b.adapter_target = ahc->ahc_scsi_dev_b;
		ahc->sc_link_b.quirks = 0x0008;	/**/
d652 1
a653 1
	
d657 5
a661 1
void
d663 2
a664 14
	struct ahc_softc *ahc;
	struct ahc_scb *scb;
{
	int iobase = ahc->sc_iobase;

	PAUSE_SEQUENCER(ahc);
	outb(QINFIFO + iobase, scb->position);
	UNPAUSE_SEQUENCER(ahc);
}

static void
ahc_getscb(iobase, scb)
	int iobase;
	struct ahc_scb *scb;
d666 1
d669 7
a675 2
	insb(SCBARRAY + iobase, scb, SCB_UP_SIZE);
	outb(SCBCNT + iobase, 0);
d679 2
a680 1
 * Catch an interrupt from the adaptor
d682 189
d872 3
a874 2
ahcintr(ahc)
	struct ahc_softc *ahc;
d876 4
a879 4
	int iobase = ahc->sc_iobase;
	u_char intstat = inb(INTSTAT + iobase);
	u_char status;
	struct ahc_scb *scb = NULL;
d881 4
a884 1
	
d889 4
a892 1
	if ((intstat & INT_PEND) == 0)
d894 3
a896 2
	
	if (intstat & BRKADRINT) {
d902 1
a902 1
		for (i = 0; error != 1 && i < num_errors; i++)
d904 24
a927 10
		panic("%s: brkadrint, %s at seqaddr = 0x%x\n",
		    ahc->sc_dev.dv_xname, hard_error[i].errmesg,
		    (inb(SEQADDR1 + iobase) << 8) |
		    (inb(SEQADDR0 + iobase) << 0));
	}
	
	if (intstat & SEQINT) {
		switch (intstat & SEQINT_MASK) {
		case BAD_PHASE:
			panic("%s: unknown scsi bus phase.  "
d929 24
a952 33
			    ahc->sc_dev.dv_xname);
			break;
		case SEND_REJECT:
			printf("%s: Warning - "
			       "message reject, message type: 0x%x\n",
			    ahc->sc_dev.dv_xname,
			    inb(HA_REJBYTE + iobase));
			break;
		case NO_IDENT:
			panic("%s: No IDENTIFY message from reconnecting "
			      "target %d at seqaddr = 0x%x "
			      "SAVED_TCL == 0x%x\n",
			    ahc->sc_dev.dv_xname,
			    (inb(SELID + iobase) >> 4) & 0xf,
			    (inb(SEQADDR1 + iobase) << 8) |
			    (inb(SEQADDR0 + iobase) << 0),
			    inb(SAVED_TCL + iobase));
			break;
		case NO_MATCH: {
			u_char active;
			int active_port = HA_ACTIVE0 + iobase;
			int tcl = inb(SCBARRAY+1 + iobase);
			int target = (tcl >> 4) & 0x0f;
			printf("%s: no active SCB for reconnecting "
			       "target %d, channel %c - issuing ABORT\n",
			    ahc->sc_dev.dv_xname,
			    target, tcl & 0x08 ? 'B' : 'A');
			printf("SAVED_TCL == 0x%x\n", inb(SAVED_TCL + iobase));
			if (tcl & 0x88) {
				/* Second channel stores its info
				 * in byte two of HA_ACTIVE
				 */
				active_port++;
d954 6
a959 6
			active = inb(active_port);
			active &= ~(0x01 << (target & 0x07));
			outb(SCBARRAY + iobase, SCB_NEEDDMA);
			outb(active_port, active);
			outb(CLRSINT1 + iobase, CLRSELTIMEO);
			RESTART_SEQUENCER(ahc);
d961 13
a973 7
		}
		case MSG_SDTR: {
			u_char scsi_id =
			    (inb(SCSIID + iobase) >> 0x4) |
			    (inb(SBLKCTL + iobase) & 0x08);
			u_char scratch, offset;
			int period;
a974 18
			/*
			 * Help the sequencer to translate the
			 * negotiated transfer rate.  Transfer is
			 * 1/4 the period in ns as is returned by
			 * the sync negotiation message.  So, we must
			 * multiply by four
			 */
			period = inb(HA_ARG_1 + iobase) << 2;
			/* The bottom half of SCSIXFER */
			offset = inb(ACCUM + iobase);

			printf("%s: SDTR, target %d period %d offset %d\n",
			    ahc->sc_dev.dv_xname, scsi_id, period, offset);
			scratch = inb(HA_TARG_SCRATCH + iobase + scsi_id);
			scratch &= 0x80;
			scratch |= ahc_scsirate(offset, period, ahc, scsi_id);

			if ((scratch & 0x7f) == 0) {
d976 4
a979 7
				 * The requested rate was so low
				 * that asyncronous transfers are
				 * faster (not to mention the
				 * controller won't support them),
				 * so we issue a message reject to
				 * ensure we go to asyncronous
				 * transfers.
d981 103
a1083 5
				outb(HA_RETURN_1 + iobase, SEND_REJ);
			} else if (ahc->sdtrpending & (0x01 << scsi_id)) {
				/*
				 * Don't send an SDTR back to the
				 * target, since we asked first.
d1085 48
a1132 2
				outb(HA_RETURN_1 + iobase, 0);
			} else {
d1134 1
a1134 1
				 * Send our own SDTR in reply
d1136 3
a1138 5
#ifdef AHC_DEBUG
				if (ahc_debug & AHC_SHOWMISC)
					printf("Sending SDTR!!\n");
#endif
				outb(HA_RETURN_1 + iobase, SEND_SDTR);
d1140 3
a1142 15
			/*
			 * Negate the flags
			 */
			ahc->needsdtr &= ~(0x01 << scsi_id);
			ahc->sdtrpending &= ~(0x01 << scsi_id);

			outb(HA_TARG_SCRATCH + iobase + scsi_id, scratch);
			outb(SCSIRATE + iobase, scratch);
			break;
		}
		case MSG_WDTR: {
			u_char scsi_id =
			    (inb(SCSIID + iobase) >> 0x4) |
			    (inb(SBLKCTL + iobase) & 0x08);
			u_char scratch, width;
d1144 1
a1144 1
			width = inb(ACCUM + iobase);
d1146 2
a1147 1
			scratch = inb(HA_TARG_SCRATCH + iobase + scsi_id);
d1149 74
a1222 19
			if (ahc->wdtrpending & (0x01 << scsi_id)) {
				/*
				 * Don't send a WDTR back to the
				 * target, since we asked first.
				 */
				outb(HA_RETURN_1 + iobase, 0);
				switch (width) {
				case BUS_8_BIT:
					scratch &= 0x7f;
					break;
				case BUS_16_BIT:
					printf("%s: target %d using 16Bit "
					       "transfers\n",
					    ahc->sc_dev.dv_xname, scsi_id);
					scratch &= 0xf8;
					scratch |= 0x88;
					break;
				case BUS_32_BIT:
					/* XXXX */
d1224 9
a1232 1
			} else {
d1234 4
a1237 1
				 * Send our own WDTR in reply
a1238 20
				switch (width) {
				case BUS_8_BIT:
					scratch &= 0x7f;
					break;
				case BUS_32_BIT:
					/* Negotiate 16_BITS */
					width = BUS_16_BIT;
				case BUS_16_BIT:
					printf("%s: target %d using 16Bit "
					       "transfers\n",
					    ahc->sc_dev.dv_xname, scsi_id);
					scratch &= 0xf8;
					scratch |= 0x88;
					break;
				}
				outb(HA_RETURN_1 + iobase,
				     width | SEND_WDTR);
			}
			ahc->needwdtr &= ~(0x01 << scsi_id);
			ahc->wdtrpending &= ~(0x01 << scsi_id);
d1240 4
a1243 11
			outb(HA_TARG_SCRATCH + iobase + scsi_id, scratch);
			outb(SCSIRATE + iobase, scratch);
			break;
		}
		case MSG_REJECT: {
			/*
			 * What we care about here is if we had an
			 * outstanding SDTR or WDTR message for this
			 * target.  If we did, this is a signal that
			 * the target is refusing negotiation.
			 */
d1245 26
a1270 31
			u_char scsi_id =
			    (inb(SCSIID + iobase) >> 0x4) |
			    (inb(SBLKCTL + iobase) & 0x08);
			u_char scratch;
			u_short mask;

			scratch = inb(HA_TARG_SCRATCH + iobase + scsi_id);

			mask = (0x01 << scsi_id);
			if (ahc->wdtrpending & mask) {
				/* note 8bit xfers and clear flag */
				scratch &= 0x7f;
				ahc->needwdtr &= ~mask;
				ahc->wdtrpending &= ~mask;
				printf("%s: target %d refusing "
				       "WIDE negotiation.  Using "
				       "8bit transfers\n",
				    ahc->sc_dev.dv_xname, scsi_id);
			} else if (ahc->sdtrpending & mask) {
				/* note asynch xfers and clear flag */
				scratch &= 0xf0;
				ahc->needsdtr &= ~mask;
				ahc->sdtrpending &= ~mask;
				printf("%s: target %d refusing "
				       "syncronous negotiation; using "
				       "asyncronous transfers\n",
				    ahc->sc_dev.dv_xname, scsi_id);
			} else {
				/*
				 * Otherwise, we ignore it.
				 */
d1272 6
a1277 2
				if (ahc_debug & AHC_SHOWMISC)
					printf("Message reject -- ignored\n");
d1279 5
d1286 29
d1316 1
a1316 15
			outb(HA_TARG_SCRATCH + iobase + scsi_id, scratch);
			outb(SCSIRATE + iobase, scratch);
			break;
		}
		case BAD_STATUS: {
			int scb_index = inb(SCBPTR + iobase);
			scb = ahc->scbarray[scb_index];

			/*
			 * The sequencer will notify us when a command
			 * has an error that would be of interest to
			 * the kernel.  This allows us to leave the sequencer
			 * running in the common case of command completes
			 * without error.
			 */
d1318 1
a1318 13
			/*
			 * Set the default return value to 0 (don't
			 * send sense).  The sense code with change
			 * this if needed and this reduces code
			 * duplication.
			 */
			outb(HA_RETURN_1 + iobase, 0);
			if (!scb || scb->flags == SCB_FREE) {
				printf("%s: ahcintr: referenced scb not "
				       "valid during seqint 0x%x scb(%d)\n",
				    ahc->sc_dev.dv_xname, intstat, scb_index);
				goto clear;
			}
d1320 3
a1322 6
			xs = scb->xs;

			ahc_getscb(iobase, scb);

#ifdef AHC_MORE_DEBUG
			if (xs->sc_link->target == DEBUGTARGET)
d1325 5
a1329 5
			xs->status = scb->target_status;
			switch (scb->target_status) {
			case SCSI_OK:
				printf("%s: Interrupted for status of 0???\n",
				    ahc->sc_dev.dv_xname);
d1331 1
a1331 1
			case SCSI_CHECK:
d1333 5
a1337 2
				sc_print_addr(xs->sc_link);
				printf("requests Check Status\n");
d1340 2
a1341 4
				if (xs->error == XS_NOERROR &&
				    scb->flags != SCB_CHKSENSE) {
					u_char head;
					u_char tail;
a1343 2
					u_char control = scb->control;
					u_char tcl = scb->target_channel_lun;
d1345 5
a1349 2
					sc_print_addr(xs->sc_link);
					printf("Sending Sense\n");
d1351 3
a1353 3
					bzero(scb, SCB_DOWN_SIZE);
					scb->flags = SCB_CHKSENSE;
					scb->control = (control & SCB_TE);
d1355 1
d1360 2
a1361 2
					sg->seg_addr = vtophys(&xs->sense);
					sg->seg_len = sizeof(struct scsi_sense_data);
d1363 2
a1364 1
					scb->target_channel_lun = tcl;
d1366 8
a1373 2
					scb->SG_list_pointer = vtophys(sg);
					scb->cmdpointer = vtophys(sc);
d1376 9
a1384 6
					outb(SCBCNT + iobase, SCBAUTO);
					outsb(SCBARRAY + iobase, scb,
					    SCB_DOWN_SIZE);
					outb(SCBCNT + iobase, 0);
					outb(SCBARRAY + iobase + 30,
					    SCB_LIST_NULL);
d1387 1
a1387 2
					 * Add this SCB to the "waiting for
					 * selection" list.
d1389 2
a1390 21
					head = inb(WAITING_SCBH + iobase);
					tail = inb(WAITING_SCBT + iobase);
					if (head & SCB_LIST_NULL) {
						/* List was empty */
						head = scb->position;
						tail = SCB_LIST_NULL;
					} else if (tail & SCB_LIST_NULL) {
						/* List had one element */
						tail = scb->position;
						outb(SCBPTR + iobase, head);
						outb(SCBARRAY + iobase + 30,
						    tail);
					} else {
						outb(SCBPTR + iobase, tail);
						tail = scb->position;
						outb(SCBARRAY + iobase + 30,
						    tail);
					}
					outb(WAITING_SCBH + iobase, head);
					outb(WAITING_SCBT + iobase, tail);
					outb(HA_RETURN_1 + iobase, SEND_SENSE);
d1394 2
a1395 1
				 * Have the sequencer do a normal command
d1400 2
a1401 1
				if (xs->error == XS_NOERROR)
d1404 2
a1405 1
			case SCSI_BUSY:
a1407 1
				xs->error = XS_BUSY;
d1409 2
a1410 2
#if 0
			case SCSI_QUEUE_FULL:
d1417 3
a1419 1
				xs->error = XS_BUSY;
d1421 7
d1429 1
a1429 1
			default:
d1432 1
a1432 1
				    scb->target_status);
d1437 5
a1441 3
		}
		case RESIDUAL: {
			int scb_index = inb(SCBPTR + iobase);
d1443 1
a1443 1

d1449 37
a1485 7
			if (scb->flags != SCB_CHKSENSE)
				scb->xs->resid =
				    (inb(iobase + SCBARRAY + 17) << 16) |
				    (inb(iobase + SCBARRAY + 16) <<  8) |
				    (inb(iobase + SCBARRAY + 15) <<  0);
#ifdef AHC_MORE_DEBUG
			printf("ahc: Handled Residual\n");
d1487 1
d1489 5
a1493 3
		}
		case ABORT_TAG: {
			int scb_index = inb(SCBPTR + iobase);
d1495 1
a1495 1

d1501 3
a1503 5
			printf("invalid tag recieved on channel %c "
			       "-- sending ABORT_TAG\n",
			    (xs->sc_link->quirks & 0x08) ? 'B' : 'A');
			scb->xs->error = XS_DRIVER_STUFFUP;
			untimeout(ahc_timeout, scb);
d1506 73
a1578 5
		}
		default:
			printf("%s: seqint, intstat == 0x%x, scsisigi = 0x%x\n",
			    ahc->sc_dev.dv_xname,
			    intstat, inb(SCSISIGI + iobase));
d1581 1
a1581 2

	clear:
d1594 4
a1597 5
	}
	
	if (intstat & SCSIINT) {
		int scb_index = inb(SCBPTR + iobase);
		scb = ahc->scbarray[scb_index];
d1599 1
d1602 19
a1620 2
		if (!scb || scb->flags == SCB_FREE) {
			printf("%s: ahcintr - referenced scb not "
d1622 1
a1622 1
			    ahc->sc_dev.dv_xname, status, scb_index);
a1626 1
			goto cmdcomplete;
d1628 10
a1637 1
		xs = scb->xs;
d1639 27
a1665 4
#ifdef AHC_MORE_DEBUG
		if ((xs->sc_link->target & 0xf) == DEBUGTARGET)
			printf("Intr status %x\n", status);
#endif
d1667 19
a1685 2
		if (status & SELTO) {
			u_char active;
d1688 1
a1688 4
			int active_port = HA_ACTIVE0 + iobase;

			outb(SCSISEQ + iobase, ENRSELI);
			xs->error = XS_SELTIMEOUT;
d1693 10
a1702 5
			flags = inb(HA_FLAGS + iobase);
			outb(HA_FLAGS + iobase, flags & ~ACTIVE_MSG);

			if (scb->target_channel_lun & 0x88)
			    active_port++;
d1704 1
a1704 5
			active = inb(active_port) &
			    ~(0x01 << (xs->sc_link->target & 0x07));
			outb(active_port, active);

			outb(SCBARRAY + iobase, SCB_NEEDDMA);
d1713 1
a1713 1
			waiting = inb(SCBARRAY + iobase + 30);
d1717 13
d1731 3
d1735 14
a1748 35
		if (status & SCSIPERR) {
			sc_print_addr(xs->sc_link);
			printf("parity error on channel %c\n",
			    (xs->sc_link->quirks & 0x08) ? 'B' : 'A');
			xs->error = XS_DRIVER_STUFFUP;

			outb(CLRSINT1 + iobase, CLRSCSIPERR);
			UNPAUSE_SEQUENCER(ahc);

			outb(CLRINT + iobase, CLRSCSIINT);
			scb = NULL;
		}
		if (status & BUSFREE) {
#if 0
			/*
			 * Has seen busfree since selection, i.e.
			 * a "spurious" selection. Shouldn't happen.
			 */
			printf("ahc: unexpected busfree\n");
#if 0
			xs->error = XS_DRIVER_STUFFUP;
			outb(CLRSINT1 + iobase, BUSFREE); /* CLRBUSFREE */
#endif
#endif
		} else {
			printf("%s: Unknown SCSIINT. Status = 0x%x\n",
			    ahc->sc_dev.dv_xname, status);
			outb(CLRSINT1 + iobase, status);
			UNPAUSE_SEQUENCER(ahc);
			outb(CLRINT + iobase, CLRSCSIINT);
			scb = NULL;
		}
		if (scb != NULL) {
			/* We want to process the command */
			untimeout(ahc_timeout, scb);
a1749 6
		}
	}

cmdcomplete:
	if (intstat & CMDCMPLT) {
		int scb_index;
d1751 1
a1751 13
		do {
			scb_index = inb(QOUTFIFO + iobase);
			scb = ahc->scbarray[scb_index];

			if (!scb || scb->flags == SCB_FREE) {
				printf("%s: WARNING "
			               "no command for scb %d (cmdcmplt)\n"
				       "QOUTCNT == %d\n",
				    ahc->sc_dev.dv_xname,
				    scb_index, inb(QOUTCNT + iobase));
				outb(CLRINT + iobase, CLRCMDINT);
				continue;
			}
d1753 1
a1753 5
			/* XXXX Should do this before reading FIFO? */
			outb(CLRINT + iobase, CLRCMDINT);
			untimeout(ahc_timeout, scb);
			ahc_done(ahc, scb);
		} while (inb(QOUTCNT + iobase));
d1755 1
a1755 1
	
d1757 1
d1765 1
a1765 1
void
d1767 2
a1768 2
	struct ahc_softc *ahc;
	struct ahc_scb *scb;
d1771 2
a1772 13
	
#ifdef AHC_MORE_DEBUG
	if ((xs->sc_link->target & 0xf) == DEBUGTARGET) {
		xs->sc_link->flags |= 0xf0;
		SC_DEBUG(xs->sc_link, SDEV_DB2, ("ahc_done\n"));
		printf("%x %x %x %x\n",
		    scb->flags,
		    scb->target_status,
		    xs->flags,
		    xs->error);
	}
#endif
	
d1777 15
a1791 5
	if (xs->error == XS_NOERROR) {
		if (scb->flags == SCB_ABORTED)
			xs->error = XS_DRIVER_STUFFUP;
		else if (scb->flags == SCB_CHKSENSE)
			xs->error = XS_SENSE;
d1793 6
a1798 1
	
a1799 1
	
d1801 2
a1802 1
	if (xs->cmd->opcode == 0x12 && xs->error == XS_NOERROR) {
d1805 1
a1805 1
					(scb->target_channel_lun & 0x08));
d1808 1
a1808 1
		 * command and see if we can do Tagged queing.  XXX This
d1812 5
a1816 8
		if (((inq_data->device & SID_TYPE) == 0)
		    && (inq_data->flags & SID_CmdQue)
		    && !(ahc->tagenable & mask)) {
			/*
			 * Disk type device and can tag
			 */
			sc_print_addr(xs->sc_link);
			printf("Tagged Queuing Device\n");
d1818 16
a1833 3
#ifdef QUEUE_FULL_SUPPORTED
			xs->sc_link->openings += 2; */
#endif
a1836 1
	
a1843 1
/* XXXX clean */
d1846 1
a1846 1
	struct ahc_softc *ahc;
d1848 3
a1850 4
	int iobase = ahc->sc_iobase;
	u_char scsi_conf, sblkctl, i;
	int intdef, max_targ = 16, wait;

d1852 1
a1852 2
	 * Assume we have a board at this stage
	 * Find out the configured interupt and the card type.
d1855 4
a1858 27
#ifdef AHC_DEBUG
	printf("%s: scb %d bytes; SCB_SIZE %d bytes, ahc_dma %d bytes\n",
	    ahc->sc_dev.dv_xname, sizeof(struct ahc_scb), SCB_DOWN_SIZE,
	    sizeof(struct ahc_dma_seg));
#endif /* AHC_DEBUG */
	
	/* Save the IRQ type before we do a chip reset */
	
	ahc->unpause = (inb(HCNTRL + iobase) & IRQMS) | INTEN;
	ahc->pause = ahc->unpause | PAUSE;
	outb(HCNTRL + iobase, CHIPRST | ahc->pause);
	
	/*
	 * Ensure that the reset has finished
	 */
	wait = 1000;
	while (wait--) {
		delay(1000);
		if (!(inb(HCNTRL + iobase) & CHIPRST))
		    break;
	}
	if (wait == 0) {
		printf("\n%s: WARNING - Failed chip reset!  "
		       "Trying to initialize anyway.\n", ahc->sc_dev.dv_xname);
		/* Forcibly clear CHIPRST */
		outb(HCNTRL + iobase, ahc->pause);
	}
d1860 11
a1870 4
	switch (ahc->type) {
	case AHC_274:
		printf("%s: 274x ", ahc->sc_dev.dv_xname);
		ahc->maxscbs = 0x4;
d1872 6
a1877 8
	case AHC_284:
		printf("%s: 284x ", ahc->sc_dev.dv_xname);
		ahc->maxscbs = 0x4;
		break;
	case AHC_AIC7870:
	case AHC_294:
		if (ahc->type == AHC_AIC7870)
			printf("%s: aic7870 ", ahc->sc_dev.dv_xname);
d1879 1
a1879 27
			printf("%s: 294x ", ahc->sc_dev.dv_xname);
		ahc->maxscbs = 0x10;
		#define DFTHRESH        3
		outb(DSPCISTATUS + iobase, DFTHRESH << 6);
		/*
		 * XXX Hard coded SCSI ID until we can read it from the
		 * SEEPROM or NVRAM.
		 */
		outb(HA_SCSICONF + iobase, 0x07 | (DFTHRESH << 6));
		/* In case we are a wide card */
		outb(HA_SCSICONF + 1 + iobase, 0x07);
		break;
	default:
	        printf("%s: unknown(0x%x) ", ahc->sc_dev.dv_xname, ahc->type);
		break;
	}
	
	/* Determine channel configuration and who we are on the scsi bus. */
	switch ((sblkctl = inb(SBLKCTL + iobase) & 0x0f)) {
	case 0:
		ahc->ahc_scsi_dev = (inb(HA_SCSICONF + iobase) & HSCSIID);
		printf("Single Channel, SCSI Id=%d, ", ahc->ahc_scsi_dev);
		outb(HA_FLAGS + iobase, SINGLE_BUS);
		break;
	case 2:
		ahc->ahc_scsi_dev = (inb(HA_SCSICONF + 1 + iobase) & HWSCSIID);
		printf("Wide Channel, SCSI Id=%d, ", ahc->ahc_scsi_dev);
d1881 1
a1881 1
		outb(HA_FLAGS + iobase, WIDE_BUS);
d1883 3
a1885 3
	case 8:
		ahc->ahc_scsi_dev = (inb(HA_SCSICONF + iobase) & HSCSIID);
		ahc->ahc_scsi_dev_b = (inb(HA_SCSICONF + 1 + iobase) & HSCSIID);
d1887 1
a1887 1
		    ahc->ahc_scsi_dev, ahc->ahc_scsi_dev_b);
d1889 1
a1889 1
		outb(HA_FLAGS + iobase, TWIN_BUS);
d1891 2
a1892 2
	default:
		printf(" Unsupported adapter type.  %x Ignoring\n", sblkctl);
d1896 1
a1896 4
	/*
	 * Take the bus led out of diagnostic mode
	 */
	outb(SBLKCTL + iobase, sblkctl);
d1898 14
a1911 41
	/*
	 * Number of SCBs that will be used. Rev E aic7770s and
	 * aic7870s have 16.  The rest have 4.
	 */
	if (!(ahc->type & AHC_AIC7870)) {
		/*
		 * See if we have a Rev E or higher
		 * aic7770. Anything below a Rev E will
		 * have a R/O autoflush disable configuration
		 * bit.
		 */
		u_char sblkctl_orig;
		sblkctl_orig = inb(SBLKCTL + iobase);
		sblkctl = sblkctl_orig ^ AUTOFLUSHDIS;
		outb(SBLKCTL + iobase, sblkctl);
		sblkctl = inb(SBLKCTL + iobase);
		if (sblkctl != sblkctl_orig) {
			printf("aic7770 >= Rev E, ");
			/*
			 * Ensure autoflush is enabled
			 */
			sblkctl &= ~AUTOFLUSHDIS;
			outb(SBLKCTL + iobase, sblkctl);
		} else
			printf("aic7770 <= Rev C, ");
	} else
		printf("aic7870, ");
	printf("%d SCBs\n", ahc->maxscbs);
	
	if (ahc->pause & IRQMS)
		printf("%s: Using Level Sensitive Interrupts\n",
		    ahc->sc_dev.dv_xname);
	else
		printf("%s: Using Edge Triggered Interrupts\n",
		    ahc->sc_dev.dv_xname);
	
	if (!(ahc->type & AHC_AIC7870)) {
		/*
		 * The 294x cards are PCI, so we get their interrupt from the
		 * PCI BIOS.
		 */
d1913 1
a1913 23
		intdef = inb(INTDEF + iobase);
		switch (intdef & 0xf) {
		case 9:
			ahc->sc_irq = 9;
			break;
		case 10:
			ahc->sc_irq = 10;
			break;
		case 11:
			ahc->sc_irq = 11;
			break;
		case 12:
			ahc->sc_irq = 12;
			break;
		case 14:
			ahc->sc_irq = 14;
			break;
		case 15:
			ahc->sc_irq = 15;
			break;
		default:
			printf("illegal irq setting\n");
			return (EIO);
d1915 27
d1943 5
a1947 3
	
	/* Set the SCSI Id, SXFRCTL1, and SIMODE1, for both channels */
	if (ahc->type & AHC_TWIN) {
d1952 2
a1953 2
		outb(SCSIID + iobase, ahc->ahc_scsi_dev_b);
		scsi_conf = inb(HA_SCSICONF + 1 + iobase) & (ENSPCHK|STIMESEL);
d1955 15
a1969 1
		outb(SIMODE1 + iobase, ENSELTIMO|ENSCSIPERR);
d1973 2
a1974 2
	outb(SCSIID + iobase, ahc->ahc_scsi_dev);
	scsi_conf = inb(HA_SCSICONF + iobase) & (ENSPCHK|STIMESEL);
d1976 15
a1990 2
	outb(SIMODE1 + iobase, ENSELTIMO|ENSCSIPERR);
	
d1997 1
a1997 1
	 * negotiation to that target so we don't activate the needsdr
a2001 2
	if (!(ahc->type & AHC_WIDE))
		max_targ = 8;
d2003 18
a2020 6
	for (i = 0; i < max_targ; i++) {
		u_char target_settings = inb(HA_TARG_SCRATCH + i + iobase);
#if 0 /* XXXX */
		target_settings |= 0x8f;
#endif
		if (target_settings & 0x0f) {
d2022 1
a2022 2
			/* Default to a asyncronous transfers (0 offset) */
			target_settings &= 0xf0;
d2024 19
a2042 9
		if (target_settings & 0x80) {
			ahc->needwdtr_orig |= (0x01 << i);
			/*
			 * We'll set the Wide flag when we
			 * are successful with Wide negotiation,
			 * so turn it off for now so we aren't
			 * confused.
			 */
			target_settings &= 0x7f;
d2044 1
a2044 1
		outb(HA_TARG_SCRATCH + i + iobase, target_settings);
d2052 1
a2052 1
	if (!(ahc->type & AHC_WIDE))
d2059 9
a2067 1
	
d2069 1
a2069 2
	 * Clear the control byte for every SCB so that the sequencer
	 * doesn't get confused and think that one of them is valid
d2071 1
a2071 4
	for (i = 0; i < ahc->maxscbs; i++) {
		outb(SCBPTR + iobase, i);
		outb(SCBARRAY + iobase, 0);
	}
d2073 5
a2077 4
#ifdef AHC_DEBUG
	printf("NEEDSDTR == 0x%x\nNEEDWDTR == 0x%x\n", ahc->needsdtr,
		ahc->needwdtr);
#endif
d2080 3
a2082 1
	 * Set the number of availible SCBs
d2084 1
a2084 1
	outb(HA_SCBCOUNT + iobase, ahc->maxscbs);
d2087 3
a2089 3
	outb(HA_ACTIVE0 + iobase, 0);
	outb(HA_ACTIVE1 + iobase, 0);
	
d2092 7
a2098 1
	outb(WAITING_SCBT + iobase, SCB_LIST_NULL);
d2100 18
a2117 3
	 * Load the Sequencer program and Enable the adapter.
	 * Place the aic7770 in fastmode which makes a big
	 * difference when doing many small block transfers.
d2119 1
a2119 15
	
	printf("%s: Downloading Sequencer Program...", ahc->sc_dev.dv_xname);
	ahc_loadseq(iobase);
	printf("Done\n");
	
	if (!(ahc->type & AHC_AIC7870))
		outb(BCTL + iobase, ENABLE);
	
	/* Reset the bus */
	outb(SCSISEQ + iobase, SCSIRSTO);
	delay(1000);
	outb(SCSISEQ + iobase, 0);
	
	RESTART_SEQUENCER(ahc);
	
d2123 1
a2123 1
void
d2125 1
a2125 1
	struct buf *bp;
d2127 11
a2137 3

	if (bp->b_bcount > ((AHC_NSEG - 1) << PGSHIFT))
		bp->b_bcount = ((AHC_NSEG - 1) << PGSHIFT);
d2139 1
d2147 1
a2147 1
int
d2149 1
a2149 1
	struct scsi_xfer *xs;
d2151 57
a2207 55
	struct scsi_link *sc_link = xs->sc_link;
	struct ahc_softc *ahc = sc_link->adapter_softc;
	struct ahc_scb *scb;
	struct ahc_dma_seg *sg;
	int seg;            /* scatter gather seg being worked on */
	u_long thiskv, thisphys, nextphys;
	int bytes_this_seg, bytes_this_page, datalen, flags;
	int s;
	u_short	mask = (0x01 << (sc_link->target | (sc_link->quirks & 0x08)));

#ifdef AHC_MORE_DEBUG
	if ((sc_link->target & 0xf) == DEBUGTARGET) {
		printf("ahc ahc_scsi_cmd for %x\n", sc_link->target);
		sc_link->flags = 0xf0;
		SC_DEBUG(sc_link, SDEV_DB2, ("ahc_scsi_cmd\n"));
	}
#endif
	
	/*
	 * get a scb to use. If the transfer
	 * is from a buf (possibly from interrupt time)
	 * then we can't allow it to sleep
	 */
	flags = xs->flags;
	if ((flags & (ITSDONE|INUSE)) != INUSE) {
		printf("%s: done or not in use?\n", ahc->sc_dev.dv_xname);
		xs->flags &= ~ITSDONE;
		xs->flags |= INUSE;
	}
	if ((scb = ahc_get_scb(ahc, flags)) == NULL) {
		xs->error = XS_DRIVER_STUFFUP;
		return (TRY_AGAIN_LATER);
	}
	scb->xs = xs;
	
#ifdef AHC_MORE_DEBUG
	if ((sc_link->target & 0xf) == DEBUGTARGET) {
		sc_link->flags = 0xf0;
		SC_DEBUG(sc_link, SDEV_DB3, ("start scb(%x)\n", scb));
	}
#endif
	
	if (flags & SCSI_RESET) {
		/* XXX: Needs Implementation */
		printf("ahc: SCSI_RESET called.\n");
	}
	
	/*
	 * Put all the arguments for the xfer in the scb
	 */
	scb->control = 0;
	if (ahc->tagenable & mask)
		scb->control |= SCB_TE;
	if ((ahc->needwdtr & mask) && !(ahc->wdtrpending & mask)) {
		scb->control |= SCB_NEEDWDTR;
d2210 3
a2212 2
	if ((ahc->needsdtr & mask) && !(ahc->sdtrpending & mask)) {
		scb->control |= SCB_NEEDSDTR;
d2215 7
a2221 2
	scb->target_channel_lun = ((sc_link->target << 4) & 0xF0) |
	    (sc_link->quirks & 0x08) | (sc_link->lun & 0x07);
d2223 1
a2223 2
	scb->cmdpointer = vtophys(xs->cmd);
	
d2225 3
a2227 2
	if (xs->datalen) {
		scb->SG_list_pointer = vtophys(scb->ahc_dma);
d2230 20
a2249 51
		{
			/*
			 * Set up the scatter gather block
			 */
#ifdef AHC_MORE_DEBUG
			if ((sc_link->target & 0xf) == DEBUGTARGET) {
				sc_link->flags = 0xf0;
				SC_DEBUG(sc_link, SDEV_DB4,
				     ("%ld @@%x:- ", xs->datalen, xs->data));
			}
#endif
			datalen = xs->datalen;
			thiskv = (long) xs->data;
			thisphys = vtophys(thiskv);
			
			while (datalen && seg < AHC_NSEG) {
				bytes_this_seg = 0;

				/* put in the base address */
				sg->seg_addr = thisphys;

#ifdef AHC_MORE_DEBUG
				if ((sc_link->target & 0xf) == DEBUGTARGET) {
					sc_link->flags = 0xf0;
					SC_DEBUGN(sc_link, SDEV_DB4, ("0x%lx",
					    thisphys));
				}
#endif

				/* do it at least once */
				nextphys = thisphys;
				while (datalen && thisphys == nextphys) {
					/*
					 * This page is contiguous (physically)
					 * with the the last, just extend the
					 * length
					 */
					/* how far to the end of the page */
					nextphys = (thisphys & ~PGOFSET) + NBPG;
					bytes_this_page = nextphys - thisphys;
					/**** or the data ****/
					bytes_this_page = min(bytes_this_page,
							      datalen);
					bytes_this_seg += bytes_this_page;
					datalen -= bytes_this_page;

					/* get more ready for the next page */
					thiskv = (thiskv & ~PGOFSET) + NBPG;
					if (datalen)
						thisphys = vtophys(thiskv);
				}
d2251 3
a2253 1
				 * next page isn't contiguous, finish the seg
d2255 14
a2268 10
#ifdef AHC_MORE_DEBUG
				if ((sc_link->target & 0xf) == DEBUGTARGET) {
					sc_link->flags = 0xf0;
					SC_DEBUGN(sc_link, SDEV_DB4, ("(0x%x)",
					    bytes_this_seg));
				}
#endif
				sg->seg_len = bytes_this_seg;
				sg++;
				seg++;
d2270 8
a2278 1
		/*end of iov/kv decision */
d2280 10
a2289 12
#ifdef AHC_MORE_DEBUG
		if ((sc_link->target & 0xf) == DEBUGTARGET) {
			sc_link->flags = 0xf0;
			SC_DEBUGN(sc_link, SDEV_DB4, ("\n"));
		}
#endif
		if (datalen) {
			/*
			 * there's still data, must have run out of segs!
			 */
			printf("%s: ahc_scsi_cmd: more than %d dma segs\n",
			    ahc->sc_dev.dv_xname, AHC_NSEG);
d2294 9
a2302 2
	} else {
		scb->SG_list_pointer = (physaddr)0;
d2304 3
d2309 2
a2310 2
#ifdef AHC_MORE_DEBUG
	if (sc_link->target == DEBUGTARGET)
a2312 1

d2315 5
a2319 1
	ahc_send_scb(ahc, scb);
d2321 20
a2340 5
	/*
	 * Usually return SUCCESSFULLY QUEUED
	 */
	if ((flags & SCSI_POLL) == 0) {
		timeout(ahc_timeout, scb, (xs->timeout * hz) / 1000);
a2341 6
#ifdef AHC_MORE_DEBUG
		if ((sc_link->target & 0xf) == DEBUGTARGET) {
			sc_link->flags = 0xf0;
			SC_DEBUG(sc_link, SDEV_DB3, ("cmd_sent\n"));
		}
#endif
a2343 3
	
	splx(s);
	
d2345 1
a2345 1
	 * If we can't use interrupts, poll on completion
d2347 5
a2351 9
#ifdef AHC_MORE_DEBUG
	if ((sc_link->target & 0xf) == DEBUGTARGET) {
		sc_link->flags = 0xf0;
		SC_DEBUG(sc_link, SDEV_DB3, ("cmd_wait\n"));
	}
#endif
	if (ahc_poll(ahc, xs, xs->timeout)) {
		ahc_timeout(scb);
		if (ahc_poll(ahc, xs, 2000))
d2353 4
a2356 1
	}
d2365 1
a2365 1
void
d2367 3
a2369 3
	struct ahc_softc *ahc;
	struct  ahc_scb *scb;
	int flags;
d2371 2
a2372 1
	int s;
d2374 1
a2374 1
	s = splbio();
d2377 38
a2414 1
	TAILQ_INSERT_TAIL(&ahc->free_scb, scb, chain);
d2416 1
a2416 1
	ahc->activescbs--;
d2418 8
a2425 61

	/*
	 * If there were none, wake anybody waiting for one to come free,
	 * starting with queued entries.
	 */
	if (scb->chain.tqe_next == 0)
		wakeup(&ahc->free_scb);

	splx(s);
}

/* XXXX check */
static inline void
ahc_init_scb(ahc, scb)
	struct ahc_softc *ahc;
	struct ahc_scb *scb;
{
	int iobase = ahc->sc_iobase;
	u_char scb_index;

	bzero(scb, sizeof(struct ahc_scb));
	scb->position = ahc->numscbs;
	/*
	 * Place in the scbarray
	 * Never is removed.  Position
	 * in ahc->scbarray is the scbarray
	 * position on the board we will
	 * load it into.
	 */
	ahc->scbarray[scb->position] = scb;

	/*
	 * Initialize the host memory location
	 * of this SCB down on the board and
	 * flag that it should be DMA's before
	 * reference.  Also set its psuedo
	 * next pointer (for use in the psuedo
	 * list of SCBs waiting for selection)
	 * to SCB_LIST_NULL.
	 */
	scb->control = SCB_NEEDDMA;
	scb->host_scb = vtophys(scb);
	scb->next_waiting = SCB_LIST_NULL;
	PAUSE_SEQUENCER(ahc);
	scb_index = inb(SCBPTR + iobase);
	outb(SCBPTR + iobase, scb->position);
	outb(SCBCNT + iobase, SCBAUTO);
	outsb(SCBARRAY + iobase, scb, 31);
	outb(SCBCNT + iobase, 0);
	outb(SCBPTR + iobase, scb_index);
	UNPAUSE_SEQUENCER(ahc);
	scb->control = 0;
}

static inline void
ahc_reset_scb(ahc, scb)
	struct ahc_softc *ahc;
	struct ahc_scb *scb;
{

	bzero(scb, SCB_BZERO_SIZE);
d2429 4
a2432 3
 * Get a free scb
 *
 * If there are none, see if we can allocate a new one.
d2434 1
a2434 1
struct ahc_scb *
d2436 2
a2437 2
	struct ahc_softc *ahc;
	int flags;
d2439 2
a2440 4
	struct ahc_scb *scb;
	int s;

	s = splbio();
d2442 1
d2447 28
a2474 5
	for (;;) {
		scb = ahc->free_scb.tqh_first;
		if (scb) {
			TAILQ_REMOVE(&ahc->free_scb, scb, chain);
			break;
d2476 5
a2480 9
		if (ahc->numscbs < ahc->maxscbs) {
			if (scb = (struct ahc_scb *) malloc(sizeof(struct ahc_scb),
			    M_TEMP, M_NOWAIT)) {
				ahc_init_scb(ahc, scb);
				ahc->numscbs++;
			} else {
				printf("%s: can't malloc scb\n",
				    ahc->sc_dev.dv_xname);
				goto out;
a2481 1
			break;
d2483 1
a2483 3
		if ((flags & SCSI_NOSLEEP) != 0)
			goto out;
		tsleep(&ahc->free_scb, PRIBIO, "ahcscb", 0);
d2486 4
a2489 2
	ahc_reset_scb(ahc, scb);
	scb->flags = SCB_ACTIVE;
d2491 5
a2495 3
	ahc->activescbs++;
	if (ahc->activescbs == ahc->maxscbs)
		printf("%s: Max SCBs active\n", ahc->sc_dev.dv_xname);
d2497 3
d2501 1
a2501 3
out:
	splx(s);
	return (scb);
d2504 2
a2505 4
/* XXXX check */
void
ahc_loadseq(iobase)
	int iobase;
d2507 1
a2507 1
	static u_char seqprog[] = {
d2512 1
d2514 1
d2516 5
d2524 2
a2525 1
 * Function to poll for command completion when in poll mode
d2527 185
a2711 8
int
ahc_poll(ahc, xs, count)
	struct ahc_softc *ahc;
	struct scsi_xfer *xs;
	int count;
{                               /* in msec  */
	int iobase = ahc->sc_iobase;
	int stport = INTSTAT + iobase;
d2713 66
a2778 1
	while (count) {
d2780 2
a2781 2
		 * If we had interrupts enabled, would we
		 * have got an interrupt?
d2783 8
a2790 6
		if (inb(stport) & INT_PEND)
			ahcintr(ahc);
		if (xs->flags & ITSDONE)
			return 0;
		delay(1000);
		count--;
d2792 2
a2793 1
	return 1;
d2796 12
a2807 5
/* XXXX check */
void
ahc_abort_scb(ahc, scb)
	struct ahc_softc *ahc;
	struct ahc_scb *scb;
d2809 4
a2812 1
	int iobase = ahc->sc_iobase;
a2813 3
	int scb_index;
	u_char flags;
	u_char scb_control;
d2815 3
a2817 1
	PAUSE_SEQUENCER(ahc);
d2819 1
a2819 1
	 * Case 1: In the QINFIFO
d2823 1
a2823 2
		int i;
		int queued = inb(QINCNT + iobase);
d2827 11
a2837 1
			if (saved_queue[i] == scb->position) {
d2839 1
a2839 1
				found = 1;
d2842 5
a2846 3
		/* Re-insert entries back into the queue */
		for (queued = 0; queued < i; queued++)
			outb(QINFIFO + iobase, saved_queue[queued]);
a2847 5
		if (found)
			goto done;
	}
	
	scb_index = inb(SCBPTR + iobase);
d2849 1
a2849 1
	 * Case 2: Not the active command
d2851 22
a2872 19
	if (scb_index != scb->position) {
		/*
		 * Select the SCB we want to abort
		 * and turn off the disconnected bit.
		 * the driver will then abort the command
		 * and notify us of the abort.
		 */
		outb(SCBPTR + iobase, scb->position);
		scb_control = inb(SCBARRAY + iobase);
		scb_control &= ~SCB_DIS;
		outb(SCBARRAY + iobase, scb_control);
		outb(SCBPTR + iobase, scb_index);
		goto done;
	}
	scb_control = inb(SCBARRAY + iobase);
	if (scb_control & SCB_DIS) {
		scb_control &= ~SCB_DIS;
		outb(SCBARRAY + iobase, scb_control);
		goto done;
d2875 61
a2935 3
	 * Case 3: Currently active command
	 */
	if ((flags = inb(HA_FLAGS + iobase)) & ACTIVE_MSG) {
d2937 2
a2938 2
		 * If there's a message in progress,
		 * reset the bus and have all devices renegotiate.
d2940 2
a2941 22
		if (scb->target_channel_lun & 0x08) {
			ahc->needsdtr |= (ahc->needsdtr_orig & 0xff00);
			ahc->sdtrpending &= 0x00ff;
			outb(HA_ACTIVE1, 0);
		} else if (ahc->type & AHC_WIDE) {
			ahc->needsdtr = ahc->needsdtr_orig;
			ahc->needwdtr = ahc->needwdtr_orig;
			ahc->sdtrpending = 0;
			ahc->wdtrpending = 0;
			outb(HA_ACTIVE0, 0);
			outb(HA_ACTIVE1, 0);
		} else {
			ahc->needsdtr |= (ahc->needsdtr_orig & 0x00ff);
			ahc->sdtrpending &= 0xff00;
			outb(HA_ACTIVE0, 0);
		}

		/* Reset the bus */
		outb(SCSISEQ + iobase, SCSIRSTO);
		delay(1000);
		outb(SCSISEQ + iobase, 0);
		goto done;
a2942 1
	
d2944 10
a2953 14
	 * Otherwise, set up an abort message and have the sequencer
	 * clean up
	 */
	outb(HA_FLAGS + iobase, flags | ACTIVE_MSG);
	outb(HA_MSG_LEN + iobase, 1);
	outb(HA_MSG_START + iobase, MSG_ABORT);
	
	outb(SCSISIGO + iobase, inb(HA_SIGSTATE + iobase) | 0x10);
	
done:
	scb->flags = SCB_ABORTED;
	UNPAUSE_SEQUENCER(ahc);
	ahc_done(ahc, scb);
	return;
d2956 5
a2960 3
void
ahc_timeout(arg)
	void *arg;
d2962 14
a2975 5
	struct ahc_scb *scb = arg;
	struct scsi_xfer *xs = scb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct ahc_softc *ahc = sc_link->adapter_softc;
	int s;
d2977 20
a2996 2
	sc_print_addr(sc_link);
	printf("timed out");
d2998 8
a3005 1
	s = splbio();
d3007 53
a3059 15
#ifdef SCSIDEBUG
	show_scsi_cmd(scb->xs);
#endif
#ifdef  AHC_DEBUG
	if (ahc_debug & AHC_SHOWSCBS)
		ahc_print_active_scb(ahc);
#endif /*AHC_DEBUG */

	if (scb->flags & SCB_IMMED) {
		printf("\n");
		scb->xs->retries = 0;   /* I MEAN IT ! */
		scb->flags |= SCB_IMMED_FAIL;
		ahc_done(ahc, scb);
		splx(s);
		return;
d3063 21
a3083 18
	 * If it has been through before, then
	 * a previous abort has failed, don't
	 * try abort again
	 */
	if (scb->flags == SCB_ABORTED) {
		/* abort timed out */
		printf(" AGAIN\n");
		scb->xs->retries = 0;	/* I MEAN IT ! */
		ahc_done(ahc, scb);
	} else {
		/* abort the operation that has timed out */
		printf("\n");
		scb->xs->error = XS_TIMEOUT;
		scb->flags = SCB_ABORTED;
		ahc_abort_scb(ahc, scb);
		/* 2 secs for the abort */
		if ((xs->flags & SCSI_POLL) == 0)
			timeout(ahc_timeout, scb, 2 * hz);
d3085 36
d3122 4
a3125 1
	splx(s);
@


1.3
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: aic7xxx.c,v 1.3 1996/02/25 22:56:30 cgd Exp $	*/
d66 1
a69 1
/*#define AHC_DEBUG /**/
d71 1
a71 2

/*#define AHC_MORE_DEBUG /**/
a630 1
	u_char scsirate;
d653 4
a656 1
ahcprint()
d659 3
d775 1
a775 1
			      "target %d at seqaddr = 0x%lx "
d854 1
a854 1
				    printf("Sending SDTR!!\n");
a1024 1
					u_char flags;
a1394 1
	/*printf("%s: reading board settings\n", ahc->sc_dev.dv_xname);/**/
@


1.2
log
@from netbsd:
Add the "ahe" driver, autoconfiguration support for the aic7xxx-based
Adaptec 2[78]4x SCSI controllers, from Michael Graff <explorer@@flame.org>.
Fixes PR #1594 from Noriyuki Soda <soda@@sra.co.jp> in a different way.
@
text
@d1 2
a2 1
/*	$NetBSD: aic7xxx.c,v 1.2 1996/01/13 02:05:22 thorpej Exp $	*/
a46 4

#include <dev/isa/isareg.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: aic7xxx.c,v 1.1 1995/10/09 09:49:30 mycroft Exp $	*/
d539 2
a540 2
	    scb->ahc_dma[0].addr,
	    scb->ahc_dma[0].len);
d542 1
a542 1
	    (int)&scb->next - (int)scb);
d1006 1
a1006 1
#ifdef AHC_DEBUG
d1421 1
a1421 1
		printf(": 274x ", ahc->sc_dev.dv_xname);
d1425 1
a1425 1
		printf(": 284x ", ahc->sc_dev.dv_xname);
d1431 1
a1431 1
			printf(": aic7870 ", ahc->sc_dev.dv_xname);
d1433 1
a1433 1
			printf(": 294x ", ahc->sc_dev.dv_xname);
d1445 3
d1472 1
a1472 1
		printf(" Unsupported adapter type.  %x Ignoring\n",sblkctl);
d1845 1
a1845 1
#ifdef AHC_DEBUG
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
