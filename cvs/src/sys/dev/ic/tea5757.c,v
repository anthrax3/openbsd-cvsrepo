head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.64
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.62
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.56
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.58
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.50
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.54
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.52
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.48
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.46
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.42
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.44
	OPENBSD_5_0:1.3.0.40
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.38
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.36
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.32
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.34
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.30
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.28
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.26
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.24
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.22
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.20
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.18
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.16
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.14
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.12
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.10
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.8
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.2
	UBC_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2002.01.07.18.32.19;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.06.16.28.18;	author mickey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.10.04.19.46.46;	author gluk;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.01.31.22.55.32;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@use flags instead of options to choose the tea5757 vs tea5759.
from Vladimir Popov <jumbo@@narod.ru>
@
text
@/*	$OpenBSD: tea5757.c,v 1.2 2001/12/06 16:28:18 mickey Exp $	*/

/*
 * Copyright (c) 2001 Vladimir Popov <jumbo@@narod.ru>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Implementation of most common TEA5757 routines */

/*
 * Philips TEA5757H Self Tuned Radio
 *         http://www.semiconductors.philips.com/pip/TEA5757H
 *
 * The TEA5757; TEA5759 is a 44-pin integrated AM/FM stereo radio circuit.
 * The radio part is based on the TEA5712.
 *
 * The TEA5757 is used in FM-standards in which the local oscillator
 * frequency is above the radio frequency (e.g. European and American
 * standards). The TEA5759 is the version in which the oscillator frequency
 * is below the radio frequency (e.g. Japanese standard).
 *
 * The TEA5757; TEA5759 radio has a bus which consists of three wires:
 * BUS-CLOCK: software driven clock input
 * DATA: data input/output
 * WRITE-ENABLE: write/read input
 *
 * The TEA5757; TEA5759 has a 25-bit shift register.
 *
 * The chips are used in Radiotrack II, Guillemot Maxi Radio FM 2000,
 * Gemtek PCI cards and most Mediaforte FM tuners and sound cards with
 * integrated FM tuners.
 */

#include <sys/param.h>
#include <sys/radioio.h>

#include <dev/ic/tea5757.h>

/*
 * Convert frequency to hardware representation
 */
u_int32_t
tea5757_encode_freq(u_int32_t freq, int tea5759)
{
	if (tea5759)
		freq -= IF_FREQ;
	else
		freq += IF_FREQ;

	/*
	 * NO FLOATING POINT!
	 */
	freq *= 10;
	freq /= 125;

	return freq & TEA5757_FREQ;
}

/*
 * Convert frequency from hardware representation
 */
u_int32_t
tea5757_decode_freq(u_int32_t freq, int tea5759)
{
	freq &= TEA5757_FREQ;
	freq *= 125; /* 12.5 kHz */
	freq /= 10;

	if (tea5759)
		freq += IF_FREQ;
	else
		freq -= IF_FREQ;

	return freq;
}

/*
 * Hardware search
 */
void
tea5757_search(struct tea5757_t *tea, u_int32_t stereo, u_int32_t lock, int dir)
{
	u_int32_t reg;
	u_int co = 0;

	reg = stereo | lock | TEA5757_SEARCH_START;
	reg |= dir ? TEA5757_SEARCH_UP : TEA5757_SEARCH_DOWN;
	tea5757_hardware_write(tea, reg);

	DELAY(TEA5757_ACQUISITION_DELAY);

	do {
		DELAY(TEA5757_WAIT_DELAY);
		reg = tea->read(tea->iot, tea->ioh, tea->offset);
	} while ((reg & TEA5757_FREQ) == 0 && ++co < 200);
}

void
tea5757_hardware_write(struct tea5757_t *tea, u_int32_t data)
{
	int i = TEA5757_REGISTER_LENGTH;

	tea->init(tea->iot, tea->ioh, tea->offset, 0);

	while (i--)
		if (data & (1 << i))
			tea->write_bit(tea->iot, tea->ioh, tea->offset, 1);
		else
			tea->write_bit(tea->iot, tea->ioh, tea->offset, 0);

	tea->rset(tea->iot, tea->ioh, tea->offset, 0);
}

u_int32_t
tea5757_set_freq(struct tea5757_t *tea, u_int32_t stereo, u_int32_t lock, u_int32_t freq)
{
	u_int32_t data = 0ul;

	if (freq < MIN_FM_FREQ)
		freq = MIN_FM_FREQ;
	if (freq > MAX_FM_FREQ)
		freq = MAX_FM_FREQ;

	data |= tea5757_encode_freq(freq, tea->flags & TEA5757_TEA5759);
	data |= stereo | lock | TEA5757_SEARCH_END;
	tea5757_hardware_write(tea, data);

	return freq;
}

u_int32_t
tea5757_encode_lock(u_int8_t lock)
{
	u_int32_t ret;

	if (lock < 8)
		ret = TEA5757_S005;
	else if (lock > 7 && lock < 15)
		ret = TEA5757_S010;
	else if (lock > 14 && lock < 51)
		ret = TEA5757_S030;
	else if (lock > 50)
		ret = TEA5757_S150;

	return ret;
}

u_int8_t
tea5757_decode_lock(u_int32_t lock)
{
	u_int8_t ret = 150;

	switch (lock) {
	case TEA5757_S005:
		ret = 5;
		break;
	case TEA5757_S010:
		ret = 10;
		break;
	case TEA5757_S030:
		ret = 30;
		break;
	case TEA5757_S150:
		ret = 150;
		break;
	}

	return ret;
}
@


1.2
log
@update the radio chipset support
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
a63 1
tea5757_encode_freq(u_int32_t freq)
d65 5
a69 5
#ifdef RADIO_TEA5759
	freq -= IF_FREQ;
#else
	freq += IF_FREQ;
#endif /* RADIO_TEA5759 */
d75 1
d83 1
a83 1
tea5757_decode_freq(u_int32_t freq)
d88 6
a93 5
#ifdef RADIO_TEA5759
	freq += IF_FREQ;
#else
	freq -= IF_FREQ;
#endif /* RADIO_TEA5759 */
d144 2
a145 1
	data = tea5757_encode_freq(freq) | stereo | lock | TEA5757_SEARCH_END;
@


1.2.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: tea5757.c,v 1.3 2002/01/07 18:32:19 mickey Exp $	*/
d63 1
a63 1
tea5757_encode_freq(u_int32_t freq, int tea5759)
d65 5
a69 5
	if (tea5759)
		freq -= IF_FREQ;
	else
		freq += IF_FREQ;

a74 1

d82 1
a82 1
tea5757_decode_freq(u_int32_t freq, int tea5759)
d87 5
a91 6

	if (tea5759)
		freq += IF_FREQ;
	else
		freq -= IF_FREQ;

d142 1
a142 2
	data |= tea5757_encode_freq(freq, tea->flags & TEA5757_TEA5759);
	data |= stereo | lock | TEA5757_SEARCH_END;
@


1.1
log
@Chip specific parts for FM-radio drivers.

Work by Vladimir Popov <jumbo@@narod.ru> and Maxim Tsyplakov <tm@@oganer.net>
@
text
@d30 24
d62 2
a63 2
u_long
tea5757_encode_freq(u_long freq)
d81 2
a82 2
u_long
tea5757_decode_freq(u_long freq)
d99 1
a99 1
tea5757_search(struct tea5757_t *tea, u_long stereo, u_long lock, int dir)
d101 1
a101 1
	u_long reg;
d117 1
a117 1
tea5757_hardware_write(struct tea5757_t *tea, u_long data)
d132 2
a133 2
u_long
tea5757_set_freq(struct tea5757_t *tea, u_long stereo, u_long lock, u_long freq)
d135 1
a135 1
	u_long data = 0ul;
d148 2
a149 2
u_long
tea5757_encode_lock(u_char lock)
d151 1
a151 1
	u_long ret;
d165 2
a166 2
u_char
tea5757_decode_lock(u_long lock)
d168 1
a168 1
	u_char ret;
a180 2
		/* FALLTHROUGH */
	default:
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.1.4.2
log
@Merge in trunk
@
text
@a29 24
/*
 * Philips TEA5757H Self Tuned Radio
 *         http://www.semiconductors.philips.com/pip/TEA5757H
 *
 * The TEA5757; TEA5759 is a 44-pin integrated AM/FM stereo radio circuit.
 * The radio part is based on the TEA5712.
 *
 * The TEA5757 is used in FM-standards in which the local oscillator
 * frequency is above the radio frequency (e.g. European and American
 * standards). The TEA5759 is the version in which the oscillator frequency
 * is below the radio frequency (e.g. Japanese standard).
 *
 * The TEA5757; TEA5759 radio has a bus which consists of three wires:
 * BUS-CLOCK: software driven clock input
 * DATA: data input/output
 * WRITE-ENABLE: write/read input
 *
 * The TEA5757; TEA5759 has a 25-bit shift register.
 *
 * The chips are used in Radiotrack II, Guillemot Maxi Radio FM 2000,
 * Gemtek PCI cards and most Mediaforte FM tuners and sound cards with
 * integrated FM tuners.
 */

d38 2
a39 2
u_int32_t
tea5757_encode_freq(u_int32_t freq, int tea5759)
d41 5
a45 5
	if (tea5759)
		freq -= IF_FREQ;
	else
		freq += IF_FREQ;

a50 1

d57 2
a58 2
u_int32_t
tea5757_decode_freq(u_int32_t freq, int tea5759)
d63 5
a67 6

	if (tea5759)
		freq += IF_FREQ;
	else
		freq -= IF_FREQ;

d75 1
a75 1
tea5757_search(struct tea5757_t *tea, u_int32_t stereo, u_int32_t lock, int dir)
d77 1
a77 1
	u_int32_t reg;
d93 1
a93 1
tea5757_hardware_write(struct tea5757_t *tea, u_int32_t data)
d108 2
a109 2
u_int32_t
tea5757_set_freq(struct tea5757_t *tea, u_int32_t stereo, u_int32_t lock, u_int32_t freq)
d111 1
a111 1
	u_int32_t data = 0ul;
d118 1
a118 2
	data |= tea5757_encode_freq(freq, tea->flags & TEA5757_TEA5759);
	data |= stereo | lock | TEA5757_SEARCH_END;
d124 2
a125 2
u_int32_t
tea5757_encode_lock(u_int8_t lock)
d127 1
a127 1
	u_int32_t ret;
d141 2
a142 2
u_int8_t
tea5757_decode_lock(u_int32_t lock)
d144 1
a144 1
	u_int8_t ret = 150;
d157 2
@


