head	1.47;
access;
symbols
	OPENBSD_6_2:1.47.0.10
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.47.0.8
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.47.0.6
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.46.0.8
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.45.0.22
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.45.0.18
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.16
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.12
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.14
	OPENBSD_5_0:1.45.0.10
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.8
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.6
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.4
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.41.0.4
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.33.0.4
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16;
locks; strict;
comment	@ * @;


1.47
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.46;
commitid	1npmDuWgN1zBR6BQ;

1.46
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.45;
commitid	I19imNlAX05zJOED;

1.45
date	2009.06.02.12.39.02;	author reyk;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.15.07.55.22;	author grange;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.29.10.05.00;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.01.20.32.16;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.29.09.39.35;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.12.01.04.52;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.12.00.41.32;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.05.16.54.33;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.05.15.13.26;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.18.17.59.58;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.07.22.03.25;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.04.13.50.00;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.19.10.27.08;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.10.14.36.46;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.14.11.02.32;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.02.12.55.11;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.17.12.51.08;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.27.11.42.51;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.24.21.46.17;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.21.20.14.54;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.08.14.55.09;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.08.14.46.50;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.18.18.42.55;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.08.22.12.21;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.08.22.02.49;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.06.09.14.53;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.20.04.21.55;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.18.14.36.39;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.10.08.30.55;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.17.23.52.05;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.17.23.21.49;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.17.22.32.48;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.16.01.31.25;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.09.18.18.15;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.31.01.00.23;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.23.10.13.04;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.11.20.11.28;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.08.16.48.25;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.03.16.40.46;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.02.14.05.49;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.02.09.31.59;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.02.03.01.16;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@/*     $OpenBSD: ar5210.c,v 1.46 2014/07/12 18:48:17 tedu Exp $        */

/*
 * Copyright (c) 2004, 2005, 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * HAL interface for the Atheros AR5000 Wireless LAN chipset
 * (AR5210 + AR5110).
 */

#include <dev/ic/ar5xxx.h>
#include <dev/ic/ar5210reg.h>
#include <dev/ic/ar5210var.h>

HAL_BOOL	 ar5k_ar5210_nic_reset(struct ath_hal *, u_int32_t);
HAL_BOOL	 ar5k_ar5210_nic_wakeup(struct ath_hal *, HAL_BOOL);
void		 ar5k_ar5210_init_tx_queue(struct ath_hal *, u_int);
void		 ar5k_ar5210_fill(struct ath_hal *);
HAL_BOOL	 ar5k_ar5210_do_calibrate(struct ath_hal *, HAL_CHANNEL *);
HAL_BOOL	 ar5k_ar5210_noise_floor(struct ath_hal *, HAL_CHANNEL *);

/*
 * Initial register setting for the AR5210
 */
static const struct ar5k_ini ar5210_ini[] =
    AR5K_AR5210_INI;

AR5K_HAL_FUNCTIONS(extern, ar5k_ar5210,);

void
ar5k_ar5210_fill(struct ath_hal *hal)
{
	hal->ah_magic = AR5K_AR5210_MAGIC;

	/*
	 * Init/Exit functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, get_rate_table);
	AR5K_HAL_FUNCTION(hal, ar5210, detach);

	/*
	 * Reset functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, reset);
	AR5K_HAL_FUNCTION(hal, ar5210, set_opmode);
	AR5K_HAL_FUNCTION(hal, ar5210, calibrate);

	/*
	 * TX functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, update_tx_triglevel);
	AR5K_HAL_FUNCTION(hal, ar5210, setup_tx_queue);
	AR5K_HAL_FUNCTION(hal, ar5210, setup_tx_queueprops);
	AR5K_HAL_FUNCTION(hal, ar5210, release_tx_queue);
	AR5K_HAL_FUNCTION(hal, ar5210, reset_tx_queue);
	AR5K_HAL_FUNCTION(hal, ar5210, get_tx_buf);
	AR5K_HAL_FUNCTION(hal, ar5210, put_tx_buf);
	AR5K_HAL_FUNCTION(hal, ar5210, tx_start);
	AR5K_HAL_FUNCTION(hal, ar5210, stop_tx_dma);
	AR5K_HAL_FUNCTION(hal, ar5210, setup_tx_desc);
	AR5K_HAL_FUNCTION(hal, ar5210, setup_xtx_desc);
	AR5K_HAL_FUNCTION(hal, ar5210, fill_tx_desc);
	AR5K_HAL_FUNCTION(hal, ar5210, proc_tx_desc);
	AR5K_HAL_FUNCTION(hal, ar5210, has_veol);

	/*
	 * RX functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, get_rx_buf);
	AR5K_HAL_FUNCTION(hal, ar5210, put_rx_buf);
	AR5K_HAL_FUNCTION(hal, ar5210, start_rx);
	AR5K_HAL_FUNCTION(hal, ar5210, stop_rx_dma);
	AR5K_HAL_FUNCTION(hal, ar5210, start_rx_pcu);
	AR5K_HAL_FUNCTION(hal, ar5210, stop_pcu_recv);
	AR5K_HAL_FUNCTION(hal, ar5210, set_mcast_filter);
	AR5K_HAL_FUNCTION(hal, ar5210, set_mcast_filterindex);
	AR5K_HAL_FUNCTION(hal, ar5210, clear_mcast_filter_idx);
	AR5K_HAL_FUNCTION(hal, ar5210, get_rx_filter);
	AR5K_HAL_FUNCTION(hal, ar5210, set_rx_filter);
	AR5K_HAL_FUNCTION(hal, ar5210, setup_rx_desc);
	AR5K_HAL_FUNCTION(hal, ar5210, proc_rx_desc);
	AR5K_HAL_FUNCTION(hal, ar5210, set_rx_signal);

	/*
	 * Misc functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, dump_state);
	AR5K_HAL_FUNCTION(hal, ar5210, get_diag_state);
	AR5K_HAL_FUNCTION(hal, ar5210, get_lladdr);
	AR5K_HAL_FUNCTION(hal, ar5210, set_lladdr);
	AR5K_HAL_FUNCTION(hal, ar5210, set_regdomain);
	AR5K_HAL_FUNCTION(hal, ar5210, set_ledstate);
	AR5K_HAL_FUNCTION(hal, ar5210, set_associd);
	AR5K_HAL_FUNCTION(hal, ar5210, set_gpio_input);
	AR5K_HAL_FUNCTION(hal, ar5210, set_gpio_output);
	AR5K_HAL_FUNCTION(hal, ar5210, get_gpio);
	AR5K_HAL_FUNCTION(hal, ar5210, set_gpio);
	AR5K_HAL_FUNCTION(hal, ar5210, set_gpio_intr);
	AR5K_HAL_FUNCTION(hal, ar5210, get_tsf32);
	AR5K_HAL_FUNCTION(hal, ar5210, get_tsf64);
	AR5K_HAL_FUNCTION(hal, ar5210, reset_tsf);
	AR5K_HAL_FUNCTION(hal, ar5210, get_regdomain);
	AR5K_HAL_FUNCTION(hal, ar5210, detect_card_present);
	AR5K_HAL_FUNCTION(hal, ar5210, update_mib_counters);
	AR5K_HAL_FUNCTION(hal, ar5210, get_rf_gain);
	AR5K_HAL_FUNCTION(hal, ar5210, set_slot_time);
	AR5K_HAL_FUNCTION(hal, ar5210, get_slot_time);
	AR5K_HAL_FUNCTION(hal, ar5210, set_ack_timeout);
	AR5K_HAL_FUNCTION(hal, ar5210, get_ack_timeout);
	AR5K_HAL_FUNCTION(hal, ar5210, set_cts_timeout);
	AR5K_HAL_FUNCTION(hal, ar5210, get_cts_timeout);

	/*
	 * Key table (WEP) functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, is_cipher_supported);
	AR5K_HAL_FUNCTION(hal, ar5210, get_keycache_size);
	AR5K_HAL_FUNCTION(hal, ar5210, reset_key);
	AR5K_HAL_FUNCTION(hal, ar5210, is_key_valid);
	AR5K_HAL_FUNCTION(hal, ar5210, set_key);
	AR5K_HAL_FUNCTION(hal, ar5210, set_key_lladdr);
	AR5K_HAL_FUNCTION(hal, ar5210, softcrypto);

	/*
	 * Power management functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, set_power);
	AR5K_HAL_FUNCTION(hal, ar5210, get_power_mode);
	AR5K_HAL_FUNCTION(hal, ar5210, query_pspoll_support);
	AR5K_HAL_FUNCTION(hal, ar5210, init_pspoll);
	AR5K_HAL_FUNCTION(hal, ar5210, enable_pspoll);
	AR5K_HAL_FUNCTION(hal, ar5210, disable_pspoll);

	/*
	 * Beacon functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, init_beacon);
	AR5K_HAL_FUNCTION(hal, ar5210, set_beacon_timers);
	AR5K_HAL_FUNCTION(hal, ar5210, reset_beacon);
	AR5K_HAL_FUNCTION(hal, ar5210, wait_for_beacon);

	/*
	 * Interrupt functions
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, is_intr_pending);
	AR5K_HAL_FUNCTION(hal, ar5210, get_isr);
	AR5K_HAL_FUNCTION(hal, ar5210, get_intr);
	AR5K_HAL_FUNCTION(hal, ar5210, set_intr);

	/*
	 * Chipset functions (ar5k-specific, non-HAL)
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, get_capabilities);
	AR5K_HAL_FUNCTION(hal, ar5210, radar_alert);

	/*
	 * EEPROM access
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, eeprom_is_busy);
	AR5K_HAL_FUNCTION(hal, ar5210, eeprom_read);
	AR5K_HAL_FUNCTION(hal, ar5210, eeprom_write);

	/*
	 * Unused functions or functions not implemented
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, set_bssid_mask);
	AR5K_HAL_FUNCTION(hal, ar5210, get_tx_queueprops);
	AR5K_HAL_FUNCTION(hal, ar5210, num_tx_pending);
	AR5K_HAL_FUNCTION(hal, ar5210, phy_disable);
	AR5K_HAL_FUNCTION(hal, ar5210, set_txpower_limit);
	AR5K_HAL_FUNCTION(hal, ar5210, set_def_antenna);
	AR5K_HAL_FUNCTION(hal, ar5210, get_def_antenna);
#ifdef notyet
	AR5K_HAL_FUNCTION(hal, ar5210, set_capability);
	AR5K_HAL_FUNCTION(hal, ar5210, proc_mib_event);
	AR5K_HAL_FUNCTION(hal, ar5210, get_tx_inter_queue);
#endif
}

struct ath_hal *
ar5k_ar5210_attach(u_int16_t device, void *sc, bus_space_tag_t st,
    bus_space_handle_t sh, int *status)
{
	int i;
	struct ath_hal *hal = (struct ath_hal*) sc;
	u_int8_t mac[IEEE80211_ADDR_LEN];
	u_int32_t srev;

	ar5k_ar5210_fill(hal);

	/* Bring device out of sleep and reset its units */
	if (ar5k_ar5210_nic_wakeup(hal, AH_TRUE) != AH_TRUE)
		return (NULL);

	/* Get MAC, PHY and RADIO revisions */
	srev = AR5K_REG_READ(AR5K_AR5210_SREV);
	hal->ah_mac_srev = srev;
	hal->ah_mac_version = AR5K_REG_MS(srev, AR5K_AR5210_SREV_VER);
	hal->ah_mac_revision = AR5K_REG_MS(srev, AR5K_AR5210_SREV_REV);
	hal->ah_phy_revision = AR5K_REG_READ(AR5K_AR5210_PHY_CHIP_ID) &
	    0x00ffffffff;

	/* ...wait until PHY is ready and read RADIO revision */
	AR5K_REG_WRITE(AR5K_AR5210_PHY(0x34), 0x00001c16);
	for (i = 0; i < 4; i++)
		AR5K_REG_WRITE(AR5K_AR5210_PHY(0x20), 0x00010000);
	hal->ah_radio_5ghz_revision = (u_int16_t)
	    (ar5k_bitswap((AR5K_REG_READ(AR5K_AR5210_PHY(256) >> 28) & 0xf), 4)
		+ 1);
	hal->ah_radio_2ghz_revision = 0;

	/* Identify the chipset */
	hal->ah_version = AR5K_AR5210;
	hal->ah_radio = AR5K_AR5110;
	hal->ah_phy = AR5K_AR5210_PHY(0);

	bcopy(etherbroadcastaddr, mac, IEEE80211_ADDR_LEN);
	ar5k_ar5210_set_associd(hal, mac, 0, 0);
	ar5k_ar5210_get_lladdr(hal, mac);
	ar5k_ar5210_set_opmode(hal);

	return (hal);
}

HAL_BOOL
ar5k_ar5210_nic_reset(struct ath_hal *hal, u_int32_t val)
{
	HAL_BOOL ret = AH_FALSE;
	u_int32_t mask = val ? val : ~0;

	/*
	 * Reset the device and wait until success
	 */
	AR5K_REG_WRITE(AR5K_AR5210_RC, val);

	/* Wait at least 128 PCI clocks */
	AR5K_DELAY(15);

	val &=
	    AR5K_AR5210_RC_PCU | AR5K_AR5210_RC_MAC |
	    AR5K_AR5210_RC_PHY | AR5K_AR5210_RC_DMA;

	mask &=
	    AR5K_AR5210_RC_PCU | AR5K_AR5210_RC_MAC |
	    AR5K_AR5210_RC_PHY | AR5K_AR5210_RC_DMA;

	ret = ar5k_register_timeout(hal, AR5K_AR5210_RC, mask, val, AH_FALSE);

	/*
	 * Reset configuration register
	 */
	if ((val & AR5K_AR5210_RC_MAC) == 0) {
		AR5K_REG_WRITE(AR5K_AR5210_CFG, AR5K_AR5210_INIT_CFG);
	}

	return (ret);
}

HAL_BOOL
ar5k_ar5210_nic_wakeup(struct ath_hal *hal, HAL_BOOL initial)
{
	/*
	 * Reset and wakeup the device
	 */

	if (initial == AH_TRUE) {
		/* ...reset hardware */
		if (ar5k_ar5210_nic_reset(hal,
			AR5K_AR5210_RC_PCI) == AH_FALSE) {
			AR5K_PRINT("failed to reset the PCI chipset\n");
			return (AH_FALSE);
		}

		AR5K_DELAY(1000);
	}

	/* ...wakeup the device */
	if (ar5k_ar5210_set_power(hal,
		HAL_PM_AWAKE, AH_TRUE, 0) == AH_FALSE) {
		AR5K_PRINT("failed to resume the AR5210 chipset\n");
		return (AH_FALSE);
	}

	/* ...do not enable Atheros turbo mode */
	AR5K_REG_WRITE(AR5K_AR5210_PHY_FC, 0);

	/* ...reset chipset */
	if (ar5k_ar5210_nic_reset(hal, AR5K_AR5210_RC_CHIP) == AH_FALSE) {
		AR5K_PRINT("failed to reset the AR5210 chipset\n");
		return (AH_FALSE);
	}

	AR5K_DELAY(1000);

	/* ...reset chipset and PCI device */
	if (ar5k_ar5210_nic_reset(hal,
		AR5K_AR5210_RC_CHIP | AR5K_AR5210_RC_PCI) == AH_FALSE) {
		AR5K_PRINT("failed to reset the AR5210 + PCI chipset\n");
		return (AH_FALSE);
	}

	AR5K_DELAY(2300);

	/* ...wakeup (again) */
	if (ar5k_ar5210_set_power(hal,
		HAL_PM_AWAKE, AH_TRUE, 0) == AH_FALSE) {
		AR5K_PRINT("failed to resume the AR5210 (again)\n");
		return (AH_FALSE);
	}

	/* ...final warm reset */
	if (ar5k_ar5210_nic_reset(hal, 0) == AH_FALSE) {
		AR5K_PRINT("failed to warm reset the AR5210\n");
		return (AH_FALSE);
	}

	return (AH_TRUE);
}

const HAL_RATE_TABLE *
ar5k_ar5210_get_rate_table(struct ath_hal *hal, u_int mode)
{
	switch (mode) {
	case HAL_MODE_11A:
		return (&hal->ah_rt_11a);
	case HAL_MODE_11B:
	case HAL_MODE_11G:
	default:
		return (NULL);
	}

	return (NULL);
}

void
ar5k_ar5210_detach(struct ath_hal *hal)
{
	/*
	 * Free HAL structure, assume interrupts are down
	 */
	free(hal, M_DEVBUF, 0);
}

HAL_BOOL
ar5k_ar5210_phy_disable(struct ath_hal *hal)
{
	AR5K_REG_WRITE(AR5K_AR5210_PHY_ACTIVE, AR5K_AR5210_PHY_DISABLE);
	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_reset(struct ath_hal *hal, HAL_OPMODE op_mode, HAL_CHANNEL *channel,
    HAL_BOOL change_channel, HAL_STATUS *status)
{
	int i;

	/* Not used, keep for HAL compatibility */
	*status = HAL_OK;

	if (ar5k_ar5210_nic_wakeup(hal, AH_FALSE) == AH_FALSE)
		return (AH_FALSE);

	/*
	 * Initialize operating mode
	 */
	hal->ah_op_mode = op_mode;
	ar5k_ar5210_set_opmode(hal);

	/*
	 * Write initial mode register settings
	 */
	for (i = 0; i < nitems(ar5210_ini); i++) {
		if (change_channel == AH_TRUE &&
		    ar5210_ini[i].ini_register >= AR5K_AR5210_PCU_MIN &&
		    ar5210_ini[i].ini_register <= AR5K_AR5210_PCU_MAX)
			continue;

		switch (ar5210_ini[i].ini_mode) {
		case AR5K_INI_READ:
			/* Cleared on read */
			AR5K_REG_READ(ar5210_ini[i].ini_register);
			break;

		case AR5K_INI_WRITE:
		default:
			AR5K_REG_WRITE(ar5210_ini[i].ini_register,
			    ar5210_ini[i].ini_value);
		}
	}

	AR5K_DELAY(1000);

	/*
	 * Set channel and calibrate the PHY
	 */

	/* Disable phy and wait */
	AR5K_REG_WRITE(AR5K_AR5210_PHY_ACTIVE, AR5K_AR5210_PHY_DISABLE);
	AR5K_DELAY(1000);

	if (ar5k_channel(hal, channel) == AH_FALSE)
		return (AH_FALSE);

	/*
	 * Activate phy and wait
	 */
	AR5K_REG_WRITE(AR5K_AR5210_PHY_ACTIVE, AR5K_AR5210_PHY_ENABLE);
	AR5K_DELAY(1000);

	ar5k_ar5210_do_calibrate(hal, channel);
	if (ar5k_ar5210_noise_floor(hal, channel) == AH_FALSE)
		return (AH_FALSE);

	/*
	 * Set RF kill flags if supported by the device (read from the EEPROM)
	 */
	if (AR5K_EEPROM_HDR_RFKILL(hal->ah_capabilities.cap_eeprom.ee_header)) {
		ar5k_ar5210_set_gpio_input(hal, 0);
		if ((hal->ah_gpio[0] = ar5k_ar5210_get_gpio(hal, 0)) == 0) {
			ar5k_ar5210_set_gpio_intr(hal, 0, 1);
		} else {
			ar5k_ar5210_set_gpio_intr(hal, 0, 0);
		}
	}

	/*
	 * Reset queues and start beacon timers at the end of the reset routine
	 */
	for (i = 0; i < hal->ah_capabilities.cap_queues.q_tx_num; i++) {
		if (ar5k_ar5210_reset_tx_queue(hal, i) == AH_FALSE) {
			AR5K_PRINTF("failed to reset TX queue #%d\n", i);
			return (AH_FALSE);
		}
	}

	AR5K_REG_DISABLE_BITS(AR5K_AR5210_BEACON,
	    AR5K_AR5210_BEACON_EN | AR5K_AR5210_BEACON_RESET_TSF);

	return (AH_TRUE);
}

void
ar5k_ar5210_set_def_antenna(struct ath_hal *hal, u_int ant)
{
	/* Not available */
	return;
}

u_int
ar5k_ar5210_get_def_antenna(struct ath_hal *hal)
{
	return (0);
}

void
ar5k_ar5210_set_opmode(struct ath_hal *hal)
{
	u_int32_t pcu_reg, beacon_reg, low_id, high_id;

	beacon_reg = 0;
	pcu_reg = 0;

	switch (hal->ah_op_mode) {
	case IEEE80211_M_STA:
		pcu_reg |= AR5K_AR5210_STA_ID1_NO_PSPOLL |
		    AR5K_AR5210_STA_ID1_DESC_ANTENNA |
		    AR5K_AR5210_STA_ID1_PWR_SV;
		break;

#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		pcu_reg |= AR5K_AR5210_STA_ID1_ADHOC |
		    AR5K_AR5210_STA_ID1_NO_PSPOLL |
		    AR5K_AR5210_STA_ID1_DESC_ANTENNA;
		beacon_reg |= AR5K_AR5210_BCR_ADHOC;
		break;

	case IEEE80211_M_HOSTAP:
		pcu_reg |= AR5K_AR5210_STA_ID1_AP |
		    AR5K_AR5210_STA_ID1_NO_PSPOLL |
		    AR5K_AR5210_STA_ID1_DESC_ANTENNA;
		beacon_reg |= AR5K_AR5210_BCR_AP;
		break;
#endif

	case IEEE80211_M_MONITOR:
		pcu_reg |= AR5K_AR5210_STA_ID1_NO_PSPOLL;
		break;

	default:
		return;
	}

	/*
	 * Set PCU and BCR registers
	 */
	low_id = AR5K_LOW_ID(hal->ah_sta_id);
	high_id = AR5K_HIGH_ID(hal->ah_sta_id);
	AR5K_REG_WRITE(AR5K_AR5210_STA_ID0, low_id);
	AR5K_REG_WRITE(AR5K_AR5210_STA_ID1, pcu_reg | high_id);
	AR5K_REG_WRITE(AR5K_AR5210_BCR, beacon_reg);

	return;
}

HAL_BOOL
ar5k_ar5210_calibrate(struct ath_hal *hal, HAL_CHANNEL *channel)
{
	HAL_BOOL ret = AH_TRUE;
	u_int32_t phy_sig, phy_agc, phy_sat, beacon;

#define AGC_DISABLE	{						\
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_PHY_AGC,			\
	    AR5K_AR5210_PHY_AGC_DISABLE);				\
	AR5K_DELAY(10);							\
}

#define AGC_ENABLE	{						\
	AR5K_REG_DISABLE_BITS(AR5K_AR5210_PHY_AGC,			\
	    AR5K_AR5210_PHY_AGC_DISABLE);				\
}

	/*
	 * Disable beacons and RX/TX queues, wait
	 */
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_DIAG_SW,
	    AR5K_AR5210_DIAG_SW_DIS_TX | AR5K_AR5210_DIAG_SW_DIS_RX);
	beacon = AR5K_REG_READ(AR5K_AR5210_BEACON);
	AR5K_REG_WRITE(AR5K_AR5210_BEACON, beacon & ~AR5K_AR5210_BEACON_EN);

	AR5K_DELAY(2300);

	/*
	 * Set the channel (with AGC turned off)
	 */
	AGC_DISABLE;
	ret = ar5k_channel(hal, channel);

	/*
	 * Activate PHY and wait
	 */
	AR5K_REG_WRITE(AR5K_AR5210_PHY_ACTIVE, AR5K_AR5210_PHY_ENABLE);
	AR5K_DELAY(1000);

	AGC_ENABLE;

	if (ret == AH_FALSE)
		return (ret);

	/*
	 * Calibrate the radio chip
	 */

	/* Remember normal state */
	phy_sig = AR5K_REG_READ(AR5K_AR5210_PHY_SIG);
	phy_agc = AR5K_REG_READ(AR5K_AR5210_PHY_AGCCOARSE);
	phy_sat = AR5K_REG_READ(AR5K_AR5210_PHY_ADCSAT);

	/* Update radio registers */
	AR5K_REG_WRITE(AR5K_AR5210_PHY_SIG,
	    (phy_sig & ~(AR5K_AR5210_PHY_SIG_FIRPWR)) |
	    AR5K_REG_SM(-1, AR5K_AR5210_PHY_SIG_FIRPWR));

	AR5K_REG_WRITE(AR5K_AR5210_PHY_AGCCOARSE,
	    (phy_agc & ~(AR5K_AR5210_PHY_AGCCOARSE_HI |
		AR5K_AR5210_PHY_AGCCOARSE_LO)) |
	    AR5K_REG_SM(-1, AR5K_AR5210_PHY_AGCCOARSE_HI) |
	    AR5K_REG_SM(-127, AR5K_AR5210_PHY_AGCCOARSE_LO));

	AR5K_REG_WRITE(AR5K_AR5210_PHY_ADCSAT,
	    (phy_sat & ~(AR5K_AR5210_PHY_ADCSAT_ICNT |
		AR5K_AR5210_PHY_ADCSAT_THR)) |
	    AR5K_REG_SM(2, AR5K_AR5210_PHY_ADCSAT_ICNT) |
	    AR5K_REG_SM(12, AR5K_AR5210_PHY_ADCSAT_THR));

	AR5K_DELAY(20);

	AGC_DISABLE;
	AR5K_REG_WRITE(AR5K_AR5210_PHY_RFSTG, AR5K_AR5210_PHY_RFSTG_DISABLE);
	AGC_ENABLE;

	AR5K_DELAY(1000);

	ret = ar5k_ar5210_do_calibrate(hal, channel);

	/* Reset to normal state */
	AR5K_REG_WRITE(AR5K_AR5210_PHY_SIG, phy_sig);
	AR5K_REG_WRITE(AR5K_AR5210_PHY_AGCCOARSE, phy_agc);
	AR5K_REG_WRITE(AR5K_AR5210_PHY_ADCSAT, phy_sat);

	if (ret == AH_FALSE)
		return (AH_FALSE);

	if (ar5k_ar5210_noise_floor(hal, channel) == AH_FALSE)
		return (AH_FALSE);

	/*
	 * Re-enable RX/TX and beacons
	 */
	AR5K_REG_DISABLE_BITS(AR5K_AR5210_DIAG_SW,
	    AR5K_AR5210_DIAG_SW_DIS_TX | AR5K_AR5210_DIAG_SW_DIS_RX);
	AR5K_REG_WRITE(AR5K_AR5210_BEACON, beacon);

#undef AGC_ENABLE
#undef AGC_DISABLE

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_do_calibrate(struct ath_hal *hal, HAL_CHANNEL *channel)
{
	/*
	 * Enable calibration and wait until completion
	 */
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_PHY_AGCCTL,
	    AR5K_AR5210_PHY_AGCCTL_CAL);

	if (ar5k_register_timeout(hal, AR5K_AR5210_PHY_AGCCTL,
		AR5K_AR5210_PHY_AGCCTL_CAL, 0, AH_FALSE) == AH_FALSE) {
		AR5K_PRINTF("calibration timeout (%uMHz)\n",
		    channel->c_channel);
		return (AH_FALSE);
	}

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_noise_floor(struct ath_hal *hal, HAL_CHANNEL *channel)
{
	int i;
	u_int32_t noise_floor;

	/*
	 * Enable noise floor calibration and wait until completion
	 */
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_PHY_AGCCTL,
	    AR5K_AR5210_PHY_AGCCTL_NF);

	if (ar5k_register_timeout(hal, AR5K_AR5210_PHY_AGCCTL,
		AR5K_AR5210_PHY_AGCCTL_NF, 0, AH_FALSE) == AH_FALSE) {
		AR5K_PRINTF("noise floor calibration timeout (%uMHz)\n",
		    channel->c_channel);
		return (AH_FALSE);
	}

	/* wait until the noise floor is calibrated */
	for (i = 20; i > 0; i--) {
		AR5K_DELAY(1000);
		noise_floor = AR5K_REG_READ(AR5K_AR5210_PHY_NF);
		if (AR5K_AR5210_PHY_NF_RVAL(noise_floor) &
		    AR5K_AR5210_PHY_NF_ACTIVE)
			noise_floor = AR5K_AR5210_PHY_NF_AVAL(noise_floor);
		if (noise_floor <= AR5K_TUNE_NOISE_FLOOR)
			break;
	}

	if (noise_floor > AR5K_TUNE_NOISE_FLOOR) {
		AR5K_PRINTF("noise floor calibration failed (%uMHz)\n",
		    channel->c_channel);
		return (AH_FALSE);
	}

	return (AH_TRUE);
}

/*
 * Transmit functions
 */

HAL_BOOL
ar5k_ar5210_update_tx_triglevel(struct ath_hal *hal, HAL_BOOL increase)
{
	u_int32_t trigger_level;
	HAL_BOOL status = AH_FALSE;

	/*
	 * Disable interrupts by setting the mask
	 */
	AR5K_REG_DISABLE_BITS(AR5K_AR5210_IMR, HAL_INT_GLOBAL);

	trigger_level = AR5K_REG_READ(AR5K_AR5210_TRIG_LVL);

	if (increase == AH_FALSE) {
		if (--trigger_level < AR5K_TUNE_MIN_TX_FIFO_THRES)
			goto done;
	} else {
		trigger_level +=
		    ((AR5K_TUNE_MAX_TX_FIFO_THRES - trigger_level) / 2);
	}

	/*
	 * Update trigger level on success
	 */
	AR5K_REG_WRITE(AR5K_AR5210_TRIG_LVL, trigger_level);
	status = AH_TRUE;

 done:
	/*
	 * Restore interrupt mask
	 */
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_IMR, HAL_INT_GLOBAL);

	return (status);
}

int
ar5k_ar5210_setup_tx_queue(struct ath_hal *hal, HAL_TX_QUEUE queue_type,
    const HAL_TXQ_INFO *queue_info)
{
	u_int queue;

	/*
	 * Get queue by type
	 */
	switch (queue_type) {
	case HAL_TX_QUEUE_DATA:
		queue = 0;
		break;
	case HAL_TX_QUEUE_BEACON:
	case HAL_TX_QUEUE_CAB:
		queue = 1;
		break;
	default:
		return (-1);
	}

	/*
	 * Setup internal queue structure
	 */
	bzero(&hal->ah_txq[queue], sizeof(HAL_TXQ_INFO));
	hal->ah_txq[queue].tqi_type = queue_type;

	if (queue_info != NULL) {
		if (ar5k_ar5210_setup_tx_queueprops(hal,
			queue, queue_info) != AH_TRUE)
			return (-1);
	}

	return (queue);
}

HAL_BOOL
ar5k_ar5210_setup_tx_queueprops(struct ath_hal *hal, int queue,
    const HAL_TXQ_INFO *queue_info)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	if (hal->ah_txq[queue].tqi_type == HAL_TX_QUEUE_INACTIVE)
		return (AH_FALSE);

	hal->ah_txq[queue].tqi_aifs = queue_info->tqi_aifs;
	hal->ah_txq[queue].tqi_cw_max = queue_info->tqi_cw_max;
	hal->ah_txq[queue].tqi_cw_min = queue_info->tqi_cw_min;
	hal->ah_txq[queue].tqi_flags = queue_info->tqi_flags;

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_get_tx_queueprops(struct ath_hal *hal, int queue,
    HAL_TXQ_INFO *queue_info)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);
	bcopy(&hal->ah_txq[queue], queue_info, sizeof(HAL_TXQ_INFO));
	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_release_tx_queue(struct ath_hal *hal, u_int queue)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	/* This queue will be skipped in further operations */
	hal->ah_txq[queue].tqi_type = HAL_TX_QUEUE_INACTIVE;

	return (AH_FALSE);
}

void
ar5k_ar5210_init_tx_queue(struct ath_hal *hal, u_int aifs)
{
	int i;
	struct {
		u_int16_t mode_register;
		u_int32_t mode_base;
	} initial[] = AR5K_AR5210_INI_MODE(aifs);

	/*
	 * Write initial mode register settings
	 */
	for (i = 0; i < nitems(initial); i++)
		AR5K_REG_WRITE((u_int32_t)initial[i].mode_register,
		    initial[i].mode_base);
}

HAL_BOOL
ar5k_ar5210_reset_tx_queue(struct ath_hal *hal, u_int queue)
{
	u_int32_t cw_min, retry_lg, retry_sh;
	HAL_TXQ_INFO *tq;

	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	tq = &hal->ah_txq[queue];

	/* Only handle data queues, others will be ignored */
	if (tq->tqi_type != HAL_TX_QUEUE_DATA)
		return (AH_TRUE);

	/* Set turbo/base mode parameters */
	ar5k_ar5210_init_tx_queue(hal, hal->ah_aifs + tq->tqi_aifs);

	/*
	 * Set retry limits
	 */
	if (hal->ah_software_retry == AH_TRUE) {
		/* XXX Need to test this */
		retry_lg = hal->ah_limit_tx_retries;
		retry_sh = retry_lg =
		    retry_lg > AR5K_AR5210_RETRY_LMT_SH_RETRY ?
		    AR5K_AR5210_RETRY_LMT_SH_RETRY : retry_lg;
	} else {
		retry_lg = AR5K_INIT_LG_RETRY;
		retry_sh = AR5K_INIT_SH_RETRY;
	}

	/*
	 * Set initial content window (cw_min/cw_max)
	 */
	cw_min = 1;
	while (cw_min < hal->ah_cw_min)
		cw_min = (cw_min << 1) | 1;

	cw_min = tq->tqi_cw_min < 0 ?
	    (cw_min >> (-tq->tqi_cw_min)) :
	    ((cw_min << tq->tqi_cw_min) + (1 << tq->tqi_cw_min) - 1);

	/* Commit values */
	AR5K_REG_WRITE(AR5K_AR5210_RETRY_LMT,
	    (cw_min << AR5K_AR5210_RETRY_LMT_CW_MIN_S)
	    | AR5K_REG_SM(AR5K_INIT_SLG_RETRY, AR5K_AR5210_RETRY_LMT_SLG_RETRY)
	    | AR5K_REG_SM(AR5K_INIT_SSH_RETRY, AR5K_AR5210_RETRY_LMT_SSH_RETRY)
	    | AR5K_REG_SM(retry_lg, AR5K_AR5210_RETRY_LMT_LG_RETRY)
	    | AR5K_REG_SM(retry_sh, AR5K_AR5210_RETRY_LMT_SH_RETRY));

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5210_get_tx_buf(struct ath_hal *hal, u_int queue)
{
	u_int16_t tx_reg;

	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	/*
	 * Get the transmit queue descriptor pointer register by type
	 */
	switch (hal->ah_txq[queue].tqi_type) {
	case HAL_TX_QUEUE_DATA:
		tx_reg = AR5K_AR5210_TXDP0;
		break;
	case HAL_TX_QUEUE_BEACON:
	case HAL_TX_QUEUE_CAB:
		tx_reg = AR5K_AR5210_TXDP1;
		break;
	default:
		return (0xffffffff);
	}

	return (AR5K_REG_READ(tx_reg));
}

HAL_BOOL
ar5k_ar5210_put_tx_buf(struct ath_hal *hal, u_int queue, u_int32_t phys_addr)
{
	u_int16_t tx_reg;

	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	/*
	 * Get the transmit queue descriptor pointer register by type
	 */
	switch (hal->ah_txq[queue].tqi_type) {
	case HAL_TX_QUEUE_DATA:
		tx_reg = AR5K_AR5210_TXDP0;
		break;
	case HAL_TX_QUEUE_BEACON:
	case HAL_TX_QUEUE_CAB:
		tx_reg = AR5K_AR5210_TXDP1;
		break;
	default:
		return (AH_FALSE);
	}

	/* Set descriptor pointer */
	AR5K_REG_WRITE(tx_reg, phys_addr);

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5210_num_tx_pending(struct ath_hal *hal, u_int queue)
{
	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5210_tx_start(struct ath_hal *hal, u_int queue)
{
	u_int32_t tx_queue;

	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	tx_queue = AR5K_REG_READ(AR5K_AR5210_CR);

	/*
	 * Set the queue type
	 */
	switch (hal->ah_txq[queue].tqi_type) {
	case HAL_TX_QUEUE_DATA:
		tx_queue |= AR5K_AR5210_CR_TXE0 & ~AR5K_AR5210_CR_TXD0;
		break;

	case HAL_TX_QUEUE_BEACON:
		tx_queue |= AR5K_AR5210_CR_TXE1 & ~AR5K_AR5210_CR_TXD1;
		AR5K_REG_WRITE(AR5K_AR5210_BSR,
		    AR5K_AR5210_BCR_TQ1V | AR5K_AR5210_BCR_BDMAE);
		break;

	case HAL_TX_QUEUE_CAB:
		tx_queue |= AR5K_AR5210_CR_TXE1 & ~AR5K_AR5210_CR_TXD1;
		AR5K_REG_WRITE(AR5K_AR5210_BSR,
		    AR5K_AR5210_BCR_TQ1FV | AR5K_AR5210_BCR_TQ1V |
		    AR5K_AR5210_BCR_BDMAE);
		break;

	default:
		return (AH_FALSE);
	}

	/* Start queue */
	AR5K_REG_WRITE(AR5K_AR5210_CR, tx_queue);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_stop_tx_dma(struct ath_hal *hal, u_int queue)
{
	u_int32_t tx_queue;

	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);

	tx_queue = AR5K_REG_READ(AR5K_AR5210_CR);

	/*
	 * Set by queue type
	 */
	switch (hal->ah_txq[queue].tqi_type) {
	case HAL_TX_QUEUE_DATA:
		tx_queue |= AR5K_AR5210_CR_TXD0 & ~AR5K_AR5210_CR_TXE0;
		break;

	case HAL_TX_QUEUE_BEACON:
	case HAL_TX_QUEUE_CAB:
		/* XXX Fix me... */
		tx_queue |= AR5K_AR5210_CR_TXD1 & ~AR5K_AR5210_CR_TXD1;
		AR5K_REG_WRITE(AR5K_AR5210_BSR, 0);
		break;

	default:
		return (AH_FALSE);
	}

	/* Stop queue */
	AR5K_REG_WRITE(AR5K_AR5210_CR, tx_queue);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_setup_tx_desc(struct ath_hal *hal, struct ath_desc *desc,
    u_int packet_length, u_int header_length, HAL_PKT_TYPE type, u_int tx_power,
    u_int tx_rate0, u_int tx_tries0, u_int key_index, u_int antenna_mode,
    u_int flags, u_int rtscts_rate, u_int rtscts_duration)
{
	u_int32_t frame_type;
	struct ar5k_ar5210_tx_desc *tx_desc;

	tx_desc = (struct ar5k_ar5210_tx_desc*)&desc->ds_ctl0;

	/*
	 * Validate input
	 */
	if (tx_tries0 == 0)
		return (AH_FALSE);

	if ((tx_desc->tx_control_0 = (packet_length &
	    AR5K_AR5210_DESC_TX_CTL0_FRAME_LEN)) != packet_length)
		return (AH_FALSE);

	if ((tx_desc->tx_control_0 = (header_length &
	    AR5K_AR5210_DESC_TX_CTL0_HEADER_LEN)) != header_length)
		return (AH_FALSE);

	if (type == HAL_PKT_TYPE_BEACON || type == HAL_PKT_TYPE_PROBE_RESP)
		frame_type = AR5K_AR5210_DESC_TX_FRAME_TYPE_NO_DELAY;
	else if (type == HAL_PKT_TYPE_PIFS)
		frame_type = AR5K_AR5210_DESC_TX_FRAME_TYPE_PIFS;
	else
		frame_type = type;

	tx_desc->tx_control_0 =
	    AR5K_REG_SM(frame_type, AR5K_AR5210_DESC_TX_CTL0_FRAME_TYPE);
	tx_desc->tx_control_0 |=
	    AR5K_REG_SM(tx_rate0, AR5K_AR5210_DESC_TX_CTL0_XMIT_RATE);

#define _TX_FLAGS(_c, _flag)						\
	if (flags & HAL_TXDESC_##_flag)					\
		tx_desc->tx_control_##_c |=				\
			AR5K_AR5210_DESC_TX_CTL##_c##_##_flag

	_TX_FLAGS(0, CLRDMASK);
	_TX_FLAGS(0, INTREQ);
	_TX_FLAGS(0, RTSENA);

#undef _TX_FLAGS

	/*
	 * WEP crap
	 */
	if (key_index != HAL_TXKEYIX_INVALID) {
		tx_desc->tx_control_0 |=
		    AR5K_AR5210_DESC_TX_CTL0_ENCRYPT_KEY_VALID;
		tx_desc->tx_control_1 |=
		    AR5K_REG_SM(key_index,
		    AR5K_AR5210_DESC_TX_CTL1_ENCRYPT_KEY_INDEX);
	}

	/*
	 * RTS/CTS
	 */
	if (flags & (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA)) {
		tx_desc->tx_control_1 |=
		    rtscts_duration & AR5K_AR5210_DESC_TX_CTL1_RTS_DURATION;
	}

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_fill_tx_desc(struct ath_hal *hal, struct ath_desc *desc,
    u_int segment_length, HAL_BOOL first_segment, HAL_BOOL last_segment)
{
	struct ar5k_ar5210_tx_desc *tx_desc;

	tx_desc = (struct ar5k_ar5210_tx_desc*)&desc->ds_ctl0;

	/* Clear status descriptor */
	bzero(desc->ds_hw, sizeof(desc->ds_hw));

	/* Validate segment length and initialize the descriptor */
	if (segment_length & ~AR5K_AR5210_DESC_TX_CTL1_BUF_LEN)
		return (AH_FALSE);
	tx_desc->tx_control_1 =
#if 0
	    (tx_desc->tx_control_1 & ~AR5K_AR5210_DESC_TX_CTL1_BUF_LEN) |
#endif
	    segment_length;

	if (first_segment != AH_TRUE)
		tx_desc->tx_control_0 &= ~AR5K_AR5210_DESC_TX_CTL0_FRAME_LEN;

	if (last_segment != AH_TRUE)
		tx_desc->tx_control_1 |= AR5K_AR5210_DESC_TX_CTL1_MORE;

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_setup_xtx_desc(struct ath_hal *hal, struct ath_desc *desc,
    u_int tx_rate1, u_int tx_tries1, u_int tx_rate2, u_int tx_tries2,
    u_int tx_rate3, u_int tx_tries3)
{
	/*
	 * Does this function is for setting up XR? Not sure...
	 * Nevertheless, I didn't find any information about XR support
	 * by the AR5210. This seems to be a slightly new feature.
	 */
	return (AH_FALSE);
}

HAL_STATUS
ar5k_ar5210_proc_tx_desc(struct ath_hal *hal, struct ath_desc *desc)
{
	struct ar5k_ar5210_tx_status *tx_status;
	struct ar5k_ar5210_tx_desc *tx_desc;

	tx_desc = (struct ar5k_ar5210_tx_desc*)&desc->ds_ctl0;
	tx_status = (struct ar5k_ar5210_tx_status*)&desc->ds_hw[0];

	/* No frame has been send or error */
	if ((tx_status->tx_status_1 & AR5K_AR5210_DESC_TX_STATUS1_DONE) == 0)
		return (HAL_EINPROGRESS);

	/*
	 * Get descriptor status
	 */
	desc->ds_us.tx.ts_tstamp =
	    AR5K_REG_MS(tx_status->tx_status_0,
	    AR5K_AR5210_DESC_TX_STATUS0_SEND_TIMESTAMP);
	desc->ds_us.tx.ts_shortretry =
	    AR5K_REG_MS(tx_status->tx_status_0,
	    AR5K_AR5210_DESC_TX_STATUS0_SHORT_RETRY_COUNT);
	desc->ds_us.tx.ts_longretry =
	    AR5K_REG_MS(tx_status->tx_status_0,
	    AR5K_AR5210_DESC_TX_STATUS0_LONG_RETRY_COUNT);
	desc->ds_us.tx.ts_seqnum =
	    AR5K_REG_MS(tx_status->tx_status_1,
	    AR5K_AR5210_DESC_TX_STATUS1_SEQ_NUM);
	desc->ds_us.tx.ts_rssi =
	    AR5K_REG_MS(tx_status->tx_status_1,
	    AR5K_AR5210_DESC_TX_STATUS1_ACK_SIG_STRENGTH);
	desc->ds_us.tx.ts_antenna = 1;
	desc->ds_us.tx.ts_status = 0;
	desc->ds_us.tx.ts_rate =
	    AR5K_REG_MS(tx_desc->tx_control_0,
	    AR5K_AR5210_DESC_TX_CTL0_XMIT_RATE);

	if ((tx_status->tx_status_0 &
	    AR5K_AR5210_DESC_TX_STATUS0_FRAME_XMIT_OK) == 0) {
		if (tx_status->tx_status_0 &
		    AR5K_AR5210_DESC_TX_STATUS0_EXCESSIVE_RETRIES)
			desc->ds_us.tx.ts_status |= HAL_TXERR_XRETRY;

		if (tx_status->tx_status_0 &
		    AR5K_AR5210_DESC_TX_STATUS0_FIFO_UNDERRUN)
			desc->ds_us.tx.ts_status |= HAL_TXERR_FIFO;

		if (tx_status->tx_status_0 &
		    AR5K_AR5210_DESC_TX_STATUS0_FILTERED)
			desc->ds_us.tx.ts_status |= HAL_TXERR_FILT;
	}

	return (HAL_OK);
}

HAL_BOOL
ar5k_ar5210_has_veol(struct ath_hal *hal)
{
	return (AH_FALSE);
}

/*
 * Receive functions
 */

u_int32_t
ar5k_ar5210_get_rx_buf(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5210_RXDP));
}

void
ar5k_ar5210_put_rx_buf(struct ath_hal *hal, u_int32_t phys_addr)
{
	AR5K_REG_WRITE(AR5K_AR5210_RXDP, phys_addr);
}

void
ar5k_ar5210_start_rx(struct ath_hal *hal)
{
	AR5K_REG_WRITE(AR5K_AR5210_CR, AR5K_AR5210_CR_RXE);
}

HAL_BOOL
ar5k_ar5210_stop_rx_dma(struct ath_hal *hal)
{
	int i;

	AR5K_REG_WRITE(AR5K_AR5210_CR, AR5K_AR5210_CR_RXD);

	/*
	 * It may take some time to disable the DMA receive unit
	 */
	for (i = 2000;
	     i > 0 && (AR5K_REG_READ(AR5K_AR5210_CR) & AR5K_AR5210_CR_RXE) != 0;
	     i--)
		AR5K_DELAY(10);

	return (i > 0 ? AH_TRUE : AH_FALSE);
}

void
ar5k_ar5210_start_rx_pcu(struct ath_hal *hal)
{
	AR5K_REG_DISABLE_BITS(AR5K_AR5210_DIAG_SW, AR5K_AR5210_DIAG_SW_DIS_RX);
}

void
ar5k_ar5210_stop_pcu_recv(struct ath_hal *hal)
{
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_DIAG_SW, AR5K_AR5210_DIAG_SW_DIS_RX);
}

void
ar5k_ar5210_set_mcast_filter(struct ath_hal *hal, u_int32_t filter0,
    u_int32_t filter1)
{
	/* Set the multicat filter */
	AR5K_REG_WRITE(AR5K_AR5210_MCAST_FIL0, filter0);
	AR5K_REG_WRITE(AR5K_AR5210_MCAST_FIL1, filter1);
}

HAL_BOOL
ar5k_ar5210_set_mcast_filterindex(struct ath_hal *hal, u_int32_t index)
{
	if (index >= 64) {
		return (AH_FALSE);
	} else if (index >= 32) {
		AR5K_REG_ENABLE_BITS(AR5K_AR5210_MCAST_FIL1,
		    (1 << (index - 32)));
	} else {
		AR5K_REG_ENABLE_BITS(AR5K_AR5210_MCAST_FIL0,
		    (1 << index));
	}

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_clear_mcast_filter_idx(struct ath_hal *hal, u_int32_t index)
{
	if (index >= 64) {
		return (AH_FALSE);
	} else if (index >= 32) {
		AR5K_REG_DISABLE_BITS(AR5K_AR5210_MCAST_FIL1,
		    (1 << (index - 32)));
	} else {
		AR5K_REG_DISABLE_BITS(AR5K_AR5210_MCAST_FIL0,
		    (1 << index));
	}

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5210_get_rx_filter(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5210_RX_FILTER));
}

void
ar5k_ar5210_set_rx_filter(struct ath_hal *hal, u_int32_t filter)
{
	/*
	 * The AR5210 uses promiscous mode to detect radar activity
	 */
	if (filter & HAL_RX_FILTER_PHYRADAR) {
		filter &= ~HAL_RX_FILTER_PHYRADAR;
		filter |= AR5K_AR5210_RX_FILTER_PROMISC;
	}

	AR5K_REG_WRITE(AR5K_AR5210_RX_FILTER, filter);
}

HAL_BOOL
ar5k_ar5210_setup_rx_desc(struct ath_hal *hal, struct ath_desc *desc,
    u_int32_t size, u_int flags)
{
	struct ar5k_ar5210_rx_desc *rx_desc;

	rx_desc = (struct ar5k_ar5210_rx_desc*)&desc->ds_ctl0;

	if ((rx_desc->rx_control_1 = (size &
	    AR5K_AR5210_DESC_RX_CTL1_BUF_LEN)) != size)
		return (AH_FALSE);

	if (flags & HAL_RXDESC_INTREQ)
		rx_desc->rx_control_1 |= AR5K_AR5210_DESC_RX_CTL1_INTREQ;

	return (AH_TRUE);
}

HAL_STATUS
ar5k_ar5210_proc_rx_desc(struct ath_hal *hal, struct ath_desc *desc,
    u_int32_t phys_addr, struct ath_desc *next)
{
	struct ar5k_ar5210_rx_status *rx_status;

	rx_status = (struct ar5k_ar5210_rx_status*)&desc->ds_hw[0];

	/* No frame received / not ready */
	if ((rx_status->rx_status_1 & AR5K_AR5210_DESC_RX_STATUS1_DONE) == 0)
		return (HAL_EINPROGRESS);

	/*
	 * Frame receive status
	 */
	desc->ds_us.rx.rs_datalen = rx_status->rx_status_0 &
	    AR5K_AR5210_DESC_RX_STATUS0_DATA_LEN;
	desc->ds_us.rx.rs_rssi =
	    AR5K_REG_MS(rx_status->rx_status_0,
	    AR5K_AR5210_DESC_RX_STATUS0_RECEIVE_SIGNAL);
	desc->ds_us.rx.rs_rate =
	    AR5K_REG_MS(rx_status->rx_status_0,
	    AR5K_AR5210_DESC_RX_STATUS0_RECEIVE_RATE);
	desc->ds_us.rx.rs_antenna = rx_status->rx_status_0 &
	    AR5K_AR5210_DESC_RX_STATUS0_RECEIVE_ANTENNA;
	desc->ds_us.rx.rs_more = rx_status->rx_status_0 &
	    AR5K_AR5210_DESC_RX_STATUS0_MORE;
	desc->ds_us.rx.rs_tstamp =
	    AR5K_REG_MS(rx_status->rx_status_1,
	    AR5K_AR5210_DESC_RX_STATUS1_RECEIVE_TIMESTAMP);
	desc->ds_us.rx.rs_status = 0;

	/*
	 * Key table status
	 */
	if (rx_status->rx_status_1 &
	    AR5K_AR5210_DESC_RX_STATUS1_KEY_INDEX_VALID) {
		desc->ds_us.rx.rs_keyix =
		    AR5K_REG_MS(rx_status->rx_status_1,
		    AR5K_AR5210_DESC_RX_STATUS1_KEY_INDEX);
	} else {
		desc->ds_us.rx.rs_keyix = HAL_RXKEYIX_INVALID;
	}

	/*
	 * Receive/descriptor errors
	 */
	if ((rx_status->rx_status_1 &
	    AR5K_AR5210_DESC_RX_STATUS1_FRAME_RECEIVE_OK) == 0) {
		if (rx_status->rx_status_1 &
		    AR5K_AR5210_DESC_RX_STATUS1_CRC_ERROR)
			desc->ds_us.rx.rs_status |= HAL_RXERR_CRC;

		if (rx_status->rx_status_1 &
		    AR5K_AR5210_DESC_RX_STATUS1_FIFO_OVERRUN)
			desc->ds_us.rx.rs_status |= HAL_RXERR_FIFO;

		if (rx_status->rx_status_1 &
		    AR5K_AR5210_DESC_RX_STATUS1_PHY_ERROR) {
			desc->ds_us.rx.rs_status |= HAL_RXERR_PHY;
			desc->ds_us.rx.rs_phyerr =
			    AR5K_REG_MS(rx_status->rx_status_1,
			    AR5K_AR5210_DESC_RX_STATUS1_PHY_ERROR);
		}

		if (rx_status->rx_status_1 &
		    AR5K_AR5210_DESC_RX_STATUS1_DECRYPT_CRC_ERROR)
			desc->ds_us.rx.rs_status |= HAL_RXERR_DECRYPT;
	}

	return (HAL_OK);
}

void
ar5k_ar5210_set_rx_signal(struct ath_hal *hal)
{
	/* Signal state monitoring is not yet supported */
}

/*
 * Misc functions
 */

void
ar5k_ar5210_dump_state(struct ath_hal *hal)
{
#ifdef AR5K_DEBUG
#define AR5K_PRINT_REGISTER(_x)						\
	printf("(%s: %08x) ", #_x, AR5K_REG_READ(AR5K_AR5210_##_x));

	printf("DMA registers:\n");
	AR5K_PRINT_REGISTER(TXDP0);
	AR5K_PRINT_REGISTER(TXDP1);
	AR5K_PRINT_REGISTER(CR);
	AR5K_PRINT_REGISTER(RXDP);
	AR5K_PRINT_REGISTER(CFG);
	AR5K_PRINT_REGISTER(ISR);
	AR5K_PRINT_REGISTER(IMR);
	AR5K_PRINT_REGISTER(IER);
	AR5K_PRINT_REGISTER(BCR);
	AR5K_PRINT_REGISTER(BSR);
	AR5K_PRINT_REGISTER(TXCFG);
	AR5K_PRINT_REGISTER(RXCFG);
	AR5K_PRINT_REGISTER(MIBC);
	AR5K_PRINT_REGISTER(TOPS);
	AR5K_PRINT_REGISTER(RXNOFRM);
	AR5K_PRINT_REGISTER(TXNOFRM);
	AR5K_PRINT_REGISTER(RPGTO);
	AR5K_PRINT_REGISTER(RFCNT);
	AR5K_PRINT_REGISTER(MISC);
	AR5K_PRINT_REGISTER(RC);
	AR5K_PRINT_REGISTER(SCR);
	AR5K_PRINT_REGISTER(INTPEND);
	AR5K_PRINT_REGISTER(SFR);
	AR5K_PRINT_REGISTER(PCICFG);
	AR5K_PRINT_REGISTER(GPIOCR);
	AR5K_PRINT_REGISTER(GPIODO);
	AR5K_PRINT_REGISTER(GPIODI);
	AR5K_PRINT_REGISTER(SREV);
	printf("\n");

	printf("PCU registers:\n");
	AR5K_PRINT_REGISTER(STA_ID0);
	AR5K_PRINT_REGISTER(STA_ID1);
	AR5K_PRINT_REGISTER(BSS_ID0);
	AR5K_PRINT_REGISTER(BSS_ID1);
	AR5K_PRINT_REGISTER(SLOT_TIME);
	AR5K_PRINT_REGISTER(TIME_OUT);
	AR5K_PRINT_REGISTER(RSSI_THR);
	AR5K_PRINT_REGISTER(RETRY_LMT);
	AR5K_PRINT_REGISTER(USEC);
	AR5K_PRINT_REGISTER(BEACON);
	AR5K_PRINT_REGISTER(CFP_PERIOD);
	AR5K_PRINT_REGISTER(TIMER0);
	AR5K_PRINT_REGISTER(TIMER1);
	AR5K_PRINT_REGISTER(TIMER2);
	AR5K_PRINT_REGISTER(TIMER3);
	AR5K_PRINT_REGISTER(IFS0);
	AR5K_PRINT_REGISTER(IFS1);
	AR5K_PRINT_REGISTER(CFP_DUR);
	AR5K_PRINT_REGISTER(RX_FILTER);
	AR5K_PRINT_REGISTER(MCAST_FIL0);
	AR5K_PRINT_REGISTER(MCAST_FIL1);
	AR5K_PRINT_REGISTER(TX_MASK0);
	AR5K_PRINT_REGISTER(TX_MASK1);
	AR5K_PRINT_REGISTER(CLR_TMASK);
	AR5K_PRINT_REGISTER(TRIG_LVL);
	AR5K_PRINT_REGISTER(DIAG_SW);
	AR5K_PRINT_REGISTER(TSF_L32);
	AR5K_PRINT_REGISTER(TSF_U32);
	AR5K_PRINT_REGISTER(LAST_TSTP);
	AR5K_PRINT_REGISTER(RETRY_CNT);
	AR5K_PRINT_REGISTER(BACKOFF);
	AR5K_PRINT_REGISTER(NAV);
	AR5K_PRINT_REGISTER(RTS_OK);
	AR5K_PRINT_REGISTER(RTS_FAIL);
	AR5K_PRINT_REGISTER(ACK_FAIL);
	AR5K_PRINT_REGISTER(FCS_FAIL);
	AR5K_PRINT_REGISTER(BEACON_CNT);
	AR5K_PRINT_REGISTER(KEYTABLE_0);
	printf("\n");

	printf("PHY registers:\n");
	AR5K_PRINT_REGISTER(PHY(0));
	AR5K_PRINT_REGISTER(PHY_FC);
	AR5K_PRINT_REGISTER(PHY_AGC);
	AR5K_PRINT_REGISTER(PHY_CHIP_ID);
	AR5K_PRINT_REGISTER(PHY_ACTIVE);
	AR5K_PRINT_REGISTER(PHY_AGCCTL);
	printf("\n");
#endif
}

HAL_BOOL
ar5k_ar5210_get_diag_state(struct ath_hal *hal, int id, void **device,
    u_int *size)
{
	/*
	 * We'll ignore this right now. This seems to be some kind of an obscure
         * debugging interface for the binary-only HAL.
	 */
	return (AH_FALSE);
}

void
ar5k_ar5210_get_lladdr(struct ath_hal *hal, u_int8_t *mac)
{
	bcopy(hal->ah_sta_id, mac, IEEE80211_ADDR_LEN);
}

HAL_BOOL
ar5k_ar5210_set_lladdr(struct ath_hal *hal, const u_int8_t *mac)
{
	u_int32_t low_id, high_id;

	/* Set new station ID */
	bcopy(mac, hal->ah_sta_id, IEEE80211_ADDR_LEN);

	low_id = AR5K_LOW_ID(mac);
	high_id = 0x0000ffff & AR5K_HIGH_ID(mac);

	AR5K_REG_WRITE(AR5K_AR5210_STA_ID0, low_id);
	AR5K_REG_WRITE(AR5K_AR5210_STA_ID1, high_id);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_set_regdomain(struct ath_hal *hal, u_int16_t regdomain,
    HAL_STATUS *status)
{
	ieee80211_regdomain_t ieee_regdomain;

	ieee_regdomain = ar5k_regdomain_to_ieee(regdomain);

	if (ar5k_eeprom_regulation_domain(hal, AH_TRUE,
		&ieee_regdomain) == AH_TRUE) {
		*status = HAL_OK;
		return (AH_TRUE);
	}

	*status = EIO;

	return (AH_FALSE);
}

void
ar5k_ar5210_set_ledstate(struct ath_hal *hal, HAL_LED_STATE state)
{
	u_int32_t led;

	led = AR5K_REG_READ(AR5K_AR5210_PCICFG);

	/*
	 * Some blinking values, define at your wish
	 */
	switch (state) {
	case IEEE80211_S_SCAN:
	case IEEE80211_S_INIT:
		led |=
		    AR5K_AR5210_PCICFG_LED_PEND |
		    AR5K_AR5210_PCICFG_LED_BCTL;
		break;
	case IEEE80211_S_RUN:
		led |=
		    AR5K_AR5210_PCICFG_LED_ACT;
		break;
	default:
		led |=
		    AR5K_AR5210_PCICFG_LED_ACT |
		    AR5K_AR5210_PCICFG_LED_BCTL;
		break;
	}

	AR5K_REG_WRITE(AR5K_AR5210_PCICFG, led);
}

void
ar5k_ar5210_set_associd(struct ath_hal *hal, const u_int8_t *bssid,
    u_int16_t assoc_id, u_int16_t tim_offset)
{
	u_int32_t low_id, high_id;

	/*
	 * Set BSSID which triggers the "SME Join" operation
	 */
	low_id = AR5K_LOW_ID(bssid);
	high_id = AR5K_HIGH_ID(bssid);
	AR5K_REG_WRITE(AR5K_AR5210_BSS_ID0, low_id);
	AR5K_REG_WRITE(AR5K_AR5210_BSS_ID1, high_id |
	    ((assoc_id & 0x3fff) << AR5K_AR5210_BSS_ID1_AID_S));
	bcopy(bssid, &hal->ah_bssid, IEEE80211_ADDR_LEN);

	if (assoc_id == 0) {
		ar5k_ar5210_disable_pspoll(hal);
		return;
	}

	AR5K_REG_WRITE_BITS(AR5K_AR5210_BEACON, AR5K_AR5210_BEACON_TIM,
	    tim_offset ? tim_offset + 4 : 0);

	ar5k_ar5210_enable_pspoll(hal, NULL, 0);
}

HAL_BOOL
ar5k_ar5210_set_bssid_mask(struct ath_hal *hal, const u_int8_t* mask)
{
	/* Not supported in 5210 */
	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5210_set_gpio_output(struct ath_hal *hal, u_int32_t gpio)
{
	if (gpio > AR5K_AR5210_NUM_GPIO)
		return (AH_FALSE);

	AR5K_REG_WRITE(AR5K_AR5210_GPIOCR,
	    (AR5K_REG_READ(AR5K_AR5210_GPIOCR) &~ AR5K_AR5210_GPIOCR_ALL(gpio))
	    | AR5K_AR5210_GPIOCR_OUT1(gpio));

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_set_gpio_input(struct ath_hal *hal, u_int32_t gpio)
{
	if (gpio > AR5K_AR5210_NUM_GPIO)
		return (AH_FALSE);

	AR5K_REG_WRITE(AR5K_AR5210_GPIOCR,
	    (AR5K_REG_READ(AR5K_AR5210_GPIOCR) &~ AR5K_AR5210_GPIOCR_ALL(gpio))
	    | AR5K_AR5210_GPIOCR_IN(gpio));

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5210_get_gpio(struct ath_hal *hal, u_int32_t gpio)
{
	if (gpio > AR5K_AR5210_NUM_GPIO)
		return (0xffffffff);

	/* GPIO input magic */
	return (((AR5K_REG_READ(AR5K_AR5210_GPIODI) &
		     AR5K_AR5210_GPIOD_MASK) >> gpio) & 0x1);
}

HAL_BOOL
ar5k_ar5210_set_gpio(struct ath_hal *hal, u_int32_t gpio, u_int32_t val)
{
	u_int32_t data;

	if (gpio > AR5K_AR5210_NUM_GPIO)
		return (0xffffffff);

	/* GPIO output magic */
	data =  AR5K_REG_READ(AR5K_AR5210_GPIODO);

	data &= ~(1 << gpio);
	data |= (val&1) << gpio;

	AR5K_REG_WRITE(AR5K_AR5210_GPIODO, data);

	return (AH_TRUE);
}

void
ar5k_ar5210_set_gpio_intr(struct ath_hal *hal, u_int gpio,
    u_int32_t interrupt_level)
{
	u_int32_t data;

	if (gpio > AR5K_AR5210_NUM_GPIO)
		return;

	/*
	 * Set the GPIO interrupt
	 */
	data = (AR5K_REG_READ(AR5K_AR5210_GPIOCR) &
	    ~(AR5K_AR5210_GPIOCR_INT_SEL(gpio) | AR5K_AR5210_GPIOCR_INT_SELH |
		AR5K_AR5210_GPIOCR_INT_ENA | AR5K_AR5210_GPIOCR_ALL(gpio))) |
	    (AR5K_AR5210_GPIOCR_INT_SEL(gpio) | AR5K_AR5210_GPIOCR_INT_ENA);

	AR5K_REG_WRITE(AR5K_AR5210_GPIOCR,
	    interrupt_level ? data : (data | AR5K_AR5210_GPIOCR_INT_SELH));

	hal->ah_imr |= AR5K_AR5210_IMR_GPIO;

	/* Enable GPIO interrupts */
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_IMR, AR5K_AR5210_IMR_GPIO);
}

u_int32_t
ar5k_ar5210_get_tsf32(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5210_TSF_L32));
}

u_int64_t
ar5k_ar5210_get_tsf64(struct ath_hal *hal)
{
	u_int64_t tsf = AR5K_REG_READ(AR5K_AR5210_TSF_U32);
	return (AR5K_REG_READ(AR5K_AR5210_TSF_L32) | (tsf << 32));
}

void
ar5k_ar5210_reset_tsf(struct ath_hal *hal)
{
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_BEACON,
	    AR5K_AR5210_BEACON_RESET_TSF);
}

u_int16_t
ar5k_ar5210_get_regdomain(struct ath_hal *hal)
{
	return (ar5k_get_regdomain(hal));
}

HAL_BOOL
ar5k_ar5210_detect_card_present(struct ath_hal *hal)
{
	u_int16_t magic;

	/*
	 * Checking the EEPROM's magic value could be an indication
	 * if the card is still present. I didn't find another suitable
	 * way to do this.
	 */
	if (ar5k_ar5210_eeprom_read(hal, AR5K_EEPROM_MAGIC, &magic) != 0)
		return (AH_FALSE);

	return (magic == AR5K_EEPROM_MAGIC_VALUE ? AH_TRUE : AH_FALSE);
}

void
ar5k_ar5210_update_mib_counters(struct ath_hal *hal, HAL_MIB_STATS *statistics)
{
	statistics->ackrcv_bad += AR5K_REG_READ(AR5K_AR5210_ACK_FAIL);
	statistics->rts_bad += AR5K_REG_READ(AR5K_AR5210_RTS_FAIL);
	statistics->rts_good += AR5K_REG_READ(AR5K_AR5210_RTS_OK);
	statistics->fcs_bad += AR5K_REG_READ(AR5K_AR5210_FCS_FAIL);
	statistics->beacons += AR5K_REG_READ(AR5K_AR5210_BEACON_CNT);
}

HAL_RFGAIN
ar5k_ar5210_get_rf_gain(struct ath_hal *hal)
{
	return (HAL_RFGAIN_INACTIVE);
}

HAL_BOOL
ar5k_ar5210_set_slot_time(struct ath_hal *hal, u_int slot_time)
{
	if (slot_time < HAL_SLOT_TIME_9 || slot_time > HAL_SLOT_TIME_MAX)
		return (AH_FALSE);

	AR5K_REG_WRITE(AR5K_AR5210_SLOT_TIME, ar5k_htoclock(slot_time));

	return (AH_TRUE);
}

u_int
ar5k_ar5210_get_slot_time(struct ath_hal *hal)
{
	return (ar5k_clocktoh(AR5K_REG_READ(AR5K_AR5210_SLOT_TIME) & 0xffff));
}

HAL_BOOL
ar5k_ar5210_set_ack_timeout(struct ath_hal *hal, u_int timeout)
{
	if (ar5k_clocktoh(AR5K_REG_MS(0xffffffff, AR5K_AR5210_TIME_OUT_ACK))
		<= timeout)
		return (AH_FALSE);

	AR5K_REG_WRITE_BITS(AR5K_AR5210_TIME_OUT, AR5K_AR5210_TIME_OUT_ACK,
	    ar5k_htoclock(timeout));

	return (AH_TRUE);
}

u_int
ar5k_ar5210_get_ack_timeout(struct ath_hal *hal)
{
	return (ar5k_clocktoh(AR5K_REG_MS(AR5K_REG_READ(AR5K_AR5210_TIME_OUT),
	    AR5K_AR5210_TIME_OUT_ACK)));
}

HAL_BOOL
ar5k_ar5210_set_cts_timeout(struct ath_hal *hal, u_int timeout)
{
	if (ar5k_clocktoh(AR5K_REG_MS(0xffffffff, AR5K_AR5210_TIME_OUT_CTS))
	    <= timeout)
		return (AH_FALSE);

	AR5K_REG_WRITE_BITS(AR5K_AR5210_TIME_OUT, AR5K_AR5210_TIME_OUT_CTS,
	    ar5k_htoclock(timeout));

	return (AH_TRUE);
}

u_int
ar5k_ar5210_get_cts_timeout(struct ath_hal *hal)
{
	return (ar5k_clocktoh(AR5K_REG_MS(AR5K_REG_READ(AR5K_AR5210_TIME_OUT),
	    AR5K_AR5210_TIME_OUT_CTS)));
}

/*
 * Key table (WEP) functions
 */

HAL_BOOL
ar5k_ar5210_is_cipher_supported(struct ath_hal *hal, HAL_CIPHER cipher)
{
	/*
	 * The AR5210 only supports WEP
	 */
	if (cipher == HAL_CIPHER_WEP)
		return (AH_TRUE);

	return (AH_FALSE);
}

u_int32_t
ar5k_ar5210_get_keycache_size(struct ath_hal *hal)
{
	return (AR5K_AR5210_KEYCACHE_SIZE);
}

HAL_BOOL
ar5k_ar5210_reset_key(struct ath_hal *hal, u_int16_t entry)
{
	int i;

	AR5K_ASSERT_ENTRY(entry, AR5K_AR5210_KEYTABLE_SIZE);

	for (i = 0; i < AR5K_AR5210_KEYCACHE_SIZE; i++)
		AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE_OFF(entry, i), 0);

	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5210_is_key_valid(struct ath_hal *hal, u_int16_t entry)
{
	AR5K_ASSERT_ENTRY(entry, AR5K_AR5210_KEYTABLE_SIZE);

	/*
	 * Check the validation flag at the end of the entry
	 */
	if (AR5K_REG_READ(AR5K_AR5210_KEYTABLE_MAC1(entry)) &
	    AR5K_AR5210_KEYTABLE_VALID)
		return (AH_TRUE);

	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5210_set_key(struct ath_hal *hal, u_int16_t entry,
    const HAL_KEYVAL *keyval, const u_int8_t *mac, int xor_notused)
{
	int i;
	u_int32_t key_v[AR5K_AR5210_KEYCACHE_SIZE - 2];

	AR5K_ASSERT_ENTRY(entry, AR5K_AR5210_KEYTABLE_SIZE);

	bzero(&key_v, sizeof(key_v));

	switch (keyval->wk_len) {
	case AR5K_KEYVAL_LENGTH_40:
		bcopy(keyval->wk_key, &key_v[0], 4);
		bcopy(keyval->wk_key + 4, &key_v[1], 1);
		key_v[5] = AR5K_AR5210_KEYTABLE_TYPE_40;
		break;

	case AR5K_KEYVAL_LENGTH_104:
		bcopy(keyval->wk_key, &key_v[0], 4);
		bcopy(keyval->wk_key + 4, &key_v[1], 2);
		bcopy(keyval->wk_key + 6, &key_v[2], 4);
		bcopy(keyval->wk_key + 10, &key_v[3], 2);
		bcopy(keyval->wk_key + 12, &key_v[4], 1);
		key_v[5] = AR5K_AR5210_KEYTABLE_TYPE_104;
		break;

	case AR5K_KEYVAL_LENGTH_128:
		bcopy(keyval->wk_key, &key_v[0], 4);
		bcopy(keyval->wk_key + 4, &key_v[1], 2);
		bcopy(keyval->wk_key + 6, &key_v[2], 4);
		bcopy(keyval->wk_key + 10, &key_v[3], 2);
		bcopy(keyval->wk_key + 12, &key_v[4], 4);
		key_v[5] = AR5K_AR5210_KEYTABLE_TYPE_128;
		break;

	default:
		/* Unsupported key length (not WEP40/104/128) */
		return (AH_FALSE);
	}

	for (i = 0; i < nitems(key_v); i++)
		AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE_OFF(entry, i), key_v[i]);

	return (ar5k_ar5210_set_key_lladdr(hal, entry, mac));
}

HAL_BOOL
ar5k_ar5210_set_key_lladdr(struct ath_hal *hal, u_int16_t entry,
    const u_int8_t *mac)
{
	u_int32_t low_id, high_id;
	const u_int8_t *mac_v;

	/*
	 * Invalid entry (key table overflow)
	 */
	AR5K_ASSERT_ENTRY(entry, AR5K_AR5210_KEYTABLE_SIZE);

	/* MAC may be NULL if it's a broadcast key */
	mac_v = mac == NULL ? etherbroadcastaddr : mac;

	low_id = AR5K_LOW_ID(mac_v);
	high_id = AR5K_HIGH_ID(mac_v) | AR5K_AR5210_KEYTABLE_VALID;

	AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE_MAC0(entry), low_id);
	AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE_MAC1(entry), high_id);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_softcrypto(struct ath_hal *hal, HAL_BOOL enable)
{
	u_int32_t bits;
	int i;

	bits = AR5K_AR5210_DIAG_SW_DIS_ENC | AR5K_AR5210_DIAG_SW_DIS_DEC;
	if (enable == AH_TRUE) {
		/* Disable the hardware crypto engine */
		AR5K_REG_ENABLE_BITS(AR5K_AR5210_DIAG_SW, bits);
	} else {
		/* Enable the hardware crypto engine */
		AR5K_REG_DISABLE_BITS(AR5K_AR5210_DIAG_SW, bits);
	}

	/* Reset the key cache */
	for (i = 0; i < AR5K_AR5210_KEYTABLE_SIZE; i++)
		ar5k_ar5210_reset_key(hal, i);

	return (AH_TRUE);
}

/*
 * Power management functions
 */

HAL_BOOL
ar5k_ar5210_set_power(struct ath_hal *hal, HAL_POWER_MODE mode,
    HAL_BOOL set_chip, u_int16_t sleep_duration)
{
	u_int32_t staid;
	int i;

	staid = AR5K_REG_READ(AR5K_AR5210_STA_ID1);

	switch (mode) {
	case HAL_PM_AUTO:
		staid &= ~AR5K_AR5210_STA_ID1_DEFAULT_ANTENNA;
		/* FALLTHROUGH */
	case HAL_PM_NETWORK_SLEEP:
		if (set_chip == AH_TRUE) {
			AR5K_REG_WRITE(AR5K_AR5210_SCR,
			    AR5K_AR5210_SCR_SLE | sleep_duration);
		}
		staid |= AR5K_AR5210_STA_ID1_PWR_SV;
		break;

	case HAL_PM_FULL_SLEEP:
		if (set_chip == AH_TRUE) {
			AR5K_REG_WRITE(AR5K_AR5210_SCR,
			    AR5K_AR5210_SCR_SLE_SLP);
		}
		staid |= AR5K_AR5210_STA_ID1_PWR_SV;
		break;

	case HAL_PM_AWAKE:
		if (set_chip == AH_FALSE)
			goto commit;

		AR5K_REG_WRITE(AR5K_AR5210_SCR, AR5K_AR5210_SCR_SLE_WAKE);

		for (i = 5000; i > 0; i--) {
			/* Check if the AR5210 did wake up */
			if ((AR5K_REG_READ(AR5K_AR5210_PCICFG) &
			    AR5K_AR5210_PCICFG_SPWR_DN) == 0)
				break;

			/* Wait a bit and retry */
			AR5K_DELAY(200);
			AR5K_REG_WRITE(AR5K_AR5210_SCR,
			    AR5K_AR5210_SCR_SLE_WAKE);
		}

		/* Fail if the AR5210 didn't wake up */
		if (i <= 0)
			return (AH_FALSE);

		staid &= ~AR5K_AR5210_STA_ID1_PWR_SV;
		break;

	default:
		return (AH_FALSE);
	}

 commit:
	hal->ah_power_mode = mode;

	AR5K_REG_WRITE(AR5K_AR5210_STA_ID1, staid);

	return (AH_TRUE);
}

HAL_POWER_MODE
ar5k_ar5210_get_power_mode(struct ath_hal *hal)
{
	return (hal->ah_power_mode);
}

HAL_BOOL
ar5k_ar5210_query_pspoll_support(struct ath_hal *hal)
{
	/* I think so, why not? */
	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_init_pspoll(struct ath_hal *hal)
{
	/*
	 * Not used on the AR5210
	 */
	return (AH_FALSE);
}

HAL_BOOL
ar5k_ar5210_enable_pspoll(struct ath_hal *hal, u_int8_t *bssid,
    u_int16_t assoc_id)
{
	AR5K_REG_DISABLE_BITS(AR5K_AR5210_STA_ID1,
	    AR5K_AR5210_STA_ID1_NO_PSPOLL |
	    AR5K_AR5210_STA_ID1_DEFAULT_ANTENNA);

	return (AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_disable_pspoll(struct ath_hal *hal)
{
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_STA_ID1,
	    AR5K_AR5210_STA_ID1_NO_PSPOLL |
	    AR5K_AR5210_STA_ID1_DEFAULT_ANTENNA);

	return (AH_TRUE);
}

/*
 * Beacon functions
 */

void
ar5k_ar5210_init_beacon(struct ath_hal *hal, u_int32_t next_beacon,
    u_int32_t interval)
{
	u_int32_t timer1, timer2, timer3;

	/*
	 * Set the additional timers by mode
	 */
	switch (hal->ah_op_mode) {
	case HAL_M_STA:
		timer1 = 0xffffffff;
		timer2 = 0xffffffff;
		timer3 = 1;
		break;

	default:
		timer1 = (next_beacon - AR5K_TUNE_DMA_BEACON_RESP) << 3;
		timer2 = (next_beacon - AR5K_TUNE_SW_BEACON_RESP) << 3;
		timer3 = next_beacon + hal->ah_atim_window;
		break;
	}

	/*
	 * Enable all timers and set the beacon register
	 * (next beacon, DMA beacon, software beacon, ATIM window time)
	 */
	AR5K_REG_WRITE(AR5K_AR5210_TIMER0, next_beacon);
	AR5K_REG_WRITE(AR5K_AR5210_TIMER1, timer1);
	AR5K_REG_WRITE(AR5K_AR5210_TIMER2, timer2);
	AR5K_REG_WRITE(AR5K_AR5210_TIMER3, timer3);

	AR5K_REG_WRITE(AR5K_AR5210_BEACON, interval &
	    (AR5K_AR5210_BEACON_PERIOD | AR5K_AR5210_BEACON_RESET_TSF |
		AR5K_AR5210_BEACON_EN));
}

void
ar5k_ar5210_set_beacon_timers(struct ath_hal *hal,
    const HAL_BEACON_STATE *state, u_int32_t tsf, u_int32_t dtim_count,
    u_int32_t cfp_count)
{
	u_int32_t cfp_period, next_cfp;

	/* Return on an invalid beacon state */
	if (state->bs_interval < 1)
		return;

	/*
	 * PCF support?
	 */
	if (state->bs_cfp_period > 0) {
		/* Enable CFP mode and set the CFP and timer registers */
		cfp_period = state->bs_cfp_period * state->bs_dtim_period *
		    state->bs_interval;
		next_cfp = (cfp_count * state->bs_dtim_period + dtim_count) *
		    state->bs_interval;

		AR5K_REG_DISABLE_BITS(AR5K_AR5210_STA_ID1,
		    AR5K_AR5210_STA_ID1_DEFAULT_ANTENNA |
		    AR5K_AR5210_STA_ID1_PCF);
		AR5K_REG_WRITE(AR5K_AR5210_CFP_PERIOD, cfp_period);
		AR5K_REG_WRITE(AR5K_AR5210_CFP_DUR, state->bs_cfp_max_duration);
		AR5K_REG_WRITE(AR5K_AR5210_TIMER2,
		    (tsf + (next_cfp == 0 ? cfp_period : next_cfp)) << 3);
	} else {
		/* Disable PCF mode */
		AR5K_REG_DISABLE_BITS(AR5K_AR5210_STA_ID1,
		    AR5K_AR5210_STA_ID1_DEFAULT_ANTENNA |
		    AR5K_AR5210_STA_ID1_PCF);
	}

	/*
	 * Enable the beacon timer register
	 */
	AR5K_REG_WRITE(AR5K_AR5210_TIMER0, state->bs_next_beacon);

	/*
	 * Start the beacon timers
	 */
	AR5K_REG_WRITE(AR5K_AR5210_BEACON,
	    (AR5K_REG_READ(AR5K_AR5210_BEACON) &~
		(AR5K_AR5210_BEACON_PERIOD | AR5K_AR5210_BEACON_TIM)) |
	    AR5K_REG_SM(state->bs_tim_offset ? state->bs_tim_offset + 4 : 0,
		AR5K_AR5210_BEACON_TIM) |
	    AR5K_REG_SM(state->bs_interval, AR5K_AR5210_BEACON_PERIOD));

	/*
	 * Write new beacon miss threshold, if it appears to be valid
	 */
	if (state->bs_bmiss_threshold <=
	    (AR5K_AR5210_RSSI_THR_BM_THR >> AR5K_AR5210_RSSI_THR_BM_THR_S)) {
		AR5K_REG_WRITE_BITS(AR5K_AR5210_RSSI_THR,
		    AR5K_AR5210_RSSI_THR_BM_THR, state->bs_bmiss_threshold);
	}
}

void
ar5k_ar5210_reset_beacon(struct ath_hal *hal)
{
	/*
	 * Disable beacon timer
	 */
	AR5K_REG_WRITE(AR5K_AR5210_TIMER0, 0);

	/*
	 * Disable some beacon register values
	 */
	AR5K_REG_DISABLE_BITS(AR5K_AR5210_STA_ID1,
	    AR5K_AR5210_STA_ID1_DEFAULT_ANTENNA | AR5K_AR5210_STA_ID1_PCF);
	AR5K_REG_WRITE(AR5K_AR5210_BEACON, AR5K_AR5210_BEACON_PERIOD);
}

HAL_BOOL
ar5k_ar5210_wait_for_beacon(struct ath_hal *hal, bus_addr_t phys_addr)
{
	int i;

	/*
	 * Wait for beaconn queue to be done
	 */
	for (i = (AR5K_TUNE_BEACON_INTERVAL / 2); i > 0 &&
		 (AR5K_REG_READ(AR5K_AR5210_BSR) &
		     AR5K_AR5210_BSR_TXQ1F) != 0 &&
		 (AR5K_REG_READ(AR5K_AR5210_CR) &
		     AR5K_AR5210_CR_TXE1) != 0; i--);

	/* Timeout... */
	if (i <= 0) {
		/*
		 * Re-schedule the beacon queue
		 */
		AR5K_REG_WRITE(AR5K_AR5210_TXDP1, (u_int32_t)phys_addr);
		AR5K_REG_WRITE(AR5K_AR5210_BCR,
		    AR5K_AR5210_BCR_TQ1V | AR5K_AR5210_BCR_BDMAE);

		return (AH_FALSE);
	}

	return (AH_TRUE);
}

/*
 * Interrupt handling
 */

HAL_BOOL
ar5k_ar5210_is_intr_pending(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5210_INTPEND) == 0 ? AH_FALSE : AH_TRUE);
}

HAL_BOOL
ar5k_ar5210_get_isr(struct ath_hal *hal, u_int32_t *interrupt_mask)
{
	u_int32_t data;

	if ((data = AR5K_REG_READ(AR5K_AR5210_ISR)) == HAL_INT_NOCARD) {
		*interrupt_mask = data;
		return (AH_FALSE);
	}

	/*
	 * Get abstract interrupt mask (HAL-compatible)
	 */
	*interrupt_mask = (data & HAL_INT_COMMON) & hal->ah_imr;

	if (data & (AR5K_AR5210_ISR_RXOK | AR5K_AR5210_ISR_RXERR))
		*interrupt_mask |= HAL_INT_RX;
	if (data & (AR5K_AR5210_ISR_TXOK | AR5K_AR5210_ISR_TXERR))
		*interrupt_mask |= HAL_INT_TX;
	if (data & AR5K_AR5210_ISR_FATAL)
		*interrupt_mask |= HAL_INT_FATAL;

	/*
	 * Special interrupt handling (not caught by the driver)
	 */
	if (((*interrupt_mask) & AR5K_AR5210_ISR_RXPHY) &&
	    hal->ah_radar.r_enabled == AH_TRUE)
		ar5k_radar_alert(hal);

	/* XXX BMISS interrupts may occur after association */
	*interrupt_mask &= ~HAL_INT_BMISS;

	return (AH_TRUE);
}

u_int32_t
ar5k_ar5210_get_intr(struct ath_hal *hal)
{
	/* Return the interrupt mask stored previously */
	return (hal->ah_imr);
}

HAL_INT
ar5k_ar5210_set_intr(struct ath_hal *hal, HAL_INT new_mask)
{
	HAL_INT old_mask, int_mask;

	/*
	 * Disable card interrupts to prevent any race conditions
	 * (they will be re-enabled afterwards).
	 */
	AR5K_REG_WRITE(AR5K_AR5210_IER, AR5K_AR5210_IER_DISABLE);

	old_mask = hal->ah_imr;

	/*
	 * Add additional, chipset-dependent interrupt mask flags
	 * and write them to the IMR (interrupt mask register).
	 */
	int_mask = new_mask & HAL_INT_COMMON;

	if (new_mask & HAL_INT_RX)
		int_mask |=
		    AR5K_AR5210_IMR_RXOK |
		    AR5K_AR5210_IMR_RXERR |
		    AR5K_AR5210_IMR_RXORN;

	if (new_mask & HAL_INT_TX)
		int_mask |=
		    AR5K_AR5210_IMR_TXOK |
		    AR5K_AR5210_IMR_TXERR |
		    AR5K_AR5210_IMR_TXURN;

	AR5K_REG_WRITE(AR5K_AR5210_IMR, int_mask);

	/* Store new interrupt mask */
	hal->ah_imr = new_mask;

	/* ..re-enable interrupts */
	if (int_mask) {
		AR5K_REG_WRITE(AR5K_AR5210_IER, AR5K_AR5210_IER_ENABLE);
	}

	return (old_mask);
}

/*
 * Misc internal functions
 */

HAL_BOOL
ar5k_ar5210_get_capabilities(struct ath_hal *hal)
{
	/* Set number of supported TX queues */
	hal->ah_capabilities.cap_queues.q_tx_num = AR5K_AR5210_TX_NUM_QUEUES;

	/*
	 * Set radio capabilities
	 * (The AR5210 only supports the middle 5GHz band)
	 */
	hal->ah_capabilities.cap_range.range_5ghz_min = 5120;
	hal->ah_capabilities.cap_range.range_5ghz_max = 5430;
	hal->ah_capabilities.cap_range.range_2ghz_min = 0;
	hal->ah_capabilities.cap_range.range_2ghz_max = 0;

	/* Set supported modes */
	hal->ah_capabilities.cap_mode = HAL_MODE_11A;

	/* Set number of GPIO pins */
	hal->ah_gpio_npins = AR5K_AR5210_NUM_GPIO;

	return (AH_TRUE);
}

void
ar5k_ar5210_radar_alert(struct ath_hal *hal, HAL_BOOL enable)
{
	/*
	 * Set the RXPHY interrupt to be able to detect
	 * possible radar activity.
	 */
	AR5K_REG_WRITE(AR5K_AR5210_IER, AR5K_AR5210_IER_DISABLE);

	if (enable == AH_TRUE) {
		AR5K_REG_ENABLE_BITS(AR5K_AR5210_IMR,
		    AR5K_AR5210_IMR_RXPHY);
	} else {
		AR5K_REG_DISABLE_BITS(AR5K_AR5210_IMR,
		    AR5K_AR5210_IMR_RXPHY);
	}

	AR5K_REG_WRITE(AR5K_AR5210_IER, AR5K_AR5210_IER_ENABLE);
}

/*
 * EEPROM access functions
 */

HAL_BOOL
ar5k_ar5210_eeprom_is_busy(struct ath_hal *hal)
{
	return (AR5K_REG_READ(AR5K_AR5210_CFG) & AR5K_AR5210_CFG_EEBS ?
	    AH_TRUE : AH_FALSE);
}

int
ar5k_ar5210_eeprom_read(struct ath_hal *hal, u_int32_t offset, u_int16_t *data)
{
	u_int32_t status, timeout;

	/* Enable eeprom access */
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_PCICFG, AR5K_AR5210_PCICFG_EEAE);

	/*
	 * Prime read pump
	 */
	(void)AR5K_REG_READ(AR5K_AR5210_EEPROM_BASE + (4 * offset));

	for (timeout = 10000; timeout > 0; timeout--) {
		AR5K_DELAY(1);
		status = AR5K_REG_READ(AR5K_AR5210_EEPROM_STATUS);
		if (status & AR5K_AR5210_EEPROM_STAT_RDDONE) {
			if (status & AR5K_AR5210_EEPROM_STAT_RDERR)
				return (EIO);
			*data = (u_int16_t)
			    (AR5K_REG_READ(AR5K_AR5210_EEPROM_RDATA) & 0xffff);
			return (0);
		}
	}

	return (ETIMEDOUT);
}

int
ar5k_ar5210_eeprom_write(struct ath_hal *hal, u_int32_t offset, u_int16_t data)
{
	u_int32_t status, timeout;

	/* Enable eeprom access */
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_PCICFG, AR5K_AR5210_PCICFG_EEAE);

	/*
	 * Prime write pump
	 */
	AR5K_REG_WRITE(AR5K_AR5210_EEPROM_BASE + (4 * offset), data);

	for (timeout = 10000; timeout > 0; timeout--) {
		AR5K_DELAY(1);
		status = AR5K_REG_READ(AR5K_AR5210_EEPROM_STATUS);
		if (status & AR5K_AR5210_EEPROM_STAT_WRDONE) {
			if (status & AR5K_AR5210_EEPROM_STAT_WRERR)
				return (EIO);
			return (0);
		}
	}

	return (ETIMEDOUT);
}

HAL_BOOL
ar5k_ar5210_set_txpower_limit(struct ath_hal *hal, u_int power)
{
	/* Not implemented */
	return (AH_FALSE);
}
@


1.46
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.45 2009/06/02 12:39:02 reyk Exp $        */
d29 2
a30 2
HAL_BOOL	 ar5k_ar5210_nic_wakeup(struct ath_hal *, HAL_BOOL, HAL_BOOL);
void		 ar5k_ar5210_init_tx_queue(struct ath_hal *, u_int, HAL_BOOL);
d205 1
a205 1
	if (ar5k_ar5210_nic_wakeup(hal, AH_FALSE, AH_TRUE) != AH_TRUE)
d273 1
a273 1
ar5k_ar5210_nic_wakeup(struct ath_hal *hal, HAL_BOOL turbo, HAL_BOOL initial)
d297 2
a298 3
	/* ...enable Atheros turbo mode if requested */
	AR5K_REG_WRITE(AR5K_AR5210_PHY_FC,
	    turbo == AH_TRUE ? AR5K_AR5210_PHY_FC_TURBO_MODE : 0);
a338 2
	case HAL_MODE_TURBO:
		return (&hal->ah_rt_turbo);
d373 1
a373 3
	if (ar5k_ar5210_nic_wakeup(hal,
		channel->c_channel_flags & IEEE80211_CHAN_T ?
		AH_TRUE : AH_FALSE, AH_FALSE) == AH_FALSE)
d795 1
a795 1
ar5k_ar5210_init_tx_queue(struct ath_hal *hal, u_int aifs, HAL_BOOL turbo)
d800 1
a800 1
		u_int32_t mode_base, mode_turbo;
d808 1
a808 2
		    turbo == AH_TRUE ?
		    initial[i].mode_turbo : initial[i].mode_base);
d826 1
a826 2
	ar5k_ar5210_init_tx_queue(hal, hal->ah_aifs + tq->tqi_aifs,
	    hal->ah_turbo == AH_TRUE ? AH_TRUE : AH_FALSE);
d1738 1
a1738 2
	AR5K_REG_WRITE(AR5K_AR5210_SLOT_TIME,
	    ar5k_htoclock(slot_time, hal->ah_turbo));
d1746 1
a1746 2
	return (ar5k_clocktoh(AR5K_REG_READ(AR5K_AR5210_SLOT_TIME) &
		    0xffff, hal->ah_turbo));
d1752 2
a1753 2
	if (ar5k_clocktoh(AR5K_REG_MS(0xffffffff, AR5K_AR5210_TIME_OUT_ACK),
		hal->ah_turbo) <= timeout)
d1757 1
a1757 1
	    ar5k_htoclock(timeout, hal->ah_turbo));
d1766 1
a1766 1
	    AR5K_AR5210_TIME_OUT_ACK), hal->ah_turbo));
d1772 2
a1773 2
	if (ar5k_clocktoh(AR5K_REG_MS(0xffffffff, AR5K_AR5210_TIME_OUT_CTS),
	    hal->ah_turbo) <= timeout)
d1777 1
a1777 1
	    ar5k_htoclock(timeout, hal->ah_turbo));
d1786 1
a1786 1
	    AR5K_AR5210_TIME_OUT_CTS), hal->ah_turbo));
d2307 1
a2307 1
	hal->ah_capabilities.cap_mode = HAL_MODE_11A | HAL_MODE_TURBO;
@


1.45
log
@replace custom macro AR5K_ELEMENTS() with nitems()
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.44 2009/01/15 07:55:22 grange Exp $        */
d357 1
a357 1
	free(hal, M_DEVBUF);
@


1.44
log
@const void foo() makes no sense. No binary change.

ok niklas@@ otto@@
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.43 2008/08/29 10:05:00 reyk Exp $        */
d390 1
a390 1
	for (i = 0; i < AR5K_ELEMENTS(ar5210_ini); i++) {
d811 1
a811 1
	for (i = 0; i < AR5K_ELEMENTS(initial); i++)
d1889 1
a1889 1
	for (i = 0; i < AR5K_ELEMENTS(key_v); i++)
@


1.43
log
@add a HAL function to force disabling the hardware crypto engine
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.42 2008/08/27 09:05:03 damien Exp $        */
d31 1
a31 1
const void	 ar5k_ar5210_fill(struct ath_hal *);
d43 1
a43 1
const void
@


1.42
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.41 2007/11/01 20:32:16 reyk Exp $        */
d135 1
d1915 22
@


1.41
log
@backout last "fix" because it breaks operation on some devices.  even
if the fix looks right, it seems to expose another problem that i
haven't found yet.

figured out by Denis Doroshenko at gmail dot com
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.40 2007/10/29 09:39:35 reyk Exp $        */
d487 1
d501 1
@


1.40
log
@fix the setup of Tx descriptors. the frame type and "no ack" bits were
initialized in ar5k_ar521*_setup_tx_desc() but cleared in
ar5k_ar521*_fill_tx_desc() by setting the segment length incorrectly.

From ath5k via Nick Kossifidis (mickflemm at gmail dot com)*

---snip---
The missing no_ack in broadcast frames caused them to be retried up to
the retry_limit(1+4=5 transmissions by default).
---snap---

* it was explicitly mentioned that it is ISC-licensed now
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.39 2007/04/10 17:47:55 miod Exp $        */
d1086 1
d1088 1
@


1.39
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.38 2007/03/12 01:04:52 reyk Exp $        */
d1083 1
a1083 2
	if ((tx_desc->tx_control_1 = (segment_length &
	    AR5K_AR5210_DESC_TX_CTL1_BUF_LEN)) != segment_length)
d1085 3
@


1.38
log
@add some HAL functions (again) inspired by the changes from the
madwifi-old-openhal project. this was backed out the last time because
it was too close to the release and i didn't respect the ABI/API lock.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.35 2007/03/05 15:13:26 reyk Exp $        */
d203 1
a203 1
	/* Bring device out of sleep and reset it's units */
@


1.37
log
@do not use bcopy to set the mac address registers. this diff should
fix the "hal" on big endian systems.

thanks to the madwifi-old-openhal people
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.36 2007/03/05 16:54:33 deraadt Exp $        */
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
d174 16
d360 7
d460 13
d777 9
d921 6
d1586 7
d2380 6
@


1.36
log
@back out, reyk is not paying attention
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.34 2007/02/14 00:53:48 jsg Exp $        */
d476 2
a477 2
	bcopy(&(hal->ah_sta_id[0]), &low_id, 4);
	bcopy(&(hal->ah_sta_id[4]), &high_id, 2);
d1448 2
a1449 3
	bcopy(mac, &low_id, 4);
	bcopy(mac + 4, &high_id, 2);
	high_id = 0x0000ffff & high_id;
d1516 2
a1517 2
	bcopy(bssid, &low_id, 4);
	bcopy(bssid + 4, &high_id, 2);
d1845 2
a1846 3
	bcopy(mac_v, &low_id, 4);
	bcopy(mac_v + 4, &high_id, 2);
	high_id |= AR5K_AR5210_KEYTABLE_VALID;
@


1.35
log
@Add some HAL functions.

From madwifi-old-openhal via Nick Kossifidis (mickflemm at gmail dot com)

Bump copyright while I'm here.
@
text
@d4 1
a4 1
 * Copyright (c) 2004, 2005, 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
a173 16

	/*
	 * Unused functions or functions not implemented
	 */
	AR5K_HAL_FUNCTION(hal, ar5210, set_bssid_mask);
	AR5K_HAL_FUNCTION(hal, ar5210, get_tx_queueprops);
	AR5K_HAL_FUNCTION(hal, ar5210, num_tx_pending);
	AR5K_HAL_FUNCTION(hal, ar5210, phy_disable);
	AR5K_HAL_FUNCTION(hal, ar5210, set_txpower_limit);
	AR5K_HAL_FUNCTION(hal, ar5210, set_def_antenna);
	AR5K_HAL_FUNCTION(hal, ar5210, get_def_antenna);
#ifdef notyet
	AR5K_HAL_FUNCTION(hal, ar5210, set_capability);
	AR5K_HAL_FUNCTION(hal, ar5210, proc_mib_event);
	AR5K_HAL_FUNCTION(hal, ar5210, get_tx_inter_queue);
#endif
a343 7
ar5k_ar5210_phy_disable(struct ath_hal *hal)
{
	AR5K_REG_WRITE(AR5K_AR5210_PHY_ACTIVE, AR5K_AR5210_PHY_DISABLE);
	return (AH_TRUE);
}

HAL_BOOL
a436 13
ar5k_ar5210_set_def_antenna(struct ath_hal *hal, u_int ant)
{
	/* Not available */
	return;
}

u_int
ar5k_ar5210_get_def_antenna(struct ath_hal *hal)
{
	return (0);
}

void
a740 9
ar5k_ar5210_get_tx_queueprops(struct ath_hal *hal, int queue,
    HAL_TXQ_INFO *queue_info)
{
	AR5K_ASSERT_ENTRY(queue, hal->ah_capabilities.cap_queues.q_tx_num);
	bcopy(&hal->ah_txq[queue], queue_info, sizeof(HAL_TXQ_INFO));
	return (AH_TRUE);
}

HAL_BOOL
a875 6
u_int32_t
ar5k_ar5210_num_tx_pending(struct ath_hal *hal, u_int queue)
{
	return (AH_FALSE);
}

a1535 7
ar5k_ar5210_set_bssid_mask(struct ath_hal *hal, const u_int8_t* mask)
{
	/* Not supported in 5210 */
	return (AH_FALSE);
}

HAL_BOOL
a2323 6
HAL_BOOL
ar5k_ar5210_set_txpower_limit(struct ath_hal *hal, u_int power)
{
	/* Not implemented */
	return (AH_FALSE);
}
@


1.34
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.33 2005/12/18 17:59:58 reyk Exp $        */
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
d174 16
d360 7
d460 13
d777 9
d921 6
d1587 7
d2382 6
@


1.33
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.32 2005/10/07 22:03:25 reyk Exp $        */
d1872 1
a1872 1
		/* fallthrough */
@


1.32
log
@KNF
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.31 2005/10/04 13:50:00 reyk Exp $        */
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.31
log
@fix a bug in Tx descriptor processing.

found by David Malone
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.30 2005/09/19 10:27:08 reyk Exp $        */
d1910 1
a1910 1
		
@


1.30
log
@don't attach unsupported radio chipsets

based on a diff by jsg@@
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.29 2005/09/10 14:36:46 jsg Exp $        */
d1091 1
a1091 1
	desc->ds_us.tx.ts_tstamp =
@


1.29
log
@ansi, no binary change.
ok reyk@@
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.28 2005/08/14 11:02:32 miod Exp $        */
d193 1
@


1.28
log
@catched->caught
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.27 2005/08/02 12:55:11 reyk Exp $        */
d44 1
a44 2
ar5k_ar5210_fill(hal)
	struct ath_hal *hal;
d177 2
a178 6
ar5k_ar5210_attach(device, sc, st, sh, status)
	u_int16_t device;
	void *sc;
	bus_space_tag_t st;
	bus_space_handle_t sh;
	int *status;
d221 1
a221 3
ar5k_ar5210_nic_reset(hal, val)
	struct ath_hal *hal;
	u_int32_t val;
d255 1
a255 4
ar5k_ar5210_nic_wakeup(hal, turbo, initial)
	struct ath_hal *hal;
	HAL_BOOL turbo;
	HAL_BOOL initial;
d317 1
a317 3
ar5k_ar5210_get_rate_table(hal, mode)
	struct ath_hal *hal;
	u_int mode;
d334 1
a334 2
ar5k_ar5210_detach(hal)
	struct ath_hal *hal;
d343 2
a344 6
ar5k_ar5210_reset(hal, op_mode, channel, change_channel, status)
	struct ath_hal *hal;
	HAL_OPMODE op_mode;
	HAL_CHANNEL *channel;
	HAL_BOOL change_channel;
	HAL_STATUS *status;
d436 1
a436 2
ar5k_ar5210_set_opmode(hal)
	struct ath_hal *hal;
d485 1
a485 3
ar5k_ar5210_calibrate(hal, channel)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
d589 1
a589 3
ar5k_ar5210_do_calibrate(hal, channel)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
d608 1
a608 3
ar5k_ar5210_noise_floor(hal, channel)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
d651 1
a651 3
ar5k_ar5210_update_tx_triglevel(hal, increase)
	struct ath_hal *hal;
	HAL_BOOL increase;
d687 2
a688 4
ar5k_ar5210_setup_tx_queue(hal, queue_type, queue_info)
	struct ath_hal *hal;
	HAL_TX_QUEUE queue_type;
	const HAL_TXQ_INFO *queue_info;
d723 2
a724 4
ar5k_ar5210_setup_tx_queueprops(hal, queue, queue_info)
	struct ath_hal *hal;
	int queue;
	const HAL_TXQ_INFO *queue_info;
d740 1
a740 3
ar5k_ar5210_release_tx_queue(hal, queue)
	struct ath_hal *hal;
	u_int queue;
d751 1
a751 4
ar5k_ar5210_init_tx_queue(hal, aifs, turbo)
	struct ath_hal *hal;
	u_int aifs;
	HAL_BOOL turbo;
d769 1
a769 3
ar5k_ar5210_reset_tx_queue(hal, queue)
	struct ath_hal *hal;
	u_int queue;
d823 1
a823 3
ar5k_ar5210_get_tx_buf(hal, queue)
	struct ath_hal *hal;
	u_int queue;
d848 1
a848 4
ar5k_ar5210_put_tx_buf(hal, queue, phys_addr)
	struct ath_hal *hal;
	u_int queue;
	u_int32_t phys_addr;
d876 1
a876 3
ar5k_ar5210_tx_start(hal, queue)
	struct ath_hal *hal;
	u_int queue;
d916 1
a916 3
ar5k_ar5210_stop_tx_dma(hal, queue)
	struct ath_hal *hal;
	u_int queue;
d950 4
a953 16
ar5k_ar5210_setup_tx_desc(hal, desc, packet_length, header_length, type,
    tx_power, tx_rate0, tx_tries0, key_index, antenna_mode, flags, rtscts_rate,
    rtscts_duration)
	struct ath_hal *hal;
	struct ath_desc *desc;
	u_int packet_length;
	u_int header_length;
	HAL_PKT_TYPE type;
	u_int tx_power;
	u_int tx_rate0;
	u_int tx_tries0;
	u_int key_index;
	u_int antenna_mode;
	u_int flags;
	u_int rtscts_rate;
	u_int rtscts_duration;
d1020 2
a1021 6
ar5k_ar5210_fill_tx_desc(hal, desc, segment_length, first_segment, last_segment)
	struct ath_hal *hal;
	struct ath_desc *desc;
	u_int segment_length;
	HAL_BOOL first_segment;
	HAL_BOOL last_segment;
d1045 3
a1047 10
ar5k_ar5210_setup_xtx_desc(hal, desc, tx_rate1, tx_tries1, tx_rate2, tx_tries2,
    tx_rate3, tx_tries3)
	struct ath_hal *hal;
	struct ath_desc *desc;
	u_int tx_rate1;
	u_int tx_tries1;
	u_int tx_rate2;
	u_int tx_tries2;
	u_int tx_rate3;
	u_int tx_tries3;
d1058 1
a1058 3
ar5k_ar5210_proc_tx_desc(hal, desc)
	struct ath_hal *hal;
	struct ath_desc *desc;
d1113 1
a1113 2
ar5k_ar5210_has_veol(hal)
	struct ath_hal *hal;
d1123 1
a1123 2
ar5k_ar5210_get_rx_buf(hal)
	struct ath_hal *hal;
d1129 1
a1129 3
ar5k_ar5210_put_rx_buf(hal, phys_addr)
	struct ath_hal *hal;
	u_int32_t phys_addr;
d1135 1
a1135 2
ar5k_ar5210_start_rx(hal)
	struct ath_hal *hal;
d1141 1
a1141 2
ar5k_ar5210_stop_rx_dma(hal)
	struct ath_hal *hal;
d1159 1
a1159 2
ar5k_ar5210_start_rx_pcu(hal)
	struct ath_hal *hal;
d1165 1
a1165 2
ar5k_ar5210_stop_pcu_recv(hal)
	struct ath_hal *hal;
d1171 2
a1172 4
ar5k_ar5210_set_mcast_filter(hal, filter0, filter1)
	struct ath_hal *hal;
	u_int32_t filter0;
	u_int32_t filter1;
d1180 1
a1180 3
ar5k_ar5210_set_mcast_filterindex(hal, index)
	struct ath_hal *hal;
	u_int32_t index;
d1196 1
a1196 3
ar5k_ar5210_clear_mcast_filter_idx(hal, index)
	struct ath_hal *hal;
	u_int32_t index;
d1212 1
a1212 2
ar5k_ar5210_get_rx_filter(hal)
	struct ath_hal *hal;
d1218 1
a1218 3
ar5k_ar5210_set_rx_filter(hal, filter)
	struct ath_hal *hal;
	u_int32_t filter;
d1232 2
a1233 5
ar5k_ar5210_setup_rx_desc(hal, desc, size, flags)
	struct ath_hal *hal;
	struct ath_desc *desc;
	u_int32_t size;
	u_int flags;
d1250 2
a1251 5
ar5k_ar5210_proc_rx_desc(hal, desc, phys_addr, next)
	struct ath_hal *hal;
	struct ath_desc *desc;
	u_int32_t phys_addr;
	struct ath_desc *next;
d1323 1
a1323 2
ar5k_ar5210_set_rx_signal(hal)
	struct ath_hal *hal;
d1333 1
a1333 2
ar5k_ar5210_dump_state(hal)
	struct ath_hal *hal;
d1423 2
a1424 6
ar5k_ar5210_get_diag_state(hal, id, device, size)
	struct ath_hal *hal;
	int id;
	void **device;
	u_int *size;

d1434 1
a1434 3
ar5k_ar5210_get_lladdr(hal, mac)
	struct ath_hal *hal;
	u_int8_t *mac;
d1440 1
a1440 3
ar5k_ar5210_set_lladdr(hal, mac)
	struct ath_hal *hal;
	const u_int8_t *mac;
d1458 2
a1459 5
ar5k_ar5210_set_regdomain(hal, regdomain, status)
	struct ath_hal *hal;
	u_int16_t regdomain;
	HAL_STATUS *status;

d1477 1
a1477 3
ar5k_ar5210_set_ledstate(hal, state)
	struct ath_hal *hal;
	HAL_LED_STATE state;
d1508 2
a1509 5
ar5k_ar5210_set_associd(hal, bssid, assoc_id, tim_offset)
	struct ath_hal *hal;
	const u_int8_t *bssid;
	u_int16_t assoc_id;
	u_int16_t tim_offset;
d1535 1
a1535 3
ar5k_ar5210_set_gpio_output(hal, gpio)
	struct ath_hal *hal;
	u_int32_t gpio;
d1548 1
a1548 3
ar5k_ar5210_set_gpio_input(hal, gpio)
	struct ath_hal *hal;
	u_int32_t gpio;
d1561 1
a1561 3
ar5k_ar5210_get_gpio(hal, gpio)
	struct ath_hal *hal;
	u_int32_t gpio;
d1572 1
a1572 4
ar5k_ar5210_set_gpio(hal, gpio, val)
	struct ath_hal *hal;
	u_int32_t gpio;
	u_int32_t val;
d1591 2
a1592 4
ar5k_ar5210_set_gpio_intr(hal, gpio, interrupt_level)
	struct ath_hal *hal;
	u_int gpio;
	u_int32_t interrupt_level;
d1617 1
a1617 2
ar5k_ar5210_get_tsf32(hal)
	struct ath_hal *hal;
d1623 1
a1623 2
ar5k_ar5210_get_tsf64(hal)
	struct ath_hal *hal;
d1630 1
a1630 2
ar5k_ar5210_reset_tsf(hal)
	struct ath_hal *hal;
d1637 1
a1637 2
ar5k_ar5210_get_regdomain(hal)
	struct ath_hal *hal;
d1643 1
a1643 2
ar5k_ar5210_detect_card_present(hal)
	struct ath_hal *hal;
d1659 1
a1659 3
ar5k_ar5210_update_mib_counters(hal, statistics)
	struct ath_hal *hal;
	HAL_MIB_STATS *statistics;
d1669 1
a1669 2
ar5k_ar5210_get_rf_gain(hal)
	struct ath_hal *hal;
d1675 1
a1675 4
ar5k_ar5210_set_slot_time(hal, slot_time)
	struct ath_hal *hal;
	u_int slot_time;

d1687 1
a1687 2
ar5k_ar5210_get_slot_time(hal)
	struct ath_hal *hal;
d1694 1
a1694 3
ar5k_ar5210_set_ack_timeout(hal, timeout)
	struct ath_hal *hal;
	u_int timeout;
d1707 1
a1707 2
ar5k_ar5210_get_ack_timeout(hal)
	struct ath_hal *hal;
d1714 1
a1714 3
ar5k_ar5210_set_cts_timeout(hal, timeout)
	struct ath_hal *hal;
	u_int timeout;
d1727 1
a1727 2
ar5k_ar5210_get_cts_timeout(hal)
	struct ath_hal *hal;
d1738 1
a1738 3
ar5k_ar5210_is_cipher_supported(hal, cipher)
	struct ath_hal *hal;
	HAL_CIPHER cipher;
d1750 1
a1750 2
ar5k_ar5210_get_keycache_size(hal)
	struct ath_hal *hal;
d1756 1
a1756 3
ar5k_ar5210_reset_key(hal, entry)
	struct ath_hal *hal;
	u_int16_t entry;
d1769 1
a1769 3
ar5k_ar5210_is_key_valid(hal, entry)
	struct ath_hal *hal;
	u_int16_t entry;
d1784 2
a1785 6
ar5k_ar5210_set_key(hal, entry, keyval, mac, xor_notused)
	struct ath_hal *hal;
	u_int16_t entry;
	const HAL_KEYVAL *keyval;
	const u_int8_t *mac;
	int xor_notused;
d1831 2
a1832 4
ar5k_ar5210_set_key_lladdr(hal, entry, mac)
	struct ath_hal *hal;
	u_int16_t entry;
	const u_int8_t *mac;
d1860 2
a1861 5
ar5k_ar5210_set_power(hal, mode, set_chip, sleep_duration)
	struct ath_hal *hal;
	HAL_POWER_MODE mode;
	HAL_BOOL set_chip;
	u_int16_t sleep_duration;
d1926 1
a1926 2
ar5k_ar5210_get_power_mode(hal)
	struct ath_hal *hal;
d1932 1
a1932 2
ar5k_ar5210_query_pspoll_support(hal)
	struct ath_hal *hal;
d1939 1
a1939 2
ar5k_ar5210_init_pspoll(hal)
	struct ath_hal *hal;
d1948 2
a1949 4
ar5k_ar5210_enable_pspoll(hal, bssid, assoc_id)
	struct ath_hal *hal;
	u_int8_t *bssid;
	u_int16_t assoc_id;
d1959 1
a1959 2
ar5k_ar5210_disable_pspoll(hal)
	struct ath_hal *hal;
d1973 2
a1974 4
ar5k_ar5210_init_beacon(hal, next_beacon, interval)
	struct ath_hal *hal;
	u_int32_t next_beacon;
	u_int32_t interval;
d2010 3
a2012 7
ar5k_ar5210_set_beacon_timers(hal, state, tsf, dtim_count, cfp_count)
	struct ath_hal *hal;
	const HAL_BEACON_STATE *state;
	u_int32_t tsf;
	u_int32_t dtim_count;
	u_int32_t cfp_count;

d2070 1
a2070 2
ar5k_ar5210_reset_beacon(hal)
	struct ath_hal *hal;
d2086 1
a2086 3
ar5k_ar5210_wait_for_beacon(hal, phys_addr)
	struct ath_hal *hal;
	bus_addr_t phys_addr;
d2119 1
a2119 2
ar5k_ar5210_is_intr_pending(hal)
	struct ath_hal *hal;
d2125 1
a2125 3
ar5k_ar5210_get_isr(hal, interrupt_mask)
	struct ath_hal *hal;
	u_int32_t *interrupt_mask;
d2160 1
a2160 2
ar5k_ar5210_get_intr(hal)
	struct ath_hal *hal;
d2167 1
a2167 3
ar5k_ar5210_set_intr(hal, new_mask)
	struct ath_hal *hal;
	HAL_INT new_mask;
d2215 1
a2215 2
ar5k_ar5210_get_capabilities(hal)
	struct ath_hal *hal;
d2239 1
a2239 3
ar5k_ar5210_radar_alert(hal, enable)
	struct ath_hal *hal;
	HAL_BOOL enable;
d2263 1
a2263 2
ar5k_ar5210_eeprom_is_busy(hal)
	struct ath_hal *hal;
d2270 1
a2270 4
ar5k_ar5210_eeprom_read(hal, offset, data)
	struct ath_hal *hal;
	u_int32_t offset;
	u_int16_t *data;
d2298 1
a2298 4
ar5k_ar5210_eeprom_write(hal, offset, data)
	struct ath_hal *hal;
	u_int32_t offset;
	u_int16_t data;
@


1.27
log
@reduce stack usage

spotted out by jsg@@
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.26 2005/06/17 12:51:08 reyk Exp $        */
d2322 1
a2322 1
	 * Special interrupt handling (not catched by the driver)
@


1.26
log
@remove non-constant array initializers which is a GNU extension.
suggested by anil some time ago.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.25 2005/05/27 11:42:51 reyk Exp $        */
d35 6
a363 1
	struct ar5k_ini initial[] = AR5K_AR5210_INI;
d382 1
a382 1
	for (i = 0; i < AR5K_ELEMENTS(initial); i++) {
d384 2
a385 2
		    initial[i].ini_register >= AR5K_AR5210_PCU_MIN &&
		    initial[i].ini_register <= AR5K_AR5210_PCU_MAX)
d388 1
a388 1
		switch (initial[i].ini_mode) {
d391 1
a391 1
			AR5K_REG_READ(initial[i].ini_register);
d396 2
a397 2
			AR5K_REG_WRITE(initial[i].ini_register,
			    initial[i].ini_value);
@


1.25
log
@remove some misplaced htole32s
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.24 2005/05/24 21:46:17 reyk Exp $        */
d1934 2
a1935 2
	int elements = AR5K_AR5210_KEYCACHE_SIZE - 2, i;
	u_int32_t key_v[elements];
d1971 1
a1971 1
	for (i = 0; i < elements; i++)
@


1.24
log
@ath_hal_rx_monitor should be used for link state monitoring instead of
setting the promisc mode. rename it to ath_hal_rx_signal and remove
the incorrect promisc flag. this should fix some problems with ath
running in forwarding mode.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.23 2005/05/21 20:14:54 reyk Exp $        */
d1548 1
a1548 1
	high_id = 0x0000ffff & htole32(high_id);
d1550 1
a1550 1
	AR5K_REG_WRITE(AR5K_AR5210_STA_ID0, htole32(low_id));
d1625 2
a1626 2
	AR5K_REG_WRITE(AR5K_AR5210_BSS_ID0, htole32(low_id));
	AR5K_REG_WRITE(AR5K_AR5210_BSS_ID1, htole32(high_id) |
d1998 2
a1999 2
	AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE_MAC0(entry), htole32(low_id));
	AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE_MAC1(entry), htole32(high_id));
@


1.23
log
@sync power management settings. this should fix some unrecoverable
sleep mode timeouts for ar5210, ar5211 and ar5212.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.22 2005/05/08 14:55:09 reyk Exp $        */
d90 1
a90 1
	AR5K_HAL_FUNCTION(hal, ar5210, set_rx_monitor);
d1412 1
a1412 1
ar5k_ar5210_set_rx_monitor(hal)
d1415 1
a1415 5
	/*
	 * XXX Not sure, if this works correctly.
	 */
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_RX_FILTER,
	    AR5K_AR5210_RX_FILTER_PROMISC);
@


1.22
log
@the ar5210 is silicon version 0, not 1.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.21 2005/05/08 14:46:50 reyk Exp $        */
d2019 1
d2022 2
d2026 3
d2033 1
d2041 1
a2048 1
		AR5K_DELAY(2000);
d2053 1
a2053 1
				AR5K_AR5210_PCICFG_SPWR_DN) == 0)
d2065 2
a2068 2
	case HAL_PM_NETWORK_SLEEP:
	case HAL_PM_UNDEFINED:
d2076 1
a2076 4
	AR5K_REG_DISABLE_BITS(AR5K_AR5210_STA_ID1,
	    AR5K_AR5210_STA_ID1_DEFAULT_ANTENNA);
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_STA_ID1,
	    AR5K_AR5210_STA_ID1_PWR_SV);
@


1.21
log
@fix silicon version number reporting. ie. ath0: mac 80.6 -> ath0: mac 5.6.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.20 2005/04/18 18:42:55 reyk Exp $        */
d192 1
a192 1
	hal->ah_mac_version = 1;
@


1.20
log
@beautify the code by renaming HAL functions with capitalized words (i
always wanted to do that). this breaks HAL compatibility but porting
should be easy, have a look at athvar.h. no functional changes.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.19 2005/04/08 22:12:21 reyk Exp $        */
d182 1
d191 1
d193 1
a193 2
	hal->ah_mac_revision = (AR5K_REG_READ(AR5K_AR5210_SREV) &
	    AR5K_AR5210_SREV_ID_M);
@


1.19
log
@move reset of HAL descriptors to ath.c
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.18 2005/04/08 22:02:49 reyk Exp $        */
d32 1
a32 1
HAL_BOOL	 ar5k_ar5210_calibrate(struct ath_hal *, HAL_CHANNEL *);
d46 1
a46 1
	AR5K_HAL_FUNCTION(hal, ar5210, getRateTable);
d53 2
a54 2
	AR5K_HAL_FUNCTION(hal, ar5210, setPCUConfig);
	AR5K_HAL_FUNCTION(hal, ar5210, perCalibration);
d59 14
a72 14
	AR5K_HAL_FUNCTION(hal, ar5210, updateTxTrigLevel);
	AR5K_HAL_FUNCTION(hal, ar5210, setupTxQueue);
	AR5K_HAL_FUNCTION(hal, ar5210, setTxQueueProps);
	AR5K_HAL_FUNCTION(hal, ar5210, releaseTxQueue);
	AR5K_HAL_FUNCTION(hal, ar5210, resetTxQueue);
	AR5K_HAL_FUNCTION(hal, ar5210, getTxDP);
	AR5K_HAL_FUNCTION(hal, ar5210, setTxDP);
	AR5K_HAL_FUNCTION(hal, ar5210, startTxDma);
	AR5K_HAL_FUNCTION(hal, ar5210, stopTxDma);
	AR5K_HAL_FUNCTION(hal, ar5210, setupTxDesc);
	AR5K_HAL_FUNCTION(hal, ar5210, setupXTxDesc);
	AR5K_HAL_FUNCTION(hal, ar5210, fillTxDesc);
	AR5K_HAL_FUNCTION(hal, ar5210, procTxDesc);
	AR5K_HAL_FUNCTION(hal, ar5210, hasVEOL);
d77 14
a90 14
	AR5K_HAL_FUNCTION(hal, ar5210, getRxDP);
	AR5K_HAL_FUNCTION(hal, ar5210, setRxDP);
	AR5K_HAL_FUNCTION(hal, ar5210, enableReceive);
	AR5K_HAL_FUNCTION(hal, ar5210, stopDmaReceive);
	AR5K_HAL_FUNCTION(hal, ar5210, startPcuReceive);
	AR5K_HAL_FUNCTION(hal, ar5210, stopPcuReceive);
	AR5K_HAL_FUNCTION(hal, ar5210, setMulticastFilter);
	AR5K_HAL_FUNCTION(hal, ar5210, setMulticastFilterIndex);
	AR5K_HAL_FUNCTION(hal, ar5210, clrMulticastFilterIndex);
	AR5K_HAL_FUNCTION(hal, ar5210, getRxFilter);
	AR5K_HAL_FUNCTION(hal, ar5210, setRxFilter);
	AR5K_HAL_FUNCTION(hal, ar5210, setupRxDesc);
	AR5K_HAL_FUNCTION(hal, ar5210, procRxDesc);
	AR5K_HAL_FUNCTION(hal, ar5210, rxMonitor);
d95 25
a119 25
	AR5K_HAL_FUNCTION(hal, ar5210, dumpState);
	AR5K_HAL_FUNCTION(hal, ar5210, getDiagState);
	AR5K_HAL_FUNCTION(hal, ar5210, getMacAddress);
	AR5K_HAL_FUNCTION(hal, ar5210, setMacAddress);
	AR5K_HAL_FUNCTION(hal, ar5210, setRegulatoryDomain);
	AR5K_HAL_FUNCTION(hal, ar5210, setLedState);
	AR5K_HAL_FUNCTION(hal, ar5210, writeAssocid);
	AR5K_HAL_FUNCTION(hal, ar5210, gpioCfgInput);
	AR5K_HAL_FUNCTION(hal, ar5210, gpioCfgOutput);
	AR5K_HAL_FUNCTION(hal, ar5210, gpioGet);
	AR5K_HAL_FUNCTION(hal, ar5210, gpioSet);
	AR5K_HAL_FUNCTION(hal, ar5210, gpioSetIntr);
	AR5K_HAL_FUNCTION(hal, ar5210, getTsf32);
	AR5K_HAL_FUNCTION(hal, ar5210, getTsf64);
	AR5K_HAL_FUNCTION(hal, ar5210, resetTsf);
	AR5K_HAL_FUNCTION(hal, ar5210, getRegDomain);
	AR5K_HAL_FUNCTION(hal, ar5210, detectCardPresent);
	AR5K_HAL_FUNCTION(hal, ar5210, updateMibCounters);
	AR5K_HAL_FUNCTION(hal, ar5210, getRfGain);
	AR5K_HAL_FUNCTION(hal, ar5210, setSlotTime);
	AR5K_HAL_FUNCTION(hal, ar5210, getSlotTime);
	AR5K_HAL_FUNCTION(hal, ar5210, setAckTimeout);
	AR5K_HAL_FUNCTION(hal, ar5210, getAckTimeout);
	AR5K_HAL_FUNCTION(hal, ar5210, setCTSTimeout);
	AR5K_HAL_FUNCTION(hal, ar5210, getCTSTimeout);
d124 6
a129 6
	AR5K_HAL_FUNCTION(hal, ar5210, isHwCipherSupported);
	AR5K_HAL_FUNCTION(hal, ar5210, getKeyCacheSize);
	AR5K_HAL_FUNCTION(hal, ar5210, resetKeyCacheEntry);
	AR5K_HAL_FUNCTION(hal, ar5210, isKeyCacheEntryValid);
	AR5K_HAL_FUNCTION(hal, ar5210, setKeyCacheEntry);
	AR5K_HAL_FUNCTION(hal, ar5210, setKeyCacheEntryMac);
d134 6
a139 6
	AR5K_HAL_FUNCTION(hal, ar5210, setPowerMode);
	AR5K_HAL_FUNCTION(hal, ar5210, getPowerMode);
	AR5K_HAL_FUNCTION(hal, ar5210, queryPSPollSupport);
	AR5K_HAL_FUNCTION(hal, ar5210, initPSPoll);
	AR5K_HAL_FUNCTION(hal, ar5210, enablePSPoll);
	AR5K_HAL_FUNCTION(hal, ar5210, disablePSPoll);
d144 4
a147 4
	AR5K_HAL_FUNCTION(hal, ar5210, beaconInit);
	AR5K_HAL_FUNCTION(hal, ar5210, setStationBeaconTimers);
	AR5K_HAL_FUNCTION(hal, ar5210, resetStationBeaconTimers);
	AR5K_HAL_FUNCTION(hal, ar5210, waitForBeaconDone);
d152 4
a155 4
	AR5K_HAL_FUNCTION(hal, ar5210, isInterruptPending);
	AR5K_HAL_FUNCTION(hal, ar5210, getPendingInterrupts);
	AR5K_HAL_FUNCTION(hal, ar5210, getInterrupts);
	AR5K_HAL_FUNCTION(hal, ar5210, setInterrupts);
d211 3
a213 3
	ar5k_ar5210_writeAssocid(hal, mac, 0, 0);
	ar5k_ar5210_getMacAddress(hal, mac);
	ar5k_ar5210_setPCUConfig(hal);
d276 1
a276 1
	if (ar5k_ar5210_setPowerMode(hal,
d304 1
a304 1
	if (ar5k_ar5210_setPowerMode(hal,
d320 1
a320 1
ar5k_ar5210_getRateTable(hal, mode)
d371 1
a371 1
	ar5k_ar5210_setPCUConfig(hal);
d414 1
a414 1
	ar5k_ar5210_calibrate(hal, channel);
d422 3
a424 3
		ar5k_ar5210_gpioCfgInput(hal, 0);
		if ((hal->ah_gpio[0] = ar5k_ar5210_gpioGet(hal, 0)) == 0) {
			ar5k_ar5210_gpioSetIntr(hal, 0, 1);
d426 1
a426 1
			ar5k_ar5210_gpioSetIntr(hal, 0, 0);
d434 1
a434 1
		if (ar5k_ar5210_resetTxQueue(hal, i) == AH_FALSE) {
d447 1
a447 1
ar5k_ar5210_setPCUConfig(hal)
d497 1
a497 1
ar5k_ar5210_perCalibration(hal, channel)
d576 1
a576 1
	ret = ar5k_ar5210_calibrate(hal, channel);
d603 1
a603 1
ar5k_ar5210_calibrate(hal, channel)
d669 1
a669 1
ar5k_ar5210_updateTxTrigLevel(hal, increase)
d707 1
a707 1
ar5k_ar5210_setupTxQueue(hal, queue_type, queue_info)
d736 1
a736 1
		if (ar5k_ar5210_setTxQueueProps(hal,
d745 1
a745 1
ar5k_ar5210_setTxQueueProps(hal, queue, queue_info)
d764 1
a764 1
ar5k_ar5210_releaseTxQueue(hal, queue)
d798 1
a798 1
ar5k_ar5210_resetTxQueue(hal, queue)
d854 1
a854 1
ar5k_ar5210_getTxDP(hal, queue)
d881 1
a881 1
ar5k_ar5210_setTxDP(hal, queue, phys_addr)
d912 1
a912 1
ar5k_ar5210_startTxDma(hal, queue)
d954 1
a954 1
ar5k_ar5210_stopTxDma(hal, queue)
d990 2
a991 2
ar5k_ar5210_setupTxDesc(hal, desc, packet_length, header_length, type, tx_power,
    tx_rate0, tx_tries0, key_index, antenna_mode, flags, rtscts_rate,
d1032 1
a1032 1
	
d1038 1
a1038 1
#define _TX_FLAGS(_c, _flag)	 					\
d1040 1
a1040 1
		tx_desc->tx_control_##_c |=    				\
d1072 1
a1072 1
ar5k_ar5210_fillTxDesc(hal, desc, segment_length, first_segment, last_segment)
d1101 1
a1101 1
ar5k_ar5210_setupXTxDesc(hal, desc, tx_rate1, tx_tries1, tx_rate2, tx_tries2,
d1121 1
a1121 1
ar5k_ar5210_procTxDesc(hal, desc)
d1178 1
a1178 1
ar5k_ar5210_hasVEOL(hal)
d1189 1
a1189 1
ar5k_ar5210_getRxDP(hal)
d1196 1
a1196 1
ar5k_ar5210_setRxDP(hal, phys_addr)
d1204 1
a1204 1
ar5k_ar5210_enableReceive(hal)
d1211 1
a1211 1
ar5k_ar5210_stopDmaReceive(hal)
d1230 1
a1230 1
ar5k_ar5210_startPcuReceive(hal)
d1237 1
a1237 1
ar5k_ar5210_stopPcuReceive(hal)
d1244 1
a1244 1
ar5k_ar5210_setMulticastFilter(hal, filter0, filter1)
d1255 1
a1255 1
ar5k_ar5210_setMulticastFilterIndex(hal, index)
d1273 1
a1273 1
ar5k_ar5210_clrMulticastFilterIndex(hal, index)
d1291 1
a1291 1
ar5k_ar5210_getRxFilter(hal)
d1298 1
a1298 1
ar5k_ar5210_setRxFilter(hal, filter)
d1314 1
a1314 1
ar5k_ar5210_setupRxDesc(hal, desc, size, flags)
d1335 1
a1335 1
ar5k_ar5210_procRxDesc(hal, desc, phys_addr, next)
d1411 1
a1411 1
ar5k_ar5210_rxMonitor(hal)
d1426 1
a1426 1
ar5k_ar5210_dumpState(hal)
d1517 1
a1517 1
ar5k_ar5210_getDiagState(hal, id, device, size)
d1532 1
a1532 1
ar5k_ar5210_getMacAddress(hal, mac)
d1540 1
a1540 1
ar5k_ar5210_setMacAddress(hal, mac)
d1560 1
a1560 1
ar5k_ar5210_setRegulatoryDomain(hal, regdomain, status)
d1582 1
a1582 1
ar5k_ar5210_setLedState(hal, state)
d1615 1
a1615 1
ar5k_ar5210_writeAssocid(hal, bssid, assoc_id, tim_offset)
d1634 1
a1634 1
		ar5k_ar5210_disablePSPoll(hal);
d1641 1
a1641 1
	ar5k_ar5210_enablePSPoll(hal, NULL, 0);
d1645 1
a1645 1
ar5k_ar5210_gpioCfgOutput(hal, gpio)
d1660 1
a1660 1
ar5k_ar5210_gpioCfgInput(hal, gpio)
d1675 1
a1675 1
ar5k_ar5210_gpioGet(hal, gpio)
d1688 1
a1688 1
ar5k_ar5210_gpioSet(hal, gpio, val)
d1710 1
a1710 1
ar5k_ar5210_gpioSetIntr(hal, gpio, interrupt_level)
d1738 1
a1738 1
ar5k_ar5210_getTsf32(hal)
d1745 1
a1745 1
ar5k_ar5210_getTsf64(hal)
d1753 1
a1753 1
ar5k_ar5210_resetTsf(hal)
d1761 1
a1761 1
ar5k_ar5210_getRegDomain(hal)
d1768 1
a1768 1
ar5k_ar5210_detectCardPresent(hal)
d1785 1
a1785 1
ar5k_ar5210_updateMibCounters(hal, statistics)
d1797 1
a1797 1
ar5k_ar5210_getRfGain(hal)
d1804 1
a1804 1
ar5k_ar5210_setSlotTime(hal, slot_time)
d1819 1
a1819 1
ar5k_ar5210_getSlotTime(hal)
d1827 1
a1827 1
ar5k_ar5210_setAckTimeout(hal, timeout)
d1842 1
a1842 1
ar5k_ar5210_getAckTimeout(hal)
d1850 1
a1850 1
ar5k_ar5210_setCTSTimeout(hal, timeout)
d1865 1
a1865 1
ar5k_ar5210_getCTSTimeout(hal)
d1877 1
a1877 1
ar5k_ar5210_isHwCipherSupported(hal, cipher)
d1891 1
a1891 1
ar5k_ar5210_getKeyCacheSize(hal)
d1898 1
a1898 1
ar5k_ar5210_resetKeyCacheEntry(hal, entry)
d1913 1
a1913 1
ar5k_ar5210_isKeyCacheEntryValid(hal, entry)
d1930 1
a1930 1
ar5k_ar5210_setKeyCacheEntry(hal, entry, keyval, mac, xor_notused)
d1977 1
a1977 1
	return (ar5k_ar5210_setKeyCacheEntryMac(hal, entry, mac));
d1981 1
a1981 1
ar5k_ar5210_setKeyCacheEntryMac(hal, entry, mac)
d2012 1
a2012 1
ar5k_ar5210_setPowerMode(hal, mode, set_chip, sleep_duration)
d2077 1
a2077 1
ar5k_ar5210_getPowerMode(hal)
d2084 1
a2084 1
ar5k_ar5210_queryPSPollSupport(hal)
d2092 1
a2092 1
ar5k_ar5210_initPSPoll(hal)
d2102 1
a2102 1
ar5k_ar5210_enablePSPoll(hal, bssid, assoc_id)
d2115 1
a2115 1
ar5k_ar5210_disablePSPoll(hal)
d2130 1
a2130 1
ar5k_ar5210_beaconInit(hal, next_beacon, interval)
d2169 1
a2169 1
ar5k_ar5210_setStationBeaconTimers(hal, state, tsf, dtim_count, cfp_count)
d2233 1
a2233 1
ar5k_ar5210_resetStationBeaconTimers(hal)
d2250 1
a2250 1
ar5k_ar5210_waitForBeaconDone(hal, phys_addr)
d2285 1
a2285 1
ar5k_ar5210_isInterruptPending(hal)
d2292 1
a2292 1
ar5k_ar5210_getPendingInterrupts(hal, interrupt_mask)
d2329 1
a2329 1
ar5k_ar5210_getInterrupts(hal)
d2337 1
a2337 1
ar5k_ar5210_setInterrupts(hal, new_mask)
@


1.18
log
@bye bye unportable bitfields
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.17 2005/04/06 09:14:53 reyk Exp $        */
a1011 3
	/* Clear descriptor */
	bzero(tx_desc, sizeof(struct ar5k_ar5210_tx_desc));

a1320 5

	/* Reset descriptor */
	desc->ds_ctl0 = 0;
	desc->ds_ctl1 = 0;
	bzero(&desc->ds_hw[0], sizeof(struct ar5k_ar5210_rx_status));
@


1.17
log
@pad keys with zeros to a supported key length. this is bad but seems
to be the default WEP behaviour for string-based keys and allows
commands like "ifconfig ath0 nwkey yuck" to work...
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.16 2005/03/20 04:21:55 reyk Exp $        */
d1007 1
d1021 2
a1022 24
	switch (type) {
	case HAL_PKT_TYPE_NORMAL:
		tx_desc->frame_type = AR5K_AR5210_DESC_TX_FRAME_TYPE_NORMAL;
		break;

	case HAL_PKT_TYPE_ATIM:
		tx_desc->frame_type = AR5K_AR5210_DESC_TX_FRAME_TYPE_ATIM;
		break;

	case HAL_PKT_TYPE_PSPOLL:
		tx_desc->frame_type = AR5K_AR5210_DESC_TX_FRAME_TYPE_PSPOLL;
		break;

	case HAL_PKT_TYPE_BEACON:
	case HAL_PKT_TYPE_PROBE_RESP:
		tx_desc->frame_type = AR5K_AR5210_DESC_TX_FRAME_TYPE_NO_DELAY;
		break;

	case HAL_PKT_TYPE_PIFS:
		tx_desc->frame_type = AR5K_AR5210_DESC_TX_FRAME_TYPE_PIFS;
		break;

	default:
		/* Invalid packet type (possibly not supported) */
a1023 1
	}
d1025 2
a1026 1
	if ((tx_desc->frame_len = packet_length) != packet_length)
d1029 20
a1048 2
	if ((tx_desc->header_len = header_length) != header_length)
		return (AH_FALSE);
d1050 1
a1050 4
	tx_desc->xmit_rate = tx_rate0;
	tx_desc->ant_mode_xmit = antenna_mode ? 1 : 0;
	tx_desc->clear_dest_mask = flags & HAL_TXDESC_CLRDMASK ? 1 : 0;
	tx_desc->inter_req = flags & HAL_TXDESC_INTREQ ? 1 : 0;
d1056 5
a1060 2
		tx_desc->encrypt_key_valid = 1;
		tx_desc->encrypt_key_index = key_index;
d1067 2
a1068 2
		tx_desc->rts_cts_enable = 1;
		tx_desc->rts_duration = rtscts_duration;
d1090 2
a1091 1
	if ((tx_desc->buf_len = segment_length) != segment_length)
d1095 1
a1095 1
		tx_desc->frame_len = 0;
d1097 2
a1098 1
	tx_desc->more = last_segment == AH_TRUE ? 0 : 1;
d1135 1
a1135 1
	if (tx_status->done == 0)
d1141 16
a1156 7
	desc->ds_us.tx.ts_seqnum = tx_status->seq_num;
	desc->ds_us.tx.ts_tstamp = tx_status->send_timestamp;
	desc->ds_us.tx.ts_shortretry = tx_status->short_retry_count;
	desc->ds_us.tx.ts_longretry = tx_status->long_retry_count;
	desc->ds_us.tx.ts_rssi = tx_status->ack_sig_strength;
	desc->ds_us.tx.ts_rate = tx_desc->xmit_rate;
	desc->ds_us.tx.ts_antenna = 0;
d1158 8
a1165 3

	if (tx_status->frame_xmit_ok == 0) {
		if (tx_status->excessive_retries)
d1168 2
a1169 1
		if (tx_status->fifo_underrun)
d1172 2
a1173 1
		if (tx_status->filtered)
a1175 7
#if 0
	/*
	 * Reset descriptor
	 */
	bzero(tx_desc, sizeof(struct ar5k_ar5210_tx_desc));
	bzero(tx_status, sizeof(struct ar5k_ar5210_tx_status));
#endif
d1332 2
a1333 1
	if ((rx_desc->buf_len = size) != size)
d1337 1
a1337 1
		rx_desc->inter_req = 1;
a1348 1
	u_int32_t now, tstamp;
d1354 1
a1354 1
	if (!rx_status->done)
d1360 15
a1374 11
	now = (AR5K_REG_READ(AR5K_AR5210_TSF_L32) >> 10) & 0xffff;
	tstamp = ((now & 0x1fff) < rx_status->receive_timestamp) ?
	    (((now - 0x2000) & 0xffff) |
		(u_int32_t)rx_status->receive_timestamp) :
	    (now | (u_int32_t)rx_status->receive_timestamp);
	desc->ds_us.rx.rs_tstamp = rx_status->receive_timestamp & 0x7fff;
	desc->ds_us.rx.rs_datalen = rx_status->data_len;
	desc->ds_us.rx.rs_rssi = rx_status->receive_sig_strength;
	desc->ds_us.rx.rs_rate = rx_status->receive_rate;
	desc->ds_us.rx.rs_antenna = rx_status->receive_antenna ? 1 : 0;
	desc->ds_us.rx.rs_more = rx_status->more ? 1 : 0;
d1380 6
a1385 1
	if (!rx_status->key_index_valid) {
a1386 2
	} else {
		desc->ds_us.rx.rs_keyix = rx_status->key_index;
d1392 4
a1395 2
	if (!rx_status->frame_receive_ok) {
		if (rx_status->crc_error)
d1398 6
a1403 1
		if (rx_status->phy_error) {
d1405 3
a1407 1
			desc->ds_us.rx.rs_phyerr = rx_status->phy_error;
d1410 2
a1411 4
		if (rx_status->fifo_overrun)
			desc->ds_us.rx.rs_status |= HAL_RXERR_FIFO;

		if (rx_status->decrypt_crc_error)
@


1.16
log
@some fixes for wep and reset.

btw.: this is a commit using an ar5212 in 11b mode...

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.15 2005/03/18 14:36:39 reyk Exp $        */
d1931 1
a1931 1
	case 5:
d1937 1
a1937 1
	case 13:
d1946 1
a1946 1
	case 16:
@


1.15
log
@ignore bmiss interrupts for now.
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.14 2005/03/10 08:30:55 reyk Exp $        */
d1880 1
a1880 1
	return (AR5K_AR5210_KEYTABLE_SIZE);
d1893 1
a1893 1
		AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE(entry) + (i << 2), 0);
a1902 2
	int offset;

d1908 1
a1908 2
	offset = (AR5K_AR5210_KEYCACHE_SIZE - 1) << 2;
	if (AR5K_REG_READ(AR5K_AR5210_KEYTABLE(entry) + offset) &
d1910 1
a1910 1
		return AH_TRUE;
d1923 1
a1923 1
	int elements = AR5K_AR5210_KEYCACHE_SIZE - 2;
a1924 1
	int i, offset = 0;
d1928 2
a1929 3
	/*
	 * Store the key type in the last field
	 */
d1932 3
a1934 1
		key_v[elements - 1] = AR5K_AR5210_KEYTABLE_TYPE_40;
d1938 6
a1943 1
		key_v[elements - 1] = AR5K_AR5210_KEYTABLE_TYPE_104;
d1947 6
a1952 1
		key_v[elements - 1] = AR5K_AR5210_KEYTABLE_TYPE_128;
d1960 2
a1961 23
	/*
	 * Write key cache entry
	 */
	for (i = 0; i < elements; i++) {
		if (elements < 5) {
			if (i % 2) {
				key_v[i] = AR5K_LE_READ_2(keyval->wk_key +
				    offset) & 0xffff;
				offset += 2;
			} else {
				key_v[i] = AR5K_LE_READ_4(keyval->wk_key +
				    offset);
				offset += 4;
			}

			if (i == 4 && keyval->wk_len <= 13)
				key_v[i] &= 0xff;
		}

		/* Write value */
		AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE(entry) + (i << 2),
		    key_v[i]);
	}
d1973 1
a1973 1
	int offset;
a1979 3
	offset = AR5K_AR5210_KEYCACHE_SIZE - 2;
	low_id = high_id = 0;

d1981 1
a1981 4
	if (mac != NULL) {
		bcopy(mac, &low_id, 4);
		bcopy(mac + 4, &high_id, 2);
	}
d1983 3
a1985 1
	high_id = 0x0000ffff & htole32(high_id);
d1987 2
a1988 3
	AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE(entry) + (offset++ << 2),
	    htole32(low_id));
	AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE(entry) + (offset << 2), high_id);
@


1.14
log
@fix beacon handling
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.13 2005/02/17 23:52:05 reyk Exp $        */
d2326 3
@


1.13
log
@a new year and a new, less restrictive license. because it has to be
free.

go ahead miod@@
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.12 2005/02/17 23:21:49 reyk Exp $        */
d210 1
a210 1
	memset(&mac, 0xff, sizeof(mac));
d487 2
a488 2
	memcpy(&low_id, &(hal->ah_sta_id[0]), 4);
	memcpy(&high_id, &(hal->ah_sta_id[4]), 2);
d1090 1
a1090 1
	desc->ds_hw[0] = desc->ds_hw[1] = 0;
d1522 1
a1522 1
	memcpy(mac, hal->ah_sta_id, IEEE80211_ADDR_LEN);
d1533 1
a1533 1
	memcpy(hal->ah_sta_id, mac, IEEE80211_ADDR_LEN);
d1535 2
a1536 2
	memcpy(&low_id, mac, 4);
	memcpy(&high_id, mac + 4, 2);
d1612 2
a1613 3
	memcpy(&low_id, bssid, 4);
	memcpy(&high_id, bssid + 4, 2);
	memcpy(&hal->ah_bssid, bssid, IEEE80211_ADDR_LEN);
d1617 1
@


1.12
log
@knf
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.11 2005/02/17 22:32:48 reyk Exp $        */
d4 1
a4 1
 * Copyright (c) 2004 Reyk Floeter <reyk@@vantronix.net>.
d6 3
a8 1
 * All rights reserved.
d10 7
a16 18
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY
 * SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
 * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.11
log
@cosmetic changes, fix regdomain code and beacon handling
@
text
@d1 1
a1 1
/*     $OpenBSD: ar5210.c,v 1.10 2005/02/16 01:31:25 reyk Exp $        */
d256 1
a256 1
	if ((val & AR5K_AR5210_RC_MAC) == 0)
d258 1
d432 1
a432 1
		if ((hal->ah_gpio[0] = ar5k_ar5210_gpioGet(hal, 0)) == 0)
d434 1
a434 1
		else
d436 1
d514 3
a516 3
        AR5K_REG_ENABLE_BITS(AR5K_AR5210_PHY_AGC,			\
            AR5K_AR5210_PHY_AGC_DISABLE);				\
        AR5K_DELAY(10);							\
d520 2
a521 2
        AR5K_REG_DISABLE_BITS(AR5K_AR5210_PHY_AGC,			\
            AR5K_AR5210_PHY_AGC_DISABLE);				\
d695 1
a695 1
	} else
d698 1
d1263 1
a1263 1
	if (index >= 64)
d1265 1
a1265 1
	else if (index >= 32)
d1268 1
a1268 1
	else
d1271 1
d1281 1
a1281 1
	if (index >= 64)
d1283 1
a1283 1
	else if (index >= 32)
d1286 1
a1286 1
	else
d1289 1
d1377 1
a1377 1
	if (!rx_status->key_index_valid)
d1379 1
a1379 1
	else
d1381 1
d1426 1
a1426 1
        printf("(%s: %08x) ", #_x, AR5K_REG_READ(AR5K_AR5210_##_x));
d1841 1
a1841 1
				  AR5K_AR5210_TIME_OUT_ACK), hal->ah_turbo));
d1850 1
a1850 1
		hal->ah_turbo) <= timeout)
d1864 1
a1864 1
				  AR5K_AR5210_TIME_OUT_CTS), hal->ah_turbo));
d1982 2
a1983 1
		AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE(entry) + (i << 2), key_v[i]);
d2036 1
a2036 1
		if (set_chip == AH_TRUE)
d2039 1
d2043 1
a2043 1
		if (set_chip == AH_TRUE)
d2046 1
d2240 1
a2240 1
	    (AR5K_AR5210_RSSI_THR_BM_THR >> AR5K_AR5210_RSSI_THR_BM_THR_S))
d2243 1
d2386 1
a2386 1
	if (int_mask)
d2388 1
d2433 1
a2433 1
	if (enable == AH_TRUE)
d2436 1
a2436 1
	else
d2439 1
@


1.10
log
@fix an invalid condition which returns on an invalid beacon state.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5210.c,v 1.9 2005/01/09 18:18:15 reyk Exp $	*/
d447 1
a447 1
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_BEACON,
d509 1
a509 1
	u_int32_t phy_sig, phy_agc, phy_sat;
d527 2
a528 1
	AR5K_REG_DISABLE_BITS(AR5K_AR5210_BEACON, AR5K_AR5210_BEACON_EN);
d601 1
a601 1
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_BEACON, AR5K_AR5210_BEACON_EN);
d1555 4
d1560 1
a1560 1
		ar5k_regdomain_to_ieee(regdomain)) == AH_TRUE) {
d1617 1
a1620 1
	memcpy(&hal->ah_bssid, bssid, IEEE80211_ADDR_LEN);
d1627 2
a1628 6
	AR5K_REG_WRITE(AR5K_AR5210_BEACON,
	    (AR5K_REG_READ(AR5K_AR5210_BEACON) &
		~AR5K_AR5210_BEACON_TIM) |
	    (((tim_offset ? tim_offset + 4 : 0) <<
		AR5K_AR5210_BEACON_TIM_S) &
		AR5K_AR5210_BEACON_TIM));
d1753 1
a1753 10
	u_int16_t regdomain;
	ieee80211_regdomain_t ieee_regdomain;

	if (ar5k_eeprom_regulation_domain(hal,
		AH_FALSE, ieee_regdomain) == AH_TRUE) {
		regdomain = ar5k_regdomain_from_ieee(ieee_regdomain);
		return (regdomain > 0 ? regdomain : hal->ah_regdomain);
	}

	return (0);
d2153 2
a2154 4
		timer1 = (next_beacon - AR5K_TUNE_DMA_BEACON_RESP) <<
		    0x00000003;
		timer2 = (next_beacon - AR5K_TUNE_SW_BEACON_RESP) <<
		    0x00000003;
d2156 1
d2224 2
a2225 2
		AR5K_AR5210_BEACON_TIM) | AR5K_REG_SM(state->bs_interval,
		    AR5K_AR5210_BEACON_PERIOD));
d2230 2
a2231 3
	if ((state->bs_bmiss_threshold > (AR5K_AR5210_RSSI_THR_BM_THR >>
		 AR5K_AR5210_RSSI_THR_BM_THR_S)) &&
	    (state->bs_bmiss_threshold & 0x00007) != 0)
d2376 2
a2377 1
	AR5K_REG_WRITE(AR5K_AR5210_IER, AR5K_AR5210_IER_ENABLE);
@


1.9
log
@fix regulation domain handling
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5210.c,v 1.8 2004/12/31 01:00:23 reyk Exp $	*/
d2194 1
a2194 1
	if (state->bs_interval > 0)
@


1.8
log
@sync with the latest work and add some stuff needed by the upcoming ar5211/ar5212
support. some further cleanups and changes will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5210.c,v 1.7 2004/11/23 10:13:04 reyk Exp $	*/
d1555 1
a1555 1
		ar5k_regdomain_to_ieee((u_int8_t)regdomain)) == AH_TRUE) {
d1756 2
a1757 2
		AH_FALSE, &ieee_regdomain) == AH_TRUE) {
		regdomain = ar5k_regdomain_from_ieee(&ieee_regdomain);
@


1.7
log
@store number of supported gpio pins
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5210.c,v 1.6 2004/11/11 20:11:28 reyk Exp $	*/
a38 2
u_int32_t	 ar5k_ar5210_chan2athchan(HAL_CHANNEL *);
HAL_BOOL	 ar5k_ar5210_set_channel(struct ath_hal *, HAL_CHANNEL *);
d41 2
a170 1
	AR5K_HAL_FUNCTION(hal, ar5210, regulation_domain);
a174 1
	AR5K_HAL_FUNCTION(hal, ar5210, eeprom_init);
d210 2
a211 2
	    (ar5k_bitswap((AR5K_REG_READ(AR5K_AR5210_PHY(256) >> 28) &
			      0xf), 4) + 1);
d214 5
d256 1
a256 1
        if ((val & AR5K_AR5210_RC_MAC) == 0)
a326 62
u_int32_t
ar5k_ar5210_chan2athchan(channel)
	HAL_CHANNEL *channel;
{
	u_int32_t athchan;

	/*
	 * Convert IEEE channel/MHz to an internal channel value used
	 * by the AR5210 chipset. This has not been verified with
	 * newer chipsets like the AR5212A who have a completely
	 * different RF/PHY part.
	 */
	athchan = (ar5k_bitswap((ieee80211_mhz2ieee(channel->c_channel,
				     channel->c_channel_flags) - 24)
		       / 2, 5) << 1) | (1 << 6) | 0x1;

	return (athchan);
}

HAL_BOOL
ar5k_ar5210_set_channel(hal, channel)
	struct ath_hal *hal;
	HAL_CHANNEL *channel;
{
	u_int32_t data;

	/* Disable phy and wait */
	AR5K_REG_WRITE(AR5K_AR5210_PHY_ACTIVE, AR5K_AR5210_PHY_DISABLE);
	AR5K_DELAY(1000);

	/*
	 * Check bounds supported by the PHY
	 * (don't care about regulation restrictions at this point)
	 */
	if (channel->c_channel < hal->ah_capabilities.cap_range.range_5ghz_min ||
	    channel->c_channel > hal->ah_capabilities.cap_range.range_5ghz_max) {
		AR5K_PRINTF("channel out of supported range (%uMHz)\n",
		    channel->c_channel);
		return (AH_FALSE);
	}

	/*
	 * Set the channel and wait
	 */
	data = ar5k_ar5210_chan2athchan(channel);
	AR5K_REG_WRITE(AR5K_AR5210_PHY(0x27), data);
	AR5K_REG_WRITE(AR5K_AR5210_PHY(0x30), 0);
	AR5K_DELAY(1000);

	/*
	 * Activate phy and wait
	 */
	AR5K_REG_WRITE(AR5K_AR5210_PHY_ACTIVE, AR5K_AR5210_PHY_ENABLE);
	AR5K_DELAY(1000);

	hal->ah_current_channel.channel = channel->c_channel;
	hal->ah_current_channel.channelFlags = channel->c_channel_flags;
	hal->ah_turbo = channel->c_channel_flags == CHANNEL_T ? AH_TRUE : AH_FALSE;

	return (AH_TRUE);
}

d367 3
d391 1
a391 1
		case INI_READ:
d396 1
a396 1
		case INI_WRITE:
d408 16
a423 1
	if (ar5k_ar5210_perCalibration(hal, channel) == AH_FALSE)
d429 2
a430 1
	if (hal->ah_capabilities.cap_eeprom.ee_rfkill != 0) {
d508 14
d534 2
a535 1
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_PHY_AGC, AR5K_AR5210_PHY_AGC_DISABLE);
d537 53
a589 1
	if (ar5k_ar5210_set_channel(hal, channel) != AH_TRUE)
d592 2
a593 1
	AR5K_REG_DISABLE_BITS(AR5K_AR5210_PHY_AGC, AR5K_AR5210_PHY_AGC_DISABLE);
d596 19
a614 1
	 * Enable noise floor calibration and wait until completion
d617 1
a617 1
	    AR5K_AR5210_PHY_AGC_CAL);
d620 1
a620 1
		AR5K_AR5210_PHY_AGC_CAL, 0, AH_FALSE) == AH_FALSE) {
d626 11
d638 1
a638 1
	 * XXX Check the current noise floor?
d641 1
a641 1
	    AR5K_AR5210_PHY_AGC_NF);
d643 23
a665 6
	/*
	 * Re-enable RX/TX and beacons
	 */
	AR5K_REG_DISABLE_BITS(AR5K_AR5210_DIAG_SW,
	    AR5K_AR5210_DIAG_SW_DIS_TX | AR5K_AR5210_DIAG_SW_DIS_RX);
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_BEACON, AR5K_AR5210_BEACON_EN);
d731 1
a731 1
		return (EINVAL);
d743 1
a743 1
			return (AH_FALSE);
d746 1
a746 1
	return (0);
d797 2
a798 1
		AR5K_REG_WRITE(initial[i].mode_register, turbo == AH_TRUE ?
d1061 1
d1074 1
a1074 1
	if (flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
a1165 1

d1417 1
d1501 1
d1554 1
a1554 1
	if (ar5k_ar5210_regulation_domain(hal, AH_TRUE,
d1755 1
a1755 1
	if (ar5k_ar5210_regulation_domain(hal,
d1775 1
a1775 1
	if (ar5k_ar5210_eeprom_read(hal, AR5K_AR5210_EEPROM_MAGIC, &magic) != 0)
d1778 1
a1778 1
	return (magic == AR5K_AR5210_EEPROM_MAGIC_VALUE ? AH_TRUE : AH_FALSE);
d2030 1
a2030 1
	int set_chip;
d2037 1
a2037 1
		if (set_chip)
d2043 1
a2043 1
		if (set_chip)
d2049 1
a2049 1
		if (!set_chip)
d2053 1
a2398 6
	/*
	 * Get the value stored in the EEPROM
	 */
	if (ar5k_ar5210_eeprom_init(hal) != 0)
		return (AH_FALSE);

a2440 35
HAL_BOOL
ar5k_ar5210_regulation_domain(hal, write, regdomain)
	struct ath_hal *hal;
	HAL_BOOL write;
	ieee80211_regdomain_t *regdomain;
{
	/* Read current value */
	if (write != AH_TRUE) {
		memcpy(regdomain,
		    &hal->ah_capabilities.cap_regdomain.reg_current,
		    sizeof(ieee80211_regdomain_t));
		return (AH_TRUE);
	}

	/* Try to write a new value */
	memcpy(&hal->ah_capabilities.cap_regdomain.reg_current, regdomain,
	    sizeof(ieee80211_regdomain_t));

	if (hal->ah_capabilities.cap_eeprom.ee_protect &
	    AR5K_AR5210_EEPROM_PROTECT_128_191)
		return (AH_FALSE);

	hal->ah_capabilities.cap_eeprom.ee_regdomain =
	    ar5k_regdomain_from_ieee(regdomain);

	AR5K_PRINTF("writing new regulation domain to EEPROM: 0x%04x\n",
	    hal->ah_capabilities.cap_eeprom.ee_regdomain);

	if (ar5k_ar5210_eeprom_write(hal, AR5K_AR5210_EEPROM_REG_DOMAIN,
		hal->ah_capabilities.cap_eeprom.ee_regdomain) != 0)
		return (AH_FALSE);

	return (AH_TRUE);
}

a2443 36

int
ar5k_ar5210_eeprom_init(hal)
	struct ath_hal *hal;
{
	int ret;

	/* Check if EEPROM is busy */
	if (ar5k_ar5210_eeprom_is_busy(hal) == AH_TRUE)
		return (EBUSY);

	/*
	 * Read values from EEPROM and store them in the capability structure
	 */
	if ((ret = ar5k_ar5210_eeprom_read(hal, AR5K_AR5210_EEPROM_MAGIC,
		 &hal->ah_capabilities.cap_eeprom.ee_magic)) != 0)
		return (ret);

	if (hal->ah_capabilities.cap_eeprom.ee_magic !=
	    AR5K_AR5210_EEPROM_MAGIC_VALUE)
		return (EFTYPE);

	if ((ret = ar5k_ar5210_eeprom_read(hal, AR5K_AR5210_EEPROM_INFO_VERSION,
		 &hal->ah_capabilities.cap_eeprom.ee_version)) != 0)
		return (ret);

	if ((ret = ar5k_ar5210_eeprom_read(hal, AR5K_AR5210_EEPROM_PROTECT,
		 &hal->ah_capabilities.cap_eeprom.ee_protect)) != 0)
		return (ret);

	if ((ret = ar5k_ar5210_eeprom_read(hal, AR5K_AR5210_EEPROM_REG_DOMAIN,
		 &hal->ah_capabilities.cap_eeprom.ee_regdomain)) != 0)
		return (ret);

	return (0);
}
@


1.6
log
@some fixes for beeing compatible with gcc3 as noticed by some people.
thanks to Joerg Sonnenberger and Nathan Binkert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5210.c,v 1.5 2004/11/08 16:48:25 reyk Exp $	*/
d2341 3
@


1.5
log
@use __packed instead of __attribute__ ((__packed__)) (ok miod@@), check
possible NULL mac in the keycache function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5210.c,v 1.4 2004/11/03 16:40:46 reyk Exp $	*/
d273 1
a273 1
			AR5K_PRINTF("failed to reset the PCI chipset\n");
d283 1
a283 1
		AR5K_PRINTF("failed to resume the AR5210 chipset\n");
d293 1
a293 1
		AR5K_PRINTF("failed to reset the AR5210 chipset\n");
d302 1
a302 1
		AR5K_PRINTF("failed to reset the AR5210 + PCI chipset\n");
d311 1
a311 1
		AR5K_PRINTF("failed to resume the AR5210 (again)\n");
d317 1
a317 1
		AR5K_PRINTF("failed to warm reset the AR5210\n");
d336 2
a337 2
	athchan = (ar5k_bitswap((ieee80211_mhz2ieee(channel->channel,
				     channel->channelFlags) - 24)
d358 4
a361 4
	if (channel->channel < hal->ah_capabilities.cap_range.range_5ghz_min ||
	    channel->channel > hal->ah_capabilities.cap_range.range_5ghz_max) {
		AR5K_PRINTF("channel out of supported range (%u MHz)\n",
		    channel->channel);
d379 3
a381 3
	hal->ah_current_channel.channel = channel->channel;
	hal->ah_current_channel.channelFlags = channel->channelFlags;
	hal->ah_turbo = channel->channelFlags == CHANNEL_T ? AH_TRUE : AH_FALSE;
d427 1
a427 1
		channel->channelFlags & IEEE80211_CHAN_T ?
d575 2
a576 1
		AR5K_PRINTF("calibration timeout\n");
@


1.4
log
@knf, use positive error values (suggested by miod@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5210.c,v 1.3 2004/11/02 14:05:49 reyk Exp $	*/
d1826 1
a1826 1
		AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE(entry) + (i * 4), 0);
d1843 1
a1843 1
	offset = (AR5K_AR5210_KEYCACHE_SIZE - 1) * 4;
d1906 1
a1906 1
		AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE(entry) + (i * 4), key_v[i]);
d1927 1
d1929 5
a1933 3
	/* XXX big endian problems? */
	bcopy(mac, &low_id, 4);
	bcopy(mac + 4, &high_id, 2);
d1937 1
a1937 1
	AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE(entry) + (offset++ * 4),
d1939 1
a1939 1
	AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE(entry) + (offset * 4), high_id);
@


1.3
log
@spacing, beautify dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5210.c,v 1.2 2004/11/02 09:31:59 reyk Exp $	*/
a33 3

#ifdef AR5K_SUPPORT_AR5210

d38 4
a41 4
HAL_BOOL 	 ar5k_ar5210_nic_wakeup(struct ath_hal *, HAL_BOOL, HAL_BOOL);
u_int32_t 	 ar5k_ar5210_chan2athchan(HAL_CHANNEL *);
HAL_BOOL 	 ar5k_ar5210_set_channel(struct ath_hal *, HAL_CHANNEL *);
void 		 ar5k_ar5210_init_tx_queue(struct ath_hal *, u_int, HAL_BOOL);
d197 2
a198 2
	if(ar5k_ar5210_nic_wakeup(hal, AH_FALSE, AH_TRUE) != AH_TRUE)
		return(NULL);
d209 1
a209 1
	for(i = 0; i < 4; i++)
d221 1
a221 1
	return(hal);
d253 1
a253 1
        if((val & AR5K_AR5210_RC_MAC) == 0)
d256 1
a256 1
	return(ret);
d269 1
a269 1
	if(initial == AH_TRUE) {
d271 2
a272 1
		if(ar5k_ar5210_nic_reset(hal, AR5K_AR5210_RC_PCI) == AH_FALSE) {
d274 1
a274 1
			return(AH_FALSE);
d281 2
a282 1
	if(ar5k_ar5210_setPowerMode(hal, HAL_PM_AWAKE, AH_TRUE, 0) == AH_FALSE) {
d284 1
a284 1
		return(AH_FALSE);
d292 1
a292 1
	if(ar5k_ar5210_nic_reset(hal, AR5K_AR5210_RC_CHIP) == AH_FALSE) {
d294 1
a294 1
		return(AH_FALSE);
d300 2
a301 2
	if(ar5k_ar5210_nic_reset(hal, AR5K_AR5210_RC_CHIP |
	       AR5K_AR5210_RC_PCI) == AH_FALSE) {
d303 1
a303 1
		return(AH_FALSE);
d309 2
a310 1
	if(ar5k_ar5210_setPowerMode(hal, HAL_PM_AWAKE, AH_TRUE, 0) == AH_FALSE) {
d312 1
a312 1
		return(AH_FALSE);
d316 1
a316 1
	if(ar5k_ar5210_nic_reset(hal, 0) == AH_FALSE) {
d318 1
a318 1
		return(AH_FALSE);
d321 1
a321 1
	return(AH_TRUE);
d340 1
a340 1
	return(athchan);
d358 1
a358 1
	if(channel->channel < hal->ah_capabilities.cap_range.range_5ghz_min ||
d362 1
a362 1
		return(AH_FALSE);
d383 1
a383 1
	return(AH_TRUE);
d391 1
a391 1
	switch(mode) {
d393 1
a393 1
		return(&hal->ah_rt_11a);
d395 1
a395 1
		return(&hal->ah_rt_turbo);
d399 1
a399 1
		return(NULL);
d402 1
a402 1
	return(NULL);
d426 4
a429 4
	if(ar5k_ar5210_nic_wakeup(hal,
	       channel->channelFlags & IEEE80211_CHAN_T ?
	       AH_TRUE : AH_FALSE, AH_FALSE) == AH_FALSE)
		return(AH_FALSE);
d440 2
a441 2
	for(i = 0; i < AR5K_ELEMENTS(initial); i++) {
		if(change_channel == AH_TRUE &&
d446 1
a446 1
		switch(initial[i].ini_mode) {
d464 2
a465 2
	if(ar5k_ar5210_perCalibration(hal, channel) == AH_FALSE)
		return(AH_FALSE);
d470 1
a470 1
	if(hal->ah_capabilities.cap_eeprom.ee_rfkill != 0) {
d480 2
a481 2
	for(i = 0; i < hal->ah_capabilities.cap_queues.q_tx_num; i++) {
		if(ar5k_ar5210_resetTxQueue(hal, i) == AH_FALSE) {
d483 1
a483 1
			return(AH_FALSE);
d490 1
a490 1
	return(AH_TRUE);
d502 1
a502 1
	switch(hal->ah_op_mode) {
d562 2
a563 2
	if(ar5k_ar5210_set_channel(hal, channel) != AH_TRUE)
		return(AH_FALSE);
d573 2
a574 2
	if(ar5k_register_timeout(hal, AR5K_AR5210_PHY_AGCCTL,
	       AR5K_AR5210_PHY_AGC_CAL, 0, AH_FALSE) == AH_FALSE) {
d576 1
a576 1
		return(AH_FALSE);
d592 1
a592 1
	return(AH_TRUE);
d614 2
a615 2
	if(increase == AH_FALSE) {
		if(--trigger_level < AR5K_TUNE_MIN_TX_FIFO_THRES)
d633 1
a633 1
	return(status);
d647 1
a647 1
	switch(queue_type) {
d656 1
a656 1
		return(-EINVAL);
d665 4
a668 3
	if(queue_info != NULL) {
		if(ar5k_ar5210_setTxQueueProps(hal, queue, queue_info) != AH_TRUE)
			return(AH_FALSE);
d671 1
a671 1
	return(0);
d682 2
a683 2
	if(hal->ah_txq[queue].tqi_type == HAL_TX_QUEUE_INACTIVE)
		return(AH_FALSE);
d690 1
a690 1
	return(AH_TRUE);
d703 1
a703 1
	return(AH_FALSE);
d721 1
a721 1
	for(i = 0; i < AR5K_ELEMENTS(initial); i++)
d739 2
a740 2
	if(tq->tqi_type != HAL_TX_QUEUE_DATA)
		return(AH_TRUE);
d749 1
a749 1
	if(hal->ah_software_retry == AH_TRUE) {
d764 1
a764 1
	while(cw_min < hal->ah_cw_min)
d779 1
a779 1
	return(AH_TRUE);
d794 1
a794 1
	switch(hal->ah_txq[queue].tqi_type) {
d803 1
a803 1
		return(0xffffffff);
d806 1
a806 1
	return(AR5K_REG_READ(tx_reg));
d822 1
a822 1
	switch(hal->ah_txq[queue].tqi_type) {
d831 1
a831 1
		return(AH_FALSE);
d837 1
a837 1
	return(AH_TRUE);
d854 1
a854 1
	switch(hal->ah_txq[queue].tqi_type) {
d873 1
a873 1
		return(AH_FALSE);
d879 1
a879 1
	return(AH_TRUE);
d896 1
a896 1
	switch(hal->ah_txq[queue].tqi_type) {
d909 1
a909 1
		return(AH_FALSE);
d915 1
a915 1
	return(AH_TRUE);
d946 2
a947 2
	if(tx_tries0 == 0)
		return(AH_FALSE);
d949 1
a949 1
	switch(type) {
d973 1
a973 1
		return(AH_FALSE);
d976 2
a977 2
	if((tx_desc->frame_len = packet_length) != packet_length)
		return(AH_FALSE);
d979 2
a980 2
	if((tx_desc->header_len = header_length) != header_length)
		return(AH_FALSE);
d989 1
a989 1
	if(key_index != HAL_TXKEYIX_INVALID) {
d997 1
a997 1
	if(flags & (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA)) {
d1002 1
a1002 1
	return(AH_TRUE);
d1021 2
a1022 2
	if((tx_desc->buf_len = segment_length) != segment_length)
		return(AH_FALSE);
d1024 1
a1024 1
	if(first_segment != AH_TRUE)
d1029 1
a1029 1
	return(AH_TRUE);
d1049 1
a1049 1
	return(AH_FALSE);
d1064 2
a1065 2
	if(tx_status->done == 0)
		return(HAL_EINPROGRESS);
d1079 2
a1080 2
	if(tx_status->frame_xmit_ok == 0) {
		if(tx_status->excessive_retries)
d1083 1
a1083 1
		if(tx_status->fifo_underrun)
d1086 1
a1086 1
		if(tx_status->filtered)
d1098 1
a1098 1
	return(HAL_OK);
d1105 1
a1105 1
	return(AH_FALSE);
d1116 1
a1116 1
	return(AR5K_REG_READ(AR5K_AR5210_RXDP));
d1145 3
a1147 3
	for(i = 2000;
	    i > 0 && (AR5K_REG_READ(AR5K_AR5210_CR) & AR5K_AR5210_CR_RXE) != 0;
	    i--)
d1150 1
a1150 1
	return(i > 0 ? AH_TRUE : AH_FALSE);
d1183 3
a1185 3
	if(index >= 64)
		return(AH_FALSE);
	else if(index >= 32)
d1192 1
a1192 1
	return(AH_TRUE);
d1200 3
a1202 3
	if(index >= 64)
		return(AH_FALSE);
	else if(index >= 32)
d1209 1
a1209 1
	return(AH_TRUE);
d1216 1
a1216 1
	return(AR5K_REG_READ(AR5K_AR5210_RX_FILTER));
d1227 1
a1227 1
	if(filter & HAL_RX_FILTER_PHYRADAR) {
d1251 2
a1252 2
	if((rx_desc->buf_len = size) != size)
		return(AH_FALSE);
d1254 1
a1254 1
	if(flags & HAL_RXDESC_INTREQ)
d1257 1
a1257 1
	return(AH_TRUE);
d1273 2
a1274 2
	if(!rx_status->done)
		return(HAL_EINPROGRESS);
d1281 3
a1283 2
	    (((now - 0x2000) & 0xffff) | (u_int32_t) rx_status->receive_timestamp) :
	    (now | (u_int32_t) rx_status->receive_timestamp);
d1295 1
a1295 1
	if(!rx_status->key_index_valid)
d1303 2
a1304 2
	if(!rx_status->frame_receive_ok) {
		if(rx_status->crc_error)
d1307 1
a1307 1
		if(rx_status->phy_error) {
d1312 1
a1312 1
		if(rx_status->fifo_overrun)
d1315 1
a1315 1
		if(rx_status->decrypt_crc_error)
d1319 1
a1319 1
	return(HAL_OK);
d1341 1
a1341 1
#define AR5K_PRINT_REGISTER(_x) 					\
d1438 1
a1438 1
	return(AH_FALSE);
d1466 1
a1466 1
	return(AH_TRUE);
d1476 2
a1477 2
	if(ar5k_ar5210_regulation_domain(hal, AH_TRUE,
	       ar5k_regdomain_to_ieee((u_int8_t)regdomain)) == AH_TRUE) {
d1479 1
a1479 1
		return(AH_TRUE);
d1482 1
a1482 1
	*status = -EIO;
d1484 1
a1484 1
	return(AH_FALSE);
d1499 1
a1499 1
	switch(state) {
d1539 1
a1539 1
	if(assoc_id == 0) {
d1559 2
a1560 2
	if(gpio > AR5K_AR5210_NUM_GPIO)
		return(AH_FALSE);
d1566 1
a1566 1
	return(AH_TRUE);
d1574 2
a1575 2
	if(gpio > AR5K_AR5210_NUM_GPIO)
		return(AH_FALSE);
d1581 1
a1581 1
	return(AH_TRUE);
d1589 2
a1590 2
	if(gpio > AR5K_AR5210_NUM_GPIO)
		return(0xffffffff);
d1593 2
a1594 2
	return(((AR5K_REG_READ(AR5K_AR5210_GPIODI) &
		    AR5K_AR5210_GPIOD_MASK) >> gpio) & 0x1);
d1605 2
a1606 2
	if(gpio > AR5K_AR5210_NUM_GPIO)
		return(0xffffffff);
d1616 1
a1616 1
	return(AH_TRUE);
d1627 1
a1627 1
	if(gpio > AR5K_AR5210_NUM_GPIO)
d1651 1
a1651 1
	return(AR5K_REG_READ(AR5K_AR5210_TSF_L32));
d1659 1
a1659 1
	return(AR5K_REG_READ(AR5K_AR5210_TSF_L32) | (tsf << 32));
d1677 2
a1678 1
	if(ar5k_ar5210_regulation_domain(hal, AH_FALSE, &ieee_regdomain) == AH_TRUE) {
d1680 1
a1680 1
		return(regdomain > 0 ? regdomain : hal->ah_regdomain);
d1683 1
a1683 1
	return(0);
d1697 2
a1698 2
	if(ar5k_ar5210_eeprom_read(hal, AR5K_AR5210_EEPROM_MAGIC, &magic) != 0)
		return(AH_FALSE);
d1700 1
a1700 1
	return(magic == AR5K_AR5210_EEPROM_MAGIC_VALUE ? AH_TRUE : AH_FALSE);
d1719 1
a1719 1
	return(HAL_RFGAIN_INACTIVE);
d1728 2
a1729 2
	if(slot_time < HAL_SLOT_TIME_9 || slot_time > HAL_SLOT_TIME_MAX)
		return(AH_FALSE);
d1734 1
a1734 1
	return(AH_TRUE);
d1741 2
a1742 2
	return(ar5k_clocktoh(AR5K_REG_READ(AR5K_AR5210_SLOT_TIME) & 0xffff,
		   hal->ah_turbo));
d1750 3
a1752 3
	if(ar5k_clocktoh(AR5K_REG_MS(0xffffffff, AR5K_AR5210_TIME_OUT_ACK),
	       hal->ah_turbo) <= timeout)
		return(AH_FALSE);
d1757 1
a1757 1
	return(AH_TRUE);
d1764 2
a1765 2
	return(ar5k_clocktoh(AR5K_REG_MS(AR5K_REG_READ(AR5K_AR5210_TIME_OUT),
				 AR5K_AR5210_TIME_OUT_ACK), hal->ah_turbo));
d1773 3
a1775 3
	if(ar5k_clocktoh(AR5K_REG_MS(0xffffffff, AR5K_AR5210_TIME_OUT_CTS),
	       hal->ah_turbo) <= timeout)
		return(AH_FALSE);
d1780 1
a1780 1
	return(AH_TRUE);
d1787 2
a1788 2
	return(ar5k_clocktoh(AR5K_REG_MS(AR5K_REG_READ(AR5K_AR5210_TIME_OUT),
				 AR5K_AR5210_TIME_OUT_CTS), hal->ah_turbo));
d1803 2
a1804 2
	if(cipher == HAL_CIPHER_WEP)
		return(AH_TRUE);
d1806 1
a1806 1
	return(AH_FALSE);
d1813 1
a1813 1
	return(AR5K_AR5210_KEYTABLE_SIZE);
d1825 1
a1825 1
	for(i = 0; i < AR5K_AR5210_KEYCACHE_SIZE; i++)
d1828 1
a1828 1
	return(AH_FALSE);
d1844 1
a1844 1
	if(AR5K_REG_READ(AR5K_AR5210_KEYTABLE(entry) + offset) &
d1848 1
a1848 1
	return(AH_FALSE);
d1868 1
a1868 1
	switch(keyval->wk_len) {
d1883 1
a1883 1
		return(AH_FALSE);
d1889 3
a1891 3
	for(i = 0; i < elements; i++) {
		if(elements < 5) {
			if(i % 2) {
d1901 1
a1901 1
			if(i == 4 && keyval->wk_len <= 13)
d1909 1
a1909 1
	return(ar5k_ar5210_setKeyCacheEntryMac(hal, entry, mac));
d1938 1
a1938 1
	return(AH_TRUE);
d1954 1
a1954 1
	switch(mode) {
d1956 1
a1956 1
		if(set_chip)
d1962 1
a1962 1
		if(set_chip)
d1968 1
a1968 1
		if(!set_chip)
d1973 1
a1973 1
		for(i = 5000; i > 0; i--) {
d1975 2
a1976 2
			if((AR5K_REG_READ(AR5K_AR5210_PCICFG) &
			       AR5K_AR5210_PCICFG_SPWR_DN) == 0)
d1986 2
a1987 2
		if(i <= 0)
			return(AH_FALSE);
d1993 1
a1993 1
		return(AH_FALSE);
d2004 1
a2004 1
	return(AH_TRUE);
d2011 1
a2011 1
	return(hal->ah_power_mode);
d2019 1
a2019 1
	return(AH_TRUE);
d2029 1
a2029 1
	return(AH_FALSE);
d2042 1
a2042 1
	return(AH_TRUE);
d2053 1
a2053 1
	return(AH_TRUE);
d2071 1
a2071 1
	switch(hal->ah_op_mode) {
d2112 1
a2112 1
	if(state->bs_interval > 0)
d2118 1
a2118 1
	if(state->bs_cfp_period > 0) {
d2147 3
a2149 2
	AR5K_REG_WRITE(AR5K_AR5210_BEACON, (AR5K_REG_READ(AR5K_AR5210_BEACON) &~
			   (AR5K_AR5210_BEACON_PERIOD | AR5K_AR5210_BEACON_TIM)) |
d2157 2
a2158 2
	if((state->bs_bmiss_threshold >
	       (AR5K_AR5210_RSSI_THR_BM_THR >> AR5K_AR5210_RSSI_THR_BM_THR_S)) &&
d2191 5
a2195 5
	for(i = (AR5K_TUNE_BEACON_INTERVAL / 2); i > 0 &&
		(AR5K_REG_READ(AR5K_AR5210_BSR) &
		    AR5K_AR5210_BSR_TXQ1F) != 0 &&
		(AR5K_REG_READ(AR5K_AR5210_CR) &
		    AR5K_AR5210_CR_TXE1) != 0; i--);
d2198 1
a2198 1
	if(i <= 0) {
d2206 1
a2206 1
		return(AH_FALSE);
d2209 1
a2209 1
	return(AH_TRUE);
d2220 1
a2220 1
	return(AR5K_REG_READ(AR5K_AR5210_INTPEND) == 0 ? AH_FALSE : AH_TRUE);
d2230 1
a2230 1
	if((data = AR5K_REG_READ(AR5K_AR5210_ISR)) == HAL_INT_NOCARD) {
d2232 1
a2232 1
		return(AH_FALSE);
d2240 1
a2240 1
	if(data & (AR5K_AR5210_ISR_RXOK | AR5K_AR5210_ISR_RXERR))
d2242 1
a2242 1
	if(data & (AR5K_AR5210_ISR_TXOK | AR5K_AR5210_ISR_TXERR))
d2244 1
a2244 1
	if(data & AR5K_AR5210_ISR_FATAL)
d2250 1
a2250 1
	if(((*interrupt_mask) & AR5K_AR5210_ISR_RXPHY) &&
d2254 1
a2254 1
	return(AH_TRUE);
d2262 1
a2262 1
	return(hal->ah_imr);
d2286 1
a2286 1
	if(new_mask & HAL_INT_RX)
d2292 1
a2292 1
	if(new_mask & HAL_INT_TX)
d2306 1
a2306 1
	return(old_mask);
d2320 2
a2321 2
	if(ar5k_ar5210_eeprom_init(hal) != 0)
		return(AH_FALSE);
d2338 1
a2338 1
	return(AH_TRUE);
d2352 1
a2352 1
	if(enable == AH_TRUE)
d2369 1
a2369 1
	if(write != AH_TRUE) {
d2373 1
a2373 1
		return(AH_TRUE);
d2380 1
a2380 1
	if(hal->ah_capabilities.cap_eeprom.ee_protect &
d2382 1
a2382 1
		return(AH_FALSE);
d2390 3
a2392 3
	if(ar5k_ar5210_eeprom_write(hal, AR5K_AR5210_EEPROM_REG_DOMAIN,
	       hal->ah_capabilities.cap_eeprom.ee_regdomain) != 0)
		return(AH_FALSE);
d2394 1
a2394 1
	return(AH_TRUE);
d2408 2
a2409 2
	if(ar5k_ar5210_eeprom_is_busy(hal) == AH_TRUE)
		return(-EBUSY);
d2414 3
a2416 3
	if((ret = ar5k_ar5210_eeprom_read(hal, AR5K_AR5210_EEPROM_MAGIC,
		&hal->ah_capabilities.cap_eeprom.ee_magic)) != 0)
		return(ret);
d2418 1
a2418 1
	if(hal->ah_capabilities.cap_eeprom.ee_magic !=
d2420 1
a2420 1
		return(-EFTYPE);
d2422 3
a2424 3
	if((ret = ar5k_ar5210_eeprom_read(hal, AR5K_AR5210_EEPROM_INFO_VERSION,
		&hal->ah_capabilities.cap_eeprom.ee_version)) != 0)
		return(ret);
d2426 3
a2428 3
	if((ret = ar5k_ar5210_eeprom_read(hal, AR5K_AR5210_EEPROM_PROTECT,
		&hal->ah_capabilities.cap_eeprom.ee_protect)) != 0)
		return(ret);
d2430 3
a2432 3
	if((ret = ar5k_ar5210_eeprom_read(hal, AR5K_AR5210_EEPROM_REG_DOMAIN,
		&hal->ah_capabilities.cap_eeprom.ee_regdomain)) != 0)
		return(ret);
d2434 1
a2434 1
	return(0);
d2441 1
a2441 1
	return(AR5K_REG_READ(AR5K_AR5210_CFG) & AR5K_AR5210_CFG_EEBS ?
d2461 1
a2461 1
	for(timeout = 10000; timeout > 0; timeout--) {
d2464 3
a2466 3
		if(status & AR5K_AR5210_EEPROM_STAT_RDDONE) {
			if(status & AR5K_AR5210_EEPROM_STAT_RDERR)
				return(-EIO);
d2469 1
a2469 1
			return(0);
d2473 1
a2473 1
	return(-ETIMEDOUT);
d2492 1
a2492 1
	for(timeout = 10000; timeout > 0; timeout--) {
d2495 4
a2498 4
		if(status & AR5K_AR5210_EEPROM_STAT_WRDONE) {
			if(status & AR5K_AR5210_EEPROM_STAT_WRERR)
				return(-EIO);
			return(0);
d2502 1
a2502 1
	return(-ETIMEDOUT);
a2504 1
#endif /* AR5K_SUPPORT_AR5210 */
@


1.2
log
@removed some printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: ar5210.c,v 1.1 2004/11/02 03:01:16 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004 Reyk Floeter <reyk@@vantronix.net>. 
d29 1
a29 1
 * HAL interface for the Atheros AR5000 Wireless LAN chipset 
d48 2
a49 2
 
const void 
d61 2
a62 2
	/* 
	 * Reset functions 
d144 1
a144 1
	 * Power management functions 
d153 2
a154 2
	/* 
	 * Beacon functions 
d162 1
a162 1
	 * Interrupt functions 
d205 1
a205 1
	hal->ah_mac_revision = (AR5K_REG_READ(AR5K_AR5210_SREV) & 
d246 1
a246 1
	
d268 2
a269 2
	/* 
	 * Reset and wakeup the device 
d289 1
a289 1
	AR5K_REG_WRITE(AR5K_AR5210_PHY_FC, 
d355 1
a355 1
	 * Check bounds supported by the PHY 
d360 1
a360 1
		AR5K_PRINTF("channel out of supported range (%u MHz)\n", 
d366 1
a366 1
	 * Set the channel and wait 
d373 2
a374 2
	/* 
	 * Activate phy and wait 
d410 1
a410 1
	 * Free HAL structure, assume interrupts are down 
d426 1
a426 1
	if(ar5k_ar5210_nic_wakeup(hal, 
d454 1
a454 1
			AR5K_REG_WRITE(initial[i].ini_register, 
d464 1
a464 1
	if(ar5k_ar5210_perCalibration(hal, channel) == AH_FALSE) 
d473 1
a473 1
		else 
d506 1
a506 1
		    AR5K_AR5210_STA_ID1_PWR_SV; 
d510 2
a511 2
		pcu_reg |= AR5K_AR5210_STA_ID1_ADHOC | 
		    AR5K_AR5210_STA_ID1_NO_PSPOLL | 
d517 2
a518 2
		pcu_reg |= AR5K_AR5210_STA_ID1_AP | 
		    AR5K_AR5210_STA_ID1_NO_PSPOLL | 
d530 2
a531 2
		
	/* 
d750 3
a752 2
		retry_lg = hal->ah_limit_tx_retries; 
		retry_sh = retry_lg = retry_lg > AR5K_AR5210_RETRY_LMT_SH_RETRY ?
d867 2
a868 1
		    AR5K_AR5210_BCR_TQ1FV | AR5K_AR5210_BCR_TQ1V | AR5K_AR5210_BCR_BDMAE);
d986 1
a986 1
	 * WEP crap 
d994 1
a994 1
	 * RTS/CTS 
d1079 1
a1079 1
		if(tx_status->excessive_retries) 
d1144 1
a1144 1
	for(i = 2000; 
d1184 1
a1184 1
	else if(index >= 32) 
d1201 1
a1201 1
	else if(index >= 32) 
d1275 1
a1275 1
	/* 
d1293 1
a1293 1
	if(!rx_status->key_index_valid) 
d1327 1
a1327 1
	AR5K_REG_ENABLE_BITS(AR5K_AR5210_RX_FILTER, 
d1434 1
a1434 1
         * debugging interface for the binary-only HAL. 
d1500 1
a1500 1
		led |= 
d1509 1
a1509 1
		led |= 
d1543 1
a1543 1
	    (AR5K_REG_READ(AR5K_AR5210_BEACON) & 
d1545 1
a1545 1
	    (((tim_offset ? tim_offset + 4 : 0) << 
d1548 1
a1548 1
	    
d1560 1
a1560 1
	AR5K_REG_WRITE(AR5K_AR5210_GPIOCR, 
d1575 1
a1575 1
	AR5K_REG_WRITE(AR5K_AR5210_GPIOCR, 
d1591 1
a1591 1
	return(((AR5K_REG_READ(AR5K_AR5210_GPIODI) & 
d1631 1
a1631 1
	data = (AR5K_REG_READ(AR5K_AR5210_GPIOCR) & 
d1897 1
a1897 1
			
d1931 2
a1932 1
	AR5K_REG_WRITE(AR5K_AR5210_KEYTABLE(entry) + (offset++ * 4), htole32(low_id));
d1960 2
a1961 1
			AR5K_REG_WRITE(AR5K_AR5210_SCR, AR5K_AR5210_SCR_SLE_SLP);
d1969 1
a1969 1
		
d1972 1
a1972 1
			if((AR5K_REG_READ(AR5K_AR5210_PCICFG) & 
d1981 1
a1981 1
		
d2199 1
a2199 1
		AR5K_REG_WRITE(AR5K_AR5210_BCR, 
d2283 1
a2283 1
		int_mask |= 
d2366 2
a2367 1
		memcpy(regdomain, &hal->ah_capabilities.cap_regdomain.reg_current,
d2377 1
a2377 1
	    AR5K_AR5210_EEPROM_PROTECT_128_191) 
d2380 1
a2380 1
	hal->ah_capabilities.cap_eeprom.ee_regdomain = 
d2383 1
a2383 1
	AR5K_PRINTF("writing new regulation domain to EEPROM: 0x%04x\n", 
d2414 1
a2414 1
	if(hal->ah_capabilities.cap_eeprom.ee_magic != 
d2441 1
a2441 1
int 
d2451 3
a2453 3
	
	/* 
	 * Prime read pump 
d2456 1
a2456 1
	
d2472 1
a2472 1
int 
d2482 2
a2483 2
	
	/* 
d2487 1
a2487 1
	
@


1.1
log
@import of a free hal part for the ath driver as a replacement for the
binary-only hal module found in FreeBSD and NetBSD. OpenBSD's approach
is based on reverse engineering because it is _not_ possible to
include a non-free and binary-only piece of software in a 100% free
operating system. it still lacks some features found in the "official" hal
module but this will be done very soon with a help by a lot of
contributors - because it's free.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1918 2
	AR5K_TRACE;

a1920 2
	AR5K_TRACE;

a1922 2
	AR5K_TRACE;

a1924 3

	AR5K_TRACE;

a1926 2
	AR5K_TRACE;

a1928 2
	AR5K_TRACE;

a1929 3

	AR5K_TRACE;

a1930 2

	AR5K_TRACE;
@

