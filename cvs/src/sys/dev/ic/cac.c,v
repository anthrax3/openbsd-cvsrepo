head	1.55;
access;
symbols
	OPENBSD_6_2:1.55.0.10
	OPENBSD_6_2_BASE:1.55
	OPENBSD_6_1:1.55.0.8
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.6
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.54.0.6
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.50.0.6
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.49.0.6
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.2
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.4
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2;
locks; strict;
comment	@ * @;


1.55
date	2015.09.01.05.46.00;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	gGad7GXD1a3OVVbM;

1.54
date	2014.12.19.07.23.57;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	cV4v1OA8Ccwr5fwb;

1.53
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.52;
commitid	uzzBR7hz9ncd4O6G;

1.52
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	JtO5uXxVcnZfhUkR;

1.51
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.50;
commitid	I19imNlAX05zJOED;

1.50
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2011.10.27.00.18.23;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	2011.05.23.07.25.19;	author otto;	state Exp;
branches;
next	1.45;

1.45
date	2011.05.20.05.40.10;	author otto;	state Exp;
branches;
next	1.44;

1.44
date	2011.04.21.23.10.08;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.05.19.54.35;	author jasper;	state Exp;
branches;
next	1.42;

1.42
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.01.03.20.38;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2010.03.29.23.33.39;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.30.19.16.23;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.04.04.57.14;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.07.16.48.31;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.20.00.36.12;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2008.10.29.21.17.15;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.06.03.09.30;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.31.12.34.39;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.03.16.53.15;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.15.05.33.39;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.03.22.31.27;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.04.16.59.31;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.19.24.22;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.16.26.40;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.15.19.16.10;	author deraadt;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2003.03.06.22.31.21;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.31.04.05.58;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.18.20.24.10;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.16.17.26.51;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.23.10.47.56;	author art;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.04.11.15.43.24;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.07.04.47.26;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.17.23.07.16;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.17.21.35.06;	author mickey;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.23.37;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.40.45;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.5.4.8;

1.5.4.8
date	2003.05.13.19.35.00;	author ho;	state Exp;
branches;
next	1.5.4.9;

1.5.4.9
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.5.4.10;

1.5.4.10
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	1.5.4.11;

1.5.4.11
date	2004.06.05.23.12.41;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.31;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;

1.13.2.1
date	2003.06.09.17.09.47;	author brad;	state Exp;
branches;
next	;


desc
@@


1.55
log
@size for free()
@
text
@/*	$OpenBSD: cac.c,v 1.54 2014/12/19 07:23:57 deraadt Exp $	*/
/*	$NetBSD: cac.c,v 1.15 2000/11/08 19:20:35 ad Exp $	*/

/*
 * Copyright (c) 2001,2003 Michael Shalayeff
 * All rights reserved.
 *
 * The SCSI emulation layer is derived from gdt(4) driver,
 * Copyright (c) 1999, 2000 Niklas Hallqvist. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andrew Doran.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for Compaq array controllers.
 */

#include "bio.h"

/* #define	CAC_DEBUG */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/buf.h>
#include <sys/endian.h>
#include <sys/malloc.h>
#include <sys/pool.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/ic/cacreg.h>
#include <dev/ic/cacvar.h>

#if NBIO > 0
#include <dev/biovar.h>
#endif
#include <sys/sensors.h>

struct cfdriver cac_cd = {
	NULL, "cac", DV_DULL
};

void    cac_scsi_cmd(struct scsi_xfer *);
void	cacminphys(struct buf *bp, struct scsi_link *sl);

struct scsi_adapter cac_switch = {
	cac_scsi_cmd, cacminphys, 0, 0,
};

void	*cac_ccb_alloc(void *);
void	cac_ccb_done(struct cac_softc *, struct cac_ccb *);
void	cac_ccb_free(void *, void *);
int	cac_ccb_poll(struct cac_softc *, struct cac_ccb *, int);
int	cac_ccb_start(struct cac_softc *, struct cac_ccb *);
int	cac_cmd(struct cac_softc *sc, int command, void *data, int datasize,
	int drive, int blkno, int flags, struct scsi_xfer *xs);
int	cac_get_dinfo(struct cac_softc *sc, int target);
void	cac_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size);

struct	cac_ccb *cac_l0_completed(struct cac_softc *);
int	cac_l0_fifo_full(struct cac_softc *);
void	cac_l0_intr_enable(struct cac_softc *, int);
int	cac_l0_intr_pending(struct cac_softc *);
void	cac_l0_submit(struct cac_softc *, struct cac_ccb *);

#if NBIO > 0
int	cac_ioctl(struct device *, u_long, caddr_t);
int	cac_ioctl_vol(struct cac_softc *, struct bioc_vol *);

#ifndef SMALL_KERNEL
int	cac_create_sensors(struct cac_softc *);
void	cac_sensor_refresh(void *);
#endif
#endif /* NBIO > 0 */

const
struct cac_linkage cac_l0 = {
	cac_l0_completed,
	cac_l0_fifo_full,
	cac_l0_intr_enable,
	cac_l0_intr_pending,
	cac_l0_submit
};

/*
 * Initialise our interface to the controller.
 */
int
cac_init(struct cac_softc *sc, int startfw)
{
	struct scsibus_attach_args saa;
	struct cac_controller_info cinfo;
	int error, rseg, size, i;
	bus_dma_segment_t seg[1];
	struct cac_ccb *ccb;

	SIMPLEQ_INIT(&sc->sc_ccb_free);
	SIMPLEQ_INIT(&sc->sc_ccb_queue);
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, cac_ccb_alloc, cac_ccb_free);

        size = sizeof(struct cac_ccb) * CAC_MAX_CCBS;

	if ((error = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, seg, 1,
	    &rseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO)) != 0) {
		printf("%s: unable to allocate CCBs, error = %d\n",
		    sc->sc_dv.dv_xname, error);
		return (-1);
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, seg, rseg, size,
	    &sc->sc_ccbs, BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map CCBs, error = %d\n",
		    sc->sc_dv.dv_xname, error);
		return (-1);
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
		printf("%s: unable to create CCB DMA map, error = %d\n",
		    sc->sc_dv.dv_xname, error);
		return (-1);
	}

	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap, sc->sc_ccbs,
	    size, NULL, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to load CCB DMA map, error = %d\n",
		    sc->sc_dv.dv_xname, error);
		return (-1);
	}

	sc->sc_ccbs_paddr = sc->sc_dmamap->dm_segs[0].ds_addr;
	ccb = (struct cac_ccb *)sc->sc_ccbs;

	for (i = 0; i < CAC_MAX_CCBS; i++, ccb++) {
		/* Create the DMA map for this CCB's data */
		error = bus_dmamap_create(sc->sc_dmat, CAC_MAX_XFER,
		    CAC_SG_SIZE, CAC_MAX_XFER, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &ccb->ccb_dmamap_xfer);

		if (error) {
			printf("%s: can't create ccb dmamap (%d)\n",
			    sc->sc_dv.dv_xname, error);
			break;
		}

		ccb->ccb_paddr = sc->sc_ccbs_paddr + i * sizeof(struct cac_ccb);
		mtx_enter(&sc->sc_ccb_mtx);
		SIMPLEQ_INSERT_TAIL(&sc->sc_ccb_free, ccb, ccb_chain);
		mtx_leave(&sc->sc_ccb_mtx);
	}

	/* Start firmware background tasks, if needed. */
	if (startfw) {
		if (cac_cmd(sc, CAC_CMD_START_FIRMWARE, &cinfo, sizeof(cinfo),
		    0, 0, CAC_CCB_DATA_IN, NULL)) {
			printf("%s: CAC_CMD_START_FIRMWARE failed\n",
			    sc->sc_dv.dv_xname);
			return (-1);
		}
	}

	if (cac_cmd(sc, CAC_CMD_GET_CTRL_INFO, &cinfo, sizeof(cinfo), 0, 0,
	    CAC_CCB_DATA_IN, NULL)) {
		printf("%s: CAC_CMD_GET_CTRL_INFO failed\n",
		    sc->sc_dv.dv_xname);
		return (-1);
	}

	if (!cinfo.num_drvs) {
		printf("%s: no volumes defined\n", sc->sc_dv.dv_xname);
		return (-1);
	}

	sc->sc_nunits = cinfo.num_drvs;
	sc->sc_dinfos = mallocarray(cinfo.num_drvs,
	    sizeof(struct cac_drive_info), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_dinfos == NULL) {
		printf("%s: cannot allocate memory for drive_info\n",
		    sc->sc_dv.dv_xname);
		return (-1);
	}

	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter = &cac_switch;
	sc->sc_link.adapter_target = cinfo.num_drvs;
	sc->sc_link.adapter_buswidth = cinfo.num_drvs;
	sc->sc_link.openings = CAC_MAX_CCBS / sc->sc_nunits;
	if (sc->sc_link.openings < 4 )
		sc->sc_link.openings = 4;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	config_found(&sc->sc_dv, &saa, scsiprint);

	(*sc->sc_cl->cl_intr_enable)(sc, 1);

#if NBIO > 0
	if (bio_register(&sc->sc_dv, cac_ioctl) != 0)
		printf("%s: controller registration failed\n",
		    sc->sc_dv.dv_xname);
	else
		sc->sc_ioctl = cac_ioctl;

#ifndef SMALL_KERNEL
	if (cac_create_sensors(sc) != 0)
		printf("%s: unable to create sensors\n", sc->sc_dv.dv_xname);
#endif
#endif


	return (0);
}

int
cac_flush(sc)
	struct cac_softc *sc;
{
	u_int8_t buf[512];

	memset(buf, 0, sizeof(buf));
	buf[0] = 1;
	return cac_cmd(sc, CAC_CMD_FLUSH_CACHE, buf, sizeof(buf), 0, 0,
	    CAC_CCB_DATA_OUT, NULL);
}

/*
 * Handle an interrupt from the controller: process finished CCBs and
 * dequeue any waiting CCBs.
 */
int
cac_intr(v)
	void *v;
{
	struct cac_softc *sc = v;
	struct cac_ccb *ccb;
	int istat, ret = 0;

	if (!(istat = (*sc->sc_cl->cl_intr_pending)(sc)))
		return 0;

	if (istat & CAC_INTR_FIFO_NEMPTY)
		while ((ccb = (*sc->sc_cl->cl_completed)(sc)) != NULL) {
			ret = 1;
			cac_ccb_done(sc, ccb);
		}
	cac_ccb_start(sc, NULL);

	return (ret);
}

/*
 * Execute a [polled] command.
 */
int
cac_cmd(struct cac_softc *sc, int command, void *data, int datasize,
	int drive, int blkno, int flags, struct scsi_xfer *xs)
{
	struct cac_ccb *ccb;
	struct cac_sgb *sgb;
	int i, rv, size, nsegs;

#ifdef CAC_DEBUG
	printf("cac_cmd op=%x drv=%d blk=%d data=%p[%x] fl=%x xs=%p ",
	    command, drive, blkno, data, datasize, flags, xs);
#endif

	if (xs) {
		ccb = xs->io;
		/*
		 * The xs may have been restarted by the scsi layer, so
		 * ensure the ccb starts in the proper state.
		 */
		ccb->ccb_flags = 0;
	} else {
		/* Internal command. Need to get our own ccb. */
		ccb = scsi_io_get(&sc->sc_iopool, SCSI_POLL | SCSI_NOSLEEP);
		if (ccb == NULL)
			return (EBUSY);
	}

	if ((flags & (CAC_CCB_DATA_IN | CAC_CCB_DATA_OUT)) != 0) {
		bus_dmamap_load(sc->sc_dmat, ccb->ccb_dmamap_xfer,
		    (void *)data, datasize, NULL, BUS_DMA_NOWAIT);

		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap_xfer, 0,
		    ccb->ccb_dmamap_xfer->dm_mapsize,
		    (flags & CAC_CCB_DATA_IN) != 0 ? BUS_DMASYNC_PREREAD :
		    BUS_DMASYNC_PREWRITE);

		sgb = ccb->ccb_seg;
		nsegs = ccb->ccb_dmamap_xfer->dm_nsegs;
		if (nsegs > CAC_SG_SIZE)
			panic("cac_cmd: nsegs botch");

		size = 0;
		for (i = 0; i < nsegs; i++, sgb++) {
			size += ccb->ccb_dmamap_xfer->dm_segs[i].ds_len;
			sgb->length =
			    htole32(ccb->ccb_dmamap_xfer->dm_segs[i].ds_len);
			sgb->addr =
			    htole32(ccb->ccb_dmamap_xfer->dm_segs[i].ds_addr);
		}
	} else {
		size = datasize;
		nsegs = 0;
	}

	ccb->ccb_hdr.drive = drive;
	ccb->ccb_hdr.priority = 0;
	ccb->ccb_hdr.size = htole16((sizeof(struct cac_req) +
	    sizeof(struct cac_sgb) * CAC_SG_SIZE) >> 2);

	ccb->ccb_req.next = 0;
	ccb->ccb_req.command = command;
	ccb->ccb_req.error = 0;
	ccb->ccb_req.blkno = htole32(blkno);
	ccb->ccb_req.bcount = htole16(howmany(size, DEV_BSIZE));
	ccb->ccb_req.sgcount = nsegs;
	ccb->ccb_req.reserved = 0;

	ccb->ccb_flags = flags;
	ccb->ccb_datasize = size;
	ccb->ccb_xs = xs;

	if (!xs || xs->flags & SCSI_POLL) {
		/* Synchronous commands musn't wait. */
		mtx_enter(&sc->sc_ccb_mtx);
		if ((*sc->sc_cl->cl_fifo_full)(sc)) {
			mtx_leave(&sc->sc_ccb_mtx);
			rv = EBUSY;
		} else {
			mtx_leave(&sc->sc_ccb_mtx);
			ccb->ccb_flags |= CAC_CCB_ACTIVE;
			(*sc->sc_cl->cl_submit)(sc, ccb);
			rv = cac_ccb_poll(sc, ccb, 2000);
		}
	} else
		rv = cac_ccb_start(sc, ccb);

	if (xs == NULL)
		scsi_io_put(&sc->sc_iopool, ccb);

	return (rv);
}

/*
 * Wait for the specified CCB to complete.  Must be called at splbio.
 */
int
cac_ccb_poll(struct cac_softc *sc, struct cac_ccb *wantccb, int timo)
{
	struct cac_ccb *ccb;
	int t;

	t = timo * 100;
	do {
		for (; t--; DELAY(10))
			if ((ccb = (*sc->sc_cl->cl_completed)(sc)) != NULL)
				break;
		if (t < 0) {
			printf("%s: timeout\n", sc->sc_dv.dv_xname);
			return (EBUSY);
		}
		cac_ccb_done(sc, ccb);
	} while (ccb != wantccb);

	return (0);
}

/*
 * Enqueue the specified command (if any) and attempt to start all enqueued
 * commands.
 */
int
cac_ccb_start(struct cac_softc *sc, struct cac_ccb *ccb)
{
	if (ccb != NULL) {
		mtx_enter(&sc->sc_ccb_mtx);
		SIMPLEQ_INSERT_TAIL(&sc->sc_ccb_queue, ccb, ccb_chain);
		mtx_leave(&sc->sc_ccb_mtx);
	}

	while (1) {
		mtx_enter(&sc->sc_ccb_mtx);
		if (SIMPLEQ_EMPTY(&sc->sc_ccb_queue) ||
		    (*sc->sc_cl->cl_fifo_full)(sc)) {
			mtx_leave(&sc->sc_ccb_mtx);
			break;
		}
		ccb = SIMPLEQ_FIRST(&sc->sc_ccb_queue);
		SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_queue, ccb_chain);
		mtx_leave(&sc->sc_ccb_mtx);

		ccb->ccb_flags |= CAC_CCB_ACTIVE;
		(*sc->sc_cl->cl_submit)(sc, ccb);
	}

	return (0);
}

/*
 * Process a finished CCB.
 */
void
cac_ccb_done(struct cac_softc *sc, struct cac_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->ccb_xs;
	int error = 0;

	if ((ccb->ccb_flags & CAC_CCB_ACTIVE) == 0) {
		printf("%s: CCB not active, xs=%p\n", sc->sc_dv.dv_xname, xs);
		if (xs) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
		}
		return;
	}

	if ((ccb->ccb_flags & (CAC_CCB_DATA_IN | CAC_CCB_DATA_OUT)) != 0) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap_xfer, 0,
		    ccb->ccb_dmamap_xfer->dm_mapsize,
		    ccb->ccb_flags & CAC_CCB_DATA_IN ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap_xfer);
	}

	if ((ccb->ccb_req.error & CAC_RET_SOFT_ERROR) != 0)
		printf("%s: soft error; corrected\n", sc->sc_dv.dv_xname);
	if ((ccb->ccb_req.error & CAC_RET_HARD_ERROR) != 0) {
		error = 1;
		printf("%s: hard error\n", sc->sc_dv.dv_xname);
	}
	if ((ccb->ccb_req.error & CAC_RET_CMD_REJECTED) != 0) {
		error = 1;
		printf("%s: invalid request\n", sc->sc_dv.dv_xname);
	}

	if (xs) {
		if (error)
			xs->error = XS_DRIVER_STUFFUP;
		else
			xs->resid = 0;

		scsi_done(xs);
	}
}

/*
 * Allocate a CCB.
 */
void *
cac_ccb_alloc(void *xsc)
{
	struct cac_softc *sc = xsc;
	struct cac_ccb *ccb = NULL;

	mtx_enter(&sc->sc_ccb_mtx);
	if (SIMPLEQ_EMPTY(&sc->sc_ccb_free)) {
#ifdef CAC_DEBUG
		printf("%s: unable to alloc CCB\n", sc->sc_dv.dv_xname);
#endif
	} else {
		ccb = SIMPLEQ_FIRST(&sc->sc_ccb_free);
		SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_free, ccb_chain);
	}
	mtx_leave(&sc->sc_ccb_mtx);

	return (ccb);
}

/*
 * Put a CCB onto the freelist.
 */
void
cac_ccb_free(void *xsc, void *xccb)
{
	struct cac_softc *sc = xsc;
	struct cac_ccb *ccb = xccb;

	ccb->ccb_flags = 0;

	mtx_enter(&sc->sc_ccb_mtx);
	SIMPLEQ_INSERT_HEAD(&sc->sc_ccb_free, ccb, ccb_chain);
	mtx_leave(&sc->sc_ccb_mtx);
}

int
cac_get_dinfo(sc, target)
	struct cac_softc *sc;
	int target;
{
	if (sc->sc_dinfos[target].ncylinders)
		return (0);

	if (cac_cmd(sc, CAC_CMD_GET_LOG_DRV_INFO, &sc->sc_dinfos[target],
	    sizeof(*sc->sc_dinfos), target, 0, CAC_CCB_DATA_IN, NULL)) {
		printf("%s: CMD_GET_LOG_DRV_INFO failed\n",
		    sc->sc_dv.dv_xname);
		return (-1);
	}

	return (0);
}

void
cacminphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > CAC_MAX_XFER)
		bp->b_bcount = CAC_MAX_XFER;
	minphys(bp);
}

void
cac_copy_internal_data(xs, v, size)
	struct scsi_xfer *xs;
	void *v;
	size_t size;
{
	size_t copy_cnt;

	if (!xs->datalen)
		printf("uio move is not yet supported\n");
	else {
		copy_cnt = MIN(size, xs->datalen);
		memcpy(xs->data, v, copy_cnt);
	}
}

void
cac_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *link = xs->sc_link;
	struct cac_softc *sc = link->adapter_softc;
	struct cac_drive_info *dinfo;
	struct scsi_inquiry_data inq;
	struct scsi_sense_data sd;
	struct scsi_read_cap_data rcd;
	u_int8_t target = link->target;
	u_int32_t blockno, blockcnt, size;
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	int op, flags, s, error;
	const char *p;

	if (target >= sc->sc_nunits || link->lun != 0) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	s = splbio();
	xs->error = XS_NOERROR;
	dinfo = &sc->sc_dinfos[target];

	switch (xs->cmd->opcode) {
	case TEST_UNIT_READY:
	case START_STOP:
#if 0
	case VERIFY:
#endif
		break;

	case REQUEST_SENSE:
		bzero(&sd, sizeof sd);
		sd.error_code = SSD_ERRCODE_CURRENT;
		sd.segment = 0;
		sd.flags = SKEY_NO_SENSE;
		*(u_int32_t*)sd.info = htole32(0);
		sd.extra_len = 0;
		cac_copy_internal_data(xs, &sd, sizeof sd);
		break;

	case INQUIRY:
		if (cac_get_dinfo(sc, target)) {
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		bzero(&inq, sizeof inq);
		inq.device = T_DIRECT;
		inq.dev_qual2 = 0;
		inq.version = 2;
		inq.response_format = 2;
		inq.additional_length = 32;
		inq.flags |= SID_CmdQue;
		strlcpy(inq.vendor, "Compaq  ", sizeof inq.vendor);
		switch (CAC_GET1(dinfo->mirror)) {
		case 0: p = "RAID0";	break;
		case 1: p = "RAID4";	break;
		case 2: p = "RAID1";	break;
		case 3: p = "RAID5";	break;
		default:p = "<UNK>";	break;
		}
		snprintf(inq.product, sizeof inq.product, "%s vol  #%02d",
		    p, target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
		cac_copy_internal_data(xs, &inq, sizeof inq);
		break;

	case READ_CAPACITY:
		if (cac_get_dinfo(sc, target)) {
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		bzero(&rcd, sizeof rcd);
		_lto4b( CAC_GET2(dinfo->ncylinders) * CAC_GET1(dinfo->nheads) *
		    CAC_GET1(dinfo->nsectors) - 1, rcd.addr);
		_lto4b(CAC_SECTOR_SIZE, rcd.length);
		cac_copy_internal_data(xs, &rcd, sizeof rcd);
		break;

	case PREVENT_ALLOW:
		break;

	case SYNCHRONIZE_CACHE:
		if (cac_flush(sc))
			xs->error = XS_DRIVER_STUFFUP;
		break;

	case READ_COMMAND:
	case READ_BIG:
	case WRITE_COMMAND:
	case WRITE_BIG:

		flags = 0;
		/* A read or write operation. */
		if (xs->cmdlen == 6) {
			rw = (struct scsi_rw *)xs->cmd;
			blockno = _3btol(rw->addr) &
			    (SRW_TOPADDR << 16 | 0xffff);
			blockcnt = rw->length ? rw->length : 0x100;
		} else {
			rwb = (struct scsi_rw_big *)xs->cmd;
			blockno = _4btol(rwb->addr);
			blockcnt = _2btol(rwb->length);
		}
		size = CAC_GET2(dinfo->ncylinders) *
		    CAC_GET1(dinfo->nheads) * CAC_GET1(dinfo->nsectors);
		if (blockno >= size || blockno + blockcnt > size) {
			printf("%s: out of bounds %u-%u >= %u\n",
			    sc->sc_dv.dv_xname, blockno, blockcnt, size);
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}

		switch (xs->cmd->opcode) {
		case READ_COMMAND:
		case READ_BIG:
			op = CAC_CMD_READ;
			flags = CAC_CCB_DATA_IN;
			break;
		case WRITE_COMMAND:
		case WRITE_BIG:
			op = CAC_CMD_WRITE;
			flags = CAC_CCB_DATA_OUT;
			break;
		}

		if ((error = cac_cmd(sc, op, xs->data, blockcnt * DEV_BSIZE,
		    target, blockno, flags, xs))) {
			splx(s);
			if (error == EBUSY)
				xs->error = XS_BUSY;
			else
				xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}

		splx(s);
		return;

	default:
		SC_DEBUG(link, SDEV_DB1, ("unsupported scsi command %#x "
		    "tgt %d ", xs->cmd->opcode, target));
		xs->error = XS_DRIVER_STUFFUP;
	}

	splx(s);
	scsi_done(xs);
}

/*
 * Board specific linkage shared between multiple bus types.
 */

int
cac_l0_fifo_full(struct cac_softc *sc)
{

	return (cac_inl(sc, CAC_REG_CMD_FIFO) == 0);
}

void
cac_l0_submit(struct cac_softc *sc, struct cac_ccb *ccb)
{
#ifdef CAC_DEBUG
	printf("submit-%x ", ccb->ccb_paddr);
#endif
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	cac_outl(sc, CAC_REG_CMD_FIFO, ccb->ccb_paddr);
}

struct cac_ccb *
cac_l0_completed(sc)
	struct cac_softc *sc;
{
	struct cac_ccb *ccb;
	paddr_t off, orig_off;

	if (!(off = cac_inl(sc, CAC_REG_DONE_FIFO)))
		return NULL;
#ifdef CAC_DEBUG
	printf("compl-%x ", off);
#endif
	orig_off = off;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

	off = (off & ~3) - sc->sc_ccbs_paddr;
	ccb = (struct cac_ccb *)(sc->sc_ccbs + off);

	if (orig_off & 3 && ccb->ccb_req.error == 0)
		ccb->ccb_req.error = CAC_RET_CMD_INVALID;

	return (ccb);
}

int
cac_l0_intr_pending(struct cac_softc *sc)
{

	return (cac_inl(sc, CAC_REG_INTR_PENDING));
}

void
cac_l0_intr_enable(struct cac_softc *sc, int state)
{

	cac_outl(sc, CAC_REG_INTR_MASK,
	    state ? CAC_INTR_ENABLE : CAC_INTR_DISABLE);
}

#if NBIO > 0
const int cac_level[] = { 0, 4, 1, 5, 51, 7 };
const int cac_stat[] = { BIOC_SVONLINE, BIOC_SVOFFLINE, BIOC_SVOFFLINE,
    BIOC_SVDEGRADED, BIOC_SVREBUILD, BIOC_SVREBUILD, BIOC_SVDEGRADED,
    BIOC_SVDEGRADED, BIOC_SVINVALID, BIOC_SVINVALID, BIOC_SVBUILDING,
    BIOC_SVOFFLINE, BIOC_SVBUILDING };

int
cac_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct cac_softc *sc = (struct cac_softc *)dev;
	struct bioc_inq *bi;
	struct bioc_disk *bd;
	cac_lock_t lock;
	int error = 0;

	lock = CAC_LOCK(sc);
	switch (cmd) {
	case BIOCINQ:
		bi = (struct bioc_inq *)addr;
		strlcpy(bi->bi_dev, sc->sc_dv.dv_xname, sizeof(bi->bi_dev));
		bi->bi_novol = sc->sc_nunits;
		bi->bi_nodisk = 0;
		break;

	case BIOCVOL:
		error = cac_ioctl_vol(sc, (struct bioc_vol *)addr);
		break;

	case BIOCDISK:
		bd = (struct bioc_disk *)addr;
		if (bd->bd_volid > sc->sc_nunits) {
			error = EINVAL;
			break;
		}
		/* No disk information yet */
		break;

	case BIOCBLINK:
	case BIOCALARM:
	case BIOCSETSTATE:
	default:
		error = ENOTTY;
	}
	CAC_UNLOCK(sc, lock);

	return (error);
}

int
cac_ioctl_vol(struct cac_softc *sc, struct bioc_vol *bv)
{
	struct cac_drive_info dinfo;
	struct cac_drive_status dstatus;
	u_int32_t blks;

	if (bv->bv_volid > sc->sc_nunits)
		return (EINVAL);
	if (cac_cmd(sc, CAC_CMD_GET_LOG_DRV_INFO, &dinfo, sizeof(dinfo),
	    bv->bv_volid, 0, CAC_CCB_DATA_IN, NULL))
		return (EIO);
	if (cac_cmd(sc, CAC_CMD_SENSE_DRV_STATUS, &dstatus, sizeof(dstatus),
	    bv->bv_volid, 0, CAC_CCB_DATA_IN, NULL))
		return (EIO);
	bv->bv_status = BIOC_SVINVALID;
	blks = CAC_GET2(dinfo.ncylinders) * CAC_GET1(dinfo.nheads) *
	    CAC_GET1(dinfo.nsectors);
	bv->bv_size = (off_t)blks * CAC_GET2(dinfo.secsize);
	bv->bv_level = cac_level[CAC_GET1(dinfo.mirror)];	/*XXX limit check */
	bv->bv_nodisk = 0;		/* XXX */
	bv->bv_status = 0;		/* XXX */
	bv->bv_percent = -1;
	bv->bv_seconds = 0;
	if (dstatus.stat < nitems(cac_stat))
		bv->bv_status = cac_stat[dstatus.stat];
	if (bv->bv_status == BIOC_SVREBUILD ||
	    bv->bv_status == BIOC_SVBUILDING)
		bv->bv_percent = ((blks - CAC_GET4(dstatus.prog)) * 1000ULL) /
		    blks;

	return (0);
}

#ifndef SMALL_KERNEL
int
cac_create_sensors(struct cac_softc *sc)
{
	struct device *dev;
	struct scsibus_softc *ssc = NULL;
	struct scsi_link *link;
	int i;

	TAILQ_FOREACH(dev, &alldevs, dv_list) {
		if (dev->dv_parent != &sc->sc_dv)
			continue;

		/* check if this is the scsibus for the logical disks */
		ssc = (struct scsibus_softc *)dev;
		if (ssc->adapter_link == &sc->sc_link)
			break;
		ssc = NULL;
	}

	if (ssc == NULL)
		return (1);

	sc->sc_sensors = mallocarray(sc->sc_nunits,
	    sizeof(struct ksensor), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_sensors == NULL)
		return (1);

	strlcpy(sc->sc_sensordev.xname, sc->sc_dv.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	for (i = 0; i < sc->sc_nunits; i++) {
		link = scsi_get_link(ssc, i, 0);
		if (link == NULL)
			goto bad;

		dev = link->device_softc;

		sc->sc_sensors[i].type = SENSOR_DRIVE;
		sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;

		strlcpy(sc->sc_sensors[i].desc, dev->dv_xname,
		    sizeof(sc->sc_sensors[i].desc));

		sensor_attach(&sc->sc_sensordev, &sc->sc_sensors[i]);
	}

	if (sensor_task_register(sc, cac_sensor_refresh, 10) == NULL)
		goto bad;

	sensordev_install(&sc->sc_sensordev);

	return (0);

bad:
	free(sc->sc_sensors, M_DEVBUF,
	    sc->sc_nunits * sizeof(struct ksensor));

	return (1);
}

void
cac_sensor_refresh(void *arg)
{
	struct cac_softc *sc = arg;
	struct bioc_vol bv;
	int i, s;

	for (i = 0; i < sc->sc_nunits; i++) {
		bzero(&bv, sizeof(bv));
		bv.bv_volid = i;
		s = splbio();
		if (cac_ioctl_vol(sc, &bv)) {
			splx(s);
			return;
		}
		splx(s);

		switch (bv.bv_status) {
		case BIOC_SVOFFLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_FAIL;
			sc->sc_sensors[i].status = SENSOR_S_CRIT;
			break;

		case BIOC_SVDEGRADED:
			sc->sc_sensors[i].value = SENSOR_DRIVE_PFAIL;
			sc->sc_sensors[i].status = SENSOR_S_WARN;
			break;

		case BIOC_SVSCRUB:
		case BIOC_SVONLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_ONLINE;
			sc->sc_sensors[i].status = SENSOR_S_OK;
			break;

		case BIOC_SVREBUILD:
		case BIOC_SVBUILDING:
			sc->sc_sensors[i].value = SENSOR_DRIVE_REBUILD;
			sc->sc_sensors[i].status = SENSOR_S_OK;
			break;

		case BIOC_SVINVALID:
			/* FALLTRHOUGH */
		default:
			sc->sc_sensors[i].value = 0; /* unknown */
			sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;
		}
	}
}
#endif /* SMALL_KERNEL */
#endif /* NBIO > 0 */
@


1.54
log
@another handful of bcopy -> memcpy because there is no overlap
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.53 2014/09/14 14:17:24 jsg Exp $	*/
d945 2
a946 1
	free(sc->sc_sensors, M_DEVBUF, 0);
@


1.53
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.52 2014/07/13 23:10:23 deraadt Exp $	*/
d584 1
a584 1
		bcopy(v, xs->data, copy_cnt);
@


1.52
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.51 2014/07/12 18:48:17 tedu Exp $	*/
a74 1
#include <sys/proc.h>
@


1.51
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.50 2013/05/30 16:15:02 deraadt Exp $	*/
d233 2
a234 2
	sc->sc_dinfos = malloc(cinfo.num_drvs * sizeof(struct cac_drive_info),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
d914 2
a915 2
	sc->sc_sensors = malloc(sizeof(struct ksensor) * sc->sc_nunits,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
@


1.50
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.49 2011/10/27 00:18:23 krw Exp $	*/
d946 1
a946 1
	free(sc->sc_sensors, M_DEVBUF);
@


1.49
log
@Initialize variables before use. From Pedro Martelletto, tweaked by
me to add more paranoia.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.48 2011/07/17 22:46:48 matthew Exp $	*/
a113 2
int	cac_flush(struct cac_softc *sc);
void	cac_shutdown(void *);
a131 2
void	*cac_sdh;	/* shutdown hook */

a254 4
	/* Set our `shutdownhook' before we start any device activity. */
	if (cac_sdh == NULL)
		cac_sdh = shutdownhook_establish(cac_shutdown, NULL);

a283 17
}

/*
 * Shut down all `cac' controllers.
 */
void
cac_shutdown(void *cookie)
{
	extern struct cfdriver cac_cd;
	struct cac_softc *sc;
	int i;

	for (i = 0; i < cac_cd.cd_ndevs; i++) {
		if ((sc = (struct cac_softc *)device_lookup(&cac_cd, i)) == NULL)
			continue;
		cac_flush(sc);
	}
@


1.48
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.47 2011/07/08 22:09:27 matthew Exp $	*/
d796 1
a796 1
	paddr_t off;
d803 5
a807 2
	if (off & 3 && ccb->ccb_req.error == 0)
		ccb->ccb_req.error = CAC_RET_CMD_INVALID;
d812 2
a813 3
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
@


1.47
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.46 2011/05/23 07:25:19 otto Exp $	*/
d248 1
a255 1
	saa.saa_targets = cinfo.num_drvs;
@


1.46
log
@Fix after poolification. For reasons not completely understood, the
fifo full check has to be protected by the mutex. ok dlg@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.45 2011/05/20 05:40:10 otto Exp $	*/
a247 1
	sc->sc_link.adapter_buswidth = cinfo.num_drvs;
d255 1
@


1.45
log
@Avoid double scsi_done(xs) in error path; ok dlg@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.44 2011/04/21 23:10:08 krw Exp $	*/
d323 1
a323 1
	if (!(istat = (sc->sc_cl->cl_intr_pending)(sc)))
d412 1
d414 1
d417 1
d468 1
a468 1
	while (!(*sc->sc_cl->cl_fifo_full)(sc)) {
d470 2
a471 1
		if (SIMPLEQ_EMPTY(&sc->sc_ccb_queue)) {
d543 1
a543 2
	if ((*sc->sc_cl->cl_fifo_full)(sc) ||
	    SIMPLEQ_EMPTY(&sc->sc_ccb_free)) {
d628 1
a628 1
	int op, flags, s, error, poll;
a638 1
	xs->free_list.le_next = NULL;
a743 1
		poll = xs->flags & SCSI_POLL;
d764 1
a765 1
	splx(s);
@


1.44
log
@A plausible iopoolification. Utter dearth of interested parties
after more than a year of grovelling emails shows further effort
is pointless.

ok matthew@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.43 2011/04/05 19:54:35 jasper Exp $	*/
a725 1
			scsi_done(xs);
@


1.43
log
@- use nitems() no binary change on amd64

"reads OK" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.42 2010/10/12 00:53:32 krw Exp $	*/
d106 1
a106 1
struct	cac_ccb *cac_ccb_alloc(struct cac_softc *, int);
d108 1
a108 1
void	cac_ccb_free(struct cac_softc *, struct cac_ccb *);
d159 2
d209 1
d211 1
d252 1
d352 12
a363 5
	if ((ccb = cac_ccb_alloc(sc, 0)) == NULL) {
#ifdef CAC_DEBUG
		printf("%s: unable to alloc CCB\n", sc->sc_dv.dv_xname);
#endif
		return (ENOMEM);
a410 1

d413 1
a413 2
			cac_ccb_free(sc, ccb);
			rv = ENOMEM; /* Causes XS_NO_CCB, i/o is retried. */
d422 3
d435 1
a435 1
	int s, t = timo * 100;
d437 1
a445 1
		s = splbio();
a446 1
		splx(s);
d454 1
a454 1
 * commands.  Must be called at splbio.
d459 2
a460 1
	if (ccb != NULL)
d462 2
d465 7
a471 2
	while ((ccb = SIMPLEQ_FIRST(&sc->sc_ccb_queue)) != NULL &&
	    !(*sc->sc_cl->cl_fifo_full)(sc)) {
d473 2
a518 1
	cac_ccb_free(sc, ccb);
d532 2
a533 2
struct cac_ccb *
cac_ccb_alloc(struct cac_softc *sc, int nosleep)
d535 2
a536 1
	struct cac_ccb *ccb;
d538 8
a545 1
	if ((ccb = SIMPLEQ_FIRST(&sc->sc_ccb_free)) != NULL)
d547 3
a549 2
	else
		ccb = NULL;
d557 1
a557 1
cac_ccb_free(struct cac_softc *sc, struct cac_ccb *ccb)
d559 2
d563 2
d566 1
d746 4
a749 7

			if (error == ENOMEM || error == EBUSY) {
				xs->error = XS_NO_CCB;
				scsi_done(xs);
				splx(s);
				return;
			} else {
d751 2
a752 4
				scsi_done(xs);
				splx(s);
				return;
			}
@


1.42
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.41 2010/09/20 06:17:49 krw Exp $	*/
d874 1
a874 1
	if (dstatus.stat < sizeof(cac_stat)/sizeof(cac_stat[0]))
@


1.41
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.40 2010/07/01 03:20:38 matthew Exp $	*/
d633 1
@


1.40
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.39 2010/06/28 18:31:02 krw Exp $	*/
d614 1
a614 1
		sd.error_code = 0x70;
@


1.39
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.38 2010/05/20 00:55:17 krw Exp $	*/
d889 1
d915 2
a916 1
		if (ssc->sc_link[i][0] == NULL)
d919 1
a919 1
		dev = ssc->sc_link[i][0]->device_softc;
@


1.38
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.37 2010/05/19 15:27:35 oga Exp $	*/
a105 4
struct scsi_device cac_dev = {
	NULL, NULL, NULL, NULL
};

a244 1
	sc->sc_link.device = &cac_dev;
@


1.37
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.36 2010/03/29 23:33:39 krw Exp $	*/
a599 1
		s = splbio();
a600 1
		splx(s);
@


1.36
log
@Initialize various uninitialized variables. Found by jsg@@ via Clang.

Feedback from miod@@ and kettenis@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.35 2010/03/23 01:57:19 krw Exp $	*/
d167 1
a167 1
	    &rseg, BUS_DMA_NOWAIT)) != 0) {
a194 1
	memset(sc->sc_ccbs, 0, size);
@


1.35
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.34 2010/01/09 23:15:06 krw Exp $	*/
d896 1
a896 1
	struct scsibus_softc *ssc;
d907 1
@


1.34
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.33 2009/11/22 14:14:10 krw Exp $	*/
d99 1
a99 1
int     cac_scsi_cmd(struct scsi_xfer *);
d409 1
a409 1
			rv = ENOMEM; /* Causes NO_CCB, i/o is retried. */
d582 1
a582 1
int
d604 1
a604 1
		return (COMPLETE);
d720 2
d723 1
a723 1
				return (NO_CCB);
d727 2
a728 1
				break;
d733 1
a733 5

		if (poll)
			return (COMPLETE);
		else
			return (SUCCESSFULLY_QUEUED);
a742 2

	return (COMPLETE);
@


1.33
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.32 2009/09/30 19:16:23 miod Exp $	*/
a509 1
		xs->flags |= ITSDONE;
a600 1
		xs->flags |= ITSDONE;
@


1.32
log
@Need to scsi_done() before returning COMPLETE for untranslated commands,
such a Test Unit Ready; found the hard way by jbg@@, and inexplicably missed
during dlg@@ and I audit of hba drivers behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.31 2009/09/04 04:57:14 miod Exp $	*/
d721 1
a721 1
			if (error == ENOMEM) {
a723 3
			} else if (poll) {
				splx(s);
				return (TRY_AGAIN_LATER);
@


1.31
log
@Missing scsi_done() in some error path returning COMPLETE; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.30 2009/03/07 16:48:31 krw Exp $	*/
d746 2
@


1.30
log
@No need to spam log with 'unable to alloc CCB' messages now that
NO_CCB is in place and the I/O is retried rather than discarded.
So move the message inside a #ifdef CAC_DEBUG.

Noticed by jbg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.29 2009/02/20 00:36:12 krw Exp $	*/
d602 4
@


1.29
log
@Bring NO_CCB to cac(4), which helps bio work better without
generating worrying error messages. Or possibly losing i/o's.

tested by jbg@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.28 2009/02/16 21:19:06 miod Exp $	*/
d354 1
d356 1
@


1.28
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.27 2008/10/29 21:17:15 brad Exp $	*/
d407 1
a407 1
			rv = -1;
d717 1
a717 1
				return (TRY_AGAIN_LATER);
@


1.27
log
@Add initial bio support; only volume status is handled.

Based on cac(4) bio support from NetBSD which is derived from
OpenBSD's ciss(4) bio support.

Tested by otto@@ jbg@@

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.26 2008/06/26 05:42:15 ray Exp $	*/
d100 1
a100 1
void	cacminphys(struct buf *bp);
d558 1
a558 2
cacminphys(bp)
	struct buf *bp;
@


1.26
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.25 2007/11/06 03:09:30 krw Exp $	*/
d65 2
d72 1
d90 5
d128 10
d266 14
d426 1
a426 1
	int s, t = timo * 10;
d429 1
a429 1
		for (; t--; DELAY(100))
d808 191
@


1.25
log
@More scsi_done() at SPLBIO.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.24 2007/10/01 04:03:51 krw Exp $	*/
a46 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.24
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.23 2006/11/28 23:59:45 dlg Exp $	*/
d401 1
a401 1
	int t = timo * 10;
d411 1
d413 1
@


1.23
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.22 2006/08/31 12:34:39 marco Exp $	*/
d228 1
a228 1
	    M_DEVBUF, M_NOWAIT);
a233 1
	bzero(sc->sc_dinfos, cinfo.num_drvs * sizeof(struct cac_drive_info));
@


1.22
log
@Prerrt print volume nr in dmesg.

ok mickey, deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.21 2005/12/03 16:53:15 krw Exp $	*/
d144 1
d245 4
a248 1
	config_found(&sc->sc_dv, &sc->sc_link, scsiprint);
@


1.21
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.20 2005/09/15 05:33:39 krw Exp $	*/
d616 1
a616 1
		snprintf(inq.product, sizeof inq.product, "%s volume  #%02d",
@


1.20
log
@Don't fake MODE SENSE page 4 info inside raid drivers, just let sd
fake a geometry. Page 4 info does not get used for size information.
Eliminate now unused union scsi_disk_pages.

ok marco@@ mickey@@ pre-lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.19 2005/07/03 22:31:27 krw Exp $	*/
a686 1
				xs->error = XS_BUSY;
a689 1
				xs->error = XS_TIMEOUT;
@


1.19
log
@Fix data_length values in simulationed MODE SENSE page 4 responses so
that scsi_do_mode_sense() accepts them.

The data_length value does not include itself, and the pg_length value
in a mode page does not include itself or the page_code fields. We
were +1 on the former and -2 on the latter resulting in a data_length
value that was too small by one.

Eliminates 'mode sense page 5 not simulated' messages.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.18 2004/05/04 16:59:31 grange Exp $	*/
a560 5
	struct {
		struct scsi_mode_header hd;
		struct scsi_blk_desc bd;
		union scsi_disk_pages dp;
	} mpd;
a621 37
	case MODE_SENSE:
		if (cac_get_dinfo(sc, target)) {
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		bzero(&mpd, sizeof mpd);
		switch (((struct scsi_mode_sense *)xs->cmd)->page) {
		case 4:
			/* scsi_disk.h says this should be 0x16 */
			mpd.dp.rigid_geometry.pg_length = 0x16;
			mpd.hd.data_length = sizeof mpd.hd -
			    sizeof mpd.hd.data_length + sizeof mpd.bd +
			    sizeof mpd.dp.rigid_geometry;
			mpd.hd.blk_desc_len = sizeof mpd.bd;

			/* XXX */
			mpd.hd.dev_spec = 0;
			_lto3b(CAC_SECTOR_SIZE, mpd.bd.blklen);
			mpd.dp.rigid_geometry.pg_code = 4;
			_lto3b(CAC_GET2(dinfo->ncylinders),
			    mpd.dp.rigid_geometry.ncyl);
			mpd.dp.rigid_geometry.nheads =
			    CAC_GET1(dinfo->nheads);
			cac_copy_internal_data(xs, (u_int8_t *)&mpd,
			    sizeof mpd);
			break;

		default:
			printf("%s: mode sense page %d not simulated\n",
			    sc->sc_dv.dv_xname,
			    ((struct scsi_mode_sense *)xs->cmd)->page);
			xs->error = XS_DRIVER_STUFFUP;
			splx(s);
			return (TRY_AGAIN_LATER);
		}
		break;

d709 2
@


1.18
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.17 2004/01/09 21:32:23 brad Exp $	*/
d637 3
a639 2
			mpd.hd.data_length = sizeof mpd.hd + sizeof mpd.bd +
			    mpd.dp.rigid_geometry.pg_length;
@


1.17
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.16 2003/06/02 19:24:22 mickey Exp $	*/
d426 1
a426 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_queue, ccb, ccb_chain);
d492 1
a492 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_free, ccb, ccb_chain);
@


1.16
log
@kill the caluses three and four on some of my code
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.15 2003/06/02 16:26:40 mickey Exp $	*/
a83 2

#include <uvm/uvm_extern.h>
@


1.15
log
@do not play w/ interrupts too much and keep 'em enabled at all times, fixes random lockups; tested by brad@@ on all models
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.14 2003/04/27 11:22:52 ho Exp $	*/
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.14
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.13 2003/03/15 19:16:10 deraadt Exp $	*/
d5 1
a5 1
 * Copyright (c) 2001 Michael Shalayeff
d257 2
a305 1
	(*sc->sc_cl->cl_intr_enable)(sc, 0);
a380 1
	(*sc->sc_cl->cl_intr_enable)(sc, 0);
a391 1
		(*sc->sc_cl->cl_intr_enable)(sc, 1);
a436 2

	(*sc->sc_cl->cl_intr_enable)(sc, 1);
@


1.13
log
@specifed -> specified
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.12 2003/03/06 22:31:21 mickey Exp $	*/
d623 1
a623 1
		strcpy(inq.vendor, "Compaq  ");
d631 3
a633 2
		sprintf(inq.product, "%s volume  #%02d", p, target);
		strcpy(inq.revision, "   ");
@


1.13.2.1
log
@MFC:
Fix by mickey@@

do not play w/ interrupts too much and keep 'em enabled at all times,
fixes random lockups; tested by brad@@ on all models

mickey@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.13 2003/03/15 19:16:10 deraadt Exp $	*/
a256 2
	(*sc->sc_cl->cl_intr_enable)(sc, 1);

d304 1
d380 1
d392 1
d438 2
@


1.12
log
@this is a fix for kernel panics and craches along w/ other stability
improvements worked out over past few months w/ different people.
the main bug was fixes w/ help of harding@@motd.ca .
10x to all and enjoy the better driver (;
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.11 2002/03/14 01:26:54 millert Exp $	*/
d423 1
a423 1
 * Enqueue the specifed command (if any) and attempt to start all enqueued
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.10 2001/12/31 04:05:58 mickey Exp $	*/
d153 1
a153 1
	bus_dma_segment_t seg;
d155 1
a155 1
	
d161 1
a161 1
	if ((error = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &seg, 1, 
d168 2
a169 3
	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg, size, 
	    (caddr_t *)&sc->sc_ccbs,
	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
d175 1
a175 1
	if ((error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0, 
d182 1
a182 1
	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap, sc->sc_ccbs, 
d201 1
a201 1
			printf("%s: can't create ccb dmamap (%d)\n", 
a205 1
		ccb->ccb_flags = 0;
d209 1
a209 1
	
d220 1
a220 1
	if (cac_cmd(sc, CAC_CMD_GET_CTRL_INFO, &cinfo, sizeof(cinfo), 0, 0, 
d222 1
a222 1
		printf("%s: CAC_CMD_GET_CTRL_INFO failed\n", 
d256 1
a256 2
		
	(*sc->sc_cl->cl_intr_enable)(sc, 1);
d268 1
a268 1
	return cac_cmd(sc, CAC_CMD_FLUSH_CACHE, buf, sizeof(buf), 0, 0, 
d284 1
a284 1
			continue; 
d287 1
a287 1
}	
d299 1
a299 1
	int ret = 0;
d301 1
a301 1
	if (!(sc->sc_cl->cl_intr_pending)(sc))
d304 7
a310 5
	while ((ccb = (*sc->sc_cl->cl_completed)(sc)) != NULL) {
		ret++;
		cac_ccb_done(sc, ccb);
		cac_ccb_start(sc, NULL);
	}
d344 1
a344 1
	
d346 3
a348 1
		nsegs = min(ccb->ccb_dmamap_xfer->dm_nsegs, CAC_SG_SIZE);
d353 1
a353 1
			sgb->length = 
d355 1
a355 1
			sgb->addr = 
d364 2
a365 1
	ccb->ccb_hdr.size = htole16((sizeof(struct cac_req) + 
d368 4
a372 1
	ccb->ccb_req.command = command;
d374 2
a375 2
	ccb->ccb_req.blkno = htole32(blkno);
	
d380 1
a381 3
		int s;

		s = splbio();
d392 1
a392 1
		splx(s);
d395 1
a395 1
	
d406 1
a406 2

	timo *= 10;
d409 1
a409 1
		for (; timo > 0; timo--) {
d412 1
a412 4
			DELAY(100);
		}

		if (timo <= 0) {
d423 1
a423 1
 * Enqueue the specifed command (if any) and attempt to start all enqueued 
a428 1

d432 2
a433 3
	while ((ccb = SIMPLEQ_FIRST(&sc->sc_ccb_queue)) != NULL) {
		if ((*sc->sc_cl->cl_fifo_full)(sc))
			return (EBUSY);
d438 3
a440 1
	
a453 1
#ifdef CAC_DEBUG
a454 1
#endif
a460 1
	ccb->ccb_flags &= ~CAC_CCB_ACTIVE;
d485 1
a485 1
		else {
a486 2
			xs->flags |= ITSDONE;
		}
d488 1
a499 1
	int s;
a500 1
	s = splbio();
a504 1
	splx(s);
a513 1
	int s;
a515 1
	s = splbio();
a516 1
	splx(s);
d581 1
a581 1
	int op, flags, s, error;
d589 1
d591 1
d615 1
a615 2
			scsi_done(xs);
			return (COMPLETE);
d639 1
a639 2
			scsi_done(xs);
			return (COMPLETE);
d667 1
d675 1
a675 2
			scsi_done(xs);
			return (COMPLETE);
d685 1
a685 1
		return (COMPLETE);
d688 1
a688 3
		s = splbio();
		if (cac_flush(sc)) {
			splx(s);
d690 1
a690 5
			scsi_done(xs);
		} else
			splx(s);
		return (COMPLETE);

a695 1
		s = splbio();
a711 1
			splx(s);
d716 1
a716 1
			return (COMPLETE);
d732 1
a735 1
			splx(s);
d737 2
a738 1
				xs->error = XS_DRIVER_STUFFUP;
d740 1
a740 1
			} else if (xs->flags & SCSI_POLL) {
d742 1
d747 1
a747 1
				return (COMPLETE);
d753 1
a753 1
		if (xs->flags & SCSI_POLL)
d761 1
d801 5
a805 2
	ccb = (struct cac_ccb *)(sc->sc_ccbs +
	    ((off & ~3) - sc->sc_ccbs_paddr));
@


1.10
log
@missing nl, from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.9 2001/11/06 19:53:18 miod Exp $	*/
d105 2
a106 2
int     cac_scsi_cmd __P((struct scsi_xfer *));
void	cacminphys __P((struct buf *bp));
d123 4
a126 4
int	cac_get_dinfo __P((struct cac_softc *sc, int target));
int	cac_flush __P((struct cac_softc *sc));
void	cac_shutdown __P((void *));
void	cac_copy_internal_data __P((struct scsi_xfer *xs, void *v, size_t size));
@


1.9
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.8 2001/11/05 17:25:58 art Exp $	*/
d333 1
a333 1
		printf("%s: unable to alloc CCB", sc->sc_dv.dv_xname);
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.10 2001/12/31 04:05:58 mickey Exp $	*/
d333 1
a333 1
		printf("%s: unable to alloc CCB\n", sc->sc_dv.dv_xname);
@


1.9.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.9.2.1 2002/01/31 22:55:31 niklas Exp $	*/
d105 2
a106 2
int     cac_scsi_cmd(struct scsi_xfer *);
void	cacminphys(struct buf *bp);
d123 4
a126 4
int	cac_get_dinfo(struct cac_softc *sc, int target);
int	cac_flush(struct cac_softc *sc);
void	cac_shutdown(void *);
void	cac_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size);
@


1.9.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d153 1
a153 1
	bus_dma_segment_t seg[1];
d155 1
a155 1

d161 1
a161 1
	if ((error = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, seg, 1,
d168 3
a170 2
	if ((error = bus_dmamem_map(sc->sc_dmat, seg, rseg, size,
	    &sc->sc_ccbs, BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
d176 1
a176 1
	if ((error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
d183 1
a183 1
	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap, sc->sc_ccbs,
d202 1
a202 1
			printf("%s: can't create ccb dmamap (%d)\n",
d207 1
d211 1
a211 1

d222 1
a222 1
	if (cac_cmd(sc, CAC_CMD_GET_CTRL_INFO, &cinfo, sizeof(cinfo), 0, 0,
d224 1
a224 1
		printf("%s: CAC_CMD_GET_CTRL_INFO failed\n",
d258 2
a259 1

d271 1
a271 1
	return cac_cmd(sc, CAC_CMD_FLUSH_CACHE, buf, sizeof(buf), 0, 0,
d287 1
a287 1
			continue;
d290 1
a290 1
}
d302 1
a302 1
	int istat, ret = 0;
d304 1
a304 1
	if (!(istat = (sc->sc_cl->cl_intr_pending)(sc)))
d307 5
a311 7
	(*sc->sc_cl->cl_intr_enable)(sc, 0);
	if (istat & CAC_INTR_FIFO_NEMPTY)
		while ((ccb = (*sc->sc_cl->cl_completed)(sc)) != NULL) {
			ret = 1;
			cac_ccb_done(sc, ccb);
		}
	cac_ccb_start(sc, NULL);
d345 1
a345 1

d347 1
a347 3
		nsegs = ccb->ccb_dmamap_xfer->dm_nsegs;
		if (nsegs > CAC_SG_SIZE)
			panic("cac_cmd: nsegs botch");
d352 1
a352 1
			sgb->length =
d354 1
a354 1
			sgb->addr =
d363 1
a363 2
	ccb->ccb_hdr.priority = 0;
	ccb->ccb_hdr.size = htole16((sizeof(struct cac_req) +
d366 1
a366 1
	ccb->ccb_req.next = 0;
d368 1
a368 1
	ccb->ccb_req.error = 0;
d370 1
a370 4
	ccb->ccb_req.bcount = htole16(howmany(size, DEV_BSIZE));
	ccb->ccb_req.sgcount = nsegs;
	ccb->ccb_req.reserved = 0;

a374 1
	(*sc->sc_cl->cl_intr_enable)(sc, 0);
d376 3
d389 1
a389 1
		(*sc->sc_cl->cl_intr_enable)(sc, 1);
d392 1
a392 1

d403 2
a404 1
	int t = timo * 10;
d407 1
a407 1
		for (; t--; DELAY(100))
d410 4
a413 1
		if (t < 0) {
d424 1
a424 1
 * Enqueue the specified command (if any) and attempt to start all enqueued
d430 1
d434 3
a436 2
	while ((ccb = SIMPLEQ_FIRST(&sc->sc_ccb_queue)) != NULL &&
	    !(*sc->sc_cl->cl_fifo_full)(sc)) {
d441 1
a441 3

	(*sc->sc_cl->cl_intr_enable)(sc, 1);

d455 1
d457 1
d464 1
d489 1
a489 1
		else
d491 2
a493 1
		xs->flags |= ITSDONE;
d505 1
d507 1
d512 1
d522 1
d525 1
d527 1
d592 1
a592 1
	int op, flags, s, error, poll;
a599 1
	s = splbio();
a600 1
	xs->free_list.le_next = NULL;
d624 2
a625 1
			break;
d633 1
a633 1
		strlcpy(inq.vendor, "Compaq  ", sizeof inq.vendor);
d641 2
a642 3
		snprintf(inq.product, sizeof inq.product, "%s volume  #%02d",
		    p, target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
d649 2
a650 1
			break;
a677 1
			splx(s);
d685 2
a686 1
			break;
d696 1
a696 1
		break;
d699 3
a701 1
		if (cac_flush(sc))
d703 5
a707 1
		break;
d713 1
d730 1
d735 1
a735 1
			break;
a750 1
		poll = xs->flags & SCSI_POLL;
d754 1
d756 1
a756 2
				xs->error = XS_BUSY;
				splx(s);
d758 1
a758 1
			} else if (poll) {
a759 1
				splx(s);
d764 1
a764 1
				break;
d770 1
a770 1
		if (poll)
a777 1
	splx(s);
d817 2
a818 5
	if (off & 3 && ccb->ccb_req.error == 0)
		ccb->ccb_req.error = CAC_RET_CMD_INVALID;

	off = (off & ~3) - sc->sc_ccbs_paddr;
	ccb = (struct cac_ccb *)(sc->sc_ccbs + off);
@


1.8
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.7 2001/10/18 20:24:10 mickey Exp $	*/
a89 1
#include <vm/vm.h>
@


1.7
log
@solve numerous problems:
- free up ccb before calling scsi_done;
- remove bogus tsleep/wakeup ccb availability mechanism;
- fix an off by one size reporting in read_capacity.
huge 10x to Alan Jones <RAJones@@teklinks.com> and
teklinks for providing a testbed and his time for testing.
tests sustained 34 simultaneous tar zxvp at ldav of 76.
however 36 simultaneous bonnies hang the machine,
possibly for different reasons though.
regardless, this fixed version passes an installation alright.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.6 2001/08/16 17:26:51 brad Exp $	*/
d342 2
a343 1
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap_xfer,
d468 2
a469 1
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap_xfer,
d800 2
a801 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
d821 2
a822 1
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap,
@


1.6
log
@do not try to undefine CAC_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.5 2001/04/23 10:47:56 art Exp $	*/
d5 1
a5 1
 * Copyright (c) 2000 Michael Shalayeff
d484 1
a494 1
	cac_ccb_free(sc, ccb);
d507 4
a510 13

	for (;;) {
		if ((ccb = SIMPLEQ_FIRST(&sc->sc_ccb_free)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_free, ccb, ccb_chain);
			break;
		}
		if (nosleep) {
			ccb = NULL;
			break;
		}
		tsleep(&sc->sc_ccb_free, PRIBIO, "cacccb", 0);
	}

a525 2
	if (SIMPLEQ_NEXT(ccb, ccb_chain) == NULL)
		wakeup(&sc->sc_ccb_free);
d591 1
a591 1
	int op, flags, s;
d689 1
a689 1
		    CAC_GET1(dinfo->nsectors), rcd.addr);
d715 20
a734 24
		if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
			/* A read or write operation. */
			if (xs->cmdlen == 6) {
				rw = (struct scsi_rw *)xs->cmd;
				blockno = _3btol(rw->addr) &
				    (SRW_TOPADDR << 16 | 0xffff);
				blockcnt = rw->length ? rw->length : 0x100;
			} else {
				rwb = (struct scsi_rw_big *)xs->cmd;
				blockno = _4btol(rwb->addr);
				blockcnt = _2btol(rwb->length);
			}
			size = CAC_GET2(dinfo->ncylinders) *
			    CAC_GET1(dinfo->nheads) *
			    CAC_GET1(dinfo->nsectors);
			if (blockno >= size || blockno + blockcnt > size) {
				splx(s);
				printf("%s: out of bounds %u-%u >= %u\n",
				    sc->sc_dv.dv_xname, blockno, blockcnt,
				    size);
				xs->error = XS_DRIVER_STUFFUP;
				scsi_done(xs);
				return (COMPLETE);
			}
d750 2
a751 2
		if (cac_cmd(sc, op, xs->data, blockcnt * DEV_BSIZE, target,
		    blockno, flags, xs)) {
d754 4
a757 1
			if (xs->flags & SCSI_POLL) {
@


1.5
log
@double splx in error path.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.4 2001/04/11 15:43:24 mickey Exp $	*/
d76 2
a77 1
#undef CAC_DEBUG
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d713 2
a714 2
		}
		splx(s);
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.5.4.1 2001/05/14 22:23:37 niklas Exp $	*/
d713 2
a714 2
		} else
			splx(s);
@


1.5.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.5.4.2 2001/07/04 10:40:45 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 2001 Michael Shalayeff
d76 1
a76 2

/* #define	CAC_DEBUG */
a482 1
	cac_ccb_free(sc, ccb);
d493 1
d506 13
a518 4
	if ((ccb = SIMPLEQ_FIRST(&sc->sc_ccb_free)) != NULL)
		SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_free, ccb, ccb_chain);
	else
		ccb = NULL;
d534 2
d601 1
a601 1
	int op, flags, s, error;
d699 1
a699 1
		    CAC_GET1(dinfo->nsectors) - 1, rcd.addr);
d725 24
a748 20
		/* A read or write operation. */
		if (xs->cmdlen == 6) {
			rw = (struct scsi_rw *)xs->cmd;
			blockno = _3btol(rw->addr) &
			    (SRW_TOPADDR << 16 | 0xffff);
			blockcnt = rw->length ? rw->length : 0x100;
		} else {
			rwb = (struct scsi_rw_big *)xs->cmd;
			blockno = _4btol(rwb->addr);
			blockcnt = _2btol(rwb->length);
		}
		size = CAC_GET2(dinfo->ncylinders) *
		    CAC_GET1(dinfo->nheads) * CAC_GET1(dinfo->nsectors);
		if (blockno >= size || blockno + blockcnt > size) {
			splx(s);
			printf("%s: out of bounds %u-%u >= %u\n",
			    sc->sc_dv.dv_xname, blockno, blockcnt, size);
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return (COMPLETE);
d764 2
a765 2
		if ((error = cac_cmd(sc, op, xs->data, blockcnt * DEV_BSIZE,
		    target, blockno, flags, xs))) {
d768 1
a768 4
			if (error == ENOMEM) {
				xs->error = XS_DRIVER_STUFFUP;
				return (TRY_AGAIN_LATER);
			} else if (xs->flags & SCSI_POLL) {
@


1.5.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
d342 1
a342 2
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap_xfer, 0,
		    ccb->ccb_dmamap_xfer->dm_mapsize,
d467 1
a467 2
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap_xfer, 0,
		    ccb->ccb_dmamap_xfer->dm_mapsize,
d798 1
a798 2
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
d818 1
a818 2
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap, 0,
	    sc->sc_dmamap->dm_mapsize,
@


1.5.4.5
log
@Merge in trunk
@
text
@d333 1
a333 1
		printf("%s: unable to alloc CCB\n", sc->sc_dv.dv_xname);
@


1.5.4.6
log
@Merge in -current from about a week ago
@
text
@d105 2
a106 2
int     cac_scsi_cmd(struct scsi_xfer *);
void	cacminphys(struct buf *bp);
d123 4
a126 4
int	cac_get_dinfo(struct cac_softc *sc, int target);
int	cac_flush(struct cac_softc *sc);
void	cac_shutdown(void *);
void	cac_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size);
@


1.5.4.7
log
@Sync the SMP branch with 3.3
@
text
@d153 1
a153 1
	bus_dma_segment_t seg[1];
d155 1
a155 1

d161 1
a161 1
	if ((error = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, seg, 1,
d168 3
a170 2
	if ((error = bus_dmamem_map(sc->sc_dmat, seg, rseg, size,
	    &sc->sc_ccbs, BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
d176 1
a176 1
	if ((error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
d183 1
a183 1
	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap, sc->sc_ccbs,
d202 1
a202 1
			printf("%s: can't create ccb dmamap (%d)\n",
d207 1
d211 1
a211 1

d222 1
a222 1
	if (cac_cmd(sc, CAC_CMD_GET_CTRL_INFO, &cinfo, sizeof(cinfo), 0, 0,
d224 1
a224 1
		printf("%s: CAC_CMD_GET_CTRL_INFO failed\n",
d258 2
a259 1

d271 1
a271 1
	return cac_cmd(sc, CAC_CMD_FLUSH_CACHE, buf, sizeof(buf), 0, 0,
d287 1
a287 1
			continue;
d290 1
a290 1
}
d302 1
a302 1
	int istat, ret = 0;
d304 1
a304 1
	if (!(istat = (sc->sc_cl->cl_intr_pending)(sc)))
d307 5
a311 7
	(*sc->sc_cl->cl_intr_enable)(sc, 0);
	if (istat & CAC_INTR_FIFO_NEMPTY)
		while ((ccb = (*sc->sc_cl->cl_completed)(sc)) != NULL) {
			ret = 1;
			cac_ccb_done(sc, ccb);
		}
	cac_ccb_start(sc, NULL);
d345 1
a345 1

d347 1
a347 3
		nsegs = ccb->ccb_dmamap_xfer->dm_nsegs;
		if (nsegs > CAC_SG_SIZE)
			panic("cac_cmd: nsegs botch");
d352 1
a352 1
			sgb->length =
d354 1
a354 1
			sgb->addr =
d363 1
a363 2
	ccb->ccb_hdr.priority = 0;
	ccb->ccb_hdr.size = htole16((sizeof(struct cac_req) +
d366 1
a366 1
	ccb->ccb_req.next = 0;
d368 1
a368 1
	ccb->ccb_req.error = 0;
d370 1
a370 4
	ccb->ccb_req.bcount = htole16(howmany(size, DEV_BSIZE));
	ccb->ccb_req.sgcount = nsegs;
	ccb->ccb_req.reserved = 0;

a374 1
	(*sc->sc_cl->cl_intr_enable)(sc, 0);
d376 3
d389 1
a389 1
		(*sc->sc_cl->cl_intr_enable)(sc, 1);
d392 1
a392 1

d403 2
a404 1
	int t = timo * 10;
d407 1
a407 1
		for (; t--; DELAY(100))
d410 4
a413 1
		if (t < 0) {
d424 1
a424 1
 * Enqueue the specified command (if any) and attempt to start all enqueued
d430 1
d434 3
a436 2
	while ((ccb = SIMPLEQ_FIRST(&sc->sc_ccb_queue)) != NULL &&
	    !(*sc->sc_cl->cl_fifo_full)(sc)) {
d441 1
a441 3

	(*sc->sc_cl->cl_intr_enable)(sc, 1);

d455 1
d457 1
d464 1
d489 1
a489 1
		else
d491 2
a493 1
		xs->flags |= ITSDONE;
d505 1
d507 1
d512 1
d522 1
d525 1
d527 1
d592 1
a592 1
	int op, flags, s, error, poll;
a599 1
	s = splbio();
a600 1
	xs->free_list.le_next = NULL;
d624 2
a625 1
			break;
d649 2
a650 1
			break;
a677 1
			splx(s);
d685 2
a686 1
			break;
d696 1
a696 1
		break;
d699 3
a701 1
		if (cac_flush(sc))
d703 5
a707 1
		break;
d713 1
d730 1
d735 1
a735 1
			break;
a750 1
		poll = xs->flags & SCSI_POLL;
d754 1
d756 1
a756 2
				xs->error = XS_BUSY;
				splx(s);
d758 1
a758 1
			} else if (poll) {
a759 1
				splx(s);
d764 1
a764 1
				break;
d770 1
a770 1
		if (poll)
a777 1
	splx(s);
d817 2
a818 5
	if (off & 3 && ccb->ccb_req.error == 0)
		ccb->ccb_req.error = CAC_RET_CMD_INVALID;

	off = (off & ~3) - sc->sc_ccbs_paddr;
	ccb = (struct cac_ccb *)(sc->sc_ccbs + off);
@


1.5.4.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.5.4.7 2003/03/28 00:38:12 niklas Exp $	*/
d623 1
a623 1
		strlcpy(inq.vendor, "Compaq  ", sizeof inq.vendor);
d631 2
a632 3
		snprintf(inq.product, sizeof inq.product, "%s volume  #%02d",
		    p, target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
@


1.5.4.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.5.4.8 2003/05/13 19:35:00 ho Exp $	*/
d5 1
a5 1
 * Copyright (c) 2001,2003 Michael Shalayeff
d19 5
a256 2
	(*sc->sc_cl->cl_intr_enable)(sc, 1);

d304 1
d380 1
d392 1
d438 2
@


1.5.4.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 2
@


1.5.4.11
log
@Merge with the trunk
@
text
@d426 1
a426 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_queue, ccb_chain);
d492 1
a492 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_ccb_free, ccb_chain);
@


1.4
log
@just fail if there are no volumes defined
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.3 2001/02/07 04:47:26 mickey Exp $	*/
d713 2
a714 2
		}
		splx(s);
@


1.3
log
@ok, commit this since it most likely to work; i guess now it will get tested a little bit sooner than in a few months; 10x brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cac.c,v 1.2 2000/12/17 23:07:16 mickey Exp $	*/
d226 5
@


1.2
log
@initialize dinfo always
@
text
@d1 2
a2 2
/*	$OpenBSD: cac.c,v 1.1 2000/12/17 21:35:06 mickey Exp $	*/
/*	$NetBSD: cac.c,v 1.14 2000/11/08 19:20:35 ad Exp $	*/
d124 1
d258 12
a277 1
	u_int8_t buf[512];
d283 1
a283 4
		memset(buf, 0, sizeof(buf));
		buf[0] = 1;
		cac_cmd(sc, CAC_CMD_FLUSH_CACHE, buf, sizeof(buf), 0, 0, 
		    CAC_CCB_DATA_OUT, NULL);
d702 11
a716 1
	case SYNCHRONIZE_CACHE:
@


1.1
log
@Compaq SMART Array RAID controllers.
based on netbsd driver.
testing helps from brad@@
eisa untested, but should work (;
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d596 1
a621 1
		dinfo = &sc->sc_dinfos[target];
a646 1
		dinfo = &sc->sc_dinfos[target];
a682 1
		dinfo = &sc->sc_dinfos[target];
@

