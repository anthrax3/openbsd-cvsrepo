head	1.35;
access;
symbols
	OPENBSD_6_0:1.35.0.10
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.4
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.8
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.6
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.2
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.33.0.8
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.4
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.6
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.28.0.4
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.7
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2
	SMP_BASE:1.1
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.35
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.34;
commitid	LS2TNeCue5R9L67C;

1.34
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2011.06.21.20.23.49;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.26.22.55.58;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.26.22.46.25;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.26.18.31.16;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.26.18.05.12;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.20.20.46.18;	author mk;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.20.20.43.27;	author mk;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.04.04.57.14;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.26.22.03.11;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2008.09.12.11.14.04;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.30.18.08.04;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.05.20.30.44;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.03.16.53.16;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.11.18.43.14;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.09.23.43.11;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.05.17.25.58;	author art;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.07.13.17.04.28;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.08.17.46.46;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.25.06.19.38;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	99.11.30.07.55.56;	author cmetz;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.05.14.22.23.44;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.02.19.10.56.18;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@/*	$OpenBSD: dpt.c,v 1.34 2013/05/30 16:15:02 deraadt Exp $	*/
/*	$NetBSD: dpt.c,v 1.12 1999/10/23 16:26:33 ad Exp $	*/

/*-
 * Copyright (c) 1997, 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andy Doran, Charles M. Hannum and by Jason R. Thorpe of the Numerical 
 * Aerospace Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Portions of this code fall under the following copyright:
 *
 * Originally written by Julian Elischer (julian@@tfs.com)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 */

/*
 * Driver for DPT EATA SCSI adapters.
 *
 * TODO:
 *
 * o Need a front-end for (newer) ISA boards.
 * o Handle older firmware better.
 * o Find a bunch of different firmware EEPROMs and try them out.
 * o Test with a bunch of different boards.
 * o dpt_readcfg() should not be using CP_PIO_GETCFG.
 * o An interface to userland applications.
 * o Some sysctls or a utility (eg dptctl(8)) to control parameters.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/endian.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/ic/dptreg.h>
#include <dev/ic/dptvar.h>

struct cfdriver dpt_cd = {
	NULL, "dpt", DV_DULL
};

void	*dpt_ccb_alloc(void *);
void	dpt_ccb_free(void *, void *);

struct scsi_adapter dpt_switch = {
	dpt_scsi_cmd,
	dpt_minphys
};

#ifndef offsetof
#define offsetof(type, member) ((size_t)(&((type *)0)->member))
#endif /* offsetof */

static char *dpt_cname[] = {
	"PM3334", "SmartRAID IV",
	"PM3332", "SmartRAID IV",
	"PM2144", "SmartCache IV",
	"PM2044", "SmartCache IV",
	"PM2142", "SmartCache IV",
	"PM2042", "SmartCache IV",
	"PM2041", "SmartCache IV",
	"PM3224", "SmartRAID III",
	"PM3222", "SmartRAID III", 
	"PM3021", "SmartRAID III",
	"PM2124", "SmartCache III",
	"PM2024", "SmartCache III",
	"PM2122", "SmartCache III",
	"PM2022", "SmartCache III",
	"PM2021", "SmartCache III",
	"SK2012", "SmartCache Plus", 
	"SK2011", "SmartCache Plus",
	NULL,     "unknown adapter, please report using sendbug(1)",
};

/*
 * Handle an interrupt from the HBA.
 */
int
dpt_intr(xxx_sc)
	void *xxx_sc;
{
	struct dpt_softc *sc;
	struct dpt_ccb *ccb;
	struct eata_sp *sp;
	static int moretimo;
	int more;

	sc = xxx_sc;
	sp = sc->sc_statpack;

	if (!sp) {
#ifdef DEBUG
		printf("%s: premature intr (st:%02x aux:%02x)\n",
			sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS),
			dpt_inb(sc, HA_AUX_STATUS));
#else /* DEBUG */
		(void) dpt_inb(sc, HA_STATUS);
#endif /* DEBUG */
		return (0);
	}

	more = 0;

#ifdef DEBUG
	if ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0)
		printf("%s: spurious intr\n", sc->sc_dv.dv_xname);
#endif

	/* Don't get stalled by HA_ST_MORE */
	if (moretimo < DPT_MORE_TIMEOUT / 100)
		moretimo = 0;
	
	for (;;) {
		/*
		 * HBA might have interrupted while we were dealing with the
		 * last completed command, since we ACK before we deal; keep 
		 * polling. If no interrupt is signalled, but the HBA has
		 * indicated that more data will be available soon, hang 
		 * around. 
		 */ 
		if ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0) {
			if (more != 0 && moretimo++ < DPT_MORE_TIMEOUT / 100) {
				DELAY(10);
				continue;
			}
			break;
		}
		
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff,
		    sizeof(struct eata_sp), BUS_DMASYNC_POSTREAD);

		if (!sp) {
			more = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;

			/* Don't get stalled by HA_ST_MORE */
			if (moretimo < DPT_MORE_TIMEOUT / 100)
				moretimo = 0;
			continue;
		}

		/* Might have looped before HBA can reset HBA_AUX_INTR */
		if (sp->sp_ccbid == -1) {
			DELAY(50);
#ifdef DIAGNOSTIC
			printf("%s: slow reset of HA_AUX_STATUS?",
			    sc->sc_dv.dv_xname);
#endif
			if ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0)
				return (0);
#ifdef DIAGNOSTIC
			printf("%s: was a slow reset of HA_AUX_STATUS",
			    sc->sc_dv.dv_xname);
#endif
			/* Re-sync DMA map */
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, 
			    sc->sc_spoff, sizeof(struct eata_sp),
			    BUS_DMASYNC_POSTREAD);
		}

		/* Make sure CCB ID from status packet is realistic */
		if (sp->sp_ccbid >= 0 && sp->sp_ccbid < sc->sc_nccbs) {
			/* Sync up DMA map and cache cmd status */
			ccb = sc->sc_ccbs + sp->sp_ccbid;

			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, 
			    CCB_OFF(sc, ccb), sizeof(struct dpt_ccb), 
			    BUS_DMASYNC_POSTWRITE);

			ccb->ccb_hba_status = sp->sp_hba_status & 0x7F;
			ccb->ccb_scsi_status = sp->sp_scsi_status;

			/* 
			 * Ack the interrupt and process the CCB. If this
			 * is a private CCB it's up to dpt_poll() to notice.
			 */
			sp->sp_ccbid = -1;
			ccb->ccb_flg |= CCB_INTR;
			more = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;
			if ((ccb->ccb_flg & CCB_PRIVATE) == 0)
				dpt_done_ccb(sc, ccb);
		} else {
			printf("%s: bogus status (returned CCB id %d)\n", 
			    sc->sc_dv.dv_xname, sp->sp_ccbid);

			/* Ack the interrupt */
			sp->sp_ccbid = -1;
			more = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;
		}
		
		/* Don't get stalled by HA_ST_MORE */
		if (moretimo < DPT_MORE_TIMEOUT / 100)
			moretimo = 0;
	}

	return (0);
}

/*
 * Initialize and attach the HBA. This is the entry point from bus
 * specific probe-and-attach code.
 */
void
dpt_init(sc, intrstr)
	struct dpt_softc *sc;
	const char *intrstr;
{
	struct eata_inquiry_data *ei;
	int i, j, error, rseg, mapsize;
	bus_dma_segment_t seg;
	struct eata_cfg *ec;
	char model[16];

	ec = &sc->sc_ec;
	
	/* Allocate the CCB/status packet/scratch DMA map and load */
	sc->sc_nccbs = min(betoh16(*(int16_t *)ec->ec_queuedepth),
			   DPT_MAX_CCBS);
	sc->sc_spoff = sc->sc_nccbs * sizeof(struct dpt_ccb);
	sc->sc_scroff = sc->sc_spoff + sizeof(struct eata_sp);
	sc->sc_scrlen = 256; /* XXX */
	mapsize = sc->sc_nccbs * sizeof(struct dpt_ccb) + sc->sc_scrlen +
	    sizeof(struct eata_sp);
		
	if ((error = bus_dmamem_alloc(sc->sc_dmat, mapsize, NBPG, 0, 
	    &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to allocate CCBs, error = %d\n",
		    sc->sc_dv.dv_xname, error);
		return;
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg, mapsize,
	    (caddr_t *)&sc->sc_ccbs, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map CCBs, error = %d\n",
		    sc->sc_dv.dv_xname, error);
		return;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, mapsize, mapsize, 1, 0, 
	    BUS_DMA_NOWAIT, &sc->sc_dmamap_ccb)) != 0) {
		printf("%s: unable to create CCB DMA map, error = %d\n",
		    sc->sc_dv.dv_xname, error);
		return;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_ccb,
	    sc->sc_ccbs, mapsize, NULL, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to load CCB DMA map, error = %d\n",
		    sc->sc_dv.dv_xname, error);
		return;
	}

	sc->sc_statpack = (struct eata_sp *)((caddr_t)sc->sc_ccbs +
	    sc->sc_spoff);
	sc->sc_sppa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr + sc->sc_spoff;
	sc->sc_scr = (caddr_t)sc->sc_ccbs + sc->sc_scroff;
	sc->sc_scrpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr + sc->sc_scroff;
	sc->sc_statpack->sp_ccbid = -1;

	/* Initialize the CCBs */
	SLIST_INIT(&sc->sc_free_ccb);
	i = dpt_create_ccbs(sc, sc->sc_ccbs, sc->sc_nccbs);

	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, dpt_ccb_alloc, dpt_ccb_free);

	if (i == 0) {
		printf("%s: unable to create CCBs\n", sc->sc_dv.dv_xname);
		return;
	} else if (i != sc->sc_nccbs) {
		printf("%s: %d/%d CCBs created!\n", sc->sc_dv.dv_xname, i, 
		    sc->sc_nccbs);
		sc->sc_nccbs = i;
	}

	/* Get the page 0 inquiry data from the HBA */
	dpt_hba_inquire(sc, &ei);

	/* 
	 * dpt0 at pci0 dev 12 function 0: DPT SmartRAID III (PM3224A/9X-R)
	 * dpt0: interrupting at irq 10
	 * dpt0: 64 queued commands, 1 channel(s), adapter on ID(s) 7
	 */
	for (i = 0; ei->ei_vendor[i] != ' ' && i < 8; i++)
		;
	ei->ei_vendor[i] = '\0';

	for (i = 0; ei->ei_model[i] != ' ' && i < 7; i++)
		model[i] = ei->ei_model[i];
	for (j = 0; ei->ei_suffix[j] != ' ' && j < 7; j++)
		model[i++] = ei->ei_suffix[j];
	model[i] = '\0';

	/* Find the canonical name for the board */
	for (i = 0; dpt_cname[i] != NULL; i += 2)
		if (memcmp(ei->ei_model, dpt_cname[i], 6) == 0)
			break;
			
	printf("%s %s (%s)\n", ei->ei_vendor, dpt_cname[i + 1], model);

	if (intrstr != NULL)
		printf("%s: interrupting at %s\n", sc->sc_dv.dv_xname, intrstr);

	printf("%s: %d queued commands, %d channel(s)\n", 
	    sc->sc_dv.dv_xname, sc->sc_nccbs, ec->ec_maxchannel + 1);

	/* Reset the SCSI bus */
	if (dpt_cmd(sc, NULL, 0, CP_IMMEDIATE, CPI_BUS_RESET))
		panic("%s: dpt_cmd failed", sc->sc_dv.dv_xname);
        DELAY(20000);
	
	/* Fill in each link and attach in turn */
	for (i = 0; i <= ec->ec_maxchannel; i++) {
		struct scsibus_attach_args saa;
		struct dpt_channel *ch;
		struct scsi_link *link;

		sc->sc_hbaid[i] = ec->ec_hba[3 - i];

		ch = &sc->sc_channel[i];
		ch->ch_sc = sc;
		ch->ch_index = i;

		link = &sc->sc_link[i];
		link->adapter_target = sc->sc_hbaid[i];
		link->luns = ec->ec_maxlun + 1;
		link->adapter_buswidth = ec->ec_maxtarget + 1;
		link->adapter = &dpt_switch;
		link->adapter_softc = ch;
		link->openings = sc->sc_nccbs;
		link->pool = &sc->sc_iopool;

		bzero(&saa, sizeof(saa));
		saa.saa_sc_link = link;

		config_found(&sc->sc_dv, &saa, scsiprint);
	}
}

/*
 * Cleanly shut down the HBA. The HBA must flush 
 * all data from its cache and mark array groups as clean.
 */
void
dpt_shutdown(void *v)
{
	struct dpt_softc *sc = v;

	dpt_cmd(sc, NULL, 0, CP_IMMEDIATE, CPI_POWEROFF_WARN);
	DELAY(5000*1000);
}

/*
 * Send an EATA command to the HBA.
 */
int
dpt_cmd(sc, cp, addr, eatacmd, icmd)
	struct dpt_softc *sc;
	struct eata_cp *cp;
	u_int32_t addr;
	int eatacmd, icmd;
{
	int i;
	
	for (i = 20000; i; i--) {
		if ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)
			break;
		DELAY(50);
	}

	/* Not the most graceful way to handle this */
	if (i == 0) {
		printf("%s: HBA timeout on EATA command issue; aborting\n", 
		    sc->sc_dv.dv_xname);
		return (-1);
	}
	
	if (cp == NULL)
		addr = 0;

	dpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);
	dpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);
	dpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);
	dpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);

	if (eatacmd == CP_IMMEDIATE) {
		if (cp == NULL) {
			/* XXX should really pass meaningful values */
			dpt_outb(sc, HA_ICMD_CODE2, 0);
			dpt_outb(sc, HA_ICMD_CODE1, 0);
		}
		dpt_outb(sc, HA_ICMD, icmd);
	}

        dpt_outb(sc, HA_COMMAND, eatacmd);
        return (0);
}

/*
 * Wait for the HBA to reach an arbitrary state.
 */
int
dpt_wait(sc, mask, state, ms)
        struct dpt_softc *sc;
        u_int8_t mask, state;
        int ms;
{
     
        for (ms *= 10; ms; ms--) {
                if ((dpt_inb(sc, HA_STATUS) & mask) == state)
                	return (0);
                DELAY(100);
        }
        return (-1);
}

/*
 * Wait for the specified CCB to finish. This is used when we may not be
 * able to sleep and/or interrupts are disabled (eg autoconfiguration). 
 * The timeout value from the CCB is used. This should only be used for 
 * CCB_PRIVATE requests; otherwise the CCB will get recycled before we get 
 * a look at it.
 */
int
dpt_poll(sc, ccb)
        struct dpt_softc *sc;
        struct dpt_ccb *ccb;
{
	int i, s;

#ifdef DEBUG
	if ((ccb->ccb_flg & CCB_PRIVATE) == 0)
		panic("dpt_poll: called for non-CCB_PRIVATE request");
#endif

 	if ((ccb->ccb_flg & CCB_INTR) != 0)
        	return (0);                

        for (i = ccb->ccb_timeout * 20; i; i--) {
                if ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) != 0) {
			s = splbio();
                	dpt_intr(sc);
			splx(s);
		}
                if ((ccb->ccb_flg & CCB_INTR) != 0)
                	return (0);
                DELAY(50);
        }
        return (-1);
}

/*
 * Read the EATA configuration from the HBA and perform some sanity checks.
 */
int
dpt_readcfg(sc)
	struct dpt_softc *sc;
{
	struct eata_cfg *ec;
	int i, j, stat;
	u_int16_t *p;

	ec = &sc->sc_ec;

	/* Older firmware may puke if we talk to it too soon after reset */
	dpt_outb(sc, HA_COMMAND, CP_RESET);
        DELAY(750000);

	for (i = 1000; i; i--) {
		if ((dpt_inb(sc, HA_STATUS) & HA_ST_READY) != 0)
			break;
		DELAY(2000);
	}
	
	if (i == 0) {
		printf("%s: HBA not ready after reset: %02x\n", 
		    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));
		return (-1);
	}

	while((((stat = dpt_inb(sc, HA_STATUS))
            != (HA_ST_READY|HA_ST_SEEK_COMPLETE))
            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR))
            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR|HA_ST_DRQ)))
            || (dpt_wait(sc, HA_ST_BUSY, 0, 2000))) {
        	/* RAID drives still spinning up? */
                if((dpt_inb(sc, HA_ERROR) != 'D')
                    || (dpt_inb(sc, HA_ERROR + 1) != 'P')
                    || (dpt_inb(sc, HA_ERROR + 2) != 'T')) {
                    	printf("%s: HBA not ready\n", sc->sc_dv.dv_xname);
                        return (-1);
		}
        }

	/* 
	 * Issue the read-config command and wait for the data to appear.
	 * XXX we shouldn't be doing this with PIO, but it makes it a lot
	 * easier as no DMA setup is required.
	 */
	dpt_outb(sc, HA_COMMAND, CP_PIO_GETCFG);
	memset(ec, 0, sizeof(*ec));
	i = (offsetof(struct eata_cfg, ec_cfglen) + sizeof(ec->ec_cfglen)) >> 1;
	p = (u_int16_t *)ec;
	
	if (dpt_wait(sc, 0xFF, HA_ST_DATA_RDY, 2000)) {
		printf("%s: cfg data didn't appear (status:%02x)\n", 
		    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));
  		return (-1);
  	}

	/* Begin reading */
 	while (i--)
		*p++ = dpt_inw(sc, HA_DATA);

	i = ec->ec_cfglen;
	if (i > sizeof(struct eata_cfg) - offsetof(struct eata_cfg, ec_cfglen) -
	    sizeof(ec->ec_cfglen))
		i = sizeof(struct eata_cfg) - offsetof(struct eata_cfg, ec_cfglen) -
		    sizeof(ec->ec_cfglen);

        j = i + offsetof(struct eata_cfg, ec_cfglen) + sizeof(ec->ec_cfglen);
        i >>= 1;

	while (i--)
                *p++ = dpt_inw(sc, HA_DATA);
        
        /* Flush until we have read 512 bytes. */
        i = (512 - j + 1) >> 1;
	while (i--)
 		dpt_inw(sc, HA_DATA);
        
        /* Defaults for older Firmware */
	if (p <= (u_short *)&ec->ec_hba[DPT_MAX_CHANNELS - 1])
		ec->ec_hba[DPT_MAX_CHANNELS - 1] = 7;

        if ((dpt_inb(sc, HA_STATUS) & HA_ST_ERROR) != 0) {
        	printf("%s: HBA error\n", sc->sc_dv.dv_xname);
        	return (-1);
        }
        
        if (!ec->ec_hbavalid) {
                printf("%s: ec_hba field invalid\n", sc->sc_dv.dv_xname);
		return (-1);
	}
	
	if (memcmp(ec->ec_eatasig, "EATA", 4) != 0) {
	        printf("%s: EATA signature mismatch\n", sc->sc_dv.dv_xname);
		return (-1);
	}
	
	if (!ec->ec_dmasupported) {
	        printf("%s: DMA not supported\n", sc->sc_dv.dv_xname);
		return (-1);
	}

	return (0);
}

/*
 * Adjust the size of each I/O before it passes to the SCSI layer.
 */
void
dpt_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > DPT_MAX_XFER)
		bp->b_bcount = DPT_MAX_XFER;
	minphys(bp);
}

/*
 * Put a CCB onto the freelist.
 */
void
dpt_ccb_free(void *xsc, void *xccb)
{
	struct dpt_softc *sc = xsc;
	struct dpt_ccb *ccb = xccb;

	ccb->ccb_flg = 0;

	mtx_enter(&sc->sc_ccb_mtx);
	SLIST_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_chain);
	mtx_leave(&sc->sc_ccb_mtx);
}

/*
 * Initialize the specified CCB.
 */
int
dpt_init_ccb(sc, ccb)
	struct dpt_softc *sc;
	struct dpt_ccb *ccb;
{
	int error;
	
	/* Create the DMA map for this CCB's data */
	error = bus_dmamap_create(sc->sc_dmat, DPT_MAX_XFER, DPT_SG_SIZE, 
	    DPT_MAX_XFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
	    &ccb->ccb_dmamap_xfer);
	
	if (error) {
		printf("%s: can't create ccb dmamap (%d)\n", 
		   sc->sc_dv.dv_xname, error);
		return (error);
	}

	ccb->ccb_flg = 0;
	ccb->ccb_ccbpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr +
	    CCB_OFF(sc, ccb);
	return (0);
}

/*
 * Create a set of CCBs and add them to the free list.
 */
int
dpt_create_ccbs(sc, ccbstore, count)
	struct dpt_softc *sc;
	struct dpt_ccb *ccbstore;
	int count;
{
	struct dpt_ccb *ccb;
	int i, error;

	memset(ccbstore, 0, sizeof(struct dpt_ccb) * count);
	
	for (i = 0, ccb = ccbstore; i < count; i++, ccb++) {
		if ((error = dpt_init_ccb(sc, ccb)) != 0) {
			printf("%s: unable to init ccb, error = %d\n",
			    sc->sc_dv.dv_xname, error);
			break;
		}
		ccb->ccb_id = i;
		SLIST_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_chain);
	}

	return (i);
}

/*
 * Get a free ccb. If there are none, see if we can allocate a new one. If 
 * none are available right now and we are permitted to sleep, then wait 
 * until one becomes free, otherwise return an error.
 */
void *
dpt_ccb_alloc(void *xsc)
{
	struct dpt_softc *sc = xsc;
	struct dpt_ccb *ccb;

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = SLIST_FIRST(&sc->sc_free_ccb);
	if (ccb != NULL) {
		SLIST_REMOVE_HEAD(&sc->sc_free_ccb, ccb_chain);
		ccb->ccb_flg |= CCB_ALLOC;
	}
	mtx_leave(&sc->sc_ccb_mtx);

	return (ccb);
}

/*
 * We have a CCB which has been processed by the HBA, now we look to see how 
 * the operation went. CCBs marked with CCB_PRIVATE are not automatically
 * passed here by dpt_intr().
 */
void
dpt_done_ccb(sc, ccb)
	struct dpt_softc *sc;
	struct dpt_ccb *ccb;
{
	struct scsi_sense_data *s1, *s2;
	struct scsi_xfer *xs;
	bus_dma_tag_t dmat;
	
	dmat = sc->sc_dmat;
	xs = ccb->ccb_xs;

	SC_DEBUG(xs->sc_link, SDEV_DB2, ("dpt_done_ccb\n"));

	/*
	 * If we were a data transfer, unload the map that described the 
	 * data buffer.
	 */
	if (xs->datalen) {
		bus_dmamap_sync(dmat, ccb->ccb_dmamap_xfer, 0,
		    ccb->ccb_dmamap_xfer->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(dmat, ccb->ccb_dmamap_xfer);
	}

	/*
	 * Otherwise, put the results of the operation into the xfer and 
	 * call whoever started it.
	 */
#ifdef DIAGNOSTIC
	if ((ccb->ccb_flg & CCB_ALLOC) == 0) {
		panic("%s: done ccb not allocated!", sc->sc_dv.dv_xname);
		return;
	}
#endif
	
	if (xs->error == XS_NOERROR) {
		if (ccb->ccb_hba_status != HA_NO_ERROR) {
			switch (ccb->ccb_hba_status) {
			case HA_ERROR_SEL_TO:
				xs->error = XS_SELTIMEOUT;
				break;
			case HA_ERROR_RESET:
				xs->error = XS_RESET;
				break;
			default:	/* Other scsi protocol messes */
				printf("%s: HBA status %x\n",
				    sc->sc_dv.dv_xname, ccb->ccb_hba_status);
				xs->error = XS_DRIVER_STUFFUP;
			}
		} else if (ccb->ccb_scsi_status != SCSI_OK) {
			switch (ccb->ccb_scsi_status) {
			case SCSI_CHECK:
				s1 = &ccb->ccb_sense;
				s2 = &xs->sense;
				*s2 = *s1;
				xs->error = XS_SENSE;
				break;
			case SCSI_BUSY:
				xs->error = XS_BUSY;
				break;
			default:
				printf("%s: SCSI status %x\n",
				    sc->sc_dv.dv_xname, ccb->ccb_scsi_status);
				xs->error = XS_DRIVER_STUFFUP;
			}
		} else
			xs->resid = 0;
			
		xs->status = ccb->ccb_scsi_status;
	}

	/* Mark the command as done */
	scsi_done(xs);
}

/*
 * Start a SCSI command.
 */
void
dpt_scsi_cmd(struct scsi_xfer *xs)
{
	int error, i, flags, s;
	struct scsi_link *sc_link;
	struct dpt_channel *ch;
	struct dpt_softc *sc;
	struct dpt_ccb *ccb;
	struct eata_sg *sg;
	struct eata_cp *cp;
	bus_dma_tag_t dmat;
	bus_dmamap_t xfer;

	sc_link = xs->sc_link;
	flags = xs->flags;
	ch = sc_link->adapter_softc;
	sc = ch->ch_sc;
	dmat = sc->sc_dmat;

	SC_DEBUG(sc_link, SDEV_DB2, ("dpt_scsi_cmd\n"));

	/* Cmds must be no more than 12 bytes for us */
	if (xs->cmdlen > 12) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	/* XXX we can't reset devices just yet */
	if ((xs->flags & SCSI_RESET) != 0) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	ccb = xs->io;
	ccb->ccb_flg &= ~CCB_ALLOC;

	ccb->ccb_xs = xs;
	ccb->ccb_timeout = xs->timeout;

	cp = &ccb->ccb_eata_cp;
	bcopy(xs->cmd, &cp->cp_scsi_cmd, xs->cmdlen);
	cp->cp_ccbid = ccb->ccb_id;
	cp->cp_id = sc_link->target;
	cp->cp_lun = sc_link->lun;
	cp->cp_channel = ch->ch_index;
	cp->cp_senselen = sizeof(ccb->ccb_sense);
	cp->cp_stataddr = htobe32(sc->sc_sppa);
	cp->cp_dispri = 1;
	cp->cp_identify = 1;
	cp->cp_autosense = 1;
	cp->cp_datain = ((xs->flags & SCSI_DATA_IN) != 0);
	cp->cp_dataout = ((xs->flags & SCSI_DATA_OUT) != 0);
	cp->cp_interpret = (sc->sc_hbaid[ch->ch_index] == sc_link->target);

	/* Synchronous xfers musn't write-back through the cache */
	if (xs->bp != NULL && (xs->bp->b_flags & (B_ASYNC | B_READ)) == 0)
		cp->cp_nocache = 1;
	else
		cp->cp_nocache = 0;

	cp->cp_senseaddr = htobe32(sc->sc_dmamap_ccb->dm_segs[0].ds_addr +
	    CCB_OFF(sc, ccb) + offsetof(struct dpt_ccb, ccb_sense));
	    
	if (xs->datalen) {
		xfer = ccb->ccb_dmamap_xfer;
		error = bus_dmamap_load(dmat, xfer, xs->data, 
		    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ? 
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);

		if (error) {
			printf("%s: dpt_scsi_cmd: ", sc->sc_dv.dv_xname); 
			if (error == EFBIG)
				printf("more than %d dma segs\n", DPT_SG_SIZE);
			else
				printf("error %d loading dma map\n", error);
		
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}

		bus_dmamap_sync(dmat, xfer, 0, xfer->dm_mapsize,
		    (flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
		    BUS_DMASYNC_PREWRITE);

		/* Don't bother using scatter/gather for just 1 segment */
		if (xfer->dm_nsegs == 1) {
			cp->cp_dataaddr = htobe32(xfer->dm_segs[0].ds_addr);
			cp->cp_datalen = htobe32(xfer->dm_segs[0].ds_len);
			cp->cp_scatter = 0;
		} else {
			/*
			 * Load the hardware scatter/gather map with the
			 * contents of the DMA map.
			 */
			sg = ccb->ccb_sg;
			for (i = 0; i < xfer->dm_nsegs; i++, sg++) {
				sg->sg_addr =
				  htobe32(xfer->dm_segs[i].ds_addr);
				sg->sg_len =
				  htobe32(xfer->dm_segs[i].ds_len);
			}
			cp->cp_dataaddr = htobe32(CCB_OFF(sc, ccb) + 
			    sc->sc_dmamap_ccb->dm_segs[0].ds_addr +
			    offsetof(struct dpt_ccb, ccb_sg));
			cp->cp_datalen = htobe32(i * sizeof(struct eata_sg));
			cp->cp_scatter = 1;
		}
	} else {
		cp->cp_dataaddr = 0;
		cp->cp_datalen = 0;
		cp->cp_scatter = 0;
	}

	/* Sync up CCB and status packet */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, CCB_OFF(sc, ccb), 
	    sizeof(struct dpt_ccb), BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff, 
	    sizeof(struct eata_sp), BUS_DMASYNC_PREREAD);

	/* 
	 * Start the command. If we are polling on completion, mark it
	 * private so that dpt_intr/dpt_done_ccb don't recycle the CCB 
	 * without us noticing.
	 */
	if ((xs->flags & SCSI_POLL) != 0)
		ccb->ccb_flg |= CCB_PRIVATE; 
	
	if (dpt_cmd(sc, &ccb->ccb_eata_cp, ccb->ccb_ccbpa, CP_DMA_CMD, 0)) {
		printf("%s: dpt_cmd failed\n", sc->sc_dv.dv_xname);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	if ((xs->flags & SCSI_POLL) == 0)
		return;

	/* Don't wait longer than this single command wants to wait */
	if (dpt_poll(sc, ccb)) {
		dpt_timeout(ccb);
		/* Wait for abort to complete */
		if (dpt_poll(sc, ccb))
			dpt_timeout(ccb);
	} 
	
	s = splbio();
	dpt_done_ccb(sc, ccb);
	splx(s);
}

/*
 * Specified CCB has timed out, abort it.
 */
void
dpt_timeout(arg)
	void *arg;
{
	struct scsi_link *sc_link;
	struct scsi_xfer *xs;
	struct dpt_channel *ch;
	struct dpt_softc *sc;
 	struct dpt_ccb *ccb;
	int s;
	
	ccb = arg;
	xs = ccb->ccb_xs;
	sc_link = xs->sc_link;
	ch = sc_link->adapter_softc;
	sc = ch->ch_sc;

	sc_print_addr(sc_link);
	printf("timed out (status:%02x aux status:%02x)", 
	    dpt_inb(sc, HA_STATUS), dpt_inb(sc, HA_AUX_STATUS));

	s = splbio();

	if ((ccb->ccb_flg & CCB_ABORT) != 0) {
		/* Abort timed out, reset the HBA */
		printf(" AGAIN, resetting HBA\n");
		dpt_outb(sc, HA_COMMAND, CP_RESET);
		DELAY(750000);
	} else {
		/* Abort the operation that has timed out */
		printf("\n");
		ccb->ccb_xs->error = XS_TIMEOUT;
		ccb->ccb_timeout = DPT_ABORT_TIMEOUT;
		ccb->ccb_flg |= CCB_ABORT;
		/* Start the abort */
		if (dpt_cmd(sc, &ccb->ccb_eata_cp, ccb->ccb_ccbpa, 
		    CP_IMMEDIATE, CPI_SPEC_ABORT))
		    printf("%s: dpt_cmd failed\n", sc->sc_dv.dv_xname);
	}

	splx(s);
}

#ifdef DEBUG
/*
 * Dump the contents of an EATA status packet.
 */
void
dpt_dump_sp(sp)
	struct eata_sp *sp;
{
	int i;
	
	printf("\thba_status\t%02x\n", sp->sp_hba_status);
	printf("\tscsi_status\t%02x\n", sp->sp_scsi_status);	
	printf("\tinv_residue\t%d\n", sp->sp_inv_residue);	
	printf("\tccbid\t\t%d\n", sp->sp_ccbid);
	printf("\tid_message\t%d\n", sp->sp_id_message);
	printf("\tque_message\t%d\n", sp->sp_que_message);	
	printf("\ttag_message\t%d\n", sp->sp_tag_message);
	printf("\tmessages\t");
	
	for (i = 0; i < 9; i++)
		printf("%d ", sp->sp_messages[i]);
		
	printf("\n");
}
#endif	/* DEBUG */

/*
 * Get inquiry data from the adapter.
 */
void
dpt_hba_inquire(sc, ei)
	struct dpt_softc *sc;
	struct eata_inquiry_data **ei;
{
	struct dpt_ccb *ccb;
	struct eata_cp *cp;
	bus_dma_tag_t dmat;
	
	*ei = (struct eata_inquiry_data *)sc->sc_scr;
	dmat = sc->sc_dmat;

	/* Get a CCB and mark as private */
	if ((ccb = scsi_io_get(&sc->sc_iopool, SCSI_NOSLEEP)) == NULL)
		panic("%s: no CCB for inquiry", sc->sc_dv.dv_xname);
	
	ccb->ccb_flg |= CCB_PRIVATE;
	ccb->ccb_timeout = 200;

	/* Put all the arguments into the CCB */
	cp = &ccb->ccb_eata_cp;
	cp->cp_ccbid = ccb->ccb_id;
	cp->cp_id = sc->sc_hbaid[0];
	cp->cp_lun = 0;
	cp->cp_channel = 0;
	cp->cp_senselen = sizeof(ccb->ccb_sense);
	cp->cp_stataddr = htobe32(sc->sc_sppa);
	cp->cp_dispri = 1;
	cp->cp_identify = 1;
	cp->cp_autosense = 0;
	cp->cp_interpret = 1;
	cp->cp_nocache = 0;
	cp->cp_datain = 1;
	cp->cp_dataout = 0;
	cp->cp_senseaddr = 0;
	cp->cp_dataaddr = htobe32(sc->sc_scrpa);
	cp->cp_datalen = htobe32(sizeof(struct eata_inquiry_data));
	cp->cp_scatter = 0;
	
	/* Put together the SCSI inquiry command */
	memset(&cp->cp_scsi_cmd, 0, 12);	/* XXX */
	cp->cp_scsi_cmd = INQUIRY;
	cp->cp_len = sizeof(struct eata_inquiry_data);

	/* Sync up CCB, status packet and scratch area */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, CCB_OFF(sc, ccb), 
	    sizeof(struct dpt_ccb), BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff, 
	    sizeof(struct eata_sp), BUS_DMASYNC_PREREAD);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_scroff, 
	    sizeof(struct eata_inquiry_data), BUS_DMASYNC_PREREAD);

	/* Start the command and poll on completion */
	if (dpt_cmd(sc, &ccb->ccb_eata_cp, ccb->ccb_ccbpa, CP_DMA_CMD, 0))
		panic("%s: dpt_cmd failed", sc->sc_dv.dv_xname);

	if (dpt_poll(sc, ccb))
		panic("%s: inquiry timed out", sc->sc_dv.dv_xname);

	if (ccb->ccb_hba_status != HA_NO_ERROR ||
	    ccb->ccb_scsi_status != SCSI_OK)
	    	panic("%s: inquiry failed (hba:%02x scsi:%02x", 
	    	    sc->sc_dv.dv_xname, ccb->ccb_hba_status,
	    	    ccb->ccb_scsi_status);
	
	/* Sync up the DMA map and free CCB, returning */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_scroff, 
	    sizeof(struct eata_inquiry_data), BUS_DMASYNC_POSTREAD);
	scsi_io_put(&sc->sc_iopool, ccb);
}
@


1.34
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.33 2011/06/21 20:23:49 matthew Exp $	*/
d72 1
a73 1
#include <machine/endian.h>
@


1.33
log
@Two dpt(4) fixes:

  1. Change adapter_softc to point to a per-channel intermediary
     object instead of pointing to the dpt_softc directly.  This
     removes dpt(4) dependency on scsibus unit numbers.

  2. Fix dpt(4) to use a struct scsibus_attach_args instead of a
     struct scsi_link for attaching the scsibus.  (Evidently no one
     has tried using dpt(4) since Nov 2006...)

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.32 2011/04/26 22:55:58 matthew Exp $	*/
a318 3
	/* Set shutdownhook before we start any device activity */
	sc->sc_sdh = shutdownhook_establish(dpt_shutdown, sc);

d384 1
a384 1
 * Our 'shutdownhook' to cleanly shut down the HBA. The HBA must flush 
d388 1
a388 2
dpt_shutdown(xxx_sc)
	void *xxx_sc;
d390 1
a390 1
	struct dpt_softc *sc;
a391 2
	sc = xxx_sc;
	printf("shutting down %s...", sc->sc_dv.dv_xname);
a393 1
	printf(" done\n");
@


1.32
log
@No point in a per-attachment scsi_adapter; move to global dpt_switch
like we do in other SCSI drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.31 2011/04/26 22:46:25 matthew Exp $	*/
d360 2
d363 1
d365 5
a370 1
		link->scsibus = i;
d375 1
a375 1
		link->adapter_softc = sc;
d378 5
a382 1
		config_found(&sc->sc_dv, link, scsiprint);
d802 1
d812 2
a813 1
	sc = sc_link->adapter_softc;
d843 1
a843 1
	cp->cp_channel = sc_link->scsibus;
d851 1
a851 1
	cp->cp_interpret = (sc->sc_hbaid[sc_link->scsibus] == sc_link->target);
d959 1
d967 2
a968 1
	sc  = sc_link->adapter_softc;
@


1.31
log
@A plausible attempt at iopoolifying dpt(4).

ok dlg@@; miod@@ warns me to not hold my breath on anyone testing this
diff though...
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.30 2011/04/26 18:31:16 matthew Exp $	*/
d89 5
d358 1
a358 4
	/* Fill in the adapter, each link and attach in turn */
	sc->sc_adapter.scsi_cmd = dpt_scsi_cmd;
	sc->sc_adapter.scsi_minphys = dpt_minphys;

d367 1
a367 1
		link->adapter = &sc->sc_adapter;
@


1.30
log
@Make dpt(4) compile on 64-bit arches; no binary change on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.29 2011/04/26 18:05:12 matthew Exp $	*/
d86 2
d302 3
d368 1
d611 1
a611 3
dpt_free_ccb(sc, ccb)
	struct dpt_softc *sc;
	struct dpt_ccb *ccb;
d613 2
a614 1
	int s;
a615 1
	s = splbio();
d618 3
a620 3
	if (SLIST_NEXT(ccb, ccb_chain) == NULL)
		wakeup(&sc->sc_free_ccb);
	splx(s);
d682 2
a683 4
struct dpt_ccb *
dpt_alloc_ccb(sc, flg)
	struct dpt_softc *sc;
	int flg;
d685 1
a686 3
	int s;

	s = splbio();
d688 5
a692 11
	for (;;) {
		ccb = SLIST_FIRST(&sc->sc_free_ccb);
		if (ccb) {
			SLIST_REMOVE_HEAD(&sc->sc_free_ccb, ccb_chain);
			break;
		}
		if ((flg & SCSI_NOSLEEP) != 0) {
			splx(s);
			return (NULL);
		}
		tsleep(&sc->sc_free_ccb, PRIBIO, "dptccb", 0);
d694 1
a695 2
	ccb->ccb_flg |= CCB_ALLOC;
	splx(s);
d777 1
a777 2
	/* Free up the CCB and mark the command as done */
	dpt_free_ccb(sc, ccb);
a802 3
	/* Protect the queue */
	s = splbio();

a806 1
		splx(s);
d810 3
a812 11
		/* XXX we can't reset devices just yet */
		if ((xs->flags & SCSI_RESET) != 0) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			splx(s);
			return;
		}

	/* Get a CCB */
	if ((ccb = dpt_alloc_ccb(sc, xs->flags)) == NULL) {
		xs->error = XS_NO_CCB;
a813 1
		splx(s);
d817 2
a818 1
	splx(s);
a860 1
			dpt_free_ccb(sc, ccb);
d914 1
a914 2
		dpt_free_ccb(sc, ccb);
		xs->error = XS_NO_CCB;
d1021 1
a1021 1
	if ((ccb = dpt_alloc_ccb(sc, 0)) == NULL)
d1076 1
a1076 1
	dpt_free_ccb(sc, ccb);
@


1.29
log
@Get rid of NetBSD/OpenBSD ifdefs; our SCSI stacks have diverged too
much for them to make sense anymore.

Diff prepared with sed; no change to dpt.o on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.28 2010/07/20 20:46:18 mk Exp $	*/
d88 1
a88 1
#define offsetof(type, member) (int)((&((type *)0)->member))
d533 1
a533 2
	i = ((int)&((struct eata_cfg *)0)->ec_cfglen + 
	    sizeof(ec->ec_cfglen)) >> 1;
d546 5
a550 6
        if ((i = ec->ec_cfglen) > (sizeof(struct eata_cfg)
            - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))
            - sizeof(ec->ec_cfglen)))
                i = sizeof(struct eata_cfg)
                  - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))
                  - sizeof(ec->ec_cfglen);
d552 1
a552 2
        j = i + (int)(&(((struct eata_cfg *)0L)->ec_cfglen)) + 
            sizeof(ec->ec_cfglen);
@


1.28
log
@Use an SLIST rather than a TAILQ for the ccb free list.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.26 2010/06/28 18:31:02 krw Exp $	*/
a73 3
#ifdef __NetBSD__
#include <machine/bswap.h>
#endif /* __NetBSD__ */
a75 6
#ifdef __NetBSD__
#include <dev/scsipi/scsi_all.h>
#include <dev/scsipi/scsipi_all.h>
#include <dev/scsipi/scsiconf.h>
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a77 1
#endif /* __OpenBSD__ */
a81 1
#ifdef __OpenBSD__
a84 1
#endif /* __OpenBSD__ */
a85 9
#ifdef __NetBSD__
/* A default for our link struct */
static struct scsipi_device dpt_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};
#endif /* __NetBSD__ */
a348 5
#ifdef __NetBSD__
	sc->sc_adapter.scsipi_cmd = dpt_scsi_cmd;
	sc->sc_adapter.scsipi_minphys = dpt_minphys;
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a350 1
#endif /* __OpenBSD__ */
a352 4
#ifdef __NetBSD__
		struct scsipi_link *link;
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a353 1
#endif /* __OpenBSD__ */
a355 9
#ifdef __NetBSD__
		link->scsipi_scsi.scsibus = i;
		link->scsipi_scsi.adapter_target = sc->sc_hbaid[i];
		link->scsipi_scsi.max_lun = ec->ec_maxlun;
		link->scsipi_scsi.max_target = ec->ec_maxtarget;
		link->type = BUS_SCSI;
		link->device = &dpt_dev;
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a359 1
#endif /* __OpenBSD__ */
a696 4
#ifdef __NetBSD__
		if ((flg & XS_CTL_NOSLEEP) != 0) {
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a697 1
#endif /* __OpenBSD__ */
a718 5
#ifdef __NetBSD__
	struct scsipi_sense_data *s1, *s2;
	struct scsipi_xfer *xs;
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a720 1
#endif /* __OpenBSD__ */
a768 4
#ifdef __NetBSD__
				s2 = &xs->sense.scsi_sense;
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a769 1
#endif /* __OpenBSD__ */
a788 5
#ifdef __NetBSD__
	xs->xs_status |= XS_STS_DONE;
	scsipi_done(xs);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a789 1
#endif /* __OpenBSD__ */
a794 5
#ifdef __NetBSD__
int
dpt_scsi_cmd(struct scsipi_xfer *xs)
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a796 1
#endif /* __OpenBSD__ */
a798 4
#ifdef __NetBSD__
	struct scsipi_link *sc_link;
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a799 1
#endif /* __OpenBSD__ */
a807 4
#ifdef __NetBSD__
	flags = xs->xs_control;
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a808 1
#endif /* __OpenBSD__ */
a825 4
#ifdef __NetBSD__
		if ((flags & XS_CTL_RESET) != 0) {
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a826 1
#endif /* __OpenBSD__ */
a833 4
#ifdef __NetBSD__
	if ((ccb = dpt_alloc_ccb(sc, flags)) == NULL) {
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a834 1
#endif /* __OpenBSD__ */
a846 4
#ifdef __NetBSD__
	memcpy(&cp->cp_scsi_cmd, xs->cmd, xs->cmdlen);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a847 1
#endif /* __OpenBSD__ */
a848 6
#ifdef __NetBSD__
	cp->cp_id = sc_link->scsipi_scsi.target;
	cp->cp_lun = sc_link->scsipi_scsi.lun;
	cp->cp_channel = sc_link->scsipi_scsi.channel;
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a851 1
#endif /* __OpenBSD__ */
a856 7
#ifdef __NetBSD__
	cp->cp_datain = ((flags & XS_CTL_DATA_IN) != 0);
	cp->cp_dataout = ((flags & XS_CTL_DATA_OUT) != 0);
	cp->cp_interpret = (sc->sc_hbaid[sc_link->scsipi_scsi.channel] ==
	    sc_link->scsipi_scsi.target);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a859 1
#endif /* __OpenBSD__ */
a871 6
#ifdef __NetBSD__
		error = bus_dmamap_load(dmat, xfer, xs->data, 
		    xs->datalen, NULL, (flags & XS_CTL_NOSLEEP) ? 
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a874 1
#endif /* __OpenBSD__ */
a966 5
#ifdef __NetBSD__
	struct scsipi_link *sc_link;
	struct scsipi_xfer *xs;
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a968 1
#endif /* __OpenBSD__ */
a977 4
#ifdef __NetBSD__
	scsi_print_addr(sc_link);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
a978 1
#endif /* __OpenBSD__ */
@


1.27
log
@Make this compile again (was broken in rev 1.24 as far as I can tell),
even though we don't actually compile it in any configurations.

ok krw
@
text
@d318 1
a318 1
	TAILQ_INIT(&sc->sc_free_ccb);
a657 1
	TAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_chain);
d659 1
a659 2
	/* Wake anybody waiting for a free ccb */
	if (TAILQ_NEXT(ccb, ccb_chain) == NULL)
d712 1
a712 1
		TAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_chain);
d734 1
a734 1
		ccb = TAILQ_FIRST(&sc->sc_free_ccb);
d736 1
a736 1
			TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ccb_chain);
@


1.26
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.25 2010/05/20 00:55:17 krw Exp $	*/
d861 1
d863 1
a863 3
dpt_scsi_cmd(xs)
#ifdef __NetBSD__
	struct scsipi_xfer *xs;
d866 2
a867 1
	struct scsi_xfer *xs;
@


1.25
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.24 2010/03/23 01:57:19 krw Exp $	*/
d98 1
a99 1
#ifdef __NetBSD__
a100 4
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
static struct scsi_device dpt_dev = {
#endif /* __OpenBSD__ */
d106 1
d394 1
a401 1
		link->device = &dpt_dev;
@


1.24
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.23 2010/01/09 23:15:06 krw Exp $	*/
a1006 1
			s = splbio();
a1007 1
			splx(s);
a1061 1
		s = splbio();
a1062 1
		splx(s);
@


1.23
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.22 2009/11/22 14:14:10 krw Exp $	*/
d907 1
a907 1
		return (COMPLETE);
d920 1
a920 1
			return (COMPLETE);
d930 2
d933 1
a933 1
		return (NO_CCB);
d1010 1
a1010 1
			return (COMPLETE);
d1063 5
a1067 1
		return (NO_CCB);
d1071 1
a1071 1
		return (SUCCESSFULLY_QUEUED);
a1083 2

	return (COMPLETE);
@


1.22
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.21 2009/09/04 04:57:14 miod Exp $	*/
a856 1
	xs->flags |= ITSDONE;
a904 1
		xs->flags |= ITSDONE;
a917 1
			xs->flags |= ITSDONE;
a1004 1
			xs->flags |= ITSDONE;
@


1.21
log
@Missing scsi_done() in some error path returning COMPLETE; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.20 2009/02/16 21:19:06 miod Exp $	*/
d1065 1
a1065 1
		return (TRY_AGAIN_LATER);
@


1.20
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.19 2008/11/26 22:03:11 krw Exp $	*/
d905 3
a908 1
		xs->error = XS_DRIVER_STUFFUP;
d919 3
a922 1
			xs->error = XS_DRIVER_STUFFUP;
d1008 4
@


1.19
log
@Stop maintaining internal queues of received scsi_xfer structures.

We can now just push unwanted ones back up into the SCSI layer
with NO_CCB like other drivers.

"Please do so" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.18 2008/11/24 00:31:35 krw Exp $	*/
d642 1
a642 2
dpt_minphys(bp)
	struct buf *bp;
a643 1

@


1.18
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.17 2008/09/12 11:14:04 miod Exp $	*/
a92 3
static void dpt_enqueue(struct dpt_softc *, struct scsi_xfer *, int);
static struct scsi_xfer *dpt_dequeue(struct dpt_softc *);

a861 14

	/*
	 * If there are entries in the software queue, try to run the first
	 * one. We should be more or less guaranteed to succeed, since we
	 * just freed an CCB. NOTE: dpt_scsi_cmd() relies on our calling it
	 * with the first entry in the queue.
	 */
#ifdef __NetBSD__
	if ((xs = TAILQ_FIRST(&sc->sc_queue)) != NULL)
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
	if ((xs = LIST_FIRST(&sc->sc_queue)) != NULL)
#endif /* __OpenBSD__ */
		dpt_scsi_cmd(xs);
a863 42
#ifdef __OpenBSD__
/*
 * Insert a scsi_xfer into the software queue.  We overload xs->free_list
 * to avoid having to allocate additional resources (since we're used
 * only during resource shortages anyhow.
 */
static void
dpt_enqueue(sc, xs, infront)
	struct dpt_softc *sc;
	struct scsi_xfer *xs;
	int             infront;
{

	if (infront || LIST_EMPTY(&sc->sc_queue)) {
		if (LIST_EMPTY(&sc->sc_queue))
			sc->sc_queuelast = xs;
		LIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);
		return;
	}
	LIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);
	sc->sc_queuelast = xs;
}

/*
 * Pull a scsi_xfer off the front of the software queue.
 */
static struct scsi_xfer *
dpt_dequeue(sc)
	struct dpt_softc *sc;
{
	struct scsi_xfer *xs;

	xs = LIST_FIRST(&sc->sc_queue);
	LIST_REMOVE(xs, free_list);

	if (LIST_EMPTY(&sc->sc_queue))
		sc->sc_queuelast = NULL;

	return (xs);
}
#endif /* __OpenBSD__ */

d876 1
a876 1
	int error, i, flags, s, fromqueue, dontqueue;
a898 2
	fromqueue = 0;
	dontqueue = 0;
d905 6
a910 20
	/*
	 * If we're running the queue from dpt_done_ccb(), we've been called 
	 * with the first queue entry as our argument.
	 */
#ifdef __NetBSD__
	if (xs == TAILQ_FIRST(&sc->sc_queue)) {
		TAILQ_REMOVE(&sc->sc_queue, xs, adapter_q);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
	if (xs == LIST_FIRST(&sc->sc_queue)) {
		xs = dpt_dequeue(sc);
#endif /* __OpenBSD__ */
		fromqueue = 1;
	} else {
		/* Cmds must be no more than 12 bytes for us */
		if (xs->cmdlen > 12) {
			splx(s);
			xs->error = XS_DRIVER_STUFFUP;
			return (COMPLETE);
		}
a923 38
		/* Polled requests can't be queued for later */
#ifdef __NetBSD__
		dontqueue = flags & XS_CTL_POLL;
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
		dontqueue = xs->flags & SCSI_POLL;
#endif /* __OpenBSD__ */

		/* If there are jobs in the queue, run them first */
#ifdef __NetBSD__
		if (TAILQ_FIRST(&sc->sc_queue) != NULL) {
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
		if (!LIST_EMPTY(&sc->sc_queue)) {
#endif /* __OpenBSD__ */
			/*
			 * If we can't queue we abort, since we must 
			 * preserve the queue order.
			 */
			if (dontqueue) {
				splx(s);
				return (TRY_AGAIN_LATER);
			}

			/* Swap with the first queue entry. */
#ifdef __NetBSD__
			TAILQ_INSERT_TAIL(&sc->sc_queue, xs, adapter_q);
			xs = TAILQ_FIRST(&sc->sc_queue);
			TAILQ_REMOVE(&sc->sc_queue, xs, adapter_q);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
			dpt_enqueue(sc, xs, 0);
			xs = dpt_dequeue(sc);
#endif /* __OpenBSD__ */
			fromqueue = 1;
		}
	}

a930 19
		/* If we can't queue, we lose */
		if (dontqueue) {
			splx(s);
			return (NO_CCB);
		}
		
		/* 
		 * Stuff request into the queue, in front if we came off 
		 * it in the first place.
		 */
#ifdef __NetBSD__
		if (fromqueue)
			TAILQ_INSERT_HEAD(&sc->sc_queue, xs, adapter_q);
		else
			TAILQ_INSERT_TAIL(&sc->sc_queue, xs, adapter_q);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
		dpt_enqueue(sc, xs, fromqueue);
#endif /* __OpenBSD__ */
d932 1
a932 1
		return (SUCCESSFULLY_QUEUED);
d1053 1
a1053 1
	if (dontqueue != 0)
d1062 1
a1062 1
	if (dontqueue == 0)
@


1.17
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.16 2008/07/30 18:08:04 miod Exp $	*/
d1047 1
a1047 1
			return (TRY_AGAIN_LATER);
@


1.16
log
@Do not print adapter target id on the attachment line, now that scsibus(4)
prints it. These should be the last offenders.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.15 2008/06/26 05:42:15 ray Exp $	*/
a1117 1
#ifdef	TFS
d1119 3
a1121 4
		if ((flags & XS_CTL_DATA_UIO) != 0) {
			error = bus_dmamap_load_uio(dmat, xfer, 
			    (struct uio *)xs->data, (flags & XS_CTL_NOSLEEP) ? 
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
d1124 3
a1126 4
		if ((xs->flags & SCSI_DATA_UIO) != 0) {
			error = bus_dmamap_load_uio(dmat, xfer, 
			    (xs->flags & SCSI_NOSLEEP) ?
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
a1127 14
		} else
#endif /*TFS */
		{
#ifdef __NetBSD__
			error = bus_dmamap_load(dmat, xfer, xs->data, 
			    xs->datalen, NULL, (flags & XS_CTL_NOSLEEP) ? 
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
			error = bus_dmamap_load(dmat, xfer, xs->data, 
			    xs->datalen, NULL, (xs->flags & SCSI_NOSLEEP) ? 
			    BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
#endif /* __OpenBSD__ */
		}
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.14 2008/05/13 02:24:08 brad Exp $	*/
d367 1
a367 1
	printf("%s: %d queued commands, %d channel(s), adapter on ID(s)", 
a368 4

	for (i = 0; i <= ec->ec_maxchannel; i++)
		printf(" %d", ec->ec_hba[3 - i]);
	printf("\n");
@


1.14
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.13 2007/11/05 20:30:44 krw Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@More scsi_done() at SPLBIO. Wrap another interrupt function call while
polling in splbio/splx. Wrap one call to dpt_done_ccb() not already at
SPLBIO.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.12 2007/04/10 17:47:55 miod Exp $	*/
a70 5

#include <sys/cdefs.h>
#ifdef __NetBSD__
__KERNEL_RCSID(0, "$NetBSD: dpt.c,v 1.12 1999/10/23 16:26:33 ad Exp $");
#endif /* __NetBSD__ */
@


1.12
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.11 2005/12/03 16:53:16 krw Exp $	*/
d524 1
a524 1
	int i;
d535 2
a536 1
                if ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) != 0)
d538 2
d1238 1
d1240 2
@


1.11
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.10 2004/12/26 21:22:13 miod Exp $	*/
d433 1
a433 1
 * all data from it's cache and mark array groups as clean.
@


1.10
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.9 2003/10/21 18:58:49 jmc Exp $	*/
a1032 1
				xs->error = XS_DRIVER_STUFFUP;
a1059 1
			xs->error = XS_DRIVER_STUFFUP;
a1219 1
		xs->error = XS_DRIVER_STUFFUP;
@


1.9
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.8 2002/12/11 18:43:14 henning Exp $	*/
d682 1
a682 1
	if (ccb->ccb_chain.tqe_next == 0)
d889 1
a889 1
	if ((xs = sc->sc_queue.lh_first) != NULL)
d907 2
a908 2
	if (infront || sc->sc_queue.lh_first == NULL) {
		if (sc->sc_queue.lh_first == NULL)
d926 1
a926 1
	xs = sc->sc_queue.lh_first;
d929 1
a929 1
	if (sc->sc_queue.lh_first == NULL)
d988 1
a988 1
	if (xs == sc->sc_queue.lh_first) {
d1025 1
a1025 1
		if (sc->sc_queue.lh_first != NULL) {
@


1.8
log
@sendbug(1), not send-pr; Peter Werner
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.7 2002/10/09 23:43:11 krw Exp $	*/
d369 1
a369 1
	/* Find the cannonical name for the board */
@


1.7
log
@Remove trailing '\n's from panic messages.

Started by a commit to siop from provos@@netbsd.org.

ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.6 2002/03/14 01:26:54 millert Exp $	*/
d148 1
a148 1
	NULL,     "unknown adapter, please report using send-pr(1)",
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.5 2001/11/05 17:25:58 art Exp $	*/
d528 1
a528 1
		panic("dpt_poll: called for non-CCB_PRIVATE request\n");
d822 1
a822 1
		panic("%s: done ccb not allocated!\n", sc->sc_dv.dv_xname);
@


1.5
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.4 2001/07/13 17:04:28 mickey Exp $	*/
d105 2
a106 2
static void dpt_enqueue __P((struct dpt_softc *, struct scsi_xfer *, int));
static struct scsi_xfer *dpt_dequeue __P((struct dpt_softc *));
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.5 2001/11/05 17:25:58 art Exp $	*/
d105 2
a106 2
static void dpt_enqueue(struct dpt_softc *, struct scsi_xfer *, int);
static struct scsi_xfer *dpt_dequeue(struct dpt_softc *);
@


1.5.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.5.2.1 2002/06/11 03:42:18 art Exp $	*/
d528 1
a528 1
		panic("dpt_poll: called for non-CCB_PRIVATE request");
d822 1
a822 1
		panic("%s: done ccb not allocated!", sc->sc_dv.dv_xname);
@


1.5.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d148 1
a148 1
	NULL,     "unknown adapter, please report using sendbug(1)",
@


1.4
log
@initialize bus width and number of luns supported.
this is tested on SmartRAID IV and consistant w/
what netbsd does.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.3 2001/07/08 17:46:46 espie Exp $	*/
a204 1
#ifdef __NetBSD__
a206 5
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
		bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb,
		    BUS_DMASYNC_POSTREAD);
#endif /* __OpenBSD__ */
a230 1
#ifdef __NetBSD__
a233 5
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, 
			    BUS_DMASYNC_POSTREAD);
#endif /* __OpenBSD__ */
a240 1
#ifdef __NetBSD__
a243 5
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
			bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, 
			    BUS_DMASYNC_POSTWRITE);
#endif /* __OpenBSD__ */
a808 1
#ifdef __NetBSD__
a810 5
		    (xs->xs_control & XS_CTL_DATA_IN) ? BUS_DMASYNC_POSTREAD :
		    BUS_DMASYNC_POSTWRITE);
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
		bus_dmamap_sync(dmat, ccb->ccb_dmamap_xfer,
a812 1
#endif /* __OpenBSD__ */
a1172 1
#ifdef __NetBSD__
d1174 1
a1174 1
		    (flags & XS_CTL_DATA_IN) ? BUS_DMASYNC_PREREAD :
a1175 5
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
		bus_dmamap_sync(dmat, xfer, (xs->flags & SCSI_DATA_IN) ?
				BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
#endif /* __OpenBSD__ */
a1206 1
#ifdef __NetBSD__
a1210 5
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);
#endif /* __OpenBSD__ */
a1370 1
#ifdef __NetBSD__
a1376 6
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);
#endif /* __OpenBSD__ */
a1391 1
#ifdef __NetBSD__
a1393 4
#endif /* __NetBSD__ */
#ifdef __OpenBSD__
	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_POSTREAD);
#endif /* __OpenBSD__ */
@


1.3
log
@Fix thinko. Okay millert@@
Uncovered by gcc 3.0, since the bad code does have unpredictable behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.2 2001/03/25 06:19:38 csapuntz Exp $	*/
d438 2
@


1.2
log
@Missing splx
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.1 1999/11/30 07:55:56 cmetz Exp $	*/
d384 1
a384 1
		model[i++] = ei->ei_model[i];
@


1.1
log
@Added port of the NetBSD (-current) DPT SmartCache III/IV PCI/EISA host adapter
driver to OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.0 1999/08/04 23:27:48 niklas Exp $	*/
d1030 1
@


1.1.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.2 2001/03/25 06:19:38 csapuntz Exp $	*/
a1029 1
			splx(s);
@


1.1.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: dpt.c,v 1.1.2.1 2001/05/14 22:23:44 niklas Exp $	*/
d384 1
a384 1
		model[i++] = ei->ei_suffix[j];
a437 2
		link->luns = ec->ec_maxlun + 1;
		link->adapter_buswidth = ec->ec_maxtarget + 1;
@


1.1.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d205 1
d208 5
d237 1
d241 5
d253 1
d257 5
d827 1
d830 5
d837 1
d1198 1
d1200 1
a1200 1
		    (flags & SCSI_DATA_IN) ? BUS_DMASYNC_PREREAD :
d1202 5
d1238 1
d1243 5
d1408 1
d1415 6
d1436 1
d1439 4
@


1.1.2.4
log
@Merge in -current from about a week ago
@
text
@d105 2
a106 2
static void dpt_enqueue(struct dpt_softc *, struct scsi_xfer *, int);
static struct scsi_xfer *dpt_dequeue(struct dpt_softc *);
@


1.1.2.5
log
@Sync the SMP branch with 3.3
@
text
@d148 1
a148 1
	NULL,     "unknown adapter, please report using sendbug(1)",
d528 1
a528 1
		panic("dpt_poll: called for non-CCB_PRIVATE request");
d822 1
a822 1
		panic("%s: done ccb not allocated!", sc->sc_dv.dv_xname);
@


1.1.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d369 1
a369 1
	/* Find the canonical name for the board */
@


