head	1.50;
access;
symbols
	OPENBSD_6_1:1.50.0.2
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.49.0.8
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.49.0.4
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.29.0.2
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.5
	UBC:1.2.0.8
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.50
date	2017.03.11.11.55.03;	author mpi;	state Exp;
branches;
next	1.49;
commitid	eXDj5wwfsbdFBB4L;

1.49
date	2015.05.24.10.57.47;	author miod;	state Exp;
branches;
next	1.48;
commitid	lWcX96d8OBs4r9kK;

1.48
date	2015.05.05.16.27.20;	author shadchin;	state Exp;
branches;
next	1.47;
commitid	OGpZ6NPD7IKNt4a2;

1.47
date	2015.03.31.02.27.30;	author jcs;	state Exp;
branches;
next	1.46;
commitid	43HoDzoL9F3CuGzh;

1.46
date	2015.03.16.01.49.11;	author jcs;	state Exp;
branches;
next	1.45;
commitid	yHIoF3FqQBnsztce;

1.45
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.44;
commitid	p4LJxGKbi0BU2cG6;

1.44
date	2015.03.12.20.24.16;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	mEj6apRO8FrXeKLL;

1.43
date	2014.12.19.07.23.57;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	cV4v1OA8Ccwr5fwb;

1.42
date	2014.10.15.15.55.42;	author uebayasi;	state Exp;
branches;
next	1.41;
commitid	TYm1otpEdh4UZ0Fg;

1.41
date	2014.10.15.15.54.47;	author uebayasi;	state Exp;
branches;
next	1.40;
commitid	qGBPOsdY9lLbZPJQ;

1.40
date	2014.10.15.13.36.45;	author uebayasi;	state Exp;
branches;
next	1.39;
commitid	nEnw3N0aAm748ksu;

1.39
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.38;
commitid	uzzBR7hz9ncd4O6G;

1.38
date	2014.07.07.18.20.15;	author shadchin;	state Exp;
branches;
next	1.37;
commitid	qKnmzoeZl0QZFs1I;

1.37
date	2013.09.24.08.33.50;	author mpi;	state Exp;
branches;
next	1.36;

1.36
date	2013.05.23.18.29.51;	author tobias;	state Exp;
branches;
next	1.35;

1.35
date	2013.04.20.18.19.59;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2013.04.20.08.01.37;	author tobias;	state Exp;
branches;
next	1.33;

1.33
date	2013.02.15.08.49.51;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2013.02.15.08.37.09;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2012.10.17.19.16.10;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2012.08.10.17.49.31;	author shadchin;	state Exp;
branches;
next	1.29;

1.29
date	2012.02.02.21.40.20;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.03.18.29.56;	author shadchin;	state Exp;
branches;
next	1.27;

1.27
date	2010.11.23.04.07.55;	author shadchin;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.28.12.48.14;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.08.13.50.24;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.05.13.50.00;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.22.14.27.44;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.21.20.10.17;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.01.12.20.31.22;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.27.16.45.20;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.25.19.16.36;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.29.04.20.37;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.16.20.03.22;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.26.22.45.27;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.31.14.38.54;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.31.14.35.51;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.08.19.52.13;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.29.12.31.29;	author martin;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.06.19.49.19;	author jcs;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.02.21.21.00;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.02.04.39.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.13.01.06.58;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.09.00.58.03;	author nordin;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.30.20.56.15;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.14.03.27.47;	author aaron;	state Exp;
branches
	1.2.4.1
	1.2.8.1;
next	1.1;

1.1
date	2000.11.13.20.12.34;	author aaron;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.24.06;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	;

1.2.8.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.2.8.2;

1.2.8.2
date	2003.05.19.21.59.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Introduce a new knob to force the first USB keyboard as console input.

By setting "machdep.forceukbd=1" you can now use your USB keyboard in
ddb(4) even if your BIOS emulates a pckbd(4).

ok tom@@, kettenis@@, deraadt@@
@
text
@/* $OpenBSD: pckbc.c,v 1.49 2015/05/24 10:57:47 miod Exp $ */
/* $NetBSD: pckbc.c,v 1.5 2000/06/09 04:58:35 soda Exp $ */

/*
 * Copyright (c) 1998
 *	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/errno.h>
#include <sys/queue.h>

#include <machine/bus.h>
#include <machine/cpu.h>

#include <dev/ic/i8042reg.h>
#include <dev/ic/pckbcvar.h>

#include "pckbd.h"

#if NPCKBD > 0
#include <dev/pckbc/pckbdvar.h>
#endif

#ifdef PCKBCDEBUG
#define DPRINTF(x...)	do { printf(x); } while (0);
#else
#define DPRINTF(x...)
#endif

/* descriptor for one device command */
struct pckbc_devcmd {
	TAILQ_ENTRY(pckbc_devcmd) next;
	int flags;
#define KBC_CMDFLAG_SYNC 1 /* give descriptor back to caller */
#define KBC_CMDFLAG_SLOW 2
	u_char cmd[4];
	int cmdlen, cmdidx, retries;
	u_char response[4];
	int status, responselen, responseidx;
};

/* data per slave device */
struct pckbc_slotdata {
	int polling; /* don't read data port in interrupt handler */
	TAILQ_HEAD(, pckbc_devcmd) cmdqueue; /* active commands */
	TAILQ_HEAD(, pckbc_devcmd) freequeue; /* free commands */
#define NCMD 5
	struct pckbc_devcmd cmds[NCMD];
};

#define CMD_IN_QUEUE(q) (!TAILQ_EMPTY(&(q)->cmdqueue))

void pckbc_init_slotdata(struct pckbc_slotdata *);
int pckbc_attach_slot(struct pckbc_softc *, pckbc_slot_t, int);
int pckbc_submatch_locators(struct device *, void *, void *);
int pckbc_submatch(struct device *, void *, void *);
int pckbcprint(void *, const char *);

struct pckbc_internal pckbc_consdata;
int pckbc_console_attached;

int pckbc_console;
static struct pckbc_slotdata pckbc_cons_slotdata;

static int pckbc_wait_output(bus_space_tag_t, bus_space_handle_t);

static int pckbc_get8042cmd(struct pckbc_internal *);
static int pckbc_put8042cmd(struct pckbc_internal *);
static int pckbc_send_devcmd(struct pckbc_internal *, pckbc_slot_t,
				  u_char);
static void pckbc_poll_cmd1(struct pckbc_internal *, pckbc_slot_t,
				 struct pckbc_devcmd *);

void pckbc_cleanqueues(struct pckbc_internal *);
void pckbc_cleanqueue(struct pckbc_slotdata *);
void pckbc_cleanup(void *);
void pckbc_poll(void *);
int pckbc_cmdresponse(struct pckbc_internal *, pckbc_slot_t, u_char);
void pckbc_start(struct pckbc_internal *, pckbc_slot_t);
int pckbcintr_internal(struct pckbc_internal *, struct pckbc_softc *);

const char *pckbc_slot_names[] = { "kbd", "aux" };

#define KBC_DEVCMD_ACK		0xfa
#define KBC_DEVCMD_RESEND	0xfe
#define KBC_DEVCMD_BAT_DONE	0xaa
#define KBC_DEVCMD_BAT_FAIL	0xfc

#define	KBD_DELAY	DELAY(8)

static inline int
pckbc_wait_output(bus_space_tag_t iot, bus_space_handle_t ioh_c)
{
	u_int i;

	for (i = 100000; i; i--)
		if (!(bus_space_read_1(iot, ioh_c, 0) & KBS_IBF)) {
			KBD_DELAY;
			return (1);
		}
	return (0);
}

int
pckbc_send_cmd(bus_space_tag_t iot, bus_space_handle_t ioh_c, u_char val)
{
	if (!pckbc_wait_output(iot, ioh_c))
		return (0);
	bus_space_write_1(iot, ioh_c, 0, val);
	return (1);
}

int
pckbc_poll_data1(bus_space_tag_t iot, bus_space_handle_t ioh_d,
    bus_space_handle_t ioh_c, pckbc_slot_t slot, int checkaux)
{
	int i;
	u_char stat;

	/* polls for ~100ms */
	for (i = 100; i; i--, delay(1000)) {
		stat = bus_space_read_1(iot, ioh_c, 0);
		if (stat & KBS_DIB) {
			register u_char c;

			KBD_DELAY;
			CPU_BUSY_CYCLE();
			c = bus_space_read_1(iot, ioh_d, 0);
			if (checkaux && (stat & KBS_AUXDATA)) {
				if (slot != PCKBC_AUX_SLOT) {
					DPRINTF("lost aux 0x%x\n", c);
					continue;
				}
			} else {
				if (slot == PCKBC_AUX_SLOT) {
					DPRINTF("lost kbd 0x%x\n", c);
					continue;
				}
			}
			return (c);
		}
	}
	return (-1);
}

/*
 * Get the current command byte.
 */
static int
pckbc_get8042cmd(struct pckbc_internal *t)
{
	bus_space_tag_t iot = t->t_iot;
	bus_space_handle_t ioh_d = t->t_ioh_d;
	bus_space_handle_t ioh_c = t->t_ioh_c;
	int data;

	if (!pckbc_send_cmd(iot, ioh_c, K_RDCMDBYTE))
		return (0);
	data = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT,
				t->t_haveaux);
	if (data == -1)
		return (0);
	t->t_cmdbyte = data;
	return (1);
}

/*
 * Pass command byte to keyboard controller (8042).
 */
static int
pckbc_put8042cmd(struct pckbc_internal *t)
{
	bus_space_tag_t iot = t->t_iot;
	bus_space_handle_t ioh_d = t->t_ioh_d;
	bus_space_handle_t ioh_c = t->t_ioh_c;

	if (!pckbc_send_cmd(iot, ioh_c, K_LDCMDBYTE))
		return (0);
	if (!pckbc_wait_output(iot, ioh_c))
		return (0);
	bus_space_write_1(iot, ioh_d, 0, t->t_cmdbyte);
	return (1);
}

static int
pckbc_send_devcmd(struct pckbc_internal *t, pckbc_slot_t slot, u_char val)
{
	bus_space_tag_t iot = t->t_iot;
	bus_space_handle_t ioh_d = t->t_ioh_d;
	bus_space_handle_t ioh_c = t->t_ioh_c;

	if (slot == PCKBC_AUX_SLOT) {
		if (!pckbc_send_cmd(iot, ioh_c, KBC_AUXWRITE))
			return (0);
	}
	if (!pckbc_wait_output(iot, ioh_c))
		return (0);
	bus_space_write_1(iot, ioh_d, 0, val);
	return (1);
}

int
pckbc_is_console(bus_space_tag_t iot, bus_addr_t addr)
{
	if (pckbc_console && !pckbc_console_attached &&
	    pckbc_consdata.t_iot == iot &&
	    pckbc_consdata.t_addr == addr)
		return (1);
	return (0);
}

int
pckbc_submatch_locators(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct pckbc_attach_args *pa = aux;

	if (cf->cf_loc[PCKBCCF_SLOT] != PCKBCCF_SLOT_DEFAULT &&
	    cf->cf_loc[PCKBCCF_SLOT] != pa->pa_slot)
		return (0);
	return (1);
}

int
pckbc_submatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;

	if (pckbc_submatch_locators(parent, match, aux) == 0)
		return (0);
	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

int
pckbc_attach_slot(struct pckbc_softc *sc, pckbc_slot_t slot, int force)
{
	struct pckbc_internal *t = sc->id;
	struct pckbc_attach_args pa;
	int found;

	pa.pa_tag = t;
	pa.pa_slot = slot;
	found = (config_found_sm((struct device *)sc, &pa, pckbcprint,
	    force ? pckbc_submatch_locators : pckbc_submatch) != NULL);

	if ((found || slot == PCKBC_AUX_SLOT) && !t->t_slotdata[slot]) {
		t->t_slotdata[slot] = malloc(sizeof(struct pckbc_slotdata),
					     M_DEVBUF, M_NOWAIT);
		if (t->t_slotdata[slot] == NULL)
			return 0;
		pckbc_init_slotdata(t->t_slotdata[slot]);

		if (!found && slot == PCKBC_AUX_SLOT) {
			/*
			 * Some machines don't handle disabling the aux slot
			 * completely and still generate data when the mouse is
			 * moved, so setup a dummy interrupt handler to discard
			 * this slot's data.
			 */
			pckbc_set_inputhandler(t, PCKBC_AUX_SLOT, NULL, sc,
			    NULL);
			found = 1;
		}
	}
	return (found);
}

void
pckbc_attach(struct pckbc_softc *sc, int flags)
{
	struct pckbc_internal *t;
	bus_space_tag_t iot;
	bus_space_handle_t ioh_d, ioh_c;
	int haskbd = 0, res;
	u_char cmdbits = 0;

	t = sc->id;
	iot = t->t_iot;
	ioh_d = t->t_ioh_d;
	ioh_c = t->t_ioh_c;

	if (pckbc_console == 0) {
		timeout_set(&t->t_cleanup, pckbc_cleanup, t);
		timeout_set(&t->t_poll, pckbc_poll, t);
	}

	/* flush */
	(void) pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);

	/* set initial cmd byte */
	if (!pckbc_put8042cmd(t)) {
#if defined(__i386__) || defined(__amd64__)
		if (!ISSET(flags, PCKBCF_FORCE_KEYBOARD_PRESENT)) {
			pckbc_release_console();
			return;
		}
#endif
		printf("kbc: cmd word write error\n");
		return;
	}

/*
 * XXX Don't check the keyboard port. There are broken keyboard controllers
 * which don't pass the test but work normally otherwise.
 */
#if 0
	/*
	 * check kbd port ok
	 */
	if (!pckbc_send_cmd(iot, ioh_c, KBC_KBDTEST))
		return;
	res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);

	/*
	 * Normally, we should get a "0" here.
	 * But there are keyboard controllers behaving differently.
	 */
	if (res == 0 || res == 0xfa || res == 0x01 || res == 0xab) {
#ifdef PCKBCDEBUG
		if (res != 0)
			printf("kbc: returned %x on kbd slot test\n", res);
#endif
		if (pckbc_attach_slot(sc, PCKBC_KBD_SLOT, 0)) {
			cmdbits |= KC8_KENABLE;
			haskbd = 1;
		}
	} else {
		printf("kbc: kbd port test: %x\n", res);
		return;
	}
#else
	if (pckbc_attach_slot(sc, PCKBC_KBD_SLOT, 0)) {
		cmdbits |= KC8_KENABLE;
		haskbd = 1;
	}
#endif /* 0 */

	/*
	 * Check aux port ok.
	 * Avoid KBC_AUXTEST because it hangs some older controllers
	 * (eg UMC880?).
	 */
	if (!pckbc_send_cmd(iot, ioh_c, KBC_AUXECHO)) {
		printf("kbc: aux echo error 1\n");
		goto nomouse;
	}
	if (!pckbc_wait_output(iot, ioh_c)) {
		printf("kbc: aux echo error 2\n");
		goto nomouse;
	}
	bus_space_write_1(iot, ioh_d, 0, 0x5a);	/* a random value */
	res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_AUX_SLOT, 1);

	if (ISSET(t->t_flags, PCKBC_NEED_AUXWRITE)) {
		/*
		 * The following code is necessary to find the aux port on the
		 * oqo-1 machine, among others.  However if confuses old
		 * (non-ps/2) keyboard controllers (at least UMC880x again).
		 */
		if (res == -1) {
			/* Read of aux echo timed out, try again */
			if (!pckbc_send_cmd(iot, ioh_c, KBC_AUXWRITE))
				goto nomouse;
			if (!pckbc_wait_output(iot, ioh_c))
				goto nomouse;
			bus_space_write_1(iot, ioh_d, 0, 0x5a);
			res = pckbc_poll_data1(iot, ioh_d, ioh_c,
			    PCKBC_AUX_SLOT, 1);
			DPRINTF("kbc: aux echo: %x\n", res);
		}
	}

	if (res != -1) {
		/*
		 * In most cases, the 0x5a gets echoed.
		 * Some old controllers (Gateway 2000 circa 1993)
		 * return 0xfe here.
		 * We are satisfied if there is anything in the
		 * aux output buffer.
		 */
		DPRINTF("kbc: aux echo: %x\n", res);
		t->t_haveaux = 1;
		if (pckbc_attach_slot(sc, PCKBC_AUX_SLOT, 0))
			cmdbits |= KC8_MENABLE;
	}
#ifdef PCKBCDEBUG
	else
		printf("kbc: aux echo test failed\n");
#endif

#if defined(__i386__) || defined(__amd64__)
	if (haskbd == 0 && !ISSET(flags, PCKBCF_FORCE_KEYBOARD_PRESENT)) {
		if (t->t_haveaux) {
			if (pckbc_attach_slot(sc, PCKBC_KBD_SLOT, 1))
				cmdbits |= KC8_KENABLE;
		} else {
			pckbc_release_console();
		}
	}
#endif

nomouse:
	/* enable needed interrupts */
	t->t_cmdbyte |= cmdbits;
	if (!pckbc_put8042cmd(t))
		printf("kbc: cmd word write error\n");
}

int
pckbcprint(void *aux, const char *pnp)
{
	struct pckbc_attach_args *pa = aux;

	if (!pnp)
		printf(" (%s slot)", pckbc_slot_names[pa->pa_slot]);
	return (QUIET);
}

void
pckbc_release_console(void)
{
#if defined(__i386__) || defined(__amd64__)
	/*
	 * If there is no keyboard present, yet we are the console,
	 * we might be on a legacy-free PC where the PS/2 emulated
	 * keyboard was elected as console, but went away as soon
	 * as the USB controller drivers attached.
	 *
	 * In that case, we want to release ourselves from console
	 * duties, unless we have been able to attach a mouse,
	 * which would mean this is a real PS/2 controller
	 * afterwards.
	 */
	if (pckbc_console != 0) {
		extern void wscn_input_init(int);

		pckbc_console = 0;
		wscn_input_init(1);
	}
#endif
}

void
pckbc_init_slotdata(struct pckbc_slotdata *q)
{
	int i;
	TAILQ_INIT(&q->cmdqueue);
	TAILQ_INIT(&q->freequeue);

	for (i = 0; i < NCMD; i++) {
		TAILQ_INSERT_TAIL(&q->freequeue, &(q->cmds[i]), next);
	}
	q->polling = 0;
}

void
pckbc_flush(pckbc_tag_t self, pckbc_slot_t slot)
{
	struct pckbc_internal *t = self;

	(void) pckbc_poll_data1(t->t_iot, t->t_ioh_d, t->t_ioh_c,
	    slot, t->t_haveaux);
}

int
pckbc_poll_data(pckbc_tag_t self, pckbc_slot_t slot)
{
	struct pckbc_internal *t = self;
	struct pckbc_slotdata *q = t->t_slotdata[slot];
	int c;

	c = pckbc_poll_data1(t->t_iot, t->t_ioh_d, t->t_ioh_c,
			     slot, t->t_haveaux);
	if (c != -1 && q && CMD_IN_QUEUE(q)) {
		/* we jumped into a running command - try to
		 deliver the response */
		if (pckbc_cmdresponse(t, slot, c))
			return (-1);
	}
	return (c);
}

/*
 * set scancode translation on
 */
int
pckbc_xt_translation(pckbc_tag_t self)
{
	struct pckbc_internal *t = self;

	if (ISSET(t->t_flags, PCKBC_CANT_TRANSLATE))
		return (-1);

	if (t->t_cmdbyte & KC8_TRANS)
		return (0);

	t->t_cmdbyte |= KC8_TRANS;
	if (!pckbc_put8042cmd(t))
		return (-1);

	/* read back to be sure */
	if (!pckbc_get8042cmd(t))
		return (-1);

	return (t->t_cmdbyte & KC8_TRANS) ? (0) : (-1);
}

static struct pckbc_portcmd {
	u_char cmd_en, cmd_dis;
} pckbc_portcmd[2] = {
	{
		KBC_KBDENABLE, KBC_KBDDISABLE,
	}, {
		KBC_AUXENABLE, KBC_AUXDISABLE,
	}
};

void
pckbc_slot_enable(pckbc_tag_t self, pckbc_slot_t slot, int on)
{
	struct pckbc_internal *t = (struct pckbc_internal *)self;
	struct pckbc_portcmd *cmd;

	cmd = &pckbc_portcmd[slot];

	if (!pckbc_send_cmd(t->t_iot, t->t_ioh_c,
			    on ? cmd->cmd_en : cmd->cmd_dis))
		printf("pckbc_slot_enable(%d) failed\n", on);

	if (slot == PCKBC_KBD_SLOT) {
		if (on)
			timeout_add_sec(&t->t_poll, 1);
		else
			timeout_del(&t->t_poll);
	}
}

void
pckbc_set_poll(pckbc_tag_t self, pckbc_slot_t slot, int on)
{
	struct pckbc_internal *t = (struct pckbc_internal *)self;

	t->t_slotdata[slot]->polling = on;

	if (!on) {
                int s;

                /*
                 * If disabling polling on a device that's been configured,
                 * make sure there are no bytes left in the FIFO, holding up
                 * the interrupt line.  Otherwise we won't get any further
                 * interrupts.
                 */
		if (t->t_sc) {
			s = spltty();
			pckbcintr_internal(t, t->t_sc);
			splx(s);
		}
	}
}

/*
 * Pass command to device, poll for ACK and data.
 * to be called at spltty()
 */
static void
pckbc_poll_cmd1(struct pckbc_internal *t, pckbc_slot_t slot,
    struct pckbc_devcmd *cmd)
{
	bus_space_tag_t iot = t->t_iot;
	bus_space_handle_t ioh_d = t->t_ioh_d;
	bus_space_handle_t ioh_c = t->t_ioh_c;
	int i, c = 0;

	while (cmd->cmdidx < cmd->cmdlen) {
		if (!pckbc_send_devcmd(t, slot, cmd->cmd[cmd->cmdidx])) {
			printf("pckbc_cmd: send error\n");
			cmd->status = EIO;
			return;
		}
		for (i = 10; i; i--) { /* 1s ??? */
			c = pckbc_poll_data1(iot, ioh_d, ioh_c, slot,
					     t->t_haveaux);
			if (c != -1)
				break;
		}

		switch (c) {
		case KBC_DEVCMD_ACK:
			cmd->cmdidx++;
			continue;
		/*
		 * Some legacy free PCs keep returning Basic Assurance Test
		 * (BAT) instead of something usable, so fail gracefully.
		 */
		case KBC_DEVCMD_RESEND:
		case KBC_DEVCMD_BAT_DONE:
		case KBC_DEVCMD_BAT_FAIL:
			DPRINTF("pckbc_cmd: %s\n",
			    c == KBC_DEVCMD_RESEND ? "RESEND": "BAT");
			if (cmd->retries++ < 5)
				continue;

			DPRINTF("pckbc_cmd: cmd failed\n");
			cmd->status = ENXIO;
			return;
		case -1:
			DPRINTF("pckbc_cmd: timeout\n");
			cmd->status = EIO;
			return;
		default:
			DPRINTF("pckbc_cmd: lost 0x%x\n", c);
		}
	}

	while (cmd->responseidx < cmd->responselen) {
		if (cmd->flags & KBC_CMDFLAG_SLOW)
			i = 100; /* 10s ??? */
		else
			i = 10; /* 1s ??? */
		while (i--) {
			c = pckbc_poll_data1(iot, ioh_d, ioh_c, slot,
					     t->t_haveaux);
			if (c != -1)
				break;
		}
		if (c == -1) {
			DPRINTF("pckbc_cmd: no data\n");
			cmd->status = ETIMEDOUT;
			return;
		} else
			cmd->response[cmd->responseidx++] = c;
	}
}

/* for use in autoconfiguration */
int
pckbc_poll_cmd(pckbc_tag_t self, pckbc_slot_t slot, u_char *cmd, int len,
    int responselen, u_char *respbuf, int slow)
{
	struct pckbc_devcmd nc;

	if ((len > 4) || (responselen > 4))
		return (EINVAL);

	bzero(&nc, sizeof(nc));
	memcpy(nc.cmd, cmd, len);
	nc.cmdlen = len;
	nc.responselen = responselen;
	nc.flags = (slow ? KBC_CMDFLAG_SLOW : 0);

	pckbc_poll_cmd1(self, slot, &nc);

	if (nc.status == 0 && respbuf)
		memcpy(respbuf, nc.response, responselen);

	return (nc.status);
}

/*
 * Clean up a command queue, throw away everything.
 */
void
pckbc_cleanqueue(struct pckbc_slotdata *q)
{
	struct pckbc_devcmd *cmd;
#ifdef PCKBCDEBUG
	int i;
#endif

	while ((cmd = TAILQ_FIRST(&q->cmdqueue))) {
		TAILQ_REMOVE(&q->cmdqueue, cmd, next);
#ifdef PCKBCDEBUG
		printf("pckbc_cleanqueue: removing");
		for (i = 0; i < cmd->cmdlen; i++)
			printf(" %02x", cmd->cmd[i]);
		printf("\n");
#endif
		TAILQ_INSERT_TAIL(&q->freequeue, cmd, next);
	}
}

void
pckbc_cleanqueues(struct pckbc_internal *t)
{
	if (t->t_slotdata[PCKBC_KBD_SLOT])
		pckbc_cleanqueue(t->t_slotdata[PCKBC_KBD_SLOT]);
	if (t->t_slotdata[PCKBC_AUX_SLOT])
		pckbc_cleanqueue(t->t_slotdata[PCKBC_AUX_SLOT]);
}

/*
 * Timeout error handler: clean queues and data port.
 * XXX could be less invasive.
 */
void
pckbc_cleanup(void *self)
{
	struct pckbc_internal *t = self;
	int s;

	printf("pckbc: command timeout\n");

	s = spltty();

	pckbc_cleanqueues(t);

	while (bus_space_read_1(t->t_iot, t->t_ioh_c, 0) & KBS_DIB) {
		KBD_DELAY;
		(void) bus_space_read_1(t->t_iot, t->t_ioh_d, 0);
	}

	/* reset KBC? */

	splx(s);
}

/*
 * Stop the keyboard controller when we are going to suspend
 */
void
pckbc_stop(struct pckbc_softc *sc)
{
	struct pckbc_internal *t = sc->id;

	timeout_del(&t->t_poll);
	pckbc_cleanqueues(t);
	timeout_del(&t->t_cleanup);
}

/*
 * Reset the keyboard controller in a violent fashion; normally done
 * after suspend/resume when we do not trust the machine.
 */
void
pckbc_reset(struct pckbc_softc *sc)
{
	struct pckbc_internal *t = sc->id;
	bus_space_tag_t iot = t->t_iot;
	bus_space_handle_t ioh_d = t->t_ioh_d, ioh_c = t->t_ioh_c;

	pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);
	/* KBC selftest */
	if (pckbc_send_cmd(iot, ioh_c, KBC_SELFTEST) == 0)
		return;
	pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);
	(void)pckbc_put8042cmd(t);
	pckbcintr_internal(t->t_sc->id, t->t_sc);
}

/*
 * Pass command to device during normal operation.
 * to be called at spltty()
 */
void
pckbc_start(struct pckbc_internal *t, pckbc_slot_t slot)
{
	struct pckbc_slotdata *q = t->t_slotdata[slot];
	struct pckbc_devcmd *cmd = TAILQ_FIRST(&q->cmdqueue);

	if (q->polling) {
		do {
			pckbc_poll_cmd1(t, slot, cmd);
			if (cmd->status)
				printf("pckbc_start: command error\n");

			if (cmd->flags & KBC_CMDFLAG_SYNC) {
				wakeup(cmd);
				cmd = TAILQ_NEXT(cmd, next);
			} else {
				TAILQ_REMOVE(&q->cmdqueue, cmd, next);
				timeout_del(&t->t_cleanup);
				TAILQ_INSERT_TAIL(&q->freequeue, cmd, next);
				cmd = TAILQ_FIRST(&q->cmdqueue);
			}
		} while (cmd);
		return;
	}

	if (!pckbc_send_devcmd(t, slot, cmd->cmd[cmd->cmdidx])) {
		printf("pckbc_start: send error\n");
		/* XXX what now? */
		return;
	}
}

/*
 * Handle command responses coming in asynchronously,
 * return nonzero if valid response.
 * to be called at spltty()
 */
int
pckbc_cmdresponse(struct pckbc_internal *t, pckbc_slot_t slot, u_char data)
{
	struct pckbc_slotdata *q = t->t_slotdata[slot];
	struct pckbc_devcmd *cmd = TAILQ_FIRST(&q->cmdqueue);
#ifdef DIAGNOSTIC
	if (!cmd)
		panic("pckbc_cmdresponse: no active command");
#endif
	if (cmd->cmdidx < cmd->cmdlen) {
		if (data != KBC_DEVCMD_ACK && data != KBC_DEVCMD_RESEND)
			return (0);

		if (data == KBC_DEVCMD_RESEND) {
			if (cmd->retries++ < 5) {
				/* try again last command */
				goto restart;
			} else {
				DPRINTF("pckbc: cmd failed\n");
				cmd->status = ENXIO;
				/* dequeue */
			}
		} else {
			if (++cmd->cmdidx < cmd->cmdlen)
				goto restart;
			if (cmd->responselen)
				return (1);
			/* else dequeue */
		}
	} else if (cmd->responseidx < cmd->responselen) {
		cmd->response[cmd->responseidx++] = data;
		if (cmd->responseidx < cmd->responselen)
			return (1);
		/* else dequeue */
	} else
		return (0);

	/* dequeue: */
	if (cmd->flags & KBC_CMDFLAG_SYNC) {
		wakeup(cmd);
		cmd = TAILQ_NEXT(cmd, next);
	} else {
		TAILQ_REMOVE(&q->cmdqueue, cmd, next);
		timeout_del(&t->t_cleanup);
		TAILQ_INSERT_TAIL(&q->freequeue, cmd, next);
		cmd = TAILQ_FIRST(&q->cmdqueue);
	}
	if (cmd == NULL)
		return (1);
restart:
	pckbc_start(t, slot);
	return (1);
}

/*
 * Put command into the device's command queue, return zero or errno.
 */
int
pckbc_enqueue_cmd(pckbc_tag_t self, pckbc_slot_t slot, u_char *cmd, int len,
    int responselen, int sync, u_char *respbuf)
{
	struct pckbc_internal *t = self;
	struct pckbc_slotdata *q = t->t_slotdata[slot];
	struct pckbc_devcmd *nc;
	int s, isactive, res = 0;

	if ((len > 4) || (responselen > 4))
		return (EINVAL);
	s = spltty();
	nc = TAILQ_FIRST(&q->freequeue);
	if (nc) {
		TAILQ_REMOVE(&q->freequeue, nc, next);
	}
	splx(s);
	if (!nc)
		return (ENOMEM);

	bzero(nc, sizeof(*nc));
	memcpy(nc->cmd, cmd, len);
	nc->cmdlen = len;
	nc->responselen = responselen;
	nc->flags = (sync ? KBC_CMDFLAG_SYNC : 0);

	s = spltty();

	if (q->polling && sync) {
		/*
		 * XXX We should poll until the queue is empty.
		 * But we don't come here normally, so make
		 * it simple and throw away everything.
		 */
		pckbc_cleanqueue(q);
	}

	isactive = CMD_IN_QUEUE(q);
	TAILQ_INSERT_TAIL(&q->cmdqueue, nc, next);
	if (!isactive)
		pckbc_start(t, slot);

	if (q->polling)
		res = (sync ? nc->status : 0);
	else if (sync) {
		if ((res = tsleep(nc, 0, "kbccmd", 1*hz))) {
			TAILQ_REMOVE(&q->cmdqueue, nc, next);
			pckbc_cleanup(t);
		} else {
			TAILQ_REMOVE(&q->cmdqueue, nc, next);
			res = nc->status;
		}
	} else
		timeout_add_sec(&t->t_cleanup, 1);

	if (sync) {
		if (respbuf)
			memcpy(respbuf, nc->response, responselen);
		TAILQ_INSERT_TAIL(&q->freequeue, nc, next);
	}

	splx(s);

	return (res);
}

void
pckbc_set_inputhandler(pckbc_tag_t self, pckbc_slot_t slot, pckbc_inputfcn func,
    void *arg, char *name)
{
	struct pckbc_internal *t = (struct pckbc_internal *)self;
	struct pckbc_softc *sc = t->t_sc;

	if (slot >= PCKBC_NSLOTS)
		panic("pckbc_set_inputhandler: bad slot %d", slot);

	sc->inputhandler[slot] = func;
	sc->inputarg[slot] = arg;
	sc->subname[slot] = name;

	if (pckbc_console && slot == PCKBC_KBD_SLOT)
		timeout_add_sec(&t->t_poll, 1);
}

void
pckbc_poll(void *v)
{
	struct pckbc_internal *t = v;
	int s;

	s = spltty();
	(void)pckbcintr_internal(t, t->t_sc);
	timeout_add_sec(&t->t_poll, 1);
	splx(s);
}

int
pckbcintr(void *vsc)
{
	struct pckbc_softc *sc = (struct pckbc_softc *)vsc;

	return (pckbcintr_internal(sc->id, sc));
}

int
pckbcintr_internal(struct pckbc_internal *t, struct pckbc_softc *sc)
{
	u_char stat;
	pckbc_slot_t slot;
	struct pckbc_slotdata *q;
	int served = 0, data;

	/* reschedule timeout further into the idle times */
	if (timeout_pending(&t->t_poll))
		timeout_add_sec(&t->t_poll, 1);

	for(;;) {
		stat = bus_space_read_1(t->t_iot, t->t_ioh_c, 0);
		if (!(stat & KBS_DIB))
			break;

		served = 1;

		slot = (t->t_haveaux && (stat & KBS_AUXDATA)) ?
		    PCKBC_AUX_SLOT : PCKBC_KBD_SLOT;
		q = t->t_slotdata[slot];

		if (!q) {
			/* XXX do something for live insertion? */
#ifdef PCKBCDEBUG
			printf("pckbcintr: no dev for slot %d\n", slot);
#endif
			KBD_DELAY;
			(void) bus_space_read_1(t->t_iot, t->t_ioh_d, 0);
			continue;
		}

		if (q->polling)
			break; /* pckbc_poll_data() will get it */

		KBD_DELAY;
		data = bus_space_read_1(t->t_iot, t->t_ioh_d, 0);

		if (CMD_IN_QUEUE(q) && pckbc_cmdresponse(t, slot, data))
			continue;

		if (sc != NULL) {
			if (sc->inputhandler[slot])
				(*sc->inputhandler[slot])(sc->inputarg[slot],
				    data);
#ifdef PCKBCDEBUG
			else
				printf("pckbcintr: slot %d lost %d\n",
				    slot, data);
#endif
		}
	}

	return (served);
}

int
pckbc_cnattach(bus_space_tag_t iot, bus_addr_t addr, bus_size_t cmd_offset,
    int flags)
{
	bus_space_handle_t ioh_d, ioh_c;
	int res = 0;

	if (bus_space_map(iot, addr + KBDATAP, 1, 0, &ioh_d))
                return (ENXIO);
	if (bus_space_map(iot, addr + cmd_offset, 1, 0, &ioh_c)) {
		bus_space_unmap(iot, ioh_d, 1);
                return (ENXIO);
	}

	pckbc_consdata.t_iot = iot;
	pckbc_consdata.t_ioh_d = ioh_d;
	pckbc_consdata.t_ioh_c = ioh_c;
	pckbc_consdata.t_addr = addr;
	pckbc_consdata.t_flags = flags;
	timeout_set(&pckbc_consdata.t_cleanup, pckbc_cleanup, &pckbc_consdata);
	timeout_set(&pckbc_consdata.t_poll, pckbc_poll, &pckbc_consdata);

	/* flush */
	(void) pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);

	/* selftest? */

	/* init cmd byte, enable ports */
	pckbc_consdata.t_cmdbyte = KC8_CPU;
	if (!pckbc_put8042cmd(&pckbc_consdata)) {
		printf("kbc: cmd word write error\n");
		res = EIO;
	}

	if (!res) {
#if (NPCKBD > 0)
		res = pckbd_cnattach(&pckbc_consdata);
#else
		res = ENXIO;
#endif /* NPCKBD > 0 */
	}

	if (res) {
		bus_space_unmap(iot, pckbc_consdata.t_ioh_d, 1);
		bus_space_unmap(iot, pckbc_consdata.t_ioh_c, 1);
	} else {
		pckbc_consdata.t_slotdata[PCKBC_KBD_SLOT] = &pckbc_cons_slotdata;
		pckbc_init_slotdata(&pckbc_cons_slotdata);
		pckbc_console = 1;
	}

	return (res);
}

struct cfdriver pckbc_cd = {
	NULL, "pckbc", DV_DULL
};
@


1.49
log
@Follow the recent pckbc@@isa changes and always establish all the necessary
interrupts at pckbc attach time, and get rid of the `intr_establish'
pckbc callback.

Tested on hppa (gsckbc) and sgi (pckbc@@hpc); not tested on sparc64 (pckbc@@ebus)
but this attachment was already behaving this way and its intr_establish
callback was an empty function.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.48 2015/05/05 16:27:20 shadchin Exp $ */
a83 1
void pckbc_release_console(void);
d88 1
a88 1
static int pckbc_console;
@


1.48
log
@Less magic number

For PS/2 - status byte - bit 5:
The bit is '1' if the data on input port 60h came from the AUX port, or '0' if
the data came from the keyboard or from the keyboard controller itself.

KBS_TERR (kbd transmission error) was valid for AT-mode, but not for PS/2-mode.

ok ratchov@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.47 2015/03/31 02:27:30 jcs Exp $ */
a950 2

	(*sc->intr_establish)(sc, slot);
@


1.47
log
@Upon finding an AUX slot that has no driver for it (such as the
ramdisks that don't have the pms driver), setup a dummy interrupt
handler to receive and discard data from the slot.

This is a less invasive way of fixing the repeating keys/delay
problem that occurs on newer ThinkPads when touching the
trackpad/trackstick while typing during the installer.

This has been in snapshots for a bit.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.46 2015/03/16 01:49:11 jcs Exp $ */
d156 1
a156 1
			if (checkaux && (stat & 0x20)) { /* aux data */
d1001 1
a1001 1
		slot = (t->t_haveaux && (stat & 0x20)) ?
@


1.46
log
@Revert 1.44 since we have found some machines where the keyboard
stops working after our aux port resets, which were not broken
before.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.45 2015/03/14 03:38:47 jsg Exp $ */
a42 1
#include <dev/pckbc/pmsreg.h>
d273 1
a273 1
	if (found && !t->t_slotdata[slot]) {
d279 12
@


1.45
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.44 2015/03/12 20:24:16 deraadt Exp $ */
a279 6
	} else if (!found && slot == PCKBC_AUX_SLOT) {
		u_char cmd[1] = { PMS_RESET };

		(void) pckbc_poll_cmd(t, PCKBC_AUX_SLOT, cmd, sizeof cmd,
		    0, NULL, 1);
		pckbc_slot_enable(t, PCKBC_AUX_SLOT, 0);
@


1.44
log
@If while attaching pckbdc device slots, we find a slot has failed to
attach and it happens to be the AUX port, aha: we are a kernel without
the pms driver.  In that case, we should reset that pms back into
'stupid mode'.  It seems some BIOS initialize newer-style nubbins/touchpads
into strange (advanced) modes, which can muddle up the pckbc pipe.  This
is experienced as 10-second typing pauses and strange repeat behaviour on the
RAMDISK, but was eventually tied to "lightly brushing" the touchpad...
work done at s2k15 with jcs
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.43 2014/12/19 07:23:57 deraadt Exp $ */
a36 1
#include <sys/lock.h>
@


1.43
log
@another handful of bcopy -> memcpy because there is no overlap
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.42 2014/10/15 15:55:42 uebayasi Exp $ */
d44 1
d281 6
@


1.42
log
@Sprinkle CPU_BUSY_CYCLE() in a few places.

OK kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d663 1
a663 1
	bcopy(cmd, nc.cmd, len);
d671 1
a671 1
		bcopy(nc.response, respbuf, responselen);
d886 1
a886 1
	bcopy(cmd, nc->cmd, len);
d922 1
a922 1
			bcopy(nc->response, respbuf, responselen);
@


1.41
log
@Revert previous (wrong commit message).
@
text
@d40 1
d155 1
@


1.40
log
@pppx(4): Correct pppx_dev_lookup() and pppx_dev2pxd() local declarations

Those two functions take one dev_t argument, not int.  Match declarations
with reality.  No functional changes.
@
text
@a39 1
#include <machine/cpu.h>
a153 1
			CPU_BUSY_CYCLE();
@


1.39
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.38 2014/07/07 18:20:15 shadchin Exp $ */
d40 1
d155 1
@


1.38
log
@Don't print warnings for mouse interrupts on bsd.rd

request and ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.37 2013/09/24 08:33:50 mpi Exp $ */
a32 1
#include <sys/proc.h>
@


1.37
log
@Try to release the console if pckbc(4) fails to send the initial
command byte.  This allows at least my USB keyboard to be part of
the console on a Lenovo E20.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.36 2013/05/23 18:29:51 tobias Exp $ */
d995 1
d997 1
@


1.36
log
@Revert Active PS/2 support for now, until we find a solution suitable
for chipsets which stopped working.

ok mpi
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.33 2013/02/15 08:49:51 mpi Exp $ */
d85 1
d307 6
a407 12
		/*
		 * If there is no keyboard present, yet we are the console,
		 * we might be on a legacy-free PC where the PS/2 emulated
		 * keyboard was elected as console, but went away as soon
		 * as the USB controller drivers attached.
		 *
		 * In that case, we want to release ourselves from console
		 * duties, unless we have been able to attach a mouse,
		 * which would mean this is a real PS/2 controller
		 * afterwards.
		 */

d412 1
a412 6
			if (pckbc_console != 0) {
				extern void wscn_input_init(int);

				pckbc_console = 0;
				wscn_input_init(1);
			}
d432 24
@


1.35
log
@correct handling of t_apmver
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.34 2013/04/20 08:01:37 tobias Exp $ */
a107 2
int pckbc_enable_apm(struct pckbc_internal *);
int pckbc_disable_apm(struct pckbc_internal *);
d109 1
a109 11
const char *pckbc_slot_names[] = {
	"kbd slot",
#ifdef PCKBC_APM
	"aux slot #0",
	"aux slot #1",
	"aux slot #2",
	"aux slot #3",
#else
	"aux slot"
#endif
};
a139 4
/*
 * NOTE: Active PS/2 Multiplexing behaviour is only checked if t != NULL.
 * This behaviour is intentional.
 */
d142 1
a142 1
    bus_space_handle_t ioh_c, pckbc_slot_t slot, struct pckbc_internal *t)
a144 1
	int active;
a149 1
		/* XXX no error bit handling */
d155 8
a162 18

#ifdef PCKBC_APM
			if (t && t->t_apmver >= 0) {
				if (stat & 0x20)
					active = PCKBC_AUX_SLOT + (stat >> 6);
				else
					active = PCKBC_KBD_SLOT;
			} else
#endif
				active = stat & 0x20 ?
				    PCKBC_AUX_SLOT : PCKBC_KBD_SLOT;

#ifdef PCKBC_APM
			if (active != PCKBC_KBD_SLOT &&
			    t && t->t_apmver >= 0 && (stat & KBS_WARM)) {
				if (c >= 0xfd) {
					/* genuine error */
					/* XXX handle hot removal? */
a164 11
				DPRINTF("pckbc apm mode reverted?\n");
				/* XXX schedule a switch as soon as possible */
			}
#endif
			if (slot != active) {
				if ((t && t->t_haveaux) ||
				    slot != PCKBC_KBD_SLOT ||
				    active == PCKBC_KBD_SLOT)
					DPRINTF("lost data on slot%d 0x%x\n",
					    active, c);
				continue;
d185 2
a186 1
	data = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, t);
d218 1
a218 9
	if (slot >= PCKBC_AUX_SLOT) {
#ifdef PCKBC_APM
		/* send specific routing prefix if multiplexing */
		if (t->t_apmver >= 0) {
			if (pckbc_send_cmd(iot, ioh_c,
			    KBC_APM_PREFIX(slot - PCKBC_AUX_SLOT)) == 0)
				return (0);
		} else
#endif
d302 1
a302 1
	(void) pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, NULL);
d320 1
a320 1
	res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, NULL);
d360 1
a360 1
	res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_AUX_SLOT, NULL);
d376 1
a376 1
			    PCKBC_AUX_SLOT, NULL);
d391 1
a391 8

#ifdef PCKBC_APM
		t->t_apmver = -1;
		t->t_apmver = pckbc_enable_apm(t);
		if (t->t_apmver >= 0) {
			printf("%s: Active PS/2 Multiplexing, version %d.%d\n",
			    sc->sc_dv.dv_xname, t->t_apmver >> 4,
			    t->t_apmver & 0x0f);
a392 6
			for (res = PCKBC_AUX_SLOT; res < PCKBC_NSLOTS; res++)
				pckbc_attach_slot(sc, res, 0);
		} else
#endif
			if (pckbc_attach_slot(sc, PCKBC_AUX_SLOT, 0))
				cmdbits |= KC8_MENABLE;
d440 1
a440 1
		printf(" (%s)", pckbc_slot_names[pa->pa_slot]);
d462 2
a463 1
	(void) pckbc_poll_data1(t->t_iot, t->t_ioh_d, t->t_ioh_c, slot, t);
d473 2
a474 1
	c = pckbc_poll_data1(t->t_iot, t->t_ioh_d, t->t_ioh_c, slot, t);
d523 1
a523 2
	const struct pckbc_portcmd *cmd;
	int rc;
a524 3
#ifdef PCKBC_APM
	cmd = &pckbc_portcmd[slot >= PCKBC_AUX_SLOT ? PCKBC_AUX_SLOT : slot];
#else
a525 1
#endif
d527 3
a529 13
#ifdef PCKBC_APM
	/* send specific routing prefix if multiplexing */
	if (t->t_apmver >= 0 && slot >= PCKBC_AUX_SLOT) {
		rc = pckbc_send_cmd(t->t_iot, t->t_ioh_c,
		    KBC_APM_PREFIX(slot - PCKBC_AUX_SLOT));
	} else
#endif
		rc = 1;
	if (rc != 0)
	rc = pckbc_send_cmd(t->t_iot, t->t_ioh_c,
	    on ? cmd->cmd_en : cmd->cmd_dis);
	if (rc == 0)
		printf("pckbc_slot_enable(%d,%d) failed\n", slot, on);
d583 2
a584 1
			c = pckbc_poll_data1(iot, ioh_d, ioh_c, slot, t);
d623 2
a624 1
			c = pckbc_poll_data1(iot, ioh_d, ioh_c, slot, t);
d687 4
a690 5
	uint slot;

	for (slot = 0; slot < PCKBC_NSLOTS; slot++)
		if (t->t_slotdata[slot])
			pckbc_cleanqueue(t->t_slotdata[slot]);
d743 1
a743 1
	pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, NULL);
d747 1
a747 5
	pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, NULL);
#ifdef PCKBC_APM
	if (t->t_apmver >= 0)
		pckbc_enable_apm(t);
#endif
d975 2
a976 10
#ifdef PCKBC_APM
		if (t->t_apmver >= 0) { /* implies t->t_haveaux != 0 */
			if (stat & 0x20)
				slot = PCKBC_AUX_SLOT + (stat >> 6);
			else
				slot = PCKBC_KBD_SLOT;
		} else
#endif
			slot = (t->t_haveaux && (stat & 0x20)) ?
			    PCKBC_AUX_SLOT : PCKBC_KBD_SLOT;
a1010 83
#ifdef PCKBC_APM

/*
 * Disable Active PS/2 Multiplexing.
 * Returns nonzero if error.
 */
int
pckbc_disable_apm(struct pckbc_internal *t)
{
	bus_space_tag_t iot = t->t_iot;
	bus_space_handle_t ioh_d = t->t_ioh_d, ioh_c = t->t_ioh_c;
	int data;

	/*
	 * Send the three bytes of the disable sequence
	 */

	if (pckbc_send_cmd(iot, ioh_c, KBC_AUXECHO) == 0 ||
	    pckbc_wait_output(iot, ioh_c) == 0)
		return -1;
	bus_space_write_1(iot, ioh_d, 0, KBC_APM_DIS1);
	data = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_AUX_SLOT, NULL);
	if (data < 0 || data != KBC_APM_DIS1)
		return -1;

	if (pckbc_send_cmd(iot, ioh_c, KBC_AUXECHO) == 0 ||
	    pckbc_wait_output(iot, ioh_c) == 0)
		return -1;
	bus_space_write_1(iot, ioh_d, 0, KBC_APM_DIS2);
	data = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_AUX_SLOT, NULL);
	if (data < 0 || data != KBC_APM_DIS2)
		return -1;

	if (pckbc_send_cmd(iot, ioh_c, KBC_AUXECHO) == 0 ||
	    pckbc_wait_output(iot, ioh_c) == 0)
		return -1;
	bus_space_write_1(iot, ioh_d, 0, KBC_APM_DIS3);
	data = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_AUX_SLOT, NULL);
	if (data < 0 || data != t->t_apmver)
		return -1;

	return 0;
}

/*
 * Enable Active PS/2 Multiplexing.
 * Returns -1 if unavailable or version supported by the controller.
 */
int
pckbc_enable_apm(struct pckbc_internal *t)
{
	bus_space_tag_t iot = t->t_iot;
	bus_space_handle_t ioh_d = t->t_ioh_d, ioh_c = t->t_ioh_c;
	int data;

	if (pckbc_send_cmd(iot, ioh_c, KBC_AUXECHO) == 0 ||
	    pckbc_wait_output(iot, ioh_c) == 0)
		return -1;
	bus_space_write_1(iot, ioh_d, 0, KBC_APM_ENB1);
	data = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_AUX_SLOT, NULL);
	if (data < 0 || data != KBC_APM_ENB1)
		return -1;

	if (pckbc_send_cmd(iot, ioh_c, KBC_AUXECHO) == 0 ||
	    pckbc_wait_output(iot, ioh_c) == 0)
		return -1;
	bus_space_write_1(iot, ioh_d, 0, KBC_APM_ENB2);
	data = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_AUX_SLOT, NULL);
	if (data < 0 || data != KBC_APM_ENB2)
		return -1;

	if (pckbc_send_cmd(iot, ioh_c, KBC_AUXECHO) == 0 ||
	    pckbc_wait_output(iot, ioh_c) == 0)
		return -1;
	bus_space_write_1(iot, ioh_d, 0, KBC_APM_ENB3);
	data = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_AUX_SLOT, NULL);
	if (data < 0 || data == KBC_APM_ENB3)
		return -1;

	return data;
}
#endif

d1034 1
a1034 1
	(void) pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, NULL);
@


1.34
log
@Enable active PS/2 multiplexing if available.
Supported for i386 and amd64 except SMALL_KERNEL.

Based on Miod's former work on this subject.

ok mpi
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.33 2013/02/15 08:49:51 mpi Exp $ */
d819 1
d822 1
@


1.33
log
@More DPRINTF use, no object change.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.32 2013/02/15 08:37:09 mpi Exp $ */
d108 2
d111 11
a121 1
const char *pckbc_slot_names[] = { "kbd", "aux" };
d152 4
d158 1
a158 1
    bus_space_handle_t ioh_c, pckbc_slot_t slot, int checkaux)
d161 1
d167 1
d173 18
a190 8
			if (checkaux && (stat & 0x20)) { /* aux data */
				if (slot != PCKBC_AUX_SLOT) {
					DPRINTF("lost aux 0x%x\n", c);
					continue;
				}
			} else {
				if (slot == PCKBC_AUX_SLOT) {
					DPRINTF("lost kbd 0x%x\n", c);
d193 11
d224 1
a224 2
	data = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT,
				t->t_haveaux);
d256 9
a264 1
	if (slot == PCKBC_AUX_SLOT) {
d348 1
a348 1
	(void) pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);
d366 1
a366 1
	res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);
d406 1
a406 1
	res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_AUX_SLOT, 1);
d422 1
a422 1
			    PCKBC_AUX_SLOT, 1);
d437 8
a444 1
		if (pckbc_attach_slot(sc, PCKBC_AUX_SLOT, 0))
d446 6
d499 1
a499 1
		printf(" (%s slot)", pckbc_slot_names[pa->pa_slot]);
d521 1
a521 2
	(void) pckbc_poll_data1(t->t_iot, t->t_ioh_d, t->t_ioh_c,
	    slot, t->t_haveaux);
d531 1
a531 2
	c = pckbc_poll_data1(t->t_iot, t->t_ioh_d, t->t_ioh_c,
			     slot, t->t_haveaux);
d580 2
a581 1
	struct pckbc_portcmd *cmd;
d583 3
d587 1
d589 13
a601 3
	if (!pckbc_send_cmd(t->t_iot, t->t_ioh_c,
			    on ? cmd->cmd_en : cmd->cmd_dis))
		printf("pckbc_slot_enable(%d) failed\n", on);
d655 1
a655 2
			c = pckbc_poll_data1(iot, ioh_d, ioh_c, slot,
					     t->t_haveaux);
d694 1
a694 2
			c = pckbc_poll_data1(iot, ioh_d, ioh_c, slot,
					     t->t_haveaux);
d757 5
a761 4
	if (t->t_slotdata[PCKBC_KBD_SLOT])
		pckbc_cleanqueue(t->t_slotdata[PCKBC_KBD_SLOT]);
	if (t->t_slotdata[PCKBC_AUX_SLOT])
		pckbc_cleanqueue(t->t_slotdata[PCKBC_AUX_SLOT]);
d814 1
a814 1
	pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);
d818 3
a820 1
	pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);
d1048 10
a1057 2
		slot = (t->t_haveaux && (stat & 0x20)) ?
		    PCKBC_AUX_SLOT : PCKBC_KBD_SLOT;
d1092 83
d1198 1
a1198 1
	(void) pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);
@


1.32
log
@Do not loop forever if the keyboard send a BAT (Basic Assurance Test)
fault code, but handle this code like ``Resend'' or  ``BAT success''
instead.

Fix a problem reported by Kent Fritz and analyzed by stsp@@.

ok shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.31 2012/10/17 19:16:10 deraadt Exp $ */
d157 1
a157 3
#ifdef PCKBCDEBUG
					printf("lost aux 0x%x\n", c);
#endif
d162 1
a162 3
#ifdef PCKBCDEBUG
					printf("lost kbd 0x%x\n", c);
#endif
d377 1
a377 3
#ifdef PCKBCDEBUG
			printf("kbc: aux echo: %x\n", res);
#endif
d389 1
a389 3
#ifdef PCKBCDEBUG
		printf("kbc: aux echo: %x\n", res);
#endif
d629 1
a629 3
#ifdef PCKBCDEBUG
			printf("pckbc_cmd: no data\n");
#endif
d811 1
a811 3
#ifdef PCKBCDEBUG
				printf("pckbc: cmd failed\n");
#endif
@


1.31
log
@cleanup more of the driver soft-state when suspending; in certain
async operational modes a timeout and some requests on a queue
were still active
helps a machine mlarkin has
ok miod shadchin mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.30 2012/08/10 17:49:31 shadchin Exp $ */
d51 6
d111 4
a114 3
#define KBC_DEVCMD_ACK 0xfa
#define KBC_DEVCMD_RESEND 0xfe
#define KBC_DEVCMD_BAT 0xaa
d597 2
a598 1
		if (c == KBC_DEVCMD_ACK) {
a600 1
		}
d605 4
a608 3
		if (c == KBC_DEVCMD_RESEND || c == KBC_DEVCMD_BAT) {
#ifdef PCKBCDEBUG
			printf("pckbc_cmd: %s\n",
a609 1
#endif
d612 6
a617 12
			else {
#ifdef PCKBCDEBUG
				printf("pckbc: cmd failed\n");
#endif
				cmd->status = ENXIO;
				return;
			}
		}
		if (c == -1) {
#ifdef PCKBCDEBUG
			printf("pckbc_cmd: timeout\n");
#endif
d620 2
a622 3
#ifdef PCKBCDEBUG
		printf("pckbc_cmd: lost 0x%x\n", c);
#endif
@


1.30
log
@simplify pckbc_xt_translation()
* call only for set translation on (once in /sys/dev/pckbd.c)
  therefore we can delete unused code.
* change behavior (more standard) - return zero on success

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.29 2012/02/02 21:40:20 deraadt Exp $ */
d95 1
d694 9
d717 1
a717 4
	if (t->t_slotdata[PCKBC_KBD_SLOT])
		pckbc_cleanqueue(t->t_slotdata[PCKBC_KBD_SLOT]);
	if (t->t_slotdata[PCKBC_AUX_SLOT])
		pckbc_cleanqueue(t->t_slotdata[PCKBC_AUX_SLOT]);
d738 2
@


1.29
log
@disable the polling timeout when we suspend; discovered by some code
guenther is working on
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.28 2010/12/03 18:29:56 shadchin Exp $ */
d485 1
a485 2
 * switch scancode translation on / off
 * return nonzero on success
d488 1
a488 1
pckbc_xt_translation(pckbc_tag_t self, pckbc_slot_t slot, int on)
a490 1
	int ison;
d492 2
a493 8
	if (ISSET(t->t_flags, PCKBC_CANT_TRANSLATE) ||
	    slot != PCKBC_KBD_SLOT) {
		/* translation only for kbd slot */
		if (on)
			return (0);
		else
			return (1);
	}
d495 2
a496 3
	ison = t->t_cmdbyte & KC8_TRANS;
	if ((on && ison) || (!on && !ison))
		return (1);
d498 1
a498 1
	t->t_cmdbyte ^= KC8_TRANS;
d500 1
a500 1
		return (0);
d504 1
a504 1
		return (0);
d506 1
a506 4
	ison = t->t_cmdbyte & KC8_TRANS;
	if ((on && ison) || (!on && !ison))
		return (1);
	return (0);
@


1.28
log
@removed slot argument of function pckbd_cnattach
because it is always PCKBC_KBD_SLOT

ok miod@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.27 2010/11/23 04:07:55 shadchin Exp $ */
d732 11
@


1.27
log
@removed slot argument of function pckbc_cnattach
because it is always PCKBC_KBD_SLOT

ok krw@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.26 2010/08/28 12:48:14 miod Exp $ */
d1051 1
a1051 1
		res = pckbd_cnattach(&pckbc_consdata, PCKBC_KBD_SLOT);
@


1.26
log
@ansify function definitions, and constify a few arrays while there.
no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.25 2010/08/08 13:50:24 miod Exp $ */
d1017 1
a1017 1
    pckbc_slot_t slot, int flags)
d1051 1
a1051 1
		res = pckbd_cnattach(&pckbc_consdata, slot);
d1061 1
a1061 1
		pckbc_consdata.t_slotdata[slot] = &pckbc_cons_slotdata;
@


1.25
log
@Try and improve legacy controller emulation heuristics; if we think we should
not attach pckbd but pms attaches, then we are on real hardware, and should
attach pckbd anyway.
No known regression on legacy free systems; makes the few machines which
required device flags changes in UKC work out of the box again.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.24 2010/08/05 13:50:00 miod Exp $ */
d111 1
a111 3
pckbc_wait_output(iot, ioh_c)
	bus_space_tag_t iot;
	bus_space_handle_t ioh_c;
d124 1
a124 4
pckbc_send_cmd(iot, ioh_c, val)
	bus_space_tag_t iot;
	bus_space_handle_t ioh_c;
	u_char val;
d133 2
a134 5
pckbc_poll_data1(iot, ioh_d, ioh_c, slot, checkaux)
	bus_space_tag_t iot;
	bus_space_handle_t ioh_d, ioh_c;
	pckbc_slot_t slot;
	int checkaux;
d172 1
a172 2
pckbc_get8042cmd(t)
	struct pckbc_internal *t;
d193 1
a193 2
pckbc_put8042cmd(t)
	struct pckbc_internal *t;
d208 1
a208 4
pckbc_send_devcmd(t, slot, val)
	struct pckbc_internal *t;
	pckbc_slot_t slot;
	u_char val;
d225 1
a225 3
pckbc_is_console(iot, addr)
	bus_space_tag_t iot;
	bus_addr_t addr;
d235 1
a235 4
pckbc_submatch_locators(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d247 1
a247 4
pckbc_submatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d257 1
a257 4
pckbc_attach_slot(sc, slot, force)
	struct pckbc_softc *sc;
	pckbc_slot_t slot;
	int force;
d279 1
a279 3
pckbc_attach(sc, flags)
	struct pckbc_softc *sc;
	int flags;
d435 1
a435 3
pckbcprint(aux, pnp)
	void *aux;
	const char *pnp;
d445 1
a445 2
pckbc_init_slotdata(q)
	struct pckbc_slotdata *q;
d458 1
a458 3
pckbc_flush(self, slot)
	pckbc_tag_t self;
	pckbc_slot_t slot;
d467 1
a467 3
pckbc_poll_data(self, slot)
	pckbc_tag_t self;
	pckbc_slot_t slot;
d489 1
a489 4
pckbc_xt_translation(self, slot, on)
	pckbc_tag_t self;
	pckbc_slot_t slot;
	int on;
d532 1
a532 4
pckbc_slot_enable(self, slot, on)
	pckbc_tag_t self;
	pckbc_slot_t slot;
	int on;
d552 1
a552 4
pckbc_set_poll(self, slot, on)
	pckbc_tag_t self;
	pckbc_slot_t slot;
	int on;
d580 2
a581 4
pckbc_poll_cmd1(t, slot, cmd)
	struct pckbc_internal *t;
	pckbc_slot_t slot;
	struct pckbc_devcmd *cmd;
d660 2
a661 7
pckbc_poll_cmd(self, slot, cmd, len, responselen, respbuf, slow)
	pckbc_tag_t self;
	pckbc_slot_t slot;
	u_char *cmd;
	int len, responselen;
	u_char *respbuf;
	int slow;
d686 1
a686 2
pckbc_cleanqueue(q)
	struct pckbc_slotdata *q;
d710 1
a710 2
pckbc_cleanup(self)
	void *self;
d759 1
a759 3
pckbc_start(t, slot)
	struct pckbc_internal *t;
	pckbc_slot_t slot;
d796 1
a796 4
pckbc_cmdresponse(t, slot, data)
	struct pckbc_internal *t;
	pckbc_slot_t slot;
	u_char data;
d855 2
a856 6
pckbc_enqueue_cmd(self, slot, cmd, len, responselen, sync, respbuf)
	pckbc_tag_t self;
	pckbc_slot_t slot;
	u_char *cmd;
	int len, responselen, sync;
	u_char *respbuf;
d921 2
a922 6
pckbc_set_inputhandler(self, slot, func, arg, name)
	pckbc_tag_t self;
	pckbc_slot_t slot;
	pckbc_inputfcn func;
	void *arg;
	char *name;
d941 1
a941 2
pckbc_poll(v)
	void *v;
d953 1
a953 2
pckbcintr(vsc)
	void *vsc;
d961 1
a961 3
pckbcintr_internal(t, sc)
	struct pckbc_internal *t;
	struct pckbc_softc *sc;
d1016 2
a1017 6
pckbc_cnattach(iot, addr, cmd_offset, slot, flags)
	bus_space_tag_t iot;
	bus_addr_t addr;
	bus_size_t cmd_offset;
	pckbc_slot_t slot;
	int flags;
@


1.24
log
@Change the management of commands in the active commands TAILQ to let issuers
of synchronous commands perform the TAILQ_REMOVE of the command themselves,
instead of relying upon this being done for us if tsleep() returns zero.

Since we momentarily set `cold' again around suspend, tsleep() becomes a
no-op, which broke this assumption, and in turn caused TAILQ corruption,
with items being put on the freelist while still on the active list.

Found the hard way by ray@@ playing with wsmoused after resume.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.23 2010/07/22 14:27:44 deraadt Exp $ */
d75 2
a76 1
int pckbc_attach_slot(struct pckbc_softc *, pckbc_slot_t);
d250 1
a250 1
pckbc_submatch(parent, match, aux)
d261 13
d278 1
a278 1
pckbc_attach_slot(sc, slot)
d281 1
d289 2
a290 2
	found = (config_found_sm((struct device *)sc, &pa,
				 pckbcprint, pckbc_submatch) != NULL);
d353 1
a353 1
		if (pckbc_attach_slot(sc, PCKBC_KBD_SLOT)) {
d362 1
a362 1
	if (pckbc_attach_slot(sc, PCKBC_KBD_SLOT)) {
a366 19
#if defined(__i386__) || defined(__amd64__)
	if (haskbd == 0 && !ISSET(flags, PCKBCF_FORCE_KEYBOARD_PRESENT)) {
		/*
		 * If there is no keyboard present, yet we are the console,
		 * we might be on a legacy-free PC where the PS/2 emulated
		 * keyboard was elected as console, but went away as soon
		 * as the USB controller drivers attached.
		 *
		 * In that case, we want to release ourselves from console
		 * duties.
		 */
		if (pckbc_console != 0) {
			extern void wscn_input_init(int);

			pckbc_console = 0;
			wscn_input_init(1);
		}
	}
#endif
d417 1
a417 1
		if (pckbc_attach_slot(sc, PCKBC_AUX_SLOT))
d423 28
@


1.23
log
@Reset the keyboard controller on resume, and also alert the children
(pckbd and pms) to do their part
started by mlarkin, cleaned up by me
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.22 2010/07/21 20:10:17 miod Exp $ */
d72 1
a72 1
#define CMD_IN_QUEUE(q) (TAILQ_FIRST(&(q)->cmdqueue) != NULL)
d799 1
a799 2
			TAILQ_REMOVE(&q->cmdqueue, cmd, next);
			if (cmd->flags & KBC_CMDFLAG_SYNC)
d801 3
a803 1
			else {
d806 1
a807 1
			cmd = TAILQ_FIRST(&q->cmdqueue);
d867 1
a867 2
	TAILQ_REMOVE(&q->cmdqueue, cmd, next);
	if (cmd->flags & KBC_CMDFLAG_SYNC)
d869 3
a871 1
	else {
d874 1
d876 1
a876 1
	if (!CMD_IN_QUEUE(q))
d938 2
a939 1
		} else
d941 1
@


1.22
log
@Disable the heuristics for legacy free systems if pckbc flags are set to 1
in UKC; found the hard way by jakemsr@@ on an old Tecra laptop.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.21 2010/01/12 20:31:22 drahn Exp $ */
d759 20
@


1.21
log
@Fix for a legacy free PC, where the keyboard controller doesn't behave.
Clues on how to fix it from miod. ok miod@@, Sure deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.20 2009/08/27 16:45:20 jsg Exp $ */
d288 1
a288 1
pckbc_attach(sc)
d290 1
a351 1
	if (haskbd == 0) {
d353 1
d369 1
a370 1
	}
@


1.20
log
@Bring in NetBSD's rev 1.45 by Matthias Drochner

'Reduce polling of the keyboard controller status by a factor of 1000.
While on real hardware hardware a poll cycle takes time in the
microsecond order of magnitude, a "legacy-free" system which emulates
the KBC in BIOS code takes milliseconds -- I'm seeing a multi-minute
delay in booting where the KBC is probed. So poll less and use delay()
to compensate so that the total wait time stays about the same.'

Noticeably helps some machines that do SMM based pckbc.
Tested by miod on alpha glass console.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.19 2009/08/25 19:16:36 miod Exp $ */
d105 1
d624 5
a628 1
		if (c == KBC_DEVCMD_RESEND) {
d630 2
a631 1
			printf("pckbc_cmd: RESEND\n");
@


1.19
log
@Legacy-free PC hardware do not have a real PS/2 keyboard controller, but
rather have the USB HCI emulate it during boot, while legacy mode is enabled.

This causes pckbd0 to attach as the console device, but is lost as soon as
the USB HCI driver attaches.

The disappearance of the emulated PS/2 controller can however be detected
in pckbc(4) - which is supposed to attach after [eou]hci(4), with the controller
refusing to ack commands and replying ``please resend'' instead.

In that case, the kernel will now no longer attach pckbd, and will perform a
new console input device selection, allowing the (real) usb keyboard to
become the console.

Thanks to krw@@ for countless tests on legacy-free hardware; also tested on
more conventional hardware by naddy@@ and I.

Only amd64 and i386 platforms are affected by this change.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.18 2008/09/10 14:01:22 blambert Exp $ */
d145 2
a146 2
	/* if 1 port read takes 1us (?), this polls for 100ms */
	for (i = 100000; i; i--) {
@


1.18
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.17 2008/07/29 04:20:37 miod Exp $ */
d47 1
a47 1
#if (NPCKBD > 0)
d293 1
a293 1
	int res;
d336 1
a336 1
		if (pckbc_attach_slot(sc, PCKBC_KBD_SLOT))
d338 2
d345 1
a345 1
	if (pckbc_attach_slot(sc, PCKBC_KBD_SLOT))
d347 2
d350 19
d633 1
a633 1
				cmd->status = EIO;
d820 1
a820 1
				cmd->status = EIO;
@


1.17
log
@Reenable the AUXWRITE dance to try and find the aux port in pckbc(4), based
on an attachment dependent flag; the Tadople SPARCLE needs it.
ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.16 2008/07/16 20:03:22 miod Exp $ */
d535 1
a535 1
			timeout_add(&t->t_poll, hz);
d888 1
a888 1
		timeout_add(&t->t_cleanup, hz);
d922 1
a922 1
		timeout_add(&t->t_poll, hz);
d934 1
a934 1
	timeout_add(&t->t_poll, hz);
d959 1
a959 1
		timeout_add(&t->t_poll, hz);
@


1.16
log
@Add a new parameter to pckbc_cnattach(): flags to put in the pckbc bowels.
For now, only one such flag is defined, PCKBC_CANT_TRANSLATE. It hints
pckbc that the device does not behave correctly to the ``set translation''
commands.

Set this flag if we are running on a Tadpole Ultrabook machine, which needs it.
This makes the built-in keyboard work correctly on this laptop (with the
help of the software translation pckbd diff).

tested & ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.15 2007/11/26 22:45:27 miod Exp $ */
d362 16
a377 14
#if 0
	/*
	 * The following code is necessary to find the aux port on the
	 * oqo-1 machine.  However if confuses old (non-ps/2) keyboard
	 * controllers.
	 */
	if (res == -1) {
		/* Read of aux echo timed out, try again */
		if (!pckbc_send_cmd(iot, ioh_c, KBC_AUXWRITE))
			goto nomouse;
		if (!pckbc_wait_output(iot, ioh_c))
			goto nomouse;
		bus_space_write_1(iot, ioh_d, 0, 0x5a);
		res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_AUX_SLOT, 1);
d379 1
a379 1
		printf("kbc: aux echo: %x\n", res);
d381 1
d383 1
a383 1
#endif
@


1.15
log
@Undo (well, comment out) 1.10 - this causes a regression on oqo-1 machines,
but fixes keyboard on legacy (non-ps/2) controllers, which are probably still
more common; discussed and ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.14 2007/01/31 14:38:54 mickey Exp $ */
d478 2
a479 1
	if (slot != PCKBC_KBD_SLOT) {
d1002 1
a1002 1
pckbc_cnattach(iot, addr, cmd_offset, slot)
d1007 1
d1023 1
@


1.14
log
@oops. now is the miodski version of the diff (;
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.13 2007/01/31 14:35:51 mickey Exp $ */
d362 6
d380 1
@


1.13
log
@run a timeout (calling intr handler) to recover from in buffer oflows that make no ints; w/ help from miod@@ and ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.12 2006/05/08 19:52:13 deraadt Exp $ */
d99 1
d551 1
a551 1
			pckbcintr(t->t_sc);
d922 1
a922 1
	(void) pckbcintr(v);
d932 9
a940 1
	struct pckbc_internal *t = sc->id;
d946 1
a946 1
	/* reschedule timeout futher into the idle times */
d978 8
a985 5
		if (sc->inputhandler[slot])
			(*sc->inputhandler[slot])(sc->inputarg[slot], data);
#ifdef PCKBCDEBUG
		else
			printf("pckbcintr: slot %d lost %d\n", slot, data);
d987 1
@


1.12
log
@silence a debug message; from kili@@outback.escape.de; ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.11 2005/12/29 12:31:29 martin Exp $ */
d96 1
d300 1
a300 1
	if (pckbc_console == 0)
d302 2
d434 1
a434 1
				slot, t->t_haveaux);
d520 7
d908 16
d937 4
d1002 1
@


1.11
log
@go via pckbc_enqeue_cmd() in pckbd_enable() if on; fixes PR 4615

ok miod@@, mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.10 2005/08/06 19:49:19 jcs Exp $ */
d772 1
d774 1
@


1.10
log
@while checking for an aux port, if we timeout waiting for our test
data to echo back, send KBC_AUXWRITE and send the test again

required to find the aux port on the oqo model 01

ok mickey@@ and miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.9 2004/11/02 21:21:00 miod Exp $ */
a635 1
	struct pckbc_internal *t = self;
d647 1
a647 1
	pckbc_poll_cmd1(t, slot, &nc);
@


1.9
log
@Remove __HAVE_NWSCONS and related remnants of pre-wscons days; no functional
change.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.8 2004/04/02 04:39:50 deraadt Exp $ */
d358 12
@


1.8
log
@remove terms 3 & 4 for drochner@@NetBSD.org; as seen on netbsd lists
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.7 2003/10/21 18:58:49 jmc Exp $ */
a44 1
#ifdef __HAVE_NWSCONS /* XXX: this port uses sys/dev/pckbc */
a45 3
#else /* ie: only md drivers attach to pckbc */
#define NPCKBD 0
#endif
a975 8
		/*
		 * XXX This should be replaced with the `notyet' case
		 * XXX when all of the old PC-style console drivers
		 * XXX have gone away.  When that happens, all of
		 * XXX the pckbc_machdep_cnattach() should be purged,
		 * XXX as well.
		 */
#ifdef notyet
a976 3
#else
		res = pckbc_machdep_cnattach(&pckbc_consdata, slot);
#endif
@


1.7
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.6 2003/03/13 01:06:58 drahn Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project
 *	by Matthias Drochner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.6
log
@Initialize the timeout for the non-console case of PS2 keyboard. Fixes
a panic on alpha with serial console. ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.5 2002/06/09 00:58:03 nordin Exp $ */
d746 1
a746 1
 * Handle command responses coming in asynchonously,
@


1.5
log
@Handle out of memory gracefully. ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.4 2002/04/30 20:56:15 miod Exp $ */
d308 3
@


1.4
log
@Correctly handle old controllers with a relaxed aux port behaviour.
This allows the mouse port to become available on AlphaStation machines,
as well as on some older x86 machines.

From NetBSD.

Tested by various people on alpha and i386, no regression discovered.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.3 2002/03/14 01:26:55 millert Exp $ */
d287 2
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.2 2001/04/14 03:27:47 aaron Exp $ */
d363 11
a373 1
	if (res == 0x5a) {
d379 2
a380 2
	  else
		printf("kbc: aux echo: %x\n", res);
@


1.2
log
@Instead of using KBC_AUXTEST, probe the aux port with KBC_AUXECHO, which is
what Linux does; from NetBSD. This apparently fixes problems with old
chipsets that handle the test command differently, leading to a non-working
keyboard. This patch was tested by many people successfully.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.1 2000/11/13 20:12:34 aaron Exp $ */
d84 4
a87 4
void pckbc_init_slotdata __P((struct pckbc_slotdata *));
int pckbc_attach_slot __P((struct pckbc_softc *, pckbc_slot_t));
int pckbc_submatch __P((struct device *, void *, void *));
int pckbcprint __P((void *, const char *));
d95 1
a95 1
static int pckbc_wait_output __P((bus_space_tag_t, bus_space_handle_t));
d97 11
a107 11
static int pckbc_get8042cmd __P((struct pckbc_internal *));
static int pckbc_put8042cmd __P((struct pckbc_internal *));
static int pckbc_send_devcmd __P((struct pckbc_internal *, pckbc_slot_t,
				  u_char));
static void pckbc_poll_cmd1 __P((struct pckbc_internal *, pckbc_slot_t,
				 struct pckbc_devcmd *));

void pckbc_cleanqueue __P((struct pckbc_slotdata *));
void pckbc_cleanup __P((void *));
int pckbc_cmdresponse __P((struct pckbc_internal *, pckbc_slot_t, u_char));
void pckbc_start __P((struct pckbc_internal *, pckbc_slot_t));
@


1.2.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.2 2001/04/14 03:27:47 aaron Exp $ */
d84 4
a87 4
void pckbc_init_slotdata(struct pckbc_slotdata *);
int pckbc_attach_slot(struct pckbc_softc *, pckbc_slot_t);
int pckbc_submatch(struct device *, void *, void *);
int pckbcprint(void *, const char *);
d95 1
a95 1
static int pckbc_wait_output(bus_space_tag_t, bus_space_handle_t);
d97 11
a107 11
static int pckbc_get8042cmd(struct pckbc_internal *);
static int pckbc_put8042cmd(struct pckbc_internal *);
static int pckbc_send_devcmd(struct pckbc_internal *, pckbc_slot_t,
				  u_char);
static void pckbc_poll_cmd1(struct pckbc_internal *, pckbc_slot_t,
				 struct pckbc_devcmd *);

void pckbc_cleanqueue(struct pckbc_slotdata *);
void pckbc_cleanup(void *);
int pckbc_cmdresponse(struct pckbc_internal *, pckbc_slot_t, u_char);
void pckbc_start(struct pckbc_internal *, pckbc_slot_t);
a286 2
		if (t->t_slotdata[slot] == NULL)
			return 0;
d363 1
a363 11
	if (res != -1) {
		/*
		 * In most cases, the 0x5a gets echoed.
		 * Some old controllers (Gateway 2000 circa 1993)
		 * return 0xfe here.
		 * We are satisfied if there is anything in the
		 * aux output buffer.
		 */
#ifdef PCKBCDEBUG
		printf("kbc: aux echo: %x\n", res);
#endif
d369 2
a370 2
	else
		printf("kbc: aux echo test failed\n");
@


1.2.8.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a307 3

	if (pckbc_console == 0)
		timeout_set(&t->t_cleanup, pckbc_cleanup, t);
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: pckbc.c,v 1.2 2001/04/14 03:27:47 aaron Exp $ */
@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d84 4
a87 4
void pckbc_init_slotdata(struct pckbc_slotdata *);
int pckbc_attach_slot(struct pckbc_softc *, pckbc_slot_t);
int pckbc_submatch(struct device *, void *, void *);
int pckbcprint(void *, const char *);
d95 1
a95 1
static int pckbc_wait_output(bus_space_tag_t, bus_space_handle_t);
d97 11
a107 11
static int pckbc_get8042cmd(struct pckbc_internal *);
static int pckbc_put8042cmd(struct pckbc_internal *);
static int pckbc_send_devcmd(struct pckbc_internal *, pckbc_slot_t,
				  u_char);
static void pckbc_poll_cmd1(struct pckbc_internal *, pckbc_slot_t,
				 struct pckbc_devcmd *);

void pckbc_cleanqueue(struct pckbc_slotdata *);
void pckbc_cleanup(void *);
int pckbc_cmdresponse(struct pckbc_internal *, pckbc_slot_t, u_char);
void pckbc_start(struct pckbc_internal *, pckbc_slot_t);
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@a286 2
		if (t->t_slotdata[slot] == NULL)
			return 0;
a306 3
	if (pckbc_console == 0)
		timeout_set(&t->t_cleanup, pckbc_cleanup, t);

d363 1
a363 11
	if (res != -1) {
		/*
		 * In most cases, the 0x5a gets echoed.
		 * Some old controllers (Gateway 2000 circa 1993)
		 * return 0xfe here.
		 * We are satisfied if there is anything in the
		 * aux output buffer.
		 */
#ifdef PCKBCDEBUG
		printf("kbc: aux echo: %x\n", res);
#endif
d369 2
a370 2
	else
		printf("kbc: aux echo test failed\n");
@


1.2.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d746 1
a746 1
 * Handle command responses coming in asynchronously,
@


1.2.4.5
log
@Merge with the trunk
@
text
@d16 6
@


1.1
log
@Machine-independent PC-like keyboard driver; from NetBSD. XXX - Not used
anywhere quite yet, but useful to have these files in the tree while we work
towards wscons for i386 and alpha.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d349 3
a351 1
	 * check aux port ok
d353 11
a363 9
	if (!pckbc_send_cmd(iot, ioh_c, KBC_AUXTEST))
		return;
	res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);

	if (res == 0 || res == 0xfa || res == 0x01) {
#ifdef PCKBCDEBUG
		if (res != 0)
			printf("kbc: returned %x on aux slot test\n", res);
#endif
d370 1
a370 1
		printf("kbc: aux port test: %x\n", res);
d373 1
d400 1
a400 1
	for (i=0; i<NCMD; i++) {
@

