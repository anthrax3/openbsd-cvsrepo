head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.6
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.8
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.6
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.10
	OPENBSD_5_0:1.21.0.6
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.10
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.12
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.8
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.6
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11;
locks; strict;
comment	@ * @;


1.26
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.25;
commitid	FuSD2mFDJWATHIDx;

1.25
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.24;
commitid	yM2VFFhpDTeFQlve;

1.24
date	2014.09.25.04.19.45;	author jsg;	state Exp;
branches;
next	1.23;
commitid	YyN37YkZHI2iLMjR;

1.23
date	2013.06.11.18.15.53;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.10.27.16.13.28;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.18.19.24.21;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.28.09.26.26;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.17.21.45.49;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.13.11.03.54;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.08.09.17.34;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.26.19.46.28;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.26.17.20.33;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2006.09.27.04.34.36;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.19.23.17.12;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.15.15.43.34;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.14.06.53.26;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.07.10.46.12;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.06.13.03.03;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.05.14.33.39;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.05.13.06.50;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.03.12.00.07;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.03.10.47.42;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.03.10.12.37;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.03.08.45.01;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.26
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@/*	$OpenBSD: acx100.c,v 1.25 2014/12/22 02:28:51 tedu Exp $ */

/*
 * Copyright (c) 2006 Jonathan Gray <jsg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Copyright (c) 2006 The DragonFly Project.  All rights reserved.
 *
 * This code is derived from software contributed to The DragonFly Project
 * by Sepherosa Ziehau <sepherosa@@gmail.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of The DragonFly Project nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific, prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/endian.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/pci/pcireg.h>

#include <dev/ic/acxvar.h>
#include <dev/ic/acxreg.h>

#define ACX100_CONF_FW_RING	0x0003
#define ACX100_CONF_MEMOPT	0x0005

#define ACX100_INTR_ENABLE	(ACXRV_INTR_TX_FINI | ACXRV_INTR_RX_FINI)
/*
 * XXX do we really care about following interrupts?
 *
 * ACXRV_INTR_INFO | ACXRV_INTR_SCAN_FINI
 */

#define ACX100_INTR_DISABLE	(uint16_t)~(ACXRV_INTR_UNKN)

#define ACX100_RATE(rate)	((rate) * 5)

#define ACX100_TXPOWER		18
#define ACX100_GPIO_POWER_LED	0x0800
#define ACX100_EE_EADDR_OFS	0x1a

#define ACX100_FW_TXRING_SIZE	(ACX_TX_DESC_CNT * sizeof(struct acx_fw_txdesc))
#define ACX100_FW_RXRING_SIZE	(ACX_RX_DESC_CNT * sizeof(struct acx_fw_rxdesc))

int	acx100_init(struct acx_softc *);
int	acx100_init_wep(struct acx_softc *);
int	acx100_init_tmplt(struct acx_softc *);
int	acx100_init_fw_ring(struct acx_softc *);
int	acx100_init_memory(struct acx_softc *);
void	acx100_init_fw_txring(struct acx_softc *, uint32_t);
void	acx100_init_fw_rxring(struct acx_softc *, uint32_t);
int	acx100_read_config(struct acx_softc *, struct acx_config *);
int	acx100_write_config(struct acx_softc *, struct acx_config *);
int	acx100_set_txpower(struct acx_softc *);
void	acx100_set_fw_txdesc_rate(struct acx_softc *,
	    struct acx_txbuf *, int);
void	acx100_set_bss_join_param(struct acx_softc *, void *, int);
int	acx100_set_wepkey(struct acx_softc *, struct ieee80211_key *, int);
void	acx100_proc_wep_rxbuf(struct acx_softc *, struct mbuf *, int *);

/*
 * NOTE:
 * Following structs' fields are little endian
 */
struct acx100_bss_join {
	uint8_t	dtim_intvl;
	uint8_t	basic_rates;
	uint8_t	all_rates;
} __packed;

struct acx100_conf_fw_ring {
	struct acx_conf	confcom;
	uint32_t	fw_ring_size;	/* total size of fw (tx + rx) ring */
	uint32_t	fw_rxring_addr;	/* start phyaddr of fw rx desc */
	uint8_t		opt;		/* see ACX100_RINGOPT_ */
	uint8_t		fw_txring_num;	/* num of TX ring */
	uint8_t		fw_rxdesc_num;	/* num of fw rx desc */
	uint8_t		reserved0;
	uint32_t	fw_ring_end[2];	/* see ACX100_SET_RING_END() */
	uint32_t	fw_txring_addr;	/* start phyaddr of fw tx desc */
	uint8_t		fw_txring_prio;	/* see ACX100_TXRING_PRIO_ */
	uint8_t		fw_txdesc_num;	/* num of fw tx desc */
	uint16_t	reserved1;
} __packed;

#define ACX100_RINGOPT_AUTO_RESET	0x1
#define ACX100_TXRING_PRIO_DEFAULT	0
#define ACX100_SET_RING_END(conf, end)			\
do {							\
	(conf)->fw_ring_end[0] = htole32(end);		\
	(conf)->fw_ring_end[1] = htole32(end + 8);	\
} while (0)

struct acx100_conf_memblk_size {
	struct acx_conf	confcom;
	uint16_t	memblk_size;	/* size of each mem block */
} __packed;

struct acx100_conf_mem {
	struct acx_conf	confcom;
	uint32_t	opt;		/* see ACX100_MEMOPT_ */
	uint32_t	h_rxring_paddr;	/* host rx desc start phyaddr */

	/*
	 * Memory blocks are controled by hardware
	 * once after they are initialized
	 */
	uint32_t	rx_memblk_addr;	/* start addr of rx mem blocks */
	uint32_t	tx_memblk_addr;	/* start addr of tx mem blocks */
	uint16_t	rx_memblk_num;	/* num of RX mem block */
	uint16_t	tx_memblk_num;	/* num of TX mem block */
} __packed;

#define ACX100_MEMOPT_MEM_INSTR		0x00000000 /* memory access instruct */
#define ACX100_MEMOPT_HOSTDESC		0x00010000 /* host indirect desc */
#define ACX100_MEMOPT_MEMBLOCK		0x00020000 /* local mem block list */
#define ACX100_MEMOPT_IO_INSTR		0x00040000 /* IO instruct */
#define ACX100_MEMOPT_PCICONF		0x00080000 /* PCI conf space */

#define ACX100_MEMBLK_ALIGN		0x20

struct acx100_conf_cca_mode {
	struct acx_conf	confcom;
	uint8_t		cca_mode;
	uint8_t		unknown;
} __packed;

struct acx100_conf_ed_thresh {
	struct acx_conf	confcom;
	uint8_t		ed_thresh;
	uint8_t		unknown[3];
} __packed;

struct acx100_conf_wepkey {
	struct acx_conf	confcom;
	uint8_t		action;	/* see ACX100_WEPKEY_ACT_ */
	uint8_t		key_len;
	uint8_t		key_idx;
#define ACX100_WEPKEY_LEN	29
	uint8_t		key[ACX100_WEPKEY_LEN];
} __packed;

#define ACX100_WEPKEY_ACT_ADD	1

static const uint16_t	acx100_reg[ACXREG_MAX] = {
	ACXREG(SOFT_RESET,		0x0000),

	ACXREG(FWMEM_ADDR,		0x0014),
	ACXREG(FWMEM_DATA,		0x0018),
	ACXREG(FWMEM_CTRL,		0x001c),
	ACXREG(FWMEM_START,		0x0020),

	ACXREG(EVENT_MASK,		0x0034),

	ACXREG(INTR_TRIG,		0x007c),
	ACXREG(INTR_MASK,		0x0098),
	ACXREG(INTR_STATUS,		0x00a4),
	ACXREG(INTR_STATUS_CLR,		0x00a8),
	ACXREG(INTR_ACK,		0x00ac),

	ACXREG(HINTR_TRIG,		0x00b0),
	ACXREG(RADIO_ENABLE,		0x0104),

	ACXREG(EEPROM_INIT,		0x02d0),
	ACXREG(EEPROM_CTRL,		0x0250),
	ACXREG(EEPROM_ADDR,		0x0254),
	ACXREG(EEPROM_DATA,		0x0258),
	ACXREG(EEPROM_CONF,		0x025c),
	ACXREG(EEPROM_INFO,		0x02ac),

	ACXREG(PHY_ADDR,		0x0268),
	ACXREG(PHY_DATA,		0x026c),
	ACXREG(PHY_CTRL,		0x0270),

	ACXREG(GPIO_OUT_ENABLE,		0x0290),
	ACXREG(GPIO_OUT,		0x0298),

	ACXREG(CMD_REG_OFFSET,		0x02a4),
	ACXREG(INFO_REG_OFFSET,		0x02a8),

	ACXREG(RESET_SENSE,		0x02d4),
	ACXREG(ECPU_CTRL,		0x02d8)
};

static const uint8_t	acx100_txpower_maxim[21] = {
	63, 63, 63, 62,
	61, 61, 60, 60,
	59, 58, 57, 55,
	53, 50, 47, 43,
	38, 31, 23, 13,
	0
};

static const uint8_t	acx100_txpower_rfmd[21] = {
	 0,  0,  0,  1,
	 2,  2,  3,  3,
	 4,  5,  6,  8,
	10, 13, 16, 20,
	25, 32, 41, 50,
	63
};

void
acx100_set_param(struct acx_softc *sc)
{
	sc->chip_mem1_rid = PCIR_BAR(1);
	sc->chip_mem2_rid = PCIR_BAR(2);
	sc->chip_ioreg = acx100_reg;
	sc->chip_hw_crypt = 1;
	sc->chip_intr_enable = ACX100_INTR_ENABLE;
#ifndef IEEE80211_STA_ONLY
	sc->chip_intr_enable |= ACXRV_INTR_DTIM;
#endif
	sc->chip_intr_disable = ACX100_INTR_DISABLE;
	sc->chip_gpio_pled = ACX100_GPIO_POWER_LED;
	sc->chip_ee_eaddr_ofs = ACX100_EE_EADDR_OFS;
	sc->chip_txdesc1_len = ACX_FRAME_HDRLEN;
	sc->chip_fw_txdesc_ctrl = DESC_CTRL_AUTODMA |
	    DESC_CTRL_RECLAIM | DESC_CTRL_FIRST_FRAG;

	sc->chip_phymode = IEEE80211_MODE_11B;
	sc->chip_chan_flags = IEEE80211_CHAN_B;
	sc->sc_ic.ic_phytype = IEEE80211_T_DS;
	sc->sc_ic.ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;

	sc->chip_init = acx100_init;
	sc->chip_set_wepkey = acx100_set_wepkey;
	sc->chip_read_config = acx100_read_config;
	sc->chip_write_config = acx100_write_config;
	sc->chip_set_fw_txdesc_rate = acx100_set_fw_txdesc_rate;
	sc->chip_set_bss_join_param = acx100_set_bss_join_param;
	sc->chip_proc_wep_rxbuf = acx100_proc_wep_rxbuf;
}

int
acx100_init(struct acx_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	/*
	 * NOTE:
	 * Order of initialization:
	 * 1) WEP
	 * 2) Templates
	 * 3) Firmware TX/RX ring
	 * 4) Hardware memory
	 * Above order is critical to get a correct memory map
	 */
	if (acx100_init_wep(sc) != 0) {
		printf("%s: %s can't initialize wep\n",
		    ifp->if_xname, __func__);
		return (ENXIO);
	}

	if (acx100_init_tmplt(sc) != 0) {
		printf("%s: %s can't initialize templates\n",
		    ifp->if_xname, __func__);
		return (ENXIO);
	}

	if (acx100_init_fw_ring(sc) != 0) {
		printf("%s: %s can't initialize fw ring\n",
		    ifp->if_xname, __func__);
		return (ENXIO);
	}

	if (acx100_init_memory(sc) != 0) {
		printf("%s: %s can't initialize hw memory\n",
		    ifp->if_xname, __func__);
		return (ENXIO);
	}

	return (0);
}

int
acx100_init_wep(struct acx_softc *sc)
{
	struct acx_conf_wepopt wep_opt;
	struct acx_conf_mmap mem_map;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	/* Set WEP cache start/end address */
	if (acx_get_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0) {
		printf("%s: can't get mmap\n", ifp->if_xname);
		return (1);
	}

	mem_map.wep_cache_start = htole32(letoh32(mem_map.code_end) + 4);
	mem_map.wep_cache_end = htole32(letoh32(mem_map.code_end) + 4);
	if (acx_set_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0) {
		printf("%s: can't set mmap\n", ifp->if_xname);
		return (1);
	}

	/* Set WEP options */
	wep_opt.nkey = htole16(IEEE80211_WEP_NKID + 10);
	wep_opt.opt = WEPOPT_HDWEP;
	if (acx_set_conf(sc, ACX_CONF_WEPOPT, &wep_opt, sizeof(wep_opt)) != 0) {
		printf("%s: can't set wep opt\n", ifp->if_xname);
		return (1);
	}

	return (0);
}

int
acx100_init_tmplt(struct acx_softc *sc)
{
	struct acx_conf_mmap mem_map;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	/* Set templates start address */
	if (acx_get_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0) {
		printf("%s: can't get mmap\n", ifp->if_xname);
		return (1);
	}

	mem_map.pkt_tmplt_start = mem_map.wep_cache_end;
	if (acx_set_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0) {
		printf("%s: can't set mmap\n", ifp->if_xname);
		return (1);
	}

	/* Initialize various packet templates */
	if (acx_init_tmplt_ordered(sc) != 0) {
		printf("%s: can't init tmplt\n", ifp->if_xname);
		return (1);
	}

	return (0);
}

int
acx100_init_fw_ring(struct acx_softc *sc)
{
	struct acx100_conf_fw_ring ring;
	struct acx_conf_mmap mem_map;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t txring_start, rxring_start, ring_end;

	/* Set firmware descriptor ring start address */
	if (acx_get_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0) {
		printf("%s: can't get mmap\n", ifp->if_xname);
		return (1);
	}

	txring_start = letoh32(mem_map.pkt_tmplt_end) + 4;
	rxring_start = txring_start + ACX100_FW_TXRING_SIZE;
	ring_end = rxring_start + ACX100_FW_RXRING_SIZE;

	mem_map.fw_desc_start = htole32(txring_start);
	if (acx_set_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0) {
		printf("%s: can't set mmap\n", ifp->if_xname);
		return (1);
	}

	/* Set firmware descriptor ring configure */
	bzero(&ring, sizeof(ring));
	ring.fw_ring_size = htole32(ACX100_FW_TXRING_SIZE +
	    ACX100_FW_RXRING_SIZE + 8);

	ring.fw_txring_num = 1;
	ring.fw_txring_addr = htole32(txring_start);
	ring.fw_txring_prio = ACX100_TXRING_PRIO_DEFAULT;
	ring.fw_txdesc_num = 0; /* XXX ignored?? */

	ring.fw_rxring_addr = htole32(rxring_start);
	ring.fw_rxdesc_num = 0; /* XXX ignored?? */

	ring.opt = ACX100_RINGOPT_AUTO_RESET;
	ACX100_SET_RING_END(&ring, ring_end);
	if (acx_set_conf(sc, ACX100_CONF_FW_RING, &ring, sizeof(ring)) != 0) {
		printf("%s: can't set fw ring configure\n", ifp->if_xname);
		return (1);
	}

	/* Setup firmware TX/RX descriptor ring */
	acx100_init_fw_txring(sc, txring_start);
	acx100_init_fw_rxring(sc, rxring_start);

	return (0);
}

#define MEMBLK_ALIGN(addr)	\
    (((addr) + (ACX100_MEMBLK_ALIGN - 1)) & ~(ACX100_MEMBLK_ALIGN - 1))

int
acx100_init_memory(struct acx_softc *sc)
{
	struct acx100_conf_memblk_size memblk_sz;
	struct acx100_conf_mem mem;
	struct acx_conf_mmap mem_map;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t memblk_start, memblk_end;
	int total_memblk, txblk_num, rxblk_num;

	/* Set memory block start address */
	if (acx_get_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0) {
		printf("%s: can't get mmap\n", ifp->if_xname);
		return (1);
	}

	mem_map.memblk_start =
	    htole32(MEMBLK_ALIGN(letoh32(mem_map.fw_desc_end) + 4));

	if (acx_set_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0) {
		printf("%s: can't set mmap\n", ifp->if_xname);
		return (1);
	}

	/* Set memory block size */
	memblk_sz.memblk_size = htole16(ACX_MEMBLOCK_SIZE);
	if (acx_set_conf(sc, ACX_CONF_MEMBLK_SIZE, &memblk_sz,
	    sizeof(memblk_sz)) != 0) {
		printf("%s: can't set mem block size\n", ifp->if_xname);
		return (1);
	}

	/* Get memory map after setting it */
	if (acx_get_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0) {
		printf("%s: can't get mmap again\n", ifp->if_xname);
		return (1);
	}
	memblk_start = letoh32(mem_map.memblk_start);
	memblk_end = letoh32(mem_map.memblk_end);

	/* Set memory options */
	mem.opt = htole32(ACX100_MEMOPT_MEMBLOCK | ACX100_MEMOPT_HOSTDESC);
	mem.h_rxring_paddr = htole32(sc->sc_ring_data.rx_ring_paddr);

	total_memblk = (memblk_end - memblk_start) / ACX_MEMBLOCK_SIZE;

	rxblk_num = total_memblk / 2;		/* 50% */
	txblk_num = total_memblk - rxblk_num;	/* 50% */

	DPRINTF(("%s: \ttotal memory blocks\t%d\n"
	    "\trx memory blocks\t%d\n"
	    "\ttx memory blocks\t%d\n",
	    ifp->if_xname, total_memblk, rxblk_num, txblk_num));

	mem.rx_memblk_num = htole16(rxblk_num);
	mem.tx_memblk_num = htole16(txblk_num);

	mem.rx_memblk_addr = htole32(MEMBLK_ALIGN(memblk_start));
	mem.tx_memblk_addr = htole32(MEMBLK_ALIGN(memblk_start +
	    (ACX_MEMBLOCK_SIZE * rxblk_num)));

	if (acx_set_conf(sc, ACX100_CONF_MEMOPT, &mem, sizeof(mem)) != 0) {
		printf("%s: can't set mem options\n", ifp->if_xname);
		return (1);
	}

	/* Initialize memory */
	if (acx_exec_command(sc, ACXCMD_INIT_MEM, NULL, 0, NULL, 0) != 0) {
		printf("%s: can't init mem\n", ifp->if_xname);
		return (1);
	}

	return (0);
}

#undef MEMBLK_ALIGN

void
acx100_init_fw_txring(struct acx_softc *sc, uint32_t fw_txdesc_start)
{
	struct acx_fw_txdesc fw_desc;
	struct acx_txbuf *tx_buf;
	uint32_t desc_paddr, fw_desc_offset;
	int i;

	bzero(&fw_desc, sizeof(fw_desc));
	fw_desc.f_tx_ctrl = DESC_CTRL_HOSTOWN | DESC_CTRL_RECLAIM |
	    DESC_CTRL_AUTODMA | DESC_CTRL_FIRST_FRAG;

	tx_buf = sc->sc_buf_data.tx_buf;
	fw_desc_offset = fw_txdesc_start;
	desc_paddr = sc->sc_ring_data.tx_ring_paddr;

	for (i = 0; i < ACX_TX_DESC_CNT; ++i) {
		fw_desc.f_tx_host_desc = htole32(desc_paddr);

		if (i == ACX_TX_DESC_CNT - 1) {
			fw_desc.f_tx_next_desc = htole32(fw_txdesc_start);
		} else {
			fw_desc.f_tx_next_desc = htole32(fw_desc_offset +
			    sizeof(struct acx_fw_txdesc));
		}

		tx_buf[i].tb_fwdesc_ofs = fw_desc_offset;
		DESC_WRITE_REGION_1(sc, fw_desc_offset, &fw_desc,
		    sizeof(fw_desc));

		desc_paddr += (2 * sizeof(struct acx_host_desc));
		fw_desc_offset += sizeof(fw_desc);
	}
}

void
acx100_init_fw_rxring(struct acx_softc *sc, uint32_t fw_rxdesc_start)
{
	struct acx_fw_rxdesc fw_desc;
	uint32_t fw_desc_offset;
	int i;

	bzero(&fw_desc, sizeof(fw_desc));
	fw_desc.f_rx_ctrl = DESC_CTRL_RECLAIM | DESC_CTRL_AUTODMA;

	fw_desc_offset = fw_rxdesc_start;

	for (i = 0; i < ACX_RX_DESC_CNT; ++i) {
		if (i == ACX_RX_DESC_CNT - 1) {
			fw_desc.f_rx_next_desc = htole32(fw_rxdesc_start);
		} else {
			fw_desc.f_rx_next_desc =
			    htole32(fw_desc_offset +
			    sizeof(struct acx_fw_rxdesc));
		}

		DESC_WRITE_REGION_1(sc, fw_desc_offset, &fw_desc,
		    sizeof(fw_desc));

		fw_desc_offset += sizeof(fw_desc);
	}
}

int
acx100_read_config(struct acx_softc *sc, struct acx_config *conf)
{
	struct acx100_conf_cca_mode cca;
	struct acx100_conf_ed_thresh ed;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	/*
	 * NOTE:
	 * CCA mode and ED threshold MUST be read during initialization
	 * or the acx100 card won't work as expected
	 */

	/* Get CCA mode */
	if (acx_get_conf(sc, ACX_CONF_CCA_MODE, &cca, sizeof(cca)) != 0) {
		printf("%s: %s can't get cca mode\n",
		    ifp->if_xname, __func__);
		return (ENXIO);
	}
	conf->cca_mode = cca.cca_mode;
	DPRINTF(("%s: cca mode %02x\n", ifp->if_xname, cca.cca_mode));

	/* Get ED threshold */
	if (acx_get_conf(sc, ACX_CONF_ED_THRESH, &ed, sizeof(ed)) != 0) {
		printf("%s: %s can't get ed threshold\n",
		    ifp->if_xname, __func__);
		return (ENXIO);
	}
	conf->ed_thresh = ed.ed_thresh;
	DPRINTF(("%s: ed threshold %02x\n", ifp->if_xname, ed.ed_thresh));

	return (0);
}

int
acx100_write_config(struct acx_softc *sc, struct acx_config *conf)
{
	struct acx100_conf_cca_mode cca;
	struct acx100_conf_ed_thresh ed;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	/* Set CCA mode */
	cca.cca_mode = conf->cca_mode;
	if (acx_set_conf(sc, ACX_CONF_CCA_MODE, &cca, sizeof(cca)) != 0) {
		printf("%s: %s can't set cca mode\n",
		    ifp->if_xname, __func__);
		return (ENXIO);
	}

	/* Set ED threshold */
	ed.ed_thresh = conf->ed_thresh;
	if (acx_set_conf(sc, ACX_CONF_ED_THRESH, &ed, sizeof(ed)) != 0) {
		printf("%s: %s can't set ed threshold\n",
		    ifp->if_xname, __func__);
		return (ENXIO);
	}

	/* Set TX power */
	acx100_set_txpower(sc);	/* ignore return value */

	return (0);
}

int
acx100_set_txpower(struct acx_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	const uint8_t *map;

	switch (sc->sc_radio_type) {
	case ACX_RADIO_TYPE_MAXIM:
		map = acx100_txpower_maxim;
		break;
	case ACX_RADIO_TYPE_RFMD:
	case ACX_RADIO_TYPE_RALINK:
		map = acx100_txpower_rfmd;
		break;
	default:
		printf("%s: TX power for radio type 0x%02x can't be set yet\n",
		    ifp->if_xname, sc->sc_radio_type);
		return (1);
	}

	acx_write_phyreg(sc, ACXRV_PHYREG_TXPOWER, map[ACX100_TXPOWER]);

	return (0);
}

void
acx100_set_fw_txdesc_rate(struct acx_softc *sc, struct acx_txbuf *tx_buf,
    int rate)
{
	FW_TXDESC_SETFIELD_1(sc, tx_buf, f_tx_rate100, ACX100_RATE(rate));
}

void
acx100_set_bss_join_param(struct acx_softc *sc, void *param, int dtim_intvl)
{
	struct acx100_bss_join *bj = param;

	bj->dtim_intvl = dtim_intvl;
	bj->basic_rates = 15;	/* XXX */
	bj->all_rates = 31;	/* XXX */
}

int
acx100_set_wepkey(struct acx_softc *sc, struct ieee80211_key *k, int k_idx)
{
	struct acx100_conf_wepkey conf_wk;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (k->k_len > ACX100_WEPKEY_LEN) {
		printf("%s: %dth WEP key size beyond %d\n",
		    ifp->if_xname, k_idx, ACX100_WEPKEY_LEN);
		return EINVAL;
	}

	conf_wk.action = ACX100_WEPKEY_ACT_ADD;
	conf_wk.key_len = k->k_len;
	conf_wk.key_idx = k_idx;
	bcopy(k->k_key, conf_wk.key, k->k_len);
	if (acx_set_conf(sc, ACX_CONF_WEPKEY, &conf_wk, sizeof(conf_wk)) != 0) {
		printf("%s: %s set %dth WEP key failed\n",
		    ifp->if_xname, __func__, k_idx);
		return ENXIO;
	}
	return 0;
}

void
acx100_proc_wep_rxbuf(struct acx_softc *sc, struct mbuf *m, int *len)
{
	int mac_hdrlen;
	struct ieee80211_frame *f;

	/*
	 * Strip leading IV and KID, and trailing CRC
	 */
	f = mtod(m, struct ieee80211_frame *);

	if ((f->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
		mac_hdrlen = sizeof(struct ieee80211_frame_addr4);
	else
		mac_hdrlen = sizeof(struct ieee80211_frame);

#define IEEEWEP_IVLEN	(IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN)
#define IEEEWEP_EXLEN	(IEEEWEP_IVLEN + IEEE80211_WEP_CRCLEN)

	*len = *len - IEEEWEP_EXLEN;

	/* Move MAC header toward frame body */
	memmove((uint8_t *)f + IEEEWEP_IVLEN, f, mac_hdrlen);
	m_adj(m, IEEEWEP_IVLEN);

#undef IEEEWEP_EXLEN
#undef IEEEWEP_IVLEN
}
@


1.25
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.24 2014/09/25 04:19:45 jsg Exp $ */
a64 1
#include <net/if_arp.h>
@


1.24
log
@include bpfilter.h so the softc will be the same size in all files
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.23 2013/06/11 18:15:53 deraadt Exp $ */
a67 1
#ifdef INET
a69 1
#endif
@


1.23
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.22 2012/10/27 16:13:28 claudio Exp $ */
d52 2
@


1.22
log
@Implememnt AP side power saving for acx(4). Tested on acx11.
With some input and OK from kettenis@@ and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.21 2010/04/20 22:05:41 tedu Exp $ */
d735 1
a735 1
	ovbcopy(f, (uint8_t *)f + IEEEWEP_IVLEN, mac_hdrlen);
@


1.21
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.20 2007/07/18 19:24:21 damien Exp $ */
d267 3
@


1.20
log
@unbreak build.

pointed out by mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.19 2007/07/18 18:10:31 damien Exp $ */
a57 1
#include <sys/sysctl.h>
@


1.19
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.18 2007/02/28 09:26:26 claudio Exp $ */
d695 1
a695 1
		    ifp->if_xname, wk_idx, ACX100_WEPKEY_LEN);
@


1.18
log
@Another round of makro killing. Kill _ACX_CONF_FUNC() and replace all
calls with acx_set_conf()/acx_get_conf(). OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.17 2006/12/17 21:45:49 claudio Exp $ */
d115 1
a115 2
int	acx100_set_wepkey(struct acx_softc *, struct ieee80211_wepkey *,
	    int);
d688 1
a688 1
acx100_set_wepkey(struct acx_softc *sc, struct ieee80211_wepkey *wk, int wk_idx)
d693 1
a693 1
	if (wk->wk_len > ACX100_WEPKEY_LEN) {
d700 3
a702 3
	conf_wk.key_len = wk->wk_len;
	conf_wk.key_idx = wk_idx;
	bcopy(wk->wk_key, conf_wk.key, wk->wk_len);
d705 1
a705 1
		    ifp->if_xname, __func__, wk_idx);
@


1.17
log
@Kill some more macros. This time ACX_NOARG_FUNC and ACX_INIT_TMPLT_FUNC
bite the dust and make the code easier to read. Help and OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.16 2006/12/13 11:03:54 mglocker Exp $ */
a202 16
#define ACX100_CONF_FUNC(sg, name)	_ACX_CONF_FUNC(sg, name, 100)
#define ACX_CONF_fw_ring		ACX100_CONF_FW_RING
#define ACX_CONF_memblk_size		ACX_CONF_MEMBLK_SIZE
#define ACX_CONF_mem			ACX100_CONF_MEMOPT
#define ACX_CONF_cca_mode		ACX_CONF_CCA_MODE
#define ACX_CONF_ed_thresh		ACX_CONF_ED_THRESH
#define ACX_CONF_wepkey			ACX_CONF_WEPKEY
ACX100_CONF_FUNC(set, fw_ring);
ACX100_CONF_FUNC(set, memblk_size);
ACX100_CONF_FUNC(set, mem);
ACX100_CONF_FUNC(get, cca_mode);
ACX100_CONF_FUNC(set, cca_mode);
ACX100_CONF_FUNC(get, ed_thresh);
ACX100_CONF_FUNC(set, ed_thresh);
ACX100_CONF_FUNC(set, wepkey);

d274 1
a274 2
	    DESC_CTRL_RECLAIM |
	    DESC_CTRL_FIRST_FRAG;
d339 1
a339 1
	if (acx_get_mmap_conf(sc, &mem_map) != 0) {
d346 1
a346 1
	if (acx_set_mmap_conf(sc, &mem_map) != 0) {
d354 1
a354 1
	if (acx_set_wepopt_conf(sc, &wep_opt) != 0) {
d369 1
a369 1
	if (acx_get_mmap_conf(sc, &mem_map) != 0) {
d375 1
a375 1
	if (acx_set_mmap_conf(sc, &mem_map) != 0) {
d398 1
a398 1
	if (acx_get_mmap_conf(sc, &mem_map) != 0) {
d408 1
a408 1
	if (acx_set_mmap_conf(sc, &mem_map) != 0) {
d428 1
a428 1
	if (acx100_set_fw_ring_conf(sc, &ring) != 0) {
d454 1
a454 1
	if (acx_get_mmap_conf(sc, &mem_map) != 0) {
d462 1
a462 1
	if (acx_set_mmap_conf(sc, &mem_map) != 0) {
d469 2
a470 1
	if (acx100_set_memblk_size_conf(sc, &memblk_sz) != 0) {
d476 1
a476 1
	if (acx_get_mmap_conf(sc, &mem_map) != 0) {
d504 1
a504 1
	if (acx100_set_mem_conf(sc, &mem) != 0) {
d529 2
a530 4
	fw_desc.f_tx_ctrl = DESC_CTRL_HOSTOWN |
	    DESC_CTRL_RECLAIM |
	    DESC_CTRL_AUTODMA |
	    DESC_CTRL_FIRST_FRAG;
d597 1
a597 1
	if (acx100_get_cca_mode_conf(sc, &cca) != 0) {
d606 1
a606 1
	if (acx100_get_ed_thresh_conf(sc, &ed) != 0) {
d626 1
a626 1
	if (acx100_set_cca_mode_conf(sc, &cca) != 0) {
d634 1
a634 1
	if (acx100_set_ed_thresh_conf(sc, &ed) != 0) {
d704 1
a704 1
	if (acx100_set_wepkey_conf(sc, &conf_wk) != 0) {
@


1.16
log
@First part of fixing broken beacon frames in acx(4) AP mode based on a
diff from Sepherosa Ziehau (DragonFly);  The firmware TIM element template
was initialized wrong.

Though, our ieee80211_alloc_beacon() routine calculates it's own TIM
element, which now results in having two TIMs in an acx(4) beacon.

Would it be an idea to introduce a ieee80211_alloc_beacon() flag to
turn the TIM element off?  Because fiddling out the TIM element in the
driver for cases in which the firmware calculates its own TIM is
a bit ugly ...

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.15 2006/12/08 09:17:34 claudio Exp $ */
a218 3
#define ACXCMD_init_mem			ACXCMD_INIT_MEM
ACX_NOARG_FUNC(init_mem);

d526 1
a526 1
	if (acx_init_mem(sc) != 0) {
@


1.15
log
@First round of evil macro removal. _acx_set_##name##_tmplt bites the dust.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.14 2006/11/26 19:46:28 deraadt Exp $ */
a385 1
	struct acx_tmplt_tim tim;
a402 10
		return (1);
	}

	/* Setup TIM template */
	bzero(&tim, sizeof(tim));
	tim.tim_eid = IEEE80211_ELEMID_TIM;
	tim.tim_len = ACX_TIM_LEN(ACX_TIM_BITMAP_LEN);
	if (acx_set_tmplt(sc, ACXCMD_TMPLT_TIM, &tim,
	    ACX_TMPLT_TIM_SIZ(ACX_TIM_BITMAP_LEN)) != 0) {
		printf("%s: can't set tim tmplt\n", ifp->if_xname);
@


1.14
log
@avoid extra inclusions; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.13 2006/11/26 17:20:33 jsg Exp $ */
d411 1
a411 1
	if (_acx_set_tim_tmplt(sc, &tim,
@


1.13
log
@Make use of ieee80211_std_rateset
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.12 2006/09/27 04:34:36 brad Exp $ */
a71 1
#include <net80211/ieee80211.h>
@


1.12
log
@add missing sys/device.h header.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.11 2006/08/19 23:17:12 mglocker Exp $ */
d300 1
a300 1
	sc->sc_ic.ic_sup_rates[IEEE80211_MODE_11B] = acx_rates_11b;
@


1.11
log
@Replace existing rate adaption code with the ieee80211_amrr framework.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.10 2006/08/15 15:43:34 deraadt Exp $ */
d59 1
@


1.10
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.9 2006/08/14 06:53:26 jsg Exp $ */
d73 1
@


1.9
log
@Turn off debug messages by default.
Reminded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.8 2006/08/07 10:46:12 mglocker Exp $ */
d21 1
a21 1
 * 
d24 1
a24 1
 * 
d28 1
a28 1
 * 
d38 1
a38 1
 * 
d258 1
a258 1
	ACXREG(ECPU_CTRL,		0x02d8) 
@


1.8
log
@Enable WEP.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.7 2006/08/06 13:03:03 mglocker Exp $ */
a75 2

#define ACX_DEBUG
@


1.7
log
@Add bpf hooks.  Based on slightly modified diff from jsg.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.6 2006/08/05 14:33:39 mglocker Exp $ */
d116 1
a116 2
#if 0
int	acx100_set_wepkey(struct acx_softc *, struct ieee80211_key *,
a117 1
#endif
a302 1
#if 0
a303 1
#endif
a720 1
#if 0
d722 1
a722 1
acx100_set_wepkey(struct acx_softc *sc, struct ieee80211_key *wk, int wk_idx)
d727 1
a727 1
	if (wk->wk_keylen > ACX100_WEPKEY_LEN) {
d734 1
a734 1
	conf_wk.key_len = wk->wk_keylen;
d736 1
a736 1
	bcopy(wk->wk_key, conf_wk.key, wk->wk_keylen);
a743 1
#endif
@


1.6
log
@Some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.5 2006/08/05 13:06:50 mglocker Exp $ */
d73 1
@


1.5
log
@Adjust copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.4 2006/08/03 12:00:07 mglocker Exp $ */
d102 19
a124 1

a281 24
int	acx100_init(struct acx_softc *);
int	acx100_init_wep(struct acx_softc *);
int	acx100_init_tmplt(struct acx_softc *);
int	acx100_init_fw_ring(struct acx_softc *);
int	acx100_init_memory(struct acx_softc *);

void	acx100_init_fw_txring(struct acx_softc *, uint32_t);
void	acx100_init_fw_rxring(struct acx_softc *, uint32_t);
int	acx100_read_config(struct acx_softc *, struct acx_config *);
int	acx100_write_config(struct acx_softc *, struct acx_config *);

int	acx100_set_txpower(struct acx_softc *);

void	acx100_set_fw_txdesc_rate(struct acx_softc *,
					  struct acx_txbuf *, int);
void	acx100_set_bss_join_param(struct acx_softc *, void *, int);

#if 0
int	acx100_set_wepkey(struct acx_softc *, struct ieee80211_key *,
				  int);
#endif

void	acx100_proc_wep_rxbuf(struct acx_softc *, struct mbuf *, int *);

d295 2
a296 2
				  DESC_CTRL_RECLAIM |
				  DESC_CTRL_FIRST_FRAG;
a327 1

d331 1
a331 1
		return ENXIO;
d337 1
a337 1
		return ENXIO;
d343 1
a343 1
		return ENXIO;
d349 1
a349 1
		return ENXIO;
d351 2
a352 1
	return 0;
d365 1
a365 1
		return 1;
d372 1
a372 1
		return 1;
d380 1
a380 1
		return 1;
d382 2
a383 1
	return 0;
d396 1
a396 1
		return 1;
d402 1
a402 1
		return 1;
d408 1
a408 1
		return 1;
d416 1
a416 1
			       ACX_TMPLT_TIM_SIZ(ACX_TIM_BITMAP_LEN)) != 0) {
d418 1
a418 1
		return 1;
d420 2
a421 1
	return 0;
d435 1
a435 1
		return 1;
d445 1
a445 1
		return 1;
d451 1
a451 1
				    ACX100_FW_RXRING_SIZE + 8);
d465 1
a465 1
		return 1;
d472 1
a472 1
	return 0;
d476 1
a476 1
	(((addr) + (ACX100_MEMBLK_ALIGN - 1)) &	~(ACX100_MEMBLK_ALIGN - 1))
d491 1
a491 1
		return 1;
d495 1
a495 1
		htole32(MEMBLK_ALIGN(letoh32(mem_map.fw_desc_end) + 4));
d499 1
a499 1
		return 1;
d506 1
a506 1
		return 1;
d512 1
a512 1
		return 1;
d535 2
a536 3
	mem.tx_memblk_addr =
		htole32(MEMBLK_ALIGN(memblk_start +
				     (ACX_MEMBLOCK_SIZE * rxblk_num)));
d540 1
a540 1
		return 1;
d546 1
a546 1
		return 1;
d548 2
a549 1
	return 0;
d564 3
a566 3
			    DESC_CTRL_RECLAIM |
			    DESC_CTRL_AUTODMA |
			    DESC_CTRL_FIRST_FRAG;
d578 2
a579 3
			fw_desc.f_tx_next_desc =
				htole32(fw_desc_offset +
					sizeof(struct acx_fw_txdesc));
d584 1
a584 1
				    sizeof(fw_desc));
d608 2
a609 2
				htole32(fw_desc_offset +
					sizeof(struct acx_fw_rxdesc));
d613 1
a613 1
				    sizeof(fw_desc));
d636 1
a636 1
		return ENXIO;
d645 1
a645 1
		return ENXIO;
d650 1
a650 1
	return 0;
d665 1
a665 1
		return ENXIO;
d673 1
a673 1
		return ENXIO;
d679 1
a679 1
	return 0;
d697 3
a699 3
		printf("%s: TX power for radio type 0x%02x "
		    "can't be set yet\n", ifp->if_xname, sc->sc_radio_type);
		return 1;
d703 2
a704 1
	return 0;
d709 1
a709 1
			  int rate)
a758 1

@


1.4
log
@Fix more cvs Id tag tweaks in copyright notes.

Spotted by <gwyllion@@ulyssis.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.3 2006/08/03 10:47:42 mglocker Exp $ */
a4 1
 * Copyright (c) 2006 Marcus Glocker <mglocker@@openbsd.org>
@


1.3
log
@Add/Fix copyright notes.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx100.c,v 1.2 2006/08/03 10:12:37 mglocker Exp $ */
a51 2
 * 
 * $DragonFly$
@


1.2
log
@Change to OpenBSD cvs tag.
@
text
@d1 18
a18 1
/*	$OpenBSD$ */
@


1.1
log
@Inital import for the acx(4) driver.

ok deraadt@@ jsg@@
@
text
@d1 1
a1 1
/* $Id: acx100.c,v 1.2 2006/08/01 11:32:19 hacki Exp $ */
@

