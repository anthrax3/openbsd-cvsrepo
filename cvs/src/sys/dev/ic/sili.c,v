head	1.58;
access;
symbols
	OPENBSD_6_2_BASE:1.58
	OPENBSD_6_1:1.58.0.8
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.58.0.6
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.51.0.12
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.51.0.8
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.51.0.6
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.51.0.2
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.4
	OPENBSD_5_0:1.49.0.2
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.43.0.4
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.39.0.4
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33;
locks; strict;
comment	@ * @;


1.58
date	2015.12.19.20.05.32;	author tb;	state Exp;
branches;
next	1.57;
commitid	UOpyHHg5FjEZrGqh;

1.57
date	2015.09.09.18.24.26;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	A1u7pQEYVfdRAnFA;

1.56
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.55;
commitid	p4LJxGKbi0BU2cG6;

1.55
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.54;
commitid	Z1vcFtHO8wRH0yRt;

1.54
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.53;
commitid	uzzBR7hz9ncd4O6G;

1.53
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	JtO5uXxVcnZfhUkR;

1.52
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.51;
commitid	I19imNlAX05zJOED;

1.51
date	2012.02.04.21.44.54;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2012.02.04.17.52.22;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2011.07.04.04.44.50;	author dhill;	state Exp;
branches;
next	1.48;

1.48
date	2011.05.08.19.46.10;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.26.21.41.00;	author drahn;	state Exp;
branches;
next	1.46;

1.46
date	2010.08.05.20.21.36;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.07.09.37.33;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.05.03.57.32;	author ray;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.23.12.46.51;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.28.13.47.09;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.26.15.59.53;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.23.18.26.03;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.23.18.21.55;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.09.05.43.37;	author ray;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.22.00.06.51;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.12.04.40.59;	author pascoe;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.10.09.08.19;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.08.08.13.30;	author pascoe;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.08.06.51.25;	author pascoe;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.08.04.45.40;	author pascoe;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.08.00.47.50;	author pascoe;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.07.15.58.26;	author pascoe;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.07.15.44.22;	author pascoe;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.07.14.46.34;	author pascoe;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.07.14.38.47;	author pascoe;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.07.14.15.14;	author pascoe;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.07.13.37.24;	author pascoe;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.07.13.23.30;	author pascoe;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.07.13.15.03;	author pascoe;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.07.13.05.18;	author pascoe;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.07.10.07.12;	author pascoe;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.07.09.24.12;	author pascoe;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.07.06.10.09;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2007.04.06.04.50.27;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.06.04.48.54;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.05.14.09.36;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.05.10.45.25;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.05.10.15.27;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.05.10.02.07;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.05.10.00.02;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.04.12.42.23;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.04.10.49.42;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.31.03.59.53;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.31.03.11.38;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.30.04.50.54;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.22.06.54.01;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.22.02.48.42;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Replace 'arc4random() % x' by 'arc4random_uniform(x)'.

Diff by Matthew Martin, thanks!

ok djm@@, tedu@@
@
text
@/*	$OpenBSD: sili.c,v 1.57 2015/09/09 18:24:26 deraadt Exp $ */

/*
 * Copyright (c) 2007 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2010 Conformal Systems LLC <info@@conformal.com>
 * Copyright (c) 2010 Jonathan Matthew <jonathan@@d14n.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/mutex.h>

#include <machine/bus.h>

#include <dev/ata/atascsi.h>
#include <dev/ata/pmreg.h>

#include <dev/ic/silireg.h>
#include <dev/ic/silivar.h>

/* use SILI_DEBUG for dmesg spam */
#define NO_SILI_DEBUG

#ifdef SILI_DEBUG
#define SILI_D_VERBOSE		(1<<0)
#define SILI_D_INTR		(1<<1)

int silidebug = SILI_D_VERBOSE;

#define DPRINTF(m, a...)	do { if ((m) & silidebug) printf(a); } while (0)
#else
#define DPRINTF(m, a...)
#endif

/* these can be used to simulate read and write errors on specific PMP ports */
#undef SILI_ERROR_TEST
int sili_error_pmp_ports = 0;		/* bitmask containing ports to fail*/
int sili_error_test_inv_p = 500;	/* 1/P(error) */
int sili_error_restart_type = SILI_PREG_PCS_PORTINIT; /* or _DEVRESET */

struct cfdriver sili_cd = {
	NULL, "sili", DV_DULL
};

/* wrapper around dma memory */
struct sili_dmamem {
	bus_dmamap_t		sdm_map;
	bus_dma_segment_t	sdm_seg;
	size_t			sdm_size;
	caddr_t			sdm_kva;
};
#define SILI_DMA_MAP(_sdm)	((_sdm)->sdm_map)
#define SILI_DMA_DVA(_sdm)	((_sdm)->sdm_map->dm_segs[0].ds_addr)
#define SILI_DMA_KVA(_sdm)	((_sdm)->sdm_kva)

struct sili_dmamem	*sili_dmamem_alloc(struct sili_softc *, bus_size_t,
			    bus_size_t);
void			sili_dmamem_free(struct sili_softc *,
			    struct sili_dmamem *);

/* per port goo */
struct sili_ccb;

/* size of scratch space for use in error recovery. */
#define SILI_SCRATCH_LEN	512	/* must be at least 1 sector */

struct sili_port {
	struct sili_softc	*sp_sc;
	bus_space_handle_t	sp_ioh;

	struct sili_ccb		*sp_ccbs;
	struct sili_dmamem	*sp_cmds;
	struct sili_dmamem	*sp_scratch;

	TAILQ_HEAD(, sili_ccb)	sp_free_ccbs;
	struct mutex		sp_free_ccb_mtx;

	volatile u_int32_t	sp_active;
	TAILQ_HEAD(, sili_ccb)	sp_active_ccbs;
	TAILQ_HEAD(, sili_ccb)	sp_deferred_ccbs;

	int			sp_port;
	int			sp_pmp_ports;
	int			sp_active_pmp_ports;
	int			sp_pmp_error_recovery;	/* port bitmask */
	volatile u_int32_t	sp_err_active;		/* cmd bitmask */
	volatile u_int32_t	sp_err_cmds;		/* cmd bitmask */

#ifdef SILI_DEBUG
	char			sp_name[16];
#define PORTNAME(_sp)	((_sp)->sp_name)
#else
#define PORTNAME(_sp)	DEVNAME((_sp)->sp_sc)
#endif
};

int			sili_ports_alloc(struct sili_softc *);
void			sili_ports_free(struct sili_softc *);

/* ccb shizz */

/*
 * the dma memory for each command will be made up of a prb followed by
 * 7 sgts, this is a neat 512 bytes.
 */
#define SILI_CMD_LEN		512

/*
 * you can fit 22 sge's into 7 sgts and a prb:
 * there's 1 sgl in an atapi prb (two in the ata one, but we cant over
 * advertise), but that's needed for the chain element. you get three sges
 * per sgt cos you lose the 4th sge for the chaining, but you keep it in
 * the last sgt. so 3 x 6 + 4 is 22.
 */
#define SILI_DMA_SEGS		22

struct sili_ccb {
	struct ata_xfer		ccb_xa;

	void			*ccb_cmd;
	u_int64_t		ccb_cmd_dva;
	bus_dmamap_t		ccb_dmamap;

	struct sili_port	*ccb_port;

	TAILQ_ENTRY(sili_ccb)	ccb_entry;
};

int			sili_ccb_alloc(struct sili_port *);
void			sili_ccb_free(struct sili_port *);
struct sili_ccb		*sili_get_ccb(struct sili_port *);
void			sili_put_ccb(struct sili_ccb *);

/* bus space ops */
u_int32_t		sili_read(struct sili_softc *, bus_size_t);
void			sili_write(struct sili_softc *, bus_size_t, u_int32_t);
u_int32_t		sili_pread(struct sili_port *, bus_size_t);
void			sili_pwrite(struct sili_port *, bus_size_t, u_int32_t);
int			sili_pwait_eq(struct sili_port *, bus_size_t,
			    u_int32_t, u_int32_t, int);
int			sili_pwait_ne(struct sili_port *, bus_size_t,
			    u_int32_t, u_int32_t, int);

/* command handling */
void			sili_post_direct(struct sili_port *, u_int,
			    void *, size_t buflen);
void			sili_post_indirect(struct sili_port *,
			    struct sili_ccb *);
void			sili_pread_fis(struct sili_port *, u_int,
			    struct ata_fis_d2h *);
u_int32_t		sili_signature(struct sili_port *, u_int);
u_int32_t		sili_port_softreset(struct sili_port *sp);
int			sili_load(struct sili_ccb *, struct sili_sge *, int);
void			sili_unload(struct sili_ccb *);
int			sili_poll(struct sili_ccb *, int, void (*)(void *));
void			sili_start(struct sili_port *, struct sili_ccb *);
int			sili_read_ncq_error(struct sili_port *, int *, int);
int			sili_pmp_port_start_error_recovery(struct sili_port *,
			    int);
void			sili_pmp_port_do_error_recovery(struct sili_port *,
			    int, u_int32_t *);
void			sili_port_clear_commands(struct sili_port *sp);

/* pmp operations */
int			sili_pmp_read(struct sili_port *, int, int,
			    u_int32_t *);
int			sili_pmp_write(struct sili_port *, int, int, u_int32_t);
int			sili_pmp_phy_status(struct sili_port *, int,
			    u_int32_t *);
int 			sili_pmp_identify(struct sili_port *, int *);

/* port interrupt handler */
u_int32_t		sili_port_intr(struct sili_port *, int);

/* atascsi interface */
int			sili_ata_probe(void *, int, int);
void			sili_ata_free(void *, int, int);
struct ata_xfer		*sili_ata_get_xfer(void *, int);
void			sili_ata_put_xfer(struct ata_xfer *);
void			sili_ata_cmd(struct ata_xfer *);
int			sili_pmp_portreset(struct sili_softc *, int, int);
int			sili_pmp_softreset(struct sili_softc *, int, int);

#ifdef SILI_ERROR_TEST
void 			sili_simulate_error(struct sili_ccb *ccb,
			    int *need_restart, int *err_port);
#endif

struct atascsi_methods sili_atascsi_methods = {
	sili_ata_probe,
	sili_ata_free,
	sili_ata_get_xfer,
	sili_ata_put_xfer,
	sili_ata_cmd
};

/* completion paths */
void			sili_ata_cmd_done(struct sili_ccb *, int);
void			sili_ata_cmd_timeout(void *);
void			sili_dummy_done(struct ata_xfer *);

void			sili_pmp_op_timeout(void *);

int
sili_attach(struct sili_softc *sc)
{
	struct atascsi_attach_args	aaa;

	printf("\n");

	if (sili_ports_alloc(sc) != 0) {
		/* error already printed by sili_port_alloc */
		return (1);
	}

	/* bounce the controller */
	sili_write(sc, SILI_REG_GC, SILI_REG_GC_GR);
	sili_write(sc, SILI_REG_GC, 0x0);

	bzero(&aaa, sizeof(aaa));
	aaa.aaa_cookie = sc;
	aaa.aaa_methods = &sili_atascsi_methods;
	aaa.aaa_minphys = NULL;
	aaa.aaa_nports = sc->sc_nports;
	aaa.aaa_ncmds = SILI_MAX_CMDS;
	aaa.aaa_capability = ASAA_CAP_NCQ | ASAA_CAP_PMP_NCQ;

	sc->sc_atascsi = atascsi_attach(&sc->sc_dev, &aaa);

	return (0);
}

int
sili_detach(struct sili_softc *sc, int flags)
{
	int				rv;

	if (sc->sc_atascsi != NULL) {
		rv = atascsi_detach(sc->sc_atascsi, flags);
		if (rv != 0)
			return (rv);
	}

	if (sc->sc_ports != NULL)
		sili_ports_free(sc);

	return (0);
}

void
sili_resume(struct sili_softc *sc)
{
	int i, j;

	/* bounce the controller */
	sili_write(sc, SILI_REG_GC, SILI_REG_GC_GR);
	sili_write(sc, SILI_REG_GC, 0x0);

	for (i = 0; i < sc->sc_nports; i++) {
		if (sili_ata_probe(sc, i, 0) == ATA_PORT_T_PM) {
			struct sili_port *sp = &sc->sc_ports[i];
			for (j = 0; j < sp->sp_pmp_ports; j++) {
				sili_ata_probe(sc, i, j);
			}
		}
	}
}

int
sili_pmp_port_start_error_recovery(struct sili_port *sp, int err_port)
{
	struct sili_ccb *ccb;

	sp->sp_pmp_error_recovery |= (1 << err_port);

	/* create a bitmask of active commands on non-error ports */
	sp->sp_err_active = 0;
	TAILQ_FOREACH(ccb, &sp->sp_active_ccbs, ccb_entry) {
		int bit = (1 << ccb->ccb_xa.pmp_port);
		if ((sp->sp_pmp_error_recovery & bit) == 0) {
			DPRINTF(SILI_D_VERBOSE, "%s: slot %d active on port "
			    "%d\n", PORTNAME(sp), ccb->ccb_xa.tag,
			    ccb->ccb_xa.pmp_port);
			sp->sp_err_active |= (1 << ccb->ccb_xa.tag);
		}
	}

	if (sp->sp_err_active == 0) {
		DPRINTF(SILI_D_VERBOSE, "%s: no other PMP ports active\n",
		    PORTNAME(sp));
		sp->sp_pmp_error_recovery = 0;
		return (0);
	}

	/* set port resume */
	sili_pwrite(sp, SILI_PREG_PCS, SILI_PREG_PCS_RESUME);

	DPRINTF(SILI_D_VERBOSE, "%s: beginning error recovery (port %d); "
	    "error port mask %x, active slot mask %x\n", PORTNAME(sp), err_port,
	    sp->sp_pmp_error_recovery, sp->sp_err_active);
	return (1);
}

void
sili_port_clear_commands(struct sili_port *sp)
{
	int port;

	DPRINTF(SILI_D_VERBOSE, "%s: clearing active commands\n",
	    PORTNAME(sp));

	/* clear port resume */
	sili_pwrite(sp, SILI_PREG_PCC, SILI_PREG_PCC_RESUME);
	delay(10000);

	/* clear port status and port active for all ports */
	for (port = 0; port < 16; port++) {
		sili_pwrite(sp, SILI_PREG_PMP_STATUS(port), 0);
		sili_pwrite(sp, SILI_PREG_PMP_QACTIVE(port), 0);
	}
}

void
sili_pmp_port_do_error_recovery(struct sili_port *sp, int slot,
    u_int32_t *need_restart)
{
	if (sp->sp_pmp_error_recovery == 0) {
		return;
	}

	/* have all outstanding commands finished yet? */
	if (sp->sp_err_active != 0) {
		DPRINTF(SILI_D_VERBOSE, "%s: PMP error recovery still waiting "
		    "for %x\n", PORTNAME(sp), sp->sp_err_active);
		*need_restart = 0;
		return;
	}

	sili_port_clear_commands(sp);

	/* get the main error recovery code to reset the port and
	 * resubmit commands.  it will also reset the error recovery flags.
	 */
	*need_restart = SILI_PREG_PCS_PORTINIT;
	DPRINTF(SILI_D_VERBOSE, "%s: PMP error recovery complete\n",
	    PORTNAME(sp));
}

#ifdef SILI_ERROR_TEST
void
sili_simulate_error(struct sili_ccb *ccb, int *need_restart, int *err_port)
{
	struct sili_port *sp = ccb->ccb_port;

	if (*need_restart == 0 &&
	    ((1 << ccb->ccb_xa.pmp_port) & sili_error_pmp_ports)) {
		switch (ccb->ccb_xa.fis->command) {
		case ATA_C_WRITE_FPDMA:
		case ATA_C_READ_FPDMA:
		case ATA_C_WRITEDMA_EXT:
		case ATA_C_READDMA_EXT:
		case ATA_C_WRITEDMA:
		case ATA_C_READDMA:
			if (arc4random_uniform(sili_error_test_inv_p) == 0) {
				printf("%s: faking error on slot %d\n",
				    PORTNAME(sp), ccb->ccb_xa.tag);
				ccb->ccb_xa.state = ATA_S_ERROR;
				*need_restart = sili_error_restart_type;
				*err_port = ccb->ccb_xa.pmp_port;

				ccb->ccb_port->sp_err_cmds |=
				    (1 << ccb->ccb_xa.tag);
			}
			break;

		default:
			/* leave other commands alone, we only want to mess
			 * with normal read/write ops
			 */
			break;
		}
	}
}
#endif

u_int32_t
sili_port_intr(struct sili_port *sp, int timeout_slot)
{
	u_int32_t			is, pss_saved, pss_masked;
	u_int32_t			processed = 0, need_restart = 0;
	u_int32_t			err_port = 0;
	int				slot;
	struct sili_ccb			*ccb;

	is = sili_pread(sp, SILI_PREG_IS);
	pss_saved = sili_pread(sp, SILI_PREG_PSS); /* reading acks CMDCOMP */

#ifdef SILI_DEBUG
	if ((pss_saved & SILI_PREG_PSS_ALL_SLOTS) != sp->sp_active ||
	    ((is >> 16) & ~SILI_PREG_IS_CMDCOMP)) {
		DPRINTF(SILI_D_INTR, "%s: IS: 0x%08x (0x%b), PSS: %08x, "
		    "active: %08x\n", PORTNAME(sp), is, is >> 16, SILI_PFMT_IS,
		    pss_saved, sp->sp_active);
	}
#endif

	/* Only interested in slot status bits. */
	pss_saved &= SILI_PREG_PSS_ALL_SLOTS;

	if (is & SILI_PREG_IS_CMDERR) {
		int			err_slot, err_code;
		u_int32_t		sactive = 0;

		sili_pwrite(sp, SILI_PREG_IS, SILI_PREG_IS_CMDERR);
		err_slot = SILI_PREG_PCS_ACTIVE(sili_pread(sp, SILI_PREG_PCS));
		err_code = sili_pread(sp, SILI_PREG_CE);
		ccb = &sp->sp_ccbs[err_slot];

		switch (err_code) {
		case SILI_PREG_CE_DEVICEERROR:
		case SILI_PREG_CE_DATAFISERROR:
			/* Extract error from command slot in LRAM. */
			sili_pread_fis(sp, err_slot, &ccb->ccb_xa.rfis);
			err_port = ccb->ccb_xa.pmp_port;
			break;

		case SILI_PREG_CE_SDBERROR:

			if (sp->sp_pmp_ports > 0) {
				/* get the PMP port number for the error */
				err_port = (sili_pread(sp, SILI_PREG_CONTEXT)
				    >> SILI_PREG_CONTEXT_PMPORT_SHIFT) &
				    SILI_PREG_CONTEXT_PMPORT_MASK;
				DPRINTF(SILI_D_VERBOSE, "%s: error port is "
				    "%d\n", PORTNAME(sp), err_port);

				/* were there any NCQ commands active for
				 * the port?
				 */
				sactive = sili_pread(sp,
				    SILI_PREG_PMP_QACTIVE(err_port));
				DPRINTF(SILI_D_VERBOSE, "%s: error SActive "
				    "%x\n", PORTNAME(sp), sactive);
				if (sactive == 0)
					break;
			} else {
				/* No NCQ commands active?  Treat as a normal
				 * error.
				 */
				sactive = sili_pread(sp, SILI_PREG_SACT);
				if (sactive == 0)
					break;
			}

			/* Extract real NCQ error slot & RFIS from
			 * log page.
			 */ 
			if (!sili_read_ncq_error(sp, &err_slot, err_port)) {
				/* got real err_slot */
				DPRINTF(SILI_D_VERBOSE, "%s.%d: error slot "
				    "%d\n", PORTNAME(sp), err_port, err_slot);
				ccb = &sp->sp_ccbs[err_slot];
				break;
			}
			DPRINTF(SILI_D_VERBOSE, "%s.%d: failed to get error "
			    "slot\n", PORTNAME(sp), err_port);

			/* failed to get error or not NCQ */

			/* FALLTHROUGH */
		default:
			/* All other error types are fatal. */
			if (err_code != SILI_PREG_CE_SDBERROR) {
				err_port = (sili_pread(sp, SILI_PREG_CONTEXT)
				    >> SILI_PREG_CONTEXT_PMPORT_SHIFT) &
				    SILI_PREG_CONTEXT_PMPORT_MASK;
			}
			printf("%s.%d: fatal error (%d), aborting active slots "
			    "(%08x) and resetting device.\n", PORTNAME(sp),
			    err_port, err_code, pss_saved);
			while (pss_saved) {
				slot = ffs(pss_saved) - 1;
				pss_saved &= ~(1 << slot);

				ccb = &sp->sp_ccbs[slot];
				KASSERT(ccb->ccb_xa.state == ATA_S_ONCHIP);
				ccb->ccb_xa.state = ATA_S_ERROR;
			}
			need_restart = SILI_PREG_PCS_DEVRESET;
			goto fatal;
		}

		DPRINTF(SILI_D_VERBOSE, "%s.%d: %serror, code %d, slot %d, "
		    "active %08x\n", PORTNAME(sp), err_port,
		    sactive ? "NCQ " : "", err_code, err_slot, sp->sp_active);

		/* Clear the failed commmand in saved PSS so cmd_done runs. */
		pss_saved &= ~(1 << err_slot);
		/* Track errored commands until we finish recovery */
		sp->sp_err_cmds |= (1 << err_slot);

		KASSERT(ccb->ccb_xa.state == ATA_S_ONCHIP);
		ccb->ccb_xa.state = ATA_S_ERROR;

		need_restart = SILI_PREG_PCS_PORTINIT;
	}
fatal:

	/* Process command timeout request only if command is still active. */
	if (timeout_slot >= 0 && (pss_saved & (1 << timeout_slot))) {
		DPRINTF(SILI_D_VERBOSE, "%s: timing out slot %d, active %08x\n",
		    PORTNAME(sp), timeout_slot, sp->sp_active);

		/* Clear the failed commmand in saved PSS so cmd_done runs. */
		pss_saved &= ~(1 << timeout_slot);

		ccb = &sp->sp_ccbs[timeout_slot];
		KASSERT(ccb->ccb_xa.state == ATA_S_ONCHIP);
		ccb->ccb_xa.state = ATA_S_TIMEOUT;

		/* Reinitialise the port and clear all active commands */
		need_restart = SILI_PREG_PCS_PORTINIT;

		err_port = ccb->ccb_xa.pmp_port;
		sp->sp_err_cmds |= (1 << timeout_slot);

		sili_port_clear_commands(sp);
	}

	/* Command slot is complete if its bit in PSS is 0 but 1 in active. */
	pss_masked = ~pss_saved & sp->sp_active;
	while (pss_masked) {
		slot = ffs(pss_masked) - 1;
		ccb = &sp->sp_ccbs[slot];
		pss_masked &= ~(1 << slot);

		/* copy the rfis into the ccb if we were asked for it */
		if (ccb->ccb_xa.state == ATA_S_ONCHIP &&
		    ccb->ccb_xa.flags & ATA_F_GET_RFIS) {
			sili_pread_fis(sp, slot, &ccb->ccb_xa.rfis);
		}

#ifdef SILI_ERROR_TEST
		/* introduce random errors on reads and writes for testing */
		sili_simulate_error(ccb, &need_restart, &err_port);
#endif

		DPRINTF(SILI_D_INTR, "%s: slot %d is complete%s%s\n",
		    PORTNAME(sp), slot, ccb->ccb_xa.state == ATA_S_ERROR ?
		    " (error)" : (ccb->ccb_xa.state == ATA_S_TIMEOUT ?
		    " (timeout)" : ""),
		    ccb->ccb_xa.flags & ATA_F_NCQ ? " (ncq)" : "");

		sili_ata_cmd_done(ccb, need_restart);

		processed |= 1 << slot;

		sili_pmp_port_do_error_recovery(sp, slot, &need_restart);
	}

	if (need_restart) {

		if (sp->sp_pmp_error_recovery) {
			if (sp->sp_err_active != 0) {
				DPRINTF(SILI_D_VERBOSE, "%s: still waiting for "
				    "non-error commands to finish; port mask "
				    "%x, slot mask %x\n", PORTNAME(sp),
				    sp->sp_pmp_error_recovery,
				    sp->sp_err_active);
				return (processed);
			}
		} else if (timeout_slot < 0 && sp->sp_pmp_ports > 0) {
			/* wait until all other commands have finished before
			 * attempting to reinit the port.
			 */
			DPRINTF(SILI_D_VERBOSE, "%s: error on port with PMP "
			    "attached, error port %d\n", PORTNAME(sp),
			    err_port);
			if (sili_pmp_port_start_error_recovery(sp, err_port)) {
				DPRINTF(SILI_D_VERBOSE, "%s: need to wait for "
				    "other commands to finish\n", PORTNAME(sp));
				return (processed);
			}
		} else if (sp->sp_pmp_ports > 0) {
			DPRINTF(SILI_D_VERBOSE, "%s: timeout on PMP port\n",
			    PORTNAME(sp));
		} else {
			DPRINTF(SILI_D_VERBOSE, "%s: error on non-PMP port\n",
			    PORTNAME(sp));
		}

		/* Re-enable transfers on port. */
		sili_pwrite(sp, SILI_PREG_PCS, need_restart);
		if (!sili_pwait_eq(sp, SILI_PREG_PCS, need_restart, 0, 5000)) {
			printf("%s: port reset bit didn't clear after error\n",
			    PORTNAME(sp));
		}
		if (!sili_pwait_eq(sp, SILI_PREG_PCS, SILI_PREG_PCS_PORTRDY,
		    SILI_PREG_PCS_PORTRDY, 1000)) {
			printf("%s: couldn't restart port after error\n",
			    PORTNAME(sp));
		}
		sili_pwrite(sp, SILI_PREG_PCC, SILI_PREG_PCC_RESUME);

		/* check that our active CCB list matches the restart mask */
		pss_masked = pss_saved & ~(sp->sp_err_cmds);
		DPRINTF(SILI_D_VERBOSE, "%s: restart mask %x\n",
		    PORTNAME(sp), pss_masked);
		TAILQ_FOREACH(ccb, &sp->sp_active_ccbs, ccb_entry) {
			if (!(pss_masked & (1 << ccb->ccb_xa.tag))) {
				panic("sili_intr: slot %d not active in "
				    "pss_masked: %08x, state %02x",
				    ccb->ccb_xa.tag, pss_masked,
				    ccb->ccb_xa.state);
			}
			pss_masked &= ~(1 << ccb->ccb_xa.tag);
		}
		if (pss_masked != 0) {
			printf("%s: mask excluding active slots: %x\n",
			    PORTNAME(sp), pss_masked);
		}
		KASSERT(pss_masked == 0);
		
		/* if we had a timeout on a PMP port, do a portreset.
		 * exclude the control port here as there isn't a real
		 * device there to reset.
		 */
		if (timeout_slot >= 0 && sp->sp_pmp_ports > 0 &&
		    err_port != 15) {

			DPRINTF(SILI_D_VERBOSE,
			    "%s.%d: doing portreset after timeout\n",
			    PORTNAME(sp), err_port);
			sili_pmp_portreset(sp->sp_sc, sp->sp_port, err_port);

			/* wait a bit to let the port settle down */
			delay(2000000);
		}

		/* if we sent a device reset to a PMP, we need to reset the
		 * devices behind it too.
		 */
		if (need_restart == SILI_PREG_PCS_DEVRESET &&
		    sp->sp_pmp_ports > 0) {
			int port_type;
			int i;

			port_type = sili_port_softreset(sp);
			if (port_type != ATA_PORT_T_PM) {
				/* device disappeared or changed type? */
				printf("%s: expected to find a port multiplier,"
				    " got %d\n", PORTNAME(sp), port_type);
			}

			/* and now portreset all active ports */
			for (i = 0; i < sp->sp_pmp_ports; i++) {
				struct sili_softc *sc = sp->sp_sc;

				if ((sp->sp_active_pmp_ports & (1 << i)) == 0)
					continue;

				if (sili_pmp_portreset(sc, sp->sp_port, i)) {
					printf("%s.%d: failed to portreset "
					    "after error\n", PORTNAME(sp), i);
				}
			}
		}

		/* Restart CCBs in the order they were originally queued. */
		TAILQ_FOREACH(ccb, &sp->sp_active_ccbs, ccb_entry) {
			DPRINTF(SILI_D_VERBOSE, "%s: restarting slot %d "
			    "after error, state %02x\n", PORTNAME(sp),
			    ccb->ccb_xa.tag, ccb->ccb_xa.state);
			KASSERT(ccb->ccb_xa.state == ATA_S_ONCHIP);
			sili_post_indirect(sp, ccb);
		}
		sp->sp_err_cmds = 0;
		sp->sp_pmp_error_recovery = 0;
		
		/*
		 * Finally, run atascsi completion for any finished CCBs.  If
		 * we had run these during cmd_done above, any ccbs that their
		 * completion generated would have been activated out of order.
		 */
		while ((ccb = TAILQ_FIRST(&sp->sp_deferred_ccbs)) != NULL) {
			TAILQ_REMOVE(&sp->sp_deferred_ccbs, ccb, ccb_entry);

			DPRINTF(SILI_D_VERBOSE, "%s: running deferred "
			    "completion for slot %d, state %02x\n",
			    PORTNAME(sp), ccb->ccb_xa.tag, ccb->ccb_xa.state);
			KASSERT(ccb->ccb_xa.state == ATA_S_COMPLETE ||
			    ccb->ccb_xa.state == ATA_S_ERROR ||
			    ccb->ccb_xa.state == ATA_S_TIMEOUT);
			ata_complete(&ccb->ccb_xa);
		}
	}

	return (processed);
}

int
sili_intr(void *arg)
{
	struct sili_softc		*sc = arg;
	u_int32_t			is;
	int				port;

	/* If the card has gone away, this will return 0xffffffff. */
	is = sili_read(sc, SILI_REG_GIS);
	if (is == 0 || is == 0xffffffff)
		return (0);
	sili_write(sc, SILI_REG_GIS, is);
	DPRINTF(SILI_D_INTR, "sili_intr, GIS: %08x\n", is);

	while (is & SILI_REG_GIS_PIS_MASK) {
		port = ffs(is) - 1;
		sili_port_intr(&sc->sc_ports[port], -1);
		is &= ~(1 << port);
	}

	return (1);
}

int
sili_ports_alloc(struct sili_softc *sc)
{
	struct sili_port		*sp;
	int				i;

	sc->sc_ports = mallocarray(sc->sc_nports, sizeof(struct sili_port),
	    M_DEVBUF, M_WAITOK | M_ZERO);

	for (i = 0; i < sc->sc_nports; i++) {
		sp = &sc->sc_ports[i];

		sp->sp_sc = sc;
		sp->sp_port = i;
#ifdef SILI_DEBUG
		snprintf(sp->sp_name, sizeof(sp->sp_name), "%s.%d",
		    DEVNAME(sc), i);
#endif
		if (bus_space_subregion(sc->sc_iot_port, sc->sc_ioh_port,
		    SILI_PORT_OFFSET(i), SILI_PORT_SIZE, &sp->sp_ioh) != 0) {
			printf("%s: unable to create register window "
			    "for port %d\n", DEVNAME(sc), i);
			goto freeports;
		}
	}

	return (0);

freeports:
	/* bus_space(9) says subregions dont have to be freed */
	free(sp, M_DEVBUF, sc->sc_nports * sizeof(struct sili_port));
	sc->sc_ports = NULL;
	return (1);
}

void
sili_ports_free(struct sili_softc *sc)
{
	struct sili_port		*sp;
	int				i;

	for (i = 0; i < sc->sc_nports; i++) {
		sp = &sc->sc_ports[i];

		if (sp->sp_ccbs != NULL)
			sili_ccb_free(sp);
	}

	/* bus_space(9) says subregions dont have to be freed */
	free(sc->sc_ports, M_DEVBUF, sc->sc_nports * sizeof(struct sili_port));
	sc->sc_ports = NULL;
}

int
sili_ccb_alloc(struct sili_port *sp)
{
	struct sili_softc		*sc = sp->sp_sc;
	struct sili_ccb			*ccb;
	struct sili_prb			*prb;
	int				i;

	TAILQ_INIT(&sp->sp_free_ccbs);
	mtx_init(&sp->sp_free_ccb_mtx, IPL_BIO);
	TAILQ_INIT(&sp->sp_active_ccbs);
	TAILQ_INIT(&sp->sp_deferred_ccbs);

	sp->sp_ccbs = mallocarray(SILI_MAX_CMDS, sizeof(struct sili_ccb),
	    M_DEVBUF, M_WAITOK);
	sp->sp_cmds = sili_dmamem_alloc(sc, SILI_CMD_LEN * SILI_MAX_CMDS,
	    SILI_PRB_ALIGN);
	if (sp->sp_cmds == NULL)
		goto free_ccbs;
	sp->sp_scratch = sili_dmamem_alloc(sc, SILI_SCRATCH_LEN, PAGE_SIZE);
	if (sp->sp_scratch == NULL)
		goto free_cmds;

	bzero(sp->sp_ccbs, sizeof(struct sili_ccb) * SILI_MAX_CMDS);

	for (i = 0; i < SILI_MAX_CMDS; i++) {
		ccb = &sp->sp_ccbs[i];
		ccb->ccb_port = sp;
		ccb->ccb_cmd = SILI_DMA_KVA(sp->sp_cmds) + i * SILI_CMD_LEN;
		ccb->ccb_cmd_dva = SILI_DMA_DVA(sp->sp_cmds) + i * SILI_CMD_LEN;
		if (bus_dmamap_create(sc->sc_dmat, MAXPHYS, SILI_DMA_SEGS,
		    MAXPHYS, 0, BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW,
		    &ccb->ccb_dmamap) != 0)
			goto free_scratch;

		prb = ccb->ccb_cmd;
		ccb->ccb_xa.fis = (struct ata_fis_h2d *)&prb->fis;
		ccb->ccb_xa.packetcmd = ((struct sili_prb_packet *)prb)->cdb;
		ccb->ccb_xa.tag = i;
		ccb->ccb_xa.state = ATA_S_COMPLETE;

		sili_put_ccb(ccb);
	}

	return (0);

free_scratch:
	sili_dmamem_free(sc, sp->sp_scratch);
free_cmds:
	sili_dmamem_free(sc, sp->sp_cmds);
free_ccbs:
	sili_ccb_free(sp);
	return (1);
}

void
sili_ccb_free(struct sili_port *sp)
{
	struct sili_softc		*sc = sp->sp_sc;
	struct sili_ccb			*ccb;

	while ((ccb = sili_get_ccb(sp)) != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);

	free(sp->sp_ccbs, M_DEVBUF, 0);
	sp->sp_ccbs = NULL;
}

struct sili_ccb *
sili_get_ccb(struct sili_port *sp)
{
	struct sili_ccb			*ccb;

	/*
	 * Don't allow new commands to start while doing PMP error
	 * recovery
	 */
	if (sp->sp_pmp_error_recovery != 0) {
		return (NULL);
	}

	mtx_enter(&sp->sp_free_ccb_mtx);
	ccb = TAILQ_FIRST(&sp->sp_free_ccbs);
	if (ccb != NULL) {
		KASSERT(ccb->ccb_xa.state == ATA_S_PUT);
		TAILQ_REMOVE(&sp->sp_free_ccbs, ccb, ccb_entry);
		ccb->ccb_xa.state = ATA_S_SETUP;
	}
	mtx_leave(&sp->sp_free_ccb_mtx);

	return (ccb);
}

void
sili_put_ccb(struct sili_ccb *ccb)
{
	struct sili_port		*sp = ccb->ccb_port;

#ifdef DIAGNOSTIC
	if (ccb->ccb_xa.state != ATA_S_COMPLETE &&
	    ccb->ccb_xa.state != ATA_S_TIMEOUT &&
	    ccb->ccb_xa.state != ATA_S_ERROR) {
		printf("%s: invalid ata_xfer state %02x in sili_put_ccb, "
		    "slot %d\n", PORTNAME(sp), ccb->ccb_xa.state,
		    ccb->ccb_xa.tag);
	}
#endif

	ccb->ccb_xa.state = ATA_S_PUT;
	mtx_enter(&sp->sp_free_ccb_mtx);
	TAILQ_INSERT_TAIL(&sp->sp_free_ccbs, ccb, ccb_entry);
	mtx_leave(&sp->sp_free_ccb_mtx);
}

struct sili_dmamem *
sili_dmamem_alloc(struct sili_softc *sc, bus_size_t size, bus_size_t align)
{
	struct sili_dmamem		*sdm;
	int				nsegs;

	sdm = malloc(sizeof(*sdm), M_DEVBUF, M_WAITOK | M_ZERO);
	sdm->sdm_size = size;

	if (bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW, &sdm->sdm_map) != 0)
		goto sdmfree;

	if (bus_dmamem_alloc(sc->sc_dmat, size, align, 0, &sdm->sdm_seg,
	    1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0)
		goto destroy;

	if (bus_dmamem_map(sc->sc_dmat, &sdm->sdm_seg, nsegs, size,
	    &sdm->sdm_kva, BUS_DMA_NOWAIT) != 0)
		goto free;

	if (bus_dmamap_load(sc->sc_dmat, sdm->sdm_map, sdm->sdm_kva, size,
	    NULL, BUS_DMA_NOWAIT) != 0)
		goto unmap;

	return (sdm);

unmap:
	bus_dmamem_unmap(sc->sc_dmat, sdm->sdm_kva, size);
free:
	bus_dmamem_free(sc->sc_dmat, &sdm->sdm_seg, 1);
destroy:
	bus_dmamap_destroy(sc->sc_dmat, sdm->sdm_map);
sdmfree:
	free(sdm, M_DEVBUF, sizeof *sdm);

	return (NULL);
}

void
sili_dmamem_free(struct sili_softc *sc, struct sili_dmamem *sdm)
{
	bus_dmamap_unload(sc->sc_dmat, sdm->sdm_map);
	bus_dmamem_unmap(sc->sc_dmat, sdm->sdm_kva, sdm->sdm_size);
	bus_dmamem_free(sc->sc_dmat, &sdm->sdm_seg, 1);
	bus_dmamap_destroy(sc->sc_dmat, sdm->sdm_map);
	free(sdm, M_DEVBUF, sizeof *sdm);
}

u_int32_t
sili_read(struct sili_softc *sc, bus_size_t r)
{
	u_int32_t			rv;

	bus_space_barrier(sc->sc_iot_global, sc->sc_ioh_global, r, 4,
	    BUS_SPACE_BARRIER_READ);
	rv = bus_space_read_4(sc->sc_iot_global, sc->sc_ioh_global, r);

	return (rv);
}

void
sili_write(struct sili_softc *sc, bus_size_t r, u_int32_t v)
{
	bus_space_write_4(sc->sc_iot_global, sc->sc_ioh_global, r, v);
	bus_space_barrier(sc->sc_iot_global, sc->sc_ioh_global, r, 4,
	    BUS_SPACE_BARRIER_WRITE);
}

u_int32_t
sili_pread(struct sili_port *sp, bus_size_t r)
{
	u_int32_t			rv;

	bus_space_barrier(sp->sp_sc->sc_iot_port, sp->sp_ioh, r, 4,
	    BUS_SPACE_BARRIER_READ);
	rv = bus_space_read_4(sp->sp_sc->sc_iot_port, sp->sp_ioh, r);

	return (rv);
}

void
sili_pwrite(struct sili_port *sp, bus_size_t r, u_int32_t v)
{
	bus_space_write_4(sp->sp_sc->sc_iot_port, sp->sp_ioh, r, v);
	bus_space_barrier(sp->sp_sc->sc_iot_port, sp->sp_ioh, r, 4,
	    BUS_SPACE_BARRIER_WRITE);
}

int
sili_pwait_eq(struct sili_port *sp, bus_size_t r, u_int32_t mask,
    u_int32_t value, int timeout)
{
	while ((sili_pread(sp, r) & mask) != value) {
		if (timeout == 0)
			return (0);

		delay(1000);
		timeout--;
	}

	return (1);
}

int
sili_pwait_ne(struct sili_port *sp, bus_size_t r, u_int32_t mask,
    u_int32_t value, int timeout)
{
	while ((sili_pread(sp, r) & mask) == value) {
		if (timeout == 0)
			return (0);

		delay(1000);
		timeout--;
	}

	return (1);
}

void
sili_post_direct(struct sili_port *sp, u_int slot, void *buf, size_t buflen)
{
	bus_size_t			r = SILI_PREG_SLOT(slot);

#ifdef DIAGNOSTIC
	if (buflen != 64 && buflen != 128)
		panic("sili_pcopy: buflen of %lu is not 64 or 128", buflen);
#endif

	bus_space_write_raw_region_4(sp->sp_sc->sc_iot_port, sp->sp_ioh, r,
	    buf, buflen);
	bus_space_barrier(sp->sp_sc->sc_iot_port, sp->sp_ioh, r, buflen,
	    BUS_SPACE_BARRIER_WRITE);

	sili_pwrite(sp, SILI_PREG_FIFO, slot);
}

void
sili_pread_fis(struct sili_port *sp, u_int slot, struct ata_fis_d2h *fis)
{
	bus_size_t			r = SILI_PREG_SLOT(slot) + 8;

	bus_space_barrier(sp->sp_sc->sc_iot_port, sp->sp_ioh, r,
	    sizeof(struct ata_fis_d2h), BUS_SPACE_BARRIER_READ);
	bus_space_read_raw_region_4(sp->sp_sc->sc_iot_port, sp->sp_ioh, r,
	    fis, sizeof(struct ata_fis_d2h));
}

void
sili_post_indirect(struct sili_port *sp, struct sili_ccb *ccb)
{
	sili_pwrite(sp, SILI_PREG_CAR_LO(ccb->ccb_xa.tag),
	    (u_int32_t)ccb->ccb_cmd_dva);
	sili_pwrite(sp, SILI_PREG_CAR_HI(ccb->ccb_xa.tag),
	    (u_int32_t)(ccb->ccb_cmd_dva >> 32));
}

u_int32_t
sili_signature(struct sili_port *sp, u_int slot)
{
	u_int32_t			sig_hi, sig_lo;

	sig_hi = sili_pread(sp, SILI_PREG_SIG_HI(slot));
	sig_hi <<= SILI_PREG_SIG_HI_SHIFT;
	sig_lo = sili_pread(sp, SILI_PREG_SIG_LO(slot));
	sig_lo &= SILI_PREG_SIG_LO_MASK;

	return (sig_hi | sig_lo);
}

void
sili_dummy_done(struct ata_xfer *xa)
{
}

int
sili_pmp_portreset(struct sili_softc *sc, int port, int pmp_port)
{
	struct sili_port	*sp;
	u_int32_t 		data;
	int			loop;

	sp = &sc->sc_ports[port];
	DPRINTF(SILI_D_VERBOSE, "%s: resetting pmp port %d\n", PORTNAME(sp),
	    pmp_port);

	if (sili_pmp_write(sp, pmp_port, SATA_PMREG_SERR, -1))
		goto err;
	if (sili_pmp_write(sp, pmp_port, SATA_PMREG_SCTL,
	    SATA_PM_SCTL_IPM_DISABLED))
		goto err;
	delay(10000);

	/* enable PHY by writing 1 then 0 to Scontrol DET field, using
	 * Write Port Multiplier commands
	 */
	data = SATA_PM_SCTL_IPM_DISABLED | SATA_PM_SCTL_DET_INIT |
	    SATA_PM_SCTL_SPD_ANY;
	if (sili_pmp_write(sp, pmp_port, SATA_PMREG_SCTL, data))
		goto err;
	delay(100000);
	
	if (sili_pmp_phy_status(sp, pmp_port, &data)) {
		printf("%s: cannot clear phy status for PMP probe\n",
			PORTNAME(sp));
		goto err;
	}
	
	sili_pmp_write(sp, pmp_port, SATA_PMREG_SERR, -1);
	data = SATA_PM_SCTL_IPM_DISABLED | SATA_PM_SCTL_DET_NONE;
	if (sili_pmp_write(sp, pmp_port, SATA_PMREG_SCTL, data))
		goto err;
	delay(100000);
	
	/* wait for PHYRDY by polling SStatus */
	for (loop = 3; loop; loop--) {
		if (sili_pmp_read(sp, pmp_port, SATA_PMREG_SSTS, &data))
			goto err;
		if (data & SATA_PM_SSTS_DET)
			break;
		delay(100000);
	}
	if (loop == 0) {
		DPRINTF(SILI_D_VERBOSE, "%s.%d: port appears to be unplugged\n",
		    PORTNAME(sp), pmp_port);
		goto err;
	}
	
	/* give it a bit more time to complete negotiation */
	for (loop = 30; loop; loop--) {
		if (sili_pmp_read(sp, pmp_port, SATA_PMREG_SSTS, &data))
			goto err;
		if ((data & SATA_PM_SSTS_DET) == SATA_PM_SSTS_DET_DEV)
			break;
		delay(10000);
	}
	if (loop == 0) {
		printf("%s.%d: device may be powered down\n", PORTNAME(sp),
		    pmp_port);
		goto err;
	}

	DPRINTF(SILI_D_VERBOSE, "%s.%d: device detected; SStatus=%08x\n",
	    PORTNAME(sp), pmp_port, data);

	/* clear the X-bit and all other error bits in Serror (PCSR[1]) */
	sili_pmp_write(sp, pmp_port, SATA_PMREG_SERR, -1);
	return (0);

err:
	DPRINTF(SILI_D_VERBOSE, "%s.%d: port reset failed\n", PORTNAME(sp),
	    pmp_port);
	sili_pmp_write(sp, pmp_port, SATA_PMREG_SERR, -1);
	return (1);
}

void
sili_pmp_op_timeout(void *cookie)
{
	struct sili_ccb *ccb = cookie;
	struct sili_port *sp = ccb->ccb_port;
	int s;

	switch (ccb->ccb_xa.state) {
	case ATA_S_PENDING:
		TAILQ_REMOVE(&sp->sp_active_ccbs, ccb, ccb_entry);
		ccb->ccb_xa.state = ATA_S_TIMEOUT;
		break;
	case ATA_S_ONCHIP:
		KASSERT(sp->sp_active == (1 << ccb->ccb_xa.tag));
		s = splbio();
		sili_port_intr(sp, ccb->ccb_xa.tag);
		splx(s);
		break;
	case ATA_S_ERROR:
		/* don't do anything? */
		break;
	default:
		panic("%s: sili_pmp_op_timeout: ccb in bad state %d",
		      PORTNAME(sp), ccb->ccb_xa.state);
	}
}

int
sili_pmp_softreset(struct sili_softc *sc, int port, int pmp_port)
{
	struct sili_ccb		*ccb;
	struct sili_prb		*prb;
	struct sili_port	*sp;
	struct ata_fis_h2d	*fis;
	u_int32_t 		data;
	u_int32_t		signature;

	sp = &sc->sc_ports[port];

	ccb = sili_get_ccb(sp);
	if (ccb == NULL) {
		printf("%s: sili_pmp_softreset NULL ccb!\n", PORTNAME(sp));
		return (-1);
	}

	ccb->ccb_xa.flags = ATA_F_POLL | ATA_F_GET_RFIS;
	ccb->ccb_xa.complete = sili_dummy_done;
	ccb->ccb_xa.pmp_port = pmp_port;
	
	prb = ccb->ccb_cmd;
	bzero(prb, sizeof(*prb));
	fis = (struct ata_fis_h2d *)&prb->fis;
	fis->flags = pmp_port;
	prb->control = SILI_PRB_SOFT_RESET;

	ccb->ccb_xa.state = ATA_S_PENDING;

	if (sili_poll(ccb, 8000, sili_pmp_op_timeout) != 0) {
		DPRINTF(SILI_D_VERBOSE, "%s.%d: softreset FIS failed\n",
		    PORTNAME(sp), pmp_port);

		sili_put_ccb(ccb);
		/* don't return a valid device type here so the caller knows
		 * it can retry if it wants to
		 */
		return (-1);
	}

	signature = ccb->ccb_xa.rfis.sector_count |
	    (ccb->ccb_xa.rfis.lba_low << 8) |
	    (ccb->ccb_xa.rfis.lba_mid << 16) |
	    (ccb->ccb_xa.rfis.lba_high << 24);
	DPRINTF(SILI_D_VERBOSE, "%s.%d: signature: %08x\n", PORTNAME(sp),
	    pmp_port, signature);

	sili_put_ccb(ccb);

	/* clear phy status and error bits */
	if (sili_pmp_phy_status(sp, pmp_port, &data)) {
		printf("%s.%d: cannot clear phy status after softreset\n",
		       PORTNAME(sp), pmp_port);
	}
	sili_pmp_write(sp, pmp_port, SATA_PMREG_SERR, -1);

	/* classify the device based on its signature */
	switch (signature) {
	case SATA_SIGNATURE_DISK:
		return (ATA_PORT_T_DISK);
	case SATA_SIGNATURE_ATAPI:
		return (ATA_PORT_T_ATAPI);
	case SATA_SIGNATURE_PORT_MULTIPLIER:
		return (ATA_PORT_T_NONE);
	default:
		return (ATA_PORT_T_NONE);
	}
}

u_int32_t
sili_port_softreset(struct sili_port *sp)
{
	struct sili_prb_softreset	sreset;
	u_int32_t			signature;

	bzero(&sreset, sizeof(sreset));
	sreset.control = htole16(SILI_PRB_SOFT_RESET | SILI_PRB_INTERRUPT_MASK);
	sreset.fis[1] = SATA_PMP_CONTROL_PORT;

	/* we use slot 0 */
	sili_post_direct(sp, 0, &sreset, sizeof(sreset));
	if (!sili_pwait_eq(sp, SILI_PREG_PSS, (1 << 0), 0, 1000)) {
		DPRINTF(SILI_D_VERBOSE, "%s: timed out while waiting for soft "
		    "reset\n", PORTNAME(sp));
		return (ATA_PORT_T_NONE);
	}

	/* Read device signature from command slot. */
	signature = sili_signature(sp, 0);

	DPRINTF(SILI_D_VERBOSE, "%s: signature 0x%08x\n", PORTNAME(sp),
	    signature);

	switch (signature) {
	case SATA_SIGNATURE_DISK:
		return (ATA_PORT_T_DISK);
	case SATA_SIGNATURE_ATAPI:
		return (ATA_PORT_T_ATAPI);
	case SATA_SIGNATURE_PORT_MULTIPLIER:
		return (ATA_PORT_T_PM);
	default:
		return (ATA_PORT_T_NONE);
	}
}

int
sili_ata_probe(void *xsc, int port, int lun)
{
	struct sili_softc		*sc = xsc;
	struct sili_port		*sp = &sc->sc_ports[port];
	int				port_type;

	/* handle pmp port probes */
	if (lun != 0) {
		int i;
		int rc;
		int pmp_port = lun - 1;

		if (lun > sp->sp_pmp_ports)
			return (ATA_PORT_T_NONE);

		for (i = 0; i < 2; i++) {
			if (sili_pmp_portreset(sc, port, pmp_port)) {
				continue;
			}

			/* small delay between attempts to allow error
			 * conditions to settle down.  this doesn't seem
			 * to affect portreset operations, just
			 * commands sent to the device.
			 */
			if (i != 0) {
				delay(5000000);
			}

			rc = sili_pmp_softreset(sc, port, pmp_port);
			switch (rc) {
			case -1:
				/* possibly try again */
				break;
			case ATA_PORT_T_DISK:
			case ATA_PORT_T_ATAPI:
				/* mark this port as active */
				sp->sp_active_pmp_ports |= (1 << pmp_port);
			default:
				return (rc);
			}
		}
		DPRINTF(SILI_D_VERBOSE, "%s.%d: probe failed\n", PORTNAME(sp),
		    pmp_port);
		return (ATA_PORT_T_NONE);
	}

	sili_pwrite(sp, SILI_PREG_PCS, SILI_PREG_PCS_PORTRESET);
	delay(10000);
	sili_pwrite(sp, SILI_PREG_PCC, SILI_PREG_PCC_PORTRESET);

	sili_pwrite(sp, SILI_PREG_PCS, SILI_PREG_PCS_PORTINIT);
	if (!sili_pwait_eq(sp, SILI_PREG_PCS, SILI_PREG_PCS_PORTRDY,
	    SILI_PREG_PCS_PORTRDY, 1000)) {
		printf("%s: couldn't initialize port\n", PORTNAME(sp));
		return (ATA_PORT_T_NONE);
	}

	sili_pwrite(sp, SILI_PREG_PCC, SILI_PREG_PCC_A32B);

	if (!sili_pwait_eq(sp, SILI_PREG_SSTS, SATA_SStatus_DET,
	    SATA_SStatus_DET_DEV, 2000)) {
		DPRINTF(SILI_D_VERBOSE, "%s: unattached\n", PORTNAME(sp));
		return (ATA_PORT_T_NONE);
	}

	DPRINTF(SILI_D_VERBOSE, "%s: SSTS 0x%08x\n", PORTNAME(sp),
	    sili_pread(sp, SILI_PREG_SSTS));

	port_type = sili_port_softreset(sp);
	if (port_type == ATA_PORT_T_NONE)
		return (port_type);

	/* allocate port resources */
	if (sili_ccb_alloc(sp) != 0)
		return (ATA_PORT_T_NONE);

	/* do PMP probe now that we can talk to the device */
	if (port_type == ATA_PORT_T_PM) {
		int i;

		sili_pwrite(sp, SILI_PREG_PCS, SILI_PREG_PCS_PMEN);

		if (sili_pmp_identify(sp, &sp->sp_pmp_ports)) {
			return (ATA_PORT_T_NONE);
		}

		/* reset all the PMP ports to wake devices up */
		for (i = 0; i < sp->sp_pmp_ports; i++) {
			sili_pmp_portreset(sp->sp_sc, sp->sp_port, i);
		}
	}

	/* enable port interrupts */
	sili_write(sc, SILI_REG_GC, sili_read(sc, SILI_REG_GC) | 1 << port);
	sili_pwrite(sp, SILI_PREG_IES, SILI_PREG_IE_CMDERR |
	    SILI_PREG_IE_CMDCOMP);

	return (port_type);
}

void
sili_ata_free(void *xsc, int port, int lun)
{
	struct sili_softc		*sc = xsc;
	struct sili_port		*sp = &sc->sc_ports[port];

	if (lun == 0) {
		if (sp->sp_ccbs != NULL)
			sili_ccb_free(sp);

		/* XXX we should do more here */
	}
}

void
sili_ata_cmd(struct ata_xfer *xa)
{
	struct sili_ccb			*ccb = (struct sili_ccb *)xa;
	struct sili_port		*sp = ccb->ccb_port;
	struct sili_softc		*sc = sp->sp_sc;
	struct sili_prb_ata		*ata;
	struct sili_prb_packet		*atapi;
	struct sili_sge			*sgl;
	int				sgllen;
	int				s;

	KASSERT(xa->state == ATA_S_SETUP || xa->state == ATA_S_TIMEOUT);

	if (xa->flags & ATA_F_PACKET) {
		atapi = ccb->ccb_cmd;

		if (xa->flags & ATA_F_WRITE)
			atapi->control = htole16(SILI_PRB_PACKET_WRITE);
		else
			atapi->control = htole16(SILI_PRB_PACKET_READ);

		sgl = atapi->sgl;
		sgllen = nitems(atapi->sgl);
	} else {
		ata = ccb->ccb_cmd;

		ata->control = 0;

		sgl = ata->sgl;
		sgllen = nitems(ata->sgl);
	}

	if (sili_load(ccb, sgl, sgllen) != 0)
		goto failcmd;

	bus_dmamap_sync(sc->sc_dmat, SILI_DMA_MAP(sp->sp_cmds),
	    xa->tag * SILI_CMD_LEN, SILI_CMD_LEN, BUS_DMASYNC_PREWRITE);

	timeout_set(&xa->stimeout, sili_ata_cmd_timeout, ccb);

	xa->state = ATA_S_PENDING;

	if (xa->flags & ATA_F_POLL)
		sili_poll(ccb, xa->timeout, sili_ata_cmd_timeout);
	else {
		s = splbio();
		timeout_add_msec(&xa->stimeout, xa->timeout);
		sili_start(sp, ccb);
		splx(s);
	}

	return;

failcmd:
	s = splbio();
	xa->state = ATA_S_ERROR;
	ata_complete(xa);
	splx(s);
}

void
sili_ata_cmd_done(struct sili_ccb *ccb, int defer_completion)
{
	struct sili_port		*sp = ccb->ccb_port;
	struct sili_softc		*sc = sp->sp_sc;
	struct ata_xfer			*xa = &ccb->ccb_xa;

	splassert(IPL_BIO);

	timeout_del(&xa->stimeout);

	bus_dmamap_sync(sc->sc_dmat, SILI_DMA_MAP(sp->sp_cmds),
	    xa->tag * SILI_CMD_LEN, SILI_CMD_LEN, BUS_DMASYNC_POSTWRITE);

	sili_unload(ccb);

	TAILQ_REMOVE(&sp->sp_active_ccbs, ccb, ccb_entry);
	sp->sp_active &= ~(1 << xa->tag);
	if (sp->sp_err_active & (1 << xa->tag)) {
		sp->sp_err_active &= ~(1 << xa->tag);
		DPRINTF(SILI_D_VERBOSE, "%s: slot %d complete, error mask now "
		    "%x\n", PORTNAME(sp), xa->tag, sp->sp_err_active);
	}

	if (xa->state == ATA_S_ONCHIP)
		xa->state = ATA_S_COMPLETE;
#ifdef DIAGNOSTIC
	else if (xa->state != ATA_S_ERROR && xa->state != ATA_S_TIMEOUT)
		printf("%s: invalid ata_xfer state %02x in sili_ata_cmd_done, "
		    "slot %d\n", PORTNAME(sp), xa->state, xa->tag);
#endif
	if (defer_completion)
		TAILQ_INSERT_TAIL(&sp->sp_deferred_ccbs, ccb, ccb_entry);
	else if (xa->state == ATA_S_COMPLETE)
		ata_complete(xa);
#ifdef DIAGNOSTIC
	else
		printf("%s: completion not deferred, but xa->state is %02x?\n",
		    PORTNAME(sp), xa->state);
#endif
}

void
sili_ata_cmd_timeout(void *xccb)
{
	struct sili_ccb			*ccb = xccb;
	struct sili_port		*sp = ccb->ccb_port;
	int				s;

	s = splbio();
	sili_port_intr(sp, ccb->ccb_xa.tag);
	splx(s);
}

int
sili_load(struct sili_ccb *ccb, struct sili_sge *sgl, int sgllen)
{
	struct sili_port		*sp = ccb->ccb_port;
	struct sili_softc		*sc = sp->sp_sc;
	struct ata_xfer			*xa = &ccb->ccb_xa;
	struct sili_sge			*nsge = sgl, *ce = NULL;
	bus_dmamap_t			dmap = ccb->ccb_dmamap;
	u_int64_t			addr;
	int				error;
	int				i;

	if (xa->datalen == 0)
		return (0);

	error = bus_dmamap_load(sc->sc_dmat, dmap, xa->data, xa->datalen, NULL,
	    (xa->flags & ATA_F_NOWAIT) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error != 0) {
		printf("%s: error %d loading dmamap\n", PORTNAME(sp), error);
		return (1);
	}

	if (dmap->dm_nsegs > sgllen)
		ce = &sgl[sgllen - 1];

	for (i = 0; i < dmap->dm_nsegs; i++) {
		if (nsge == ce) {
			nsge++;

			addr = ccb->ccb_cmd_dva;
			addr += ((u_int8_t *)nsge - (u_int8_t *)ccb->ccb_cmd);

			ce->addr_lo = htole32((u_int32_t)addr);
			ce->addr_hi = htole32((u_int32_t)(addr >> 32));
			ce->flags = htole32(SILI_SGE_LNK);

			if ((dmap->dm_nsegs - i) > SILI_SGT_SGLLEN)
				ce += SILI_SGT_SGLLEN;
			else
				ce = NULL;
		}

		sgl = nsge;

		addr = dmap->dm_segs[i].ds_addr;
		sgl->addr_lo = htole32((u_int32_t)addr);
		sgl->addr_hi = htole32((u_int32_t)(addr >> 32));
		sgl->data_count = htole32(dmap->dm_segs[i].ds_len);
		sgl->flags = 0;

		nsge++;
	}
	sgl->flags |= htole32(SILI_SGE_TRM);

	bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
	    (xa->flags & ATA_F_READ) ? BUS_DMASYNC_PREREAD :
	    BUS_DMASYNC_PREWRITE);

	return (0);
}

void
sili_unload(struct sili_ccb *ccb)
{
	struct sili_port		*sp = ccb->ccb_port;
	struct sili_softc		*sc = sp->sp_sc;
	struct ata_xfer			*xa = &ccb->ccb_xa;
	bus_dmamap_t			dmap = ccb->ccb_dmamap;

	if (xa->datalen == 0)
		return;

	bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
	    (xa->flags & ATA_F_READ) ? BUS_DMASYNC_POSTREAD :
	    BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, dmap);

	if (xa->flags & ATA_F_READ)
		xa->resid = xa->datalen - sili_pread(sp,
		    SILI_PREG_RX_COUNT(xa->tag));
	else
		xa->resid = 0;
}

int
sili_poll(struct sili_ccb *ccb, int timeout, void (*timeout_fn)(void *))
{
	struct sili_port		*sp = ccb->ccb_port;
	int				s;

	s = splbio();
	sili_start(sp, ccb);
	do {
		if (sili_port_intr(sp, -1) & (1 << ccb->ccb_xa.tag)) {
			splx(s);
			return (ccb->ccb_xa.state != ATA_S_COMPLETE);
		}

		delay(1000);
	} while (--timeout > 0);

	/* Run timeout while at splbio, otherwise sili_intr could interfere. */
	if (timeout_fn != NULL)
		timeout_fn(ccb);

	splx(s);

	return (1);
}

void
sili_start(struct sili_port *sp, struct sili_ccb *ccb)
{
	int				slot = ccb->ccb_xa.tag;

	splassert(IPL_BIO);
	KASSERT(ccb->ccb_xa.state == ATA_S_PENDING);
	KASSERT(sp->sp_pmp_error_recovery == 0);

	TAILQ_INSERT_TAIL(&sp->sp_active_ccbs, ccb, ccb_entry);
	sp->sp_active |= 1 << slot;
	ccb->ccb_xa.state = ATA_S_ONCHIP;

	sili_post_indirect(sp, ccb);
}

int
sili_read_ncq_error(struct sili_port *sp, int *err_slotp, int pmp_port)
{
	struct sili_softc		*sc = sp->sp_sc;
	struct sili_prb_ata		read_10h;
	u_int64_t			addr;
	struct ata_fis_h2d		*fis;
	struct ata_log_page_10h		*log;
	struct sili_ccb			*ccb;
	int				rc;

	sili_pwrite(sp, SILI_PREG_PCS, SILI_PREG_PCS_PORTINIT);
	if (!sili_pwait_eq(sp, SILI_PREG_PCS, SILI_PREG_PCS_PORTRDY,
	    SILI_PREG_PCS_PORTRDY, 1000)) {
		printf("%s: couldn't ready port during log page read\n",
		    PORTNAME(sp));
		return (1);
	}

	/* READ LOG EXT 10h into scratch space */
	bzero(&read_10h, sizeof(read_10h));
	read_10h.control = htole16(SILI_PRB_INTERRUPT_MASK);

	addr = SILI_DMA_DVA(sp->sp_scratch);
	read_10h.sgl[0].addr_lo = htole32((u_int32_t)addr);
	read_10h.sgl[0].addr_hi = htole32((u_int32_t)(addr >> 32));
	read_10h.sgl[0].data_count = htole32(512);
	read_10h.sgl[0].flags = htole32(SILI_SGE_TRM);

	fis = (struct ata_fis_h2d *)read_10h.fis;
	fis->type = ATA_FIS_TYPE_H2D;
	fis->flags = ATA_H2D_FLAGS_CMD | pmp_port;
	fis->command = ATA_C_READ_LOG_EXT;
	fis->lba_low = 0x10;		/* queued error log page (10h) */
	fis->sector_count = 1;		/* number of sectors (1) */
	fis->sector_count_exp = 0;
	fis->lba_mid = 0;		/* starting offset */
	fis->lba_mid_exp = 0;
	fis->device = 0;

	bus_dmamap_sync(sc->sc_dmat, SILI_DMA_MAP(sp->sp_scratch), 0,
	    512, BUS_DMASYNC_PREREAD);

	/* issue read and poll for completion */
	sili_post_direct(sp, 0, &read_10h, sizeof(read_10h));
	rc = sili_pwait_eq(sp, SILI_PREG_PSS, (1 << 0), 0, 1000);

	bus_dmamap_sync(sc->sc_dmat, SILI_DMA_MAP(sp->sp_scratch), 0,
	    512, BUS_DMASYNC_POSTREAD);

	if (!rc) {
		DPRINTF(SILI_D_VERBOSE, "%s: timed out while waiting for log "
		    "page read\n", PORTNAME(sp));
		return (1);
	}

	/* Extract failed register set and tags from the scratch space. */
	log = (struct ata_log_page_10h *)SILI_DMA_KVA(sp->sp_scratch);
	if (ISSET(log->err_regs.type, ATA_LOG_10H_TYPE_NOTQUEUED)) {
		/* Not queued bit was set - wasn't an NCQ error? */
		printf("%s: read NCQ error page, but not an NCQ error?\n",
		    PORTNAME(sp));
		return (1);
	}

	/* Copy back the log record as a D2H register FIS. */
	*err_slotp = log->err_regs.type & ATA_LOG_10H_TYPE_TAG_MASK;

	ccb = &sp->sp_ccbs[*err_slotp];
	memcpy(&ccb->ccb_xa.rfis, &log->err_regs, sizeof(struct ata_fis_d2h));
	ccb->ccb_xa.rfis.type = ATA_FIS_TYPE_D2H;
	ccb->ccb_xa.rfis.flags = 0;

	return (0);
}

struct ata_xfer *
sili_ata_get_xfer(void *xsc, int port)
{
	struct sili_softc		*sc = xsc;
	struct sili_port		*sp = &sc->sc_ports[port];
	struct sili_ccb			*ccb;

	ccb = sili_get_ccb(sp);
	if (ccb == NULL) {
		printf("%s: sili_ata_get_xfer NULL ccb!\n", PORTNAME(sp));
		return (NULL);
	}

	bzero(ccb->ccb_cmd, SILI_CMD_LEN);

	return ((struct ata_xfer *)ccb);
}

void
sili_ata_put_xfer(struct ata_xfer *xa)
{
	struct sili_ccb			*ccb = (struct sili_ccb *)xa;

	sili_put_ccb(ccb);
}

/* PMP register ops */
int
sili_pmp_read(struct sili_port *sp, int target, int which, u_int32_t *datap)
{
	struct sili_ccb	*ccb;
	struct sili_prb	*prb;
	struct ata_fis_h2d *fis;
	int error;

	ccb = sili_get_ccb(sp);
	if (ccb == NULL) {
		printf("%s: sili_pmp_read NULL ccb!\n", PORTNAME(sp));
		return (1);
	}
	ccb->ccb_xa.flags = ATA_F_POLL | ATA_F_GET_RFIS;
	ccb->ccb_xa.complete = sili_dummy_done;
	ccb->ccb_xa.pmp_port = SATA_PMP_CONTROL_PORT;
	ccb->ccb_xa.state = ATA_S_PENDING;
	
	prb = ccb->ccb_cmd;
	bzero(prb, sizeof(*prb));
	fis = (struct ata_fis_h2d *)&prb->fis;
	fis->type = ATA_FIS_TYPE_H2D;
	fis->flags = ATA_H2D_FLAGS_CMD | SATA_PMP_CONTROL_PORT;
	fis->command = ATA_C_READ_PM;
	fis->features = which;
	fis->device = target | ATA_H2D_DEVICE_LBA;
	fis->control = ATA_FIS_CONTROL_4BIT;

	if (sili_poll(ccb, 1000, sili_pmp_op_timeout) != 0) {
		printf("sili_pmp_read(%d, %d) failed\n", target, which);
		error = 1;
	} else {
		*datap = ccb->ccb_xa.rfis.sector_count |
		    (ccb->ccb_xa.rfis.lba_low << 8) |
		    (ccb->ccb_xa.rfis.lba_mid << 16) |
		    (ccb->ccb_xa.rfis.lba_high << 24);
		error = 0;
	}
	sili_put_ccb(ccb);
	return (error);
}

int
sili_pmp_write(struct sili_port *sp, int target, int which, u_int32_t data)
{
	struct sili_ccb	*ccb;
	struct sili_prb	*prb;
	struct ata_fis_h2d *fis;
	int error;

	ccb = sili_get_ccb(sp);
	if (ccb == NULL) {
		printf("%s: sili_pmp_write NULL ccb!\n", PORTNAME(sp));
		return (1);
	}
	ccb->ccb_xa.complete = sili_dummy_done;
	ccb->ccb_xa.flags = ATA_F_POLL;
	ccb->ccb_xa.pmp_port = SATA_PMP_CONTROL_PORT;
	ccb->ccb_xa.state = ATA_S_PENDING;

	prb = ccb->ccb_cmd;
	bzero(prb, sizeof(*prb));
	fis = (struct ata_fis_h2d *)&prb->fis;
	fis->type = ATA_FIS_TYPE_H2D;
	fis->flags = ATA_H2D_FLAGS_CMD | SATA_PMP_CONTROL_PORT;
	fis->command = ATA_C_WRITE_PM;
	fis->features = which;
	fis->device = target | ATA_H2D_DEVICE_LBA;
	fis->sector_count = (u_int8_t)data;
	fis->lba_low = (u_int8_t)(data >> 8);
	fis->lba_mid = (u_int8_t)(data >> 16);
	fis->lba_high = (u_int8_t)(data >> 24);
	fis->control = ATA_FIS_CONTROL_4BIT;

	error = sili_poll(ccb, 1000, sili_pmp_op_timeout);
	sili_put_ccb(ccb);
	return (error);
}

int
sili_pmp_phy_status(struct sili_port *sp, int target, u_int32_t *datap)
{
	int error;

	error = sili_pmp_read(sp, target, SATA_PMREG_SSTS, datap);
	if (error == 0)
		error = sili_pmp_write(sp, target, SATA_PMREG_SERR, -1);
	if (error)
		*datap = 0;

	return (error);
}

int
sili_pmp_identify(struct sili_port *sp, int *ret_nports)
{
	u_int32_t chipid;
	u_int32_t rev;
	u_int32_t nports;
	u_int32_t features;
	u_int32_t enabled;

	if (sili_pmp_read(sp, 15, 0, &chipid) ||
	    sili_pmp_read(sp, 15, 1, &rev) ||
	    sili_pmp_read(sp, 15, 2, &nports) ||
	    sili_pmp_read(sp, 15, SATA_PMREG_FEA, &features) ||
	    sili_pmp_read(sp, 15, SATA_PMREG_FEAEN, &enabled)) {
		printf("%s: port multiplier identification failed\n",
		    PORTNAME(sp));
		return (1);
	}

	nports &= 0x0F;

	/* ignore SEMB port on SiI3726 port multiplier chips */
	if (chipid == 0x37261095) {
		nports--;
	}

	printf("%s: port multiplier found: chip=%08x rev=0x%b nports=%d, "
	    "features: 0x%b, enabled: 0x%b\n", PORTNAME(sp), chipid, rev,
	    SATA_PFMT_PM_REV, nports, features, SATA_PFMT_PM_FEA, enabled,
	    SATA_PFMT_PM_FEA);

	*ret_nports = nports;
	return (0);
}
@


1.57
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.56 2015/03/14 03:38:47 jsg Exp $ */
d380 1
a380 1
			if ((arc4random() % sili_error_test_inv_p) == 0) {
@


1.56
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.55 2014/11/18 02:37:30 tedu Exp $ */
d770 1
a770 1
	free(sp, M_DEVBUF, 0);
d789 1
a789 1
	free(sc->sc_ports, M_DEVBUF, 0);
d941 1
a941 1
	free(sdm, M_DEVBUF, 0);
d953 1
a953 1
	free(sdm, M_DEVBUF, 0);
@


1.55
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.54 2014/09/14 14:17:25 jsg Exp $ */
a22 1
#include <sys/buf.h>
@


1.54
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.53 2014/07/13 23:10:23 deraadt Exp $ */
a56 4

#ifdef SILI_ERROR_TEST
#include <dev/rndvar.h>
#endif
@


1.53
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.52 2014/07/12 18:48:17 tedu Exp $ */
d25 1
a25 1
#include <sys/proc.h>
@


1.52
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.51 2012/02/04 21:44:54 krw Exp $ */
d751 1
a751 1
	sc->sc_ports = malloc(sizeof(struct sili_port) * sc->sc_nports,
d811 1
a811 1
	sp->sp_ccbs = malloc(sizeof(struct sili_ccb) * SILI_MAX_CMDS,
@


1.51
log
@Close races where timer is started on a command and then an splbio()
is called before the command is started. This might have resulted
in the timeout firing and invalidating the command before it is
started. Move the timeout_add_* inside the relevant splbio()/splx().

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.50 2012/02/04 17:52:22 krw Exp $ */
d775 1
a775 1
	free(sp, M_DEVBUF);
d794 1
a794 1
	free(sc->sc_ports, M_DEVBUF);
d862 1
a862 1
	free(sp->sp_ccbs, M_DEVBUF);
d946 1
a946 1
	free(sdm, M_DEVBUF);
d958 1
a958 1
	free(sdm, M_DEVBUF);
@


1.50
log
@Since sili_get_ccb() can return NULL if there are no ccb's available,
check for the result in sili_pmp_softreset() as is done for all other
invocations of sili_get_ccb().  While here disambiguate the printf's
being emitted when sili_get_ccb() returns NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.49 2011/07/04 04:44:50 dhill Exp $ */
d1463 1
a1464 1
		s = splbio();
@


1.49
log
@remove unneeded cast.
no binary change.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.48 2011/05/08 19:46:10 matthew Exp $ */
d871 2
a872 1
	/* don't allow new commands to start while doing PMP error
d1208 5
d1743 1
d1771 1
a1771 1
		printf("%s: NULL ccb!\n", PORTNAME(sp));
d1813 1
a1813 1
		printf("%s: NULL ccb!\n", PORTNAME(sp));
@


1.48
log
@Move ata_put_xfer() from ata_xfer to atascsi_methods.  It's just silly
to have a non-changing function pointer be part of an object rather
than it's virtual method table.

ok dlg@@; tested on ahci(4) by Mattieu Baptiste, jasper@@, and Jason
Crawford; no sili(4) testers, but identical changes to ahci(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.47 2011/01/26 21:41:00 drahn Exp $ */
d75 1
a75 1
#define SILI_DMA_KVA(_sdm)	((void *)(_sdm)->sdm_kva)
@


1.47
log
@Add port multiplier support, has been in snaps for a while with no reported
issues. No actual OKs, but general acknowledgement and 'get it in' from several.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.46 2010/08/05 20:21:36 kettenis Exp $ */
d214 1
a836 1
		ccb->ccb_xa.ata_put_xfer = sili_ata_put_xfer;
@


1.46
log
@Suspend/resume support for sili(4).  Not perfect yet, but prevents us from
getting stuck.  Based on an initial diff from deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.45 2010/05/19 15:27:35 oga Exp $ */
d5 2
d33 1
d52 10
d103 7
d173 1
d178 14
a191 1
int			sili_read_ncq_error(struct sili_port *, int *);
d197 2
a198 2
int			sili_ata_probe(void *, int);
void			sili_ata_free(void *, int);
d202 7
d220 3
d246 1
a246 1
	aaa.aaa_capability = ASAA_CAP_NCQ;
d273 1
a273 1
	int i;
d279 62
a340 2
	for (i = 0; i < sc->sc_nports; i++)
		sili_ata_probe(sc, i);
d343 63
d411 1
d444 1
a447 4
			/* No NCQ commands active?  Treat as a normal error. */
			sactive = sili_pread(sp, SILI_PREG_SACT);/* XXX Pmult */
			if (sactive == 0)
				break;
d449 30
a478 2
			/* Extract real NCQ error slot & RFIS from log page. */
			if (!sili_read_ncq_error(sp, &err_slot)) {
d480 2
d485 2
d493 6
a498 1
			printf("%s: fatal error (%d), aborting active slots "
d500 1
a500 1
			    err_code, pss_saved);
d513 3
a515 3
		DPRINTF(SILI_D_VERBOSE, "%s: %serror, code %d, slot %d, "
		    "active %08x\n", PORTNAME(sp), sactive ? "NCQ " : "",
		    err_code, err_slot, sp->sp_active);
d519 2
d541 7
a547 2
		/* Reset device to abort all commands (including this one). */
		need_restart = SILI_PREG_PCS_DEVRESET;
d557 12
a568 1
		DPRINTF(SILI_D_INTR, "%s: slot %d is complete%s\n",
d571 2
a572 1
		    " (timeout)" : ""));
d577 2
d582 30
d614 4
d623 1
d625 4
a628 2
		/* Restart CCBs in the order they were originally queued. */
		pss_masked = pss_saved;
a629 3
			DPRINTF(SILI_D_VERBOSE, "%s: restarting slot %d "
			    "after error, state %02x\n", PORTNAME(sp),
			    ccb->ccb_xa.tag, ccb->ccb_xa.state);
d637 37
d675 19
d697 3
a699 2
		KASSERT(pss_masked == 0);

d708 3
d757 1
d871 7
d1081 113
d1195 1
a1195 1
sili_ata_probe(void *xsc, int port)
d1197 41
a1237 5
	struct sili_softc		*sc = xsc;
	struct sili_port		*sp = &sc->sc_ports[port];
	struct sili_prb_softreset	sreset;
	u_int32_t			signature;
	int				port_type;
d1239 6
a1244 2
	sili_pwrite(sp, SILI_PREG_PCC, SILI_PREG_PCC_PORTRESET);
	sili_pwrite(sp, SILI_PREG_PCC, SILI_PREG_PCC_A32B);
d1246 9
a1254 2
	if (!sili_pwait_eq(sp, SILI_PREG_SSTS, SATA_SStatus_DET,
	    SATA_SStatus_DET_DEV, 1000))
d1256 2
d1259 5
a1263 2
	DPRINTF(SILI_D_VERBOSE, "%s: SSTS 0x%08x\n", PORTNAME(sp),
	    sili_pread(sp, SILI_PREG_SSTS));
d1267 1
a1267 1
	/* XXX sreset fis pmp field */
d1285 1
a1285 2
		port_type = ATA_PORT_T_DISK;
		break;
d1287 1
a1287 2
		port_type = ATA_PORT_T_ATAPI;
		break;
d1289 1
d1293 75
d1373 16
d1398 1
a1398 1
sili_ata_free(void *xsc, int port)
d1403 3
a1405 2
	if (sp->sp_ccbs != NULL)
		sili_ccb_free(sp);
d1407 2
a1408 1
	/* XXX we should do more here */
d1423 1
a1423 1
	KASSERT(xa->state == ATA_S_SETUP);
d1490 5
d1621 1
a1621 1
			return (0);
d1643 1
d1653 1
a1653 1
sili_read_ncq_error(struct sili_port *sp, int *err_slotp)
d1683 1
a1683 1
	fis->flags = ATA_H2D_FLAGS_CMD;	/* XXX fis pmp field */
a1736 1
		printf("sili_ata_get_xfer: NULL ccb\n");
d1751 129
@


1.45
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.44 2009/12/07 09:37:33 dlg Exp $ */
d224 13
@


1.44
log
@get rid of the return codes from command submission, ata_cmd handlers
now return void. all state about a command is now represented within
the ata_xfer structure, and all layers using it (both hba and
atascsi) now check only ata_xfer.

this relies on my scsi midlayer changes. it was written just before
the second last backout of the midlayer.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.42 2009/02/16 21:19:07 miod Exp $ */
d587 1
a587 1
	    1, &nsegs, BUS_DMA_NOWAIT) != 0)
a596 2

	bzero(sdm->sdm_kva, size);
@


1.43
log
@%zu is not meant for size_t in the kernel. Change to %lu.

OK miod
@
text
@d167 1
a167 1
int			sili_ata_cmd(struct ata_xfer *);
d384 1
a384 1
			ccb->ccb_xa.complete(&ccb->ccb_xa);
d818 1
a818 1
int
d861 1
a861 1
	if (xa->flags & ATA_F_POLL) {
d863 5
a867 1
		return (ATA_COMPLETE);
d870 1
a870 6
	timeout_add_msec(&xa->stimeout, xa->timeout);

	s = splbio();
	sili_start(sp, ccb);
	splx(s);
	return (ATA_QUEUED);
d875 1
a875 1
	xa->complete(xa);
a876 1
	return (ATA_ERROR);
d908 1
a908 1
		xa->complete(xa);
@


1.42
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.41 2009/01/21 21:54:00 grange Exp $ */
d701 1
a701 1
		panic("sili_pcopy: buflen of %zu is not 64 or 128", buflen);
@


1.41
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.40 2008/11/23 12:46:51 dlg Exp $ */
d199 1
a199 1
	aaa.aaa_minphys = minphys;
@


1.40
log
@sizeofa -> nitems
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.39 2007/11/28 13:47:09 dlg Exp $ */
d866 1
a866 1
	timeout_add(&xa->stimeout, (xa->timeout * hz) / 1000);
@


1.39
log
@make ata controllers protect their own command lists so atascsi doesnt have
to continually go to splbio to ensure its safe to work on them. shrinks
code a little.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.38 2007/11/26 15:59:53 dlg Exp $ */
d841 1
a841 1
		sgllen = sizeofa(atapi->sgl);
d848 1
a848 1
		sgllen = sizeofa(ata->sgl);
@


1.38
log
@drive port probes from the scsi midlayer now that it will ask the adapter
if a device is there before doing any scsi commands. also implement a free
path for when devices are detached. software hotplug has been tested on
sili, and ahci is still working according to claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.37 2007/11/23 18:26:03 kettenis Exp $ */
d26 1
d84 1
d475 1
d540 1
d547 1
d568 1
d570 1
@


1.37
log
@If the card has gone away, return imediately from the interrupt handler.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.36 2007/11/23 18:21:55 dlg Exp $ */
d162 1
d169 1
d797 12
@


1.36
log
@starting bits to implement hotplug of sili controllers. this adds the code
to clean up the atascsi stuff, and has sili call it when its going away.

tested on an expresscard sili variant by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.35 2007/10/09 05:43:37 ray Exp $ */
d394 1
d396 1
a396 1
	if (is == 0)
@


1.35
log
@Use %zu for printing size_t values.

OK dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.34 2007/10/01 04:03:51 krw Exp $ */
d208 11
@


1.34
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.33 2007/04/22 00:06:51 dlg Exp $ */
d680 1
a680 1
		panic("sili_pcopy: buflen of %d is not 64 or 128", buflen);
@


1.33
log
@disable debug output here too. it's working fine (even on strange archs)
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.32 2007/04/12 04:40:59 pascoe Exp $ */
d405 1
a405 2
	    M_DEVBUF, M_WAITOK);
	bzero(sc->sc_ports, sizeof(struct sili_port) * sc->sc_nports);
d558 1
a558 2
	sdm = malloc(sizeof(struct sili_dmamem), M_DEVBUF, M_WAITOK);
	bzero(sdm, sizeof(struct sili_dmamem));
@


1.32
log
@Oops, a code rearrangement meant that I didn't initialise the failed ccb
pointer for problematic non-NCQ commands.

spotted by and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.31 2007/04/10 09:08:19 dlg Exp $ */
d34 2
a35 1
#define SILI_DEBUG
@


1.31
log
@wrap reading of the error fis up into a func of its own, and use
bus_space_read_raw_region_4 to do it. more archs are happy with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.29 2007/04/08 06:51:25 pascoe Exp $ */
d240 1
d256 3
a258 1
			if (!sili_read_ncq_error(sp, &err_slot))
d260 1
a288 1
		ccb = &sp->sp_ccbs[err_slot];
@


1.30
log
@Change the API to sili_port_intr so it can timeout a command and reuse the
existing reset/requeue infrastructure, and implement command timeouts.

sili_port_intr now always processes all pending CCBs, so switch to use the
auto-clearing interrupt status reads.
@
text
@d147 2
a235 1
		bus_size_t		r;
d245 1
a245 7
			r = SILI_PREG_SLOT(err_slot) + 8;
			bus_space_barrier(sp->sp_sc->sc_iot_port, sp->sp_ioh,
			    r, sizeof(struct ata_fis_d2h),
			    BUS_SPACE_BARRIER_READ);
			bus_space_read_region_1(sp->sp_sc->sc_iot_port,
			    sp->sp_ioh, r, &ccb->ccb_xa.rfis,
			    sizeof(struct ata_fis_d2h));
d687 11
@


1.29
log
@Add support for NCQ error recovery and enable NCQ command submission.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.28 2007/04/08 04:45:40 pascoe Exp $ */
d155 1
a155 1
u_int32_t		sili_port_intr(struct sili_port *, u_int32_t);
d209 1
a209 1
sili_port_intr(struct sili_port *sp, u_int32_t slotmask)
d217 1
a217 5
	pss_saved = sili_pread(sp, SILI_PREG_PSS);

	/* Ack port interrupt only if checking all command slots. */
	if (slotmask == SILI_PREG_PSS_ALL_SLOTS)
		sili_pwrite(sp, SILI_PREG_IS, is);
d236 1
d298 16
d323 2
a324 1
		    " (error)" : "");
d368 2
a369 1
			    ccb->ccb_xa.state == ATA_S_ERROR);
d392 1
a392 1
		sili_port_intr(&sc->sc_ports[port], SILI_PREG_PSS_ALL_SLOTS);
a726 1
	sili_pwrite(sp, SILI_PREG_PCS, SILI_PREG_PCS_NOINTCLR);
d870 5
d881 2
d884 3
a886 1
	printf("%s: ccb %p timed out\n", PORTNAME(ccb->ccb_port), ccb);
d982 1
a982 2
		if (ISSET(sili_port_intr(sp, SILI_PREG_PSS_ALL_SLOTS),
		    1 << ccb->ccb_xa.tag)) {
@


1.28
log
@Track the order that CCBs are submitted in, so that after an error we are
sure to reissue commands in the correct order.  Defer completion of commands
when we an error has occurred so that new commands don't go active before
queeud ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.27 2007/04/08 00:47:50 pascoe Exp $ */
d70 3
d79 1
d152 1
d195 1
d212 2
a213 2
	u_int32_t			processed = 0;
	int				slot, need_restart = 0;
d236 2
a237 1
		int			err_slot;
a239 1
		/* XXX Non-NCQ error path. */
d241 1
d243 1
a243 7
		ccb = &sp->sp_ccbs[err_slot];

		DPRINTF(SILI_D_VERBOSE, "%s: error, code %d, slot %d, "
		    "active %08x\n", PORTNAME(sp), sili_pread(sp, SILI_PREG_CE),
		    err_slot, sp->sp_active);

		switch (sili_pread(sp, SILI_PREG_CE)) {
d255 1
d257 12
a268 4
			/* An NCQ error? */
			if (1 /* no_ncq_commands_outstanding */)
				need_restart = 1;
			break;
d270 14
a283 2
			printf("%s: fatal error\n", PORTNAME(sp));
			break;
d286 4
d293 1
d297 1
a297 1
		need_restart = 1;
d299 1
d319 1
a319 1
		sili_pwrite(sp, SILI_PREG_PCS, SILI_PREG_PCS_PORTINIT);
d359 1
a359 1
	return processed;
d455 3
d469 1
a469 1
			goto free_cmds;
d483 2
d990 76
@


1.27
log
@sili uses one queue for NCQ and legacy commands.  No need for the AHCI-style
indirection when determining which commands are complete.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.26 2007/04/07 15:58:26 pascoe Exp $ */
d80 2
d165 1
a165 1
void			sili_ata_cmd_done(struct sili_ccb *);
d238 3
a240 2
		DPRINTF(SILI_D_VERBOSE, "%s: error, code %d, slot %d\n",
		    PORTNAME(sp), sili_pread(sp, SILI_PREG_CE), err_slot);
a244 1
			need_restart = 1;
d264 1
a264 1
		/* Clear the failed commmand in saved PSS so completion runs. */
d269 2
d284 1
a284 2
		sp->sp_active &= ~(1 << slot);
		sili_ata_cmd_done(ccb);
a288 1
	/* Restart port and reissue outstanding commands. */
d290 1
d298 13
a310 4
		while (pss_saved) {
			slot = ffs(pss_saved) - 1;
			ccb = &sp->sp_ccbs[slot];
			pss_saved &= ~(1 << slot);
a311 2
			DPRINTF(SILI_D_VERBOSE, "%s: restarting slot %d "
			    "after error\n", PORTNAME(sp), slot);
d315 14
d418 2
a648 1
	ccb->ccb_xa.state = ATA_S_ONCHIP;
d794 1
a794 1
sili_ata_cmd_done(struct sili_ccb *ccb)
d809 3
d819 3
a821 1
	if (xa->state != ATA_S_TIMEOUT)
d952 1
d954 2
@


1.26
log
@Always assume write commands had zero residual; the chip only counts
received bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.25 2007/04/07 15:44:22 pascoe Exp $ */
a204 1
	volatile u_int32_t		*active = &sp->sp_active;
d216 1
a216 1
	if ((pss_saved & SILI_PREG_PSS_ALL_SLOTS) != *active ||
d220 1
a220 1
			pss_saved, *active);
d270 1
a270 1
	pss_masked = ~pss_saved & *active;
d280 1
a280 1
		*active &= ~(1 << slot);
@


1.25
log
@Whitespace cleanup.  No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.24 2007/04/07 14:46:34 pascoe Exp $ */
d881 5
a885 1
	xa->resid = xa->datalen - sili_pread(sp, SILI_PREG_RX_COUNT(xa->tag));
@


1.24
log
@Add transfer failure detection and recovery from non-fatal errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.23 2007/04/07 14:38:47 pascoe Exp $ */
d58 3
a60 3
#define SILI_DMA_MAP(_sdm)      ((_sdm)->sdm_map)
#define SILI_DMA_DVA(_sdm)      ((_sdm)->sdm_map->dm_segs[0].ds_addr)
#define SILI_DMA_KVA(_sdm)      ((void *)(_sdm)->sdm_kva)
d123 1
a123 1
struct sili_ccb 	*sili_get_ccb(struct sili_port *);
d245 2
a246 2
	 		r = SILI_PREG_SLOT(err_slot) + 8;
			bus_space_barrier(sp->sp_sc->sc_iot_port, sp->sp_ioh, 
d350 1
a350 1
#endif		
d574 1
a574 1
sili_pwait_eq(struct sili_port *sp, bus_size_t r, u_int32_t mask, 
d589 1
a589 1
sili_pwait_ne(struct sili_port *sp, bus_size_t r, u_int32_t mask, 
@


1.23
log
@Rework command issue/completion flow to be more like AHCI's and switch to
using interrupts to detect command completion.

Report on command timeouts (but no recovery yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.22 2007/04/07 14:15:14 pascoe Exp $ */
d206 1
a206 1
	int				slot;
d228 42
d285 21
@


1.22
log
@Split command completion out into a separate function, working towards
IRQ based completion.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.21 2007/04/07 13:37:24 pascoe Exp $ */
d38 1
d79 2
d144 5
d164 1
d200 48
a250 1
#if 0
d252 14
a265 1
#endif
d267 1
a267 1
	return (0);
d592 1
d635 5
d670 1
a670 1
		ata->control = htole16(SILI_PRB_INTERRUPT_MASK);
d682 2
d686 7
a692 3
#if 0
	sili_post_direct(sp, 0, &ccb->ccb_prb, sizeof(ccb->ccb_prb));
#endif
d694 1
a694 2
	sili_post_indirect(sp, ccb);
	sili_ata_cmd_done(ccb);
d696 1
a696 2

	return (ATA_COMPLETE);
d715 1
a715 5
	if (!sili_pwait_eq(sp, SILI_PREG_PSS, (1 << ccb->ccb_xa.tag), 0,
	    ccb->ccb_xa.timeout)) {
		printf("%s: cmd failed\n", PORTNAME(sp));
		xa->state = ATA_S_ERROR;
	}
d724 8
d733 6
a738 1
	xa->complete(xa);
d819 39
@


1.21
log
@Permit PACKET command issue.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.20 2007/04/07 13:23:30 pascoe Exp $ */
d154 3
d492 1
d580 2
d601 3
a603 4
	if (sili_load(ccb, sgl, sgllen) != 0) {
		xa->state = ATA_S_ERROR;
		return (ATA_ERROR);
	}
d607 2
d612 1
d614 22
a639 1
		return (ATA_ERROR);
d647 2
a648 1
	xa->state = ATA_S_COMPLETE;
a649 1
	s = splbio();
a650 3
	splx(s);

	return (ATA_COMPLETE);
@


1.20
log
@Fill out control information for ATAPI commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.19 2007/04/07 13:15:03 pascoe Exp $ */
d534 2
a535 1
		/* DPRINTF timeout waiting for soft reset */
a585 3

		xa->state = ATA_S_ERROR;
		return (ATA_ERROR);
@


1.19
log
@Helper macros to provide the port name in debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.18 2007/04/07 13:05:18 pascoe Exp $ */
d577 5
@


1.18
log
@Use the rx_count saved in the LRAM command slot entry to determine the
xfer residual.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.17 2007/04/07 10:07:12 pascoe Exp $ */
d77 7
d212 4
d337 1
a337 1
		    "slot %d\n", DEVNAME(sp->sp_sc), ccb->ccb_xa.state,
d524 1
a524 1
	DPRINTF(SILI_D_VERBOSE, "%s.%d: SSTS 0x%08x\n", DEVNAME(sc), port,
d541 1
a541 1
	DPRINTF(SILI_D_VERBOSE, "%s.%d: signature 0x%08x\n", DEVNAME(sc), port,
d605 1
a605 1
		printf("%s: cmd failed\n", DEVNAME(sp->sp_sc));
d642 1
a642 1
		printf("%s: error %d loading dmamap\n", DEVNAME(sc), error);
@


1.17
log
@Sync the command corresponding to our ccb, not slot 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.16 2007/04/07 09:24:12 pascoe Exp $ */
d690 1
a690 1
	xa->resid = 0;
@


1.16
log
@Add infrastructure to handle more than one ccb.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.15 2007/04/07 06:10:09 dlg Exp $ */
d586 1
a586 1
            0, SILI_CMD_LEN, BUS_DMASYNC_PREWRITE);
d600 1
a600 1
            0, SILI_CMD_LEN, BUS_DMASYNC_POSTWRITE);
@


1.15
log
@this diff covers two changes, but theyre very tightly tied together.

implement long sgls by allocating 512 bytes per command, which gives us 7
scatter gather tables to fill in per command. we can now do proper sized
io. commands are still polled though, so its very very slow ;)

since you cant submit more than 128 bytes using direct command submission,
we needed to implement indirect submission too.

this almost worked, but i gave the controller to pascoe before i got it
working. he did the fixes to my dumb dumb mistakes. thanks pascoe. thascoe.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.14 2007/04/06 04:50:27 dlg Exp $ */
d75 2
d107 2
d113 2
d168 1
a168 1
	aaa.aaa_ncmds = 1 /* XXX SILI_MAX_CMDS */;
d245 2
d248 1
a248 1
	/* XXX this should allocate multiple ccbs */
d250 3
a252 2
	sp->sp_ccbs = malloc(sizeof(struct sili_ccb), M_DEVBUF, M_WAITOK);
	sp->sp_cmds = sili_dmamem_alloc(sc, SILI_CMD_LEN /* * SILI_MAX_CMDS */,
d257 21
a277 9
	ccb = sp->sp_ccbs;
	bzero(ccb, sizeof(struct sili_ccb));
	ccb->ccb_port = sp;
	ccb->ccb_cmd = SILI_DMA_KVA(sp->sp_cmds);
	ccb->ccb_cmd_dva = SILI_DMA_DVA(sp->sp_cmds);
	if (bus_dmamap_create(sc->sc_dmat, MAXPHYS, SILI_DMA_SEGS,
	    MAXPHYS, 0, BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW,
	    &sp->sp_ccbs->ccb_dmamap) != 0)
		goto free_cmds;
d284 1
a284 1
	free(sp->sp_ccbs, M_DEVBUF);
d294 2
a295 2
	ccb = sp->sp_ccbs;
	bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);
d301 34
d570 1
d581 2
a582 1
	if (sili_load(ccb, sgl, sgllen) != 0)
d584 1
d592 2
a593 1
	if (!sili_pwait_eq(sp, SILI_PREG_PSS, (1 << 0), 0, 1000)) {
d595 1
d698 7
a704 3
	struct sili_ccb			*ccb = sp->sp_ccbs;
	struct sili_prb			*prb = ccb->ccb_cmd;
	struct ata_xfer			*xa;
d708 1
a708 5
	xa = &ccb->ccb_xa;
	xa->fis = (struct ata_fis_h2d *)&prb->fis;
	xa->ata_put_xfer = sili_ata_put_xfer;

	return (xa);
d714 3
a716 1
	/* this does nothing (yet) */
@


1.14
log
@white space fix
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.13 2007/04/06 04:48:54 dlg Exp $ */
d74 1
d81 16
d100 2
a101 1
	struct sili_prb_ata	ccb_prb;
d123 2
d126 1
a126 1
int			sili_load(struct sili_ccb *);
d243 4
d249 1
d251 3
a253 1
	if (bus_dmamap_create(sc->sc_dmat, MAXPHYS, 2 /* XXX */,
d256 1
a256 1
		goto free_ccbs;
d260 2
d420 9
d452 1
a452 1
	sili_pwrite(sp, SILI_PREG_PCS, SILI_PREG_PCS_A32B);
d502 5
d509 5
a513 1
	ccb->ccb_prb.control = htole16(SILI_PRB_INTERRUPT_MASK);
a514 1
	if (sili_load(ccb) != 0)
d516 2
d519 12
d532 2
d539 3
d554 1
a554 1
sili_load(struct sili_ccb *ccb)
d559 1
a559 1
	struct sili_sge			*sge;
d575 3
d579 17
a595 1
		sge = &ccb->ccb_prb.sgl[i];
d598 6
a603 3
		sge->addr_lo = htole32((u_int32_t)addr);
		sge->addr_hi = htole32((u_int32_t)(addr >> 32));
		sge->data_count = htole32(dmap->dm_segs[i].ds_len);
d605 1
a605 1
	sge->flags |= htole32(SILI_SGE_TRM);
d639 1
d642 1
a642 1
	bzero(&ccb->ccb_prb, sizeof(struct sili_prb_ata));
d645 1
a645 1
	xa->fis = (struct ata_fis_h2d *)&ccb->ccb_prb.fis;
@


1.13
log
@copy the dmamem wrapper into sili for use for allocating hba memory. this
has journeyed from ami into mpi, mfi, arc, vic, ahci, and now sili so far.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.12 2007/04/05 14:09:36 dlg Exp $ */
d434 1
a434 1
        /* Read device signature from command slot. */
@


1.12
log
@this is a relatively big commit that implements a basic io path.

it does this:
- limits the ncmds advertised to atascsi to 1 (cos that lets us write dumb
  but working code)
- the port probe translates device signatures to device types now
- defines a basic ccb structure
- the port probe allocates a ccb if it decides that the port is going to
  be used
- takes an io from atascsi, fills in the prb, does a direct command
  submission and then polls for completion (all without generating
  interrupts, its kinda cool)
- limits the sgl to only two elements, which sucks, but it lets us get the
  inquiry and disk attach done. note, the sgl structures are like a smaller
  version of mpis sgl chains, but with a better layout. sgl chains suck
  btw.
- frees the ccb when the port is freed.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.11 2007/04/05 10:45:25 dlg Exp $ */
d50 16
d249 52
@


1.11
log
@finish resetting the device by sending a soft reset via the post_direct
mechanism, and then read the device signature.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.10 2007/04/05 10:15:27 dlg Exp $ */
d50 3
d56 2
d63 14
d85 2
d90 2
d126 1
a126 1
	aaa.aaa_ncmds = SILI_MAX_CMDS;
d183 10
d198 37
d343 1
d372 17
a388 1
	return (ATA_PORT_T_NONE);
d394 82
a475 1
	return (ATA_ERROR);
d481 18
a498 1
	return (NULL);
@


1.10
log
@sili_post_direct lets you submit a prb without all the goop of a ccb and
xfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.9 2007/04/05 10:02:07 dlg Exp $ */
d68 1
d253 13
d271 2
d281 1
a281 1
	printf("%s.%d: SSTS 0x%08x\n", DEVNAME(sc), port,
d283 17
@


1.9
log
@rearrange the busywait funcs slightly
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.8 2007/04/05 10:00:02 dlg Exp $ */
d66 2
d232 18
@


1.8
log
@DPRINTF will be useful soon, so stick it in
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.7 2007/04/04 12:42:23 dlg Exp $ */
d207 1
a207 1
		if (timeout-- == 0)
d211 1
d222 1
a222 1
		if (timeout-- == 0)
d226 1
@


1.7
log
@implement sili_pwait_{ne,eq} for busy waiting on register values.

fill in sili_ata_probe a bit so it actually moves the port out of the reset
state and waits for the SStatus register to show that a device has been
detected.

the next step is to issue a soft reset and get the device signature, but i
need a code path for commands (like a soft reset) first.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.5 2007/03/31 03:59:53 dlg Exp $ */
d33 12
@


1.6
log
@do a global reset properly.
@
text
@d50 4
d191 28
d221 13
@


1.5
log
@initial atascsi glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.4 2007/03/31 03:11:38 dlg Exp $ */
d75 2
@


1.4
log
@the attach glue now specifies how many ports the chip has.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.3 2007/03/30 04:50:54 dlg Exp $ */
d51 12
d66 2
d75 11
d182 18
@


1.3
log
@start filling out stuff for managing each port. this allocates it, set a
register window up, and provides access to the port registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.2 2007/03/22 06:54:01 dlg Exp $ */
a55 1
	sc->sc_nports = 4; /* XXX magic */
d116 1
@


1.2
log
@read and write funcs for the global register space
@
text
@d1 1
a1 1
/*	$OpenBSD: sili.c,v 1.1 2007/03/22 02:48:42 dlg Exp $ */
d38 8
d48 2
d56 6
d81 38
d136 20
@


1.1
log
@import sili(4) so it can be worked on in the tree. this will support the
silicon image 3124/3132/3531 sata chipsets eventually.

so far this is the autoconf glue, an actual match routine for the 3124, and
interrupt establishment code. it is split up between pci and ic cos there
are cardbus variants of these controllers that we can support in the
future.

thanks to jolan@@ for the name, it was better liked than my initial
suggestion of siisl(4).
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d38 3
d65 19
@

