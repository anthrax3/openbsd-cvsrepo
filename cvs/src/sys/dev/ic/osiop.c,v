head	1.50;
access;
symbols
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.10
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.4
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.50.0.6
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.48.0.14
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.48.0.10
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.8
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.4
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.6
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC:1.13.0.2
	UBC_SYNC_A:1.12
	SMP:1.3.0.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.50
date	2014.12.19.07.23.57;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	cV4v1OA8Ccwr5fwb;

1.49
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	JtO5uXxVcnZfhUkR;

1.48
date	2011.06.23.16.31.16;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.02.13.38.27;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2010.12.08.21.57.47;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2010.06.28.04.39.57;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.41;

1.41
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.10.00.10.23;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.28.10.13.53;	author jasper;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.03.19.08.25;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.12.11.14.04;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.27.21.08.48;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.05.00.21.36;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.20.18.02.39;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.22.04.14.03;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.03.16.53.16;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.21.22.55.43;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.27.21.34.18;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.27.15.53.13;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.31.20.37.52;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.15.13.03.44;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.29.09.08.19;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.11.06.20.57;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.03.19.32.34;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.28.02;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.19.21.32.18;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.06.22.55.38;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.06.22.40.57;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.06.22.01.43;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.12.01.16.57;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.11.02.00.49;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.09.02.30.32;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.09.00.47.54;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.08.18.03.46;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.06.20.24.31;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.11.19.20.27;	author mickey;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2003.02.02.01.50.30;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.08.02.11.38;	author krw;	state Exp;
branches;
next	;

1.3.4.1
date	2003.05.13.19.35.02;	author ho;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.50
log
@another handful of bcopy -> memcpy because there is no overlap
@
text
@/*	$OpenBSD: osiop.c,v 1.49 2014/07/13 23:10:23 deraadt Exp $	*/
/*	$NetBSD: osiop.c,v 1.9 2002/04/05 18:27:54 bouyer Exp $	*/

/*
 * Copyright (c) 2001 Izumi Tsutsui.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994 Michael L. Hitch
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Van Jacobson of Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)siop.c	7.5 (Berkeley) 5/4/91
 */

/*
 * MI NCR53C710 scsi adaptor driver; based on arch/amiga/dev/siop.c:
 *	NetBSD: siop.c,v 1.43 1999/09/30 22:59:53 thorpej Exp
 *
 * bus_space/bus_dma'fied by Izumi Tsutsui <tsutsui@@ceres.dti.ne.jp>
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/kernel.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <machine/cpu.h>
#include <machine/bus.h>

#include <dev/ic/osiopreg.h>
#include <dev/ic/osiopvar.h>

/* 53C710 script */
#include <dev/microcode/siop/osiop.out>

void osiop_attach(struct osiop_softc *);
void osiop_minphys(struct buf *, struct scsi_link *);
void *osiop_io_get(void *);
void osiop_io_put(void *, void *);
void osiop_scsicmd(struct scsi_xfer *xs);
void osiop_poll(struct osiop_softc *, struct osiop_acb *);
void osiop_sched(struct osiop_softc *);
void osiop_scsidone(struct osiop_acb *, int);
void osiop_abort(struct osiop_softc *, const char *);
void osiop_init(struct osiop_softc *);
void osiop_reset(struct osiop_softc *);
void osiop_resetbus(struct osiop_softc *);
void osiop_start(struct osiop_softc *);
int osiop_checkintr(struct osiop_softc *, u_int8_t, u_int8_t, u_int8_t, int *);
void osiop_select(struct osiop_softc *);
void osiop_update_xfer_mode(struct osiop_softc *, int);
void scsi_period_to_osiop(struct osiop_softc *, int);
void osiop_timeout(void *);

int osiop_reset_delay = 250;	/* delay after reset, in milliseconds */

/* #define OSIOP_DEBUG */
#ifdef OSIOP_DEBUG
#define DEBUG_DMA	0x0001
#define DEBUG_INT	0x0002
#define DEBUG_PHASE	0x0004
#define DEBUG_DISC	0x0008
#define DEBUG_CMD	0x0010
#define DEBUG_SYNC	0x0020
#define DEBUG_SCHED	0x0040
#define DEBUG_ALL	0xffff
int osiop_debug = 0; /*DEBUG_ALL;*/
int osiopstarts = 0;
int osiopints = 0;
int osiopphmm = 0;
int osiop_trix = 0;
#define OSIOP_TRACE_SIZE	128
#define OSIOP_TRACE(a,b,c,d)	do {				\
	osiop_trbuf[osiop_trix + 0] = (a);			\
	osiop_trbuf[osiop_trix + 1] = (b);			\
	osiop_trbuf[osiop_trix + 2] = (c);			\
	osiop_trbuf[osiop_trix + 3] = (d);			\
	osiop_trix = (osiop_trix + 4) & (OSIOP_TRACE_SIZE - 1);	\
} while (0)
u_int8_t osiop_trbuf[OSIOP_TRACE_SIZE];
void osiop_dump_trace(void);
void osiop_dump_acb(struct osiop_acb *);
void osiop_dump(struct osiop_softc *);
#else
#define OSIOP_TRACE(a,b,c,d)
#endif

#ifdef OSIOP_DEBUG
/*
 * sync period transfer lookup - only valid for 66MHz clock
 */
static struct {
	u_int8_t p;	/* period from sync request message */
	u_int8_t r;	/* siop_period << 4 | sbcl */
} sync_tab[] = {
	{ 60/4, 0<<4 | 1},
	{ 76/4, 1<<4 | 1},
	{ 92/4, 2<<4 | 1},
	{ 92/4, 0<<4 | 2},
	{108/4, 3<<4 | 1},
	{116/4, 1<<4 | 2},
	{120/4, 4<<4 | 1},
	{120/4, 0<<4 | 3},
	{136/4, 5<<4 | 1},
	{140/4, 2<<4 | 2},
	{152/4, 6<<4 | 1},
	{152/4, 1<<4 | 3},
	{164/4, 3<<4 | 2},
	{168/4, 7<<4 | 1},
	{180/4, 2<<4 | 3},
	{184/4, 4<<4 | 2},
	{208/4, 5<<4 | 2},
	{212/4, 3<<4 | 3},
	{232/4, 6<<4 | 2},
	{240/4, 4<<4 | 3},
	{256/4, 7<<4 | 2},
	{272/4, 5<<4 | 3},
	{300/4, 6<<4 | 3},
	{332/4, 7<<4 | 3}
};
#endif

struct cfdriver osiop_cd = {
	NULL, "osiop", DV_DULL
};

struct scsi_adapter osiop_adapter = {
	osiop_scsicmd,
	osiop_minphys,
	NULL,
	NULL,
};

void
osiop_attach(sc)
	struct osiop_softc *sc;
{
	struct scsibus_attach_args saa;
	struct osiop_acb *acb;
	bus_dma_segment_t seg;
	int nseg;
	int i, err;

	/*
	 * Allocate and map DMA-safe memory for the script.
	 */
	err = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, PAGE_SIZE, 0,
	    &seg, 1, &nseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (err) {
		printf(": failed to allocate script memory, err=%d\n", err);
		return;
	}
	err = bus_dmamem_map(sc->sc_dmat, &seg, nseg, PAGE_SIZE,
	    (caddr_t *)&sc->sc_script, BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (err) {
		printf(": failed to map script memory, err=%d\n", err);
		return;
	}
	err = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1, PAGE_SIZE, 0,
	    BUS_DMA_NOWAIT, &sc->sc_scrdma);
	if (err) {
		printf(": failed to create script map, err=%d\n", err);
		return;
	}
	err = bus_dmamap_load_raw(sc->sc_dmat, sc->sc_scrdma,
	    &seg, nseg, PAGE_SIZE, BUS_DMA_NOWAIT);
	if (err) {
		printf(": failed to load script map, err=%d\n", err);
		return;
	}

	/*
	 * Copy and sync script
	 */
	memcpy(sc->sc_script, osiop_script, sizeof(osiop_script));
	bus_dmamap_sync(sc->sc_dmat, sc->sc_scrdma, 0, sizeof(osiop_script),
	    BUS_DMASYNC_PREWRITE);

	/*
	 * Allocate and map DMA-safe memory for the script data structure.
	 */
	err = bus_dmamem_alloc(sc->sc_dmat,
	    sizeof(struct osiop_ds) * OSIOP_NACB, PAGE_SIZE, 0,
	    &seg, 1, &nseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (err) {
		printf(": failed to allocate ds memory, err=%d\n", err);
		return;
	}
	err = bus_dmamem_map(sc->sc_dmat, &seg, nseg,
	    sizeof(struct osiop_ds) * OSIOP_NACB, (caddr_t *)&sc->sc_ds,
	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT);
	if (err) {
		printf(": failed to map ds memory, err=%d\n", err);
		return;
	}
	err = bus_dmamap_create(sc->sc_dmat,
	    sizeof(struct osiop_ds) * OSIOP_NACB, 1,
	    sizeof(struct osiop_ds) * OSIOP_NACB, 0,
	    BUS_DMA_NOWAIT, &sc->sc_dsdma);
	if (err) {
		printf(": failed to create ds map, err=%d\n", err);
		return;
	}
	err = bus_dmamap_load_raw(sc->sc_dmat, sc->sc_dsdma,
	    &seg, nseg, sizeof(struct osiop_ds) * OSIOP_NACB, BUS_DMA_NOWAIT);
	if (err) {
		printf(": failed to load ds map, err=%d\n", err);
		return;
	}

	/*
	 * Allocate (malloc) memory for acb's.
	 */
	acb = mallocarray(OSIOP_NACB, sizeof(*acb), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (acb == NULL) {
		printf(": can't allocate memory for acb\n");
		return;
	}
	sc->sc_acb = acb;

	sc->sc_cfflags = sc->sc_dev.dv_cfdata->cf_flags;
	sc->sc_nexus = NULL;
	sc->sc_active = 0;

	bzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));

	/* Initialize command block queue */
	TAILQ_INIT(&sc->ready_list);
	TAILQ_INIT(&sc->nexus_list);
	TAILQ_INIT(&sc->free_list);

	/* Initialize each command block */
	for (i = 0; i < OSIOP_NACB; i++, acb++) {
		bus_addr_t dsa;

		err = bus_dmamap_create(sc->sc_dmat, OSIOP_MAX_XFER, OSIOP_NSG,
		    OSIOP_MAX_XFER, 0, BUS_DMA_NOWAIT, &acb->datadma);
		if (err) {
			printf(": failed to create datadma map, err=%d\n",
			    err);
			return;
		}

		acb->sc = sc;
		acb->ds = &sc->sc_ds[i];
		acb->dsoffset = sizeof(struct osiop_ds) * i;

		dsa = sc->sc_dsdma->dm_segs[0].ds_addr + acb->dsoffset;
		acb->ds->id.addr = dsa + OSIOP_DSIDOFF;
		acb->ds->cmd.addr = dsa + OSIOP_DSCMDOFF;
		acb->ds->status.count = 1;
		acb->ds->status.addr = dsa + OSIOP_DSSTATOFF;
		acb->ds->msg.count = 1;
		acb->ds->msg.addr = dsa + OSIOP_DSMSGOFF;
		acb->ds->msgin.count = 1;
		acb->ds->msgin.addr = dsa + OSIOP_DSMSGINOFF;
		acb->ds->extmsg.count = 1;
		acb->ds->extmsg.addr = dsa + OSIOP_DSEXTMSGOFF;
		acb->ds->synmsg.count = 3;
		acb->ds->synmsg.addr = dsa + OSIOP_DSSYNMSGOFF;
		TAILQ_INSERT_TAIL(&sc->free_list, acb, chain);
	}

	mtx_init(&sc->free_list_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, osiop_io_get, osiop_io_put);

	printf(": NCR53C710 rev %d, %dMHz\n",
	    osiop_read_1(sc, OSIOP_CTEST8) >> 4, sc->sc_clock_freq);

	/*
	 * Initialize all
	 */
	osiop_init(sc);

	/*
	 * Fill in the sc_link.
	 */
	sc->sc_link.adapter = &osiop_adapter;
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.openings = 4;
	sc->sc_link.adapter_buswidth = OSIOP_NTGT;
	sc->sc_link.adapter_target = sc->sc_id;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	/*
	 * Now try to attach all the sub devices.
	 */
	config_found(&sc->sc_dev, &saa, scsiprint);
}

/*
 * default minphys routine for osiop based controllers
 */
void
osiop_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > OSIOP_MAX_XFER)
		bp->b_bcount = OSIOP_MAX_XFER;
	minphys(bp);
}

void *
osiop_io_get(void *xsc)
{
	struct osiop_softc *sc = xsc;
	struct osiop_acb *acb;

	mtx_enter(&sc->free_list_mtx);
	acb = TAILQ_FIRST(&sc->free_list);
	if (acb != NULL)
		TAILQ_REMOVE(&sc->free_list, acb, chain);
	mtx_leave(&sc->free_list_mtx);

	return (acb);
}

void
osiop_io_put(void *xsc, void *xio)
{
	struct osiop_softc *sc = xsc;
	struct osiop_acb *acb = xio;

	mtx_enter(&sc->free_list_mtx);
	TAILQ_INSERT_TAIL(&sc->free_list, acb, chain);
	mtx_leave(&sc->free_list_mtx);
}

/*
 * used by specific osiop controller
 *
 */
void
osiop_scsicmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *periph = xs->sc_link;
	struct osiop_acb *acb;
	struct osiop_softc *sc = periph->adapter_softc;
	int err, s;
	int dopoll;

	/* XXXX ?? */
	if (sc->sc_nexus && (xs->flags & SCSI_POLL))
#if 0
		panic("osiop_scsicmd: busy");
#else
		printf("osiop_scsicmd: busy\n");
#endif

	acb = xs->io;

	acb->flags = 0;
	acb->status = ACB_S_READY;
	acb->xs = xs;
	acb->xsflags = xs->flags;
	memcpy(&acb->ds->scsi_cmd, xs->cmd, xs->cmdlen);
	acb->ds->cmd.count = xs->cmdlen;
	acb->datalen = 0;
#ifdef OSIOP_DEBUG
	acb->data = xs->data;
#endif

	/* Setup DMA map for data buffer */
	if (acb->xsflags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		acb->datalen = xs->datalen;
		err = bus_dmamap_load(sc->sc_dmat, acb->datadma,
		    xs->data, acb->datalen, NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_STREAMING |
		    ((acb->xsflags & SCSI_DATA_IN) ?
		     BUS_DMA_READ : BUS_DMA_WRITE));
		if (err) {
			printf("%s: unable to load data DMA map: %d",
			    sc->sc_dev.dv_xname, err);
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}
		bus_dmamap_sync(sc->sc_dmat, acb->datadma,
		    0, acb->datalen, (acb->xsflags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
	}

	/*
	 * Always initialize timeout so it does not contain trash
	 * that could confuse timeout_del().
	 */
	timeout_set(&xs->stimeout, osiop_timeout, acb);

	s = splbio();
	TAILQ_INSERT_TAIL(&sc->ready_list, acb, chain);

	if ((acb->xsflags & SCSI_POLL) || (sc->sc_flags & OSIOP_NODMA))
		dopoll = 1;
	else {
		dopoll = 0;
		/* start expire timer */
		timeout_add_msec(&xs->stimeout, xs->timeout);
	}

	osiop_sched(sc);

	splx(s);

	if (dopoll)
		osiop_poll(sc, acb);
}

void
osiop_poll(sc, acb)
	struct osiop_softc *sc;
	struct osiop_acb *acb;
{
	struct scsi_xfer *xs = acb->xs;
	int status, i, s, to;
	u_int8_t istat, dstat, sstat0;

	s = splbio();
	to = xs->timeout / 1000;
	if (!TAILQ_EMPTY(&sc->nexus_list))
		printf("%s: osiop_poll called with disconnected device\n",
		    sc->sc_dev.dv_xname);
	for (;;) {
		i = 1000;
		while (((istat = osiop_read_1(sc, OSIOP_ISTAT)) &
		    (OSIOP_ISTAT_SIP | OSIOP_ISTAT_DIP)) == 0) {
			if (i <= 0) {
#ifdef OSIOP_DEBUG
				printf("waiting: tgt %d cmd %02x sbcl %02x"
				    " dsp %x (+%lx) dcmd %x"
				    " ds %p timeout %d\n",
				    xs->sc_link->target,
				    acb->ds->scsi_cmd.opcode,
				    osiop_read_1(sc, OSIOP_SBCL),
				    osiop_read_4(sc, OSIOP_DSP),
				    osiop_read_4(sc, OSIOP_DSP) -
				        sc->sc_scrdma->dm_segs[0].ds_addr,
				    osiop_read_1(sc, OSIOP_DCMD),
				    acb->ds, acb->xs->timeout);
#endif
				i = 1000;
				to--;
				if (to <= 0) {
					osiop_reset(sc);
					splx(s);
					return;
				}
			}
			delay(1000);
			i--;
		}
		sstat0 = osiop_read_1(sc, OSIOP_SSTAT0);
		delay(25); /* Need delay between SSTAT0 and DSTAT reads */
		dstat = osiop_read_1(sc, OSIOP_DSTAT);
		if (osiop_checkintr(sc, istat, dstat, sstat0, &status)) {
			if (acb != sc->sc_nexus)
				printf("%s: osiop_poll disconnected device"
				    " completed\n", sc->sc_dev.dv_xname);
			else if ((sc->sc_flags & OSIOP_INTDEFER) == 0) {
				sc->sc_flags &= ~OSIOP_INTSOFF;
				osiop_write_1(sc, OSIOP_SIEN, sc->sc_sien);
				osiop_write_1(sc, OSIOP_DIEN, sc->sc_dien);
			}
			osiop_scsidone(sc->sc_nexus, status);
		}

		if (xs->flags & ITSDONE)
			break;
	}

	splx(s);
	return;
}

/*
 * start next command that's ready
 */
void
osiop_sched(sc)
	struct osiop_softc *sc;
{
	struct osiop_tinfo *ti;
	struct scsi_link *periph;
	struct osiop_acb *acb;

	if ((sc->sc_nexus != NULL) || TAILQ_EMPTY(&sc->ready_list)) {
#ifdef OSIOP_DEBUG
		if (osiop_debug & DEBUG_SCHED)
			printf("%s: osiop_sched->nexus %p/%d ready %p/%d\n",
			    sc->sc_dev.dv_xname, sc->sc_nexus,
			    sc->sc_nexus != NULL ?
			     sc->sc_nexus->xs->sc_link->target : 0,
			    TAILQ_FIRST(&sc->ready_list),
			    TAILQ_FIRST(&sc->ready_list) != NULL ?
			     TAILQ_FIRST(&sc->ready_list)->xs->sc_link->target :
			     0);
#endif
		return;
	}
	TAILQ_FOREACH(acb, &sc->ready_list, chain) {
		periph = acb->xs->sc_link;
		ti = &sc->sc_tinfo[periph->target];
		if ((ti->lubusy & (1 << periph->lun)) == 0) {
			TAILQ_REMOVE(&sc->ready_list, acb, chain);
			sc->sc_nexus = acb;
			ti->lubusy |= (1 << periph->lun);
			break;
		}
	}

	if (acb == NULL) {
#ifdef OSIOP_DEBUG
		if (osiop_debug & DEBUG_SCHED)
			printf("%s: osiop_sched didn't find ready command\n",
			    sc->sc_dev.dv_xname);
#endif
		return;
	}

	if (acb->xsflags & SCSI_RESET)
		osiop_reset(sc);

	sc->sc_active++;
	osiop_select(sc);
}

void
osiop_scsidone(acb, status)
	struct osiop_acb *acb;
	int status;
{
	struct scsi_xfer *xs;
	struct scsi_link *periph;
	struct osiop_softc *sc;
	int autosense;

#ifdef DIAGNOSTIC
	if (acb == NULL || acb->xs == NULL) {
		printf("osiop_scsidone: NULL acb %p or scsi_xfer\n", acb);
#if defined(OSIOP_DEBUG) && defined(DDB)
		Debugger();
#endif
		return;
	}
#endif
	xs = acb->xs;
	sc = acb->sc;
	periph = xs->sc_link;

	/*
	 * Record if this is the completion of an auto sense
	 * scsi command, and then reset the flag so we don't loop
	 * when such a command fails or times out.
	 */
	autosense = acb->flags & ACB_F_AUTOSENSE;
	acb->flags &= ~ACB_F_AUTOSENSE;

#ifdef OSIOP_DEBUG
	if (acb->status != ACB_S_DONE)
		printf("%s: acb not done (status %d)\n",
		    sc->sc_dev.dv_xname, acb->status);
#endif

	if (acb->xsflags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		bus_dmamap_sync(sc->sc_dmat, acb->datadma, 0, acb->datalen,
		    (acb->xsflags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, acb->datadma);
	}

	timeout_del(&xs->stimeout);
	xs->status = status;

	switch (status) {
	case SCSI_OK:
		if (autosense == 0)
			xs->error = XS_NOERROR;
		else
			xs->error = XS_SENSE;
		break;
	case SCSI_BUSY:
		xs->error = XS_BUSY;
		break;
	case SCSI_CHECK:
		if (autosense == 0)
			acb->flags |= ACB_F_AUTOSENSE;
		else
			xs->error = XS_DRIVER_STUFFUP;
		break;
	case SCSI_OSIOP_NOCHECK:
		/*
		 * don't check status, xs->error is already valid
		 */
		break;
	case SCSI_OSIOP_NOSTATUS:
		/*
		 * the status byte was not updated, cmd was
		 * aborted
		 */
		xs->error = XS_SELTIMEOUT;
		break;
	default:
#ifdef OSIOP_DEBUG
		printf("%s: osiop_scsidone: unknown status code (0x%02x)\n",
		    sc->sc_dev.dv_xname, status);
#endif
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

	/*
	 * Remove the ACB from whatever queue it's on.  We have to do a bit of
	 * a hack to figure out which queue it's on.  Note that it is *not*
	 * necessary to cdr down the ready queue, but we must cdr down the
	 * nexus queue and see if it's there, so we can mark the unit as no
	 * longer busy.  This code is sickening, but it works.
	 */
	if (acb == sc->sc_nexus) {
		sc->sc_nexus = NULL;
		sc->sc_tinfo[periph->target].lubusy &=
		    ~(1 << periph->lun);
		sc->sc_active--;
		OSIOP_TRACE('d', 'a', status, 0);
	} else if (sc->ready_list.tqh_last == &TAILQ_NEXT(acb, chain)) {
		TAILQ_REMOVE(&sc->ready_list, acb, chain);
		OSIOP_TRACE('d', 'r', status, 0);
	} else {
		struct osiop_acb *acb2;
		TAILQ_FOREACH(acb2, &sc->nexus_list, chain) {
			if (acb2 == acb) {
				TAILQ_REMOVE(&sc->nexus_list, acb, chain);
				sc->sc_tinfo[periph->target].lubusy &=
				    ~(1 << periph->lun);
				sc->sc_active--;
				break;
			}
		}
		if (acb2 == NULL) {
			if (TAILQ_NEXT(acb, chain) != NULL) {
				TAILQ_REMOVE(&sc->ready_list, acb, chain);
				sc->sc_active--;
			} else {
				printf("%s: can't find matching acb\n",
				    sc->sc_dev.dv_xname);
			}
		}
		OSIOP_TRACE('d', 'n', status, 0);
	}

	if ((acb->flags & ACB_F_AUTOSENSE) == 0) {
		/* Put it on the free list. */
FREE:
		acb->status = ACB_S_FREE;
#ifdef DIAGNOSTIC
		acb->xs = NULL;
#endif
		sc->sc_tinfo[periph->target].cmds++;

#ifdef DIAGNOSTIC
		acb->xs = NULL;
#endif
		xs->resid = 0;
		scsi_done(xs);
	} else {
		/* Set up REQUEST_SENSE command */
		struct scsi_sense *cmd = (struct scsi_sense *)&acb->ds->scsi_cmd;
		int err;

		bzero(cmd, sizeof(*cmd));
		acb->ds->cmd.count = sizeof(*cmd);
		cmd->opcode = REQUEST_SENSE;
		cmd->byte2  = xs->sc_link->lun << 5;
		cmd->length = sizeof(xs->sense);

		/* Setup DMA map for data buffer */
		acb->xsflags &= SCSI_POLL | SCSI_NOSLEEP;
		acb->xsflags |= SCSI_DATA_IN;
		acb->datalen  = sizeof xs->sense;
#ifdef OSIOP_DEBUG
		acb->data = &xs->sense;
#endif
		err = bus_dmamap_load(sc->sc_dmat, acb->datadma,
		    &xs->sense, sizeof(xs->sense), NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_STREAMING | BUS_DMA_READ);
		if (err) {
			printf("%s: unable to load REQUEST_SENSE data DMA map: %d",
			    sc->sc_dev.dv_xname, err);
			xs->error = XS_DRIVER_STUFFUP;
			goto FREE;
		}
		bus_dmamap_sync(sc->sc_dmat, acb->datadma,
		    0, sizeof(xs->sense), BUS_DMASYNC_PREREAD);

		sc->sc_tinfo[periph->target].senses++;
		acb->status  = ACB_S_READY;
		TAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);
		if (((acb->xsflags & SCSI_POLL) == 0) && ((sc->sc_flags & OSIOP_NODMA) == 0))
			/* start expire timer */
			timeout_add_msec(&xs->stimeout, xs->timeout);
	}

	osiop_sched(sc);
}

void
osiop_abort(sc, where)
	struct osiop_softc *sc;
	const char *where;
{
	u_int8_t dstat, sstat0;

	sstat0 = osiop_read_1(sc, OSIOP_SSTAT0);
	delay(25); /* Need delay between SSTAT0 and DSTAT reads */
	dstat = osiop_read_1(sc, OSIOP_DSTAT);

	printf("%s: abort %s: dstat %02x, sstat0 %02x sbcl %02x\n",
	    sc->sc_dev.dv_xname, where,
	    dstat, sstat0,
	    osiop_read_1(sc, OSIOP_SBCL));

	/* XXX XXX XXX */
	if (sc->sc_active > 0) {
		sc->sc_active = 0;
	}
}

void
osiop_init(sc)
	struct osiop_softc *sc;
{
	int i, inhibit_sync, inhibit_disc;

	sc->sc_tcp[1] = 1000 / sc->sc_clock_freq;
	sc->sc_tcp[2] = 1500 / sc->sc_clock_freq;
	sc->sc_tcp[3] = 2000 / sc->sc_clock_freq;
	sc->sc_minsync = sc->sc_tcp[1];		/* in 4ns units */

	if (sc->sc_minsync < 25)
		sc->sc_minsync = 25;

	if (sc->sc_clock_freq <= 25) {
		sc->sc_dcntl |= OSIOP_DCNTL_CF_1;	/* SCLK/1 */
		sc->sc_tcp[0] = sc->sc_tcp[1];
	} else if (sc->sc_clock_freq <= 37) {
		sc->sc_dcntl |= OSIOP_DCNTL_CF_1_5;	/* SCLK/1.5 */
		sc->sc_tcp[0] = sc->sc_tcp[2];
	} else if (sc->sc_clock_freq <= 50) {
		sc->sc_dcntl |= OSIOP_DCNTL_CF_2;	/* SCLK/2 */
		sc->sc_tcp[0] = sc->sc_tcp[3];
	} else {
		sc->sc_dcntl |= OSIOP_DCNTL_CF_3;	/* SCLK/3 */
		sc->sc_tcp[0] = 3000 / sc->sc_clock_freq;
	}

	if ((sc->sc_cfflags & 0x10000) != 0) {
		sc->sc_flags |= OSIOP_NODMA;
#ifdef OSIOP_DEBUG
		printf("%s: DMA disabled; use polling\n",
		    sc->sc_dev.dv_xname);
#endif
	}

	inhibit_sync = (sc->sc_cfflags & 0xff00) >> 8;	/* XXX */
	inhibit_disc =  sc->sc_cfflags & 0x00ff;	/* XXX */
#ifdef OSIOP_DEBUG
	if (inhibit_sync != 0)
		printf("%s: Inhibiting synchronous transfer: 0x%02x\n",
		    sc->sc_dev.dv_xname, inhibit_sync);
	if (inhibit_disc != 0)
		printf("%s: Inhibiting disconnect: 0x%02x\n",
		    sc->sc_dev.dv_xname, inhibit_disc);
#endif
	for (i = 0; i < OSIOP_NTGT; i++) {
		if (inhibit_sync & (1 << i))
			sc->sc_tinfo[i].flags |= TI_NOSYNC;
		if (inhibit_disc & (1 << i))
			sc->sc_tinfo[i].flags |= TI_NODISC;
	}

	osiop_resetbus(sc);
	osiop_reset(sc);
}

void
osiop_reset(sc)
	struct osiop_softc *sc;
{
	struct osiop_acb *acb;
	int i, s;
	u_int8_t stat;

#ifdef OSIOP_DEBUG
	printf("%s: resetting chip\n", sc->sc_dev.dv_xname);
#endif
	if (sc->sc_flags & OSIOP_ALIVE)
		osiop_abort(sc, "reset");

	s = splbio();

	/*
	 * Reset the chip
	 * XXX - is this really needed?
	 */

	/* abort current script */
	osiop_write_1(sc, OSIOP_ISTAT,
	    osiop_read_1(sc, OSIOP_ISTAT) | OSIOP_ISTAT_ABRT);
	/* reset chip */
	osiop_write_1(sc, OSIOP_ISTAT,
	    osiop_read_1(sc, OSIOP_ISTAT) | OSIOP_ISTAT_RST);
	delay(100);
	osiop_write_1(sc, OSIOP_ISTAT,
	    osiop_read_1(sc, OSIOP_ISTAT) & ~OSIOP_ISTAT_RST);
	delay(100);

	/*
	 * Set up various chip parameters
	 */
	osiop_write_1(sc, OSIOP_SCNTL0,
	    OSIOP_ARB_FULL | OSIOP_SCNTL0_EPC | OSIOP_SCNTL0_EPG);
	osiop_write_1(sc, OSIOP_SCNTL1, OSIOP_SCNTL1_ESR);
	osiop_write_1(sc, OSIOP_DCNTL, sc->sc_dcntl);
	osiop_write_1(sc, OSIOP_DMODE, sc->sc_dmode);
	/* don't enable interrupts yet */
	osiop_write_1(sc, OSIOP_SIEN, 0x00);
	osiop_write_1(sc, OSIOP_DIEN, 0x00);
	osiop_write_1(sc, OSIOP_SCID, OSIOP_SCID_VALUE(sc->sc_id));
	osiop_write_1(sc, OSIOP_DWT, 0x00);
	osiop_write_1(sc, OSIOP_CTEST0, osiop_read_1(sc, OSIOP_CTEST0)
	    | OSIOP_CTEST0_BTD | OSIOP_CTEST0_EAN);
	osiop_write_1(sc, OSIOP_CTEST7,
	    osiop_read_1(sc, OSIOP_CTEST7) | sc->sc_ctest7);

	/* will need to re-negotiate sync xfers */
	for (i = 0; i < OSIOP_NTGT; i++) {
		sc->sc_tinfo[i].state = NEG_INIT;
		sc->sc_tinfo[i].period = 0;
		sc->sc_tinfo[i].offset = 0;
	}

	stat = osiop_read_1(sc, OSIOP_ISTAT);
	if (stat & OSIOP_ISTAT_SIP)
		osiop_read_1(sc, OSIOP_SSTAT0);
	if (stat & OSIOP_ISTAT_DIP) {
		if (stat & OSIOP_ISTAT_SIP)
			/* Need delay between SSTAT0 and DSTAT reads */
			delay(25);
		osiop_read_1(sc, OSIOP_DSTAT);
	}

	splx(s);

	delay(osiop_reset_delay * 1000);

	s = splbio();
	if (sc->sc_nexus != NULL) {
		sc->sc_nexus->xs->error =
		    (sc->sc_nexus->flags & ACB_F_TIMEOUT) ?
		    XS_TIMEOUT : XS_RESET;
		sc->sc_nexus->status = ACB_S_DONE;
		osiop_scsidone(sc->sc_nexus, SCSI_OSIOP_NOCHECK);
	}
	while ((acb = TAILQ_FIRST(&sc->nexus_list)) != NULL) {
		acb->xs->error = (acb->flags & ACB_F_TIMEOUT) ?
		    XS_TIMEOUT : XS_RESET;
		acb->status = ACB_S_DONE;
		osiop_scsidone(acb, SCSI_OSIOP_NOCHECK);
	}
	splx(s);

	sc->sc_flags &= ~(OSIOP_INTDEFER | OSIOP_INTSOFF);
	/* enable SCSI and DMA interrupts */
	sc->sc_sien = OSIOP_SIEN_M_A | OSIOP_SIEN_STO | /*OSIOP_SIEN_SEL |*/
	    OSIOP_SIEN_SGE | OSIOP_SIEN_UDC | OSIOP_SIEN_RST | OSIOP_SIEN_PAR;
	sc->sc_dien = OSIOP_DIEN_BF | OSIOP_DIEN_ABRT | OSIOP_DIEN_SIR |
	    /*OSIOP_DIEN_WTD |*/ OSIOP_DIEN_IID;
	osiop_write_1(sc, OSIOP_SIEN, sc->sc_sien);
	osiop_write_1(sc, OSIOP_DIEN, sc->sc_dien);
}

void
osiop_resetbus(sc)
	struct osiop_softc *sc;
{

	osiop_write_1(sc, OSIOP_SIEN, 0);
	osiop_write_1(sc, OSIOP_SCNTL1,
	    osiop_read_1(sc, OSIOP_SCNTL1) | OSIOP_SCNTL1_RST);
	delay(25);
	osiop_write_1(sc, OSIOP_SCNTL1,
	    osiop_read_1(sc, OSIOP_SCNTL1) & ~OSIOP_SCNTL1_RST);
}

/*
 * Setup Data Storage for 53C710 and start SCRIPTS processing
 */

void
osiop_start(sc)
	struct osiop_softc *sc;
{
	struct osiop_acb *acb = sc->sc_nexus;
	struct osiop_ds *ds = acb->ds;
	struct scsi_xfer *xs = acb->xs;
	bus_dmamap_t dsdma = sc->sc_dsdma, datadma = acb->datadma;
	struct osiop_tinfo *ti;
	int target = xs->sc_link->target;
	int lun = xs->sc_link->lun;
	int disconnect, i;

#ifdef OSIOP_DEBUG
	if (osiop_debug & DEBUG_DISC &&
	    osiop_read_1(sc, OSIOP_SBCL) & OSIOP_BSY) {
		printf("ACK! osiop was busy: script %p dsa %p active %d\n",
		    sc->sc_script, acb->ds, sc->sc_active);
		printf("istat %02x sfbr %02x lcrc %02x sien %02x dien %02x\n",
		    osiop_read_1(sc, OSIOP_ISTAT),
		    osiop_read_1(sc, OSIOP_SFBR),
		    osiop_read_1(sc, OSIOP_LCRC),
		    osiop_read_1(sc, OSIOP_SIEN),
		    osiop_read_1(sc, OSIOP_DIEN));
	}
#endif

#ifdef OSIOP_DEBUG
	if (acb->status != ACB_S_READY)
		panic("osiop_start: non-ready cmd in acb");
#endif

	acb->intstat = 0;

	ti = &sc->sc_tinfo[target];
	ds->scsi_addr = ((1 << 16) << target) | (ti->sxfer << 8);

	disconnect = (ds->scsi_cmd.opcode != REQUEST_SENSE) &&
	    (ti->flags & TI_NODISC) == 0;

	ds->msgout[0] = MSG_IDENTIFY(lun, disconnect);
	ds->id.count = 1;
	ds->stat[0] = SCSI_OSIOP_NOSTATUS;	/* set invalid status */
	ds->msgbuf[0] = ds->msgbuf[1] = MSG_INVALID;
	bzero(&ds->data, sizeof(ds->data));

	/*
	 * Negotiate wide is the initial negotiation state;  since the 53c710
	 * doesn't do wide transfers, just begin the synchronous transfer
	 * negotiation here.
	 */
	if (ti->state == NEG_INIT) {
		if ((ti->flags & TI_NOSYNC) != 0) {
			ti->state = NEG_DONE;
			ti->period = 0;
			ti->offset = 0;
			osiop_update_xfer_mode(sc, target);
#ifdef OSIOP_DEBUG
			if (osiop_debug & DEBUG_SYNC)
				printf("Forcing target %d asynchronous\n",
				    target);
#endif
		} else {
			ds->msgbuf[2] = MSG_INVALID;
			ds->msgout[1] = MSG_EXTENDED;
			ds->msgout[2] = MSG_EXT_SDTR_LEN;
			ds->msgout[3] = MSG_EXT_SDTR;
			ds->msgout[4] = sc->sc_minsync;
			ds->msgout[5] = OSIOP_MAX_OFFSET;
			ds->id.count = MSG_EXT_SDTR_LEN + 3;
			ti->state = NEG_WAITS;
#ifdef OSIOP_DEBUG
			if (osiop_debug & DEBUG_SYNC)
				printf("Sending sync request to target %d\n",
				    target);
#endif
		}
	}

	acb->curaddr = 0;
	acb->curlen = 0;

	/*
	 * Build physical DMA addresses for scatter/gather I/O
	 */
	if (acb->xsflags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		for (i = 0; i < datadma->dm_nsegs; i++) {
			ds->data[i].count = datadma->dm_segs[i].ds_len;
			ds->data[i].addr  = datadma->dm_segs[i].ds_addr;
		}
	}

	/* sync script data structure */
	bus_dmamap_sync(sc->sc_dmat, dsdma,
	    acb->dsoffset, sizeof(struct osiop_ds),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	acb->status = ACB_S_ACTIVE;

#ifdef OSIOP_DEBUG
	if (osiop_debug & DEBUG_DISC &&
	    osiop_read_1(sc, OSIOP_SBCL) & OSIOP_BSY) {
		printf("ACK! osiop was busy at start: "
		    "script %p dsa %p active %d\n",
		    sc->sc_script, acb->ds, sc->sc_active);
	}
#endif
	if (TAILQ_EMPTY(&sc->nexus_list)) {
		if (osiop_read_1(sc, OSIOP_ISTAT) & OSIOP_ISTAT_CON)
			printf("%s: osiop_select while connected?\n",
			    sc->sc_dev.dv_xname);
		osiop_write_4(sc, OSIOP_TEMP, 0);
		osiop_write_1(sc, OSIOP_SBCL, ti->sbcl);
		osiop_write_4(sc, OSIOP_DSA,
		    dsdma->dm_segs[0].ds_addr + acb->dsoffset);
		osiop_write_4(sc, OSIOP_DSP,
		    sc->sc_scrdma->dm_segs[0].ds_addr + Ent_scripts);
		OSIOP_TRACE('s', 1, 0, 0);
	} else {
		if ((osiop_read_1(sc, OSIOP_ISTAT) & OSIOP_ISTAT_CON) == 0) {
			osiop_write_1(sc, OSIOP_ISTAT, OSIOP_ISTAT_SIGP);
			OSIOP_TRACE('s', 2, 0, 0);
		} else {
			OSIOP_TRACE('s', 3,
			    osiop_read_1(sc, OSIOP_ISTAT), 0);
		}
	}
#ifdef OSIOP_DEBUG
	osiopstarts++;
#endif
}

/*
 * Process a DMA or SCSI interrupt from the 53C710 SIOP
 */

int
osiop_checkintr(sc, istat, dstat, sstat0, status)
	struct	osiop_softc *sc;
	u_int8_t istat;
	u_int8_t dstat;
	u_int8_t sstat0;
	int *status;
{
	struct osiop_acb *acb = sc->sc_nexus;
	struct osiop_ds *ds;
	bus_dmamap_t dsdma = sc->sc_dsdma;
	bus_addr_t scraddr = sc->sc_scrdma->dm_segs[0].ds_addr;
	int target = 0;
	int dfifo, dbc, intcode, sstat1;

	dfifo = osiop_read_1(sc, OSIOP_DFIFO);
	dbc = osiop_read_4(sc, OSIOP_DBC) & 0x00ffffff;
	sstat1 = osiop_read_1(sc, OSIOP_SSTAT1);
	osiop_write_1(sc, OSIOP_CTEST8,
	    osiop_read_1(sc, OSIOP_CTEST8) | OSIOP_CTEST8_CLF);
	while ((osiop_read_1(sc, OSIOP_CTEST1) & OSIOP_CTEST1_FMT) !=
	    OSIOP_CTEST1_FMT)
		;
	osiop_write_1(sc, OSIOP_CTEST8,
	    osiop_read_1(sc, OSIOP_CTEST8) & ~OSIOP_CTEST8_CLF);
	intcode = osiop_read_4(sc, OSIOP_DSPS);
#ifdef OSIOP_DEBUG
	osiopints++;
	if (osiop_read_4(sc, OSIOP_DSP) != 0 &&
	    (osiop_read_4(sc, OSIOP_DSP) < scraddr ||
	    osiop_read_4(sc, OSIOP_DSP) >= scraddr + sizeof(osiop_script))) {
		printf("%s: dsp not within script dsp %x scripts %lx:%lx",
		    sc->sc_dev.dv_xname,
		    osiop_read_4(sc, OSIOP_DSP),
		    scraddr, scraddr + sizeof(osiop_script));
		printf(" istat %x dstat %x sstat0 %x\n", istat, dstat, sstat0);
#ifdef DDB
		Debugger();
#endif
	}
#endif
	OSIOP_TRACE('i', dstat, istat, (istat & OSIOP_ISTAT_DIP) ?
	    intcode & 0xff : sstat0);

	ds = NULL;
	if (acb != NULL) { /* XXX */
		ds = acb->ds;
		bus_dmamap_sync(sc->sc_dmat, dsdma,
		    acb->dsoffset, sizeof(struct osiop_ds),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
#ifdef OSIOP_DEBUG
		if (acb->status != ACB_S_ACTIVE)
			printf("osiop_checkintr: acb not active (status %d)\n",
			    acb->status);
#endif
	}

	if (dstat & OSIOP_DSTAT_SIR && intcode == A_ok) {
		/* Normal completion status, or check condition */
		struct osiop_tinfo *ti;
		if (acb == NULL) {
			printf("%s: COMPLETE with no active command?\n",
			    sc->sc_dev.dv_xname);
			return (0);
		}
#ifdef OSIOP_DEBUG
		if (osiop_read_4(sc, OSIOP_DSA) !=
		    dsdma->dm_segs[0].ds_addr + acb->dsoffset) {
			printf("osiop: invalid dsa: %x %lx\n",
			    osiop_read_4(sc, OSIOP_DSA),
			    dsdma->dm_segs[0].ds_addr + acb->dsoffset);
			panic("*** osiop DSA invalid ***");
		}
#endif
		target = acb->xs->sc_link->target;
		ti = &sc->sc_tinfo[target];
		if (ti->state == NEG_WAITS) {
			if (ds->msgbuf[1] == MSG_INVALID)
				printf("%s: target %d ignored sync request\n",
				    sc->sc_dev.dv_xname, target);
			else if (ds->msgbuf[1] == MSG_MESSAGE_REJECT)
				printf("%s: target %d rejected sync request\n",
				    sc->sc_dev.dv_xname, target);
			ti->period = 0;
			ti->offset = 0;
			osiop_update_xfer_mode(sc, target);
			ti->state = NEG_DONE;
		}
#ifdef OSIOP_DEBUG
		if (osiop_read_1(sc, OSIOP_SBCL) & OSIOP_BSY) {
#if 0
			printf("ACK! osiop was busy at end: "
			    "script %p dsa %p\n", &osiop_script, ds);
#endif
		}
		if (ds->msgbuf[0] != MSG_CMDCOMPLETE)
			printf("%s: message was not COMMAND COMPLETE: %02x\n",
			    sc->sc_dev.dv_xname, ds->msgbuf[0]);
#endif
		if (!TAILQ_EMPTY(&sc->nexus_list))
			osiop_write_1(sc, OSIOP_DCNTL,
			    osiop_read_1(sc, OSIOP_DCNTL) | OSIOP_DCNTL_STD);
		*status = ds->stat[0];
		acb->status = ACB_S_DONE;
		return (1);
	}
	if (dstat & OSIOP_DSTAT_SIR && intcode == A_int_syncmsg) {
		if (acb == NULL) {
			printf("%s: Sync message with no active command?\n",
			    sc->sc_dev.dv_xname);
			return (0);
		}
		target = acb->xs->sc_link->target;
		if (ds->msgbuf[1] == MSG_EXTENDED &&
		    ds->msgbuf[2] == MSG_EXT_SDTR_LEN &&
		    ds->msgbuf[3] == MSG_EXT_SDTR) {
			struct osiop_tinfo *ti = &sc->sc_tinfo[target];
#ifdef OSIOP_DEBUG
			if (osiop_debug & DEBUG_SYNC)
				printf("sync msg in: "
				    "%02x %02x %02x %02x %02x %02x\n",
				    ds->msgbuf[0], ds->msgbuf[1],
				    ds->msgbuf[2], ds->msgbuf[3],
				    ds->msgbuf[4], ds->msgbuf[5]);
#endif
			ti->period = ds->msgbuf[4];
			ti->offset = ds->msgbuf[5];
			osiop_update_xfer_mode(sc, target);

			bus_dmamap_sync(sc->sc_dmat, dsdma,
			    acb->dsoffset, sizeof(struct osiop_ds),
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
			osiop_write_1(sc, OSIOP_SXFER, ti->sxfer);
			osiop_write_1(sc, OSIOP_SBCL, ti->sbcl);
			if (ti->state == NEG_WAITS) {
				ti->state = NEG_DONE;
				osiop_write_4(sc, OSIOP_DSP,
				    scraddr + Ent_clear_ack);
				return (0);
			}
			osiop_write_1(sc, OSIOP_DCNTL,
			    osiop_read_1(sc, OSIOP_DCNTL) | OSIOP_DCNTL_STD);
			ti->state = NEG_DONE;
			return (0);
		}
		/* XXX - not SDTR message */
	}
	if (sstat0 & OSIOP_SSTAT0_M_A) {
		/* Phase mismatch */
#ifdef OSIOP_DEBUG
		osiopphmm++;
#endif
		if (acb == NULL) {
			printf("%s: Phase mismatch with no active command?\n",
			    sc->sc_dev.dv_xname);
			return (0);
		}
		if (acb->datalen > 0) {
			int adjust = (dfifo - (dbc & 0x7f)) & 0x7f;
			if (sstat1 & OSIOP_SSTAT1_ORF)
				adjust++;
			if (sstat1 & OSIOP_SSTAT1_OLF)
				adjust++;
			acb->curaddr = osiop_read_4(sc, OSIOP_DNAD) - adjust;
			acb->curlen = dbc + adjust;
#ifdef OSIOP_DEBUG
			if (osiop_debug & DEBUG_DISC) {
				printf("Phase mismatch: curaddr %lx "
				    "curlen %lx dfifo %x dbc %x sstat1 %x "
				    "adjust %x sbcl %x starts %d acb %p\n",
				    acb->curaddr, acb->curlen, dfifo,
				    dbc, sstat1, adjust,
				    osiop_read_1(sc, OSIOP_SBCL),
				    osiopstarts, acb);
				if (ds->data[1].count != 0) {
					int i;
					for (i = 0; ds->data[i].count != 0; i++)
						printf("chain[%d] "
						    "addr %x len %x\n", i,
						    ds->data[i].addr,
						    ds->data[i].count);
				}
				bus_dmamap_sync(sc->sc_dmat, dsdma,
				    acb->dsoffset, sizeof(struct osiop_ds),
				    BUS_DMASYNC_PREREAD |
				    BUS_DMASYNC_PREWRITE);
			}
#endif
		}
#ifdef OSIOP_DEBUG
		OSIOP_TRACE('m', osiop_read_1(sc, OSIOP_SBCL),
		    osiop_read_4(sc, OSIOP_DSP) >> 8,
		    osiop_read_4(sc, OSIOP_DSP));
		if (osiop_debug & DEBUG_PHASE)
			printf("Phase mismatch: %x dsp +%lx dcmd %x\n",
			    osiop_read_1(sc, OSIOP_SBCL),
			    osiop_read_4(sc, OSIOP_DSP) - scraddr,
			    osiop_read_4(sc, OSIOP_DBC));
#endif
		if ((osiop_read_1(sc, OSIOP_SBCL) & OSIOP_REQ) == 0) {
			printf("Phase mismatch: "
			    "REQ not asserted! %02x dsp %x\n",
			    osiop_read_1(sc, OSIOP_SBCL),
			    osiop_read_4(sc, OSIOP_DSP));
#if defined(OSIOP_DEBUG) && defined(DDB)
			/*Debugger(); XXX is*/
#endif
		}
		switch (OSIOP_PHASE(osiop_read_1(sc, OSIOP_SBCL))) {
		case DATA_OUT_PHASE:
		case DATA_IN_PHASE:
		case STATUS_PHASE:
		case COMMAND_PHASE:
		case MSG_IN_PHASE:
		case MSG_OUT_PHASE:
			osiop_write_4(sc, OSIOP_DSP, scraddr + Ent_switch);
			break;
		default:
			printf("%s: invalid phase\n", sc->sc_dev.dv_xname);
			goto bad_phase;
		}
		return (0);
	}
	if (sstat0 & OSIOP_SSTAT0_STO) {
		/* Select timed out */
		if (acb == NULL) {
			printf("%s: Select timeout with no active command?\n",
			    sc->sc_dev.dv_xname);
#if 0
			return (0);
#else
			goto bad_phase;
#endif
		}
#ifdef OSIOP_DEBUG
		if (osiop_read_1(sc, OSIOP_SBCL) & OSIOP_BSY) {
			printf("ACK! osiop was busy at timeout: "
			    "script %p dsa %lx\n", sc->sc_script,
			    dsdma->dm_segs[0].ds_addr + acb->dsoffset);
			printf(" sbcl %x sdid %x "
			    "istat %x dstat %x sstat0 %x\n",
			    osiop_read_1(sc, OSIOP_SBCL),
			    osiop_read_1(sc, OSIOP_SDID),
			    istat, dstat, sstat0);
			if ((osiop_read_1(sc, OSIOP_SBCL) & OSIOP_BSY) == 0) {
				printf("Yikes, it's not busy now!\n");
#if 0
				*status = SCSI_OSIOP_NOSTATUS;
				if (!TAILQ_EMPTY(&sc->nexus_list))
					osiop_write_4(sc, OSIOP_DSP,
					    scraddr + Ent_wait_reselect);
				return (1);
#endif
			}
#if 0
			osiop_write_1(sc, OSIOP_DCNTL,
			    osiop_read_1(sc, OSIOP_DCNTL) | OSIOP_DCNTL_STD);
#endif
			return (0);
		}
#endif
		acb->status = ACB_S_DONE;
		*status = SCSI_OSIOP_NOSTATUS;
		acb->xs->error = XS_SELTIMEOUT;
		if (!TAILQ_EMPTY(&sc->nexus_list))
			osiop_write_4(sc, OSIOP_DSP,
			    scraddr + Ent_wait_reselect);
		return (1);
	}
	if (acb != NULL)
		target = acb->xs->sc_link->target;
	else
		target = sc->sc_id;
	if (sstat0 & OSIOP_SSTAT0_UDC) {
#ifdef OSIOP_DEBUG
		if (acb == NULL)
			printf("%s: Unexpected disconnect "
			    "with no active command?\n", sc->sc_dev.dv_xname);
		printf("%s: target %d disconnected unexpectedly\n",
		    sc->sc_dev.dv_xname, target);
#endif
#if 0
		osiop_abort(sc, "osiop_chkintr");
#endif
		*status = SCSI_CHECK;
		if (!TAILQ_EMPTY(&sc->nexus_list))
			osiop_write_4(sc, OSIOP_DSP,
			    scraddr + Ent_wait_reselect);
		return (acb != NULL);
	}
	if (dstat & OSIOP_DSTAT_SIR &&
	    (intcode == A_int_disc || intcode == A_int_disc_wodp)) {
		/* Disconnect */
		if (acb == NULL) {
			printf("%s: Disconnect with no active command?\n",
			    sc->sc_dev.dv_xname);
			return (0);
		}
#ifdef OSIOP_DEBUG
		if (osiop_debug & DEBUG_DISC) {
			printf("%s: ID %02x disconnected TEMP %x (+%lx) "
			    "curaddr %lx curlen %lx buf %x len %x dfifo %x "
			    "dbc %x sstat1 %x starts %d acb %p\n",
			    sc->sc_dev.dv_xname, 1 << target,
			    osiop_read_4(sc, OSIOP_TEMP),
			    (osiop_read_4(sc, OSIOP_TEMP) != 0) ?
			        osiop_read_4(sc, OSIOP_TEMP) - scraddr : 0,
			    acb->curaddr, acb->curlen,
			    ds->data[0].addr, ds->data[0].count,
			    dfifo, dbc, sstat1, osiopstarts, acb);
			bus_dmamap_sync(sc->sc_dmat, dsdma,
			    acb->dsoffset, sizeof(struct osiop_ds),
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		}
#endif
		/*
		 * XXXX need to update curaddr/curlen to reflect
		 * current data transferred.  If device disconnected in
		 * the middle of a DMA block, they should already be set
		 * by the phase change interrupt.  If the disconnect
		 * occurs on a DMA block boundary, we have to figure out
		 * which DMA block it was.
		 */
		if (acb->datalen > 0 &&
		    osiop_read_4(sc, OSIOP_TEMP) != 0) {
			long n = osiop_read_4(sc, OSIOP_TEMP) - scraddr;

			if (acb->curlen != 0 &&
			    acb->curlen != ds->data[0].count)
				printf("%s: curaddr/curlen already set? "
				    "n %lx iob %lx/%lx chain[0] %x/%x\n",
				    sc->sc_dev.dv_xname, n,
				    acb->curaddr, acb->curlen,
				    ds->data[0].addr, ds->data[0].count);
			if (n < Ent_datain)
				n = (n - Ent_dataout) / 16;
			else
				n = (n - Ent_datain) / 16;
			if (n < 0 || n >= OSIOP_NSG)
				printf("TEMP invalid %ld\n", n);
			else {
				acb->curaddr = ds->data[n].addr;
				acb->curlen = ds->data[n].count;
			}
#ifdef OSIOP_DEBUG
			if (osiop_debug & DEBUG_DISC) {
				printf("%s: TEMP offset %ld",
				    sc->sc_dev.dv_xname, n);
				printf(" curaddr %lx curlen %lx\n",
				    acb->curaddr, acb->curlen);
			}
#endif
		}
		/*
		 * If data transfer was interrupted by disconnect, curaddr
		 * and curlen should reflect the point of interruption.
		 * Adjust the DMA chain so that the data transfer begins
		 * at the appropriate place upon reselection.
		 * XXX This should only be done on save data pointer message?
		 */
		if (acb->curlen > 0) {
			int i, j;
#ifdef OSIOP_DEBUG
			if (osiop_debug & DEBUG_DISC)
				printf("%s: adjusting DMA chain\n",
				    sc->sc_dev.dv_xname);
			if (intcode == A_int_disc_wodp)
				printf("%s: ID %02x disconnected "
				    "without Save Data Pointers\n",
				    sc->sc_dev.dv_xname, 1 << target);
#endif
			for (i = 0; i < OSIOP_NSG; i++) {
				if (ds->data[i].count == 0)
					break;
				if (acb->curaddr >= ds->data[i].addr &&
				    acb->curaddr <
				    (ds->data[i].addr + ds->data[i].count))
					break;
			}
			if (i >= OSIOP_NSG || ds->data[i].count == 0) {
				printf("couldn't find saved data pointer: "
				    "curaddr %lx curlen %lx i %d\n",
				    acb->curaddr, acb->curlen, i);
#if defined(OSIOP_DEBUG) && defined(DDB)
				Debugger();
#endif
			}
#ifdef OSIOP_DEBUG
			if (osiop_debug & DEBUG_DISC)
				printf(" chain[0]: %x/%x -> %lx/%lx\n",
				    ds->data[0].addr, ds->data[0].count,
				    acb->curaddr, acb->curlen);
#endif
			ds->data[0].addr = acb->curaddr;
			ds->data[0].count = acb->curlen;
			for (j = 1, i = i + 1;
			    i < OSIOP_NSG && ds->data[i].count > 0;
			    i++, j++) {
#ifdef OSIOP_DEBUG
				if (osiop_debug & DEBUG_DISC)
					printf("  chain[%d]: %x/%x -> %x/%x\n",
					    j,
					    ds->data[j].addr, ds->data[j].count,
					    ds->data[i].addr, ds->data[i].count);
#endif
				ds->data[j].addr  = ds->data[i].addr;
				ds->data[j].count = ds->data[i].count;
			}
			if (j < OSIOP_NSG) {
				ds->data[j].addr  = 0;
				ds->data[j].count = 0;
			}
			bus_dmamap_sync(sc->sc_dmat, dsdma,
			    acb->dsoffset, sizeof(struct osiop_ds),
			    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		}
		sc->sc_tinfo[target].dconns++;
		/*
		 * add nexus to waiting list
		 * clear nexus
		 * try to start another command for another target/lun
		 */
		acb->intstat = sc->sc_flags & OSIOP_INTSOFF;
		TAILQ_INSERT_TAIL(&sc->nexus_list, acb, chain);
		sc->sc_nexus = NULL;		/* no current device */
		osiop_write_4(sc, OSIOP_DSP, scraddr + Ent_wait_reselect);
		/* XXXX start another command ? */
		osiop_sched(sc);
		return (0);
	}
	if (dstat & OSIOP_DSTAT_SIR && intcode == A_int_reconnect) {
		int reselid = ffs(osiop_read_4(sc, OSIOP_SCRATCH) & 0xff) - 1;
		int reselun = osiop_read_1(sc, OSIOP_SFBR) & 0x07;
#ifdef OSIOP_DEBUG
		u_int8_t resmsg;
#endif

		/* Reconnect */
		/* XXXX save current SBCL */
		sc->sc_sstat1 = osiop_read_1(sc, OSIOP_SBCL);
#ifdef OSIOP_DEBUG
		if (osiop_debug & DEBUG_DISC)
			printf("%s: target ID %02x reselected dsps %x\n",
			    sc->sc_dev.dv_xname, reselid, intcode);
		resmsg = osiop_read_1(sc, OSIOP_SFBR);
		if (!MSG_ISIDENTIFY(resmsg))
			printf("%s: Reselect message in was not identify: "
			    "%02x\n", sc->sc_dev.dv_xname, resmsg);
#endif
		if (sc->sc_nexus != NULL) {
			struct scsi_link *periph =
			    sc->sc_nexus->xs->sc_link;
#ifdef OSIOP_DEBUG
			if (osiop_debug & DEBUG_DISC)
				printf("%s: reselect ID %02x w/active\n",
				    sc->sc_dev.dv_xname, reselid);
#endif
			TAILQ_INSERT_HEAD(&sc->ready_list,
			    sc->sc_nexus, chain);
			sc->sc_tinfo[periph->target].lubusy
			    &= ~(1 << periph->lun);
			sc->sc_active--;
		}
		/*
		 * locate acb of reselecting device
		 * set sc->sc_nexus to acb
		 */
		TAILQ_FOREACH(acb, &sc->nexus_list, chain) {
			struct scsi_link *periph = acb->xs->sc_link;
			if (reselid != periph->target ||
			    reselun != periph->lun) {
				continue;
			}
			TAILQ_REMOVE(&sc->nexus_list, acb, chain);
			sc->sc_nexus = acb;
			sc->sc_flags |= acb->intstat;
			acb->intstat = 0;
			osiop_write_4(sc, OSIOP_DSA,
			    dsdma->dm_segs[0].ds_addr + acb->dsoffset);
			osiop_write_1(sc, OSIOP_SXFER,
			    sc->sc_tinfo[reselid].sxfer);
			osiop_write_1(sc, OSIOP_SBCL,
			    sc->sc_tinfo[reselid].sbcl);
			break;
		}
		if (acb == NULL) {
			printf("%s: target ID %02x reselect nexus_list %p\n",
			    sc->sc_dev.dv_xname, reselid,
			    TAILQ_FIRST(&sc->nexus_list));
			panic("unable to find reselecting device");
		}

		osiop_write_4(sc, OSIOP_TEMP, 0);
		osiop_write_1(sc, OSIOP_DCNTL,
		    osiop_read_1(sc, OSIOP_DCNTL) | OSIOP_DCNTL_STD);
		return (0);
	}
	if (dstat & OSIOP_DSTAT_SIR && intcode == A_int_connect) {
#ifdef OSIOP_DEBUG
		u_int8_t ctest2 = osiop_read_1(sc, OSIOP_CTEST2);

		/* reselect was interrupted (by Sig_P or select) */
		if (osiop_debug & DEBUG_DISC ||
		    (ctest2 & OSIOP_CTEST2_SIGP) == 0)
			printf("%s: reselect interrupted (Sig_P?) "
			    "scntl1 %x ctest2 %x sfbr %x istat %x/%x\n",
			    sc->sc_dev.dv_xname,
			    osiop_read_1(sc, OSIOP_SCNTL1), ctest2,
			    osiop_read_1(sc, OSIOP_SFBR), istat,
			    osiop_read_1(sc, OSIOP_ISTAT));
#endif
		/* XXX assumes it was not select */
		if (sc->sc_nexus == NULL) {
#ifdef OSIOP_DEBUG
			printf("%s: reselect interrupted, sc_nexus == NULL\n",
			    sc->sc_dev.dv_xname);
#if 0
			osiop_dump(sc);
#endif
#endif
			osiop_write_1(sc, OSIOP_DCNTL,
			    osiop_read_1(sc, OSIOP_DCNTL) | OSIOP_DCNTL_STD);
			return (0);
		}
		target = sc->sc_nexus->xs->sc_link->target;
		osiop_write_4(sc, OSIOP_TEMP, 0);
		osiop_write_4(sc, OSIOP_DSA,
		    dsdma->dm_segs[0].ds_addr + sc->sc_nexus->dsoffset);
		osiop_write_1(sc, OSIOP_SXFER, sc->sc_tinfo[target].sxfer);
		osiop_write_1(sc, OSIOP_SBCL, sc->sc_tinfo[target].sbcl);
		osiop_write_4(sc, OSIOP_DSP, scraddr + Ent_scripts);
		return (0);
	}
	if (dstat & OSIOP_DSTAT_SIR && intcode == A_int_msgin) {
		/* Unrecognized message in byte */
		if (acb == NULL) {
			printf("%s: Bad message-in with no active command?\n",
			    sc->sc_dev.dv_xname);
			return (0);
		}
		printf("%s: Unrecognized message in data "
		    "sfbr %x msg %x sbcl %x\n", sc->sc_dev.dv_xname,
		    osiop_read_1(sc, OSIOP_SFBR), ds->msgbuf[1],
		    osiop_read_1(sc, OSIOP_SBCL));
		/* what should be done here? */
		osiop_write_4(sc, OSIOP_DSP, scraddr + Ent_switch);
		bus_dmamap_sync(sc->sc_dmat, dsdma,
		    acb->dsoffset, sizeof(struct osiop_ds),
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
		return (0);
	}
	if (dstat & OSIOP_DSTAT_SIR && intcode == A_int_status) {
		/* Status phase wasn't followed by message in phase? */
		printf("%s: Status phase not followed by message in phase? "
		    "sbcl %x sbdl %x\n", sc->sc_dev.dv_xname,
		    osiop_read_1(sc, OSIOP_SBCL),
		    osiop_read_1(sc, OSIOP_SBDL));
		if (osiop_read_1(sc, OSIOP_SBCL) == 0xa7) {
			/* It is now, just continue the script? */
			osiop_write_1(sc, OSIOP_DCNTL,
			    osiop_read_1(sc, OSIOP_DCNTL) | OSIOP_DCNTL_STD);
			return (0);
		}
	}
	if (dstat & OSIOP_DSTAT_SIR && sstat0 == 0) {
		printf("OSIOP interrupt: %x sts %x msg %x %x sbcl %x\n",
		    intcode, ds->stat[0], ds->msgbuf[0], ds->msgbuf[1],
		    osiop_read_1(sc, OSIOP_SBCL));
		osiop_reset(sc);
		*status = SCSI_OSIOP_NOSTATUS;
		return (0);	/* osiop_reset has cleaned up */
	}
	if (sstat0 & OSIOP_SSTAT0_SGE)
		printf("%s: SCSI Gross Error\n", sc->sc_dev.dv_xname);
	if (sstat0 & OSIOP_SSTAT0_PAR)
		printf("%s: Parity Error\n", sc->sc_dev.dv_xname);
	if (dstat & OSIOP_DSTAT_IID)
		printf("%s: Invalid instruction detected\n",
		    sc->sc_dev.dv_xname);
 bad_phase:
	/*
	 * temporary panic for unhandled conditions
	 * displays various things about the 53C710 status and registers
	 * then panics.
	 * XXXX need to clean this up to print out the info, reset, and continue
	 */
	printf("osiop_chkintr: target %x ds %p\n", target, ds);
	printf("scripts %lx ds %lx dsp %x dcmd %x\n", scraddr,
	    acb ? sc->sc_dsdma->dm_segs[0].ds_addr + acb->dsoffset : 0,
	    osiop_read_4(sc, OSIOP_DSP),
	    osiop_read_4(sc, OSIOP_DBC));
	printf("osiop_chkintr: istat %x dstat %x sstat0 %x "
	    "dsps %x dsa %x sbcl %x sts %x msg %x %x sfbr %x\n",
	    istat, dstat, sstat0, intcode,
	    osiop_read_4(sc, OSIOP_DSA),
	    osiop_read_1(sc, OSIOP_SBCL),
	    ds ? ds->stat[0] : 0,
	    ds ? ds->msgbuf[0] : 0,
	    ds ? ds->msgbuf[1] : 0,
	    osiop_read_1(sc, OSIOP_SFBR));
#ifdef OSIOP_DEBUG
	if (osiop_debug & DEBUG_DMA)
		panic("osiop_chkintr: **** temp ****");
#endif
	osiop_reset(sc);	/* hard reset */
	*status = SCSI_OSIOP_NOSTATUS;
	if (acb != NULL)
		acb->status = ACB_S_DONE;
	return (0);		/* osiop_reset cleaned up */
}

void
osiop_select(sc)
	struct osiop_softc *sc;
{
	struct osiop_acb *acb = sc->sc_nexus;

#ifdef OSIOP_DEBUG
	if (osiop_debug & DEBUG_CMD)
		printf("%s: select ", sc->sc_dev.dv_xname);
#endif

	if (acb->xsflags & SCSI_POLL || sc->sc_flags & OSIOP_NODMA) {
		sc->sc_flags |= OSIOP_INTSOFF;
		sc->sc_flags &= ~OSIOP_INTDEFER;
		if ((osiop_read_1(sc, OSIOP_ISTAT) & OSIOP_ISTAT_CON) == 0) {
			osiop_write_1(sc, OSIOP_SIEN, 0);
			osiop_write_1(sc, OSIOP_DIEN, 0);
		}
#if 0
	} else if ((sc->sc_flags & OSIOP_INTDEFER) == 0) {
		sc->sc_flags &= ~OSIOP_INTSOFF;
		if ((osiop_read_1(sc, OSIOP_ISTAT) & OSIOP_ISTAT_CON) == 0) {
			osiop_write_1(sc, OSIOP_SIEN, sc->sc_sien);
			osiop_write_1(sc, OSIOP_DIEN, sc->sc_dien);
		}
#endif
	}
#ifdef OSIOP_DEBUG
	if (osiop_debug & DEBUG_CMD)
		printf("osiop_select: target %x cmd %02x ds %p\n",
		    acb->xs->sc_link->target,
		    acb->ds->scsi_cmd.opcode, sc->sc_nexus->ds);
#endif

	osiop_start(sc);

	return;
}

/*
 * 53C710 interrupt handler
 */

void
osiop_intr(sc)
	struct osiop_softc *sc;
{
	int status, s;
	u_int8_t istat, dstat, sstat0;

	s = splbio();

	istat = sc->sc_istat;
	if ((istat & (OSIOP_ISTAT_SIP | OSIOP_ISTAT_DIP)) == 0) {
		splx(s);
		return;
	}

	/* Got a valid interrupt on this device; set by MD handler */
	dstat = sc->sc_dstat;
	sstat0 = sc->sc_sstat0;
	sc->sc_istat = 0;
#ifdef OSIOP_DEBUG
	if (!sc->sc_active) {
		/* XXX needs sync */
		printf("%s: spurious interrupt? "
		    "istat %x dstat %x sstat0 %x nexus %p status %x\n",
		    sc->sc_dev.dv_xname, istat, dstat, sstat0, sc->sc_nexus,
		    (sc->sc_nexus != NULL) ? sc->sc_nexus->ds->stat[0] : 0);
	}
#endif

#ifdef OSIOP_DEBUG
	if (osiop_debug & (DEBUG_INT|DEBUG_CMD)) {
		/* XXX needs sync */
		printf("%s: intr istat %x dstat %x sstat0 %x dsps %x "
		    "sbcl %x dsp %x dcmd %x sts %x msg %x\n",
		    sc->sc_dev.dv_xname,
		    istat, dstat, sstat0,
		    osiop_read_4(sc, OSIOP_DSPS),
		    osiop_read_1(sc, OSIOP_SBCL),
		    osiop_read_4(sc, OSIOP_DSP),
		    osiop_read_4(sc, OSIOP_DBC),
		    (sc->sc_nexus != NULL) ? sc->sc_nexus->ds->stat[0] : 0,
		    (sc->sc_nexus != NULL) ? sc->sc_nexus->ds->msgbuf[0] : 0);
	}
#endif
	if (sc->sc_flags & OSIOP_INTDEFER) {
		sc->sc_flags &= ~(OSIOP_INTDEFER | OSIOP_INTSOFF);
		osiop_write_1(sc, OSIOP_SIEN, sc->sc_sien);
		osiop_write_1(sc, OSIOP_DIEN, sc->sc_dien);
	}
	if (osiop_checkintr(sc, istat, dstat, sstat0, &status)) {
#if 0
		if (status == SCSI_OSIOP_NOSTATUS)
			printf("osiop_intr: no valid status \n");
#endif
		if ((sc->sc_flags & (OSIOP_INTSOFF | OSIOP_INTDEFER)) !=
		    OSIOP_INTSOFF) {
#if 0
			if (osiop_read_1(sc, OSIOP_SBCL) & OSIOP_BSY) {
				struct scsi_link *periph;

				periph = sc->sc_nexus->xs->sc_link;
				printf("%s: SCSI bus busy at completion"
				    " targ %d sbcl %02x sfbr %x lcrc "
				    "%02x dsp +%x\n", sc->sc_dev.dv_xname,
				    periph->periphtarget,
				    osiop_read_1(sc, OSIOP_SBCL),
				    osiop_read_1(sc, OSIOP_SFBR),
				    osiop_read_1(sc, OSIOP_LCRC),
				    osiop_read_4(sc, OSIOP_DSP) -
				        sc->sc_scrdma->dm_segs[0].ds_addr);
			}
#endif
			osiop_scsidone(sc->sc_nexus, status);
		}
	}
	splx(s);
}

void
osiop_update_xfer_mode(sc, target)
	struct osiop_softc *sc;
	int target;
{
	struct osiop_tinfo *ti = &sc->sc_tinfo[target];

	printf("%s: target %d now using 8 bit ", sc->sc_dev.dv_xname, target);

	ti->sxfer = 0;
	ti->sbcl = 0;
	if (ti->offset != 0) {
		scsi_period_to_osiop(sc, target);
		switch (ti->period) {
		case 0x00:
		case 0x01:
		case 0x02:
		case 0x03:
		case 0x04:
		case 0x05:
		case 0x06:
		case 0x07:
		case 0x08:
			/* Reserved transfer period factor */
			printf("??");
			break;
		case 0x09:
			/* Transfer period = 12.5 ns */
			printf("80");
			break;
		case 0x0a:
			/* Transfer period = 25 ns */
			printf("40");
			break;
		case 0x0b:
			/* Transfer period = 30.3 ns */
			printf("33");
			break;
		case 0x0c:
			/* Transfer period = 50 ns */
			printf("20");
			break;
		default:
			/* Transfer period = ti->period*4 ns */
			printf("%d", 1000/(ti->period*4));
			break;
		}
		printf(" MHz %d REQ/ACK offset", ti->offset);
	} else
		printf("asynch");

	printf(" xfers\n");
}

/*
 * This is based on the Progressive Peripherals 33MHz Zeus driver and will
 * not be correct for other 53c710 boards.
 *
 */
void
scsi_period_to_osiop(sc, target)
	struct osiop_softc *sc;
	int target;
{
	int period, offset, sxfer, sbcl;
#ifdef OSIOP_DEBUG
	int i;
#endif

	period = sc->sc_tinfo[target].period;
	offset = sc->sc_tinfo[target].offset;
#ifdef OSIOP_DEBUG
	if (osiop_debug & DEBUG_SYNC) {
		sxfer = 0;
		if (offset <= OSIOP_MAX_OFFSET)
			sxfer = offset;
		for (i = 0; i < sizeof(sync_tab) / sizeof(sync_tab[0]); i++) {
			if (period <= sync_tab[i].p) {
				sxfer |= sync_tab[i].r & 0x70;
				sbcl = sync_tab[i].r & 0x03;
				break;
			}
		}
		printf("osiop sync old: osiop_sxfr %02x, osiop_sbcl %02x\n",
		    sxfer, sbcl);
	}
#endif
	for (sbcl = 1; sbcl < 4; sbcl++) {
		sxfer = (period * 4 - 1) / sc->sc_tcp[sbcl] - 3;
		if (sxfer >= 0 && sxfer <= 7)
			break;
	}
	if (sbcl > 3) {
		printf("osiop sync: unable to compute sync params "
		    "for period %d ns\n", period * 4);
		/*
		 * XXX need to pick a value we can do and renegotiate
		 */
		sxfer = sbcl = 0;
	} else {
		sxfer = (sxfer << 4) | ((offset <= OSIOP_MAX_OFFSET) ?
		    offset : OSIOP_MAX_OFFSET);
#ifdef OSIOP_DEBUG
		if (osiop_debug & DEBUG_SYNC) {
			printf("osiop sync: params for period %dns: sxfer %x sbcl %x",
			    period * 4, sxfer, sbcl);
			printf(" actual period %dns\n",
			    sc->sc_tcp[sbcl] * ((sxfer >> 4) + 4));
		}
#endif
	}
	sc->sc_tinfo[target].sxfer = sxfer;
	sc->sc_tinfo[target].sbcl = sbcl;
#ifdef OSIOP_DEBUG
	if (osiop_debug & DEBUG_SYNC)
		printf("osiop sync: osiop_sxfr %02x, osiop_sbcl %02x\n",
		    sxfer, sbcl);
#endif
}

void
osiop_timeout(arg)
	void *arg;
{
	struct osiop_acb *acb = arg;
	struct scsi_xfer *xs = acb->xs;
	struct osiop_softc *sc = acb->sc;
	int s;

	sc_print_addr(xs->sc_link);
	printf("command 0x%02x timeout on xs %p\n", xs->cmd->opcode, xs);

	s = splbio();
	/* reset the scsi bus */
	osiop_resetbus(sc);

	acb->flags |= ACB_F_TIMEOUT;
	osiop_reset(sc);
	splx(s);
	return;
}

#ifdef OSIOP_DEBUG

#if OSIOP_TRACE_SIZE
void
osiop_dump_trace(void)
{
	int i;

	printf("osiop trace: next index %d\n", osiop_trix);
	i = osiop_trix;
	do {
		printf("%3d: '%c' %02x %02x %02x\n", i,
		    osiop_trbuf[i], osiop_trbuf[i + 1],
		    osiop_trbuf[i + 2], osiop_trbuf[i + 3]);
		i = (i + 4) & (OSIOP_TRACE_SIZE - 1);
	} while (i != osiop_trix);
}
#endif

void
osiop_dump_acb(acb)
	struct osiop_acb *acb;
{
	u_int8_t *b;
	int i;

	printf("acb@@%p ", acb);
	if (acb->xs == NULL) {
		printf("<unused>\n");
		return;
	}

	b = (u_int8_t *)&acb->ds->scsi_cmd;
	printf("(%d:%d) status %2x cmdlen %2ld cmd ",
	    acb->xs->sc_link->target,
	    acb->xs->sc_link->lun,
	    acb->status,
	    acb->ds->cmd.count);
	for (i = acb->ds->cmd.count; i > 0; i--)
		printf(" %02x", *b++);
	printf("\n");
	printf("  xs: %p data %p:%04x ", acb->xs, acb->data,
	    acb->datalen);
	printf("cur %lx:%lx\n", acb->curaddr, acb->curlen);
}

void
osiop_dump(sc)
	struct osiop_softc *sc;
{
	struct osiop_acb *acb;
	int i, s;

	s = splbio();
#if OSIOP_TRACE_SIZE
	osiop_dump_trace();
#endif
	printf("%s@@%p istat %02x\n",
	    sc->sc_dev.dv_xname, sc, osiop_read_1(sc, OSIOP_ISTAT));
	mtx_enter(&sc->free_list_mtx);
	if ((acb = TAILQ_FIRST(&sc->free_list)) != NULL) {
		printf("Free list:\n");
		while (acb) {
			osiop_dump_acb(acb);
			acb = TAILQ_NEXT(acb, chain);
		}
	}
	mtx_leave(&sc->free_list_mtx);
	if ((acb = TAILQ_FIRST(&sc->ready_list)) != NULL) {
		printf("Ready list:\n");
		while (acb) {
			osiop_dump_acb(acb);
			acb = TAILQ_NEXT(acb, chain);
		}
	}
	if ((acb = TAILQ_FIRST(&sc->nexus_list)) != NULL) {
		printf("Nexus list:\n");
		while (acb) {
			osiop_dump_acb(acb);
			acb = TAILQ_NEXT(acb, chain);
		}
	}
	if (sc->sc_nexus) {
		printf("Nexus:\n");
		osiop_dump_acb(sc->sc_nexus);
	}
	for (i = 0; i < OSIOP_NTGT; i++) {
		if (sc->sc_tinfo[i].cmds > 2) {
			printf("tgt %d: cmds %d disc %d lubusy %x\n",
			    i, sc->sc_tinfo[i].cmds,
			    sc->sc_tinfo[i].dconns,
			    sc->sc_tinfo[i].lubusy);
		}
	}
	splx(s);
}
#endif
@


1.49
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.48 2011/06/23 16:31:16 deraadt Exp $	*/
d415 1
a415 1
	bcopy(xs->cmd, &acb->ds->scsi_cmd, xs->cmdlen);
@


1.48
log
@a bit more ansi; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.47 2011/01/02 13:38:27 miod Exp $	*/
d270 1
a270 1
	acb = malloc(sizeof(*acb) * OSIOP_NACB, M_DEVBUF, M_NOWAIT | M_ZERO);
@


1.47
log
@Prevent a few more NULL pointer dereferences in troublesome situations; from
NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.46 2010/12/08 21:57:47 miod Exp $	*/
d1970 1
a1970 1
osiop_dump_trace()
@


1.46
log
@Reset acb->xs to NULL before scsi_done if option DIAGNOSTIC. There seem to be
one bad case of use-after-free after a hell lot of heavy I/O creeping in again
in this driver. This doesn't fix it but will hopefully help me diagnose once
it occurs again.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.45 2010/06/28 18:31:02 krw Exp $	*/
d717 3
d1680 1
a1680 1
	    sc->sc_dsdma->dm_segs[0].ds_addr + acb->dsoffset,
d1688 3
a1690 1
	    ds->stat[0], ds->msgbuf[0], ds->msgbuf[1],
@


1.45
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.44 2010/06/28 04:39:57 dlg Exp $	*/
d597 1
a597 1
		printf("osiop_scsidone: NULL acb or scsi_xfer\n");
d712 3
@


1.44
log
@implement iopools in osiop to get rid of another use of XS_NO_CCB.

original diff corrected by miod@@
tested by and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.43 2010/05/20 00:55:17 krw Exp $	*/
a189 7
struct scsi_device osiop_dev = {
	NULL,
	NULL,
	NULL,
	NULL,
};

a335 1
	sc->sc_link.device = &osiop_dev;
@


1.43
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.42 2010/05/19 15:27:35 oga Exp $	*/
d94 2
d327 3
d347 1
d369 26
d417 1
a417 16
	s = splbio();
	acb = TAILQ_FIRST(&sc->free_list);
	if (acb != NULL) {
		TAILQ_REMOVE(&sc->free_list, acb, chain);
	}
	else {
#ifdef DIAGNOSTIC
		sc_print_addr(periph);
		printf("unable to allocate acb\n");
		panic("osiop_scsipi_request");
#endif
		splx(s);
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}
a442 2
			TAILQ_INSERT_TAIL(&sc->free_list, acb, chain);
			splx(s);
d456 1
a719 1
		TAILQ_INSERT_TAIL(&sc->free_list, acb, chain);
d2025 1
d2033 1
@


1.42
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.41 2010/03/23 01:57:19 krw Exp $	*/
a397 1
		s = splbio();
a398 1
		splx(s);
@


1.41
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.40 2010/01/10 00:10:23 krw Exp $	*/
d209 1
a209 1
	    &seg, 1, &nseg, BUS_DMA_NOWAIT);
a231 1
	bzero(sc->sc_script, PAGE_SIZE);
d245 1
a245 1
	    &seg, 1, &nseg, BUS_DMA_NOWAIT);
a270 1
	bzero(sc->sc_ds, sizeof(struct osiop_ds) * OSIOP_NACB);
@


1.40
log
@Set ITSDONE in scsi_done() and zap trivial instances of setting it
in the drivers just before calling scsi_done().

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.39 2009/08/28 10:13:53 jasper Exp $	*/
d94 1
a94 1
int osiop_scsicmd(struct scsi_xfer *xs);
d369 1
a369 1
int
d399 5
a403 1
		return (NO_CCB);
d432 1
a432 1
			return (COMPLETE);
a460 5

	if (xs->flags & (SCSI_POLL | ITSDONE))
		return (COMPLETE);
	else
		return (SUCCESSFULLY_QUEUED);
@


1.39
log
@remove a bunch of unused Debugger()s.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.38 2009/03/03 19:08:25 miod Exp $	*/
a712 1
		xs->flags |= ITSDONE;
@


1.38
log
@Make sure the scsi_xfer timeout is triggered while the command is still alive.
With the current code, a fast command could complete between splx and
the timeout being triggered, we'd then happily return COMPLETE, reuse
the scsi_xfer, schedule the timeout again, causing a nice cycle in the
timeout wheels.

(I know, I know, I have to inspect all other scsi drivers now, but I'm
really tired after spending three hours on this)
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.37 2009/02/16 21:19:07 miod Exp $	*/
a699 5
#ifdef DDB
#if 0
				Debugger();
#endif
#endif
a972 5
#ifdef DDB
#if 0
		Debugger();
#endif
#endif
a1053 5
#ifdef DDB
#if 0
		Debugger();
#endif
#endif
a1177 3
#ifdef DDB
			Debugger();
#endif
a1342 3
#ifdef DDB
			Debugger();
#endif
a1602 3
#ifdef DDB
			Debugger();
#endif
a1685 5
#if 0
#ifdef DDB
	Debugger();
#endif
#endif
@


1.37
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.36 2009/01/21 21:54:00 grange Exp $	*/
d377 1
d443 8
d455 1
a455 1
	if ((acb->xsflags & SCSI_POLL) || (sc->sc_flags & OSIOP_NODMA))
a456 3
	else
		/* start expire timer */
		timeout_add_msec(&xs->stimeout, xs->timeout);
@


1.36
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.35 2008/11/24 00:31:35 krw Exp $	*/
d93 1
a93 1
void osiop_minphys(struct buf *);
d358 1
a358 2
osiop_minphys(bp)
	struct buf *bp;
a359 1

@


1.35
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.34 2008/09/12 11:14:04 miod Exp $	*/
d452 1
a452 1
		timeout_add(&xs->stimeout, (xs->timeout/1000) * hz);
d751 1
a751 1
			timeout_add(&xs->stimeout, (xs->timeout/1000) * hz);
@


1.34
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.33 2008/05/27 21:08:48 kettenis Exp $	*/
d400 1
a400 1
		return (TRY_AGAIN_LATER);
@


1.33
log
@Don't print SCSI ID, it's redundant now that scsibus(4) prints the same
information.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.32 2008/05/13 02:24:08 brad Exp $	*/
a378 4

	/* XXXX ?? */
	if (xs->flags & SCSI_DATA_UIO)
		panic("osiop: scsi data uio requested");
@


1.32
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.31 2007/11/05 00:21:36 krw Exp $	*/
d327 2
a328 2
	printf(": NCR53C710 rev %d, %dMHz, SCSI ID %d\n",
	    osiop_read_1(sc, OSIOP_CTEST8) >> 4, sc->sc_clock_freq, sc->sc_id);
@


1.31
log
@Take a bit more care to ensure that SCSI_POLL commands always return
COMPLETE and never SUCCESSFULLY_QUEUED.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.30 2007/10/01 04:03:51 krw Exp $	*/
a70 3

#include <sys/cdefs.h>
/* __KERNEL_RCSID(0, "$NetBSD: osiop.c,v 1.9 2002/04/05 18:27:54 bouyer Exp $"); */
@


1.30
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.29 2007/06/20 18:02:39 miod Exp $	*/
d461 3
a463 1
	if ((xs->flags & ITSDONE) == 0)
a464 2
	else
		return (COMPLETE);
@


1.29
log
@Better recovery when osiop goes nuts and spits
osiop0: osiop_select while connected?
in loops. Before returning from the interrupt handler, whack the chip.
Unfortunately, this causes the few i/o which were queued to time out,
but this is better than spinning and eventually panicing.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.28 2007/05/22 04:14:03 jsg Exp $	*/
d280 1
a280 2
	acb = malloc(sizeof(struct osiop_acb) * OSIOP_NACB,
	    M_DEVBUF, M_NOWAIT);
a284 1
	bzero(acb, sizeof(struct osiop_acb) * OSIOP_NACB);
@


1.28
log
@Remove broken URLs.
Fixes PRs 5482, 5483, 5484, 5486, 5487, 5488
Filed by casati@@nortel.com
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.27 2006/11/28 23:59:45 dlg Exp $	*/
d1336 1
d1338 3
d1715 1
d1720 1
d1723 2
a1724 1
	acb->status = ACB_S_DONE;
@


1.27
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.26 2005/12/03 16:53:16 krw Exp $	*/
a69 3
 *
 * The 53c710 datasheet is available at:
 * http://www.lsilogic.com/techlib/techdocs/storage_stand_prod/index.html
@


1.26
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.25 2005/11/21 22:55:43 miod Exp $	*/
d205 1
d353 3
d359 1
a359 1
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
@


1.25
log
@Do not dare dereferencing NULL pointers if OSIOP_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.24 2005/04/27 21:34:18 miod Exp $	*/
a406 1
		xs->error = XS_DRIVER_STUFFUP;
@


1.24
log
@In osiop_checkintr(), bail out early and do not claim the interrupt for
``can't happen'' situations (which happen sometimes on mvme88k), rather
than inadvertently dereference NULL pointers and panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.23 2004/12/27 15:53:13 miod Exp $	*/
d549 1
a549 1
			printf("%s: osiop_sched- nexus %p/%d ready %p/%d\n",
d551 2
a552 1
			    sc->sc_nexus->xs->sc_link->target,
d554 3
a556 1
			    TAILQ_FIRST(&sc->ready_list)->xs->sc_link->target);
@


1.23
log
@Gremlin crept in; found by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.22 2004/12/26 21:22:13 miod Exp $	*/
d1162 1
a1162 1
		if (acb == NULL)
d1165 2
d1212 1
a1212 1
		if (acb == NULL)
d1215 2
d1257 1
a1257 1
		if (acb == NULL)
d1260 2
d1330 1
a1330 1
		if (acb == NULL)
d1333 2
d1642 1
a1642 1
		if (acb == NULL)
d1645 2
@


1.22
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.21 2004/03/31 20:37:52 mickey Exp $	*/
d681 1
a681 1
	} else if (sc->ready_list.tqh_last == TAILQ_NEXT(acb, chain)) {
@


1.21
log
@cleanup some whitespaces
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.20 2004/03/15 13:03:44 miod Exp $	*/
d552 2
a553 2
			    sc->ready_list.tqh_first,
			    sc->ready_list.tqh_first->xs->sc_link->target);
d681 1
a681 1
	} else if (sc->ready_list.tqh_last == &acb->chain.tqe_next) {
d696 1
a696 1
			if (acb->chain.tqe_next != NULL) {
@


1.20
log
@No need for ADEV_NODOORLOCK quirk anymore; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.19 2004/01/09 21:32:23 brad Exp $	*/
d411 1
a411 1
 
d459 1
a459 1
	else	
d606 1
a606 1
	
a1158 1

d1871 1
a1871 1
		default: 
d1874 1
a1874 1
			break;	
@


1.19
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.18 2003/10/21 18:58:49 jmc Exp $	*/
a350 1
	sc->sc_link.quirks = ADEV_NODOORLOCK;
@


1.18
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.17 2003/09/29 09:08:19 miod Exp $	*/
a83 2

#include <uvm/uvm_extern.h>
@


1.17
log
@avaliable -> available
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.16 2003/08/11 06:20:57 mickey Exp $	*/
d117 1
a117 1
int osiop_reset_delay = 250;	/* delay after reset, in milleseconds */
d1013 1
a1013 1
	 * negotation here.
@


1.16
log
@make sure Debugger() is called only inside _both_ DDB and OSIOP_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.15 2003/08/03 19:32:34 mickey Exp $	*/
d71 1
a71 1
 * The 53c710 datasheet is avaliable at:
@


1.15
log
@use bus_dmamap_load_raw() instead of bus_dmamap_load() where appropriate; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.14 2003/06/02 23:28:02 millert Exp $	*/
d1483 1
a1483 1
#ifdef DDB
a1701 1
#endif
d1704 1
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.13 2003/05/19 21:32:18 krw Exp $	*/
d233 2
a234 2
	err = bus_dmamap_load(sc->sc_dmat, sc->sc_scrdma,
	    sc->sc_script, PAGE_SIZE, NULL, BUS_DMA_NOWAIT);
d273 2
a274 2
	err = bus_dmamap_load(sc->sc_dmat, sc->sc_dsdma, sc->sc_ds,
	    sizeof(struct osiop_ds) * OSIOP_NACB, NULL, BUS_DMA_NOWAIT);
@


1.13
log
@Put required delays between reading DSTAT and SSTAT0 registers. Add new ones
where required and modify existing ones to use a consistant delay(25).

From NetBSD with minor mods.

ok mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.12 2003/05/06 22:55:38 mickey Exp $	*/
d46 1
a46 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@make sure we always zero out ds (and get no trash from stack) and always warn about no acb where applicable; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.11 2003/05/06 22:40:57 mickey Exp $	*/
d520 1
d775 5
d783 1
a783 2
	    osiop_read_1(sc, OSIOP_DSTAT),
	    osiop_read_1(sc, OSIOP_SSTAT0),
d909 4
a912 1
	if (stat & OSIOP_ISTAT_DIP)
d914 1
@


1.11
log
@count auto-sense reqs as well; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.10 2003/05/06 22:01:43 mickey Exp $	*/
d1144 1
d1161 3
d1209 3
d1251 1
a1254 1
#endif
a1322 1
#ifdef OSIOP_DEBUG
d1326 1
@


1.10
log
@allow programming dma block bus transaction length on 710 and set to 8 words for hppa/osiop; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.9 2003/04/12 01:16:57 krw Exp $	*/
d758 1
@


1.9
log
@Fix index bounds checking in save data pointers logic.

Fix an indent problem and an extra blank space.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.8 2003/04/11 02:00:49 krw Exp $	*/
d882 1
a882 1
	osiop_write_1(sc, OSIOP_DMODE, OSIOP_DMODE_BL4);
@


1.8
log
@Delete a doubly redundant call to timeout_del() in osiop_timeout.
First, the only way to get there was if the timeout fired, in which
case timeout_del() is a noop. Second, it will be called in
osiop_scsidone() for every active command when osiop_reset() is called
in osiop_timeout().

From mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.7 2003/04/09 02:30:32 krw Exp $	*/
d1425 1
a1425 1
			if (n <= 0 && n > OSIOP_NSG)
a1448 1

d1486 5
a1490 4
			if (osiop_debug & DEBUG_DISC)
				printf("  chain[%d]: %x/%x -> %x/%x\n", j,
				    ds->data[j].addr, ds->data[j].count,
				    ds->data[i].addr, ds->data[i].count);
@


1.7
log
@Cleanup/make more consistant the various DEBUG flags and uses thereof.

Eliminate a couple of unused debug defines and variables.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.6 2003/04/09 00:47:54 krw Exp $	*/
a1955 2
	/* deactivate timeout */
	timeout_del(&xs->stimeout);
@


1.6
log
@Reduce default OSIOP_DEBUG output to a useful volume.

From mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.5 2003/04/08 18:03:46 krw Exp $	*/
d125 8
a132 7
#define DEBUG_DMA	0x01
#define DEBUG_INT	0x02
#define DEBUG_PHASE	0x04
#define DEBUG_UNEXCEPT	0x08
#define DEBUG_DISC	0x10
#define DEBUG_CMD	0x20
#define DEBUG_ALL	0xff
a133 2
int osiopsync_debug = 0;
int osiopdma_hits = 1;
d154 1
a154 1
#ifdef OSIOP_DEBUG_SYNC
d554 1
a554 1
		if (osiop_debug)
d576 1
a576 1
		if (osiop_debug)
d1016 1
a1016 1
			if (osiopsync_debug)
d1030 1
a1030 1
			if (osiopsync_debug)
d1210 1
a1210 1
			if (osiopsync_debug)
d1885 1
a1885 1
#ifdef DEBUG_SYNC
d1891 11
a1901 9
#ifdef DEBUG_SYNC
	sxfer = 0;
	if (offset <= OSIOP_MAX_OFFSET)
		sxfer = offset;
	for (i = 0; i < sizeof(sync_tab) / sizeof(sync_tab[0]); i++) {
		if (period <= sync_tab[i].p) {
			sxfer |= sync_tab[i].r & 0x70;
			sbcl = sync_tab[i].r & 0x03;
			break;
d1903 2
a1905 2
	printf("osiop sync old: osiop_sxfr %02x, osiop_sbcl %02x\n",
	    sxfer, sbcl);
d1922 7
a1928 5
#ifdef DEBUG_SYNC
		printf("osiop sync: params for period %dns: sxfer %x sbcl %x",
		    period * 4, sxfer, sbcl);
		printf(" actual period %dns\n",
		    sc->sc_tcp[sbcl] * ((sxfer >> 4) + 4));
d1933 4
a1936 2
#ifdef DEBUG_SYNC
	printf("osiop sync: osiop_sxfr %02x, osiop_sbcl %02x\n", sxfer, sbcl);
@


1.5
log
@Fix diagnostic output to display data buffer actually being used.

Fix setting of data buffer length when doing auto request sense.

Add a little general paranoia about setting data buffer length.

Eliminate $ifdef'ed field in acb structure, leaving diagnostic code
using it #ifdef'ed.

Mostly suggested by and ok mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.4 2003/04/06 20:24:31 krw Exp $	*/
d555 6
a560 5
		printf("%s: osiop_sched- nexus %p/%d ready %p/%d\n",
		    sc->sc_dev.dv_xname, sc->sc_nexus,
		    sc->sc_nexus->xs->sc_link->target,
		    sc->ready_list.tqh_first,
		    sc->ready_list.tqh_first->xs->sc_link->target);
d577 3
a579 2
		printf("%s: osiop_sched didn't find ready command\n",
		    sc->sc_dev.dv_xname);
@


1.4
log
@Fix a lot of issues in osiop.

In particular fix dma memory handling and as a result request sense
processing.

Much input/advice/testing from Mickey.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.3 2003/02/11 19:20:27 mickey Exp $	*/
d426 4
a429 1
	acb->datalen = xs->datalen;
d433 1
d741 4
d1998 2
a1999 2
	printf("  xs: %p data %p:%04x ", acb->xs, acb->xs->data,
	    acb->xs->datalen);
@


1.3
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.2 2003/02/02 01:50:30 krw Exp $	*/
a81 4
/* #define OSIOP_DEBUG */

/* #include "opt_ddb.h" */

d123 32
a189 31
#ifdef OSIOP_DEBUG
#define DEBUG_DMA	0x01
#define DEBUG_INT	0x02
#define DEBUG_PHASE	0x04
#define DEBUG_UNEXCEPT	0x08
#define DEBUG_DISC	0x10
#define DEBUG_CMD	0x20
#define DEBUG_ALL	0xff
int osiop_debug = 0; /*DEBUG_ALL;*/
int osiopsync_debug = 0;
int osiopdma_hits = 1;
int osiopstarts = 0;
int osiopints = 0;
int osiopphmm = 0;
int osiop_trix = 0;
#define OSIOP_TRACE_SIZE	128
#define OSIOP_TRACE(a,b,c,d)	do {				\
	osiop_trbuf[osiop_trix + 0] = (a);			\
	osiop_trbuf[osiop_trix + 1] = (b);			\
	osiop_trbuf[osiop_trix + 2] = (c);			\
	osiop_trbuf[osiop_trix + 3] = (d);			\
	osiop_trix = (osiop_trix + 4) & (OSIOP_TRACE_SIZE - 1);	\
} while (0)
u_int8_t osiop_trbuf[OSIOP_TRACE_SIZE];
void osiop_dump_trace(void);
void osiop_dump_acb(struct osiop_acb *);
void osiop_dump(struct osiop_softc *);
#else
#define OSIOP_TRACE(a,b,c,d)
#endif

d286 3
d297 1
d301 2
a302 1
	memset(sc->sc_tinfo, 0, sizeof(sc->sc_tinfo));
d310 1
a310 1
	for (i = 0; i < OSIOP_NACB; i++) {
a312 7
		/* XXX How much size is required for each command block? */
		err = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1, PAGE_SIZE,
		    0, BUS_DMA_NOWAIT, &acb->cmddma);
		if (err) {
			printf(": failed to create cmddma map, err=%d\n", err);
			return;
		}
d327 1
a338 2

		acb++;
d390 1
a390 3
	int err, flags, s;

	flags = xs->flags;
d393 1
a393 1
	if (flags & SCSI_DATA_UIO)
d397 1
a397 1
	if (sc->sc_nexus && flags & SCSI_POLL)
d423 4
a426 13

	/* Setup DMA map for SCSI command buffer */
	err = bus_dmamap_load(sc->sc_dmat, acb->cmddma,
	    xs->cmd, xs->cmdlen, NULL, BUS_DMA_NOWAIT);
	if (err) {
		printf("%s: unable to load cmd DMA map: %d",
		    sc->sc_dev.dv_xname, err);
		xs->error = XS_DRIVER_STUFFUP;
		TAILQ_INSERT_TAIL(&sc->free_list, acb, chain);
		scsi_done(xs);
		splx(s);
		return (COMPLETE);
	}
d429 1
a429 1
	if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
d431 1
a431 1
		    xs->data, xs->datalen, NULL,
d433 1
a433 1
		    ((xs->flags & SCSI_DATA_IN) ?
a439 1
			bus_dmamap_unload(sc->sc_dmat, acb->cmddma);
d445 1
a445 1
		    0, xs->datalen, (xs->flags & SCSI_DATA_IN) ?
a447 2
	bus_dmamap_sync(sc->sc_dmat, acb->cmddma, 0, xs->cmdlen,
	    BUS_DMASYNC_PREWRITE);
d449 5
a453 5
	acb->cmdlen = xs->cmdlen;
	acb->datalen = xs->datalen;
#ifdef OSIOP_DEBUG
	acb->data = xs->data;
#endif
d457 1
a457 2
	if (sc->sc_nexus == NULL)
		osiop_sched(sc);
d461 1
a461 1
	if (flags & SCSI_POLL || sc->sc_flags & OSIOP_NODMA)
d463 3
d497 1
a497 1
				    xs->cmd->opcode,
d545 1
a547 1
	int i;
d549 1
a550 1
	if (sc->sc_nexus != NULL) {
d556 1
a558 1
#endif
d561 2
a562 4
		i = periph->target;
		if ((sc->sc_tinfo[i].lubusy & (1 << periph->lun)) == 0) {
			struct osiop_tinfo *ti;

a564 1
			ti = &sc->sc_tinfo[i];
d578 1
a578 1
	if (acb->xs->flags & SCSI_RESET)
d593 1
a593 1
	int dosched = 0;
d607 8
d622 8
d634 4
a637 1
		xs->error = XS_NOERROR;
d643 4
a646 2
		bzero(&xs->sense, sizeof(struct scsi_sense_data));
		xs->error = XS_SENSE;
a668 11
	if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		bus_dmamap_sync(sc->sc_dmat, acb->datadma, 0, acb->datalen,
		    (xs->flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, acb->datadma);
	}

	bus_dmamap_sync(sc->sc_dmat, acb->cmddma, 0, acb->cmdlen,
	    BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, acb->cmddma);

a679 2
		if (!TAILQ_EMPTY(&sc->ready_list))
			dosched = 1;	/* start next command */
a711 4
	/* Put it on the free list. */
	acb->status = ACB_S_FREE;
	TAILQ_INSERT_TAIL(&sc->free_list, acb, chain);
	sc->sc_tinfo[periph->target].cmds++;
d713 42
a754 4
	timeout_del(&xs->stimeout);
	xs->resid = 0;
	xs->flags |= ITSDONE;
	scsi_done(xs);
d756 1
a756 2
	if (dosched && sc->sc_nexus == NULL)
		osiop_sched(sc);
a906 1
		sc->sc_nexus->flags = 0;
a912 1
		acb->flags = 0;
a982 3
	ds->cmd.count = acb->cmdlen;
	ds->cmd.addr = acb->cmddma->dm_segs[0].ds_addr;

d986 1
a986 1
	disconnect = (xs->cmd->opcode != REQUEST_SENSE) &&
d993 1
a993 1
	memset(&ds->data, 0, sizeof(ds->data));
d1034 1
a1034 1
	if (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
a1047 6
	/* handle timeout */
	timeout_set(&xs->stimeout, osiop_timeout, acb);
	if ((xs->flags & SCSI_POLL) == 0) {
		/* start expire timer */
		timeout_add(&xs->stimeout, (xs->timeout/1000) * hz);
	}
d1505 1
a1505 2
		if (!TAILQ_EMPTY(&sc->ready_list))
			osiop_sched(sc);
d1701 1
a1701 1
	if (acb->xs->flags & SCSI_POLL || sc->sc_flags & OSIOP_NODMA) {
d1721 1
a1721 1
		    acb->xs->cmd->opcode, sc->sc_nexus->ds);
d1935 1
a1935 1
	printf("command timeout\n");
d1981 1
a1981 1
	b = (u_int8_t *)&acb->xs->cmd;
d1984 4
a1987 2
	    acb->xs->sc_link->lun, acb->status, acb->cmdlen);
	for (i = acb->cmdlen; i > 0; i--)
a1991 1
	printf("va %p:%lx ", acb->data, acb->datalen);
@


1.3.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.3 2003/02/11 19:20:27 mickey Exp $	*/
d82 4
d127 1
a127 32
/* #define OSIOP_DEBUG */
#ifdef OSIOP_DEBUG
#define DEBUG_DMA	0x0001
#define DEBUG_INT	0x0002
#define DEBUG_PHASE	0x0004
#define DEBUG_DISC	0x0008
#define DEBUG_CMD	0x0010
#define DEBUG_SYNC	0x0020
#define DEBUG_SCHED	0x0040
#define DEBUG_ALL	0xffff
int osiop_debug = 0; /*DEBUG_ALL;*/
int osiopstarts = 0;
int osiopints = 0;
int osiopphmm = 0;
int osiop_trix = 0;
#define OSIOP_TRACE_SIZE	128
#define OSIOP_TRACE(a,b,c,d)	do {				\
	osiop_trbuf[osiop_trix + 0] = (a);			\
	osiop_trbuf[osiop_trix + 1] = (b);			\
	osiop_trbuf[osiop_trix + 2] = (c);			\
	osiop_trbuf[osiop_trix + 3] = (d);			\
	osiop_trix = (osiop_trix + 4) & (OSIOP_TRACE_SIZE - 1);	\
} while (0)
u_int8_t osiop_trbuf[OSIOP_TRACE_SIZE];
void osiop_dump_trace(void);
void osiop_dump_acb(struct osiop_acb *);
void osiop_dump(struct osiop_softc *);
#else
#define OSIOP_TRACE(a,b,c,d)
#endif

#ifdef OSIOP_DEBUG
d162 31
a288 3
	/*
	 * Allocate (malloc) memory for acb's.
	 */
a296 1

d300 1
a300 2

	bzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));
d308 1
a308 1
	for (i = 0; i < OSIOP_NACB; i++, acb++) {
d311 7
a331 1
		acb->ds->cmd.addr = dsa + OSIOP_DSCMDOFF;
d343 2
d396 3
a398 1
	int err, s;
d401 1
a401 1
	if (xs->flags & SCSI_DATA_UIO)
d405 1
a405 1
	if (sc->sc_nexus && (xs->flags & SCSI_POLL))
d431 13
a443 7
	acb->xsflags = xs->flags;
	bcopy(xs->cmd, &acb->ds->scsi_cmd, xs->cmdlen);
	acb->ds->cmd.count = xs->cmdlen;
	acb->datalen = 0;
#ifdef OSIOP_DEBUG
	acb->data = xs->data;
#endif
d446 1
a446 2
	if (acb->xsflags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		acb->datalen = xs->datalen;
d448 1
a448 1
		    xs->data, acb->datalen, NULL,
d450 1
a450 1
		    ((acb->xsflags & SCSI_DATA_IN) ?
d457 1
d463 1
a463 1
		    0, acb->datalen, (acb->xsflags & SCSI_DATA_IN) ?
d466 2
d469 5
a473 5
	/*
	 * Always initialize timeout so it does not contain trash
	 * that could confuse timeout_del().
	 */
	timeout_set(&xs->stimeout, osiop_timeout, acb);
d477 2
a478 1
	osiop_sched(sc);
d482 1
a482 1
	if ((acb->xsflags & SCSI_POLL) || (sc->sc_flags & OSIOP_NODMA))
a483 3
	else	
		/* start expire timer */
		timeout_add(&xs->stimeout, (xs->timeout/1000) * hz);
d515 1
a515 1
				    acb->ds->scsi_cmd.opcode,
a562 1
	struct osiop_tinfo *ti;
d565 1
a566 1
	if ((sc->sc_nexus != NULL) || TAILQ_EMPTY(&sc->ready_list)) {
d568 6
a573 7
		if (osiop_debug & DEBUG_SCHED)
			printf("%s: osiop_sched- nexus %p/%d ready %p/%d\n",
			    sc->sc_dev.dv_xname, sc->sc_nexus,
			    sc->sc_nexus->xs->sc_link->target,
			    sc->ready_list.tqh_first,
			    sc->ready_list.tqh_first->xs->sc_link->target);
#endif
d576 1
d579 4
a582 2
		ti = &sc->sc_tinfo[periph->target];
		if ((ti->lubusy & (1 << periph->lun)) == 0) {
d585 1
d593 2
a594 3
		if (osiop_debug & DEBUG_SCHED)
			printf("%s: osiop_sched didn't find ready command\n",
			    sc->sc_dev.dv_xname);
d599 1
a599 1
	if (acb->xsflags & SCSI_RESET)
d614 1
a614 1
	int autosense;
a627 8
	
	/*
	 * Record if this is the completion of an auto sense
	 * scsi command, and then reset the flag so we don't loop
	 * when such a command fails or times out.
	 */
	autosense = acb->flags & ACB_F_AUTOSENSE;
	acb->flags &= ~ACB_F_AUTOSENSE;
a634 8
	if (acb->xsflags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		bus_dmamap_sync(sc->sc_dmat, acb->datadma, 0, acb->datalen,
		    (acb->xsflags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, acb->datadma);
	}

	timeout_del(&xs->stimeout);
d639 1
a639 4
		if (autosense == 0)
			xs->error = XS_NOERROR;
		else
			xs->error = XS_SENSE;
d645 2
a646 4
		if (autosense == 0)
			acb->flags |= ACB_F_AUTOSENSE;
		else
			xs->error = XS_DRIVER_STUFFUP;
d669 11
d691 2
d725 4
d730 4
a733 6
	if ((acb->flags & ACB_F_AUTOSENSE) == 0) {
		/* Put it on the free list. */
FREE:
		acb->status = ACB_S_FREE;
		TAILQ_INSERT_TAIL(&sc->free_list, acb, chain);
		sc->sc_tinfo[periph->target].cmds++;
d735 2
a736 42
		xs->resid = 0;
		xs->flags |= ITSDONE;
		scsi_done(xs);
	} else {
		/* Set up REQUEST_SENSE command */
		struct scsi_sense *cmd = (struct scsi_sense *)&acb->ds->scsi_cmd;
		int err;

		bzero(cmd, sizeof(*cmd));
		acb->ds->cmd.count = sizeof(*cmd);
		cmd->opcode = REQUEST_SENSE;
		cmd->byte2  = xs->sc_link->lun << 5;
		cmd->length = sizeof(xs->sense);

		/* Setup DMA map for data buffer */
		acb->xsflags &= SCSI_POLL | SCSI_NOSLEEP;
		acb->xsflags |= SCSI_DATA_IN;
		acb->datalen  = sizeof xs->sense;
#ifdef OSIOP_DEBUG
		acb->data = &xs->sense;
#endif
		err = bus_dmamap_load(sc->sc_dmat, acb->datadma,
		    &xs->sense, sizeof(xs->sense), NULL,
		    BUS_DMA_NOWAIT | BUS_DMA_STREAMING | BUS_DMA_READ);
		if (err) {
			printf("%s: unable to load REQUEST_SENSE data DMA map: %d",
			    sc->sc_dev.dv_xname, err);
			xs->error = XS_DRIVER_STUFFUP;
			goto FREE;
		}
		bus_dmamap_sync(sc->sc_dmat, acb->datadma,
		    0, sizeof(xs->sense), BUS_DMASYNC_PREREAD);

		sc->sc_tinfo[periph->target].senses++;
		acb->status  = ACB_S_READY;
		TAILQ_INSERT_HEAD(&sc->ready_list, acb, chain);
		if (((acb->xsflags & SCSI_POLL) == 0) && ((sc->sc_flags & OSIOP_NODMA) == 0))
			/* start expire timer */
			timeout_add(&xs->stimeout, (xs->timeout/1000) * hz);
	}

	osiop_sched(sc);
d853 1
a853 1
	osiop_write_1(sc, OSIOP_DMODE, sc->sc_dmode);
d887 1
d894 1
d965 3
d971 1
a971 1
	disconnect = (ds->scsi_cmd.opcode != REQUEST_SENSE) &&
d978 1
a978 1
	bzero(&ds->data, sizeof(ds->data));
d992 1
a992 1
			if (osiop_debug & DEBUG_SYNC)
d1006 1
a1006 1
			if (osiop_debug & DEBUG_SYNC)
d1019 1
a1019 1
	if (acb->xsflags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
d1033 6
a1124 1
	ds = NULL;
a1140 3
		if (acb == NULL)
			printf("%s: COMPLETE with no active command?\n",
			    sc->sc_dev.dv_xname);
a1185 3
		if (acb == NULL)
			printf("%s: Sync message with no active command?\n",
			    sc->sc_dev.dv_xname);
d1192 1
a1192 1
			if (osiop_debug & DEBUG_SYNC)
a1224 1
#endif
d1228 1
d1297 1
a1300 1
#ifdef OSIOP_DEBUG
d1407 1
a1407 1
			if (n < 0 || n >= OSIOP_NSG)
d1431 1
d1469 4
a1472 5
				if (osiop_debug & DEBUG_DISC)
					printf("  chain[%d]: %x/%x -> %x/%x\n",
					    j,
					    ds->data[j].addr, ds->data[j].count,
					    ds->data[i].addr, ds->data[i].count);
d1496 2
a1497 1
		osiop_sched(sc);
d1693 1
a1693 1
	if (acb->xsflags & SCSI_POLL || sc->sc_flags & OSIOP_NODMA) {
d1713 1
a1713 1
		    acb->ds->scsi_cmd.opcode, sc->sc_nexus->ds);
d1868 1
a1868 1
#ifdef OSIOP_DEBUG
d1874 9
a1882 11
#ifdef OSIOP_DEBUG
	if (osiop_debug & DEBUG_SYNC) {
		sxfer = 0;
		if (offset <= OSIOP_MAX_OFFSET)
			sxfer = offset;
		for (i = 0; i < sizeof(sync_tab) / sizeof(sync_tab[0]); i++) {
			if (period <= sync_tab[i].p) {
				sxfer |= sync_tab[i].r & 0x70;
				sbcl = sync_tab[i].r & 0x03;
				break;
			}
a1883 2
		printf("osiop sync old: osiop_sxfr %02x, osiop_sbcl %02x\n",
		    sxfer, sbcl);
d1885 2
d1903 5
a1907 7
#ifdef OSIOP_DEBUG
		if (osiop_debug & DEBUG_SYNC) {
			printf("osiop sync: params for period %dns: sxfer %x sbcl %x",
			    period * 4, sxfer, sbcl);
			printf(" actual period %dns\n",
			    sc->sc_tcp[sbcl] * ((sxfer >> 4) + 4));
		}
d1912 2
a1913 4
#ifdef OSIOP_DEBUG
	if (osiop_debug & DEBUG_SYNC)
		printf("osiop sync: osiop_sxfr %02x, osiop_sbcl %02x\n",
		    sxfer, sbcl);
d1927 1
a1927 1
	printf("command 0x%02x timeout on xs %p\n", xs->cmd->opcode, xs);
d1933 2
d1973 1
a1973 1
	b = (u_int8_t *)&acb->ds->scsi_cmd;
d1976 2
a1977 4
	    acb->xs->sc_link->lun,
	    acb->status,
	    acb->ds->cmd.count);
	for (i = acb->ds->cmd.count; i > 0; i--)
d1980 3
a1982 2
	printf("  xs: %p data %p:%04x ", acb->xs, acb->data,
	    acb->datalen);
@


1.3.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.3.4.1 2003/05/13 19:35:02 ho Exp $	*/
d46 5
a50 1
 * 3. Neither the name of the University nor the names of its contributors
a519 1
		delay(25); /* Need delay between SSTAT0 and DSTAT reads */
a773 5
	u_int8_t dstat, sstat0;

	sstat0 = osiop_read_1(sc, OSIOP_SSTAT0);
	delay(25); /* Need delay between SSTAT0 and DSTAT reads */
	dstat = osiop_read_1(sc, OSIOP_DSTAT);
d777 2
a778 1
	    dstat, sstat0,
d904 1
a904 4
	if (stat & OSIOP_ISTAT_DIP) {
		if (stat & OSIOP_ISTAT_SIP)
			/* Need delay between SSTAT0 and DSTAT reads */
			delay(25);
a905 1
	}
@


1.3.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
a71 1
 * The 53c710 datasheet is available at:
d85 2
d117 1
a117 1
int osiop_reset_delay = 250;	/* delay after reset, in milliseconds */
d233 2
a234 2
	err = bus_dmamap_load_raw(sc->sc_dmat, sc->sc_scrdma,
	    &seg, nseg, PAGE_SIZE, BUS_DMA_NOWAIT);
d273 2
a274 2
	err = bus_dmamap_load_raw(sc->sc_dmat, sc->sc_dsdma,
	    &seg, nseg, sizeof(struct osiop_ds) * OSIOP_NACB, BUS_DMA_NOWAIT);
d1013 1
a1013 1
	 * negotiation here.
d1483 1
a1483 1
#if defined(OSIOP_DEBUG) && defined(DDB)
d1702 1
a1704 1
#endif
@


1.3.4.4
log
@Merge with the trunk
@
text
@d351 1
d412 1
a412 1

d460 1
a460 1
	else
d607 1
a607 1

d1160 1
d1873 1
a1873 1
		default:
d1876 1
a1876 1
			break;
@


1.2
log
@Real (although generic) negotiation results message during boot.
@
text
@d1 1
a1 1
/*	$OpenBSD: osiop.c,v 1.1 2003/01/08 02:11:38 krw Exp $	*/
d1858 1
a1858 1
 * This is based on the Progressive Peripherals 33Mhz Zeus driver and will
@


1.1
log
@Merry Christmas Mickey!

First cut at osiop driver (LSI Logic/Symbios/NCR 53C710). For hppa
only at the moment.

Functional for the most part, but there are known problems:

1) SCSI_CHECK/REQUEST_SENSE not handled at all - simply returns a
zero'ed scsi_sense_data buffer. As a result all osiop sc_link's are
created with the ADEV_NODOORLOCK quirk to suppress PREVENT_ALLOW
commands from being issued (and failing) during probe.

2) Sync negotiation (wide is not supported on this chip) needs to be
validated due to some ominous comments in the source about being valid
only for the 33Mhz Zeus board.

3) Probe message needs fixing/completion to issue useful info. See 2).

4) Timeout/hangs occur under heavy load, e.g. make builds.

From NetBSD.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1810 1
a1810 1
	printf("%s: target %d using ", sc->sc_dev.dv_xname, target);
d1816 35
a1850 1
		printf("Synchronous (%d offset %d period) ");
d1852 1
a1852 1
		printf("Asynchronous ");
d1854 1
a1854 1
	printf("data transfers\n");
@

