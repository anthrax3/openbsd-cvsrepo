head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.34
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.36
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.30
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.32
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.24
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.28
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.26
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.22
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.20
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.16
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.18
	OPENBSD_5_0:1.10.0.14
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.12
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.10
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.6
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.26
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.24
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.22
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.20
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.18
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.16
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.14
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.12
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.10
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.05.17.25.58;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.08.26.02.39.05;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.15.16.27.53;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.29.00.04.31;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.29.20.15.59;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.05.22.20.39;	author deraadt;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	98.12.30.15.13.04;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	98.11.17.06.14.58;	author downsj;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.23.21;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2002.03.28.11.50.59;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@/*	$OpenBSD: adw.h,v 1.9 2002/03/14 01:26:53 millert Exp $ */
/*      $NetBSD: adw.h,v 1.9 2000/05/26 15:13:43 dante Exp $        */

/*
 * Generic driver definitions and exported functions for the Advanced
 * Systems Inc. SCSI controllers
 * 
 * Copyright (c) 1998, 1999, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Author: Baldassare Dante Profeta <dante@@mclink.it>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _ADVANSYS_WIDE_H_
#define _ADVANSYS_WIDE_H_

/******************************************************************************/

typedef int (* ADW_ISR_CALLBACK) (ADW_SOFTC *, ADW_SCSI_REQ_Q *);
typedef void (* ADW_ASYNC_CALLBACK) (ADW_SOFTC *, u_int8_t);


/*
 * per request scatter-gather element limit
 * We could have up to 256 SG lists.
 */
#define ADW_MAX_SG_LIST		255

/* 
 * Scatter-Gather Definitions per request.
 */

#define NO_OF_SG_PER_BLOCK	15

/* Number of SG blocks needed. */
#define ADW_NUM_SG_BLOCK \
	((ADW_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK)


struct adw_ccb {
	ADW_SCSI_REQ_Q		scsiq;
	ADW_SG_BLOCK		sg_block[ADW_NUM_SG_BLOCK];

	struct scsi_sense_data  scsi_sense;

	TAILQ_ENTRY(adw_ccb)	chain;
	struct adw_ccb		*nexthash;
	u_int32_t		hashkey;

	struct scsi_xfer	*xs;	/* the scsi_xfer for this cmd */
	int			flags;	/* see below */

	int			timeout;

	/*
	 * This DMA map maps the buffer involved in the transfer.
	 */
	bus_dmamap_t		dmamap_xfer;
};

typedef struct adw_ccb ADW_CCB;

/* flags for ADW_CCB */
#define CCB_ALLOC	0x01
#define CCB_ABORTING	0x02
#define CCB_ABORTED	0x04


#define ADW_MAX_CCB	63	/* Max. number commands per device (63) */

struct adw_control {
	ADW_CCB		ccbs[ADW_MAX_CCB];	/* all our control blocks */
	ADW_CARRIER	*carriers;		/* all our carriers */
};

/*
 * Offset of a CCB from the beginning of the control DMA mapping.
 */
#define	ADW_CCB_OFF(c)	(offsetof(struct adw_control, ccbs[0]) +	\
		    (((u_long)(c)) - ((u_long)&sc->sc_control->ccbs[0])))

/******************************************************************************/

int adw_init(ADW_SOFTC *sc);
void adw_attach(ADW_SOFTC *sc);
int adw_intr(void *arg);
ADW_CCB *adw_ccb_phys_kv(ADW_SOFTC *, u_int32_t);

/******************************************************************************/

#endif /* _ADVANSYS_ADW_H_ */
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.h,v 1.8 2001/11/05 17:25:58 art Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.8
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.h,v 1.7 2001/08/26 02:39:05 krw Exp $ */
d112 4
a115 4
int adw_init __P((ADW_SOFTC *sc));
void adw_attach __P((ADW_SOFTC *sc));
int adw_intr __P((void *arg));
ADW_CCB *adw_ccb_phys_kv __P((ADW_SOFTC *, u_int32_t));
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.h,v 1.8 2001/11/05 17:25:58 art Exp $ */
d112 4
a115 4
int adw_init(ADW_SOFTC *sc);
void adw_attach(ADW_SOFTC *sc);
int adw_intr(void *arg);
ADW_CCB *adw_ccb_phys_kv(ADW_SOFTC *, u_int32_t);
@


1.7
log
@Prepare for transition to 5-parameter bus_dmamap_sync() by creating and
using *_bus_dmamap_sync() defines that are defined appropriately
depending on __HAS_NEW_BUS_DMAMAP_SYNC.

Most of the code changes are simple reversions to the original NetBSD
code.

Slip in a siop_script_sync() instead of a manually done code section.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.h,v 1.6 2001/01/15 16:27:53 krw Exp $ */
a117 9

#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define	adw_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (off), (len), (op))
#else
#define	adw_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (op))
#endif

@


1.6
log
@Use xs->stimeout instead of adding a struct timeout to ccb
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.h,v 1.5 2000/06/29 00:04:31 krw Exp $ */
d118 9
@


1.5
log
@Sync adw files with (almost) latest NetBSD versions:

adw.c     synched with v1.23 (from v1.14)
adw.h                  v1.9  (     v1.5 )
adwlib.c               v1.17 (     v1.7 )
adwlib.h               v1.13 (     v1.7 )
adwmcode.c             v1.5  (     v1.2 )
adwmcode.h             v1.5  (     v1.2 )

microcode for cards is updated to latest version,
loss of carrier problems are solved in a more
robust manner than before, lots of code cleanup.

first support for upcoming U3W cards added, as
a result of which the driver is now too large
for RAMDISK and has been moved to RAMDISKB.

Most of the work done by dante@@ NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.h,v 1.4 2000/04/29 20:15:59 krw Exp $ */
a81 1
	struct timeout          to;
@


1.4
log
@add $ tag
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*      $NetBSD: adw.h,v 1.5 2000/02/03 20:29:15 dante Exp $        */
a51 41
 * Every adw_carrier structure _MUST_ always be aligned on a 16 bytes boundary
 */
struct adw_carrier {
/* ---------- the microcode wants the field below ---------- */
	u_int32_t	unused;	  /* Carrier Virtual Address -UNUSED- */
	u_int32_t	carr_pa;  /* Carrier Physical Address */
	u_int32_t	areq_vpa; /* ADW_SCSI_REQ_Q Physical Address */
	/*
	 * next_vpa [31:4]	Carrier Physical Next Pointer
	 *
	 * next_vpa [3:1]	Reserved Bits
	 * next_vpa [0]		Done Flag set in Response Queue.
	 */
	u_int32_t	next_vpa;
/* ----------                                     ---------- */
	struct adw_carrier	*nexthash;	/* Carrier Virtual Address */

	int			id;
	/*
	 * This DMA map maps the buffer involved in the carrier transfer.
	 */
//	bus_dmamap_t	dmamap_xfer;
};

typedef struct adw_carrier ADW_CARRIER;

#define ADW_CARRIER_SIZE	((((int)((sizeof(ADW_CARRIER)-1)/16))+1)*16)


/*
 * Mask used to eliminate low 4 bits of carrier 'next_vpa' field.
 */
#define ASC_NEXT_VPA_MASK       0xFFFFFFF0

#define ASC_RQ_DONE             0x00000001
#define ASC_CQ_STOPPER          0x00000000

#define ASC_GET_CARRP(carrp) ((carrp) & ASC_NEXT_VPA_MASK)


/*
a71 2
	ADW_CARRIER		*carr_list;	/* carriers involved */

d82 2
d98 1
a98 2
#define ADW_MAX_CARRIER	20	/* Max. number of host commands (253) */
#define ADW_MAX_CCB	16	/* Max. number commands per device (63) */
a102 1
	bus_dmamap_t	dmamap_xfer;
a105 5
 * Offset of a carrier from the beginning of the carriers DMA mapping.
 */
#define	ADW_CARRIER_ADDR(sc, x)	((sc)->sc_dmamap_carrier->dm_segs[0].ds_addr + \
			(((u_long)x) - ((u_long)(sc)->sc_control->carriers)))
/*
a116 1
ADW_CARRIER *adw_carrier_phys_kv __P((ADW_SOFTC *, u_int32_t));
@


1.3
log
@support new u2w cards; dante@@mclink.it, merged by kwesterback@@home.com
@
text
@d1 1
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: adw.h,v 1.6 2001/01/15 16:27:53 krw Exp $ */
/*      $NetBSD: adw.h,v 1.9 2000/05/26 15:13:43 dante Exp $        */
d51 41
d112 2
a123 1

d138 2
a139 1
#define ADW_MAX_CCB	63	/* Max. number commands per device (63) */
d144 1
d148 5
d164 1
@


1.3.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: adw.h,v 1.3.2.1 2001/05/14 22:23:21 niklas Exp $ */
a117 9

#ifdef __HAS_NEW_BUS_DMAMAP_SYNC
#define	adw_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (off), (len), (op))
#else
#define	adw_bus_dmamap_sync(tag, map, off, len, op)	\
    bus_dmamap_sync((tag), (map), (op))
#endif

@


1.3.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d118 9
@


1.3.2.4
log
@Merge in -current from about a week ago
@
text
@d112 4
a115 4
int adw_init(ADW_SOFTC *sc);
void adw_attach(ADW_SOFTC *sc);
int adw_intr(void *arg);
ADW_CCB *adw_ccb_phys_kv(ADW_SOFTC *, u_int32_t);
@


1.2
log
@For now, just allocate gobs more CCBs in an attempt to avoid running out during
autoconf.  This needs to be fixed correctly...
@
text
@d1 1
a1 2
/*	$OpenBSD: adw.h,v 1.1 1998/11/17 06:14:58 downsj Exp $	*/
/*      $NetBSD: adw.h,v 1.1 1998/09/26 16:10:41 dante Exp $        */
d7 1
a7 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d47 1
a47 1
typedef int (* ADW_SBRESET_CALLBACK) (ADW_SOFTC *);
d49 47
a95 2
/* per request scatter-gather element limit  */
#define ADW_MAX_SG_LIST		64
d108 2
a109 2
struct adw_ccb
{
a110 1
	ADW_SCSI_REQ_Q		scsiq;
d112 3
a114 1
	struct scsi_sense_data scsi_sense;
d117 3
d133 3
a135 3
#define CCB_ALLOC       0x01
#define CCB_ABORT       0x02
#define	CCB_WATCHDOG	0x10
d138 7
a144 5
#define ADW_MAX_CCB	64

struct adw_control
{
	ADW_CCB	ccbs[ADW_MAX_CCB];	/* all our control blocks */
d148 5
d163 2
@


1.1
log
@Add adw device driver, from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
a90 1
#define ADW_MAX_CCB	16
@

