head	1.61;
access;
symbols
	OPENBSD_6_2:1.61.0.6
	OPENBSD_6_2_BASE:1.61
	OPENBSD_6_1:1.61.0.4
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.60.0.4
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.55.0.4
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.43.0.10
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.6
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.8
	OPENBSD_5_0:1.43.0.4
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.41.0.4
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.6
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.2
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.39.0.6
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.24.0.6
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.4
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.23.0.4
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.24
	UBC:1.19.0.4
	UBC_BASE:1.19
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.61
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.60;
commitid	VyLWTsbepAOk7VQM;

1.60
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.59;
commitid	QHiEhS9DHyE6oiIr;

1.59
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.58;
commitid	J9apD0jq2AjFmqZc;

1.58
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.57;
commitid	B0kwmVGiD5DVx4kv;

1.57
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.56;
commitid	5DvsamK0GblTp8ww;

1.56
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.55;
commitid	p0v5tuE1Ch6fY0Nj;

1.55
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.54;
commitid	MVWrtktB46JRxFWT;

1.54
date	2015.05.21.09.44.32;	author mpi;	state Exp;
branches;
next	1.53;
commitid	2EGRbodkP1qU9Egw;

1.53
date	2015.05.21.09.36.20;	author mpi;	state Exp;
branches;
next	1.52;
commitid	IzQAc3r8SVdLPh6M;

1.52
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.51;
commitid	hN5bFCE56DrAjl99;

1.51
date	2015.04.30.20.55.23;	author mpi;	state Exp;
branches;
next	1.50;
commitid	QRbs3CD4c9JVhPoc;

1.50
date	2015.04.01.14.29.54;	author mpi;	state Exp;
branches;
next	1.49;
commitid	YvwyndathKBmcy5L;

1.49
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.48;
commitid	p4LJxGKbi0BU2cG6;

1.48
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.47;
commitid	yM2VFFhpDTeFQlve;

1.47
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.46;
commitid	TGHgrLxu6sxZoiFt;

1.46
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.08.07.01.06.29;	author bluhm;	state Exp;
branches;
next	1.44;

1.44
date	2013.05.21.21.14.59;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2010.08.29.18.01.21;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2010.04.20.20.42.54;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2008.10.03.20.25.29;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.07.18.53.04;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2006.10.20.17.28.10;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2006.10.20.16.54.01;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.10.00.09.07;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2006.10.07.22.08.19;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.03.20.36.10;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.03.20.06.21;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2006.09.17.18.03.06;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.25.22.41.42;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.24.23.56.19;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.22.23.26.02;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2005.06.08.17.02.59;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.06.17.56.36;	author mcbride;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2002.10.09.23.43.11;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.12.19.13.56;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.08.05.38.53;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches
	1.19.4.1;
next	1.18;

1.18
date	2001.08.18.16.50.03;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.09.17.22.12;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.08.23.38.05;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.27.06.34.41;	author kjc;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.23.22.57.13;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.23.21.54.43;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.29.01.39.32;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.25.06.17.33;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.12.05.36.57;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.20.19.39.37;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.29.17.08.51;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.19.21.40.45;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.19.21.35.10;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	99.08.13.21.10.14;	author deraadt;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	99.08.08.21.46.15;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.03.02.06.12.33;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.02.28.03.23.36;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	98.09.22.06.41.12;	author fgsch;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.23.43;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.40.51;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2004.06.05.23.12.41;	author niklas;	state Exp;
branches;
next	1.5.4.8;

1.5.4.8
date	2004.06.07.20.41.21;	author niklas;	state Exp;
branches;
next	;

1.19.4.1
date	2002.01.31.22.55.31;	author niklas;	state Exp;
branches;
next	1.19.4.2;

1.19.4.2
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	1.19.4.3;

1.19.4.3
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	;


desc
@@


1.61
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: dp8390.c,v 1.60 2016/04/13 10:49:26 mpi Exp $	*/
/*	$NetBSD: dp8390.c,v 1.13 1998/07/05 06:49:11 jonathan Exp $	*/

/*
 * Device driver for National Semiconductor DS8390/WD83C690 based ethernet
 * adapters.
 *
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * Copyright (C) 1993, David Greenman.  This software may be used, modified,
 * copied, distributed, and sold, in both source and binary form provided that
 * the above copyright and these terms are retained.  Under no circumstances is
 * the author responsible for the proper functioning of this software, nor does
 * the author assume any responsibility for damages incurred with its use.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>

#include <dev/ic/dp8390reg.h>
#include <dev/ic/dp8390var.h>

#ifdef DEBUG
#define __inline__	/* XXX for debugging porpoises */
#endif

static __inline__ void	dp8390_xmit(struct dp8390_softc *);

static __inline__ void	dp8390_read_hdr(struct dp8390_softc *,
			    int, struct dp8390_ring *);
static __inline__ int	dp8390_ring_copy(struct dp8390_softc *,
			    int, caddr_t, u_short);
static __inline__ int	dp8390_write_mbuf(struct dp8390_softc *,
			    struct mbuf *, int);

static int		dp8390_test_mem(struct dp8390_softc *);

#ifdef DEBUG
int	dp8390_debug = 0;
#endif

/*
 * Standard media init routine for the dp8390.
 */
void
dp8390_media_init(struct dp8390_softc *sc)
{
	ifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);
	ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);
}

/*
 * Do bus-independent setup.
 */
int
dp8390_config(struct dp8390_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int rv;

	rv = 1;

	if (!sc->test_mem)
		sc->test_mem = dp8390_test_mem;

	/* Allocate one xmit buffer if < 16k, two buffers otherwise. */
	if ((sc->mem_size < 16384) ||
	    (sc->sc_flags & DP8390_NO_MULTI_BUFFERING))
		sc->txb_cnt = 1;
	else if (sc->mem_size < 8192 * 3)
		sc->txb_cnt = 2;
	else
		sc->txb_cnt = 3;

	sc->tx_page_start = sc->mem_start >> ED_PAGE_SHIFT;
	sc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;
	sc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);
	sc->mem_ring = sc->mem_start +
	    ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);
	sc->mem_end = sc->mem_start + sc->mem_size;

	/* Now zero memory and verify that it is clear. */
	if ((*sc->test_mem)(sc))
		goto out;

	/* Set interface to stopped condition (reset). */
	dp8390_stop(sc);

	/* Initialize ifnet structure. */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = dp8390_start;
	ifp->if_ioctl = dp8390_ioctl;
	if (!ifp->if_watchdog)
		ifp->if_watchdog = dp8390_watchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* Print additional info when attached. */
	printf(", address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	/* Initialize media goo. */
	(*sc->sc_media_init)(sc);

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	rv = 0;
out:
	return (rv);
}

/*
 * Media change callback.
 */
int
dp8390_mediachange(struct ifnet *ifp)
{
	struct dp8390_softc *sc = ifp->if_softc;

	if (sc->sc_mediachange)
		return ((*sc->sc_mediachange)(sc));

	return (0);
}

/*
 * Media status callback.
 */
void
dp8390_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct dp8390_softc *sc = ifp->if_softc;

	if (sc->sc_enabled == 0) {
		ifmr->ifm_active = IFM_ETHER | IFM_NONE;
		ifmr->ifm_status = 0;
		return;
	}

	if (sc->sc_mediastatus)
		(*sc->sc_mediastatus)(sc, ifmr);
}

/*
 * Reset interface.
 */
void
dp8390_reset(struct dp8390_softc *sc)
{
	int     s;

	s = splnet();
	dp8390_stop(sc);
	dp8390_init(sc);
	splx(s);
}

/*
 * Take interface offline.
 */
void
dp8390_stop(struct dp8390_softc *sc)
{
	bus_space_tag_t regt = sc->sc_regt;
	bus_space_handle_t regh = sc->sc_regh;
	int n = 5000;

	/* Stop everything on the interface, and select page 0 registers. */
	NIC_BARRIER(regt, regh);
	NIC_PUT(regt, regh, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);
	NIC_BARRIER(regt, regh);

	/*
	 * Wait for interface to enter stopped state, but limit # of checks to
	 * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but
	 * just in case it's an old one.
	 */
	while (((NIC_GET(regt, regh,
	    ED_P0_ISR) & ED_ISR_RST) == 0) && --n)
		DELAY(1);

	if (sc->stop_card != NULL)
		(*sc->stop_card)(sc);
}

/*
 * Device timeout/watchdog routine.  Entered if the device neglects to generate
 * an interrupt after a transmit has been started on it.
 */

void
dp8390_watchdog(struct ifnet *ifp)
{
	struct dp8390_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	dp8390_reset(sc);
}

/*
 * Initialize device.
 */
void
dp8390_init(struct dp8390_softc *sc)
{
	bus_space_tag_t regt = sc->sc_regt;
	bus_space_handle_t regh = sc->sc_regh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int8_t mcaf[8];
	int i;

	/*
	 * Initialize the NIC in the exact order outlined in the NS manual.
	 * This init procedure is "mandatory"...don't change what or when
	 * things happen.
	 */

	/* Reset transmitter flags. */
	ifp->if_timer = 0;

	sc->txb_inuse = 0;
	sc->txb_new = 0;
	sc->txb_next_tx = 0;

	/* Set interface for page 0, remote DMA complete, stopped. */
	NIC_BARRIER(regt, regh);
	NIC_PUT(regt, regh, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);
	NIC_BARRIER(regt, regh);

	if (sc->dcr_reg & ED_DCR_LS) {
		NIC_PUT(regt, regh, ED_P0_DCR, sc->dcr_reg);
	} else {
		/*
		 * Set FIFO threshold to 8, No auto-init Remote DMA, byte
		 * order=80x86, byte-wide DMA xfers,
		 */
		NIC_PUT(regt, regh, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);
	}

	/* Clear remote byte count registers. */
	NIC_PUT(regt, regh, ED_P0_RBCR0, 0);
	NIC_PUT(regt, regh, ED_P0_RBCR1, 0);

	/* Tell RCR to do nothing for now. */
	NIC_PUT(regt, regh, ED_P0_RCR, ED_RCR_MON | sc->rcr_proto);

	/* Place NIC in internal loopback mode. */
	NIC_PUT(regt, regh, ED_P0_TCR, ED_TCR_LB0);

	/* Set lower bits of byte addressable framing to 0. */
	if (sc->is790)
		NIC_PUT(regt, regh, 0x09, 0);

	/* Initialize receive buffer ring. */
	NIC_PUT(regt, regh, ED_P0_BNRY, sc->rec_page_start);
	NIC_PUT(regt, regh, ED_P0_PSTART, sc->rec_page_start);
	NIC_PUT(regt, regh, ED_P0_PSTOP, sc->rec_page_stop);

	/*
	 * Enable the following interrupts: receive/transmit complete,
	 * receive/transmit error, and Receiver OverWrite.
	 *
	 * Counter overflow and Remote DMA complete are *not* enabled.
	 */
	NIC_PUT(regt, regh, ED_P0_IMR,
	    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |
	    ED_IMR_OVWE);

	/*
	 * Clear all interrupts.  A '1' in each bit position clears the
	 * corresponding flag.
	 */
	NIC_PUT(regt, regh, ED_P0_ISR, 0xff);

	/* Program command register for page 1. */
	NIC_BARRIER(regt, regh);
	NIC_PUT(regt, regh, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);
	NIC_BARRIER(regt, regh);

	/* Copy out our station address. */
	for (i = 0; i < ETHER_ADDR_LEN; ++i)
		NIC_PUT(regt, regh, ED_P1_PAR0 + i,
		    sc->sc_arpcom.ac_enaddr[i]);

	/* Set multicast filter on chip. */
	dp8390_getmcaf(&sc->sc_arpcom, mcaf);
	for (i = 0; i < 8; i++)
		NIC_PUT(regt, regh, ED_P1_MAR0 + i, mcaf[i]);

	/*
	 * Set current page pointer to one page after the boundary pointer, as
	 * recommended in the National manual.
	 */
	sc->next_packet = sc->rec_page_start + 1;
	NIC_PUT(regt, regh, ED_P1_CURR, sc->next_packet);

	/* Program command register for page 0. */
	NIC_BARRIER(regt, regh);
	NIC_PUT(regt, regh, ED_P1_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);
	NIC_BARRIER(regt, regh);

	/* Accept broadcast and multicast packets by default. */
	i = ED_RCR_AB | ED_RCR_AM | sc->rcr_proto;
	if (ifp->if_flags & IFF_PROMISC) {
		/*
		 * Set promiscuous mode.  Multicast filter was set earlier so
		 * that we should receive all multicast packets.
		 */
		i |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;
	}
	NIC_PUT(regt, regh, ED_P0_RCR, i);

	/* Take interface out of loopback. */
	NIC_PUT(regt, regh, ED_P0_TCR, 0);

	/* Do any card-specific initialization, if applicable. */
	if (sc->init_card)
		(*sc->init_card)(sc);

	/* Fire up the interface. */
	NIC_BARRIER(regt, regh);
	NIC_PUT(regt, regh, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

	/* Set 'running' flag, and clear output active flag. */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* ...and attempt to start output. */
	dp8390_start(ifp);
}

/*
 * This routine actually starts the transmission on the interface.
 */
static __inline__ void
dp8390_xmit(struct dp8390_softc *sc)
{
	bus_space_tag_t regt = sc->sc_regt;
	bus_space_handle_t regh = sc->sc_regh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_short len;

#ifdef DIAGNOSTIC
	if ((sc->txb_next_tx + sc->txb_inuse) % sc->txb_cnt != sc->txb_new)
		panic("dp8390_xmit: desync, next_tx=%d inuse=%d cnt=%d new=%d",
		    sc->txb_next_tx, sc->txb_inuse, sc->txb_cnt, sc->txb_new);

	if (sc->txb_inuse == 0)
		panic("dp8390_xmit: no packets to xmit");
#endif

	len = sc->txb_len[sc->txb_next_tx];

	/* Set NIC for page 0 register access. */
	NIC_BARRIER(regt, regh);
	NIC_PUT(regt, regh, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
	NIC_BARRIER(regt, regh);

	/* Set TX buffer start page. */
	NIC_PUT(regt, regh, ED_P0_TPSR, sc->tx_page_start +
	    sc->txb_next_tx * ED_TXBUF_SIZE);

	/* Set TX length. */
	NIC_PUT(regt, regh, ED_P0_TBCR0, len);
	NIC_PUT(regt, regh, ED_P0_TBCR1, len >> 8);

	/* Set page 0, remote DMA complete, transmit packet, and *start*. */
	NIC_BARRIER(regt, regh);
	NIC_PUT(regt, regh, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);

	/* Point to next transmit buffer slot and wrap if necessary. */
	if (++sc->txb_next_tx == sc->txb_cnt)
		sc->txb_next_tx = 0;

	/* Set a timer just in case we never hear from the board again. */
	ifp->if_timer = 2;
}

/*
 * Start output on interface.
 * We make two assumptions here:
 *  1) that the current priority is set to splnet _before_ this code
 *     is called *and* is returned to the appropriate priority after
 *     return
 *  2) that the IFF_OACTIVE flag is checked before this code is called
 *     (i.e. that the output part of the interface is idle)
 */
void
dp8390_start(struct ifnet *ifp)
{
	struct dp8390_softc *sc = ifp->if_softc;
	struct mbuf *m0;
	int buffer;
	int len;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

outloop:
	/* See if there is room to put another packet in the buffer. */
	if (sc->txb_inuse == sc->txb_cnt) {
		/* No room.  Indicate this to the outside world and exit. */
		ifq_set_oactive(&ifp->if_snd);
		return;
	}
	IFQ_DEQUEUE(&ifp->if_snd, m0);
	if (m0 == NULL)
		return;

	/* We need to use m->m_pkthdr.len, so require the header */
	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("dp8390_start: no header mbuf");

#if NBPFILTER > 0
	/* Tap off here if there is a BPF listener. */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

	/* txb_new points to next open buffer slot. */
	buffer = sc->mem_start +
	    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);

	if (sc->write_mbuf)
		len = (*sc->write_mbuf)(sc, m0, buffer);
	else
		len = dp8390_write_mbuf(sc, m0, buffer);

	m_freem(m0);
	sc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN - ETHER_CRC_LEN);

	/* Point to next buffer slot and wrap if necessary. */
	if (++sc->txb_new == sc->txb_cnt)
		sc->txb_new = 0;

	/* Start the first packet transmitting. */
	if (sc->txb_inuse++ == 0)
		dp8390_xmit(sc);

	/* Loop back to the top to possibly buffer more packets. */
	goto outloop;
}

/*
 * Ethernet interface receiver interrupt.
 */
void
dp8390_rint(struct dp8390_softc *sc)
{
	bus_space_tag_t regt = sc->sc_regt;
	bus_space_handle_t regh = sc->sc_regh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct dp8390_ring packet_hdr;
	struct mbuf *m;
	int packet_ptr;
	u_short len;
	u_char boundary, current;
	u_char nlen;

loop:
	/* Set NIC to page 1 registers to get 'current' pointer. */
	NIC_BARRIER(regt, regh);
	NIC_PUT(regt, regh, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);
	NIC_BARRIER(regt, regh);

	/*
	 * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.
	 * it points to where new data has been buffered.  The 'CURR' (current)
	 * register points to the logical end of the ring-buffer - i.e. it
	 * points to where additional new data will be added.  We loop here
	 * until the logical beginning equals the logical end (or in other
	 * words, until the ring-buffer is empty).
	 */
	current = NIC_GET(regt, regh, ED_P1_CURR);
	if (sc->next_packet == current)
		goto exit;

	/* Set NIC to page 0 registers to update boundary register. */
	NIC_BARRIER(regt, regh);
	NIC_PUT(regt, regh, ED_P1_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
	NIC_BARRIER(regt, regh);

	do {
		/* Get pointer to this buffer's header structure. */
		packet_ptr = sc->mem_ring +
		    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);

		if (sc->read_hdr)
			(*sc->read_hdr)(sc, packet_ptr, &packet_hdr);
		else
			dp8390_read_hdr(sc, packet_ptr, &packet_hdr);
		len = packet_hdr.count;

		/*
		 * Try do deal with old, buggy chips that sometimes duplicate
		 * the low byte of the length into the high byte.  We do this
		 * by simply ignoring the high byte of the length and always
		 * recalculating it.
		 *
		 * NOTE: sc->next_packet is pointing at the current packet.
		 */
		if (packet_hdr.next_packet >= sc->next_packet)
			nlen = (packet_hdr.next_packet - sc->next_packet);
		else
			nlen = ((packet_hdr.next_packet - sc->rec_page_start) +
			    (sc->rec_page_stop - sc->next_packet));
		--nlen;
		if ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)
			--nlen;
		len = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);
#ifdef DIAGNOSTIC
		if (len != packet_hdr.count) {
			printf("%s: length does not match "
			    "next packet pointer\n", sc->sc_dev.dv_xname);
			printf("%s: len %04x nlen %04x start %02x "
			    "first %02x curr %02x next %02x stop %02x\n",
			    sc->sc_dev.dv_xname, packet_hdr.count, len,
			    sc->rec_page_start, sc->next_packet, current,
			    packet_hdr.next_packet, sc->rec_page_stop);
		}
#endif

		/*
		 * Be fairly liberal about what we allow as a "reasonable"
		 * length so that a [crufty] packet will make it to BPF (and
		 * can thus be analyzed).  Note that all that is really
		 * important is that we have a length that will fit into one
		 * mbuf cluster or less; the upper layer protocols can then
		 * figure out the length from their own length field(s).
		 */
		if (len <= MCLBYTES &&
		    packet_hdr.next_packet >= sc->rec_page_start &&
		    packet_hdr.next_packet < sc->rec_page_stop) {
			/* Go get packet. */
			m = dp8390_get(sc,
			    packet_ptr + sizeof(struct dp8390_ring),
			    len - sizeof(struct dp8390_ring));
			if (m == NULL) {
				ifp->if_ierrors++;
				goto exit;
			}
			ml_enqueue(&ml, m);
		} else {
			/* Really BAD.  The ring pointers are corrupted. */
			log(LOG_ERR, "%s: NIC memory corrupt - "
			    "invalid packet length %d\n",
			    sc->sc_dev.dv_xname, len);
			ifp->if_ierrors++;
			dp8390_reset(sc);
			goto exit;
		}

		/* Update next packet pointer. */
		sc->next_packet = packet_hdr.next_packet;

		/*
		 * Update NIC boundary pointer - being careful to keep it one
		 * buffer behind (as recommended by NS databook).
		 */
		boundary = sc->next_packet - 1;
		if (boundary < sc->rec_page_start)
			boundary = sc->rec_page_stop - 1;
		NIC_PUT(regt, regh, ED_P0_BNRY, boundary);
	} while (sc->next_packet != current);

	goto loop;

exit:
	if_input(ifp, &ml);
}

/* Ethernet interface interrupt processor. */
int
dp8390_intr(void *arg)
{
	struct dp8390_softc *sc = (struct dp8390_softc *)arg;
	bus_space_tag_t regt = sc->sc_regt;
	bus_space_handle_t regh = sc->sc_regh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_char isr;

	if (sc->sc_enabled == 0)
		return (0);

	/* Set NIC to page 0 registers. */
	NIC_BARRIER(regt, regh);
	NIC_PUT(regt, regh, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
	NIC_BARRIER(regt, regh);

	isr = NIC_GET(regt, regh, ED_P0_ISR);
	if (!isr)
		return (0);

	/* Loop until there are no more new interrupts. */
	for (;;) {
		/*
		 * Reset all the bits that we are 'acknowledging' by writing a
		 * '1' to each bit position that was set.
		 * (Writing a '1' *clears* the bit.)
		 */
		NIC_PUT(regt, regh, ED_P0_ISR, isr);

		/* Work around for AX88190 bug */
		if ((sc->sc_flags & DP8390_DO_AX88190_WORKAROUND) != 0)
			while ((NIC_GET(regt, regh, ED_P0_ISR) & isr) != 0) {
				NIC_PUT(regt, regh, ED_P0_ISR, 0);
				NIC_PUT(regt, regh, ED_P0_ISR, isr);
			}

		/*
		 * Handle transmitter interrupts.  Handle these first because
		 * the receiver will reset the board under some conditions.
		 *
		 * If the chip was reset while a packet was transmitting, it
		 * may still deliver a TX interrupt.  In this case, just ignore
		 * the interrupt.
		 */
		if (isr & (ED_ISR_PTX | ED_ISR_TXE) &&
		    sc->txb_inuse != 0) {
			u_char collisions =
			    NIC_GET(regt, regh, ED_P0_NCR) & 0x0f;

			/*
			 * Check for transmit error.  If a TX completed with an
			 * error, we end up throwing the packet away.  Really
			 * the only error that is possible is excessive
			 * collisions, and in this case it is best to allow the
			 * automatic mechanisms of TCP to backoff the flow.  Of
			 * course, with UDP we're screwed, but this is expected
			 * when a network is heavily loaded.
			 */
			if (isr & ED_ISR_TXE) {
				/*
				 * Excessive collisions (16).
				 */
				if ((NIC_GET(regt, regh, ED_P0_TSR)
				    & ED_TSR_ABT) && (collisions == 0)) {
					/*
					 * When collisions total 16, the P0_NCR
					 * will indicate 0, and the TSR_ABT is
					 * set.
					 */
					collisions = 16;
				}

				/* Update output errors counter. */
				++ifp->if_oerrors;
			} else {
				/*
				 * Throw away the non-error status bits.
				 *
				 * XXX
				 * It may be useful to detect loss of carrier
				 * and late collisions here.
				 */
				(void)NIC_GET(regt, regh, ED_P0_TSR);
			}

			/* Clear watchdog timer. */
			ifp->if_timer = 0;
			ifq_clr_oactive(&ifp->if_snd);

			/*
			 * Add in total number of collisions on last
			 * transmission.
			 */
			ifp->if_collisions += collisions;

			/*
			 * Decrement buffer in-use count if not zero (can only
			 * be zero if a transmitter interrupt occurred while not
			 * actually transmitting).
			 * If data is ready to transmit, start it transmitting,
			 * otherwise defer until after handling receiver.
			 */
			if (--sc->txb_inuse != 0)
				dp8390_xmit(sc);
		}

		/* Handle receiver interrupts. */
		if (isr & (ED_ISR_PRX | ED_ISR_RXE | ED_ISR_OVW)) {
			/*
			 * Overwrite warning.  In order to make sure that a
			 * lockup of the local DMA hasn't occurred, we reset
			 * and re-init the NIC.  The NSC manual suggests only a
			 * partial reset/re-init is necessary - but some chips
			 * seem to want more.  The DMA lockup has been seen
			 * only with early rev chips - Methinks this bug was
			 * fixed in later revs.  -DG
			 */
			if (isr & ED_ISR_OVW) {
				++ifp->if_ierrors;
#ifdef DEBUG
				log(LOG_WARNING, "%s: warning - receiver "
				    "ring buffer overrun\n",
				    sc->sc_dev.dv_xname);
#endif
				/* Stop/reset/re-init NIC. */
				dp8390_reset(sc);
			} else {
				/*
				 * Receiver Error.  One or more of: CRC error,
				 * frame alignment error FIFO overrun, or
				 * missed packet.
				 */
				if (isr & ED_ISR_RXE) {
					++ifp->if_ierrors;
#ifdef DEBUG
					if (dp8390_debug) {
						printf("%s: receive error %x\n",
						    sc->sc_dev.dv_xname,
						    NIC_GET(regt, regh,
							ED_P0_RSR));
					}
#endif
				}

				/*
				 * Go get the packet(s)
				 * XXX - Doing this on an error is dubious
				 * because there shouldn't be any data to get
				 * (we've configured the interface to not
				 * accept packets with errors).
				 */
				if (sc->recv_int)
					(*sc->recv_int)(sc);
				else
					dp8390_rint(sc);
			}
		}

		/*
		 * If it looks like the transmitter can take more data, attempt
		 * to start output on the interface.  This is done after
		 * handling the receiver to give the receiver priority.
		 */
		dp8390_start(ifp);

		/*
		 * Return NIC CR to standard state: page 0, remote DMA
		 * complete, start (toggling the TXP bit off, even if was just
		 * set in the transmit routine, is *okay* - it is 'edge'
		 * triggered from low to high).
		 */
		NIC_BARRIER(regt, regh);
		NIC_PUT(regt, regh, ED_P0_CR,
		    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
		NIC_BARRIER(regt, regh);

		/*
		 * If the Network Talley Counters overflow, read them to reset
		 * them.  It appears that old 8390's won't clear the ISR flag
		 * otherwise - resulting in an infinite loop.
		 */
		if (isr & ED_ISR_CNT) {
			(void)NIC_GET(regt, regh, ED_P0_CNTR0);
			(void)NIC_GET(regt, regh, ED_P0_CNTR1);
			(void)NIC_GET(regt, regh, ED_P0_CNTR2);
		}

		isr = NIC_GET(regt, regh, ED_P0_ISR);
		if (!isr)
			return (1);
	}
}

int
dp8390_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct dp8390_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *) data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		if ((error = dp8390_enable(sc)) != 0)
			break;
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			dp8390_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else {
				if ((error = dp8390_enable(sc)) != 0)
					break;
				dp8390_init(sc);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING) {
				dp8390_stop(sc);
				ifp->if_flags &= ~IFF_RUNNING;
				dp8390_disable(sc);
			}
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING) {
			dp8390_stop(sc);
			dp8390_init(sc);
		}
		error = 0;
	}

	splx(s);
	return (error);
}

/*
 * Supporting routines.
 */

/*
 * Compute the multicast address filter from the list of multicast addresses we
 * need to listen to.
 */
void
dp8390_getmcaf(struct arpcom *ac, u_int8_t *af)
{
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	u_int32_t crc;
	int i;
	struct ether_multistep step;

	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		for (i = 0; i < 8; i++)
			af[i] = 0xff;
		return;
	}
	for (i = 0; i < 8; i++)
		af[i] = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		/* Just want the 6 most significant bits. */
		crc = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;

		/* Turn on the corresponding bit in the filter. */
		af[crc >> 3] |= 1 << (crc & 0x7);

		ETHER_NEXT_MULTI(step, enm);
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
}

/*
 * Copy data from receive buffer to a new mbuf chain allocating mbufs
 * as needed.  Return pointer to first mbuf in chain.
 * sc = dp8390 info (softc)
 * src = pointer in dp8390 ring buffer
 * total_len = amount of data to copy
 */
struct mbuf *
dp8390_get(struct dp8390_softc *sc, int src, u_short total_len)
{
	struct mbuf *m, *m0, *newm;
	u_short len;

	MGETHDR(m0, M_DONTWAIT, MT_DATA);
	if (m0 == NULL)
		return (0);
	m0->m_pkthdr.len = total_len;
	len = MHLEN;
	m = m0;

	while (total_len > 0) {
		if (total_len >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (!(m->m_flags & M_EXT))
				goto bad;
			len = MCLBYTES;
		}

		/*
		 * Make sure the data after the Ethernet header is aligned.
		 */
		if (m == m0) {
			caddr_t newdata = (caddr_t)
			    ALIGN(m->m_data + sizeof(struct ether_header)) -
			    sizeof(struct ether_header);
			len -= newdata - m->m_data;
			m->m_data = newdata;
		}

		m->m_len = len = min(total_len, len);
		if (sc->ring_copy)
			src = (*sc->ring_copy)(sc, src, mtod(m, caddr_t), len);
		else
			src = dp8390_ring_copy(sc, src, mtod(m, caddr_t), len);

		total_len -= len;
		if (total_len > 0) {
			MGET(newm, M_DONTWAIT, MT_DATA);
			if (newm == NULL)
				goto bad;
			len = MLEN;
			m = m->m_next = newm;
		}
	}

	return (m0);

bad:
	m_freem(m0);
	return (0);
}


/*
 * Default driver support functions.
 *
 * NOTE: all support functions assume 8-bit shared memory.
 */
/*
 * Zero NIC buffer memory and verify that it is clear.
 */
static int
dp8390_test_mem(struct dp8390_softc *sc)
{
	bus_space_tag_t buft = sc->sc_buft;
	bus_space_handle_t bufh = sc->sc_bufh;
	int i;

	bus_space_set_region_1(buft, bufh, sc->mem_start, 0, sc->mem_size);

	for (i = 0; i < sc->mem_size; ++i) {
		if (bus_space_read_1(buft, bufh, sc->mem_start + i)) {
			printf(": failed to clear NIC buffer at offset %x - "
			    "check configuration\n", (sc->mem_start + i));
			return 1;
		}
	}

	return 0;
}

/*
 * Read a packet header from the ring, given the source offset.
 */
static __inline__ void
dp8390_read_hdr(struct dp8390_softc *sc, int src, struct dp8390_ring *hdrp)
{
	bus_space_tag_t buft = sc->sc_buft;
	bus_space_handle_t bufh = sc->sc_bufh;

	/*
	 * The byte count includes a 4 byte header that was added by
	 * the NIC.
	 */
	hdrp->rsr = bus_space_read_1(buft, bufh, src);
	hdrp->next_packet = bus_space_read_1(buft, bufh, src + 1);
	hdrp->count = bus_space_read_1(buft, bufh, src + 2) |
	    (bus_space_read_1(buft, bufh, src + 3) << 8);
}

/*
 * Copy `amount' bytes from a packet in the ring buffer to a linear
 * destination buffer, given a source offset and destination address.
 * Takes into account ring-wrap.
 */
static __inline__ int
dp8390_ring_copy(struct dp8390_softc *sc, int src, caddr_t dst, u_short amount)
{
	bus_space_tag_t buft = sc->sc_buft;
	bus_space_handle_t bufh = sc->sc_bufh;
	u_short tmp_amount;

	/* Does copy wrap to lower addr in ring buffer? */
	if (src + amount > sc->mem_end) {
		tmp_amount = sc->mem_end - src;

		/* Copy amount up to end of NIC memory. */
		bus_space_read_region_1(buft, bufh, src, dst, tmp_amount);

		amount -= tmp_amount;
		src = sc->mem_ring;
		dst += tmp_amount;
	}
	bus_space_read_region_1(buft, bufh, src, dst, amount);

	return (src + amount);
}

/*
 * Copy a packet from an mbuf to the transmit buffer on the card.
 *
 * Currently uses an extra buffer/extra memory copy, unless the whole
 * packet fits in one mbuf.
 */
static __inline__ int
dp8390_write_mbuf(struct dp8390_softc *sc, struct mbuf *m, int buf)
{
	bus_space_tag_t buft = sc->sc_buft;
	bus_space_handle_t bufh = sc->sc_bufh;
	u_char *data;
	int len, totlen = 0;

	for (; m ; m = m->m_next) {
		data = mtod(m, u_char *);
		len = m->m_len;
		if (len > 0) {
			bus_space_write_region_1(buft, bufh, buf, data, len);
			totlen += len;
			buf += len;
		}
	}

	return (totlen);
}

/*
 * Enable power on the interface.
 */
int
dp8390_enable(struct dp8390_softc *sc)
{

	if (sc->sc_enabled == 0 && sc->sc_enable != NULL) {
		if ((*sc->sc_enable)(sc) != 0) {
			printf("%s: device enable failed\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}
	}

	sc->sc_enabled = 1;
	return (0);
}

/*
 * Disable power on the interface.
 */
void
dp8390_disable(struct dp8390_softc *sc)
{
	if (sc->sc_enabled != 0 && sc->sc_disable != NULL) {
		(*sc->sc_disable)(sc);
		sc->sc_enabled = 0;
	}
}

int
dp8390_detach(struct dp8390_softc *sc, int flags)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* dp8390_disable() checks sc->sc_enabled */
	dp8390_disable(sc);

	if (sc->sc_media_fini != NULL)
		(*sc->sc_media_fini)(sc);

	/* Delete all reamining media. */
	ifmedia_delete_instance(&sc->sc_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (0);
}
@


1.60
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.59 2015/12/08 13:34:22 tedu Exp $	*/
a694 6

				/*
				 * Update total number of successfully
				 * transmitted packets.
				 */
				++ifp->if_opackets;
@


1.59
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.58 2015/11/25 03:09:58 dlg Exp $	*/
a118 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.58
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.57 2015/11/24 13:33:17 mpi Exp $	*/
d118 1
a118 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.57
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.56 2015/10/25 12:48:46 mpi Exp $	*/
d359 1
a359 1
	ifp->if_flags &= ~IFF_OACTIVE;
d431 1
a431 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d438 1
a438 1
		ifp->if_flags |= IFF_OACTIVE;
d706 1
a706 1
			ifp->if_flags &= ~IFF_OACTIVE;
@


1.56
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.55 2015/06/24 09:40:54 mpi Exp $	*/
a28 1
#include <net/if_types.h>
@


1.55
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.54 2015/05/21 09:44:32 mpi Exp $	*/
a816 1
	struct ifaddr *ifa = (struct ifaddr *) data;
a828 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.54
log
@No need for ifp since we do not set "rcvif".
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.53 2015/05/21 09:36:20 mpi Exp $	*/
a580 1
			ifp->if_ipackets++;
@


1.53
log
@No need to set "rcvif", if_input() does it for you.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.52 2015/05/13 10:42:46 jsg Exp $	*/
a929 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
@


1.52
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.51 2015/04/30 20:55:23 mpi Exp $	*/
a936 1
	m0->m_pkthdr.rcvif = ifp;
@


1.51
log
@Convert to if_input().

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.50 2015/04/01 14:29:54 mpi Exp $	*/
d443 1
a443 1
	if (m0 == 0)
@


1.50
log
@Kill useless comments talking about ether_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.49 2015/03/14 03:38:47 jsg Exp $	*/
d488 2
d491 1
d514 1
a514 1
		return;
d574 1
a574 1
			dp8390_read(sc,
d577 6
d588 1
a588 1
			++sc->sc_arpcom.ac_if.if_ierrors;
d590 1
a590 1
			return;
d607 3
a872 28

void
dp8390_read(struct dp8390_softc *sc, int buf, u_short len)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m;

	/* Pull packet off interface. */
	m = dp8390_get(sc, buf, len);
	if (m == 0) {
		ifp->if_ierrors++;
		return;
	}

	ifp->if_ipackets++;

#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to bpf.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	ether_input_mbuf(ifp, m);
}

@


1.49
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.48 2014/12/22 02:28:51 tedu Exp $	*/
a861 4
/*
 * Retrieve packet from buffer memory and send to the next level up via
 * ether_input().  If there is a BPF listener, give a copy to BPF, too.
 */
@


1.48
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.47 2014/07/22 13:12:11 mpi Exp $	*/
a28 1
#include <net/if_dl.h>
@


1.47
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.46 2013/11/26 09:50:33 mpi Exp $	*/
a819 1
#ifdef INET
a821 1
#endif
@


1.46
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.45 2013/08/07 01:06:29 bluhm Exp $	*/
a32 1
#ifdef INET
a33 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a34 1
#endif
@


1.45
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.44 2013/05/21 21:14:59 brad Exp $	*/
d926 1
a926 1
	if (ifp->if_flags & IFF_PROMISC) {
a935 16
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    sizeof(enm->enm_addrlo)) != 0) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			ifp->if_flags |= IFF_ALLMULTI;
			for (i = 0; i < 8; i++)
				af[i] = 0xff;
			return;
		}

@


1.44
log
@Rewrite ioctl handling bits.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.43 2010/08/29 18:01:21 deraadt Exp $	*/
a35 1
#include <netinet/in_var.h>
@


1.43
log
@expose dp8390_enable/disable to the higher level drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.42 2010/04/20 20:42:54 deraadt Exp $	*/
a807 3
/*
 * Process an ioctl request.  This code needs some work - it looks pretty ugly.
 */
d823 2
a824 2

		switch (ifa->ifa_addr->sa_family) {
d826 1
a826 2
		case AF_INET:
			dp8390_init(sc);
a827 1
			break;
a828 4
		default:
			dp8390_init(sc);
			break;
		}
d832 14
a845 25
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			dp8390_stop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
			dp8390_disable(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			if ((error = dp8390_enable(sc)) != 0)
				break;
			dp8390_init(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0) {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			dp8390_stop(sc);
			dp8390_init(sc);
d860 1
a860 1
			dp8390_stop(sc);	/* XXX for ds_setmcaf? */
@


1.42
log
@- Fix a calculation bug with the RX ring buffer memory address which
  slipped into the original NetBSD code around sixteen years ago.
  Although it has been working so far because some devices used
  address zero and other devices ignored the wrong higher bits.

- Remove the mem_ring override in ne2000_attach() now that
  dp8390_config() calculates mem_ring correctly.

From NetBSD, via brad
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.41 2008/11/28 02:44:17 brad Exp $	*/
a63 3

int	dp8390_enable(struct dp8390_softc *);
void	dp8390_disable(struct dp8390_softc *);
@


1.41
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.40 2008/10/03 20:25:29 brad Exp $	*/
d109 2
a110 1
	sc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);
@


1.40
log
@Use ether_ioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.39 2007/05/07 18:53:04 deraadt Exp $	*/
a841 8
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;

a870 25
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		if (sc->sc_enabled == 0) {
			error = EIO;
			break;
		}

		/* Update our multicast list. */
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING) {
				dp8390_stop(sc);	/* XXX for ds_setmcaf? */
				dp8390_init(sc);
			}
			error = 0;
		}
		break;

d878 8
@


1.39
log
@floating unused variable (except in debug case)
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.38 2006/10/20 17:28:10 brad Exp $	*/
a823 1

d910 1
a910 2
		error = EINVAL;
		break;
@


1.38
log
@sync some comments with the NetBSD driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.37 2006/10/20 16:54:01 brad Exp $	*/
d68 1
d70 1
@


1.37
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.36 2006/10/10 00:09:07 brad Exp $	*/
d684 7
a690 1
				/* Throw away the non-error status bits. */
d999 1
d1012 2
a1013 2
 * Copy data from receive buffer to end of mbuf chain allocate additional mbufs
 * as needed.  Return pointer to last mbuf in chain.
d1016 1
a1016 2
 * dst = pointer to last mbuf in mbuf chain to copy to
 * amount = amount of data to copy
@


1.36
log
@Add bus_space_barrier.
Add DELAY in some busy loops to allow the DMA engine to actually do something
(neccessary on fast processors).

From ws@@ & mycroft@@ NetBSD

Testing by deraadt@@ nick@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.35 2006/10/07 22:08:19 brad Exp $	*/
d85 1
a85 2
dp8390_config(sc)
	struct dp8390_softc *sc;
d149 1
a149 2
dp8390_mediachange(ifp)
	struct ifnet *ifp;
d163 1
a163 3
dp8390_mediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d181 1
a181 2
dp8390_reset(sc)
	struct dp8390_softc *sc;
d195 1
a195 2
dp8390_stop(sc)
	struct dp8390_softc *sc;
d226 1
a226 2
dp8390_watchdog(ifp)
	struct ifnet *ifp;
d240 1
a240 2
dp8390_init(sc)
	struct dp8390_softc *sc;
d376 1
a376 2
dp8390_xmit(sc)
	struct dp8390_softc *sc;
d431 1
a431 2
dp8390_start(ifp)
	struct ifnet *ifp;
d490 1
a490 2
dp8390_rint(sc)
	struct dp8390_softc *sc;
d608 1
a608 2
dp8390_intr(arg)
	void *arg;
d806 1
a806 4
dp8390_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d916 1
a916 4
dp8390_read(sc, buf, len)
	struct dp8390_softc *sc;
	int buf;
	u_short len;
d952 1
a952 3
dp8390_getmcaf(ec, af)
	struct arpcom *ec;
	u_int8_t *af;
d954 1
a954 1
	struct ifnet *ifp = &ec->ac_if;
d976 1
a976 1
	ETHER_FIRST_MULTI(step, ec, enm);
d1013 1
a1013 4
dp8390_get(sc, src, total_len)
	struct dp8390_softc *sc;
	int src;
	u_short total_len;
d1079 1
a1079 2
dp8390_test_mem(sc)
	struct dp8390_softc *sc;
d1102 1
a1102 4
dp8390_read_hdr(sc, src, hdrp)
	struct dp8390_softc *sc;
	int src;
	struct dp8390_ring *hdrp;
d1123 1
a1123 5
dp8390_ring_copy(sc, src, dst, amount)
	struct dp8390_softc *sc;
	int src;
	caddr_t dst;
	u_short amount;
d1152 1
a1152 4
dp8390_write_mbuf(sc, m, buf)
	struct dp8390_softc *sc;
	struct mbuf *m;
	int buf;
d1176 1
a1176 2
dp8390_enable(sc)
	struct dp8390_softc *sc;
d1195 1
a1195 2
dp8390_disable(sc)
	struct dp8390_softc *sc;
a1196 1

d1204 1
a1204 3
dp8390_detach(sc, flags)
	struct dp8390_softc *sc;
	int flags;
@


1.35
log
@MGET/MGETHDR will return NULL upon failure, not 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.34 2006/10/03 20:36:10 brad Exp $	*/
d208 1
d211 1
d220 1
a220 1
		;
d270 1
d273 1
d321 1
d324 1
d344 1
d347 1
d368 1
d404 1
d407 1
d418 1
d513 1
d516 1
d531 1
d534 1
d632 1
d635 1
d792 1
d795 1
@


1.34
log
@add in a missing piece of the ASIX AX88190 chipset workaround to dp8390_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.33 2006/10/03 20:06:21 brad Exp $	*/
d1023 1
a1023 1
	if (m0 == 0)
d1033 1
a1033 1
			if ((m->m_flags & M_EXT) == 0)
d1058 1
a1058 1
			if (newm == 0)
@


1.33
log
@Simplify the code dealing with the mbuf chain in dp8390_get().

From bad@@ & mycroft@@ NetBSD

Tested by nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.32 2006/09/17 18:03:06 brad Exp $	*/
d286 1
a286 1
	NIC_PUT(regt, regh, ED_P0_RCR, ED_RCR_MON);
@


1.32
log
@set the IFCAP_VLAN_MTU flag.

From bouyer@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.31 2006/03/25 22:41:42 djm Exp $	*/
d158 1
a158 1
	return (EINVAL);
d1019 1
a1019 1
	struct mbuf *top, **mp, *m;
d1022 5
a1026 5
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
		return 0;
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = total_len;
d1028 1
a1028 2
	top = 0;
	mp = &top;
a1030 8
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				m_freem(top);
				return 0;
			}
			len = MLEN;
		}
d1033 2
a1034 5
			if ((m->m_flags & M_EXT) == 0) {
				m_freem(m);
				m_freem(top);
				return 0;
			}
d1041 1
a1041 1
		if (top == NULL) {
d1054 1
d1056 7
a1062 2
		*mp = m;
		mp = &m->m_next;
d1065 5
a1069 1
	return top;
@


1.31
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.30 2006/02/24 23:56:19 brad Exp $	*/
d128 2
@


1.30
log
@Make the "ring buffer overrun" message a DEBUG message instead
of a DIAGNOSTIC message for now, this should be looked at after
release.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.29 2005/10/22 23:26:02 brad Exp $	*/
d455 1
a455 1
		bpf_mtap(ifp->if_bpf, m0);
d932 1
a932 1
		bpf_mtap(ifp->if_bpf, m);
@


1.29
log
@shorten ne(4) dmesg entries from 2-3 lines to 1.

Thanks to Han Boetes for testing on an isapnp card.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.28 2005/06/08 17:02:59 henning Exp $	*/
d720 1
a720 1
#ifdef DIAGNOSTIC
@


1.28
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.27 2005/01/15 05:24:11 brad Exp $	*/
d130 1
a130 2
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));
@


1.27
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.26 2004/06/06 17:56:36 mcbride Exp $	*/
a40 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a821 17
#endif
#ifdef NS
			/* XXX - This code is probably wrong. */
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else
				bcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),
				    ETHER_ADDR_LEN);
			/* Set new address. */
			dp8390_init(sc);
			break;
		    }
@


1.26
log
@Multicast cleanups
- make multicast ranges work
- replace handrolled crc code with ether_crc32_{be,le}()
- add missing calls to ether_{add,del}multi()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.25 2004/05/12 06:35:10 tedu Exp $	*/
d905 4
a908 2
			dp8390_stop(sc);	/* XXX for ds_setmcaf? */
			dp8390_init(sc);
@


1.25
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.24 2002/10/09 23:43:11 krw Exp $	*/
a974 1
	u_int8_t *cp, c;
d976 1
a976 1
	int i, len;
a1011 13
		cp = enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = sizeof(enm->enm_addrlo); --len >= 0;) {
			c = *cp++;
			for (i = 8; --i >= 0;) {
				if (((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01)) {
					crc <<= 1;
					crc ^= 0x04c11db6 | 1;
				} else
					crc <<= 1;
				c >>= 1;
			}
		}
d1013 1
a1013 1
		crc >>= 26;
@


1.24
log
@Remove trailing '\n's from panic messages.

Started by a commit to siop from provos@@netbsd.org.

ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.23 2002/03/14 01:26:54 millert Exp $	*/
a47 1
#include <net/bpfdesc.h>
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.22 2002/03/12 19:13:56 fgsch Exp $	*/
d394 1
a394 1
		panic("dp8390_xmit: no packets to xmit\n");
@


1.22
log
@don't need to call IFQ_SET_READY() twice; this driver was already
ALTQify'ed.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.21 2002/03/12 09:51:20 kjc Exp $	*/
d60 1
a60 1
static __inline__ void	dp8390_xmit __P((struct dp8390_softc *));
d62 6
a67 6
static __inline__ void	dp8390_read_hdr __P((struct dp8390_softc *,
			    int, struct dp8390_ring *));
static __inline__ int	dp8390_ring_copy __P((struct dp8390_softc *,
			    int, caddr_t, u_short));
static __inline__ int	dp8390_write_mbuf __P((struct dp8390_softc *,
			    struct mbuf *, int));
d69 1
a69 1
static int		dp8390_test_mem __P((struct dp8390_softc *));
d71 2
a72 2
int	dp8390_enable __P((struct dp8390_softc *));
void	dp8390_disable __P((struct dp8390_softc *));
@


1.21
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.20 2002/01/08 05:38:53 fgsch Exp $	*/
a140 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.20
log
@SIOCSIFMTU support; patches by Claudio Castiglia <ccastig@@softhome.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.19 2001/09/20 17:02:31 mpech Exp $	*/
d141 1
@


1.19
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.18 2001/08/18 16:50:03 aaron Exp $	*/
d849 8
@


1.19.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.20 2002/01/08 05:38:53 fgsch Exp $	*/
a848 8
		}
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
@


1.19.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.19.4.1 2002/01/31 22:55:31 niklas Exp $	*/
d60 1
a60 1
static __inline__ void	dp8390_xmit(struct dp8390_softc *);
d62 6
a67 6
static __inline__ void	dp8390_read_hdr(struct dp8390_softc *,
			    int, struct dp8390_ring *);
static __inline__ int	dp8390_ring_copy(struct dp8390_softc *,
			    int, caddr_t, u_short);
static __inline__ int	dp8390_write_mbuf(struct dp8390_softc *,
			    struct mbuf *, int);
d69 1
a69 1
static int		dp8390_test_mem(struct dp8390_softc *);
d71 2
a72 2
int	dp8390_enable(struct dp8390_softc *);
void	dp8390_disable(struct dp8390_softc *);
@


1.19.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.19.4.2 2002/06/11 03:42:18 art Exp $	*/
d394 1
a394 1
		panic("dp8390_xmit: no packets to xmit");
@


1.18
log
@Make use of ax88190_stop_card and dl10019_stop_card.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.17 2001/07/09 17:22:12 fgsch Exp $	*/
d705 1
a705 1
			 * be zero if a transmitter interrupt occured while not
@


1.17
log
@Move IFQ_SET_READY macro to attach time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.16 2001/07/08 23:38:05 fgsch Exp $	*/
d224 3
@


1.16
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.15 2001/06/27 06:34:41 kjc Exp $	*/
d133 1
a180 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.15
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.14 2001/06/23 22:57:13 fgsch Exp $	*/
a132 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
@


1.14
log
@ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.13 2001/06/23 21:54:43 fgsch Exp $	*/
d133 1
a133 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
d181 1
d449 1
a449 1
	IF_DEQUEUE(&ifp->if_snd, m0);
@


1.13
log
@Remove repeated ethernet constants; use if_ether.h for it instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.12 2001/03/29 01:39:32 aaron Exp $	*/
a926 1
	struct ether_header *eh;
a936 3
	/* We assume that the header fits entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d946 1
a946 3
	/* Fix up data start offset in mbuf to point past ether header. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.12
log
@Add MII support to NE2000 PCMCIA driver. Both the Netgear FA410TXC and
New Media LiveWire Fast Ethernet adapters now work after these changes,
although the Netgear card still requires media to be set manually.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.11 2001/03/25 06:17:33 fgsch Exp $	*/
a72 4

#define	ETHER_MIN_LEN	64
#define ETHER_MAX_LEN	1518
#define	ETHER_ADDR_LEN	6
@


1.11
log
@don't count the input packets twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.10 2001/03/12 05:36:57 aaron Exp $	*/
d1253 22
@


1.10
log
@Adjust the way that media is initialized on DP8390-compatibles; from NetBSD.
The dp8390_softc now has media_init and media_fini function pointers that
do the work. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.9 2001/02/20 19:39:37 mickey Exp $	*/
a580 1
			++sc->sc_arpcom.ac_if.if_ipackets;
@


1.9
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.8 2000/05/29 17:08:51 fgsch Exp $	*/
a73 3
int	dp8390_mediachange __P((struct ifnet *));
void	dp8390_mediastatus __P((struct ifnet *, struct ifmediareq *));

d81 11
d95 1
a95 1
dp8390_config(sc, media, nmedia, defmedia)
a96 1
	int *media, nmedia, defmedia;
d99 1
a99 1
	int i, rv;
d139 4
d144 1
a144 9
	ifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);
	if (media != NULL) {
		for (i = 0; i < nmedia; i++)
			ifmedia_add(&sc->sc_media, media[i], 0, NULL);
		ifmedia_set(&sc->sc_media, defmedia);
	} else {
		ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);
		ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);
	}
a149 4
	/* Print additional info when attached. */
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));

d166 1
@


1.8
log
@preparing for AX88190 support; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.7 2000/04/19 21:40:45 fgsch Exp $	*/
a145 4
#if NBPFILTER > 0
	bpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
		sizeof(struct ether_header));
#endif
@


1.7
log
@Remove NetBSD ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.6 2000/04/19 21:35:10 fgsch Exp $	*/
d352 1
a352 1
	i = ED_RCR_AB | ED_RCR_AM;
d642 7
@


1.6
log
@* use different numbers of transmit buffers depending on the memory
  size (not working yet), useful for 100mbit cards.
* add some diagnostic messages
* compute the xmit buffer length w/o taking crc length in count
* when SIOCSIFFLAGS is issued and none of the above conditions match,
  check for IFF_UP rather than sc_enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.5 1999/08/13 21:10:14 deraadt Exp $	*/
a31 3
#ifdef __NetBSD__
#include <net/if_ether.h>
#endif
a37 3
#ifdef __NetBSD__
#include <netinet/if_inarp.h>
#else
a39 1
#endif
a90 3
#ifdef __NetBSD__
	struct ifnet *ifp = &sc->sc_ec.ec_if;
#else
a91 1
#endif
a144 3
#ifdef __NetBSD__
	ether_ifattach(ifp, sc->sc_enaddr);
#else
a145 1
#endif
a146 3
#ifdef __NetBSD__
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#else
a149 1
#endif
a152 3
#ifdef __NetBSD__
	    ether_sprintf(sc->sc_enaddr));
#else
a153 1
#endif
a245 3
#ifdef __NetBSD__
	++sc->sc_ec.ec_if.if_oerrors;
#else
a246 1
#endif
a259 3
#ifdef __NetBSD__
	struct ifnet *ifp = &sc->sc_ec.ec_if;
#else
a260 1
#endif
a331 4
#ifdef __NetBSD__
		NIC_PUT(regt, regh, ED_P1_PAR0 + i,
		    LLADDR(ifp->if_sadl)[i]);
#else
a333 1
#endif
a335 3
#ifdef __NetBSD__
	dp8390_getmcaf(&sc->sc_ec, mcaf);
#else
a336 1
#endif
a389 3
#ifdef __NetBSD__
	struct ifnet *ifp = &sc->sc_ec.ec_if;
#else
a390 1
#endif
a584 3
#ifdef __NetBSD__
			++sc->sc_ec.ec_if.if_ipackets;
#else
a585 1
#endif
a590 3
#ifdef __NetBSD__
			++sc->sc_ec.ec_if.if_ierrors;
#else
a591 1
#endif
a619 3
#ifdef __NetBSD__
	struct ifnet *ifp = &sc->sc_ec.ec_if;
#else
a620 1
#endif
a824 3
#ifdef __NetBSD__
			arp_ifinit(ifp, ifa);
#else
a825 1
#endif
a888 4
#ifdef __NetBSD__
		    ether_addmulti(ifr, &sc->sc_ec) :
		    ether_delmulti(ifr, &sc->sc_ec);
#else
a890 1
#endif
a926 3
#ifdef __NetBSD__
	struct ifnet *ifp = &sc->sc_ec.ec_if;
#else
a927 1
#endif
a967 3
#ifdef __NetBSD__
	struct ethercom *ec;
#else
a968 1
#endif
a970 3
#ifdef __NetBSD__
	struct ifnet *ifp = &ec->ec_if;
#else
a971 1
#endif
a1048 3
#ifdef __NetBSD__
	struct ifnet *ifp = &sc->sc_ec.ec_if;
#else
a1049 1
#endif
@


1.5
log
@well of course it is Ethernet...
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.4 1999/08/08 21:46:15 niklas Exp $	*/
d114 2
d117 1
a117 1
		sc->txb_cnt = 2;
d437 9
d524 1
a524 1
	sc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN);
d930 1
a930 1
		} else if (sc->sc_enabled) {
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.12 2001/03/29 01:39:32 aaron Exp $	*/
d32 3
d41 3
d46 1
d81 3
a90 11
 * Standard media init routine for the dp8390.
 */
void
dp8390_media_init(struct dp8390_softc *sc)
{
	ifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);
	ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);
}

/*
d94 1
a94 1
dp8390_config(sc)
d96 1
d98 3
d102 2
a103 1
	int rv;
d114 1
a114 1
	else if (sc->mem_size < 8192 * 3)
a115 2
	else
		sc->txb_cnt = 3;
a140 4
	/* Print additional info when attached. */
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));

d142 9
a150 1
	(*sc->sc_media_init)(sc);
d154 3
d158 17
a191 1

d267 3
d271 1
d285 3
d289 1
d361 4
d367 1
d370 3
d374 1
d390 1
a390 1
	i = ED_RCR_AB | ED_RCR_AM | sc->rcr_proto;
d428 3
d432 1
a434 9
#ifdef DIAGNOSTIC
	if ((sc->txb_next_tx + sc->txb_inuse) % sc->txb_cnt != sc->txb_new)
		panic("dp8390_xmit: desync, next_tx=%d inuse=%d cnt=%d new=%d",
		    sc->txb_next_tx, sc->txb_inuse, sc->txb_cnt, sc->txb_new);

	if (sc->txb_inuse == 0)
		panic("dp8390_xmit: no packets to xmit\n");
#endif

d513 1
a513 1
	sc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN - ETHER_CRC_LEN);
d618 5
d628 3
d632 1
d661 3
d665 1
a687 7
		/* Work around for AX88190 bug */
		if ((sc->sc_flags & DP8390_DO_AX88190_WORKAROUND) != 0)
			while ((NIC_GET(regt, regh, ED_P0_ISR) & isr) != 0) {
				NIC_PUT(regt, regh, ED_P0_ISR, 0);
				NIC_PUT(regt, regh, ED_P0_ISR, isr);
			}

d870 3
d874 1
d919 1
a919 1
		} else if ((ifp->if_flags & IFF_UP) != 0) {
d938 4
d944 1
d981 3
d985 1
d1026 3
d1030 1
d1033 3
d1037 1
d1115 3
d1119 1
a1320 22
}

int
dp8390_detach(sc, flags)
	struct dp8390_softc *sc;
	int flags;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* dp8390_disable() checks sc->sc_enabled */
	dp8390_disable(sc);

	if (sc->sc_media_fini != NULL)
		(*sc->sc_media_fini)(sc);

	/* Delete all reamining media. */
	ifmedia_delete_instance(&sc->sc_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (0);
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.5.4.1 2001/05/14 22:23:43 niklas Exp $	*/
d74 4
d137 1
a137 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
a184 1
	IFQ_SET_READY(&ifp->if_snd);
d452 1
a452 1
	IFQ_DEQUEUE(&ifp->if_snd, m0);
d931 1
d942 3
d954 3
a956 1
	ether_input_mbuf(ifp, m);
@


1.5.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.5.4.2 2001/07/04 10:40:51 niklas Exp $	*/
d133 1
a133 1
	IFQ_SET_READY(&ifp->if_snd);
d181 1
a224 3

	if (sc->stop_card != NULL)
		(*sc->stop_card)(sc);
d703 1
a703 1
			 * be zero if a transmitter interrupt occurred while not
@


1.5.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a848 8
		}
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
@


1.5.4.5
log
@Merge in -current from about a week ago
@
text
@d60 1
a60 1
static __inline__ void	dp8390_xmit(struct dp8390_softc *);
d62 6
a67 6
static __inline__ void	dp8390_read_hdr(struct dp8390_softc *,
			    int, struct dp8390_ring *);
static __inline__ int	dp8390_ring_copy(struct dp8390_softc *,
			    int, caddr_t, u_short);
static __inline__ int	dp8390_write_mbuf(struct dp8390_softc *,
			    struct mbuf *, int);
d69 1
a69 1
static int		dp8390_test_mem(struct dp8390_softc *);
d71 2
a72 2
int	dp8390_enable(struct dp8390_softc *);
void	dp8390_disable(struct dp8390_softc *);
@


1.5.4.6
log
@Sync the SMP branch with 3.3
@
text
@d394 1
a394 1
		panic("dp8390_xmit: no packets to xmit");
@


1.5.4.7
log
@Merge with the trunk
@
text
@d48 1
@


1.5.4.8
log
@sync to head
@
text
@d975 1
d977 1
a977 1
	int i;
d1013 13
d1027 1
a1027 1
		crc = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;
@


1.4
log
@These all are backends for interfaces that can be attached late, whence
ifinit can not set their ifq_maxlen, so do it ourselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.3 1999/03/02 06:12:33 fgsch Exp $	*/
d169 1
a169 1
	printf("%s: Ethernet address %s\n", sc->sc_dev.dv_xname,
@


1.3
log
@Ignore TX interrupts when there are not packets buffered.
This fix a problem seen with realtek 80[12]9 based cards; noted by
scomeau@@obscurity.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.2 1999/02/28 03:23:36 jason Exp $	*/
d139 1
@


1.2
log
@compensate for the test of packet ownership being moved to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: dp8390.c,v 1.1 1998/09/22 06:41:12 fgsch Exp $	*/
a338 6
	 * Clear all interrupts.  A '1' in each bit position clears the
	 * corresponding flag.
	 */
	NIC_PUT(regt, regh, ED_P0_ISR, 0xff);

	/*
d348 6
d388 1
d453 1
a453 2
	sc->txb_next_tx++;
	if (sc->txb_next_tx == sc->txb_cnt)
a513 4
	/* Start the first packet transmitting. */
	if (sc->txb_inuse == 0)
		dp8390_xmit(sc);

d518 3
a520 1
	sc->txb_inuse++;
d690 4
d695 4
a698 3
		if (isr & (ED_ISR_PTX | ED_ISR_TXE)) {
			u_char collisions = NIC_GET(regt, regh,
			    ED_P0_NCR) & 0x0f;
a708 1
			(void)NIC_GET(regt, regh, ED_P0_TSR);
d726 3
a735 3
			/* Done with the buffer. */
			sc->txb_inuse--;

d753 1
a753 1
			if (sc->txb_inuse > 0)
@


1.1
log
@New DS8390/WD83C690 device driver used by ec, ne and we from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1003 1
a1003 1
	if (ifp->if_bpf) {
a1004 18

		/*
		 * Note that the interface cannot be in promiscuous mode if
		 * there are no BPF listeners.  And if we are in promiscuous
		 * mode, we have to check if this packet is really ours.
		 */
		if ((ifp->if_flags & IFF_PROMISC) &&
		    (eh->ether_dhost[0] & 1) == 0 &&	/* !mcast and !bcast */
#ifdef __NetBSD__
		    bcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),
#else
		    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,
#endif
		    sizeof(eh->ether_dhost)) != 0) {
			m_freem(m);
			return;
		}
	}
@

