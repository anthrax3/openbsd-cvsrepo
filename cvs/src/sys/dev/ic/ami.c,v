head	1.233;
access;
symbols
	OPENBSD_6_2_BASE:1.233
	OPENBSD_6_1:1.232.0.4
	OPENBSD_6_1_BASE:1.232
	OPENBSD_6_0:1.231.0.6
	OPENBSD_6_0_BASE:1.231
	OPENBSD_5_9:1.231.0.2
	OPENBSD_5_9_BASE:1.231
	OPENBSD_5_8:1.230.0.6
	OPENBSD_5_8_BASE:1.230
	OPENBSD_5_7:1.230.0.2
	OPENBSD_5_7_BASE:1.230
	OPENBSD_5_6:1.228.0.4
	OPENBSD_5_6_BASE:1.228
	OPENBSD_5_5:1.226.0.4
	OPENBSD_5_5_BASE:1.226
	OPENBSD_5_4:1.225.0.2
	OPENBSD_5_4_BASE:1.225
	OPENBSD_5_3:1.223.0.6
	OPENBSD_5_3_BASE:1.223
	OPENBSD_5_2:1.223.0.2
	OPENBSD_5_2_BASE:1.223
	OPENBSD_5_1_BASE:1.223
	OPENBSD_5_1:1.223.0.4
	OPENBSD_5_0:1.220.0.2
	OPENBSD_5_0_BASE:1.220
	OPENBSD_4_9:1.218.0.2
	OPENBSD_4_9_BASE:1.218
	OPENBSD_4_8:1.212.0.2
	OPENBSD_4_8_BASE:1.212
	OPENBSD_4_7:1.199.0.2
	OPENBSD_4_7_BASE:1.199
	OPENBSD_4_6:1.195.0.4
	OPENBSD_4_6_BASE:1.195
	OPENBSD_4_5:1.192.0.2
	OPENBSD_4_5_BASE:1.192
	OPENBSD_4_4:1.187.0.2
	OPENBSD_4_4_BASE:1.187
	OPENBSD_4_3:1.186.0.2
	OPENBSD_4_3_BASE:1.186
	OPENBSD_4_2:1.184.0.2
	OPENBSD_4_2_BASE:1.184
	OPENBSD_4_1:1.176.0.2
	OPENBSD_4_1_BASE:1.176
	OPENBSD_4_0:1.173.0.2
	OPENBSD_4_0_BASE:1.173
	OPENBSD_3_9:1.107.0.2
	OPENBSD_3_9_BASE:1.107
	OPENBSD_3_8:1.73.0.2
	OPENBSD_3_8_BASE:1.73
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.19
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	SMP:1.8.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2;
locks; strict;
comment	@ * @;


1.233
date	2017.04.08.02.57.24;	author deraadt;	state Exp;
branches;
next	1.232;
commitid	6s3MfY9d6ZKdL2Uz;

1.232
date	2016.08.14.04.08.03;	author dlg;	state Exp;
branches;
next	1.231;
commitid	7Sh26Zh99sH8viYr;

1.231
date	2015.09.09.18.23.55;	author deraadt;	state Exp;
branches;
next	1.230;
commitid	pxEWup0rbECbQnbF;

1.230
date	2014.11.05.01.02.10;	author daniel;	state Exp;
branches;
next	1.229;
commitid	eFshAu2yrXroX4tH;

1.229
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.228;
commitid	uzzBR7hz9ncd4O6G;

1.228
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.227;
commitid	JtO5uXxVcnZfhUkR;

1.227
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.226;
commitid	I19imNlAX05zJOED;

1.226
date	2013.10.19.13.03.43;	author dlg;	state Exp;
branches;
next	1.225;

1.225
date	2013.06.11.16.42.14;	author deraadt;	state Exp;
branches;
next	1.224;

1.224
date	2013.05.07.01.54.06;	author jsg;	state Exp;
branches;
next	1.223;

1.223
date	2012.01.09.18.50.44;	author deraadt;	state Exp;
branches;
next	1.222;

1.222
date	2012.01.09.15.43.15;	author deraadt;	state Exp;
branches;
next	1.221;

1.221
date	2011.10.05.06.41.30;	author dlg;	state Exp;
branches;
next	1.220;

1.220
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches
	1.220.2.1;
next	1.219;

1.219
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.218;

1.218
date	2011.02.22.02.30.08;	author dlg;	state Exp;
branches;
next	1.217;

1.217
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.216;

1.216
date	2010.09.24.01.32.09;	author dlg;	state Exp;
branches;
next	1.215;

1.215
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.214;

1.214
date	2010.09.02.11.54.44;	author dlg;	state Exp;
branches;
next	1.213;

1.213
date	2010.08.25.00.47.52;	author dlg;	state Exp;
branches;
next	1.212;

1.212
date	2010.07.01.03.20.38;	author matthew;	state Exp;
branches;
next	1.211;

1.211
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.210;

1.210
date	2010.06.28.05.43.46;	author jsg;	state Exp;
branches;
next	1.209;

1.209
date	2010.06.23.04.53.53;	author dlg;	state Exp;
branches;
next	1.208;

1.208
date	2010.06.23.03.46.25;	author dlg;	state Exp;
branches;
next	1.207;

1.207
date	2010.06.21.11.43.38;	author dlg;	state Exp;
branches;
next	1.206;

1.206
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.205;

1.205
date	2010.06.03.12.04.39;	author dlg;	state Exp;
branches;
next	1.204;

1.204
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.203;

1.203
date	2010.05.18.20.54.34;	author oga;	state Exp;
branches;
next	1.202;

1.202
date	2010.05.16.20.33.59;	author nicm;	state Exp;
branches;
next	1.201;

1.201
date	2010.05.01.08.14.26;	author mk;	state Exp;
branches;
next	1.200;

1.200
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.199;

1.199
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.198;

1.198
date	2009.12.06.12.31.10;	author chl;	state Exp;
branches;
next	1.197;

1.197
date	2009.08.12.14.15.05;	author dlg;	state Exp;
branches;
next	1.196;

1.196
date	2009.08.09.21.50.20;	author krw;	state Exp;
branches;
next	1.195;

1.195
date	2009.06.11.15.48.10;	author chl;	state Exp;
branches;
next	1.194;

1.194
date	2009.06.11.07.47.41;	author chl;	state Exp;
branches;
next	1.193;

1.193
date	2009.06.04.06.34.38;	author ray;	state Exp;
branches;
next	1.192;

1.192
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.191;

1.191
date	2009.01.11.16.54.59;	author blambert;	state Exp;
branches;
next	1.190;

1.190
date	2008.10.28.11.53.18;	author marco;	state Exp;
branches;
next	1.189;

1.189
date	2008.10.28.11.49.28;	author marco;	state Exp;
branches;
next	1.188;

1.188
date	2008.10.28.11.43.10;	author marco;	state Exp;
branches;
next	1.187;

1.187
date	2008.04.10.06.39.00;	author dlg;	state Exp;
branches;
next	1.186;

1.186
date	2007.12.28.16.19.14;	author dlg;	state Exp;
branches;
next	1.185;

1.185
date	2007.09.27.08.45.19;	author chl;	state Exp;
branches;
next	1.184;

1.184
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.183;

1.183
date	2007.05.31.18.39.03;	author dlg;	state Exp;
branches;
next	1.182;

1.182
date	2007.05.31.18.34.12;	author dlg;	state Exp;
branches;
next	1.181;

1.181
date	2007.05.29.22.17.50;	author todd;	state Exp;
branches;
next	1.180;

1.180
date	2007.05.29.20.41.41;	author marco;	state Exp;
branches;
next	1.179;

1.179
date	2007.05.08.13.11.21;	author dlg;	state Exp;
branches;
next	1.178;

1.178
date	2007.04.26.11.39.33;	author bluhm;	state Exp;
branches;
next	1.177;

1.177
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.176;

1.176
date	2007.01.27.05.09.51;	author dlg;	state Exp;
branches;
next	1.175;

1.175
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.174;

1.174
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.173;

1.173
date	2006.08.28.01.34.52;	author krw;	state Exp;
branches;
next	1.172;

1.172
date	2006.08.03.09.06.51;	author dlg;	state Exp;
branches;
next	1.171;

1.171
date	2006.06.28.08.26.00;	author dlg;	state Exp;
branches;
next	1.170;

1.170
date	2006.06.28.04.48.56;	author deraadt;	state Exp;
branches;
next	1.169;

1.169
date	2006.06.27.23.10.38;	author dlg;	state Exp;
branches;
next	1.168;

1.168
date	2006.06.27.08.01.05;	author dlg;	state Exp;
branches;
next	1.167;

1.167
date	2006.06.27.07.56.55;	author dlg;	state Exp;
branches;
next	1.166;

1.166
date	2006.06.09.04.48.13;	author marco;	state Exp;
branches;
next	1.165;

1.165
date	2006.06.09.04.27.10;	author marco;	state Exp;
branches;
next	1.164;

1.164
date	2006.05.28.09.21.57;	author uwe;	state Exp;
branches;
next	1.163;

1.163
date	2006.05.26.15.57.32;	author marco;	state Exp;
branches;
next	1.162;

1.162
date	2006.05.21.19.48.51;	author dlg;	state Exp;
branches;
next	1.161;

1.161
date	2006.05.21.19.17.22;	author dlg;	state Exp;
branches;
next	1.160;

1.160
date	2006.05.21.18.52.37;	author dlg;	state Exp;
branches;
next	1.159;

1.159
date	2006.05.21.18.28.24;	author dlg;	state Exp;
branches;
next	1.158;

1.158
date	2006.05.21.03.33.53;	author dlg;	state Exp;
branches;
next	1.157;

1.157
date	2006.05.21.02.51.09;	author dlg;	state Exp;
branches;
next	1.156;

1.156
date	2006.05.12.20.51.25;	author marco;	state Exp;
branches;
next	1.155;

1.155
date	2006.04.26.22.41.08;	author dlg;	state Exp;
branches;
next	1.154;

1.154
date	2006.04.25.13.32.03;	author dlg;	state Exp;
branches;
next	1.153;

1.153
date	2006.04.23.15.32.09;	author marco;	state Exp;
branches;
next	1.152;

1.152
date	2006.04.22.18.55.36;	author marco;	state Exp;
branches;
next	1.151;

1.151
date	2006.04.21.07.29.00;	author dlg;	state Exp;
branches;
next	1.150;

1.150
date	2006.04.20.13.32.29;	author dlg;	state Exp;
branches;
next	1.149;

1.149
date	2006.04.20.13.02.26;	author dlg;	state Exp;
branches;
next	1.148;

1.148
date	2006.04.20.12.14.54;	author dlg;	state Exp;
branches;
next	1.147;

1.147
date	2006.04.20.04.39.11;	author dlg;	state Exp;
branches;
next	1.146;

1.146
date	2006.04.19.03.38.53;	author krw;	state Exp;
branches;
next	1.145;

1.145
date	2006.04.18.18.31.04;	author marco;	state Exp;
branches;
next	1.144;

1.144
date	2006.04.18.04.15.44;	author marco;	state Exp;
branches;
next	1.143;

1.143
date	2006.04.06.10.16.45;	author dlg;	state Exp;
branches;
next	1.142;

1.142
date	2006.04.06.04.16.35;	author dlg;	state Exp;
branches;
next	1.141;

1.141
date	2006.04.05.14.07.24;	author dlg;	state Exp;
branches;
next	1.140;

1.140
date	2006.04.03.01.53.04;	author marco;	state Exp;
branches;
next	1.139;

1.139
date	2006.04.03.01.40.00;	author marco;	state Exp;
branches;
next	1.138;

1.138
date	2006.04.03.01.35.06;	author marco;	state Exp;
branches;
next	1.137;

1.137
date	2006.03.29.13.38.05;	author dlg;	state Exp;
branches;
next	1.136;

1.136
date	2006.03.29.13.31.15;	author dlg;	state Exp;
branches;
next	1.135;

1.135
date	2006.03.20.10.52.34;	author dlg;	state Exp;
branches;
next	1.134;

1.134
date	2006.03.20.10.49.53;	author dlg;	state Exp;
branches;
next	1.133;

1.133
date	2006.03.20.10.10.59;	author dlg;	state Exp;
branches;
next	1.132;

1.132
date	2006.03.20.09.59.26;	author dlg;	state Exp;
branches;
next	1.131;

1.131
date	2006.03.20.09.46.28;	author dlg;	state Exp;
branches;
next	1.130;

1.130
date	2006.03.20.09.34.37;	author dlg;	state Exp;
branches;
next	1.129;

1.129
date	2006.03.20.09.12.05;	author dlg;	state Exp;
branches;
next	1.128;

1.128
date	2006.03.20.09.02.02;	author dlg;	state Exp;
branches;
next	1.127;

1.127
date	2006.03.20.08.59.42;	author dlg;	state Exp;
branches;
next	1.126;

1.126
date	2006.03.19.11.53.23;	author dlg;	state Exp;
branches;
next	1.125;

1.125
date	2006.03.18.04.44.52;	author dlg;	state Exp;
branches;
next	1.124;

1.124
date	2006.03.18.03.13.43;	author dlg;	state Exp;
branches;
next	1.123;

1.123
date	2006.03.18.02.28.29;	author dlg;	state Exp;
branches;
next	1.122;

1.122
date	2006.03.17.14.18.39;	author dlg;	state Exp;
branches;
next	1.121;

1.121
date	2006.03.17.13.34.23;	author dlg;	state Exp;
branches;
next	1.120;

1.120
date	2006.03.17.10.49.12;	author dlg;	state Exp;
branches;
next	1.119;

1.119
date	2006.03.15.14.31.29;	author dlg;	state Exp;
branches;
next	1.118;

1.118
date	2006.03.15.13.51.04;	author dlg;	state Exp;
branches;
next	1.117;

1.117
date	2006.03.15.12.38.56;	author dlg;	state Exp;
branches;
next	1.116;

1.116
date	2006.03.15.12.02.35;	author dlg;	state Exp;
branches;
next	1.115;

1.115
date	2006.03.14.15.03.11;	author dlg;	state Exp;
branches;
next	1.114;

1.114
date	2006.03.14.13.33.23;	author dlg;	state Exp;
branches;
next	1.113;

1.113
date	2006.03.14.11.57.21;	author dlg;	state Exp;
branches;
next	1.112;

1.112
date	2006.03.14.11.44.08;	author dlg;	state Exp;
branches;
next	1.111;

1.111
date	2006.03.13.22.11.23;	author brad;	state Exp;
branches;
next	1.110;

1.110
date	2006.03.13.12.08.40;	author dlg;	state Exp;
branches;
next	1.109;

1.109
date	2006.03.13.11.49.52;	author dlg;	state Exp;
branches;
next	1.108;

1.108
date	2006.03.13.11.11.55;	author dlg;	state Exp;
branches;
next	1.107;

1.107
date	2006.01.29.00.48.19;	author krw;	state Exp;
branches;
next	1.106;

1.106
date	2005.12.21.12.26.24;	author dlg;	state Exp;
branches;
next	1.105;

1.105
date	2005.12.13.12.13.58;	author dlg;	state Exp;
branches;
next	1.104;

1.104
date	2005.12.11.03.32.07;	author dlg;	state Exp;
branches;
next	1.103;

1.103
date	2005.12.10.12.03.23;	author dlg;	state Exp;
branches;
next	1.102;

1.102
date	2005.12.09.07.49.25;	author dlg;	state Exp;
branches;
next	1.101;

1.101
date	2005.12.03.16.53.15;	author krw;	state Exp;
branches;
next	1.100;

1.100
date	2005.11.27.07.28.57;	author marco;	state Exp;
branches;
next	1.99;

1.99
date	2005.11.27.04.26.14;	author krw;	state Exp;
branches;
next	1.98;

1.98
date	2005.11.26.05.49.47;	author marco;	state Exp;
branches;
next	1.97;

1.97
date	2005.11.24.22.18.55;	author dlg;	state Exp;
branches;
next	1.96;

1.96
date	2005.11.23.21.36.18;	author dlg;	state Exp;
branches;
next	1.95;

1.95
date	2005.11.23.12.12.59;	author dlg;	state Exp;
branches;
next	1.94;

1.94
date	2005.10.11.09.10.49;	author dlg;	state Exp;
branches;
next	1.93;

1.93
date	2005.10.10.08.17.46;	author dlg;	state Exp;
branches;
next	1.92;

1.92
date	2005.10.03.21.11.14;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2005.10.02.06.30.50;	author dlg;	state Exp;
branches;
next	1.90;

1.90
date	2005.09.30.10.10.29;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2005.09.30.09.55.20;	author dlg;	state Exp;
branches;
next	1.88;

1.88
date	2005.09.30.07.53.03;	author dlg;	state Exp;
branches;
next	1.87;

1.87
date	2005.09.26.21.33.02;	author dlg;	state Exp;
branches;
next	1.86;

1.86
date	2005.09.25.04.59.14;	author dlg;	state Exp;
branches;
next	1.85;

1.85
date	2005.09.25.04.48.51;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2005.09.22.07.37.32;	author dlg;	state Exp;
branches;
next	1.83;

1.83
date	2005.09.21.10.54.37;	author dlg;	state Exp;
branches;
next	1.82;

1.82
date	2005.09.21.10.36.14;	author dlg;	state Exp;
branches;
next	1.81;

1.81
date	2005.09.21.08.52.44;	author dlg;	state Exp;
branches;
next	1.80;

1.80
date	2005.09.21.08.39.15;	author dlg;	state Exp;
branches;
next	1.79;

1.79
date	2005.09.21.08.36.35;	author dlg;	state Exp;
branches;
next	1.78;

1.78
date	2005.09.21.08.33.03;	author dlg;	state Exp;
branches;
next	1.77;

1.77
date	2005.09.19.08.17.13;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2005.09.19.07.45.28;	author dlg;	state Exp;
branches;
next	1.75;

1.75
date	2005.09.19.04.11.03;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2005.09.15.05.33.39;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2005.08.31.18.27.31;	author marco;	state Exp;
branches
	1.73.2.1;
next	1.72;

1.72
date	2005.08.31.17.59.09;	author marco;	state Exp;
branches;
next	1.71;

1.71
date	2005.08.31.12.52.36;	author marco;	state Exp;
branches;
next	1.70;

1.70
date	2005.08.30.02.40.25;	author dlg;	state Exp;
branches;
next	1.69;

1.69
date	2005.08.22.20.39.39;	author marco;	state Exp;
branches;
next	1.68;

1.68
date	2005.08.18.04.49.52;	author marco;	state Exp;
branches;
next	1.67;

1.67
date	2005.08.17.21.49.14;	author marco;	state Exp;
branches;
next	1.66;

1.66
date	2005.08.17.20.31.18;	author marco;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.17.19.38.27;	author marco;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.17.15.39.03;	author marco;	state Exp;
branches;
next	1.63;

1.63
date	2005.08.17.06.41.06;	author dlg;	state Exp;
branches;
next	1.62;

1.62
date	2005.08.17.06.31.01;	author marco;	state Exp;
branches;
next	1.61;

1.61
date	2005.08.17.06.23.52;	author marco;	state Exp;
branches;
next	1.60;

1.60
date	2005.08.17.06.07.31;	author marco;	state Exp;
branches;
next	1.59;

1.59
date	2005.08.16.01.12.46;	author marco;	state Exp;
branches;
next	1.58;

1.58
date	2005.08.15.23.22.45;	author marco;	state Exp;
branches;
next	1.57;

1.57
date	2005.08.09.14.29.18;	author marco;	state Exp;
branches;
next	1.56;

1.56
date	2005.08.08.20.23.46;	author marco;	state Exp;
branches;
next	1.55;

1.55
date	2005.08.08.04.02.31;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2005.08.08.03.11.36;	author marco;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.05.04.16.51;	author marco;	state Exp;
branches;
next	1.52;

1.52
date	2005.08.01.16.39.10;	author marco;	state Exp;
branches;
next	1.51;

1.51
date	2005.07.29.16.59.26;	author marco;	state Exp;
branches;
next	1.50;

1.50
date	2005.07.29.16.56.13;	author marco;	state Exp;
branches;
next	1.49;

1.49
date	2005.07.29.16.01.30;	author marco;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.18.15.10.56;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.18.01.29.01;	author marco;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.03.22.31.27;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2005.06.28.18.33.11;	author marco;	state Exp;
branches;
next	1.44;

1.44
date	2005.06.28.15.09.36;	author marco;	state Exp;
branches;
next	1.43;

1.43
date	2005.06.28.13.58.05;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2005.06.16.20.36.03;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.28.00.15.41;	author marco;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.28.00.07.03;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.27.20.39.29;	author marco;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.17.18.38.52;	author marco;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.11.18.48.53;	author marco;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.09.19.50.48;	author marco;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.27.21.54.47;	author marco;	state Exp;
branches;
next	1.34;

1.34
date	2005.04.17.17.37.38;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.17.16.32.43;	author marco;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.04.22.40.31;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.01.20.14.40;	author marco;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.29.22.24.27;	author marco;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.29.22.20.38;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.03.17.47.27;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.08.18.14.54;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.26.00.35.42;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.26.00.11.24;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.28.23.55.50;	author avsm;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.19.24.22;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.25.00.26.08;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.03.21.13.06;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.26.02.36.53;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.26.18.09.53;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.12.16.44.11;	author mickey;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.12.14.52.52;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.04.22.53.25;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.25.01.11.37;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.05.03.08.25;	author mickey;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.04.30.15.45.05;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.16.09.06.34;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.26.22.21.41;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.15.00.43.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.14.23.42.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.09.15.46.30;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.09.11.14.21;	author mickey;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.23.28;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.40.32;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.8.2.8;

1.8.2.8
date	2003.05.13.19.34.59;	author ho;	state Exp;
branches;
next	1.8.2.9;

1.8.2.9
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.8.2.10;

1.8.2.10
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;

1.73.2.1
date	2005.12.07.22.30.29;	author brad;	state Exp;
branches;
next	1.73.2.2;

1.73.2.2
date	2006.02.24.01.34.47;	author brad;	state Exp;
branches;
next	;

1.220.2.1
date	2011.10.05.10.45.47;	author henning;	state Exp;
branches;
next	;


desc
@@


1.233
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: ami.c,v 1.232 2016/08/14 04:08:03 dlg Exp $	*/

/*
 * Copyright (c) 2001 Michael Shalayeff
 * Copyright (c) 2005 Marco Peereboom
 * Copyright (c) 2006 David Gwynne
 * All rights reserved.
 *
 * The SCSI emulation layer is derived from gdt(4) driver,
 * Copyright (c) 1999, 2000 Niklas Hallqvist. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * American Megatrends Inc. MegaRAID controllers driver
 *
 * This driver was made because these ppl and organizations
 * donated hardware and provided documentation:
 *
 * - 428 model card
 *	John Kerbawy, Stephan Matis, Mark Stovall;
 *
 * - 467 and 475 model cards, docs
 *	American Megatrends Inc.;
 *
 * - uninterruptable electric power for cvs
 *	Theo de Raadt.
 */

#include "bio.h"

/* #define	AMI_DEBUG */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/rwlock.h>
#include <sys/pool.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/biovar.h>
#include <dev/ic/amireg.h>
#include <dev/ic/amivar.h>

#ifdef AMI_DEBUG
#define	AMI_DPRINTF(m,a)	do { if (ami_debug & (m)) printf a; } while (0)
#define	AMI_D_CMD	0x0001
#define	AMI_D_INTR	0x0002
#define	AMI_D_MISC	0x0004
#define	AMI_D_DMA	0x0008
#define	AMI_D_IOCTL	0x0010
int ami_debug = 0
/*	| AMI_D_CMD */
/*	| AMI_D_INTR */
/*	| AMI_D_MISC */
/*	| AMI_D_DMA */
/*	| AMI_D_IOCTL */
	;
#else
#define	AMI_DPRINTF(m,a)	/* m, a */
#endif

struct cfdriver ami_cd = {
	NULL, "ami", DV_DULL
};

void	ami_scsi_cmd(struct scsi_xfer *);
int	ami_scsi_ioctl(struct scsi_link *, u_long, caddr_t, int);
void	amiminphys(struct buf *bp, struct scsi_link *sl);

struct scsi_adapter ami_switch = {
	ami_scsi_cmd, amiminphys, 0, 0, ami_scsi_ioctl
};

void	ami_scsi_raw_cmd(struct scsi_xfer *);

struct scsi_adapter ami_raw_switch = {
	ami_scsi_raw_cmd, amiminphys, 0, 0,
};

void *		ami_get_ccb(void *);
void		ami_put_ccb(void *, void *);

u_int32_t	ami_read(struct ami_softc *, bus_size_t);
void		ami_write(struct ami_softc *, bus_size_t, u_int32_t);

void		ami_copyhds(struct ami_softc *, const u_int32_t *,
		    const u_int8_t *, const u_int8_t *);
struct ami_mem	*ami_allocmem(struct ami_softc *, size_t);
void		ami_freemem(struct ami_softc *, struct ami_mem *);
int		ami_alloc_ccbs(struct ami_softc *, int);

int		ami_poll(struct ami_softc *, struct ami_ccb *);
void		ami_start(struct ami_softc *, struct ami_ccb *);
void		ami_complete(struct ami_softc *, struct ami_ccb *, int);
void		ami_runqueue_tick(void *);
void		ami_runqueue(struct ami_softc *);

void 		ami_start_xs(struct ami_softc *sc, struct ami_ccb *,
		    struct scsi_xfer *);
void		ami_done_xs(struct ami_softc *, struct ami_ccb *);
void		ami_done_pt(struct ami_softc *, struct ami_ccb *);
void		ami_done_flush(struct ami_softc *, struct ami_ccb *);
void		ami_done_sysflush(struct ami_softc *, struct ami_ccb *);

void		ami_done_dummy(struct ami_softc *, struct ami_ccb *);
void		ami_done_ioctl(struct ami_softc *, struct ami_ccb *);
void		ami_done_init(struct ami_softc *, struct ami_ccb *);

void		ami_copy_internal_data(struct scsi_xfer *, void *, size_t);

int		ami_load_ptmem(struct ami_softc*, struct ami_ccb *,
		    void *, size_t, int, int);

#if NBIO > 0
int		ami_mgmt(struct ami_softc *, u_int8_t, u_int8_t, u_int8_t,
		    u_int8_t, size_t, void *);
int		ami_drv_pt(struct ami_softc *, u_int8_t, u_int8_t, u_int8_t *,
		    int, int, void *);
int		ami_drv_readcap(struct ami_softc *, u_int8_t, u_int8_t,
		    daddr_t *);
int		ami_drv_inq(struct ami_softc *, u_int8_t, u_int8_t, u_int8_t,
		    void *);
int		ami_ioctl(struct device *, u_long, caddr_t);
int		ami_ioctl_inq(struct ami_softc *, struct bioc_inq *);
int		ami_vol(struct ami_softc *, struct bioc_vol *,
		    struct ami_big_diskarray *);
int		ami_disk(struct ami_softc *, struct bioc_disk *,
		    struct ami_big_diskarray *);
int		ami_ioctl_vol(struct ami_softc *, struct bioc_vol *);
int		ami_ioctl_disk(struct ami_softc *, struct bioc_disk *);
int		ami_ioctl_alarm(struct ami_softc *, struct bioc_alarm *);
int		ami_ioctl_setstate(struct ami_softc *, struct bioc_setstate *);

#ifndef SMALL_KERNEL
int		ami_create_sensors(struct ami_softc *);
void		ami_refresh_sensors(void *);
#endif
#endif /* NBIO > 0 */

#define DEVNAME(_s)	((_s)->sc_dev.dv_xname)

void *
ami_get_ccb(void *xsc)
{
	struct ami_softc *sc = xsc;
	struct ami_ccb *ccb;

	mtx_enter(&sc->sc_ccb_freeq_mtx);
	ccb = TAILQ_FIRST(&sc->sc_ccb_freeq);
	if (ccb != NULL) {
		TAILQ_REMOVE(&sc->sc_ccb_freeq, ccb, ccb_link);
		ccb->ccb_state = AMI_CCB_READY;
	}
	mtx_leave(&sc->sc_ccb_freeq_mtx);

	return (ccb);
}

void
ami_put_ccb(void *xsc, void *xccb)
{
	struct ami_softc *sc = xsc;
	struct ami_ccb *ccb = xccb;

	ccb->ccb_state = AMI_CCB_FREE;
	ccb->ccb_xs = NULL;
	ccb->ccb_flags = 0;
	ccb->ccb_done = NULL;

	mtx_enter(&sc->sc_ccb_freeq_mtx);
	TAILQ_INSERT_TAIL(&sc->sc_ccb_freeq, ccb, ccb_link);
	mtx_leave(&sc->sc_ccb_freeq_mtx);
}

u_int32_t
ami_read(struct ami_softc *sc, bus_size_t r)
{
	u_int32_t rv;

	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, 4,
	    BUS_SPACE_BARRIER_READ);
	rv = bus_space_read_4(sc->sc_iot, sc->sc_ioh, r);

	AMI_DPRINTF(AMI_D_CMD, ("ari 0x%x 0x08%x ", r, rv));
	return (rv);
}

void
ami_write(struct ami_softc *sc, bus_size_t r, u_int32_t v)
{
	AMI_DPRINTF(AMI_D_CMD, ("awo 0x%x 0x%08x ", r, v));

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, r, v);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh, r, 4,
	    BUS_SPACE_BARRIER_WRITE);
}

struct ami_mem *
ami_allocmem(struct ami_softc *sc, size_t size)
{
	struct ami_mem		*am;
	int			nsegs;

	am = malloc(sizeof(struct ami_mem), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (am == NULL)
		return (NULL);

	am->am_size = size;

	if (bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &am->am_map) != 0)
		goto amfree; 

	if (bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE, 0, &am->am_seg, 1,
	    &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0)
		goto destroy;

	if (bus_dmamem_map(sc->sc_dmat, &am->am_seg, nsegs, size, &am->am_kva,
	    BUS_DMA_NOWAIT) != 0)
		goto free;

	if (bus_dmamap_load(sc->sc_dmat, am->am_map, am->am_kva, size, NULL,
	    BUS_DMA_NOWAIT) != 0)
		goto unmap;

	return (am);

unmap:
	bus_dmamem_unmap(sc->sc_dmat, am->am_kva, size);
free:
	bus_dmamem_free(sc->sc_dmat, &am->am_seg, 1);
destroy:
	bus_dmamap_destroy(sc->sc_dmat, am->am_map);
amfree:
	free(am, M_DEVBUF, sizeof *am);

	return (NULL);
}

void
ami_freemem(struct ami_softc *sc, struct ami_mem *am)
{
	bus_dmamap_unload(sc->sc_dmat, am->am_map);
	bus_dmamem_unmap(sc->sc_dmat, am->am_kva, am->am_size);
	bus_dmamem_free(sc->sc_dmat, &am->am_seg, 1);
	bus_dmamap_destroy(sc->sc_dmat, am->am_map);
	free(am, M_DEVBUF, sizeof *am);
}

void
ami_copyhds(struct ami_softc *sc, const u_int32_t *sizes,
    const u_int8_t *props, const u_int8_t *stats)
{
	int i;

	for (i = 0; i < sc->sc_nunits; i++) {
		sc->sc_hdr[i].hd_present = 1;
		sc->sc_hdr[i].hd_is_logdrv = 1;
		sc->sc_hdr[i].hd_size = letoh32(sizes[i]);
		sc->sc_hdr[i].hd_prop = props[i];
		sc->sc_hdr[i].hd_stat = stats[i];
	}
}

int
ami_alloc_ccbs(struct ami_softc *sc, int nccbs)
{
	struct ami_ccb *ccb;
	struct ami_ccbmem *ccbmem, *mem;
	int i, error;

	sc->sc_ccbs = mallocarray(nccbs, sizeof(struct ami_ccb),
	    M_DEVBUF, M_NOWAIT);
	if (sc->sc_ccbs == NULL) {
		printf(": unable to allocate ccbs\n");
		return (1);
	}

	sc->sc_ccbmem_am = ami_allocmem(sc, sizeof(struct ami_ccbmem) * nccbs);
	if (sc->sc_ccbmem_am == NULL) {
		printf(": unable to allocate ccb dmamem\n");
		goto free_ccbs;
	}
	ccbmem = AMIMEM_KVA(sc->sc_ccbmem_am);

	TAILQ_INIT(&sc->sc_ccb_freeq);
	mtx_init(&sc->sc_ccb_freeq_mtx, IPL_BIO);
	TAILQ_INIT(&sc->sc_ccb_preq);
	TAILQ_INIT(&sc->sc_ccb_runq);
	timeout_set(&sc->sc_run_tmo, ami_runqueue_tick, sc);

	scsi_iopool_init(&sc->sc_iopool, sc, ami_get_ccb, ami_put_ccb);

	for (i = 0; i < nccbs; i++) {
		ccb = &sc->sc_ccbs[i];
		mem = &ccbmem[i];

		error = bus_dmamap_create(sc->sc_dmat, AMI_MAXFER,
		    AMI_MAXOFFSETS, AMI_MAXFER, 0,
		    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &ccb->ccb_dmamap);
		if (error) {
			printf(": cannot create ccb dmamap (%d)\n", error);
			goto free_list;
		}

		ccb->ccb_sc = sc;

		ccb->ccb_cmd.acc_id = i + 1;
		ccb->ccb_offset = sizeof(struct ami_ccbmem) * i;

		ccb->ccb_pt = &mem->cd_pt;
		ccb->ccb_ptpa = htole32(AMIMEM_DVA(sc->sc_ccbmem_am) +
		    ccb->ccb_offset);

		ccb->ccb_sglist = mem->cd_sg;
		ccb->ccb_sglistpa = htole32(AMIMEM_DVA(sc->sc_ccbmem_am) +
		    ccb->ccb_offset + sizeof(struct ami_passthrough));

		/* override last command for management */
		if (i == nccbs - 1) {
			ccb->ccb_cmd.acc_id = 0xfe;
			sc->sc_mgmtccb = ccb;
		} else {
			ami_put_ccb(sc, ccb);
		}
	}

	return (0);

free_list:
	while ((ccb = ami_get_ccb(sc)) != NULL)
		bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);

	ami_freemem(sc, sc->sc_ccbmem_am);
free_ccbs:
	free(sc->sc_ccbs, M_DEVBUF, 0);

	return (1);
}

int
ami_attach(struct ami_softc *sc)
{
	struct scsibus_attach_args saa;
	struct ami_rawsoftc *rsc;
	struct ami_ccb iccb;
	struct ami_iocmd *cmd;
	struct ami_mem *am;
	struct ami_inquiry *inq;
	struct ami_fc_einquiry *einq;
	struct ami_fc_prodinfo *pi;
	const char *p;
	paddr_t	pa;

	mtx_init(&sc->sc_cmd_mtx, IPL_BIO);

	am = ami_allocmem(sc, NBPG);
	if (am == NULL) {
		printf(": unable to allocate init data\n");
		return (1);
	}
	pa = htole32(AMIMEM_DVA(am));

	sc->sc_mbox_am = ami_allocmem(sc, sizeof(struct ami_iocmd));
	if (sc->sc_mbox_am == NULL) {
		printf(": unable to allocate mbox\n");
		goto free_idata;
	}
	sc->sc_mbox = (volatile struct ami_iocmd *)AMIMEM_KVA(sc->sc_mbox_am);
	sc->sc_mbox_pa = htole32(AMIMEM_DVA(sc->sc_mbox_am));
	AMI_DPRINTF(AMI_D_CMD, ("mbox=%p ", sc->sc_mbox));
	AMI_DPRINTF(AMI_D_CMD, ("mbox_pa=0x%llx ", (long long)sc->sc_mbox_pa));

	/* create a spartan ccb for use with ami_poll */
	bzero(&iccb, sizeof(iccb));
	iccb.ccb_sc = sc;
	iccb.ccb_done = ami_done_init;
	cmd = &iccb.ccb_cmd;

	(sc->sc_init)(sc);

	/* try FC inquiry first */
	cmd->acc_cmd = AMI_FCOP;
	cmd->acc_io.aio_channel = AMI_FC_EINQ3;
	cmd->acc_io.aio_param = AMI_FC_EINQ3_SOLICITED_FULL;
	cmd->acc_io.aio_data = pa;
	if (ami_poll(sc, &iccb) == 0) {
		einq = AMIMEM_KVA(am);
		pi = AMIMEM_KVA(am);

		sc->sc_nunits = einq->ain_nlogdrv;
		sc->sc_drvinscnt = einq->ain_drvinscnt + 1; /* force scan */
		ami_copyhds(sc, einq->ain_ldsize, einq->ain_ldprop,
		    einq->ain_ldstat);

		cmd->acc_cmd = AMI_FCOP;
		cmd->acc_io.aio_channel = AMI_FC_PRODINF;
		cmd->acc_io.aio_param = 0;
		cmd->acc_io.aio_data = pa;
		if (ami_poll(sc, &iccb) == 0) {
			sc->sc_maxunits = AMI_BIG_MAX_LDRIVES;

			bcopy (pi->api_fwver, sc->sc_fwver, 16);
			sc->sc_fwver[15] = '\0';
			bcopy (pi->api_biosver, sc->sc_biosver, 16);
			sc->sc_biosver[15] = '\0';
			sc->sc_channels = pi->api_channels;
			sc->sc_targets = pi->api_fcloops;
			sc->sc_memory = letoh16(pi->api_ramsize);
			sc->sc_maxcmds = pi->api_maxcmd;
			p = "FC loop";
		}
	}

	if (sc->sc_maxunits == 0) {
		inq = AMIMEM_KVA(am);

		cmd->acc_cmd = AMI_EINQUIRY;
		cmd->acc_io.aio_channel = 0;
		cmd->acc_io.aio_param = 0;
		cmd->acc_io.aio_data = pa;
		if (ami_poll(sc, &iccb) != 0) {
			cmd->acc_cmd = AMI_INQUIRY;
			cmd->acc_io.aio_channel = 0;
			cmd->acc_io.aio_param = 0;
			cmd->acc_io.aio_data = pa;
			if (ami_poll(sc, &iccb) != 0) {
				printf(": cannot do inquiry\n");
				goto free_mbox;
			}
		}

		sc->sc_maxunits = AMI_MAX_LDRIVES;
		sc->sc_nunits = inq->ain_nlogdrv;
		ami_copyhds(sc, inq->ain_ldsize, inq->ain_ldprop,
		    inq->ain_ldstat);

		bcopy (inq->ain_fwver, sc->sc_fwver, 4);
		sc->sc_fwver[4] = '\0';
		bcopy (inq->ain_biosver, sc->sc_biosver, 4);
		sc->sc_biosver[4] = '\0';
		sc->sc_channels = inq->ain_channels;
		sc->sc_targets = inq->ain_targets;
		sc->sc_memory = inq->ain_ramsize;
		sc->sc_maxcmds = inq->ain_maxcmd;
		sc->sc_drvinscnt = inq->ain_drvinscnt + 1; /* force scan */
		p = "target";
	}

	if (sc->sc_flags & AMI_BROKEN) {
		sc->sc_link.openings = 1;
		sc->sc_maxcmds = 1;
		sc->sc_maxunits = 1;
	} else {
		sc->sc_maxunits = AMI_BIG_MAX_LDRIVES;
		if (sc->sc_maxcmds > AMI_MAXCMDS)
			sc->sc_maxcmds = AMI_MAXCMDS;
		/*
		 * Reserve ccb's for ioctl's and raw commands to
		 * processors/enclosures by lowering the number of
		 * openings available for logical units.
		 */
		sc->sc_maxcmds -= AMI_MAXIOCTLCMDS + AMI_MAXPROCS *
		    AMI_MAXRAWCMDS * sc->sc_channels;

		sc->sc_link.openings = sc->sc_maxcmds;
	}

	if (ami_alloc_ccbs(sc, AMI_MAXCMDS + 1) != 0) {
		/* error already printed */
		goto free_mbox;
	}

	ami_freemem(sc, am);

	/* hack for hp netraid version encoding */
	if ('A' <= sc->sc_fwver[2] && sc->sc_fwver[2] <= 'Z' &&
	    sc->sc_fwver[1] < ' ' && sc->sc_fwver[0] < ' ' &&
	    'A' <= sc->sc_biosver[2] && sc->sc_biosver[2] <= 'Z' &&
	    sc->sc_biosver[1] < ' ' && sc->sc_biosver[0] < ' ') {

		snprintf(sc->sc_fwver, sizeof sc->sc_fwver, "%c.%02d.%02d",
		    sc->sc_fwver[2], sc->sc_fwver[1], sc->sc_fwver[0]);
		snprintf(sc->sc_biosver, sizeof sc->sc_biosver, "%c.%02d.%02d",
		    sc->sc_biosver[2], sc->sc_biosver[1], sc->sc_biosver[0]);
	}

	/* TODO: fetch & print cache strategy */
	/* TODO: fetch & print scsi and raid info */

	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter = &ami_switch;
	sc->sc_link.adapter_target = sc->sc_maxunits;
	sc->sc_link.adapter_buswidth = sc->sc_maxunits;
	sc->sc_link.pool = &sc->sc_iopool;

#ifdef AMI_DEBUG
	printf(", FW %s, BIOS v%s, %dMB RAM\n"
	    "%s: %d channels, %d %ss, %d logical drives, "
	    "openings %d, max commands %d, quirks: %04x\n",
	    sc->sc_fwver, sc->sc_biosver, sc->sc_memory, DEVNAME(sc),
	    sc->sc_channels, sc->sc_targets, p, sc->sc_nunits,
	    sc->sc_link.openings, sc->sc_maxcmds, sc->sc_flags);
#else
	printf(", FW %s, BIOS v%s, %dMB RAM\n"
	    "%s: %d channels, %d %ss, %d logical drives\n",
	    sc->sc_fwver, sc->sc_biosver, sc->sc_memory, DEVNAME(sc),
	    sc->sc_channels, sc->sc_targets, p, sc->sc_nunits);
#endif /* AMI_DEBUG */

	if (sc->sc_flags & AMI_BROKEN && sc->sc_nunits > 1)
		printf("%s: firmware buggy, limiting access to first logical "
		    "disk\n", DEVNAME(sc));

	/* lock around ioctl requests */
	rw_init(&sc->sc_lock, NULL);

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	config_found(&sc->sc_dev, &saa, scsiprint);

	/* can't do bioctls, sensors, or pass-through on broken devices */
	if (sc->sc_flags & AMI_BROKEN)
		return (0);

#if NBIO > 0
	if (bio_register(&sc->sc_dev, ami_ioctl) != 0)
		printf("%s: controller registration failed\n", DEVNAME(sc));
	else
		sc->sc_ioctl = ami_ioctl;

#ifndef SMALL_KERNEL
	if (ami_create_sensors(sc) != 0)
		printf("%s: unable to create sensors\n", DEVNAME(sc));
#endif
#endif

	rsc = mallocarray(sc->sc_channels, sizeof(struct ami_rawsoftc),
	    M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!rsc) {
		printf("%s: no memory for raw interface\n", DEVNAME(sc));
		return (0);
	}

	for (sc->sc_rawsoftcs = rsc;
	     rsc < &sc->sc_rawsoftcs[sc->sc_channels]; rsc++) {

		struct scsibus_softc *ptbus;
		struct scsi_link *proclink;
		struct device *procdev;

		rsc->sc_softc = sc;
		rsc->sc_channel = rsc - sc->sc_rawsoftcs;
		rsc->sc_link.openings = sc->sc_maxcmds;
		rsc->sc_link.adapter_softc = rsc;
		rsc->sc_link.adapter = &ami_raw_switch;
		rsc->sc_proctarget = -1;
		/* TODO fetch it from the controller */
		rsc->sc_link.adapter_target = 16;
		rsc->sc_link.adapter_buswidth = 16;
		rsc->sc_link.pool = &sc->sc_iopool;

		bzero(&saa, sizeof(saa));
		saa.saa_sc_link = &rsc->sc_link;

		ptbus = (struct scsibus_softc *)config_found(&sc->sc_dev,
		    &saa, scsiprint);

		if (ptbus == NULL || rsc->sc_proctarget == -1)
			continue;

		proclink = scsi_get_link(ptbus, rsc->sc_proctarget, 0);
		if (proclink == NULL)
			continue;

		procdev = proclink->device_softc;
		strlcpy(rsc->sc_procdev, procdev->dv_xname,
		    sizeof(rsc->sc_procdev));
	}

	return (0);

free_mbox:
	ami_freemem(sc, sc->sc_mbox_am);
free_idata:
	ami_freemem(sc, am);

	return (1);
}

int
ami_quartz_init(struct ami_softc *sc)
{
	ami_write(sc, AMI_QIDB, 0);

	return (0);
}

int
ami_quartz_exec(struct ami_softc *sc, struct ami_iocmd *cmd)
{
	if (sc->sc_mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (EBUSY);
	}

	memcpy((struct ami_iocmd *)sc->sc_mbox, cmd, 16);
	bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
	    sizeof(struct ami_iocmd), BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	sc->sc_mbox->acc_busy = 1;
	sc->sc_mbox->acc_poll = 0;
	sc->sc_mbox->acc_ack = 0;

	ami_write(sc, AMI_QIDB, sc->sc_mbox_pa | htole32(AMI_QIDB_EXEC));

	return (0);
}

int
ami_quartz_done(struct ami_softc *sc, struct ami_iocmd *mbox)
{
	u_int32_t i, n;
	u_int8_t nstat, status;
	u_int8_t completed[AMI_MAXSTATACK];

	if (ami_read(sc, AMI_QODB) != AMI_QODB_READY)
		return (0); /* nothing to do */

	ami_write(sc, AMI_QODB, AMI_QODB_READY);

	/*
	 * The following sequence is not supposed to have a timeout clause
	 * since the firmware has a "guarantee" that all commands will
	 * complete.  The choice is either panic or hoping for a miracle
	 * and that the IOs will complete much later.
	 */
	i = 0;
	while ((nstat = sc->sc_mbox->acc_nstat) == 0xff) {
		bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
		    sizeof(struct ami_iocmd), BUS_DMASYNC_POSTREAD);
		delay(1);
		if (i++ > 1000000)
			return (0); /* nothing to do */
	}
	sc->sc_mbox->acc_nstat = 0xff;
	bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
	    sizeof(struct ami_iocmd), BUS_DMASYNC_POSTWRITE);

	/* wait until fw wrote out all completions */
	i = 0;
	AMI_DPRINTF(AMI_D_CMD, ("aqd %d ", nstat));
	for (n = 0; n < nstat; n++) {
		bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
		    sizeof(struct ami_iocmd), BUS_DMASYNC_PREREAD);
		while ((completed[n] = sc->sc_mbox->acc_cmplidl[n]) == 0xff) {
			delay(1);
			if (i++ > 1000000)
				return (0); /* nothing to do */
		}
		sc->sc_mbox->acc_cmplidl[n] = 0xff;
		bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
		    sizeof(struct ami_iocmd), BUS_DMASYNC_POSTWRITE);
	}

	/* this should never happen, someone screwed up the completion status */
	if ((status = sc->sc_mbox->acc_status) == 0xff)
		panic("%s: status 0xff from the firmware", DEVNAME(sc));

	sc->sc_mbox->acc_status = 0xff;

	/* copy mailbox to temporary one and fixup other changed values */
	bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_mbox_am), 0, 16,
	    BUS_DMASYNC_POSTWRITE);
	memcpy(mbox, (struct ami_iocmd *)sc->sc_mbox, 16);
	mbox->acc_nstat = nstat;
	mbox->acc_status = status;
	for (n = 0; n < nstat; n++)
		mbox->acc_cmplidl[n] = completed[n];

	/* ack interrupt */
	ami_write(sc, AMI_QIDB, AMI_QIDB_ACK);

	return (1);	/* ready to complete all IOs in acc_cmplidl */
}

int
ami_quartz_poll(struct ami_softc *sc, struct ami_iocmd *cmd)
{
	/* struct scsi_xfer *xs = ccb->ccb_xs; */
	u_int32_t i;
	u_int8_t status;

	splassert(IPL_BIO);

	if (sc->sc_dis_poll)
		return (-1); /* fail */

	i = 0;
	while (sc->sc_mbox->acc_busy && (i < AMI_MAX_BUSYWAIT)) {
		delay(1);
		i++;
	}
	if (sc->sc_mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (-1);
	}

	memcpy((struct ami_iocmd *)sc->sc_mbox, cmd, 16);
	bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_mbox_am), 0, 16,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	sc->sc_mbox->acc_id = 0xfe;
	sc->sc_mbox->acc_busy = 1;
	sc->sc_mbox->acc_poll = 0;
	sc->sc_mbox->acc_ack = 0;
	sc->sc_mbox->acc_nstat = 0xff;
	sc->sc_mbox->acc_status = 0xff;

	/* send command to firmware */
	ami_write(sc, AMI_QIDB, sc->sc_mbox_pa | htole32(AMI_QIDB_EXEC));

	i = 0;
	while ((sc->sc_mbox->acc_nstat == 0xff) && (i < AMI_MAX_POLLWAIT)) {
		delay(1);
		i++;
	}
	if (i >= AMI_MAX_POLLWAIT) {
		printf("%s: command not accepted, polling disabled\n",
		    DEVNAME(sc));
		sc->sc_dis_poll = 1;
		return (-1);
	}

	/* poll firmware */
	i = 0;
	while ((sc->sc_mbox->acc_poll != 0x77) && (i < AMI_MAX_POLLWAIT)) {
		delay(1);
		i++;
	}
	if (i >= AMI_MAX_POLLWAIT) {
		printf("%s: firmware didn't reply, polling disabled\n",
		    DEVNAME(sc));
		sc->sc_dis_poll = 1;
		return (-1);
	}

	/* ack */
	ami_write(sc, AMI_QIDB, sc->sc_mbox_pa | htole32(AMI_QIDB_ACK));

	i = 0;
	while((ami_read(sc, AMI_QIDB) & AMI_QIDB_ACK) &&
	    (i < AMI_MAX_POLLWAIT)) {
		delay(1);
		i++;
	}
	if (i >= AMI_MAX_POLLWAIT) {
		printf("%s: firmware didn't ack the ack, polling disabled\n",
		    DEVNAME(sc));
		sc->sc_dis_poll = 1;
		return (-1);
	}

	sc->sc_mbox->acc_poll = 0;
	sc->sc_mbox->acc_ack = 0x77;
	status = sc->sc_mbox->acc_status;
	sc->sc_mbox->acc_nstat = 0xff;
	sc->sc_mbox->acc_status = 0xff;

	for (i = 0; i < AMI_MAXSTATACK; i++)
		sc->sc_mbox->acc_cmplidl[i] = 0xff;

	return (status);
}

int
ami_schwartz_init(struct ami_softc *sc)
{
	u_int32_t a = (u_int32_t)sc->sc_mbox_pa;

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, AMI_SMBADDR, a);
	/* XXX 40bit address ??? */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMI_SMBENA, 0);

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMI_SCMD, AMI_SCMD_ACK);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMI_SIEM, AMI_SEIM_ENA |
	    bus_space_read_1(sc->sc_iot, sc->sc_ioh, AMI_SIEM));

	return (0);
}

int
ami_schwartz_exec(struct ami_softc *sc, struct ami_iocmd *cmd)
{
	if (bus_space_read_1(sc->sc_iot, sc->sc_ioh, AMI_SMBSTAT) &
	    AMI_SMBST_BUSY) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (EBUSY);
	}

	memcpy((struct ami_iocmd *)sc->sc_mbox, cmd, 16);
	sc->sc_mbox->acc_busy = 1;
	sc->sc_mbox->acc_poll = 0;
	sc->sc_mbox->acc_ack = 0;

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMI_SCMD, AMI_SCMD_EXEC);
	return (0);
}

int
ami_schwartz_done(struct ami_softc *sc, struct ami_iocmd *mbox)
{
	u_int8_t stat;

#if 0
	/* do not scramble the busy mailbox */
	if (sc->sc_mbox->acc_busy)
		return (0);
#endif
	if (bus_space_read_1(sc->sc_iot, sc->sc_ioh, AMI_SMBSTAT) &
	    AMI_SMBST_BUSY)
		return (0);

	stat = bus_space_read_1(sc->sc_iot, sc->sc_ioh, AMI_ISTAT);
	if (stat & AMI_ISTAT_PEND) {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMI_ISTAT, stat);

		*mbox = *sc->sc_mbox;
		AMI_DPRINTF(AMI_D_CMD, ("asd %d ", mbox->acc_nstat));

		bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMI_SCMD,
		    AMI_SCMD_ACK);

		return (1);
	}

	return (0);
}

int
ami_schwartz_poll(struct ami_softc *sc, struct ami_iocmd *mbox)
{
	u_int8_t status;
	u_int32_t i;
	int rv;

	splassert(IPL_BIO);

	if (sc->sc_dis_poll)
		return (-1); /* fail */

	for (i = 0; i < AMI_MAX_POLLWAIT; i++) {
		if (!(bus_space_read_1(sc->sc_iot, sc->sc_ioh, AMI_SMBSTAT) &
		    AMI_SMBST_BUSY))
			break;
		delay(1);
	}
	if (i >= AMI_MAX_POLLWAIT) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (-1);
	}

	memcpy((struct ami_iocmd *)sc->sc_mbox, mbox, 16);
	bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_mbox_am), 0, 16,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	sc->sc_mbox->acc_busy = 1;
	sc->sc_mbox->acc_poll = 0;
	sc->sc_mbox->acc_ack = 0;
	/* send command to firmware */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMI_SCMD, AMI_SCMD_EXEC);

	/* wait until no longer busy */
	for (i = 0; i < AMI_MAX_POLLWAIT; i++) {
		if (!(bus_space_read_1(sc->sc_iot, sc->sc_ioh, AMI_SMBSTAT) &
		    AMI_SMBST_BUSY))
			break;
		delay(1);
	}
	if (i >= AMI_MAX_POLLWAIT) {
		printf("%s: command not accepted, polling disabled\n",
		    DEVNAME(sc));
		sc->sc_dis_poll = 1;
		return (-1);
	}

	/* wait for interrupt bit */
	for (i = 0; i < AMI_MAX_POLLWAIT; i++) {
		status = bus_space_read_1(sc->sc_iot, sc->sc_ioh, AMI_ISTAT);
		if (status & AMI_ISTAT_PEND)
			break;
		delay(1);
	}
	if (i >= AMI_MAX_POLLWAIT) {
		printf("%s: interrupt didn't arrive, polling disabled\n",
		    DEVNAME(sc));
		sc->sc_dis_poll = 1;
		return (-1);
	}

	/* write ststus back to firmware */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMI_ISTAT, status);

	/* copy mailbox and status back */
	bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
	    sizeof(struct ami_iocmd), BUS_DMASYNC_PREREAD);
	*mbox = *sc->sc_mbox;
	rv = sc->sc_mbox->acc_status;

	/* ack interrupt */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AMI_SCMD, AMI_SCMD_ACK);

	return (rv);
}

void
ami_start_xs(struct ami_softc *sc, struct ami_ccb *ccb, struct scsi_xfer *xs)
{
	if (xs->flags & SCSI_POLL)
		ami_complete(sc, ccb, xs->timeout);
	else
		ami_start(sc, ccb);
}

void
ami_start(struct ami_softc *sc, struct ami_ccb *ccb)
{
	mtx_enter(&sc->sc_cmd_mtx);
	ccb->ccb_state = AMI_CCB_PREQUEUED;
	TAILQ_INSERT_TAIL(&sc->sc_ccb_preq, ccb, ccb_link);
	mtx_leave(&sc->sc_cmd_mtx);

	ami_runqueue(sc);
}

void
ami_runqueue_tick(void *arg)
{
	ami_runqueue(arg);
}

void
ami_runqueue(struct ami_softc *sc)
{
	struct ami_ccb *ccb;
	int add = 0;

	mtx_enter(&sc->sc_cmd_mtx);
	if (!sc->sc_drainio) {
		while ((ccb = TAILQ_FIRST(&sc->sc_ccb_preq)) != NULL) {
			if (sc->sc_exec(sc, &ccb->ccb_cmd) != 0) {
				add = 1;
				break;
			}

			TAILQ_REMOVE(&sc->sc_ccb_preq, ccb, ccb_link);
			ccb->ccb_state = AMI_CCB_QUEUED;
			TAILQ_INSERT_TAIL(&sc->sc_ccb_runq, ccb, ccb_link);
		}
	}
	mtx_leave(&sc->sc_cmd_mtx);

	if (add)
		timeout_add(&sc->sc_run_tmo, 1);
}

int
ami_poll(struct ami_softc *sc, struct ami_ccb *ccb)
{
	int error;

	mtx_enter(&sc->sc_cmd_mtx);
	error = sc->sc_poll(sc, &ccb->ccb_cmd);
	if (error == -1)
		ccb->ccb_flags |= AMI_CCB_F_ERR;
	mtx_leave(&sc->sc_cmd_mtx);

	ccb->ccb_done(sc, ccb);

	return (error);
}

void
ami_complete(struct ami_softc *sc, struct ami_ccb *ccb, int timeout)
{
	void (*done)(struct ami_softc *, struct ami_ccb *);
	int ready;
	int i = 0;
	int s;

	done = ccb->ccb_done;
	ccb->ccb_done = ami_done_dummy;

	/*
	 * since exec will return if the mbox is busy we have to busy wait
	 * ourselves. once its in, jam it into the runq.
	 */
	mtx_enter(&sc->sc_cmd_mtx);
	while (i < AMI_MAX_BUSYWAIT) {
		if (sc->sc_exec(sc, &ccb->ccb_cmd) == 0) {
			ccb->ccb_state = AMI_CCB_QUEUED;
			TAILQ_INSERT_TAIL(&sc->sc_ccb_runq, ccb, ccb_link);
			break;
		}
		DELAY(1000);
		i++;
	}
	ready = (ccb->ccb_state == AMI_CCB_QUEUED);
	mtx_leave(&sc->sc_cmd_mtx);

	if (!ready) {
		ccb->ccb_flags |= AMI_CCB_F_ERR;
		ccb->ccb_state = AMI_CCB_READY;
		goto done;
	}

	/*
	 * Override timeout for PERC3.  The first command triggers a chip
	 * reset on the QL12160 chip which causes the firmware to reload.
	 * 30000 is slightly less than double of how long it takes for the
	 * firmware to be up again.  After the first two commands the
	 * timeouts are as expected.
	 */
	timeout = MAX(30000, timeout); /* timeout */

	while (ccb->ccb_state == AMI_CCB_QUEUED) {
		s = splbio(); /* interrupt handlers are called at their IPL */
		ready = ami_intr(sc);
		splx(s);
		
		if (ready == 0) {
			if (timeout-- == 0) {
				/* XXX */
				printf("%s: timeout\n", DEVNAME(sc));
				return;
			}

			delay(1000);
			continue;
		}
	}

done:
	done(sc, ccb);
}

void
ami_done_pt(struct ami_softc *sc, struct ami_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->ccb_xs;
	struct scsi_link *link = xs->sc_link;
	struct ami_rawsoftc *rsc = link->adapter_softc;
	u_int8_t target = link->target, type;

	bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
	    ccb->ccb_offset, sizeof(struct ami_ccbmem),
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

	if (xs->data != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}

	xs->resid = 0;

	if (ccb->ccb_flags & AMI_CCB_F_ERR)
		xs->error = XS_DRIVER_STUFFUP;
 	else if (ccb->ccb_status != 0x00)
		xs->error = XS_DRIVER_STUFFUP;
	else if (xs->flags & SCSI_POLL && xs->cmd->opcode == INQUIRY) {
		type = ((struct scsi_inquiry_data *)xs->data)->device &
		    SID_TYPE;
		if (!(type == T_PROCESSOR || type == T_ENCLOSURE))
			xs->error = XS_DRIVER_STUFFUP;
		else
			rsc->sc_proctarget = target;
	}

	scsi_done(xs);
}

void
ami_done_xs(struct ami_softc *sc, struct ami_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->ccb_xs;

	if (xs->data != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize,
		    (xs->flags & SCSI_DATA_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

		bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
		    ccb->ccb_offset, sizeof(struct ami_ccbmem),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}

	xs->resid = 0;

	if (ccb->ccb_flags & AMI_CCB_F_ERR)
		xs->error = XS_DRIVER_STUFFUP;

	scsi_done(xs);
}

void
ami_done_flush(struct ami_softc *sc, struct ami_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->ccb_xs;
	struct ami_iocmd *cmd = &ccb->ccb_cmd;

	if (ccb->ccb_flags & AMI_CCB_F_ERR) {
		xs->error = XS_DRIVER_STUFFUP;
		xs->resid = 0;

		scsi_done(xs);
		return;
	}

	/* reuse the ccb for the sysflush command */
	ccb->ccb_done = ami_done_sysflush;
	cmd->acc_cmd = AMI_SYSFLUSH;

	ami_start_xs(sc, ccb, xs);
}

void
ami_done_sysflush(struct ami_softc *sc, struct ami_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->ccb_xs;

	xs->resid = 0;
	if (ccb->ccb_flags & AMI_CCB_F_ERR)
		xs->error = XS_DRIVER_STUFFUP;

	scsi_done(xs);
}

void
ami_done_dummy(struct ami_softc *sc, struct ami_ccb *ccb)
{
}

void
ami_done_ioctl(struct ami_softc *sc, struct ami_ccb *ccb)
{
	wakeup(ccb);
}

void
ami_done_init(struct ami_softc *sc, struct ami_ccb *ccb)
{
	/* the ccb is going to be reused, so do nothing with it */
}

void
amiminphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > AMI_MAXFER)
		bp->b_bcount = AMI_MAXFER;
	minphys(bp);
}

void
ami_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size)
{
	size_t copy_cnt;

	AMI_DPRINTF(AMI_D_MISC, ("ami_copy_internal_data "));

	if (!xs->datalen)
		printf("uio move not yet supported\n");
	else {
		copy_cnt = MIN(size, xs->datalen);
		bcopy(v, xs->data, copy_cnt);
	}
}

void
ami_scsi_raw_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct ami_rawsoftc *rsc = link->adapter_softc;
	struct ami_softc *sc = rsc->sc_softc;
	u_int8_t channel = rsc->sc_channel, target = link->target;
	struct ami_ccb *ccb;

	AMI_DPRINTF(AMI_D_CMD, ("ami_scsi_raw_cmd "));

	if (xs->cmdlen > AMI_MAX_CDB) {
		AMI_DPRINTF(AMI_D_CMD, ("CDB too big %p ", xs));
		bzero(&xs->sense, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | SSD_ERRCODE_CURRENT;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* illcmd, 0x24 illfield */
		xs->error = XS_SENSE;
		scsi_done(xs);
		return;
	}

	xs->error = XS_NOERROR;

	ccb = xs->io;

	memset(ccb->ccb_pt, 0, sizeof(struct ami_passthrough));

	ccb->ccb_xs = xs;
	ccb->ccb_done = ami_done_pt;

	ccb->ccb_cmd.acc_cmd = AMI_PASSTHRU;
	ccb->ccb_cmd.acc_passthru.apt_data = ccb->ccb_ptpa;
	
	ccb->ccb_pt->apt_param = AMI_PTPARAM(AMI_TIMEOUT_6,1,0);
	ccb->ccb_pt->apt_channel = channel;
	ccb->ccb_pt->apt_target = target;
	bcopy(xs->cmd, ccb->ccb_pt->apt_cdb, AMI_MAX_CDB);
	ccb->ccb_pt->apt_ncdb = xs->cmdlen;
	ccb->ccb_pt->apt_nsense = AMI_MAX_SENSE;
	ccb->ccb_pt->apt_datalen = xs->datalen;
	ccb->ccb_pt->apt_data = 0;

	if (ami_load_ptmem(sc, ccb, xs->data, xs->datalen,
	    xs->flags & SCSI_DATA_IN, xs->flags & SCSI_NOSLEEP) != 0) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	ami_start_xs(sc, ccb, xs);
}

int
ami_load_ptmem(struct ami_softc *sc, struct ami_ccb *ccb, void *data,
    size_t len, int read, int nowait)
{
	bus_dmamap_t dmap = ccb->ccb_dmamap;
	bus_dma_segment_t *sgd;
	int error, i;

	if (data != NULL) {
		error = bus_dmamap_load(sc->sc_dmat, dmap, data, len, NULL,
		    nowait ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
		if (error) {
			if (error == EFBIG)
				printf("more than %d dma segs\n",
				    AMI_MAXOFFSETS);
			else
				printf("error %d loading dma map\n", error);

			return (1);
		}

		sgd = dmap->dm_segs;
		if (dmap->dm_nsegs > 1) {
			struct ami_sgent *sgl = ccb->ccb_sglist;

			ccb->ccb_pt->apt_nsge = dmap->dm_nsegs;
			ccb->ccb_pt->apt_data = ccb->ccb_sglistpa;

			for (i = 0; i < dmap->dm_nsegs; i++) {
				sgl[i].asg_addr = htole32(sgd[i].ds_addr);
				sgl[i].asg_len = htole32(sgd[i].ds_len);
			}
		} else {
			ccb->ccb_pt->apt_nsge = 0;
			ccb->ccb_pt->apt_data = htole32(sgd->ds_addr);
		}

		bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
		    read ? BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
	}

	bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
	    ccb->ccb_offset, sizeof(struct ami_ccbmem),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	return (0);
}

void
ami_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct ami_softc *sc = link->adapter_softc;
	struct device *dev = link->device_softc;
	struct ami_ccb *ccb;
	struct ami_iocmd *cmd;
	struct scsi_inquiry_data inq;
	struct scsi_sense_data sd;
	struct scsi_read_cap_data rcd;
	u_int8_t target = link->target;
	u_int32_t blockno, blockcnt;
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	bus_dma_segment_t *sgd;
	int error;
	int i;

	AMI_DPRINTF(AMI_D_CMD, ("ami_scsi_cmd "));

	if (target >= sc->sc_nunits || !sc->sc_hdr[target].hd_present ||
	    link->lun != 0) {
		AMI_DPRINTF(AMI_D_CMD, ("no target %d ", target));
		/* XXX should be XS_SENSE and sense filled out */
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	xs->error = XS_NOERROR;

	switch (xs->cmd->opcode) {
	case READ_COMMAND:
	case READ_BIG:
	case WRITE_COMMAND:
	case WRITE_BIG:
		/* deal with io outside the switch */
		break;

	case SYNCHRONIZE_CACHE:
		ccb = xs->io;

		ccb->ccb_xs = xs;
		ccb->ccb_done = ami_done_flush;
		if (xs->timeout < 30000)
			xs->timeout = 30000;	/* at least 30sec */

		cmd = &ccb->ccb_cmd;
		cmd->acc_cmd = AMI_FLUSH;

		ami_start_xs(sc, ccb, xs);
		return;

	case TEST_UNIT_READY:
		/* save off sd? after autoconf */
		if (!cold)	/* XXX bogus */
			strlcpy(sc->sc_hdr[target].dev, dev->dv_xname,
			    sizeof(sc->sc_hdr[target].dev));
	case START_STOP:
#if 0
	case VERIFY:
#endif
	case PREVENT_ALLOW:
		AMI_DPRINTF(AMI_D_CMD, ("opc %d tgt %d ", xs->cmd->opcode,
		    target));
		xs->error = XS_NOERROR;
		scsi_done(xs);
		return;

	case REQUEST_SENSE:
		AMI_DPRINTF(AMI_D_CMD, ("REQUEST SENSE tgt %d ", target));
		bzero(&sd, sizeof(sd));
		sd.error_code = SSD_ERRCODE_CURRENT;
		sd.segment = 0;
		sd.flags = SKEY_NO_SENSE;
		*(u_int32_t*)sd.info = htole32(0);
		sd.extra_len = 0;
		ami_copy_internal_data(xs, &sd, sizeof(sd));

		xs->error = XS_NOERROR;
		scsi_done(xs);
		return;

	case INQUIRY:
		if (ISSET(((struct scsi_inquiry *)xs->cmd)->flags, SI_EVPD)) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}

		AMI_DPRINTF(AMI_D_CMD, ("INQUIRY tgt %d ", target));
		bzero(&inq, sizeof(inq));
		inq.device = T_DIRECT;
		inq.dev_qual2 = 0;
		inq.version = 2;
		inq.response_format = 2;
		inq.additional_length = 32;
		inq.flags |= SID_CmdQue;
		strlcpy(inq.vendor, "AMI    ", sizeof(inq.vendor));
		snprintf(inq.product, sizeof(inq.product),
		    "Host drive  #%02d", target);
		strlcpy(inq.revision, "   ", sizeof(inq.revision));
		ami_copy_internal_data(xs, &inq, sizeof(inq));

		xs->error = XS_NOERROR;
		scsi_done(xs);
		return;

	case READ_CAPACITY:
		AMI_DPRINTF(AMI_D_CMD, ("READ CAPACITY tgt %d ", target));
		bzero(&rcd, sizeof(rcd));
		_lto4b(sc->sc_hdr[target].hd_size - 1, rcd.addr);
		_lto4b(AMI_SECTOR_SIZE, rcd.length);
		ami_copy_internal_data(xs, &rcd, sizeof(rcd));

		xs->error = XS_NOERROR;
		scsi_done(xs);
		return;

	default:
		AMI_DPRINTF(AMI_D_CMD, ("unsupported scsi command %#x tgt %d ",
		    xs->cmd->opcode, target));

		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	/* A read or write operation. */
	if (xs->cmdlen == 6) {
		rw = (struct scsi_rw *)xs->cmd;
		blockno = _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);
		blockcnt = rw->length ? rw->length : 0x100;
	} else {
		rwb = (struct scsi_rw_big *)xs->cmd;
		blockno = _4btol(rwb->addr);
		blockcnt = _2btol(rwb->length);
	}

	if (blockno >= sc->sc_hdr[target].hd_size ||
	    blockno + blockcnt > sc->sc_hdr[target].hd_size) {
		printf("%s: out of bounds %u-%u >= %u\n", DEVNAME(sc),
		    blockno, blockcnt, sc->sc_hdr[target].hd_size);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	ccb = xs->io;

	ccb->ccb_xs = xs;
	ccb->ccb_done = ami_done_xs;

	cmd = &ccb->ccb_cmd;
	cmd->acc_cmd = (xs->flags & SCSI_DATA_IN) ? AMI_READ : AMI_WRITE;
	cmd->acc_mbox.amb_nsect = htole16(blockcnt);
	cmd->acc_mbox.amb_lba = htole32(blockno);
	cmd->acc_mbox.amb_ldn = target;

	error = bus_dmamap_load(sc->sc_dmat, ccb->ccb_dmamap,
	    xs->data, xs->datalen, NULL,
	    (xs->flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error) {
		if (error == EFBIG)
			printf("more than %d dma segs\n", AMI_MAXOFFSETS);
		else
			printf("error %d loading dma map\n", error);

		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	sgd = ccb->ccb_dmamap->dm_segs;
	if (ccb->ccb_dmamap->dm_nsegs > 1) {
		struct ami_sgent *sgl = ccb->ccb_sglist;

		cmd->acc_mbox.amb_nsge = ccb->ccb_dmamap->dm_nsegs;
		cmd->acc_mbox.amb_data = ccb->ccb_sglistpa;

		for (i = 0; i < ccb->ccb_dmamap->dm_nsegs; i++) {
			sgl[i].asg_addr = htole32(sgd[i].ds_addr);
			sgl[i].asg_len = htole32(sgd[i].ds_len);
		}
	} else {
		cmd->acc_mbox.amb_nsge = 0;
		cmd->acc_mbox.amb_data = htole32(sgd->ds_addr);
	}

	bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
	    ccb->ccb_offset, sizeof(struct ami_ccbmem),
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
	    ccb->ccb_dmamap->dm_mapsize, (xs->flags & SCSI_DATA_IN) ?
	    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);

	ami_start_xs(sc, ccb, xs);
}

int
ami_intr(void *v)
{
	struct ami_iocmd mbox;
	struct ami_softc *sc = v;
	struct ami_ccb *ccb;
	int i, rv = 0, ready;

	mtx_enter(&sc->sc_cmd_mtx);
	while (!TAILQ_EMPTY(&sc->sc_ccb_runq) && sc->sc_done(sc, &mbox)) {
		AMI_DPRINTF(AMI_D_CMD, ("got#%d ", mbox.acc_nstat));
		for (i = 0; i < mbox.acc_nstat; i++ ) {
			ready = mbox.acc_cmplidl[i] - 1;
			AMI_DPRINTF(AMI_D_CMD, ("ready=%d ", ready));

			ccb = &sc->sc_ccbs[ready];
			ccb->ccb_status = mbox.acc_status;
			ccb->ccb_state = AMI_CCB_READY;
			TAILQ_REMOVE(&ccb->ccb_sc->sc_ccb_runq, ccb, ccb_link);

			mtx_leave(&sc->sc_cmd_mtx);
			ccb->ccb_done(sc, ccb);
			mtx_enter(&sc->sc_cmd_mtx);

			rv = 1;
		}
	}
	ready = (sc->sc_drainio && TAILQ_EMPTY(&sc->sc_ccb_runq));
	mtx_leave(&sc->sc_cmd_mtx);

	if (ready)
		wakeup(sc);
	else if (rv)
		ami_runqueue(sc);

	AMI_DPRINTF(AMI_D_INTR, ("exit "));
	return (rv);
}

int
ami_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag)
{
	struct ami_softc *sc = (struct ami_softc *)link->adapter_softc;
	/* struct device *dev = (struct device *)link->device_softc; */
	/* u_int8_t target = link->target; */

	if (sc->sc_ioctl)
		return (sc->sc_ioctl(link->adapter_softc, cmd, addr));
	else
		return (ENOTTY);
}

#if NBIO > 0
int
ami_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct ami_softc *sc = (struct ami_softc *)dev;
	int error = 0;

	AMI_DPRINTF(AMI_D_IOCTL, ("%s: ioctl ", DEVNAME(sc)));

	if (sc->sc_flags & AMI_BROKEN)
		return (ENODEV); /* can't do this to broken device for now */

	switch (cmd) {
	case BIOCINQ:
		AMI_DPRINTF(AMI_D_IOCTL, ("inq "));
		error = ami_ioctl_inq(sc, (struct bioc_inq *)addr);
		break;

	case BIOCVOL:
		AMI_DPRINTF(AMI_D_IOCTL, ("vol "));
		error = ami_ioctl_vol(sc, (struct bioc_vol *)addr);
		break;

	case BIOCDISK:
		AMI_DPRINTF(AMI_D_IOCTL, ("disk "));
		error = ami_ioctl_disk(sc, (struct bioc_disk *)addr);
		break;

	case BIOCALARM:
		AMI_DPRINTF(AMI_D_IOCTL, ("alarm "));
		error = ami_ioctl_alarm(sc, (struct bioc_alarm *)addr);
		break;

	case BIOCSETSTATE:
		AMI_DPRINTF(AMI_D_IOCTL, ("setstate "));
		error = ami_ioctl_setstate(sc, (struct bioc_setstate *)addr);
		break;

	default:
		AMI_DPRINTF(AMI_D_IOCTL, (" invalid ioctl\n"));
		error = EINVAL;
	}

	return (error);
}

int
ami_drv_pt(struct ami_softc *sc, u_int8_t ch, u_int8_t tg, u_int8_t *cmd,
    int clen, int blen, void *buf)
{
	struct ami_ccb *ccb;
	struct ami_passthrough *pt;
	int error = 0;

	rw_enter_write(&sc->sc_lock);

	ccb = scsi_io_get(&sc->sc_iopool, 0);
	if (ccb == NULL) {
		error = ENOMEM;
		goto err;
	}

	ccb->ccb_done = ami_done_ioctl;

	ccb->ccb_cmd.acc_cmd = AMI_PASSTHRU;
	ccb->ccb_cmd.acc_passthru.apt_data = ccb->ccb_ptpa;

	pt = ccb->ccb_pt;
	memset(pt, 0, sizeof *pt);
	pt->apt_channel = ch;
	pt->apt_target = tg;
	pt->apt_ncdb = clen;
	pt->apt_nsense = sizeof(struct scsi_sense_data);
	pt->apt_datalen = blen;
	pt->apt_data = 0;

	bcopy(cmd, pt->apt_cdb, clen);

	if (ami_load_ptmem(sc, ccb, buf, blen, 1, 0) != 0) {
		error = ENOMEM;
		goto ptmemerr;
	}

	ami_start(sc, ccb);

	while (ccb->ccb_state != AMI_CCB_READY)
		tsleep(ccb, PRIBIO, "ami_drv_pt", 0);

	bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
	    ccb->ccb_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
	bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
	    ccb->ccb_offset, sizeof(struct ami_ccbmem),
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
	bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);

	if (ccb->ccb_flags & AMI_CCB_F_ERR)
		error = EIO;
	else if (pt->apt_scsistat != 0x00)
		error = EIO;

ptmemerr:
	scsi_io_put(&sc->sc_iopool, ccb);

err:
	rw_exit_write(&sc->sc_lock);
	return (error);
}

int
ami_drv_inq(struct ami_softc *sc, u_int8_t ch, u_int8_t tg, u_int8_t page,
    void *inqbuf)
{
	struct scsi_inquiry_data *inq = inqbuf;
	u_int8_t cdb[6];
	int error = 0;

	bzero(&cdb, sizeof cdb);

	cdb[0] = INQUIRY;
	cdb[1] = 0;
	cdb[2] = 0;
	cdb[3] = 0;
	cdb[4] = sizeof(struct scsi_inquiry_data);
	cdb[5] = 0;
	if (page != 0) {
		cdb[1] = SI_EVPD;
		cdb[2] = page;
	}

	error = ami_drv_pt(sc, ch, tg, cdb, 6, sizeof *inq, inqbuf);
	if (error)
		return (error);

	if ((inq->device & SID_TYPE) != T_DIRECT)
		error = EINVAL;

	return (error);
}

int
ami_drv_readcap(struct ami_softc *sc, u_int8_t ch, u_int8_t tg, daddr_t *sz)
{
	struct scsi_read_cap_data *rcd = NULL;
	struct scsi_read_cap_data_16 *rcd16 = NULL;
	u_int8_t cdb[16];
	u_int32_t blksz;
	daddr_t noblk;
	int error = 0;

	bzero(&cdb, sizeof cdb);
	cdb[0] = READ_CAPACITY;
	rcd = dma_alloc(sizeof(*rcd), PR_WAITOK);

	error = ami_drv_pt(sc, ch, tg, cdb, 10, sizeof(*rcd), rcd);
	if (error)
		goto fail;

	noblk = _4btol(rcd->addr);
	if (noblk == 0xffffffffllu) {
		/* huge disk */
		bzero(&cdb, sizeof cdb);
		cdb[0] = READ_CAPACITY_16;
		rcd16 = dma_alloc(sizeof(*rcd16), PR_WAITOK);

		error = ami_drv_pt(sc, ch, tg, cdb, 16, sizeof(*rcd16), rcd16);
		if (error)
			goto fail;

		noblk = _8btol(rcd16->addr);
		blksz = _4btol(rcd16->length);
	} else
		blksz = _4btol(rcd->length);

	if (blksz == 0)
		blksz = 512;
	*sz = noblk * blksz;

fail:
	if (rcd16)
		dma_free(rcd16, sizeof(*rcd16));
	dma_free(rcd, sizeof(*rcd));
	return (error);
}

int
ami_mgmt(struct ami_softc *sc, u_int8_t opcode, u_int8_t par1, u_int8_t par2,
    u_int8_t par3, size_t size, void *buffer)
{
	struct ami_ccb *ccb;
	struct ami_iocmd *cmd;
	struct ami_mem *am = NULL;
	char *idata = NULL;
	int error = 0;

	rw_enter_write(&sc->sc_lock);

	if (opcode != AMI_CHSTATE) {
		ccb = scsi_io_get(&sc->sc_iopool, 0);
		if (ccb == NULL) {
			error = ENOMEM;
			goto err;
		}
		ccb->ccb_done = ami_done_ioctl;
	} else
		ccb = sc->sc_mgmtccb;

	if (size) {
		if ((am = ami_allocmem(sc, size)) == NULL) {
			error = ENOMEM;
			goto memerr;
		}
		idata = AMIMEM_KVA(am);
	}

	cmd = &ccb->ccb_cmd;
	cmd->acc_cmd = opcode;

	/*
	 * some commands require data to be written to idata before sending
	 * command to fw
	 */
	switch (opcode) {
	case AMI_SPEAKER:
		*idata = par1;
		break;
	default:
		cmd->acc_io.aio_channel = par1;
		cmd->acc_io.aio_param = par2;
		cmd->acc_io.aio_pad[0] = par3;
		break;
	};

	cmd->acc_io.aio_data = am ? htole32(AMIMEM_DVA(am)) : 0;

	if (opcode != AMI_CHSTATE) {
		ami_start(sc, ccb);
		mtx_enter(&sc->sc_cmd_mtx);
		while (ccb->ccb_state != AMI_CCB_READY)
			msleep(ccb, &sc->sc_cmd_mtx, PRIBIO,"ami_mgmt", 0);
		mtx_leave(&sc->sc_cmd_mtx);
	} else {
		/* change state must be run with id 0xfe and MUST be polled */
		mtx_enter(&sc->sc_cmd_mtx);
		sc->sc_drainio = 1;
		while (!TAILQ_EMPTY(&sc->sc_ccb_runq)) {
			if (msleep(sc, &sc->sc_cmd_mtx, PRIBIO,
			    "amimgmt", hz * 60) == EWOULDBLOCK) {
				printf("%s: drain io timeout\n", DEVNAME(sc));
				ccb->ccb_flags |= AMI_CCB_F_ERR;
				goto restartio;
			}
		}

		error = sc->sc_poll(sc, &ccb->ccb_cmd);
		if (error == -1)
			ccb->ccb_flags |= AMI_CCB_F_ERR;

restartio:
		/* restart io */
		sc->sc_drainio = 0;
		mtx_leave(&sc->sc_cmd_mtx);
		ami_runqueue(sc);
	}

	if (ccb->ccb_flags & AMI_CCB_F_ERR)
		error = EIO;
	else if (buffer && size)
		memcpy(buffer, idata, size);

	if (am)
		ami_freemem(sc, am);
memerr:
	if (opcode != AMI_CHSTATE) {
		scsi_io_put(&sc->sc_iopool, ccb);
	} else {
		ccb->ccb_flags = 0;
		ccb->ccb_state = AMI_CCB_FREE;
	}

err:
	rw_exit_write(&sc->sc_lock);
	return (error);
}

int
ami_ioctl_inq(struct ami_softc *sc, struct bioc_inq *bi)
{
	struct ami_big_diskarray *p; /* struct too large for stack */
	struct scsi_inquiry_data *inqbuf;
	struct ami_fc_einquiry einq;
	int ch, tg;
	int i, s, t, off;
	int error = 0, changes = 0;

	if ((error = ami_mgmt(sc, AMI_FCOP, AMI_FC_EINQ3,
	    AMI_FC_EINQ3_SOLICITED_FULL, 0, sizeof einq, &einq)))
		return (EINVAL);

	inqbuf = dma_alloc(sizeof(*inqbuf), PR_WAITOK);

	if (einq.ain_drvinscnt == sc->sc_drvinscnt) {
		/* poke existing known drives to make sure they aren't gone */
		for(i = 0; i < sc->sc_channels * 16; i++) {
			if (sc->sc_plist[i] == 0)
				continue;

			ch = (i & 0xf0) >> 4;
			tg = i & 0x0f;
			if (ami_drv_inq(sc, ch, tg, 0, inqbuf)) {
				/* drive is gone, force rescan */
				changes = 1;
				break;
			}
		}
		if (changes == 0) {
			bcopy(&sc->sc_bi, bi, sizeof *bi);
			goto done;
		}
	}

	sc->sc_drvinscnt = einq.ain_drvinscnt;

	p = malloc(sizeof *p, M_DEVBUF, M_NOWAIT);
	if (!p) {
		error = ENOMEM;
		goto done;
	}

	if ((error = ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, 0, sizeof *p,
	    p))) {
		error = EINVAL;
		goto bail;
	}

	bzero(sc->sc_plist, sizeof sc->sc_plist);

	bi->bi_novol = p->ada_nld;
	bi->bi_nodisk = 0;
	strlcpy(bi->bi_dev, DEVNAME(sc), sizeof(bi->bi_dev));

	/* count used disks, including failed ones */
	for (i = 0; i < p->ada_nld; i++)
		for (s = 0; s < p->ald[i].adl_spandepth; s++)
			for (t = 0; t < p->ald[i].adl_nstripes; t++) {
				off = p->ald[i].asp[s].adv[t].add_channel *
				    AMI_MAX_TARGET +
				    p->ald[i].asp[s].adv[t].add_target;

				/* account for multi raid vol on same disk */
				if (!sc->sc_plist[off]) {
					sc->sc_plist[off] = 1;
					bi->bi_nodisk++;
				}
			}

	/* count unsued disks */
	for(i = 0; i < sc->sc_channels * 16; i++) {
	    	if (sc->sc_plist[i])
			continue; /* skip claimed drives */

		/*
		 * hack to invalidate device type, needed for initiator id
		 * on an unconnected channel.
		 * XXX find out if we can determine this differently
		 */
		memset(inqbuf, 0xff, sizeof(*inqbuf));

		ch = (i & 0xf0) >> 4;
		tg = i & 0x0f;
		if (!ami_drv_inq(sc, ch, tg, 0, inqbuf)) {
			if ((inqbuf->device & SID_TYPE) != T_DIRECT)
				continue;
			bi->bi_novol++;
			bi->bi_nodisk++;
			sc->sc_plist[i] = 2;
		} else
			sc->sc_plist[i] = 0;
	}

	bcopy(bi, &sc->sc_bi, sizeof sc->sc_bi);
	error = 0;
bail:
	free(p, M_DEVBUF, sizeof *p);
done:
	dma_free(inqbuf, sizeof(*inqbuf));
	return (error);
}

int
ami_vol(struct ami_softc *sc, struct bioc_vol *bv, struct ami_big_diskarray *p)
{
	int i, ld = p->ada_nld, error = EINVAL;

	for(i = 0; i < sc->sc_channels * 16; i++) {
	    	/* skip claimed/unused drives */
	    	if (sc->sc_plist[i] != 2)
			continue;

		/* are we it? */
		if (ld != bv->bv_volid) {
			ld++;
			continue;
		}

		bv->bv_status = BIOC_SVONLINE;
		bv->bv_size = (uint64_t)p->apd[i].adp_size *
		    (uint64_t)512;
		bv->bv_nodisk = 1;
		strlcpy(bv->bv_dev,
		    sc->sc_hdr[bv->bv_volid].dev,
		    sizeof(bv->bv_dev));

		if (p->apd[i].adp_ostatus == AMI_PD_HOTSPARE
		    && p->apd[i].adp_type == 0)
			bv->bv_level = -1;
		else
			bv->bv_level = -2;

		error = 0;
		goto bail;
	}

bail:
	return (error);
}

int
ami_disk(struct ami_softc *sc, struct bioc_disk *bd,
    struct ami_big_diskarray *p)
{
	char vend[8+16+4+1], *vendp;
	char ser[32 + 1];
	struct scsi_inquiry_data *inqbuf;
	struct scsi_vpd_serial *vpdbuf;
	int i, ld = p->ada_nld, error = EINVAL;
	u_int8_t ch, tg;
	daddr_t sz = 0;

	inqbuf = dma_alloc(sizeof(*inqbuf), PR_WAITOK);
	vpdbuf = dma_alloc(sizeof(*vpdbuf), PR_WAITOK);

	for(i = 0; i < sc->sc_channels * 16; i++) {
	    	/* skip claimed/unused drives */
	    	if (sc->sc_plist[i] != 2)
			continue;

		/* are we it? */
		if (ld != bd->bd_volid) {
			ld++;
			continue;
		}

		ch = (i & 0xf0) >> 4;
		tg = i & 0x0f;
		if (ami_drv_inq(sc, ch, tg, 0, inqbuf)) 
			goto bail;
		
		vendp = inqbuf->vendor;
		bcopy(vendp, vend, sizeof vend - 1);

		vend[sizeof vend - 1] = '\0';
		strlcpy(bd->bd_vendor, vend, sizeof(bd->bd_vendor));

		if (!ami_drv_inq(sc, ch, tg, 0x80, vpdbuf)) {
			bcopy(vpdbuf->serial, ser, sizeof ser - 1);
			ser[sizeof ser - 1] = '\0';
			if (_2btol(vpdbuf->hdr.page_length) < sizeof ser)
				ser[_2btol(vpdbuf->hdr.page_length)] = '\0';
			strlcpy(bd->bd_serial, ser, sizeof(bd->bd_serial));
		}

		error = ami_drv_readcap(sc, ch, tg, &sz);
		if (error)
			goto bail;

		bd->bd_size = sz;
		bd->bd_channel = ch;
		bd->bd_target = tg;

		strlcpy(bd->bd_procdev, sc->sc_rawsoftcs[ch].sc_procdev,
		    sizeof(bd->bd_procdev));

		if (p->apd[i].adp_ostatus == AMI_PD_HOTSPARE)
			bd->bd_status = BIOC_SDHOTSPARE;
		else
			bd->bd_status = BIOC_SDUNUSED;

#ifdef AMI_DEBUG
		if (p->apd[i].adp_type != 0)
			printf("invalid disk type: %d %d %x inquiry type: %x\n",
			    ch, tg, p->apd[i].adp_type, inqbuf->device);
#endif /* AMI_DEBUG */

		error = 0;
		goto bail;
	}

bail:
	dma_free(inqbuf, sizeof(*inqbuf));
	dma_free(vpdbuf, sizeof(*vpdbuf));
	return (error);
}

int
ami_ioctl_vol(struct ami_softc *sc, struct bioc_vol *bv)
{
	struct ami_big_diskarray *p; /* struct too large for stack */
	int i, s, t, off;
	int error = 0;
	struct ami_progress perc;
	u_int8_t bgi[5]; /* 40 LD, 1 bit per LD if BGI is active */

	p = malloc(sizeof *p, M_DEVBUF, M_NOWAIT);
	if (!p)
		return (ENOMEM);

	if ((error = ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, 0, sizeof *p, p)))
		goto bail;

	if (bv->bv_volid >= p->ada_nld) {
		error = ami_vol(sc, bv, p);
		goto bail;
	}

	i = bv->bv_volid;

	switch (p->ald[i].adl_status) {
	case AMI_RDRV_OFFLINE:
		bv->bv_status = BIOC_SVOFFLINE;
		break;

	case AMI_RDRV_DEGRADED:
		bv->bv_status = BIOC_SVDEGRADED;
		break;

	case AMI_RDRV_OPTIMAL:
		bv->bv_status = BIOC_SVONLINE;
		bv->bv_percent = -1;

		/* get BGI progress here and over-ride status if so */
		memset(bgi, 0, sizeof bgi);
		if (ami_mgmt(sc, AMI_MISC, AMI_GET_BGI, 0, 0, sizeof bgi, &bgi))
			break;

		if ((bgi[i / 8] & (1 << i % 8)) == 0)
			break;

		if (!ami_mgmt(sc, AMI_GCHECKPROGR, i, 0, 0, sizeof perc, &perc))
		    	if (perc.apr_progress < 100) {
				bv->bv_status = BIOC_SVSCRUB;
				bv->bv_percent = perc.apr_progress >= 100 ? -1 :
				    perc.apr_progress;
			}
		break;

	default:
		bv->bv_status = BIOC_SVINVALID;
	}

	/* over-ride status if a pd is in rebuild status for this ld */
	for (s = 0; s < p->ald[i].adl_spandepth; s++)
		for (t = 0; t < p->ald[i].adl_nstripes; t++) {
			off = p->ald[i].asp[s].adv[t].add_channel *
			    AMI_MAX_TARGET +
			    p->ald[i].asp[s].adv[t].add_target;

			if (p->apd[off].adp_ostatus != AMI_PD_RBLD)
				continue;

			/* get rebuild progress from pd 0 */
			bv->bv_status = BIOC_SVREBUILD;
			if (ami_mgmt(sc, AMI_GRBLDPROGR,
			    p->ald[i].asp[s].adv[t].add_channel,
			    p->ald[i].asp[s].adv[t].add_target, 0,
			    sizeof perc, &perc))
				bv->bv_percent = -1;
			else
				bv->bv_percent = perc.apr_progress >= 100 ? -1 :
				    perc.apr_progress;
			break;
		}

	bv->bv_size = 0;
	bv->bv_level = p->ald[i].adl_raidlvl;
	bv->bv_nodisk = 0;

	for (s = 0; s < p->ald[i].adl_spandepth; s++) {
		for (t = 0; t < p->ald[i].adl_nstripes; t++)
			bv->bv_nodisk++;

		switch (bv->bv_level) {
		case 0:
			bv->bv_size += p->ald[i].asp[s].ads_length *
			    p->ald[i].adl_nstripes;
			break;

		case 1:
			bv->bv_size += p->ald[i].asp[s].ads_length;
			break;

		case 5:
			bv->bv_size += p->ald[i].asp[s].ads_length *
			    (p->ald[i].adl_nstripes - 1);
			break;
		}
	}

	if (p->ald[i].adl_spandepth > 1)
		bv->bv_level *= 10;

	bv->bv_size *= (uint64_t)512;

	strlcpy(bv->bv_dev, sc->sc_hdr[i].dev, sizeof(bv->bv_dev));
	
bail:
	free(p, M_DEVBUF, sizeof *p);

	return (error);
}

int
ami_ioctl_disk(struct ami_softc *sc, struct bioc_disk *bd)
{
	struct scsi_inquiry_data *inqbuf;
	struct scsi_vpd_serial *vpdbuf;
	struct ami_big_diskarray *p; /* struct too large for stack */
	int i, s, t, d;
	int off;
	int error = EINVAL;
	u_int16_t ch, tg;
	char vend[8+16+4+1], *vendp;
	char ser[32 + 1];

	inqbuf = dma_alloc(sizeof(*inqbuf), PR_WAITOK);
	vpdbuf = dma_alloc(sizeof(*inqbuf), PR_WAITOK);
	p = malloc(sizeof *p, M_DEVBUF, M_WAITOK);

	if ((error = ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, 0, sizeof *p, p)))
		goto bail;

	if (bd->bd_volid >= p->ada_nld) {
		error = ami_disk(sc, bd, p);
		goto bail;
	}

	i = bd->bd_volid;
	for (s = 0, d = 0; s < p->ald[i].adl_spandepth; s++)
		for (t = 0; t < p->ald[i].adl_nstripes; t++) {
			if (d != bd->bd_diskid) {
				d++;
				continue;
			}

			off = p->ald[i].asp[s].adv[t].add_channel *
			    AMI_MAX_TARGET +
			    p->ald[i].asp[s].adv[t].add_target;

			bd->bd_size = (uint64_t)p->apd[off].adp_size *
			    (uint64_t)512;

			switch (p->apd[off].adp_ostatus) {
			case AMI_PD_UNCNF:
				bd->bd_status = BIOC_SDUNUSED;
				break;

			case AMI_PD_ONLINE:
				bd->bd_status = BIOC_SDONLINE;
				break;

			case AMI_PD_FAILED:
				bd->bd_status = BIOC_SDFAILED;
				bd->bd_size = 0;
				break;

			case AMI_PD_RBLD:
				bd->bd_status = BIOC_SDREBUILD;
				break;

			case AMI_PD_HOTSPARE:
				bd->bd_status = BIOC_SDHOTSPARE;
				break;

			default:
				bd->bd_status = BIOC_SDINVALID;
				bd->bd_size = 0;
			}


			ch = p->ald[i].asp[s].adv[t].add_target >> 4;
			tg = p->ald[i].asp[s].adv[t].add_target & 0x0f;

			bd->bd_channel = ch;
			bd->bd_target = tg;
			strlcpy(bd->bd_procdev, sc->sc_rawsoftcs[ch].sc_procdev,
			    sizeof(bd->bd_procdev));

			/* if we are failed don't query drive */
			if (bd->bd_size == 0) {
				bzero(&bd->bd_vendor, sizeof(bd->bd_vendor));
				bzero(&bd->bd_serial, sizeof(bd->bd_serial));
				goto done;
			}

			if (!ami_drv_inq(sc, ch, tg, 0, inqbuf)) {
				vendp = inqbuf->vendor;
				bcopy(vendp, vend, sizeof vend - 1);
				vend[sizeof vend - 1] = '\0';
				strlcpy(bd->bd_vendor, vend,
				    sizeof(bd->bd_vendor));
			}

			if (!ami_drv_inq(sc, ch, tg, 0x80, vpdbuf)) {
				bcopy(vpdbuf->serial, ser, sizeof ser - 1);
				ser[sizeof ser - 1] = '\0';
				if (_2btol(vpdbuf->hdr.page_length) <
				    sizeof(ser))
					ser[_2btol(vpdbuf->hdr.page_length)] =
					    '\0';
				strlcpy(bd->bd_serial, ser,
				    sizeof(bd->bd_serial));
			}
			goto done;
		}

done:
	error = 0;
bail:
	free(p, M_DEVBUF, sizeof *p);
	dma_free(vpdbuf, sizeof(*vpdbuf));
	dma_free(inqbuf, sizeof(*inqbuf));

	return (error);
}

int ami_ioctl_alarm(struct ami_softc *sc, struct bioc_alarm *ba)
{
	int error = 0;
	u_int8_t func, ret;

	switch(ba->ba_opcode) {
	case BIOC_SADISABLE:
		func = AMI_SPKR_OFF;
		break;

	case BIOC_SAENABLE:
		func = AMI_SPKR_ON;
		break;

	case BIOC_SASILENCE:
		func = AMI_SPKR_SHUT;
		break;

	case BIOC_GASTATUS:
		func = AMI_SPKR_GVAL;
		break;

	case BIOC_SATEST:
		func = AMI_SPKR_TEST;
		break;

	default:
		AMI_DPRINTF(AMI_D_IOCTL, ("%s: biocalarm invalid opcode %x\n",
		    DEVNAME(sc), ba->ba_opcode));
		return (EINVAL);
	}

	if (!(error = ami_mgmt(sc, AMI_SPEAKER, func, 0, 0, sizeof ret,
	    &ret))) {
		if (ba->ba_opcode == BIOC_GASTATUS)
			ba->ba_status = ret;
		else
			ba->ba_status = 0;
	}

	return (error);
}

int
ami_ioctl_setstate(struct ami_softc *sc, struct bioc_setstate *bs)
{
	struct scsi_inquiry_data *inqbuf;
	int func, error = 0;

	inqbuf = dma_alloc(sizeof(*inqbuf), PR_WAITOK);

	switch (bs->bs_status) {
	case BIOC_SSONLINE:
		func = AMI_STATE_ON;
		break;

	case BIOC_SSOFFLINE:
		func = AMI_STATE_FAIL;
		break;

	case BIOC_SSHOTSPARE:
		if (ami_drv_inq(sc, bs->bs_channel, bs->bs_target, 0,
		    inqbuf)) {
			error = EINVAL;
			goto done;
		}

		func = AMI_STATE_SPARE;
		break;

	default:
		AMI_DPRINTF(AMI_D_IOCTL, ("%s: biocsetstate invalid opcode %x\n"
		    , DEVNAME(sc), bs->bs_status));
		error = EINVAL;
		goto done;
	}

	if ((error = ami_mgmt(sc, AMI_CHSTATE, bs->bs_channel, bs->bs_target,
	    func, 0, NULL)))
		goto done;

done:
	dma_free(inqbuf, sizeof(*inqbuf));
	return (error);
}

#ifndef SMALL_KERNEL
int
ami_create_sensors(struct ami_softc *sc)
{
	struct device *dev;
	struct scsibus_softc *ssc = NULL;
	struct scsi_link *link;
	int i;

	TAILQ_FOREACH(dev, &alldevs, dv_list) {
		if (dev->dv_parent != &sc->sc_dev)
			continue;

		/* check if this is the scsibus for the logical disks */
		ssc = (struct scsibus_softc *)dev;
		if (ssc->adapter_link == &sc->sc_link)
			break;
	}

	if (ssc == NULL)
		return (1);

	sc->sc_sensors = mallocarray(sc->sc_nunits, sizeof(struct ksensor),
	    M_DEVBUF, M_WAITOK|M_CANFAIL|M_ZERO);
	if (sc->sc_sensors == NULL)
		return (1);

	strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensordev.xname));

	for (i = 0; i < sc->sc_nunits; i++) {
		link = scsi_get_link(ssc, i, 0);
		if (link == NULL)
			goto bad;

		dev = link->device_softc;

		sc->sc_sensors[i].type = SENSOR_DRIVE;
		sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;

		strlcpy(sc->sc_sensors[i].desc, dev->dv_xname,
		    sizeof(sc->sc_sensors[i].desc));

		sensor_attach(&sc->sc_sensordev, &sc->sc_sensors[i]);
	}

	sc->sc_bd = malloc(sizeof(*sc->sc_bd), M_DEVBUF, M_WAITOK|M_CANFAIL);
	if (sc->sc_bd == NULL)
		goto bad;

	if (sensor_task_register(sc, ami_refresh_sensors, 10) == NULL)
		goto freebd;

	sensordev_install(&sc->sc_sensordev);

	return (0);

freebd:
	free(sc->sc_bd, M_DEVBUF, sizeof(*sc->sc_bd));
bad:
	free(sc->sc_sensors, M_DEVBUF, sc->sc_nunits * sizeof(struct ksensor));

	return (1);
}

void
ami_refresh_sensors(void *arg)
{
	struct ami_softc *sc = arg;
	int i;

	if (ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, 0, sizeof(*sc->sc_bd),
	    sc->sc_bd)) {
		for (i = 0; i < sc->sc_nunits; i++) {
			sc->sc_sensors[i].value = 0; /* unknown */
			sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;
		}
		return;
	}

	for (i = 0; i < sc->sc_nunits; i++) {
		switch (sc->sc_bd->ald[i].adl_status) {
		case AMI_RDRV_OFFLINE:
			sc->sc_sensors[i].value = SENSOR_DRIVE_FAIL;
			sc->sc_sensors[i].status = SENSOR_S_CRIT;
			break;

		case AMI_RDRV_DEGRADED:
			sc->sc_sensors[i].value = SENSOR_DRIVE_PFAIL;
			sc->sc_sensors[i].status = SENSOR_S_WARN;
			break;

		case AMI_RDRV_OPTIMAL:
			sc->sc_sensors[i].value = SENSOR_DRIVE_ONLINE;
			sc->sc_sensors[i].status = SENSOR_S_OK;
			break;

		default:
			sc->sc_sensors[i].value = 0; /* unknown */
			sc->sc_sensors[i].status = SENSOR_S_UNKNOWN;
		}
	}
}
#endif /* SMALL_KERNEL */
#endif /* NBIO > 0 */

#ifdef AMI_DEBUG
void
ami_print_mbox(struct ami_iocmd *mbox)
{
	int i;

	printf("acc_cmd: %d  aac_id: %d  acc_busy: %d  acc_nstat: %d  ",
	    mbox->acc_cmd, mbox->acc_id, mbox->acc_busy, mbox->acc_nstat);
	printf("acc_status: %d  acc_poll: %d  acc_ack: %d\n",
	    mbox->acc_status, mbox->acc_poll, mbox->acc_ack);

	printf("acc_cmplidl: ");
	for (i = 0; i < AMI_MAXSTATACK; i++) {
		printf("[%d] = %d  ", i, mbox->acc_cmplidl[i]);
	}

	printf("\n");
}
#endif /* AMI_DEBUG */
@


1.232
log
@change some types in bio from u_quad_t to uint64_t, and fix casts in
drivers that fill that field in too.

quad types are going away.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.231 2015/09/09 18:23:55 deraadt Exp $	*/
d2296 1
a2296 1
	free(p, M_DEVBUF, 0);
@


1.231
log
@sizes for free(); ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.230 2014/11/05 01:02:10 daniel Exp $	*/
d1974 2
a1975 2
		bv->bv_size = (u_quad_t)p->apd[i].adp_size *
		    (u_quad_t)512;
d2179 1
a2179 1
	bv->bv_size *= (u_quad_t)512;
d2226 2
a2227 2
			bd->bd_size = (u_quad_t)p->apd[off].adp_size *
			    (u_quad_t)512;
@


1.230
log
@Functions that say they return void should not try to return something.

ok deraadt@@
"Even though I admire the chutzpah of return(void), I agree". ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.229 2014/09/14 14:17:24 jsg Exp $	*/
d264 1
a264 1
	free(am, M_DEVBUF, 0);
d276 1
a276 1
	free(am, M_DEVBUF, 0);
d1951 1
a1951 1
	free(p, M_DEVBUF, 0);
d2184 1
a2184 1
	free(p, M_DEVBUF, 0);
d2447 1
a2447 1
	free(sc->sc_bd, M_DEVBUF, 0);
d2449 1
a2449 1
	free(sc->sc_sensors, M_DEVBUF, 0);
@


1.229
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.228 2014/07/13 23:10:23 deraadt Exp $	*/
d1367 2
a1368 1
		return (ami_start_xs(sc, ccb, xs));
@


1.228
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.227 2014/07/12 18:48:17 tedu Exp $	*/
a59 1
#include <sys/proc.h>
@


1.227
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.226 2013/10/19 13:03:43 dlg Exp $	*/
d302 1
a302 1
	sc->sc_ccbs = malloc(sizeof(struct ami_ccb) * nccbs,
d569 1
a569 1
	rsc = malloc(sizeof(struct ami_rawsoftc) * sc->sc_channels,
d2411 1
a2411 1
	sc->sc_sensors = malloc(sizeof(struct ksensor) * sc->sc_nunits,
@


1.226
log
@we dont fake VPD INQUIRY pages, so fail on requests for them.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.225 2013/06/11 16:42:14 deraadt Exp $	*/
d265 1
a265 1
	free(am, M_DEVBUF);
d277 1
a277 1
	free(am, M_DEVBUF);
d366 1
a366 1
	free(sc->sc_ccbs, M_DEVBUF);
d1951 1
a1951 1
	free(p, M_DEVBUF);
d2184 1
a2184 1
	free(p, M_DEVBUF);
d2296 1
a2296 1
	free(p, M_DEVBUF);
d2447 1
a2447 1
	free(sc->sc_bd, M_DEVBUF);
d2449 1
a2449 1
	free(sc->sc_sensors, M_DEVBUF);
@


1.225
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.224 2013/05/07 01:54:06 jsg Exp $	*/
d1401 6
@


1.224
log
@fix a double free in an error path
reminded of this diff by a report from Arto Jonsson
ok krw@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.223 2012/01/09 18:50:44 deraadt Exp $	*/
d150 1
a150 1
		    daddr64_t *);
d1703 1
a1703 1
ami_drv_readcap(struct ami_softc *sc, u_int8_t ch, u_int8_t tg, daddr64_t *sz)
d1709 1
a1709 1
	daddr64_t noblk;
d1999 1
a1999 1
	daddr64_t sz = 0;
@


1.223
log
@repair errors paths for dma_alloc; spotted by dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.222 2012/01/09 15:43:15 deraadt Exp $	*/
a498 2
	ami_freemem(sc, am);

d503 2
@


1.222
log
@another set of missing dma_alloc's for talking to a device.  hit by
henning.
ok krw dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.221 2011/10/05 06:41:30 dlg Exp $	*/
d1705 2
a1706 2
	struct scsi_read_cap_data *rcd;
	struct scsi_read_cap_data_16 *rcd16;
d1718 1
a1718 1
		return (error);
d1729 1
a1729 1
			return (error);
a1732 2

		dma_free(rcd16, sizeof(*rcd16));
a1735 2
	dma_free(rcd, sizeof(*rcd));

d1740 4
@


1.221
log
@ami_drv_inq bus_dmamap_loads the inquiry buffer, so that buffer has to be
under 4g now. this moves the inqbufs off the stack to dma_alloc/dma_free.

reported by and fix tested by henning@@
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.220 2011/07/17 22:46:48 matthew Exp $	*/
d1705 2
a1706 2
	struct scsi_read_cap_data rcd;
	struct scsi_read_cap_data_16 rcd16;
a1711 1
	bzero(&rcd, sizeof rcd);
d1714 1
d1716 1
a1716 1
	error = ami_drv_pt(sc, ch, tg, cdb, 10, sizeof rcd, &rcd);
d1720 1
a1720 1
	noblk = _4btol(rcd.addr);
a1722 1
		bzero(&rcd16, sizeof rcd16);
d1725 1
d1727 1
a1727 1
		error = ami_drv_pt(sc, ch, tg, cdb, 16, sizeof rcd16, &rcd16);
d1731 4
a1734 2
		noblk = _8btol(rcd16.addr);
		blksz = _4btol(rcd16.length);
d1736 3
a1738 1
		blksz = _4btol(rcd.length);
@


1.220
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.219 2011/07/08 22:09:27 matthew Exp $	*/
d62 1
d1847 1
a1847 1
	struct scsi_inquiry_data inqbuf;
d1857 2
d1867 1
a1867 1
			if (ami_drv_inq(sc, ch, tg, 0, &inqbuf)) {
d1875 1
a1875 1
			return (0);
d1882 4
a1885 2
	if (!p)
		return (ENOMEM);
d1924 1
a1924 1
		memset(&inqbuf, 0xff, sizeof inqbuf);
d1928 2
a1929 2
		if (!ami_drv_inq(sc, ch, tg, 0, &inqbuf)) {
			if ((inqbuf.device & SID_TYPE) != T_DIRECT)
d1942 2
d1991 2
a1992 2
	struct scsi_inquiry_data inqbuf;
	struct scsi_vpd_serial vpdbuf;
d1997 3
d2013 1
a2013 1
		if (ami_drv_inq(sc, ch, tg, 0, &inqbuf)) 
d2016 1
a2016 1
		vendp = inqbuf.vendor;
d2022 2
a2023 2
		if (!ami_drv_inq(sc, ch, tg, 0x80, &vpdbuf)) {
			bcopy(vpdbuf.serial, ser, sizeof ser - 1);
d2025 2
a2026 2
			if (_2btol(vpdbuf.hdr.page_length) < sizeof ser)
				ser[_2btol(vpdbuf.hdr.page_length)] = '\0';
d2049 1
a2049 1
			    ch, tg, p->apd[i].adp_type, inqbuf.device);
d2057 2
d2182 2
a2183 2
	struct scsi_inquiry_data inqbuf;
	struct scsi_vpd_serial vpdbuf;
d2192 3
a2194 3
	p = malloc(sizeof *p, M_DEVBUF, M_NOWAIT);
	if (!p)
		return (ENOMEM);
d2262 2
a2263 2
			if (!ami_drv_inq(sc, ch, tg, 0, &inqbuf)) {
				vendp = inqbuf.vendor;
d2270 2
a2271 2
			if (!ami_drv_inq(sc, ch, tg, 0x80, &vpdbuf)) {
				bcopy(vpdbuf.serial, ser, sizeof ser - 1);
d2273 3
a2275 2
				if (_2btol(vpdbuf.hdr.page_length) < sizeof ser)
					ser[_2btol(vpdbuf.hdr.page_length)] =
d2287 2
d2339 4
a2342 2
	struct scsi_inquiry_data inqbuf;
	int func, error;
d2355 4
a2358 2
		    &inqbuf))
			return (EINVAL);
d2366 2
a2367 1
		return (EINVAL);
d2372 1
a2372 1
		return (error);
d2374 3
a2376 1
	return (0);
@


1.220.2.1
log
@MFC, by dlg, ok deraadt
> ami_drv_inq bus_dmamap_loads the inquiry buffer, so that buffer has to be
> under 4g now. this moves the inqbufs off the stack to dma_alloc/dma_free.
>
> reported by and fix tested by henning@@
> ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.220 2011/07/17 22:46:48 matthew Exp $	*/
a61 1
#include <sys/pool.h>
d1846 1
a1846 1
	struct scsi_inquiry_data *inqbuf;
a1855 2
	inqbuf = dma_alloc(sizeof(*inqbuf), PR_WAITOK);

d1864 1
a1864 1
			if (ami_drv_inq(sc, ch, tg, 0, inqbuf)) {
d1872 1
a1872 1
			goto done;
d1879 2
a1880 4
	if (!p) {
		error = ENOMEM;
		goto done;
	}
d1919 1
a1919 1
		memset(inqbuf, 0xff, sizeof(*inqbuf));
d1923 2
a1924 2
		if (!ami_drv_inq(sc, ch, tg, 0, inqbuf)) {
			if ((inqbuf->device & SID_TYPE) != T_DIRECT)
a1936 2
done:
	dma_free(inqbuf, sizeof(*inqbuf));
d1984 2
a1985 2
	struct scsi_inquiry_data *inqbuf;
	struct scsi_vpd_serial *vpdbuf;
a1989 3
	inqbuf = dma_alloc(sizeof(*inqbuf), PR_WAITOK);
	vpdbuf = dma_alloc(sizeof(*vpdbuf), PR_WAITOK);

d2003 1
a2003 1
		if (ami_drv_inq(sc, ch, tg, 0, inqbuf)) 
d2006 1
a2006 1
		vendp = inqbuf->vendor;
d2012 2
a2013 2
		if (!ami_drv_inq(sc, ch, tg, 0x80, vpdbuf)) {
			bcopy(vpdbuf->serial, ser, sizeof ser - 1);
d2015 2
a2016 2
			if (_2btol(vpdbuf->hdr.page_length) < sizeof ser)
				ser[_2btol(vpdbuf->hdr.page_length)] = '\0';
d2039 1
a2039 1
			    ch, tg, p->apd[i].adp_type, inqbuf->device);
a2046 2
	dma_free(inqbuf, sizeof(*inqbuf));
	dma_free(vpdbuf, sizeof(*vpdbuf));
d2170 2
a2171 2
	struct scsi_inquiry_data *inqbuf;
	struct scsi_vpd_serial *vpdbuf;
d2180 3
a2182 3
	inqbuf = dma_alloc(sizeof(*inqbuf), PR_WAITOK);
	vpdbuf = dma_alloc(sizeof(*inqbuf), PR_WAITOK);
	p = malloc(sizeof *p, M_DEVBUF, M_WAITOK);
d2250 2
a2251 2
			if (!ami_drv_inq(sc, ch, tg, 0, inqbuf)) {
				vendp = inqbuf->vendor;
d2258 2
a2259 2
			if (!ami_drv_inq(sc, ch, tg, 0x80, vpdbuf)) {
				bcopy(vpdbuf->serial, ser, sizeof ser - 1);
d2261 2
a2262 3
				if (_2btol(vpdbuf->hdr.page_length) <
				    sizeof(ser))
					ser[_2btol(vpdbuf->hdr.page_length)] =
a2273 2
	dma_free(vpdbuf, sizeof(*vpdbuf));
	dma_free(inqbuf, sizeof(*inqbuf));
d2324 2
a2325 4
	struct scsi_inquiry_data *inqbuf;
	int func, error = 0;

	inqbuf = dma_alloc(sizeof(*inqbuf), PR_WAITOK);
d2338 2
a2339 4
		    inqbuf)) {
			error = EINVAL;
			goto done;
		}
d2347 1
a2347 2
		error = EINVAL;
		goto done;
d2352 1
a2352 1
		goto done;
d2354 1
a2354 3
done:
	dma_free(inqbuf, sizeof(*inqbuf));
	return (error);
@


1.219
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.218 2011/02/22 02:30:08 dlg Exp $	*/
d523 1
a548 1
	saa.saa_targets = sc->sc_maxunits;
d590 1
a594 1
		saa.saa_targets = 16;
@


1.218
log
@ami figures out the names of the enclosure attached to it by snooping
commands on the passthru busses after the kernel becomes !cold. however,
if the enclosure doesnt have any sensors then we dont issue regular
commands to it, so ami cant see what its name is.

this moves the name fetch from the passthru io path to a walk of all the
devices on the bus just after they were attached.

problem reported and fix tested by henning@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.217 2010/10/12 00:53:32 krw Exp $	*/
a522 1
	sc->sc_link.adapter_buswidth = sc->sc_maxunits;
d548 1
a589 1
		rsc->sc_link.adapter_buswidth = 16;
d594 1
@


1.217
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.216 2010/09/24 01:32:09 dlg Exp $	*/
d578 4
d596 13
a608 1
		config_found(&sc->sc_dev, &saa, scsiprint);
a1221 1
	struct device *dev = link->device_softc;
a1224 4

	if (!cold && target == rsc->sc_proctarget)
		strlcpy(rsc->sc_procdev, dev->dv_xname,
		    sizeof(rsc->sc_procdev));
@


1.216
log
@remove useless store
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.215 2010/09/20 06:17:49 krw Exp $	*/
d1396 1
@


1.215
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.214 2010/09/02 11:54:44 dlg Exp $	*/
a1334 1
	error = 0;
@


1.214
log
@the page_length field in the vpd page header is 2 bytes, not 1.

ok krw@@ marco@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.213 2010/08/25 00:47:52 dlg Exp $	*/
d1218 1
a1218 1
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
d1378 1
a1378 1
		sd.error_code = 0x70;
@


1.213
log
@try giving all devices on ami access to all the ccbs. iopools will share
them out safely.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.212 2010/07/01 03:20:38 matthew Exp $	*/
d2004 2
a2005 2
			if (vpdbuf.hdr.page_length < sizeof ser)
				ser[vpdbuf.hdr.page_length] = '\0';
d2250 3
a2252 2
				if (vpdbuf.hdr.page_length < sizeof ser)
					ser[vpdbuf.hdr.page_length] = '\0';
@


1.212
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.211 2010/06/28 18:31:02 krw Exp $	*/
d495 1
a495 5
		if (sc->sc_nunits)
			sc->sc_link.openings =
			    sc->sc_maxcmds / sc->sc_nunits;
		else
			sc->sc_link.openings = sc->sc_maxcmds;
d580 1
a580 1
		rsc->sc_link.openings = AMI_MAXRAWCMDS;
@


1.211
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.210 2010/06/28 05:43:46 jsg Exp $	*/
d2355 1
d2380 2
a2381 1
		if (ssc->sc_link[i][0] == NULL)
d2384 1
a2384 1
		dev = ssc->sc_link[i][0]->device_softc;
@


1.210
log
@add back the initialisation of a loop condition that
was mistakenly removed in 1.208

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.209 2010/06/23 04:53:53 dlg Exp $	*/
a102 4
struct scsi_device ami_dev = {
	NULL, NULL, NULL, NULL
};

a108 4
struct scsi_device ami_raw_dev = {
	NULL, NULL, NULL, NULL
};

a523 1
	sc->sc_link.device = &ami_dev;
a583 1
		rsc->sc_link.device = &ami_raw_dev;
@


1.209
log
@cut ami over to iopools.

makes the ioctl and sensor paths more reliably now that they cant fail
due to a ccb allocation failure, and allows better sharing of resources
between multiple logical volumes and physical devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.208 2010/06/23 03:46:25 dlg Exp $	*/
d1016 1
a1016 1
	int i;
@


1.208
log
@switch ami over to using mutexes instead of splbio to protect itself. this
protects the ccb runqueues and the mailbox with a single mutex.

the biggest change as a consequence of this is a rewrite of the polled
command code. it now forces the polled command onto the chip ahead of the
pending runqueue, and simply runs the interrupt handler until the ccb
completes.

tested by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.207 2010/06/21 11:43:38 dlg Exp $	*/
d117 2
a118 2
struct ami_ccb	*ami_get_ccb(struct ami_softc *);
void		ami_put_ccb(struct ami_softc *, struct ami_ccb *);
d179 2
a180 2
struct ami_ccb *
ami_get_ccb(struct ami_softc *sc)
d182 1
d197 1
a197 1
ami_put_ccb(struct ami_softc *sc, struct ami_ccb *ccb)
d199 3
d329 2
d537 1
d601 1
a1110 1
	ami_put_ccb(sc, ccb);
a1136 1
	ami_put_ccb(sc, ccb);
a1149 1
		ami_put_ccb(sc, ccb);
a1169 1
	ami_put_ccb(sc, ccb);
d1242 1
a1242 6
	ccb = ami_get_ccb(sc);
	if (ccb == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}
a1263 1
		ami_put_ccb(sc, ccb);
d1361 1
a1361 6
		ccb = ami_get_ccb(sc);
		if (ccb == NULL) {
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			return;
		}
d1461 1
a1461 6
	ccb = ami_get_ccb(sc);
	if (ccb == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}
a1481 1
		ami_put_ccb(sc, ccb);
d1621 1
a1621 1
	ccb = ami_get_ccb(sc);
d1666 1
a1666 1
	ami_put_ccb(sc, ccb);
d1758 1
a1758 1
		ccb = ami_get_ccb(sc);
d1834 1
a1834 1
		ami_put_ccb(sc, ccb);
@


1.207
log
@protect the ccb free list with its own mutex.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.206 2010/06/15 04:11:34 dlg Exp $	*/
a116 2
void		ami_remove_runq(struct ami_ccb *);
void		ami_insert_runq(struct ami_ccb *);
a131 1
int		ami_done(struct ami_softc *, int, int);
a140 1
void		ami_stimeout(void *);
a178 18
void
ami_remove_runq(struct ami_ccb *ccb)
{
	splassert(IPL_BIO);

	TAILQ_REMOVE(&ccb->ccb_sc->sc_ccb_runq, ccb, ccb_link);
	if (ccb->ccb_sc->sc_drainio && TAILQ_EMPTY(&ccb->ccb_sc->sc_ccb_runq))
		wakeup(ccb->ccb_sc);
}

void
ami_insert_runq(struct ami_ccb *ccb)
{
	splassert(IPL_BIO);

	TAILQ_INSERT_TAIL(&ccb->ccb_sc->sc_ccb_runq, ccb, ccb_link);
}

d385 2
a386 1
	int s;
a412 2
	s = splbio();

a458 1
				splx(s);
a503 2
	splx(s);

d939 1
a939 3
	timeout_set(&xs->stimeout, ami_stimeout, ccb);

	if (xs->flags & SCSI_POLL) {
d941 2
a942 6
		return;
	}

	/* XXX way wrong, this timeout needs to be set later */
	timeout_add_sec(&xs->stimeout, 61);
	ami_start(sc, ccb);
d948 1
a948 3
	int s;

	s = splbio();
d951 2
a953 1
	splx(s);
d959 1
a959 6
	struct ami_softc *sc = arg;
	int s;

	s = splbio();
	ami_runqueue(sc);
	splx(s);
d966 1
d968 7
a974 1
	splassert(IPL_BIO);
d976 3
a978 7
	if (sc->sc_drainio)
		return;

	while ((ccb = TAILQ_FIRST(&sc->sc_ccb_preq)) != NULL) {
		if (sc->sc_exec(sc, &ccb->ccb_cmd) != 0) {
			timeout_add(&sc->sc_run_tmo, 1);
			break;
d980 2
d983 2
a984 4
		TAILQ_REMOVE(&sc->sc_ccb_preq, ccb, ccb_link);
		ccb->ccb_state = AMI_CCB_QUEUED;
		ami_insert_runq(ccb);
	}
a990 1
	int s;
d992 1
a992 1
	s = splbio();
d996 1
a998 1
	splx(s);
d1006 4
a1009 3
	struct ami_iocmd mbox;
	int i = 0, j, done = 0;
	int s, ready;
d1011 2
a1012 1
	s = splbio();
d1018 1
d1022 1
a1022 1
			ami_insert_runq(ccb);
d1028 8
a1035 2
	if (ccb->ccb_state != AMI_CCB_QUEUED)
		goto err;
d1044 12
a1055 8
	i = 0;
	while (i < 30000 /* timeout */) {
		if (sc->sc_done(sc, &mbox) != 0) {
			for (j = 0; j < mbox.acc_nstat; j++) {
				ready = mbox.acc_cmplidl[j];
				ami_done(sc, ready, mbox.acc_status);
				if (ready == ccb->ccb_cmd.acc_id)
					done = 1;
d1057 3
a1059 2
			if (done)
				break;
a1060 9

		DELAY(1000);
		i++;
	}
	if (!done) {
		printf("%s: timeout ccb %d\n", DEVNAME(sc),
		    ccb->ccb_cmd.acc_id);
		ami_remove_runq(ccb);
		goto err;
d1063 2
a1064 68
	/* start the runqueue again */
	ami_runqueue(sc);

	splx(s);

	return;

err:
	ccb->ccb_flags |= AMI_CCB_F_ERR;
	ccb->ccb_state = AMI_CCB_READY;
	ccb->ccb_done(sc, ccb);
	splx(s);
}

void
ami_stimeout(void *v)
{
	struct ami_ccb *ccb = v;
	struct ami_softc *sc = ccb->ccb_sc;
	struct ami_iocmd *cmd = &ccb->ccb_cmd;
	int s;

	s = splbio();
	switch (ccb->ccb_state) {
	case AMI_CCB_PREQUEUED:
		/* command never ran, cleanup is easy */
		TAILQ_REMOVE(&sc->sc_ccb_preq, ccb, ccb_link);
		ccb->ccb_flags |= AMI_CCB_F_ERR;
		ccb->ccb_done(sc, ccb);
		break;

	case AMI_CCB_QUEUED:
		/*
		 * ccb has taken more than a minute to finish. we can't take
		 * it off the hardware in case it finishes later, but we can
		 * warn the user to look at what is happening.
		 */
		AMI_DPRINTF(AMI_D_CMD, ("%s: stimeout ccb %d, check volume "
		    "state\n", DEVNAME(sc), cmd->acc_id));
		break;

	default:
		panic("%s: ami_stimeout(%d) botch", DEVNAME(sc), cmd->acc_id);
	}

	splx(s);
}

int
ami_done(struct ami_softc *sc, int idx, int status)
{
	struct ami_ccb *ccb = &sc->sc_ccbs[idx - 1];

	AMI_DPRINTF(AMI_D_CMD, ("done(%d) ", ccb->ccb_cmd.acc_id));

	if (ccb->ccb_state != AMI_CCB_QUEUED) {
		printf("%s: unqueued ccb %d ready, state = %d\n",
		    DEVNAME(sc), idx, ccb->ccb_state);
		return (1);
	}

	ccb->ccb_state = AMI_CCB_READY;
	ccb->ccb_status = status;
	ami_remove_runq(ccb);

	ccb->ccb_done(sc, ccb);

	return (0);
a1087 1
	timeout_del(&xs->stimeout);
a1124 1
	timeout_del(&xs->stimeout);
a1139 1
	timeout_del(&xs->stimeout);
a1160 1
	timeout_del(&xs->stimeout);
d1529 1
d1531 1
a1531 1
	struct ami_iocmd mbox;
d1534 2
a1535 8
	splassert(IPL_BIO);

	if (TAILQ_EMPTY(&sc->sc_ccb_runq))
		return (0);

	AMI_DPRINTF(AMI_D_INTR, ("intr "));

	while ((sc->sc_done)(sc, &mbox)) {
d1538 1
a1538 1
			ready = mbox.acc_cmplidl[i];
d1540 11
a1550 2
			if (!ami_done(sc, ready, mbox.acc_status))
				rv |= 1;
d1553 2
d1556 3
a1558 1
	if (rv)
d1766 1
a1766 1
	int s, error = 0;
d1810 1
a1810 1
		s = splbio();
d1812 2
a1813 2
			tsleep(ccb, PRIBIO,"ami_mgmt", 0);
		splx(s);
d1816 1
a1816 1
		s = splbio();
d1819 2
a1820 2
			if (tsleep(sc, PRIBIO, "ami_mgmt_drain", hz * 60) ==
			    EWOULDBLOCK) {
d1834 1
a1835 1
		splx(s);
@


1.206
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.205 2010/06/03 12:04:39 dlg Exp $	*/
d120 1
a120 1
void		ami_put_ccb(struct ami_ccb *);
d206 1
a206 2
	splassert(IPL_BIO);

d208 1
a208 1
	if (ccb) {
d212 1
d218 1
a218 1
ami_put_ccb(struct ami_ccb *ccb)
a219 4
	struct ami_softc *sc = ccb->ccb_sc;

	splassert(IPL_BIO);

d224 2
d227 1
d325 1
a325 1
	int i, s, error;
d342 1
d377 1
a377 3
			s = splbio();
			ami_put_ccb(ccb);
			splx(s);
d1201 1
a1201 1
	ami_put_ccb(ccb);
d1229 1
a1229 1
	ami_put_ccb(ccb);
d1244 1
a1244 1
		ami_put_ccb(ccb);
d1266 1
a1266 1
	ami_put_ccb(ccb);
a1318 1
	int s;
a1338 1
	s = splbio();	
a1339 1
	splx(s);
d1366 1
a1366 3
		s = splbio();
		ami_put_ccb(ccb);
		splx(s);
a1438 1
	int s;
a1463 1
		s = splbio();
a1464 1
		splx(s);
a1568 1
	s = splbio();
a1569 1
	splx(s);
d1595 1
a1595 3
		s = splbio();
		ami_put_ccb(ccb);
		splx(s);
a1723 1
	int s;
a1726 1
	s = splbio();
a1727 1
	splx(s);
d1772 1
a1772 3
	s = splbio();
	ami_put_ccb(ccb);
	splx(s);
a1863 1
		s = splbio();
a1864 1
		splx(s);
d1940 1
a1940 3
		s = splbio();
		ami_put_ccb(ccb);
		splx(s);
@


1.205
log
@massage the code to avoid races in ami_mgmt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.204 2010/05/20 00:55:17 krw Exp $	*/
d96 1
a96 1
int	ami_scsi_ioctl(struct scsi_link *, u_long, caddr_t, int, struct proc *);
d1673 1
a1673 2
ami_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag,
    struct proc *p)
@


1.204
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.203 2010/05/18 20:54:34 oga Exp $	*/
d189 2
a190 5
	if (TAILQ_EMPTY(&ccb->ccb_sc->sc_ccb_runq)) {
		ccb->ccb_sc->sc_drained = 1;
		if (ccb->ccb_sc->sc_drainio)
			wakeup(ccb->ccb_sc);
	}
a197 1
	ccb->ccb_sc->sc_drained = 0;
a537 1
	sc->sc_drained = 1;
a1013 1
			/* this is now raceable too with other incoming io */
d1892 1
a1892 1
	} else {
a1893 2
		ccb->ccb_done = ami_done_dummy;
	}
d1925 1
d1928 1
d1931 1
d1933 1
a1933 1
		while (sc->sc_drained != 1)
d1940 6
a1945 1
		ami_poll(sc, ccb);
a1947 1
		s = splbio();
a1967 1
		ccb->ccb_done = NULL;
@


1.203
log
@bus_dmamem_alloc() ...; bzero/memset(); ->
bus_dmamem_alloc(, BUS_DMA_ZERO);

"ok on all the ones with my copyright" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.202 2010/05/16 20:33:59 nicm Exp $	*/
a1341 1
		s = splbio();
a1342 1
		splx(s);
a1352 1
		s = splbio();
a1353 1
		splx(s);
d1379 1
a1380 1
		splx(s);
a1461 1
		s = splbio();
a1462 1
		splx(s);
a1482 1
			s = splbio();
a1483 1
			splx(s);
a1509 1
		s = splbio();
a1510 1
		splx(s);
a1523 1
		s = splbio();
a1524 1
		splx(s);
a1541 1
		s = splbio();
a1542 1
		splx(s);
a1552 1
		s = splbio();
a1553 1
		splx(s);
a1560 1
		s = splbio();
a1561 1
		splx(s);
a1580 1
		s = splbio();
a1581 1
		splx(s);
a1589 1
		s = splbio();
a1590 1
		splx(s);
d1615 1
a1616 1
		splx(s);
@


1.202
log
@Use a temporary variable for now to sidestep -Wbounded checking when
copying vendor[8]/product[16]/revision[4] out of struct scsi_inquiry_data
together with one memcopy.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.201 2010/05/01 08:14:26 mk Exp $	*/
d275 1
a275 1
	    &nsegs, BUS_DMA_NOWAIT) != 0)
a285 1
	memset(am->am_kva, 0, size);
@


1.201
log
@incomming -> incoming

The ones found in gnu/ left out by intention.

ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.200 2010/03/23 01:57:19 krw Exp $	*/
d2140 1
a2140 1
	char vend[8+16+4+1];
d2164 2
a2165 1
		bcopy(inqbuf.vendor, vend, sizeof vend - 1);
d2335 1
a2335 1
	char vend[8+16+4+1];
d2409 2
a2410 1
				bcopy(inqbuf.vendor, vend, sizeof vend - 1);
@


1.200
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.199 2010/01/09 23:15:06 krw Exp $	*/
d1020 1
a1020 1
			/* this is now raceable too with other incomming io */
@


1.199
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.198 2009/12/06 12:31:10 chl Exp $	*/
d95 1
a95 1
int	ami_scsi_cmd(struct scsi_xfer *);
d107 1
a107 1
int	ami_scsi_raw_cmd(struct scsi_xfer *);
d138 1
a138 1
int 		ami_start_xs(struct ami_softc *sc, struct ami_ccb *,
d970 1
a970 1
int
d977 1
a977 1
		return (COMPLETE);
a982 2

	return (SUCCESSFULLY_QUEUED);
d1319 1
a1319 1
int
d1346 1
a1346 1
		return (COMPLETE);
d1355 5
a1359 1
		return (NO_CCB);
d1386 1
a1386 1
		return (COMPLETE);
d1389 1
a1389 1
	return (ami_start_xs(sc, ccb, xs));
d1440 1
a1440 1
int
d1470 1
a1470 1
		return (COMPLETE);
d1489 5
a1493 1
			return (NO_CCB);
d1522 1
a1522 1
		return (COMPLETE);
d1538 1
a1538 1
		return (COMPLETE);
d1558 1
a1558 1
		return (COMPLETE);
d1571 1
a1571 1
		return (COMPLETE);
d1581 1
a1581 1
		return (COMPLETE);
d1603 1
a1603 1
		return (COMPLETE);
d1610 5
a1614 1
		return (NO_CCB);
d1640 1
a1640 1
		return (COMPLETE);
d1667 1
a1667 1
	return (ami_start_xs(sc, ccb, xs));
@


1.198
log
@change M_WAITOK --> M_WAITOK|M_CANFAIL

with input from marco@@

"that i like" marco@@
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.197 2009/08/12 14:15:05 dlg Exp $	*/
a1197 1
	xs->flags |= ITSDONE;
a1235 1
	xs->flags |= ITSDONE;
a1253 1
		xs->flags |= ITSDONE;
a1273 1
	xs->flags |= ITSDONE;
a1344 1
		xs->flags |= ITSDONE;
a1379 1
		xs->flags |= ITSDONE;
a1464 1
		xs->flags |= ITSDONE;
a1512 1
		xs->flags |= ITSDONE;
a1528 1
		xs->flags |= ITSDONE;
a1548 1
		xs->flags |= ITSDONE;
a1561 1
		xs->flags |= ITSDONE;
a1571 1
		xs->flags |= ITSDONE;
a1593 1
		xs->flags |= ITSDONE;
a1625 1
		xs->flags |= ITSDONE;
@


1.197
log
@though shalt complete the xs (ie, call scsi_done with it) before returning
COMPLETE in a scsi_cmd handler.

found by thib when testing my midlayer changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.196 2009/08/09 21:50:20 krw Exp $	*/
d2538 1
a2538 1
	    M_DEVBUF, M_WAITOK|M_ZERO);
d2560 1
a2560 1
	sc->sc_bd = malloc(sizeof(*sc->sc_bd), M_DEVBUF, M_WAITOK);
@


1.196
log
@Make ami(4) use NO_CCB at least some of the time.

"Should never happen but I like it" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.195 2009/06/11 15:48:10 chl Exp $	*/
d1349 1
d1385 1
d1519 5
d1535 3
d1556 3
d1570 3
d1581 1
d1583 1
d1606 1
d1639 1
@


1.195
log
@fix potential use of uninitialized value.

found by LLVM/Clang Static Analyzer.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.194 2009/06/11 07:47:41 chl Exp $	*/
d1361 1
a1361 5
		xs->error = XS_DRIVER_STUFFUP;
		s = splbio();
		scsi_done(xs);
		splx(s);
		return (COMPLETE);
d1492 1
a1492 5
			xs->error = XS_DRIVER_STUFFUP;
			s = splbio();
			scsi_done(xs);
			splx(s);
			return (COMPLETE);
d1598 1
a1598 5
		xs->error = XS_DRIVER_STUFFUP;
		s = splbio();
		scsi_done(xs);
		splx(s);
		return (COMPLETE);
@


1.194
log
@remove dead assignment and newly created unused variable.

Found by LLVM/Clang Static Analyzer.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.193 2009/06/04 06:34:38 ray Exp $	*/
d2513 1
a2513 1
	struct scsibus_softc *ssc;
@


1.193
log
@Add missing argument to printf statement.

Found with -Wformat.

OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.192 2009/02/16 21:19:06 miod Exp $	*/
d2476 1
a2476 1
	int func, off, error;
a2487 2
		off = bs->bs_channel * AMI_MAX_TARGET + bs->bs_target;

@


1.192
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.191 2009/01/11 16:54:59 blambert Exp $	*/
d1960 1
a1960 1
				printf("%s: drain io timeout\n");
@


1.191
log
@Actual final round of timeout_add(to, n * hz) -> timeout_add_sec(to, n)
conversions.

ok kettenis@@
ok krw@@ (possibly for the second time :)
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.190 2008/10/28 11:53:18 marco Exp $	*/
d97 1
a97 1
void	amiminphys(struct buf *bp);
d1303 1
a1303 1
amiminphys(struct buf *bp)
@


1.190
log
@Shut splassert up
Fix an undo error in previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.189 2008/10/28 11:49:28 marco Exp $	*/
d981 1
a981 1
	timeout_add(&xs->stimeout, 61 * hz);
@


1.189
log
@Be nicer waking up.

prompted and ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.188 2008/10/28 11:43:10 marco Exp $	*/
d191 1
a191 1
		if (sc->sc_drainio)
d331 1
a331 1
	int i, error;
d381 2
a382 1
		} else
d384 2
@


1.188
log
@Major overhaul of bio.
Fix set hotspare that didn't always work.
Fix several very subtle bugs because of firmware lies
Fix disk size that sometimes was incorrect
Only poke drives if something changed so it makes bio way faster on subsequent calls

Tested by several folks, thanks
Ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.187 2008/04/10 06:39:00 dlg Exp $	*/
d191 2
a192 1
		wakeup(ccb->ccb_sc);
@


1.187
log
@the success of a command is reported in the mbox, but not passed on to the
completion routines to do anything useful with.

this stashes the commands status in the ccb for the ccb_done handlers to
use. the completion path for passthru commands now checks the mbox status
to see if the command actually works. this prevents phantom devices from
appearing on the passthru busses.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.185 2007/09/27 08:45:19 chl Exp $	*/
d69 1
a72 6

#if NBIO > 0
#include <dev/biovar.h>
#include <sys/sensors.h>
#endif

d81 3
a83 3
	| AMI_D_CMD
	| AMI_D_INTR
	| AMI_D_MISC
d117 2
d146 1
d158 4
d183 21
d209 2
d225 2
d376 6
a381 1
		ami_put_ccb(ccb);
d405 3
d445 2
a446 2
		struct ami_fc_einquiry *einq = AMIMEM_KVA(am);
		struct ami_fc_prodinfo *pi = AMIMEM_KVA(am);
d449 1
d473 1
a473 1
		struct ami_inquiry *inq = AMIMEM_KVA(am);
d504 1
d535 1
a535 1
	if (ami_alloc_ccbs(sc, AMI_MAXCMDS) != 0) {
d539 1
d744 2
d747 1
a747 1
		return (1); /* fail */
d756 1
a756 1
		return (EBUSY);
a766 1

d773 1
d782 1
a782 13
		return (1);
	}

	sc->sc_mbox->acc_nstat = 0xff;

	while ((sc->sc_mbox->acc_status == 0xff) && (i < AMI_MAX_POLLWAIT)) {
		delay(1);
		i++;
	}
	if (i >= AMI_MAX_POLLWAIT) {
		printf("%s: bad status, polling disabled\n", DEVNAME(sc));
		sc->sc_dis_poll = 1;
		return (1);
a783 2
	status = sc->sc_mbox->acc_status;
	sc->sc_mbox->acc_status = 0xff;
d786 1
d795 1
a795 1
		return 1;
a797 3
	sc->sc_mbox->acc_poll = 0;
	sc->sc_mbox->acc_ack = 0x77;

d801 1
d811 1
a811 1
		return (1);
d814 6
d897 2
d900 1
a900 1
		return (1); /* fail */
d910 1
a910 1
		return (EBUSY);
d934 1
a934 1
		return (1); /* fail */
d948 1
a948 1
		return (1); /* fail */
d975 2
a976 1
 
d1011 5
d1025 1
a1025 1
		TAILQ_INSERT_TAIL(&sc->sc_ccb_runq, ccb, ccb_link);
a1034 5
	/* XXX this is broken, shall drain IO or consider this
	 * a normal completion which can complete async and
	 * polled commands until the polled commands completes
	 */

d1037 1
a1037 1
	if (error)
d1051 1
a1051 1
	int s;
d1062 1
a1062 1
			TAILQ_INSERT_TAIL(&sc->sc_ccb_runq, ccb, ccb_link);
a1064 1
		
d1071 7
d1079 1
a1079 1
	while (i < timeout) {
d1082 1
a1082 1
				int ready = mbox.acc_cmplidl[j];
d1097 1
a1097 1
		TAILQ_REMOVE(&sc->sc_ccb_runq, ccb, ccb_link);
d1164 1
a1164 1
	TAILQ_REMOVE(&sc->sc_ccb_runq, ccb, ccb_link);
d1282 5
d1667 3
a1669 1
	int i, rv = 0;
d1679 1
a1679 2
			int ready = mbox.acc_cmplidl[i];

a1680 1

d1754 2
a1755 2
ami_drv_inq(struct ami_softc *sc, u_int8_t ch, u_int8_t tg, u_int8_t page,
    void *inqbuf)
a1758 1
	struct scsi_inquiry_data *inq = inqbuf;
d1778 1
a1778 1
	memset(pt, 0, sizeof(struct ami_passthrough));
d1781 1
a1781 1
	pt->apt_ncdb = sizeof(struct scsi_inquiry);
d1783 1
a1783 1
	pt->apt_datalen = sizeof(struct scsi_inquiry_data);
d1786 1
a1786 11
	pt->apt_cdb[0] = INQUIRY;
	pt->apt_cdb[1] = 0;
	pt->apt_cdb[2] = 0;
	pt->apt_cdb[3] = 0;
	pt->apt_cdb[4] = sizeof(struct scsi_inquiry_data); /* INQUIRY length */
	pt->apt_cdb[5] = 0;

	if (page != 0) {
		pt->apt_cdb[1] = SI_EVPD;
		pt->apt_cdb[2] = page;
	}
d1788 1
a1788 2
	if (ami_load_ptmem(sc, ccb, inqbuf, sizeof(struct scsi_inquiry_data),
	    1, 0) != 0) {
d1796 1
a1796 1
		tsleep(ccb, PRIBIO, "ami_drv_inq", 0);
a1808 2
	else if ((inq->device & SID_TYPE) != T_DIRECT)
		error = EINVAL;
d1821 72
d1900 1
a1900 2
	int error = 0;
	int s;
d1904 12
a1915 6
	s = splbio();
	ccb = ami_get_ccb(sc);
	splx(s);
	if (ccb == NULL) {
		error = ENOMEM;
		goto err;
a1925 1
	ccb->ccb_done = ami_done_ioctl;
a1926 1

d1946 22
a1967 3
	ami_start(sc, ccb);
	while (ccb->ccb_state != AMI_CCB_READY)
		tsleep(ccb, PRIBIO,"ami_mgmt", 0);
a1975 1

d1977 9
a1985 3
	s = splbio();
	ami_put_ccb(ccb);
	splx(s);
a1995 4
	char *plist;
	int i, s, t;
	int off;
	int error = 0;
d1997 30
a2026 1
	u_int8_t ch, tg;
d2032 3
a2034 3
	plist = malloc(AMI_BIG_MAX_PDRIVES, M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!plist) {
		error = ENOMEM;
d2038 1
a2038 3
	if ((error = ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, 0, sizeof *p,
	    p)))
		goto bail2;
a2041 1

d2044 1
a2044 1
	/* do we actually care how many disks we have at this point? */
d2052 3
a2054 2
				if (!plist[off]) {
					plist[off] = 1;
d2059 4
a2062 12
	/*
	 * hack warning!
	 * Megaraid cards sometimes return a size in the PD structure
	 * even though there is no disk in that slot.  Work around
	 * that by issuing an INQUIRY to determine if there is
	 * an actual disk in the slot.
	 */
	for(i = 0; i < ((sc->sc_flags & AMI_QUARTZ) ?
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++) {
	    	/* skip claimed drives */
	    	if (plist[i])
			continue;
d2064 4
a2067 3
	    	/*
		 * poke drive to make sure its there.  If it is it is either
		 * unused or a hot spare; at this point we dont care which it is
d2069 1
a2069 3
		if (p->apd[i].adp_size) {
			ch = (i & 0xf0) >> 4;
			tg = i & 0x0f;
d2071 10
a2080 6
			if (!ami_drv_inq(sc, ch, tg, 0, &inqbuf)) {
				bi->bi_novol++;
				bi->bi_nodisk++;
				plist[i] = 1;
			}
		}
d2083 2
a2084 2
bail2:
	free(plist, M_DEVBUF);
a2086 1

d2093 1
a2093 5
	struct scsi_inquiry_data inqbuf;
	char *plist;
	int i, s, t, off;
	int ld = p->ada_nld, error = EINVAL;
	u_int8_t ch, tg;
d2095 4
a2098 3
	plist = malloc(AMI_BIG_MAX_PDRIVES, M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!plist)
		return (ENOMEM);
d2100 3
a2102 16
	/* setup plist */
	for (i = 0; i < p->ada_nld; i++)
		for (s = 0; s < p->ald[i].adl_spandepth; s++)
			for (t = 0; t < p->ald[i].adl_nstripes; t++) {
				off = p->ald[i].asp[s].adv[t].add_channel *
				    AMI_MAX_TARGET +
				    p->ald[i].asp[s].adv[t].add_target;

				if (!plist[off])
					plist[off] = 1;
			}

	for(i = 0; i < ((sc->sc_flags & AMI_QUARTZ) ?
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++) {
	    	/* skip claimed drives */
	    	if (plist[i])
d2104 1
d2106 13
a2118 7
	    	/*
		 * poke drive to make sure its there.  If it is it is either
		 * unused or a hot spare; at this point we dont care which it is
		 */
		if (p->apd[i].adp_size) {
			ch = (i & 0xf0) >> 4;
			tg = i & 0x0f;
d2120 2
a2121 24
			if (!ami_drv_inq(sc, ch, tg, 0, &inqbuf)) {
				if (ld != bv->bv_volid) {
					ld++;
					continue;
				}

				bv->bv_status = BIOC_SVONLINE;
				bv->bv_size = (u_quad_t)p->apd[i].adp_size *
				    (u_quad_t)512;
				bv->bv_nodisk = 1;
				strlcpy(bv->bv_dev,
				    sc->sc_hdr[bv->bv_volid].dev,
				    sizeof(bv->bv_dev));

				if (p->apd[i].adp_ostatus == AMI_PD_HOTSPARE
				    && p->apd[i].adp_type == 0)
					bv->bv_level = -1;
				else
					bv->bv_level = -2;

				error = 0;
				goto bail;
			}
		}
a2124 2
	free(plist, M_DEVBUF);

d2132 2
d2136 1
a2136 3
	char *plist;
	int i, s, t, off;
	int ld = p->ada_nld, error = EINVAL;
d2138 1
d2140 3
a2142 22
	plist = malloc(AMI_BIG_MAX_PDRIVES, M_DEVBUF, M_NOWAIT|M_ZERO);
	if (!plist)
		return (ENOMEM);

	/* setup plist */
	for (i = 0; i < p->ada_nld; i++)
		for (s = 0; s < p->ald[i].adl_spandepth; s++)
			for (t = 0; t < p->ald[i].adl_nstripes; t++) {
				off = p->ald[i].asp[s].adv[t].add_channel *
				    AMI_MAX_TARGET +
				    p->ald[i].asp[s].adv[t].add_target;

				if (!plist[off])
					plist[off] = 1;
			}

	for(i = 0; i < ((sc->sc_flags & AMI_QUARTZ) ?
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++) {
		char vend[8+16+4+1];

	    	/* skip claimed drives */
	    	if (plist[i])
d2145 3
a2147 2
		/* no size no disk, most of the times */
		if (!p->apd[i].adp_size)
d2149 1
a2152 5

	    	/*
		 * poke drive to make sure its there.  If it is it is either
		 * unused or a hot spare; at this point we dont care which it is
		 */
d2154 1
a2154 1
			continue;
a2155 5
		if (ld != bd->bd_volid) {
			ld++;
			continue;
		}

a2161 2
			char ser[32 + 1];

a2162 1

a2165 1

d2169 3
a2171 1
		bd->bd_size = (u_quad_t)p->apd[i].adp_size * (u_quad_t)512;
d2173 1
a2195 2
	free(plist, M_DEVBUF);

d2265 1
a2265 1
			/* get rebuild progress here */
a2274 4

			/* XXX fix this, we should either use lowest percentage
			 * of all disks in rebuild state or an average
			 */
d2324 1
a2324 1
	int error = 0;
d2326 2
a2341 2
	error = EINVAL;

d2353 3
d2367 1
d2380 1
a2382 2
			bd->bd_size = (u_quad_t)p->apd[off].adp_size *
			    (u_quad_t)512;
d2387 12
a2399 2
				char vend[8+16+4+1];

a2400 1

a2406 2
				char ser[32 + 1];

a2407 1

d2414 1
a2414 9

			bd->bd_channel = ch;
			bd->bd_target = tg;

			strlcpy(bd->bd_procdev, sc->sc_rawsoftcs[ch].sc_procdev,
			    sizeof(bd->bd_procdev));

			error = 0;
			goto bail;
d2417 2
a2418 1
	/* XXX if we reach this do dedicated hotspare magic*/
@


1.186
log
@massage the way vpds are defined. rename the page used for the devices
serial number and split the vpd header out for use in other places. while
here define the device identification page bits too.

ok krw@@ marco@@
@
text
@d137 1
a137 1
int		ami_done(struct ami_softc *, int);
d1043 1
a1043 1
				ami_done(sc, ready);
d1110 1
a1110 1
ami_done(struct ami_softc *sc, int idx)
d1123 1
d1158 3
a1160 1
 	else if (xs->flags & SCSI_POLL && xs->cmd->opcode == INQUIRY) {
d1636 1
a1636 1
			if (!ami_done(sc, ready))
@


1.185
log
@M_ZERO changes

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.184 2007/06/24 05:34:35 dlg Exp $	*/
d2016 1
a2016 1
	struct scsi_inquiry_vpd vpdbuf;
d2076 2
a2077 2
			if (vpdbuf.page_length < sizeof ser)
				ser[vpdbuf.page_length] = '\0';
d2236 1
a2236 1
	struct scsi_inquiry_vpd vpdbuf;
d2316 2
a2317 2
				if (vpdbuf.page_length < sizeof ser)
					ser[vpdbuf.page_length] = '\0';
@


1.184
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.183 2007/05/31 18:39:03 dlg Exp $	*/
d236 1
a236 1
	am = malloc(sizeof(struct ami_mem), M_DEVBUF, M_NOWAIT);
a239 1
	memset(am, 0, sizeof(struct ami_mem));
d567 1
a567 1
	    M_DEVBUF, M_NOWAIT);
a572 1
	bzero(rsc, sizeof(struct ami_rawsoftc) * sc->sc_channels);
d1874 1
a1874 1
	plist = malloc(AMI_BIG_MAX_PDRIVES, M_DEVBUF, M_NOWAIT);
a1883 2
	memset(plist, 0, AMI_BIG_MAX_PDRIVES);

d1949 1
a1949 1
	plist = malloc(AMI_BIG_MAX_PDRIVES, M_DEVBUF, M_NOWAIT);
a1952 2
	memset(plist, 0, AMI_BIG_MAX_PDRIVES);

d2022 1
a2022 1
	plist = malloc(AMI_BIG_MAX_PDRIVES, M_DEVBUF, M_NOWAIT);
a2025 2
	memset(plist, 0, AMI_BIG_MAX_PDRIVES);

d2442 1
a2442 1
	    M_DEVBUF, M_WAITOK);
a2444 1
	bzero(sc->sc_sensors, sizeof(struct ksensor) * sc->sc_nunits);	
@


1.183
log
@erroneously EINVAL is always reported where the function
actually produces the real errno for the problem.
currently for kernel memory allocation failures
bioctl would return EINVAL that makes no sense.

another diff from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.182 2007/05/31 18:34:12 dlg Exp $	*/
d2477 1
a2477 1
	if (sensor_task_register(sc, ami_refresh_sensors, 10) != 0)
@


1.182
log
@if poking the controller fails for whatever reason the drives'
sensor status will still be marked as ok (or etc..)
thus erroneously reporting value as valid.

this nice diff was from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.181 2007/05/29 22:17:50 todd Exp $	*/
d1882 2
a1883 2
	if (ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, 0, sizeof *p, p)) {
		error = EINVAL;
a1884 1
	}
d2132 1
a2132 2
	if (ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, 0, sizeof *p, p)) {
		error = EINVAL;
a2133 1
	}
d2255 1
a2255 2
	if (ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, 0, sizeof *p, p)) {
		error = EINVAL;
a2256 1
	}
d2379 2
a2380 3
	if (ami_mgmt(sc, AMI_SPEAKER, func, 0, 0, sizeof ret, &ret))
		error = EINVAL;
	else
d2385 1
d2394 1
a2394 2
	int func;
	int off;
d2421 3
a2423 3
	if (ami_mgmt(sc, AMI_CHSTATE, bs->bs_channel, bs->bs_target, func,
	    0, NULL))
		return (EINVAL);
@


1.181
log
@sprinkle some SMALL_KERNEL to permit bio/softraid to run on boot media
ok marco@@ then suggested deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.180 2007/05/29 20:41:41 marco Exp $	*/
d2505 5
a2509 1
	    sc->sc_bd))
d2511 1
@


1.180
log
@Make stimeout a debug print.  It has no value for users to see it.

prompted by deraadt
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.179 2007/05/08 13:11:21 dlg Exp $	*/
d173 1
d176 1
d561 1
d565 1
d2434 1
d2531 1
@


1.179
log
@ami chips have no mechanism to take commands off them once we've submitted
them. this means that we cant reliably complete an io before the chip says
we can because it can possibly complete later and overwrite memory it no
longer owns, or write garbage to disk.

so this diff forces the timeout on a scsi io to be as long as the chip
should ever take, which is sixty seconds. after much discussion with marco
we also decided to add a bit more so the time spent in the software runq
wouldnt affect the ios lifetime too much.

instead of completing ios out of the timeout, this simply warns the
operator to check the state of the volumes if things are starting to slow
down.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.178 2007/04/26 11:39:33 bluhm Exp $	*/
d1096 2
a1097 2
		printf("%s: stimeout ccb %d, check volume state\n",
		    DEVNAME(sc), cmd->acc_id);
@


1.178
log
@Improve debug statements.  No binary change without AMI_DEBUG.
ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.177 2007/03/22 16:55:31 deraadt Exp $	*/
d941 1
a941 1
	timeout_add(&xs->stimeout, (xs->timeout * hz) / 1000);
d1087 1
d1091 7
a1097 3
		/* XXX create a list to save ccb to and print the whole list */
		printf("%s: timeout ccb %d\n", DEVNAME(sc), cmd->acc_id);
		TAILQ_REMOVE(&sc->sc_ccb_runq, ccb, ccb_link);
a1103 1
	ccb->ccb_done(sc, ccb);
@


1.177
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.176 2007/01/27 05:09:51 dlg Exp $	*/
d221 1
a221 1
	AMI_DPRINTF(AMI_D_CMD, ("awo 0x%x 0x%08x", r, v));
d390 2
a391 1
	AMI_DPRINTF(AMI_D_CMD, ("mbox_pa=%llx ", sc->sc_mbox_pa));
d2530 1
a2530 1
	printf("acc_cmd: %d  aac_id: %d  acc_busy: %d  acc_nstat: %d",
@


1.176
log
@convert to our locks to rwlocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.175 2006/12/23 17:46:39 deraadt Exp $	*/
d2445 1
a2445 1
	sc->sc_sensors = malloc(sizeof(struct sensor) * sc->sc_nunits,
d2449 1
a2449 1
	bzero(sc->sc_sensors, sizeof(struct sensor) * sc->sc_nunits);	
@


1.175
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.174 2006/11/28 23:59:45 dlg Exp $	*/
d61 1
a61 1
#include <sys/lock.h>
d541 1
a541 1
	lockinit(&sc->sc_lock, PZERO, DEVNAME(sc), 0, 0);
d1708 1
a1708 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d1775 1
a1775 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d1790 1
a1790 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d1848 1
a1848 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
@


1.174
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.173 2006/08/28 01:34:52 krw Exp $	*/
d2451 3
a2462 2
		strlcpy(sc->sc_sensors[i].device, DEVNAME(sc),
		    sizeof(sc->sc_sensors[i].device));
d2466 1
a2466 1
		sensor_add(&sc->sc_sensors[i]);
d2476 2
a2482 2
	while (--i >= 0)
		sensor_del(&sc->sc_sensors[i]);
@


1.173
log
@bzero() the sensor memory after allocating it.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.172 2006/08/03 09:06:51 dlg Exp $	*/
d367 1
d543 4
a546 1
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
d584 4
a587 1
		config_found(&sc->sc_dev, &rsc->sc_link, scsiprint);
@


1.172
log
@always call scsi_done at splbio. issue found by pedro@@
while here try to avoid nesting splbio calls when dealing with the
runqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.171 2006/06/28 08:26:00 dlg Exp $	*/
d2442 1
@


1.171
log
@rewrite how the sensors are created. previously they would wait for io to
be done on the logical disks so ami_scsi_cmd can stash the name of the
device doing the io. we now walk the device tree after the logical disks
are attached and use the names of ami's child devices.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.170 2006/06/28 04:48:56 deraadt Exp $	*/
d138 2
a139 1
void		ami_runqueue(void *);
d321 1
a321 1
	timeout_set(&sc->sc_run_tmo, ami_runqueue, sc);
d947 1
d949 1
d951 7
d959 1
d963 1
a963 1
ami_runqueue(void *arg)
a964 1
	struct ami_softc *sc = arg;
a965 1
	int s;
a966 1
	s = splbio();
a977 1
	splx(s);
a1049 1
	splx(s);
d1053 3
d1283 1
d1285 1
d1296 1
d1298 1
d1321 1
d1324 1
a1325 2
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
d1408 1
d1410 1
d1431 1
d1433 1
d1470 1
d1472 1
d1488 1
d1490 1
d1499 1
d1501 1
d1508 1
d1510 1
d1530 1
d1532 1
d1541 1
d1543 1
d1565 1
d1568 1
a1569 2
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
@


1.170
log
@put proto where it is because dlg says he is a dodo
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.169 2006/06/27 23:10:38 dlg Exp $	*/
d171 3
a173 1
void		ami_refresh(void *);
d553 2
a554 2
	if (sensor_task_register(sc, ami_refresh, 10))
		printf("%s: unable to register update task\n", DEVNAME(sc));
d2389 61
d2451 1
a2451 1
ami_refresh(void *arg)
d2456 1
a2456 20
	if (sc->sc_first_poll == 0) {
		sc->sc_first_poll = 1;
		sc->sc_sens_ld = malloc(sizeof(struct sensor) * sc->sc_nunits,
		    M_DEVBUF, M_WAITOK);
		sc->sc_bd = malloc(sizeof *sc->sc_bd, M_DEVBUF, M_WAITOK);

		for (i = 0; i < sc->sc_nunits; i++) {
			strlcpy(sc->sc_sens_ld[i].device, sc->sc_hdr[i].dev,
			    sizeof(sc->sc_sens_ld[i].device));
			snprintf(sc->sc_sens_ld[i].desc,
			    sizeof(sc->sc_sens_ld[i].desc), "%s %d",
			    DEVNAME(sc), i);
			sc->sc_sens_ld[i].type = SENSOR_DRIVE;
			sensor_add(&sc->sc_sens_ld[i]);
			sc->sc_sens_ld[i].value = SENSOR_DRIVE_ONLINE;
			sc->sc_sens_ld[i].status = SENSOR_S_OK;
		}
	}

	if (ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, 0, sizeof *sc->sc_bd,
d2463 2
a2464 2
			sc->sc_sens_ld[i].value = SENSOR_DRIVE_FAIL;
			sc->sc_sens_ld[i].status = SENSOR_S_CRIT;
d2468 2
a2469 2
			sc->sc_sens_ld[i].value = SENSOR_DRIVE_PFAIL;
			sc->sc_sens_ld[i].status = SENSOR_S_WARN;
d2473 2
a2474 2
			sc->sc_sens_ld[i].value = SENSOR_DRIVE_ONLINE;
			sc->sc_sens_ld[i].status = SENSOR_S_OK;
d2478 2
a2479 2
			sc->sc_sens_ld[i].value = 0xffff; /* unknown */
			sc->sc_sens_ld[i].status = SENSOR_S_UNKNOWN;
@


1.169
log
@unbreak builds without BIO by moving the sensor setup back under its ifdef.
i could move the shared code that the sensor and bio paths use, but this
would add bloat i think.

found by _mx, fix by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.168 2006/06/27 08:01:05 dlg Exp $	*/
a155 2
void		ami_refresh(void *);

d171 1
@


1.168
log
@we can do the sensors without BIO
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.167 2006/06/27 07:56:55 dlg Exp $	*/
a71 1
#include <sys/sensors.h>
d75 1
a550 1
#endif
d554 1
@


1.167
log
@we cant do bioctl or sensors on broken controllers since they dont have the
spare ccbs for it and they dont understand the megaraid commands we use in
those paths.

initially found by jared rr spiegel
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.166 2006/06/09 04:48:13 marco Exp $	*/
d72 2
a75 1
#include <sys/sensors.h>
d156 2
a172 1
void		ami_refresh(void *);
@


1.166
log
@Simplify ami_disk by chaging some ifs around.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.165 2006/06/09 04:27:10 marco Exp $	*/
d538 6
d546 1
a546 1
		printf("%s: controller registration failed", DEVNAME(sc));
d549 1
a552 7
#endif /* NBIO > 0 */

	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);

	/* can't do pass-through on broken device for now */
	if (sc->sc_flags & AMI_BROKEN)
		return (0);
a563 2

		/* TODO fetch and print channel properties */
@


1.165
log
@Add percentages for BGI and Rebuild. Example:
# bioctl -h ami0
Volume  Status     Size           Device
 ami0 0 Rebuild             1000M sd1     RAID5 8% done
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.164 2006/05/28 09:21:57 uwe Exp $	*/
d2003 2
d2009 7
d2020 12
a2031 3
		if (p->apd[i].adp_size) {
			ch = (i & 0xf0) >> 4;
			tg = i & 0x0f;
d2033 2
a2034 2
			if (!ami_drv_inq(sc, ch, tg, 0, &inqbuf)) {
				char vend[8+16+4+1];
d2036 1
a2036 4
				if (ld != bd->bd_volid) {
					ld++;
					continue;
				}
d2038 3
a2040 2
				bcopy(inqbuf.vendor, vend,
				    sizeof vend - 1);
d2042 2
a2043 16
				vend[sizeof vend - 1] = '\0';
				strlcpy(bd->bd_vendor, vend,
				    sizeof(bd->bd_vendor));

				if (!ami_drv_inq(sc, ch, tg, 0x80, &vpdbuf)) {
					char ser[32 + 1];

					bcopy(vpdbuf.serial, ser,
					    sizeof ser - 1);

					ser[sizeof ser - 1] = '\0';
					if (vpdbuf.page_length < sizeof ser)
						ser[vpdbuf.page_length] = '\0';
					strlcpy(bd->bd_serial, ser,
					    sizeof(bd->bd_serial));
				}
d2045 1
a2045 2
				bd->bd_size = (u_quad_t)p->apd[i].adp_size *
				    (u_quad_t)512;
d2047 2
a2048 2
				bd->bd_channel = ch;
				bd->bd_target = tg;
d2050 2
a2051 3
				strlcpy(bd->bd_procdev,
				    sc->sc_rawsoftcs[ch].sc_procdev,
				    sizeof(bd->bd_procdev));
d2053 4
a2056 4
				if (p->apd[i].adp_ostatus == AMI_PD_HOTSPARE)
					bd->bd_status = BIOC_SDHOTSPARE;
				else
					bd->bd_status = BIOC_SDUNUSED;
d2059 3
a2061 5
				if (p->apd[i].adp_type != 0)
					printf("invalid disk type: %d %d "
					    "%x inquiry type: %x\n",
					    ch, tg, p->apd[i].adp_type,
					    inqbuf.device);
d2064 2
a2065 4
				error = 0;
				goto bail;
			}
		}
@


1.164
log
@Remove dead code; free commit on behalf of dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.163 2006/05/26 15:57:32 marco Exp $	*/
d2082 1
a2082 1
	int i, s, t;
d2084 2
d2114 16
d2135 27
@


1.163
log
@Add dlg to copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.162 2006/05/21 19:48:51 dlg Exp $	*/
a1496 5
#if 0
		/* TODO: reflect DPO & FUA flags */
		if (xs->cmd->opcode == WRITE_BIG && rwb->byte2 & 0x18)
			flags |= 0;
#endif
@


1.162
log
@move the allocation of ccb out of ami_attach into a function of its own
(aptly called ami_alloc_ccbs). allocate the ccbs after the firmware has
been queried, but still for the full number of AMI_MAXCMDS.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.161 2006/05/21 19:17:22 dlg Exp $	*/
d6 1
@


1.161
log
@move variable declarations at the start of a block in ami_attach to the top
of the function and unindent that block.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.160 2006/05/21 18:52:37 dlg Exp $	*/
d130 1
d293 1
a293 1
ami_attach(struct ami_softc *sc)
d295 1
a295 3
	struct ami_rawsoftc *rsc;
	struct ami_ccb iccb, *ccb;
	struct ami_iocmd *cmd;
a296 3
	struct ami_mem *am;
	const char *p;
	paddr_t	pa;
a297 8
	int s;

	am = ami_allocmem(sc, NBPG);
	if (am == NULL) {
		printf(": unable to allocate init data\n");
		return (1);
	}
	pa = htole32(AMIMEM_DVA(am));
d299 1
a299 10
	sc->sc_mbox_am = ami_allocmem(sc, sizeof(struct ami_iocmd));
	if (sc->sc_mbox_am == NULL) {
		printf(": unable to allocate mbox\n");
		goto free_idata;
	}
	sc->sc_mbox = (volatile struct ami_iocmd *)AMIMEM_KVA(sc->sc_mbox_am);
	sc->sc_mbox_pa = htole32(AMIMEM_DVA(sc->sc_mbox_am));
	AMI_DPRINTF(AMI_D_CMD, ("mbox_pa=%llx ", sc->sc_mbox_pa));

	sc->sc_ccbs = malloc(sizeof(struct ami_ccb) * AMI_MAXCMDS,
d303 1
a303 1
		goto free_mbox;
d306 1
a306 2
	sc->sc_ccbmem_am = ami_allocmem(sc,
	    sizeof(struct ami_ccbmem) * AMI_MAXCMDS);
d318 1
a318 1
	for (i = 0; i < AMI_MAXCMDS; i++) {
d327 1
a327 1
			goto destroy;
d346 40
d443 1
a443 1
				goto destroy;
d490 5
a581 8
destroy:
	for (ccb = &sc->sc_ccbs[AMI_MAXCMDS - 1]; ccb > sc->sc_ccbs; ccb--)
		if (ccb->ccb_dmamap)
			bus_dmamap_destroy(sc->sc_dmat, ccb->ccb_dmamap);

	ami_freemem(sc, sc->sc_ccbmem_am);
free_ccbs:
	free(sc->sc_ccbs, M_DEVBUF);
@


1.160
log
@during attach use a static, spartan ccb with ami_poll to query to firmare
for its params. this means we can ask it how many ccbs it can deal with
before we allocate them.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.159 2006/05/21 18:28:24 dlg Exp $	*/
d300 3
a302 2
	int	i, error;
	/* u_int32_t *pp; */
d309 1
a374 3
	{
		paddr_t	pa = htole32(AMIMEM_DVA(am));
		int s;
d376 14
a389 1
		s = splbio();
a390 1
		/* try FC inquiry first */
d392 2
a393 2
		cmd->acc_io.aio_channel = AMI_FC_EINQ3;
		cmd->acc_io.aio_param = AMI_FC_EINQ3_SOLICITED_FULL;
d396 1
a396 13
			struct ami_fc_einquiry *einq = AMIMEM_KVA(am);
			struct ami_fc_prodinfo *pi = AMIMEM_KVA(am);

			sc->sc_nunits = einq->ain_nlogdrv;
			ami_copyhds(sc, einq->ain_ldsize, einq->ain_ldprop,
			    einq->ain_ldstat);

			cmd->acc_cmd = AMI_FCOP;
			cmd->acc_io.aio_channel = AMI_FC_PRODINF;
			cmd->acc_io.aio_param = 0;
			cmd->acc_io.aio_data = pa;
			if (ami_poll(sc, &iccb) == 0) {
				sc->sc_maxunits = AMI_BIG_MAX_LDRIVES;
d398 9
a406 10
				bcopy (pi->api_fwver, sc->sc_fwver, 16);
				sc->sc_fwver[15] = '\0';
				bcopy (pi->api_biosver, sc->sc_biosver, 16);
				sc->sc_biosver[15] = '\0';
				sc->sc_channels = pi->api_channels;
				sc->sc_targets = pi->api_fcloops;
				sc->sc_memory = letoh16(pi->api_ramsize);
				sc->sc_maxcmds = pi->api_maxcmd;
				p = "FC loop";
			}
d408 1
d410 2
a411 2
		if (sc->sc_maxunits == 0) {
			struct ami_inquiry *inq = AMIMEM_KVA(am);
d413 6
a418 1
			cmd->acc_cmd = AMI_EINQUIRY;
d423 3
a425 9
				cmd->acc_cmd = AMI_INQUIRY;
				cmd->acc_io.aio_channel = 0;
				cmd->acc_io.aio_param = 0;
				cmd->acc_io.aio_data = pa;
				if (ami_poll(sc, &iccb) != 0) {
					splx(s);
					printf(": cannot do inquiry\n");
					goto destroy;
				}
a426 15

			sc->sc_maxunits = AMI_MAX_LDRIVES;
			sc->sc_nunits = inq->ain_nlogdrv;
			ami_copyhds(sc, inq->ain_ldsize, inq->ain_ldprop,
			    inq->ain_ldstat);

			bcopy (inq->ain_fwver, sc->sc_fwver, 4);
			sc->sc_fwver[4] = '\0';
			bcopy (inq->ain_biosver, sc->sc_biosver, 4);
			sc->sc_biosver[4] = '\0';
			sc->sc_channels = inq->ain_channels;
			sc->sc_targets = inq->ain_targets;
			sc->sc_memory = inq->ain_ramsize;
			sc->sc_maxcmds = inq->ain_maxcmd;
			p = "target";
d429 15
a443 22
		if (sc->sc_flags & AMI_BROKEN) {
			sc->sc_link.openings = 1;
			sc->sc_maxcmds = 1;
			sc->sc_maxunits = 1;
		} else {
			sc->sc_maxunits = AMI_BIG_MAX_LDRIVES;
			if (sc->sc_maxcmds > AMI_MAXCMDS)
				sc->sc_maxcmds = AMI_MAXCMDS;
			/*
			 * Reserve ccb's for ioctl's and raw commands to
			 * processors/enclosures by lowering the number of
			 * openings available for logical units.
			 */
			sc->sc_maxcmds -= AMI_MAXIOCTLCMDS + AMI_MAXPROCS *
			    AMI_MAXRAWCMDS * sc->sc_channels;

			if (sc->sc_nunits)
				sc->sc_link.openings =
				    sc->sc_maxcmds / sc->sc_nunits;
			else
				sc->sc_link.openings = sc->sc_maxcmds;
		}
d445 21
a465 1
		splx(s);
d467 3
@


1.159
log
@the maximum possible number of ccbs that a megaraid can use (126 of them)
is preallocated in the softc, even if the driver is only ever going to use
one of them when running. this allocates them separately during attach as a
first step toward having the driver only allocate as many ccbs as the
firmware can support.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.158 2006/05/21 03:33:53 dlg Exp $	*/
d146 1
a146 1
void		ami_done_ccb(struct ami_softc *, struct ami_ccb *);
d295 1
a295 1
	struct ami_ccb	*ccb;
d366 6
a378 4
		ccb = ami_get_ccb(sc);
		ccb->ccb_done = ami_done_ccb;
		cmd = &ccb->ccb_cmd;

d384 1
a384 1
		if (ami_poll(sc, ccb) == 0) {
a391 4
			ccb = ami_get_ccb(sc);
			ccb->ccb_done = ami_done_ccb;
			cmd = &ccb->ccb_cmd;

d396 1
a396 1
			if (ami_poll(sc, ccb) == 0) {
a413 4
			ccb = ami_get_ccb(sc);
			ccb->ccb_done = ami_done_ccb;
			cmd = &ccb->ccb_cmd;

d418 1
a418 5
			if (ami_poll(sc, ccb) != 0) {
				ccb = ami_get_ccb(sc);
				ccb->ccb_done = ami_done_ccb;
				cmd = &ccb->ccb_cmd;

d423 1
a423 1
				if (ami_poll(sc, ccb) != 0) {
d1206 1
a1206 1
ami_done_ccb(struct ami_softc *sc, struct ami_ccb *ccb)
d1208 1
a1208 1
	ami_put_ccb(ccb);
@


1.158
log
@remove a chunk of code that was ifdefed out due to compat issues with
older firmwares. it was stagnating and now completely broken. if we need it
back then we can poke around in cvs for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.157 2006/05/21 02:51:09 dlg Exp $	*/
d318 7
d329 1
a329 1
		goto free_mbox;
d576 2
@


1.157
log
@The SCSI command on the passthrough bus is handed to the firmware via a
structure not included in the MegaRAID command, so it needs to be synced
before we submit it. Previously this was done only when the SCSI command
had an associated data buffer. The syncing of the passthrough command is
now done unconditionally.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.156 2006/05/12 20:51:25 marco Exp $	*/
a447 35
#if 0
		/* FIXME need to find a way to detect if fw supports this
		 * calling it this way crashes fw when io is ran to
		 * multiple logical disks
		 */

		/* reset the IO completion values to 0
		 * the firmware either has at least pp[0] IOs outstanding
		 * -or-
		 * it times out pp[1] us before it completes any IO
		 * if the values remain unchanged it locksteps the driver
		 * to a maximum of 4 outstanding IOs and it hits the 5us timer
		 * continuously (these are the default values)
		 * this trick only works with firmwares newer than 5/13/05
		 * Setting the values outright will hang old firmwares so
		 * we need to read them first before setting them.
		 */
		ccb = ami_get_ccb(sc);
		ccb->ccb_done = ami_done_ccb;
		ccb->ccb_data = NULL;
		cmd = &ccb->ccb_cmd;

		cmd->acc_cmd = AMI_MISC;
		cmd->acc_io.aio_channel = AMI_GET_IO_CMPL; /* sub opcode */
		cmd->acc_io.aio_param = 0;
		cmd->acc_io.aio_data = pa;

		if (ami_poll(sc, ccb) != 0) {
			AMI_DPRINTF(AMI_D_MISC, ("getting io completion values"
			    " failed\n"));
		} else {
			ccb = ami_get_ccb(sc);
			ccb->ccb_done = ami_done_ccb;
			ccb->ccb_data = NULL;
			cmd = &ccb->ccb_cmd;
a448 19
			cmd->acc_cmd = AMI_MISC;
			cmd->acc_io.aio_channel = AMI_SET_IO_CMPL;
			cmd->acc_io.aio_param = 0;
			cmd->acc_io.aio_data = pa;

			/* set parameters */
			pp = AMIMEM_KVA(am);
			pp[0] = 0; /* minimal outstanding commands, 0 disable */
			pp[1] = 0; /* maximal timeout in us, 0 disable */

			if (ami_poll(sc, ccb) != 0) {
				AMI_DPRINTF(AMI_D_MISC, ("setting io completion"
				    " values failed\n"));
			} else {
				AMI_DPRINTF(AMI_D_MISC, ("setting io completion"
				    " values succeeded\n"));
			}
		}
#endif
@


1.156
log
@Fix a misreporting bug after bioctl -H is used to create a hotspare.  This was
reported by several people.  What happens is that the firmware sometimes
misreports what SCSI type a device is.  The driver was only allowing a create
hotspare function when the type was set to hard disk.  Since the firmware will,
obviously, not allow the driver to create a hotspare on any other type of device
the driver doesn't need these smarts and now will ignore the type.

Tested by henning todd and Ben Lovett.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.155 2006/04/26 22:41:08 dlg Exp $	*/
d1154 4
a1163 4
		bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
		    ccb->ccb_offset, sizeof(struct ami_ccbmem),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

d1364 1
a1364 1
	int error = 0, i;
d1366 9
a1374 2
	if (data == NULL) /* nothing to do */
		return (0);
d1376 2
a1377 7
	error = bus_dmamap_load(sc->sc_dmat, ccb->ccb_dmamap, data, len,
	    NULL, nowait ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);
	if (error) {
		if (error == EFBIG)
			printf("more than %d dma segs\n", AMI_MAXOFFSETS);
		else
			printf("error %d loading dma map\n", error);
d1379 15
a1393 2
		return (1);
	}
d1395 2
a1396 14
	sgd = dmap->dm_segs;
	if (dmap->dm_nsegs > 1) {
		struct ami_sgent *sgl = ccb->ccb_sglist;

		ccb->ccb_pt->apt_nsge = dmap->dm_nsegs;
		ccb->ccb_pt->apt_data = ccb->ccb_sglistpa;

		for (i = 0; i < dmap->dm_nsegs; i++) {
			sgl[i].asg_addr = htole32(sgd[i].ds_addr);
			sgl[i].asg_len = htole32(sgd[i].ds_len);
		}
	} else {
		ccb->ccb_pt->apt_nsge = 0;
		ccb->ccb_pt->apt_data = htole32(sgd->ds_addr);
a1401 3

	bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0, dmap->dm_mapsize,
	    read ? BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
@


1.155
log
@it turns out that a drivers interrupt handler is called at the spl it was
established at. this means we dont need splbio() calls in ami_intr because
its already been raised.

this diff removes unneeded splbio calls from the interrupt handler path.
it also sets it up so the completion paths are all called at splbio, so i
can get rid of the spl calls inside those functions too.

neither marco or pedro could see anything wrong with it
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.151 2006/04/21 07:29:00 dlg Exp $	*/
d50 2
a75 2
/*#define	AMI_DEBUG */

d2098 1
a2098 2
				if (p->apd[i].adp_ostatus == AMI_PD_HOTSPARE
				    && p->apd[i].adp_type == 0)
d2103 8
d2356 1
a2357 2
	struct ami_big_diskarray *p;
	struct scsi_inquiry_data inqbuf;
a2369 7
		p = malloc(sizeof *p, M_DEVBUF, M_NOWAIT);
		if (!p)
			return (ENOMEM);

		if (ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, 0, sizeof *p, p))
			goto bail;

d2374 1
a2374 3
			goto bail;

		free(p, M_DEVBUF);
a2389 5

bail:
	free(p, M_DEVBUF);

	return (EINVAL);
@


1.154
log
@the error path for teh sync cache command should return, not try to blunder
on with the second half of the command.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.153 2006/04/23 15:32:09 marco Exp $	*/
a1024 2
	splx(s);

d1027 1
d1029 1
a1088 1
	splx(s);
d1092 1
d1103 1
a1106 1
		s = splbio();
a1108 1
		splx(s);
a1113 1
		s = splbio();
a1114 2
		/* do not reuse the ccb since its still on the hw */
		splx(s);
d1122 1
a1128 1
	int s;
a1137 1
	s = splbio();
a1139 1
	splx(s);
a1152 1
	int s;
a1181 1
	s = splbio();
a1183 1
	splx(s);
a1189 1
	int s;
a1210 1
	s = splbio();
a1212 1
	splx(s);
a1219 1
	int s;
a1226 1
		s = splbio();
a1228 1
		splx(s);
a1242 1
	int s;
a1249 1
	s = splbio();
a1251 1
	splx(s);
a1262 3
	int s;

	s = splbio();
a1263 1
	splx(s);
a1620 1
	int s;
a1626 1
	s = splbio();
a1637 2

	splx(s);
@


1.153
log
@Fix an embarrassing pasto that triggered a panic.  Reported by henning.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.152 2006/04/22 18:55:36 marco Exp $	*/
d1244 1
@


1.152
log
@Henning reported a crash I can't explain while using the new sensor code.
Disable until diagnosed and fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.151 2006/04/21 07:29:00 dlg Exp $	*/
a577 2
	/* XXX */
	/*
a579 1
	*/
d2451 1
a2451 3
	    sc->sc_bd)) {
		sc->sc_sens_ld[i].value = 0xffff; /* unknown */
		sc->sc_sens_ld[i].status = SENSOR_S_UNKNOWN;
a2452 1
	}
@


1.151
log
@remove the ami_inquire prototype. the function doesnt exist and its not
used anywhere.

thanks lint. thint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.150 2006/04/20 13:32:29 dlg Exp $	*/
d578 2
d582 1
@


1.150
log
@return after goto wont be reached, so remove it. found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.149 2006/04/20 13:02:26 dlg Exp $	*/
a148 1
int		ami_inquire(struct ami_softc *, u_int8_t);
@


1.149
log
@get rid of the ccb list typedef. while here switch to TAILQ_HEAD instead
of TAILQ_TAIL when pulling ccbs off the free list since it does less
"interesting" things with pointers. changes prompted by lint bitching.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.148 2006/04/20 12:14:54 dlg Exp $	*/
a1837 1
			return (ENOMEM);
@


1.148
log
@remove some useless code found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.147 2006/04/20 04:39:11 dlg Exp $	*/
d179 1
a179 1
	ccb = TAILQ_LAST(&sc->sc_ccb_freeq, ami_queue_head);
@


1.147
log
@this is the proper fix for krws bug. i feel kinda bad taking the commit
from him since he did most of the hard work on it.

when marco added the sensor for logical disks he added some extra bits
to the softc, but inside an #if NBIO > 0 block. NBIO is set by "bio.h"
which was included in ami.c, but not in ami_pci.c which is what is
actually responsible for getting the softc allocated. because of this
the softc in the rest of the system was smaller than what ami.c needed,
so technically it was using unallocated memory. in krws case that
unallocated space was filled with garbage, hence his panic.

the moral of this story is do NOT put #if inside structs that are passed
between different source files. its too easy to have this kind of screwup
happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.146 2006/04/19 03:38:53 krw Exp $	*/
d733 1
a733 1
	u_int8_t status, ready;
a817 2
	ready = sc->sc_mbox->acc_cmplidl[0];

a819 13
#if 0
	/* FIXME */
	/* am I a scsi command? if so complete it */
	if (xs) {
		printf("sc ");
		if (!ami_done(sc, ready))
			status = 0;
		else
			status = 1; /* failed */
	} else /* need to clean up ccb ourselves */
		ami_put_ccb(ccb);
#endif

@


1.146
log
@Make sure sc_first_poll is initialized to 0 so sensor_task_thread
doesn't blow up on first call to ami_refresh(). There's probably a
better fix, but this stops the crashes while that fix is found.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.145 2006/04/18 18:31:04 marco Exp $	*/
a578 1
	sc->sc_first_poll = 0;
@


1.145
log
@Make output in sysctl pretier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.144 2006/04/18 04:15:44 marco Exp $	*/
d579 1
@


1.144
log
@Display logical disk status in sysctl.  Now one can use sensorsd to
monitor disks on ami.
Ex.: hw.sensors.0=sd2, logical disk, WARNING, drive, degraded

Requested deraadt@@ ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.143 2006/04/06 10:16:45 dlg Exp $	*/
d2457 3
a2459 2
			strlcpy(sc->sc_sens_ld[i].desc, "logical disk",
			    sizeof(sc->sc_sens_ld[i].desc));
@


1.143
log
@the synchronise cache path is unique in ami in that it uses two megaraid
commands to emulated one scsi command. i reuse the ccb and pushed it
along the scsi setup path twice. when we do this for asynchronous cache
syncs this happens with the timeout: timeout_set, timeout_add,
timeout_set, timeout_del.

from the looks of the timeout code the repeat of the timeout_set/add part
can do really interesting things with the linked list holding all the
timeouts.

this adds a timeout_del in the middle of the two set/adds so the lists
are kept sane.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.142 2006/04/06 04:16:35 dlg Exp $	*/
d71 1
d169 1
d578 3
d1016 1
d1034 5
d1129 1
d2440 55
@


1.142
log
@kudos to djm for finding an embarrassing bug. using the same variable
as a counter for both an inner and outer loop is not good(tm).

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.141 2006/04/05 14:07:24 dlg Exp $	*/
d1238 1
a1239 1
		timeout_del(&xs->stimeout);
@


1.141
log
@reintroduce ami_complete, a replacement for ami_poll that is built on top
of the async exec and done commands. ami_poll uses a special command id
that isnt needed for normal commands. on top of this we should drain the
runq before using ami_poll. using ami_complete means that we can poll with
commands still on the card.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.140 2006/04/03 01:53:04 marco Exp $	*/
d1043 1
a1043 1
	int i = 0, done = 0;
d1068 2
a1069 2
			for (i = 0; i < mbox.acc_nstat; i++) {
				int ready = mbox.acc_cmplidl[i];
@


1.140
log
@Move scsi_done back under splbio.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.139 2006/04/03 01:40:00 marco Exp $	*/
d132 1
d975 2
d978 1
a978 1
		ami_poll(sc, ccb);
d980 2
a981 3
	} 

	timeout_set(&xs->stimeout, ami_stimeout, ccb);
a982 1

d1040 61
a1670 1
	
@


1.139
log
@Since we have a run-queue now lets check it in the isr and get io onto
the card if there is any still pending.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.138 2006/04/03 01:35:06 marco Exp $	*/
d1133 1
a1134 2

	scsi_done(xs);
d1165 1
a1166 2

	scsi_done(xs);
d1184 1
a1185 2

		scsi_done(xs);
d1209 1
a1210 2

	scsi_done(xs);
@


1.138
log
@Silly dlg hz/500 isnt a whole lot.  Also removed busy-wait in
ami_quartz_exec.  This fixes interactivity issues that we saw when running
iogen.  This is possible due to the new run-queue model for io.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.137 2006/03/29 13:38:05 dlg Exp $	*/
d1609 5
@


1.137
log
@we never use what the ccb completion functions return, so make them all
return void instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.136 2006/03/29 13:31:15 dlg Exp $	*/
a636 7
	u_int32_t i;

	i = 0;
	while (sc->sc_mbox->acc_busy && (i < AMI_MAX_BUSYWAIT)) {
		delay(1);
		i++;
	}
d1010 1
a1010 1
			timeout_add(&sc->sc_run_tmo, hz/500);
@


1.136
log
@fix the sync_cache scsi command up so it can run asynchronously using the
callback bits for completions. also do the AMI_SYSFLUSH command as well
as AMI_FLUSH.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.135 2006/03/20 10:52:34 dlg Exp $	*/
d137 4
a140 4
int		ami_done_xs(struct ami_softc *, struct ami_ccb *);
int		ami_done_pt(struct ami_softc *, struct ami_ccb *);
int		ami_done_flush(struct ami_softc *, struct ami_ccb *);
int		ami_done_sysflush(struct ami_softc *, struct ami_ccb *);
d143 2
a144 2
int		ami_done_ioctl(struct ami_softc *, struct ami_ccb *);
int		ami_done_ccb(struct ami_softc *, struct ami_ccb *);
d1101 1
a1101 1
int
a1142 2

	return (0);
d1145 1
a1145 1
int
a1175 2

	return (0);
d1178 1
a1178 1
int
a1195 1
		return (0);
a1202 1
	return (0);
d1205 1
a1205 1
int
a1221 2

	return (0);
d1224 1
a1224 1
int
a1227 1
	return (0);
d1230 1
a1230 1
int
a1237 2

	return (0);
@


1.135
log
@remove kernel printfs that say "unable to allocate memory" just before
returning ENOMEM and the like. userland can say that for us while keeping
our dmesg clean.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.134 2006/03/20 10:49:53 dlg Exp $	*/
d139 2
d1183 50
d1445 1
a1445 1
		ccb->ccb_done = ami_done_ccb;
d1452 1
a1452 8
		s = splbio();
		error = ami_poll(sc, ccb);
		splx(s);
		if (error)
			xs->error = XS_DRIVER_STUFFUP;

		scsi_done(xs);
		return (COMPLETE);
@


1.134
log
@finer grained use of splbio in the ioctl paths. only use it when dealing
with the ccb queues rather than over the whole ioctl.

also get rid of the CMD_WAIT flag which is used to restrict the ioctl to
only one caller at a time. this is actually protecting from overuse of
ccbs for management tasks (like bioctl) by making sure the scsi paths
will always have their ccbs. replace the flag with a real lock so that
callers can sleep till the mgmt ccb is free, rather than returning EBUSY
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.133 2006/03/20 10:10:59 dlg Exp $	*/
d1813 1
a1813 2
	if (!p) {
		printf("%s: no memory for disk array\n", DEVNAME(sc));
a1814 1
	}
a1817 1
		printf("%s: no memory for disk list\n", DEVNAME(sc));
d1895 1
a1895 2
	if (!plist) {
		printf("%s: no memory for disk list\n", DEVNAME(sc));
a1896 1
	}
d1970 1
a1970 2
	if (!plist) {
		printf("%s: no memory for disk list\n", DEVNAME(sc));
a1971 1
	}
d2065 1
a2065 2
	if (!p) {
		printf("%s: no memory for raw interface\n", DEVNAME(sc));
a2066 1
	}
d2147 1
a2147 2
	if (!p) {
		printf("%s: no memory for raw interface\n", DEVNAME(sc));
a2148 1
	}
d2306 1
a2306 2
		if (!p) {
			printf("%s: no memory for setstate\n", DEVNAME(sc));
a2307 1
		}
@


1.133
log
@shrink the ccb even more. instead of having a "wakeup" member to say when
the ioctl paths can wake up, check the state of the ccb instead. when the
ccb becomes READY again then the command has completed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.132 2006/03/20 09:59:26 dlg Exp $	*/
d58 1
d565 3
a1604 1
	int s;
a1611 8
	s = splbio();
	if (sc->sc_flags & AMI_CMDWAIT) {
		splx(s);
		return (EBUSY);
	}

	sc->sc_flags |= AMI_CMDWAIT;

a1642 4
	sc->sc_flags &= ~AMI_CMDWAIT;

	splx(s);

d1654 3
d1658 1
d1660 5
a1664 2
	if (ccb == NULL)
		return (ENOMEM);
d1694 2
a1695 2
		ami_put_ccb(ccb);
		return (ENOMEM);
d1717 2
d1720 1
d1722 2
d1735 2
a1736 1
	int error = EINVAL;
d1738 3
d1742 5
a1746 2
	if (ccb == NULL)
		return (ENOMEM);
d1750 2
a1751 1
			ami_put_ccb(ccb);
a1767 4
		if (!idata) {
			ami_put_ccb(ccb);
			return (ENOMEM);
		}
d1783 4
a1786 3
	if (!(ccb->ccb_flags & AMI_CCB_F_ERR)) {
		if (buffer && size)
			memcpy(buffer, idata, size);
d1788 2
a1789 2
		error = 0;
	}
d1791 2
d1794 1
a1794 2
	if (am)
		ami_freemem(sc, am);
d1796 2
@


1.132
log
@remove the bits in the ccb for generalised handling of dmaable memory.

now that each code path that puts commands on the hardware has specific
completion routines, we dont have to deal with the memory magic in a
generic fashion.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.131 2006/03/20 09:46:28 dlg Exp $	*/
a187 1
	ccb->ccb_wakeup = 0;
a1178 1
	ccb->ccb_wakeup = 0;
a1179 1

a1667 1
	ccb->ccb_wakeup = 1;
d1702 1
a1702 1
	while (ccb->ccb_wakeup)
a1745 1
	ccb->ccb_wakeup = 1;
d1773 1
a1773 1
	while (ccb->ccb_wakeup)
@


1.131
log
@switch the mgmt ioctl path to use the ioctl completion function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.130 2006/03/20 09:34:37 dlg Exp $	*/
a188 1
	ccb->ccb_data = NULL;
d1191 3
a1193 21
	if (ccb->ccb_data != NULL) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize,
		    (ccb->ccb_dir == AMI_CCB_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

		bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
		    ccb->ccb_offset, sizeof(struct ami_ccbmem),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}

	if (ccb->ccb_wakeup) {
		ccb->ccb_wakeup = 0;
		wakeup(ccb);
	} else {
		s = splbio();
		ami_put_ccb(ccb);
		splx(s);
	}
@


1.130
log
@move the drv_inq ioctl path to its own completion routine. all the cleanup
of the dmammem is now done in the ioctl, the completion routing simply
wakes it up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.129 2006/03/20 09:12:05 dlg Exp $	*/
a1768 2
	ccb->ccb_data = NULL;
	ccb->ccb_done = ami_done_ccb;
d1770 1
a1796 1

@


1.129
log
@get rid of the CCB_READY check in ami_start, it is subtly broken and slows
things down. this path is easy to verify without this code so im just
dropping it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.128 2006/03/20 09:02:02 dlg Exp $	*/
d140 1
d142 1
d1179 9
d1684 1
d1691 1
a1691 4
	ccb->ccb_data = inqbuf;
	ccb->ccb_len = sizeof(struct scsi_inquiry_data);
	ccb->ccb_dir = AMI_CCB_IN;
	ccb->ccb_done = ami_done_ccb;
d1728 6
a1733 1
	ami_put_ccb(ccb);
d1735 6
a1740 2
	if (pt->apt_scsistat != 0x00)
		return (EIO);
d1742 1
a1742 2
	if ((inq->device & SID_TYPE) != T_DIRECT)
		return (EINVAL);
d1744 1
a1744 1
	return (0);
@


1.128
log
@the command queues are important so wrap them up in splbio
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.127 2006/03/20 08:59:42 dlg Exp $	*/
a991 8

	if (ccb->ccb_state != AMI_CCB_READY) {
		printf("%s: ccb %d not ready (%d)\n", DEVNAME(sc),
		    ccb->ccb_cmd.acc_id, ccb->ccb_state);
		ccb->ccb_flags |= AMI_CCB_F_ERR;
		ccb->ccb_done(sc, ccb);
		return;
	}
@


1.127
log
@shorten the setup of the xs timeout
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.126 2006/03/19 11:53:23 dlg Exp $	*/
d991 2
d1001 1
d1004 1
@


1.126
log
@this is a really large reworking of how ami works in terms of submitting
commands to the hardware and completing them.

previously the driver was very engineered toward moving io from the
logical disks scsi commands onto the hardware and off. as we built extra
functionality into the driver, this path grew more and more hairy as bits
were tacked on to cope.

this strips it back to dealing with getting the command onto the hardware
and off again. each path that submits commands now has to do all its work
before submitting the ccb, and supply a function for completing the ccb.
both the async and polled paths call the completion routines for commands
now. async commands that fail to get onto the hardware first go are stuck
on a queue and retried out of a timeout. previously this was only done for
scsi commands, now all paths take advantage of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.125 2006/03/18 04:44:52 dlg Exp $	*/
a974 2
	struct timeval tv;

d981 1
a981 5

	/* add 5sec for whacky done() loops */
	tv.tv_sec = 5 + xs->timeout / 1000;
	tv.tv_usec = 1000 * (xs->timeout % 1000);
	timeout_add(&xs->stimeout, tvtohz(&tv));
@


1.125
log
@scsi completions never go via the generic done path now. xs is always set
in the scis done path
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.124 2006/03/18 03:13:43 dlg Exp $	*/
d128 1
a128 3
void		ami_stimeout(void *);
int		ami_start(struct ami_softc *, struct ami_ccb *);
int 		ami_start_xs(struct ami_ccb *, int, int);
d130 1
d132 8
a140 1
int		ami_done_xs(struct ami_softc *, struct ami_ccb *);
d171 1
a171 1
	ccb = TAILQ_LAST(&sc->sc_free_ccb, ami_queue_head);
d173 1
a173 1
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ccb_link);
d189 3
a191 1
	TAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_link);
d321 4
a324 3
	TAILQ_INIT(&sc->sc_ccbq);
	TAILQ_INIT(&sc->sc_ccbdone);
	TAILQ_INIT(&sc->sc_free_ccb);
a338 1
		ccb->ccb_state = AMI_CCB_FREE;
d351 1
a351 1
		TAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_link);
d362 1
d379 1
d405 1
d414 1
d461 1
d475 1
d973 1
a973 1
ami_start_xs(struct ami_ccb *ccb, int flags, int wait)
d975 13
a987 2
	struct ami_softc *sc = ccb->ccb_sc;
	int error = 0;
d989 1
a989 4
	if (wait)
		error = ami_poll(sc, ccb);
	else
		error = ami_start(sc, ccb);
d991 1
a991 1
	return (error);
d994 1
a994 1
int
a996 4
	struct ami_iocmd *cmd = &ccb->ccb_cmd;
	struct scsi_xfer *xs = ccb->ccb_xs;
	int error;

d998 5
a1002 3
		printf("%s: ccb %d not ready <%d>\n", DEVNAME(sc),
		    cmd->acc_id, ccb->ccb_state);
		return (EINVAL);
d1005 5
a1009 2
	if (xs != NULL)
		timeout_set(&xs->stimeout, ami_stimeout, ccb);
d1011 6
a1016 4
	error = sc->sc_exec(sc, cmd);
	if (!error) {
		ccb->ccb_state = AMI_CCB_QUEUED;
		TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);
d1018 5
a1022 6
		if (xs) {
			struct timeval tv;
			/* add 5sec for whacky done() loops */
			tv.tv_sec = 5 + xs->timeout / 1000;
			tv.tv_usec = 1000 * (xs->timeout % 1000);
			timeout_add(&xs->stimeout, tvtohz(&tv));
d1025 3
a1027 1
		return (0);
d1029 1
a1029 25

	if (xs) {
		ccb->ccb_state = AMI_CCB_PREQUEUED;
		timeout_add(&xs->stimeout, 1);
		return (0);
	}

	/* error path */
	if (ccb->ccb_data) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize,
		    (ccb->ccb_dir == AMI_CCB_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

		bus_dmamap_sync(sc->sc_dmat,
		    AMIMEM_MAP(sc->sc_ccbmem_am),
		    ccb->ccb_offset, sizeof(struct ami_ccbmem),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}

	ami_put_ccb(ccb);

	return (error);
d1036 1
d1038 1
d1040 1
d1042 3
a1044 17
	if (ccb->ccb_data) {
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize,
		    (ccb->ccb_dir == AMI_CCB_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

		bus_dmamap_sync(sc->sc_dmat,
		    AMIMEM_MAP(sc->sc_ccbmem_am),
		    ccb->ccb_offset, sizeof(struct ami_ccbmem),
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
	}
	if (ccb->ccb_wakeup)
		ccb->ccb_wakeup = 0;
	else
		ami_put_ccb(ccb);
a1048 1
/* FIXME timeouts should be rethought */
a1053 1
	struct scsi_xfer *xs = ccb->ccb_xs;
a1054 1
	volatile struct ami_iocmd *mbox = sc->sc_mbox;
a1056 1
	s = splbio();
d1059 5
a1063 13
		if (mbox->acc_busy) {
			timeout_add(&xs->stimeout, 1);
			break;
		}

		AMI_DPRINTF(AMI_D_CMD, ("requeue(%d) ", cmd->acc_id));

		ccb->ccb_state = AMI_CCB_READY;
		if (ami_start(sc, ccb)) {
			AMI_DPRINTF(AMI_D_CMD, ("requeue(%d) again\n", cmd->acc_id));
			ccb->ccb_state = AMI_CCB_PREQUEUED;
			timeout_add(&xs->stimeout, 1);
		}
a1066 1
		/* XXX need to kill all cmds in the queue and reset the card */
d1068 4
a1071 15
		AMI_DPRINTF(AMI_D_CMD, ("timeout(%d) ", cmd->acc_id));
		if (xs->cmd->opcode != PREVENT_ALLOW &&
		    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
			bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize,
			    (xs->flags & SCSI_DATA_IN) ?
			    BUS_DMASYNC_POSTREAD :
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmamap);
		}
		TAILQ_REMOVE(&sc->sc_ccbq, ccb, ccb_link);
		ami_put_ccb(ccb);
		xs->error = XS_TIMEOUT;
		xs->flags |= ITSDONE;
		scsi_done(xs);
d1073 3
a1075 3
	case AMI_CCB_FREE:
	case AMI_CCB_READY:
		panic("ami_stimeout(%d) botch", cmd->acc_id);
d1077 2
a1078 1
	splx(s);
d1097 1
a1097 1
	TAILQ_REMOVE(&sc->sc_ccbq, ccb, ccb_link);
d1106 1
a1106 1
ami_done_xs(struct ami_softc *sc, struct ami_ccb *ccb)
d1109 3
d1127 15
d1146 24
d1173 8
a1247 1
	int error;
a1248 1
	char type;
d1281 1
a1281 4
	ccb->ccb_len  = xs->datalen;
	ccb->ccb_data = xs->data;
	ccb->ccb_dir = (xs->flags & SCSI_DATA_IN) ? AMI_CCB_IN : AMI_CCB_OUT;
	ccb->ccb_done = ami_done_xs;
d1305 1
a1305 28
	s = splbio();
	error = ami_start_xs(ccb, (xs->flags & SCSI_NOSLEEP) ?
	    BUS_DMA_NOWAIT : BUS_DMA_WAITOK, xs->flags & SCSI_POLL);
	splx(s);
	if (error) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return (COMPLETE);
	}

	if (xs->flags & SCSI_POLL) {
		if (xs->cmd->opcode == INQUIRY) {
			type = ((struct scsi_inquiry_data *)xs->data)->device
			    & SID_TYPE;

			if (!(type == T_PROCESSOR || type == T_ENCLOSURE))
				xs->error = XS_DRIVER_STUFFUP;
			else
				rsc->sc_proctarget = target; /* save target */
		}

		scsi_done(xs);
	}

	if (xs->flags & SCSI_POLL)
		return (COMPLETE);
	else
		return (SUCCESSFULLY_QUEUED);
a1519 3
	ccb->ccb_len  = xs->datalen;
	ccb->ccb_data = xs->data;
	ccb->ccb_dir = (xs->flags & SCSI_DATA_IN) ? AMI_CCB_IN : AMI_CCB_OUT;
d1569 1
a1569 14
	s = splbio();
	error = ami_start_xs(ccb, (xs->flags & SCSI_NOSLEEP) ?
	    BUS_DMA_NOWAIT : BUS_DMA_WAITOK, xs->flags & SCSI_POLL);
	splx(s);
	if (error) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return (COMPLETE);
	}

	if (xs->flags & SCSI_POLL)
		return (COMPLETE);
	else
		return (SUCCESSFULLY_QUEUED);
d1580 1
a1580 1
	if (TAILQ_EMPTY(&sc->sc_ccbq))
d1724 1
a1724 2
	if (ami_start(sc, ccb) != 0)
		return (EIO);
d1748 1
a1748 1
	int error = 0;
d1790 1
a1790 3
	if (ami_start(sc, ccb) == 0) {
		while (ccb->ccb_wakeup)
			tsleep(ccb, PRIBIO,"ami_mgmt", 0);
d1792 2
a1793 1
		ami_put_ccb(ccb);
d1795 1
a1795 2
		/* XXX how do commands fail? */
		
a1797 2
	} else
		error = EINVAL;
d1799 4
@


1.124
log
@use polling for the synchronise command while i move the xs setup and
completion stuff around.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.123 2006/03/18 02:28:29 dlg Exp $	*/
d1160 4
a1163 7
	if (xs) {
		timeout_del(&xs->stimeout);
		xs->resid = 0;
		xs->flags |= ITSDONE;
		AMI_DPRINTF(AMI_D_CMD, ("scsi_done(%d) ", idx));
		scsi_done(xs);
	}
a1170 1
	struct scsi_xfer *xs = ccb->ccb_xs;
a1192 8
	}

	if (xs) {
		timeout_del(&xs->stimeout);
		xs->resid = 0;
		xs->flags |= ITSDONE;
		AMI_DPRINTF(AMI_D_CMD, ("scsi_done(%d) ", idx));
		scsi_done(xs);
@


1.123
log
@rename ami_cmd to ami_start_xs
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.122 2006/03/17 14:18:39 dlg Exp $	*/
d1444 1
a1444 2
		error = ami_start_xs(ccb, (xs->flags & SCSI_NOSLEEP) ?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK, xs->flags & SCSI_POLL);
d1446 1
a1446 1
		if (error) {
a1447 3
			scsi_done(xs);
			return (COMPLETE);
		}
d1449 2
a1450 4
		if (xs->flags & SCSI_POLL)
			return (COMPLETE);
		else
			return (SUCCESSFULLY_QUEUED);
@


1.122
log
@create a completion path for scsi commands without the cruft for waking
up ioctl paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.121 2006/03/17 13:34:23 dlg Exp $	*/
a128 1
int 		ami_cmd(struct ami_ccb *, int, int);
d130 1
d959 1
a959 1
ami_cmd(struct ami_ccb *ccb, int flags, int wait)
d1305 1
a1305 1
	error = ami_cmd(ccb, (xs->flags & SCSI_NOSLEEP) ?
d1444 1
a1444 1
		error = ami_cmd(ccb, (xs->flags & SCSI_NOSLEEP) ?
d1605 1
a1605 1
	error = ami_cmd(ccb, (xs->flags & SCSI_NOSLEEP) ?
@


1.121
log
@split the completion path up. its now the responsibility of the the path
that sets the command up to say how its should be completed. this means
we dont have to complicate a generic handler to cope with all the different
setup paths. however, at the moment we're using the generic complicated
one :)
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.120 2006/03/17 10:49:12 dlg Exp $	*/
d134 1
d1138 34
d1280 1
a1280 1
	ccb->ccb_done = ami_done_ccb;
d1555 1
a1555 1
	ccb->ccb_done = ami_done_ccb;
@


1.120
log
@remove the last remnants of AMI_POLLING
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.119 2006/03/15 14:31:29 dlg Exp $	*/
d133 1
a1115 1
	struct scsi_xfer *xs = ccb->ccb_xs;
d1129 12
d1158 2
a1159 1
	} else
d1161 2
a1171 2
	splx(s);

d1245 1
d1401 1
d1520 1
d1705 1
d1777 1
@


1.119
log
@switch the ioctl paths to using ami_start instead of ami_cmd. now the only
things left using ami_cmd are the scsi paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.118 2006/03/15 13:51:04 dlg Exp $	*/
a343 2
	timeout_set(&sc->sc_poll_tmo, (void (*)(void *))ami_intr, sc);

a1593 7

#ifdef AMI_POLLING
	if (!TAILQ_EMPTY(&sc->sc_ccbq) && !timeout_pending(&sc->sc_poll_tmo)) {
		AMI_DPRINTF(AMI_D_INTR, ("tmo "));
		timeout_add(&sc->sc_poll_tmo, 2);
	}
#endif
@


1.118
log
@clean up ami_start and move the error handling for a failed command from
ami_cmd into ami_start.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.117 2006/03/15 12:38:56 dlg Exp $	*/
d1729 1
a1729 1
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 0) != 0)
d1795 1
a1795 1
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 0) == 0) {
@


1.117
log
@split the code in ami_cmd that does the polling commands out into a
function of its own. switch callers of ami_cmd that want polled commands
over to using ami_poll.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.116 2006/03/15 12:02:35 dlg Exp $	*/
d130 1
a130 1
int		ami_start(struct ami_ccb *, int);
a961 1
	bus_dmamap_t dmap = ccb->ccb_dmamap;
d966 2
a967 18
	else if ((error = ami_start(ccb, wait))) {
		AMI_DPRINTF(AMI_D_DMA, ("error=%d ", error));
		__asm __volatile(".globl _bpamierr\n_bpamierr:");
		if (ccb->ccb_data) {
			bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize,
			    (ccb->ccb_dir == AMI_CCB_IN) ?
			    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

			bus_dmamap_sync(sc->sc_dmat,
			    AMIMEM_MAP(sc->sc_ccbmem_am),
			    ccb->ccb_offset, sizeof(struct ami_ccbmem),
			    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmat, dmap);
		}
		ami_put_ccb(ccb);
	}
d973 1
a973 1
ami_start(struct ami_ccb *ccb, int wait)
a974 1
	struct ami_softc *sc = ccb->ccb_sc;
d977 1
a977 4
	volatile struct ami_iocmd *mbox = sc->sc_mbox;
	int i;

	AMI_DPRINTF(AMI_D_CMD, ("start(%d) ", cmd->acc_id));
d985 1
a985 1
	if (xs)
d988 4
a991 1
	if (wait && mbox->acc_busy) {
d993 7
a999 1
		for (i = 100000; i-- && mbox->acc_busy; DELAY(10));
d1001 1
a1001 4
		if (mbox->acc_busy) {
			AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
			return (EAGAIN);
		}
d1004 1
a1004 20
	AMI_DPRINTF(AMI_D_CMD, ("exec "));

	if (!(i = (sc->sc_exec)(sc, cmd))) {
		ccb->ccb_state = AMI_CCB_QUEUED;
		TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);
		if (!wait) {
#ifdef AMI_POLLING
			if (!timeout_pending(&sc->sc_poll_tmo))
				timeout_add(&sc->sc_poll_tmo, 1);
#endif
			if (xs) {
				struct timeval tv;
				/* add 5sec for whacky done() loops */
				tv.tv_sec = 5 + xs->timeout / 1000;
				tv.tv_usec = 1000 * (xs->timeout % 1000);
				timeout_add(&xs->stimeout, tvtohz(&tv));
			}
		}
	} else if (!wait && xs) {
		AMI_DPRINTF(AMI_D_CMD, ("2queue1(%d) ", cmd->acc_id));
d1010 18
a1027 1
	return (i);
d1080 1
a1080 1
		if (ami_start(ccb, 0)) {
@


1.116
log
@sc->sc_dev.dv_xname converted to DEVNAME(sc). makes things a little easier
for me to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.115 2006/03/14 15:03:11 dlg Exp $	*/
d131 1
d361 1
a361 1
		if (ami_cmd(ccb, BUS_DMA_NOWAIT, 1) == 0) {
d376 1
a376 1
			if (ami_cmd(ccb, BUS_DMA_NOWAIT, 1) == 0) {
d401 1
a401 1
			if (ami_cmd(ccb, BUS_DMA_NOWAIT, 1) != 0) {
d409 1
a409 1
				if (ami_cmd(ccb, BUS_DMA_NOWAIT, 1) != 0) {
d457 1
a457 1
		if (ami_cmd(ccb, BUS_DMA_NOWAIT, 1) != 0) {
d475 1
a475 1
			if (ami_cmd(ccb, BUS_DMA_NOWAIT, 1) != 0) {
d965 3
a967 26
	if (wait) {
		AMI_DPRINTF(AMI_D_DMA, ("waiting "));
		/* FIXME remove all wait out ami_start */
		error = sc->sc_poll(sc, &ccb->ccb_cmd);
#ifdef AMI_DEBUG
		if (error)
			AMI_DPRINTF(AMI_D_MISC, ("pf "));
#endif
		if (ccb->ccb_data) {
			bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize,
			    (ccb->ccb_dir == AMI_CCB_IN) ?
			    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);

			bus_dmamap_sync(sc->sc_dmat,
			    AMIMEM_MAP(sc->sc_ccbmem_am),
			    ccb->ccb_offset, sizeof(struct ami_ccbmem),
			    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);

			bus_dmamap_unload(sc->sc_dmat, dmap);
		}
		if (ccb->ccb_wakeup)
			ccb->ccb_wakeup = 0;
		else
			ami_put_ccb(ccb);
	} else if ((error = ami_start(ccb, wait))) {
d1045 28
@


1.115
log
@move the loading of the dmamaps for passthrough commands out of ami_cmd
and into a function of its own called ami_load_ptmem. sleep now, more
cleanup later.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.114 2006/03/14 13:33:23 dlg Exp $	*/
d155 2
d535 1
a535 2
	    sc->sc_fwver, sc->sc_biosver, sc->sc_memory,
	    sc->sc_dev.dv_xname,
d541 1
a541 2
	    sc->sc_fwver, sc->sc_biosver, sc->sc_memory,
	    sc->sc_dev.dv_xname,
d547 1
a547 1
		    "disk\n", sc->sc_dev.dv_xname);
d551 1
a551 2
		printf("%s: controller registration failed",
		    sc->sc_dev.dv_xname);
d565 1
a565 2
		printf("%s: no memory for raw interface\n",
		    sc->sc_dev.dv_xname);
d689 1
a689 1
		panic("%s: status 0xff from the firmware", sc->sc_dev.dv_xname);
d749 1
a749 1
		    sc->sc_dev.dv_xname);
d761 1
a761 2
		printf("%s: bad status, polling disabled\n",
		    sc->sc_dev.dv_xname);
d775 1
a775 1
		    sc->sc_dev.dv_xname);
d793 1
a793 1
		    sc->sc_dev.dv_xname);
d923 1
a923 1
		    sc->sc_dev.dv_xname);
d937 1
a937 1
		    sc->sc_dev.dv_xname);
d1023 2
a1024 2
		printf("%s: ccb %d not ready <%d>\n",
		    sc->sc_dev.dv_xname, cmd->acc_id, ccb->ccb_state);
d1100 1
a1100 2
		printf("%s: timeout ccb %d\n",
		    sc->sc_dev.dv_xname, cmd->acc_id);
d1135 1
a1135 1
		    sc->sc_dev.dv_xname, idx, ccb->ccb_state);
d1498 2
a1499 3
		printf("%s: out of bounds %u-%u >= %u\n",
		    sc->sc_dev.dv_xname, blockno, blockcnt,
		    sc->sc_hdr[target].hd_size);
d1642 1
a1642 1
	AMI_DPRINTF(AMI_D_IOCTL, ("%s: ioctl ", sc->sc_dev.dv_xname));
d1682 1
a1682 2
		AMI_DPRINTF(AMI_D_IOCTL, ("%s: invalid ioctl\n",
		    sc->sc_dev.dv_xname));
d1838 1
a1838 1
		printf("%s: no memory for disk array\n",sc->sc_dev.dv_xname);
d1844 1
a1844 1
		printf("%s: no memory for disk list\n",sc->sc_dev.dv_xname);
d1859 1
a1859 1
	strlcpy(bi->bi_dev, sc->sc_dev.dv_xname, sizeof(bi->bi_dev));
d1923 1
a1923 1
		printf("%s: no memory for disk list\n",sc->sc_dev.dv_xname);
d2000 1
a2000 1
		printf("%s: no memory for disk list\n",sc->sc_dev.dv_xname);
d2097 1
a2097 1
		printf("%s: no memory for raw interface\n",sc->sc_dev.dv_xname);
d2181 1
a2181 1
		printf("%s: no memory for raw interface\n",sc->sc_dev.dv_xname);
d2307 1
a2307 1
		    sc->sc_dev.dv_xname, ba->ba_opcode));
d2342 1
a2342 2
			printf("%s: no memory for setstate\n",
			    sc->sc_dev.dv_xname);
d2362 1
a2362 1
		    , sc->sc_dev.dv_xname, bs->bs_status));
@


1.114
log
@move the loading of the dma maps for logical disk reads and writes from
ami_cmd up into ami_scsi_cmd. this simplifies ami_cmd somewhat and moves
more stuff out from under splbio. theres more to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.113 2006/03/14 11:57:21 dlg Exp $	*/
d135 3
a963 1
	struct ami_iocmd *cmd = &ccb->ccb_cmd;
d965 1
a965 44
	int error = 0, i;

	if (cmd->acc_cmd == AMI_PASSTHRU && ccb->ccb_data) {
		bus_dma_segment_t *sgd;

		error = bus_dmamap_load(sc->sc_dmat, dmap, ccb->ccb_data,
		    ccb->ccb_len, NULL, flags);
		if (error) {
			if (error == EFBIG)
				printf("more than %d dma segs\n",
				    AMI_MAXOFFSETS);
			else
				printf("error %d loading dma map\n", error);

			ami_put_ccb(ccb);
			return (error);
		}

		cmd->acc_passthru.apt_data = ccb->ccb_ptpa;

		sgd = dmap->dm_segs;
		if(dmap->dm_nsegs > 1) {
			struct ami_sgent *sgl = ccb->ccb_sglist;

			ccb->ccb_pt->apt_nsge = dmap->dm_nsegs;
			ccb->ccb_pt->apt_data = ccb->ccb_sglistpa;

			for (i = 0; i < dmap->dm_nsegs; i++, sgd++) {
				sgl[i].asg_addr = htole32(sgd->ds_addr);
				sgl[i].asg_len  = htole32(sgd->ds_len);
			}
		} else {
			ccb->ccb_pt->apt_nsge = 0;
			ccb->ccb_pt->apt_data = htole32(sgd->ds_addr);
		}

		bus_dmamap_sync(sc->sc_dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
		    ccb->ccb_offset, sizeof(struct ami_ccbmem),
		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

		bus_dmamap_sync(sc->sc_dmat, dmap, 0, dmap->dm_mapsize,
		    (ccb->ccb_dir == AMI_CCB_IN) ?
		    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
	}
a1210 1
	struct ami_iocmd *cmd;
d1249 3
d1262 9
a1270 2
	cmd = &ccb->ccb_cmd;
	cmd->acc_cmd = AMI_PASSTHRU;
d1303 48
d1717 1
a1719 1

d1738 6
@


1.113
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.112 2006/03/14 11:44:08 dlg Exp $	*/
d961 1
d965 1
a965 2
	if (ccb->ccb_data) {
		struct ami_iocmd *cmd = &ccb->ccb_cmd;
d981 1
a981 2
		if (cmd->acc_cmd == AMI_PASSTHRU)
			cmd->acc_passthru.apt_data = ccb->ccb_ptpa;
a983 4
		AMI_DPRINTF(AMI_D_DMA, ("data=%p/%u<0x%lx/%u",
		    ccb->ccb_data, ccb->ccb_len,
		    sgd->ds_addr, sgd->ds_len));

d987 2
a988 7
			if (cmd->acc_cmd == AMI_PASSTHRU) {
				ccb->ccb_pt->apt_nsge = dmap->dm_nsegs;
				ccb->ccb_pt->apt_data = ccb->ccb_sglistpa;
			} else {
				cmd->acc_mbox.amb_nsge = dmap->dm_nsegs;
				cmd->acc_mbox.amb_data = ccb->ccb_sglistpa;
			}
a992 5
#ifdef AMI_DEBUG
				if (i)
					AMI_DPRINTF(AMI_D_DMA, (",0x%lx/%u",
					    sgd->ds_addr, sgd->ds_len));
#endif
d995 2
a996 7
			if (cmd->acc_cmd == AMI_PASSTHRU) {
				ccb->ccb_pt->apt_nsge = 0;
				ccb->ccb_pt->apt_data = htole32(sgd->ds_addr);
			} else {
				cmd->acc_mbox.amb_nsge = 0;
				cmd->acc_mbox.amb_data = htole32(sgd->ds_addr);
			}
a997 1
		AMI_DPRINTF(AMI_D_DMA, ("> "));
d1006 1
a1006 2
	} else
		ccb->ccb_cmd.acc_mbox.amb_nsge = 0;
d1299 1
d1349 1
d1352 1
d1504 2
a1505 1
	ccb->ccb_len = xs->datalen;
a1506 1
	ccb->ccb_data = xs->data;
d1513 41
a1553 1
	cmd->acc_mbox.amb_data = 0;
d1710 1
@


1.112
log
@shuffle the switch statement around in scsi_cmd. do the io commands
outside the switch so i have some more room to put ugly code in there.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.111 2006/03/13 22:11:23 brad Exp $	*/
d1444 1
a1444 1
		bzero(&sd, sizeof sd);
d1450 1
a1450 1
		ami_copy_internal_data(xs, &sd, sizeof sd);
d1456 1
a1456 1
		bzero(&inq, sizeof inq);
d1462 5
a1466 5
		strlcpy(inq.vendor, "AMI    ", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Host drive  #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
		ami_copy_internal_data(xs, &inq, sizeof inq);
d1472 1
a1472 1
		bzero(&rcd, sizeof rcd);
d1475 1
a1475 1
		ami_copy_internal_data(xs, &rcd, sizeof rcd);
@


1.111
log
@make the dmseg printing look a little nicer.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.110 2006/03/13 12:08:40 dlg Exp $	*/
d1389 39
a1432 1

d1437 1
d1440 1
a1440 1
		break;
d1451 2
a1452 1
		break;
d1467 2
a1468 1
		break;
d1476 2
a1477 1
		break;
d1479 5
a1483 2
	case PREVENT_ALLOW:
		AMI_DPRINTF(AMI_D_CMD, ("PREVENT/ALLOW "));
d1485 1
d1487 9
a1495 65
	case SYNCHRONIZE_CACHE:
		AMI_DPRINTF(AMI_D_CMD, ("SYNCHRONIZE CACHE "));

		s = splbio();
		ccb = ami_get_ccb(sc);
		splx(s);
		if (ccb == NULL) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return (COMPLETE);
		}

		ccb->ccb_xs = xs;
		if (xs->timeout < 30000)
			xs->timeout = 30000;	/* at least 30sec */

		cmd = &ccb->ccb_cmd;
		cmd->acc_cmd = AMI_FLUSH;

		s = splbio();
		error = ami_cmd(ccb, (xs->flags & SCSI_NOSLEEP) ?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK, xs->flags & SCSI_POLL);
		splx(s);
		if (error) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return (COMPLETE);
		}

		if (xs->flags & SCSI_POLL)
			return (COMPLETE);
		else
			return (SUCCESSFULLY_QUEUED);

	case READ_COMMAND:
		if (!error) {
			AMI_DPRINTF(AMI_D_CMD, ("READ "));
			error++;
		}
	case READ_BIG:
		if (!error) {
			AMI_DPRINTF(AMI_D_CMD, ("READ BIG "));
			error++;
		}
	case WRITE_COMMAND:
		if (!error) {
			AMI_DPRINTF(AMI_D_CMD, ("WRITE "));
			error++;
		}
	case WRITE_BIG:
		if (!error) {
			AMI_DPRINTF(AMI_D_CMD, ("WRITE BIG "));
			error++;
		}

		/* A read or write operation. */
		if (xs->cmdlen == 6) {
			rw = (struct scsi_rw *)xs->cmd;
			blockno = _3btol(rw->addr) &
			    (SRW_TOPADDR << 16 | 0xffff);
			blockcnt = rw->length ? rw->length : 0x100;
		} else {
			rwb = (struct scsi_rw_big *)xs->cmd;
			blockno = _4btol(rwb->addr);
			blockcnt = _2btol(rwb->length);
d1497 3
a1499 4
			/* TODO: reflect DPO & FUA flags */
			if (xs->cmd->opcode == WRITE_BIG &&
			    rwb->byte2 & 0x18)
				flags |= 0;
d1501 1
a1501 1
		}
d1503 9
a1511 9
		if (blockno >= sc->sc_hdr[target].hd_size ||
		    blockno + blockcnt > sc->sc_hdr[target].hd_size) {
			printf("%s: out of bounds %u-%u >= %u\n",
			    sc->sc_dev.dv_xname, blockno, blockcnt,
			    sc->sc_hdr[target].hd_size);
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return (COMPLETE);
		}
d1513 8
a1520 8
		s = splbio();
		ccb = ami_get_ccb(sc);
		splx(s);
		if (ccb == NULL) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return (COMPLETE);
		}
d1522 4
a1525 19
		ccb->ccb_xs = xs;
		ccb->ccb_len  = xs->datalen;
		ccb->ccb_dir  = (xs->flags & SCSI_DATA_IN) ?
		    AMI_CCB_IN : AMI_CCB_OUT;
		ccb->ccb_data = xs->data;
		cmd = &ccb->ccb_cmd;
		cmd->acc_mbox.amb_nsect = htole16(blockcnt);
		cmd->acc_mbox.amb_lba = htole32(blockno);
		cmd->acc_mbox.amb_ldn = target;
		cmd->acc_mbox.amb_data = 0;

		switch (xs->cmd->opcode) {
		case READ_COMMAND: case READ_BIG:
			cmd->acc_cmd = AMI_READ;
			break;
		case WRITE_COMMAND: case WRITE_BIG:
			cmd->acc_cmd = AMI_WRITE;
			break;
		}
d1527 6
a1532 9
		s = splbio();
		error = ami_cmd(ccb, (xs->flags & SCSI_NOSLEEP) ?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK, xs->flags & SCSI_POLL);
		splx(s);
		if (error) {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return (COMPLETE);
		}
d1534 5
a1538 8
		if (xs->flags & SCSI_POLL)
			return (COMPLETE);
		else
			return (SUCCESSFULLY_QUEUED);

	default:
		AMI_DPRINTF(AMI_D_CMD, ("unsupported scsi command %#x tgt %d ",
		    xs->cmd->opcode, target));
d1540 2
d1544 4
a1547 1
	return (COMPLETE);
@


1.110
log
@finner grained use of splbio in scsi_raw_cmd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.109 2006/03/13 11:49:52 dlg Exp $	*/
d527 1
a527 1
	printf(": FW %s, BIOS v%s, %dMB RAM\n"
d535 1
a535 1
	printf(": FW %s, BIOS v%s, %dMB RAM\n"
@


1.109
log
@finer use of splbio in scsi_cmd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.108 2006/03/13 11:11:55 dlg Exp $	*/
a1280 2
	s = splbio();

a1292 1
		splx(s);
d1298 4
a1301 1
	if ((ccb = ami_get_ccb(sc)) == NULL) {
a1303 1
		splx(s);
d1325 5
a1329 2
	if ((error = ami_cmd(ccb, ((xs->flags & SCSI_NOSLEEP) ?
	    BUS_DMA_NOWAIT : BUS_DMA_WAITOK), xs->flags & SCSI_POLL))) {
a1331 1
		splx(s);
a1348 1
	splx(s);
@


1.108
log
@split the io and synchronise paths for scsi commands going to the logical
disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.107 2006/01/29 00:48:19 krw Exp $	*/
a1374 1
	s = splbio();
a1381 1
		splx(s);
a1438 1
		splx(s);
d1444 1
d1446 1
a1449 1
			splx(s);
d1460 5
a1464 2
		if (ami_cmd(ccb, (xs->flags & SCSI_NOSLEEP) ?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK, xs->flags & SCSI_POLL)) {
a1466 1
			splx(s);
a1469 1
		splx(s);
a1520 1
			splx(s);
d1524 1
d1526 1
a1529 1
			splx(s);
d1553 5
a1557 2
		if (ami_cmd(ccb, (xs->flags & SCSI_NOSLEEP) ?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK, xs->flags & SCSI_POLL)) {
a1559 1
			splx(s);
a1562 1
		splx(s);
a1573 1
	splx(s);
@


1.107
log
@Don't ask bus_dmamem_alloc() for zero bytes.  'bioctl -H x:y amiz' no
longer triggers a panic.

ok marco@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.106 2005/12/21 12:26:24 dlg Exp $	*/
d1370 1
a1370 1
	int error, flags;
d1446 30
a1475 1
		error++;
d1497 27
a1523 27
		flags = xs->flags;
		if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
			/* A read or write operation. */
			if (xs->cmdlen == 6) {
				rw = (struct scsi_rw *)xs->cmd;
				blockno = _3btol(rw->addr) &
				    (SRW_TOPADDR << 16 | 0xffff);
				blockcnt = rw->length ? rw->length : 0x100;
			} else {
				rwb = (struct scsi_rw_big *)xs->cmd;
				blockno = _4btol(rwb->addr);
				blockcnt = _2btol(rwb->length);
				/* TODO: reflect DPO & FUA flags */
				if (xs->cmd->opcode == WRITE_BIG &&
				    rwb->byte2 & 0x18)
					flags |= 0;
			}
			if (blockno >= sc->sc_hdr[target].hd_size ||
			    blockno + blockcnt > sc->sc_hdr[target].hd_size) {
				printf("%s: out of bounds %u-%u >= %u\n",
				    sc->sc_dev.dv_xname, blockno, blockcnt,
				    sc->sc_hdr[target].hd_size);
				xs->error = XS_DRIVER_STUFFUP;
				scsi_done(xs);
				splx(s);
				return (COMPLETE);
			}
d1526 2
a1527 2
		if ((ccb = ami_get_ccb(sc)) == NULL) {
			AMI_DPRINTF(AMI_D_CMD, ("no more ccbs "));
a1530 1
		__asm __volatile(".globl _bpamiccb\n_bpamiccb:");
a1545 5
		case SYNCHRONIZE_CACHE:
			cmd->acc_cmd = AMI_FLUSH;
			if (xs->timeout < 30000)
				xs->timeout = 30000;	/* at least 30sec */
			break;
d1554 6
a1559 14
		if ((error = ami_cmd(ccb, ((flags & SCSI_NOSLEEP)?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK), flags & SCSI_POLL))) {

			AMI_DPRINTF(AMI_D_CMD, ("failed %p ", xs));
		__asm __volatile(".globl _bpamifail\n_bpamifail:");
			if (flags & SCSI_POLL) {
				splx(s);
				return (TRY_AGAIN_LATER);
			} else {
				xs->error = XS_DRIVER_STUFFUP;
				scsi_done(xs);
				splx(s);
				return (COMPLETE);
			}
d1563 1
a1563 1
		if (flags & SCSI_POLL)
@


1.106
log
@shrink a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.105 2005/12/13 12:13:58 dlg Exp $	*/
d1738 2
a1739 2
	struct ami_mem *am;
	char *idata;
d1746 6
a1751 3
	if ((am = ami_allocmem(sc, size)) == NULL) {
		ami_put_ccb(ccb);
		return (ENOMEM);
a1752 1
	idata = AMIMEM_KVA(am);
d1766 4
d1779 1
a1779 1
	cmd->acc_io.aio_data = htole32(AMIMEM_DVA(am));
d1789 1
a1789 1
		if (buffer)
d1794 2
a1795 1
	ami_freemem(sc, am);
@


1.105
log
@use consistent naming for members of the softc struct
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.104 2005/12/11 03:32:07 dlg Exp $	*/
d121 2
a122 4
void		ami_write_inbound_db(struct ami_softc *, u_int32_t);
void		ami_write_outbound_db(struct ami_softc *, u_int32_t);
u_int32_t	ami_read_inbound_db(struct ami_softc *);
u_int32_t	ami_read_outbound_db(struct ami_softc *);
a177 10
void
ami_write_inbound_db(struct ami_softc *sc, u_int32_t v)
{
	AMI_DPRINTF(AMI_D_CMD, ("awi %x ", v));

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, AMI_QIDB, v);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_WRITE);
}

d179 1
a179 1
ami_read_inbound_db(struct ami_softc *sc)
d183 3
a185 4
	bus_space_barrier(sc->sc_iot, sc->sc_ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_READ);
	rv = bus_space_read_4(sc->sc_iot, sc->sc_ioh, AMI_QIDB);
	AMI_DPRINTF(AMI_D_CMD, ("ari %x ", rv));
d187 1
d192 1
a192 1
ami_write_outbound_db(struct ami_softc *sc, u_int32_t v)
d194 1
a194 6
	AMI_DPRINTF(AMI_D_CMD, ("awo %x ", v));

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, AMI_QODB, v);
	bus_space_barrier(sc->sc_iot, sc->sc_ioh,
	    AMI_QODB, 4, BUS_SPACE_BARRIER_WRITE);
}
d196 3
a198 11
u_int32_t
ami_read_outbound_db(struct ami_softc *sc)
{
	u_int32_t rv;

	bus_space_barrier(sc->sc_iot, sc->sc_ioh,
	    AMI_QODB, 4, BUS_SPACE_BARRIER_READ);
	rv = bus_space_read_4(sc->sc_iot, sc->sc_ioh, AMI_QODB);
	AMI_DPRINTF(AMI_D_CMD, ("aro %x ", rv));

	return (rv);
d607 1
a607 1
	ami_write_inbound_db(sc, 0);
d615 1
a615 1
	u_int32_t qidb, i;
d635 1
a635 2
	qidb = sc->sc_mbox_pa | htole32(AMI_QIDB_EXEC);
	ami_write_inbound_db(sc, qidb);
d643 1
a643 1
	u_int32_t qdb, i, n;
d647 1
a647 2
	qdb = ami_read_outbound_db(sc);
	if (qdb != AMI_QODB_READY)
d650 1
a650 1
	ami_write_outbound_db(sc, AMI_QODB_READY);
d676 1
a676 2
		while ((completed[n] = sc->sc_mbox->acc_cmplidl[n]) ==
		    0xff) {
d702 1
a702 1
	ami_write_inbound_db(sc, AMI_QIDB_ACK);
d711 1
a711 1
	u_int32_t qidb, i;
d740 1
a740 2
	qidb = sc->sc_mbox_pa | htole32(AMI_QIDB_EXEC);
	ami_write_inbound_db(sc, qidb);
d784 1
a784 2
	qidb = sc->sc_mbox_pa | htole32(AMI_QIDB_ACK);
	ami_write_inbound_db(sc, qidb);
d786 1
a786 1
	while((ami_read_inbound_db(sc) & AMI_QIDB_ACK) &&
@


1.104
log
@cleanup some knr to ansi i missed, and some extra whitespace i accidentally
snuck in.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.103 2005/12/10 12:03:23 dlg Exp $	*/
d185 2
a186 2
	bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, v);
	bus_space_barrier(sc->iot, sc->ioh,
d195 1
a195 1
	bus_space_barrier(sc->iot, sc->ioh,
d197 1
a197 1
	rv = bus_space_read_4(sc->iot, sc->ioh, AMI_QIDB);
d208 2
a209 2
	bus_space_write_4(sc->iot, sc->ioh, AMI_QODB, v);
	bus_space_barrier(sc->iot, sc->ioh,
d218 1
a218 1
	bus_space_barrier(sc->iot, sc->ioh,
d220 1
a220 1
	rv = bus_space_read_4(sc->iot, sc->ioh, AMI_QODB);
d239 1
a239 1
	if (bus_dmamap_create(sc->dmat, size, 1, size, 0,
d243 1
a243 1
	if (bus_dmamem_alloc(sc->dmat, size, PAGE_SIZE, 0, &am->am_seg, 1,
d247 1
a247 1
	if (bus_dmamem_map(sc->dmat, &am->am_seg, nsegs, size, &am->am_kva,
d251 1
a251 1
	if (bus_dmamap_load(sc->dmat, am->am_map, am->am_kva, size, NULL,
d259 1
a259 1
	bus_dmamem_unmap(sc->dmat, am->am_kva, size);
d261 1
a261 1
	bus_dmamem_free(sc->dmat, &am->am_seg, 1);
d263 1
a263 1
	bus_dmamap_destroy(sc->dmat, am->am_map);
d273 4
a276 4
	bus_dmamap_unload(sc->dmat, am->am_map);
	bus_dmamem_unmap(sc->dmat, am->am_kva, am->am_size);
	bus_dmamem_free(sc->dmat, &am->am_seg, 1);
	bus_dmamap_destroy(sc->dmat, am->am_map);
d338 3
a340 3
		error = bus_dmamap_create(sc->dmat, AMI_MAXFER, AMI_MAXOFFSETS,
		    AMI_MAXFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
		    &ccb->ccb_dmamap);
d618 1
a618 1
			bus_dmamap_destroy(sc->dmat, ccb->ccb_dmamap);
d653 1
a653 1
	bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
d687 1
a687 1
		bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
d694 1
a694 1
	bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
d701 1
a701 1
		bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
d710 1
a710 1
		bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
d721 1
a721 1
	bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_mbox_am), 0, 16,
d756 1
a756 1
	bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_mbox_am), 0, 16,
d854 1
a854 1
	bus_space_write_4(sc->iot, sc->ioh, AMI_SMBADDR, a);
d856 1
a856 1
	bus_space_write_1(sc->iot, sc->ioh, AMI_SMBENA, 0);
d858 3
a860 3
	bus_space_write_1(sc->iot, sc->ioh, AMI_SCMD, AMI_SCMD_ACK);
	bus_space_write_1(sc->iot, sc->ioh, AMI_SIEM, AMI_SEIM_ENA |
	    bus_space_read_1(sc->iot, sc->ioh, AMI_SIEM));
d868 2
a869 1
	if (bus_space_read_1(sc->iot, sc->ioh, AMI_SMBSTAT) & AMI_SMBST_BUSY) {
d879 1
a879 1
	bus_space_write_1(sc->iot, sc->ioh, AMI_SCMD, AMI_SCMD_EXEC);
d893 2
a894 1
	if (bus_space_read_1(sc->iot, sc->ioh, AMI_SMBSTAT) & AMI_SMBST_BUSY)
d897 1
a897 1
	stat = bus_space_read_1(sc->iot, sc->ioh, AMI_ISTAT);
d899 1
a899 1
		bus_space_write_1(sc->iot, sc->ioh, AMI_ISTAT, stat);
d904 2
a905 1
		bus_space_write_1(sc->iot, sc->ioh, AMI_SCMD, AMI_SCMD_ACK);
d924 1
a924 1
		if (!(bus_space_read_1(sc->iot, sc->ioh, AMI_SMBSTAT) &
d935 1
a935 1
	bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_mbox_am), 0, 16,
d942 1
a942 1
	bus_space_write_1(sc->iot, sc->ioh, AMI_SCMD, AMI_SCMD_EXEC);
d946 1
a946 1
		if (!(bus_space_read_1(sc->iot, sc->ioh, AMI_SMBSTAT) &
d960 1
a960 1
		status = bus_space_read_1(sc->iot, sc->ioh, AMI_ISTAT);
d973 1
a973 1
	bus_space_write_1(sc->iot, sc->ioh, AMI_ISTAT, status);
d976 1
a976 1
	bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_mbox_am), 0,
d982 1
a982 1
	bus_space_write_1(sc->iot, sc->ioh, AMI_SCMD, AMI_SCMD_ACK);
d998 1
a998 1
		error = bus_dmamap_load(sc->dmat, dmap, ccb->ccb_data,
d1050 1
a1050 1
		bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
d1054 1
a1054 1
		bus_dmamap_sync(sc->dmat, dmap, 0, dmap->dm_mapsize,
d1069 1
a1069 1
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
d1074 2
a1075 1
			bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
d1079 1
a1079 1
			bus_dmamap_unload(sc->dmat, dmap);
d1089 1
a1089 1
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
d1094 2
a1095 1
			bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
d1099 1
a1099 1
			bus_dmamap_unload(sc->dmat, dmap);
d1201 1
a1201 1
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
d1206 1
a1206 1
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
d1241 1
a1241 1
		bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
d1246 1
a1246 1
		bus_dmamap_sync(sc->dmat, AMIMEM_MAP(sc->sc_ccbmem_am),
d1250 1
a1250 1
		bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
@


1.103
log
@another go at cleaning up bus_dma usage.

when you're using the bus dma api like we are, there are two
bus_dma_segment_t's involved, one for the pa stuff and one for the dva
stuff. we set this up ok in ami_allocmem, but then we forget half of it
when we return from that function. even worse, we assume theyre the same
thing in ami_freemem.

this diff fixes that by wrapping all the dma bits into a struct (called
struct ami_mem) and providing a few macros for accessing the useful parts
of it. we just pass this struct around now instead of having to handle all
the busdma bits in every function.

ok marco@@ jason@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.102 2005/12/09 07:49:25 dlg Exp $	*/
a279 2


d1642 1
a1642 4
ami_ioctl(dev, cmd, addr)
	struct device *dev;
	u_long cmd;
	caddr_t addr;
@


1.102
log
@back out 1.97. it was causing a freeze on boot with an older card. problem
found and cause narrowed down by jrrs.

it looks like we're trying to submit a command during attach to be
completed by polling. however it must be generating an interrupt for the
command, which completes out of the interrupt handler behind the scenes
of our polling. we just seem to sit there forever as a consequence.

this is a bandaid over a real fix, but it'll do until i can talk marco into
fixing it properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.96 2005/11/23 21:36:18 dlg Exp $	*/
d128 2
a129 4
void		*ami_allocmem(bus_dma_tag_t, bus_dmamap_t *, size_t, size_t,
		    const char *);
void		ami_freemem(caddr_t, bus_dma_tag_t, bus_dmamap_t *, size_t,
		    size_t, const char *);
d226 8
a233 13
void *
ami_allocmem(bus_dma_tag_t dmat, bus_dmamap_t *map, size_t isize, size_t nent,
    const char *iname)
{
	bus_dma_segment_t segp;
	size_t total = isize * nent;
	caddr_t p;
	int error, rseg;

	/* XXX this is because we might have no dmamem_load_raw */
	if ((error = bus_dmamap_create(dmat, total, 1,
	    total, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, map))) {
		printf(": cannot create %s dmamap (%d)\n", iname, error);
a234 1
	}
d236 9
a244 4
	if ((error = bus_dmamem_alloc(dmat, total, PAGE_SIZE, 0, &segp, 1,
	    &rseg, BUS_DMA_NOWAIT))) {
		printf(": cannot allocate %s%s (%d)\n",
		    iname, nent==1? "": "s", error);
a245 1
	}
d247 2
a248 4
	if ((error = bus_dmamem_map(dmat, &segp, rseg, total, &p,
	    BUS_DMA_NOWAIT))) {
		printf(": cannot map %s%s (%d)\n",
		    iname, nent==1? "": "s", error);
a249 1
	}
d251 2
a252 3
	if ((error = bus_dmamap_load(dmat, *map, p, total, NULL,
	    BUS_DMA_NOWAIT))) {
		printf(": cannot load %s dma map (%d)\n", iname, error);
a253 3
	}

	bzero(p, total);
d255 2
a256 1
	return (p);
d259 1
a259 1
	bus_dmamem_unmap(dmat, p, total);
d261 1
a261 1
	bus_dmamem_free(dmat, &segp, 1);
d263 3
a265 1
	bus_dmamap_destroy(dmat, *map);
d271 1
a271 2
ami_freemem(caddr_t p, bus_dma_tag_t dmat, bus_dmamap_t *map,
     size_t isize, size_t nent, const char *iname)
d273 7
a279 2
	bus_dma_segment_t segp = (*map)->dm_segs[0];
	size_t total = isize * nent;
a280 6
	bus_dmamap_unload(dmat, *map);
	bus_dmamem_unmap(dmat, p, total);
	bus_dmamem_free(dmat, &segp, 1);
	bus_dmamap_destroy(dmat, *map);
	*map = NULL;
}
d303 2
a304 2
	struct ami_ccbmem *mem;
	bus_dmamap_t idatamap;
a305 1
	void	*idata;
d309 3
a311 1
	if (!(idata = ami_allocmem(sc->dmat, &idatamap, NBPG, 1, "init data")))
d313 1
d315 3
a317 3
	sc->sc_mbox = ami_allocmem(sc->dmat, &sc->sc_mbox_map,
	    sizeof(struct ami_iocmd), 1, "mbox");
	if (!sc->sc_mbox)
d319 3
a321 2

	sc->sc_mbox_pa = htole32(sc->sc_mbox_map->dm_segs[0].ds_addr);
d324 4
a327 3
	sc->sc_ccbmem = ami_allocmem(sc->dmat, &sc->sc_ccbmap,
	    sizeof(struct ami_ccbmem), AMI_MAXCMDS, "ccb dmamem");
	if (!sc->sc_ccbmem)
d329 2
d338 1
a338 1
		mem = &sc->sc_ccbmem[i];
d355 1
a355 1
		ccb->ccb_ptpa = htole32(sc->sc_ccbmap->dm_segs[0].ds_addr +
d359 1
a359 1
		ccb->ccb_sglistpa = htole32(sc->sc_ccbmap->dm_segs[0].ds_addr +
d369 1
a369 1
		paddr_t	pa = htole32(idatamap->dm_segs[0].ds_addr);
d383 2
a384 2
			struct ami_fc_einquiry *einq = idata;
			struct ami_fc_prodinfo *pi = idata;
d413 1
a413 1
			struct ami_inquiry *inq = idata;
d492 1
a492 1
			pp = idata;
d530 1
a530 1
	ami_freemem(idata, sc->dmat, &idatamap, NBPG, 1, "init data");
d622 1
a622 3
	ami_freemem((caddr_t)sc->sc_ccbmem, sc->dmat, &sc->sc_ccbmap,
	    sizeof(struct ami_ccbmem), AMI_MAXCMDS,
	    "ccb dmamem");
d624 1
a624 2
	ami_freemem((caddr_t)sc->sc_mbox, sc->dmat, &sc->sc_mbox_map,
	    sizeof(struct ami_iocmd), 1, "mbox");
d626 1
a626 1
	ami_freemem(idata, sc->dmat, &idatamap, NBPG, 1, "init data");
d655 2
a656 2
	bus_dmamap_sync(sc->dmat, sc->sc_mbox_map, 0, sizeof(struct ami_iocmd),
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
d689 1
a689 1
		bus_dmamap_sync(sc->dmat, sc->sc_mbox_map, 0,
d696 1
a696 1
	bus_dmamap_sync(sc->dmat, sc->sc_mbox_map, 0,
d703 1
a703 1
		bus_dmamap_sync(sc->dmat, sc->sc_mbox_map, 0,
d712 1
a712 1
		bus_dmamap_sync(sc->dmat, sc->sc_mbox_map, 0,
d723 1
a723 1
	bus_dmamap_sync(sc->dmat, sc->sc_mbox_map, 0, 16,
d758 1
a758 1
	bus_dmamap_sync(sc->dmat, sc->sc_mbox_map, 0, 16,
d934 1
a934 1
	bus_dmamap_sync(sc->dmat, sc->sc_mbox_map, 0, 16,
d975 2
a976 2
	bus_dmamap_sync(sc->dmat, sc->sc_mbox_map, 0, sizeof(struct ami_iocmd),
	    BUS_DMASYNC_PREREAD);
d1049 1
a1049 1
		bus_dmamap_sync(sc->dmat, sc->sc_ccbmap,
d1073 1
a1073 1
			bus_dmamap_sync(sc->dmat, sc->sc_ccbmap,
d1092 1
a1092 1
			bus_dmamap_sync(sc->dmat, sc->sc_ccbmap,
d1243 1
a1243 1
		bus_dmamap_sync(sc->dmat, sc->sc_ccbmap,
d1768 2
a1769 3
	void *idata;
	bus_dmamap_t idatamap;
	paddr_t	pa;
d1776 1
a1776 2
	if (!(idata = ami_allocmem(sc->dmat, &idatamap, NBPG, (size / NBPG) + 1,
	    "ami mgmt"))) {
d1780 1
a1780 2

	pa = htole32(idatamap->dm_segs[0].ds_addr);
d1794 1
a1794 1
		*((char *)idata) = par1;
d1803 1
a1803 1
	cmd->acc_io.aio_data = pa;
d1818 1
a1818 2
	ami_freemem(idata, sc->dmat, &idatamap, NBPG, (size / NBPG) + 1,
	    "ami mgmt");
@


1.101
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.100 2005/11/27 07:28:57 marco Exp $	*/
d374 3
d435 1
d532 1
@


1.100
log
@Prevent scsi pass-through busses from attaching when a board is marked
broken.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.99 2005/11/27 04:26:14 krw Exp $	*/
a1565 1
				xs->error = XS_TIMEOUT;
@


1.99
log
@Fix ami_freemem() by initializing segp before using it.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.98 2005/11/26 05:49:47 marco Exp $	*/
d581 4
@


1.98
log
@Move bus_dma from pa to dva.  I wrote the initial diff with an ok from dlg@@

krw@@ removed all seg references and cleaned up htole32 a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.97 2005/11/24 22:18:55 dlg Exp $	*/
d282 1
a282 1
	bus_dma_segment_t segp;
@


1.97
log
@dont need spls in attach
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.96 2005/11/23 21:36:18 dlg Exp $	*/
d128 4
a131 4
void		*ami_allocmem(bus_dma_tag_t, bus_dmamap_t *,
		    bus_dma_segment_t *, size_t, size_t, const char *);
void		ami_freemem(caddr_t, bus_dma_tag_t, bus_dmamap_t *,
		    bus_dma_segment_t *, size_t, size_t, const char *);
d229 2
a230 2
ami_allocmem(bus_dma_tag_t dmat, bus_dmamap_t *map, bus_dma_segment_t *segp,
    size_t isize, size_t nent, const char *iname)
d232 1
d244 1
a244 1
	if ((error = bus_dmamem_alloc(dmat, total, PAGE_SIZE, 0, segp, 1,
d251 1
a251 1
	if ((error = bus_dmamem_map(dmat, segp, rseg, total, &p,
d271 1
a271 1
	bus_dmamem_free(dmat, segp, 1);
d280 1
a280 1
    bus_dma_segment_t *segp, size_t isize, size_t nent, const char *iname)
d282 1
d287 1
a287 1
	bus_dmamem_free(dmat, segp, 1);
a314 1
	bus_dma_segment_t idataseg[1];
d320 1
a320 2
	if (!(idata = ami_allocmem(sc->dmat, &idatamap, idataseg,
	    NBPG, 1, "init data")))
d323 1
a323 1
	sc->sc_mbox = ami_allocmem(sc->dmat, &sc->sc_mbox_map, sc->sc_mbox_seg,
d328 1
a328 1
	sc->sc_mbox_pa = sc->sc_mbox_seg[0].ds_addr;
d331 1
a331 1
	sc->sc_ccbmem = ami_allocmem(sc->dmat, &sc->sc_ccbmap, sc->sc_ccbseg,
d359 1
a359 1
		ccb->ccb_ptpa = htole32(sc->sc_ccbseg[0].ds_addr +
d363 1
a363 1
		ccb->ccb_sglistpa = htole32(sc->sc_ccbseg[0].ds_addr +
d373 1
a373 1
		paddr_t	pa = idataseg[0].ds_addr;
d382 1
a382 1
		cmd->acc_io.aio_data = htole32(pa);
d397 1
a397 1
			cmd->acc_io.aio_data = htole32(pa);
d422 1
a422 1
			cmd->acc_io.aio_data = htole32(pa);
d430 1
a430 1
				cmd->acc_io.aio_data = htole32(pa);
d476 1
a476 1
		cmd->acc_io.aio_data = htole32(pa);
d489 1
a489 1
			cmd->acc_io.aio_data = htole32(pa);
d529 1
a529 1
	ami_freemem(idata, sc->dmat, &idatamap, idataseg, NBPG, 1, "init data");
d618 1
a618 1
	    sc->sc_ccbseg, sizeof(struct ami_ccbmem), AMI_MAXCMDS,
d622 1
a622 1
	    sc->sc_mbox_seg, sizeof(struct ami_iocmd), 1, "mbox");
d624 1
a624 1
	ami_freemem(idata, sc->dmat, &idatamap, idataseg, NBPG, 1, "init data");
d660 1
a660 1
	qidb = sc->sc_mbox_pa | AMI_QIDB_EXEC;
d768 1
a768 1
	qidb = sc->sc_mbox_pa | AMI_QIDB_EXEC;
d813 1
a813 1
	qidb = sc->sc_mbox_pa | AMI_QIDB_ACK;
a1768 1
	bus_dma_segment_t idataseg[1];
d1776 2
a1777 2
	if (!(idata = ami_allocmem(sc->dmat, &idatamap, idataseg, NBPG,
	    (size / NBPG) + 1, "ami mgmt"))) {
d1782 1
a1782 1
	pa = idataseg[0].ds_addr;
d1805 1
a1805 1
	cmd->acc_io.aio_data = htole32(pa);
d1820 2
a1821 2
	ami_freemem(idata, sc->dmat, &idatamap, idataseg, NBPG,
	    (size / NBPG) + 1, "ami mgmt");
@


1.96
log
@make this easier for me to read by changing the locking to use the bare
spl calls rather than ami's macro wrappers for them.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.95 2005/11/23 12:12:59 dlg Exp $	*/
a373 3
		int s;

		s = splbio();
a431 1
					splx(s);
a527 1
		splx(s);
@


1.95
log
@slight shuffle at the top of the file. dont include biovar.h if bio is not
configured
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.94 2005/10/11 09:10:49 dlg Exp $	*/
d374 1
a374 1
		ami_lock_t lock;
d376 1
a376 1
		lock = AMI_LOCK_AMI(sc);
d435 1
a435 1
					AMI_UNLOCK_AMI(sc, lock);
d532 1
a532 1
		AMI_UNLOCK_AMI(sc, lock);
d1174 1
a1174 1
	ami_lock_t lock;
d1176 1
a1176 1
	lock = AMI_LOCK_AMI(sc);
d1218 1
a1218 1
	AMI_UNLOCK_AMI(sc, lock);
d1226 1
a1226 1
	ami_lock_t lock;
d1236 1
a1236 1
	lock = AMI_LOCK_AMI(sc);
d1267 1
a1267 1
	AMI_UNLOCK_AMI(sc, lock);
d1306 1
a1306 1
	ami_lock_t lock;
d1311 1
a1311 1
	lock = AMI_LOCK_AMI(sc);
d1325 1
a1325 1
		AMI_UNLOCK_AMI(sc, lock);
d1334 1
a1334 1
		AMI_UNLOCK_AMI(sc, lock);
d1360 1
a1360 1
		AMI_UNLOCK_AMI(sc, lock);
d1378 1
a1378 1
	AMI_UNLOCK_AMI(sc, lock);
d1401 1
a1401 1
	ami_lock_t lock;
d1405 1
a1405 1
	lock = AMI_LOCK_AMI(sc);
d1413 1
a1413 1
		AMI_UNLOCK_AMI(sc, lock);
d1471 1
a1471 1
		AMI_UNLOCK_AMI(sc, lock);
d1522 1
a1522 1
				AMI_UNLOCK_AMI(sc, lock);
d1531 1
a1531 1
			AMI_UNLOCK_AMI(sc, lock);
d1568 1
a1568 1
				AMI_UNLOCK_AMI(sc, lock);
d1573 1
a1573 1
				AMI_UNLOCK_AMI(sc, lock);
d1578 1
a1578 1
		AMI_UNLOCK_AMI(sc, lock);
d1590 1
a1590 1
	AMI_UNLOCK_AMI(sc, lock);
d1600 1
a1600 1
	ami_lock_t lock;
d1607 1
a1607 1
	lock = AMI_LOCK_AMI(sc);
d1627 1
a1627 1
	AMI_UNLOCK_AMI(sc, lock);
d1654 1
a1654 1
	ami_lock_t lock;
d1662 1
a1662 1
	lock = AMI_LOCK_AMI(sc);
d1664 1
a1664 1
		AMI_UNLOCK_AMI(sc, lock);
d1704 1
a1704 1
	AMI_UNLOCK_AMI(sc, lock);
@


1.94
log
@ansi and a sprinkle of knf. i'll do anything to avoid doing assignments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.93 2005/10/10 08:17:46 dlg Exp $	*/
d48 1
a48 1
/*#define	AMI_DEBUG */
d68 1
d70 3
a72 1
#include "bio.h"
@


1.93
log
@do { } while (0) wrapper for the debug statement
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.92 2005/10/03 21:11:14 krw Exp $	*/
d93 2
a94 3
int	ami_scsi_cmd(struct scsi_xfer *xs);
int	ami_scsi_ioctl(struct scsi_link *link, u_long cmd,
    caddr_t addr, int flag, struct proc *p);
d105 1
a105 1
int	ami_scsi_raw_cmd(struct scsi_xfer *xs);
d115 2
a116 2
struct ami_ccb *ami_get_ccb(struct ami_softc *sc);
void ami_put_ccb(struct ami_ccb *ccb);
d118 17
a134 17
void ami_write_inbound_db(struct ami_softc *, u_int32_t);
void ami_write_outbound_db(struct ami_softc *, u_int32_t);
u_int32_t ami_read_inbound_db(struct ami_softc *);
u_int32_t ami_read_outbound_db(struct ami_softc *);

void ami_copyhds(struct ami_softc *sc, const u_int32_t *sizes,
	const u_int8_t *props, const u_int8_t *stats);
void *ami_allocmem(bus_dma_tag_t dmat, bus_dmamap_t *map,
	bus_dma_segment_t *segp, size_t isize, size_t nent, const char *iname);
void ami_freemem(caddr_t p, bus_dma_tag_t dmat, bus_dmamap_t *map,
	bus_dma_segment_t *segp, size_t isize, size_t nent, const char *iname);
void ami_stimeout(void *v);
int  ami_cmd(struct ami_ccb *ccb, int flags, int wait);
int  ami_start(struct ami_ccb *ccb, int wait);
int  ami_done(struct ami_softc *sc, int idx);
void ami_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size);
int  ami_inquire(struct ami_softc *sc, u_int8_t op);
d137 14
a150 13
int ami_mgmt(struct ami_softc *, u_int8_t, u_int8_t, u_int8_t, u_int8_t,
    size_t, void *);
int ami_drv_inq(struct ami_softc *, u_int8_t, u_int8_t, u_int8_t, void *);
int ami_ioctl(struct device *, u_long, caddr_t);
int ami_ioctl_inq(struct ami_softc *, struct bioc_inq *);
int ami_vol(struct ami_softc *, struct bioc_vol *,
    struct ami_big_diskarray *);
int ami_disk(struct ami_softc *, struct bioc_disk *,
    struct ami_big_diskarray *);
int ami_ioctl_vol(struct ami_softc *, struct bioc_vol *);
int ami_ioctl_disk(struct ami_softc *, struct bioc_disk *);
int ami_ioctl_alarm(struct ami_softc *, struct bioc_alarm *);
int ami_ioctl_setstate(struct ami_softc *, struct bioc_setstate *);
d154 1
a154 2
ami_get_ccb(sc)
	struct ami_softc *sc;
d163 2
a164 1
	return ccb;
d168 1
a168 2
ami_put_ccb(ccb)
	struct ami_ccb *ccb;
d180 1
a180 3
ami_write_inbound_db(sc, v)
	struct ami_softc *sc;
	u_int32_t v;
d190 1
a190 2
ami_read_inbound_db(sc)
	struct ami_softc *sc;
d203 1
a203 3
ami_write_outbound_db(sc, v)
	struct ami_softc *sc;
	u_int32_t v;
d213 1
a213 2
ami_read_outbound_db(sc)
	struct ami_softc *sc;
d226 2
a227 6
ami_allocmem(dmat, map, segp, isize, nent, iname)
	bus_dma_tag_t dmat;
	bus_dmamap_t *map;
	bus_dma_segment_t *segp;
	size_t isize, nent;
	const char *iname;
d275 2
a276 7
ami_freemem(p, dmat, map, segp, isize, nent, iname)
	caddr_t p;
	bus_dma_tag_t dmat;
	bus_dmamap_t *map;
	bus_dma_segment_t *segp;
	size_t isize, nent;
	const char *iname;
d288 2
a289 4
ami_copyhds(sc, sizes, props, stats)
	struct ami_softc *sc;
	const u_int32_t *sizes;
	const u_int8_t *props, *stats;
d303 1
a303 2
ami_attach(sc)
	struct ami_softc *sc;
d318 1
a318 1
		return 1;
d612 1
a612 1
	return 0;
d628 1
a628 1
	return 1;
d632 1
a632 2
ami_quartz_init(sc)
	struct ami_softc *sc;
d636 1
a636 1
	return 0;
d640 1
a640 3
ami_quartz_exec(sc, cmd)
	struct ami_softc *sc;
	struct ami_iocmd *cmd;
d669 1
a669 3
ami_quartz_done(sc, mbox)
	struct ami_softc *sc;
	struct ami_iocmd *mbox;
d738 1
a738 3
ami_quartz_poll(sc, cmd)
	struct ami_softc *sc;
	struct ami_iocmd *cmd;
d745 1
a745 1
		return 1; /* fail */
d781 1
a781 1
		return 1;
d794 1
a794 1
		return 1;
d827 1
a827 1
		return 1;
d848 1
a848 1
	return status;
d852 1
a852 2
ami_schwartz_init(sc)
	struct ami_softc *sc;
d864 1
a864 1
	return 0;
d868 1
a868 3
ami_schwartz_exec(sc, cmd)
	struct ami_softc *sc;
	struct ami_iocmd *cmd;
d872 1
a872 1
		return EBUSY;
d881 1
a881 1
	return 0;
d885 1
a885 3
ami_schwartz_done(sc, mbox)
	struct ami_softc *sc;
	struct ami_iocmd *mbox;
d895 1
a895 1
		return 0;
d906 1
a906 1
		return 1;
d909 1
a909 1
	return 0;
d913 1
a913 3
ami_schwartz_poll(sc, mbox)
	struct ami_softc *sc;
	struct ami_iocmd *mbox;
d919 2
a920 3
	if (sc->sc_dis_poll) {
		return 1; /* fail */
	}
d923 2
a924 1
		if (!(bus_space_read_1(sc->iot, sc->ioh, AMI_SMBSTAT) & AMI_SMBST_BUSY))
d945 2
a946 1
		if (!(bus_space_read_1(sc->iot, sc->ioh, AMI_SMBSTAT) & AMI_SMBST_BUSY))
d954 1
a954 1
		return 1; /* fail */
d968 1
a968 1
		return 1; /* fail */
d983 1
a983 1
	return rv;
d987 1
a987 3
ami_cmd(ccb, flags, wait)
	struct ami_ccb *ccb;
	int flags, wait;
d1001 2
a1002 1
				printf("more than %d dma segs\n", AMI_MAXOFFSETS);
d1105 1
a1105 3
ami_start(ccb, wait)
	struct ami_ccb *ccb;
	int wait;
d1164 1
a1164 2
ami_stimeout(v)
	void *v;
d1219 1
a1219 3
ami_done(sc, idx)
	struct ami_softc *sc;
	int	idx;
d1270 1
a1270 2
amiminphys(bp)
	struct buf *bp;
d1278 1
a1278 4
ami_copy_internal_data(xs, v, size)
	struct scsi_xfer *xs;
	void *v;
	size_t size;
d1293 1
a1293 2
ami_scsi_raw_cmd(xs)
	struct scsi_xfer *xs;
d1383 1
a1383 2
ami_scsi_cmd(xs)
	struct scsi_xfer *xs;
d1592 1
a1592 2
ami_intr(v)
	void *v;
d1630 2
a1631 2
ami_scsi_ioctl(struct scsi_link *link, u_long cmd,
    caddr_t addr, int flag, struct proc *p)
d1657 1
a1657 1
		return ENODEV; /* can't do this to broken device for now */
d1662 1
a1662 1
		return EBUSY;
d1707 2
a1708 6
ami_drv_inq(sc, ch, tg, page, inqbuf)
	struct ami_softc *sc;
	u_int8_t ch;
	u_int8_t tg;
	u_int8_t page;
	void *inqbuf;
d1764 2
a1765 8
ami_mgmt(sc, opcode, par1, par2, par3, size, buffer)
	struct ami_softc *sc;
	u_int8_t opcode;
	u_int8_t par1;
	u_int8_t par2;
	u_int8_t par3;
	size_t size;
	void *buffer;
d1805 1
d1820 1
a1820 2
	}
	else
d1830 1
a1830 3
ami_ioctl_inq(sc, bi)
	struct ami_softc *sc;
	struct bioc_inq *bi;
d1917 1
a1917 4
ami_vol(sc, bv, p)
	struct ami_softc *sc;
	struct bioc_vol *bv;
	struct ami_big_diskarray *p;
d1992 2
a1993 4
ami_disk(sc, bd, p)
	struct ami_softc *sc;
	struct bioc_disk *bd;
	struct ami_big_diskarray *p;
d2093 1
a2093 3
ami_ioctl_vol(sc, bv)
	struct ami_softc *sc;
	struct bioc_vol *bv;
d2173 1
a2173 3
ami_ioctl_disk(sc, bd)
	struct ami_softc *sc;
	struct bioc_disk *bd;
d2283 1
a2283 3
int ami_ioctl_alarm(sc, ba)
	struct ami_softc *sc;
	struct bioc_alarm *ba;
d2327 1
a2327 3
ami_ioctl_setstate(sc, bs)
	struct ami_softc *sc;
	struct bioc_setstate *bs;
d2386 1
a2386 2
ami_print_mbox(mbox)
	struct ami_iocmd *mbox;
@


1.92
log
@Reduce the number of openings the logical devices have to play with so
that ioctl's and raw commands will not cause i/o failures. Assume a
max of two processors/enclosures per raw bus for the moment.

Fixes regular crashes on my 1 logical device, all-softdep system
during make build with a bioctl loop running.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.91 2005/10/02 06:30:50 dlg Exp $	*/
d72 1
a72 1
#define	AMI_DPRINTF(m,a)	if (ami_debug & (m)) printf a
@


1.91
log
@replace the two separate dmamem allocations for the passthrough commands
and the scatter gather lists with a single allocation containing both.
more importantly, actually sync the appropriate parts of this allocation
when giving the commands to or taking the response from the device.

tested by and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.90 2005/09/30 10:10:29 dlg Exp $	*/
d533 7
d620 1
a620 1
		rsc->sc_link.openings = sc->sc_maxcmds;
@


1.90
log
@unless AMI_DEBUG is defined, dont compile in if statements that only there
to see if we should DPRINTF. this has been bugging me for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.89 2005/09/30 09:55:20 dlg Exp $	*/
d327 1
d347 3
a349 3
	sc->sc_pts = ami_allocmem(sc->dmat, &sc->sc_ptmap, sc->sc_ptseg,
	    sizeof(struct ami_passthrough), AMI_MAXCMDS, "ptlist");
	if (!sc->sc_pts)
a351 5
	sc->sc_sgents = ami_allocmem(sc->dmat, &sc->sc_sgmap, sc->sc_sgseg,
	    sizeof(struct ami_sgent) * AMI_SGEPERCMD, AMI_MAXCMDS, "sglist");
	if (!sc->sc_sgents)
		goto free_pts;

d358 1
a367 1

d370 1
d372 10
a381 6
		ccb->ccb_pt = &sc->sc_pts[i];
		ccb->ccb_ptpa = htole32(sc->sc_ptseg[0].ds_addr +
		    (sizeof(struct ami_passthrough) * i));
		ccb->ccb_sglist = &sc->sc_sgents[i * AMI_SGEPERCMD];
		ccb->ccb_sglistpa = htole32(sc->sc_sgseg[0].ds_addr +
		    (sizeof(struct ami_sgent) * AMI_SGEPERCMD * i));
d631 3
a633 6
	ami_freemem((caddr_t)sc->sc_sgents, sc->dmat, &sc->sc_sgmap,
	    sc->sc_sgseg, sizeof(struct ami_sgent) * AMI_SGEPERCMD,
	    AMI_MAXCMDS, "sglist");
free_pts:
	ami_freemem((caddr_t)sc->sc_pts, sc->dmat, &sc->sc_ptmap, sc->sc_ptseg,
	    sizeof(struct ami_passthrough), AMI_MAXCMDS, "ptlist");
d1075 4
d1093 10
a1102 1
		if (ccb->ccb_data)
d1104 1
d1112 10
a1121 1
		if (ccb->ccb_data)
d1123 1
d1273 4
@


1.89
log
@sync the dma mapping for the data buffer in the right direction when
sending commands
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.88 2005/09/30 07:53:03 dlg Exp $	*/
d1060 1
d1064 1
d1086 3
a1088 1
		if ((error = sc->sc_poll(sc, &ccb->ccb_cmd))) {
d1090 1
a1090 1
		}
@


1.88
log
@remove the dmamap used for iocmds since they were only copied into the
mbox, no dma was ever performed on them. store them in the ccb instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.87 2005/09/26 21:33:02 dlg Exp $	*/
d1076 2
a1077 1
		    BUS_DMASYNC_PREWRITE);
@


1.87
log
@allocate and map the mbox separately to the iocmds used by the ccbs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.86 2005/09/25 04:59:14 dlg Exp $	*/
a326 2
	struct ami_passthrough *pt;
	struct ami_sgent *sg;
d331 1
a331 1
	int	error;
a345 5
	sc->sc_cmds = ami_allocmem(sc->dmat, &sc->sc_cmdmap, sc->sc_cmdseg,
	    sizeof(struct ami_iocmd), AMI_MAXCMDS+1, "command");
	if (!sc->sc_cmds)
		goto free_mbox;

d347 1
a347 1
	    sizeof(struct ami_passthrough), AMI_MAXCMDS+1, "ptlist");
d349 1
a349 1
		goto free_cmds;
d352 1
a352 1
	    sizeof(struct ami_sgent) * AMI_SGEPERCMD, AMI_MAXCMDS+1, "sglist");
d360 9
a368 31
	/* 0th command is a mailbox */
	for (ccb = &sc->sc_ccbs[AMI_MAXCMDS-1],
	     cmd = sc->sc_cmds  + sizeof(*cmd) * AMI_MAXCMDS,
	     pt = sc->sc_pts  + sizeof(*pt) * AMI_MAXCMDS,
	     sg = sc->sc_sgents + sizeof(*sg)  * AMI_MAXCMDS * AMI_SGEPERCMD;
	     cmd >= (struct ami_iocmd *)sc->sc_cmds;
	     cmd--, ccb--, pt--, sg -= AMI_SGEPERCMD) {

		cmd->acc_id = cmd - (struct ami_iocmd *)sc->sc_cmds;
		if (cmd->acc_id) {
			error = bus_dmamap_create(sc->dmat,
			    AMI_MAXFER, AMI_MAXOFFSETS, AMI_MAXFER, 0,
			    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,
			    &ccb->ccb_dmamap);
			if (error) {
				printf(": cannot create ccb dmamap (%d)\n",
				    error);
				goto destroy;
			}
			ccb->ccb_sc = sc;
			ccb->ccb_cmd = cmd;
			ccb->ccb_state = AMI_CCB_FREE;
			ccb->ccb_cmdpa = htole32(sc->sc_cmdseg[0].ds_addr +
			    cmd->acc_id * sizeof(*cmd));
			ccb->ccb_pt = pt;
			ccb->ccb_ptpa = htole32(sc->sc_ptseg[0].ds_addr +
			    cmd->acc_id * sizeof(*pt));
			ccb->ccb_sglist = sg;
			ccb->ccb_sglistpa = htole32(sc->sc_sgseg[0].ds_addr +
			    cmd->acc_id * sizeof(*sg) * AMI_SGEPERCMD);
			TAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_link);
d370 12
d394 1
a394 1
		cmd = ccb->ccb_cmd;
d410 1
a410 1
			cmd = ccb->ccb_cmd;
d435 1
a435 1
			cmd = ccb->ccb_cmd;
d443 1
a443 1
				cmd = ccb->ccb_cmd;
d490 1
a490 1
		cmd = ccb->ccb_cmd;
d503 1
a503 1
			cmd = ccb->ccb_cmd;
d630 3
a632 2
	ami_freemem(sc->sc_sgents, sc->dmat, &sc->sc_sgmap, sc->sc_sgseg,
	    sizeof(struct ami_sgent) * AMI_SGEPERCMD, AMI_MAXCMDS+1, "sglist");
d634 2
a635 5
	ami_freemem(sc->sc_pts, sc->dmat, &sc->sc_ptmap, sc->sc_ptseg,
	    sizeof(struct ami_passthrough), AMI_MAXCMDS+1, "ptlist");
free_cmds:
	ami_freemem(sc->sc_cmds, sc->dmat, &sc->sc_cmdmap, sc->sc_cmdseg,
	    sizeof(struct ami_iocmd), AMI_MAXCMDS+1, "command");
d1023 1
a1023 1
		struct ami_iocmd *cmd = ccb->ccb_cmd;
d1078 1
a1078 3
		ccb->ccb_cmd->acc_mbox.amb_nsge = 0;
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, sc->sc_cmdmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
d1083 1
a1083 1
		if ((error = sc->sc_poll(sc, ccb->ccb_cmd))) {
d1109 1
a1109 1
	struct ami_iocmd *cmd = ccb->ccb_cmd;
d1171 1
a1171 1
	struct ami_iocmd *cmd = ccb->ccb_cmd;
d1229 1
a1229 1
	AMI_DPRINTF(AMI_D_CMD, ("done(%d) ", ccb->ccb_cmd->acc_id));
d1355 1
a1355 1
	cmd = ccb->ccb_cmd;
d1544 1
a1544 1
		cmd = ccb->ccb_cmd;
d1734 1
a1734 1
	ccb->ccb_cmd->acc_cmd = AMI_PASSTHRU;
d1806 1
a1806 1
	cmd = ccb->ccb_cmd;
@


1.86
log
@1.83 again:
fix ami_drv_inq so it uses ami_cmd's ability to use an arbitrary kernel
buffer for passthrough io rather than setting its own up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.83 2005/09/21 10:54:37 dlg Exp $	*/
d340 8
d351 1
a351 1
		goto free_idata;
a397 5
		} else {
			sc->sc_mbox = cmd;
			sc->sc_mbox_pa = sc->sc_cmdseg[0].ds_addr;
			AMI_DPRINTF(AMI_D_CMD, ("mbox_pa=%llx ",
			    sc->sc_mbox_pa));
d655 3
d691 1
a691 1
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, 128,
d727 2
a728 2
		bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, 128,
		    BUS_DMASYNC_POSTREAD);
d734 2
a735 2
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, 128,
	    BUS_DMASYNC_POSTWRITE);
d741 2
a742 2
		bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, 128,
		    BUS_DMASYNC_PREREAD);
d750 2
a751 2
		bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, 128,
		    BUS_DMASYNC_POSTWRITE);
d761 1
a761 1
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, 16,
d798 1
a798 1
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, 16,
d981 1
a981 1
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, 16,
d1021 1
a1021 1
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, 128,
@


1.85
log
@1.82 again; dont use the scsi xfer to decide if we should dma_sync.
instead use generic variables in the ccb so commands not originating from
the scsi layer can be handled by ami_done as well.

this version does not freeze like 1.82. the secret seems to be to go
ami_put_ccb before scsi_done.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.84 2005/09/22 07:37:32 dlg Exp $	*/
d1737 2
a1738 8
	struct ami_iocmd *cmd;
	struct ami_passthrough *ps;
	struct scsi_inquiry_data *pp;
	void *idata;
	bus_dmamap_t idatamap;
	bus_dma_segment_t idataseg[1];
	paddr_t	pa;
	int error = 0;
a1743 11
	if (!(idata = ami_allocmem(sc->dmat, &idatamap, idataseg, NBPG, 1,
	    "ami mgmt"))) {
		ami_put_ccb(ccb);
	    	return (ENOMEM);
	}

	pa = idataseg[0].ds_addr;
	ps = idata;
	pp = idata + sizeof *ps;

	ccb->ccb_data = NULL;
d1745 21
a1765 18
	cmd = ccb->ccb_cmd;

	cmd->acc_cmd = AMI_PASSTHRU;
	cmd->acc_passthru.apt_data = htole32(pa);

	memset(ps, 0, sizeof *ps);

	ps->apt_channel = ch;
	ps->apt_target = tg;
	ps->apt_ncdb = sizeof(struct scsi_inquiry);
	ps->apt_nsense = sizeof(struct scsi_sense_data);

	ps->apt_cdb[0] = INQUIRY;
	ps->apt_cdb[1] = 0;
	ps->apt_cdb[2] = 0;
	ps->apt_cdb[3] = 0;
	ps->apt_cdb[4] = sizeof(struct scsi_inquiry_data); /* INQUIRY length */
	ps->apt_cdb[5] = 0;
d1768 2
a1769 2
		ps->apt_cdb[1] = SI_EVPD;
		ps->apt_cdb[2] = page;
d1772 2
a1773 2
	ps->apt_data = htole32(pa + sizeof *ps);
	ps->apt_datalen = sizeof(struct scsi_inquiry_data);
d1775 2
a1776 3
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 0) == 0) {
		while (ccb->ccb_wakeup)
			tsleep(ccb, PRIBIO, "ami_drv_inq", 0);
d1778 1
a1778 1
		ami_put_ccb(ccb);
d1780 2
a1781 2
		if (ps->apt_scsistat == 0x00) {
			memcpy(inqbuf, pp, sizeof(struct scsi_inquiry_data));
d1783 2
a1784 2
			if (pp->device != T_DIRECT)
				error = EINVAL;
d1786 1
a1786 12
			goto bail;
		}

		error = EINVAL;
	}
	else 
		error = EINVAL;

bail:
	ami_freemem(idata, sc->dmat, &idatamap, idataseg, NBPG, 1, "ami mgmt");

	return (error);
@


1.84
log
@revert 1.82 and 1.83 of ami.c and 1.26 of amivar.h since it seems to be
causing random lockups on my machine. sigh.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.81 2005/09/21 08:52:44 dlg Exp $	*/
d175 2
d1256 5
a1260 10
	if (xs) {
		timeout_del(&xs->stimeout);

		if (xs->cmd->opcode != PREVENT_ALLOW &&
		    xs->cmd->opcode != SYNCHRONIZE_CACHE)
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize,
			    (xs->flags & SCSI_DATA_IN) ?
			    BUS_DMASYNC_POSTREAD :
			    BUS_DMASYNC_POSTWRITE);
a1262 17

		ccb->ccb_xs = NULL;
	} else {
		struct ami_iocmd *cmd = ccb->ccb_cmd;

		switch (cmd->acc_cmd) {
		case AMI_INQUIRY:
		case AMI_EINQUIRY:
		case AMI_EINQUIRY3:
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
			break;
		default:
			/* no data */
			break;
		}
d1272 1
d1360 1
d1556 2
@


1.83
log
@fix ami_drv_inq so it uses ami_cmd's ability to use an arbitrary kernel
buffer for passthrough io rather than setting its own up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.82 2005/09/21 10:36:14 dlg Exp $	*/
d1211 2
a1212 3

		/* XXX ccb might complete and overwrite this mem */
		if (ccb->ccb_data != NULL) {
d1215 3
a1217 2
			    (ccb->ccb_dir == AMI_CCB_IN) ?
			    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
a1218 1
			ccb->ccb_data = NULL;
d1254 2
a1255 1
	/* dma sync cmd/pt/sglist */
d1257 7
a1263 5
	if (ccb->ccb_data != NULL) {
		bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
		    ccb->ccb_dmamap->dm_mapsize,
		    (ccb->ccb_dir == AMI_CCB_IN) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
d1267 16
a1282 1
		ccb->ccb_data = NULL;
d1285 6
a1291 2
		timeout_del(&xs->stimeout);

a1295 2

		ccb->ccb_xs = NULL;
a1297 6
	if (ccb->ccb_wakeup) {
		ccb->ccb_wakeup = 0;
		wakeup(ccb);
	} else
		ami_put_ccb(ccb);

d1340 1
d1374 2
d1377 1
a1378 4
	ccb->ccb_len = xs->datalen;
	ccb->ccb_dir = (xs->flags & SCSI_DATA_IN) ? AMI_CCB_IN : AMI_CCB_OUT;

	ccb->ccb_cmd->acc_cmd = AMI_PASSTHRU;
a1379 1
	memset(ccb->ccb_pt, 0, sizeof(struct ami_passthrough));
d1388 3
d1573 1
a1574 4
		ccb->ccb_len = xs->datalen;
		ccb->ccb_dir = (xs->flags & SCSI_DATA_IN) ?
		    AMI_CCB_IN : AMI_CCB_OUT;

d1753 8
a1760 2
	struct ami_passthrough *pt;
	struct scsi_inquiry_data *inq = inqbuf;
d1766 11
d1778 18
a1795 21
	ccb->ccb_data = inqbuf;
	ccb->ccb_len = sizeof(struct scsi_inquiry_data);
	ccb->ccb_dir = AMI_CCB_IN;

	ccb->ccb_cmd->acc_cmd = AMI_PASSTHRU;

	pt = ccb->ccb_pt;

	memset(pt, 0, sizeof(struct ami_passthrough));
	pt->apt_channel = ch;
	pt->apt_target = tg;
	pt->apt_ncdb = sizeof(struct scsi_inquiry);
	pt->apt_nsense = sizeof(struct scsi_sense_data);
	pt->apt_datalen = sizeof(struct scsi_inquiry_data);

	pt->apt_cdb[0] = INQUIRY;
	pt->apt_cdb[1] = 0;
	pt->apt_cdb[2] = 0;
	pt->apt_cdb[3] = 0;
	pt->apt_cdb[4] = sizeof(struct scsi_inquiry_data); /* INQUIRY length */
	pt->apt_cdb[5] = 0;
d1798 2
a1799 2
		pt->apt_cdb[1] = SI_EVPD;
		pt->apt_cdb[2] = page;
d1802 2
a1803 2
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 0) != 0)
		return (EIO);
d1805 3
a1807 2
	while (ccb->ccb_wakeup)
		tsleep(ccb, PRIBIO, "ami_drv_inq", 0);
d1809 4
a1812 1
	ami_put_ccb(ccb);
d1814 5
a1818 2
	if (pt->apt_scsistat != 0x00)
		return (EIO);
d1820 7
a1826 2
	if ((inq->device & SID_TYPE) != T_DIRECT)
		return (EINVAL);
d1828 1
a1828 1
	return (0);
@


1.82
log
@dont use the scsi xfer in ami_done to figure out if we have to sync a
buffer or not. this will allow us to issue arbitrary passthrough commands
without needing them to come in via ami_scsi_raw_cmd. useful for management
functionality...
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.81 2005/09/21 08:52:44 dlg Exp $	*/
d1741 2
a1742 8
	struct ami_iocmd *cmd;
	struct ami_passthrough *ps;
	struct scsi_inquiry_data *pp;
	void *idata;
	bus_dmamap_t idatamap;
	bus_dma_segment_t idataseg[1];
	paddr_t	pa;
	int error = 0;
a1747 11
	if (!(idata = ami_allocmem(sc->dmat, &idatamap, idataseg, NBPG, 1,
	    "ami mgmt"))) {
		ami_put_ccb(ccb);
	    	return (ENOMEM);
	}

	pa = idataseg[0].ds_addr;
	ps = idata;
	pp = idata + sizeof *ps;

	ccb->ccb_data = NULL;
d1749 3
a1751 1
	cmd = ccb->ccb_cmd;
d1753 1
a1753 2
	cmd->acc_cmd = AMI_PASSTHRU;
	cmd->acc_passthru.apt_data = htole32(pa);
d1755 1
a1755 1
	memset(ps, 0, sizeof *ps);
d1757 13
a1769 11
	ps->apt_channel = ch;
	ps->apt_target = tg;
	ps->apt_ncdb = sizeof(struct scsi_inquiry);
	ps->apt_nsense = sizeof(struct scsi_sense_data);

	ps->apt_cdb[0] = INQUIRY;
	ps->apt_cdb[1] = 0;
	ps->apt_cdb[2] = 0;
	ps->apt_cdb[3] = 0;
	ps->apt_cdb[4] = sizeof(struct scsi_inquiry_data); /* INQUIRY length */
	ps->apt_cdb[5] = 0;
d1772 2
a1773 2
		ps->apt_cdb[1] = SI_EVPD;
		ps->apt_cdb[2] = page;
d1776 2
a1777 2
	ps->apt_data = htole32(pa + sizeof *ps);
	ps->apt_datalen = sizeof(struct scsi_inquiry_data);
d1779 2
a1780 3
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 0) == 0) {
		while (ccb->ccb_wakeup)
			tsleep(ccb, PRIBIO, "ami_drv_inq", 0);
d1782 1
a1782 1
		ami_put_ccb(ccb);
d1784 2
a1785 2
		if (ps->apt_scsistat == 0x00) {
			memcpy(inqbuf, pp, sizeof(struct scsi_inquiry_data));
d1787 2
a1788 2
			if (pp->device != T_DIRECT)
				error = EINVAL;
d1790 1
a1790 12
			goto bail;
		}

		error = EINVAL;
	}
	else 
		error = EINVAL;

bail:
	ami_freemem(idata, sc->dmat, &idatamap, idataseg, NBPG, 1, "ami mgmt");

	return (error);
@


1.81
log
@remove the bits in the ccb that were needed to support scsi commands on
the passthrough bus when bounce buffers were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.80 2005/09/21 08:39:15 dlg Exp $	*/
d1211 3
a1213 2
		if (xs->cmd->opcode != PREVENT_ALLOW &&
		    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
d1216 2
a1217 3
			    (xs->flags & SCSI_DATA_IN) ?
			    BUS_DMASYNC_POSTREAD :
			    BUS_DMASYNC_POSTWRITE);
d1219 1
d1255 13
d1271 4
a1274 9
		if (xs->cmd->opcode != PREVENT_ALLOW &&
		    xs->cmd->opcode != SYNCHRONIZE_CACHE)
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize,
			    (xs->flags & SCSI_DATA_IN) ?
			    BUS_DMASYNC_POSTREAD :
			    BUS_DMASYNC_POSTWRITE);

		bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
a1276 15
	} else {
		struct ami_iocmd *cmd = ccb->ccb_cmd;

		switch (cmd->acc_cmd) {
		case AMI_INQUIRY:
		case AMI_EINQUIRY:
		case AMI_EINQUIRY3:
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
			break;
		default:
			/* no data */
			break;
		}
a1284 7
	if (xs) {
		xs->resid = 0;
		xs->flags |= ITSDONE;
		AMI_DPRINTF(AMI_D_CMD, ("scsi_done(%d) ", idx));
		scsi_done(xs);
	}

a1326 1
	struct ami_iocmd *cmd;
a1359 2
	memset(ccb->ccb_pt, 0, sizeof(struct ami_passthrough));

a1360 1
	ccb->ccb_len  = xs->datalen;
d1362 4
d1367 1
a1375 3
	cmd = ccb->ccb_cmd;
	cmd->acc_cmd = AMI_PASSTHRU;

a1557 1
		ccb->ccb_len  = xs->datalen;
d1559 4
@


1.80
log
@rename nsg to nsge in struct ami_passthrough to be consistent with the
naming elsewhere in this driver.

suggested by marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.79 2005/09/21 08:36:35 dlg Exp $	*/
a174 1
	ccb->ami_pt.idata = NULL;
a1255 13
		if (ccb->ami_pt.idata) {/* this is on the pt bus */
			if (ccb->ami_pt.dir == AMI_PT_IN)
				memcpy(xs->data, ccb->ami_pt.idata +
				    sizeof(struct ami_passthrough),
				    xs->datalen);
		} else {
			if (xs->cmd->opcode != PREVENT_ALLOW &&
			    xs->cmd->opcode != SYNCHRONIZE_CACHE)
				bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
				    ccb->ccb_dmamap->dm_mapsize,
				    (xs->flags & SCSI_DATA_IN) ?
				    BUS_DMASYNC_POSTREAD :
				    BUS_DMASYNC_POSTWRITE);
d1257 10
a1266 2
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
		}
@


1.79
log
@use the ccbs passthrough command in the raw scsi path rather than
allocating it and a bounce buffer for each scsi io. gets rid of the alloc
sleeps and frees and simplifies things greatly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.78 2005/09/21 08:33:03 dlg Exp $	*/
d1062 1
a1062 1
				ccb->ccb_pt->apt_nsg = dmap->dm_nsegs;
d1078 1
a1078 1
				ccb->ccb_pt->apt_nsg = 0;
@


1.78
log
@allocate space in each ccb to store a passthrough command
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.76 2005/09/19 07:45:28 dlg Exp $	*/
d1050 3
d1061 7
a1067 2
			cmd->acc_mbox.amb_nsge = dmap->dm_nsegs;
			cmd->acc_mbox.amb_data = ccb->ccb_sglistpa;
d1077 7
a1083 2
			cmd->acc_mbox.amb_nsge = 0;
			cmd->acc_mbox.amb_data = htole32(sgd->ds_addr);
a1346 1
	struct ami_passthrough *ps;
a1347 1
	int direction;
a1348 4
	void *idata;
	bus_dmamap_t idatamap;
	bus_dma_segment_t idataseg[1];
	paddr_t pa;
d1355 3
a1357 44
	/*
	 * do this early to prevent default cases later on that don't make sense
	 */
	switch (xs->cmd->opcode) {
	/* to target */
	case TEST_UNIT_READY:
	case START_STOP:
	case PREVENT_ALLOW:
	case WRITE_COMMAND:
	case WRITE_BIG:
	case SYNCHRONIZE_CACHE:
	case SEND_DIAGNOSTIC:
	case WRITE_BUFFER:
		direction = AMI_PT_OUT;
		break;
	/* from target */
	case REQUEST_SENSE:
	case INQUIRY:
	case MODE_SENSE:
	case READ_CAPACITY:
	case READ_COMMAND:
	case READ_BIG:
	case READ_BUFFER:
	case RECEIVE_DIAGNOSTIC:
		if (!cold)	/* XXX bogus */
			if (target == rsc->sc_proctarget)
				strlcpy(rsc->sc_procdev, dev->dv_xname,
				    sizeof(rsc->sc_procdev));

		direction = AMI_PT_IN;
		break;

	default:
		printf("%s: unsupported command(0x%02x)\n",
		    sc->sc_dev.dv_xname, xs->cmd->opcode);
		bzero(&xs->sense, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* illcmd, 0x24 illfield */
		xs->error = XS_SENSE;
		scsi_done(xs);
		AMI_UNLOCK_AMI(sc, lock);
		return (COMPLETE);
	}
a1370 9
	if (xs->datalen > NBPG - 128) {
		printf("%s: xs->datalen too big(%d)\n", sc->sc_dev.dv_xname,
		    xs->datalen);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		AMI_UNLOCK_AMI(sc, lock);
		return (COMPLETE);
	}

d1380 1
a1380 16
	if (!(idata = ami_allocmem(sc->dmat, &idatamap, idataseg, NBPG, 1,
	    "ami raw"))) {
	    	ami_put_ccb(ccb);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		AMI_UNLOCK_AMI(sc, lock);
		return (COMPLETE);
	}

	ccb->ami_pt.idata = idata;
	ccb->ami_pt.dir = direction;
	ps = idata;
	pa = idataseg[0].ds_addr;
	ps = (struct ami_passthrough *)idata;

	memset(ps, 0, sizeof *ps);
d1384 1
a1384 1
	ccb->ccb_data = NULL;
d1386 7
a1392 8
	ps->apt_param = AMI_PTPARAM(AMI_TIMEOUT_6,1,0);
	ps->apt_channel = channel;
	ps->apt_target = target;
	bcopy(xs->cmd, ps->apt_cdb, AMI_MAX_CDB);
	ps->apt_ncdb = xs->cmdlen;
	ps->apt_nsense = AMI_MAX_SENSE;
	ps->apt_data = htole32(pa + sizeof *ps);
	ps->apt_datalen = xs->datalen;
a1395 7
	cmd->acc_passthru.apt_data = htole32(pa);

	if (ccb->ami_pt.dir == AMI_PT_OUT)
		memcpy(ccb->ami_pt.idata + sizeof *ps, xs->data, xs->datalen);

	if ((xs->flags & SCSI_POLL) == 0)
		ccb->ccb_wakeup = 1;
a1398 4
		ami_freemem(ccb->ami_pt.idata, sc->dmat, &idatamap, idataseg,
		    NBPG, 1, "ami raw");
		ccb->ami_pt.idata = NULL;

d1407 2
a1408 1
			type = *((char *)idata + sizeof *ps) & SID_TYPE;
d1413 1
a1413 1
				rsc->sc_proctarget = target; /* save off target */
a1414 2
		if (direction == AMI_PT_IN)
			memcpy(xs->data, idata + sizeof *ps, xs->datalen);
a1416 5
	} else {
		while (ccb->ccb_wakeup)
			tsleep(ccb, PRIBIO, "ami_pt", 0);

		ami_put_ccb(ccb);
a1418 2
	ami_freemem(idata, sc->dmat, &idatamap, idataseg, NBPG, 1, "ami raw");

d1420 4
a1423 1
	return (COMPLETE);
@


1.77
log
@dont use htole32 to set up values to be assigned to an 8 bit field.
@
text
@d326 1
d344 5
d352 1
a352 1
		goto free_cmds;
d361 1
d364 1
a364 1
	     cmd--, ccb--, sg -= AMI_SGEPERCMD) {
d382 3
d645 3
@


1.76
log
@replace the pointer mess used to handle wakeups on ccbs with a real flag

tested and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.75 2005/09/19 04:11:03 krw Exp $	*/
d1045 1
a1045 1
			cmd->acc_mbox.amb_nsge = htole32(dmap->dm_nsegs);
d1056 1
a1056 1
			cmd->acc_mbox.amb_nsge = htole32(0);
d1064 1
a1064 1
		ccb->ccb_cmd->acc_mbox.amb_nsge = htole32(0);
@


1.75
log
@Typo 'taget' -> 'target'.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.74 2005/09/15 05:33:39 krw Exp $	*/
d174 1
a174 1
	ccb->ccb_done = NULL;
d1074 6
a1079 2
		/* always free ccb */
		ami_put_ccb(ccb);
d1265 5
a1269 6
	if (ccb->ccb_done) {
		*ccb->ccb_done = 1;
		wakeup((void *)ccb->ccb_done);
	}

	ami_put_ccb(ccb);
a1323 1
	volatile int done = 0;
a1429 1
	ccb->ccb_done = &done;
d1447 2
a1448 2
	if (xs->flags & SCSI_POLL)
		done = 1; /* Don't wait for completion twice. */
d1475 5
a1481 3
	while (!done)
		tsleep((void *)&done, PRIBIO, "ami_pt", 0);

a1828 1
	volatile int done = 0;
d1845 1
a1845 1
	ccb->ccb_done = &done;
d1874 4
a1877 6
		while (!done)
			if (tsleep((void *)&done, PRIBIO, "ami_drv_inq",
			    15 * hz) == EWOULDBLOCK) {
				error = EINVAL;
				goto bail;
			}
a1915 1
	volatile int done = 0;
d1930 1
a1930 1
	ccb->ccb_done = &done;
d1952 4
a1955 6
		while (!done)
			if (tsleep((void *)&done, PRIBIO,"ami_mgmt",
			    15 * hz) == EWOULDBLOCK) {
				error = EINVAL;
				goto bail;
			}
a1964 1
bail:
@


1.74
log
@Don't fake MODE SENSE page 4 info inside raid drivers, just let sd
fake a geometry. Page 4 info does not get used for size information.
Eliminate now unused union scsi_disk_pages.

ok marco@@ mickey@@ pre-lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.73 2005/08/31 18:27:31 marco Exp $	*/
d1509 1
a1509 1
		AMI_DPRINTF(AMI_D_CMD, ("no taget %d ", target));
@


1.73
log
@Remove check that prevents disks that are not in the unused state to move to
hot spare state.  This *should* be detected in f/w however there is one known
case where it does not work and hence this workaround was committed.  By having
this in there disks that were removed and reinserted that used to be hotspares
show up as unused however the meta data on disk conflicts with this preventing
it to be moved to hotspare.

OK, commit this, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.72 2005/08/31 17:59:09 marco Exp $	*/
a315 7
		if (sc->sc_hdr[i].hd_size > 0x200000) {
			sc->sc_hdr[i].hd_heads = 255;
			sc->sc_hdr[i].hd_secs = 63;
		} else {
			sc->sc_hdr[i].hd_heads = 64;
			sc->sc_hdr[i].hd_secs = 32;
		}
a1495 5
	struct {
		struct scsi_mode_header hd;
		struct scsi_blk_desc bd;
		union scsi_disk_pages dp;
	} mpd;
a1561 34
	case MODE_SENSE:
		AMI_DPRINTF(AMI_D_CMD, ("MODE SENSE tgt %d ", target));

		bzero(&mpd, sizeof mpd);
		switch (((struct scsi_mode_sense *)xs->cmd)->page) {
		case 4:
			/* scsi_disk.h says this should be 0x16 */
			mpd.dp.rigid_geometry.pg_length = 0x16;
			mpd.hd.data_length = sizeof mpd.hd -
			    sizeof mpd.hd.data_length + sizeof mpd.bd +
			    sizeof mpd.dp.rigid_geometry;
			mpd.hd.blk_desc_len = sizeof mpd.bd;

			mpd.hd.dev_spec = 0;	/* writeprotect ? XXX */
			_lto3b(AMI_SECTOR_SIZE, mpd.bd.blklen);
			mpd.dp.rigid_geometry.pg_code = 4;
			_lto3b(sc->sc_hdr[target].hd_size /
			    sc->sc_hdr[target].hd_heads /
			    sc->sc_hdr[target].hd_secs,
			    mpd.dp.rigid_geometry.ncyl);
			mpd.dp.rigid_geometry.nheads =
			    sc->sc_hdr[target].hd_heads;
			ami_copy_internal_data(xs, (u_int8_t *)&mpd,
			    sizeof mpd);
			break;

		default:
			printf("%s: mode sense page %d not simulated\n",
			    sc->sc_dev.dv_xname,
			    ((struct scsi_mode_sense *)xs->cmd)->page);
			xs->error = XS_DRIVER_STUFFUP;
		}
		break;

d1684 2
a1685 1
		AMI_DPRINTF(AMI_D_CMD, ("unknown opc %d ", xs->cmd->opcode));
@


1.73.2.1
log
@MFC:
Fixes by marco@@

ic/ami.c - rev 1.100

Prevent scsi pass-through busses from attaching when a board is marked
broken.

pci/ami_pci.c - rev 1.32

Add older card to quirk table.  This fixes the ccb timeout as reported by
J.C. Roberts <unknown at abac dot com> on misc@@.

ok deraadt@@ marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.73 2005/08/31 18:27:31 marco Exp $	*/
a603 4

	/* can't do pass-through on broken device for now */
	if (sc->sc_flags & AMI_BROKEN)
		return (0);
@


1.73.2.2
log
@MFC:
Fix by krw@@

Reduce the number of openings the logical devices have to play with so
that ioctl's and raw commands will not cause i/o failures. Assume a
max of two processors/enclosures per raw bus for the moment.

Fixes regular crashes on my 1 logical device, all-softdep system
during make build with a bioctl loop running.

ok deraadt@@ dlg@@ marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.73.2.1 2005/12/07 22:30:29 brad Exp $	*/
a542 9
			/*
			 * Reserve ccb's for ioctl's and raw commands to
			 * processors/enclosures by lowering the number of
			 * openings available for logical units.
			 */
			sc->sc_maxcmds -= AMI_MAXIOCTLCMDS + AMI_MAXPROCS *
			    AMI_MAXRAWCMDS * sc->sc_channels;
 

d626 1
a626 1
		rsc->sc_link.openings = AMI_MAXRAWCMDS;
@


1.72
log
@Fix some tsleep magic.  Code done by krw@@

feel free to commit, krw@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.71 2005/08/31 12:52:36 marco Exp $	*/
a2560 3

		if (p->apd[off].adp_ostatus != AMI_PD_UNCNF)
			goto bail;
@


1.71
log
@Make ioctls stop polling for completion.  This enhances the responsiveness
of the system.

tested and ok krw@@, dlg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.70 2005/08/30 02:40:25 dlg Exp $	*/
a162 1
		ccb->ccb_type = 0;
d174 2
a175 1
	ccb->ccb_type = 0;
a1238 3

			wakeup(ccb->ami_pt.idata);
			ccb->ami_pt.idata = NULL;
d1268 3
a1270 3
	if (ccb->ccb_type == AMI_MGMT_CCB) {
		wakeup(sc);
		ccb->ccb_type = 0;
d1328 1
d1435 1
d1453 3
d1481 4
a1484 2
	} else
		tsleep(ccb->ami_pt.idata, PRIBIO, "ami_pt", 0);
d1871 5
d1878 2
a1879 1
	    "ami mgmt")))
d1881 1
a1886 1
	ccb = ami_get_ccb(sc);
d1888 1
a1888 1
	ccb->ccb_type = AMI_MGMT_CCB;
d1917 6
a1922 4
		if (tsleep(sc, PRIBIO, "ami_drv_inq", 15 * hz) == EWOULDBLOCK) {
			error = EINVAL;
			goto bail;
		}
d1961 5
d1968 2
a1969 1
	    (size / NBPG) + 1, "ami mgmt")))
d1971 1
a1974 1
	ccb = ami_get_ccb(sc);
d1976 1
a1976 1
	ccb->ccb_type = AMI_MGMT_CCB;
d1998 6
a2003 4
		if (tsleep(sc, PRIBIO,"ami_mgmt", 15 * hz) == EWOULDBLOCK) {
			error = EINVAL;
			goto bail;
		}
@


1.70
log
@unfortunately large fixes to memleaks caused by abuse of incomplete
allocmem and freemem functions. freemem now unmaps dma memory from the
kernel address space instead of leaking it.

lots of tweaks and input from marco (who also found the bug in the first
place). lots of testing by krw and marco.

ok krw@@ marco@@ permitted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.69 2005/08/22 20:39:39 marco Exp $	*/
d163 1
d175 1
d184 1
a184 1
	AMI_DPRINTF(AMI_D_CMD, ("awi %xn", v));
d1271 5
a1282 2
		if (sc->sc_flags & AMI_CMDWAIT && TAILQ_EMPTY(&sc->sc_ccbq))
			wakeup(&sc->sc_free_ccb);
d1284 1
a1407 3
	while (sc->sc_flags & AMI_CMDWAIT)
		tsleep(&sc->sc_ccbq, PRIBIO + 1, "ami_raw", 0);

a1669 3
		while (sc->sc_flags & AMI_CMDWAIT)
			tsleep(&sc->sc_ccbq, PRIBIO + 1, "ami_cmd", 0);

d1809 1
a1809 12
	switch (cmd) {
	case BIOCINQ:
	case BIOCVOL:
	case BIOCDISK:
	case BIOCALARM:
	case BIOCSETSTATE:
		sc->sc_flags |= AMI_CMDWAIT;
		while (!TAILQ_EMPTY(&sc->sc_ccbq))
			if (tsleep(&sc->sc_free_ccb, PRIBIO, "ami_ioctl",
			    100 * 60) == EWOULDBLOCK)
				return EWOULDBLOCK;
	}
a1843 1
	wakeup(&sc->sc_ccbq);
d1878 1
d1906 17
a1922 2
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 1) == 0)
		memcpy(inqbuf, pp, sizeof(struct scsi_inquiry_data));
d1926 1
d1958 1
d1979 8
a1986 1
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 1) == 0) {
d1993 1
@


1.69
log
@Only let unused disks be marked hot spares.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.68 2005/08/18 04:49:52 marco Exp $	*/
d128 1
a128 1
void ami_freemem(bus_dma_tag_t dmat, bus_dmamap_t *map,
a129 1
void ami_dispose(struct ami_softc *sc);
d242 6
d252 1
a252 1
		return (NULL);
d259 1
a259 1
		return (NULL);
a261 6
	bzero(p, total);
	if ((error = bus_dmamap_create(dmat, total, 1,
	    total, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, map))) {
		printf(": cannot create %s dmamap (%d)\n", iname, error);
		return (NULL);
	}
d265 1
a265 1
		return (NULL);
d268 2
d271 9
d283 2
a284 1
ami_freemem(dmat, map, segp, isize, nent, iname)
d291 4
a300 17
ami_dispose(sc)
	struct ami_softc *sc;
{
	register struct ami_ccb *ccb;

	/* traverse the ccbs and destroy the maps */
	for (ccb = &sc->sc_ccbs[AMI_MAXCMDS - 1]; ccb > sc->sc_ccbs; ccb--)
		if (ccb->ccb_dmamap)
			bus_dmamap_destroy(sc->dmat, ccb->ccb_dmamap);
	ami_freemem(sc->dmat, &sc->sc_sgmap, sc->sc_sgseg,
	    sizeof(struct ami_sgent) * AMI_SGEPERCMD, AMI_MAXCMDS, "sglist");
	ami_freemem(sc->dmat, &sc->sc_cmdmap, sc->sc_cmdseg,
	    sizeof(struct ami_iocmd), AMI_MAXCMDS + 1, "command");
}


void
d340 1
a340 3
	    NBPG, 1, "init data"))) {
		ami_freemem(sc->dmat, &idatamap, idataseg,
		    NBPG, 1, "init data");
a341 1
	}
d345 3
a347 6
	if (!sc->sc_cmds) {
		ami_dispose(sc);
		ami_freemem(sc->dmat, &idatamap,
		    idataseg, NBPG, 1, "init data");
		return 1;
	}
d350 2
a351 6
	if (!sc->sc_sgents) {
		ami_dispose(sc);
		ami_freemem(sc->dmat, &idatamap,
		    idataseg, NBPG, 1, "init data");
		return 1;
	}
d373 1
a373 4
				ami_dispose(sc);
				ami_freemem(sc->dmat, &idatamap,
				    idataseg, NBPG, 1, "init data");
				return (1);
d460 1
a460 4
					ami_dispose(sc);
					ami_freemem(sc->dmat, &idatamap,
					    idataseg, NBPG, 1, "init data");
					return (1);
d550 1
a550 1
	ami_freemem(sc->dmat, &idatamap, idataseg, NBPG, 1, "init data");
d632 15
d1232 5
a1236 7
		if (xs->cmd->opcode != PREVENT_ALLOW &&
		    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize,
			    (xs->flags & SCSI_DATA_IN) ?
			    BUS_DMASYNC_POSTREAD :
			    BUS_DMASYNC_POSTWRITE);
d1238 10
a1247 10
			if (ccb->ami_pt.idata) {
				if (ccb->ami_pt.dir == AMI_PT_IN)
					memcpy(xs->data, ccb->ami_pt.idata +
					    sizeof(struct ami_passthrough),
					    xs->datalen);

				ccb->ami_pt.idata = NULL;
				ami_freemem(sc->dmat, &ccb->ami_pt.idatamap,
				    ccb->ami_pt.idataseg, NBPG, 1, "ami raw");
			}
d1326 3
d1414 1
a1414 2
	if (!(ccb->ami_pt.idata = ami_allocmem(sc->dmat,
	    &ccb->ami_pt.idatamap, ccb->ami_pt.idataseg, NBPG, 1,
d1423 1
d1425 3
a1427 2
	ps = ccb->ami_pt.idata;
	pa = ccb->ami_pt.idataseg[0].ds_addr;
d1451 1
a1451 1
	if ((error = ami_cmd(ccb, ((xs->flags & SCSI_NOSLEEP)?
d1453 2
a1455 2
		ami_freemem(sc->dmat, &ccb->ami_pt.idatamap,
		    ccb->ami_pt.idataseg, NBPG, 1, "ami raw");
a1462 1

d1465 1
a1465 2
			type = *((char *)ccb->ami_pt.idata + sizeof *ps) &
			    SID_TYPE;
d1472 2
d1475 3
d1479 1
a1479 12
		if (ccb->ami_pt.dir == AMI_PT_IN)
			memcpy(xs->data, ccb->ami_pt.idata + sizeof *ps,
			    xs->datalen);

		ccb->ami_pt.idata = NULL;
		ami_freemem(sc->dmat, &ccb->ami_pt.idatamap,
		    ccb->ami_pt.idataseg, NBPG, 1, "ami raw");

		scsi_done(xs);
		AMI_UNLOCK_AMI(sc, lock);
		return (COMPLETE);
	}
d1482 1
a1482 1
	return (SUCCESSFULLY_QUEUED);
d1881 2
a1882 4
	    "ami mgmt"))) {
	    	error = ENOMEM;
		goto bail;
	}
d1922 1
a1922 2
bail:
	ami_freemem(sc->dmat, &idatamap, idataseg, NBPG, 1, "ami mgmt");
d1946 2
a1947 4
	    (size / NBPG) + 1, "ami mgmt"))) {
	    	error = ENOMEM;
		goto bail;
	}
d1980 2
a1981 3
bail:;
	ami_freemem(sc->dmat, &idatamap, idataseg, NBPG, (size / NBPG) + 1,
	    "ami mgmt");
@


1.68
log
@Add "create hot spare" ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.67 2005/08/17 21:49:14 marco Exp $	*/
d2517 3
d2531 21
d2566 5
@


1.67
log
@Add additional paramter to ami_mgmt so that we can start support "set hdd state".
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.66 2005/08/17 20:31:18 marco Exp $	*/
d151 1
d1823 1
d1851 6
a1856 1
		
d2497 1
a2497 1
		error = EINVAL;
d2509 33
@


1.66
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.65 2005/08/17 19:38:27 marco Exp $	*/
d139 1
a139 1
int ami_mgmt(struct ami_softc *, u_int8_t, u_int8_t, u_int8_t,
d1933 1
a1933 1
ami_mgmt(sc, opcode, par1, par2, size, buffer)
d1938 1
d1975 1
d1980 4
a1983 2
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 1) == 0)
		memcpy(buffer, idata, size);
d2020 1
a2020 1
	if (ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, sizeof *p, p)) {
d2279 1
a2279 1
	if (ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, sizeof *p, p)) {
d2365 1
a2365 1
	if (ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, sizeof *p, p)) {
d2493 1
a2493 1
	if (ami_mgmt(sc, AMI_SPEAKER, func, 0, sizeof ret, &ret))
@


1.65
log
@Cleanup up hot spare and unsused disk code. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.64 2005/08/17 15:39:03 marco Exp $	*/
d525 1
a525 2
		}
		else {
d543 1
a543 2
			}
			else {
d553 1
a553 2
		}
		else {
d870 1
a870 2
	}
	else /* need to clean up ccb ourselves */
d1083 1
a1083 2
	}
	else if ((error = ami_start(ccb, wait))) {
@


1.64
log
@Move WRITE_BUFFER to appropriate spot.  Bad dlg@@
Add SEND_DIAGNOSTIC as valid command.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.63 2005/08/17 06:41:06 dlg Exp $	*/
d144 1
a144 1
int ami_sparevol(struct ami_softc *, struct bioc_vol *,
d146 1
a146 5
int ami_unusedvol(struct ami_softc *, struct bioc_vol *,
    struct ami_big_diskarray *);
int ami_sparedisk(struct ami_softc *, struct bioc_disk *,
    struct ami_big_diskarray *);
int ami_unuseddisk(struct ami_softc *, struct bioc_disk *,
d2047 7
d2056 3
a2058 11
		/* count global hotspares as volumes */
		if (p->apd[i].adp_ostatus == AMI_PD_HOTSPARE
		    && p->apd[i].adp_type == 0) {
			bi->bi_novol++;

			if (!plist[i]) {
				plist[i] = 1;
				bi->bi_nodisk++;
			}

		}
d2060 3
a2062 6
		/*
		 * hack warning!
		 * Megaraid cards sometimes return a size in the PD structure
		 * even though there is no disk in that slot.  Work around
		 * that by issuing an INQUIRY to determine if there is
		 * an actual disk in the slot.
a2063 2

		/* count unused disks as a volume too */
d2069 3
a2071 6
				if (!plist[i]) {
					/* if it isnt claimed its unused */
					bi->bi_novol++;
					plist[i] = 1;
					bi->bi_nodisk++;
				}
d2085 1
a2085 33
ami_sparevol(sc, bv, p)
	struct ami_softc *sc;
	struct bioc_vol *bv;
	struct ami_big_diskarray *p;
{
	int i;
	int ld = p->ada_nld;

	for(i = 0; i < ((sc->sc_flags & AMI_QUARTZ) ?
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++)
		if (p->apd[i].adp_ostatus == AMI_PD_HOTSPARE
		    && p->apd[i].adp_type == 0) {
			if (ld == bv->bv_volid) {
				/* found hs, fake data */
				bv->bv_status = BIOC_SVONLINE;
				bv->bv_size = (u_quad_t)p->apd[i].adp_size *
				    (u_quad_t)512;
				bv->bv_level = -1;
				bv->bv_nodisk = 1;
				strlcpy(bv->bv_dev,
				    sc->sc_hdr[bv->bv_volid].dev,
				    sizeof(bv->bv_dev));

				return (0);
			}
			ld++;
		}

	return (EINVAL);
}

int
ami_unusedvol(sc, bv, p)
d2092 2
a2093 3
	int error = EINVAL;
	int i;
	int ld = p->ada_nld;
d2104 10
a2113 8
	for(i = 0; i < ((sc->sc_flags & AMI_QUARTZ) ?
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++) {
		/* skip hot spares and adjust counter and mark them used */
		if (p->apd[i].adp_ostatus == AMI_PD_HOTSPARE
		    && p->apd[i].adp_type == 0) {
			if (!plist[i]) {
				plist[i] = 1;
				ld++;
a2115 12
			continue;
		}

		/* skip everything else that is in use */
		if (p->apd[i].adp_ostatus != BIOC_SDONLINE) {
			if (!plist[i])
				plist[i] = 1;

			continue;
		}
	}

d2118 2
a2119 1
		if (plist[i])
d2122 4
d2131 17
a2147 5
				if (ld == bv->bv_volid) {
					/* if it isnt claimed its unused */
					bv->bv_status = BIOC_SVONLINE;
					bv->bv_size = (u_quad_t)
					    p->apd[i].adp_size * (u_quad_t)512;
a2148 4
					bv->bv_nodisk = 1;
					strlcpy(bv->bv_dev,
					    sc->sc_hdr[bv->bv_volid].dev,
					    sizeof(bv->bv_dev));
d2150 2
a2151 4
					error = 0;
					goto bail;
				}
				ld++;
a2161 1
/* XXX consolidate this with ami_sparevol() */
d2163 1
a2163 1
ami_sparedisk(sc, bd, p)
d2170 3
a2172 2
	int i;
	int ld = p->ada_nld;
d2175 20
d2197 3
a2199 6
		if (p->apd[i].adp_ostatus == AMI_PD_HOTSPARE
		    && p->apd[i].adp_type == 0) {
			if (ld == bd->bd_volid) {
				bd->bd_status = BIOC_SDHOTSPARE;
				bd->bd_size = (u_quad_t)p->apd[i].adp_size *
				    (u_quad_t)512;
d2201 7
a2207 2
				ch = (i & 0xf0) >> 4;
				tg = i & 0x0f;
d2209 2
d2212 4
a2215 2
				if (!ami_drv_inq(sc, ch, tg, 0, &inqbuf)) {
					char vend[8+16+4+1];
d2217 2
a2218 2
					bcopy(inqbuf.vendor, vend,
					    sizeof vend - 1);
d2220 3
a2222 4
					vend[sizeof vend - 1] = '\0';
					strlcpy(bd->bd_vendor, vend,
					    sizeof(bd->bd_vendor));
				}
d2237 3
d2247 4
a2250 91
				return (0);
			}
			ld++;
		}
	}

	return (EINVAL);
}

/* XXX consolidate this with ami_unusedvol() */
int
ami_unuseddisk(sc, bd, p)
	struct ami_softc *sc;
	struct bioc_disk *bd;
	struct ami_big_diskarray *p;
{
	struct scsi_inquiry_data inqbuf;
	struct scsi_inquiry_vpd vpdbuf;
	char *plist;
	int error = EINVAL;
	int i;
	int ld = p->ada_nld;
	u_int8_t ch, tg;

	plist = malloc(AMI_BIG_MAX_PDRIVES, M_DEVBUF, M_NOWAIT);
	if (!plist) {
		printf("%s: no memory for disk list\n",sc->sc_dev.dv_xname);
		return (ENOMEM);
	}

	memset(plist, 0, AMI_BIG_MAX_PDRIVES);

	for(i = 0; i < ((sc->sc_flags & AMI_QUARTZ) ?
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++) {
		/* skip hot spares and adjust counter and mark them used */
		if (p->apd[i].adp_ostatus == AMI_PD_HOTSPARE
		    && p->apd[i].adp_type == 0) {
			if (!plist[i]) {
				plist[i] = 1;
				ld++;
			}

			continue;
		}

		/* skip everything else that is in use */
		if (p->apd[i].adp_ostatus != BIOC_SDONLINE) {
			if (!plist[i])
				plist[i] = 1;

			continue;
		}
	}

	for(i = 0; i < ((sc->sc_flags & AMI_QUARTZ) ?
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++) {
		if (plist[i])
			continue;

		if (p->apd[i].adp_size) {
			ch = (i & 0xf0) >> 4;
			tg = i & 0x0f;

			if (!ami_drv_inq(sc, ch, tg, 0, &inqbuf)) {
				if (ld == bd->bd_volid) {
					/* if it isnt claimed its unused */
					char vend[8+16+4+1];

					bcopy(inqbuf.vendor, vend,
					    sizeof vend - 1);

					vend[sizeof vend - 1] = '\0';
					strlcpy(bd->bd_vendor, vend,
					    sizeof(bd->bd_vendor));

					if (!ami_drv_inq(sc, ch, tg, 0x80,
					    &vpdbuf)) {
						char ser[32 + 1];

						bcopy(vpdbuf.serial, ser,
						    sizeof ser - 1);

						ser[sizeof ser - 1] = '\0';
						if (vpdbuf.page_length <
						    sizeof ser)
							ser[vpdbuf.page_length] = '\0';
						strlcpy(bd->bd_serial, ser,
						    sizeof(bd->bd_serial));
					}


a2251 10
					bd->bd_size = (u_quad_t)
					    p->apd[i].adp_size *
					    (u_quad_t)512;

					bd->bd_channel = ch;
					bd->bd_target = tg;

					strlcpy(bd->bd_procdev,
					    sc->sc_rawsoftcs[ch].sc_procdev,
					    sizeof(bd->bd_procdev));
d2253 2
a2254 4
					error = 0;
					goto bail;
				}
				ld++;
d2286 1
a2286 7
		/* is this a hot spare? */
		error = ami_sparevol(sc, bv, p);
		if (error == 0)
			goto bail;

		/* is this an unused disk? */
		error = ami_unusedvol(sc, bv, p);
d2372 1
a2372 7
		/* is this a hot spare? */
		error = ami_sparedisk(sc, bd, p);
		if (error == 0)
			goto bail;

		/* is this an unused disk? */
		error = ami_unuseddisk(sc, bd, p);
@


1.63
log
@WRITE_BUFFER is a valid command to make it to the passthru busses. make
the unsupported command printf use hex instead of decimal when printing
while im here so i dont have to think and do maths to figure out what
it is complaining about

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.62 2005/08/17 06:31:01 marco Exp $	*/
d1357 2
a1367 1
	case WRITE_BUFFER:
@


1.62
log
@Add support for unused disks.
Fix SCSI string madness (by deraadt).
Add some debug statements in bioctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.61 2005/08/17 06:23:52 marco Exp $	*/
d1366 1
d1378 2
a1379 2
		printf("%s: unsupported command(%d)\n", sc->sc_dev.dv_xname,
		    xs->cmd->opcode);
@


1.61
log
@ARGH! undo commit because i used the wrong tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.59 2005/08/16 01:12:46 marco Exp $	*/
d144 1
a144 1
int ami_global_hsvol(struct ami_softc *, struct bioc_vol *,
d146 5
a150 1
int ami_global_hsdisk(struct ami_softc *, struct bioc_disk *,
d2007 2
a2048 1
	/* count global hotspares as volumes */
d2050 2
a2051 1
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++)
d2060 24
d2085 1
d2096 1
a2096 1
ami_global_hsvol(sc, bv, p)
d2128 80
a2207 1
ami_global_hsdisk(sc, bd, p)
d2219 1
a2219 1
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++)
d2230 9
a2238 2
				if (!ami_drv_inq(sc, ch, tg, 0, &inqbuf))
					strlcpy(bd->bd_vendor, inqbuf.vendor,
d2240 4
d2245 7
a2251 5
				if (!ami_drv_inq(sc, ch, tg, 0x80, &vpdbuf))
					strlcpy(bd->bd_serial, vpdbuf.serial,
					    vpdbuf.page_length <
					    sizeof(bd->bd_serial) ?
					    vpdbuf.page_length :
d2253 1
d2266 1
d2271 108
d2400 7
a2406 2
		/* is this a global hot spare? */
		error = ami_global_hsvol(sc, bv, p);
a2453 2
	/* XXX adjust disk count to account for dedicated hot spares */

d2492 7
a2498 1
		error = ami_global_hsdisk(sc, bd, p);
d2547 7
a2553 2
			if (!ami_drv_inq(sc, ch, tg, 0, &inqbuf))
				strlcpy(bd->bd_vendor, inqbuf.vendor,
d2555 1
d2557 2
a2558 4
			if (!ami_drv_inq(sc, ch, tg, 0x80, &vpdbuf))
				strlcpy(bd->bd_serial, vpdbuf.serial,
				    vpdbuf.page_length < sizeof(bd->bd_serial) ?
				    vpdbuf.page_length : sizeof(bd->bd_serial));
d2560 8
@


1.60
log
@Add support for unused disks.
Fix SCSI string madness (by deraadt).
Add some debug statements in bioctl.
@
text
@a2002 2
	struct scsi_inquiry_data inqbuf;
	u_int8_t ch, tg;
d2043 1
a2043 1
	//printf("before bi->bi_novol: %d   bi->bi_nodisk %d\n", bi->bi_novol, bi->bi_nodisk);
d2045 1
a2045 2
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++) {
		/* count global hotspares as volumes */
a2053 1

a2055 17
		/* count unused disks as a volume too */
		if (p->apd[i].adp_size) {
			ch = (i & 0xf0) >> 4;
			tg = i & 0x0f;

			if (!ami_drv_inq(sc, ch, tg, 0, &inqbuf)) {
				if (!plist[i]) {
					/* if it isnt claimed its unused */
					bi->bi_novol++;

					plist[i] = 1;
					bi->bi_nodisk++;
				}
			}
		}
	}

d2109 1
a2109 10
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++) {
		/*
		printf("%02x: type: %u status: %u tag: %u sneg: %u size: %u\n",
		i,
		p->apd[i].adp_type,
		p->apd[i].adp_ostatus,
		p->apd[i].adp_tagdepth,
		p->apd[i].adp_sneg,
		p->apd[i].adp_size);
		*/
d2122 1
a2122 1
					    sizeof(bd->bd_vendor) -3);
a2141 1
	}
d2307 1
a2307 1
				    sizeof(bd->bd_vendor) -3);
@


1.59
log
@Fix a few retardos.  Yelled at by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.58 2005/08/15 23:22:45 marco Exp $	*/
d2003 2
d2045 1
a2045 1
	/* count global hotspares as volumes */
d2047 2
a2048 1
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++)
d2057 1
d2060 17
d2130 10
a2139 1
	    AMI_BIG_MAX_PDRIVES : AMI_MAX_PDRIVES); i++)
d2152 1
a2152 1
					    sizeof(bd->bd_vendor));
d2172 1
d2338 1
a2338 1
				    sizeof(bd->bd_vendor));
@


1.58
log
@Add global hot spare support.
Add flag to determine controller type.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.57 2005/08/09 14:29:18 marco Exp $	*/
d2122 1
a2122 1
					    8 + 16 + 4 + 1);
d2307 1
a2307 1
				    8 + 16 + 4 + 1); /* vendor prod rev zero */
@


1.57
log
@Provide HDD serial numbers to bio.  Requested deraadt@@ ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.56 2005/08/08 20:23:46 marco Exp $	*/
d144 4
a2039 1

d2043 13
d2065 82
d2166 3
a2168 2
	if (bv->bv_volid > p->ada_nld) {
		error = EINVAL;
d2216 2
d2255 2
a2256 2
	if (bd->bd_volid > p->ada_nld) {
		error = EINVAL;
d2263 1
a2263 1
	for (s = 0, d = 0; s < p->ald[i].adl_spandepth; s++) {
a2323 1
	}
d2325 1
@


1.56
log
@Add ses link.  Tested and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.55 2005/08/08 04:02:31 deraadt Exp $	*/
d141 1
a141 1
int ami_drv_inq(struct ami_softc *, u_int8_t, u_int8_t, void *);
d1864 1
a1864 1
ami_drv_inq(sc, ch, tg, inqbuf)
d1868 1
d1912 5
d2136 1
d2204 1
a2204 1
			if (!ami_drv_inq(sc, ch, tg, &inqbuf))
d2207 6
@


1.55
log
@rename a bunch of bio/raid APIs to stop the bleeding in dlg and
my eyes; marco ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.54 2005/08/08 03:11:36 marco Exp $	*/
d639 1
d1324 1
d1360 5
d1470 2
d1474 1
d2203 3
@


1.54
log
@Add devices to structures.

ok and help deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.53 2005/08/05 04:16:51 marco Exp $	*/
d143 4
a146 4
int ami_ioctl_inq(struct ami_softc *, bioc_inq *);
int ami_ioctl_vol(struct ami_softc *, bioc_vol *);
int ami_ioctl_disk(struct ami_softc *, bioc_disk *);
int ami_ioctl_alarm(struct ami_softc *, bioc_alarm *);
d1821 1
a1821 1
		error = ami_ioctl_inq(sc, (bioc_inq *)addr);
d1826 1
a1826 1
		error = ami_ioctl_vol(sc, (bioc_vol *)addr);
d1831 1
a1831 1
		error = ami_ioctl_disk(sc, (bioc_disk *)addr);
d1836 1
a1836 1
		error = ami_ioctl_alarm(sc, (bioc_alarm *)addr);
d1976 1
a1976 1
	bioc_inq *bi;
d2004 2
a2005 2
	bi->novol = p->ada_nld;
	bi->nodisk = 0;
d2007 1
a2007 1
	strlcpy(bi->dev, sc->sc_dev.dv_xname, sizeof(bi->dev));
d2019 1
a2019 1
					bi->nodisk++;
d2035 1
a2035 1
	bioc_vol *bv;
d2052 1
a2052 1
	if (bv->volid > p->ada_nld) {
d2057 1
a2057 1
	i = bv->volid;
d2061 1
a2061 1
		bv->status = BIOC_SVOFFLINE;
d2065 1
a2065 1
		bv->status = BIOC_SVDEGRADED;
d2069 1
a2069 1
		bv->status = BIOC_SVONLINE;
d2073 1
a2073 1
		bv->status = BIOC_SVINVALID;
d2076 3
a2078 3
	bv->size = 0;
	bv->level = p->ald[i].adl_raidlvl;
	bv->nodisk = 0;
d2082 1
a2082 1
			bv->nodisk++;
d2084 1
a2084 1
		switch (bv->level) {
d2086 1
a2086 1
			bv->size += p->ald[i].asp[s].ads_length *
d2091 1
a2091 1
			bv->size += p->ald[i].asp[s].ads_length;
d2095 1
a2095 1
			bv->size += p->ald[i].asp[s].ads_length *
d2102 1
a2102 1
		bv->level *= 10;
d2104 1
a2104 1
	bv->size *= (u_quad_t)512;
d2106 1
a2106 1
	strlcpy(bv->dev, sc->sc_hdr[i].dev, sizeof(bv->dev));
d2117 1
a2117 1
	bioc_disk *bd;
d2137 1
a2137 1
	if (bd->volid > p->ada_nld) {
d2142 1
a2142 1
	i = bd->volid;
d2147 1
a2147 1
			if (d != bd->diskid) {
d2158 1
a2158 1
				bd->status = BIOC_SDUNUSED;
d2162 1
a2162 1
				bd->status = BIOC_SDONLINE;
d2166 1
a2166 1
				bd->status = BIOC_SDFAILED;
d2170 1
a2170 1
				bd->status = BIOC_SDREBUILD;
d2174 1
a2174 1
				bd->status = BIOC_SDHOTSPARE;
d2178 1
a2178 1
				bd->status = BIOC_SDINVALID;
d2181 1
a2181 1
			bd->size = (u_quad_t)p->apd[off].adp_size *
d2188 1
a2188 1
				strlcpy(bd->vendor, inqbuf.vendor,
d2191 2
a2192 2
			bd->channel = ch;
			bd->target = tg;
d2207 1
a2207 1
	bioc_alarm *ba;
d2212 1
a2212 1
	switch(ba->opcode) {
d2235 1
a2235 1
		    sc->sc_dev.dv_xname, ba->opcode));
d2242 2
a2243 2
		if (ba->opcode == BIOC_GASTATUS)
			ba->status = ret;
d2245 1
a2245 1
			ba->status = 0;
@


1.53
log
@Add support for SCSI pass-through commands for enclosure and processor devices
to expose ses(4) and safte(4) information.

ok beck@@, dlg@@
put your ami pt diff in, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.52 2005/08/01 16:39:10 marco Exp $	*/
d1488 1
d1525 5
d1775 1
d2007 2
d2104 1
a2104 1
	bv->size *= (quad_t)512;
d2106 2
d2124 1
d2181 2
a2182 1
			bd->size = (quad_t)p->apd[off].adp_size * (quad_t)512;
d2184 4
a2187 4
			if (!ami_drv_inq(sc,
			    (p->ald[i].asp[s].adv[t].add_target >> 4),
			    (p->ald[i].asp[s].adv[t].add_target & 0x0f),
			    &inqbuf)) {
d2190 3
a2192 1
			}
@


1.52
log
@Add alarm control.

Fix buglet where ami does not count physical drives correctly.
Reported by Stephan Tesch stephan at tesch dot cx
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.51 2005/07/29 16:59:26 marco Exp $	*/
d325 1
a325 1
	/* struct ami_rawsoftc *rsc; */
a618 1
#if 0
d640 2
a641 2
		rsc->sc_link.adapter_target = sc->sc_targets;
		rsc->sc_link.adapter_buswidth = sc->sc_targets;
d645 1
a645 1
#endif
d1241 12
d1323 1
a1323 1
	struct ami_ccb *ccb, *ccb1;
d1327 1
d1329 2
d1336 38
d1386 9
d1407 4
a1410 2
	if ((ccb1 = ami_get_ccb(sc)) == NULL) {
		ami_put_ccb(ccb);
d1417 6
a1423 1
	ccb->ccb_ccb1 = ccb1;
d1425 2
a1426 3
	ccb->ccb_data = xs->data;

	ps = (struct ami_passthrough *)ccb1->ccb_cmd;
d1433 2
d1438 4
a1441 1
	cmd->acc_passthru.apt_data = ccb1->ccb_cmdpa;
d1445 3
d1449 4
a1452 11
		AMI_DPRINTF(AMI_D_CMD, ("failed %p ", xs));
		if (xs->flags & SCSI_POLL) {
			xs->error = XS_TIMEOUT;
			AMI_UNLOCK_AMI(sc, lock);
			return (TRY_AGAIN_LATER);
		} else {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			AMI_UNLOCK_AMI(sc, lock);
			return (COMPLETE);
		}
d1457 16
a1670 1
		ccb->ccb_ccb1 = NULL;
@


1.51
log
@oops don't leak memory when ami_mgmt fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.50 2005/07/29 16:56:13 marco Exp $	*/
d146 1
d1720 1
d1744 5
d1855 14
a1868 2
	cmd->acc_io.aio_channel = par1;
	cmd->acc_io.aio_param = par2;
d1912 1
a1912 1
	memset(plist, 0, sizeof plist);
d2103 45
@


1.50
log
@Per art's email, don't keep something bigger than > 256 bytes on the stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.49 2005/07/29 16:01:30 marco Exp $	*/
d1890 1
a1890 1
		goto bail;
d1913 1
@


1.49
log
@Redo bioctl because initial implementation was too complex.

tested and ok dlg@@ beck@@
get it in @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.47 2005/07/18 01:29:01 marco Exp $	*/
a1868 1
	char plist[AMI_BIG_MAX_PDRIVES];
d1870 1
d1877 1
a1877 1
		printf("%s: no memory for raw interface\n",sc->sc_dev.dv_xname);
d1881 7
d1913 1
@


1.48
log
@revert marcos bio changes, mickey not ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.46 2005/07/03 22:31:27 krw Exp $	*/
d139 3
d143 3
a145 4
int ami_ioctl_alarm(struct ami_softc *, bioc_alarm *);
int ami_ioctl_startstop( struct ami_softc *, bioc_startstop *);
int ami_ioctl_status( struct ami_softc *, bioc_status *);
int ami_ioctl_passthru(struct ami_softc *, bioc_scsicmd *);
d1685 1
a1699 1
	int error = 0;
d1702 1
d1704 1
a1704 1
	/* FIXME do we need to test for sc_dis_poll? */
d1716 3
a1718 5
	case BIOCALARM:
	case BIOCBLINK:
	case BIOCSTARTSTOP:
	case BIOCSTATUS:
	case BIOCSCSICMD:
d1727 3
a1729 35
	case BIOCPING:
		((bioc_ping *)addr)->x++;

		AMI_DPRINTF(AMI_D_IOCTL, ("%s: biocping: %x\n",
		    sc->sc_dev.dv_xname, ((bioc_ping *)addr)->x));
		break;

	case BIOCCAPABILITIES:
		((bioc_capabilities *)addr)->ioctls =
		    BIOC_ALARM | BIOC_PING | BIOC_SCSICMD | BIOC_STARTSTOP |
		    BIOC_STATUS | BIOC_BLINK;

		((bioc_capabilities *)addr)->raid_types =
		    BIOC_RAID0 | BIOC_RAID1 | BIOC_RAID5 |
		    BIOC_RAID10 | BIOC_RAID50;

		AMI_DPRINTF(AMI_D_IOCTL, ("%s: bioccapabilities:  ioctls: "
		    "%016llx raid_types: %08lx\n",
		    sc->sc_dev.dv_xname,
		    ((bioc_capabilities *)addr)->ioctls,
		    ((bioc_capabilities *)addr)->raid_types));
		break;

	case BIOCALARM:
		error = ami_ioctl_alarm(sc, (bioc_alarm *)addr);
		break;

	case BIOCBLINK:
		error = EOPNOTSUPP; /* let userland land knows it must issue
				   * a cdb to handle blinking. */
		break;

	case BIOCSTARTSTOP:
		AMI_DPRINTF(AMI_D_IOCTL, ("start stop unit\n"));
		error = ami_ioctl_startstop(sc, (bioc_startstop *)addr);
d1732 3
a1734 3
	case BIOCSTATUS:
		AMI_DPRINTF(AMI_D_IOCTL, ("status\n"));
		error = ami_ioctl_status(sc, (bioc_status *)addr);
d1737 3
a1739 3
	case BIOCSCSICMD:
		AMI_DPRINTF(AMI_D_IOCTL, ("scsi cmd\n"));
		error = ami_ioctl_passthru(sc, (bioc_scsicmd *)addr);
d1757 1
a1757 1
ami_ioctl_alarm(sc, ra)
d1759 3
a1761 1
	bioc_alarm *ra;
d1763 1
a1763 2
	int error = 0;
	struct ami_ccb	*ccb;
d1765 3
a1767 1
	void	*idata;
d1771 1
a1771 2
	u_int8_t *p;

d1773 4
a1776 5
	if (!(idata = ami_allocmem(sc->dmat, &idatamap, idataseg,
	    NBPG, 1, "ioctl data"))) {
		ami_freemem(sc->dmat, &idatamap, idataseg,
		    NBPG, 1, "ioctl data");
		return ENOMEM;
d1780 2
a1781 1
	p = idata;
d1787 2
a1788 4
	cmd->acc_cmd = AMI_ALARM;
	cmd->acc_io.aio_channel = 0;
	cmd->acc_io.aio_param = 0;
	cmd->acc_io.aio_data = htole32(pa);
d1790 1
a1790 4
	switch(ra->opcode) {
	case BIOCSALARM_DISABLE:
		*p = AMI_ALARM_OFF;
		break;
d1792 11
a1802 25
	case BIOCSALARM_ENABLE:
		*p = AMI_ALARM_ON;
		break;

	case BIOCSALARM_SILENCE:
		*p = AMI_ALARM_QUIET;
		break;

	case BIOCGALARM_STATE:
		*p = AMI_ALARM_GET;
		break;

	case BIOCSALARM_TEST:
		*p = AMI_ALARM_TEST;
		break;

	default:
		AMI_DPRINTF(AMI_D_IOCTL, ("%s: biocalarm invalid opcode %x\n",
		    sc->sc_dev.dv_xname, ra->opcode));
		ami_put_ccb(ccb);
		return EINVAL;
	}

	AMI_DPRINTF(AMI_D_IOCTL, ("%s: biocalarm: in: %x ",
	    sc->sc_dev.dv_xname, *p));
d1804 2
d1807 3
a1809 9
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 1) == 0) {
		AMI_DPRINTF(AMI_D_IOCTL, ("out %x\n", *p));
		if (ra->opcode == BIOCGALARM_STATE)
			ra->state = *p;
		else
			ra->state = 0;
	}
	else {
		AMI_DPRINTF(AMI_D_IOCTL, ("failed\n"));
a1810 1
	}
d1812 2
a1813 1
	ami_freemem(sc->dmat, &idatamap, idataseg, NBPG, 1, "ioctl data");
d1819 1
a1819 1
ami_ioctl_startstop(sc, bs)
d1821 5
a1825 1
	bioc_startstop *bs;
d1827 6
d1834 8
a1841 2
	struct ami_ccb	*ccb;
	struct ami_iocmd *cmd;
d1847 4
a1850 2
	AMI_DPRINTF(AMI_D_IOCTL, ("start/stop %d unit %d %d\n",
	    bs->opcode, bs->channel, bs->target));
d1852 2
a1853 4
	if (bs->opcode == BIOCSUNIT_START)
		cmd->acc_cmd = AMI_STARTU;
	else if (bs->opcode == BIOCSUNIT_STOP)
		cmd->acc_cmd = AMI_STOPU;
d1855 1
a1855 1
		return EINVAL;
d1857 3
a1859 14
	/* FIXME test if channel and target are in range */
	cmd->acc_io.aio_channel = bs->channel;
	cmd->acc_io.aio_param = bs->target;
	cmd->acc_io.aio_pad[0] = AMI_STARTU_SYNC;
	cmd->acc_io.aio_data = NULL;

	if (ami_cmd(ccb, BUS_DMA_WAITOK, 1) == 0) {
		AMI_DPRINTF(AMI_D_IOCTL, ("%s\n",
		    bs->opcode  == BIOCSUNIT_START ? "started" : "stopped"));
	}
	else {
		AMI_DPRINTF(AMI_D_IOCTL, ("failed\n"));
		error = EINVAL;
	}
d1865 1
a1865 1
ami_ioctl_status(sc, bs)
d1867 1
a1867 1
	bioc_status *bs;
d1869 4
a1873 7
	struct ami_ccb	*ccb;
	struct ami_iocmd *cmd;
	void	*idata;
	bus_dmamap_t idatamap;
	bus_dma_segment_t idataseg[1];
	paddr_t	pa;
	u_int8_t *p;
d1875 9
a1883 5
	if (!(idata = ami_allocmem(sc->dmat, &idatamap, idataseg,
	    NBPG, 1, "ioctl data"))) {
		ami_freemem(sc->dmat, &idatamap, idataseg,
		    NBPG, 1, "ioctl data");
		return ENOMEM;
d1886 1
a1886 2
	pa = idataseg[0].ds_addr;
	p = idata;
d1888 2
a1889 3
	ccb = ami_get_ccb(sc);
	ccb->ccb_data = NULL;
	cmd = ccb->ccb_cmd;
d1891 7
a1897 4
	cmd->acc_cmd = AMI_FCOP;
	cmd->acc_io.aio_channel = AMI_FC_EINQ3;
	cmd->acc_io.aio_param = AMI_FC_EINQ3_SOLICITED_FULL;
	cmd->acc_io.aio_data = htole32(pa);
d1899 3
a1901 1
	AMI_DPRINTF(AMI_D_IOCTL, ("status %d\n", bs->opcode));
d1903 2
a1904 7
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 1) == 0) {
		AMI_DPRINTF(AMI_D_IOCTL, ("success\n"));
	}
	else {
		AMI_DPRINTF(AMI_D_IOCTL, ("failed\n"));
		error = EINVAL;
	}
d1906 2
a1907 1
	ami_freemem(sc->dmat, &idatamap, idataseg, NBPG, 1, "ioctl data");
d1913 1
a1913 1
ami_ioctl_passthru(sc, bp)
d1915 1
a1915 1
	bioc_scsicmd *bp;
d1917 2
a1919 7
	struct ami_ccb	*ccb;
	struct ami_iocmd *cmd;
	struct ami_passthrough *ps;
	void	*idata;
	bus_dmamap_t idatamap;
	bus_dma_segment_t idataseg[1];
	paddr_t	pa;
d1921 10
a1930 3
#ifdef AMI_DEBUG
	u_int8_t i = 0;
#endif /* AMI_DEBUG */
d1932 4
a1935 1
	AMI_DPRINTF(AMI_D_IOCTL, ("in passthrough\n"));
d1937 1
a1937 2
	/* FIXME: validate channel/target pair, or let the firmware bomb it?
	 */
d1939 4
a1942 2
	if (bp->cdblen > BIOC_MAX_CDB)
		return (EINVAL);
d1944 3
a1946 4
	if (bp->direction == BIOC_DIRIN &&
	    (bp->datalen == 0 || bp->data == NULL))
		/* if userland expects data give us a len and a pointer */
		return (EINVAL);
d1948 3
a1950 2
	if (bp->datalen > 1024)
		return (EINVAL); /* cap at 1k for now */
d1952 2
a1953 5
	if (!(idata = ami_allocmem(sc->dmat, &idatamap, idataseg,
	    NBPG, 1, "ioctl data"))) {
		ami_freemem(sc->dmat, &idatamap, idataseg,
		    NBPG, 1, "ioctl data");
		return (ENOMEM);
d1956 24
a1979 2
	pa = idataseg[0].ds_addr;
	ps = idata;
d1981 2
a1982 3
	ccb = ami_get_ccb(sc);
	ccb->ccb_data = NULL;
	cmd = ccb->ccb_cmd;
d1984 1
a1984 2
	cmd->acc_cmd = AMI_PASSTHRU;
	cmd->acc_passthru.apt_data = htole32(pa);
d1986 2
a1987 1
	memset(ps, 0, sizeof *ps);
d1989 2
a1990 5
	ps->apt_channel = bp->channel;
	ps->apt_target = bp->target;
	ps->apt_ncdb = bp->cdblen;
	ps->apt_nsense = BIOC_MAX_SENSE; /* do not let userland dictate this */
	memcpy(&ps->apt_cdb[0], &bp->cdb[0], bp->cdblen);
d1992 10
a2001 2
	ps->apt_data = htole32(pa + sizeof *ps);
	ps->apt_datalen = bp->datalen;
d2003 4
a2006 3
	if (bp->direction == BIOC_DIROUT) {
		/* userland sent us some data */
		copyin(bp->data, idata + sizeof *ps, ps->apt_datalen);
d2009 4
a2012 5
#ifdef AMI_DEBUG
	AMI_DPRINTF(AMI_D_IOCTL, ("%s: ps->apt_channel: %x, ps->apt_target: %x "
	    "ps->apt_cdblen: %x ps->apt_data: %x ps->apt_datalen: %x\n%s: cdb: "
	    , sc->sc_dev.dv_xname, ps->apt_channel, ps->apt_target,
	    ps->apt_ncdb, ps->apt_data, ps->apt_datalen, sc->sc_dev.dv_xname));
d2014 3
a2016 2
	for (i = 0; i < ps->apt_ncdb; i++) {
		printf("%0x ", ps->apt_cdb[i]);
a2017 2
	printf("\n");
#endif /* AMI_DEBUG */
d2019 38
a2056 20
	if (ami_cmd(ccb, BUS_DMA_WAITOK, 1) == 0) {
		AMI_DPRINTF(AMI_D_IOCTL, ("cdb issued\n"));
		if (bp->direction == BIOC_DIRIN) {
			/* userland expects data */
			bp->datalen = ps->apt_datalen;
			AMI_DPRINTF(AMI_D_IOCTL, ("%s: passthrough %x\n",
			    sc->sc_dev.dv_xname, ps->apt_datalen));
			copyout(idata + sizeof *ps, bp->data, ps->apt_datalen);
		}
	}
	else {
		/* copy sense data back to user space */
		memcpy(&bp->sensebuf[0], &ps->apt_sense[0], ps->apt_nsense);
		bp->senselen = ps->apt_nsense;
		/*
		 * this needs to be checked in userland since error can't
		 * be set. Setting it prevents it from being coppied back to
		 * userland
		 */
		bp->status = 1;
d2058 1
a2058 4
#ifdef AMI_DEBUG
		AMI_DPRINTF(AMI_D_IOCTL, ("%s: passthrough failed %x %x\n%s: ",
		    sc->sc_dev.dv_xname, bp->status, bp->senselen,
		    sc->sc_dev.dv_xname));
d2060 7
a2066 2
		for (i = 0; i < bp->senselen; i++)
			printf("%0x ", bp->sensebuf[i]);
d2068 3
a2070 2
		printf("\n");
#endif /* AMI_DEBUG */
d2073 2
a2074 1
	ami_freemem(sc->dmat, &idatamap, idataseg, NBPG, 1, "ioctl data");
@


1.47
log
@Rip out all previous bio code because it sucked.  Replaced all ioctl code in
ami(4) and bio(4).

Note that this will break trees where userland and kernel are not in sync.

ok dlg@@
@
text
@d48 1
a48 1
/*#define AMI_DEBUG */
d79 5
a83 5
/*	| AMI_D_CMD*/
/*	| AMI_D_INTR*/
/*	| AMI_D_MISC*/
/*	| AMI_D_DMA*/
	| AMI_D_IOCTL
a138 3
int ami_mgmt(struct ami_softc *, u_int8_t, u_int8_t, u_int8_t,
    size_t, void *);
int ami_drv_inq(struct ami_softc *, u_int8_t, u_int8_t, void *);
a139 4
int ami_ioctl_inq(struct ami_softc *, bioc_inq *);
int ami_ioctl_vol(struct ami_softc *, bioc_vol *);
int ami_ioctl_disk(struct ami_softc *, bioc_disk *);
#if 0
a143 1
#endif
a584 1
	sc->sc_state_ch = 1; /* mark state as changed */
a1682 1
	/* u_int8_t target = link->target; */
a1690 455
struct disk {
	SLIST_ENTRY(disk) next;
	bioc_disk bd;

	int ch;
	int tg;
};

struct volume {
	SLIST_ENTRY(volume) next;
	bioc_vol bv;
};

SLIST_HEAD(disk_list, disk);
struct disk_list disks = SLIST_HEAD_INITIALIZER(disk);

SLIST_HEAD(vol_list, volume);
struct vol_list volumes = SLIST_HEAD_INITIALIZER(volume);

int
ami_ioctl(dev, cmd, addr)
	struct device *dev;
	u_long cmd;
	caddr_t addr;
{
	struct ami_softc *sc = (struct ami_softc *)dev;
	ami_lock_t lock;
	int error = 0;

	AMI_DPRINTF(AMI_D_IOCTL, ("%s: ioctl()\n", sc->sc_dev.dv_xname));

	if (sc->sc_flags & AMI_BROKEN)
		return ENODEV; /* can't do this to broken device for now */

	lock = AMI_LOCK_AMI(sc);
	if (sc->sc_flags & AMI_CMDWAIT) {
		AMI_UNLOCK_AMI(sc, lock);
		return EBUSY;
	}

	switch (cmd) {
	case BIOCINQ:
	case BIOCVOL:
	case BIOCDISK:
		sc->sc_flags |= AMI_CMDWAIT;
		while (!TAILQ_EMPTY(&sc->sc_ccbq))
			if (tsleep(&sc->sc_free_ccb, PRIBIO, "ami_ioctl",
			    100 * 60) == EWOULDBLOCK)
				return EWOULDBLOCK;
	}

	switch (cmd) {
	case BIOCINQ:
		AMI_DPRINTF(AMI_D_IOCTL, ("inquiry\n"));
		error = ami_ioctl_inq(sc, (bioc_inq *)addr);
		break;

	case BIOCVOL:
		AMI_DPRINTF(AMI_D_IOCTL, ("volume\n"));
		error = ami_ioctl_vol(sc, (bioc_vol *)addr);
		break;

	case BIOCDISK:
		AMI_DPRINTF(AMI_D_IOCTL, ("disk\n"));
		error = ami_ioctl_disk(sc, (bioc_disk *)addr);
		break;

	default:
		AMI_DPRINTF(AMI_D_IOCTL, ("%s: invalid ioctl\n",
		    sc->sc_dev.dv_xname));
		error = EINVAL;
	}

	sc->sc_flags &= ~AMI_CMDWAIT;
	wakeup(&sc->sc_ccbq);

	AMI_UNLOCK_AMI(sc, lock);

	return (error);
}

int
ami_drv_inq(sc, ch, tg, inqbuf)
	struct ami_softc *sc;
	u_int8_t ch;
	u_int8_t tg;
	void *inqbuf;
{
	struct ami_ccb *ccb;
	struct ami_iocmd *cmd;
	struct ami_passthrough *ps;
	struct scsi_inquiry_data *pp;
	void *idata;
	bus_dmamap_t idatamap;
	bus_dma_segment_t idataseg[1];
	paddr_t	pa;
	int error = 0;

	if (!(idata = ami_allocmem(sc->dmat, &idatamap, idataseg, NBPG, 1,
	    "ami mgmt"))) {
	    	error = ENOMEM;
		goto bail;
	}

	pa = idataseg[0].ds_addr;
	ps = idata;
	pp = idata + sizeof *ps;

	ccb = ami_get_ccb(sc);
	ccb->ccb_data = NULL;
	cmd = ccb->ccb_cmd;

	cmd->acc_cmd = AMI_PASSTHRU;
	cmd->acc_passthru.apt_data = htole32(pa);

	memset(ps, 0, sizeof *ps);

	ps->apt_channel = ch;
	ps->apt_target = tg;
	ps->apt_ncdb = sizeof(struct scsi_inquiry);
	ps->apt_nsense = sizeof(struct scsi_sense_data);

	ps->apt_cdb[0] = INQUIRY;
	ps->apt_cdb[1] = 0;
	ps->apt_cdb[2] = 0;
	ps->apt_cdb[3] = 0;
	ps->apt_cdb[4] = sizeof(struct scsi_inquiry_data); /* INQUIRY length */
	ps->apt_cdb[5] = 0;

	ps->apt_data = htole32(pa + sizeof *ps);
	ps->apt_datalen = sizeof(struct scsi_inquiry_data);

	AMI_DPRINTF(AMI_D_IOCTL, ("%s: ami_drv_inq(%p, %02x, %02x, ,%p) ",
	    sc->sc_dev.dv_xname, sc, ch, tg, inqbuf));

	if (ami_cmd(ccb, BUS_DMA_WAITOK, 1) == 0) {
		AMI_DPRINTF(AMI_D_IOCTL, ("completed\n"));

		memcpy(inqbuf, pp, sizeof(struct scsi_inquiry_data));
	}
	else {
		AMI_DPRINTF(AMI_D_IOCTL, ("failed\n"));

		error = EINVAL;
	}

bail:
	ami_freemem(sc->dmat, &idatamap, idataseg, NBPG, 1, "ami mgmt");

	return (error);
}

int
ami_mgmt(sc, opcode, par1, par2, size, buffer)
	struct ami_softc *sc;
	u_int8_t opcode;
	u_int8_t par1;
	u_int8_t par2;
	size_t size;
	void *buffer;
{
	struct ami_ccb *ccb;
	struct ami_iocmd *cmd;
	void *idata;
	bus_dmamap_t idatamap;
	bus_dma_segment_t idataseg[1];
	paddr_t	pa;
	int error = 0;

	if (!(idata = ami_allocmem(sc->dmat, &idatamap, idataseg, NBPG,
	    (size / NBPG) + 1, "ami mgmt"))) {
	    	error = ENOMEM;
		goto bail;
	}

	pa = idataseg[0].ds_addr;

	ccb = ami_get_ccb(sc);
	ccb->ccb_data = NULL;
	cmd = ccb->ccb_cmd;

	cmd->acc_cmd = opcode;
	cmd->acc_io.aio_channel = par1;
	cmd->acc_io.aio_param = par2;
	cmd->acc_io.aio_data = htole32(pa);

	AMI_DPRINTF(AMI_D_IOCTL, ("%s: ami_mgmt(%p, %02x, %02x, %02x, %d,%p) ",
	    sc->sc_dev.dv_xname, sc, opcode, par1, par2, size, buffer));

	if (ami_cmd(ccb, BUS_DMA_WAITOK, 1) == 0) {
		AMI_DPRINTF(AMI_D_IOCTL, ("completed\n"));

		memcpy(buffer, idata, size);
	}
	else {
		AMI_DPRINTF(AMI_D_IOCTL, ("failed\n"));

		error = EINVAL;
	}

bail:;
	ami_freemem(sc->dmat, &idatamap, idataseg, NBPG, (size / NBPG) + 1,
	    "ami mgmt");

	return (error);
}

int
ami_ioctl_inq(sc, bi)
	struct ami_softc *sc;
	bioc_inq *bi;
{
	struct scsi_inquiry_data inqbuf;
	struct ami_big_diskarray *p; /* struct too large for stack */
	struct volume *vol;
	struct disk *dk;
	int i, s, t, c;
	int off;
	int error = 0;

	if (!sc->sc_state_ch) {
		bi->novol = 0;
		bi->nodisk = 0;
		SLIST_FOREACH(vol, &volumes, next) {
			bi->novol++;
			bi->nodisk += vol->bv.nodisk;
		}

		return 0;
	}

	AMI_DPRINTF(AMI_D_IOCTL, ("%s: biocinq", sc->sc_dev.dv_xname));

	p = malloc(sizeof *p, M_DEVBUF, M_NOWAIT);
	if (!p) {
		printf("%s: no memory for raw interface\n", sc->sc_dev.dv_xname);
		return (ENOMEM);
	}

	bi->nodisk = 0;

	for (c = 0; c < 4; c++) { /* FIXME get max channel from inq3 */
		for (t = 0; t < AMI_MAX_TARGET; t++) {
			if (!ami_drv_inq(sc, c, t, &inqbuf)) {
				if ((inqbuf.device & SID_TYPE) != T_DIRECT)
					/* XXX save c:t if PROC for later use */
					continue; /* we only care about disk */

				dk = malloc(sizeof(struct disk), M_DEVBUF,
				    M_NOWAIT);
				if (!dk) {
					/* FIXME */
					panic("not enough memory.");
				}

				dk->ch = c;
				dk->tg = t;
				dk->bd.diskid = bi->nodisk;
				dk->bd.status = 0; /* XXX xlate */
				dk->bd.volid = -1; /* not yet claimed */
				dk->bd.size = 0; /* GETCAP or get in 2nd pass */
				strlcpy(dk->bd.vendor, inqbuf.vendor,
				    8 + 16 + 4 + 1); /* vendor prod rev zero */

				bi->nodisk++;

				SLIST_INSERT_HEAD(&disks, dk, next);
			}
			else {
				AMI_DPRINTF(AMI_D_IOCTL, ("c: %d t: %d "
				    "fail\n", c, t));
			}
		}
	}

	if (!ami_mgmt(sc, AMI_FCOP, AMI_FC_RDCONF, 0, sizeof *p, p)) {
		bi->novol = p->ada_nld;

		AMI_DPRINTF(AMI_D_IOCTL, ("novol: %d  nodisk: %d p: %p\n",
		    bi->novol, bi->nodisk, &p));

		/* setup volume list */
		for (i = 0; i < p->ada_nld; i++) {
			vol = malloc(sizeof(struct volume), M_DEVBUF, M_NOWAIT);
			if (!vol) {
				/* FIXME */
				panic("not enough memory.");
			}

			vol->bv.volid = i;
			vol->bv.status = 0; /* XXX translate ami status */
			vol->bv.size = 0;
			vol->bv.level = p->ada_ldrv[i].adl_raidlvl;
			vol->bv.nodisk = 0;
			/* do string ops here, question is how */

			for (s = 0; s < p->ada_ldrv[i].adl_spandepth; s++) {
				for (t = 0; t < p->ada_ldrv[i].adl_nstripes; t++) {
					vol->bv.nodisk++;

					off = p->ada_ldrv[i].adl_spans[s].ads_devs[t].add_channel * AMI_MAX_TARGET + p->ada_ldrv[i].adl_spans[s].ads_devs[t].add_target;
					/* walk disk list and add size */
					SLIST_FOREACH(dk, &disks, next) {
						if (dk->ch != (p->ada_ldrv[i].adl_spans[s].ads_devs[t].add_target >> 4) || dk->tg != (p->ada_ldrv[i].adl_spans[s].ads_devs[t].add_target & 0x0f))
							continue;

						dk->bd.size = (quad_t)p->ada_pdrv[off].adp_size;
						dk->bd.volid = i;

						AMI_DPRINTF(AMI_D_IOCTL, ("\tdiskid: %d\n", dk->bd.diskid));
						AMI_DPRINTF(AMI_D_IOCTL, ("\tstatus: %d\n", dk->bd.status));
						AMI_DPRINTF(AMI_D_IOCTL, ("\tvolid : %d\n", dk->bd.volid));
						AMI_DPRINTF(AMI_D_IOCTL, ("\tsize  : %d\n", dk->bd.size));
						AMI_DPRINTF(AMI_D_IOCTL, ("\tvendor: %s\n", dk->bd.vendor));
						AMI_DPRINTF(AMI_D_IOCTL, ("\tchan  : %d\n", dk->ch));
						AMI_DPRINTF(AMI_D_IOCTL, ("\ttarget: %d\n", dk->tg));

					}
				}

				switch (vol->bv.level) {
				case 0:
					vol->bv.size += p->ada_ldrv[i].adl_spans[s].ads_length * p->ada_ldrv[i].adl_nstripes;
					break;

				case 1:
					vol->bv.size += p->ada_ldrv[i].adl_spans[s].ads_length;
					break;

				case 5:
					vol->bv.size += p->ada_ldrv[i].adl_spans[s].ads_length * (p->ada_ldrv[i].adl_nstripes - 1);
					break;
				}

			}

			if (p->ada_ldrv[i].adl_spandepth > 1)
				vol->bv.level *= 10;

			vol->bv.size *= (quad_t)512;

			AMI_DPRINTF(AMI_D_IOCTL, ("voldid: %d\n",
			    vol->bv.volid));
			AMI_DPRINTF(AMI_D_IOCTL, ("status: %d\n",
			    vol->bv.status));
			AMI_DPRINTF(AMI_D_IOCTL, ("size  : %lld\n",
			    vol->bv.size));
			AMI_DPRINTF(AMI_D_IOCTL, ("level : %d\n",
			    vol->bv.level));
			AMI_DPRINTF(AMI_D_IOCTL, ("nodisk: %d\n",
			    vol->bv.nodisk));

			SLIST_INSERT_HEAD(&volumes, vol, next);
		}

#if 0
		printf("LD: %d  %d\n", p->ada_nld, sizeof p);

		for (i = 0; i < p->ada_nld; i++) {
			printf("\tspandepth: %d\n", p->ada_ldrv[i].adl_spandepth);
			printf("\traidlvl  : %d\n", p->ada_ldrv[i].adl_raidlvl);
			printf("\trd ahead : %d\n", p->ada_ldrv[i].adl_rdahead);
			printf("\tstrp size: %d\n", p->ada_ldrv[i].adl_stripesz);
			printf("\tstatus   : %d\n", p->ada_ldrv[i].adl_status);
			printf("\twr policy: %d\n", p->ada_ldrv[i].adl_wrpolicy);
			printf("\tdirectio : %d\n", p->ada_ldrv[i].adl_directio);
			printf("\tnr stripe: %d\n", p->ada_ldrv[i].adl_nstripes);
			for (s = 0; s < p->ada_ldrv[i].adl_spandepth; s++) {
				for (t = 0; t < p->ada_ldrv[i].adl_nstripes; t++) {
				off = p->ada_ldrv[i].adl_spans[s].ads_devs[t].add_channel *
				    AMI_MAX_TARGET +
				    p->ada_ldrv[i].adl_spans[s].ads_devs[t].add_target;

				printf("\t\tspan     : %d\n", s);
				printf("\t\tstart    : %d\n",
				    (u_int32_t)p->ada_ldrv[i].adl_spans[s].ads_start);
				printf("\t\tlength   : %d\n",
				    (u_int32_t)p->ada_ldrv[i].adl_spans[s].ads_length);

					printf("\t\t\tchannel  : %02x\n",
					    p->ada_ldrv[i].adl_spans[s].ads_devs[t].add_channel);
					printf("\t\t\ttarget   : %02x\n",
					    p->ada_ldrv[i].adl_spans[s].ads_devs[t].add_target);
					printf("\t\t\toff      : %d\n");

					printf("\t\t\ttype     : %d\n",
					    p->ada_pdrv[off].adp_type);
					printf("\t\t\tstatus   : %d\n",
					    p->ada_pdrv[off].adp_ostatus);
					printf("\t\t\tdepth    : %d\n",
					    p->ada_pdrv[off].adp_tagdepth);
					printf("\t\t\tsneg     : %d\n",
					    p->ada_pdrv[off].adp_sneg);
					printf("\t\t\tsize     : %d\n\n",
					    (u_int32_t)p->ada_pdrv[off].adp_size);
				}
			}
		}
#endif
	}
	else {
		AMI_DPRINTF(AMI_D_IOCTL, ("failed\n"));
		error = EINVAL;
	}

	free(p, M_DEVBUF);

	sc->sc_state_ch = 0; /* state normalized */

	return (error);
}

int
ami_ioctl_vol(sc, bv)
	struct ami_softc *sc;
	bioc_vol *bv;
{
	struct volume *vol;
	int error = EINVAL;

	AMI_DPRINTF(AMI_D_IOCTL, ("%s: biocvol\n", sc->sc_dev.dv_xname));

	SLIST_FOREACH(vol, &volumes, next) {
		if (bv->volid != vol->bv.volid)
			continue;
	
		memcpy(bv, &vol->bv, sizeof *bv);
		error = 0;
	}

	return (error);
}

int
ami_ioctl_disk(sc, bd)
	struct ami_softc *sc;
	bioc_disk *bd;
{
	struct disk *dk;
	int error = EINVAL;

	AMI_DPRINTF(AMI_D_IOCTL, ("%s: biocdisk\n", sc->sc_dev.dv_xname));

	SLIST_FOREACH(dk, &disks, next) {
		if (bd->diskid != dk->bd.diskid)
			continue;

		memcpy(bd, &dk->bd, sizeof *bd);
		error = 0;
	}

	return (error);
}

#if 0
a2074 2
#endif

@


1.46
log
@Fix data_length values in simulationed MODE SENSE page 4 responses so
that scsi_do_mode_sense() accepts them.

The data_length value does not include itself, and the pg_length value
in a mode page does not include itself or the page_code fields. We
were +1 on the former and -2 on the latter resulting in a data_length
value that was too small by one.

Eliminates 'mode sense page 5 not simulated' messages.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.45 2005/06/28 18:33:11 marco Exp $	*/
d48 1
a48 1
/*#define	AMI_DEBUG */
d79 5
a83 5
	| AMI_D_CMD
	| AMI_D_INTR
	| AMI_D_MISC
/*	| AMI_D_DMA */
/*	| AMI_D_IOCTL */
d139 3
d143 4
d151 1
d593 1
d1692 1
d1701 455
d2540 2
@


1.45
log
@NBIO > 0 the bioctl code.
Conditional jump to ami_ioctl() if NBIO > 0 is defined.

ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.44 2005/06/28 15:09:36 marco Exp $	*/
d1479 3
a1481 2
			mpd.hd.data_length = sizeof mpd.hd + sizeof mpd.bd +
			    mpd.dp.rigid_geometry.pg_length;
@


1.44
log
@implement ami_schwartz_poll() per the FIXME leftover from the hackathon.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.43 2005/06/28 13:58:05 mickey Exp $	*/
d138 1
d144 1
d610 3
a612 1
#endif
d1681 6
a1686 1
	return ami_ioctl(link->adapter_softc, cmd, addr);
d1689 1
d2074 1
@


1.43
log
@allow posting BIO ioctls to the daughter devices (sd*) as well; marco@@ testing and ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.42 2005/06/16 20:36:03 mickey Exp $	*/
d938 1
a938 1
ami_schwartz_poll(sc, cmd)
d940 1
a940 1
	struct ami_iocmd *cmd;
d942 21
a962 1
	/* FIXME add the actual code here */
d964 30
a993 1
	if (sc->sc_dis_poll)
d995 13
d1009 1
a1009 1
	return 1;
@


1.42
log
@supply mising busdma flags to ami_cmd (used to be 0 for waitok);
spread a few dma_sync calls in the completion sequence;
minor cleanups.
marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.41 2005/05/28 00:15:41 marco Exp $	*/
d94 2
d99 1
a99 1
	ami_scsi_cmd, amiminphys, 0, 0,
a137 1
#if NBIO > 0
a142 1
#endif
d1611 7
a1617 1
#if NBIO > 0
a2001 1
#endif /* NBIO > 0 */
@


1.41
log
@Step 3 in fixing bioctl commands intermixed with regular io.

Enhance performance by using two sleep channels instead of one.  All mickey, but I'll take credit for typing it.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.40 2005/05/28 00:07:03 marco Exp $	*/
d414 1
a414 1
		if (ami_cmd(ccb, 0, 1) == 0) {
d429 1
a429 1
			if (ami_cmd(ccb, 0, 1) == 0) {
d454 1
a454 1
			if (ami_cmd(ccb, 0, 1) != 0) {
d462 1
a462 1
				if (ami_cmd(ccb, 0, 1) != 0) {
d513 1
a513 1
		if (ami_cmd(ccb, 0, 1) != 0) {
d532 1
a532 1
			if (ami_cmd(ccb, 0, 1) != 0) {
d670 1
a670 1
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, 16,
d706 2
d713 2
d720 2
d729 2
d745 1
a745 1
	for (n = 0; n < nstat; n++) {
a746 1
	}
d751 1
a751 1
	return (1); /* ready to complete all IOs in acc_cmplidl */
d1618 1
a1618 1
	int lock, error = 0;
d1620 1
d1774 1
a1774 1
	if (ami_cmd(ccb, 0, 1) == 0) {
d1820 1
a1820 1
	if (ami_cmd(ccb, 0, 1) == 0) {
d1867 1
a1867 1
	if (ami_cmd(ccb, 0, 1) == 0) {
d1959 1
a1959 1
	if (ami_cmd(ccb, 0, 1) == 0) {
@


1.40
log
@Step 2 in fixing bioctl commands intermixed with regular io.

Add tsleep/wakeup magic to drain IO when a RAID mgmt command wants to run.
Issue RAID mgmt command.
Resume IO.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.39 2005/05/27 20:39:29 marco Exp $	*/
d1194 1
a1194 1
			wakeup(&sc->sc_ccbq);
d1633 1
a1633 1
			if (tsleep(&sc->sc_ccbq, PRIBIO, "ami_ioctl",
@


1.39
log
@step 1 in fixing bioctl commands intermixed with regular io.

- Added the magical sequence for polling IO
- Created new polling function per hardware generation

Lots and lots of constructive yelling mickey@@
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.38 2005/05/17 18:38:52 marco Exp $	*/
d57 1
d936 4
d1193 2
d1258 3
d1497 3
d1614 2
d1626 13
d1691 3
@


1.38
log
@Need to find a way to detect if fw supports disabling hold of timers before
this can go in.  Calling it this way crashes fw when io is ran to multiple
logical disks
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.37 2005/05/11 18:48:53 marco Exp $	*/
d48 1
a48 1
 /*#define	AMI_DEBUG */
d78 2
a79 2
/*	| AMI_D_CMD */
/*	| AMI_D_INTR */
a130 1
int  ami_complete(struct ami_ccb *ccb);
d747 117
d930 9
d994 10
a1003 1
	if ((error = ami_start(ccb, wait))) {
a1008 4
	} else if (wait) {
		AMI_DPRINTF(AMI_D_DMA, ("waiting "));
		if ((error = ami_complete(ccb)))
			ami_put_ccb(ccb);
d1074 1
a1131 38
ami_complete(ccb)
	struct ami_ccb *ccb;
{
	struct ami_softc *sc = ccb->ccb_sc;
	struct scsi_xfer *xs = ccb->ccb_xs;
	struct ami_iocmd mbox;
	int i, j, rv, status;

	i = 1 * (xs? xs->timeout: 1000);
	AMI_DPRINTF(AMI_D_CMD, ("%d ", i));
	for (rv = 1, status = 0; !status && rv && i--; DELAY(1000))
		if ((sc->sc_done)(sc, &mbox)) {
			AMI_DPRINTF(AMI_D_CMD, ("got#%d ", mbox.acc_nstat));
			status = mbox.acc_status;
			for (j = 0; j < mbox.acc_nstat; j++ ) {
				int ready = mbox.acc_cmplidl[j];

				AMI_DPRINTF(AMI_D_CMD, ("ready=%x ", ready));

				if (!ami_done(sc, ready) &&
				    ccb->ccb_cmd->acc_id == ready)
					rv = 0;
			}
		}

	if (status) {
		AMI_DPRINTF(AMI_D_CMD, ("aborted\n"));
	} else if (!rv) {
		AMI_DPRINTF(AMI_D_CMD, ("complete\n"));
	} else if (i < 0) {
		AMI_DPRINTF(AMI_D_CMD, ("timeout\n"));
	} else
		AMI_DPRINTF(AMI_D_CMD, ("screwed\n"));

	return rv? rv : status;
}

int
d1598 1
a1598 1
	int error = 0;
d1604 6
d1664 2
a1676 1
	ami_lock_t lock;
a1693 2
	lock = AMI_LOCK_AMI(sc);

a1727 1
		AMI_UNLOCK_AMI(sc, lock);
a1746 2
	AMI_UNLOCK_AMI(sc, lock);

a1759 3
	ami_lock_t lock;

	lock = AMI_LOCK_AMI(sc);
a1789 2
	AMI_UNLOCK_AMI(sc, lock);

a1800 1
	ami_lock_t lock;
a1816 2
	lock = AMI_LOCK_AMI(sc);

a1835 2
	AMI_UNLOCK_AMI(sc, lock);

a1849 1
	ami_lock_t lock;
a1884 2
	lock = AMI_LOCK_AMI(sc);

d1946 1
a1946 2
		for (i = 0; i < bp->senselen; i++) {
			bp->sensebuf[i] = ps->apt_sense[i];
d1948 1
a1948 1
		}
a1951 2

	AMI_UNLOCK_AMI(sc, lock);
@


1.37
log
@Reset IO completion values to 0 to disable completion holdof.  This improves
read performance.

This will only work with firmwares that are launched post 5/13/2005.

Help LSI, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.36 2005/05/09 19:50:48 marco Exp $	*/
d80 1
a80 1
/*	| AMI_D_MISC */
d82 1
a82 1
	| AMI_D_IOCTL
d329 1
a329 1
	u_int32_t *pp;
d487 5
d501 2
d509 1
a509 1
		cmd->acc_io.aio_channel = AMI_SET_IO_CMPL; /* sub opcode */
a512 4
		/* set parameters */
		pp = idata;
		pp[0] = 0; /* minimal outstanding commands, 0 disable */
		pp[1] = 0; /* maximal timeout in us, 0 disable */
d514 1
a514 1
			AMI_DPRINTF(AMI_D_MISC, ("setting io completion values"
d518 22
a539 2
			AMI_DPRINTF(AMI_D_MISC, ("setting io completion values"
			    " succeeded\n"));
d541 1
a541 1

@


1.36
log
@replace sc_quirk with sc_flags, spotted and ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.35 2005/04/27 21:54:47 marco Exp $	*/
d329 1
d488 30
a517 1
		AMI_UNLOCK_AMI(sc, lock);
d535 2
@


1.35
log
@Remove unnecessary step in ack sequence.

Help LSI, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.34 2005/04/17 17:37:38 mickey Exp $	*/
d489 1
a489 1
		if (sc->sc_quirks & AMI_BROKEN) {
d536 1
a536 1
	    sc->sc_link.openings, sc->sc_maxcmds, sc->sc_quirks);
d545 1
a545 1
	if (sc->sc_quirks & AMI_BROKEN && sc->sc_nunits > 1)
d1453 1
a1453 1
	if (sc->sc_quirks & AMI_BROKEN)
@


1.34
log
@tabs not spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.33 2005/04/17 16:32:43 marco Exp $	*/
a675 10
	/* ack interrupt */
	ami_write_inbound_db(sc, AMI_QIDB_ACK);

	i = 0;
	while(ami_read_inbound_db(sc) & AMI_QIDB_ACK) {
		delay(1);
		if (i++ > 1000000)
			return (0); /* nothing to do */
	}

d685 3
@


1.33
log
@Timeouts are not ran at splhigh anymore so we don't need splimp.

Inspired by beck@@, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.32 2005/04/04 22:40:31 marco Exp $	*/
d531 2
a532 2
	     "%s: %d channels, %d %ss, %d logical drives, "
	     "openings %d, max commands %d, quirks: %04x\n",
d539 1
a539 1
	     "%s: %d channels, %d %ss, %d logical drives\n",
d550 4
a553 4
        if (bio_register(&sc->sc_dev, ami_ioctl) != 0)
                printf("%s: controller registration failed",
                    sc->sc_dev.dv_xname);
#endif  
d1453 3
a1455 3
        struct device *dev;
        u_long cmd;
        caddr_t addr;
d1522 1
a1522 1
        struct ami_softc *sc;
d1611 1
a1611 1
        struct ami_softc *sc;
d1657 1
a1657 1
        struct ami_softc *sc;
d1738 1
a1738 1
		return (EINVAL); 
d1804 6
a1809 5
		bp->status = 1;                /* this needs to be checked in
						* userland since error can't
						* be set. Setting it prevents
						* it from being coppied back to
						* userland */
d1813 1
a1813 1
		    sc->sc_dev.dv_xname, bp->status, bp->senselen, 
@


1.32
log
@Add blink and unblink but tell userland it is responsible for actually doing it
because the ami firmware does not support it.  In this case bioctl(8) will do
it with SES passthrough commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.31 2005/04/01 20:14:40 marco Exp $	*/
d772 1
a772 1
	int error = 0, i, s;
a820 1
	s = splimp();
a831 1
	splx(s);
d905 1
a905 1
	ami_lock_t lock, s;
a938 1
		s = splimp();
a940 1
		splx(s);
d997 1
a997 1
	ami_lock_t lock, s;
a1007 1
	s = splimp();
a1040 1
	splx(s);
a1047 1

d1417 1
a1417 1
	int i, s, rv = 0;
a1425 1
	s = splimp();	/* XXX need to do this to mask timeouts */
a1444 1
	splx(s);
@


1.31
log
@shut ami up, bad me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.30 2005/03/29 22:24:27 marco Exp $	*/
d1483 1
a1483 1
		    BIOC_STATUS;
d1498 5
@


1.30
log
@add copyright me
per mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.29 2005/03/29 22:20:38 marco Exp $	*/
d48 1
a48 1
#define	AMI_DEBUG
d1726 2
d1729 1
@


1.29
log
@add raid mgmt ioctls

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.28 2005/02/03 17:47:27 mickey Exp $	*/
d5 1
@


1.28
log
@add 5sec to the xs->timeout to overcompensate for possible delays in quartz_done(); marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.27 2005/01/08 18:14:54 mickey Exp $	*/
d47 1
a47 1
/* #define	AMI_DEBUG */
d52 1
d66 3
d75 1
d77 2
a78 2
	| AMI_D_CMD
	| AMI_D_INTR
d81 1
d135 8
d548 6
d555 1
d1457 373
@


1.27
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.26 2004/12/26 00:35:42 marco Exp $	*/
d860 2
a861 1
				tv.tv_sec = xs->timeout / 1000;
@


1.26
log
@Make debug less verbose.  Prompted by mickey@@

And for the archives:
* Peruse the handshake mechanism between driver and firmware from the Linux
  driver which is maintained by LSI.
* Copy only the first 16 bytes of the mailbox (under heavy IO overwriting the
  17th byte could cause the firmware to crash).
* Limit ULTRA HBAs (a.k.a. schwartz) to one single LD (Logical Drive) because
  for some reason having more than 1 ccb causes the firmware to hang.  Whenever
  the driver limits the LDs it issues a warning in dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.25 2004/12/26 00:11:24 marco Exp $	*/
a128 1

d170 1
a170 1
	
@


1.25
log
@This should fix long outstanding issues with ami(4).  The reported
symptoms that were fixed are:
* Very slow throughput
* ccb timeout (i.e. ami0: timeout ccb 1)
* All IO to ami devices hangs
* Only 1 LD (Logical Drive) can be accessed at the same time
* System hangs/freezes when running IO to ami cards.

Issues it doesn't fix:
* Really old ULTRA-2 controllers still crash whenever more than 1 LD are
  accessed at the same time therefore the driver limits the maximum LDs to 1.

Tested by several folks and ok beck@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.24 2004/01/09 21:32:23 brad Exp $	*/
d159 1
a159 1
	AMI_DPRINTF(AMI_D_CMD, ("ami_write_inbound_db(%x)", v));
d175 1
a175 1
	AMI_DPRINTF(AMI_D_CMD, ("ami_read_inbound_db(%x)", rv));
d185 1
a185 1
	AMI_DPRINTF(AMI_D_CMD, ("ami_write_outbound_db(%x)", v));
d201 1
a201 1
	AMI_DPRINTF(AMI_D_CMD, ("ami_read_outbound_db(%x)", rv));
a582 2
	AMI_DPRINTF(AMI_D_CMD, ("ami_quartz_exec() "));

a603 1
	AMI_DPRINTF(AMI_D_CMD, ("ami_quartz_exec() returning "));
a615 2
	AMI_DPRINTF(AMI_D_CMD, ("ami_quartz_done() "));

d638 1
a638 1
	AMI_DPRINTF(AMI_D_CMD, ("ami_quartz_done() nstat %d ", nstat));
a683 2
	AMI_DPRINTF(AMI_D_CMD, ("ami_schwartz_init() "));

a699 2
	AMI_DPRINTF(AMI_D_CMD, ("ami_schwartz_exec() "));

a720 1
	AMI_DPRINTF(AMI_D_CMD, ("ami_schwartz_done() "));
d734 1
a734 2
		AMI_DPRINTF(AMI_D_CMD, ("ami_schwartz_done() acc_nstat %d ",
		    mbox->acc_nstat));
d1413 1
@


1.24
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.23 2003/06/28 23:55:50 avsm Exp $	*/
d106 8
a113 2
static __inline struct ami_ccb *ami_get_ccb(struct ami_softc *sc);
static __inline void ami_put_ccb(struct ami_ccb *ccb);
d130 1
a130 1
static __inline struct ami_ccb *
d144 1
a144 1
static __inline void
d154 52
d475 16
a490 2
		if (sc->sc_maxcmds > AMI_MAXCMDS)
			sc->sc_maxcmds = 1 /* AMI_MAXCMDS */;
a505 6
	printf(": FW %s, BIOS v%s, %dMB RAM\n"
	     "%s: %d channels, %d %ss, %d logical drives\n",
	    sc->sc_fwver, sc->sc_biosver, sc->sc_memory,
	    sc->sc_dev.dv_xname,
	    sc->sc_channels, sc->sc_targets, p, sc->sc_nunits);

a509 1
	sc->sc_link.openings = sc->sc_maxcmds;
d515 20
d571 1
a571 3
	bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, 0);
	bus_space_barrier(sc->iot, sc->ioh,
		    AMI_QIDB, 4, BUS_SPACE_BARRIER_WRITE);
d581 3
a583 1
	u_int32_t qidb;
d585 4
a588 6
	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_READ);
	qidb = bus_space_read_4(sc->iot, sc->ioh, AMI_QIDB);
	if (qidb & (AMI_QIDB_EXEC | AMI_QIDB_ACK)) {
		AMI_DPRINTF(AMI_D_CMD, ("qidb1=%x ", qidb));
		return (EBUSY);
a589 2

	/* do not scramble the busy mailbox */
d595 2
a596 2
	*sc->sc_mbox = *cmd;
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, sizeof(*cmd),
d599 4
d604 3
a606 4
	AMI_DPRINTF(AMI_D_CMD, ("qidb2=%x ", qidb));
	bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, qidb);
	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_WRITE);
d615 63
a677 35
	u_int32_t qdb;

	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_READ);
	qdb = bus_space_read_4(sc->iot, sc->ioh, AMI_QIDB);
	if (qdb & (AMI_QIDB_EXEC | AMI_QIDB_ACK)) {
		AMI_DPRINTF(AMI_D_CMD, ("qidb3=%x ", qdb));
		return (0);
	}

	/* do not scramble the busy mailbox */
	if (sc->sc_mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (0);
	}

	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QODB, 4, BUS_SPACE_BARRIER_READ);
	qdb = bus_space_read_4(sc->iot, sc->ioh, AMI_QODB);
	if (qdb == AMI_QODB_READY) {

		bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, sizeof(*mbox),
		    BUS_DMASYNC_POSTWRITE);
		*mbox = *sc->sc_mbox;

		/* ack interrupt */
		bus_space_write_4(sc->iot, sc->ioh, AMI_QODB, AMI_QODB_READY);
		bus_space_barrier(sc->iot, sc->ioh,
		    AMI_QODB, 4, BUS_SPACE_BARRIER_WRITE);

		qdb = sc->sc_mbox_pa | AMI_QIDB_ACK;
		bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, qdb);
		bus_space_barrier(sc->iot, sc->ioh,
		    AMI_QIDB, 4, BUS_SPACE_BARRIER_WRITE);
		return (1);
d680 1
a680 3
	AMI_DPRINTF(AMI_D_CMD, ("qodb=%x ", qdb));

	return (0);
d689 2
d707 4
a710 1
	if (bus_space_read_1(sc->iot, sc->ioh, AMI_SMBSTAT) & AMI_SMBST_BUSY)
d712 6
a718 1
	*sc->sc_mbox = *cmd;
d729 2
d744 2
a861 4
	cmd->acc_busy = 1;
	cmd->acc_poll = 0;
	cmd->acc_ack = 0;

a1423 1
		AMI_DPRINTF(AMI_D_CMD, ("got#%d ", mbox.acc_nstat));
d1446 21
@


1.23
log
@fix wrong format type; ok deraadt, tedu, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.22 2003/06/02 19:24:22 mickey Exp $	*/
a56 2

#include <uvm/uvm_extern.h>
@


1.22
log
@kill the caluses three and four on some of my code
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.21 2003/04/27 11:22:52 ho Exp $	*/
d822 1
a822 1
		panic("ami_stimeout(%p) botch", cmd->acc_id);
@


1.21
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.20 2003/02/25 00:26:08 tedu Exp $	*/
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.20
log
@fix two off by ones
credit to Yichen Xie's bounds checker

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.19 2002/07/03 21:13:06 aaron Exp $	*/
d435 4
a438 4
		sprintf(sc->sc_fwver, "%c.%02d.%02d", sc->sc_fwver[2],
		    sc->sc_fwver[1], sc->sc_fwver[0]);
		sprintf(sc->sc_biosver, "%c.%02d.%02d", sc->sc_biosver[2],
		    sc->sc_biosver[1], sc->sc_biosver[0]);
d1123 4
a1126 3
		strcpy(inq.vendor, "AMI    ");
		sprintf(inq.product, "Host drive  #%02d", target);
		strcpy(inq.revision, "   ");
@


1.19
log
@Another missing call to AMI_UNLOCK_API(). Fixes SPL NOT LOWERED errors seen
when trying to mount/unmount a 900GB hardware RAID filesystem on an AMI card.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.18 2002/04/26 02:36:53 nate Exp $	*/
d367 1
a367 1
				sc->sc_fwver[16] = '\0';
d369 1
a369 1
				sc->sc_biosver[16] = '\0';
@


1.18
log
@Add missing unlock.  Ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.17 2002/03/26 18:09:53 mickey Exp $	*/
d1172 1
@


1.17
log
@enforce higher spl such that ccbs do not get fired upon in timeouts and other places where we call for resource allocations which do no proper spl protection these days
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.16 2002/03/14 01:26:54 millert Exp $	*/
d1050 1
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.15 2001/12/12 16:44:11 mickey Exp $	*/
d493 4
d507 8
a517 6
		return (0);
	}

	qidb = bus_space_read_4(sc->iot, sc->ioh, AMI_QIDB);
	if (qidb & (AMI_QIDB_EXEC | AMI_QIDB_ACK)) {
		AMI_DPRINTF(AMI_D_CMD, ("qidb1=%x ", qidb));
d522 2
d528 2
d540 8
d554 2
a555 6
	qdb = bus_space_read_4(sc->iot, sc->ioh, AMI_QIDB);
	if (qdb & (AMI_QIDB_EXEC | AMI_QIDB_ACK)) {
		AMI_DPRINTF(AMI_D_CMD, ("qidb3=%x ", qdb));
		return (0);
	}

d559 2
a560 2
		bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0,
		    sc->sc_cmdmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
d565 2
d570 2
d645 1
a645 1
	int error = 0, i;
d660 1
a660 1
			return error;
d694 1
d706 1
d708 1
a708 1
	return error;
d727 1
a727 1
		return EINVAL;
d757 6
a762 2
			if (xs)
				timeout_add(&xs->stimeout, hz * xs->timeout / 1000);
d771 1
a771 1
	return i;
d783 1
a783 1
	ami_lock_t lock;
d805 2
d817 1
d820 1
d822 1
d877 1
a877 1
	ami_lock_t lock;
d884 1
a884 1
		return 1;
d888 2
a890 1
	ccb->ccb_state = AMI_CCB_READY;
d922 1
a922 1
	AMI_UNLOCK_AMI(sc, lock);
d931 3
a933 1
	return 0;
d979 2
d989 1
a994 2
	lock = AMI_LOCK_AMI(sc);

a995 1
		AMI_UNLOCK_AMI(sc, lock);
d998 1
a1003 1
		AMI_UNLOCK_AMI(sc, lock);
d1006 1
a1029 1
		AMI_UNLOCK_AMI(sc, lock);
d1033 1
d1038 1
a1042 1
	AMI_UNLOCK_AMI(sc, lock);
d1046 1
d1076 3
d1081 1
d1086 1
a1089 2
	AMI_DPRINTF(AMI_D_CMD, ("ami_scsi_cmd "));

a1215 1
				AMI_UNLOCK_AMI(sc, lock);
d1221 1
a1225 1
		lock = AMI_LOCK_AMI(sc);
a1226 1
			AMI_UNLOCK_AMI(sc, lock);
d1230 1
d1246 1
a1246 2
		case SYNCHRONIZE_CACHE:	
			flags |= SCSI_POLL;
d1248 2
a1249 1
			/* XXX do other fields matter ? */
a1261 1
			AMI_UNLOCK_AMI(sc, lock);
d1266 1
d1271 1
d1287 1
d1297 1
a1297 1
	int i, rv = 0;
d1306 1
a1307 1
		AMI_UNLOCK_AMI(sc, lock);
d1310 1
a1310 1
			register int ready = mbox.acc_cmplidl[i];
d1315 1
a1315 1
				rv = 1;
a1316 1
		lock = AMI_LOCK_AMI(sc);
d1322 1
a1322 1
		timeout_add(&sc->sc_poll_tmo, 100);
d1326 1
d1329 1
a1329 1
	return rv;
@


1.15
log
@disable debugging, pointed out by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.14 2001/12/12 14:52:52 mickey Exp $	*/
d92 2
a93 2
int	ami_scsi_cmd __P((struct scsi_xfer *xs));
void	amiminphys __P((struct buf *bp));
d103 1
a103 1
int	ami_scsi_raw_cmd __P((struct scsi_xfer *xs));
d113 16
a128 16
static __inline struct ami_ccb *ami_get_ccb __P((struct ami_softc *sc));
static __inline void ami_put_ccb __P((struct ami_ccb *ccb));
void ami_copyhds __P((struct ami_softc *sc, const u_int32_t *sizes,
	const u_int8_t *props, const u_int8_t *stats));
void *ami_allocmem __P((bus_dma_tag_t dmat, bus_dmamap_t *map,
	bus_dma_segment_t *segp, size_t isize, size_t nent, const char *iname));
void ami_freemem __P((bus_dma_tag_t dmat, bus_dmamap_t *map,
	bus_dma_segment_t *segp, size_t isize, size_t nent, const char *iname));
void ami_dispose __P((struct ami_softc *sc));
void ami_stimeout __P((void *v));
int  ami_cmd __P((struct ami_ccb *ccb, int flags, int wait));
int  ami_start __P((struct ami_ccb *ccb, int wait));
int  ami_complete __P((struct ami_ccb *ccb));
int  ami_done __P((struct ami_softc *sc, int idx));
void ami_copy_internal_data __P((struct scsi_xfer *xs, void *v, size_t size));
int  ami_inquire __P((struct ami_softc *sc, u_int8_t op));
d331 1
a331 1
	timeout_set(&sc->sc_poll_tmo, (void (*)__P((void *)))ami_intr, sc);
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.15 2001/12/12 16:44:11 mickey Exp $	*/
d92 2
a93 2
int	ami_scsi_cmd(struct scsi_xfer *xs);
void	amiminphys(struct buf *bp);
d103 1
a103 1
int	ami_scsi_raw_cmd(struct scsi_xfer *xs);
d113 16
a128 16
static __inline struct ami_ccb *ami_get_ccb(struct ami_softc *sc);
static __inline void ami_put_ccb(struct ami_ccb *ccb);
void ami_copyhds(struct ami_softc *sc, const u_int32_t *sizes,
	const u_int8_t *props, const u_int8_t *stats);
void *ami_allocmem(bus_dma_tag_t dmat, bus_dmamap_t *map,
	bus_dma_segment_t *segp, size_t isize, size_t nent, const char *iname);
void ami_freemem(bus_dma_tag_t dmat, bus_dmamap_t *map,
	bus_dma_segment_t *segp, size_t isize, size_t nent, const char *iname);
void ami_dispose(struct ami_softc *sc);
void ami_stimeout(void *v);
int  ami_cmd(struct ami_ccb *ccb, int flags, int wait);
int  ami_start(struct ami_ccb *ccb, int wait);
int  ami_complete(struct ami_ccb *ccb);
int  ami_done(struct ami_softc *sc, int idx);
void ami_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size);
int  ami_inquire(struct ami_softc *sc, u_int8_t op);
d331 1
a331 1
	timeout_set(&sc->sc_poll_tmo, (void (*)(void *))ami_intr, sc);
a492 4
	bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, 0);
	bus_space_barrier(sc->iot, sc->ioh,
		    AMI_QIDB, 4, BUS_SPACE_BARRIER_WRITE);

d503 6
a508 2
	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_READ);
a514 6
	/* do not scramble the busy mailbox */
	if (sc->sc_mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (EBUSY);
	}

a515 2
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, sizeof(*cmd),
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
a519 2
	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_WRITE);
d530 6
a535 2
	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_READ);
a541 8
	/* do not scramble the busy mailbox */
	if (sc->sc_mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (0);
	}

	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QODB, 4, BUS_SPACE_BARRIER_READ);
d545 2
a546 2
		bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, sizeof(*mbox),
		    BUS_DMASYNC_POSTWRITE);
a550 2
		bus_space_barrier(sc->iot, sc->ioh,
		    AMI_QODB, 4, BUS_SPACE_BARRIER_WRITE);
a553 2
		bus_space_barrier(sc->iot, sc->ioh,
		    AMI_QIDB, 4, BUS_SPACE_BARRIER_WRITE);
d627 1
a627 1
	int error = 0, i, s;
d642 1
a642 1
			return (error);
a675 1
	s = splimp();
a686 1
	splx(s);
d688 1
a688 1
	return (error);
d707 1
a707 1
		return (EINVAL);
d737 2
a738 6
			if (xs) {
				struct timeval tv;
				tv.tv_sec = xs->timeout / 1000;
				tv.tv_usec = 1000 * (xs->timeout % 1000);
				timeout_add(&xs->stimeout, tvtohz(&tv));
			}
d747 1
a747 1
	return (i);
d759 1
a759 1
	ami_lock_t lock, s;
a780 2
		printf("%s: timeout ccb %d\n",
		    sc->sc_dev.dv_xname, cmd->acc_id);
a790 1
		s = splimp();
a792 1
		splx(s);
a793 1
		xs->flags |= ITSDONE;
d848 1
a848 1
	ami_lock_t lock, s;
d855 1
a855 1
		return (1);
d859 1
a859 1
	s = splimp();
a860 1
	TAILQ_REMOVE(&sc->sc_ccbq, ccb, ccb_link);
d892 1
a892 1
	splx(s);
d901 1
a901 3
	AMI_UNLOCK_AMI(sc, lock);

	return (0);
a946 2
	lock = AMI_LOCK_AMI(sc);

a954 1
		AMI_UNLOCK_AMI(sc, lock);
d960 2
d963 1
a965 1
		AMI_UNLOCK_AMI(sc, lock);
d971 1
a973 1
		AMI_UNLOCK_AMI(sc, lock);
d997 1
a1000 1
			AMI_UNLOCK_AMI(sc, lock);
a1004 1
			AMI_UNLOCK_AMI(sc, lock);
d1009 1
a1012 1
		AMI_UNLOCK_AMI(sc, lock);
a1015 1
	AMI_UNLOCK_AMI(sc, lock);
a1041 3
	AMI_DPRINTF(AMI_D_CMD, ("ami_scsi_cmd "));

	lock = AMI_LOCK_AMI(sc);
a1043 1
		AMI_DPRINTF(AMI_D_CMD, ("no taget %d ", target));
a1047 1
		AMI_UNLOCK_AMI(sc, lock);
d1051 2
d1179 1
a1184 1
				AMI_UNLOCK_AMI(sc, lock);
d1189 1
d1191 1
a1194 1
			AMI_UNLOCK_AMI(sc, lock);
d1210 2
a1211 1
		case SYNCHRONIZE_CACHE:
d1213 1
a1213 2
			if (xs->timeout < 30000)
				xs->timeout = 30000;	/* at least 30sec */
d1226 1
a1230 1
				AMI_UNLOCK_AMI(sc, lock);
a1234 1
				AMI_UNLOCK_AMI(sc, lock);
a1249 1
	AMI_UNLOCK_AMI(sc, lock);
d1259 1
a1259 1
	int i, s, rv = 0;
a1267 1
	s = splimp();	/* XXX need to do this to mask timeouts */
d1269 1
d1272 1
a1272 1
			int ready = mbox.acc_cmplidl[i];
d1277 1
a1277 1
				rv |= 1;
d1279 1
d1285 1
a1285 1
		timeout_add(&sc->sc_poll_tmo, 2);
a1288 1
	splx(s);
d1291 1
a1291 1
	return (rv);
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.15.2.1 2002/06/11 03:42:17 art Exp $	*/
a1171 1
		AMI_UNLOCK_AMI(sc, lock);
@


1.15.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d367 1
a367 1
				sc->sc_fwver[15] = '\0';
d369 1
a369 1
				sc->sc_biosver[15] = '\0';
d435 4
a438 4
		snprintf(sc->sc_fwver, sizeof sc->sc_fwver, "%c.%02d.%02d",
		    sc->sc_fwver[2], sc->sc_fwver[1], sc->sc_fwver[0]);
		snprintf(sc->sc_biosver, sizeof sc->sc_biosver, "%c.%02d.%02d",
		    sc->sc_biosver[2], sc->sc_biosver[1], sc->sc_biosver[0]);
d1123 3
a1125 4
		strlcpy(inq.vendor, "AMI    ", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Host drive  #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
@


1.14
log
@usmoke some scsi drugs, a little bit
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.8.2.4 2001/11/13 21:10:00 niklas Exp $	*/
d52 1
a52 1
#define	AMI_DEBUG
@


1.13
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.12 2001/11/05 17:25:58 art Exp $	*/
d52 1
a52 1
/* #define	AMI_DEBUG */
d81 2
a82 2
	| AMI_D_MISC
	| AMI_D_DMA
a289 1
	TAILQ_INIT(&sc->sc_ccb2q);
d326 2
d503 6
d511 1
a511 1
		AMI_DPRINTF(AMI_D_CMD, ("qidb=%x ", qidb));
d518 1
a518 1
	AMI_DPRINTF(AMI_D_CMD, ("qidb=%x ", qidb));
d529 1
a529 1
#if 0
d535 1
a535 1
#endif
d538 1
a538 1
		AMI_DPRINTF(AMI_D_CMD, ("qidb=%x ", qdb));
d671 2
a672 1
	}
d713 1
a713 10
	if (mbox->acc_busy) {

		if (!wait) {
			AMI_DPRINTF(AMI_D_CMD, ("2queue(%d) ", cmd->acc_id));
			ccb->ccb_state = AMI_CCB_PREQUEUED;
			if (xs)
				timeout_add(&xs->stimeout, 1);

			return (xs? 0 : EBUSY);
		}
d738 1
a738 1
				/*timeout_add(&xs->stimeout, hz * xs->timeout / 1000)*/;
d740 1
a740 1
	} else if (!wait) {
d743 2
a744 4
		if (xs) {
			timeout_add(&xs->stimeout, 1);
			return (0);
		}
d761 1
d766 1
a766 1
			return;
d770 1
a771 2

		lock = AMI_LOCK_AMI(sc);
a776 1
		AMI_UNLOCK_AMI(sc, lock);
d782 9
a790 1
		lock = AMI_LOCK_AMI(sc);
a792 1
		AMI_UNLOCK_AMI(sc, lock);
d800 1
d812 3
a814 3
	DELAY(10000000);
	for (rv = 1, status = 0, i = 1 * (xs? xs->timeout: 1000);
	     !status && rv && i--; DELAY(1000))
a860 1
	AMI_UNLOCK_AMI(sc, lock);
d873 1
a890 1
	lock = AMI_LOCK_AMI(sc);
a1158 1
		lock = AMI_LOCK_AMI(sc);
d1160 1
a1160 1
		flags = 0;
d1175 1
a1175 1
					flags = 0;
d1184 2
a1185 1
				break;
d1189 1
d1194 1
d1196 1
a1196 1
			break;
d1211 1
d1223 2
a1224 2
		if ((error = ami_cmd(ccb, ((xs->flags & SCSI_NOSLEEP)?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK), xs->flags & SCSI_POLL))) {
d1229 1
a1229 1
			if (xs->flags & SCSI_POLL) {
d1234 2
a1235 1
				break;
d1240 4
a1243 3
		if (xs->flags & SCSI_POLL)
			break;
		return (SUCCESSFULLY_QUEUED);
d1250 1
a1250 3
	xs->flags |= ITSDONE;
	scsi_done(xs);
	return (xs->flags & SCSI_POLL? COMPLETE : SUCCESSFULLY_QUEUED);
d1290 1
@


1.12
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.11 2001/09/11 20:05:25 miod Exp $	*/
a62 1
#include <vm/vm.h>
@


1.11
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.10 2001/07/04 22:53:25 espie Exp $	*/
d539 2
a540 1
		bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, BUS_DMASYNC_POSTREAD);
d663 2
a664 1
		bus_dmamap_sync(sc->dmat, dmap, BUS_DMASYNC_PREWRITE);
d666 2
a667 1
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, BUS_DMASYNC_PREWRITE);
d864 2
a865 1
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap,
d878 2
a879 2
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap,
			    BUS_DMASYNC_POSTREAD);
@


1.10
log
@case labels without statements are not permitted by ANSI C... and gcc 3.0
warns about them.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.9 2001/06/25 01:11:37 mickey Exp $	*/
a63 1
#include <vm/vm_kern.h>
@


1.9
log
@partial endianess fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.8 2001/05/05 03:08:25 mickey Exp $	*/
d881 1
@


1.8
log
@left out the debugging enabled; from ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.7 2001/04/30 15:45:05 mickey Exp $	*/
d83 2
a84 2
/*	| AMI_D_MISC */
/*	| AMI_D_DMA */
d240 1
a240 1
		sc->sc_hdr[i].hd_size = sizes[i];
d320 2
a321 2
			ccb->ccb_cmdpa = sc->sc_cmdseg[0].ds_addr +
			    cmd->acc_id * sizeof(*cmd);
d323 2
a324 2
			ccb->ccb_sglistpa = sc->sc_sgseg[0].ds_addr +
			    cmd->acc_id * sizeof(*sg) * AMI_SGEPERCMD;
d348 1
a348 1
		cmd->acc_io.aio_data = pa;
d363 1
a363 1
			cmd->acc_io.aio_data = pa;
d373 1
a373 1
				sc->sc_memory = pi->api_ramsize;
d388 1
a388 1
			cmd->acc_io.aio_data = pa;
d396 1
a396 1
				cmd->acc_io.aio_data = kvtop((caddr_t)&inq);
d505 2
a506 1
	if (qidb & htole32((AMI_QIDB_EXEC | AMI_QIDB_ACK)))
d508 1
d513 3
a515 3
	bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, htole32(qidb));
	DELAY(10);
	return 0;
d524 1
a524 1

d526 2
a527 1
	if (sc->sc_mbox->acc_busy)
d529 2
a530 1

d532 2
a533 1
	if (qdb & htole32((AMI_QIDB_EXEC | AMI_QIDB_ACK)))
d535 1
d538 1
a538 1
	if (letoh32(qdb) == AMI_QODB_READY) {
d547 1
a547 2
		bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, htole32(qdb));
		DELAY(10);
d551 2
d592 1
a592 1

d596 1
a596 1

d648 1
a648 1
			cmd->acc_mbox.amb_data = htole32(ccb->ccb_sglistpa);
d807 3
a809 2
	for (rv = 1, status = 0, i = 100 * (xs? xs->timeout: 1000);
	     !status && rv && i--; DELAY(10))
d1196 2
a1197 2
		cmd->acc_mbox.amb_nsect = blockcnt;
		cmd->acc_mbox.amb_lba = blockno;
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.6 2001/04/16 09:06:34 deraadt Exp $	*/
d80 6
a85 1
int ami_debug = 0xffff;
d124 1
a124 1
void ami_requeue __P((void *v));
d141 1
a142 1
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ccb_link);
d243 1
a243 1
		if (sizes[i] > 0x200000) {
d257 1
d275 1
a275 1
	    sizeof(struct ami_iocmd), AMI_MAXCMDS + 1, "command");
d283 1
a283 1
	    sizeof(struct ami_sgent) * AMI_SGEPERCMD, AMI_MAXCMDS, "sglist");
d332 2
a335 2
		struct ami_inquiry *inq = idata;
		struct ami_fc_einquiry *einq = idata;
d337 3
d350 1
d380 2
d398 1
d423 2
d426 1
a426 1
			sc->sc_maxcmds = AMI_MAXCMDS;
d430 12
a441 2
	/* TODO: fetch & print cache strategy */
	/* TODO: fetch & print scsi and raid info */
d448 2
a449 1
	timeout_set(&sc->sc_requeue_tmo, ami_requeue, sc);
a456 1
	sc->sc_link_raw = sc->sc_link;
d459 24
d484 2
a485 7
#if notyet
	sc->sc_link_raw.device = &ami_raw_dev;
	sc->sc_link_raw.adapter = &ami_raw_switch;
	sc->sc_link_raw.adapter_target = AMI_MAX_PDRIVES;
	sc->sc_link_raw.adapter_buswidth = AMI_MAX_PDRIVES;

	config_found(&sc->sc_dev, &sc->sc_link_raw, scsiprint);
a486 1

d498 1
a498 1
ami_quartz_exec(sc)
d500 1
d505 4
a508 2
	if (letoh32(qidb) & AMI_QIDB_EXEC)
		return EBUSY;
d512 1
d521 9
a529 1
	u_int32_t qodb;
d531 2
a532 2
	qodb = bus_space_read_4(sc->iot, sc->ioh, AMI_QODB);
	if (letoh32(qodb) == AMI_QODB_READY) {
d534 1
d540 4
a543 3
		qodb = sc->sc_mbox_pa | AMI_QIDB_ACK;
		bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, htole32(qodb));
		return 1;
d546 1
a546 1
	return 0;
d567 1
a567 1
ami_schwartz_exec(sc)
d569 1
d572 3
a574 1
		return EAGAIN;
d586 7
d614 1
a614 1
	int error, s, i;
a659 4
	/* XXX somehow interrupts have started to happen in autoconf() */
	if (wait)
		s = splbio();

d661 2
d666 2
a667 1
	} else if (wait)
d670 1
a670 3

	if (wait)
		splx(s);
d682 1
d684 1
a684 1
	int s, i;
d694 4
a697 1
	if (mbox->acc_busy && !wait) {
d699 8
a706 11
		ccb->ccb_state = AMI_CCB_PREQUEUED;
		s = splclock();
		TAILQ_INSERT_TAIL(&sc->sc_ccb2q, ccb, ccb_link);
		if (!sc->sc_timeout) {
			sc->sc_timeout++;
			splx(s);
			timeout_add(&sc->sc_requeue_tmo, 0);
		} else
			splx(s);
		return 0;
	}
d708 1
a708 1
	for (i = 10000; i-- && mbox->acc_busy; DELAY(100));
d710 4
a713 3
	if (mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return 1;
a717 3
	ccb->ccb_state = AMI_CCB_QUEUED;
	TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);

a720 1
	*mbox = *cmd;
d722 19
a740 2
	if ((i = (sc->sc_exec)(sc)))
		cmd->acc_busy = 0;
d746 1
a746 1
ami_requeue(v)
d749 4
a752 3
	struct ami_softc *sc = v;
	struct ami_ccb *ccb;
	struct ami_iocmd *cmd;
d754 1
a754 1
	int s;
d756 6
a761 4
	if (mbox->acc_busy) {
		timeout_add(&sc->sc_requeue_tmo, 1);
		return;
	}
d763 2
a764 4
	s = splclock();
	ccb = TAILQ_FIRST(&sc->sc_ccb2q);
	TAILQ_REMOVE(&sc->sc_ccb2q, ccb, ccb_link);
	splx(s);
d766 8
a773 3
	cmd = ccb->ccb_cmd;
	AMI_DPRINTF(AMI_D_CMD, ("requeue(%d) ", cmd->acc_id));
	ccb->ccb_state = AMI_CCB_READY;
d775 14
a788 7
	if (!ami_start(ccb, 0))
		AMI_DPRINTF(AMI_D_CMD, ("requeue(%d) again\n", cmd->acc_id));

	if (!TAILQ_EMPTY(&sc->sc_ccb2q))
		timeout_add(&sc->sc_requeue_tmo, 1);
	else
		sc->sc_timeout = 0;
d796 1
d800 2
a801 1
	for (rv = 1, status = 0, i = 10000; !status && rv && i--; DELAY(100))
d803 1
a803 1
			AMI_DPRINTF(AMI_D_CMD, ("got-%d ", mbox.acc_nstat));
a809 1
				/* XXX could it happen that scsi_done allocs it? */
d811 1
a811 1
				    ccb->ccb_state == AMI_CCB_FREE)
a832 1
	struct scsi_xfer *xs;
d834 2
d837 1
a837 1
	AMI_DPRINTF(AMI_D_CMD, ("done(%d) ", idx));
d845 1
d847 2
d850 2
a851 1
	if ((xs = ccb->ccb_xs)) {
a866 1
		case AMI_READ:
a870 5
		case AMI_WRITE:
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
			break;
d876 1
d878 1
d883 1
d921 10
d933 70
a1002 3
	/* XXX Not yet implemented */
	xs->error = XS_DRIVER_STUFFUP;
	return (COMPLETE);
d1030 1
d1032 2
d1039 1
a1106 1
			return (TRY_AGAIN_LATER);
d1123 2
d1126 4
d1131 4
d1136 4
d1141 4
d1171 1
a1171 2
				scsi_done(xs);
				return (COMPLETE);
d1177 1
d1179 2
a1180 2
			scsi_done(xs);
			return (COMPLETE);
d1184 2
a1186 1
		ccb->ccb_len  = xs->datalen;
a1203 6
#ifdef DIAGNOSTIC
		default:
			printf("%s: but how?\n", sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			return (COMPLETE);
#endif
d1211 1
d1217 1
a1217 2
				scsi_done(xs);
				return (COMPLETE);
d1222 2
a1223 5

		if (xs->flags & SCSI_POLL) {
			scsi_done(xs);
			return (COMPLETE);
		}
d1231 3
a1233 1
	return (COMPLETE);
d1243 4
d1248 3
d1252 2
a1253 1
		AMI_DPRINTF(AMI_D_CMD, ("got-%d ", mbox.acc_nstat));
d1257 1
a1257 1
			AMI_DPRINTF(AMI_D_CMD, ("ready=%x ", ready));
d1260 1
a1260 1
				rv++;
d1262 7
d1270 1
d1272 1
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.8.2.1 2001/05/14 22:23:28 niklas Exp $	*/
d80 1
a80 6
int ami_debug = 0
	| AMI_D_CMD
	| AMI_D_INTR
	| AMI_D_MISC
	| AMI_D_DMA
	;
d119 1
a119 1
void ami_stimeout __P((void *v));
d136 1
a137 1
		ccb->ccb_state = AMI_CCB_READY;
d235 1
a235 1
		sc->sc_hdr[i].hd_size = letoh32(sizes[i]);
d238 1
a238 1
		if (sc->sc_hdr[i].hd_size > 0x200000) {
a251 1
	/* struct ami_rawsoftc *rsc; */
d269 1
a269 1
	    sizeof(struct ami_iocmd), AMI_MAXCMDS+1, "command");
d277 1
a277 1
	    sizeof(struct ami_sgent) * AMI_SGEPERCMD, AMI_MAXCMDS+1, "sglist");
d314 2
a315 2
			ccb->ccb_cmdpa = htole32(sc->sc_cmdseg[0].ds_addr +
			    cmd->acc_id * sizeof(*cmd));
d317 2
a318 2
			ccb->ccb_sglistpa = htole32(sc->sc_sgseg[0].ds_addr +
			    cmd->acc_id * sizeof(*sg) * AMI_SGEPERCMD);
a325 2
	timeout_set(&sc->sc_poll_tmo, (void (*)__P((void *)))ami_intr, sc);

d328 2
a330 3
		ami_lock_t lock;

		lock = AMI_LOCK_AMI(sc);
d339 1
a339 1
		cmd->acc_io.aio_data = htole32(pa);
a340 1
			struct ami_fc_einquiry *einq = idata;
d353 1
a353 1
			cmd->acc_io.aio_data = htole32(pa);
d363 1
a363 1
				sc->sc_memory = letoh16(pi->api_ramsize);
a369 2
			struct ami_inquiry *inq = idata;

d376 1
a376 1
			cmd->acc_io.aio_data = htole32(pa);
d384 1
a384 1
				cmd->acc_io.aio_data = htole32(pa);
a385 1
					AMI_UNLOCK_AMI(sc, lock);
a409 2
		AMI_UNLOCK_AMI(sc, lock);

d411 1
a411 1
			sc->sc_maxcmds = 1 /* AMI_MAXCMDS */;
d415 2
a416 12
	/* hack for hp netraid version encoding */
	if ('A' <= sc->sc_fwver[2] && sc->sc_fwver[2] <= 'Z' &&
	    sc->sc_fwver[1] < ' ' && sc->sc_fwver[0] < ' ' &&
	    'A' <= sc->sc_biosver[2] && sc->sc_biosver[2] <= 'Z' &&
	    sc->sc_biosver[1] < ' ' && sc->sc_biosver[0] < ' ') {

		sprintf(sc->sc_fwver, "%c.%02d.%02d", sc->sc_fwver[2],
		    sc->sc_fwver[1], sc->sc_fwver[0]);
		sprintf(sc->sc_biosver, "%c.%02d.%02d", sc->sc_biosver[2],
		    sc->sc_biosver[1], sc->sc_biosver[0]);
	}

d423 1
a423 2
	/* TODO: fetch & print cache strategy */
	/* TODO: fetch & print scsi and raid info */
d431 1
a433 24
#if 0
	rsc = malloc(sizeof(struct ami_rawsoftc) * sc->sc_channels,
	    M_DEVBUF, M_NOWAIT);
	if (!rsc) {
		printf("%s: no memory for raw interface\n",
		    sc->sc_dev.dv_xname);
		return (0);
	}

	bzero(rsc, sizeof(struct ami_rawsoftc) * sc->sc_channels);
	for (sc->sc_rawsoftcs = rsc;
	     rsc < &sc->sc_rawsoftcs[sc->sc_channels]; rsc++) {

		/* TODO fetch and print channel properties */

		rsc->sc_softc = sc;
		rsc->sc_channel = rsc - sc->sc_rawsoftcs;
		rsc->sc_link.device = &ami_raw_dev;
		rsc->sc_link.openings = sc->sc_maxcmds;
		rsc->sc_link.adapter_softc = rsc;
		rsc->sc_link.adapter = &ami_raw_switch;
		/* TODO fetch it from the controller */
		rsc->sc_link.adapter_target = sc->sc_targets;
		rsc->sc_link.adapter_buswidth = sc->sc_targets;
d435 7
a441 2
		config_found(&sc->sc_dev, &rsc->sc_link, scsiprint);
	}
d443 1
d455 1
a455 1
ami_quartz_exec(sc, cmd)
a456 1
	struct ami_iocmd *cmd;
d461 2
a462 6
	if (qidb & (AMI_QIDB_EXEC | AMI_QIDB_ACK)) {
		AMI_DPRINTF(AMI_D_CMD, ("qidb=%x ", qidb));
		return (EBUSY);
	}

	*sc->sc_mbox = *cmd;
d465 2
a466 3
	AMI_DPRINTF(AMI_D_CMD, ("qidb=%x ", qidb));
	bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, qidb);
	return (0);
d474 1
a474 13
	u_int32_t qdb;
#if 0
	/* do not scramble the busy mailbox */
	if (sc->sc_mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (0);
	}
#endif
	qdb = bus_space_read_4(sc->iot, sc->ioh, AMI_QIDB);
	if (qdb & (AMI_QIDB_EXEC | AMI_QIDB_ACK)) {
		AMI_DPRINTF(AMI_D_CMD, ("qidb=%x ", qdb));
		return (0);
	}
d476 2
a477 2
	qdb = bus_space_read_4(sc->iot, sc->ioh, AMI_QODB);
	if (qdb == AMI_QODB_READY) {
a478 1
		bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, BUS_DMASYNC_POSTREAD);
d484 3
a486 3
		qdb = sc->sc_mbox_pa | AMI_QIDB_ACK;
		bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, qdb);
		return (1);
d489 1
a489 3
	AMI_DPRINTF(AMI_D_CMD, ("qodb=%x ", qdb));

	return (0);
d510 1
a510 1
ami_schwartz_exec(sc, cmd)
a511 1
	struct ami_iocmd *cmd;
d514 1
a514 3
		return EBUSY;

	*sc->sc_mbox = *cmd;
a524 7
#if 0
	/* do not scramble the busy mailbox */
	if (sc->sc_mbox->acc_busy)
		return (0);
#endif
	if (bus_space_read_1(sc->iot, sc->ioh, AMI_SMBSTAT) & AMI_SMBST_BUSY)
		return 0;
d547 1
a547 1
	int error = 0, i;
d574 1
a574 1
			cmd->acc_mbox.amb_data = ccb->ccb_sglistpa;
d593 4
a597 2
		AMI_DPRINTF(AMI_D_DMA, ("error=%d ", error));
		__asm __volatile(".globl _bpamierr\n_bpamierr:");
d601 1
a601 2
	} else if (wait) {
		AMI_DPRINTF(AMI_D_DMA, ("waiting "));
d604 3
a606 1
	}
a617 1
	struct scsi_xfer *xs = ccb->ccb_xs;
d619 1
a619 1
	int i;
d629 1
a629 2
	if (xs)
		timeout_set(&xs->stimeout, ami_stimeout, ccb);
d631 11
a641 1
	if (mbox->acc_busy) {
d643 1
a643 5
		if (!wait) {
			AMI_DPRINTF(AMI_D_CMD, ("2queue(%d) ", cmd->acc_id));
			ccb->ccb_state = AMI_CCB_PREQUEUED;
			if (xs)
				timeout_add(&xs->stimeout, 1);
d645 3
a647 9
			return (xs? 0 : EBUSY);
		}

		for (i = 100000; i-- && mbox->acc_busy; DELAY(10));

		if (mbox->acc_busy) {
			AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
			return (EAGAIN);
		}
d652 3
d658 1
d660 2
a661 19
	if (!(i = (sc->sc_exec)(sc, cmd))) {
		ccb->ccb_state = AMI_CCB_QUEUED;
		TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);
		if (!wait) {
#ifdef AMI_POLLING
			if (!timeout_pending(&sc->sc_poll_tmo))
				timeout_add(&sc->sc_poll_tmo, 1);
#endif
			if (xs)
				/*timeout_add(&xs->stimeout, hz * xs->timeout / 1000)*/;
		}
	} else if (!wait) {
		AMI_DPRINTF(AMI_D_CMD, ("2queue1(%d) ", cmd->acc_id));
		ccb->ccb_state = AMI_CCB_PREQUEUED;
		if (xs) {
			timeout_add(&xs->stimeout, 1);
			return (0);
		}
	}
d667 1
a667 1
ami_stimeout(v)
d670 3
a672 4
	struct ami_ccb *ccb = v;
	struct ami_softc *sc = ccb->ccb_sc;
	struct scsi_xfer *xs = ccb->ccb_xs;
	struct ami_iocmd *cmd = ccb->ccb_cmd;
d674 6
a679 1
	ami_lock_t lock;
d681 4
a684 6
	switch (ccb->ccb_state) {
	case AMI_CCB_PREQUEUED:
		if (mbox->acc_busy) {
			timeout_add(&xs->stimeout, 1);
			return;
		}
d686 3
a688 2
		AMI_DPRINTF(AMI_D_CMD, ("requeue(%d) ", cmd->acc_id));
		ccb->ccb_state = AMI_CCB_READY;
d690 2
a691 8
		lock = AMI_LOCK_AMI(sc);
		if (ami_start(ccb, 0)) {
			AMI_DPRINTF(AMI_D_CMD, ("requeue(%d) again\n", cmd->acc_id));
			ccb->ccb_state = AMI_CCB_PREQUEUED;
			timeout_add(&xs->stimeout, 1);
		}
		AMI_UNLOCK_AMI(sc, lock);
		break;
d693 4
a696 14
	case AMI_CCB_QUEUED:
		/* XXX need to kill all cmds in the queue and reset the card */
		AMI_DPRINTF(AMI_D_CMD, ("timeout(%d) ", cmd->acc_id));
		lock = AMI_LOCK_AMI(sc);
		TAILQ_REMOVE(&sc->sc_ccbq, ccb, ccb_link);
		ami_put_ccb(ccb);
		AMI_UNLOCK_AMI(sc, lock);
		xs->error = XS_TIMEOUT;
		scsi_done(xs);
		break;
	case AMI_CCB_FREE:
	case AMI_CCB_READY:
		panic("ami_stimeout(%p) botch", cmd->acc_id);
	}
a703 1
	struct scsi_xfer *xs = ccb->ccb_xs;
d707 1
a707 3
	DELAY(10000000);
	for (rv = 1, status = 0, i = 1 * (xs? xs->timeout: 1000);
	     !status && rv && i--; DELAY(1000))
d709 1
a709 1
			AMI_DPRINTF(AMI_D_CMD, ("got#%d ", mbox.acc_nstat));
d716 1
d718 1
a718 1
				    ccb->ccb_cmd->acc_id == ready)
d740 1
a741 2
	struct scsi_xfer *xs = ccb->ccb_xs;
	ami_lock_t lock;
d743 1
a743 1
	AMI_DPRINTF(AMI_D_CMD, ("done(%d) ", ccb->ccb_cmd->acc_id));
a750 1
	lock = AMI_LOCK_AMI(sc);
a751 2
	ccb->ccb_state = AMI_CCB_READY;
	AMI_UNLOCK_AMI(sc, lock);
d753 1
a753 2
	if (xs) {
		timeout_del(&xs->stimeout);
d769 1
d774 5
a783 1
	lock = AMI_LOCK_AMI(sc);
a784 1
	AMI_UNLOCK_AMI(sc, lock);
a788 1
		AMI_DPRINTF(AMI_D_CMD, ("scsi_done(%d) ", idx));
a825 10
	struct scsi_link *link = xs->sc_link;
	struct ami_rawsoftc *rsc = link->adapter_softc;
	struct ami_softc *sc = rsc->sc_softc;
	u_int8_t channel = rsc->sc_channel, target = link->target;
	struct ami_ccb *ccb, *ccb1;
	struct ami_iocmd *cmd;
	struct ami_passthrough *ps;
	int error;
	ami_lock_t lock;

d828 3
a830 70
	if (xs->cmdlen > AMI_MAX_CDB) {
		AMI_DPRINTF(AMI_D_CMD, ("CDB too big %p ", xs));
		bzero(&xs->sense, sizeof(xs->sense));
		xs->sense.error_code = SSD_ERRCODE_VALID | 0x70;
		xs->sense.flags = SKEY_ILLEGAL_REQUEST;
		xs->sense.add_sense_code = 0x20; /* illcmd, 0x24 illfield */
		xs->error = XS_SENSE;
		scsi_done(xs);
		return (COMPLETE);
	}

	xs->error = XS_NOERROR;

	lock = AMI_LOCK_AMI(sc);

	if ((ccb = ami_get_ccb(sc)) == NULL) {
		AMI_UNLOCK_AMI(sc, lock);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return (COMPLETE);
	}

	if ((ccb1 = ami_get_ccb(sc)) == NULL) {
		ami_put_ccb(ccb);
		AMI_UNLOCK_AMI(sc, lock);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return (COMPLETE);
	}

	ccb->ccb_xs = xs;
	ccb->ccb_ccb1 = ccb1;
	ccb->ccb_len  = xs->datalen;
	ccb->ccb_data = xs->data;

	ps = (struct ami_passthrough *)ccb1->ccb_cmd;
	ps->apt_param = AMI_PTPARAM(AMI_TIMEOUT_6,1,0);
	ps->apt_channel = channel;
	ps->apt_target = target;
	bcopy(xs->cmd, ps->apt_cdb, AMI_MAX_CDB);
	ps->apt_ncdb = xs->cmdlen;
	ps->apt_nsense = AMI_MAX_SENSE;

	cmd = ccb->ccb_cmd;
	cmd->acc_cmd = AMI_PASSTHRU;
	cmd->acc_passthru.apt_data = ccb1->ccb_cmdpa;

	if ((error = ami_cmd(ccb, ((xs->flags & SCSI_NOSLEEP)?
	    BUS_DMA_NOWAIT : BUS_DMA_WAITOK), xs->flags & SCSI_POLL))) {

		AMI_UNLOCK_AMI(sc, lock);
		AMI_DPRINTF(AMI_D_CMD, ("failed %p ", xs));
		if (xs->flags & SCSI_POLL) {
			xs->error = XS_TIMEOUT;
			return (TRY_AGAIN_LATER);
		} else {
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return (COMPLETE);
		}
	}

	AMI_UNLOCK_AMI(sc, lock);

	if (xs->flags & SCSI_POLL) {
		scsi_done(xs);
		return (COMPLETE);
	}

	return (SUCCESSFULLY_QUEUED);
a857 1
		/* XXX should be XS_SENSE and sense filled out */
a858 2
		xs->flags |= ITSDONE;
		scsi_done(xs);
a863 1
	error = 0;
d931 1
a947 2
		AMI_DPRINTF(AMI_D_CMD, ("SYNCHRONIZE CACHE "));
		error++;
a948 4
		if (!error) {
			AMI_DPRINTF(AMI_D_CMD, ("READ "));
			error++;
		}
a949 4
		if (!error) {
			AMI_DPRINTF(AMI_D_CMD, ("READ BIG "));
			error++;
		}
a950 4
		if (!error) {
			AMI_DPRINTF(AMI_D_CMD, ("WRITE "));
			error++;
		}
a951 4
		if (!error) {
			AMI_DPRINTF(AMI_D_CMD, ("WRITE BIG "));
			error++;
		}
d978 2
a979 1
				break;
a984 1
			AMI_DPRINTF(AMI_D_CMD, ("no more ccbs "));
d986 2
a987 2
		__asm __volatile(".globl _bpamiccb\n_bpamiccb:");
			break;
d991 1
a991 1
		ccb->ccb_ccb1 = NULL;
a992 1
		ccb->ccb_data = xs->data;
d994 2
a995 2
		cmd->acc_mbox.amb_nsect = htole16(blockcnt);
		cmd->acc_mbox.amb_lba = htole32(blockno);
d1010 6
a1022 1
		__asm __volatile(".globl _bpamifail\n_bpamifail:");
d1028 2
a1029 1
				break;
d1034 5
a1038 2
		if (xs->flags & SCSI_POLL)
			break;
d1046 1
a1046 3
	xs->flags |= ITSDONE;
	scsi_done(xs);
	return (xs->flags & SCSI_POLL? COMPLETE : SUCCESSFULLY_QUEUED);
a1055 6
	ami_lock_t lock;

	if (TAILQ_EMPTY(&sc->sc_ccbq))
		return (0);

	AMI_DPRINTF(AMI_D_INTR, ("intr "));
a1056 1
	lock = AMI_LOCK_AMI(sc);
d1058 1
a1058 2
		AMI_UNLOCK_AMI(sc, lock);
		AMI_DPRINTF(AMI_D_CMD, ("got#%d ", mbox.acc_nstat));
d1062 1
a1062 1
			AMI_DPRINTF(AMI_D_CMD, ("ready=%d ", ready));
d1065 1
a1065 1
				rv = 1;
a1066 1
		lock = AMI_LOCK_AMI(sc);
a1068 8
#ifdef AMI_POLLING
	if (!TAILQ_EMPTY(&sc->sc_ccbq) && !timeout_pending(&sc->sc_poll_tmo)) {
		AMI_DPRINTF(AMI_D_INTR, ("tmo "));
		timeout_add(&sc->sc_poll_tmo, 100);
	}
#endif

	AMI_UNLOCK_AMI(sc, lock);
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.8.2.2 2001/07/04 10:40:32 niklas Exp $	*/
d64 1
a880 1
			break;
@


1.8.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
d539 1
a539 2
		bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0,
		    sc->sc_cmdmap->dm_mapsize, BUS_DMASYNC_POSTREAD);
d662 1
a662 2
		bus_dmamap_sync(sc->dmat, dmap, 0, dmap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);
d664 1
a664 2
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, sc->sc_cmdmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
d861 1
a861 2
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize,
d874 2
a875 2
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
@


1.8.2.5
log
@Merge in trunk
@
text
@d81 2
a82 2
/*	| AMI_D_MISC */
/*	| AMI_D_DMA */
d290 1
a326 2
			AMI_DPRINTF(AMI_D_CMD, ("mbox_pa=%llx ",
			    sc->sc_mbox_pa));
a501 6
	/* do not scramble the busy mailbox */
	if (sc->sc_mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (0);
	}

d504 1
a504 1
		AMI_DPRINTF(AMI_D_CMD, ("qidb1=%x ", qidb));
d511 1
a511 1
	AMI_DPRINTF(AMI_D_CMD, ("qidb2=%x ", qidb));
d522 1
a522 1

d528 1
a528 1

d531 1
a531 1
		AMI_DPRINTF(AMI_D_CMD, ("qidb3=%x ", qdb));
d664 1
a664 2
	} else
		ccb->ccb_cmd->acc_mbox.amb_nsge = htole32(0);
d705 10
a714 1
	if (wait && mbox->acc_busy) {
d739 1
a739 1
				timeout_add(&xs->stimeout, hz * xs->timeout / 1000);
d741 1
a741 1
	} else if (!wait && xs) {
d744 4
a747 2
		timeout_add(&xs->stimeout, 1);
		return (0);
a763 1
	lock = AMI_LOCK_AMI(sc);
d768 1
a768 1
			break;
d772 1
d774 1
a774 1
		ccb->ccb_state = AMI_CCB_READY;
d780 1
d786 1
a786 9
		if (xs->cmd->opcode != PREVENT_ALLOW &&
		    xs->cmd->opcode != SYNCHRONIZE_CACHE) {
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap, 0,
			    ccb->ccb_dmamap->dm_mapsize,
			    (xs->flags & SCSI_DATA_IN) ?
			    BUS_DMASYNC_POSTREAD :
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
		}
d789 1
a796 1
	AMI_UNLOCK_AMI(sc, lock);
d808 3
a810 3
	i = 1 * (xs? xs->timeout: 1000);
	AMI_DPRINTF(AMI_D_CMD, ("%d ", i));
	for (rv = 1, status = 0; !status && rv && i--; DELAY(1000))
d857 1
a869 1
		ccb->ccb_xs = NULL;
d887 1
d1156 1
d1158 1
a1158 1
		flags = xs->flags;
d1173 1
a1173 1
					flags |= 0;
d1182 1
a1182 2
				scsi_done(xs);
				return (COMPLETE);
a1185 1
		lock = AMI_LOCK_AMI(sc);
a1189 1
			scsi_done(xs);
d1191 1
a1191 1
			return (COMPLETE);
a1205 1
			flags |= SCSI_POLL;
d1217 2
a1218 2
		if ((error = ami_cmd(ccb, ((flags & SCSI_NOSLEEP)?
		    BUS_DMA_NOWAIT : BUS_DMA_WAITOK), flags & SCSI_POLL))) {
d1223 1
a1223 1
			if (flags & SCSI_POLL) {
d1228 1
a1228 2
				scsi_done(xs);
				return (COMPLETE);
d1233 3
a1235 4
		if (flags & SCSI_POLL)
			return (COMPLETE);
		else
			return (SUCCESSFULLY_QUEUED);
d1242 3
a1244 1
	return (COMPLETE);
a1283 1
	AMI_DPRINTF(AMI_D_INTR, ("exit "));
@


1.8.2.6
log
@Merge in -current from about a week ago
@
text
@d92 2
a93 2
int	ami_scsi_cmd(struct scsi_xfer *xs);
void	amiminphys(struct buf *bp);
d103 1
a103 1
int	ami_scsi_raw_cmd(struct scsi_xfer *xs);
d113 16
a128 16
static __inline struct ami_ccb *ami_get_ccb(struct ami_softc *sc);
static __inline void ami_put_ccb(struct ami_ccb *ccb);
void ami_copyhds(struct ami_softc *sc, const u_int32_t *sizes,
	const u_int8_t *props, const u_int8_t *stats);
void *ami_allocmem(bus_dma_tag_t dmat, bus_dmamap_t *map,
	bus_dma_segment_t *segp, size_t isize, size_t nent, const char *iname);
void ami_freemem(bus_dma_tag_t dmat, bus_dmamap_t *map,
	bus_dma_segment_t *segp, size_t isize, size_t nent, const char *iname);
void ami_dispose(struct ami_softc *sc);
void ami_stimeout(void *v);
int  ami_cmd(struct ami_ccb *ccb, int flags, int wait);
int  ami_start(struct ami_ccb *ccb, int wait);
int  ami_complete(struct ami_ccb *ccb);
int  ami_done(struct ami_softc *sc, int idx);
void ami_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size);
int  ami_inquire(struct ami_softc *sc, u_int8_t op);
d331 1
a331 1
	timeout_set(&sc->sc_poll_tmo, (void (*)(void *))ami_intr, sc);
@


1.8.2.7
log
@Sync the SMP branch with 3.3
@
text
@d367 1
a367 1
				sc->sc_fwver[15] = '\0';
d369 1
a369 1
				sc->sc_biosver[15] = '\0';
a492 4
	bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, 0);
	bus_space_barrier(sc->iot, sc->ioh,
		    AMI_QIDB, 4, BUS_SPACE_BARRIER_WRITE);

d503 6
a508 2
	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_READ);
a514 6
	/* do not scramble the busy mailbox */
	if (sc->sc_mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (EBUSY);
	}

a515 2
	bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, sizeof(*cmd),
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
a519 2
	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_WRITE);
d530 6
a535 2
	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QIDB, 4, BUS_SPACE_BARRIER_READ);
a541 8
	/* do not scramble the busy mailbox */
	if (sc->sc_mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return (0);
	}

	bus_space_barrier(sc->iot, sc->ioh,
	    AMI_QODB, 4, BUS_SPACE_BARRIER_READ);
d545 2
a546 2
		bus_dmamap_sync(sc->dmat, sc->sc_cmdmap, 0, sizeof(*mbox),
		    BUS_DMASYNC_POSTWRITE);
a550 2
		bus_space_barrier(sc->iot, sc->ioh,
		    AMI_QODB, 4, BUS_SPACE_BARRIER_WRITE);
a553 2
		bus_space_barrier(sc->iot, sc->ioh,
		    AMI_QIDB, 4, BUS_SPACE_BARRIER_WRITE);
d627 1
a627 1
	int error = 0, i, s;
d642 1
a642 1
			return (error);
a675 1
	s = splimp();
a686 1
	splx(s);
d688 1
a688 1
	return (error);
d707 1
a707 1
		return (EINVAL);
d737 2
a738 6
			if (xs) {
				struct timeval tv;
				tv.tv_sec = xs->timeout / 1000;
				tv.tv_usec = 1000 * (xs->timeout % 1000);
				timeout_add(&xs->stimeout, tvtohz(&tv));
			}
d747 1
a747 1
	return (i);
d759 1
a759 1
	ami_lock_t lock, s;
a780 2
		printf("%s: timeout ccb %d\n",
		    sc->sc_dev.dv_xname, cmd->acc_id);
a790 1
		s = splimp();
a792 1
		splx(s);
a793 1
		xs->flags |= ITSDONE;
d848 1
a848 1
	ami_lock_t lock, s;
d855 1
a855 1
		return (1);
d859 1
a859 1
	s = splimp();
a860 1
	TAILQ_REMOVE(&sc->sc_ccbq, ccb, ccb_link);
d892 1
a892 1
	splx(s);
d901 1
a901 3
	AMI_UNLOCK_AMI(sc, lock);

	return (0);
a946 2
	lock = AMI_LOCK_AMI(sc);

a954 1
		AMI_UNLOCK_AMI(sc, lock);
d960 2
d963 1
a965 1
		AMI_UNLOCK_AMI(sc, lock);
d971 1
a973 1
		AMI_UNLOCK_AMI(sc, lock);
d997 1
a1000 1
			AMI_UNLOCK_AMI(sc, lock);
a1004 1
			AMI_UNLOCK_AMI(sc, lock);
d1009 1
a1012 1
		AMI_UNLOCK_AMI(sc, lock);
a1015 1
	AMI_UNLOCK_AMI(sc, lock);
a1041 3
	AMI_DPRINTF(AMI_D_CMD, ("ami_scsi_cmd "));

	lock = AMI_LOCK_AMI(sc);
a1043 1
		AMI_DPRINTF(AMI_D_CMD, ("no taget %d ", target));
a1047 1
		AMI_UNLOCK_AMI(sc, lock);
d1051 2
a1133 1
		AMI_UNLOCK_AMI(sc, lock);
d1179 1
a1184 1
				AMI_UNLOCK_AMI(sc, lock);
d1189 1
d1191 1
a1194 1
			AMI_UNLOCK_AMI(sc, lock);
d1210 2
a1211 1
		case SYNCHRONIZE_CACHE:
d1213 1
a1213 2
			if (xs->timeout < 30000)
				xs->timeout = 30000;	/* at least 30sec */
d1226 1
a1230 1
				AMI_UNLOCK_AMI(sc, lock);
a1234 1
				AMI_UNLOCK_AMI(sc, lock);
a1249 1
	AMI_UNLOCK_AMI(sc, lock);
d1259 1
a1259 1
	int i, s, rv = 0;
a1267 1
	s = splimp();	/* XXX need to do this to mask timeouts */
d1269 1
d1272 1
a1272 1
			int ready = mbox.acc_cmplidl[i];
d1277 1
a1277 1
				rv |= 1;
d1279 1
d1285 1
a1285 1
		timeout_add(&sc->sc_poll_tmo, 2);
a1288 1
	splx(s);
d1291 1
a1291 1
	return (rv);
@


1.8.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.8.2.7 2003/03/28 00:38:12 niklas Exp $	*/
d435 4
a438 4
		snprintf(sc->sc_fwver, sizeof sc->sc_fwver, "%c.%02d.%02d",
		    sc->sc_fwver[2], sc->sc_fwver[1], sc->sc_fwver[0]);
		snprintf(sc->sc_biosver, sizeof sc->sc_biosver, "%c.%02d.%02d",
		    sc->sc_biosver[2], sc->sc_biosver[1], sc->sc_biosver[0]);
d1123 3
a1125 4
		strlcpy(inq.vendor, "AMI    ", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Host drive  #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
@


1.8.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.8.2.8 2003/05/13 19:34:59 ho Exp $	*/
d18 5
@


1.8.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 2
d822 1
a822 1
		panic("ami_stimeout(%d) botch", cmd->acc_id);
@


1.7
log
@rework scsi stuff a bit, better locking.
still concurrent commands get busted, for some reason,
for tihs reason we lock to1 command at a time for now.
prev commit toamivar.h was a homeless -m.
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.6 2001/04/16 09:06:34 deraadt Exp $	*/
d52 1
a52 1
#define	AMI_DEBUG
@


1.6
log
@incorrect return value from ami_intr
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.5 2001/03/26 22:21:41 mickey Exp $	*/
d52 1
a52 1
/* #define	AMI_DEBUG */
d80 6
a85 1
int ami_debug = 0xffff;
d124 1
a124 1
void ami_requeue __P((void *v));
d141 1
a142 1
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ccb_link);
d243 1
a243 1
		if (sizes[i] > 0x200000) {
d257 1
d275 1
a275 1
	    sizeof(struct ami_iocmd), AMI_MAXCMDS + 1, "command");
d283 1
a283 1
	    sizeof(struct ami_sgent) * AMI_SGEPERCMD, AMI_MAXCMDS, "sglist");
d332 2
a335 2
		struct ami_inquiry *inq = idata;
		struct ami_fc_einquiry *einq = idata;
d337 3
d350 1
d380 2
d398 1
d423 2
d426 1
a426 1
			sc->sc_maxcmds = AMI_MAXCMDS;
d430 12
a441 2
	/* TODO: fetch & print cache strategy */
	/* TODO: fetch & print scsi and raid info */
d448 2
a449 1
	timeout_set(&sc->sc_requeue_tmo, ami_requeue, sc);
a456 1
	sc->sc_link_raw = sc->sc_link;
d459 24
d484 2
a485 7
#if notyet
	sc->sc_link_raw.device = &ami_raw_dev;
	sc->sc_link_raw.adapter = &ami_raw_switch;
	sc->sc_link_raw.adapter_target = AMI_MAX_PDRIVES;
	sc->sc_link_raw.adapter_buswidth = AMI_MAX_PDRIVES;

	config_found(&sc->sc_dev, &sc->sc_link_raw, scsiprint);
a486 1

d498 1
a498 1
ami_quartz_exec(sc)
d500 1
d505 4
a508 2
	if (letoh32(qidb) & AMI_QIDB_EXEC)
		return EBUSY;
d512 1
d521 9
a529 1
	u_int32_t qodb;
d531 2
a532 2
	qodb = bus_space_read_4(sc->iot, sc->ioh, AMI_QODB);
	if (letoh32(qodb) == AMI_QODB_READY) {
d534 1
d540 4
a543 3
		qodb = sc->sc_mbox_pa | AMI_QIDB_ACK;
		bus_space_write_4(sc->iot, sc->ioh, AMI_QIDB, htole32(qodb));
		return 1;
d546 1
a546 1
	return 0;
d567 1
a567 1
ami_schwartz_exec(sc)
d569 1
d572 3
a574 1
		return EAGAIN;
d586 7
d614 1
a614 1
	int error, s, i;
a659 4
	/* XXX somehow interrupts have started to happen in autoconf() */
	if (wait)
		s = splbio();

d661 2
d666 2
a667 1
	} else if (wait)
d670 1
a670 3

	if (wait)
		splx(s);
d682 1
d684 1
a684 1
	int s, i;
d694 4
a697 1
	if (mbox->acc_busy && !wait) {
d699 8
a706 11
		ccb->ccb_state = AMI_CCB_PREQUEUED;
		s = splclock();
		TAILQ_INSERT_TAIL(&sc->sc_ccb2q, ccb, ccb_link);
		if (!sc->sc_timeout) {
			sc->sc_timeout++;
			splx(s);
			timeout_add(&sc->sc_requeue_tmo, 0);
		} else
			splx(s);
		return 0;
	}
d708 1
a708 1
	for (i = 10000; i-- && mbox->acc_busy; DELAY(100));
d710 4
a713 3
	if (mbox->acc_busy) {
		AMI_DPRINTF(AMI_D_CMD, ("mbox_busy "));
		return 1;
a717 3
	ccb->ccb_state = AMI_CCB_QUEUED;
	TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ccb_link);

a720 1
	*mbox = *cmd;
d722 19
a740 2
	if ((i = (sc->sc_exec)(sc)))
		cmd->acc_busy = 0;
d746 1
a746 1
ami_requeue(v)
d749 4
a752 3
	struct ami_softc *sc = v;
	struct ami_ccb *ccb;
	struct ami_iocmd *cmd;
d754 1
a754 1
	int s;
d756 6
a761 4
	if (mbox->acc_busy) {
		timeout_add(&sc->sc_requeue_tmo, 1);
		return;
	}
d763 2
a764 4
	s = splclock();
	ccb = TAILQ_FIRST(&sc->sc_ccb2q);
	TAILQ_REMOVE(&sc->sc_ccb2q, ccb, ccb_link);
	splx(s);
d766 8
a773 3
	cmd = ccb->ccb_cmd;
	AMI_DPRINTF(AMI_D_CMD, ("requeue(%d) ", cmd->acc_id));
	ccb->ccb_state = AMI_CCB_READY;
d775 14
a788 7
	if (!ami_start(ccb, 0))
		AMI_DPRINTF(AMI_D_CMD, ("requeue(%d) again\n", cmd->acc_id));

	if (!TAILQ_EMPTY(&sc->sc_ccb2q))
		timeout_add(&sc->sc_requeue_tmo, 1);
	else
		sc->sc_timeout = 0;
d796 1
d800 2
a801 1
	for (rv = 1, status = 0, i = 10000; !status && rv && i--; DELAY(100))
d803 1
a803 1
			AMI_DPRINTF(AMI_D_CMD, ("got-%d ", mbox.acc_nstat));
a809 1
				/* XXX could it happen that scsi_done allocs it? */
d811 1
a811 1
				    ccb->ccb_state == AMI_CCB_FREE)
a832 1
	struct scsi_xfer *xs;
d834 2
d837 1
a837 1
	AMI_DPRINTF(AMI_D_CMD, ("done(%d) ", idx));
d845 1
d847 2
d850 2
a851 1
	if ((xs = ccb->ccb_xs)) {
a866 1
		case AMI_READ:
a870 5
		case AMI_WRITE:
			bus_dmamap_sync(sc->dmat, ccb->ccb_dmamap,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->dmat, ccb->ccb_dmamap);
			break;
d876 1
d878 1
d883 1
d921 10
d933 70
a1002 3
	/* XXX Not yet implemented */
	xs->error = XS_DRIVER_STUFFUP;
	return (COMPLETE);
d1030 1
d1032 2
d1039 1
a1106 1
			return (TRY_AGAIN_LATER);
d1123 2
d1126 4
d1131 4
d1136 4
d1141 4
d1171 1
a1171 2
				scsi_done(xs);
				return (COMPLETE);
d1177 1
d1179 2
a1180 2
			scsi_done(xs);
			return (COMPLETE);
d1184 2
a1186 1
		ccb->ccb_len  = xs->datalen;
a1203 6
#ifdef DIAGNOSTIC
		default:
			printf("%s: but how?\n", sc->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			return (COMPLETE);
#endif
d1211 1
d1217 1
a1217 2
				scsi_done(xs);
				return (COMPLETE);
d1222 2
a1223 5

		if (xs->flags & SCSI_POLL) {
			scsi_done(xs);
			return (COMPLETE);
		}
d1231 3
a1233 1
	return (COMPLETE);
d1243 4
d1248 3
d1252 2
a1253 1
		AMI_DPRINTF(AMI_D_CMD, ("got-%d ", mbox.acc_nstat));
d1257 1
a1257 1
			AMI_DPRINTF(AMI_D_CMD, ("ready=%x ", ready));
d1260 1
a1260 1
				rv++;
d1262 7
d1270 1
d1272 1
@


1.5
log
@fix scsi_done calling, locking, quartz_done
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.4 2001/03/15 00:43:08 deraadt Exp $	*/
d1055 1
a1055 1
	int i, rv;
@


1.4
log
@ensure that SYNCHRONIZE_CACHE works; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.3 2001/03/14 23:42:33 deraadt Exp $	*/
d485 1
a485 1
		bus_space_write_4(sc->iot, sc->ioh, AMI_QODB, htole32(qodb));
d977 1
a978 1
				xs->error = XS_DRIVER_STUFFUP;
d984 2
a986 1
			xs->error = XS_DRIVER_STUFFUP;
d1027 1
a1028 1
				xs->error = XS_DRIVER_STUFFUP;
@


1.3
log
@AMI and 3WARE have less of a relationship than this driver seems to indicate
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.2 2001/03/09 15:46:30 mickey Exp $	*/
d947 1
@


1.2
log
@give some dadaical credits and disable debugging
@
text
@d1 1
a1 1
/*	$OpenBSD: ami.c,v 1.1 2001/03/09 11:14:21 mickey Exp $	*/
d895 1
a895 1
		strcpy(inq.vendor, "3WARE  ");
@


1.1
log
@seems to work; rush because of cvs's battery at 73% now
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 15
d52 1
a52 1
#define	AMI_DEBUG
@

