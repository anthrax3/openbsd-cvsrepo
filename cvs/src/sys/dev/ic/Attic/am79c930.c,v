head	1.5;
access;
symbols
	OPENBSD_4_3:1.4.0.26
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.24
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.22
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.20
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.18
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.16
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.14
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.12
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2
	SMP_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2008.05.23.14.04.18;	author brad;	state dead;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.04.09.02.56;	author niklas;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2000.08.17.16.16.30;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	99.12.16.02.56.56;	author deraadt;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.05.14.22.23.27;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Bye bye awi(4). No net80211 love, uses its own WEP code and has not worked
properly in 8.5 years so just garbage collect the driver.

ok damien@@ deraadt@@
@
text
@/* $OpenBSD: am79c930.c,v 1.4 2002/03/14 01:26:54 millert Exp $ */
/* $NetBSD: am79c930.c,v 1.5 2000/03/23 13:57:58 onoe Exp $ */

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Am79c930 chip driver.
 *
 * This is used by the awi driver to use the shared
 * memory attached to the 79c930 to communicate with the firmware running
 * in the 930's on-board 80188 core.
 *
 * The 79c930 can be mapped into just I/O space, or also have a
 * memory mapping; the mapping must be set up by the bus front-end
 * before am79c930_init is called.
 */

/*
 * operations:
 *
 * read_8, read_16, read_32, read_64, read_bytes
 * write_8, write_16, write_32, write_64, write_bytes
 * (two versions, depending on whether memory-space or i/o space is in use).
 *
 * interrupt E.C.
 * start isr
 * end isr
 */

#include <sys/param.h>
#include <sys/systm.h>
#ifndef __FreeBSD__
#include <sys/device.h>
#endif

#include <machine/cpu.h>
#ifdef __FreeBSD__
#include <machine/bus_pio.h>
#include <machine/bus_memio.h>
#endif
#include <machine/bus.h>
#ifdef __NetBSD__
#include <machine/intr.h>
#endif

#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <dev/ic/am79c930reg.h>
#include <dev/ic/am79c930var.h>
#endif
#ifdef __FreeBSD__
#include <dev/awi/am79c930reg.h>
#include <dev/awi/am79c930var.h>
#endif

#define AM930_DELAY(x) /*nothing*/

void am79c930_regdump(struct am79c930_softc *sc);

static void io_write_1(struct am79c930_softc *, u_int32_t, u_int8_t);
static void io_write_2(struct am79c930_softc *, u_int32_t, u_int16_t);
static void io_write_4(struct am79c930_softc *, u_int32_t, u_int32_t);
static void io_write_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);

static u_int8_t io_read_1(struct am79c930_softc *, u_int32_t);
static u_int16_t io_read_2(struct am79c930_softc *, u_int32_t);
static u_int32_t io_read_4(struct am79c930_softc *, u_int32_t);
static void io_read_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);

static void mem_write_1(struct am79c930_softc *, u_int32_t, u_int8_t);
static void mem_write_2(struct am79c930_softc *, u_int32_t, u_int16_t);
static void mem_write_4(struct am79c930_softc *, u_int32_t, u_int32_t);
static void mem_write_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);

static u_int8_t mem_read_1(struct am79c930_softc *, u_int32_t);
static u_int16_t mem_read_2(struct am79c930_softc *, u_int32_t);
static u_int32_t mem_read_4(struct am79c930_softc *, u_int32_t);
static void mem_read_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);

static struct am79c930_ops iospace_ops = {
	io_write_1,
	io_write_2,
	io_write_4,
	io_write_bytes,
	io_read_1,
	io_read_2,
	io_read_4,
	io_read_bytes
};

struct am79c930_ops memspace_ops = {
	mem_write_1,
	mem_write_2,
	mem_write_4,
	mem_write_bytes,
	mem_read_1,
	mem_read_2,
	mem_read_4,
	mem_read_bytes
};

static void io_write_1 (sc, off, val)
	struct am79c930_softc *sc;
	u_int32_t off;
	u_int8_t val;
{
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA, val);
	AM930_DELAY(1);
}

static void io_write_2 (sc, off, val)
	struct am79c930_softc *sc;
	u_int32_t off;
	u_int16_t val;
{
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA, val & 0xff);
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA, (val>>8)&0xff);
	AM930_DELAY(1);
}

static void io_write_4 (sc, off, val)
	struct am79c930_softc *sc;
	u_int32_t off;
	u_int32_t val;
{
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA,val & 0xff);
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA,(val>>8)&0xff);
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA,(val>>16)&0xff);
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA,(val>>24)&0xff);
	AM930_DELAY(1);
}

static void io_write_bytes (sc, off, ptr, len)
	struct am79c930_softc *sc;
	u_int32_t off;
	u_int8_t *ptr;
	size_t len;
{
	int i;

	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	for (i=0; i<len; i++)
		bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA,ptr[i]);
}

static u_int8_t io_read_1 (sc, off)
	struct am79c930_softc *sc;
	u_int32_t off;
{
	u_int8_t val;
	
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	val = bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA);
	AM930_DELAY(1);
	return val;
}

static u_int16_t io_read_2 (sc, off)
	struct am79c930_softc *sc;
	u_int32_t off;
{
	u_int16_t val;

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	val = bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA);
	AM930_DELAY(1);
	val |= bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA) << 8;
	AM930_DELAY(1);	
	return val;
}

static u_int32_t io_read_4 (sc, off)
	struct am79c930_softc *sc;
	u_int32_t off;
{
	u_int32_t val;

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	val = bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA);
	AM930_DELAY(1);
	val |= bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA) << 8;
	AM930_DELAY(1);	
	val |= bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA) << 16;
	AM930_DELAY(1);	
	val |= bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA) << 24;
	AM930_DELAY(1);	
	return val;
}

static void io_read_bytes (sc, off, ptr, len)
	struct am79c930_softc *sc;
	u_int32_t off;
	u_int8_t *ptr;
	size_t len;
{
	int i;
	
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	for (i=0; i<len; i++) 
		ptr[i] = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    AM79C930_IODPA);
}

static void mem_write_1 (sc, off, val)
	struct am79c930_softc *sc;
	u_int32_t off;
	u_int8_t val;
{
	bus_space_write_1(sc->sc_memt, sc->sc_memh, off, val);
}

static void mem_write_2 (sc, off, val)
	struct am79c930_softc *sc;
	u_int32_t off;
	u_int16_t val;
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;

	/* could be unaligned */
	if ((off & 0x1) == 0)
		bus_space_write_2(t, h, off,    val);
	else {
		bus_space_write_1(t, h, off,    val        & 0xff);
		bus_space_write_1(t, h, off+1, (val >>  8) & 0xff);
	}
}

static void mem_write_4 (sc, off, val)
	struct am79c930_softc *sc;
	u_int32_t off;
	u_int32_t val;
{
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;

	/* could be unaligned */
	if ((off & 0x3) == 0)
		bus_space_write_4(t, h, off,    val);
	else {
		bus_space_write_1(t, h, off,    val        & 0xff);
		bus_space_write_1(t, h, off+1, (val >>  8) & 0xff);
		bus_space_write_1(t, h, off+2, (val >> 16) & 0xff);
		bus_space_write_1(t, h, off+3, (val >> 24) & 0xff);
	}
}

static void mem_write_bytes (sc, off, ptr, len)
	struct am79c930_softc *sc;
	u_int32_t off;
	u_int8_t *ptr;
	size_t len;
{
	bus_space_write_region_1 (sc->sc_memt, sc->sc_memh, off, ptr, len);
}


static u_int8_t mem_read_1 (sc, off)
	struct am79c930_softc *sc;
	u_int32_t off;
{
	return bus_space_read_1(sc->sc_memt, sc->sc_memh, off);
}

static u_int16_t mem_read_2 (sc, off)
	struct am79c930_softc *sc;
	u_int32_t off;
{
	/* could be unaligned */
	if ((off & 0x1) == 0)
		return bus_space_read_2(sc->sc_memt, sc->sc_memh, off);
	else
		return
		     bus_space_read_1(sc->sc_memt, sc->sc_memh, off  )       |
		    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+1) << 8);
}

static u_int32_t mem_read_4 (sc, off)
	struct am79c930_softc *sc;
	u_int32_t off;
{
	/* could be unaligned */
	if ((off & 0x3) == 0)
		return bus_space_read_4(sc->sc_memt, sc->sc_memh, off);
	else
		return
		     bus_space_read_1(sc->sc_memt, sc->sc_memh, off  )       |
		    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+1) << 8) |
		    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+2) <<16) |
		    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+3) <<24);
}



static void mem_read_bytes (sc, off, ptr, len)
	struct am79c930_softc *sc;
	u_int32_t off;
	u_int8_t *ptr;
	size_t len;
{
	bus_space_read_region_1 (sc->sc_memt, sc->sc_memh, off, ptr, len);
}




/*
 * Set bits in GCR.
 */

void am79c930_gcr_setbits (sc, bits)
	struct am79c930_softc *sc;
	u_int8_t bits;
{
	u_int8_t gcr = bus_space_read_1 (sc->sc_iot, sc->sc_ioh, AM79C930_GCR);

	gcr |= bits;
	
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_GCR, gcr);
}

/*
 * Clear bits in GCR.
 */

void am79c930_gcr_clearbits (sc, bits)
	struct am79c930_softc *sc;
	u_int8_t bits;
{
	u_int8_t gcr = bus_space_read_1 (sc->sc_iot, sc->sc_ioh, AM79C930_GCR);

	gcr &= ~bits;
	
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_GCR, gcr);
}

u_int8_t am79c930_gcr_read (sc)
	struct am79c930_softc *sc;
{
	return bus_space_read_1 (sc->sc_iot, sc->sc_ioh, AM79C930_GCR);
}

#if 0 
void am79c930_regdump (sc) 
	struct am79c930_softc *sc;
{
	u_int8_t buf[8];
	int i;

	AM930_DELAY(5);
	for (i=0; i<8; i++) {
		buf[i] = bus_space_read_1 (sc->sc_iot, sc->sc_ioh, i);
		AM930_DELAY(5);
	}
	printf("am79c930: regdump:");
	for (i=0; i<8; i++) {
		printf(" %02x", buf[i]);
	}
	printf("\n");
}
#endif

void am79c930_chip_init (sc, how)
	struct am79c930_softc *sc;
{
	/* zero the bank select register, and leave it that way.. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_BSS, 0);
	if (how)
	  	sc->sc_ops = &memspace_ops;
	else
	  	sc->sc_ops = &iospace_ops;
}


@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: am79c930.c,v 1.3 2001/07/04 09:02:56 niklas Exp $ */
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/* $OpenBSD: am79c930.c,v 1.5 2000/03/23 13:57:58 onoe Exp $ */
d91 1
a91 1
void am79c930_regdump __P((struct am79c930_softc *sc));
d93 19
a111 19
static void io_write_1 __P((struct am79c930_softc *, u_int32_t, u_int8_t));
static void io_write_2 __P((struct am79c930_softc *, u_int32_t, u_int16_t));
static void io_write_4 __P((struct am79c930_softc *, u_int32_t, u_int32_t));
static void io_write_bytes __P((struct am79c930_softc *, u_int32_t, u_int8_t *, size_t));

static u_int8_t io_read_1 __P((struct am79c930_softc *, u_int32_t));
static u_int16_t io_read_2 __P((struct am79c930_softc *, u_int32_t));
static u_int32_t io_read_4 __P((struct am79c930_softc *, u_int32_t));
static void io_read_bytes __P((struct am79c930_softc *, u_int32_t, u_int8_t *, size_t));

static void mem_write_1 __P((struct am79c930_softc *, u_int32_t, u_int8_t));
static void mem_write_2 __P((struct am79c930_softc *, u_int32_t, u_int16_t));
static void mem_write_4 __P((struct am79c930_softc *, u_int32_t, u_int32_t));
static void mem_write_bytes __P((struct am79c930_softc *, u_int32_t, u_int8_t *, size_t));

static u_int8_t mem_read_1 __P((struct am79c930_softc *, u_int32_t));
static u_int16_t mem_read_2 __P((struct am79c930_softc *, u_int32_t));
static u_int32_t mem_read_4 __P((struct am79c930_softc *, u_int32_t));
static void mem_read_bytes __P((struct am79c930_softc *, u_int32_t, u_int8_t *, size_t));
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: am79c930.c,v 1.3 2001/07/04 09:02:56 niklas Exp $ */
d91 1
a91 1
void am79c930_regdump(struct am79c930_softc *sc);
d93 19
a111 19
static void io_write_1(struct am79c930_softc *, u_int32_t, u_int8_t);
static void io_write_2(struct am79c930_softc *, u_int32_t, u_int16_t);
static void io_write_4(struct am79c930_softc *, u_int32_t, u_int32_t);
static void io_write_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);

static u_int8_t io_read_1(struct am79c930_softc *, u_int32_t);
static u_int16_t io_read_2(struct am79c930_softc *, u_int32_t);
static u_int32_t io_read_4(struct am79c930_softc *, u_int32_t);
static void io_read_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);

static void mem_write_1(struct am79c930_softc *, u_int32_t, u_int8_t);
static void mem_write_2(struct am79c930_softc *, u_int32_t, u_int16_t);
static void mem_write_4(struct am79c930_softc *, u_int32_t, u_int32_t);
static void mem_write_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);

static u_int8_t mem_read_1(struct am79c930_softc *, u_int32_t);
static u_int16_t mem_read_2(struct am79c930_softc *, u_int32_t);
static u_int32_t mem_read_4(struct am79c930_softc *, u_int32_t);
static void mem_read_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);
@


1.2
log
@replace if_awi w/ semi-current netbsd driver; still has problems
@
text
@d1 1
@


1.1
log
@non-working awi driver; someone finish it
@
text
@d1 1
a1 2
/* $NetBSD: am79c930.c,v 1.2 1999/11/05 05:13:36 sommerfeld Exp $ */
/* $OpenBSD$ */
d65 1
a65 1
#include <sys/kernel.h>
d67 1
d70 4
d75 1
d77 1
d79 1
d82 5
d88 1
a88 1
#define AM930_DELAY(x) /*nothing*/;
a138 1
	/* XXX bank-switching? */
d154 10
a163 2
	io_write_1(sc, off,    val       & 0xff);
	io_write_1(sc, off+1, (val >> 8) & 0xff);
d171 14
a184 5
	/* XXX higher offset values needed for bank-switching! */
	io_write_1(sc, off,    val        & 0xff);
	io_write_1(sc, off+1, (val >>  8) & 0xff);
	io_write_1(sc, off+2, (val >> 16) & 0xff);
	io_write_1(sc, off+3, (val >> 24) & 0xff);
d194 7
a200 2
	/* XXX higher offset values needed for bank-switching! */
	
d202 1
a202 1
		io_write_1 (sc, off+i, ptr[i]);
d225 12
a236 2
	return io_read_1 (sc, off) |
	    (io_read_1 (sc, off+1) << 8);
d243 16
a258 5
	/* XXX bank-switching? */
	return io_read_1 (sc, off) |
	    (io_read_1 (sc, off+1) << 8) |
	    (io_read_1 (sc, off+2) << 16) |
	    (io_read_1 (sc, off+3) << 24);
d269 5
d275 2
a276 1
		ptr[i] = io_read_1(sc, off+i);
a278 2


a283 1
	/* XXX higher offset values needed for bank-switching! */
d292 10
a301 3
	/* XXX higher offset values needed for bank-switching! */
	bus_space_write_1(sc->sc_memt, sc->sc_memh, off,    val       & 0xff);
	bus_space_write_1(sc->sc_memt, sc->sc_memh, off+1, (val >> 8) & 0xff);
d309 12
a320 5
	/* XXX higher offset values needed for bank-switching! */
	bus_space_write_1(sc->sc_memt, sc->sc_memh, off,    val        & 0xff);
	bus_space_write_1(sc->sc_memt, sc->sc_memh, off+1, (val >>  8) & 0xff);
	bus_space_write_1(sc->sc_memt, sc->sc_memh, off+2, (val >> 16) & 0xff);
	bus_space_write_1(sc->sc_memt, sc->sc_memh, off+3, (val >> 24) & 0xff);
d329 1
a329 5
	int i;
	/* XXX higher offset values needed for bank-switching! */
	
	for (i=0; i<len; i++)
		bus_space_write_1 (sc->sc_memt, sc->sc_memh, off+i, ptr[i]);
a336 1
	/* XXX higher offset values needed for bank-switching! */
d344 7
a350 4
	/* XXX higher offset values needed for bank-switching! */
	return
	    bus_space_read_1(sc->sc_memt, sc->sc_memh, off) |
	    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+1) <<8);
d357 9
a365 6
	/* XXX higher offset values needed for bank-switching! */
	return
	    bus_space_read_1(sc->sc_memt, sc->sc_memh, off) |
	    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+1) <<8)|
	    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+2) <<16) |
	    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+3) <<24);
d376 1
a376 6
	int i;
	
	/* XXX higher offset values needed for bank-switching! */

	for (i=0; i<len; i++) 
		ptr[i] = bus_space_read_1(sc->sc_memt, sc->sc_memh, off+i);
d448 2
@


1.1.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 1
/* $NetBSD: am79c930.c,v 1.5 2000/03/23 13:57:58 onoe Exp $ */
d66 1
a66 1
#ifndef __FreeBSD__
a67 1
#endif
a69 4
#ifdef __FreeBSD__
#include <machine/bus_pio.h>
#include <machine/bus_memio.h>
#endif
a70 1
#ifdef __NetBSD__
a71 1
#endif
a72 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a74 5
#endif
#ifdef __FreeBSD__
#include <dev/awi/am79c930reg.h>
#include <dev/awi/am79c930var.h>
#endif
d76 1
a76 1
#define AM930_DELAY(x) /*nothing*/
d127 1
d143 2
a144 10
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA, val & 0xff);
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA, (val>>8)&0xff);
	AM930_DELAY(1);
d152 5
a156 14
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA,val & 0xff);
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA,(val>>8)&0xff);
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA,(val>>16)&0xff);
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA,(val>>24)&0xff);
	AM930_DELAY(1);
d166 2
a167 7

	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
d169 1
a169 1
		bus_space_write_1(sc->sc_iot,sc->sc_ioh,AM79C930_IODPA,ptr[i]);
d192 2
a193 12
	u_int16_t val;

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	val = bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA);
	AM930_DELAY(1);
	val |= bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA) << 8;
	AM930_DELAY(1);	
	return val;
d200 5
a204 16
	u_int32_t val;

	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
	val = bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA);
	AM930_DELAY(1);
	val |= bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA) << 8;
	AM930_DELAY(1);	
	val |= bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA) << 16;
	AM930_DELAY(1);	
	val |= bus_space_read_1(sc->sc_iot, sc->sc_ioh, AM79C930_IODPA) << 24;
	AM930_DELAY(1);	
	return val;
a214 5
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_HI,
	    ((off>>8)& 0x7f));
	AM930_DELAY(1);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, AM79C930_LMA_LO, (off&0xff));
	AM930_DELAY(1);
d216 1
a216 2
		ptr[i] = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    AM79C930_IODPA);
d219 2
d226 1
d235 3
a237 10
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;

	/* could be unaligned */
	if ((off & 0x1) == 0)
		bus_space_write_2(t, h, off,    val);
	else {
		bus_space_write_1(t, h, off,    val        & 0xff);
		bus_space_write_1(t, h, off+1, (val >>  8) & 0xff);
	}
d245 5
a249 12
	bus_space_tag_t t = sc->sc_memt;
	bus_space_handle_t h = sc->sc_memh;

	/* could be unaligned */
	if ((off & 0x3) == 0)
		bus_space_write_4(t, h, off,    val);
	else {
		bus_space_write_1(t, h, off,    val        & 0xff);
		bus_space_write_1(t, h, off+1, (val >>  8) & 0xff);
		bus_space_write_1(t, h, off+2, (val >> 16) & 0xff);
		bus_space_write_1(t, h, off+3, (val >> 24) & 0xff);
	}
d258 5
a262 1
	bus_space_write_region_1 (sc->sc_memt, sc->sc_memh, off, ptr, len);
d270 1
d278 4
a281 7
	/* could be unaligned */
	if ((off & 0x1) == 0)
		return bus_space_read_2(sc->sc_memt, sc->sc_memh, off);
	else
		return
		     bus_space_read_1(sc->sc_memt, sc->sc_memh, off  )       |
		    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+1) << 8);
d288 6
a293 9
	/* could be unaligned */
	if ((off & 0x3) == 0)
		return bus_space_read_4(sc->sc_memt, sc->sc_memh, off);
	else
		return
		     bus_space_read_1(sc->sc_memt, sc->sc_memh, off  )       |
		    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+1) << 8) |
		    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+2) <<16) |
		    (bus_space_read_1(sc->sc_memt, sc->sc_memh, off+3) <<24);
d304 6
a309 1
	bus_space_read_region_1 (sc->sc_memt, sc->sc_memh, off, ptr, len);
a380 2


@


1.1.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/* $OpenBSD$ */
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d91 1
a91 1
void am79c930_regdump(struct am79c930_softc *sc);
d93 4
a96 4
static void io_write_1(struct am79c930_softc *, u_int32_t, u_int8_t);
static void io_write_2(struct am79c930_softc *, u_int32_t, u_int16_t);
static void io_write_4(struct am79c930_softc *, u_int32_t, u_int32_t);
static void io_write_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);
d98 4
a101 4
static u_int8_t io_read_1(struct am79c930_softc *, u_int32_t);
static u_int16_t io_read_2(struct am79c930_softc *, u_int32_t);
static u_int32_t io_read_4(struct am79c930_softc *, u_int32_t);
static void io_read_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);
d103 4
a106 4
static void mem_write_1(struct am79c930_softc *, u_int32_t, u_int8_t);
static void mem_write_2(struct am79c930_softc *, u_int32_t, u_int16_t);
static void mem_write_4(struct am79c930_softc *, u_int32_t, u_int32_t);
static void mem_write_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);
d108 4
a111 4
static u_int8_t mem_read_1(struct am79c930_softc *, u_int32_t);
static u_int16_t mem_read_2(struct am79c930_softc *, u_int32_t);
static u_int32_t mem_read_4(struct am79c930_softc *, u_int32_t);
static void mem_read_bytes(struct am79c930_softc *, u_int32_t, u_int8_t *, size_t);
@


