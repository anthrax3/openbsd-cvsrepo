head	1.49;
access;
symbols
	OPENBSD_5_7:1.48.0.4
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.48.0.8
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.48.0.6
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.47.0.6
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.47.0.2
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.4
	OPENBSD_5_0:1.46.0.2
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.45.0.2
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.4
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.6
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.22.0.4
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.24
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.5
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.49
date	2015.06.19.11.12.24;	author jmatthew;	state dead;
branches;
next	1.48;
commitid	I5HMIEQiHPSVn0jd;

1.48
date	2013.03.04.00.41.54;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2011.10.22.19.34.06;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2011.04.05.12.09.20;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2010.12.31.19.20.42;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.27.02.06.03;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.04.02.23.10;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.08.09.51.53;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.01.20.55.57;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.27.15.23.20;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.11.16.54.59;	author blambert;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.32;

1.32
date	2008.03.19.18.37.20;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.03.16.53.16;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2004.08.02.19.55.45;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.06.21.08.06;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.17.17.43.47;	author mjacob;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.17.01.32.35;	author mjacob;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.14.00.20.55;	author mjacob;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.12.13.00.15.40;	author nordin;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.01.07.16.40;	author mjacob;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.24.20.59.38;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.04.22.07.40;	author mjacob;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.12.23.47.11;	author mjacob;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.16.20.01.27;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.09.03.27.04;	author mjacob;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.06.01.07.22;	author mjacob;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.16.22.45.00;	author mjacob;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.16.01.02.00;	author mjacob;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.07.19.00.47;	author mjacob;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.06.05.31.48;	author mjacob;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.06.05.47.54;	author mjacob;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.05.22.22.55;	author mjacob;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.20.21.22.41;	author mjacob;	state Exp;
branches;
next	1.6;

1.6
date	99.12.16.05.25.39;	author mjacob;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.11.22.22.34.30;	author mjacob;	state Exp;
branches;
next	1.4;

1.4
date	99.11.22.12.50.53;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	99.03.25.22.58.38;	author mjacob;	state Exp;
branches;
next	1.2;

1.2
date	99.03.17.12.54.32;	author mjacob;	state Exp;
branches;
next	1.1;

1.1
date	99.03.17.05.26.09;	author mjacob;	state Exp;
branches;
next	;

1.6.2.1
date	2000.02.21.22.29.05;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.03.24.09.09.10;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.05.14.22.23.55;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.07.04.10.40.57;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2004.02.19.10.56.19;	author niklas;	state Exp;
branches;
next	;

1.22.2.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.10.29.00.33.25;	author art;	state Exp;
branches;
next	;


desc
@@


1.49
log
@remove isp(4) now that the ql* family have replaced it
@
text
@/* 	$OpenBSD: isp_openbsd.c,v 1.48 2013/03/04 00:41:54 dlg Exp $ */
/*
 * Platform (OpenBSD) dependent common attachment code for QLogic adapters.
 *
 * Copyright (c) 1999, 2000, 2001 by Matthew Jacob
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 *    documentation and/or other materials provided with the distribution.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The author may be reached via electronic communications at
 *
 *  mjacob@@feral.com
 *
 * or, via United States Postal Address
 *
 *  Matthew Jacob
 *  Feral Software
 *  PMB#825
 *  5214-F Diamond Heights Blvd.
 *  San Francisco, CA, 94131
 */

#include <dev/ic/isp_openbsd.h>

/*
 * Set a timeout for the watchdogging of a command.
 *
 * The dimensional analysis is
 *
 *	milliseconds * (seconds/millisecond) * (ticks/second) = ticks
 *
 *			=
 *
 *	(milliseconds / 1000) * hz = ticks
 *
 *
 * For timeouts less than 1 second, we'll get zero. Because of this, and
 * because we want to establish *our* timeout to be longer than what the
 * firmware might do, we just add 3 seconds at the back end.
 */
#define	_XT(xs)	((((xs)->timeout/1000) * hz) + (3 * hz))

static void ispminphys(struct buf *, struct scsi_link *);
static int isp_scsi_probe(struct scsi_link *);
static void ispcmd_slow(XS_T *);
static void ispcmd(XS_T *);

void isp_polled_cmd (struct ispsoftc *, XS_T *);
void isp_wdog (void *);
void isp_make_here(ispsoftc_t *, int);
void isp_make_gone(ispsoftc_t *, int);
void isp_requeue(void *);
void isp_trestart(void *);
void isp_restart(struct ispsoftc *);
void isp_add2_blocked_queue(struct ispsoftc *isp, XS_T *xs);
int isp_mstohz(int ms);

struct cfdriver isp_cd = {
	NULL, "isp", DV_DULL
};

static const char *roles[4] = {
    "(none)", "Target", "Initiator", "Target/Initiator"
};
static const char prom3[] =
    "PortID 0x%06x Departed from Target %u because of %s";
#define	isp_change_is_bad	0

/*
 * Complete attachment of hardware, include subdevices.
 */
void
isp_attach(struct ispsoftc *isp)
{
	struct scsibus_attach_args saa;
	struct scsi_link *lptr = &isp->isp_osinfo._link[0];
	isp->isp_osinfo._adapter.scsi_minphys = ispminphys;
	isp->isp_osinfo._adapter.dev_probe = isp_scsi_probe;

	isp->isp_state = ISP_RUNSTATE;

	/*
	 * We only manage a single wait queues for dual bus controllers.
	 * This is arguably broken.
	 */
	SIMPLEQ_INIT(&isp->isp_osinfo.wq);

	lptr->adapter_softc = isp;
	lptr->adapter = &isp->isp_osinfo._adapter;
	lptr->openings = imin(isp->isp_maxcmds, MAXISPREQUEST(isp));
	isp->isp_osinfo._adapter.scsi_cmd = ispcmd_slow;
	if (IS_FC(isp)) {
		lptr->adapter_buswidth = MAX_FC_TARG;
		lptr->adapter_target = MAX_FC_TARG; /* i.e. ignore. */
		lptr->node_wwn = ISP_NODEWWN(isp);
		lptr->port_wwn = ISP_PORTWWN(isp);
	} else {
		sdparam *sdp = isp->isp_param;
		lptr->adapter_buswidth = MAX_TARGETS;
		/* We can set max lun width here */
		lptr->adapter_target = sdp->isp_initiator_id;
		isp->isp_osinfo.discovered[0] = 1 << sdp->isp_initiator_id;
		if (IS_DUALBUS(isp)) {
			struct scsi_link *lptrb = &isp->isp_osinfo._link[1];
			lptrb->adapter_softc = isp;
			lptrb->adapter = &isp->isp_osinfo._adapter;
			lptrb->openings = lptr->openings;
			lptrb->adapter_buswidth = MAX_TARGETS;
			lptrb->adapter_target = sdp->isp_initiator_id;
			lptrb->flags = SDEV_2NDBUS;
			isp->isp_osinfo.discovered[1] =
			    1 << (sdp+1)->isp_initiator_id;
		}
	}

	/*
	 * Send a SCSI Bus Reset (used to be done as part of attach,
	 * but now left to the OS outer layers).
	 *
	 * We don't do 'bus resets' for FC because the LIP that occurs
	 * when we start the firmware does all that for us.
	 */
	if (IS_SCSI(isp)) {
		int bus = 0;
		ISP_LOCK(isp);
		(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);
		if (IS_DUALBUS(isp)) {
			bus++;
			(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);
		}
		ISP_UNLOCK(isp);
		/*
		 * wait for the bus to settle.
		 */
		delay(4 * 1000000);
	} else {
		delay(2 * 1000000);
		ISP_LOCK(isp);
		isp_fc_runstate(isp, 10 * 1000000);
		ISP_UNLOCK(isp);
	}

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = lptr;

	/*
	 * And attach children (if any).
	 */
	config_found((void *)isp, &saa, scsiprint);
	if (IS_DUALBUS(isp)) {
		lptr++;
		bzero(&saa, sizeof(saa));
		saa.saa_sc_link = lptr;
		config_found((void *)isp, &saa, scsiprint);
	}
}

/*
 * minphys our xfers
 *
 * Unfortunately, the buffer pointer describes the target device- not the
 * adapter device, so we can't use the pointer to find out what kind of
 * adapter we are and adjust accordingly.
 */

static void
ispminphys(struct buf *bp, struct scsi_link *sl)
{
	/*
	 * XX: Only the 1020 has a 24 bit limit.
	 */
	if (bp->b_bcount >= (1 << 24)) {
		bp->b_bcount = (1 << 24);
	}
	minphys(bp);
}

void
ispcmd_slow(XS_T *xs)
{
	sdparam *sdp;
	int tgt, chan;
	u_int16_t f;
	struct ispsoftc *isp = XS_ISP(xs);

	if (IS_FC(isp)) {
		if (cold == 0) {
			isp->isp_osinfo.no_mbox_ints = 0;
			isp->isp_osinfo._adapter.scsi_cmd = ispcmd;
		}
		return (ispcmd(xs));
	}

	/*
	 * Have we completed discovery for this target on this adapter?
	 */
	sdp = isp->isp_param;
	tgt = XS_TGT(xs);
	chan = XS_CHANNEL(xs);
	sdp += chan;
	if ((xs->flags & SCSI_POLL) != 0 ||
	    (isp->isp_osinfo.discovered[chan] & (1 << tgt)) != 0) {
		return (ispcmd(xs));
	}
	if (cold == 0) {
		isp->isp_osinfo.no_mbox_ints = 0;
	}

	f = DPARM_DEFAULT;
	if (xs->sc_link->quirks & SDEV_NOSYNC) {
		f &= ~DPARM_SYNC;
	}
	if (xs->sc_link->quirks & SDEV_NOWIDE) {
		f &= ~DPARM_WIDE;
	}
	if (xs->sc_link->quirks & SDEV_NOTAGS) {
		f &= ~DPARM_TQING;
	}

	/*
	 * Okay, we know about this device now,
	 * so mark parameters to be updated for it.
	 */
	sdp->isp_devparam[tgt].goal_flags = f;
	sdp->isp_devparam[tgt].dev_update = 1;
	isp->isp_update |= (1 << chan);

	/*
	 * Now check to see whether we can get out of this checking mode now.
	 * XXX: WE CANNOT AS YET BECAUSE THERE IS NO MECHANISM TO TELL US
	 * XXX: WHEN WE'RE DONE DISCOVERY BECAUSE WE NEED ONE COMMAND AFTER
	 * XXX: DISCOVERY IS DONE FOR EACH TARGET TO TELL US THAT WE'RE DONE
	 * XXX: AND THAT DOESN'T HAPPEN HERE. AT BEST WE CAN MARK OURSELVES
	 * XXX: DONE WITH DISCOVERY FOR THIS TARGET AND SO SAVE MAYBE 20
	 * XXX: LINES OF C CODE.
	 */
	isp->isp_osinfo.discovered[chan] |= (1 << tgt);
	/* do not bother with these lines- they'll never execute correctly */
#if	0
	sdp = isp->isp_param;
	for (chan = 0; chan < (IS_12X0(isp)? 2 : 1); chan++, sdp++) {
		f = 0xffff & ~(1 << sdp->isp_initiator_id);
		if (isp->isp_osinfo.discovered[chan] != f) {
			break;
		}
	}
	if (chan == (IS_12X0(isp)? 2 : 1)) {
		isp->isp_osinfo._adapter.scsipi_cmd = ispcmd;
		if (IS_12X0(isp))
			isp->isp_update |= 2;
	}
#endif
	return (ispcmd(xs));
}

void
isp_add2_blocked_queue(struct ispsoftc *isp, XS_T *xs)
{
	SIMPLEQ_INSERT_TAIL(&isp->isp_osinfo.wq, xs, xfer_list);
}

int
isp_scsi_probe(struct scsi_link *link)
{
	struct ispsoftc *isp = (struct ispsoftc *)link->adapter_softc;

	if (link->lun >= isp->isp_maxluns)
		return (ENXIO);

	return (0);
}

void
ispcmd(XS_T *xs)
{
	struct ispsoftc *isp;
	int result;

	/*
	 * Make sure that there's *some* kind of sane setting.
	 */
	isp = XS_ISP(xs);

	timeout_set(&xs->stimeout, isp_wdog, xs);

	ISP_LOCK(isp);

	if (isp->isp_state < ISP_RUNSTATE) {
		ISP_DISABLE_INTS(isp);
		isp_init(isp);
		if (isp->isp_state != ISP_INITSTATE) {
			ISP_ENABLE_INTS(isp);
			XS_SETERR(xs, HBA_BOTCH);
			scsi_done(xs);
			ISP_UNLOCK(isp);
			return;
		}
		isp->isp_state = ISP_RUNSTATE;
		ISP_ENABLE_INTS(isp);
	}

	/*
	 * Check for queue blockage...
	 */
	if (isp->isp_osinfo.blocked) {
		if (xs->flags & SCSI_POLL) {
			xs->error = XS_NO_CCB;
			scsi_done(xs);
			ISP_UNLOCK(isp);
			return;
		}
		if (isp->isp_osinfo.blocked == 2) {
			isp_restart(isp);
		}
		if (isp->isp_osinfo.blocked) {
			isp_add2_blocked_queue(isp, xs);
			ISP_UNLOCK(isp);
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG0, "added to blocked queue");
#endif
			return;
		}
	}

	if (xs->flags & SCSI_POLL) {
		volatile u_int8_t ombi = isp->isp_osinfo.no_mbox_ints;
		isp->isp_osinfo.no_mbox_ints = 1;
		isp_polled_cmd(isp, xs);
		isp->isp_osinfo.no_mbox_ints = ombi;
		ISP_UNLOCK(isp);
		return;
	}

	result = isp_start(xs);

	switch (result) {
	case CMD_QUEUED:
		if (xs->timeout) {
			timeout_add(&xs->stimeout, _XT(xs));
			XS_CMD_S_TIMER(xs);
		}
		if (isp->isp_osinfo.hiwater < isp->isp_nactive) {
			isp->isp_osinfo.hiwater = isp->isp_nactive;
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG0,
			    "Active Hiwater Mark=%d", isp->isp_nactive);
#endif
		}
		break;
	case CMD_EAGAIN:
		isp->isp_osinfo.blocked |= 2;
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, "blocking queue");
#endif
		isp_add2_blocked_queue(isp, xs);
		break;
	case CMD_RQLATER:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG1, "retrying later for %d.%d",
		    XS_TGT(xs), XS_LUN(xs));
#endif
		timeout_set(&xs->stimeout, isp_requeue, xs);
		timeout_add_sec(&xs->stimeout, 1);
		XS_CMD_S_TIMER(xs);
		break;
	case CMD_COMPLETE:
		scsi_done(xs);
		break;
	}
	ISP_UNLOCK(isp);
}

void
isp_polled_cmd(struct ispsoftc *isp, XS_T *xs)
{
	int result;
	int infinite = 0, mswait;

	result = isp_start(xs);

	switch (result) {
	case CMD_QUEUED:
		break;
	case CMD_RQLATER:
	case CMD_EAGAIN:
		xs->error = XS_NO_CCB;
		/* FALLTHROUGH */
	case CMD_COMPLETE:
		scsi_done(xs);
		return;
	}

	/*
	 * If we can't use interrupts, poll on completion.
	 */
	if ((mswait = XS_TIME(xs)) == 0)
		infinite = 1;

	while (mswait || infinite) {
		u_int32_t isr;
		u_int16_t sema, mbox;
		if (ISP_READ_ISR(isp, &isr, &sema, &mbox)) {
			isp_intr(isp, isr, sema, mbox);
			if (XS_CMD_DONE_P(xs)) {
				break;
			}
		}
		USEC_DELAY(1000);
		mswait -= 1;
	}

	/*
	 * If no other error occurred but we didn't finish,
	 * something bad happened.
	 */
	if (XS_CMD_DONE_P(xs) == 0) {
		if (isp_control(isp, ISPCTL_ABORT_CMD, xs)) {
			isp_reinit(isp);
		}
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_BOTCH);
		}
	}
}

void
isp_done(XS_T *xs)
{
	XS_CMD_S_DONE(xs);
	if (XS_CMD_WDOG_P(xs) == 0) {
		struct ispsoftc *isp = XS_ISP(xs);
		if (XS_CMD_TIMER_P(xs)) {
			timeout_del(&xs->stimeout);
			XS_CMD_C_TIMER(xs);
		}
		if (XS_CMD_GRACE_P(xs)) {
			struct ispsoftc *isp = XS_ISP(xs);
			isp_prt(isp, ISP_LOGWARN,
			    "finished command on borrowed time");
		}
		XS_CMD_S_CLEAR(xs);
		scsi_done(xs);
		if (isp->isp_osinfo.blocked == 2) {
			isp->isp_osinfo.blocked = 0;
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG0, "restarting blocked queue");
#endif
			isp_restart(isp);
		}
	}
}

void
isp_wdog(void *arg)
{
	XS_T *xs = arg;
	struct ispsoftc *isp = XS_ISP(xs);
	u_int32_t handle;

	/*
	 * We've decided this command is dead. Make sure we're not trying
	 * to kill a command that's already dead by getting its handle and
	 * and seeing whether it's still alive.
	 */
	ISP_LOCK(isp);
	handle = isp_find_handle(isp, xs);
	if (handle) {
		u_int32_t isr;
		u_int16_t sema, mbox;

		if (XS_CMD_DONE_P(xs)) {
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG1,
			    "watchdog found done cmd (handle 0x%x)",
			    handle);
#endif
			ISP_UNLOCK(isp);
			return;
		}

		if (XS_CMD_WDOG_P(xs)) {
#ifndef SMALL_KERNEL
			isp_prt(isp, ISP_LOGDEBUG1,
			    "recursive watchdog (handle 0x%x)",
			    handle);
#endif
			ISP_UNLOCK(isp);
			return;
		}

		XS_CMD_S_WDOG(xs);

		if (ISP_READ_ISR(isp, &isr, &sema, &mbox)) {
			isp_intr(isp, isr, sema, mbox);
		}

		if (XS_CMD_DONE_P(xs)) {
			isp_prt(isp, ISP_LOGINFO,
			    "watchdog cleanup for handle 0x%x", handle);
			XS_CMD_C_WDOG(xs);
			isp_done(xs);
		} else if (XS_CMD_GRACE_P(xs)) {
			/*
			 * Make sure the command is *really* dead before we
			 * release the handle (and DMA resources) for reuse.
			 */
			(void) isp_control(isp, ISPCTL_ABORT_CMD, arg);

			/*
			 * After this point, the command is really dead.
			 */
			if (XS_XFRLEN(xs)) {
				ISP_DMAFREE(isp, xs, handle);
			}
			isp_prt(isp, ISP_LOGWARN,
			    "watchdog timeout on handle %x", handle);
			isp_destroy_handle(isp, handle);
			XS_SETERR(xs, XS_TIMEOUT);
			XS_CMD_S_CLEAR(xs);
			isp_done(xs);
		} else {
			u_int32_t optr, nxti;
			ispreq_t local, *mp = &local, *qe;

			isp_prt(isp, ISP_LOGWARN,
			    "possible command timeout on handle %x", handle);

			XS_CMD_C_WDOG(xs);
			timeout_add(&xs->stimeout, _XT(xs));
			XS_CMD_S_TIMER(xs);
			if (isp_getrqentry(isp, &nxti, &optr, (void **) &qe)) {
				ISP_UNLOCK(isp);
				return;
			}
			XS_CMD_S_GRACE(xs);
			MEMZERO((void *) mp, sizeof (*mp));
			mp->req_header.rqs_entry_count = 1;
			mp->req_header.rqs_entry_type = RQSTYPE_MARKER;
			mp->req_cdblen = SYNC_ALL;
			mp->req_target = XS_CHANNEL(xs) << 7;
			isp_put_request(isp, mp, qe);
			ISP_ADD_REQUEST(isp, nxti);
		}
	}
#ifndef SMALL_KERNEL
	  else if (isp->isp_dblev) {
		isp_prt(isp, ISP_LOGDEBUG1, "watchdog with no command");
	}
#endif
	ISP_UNLOCK(isp);
}

void
isp_make_here(ispsoftc_t *isp, int tgt)
{
	isp_prt(isp, ISP_LOGINFO, "target %d has arrived", tgt);
}

void
isp_make_gone(ispsoftc_t *isp, int tgt)
{
	isp_prt(isp, ISP_LOGINFO, "target %d has departed", tgt);
}

/*
 * Free any associated resources prior to decommissioning and
 * set the card to a known state (so it doesn't wake up and kick
 * us when we aren't expecting it to).
 *
 * Locks are held before coming here.
 */
void
isp_uninit(struct ispsoftc *isp)
{
	ISP_LOCK(isp);
	/*
	 * Leave with interrupts disabled.
	 */
	ISP_DISABLE_INTS(isp);

	ISP_UNLOCK(isp);
}

/*
 * Restart function for a command to be requeued later.
 */
void
isp_requeue(void *arg)
{
	int r;
	struct scsi_xfer *xs = arg;
	struct ispsoftc *isp = XS_ISP(xs);
	ISP_LOCK(isp);
	r = isp_start(xs);
	switch (r) {
	case CMD_QUEUED:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG1, "restarted command for %d.%d",
		    XS_TGT(xs), XS_LUN(xs));
#endif
		if (xs->timeout) {
			timeout_set(&xs->stimeout, isp_wdog, xs);
			timeout_add(&xs->stimeout, _XT(xs));
			XS_CMD_S_TIMER(xs);
		}
		break;
	case CMD_EAGAIN:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, "blocked cmd again");
#endif
		isp->isp_osinfo.blocked |= 2;
		isp_add2_blocked_queue(isp, xs);
		break;
	case CMD_RQLATER:
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, "%s for %d.%d",
		    (r == CMD_EAGAIN)? "CMD_EAGAIN" : "CMD_RQLATER",
		    XS_TGT(xs), XS_LUN(xs));
#endif
		timeout_set(&xs->stimeout, isp_requeue, xs);
		timeout_add_sec(&xs->stimeout, 1);
		XS_CMD_S_TIMER(xs);
		break;
	case CMD_COMPLETE:
		/* can only be an error */
		if (XS_NOERR(xs))
			XS_SETERR(xs, XS_DRIVER_STUFFUP);
		isp_done(xs);
		break;
	}
	ISP_UNLOCK(isp);
}

/*
 * Restart function after a LOOP UP event or a command completing,
 * sometimes done as a timeout for some hysteresis.
 */
void
isp_trestart(void *arg)
{
	struct ispsoftc *isp = arg;
	struct scsi_xfer *xs;
	struct scsi_xfer_list list;

	ISP_LOCK(isp);
	isp->isp_osinfo.rtpend = 0;
	if (isp->isp_osinfo.blocked) {
		ISP_UNLOCK(isp);
		return;
	}
	
	list = isp->isp_osinfo.wq;
	SIMPLEQ_INIT(&isp->isp_osinfo.wq);
	ISP_UNLOCK(isp);

	while ((xs = SIMPLEQ_FIRST(&list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&list, xfer_list);
		isp_requeue(xs);
	}
}

void
isp_restart(struct ispsoftc *isp)
{
	struct scsi_xfer *xs;
	struct scsi_xfer_list list;

	if (isp->isp_osinfo.blocked)
		return;

	list = isp->isp_osinfo.wq;
	SIMPLEQ_INIT(&isp->isp_osinfo.wq);

	while ((xs = SIMPLEQ_FIRST(&list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&list, xfer_list);
		isp_requeue(xs);
	}
}

int
isp_async(struct ispsoftc *isp, ispasync_t cmd, void *arg)
{
	int bus, tgt;
	char *msg = NULL;
	static const char prom[] =
	    "PortID 0x%06x handle 0x%x role %s %s\n"
	    "      WWNN 0x%08x%08x WWPN 0x%08x%08x";
	static const char prom2[] =
	    "PortID 0x%06x handle 0x%x role %s %s tgt %u\n"
	    "      WWNN 0x%08x%08x WWPN 0x%08x%08x";
	fcportdb_t *lp;

	switch (cmd) {
	case ISPASYNC_NEW_TGT_PARAMS:
	if (IS_SCSI(isp) && isp->isp_dblev) {
		sdparam *sdp = isp->isp_param;
		char *wt;
		int mhz, flags, period;

		tgt = *((int *) arg);
		bus = (tgt >> 16) & 0xffff;
		tgt &= 0xffff;
		sdp += bus;
		flags = sdp->isp_devparam[tgt].actv_flags;
		period = sdp->isp_devparam[tgt].actv_period;

		if ((flags & DPARM_SYNC) && period &&
		    (sdp->isp_devparam[tgt].actv_offset) != 0) {
			/*
			 * There's some ambiguity about our negotiated speed
			 * if we haven't detected LVD mode correctly (which
			 * seems to happen, unfortunately). If we're in LVD
			 * mode, then different rules apply about speed.
			 */
			if (sdp->isp_lvdmode || period < 0xc) {
				switch (period) {
				case 0x9:
					mhz = 80;
					break;
				case 0xa:
					mhz = 40;
					break;
				case 0xb:
					mhz = 33;
					break;
				case 0xc:
					mhz = 25;
					break;
				default:
					mhz = 1000 / (period * 4);
					break;
				}
			} else {
				mhz = 1000 / (period * 4);
			}
		} else {
			mhz = 0;
		}
		switch (flags & (DPARM_WIDE|DPARM_TQING)) {
		case DPARM_WIDE:
			wt = ", 16 bit wide";
			break;
		case DPARM_TQING:
			wt = ", Tagged Queueing Enabled";
			break;
		case DPARM_WIDE|DPARM_TQING:
			wt = ", 16 bit wide, Tagged Queueing Enabled";
			break;
		default:
			wt = " ";
			break;
		}
		if (mhz) {
			isp_prt(isp, ISP_LOGINFO,
			    "Bus %d Target %d at %dMHz Max Offset %d%s",
			    bus, tgt, mhz, sdp->isp_devparam[tgt].actv_offset,
			    wt);
		} else {
			isp_prt(isp, ISP_LOGINFO,
			    "Bus %d Target %d Async Mode%s", bus, tgt, wt);
		}
		break;
	}
	case ISPASYNC_BUS_RESET:
		if (arg)
			bus = *((int *) arg);
		else
			bus = 0;
		isp_prt(isp, ISP_LOGINFO, "SCSI bus %d reset detected", bus);
		break;
	case ISPASYNC_LOOP_DOWN:
		/*
		 * Hopefully we get here in time to minimize the number
		 * of commands we are firing off that are sure to die.
		 */
		isp->isp_osinfo.blocked |= 1;
		isp_prt(isp, ISP_LOGINFO, "Loop DOWN");
		break;
        case ISPASYNC_LOOP_UP:
		isp->isp_osinfo.blocked &= ~1;
		if (isp->isp_osinfo.rtpend == 0) {
			timeout_set(&isp->isp_osinfo.rqt, isp_trestart, isp);
			isp->isp_osinfo.rtpend = 1;
		}
		timeout_add(&isp->isp_osinfo.rqt, 1);
		isp_prt(isp, ISP_LOGINFO, "Loop UP");
		break;
	case ISPASYNC_DEV_ARRIVED:
		lp = arg;
		lp->reserved = 0;
		if ((isp->isp_role & ISP_ROLE_INITIATOR) &&
		    (lp->roles & (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT))) {
			int dbidx = lp - FCPARAM(isp)->portdb;
			int i;

			for (i = 0; i < MAX_FC_TARG; i++) {
				if (i >= FL_ID && i <= SNS_ID) {
					continue;
				}
				if (FCPARAM(isp)->isp_ini_map[i] == 0) {
					break;
				}
			}
			if (i < MAX_FC_TARG) {
				FCPARAM(isp)->isp_ini_map[i] = dbidx + 1;
				lp->ini_map_idx = i + 1;
			} else {
				isp_prt(isp, ISP_LOGWARN, "out of target ids");
				isp_dump_portdb(isp);
			}
		}
		if (lp->ini_map_idx) {
			tgt = lp->ini_map_idx - 1;
			isp_prt(isp, ISP_LOGCONFIG, prom2,
			    lp->portid, lp->handle,
		            roles[lp->roles], "arrived at", tgt,
		    	    (uint32_t) (lp->node_wwn >> 32),
			    (uint32_t) lp->node_wwn,
		    	    (uint32_t) (lp->port_wwn >> 32),
			    (uint32_t) lp->port_wwn);
			isp_make_here(isp, tgt);
		} else {
			isp_prt(isp, ISP_LOGCONFIG, prom,
			    lp->portid, lp->handle,
		            roles[lp->roles], "arrived",
		    	    (uint32_t) (lp->node_wwn >> 32),
			    (uint32_t) lp->node_wwn,
		    	    (uint32_t) (lp->port_wwn >> 32),
			    (uint32_t) lp->port_wwn);
		}
		break;
	case ISPASYNC_DEV_CHANGED:
		lp = arg;
		if (isp_change_is_bad) {
			lp->state = FC_PORTDB_STATE_NIL;
			if (lp->ini_map_idx) {
				tgt = lp->ini_map_idx - 1;
				FCPARAM(isp)->isp_ini_map[tgt] = 0;
				lp->ini_map_idx = 0;
				isp_prt(isp, ISP_LOGCONFIG, prom3,
				    lp->portid, tgt, "change is bad");
				isp_make_gone(isp, tgt);
			} else {
				isp_prt(isp, ISP_LOGCONFIG, prom,
				    lp->portid, lp->handle,
				    roles[lp->roles],
				    "changed and departed",
				    (uint32_t) (lp->node_wwn >> 32),
				    (uint32_t) lp->node_wwn,
				    (uint32_t) (lp->port_wwn >> 32),
				    (uint32_t) lp->port_wwn);
			}
		} else {
			lp->portid = lp->new_portid;
			lp->roles = lp->new_roles;
			if (lp->ini_map_idx) {
				int t = lp->ini_map_idx - 1;
				FCPARAM(isp)->isp_ini_map[t] =
				    (lp - FCPARAM(isp)->portdb) + 1;
				tgt = lp->ini_map_idx - 1;
				isp_prt(isp, ISP_LOGCONFIG, prom2,
				    lp->portid, lp->handle,
				    roles[lp->roles], "changed at", tgt,
				    (uint32_t) (lp->node_wwn >> 32),
				    (uint32_t) lp->node_wwn,
				    (uint32_t) (lp->port_wwn >> 32),
				    (uint32_t) lp->port_wwn);
			} else {
				isp_prt(isp, ISP_LOGCONFIG, prom,
				    lp->portid, lp->handle,
				    roles[lp->roles], "changed",
				    (uint32_t) (lp->node_wwn >> 32),
				    (uint32_t) lp->node_wwn,
				    (uint32_t) (lp->port_wwn >> 32),
				    (uint32_t) lp->port_wwn);
			}
		}
		break;
	case ISPASYNC_DEV_STAYED:
		lp = arg;
		if (lp->ini_map_idx) {
			tgt = lp->ini_map_idx - 1;
			isp_prt(isp, ISP_LOGCONFIG, prom2,
			    lp->portid, lp->handle,
		    	    roles[lp->roles], "stayed at", tgt,
			    (uint32_t) (lp->node_wwn >> 32),
			    (uint32_t) lp->node_wwn,
		    	    (uint32_t) (lp->port_wwn >> 32),
			    (uint32_t) lp->port_wwn);
		} else {
			isp_prt(isp, ISP_LOGCONFIG, prom,
			    lp->portid, lp->handle,
		    	    roles[lp->roles], "stayed",
			    (uint32_t) (lp->node_wwn >> 32),
			    (uint32_t) lp->node_wwn,
		    	    (uint32_t) (lp->port_wwn >> 32),
			    (uint32_t) lp->port_wwn);
		}
		break;
	case ISPASYNC_DEV_GONE:
		lp = arg;
		if (lp->ini_map_idx && lp->reserved == 0) {
			lp->reserved = 1;
			lp->state = FC_PORTDB_STATE_ZOMBIE;
			tgt = lp->ini_map_idx - 1;
			isp_prt(isp, ISP_LOGCONFIG, prom2,
			    lp->portid, lp->handle,
		            roles[lp->roles], "gone zombie at", tgt,
		    	    (uint32_t) (lp->node_wwn >> 32),
			    (uint32_t) lp->node_wwn,
		    	    (uint32_t) (lp->port_wwn >> 32),
			    (uint32_t) lp->port_wwn);
		} else if (lp->reserved == 0) {
			isp_prt(isp, ISP_LOGCONFIG, prom,
			    lp->portid, lp->handle,
			    roles[lp->roles], "departed",
			    (uint32_t) (lp->node_wwn >> 32),
			    (uint32_t) lp->node_wwn,
			    (uint32_t) (lp->port_wwn >> 32),
			    (uint32_t) lp->port_wwn);
		}
		break;
	case ISPASYNC_CHANGE_NOTIFY:
		if (arg == ISPASYNC_CHANGE_PDB) {
			msg = "Port Database Changed";
		} else if (arg == ISPASYNC_CHANGE_SNS) {
			msg = "Name Server Database Changed";
		} else {
			msg = "Other Change Notify";
		}
		isp_prt(isp, ISP_LOGINFO, msg);
		break;
	case ISPASYNC_FW_CRASH:
	{
		u_int16_t mbox1, mbox6;
		mbox1 = ISP_READ(isp, OUTMAILBOX1);
		if (IS_DUALBUS(isp)) { 
			mbox6 = ISP_READ(isp, OUTMAILBOX6);
		} else {
			mbox6 = 0;
		}
                isp_prt(isp, ISP_LOGERR,
                    "Internal Firmware Error on bus %d @@ RISC Address 0x%x",
                    mbox6, mbox1);
#ifdef	ISP_FW_CRASH_DUMP
		if (IS_FC(isp)) {
			isp->isp_osinfo.blocked |= 1;
			isp_fw_dump(isp);
		}
		isp_reinit(isp);
		isp_async(isp, ISPASYNC_FW_RESTART, NULL);
#endif
		break;
	}
	default:
		break;
	}
	return (0);
}

void
isp_prt(struct ispsoftc *isp, int level, const char *fmt, ...)
{
	va_list ap;
	if (level != ISP_LOGALL && (level & isp->isp_dblev) == 0) {
		return;
	}
	printf("%s: ", isp->isp_name);
	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
	printf("\n");
}

int
isp_mbox_acquire(ispsoftc_t *isp)
{
	if (isp->isp_osinfo.mboxbsy) {
		return (1);
	} else {
		isp->isp_osinfo.mboxcmd_done = 0;
		isp->isp_osinfo.mboxbsy = 1;
		return (0);
	}
}

void
isp_lock(struct ispsoftc *isp)
{
	int s = splbio();
	if (isp->isp_osinfo.islocked++ == 0) {
		isp->isp_osinfo.splsaved = s;
	} else {
		splx(s);
	}
}

void
isp_unlock(struct ispsoftc *isp)
{
	if (isp->isp_osinfo.islocked-- <= 1) {
		isp->isp_osinfo.islocked = 0;
		splx(isp->isp_osinfo.splsaved);
	}
}

/*
 * XXX Since the clocks aren't running yet during autoconf, we have to
 * keep track of time ourselves, otherwise we may end up waiting
 * forever for the FC link to go up.
 */
struct timespec isp_nanotime;

void
isp_delay(int usec)
{
	delay(usec);
	isp_nanotime.tv_nsec += (usec * 1000);
	if (isp_nanotime.tv_nsec >= 1000000000L) {
		isp_nanotime.tv_sec++;
		isp_nanotime.tv_nsec -= 1000000000L;
	}
}

u_int64_t
isp_nanotime_sub(struct timespec *b, struct timespec *a)
{
	struct timespec x;
	u_int64_t elapsed;
	timespecsub(b, a, &x);
	elapsed = GET_NANOSEC(&x);
	if (elapsed == 0)
		elapsed++;
	return (elapsed);
}

void
isp_mbox_wait_complete(ispsoftc_t *isp, mbreg_t *mbp)
{
	unsigned int usecs = mbp->timeout;
	unsigned int max, olim, ilim;

	if (usecs == 0) {
		usecs = MBCMD_DEFAULT_TIMEOUT;
	}
	max = isp->isp_mbxwrk0 + 1;

	if (isp->isp_osinfo.mbox_sleep_ok) {
		unsigned int ms = (usecs + 999) / 1000;

		isp->isp_osinfo.mbox_sleep_ok = 0;
		isp->isp_osinfo.mbox_sleeping = 1;
		for (olim = 0; olim < max; olim++) {
			tsleep(&isp->isp_mbxworkp, PRIBIO, "ispmbx_sleep",
			    isp_mstohz(ms));
			if (isp->isp_osinfo.mboxcmd_done) {
				break;
			}
		}
		isp->isp_osinfo.mbox_sleep_ok = 1;
		isp->isp_osinfo.mbox_sleeping = 0;
	} else {
		for (olim = 0; olim < max; olim++) {
			for (ilim = 0; ilim < usecs; ilim += 100) {
				uint32_t isr;
				uint16_t sema, mbox;
				if (isp->isp_osinfo.mboxcmd_done) {
					break;
				}
				if (ISP_READ_ISR(isp, &isr, &sema, &mbox)) {
					isp_intr(isp, isr, sema, mbox);
					if (isp->isp_osinfo.mboxcmd_done) {
						break;
					}
				}
				USEC_DELAY(100);
			}
			if (isp->isp_osinfo.mboxcmd_done) {
				break;
			}
		}
	}
	if (isp->isp_osinfo.mboxcmd_done == 0) {
		isp_prt(isp, ISP_LOGWARN,
		    "%s Mailbox Command (0x%x) Timeout (%uus)",
		    isp->isp_osinfo.mbox_sleep_ok? "Interrupting" : "Polled",
		    isp->isp_lastmbxcmd, usecs);
		mbp->param[0] = MBOX_TIMEOUT;
		isp->isp_osinfo.mboxcmd_done = 1;
	}
}

void
isp_mbox_notify_done(ispsoftc_t *isp)
{
	if (isp->isp_osinfo.mbox_sleeping) {
		wakeup(&isp->isp_mbxworkp);
	}
	isp->isp_osinfo.mboxcmd_done = 1;
}

void
isp_mbox_release(ispsoftc_t *isp)
{
	isp->isp_osinfo.mboxbsy = 0;
}

int
isp_mstohz(int ms)
{
	int hz;
	struct timeval t;
	t.tv_sec = ms / 1000;
	t.tv_usec = (ms % 1000) * 1000;
	hz = tvtohz(&t);
	if (hz < 0) {
		hz = 0x7fffffff;
	}
	if (hz == 0) {
		hz = 1;
	}
	return (hz);
}
@


1.48
log
@replace the LIST_ENTRY in scsi_xfer with a SIMPLEQ_ENTRY. the things that
use it want something they can add to the end of they do horrible things
to be able to do that with the LIST_ENTRY.

this makes those horrible things a bit less horrible, and makes it easier
to use lists of scsi_xfers in other things.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.47 2011/10/22 19:34:06 miod Exp $ */
@


1.47
log
@Comment out ISP_{T,}DEBUG[0-3] traces if option SMALL_KERNEL; allows alpha
floppyB to fit again. ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.46 2011/04/05 12:09:20 dlg Exp $ */
d106 1
a106 1
	isp->isp_osinfo.wqf = isp->isp_osinfo.wqt = NULL;
d279 1
a279 7
	if (isp->isp_osinfo.wqf != NULL) {
		isp->isp_osinfo.wqt->free_list.le_next = xs;
	} else {
		isp->isp_osinfo.wqf = xs;
	}
	isp->isp_osinfo.wqt = xs;
	xs->free_list.le_next = NULL;
d662 2
a663 1
	struct scsi_xfer *list;
d667 8
a674 3
	list = isp->isp_osinfo.wqf;
	if (isp->isp_osinfo.blocked == 0 && list != NULL) {
		int nrestarted = 0;
d676 3
a678 15
		isp->isp_osinfo.wqf = NULL;
		ISP_UNLOCK(isp);
		do {
			struct scsi_xfer *xs = list;
			list = xs->free_list.le_next;
			xs->free_list.le_next = NULL;
			isp_requeue(xs);
			if (isp->isp_osinfo.wqf == NULL)
				nrestarted++;
		} while (list != NULL);
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, "requeued %d commands", nrestarted);
#endif
	} else {
		ISP_UNLOCK(isp);
d685 8
a692 1
	struct scsi_xfer *list;
d694 3
a696 16
	list = isp->isp_osinfo.wqf;
	if (isp->isp_osinfo.blocked == 0 && list != NULL) {
		int nrestarted = 0;

		isp->isp_osinfo.wqf = NULL;
		do {
			struct scsi_xfer *xs = list;
			list = xs->free_list.le_next;
			xs->free_list.le_next = NULL;
			isp_requeue(xs);
			if (isp->isp_osinfo.wqf == NULL)
				nrestarted++;
		} while (list != NULL);
#ifndef SMALL_KERNEL
		isp_prt(isp, ISP_LOGDEBUG0, "requeued %d commands", nrestarted);
#endif
@


1.46
log
@add a scsi probe routine so isp(4) can reject high luns when the midlayer
is probing, rather than every time it issues an io.

ok krw@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.45 2010/12/31 19:20:42 kettenis Exp $ */
d344 1
d346 1
d370 1
d373 1
d378 1
d380 1
d384 1
d387 1
d471 1
d473 1
d498 1
d502 1
d508 1
d512 1
d570 3
a572 1
	} else if (isp->isp_dblev) {
d575 1
d623 1
d626 1
d634 1
d636 1
d641 1
d645 1
d686 1
d688 1
d712 1
d714 1
@


1.45
log
@Add missing scsi_done().

ok matthew@@, krw@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.44 2010/06/28 18:31:02 krw Exp $ */
d64 1
d98 1
d288 11
a312 7

	if (XS_LUN(xs) >= isp->isp_maxluns) {
		xs->error = XS_SELTIMEOUT;
		scsi_done(xs);
		ISP_UNLOCK(isp);
		return;
	}
@


1.44
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.43 2010/03/27 02:06:03 krw Exp $ */
d379 1
@


1.43
log
@Fix isp(4) fallout from NO_CCB nuking. Seen by several.

ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.42 2010/03/23 01:57:19 krw Exp $ */
a66 2
struct scsi_device isp_dev = { NULL, NULL, NULL, NULL };

a106 1
	lptr->device = &isp_dev;
a123 1
			lptrb->device = &isp_dev;
@


1.42
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.41 2010/01/04 02:23:10 krw Exp $ */
d398 1
a398 1
		return;
d405 1
a405 1
		break;
@


1.41
log
@Add a few missing scsi_done()'s before returning COMPLETE. Also
return COMPLETE and not CMD_COMPLETE in one case.

Tested by kettenis@@ and myself on Blade1000's.

ok dlg@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.40 2009/11/22 14:14:10 krw Exp $ */
d64 2
a65 2
static int32_t ispcmd_slow(XS_T *);
static int32_t ispcmd(XS_T *);
d69 1
a69 1
int isp_polled_cmd (struct ispsoftc *, XS_T *);
d200 1
a200 1
int32_t
d290 1
a290 1
int32_t
a295 1

d309 1
a309 1
		return (COMPLETE);
d320 1
a320 1
			return (COMPLETE);
d331 2
d334 1
a334 1
			return (NO_CCB);
d343 1
a343 1
			return (SUCCESSFULLY_QUEUED);
d350 1
a350 1
		result = isp_polled_cmd(isp, xs);
d353 1
a353 1
		return (result);
a359 1
		result = SUCCESSFULLY_QUEUED;
a373 1
		result = SUCCESSFULLY_QUEUED;
a375 1
		result = SUCCESSFULLY_QUEUED;	/* Lie */
a382 1
		result = COMPLETE;
a385 1
	return (result);
d388 1
a388 1
int
d398 1
a398 2
		result = SUCCESSFULLY_QUEUED;
		break;
d401 2
a402 2
		result = NO_CCB;
		break;
a404 1
		result = COMPLETE;
a407 4
	if (result != SUCCESSFULLY_QUEUED) {
		return (result);
	}

a438 2

	return (COMPLETE);
@


1.40
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.39 2009/08/08 09:51:53 dlg Exp $ */
d304 2
d308 2
a312 1
	ISP_LOCK(isp);
d318 2
d321 1
a321 2
			XS_SETERR(xs, HBA_BOTCH);
			return (CMD_COMPLETE);
d409 1
a411 1
		
d449 2
a450 2
	result = COMPLETE;
	return (result);
@


1.39
log
@if the port is fc, populate the adapters scsi_link structure with the wwpn
and wwnn so scsibus can use it.

requested by and ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.37 2009/06/27 15:23:20 kettenis Exp $ */
d329 1
a329 1
			return (TRY_AGAIN_LATER);
d402 1
a402 1
		result = TRY_AGAIN_LATER;
@


1.38
log
@Add a workaround for the fact that our clocks aren't running during autoconf
(at least on some of our architectures, including hppa).  Since isp(4) keeps
track of elapsed time to determine if it should continue to wait for the FC
link to come up it would wait very very long.  Figured out by krw@@.

ok deraadt@@, krw@@
@
text
@d116 2
@


1.37
log
@Remove debug printfs.

ok krw@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.36 2009/06/24 11:00:53 krw Exp $ */
d1018 18
@


1.36
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.35 2009/02/16 21:19:06 miod Exp $ */
a820 2
				printf("ISPASYNC_DEV_ARRIVED: %d/%d\n",
				    i, FCPARAM(isp)->isp_ini_map[i]);
a852 2
				printf("ISPASYNC_DEV_CHANGED: %d/%d\n",
				    tgt, FCPARAM(isp)->isp_ini_map[tgt]);
a873 2
				printf("ISPASYNC_DEV_CHANGED(2): %d/%d\n",
				    t, FCPARAM(isp)->isp_ini_map[t]);
@


1.35
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.34 2009/01/11 16:54:59 blambert Exp $ */
a42 2
/* expand expensive inline functions here. */
#define EXPENSIVE_INLINE
d67 1
a67 1
static struct scsi_device isp_dev = { NULL, NULL, NULL, NULL };
d69 9
a77 5
static int isp_polled_cmd (struct ispsoftc *, XS_T *);
static void isp_wdog (void *);
static void isp_requeue(void *);
static void isp_trestart(void *);
static void isp_restart(struct ispsoftc *);
d83 6
d115 1
a115 2
		/* We can set max lun width here */
		/* loopid set below */
a156 2
		fcparam *fcp = isp->isp_param;
		int defid = MAX_FC_TARG;
a159 4
		if (fcp->isp_fwstate == FW_READY &&
		    fcp->isp_loopstate >= LOOP_PDB_RCVD) {
			defid = fcp->isp_loopid;
		}
a160 1
		lptr->adapter_target = defid;
d198 1
a198 1
static int32_t
d276 1
a276 3
static INLINE void isp_add2_blocked_queue(struct ispsoftc *, XS_T *);

static INLINE void
d288 1
a288 1
static int32_t
d309 1
a309 1
		DISABLE_INTS(isp);
d312 1
a312 1
			ENABLE_INTS(isp);
d318 1
a318 1
		ENABLE_INTS(isp);
d386 1
a386 1
static int
d419 2
a420 1
		u_int16_t isr, sema, mbox;
d472 1
a472 1
static void
d487 2
a488 1
		u_int16_t isr, sema, mbox;
d537 1
a537 1
			u_int16_t nxti, optr;
d554 1
a554 1
			mp->req_modifier = SYNC_ALL;
d565 12
d591 1
a591 1
	DISABLE_INTS(isp);
d599 1
a599 1
static void
d644 1
a644 1
static void
d672 1
a672 1
static void
d698 8
d802 36
a837 24
	case ISPASYNC_PROMENADE:
	if (IS_FC(isp) && isp->isp_dblev) {
		const char *fmt = "Target %d (Loop 0x%x) Port ID 0x%x "
		    "role %s %s\n Port WWN 0x%08x%08x\n Node WWN 0x%08x%08x";
		const static char *roles[4] = {
		    "No", "Target", "Initiator", "Target/Initiator"
		};
		fcparam *fcp = isp->isp_param;
		int tgt = *((int *) arg);
		struct lportdb *lp = &fcp->portdb[tgt]; 

		isp_prt(isp, ISP_LOGINFO, fmt, tgt, lp->loopid, lp->portid,
		    roles[lp->roles & 0x3],
		    (lp->valid)? "Arrived" : "Departed",
		    (u_int32_t) (lp->port_wwn >> 32),
		    (u_int32_t) (lp->port_wwn & 0xffffffffLL),
		    (u_int32_t) (lp->node_wwn >> 32),
		    (u_int32_t) (lp->node_wwn & 0xffffffffLL));
		break;
	}
	case ISPASYNC_CHANGE_NOTIFY:
		if (arg == (void *) 1) {
			isp_prt(isp, ISP_LOGINFO,
			    "Name Server Database Changed");
d839 7
a845 2
			isp_prt(isp, ISP_LOGINFO,
			    "Name Server Database Changed");
d848 48
a895 85
	case ISPASYNC_FABRIC_DEV:
	{
		int target, base, lim;
		fcparam *fcp = isp->isp_param;
		struct lportdb *lp = NULL;
		struct lportdb *clp = (struct lportdb *) arg;
		char *pt;

		switch (clp->port_type) {
		case 1:
			pt = "   N_Port";
			break;
		case 2:
			pt = "  NL_Port";
			break;
		case 3:
			pt = "F/NL_Port";
			break;
		case 0x7f:
			pt = "  Nx_Port";
			break;
		case 0x81:
			pt = "  F_port";
			break;
		case 0x82:
			pt = "  FL_Port";
			break;
		case 0x84:
			pt = "   E_port";
			break;
		default:
			pt = " ";
			break;
		}

		isp_prt(isp, ISP_LOGINFO,
		    "%s Fabric Device @@ PortID 0x%x", pt, clp->portid);

		/*
		 * If we don't have an initiator role we bail.
		 *
		 * We just use ISPASYNC_FABRIC_DEV for announcement purposes.
		 */

		if ((isp->isp_role & ISP_ROLE_INITIATOR) == 0) {
			break;
		}

		/*
		 * Is this entry for us? If so, we bail.
		 */

		if (fcp->isp_portid == clp->portid) {
			break;
		}

		/*
		 * Else, the default policy is to find room for it in
		 * our local port database. Later, when we execute
		 * the call to isp_pdb_sync either this newly arrived
		 * or already logged in device will be (re)announced.
		 */

		if (fcp->isp_topo == TOPO_FL_PORT)
			base = FC_SNS_ID+1;
		else
			base = 0;

		if (fcp->isp_topo == TOPO_N_PORT)
			lim = 1;
		else
			lim = MAX_FC_TARG;

		/*
		 * Is it already in our list?
		 */
		for (target = base; target < lim; target++) {
			if (target >= FL_PORT_ID && target <= FC_SNS_ID) {
				continue;
			}
			lp = &fcp->portdb[target];
			if (lp->port_wwn == clp->port_wwn &&
			    lp->node_wwn == clp->node_wwn) {
				lp->fabric_dev = 1;
				break;
d898 20
a917 2
		if (target < lim) {
			break;
d919 22
a940 8
		for (target = base; target < lim; target++) {
			if (target >= FL_PORT_ID && target <= FC_SNS_ID) {
				continue;
			}
			lp = &fcp->portdb[target];
			if (lp->port_wwn == 0) {
				break;
			}
d942 8
a949 4
		if (target == lim) {
			isp_prt(isp, ISP_LOGWARN,
			    "out of space for fabric devices");
			break;
d951 1
a951 6
		lp->port_type = clp->port_type;
		lp->fc4_type = clp->fc4_type;
		lp->node_wwn = clp->node_wwn;
		lp->port_wwn = clp->port_wwn;
		lp->portid = clp->portid;
		lp->fabric_dev = 1;
a952 1
	}
d993 132
@


1.34
log
@Actual final round of timeout_add(to, n * hz) -> timeout_add_sec(to, n)
conversions.

ok kettenis@@
ok krw@@ (possibly for the second time :)
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.33 2008/10/15 19:12:18 blambert Exp $ */
d65 1
a65 1
static void ispminphys(struct buf *);
d187 1
a187 1
ispminphys(struct buf *bp)
@


1.33
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.32 2008/03/19 18:37:20 kettenis Exp $ */
d377 1
a377 1
		timeout_add(&xs->stimeout, hz);
@


1.32
log
@Make sure we pass the right argument to isp_wdog() when setting timeouts.

ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.31 2008/01/21 20:00:33 sobrado Exp $ */
d615 1
a615 1
		timeout_add(&xs->stimeout, hz);
@


1.31
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.30 2007/04/10 17:47:55 miod Exp $ */
d302 1
a302 1
	timeout_set(&xs->stimeout, isp_wdog, isp);
d600 1
a600 1
			timeout_set(&xs->stimeout, isp_wdog, isp);
@


1.30
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.29 2006/11/28 23:59:45 dlg Exp $ */
d3 1
a3 1
 * Platform (OpenBSD) dependent common attachment code for Qlogic adapters.
@


1.29
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.28 2005/12/03 16:53:16 krw Exp $ */
d482 1
a482 1
	 * to kill a command that's already dead by getting it's handle and
@


1.28
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.27 2004/08/02 19:55:45 art Exp $ */
d88 1
d162 4
d169 1
a169 1
	config_found((void *)isp, lptr, scsiprint);
d172 3
a174 1
		config_found((void *)isp, lptr, scsiprint);
@


1.27
log
@Use some horrible macros to uninline a few functions that are expensive
when inlined and shave a few k from the kernel size.

The goal here was not to make the nicest diff possible, but the smallest.

deraadt@@ drahn@@ ok
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.26 2003/10/21 18:58:49 jmc Exp $ */
a320 1
			xs->error = XS_DRIVER_STUFFUP;
a394 3
		if (XS_NOERR(xs)) {
			xs->error = XS_DRIVER_STUFFUP;
		}
@


1.26
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.25 2003/08/06 21:08:06 millert Exp $ */
d43 2
@


1.25
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.24 2002/08/17 17:43:47 mjacob Exp $ */
d520 1
a520 1
			 * After this point, the comamnd is really dead.
d624 2
a625 2
 * Restart function after a LOOP UP event or a commmand completing,
 * somtimes done as a timeout for some hysteresis.
@


1.24
log
@Add ISPASYNC_FW_CRASH case.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.23 2002/05/17 01:32:35 mjacob Exp $ */
d296 1
a296 1
		xs->error = XS_SELTIMEOUT;;
d693 1
a693 1
		flags = sdp->isp_devparam[tgt].actv_flags;;
@


1.23
log
@Acoommodate changes to fabric evaluation.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.22 2001/12/14 00:20:55 mjacob Exp $ */
d782 1
a782 1
		    "None", "Target", "Initiator", "Target/Initiator"
d916 22
@


1.22
log
@Major restructuring for swizzling to the request queue and unswizzling from
the response queue. Instead of the ad hoc ISP_SWIZZLE_REQUEST, we now have
a complete set of inline functions in isp_inline.h. Each platform is
responsible for providing just one of a set of ISP_IOX_{GET,PUT}{8,16,32}
macros.

The reason this needs to be done is that we need to have a single set of
functions that will work correctly on multiple architectures for both little
and big endian machines. It also needs to work correctly in the case that
we have the request or response queues in memory that has to be treated
specially (e.g., have ddi_dma_sync called on it for Solaris after we update
it or before we read from it).

One thing that falls out of this is that we no longer build requests in the
request queue itself. Instead, we build the request locally (e.g., on the
stack) and then as part of the swizzling operation, copy it to the request
queue entry we've allocated. I thought long and hard about whether this was
too expensive a change to make as it in a lot of cases requires an extra
copy. On balance, the flexbility is worth it. With any luck, the entry that
we build locally stays in a processor writeback cache (after all, it's only
64 bytes) so that the cost of actually flushing it to the memory area that is
the shared queue with the PCI device is not all that expensive. We may examine
this again and try to get clever in the future to try and avoid copies.

Another change that falls out of this is that MEMORYBARRIER should be taken
a lot more seriously. The macro ISP_ADD_REQUEST does a MEMORYBARRIER on the
entry being added. But there had been many other places this had been missing.
It's now very important that it be done.

For OpenSD, it does a ddi_dmamap_sync as appropriate. This gets us out of
the explicit ddi_dmamap_sync on the whole response queue that we did for SBus
cards at each interrupt. Now, because SBus/sparc doesn't use bus_dma, some
shenanigans were done to support this. But Jason was nice enough to test the
SBus/sparcv9 changes for me, and they did the right thing as well.

Set things up so that platforms that cannot have an SBus don't get a lot of
the SBus code checks (dead coded out).

Additional changes:

Fix a longstanding buglet of sorts. When we get an entry via isp_getrqentry,
the iptr value that gets returned is the value we intend to eventually plug
into the ISP registers as the entry *one past* the last one we've written-
*not* the current entry we're updating. All along we've been calling sync
functions on the wrong index value. Argh. The 'fix' here is to rename all
'iptr' variables as 'nxti' to remember that this is the 'next' pointer-
not the current pointer.

Devote a single bit to mboxbsy- and set aside bits for output mbox registers
that we need to pick up- we can have at least one command which does not
have any defined output registers (MBOX_EXECUTE_FIRMWARE).

Explicitly decode GetAllNext SNS Response back *as* a GetAllNext response.
Otherwise, we won't unswizzle it correctly.

Nuke some additional __P macros.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.20 2001/09/01 07:16:40 mjacob Exp $ */
d782 1
a782 1
		    "No", "Target", "Initiator", "Target/Initiator"
d808 2
a809 1
		int target, lrange;
d811 1
a812 32
		sns_ganrsp_t *resp = (sns_ganrsp_t *) arg;
		u_int32_t portid;
		u_int64_t wwpn, wwnn;
		fcparam *fcp = isp->isp_param;

		portid =
		    (((u_int32_t) resp->snscb_port_id[0]) << 16) |
		    (((u_int32_t) resp->snscb_port_id[1]) << 8) |
		    (((u_int32_t) resp->snscb_port_id[2]));

		wwpn =
		    (((u_int64_t)resp->snscb_portname[0]) << 56) |
		    (((u_int64_t)resp->snscb_portname[1]) << 48) |
		    (((u_int64_t)resp->snscb_portname[2]) << 40) |
		    (((u_int64_t)resp->snscb_portname[3]) << 32) |
		    (((u_int64_t)resp->snscb_portname[4]) << 24) |
		    (((u_int64_t)resp->snscb_portname[5]) << 16) |
		    (((u_int64_t)resp->snscb_portname[6]) <<  8) |
		    (((u_int64_t)resp->snscb_portname[7]));

		wwnn =
		    (((u_int64_t)resp->snscb_nodename[0]) << 56) |
		    (((u_int64_t)resp->snscb_nodename[1]) << 48) |
		    (((u_int64_t)resp->snscb_nodename[2]) << 40) |
		    (((u_int64_t)resp->snscb_nodename[3]) << 32) |
		    (((u_int64_t)resp->snscb_nodename[4]) << 24) |
		    (((u_int64_t)resp->snscb_nodename[5]) << 16) |
		    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |
		    (((u_int64_t)resp->snscb_nodename[7]));
		if (portid == 0 || wwpn == 0) {
			break;
		}
d814 1
a814 1
		switch (resp->snscb_port_type) {
d837 1
a837 1
			pt = "?";
d840 1
d842 2
a843 3
		    "%s @@ 0x%x, Node 0x%08x%08x Port %08x%08x",
		    pt, portid, ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),
		    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));
d845 3
a847 1
		 * We're only interested in SCSI_FCP types (for now)
d849 2
a850 1
		if ((resp->snscb_fc4_types[2] & 1) == 0) {
d853 18
a870 2
		if (fcp->isp_topo != TOPO_F_PORT)
			lrange = FC_SNS_ID+1;
d872 7
a878 1
			lrange = 0;
d882 1
a882 1
		for (target = lrange; target < MAX_FC_TARG; target++) {
d887 2
a888 1
			if (lp->port_wwn == wwpn && lp->node_wwn == wwnn) {
d893 1
a893 1
		if (target < MAX_FC_TARG) {
d896 1
a896 1
		for (target = lrange; target < MAX_FC_TARG; target++) {
d905 1
a905 1
		if (target == MAX_FC_TARG) {
d907 1
a907 1
			    "no more space for fabric devices");
d910 5
a914 3
		lp->node_wwn = wwnn;
		lp->port_wwn = wwpn;
		lp->portid = portid;
@


1.22.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.22 2001/12/14 00:20:55 mjacob Exp $ */
d782 1
a782 1
		    "None", "Target", "Initiator", "Target/Initiator"
d808 1
a808 2
		int target, base, lim;
		fcparam *fcp = isp->isp_param;
a809 1
		struct lportdb *clp = (struct lportdb *) arg;
d811 32
d844 1
a844 1
		switch (clp->port_type) {
d867 1
a867 1
			pt = " ";
a869 1

d871 3
a873 2
		    "%s Fabric Device @@ PortID 0x%x", pt, clp->portid);

d875 1
a875 3
		 * If we don't have an initiator role we bail.
		 *
		 * We just use ISPASYNC_FABRIC_DEV for announcement purposes.
d877 1
a877 2

		if ((isp->isp_role & ISP_ROLE_INITIATOR) == 0) {
d880 2
a881 18

		/*
		 * Is this entry for us? If so, we bail.
		 */

		if (fcp->isp_portid == clp->portid) {
			break;
		}

		/*
		 * Else, the default policy is to find room for it in
		 * our local port database. Later, when we execute
		 * the call to isp_pdb_sync either this newly arrived
		 * or already logged in device will be (re)announced.
		 */

		if (fcp->isp_topo == TOPO_FL_PORT)
			base = FC_SNS_ID+1;
d883 1
a883 7
			base = 0;

		if (fcp->isp_topo == TOPO_N_PORT)
			lim = 1;
		else
			lim = MAX_FC_TARG;

d887 1
a887 1
		for (target = base; target < lim; target++) {
d892 1
a892 2
			if (lp->port_wwn == clp->port_wwn &&
			    lp->node_wwn == clp->node_wwn) {
d897 1
a897 1
		if (target < lim) {
d900 1
a900 1
		for (target = base; target < lim; target++) {
d909 1
a909 1
		if (target == lim) {
d911 1
a911 1
			    "out of space for fabric devices");
d914 3
a916 5
		lp->port_type = clp->port_type;
		lp->fc4_type = clp->fc4_type;
		lp->node_wwn = clp->node_wwn;
		lp->port_wwn = clp->port_wwn;
		lp->portid = clp->portid;
@


1.22.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.22.2.1 2002/06/11 03:42:19 art Exp $ */
d782 1
a782 1
		    "No", "Target", "Initiator", "Target/Initiator"
a915 22
		break;
	}
	case ISPASYNC_FW_CRASH:
	{
		u_int16_t mbox1, mbox6;
		mbox1 = ISP_READ(isp, OUTMAILBOX1);
		if (IS_DUALBUS(isp)) { 
			mbox6 = ISP_READ(isp, OUTMAILBOX6);
		} else {
			mbox6 = 0;
		}
                isp_prt(isp, ISP_LOGERR,
                    "Internal Firmware Error on bus %d @@ RISC Address 0x%x",
                    mbox6, mbox1);
#ifdef	ISP_FW_CRASH_DUMP
		if (IS_FC(isp)) {
			isp->isp_osinfo.blocked |= 1;
			isp_fw_dump(isp);
		}
		isp_reinit(isp);
		isp_async(isp, ISPASYNC_FW_RESTART, NULL);
#endif
@


1.21
log
@Initialize variable before use. ok fgs@@
@
text
@d532 2
a533 2
			u_int16_t iptr, optr;
			ispreq_t *mp;
d541 1
a541 1
			if (isp_getrqentry(isp, &iptr, &optr, (void **) &mp)) {
d551 2
a552 2
			ISP_SWIZZLE_REQUEST(isp, mp);
			ISP_ADD_REQUEST(isp, iptr);
@


1.20
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.19 2001/06/24 20:59:38 fgsch Exp $ */
d291 2
a293 2

	isp = XS_ISP(xs);
@


1.19
log
@remove cold.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.18 2001/04/04 22:07:40 mjacob Exp $ */
d235 1
a235 1
	sdp->isp_devparam[tgt].dev_flags = f;
d416 3
a418 1
		if (isp_intr((void *)isp)) {
d483 1
a483 1
		u_int16_t r, r1, i;
d503 7
a509 10
		i = 0;
		do {
			r = ISP_READ(isp, BIU_ISR);
			USEC_DELAY(1);
			r1 = ISP_READ(isp, BIU_ISR);
		} while (r != r1 && ++i < 1000);

		if (INT_PENDING(isp, r) && isp_intr(isp) && XS_CMD_DONE_P(xs)) {
			isp_prt(isp, ISP_LOGINFO, "watchdog cleanup (%x, %x)",
			    handle, r);
d525 2
a526 1
			printf("%s: watchdog timeout (%x, %x)\n", handle, r);
d535 2
a536 2
			isp_prt(isp, ISP_LOGINFO,
			    "possible command timeout (%x, %x)", handle, r);
d693 2
a694 2
		flags = sdp->isp_devparam[tgt].cur_dflags;
		period = sdp->isp_devparam[tgt].cur_period;
d697 1
a697 1
		    (sdp->isp_devparam[tgt].cur_offset) != 0) {
d745 1
a745 1
			    bus, tgt, mhz, sdp->isp_devparam[tgt].cur_offset,
@


1.18
log
@Ansify source. Set poenings to maxcmds again. Turn on interrupt
driven mailbox commands if we've gotten past coldstart. Go to
a synchronous restart queue blockage model for REQUEST QUEUE
overflow conditions. Make sure that we only delete timers for
commands that haven't gotten expired timers.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.17 2001/02/12 23:47:11 mjacob Exp $ */
a191 1
	extern int cold;
@


1.17
log
@Change ISPASYNC_LOGGED_INOUT to ISPASYNC_PROMENADE.
Make sure we note if something is a fabric device.
Use isp_fc_runstate instead of isp_control calls
with ISPCTL_FCLINK_TEST and ISPCTL_PDB_SYNC.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.16 2001/01/16 20:01:27 mickey Exp $ */
d5 1
a5 1
 * Copyright (c) 1999, 2000 by Matthew Jacob
d63 3
a65 3
static void ispminphys __P((struct buf *));
static int32_t ispcmd_slow __P((XS_T *));
static int32_t ispcmd __P((XS_T *));
d69 2
a70 2
static int isp_polled_cmd __P((struct ispsoftc *, XS_T *));
static void isp_wdog __P((void *));
d72 2
a73 1
static void isp_internal_restart(void *);
d84 1
a84 2
isp_attach(isp)
	struct ispsoftc *isp;
d100 2
a101 1
	lptr->openings = isp->isp_maxcmds > 128? 128 : isp->isp_maxcmds;
a102 1
		isp->isp_osinfo._adapter.scsi_cmd = ispcmd;
a107 1
		isp->isp_osinfo._adapter.scsi_cmd = ispcmd_slow;
d117 1
a117 2
			lptrb->openings = isp->isp_maxcmds > 128?
			    128 : isp->isp_maxcmds;
a158 10

	/*
	 * After this point, we *could* be doing the new configuration
	 * schema which allows interrups, so we can do tsleep/wakeup
	 * for mailbox stuff at that point.
	 */
#if	0
	isp->isp_osinfo.no_mbox_ints = 0;
#endif

d178 1
a178 2
ispminphys(bp)
	struct buf *bp;
d190 1
a190 2
ispcmd_slow(xs)
	XS_T *xs;
d192 1
d198 8
d217 3
d223 1
a223 6
		f ^= DPARM_SYNC;
#ifdef	DEBUG
	} else {
		printf("%s: channel %d target %d can do SYNC xfers\n",
		    isp->isp_name, chan, tgt);
#endif
d226 1
a226 6
		f ^= DPARM_WIDE;
#ifdef	DEBUG
	} else {
		printf("%s: channel %d target %d can do WIDE xfers\n",
		    isp->isp_name, chan, tgt);
#endif
d229 1
a229 6
		f ^= DPARM_TQING;
#ifdef	DEBUG
	} else {
		printf("%s: channel %d target %d can do TAGGED xfers\n",
		    isp->isp_name, chan, tgt);
#endif
d268 14
d283 1
a283 2
ispcmd(xs)
	XS_T *xs;
a292 1
	timeout_del(&xs->stimeout);
a318 1
		isp_prt(isp, ISP_LOGDEBUG2, "blocked");
d324 8
a331 4
		if (isp->isp_osinfo.wqf != NULL) {
			isp->isp_osinfo.wqt->free_list.le_next = xs;
		} else {
			isp->isp_osinfo.wqf = xs;
a332 4
		isp->isp_osinfo.wqt = xs;
		xs->free_list.le_next = NULL;
		ISP_UNLOCK(isp);
		return (SUCCESSFULLY_QUEUED);
a345 10
#if	0
{
	static int na[16] = { 0 };
	if (na[isp->isp_unit] < isp->isp_nactive) {
		isp_prt(isp, ISP_LOGALL, "active hiwater %d", isp->isp_nactive);
		na[isp->isp_unit] = isp->isp_nactive;
	}
}
#endif

d351 6
d360 4
a363 2
#if	0
		result = TRY_AGAIN_LATER;
a364 1
#endif
d366 3
a368 1
		result = SUCCESSFULLY_QUEUED;
d371 1
d382 1
a382 3
isp_polled_cmd(isp, xs)
	struct ispsoftc *isp;
	XS_T *xs;
d443 1
a443 2
isp_done(xs)
	XS_T *xs;
d447 2
a448 1
		if (xs->timeout) {
d450 1
d454 1
a454 1
			isp_prt(isp, ISP_LOGDEBUG1,
d459 5
d468 1
a468 2
isp_wdog(arg)
	void *arg;
d510 2
a511 2
			isp_prt(isp, ISP_LOGDEBUG1, "watchdog cleanup (%x, %x)",
			    isp->isp_name, handle, r);
d536 1
a536 1
			isp_prt(isp, ISP_LOGDEBUG2,
d541 1
d556 1
a556 1
		isp_prt(isp, ISP_LOGDEBUG2, "watchdog with no command");
d569 1
a569 2
isp_uninit(isp)
	struct ispsoftc *isp;
d586 1
d590 5
a594 4
	switch (ispcmd_slow(xs)) {
	case SUCCESSFULLY_QUEUED:
		printf("%s: isp_command_reque: queued %d.%d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d598 1
d601 9
a609 3
	case TRY_AGAIN_LATER:
		printf("%s: EAGAIN for %d.%d\n",
		    isp->isp_name, XS_TGT(xs), XS_LUN(xs));
d612 1
d614 1
a614 1
	case COMPLETE:
d618 1
a618 1
		XS_CMD_S_DONE(xs);
d625 2
a626 2
 * Restart function after a LOOP UP event (e.g.),
 * done as a timeout for some hysteresis.
d629 1
a629 1
isp_internal_restart(void *arg)
d632 1
a632 1
	int result, nrestarted = 0;
d635 10
a644 4
	if (isp->isp_osinfo.blocked == 0) {
		struct scsi_xfer *xs;
		while ((xs = isp->isp_osinfo.wqf) != NULL) {
			isp->isp_osinfo.wqf = xs->free_list.le_next;
d646 29
a674 13
			result = isp_start(xs);
			if (result != CMD_QUEUED) {
				printf("%s: botched command restart (0x%x)\n",
				    isp->isp_name, result);
				if (XS_NOERR(xs))
					XS_SETERR(xs, XS_DRIVER_STUFFUP);
				XS_CMD_S_DONE(xs);
			} else if (xs->timeout) {
				timeout_add(&xs->stimeout, _XT(xs));
			}
			nrestarted++;
		}
		printf("%s: requeued %d commands\n", isp->isp_name, nrestarted);
a675 1
	ISP_UNLOCK(isp);
d679 1
a679 4
isp_async(isp, cmd, arg)
	struct ispsoftc *isp;
	ispasync_t cmd;
	void *arg;
d766 1
a766 1
		isp->isp_osinfo.blocked = 1;
d770 5
a774 2
		isp->isp_osinfo.blocked = 0;
		timeout_set(&isp->isp_osinfo.rqt, isp_internal_restart, isp);
a927 1
#ifdef	__STDC__
a928 6
#else
isp_log(isp, fmt, va_alist)
	struct ispsoftc *isp;
	char *fmt;
	va_dcl;
#endif
@


1.16
log
@limit the scsi_link.openings to 128 to be safe
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.15 2001/01/09 03:27:04 mjacob Exp $ */
a148 1
		int defid;
d150 1
a151 1
		defid = MAX_FC_TARG;
d153 4
a156 11
		/*
		 * We probably won't have clock interrupts running,
		 * so we'll be really short (smoke test, really)
		 * at this time.
		 */
		if (isp_control(isp, ISPCTL_FCLINK_TEST, NULL)) {
			(void) isp_control(isp, ISPCTL_PDB_SYNC, NULL);
			if (fcp->isp_fwstate == FW_READY &&
			    fcp->isp_loopstate >= LOOP_PDB_RCVD) { 
				defid = fcp->isp_loopid;
			}
d159 1
a159 1
		lptr->adapter_target = fcp->isp_loopid;
d750 1
a750 1
	case ISPASYNC_LOGGED_INOUT:
a756 1
		char *ptr;
a760 5
		if (lp->valid) {
			ptr = "arrived";
		} else {
			ptr = "disappeared";
		}
d762 2
a763 1
		    roles[lp->roles & 0x3], ptr,
d781 4
a784 3
		int target;
		struct lportdb *lp;
		sns_scrsp_t *resp = (sns_scrsp_t *) arg;
d786 1
a786 1
		u_int64_t wwn;
d793 2
a794 1
		wwn =
d804 39
d844 20
a863 5
		    "Fabric Device (Type 0x%x)@@PortID 0x%x WWN 0x%08x%08x",
		    resp->snscb_port_type, portid, ((u_int32_t)(wwn >> 32)),
		    ((u_int32_t)(wwn & 0xffffffff)));

		for (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {
d865 2
a866 1
			if (lp->port_wwn == wwn)
d868 1
d873 4
a876 1
		for (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {
d878 1
a878 1
			if (lp->port_wwn == 0)
d880 1
d885 1
a885 1
			return (-1);
d887 2
a888 1
		lp->port_wwn = lp->node_wwn = wwn;
d890 1
@


1.15
log
@Follow changes to some async event codes.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.14 2000/12/06 01:07:22 mjacob Exp $ */
d100 1
a100 1
	lptr->openings = isp->isp_maxcmds;
d118 2
a119 1
			lptrb->openings = isp->isp_maxcmds;
@


1.14
log
@Update isp codebase to current common head- USEC_SLEEP macro added,
instrumentation for interrupts, specific topology preferences for
the 2200. Fix the hole in the OpenBSD port becuause there'd been
no maxluns limit from the midlayer and have the command routine
bounce commands > the maxluns for a particular controller (in
particular, Qlogic FC cards where we can't tell when it hasn't been
us that have loaded the F/W whether or not SCCLUN is in effect
or not).
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.13 2000/10/16 22:45:00 mjacob Exp $ */
d757 1
a757 1
	case ISPASYNC_PDB_CHANGED:
a781 1
#ifdef	ISP2100_FABRIC
d783 7
a789 1
		isp_prt(isp, ISP_LOGINFO, "Name Server Database Changed");
a840 1
#endif
@


1.13
log
@quiet these puppies down- this OpenBSD, not some callow system like NetBSD
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.12 2000/10/16 01:02:00 mjacob Exp $ */
d299 1
d307 5
@


1.12
log
@Update OpenBSD with respect to Solaris/FreeBSD/NetBSD/Linux versions.

Major rewrite of a lot of internals- far too many to list. Cleaner
locking, more paramaterization, an isp_prt logging function that
handles debugging as well as error printouts. We also should no
longer hang if there is no Loop for Fibre Channel when booting.

The file ispvar.h now contains a list of all platform required macros
and explanation as to what they're for. This should make maintenance
easier.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.11 2000/07/07 19:00:47 mjacob Exp $ */
a145 2
		printf("%s: waiting 4 seconds for bus reset settling\n",
		    isp->isp_name);
@


1.11
log
@Pick up change that went into NetBSD side- I pooched the timeout
calculation. Now it's better.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.10 2000/07/06 05:31:48 mjacob Exp $ */
d5 1
a5 3
 *---------------------------------------
 * Copyright (c) 1999 by Matthew Jacob
 * NASA/Ames Research Center
a6 1
 *---------------------------------------
a13 2
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
d15 1
a15 1
 * 3. The name of the author may not be used to endorse or promote products
a31 1
 *  mjacob@@nas.nasa.gov
a44 11
static void ispminphys __P((struct buf *));
static int32_t ispcmd_slow __P((ISP_SCSI_XFER_T *));
static int32_t ispcmd __P((ISP_SCSI_XFER_T *));

static struct scsi_device isp_dev = { NULL, NULL, NULL, NULL };

static int isp_poll __P((struct ispsoftc *, ISP_SCSI_XFER_T *, int));
static void isp_wdog __P((void *));
static void isp_requeue(void *);
static void isp_internal_restart(void *);

d63 11
d136 1
d142 1
d150 1
a150 1
		int i, j;
d152 3
d156 3
a158 1
		 * wait for the loop to settle.
d160 2
a161 19
		printf("%s: waiting 2 seconds for loop reset settling\n",
		    isp->isp_name);
		delay(2 * 1000000);
		for (j = 0; j < 5; j++) {
			for (i = 0; i < 5; i++) {
				if (isp_control(isp, ISPCTL_FCLINK_TEST, NULL))
					continue;
				/*
				 * Wait extra time to see if the f/w
				 * eventually completed an FLOGI that
				 * will allow us to know we're on a
				 * fabric.
				 */
				if (fcp->isp_onfabric == 0) {
					delay(1 * 1000000);
					continue;
				}
				break;
			}
d164 1
a164 1
				break;
d167 1
d172 9
d213 1
a213 1
	ISP_SCSI_XFER_T *xs;
a285 2
		CFGPRINTF("%s: allowing sync/wide negotiation and "
		    "tag usage\n", isp->isp_name);
d296 1
a296 1
	ISP_SCSI_XFER_T *xs;
a299 1
	int s;
d309 1
a309 1
	s = splbio();
d315 1
a315 1
			(void) splx(s);
d327 1
a327 1
		IDPRINTF(2, ("%s: blocked\n", isp->isp_name));
d330 1
a330 1
			splx(s);
d340 1
a340 1
		splx(s);
a342 1
	result = ispscsicmd(xs);
d344 6
a349 21
	if ((xs->flags & SCSI_POLL) == 0) {
		switch (result) {
		case CMD_QUEUED:
			result = SUCCESSFULLY_QUEUED;
			if (xs->timeout) {
				timeout_add(&xs->stimeout, _XT(xs));
			}
			break;
		case CMD_EAGAIN:
			result = TRY_AGAIN_LATER;
			break;
		case CMD_RQLATER:
			result = SUCCESSFULLY_QUEUED;
			timeout_set(&xs->stimeout, isp_requeue, xs);
			timeout_add(&xs->stimeout, hz);
			break;
		case CMD_COMPLETE:
			result = COMPLETE;
			break;
		}
		(void) splx(s);
d353 47
d417 4
d422 1
a422 1
	 * We can't use interrupts so poll on completion.
d424 7
a430 13
	if (result == SUCCESSFULLY_QUEUED) {
		if (isp_poll(isp, xs, xs->timeout)) {
			/*
			 * If no other error occurred but we didn't finish,
			 * something bad happened.
			 */
			if (XS_CMD_DONE_P(xs) == 0) {
				if (isp_control(isp, ISPCTL_ABORT_CMD, xs)) {
					isp_restart(isp);
				}
				if (XS_NOERR(xs)) {
					XS_SETERR(xs, HBA_BOTCH);
				}
d433 15
a447 1
		result = COMPLETE;
d449 1
a449 1
	(void) splx(s);
d455 1
a455 1
	ISP_SCSI_XFER_T *xs;
d464 2
a465 2
			PRINTF("%s: finished command on borrowed time\n",
			    isp->isp_name);
a471 22
static int
isp_poll(isp, xs, mswait)
	struct ispsoftc *isp;
	ISP_SCSI_XFER_T *xs;
	int mswait;
{

	while (mswait) {
		/* Try the interrupt handling routine */
		(void)isp_intr((void *)isp);

		/* See if the xs is now done */
		if (XS_CMD_DONE_P(xs)) {
			return (0);
		}
		delay(1000);	/* wait one millisecond */
		mswait--;
	}
	return (1);
}


d476 1
a476 1
	ISP_SCSI_XFER_T *xs = arg;
a478 1
	int s = splbio();
d485 1
d491 4
a494 3
			PRINTF("%s: watchdog found done cmd (handle 0x%x)\n",
			    isp->isp_name, handle);
			(void) splx(s);
d499 4
a502 3
			PRINTF("%s: recursive watchdog (handle 0x%x)\n",
			    isp->isp_name, handle);
			(void) splx(s);
d511 1
a511 1
			SYS_DELAY(1);
d516 2
a517 2
			IDPRINTF(1, ("%s: watchdog cleanup (%x, %x)\n",
			    isp->isp_name, handle, r));
d533 1
a533 2
			printf("%s: watchdog timeout (%x, %x)\n",
			    isp->isp_name, handle, r);
d542 2
a543 2
			IDPRINTF(2, ("%s: possible command timeout (%x, %x)\n",
			    isp->isp_name, handle, r));
d548 1
a548 1
				(void) splx(s);
a557 1
			MemoryBarrier();
d561 1
a561 1
		PRINTF("%s: watchdog with no command\n", isp->isp_name);
d563 1
a563 1
	(void) splx(s);
d577 1
a577 1
	int s = splbio();
d583 1
a583 1
	splx(s);
d594 1
a594 1
	int s = splbio();
d607 3
a609 1
		/* FALLTHROUGH */
d614 1
a614 1
		XS_CMD_DONE(xs);
d617 1
a617 1
	(void) splx(s);
d628 1
a628 1
	int result, nrestarted = 0, s;
d630 1
a630 1
	s = splbio();
d636 1
a636 3
			DISABLE_INTS(isp);
			result = ispscsicmd(xs);
			ENABLE_INTS(isp);
d642 1
a642 1
				XS_CMD_DONE(xs);
d650 1
a650 1
	(void) splx(s);
d660 1
a660 1
	int s = splbio();
a671 1

d674 1
d677 6
d709 1
a709 1
			wt = ", 16 bit wide\n";
d712 1
a712 1
			wt = ", Tagged Queueing Enabled\n";
d715 1
a715 1
			wt = ", 16 bit wide, Tagged Queueing Enabled\n";
d718 1
a718 1
			wt = "\n";
d722 4
a725 3
			CFGPRINTF("%s: Bus %d Target %d at %dMHz Max "
			    "Offset %d%s", isp->isp_name, bus, tgt, mhz,
			    sdp->isp_devparam[tgt].cur_offset, wt);
d727 2
a728 2
			CFGPRINTF("%s: Bus %d Target %d Async Mode%s",
			    isp->isp_name, bus, tgt, wt);
d737 1
a737 1
		printf("%s: SCSI bus %d reset detected\n", isp->isp_name, bus);
d745 1
a745 1
		printf("%s: Loop DOWN\n", isp->isp_name);
d751 1
a751 1
		printf("%s: Loop UP\n", isp->isp_name);
d755 2
a756 2
		const char *fmt = "%s: Target %d (Loop 0x%x) Port ID 0x%x "
		    "role %s %s\n Port WWN 0x%08x%08x\n Node WWN 0x%08x%08x\n";
d770 1
a770 1
		printf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,
d778 1
d780 1
a780 1
		printf("%s: Name Server Database Changed\n", isp->isp_name);
d786 1
a786 2
		char *pt;
		sns_ganrsp_t *resp = (sns_ganrsp_t *) arg;
d788 1
a788 1
		u_int64_t wwpn, wwnn;
d795 1
a795 2

		wwpn =
d805 4
a808 12
		wwnn =
		    (((u_int64_t)resp->snscb_nodename[0]) << 56) |
		    (((u_int64_t)resp->snscb_nodename[1]) << 48) |
		    (((u_int64_t)resp->snscb_nodename[2]) << 40) |
		    (((u_int64_t)resp->snscb_nodename[3]) << 32) |
		    (((u_int64_t)resp->snscb_nodename[4]) << 24) |
		    (((u_int64_t)resp->snscb_nodename[5]) << 16) |
		    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |
		    (((u_int64_t)resp->snscb_nodename[7]));
		if (portid == 0 || wwpn == 0) {
			break;
		}
a809 38
		switch (resp->snscb_port_type) {
		case 1:
			pt = "   N_Port";
			break;
		case 2:
			pt = "  NL_Port";
			break;
		case 3:
			pt = "F/NL_Port";
			break;
		case 0x7f:
			pt = "  Nx_Port";
			break;
		case 0x81:
			pt = "  F_port";
			break;
		case 0x82:
			pt = "  FL_Port";
			break;
		case 0x84:
			pt = "   E_port";
			break;
		default:
			pt = "?";
			break;
		}
		CFGPRINTF("%s: %s @@ 0x%x, Node 0x%08x%08x Port %08x%08x\n",
		    isp->isp_name, pt, portid,
		    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),
		    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));
#if	0
		if ((resp->snscb_fc4_types[1] & 0x1) == 0) {
			printf("Types 0..3: 0x%x 0x%x 0x%x 0x%x\n",
			    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],
			    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);
			break;
		}
#endif
d812 1
a812 1
			if (lp->port_wwn == wwpn && lp->node_wwn == wwnn)
d824 3
a826 3
			printf("%s: no more space for fabric devices\n",
			    isp->isp_name);
			break;
d828 1
a828 2
		lp->node_wwn = wwnn;
		lp->port_wwn = wwpn;
d832 1
a835 1
	(void) splx(s);
d837 21
@


1.10
log
@Resync with FreeBSD/NetBSD. Salient features are that the mailbox command
routines are not necessarily polled now- this should cut down on some of
the spurious lost commands that have occurred. Also, we now watchdog each
command and make sure that command constipation doesn't occur (which it
has been documented to do on the QLA2100 cards).
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.9 2000/04/06 05:47:54 mjacob Exp $ */
d62 17
a78 1
#define	_XT(xs)	((((xs)->timeout + 999)/1000) + (2 * hz))
@


1.9
log
@Remove restriction against bus resets for Ultra3 cards (and what
would have been for Ultra2)- we've fixed the problem in isp_control.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.8 2000/03/05 22:22:55 mjacob Exp $ */
d58 2
a59 2
static void isp_watch __P((void *));
static void isp_command_requeue(void *);
d62 2
a149 1
#ifdef	ISP2100_FABRIC
a159 1
#endif
a170 8
	 * Start the watchdog.
	 *
	 * The watchdog will, ridiculously enough, also enable Sync negotiation.
	 */
	isp->isp_dogactive = 1;
	timeout(isp_watch, isp, WATCH_INTERVAL * hz);

	/*
d294 8
a301 1
	isp = xs->sc_link->adapter_softc;
a302 1

a335 1
	DISABLE_INTS(isp);
a336 1
	ENABLE_INTS(isp);
d342 3
d351 2
a352 1
			timeout(isp_command_requeue, xs, hz);
d388 1
a388 1
			if (XS_IS_CMD_DONE(xs) == 0) {
d403 19
d434 1
a434 1
		if (XS_IS_CMD_DONE(xs)) {
d445 1
a445 1
isp_watch(arg)
d448 4
a451 4
	int i;
	struct ispsoftc *isp = arg;
	struct scsi_xfer *xs;
	int s;
d454 13
a466 6
	 * Look for completely dead commands (but not polled ones).
	 */
	s = splbio();
	for (i = 0; i < isp->isp_maxcmds; i++) {
		if ((xs = (struct scsi_xfer *) isp->isp_xflist[i]) == NULL) {
			continue;
d468 6
a473 2
		if (xs->timeout == 0 || (xs->flags & SCSI_POLL)) {
			continue;
a474 1
		xs->timeout -= (WATCH_INTERVAL * 1000);
d476 55
a530 16
		/*
		 * Avoid later thinking that this
		 * transaction is not being timed.
		 * Then give ourselves to watchdog
		 * periods of grace.
		 */
		if (xs->timeout == 0) {
			xs->timeout = 1;
		} else if (xs->timeout > -(2 * WATCH_INTERVAL * 1000)) {
			continue;
		}
		if (isp_control(isp, ISPCTL_ABORT_CMD, xs)) {
			printf("%s: isp_watch failed to abort command\n",
			    isp->isp_name);
			isp_restart(isp);
			break;
d532 2
d535 1
a535 3
        timeout(isp_watch, isp, WATCH_INTERVAL * hz);
	isp->isp_dogactive = 1;
	splx(s);
a554 8
	/*
	 * Turn off the watchdog (if active).
	 */
	if (isp->isp_dogactive) {
		untimeout(isp_watch, isp);
		isp->isp_dogactive = 0;
	}

d562 1
a562 1
isp_command_requeue(void *arg)
d571 4
d615 2
d714 2
a715 1
		timeout(isp_internal_restart, isp, 1);
a742 1
#ifdef	ISP2100_FABRIC
a844 1
#endif
@


1.8
log
@Don't issue an initial SCSI bus reset for Ultra3 cards. What seems to
happen is that the SCSI bus reset, even after several seconds delay, seems
to cause the Qlogic to then destroy several subsequent commands (which,
ha ha, happen during probing for devices). I dunno why this is- some Qlogic
f/w problem that we need to step around.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.7 2000/02/20 21:22:41 mjacob Exp $ */
d119 2
a120 4
	 * XXX: For now, skip resets for FC because the method by which
	 * XXX: we deal with loop down after issuing resets (which causes
	 * XXX: port logouts for all devices) needs interrupts to run so
	 * XXX: that async events happen.
d123 4
a126 3
		/* XXX: There's some issue with resets && Ultra3 */
		if (!IS_ULTRA3(isp)) {
			int bus = 0;
a127 10
			if (IS_DUALBUS(isp)) {
				bus++;
				(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);
			}
			/*
			 * wait for the bus to settle.
			 */
			printf("%s: waiting 4 seconds for bus reset settling\n",
			    isp->isp_name);
			delay(4 * 1000000);
d129 6
@


1.7
log
@Add 12160 (Ultra3) support. Add files and changes for target mode support.
Do some SNS fabric suppor tchanges. Roll revision levels. Tested on
GENERIC i386 && sparc.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.6 1999/12/16 05:25:39 mjacob Exp $ */
d125 3
a127 4
		int bus = 0;
		(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);
		if (IS_DUALBUS(isp)) {
			bus++;
d129 10
a139 6
		/*
		 * wait for the bus to settle.
		 */
		printf("%s: waiting 4 seconds for bus reset settling\n",
		    isp->isp_name);
		delay(4 * 1000000);
@


1.6
log
@Add in dual bus (1240/1280) support. Some more cleanups, including fixes
to the speed update stuff. Also a fix for an amazingly silly botch in
isp_async.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.5 1999/11/22 22:34:30 mjacob Exp $ */
d587 3
d686 2
a687 1
		sns_scrsp_t *resp = (sns_scrsp_t *) arg;
d689 1
a689 1
		u_int64_t wwn;
d696 2
a697 1
		wwn =
d706 29
a734 5
		printf("%s: Fabric Device (Type 0x%x)@@PortID 0x%x WWN "
		    "0x%08x%08x\n", isp->isp_name, resp->snscb_port_type,
		    portid, ((u_int32_t)(wwn >> 32)),
		    ((u_int32_t)(wwn & 0xffffffff)));
		if (resp->snscb_port_type != 2)
d736 22
d760 1
a760 1
			if (lp->port_wwn == wwn)
d774 1
a774 1
			return (-1);
d776 2
a777 1
		lp->port_wwn = lp->node_wwn = wwn;
@


1.6.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.7 2000/02/20 21:22:41 mjacob Exp $ */
a586 3
				case 0x9:
					mhz = 80;
					break;
d683 1
a683 2
		char *pt;
		sns_ganrsp_t *resp = (sns_ganrsp_t *) arg;
d685 1
a685 1
		u_int64_t wwpn, wwnn;
d692 1
a692 2

		wwpn =
d701 5
a705 29

		wwnn =
		    (((u_int64_t)resp->snscb_nodename[0]) << 56) |
		    (((u_int64_t)resp->snscb_nodename[1]) << 48) |
		    (((u_int64_t)resp->snscb_nodename[2]) << 40) |
		    (((u_int64_t)resp->snscb_nodename[3]) << 32) |
		    (((u_int64_t)resp->snscb_nodename[4]) << 24) |
		    (((u_int64_t)resp->snscb_nodename[5]) << 16) |
		    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |
		    (((u_int64_t)resp->snscb_nodename[7]));
		if (portid == 0 || wwpn == 0) {
			break;
		}

		switch (resp->snscb_port_type) {
		case 1:
			pt = "   N_Port";
			break;
		case 2:
			pt = "  NL_Port";
			break;
		case 3:
			pt = "F/NL_Port";
			break;
		case 0x7f:
			pt = "  Nx_Port";
			break;
		case 0x81:
			pt = "  F_port";
a706 22
		case 0x82:
			pt = "  FL_Port";
			break;
		case 0x84:
			pt = "   E_port";
			break;
		default:
			pt = "?";
			break;
		}
		CFGPRINTF("%s: %s @@ 0x%x, Node 0x%08x%08x Port %08x%08x\n",
		    isp->isp_name, pt, portid,
		    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),
		    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));
#if	0
		if ((resp->snscb_fc4_types[1] & 0x1) == 0) {
			printf("Types 0..3: 0x%x 0x%x 0x%x 0x%x\n",
			    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],
			    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);
			break;
		}
#endif
d709 1
a709 1
			if (lp->port_wwn == wwpn && lp->node_wwn == wwnn)
d723 1
a723 1
			break;
d725 1
a725 2
		lp->node_wwn = wwnn;
		lp->port_wwn = wwpn;
@


1.6.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/* 	$OpenBSD$ */
d125 4
a128 3
		/* XXX: There's some issue with resets && Ultra3 */
		if (!IS_ULTRA3(isp)) {
			int bus = 0;
a129 10
			if (IS_DUALBUS(isp)) {
				bus++;
				(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);
			}
			/*
			 * wait for the bus to settle.
			 */
			printf("%s: waiting 4 seconds for bus reset settling\n",
			    isp->isp_name);
			delay(4 * 1000000);
d131 6
@


1.6.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.18 2001/04/04 22:07:40 mjacob Exp $ */
d5 3
a7 1
 * Copyright (c) 1999, 2000, 2001 by Matthew Jacob
d9 1
d17 2
d20 1
a20 1
 * 2. The name of the author may not be used to endorse or promote products
d37 1
d51 3
a53 21
/*
 * Set a timeout for the watchdogging of a command.
 *
 * The dimensional analysis is
 *
 *	milliseconds * (seconds/millisecond) * (ticks/second) = ticks
 *
 *			=
 *
 *	(milliseconds / 1000) * hz = ticks
 *
 *
 * For timeouts less than 1 second, we'll get zero. Because of this, and
 * because we want to establish *our* timeout to be longer than what the
 * firmware might do, we just add 3 seconds at the back end.
 */
#define	_XT(xs)	((((xs)->timeout/1000) * hz) + (3 * hz))

static void ispminphys(struct buf *);
static int32_t ispcmd_slow(XS_T *);
static int32_t ispcmd(XS_T *);
d57 4
a60 5
static int isp_polled_cmd (struct ispsoftc *, XS_T *);
static void isp_wdog (void *);
static void isp_requeue(void *);
static void isp_trestart(void *);
static void isp_restart(struct ispsoftc *);
d71 2
a72 1
isp_attach(struct ispsoftc *isp)
d88 1
a88 2
	lptr->openings = imin(isp->isp_maxcmds, MAXISPREQUEST(isp));
	isp->isp_osinfo._adapter.scsi_cmd = ispcmd_slow;
d90 1
d96 1
d106 1
a106 1
			lptrb->openings = lptr->openings;
d119 4
a122 2
	 * We don't do 'bus resets' for FC because the LIP that occurs
	 * when we start the firmware does all that for us.
d125 3
a127 5
		int bus = 0;
		ISP_LOCK(isp);
		(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);
		if (IS_DUALBUS(isp)) {
			bus++;
d129 10
d140 3
a142 1
		ISP_UNLOCK(isp);
d144 1
a144 1
		 * wait for the bus to settle.
d146 2
a147 4
		delay(4 * 1000000);
	} else {
		fcparam *fcp = isp->isp_param;
		int defid = MAX_FC_TARG;
d149 22
a170 5
		ISP_LOCK(isp);
		isp_fc_runstate(isp, 10 * 1000000);
		if (fcp->isp_fwstate == FW_READY &&
		    fcp->isp_loopstate >= LOOP_PDB_RCVD) {
			defid = fcp->isp_loopid;
d172 1
a172 2
		ISP_UNLOCK(isp);
		lptr->adapter_target = defid;
d174 9
d202 2
a203 1
ispminphys(struct buf *bp)
d215 2
a216 1
ispcmd_slow(XS_T *xs)
a217 1
	extern int cold;
a222 8
	if (IS_FC(isp)) {
		if (cold == 0) {
			isp->isp_osinfo.no_mbox_ints = 0;
			isp->isp_osinfo._adapter.scsi_cmd = ispcmd;
		}
		return (ispcmd(xs));
	}

a233 3
	if (cold == 0) {
		isp->isp_osinfo.no_mbox_ints = 0;
	}
d237 6
a242 1
		f &= ~DPARM_SYNC;
d245 6
a250 1
		f &= ~DPARM_WIDE;
d253 6
a258 1
		f &= ~DPARM_TQING;
d289 2
a298 14
static INLINE void isp_add2_blocked_queue(struct ispsoftc *, XS_T *);

static INLINE void
isp_add2_blocked_queue(struct ispsoftc *isp, XS_T *xs)
{
	if (isp->isp_osinfo.wqf != NULL) {
		isp->isp_osinfo.wqt->free_list.le_next = xs;
	} else {
		isp->isp_osinfo.wqf = xs;
	}
	isp->isp_osinfo.wqt = xs;
	xs->free_list.le_next = NULL;
}

d300 2
a301 1
ispcmd(XS_T *xs)
d305 1
d307 2
a309 13
	/*
	 * Make sure that there's *some* kind of sane setting.
	 */
	timeout_set(&xs->stimeout, isp_wdog, isp);

	isp = XS_ISP(xs);

	if (XS_LUN(xs) >= isp->isp_maxluns) {
		xs->error = XS_SELTIMEOUT;;
		return (COMPLETE);
	}

	ISP_LOCK(isp);
d315 1
a315 1
			ISP_UNLOCK(isp);
d327 1
d330 1
a330 1
			ISP_UNLOCK(isp);
d333 4
a336 8
		if (isp->isp_osinfo.blocked == 2) {
			isp_restart(isp);
		}
		if (isp->isp_osinfo.blocked) {
			isp_add2_blocked_queue(isp, xs);
			ISP_UNLOCK(isp);
			isp_prt(isp, ISP_LOGDEBUG0, "added to blocked queue");
			return (SUCCESSFULLY_QUEUED);
d338 4
d343 3
d347 17
a363 6
	if (xs->flags & SCSI_POLL) {
		volatile u_int8_t ombi = isp->isp_osinfo.no_mbox_ints;
		isp->isp_osinfo.no_mbox_ints = 1;
		result = isp_polled_cmd(isp, xs);
		isp->isp_osinfo.no_mbox_ints = ombi;
		ISP_UNLOCK(isp);
a366 45
	result = isp_start(xs);

	switch (result) {
	case CMD_QUEUED:
		result = SUCCESSFULLY_QUEUED;
		if (xs->timeout) {
			timeout_add(&xs->stimeout, _XT(xs));
			XS_CMD_S_TIMER(xs);
		}
		if (isp->isp_osinfo.hiwater < isp->isp_nactive) {
			isp->isp_osinfo.hiwater = isp->isp_nactive;
			isp_prt(isp, ISP_LOGDEBUG0,
			    "Active Hiwater Mark=%d", isp->isp_nactive);
		}
		break;
	case CMD_EAGAIN:
		isp->isp_osinfo.blocked |= 2;
		isp_prt(isp, ISP_LOGDEBUG0, "blocking queue");
		isp_add2_blocked_queue(isp, xs);
		result = SUCCESSFULLY_QUEUED;
		break;
	case CMD_RQLATER:
		result = SUCCESSFULLY_QUEUED;	/* Lie */
		isp_prt(isp, ISP_LOGDEBUG1, "retrying later for %d.%d",
		    XS_TGT(xs), XS_LUN(xs));
		timeout_set(&xs->stimeout, isp_requeue, xs);
		timeout_add(&xs->stimeout, hz);
		XS_CMD_S_TIMER(xs);
		break;
	case CMD_COMPLETE:
		result = COMPLETE;
		break;
	}
	ISP_UNLOCK(isp);
	return (result);
}

static int
isp_polled_cmd(struct ispsoftc *isp, XS_T *xs)
{
	int result;
	int infinite = 0, mswait;

	result = isp_start(xs);

a383 4
	if (result != SUCCESSFULLY_QUEUED) {
		return (result);
	}

d385 1
a385 1
	 * If we can't use interrupts, poll on completion.
d387 13
a399 7
	if ((mswait = XS_TIME(xs)) == 0)
		infinite = 1;

	while (mswait || infinite) {
		if (isp_intr((void *)isp)) {
			if (XS_CMD_DONE_P(xs)) {
				break;
d402 1
a402 2
		USEC_DELAY(1000);
		mswait -= 1;
d404 1
a404 14

	/*
	 * If no other error occurred but we didn't finish,
	 * something bad happened.
	 */
	if (XS_CMD_DONE_P(xs) == 0) {
		if (isp_control(isp, ISPCTL_ABORT_CMD, xs)) {
			isp_reinit(isp);
		}
		if (XS_NOERR(xs)) {
			XS_SETERR(xs, HBA_BOTCH);
		}
	}
	result = COMPLETE;
d408 5
a412 2
void
isp_done(XS_T *xs)
d414 8
a421 18
	XS_CMD_S_DONE(xs);
	if (XS_CMD_WDOG_P(xs) == 0) {
		struct ispsoftc *isp = XS_ISP(xs);
		if (XS_CMD_TIMER_P(xs)) {
			timeout_del(&xs->stimeout);
			XS_CMD_C_TIMER(xs);
		}
		if (XS_CMD_GRACE_P(xs)) {
			struct ispsoftc *isp = XS_ISP(xs);
			isp_prt(isp, ISP_LOGWARN,
			    "finished command on borrowed time");
		}
		XS_CMD_S_CLEAR(xs);
		scsi_done(xs);
		if (isp->isp_osinfo.blocked == 2) {
			isp->isp_osinfo.blocked = 0;
			isp_prt(isp, ISP_LOGDEBUG0, "restarting blocked queue");
			isp_restart(isp);
d423 2
d426 1
d429 1
d431 2
a432 1
isp_wdog(void *arg)
d434 4
a437 3
	XS_T *xs = arg;
	struct ispsoftc *isp = XS_ISP(xs);
	u_int32_t handle;
d440 11
a450 45
	 * We've decided this command is dead. Make sure we're not trying
	 * to kill a command that's already dead by getting it's handle and
	 * and seeing whether it's still alive.
	 */
	ISP_LOCK(isp);
	handle = isp_find_handle(isp, xs);
	if (handle) {
		u_int16_t r, r1, i;

		if (XS_CMD_DONE_P(xs)) {
			isp_prt(isp, ISP_LOGDEBUG1,
			    "watchdog found done cmd (handle 0x%x)",
			    handle);
			ISP_UNLOCK(isp);
			return;
		}

		if (XS_CMD_WDOG_P(xs)) {
			isp_prt(isp, ISP_LOGDEBUG1,
			    "recursive watchdog (handle 0x%x)",
			    handle);
			ISP_UNLOCK(isp);
			return;
		}

		XS_CMD_S_WDOG(xs);

		i = 0;
		do {
			r = ISP_READ(isp, BIU_ISR);
			USEC_DELAY(1);
			r1 = ISP_READ(isp, BIU_ISR);
		} while (r != r1 && ++i < 1000);

		if (INT_PENDING(isp, r) && isp_intr(isp) && XS_CMD_DONE_P(xs)) {
			isp_prt(isp, ISP_LOGINFO, "watchdog cleanup (%x, %x)",
			    handle, r);
			XS_CMD_C_WDOG(xs);
			isp_done(xs);
		} else if (XS_CMD_GRACE_P(xs)) {
			/*
			 * Make sure the command is *really* dead before we
			 * release the handle (and DMA resources) for reuse.
			 */
			(void) isp_control(isp, ISPCTL_ABORT_CMD, arg);
d452 16
a467 33
			/*
			 * After this point, the comamnd is really dead.
			 */
			if (XS_XFRLEN(xs)) {
				ISP_DMAFREE(isp, xs, handle);
			}
			printf("%s: watchdog timeout (%x, %x)\n", handle, r);
			isp_destroy_handle(isp, handle);
			XS_SETERR(xs, XS_TIMEOUT);
			XS_CMD_S_CLEAR(xs);
			isp_done(xs);
		} else {
			u_int16_t iptr, optr;
			ispreq_t *mp;

			isp_prt(isp, ISP_LOGINFO,
			    "possible command timeout (%x, %x)", handle, r);

			XS_CMD_C_WDOG(xs);
			timeout_add(&xs->stimeout, _XT(xs));
			XS_CMD_S_TIMER(xs);
			if (isp_getrqentry(isp, &iptr, &optr, (void **) &mp)) {
				ISP_UNLOCK(isp);
				return;
			}
			XS_CMD_S_GRACE(xs);
			MEMZERO((void *) mp, sizeof (*mp));
			mp->req_header.rqs_entry_count = 1;
			mp->req_header.rqs_entry_type = RQSTYPE_MARKER;
			mp->req_modifier = SYNC_ALL;
			mp->req_target = XS_CHANNEL(xs) << 7;
			ISP_SWIZZLE_REQUEST(isp, mp);
			ISP_ADD_REQUEST(isp, iptr);
a468 2
	} else if (isp->isp_dblev) {
		isp_prt(isp, ISP_LOGDEBUG1, "watchdog with no command");
d470 3
a472 1
	ISP_UNLOCK(isp);
d483 2
a484 1
isp_uninit(struct ispsoftc *isp)
d486 1
a486 1
	ISP_LOCK(isp);
d492 9
a500 1
	ISP_UNLOCK(isp);
d507 1
a507 1
isp_requeue(void *arg)
a508 1
	int r;
d511 11
a521 26
	ISP_LOCK(isp);
	r = isp_start(xs);
	switch (r) {
	case CMD_QUEUED:
		isp_prt(isp, ISP_LOGDEBUG1, "restarted command for %d.%d",
		    XS_TGT(xs), XS_LUN(xs));
		if (xs->timeout) {
			timeout_set(&xs->stimeout, isp_wdog, isp);
			timeout_add(&xs->stimeout, _XT(xs));
			XS_CMD_S_TIMER(xs);
		}
		break;
	case CMD_EAGAIN:
		isp_prt(isp, ISP_LOGDEBUG0, "blocked cmd again");
		isp->isp_osinfo.blocked |= 2;
		isp_add2_blocked_queue(isp, xs);
		break;
	case CMD_RQLATER:
		isp_prt(isp, ISP_LOGDEBUG0, "%s for %d.%d",
		    (r == CMD_EAGAIN)? "CMD_EAGAIN" : "CMD_RQLATER",
		    XS_TGT(xs), XS_LUN(xs));
		timeout_set(&xs->stimeout, isp_requeue, xs);
		timeout_add(&xs->stimeout, hz);
		XS_CMD_S_TIMER(xs);
		break;
	case CMD_COMPLETE:
d525 1
a525 1
		isp_done(xs);
d528 1
a528 1
	ISP_UNLOCK(isp);
d532 2
a533 2
 * Restart function after a LOOP UP event or a commmand completing,
 * somtimes done as a timeout for some hysteresis.
d536 1
a536 1
isp_trestart(void *arg)
d539 1
a539 1
	struct scsi_xfer *list;
d541 5
a545 11
	ISP_LOCK(isp);
	isp->isp_osinfo.rtpend = 0;
	list = isp->isp_osinfo.wqf;
	if (isp->isp_osinfo.blocked == 0 && list != NULL) {
		int nrestarted = 0;

		isp->isp_osinfo.wqf = NULL;
		ISP_UNLOCK(isp);
		do {
			struct scsi_xfer *xs = list;
			list = xs->free_list.le_next;
d547 13
a559 29
			isp_requeue(xs);
			if (isp->isp_osinfo.wqf == NULL)
				nrestarted++;
		} while (list != NULL);
		isp_prt(isp, ISP_LOGDEBUG0, "requeued %d commands", nrestarted);
	} else {
		ISP_UNLOCK(isp);
	}
}

static void
isp_restart(struct ispsoftc *isp)
{
	struct scsi_xfer *list;

	list = isp->isp_osinfo.wqf;
	if (isp->isp_osinfo.blocked == 0 && list != NULL) {
		int nrestarted = 0;

		isp->isp_osinfo.wqf = NULL;
		do {
			struct scsi_xfer *xs = list;
			list = xs->free_list.le_next;
			xs->free_list.le_next = NULL;
			isp_requeue(xs);
			if (isp->isp_osinfo.wqf == NULL)
				nrestarted++;
		} while (list != NULL);
		isp_prt(isp, ISP_LOGDEBUG0, "requeued %d commands", nrestarted);
d561 1
d565 4
a568 1
isp_async(struct ispsoftc *isp, ispasync_t cmd, void *arg)
d571 1
a571 1

d583 1
a585 1

a587 6
			/*
			 * There's some ambiguity about our negotiated speed
			 * if we haven't detected LVD mode correctly (which
			 * seems to happen, unfortunately). If we're in LVD
			 * mode, then different rules apply about speed.
			 */
d614 1
a614 1
			wt = ", 16 bit wide";
d617 1
a617 1
			wt = ", Tagged Queueing Enabled";
d620 1
a620 1
			wt = ", 16 bit wide, Tagged Queueing Enabled";
d623 1
a623 1
			wt = " ";
d627 3
a629 4
			isp_prt(isp, ISP_LOGINFO,
			    "Bus %d Target %d at %dMHz Max Offset %d%s",
			    bus, tgt, mhz, sdp->isp_devparam[tgt].cur_offset,
			    wt);
d631 2
a632 2
			isp_prt(isp, ISP_LOGINFO,
			    "Bus %d Target %d Async Mode%s", bus, tgt, wt);
d641 1
a641 1
		isp_prt(isp, ISP_LOGINFO, "SCSI bus %d reset detected", bus);
d648 2
a649 2
		isp->isp_osinfo.blocked |= 1;
		isp_prt(isp, ISP_LOGINFO, "Loop DOWN");
d652 3
a654 7
		isp->isp_osinfo.blocked &= ~1;
		if (isp->isp_osinfo.rtpend == 0) {
			timeout_set(&isp->isp_osinfo.rqt, isp_trestart, isp);
			isp->isp_osinfo.rtpend = 1;
		}
		timeout_add(&isp->isp_osinfo.rqt, 1);
		isp_prt(isp, ISP_LOGINFO, "Loop UP");
d656 1
a656 1
	case ISPASYNC_PROMENADE:
d658 2
a659 2
		const char *fmt = "Target %d (Loop 0x%x) Port ID 0x%x "
		    "role %s %s\n Port WWN 0x%08x%08x\n Node WWN 0x%08x%08x";
d663 1
d668 7
a674 3
		isp_prt(isp, ISP_LOGINFO, fmt, tgt, lp->loopid, lp->portid,
		    roles[lp->roles & 0x3],
		    (lp->valid)? "Arrived" : "Departed",
d681 1
d683 1
a683 7
		if (arg == (void *) 1) {
			isp_prt(isp, ISP_LOGINFO,
			    "Name Server Database Changed");
		} else {
			isp_prt(isp, ISP_LOGINFO,
			    "Name Server Database Changed");
		}
d687 2
a688 2
		int target, lrange;
		struct lportdb *lp = NULL;
d749 3
a751 3
		isp_prt(isp, ISP_LOGINFO,
		    "%s @@ 0x%x, Node 0x%08x%08x Port %08x%08x",
		    pt, portid, ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),
d753 5
a757 4
		/*
		 * We're only interested in SCSI_FCP types (for now)
		 */
		if ((resp->snscb_fc4_types[2] & 1) == 0) {
d760 2
a761 11
		if (fcp->isp_topo != TOPO_F_PORT)
			lrange = FC_SNS_ID+1;
		else
			lrange = 0;
		/*
		 * Is it already in our list?
		 */
		for (target = lrange; target < MAX_FC_TARG; target++) {
			if (target >= FL_PORT_ID && target <= FC_SNS_ID) {
				continue;
			}
d763 1
a763 2
			if (lp->port_wwn == wwpn && lp->node_wwn == wwnn) {
				lp->fabric_dev = 1;
a764 1
			}
d769 1
a769 4
		for (target = lrange; target < MAX_FC_TARG; target++) {
			if (target >= FL_PORT_ID && target <= FC_SNS_ID) {
				continue;
			}
d771 1
a771 1
			if (lp->port_wwn == 0) {
a772 1
			}
d775 2
a776 2
			isp_prt(isp, ISP_LOGWARN,
			    "no more space for fabric devices");
a781 1
		lp->fabric_dev = 1;
d784 1
d788 1
a789 14
}

void
isp_prt(struct ispsoftc *isp, int level, const char *fmt, ...)
{
	va_list ap;
	if (level != ISP_LOGALL && (level & isp->isp_dblev) == 0) {
		return;
	}
	printf("%s: ", isp->isp_name);
	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
	printf("\n");
@


1.6.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.6.2.3 2001/05/14 22:23:55 niklas Exp $ */
d192 1
@


1.6.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.6.2.4 2001/07/04 10:40:57 niklas Exp $ */
d235 1
a235 1
	sdp->isp_devparam[tgt].goal_flags = f;
d416 1
a416 3
		u_int16_t isr, sema, mbox;
		if (ISP_READ_ISR(isp, &isr, &sema, &mbox)) {
			isp_intr(isp, isr, sema, mbox);
d481 1
a481 1
		u_int16_t isr, sema, mbox;
d501 10
a510 7
		if (ISP_READ_ISR(isp, &isr, &sema, &mbox)) {
			isp_intr(isp, isr, sema, mbox);
		}

		if (XS_CMD_DONE_P(xs)) {
			isp_prt(isp, ISP_LOGINFO,
			    "watchdog cleanup for handle 0x%x", handle);
d526 1
a526 2
			isp_prt(isp, ISP_LOGWARN,
			    "watchdog timeout on handle %x", handle);
d535 2
a536 2
			isp_prt(isp, ISP_LOGWARN,
			    "possible command timeout on handle %x", handle);
d693 2
a694 2
		flags = sdp->isp_devparam[tgt].actv_flags;;
		period = sdp->isp_devparam[tgt].actv_period;
d697 1
a697 1
		    (sdp->isp_devparam[tgt].actv_offset) != 0) {
d745 1
a745 1
			    bus, tgt, mhz, sdp->isp_devparam[tgt].actv_offset,
@


1.6.2.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/* 	$OpenBSD$ */
d291 2
a294 2
	timeout_set(&xs->stimeout, isp_wdog, isp);

d532 2
a533 2
			u_int16_t nxti, optr;
			ispreq_t local, *mp = &local, *qe;
d541 1
a541 1
			if (isp_getrqentry(isp, &nxti, &optr, (void **) &qe)) {
d551 2
a552 2
			isp_put_request(isp, mp, qe);
			ISP_ADD_REQUEST(isp, nxti);
@


1.6.2.7
log
@Sync the SMP branch with 3.3
@
text
@d808 1
a808 2
		int target, base, lim;
		fcparam *fcp = isp->isp_param;
a809 1
		struct lportdb *clp = (struct lportdb *) arg;
d811 32
d844 1
a844 1
		switch (clp->port_type) {
d867 1
a867 1
			pt = " ";
a869 1

d871 3
a873 2
		    "%s Fabric Device @@ PortID 0x%x", pt, clp->portid);

d875 1
a875 3
		 * If we don't have an initiator role we bail.
		 *
		 * We just use ISPASYNC_FABRIC_DEV for announcement purposes.
d877 1
a877 2

		if ((isp->isp_role & ISP_ROLE_INITIATOR) == 0) {
d880 2
a881 18

		/*
		 * Is this entry for us? If so, we bail.
		 */

		if (fcp->isp_portid == clp->portid) {
			break;
		}

		/*
		 * Else, the default policy is to find room for it in
		 * our local port database. Later, when we execute
		 * the call to isp_pdb_sync either this newly arrived
		 * or already logged in device will be (re)announced.
		 */

		if (fcp->isp_topo == TOPO_FL_PORT)
			base = FC_SNS_ID+1;
d883 1
a883 7
			base = 0;

		if (fcp->isp_topo == TOPO_N_PORT)
			lim = 1;
		else
			lim = MAX_FC_TARG;

d887 1
a887 1
		for (target = base; target < lim; target++) {
d892 1
a892 2
			if (lp->port_wwn == clp->port_wwn &&
			    lp->node_wwn == clp->node_wwn) {
d897 1
a897 1
		if (target < lim) {
d900 1
a900 1
		for (target = base; target < lim; target++) {
d909 1
a909 1
		if (target == lim) {
d911 1
a911 1
			    "out of space for fabric devices");
d914 3
a916 5
		lp->port_type = clp->port_type;
		lp->fc4_type = clp->fc4_type;
		lp->node_wwn = clp->node_wwn;
		lp->port_wwn = clp->port_wwn;
		lp->portid = clp->portid;
a917 22
		break;
	}
	case ISPASYNC_FW_CRASH:
	{
		u_int16_t mbox1, mbox6;
		mbox1 = ISP_READ(isp, OUTMAILBOX1);
		if (IS_DUALBUS(isp)) { 
			mbox6 = ISP_READ(isp, OUTMAILBOX6);
		} else {
			mbox6 = 0;
		}
                isp_prt(isp, ISP_LOGERR,
                    "Internal Firmware Error on bus %d @@ RISC Address 0x%x",
                    mbox6, mbox1);
#ifdef	ISP_FW_CRASH_DUMP
		if (IS_FC(isp)) {
			isp->isp_osinfo.blocked |= 1;
			isp_fw_dump(isp);
		}
		isp_reinit(isp);
		isp_async(isp, ISPASYNC_FW_RESTART, NULL);
#endif
@


1.6.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d296 1
a296 1
		xs->error = XS_SELTIMEOUT;
d520 1
a520 1
			 * After this point, the command is really dead.
d624 2
a625 2
 * Restart function after a LOOP UP event or a command completing,
 * sometimes done as a timeout for some hysteresis.
d693 1
a693 1
		flags = sdp->isp_devparam[tgt].actv_flags;
@


1.5
log
@Fix crock where channel was used before being set. All my kernels
worked, guess it was a random thing. Pity that the compiler didn't,
like it would have for FreeBSD, warn about 'used before being set'.
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.4 1999/11/22 12:50:53 mjacob Exp $ */
d56 1
d74 1
d78 1
d80 2
a81 2
	 * OpenBSD will lose on the 1240 support because you don't
	 * get multiple SCSI busses per adapter instance.
d83 1
a83 8
#if	0
	isp->isp_osinfo._link.channel = SCSI_CHANNEL_ONLY_ONE;
#endif
	isp->isp_osinfo._link.adapter_softc = isp;
	isp->isp_osinfo._link.device = &isp_dev;
	isp->isp_osinfo._link.adapter = &isp->isp_osinfo._adapter;
	isp->isp_osinfo._link.openings = isp->isp_maxcmds;
	isp->isp_osinfo.wqf = isp->isp_osinfo.wqt = NULL; /* XXX 2nd Bus? */
d85 4
d91 1
a91 1
		isp->isp_osinfo._link.adapter_buswidth = MAX_FC_TARG;
d97 1
a97 1
		isp->isp_osinfo._link.adapter_buswidth = MAX_TARGETS;
d99 1
a99 2
		isp->isp_osinfo._link.adapter_target =
			sdp->isp_initiator_id;
d101 12
d127 1
a127 1
		if (IS_12X0(isp)) {
d134 1
a134 1
		printf("%s: waiting 2 seconds for bus reset settling\n",
d136 1
a136 1
		delay(2 * 1000000);
d169 1
a169 1
		isp->isp_osinfo._link.adapter_target = fcp->isp_loopid;
d183 5
a187 1
	config_found((void *)isp, &isp->isp_osinfo._link, scsiprint);
d233 1
a233 1
	if (xs->sc_link->quirks & SDEV_NOSYNCWIDE) {
a234 1
		f ^= DPARM_WIDE;
d239 6
d264 1
a264 1
	isp->isp_update |= 1 << chan;
d324 1
d579 1
d585 1
a585 1
			if (sdp->isp_lvdmode) {
@


1.4
log
@Far too many things to note- a complete new revision coming in including
FABRIC support...
@
text
@d1 1
a1 1
/* 	$OpenBSD: isp_openbsd.c,v 1.3 1999/03/25 22:58:38 mjacob Exp $ */
a208 1
	sdp += chan;
d211 1
@


1.3
log
@roll internal revision levels and enable 1080 support
@
text
@d1 1
a1 2
/* 	$OpenBSD: isp_openbsd.c,v 1.2 1999/03/17 12:54:32 mjacob Exp $ */
/* release_03_25_99 */
d44 3
a46 3
 *  2339 3rd Street
 *  Suite 24
 *  San Francisco, CA, 94107
d52 1
d58 2
a65 4
#define	FC_OPENINGS	RQUEST_QUEUE_LEN / (MAX_FC_TARG-1)
#define	PI_OPENINGS	RQUEST_QUEUE_LEN / (MAX_TARGETS-1)
#define	DTHR		1

a72 1
	isp->isp_osinfo._adapter.scsi_cmd = ispcmd;
d86 2
d89 2
a90 2
	if (isp->isp_type & ISP_HA_FC) {
		isp->isp_osinfo._link.openings = FC_OPENINGS;
d93 1
a93 2
		isp->isp_osinfo._link.adapter_target =
			((fcparam *)isp->isp_param)->isp_loopid;
d95 2
a96 2
		isp->isp_osinfo.delay_throttle_count = DTHR;
		isp->isp_osinfo._link.openings = PI_OPENINGS;
d100 2
a101 1
			((sdparam *)isp->isp_param)->isp_initiator_id;
a102 2
	if (isp->isp_osinfo._link.openings < 2)
		isp->isp_osinfo._link.openings = 2;
d114 6
a119 1
		(void) isp_control(isp, ISPCTL_RESET_BUS, NULL);
d121 1
a121 1
		 * Wait for it to settle.
d123 2
d126 33
d164 1
a164 1
	 * The wathdog will, ridiculously enough, also enable Sync negotiation.
d196 81
a276 1
static int
d299 20
d322 17
a338 1
	if (result != CMD_QUEUED || (xs->flags & SCSI_POLL) == 0) {
d343 17
d361 1
a361 1
	 * If we can't use interrupts, poll on completion.
d363 13
a375 12
	if (isp_poll(isp, xs, xs->timeout)) {
		/*
		 * If no other error occurred but we didn't finish,
		 * something bad happened.
		 */
		if ((xs->flags & ITSDONE) == 0) {
			isp->isp_nactive--;
			if (isp->isp_nactive < 0)
				isp->isp_nactive = 0;
			if (xs->error == XS_NOERROR) {
				isp_lostcmd(isp, xs);
				xs->error = XS_DRIVER_STUFFUP;
d378 1
d381 1
a381 1
	return (COMPLETE);
d412 2
a413 2
	ISP_SCSI_XFER_T *xs;
	int s = splbio();
d416 1
a416 1
	 * Look for completely dead commands.
d418 3
a420 2
	for (i = 0; i < RQUEST_QUEUE_LEN; i++) {
		if ((xs = (ISP_SCSI_XFER_T *) isp->isp_xflist[i]) == NULL) {
d423 1
a423 1
		if (XS_TIME(xs) == 0) {
d426 2
a427 1
		XS_TIME(xs) -= (WATCH_INTERVAL * 1000);
a438 3
		if (IS_SCSI(isp)) {
			isp->isp_osinfo.delay_throttle_count = DTHR;
		}
d446 1
a446 13

	if (isp->isp_osinfo.delay_throttle_count) {
		if (--isp->isp_osinfo.delay_throttle_count == 0) {
			sdparam *sdp = isp->isp_param;
			for (i = 0; i < MAX_TARGETS; i++) {
				sdp->isp_devparam[i].dev_flags |=
					DPARM_WIDE|DPARM_SYNC|DPARM_TQING;
				sdp->isp_devparam[i].dev_update = 1;
			}
			isp->isp_update = 1;
		}
	}
	timeout(isp_watch, isp, WATCH_INTERVAL * hz);
d448 1
a448 1
	(void) splx(s);
d479 61
d546 1
d550 25
a574 27
		if (IS_SCSI(isp)) {
			sdparam *sdp = isp->isp_param;
			char *wt;
			int mhz, flags, tgt, period;

			tgt = *((int *) arg);

			flags = sdp->isp_devparam[tgt].cur_dflags;
			period = sdp->isp_devparam[tgt].cur_period;
			if ((flags & DPARM_SYNC) && period &&
			    (sdp->isp_devparam[tgt].cur_offset) != 0) {
				if (sdp->isp_lvdmode) {
					switch (period) {
					case 0xa:
						mhz = 40;
						break;
					case 0xb:
						mhz = 33;
						break;
					case 0xc:
						mhz = 25;
						break;
					default:
						mhz = 1000 / (period * 4);
						break;
					}
				} else {
d576 1
d579 1
a579 23
				mhz = 0;
			}
			switch (flags & (DPARM_WIDE|DPARM_TQING)) {
			case DPARM_WIDE:
				wt = ", 16 bit wide\n";
				break;
			case DPARM_TQING:
				wt = ", Tagged Queueing Enabled\n";
				break;
			case DPARM_WIDE|DPARM_TQING:
				wt = ", 16 bit wide, Tagged Queueing Enabled\n";
				break;
			default:
				wt = "\n";
				break;
			}
			if (mhz) {
				printf("%s: Target %d at %dMHz Max Offset %d%s",
				    isp->isp_name, tgt, mhz,
				    sdp->isp_devparam[tgt].cur_offset, wt);
			} else {
				printf("%s: Target %d Async Mode%s",
				    isp->isp_name, tgt, wt);
d581 24
d607 1
d609 5
a613 1
		printf("%s: SCSI bus reset detected\n", isp->isp_name);
d616 5
d623 3
a625 1
	case ISPASYNC_LOOP_UP:
d628 5
a632 5
	case ISPASYNC_PDB_CHANGE_COMPLETE:
#if	0
	if (isp->isp_type & ISP_HA_FC) {
		int i;
		static char *roles[4] = {
d635 53
a687 32
		for (i = 0; i < MAX_FC_TARG; i++)  {
			isp_pdb_t *pdbp =
			    &((fcparam *)isp->isp_param)->isp_pdb[i];
			if (pdbp->pdb_options == INVALID_PDB_OPTIONS)
				continue;
			printf("%s: Loop ID %d, %s role\n",
			    isp->isp_name, pdbp->pdb_loopid,
			    roles[(pdbp->pdb_prli_svc3 >> 4) & 0x3]);
			printf("     Node Address 0x%x WWN 0x"
			    "%02x%02x%02x%02x%02x%02x%02x%02x\n",
			    BITS2WORD(pdbp->pdb_portid_bits),
			    pdbp->pdb_portname[0], pdbp->pdb_portname[1],
			    pdbp->pdb_portname[2], pdbp->pdb_portname[3],
			    pdbp->pdb_portname[4], pdbp->pdb_portname[5],
			    pdbp->pdb_portname[6], pdbp->pdb_portname[7]);
			if (pdbp->pdb_options & PDB_OPTIONS_ADISC)
				printf("     Hard Address 0x%x WWN 0x"
				    "%02x%02x%02x%02x%02x%02x%02x%02x\n",
				    BITS2WORD(pdbp->pdb_hardaddr_bits),
				    pdbp->pdb_nodename[0],
				    pdbp->pdb_nodename[1],
				    pdbp->pdb_nodename[2],
				    pdbp->pdb_nodename[3],
				    pdbp->pdb_nodename[4],
				    pdbp->pdb_nodename[5],
				    pdbp->pdb_nodename[6],
				    pdbp->pdb_nodename[7]);
			switch (pdbp->pdb_prli_svc3 & SVC3_ROLE_MASK) {
			case SVC3_TGT_ROLE|SVC3_INI_ROLE:
				printf("     Master State=%s, Slave State=%s\n",
				    isp2100_pdb_statename(pdbp->pdb_mstate),
				    isp2100_pdb_statename(pdbp->pdb_sstate));
d689 7
a695 3
			case SVC3_TGT_ROLE:
				printf("     Master State=%s\n",
				    isp2100_pdb_statename(pdbp->pdb_mstate));
a696 7
			case SVC3_INI_ROLE:
				printf("     Slave State=%s\n",
				    isp2100_pdb_statename(pdbp->pdb_sstate));
				break;
			default:
				break;
			}
d698 7
a706 2
#else
		break;
a707 3
	case ISPASYNC_CHANGE_NOTIFY:
		printf("%s: Name Server Database Changed\n", isp->isp_name);
		break;
@


1.2
log
@fix OpenBSD headers
@
text
@d1 2
a2 2
/* 	$OpenBSD: isp_openbsd.c,v 1.1 1999/03/17 05:26:09 mjacob Exp $ */
/* release_03_16_99 */
d7 1
a7 1
 * Copyright (c) 1997, 1998, 1999 by Matthew Jacob
d66 1
d97 1
d130 1
a130 1
	timeout(isp_watch, isp, 30 * hz);
a232 1
#define	DTHR	2
a237 1
	static int delay_throttle_count = DTHR;
d265 3
a267 1
		delay_throttle_count = DTHR;
d276 2
a277 2
	if (delay_throttle_count) {
		if (--delay_throttle_count == 0) {
d332 1
a332 1
			int ns, flags, tgt;
d336 22
a357 3
			flags = sdp->isp_devparam[tgt].dev_flags;
			if (flags & DPARM_SYNC) {
				ns = sdp->isp_devparam[tgt].sync_period * 4;
d359 1
a359 1
				ns = 0;
d375 1
a375 1
			if (ns) {
d377 2
a378 2
				    isp->isp_name, tgt, 1000 / ns,
				    sdp->isp_devparam[tgt].sync_offset, wt);
@


1.1
log
@complete update of ISP driver- includes 2100 FC support
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
@

