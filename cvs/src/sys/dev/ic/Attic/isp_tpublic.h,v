head	1.13;
access;
symbols
	OPENBSD_5_3:1.12.0.16
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.14
	OPENBSD_5_0:1.12.0.10
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.8
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.6
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.8.0.14
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.13
date	2013.05.30.14.48.44;	author kurt;	state dead;
branches;
next	1.12;

1.12
date	2009.06.24.11.00.53;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.01.18.54.27;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.21.20.00.33;	author sobrado;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.04.21.13.37;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.03.18.35.45;	author mjacob;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.18.29.03;	author mjacob;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.09.01.07.16.40;	author mjacob;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.04.22.08.55;	author mjacob;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.06.05.31.48;	author mjacob;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.20.21.22.40;	author mjacob;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.02.21.22.29.05;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.05.14.22.23.56;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.31.03.22.42;	author nate;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.28.00.38.14;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.02.19.10.56.19;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2003.05.19.21.54.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@tedu unused header. okay krw@@
@
text
@/* $OpenBSD: isp_tpublic.h,v 1.12 2009/06/24 11:00:53 krw Exp $ */
/* $FreeBSD: src/sys/dev/isp/isp_tpublic.h,v 1.19 2007/05/05 20:17:23 mjacob Exp $ */
/*-
 *  Copyright (c) 1997-2007 by Matthew Jacob
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 * 
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 *  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 *  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE.
 */
/*
 * Host Adapter Public Target Interface Structures && Routines
 */

#ifndef    _ISP_TPUBLIC_H
#define    _ISP_TPUBLIC_H    1

/*
 * Action codes set by the MD target driver for
 * the external layer to figure out what to do with.
 */
typedef enum {
 	QOUT_HBA_REG=0,	/* the argument is a pointer to a hba_register_t */
 	QOUT_ENABLE,	/* the argument is a pointer to a enadis_t */
 	QOUT_DISABLE,	/* the argument is a pointer to a enadis_t */
 	QOUT_TMD_START,	/* the argument is a pointer to a tmd_cmd_t */
 	QOUT_TMD_DONE,	/* the argument is a pointer to a tmd_cmd_t */
 	QOUT_NOTIFY,	/* the argument is a pointer to a tmd_notify_t */
 	QOUT_HBA_UNREG	/* the argument is a pointer to a hba_register_t */
} tact_e;

/*
 * Action codes set by the external layer for the
 * MD driver to figure out what to do with.
 */
typedef enum {
	QIN_HBA_REG=99,	/* the argument is a pointer to a hba_register_t */
	QIN_GETINFO,	/* the argument is a pointer to a info_t */
	QIN_SETINFO,	/* the argument is a pointer to a info_t */
	QIN_GETDLIST,	/* the argument is a pointer to a fc_dlist_t */
	QIN_ENABLE,	/* the argument is a pointer to a enadis_t */
	QIN_DISABLE,	/* the argument is a pointer to a enadis_t */
	QIN_TMD_CONT,	/* the argument is a pointer to a tmd_cmd_t */
	QIN_TMD_FIN,	/* the argument is a pointer to a tmd_cmd_t */
	QIN_NOTIFY_ACK,	/* the argument is a pointer to a tmd_notify_t */
	QIN_HBA_UNREG	/* the argument is a pointer to a hba_register_t */
} qact_e;

/*
 * This structure is used to register to other software modules the
 * binding of an HBA identifier, driver name and instance and the
 * lun width capapbilities of this target driver. It's up to each
 * platform to figure out how it wants to do this, but a typical
 * sequence would be for the MD layer to find some external module's
 * entry point and start by sending a QOUT_HBA_REG with info filled
 * in, and the external module to call back with a QIN_HBA_REG that
 * passes back the corresponding information.
 */
#define    QR_VERSION    16
typedef struct {
    /* NB: tags from here to r_version must never change */
    void *                  r_identity;
    void                    (*r_action)(qact_e, void *);
    char                    r_name[8];
    int                     r_inst;
    int                     r_version;
    u_int32_t               r_locator;
    u_int32_t               r_nchannels;
    enum { R_FC, R_SPI }    r_type;
    void *                  r_private;
} hba_register_t;

/*
 * An information structure that is used to get or set per-channel transport layer parameters.
 */
typedef struct {
    void *                  i_identity;
    enum { I_FC, I_SPI }    i_type;
    int                     i_channel;
    int                     i_error;
    union {
        struct {
            u_int64_t    wwnn_nvram;
            u_int64_t    wwpn_nvram;
            u_int64_t    wwnn;
            u_int64_t    wwpn;
        } fc;
        struct {
            int         iid;
        } spi;
    }                       i_id;
} info_t;

/*
 * An information structure to return a list of logged in WWPNs. FC specific.
 */
typedef struct {
    void *                  d_identity;
    int                     d_channel;
    int                     d_error;
    int                     d_count;
    u_int64_t *             d_wwpns;
} fc_dlist_t;
/*
 * Notify structure
 */
typedef enum {
    NT_ABORT_TASK=0x1000,
    NT_ABORT_TASK_SET,
    NT_CLEAR_ACA,
    NT_CLEAR_TASK_SET,
    NT_LUN_RESET,
    NT_TARGET_RESET,
    NT_BUS_RESET,
    NT_LIP_RESET,
    NT_LINK_UP,
    NT_LINK_DOWN,
    NT_LOGOUT,
    NT_HBA_RESET
} tmd_ncode_t;

typedef struct tmd_notify {
    void *      nt_hba;         /* HBA tag */
    u_int64_t   nt_iid;         /* inititator id */
    u_int64_t   nt_tgt;         /* target id */
    u_int16_t   nt_lun;         /* logical unit */
    u_int16_t               : 15,
                nt_need_ack : 1;    /* this notify needs an ACK */
    u_int64_t   nt_tagval;      /* tag value */
    u_int32_t   nt_channel;     /* channel id */
    tmd_ncode_t nt_ncode;       /* action */
    void *      nt_lreserved;
    void *      nt_hreserved;
} tmd_notify_t;
#define LUN_ANY     0xffff
#define TGT_ANY     ((u_int64_t) -1)
#define INI_ANY     ((u_int64_t) -1)
#define TAG_ANY     ((u_int64_t) 0)
#define MATCH_TMD(tmd, iid, lun, tag)                   \
    (                                                   \
        (tmd) &&                                        \
        (iid == INI_ANY || iid == tmd->cd_iid) &&       \
        (lun == LUN_ANY || lun == tmd->cd_lun) &&       \
        (tag == TAG_ANY || tag == tmd->cd_tagval)       \
    )

/*
 * A word about ENABLE/DISABLE: the argument is a pointer to a enadis_t
 * with en_hba, en_iid, en_chan, en_tgt and en_lun filled out.
 *
 * If an error occurs in either enabling or disabling the described lun
 * cd_error is set with an appropriate non-zero value.
 */
typedef struct {
    void *          en_private;     /* for outer layer usage */
    void *          en_hba;         /* HBA tag */
    u_int64_t       en_iid;         /* initiator ID */
    u_int64_t       en_tgt;         /* target id */
    u_int16_t       en_lun;         /* logical unit */
    u_int16_t       en_chan;        /* channel on card */
    int             en_error;
} enadis_t;

/*
 * Suggested Software Target Mode Command Handling structure.
 *
 * A note about terminology:
 *
 *   MD stands for "Machine Dependent".
 *
 *    This driver is structured in three layers: Outer MD, core, and inner MD.
 *    The latter also is bus dependent (i.e., is cognizant of PCI bus issues
 *    as well as platform issues).
 *
 *
 *   "Outer Layer" means "Other Module"
 *
 *    Some additional module that actually implements SCSI target command
 *    policy is the recipient of incoming commands and the source of the
 *    disposition for them.
 *
 * The command structure below is one suggested possible MD command structure,
 * but since the handling of thbis is entirely in the MD layer, there is
 * no explicit or implicit requirement that it be used.
 *
 * The cd_private tag should be used by the MD layer to keep a free list
 * of these structures. Code outside of this driver can then use this
 * to identify it's own unit structures. That is, when not on the MD
 * layer's freelist, the MD layer should shove into it the identifier
 * that the outer layer has for it- passed in on an initial QIN_HBA_REG
 * call (see below).
 *
 * The cd_hba tag is a tag that uniquely identifies the HBA this target
 * mode command is coming from. The outer layer has to pass this back
 * unchanged to avoid chaos.
 *
 * The cd_iid, cd_tgt, cd_lun and cd_port tags are used to identify the
 * id of the initiator who sent us a command, the target claim to be, the
 * lun on the target we claim to be, and the port instance (for multiple
 * port host adapters) that this applies to (consider it an extra port
 * parameter). The iid, tgt and lun values are deliberately chosen to be
 * fat so that, for example, World Wide Names can be used instead of
 * the units that the firmware uses (in the case where the MD
 * layer maintains a port database, for example).
 *
 * The cd_tagtype field specifies what kind of command tag type, if
 * any, has been sent with the command. Note that the Outer Layer
 * still needs to pass the tag handle through unchanged even
 * if the tag type is CD_UNTAGGED.
 *
 * The cd_cdb contains storage for the passed in command descriptor block.
 * There is no need to define length as the callee should be able to
 * figure this out.
 *
 * The tag cd_lflags are the flags set by the MD driver when it gets
 * command incoming or when it needs to inform any outside entities
 * that the last requested action failed.
 *
 * The tag cd_hflags should be set by any outside software to indicate
 * the validity of sense and status fields (defined below) and to indicate
 * the direction data is expected to move. It is an error to have both
 * CDFH_DATA_IN and CDFH_DATA_OUT set.
 *
 * If the CDFH_STSVALID flag is set, the command should be completed (after
 * sending any data and/or status). If CDFH_SNSVALID is set and the MD layer
 * can also handle sending the associated sense data (either back with an
 * FCP RESPONSE IU for Fibre Channel or otherwise automatically handling a
 * REQUEST SENSE from the initator for this target/lun), the MD layer will
 * set the CDFL_SENTSENSE flag on successful transmission of the sense data.
 * It is an error for the CDFH_SNSVALID bit to be set and CDFH_STSVALID not
 * to be set. It is an error for the CDFH_SNSVALID be set and the associated
 * SCSI status (cd_scsi_status) not be set to CHECK CONDITON.
 * 
 * The tag cd_data points to a data segment to either be filled or
 * read from depending on the direction of data movement. The tag
 * is undefined if no data direction is set. The MD layer and outer
 * layers must agree on the meaning of cd_data and it is specifically
 * not defined here.
 *
 * The tag cd_totlen is the total data amount expected to be moved
 * over the life of the command. It may be set by the MD layer, possibly
 * from the datalen field of an FCP CMND IU unit. If it shows up in the outer
 * layers set to zero and the CDB indicates data should be moved, the outer
 * layer should set it to the amount expected to be moved.
 *
 * The tag cd_resid should be the total residual of data not transferred.
 * The outer layers need to set this at the beginning of command processing
 * to equal cd_totlen. As data is successfully moved, this value is decreased.
 * At the end of a command, any nonzero residual indicates the number of bytes
 * requested by the command but not moved.
 *
 * The tag cd_xfrlen is the length of the currently active data transfer.
 * This allows several interations between any outside software and the
 * MD layer to move data.
 *
 * The reason that total length and total residual have to be tracked
 * is to keep track of relative offset.
 *
 * The tags cd_sense and cd_scsi_status are pretty obvious.
 *
 * The tag cd_error is to communicate between the MD layer and outer software
 * the current error conditions.
 *
 * The tag cd_lreserved, cd_hreserved are scratch areas for use for the MD
 * and outer layers respectively.
 * 
 */

#ifndef    TMD_CDBLEN
#define    TMD_CDBLEN       16
#endif
#ifndef    TMD_SENSELEN
#define    TMD_SENSELEN     18
#endif
#ifndef    QCDS
#define    QCDS             (sizeof (void *))
#endif

typedef struct tmd_cmd {
	void *			cd_private;	/* private data pointer */
	void *			cd_hba;		/* HBA tag */
	void *			cd_data;	/* 'pointer' to data */
	u_int64_t		cd_iid;		/* initiator ID */
	u_int64_t		cd_tgt;		/* target id */
	u_int8_t		cd_lun[8];	/* logical unit */
	u_int64_t		cd_tagval;	/* tag value */
	u_int32_t		cd_channel;	/* channel index */
	u_int32_t		cd_lflags;	/* flags lower level sets */
	u_int32_t		cd_hflags;	/* flags higher level sets */
	u_int32_t		cd_totlen;	/* total data load */
	u_int32_t		cd_resid;	/* total data residual */
	u_int32_t		cd_xfrlen;	/* current data load */
	int32_t			cd_error;	/* current error */
	u_int8_t		cd_tagtype;	/* tag type */
	u_int8_t		cd_scsi_status;
	u_int8_t		cd_sense[TMD_SENSELEN];
	u_int8_t		cd_cdb[TMD_CDBLEN];
	union {
		void *		ptrs[QCDS / sizeof (void *)];
		u_int64_t	llongs[QCDS / sizeof (u_int64_t)];
		u_int32_t	longs[QCDS / sizeof (u_int32_t)];
		u_int16_t	shorts[QCDS / sizeof (u_int16_t)];
		u_int8_t	bytes[QCDS];
	} cd_lreserved[4], cd_hreserved[4];
} tmd_cmd_t;

/* defined tags */
#define CD_UNTAGGED     0
#define CD_SIMPLE_TAG   1
#define CD_ORDERED_TAG  2
#define CD_HEAD_TAG     3
#define CD_ACA_TAG      4

#ifndef    TMD_SIZE
#define    TMD_SIZE     (sizeof (tmd_cmd_t))
#endif

#define L0LUN_TO_FLATLUN(lptr)              ((((lptr)[0] & 0x3f) << 8) | ((lptr)[1]))
#define FLATLUN_TO_L0LUN(lptr, lun)                 \
    (lptr)[1] = lun & 0xff;                         \
    if (sizeof (lun) == 1) {                        \
        (lptr)[0] = 0;                              \
    } else {                                        \
        u_int16_t nl = lun;                         \
        if (nl == LUN_ANY) {                        \
            (lptr)[0] = (nl >> 8) & 0xff;           \
        } else if (nl < 256) {                      \
            (lptr)[0] = 0;                          \
        } else {                                    \
            (lptr)[0] = 0x40 | ((nl >> 8) & 0x3f);  \
        }                                           \
    }                                               \
    memset(&(lptr)[2], 0, 6)

/*
 * Note that NODISC (obviously) doesn't apply to non-SPI transport.
 *
 * Note that knowing the data direction and lengh at the time of receipt of
 * a command from the initiator is a feature only of Fibre Channel.
 *
 * The CDFL_BIDIR is in anticipation of the adoption of some newer
 * features required by OSD.
 *
 * The principle selector for MD layer to know whether data is to
 * be transferred in any QOUT_TMD_CONT call is cd_xfrlen- the
 * flags CDFH_DATA_IN and CDFH_DATA_OUT define which direction.
 */
#define	CDFL_SNSVALID	0x01	/* sense data (from f/w) good */
#define	CDFL_SENTSTATUS	0x02	/* last action sent status */
#define	CDFL_DATA_IN	0x04	/* target (us) -> initiator (them) */
#define CDFL_DATA_OUT	0x08	/* initiator (them) -> target (us) */
#define    CDFL_BIDIR           0x0C            /* bidirectional data */
#define    CDFL_ERROR           0x10            /* last action ended in error */
#define    CDFL_NODISC          0x20            /* disconnects disabled */
#define    CDFL_SENTSENSE       0x40            /* last action sent sense data */
#define    CDFL_BUSY            0x80            /* this command is not on a free list */
#define    CDFL_PRIVATE         0xFF000000      /* private layer flags */

#define    CDFH_SNSVALID        0x01            /* sense data (from outer layer) good */
#define    CDFH_STSVALID        0x02            /* status valid */
#define    CDFH_DATA_IN         0x04            /* target (us) -> initiator (them) */
#define    CDFH_DATA_OUT        0x08            /* initiator (them) -> target (us) */
#define    CDFH_DATA_MASK       0x0C            /* mask to cover data direction */
#define    CDFH_PRIVATE         0xFF000000      /* private layer flags */


/*
 * A word about the START/CONT/DONE/FIN dance:
 *
 *    When the HBA is enabled for receiving commands, one may show up
 *    without notice. When that happens, the MD target mode driver
 *    gets a tmd_cmd_t, fills it with the info that just arrived, and
 *    calls the outer layer with a QOUT_TMD_START code and pointer to
 *    the tmd_cmd_t.
 *
 *    The outer layer decodes the command, fetches data, prepares stuff,
 *    whatever, and starts by passing back the pointer with a QIN_TMD_CONT
 *    code which causes the MD target mode driver to generate CTIOs to
 *    satisfy whatever action needs to be taken. When those CTIOs complete,
 *    the MD target driver sends the pointer to the cmd_tmd_t back with
 *    a QOUT_TMD_DONE code. This repeats for as long as necessary. These
 *    may not be done in parallel- they are sequential operations.
 *
 *    The outer layer signals it wants to end the command by settings within
 *    the tmd_cmd_t itself. When the final QIN_TMD_CONT is reported completed,
 *    the outer layer frees the tmd_cmd_t by sending the pointer to it
 *    back with a QIN_TMD_FIN code.
 *
 *    The graph looks like:
 *
 *    QOUT_TMD_START -> [ QIN_TMD_CONT -> QOUT_TMD_DONE ] * -> QIN_TMD_FIN.
 *
 */

/*
 * Target handler functions.
 *
 * The MD target handler function (the outer layer calls this)
 * should be be prototyped like:
 *
 *    void target_action(qact_e, void *arg)
 *
 * The outer layer target handler function (the MD layer calls this)
 * should be be prototyped like:
 *
 *    void scsi_target_handler(tact_e, void *arg)
 */
#endif    /* _ISP_TPUBLIC_H */
/*
 * vim:ts=4:sw=4:expandtab
 */
@


1.12
log
@Major update to isp driver, mostly from mjacob via FreeBSD.

Everything that worked before should still work so in it goes. Newer
boards (2300, 2400) may now work but are still a work in progress.
Thanks to many testers but especially kettenis@@ for finding a show
stopper bug and stomping it.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.11 2008/11/01 18:54:27 krw Exp $ */
@


1.11
log
@Start updating isp. Just new defines, comments, whitespace, anything that
doesn't change the .o.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.10 2008/01/21 20:00:33 sobrado Exp $ */
d42 5
a46 4
	QOUT_TMD_START,	/* the argument is a pointer to a tmd_cmd_t */
	QOUT_TMD_DONE,	/* the argument is a pointer to a tmd_cmd_t */
	QOUT_TEVENT,	/* the argument is a pointer to a tmd_event_t */
	QOUT_TMSG,	/* the argument is a pointer to a tmd_msg_t */
d55 6
a60 3
	QIN_HBA_REG=6,	/* the argument is a pointer to a hba_register_t */
	QIN_ENABLE,	/* the argument is a pointer to a tmd_cmd_t */
	QIN_DISABLE,	/* the argument is a pointer to a tmd_cmd_t */
d63 1
a66 14
#ifndef	IN_MSGLEN
#define	IN_MSGLEN	8
#endif
typedef struct {
	void *		nt_hba;			/* HBA tag */
	u_int64_t	nt_iid;			/* initiator id */
	u_int64_t	nt_tgt;			/* target id */
	u_int64_t	nt_lun;			/* logical unit */
	u_int8_t	nt_bus;			/* bus */
	u_int8_t	nt_tagtype;		/* tag type */
	u_int16_t	nt_tagval;		/* tag value */
	u_int8_t	nt_msg[IN_MSGLEN];	/* message content */
} tmd_msg_t;

d79 10
a88 6
	void *	r_identity;
	char	r_name[8];
	int	r_inst;
	int	r_lunwidth;
	int	r_buswidth;
	void   (*r_action)(int, void *);
a90 6
typedef struct {
	void *		ev_hba;			/* HBA tag */
	u_int16_t	ev_bus;			/* bus */
	u_int16_t	ev_event;		/* type of async event */
} tmd_event_t;

a286 20
#ifndef	_LP64
#if	defined(__alpha__) || defined(__sparcv9cpu) || defined(__sparc_v9__) ||\
    defined(__ia64__)
#define	_LP64
#endif
#endif

#ifndef	_TMD_PAD_LEN
#ifdef	_LP64
#define	_TMD_PAD_LEN	12
#else
#define	_TMD_PAD_LEN	24
#endif
#endif
#ifndef	ATIO_CDBLEN
#define	ATIO_CDBLEN	26
#endif
#ifndef	QLTM_SENSELEN
#define	QLTM_SENSELEN	18
#endif
d303 6
a308 8
	u_int64_t		cd_lun;		/* logical unit */
	u_int8_t		cd_bus;		/* bus */
	u_int8_t		cd_tagtype;	/* tag type */
	u_int32_t		cd_tagval;	/* tag value */
	u_int8_t		cd_cdb[ATIO_CDBLEN];	/* Command */
	u_int8_t		cd_lflags;	/* flags lower level sets */
	u_int8_t		cd_hflags;	/* flags higher level sets */
	u_int32_t		cd_totlen;	/* total data requirement */
d312 11
a322 3
	u_int8_t		cd_sense[QLTM_SENSELEN];
	u_int16_t		cd_scsi_status;	/* closing SCSI status */
	u_int8_t		cd_reserved[_TMD_PAD_LEN];
d367 9
a375 8
#define	CDFL_NODISC	0x02	/* disconnects disabled */
#define	CDFL_SENTSENSE	0x04	/* last action sent sense data */
#define	CDFL_SENTSTATUS	0x08	/* last action sent status */
#define	CDFL_BIDIR      0x0C	/* bidirectional data */
#define	CDFL_ERROR	0x10	/* last action ended in error */
#define	CDFL_BUSY	0x40	/* this command is not on a free list */
#define	CDFL_PRIVATE_0	0x80	/* private layer flags */
	
a376 1
#define    CDFH_NODATA          0x00		/* no data transfer expected */
a381 1
#define    CDFH_PRIVATE_0       0x80            /* private layer flags */
@


1.10
log
@use the right capitalization for `QLogic'

ok jsing@@
@
text
@d1 28
a28 1
/* $OpenBSD: isp_tpublic.h,v 1.9 2007/04/10 17:47:55 miod Exp $ */
d30 1
a30 29
 * QLogic ISP Host Adapter Public Target Interface Structures && Routines
 *---------------------------------------
 * Copyright (c) 2000, 2001 by Matthew Jacob
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification, immediately at the beginning of the file.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * Matthew Jacob
 * Feral Software
 * mjacob@@feral.com
d33 3
d37 15
a51 4
 * Required software target mode message and event handling structures.
 *
 * The message and event structures are used by the MI layer
 * to propagate messages and events upstream.
d53 8
d76 20
d103 91
d217 1
a217 1
 * to identify its own unit structures. That is, when not on the MD
d226 1
a226 1
 * The cd_iid, cd_tgt, cd_lun and cd_bus tags are used to identify the
d228 2
a229 2
 * lun on the target we claim to be, and the bus instance (for multiple
 * bus host adapters) that this applies to (consider it an extra Port
d232 1
a232 1
 * the units that the QLogic firmware uses (in the case where the MD
d235 4
a238 9
 * The cd_tagtype field specifies what kind of command tag has been
 * sent with the command. The cd_tagval is the tag's value (low 16
 * bits). It also contains (in the upper 16 bits) any command handle.
 *
 *
 * N.B.: when the MD layer sends this command to outside software
 * the outside software likely *MUST* return the same cd_tagval that
 * was in place because this value is likely what the QLogic f/w uses
 * to identify a command.
d241 2
a242 3
 * This is the maximum size we can get out of the QLogic f/w. There's no
 * passed in length because whoever decodes the command to act upon it
 * will know what the appropriate length is.
d266 2
a267 1
 * layers must agree on the meaning of cd_data.
d270 1
a270 1
 * over the life of the command. It *may* be set by the MD layer, possibly
d279 1
a279 1
 * requested but not moved. XXXXXXXXXXXXXXXXXXXXXXX TOO VAGUE!!! 
d286 1
a286 15
 * is that fibre channel FCP DATA IU units have to have a relative
 * offset field.
 *
 * N.B.: there is no necessary 1-to-1 correspondence between any one
 * data transfer segment and the number of CTIOs that will be generated
 * satisfy the current data transfer segment. It's not also possible to
 * predict how big a transfer can be before it will be 'too big'. Be
 * reasonable- a 64KB transfer is 'reasonable'. A 1MB transfer may not
 * be. A 32MB transfer is unreasonable. The problem here has to do with
 * how CTIOs can be used to map passed data pointers. In systems which
 * have page based scatter-gather requirements, each PAGESIZEd chunk will
 * consume one data segment descriptor- you get 3 or 4 of them per CTIO.
 * The size of the REQUEST QUEUE you drop a CTIO onto is finite (typically
 * it's 256, but on some systems it's even smaller, and note you have to
 * sure this queue with the initiator side of this driver).
d293 3
a295 3
 * The tag cd_reserved pads out the structure to 128 bytes. The first
 * half of the pad area is reserved to the MD layer, and the second half
 * may be used by outer layers, for scratch purposes.
d318 10
d329 1
a329 1
	void *			cd_private;	/* layer private data */
d343 1
a343 1
	u_int32_t		cd_xfrlen;	/* current data requirement */
d350 27
a376 15
#define	CDFL_SNSVALID	0x01		/* sense data (from f/w) valid */
#define	CDFL_NODISC	0x02		/* disconnects disabled */
#define	CDFL_SENTSENSE	0x04		/* last action sent sense data */
#define	CDFL_SENTSTATUS	0x08		/* last action sent status */
#define	CDFL_ERROR	0x10		/* last action ended in error */
#define	CDFL_BUSY	0x40		/* this command is not on a free list */
#define	CDFL_PRIVATE_0	0x80		/* private layer flags */

#define	CDFH_SNSVALID	0x01		/* sense data valid */
#define	CDFH_STSVALID	0x02		/* status valid */
#define	CDFH_NODATA	0x00		/* no data transfer expected */
#define	CDFH_DATA_IN	0x04		/* target (us) -> initiator (them) */
#define	CDFH_DATA_OUT	0x08		/* initiator (them) -> target (us) */
#define	CDFH_DATA_MASK	0x0C		/* mask to cover data direction */
#define	CDFH_PRIVATE_0	0x80		/* private layer flags */
d379 11
a389 2
 * Action codes set by the QLogic MD target driver for
 * the external layer to figure out what to do with.
d391 18
a408 8
typedef enum {
	QOUT_HBA_REG=0,	/* the argument is a pointer to a hba_register_t */
	QOUT_TMD_START,	/* the argument is a pointer to a tmd_cmd_t */
	QOUT_TMD_DONE,	/* the argument is a pointer to a tmd_cmd_t */
	QOUT_TEVENT,	/* the argument is a pointer to a tmd_event_t */
	QOUT_TMSG,	/* the argument is a pointer to a tmd_msg_t */
	QOUT_HBA_UNREG	/* the argument is a pointer to a hba_register_t */
} tact_e;
a409 12
/*
 * Action codes set by the external layer for the
 * MD QLogic driver to figure out what to do with.
 */
typedef enum {
	QIN_HBA_REG=6,	/* the argument is a pointer to a hba_register_t */
	QIN_ENABLE,	/* the argument is a pointer to a tmd_cmd_t */
	QIN_DISABLE,	/* the argument is a pointer to a tmd_cmd_t */
	QIN_TMD_CONT,	/* the argument is a pointer to a tmd_cmd_t */
	QIN_TMD_FIN,	/* the argument is a pointer to a done tmd_cmd_t */
	QIN_HBA_UNREG	/* the argument is a pointer to a hba_register_t */
} qact_e;
d414 18
a431 17
 *	When the HBA is enabled for receiving commands, one may	show up
 *	without notice. When that happens, the QLogic target mode driver
 *	gets a tmd_cmd_t, fills it with the info that just arrived, and
 *	calls the outer layer with a QOUT_TMD_START code and pointer to
 *	the tmd_cmd_t.
 *
 *	The outer layer decodes the command, fetches data, prepares stuff,
 *	whatever, and starts by passing back the pointer with a QIN_TMD_CONT
 *	code which causes the QLogic target mode driver to generate CTIOs to
 *	satisfy whatever action needs to be taken. When those CTIOs complete,
 *	the QLogic target driver sends the pointer to the cmd_tmd_t back with
 *	a QOUT_TMD_DONE code. This repeats for as long as necessary.
 *
 *	The outer layer signals it wants to end the command by settings within
 *	the tmd_cmd_t itself. When the final QIN_TMD_CONT is reported completed,
 *	the outer layer frees the tmd_cmd_t by sending the pointer to it
 *	back with a QIN_TMD_FIN code.
d433 1
a433 1
 *	The graph looks like:
d435 1
a435 1
 *	QOUT_TMD_START -> [ QIN_TMD_CONT -> QOUT_TMD_DONE ] * -> QIN_TMD_FIN.
d440 1
a440 4
 * A word about ENABLE/DISABLE: the argument is a pointer to a tmd_cmd_t
 * with cd_hba, cd_bus, cd_tgt and cd_lun filled out. If an error occurs
 * in either enabling or disabling the described lun, cd_lflags is set
 * with CDFL_ERROR.
a441 5
 * Logical unit zero must be the first enabled and the last disabled.
 */

/*
 * Target handler functions.
d445 1
a445 1
 *	void target_action(qact_e, void *arg)
d450 1
a450 1
 *	void system_action(tact_e, void *arg)
d452 1
a452 1

d454 1
a454 8
 * This structure is used to register to other software modules the
 * binding of an HBA identifier, driver name and instance and the
 * lun width capabilities of this target driver. It's up to each
 * platform to figure out how it wants to do this, but a typical
 * sequence would be for the MD layer to find some external module's
 * entry point and start by sending a QOUT_HBA_REG with info filled
 * in, and the external module to call back with a QIN_HBA_REG that
 * passes back the corresponding information.
a455 8
typedef struct {
	void *	r_identity;
	char	r_name[8];
	int	r_inst;
	int	r_lunwidth;
	int	r_buswidth;
	void   (*r_action)(int, void *);
} hba_register_t;
@


1.9
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.8 2003/12/04 21:13:37 miod Exp $ */
d3 1
a3 1
 * Qlogic ISP Host Adapter Public Target Interface Structures && Routines
d100 1
a100 1
 * the units that the Qlogic firmware uses (in the case where the MD
d110 1
a110 1
 * was in place because this value is likely what the Qlogic f/w uses
d114 1
a114 1
 * This is the maximum size we can get out of the Qlogic f/w. There's no
d244 1
a244 1
 * Action codes set by the Qlogic MD target driver for
d258 1
a258 1
 * MD Qlogic driver to figure out what to do with.
d273 1
a273 1
 *	without notice. When that happens, the Qlogic target mode driver
d280 1
a280 1
 *	code which causes the Qlogic target mode driver to generate CTIOs to
d282 1
a282 1
 *	the Qlogic target driver sends the pointer to the cmd_tmd_t back with
@


1.8
log
@Typos
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.7 2003/10/21 18:58:49 jmc Exp $ */
d85 1
a85 1
 * to identify it's own unit structures. That is, when not on the MD
@


1.7
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.6 2003/03/03 18:35:45 mjacob Exp $ */
d46 1
a46 1
	u_int64_t	nt_iid;			/* inititator id */
@


1.6
log
@spelling fixes
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.5 2001/10/24 18:29:03 mjacob Exp $ */
d149 1
a149 1
 * The outer layers need to set this at the begining of command processing
d321 1
a321 1
 * lun width capapbilities of this target driver. It's up to each
@


1.5
log
@keep up with the joneses (track other OS)
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.4 2001/09/01 07:16:40 mjacob Exp $ */
d85 1
a85 1
 * as an to identify it's own unit structures. That is, when not on the MD
d297 1
a297 1
 * A word about ENABLE/DISABLE: the argument is a pointer to an tmd_cmd_t
@


1.5.2.1
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d85 1
a85 1
 * to identify it's own unit structures. That is, when not on the MD
d297 1
a297 1
 * A word about ENABLE/DISABLE: the argument is a pointer to a tmd_cmd_t
@


1.4
log
@Catch up with mainline of code development.

Add support for 2 Gigabit cards (2300/2312). This necessitated a change
in how interrupts are down- the 23XX has not only a different place to check
for an interrupt, but unlike all other QLogic cards, you have to read the
status as a 32 bit word- not 16 bit words. Rather than have device specific
functions as called from the core module (in isp_intr), it makes more sense
to have the platform/bus modules do the gruntwork of splitting out the
isr, semaphore register and the first outgoing mailbox register (if needed)
*prior* to calling isp_intr (if calling isp_intr is necessary at all).

Rearchitect how regular SCSI parameters are stored or used.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.3 2001/04/04 22:08:55 mjacob Exp $ */
d186 2
a187 1
#if	defined(__alpha__) || defined(__sparcv9cpu) || defined(__sparc_v9__)
@


1.3
log
@Keep up with the Joneses- sync up with core code for (eventual) usage here.
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.2 2000/07/06 05:31:48 mjacob Exp $ */
d226 1
a226 1
#define	CDFL_BUSY	0x01		/* this command is not on a free list */
d231 1
@


1.2
log
@Resync with FreeBSD/NetBSD. Salient features are that the mailbox command
routines are not necessarily polled now- this should cut down on some of
the spurious lost commands that have occurred. Also, we now watchdog each
command and make sure that command constipation doesn't occur (which it
has been documented to do on the QLA2100 cards).
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.1 2000/02/20 21:22:40 mjacob Exp $ */
d5 1
a5 1
 * Copyright (c) 2000 by Matthew Jacob
d104 3
a106 1
 * sent with the command. The cd_tagval is the tag's value.
d180 3
a182 1
 * The tag cd_reserved pads out the structure to 128 bytes.
d213 1
a213 1
	u_int16_t		cd_tagval;	/* tag value */
d273 1
a273 1
 *	calls the outer layer with a QIN_TMD_START code and pointer to
d332 1
a332 1
	void   (*r_action) __P((int, void *));
@


1.1
log
@Add 12160 (Ultra3) support. Add files and changes for target mode support.
Do some SNS fabric suppor tchanges. Roll revision levels. Tested on
GENERIC i386 && sparc.
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
d62 1
a62 1
 * Suggested software target mode command handling structure.
d64 18
a81 3
 * The command structure is one suggested possible MD command structure,
 * but since the handling of thbis is entirely in the MD layer, there
 * is no requirement that it be used.
d141 4
a144 5
 * over the life of the command. It may be set by the MD layer,
 * for example, from the datalen field of an FCP CMND IU unit. If
 * it shows up in the outer layers set to zero and the CDB indicates
 * data should be moved, the outer layer should set it to the amount
 * expected to be moved.
d150 1
a150 1
 * requested but not moved.
d223 1
a223 1
#define	CDFL_NODISC	0x02		/* disconnect not allowed */
d225 2
a226 1
#define	CDFL_ERROR	0x08		/* last action ended in error */
d256 2
d287 10
d327 1
@


1.1.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.1 2000/02/20 21:22:40 mjacob Exp $ */
@


1.1.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.3 2001/04/04 22:08:55 mjacob Exp $ */
d5 1
a5 1
 * Copyright (c) 2000, 2001 by Matthew Jacob
d62 1
a62 1
 * Suggested Software Target Mode Command Handling structure.
d64 3
a66 18
 * A note about terminology:
 *
 *   MD stands for "Machine Dependent".
 *
 *    This driver is structured in three layers: Outer MD, core, and inner MD.
 *    The latter also is bus dependent (i.e., is cognizant of PCI bus issues
 *    as well as platform issues).
 *
 *
 *   "Outer Layer" means "Other Module"
 *
 *    Some additional module that actually implements SCSI target command
 *    policy is the recipient of incoming commands and the source of the
 *    disposition for them.
 *
 * The command structure below is one suggested possible MD command structure,
 * but since the handling of thbis is entirely in the MD layer, there is
 * no explicit or implicit requirement that it be used.
d89 1
a89 3
 * sent with the command. The cd_tagval is the tag's value (low 16
 * bits). It also contains (in the upper 16 bits) any command handle.
 *
d126 5
a130 4
 * over the life of the command. It *may* be set by the MD layer, possibly
 * from the datalen field of an FCP CMND IU unit. If it shows up in the outer
 * layers set to zero and the CDB indicates data should be moved, the outer
 * layer should set it to the amount expected to be moved.
d136 1
a136 1
 * requested but not moved. XXXXXXXXXXXXXXXXXXXXXXX TOO VAGUE!!! 
d164 1
a164 3
 * The tag cd_reserved pads out the structure to 128 bytes. The first
 * half of the pad area is reserved to the MD layer, and the second half
 * may be used by outer layers, for scratch purposes.
d195 1
a195 1
	u_int32_t		cd_tagval;	/* tag value */
d209 1
a209 1
#define	CDFL_NODISC	0x02		/* disconnects disabled */
d211 1
a211 2
#define	CDFL_SENTSTATUS	0x08		/* last action sent status */
#define	CDFL_ERROR	0x10		/* last action ended in error */
a240 2
	QIN_ENABLE,	/* the argument is a pointer to a tmd_cmd_t */
	QIN_DISABLE,	/* the argument is a pointer to a tmd_cmd_t */
d252 1
a252 1
 *	calls the outer layer with a QOUT_TMD_START code and pointer to
a269 10
 *
 */

/*
 * A word about ENABLE/DISABLE: the argument is a pointer to an tmd_cmd_t
 * with cd_hba, cd_bus, cd_tgt and cd_lun filled out. If an error occurs
 * in either enabling or disabling the described lun, cd_lflags is set
 * with CDFL_ERROR.
 *
 * Logical unit zero must be the first enabled and the last disabled.
d300 1
a300 2
	int	r_buswidth;
	void   (*r_action)(int, void *);
@


1.1.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: isp_tpublic.h,v 1.1.2.2 2001/05/14 22:23:56 niklas Exp $ */
d186 1
a186 2
#if	defined(__alpha__) || defined(__sparcv9cpu) || defined(__sparc_v9__) ||\
    defined(__ia64__)
d226 1
a226 1
#define	CDFL_SNSVALID	0x01		/* sense data (from f/w) valid */
a230 1
#define	CDFL_BUSY	0x40		/* this command is not on a free list */
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d85 1
a85 1
 * to identify it's own unit structures. That is, when not on the MD
d297 1
a297 1
 * A word about ENABLE/DISABLE: the argument is a pointer to a tmd_cmd_t
@


1.1.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d46 1
a46 1
	u_int64_t	nt_iid;			/* initiator id */
d149 1
a149 1
 * The outer layers need to set this at the beginning of command processing
d321 1
a321 1
 * lun width capabilities of this target driver. It's up to each
@


